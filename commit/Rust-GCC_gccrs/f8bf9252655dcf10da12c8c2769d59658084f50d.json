{"sha": "f8bf9252655dcf10da12c8c2769d59658084f50d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhiZjkyNTI2NTVkY2YxMGRhMTJjOGMyNzY5ZDU5NjU4MDg0ZjUwZA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2008-09-02T16:31:04Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-09-02T16:31:04Z"}, "message": "backport: configure: Regenerate.\n\n2008-09-02  Sebastian Pop  <sebastian.pop@amd.com>\n\t    Tobias Grosser  <grosser@fim.uni-passau.de>\n\t    Jan Sjodin  <jan.sjodin@amd.com>\n\t    Harsha Jagasia  <harsha.jagasia@amd.com>\n\t    Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>\n\t    Konrad Trifunovic  <konrad.trifunovic@inria.fr>\n\t    Adrien Eliche  <aeliche@isty.uvsq.fr>\n\n\tMerge from graphite branch.\n\t* configure: Regenerate.\n\t* Makefile.in: Regenerate.\n\t* configure.ac (host_libs): Add ppl and cloog.\n\tAdd checks for PPL and CLooG.\n\t* Makefile.def (ppl, cloog): Added modules and dependences.\n\t* Makefile.tpl (PPLLIBS, PPLINC, CLOOGLIBS, CLOOGINC): New.\n\t(HOST_PPLLIBS, HOST_PPLINC, HOST_CLOOGLIBS, HOST_CLOOGINC): New.\n\ngcc/\n\t* graphite.c: New.\n\t* graphite.h: New.\n\t* tree-loop-linear.c (perfect_loop_nest_depth): Export.\n\t* doc/invoke.texi (-floop-block, -floop-interchange,\n\t-floop-strip-mine): Document new flags.\n\t* tree-into-ssa.c (gimple_vec): Moved...\n\t* tree-loop-distribution.c (rdg_component): Moved...\n\t* cfgloopmanip.c: Include tree-flow.h.\n\t(update_dominators_in_loop): New.\n\t(create_empty_if_region_on_edge): New.\n\t(create_empty_loop_on_edge): New.\n\t(loopify): Use update_dominators_in_loop.\n\t* tree-pass.h (pass_graphite_transforms): Declared.\n\t* configure: Regenerate.\n\t* tree-phinodes.c (make_phi_node): Export.\n\t(add_phi_node_to_bb): New, split from create_phi_node.\n\t* tree-chrec.c (for_each_scev_op): New.\n\t* tree-chrec.h (for_each_scev_op): Declared.\n\t* tree-ssa-loop-ivopts.c (get_phi_with_result): New.\n\t(remove_statement): Call get_phi_with_result.\n\t* config.in (HAVE_cloog): Undef.\n\t* gdbinit.in (pgg): New.\n\t* timevar.def (TV_GRAPHITE_TRANSFORMS): New.\n\t* tree-ssa-loop.c (graphite_transforms): New.\n\t(gate_graphite_transforms): New.\n\t(pass_graphite_transforms): New.\n\t* configure.ac (PPLLIBS, PPLINC, CLOOGLIBS, CLOOGINC,\n\tHAVE_cloog): Defined.\n\t* tree-vectorizer.c (rename_variables_in_bb): Export.\n\t* tree-data-ref.c (dr_may_alias_p): Export.\n\t(stmt_simple_memref_p): New.\n\t(find_data_references_in_stmt): Export.\n\t(find_data_references_in_loop): Export.\n\t(create_rdg_edge_for_ddr): Initialize RDGE_RELATION.\n\t(create_rdg_edges_for_scalar): Initialize RDGE_RELATION.\n\t(create_rdg_vertices): Export.\n\t(build_empty_rdg): New.\n\t(build_rdg): Call build_empty_rdg.  Free dependence_relations.\n\t* tree-data-ref.h (rdg_component): ... here.\n\t(scop_p): New.\n\t(struct data_reference): Add a field scop.\n\t(DR_SCOP): New.\n\t(find_data_references_in_loop): Declared.\n\t(find_data_references_in_stmt): Declared.\n\t(create_rdg_vertices): Declared.\n\t(dr_may_alias_p): Declared.\n\t(stmt_simple_memref_p): Declared.\n\t(struct rdg_edge): Add a field ddr_p relation.\n\t(build_empty_rdg): Declared.\n\t* lambda.h (lambda_matrix): Declare a VEC of.\n\t(find_induction_var_from_exit_cond): Declared.\n\t(lambda_vector_compare): New.\n\t* common.opt (fgraphite, floop-strip-mine,\n\tfloop-interchange, floop-block): New flags.\n\t* lambda-code.c (find_induction_var_from_exit_cond): Export.\n\t* cfgloop.c (is_loop_exit): New.\n\t* cfgloop.h (is_loop_exit): Declared.\n\t(create_empty_if_region_on_edge): Declared.\n\t(create_empty_loop_on_edge): Declared.\n\t* tree-flow.h (add_phi_node_to_bb): Declared.\n\t(make_phi_node): Declared.\n\t(rename_variables_in_bb): Declared.\n\t(perfect_loop_nest_depth): Declared.\n\t(graphite_transform_loops): Declared.\n\t* Makefile.in (cfgloopmanip.o): Depend on TREE_FLOW_H.\n\t(graphite.o-warn): Add -Wno-error.\n\t(PPLLIBS, PPLINC, CLOOGLIBS, CLOOGINC): Declared.\n\t(LIBS): Add GMPLIBS, CLOOGLIBS, PPLLIBS.\n\t(INCLUDES): Add PPLINC, CLOOGINC.\n\t(OBJS-common): Add graphite.o.\n\t(graphite.o): Add rule.\n\t* gimple.h (gimple_vec): ... here.\n\t* tree-cfg.c (print_loops): Start printing at ENTRY_BLOCK_PTR.\n\t* passes.c (init_optimization_passes): Schedule \n\tpass_graphite_transforms.\n\ntestsuite/\n\n\t* gcc.dg/graphite/scop-{0,1,2,3,4,5,6,7,8,9,\n\t10,11,12,13,14,15,16,17,18}.c: New.\n\t* gcc.dg/graphite/graphite.exp: New.\n\t* gcc.dg/graphite/scop-matmult.c: New.\n\t* gcc.dg/graphite/block-0.c: New.\n\t* lib/target-supports.exp (check_effective_target_fgraphite): New.\n\t* gfortran.dg/graphite/block-1.f90: New.\n\t* gfortran.dg/graphite/scop-{1,2}.f: New.\n\t* gfortran.dg/graphite/block-{1,3,4}.f90: New.\n\t* gfortran.dg/graphite/graphite.exp: New.\n\n\nCo-Authored-By: Adrien Eliche <aeliche@isty.uvsq.fr>\nCo-Authored-By: Dwarakanath Rajagopal <dwarak.rajagopal@amd.com>\nCo-Authored-By: Harsha Jagasia <harsha.jagasia@amd.com>\nCo-Authored-By: Jan Sjodin <jan.sjodin@amd.com>\nCo-Authored-By: Konrad Trifunovic <konrad.trifunovic@inria.fr>\nCo-Authored-By: Tobias Grosser <grosser@fim.uni-passau.de>\n\nFrom-SVN: r139893", "tree": {"sha": "1f3fd1f9608de8f06cfa843f8a480d295f0665d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f3fd1f9608de8f06cfa843f8a480d295f0665d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8bf9252655dcf10da12c8c2769d59658084f50d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8bf9252655dcf10da12c8c2769d59658084f50d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8bf9252655dcf10da12c8c2769d59658084f50d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8bf9252655dcf10da12c8c2769d59658084f50d/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57b08d04c67ff8db02f6b95e564432841384661b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57b08d04c67ff8db02f6b95e564432841384661b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57b08d04c67ff8db02f6b95e564432841384661b"}], "stats": {"total": 10604, "additions": 10002, "deletions": 602}, "files": [{"sha": "0840eb3d4bfcda1416645f5590e23a5647851ee7", "filename": "ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -1,3 +1,20 @@\n+2008-09-02  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Tobias Grosser  <grosser@fim.uni-passau.de>\n+\t    Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Harsha Jagasia  <harsha.jagasia@amd.com>\n+\t    Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>\n+\t    Konrad Trifunovic  <konrad.trifunovic@inria.fr>\n+\t    Adrien Eliche  <aeliche@isty.uvsq.fr>\n+\n+\tMerge from graphite branch.\n+\t* configure: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\t* configure.ac (host_libs): Add ppl and cloog.\n+\tAdd checks for PPL and CLooG.\n+\t* Makefile.def (ppl, cloog): Added modules and dependences.\n+\t* Makefile.tpl (PPLLIBS, PPLINC, CLOOGLIBS, CLOOGINC): New.\n+\t(HOST_PPLLIBS, HOST_PPLINC, HOST_CLOOGLIBS, HOST_CLOOGINC): New.\n+\n 2008-08-31  Aaron W. LaFramboise  <aaronavay62@aaronwl.com>\n \n \t* configure.ac (RPATH_ENVVAR): Use PATH on Windows."}, {"sha": "b5e38151e3add7d4b9b5056d635dfe9189380ffe", "filename": "Makefile.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -68,6 +68,16 @@ host_modules= { module= mpfr; lib_path=.libs; bootstrap=true;\n \t\tno_install= true; \n \t        host=\"none-${host_vendor}-${host_os}\";\n \t\ttarget=\"none-${host_vendor}-${host_os}\"; };\n+host_modules= { module= ppl; lib_path=.libs; bootstrap=true;\n+\t\textra_configure_flags='--disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/';\n+\t\tno_install= true; \n+\t        host=\"none-${host_vendor}-${host_os}\";\n+\t\ttarget=\"none-${host_vendor}-${host_os}\"; };\n+host_modules= { module= cloog; lib_path=.libs; bootstrap=true;\n+\t\textra_configure_flags='--disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-ppl=$$r/$(HOST_SUBDIR)/ppl/ --with-bits=gmp';\n+\t\tno_install= true; \n+\t        host=\"none-${host_vendor}-${host_os}\";\n+\t\ttarget=\"none-${host_vendor}-${host_os}\"; };\n host_modules= { module= gnuserv; };\n host_modules= { module= gold; bootstrap=true; };\n host_modules= { module= gprof; };\n@@ -295,6 +305,8 @@ dependencies = { module=all-gcc; on=all-libiberty; hard=true; };\n dependencies = { module=all-gcc; on=all-gmp; };\n dependencies = { module=all-gcc; on=all-intl; };\n dependencies = { module=all-gcc; on=all-mpfr; };\n+dependencies = { module=all-gcc; on=all-ppl; };\n+dependencies = { module=all-gcc; on=all-cloog; };\n dependencies = { module=all-gcc; on=all-build-texinfo; };\n dependencies = { module=all-gcc; on=all-build-bison; };\n dependencies = { module=all-gcc; on=all-build-byacc; };\n@@ -318,6 +330,9 @@ dependencies = { module=all-fixincludes; on=all-libiberty; };\n dependencies = { module=all-gnattools; on=all-target-libada; };\n \n dependencies = { module=configure-mpfr; on=all-gmp; };\n+dependencies = { module=configure-ppl; on=all-gmp; };\n+dependencies = { module=configure-ppl; on=all-mpfr; };\n+dependencies = { module=configure-cloog; on=all-ppl; };\n \n // Host modules specific to gdb.\n dependencies = { module=configure-gdb; on=all-intl; };"}, {"sha": "0f235fd740cf50096c66112c2c2bf91e9c9270af", "filename": "Makefile.in", "status": "modified", "additions": 2709, "deletions": 495, "changes": 3204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=f8bf9252655dcf10da12c8c2769d59658084f50d"}, {"sha": "f654fb3df56bc63049daa414467a1871f8385d5d", "filename": "Makefile.tpl", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -199,6 +199,10 @@ HOST_EXPORTS = \\\n \tTOPLEVEL_CONFIGURE_ARGUMENTS=\"$(TOPLEVEL_CONFIGURE_ARGUMENTS)\"; export TOPLEVEL_CONFIGURE_ARGUMENTS; \\\n \tGMPLIBS=\"$(HOST_GMPLIBS)\"; export GMPLIBS; \\\n \tGMPINC=\"$(HOST_GMPINC)\"; export GMPINC; \\\n+\tPPLLIBS=\"$(HOST_PPLLIBS)\"; export PPLLIBS; \\\n+\tPPLINC=\"$(HOST_PPLINC)\"; export PPLINC; \\\n+\tCLOOGLIBS=\"$(HOST_CLOOGLIBS)\"; export CLOOGLIBS; \\\n+\tCLOOGINC=\"$(HOST_CLOOGINC)\"; export CLOOGINC; \\\n @if gcc-bootstrap\n \t$(RPATH_ENVVAR)=`echo \"$(TARGET_LIB_PATH)$$$(RPATH_ENVVAR)\" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \\\n @endif gcc-bootstrap\n@@ -258,6 +262,14 @@ NORMAL_TARGET_EXPORTS = \\\n HOST_GMPLIBS = @gmplibs@\n HOST_GMPINC = @gmpinc@\n \n+# Where to find PPL\n+HOST_PPLLIBS = @ppllibs@\n+HOST_PPLINC = @pplinc@\n+\n+# Where to find CLOOG\n+HOST_CLOOGLIBS = @clooglibs@\n+HOST_CLOOGINC = @clooginc@\n+\n # ----------------------------------------------\n # Programs producing files for the BUILD machine\n # ----------------------------------------------"}, {"sha": "52718c2dd03ebd0c20dd09a31441b4ddd7674b66", "filename": "configure", "status": "modified", "additions": 227, "deletions": 2, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -272,7 +272,7 @@ PACKAGE_STRING=\n PACKAGE_BUGREPORT=\n \n ac_unique_file=\"move-if-change\"\n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS TOPLEVEL_CONFIGURE_ARGUMENTS build build_cpu build_vendor build_os build_noncanonical host_noncanonical target_noncanonical host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LN LN_S build_libsubdir build_subdir host_subdir target_subdir CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CXX CXXFLAGS ac_ct_CXX GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE do_compare gmplibs gmpinc stage1_languages SYSROOT_CFLAGS_FOR_TARGET DEBUG_PREFIX_CFLAGS_FOR_TARGET CFLAGS_FOR_TARGET CXXFLAGS_FOR_TARGET RPATH_ENVVAR GCC_SHLIB_SUBDIR tooldir build_tooldir CONFIGURE_GDB_TK GDB_TK INSTALL_GDB_TK build_configargs build_configdirs host_configargs configdirs target_configargs AR_FOR_BUILD AS_FOR_BUILD CC_FOR_BUILD CFLAGS_FOR_BUILD CXXFLAGS_FOR_BUILD CXX_FOR_BUILD DLLTOOL_FOR_BUILD GCJ_FOR_BUILD GFORTRAN_FOR_BUILD LDFLAGS_FOR_BUILD LD_FOR_BUILD NM_FOR_BUILD RANLIB_FOR_BUILD WINDMC_FOR_BUILD WINDRES_FOR_BUILD config_shell YACC BISON M4 LEX FLEX MAKEINFO EXPECT RUNTEST AR AS DLLTOOL LD LIPO NM RANLIB STRIP WINDRES WINDMC OBJCOPY OBJDUMP CC_FOR_TARGET CXX_FOR_TARGET GCC_FOR_TARGET GCJ_FOR_TARGET GFORTRAN_FOR_TARGET AR_FOR_TARGET AS_FOR_TARGET DLLTOOL_FOR_TARGET LD_FOR_TARGET LIPO_FOR_TARGET NM_FOR_TARGET OBJDUMP_FOR_TARGET RANLIB_FOR_TARGET STRIP_FOR_TARGET WINDRES_FOR_TARGET WINDMC_FOR_TARGET RAW_CXX_FOR_TARGET FLAGS_FOR_TARGET COMPILER_AS_FOR_TARGET COMPILER_LD_FOR_TARGET COMPILER_NM_FOR_TARGET MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT stage1_cflags stage1_checking stage2_werror_flag datarootdir docdir pdfdir htmldir LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS TOPLEVEL_CONFIGURE_ARGUMENTS build build_cpu build_vendor build_os build_noncanonical host_noncanonical target_noncanonical host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LN LN_S build_libsubdir build_subdir host_subdir target_subdir CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CXX CXXFLAGS ac_ct_CXX GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE do_compare gmplibs gmpinc ppllibs pplinc clooglibs clooginc stage1_languages SYSROOT_CFLAGS_FOR_TARGET DEBUG_PREFIX_CFLAGS_FOR_TARGET CFLAGS_FOR_TARGET CXXFLAGS_FOR_TARGET RPATH_ENVVAR GCC_SHLIB_SUBDIR tooldir build_tooldir CONFIGURE_GDB_TK GDB_TK INSTALL_GDB_TK build_configargs build_configdirs host_configargs configdirs target_configargs AR_FOR_BUILD AS_FOR_BUILD CC_FOR_BUILD CFLAGS_FOR_BUILD CXXFLAGS_FOR_BUILD CXX_FOR_BUILD DLLTOOL_FOR_BUILD GCJ_FOR_BUILD GFORTRAN_FOR_BUILD LDFLAGS_FOR_BUILD LD_FOR_BUILD NM_FOR_BUILD RANLIB_FOR_BUILD WINDMC_FOR_BUILD WINDRES_FOR_BUILD config_shell YACC BISON M4 LEX FLEX MAKEINFO EXPECT RUNTEST AR AS DLLTOOL LD LIPO NM RANLIB STRIP WINDRES WINDMC OBJCOPY OBJDUMP CC_FOR_TARGET CXX_FOR_TARGET GCC_FOR_TARGET GCJ_FOR_TARGET GFORTRAN_FOR_TARGET AR_FOR_TARGET AS_FOR_TARGET DLLTOOL_FOR_TARGET LD_FOR_TARGET LIPO_FOR_TARGET NM_FOR_TARGET OBJDUMP_FOR_TARGET RANLIB_FOR_TARGET STRIP_FOR_TARGET WINDRES_FOR_TARGET WINDMC_FOR_TARGET RAW_CXX_FOR_TARGET FLAGS_FOR_TARGET COMPILER_AS_FOR_TARGET COMPILER_LD_FOR_TARGET COMPILER_NM_FOR_TARGET MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT stage1_cflags stage1_checking stage2_werror_flag datarootdir docdir pdfdir htmldir LIBOBJS LTLIBOBJS'\n ac_subst_files='serialization_dependencies host_makefile_frag target_makefile_frag alphaieee_frag ospace_frag'\n ac_pwd=`pwd`\n \n@@ -967,6 +967,16 @@ Optional Packages:\n                           plus --with-gmp-lib=PATH/lib\n   --with-gmp-include=PATH specify directory for installed GMP include files\n   --with-gmp-lib=PATH     specify directory for the installed GMP library\n+  --with-ppl=PATH         Specify prefix directory for the installed PPL package\n+                          Equivalent to --with-ppl-include=PATH/include\n+                          plus --with-ppl-lib=PATH/lib\n+  --with-ppl-include=PATH Specify directory for installed PPL include files\n+  --with-ppl-lib=PATH     Specify the directory for the installed PPL library\n+  --with-cloog=PATH         Specify prefix directory for the installed CLOOG package\n+                          Equivalent to --with-cloog-include=PATH/include\n+                          plus --with-cloog-lib=PATH/lib\n+  --with-cloog-include=PATH Specify directory for installed CLOOG include files\n+  --with-cloog-lib=PATH     Specify the directory for the installed CLOOG library\n   --with-build-sysroot=SYSROOT\n                           use sysroot as the system root during the build\n   --with-debug-prefix-map='A=B C=D ...'\n@@ -1873,7 +1883,7 @@ build_tools=\"build-texinfo build-byacc build-flex build-bison build-m4 build-fix\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr\"\n+host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr ppl cloog\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -4791,6 +4801,217 @@ fi\n \n \n \n+\n+# Check for PPL\n+ppl_major_version=0\n+ppl_minor_version=10\n+ppllibs=\n+pplinc=\n+\n+\n+# Check whether --with-ppl or --without-ppl was given.\n+if test \"${with_ppl+set}\" = set; then\n+  withval=\"$with_ppl\"\n+\n+fi;\n+\n+# Check whether --with-ppl_include or --without-ppl_include was given.\n+if test \"${with_ppl_include+set}\" = set; then\n+  withval=\"$with_ppl_include\"\n+\n+fi;\n+\n+# Check whether --with-ppl_lib or --without-ppl_lib was given.\n+if test \"${with_ppl_lib+set}\" = set; then\n+  withval=\"$with_ppl_lib\"\n+\n+fi;\n+\n+if test \"x$with_ppl\" != x; then\n+  ppllibs=\"-L$with_ppl/lib -lppl_c -lppl -lgmpxx\"\n+  pplinc=\"-I$with_ppl/include $pplinc\"\n+  LIBS=\"$ppllibs $LIBS\"\n+fi\n+if test \"x$with_ppl_include\" != x; then\n+  pplinc=\"-I$with_ppl_include $pplinc\"\n+fi\n+if test \"x$with_ppl_lib\" != x; then\n+  ppllibs=\"-L$with_ppl_lib -lppl_c -lppl -lgmpxx\"\n+  LIBS=\"$ppllibs $LIBS\"\n+fi\n+if test \"x$with_ppl$with_ppl_include$with_ppl_lib\" = x && test -d ${srcdir}/ppl; then\n+  ppllibs='-L$$r/$(HOST_SUBDIR)/ppl/.libs -L$$r/$(HOST_SUBDIR)/ppl/_libs -lppl_c -lppl -lgmpxx '\n+  pplinc='-I$$r/$(HOST_SUBDIR)/ppl/include -I$$s/ppl/include '\n+  LIBS=\"$ppllibs $LIBS\"\n+fi\n+\n+# Flags needed for PPL\n+\n+\n+\n+\n+# Check for CLOOG\n+clooglibs=\n+clooginc=\n+\n+\n+# Check whether --with-cloog or --without-cloog was given.\n+if test \"${with_cloog+set}\" = set; then\n+  withval=\"$with_cloog\"\n+\n+fi;\n+\n+# Check whether --with-cloog_include or --without-cloog_include was given.\n+if test \"${with_cloog_include+set}\" = set; then\n+  withval=\"$with_cloog_include\"\n+\n+fi;\n+\n+# Check whether --with-cloog_lib or --without-cloog_lib was given.\n+if test \"${with_cloog_lib+set}\" = set; then\n+  withval=\"$with_cloog_lib\"\n+\n+fi;\n+\n+if test \"x$with_cloog\" != x; then\n+  clooglibs=\"-L$with_cloog/lib -lcloog\"\n+  clooginc=\"-I$with_cloog/include -DCLOOG_PPL_BACKEND \"\n+  LIBS=\"$clooglibs $LIBS\"\n+fi\n+if test \"x$with_cloog_include\" != x; then\n+  clooginc=\"-I$with_cloog_include -DCLOOG_PPL_BACKEND \"\n+fi\n+if test \"x$with_cloog_lib\" != x; then\n+  clooglibs=\"-L$with_cloog_lib -lcloog\"\n+  LIBS=\"$clooglibs $LIBS\"\n+fi\n+if test \"x$with_cloog$with_cloog_include$with_cloog_lib\" = x && test -d ${srcdir}/cloog; then\n+  clooglibs='-L$$r/$(HOST_SUBDIR)/cloog/.libs -L$$r/$(HOST_SUBDIR)/cloog/_libs -lcloog '\n+  clooginc='-I$$r/$(HOST_SUBDIR)/cloog/include -I$$s/cloog/include -DCLOOG_PPL_BACKEND '\n+  LIBS=\"$clooglibs $LIBS\"\n+fi\n+\n+saved_CFLAGS=\"$CFLAGS\"\n+CFLAGS=\"$CFLAGS $pplinc $gmpinc\"\n+\n+echo \"$as_me:$LINENO: checking for version $ppl_major_version.$ppl_minor_version of PPL\" >&5\n+echo $ECHO_N \"checking for version $ppl_major_version.$ppl_minor_version of PPL... $ECHO_C\" >&6\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include \"ppl_c.h\"\n+int\n+main ()\n+{\n+\n+#if PPL_VERSION_MAJOR != $ppl_major_version || PPL_VERSION_MINOR != $ppl_minor_version\n+choke me\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  echo \"$as_me:$LINENO: result: yes\" >&5\n+echo \"${ECHO_T}yes\" >&6\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+echo \"$as_me:$LINENO: result: no\" >&5\n+echo \"${ECHO_T}no\" >&6; clooglibs= ; clooginc=\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+CFLAGS=\"$saved_CFLAGS\"\n+\n+saved_CFLAGS=\"$CFLAGS\"\n+CFLAGS=\"$CFLAGS $clooginc $gmpinc $pplinc\"\n+\n+echo \"$as_me:$LINENO: checking for correct version of CLooG\" >&5\n+echo $ECHO_N \"checking for correct version of CLooG... $ECHO_C\" >&6\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include \"cloog/cloog.h\"\n+int\n+main ()\n+{\n+\n+#if CLOOG_VERSION_MAJOR != 0 || CLOOG_VERSION_MINOR != 15\n+choke me\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  echo \"$as_me:$LINENO: result: yes\" >&5\n+echo \"${ECHO_T}yes\" >&6\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+echo \"$as_me:$LINENO: result: no\" >&5\n+echo \"${ECHO_T}no\" >&6; clooglibs= ; clooginc=\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+CFLAGS=\"$saved_CFLAGS\"\n+\n+# Flags needed for CLOOG\n+\n+\n+\n+\n # By default, C is the only stage 1 language.\n stage1_languages=,c,\n \n@@ -12977,6 +13198,10 @@ s,@ac_ct_GNATMAKE@,$ac_ct_GNATMAKE,;t t\n s,@do_compare@,$do_compare,;t t\n s,@gmplibs@,$gmplibs,;t t\n s,@gmpinc@,$gmpinc,;t t\n+s,@ppllibs@,$ppllibs,;t t\n+s,@pplinc@,$pplinc,;t t\n+s,@clooglibs@,$clooglibs,;t t\n+s,@clooginc@,$clooginc,;t t\n s,@stage1_languages@,$stage1_languages,;t t\n s,@SYSROOT_CFLAGS_FOR_TARGET@,$SYSROOT_CFLAGS_FOR_TARGET,;t t\n s,@DEBUG_PREFIX_CFLAGS_FOR_TARGET@,$DEBUG_PREFIX_CFLAGS_FOR_TARGET,;t t"}, {"sha": "1e6e3742838430bb018f51bf5230e4651302dadc", "filename": "configure.ac", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -158,7 +158,7 @@ build_tools=\"build-texinfo build-byacc build-flex build-bison build-m4 build-fix\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr\"\n+host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr ppl cloog\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -1310,6 +1310,97 @@ fi\n AC_SUBST(gmplibs)\n AC_SUBST(gmpinc)\n \n+\n+# Check for PPL\n+ppl_major_version=0\n+ppl_minor_version=10\n+ppllibs=\n+pplinc=\n+\n+AC_ARG_WITH(ppl, [  --with-ppl=PATH         Specify prefix directory for the installed PPL package\n+                          Equivalent to --with-ppl-include=PATH/include\n+                          plus --with-ppl-lib=PATH/lib])\n+AC_ARG_WITH(ppl_include, [  --with-ppl-include=PATH Specify directory for installed PPL include files])\n+AC_ARG_WITH(ppl_lib, [  --with-ppl-lib=PATH     Specify the directory for the installed PPL library])\n+\n+if test \"x$with_ppl\" != x; then\n+  ppllibs=\"-L$with_ppl/lib -lppl_c -lppl -lgmpxx\"\n+  pplinc=\"-I$with_ppl/include $pplinc\"\n+  LIBS=\"$ppllibs $LIBS\"\n+fi\n+if test \"x$with_ppl_include\" != x; then\n+  pplinc=\"-I$with_ppl_include $pplinc\"\n+fi\n+if test \"x$with_ppl_lib\" != x; then\n+  ppllibs=\"-L$with_ppl_lib -lppl_c -lppl -lgmpxx\"\n+  LIBS=\"$ppllibs $LIBS\"\n+fi\n+if test \"x$with_ppl$with_ppl_include$with_ppl_lib\" = x && test -d ${srcdir}/ppl; then\n+  ppllibs='-L$$r/$(HOST_SUBDIR)/ppl/.libs -L$$r/$(HOST_SUBDIR)/ppl/_libs -lppl_c -lppl -lgmpxx '\n+  pplinc='-I$$r/$(HOST_SUBDIR)/ppl/include -I$$s/ppl/include '\n+  LIBS=\"$ppllibs $LIBS\"\n+fi\n+\n+# Flags needed for PPL\n+AC_SUBST(ppllibs)\n+AC_SUBST(pplinc)\n+\n+\n+# Check for CLOOG\n+clooglibs=\n+clooginc=\n+\n+AC_ARG_WITH(cloog, [  --with-cloog=PATH         Specify prefix directory for the installed CLOOG package\n+                          Equivalent to --with-cloog-include=PATH/include\n+                          plus --with-cloog-lib=PATH/lib])\n+AC_ARG_WITH(cloog_include, [  --with-cloog-include=PATH Specify directory for installed CLOOG include files])\n+AC_ARG_WITH(cloog_lib, [  --with-cloog-lib=PATH     Specify the directory for the installed CLOOG library])\n+\n+if test \"x$with_cloog\" != x; then\n+  clooglibs=\"-L$with_cloog/lib -lcloog\"\n+  clooginc=\"-I$with_cloog/include -DCLOOG_PPL_BACKEND \"\n+  LIBS=\"$clooglibs $LIBS\"\n+fi\n+if test \"x$with_cloog_include\" != x; then\n+  clooginc=\"-I$with_cloog_include -DCLOOG_PPL_BACKEND \"\n+fi\n+if test \"x$with_cloog_lib\" != x; then\n+  clooglibs=\"-L$with_cloog_lib -lcloog\"\n+  LIBS=\"$clooglibs $LIBS\"\n+fi\n+if test \"x$with_cloog$with_cloog_include$with_cloog_lib\" = x && test -d ${srcdir}/cloog; then\n+  clooglibs='-L$$r/$(HOST_SUBDIR)/cloog/.libs -L$$r/$(HOST_SUBDIR)/cloog/_libs -lcloog '\n+  clooginc='-I$$r/$(HOST_SUBDIR)/cloog/include -I$$s/cloog/include -DCLOOG_PPL_BACKEND '\n+  LIBS=\"$clooglibs $LIBS\"\n+fi\n+\n+saved_CFLAGS=\"$CFLAGS\"\n+CFLAGS=\"$CFLAGS $pplinc $gmpinc\"\n+\n+AC_MSG_CHECKING([for version $ppl_major_version.$ppl_minor_version of PPL])\n+AC_TRY_COMPILE([#include \"ppl_c.h\"],[\n+#if PPL_VERSION_MAJOR != $ppl_major_version || PPL_VERSION_MINOR != $ppl_minor_version\n+choke me\n+#endif\n+], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no]); clooglibs= ; clooginc= ])\n+CFLAGS=\"$saved_CFLAGS\"\n+\n+saved_CFLAGS=\"$CFLAGS\"\n+CFLAGS=\"$CFLAGS $clooginc $gmpinc $pplinc\"\n+\n+AC_MSG_CHECKING([for correct version of CLooG])\n+AC_TRY_COMPILE([#include \"cloog/cloog.h\"],[\n+#if CLOOG_VERSION_MAJOR != 0 || CLOOG_VERSION_MINOR != 15\n+choke me\n+#endif\n+], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no]); clooglibs= ; clooginc= ])\n+CFLAGS=\"$saved_CFLAGS\"\n+\n+# Flags needed for CLOOG\n+AC_SUBST(clooglibs)\n+AC_SUBST(clooginc)\n+\n+\n # By default, C is the only stage 1 language.\n stage1_languages=,c,\n "}, {"sha": "4a4bfc2f2caa17cff866dc2f687f9cee5e96052f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -183,6 +183,8 @@ dfp.o-warn = -Wno-error\n bitmap.o-warn = -Wno-error\n # dominance.c contains a -Wc++compat warning.\n dominance.o-warn = -Wno-error\n+# graphite.c contains code calling cloog that has problems.\n+graphite.o-warn = -Wno-error\n \n # All warnings have to be shut off in stage1 if the compiler used then\n # isn't gcc; configure determines that.  WARN_CFLAGS will be either\n@@ -281,6 +283,14 @@ ZLIBINC = @zlibinc@\n GMPLIBS = @GMPLIBS@\n GMPINC = @GMPINC@\n \n+# How to find PPL\n+PPLLIBS = @PPLLIBS@\n+PPLINC = @PPLINC@\n+\n+# How to find CLOOG\n+CLOOGLIBS = @CLOOGLIBS@\n+CLOOGINC = @CLOOGINC@\n+\n CPPLIB = ../libcpp/libcpp.a\n CPPINC = -I$(srcdir)/../libcpp/include\n \n@@ -891,7 +901,8 @@ BUILD_LIBDEPS= $(BUILD_LIBIBERTY)\n \n # How to link with both our special library facilities\n # and the system's installed libraries.\n-LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER)\n+LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER) \\\n+       $(GMPLIBS) $(CLOOGLIBS) $(PPLLIBS)\n \n # Any system libraries needed just for GNAT.\n SYSLIBS = @GNAT_LIBEXC@\n@@ -920,7 +931,8 @@ BUILD_ERRORS = build/errors.o\n # libintl.h will be found in ../intl if we are using the included libintl.\n INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \\\n \t   -I$(srcdir)/../include @INCINTL@ \\\n-\t   $(CPPINC) $(GMPINC) $(DECNUMINC)\n+\t   $(CPPINC) $(GMPINC) $(DECNUMINC) \\\n+\t   $(PPLINC) $(CLOOGINC)\n \n .c.o:\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)\n@@ -1094,6 +1106,7 @@ OBJS-common = \\\n \tglobal.o \\\n \tgraph.o \\\n \tgraphds.o \\\n+\tgraphite.o \\\n \tgtype-desc.o \\\n \thaifa-sched.o \\\n \thooks.o \\\n@@ -2340,6 +2353,10 @@ tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    $(TREE_DATA_REF_H) $(SCEV_H) tree-pass.h tree-chrec.h langhooks.h\n+graphite.o: graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) domwalk.h \\\n+   $(TREE_DATA_REF_H) $(SCEV_H) tree-pass.h tree-chrec.h graphite.h pointer-set.h\n tree-vect-analyze.o: tree-vect-analyze.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RECOG_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\"}, {"sha": "f6fe6239886971cfaac53970bfa0d779731654f8", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -1620,3 +1620,18 @@ single_exit (const struct loop *loop)\n   else\n     return NULL;\n }\n+\n+/* Returns true when BB has an edge exiting LOOP.  */\n+\n+bool\n+is_loop_exit (struct loop *loop, basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (loop_exit_edge_p (loop, e))\n+      return true;\n+\n+  return false;\n+}"}, {"sha": "37bf9937bfafeed35b488f00bb21a54230412707", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -228,6 +228,7 @@ extern int num_loop_insns (const struct loop *);\n extern int average_num_loop_insns (const struct loop *);\n extern unsigned get_loop_level (const struct loop *);\n extern bool loop_exit_edge_p (const struct loop *, const_edge);\n+extern bool is_loop_exit (struct loop *, basic_block);\n extern void mark_loop_exit_edges (void);\n \n /* Loops & cfg manipulation.  */\n@@ -284,6 +285,9 @@ extern bool can_duplicate_loop_p (const struct loop *loop);\n #define DLTHE_FLAG_COMPLETTE_PEEL 4\t/* Update frequencies expecting\n \t\t\t\t\t   a complete peeling.  */\n \n+extern edge create_empty_if_region_on_edge (edge, tree);\n+extern struct loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n+\t\t\t\t\t       tree *, struct loop *);\n extern struct loop * duplicate_loop (struct loop *, struct loop *);\n extern bool duplicate_loop_to_header_edge (struct loop *, edge, \n \t\t\t\t\t   unsigned, sbitmap, edge,"}, {"sha": "d8979b44f4a0151b544a11f9a3ecbe99065ceee5", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 239, "deletions": 33, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfglayout.h\"\n #include \"cfghooks.h\"\n #include \"output.h\"\n+#include \"tree-flow.h\"\n \n static void duplicate_subloops (struct loop *, struct loop *);\n static void copy_loops_to (struct loop **, int,\n@@ -466,6 +467,243 @@ scale_loop_frequencies (struct loop *loop, int num, int den)\n   free (bbs);\n }\n \n+/* Recompute dominance information for basic blocks outside LOOP.  */\n+\n+static void\n+update_dominators_in_loop (struct loop *loop)\n+{\n+  VEC (basic_block, heap) *dom_bbs = NULL;\n+  sbitmap seen;\n+  basic_block *body;\n+  unsigned i;\n+\n+  seen = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (seen);\n+  body = get_loop_body (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    SET_BIT (seen, body[i]->index);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block ldom;\n+\n+      for (ldom = first_dom_son (CDI_DOMINATORS, body[i]);\n+\t   ldom;\n+\t   ldom = next_dom_son (CDI_DOMINATORS, ldom))\n+\tif (!TEST_BIT (seen, ldom->index))\n+\t  {\n+\t    SET_BIT (seen, ldom->index);\n+\t    VEC_safe_push (basic_block, heap, dom_bbs, ldom);\n+\t  }\n+    }\n+\n+  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, false);\n+  free (body);\n+  free (seen);\n+  VEC_free (basic_block, heap, dom_bbs);\n+}\n+\n+/* Creates an if region as shown above. CONDITION is used to create\n+   the test for the if. \n+\n+   |\n+   |     -------------                 -------------\n+   |     |  pred_bb  |                 |  pred_bb  |\n+   |     -------------                 -------------\n+   |           |                             |\n+   |           |                             | ENTRY_EDGE\n+   |           | ENTRY_EDGE                  V\n+   |           |             ====>     -------------\n+   |           |                       |  cond_bb  |\n+   |           |                       | CONDITION |\n+   |           |                       -------------\n+   |           V                        /         \\\n+   |     -------------         e_false /           \\ e_true\n+   |     |  succ_bb  |                V             V\n+   |     -------------         -----------       -----------\n+   |                           | false_bb |      | true_bb |\n+   |                           -----------       -----------\n+   |                                   \\           /\n+   |                                    \\         /\n+   |                                     V       V\n+   |                                   -------------\n+   |                                   |  join_bb  |\n+   |                                   -------------\n+   |                                         | exit_edge (result)\n+   |                                         V\n+   |                                    -----------\n+   |                                    | succ_bb |\n+   |                                    -----------\n+   |\n+ */\n+\n+edge\n+create_empty_if_region_on_edge (edge entry_edge, tree condition)\n+{\n+\n+  basic_block succ_bb, cond_bb, true_bb, false_bb, join_bb;\n+  edge e_true, e_false, exit_edge;\n+  gimple cond_stmt;\n+  tree simple_cond;\n+  gimple_stmt_iterator gsi;\n+\n+  succ_bb = entry_edge->dest;\n+  cond_bb = split_edge (entry_edge);\n+  \n+  /* Insert condition in cond_bb.  */\n+  gsi = gsi_last_bb (cond_bb);\n+  simple_cond =\n+    force_gimple_operand_gsi (&gsi, condition, true, NULL,\n+\t\t\t      false, GSI_NEW_STMT);\n+  cond_stmt = gimple_build_cond_from_tree (simple_cond, NULL_TREE, NULL_TREE);\n+  gsi = gsi_last_bb (cond_bb);\n+  gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n+  \n+  join_bb = split_edge (single_succ_edge (cond_bb));\n+\n+  e_true = single_succ_edge (cond_bb);\n+  true_bb = split_edge (e_true);\n+\n+  e_false = make_edge (cond_bb, join_bb, 0);\n+  false_bb = split_edge (e_false);\n+\n+  e_true->flags &= ~EDGE_FALLTHRU;\n+  e_true->flags |= EDGE_TRUE_VALUE;\n+  e_false->flags &= ~EDGE_FALLTHRU;\n+  e_false->flags |= EDGE_FALSE_VALUE;\n+\n+  set_immediate_dominator (CDI_DOMINATORS, cond_bb, entry_edge->src);\n+  set_immediate_dominator (CDI_DOMINATORS, true_bb, cond_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, false_bb, cond_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);\n+\n+  exit_edge = single_succ_edge (join_bb);\n+\n+  if (single_pred_p (exit_edge->dest))\n+    set_immediate_dominator (CDI_DOMINATORS, exit_edge->dest, join_bb);\n+\n+  return exit_edge;\n+}\n+\n+/* create_empty_loop_on_edge\n+   |\n+   |     -------------                 ------------------------\n+   |     |  pred_bb  |                 |  pred_bb              |\n+   |     -------------                 |  IV_0 = INITIAL_VALUE |\n+   |           |                       ------------------------\n+   |           |                       ______    | ENTRY_EDGE\n+   |           | ENTRY_EDGE           /      V   V\n+   |           |             ====>   |     -----------------------------\n+   |           |                     |     | IV_BEFORE = phi (IV_0, IV) |\n+   |           |                     |     | loop_header                |\n+   |           V                     |     | IV_BEFORE <= UPPER_BOUND   |\n+   |     -------------               |     -----------------------\\-----\n+   |     |  succ_bb  |               |         |                   \\\n+   |     -------------               |         |                    \\ exit_e\n+   |                                 |         V                     V---------\n+   |                                 |      --------------           | succ_bb |\n+   |                                 |      | loop_latch  |          ----------\n+   |                                 |      |IV = IV_BEFORE + STRIDE\n+   |                                 |      --------------\n+   |                                  \\       /\n+   |                                   \\ ___ /\n+\n+   Creates an empty loop as shown above, the IV_BEFORE is the SSA_NAME\n+   that is used before the increment of IV. IV_BEFORE should be used for \n+   adding code to the body that uses the IV.  OUTER is the outer loop in\n+   which the new loop should be inserted.  */\n+\n+struct loop *\n+create_empty_loop_on_edge (edge entry_edge, \n+\t\t\t   tree initial_value,\n+\t\t\t   tree stride, tree upper_bound,\n+\t\t\t   tree iv,\n+\t\t\t   tree *iv_before,\n+\t\t\t   struct loop *outer)\n+{\n+  basic_block loop_header, loop_latch, succ_bb, pred_bb;\n+  struct loop *loop;\n+  int freq;\n+  gcov_type cnt;\n+  gimple_stmt_iterator gsi;\n+  bool insert_after;\n+  gimple_seq stmts;\n+  gimple cond_expr;\n+  tree exit_test;\n+  edge exit_e;\n+  int prob;\n+  tree upper_bound_gimplified;\n+  \n+  gcc_assert (entry_edge && initial_value && stride && upper_bound && iv);\n+\n+  /* Create header, latch and wire up the loop.  */\n+  pred_bb = entry_edge->src;\n+  loop_header = split_edge (entry_edge);\n+  loop_latch = split_edge (single_succ_edge (loop_header));\n+  succ_bb = single_succ (loop_latch);\n+  make_edge (loop_header, succ_bb, 0);\n+  redirect_edge_succ_nodup (single_succ_edge (loop_latch), loop_header);\n+\n+  /* Set immediate dominator information.  */\n+  set_immediate_dominator (CDI_DOMINATORS, loop_header, pred_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, loop_latch, loop_header);\n+  set_immediate_dominator (CDI_DOMINATORS, succ_bb, loop_header);\n+\n+  /* Initialize a loop structure and put it in a loop hierarchy.  */\n+  loop = alloc_loop ();\n+  loop->header = loop_header;\n+  loop->latch = loop_latch;\n+  add_loop (loop, outer);\n+\n+  /* TODO: Fix frequencies and counts.  */\n+  freq = EDGE_FREQUENCY (entry_edge);\n+  cnt = entry_edge->count;\n+\n+  prob = REG_BR_PROB_BASE / 2;\n+\n+  scale_loop_frequencies (loop, REG_BR_PROB_BASE - prob, REG_BR_PROB_BASE);\n+\n+  /* Update dominators.  */\n+  update_dominators_in_loop (loop);\n+\n+  /* Construct IV code in loop.  */\n+  initial_value = force_gimple_operand (initial_value, &stmts, true, iv);\n+  if (stmts)\n+    {\n+      gsi_insert_seq_on_edge (loop_preheader_edge (loop), stmts);\n+      gsi_commit_edge_inserts ();\n+    }\n+\n+  standard_iv_increment_position (loop, &gsi, &insert_after);\n+  create_iv (initial_value, stride, iv, loop, &gsi, insert_after,\n+\t     iv_before, NULL);\n+\n+  /* Modify edge flags.  */\n+  exit_e = single_exit (loop);\n+  exit_e->flags = EDGE_LOOP_EXIT | EDGE_FALSE_VALUE;\n+  single_pred_edge (loop_latch)->flags = EDGE_TRUE_VALUE;\n+\n+  gsi = gsi_last_bb (exit_e->src);\n+\n+  upper_bound_gimplified = \n+    force_gimple_operand_gsi (&gsi, upper_bound, true, NULL,\n+\t\t\t      false, GSI_NEW_STMT);\n+  gsi = gsi_last_bb (exit_e->src);\n+  \n+  cond_expr = gimple_build_cond \n+    (LE_EXPR, *iv_before, upper_bound_gimplified, NULL_TREE, NULL_TREE);\n+\n+  exit_test = gimple_cond_lhs (cond_expr);\n+  exit_test = force_gimple_operand_gsi (&gsi, exit_test, true, NULL,\n+\t\t\t\t\tfalse, GSI_NEW_STMT);\n+  gimple_cond_set_lhs (cond_expr, exit_test);\n+  gsi = gsi_last_bb (exit_e->src);\n+  gsi_insert_after (&gsi, cond_expr, GSI_NEW_STMT);\n+\n+  return loop;\n+}\n+\n /* Make area between HEADER_EDGE and LATCH_EDGE a loop by connecting\n    latch to header and update loop tree and dominators\n    accordingly. Everything between them plus LATCH_EDGE destination must\n@@ -483,10 +721,6 @@ loopify (edge latch_edge, edge header_edge,\n {\n   basic_block succ_bb = latch_edge->dest;\n   basic_block pred_bb = header_edge->src;\n-  basic_block *body;\n-  VEC (basic_block, heap) *dom_bbs;\n-  unsigned i;\n-  sbitmap seen;\n   struct loop *loop = alloc_loop ();\n   struct loop *outer = loop_outer (succ_bb->loop_father);\n   int freq;\n@@ -538,35 +772,7 @@ loopify (edge latch_edge, edge header_edge,\n     }\n   scale_loop_frequencies (loop, false_scale, REG_BR_PROB_BASE);\n   scale_loop_frequencies (succ_bb->loop_father, true_scale, REG_BR_PROB_BASE);\n-\n-  /* Update dominators of blocks outside of LOOP.  */\n-  dom_bbs = NULL;\n-  seen = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (seen);\n-  body = get_loop_body (loop);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    SET_BIT (seen, body[i]->index);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      basic_block ldom;\n-\n-      for (ldom = first_dom_son (CDI_DOMINATORS, body[i]);\n-\t   ldom;\n-\t   ldom = next_dom_son (CDI_DOMINATORS, ldom))\n-\tif (!TEST_BIT (seen, ldom->index))\n-\t  {\n-\t    SET_BIT (seen, ldom->index);\n-\t    VEC_safe_push (basic_block, heap, dom_bbs, ldom);\n-\t  }\n-    }\n-\n-  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, false);\n-\n-  free (body);\n-  free (seen);\n-  VEC_free (basic_block, heap, dom_bbs);\n+  update_dominators_in_loop (loop);\n \n   return loop;\n }"}, {"sha": "e7f8159a1613ab158542978423a7d20f07ecf3ab", "filename": "gcc/common.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -547,6 +547,22 @@ Common Report Var(flag_gcse_after_reload) Optimization\n Perform global common subexpression elimination after register allocation\n has finished\n \n+fgraphite\n+Common Report Var(flag_graphite)\n+Enable in and out of Graphite representation\n+\n+floop-strip-mine\n+Common Report Var(flag_loop_strip_mine) Optimization\n+Enable Loop Strip Mining transformation\n+\n+floop-interchange\n+Common Report Var(flag_loop_interchange) Optimization\n+Enable Loop Interchange transformation\n+\n+floop-block\n+Common Report Var(flag_loop_block) Optimization\n+Enable Loop Blocking transformation\n+\n fguess-branch-probability\n Common Report Var(flag_guess_branch_prob) Optimization\n Enable guessing of branch probabilities"}, {"sha": "17bdeb44ae6f7d4db879a9e46a89fb5f8acc7093", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -1327,6 +1327,12 @@\n #endif\n \n \n+/* Define if cloog is in use. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_cloog\n+#endif\n+\n+\n /* Define as const if the declaration of iconv() needs const. */\n #ifndef USED_FOR_TARGET\n #undef ICONV_CONST"}, {"sha": "aff51d69fcfa2b1ffe30dee83c40b0ad77740b29", "filename": "gcc/configure", "status": "modified", "additions": 55, "deletions": 15, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -458,7 +458,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP EGREP loose_warn strict_warn warn_cflags nocommon_flag TREEBROWSER valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_decimal_float enable_fixed_point enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI datarootdir docdir htmldir SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LTLIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file extra_opt_files USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS BUILD_LDFLAGS STMP_FIXINC STMP_FIXPROTO collect2 LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN ac_ct_AR STRIP ac_ct_STRIP lt_ECHO objdir enable_fast_install gcc_cv_as ORIGINAL_AS_FOR_TARGET gcc_cv_ld ORIGINAL_LD_FOR_TARGET gcc_cv_nm ORIGINAL_NM_FOR_TARGET gcc_cv_objdump libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir subdirs srcdir all_compilers all_gtfiles all_lang_makefrags all_lang_makefiles all_languages all_selected_languages build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines build_file_translate check_languages cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines c_target_objs cxx_target_objs fortran_target_objs target_cpu_default GMPLIBS GMPINC LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP EGREP loose_warn strict_warn warn_cflags nocommon_flag TREEBROWSER valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_decimal_float enable_fixed_point enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI datarootdir docdir htmldir SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LTLIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file extra_opt_files USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS BUILD_LDFLAGS STMP_FIXINC STMP_FIXPROTO collect2 LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN ac_ct_AR STRIP ac_ct_STRIP lt_ECHO objdir enable_fast_install gcc_cv_as ORIGINAL_AS_FOR_TARGET gcc_cv_ld ORIGINAL_LD_FOR_TARGET gcc_cv_nm ORIGINAL_NM_FOR_TARGET gcc_cv_objdump libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir subdirs srcdir all_compilers all_gtfiles all_lang_makefrags all_lang_makefiles all_languages all_selected_languages build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines build_file_translate check_languages cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines c_target_objs cxx_target_objs fortran_target_objs target_cpu_default GMPLIBS GMPINC PPLLIBS PPLINC CLOOGLIBS CLOOGINC GRAPHITE LIBOBJS LTLIBOBJS'\n ac_subst_files='language_hooks'\n ac_pwd=`pwd`\n \n@@ -928,6 +928,22 @@ ac_env_GMPINC_set=${GMPINC+set}\n ac_env_GMPINC_value=$GMPINC\n ac_cv_env_GMPINC_set=${GMPINC+set}\n ac_cv_env_GMPINC_value=$GMPINC\n+ac_env_PPLLIBS_set=${PPLLIBS+set}\n+ac_env_PPLLIBS_value=$PPLLIBS\n+ac_cv_env_PPLLIBS_set=${PPLLIBS+set}\n+ac_cv_env_PPLLIBS_value=$PPLLIBS\n+ac_env_PPLINC_set=${PPLINC+set}\n+ac_env_PPLINC_value=$PPLINC\n+ac_cv_env_PPLINC_set=${PPLINC+set}\n+ac_cv_env_PPLINC_value=$PPLINC\n+ac_env_CLOOGLIBS_set=${CLOOGLIBS+set}\n+ac_env_CLOOGLIBS_value=$CLOOGLIBS\n+ac_cv_env_CLOOGLIBS_set=${CLOOGLIBS+set}\n+ac_cv_env_CLOOGLIBS_value=$CLOOGLIBS\n+ac_env_CLOOGINC_set=${CLOOGINC+set}\n+ac_env_CLOOGINC_value=$CLOOGINC\n+ac_cv_env_CLOOGINC_set=${CLOOGINC+set}\n+ac_cv_env_CLOOGINC_value=$CLOOGINC\n \n #\n # Report the --help message.\n@@ -1117,6 +1133,10 @@ Some influential environment variables:\n   CPP         C preprocessor\n   GMPLIBS     How to link GMP\n   GMPINC      How to find GMP include files\n+  PPLLIBS     How to link PPL\n+  PPLINC      How to find PPL include files\n+  CLOOGLIBS   How to link CLOOG\n+  CLOOGINC    How to find CLOOG include files\n \n Use these variables to override the choices made by `configure' or to help\n it to find libraries and programs with nonstandard names/locations.\n@@ -14721,13 +14741,13 @@ if test \"${lt_cv_nm_interface+set}\" = set; then\n else\n   lt_cv_nm_interface=\"BSD nm\"\n   echo \"int some_variable = 0;\" > conftest.$ac_ext\n-  (eval echo \"\\\"\\$as_me:14724: $ac_compile\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14744: $ac_compile\\\"\" >&5)\n   (eval \"$ac_compile\" 2>conftest.err)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:14727: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14747: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n   (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:14730: output\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14750: output\\\"\" >&5)\n   cat conftest.out >&5\n   if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n     lt_cv_nm_interface=\"MS dumpbin\"\n@@ -15782,7 +15802,7 @@ ia64-*-hpux*)\n   ;;\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 15785 \"configure\"' > conftest.$ac_ext\n+  echo '#line 15805 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -16402,11 +16422,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16405: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16425: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:16409: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16429: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -16724,11 +16744,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16727: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16747: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:16731: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16751: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -16829,11 +16849,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16832: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16852: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:16836: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16856: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -16884,11 +16904,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16887: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16907: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:16891: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16911: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -19681,7 +19701,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19684 \"configure\"\n+#line 19704 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19781,7 +19801,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19784 \"configure\"\n+#line 19804 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -23997,6 +24017,21 @@ fi\n \n \n \n+\n+\n+\n+\n+\n+if test \"x${CLOOGLIBS}\" != \"x\" ; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_cloog 1\n+_ACEOF\n+\n+   GRAPHITE=graphite.o\n+fi\n+\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n \n@@ -24825,6 +24860,11 @@ s,@fortran_target_objs@,$fortran_target_objs,;t t\n s,@target_cpu_default@,$target_cpu_default,;t t\n s,@GMPLIBS@,$GMPLIBS,;t t\n s,@GMPINC@,$GMPINC,;t t\n+s,@PPLLIBS@,$PPLLIBS,;t t\n+s,@PPLINC@,$PPLINC,;t t\n+s,@CLOOGLIBS@,$CLOOGLIBS,;t t\n+s,@CLOOGINC@,$CLOOGINC,;t t\n+s,@GRAPHITE@,$GRAPHITE,;t t\n s,@LIBOBJS@,$LIBOBJS,;t t\n s,@LTLIBOBJS@,$LTLIBOBJS,;t t\n /@language_hooks@/r $language_hooks"}, {"sha": "f4cff3d114c80a2d889d927002cdd11f5031108b", "filename": "gcc/configure.ac", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -3883,6 +3883,15 @@ fi\n AC_ARG_VAR(GMPLIBS,[How to link GMP])\n AC_ARG_VAR(GMPINC,[How to find GMP include files])\n \n+AC_ARG_VAR(PPLLIBS,[How to link PPL])\n+AC_ARG_VAR(PPLINC,[How to find PPL include files])\n+\n+AC_ARG_VAR(CLOOGLIBS,[How to link CLOOG])\n+AC_ARG_VAR(CLOOGINC,[How to find CLOOG include files])\n+if test \"x${CLOOGLIBS}\" != \"x\" ; then \n+   AC_DEFINE(HAVE_cloog, 1, [Define if cloog is in use.])\n+fi\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n "}, {"sha": "5768f082026eb88a7e96a1b2c3ecb442e2084144", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -338,6 +338,7 @@ Objective-C and Objective-C++ Dialects}.\n -fira-coalesce -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n+-floop-block -floop-interchange -floop-strip-mine @gol\n -fmerge-all-constants -fmerge-constants -fmodulo-sched @gol\n -fmodulo-sched-allow-regmoves -fmove-loop-invariants -fmudflap @gol\n -fmudflapir -fmudflapth -fno-branch-count-reg -fno-default-inline @gol\n@@ -6012,6 +6013,81 @@ at @option{-O} and higher.\n Perform linear loop transformations on tree.  This flag can improve cache\n performance and allow further loop optimizations to take place.\n \n+@item -floop-interchange\n+Perform loop interchange transformations on loops.  Interchanging two\n+nested loops switches the inner and outer loops.  For example, given a\n+loop like:\n+@smallexample\n+DO J = 1, M\n+  DO I = 1, N\n+    A(J, I) = A(J, I) * C\n+  ENDDO\n+ENDDO\n+@end smallexample\n+loop interchange will transform the loop as if the user had written:\n+@smallexample\n+DO I = 1, N\n+  DO J = 1, M\n+    A(J, I) = A(J, I) * C\n+  ENDDO\n+ENDDO\n+@end smallexample\n+which can be beneficial when @code{N} is larger than the caches,\n+because in Fortran, the elements of an array are stored in memory\n+contiguously by column, and the original loop iterates over rows,\n+potentially creating at each access a cache miss.  This optimization\n+applies to all the languages supported by GCC and is not limited to\n+Fortran.\n+\n+@item -floop-strip-mine\n+Perform loop strip mining transformations on loops.  Strip mining\n+splits a loop into two nested loops.  The outer loop has strides \n+equal to the strip size and the inner loop has strides of the \n+original loop within a strip.  For example, given a loop like:\n+@smallexample\n+DO I = 1, N\n+  A(I) = A(I) + C\n+ENDDO\n+@end smallexample\n+loop strip mining will transform the loop as if the user had written:\n+@smallexample\n+DO II = 1, N, 4\n+  DO I = II, min (II + 4, N)\n+    A(I) = A(I) + C\n+  ENDDO\n+ENDDO\n+@end smallexample\n+This optimization applies to all the languages supported by GCC and is\n+not limited to Fortran.\n+\n+@item -floop-block\n+Perform loop blocking transformations on loops.  Blocking strip mines\n+each loop in the loop nest such that the memory accesses of the\n+element loops fit inside caches.  For example, given a loop like:\n+@smallexample\n+DO I = 1, N\n+  DO J = 1, M\n+    A(J, I) = B(I) + C(J)\n+  ENDDO\n+ENDDO\n+@end smallexample\n+loop blocking will transform the loop as if the user had written:\n+@smallexample\n+DO II = 1, N, 64\n+  DO JJ = 1, M, 64\n+    DO I = II, min (II + 64, N)\n+      DO J = JJ, min (JJ + 64, M)\n+        A(J, I) = B(I) + C(J)\n+      ENDDO\n+    ENDDO\n+  ENDDO\n+ENDDO\n+@end smallexample\n+which can be beneficial when @code{M} is larger than the caches,\n+because the innermost loop will iterate over a smaller amount of data\n+that can be kept in the caches.  This optimization applies to all the\n+languages supported by GCC and is not limited to Fortran.\n+\n @item -fcheck-data-deps\n @opindex fcheck-data-deps\n Compare the results of several data dependence analyzers.  This option"}, {"sha": "9df289cb5dcef9f3c0d2bc7b2738d323177ccf28", "filename": "gcc/gdbinit.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fgdbinit.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fgdbinit.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbinit.in?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -40,6 +40,15 @@ Print the tree that is $ in C syntax.\n Works only when an inferior is executing.\n end\n \n+define pgg\n+set debug_gimple_stmt ($)\n+end\n+\n+document pgg\n+Print the Gimple statement that is $ in C syntax.\n+Works only when an inferior is executing.\n+end\n+\n define pgs\n set debug_generic_stmt ($)\n end"}, {"sha": "ca8e64404e2656e8c2314b0806886ced1c398630", "filename": "gcc/gimple.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -38,6 +38,12 @@ DEF_VEC_P(gimple_seq);\n DEF_VEC_ALLOC_P(gimple_seq,gc);\n DEF_VEC_ALLOC_P(gimple_seq,heap);\n \n+/* For each block, the PHI nodes that need to be rewritten are stored into\n+   these vectors.  */\n+typedef VEC(gimple, heap) *gimple_vec;\n+DEF_VEC_P (gimple_vec);\n+DEF_VEC_ALLOC_P (gimple_vec, heap);\n+\n enum gimple_code {\n #define DEFGSCODE(SYM, STRING, STRUCT)\tSYM,\n #include \"gimple.def\""}, {"sha": "86b0eae6f97c878e6d7ac5e39d3d1e7793de4c71", "filename": "gcc/graphite.c", "status": "added", "additions": 4806, "deletions": 0, "changes": 4806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d"}, {"sha": "1a3cf6ccc65b3c4a4c6e7938da4fd6d69079d1d3", "filename": "gcc/graphite.h", "status": "added", "additions": 516, "deletions": 0, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,516 @@\n+/* Gimple Represented as Polyhedra.\n+   Copyright (C) 2006, 2007, 2008  Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@inria.fr>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"tree-data-ref.h\"\n+\n+typedef struct graphite_bb *graphite_bb_p;\n+DEF_VEC_P(graphite_bb_p);\n+DEF_VEC_ALLOC_P (graphite_bb_p, heap);\n+\n+DEF_VEC_P(scop_p);\n+DEF_VEC_ALLOC_P (scop_p, heap);\n+\n+static inline int scop_nb_loops (scop_p scop);\n+static inline unsigned scop_nb_params (scop_p scop);\n+static inline bool scop_contains_loop (scop_p scop, struct loop *loop);\n+\n+struct graphite_bb\n+{\n+  basic_block bb;\n+  scop_p scop;\n+\n+  /* The static schedule contains the textual order for every loop layer.\n+    \n+     Example:\n+\n+     S0\n+     for (i ...)\n+       {\n+         S1\n+         for (j ...)\n+           {\n+             S2\n+             S3\n+           }\n+         S4\n+       }\n+     S5\n+     for (k ...)\n+       {\n+         S6\n+         S7\n+         for (l ...)\n+           {\n+             S8\n+           }\n+         S9\n+       }\n+     S10\n+\n+     Schedules:\n+  \n+        | Depth       \n+     BB | 0  1  2 \n+     ------------\n+     S0 | 0\n+     S1 | 1, 0\n+     S2 | 1, 1, 0\n+     S3 | 1, 1, 1\n+     S4 | 1, 2\n+     S5 | 2\n+     S6 | 3, 0\n+     S7 | 3, 1\n+     S8 | 3, 2, 0\n+     S9 | 3, 3\n+     S10| 4\n+\n+   Normalization rules:\n+     - One SCoP can never contain two bbs with the same schedule timestamp.\n+     - All bbs at the same loop depth have a consecutive ordering (no gaps). */\n+  lambda_vector static_schedule;\n+\n+  /* The iteration domain of this bb. It contains this columns:\n+     - In/Eq: If this line is a equation or inequation.\n+     - For every loop iterator one column.\n+     - One column for every parameter in this SCoP.\n+     - The constant column to add integers to the (in)equations.\n+\n+     Example:\n+\n+     for (i = a - 7*b + 8; i <= 3*a + 13*b + 20; i++)\n+       for (j = 2; j <= 2*i + 5; j++)\n+         for (k = 0; k <= 5; k++)\n+           S (i,j,k)\n+\n+     Loop iterators: i, j, k \n+     Parameters: a, b\n+      \n+     (I)eq   i   j   k   a   b   1\n+  \n+     1       1   0   0  -1   7   -8    #  i >=  a -  7b +  8\n+     1      -1   0   0   3   13  20    #  i <= 3a + 13b + 20\n+     1       0   1   0   0   0   -2    #  j >= 2\n+     1       2  -1   0   0   0    5    #  j <= 2i + 5\n+     1       0   0   1   0   0    0    #  k >= 0 \n+     1       0   0  -1   0   0    5    #  k <= 5\n+\n+     The number of loop iterators may change and is not connected to the\n+     number of loops, that surrounded this bb in the gimple code. */\n+   CloogMatrix *domain;\n+\n+  /* Lists containing the restrictions of the conditional statements\n+     dominating this bb. This bb can only be executed, if all conditions\n+     are true.\n+ \n+     Example:\n+ \n+     for (i = 0; i <= 20; i++)\n+     {\n+       A\n+ \n+       if (2i <= 8)\n+         B\n+     }\n+ \n+     So for B there is a additional condition (2i <= 8).\n+ \n+     TODO: Add this restrictions to the domain matrix.\n+      \n+     List of COND_EXPR and SWITCH_EXPR. A COND_EXPR is true only if the \n+     corresponding element in CONDITION_CASES is not NULL_TREE. For a \n+     SWITCH_EXPR the corresponding element in CONDITION_CASES is a \n+     CASE_LABEL_EXPR.  */\n+  VEC (gimple, heap) *conditions;\n+  VEC (gimple, heap) *condition_cases;\n+\n+  /* LOOPS contains for every column in the graphite domain the corresponding\n+     gimple loop. If there exists no corresponding gimple loop LOOPS contains\n+     NULL. \n+  \n+     Example:\n+\n+     Original code:\n+\n+     for (i = 0; i <= 20; i++) \n+       for (j = 5; j <= 10; j++)\n+         A\n+\n+     Original domain:\n+\n+     (I)eq  i  j  1\n+     1      1  0  0   # i >= 0\n+     1     -1  0  20  # i <= 20\n+     1      0  1  0   # j >= 0\n+     1      0 -1  10  # j <= 10\n+\n+     Original loops vector:\n+     0         1 \n+     Loop i    Loop j\n+\n+     After some changes (Exchange i and j, strip-mine i):\n+     \n+     Domain:\n+\n+     (I)eq  j  ii i  k  1\n+     1      0  0  1  0  0   # i >= 0\n+     1      0  0 -1  0  20  # i <= 20\n+     1      1  0  0  0  0   # j >= 0\n+     1     -1  0  0  0  10  # j <= 10\n+     1      0 -1  1  0  0   # ii <= i\n+     1      0  1 -1  0  1   # ii + 1 >= i \n+     1      0 -1  0  2  0   # ii <= 2k\n+     1      0  1  0 -2  0   # ii >= 2k \n+\n+     Iterator vector:\n+     0        1        2         3\n+     Loop j   NULL     Loop i    NULL\n+    \n+     Means the original loop i is now at column two of the domain and\n+     loop j in the original loop nest is now at column 0.  Column 1 and\n+     3 are emtpy.  */\n+  VEC (loop_p, heap) *loops;\n+\n+  lambda_vector compressed_alpha_matrix;\n+  CloogMatrix *dynamic_schedule;\n+  VEC (data_reference_p, heap) *data_refs;\n+};\n+\n+#define GBB_BB(GBB) GBB->bb\n+#define GBB_SCOP(GBB) GBB->scop\n+#define GBB_STATIC_SCHEDULE(GBB) GBB->static_schedule\n+#define GBB_DATA_REFS(GBB) GBB->data_refs\n+#define GBB_ALPHA(GBB) GBB->compressed_alpha_matrix\n+#define GBB_DYNAMIC_SCHEDULE(GBB) GBB->dynamic_schedule\n+#define GBB_DOMAIN(GBB) GBB->domain\n+#define GBB_CONDITIONS(GBB) GBB->conditions\n+#define GBB_CONDITION_CASES(GBB) GBB->condition_cases\n+#define GBB_LOOPS(GBB) GBB->loops\n+\n+/* Return the loop that contains the basic block GBB.  */\n+\n+static inline struct loop *\n+gbb_loop (struct graphite_bb *gbb)\n+{\n+  return GBB_BB (gbb)->loop_father;\n+}\n+\n+/* Calculate the number of loops around GB in the current SCOP.  Only\n+   works if GBB_DOMAIN is built.  */\n+\n+static inline int\n+gbb_nb_loops (const struct graphite_bb *gb)\n+{\n+  scop_p scop = GBB_SCOP (gb);\n+\n+  if (GBB_DOMAIN (gb) == NULL)\n+    return 0;\n+  \n+  return GBB_DOMAIN (gb)->NbColumns - scop_nb_params (scop) - 2;\n+}\n+\n+/* Returns the gimple loop, that corresponds to the loop_iterator_INDEX.  \n+   If there is no corresponding gimple loop, we return NULL.  */\n+\n+static inline loop_p\n+gbb_loop_at_index (graphite_bb_p gb, int index)\n+{\n+  return VEC_index (loop_p, GBB_LOOPS (gb), index);\n+}\n+\n+/* Returns the corresponding loop iterator index for a gimple loop.  */\n+\n+static inline int\n+gbb_loop_index (graphite_bb_p gb, loop_p loop)\n+{\n+  int i;\n+  loop_p l;\n+\n+  for (i = 0; VEC_iterate (loop_p, GBB_LOOPS (gb), i, l); i++)\n+    if (loop == l)\n+      return i;\n+\n+  gcc_unreachable();\n+}\n+\n+struct loop_to_cloog_loop_str\n+{\n+  unsigned int loop_num;\n+  unsigned int loop_position; /* The column that represents this loop.  */\n+  CloogLoop *cloog_loop;\n+};\n+\n+typedef struct name_tree\n+{\n+  tree t;\n+  const char *name;\n+  struct loop* loop;\n+} *name_tree;\n+\n+DEF_VEC_P(name_tree);\n+DEF_VEC_ALLOC_P (name_tree, heap);\n+\n+/* A Single Entry, Single Exit region is a part of the CFG delimited\n+   by two edges.  */\n+typedef struct sese\n+{\n+  edge entry, exit;\n+} *sese;\n+\n+#define SESE_ENTRY(S) (S->entry)\n+#define SESE_EXIT(S) (S->exit)\n+\n+/* A SCOP is a Static Control Part of the program, simple enough to be\n+   represented in polyhedral form.  */\n+struct scop\n+{\n+  /* A SCOP is defined as a SESE region.  */\n+  sese region;\n+\n+  /* All the basic blocks in this scop.  They have extra information\n+     attached to them, in the graphite_bb structure.  */\n+  VEC (graphite_bb_p, heap) *bbs;\n+\n+  /* Set for a basic block index when it belongs to this SCOP.  */\n+  bitmap bbs_b;\n+\n+  lambda_vector static_schedule;\n+\n+  /* Parameters used within the SCOP.  */\n+  VEC (name_tree, heap) *params;\n+\n+  /* A collection of old induction variables*/ \n+  VEC (name_tree, heap) *old_ivs;\n+\n+  /* Loops completely contained in the SCOP.  */\n+  bitmap loops;\n+  VEC (loop_p, heap) *loop_nest;\n+\n+  /* ???  It looks like a global mapping loop_id -> cloog_loop would work.  */\n+  htab_t loop2cloog_loop;\n+\n+  /* CLooG representation of this SCOP.  */\n+  CloogProgram *program;\n+};\n+\n+#define SCOP_BBS(S) S->bbs\n+#define SCOP_BBS_B(S) S->bbs_b\n+#define SCOP_REGION(S) S->region\n+/* SCOP_ENTRY bb dominates all the bbs of the scop.  SCOP_EXIT bb\n+   post-dominates all the bbs of the scop.  SCOP_EXIT potentially\n+   contains non affine data accesses, side effect statements or\n+   difficult constructs, and thus is not considered part of the scop,\n+   but just a boundary.  SCOP_ENTRY is considered part of the scop.  */\n+#define SCOP_ENTRY(S) (SESE_ENTRY (SCOP_REGION (S))->dest)\n+#define SCOP_EXIT(S) (SESE_EXIT (SCOP_REGION (S))->dest)\n+#define SCOP_STATIC_SCHEDULE(S) S->static_schedule\n+#define SCOP_LOOPS(S) S->loops\n+#define SCOP_LOOP_NEST(S) S->loop_nest\n+#define SCOP_PARAMS(S) S->params\n+#define SCOP_OLDIVS(S) S->old_ivs\n+#define SCOP_PROG(S) S->program\n+#define SCOP_LOOP2CLOOG_LOOP(S) S->loop2cloog_loop\n+#define SCOP_LOOPS_MAPPING(S) S->loops_mapping\n+\n+extern void debug_scop (scop_p, int);\n+extern void debug_scops (int);\n+extern void print_graphite_bb (FILE *, graphite_bb_p, int, int);\n+extern void debug_gbb (graphite_bb_p, int);\n+extern void dot_scop (scop_p);\n+extern void dot_all_scops (void);\n+extern void debug_clast_stmt (struct clast_stmt *);\n+\n+\n+extern void debug_loop_vec (graphite_bb_p gb);\n+extern void debug_oldivs (scop_p);\n+\n+typedef VEC(name_tree, heap) **loop_iv_stack;\n+extern void loop_iv_stack_debug (loop_iv_stack);\n+\n+\n+/* Return the number of gimple loops contained in SCOP.  */\n+\n+static inline int\n+scop_nb_loops (scop_p scop)\n+{\n+  return VEC_length (loop_p, SCOP_LOOP_NEST (scop));\n+}\n+\n+/* Returns the number of parameters for SCOP.  */\n+\n+static inline unsigned\n+scop_nb_params (scop_p scop)\n+{\n+  return VEC_length (name_tree, SCOP_PARAMS (scop));\n+}\n+\n+/* Return the dimension of the domains for SCOP.  */\n+\n+static inline int\n+scop_dim_domain (scop_p scop)\n+{\n+  return scop_nb_loops (scop) + scop_nb_params (scop) + 1;\n+}\n+\n+/* Return the dimension of the domains for GB.  */\n+\n+static inline int\n+gbb_dim_domain (graphite_bb_p gb)\n+{\n+  return scop_dim_domain (GBB_SCOP (gb));\n+}\n+\n+/* Returns the dimensionality of a loop iteration domain for a given\n+   loop, identified by LOOP_NUM, with respect to SCOP.  */\n+\n+static inline int\n+loop_domain_dim (unsigned int loop_num, scop_p scop)\n+{\n+  struct loop_to_cloog_loop_str tmp, *slot; \n+  htab_t tab = SCOP_LOOP2CLOOG_LOOP (scop);\n+\n+  tmp.loop_num = loop_num;\n+  slot = (struct loop_to_cloog_loop_str *) htab_find (tab, &tmp);\n+\n+  /* The loop containing the entry of the scop is not always part of\n+     the SCoP, and it is not registered in SCOP_LOOP2CLOOG_LOOP.  */\n+  if (!slot)\n+    return scop_nb_params (scop) + 2;\n+\n+  return cloog_domain_dim (cloog_loop_domain (slot->cloog_loop)) + 2;\n+}\n+\n+/* Returns the dimensionality of an enclosing loop iteration domain\n+   with respect to enclosing SCoP for a given data reference REF.  */\n+\n+static inline int\n+ref_nb_loops (data_reference_p ref)\n+{\n+  return loop_domain_dim (loop_containing_stmt (DR_STMT (ref))->num, DR_SCOP (ref));\n+}\n+\n+/* Returns the dimensionality of a loop iteration vector in a loop\n+   iteration domain for a given loop (identified by LOOP_NUM) with\n+   respect to SCOP.  */\n+\n+static inline int\n+loop_iteration_vector_dim (unsigned int loop_num, scop_p scop)\n+{\n+  return loop_domain_dim (loop_num, scop) - 2 - scop_nb_params (scop);\n+}\n+\n+/* Checks, if SCOP contains LOOP.  */\n+\n+static inline bool\n+scop_contains_loop (scop_p scop, struct loop *loop)\n+{\n+  return bitmap_bit_p (SCOP_LOOPS (scop), loop->num);\n+}\n+\n+/* Returns the index of LOOP in the domain matrix for the SCOP.  */\n+\n+static inline int\n+scop_loop_index (scop_p scop, struct loop *loop)\n+{\n+  unsigned i;\n+  struct loop *l;\n+\n+  gcc_assert (scop_contains_loop (scop, loop));\n+\n+  for (i = 0; VEC_iterate (loop_p, SCOP_LOOP_NEST (scop), i, l); i++)\n+    if (l == loop)\n+      return i;\n+\n+  gcc_unreachable();\n+}\n+\n+/* Return the index of innermost loop that contains the basic block\n+   GBB.  */\n+\n+static inline int\n+gbb_inner_most_loop_index (scop_p scop, graphite_bb_p gb)\n+{\n+  return scop_loop_index(scop, gbb_loop (gb));\n+}\n+\n+/* Return the outermost loop that contains the loop LOOP.  The outer\n+   loops are searched until a sibling for the outer loop is found.  */\n+\n+static struct loop *\n+outer_most_loop_1 (scop_p scop, struct loop* loop, struct loop* current_outer)\n+{\n+  return (!scop_contains_loop (scop, loop)) ? current_outer :\n+    (loop->next != NULL) ? loop :\n+    outer_most_loop_1 (scop, loop_outer (loop), loop);\n+}\n+\n+/* Return the outermost loop that contains the loop LOOP.  */\n+\n+static struct loop *\n+outer_most_loop (scop_p scop, struct loop *loop)\n+{\n+  return outer_most_loop_1 (scop, loop, NULL);\n+}\n+\n+/* Return the index of the outermost loop that contains the basic\n+   block BB.  */\n+\n+static inline int\n+gbb_outer_most_loop_index (scop_p scop, graphite_bb_p gb)\n+{\n+  return scop_loop_index (scop, outer_most_loop (scop, gbb_loop (gb)));\n+}\n+\n+/* Return the loop depth of LOOP in SCOP.  */\n+\n+static inline unsigned int\n+scop_gimple_loop_depth (scop_p scop, loop_p loop)\n+{\n+  unsigned int depth = 0;\n+\n+  loop = loop_outer (loop);\n+\n+  while (scop_contains_loop (scop, loop))\n+    {\n+      depth++;\n+      loop = loop_outer (loop);\n+    }\n+\n+  return depth;\n+}\n+\n+/* Associate a POLYHEDRON dependence description to two data\n+   references A and B.  */\n+struct data_dependence_polyhedron\n+{\n+  struct data_reference *a;\n+  struct data_reference *b;\n+  bool reversed_p;\n+  bool loop_carried; /*TODO:konrad get rid of this, make level signed */\n+  signed level;\n+  CloogDomain *polyhedron;  \n+};\n+\n+#define RDGE_DDP(E)   ((struct data_dependence_polyhedron*) ((E)->data))\n+\n+typedef struct data_dependence_polyhedron *ddp_p;\n+\n+DEF_VEC_P(ddp_p);\n+DEF_VEC_ALLOC_P(ddp_p,heap);\n+"}, {"sha": "2fdd898f0644d415b1e929c706dda93eb2590a38", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -147,7 +147,6 @@ static lambda_lattice lambda_lattice_new (int, int, struct obstack *);\n static lambda_lattice lambda_lattice_compute_base (lambda_loopnest,\n                                                    struct obstack *);\n \n-static tree find_induction_var_from_exit_cond (struct loop *);\n static bool can_convert_to_perfect_nest (struct loop *);\n \n /* Create a new lambda body vector.  */\n@@ -1434,7 +1433,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n /* Given a LOOP, find the induction variable it is testing against in the exit\n    condition.  Return the induction variable if found, NULL otherwise.  */\n \n-static tree\n+tree\n find_induction_var_from_exit_cond (struct loop *loop)\n {\n   gimple expr = get_loop_exit_condition (loop);"}, {"sha": "2d321fbab6dd96290fb7da263f32919a6bec37c7", "filename": "gcc/lambda.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -39,6 +39,9 @@ DEF_VEC_ALLOC_P (lambda_vector_vec_p, heap);\n    all vectors are the same length).  */\n typedef lambda_vector *lambda_matrix;\n \n+DEF_VEC_P (lambda_matrix);\n+DEF_VEC_ALLOC_P (lambda_matrix, heap);\n+\n /* A transformation matrix, which is a self-contained ROWSIZE x COLSIZE\n    matrix.  Rather than use floats, we simply keep a single DENOMINATOR that\n    represents the denominator for every element in the matrix.  */\n@@ -213,6 +216,7 @@ void lambda_loopnest_to_gcc_loopnest (struct loop *,\n                                       lambda_loopnest, lambda_trans_matrix,\n                                       struct obstack *);\n void remove_iv (gimple);\n+tree find_induction_var_from_exit_cond (struct loop *);\n \n static inline void lambda_vector_negate (lambda_vector, lambda_vector, int);\n static inline void lambda_vector_mult_const (lambda_vector, lambda_vector, int, int);\n@@ -374,6 +378,33 @@ lambda_vector_matrix_mult (lambda_vector vect, int m, lambda_matrix mat,\n       dest[i] += mat[j][i] * vect[j];\n }\n \n+/* Compare two vectors returning an integer less than, equal to, or\n+   greater than zero if the first argument is considered to be respectively\n+   less than, equal to, or greater than the second.  \n+   We use the lexicographic order.  */\n+\n+static inline int\n+lambda_vector_compare (lambda_vector vec1, int length1, lambda_vector vec2,\n+                       int length2)\n+{\n+  int min_length;\n+  int i;\n+\n+  if (length1 < length2)\n+    min_length = length1;\n+  else\n+    min_length = length2;\n+\n+  for (i = 0; i < min_length; i++)\n+    if (vec1[i] < vec2[i])\n+      return -1;\n+    else if (vec1[i] > vec2[i])\n+      return 1;\n+    else\n+      continue;\n+\n+  return length1 - length2;\n+}\n \n /* Print out a vector VEC of length N to OUTFILE.  */\n "}, {"sha": "36c107e852a4342e7dc9d58089397c2e32b197fd", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -655,6 +655,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_check_data_deps);\n \t  NEXT_PASS (pass_loop_distribution);\n \t  NEXT_PASS (pass_linear_transform);\n+\t  NEXT_PASS (pass_graphite_transforms);\n \t  NEXT_PASS (pass_iv_canon);\n \t  NEXT_PASS (pass_if_conversion);\n \t  NEXT_PASS (pass_vectorize);"}, {"sha": "5c75e1fde36d73f1221406d55b0a10600832db55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -1,3 +1,23 @@\n+2008-09-02  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Tobias Grosser  <grosser@fim.uni-passau.de>\n+\t    Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Harsha Jagasia  <harsha.jagasia@amd.com>\n+\t    Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>\n+\t    Konrad Trifunovic  <konrad.trifunovic@inria.fr>\n+\t    Adrien Eliche  <aeliche@isty.uvsq.fr>\n+\n+\tMerge from graphite branch.\n+\t* gcc.dg/graphite/scop-{0,1,2,3,4,5,6,7,8,9,\n+\t10,11,12,13,14,15,16,17,18}.c: New.\n+\t* gcc.dg/graphite/graphite.exp: New.\n+\t* gcc.dg/graphite/scop-matmult.c: New.\n+\t* gcc.dg/graphite/block-0.c: New.\n+\t* lib/target-supports.exp (check_effective_target_fgraphite): New.\n+\t* gfortran.dg/graphite/block-1.f90: New.\n+\t* gfortran.dg/graphite/scop-{1,2}.f: New.\n+\t* gfortran.dg/graphite/block-{1,3,4}.f90: New.\n+\t* gfortran.dg/graphite/graphite.exp: New.\n+\t\n 2008-09-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37327"}, {"sha": "f277f05fb06699bfd63bcb7cd252c5d6b08982b4", "filename": "gcc/testsuite/gcc.dg/graphite/block-0.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-O -floop-block -fdump-tree-graphite-all\" } */\n+\n+#define N 1000\n+\n+int toto()\n+{\n+  int j;\n+  int i;\n+  int a[N];\n+  int b[N];\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      a[j] = a[i] + 1;\n+\n+  return a[0];\n+}\n+\n+main()\n+{\n+  return toto();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop blocked\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "039b974fdae355285a29ea9b6e229bdbcf181d33", "filename": "gcc/testsuite/gcc.dg/graphite/block-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+\n+#define MAX 8192\n+\n+int main()\n+{\n+  int i, j;\n+  int sum = 0;\n+  int A[MAX * MAX];\n+  int B[MAX * MAX];\n+\n+  for (i = 0; i < MAX; i++)\n+    for (j = 0; j < MAX; j++)\n+      {\n+\tA[i*MAX + j] = j;\n+\tB[i*MAX + j] = j;\n+      }\n+\n+  for (i = 0; i < MAX; i++)\n+    for (j = 0; j < MAX; j++)\n+      A[i*MAX + j] += B[j*MAX + i];\n+\n+  for(i = 0; i < MAX; i++)\n+    for(j = 0; j < MAX; j++)\n+      sum += A[i*MAX + j];\n+\n+  return sum;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop blocked\" 3 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "a1257177f552dbbd2f9a63ab20d9382db37384b0", "filename": "gcc/testsuite/gcc.dg/graphite/graphite.exp", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,48 @@\n+#   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+if ![check_effective_target_fgraphite] {\n+  return\n+}\n+\n+# The default action for a test is 'compile'.  Save current default.\n+global dg-do-what-default\n+set save-dg-do-what-default ${dg-do-what-default}\n+set dg-do-what-default compile\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# Clean up.\n+set dg-do-what-default ${save-dg-do-what-default}\n+\n+# All done.\n+dg-finish"}, {"sha": "ea3ae065a0be5f2073c61a6d11524dc6ff1aea32", "filename": "gcc/testsuite/gcc.dg/graphite/scop-0.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-0.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+int foo (void);\n+void bar (void);\n+\n+int toto()\n+{\n+  /* Scop 1. */\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+  int N = foo ();\n+\n+  for (i = 0; i < 2*N+ 100; i++)\n+    for (j = 0; j < 200; j++)\n+      a[j][i] = a[j+1][10] + 2;\n+\n+  return a[3][5] + b[1];\n+  /* End scop 1. */\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 1\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */\n+"}, {"sha": "ed6159fb3658deda1334ffb91f9556322584c9a0", "filename": "gcc/testsuite/gcc.dg/graphite/scop-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-1.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar (void);\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 100; j++)\n+\ta[j][i] = a[j+1][i-1] + 2;\n+\n+      b[i] = b[i-1] + 2;\n+\n+      bar ();\n+\n+      for (j = 1; j < 100; j++)\n+\ta[j][i] = a[j+1][i-1] + 2;\n+\n+      b[i] = a[i-1][i] + 2;\n+\n+      for (j = 1; j < 100; j++)\n+\ta[j][i] = a[j+1][i-1] + 2;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 3\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "8aff2c74302fd95a2d6845ee6fa286112d07177d", "filename": "gcc/testsuite/gcc.dg/graphite/scop-10.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-10.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar (void);\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 100; j++)\n+        b[i+j] = b[i+j-1] + 2;\n+\n+      if (i * 2 == i + 8)\n+        bar ();\n+      else \n+        {\n+\t  for (j = 1; j < 100; j++)\n+\t    b[i+j] = b[i+j-1] + 2;\n+\t  a[i][i] = 2;\n+\t}\n+\n+      for (k = 1; k < 100; k++)\n+        b[i+k] = b[i+k-5] + 2;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 3\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "e5a0fdb3904b52cbe11a6b87f2c6d28239060c6f", "filename": "gcc/testsuite/gcc.dg/graphite/scop-11.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-11.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar ();\n+\n+int toto()\n+{\n+  int i,j, b;\n+  int a[100];\n+\n+  if (i == 20)\n+    {\n+      for (j = 0; j <= 20; j++)\n+        a[j] = b + i;\n+      b = 3;\n+      bar();\n+    }\n+  else \n+    {\n+      if (i == 30)\n+\t{\n+          for (j = 0; j <= 20; j++)\n+            a[j] = b + i;\n+\t  b = 5;\n+\t}\n+    }\n+\n+  for (j = 0; j <= 20; j++)\n+    a[j] = b + i;\n+\n+  return a[b];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 3\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "0c130330ccd8034e72d7043e971420810fce594d", "filename": "gcc/testsuite/gcc.dg/graphite/scop-12.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-12.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar ();\n+\n+int toto()\n+{\n+  int i,j, b;\n+  int a[100];\n+\n+  switch (i)\n+    {\n+    \n+      case 5:\n+        for (j = 0; j <= 20; j++)\n+          a[j] = b + i + 12;\n+        break;\n+      case 8:\n+        for (j = 0; j <= 20; j++)\n+          a[j] = b + i + 122;\n+        break;\n+      case 15:\n+        for (j = 0; j <= 20; j++)\n+          a[j] = b + i + 12;\n+        break;\n+      case 18:\n+        for (j = 0; j <= 20; j++)\n+          a[j] = b + i + 4;\n+        break;\n+     default:\n+        for (j = 0; j <= 20; j++)\n+          a[j] = b + i + 3;\n+   }\n+\n+  return a[b];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 5\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "aa55e10f3f47b726e32718755193b11ac261a5b9", "filename": "gcc/testsuite/gcc.dg/graphite/scop-13.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-13.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar ();\n+\n+int toto()\n+{\n+  int i,j, b;\n+  int a[100];\n+\n+  if (i == 20)\n+    {\n+      b = 3;\n+      goto B;\n+    }\n+  else \n+    {\n+      if (i == 30)\n+\t{\n+          a[i] = b;\n+\n+\n+          for (j = 0; j <= 20; j++)\n+            a[j] = b + i;\n+\n+          B:\n+\n+          for (j = 0; j <= 20; j++)\n+            a[j+b] = b + i;\n+          \n+          bar ();\n+\t}\n+      else \n+        {\n+          a[i] = b + 3;\n+        }\n+    }\n+\n+\n+  return a[b];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "a707b01d4509c6f2144f7df6350a4bcd58465a4a", "filename": "gcc/testsuite/gcc.dg/graphite/scop-14.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-14.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar ();\n+\n+int toto()\n+{\n+  int i,j, b;\n+  int a[100];\n+\n+  for (j = 0; j <= 20; j++)\n+    {\n+      a[j] = b + i;\n+      \n+      if (j * i == b)\n+        break;\n+\n+      a[j+b] = b + i;\n+    }\n+\n+  a[i] = b + 3;\n+\n+\n+  return a[b];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 0\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "7e2425373155add457da8f4537cb6f9d50b2ec92", "filename": "gcc/testsuite/gcc.dg/graphite/scop-15.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-15.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+#  define EXTERN(type, array)  extern type array[]\n+typedef unsigned char  uch;\n+typedef unsigned short ush;\n+EXTERN(uch, window);\n+EXTERN(ush, prev);\n+#ifndef WSIZE\n+#  define WSIZE 0x8000\n+#endif                \n+#define MIN_MATCH  3\n+#define MAX_MATCH  258\n+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n+#define MAX_DIST  (WSIZE-MIN_LOOKAHEAD)\n+#define near\n+typedef unsigned IPos;\n+unsigned near max_chain_length;\n+extern unsigned near strstart;\n+unsigned int near prev_length;\n+#define NIL 0\n+unsigned near good_match;\n+int near nice_match;\n+#define WMASK     (WSIZE-1)\n+int longest_match(IPos cur_match)\n+{\n+    unsigned chain_length = max_chain_length;\n+    register uch *scan = window + strstart;  \n+    register uch *match;                     \n+    register int len;                        \n+    int best_len = prev_length;              \n+    IPos limit = strstart > (IPos)MAX_DIST ? strstart - (IPos)MAX_DIST : NIL;\n+    register uch *strend = window + strstart + MAX_MATCH;\n+    register uch scan_end   = scan[best_len];\n+    if (prev_length >= good_match) {\n+    }\n+    do {\n+        if (match[best_len]   != scan_end  ||\n+            *++match          != scan[1])      continue;\n+        do {\n+        } while (*++scan == *++match && *++scan == *++match &&\n+                 scan < strend);\n+        len = MAX_MATCH - (int)(strend - scan);\n+        if (len > best_len) {\n+            best_len = len;\n+            if (len >= nice_match) break;\n+        }\n+    } while ((cur_match = prev[cur_match & WMASK]) > limit\n+\t     && --chain_length != 0);\n+    return best_len;\n+}\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 0\" 1 \"graphite\"} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "42f7b6aade3cd6963e81f1fc1263d0e6aee95a0c", "filename": "gcc/testsuite/gcc.dg/graphite/scop-16.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-16.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+#define N 10000\n+void foo (int);\n+int test ()\n+{\n+  int a[N][N];\n+  int b[N][N];\n+  unsigned i, j;\n+\n+  for (i = 0; i < N; i++) \n+    for (j = 0; j < N; j++)\n+      a[i][j] = i*j;\n+\n+  for (j = 1; j < N; j++) \n+    for (i = 0; i < N; i++)\n+      a[i][j] = a[i][j-1] + b[i][j];\n+\n+  for (i = 0; i < N; i++) \n+    for (j = 0; j < N; j++) \n+      foo (a[i][j]); \n+}\n+\n+/* Interchange is legal for loops 0 and 1 of the first two SCoPs */\n+/* { dg-final { scan-tree-dump-times \"Interchange valid for loops 0 and 1:\" 2 \"graphite\"} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "4c1b0ca2993b7ef10eeae834f99409c1f94f38bf", "filename": "gcc/testsuite/gcc.dg/graphite/scop-17.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-17.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+#define N 10000\n+void foo (int);\n+int test ()\n+{\n+  int a[N][N];\n+  unsigned i, j;\n+\n+  for (i = 0; i < N; i++) \n+    for (j = 0; j < N; j++)\n+\ta[i][j] = i*j;\n+\n+  for (i = 1; i < N; i++) \n+    for (j = 1; j < (N-1) ; j++)\n+\ta[i][j] = a[i-1][j+1] * a[i-1][j+1]/2;\n+\n+  for (i = 0; i < N; i++) \n+    for (j = 0; j < N; j++)\n+      foo (a[i][j]); \n+}\n+\n+/* Interchange is not legal for loops 0 and 1 of SCoP 2.  */\n+/* { dg-final { scan-tree-dump-times \"Interchange not valid for loops 0 and 1:\" 1 \"graphite\"} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "fe2d5f4a4121ac4a3b0174d4fe3a03b77f7e08aa", "filename": "gcc/testsuite/gcc.dg/graphite/scop-18.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-18.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+\n+#define N 24\n+#define M 1000\n+\n+float A[1000][1000], B[1000][1000], C[1000][1000];\n+\n+void test (void)\n+{\n+  int i, j, k;\n+\n+  /* These loops contain too few iterations for being strip-mined by 64.  */\n+  for (i = 0; i < 24; i++)\n+    for (j = 0; j < 24; j++)\n+      for (k = 0; k < 24; k++)\n+        A[i][j] += B[i][k] * C[k][j];\n+\n+  /* These loops should still be strip mined.  */\n+  for (i = 0; i < 1000; i++)\n+    for (j = 0; j < 1000; j++)\n+      for (k = 0; k < 1000; k++)\n+        A[i][j] += B[i][k] * C[k][j];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Strip Mining is not profitable\" 3 \"graphite\" } } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "cf25dcdaf093073456f925a594e024a9d9482b57", "filename": "gcc/testsuite/gcc.dg/graphite/scop-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-2.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar (void);\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 100; j++)\n+\tfor (k = 1; k < 100; k++)\n+\t  a[j][k] = a[j+1][i-1] + 2;\n+\n+      b[i] = b[i-1] + 2;\n+\n+      bar ();\n+\n+      for (j = 1; j < 100; j++)\n+\ta[j][i] = a[j+1][i-1] + 2;\n+\n+      b[i] = b[i-1] + 2;\n+\n+      bar ();\n+\n+      for (j = 1; j < 100; j++)\n+\ta[j][i] = a[j+1][i-1] + 2;\n+\n+      b[i] = a[i-1][i] + 2;\n+\n+      for (j = 1; j < 100; j++)\n+\ta[j][i] = a[j+1][i-1] + 2;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 4\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "1789e6b6c5a82826dc7ada43dd478bb4df85dd55", "filename": "gcc/testsuite/gcc.dg/graphite/scop-3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-3.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 80; j++)\n+\ta[j][i] = a[j+1][2*i-1*j] + 12;\n+\n+      b[i] = b[i-1] + 10;\n+\n+      for (j = 1; j < 60; j++)\n+\ta[j][i] = a[j+1][i-1] + 8;\n+\n+      if (i == 23)\n+\tb[i] = a[i-1][i] + 6;\n+\n+      for (j = 1; j < 40; j++)\n+\ta[j][i] = a[j+1][i-1] + 4;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 3\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "515c53ad592fe86106f3d23952af4eeef30b03c2", "filename": "gcc/testsuite/gcc.dg/graphite/scop-4.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-4.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar ();\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 80; j++)\n+\ta[j][i] = a[j+1][2*i-1*j] + 12;\n+\n+      b[i] = b[i-1] + 10;\n+\n+      for (j = 1; j < 60; j++)\n+\ta[j][i] = a[j+1][i-1] + 8;\n+\n+      bar ();\n+\n+      if (i == 23)\n+\tb[i] = a[i-1][i] + 6;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "697a28ea1683f06621070fcbd3e10ce83b2e3e13", "filename": "gcc/testsuite/gcc.dg/graphite/scop-5.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-5.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar ();\n+\n+int toto()\n+{\n+  int i,j, b;\n+  int a[100];\n+\n+  if (i == 20)\n+    {\n+      for (j = 0; j <= 20; j++)\n+        a[j] = b + i;\n+      b = 3;\n+      bar();\n+    }\n+  else \n+    {\n+      if (i == 30)\n+\t{\n+          for (j = 0; j <= 20; j++)\n+            a[j] = b + i;\n+\t  b = 5;\n+\t}\n+      else\n+\t{\n+          for (j = 0; j <= 20; j++)\n+            a[j] = b + i;\n+\t  b = 8;\n+\t}\n+    }\n+\n+  return a[b];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 3\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "d2623204735a2d6ecbd6ffeb3953a10abf1d6b2f", "filename": "gcc/testsuite/gcc.dg/graphite/scop-6.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-6.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar (void);\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 100; j++)\n+        b[i+j] = b[i+j-1] + 2;\n+\n+      if (i * 2 == i + 8)\n+        b[i+k] = b[i+k-1] + 2;\n+      else \n+        {\n+        for (k = 1; k < 100; k++)\n+          b[i+k] = b[i+k-1] + 2;\n+        bar ();\n+        }\n+      \n+      for (k = 1; k < 100; k++)\n+        b[i+k] = b[i+k-5] + 2;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 3\" 1 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "1187ce104ecbd63aa36450d37ddd52e389d555d0", "filename": "gcc/testsuite/gcc.dg/graphite/scop-7.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-7.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar (void);\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 100; j++)\n+        b[i+j] = b[i+j-1] + 2;\n+\n+      if (i * 2 == i + 8)\n+\t{\n+\t  bar ();\n+\t  for (j = 1; j < 100; j++)\n+\t    b[i+j] = b[i+j-1] + 2;\n+\t}\n+      else \n+\ta[i][i] = 2;\n+\n+      for (k = 1; k < 100; k++)\n+        b[i+k] = b[i+k-5] + 2;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 3\" 1 \"graphite\"} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "491ad372febb96d5333e0861246f50f5066be82a", "filename": "gcc/testsuite/gcc.dg/graphite/scop-8.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-8.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+int bar (void);\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 100; j++)\n+        b[i+j] = b[i+j-1] + 2;\n+\n+      if (i * 2 == i + 8)\n+\t{\n+\t  for (j = 1; j < 100; j++)\n+\t    if (bar ())\n+\t      b[i+j] = b[i+j-1] + 2;\n+\t}\n+      else \n+\ta[i][i] = 2;\n+\n+      for (k = 1; k < 100; k++)\n+        b[i+k] = b[i+k-5] + 2;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "871b86b8bd404bc623c22c0f05a56886b13205f8", "filename": "gcc/testsuite/gcc.dg/graphite/scop-9.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-9.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+void bar (void);\n+\n+int toto()\n+{\n+  int i, j, k;\n+  int a[100][100];\n+  int b[100];\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      for (j = 1; j < 100; j++)\n+        b[i+j] = b[i+j-1] + 2;\n+\n+      if (i * 2 == i + 8)\n+        bar ();\n+      else \n+\ta[i][i] = 2;\n+\n+      for (k = 1; k < 100; k++)\n+        b[i+k] = b[i+k-5] + 2;\n+    }\n+\n+  return a[3][5] + b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "61a5be1fd21be39b00abc7acbdd74a814bf25101", "filename": "gcc/testsuite/gcc.dg/graphite/scop-matmult.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-matmult.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-matmult.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-matmult.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n+float A[1000][1000], B[1000][1000], C[1000][1000];\n+\n+/* Multiply two n x n matrices A and B and store the result in C.  */\n+\n+void matmult (int n)\n+{\n+  int i,j,k;\n+\n+  for (i = 0; i < n; i++)\n+    for (j = 0; j < n; j++)\n+      for (k = 0; k < n; k++)\n+        A[i][j] += B[i][k] * C[k][j];\n+}\n+\n+/* This one fails because the number of iterations cannot be\n+   determined anymore for the outermost loop.  */\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 1\" 1 \"graphite\" { xfail *-*-* } } } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "124f06d16eb74fc9f4442f9b083874e06e0b285a", "filename": "gcc/testsuite/gfortran.dg/graphite/block-1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-1.f90?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,14 @@\n+! { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } \n+\n+subroutine matrix_multiply(a,b,c,n)\n+\n+real(8), dimension(n,n) :: a,b,c\n+\n+! The following code is disabled for the moment.\n+! c=0.d0\n+\n+end subroutine matrix_multiply\n+\n+! { dg-final { scan-tree-dump-times \"Loop blocked\" 2 \"graphite\" { xfail *-*-* } } } \n+! { dg-final { cleanup-tree-dump \"graphite\" } } \n+"}, {"sha": "af966ec5f97a515bd7586cb9009f237025f1f42a", "filename": "gcc/testsuite/gfortran.dg/graphite/block-2.f", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-2.f?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,22 @@\n+! { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } \n+\n+      SUBROUTINE MATRIX_MUL_UNROLLED (A, B, C, L, M, N)\n+      DIMENSION A(L,M), B(M,N), C(L,N)\n+\n+      DO 100 K = 1, N\n+        DO 100 I = 1, L\n+          C(I,K) = 0.\n+100     CONTINUE\n+      DO 110 J = 1, M, 4\n+        DO 110 K = 1, N\n+          DO 110 I = 1, L\n+            C(I,K) = C(I,K) + A(I,J) * B(J,K)\n+     $             + A(I,J+1) * B(J+1,K) + A(I,J+2) * B(J+2,K)\n+     $             + A(I,J+3) * B(J+3,K)\n+110   CONTINUE\n+\n+      RETURN\n+      END\n+\n+! { dg-final { scan-tree-dump-times \"Loop blocked\" 3 \"graphite\" { xfail { \"*-*-*\" } } } } \n+! { dg-final { cleanup-tree-dump \"graphite\" } } "}, {"sha": "c7809d3431b5b6445bc20ae55c3057bc8f7727f9", "filename": "gcc/testsuite/gfortran.dg/graphite/block-3.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-3.f90?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,19 @@\n+! { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } \n+\n+subroutine matrix_multiply(a,b,c,n)\n+\n+real(8), dimension(n,n) :: a,b,c\n+\n+do i = 1,n\n+  do j = 1,n\n+    do k = 1,n\n+      c(j,i) = c(j,i) + a(k,i) * b(j,k)\n+    enddo\n+ enddo\n+enddo\n+\n+end subroutine matrix_multiply\n+\n+! { dg-final { scan-tree-dump-times \"Loop blocked\" 2 \"graphite\" { xfail *-*-* } } } \n+! { dg-final { cleanup-tree-dump \"graphite\" } } \n+"}, {"sha": "586a77725128fc476c3ca5a2c6e860382162dd80", "filename": "gcc/testsuite/gfortran.dg/graphite/block-4.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-4.f90?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,22 @@\n+! { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } \n+\n+subroutine matrix_multiply(a,b,c,n)\n+\n+real(8), dimension(n,n) :: a,b,c\n+\n+! The following code is disabled for the moment.\n+! c=0.d0\n+\n+do i = 1,n\n+  do j = 1,n\n+    do k = 1,n\n+      c(j,i) = c(j,i) + a(k,i) * b(j,k)\n+    enddo\n+ enddo\n+enddo\n+\n+end subroutine matrix_multiply\n+\n+! { dg-final { scan-tree-dump-times \"Loop blocked\" 2 \"graphite\" { xfail *-*-* } } } \n+! { dg-final { cleanup-tree-dump \"graphite\" } } \n+"}, {"sha": "a9fdb2c508fb71325ada91dda812de078950c3e1", "filename": "gcc/testsuite/gfortran.dg/graphite/graphite.exp", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,48 @@\n+#   Copyright (C) 2008 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gfortran-dg.exp\n+\n+if ![check_effective_target_fgraphite] {\n+  return\n+}\n+\n+# The default action for a test is 'compile'.  Save current default.\n+global dg-do-what-default\n+set save-dg-do-what-default ${dg-do-what-default}\n+set dg-do-what-default compile\n+\n+# If a testcase doesn't have special options, use these.\n+set DEFAULT_GRAPHITE_FLAGS \"\"\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+gfortran-dg-runtest [lsort \\\n+       [glob -nocomplain $srcdir/$subdir/*.\\[fF\\]{,90,95,03,08} ] ] $DEFAULT_GRAPHITE_FLAGS\n+\n+gfortran-dg-runtest [lsort \\\n+       [glob -nocomplain $srcdir/$subdir/g77/*.\\[fF\\] ] ] $DEFAULT_GRAPHITE_FLAGS\n+\n+# Clean up.\n+set dg-do-what-default ${save-dg-do-what-default}\n+\n+# All done.\n+dg-finish"}, {"sha": "a279abaf9c2943684445c445011617889b41bada", "filename": "gcc/testsuite/gfortran.dg/graphite/scop-1.f", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fscop-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fscop-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fscop-1.f?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -0,0 +1,13 @@\n+C { dg-options \"-O2 -fgraphite\" }\n+\n+      dimension p1(2),t(6,4),b1(2),b2(2),al1(2),al2(2),g1(2),g2(2)\n+      save\n+      if(nlin.eq.0) then\n+        do 20 l=1,2\n+          ll=2*l\n+          b2(l)=t(6-ll,ll-1)*t(6-ll,ll-1)+t(7-ll,ll-1)*t(7-ll,ll-1)\n+          write(*,*) b2(l)\n+   20   continue\n+      endif\n+      end\n+"}, {"sha": "527d277051a326de27e85c5eebd9708cfb8bac4d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -562,6 +562,15 @@ proc check_effective_target_tls_runtime {} {\n     }]\n }\n \n+# Return 1 if compilation with -fgraphite is error-free for trivial \n+# code, 0 otherwise.\n+\n+proc check_effective_target_fgraphite {} {\n+    return [check_no_compiler_messages fgraphite object {\n+\tvoid foo (void) { }\n+    } \"-fgraphite\"]\n+}\n+\n # Return 1 if compilation with -fopenmp is error-free for trivial\n # code, 0 otherwise.\n "}, {"sha": "4351f17e4b52186f8f77c6f812cea8be1e555ebf", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -125,6 +125,7 @@ DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_PARALLELIZE_LOOPS, \"tree parallelize loops\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree vectorization\")\n+DEFTIMEVAR (TV_GRAPHITE_TRANSFORMS   , \"GRAPHITE loop transforms\")\n DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear\")\n DEFTIMEVAR (TV_TREE_LOOP_DISTRIBUTION, \"tree loop distribution\")\n DEFTIMEVAR (TV_CHECK_DATA_DEPS       , \"tree check data dependences\")"}, {"sha": "f63e67621041e69be6e0a288b59fd009e4b2dc0d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -6140,7 +6140,7 @@ print_loops (FILE *file, int verbosity)\n {\n   basic_block bb;\n \n-  bb = BASIC_BLOCK (NUM_FIXED_BLOCKS);\n+  bb = ENTRY_BLOCK_PTR;\n   if (bb && bb->loop_father)\n     print_loop_and_siblings (file, bb->loop_father, 0, verbosity);\n }"}, {"sha": "26ae9b408a70a2f9c51f5fe8d15419ea658efa17", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -1407,3 +1407,26 @@ scev_direction (const_tree chrec)\n   else\n     return EV_DIR_GROWS;\n }\n+\n+/* Iterates over all the components of SCEV, and calls CBCK.  */\n+\n+void\n+for_each_scev_op (tree *scev, bool (*cbck) (tree *, void *), void *data)\n+{\n+  switch (TREE_CODE_LENGTH (TREE_CODE (*scev)))\n+    {\n+    case 3:\n+      for_each_scev_op (&TREE_OPERAND (*scev, 2), cbck, data);\n+\n+    case 2:\n+      for_each_scev_op (&TREE_OPERAND (*scev, 1), cbck, data);\n+      \n+    case 1:\n+      for_each_scev_op (&TREE_OPERAND (*scev, 0), cbck, data);\n+\n+    default:\n+      cbck (scev, data);\n+      break;\n+    }\n+}\n+"}, {"sha": "d35dcd3064c60a2c538b543c3ed27549d4aee479", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -70,6 +70,7 @@ extern tree evolution_part_in_loop_num (tree, unsigned);\n extern tree hide_evolution_in_other_loops_than_loop (tree, unsigned);\n extern tree reset_evolution_in_loop (unsigned, tree, tree);\n extern tree chrec_merge (tree, tree);\n+extern void for_each_scev_op (tree *, bool (*) (tree *, void *), void *);\n \n /* Observers.  */\n extern bool eq_evolutions_p (const_tree, const_tree);"}, {"sha": "af1146c7fefd2cf624f975eb6aa92213b5b38a6a", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -1224,7 +1224,7 @@ disjoint_objects_p (tree a, tree b)\n /* Returns false if we can prove that data references A and B do not alias,\n    true otherwise.  */\n \n-static bool\n+bool\n dr_may_alias_p (const struct data_reference *a, const struct data_reference *b)\n {\n   const_tree addr_a = DR_BASE_ADDRESS (a);\n@@ -3303,6 +3303,21 @@ access_functions_are_affine_or_constant_p (const struct data_reference *a,\n   return true;\n }\n \n+/* Return true if we can create an affine data-ref for OP in STMT.  */\n+\n+bool\n+stmt_simple_memref_p (struct loop *loop, gimple stmt, tree op)\n+{\n+  data_reference_p dr;\n+\n+  dr = create_data_ref (loop, op, stmt, true);\n+  if (!access_functions_are_affine_or_constant_p (dr, loop))\n+    return false;\n+\n+  free_data_ref (dr);\n+  return true;\n+}\n+\n /* Initializes an equation for an OMEGA problem using the information\n    contained in the ACCESS_FUN.  Returns true when the operation\n    succeeded.\n@@ -4069,9 +4084,9 @@ get_references_in_stmt (gimple stmt, VEC (data_ref_loc, heap) **references)\n \n /* Stores the data references in STMT to DATAREFS.  If there is an unanalyzable\n    reference, returns false, otherwise returns true.  NEST is the outermost\n-   loop of the loop nest in that the references should be analyzed.  */\n+   loop of the loop nest in which the references should be analyzed.  */\n \n-static bool\n+bool\n find_data_references_in_stmt (struct loop *nest, gimple stmt,\n \t\t\t      VEC (data_reference_p, heap) **datarefs)\n {\n@@ -4116,7 +4131,7 @@ find_data_references_in_stmt (struct loop *nest, gimple stmt,\n    TODO: This function should be made smarter so that it can handle address\n    arithmetic as if they were array accesses, etc.  */\n \n-static tree \n+tree \n find_data_references_in_loop (struct loop *loop,\n \t\t\t      VEC (data_reference_p, heap) **datarefs)\n {\n@@ -4644,6 +4659,7 @@ create_rdg_edge_for_ddr (struct graph *rdg, ddr_p ddr)\n   e->data = XNEW (struct rdg_edge);\n \n   RDGE_LEVEL (e) = level;\n+  RDGE_RELATION (e) = ddr;\n \n   /* Determines the type of the data dependence.  */\n   if (DR_IS_READ (dra) && DR_IS_READ (drb))\n@@ -4676,6 +4692,7 @@ create_rdg_edges_for_scalar (struct graph *rdg, tree def, int idef)\n       e = add_edge (rdg, idef, use);\n       e->data = XNEW (struct rdg_edge);\n       RDGE_TYPE (e) = flow_dd;\n+      RDGE_RELATION (e) = NULL;\n     }\n }\n \n@@ -4701,7 +4718,7 @@ create_rdg_edges (struct graph *rdg, VEC (ddr_p, heap) *ddrs)\n \n /* Build the vertices of the reduced dependence graph RDG.  */\n \n-static void\n+void\n create_rdg_vertices (struct graph *rdg, VEC (gimple, heap) *stmts)\n {\n   int i, j;\n@@ -4821,6 +4838,21 @@ hash_stmt_vertex_del (void *e)\n   free (e);\n }\n \n+/* Build the Reduced Dependence Graph (RDG) with one vertex per\n+   statement of the loop nest, and one edge per data dependence or\n+   scalar dependence.  */\n+\n+struct graph *\n+build_empty_rdg (int n_stmts)\n+{\n+  int nb_data_refs = 10;\n+  struct graph *rdg = new_graph (n_stmts);\n+\n+  rdg->indices = htab_create (nb_data_refs, hash_stmt_vertex_info,\n+\t\t\t      eq_stmt_vertex_info, hash_stmt_vertex_del);\n+  return rdg;\n+}\n+\n /* Build the Reduced Dependence Graph (RDG) with one vertex per\n    statement of the loop nest, and one edge per data dependence or\n    scalar dependence.  */\n@@ -4842,21 +4874,23 @@ build_rdg (struct loop *loop)\n                                      &dependence_relations);\n \n   if (!known_dependences_p (dependence_relations))\n-    goto end_rdg;\n+    {\n+      free_dependence_relations (dependence_relations);\n+      free_data_refs (datarefs);\n+      VEC_free (gimple, heap, stmts);\n+\n+      return rdg;\n+    }\n \n   stmts_from_loop (loop, &stmts);\n-  rdg = new_graph (VEC_length (gimple, stmts));\n+  rdg = build_empty_rdg (VEC_length (gimple, stmts));\n \n   rdg->indices = htab_create (nb_data_refs, hash_stmt_vertex_info,\n \t\t\t      eq_stmt_vertex_info, hash_stmt_vertex_del);\n   create_rdg_vertices (rdg, stmts);\n   create_rdg_edges (rdg, dependence_relations);\n \n- end_rdg:\n-  free_dependence_relations (dependence_relations);\n-  free_data_refs (datarefs);\n   VEC_free (gimple, heap, stmts);\n-\n   return rdg;\n }\n "}, {"sha": "ee514c5ee922a7ea18a1149aa7e9a9ae25c6d634", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -96,6 +96,8 @@ struct dr_alias\n   bitmap vops;\n };\n \n+typedef struct scop *scop_p;\n+\n /* Each vector of the access matrix represents a linear access\n    function for a subscript.  First elements correspond to the\n    leftmost indices, ie. for a[i][j] the first vector corresponds to\n@@ -170,16 +172,20 @@ struct data_reference\n   /* Behavior of the memory reference in the innermost loop.  */\n   struct innermost_loop_behavior innermost;\n \n-  /* Decomposition to indices for alias analysis.  */\n+  /* Subscripts of this data reference.  */\n   struct indices indices;\n \n   /* Alias information for the data reference.  */\n   struct dr_alias alias;\n \n+  /* The SCoP in which the data reference was analyzed.  */\n+  scop_p scop;\n+\n   /* Matrix representation for the data access functions.  */\n   struct access_matrix *access_matrix;\n };\n \n+#define DR_SCOP(DR)                (DR)->scop\n #define DR_STMT(DR)                (DR)->stmt\n #define DR_REF(DR)                 (DR)->ref\n #define DR_BASE_OBJECT(DR)         (DR)->indices.base_object\n@@ -373,6 +379,8 @@ void dr_analyze_innermost (struct data_reference *);\n extern bool compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       VEC (data_reference_p, heap) **,\n \t\t\t\t\t       VEC (ddr_p, heap) **);\n+extern tree find_data_references_in_loop (struct loop *, \n+                                          VEC (data_reference_p, heap) **);\n extern void print_direction_vector (FILE *, lambda_vector, int);\n extern void print_dir_vectors (FILE *, VEC (lambda_vector, heap) *, int);\n extern void print_dist_vectors (FILE *, VEC (lambda_vector, heap) *, int);\n@@ -392,10 +400,18 @@ extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (VEC (ddr_p, heap) *);\n extern void free_data_ref (data_reference_p);\n extern void free_data_refs (VEC (data_reference_p, heap) *);\n+extern bool find_data_references_in_stmt (struct loop *, gimple,\n+\t\t\t\t\t  VEC (data_reference_p, heap) **);\n struct data_reference *create_data_ref (struct loop *, tree, gimple, bool);\n-bool find_loop_nest (struct loop *, VEC (loop_p, heap) **);\n-void compute_all_dependences (VEC (data_reference_p, heap) *,\n-\t\t\t      VEC (ddr_p, heap) **, VEC (loop_p, heap) *, bool);\n+extern bool find_loop_nest (struct loop *, VEC (loop_p, heap) **);\n+extern void compute_all_dependences (VEC (data_reference_p, heap) *,\n+\t\t\t\t     VEC (ddr_p, heap) **, VEC (loop_p, heap) *,\n+\t\t\t\t     bool);\n+\n+extern void create_rdg_vertices (struct graph *, VEC (gimple, heap) *);\n+extern bool dr_may_alias_p (const struct data_reference *,\n+\t\t\t    const struct data_reference *);\n+extern bool stmt_simple_memref_p (struct loop *, gimple, tree);\n \n /* Return true when the DDR contains two data references that have the\n    same access functions.  */\n@@ -511,15 +527,21 @@ typedef struct rdg_edge\n   /* Type of the dependence.  */\n   enum rdg_dep_type type;\n \n-  /* Levels of the dependence: the depth of the loops that\n-    carry the dependence.  */\n+  /* Levels of the dependence: the depth of the loops that carry the\n+     dependence.  */\n   unsigned level;\n+\n+  /* Dependence relation between data dependences, NULL when one of\n+     the vertices is a scalar.  */\n+  ddr_p relation;\n } *rdg_edge_p;\n \n #define RDGE_TYPE(E)        ((struct rdg_edge *) ((E)->data))->type\n #define RDGE_LEVEL(E)       ((struct rdg_edge *) ((E)->data))->level\n+#define RDGE_RELATION(E)    ((struct rdg_edge *) ((E)->data))->relation\n \n struct graph *build_rdg (struct loop *);\n+struct graph *build_empty_rdg (int);\n void free_rdg (struct graph *);\n \n /* Return the index of the variable VAR in the LOOP_NEST array.  */\n@@ -561,7 +583,21 @@ void lambda_collect_parameters (VEC (data_reference_p, heap) *,\n bool lambda_compute_access_matrices (VEC (data_reference_p, heap) *,\n \t\t\t\t     VEC (tree, heap) *, int);\n \n-/* In tree-data-refs.c  */\n+/* In tree-data-ref.c  */\n void split_constant_offset (tree , tree *, tree *);\n \n+/* Strongly connected components of the reduced data dependence graph.  */\n+\n+typedef struct rdg_component\n+{\n+  int num;\n+  VEC (int, heap) *vertices;\n+} *rdgc;\n+\n+DEF_VEC_P (rdgc);\n+DEF_VEC_ALLOC_P (rdgc, heap);\n+\n+DEF_VEC_P (bitmap);\n+DEF_VEC_ALLOC_P (bitmap, heap);\n+\n #endif  /* GCC_TREE_DATA_REF_H  */"}, {"sha": "c75afb0d839c5d91e3a51eead442bcbfb6d94bb7", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -786,6 +786,8 @@ extern gimple get_single_def_stmt_with_phi (tree, gimple);\n \n /* In tree-phinodes.c  */\n extern void reserve_phi_args_for_new_edge (basic_block);\n+extern void add_phi_node_to_bb (gimple phi, basic_block bb);\n+extern gimple make_phi_node (tree var, int len);\n extern gimple create_phi_node (tree, basic_block);\n extern void add_phi_arg (gimple, tree, edge);\n extern void remove_phi_args (edge);\n@@ -1023,6 +1025,7 @@ bool gimple_duplicate_loop_to_header_edge (struct loop *, edge,\n \t\t\t\t\t int);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *, edge);\n void rename_variables_in_loop (struct loop *);\n+void rename_variables_in_bb (basic_block bb);\n struct loop *tree_ssa_loop_version (struct loop *, tree,\n \t\t\t\t    basic_block *);\n tree expand_simple_operations (tree);\n@@ -1116,6 +1119,10 @@ bool sra_type_can_be_decomposed_p (tree);\n \n /* In tree-loop-linear.c  */\n extern void linear_transform_loops (void);\n+extern unsigned perfect_loop_nest_depth (struct loop *);\n+\n+/* In graphite.c  */\n+extern void graphite_transform_loops (void);\n \n /* In tree-data-ref.c  */\n extern void tree_check_data_deps (void);"}, {"sha": "928333ba4baaa681ace12ffacd44944c157e258b", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -130,12 +130,6 @@ static bitmap mem_syms_to_rename;\n    released after we finish updating the SSA web.  */\n static bitmap names_to_release;\n \n-/* For each block, the PHI nodes that need to be rewritten are stored into\n-   these vectors.  */\n-typedef VEC(gimple, heap) *gimple_vec;\n-DEF_VEC_P (gimple_vec);\n-DEF_VEC_ALLOC_P (gimple_vec, heap);\n-\n static VEC(gimple_vec, heap) *phis_to_rewrite;\n \n /* The bitmap of non-NULL elements of PHIS_TO_REWRITE.  */"}, {"sha": "ed54cf327305874fe69eb001c54b2c9e199a5ef5", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -710,17 +710,6 @@ rdg_flag_loop_exits (struct graph *rdg, bitmap loops, bitmap partition,\n     }\n }\n \n-/* Strongly connected components of the reduced data dependence graph.  */\n-\n-typedef struct rdg_component\n-{\n-  int num;\n-  VEC (int, heap) *vertices;\n-} *rdgc;\n-\n-DEF_VEC_P (rdgc);\n-DEF_VEC_ALLOC_P (rdgc, heap);\n-\n /* Flag all the nodes of RDG containing memory accesses that could\n    potentially belong to arrays already accessed in the current\n    PARTITION.  */\n@@ -864,9 +853,6 @@ rdg_build_components (struct graph *rdg, VEC (int, heap) *starting_vertices,\n   BITMAP_FREE (saved_components);\n }\n \n-DEF_VEC_P (bitmap);\n-DEF_VEC_ALLOC_P (bitmap, heap);\n-\n /* Aggregate several components into a useful partition that is\n    registered in the PARTITIONS vector.  Partitions will be\n    distributed in different loops.  */"}, {"sha": "7e5f298be16a662a1dea45076d772ac2165de013", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -272,7 +272,7 @@ try_interchange_loops (lambda_trans_matrix trans,\n /* Return the number of nested loops in LOOP_NEST, or 0 if the loops\n    are not perfectly nested.  */\n \n-static unsigned int\n+unsigned int\n perfect_loop_nest_depth (struct loop *loop_nest)\n {\n   struct loop *temp;"}, {"sha": "7fe1510089a9a45a0aefb414a84f9a9a0be07185", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -322,6 +322,7 @@ extern struct gimple_opt_pass pass_iv_canon;\n extern struct gimple_opt_pass pass_scev_cprop;\n extern struct gimple_opt_pass pass_empty_loop;\n extern struct gimple_opt_pass pass_record_bounds;\n+extern struct gimple_opt_pass pass_graphite_transforms;\n extern struct gimple_opt_pass pass_if_conversion;\n extern struct gimple_opt_pass pass_loop_distribution;\n extern struct gimple_opt_pass pass_vectorize;"}, {"sha": "7fd5a8f30cc4092b992ef3fae5ac17c08ed403be", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -202,10 +202,9 @@ ideal_phi_node_len (int len)\n   return new_len;\n }\n \n-\n /* Return a PHI node with LEN argument slots for variable VAR.  */\n \n-static gimple\n+gimple\n make_phi_node (tree var, int len)\n {\n   gimple phi;\n@@ -348,15 +347,12 @@ reserve_phi_args_for_new_edge (basic_block bb)\n     }\n }\n \n+/* Adds PHI to BB.  */\n \n-/* Create a new PHI node for variable VAR at basic block BB.  */\n-\n-gimple\n-create_phi_node (tree var, basic_block bb)\n+void \n+add_phi_node_to_bb (gimple phi, basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n-  gimple phi = make_phi_node (var, EDGE_COUNT (bb->preds));\n-\n   /* Add the new PHI node to the list of PHI nodes for block BB.  */\n   if (phi_nodes (bb) == NULL)\n     set_phi_nodes (bb, gimple_seq_alloc ());\n@@ -367,6 +363,16 @@ create_phi_node (tree var, basic_block bb)\n   /* Associate BB to the PHI node.  */\n   gimple_set_bb (phi, bb);\n \n+}\n+\n+/* Create a new PHI node for variable VAR at basic block BB.  */\n+\n+gimple\n+create_phi_node (tree var, basic_block bb)\n+{\n+  gimple phi = make_phi_node (var, EDGE_COUNT (bb->preds));\n+\n+  add_phi_node_to_bb (phi, bb);\n   return phi;\n }\n "}, {"sha": "341f41cea52215e78d4bd92cb9420e47c649eac5", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -5021,18 +5021,38 @@ create_new_ivs (struct ivopts_data *data, struct iv_ca *set)\n     }\n }\n \n+/* Returns the phi-node in BB with result RESULT.  */\n+\n+static gimple\n+get_phi_with_result (basic_block bb, tree result)\n+{\n+  gimple_stmt_iterator i = gsi_start_phis (bb);\n+\n+  for (; !gsi_end_p (i); gsi_next (&i))\n+    if (gimple_phi_result (gsi_stmt (i)) == result)\n+      return gsi_stmt (i);\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+\n /* Removes statement STMT (real or a phi node).  If INCLUDING_DEFINED_NAME\n    is true, remove also the ssa name defined by the statement.  */\n \n static void\n remove_statement (gimple stmt, bool including_defined_name)\n {\n-  gimple_stmt_iterator bsi = gsi_for_stmt (stmt);\n-\n   if (gimple_code (stmt) == GIMPLE_PHI)\n-    remove_phi_node (&bsi, including_defined_name);\n+    {\n+      gimple bb_phi = get_phi_with_result (gimple_bb (stmt), \n+\t\t\t\t\t gimple_phi_result (stmt));\n+      gimple_stmt_iterator bsi = gsi_for_stmt (bb_phi);\n+      remove_phi_node (&bsi, including_defined_name);\n+    }\n   else\n     {\n+      gimple_stmt_iterator bsi = gsi_for_stmt (stmt);\n       gsi_remove (&bsi, true);\n       release_defs (stmt); \n     }"}, {"sha": "51fc07c558ae042eb5411c31d14d67235c8e3b74", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -287,6 +287,49 @@ struct gimple_opt_pass pass_linear_transform =\n  }\n };\n \n+/* GRAPHITE optimizations.  */\n+\n+static unsigned int\n+graphite_transforms (void)\n+{\n+  if (!current_loops)\n+    return 0;\n+\n+  graphite_transform_loops ();\n+\n+  return 0;\n+}\n+\n+static bool\n+gate_graphite_transforms (void)\n+{\n+  /* Enable -fgraphite pass if any one of the graphite optimization flags \n+     is turned on.  */\n+  if (flag_loop_block || flag_loop_interchange || flag_loop_strip_mine)\n+    flag_graphite = 1;\n+\n+  return flag_graphite != 0;\n+}\n+\n+struct gimple_opt_pass pass_graphite_transforms =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"graphite\",\t\t\t\t/* name */\n+  gate_graphite_transforms,\t\t/* gate */\n+  graphite_transforms,       \t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_GRAPHITE_TRANSFORMS,  \t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_verify_loops\t\t\t/* todo_flags_finish */\n+ }\n+};\n+\n /* Check the correctness of the data dependence analyzers.  */\n \n static unsigned int"}, {"sha": "40d1302c723388f8d39c2dddfd8715e03d847213", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf9252655dcf10da12c8c2769d59658084f50d/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f8bf9252655dcf10da12c8c2769d59658084f50d", "patch": "@@ -201,7 +201,7 @@ rename_use_op (use_operand_p op_p)\n \n /* Renames the variables in basic block BB.  */\n \n-static void\n+void\n rename_variables_in_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;"}]}