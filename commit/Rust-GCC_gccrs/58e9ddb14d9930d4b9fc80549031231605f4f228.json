{"sha": "58e9ddb14d9930d4b9fc80549031231605f4f228", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThlOWRkYjE0ZDk5MzBkNGI5ZmM4MDU0OTAzMTIzMTYwNWY0ZjIyOA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2011-10-12T10:18:17Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2011-10-12T10:18:17Z"}, "message": "arm.h (EMIT_EABI_ATTRIBUTE): New macro.\n\n\t* config/arm/arm.h (EMIT_EABI_ATTRIBUTE): New macro.  Used to\n\temit a .eabi_attribute assembler directive, possibly with a\n\tcomment attached.\n\t* config/arm/arm.c (arm_file_start): Use the new macro.\n\t* config/arm/arm-c.c (arm_output_c_attributes): Likewise.\n\nFrom-SVN: r179844", "tree": {"sha": "27b7ebee9e1f24959f4d44e6f4d4095c9bd6e8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27b7ebee9e1f24959f4d44e6f4d4095c9bd6e8aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58e9ddb14d9930d4b9fc80549031231605f4f228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e9ddb14d9930d4b9fc80549031231605f4f228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58e9ddb14d9930d4b9fc80549031231605f4f228", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e9ddb14d9930d4b9fc80549031231605f4f228/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9bc9ee679959ee61d93ee0d39b7df2235bf0f38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bc9ee679959ee61d93ee0d39b7df2235bf0f38a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bc9ee679959ee61d93ee0d39b7df2235bf0f38a"}], "stats": {"total": 303, "additions": 156, "deletions": 147}, "files": [{"sha": "474bbb4d64f890b2068e6579856f08f473824f99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58e9ddb14d9930d4b9fc80549031231605f4f228/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58e9ddb14d9930d4b9fc80549031231605f4f228/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58e9ddb14d9930d4b9fc80549031231605f4f228", "patch": "@@ -1,3 +1,11 @@\n+2011-10-12  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/arm/arm.h (EMIT_EABI_ATTRIBUTE): New macro.  Used to\n+\temit a .eabi_attribute assembler directive, possibly with a\n+\tcomment attached.\n+\t* config/arm/arm.c (arm_file_start): Use the new macro.\n+\t* config/arm/arm-c.c (arm_output_c_attributes): Likewise.\n+\n 2011-10-12  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/49939"}, {"sha": "cd4cefbc330db0287f7260cc9833d5bfd62f5b33", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58e9ddb14d9930d4b9fc80549031231605f4f228/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58e9ddb14d9930d4b9fc80549031231605f4f228/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=58e9ddb14d9930d4b9fc80549031231605f4f228", "patch": "@@ -1,20 +1,20 @@\n-/* Copyright (C) 2007, 2010 Free Software Foundation, Inc.\n+/* Copyright (C) 2007, 2010, 2011  Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -25,21 +25,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"c-family/c-common.h\"\n \n-\n /* Output C specific EABI object attributes.  These can not be done in\n    arm.c because they require information from the C frontend.  */\n \n-static void arm_output_c_attributes(void)\n+static void\n+arm_output_c_attributes (void)\n {\n-  /* Tag_ABI_PCS_wchar_t.  */\n-  asm_fprintf (asm_out_file, \"\\t.eabi_attribute 18, %d\\n\",\n-\t       (int)(TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT));\n+  EMIT_EABI_ATTRIBUTE (Tag_ABI_PCS_wchar_t, 18,\n+\t\t       (int)(TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT));\n }\n \n \n /* Setup so that common code calls arm_output_c_attributes.  */\n \n-void arm_lang_object_attributes_init(void)\n+void\n+arm_lang_object_attributes_init (void)\n {\n   arm_lang_output_object_attributes_hook = arm_output_c_attributes;\n }"}, {"sha": "ad733dad1d0e6387fb0135e210dbadfd0b7aaa1f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 114, "deletions": 128, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58e9ddb14d9930d4b9fc80549031231605f4f228/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58e9ddb14d9930d4b9fc80549031231605f4f228/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=58e9ddb14d9930d4b9fc80549031231605f4f228", "patch": "@@ -1062,12 +1062,12 @@ arm_set_fixed_optab_libfunc (optab optable, enum machine_mode mode,\n \t\t\t     int num_suffix)\n {\n   char buffer[50];\n-  \n+\n   if (num_suffix == 0)\n     sprintf (buffer, \"__gnu_%s%s\", funcname, modename);\n   else\n     sprintf (buffer, \"__gnu_%s%s%d\", funcname, modename, num_suffix);\n-  \n+\n   set_optab_libfunc (optable, mode, buffer);\n }\n \n@@ -1078,13 +1078,13 @@ arm_set_fixed_conv_libfunc (convert_optab optable, enum machine_mode to,\n {\n   char buffer[50];\n   const char *maybe_suffix_2 = \"\";\n-  \n+\n   /* Follow the logic for selecting a \"2\" suffix in fixed-bit.h.  */\n   if (ALL_FIXED_POINT_MODE_P (from) && ALL_FIXED_POINT_MODE_P (to)\n       && UNSIGNED_FIXED_POINT_MODE_P (from) == UNSIGNED_FIXED_POINT_MODE_P (to)\n       && ALL_FRACT_MODE_P (from) == ALL_FRACT_MODE_P (to))\n     maybe_suffix_2 = \"2\";\n-  \n+\n   sprintf (buffer, \"__gnu_%s%s%s%s\", funcname, fromname, toname,\n \t   maybe_suffix_2);\n \n@@ -1210,11 +1210,11 @@ arm_init_libfuncs (void)\n \t\t\t(arm_fp16_format == ARM_FP16_FORMAT_IEEE\n \t\t\t ? \"__gnu_f2h_ieee\"\n \t\t\t : \"__gnu_f2h_alternative\"));\n-      set_conv_libfunc (sext_optab, SFmode, HFmode, \n+      set_conv_libfunc (sext_optab, SFmode, HFmode,\n \t\t\t(arm_fp16_format == ARM_FP16_FORMAT_IEEE\n \t\t\t ? \"__gnu_h2f_ieee\"\n \t\t\t : \"__gnu_h2f_alternative\"));\n-      \n+\n       /* Arithmetic.  */\n       set_optab_libfunc (add_optab, HFmode, NULL);\n       set_optab_libfunc (sdiv_optab, HFmode, NULL);\n@@ -1380,14 +1380,14 @@ arm_build_builtin_va_list (void)\n {\n   tree va_list_name;\n   tree ap_field;\n-  \n+\n   if (!TARGET_AAPCS_BASED)\n     return std_build_builtin_va_list ();\n \n   /* AAPCS \\S 7.1.4 requires that va_list be a typedef for a type\n      defined as:\n \n-       struct __va_list \n+       struct __va_list\n        {\n \t void *__ap;\n        };\n@@ -1411,7 +1411,7 @@ arm_build_builtin_va_list (void)\n   TYPE_STUB_DECL (va_list_type) = va_list_name;\n   /* Create the __ap field.  */\n   ap_field = build_decl (BUILTINS_LOCATION,\n-\t\t\t FIELD_DECL, \n+\t\t\t FIELD_DECL,\n \t\t\t get_identifier (\"__ap\"),\n \t\t\t ptr_type_node);\n   DECL_ARTIFICIAL (ap_field) = 1;\n@@ -1437,7 +1437,7 @@ arm_extract_valist_ptr (tree valist)\n   if (TARGET_AAPCS_BASED)\n     {\n       tree ap_field = TYPE_FIELDS (TREE_TYPE (valist));\n-      valist = build3 (COMPONENT_REF, TREE_TYPE (ap_field), \n+      valist = build3 (COMPONENT_REF, TREE_TYPE (ap_field),\n \t\t       valist, ap_field, NULL_TREE);\n     }\n \n@@ -1454,7 +1454,7 @@ arm_expand_builtin_va_start (tree valist, rtx nextarg)\n \n /* Implement TARGET_GIMPLIFY_VA_ARG_EXPR.  */\n static tree\n-arm_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p, \n+arm_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t\t\t  gimple_seq *post_p)\n {\n   valist = arm_extract_valist_ptr (valist);\n@@ -2312,7 +2312,7 @@ use_return_insn (int iscond, rtx sibling)\n       if (saved_int_regs != 0 && saved_int_regs != (1 << LR_REGNUM))\n \treturn 0;\n \n-      if (flag_pic \n+      if (flag_pic\n \t  && arm_pic_register != INVALID_REGNUM\n \t  && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n \treturn 0;\n@@ -2368,7 +2368,7 @@ const_ok_for_arm (HOST_WIDE_INT i)\n \n   /* Get the number of trailing zeros.  */\n   lowbit = ffs((int) i) - 1;\n-  \n+\n   /* Only even shifts are allowed in ARM mode so round down to the\n      nearest even number.  */\n   if (TARGET_ARM)\n@@ -2632,10 +2632,10 @@ optimal_immediate_sequence_1 (enum rtx_code code, unsigned HOST_WIDE_INT val,\n \n   /* Try and find a way of doing the job in either two or three\n      instructions.\n-     \n+\n      In ARM mode we can use 8-bit constants, rotated to any 2-bit aligned\n      location.  We start at position I.  This may be the MSB, or\n-     optimial_immediate_sequence may have positioned it at the largest block \n+     optimial_immediate_sequence may have positioned it at the largest block\n      of zeros that are aligned on a 2-bit boundary. We then fill up the temps,\n      wrapping around to the top of the word when we drop off the bottom.\n      In the worst case this code should produce no more than four insns.\n@@ -2684,11 +2684,11 @@ optimal_immediate_sequence_1 (enum rtx_code code, unsigned HOST_WIDE_INT val,\n \n       /* Next, see if we can do a better job with a thumb2 replicated\n \t constant.\n-       \n+\n          We do it this way around to catch the cases like 0x01F001E0 where\n \t two 8-bit immediates would work, but a replicated constant would\n \t make it worse.\n-       \n+\n          TODO: 16-bit constants that don't clear all the bits, but still win.\n          TODO: Arithmetic splitting for set/add/sub, rather than bitwise.  */\n       if (TARGET_THUMB2)\n@@ -2716,7 +2716,7 @@ optimal_immediate_sequence_1 (enum rtx_code code, unsigned HOST_WIDE_INT val,\n \t\t      || (matching_bytes == 2\n \t\t\t  && const_ok_for_op (remainder & ~tmp2, code))))\n \t\t{\n-\t\t  /* At least 3 of the bytes match, and the fourth has at \n+\t\t  /* At least 3 of the bytes match, and the fourth has at\n \t\t     least as many bits set, or two of the bytes match\n \t\t     and it will only require one more insn to finish.  */\n \t\t  result = tmp2;\n@@ -3629,7 +3629,7 @@ arm_libcall_uses_aapcs_base (const_rtx libcall)\n \t\t   convert_optab_libfunc (sfloat_optab, SFmode, DImode));\n       add_libcall (libcall_htab,\n \t\t   convert_optab_libfunc (sfloat_optab, DFmode, DImode));\n-      \n+\n       add_libcall (libcall_htab,\n \t\t   convert_optab_libfunc (ufloat_optab, SFmode, SImode));\n       add_libcall (libcall_htab,\n@@ -3949,7 +3949,7 @@ arm_get_pcs_model (const_tree type, const_tree decl)\n \t (no argument is ever a candidate for a co-processor\n \t register).  */\n       bool base_rules = stdarg_p (type);\n-      \n+\n       if (user_convention)\n \t{\n \t  if (user_pcs > ARM_PCS_AAPCS_LOCAL)\n@@ -3984,7 +3984,7 @@ arm_get_pcs_model (const_tree type, const_tree decl)\n static void\n aapcs_vfp_cum_init (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,\n \t\t    const_tree fntype ATTRIBUTE_UNUSED,\n-\t\t    rtx libcall ATTRIBUTE_UNUSED, \n+\t\t    rtx libcall ATTRIBUTE_UNUSED,\n \t\t    const_tree fndecl ATTRIBUTE_UNUSED)\n {\n   /* Record the unallocated VFP registers.  */\n@@ -4089,7 +4089,7 @@ aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n \n \treturn count;\n       }\n-      \n+\n     case RECORD_TYPE:\n       {\n \tint count = 0;\n@@ -4237,7 +4237,7 @@ aapcs_vfp_is_return_candidate (enum arm_pcs pcs_variant,\n }\n \n static bool\n-aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, enum machine_mode mode, \n+aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n \t\t\t     const_tree type)\n {\n   if (!use_vfp_abi (pcum->pcs_variant, false))\n@@ -4255,7 +4255,7 @@ aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n   int shift = GET_MODE_SIZE (pcum->aapcs_vfp_rmode) / GET_MODE_SIZE (SFmode);\n   unsigned mask = (1 << (shift * pcum->aapcs_vfp_rcount)) - 1;\n   int regno;\n-  \n+\n   for (regno = 0; regno < NUM_VFP_ARG_REGS; regno += shift)\n     if (((pcum->aapcs_vfp_regs_free >> regno) & mask) == mask)\n       {\n@@ -4282,10 +4282,10 @@ aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n \t    par = gen_rtx_PARALLEL (mode, rtvec_alloc (rcount));\n \t    for (i = 0; i < rcount; i++)\n \t      {\n-\t\trtx tmp = gen_rtx_REG (rmode, \n+\t\trtx tmp = gen_rtx_REG (rmode,\n \t\t\t\t       FIRST_VFP_REGNUM + regno + i * rshift);\n \t\ttmp = gen_rtx_EXPR_LIST\n-\t\t  (VOIDmode, tmp, \n+\t\t  (VOIDmode, tmp,\n \t\t   GEN_INT (i * GET_MODE_SIZE (rmode)));\n \t\tXVECEXP (par, 0, i) = tmp;\n \t      }\n@@ -4314,7 +4314,7 @@ aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n       int i;\n       rtx par;\n       int shift;\n-      \n+\n       aapcs_vfp_is_call_or_return_candidate (pcs_variant, mode, type,\n \t\t\t\t\t     &ag_mode, &count);\n \n@@ -4333,7 +4333,7 @@ aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n       for (i = 0; i < count; i++)\n \t{\n \t  rtx tmp = gen_rtx_REG (ag_mode, FIRST_VFP_REGNUM + i * shift);\n-\t  tmp = gen_rtx_EXPR_LIST (VOIDmode, tmp, \n+\t  tmp = gen_rtx_EXPR_LIST (VOIDmode, tmp,\n \t\t\t\t   GEN_INT (i * GET_MODE_SIZE (ag_mode)));\n \t  XVECEXP (par, 0, i) = tmp;\n \t}\n@@ -4370,7 +4370,7 @@ aapcs_vfp_advance (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,\n    and stops after the first match.  If that entry then fails to put\n    the argument into a co-processor register, the argument will go on\n    the stack.  */\n-static struct \n+static struct\n {\n   /* Initialize co-processor related state in CUMULATIVE_ARGS structure.  */\n   void (*cum_init) (CUMULATIVE_ARGS *, const_tree, rtx, const_tree);\n@@ -4406,7 +4406,7 @@ static struct\n #undef AAPCS_CP\n \n static int\n-aapcs_select_call_coproc (CUMULATIVE_ARGS *pcum, enum machine_mode mode, \n+aapcs_select_call_coproc (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n \t\t\t  const_tree type)\n {\n   int i;\n@@ -4446,7 +4446,7 @@ aapcs_select_return_coproc (const_tree type, const_tree fntype)\n       int i;\n \n       for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)\n-\tif (aapcs_cp_arg_layout[i].is_return_candidate (pcs_variant, \n+\tif (aapcs_cp_arg_layout[i].is_return_candidate (pcs_variant,\n \t\t\t\t\t\t\tTYPE_MODE (type),\n \t\t\t\t\t\t\ttype))\n \t  return i;\n@@ -4538,7 +4538,7 @@ aapcs_layout_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n      anonymous argument which is on the stack.  */\n   if (!named)\n     return;\n-  \n+\n   /* Is this a potential co-processor register candidate?  */\n   if (pcum->pcs_variant != ARM_PCS_AAPCS)\n     {\n@@ -4638,7 +4638,7 @@ arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n     {\n       if (arm_libcall_uses_aapcs_base (libname))\n \tpcum->pcs_variant = ARM_PCS_AAPCS;\n- \n+\n       pcum->aapcs_ncrn = pcum->aapcs_next_ncrn = 0;\n       pcum->aapcs_reg = NULL_RTX;\n       pcum->aapcs_partial = 0;\n@@ -5685,7 +5685,7 @@ thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n {\n   bool use_ldrd;\n   enum rtx_code code = GET_CODE (x);\n-  \n+\n   if (arm_address_register_rtx_p (x, strict_p))\n     return 1;\n \n@@ -5713,7 +5713,7 @@ thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n       offset = INTVAL(addend);\n       if (GET_MODE_SIZE (mode) <= 4)\n \treturn (offset > -256 && offset < 256);\n-      \n+\n       return (use_ldrd && offset > -1024 && offset < 1024\n \t      && (offset & 3) == 0);\n     }\n@@ -5869,14 +5869,14 @@ static bool\n thumb2_index_mul_operand (rtx op)\n {\n   HOST_WIDE_INT val;\n-  \n+\n   if (GET_CODE(op) != CONST_INT)\n     return false;\n \n   val = INTVAL(op);\n   return (val == 1 || val == 2 || val == 4 || val == 8);\n }\n-  \n+\n /* Return nonzero if INDEX is a valid Thumb-2 address index operand.  */\n static int\n thumb2_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n@@ -6224,11 +6224,11 @@ arm_call_tls_get_addr (rtx x, rtx reg, rtx *valuep, int reloc)\n     emit_insn (gen_pic_add_dot_plus_eight (reg, reg, labelno));\n   else\n     emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));\n-  \n+\n   *valuep = emit_library_call_value (get_tls_get_addr (), NULL_RTX,\n \t\t\t\t     LCT_PURE, /* LCT_CONST?  */\n \t\t\t\t     Pmode, 1, reg, Pmode);\n-  \n+\n   insns = get_insns ();\n   end_sequence ();\n \n@@ -6246,7 +6246,7 @@ arm_tls_descseq_addr (rtx x, rtx reg)\n \t\t\t\t       GEN_INT (!TARGET_ARM)),\n \t\t\t    UNSPEC_TLS);\n   rtx reg0 = load_tls_operand (sum, gen_rtx_REG (SImode, 0));\n-  \n+\n   emit_insn (gen_tlscall (x, labelno));\n   if (!reg)\n     reg = gen_reg_rtx (SImode);\n@@ -6272,7 +6272,7 @@ legitimize_tls_address (rtx x, rtx reg)\n \t  reg = arm_tls_descseq_addr (x, reg);\n \n \t  tp = arm_load_tp (NULL_RTX);\n-\t  \n+\n \t  dest = gen_rtx_PLUS (Pmode, tp, reg);\n \t}\n       else\n@@ -6290,20 +6290,20 @@ legitimize_tls_address (rtx x, rtx reg)\n \t  reg = arm_tls_descseq_addr (x, reg);\n \n \t  tp = arm_load_tp (NULL_RTX);\n-\t  \n+\n \t  dest = gen_rtx_PLUS (Pmode, tp, reg);\n \t}\n       else\n \t{\n \t  insns = arm_call_tls_get_addr (x, reg, &ret, TLS_LDM32);\n-\t  \n+\n \t  /* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n \t     share the LDM result with other LD model accesses.  */\n \t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const1_rtx),\n \t\t\t\tUNSPEC_TLS);\n \t  dest = gen_reg_rtx (Pmode);\n \t  emit_libcall_block (insns, dest, ret, eqv);\n-\t  \n+\n \t  /* Load the addend.  */\n \t  addend = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x,\n \t\t\t\t\t\t     GEN_INT (TLS_LDO32)),\n@@ -7428,7 +7428,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), subcode, 0, speed);\n \t  return true;\n \t}\n-      \n+\n       return false;\n \n     case UMIN:\n@@ -8338,9 +8338,9 @@ cortex_a9_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n \t  {\n \t    if (GET_CODE (PATTERN (insn)) == SET)\n \t      {\n-\t\tif (GET_MODE_CLASS \n+\t\tif (GET_MODE_CLASS\n \t\t    (GET_MODE (SET_DEST (PATTERN (insn)))) == MODE_FLOAT\n-\t\t  || GET_MODE_CLASS \n+\t\t  || GET_MODE_CLASS\n \t\t    (GET_MODE (SET_SRC (PATTERN (insn)))) == MODE_FLOAT)\n \t\t  {\n \t\t    enum attr_type attr_type_insn = get_attr_type (insn);\n@@ -8360,7 +8360,7 @@ cortex_a9_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n \t\t      {\n \t\t\t/* FMACS is a special case where the dependant\n \t\t\t   instruction can be issued 3 cycles before\n-\t\t\t   the normal latency in case of an output \n+\t\t\t   the normal latency in case of an output\n \t\t\t   dependency.  */\n \t\t\tif ((attr_type_insn == TYPE_FMACS\n \t\t\t     || attr_type_insn == TYPE_FMACD)\n@@ -8428,8 +8428,8 @@ fa726te_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n    It corrects the value of COST based on the relationship between\n    INSN and DEP through the dependence LINK.  It returns the new\n    value. There is a per-core adjust_cost hook to adjust scheduler costs\n-   and the per-core hook can choose to completely override the generic \n-   adjust_cost function. Only put bits of code into arm_adjust_cost that \n+   and the per-core hook can choose to completely override the generic\n+   adjust_cost function. Only put bits of code into arm_adjust_cost that\n    are common across all cores.  */\n static int\n arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n@@ -8473,7 +8473,7 @@ arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n \t constant pool are cached, and that others will miss.  This is a\n \t hack.  */\n \n-      if ((GET_CODE (src_mem) == SYMBOL_REF \n+      if ((GET_CODE (src_mem) == SYMBOL_REF\n \t   && CONSTANT_POOL_ADDRESS_P (src_mem))\n \t  || reg_mentioned_p (stack_pointer_rtx, src_mem)\n \t  || reg_mentioned_p (frame_pointer_rtx, src_mem)\n@@ -9868,7 +9868,7 @@ arm_cannot_copy_insn_p (rtx insn)\n      word.  */\n   if (recog_memoized (insn) == CODE_FOR_tlscall)\n     return true;\n-  \n+\n   return for_each_rtx (&PATTERN (insn), arm_note_pic_base, NULL);\n }\n \n@@ -11097,7 +11097,7 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \n   /* A compare with a shifted operand.  Because of canonicalization, the\n      comparison will have to be swapped when we emit the assembler.  */\n-  if (GET_MODE (y) == SImode \n+  if (GET_MODE (y) == SImode\n       && (REG_P (y) || (GET_CODE (y) == SUBREG))\n       && (GET_CODE (x) == ASHIFT || GET_CODE (x) == ASHIFTRT\n \t  || GET_CODE (x) == LSHIFTRT || GET_CODE (x) == ROTATE\n@@ -11106,7 +11106,7 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \n   /* This operation is performed swapped, but since we only rely on the Z\n      flag we don't need an additional mode.  */\n-  if (GET_MODE (y) == SImode \n+  if (GET_MODE (y) == SImode\n       && (REG_P (y) || (GET_CODE (y) == SUBREG))\n       && GET_CODE (x) == NEG\n       && (op ==\tEQ || op == NE))\n@@ -12456,7 +12456,7 @@ create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)\n \t     still put the pool after the table.  */\n \t  new_cost = arm_barrier_cost (from);\n \n-\t  if (count < max_count \n+\t  if (count < max_count\n \t      && (!selected || new_cost <= selected_cost))\n \t    {\n \t      selected = tmp;\n@@ -12838,7 +12838,7 @@ arm_reorg (void)\n \n   if (TARGET_THUMB2)\n     thumb2_reorg ();\n-  \n+\n   minipool_fix_head = minipool_fix_tail = NULL;\n \n   /* The first insn must always be a note, or the code below won't\n@@ -13452,7 +13452,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n   if (count)\n     *count = 1;\n \n-  /* The only case when this might happen is when \n+  /* The only case when this might happen is when\n      you are looking at the length of a DImode instruction\n      that has an invalid constant in it.  */\n   if (code0 == REG && code1 != MEM)\n@@ -13461,7 +13461,6 @@ output_move_double (rtx *operands, bool emit, int *count)\n       *count = 2;\n       return \"\";\n     }\n-      \n \n   if (code0 == REG)\n     {\n@@ -13489,7 +13488,6 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t  gcc_assert (TARGET_LDRD);\n \t  if (emit)\n \t    output_asm_insn (\"ldr%(d%)\\t%0, [%m1, #8]!\", operands);\n-\t  \n \t  break;\n \n \tcase PRE_DEC:\n@@ -13503,7 +13501,6 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t  break;\n \n \tcase POST_INC:\n-\t  \n \t  if (emit)\n \t    {\n \t      if (TARGET_LDRD)\n@@ -13692,15 +13689,14 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t    }\n \n \t\t  if (GET_CODE (otherops[2]) == CONST_INT)\n-\t\t    {\t\t\t\t\t\t\t\n+\t\t    {\n \t\t      if (emit)\n \t\t\t{\n \t\t\t  if (!(const_ok_for_arm (INTVAL (otherops[2]))))\n \t\t\t    output_asm_insn (\"sub%?\\t%0, %1, #%n2\", otherops);\n \t\t\t  else\n \t\t\t    output_asm_insn (\"add%?\\t%0, %1, %2\", otherops);\n \t\t\t}\n-\t\t\t\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -13716,8 +13712,8 @@ output_move_double (rtx *operands, bool emit, int *count)\n \n \t      if (TARGET_LDRD)\n \t\treturn \"ldr%(d%)\\t%0, [%1]\";\n-\t      \n-\t\treturn \"ldm%(ia%)\\t%1, %M0\";\n+\n+\t      return \"ldm%(ia%)\\t%1, %M0\";\n \t    }\n \t  else\n \t    {\n@@ -13894,7 +13890,6 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t    }\n \t  if (count)\n \t    *count = 2;\n-\n \t}\n     }\n \n@@ -14104,7 +14099,7 @@ output_move_neon (rtx *operands)\n       ops[0] = XEXP (addr, 0);\n       ops[1] = reg;\n       break;\n-    \n+\n     case POST_MODIFY:\n       /* FIXME: Not currently enabled in neon_vector_mem_operand.  */\n       gcc_unreachable ();\n@@ -14596,7 +14591,7 @@ arm_compute_save_reg0_reg12_mask (void)\n }\n \n \n-/* Compute the number of bytes used to store the static chain register on the \n+/* Compute the number of bytes used to store the static chain register on the\n    stack, above the stack frame. We need to know this accurately to get the\n    alignment of the rest of the stack frame correct. */\n \n@@ -14935,7 +14930,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t\t     then try to pop r3 instead.  */\n \t\t  if (stack_adjust)\n \t\t    live_regs_mask |= 1 << 3;\n-\t\t  \n+\n \t\t  if (TARGET_UNIFIED_ASM)\n \t\t    sprintf (instr, \"ldmfd%s\\t%%|sp, {\", conditional);\n \t\t  else\n@@ -15149,7 +15144,7 @@ arm_output_epilogue (rtx sibling)\n \n   /* If we have already generated the return instruction\n      then it is futile to generate anything else.  */\n-  if (use_return_insn (FALSE, sibling) && \n+  if (use_return_insn (FALSE, sibling) &&\n       (cfun->machine->return_used_this_function != 0))\n     return \"\";\n \n@@ -15357,7 +15352,7 @@ arm_output_epilogue (rtx sibling)\n \t{\n \t  operands[0] = stack_pointer_rtx;\n \t  operands[1] = hard_frame_pointer_rtx;\n-\t  \n+\n \t  operands[2] = GEN_INT (offsets->frame - offsets->saved_regs);\n \t  output_add_immediate (operands);\n \t}\n@@ -15405,7 +15400,7 @@ arm_output_epilogue (rtx sibling)\n \t\t  }\n \t\t}\n \t    }\n-\t  \n+\n \t  if (amount)\n \t    {\n \t      operands[1] = operands[0];\n@@ -16037,7 +16032,7 @@ arm_get_frame_offsets (void)\n \t{\n \t  int reg = -1;\n \n-\t  /* If it is safe to use r3, then do so.  This sometimes \n+\t  /* If it is safe to use r3, then do so.  This sometimes\n \t     generates better code on Thumb-2 by avoiding the need to\n \t     use 32-bit push/pop instructions.  */\n  \t  if (! any_sibcall_uses_r3 ()\n@@ -16483,7 +16478,7 @@ arm_expand_prologue (void)\n       && TARGET_ARM)\n     {\n       rtx lr = gen_rtx_REG (SImode, LR_REGNUM);\n-      \n+\n       emit_set_insn (lr, plus_constant (lr, -4));\n     }\n \n@@ -16694,7 +16689,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       if (TARGET_UNIFIED_ASM)\n \tarm_print_condition (stream);\n       break;\n-  \n+\n     case '.':\n       /* The current condition code for a condition code setting instruction.\n \t Preceded by 's' in unified syntax, otherwise followed by 's'.  */\n@@ -17221,7 +17216,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t   of the target.  */\n \talign = MEM_ALIGN (x) >> 3;\n \tmemsize = MEM_SIZE (x);\n-\t\n+\n \t/* Only certain alignment specifiers are supported by the hardware.  */\n \tif (memsize == 16 && (align % 32) == 0)\n \t  align_bits = 256;\n@@ -17231,7 +17226,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t  align_bits = 64;\n \telse\n \t  align_bits = 0;\n-\t\n+\n \tif (align_bits != 0)\n \t  asm_fprintf (stream, \":%d\", align_bits);\n \n@@ -17301,7 +17296,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \tfprintf (stream, \"d%d[%d]\", regno/2, ((regno % 2) ? 2 : 0));\n       }\n       return;\n-      \n+\n     default:\n       if (x == 0)\n \t{\n@@ -17340,7 +17335,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t      fputs (\":lower16:\", stream);\n \t      x = XEXP (x, 0);\n \t    }\n-\t    \n+\n \t  output_addr_const (stream, x);\n \t  break;\n \t}\n@@ -17554,8 +17549,8 @@ arm_elf_asm_cdtor (rtx symbol, int priority, bool is_ctor)\n \n   if (!TARGET_AAPCS_BASED)\n     {\n-      (is_ctor ? \n-       default_named_section_asm_out_constructor \n+      (is_ctor ?\n+       default_named_section_asm_out_constructor\n        : default_named_section_asm_out_destructor) (symbol, priority);\n       return;\n     }\n@@ -17564,7 +17559,7 @@ arm_elf_asm_cdtor (rtx symbol, int priority, bool is_ctor)\n   if (priority != DEFAULT_INIT_PRIORITY)\n     {\n       char buf[18];\n-      sprintf (buf, \"%s.%.5u\", \n+      sprintf (buf, \"%s.%.5u\",\n \t       is_ctor ? \".init_array\" : \".fini_array\",\n \t       priority);\n       s = get_section (buf, SECTION_WRITE, NULL_TREE);\n@@ -17638,6 +17633,7 @@ arm_elf_asm_destructor (rtx symbol, int priority)\n /* Returns the index of the ARM condition code string in\n    `arm_condition_codes', or ARM_NV if the comparison is invalid.\n    COMPARISON should be an rtx like `(eq (...) (...))'.  */\n+\n enum arm_cond_code\n maybe_get_arm_condition_code (rtx comparison)\n {\n@@ -18255,7 +18251,7 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n       if (IS_IWMMXT_REGNUM (regno))\n \treturn VALID_IWMMXT_REG_MODE (mode);\n     }\n-  \n+\n   /* We allow almost any value to be stored in the general registers.\n      Restrict doubleword quantities to even register pairs so that we can\n      use ldrd.  Do not allow very large Neon structure opaque modes in\n@@ -19440,7 +19436,7 @@ arm_init_neon_builtins (void)\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n-  \n+\n struct builtin_description\n {\n   const unsigned int       mask;\n@@ -19456,7 +19452,7 @@ static const struct builtin_description bdesc_2arg[] =\n #define IWMMXT_BUILTIN(code, string, builtin) \\\n   { FL_IWMMXT, CODE_FOR_##code, \"__builtin_arm_\" string, \\\n     ARM_BUILTIN_##builtin, UNKNOWN, 0 },\n-  \n+\n   IWMMXT_BUILTIN (addv8qi3, \"waddb\", WADDB)\n   IWMMXT_BUILTIN (addv4hi3, \"waddh\", WADDH)\n   IWMMXT_BUILTIN (addv2si3, \"waddw\", WADDW)\n@@ -19515,10 +19511,10 @@ static const struct builtin_description bdesc_2arg[] =\n   IWMMXT_BUILTIN (iwmmxt_wunpckihw, \"wunpckihw\", WUNPCKIHW)\n   IWMMXT_BUILTIN (iwmmxt_wmadds, \"wmadds\", WMADDS)\n   IWMMXT_BUILTIN (iwmmxt_wmaddu, \"wmaddu\", WMADDU)\n-  \n+\n #define IWMMXT_BUILTIN2(code, builtin) \\\n   { FL_IWMMXT, CODE_FOR_##code, NULL, ARM_BUILTIN_##builtin, UNKNOWN, 0 },\n-  \n+\n   IWMMXT_BUILTIN2 (iwmmxt_wpackhss, WPACKHSS)\n   IWMMXT_BUILTIN2 (iwmmxt_wpackwss, WPACKWSS)\n   IWMMXT_BUILTIN2 (iwmmxt_wpackdss, WPACKDSS)\n@@ -19552,7 +19548,7 @@ static const struct builtin_description bdesc_2arg[] =\n   IWMMXT_BUILTIN2 (iwmmxt_wmacuz,   WMACUZ)\n   IWMMXT_BUILTIN2 (iwmmxt_wmacsz,   WMACSZ)\n };\n-  \n+\n static const struct builtin_description bdesc_1arg[] =\n {\n   IWMMXT_BUILTIN (iwmmxt_tmovmskb, \"tmovmskb\", TMOVMSKB)\n@@ -19574,7 +19570,7 @@ static const struct builtin_description bdesc_1arg[] =\n   IWMMXT_BUILTIN (iwmmxt_wunpckelsh, \"wunpckelsh\", WUNPCKELSH)\n   IWMMXT_BUILTIN (iwmmxt_wunpckelsw, \"wunpckelsw\", WUNPCKELSW)\n };\n-  \n+\n /* Set up all the iWMMXt builtins.  This is not called if\n    TARGET_IWMMXT is zero.  */\n \n@@ -19698,7 +19694,7 @@ arm_init_iwmmxt_builtins (void)\n     = build_function_type_list (long_long_unsigned_type_node,\n \t\t\t\tV4HI_type_node,V4HI_type_node,\n \t\t\t\tNULL_TREE);\n-  \n+\n   /* Normal vector binops.  */\n   tree v8qi_ftype_v8qi_v8qi\n     = build_function_type_list (V8QI_type_node,\n@@ -19714,7 +19710,7 @@ arm_init_iwmmxt_builtins (void)\n \t\t\t\tlong_long_unsigned_type_node,\n \t\t\t\tlong_long_unsigned_type_node,\n \t\t\t\tNULL_TREE);\n-  \n+\n   /* Add all builtins that are more or less simple operations on two\n      operands.  */\n   for (i = 0, d = bdesc_2arg; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n@@ -20669,7 +20665,7 @@ number_of_first_bit_set (unsigned mask)\n   return ctz_hwi (mask);\n }\n \n-/* Like emit_multi_reg_push, but allowing for a different set of \n+/* Like emit_multi_reg_push, but allowing for a different set of\n    registers to be described as saved.  MASK is the set of registers\n    to be saved; REAL_REGS is the set of registers to be described as\n    saved.  If REAL_REGS is 0, only describe the stack adjustment.  */\n@@ -22291,9 +22287,9 @@ arm_file_start (void)\n \t  if (arm_fpu_desc->model == ARM_FP_MODEL_VFP)\n \t    {\n \t      if (TARGET_HARD_FLOAT)\n-\t\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 27, 3\\n\");\n+\t\tEMIT_EABI_ATTRIBUTE (Tag_ABI_HardFP_use, 27, 3);\n \t      if (TARGET_HARD_FLOAT_ABI)\n-\t\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 28, 1\\n\");\n+\t\tEMIT_EABI_ATTRIBUTE (Tag_ABI_VFP_args, 28, 1);\n \t    }\n \t}\n       asm_fprintf (asm_out_file, \"\\t.fpu %s\\n\", fpu_name);\n@@ -22302,30 +22298,23 @@ arm_file_start (void)\n          are used.  However we don't have any easy way of figuring this out.\n \t Conservatively record the setting that would have been used.  */\n \n-      /* Tag_ABI_FP_rounding.  */\n       if (flag_rounding_math)\n-\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 19, 1\\n\");\n+\tEMIT_EABI_ATTRIBUTE (Tag_ABI_FP_rounding, 19, 1);\n+\n       if (!flag_unsafe_math_optimizations)\n \t{\n-\t  /* Tag_ABI_FP_denomal.  */\n-\t  asm_fprintf (asm_out_file, \"\\t.eabi_attribute 20, 1\\n\");\n-\t  /* Tag_ABI_FP_exceptions.  */\n-\t  asm_fprintf (asm_out_file, \"\\t.eabi_attribute 21, 1\\n\");\n+\t  EMIT_EABI_ATTRIBUTE (Tag_ABI_FP_denormal, 20, 1);\n+\t  EMIT_EABI_ATTRIBUTE (Tag_ABI_FP_exceptions, 21, 1);\n \t}\n-      /* Tag_ABI_FP_user_exceptions.  */\n       if (flag_signaling_nans)\n-\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 22, 1\\n\");\n-      /* Tag_ABI_FP_number_model.  */\n-      asm_fprintf (asm_out_file, \"\\t.eabi_attribute 23, %d\\n\", \n-\t\t   flag_finite_math_only ? 1 : 3);\n-\n-      /* Tag_ABI_align8_needed.  */\n-      asm_fprintf (asm_out_file, \"\\t.eabi_attribute 24, 1\\n\");\n-      /* Tag_ABI_align8_preserved.  */\n-      asm_fprintf (asm_out_file, \"\\t.eabi_attribute 25, 1\\n\");\n-      /* Tag_ABI_enum_size.  */\n-      asm_fprintf (asm_out_file, \"\\t.eabi_attribute 26, %d\\n\",\n-\t\t   flag_short_enums ? 1 : 2);\n+\tEMIT_EABI_ATTRIBUTE (Tag_ABI_FP_user_exceptions, 22, 1);\n+\n+      EMIT_EABI_ATTRIBUTE (Tag_ABI_FP_number_model, 23,\n+\t\t\t   flag_finite_math_only ? 1 : 3);\n+\n+      EMIT_EABI_ATTRIBUTE (Tag_ABI_align8_needed, 24, 1);\n+      EMIT_EABI_ATTRIBUTE (Tag_ABI_align8_preserved, 25, 1);\n+      EMIT_EABI_ATTRIBUTE (Tag_ABI_enum_size, 26, flag_short_enums ? 1 : 2);\n \n       /* Tag_ABI_optimization_goals.  */\n       if (optimize_size)\n@@ -22336,21 +22325,18 @@ arm_file_start (void)\n \tval = 1;\n       else\n \tval = 6;\n-      asm_fprintf (asm_out_file, \"\\t.eabi_attribute 30, %d\\n\", val);\n+      EMIT_EABI_ATTRIBUTE (Tag_ABI_optimization_goals, 30, val);\n \n-      /* Tag_CPU_unaligned_access.  */\n-      asm_fprintf (asm_out_file, \"\\t.eabi_attribute 34, %d\\n\",\n-\t\t   unaligned_access);\n+      EMIT_EABI_ATTRIBUTE (Tag_CPU_unaligned_access, 34, unaligned_access);\n \n-      /* Tag_ABI_FP_16bit_format.  */\n       if (arm_fp16_format)\n-\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 38, %d\\n\",\n-\t\t     (int)arm_fp16_format);\n+\tEMIT_EABI_ATTRIBUTE (Tag_ABI_FP_16bit_format, 38, (int) arm_fp16_format);\n \n       if (arm_lang_output_object_attributes_hook)\n \tarm_lang_output_object_attributes_hook();\n     }\n-  default_file_start();\n+\n+  default_file_start ();\n }\n \n static void\n@@ -22638,7 +22624,7 @@ arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   int nregs;\n-  \n+\n   cfun->machine->uses_anonymous_args = 1;\n   if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n     {\n@@ -22648,7 +22634,7 @@ arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n     }\n   else\n     nregs = pcum->nregs;\n-  \n+\n   if (nregs < NUM_ARG_REGS)\n     *pretend_size = (NUM_ARG_REGS - nregs) * UNITS_PER_WORD;\n }\n@@ -23148,7 +23134,7 @@ arm_preferred_simd_mode (enum machine_mode mode)\n }\n \n /* Implement TARGET_CLASS_LIKELY_SPILLED_P.\n- \n+\n    We need to define this for LO_REGS on Thumb-1.  Otherwise we can end up\n    using r0-r4 for function arguments, r7 for the stack frame and don't have\n    enough left over to do doubleword arithmetic.  For Thumb-2 all the\n@@ -23716,7 +23702,7 @@ arm_output_shift(rtx * operands, int set_flags)\n   const char *shift;\n   HOST_WIDE_INT val;\n   char c;\n-  \n+\n   c = flag_chars[set_flags];\n   if (TARGET_UNIFIED_ASM)\n     {\n@@ -23747,10 +23733,10 @@ thumb1_output_casesi (rtx *operands)\n   switch (GET_MODE(diff_vec))\n     {\n     case QImode:\n-      return (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned ? \n+      return (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned ?\n \t      \"bl\\t%___gnu_thumb1_case_uqi\" : \"bl\\t%___gnu_thumb1_case_sqi\");\n     case HImode:\n-      return (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned ? \n+      return (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned ?\n \t      \"bl\\t%___gnu_thumb1_case_uhi\" : \"bl\\t%___gnu_thumb1_case_shi\");\n     case SImode:\n       return \"bl\\t%___gnu_thumb1_case_si\";\n@@ -23859,7 +23845,7 @@ arm_mangle_type (const_tree type)\n \n   /* The ARM ABI documents (10th October 2008) say that \"__va_list\"\n      has to be managled as if it is in the \"std\" namespace.  */\n-  if (TARGET_AAPCS_BASED \n+  if (TARGET_AAPCS_BASED\n       && lang_hooks.types_compatible_p (CONST_CAST_TREE (type), va_list_type))\n     {\n       static bool warned;\n@@ -24385,7 +24371,7 @@ arm_builtin_support_vector_misalignment (enum machine_mode mode,\n \t packed access.  */\n       return ((misalignment % align) == 0);\n     }\n-  \n+\n   return default_builtin_support_vector_misalignment (mode, type, misalignment,\n \t\t\t\t\t\t      is_packed);\n }"}, {"sha": "8ce2b3e3e97cde7668fd8db5ff0d7004c8d1164e", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58e9ddb14d9930d4b9fc80549031231605f4f228/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58e9ddb14d9930d4b9fc80549031231605f4f228/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=58e9ddb14d9930d4b9fc80549031231605f4f228", "patch": "@@ -2235,4 +2235,19 @@ extern int making_const_table;\n    \" %{mcpu=generic-*:-march=%*;\"\t\t\t\t\\\n    \"   :%{mcpu=*:-mcpu=%*} %{march=*:-march=%*}}\"\n \n+/* This macro is used to emit an EABI tag and its associated value.\n+   We emit the numerical value of the tag in case the assembler does not\n+   support textual tags.  (Eg gas prior to 2.20).  If requested we include\n+   the tag name in a comment so that anyone reading the assembler output\n+   will know which tag is being set.  */\n+#define EMIT_EABI_ATTRIBUTE(NAME,NUM,VAL)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      asm_fprintf (asm_out_file, \"\\t.eabi_attribute %d, %d\", NUM, VAL); \\\n+      if (flag_verbose_asm || flag_debug_asm)\t\t\t\t\\\n+\tasm_fprintf (asm_out_file, \"\\t%s \" #NAME, ASM_COMMENT_START);\t\\\n+      asm_fprintf (asm_out_file, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n #endif /* ! GCC_ARM_H */"}]}