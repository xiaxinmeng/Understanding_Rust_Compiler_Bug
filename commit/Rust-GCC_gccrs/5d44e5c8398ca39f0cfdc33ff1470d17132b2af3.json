{"sha": "5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ0NGU1YzgzOThjYTM5ZjBjZmRjMzNmZjE0NzBkMTcxMzJiMmFmMw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-09-10T06:01:50Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-09-10T06:01:50Z"}, "message": "re PR fortran/45186 (Gfortran 4.5.0 emits wrong linenumbers)\n\n2010-09-10  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45186\n        * trans.h (build1_stat_loc, build2_stat_loc, build3_stat_loc,\n        build4_stat_loc): New inline functions.\n        (build1_loc, build2_loc, build3_loc, build4_loc): New macros.\n        (build1_v, build2_v, build3_v, build4_v): Use input_location\n        as locus.\n        * trans-array.c (gfc_trans_scalarized_loop_end,\n        gfc_conv_array_parameter): Replace build[1-4] by build[1-4]_loc.\n        * trans.c (gfc_build_addr_expr, gfc_build_array_ref,\n        gfc_finish_wrapped_block): Ditto.\n        * trans-decl.c (gfc_init_default_dt, init_intent_out_dt): Ditto.\n        * trans-expr.c (gfc_conv_missing_dummy,\n        gfc_trans_alloc_subarray_assign, gfc_trans_zero_assign): Ditto.\n        * trans-openmp.c (gfc_omp_clause_default_ctor,\n        gfc_trans_omp_critical, gfc_trans_omp_parallel,\n        gfc_trans_omp_parallel_do, gfc_trans_omp_parallel_sections,\n        gfc_trans_omp_parallel_workshare, gfc_trans_omp_sections\n        gfc_trans_omp_single, gfc_trans_omp_task,\n        gfc_trans_omp_workshare): Ditto.\n\nFrom-SVN: r164143", "tree": {"sha": "46dfd2506be1556f07f9559109074d19c8c2de57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46dfd2506be1556f07f9559109074d19c8c2de57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63d1822fccfef3fc2f35392386b894604cbca465", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d1822fccfef3fc2f35392386b894604cbca465", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d1822fccfef3fc2f35392386b894604cbca465"}], "stats": {"total": 173, "additions": 128, "deletions": 45}, "files": [{"sha": "f7f5272f0d9205bacd0381ad103d0ff775b75d4f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "patch": "@@ -1,3 +1,25 @@\n+2010-09-10  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/45186\n+\t* trans.h (build1_stat_loc, build2_stat_loc, build3_stat_loc,\n+\tbuild4_stat_loc): New inline functions.\n+\t(build1_loc, build2_loc, build3_loc, build4_loc): New macros.\n+\t(build1_v, build2_v, build3_v, build4_v): Use input_location\n+\tas locus.\n+\t* trans-array.c (gfc_trans_scalarized_loop_end,\n+\tgfc_conv_array_parameter): Replace build[1-4] by build[1-4]_loc.\n+\t* trans.c (gfc_build_addr_expr, gfc_build_array_ref,\n+\tgfc_finish_wrapped_block): Ditto.\n+\t* trans-decl.c (gfc_init_default_dt, init_intent_out_dt): Ditto.\n+\t* trans-expr.c (gfc_conv_missing_dummy,\n+\tgfc_trans_alloc_subarray_assign, gfc_trans_zero_assign): Ditto.\n+\t* trans-openmp.c (gfc_omp_clause_default_ctor,\n+\tgfc_trans_omp_critical, gfc_trans_omp_parallel,\n+\tgfc_trans_omp_parallel_do, gfc_trans_omp_parallel_sections,\n+\tgfc_trans_omp_parallel_workshare, gfc_trans_omp_sections\n+\tgfc_trans_omp_single, gfc_trans_omp_task,\n+\tgfc_trans_omp_workshare): Ditto.\n+\n 2010-09-09  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* fortran/expr.c (check_inquiry): OPTIONAL attribute is not allowed"}, {"sha": "44c47d776cdb57adb66dcb700ce30ee5d526b625", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "patch": "@@ -2944,12 +2944,14 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n \t\t\t\t\t loop->from[n]);\n       OMP_FOR_INIT (stmt) = init;\n       /* The exit condition.  */\n-      TREE_VEC_ELT (cond, 0) = build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t       loop->loopvar[n], loop->to[n]);\n+      TREE_VEC_ELT (cond, 0) = build2_loc (input_location, LE_EXPR,\n+\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   loop->loopvar[n], loop->to[n]);\n+      SET_EXPR_LOCATION (TREE_VEC_ELT (cond, 0), input_location);\n       OMP_FOR_COND (stmt) = cond;\n       /* Increment the loopvar.  */\n-      tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t  loop->loopvar[n], gfc_index_one_node);\n+      tmp = build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\tloop->loopvar[n], gfc_index_one_node);\n       TREE_VEC_ELT (incr, 0) = fold_build2_loc (input_location, MODIFY_EXPR,\n \t  void_type_node, loop->loopvar[n], tmp);\n       OMP_FOR_INCR (stmt) = incr;\n@@ -5931,8 +5933,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n       if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n \t{\n \t  tmp = gfc_conv_expr_present (sym);\n-\t  ptr = build3 (COND_EXPR, TREE_TYPE (se->expr), tmp,\n-\t\t\tfold_convert (TREE_TYPE (se->expr), ptr),\n+\t  ptr = build3_loc (input_location, COND_EXPR, TREE_TYPE (se->expr),\n+\t\t\ttmp, fold_convert (TREE_TYPE (se->expr), ptr),\n \t\t\tfold_convert (TREE_TYPE (se->expr), null_pointer_node));\n \t}\n "}, {"sha": "0ff297f7e6bc47defa69ef3ac675bd4288e20a62", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "patch": "@@ -3083,8 +3083,8 @@ gfc_init_default_dt (gfc_symbol * sym, stmtblock_t * block, bool dealloc)\n \t\t\t  || sym->ns->proc_name->attr.entry_master))\n     {\n       present = gfc_conv_expr_present (sym);\n-      tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n-\t\t    tmp, build_empty_stmt (input_location));\n+      tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp), present,\n+\t\t\ttmp, build_empty_stmt (input_location));\n     }\n   gfc_add_expr_to_block (block, tmp);\n   gfc_free_expr (e);\n@@ -3119,8 +3119,9 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t|| f->sym->ns->proc_name->attr.entry_master)\n \t      {\n \t\tpresent = gfc_conv_expr_present (f->sym);\n-\t\ttmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n-\t\t\t      tmp, build_empty_stmt (input_location));\n+\t\ttmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp),\n+\t\t\t\t  present, tmp,\n+\t\t\t\t  build_empty_stmt (input_location));\n \t      }\n \n \t    gfc_add_expr_to_block (&init, tmp);"}, {"sha": "db1686b35df7aa5f2638330f9cfd507bc6a4e83d", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "patch": "@@ -178,15 +178,16 @@ gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts, int kind)\n \t\t\t\t\t\t\tse->expr));\n     \n       /* Test for a NULL value.  */\n-      tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present, tmp,\n-\t\t    fold_convert (TREE_TYPE (tmp), integer_one_node));\n+      tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp), present,\n+\t\t\ttmp, fold_convert (TREE_TYPE (tmp), integer_one_node));\n       tmp = gfc_evaluate_now (tmp, &se->pre);\n       se->expr = gfc_build_addr_expr (NULL_TREE, tmp);\n     }\n   else\n     {\n-      tmp = build3 (COND_EXPR, TREE_TYPE (se->expr), present, se->expr,\n-\t\t    fold_convert (TREE_TYPE (se->expr), integer_zero_node));\n+      tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (se->expr),\n+\t\t\tpresent, se->expr,\n+\t\t\tfold_convert (TREE_TYPE (se->expr), integer_zero_node));\n       tmp = gfc_evaluate_now (tmp, &se->pre);\n       se->expr = tmp;\n     }\n@@ -4299,9 +4300,8 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n \t\t\t\t\tnull_pointer_node);\n \t  null_expr = gfc_finish_block (&block);\n \t  tmp = gfc_conv_descriptor_data_get (arg->symtree->n.sym->backend_decl);\n-\t  tmp = build2 (EQ_EXPR, boolean_type_node, tmp,\n-\t\t\tfold_convert (TREE_TYPE (tmp),\n-\t\t\t\t      null_pointer_node));\n+\t  tmp = build2_loc (input_location, EQ_EXPR, boolean_type_node, tmp,\n+\t\t\t    fold_convert (TREE_TYPE (tmp), null_pointer_node));\n \t  return build3_v (COND_EXPR, tmp,\n \t\t\t   null_expr, non_null_expr);\n \t}\n@@ -5396,8 +5396,8 @@ gfc_trans_zero_assign (gfc_expr * expr)\n   /* If we are zeroing a local array avoid taking its address by emitting\n      a = {} instead.  */\n   if (!POINTER_TYPE_P (TREE_TYPE (dest)))\n-    return build2 (MODIFY_EXPR, void_type_node,\n-\t\t   dest, build_constructor (TREE_TYPE (dest), NULL));\n+    return build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t       dest, build_constructor (TREE_TYPE (dest), NULL));\n \n   /* Convert arguments to the correct types.  */\n   dest = fold_convert (pvoid_type_node, dest);"}, {"sha": "6fe362b778e05ead2e58182256d9fa9c00141565", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "patch": "@@ -202,8 +202,8 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n \t\t\t  fold_convert (pvoid_type_node,\n \t\t\t\t\tgfc_conv_descriptor_data_get (outer)),\n \t\t\t  null_pointer_node);\n-  gfc_add_expr_to_block (&block, build3 (COND_EXPR, void_type_node,\n-\t\t\t cond, then_b, else_b));\n+  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n+\t\t\t void_type_node, cond, then_b, else_b));\n \n   return gfc_finish_block (&block);\n }\n@@ -1155,7 +1155,7 @@ gfc_trans_omp_critical (gfc_code *code)\n   if (code->ext.omp_name != NULL)\n     name = get_identifier (code->ext.omp_name);\n   stmt = gfc_trans_code (code->block->next);\n-  return build2 (OMP_CRITICAL, void_type_node, stmt, name);\n+  return build2_loc (input_location, OMP_CRITICAL, void_type_node, stmt, name);\n }\n \n typedef struct dovar_init_d {\n@@ -1446,7 +1446,8 @@ gfc_trans_omp_parallel (gfc_code *code)\n   omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n \t\t\t\t       code->loc);\n   stmt = gfc_trans_omp_code (code->block->next, true);\n-  stmt = build2 (OMP_PARALLEL, void_type_node, stmt, omp_clauses);\n+  stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n+\t\t     omp_clauses);\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n }\n@@ -1486,7 +1487,8 @@ gfc_trans_omp_parallel_do (gfc_code *code)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n     poplevel (0, 0, 0);\n-  stmt = build2 (OMP_PARALLEL, void_type_node, stmt, omp_clauses);\n+  stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n+\t\t     omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n@@ -1511,7 +1513,8 @@ gfc_trans_omp_parallel_sections (gfc_code *code)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n     poplevel (0, 0, 0);\n-  stmt = build2 (OMP_PARALLEL, void_type_node, stmt, omp_clauses);\n+  stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n+\t\t     omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n@@ -1536,7 +1539,8 @@ gfc_trans_omp_parallel_workshare (gfc_code *code)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n     poplevel (0, 0, 0);\n-  stmt = build2 (OMP_PARALLEL, void_type_node, stmt, omp_clauses);\n+  stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n+\t\t     omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n@@ -1568,7 +1572,8 @@ gfc_trans_omp_sections (gfc_code *code, gfc_omp_clauses *clauses)\n     }\n   stmt = gfc_finish_block (&body);\n \n-  stmt = build2 (OMP_SECTIONS, void_type_node, stmt, omp_clauses);\n+  stmt = build2_loc (input_location, OMP_SECTIONS, void_type_node, stmt,\n+\t\t     omp_clauses);\n   gfc_add_expr_to_block (&block, stmt);\n \n   return gfc_finish_block (&block);\n@@ -1579,7 +1584,8 @@ gfc_trans_omp_single (gfc_code *code, gfc_omp_clauses *clauses)\n {\n   tree omp_clauses = gfc_trans_omp_clauses (NULL, clauses, code->loc);\n   tree stmt = gfc_trans_omp_code (code->block->next, true);\n-  stmt = build2 (OMP_SINGLE, void_type_node, stmt, omp_clauses);\n+  stmt = build2_loc (input_location, OMP_SINGLE, void_type_node, stmt,\n+\t\t     omp_clauses);\n   return stmt;\n }\n \n@@ -1593,7 +1599,8 @@ gfc_trans_omp_task (gfc_code *code)\n   omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n \t\t\t\t       code->loc);\n   stmt = gfc_trans_omp_code (code->block->next, true);\n-  stmt = build2 (OMP_TASK, void_type_node, stmt, omp_clauses);\n+  stmt = build2_loc (input_location, OMP_TASK, void_type_node, stmt,\n+\t\t     omp_clauses);\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n }\n@@ -1708,7 +1715,8 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n \t\t{\n \t\t  /* Finish single block and add it to pblock.  */\n \t\t  tmp = gfc_finish_block (&singleblock);\n-\t\t  tmp = build2 (OMP_SINGLE, void_type_node, tmp, NULL_TREE);\n+\t\t  tmp = build2_loc (input_location, OMP_SINGLE,\n+\t\t\t\t    void_type_node, tmp, NULL_TREE);\n \t\t  gfc_add_expr_to_block (pblock, tmp);\n \t\t  /* Add current gfc_code to pblock.  */\n \t\t  gfc_add_expr_to_block (pblock, res);\n@@ -1737,10 +1745,10 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n     {\n       /* Finish single block and add it to pblock.  */\n       tmp = gfc_finish_block (&singleblock);\n-      tmp = build2 (OMP_SINGLE, void_type_node, tmp,\n-\t\t    clauses->nowait\n-\t\t    ? build_omp_clause (input_location, OMP_CLAUSE_NOWAIT)\n-\t\t    : NULL_TREE);\n+      tmp = build2_loc (input_location, OMP_SINGLE, void_type_node, tmp,\n+\t\t\tclauses->nowait\n+\t\t\t? build_omp_clause (input_location, OMP_CLAUSE_NOWAIT)\n+\t\t\t: NULL_TREE);\n       gfc_add_expr_to_block (pblock, tmp);\n     }\n "}, {"sha": "a608fb122525c724552e5063fd980dc8c81989fb", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "patch": "@@ -278,8 +278,8 @@ gfc_build_addr_expr (tree type, tree t)\n       tree type_domain = TYPE_DOMAIN (base_type);\n       if (type_domain && TYPE_MIN_VALUE (type_domain))\n         min_val = TYPE_MIN_VALUE (type_domain);\n-      t = fold (build4 (ARRAY_REF, TREE_TYPE (type),\n-\t\t\tt, min_val, NULL_TREE, NULL_TREE));\n+      t = fold (build4_loc (input_location, ARRAY_REF, TREE_TYPE (type),\n+\t\t\t    t, min_val, NULL_TREE, NULL_TREE));\n       natural_type = type;\n     }\n   else\n@@ -347,7 +347,8 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n     }\n   else\n     /* Otherwise use a straightforward array reference.  */\n-    return build4 (ARRAY_REF, type, base, offset, NULL_TREE, NULL_TREE);\n+    return build4_loc (input_location, ARRAY_REF, type, base, offset,\n+\t\t       NULL_TREE, NULL_TREE);\n }\n \n \n@@ -1476,7 +1477,8 @@ gfc_finish_wrapped_block (gfc_wrapped_block* block)\n   result = block->init;\n   add_expr_to_chain (&result, block->code, false);\n   if (block->cleanup)\n-    result = build2 (TRY_FINALLY_EXPR, void_type_node, result, block->cleanup);\n+    result = build2_loc (input_location, TRY_FINALLY_EXPR, void_type_node,\n+\t\t\t result, block->cleanup);\n   \n   /* Clear the block.  */\n   block->init = NULL_TREE;"}, {"sha": "35b017d4e8e65b9afc180d896e232349be17a71d", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d44e5c8398ca39f0cfdc33ff1470d17132b2af3/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5d44e5c8398ca39f0cfdc33ff1470d17132b2af3", "patch": "@@ -741,14 +741,62 @@ struct GTY((variable_size)) lang_decl {\n #define GFC_TYPE_ARRAY_BASE_DECL(node, internal) \\\n   (TYPE_LANG_SPECIFIC(node)->base_decl[(internal)])\n \n+\n+/* Create _loc version of build[0-9].  */\n+\n+static inline tree\n+build1_stat_loc (location_t loc, enum tree_code code, tree type,\n+\t\t tree op MEM_STAT_DECL)\n+{\n+  tree t = build1_stat (code, type, op PASS_MEM_STAT);\n+  SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build1_loc(l,c,t1,t2) build1_stat_loc (l,c,t1,t2 MEM_STAT_INFO)\n+\n+static inline tree\n+build2_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n+\t\t tree op MEM_STAT_DECL)\n+{\n+  tree t = build2_stat (code, type, arg0, op PASS_MEM_STAT);\n+  SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build2_loc(l,c,t1,t2,t3) build2_stat_loc (l,c,t1,t2,t3 MEM_STAT_INFO)\n+\n+static inline tree\n+build3_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n+\t\t tree arg1, tree op MEM_STAT_DECL)\n+{\n+  tree t = build3_stat (code, type, arg0, arg1, op PASS_MEM_STAT);\n+  SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build3_loc(l,c,t1,t2,t3,t4) \\\n+  build3_stat_loc (l,c,t1,t2,t3,t4 MEM_STAT_INFO)\n+\n+static inline tree\n+build4_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n+\t\t tree arg1, tree arg2, tree op MEM_STAT_DECL)\n+{\n+  tree t = build4_stat (code, type, arg0, arg1, arg2, op PASS_MEM_STAT);\n+  SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build4_loc(l,c,t1,t2,t3,t4,t5) \\\n+  build4_stat_loc (l,c,t1,t2,t3,t4,t5 MEM_STAT_INFO)\n+\n+\n /* Build an expression with void type.  */\n-#define build1_v(code, arg) fold_build1(code, void_type_node, arg)\n-#define build2_v(code, arg1, arg2) fold_build2(code, void_type_node, \\\n-                                               arg1, arg2)\n-#define build3_v(code, arg1, arg2, arg3) fold_build3(code, void_type_node, \\\n-                                                     arg1, arg2, arg3)\n-#define build4_v(code, arg1, arg2, arg3, arg4) build4(code, void_type_node, \\\n-\t\t\t\t\t\t      arg1, arg2, arg3, arg4)\n+#define build1_v(code, arg) \\\n+\tfold_build1_loc (input_location, code, void_type_node, arg)\n+#define build2_v(code, arg1, arg2) \\\n+\tfold_build2_loc (input_location, code, void_type_node, arg1, arg2)\n+#define build3_v(code, arg1, arg2, arg3) \\\n+\tfold_build3_loc (input_location, code, void_type_node, arg1, arg2, arg3)\n+#define build4_v(code, arg1, arg2, arg3, arg4) \\\n+\tbuild4_loc (input_location, code, void_type_node, arg1, arg2, \\\n+\t\t    arg3, arg4)\n \n /* This group of functions allows a caller to evaluate an expression from\n    the callee's interface.  It establishes a mapping between the interface's"}]}