{"sha": "858e4e8cfd71520171ec34839f62cae712b7ee55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU4ZTRlOGNmZDcxNTIwMTcxZWMzNDgzOWY2MmNhZTcxMmI3ZWU1NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-11-21T02:08:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-21T02:08:30Z"}, "message": "* alpha.c (alpha_emit_set_const_1): Handle narrow hosts better.\n\nFrom-SVN: r16627", "tree": {"sha": "d4df3d888e247368c9d963fbbc6a0b0f90b9c83b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4df3d888e247368c9d963fbbc6a0b0f90b9c83b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/858e4e8cfd71520171ec34839f62cae712b7ee55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858e4e8cfd71520171ec34839f62cae712b7ee55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858e4e8cfd71520171ec34839f62cae712b7ee55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858e4e8cfd71520171ec34839f62cae712b7ee55/comments", "author": null, "committer": null, "parents": [{"sha": "a21d14e9919cce73fd6aefed24054caebd175cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21d14e9919cce73fd6aefed24054caebd175cae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a21d14e9919cce73fd6aefed24054caebd175cae"}], "stats": {"total": 29, "additions": 22, "deletions": 7}, "files": [{"sha": "3771facf013d9f1dc8ce0e9624aa0038475cb4f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/858e4e8cfd71520171ec34839f62cae712b7ee55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/858e4e8cfd71520171ec34839f62cae712b7ee55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=858e4e8cfd71520171ec34839f62cae712b7ee55", "patch": "@@ -1,3 +1,7 @@\n+Thu Nov 20 16:11:50 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_emit_set_const_1): Handle narrow hosts better.\n+\n Thu Nov 20 16:11:50 1997  Klaus Kaempf  <kkaempf@progis.de>\n \n \t* alpha/vms.h (ASM_OUTPUT_ADDR_VEC_ELT): Add an L for the local label"}, {"sha": "6155a1dc6a3e1b936cd8c2b3a82e3827f7047c8b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/858e4e8cfd71520171ec34839f62cae712b7ee55/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/858e4e8cfd71520171ec34839f62cae712b7ee55/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=858e4e8cfd71520171ec34839f62cae712b7ee55", "patch": "@@ -904,12 +904,10 @@ alpha_emit_set_const_1 (target, mode, c, n)\n \n   /* If this is a sign-extended 32-bit constant, we can do this in at most\n      three insns, so do it if we have enough insns left.  We always have\n-     a sign-extended 32-bit constant when compiling on a narrow machine. \n-     Note that we cannot handle the constant 0x80000000.  */\n+     a sign-extended 32-bit constant when compiling on a narrow machine.   */\n \n-  if ((HOST_BITS_PER_WIDE_INT != 64\n-       || c >> 31 == -1 || c >> 31 == 0)\n-      && c != 0x80000000U)\n+  if (HOST_BITS_PER_WIDE_INT != 64\n+      || c >> 31 == -1 || c >> 31 == 0)\n     {\n       HOST_WIDE_INT low = (c & 0xffff) - 2 * (c & 0x8000);\n       HOST_WIDE_INT tmp1 = c - low;\n@@ -928,7 +926,18 @@ alpha_emit_set_const_1 (target, mode, c, n)\n \t}\n \n       if (c == low || (low == 0 && extra == 0))\n-\treturn copy_to_suggested_reg (GEN_INT (c), target, mode);\n+\t{\n+\t  /* We used to use copy_to_suggested_reg (GEN_INT (c), target, mode)\n+\t     but that meant that we can't handle INT_MIN on 32-bit machines\n+\t     (like NT/Alpha), because we recurse indefinitely through \n+\t     emit_move_insn to gen_movdi.  So instead, since we know exactly\n+\t     what we want, create it explicitly.  */\n+\n+\t  if (target == NULL)\n+\t    target = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target, GEN_INT (c)));\n+\t  return target;\n+\t}\n       else if (n >= 2 + (extra != 0))\n \t{\n \t  temp = copy_to_suggested_reg (GEN_INT (low), subtarget, mode);\n@@ -1006,9 +1015,11 @@ alpha_emit_set_const_1 (target, mode, c, n)\n       /* Now try high-order zero bits.  Here we try the shifted-in bits as\n \t all zero and all ones.  Be careful to avoid shifting outside the\n \t mode and to avoid shifting outside the host wide int size.  */\n+      /* On narrow hosts, don't shift a 1 into the high bit, since we'll\n+\t confuse the recursive call and set all of the high 32 bits.  */\n \n       if ((bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n-\t\t   - floor_log2 (c) - 1)) > 0)\n+\t\t   - floor_log2 (c) - 1 - (HOST_BITS_PER_WIDE_INT < 64))) > 0)\n \tfor (; bits > 0; bits--)\n \t  if ((temp = alpha_emit_set_const (subtarget, mode,\n \t\t\t\t\t    c << bits, i)) != 0"}]}