{"sha": "a125d8555a7c049962de97f73829f5938e7fb4e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEyNWQ4NTU1YTdjMDQ5OTYyZGU5N2Y3MzgyOWY1OTM4ZTdmYjRlOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-22T03:19:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-22T03:19:34Z"}, "message": "regrename.c (scan_rtx_reg): Terminate the chain rather than abort on mark_read with NO_REGS.\n\n        * regrename.c (scan_rtx_reg): Terminate the chain rather than\n        abort on mark_read with NO_REGS.\n\nFrom-SVN: r37644", "tree": {"sha": "6614a05f9eaaaefc3fb6c56d73430679467f6009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6614a05f9eaaaefc3fb6c56d73430679467f6009"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a125d8555a7c049962de97f73829f5938e7fb4e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a125d8555a7c049962de97f73829f5938e7fb4e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a125d8555a7c049962de97f73829f5938e7fb4e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a125d8555a7c049962de97f73829f5938e7fb4e9/comments", "author": null, "committer": null, "parents": [{"sha": "4dc16355495fed26d2ff551dddcb44e84fddf374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dc16355495fed26d2ff551dddcb44e84fddf374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dc16355495fed26d2ff551dddcb44e84fddf374"}], "stats": {"total": 45, "additions": 30, "deletions": 15}, "files": [{"sha": "2cbd967234fbe7a5c7b2d32107af543e77262002", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a125d8555a7c049962de97f73829f5938e7fb4e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a125d8555a7c049962de97f73829f5938e7fb4e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a125d8555a7c049962de97f73829f5938e7fb4e9", "patch": "@@ -1,3 +1,8 @@\n+2000-11-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* regrename.c (scan_rtx_reg): Terminate the chain rather than\n+\tabort on mark_read with NO_REGS.\n+\n 2000-11-21  Mike Stump  <mrs@wrs.com>\n \n \t* fixinc/fixtests.c (TEST_FOR_FIX_PROC_HEAD): Fix to allow"}, {"sha": "19cc9e865cca036ee118c0f708a43d3f3a7727b2", "filename": "gcc/regrename.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a125d8555a7c049962de97f73829f5938e7fb4e9/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a125d8555a7c049962de97f73829f5938e7fb4e9/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=a125d8555a7c049962de97f73829f5938e7fb4e9", "patch": "@@ -325,26 +325,36 @@ scan_rtx_reg (insn, loc, class, action, type)\n \n \t  if (regno + nregs <= this_regno\n \t      || this_regno + this_nregs <= regno)\n-\t    p = &this->next_chain;\n-\t  else if (action == mark_read)\n+\t    {\n+\t      p = &this->next_chain;\n+\t      continue;\n+\t    }\n+\n+\t  if (action == mark_read)\n \t    {\n \t      if (! exact_match)\n \t\tabort ();\n-\t      if (class == NO_REGS)\n-\t\tabort ();\n \n-\t      this = (struct du_chain *)\n-\t\tobstack_alloc (&rename_obstack, sizeof (struct du_chain));\n-\t      this->next_use = *p;\n-\t      this->next_chain = (*p)->next_chain;\n-\t      this->loc = loc;\n-\t      this->insn = insn;\n-\t      this->class = class;\n-\t      this->need_caller_save_reg = 0;\n-\t      *p = this;\n-\t      return;\n+\t      /* ??? Class NO_REGS can happen if the md file makes use of \n+\t\t EXTRA_CONSTRAINTS to match registers.  Which is arguably\n+\t\t wrong, but there we are.  Since we know not what this may\n+\t\t be replaced with, terminate the chain.  */\n+\t      if (class != NO_REGS)\n+\t\t{\n+\t\t  this = (struct du_chain *)\n+\t\t    obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n+\t\t  this->next_use = *p;\n+\t\t  this->next_chain = (*p)->next_chain;\n+\t\t  this->loc = loc;\n+\t\t  this->insn = insn;\n+\t\t  this->class = class;\n+\t\t  this->need_caller_save_reg = 0;\n+\t\t  *p = this;\n+\t\t  return;\n+\t\t}\n \t    }\n-\t  else if (action != terminate_overlapping_read || ! exact_match)\n+\n+\t  if (action != terminate_overlapping_read || ! exact_match)\n \t    {\n \t      struct du_chain *next = this->next_chain;\n "}]}