{"sha": "d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI1YWE3YWI3N2E3ZmZhNzViYTNhMDI5ZDFiMmZkNmE0MDg0ZTk2NQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-03-30T08:58:52Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-03-30T08:58:52Z"}, "message": "bb-reorder.c (partition_hot_cold_basic_blocks): Do not enter/exit cfglayout mode.\n\n2009-03-30  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* bb-reorder.c (partition_hot_cold_basic_blocks): Do not\n\tenter/exit cfglayout mode.\n\t(pass_partition_block): Require it.\n\t* combine.c (find_single_use, reg_dead_at_p): Use CFG.\n\t(combine_instructions): Track basic blocks instead of labels.\n\t(update_cfg_for_uncondjump): New.\n\t(try_combine): Use it.  Update jumps after rescanning.\n\t(pass_combine): Require PROP_cfglayout.\n\t* passes.c (pass_outof_cfg_layout_mode): Move after regmove.\n\nFrom-SVN: r145283", "tree": {"sha": "5c06cd60705906a16ed5c11d8b3b2e9b2f8f7bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c06cd60705906a16ed5c11d8b3b2e9b2f8f7bcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c9e26f5c0080a49ea83aafcbac0d9e619f4ad32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c9e26f5c0080a49ea83aafcbac0d9e619f4ad32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c9e26f5c0080a49ea83aafcbac0d9e619f4ad32"}], "stats": {"total": 175, "additions": 94, "deletions": 81}, "files": [{"sha": "3e70130c4346135be94e70336cd897a0db2edaa9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965", "patch": "@@ -1,3 +1,15 @@\n+2009-03-30  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* bb-reorder.c (partition_hot_cold_basic_blocks): Do not\n+\tenter/exit cfglayout mode.\n+\t(pass_partition_block): Require it.\n+\t* combine.c (find_single_use, reg_dead_at_p): Use CFG.\n+\t(combine_instructions): Track basic blocks instead of labels.\n+\t(update_cfg_for_uncondjump): New.\n+\t(try_combine): Use it.  Update jumps after rescanning.\n+\t(pass_combine): Require PROP_cfglayout.\n+\t* passes.c (pass_outof_cfg_layout_mode): Move after regmove.\n+\n 2009-03-30  Paolo Bonzini  <bonzini@gnu.org>\n \n         * cfglayout.c (pass_into_cfg_layout_mode, pass_outof_cfg_layout_mode):"}, {"sha": "d1a36c133463d578ec5661fb0eb1a653181c1731", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965", "patch": "@@ -2177,7 +2177,6 @@ struct rtl_opt_pass pass_duplicate_computed_gotos =\n static void\n partition_hot_cold_basic_blocks (void)\n {\n-  basic_block cur_bb;\n   edge *crossing_edges;\n   int n_crossing_edges;\n   int max_edges = 2 * last_basic_block;\n@@ -2187,13 +2186,6 @@ partition_hot_cold_basic_blocks (void)\n \n   crossing_edges = XCNEWVEC (edge, max_edges);\n \n-  cfg_layout_initialize (0);\n-\n-  FOR_EACH_BB (cur_bb)\n-    if (cur_bb->index >= NUM_FIXED_BLOCKS\n-\t&& cur_bb->next_bb->index >= NUM_FIXED_BLOCKS)\n-      cur_bb->aux = cur_bb->next_bb;\n-\n   find_rarely_executed_basic_blocks_and_crossing_edges (&crossing_edges,\n \t\t\t\t\t\t\t&n_crossing_edges,\n \t\t\t\t\t\t\t&max_edges);\n@@ -2202,8 +2194,6 @@ partition_hot_cold_basic_blocks (void)\n     fix_edges_for_rarely_executed_code (crossing_edges, n_crossing_edges);\n \n   free (crossing_edges);\n-\n-  cfg_layout_finalize ();\n }\n \f\n static bool\n@@ -2300,7 +2290,7 @@ struct rtl_opt_pass pass_partition_blocks =\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n   TV_REORDER_BLOCKS,                    /* tv_id */\n-  0,                                    /* properties_required */\n+  PROP_cfglayout,                       /* properties_required */\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */"}, {"sha": "a8200bc125ad0c8427688279e8a111b55e7c1079", "filename": "gcc/combine.c", "status": "modified", "additions": 80, "deletions": 69, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965", "patch": "@@ -605,6 +605,7 @@ find_single_use_1 (rtx dest, rtx *loc)\n static rtx *\n find_single_use (rtx dest, rtx insn, rtx *ploc)\n {\n+  basic_block bb;\n   rtx next;\n   rtx *result;\n   rtx link;\n@@ -627,9 +628,10 @@ find_single_use (rtx dest, rtx insn, rtx *ploc)\n   if (!REG_P (dest))\n     return 0;\n \n-  for (next = next_nonnote_insn (insn);\n-       next != 0 && !LABEL_P (next);\n-       next = next_nonnote_insn (next))\n+  bb = BLOCK_FOR_INSN (insn);\n+  for (next = NEXT_INSN (insn);\n+       next && BLOCK_FOR_INSN (next) == bb;\n+       next = NEXT_INSN (next))\n     if (INSN_P (next) && dead_or_set_p (next, dest))\n       {\n \tfor (link = LOG_LINKS (next); link; link = XEXP (link, 1))\n@@ -1062,17 +1064,19 @@ combine_instructions (rtx f, unsigned int nregs)\n      Also set any known values so that we can use it while searching\n      for what bits are known to be set.  */\n \n-  label_tick = label_tick_ebb_start = 1;\n-\n   setup_incoming_promotions (first);\n \n   create_log_links ();\n+  label_tick_ebb_start = ENTRY_BLOCK_PTR->index;\n   FOR_EACH_BB (this_basic_block)\n     {\n       optimize_this_for_speed_p = optimize_bb_for_speed_p (this_basic_block);\n       last_call_luid = 0;\n       mem_last_set = -1;\n-      label_tick++;\n+      label_tick = this_basic_block->index;\n+      if (!single_pred_p (this_basic_block)\n+\t  || single_pred (this_basic_block)->index != label_tick - 1)\n+\tlabel_tick_ebb_start = label_tick;\n       FOR_BB_INSNS (this_basic_block, insn)\n         if (INSN_P (insn) && BLOCK_FOR_INSN (insn))\n \t  {\n@@ -1098,15 +1102,13 @@ combine_instructions (rtx f, unsigned int nregs)\n \t      fprintf(dump_file, \"insn_cost %d: %d\\n\",\n \t\t    INSN_UID (insn), INSN_COST (insn));\n \t  }\n-\telse if (LABEL_P (insn))\n-\t  label_tick_ebb_start = label_tick;\n     }\n \n   nonzero_sign_valid = 1;\n \n   /* Now scan all the insns in forward order.  */\n \n-  label_tick = label_tick_ebb_start = 1;\n+  label_tick_ebb_start = ENTRY_BLOCK_PTR->index;\n   init_reg_last ();\n   setup_incoming_promotions (first);\n \n@@ -1115,7 +1117,10 @@ combine_instructions (rtx f, unsigned int nregs)\n       optimize_this_for_speed_p = optimize_bb_for_speed_p (this_basic_block);\n       last_call_luid = 0;\n       mem_last_set = -1;\n-      label_tick++;\n+      label_tick = this_basic_block->index;\n+      if (!single_pred_p (this_basic_block)\n+\t  || single_pred (this_basic_block)->index != label_tick - 1)\n+\tlabel_tick_ebb_start = label_tick;\n       rtl_profile_for_bb (this_basic_block);\n       for (insn = BB_HEAD (this_basic_block);\n \t   insn != NEXT_INSN (BB_END (this_basic_block));\n@@ -1268,8 +1273,6 @@ combine_instructions (rtx f, unsigned int nregs)\n \t    retry:\n \t      ;\n \t    }\n-\t  else if (LABEL_P (insn))\n-\t    label_tick_ebb_start = label_tick;\n \t}\n     }\n \n@@ -2159,6 +2162,25 @@ reg_subword_p (rtx x, rtx reg)\n }\n \n \n+/* Delete the conditional jump INSN and adjust the CFG correspondingly.\n+   Note that the INSN should be deleted *after* removing dead edges, so\n+   that the kept edge is the fallthrough edge for a (set (pc) (pc))\n+   but not for a (set (pc) (label_ref FOO)).  */\n+\n+static void\n+update_cfg_for_uncondjump (rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+\n+  if (BB_END (bb) == insn)\n+    purge_dead_edges (bb);\n+\n+  delete_insn (insn);\n+  if (EDGE_COUNT (bb->succs) == 1)\n+    single_succ_edge (bb)->flags |= EDGE_FALLTHRU;\n+}\n+\n+\n /* Try to combine the insns I1 and I2 into I3.\n    Here I1 and I2 appear earlier than I3.\n    I1 can be zero; then we combine just I2 into I3.\n@@ -3712,43 +3734,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n     note_stores (newpat, set_nonzero_bits_and_sign_copies, NULL);\n-\n-    /* Set new_direct_jump_p if a new return or simple jump instruction\n-       has been created.\n-\n-       If I3 is now an unconditional jump, ensure that it has a\n-       BARRIER following it since it may have initially been a\n-       conditional jump.  It may also be the last nonnote insn.  */\n-\n-    if (returnjump_p (i3) || any_uncondjump_p (i3))\n-      {\n-\t*new_direct_jump_p = 1;\n-\tmark_jump_label (PATTERN (i3), i3, 0);\n-\n-\tif ((temp = next_nonnote_insn (i3)) == NULL_RTX\n-\t    || !BARRIER_P (temp))\n-\t  emit_barrier_after (i3);\n-      }\n-\n-    if (undobuf.other_insn != NULL_RTX\n-\t&& (returnjump_p (undobuf.other_insn)\n-\t    || any_uncondjump_p (undobuf.other_insn)))\n-      {\n-\t*new_direct_jump_p = 1;\n-\n-\tif ((temp = next_nonnote_insn (undobuf.other_insn)) == NULL_RTX\n-\t    || !BARRIER_P (temp))\n-\t  emit_barrier_after (undobuf.other_insn);\n-      }\n-\n-    /* An NOOP jump does not need barrier, but it does need cleaning up\n-       of CFG.  */\n-    if (GET_CODE (newpat) == SET\n-\t&& SET_SRC (newpat) == pc_rtx\n-\t&& SET_DEST (newpat) == pc_rtx)\n-      *new_direct_jump_p = 1;\n   }\n-  \n+\n   if (undobuf.other_insn != NULL_RTX)\n     {\n       if (dump_file)\n@@ -3789,6 +3776,34 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       df_insn_rescan (i3);\n     }\n   \n+  /* Set new_direct_jump_p if a new return or simple jump instruction\n+     has been created.  Adjust the CFG accordingly.  */\n+\n+  if (returnjump_p (i3) || any_uncondjump_p (i3))\n+    {\n+      *new_direct_jump_p = 1;\n+      mark_jump_label (PATTERN (i3), i3, 0);\n+      update_cfg_for_uncondjump (i3);\n+    }\n+\n+  if (undobuf.other_insn != NULL_RTX\n+      && (returnjump_p (undobuf.other_insn)\n+\t  || any_uncondjump_p (undobuf.other_insn)))\n+    {\n+      *new_direct_jump_p = 1;\n+      update_cfg_for_uncondjump (undobuf.other_insn);\n+    }\n+\n+  /* A noop might also need cleaning up of CFG, if it comes from the\n+     simplification of a jump.  */\n+  if (GET_CODE (newpat) == SET\n+      && SET_SRC (newpat) == pc_rtx\n+      && SET_DEST (newpat) == pc_rtx)\n+    {\n+      *new_direct_jump_p = 1;\n+      update_cfg_for_uncondjump (i3);\n+    }\n+  \n   combine_successes++;\n   undo_commit ();\n \n@@ -11984,32 +11999,28 @@ reg_dead_at_p (rtx reg, rtx insn)\n \t  return 0;\n     }\n \n-  /* Scan backwards until we find a REG_DEAD note, SET, CLOBBER, label, or\n-     beginning of function.  */\n-  for (; insn && !LABEL_P (insn) && !BARRIER_P (insn);\n-       insn = prev_nonnote_insn (insn))\n+  /* Scan backwards until we find a REG_DEAD note, SET, CLOBBER, or\n+     beginning of basic block.  */\n+  block = BLOCK_FOR_INSN (insn);\n+  for (;;)\n     {\n-      note_stores (PATTERN (insn), reg_dead_at_p_1, NULL);\n-      if (reg_dead_flag)\n-\treturn reg_dead_flag == 1 ? 1 : 0;\n+      if (INSN_P (insn))\n+        {\n+\t  note_stores (PATTERN (insn), reg_dead_at_p_1, NULL);\n+\t  if (reg_dead_flag)\n+\t    return reg_dead_flag == 1 ? 1 : 0;\n \n-      if (find_regno_note (insn, REG_DEAD, reg_dead_regno))\n-\treturn 1;\n-    }\n+\t  if (find_regno_note (insn, REG_DEAD, reg_dead_regno))\n+\t    return 1;\n+        }\n \n-  /* Get the basic block that we were in.  */\n-  if (insn == 0)\n-    block = ENTRY_BLOCK_PTR->next_bb;\n-  else\n-    {\n-      FOR_EACH_BB (block)\n-\tif (insn == BB_HEAD (block))\n-\t  break;\n+      if (insn == BB_HEAD (block))\n+\tbreak;\n \n-      if (block == EXIT_BLOCK_PTR)\n-\treturn 0;\n+      insn = PREV_INSN (insn);\n     }\n \n+  /* Look at live-in sets for the basic block that we were in.  */\n   for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n     if (REGNO_REG_SET_P (df_get_live_in (block), i))\n       return 0;\n@@ -13025,7 +13036,7 @@ struct rtl_opt_pass pass_combine =\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n   TV_COMBINE,                           /* tv_id */\n-  0,                                    /* properties_required */\n+  PROP_cfglayout,                       /* properties_required */\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */"}, {"sha": "bf312f9171a2013641d1e93ce0d802a904f94863", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d25aa7ab77a7ffa75ba3a029d1b2fd6a4084e965", "patch": "@@ -758,12 +758,12 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_reginfo_init);\n       NEXT_PASS (pass_inc_dec);\n       NEXT_PASS (pass_initialize_regs);\n-      NEXT_PASS (pass_outof_cfg_layout_mode);\n       NEXT_PASS (pass_ud_rtl_dce);\n       NEXT_PASS (pass_combine);\n       NEXT_PASS (pass_if_after_combine);\n       NEXT_PASS (pass_partition_blocks);\n       NEXT_PASS (pass_regmove);\n+      NEXT_PASS (pass_outof_cfg_layout_mode);\n       NEXT_PASS (pass_split_all_insns);\n       NEXT_PASS (pass_lower_subreg2);\n       NEXT_PASS (pass_df_initialize_no_opt);"}]}