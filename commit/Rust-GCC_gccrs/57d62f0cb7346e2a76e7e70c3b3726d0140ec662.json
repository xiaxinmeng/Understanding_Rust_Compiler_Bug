{"sha": "57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdkNjJmMGNiNzM0NmUyYTc2ZTdlNzBjM2IzNzI2ZDAxNDBlYzY2Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T09:36:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T09:36:41Z"}, "message": "[multiple changes]\n\n2010-10-22  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_util.ads, sem_util.adb, sem_aux.ads, sem_aux.adb\n\t(Is_Generic_Formal): Moved from Sem_Util to Sem_Aux.\n\n2010-10-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_Iterator_Loop): New subprogram, implements new\n\titerator forms over arrays and containers, in loops and quantified\n\texpressions.\n\t* exp_util.adb (Insert_Actions): include N_Iterator_Specification.\n\t* par-ch4.adb (P_Quantified_Expression): Handle iterator specifications.\n\t* par-ch5.adb (P_Iterator_Specification): New subprogram. Modify\n\tP_Iteration_Scheme to handle both loop forms.\n\t* sem.adb: Handle N_Iterator_Specification.\n\t* sem_ch5.adb, sem_ch5.ads (Analyze_Iterator_Specification): New\n\tsubprogram.\n\t* sinfo.adb, sinfo.ads: New node N_Iterator_Specification.\n\tN_Iteration_Scheme can now include an Iterator_Specification. Ditto\n\tfor N_Quantified_Expression.\n\t* snames.ads-tmpl: Add names Cursor, Element, Element_Type, No_Element,\n\tand Previous, to support iterators over predefined containers.\n\t* sprint.adb: Handle N_Iterator_Specification.\n\nFrom-SVN: r165811", "tree": {"sha": "b51589b3c1031d88407ce19e8674a52d97c3acfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b51589b3c1031d88407ce19e8674a52d97c3acfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/comments", "author": null, "committer": null, "parents": [{"sha": "c3ad80f0001bc349f484f576576997984f7aa1ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ad80f0001bc349f484f576576997984f7aa1ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3ad80f0001bc349f484f576576997984f7aa1ff"}], "stats": {"total": 592, "additions": 557, "deletions": 35}, "files": [{"sha": "04e8a0ec7bbe1cf4d541b00e1496d3f4ecda6ac1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -1,3 +1,27 @@\n+2010-10-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_util.ads, sem_util.adb, sem_aux.ads, sem_aux.adb\n+\t(Is_Generic_Formal): Moved from Sem_Util to Sem_Aux.\n+\n+2010-10-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Iterator_Loop): New subprogram, implements new\n+\titerator forms over arrays and containers, in loops and quantified\n+\texpressions.\n+\t* exp_util.adb (Insert_Actions): include N_Iterator_Specification.\n+\t* par-ch4.adb (P_Quantified_Expression): Handle iterator specifications.\n+\t* par-ch5.adb (P_Iterator_Specification): New subprogram. Modify\n+\tP_Iteration_Scheme to handle both loop forms.\n+\t* sem.adb: Handle N_Iterator_Specification.\n+\t* sem_ch5.adb, sem_ch5.ads (Analyze_Iterator_Specification): New\n+\tsubprogram.\n+\t* sinfo.adb, sinfo.ads: New node N_Iterator_Specification.\n+\tN_Iteration_Scheme can now include an Iterator_Specification. Ditto\n+\tfor N_Quantified_Expression.\n+\t* snames.ads-tmpl: Add names Cursor, Element, Element_Type, No_Element,\n+\tand Previous, to support iterators over predefined containers.\n+\t* sprint.adb: Handle N_Iterator_Specification.\n+\n 2010-10-22  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_prag.adb, sem_ch12.adb, sem_util.adb, sem_util.ads"}, {"sha": "48e6238fac7d8f9d88bcf8e072a9df2a9d73c21a", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 206, "deletions": 1, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -103,6 +103,10 @@ package body Exp_Ch5 is\n    --  clause (this last case is required because holes in the tagged type\n    --  might be filled with components from child types).\n \n+   procedure Expand_Iterator_Loop (N : Node_Id);\n+   --  Expand loops over arrays and containers that use the form \"for X of C\"\n+   --  with an optional subtype mark, and \"for Y in C\".\n+\n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n    --  Generate the necessary code for controlled and tagged assignment, that\n    --  is to say, finalization of the target before, adjustment of the target\n@@ -2747,6 +2751,201 @@ package body Exp_Ch5 is\n       end if;\n    end Expand_N_If_Statement;\n \n+   --------------------------\n+   -- Expand_Iterator_Loop --\n+   --------------------------\n+\n+   procedure Expand_Iterator_Loop (N : Node_Id) is\n+      Loc        : constant Source_Ptr := Sloc (N);\n+      Isc        : constant Node_Id    := Iteration_Scheme (N);\n+      I_Spec     : constant Node_Id    := Iterator_Specification (Isc);\n+      Id         : constant Entity_Id  := Defining_Identifier (I_Spec);\n+      Container  : constant Entity_Id :=  Entity (Name (I_Spec));\n+\n+      Typ        : constant Entity_Id := Etype (Container);\n+\n+      Cursor     : Entity_Id;\n+      New_Loop   : Node_Id;\n+      Stats      : List_Id;\n+\n+   begin\n+      if Is_Array_Type (Typ) then\n+         if Of_Present (I_Spec) then\n+            Cursor := Make_Temporary (Loc, 'C');\n+\n+            --  For Elem of Arr loop ..\n+\n+            declare\n+               Decl : constant Node_Id :=\n+                        Make_Object_Renaming_Declaration (Loc,\n+                          Defining_Identifier => Id,\n+                          Subtype_Mark =>\n+                            New_Occurrence_Of (Component_Type (Typ), Loc),\n+                          Name => Make_Indexed_Component (Loc,\n+                            Prefix => New_Occurrence_Of (Container, Loc),\n+                            Expressions =>\n+                              New_List (New_Occurrence_Of (Cursor, Loc))));\n+            begin\n+               Stats := Statements (N);\n+               Prepend (Decl, Stats);\n+\n+               New_Loop := Make_Loop_Statement (Loc,\n+                 Iteration_Scheme =>\n+                   Make_Iteration_Scheme (Loc,\n+                     Loop_Parameter_Specification =>\n+                       Make_Loop_Parameter_Specification (Loc,\n+                         Defining_Identifier => Cursor,\n+                         Discrete_Subtype_Definition =>\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix => New_Occurrence_Of (Container, Loc),\n+                              Attribute_Name => Name_Range),\n+                         Reverse_Present => Reverse_Present (I_Spec))),\n+                 Statements => Stats,\n+                 End_Label => Empty);\n+            end;\n+\n+         else\n+\n+            --  For Index in Array loop\n+            --\n+            --  The cursor (index into the array) is the source Id.\n+\n+            Cursor := Id;\n+            New_Loop := Make_Loop_Statement (Loc,\n+              Iteration_Scheme =>\n+                Make_Iteration_Scheme (Loc,\n+                  Loop_Parameter_Specification =>\n+                    Make_Loop_Parameter_Specification (Loc,\n+                      Defining_Identifier => Cursor,\n+                      Discrete_Subtype_Definition =>\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix => New_Occurrence_Of (Container, Loc),\n+                           Attribute_Name => Name_Range),\n+                      Reverse_Present => Reverse_Present (I_Spec))),\n+              Statements => Statements (N),\n+              End_Label => Empty);\n+         end if;\n+\n+      else\n+\n+         --  Iterators over containers. In both cases these require a\n+         --  cursor of the proper type.\n+\n+         --  Cursor : P.Cursor_Type := Container.First;\n+         --  while Cursor /= P.No_Element loop\n+\n+         --     --  for the \"of\" form, the element name renames\n+         --     --  the element denoted by the cursor.\n+\n+         --     Obj : P.Element_Type renames Element (Cursor);\n+         --     Statements;\n+         --     P.Next (Cursor);\n+         --  end loop;\n+         --\n+         --  with the obvious replacements if \"reverse\" is specified.\n+\n+         declare\n+            Element_Type  : constant Entity_Id := Etype (Id);\n+            Pack          : constant Entity_Id := Scope (Etype (Container));\n+\n+            Name_Init     : Name_Id;\n+            Name_Step     : Name_Id;\n+\n+            Cond          : Node_Id;\n+            Cursor_Decl   : Node_Id;\n+            Renaming_Decl : Node_Id;\n+\n+         begin\n+            Stats := Statements (N);\n+\n+            if Of_Present (I_Spec) then\n+               Cursor := Make_Temporary (Loc, 'C');\n+\n+            else\n+               Cursor := Id;\n+            end if;\n+\n+            if Reverse_Present (I_Spec) then\n+\n+               --  Must verify that the container has a reverse iterator ???\n+\n+               Name_Init := Name_Last;\n+               Name_Step := Name_Previous;\n+\n+            else\n+               Name_Init := Name_First;\n+               Name_Step := Name_Next;\n+            end if;\n+\n+            --  C : Cursor_Type := Container.First;\n+\n+            Cursor_Decl := Make_Object_Declaration (Loc,\n+              Defining_Identifier => Cursor,\n+              Object_Definition =>\n+                Make_Selected_Component (Loc,\n+                  Prefix => New_Occurrence_Of (Pack, Loc),\n+                  Selector_Name =>\n+                    Make_Identifier (Loc, Name_Cursor)),\n+              Expression =>\n+                Make_Selected_Component (Loc,\n+                  Prefix => New_Occurrence_Of (Container, Loc),\n+                  Selector_Name => Make_Identifier (Loc, Name_Init)));\n+\n+            Insert_Action (N, Cursor_Decl);\n+\n+            --  while C /= No_Element loop\n+\n+            Cond := Make_Op_Ne (Loc,\n+              Left_Opnd => New_Occurrence_Of (Cursor, Loc),\n+              Right_Opnd => Make_Selected_Component (Loc,\n+                 Prefix => New_Occurrence_Of (Pack, Loc),\n+                 Selector_Name => Make_Identifier (Loc,\n+                   Chars => Name_No_Element)));\n+\n+            if Of_Present (I_Spec) then\n+\n+               --  Id : Element_Type renames Pack.Element (Cursor);\n+\n+               Renaming_Decl :=\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Id,\n+                   Subtype_Mark => New_Occurrence_Of (Element_Type, Loc),\n+                   Name => Make_Indexed_Component (Loc,\n+                     Prefix =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix =>  New_Occurrence_Of (Pack, Loc),\n+                       Selector_Name =>\n+                         Make_Identifier (Loc, Chars => Name_Element)),\n+                     Expressions =>\n+                       New_List (New_Occurrence_Of (Cursor, Loc))));\n+\n+               Prepend (Renaming_Decl, Stats);\n+            end if;\n+\n+            --  For both iterator forms, add call to Next to advance cursor.\n+\n+            Append_To (Stats,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => Make_Selected_Component (Loc,\n+                  Prefix => New_Occurrence_Of (Pack, Loc),\n+                  Selector_Name => Make_Identifier (Loc, Name_Step)),\n+                Parameter_Associations =>\n+                  New_List (New_Occurrence_Of (Cursor, Loc))));\n+\n+            New_Loop := Make_Loop_Statement (Loc,\n+              Iteration_Scheme =>\n+                Make_Iteration_Scheme (Loc,\n+                  Condition => Cond),\n+              Statements => Stats,\n+              End_Label => Empty);\n+         end;\n+      end if;\n+\n+      --  Set_Analyzed (I_Spec);\n+      Rewrite (N, New_Loop);\n+      Analyze (N);\n+   end Expand_Iterator_Loop;\n+\n    -----------------------------\n    -- Expand_N_Loop_Statement --\n    -----------------------------\n@@ -2755,7 +2954,8 @@ package body Exp_Ch5 is\n    --  2. Deal with while condition for C/Fortran boolean\n    --  3. Deal with loops with a non-standard enumeration type range\n    --  4. Deal with while loops where Condition_Actions is set\n-   --  5. Insert polling call if required\n+   --  5. Deal with loops with iterators over arrays and containers\n+   --  6. Insert polling call if required\n \n    procedure Expand_N_Loop_Statement (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n@@ -2955,6 +3155,11 @@ package body Exp_Ch5 is\n \n             Analyze (N);\n          end;\n+\n+      elsif Present (Isc)\n+        and then Present (Iterator_Specification (Isc))\n+      then\n+         Expand_Iterator_Loop (N);\n       end if;\n    end Expand_N_Loop_Statement;\n "}, {"sha": "3a94befeffbc7e602474b7050403c7493f2bf2c6", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -2828,6 +2828,7 @@ package body Exp_Util is\n                N_Index_Or_Discriminant_Constraint       |\n                N_Indexed_Component                      |\n                N_Integer_Literal                        |\n+               N_Iterator_Specification                 |\n                N_Itype_Reference                        |\n                N_Label                                  |\n                N_Loop_Parameter_Specification           |"}, {"sha": "8ab04ef1be822764301a457ef3f0a18b9e8d3108", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -2514,7 +2514,8 @@ package body Ch4 is\n    --    for QUANTIFIER ITERATOR_SPECIFICATION => PREDICATE\n \n    function P_Quantified_Expression return Node_Id is\n-      Node1 : Node_Id;\n+      I_Spec : Node_Id;\n+      Node1  : Node_Id;\n \n    begin\n       Scan;  --  past FOR\n@@ -2536,7 +2537,13 @@ package body Ch4 is\n       end if;\n \n       Scan;\n-      Set_Loop_Parameter_Specification (Node1, P_Loop_Parameter_Specification);\n+      I_Spec := P_Loop_Parameter_Specification;\n+\n+      if Nkind (I_Spec) = N_Loop_Parameter_Specification then\n+         Set_Loop_Parameter_Specification (Node1, I_Spec);\n+      else\n+         Set_Iterator_Specification (Node1, I_Spec);\n+      end if;\n \n       if Token = Tok_Arrow then\n          Scan;"}, {"sha": "e6f28c9efba4cac7113a47118c0ca7ae4b4966e1", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 65, "deletions": 4, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -60,6 +60,11 @@ package body Ch5 is\n    --  the N_Identifier node for the label on the loop. If Loop_Name is\n    --  Empty on entry (the default), then the for statement is unlabeled.\n \n+   function P_Iterator_Specification (Def_Id : Node_Id) return Node_Id;\n+   --  Parse an iterator specification. The defining identifier has already\n+   --  been scanned, as it is the common prefix between loop and iterator\n+   --  specification.\n+\n    function P_Loop_Statement (Loop_Name : Node_Id := Empty) return Node_Id;\n    --  Parse loop statement. If Loop_Name is non-Empty on entry, it is\n    --  the N_Identifier node for the label on the loop. If Loop_Name is\n@@ -1552,6 +1557,7 @@ package body Ch5 is\n       Iter_Scheme_Node : Node_Id;\n       Loop_For_Flag    : Boolean;\n       Created_Name     : Node_Id;\n+      Spec             : Node_Id;\n \n    begin\n       Push_Scope_Stack;\n@@ -1563,8 +1569,13 @@ package body Ch5 is\n       Loop_For_Flag := (Prev_Token = Tok_Loop);\n       Scan; -- past FOR\n       Iter_Scheme_Node := New_Node (N_Iteration_Scheme, Token_Ptr);\n-      Set_Loop_Parameter_Specification\n-         (Iter_Scheme_Node, P_Loop_Parameter_Specification);\n+      Spec := P_Loop_Parameter_Specification;\n+      if Nkind (Spec) = N_Loop_Parameter_Specification then\n+         Set_Loop_Parameter_Specification\n+           (Iter_Scheme_Node, Spec);\n+      else\n+         Set_Iterator_Specification (Iter_Scheme_Node, Spec);\n+      end if;\n \n       --  The following is a special test so that a miswritten for loop such\n       --  as \"loop for I in 1..10;\" is handled nicely, without making an extra\n@@ -1686,11 +1697,27 @@ package body Ch5 is\n       Scan_State : Saved_Scan_State;\n \n    begin\n-      Loop_Param_Specification_Node :=\n-        New_Node (N_Loop_Parameter_Specification, Token_Ptr);\n \n       Save_Scan_State (Scan_State);\n       ID_Node := P_Defining_Identifier (C_In);\n+\n+      --  If the next token is OF it indicates the Ada2012 iterator. If the\n+      --  next token is a colon, the iterator includes a subtype indication\n+      --  for the bound variable of the iteration. Otherwise we parse the\n+      --  construct as a loop parameter specification. Note that the form:\n+      --  \"for A in B\" is ambiguous, and must be resolved semantically: if B\n+      --  is a discrete subtype this is a loop specification, but if it is an\n+      --  expression it is an iterator specification. Ambiguity is resolved\n+      --  during analysis of the loop parameter specification.\n+\n+      if Token = Tok_Of\n+        or else Token = Tok_Colon\n+      then\n+         return P_Iterator_Specification (ID_Node);\n+      end if;\n+\n+      Loop_Param_Specification_Node :=\n+        New_Node (N_Loop_Parameter_Specification, Token_Ptr);\n       Set_Defining_Identifier (Loop_Param_Specification_Node, ID_Node);\n \n       if Token = Tok_Left_Paren then\n@@ -1720,6 +1747,40 @@ package body Ch5 is\n          return Error;\n    end P_Loop_Parameter_Specification;\n \n+   ----------------------------------\n+   -- 5.5.1 Iterator_Specification --\n+   ----------------------------------\n+\n+   function P_Iterator_Specification (Def_Id : Node_Id) return Node_Id is\n+      Node1 : Node_Id;\n+   begin\n+      Node1 :=  New_Node (N_Iterator_Specification, Token_Ptr);\n+      Set_Defining_Identifier (Node1, Def_Id);\n+\n+      if Token = Tok_Colon then\n+         Scan;  --  past :\n+         Set_Subtype_Indication (Node1, P_Subtype_Indication);\n+      end if;\n+\n+      if Token = Tok_Of then\n+         Set_Of_Present (Node1);\n+         Scan;  --  past OF\n+      elsif Token = Tok_In then\n+         Scan;  --  past IN\n+      else\n+         return Error;\n+      end if;\n+\n+      if Token = Tok_Reverse then\n+         Scan; -- past REVERSE\n+         Set_Reverse_Present (Node1, True);\n+      end if;\n+\n+      Set_Name (Node1, P_Name);\n+\n+      return Node1;\n+   end P_Iterator_Specification;\n+\n    --------------------------\n    -- 5.6  Block Statement --\n    --------------------------"}, {"sha": "9a9809cb070bb588ea5f83a82b95dd0eba609ada", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -302,6 +302,9 @@ package body Sem is\n          when N_Integer_Literal =>\n             Analyze_Integer_Literal (N);\n \n+         when N_Iterator_Specification =>\n+            Analyze_Iterator_Specification (N);\n+\n          when N_Itype_Reference =>\n             Analyze_Itype_Reference (N);\n "}, {"sha": "f19ead7117d7412a46277f1e0733d8cfa4f1282c", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -537,6 +537,25 @@ package body Sem_Aux is\n       end if;\n    end Is_Derived_Type;\n \n+   -----------------------\n+   -- Is_Generic_Formal --\n+   -----------------------\n+\n+   function Is_Generic_Formal (E : Entity_Id) return Boolean is\n+      Kind : Node_Kind;\n+   begin\n+      if No (E) then\n+         return False;\n+      else\n+         Kind := Nkind (Parent (E));\n+         return\n+           Nkind_In (Kind, N_Formal_Object_Declaration,\n+                           N_Formal_Package_Declaration,\n+                           N_Formal_Type_Declaration)\n+             or else Is_Formal_Subprogram (E);\n+      end if;\n+   end Is_Generic_Formal;\n+\n    ---------------------------\n    -- Is_Indefinite_Subtype --\n    ---------------------------"}, {"sha": "25f95ab6e990254004f6ecab32a8e1f16f146f18", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -159,6 +159,11 @@ package Sem_Aux is\n    --  Determines if the given entity Ent is a derived type. Result is always\n    --  false if argument is not a type.\n \n+   function Is_Generic_Formal (E : Entity_Id) return Boolean;\n+   --  Determine whether E is a generic formal parameter. In particular this is\n+   --  used to set the visibility of generic formals of a generic package\n+   --  declared with a box or with partial parametrization.\n+\n    function Is_Indefinite_Subtype (Ent : Entity_Id) return Boolean;\n    --  Ent is any entity. Determines if given entity is an unconstrained array\n    --  type or subtype, a discriminated record type or subtype with no initial"}, {"sha": "a303807a80d084678d50219097641db29dafcd09", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -1734,6 +1734,10 @@ package body Sem_Ch5 is\n    --  Start of processing for Analyze_Iteration_Scheme\n \n    begin\n+      if Analyzed (N) then\n+         return;\n+      end if;\n+\n       --  For an infinite loop, there is no iteration scheme\n \n       if No (N) then\n@@ -1753,6 +1757,9 @@ package body Sem_Ch5 is\n                Set_Current_Value_Condition (N);\n                return;\n \n+            elsif Present (Iterator_Specification (N)) then\n+               Analyze_Iterator_Specification (Iterator_Specification (N));\n+\n             --  Else we have a FOR loop\n \n             else\n@@ -1795,6 +1802,31 @@ package body Sem_Ch5 is\n                      Process_Bounds (DS);\n                   else\n                      Analyze (DS);\n+\n+                     if Nkind (DS) = N_Function_Call\n+                       or else\n+                         (Is_Entity_Name (DS)\n+                            and then not Is_Type (Entity (DS)))\n+                     then\n+\n+                        --  this is an iterator specification. Rewrite as\n+                        --  such and analyze.\n+\n+                        declare\n+                           I_Spec : constant Node_Id :=\n+                             Make_Iterator_Specification (Sloc (LP),\n+                               Defining_Identifier => Relocate_Node (Id),\n+                               Name => Relocate_Node (DS),\n+                               Subtype_Indication => Empty,\n+                               Reverse_Present => Reverse_Present (LP));\n+\n+                        begin\n+                           Set_Iterator_Specification (N, I_Spec);\n+                           Set_Loop_Parameter_Specification (N, Empty);\n+                           Analyze_Iterator_Specification (I_Spec);\n+                           return;\n+                        end;\n+                     end if;\n                   end if;\n \n                   if DS = Error then\n@@ -1938,6 +1970,73 @@ package body Sem_Ch5 is\n       end if;\n    end Analyze_Iteration_Scheme;\n \n+   -------------------------------------\n+   --  Analyze_Iterator_Specification --\n+   -------------------------------------\n+\n+   procedure Analyze_Iterator_Specification (N : Node_Id) is\n+      Def_Id    : constant Node_Id := Defining_Identifier (N);\n+      Subt      : constant Node_Id := Subtype_Indication (N);\n+      Container : constant Node_Id := Name (N);\n+\n+      Ent       : Entity_Id;\n+      Typ       : Entity_Id;\n+\n+   begin\n+      Enter_Name (Def_Id);\n+      Set_Ekind (Def_Id, E_Variable);\n+\n+      if Present (Subt) then\n+         Analyze (Subt);\n+      end if;\n+\n+      Analyze_And_Resolve (Container);\n+      Typ := Etype (Container);\n+\n+      if Is_Array_Type (Typ) then\n+         if Of_Present (N) then\n+            Set_Etype (Def_Id, Component_Type (Typ));\n+\n+         else\n+            Set_Etype (Def_Id, Etype (First_Index (Typ)));\n+         end if;\n+\n+      else\n+         --  Iteration over a container.\n+\n+         Set_Ekind (Def_Id, E_Loop_Parameter);\n+         if Of_Present (N) then\n+\n+            --  Find the Element_Type in the package instance that defines\n+            --  the container type.\n+\n+            Ent := First_Entity (Scope (Typ));\n+            while Present (Ent) loop\n+               if Chars (Ent) = Name_Element_Type then\n+                  Set_Etype (Def_Id, Ent);\n+                  exit;\n+               end if;\n+\n+               Next_Entity (Ent);\n+            end loop;\n+\n+         else\n+\n+            --  Find the Cursor type in similar fashion.\n+\n+            Ent := First_Entity (Scope (Typ));\n+            while Present (Ent) loop\n+               if Chars (Ent) = Name_Cursor then\n+                  Set_Etype (Def_Id, Ent);\n+                  exit;\n+               end if;\n+\n+               Next_Entity (Ent);\n+            end loop;\n+         end if;\n+      end if;\n+   end Analyze_Iterator_Specification;\n+\n    -------------------\n    -- Analyze_Label --\n    -------------------"}, {"sha": "fdf09db32d5aa0b8325e41d5a2dcf21bb384d63f", "filename": "gcc/ada/sem_ch5.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.ads?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -34,6 +34,7 @@ package Sem_Ch5 is\n    procedure Analyze_Goto_Statement             (N : Node_Id);\n    procedure Analyze_If_Statement               (N : Node_Id);\n    procedure Analyze_Implicit_Label_Declaration (N : Node_Id);\n+   procedure Analyze_Iterator_Specification     (N : Node_Id);\n    procedure Analyze_Iteration_Scheme           (N : Node_Id);\n    procedure Analyze_Label                      (N : Node_Id);\n    procedure Analyze_Loop_Statement             (N : Node_Id);"}, {"sha": "109ee5809760b1c74e1cdf22f1942f953682bb61", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -6559,25 +6559,6 @@ package body Sem_Util is\n       end if;\n    end Is_Fully_Initialized_Variant;\n \n-   -----------------------\n-   -- Is_Generic_Formal --\n-   -----------------------\n-\n-   function Is_Generic_Formal (E : Entity_Id) return Boolean is\n-      Kind : Node_Kind;\n-   begin\n-      if No (E) then\n-         return False;\n-      else\n-         Kind := Nkind (Parent (E));\n-         return\n-           Nkind_In (Kind, N_Formal_Object_Declaration,\n-                           N_Formal_Package_Declaration,\n-                           N_Formal_Type_Declaration)\n-             or else Is_Formal_Subprogram (E);\n-      end if;\n-   end Is_Generic_Formal;\n-\n    ------------\n    -- Is_LHS --\n    ------------"}, {"sha": "be4987b9494c62802f43fcef297ba77e9dd50e8f", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -733,11 +733,6 @@ package Sem_Util is\n    --  means that the result returned is not crucial, but should err on the\n    --  side of thinking things are fully initialized if it does not know.\n \n-   function Is_Generic_Formal (E : Entity_Id) return Boolean;\n-   --  Determine whether E is a generic formal parameter. In particular this is\n-   --  used to set the visibility of generic formals of a generic package\n-   --  declared with a box or with partial parametrization.\n-\n    function Is_Inherited_Operation (E : Entity_Id) return Boolean;\n    --  E is a subprogram. Return True is E is an implicit operation inherited\n    --  by a derived type declarations."}, {"sha": "fe6bf8156c8111bb7d8f6ee6b30bc55f7281e6da", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -744,6 +744,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Full_Type_Declaration\n         or else NT (N).Nkind = N_Implicit_Label_Declaration\n         or else NT (N).Nkind = N_Incomplete_Type_Declaration\n+        or else NT (N).Nkind = N_Iterator_Specification\n         or else NT (N).Nkind = N_Loop_Parameter_Specification\n         or else NT (N).Nkind = N_Number_Declaration\n         or else NT (N).Nkind = N_Object_Declaration\n@@ -1866,6 +1867,15 @@ package body Sinfo is\n       return Node2 (N);\n    end Iteration_Scheme;\n \n+   function Iterator_Specification\n+     (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Iteration_Scheme\n+        or else NT (N).Nkind = N_Quantified_Expression);\n+      return Node2 (N);\n+   end Iterator_Specification;\n+\n    function Itype\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -2086,6 +2096,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Generic_Package_Renaming_Declaration\n         or else NT (N).Nkind = N_Generic_Procedure_Renaming_Declaration\n         or else NT (N).Nkind = N_Goto_Statement\n+        or else NT (N).Nkind = N_Iterator_Specification\n         or else NT (N).Nkind = N_Object_Renaming_Declaration\n         or else NT (N).Nkind = N_Package_Instantiation\n         or else NT (N).Nkind = N_Package_Renaming_Declaration\n@@ -2270,6 +2281,14 @@ package body Sinfo is\n       return Node4 (N);\n    end Object_Definition;\n \n+   function Of_Present\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Iterator_Specification);\n+      return Flag16 (N);\n+   end Of_Present;\n+\n    function Original_Discriminant\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -2630,6 +2649,7 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Iterator_Specification\n         or else NT (N).Nkind = N_Loop_Parameter_Specification);\n       return Flag15 (N);\n    end Reverse_Present;\n@@ -2825,6 +2845,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Access_To_Object_Definition\n         or else NT (N).Nkind = N_Component_Definition\n         or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Iterator_Specification\n         or else NT (N).Nkind = N_Private_Extension_Declaration\n         or else NT (N).Nkind = N_Subtype_Declaration);\n       return Node5 (N);\n@@ -3742,6 +3763,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Full_Type_Declaration\n         or else NT (N).Nkind = N_Implicit_Label_Declaration\n         or else NT (N).Nkind = N_Incomplete_Type_Declaration\n+        or else NT (N).Nkind = N_Iterator_Specification\n         or else NT (N).Nkind = N_Loop_Parameter_Specification\n         or else NT (N).Nkind = N_Number_Declaration\n         or else NT (N).Nkind = N_Object_Declaration\n@@ -4856,6 +4878,15 @@ package body Sinfo is\n       Set_Node2_With_Parent (N, Val);\n    end Set_Iteration_Scheme;\n \n+   procedure Set_Iterator_Specification\n+     (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Iteration_Scheme\n+        or else NT (N).Nkind = N_Quantified_Expression);\n+      Set_Node2_With_Parent (N, Val);\n+   end Set_Iterator_Specification;\n+\n    procedure Set_Itype\n       (N : Node_Id; Val : Entity_Id) is\n    begin\n@@ -5076,6 +5107,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Generic_Package_Renaming_Declaration\n         or else NT (N).Nkind = N_Generic_Procedure_Renaming_Declaration\n         or else NT (N).Nkind = N_Goto_Statement\n+        or else NT (N).Nkind = N_Iterator_Specification\n         or else NT (N).Nkind = N_Object_Renaming_Declaration\n         or else NT (N).Nkind = N_Package_Instantiation\n         or else NT (N).Nkind = N_Package_Renaming_Declaration\n@@ -5260,6 +5292,14 @@ package body Sinfo is\n       Set_Node4_With_Parent (N, Val);\n    end Set_Object_Definition;\n \n+   procedure Set_Of_Present\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Iterator_Specification);\n+      Set_Flag16 (N, Val);\n+   end Set_Of_Present;\n+\n    procedure Set_Original_Discriminant\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -5620,6 +5660,7 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Iterator_Specification\n         or else NT (N).Nkind = N_Loop_Parameter_Specification);\n       Set_Flag15 (N, Val);\n    end Set_Reverse_Present;\n@@ -5815,6 +5856,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Access_To_Object_Definition\n         or else NT (N).Nkind = N_Component_Definition\n         or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Iterator_Specification\n         or else NT (N).Nkind = N_Private_Extension_Declaration\n         or else NT (N).Nkind = N_Subtype_Declaration);\n       Set_Node5_With_Parent (N, Val);"}, {"sha": "2b145cca14c9bca46a571efbea1d89187a6fb567", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -1544,6 +1544,10 @@ package Sinfo is\n    --    is used for properly setting out of range values for use by pragmas\n    --    Initialize_Scalars and Normalize_Scalars.\n \n+   --  Of_Present (Flag16)\n+   --  Present in N_Iterastor_Specification nodes, to mark the Ada2012 iterator\n+   --  form over arrays and containers.\n+\n    --  Original_Discriminant (Node2-Sem)\n    --    Present in identifiers. Used in references to discriminants that\n    --    appear in generic units. Because the names of the discriminants may be\n@@ -3829,6 +3833,7 @@ package Sinfo is\n \n       --  N_Quantified_Expression\n       --  Sloc points to FOR\n+      --  Iterator_Specification (Node2) (set to Empty if not Present)\n       --  Loop_Parameter_Specification (Node4)\n       --  Condition (Node1)\n       --  All_Present (Flag15)\n@@ -4164,7 +4169,11 @@ package Sinfo is\n       --------------------------\n \n       --  ITERATION_SCHEME ::=\n-      --    while CONDITION | for LOOP_PARAMETER_SPECIFICATION\n+      --    while CONDITION | for LOOP_PARAMETER_SPECIFICATION |\n+      --    for ITERATOR_SPECIFICATION\n+\n+      --  Only one of (Iterator_Specification, Loop_Parameter_Specification)\n+      --  is present at a time, the other one is empty.\n \n       --  Gigi restriction: This expander ensures that the type of the\n       --  Condition field is always Standard.Boolean, even if the type\n@@ -4174,6 +4183,7 @@ package Sinfo is\n       --  Sloc points to WHILE or FOR\n       --  Condition (Node1) (set to Empty if FOR case)\n       --  Condition_Actions (List3-Sem)\n+      --  Iterator_Specification (Node2) (set to Empty if not Present)\n       --  Loop_Parameter_Specification (Node4) (set to Empty if WHILE case)\n \n       ---------------------------------------\n@@ -4189,6 +4199,22 @@ package Sinfo is\n       --  Reverse_Present (Flag15)\n       --  Discrete_Subtype_Definition (Node4)\n \n+      ----------------------------------\n+      -- 5.5.1 Iterator specification --\n+      ----------------------------------\n+\n+      --  ITERATOR_SPECIFICATION ::=\n+      --    DEFINING_IDENTIFIER in [reverse] NAME\n+      --    DEFINING_IDENTIFIER [: SUBTYPE_INDICATION] of [reverse] NAME\n+\n+      --  N_Iterator_Specification\n+      --  Sloc points to defining identifier\n+      --  Defining_Identifier (Node1)\n+      --  Name (Node2)\n+      --  Reverse_Present (Flag15)\n+      --  Of_Present (Flag16)\n+      --  Subtype_Indication (Node5)\n+\n       --------------------------\n       -- 5.6  Block Statement --\n       --------------------------\n@@ -7500,6 +7526,7 @@ package Sinfo is\n       N_Formal_Type_Declaration,\n       N_Full_Type_Declaration,\n       N_Incomplete_Type_Declaration,\n+      N_Iterator_Specification,\n       N_Loop_Parameter_Specification,\n       N_Object_Declaration,\n       N_Parameterized_Expression,\n@@ -8492,6 +8519,9 @@ package Sinfo is\n    function Iteration_Scheme\n      (N : Node_Id) return Node_Id;    -- Node2\n \n+   function Iterator_Specification\n+     (N : Node_Id) return Node_Id;    -- Node2\n+\n    function Itype\n      (N : Node_Id) return Entity_Id;  -- Node1\n \n@@ -8612,6 +8642,9 @@ package Sinfo is\n    function Object_Definition\n      (N : Node_Id) return Node_Id;    -- Node4\n \n+   function Of_Present\n+     (N : Node_Id) return Boolean;    -- Flag16\n+\n    function Original_Discriminant\n      (N : Node_Id) return Node_Id;    -- Node2\n \n@@ -9446,6 +9479,9 @@ package Sinfo is\n    procedure Set_Iteration_Scheme\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n+   procedure Set_Iterator_Specification\n+     (N : Node_Id; Val : Node_Id);            -- Node2\n+\n    procedure Set_Itype\n      (N : Node_Id; Val : Entity_Id);          -- Node1\n \n@@ -9566,6 +9602,9 @@ package Sinfo is\n    procedure Set_Object_Definition\n      (N : Node_Id; Val : Node_Id);            -- Node4\n \n+   procedure Set_Of_Present\n+     (N : Node_Id; Val : Boolean := True);   -- Flag16\n+\n    procedure Set_Original_Discriminant\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n@@ -10492,7 +10531,7 @@ package Sinfo is\n \n      N_Quantified_Expression =>\n        (1 => True,    --  Condition (Node1)\n-        2 => False,   --  unused\n+        2 => True,    --  Iterator_Specification\n         3 => False,   --  unused\n         4 => True,    --  Loop_Parameter_Specification (Node4)\n         5 => False),  --  Etype (Node5-Sem)\n@@ -10576,7 +10615,7 @@ package Sinfo is\n \n      N_Iteration_Scheme =>\n        (1 => True,    --  Condition (Node1)\n-        2 => False,   --  unused\n+        2 => True,    --  Iterator_Specification (Node2)\n         3 => False,   --  Condition_Actions (List3-Sem)\n         4 => True,    --  Loop_Parameter_Specification (Node4)\n         5 => False),  --  unused\n@@ -10588,6 +10627,13 @@ package Sinfo is\n         4 => True,    --  Discrete_Subtype_Definition (Node4)\n         5 => False),  --  unused\n \n+     N_Iterator_Specification =>\n+       (1 => True,    --  Defining_Identifier (Node1)\n+        2 => True,    --  Name (Node2)\n+        3 => False,   --  Unused\n+        4 => False,   --  Unused\n+        5 => True),   --  Subtype_Indication (Node5)\n+\n      N_Block_Statement =>\n        (1 => True,    --  Identifier (Node1)\n         2 => True,    --  Declarations (List2)"}, {"sha": "91f50e46712192433ce3693e3b0846a9a578c5e0", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -1198,6 +1198,14 @@ package Snames is\n \n    Name_Unaligned_Valid                  : constant Name_Id := N + $;\n \n+   --  Names used to implement iterators over predefined  containers.\n+\n+   Name_Cursor                           : constant Name_Id := N + $;\n+   Name_Element                          : constant Name_Id := N + $;\n+   Name_Element_Type                     : constant Name_Id := N + $;\n+   Name_No_Element                       : constant Name_Id := N + $;\n+   Name_Previous                         : constant Name_Id := N + $;\n+\n    --  Ada 05 reserved words\n \n    First_2005_Reserved_Word              : constant Name_Id := N + $;"}, {"sha": "627fb2f28bd1745f9b02a8411218bc4925ac83fe", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d62f0cb7346e2a76e7e70c3b3726d0140ec662/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=57d62f0cb7346e2a76e7e70c3b3726d0140ec662", "patch": "@@ -1995,11 +1995,36 @@ package body Sprint is\n                Sprint_Node (Condition (Node));\n             else\n                Write_Str_With_Col_Check_Sloc (\"for \");\n-               Sprint_Node (Loop_Parameter_Specification (Node));\n+               if Present (Iterator_Specification (Node)) then\n+                  Sprint_Node (Iterator_Specification (Node));\n+               else\n+                  Sprint_Node (Loop_Parameter_Specification (Node));\n+               end if;\n             end if;\n \n             Write_Char (' ');\n \n+         when N_Iterator_Specification =>\n+            Set_Debug_Sloc;\n+            Write_Id (Defining_Identifier (Node));\n+\n+            if Present (Subtype_Indication (Node)) then\n+               Write_Str_With_Col_Check (\" : \");\n+               Sprint_Node (Subtype_Indication (Node));\n+            end if;\n+\n+            if Of_Present (Node) then\n+               Write_Str_With_Col_Check (\" of \");\n+            else\n+               Write_Str_With_Col_Check (\" in \");\n+            end if;\n+\n+            if Reverse_Present (Node) then\n+               Write_Str_With_Col_Check (\"reverse \");\n+            end if;\n+\n+            Sprint_Node (Name (Node));\n+\n          when N_Itype_Reference =>\n             Write_Indent_Str_Sloc (\"reference \");\n             Write_Id (Itype (Node));"}]}