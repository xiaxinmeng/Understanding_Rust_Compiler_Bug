{"sha": "0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNjYWFhYjBlMzFhM2RkNDA2ZGZmYjcwZjZlMzExYjQ2ZTk5YWU2Yw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2014-10-03T20:06:38Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2014-10-03T20:06:38Z"}, "message": "lex.c (search_line_fast): Add new version to be used for Power8 and later targets when Altivec is enabled.\n\n2014-10-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* lex.c (search_line_fast): Add new version to be used for Power8\n\tand later targets when Altivec is enabled.  Restrict the existing\n\tAltivec version to big-endian systems so that lvsr is not used on\n\tlittle endian, where it is deprecated.  Remove LE-specific code\n\tfrom the now-BE-only version.\n\nFrom-SVN: r215873", "tree": {"sha": "2cf47064ba3e0e7d55b6d9d03cbb18665094adac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cf47064ba3e0e7d55b6d9d03cbb18665094adac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c9aabbde58e5c540b0718c0a585e3ca97910317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9aabbde58e5c540b0718c0a585e3ca97910317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9aabbde58e5c540b0718c0a585e3ca97910317"}], "stats": {"total": 123, "additions": 112, "deletions": 11}, "files": [{"sha": "09304ef84963e8d536176e107043e6347a19a511", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c", "patch": "@@ -1,3 +1,11 @@\n+2014-10-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* lex.c (search_line_fast): Add new version to be used for Power8\n+\tand later targets when Altivec is enabled.  Restrict the existing\n+\tAltivec version to big-endian systems so that lvsr is not used on\n+\tlittle endian, where it is deprecated.  Remove LE-specific code\n+\tfrom the now-BE-only version.\n+\n 2014-10-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \t    Jeff Law  <law@redhat.com>\n "}, {"sha": "45eaca7ab4fff440755f2032273fa271f9064245", "filename": "libcpp/lex.c", "status": "modified", "additions": 104, "deletions": 11, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=0ccaaab0e31a3dd406dffb70f6e311b46e99ae6c", "patch": "@@ -513,9 +513,111 @@ init_vectorized_lexer (void)\n   search_line_fast = impl;\n }\n \n-#elif (GCC_VERSION >= 4005) && defined(__ALTIVEC__)\n+#elif defined(_ARCH_PWR8) && defined(__ALTIVEC__)\n \n-/* A vection of the fast scanner using AltiVec vectorized byte compares.  */\n+/* A vection of the fast scanner using AltiVec vectorized byte compares\n+   and VSX unaligned loads (when VSX is available).  This is otherwise\n+   the same as the pre-GCC 5 version.  */\n+\n+static const uchar *\n+search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n+{\n+  typedef __attribute__((altivec(vector))) unsigned char vc;\n+\n+  const vc repl_nl = {\n+    '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', \n+    '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n'\n+  };\n+  const vc repl_cr = {\n+    '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', \n+    '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r'\n+  };\n+  const vc repl_bs = {\n+    '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', \n+    '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\'\n+  };\n+  const vc repl_qm = {\n+    '?', '?', '?', '?', '?', '?', '?', '?', \n+    '?', '?', '?', '?', '?', '?', '?', '?', \n+  };\n+  const vc zero = { 0 };\n+\n+  vc data, t;\n+\n+  /* Main loop processing 16 bytes at a time.  */\n+  do\n+    {\n+      vc m_nl, m_cr, m_bs, m_qm;\n+\n+      data = *((const vc *)s);\n+      s += 16;\n+\n+      m_nl = (vc) __builtin_vec_cmpeq(data, repl_nl);\n+      m_cr = (vc) __builtin_vec_cmpeq(data, repl_cr);\n+      m_bs = (vc) __builtin_vec_cmpeq(data, repl_bs);\n+      m_qm = (vc) __builtin_vec_cmpeq(data, repl_qm);\n+      t = (m_nl | m_cr) | (m_bs | m_qm);\n+\n+      /* T now contains 0xff in bytes for which we matched one of the relevant\n+\t characters.  We want to exit the loop if any byte in T is non-zero.\n+\t Below is the expansion of vec_any_ne(t, zero).  */\n+    }\n+  while (!__builtin_vec_vcmpeq_p(/*__CR6_LT_REV*/3, t, zero));\n+\n+  /* Restore s to to point to the 16 bytes we just processed.  */\n+  s -= 16;\n+\n+  {\n+#define N  (sizeof(vc) / sizeof(long))\n+\n+    union {\n+      vc v;\n+      /* Statically assert that N is 2 or 4.  */\n+      unsigned long l[(N == 2 || N == 4) ? N : -1];\n+    } u;\n+    unsigned long l, i = 0;\n+\n+    u.v = t;\n+\n+    /* Find the first word of T that is non-zero.  */\n+    switch (N)\n+      {\n+      case 4:\n+\tl = u.l[i++];\n+\tif (l != 0)\n+\t  break;\n+\ts += sizeof(unsigned long);\n+\tl = u.l[i++];\n+\tif (l != 0)\n+\t  break;\n+\ts += sizeof(unsigned long);\n+      case 2:\n+\tl = u.l[i++];\n+\tif (l != 0)\n+\t  break;\n+\ts += sizeof(unsigned long);\n+\tl = u.l[i];\n+      }\n+\n+    /* L now contains 0xff in bytes for which we matched one of the\n+       relevant characters.  We can find the byte index by finding\n+       its bit index and dividing by 8.  */\n+#ifdef __BIG_ENDIAN__\n+    l = __builtin_clzl(l) >> 3;\n+#else\n+    l = __builtin_ctzl(l) >> 3;\n+#endif\n+    return s + l;\n+\n+#undef N\n+  }\n+}\n+\n+#elif (GCC_VERSION >= 4005) && defined(__ALTIVEC__) && defined (__BIG_ENDIAN__)\n+\n+/* A vection of the fast scanner using AltiVec vectorized byte compares.\n+   This cannot be used for little endian because vec_lvsl/lvsr are\n+   deprecated for little endian and the code won't work properly.  */\n /* ??? Unfortunately, attribute(target(\"altivec\")) is not yet supported,\n    so we can't compile this function without -maltivec on the command line\n    (or implied by some other switch).  */\n@@ -557,13 +659,8 @@ search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n      beginning with all ones and shifting in zeros according to the\n      mis-alignment.  The LVSR instruction pulls the exact shift we\n      want from the address.  */\n-#ifdef __BIG_ENDIAN__\n   mask = __builtin_vec_lvsr(0, s);\n   mask = __builtin_vec_perm(zero, ones, mask);\n-#else\n-  mask = __builtin_vec_lvsl(0, s);\n-  mask = __builtin_vec_perm(ones, zero, mask);\n-#endif\n   data &= mask;\n \n   /* While altivec loads mask addresses, we still need to align S so\n@@ -627,11 +724,7 @@ search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n     /* L now contains 0xff in bytes for which we matched one of the\n        relevant characters.  We can find the byte index by finding\n        its bit index and dividing by 8.  */\n-#ifdef __BIG_ENDIAN__\n     l = __builtin_clzl(l) >> 3;\n-#else\n-    l = __builtin_ctzl(l) >> 3;\n-#endif\n     return s + l;\n \n #undef N"}]}