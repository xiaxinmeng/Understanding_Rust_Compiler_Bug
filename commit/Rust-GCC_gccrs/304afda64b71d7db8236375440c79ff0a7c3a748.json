{"sha": "304afda64b71d7db8236375440c79ff0a7c3a748", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA0YWZkYTY0YjcxZDdkYjgyMzYzNzU0NDBjNzlmZjBhN2MzYTc0OA==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2005-11-05T16:50:47Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2005-11-05T16:50:47Z"}, "message": "lambda-code.c (lambda_transform_legal_p): Use DDR_NUM_DIST_VECTS for testing whether the data_dependence_relation...\n\n\t* lambda-code.c (lambda_transform_legal_p): Use DDR_NUM_DIST_VECTS\n\tfor testing whether the data_dependence_relation contains distance\n\tvectors.  Iterate over all distance vectors of the ddr.\n\t* lambda.h: Define a vec of lambda_vector pointers.\n\t* tree-data-ref.c (dump_data_dependence_relation,\n\tdump_data_dependence_direction): Iterate over all distance and\n\tdirection vectors of the ddr.\n\t(initialize_data_dependence_relation): Initialize DDR_DIR_VECTS and\n\tDDR_DIST_VECTS.\n\t(build_classic_dist_vector, build_classic_dir_vector): Push a set\n\tof distance/direction vectors instead of a single one.\n\t* tree-data-ref.h (dir_vects, dist_vects): Replace dir/dist \n\tlambda_vectors with a vec of lambda_vectors.\n\t(DDR_DIR_VECT, DDR_DIST_VECT): Redefined as operations on vec.\n\t(DDR_DIR_VECTS, DDR_DIST_VECTS, DDR_NUM_DIR_VECTS,\n\tDDR_NUM_DIST_VECTS): New.\n\t* tree-loop-linear.c (gather_interchange_stats): Test for the\n\texistence of distance vectors only after having checked that there\n\tis a dependence.  Iterate over all distance vectors of the ddr.\n\t(linear_transform_loops): Use dump_data_dependence_relation.\n\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence): Test for\n\tdistance vectors using DDR_NUM_DIST_VECTS.  Iterate over all the\n\tdistance vectors of the ddr.\n\nFrom-SVN: r106530", "tree": {"sha": "04c21f33875e763a6900f3781420822aed5db6ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04c21f33875e763a6900f3781420822aed5db6ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/304afda64b71d7db8236375440c79ff0a7c3a748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304afda64b71d7db8236375440c79ff0a7c3a748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/304afda64b71d7db8236375440c79ff0a7c3a748", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304afda64b71d7db8236375440c79ff0a7c3a748/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "541c886c9f35a68fbe4e01d82c43909e9d0b4aa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/541c886c9f35a68fbe4e01d82c43909e9d0b4aa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/541c886c9f35a68fbe4e01d82c43909e9d0b4aa7"}], "stats": {"total": 412, "additions": 254, "deletions": 158}, "files": [{"sha": "ec270296769a1dc275c30ec41532a78e4c39bdbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=304afda64b71d7db8236375440c79ff0a7c3a748", "patch": "@@ -1,3 +1,29 @@\n+2005-11-05  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* lambda-code.c (lambda_transform_legal_p): Use DDR_NUM_DIST_VECTS\n+\tfor testing whether the data_dependence_relation contains distance\n+\tvectors.  Iterate over all distance vectors of the ddr.\n+\t* lambda.h: Define a vec of lambda_vector pointers.\n+\t* tree-data-ref.c (dump_data_dependence_relation,\n+\tdump_data_dependence_direction): Iterate over all distance and\n+\tdirection vectors of the ddr.\n+\t(initialize_data_dependence_relation): Initialize DDR_DIR_VECTS and\n+\tDDR_DIST_VECTS.\n+\t(build_classic_dist_vector, build_classic_dir_vector): Push a set\n+\tof distance/direction vectors instead of a single one.\n+\t* tree-data-ref.h (dir_vects, dist_vects): Replace dir/dist \n+\tlambda_vectors with a vec of lambda_vectors.\n+\t(DDR_DIR_VECT, DDR_DIST_VECT): Redefined as operations on vec.\n+\t(DDR_DIR_VECTS, DDR_DIST_VECTS, DDR_NUM_DIR_VECTS,\n+\tDDR_NUM_DIST_VECTS): New.\n+\t* tree-loop-linear.c (gather_interchange_stats): Test for the\n+\texistence of distance vectors only after having checked that there\n+\tis a dependence.  Iterate over all distance vectors of the ddr.\n+\t(linear_transform_loops): Use dump_data_dependence_relation.\n+\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence): Test for\n+\tdistance vectors using DDR_NUM_DIST_VECTS.  Iterate over all the\n+\tdistance vectors of the ddr.\n+\n 2005-11-05  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.c (n_dregs_to_save, n_pregs_to_save,"}, {"sha": "2d6db22cced618966110299d70e848a4b678fde3", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=304afda64b71d7db8236375440c79ff0a7c3a748", "patch": "@@ -2591,7 +2591,7 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n \t\t\t  int nb_loops,\n \t\t\t  varray_type dependence_relations)\n {\n-  unsigned int i;\n+  unsigned int i, j;\n   lambda_vector distres;\n   struct data_dependence_relation *ddr;\n \n@@ -2628,15 +2628,18 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n \t  \n       /* If the dependence could not be captured by a distance vector,\n \t conservatively answer that the transform is not valid.  */\n-      if (DDR_DIST_VECT (ddr) == NULL)\n+      if (DDR_NUM_DIST_VECTS (ddr) == 0)\n \treturn false;\n \n       /* Compute trans.dist_vect */\n-      lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops, \n-\t\t\t\t DDR_DIST_VECT (ddr), distres);\n+      for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)\n+\t{\n+\t  lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops, \n+\t\t\t\t     DDR_DIST_VECT (ddr, j), distres);\n \n-      if (!lambda_vector_lexico_pos (distres, nb_loops))\n-\treturn false;\n+\t  if (!lambda_vector_lexico_pos (distres, nb_loops))\n+\t    return false;\n+\t}\n     }\n   return true;\n }"}, {"sha": "418cb041ca9b1074c15be5dc907f7794dfe3cfa5", "filename": "gcc/lambda.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=304afda64b71d7db8236375440c79ff0a7c3a748", "patch": "@@ -30,6 +30,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    integers.  */\n typedef int *lambda_vector;\n \n+DEF_VEC_P(lambda_vector);\n+DEF_VEC_ALLOC_P(lambda_vector,heap);\n+\n /* An integer matrix.  A matrix consists of m vectors of length n (IE\n    all vectors are the same length).  */\n typedef lambda_vector *lambda_matrix;"}, {"sha": "10a223e2251b3c28e28e5ab632d5b5186a0c7123", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 138, "deletions": 83, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=304afda64b71d7db8236375440c79ff0a7c3a748", "patch": "@@ -626,6 +626,7 @@ dump_data_dependence_relation (FILE *outf,\n   else if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n     {\n       unsigned int i;\n+\n       for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n \t{\n \t  fprintf (outf, \"  access_fn_A: \");\n@@ -634,15 +635,19 @@ dump_data_dependence_relation (FILE *outf,\n \t  print_generic_stmt (outf, DR_ACCESS_FN (drb, i), 0);\n \t  dump_subscript (outf, DDR_SUBSCRIPT (ddr, i));\n \t}\n-      if (DDR_DIST_VECT (ddr))\n+\n+      for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n \t{\n-\t  fprintf (outf, \"  distance_vect: \");\n-\t  print_lambda_vector (outf, DDR_DIST_VECT (ddr), DDR_SIZE_VECT (ddr));\n+\t  fprintf (outf, \"  distance_vector: \");\n+\t  print_lambda_vector (outf, DDR_DIST_VECT (ddr, i),\n+\t\t\t       DDR_SIZE_VECT (ddr));\n \t}\n-      if (DDR_DIR_VECT (ddr))\n+\n+      for (i = 0; i < DDR_NUM_DIR_VECTS (ddr); i++)\n \t{\n-\t  fprintf (outf, \"  direction_vect: \");\n-\t  print_lambda_vector (outf, DDR_DIR_VECT (ddr), DDR_SIZE_VECT (ddr));\n+\t  fprintf (outf, \"  direction_vector: \");\n+\t  print_lambda_vector (outf, DDR_DIR_VECT (ddr, i),\n+\t\t\t       DDR_SIZE_VECT (ddr));\n \t}\n     }\n \n@@ -700,7 +705,7 @@ dump_data_dependence_direction (FILE *file,\n void \n dump_dist_dir_vectors (FILE *file, varray_type ddrs)\n {\n-  unsigned int i;\n+  unsigned int i, j;\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (ddrs); i++)\n     {\n@@ -710,12 +715,21 @@ dump_dist_dir_vectors (FILE *file, varray_type ddrs)\n       if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE\n \t  && DDR_AFFINE_P (ddr))\n \t{\n-\t  fprintf (file, \"DISTANCE_V (\");\n-\t  print_lambda_vector (file, DDR_DIST_VECT (ddr), DDR_SIZE_VECT (ddr));\n-\t  fprintf (file, \")\\n\");\n-\t  fprintf (file, \"DIRECTION_V (\");\n-\t  print_lambda_vector (file, DDR_DIR_VECT (ddr), DDR_SIZE_VECT (ddr));\n-\t  fprintf (file, \")\\n\");\n+\t  for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)\n+\t    {\n+\t      fprintf (file, \"DISTANCE_V (\");\n+\t      print_lambda_vector (file, DDR_DIST_VECT (ddr, j),\n+\t\t\t\t   DDR_SIZE_VECT (ddr));\n+\t      fprintf (file, \")\\n\");\n+\t    }\n+\n+\t  for (j = 0; j < DDR_NUM_DIR_VECTS (ddr); j++)\n+\t    {\n+\t      fprintf (file, \"DIRECTION_V (\");\n+\t      print_lambda_vector (file, DDR_DIR_VECT (ddr, j),\n+\t\t\t\t   DDR_SIZE_VECT (ddr));\n+\t      fprintf (file, \")\\n\");\n+\t    }\n \t}\n     }\n   fprintf (file, \"\\n\\n\");\n@@ -1999,9 +2013,9 @@ initialize_data_dependence_relation (struct data_reference *a,\n   DDR_ARE_DEPENDENT (res) = NULL_TREE;\n   DDR_SUBSCRIPTS_VECTOR_INIT (res, DR_NUM_DIMENSIONS (a));\n   DDR_SIZE_VECT (res) = 0;\n-  DDR_DIST_VECT (res) = NULL;\n-  DDR_DIR_VECT (res) = NULL;\n-      \n+  DDR_DIR_VECTS (res) = NULL;\n+  DDR_DIST_VECTS (res) = NULL;\n+\n   for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n     {\n       struct subscript *subscript;\n@@ -3088,7 +3102,9 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n {\n   unsigned i;\n   lambda_vector dist_v, init_v;\n+  bool init_b = false;\n   \n+  DDR_SIZE_VECT (ddr) = nb_loops;\n   dist_v = lambda_vector_new (nb_loops);\n   init_v = lambda_vector_new (nb_loops);\n   lambda_vector_clear (dist_v, nb_loops);\n@@ -3186,9 +3202,38 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \n \t  dist_v[loop_depth] = dist;\n \t  init_v[loop_depth] = 1;\n+\t  init_b = true;\n \t}\n     }\n-  \n+\n+  /* Save the distance vector if we initialized one.  */\n+  if (init_b)\n+    {\n+      lambda_vector save_v;\n+\n+      /* Verify a basic constraint: classic distance vectors should always\n+\t be lexicographically positive.  */\n+      if (!lambda_vector_lexico_pos (dist_v, DDR_SIZE_VECT (ddr)))\n+\t{\n+\t  if (DDR_SIZE_VECT (ddr) == 1)\n+\t    /* This one is simple to fix, and can be fixed.\n+\t       Multidimensional arrays cannot be fixed that simply.  */\n+\t    lambda_vector_negate (dist_v, dist_v, DDR_SIZE_VECT (ddr));\n+\t  else\n+\t    /* This is not valid: we need the delta test for properly\n+\t       fixing all this.  */\n+\t    return false;\n+\t}\n+\n+      save_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n+      lambda_vector_copy (dist_v, save_v, DDR_SIZE_VECT (ddr));\n+      VEC_safe_push (lambda_vector, heap, DDR_DIST_VECTS (ddr), save_v);\n+\n+      /* There is nothing more to do when there are no outer loops.  */\n+      if (DDR_SIZE_VECT (ddr) == 1)\n+\tgoto classic_dist_done;\n+    }\n+\n   /* There is a distance of 1 on all the outer loops: \n      \n      Example: there is a dependence of distance 1 on loop_1 for the array A.\n@@ -3206,59 +3251,63 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n     \n     /* Get the common ancestor loop.  */\n     lca = find_common_loop (loop_a, loop_b); \n-    \n-    lca_depth = lca->depth;\n-    lca_depth -= first_loop_depth;\n+    lca_depth = lca->depth - first_loop_depth;\n+\n     gcc_assert (lca_depth >= 0);\n     gcc_assert (lca_depth < nb_loops);\n-\n+    \n     /* For each outer loop where init_v is not set, the accesses are\n        in dependence of distance 1 in the loop.  */\n-    if (lca != loop_a\n-\t&& lca != loop_b\n-\t&& init_v[lca_depth] == 0)\n-      dist_v[lca_depth] = 1;\n-    \n-    lca = lca->outer;\n-    \n-    if (lca)\n+    while (lca->depth != 0)\n       {\n-\tlca_depth = lca->depth - first_loop_depth;\n-\twhile (lca->depth != 0)\n-\t  {\n-\t    /* If we're considering just a sub-nest, then don't record\n-\t       any information on the outer loops.  */\n-\t    if (lca_depth < 0)\n-\t      break;\n+\t/* If we're considering just a sub-nest, then don't record\n+\t   any information on the outer loops.  */\n+\tif (lca_depth < 0)\n+\t  break;\n \n-\t    gcc_assert (lca_depth < nb_loops);\n+\tgcc_assert (lca_depth < nb_loops);\n \n-\t    if (init_v[lca_depth] == 0)\n-\t      dist_v[lca_depth] = 1;\n-\t    lca = lca->outer;\n-\t    lca_depth = lca->depth - first_loop_depth;\n-\t  \n+\t/* If we haven't yet determined a distance for this outer\n+\t   loop, push a new distance vector composed of the previous\n+\t   distance, and a distance of 1 for this outer loop.\n+\t   Example:\n+\n+\t   | loop_1\n+\t   |   loop_2\n+\t   |     A[10]\n+\t   |   endloop_2\n+\t   | endloop_1\n+\n+\t   Saved vectors are of the form (dist_in_1, dist_in_2).\n+\t   First, we save (0, 1), then we have to save (1, 0).  */\n+\tif (init_v[lca_depth] == 0)\n+\t  {\n+\t    lambda_vector save_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n+\n+\t    lambda_vector_copy (dist_v, save_v, DDR_SIZE_VECT (ddr));\n+\t    save_v[lca_depth] = 1;\n+\t    VEC_safe_push (lambda_vector, heap, DDR_DIST_VECTS (ddr), save_v);\n \t  }\n+\n+\tlca = lca->outer;\n+\tlca_depth = lca->depth - first_loop_depth;\n       }\n   }\n-  \n-  DDR_DIST_VECT (ddr) = dist_v;\n-  DDR_SIZE_VECT (ddr) = nb_loops;\n \n-  /* Verify a basic constraint: classic distance vectors should always\n-     be lexicographically positive.  */\n-  if (!lambda_vector_lexico_pos (DDR_DIST_VECT (ddr),\n-\t\t\t\t DDR_SIZE_VECT (ddr)))\n+ classic_dist_done:;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      if (DDR_SIZE_VECT (ddr) == 1)\n-\t/* This one is simple to fix, and can be fixed.\n-\t   Multidimensional arrays cannot be fixed that simply.  */\n-\tlambda_vector_negate (DDR_DIST_VECT (ddr), DDR_DIST_VECT (ddr),\n-\t\t\t      DDR_SIZE_VECT (ddr));\n-      else\n-\t/* This is not valid: we need the delta test for properly\n-\t   fixing all this.  */\n-\treturn false;\n+      fprintf (dump_file, \"(build_classic_dist_vector\\n\");\n+\n+      for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n+\t{\n+\t  fprintf (dump_file, \"  dist_vector = (\");\n+\t  print_lambda_vector (dump_file, DDR_DIST_VECT (ddr, i),\n+\t\t\t       DDR_SIZE_VECT (ddr));\n+\t  fprintf (dump_file, \"  )\\n\");\n+\t}\n+      fprintf (dump_file, \")\\n\");\n     }\n \n   return true;\n@@ -3280,11 +3329,14 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n {\n   unsigned i;\n   lambda_vector dir_v, init_v;\n+  bool init_b = false;\n   \n   dir_v = lambda_vector_new (nb_loops);\n   init_v = lambda_vector_new (nb_loops);\n   lambda_vector_clear (dir_v, nb_loops);\n   lambda_vector_clear (init_v, nb_loops);\n+\n+  DDR_SIZE_VECT (ddr) = nb_loops;\n   \n   if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n     return true;\n@@ -3388,9 +3440,19 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \t  \n \t  dir_v[loop_depth] = dir;\n \t  init_v[loop_depth] = 1;\n+\t  init_b = true;\n \t}\n     }\n-  \n+\n+  /* Save the direction vector if we initialized one.  */\n+  if (init_b)\n+    {\n+      lambda_vector save_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n+\n+      lambda_vector_copy (dir_v, save_v, DDR_SIZE_VECT (ddr));\n+      VEC_safe_push (lambda_vector, heap, DDR_DIR_VECTS (ddr), save_v);\n+    }\n+\n   /* There is a distance of 1 on all the outer loops: \n      \n      Example: there is a dependence of distance 1 on loop_1 for the array A.\n@@ -3413,37 +3475,30 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n     gcc_assert (lca_depth >= 0);\n     gcc_assert (lca_depth < nb_loops);\n \n-    /* For each outer loop where init_v is not set, the accesses are\n-       in dependence of distance 1 in the loop.  */\n-    if (lca != loop_a\n-\t&& lca != loop_b\n-\t&& init_v[lca_depth] == 0)\n-      dir_v[lca_depth] = dir_positive;\n-    \n-    lca = lca->outer;\n-    if (lca)\n+    while (lca->depth != 0)\n       {\n-\tlca_depth = lca->depth - first_loop_depth;\n-\twhile (lca->depth != 0)\n+\t/* If we're considering just a sub-nest, then don't record\n+\t   any information on the outer loops.  */\n+\tif (lca_depth < 0)\n+\t  break;\n+\n+\tgcc_assert (lca_depth < nb_loops);\n+\n+\tif (init_v[lca_depth] == 0)\n \t  {\n-\t    /* If we're considering just a sub-nest, then don't record\n-\t       any information on the outer loops.  */\n-\t    if (lca_depth < 0)\n-\t      break;\n+\t    lambda_vector save_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n \n-\t    gcc_assert (lca_depth < nb_loops);\n+\t    lambda_vector_copy (dir_v, save_v, DDR_SIZE_VECT (ddr));\n+\t    save_v[lca_depth] = dir_positive;\n+\t    VEC_safe_push (lambda_vector, heap, DDR_DIR_VECTS (ddr), save_v);\n+\t  }\n \n-\t    if (init_v[lca_depth] == 0)\n-\t      dir_v[lca_depth] = dir_positive;\n-\t    lca = lca->outer;\n-\t    lca_depth = lca->depth - first_loop_depth;\n+\tlca = lca->outer;\n+\tlca_depth = lca->depth - first_loop_depth;\n \t   \n-\t  }\n       }\n   }\n-  \n-  DDR_DIR_VECT (ddr) = dir_v;\n-  DDR_SIZE_VECT (ddr) = nb_loops;\n+\n   return true;\n }\n "}, {"sha": "5b90e2d554405111253c7fb8fc3096ab5231f072", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=304afda64b71d7db8236375440c79ff0a7c3a748", "patch": "@@ -217,14 +217,15 @@ struct data_dependence_relation\n      the data_dependence_relation.  */\n   varray_type subscripts;\n \n-  /* The size of the direction/distance vectors.  */\n+  /* The size of the direction/distance vectors: the depth of the\n+     analyzed loop nest.  */\n   int size_vect;\n \n   /* The classic direction vector.  */\n-  lambda_vector dir_vect;\n+  VEC(lambda_vector,heap) *dir_vects;\n \n   /* The classic distance vector.  */\n-  lambda_vector dist_vect;\n+  VEC(lambda_vector,heap) *dist_vects;\n };\n \n #define DDR_A(DDR) DDR->a\n@@ -237,8 +238,17 @@ struct data_dependence_relation\n #define DDR_SUBSCRIPT(DDR, I) VARRAY_GENERIC_PTR (DDR_SUBSCRIPTS (DDR), I)\n #define DDR_NUM_SUBSCRIPTS(DDR) VARRAY_ACTIVE_SIZE (DDR_SUBSCRIPTS (DDR))\n #define DDR_SIZE_VECT(DDR) DDR->size_vect\n-#define DDR_DIR_VECT(DDR) DDR->dir_vect\n-#define DDR_DIST_VECT(DDR) DDR->dist_vect\n+\n+#define DDR_DIST_VECTS(DDR) ((DDR)->dist_vects)\n+#define DDR_DIR_VECTS(DDR) ((DDR)->dir_vects)\n+#define DDR_NUM_DIST_VECTS(DDR) \\\n+  (VEC_length (lambda_vector, DDR_DIST_VECTS (DDR)))\n+#define DDR_NUM_DIR_VECTS(DDR) \\\n+  (VEC_length (lambda_vector, DDR_DIR_VECTS (DDR)))\n+#define DDR_DIR_VECT(DDR, I) \\\n+  VEC_index (lambda_vector, DDR_DIR_VECTS (DDR), I)\n+#define DDR_DIST_VECT(DDR, I) \\\n+  VEC_index (lambda_vector, DDR_DIST_VECTS (DDR), I)\n \n \f\n "}, {"sha": "da790dc842f9a311a7d4dc969a302b2fa501c2f6", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=304afda64b71d7db8236375440c79ff0a7c3a748", "patch": "@@ -98,37 +98,39 @@ gather_interchange_stats (varray_type dependence_relations,\n \t\t\t  unsigned int *nb_deps_not_carried_by_loop, \n \t\t\t  unsigned int *access_strides)\n {\n-  unsigned int i;\n+  unsigned int i, j;\n \n   *dependence_steps = 0;\n   *nb_deps_not_carried_by_loop = 0;\n   *access_strides = 0;\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n     {\n-      int dist;\n       struct data_dependence_relation *ddr = \n \t(struct data_dependence_relation *) \n \tVARRAY_GENERIC_PTR (dependence_relations, i);\n \n       /* If we don't know anything about this dependence, or the distance\n \t vector is NULL, or there is no dependence, then there is no reuse of\n \t data.  */\n-\n-      if (DDR_DIST_VECT (ddr) == NULL\n-\t  || DDR_ARE_DEPENDENT (ddr) == chrec_dont_know\n-\t  || DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know\n+\t  || DDR_ARE_DEPENDENT (ddr) == chrec_known\n+\t  || DDR_NUM_DIST_VECTS (ddr) == 0)\n \tcontinue;\n-      \n \n-      \n-      dist = DDR_DIST_VECT (ddr)[loop->depth - first_loop->depth];\n-      if (dist == 0)\n-\t(*nb_deps_not_carried_by_loop) += 1;\n-      else if (dist < 0)\n-\t(*dependence_steps) += -dist;\n-      else\n-\t(*dependence_steps) += dist;\n+      for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)\n+\t{\n+\t  int dist = DDR_DIST_VECT (ddr, j)[loop->depth - first_loop->depth];\n+\n+\t  if (dist == 0)\n+\t    (*nb_deps_not_carried_by_loop) += 1;\n+\n+\t  else if (dist < 0)\n+\t    (*dependence_steps) += -dist;\n+\n+\t  else\n+\t    (*dependence_steps) += dist;\n+\t}\n     }\n \n   /* Compute the access strides.  */\n@@ -307,16 +309,7 @@ linear_transform_loops (struct loops *loops)\n \t\tVARRAY_GENERIC_PTR (dependence_relations, j);\n \n \t      if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n-\t\t{\n-\t\t  fprintf (dump_file, \"DISTANCE_V (\");\n-\t\t  print_lambda_vector (dump_file, DDR_DIST_VECT (ddr), \n-\t\t\t\t       DDR_SIZE_VECT (ddr));\n-\t\t  fprintf (dump_file, \")\\n\");\n-\t\t  fprintf (dump_file, \"DIRECTION_V (\");\n-\t\t  print_lambda_vector (dump_file, DDR_DIR_VECT (ddr), \n-\t\t\t\t       DDR_SIZE_VECT (ddr));\n-\t\t  fprintf (dump_file, \")\\n\");\n-\t\t}\n+\t\tdump_data_dependence_relation (dump_file, ddr);\n \t    }\n \t  fprintf (dump_file, \"\\n\\n\");\n \t}"}, {"sha": "ab749fba34a5b8938acd998d09415e2089df66d2", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304afda64b71d7db8236375440c79ff0a7c3a748/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=304afda64b71d7db8236375440c79ff0a7c3a748", "patch": "@@ -570,9 +570,9 @@ static bool\n vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n                                   loop_vec_info loop_vinfo)\n {\n+  unsigned int i;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  int dist = 0;\n   unsigned int loop_depth = 0;\n   struct loop *loop_nest = loop;\n   struct data_reference *dra = DDR_A (ddr);\n@@ -596,7 +596,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       return true;\n     }\n \n-  if (!DDR_DIST_VECT (ddr))\n+  if (DDR_NUM_DIST_VECTS (ddr) == 0)\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         {\n@@ -614,48 +614,54 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       loop_nest = loop_nest->outer;\n       loop_depth++;\n     }\n-         \n-  dist = DDR_DIST_VECT (ddr)[loop_depth];\n-  if (vect_print_dump_info (REPORT_DR_DETAILS))\n-    fprintf (vect_dump, \"dependence distance  = %d.\",dist);\n \n-  /* Same loop iteration.  */\n-  if (dist % vectorization_factor == 0)\n+  for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n     {\n-      /* Two references with distance zero have the same alignment.  */\n-      VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n-      VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n-      if (vect_print_dump_info (REPORT_ALIGNMENT))\n-        fprintf (vect_dump, \"accesses have the same alignment.\");\n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n-        {\n-          fprintf (vect_dump, \"dependence distance modulo vf == 0 between \");\n-          print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-          fprintf (vect_dump, \" and \");\n-          print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n-        }\n-      return false;\n-    }    \n+      int dist = DDR_DIST_VECT (ddr, i)[loop_depth];\n \n-  if (abs (dist) >= vectorization_factor)\n-    {\n-      /* Dependence distance does not create dependence, as far as vectorization\n-         is concerned, in this case.  */\n       if (vect_print_dump_info (REPORT_DR_DETAILS))\n-        fprintf (vect_dump, \"dependence distance >= VF.\");\n-       return false;\n-    }\n-  \n-  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-    {\n-      fprintf (vect_dump,\n-        \"not vectorized: possible dependence between data-refs \");\n-      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-      fprintf (vect_dump, \" and \");\n-      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\tfprintf (vect_dump, \"dependence distance  = %d.\", dist);\n+\n+      /* Same loop iteration.  */\n+      if (dist % vectorization_factor == 0)\n+\t{\n+\t  /* Two references with distance zero have the same alignment.  */\n+\t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n+\t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n+\t    fprintf (vect_dump, \"accesses have the same alignment.\");\n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"dependence distance modulo vf == 0 between \");\n+\t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+\t      fprintf (vect_dump, \" and \");\n+\t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      if (abs (dist) >= vectorization_factor)\n+\t{\n+\t  /* Dependence distance does not create dependence, as far as vectorization\n+\t     is concerned, in this case.  */\n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    fprintf (vect_dump, \"dependence distance >= VF.\");\n+\t  continue;\n+\t}\n+\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t{\n+\t  fprintf (vect_dump,\n+\t\t   \"not vectorized: possible dependence between data-refs \");\n+\t  print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+\t  fprintf (vect_dump, \" and \");\n+\t  print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t}\n+\n+      return true;\n     }\n-        \n-  return true;\n+\n+  return false;\n }\n \n "}]}