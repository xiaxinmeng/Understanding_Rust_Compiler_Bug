{"sha": "f7f049fa4620ada6457ed6163b1fdf0de37a3258", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdmMDQ5ZmE0NjIwYWRhNjQ1N2VkNjE2M2IxZmRmMGRlMzdhMzI1OA==", "commit": {"author": {"name": "Caroline Tice", "email": "cmtice@google.com", "date": "2015-01-29T08:03:56Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2015-01-29T08:03:56Z"}, "message": "Committing VTV Cygwin patch for Patrick Wollgast\n\n* gcc/config/i386/cygwin.h (STARTFILE_SPEC): Add vtv_start.o,\n    if -fvtable-verify=preinit/std is used.\n* gcc/config/i386/mingw-w64.h (STARTFILE_SPEC): Likewise.\n* gcc/config/i386/mingw32.h (STARTFILE_SPEC): Likewise.\n* gcc/config/i386/cygwin.h (ENDFILE_SPEC): Add vtv_end.o,\n    if -fvtable-verify=preinit/std is used.\n* gcc/config/i386/mingw32.h (ENDFILE_SPEC): Likewise.\n* gcc/config/i386/cygwin.h (LIB_SPEC): Pass -lvtv and -lpsapi,\n    if -fvtable-verify=preinit/std is used.\n* gcc/config/i386/mingw-w64.h (LIB_SPEC): Likewise.\n* gcc/config/i386/mingw32.h (LIB_SPEC): Likewise.\n\n* gcc/cp/vtable-class-hierarchy.c (vtv_generate_init_routine): Add\n    check for not TARGET_PECOFF at the VTV_PREINIT_PRIORITY checks.\n\n* gcc/varasm.c (assemble_variable): Add code to properly set the comdat\n    section and name for the .vtable_map_vars section in case the\n    target is PE or COFF.\n\n\n* libgcc/Makefile.in: Move rules to build vtv_*.o out of the check\n    for CUSTOM_CRTSTUFF.\n* libgcc/config.host (i[34567]86-*-cygwin*, x86_64-*-cygwin*, i[34567]86-*-mingw*)\n    (x86_64-*-mingw*): Only add vtv_*.o to extra_parts if enable_vtable_verify.\n\n\n* libstdc++-v3/acinclude.m4: Define VTV_CYGMIN.\n* libstdc++-v3/configure: Regenerate.\n\n* libstdc++-v3/libsupc++/Makefile.am: Add vtv_sources only to\n    libsupc___la_SOURCES and libsupc__convenience_la_SOURCES if VTV_CYGMIN is\n    not set.\n* libstdc++-v3/libsupc++/Makefile.in: Regenerated.\n* libstdc++-v3/libsupc++/vtv_stubs.cc: Add none weak declaration of every\n    function for Cygwin and MinGW.\n\n* libstdc++-v3/src/Makefile.am: Add libvtv.la to toolexeclib_LTLIBRARIES,\n    if VTV_CYGMIN is set. Define libvtv_la_SOURCES, libvtv_la_LDFLAGS,\n    libvtv_la_AM_CXXFLAGS and libvtv_la_LINK if VTV_CYGMIN is set.\n* libstdc++-v3/src/Makefile.in: Regenerate.\n\n\n* libvtv/Makefile.am : Add libvtv.la to toolexeclib_LTLIBRARIES, if VTV_CYGMIN\n    is set. Define libvtv_la_LIBADD, libvtv_la_LDFLAGS, libvtv_stubs_la_LDFLAGS\n    and libvtv_stubs_la_SOURCES if VTV_CYGMIN is set. Add obstac.c to\n    libvtv_la_SOURCES if VTV_CYGMIN is set.\n* libvtv/Makefile.in : Regenerate.\n* libvtv/aclocal.m4 : Regenerate.\n* libvtv/configure : Regenerate.\n* libvtv/configure.ac : Add ACX_LT_HOST_FLAGS. Define VTV_CYGMIN.\n* libvtv/configure.tgt : (x86_64-*-cygwin*, i?86-*-cygwin*, x86_64-*-mingw*)\n    (i?86-*-mingw*): Add to supported targets.\n* libvtv/vtv_fail.cc : Skip inclusion of execinfo.h on Cygwin and MinGW.\n(log_error_message): Skip calls to backtrace and backtrace_symbols_fd on Cygwin\n    and MinGW.\n* libvtv/vtv_malloc.cc : Include windows.h and skip sys/mman.h inclusion on\n    Cygwin and MinGW. Add sysconf port on Cygwin and MinGW.\n(obstack_chunk_alloc): Exchange call to mmap with call to VirtualAlloc on Cygwin\n    and MinGW.\n(__vtv_malloc_init): Exchange call to sysconf with call to port of sysconf on\n    Cygwin and MinGW.\n* libvtv/vtv_malloc.h : Declare mprotect and define PROT_READ and PROT_WRITE on\n    Cygwin and MinGW.\n* libvtv/map.h : Include stdint.h on MinGW.\n* libvtv/rts.cc : Include windows.h, winternl.h and psapi.h, skip include of\n    execinfo.h, sys/mman.h and link.h on Cygwin and MinGW.\n    Add port of __fortify_fail on Cygwin and MinGW.\n    Change ElfW (Addr) to uintptr_t on Cygwin and MinGW.\n(read_section_offset_and_length): Add port for Cygwin and MinGW\n(iterate_modules): New function.\n(vtv_unprotect_vtable_vars): Use iterate_modules instead of dl_iterate_phdr on\n    Cygwin and MinGW.\n(vtv_protect_vtable_vars): Likewise.\n(count_all_pages): Likewise.\n(dl_iterate_phdr_count_pages): Don't build on Cygwin and MinGW.\n* libvtv/utils.cc : Include windows.h and skip execinfo.h inclusion on\n    Cygwin and MinGW.\n(__vtv_open_log): Exchange call to getuid and getpid with GetCurrentProcessId and\n    adjust call to snprintf accordingly on Cygwin and MinGW.\n    Adjust calls to mkdir on MinGW.\n    Adjust call to open on Cygwin and MinGW.\n(__vtv_add_to_log): Adjust call to snprintf on Cygwin and MinGW.\n(__vtv_log_verification_failure): Don't generate a backtrace on Cygwin and MinGW.\n\nFrom-SVN: r220232", "tree": {"sha": "d1a4e15369f535e9126c671e3f4bfc0bfe410bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1a4e15369f535e9126c671e3f4bfc0bfe410bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7f049fa4620ada6457ed6163b1fdf0de37a3258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7f049fa4620ada6457ed6163b1fdf0de37a3258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7f049fa4620ada6457ed6163b1fdf0de37a3258", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7f049fa4620ada6457ed6163b1fdf0de37a3258/comments", "author": {"login": "cmtice", "id": 5561162, "node_id": "MDQ6VXNlcjU1NjExNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/5561162?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cmtice", "html_url": "https://github.com/cmtice", "followers_url": "https://api.github.com/users/cmtice/followers", "following_url": "https://api.github.com/users/cmtice/following{/other_user}", "gists_url": "https://api.github.com/users/cmtice/gists{/gist_id}", "starred_url": "https://api.github.com/users/cmtice/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cmtice/subscriptions", "organizations_url": "https://api.github.com/users/cmtice/orgs", "repos_url": "https://api.github.com/users/cmtice/repos", "events_url": "https://api.github.com/users/cmtice/events{/privacy}", "received_events_url": "https://api.github.com/users/cmtice/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10881cffc20a2eddc90f40ec5796fc0ce697f8d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10881cffc20a2eddc90f40ec5796fc0ce697f8d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10881cffc20a2eddc90f40ec5796fc0ce697f8d7"}], "stats": {"total": 666, "additions": 654, "deletions": 12}, "files": [{"sha": "67f5f7fb44679261a5dd1b6e1ebcec617b2e404d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -1,3 +1,21 @@\n+2015-01-27  Caroline Tice  <cmtice@google.com>\n+\n+\tCommitting VTV Cywin/Ming patch for Patrick Wollgast\n+\t* config/i386/cygwin.h (STARTFILE_SPEC): Add vtv_start.o,\n+\tif -fvtable-verify=preinit/std is used.\n+\t* config/i386/mingw-w64.h (STARTFILE_SPEC): Likewise.\n+\t* config/i386/mingw32.h (STARTFILE_SPEC): Likewise.\n+\t* config/i386/cygwin.h (ENDFILE_SPEC): Add vtv_end.o,\n+\tif -fvtable-verify=preinit/std is used.\n+\t* config/i386/mingw32.h (ENDFILE_SPEC): Likewise.\n+\t* config/i386/cygwin.h (LIB_SPEC): Pass -lvtv and -lpsapi,\n+\tif -fvtable-verify=preinit/std is used.\n+\t* config/i386/mingw-w64.h (LIB_SPEC): Likewise.\n+\t* config/i386/mingw32.h (LIB_SPEC): Likewise.\n+\t* varasm.c (assemble_variable): Add code to properly set the comdat\n+\tsection and name for the .vtable_map_vars section in case the\n+\ttarget is PE or COFF.\n+\n 2015-01-29  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/64801"}, {"sha": "2186937849a7ca1d61df6240d1acfac6277b475c", "filename": "gcc/config/i386/cygwin.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fconfig%2Fi386%2Fcygwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fconfig%2Fi386%2Fcygwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.h?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -41,12 +41,18 @@ along with GCC; see the file COPYING3.  If not see\n #define STARTFILE_SPEC \"\\\n   %{!shared: %{!mdll: crt0%O%s \\\n   %{pg:gcrt0%O%s}}}\\\n-  %{shared:crtbeginS.o%s;:crtbegin.o%s}\"\n+  %{shared:crtbeginS.o%s;:crtbegin.o%s} \\\n+  %{fvtable-verify=none:%s; \\\n+    fvtable-verify=preinit:vtv_start.o%s; \\\n+    fvtable-verify=std:vtv_start.o%s}\"\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n   \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\\\n    %{!shared:%:if-exists(default-manifest.o%s)}\\\n+   %{fvtable-verify=none:%s; \\\n+    fvtable-verify=preinit:vtv_end.o%s; \\\n+    fvtable-verify=std:vtv_end.o%s} \\\n    crtend.o%s\"\n \n /* Normally, -lgcc is not needed since everything in it is in the DLL, but we\n@@ -81,6 +87,8 @@ along with GCC; see the file COPYING3.  If not see\n   %{pthread: } \\\n   -lcygwin \\\n   %{mwindows:-lgdi32 -lcomdlg32} \\\n+  %{fvtable-verify=preinit:-lvtv -lpsapi; \\\n+    fvtable-verify=std:-lvtv -lpsapi} \\\n   -ladvapi32 -lshell32 -luser32 -lkernel32\"\n \n /* To implement C++ function replacement we always wrap the cxx"}, {"sha": "578a7b7c6994d8d75caed334e822594a06f649f0", "filename": "gcc/config/i386/mingw-w64.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fconfig%2Fi386%2Fmingw-w64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fconfig%2Fi386%2Fmingw-w64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw-w64.h?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -32,7 +32,10 @@ along with GCC; see the file COPYING3.  If not see\n   %{!shared:%{!mdll:%{!municode:crt2%O%s}}} \\\n   %{!shared:%{!mdll:%{municode:crt2u%O%s}}} \\\n   %{pg:gcrt2%O%s} \\\n-  crtbegin.o%s\"\n+  crtbegin.o%s \\\n+  %{fvtable-verify=none:%s; \\\n+    fvtable-verify=preinit:vtv_start.o%s; \\\n+    fvtable-verify=std:vtv_start.o%s}\"\n \n /* Enable multilib.  */\n \n@@ -43,6 +46,8 @@ along with GCC; see the file COPYING3.  If not see\n #define LIB_SPEC \"%{pg:-lgmon} %{\" SPEC_PTHREAD1 \":-lpthread} \" \\\n \t\t \"%{\" SPEC_PTHREAD2 \": } \" \\\n \t\t \"%{mwindows:-lgdi32 -lcomdlg32} \" \\\n+     \"%{fvtable-verify=preinit:-lvtv -lpsapi; \\\n+        fvtable-verify=std:-lvtv -lpsapi} \" \\\n \t\t \"-ladvapi32 -lshell32 -luser32 -lkernel32\"\n \n #undef SPEC_32"}, {"sha": "f1397614ed8a325f11f9d2e991c0c590a0015d6e", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -91,6 +91,8 @@ along with GCC; see the file COPYING3.  If not see\n #define LIB_SPEC \"%{pg:-lgmon} %{\" SPEC_PTHREAD1 \":-lpthread} \" \\\n \t\t \"%{\" SPEC_PTHREAD2 \": } \" \\\n \t\t \"%{mwindows:-lgdi32 -lcomdlg32} \" \\\n+     \"%{fvtable-verify=preinit:-lvtv -lpsapi; \\\n+        fvtable-verify=std:-lvtv -lpsapi} \" \\\n                  \"-ladvapi32 -lshell32 -luser32 -lkernel32\"\n \n /* Weak symbols do not get resolved if using a Windows dll import lib.\n@@ -143,12 +145,18 @@ along with GCC; see the file COPYING3.  If not see\n #undef STARTFILE_SPEC\n #define STARTFILE_SPEC \"%{shared|mdll:dllcrt2%O%s} \\\n   %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s} \\\n-  crtbegin.o%s\"\n+  crtbegin.o%s \\\n+  %{fvtable-verify=none:%s; \\\n+    fvtable-verify=preinit:vtv_start.o%s; \\\n+    fvtable-verify=std:vtv_start.o%s}\"\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n   \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n    %{!shared:%:if-exists(default-manifest.o%s)}\\\n+   %{fvtable-verify=none:%s; \\\n+    fvtable-verify=preinit:vtv_end.o%s; \\\n+    fvtable-verify=std:vtv_end.o%s} \\\n   crtend.o%s\"\n \n /* Override startfile prefix defaults.  */"}, {"sha": "743fda3704d7c74bbd04c0764fb46e0a3ba65fc7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -1,3 +1,9 @@\n+2015-01-27  Caroline Tice  <cmtice@google.com>\n+\n+\tCommitting VTV Cywin/Ming patch for Patrick Wollgast\n+\t* vtable-class-hierarchy.cc (vtv_generate_init_routine): Add\n+\tcheck for not TARGET_PECOFF at the VTV_PREINIT_PRIORITY checks.\n+\n 2015-01-27  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/58597"}, {"sha": "a138ee4e43b51f9c73009a8cd3e58305f3698ea0", "filename": "gcc/cp/vtable-class-hierarchy.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fcp%2Fvtable-class-hierarchy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fcp%2Fvtable-class-hierarchy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fvtable-class-hierarchy.c?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -1194,15 +1194,23 @@ vtv_generate_init_routine (void)\n       TREE_STATIC (vtv_fndecl) = 1;\n       TREE_USED (vtv_fndecl) = 1;\n       DECL_PRESERVE_P (vtv_fndecl) = 1;\n+#if defined (TARGET_PECOFF)\n+      if (flag_vtable_verify == VTV_PREINIT_PRIORITY && !TARGET_PECOFF)\n+#else\n       if (flag_vtable_verify == VTV_PREINIT_PRIORITY)\n+#endif\n         DECL_STATIC_CONSTRUCTOR (vtv_fndecl) = 0;\n \n       gimplify_function_tree (vtv_fndecl);\n       cgraph_node::add_new_function (vtv_fndecl, false);\n \n       symtab->process_new_functions ();\n \n+#if defined (TARGET_PECOFF)\n+      if (flag_vtable_verify == VTV_PREINIT_PRIORITY && !TARGET_PECOFF)\n+#else\n       if (flag_vtable_verify == VTV_PREINIT_PRIORITY)\n+#endif\n         assemble_vtv_preinit_initializer (vtv_fndecl);\n \n     }"}, {"sha": "2069432ad9a4688180c90970144df65a0827ed14", "filename": "gcc/varasm.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -2252,6 +2252,33 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \t\t\t\t         | SECTION_LINKONCE,\n \t\t\t    \t         DECL_NAME (decl));\n           in_section = sect;\n+#elif defined (TARGET_PECOFF)\n+          /* Neither OBJECT_FORMAT_PE, nor OBJECT_FORMAT_COFF is set here.\n+             Therefore the following check is used.\n+             In case a the target is PE or COFF a comdat group section\n+             is created, e.g. .vtable_map_vars$foo. The linker places\n+             everything in .vtable_map_vars at the end.\n+\n+             A fix could be made in\n+             gcc/config/i386/winnt.c: i386_pe_unique_section. */\n+          if (TARGET_PECOFF)\n+          {\n+            char *name;\n+            \n+            if (TREE_CODE (DECL_NAME (decl)) == IDENTIFIER_NODE)\n+              name = ACONCAT ((sect->named.name, \"$\",\n+                               IDENTIFIER_POINTER (DECL_NAME (decl)), NULL));\n+            else\n+              name = ACONCAT ((sect->named.name, \"$\",\n+                    IDENTIFIER_POINTER (DECL_COMDAT_GROUP (DECL_NAME (decl))),\n+                    NULL));\n+\n+            targetm.asm_out.named_section (name,\n+                                           sect->named.common.flags\n+                                           | SECTION_LINKONCE,\n+                                           DECL_NAME (decl));\n+            in_section = sect;\n+        }\n #else\n           switch_to_section (sect);\n #endif"}, {"sha": "5600d56bb86fc6e1ff5649c92489e92b74c6ac02", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -1,3 +1,13 @@\n+2015-01-27  Caroline Tice  <cmtice@google.com>\n+\n+\tCommitting VTV Cywin/Ming patch for Patrick Wollgast\n+\t* Makefile.in: Move rules to build vtv_*.o out of the check\n+\tfor CUSTOM_CRTSTUFF.\n+\t* config.host (i[34567]86-*-cygwin*, x86_64-*-cygwin*,\n+\ti[34567]86-*-mingw*)\n+\t (x86_64-*-mingw*): Only add vtv_*.o to extra_parts if\n+\tenable_vtable_verify.\n+\n 2015-01-27  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rl78/cmpsi2.S: Use function start and end macros."}, {"sha": "88ddfea18eb229cfbf7bc098bada4ce31dfcf159", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -1003,6 +1003,7 @@ crtoffloadbegin$(objext): $(srcdir)/offloadstuff.c\n \n crtoffloadend$(objext): $(srcdir)/offloadstuff.c\n \t$(crt_compile) $(CRTSTUFF_T_CFLAGS) -c $< -DCRT_END\n+endif\n \n ifeq ($(enable_vtable_verify),yes)\n # These are used in vtable verification; see comments in source files for\n@@ -1019,7 +1020,6 @@ vtv_start_preinit$(objext): $(srcdir)/vtv_start_preinit.c\n vtv_end_preinit$(objext): $(srcdir)/vtv_end_preinit.c\n \t$(crt_compile) $(CRTSTUFF_T_CFLAGS_S) -c $(srcdir)/vtv_end_preinit.c\n endif\n-endif\n \n ifeq ($(CUSTOM_CRTIN),)\n # -x assembler-with-cpp is only needed on case-insensitive filesystem."}, {"sha": "5baeae54e6c44a6965e29e04807caba4b16ad8bd", "filename": "libgcc/config.host", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -626,6 +626,9 @@ i[4567]86-wrs-vxworks|i[4567]86-wrs-vxworksae)\n \t;;\n i[34567]86-*-cygwin*)\n \textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtfastmath.o\"\n+\tif test x$enable_vtable_verify = xyes; then\n+\t\textra_parts=\"$extra_parts vtv_start.o vtv_end.o vtv_start_preinit.o vtv_end_preinit.o\"\n+\tfi\n \t# This has to match the logic for DWARF2_UNWIND_INFO in gcc/config/i386/cygming.h\n \tif test x$enable_sjlj_exceptions = xyes; then\n \t\ttmake_eh_file=\"i386/t-sjlj-eh\"\n@@ -642,6 +645,9 @@ i[34567]86-*-cygwin*)\n \t;;\n x86_64-*-cygwin*)\n \textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtfastmath.o\"\n+\tif test x$enable_vtable_verify = xyes; then\n+\t\textra_parts=\"$extra_parts vtv_start.o vtv_end.o vtv_start_preinit.o vtv_end_preinit.o\"\n+\tfi\n \t# This has to match the logic for DWARF2_UNWIND_INFO in gcc/config/i386/cygming.h\n \tif test x$enable_sjlj_exceptions = xyes; then\n \t\ttmake_eh_file=\"i386/t-sjlj-eh\"\n@@ -659,6 +665,9 @@ x86_64-*-cygwin*)\n \t;;\n i[34567]86-*-mingw*)\n \textra_parts=\"crtbegin.o crtend.o crtfastmath.o\"\n+\tif test x$enable_vtable_verify = xyes; then\n+\t\textra_parts=\"$extra_parts vtv_start.o vtv_end.o vtv_start_preinit.o vtv_end_preinit.o\"\n+\tfi\n \tcase ${target_thread_file} in\n \t  win32)\n \t    tmake_file=\"$tmake_file i386/t-gthr-win32\"\n@@ -705,6 +714,9 @@ x86_64-*-mingw*)\n \tfi\n \ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_dlldir_file} i386/t-slibgcc-cygming i386/t-cygming i386/t-mingw32 t-dfprules i386/t-crtfm i386/t-chkstk\"\n \textra_parts=\"$extra_parts crtbegin.o crtend.o crtfastmath.o\"\n+\tif test x$enable_vtable_verify = xyes; then\n+\t\textra_parts=\"$extra_parts vtv_start.o vtv_end.o vtv_start_preinit.o vtv_end_preinit.o\"\n+\tfi\n \t;;\n i[34567]86-*-interix[3-9]*)\n \ttmake_file=\"$tmake_file i386/t-interix i386/t-chkstk\""}, {"sha": "5e1aeaeeb52ef13f436dcf85b26a07202a1e10d4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -1,3 +1,18 @@\n+2015-01-27  Caroline Tice  <cmtice@google.com>\n+\n+\tCommitting VTV Cywin/Ming patch for Patrick Wollgast\n+\t* acinclude.m4: Define VTV_CYGMIN.\n+\t* configure: Regenerate.\n+\t* libsupc++/Makefile.am: Add vtv_sources only to libsupc___la_SOURCES\n+\tand libsupc__convenience_la_SOURCES if VTV_CYGMIN is not set.\n+\t* libsupc++/Makefile.in: Regenerated.\n+\t* libsupc++/vtv_stubs.cc: Add none weak declaration of every function\n+\tfor Cygwin and MinGW.\n+\t* src/Makefile.am: Add libvtv.la to toolexeclib_LTLIBRARIES, if\n+\tVTV_CYGMIN is set. Define libvtv_la_SOURCES, libvtv_la_LDFLAGS,\n+\tlibvtv_la_AM_CXXFLAGS and libvtv_la_LINK if VTV_CYGMIN is set.\n+\t* libstdc++-v3/src/Makefile.in: Regenerate.\n+\n 2015-01-28  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/64828"}, {"sha": "59df22d87033ebb405ae94b8ec68153aef69fbb3", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -2321,7 +2321,17 @@ AC_DEFUN([GLIBCXX_ENABLE_VTABLE_VERIFY], [\n   AC_MSG_RESULT([$enable_vtable_verify])\n \n   if test $enable_vtable_verify = yes; then\n-    VTV_CXXFLAGS=\"-fvtable-verify=std -Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end\"\n+    case ${target_os} in\n+      cygwin*|mingw32*)\n+        VTV_CXXFLAGS=\"-fvtable-verify=std -Wl,-lvtv,-u_vtable_map_vars_start,-u_vtable_map_vars_end\"\n+        vtv_cygmin=\"yes\"\n+        ;;\n+      *)\n+        VTV_CXXFLAGS=\"-fvtable-verify=std -Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end\"\n+        vtv_cygmin=\"no\"\n+        ;;\n+    esac\n+    AM_CONDITIONAL(VTV_CYGMIN, test $vtv_cygmin = yes)\n     VTV_PCH_CXXFLAGS=\"-fvtable-verify=std\"\n     VTV_CXXLINKFLAGS=\"-L${toplevel_builddir}/libvtv/.libs -Wl,--rpath -Wl,${toplevel_builddir}/libvtv/.libs\"\t\t\n   else"}, {"sha": "651a66254be6e612dd8c06599c6763a34c8dbb0f", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -100,9 +100,11 @@ sources = \\\n \tvterminate.cc\n \n if ENABLE_VTABLE_VERIFY\n+if !VTV_CYGMIN\n   vtv_sources = \\\n \tvtv_stubs.cc\n endif\n+endif\n \n libsupc___la_SOURCES = $(sources) $(c_sources) $(vtv_sources)\n libsupc__convenience_la_SOURCES = $(sources) $(c_sources) $(vtv_sources)"}, {"sha": "e573b336ee5abd04230bf7ef9c02cc0223c64ff2", "filename": "libstdc++-v3/libsupc++/vtv_stubs.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvtv_stubs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvtv_stubs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvtv_stubs.cc?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -37,6 +37,39 @@\n \n #include <cstddef>\n \n+/* weak symbols on Windows work differently than on Linux. To be able\n+   to switch vtv on and off on Windows two dlls are built. One with\n+   the sources from libvtv, the other from these stubs. Depending on\n+   which dll is placed in the folder of the executable the functions\n+   from libvtv or the stubs functions are used. */\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+extern \"C\"\n+void\n+__VLTChangePermission(int);\n+\n+void\n+__VLTRegisterSet(void**, const void*, std::size_t, std::size_t,\n+\t\t void**);\n+\n+void\n+__VLTRegisterPair(void**, const void*, std::size_t,\n+\t\t  const void*);\n+\n+const void*\n+__VLTVerifyVtablePointer(void**, const void*);\n+\n+void\n+__VLTRegisterSetDebug(void**, const void*, std::size_t, std::size_t,\n+\t\t      void**);\n+\n+void\n+__VLTRegisterPairDebug(void**, const void*, std::size_t, const void*,\n+\t\t       const char*, const char*);\n+\n+const void*\n+__VLTVerifyVtablePointerDebug(void**, const void*, const char*,\n+\t\t\t      const char*);\n+#else\n // Declare as weak for libsupc++, strong definitions are in libvtv.\n #if __GXX_WEAK__\n extern \"C\"\n@@ -66,6 +99,7 @@ const void*\n __VLTVerifyVtablePointerDebug(void**, const void*, const char*,\n \t\t\t      const char*) __attribute__((weak));\n #endif\n+#endif\n \n // Stub definitions.\n extern \"C\""}, {"sha": "debf967801fd0599265414a6d8bc0f1cea1a228c", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -25,7 +25,30 @@ include $(top_srcdir)/fragment.am\n SUBDIRS = c++98 c++11\n \n # Cross compiler support.\n+if VTV_CYGMIN\n+toolexeclib_LTLIBRARIES = libvtv.la libstdc++.la\n+else\n toolexeclib_LTLIBRARIES = libstdc++.la\n+endif\n+\n+if VTV_CYGMIN\n+vtv_stubs.cc:\n+\trm -f $@\n+\t$(LN_S) $(toplevel_srcdir)/libstdc++-v3/libsupc++/vtv_stubs.cc $@\n+\n+libvtv_la_SOURCES = vtv_stubs.cc\n+libvtv_la_LDFLAGS = $(lt_host_flags)\n+\n+libvtv_la_AM_CXXFLAGS = \\\n+\t$(glibcxx_compiler_pic_flag) \\\n+\t$(XTEMPLATE_FLAGS) \\\n+\t-Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end \\\n+\t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n+\n+libvtv_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(libvtv_la_AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libvtv_la_LDFLAGS) $(LDFLAGS) -o $@\n+endif\n \n vpath % $(top_srcdir)/src/c++98\n vpath % $(top_srcdir)/src/c++11"}, {"sha": "7b80282a5f820aa9e5f91e30aa8cc887ac96829e", "filename": "libvtv/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2FChangeLog?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -1,3 +1,50 @@\n+2015-01-27  Caroline Tice  <cmtice@google.com>\n+\n+\tCommitting VTV Cywin/Ming patch for Patrick Wollgast\n+\t* libvtv/Makefile.am : Add libvtv.la to toolexeclib_LTLIBRARIES, if\n+\tVTV_CYGMIN is set. Define libvtv_la_LIBADD, libvtv_la_LDFLAGS,\n+\tlibvtv_stubs_la_LDFLAGS and libvtv_stubs_la_SOURCES if VTV_CYGMIN is\n+\tset. Add obstac.c to libvtv_la_SOURCES if VTV_CYGMIN is set.\n+\t* libvtv/Makefile.in : Regenerate.\n+\t* libvtv/aclocal.m4 : Regenerate.\n+\t* libvtv/configure : Regenerate.\n+\t* libvtv/configure.ac : Add ACX_LT_HOST_FLAGS. Define VTV_CYGMIN.\n+\t* libvtv/configure.tgt : (x86_64-*-cygwin*, i?86-*-cygwin*,\n+\tx86_64-*-mingw*)\n+        (i?86-*-mingw*): Add to supported targets.\n+\t* libvtv/vtv_fail.cc : Skip inclusion of execinfo.h on Cygwin and MinGW.\n+\t(log_error_message): Skip calls to backtrace and backtrace_symbols_fd\n+\ton Cygwin and MinGW.\n+\t* libvtv/vtv_malloc.cc : Include windows.h and skip sys/mman.h\n+\tinclusion on Cygwin and MinGW. Add sysconf port on Cygwin and MinGW.\n+\t(obstack_chunk_alloc): Exchange call to mmap with call to VirtualAlloc\n+\ton Cygwin and MinGW.\n+\t(__vtv_malloc_init): Exchange call to sysconf with call to port of\n+\tsysconf on Cygwin and MinGW.\n+\t* libvtv/vtv_malloc.h : Declare mprotect and define PROT_READ and\n+\tPROT_WRITE on Cygwin and MinGW.\n+\t* libvtv/map.h : Include stdint.h on MinGW.\n+\t* libvtv/rts.cc : Include windows.h, winternl.h and psapi.h, skip\n+\tinclude of execinfo.h, sys/mman.h and link.h on Cygwin and MinGW.  Add\n+\tport of __fortify_fail on Cygwin and MinGW.  Change ElfW (Addr) to\n+\tuintptr_t on Cygwin and MinGW.\n+\t(read_section_offset_and_length): Add port for Cygwin and MinGW\n+\t(iterate_modules): New function.\n+\t(vtv_unprotect_vtable_vars): Use iterate_modules instead of\n+\tdl_iterate_phdr on Cygwin and MinGW.\n+\t(vtv_protect_vtable_vars): Likewise.\n+\t(count_all_pages): Likewise.\n+\t(dl_iterate_phdr_count_pages): Don't build on Cygwin and MinGW.\n+\t* libvtv/utils.cc : Include windows.h and skip execinfo.h inclusion on\n+\t Cygwin and MinGW.\n+\t(__vtv_open_log): Exchange call to getuid and getpid with\n+\tGetCurrentProcessId and adjust call to snprintf accordingly on Cygwin\n+\tand MinGW.  Adjust calls to mkdir on MinGW.  Adjust call to open on\n+\tCygwin and MinGW.\n+\t(__vtv_add_to_log): Adjust call to snprintf on Cygwin and MinGW.\n+\t(__vtv_log_verification_failure): Don't generate a backtrace on Cygwin\n+\tand MinGW.\n+\n 2014-12-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* testsuite/lib/libvtv.exp: Load target-utils.exp"}, {"sha": "2c9fb548d5f3070cea3f68e2428607bf36b112c8", "filename": "libvtv/Makefile.am", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2FMakefile.am?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -38,7 +38,11 @@ AM_CXXFLAGS = $(XCFLAGS)\n AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n AM_CXXFLAGS += -Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end\n \n-toolexeclib_LTLIBRARIES = libvtv.la\n+if VTV_CYGMIN\n+  toolexeclib_LTLIBRARIES = libvtv.la libvtv_stubs.la\n+else\n+  toolexeclib_LTLIBRARIES = libvtv.la\n+endif\n \n vtv_headers = \\\n \tvtv_map.h \\\n@@ -55,6 +59,11 @@ vtv_sources = \\\n         vtv_utils.cc \\\n \tvtv_end.c\n \n+vtv_stubs_sources = \\\n+\tvtv_start.c \\\n+\tvtv_stubs.cc \\\n+\tvtv_end.c\n+\n libvtv_includedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n \n # Link in vtv_start and vtv_end. \n@@ -67,8 +76,29 @@ vtv_end.c:\n \trm -f $@\n \t$(LN_S) $(toplevel_srcdir)/libgcc/vtv_end.c $@\n \n+if VTV_CYGMIN\n+  obstack.c:\n+\t  rm -f $@\n+\t  $(LN_S) $(toplevel_srcdir)/libiberty/obstack.c $@\n+  \n+  vtv_stubs.cc:\n+\t  rm -f $@\n+\t  $(LN_S) $(toplevel_srcdir)/libstdc++-v3/libsupc++/vtv_stubs.cc $@\n+endif\n+\n+if VTV_CYGMIN\n+  libvtv_la_LIBADD = -lpsapi\n+  libvtv_la_LDFLAGS = $(lt_host_flags)\n+  libvtv_stubs_la_LDFLAGS = $(lt_host_flags)\n+endif\n+\n if ENABLE_VTABLE_VERIFY\n+if VTV_CYGMIN\n+  libvtv_la_SOURCES = $(vtv_sources) obstack.c\n+  libvtv_stubs_la_SOURCES = $(vtv_stubs_sources)\n+else\n   libvtv_la_SOURCES = $(vtv_sources)\n+endif\n   libvtv_include_HEADERS = $(vtv_headers)\n else\n   libvtv_la_SOURCES =\n@@ -78,6 +108,8 @@ endif\n # Least ordering for dependencies mean linking w/o libstdc++ for as\n # long as the development of libvtv does not absolutely require it.\n CXXVTV=$(CC_FOR_TARGET)\n+CXXLD=$(CC_FOR_TARGET)\n+\n LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=compile $(CXXVTV) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)"}, {"sha": "f0af8ede0c40bf2c3fdc851ed0f82ef30e95ac0c", "filename": "libvtv/configure.ac", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fconfigure.ac?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -122,6 +122,7 @@ AC_CHECK_TOOL(RANLIB, ranlib, :)\n # Configure libtool\n AC_LIBTOOL_DLOPEN\n AM_PROG_LIBTOOL\n+ACX_LT_HOST_FLAGS\n AC_SUBST(enable_shared)\n AC_SUBST(enable_static)\n \n@@ -155,4 +156,15 @@ _EOF\n ])\n fi\n \n+case \"$target_os\" in\n+  cygwin*|mingw32*)\n+    vtv_cygmin=\"yes\"\n+    ;;\n+  *)\n+    vtv_cygmin=\"no\"\n+    ;;\n+esac\n+\n+AM_CONDITIONAL(VTV_CYGMIN, test $vtv_cygmin = yes)\n+\n AC_OUTPUT"}, {"sha": "00fb4d51ed4fabf598d003420ab7dc17cac44624", "filename": "libvtv/configure.tgt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fconfigure.tgt?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -26,6 +26,12 @@ case \"${target}\" in\n   x86_64-*-linux* | i?86-*-linux*)\n \tVTV_SUPPORTED=yes\n \t;;\n+  x86_64-*-cygwin* | i?86-*-cygwin*)\n+\tVTV_SUPPORTED=yes\n+\t;;\n+  x86_64-*-mingw* | i?86-*-mingw*)\n+\tVTV_SUPPORTED=yes\n+\t;;\n   powerpc*-*-linux*)\n \t;;\n   sparc*-*-linux*)"}, {"sha": "7e7992267aab6d81026a44f60a9ec34a7f52992c", "filename": "libvtv/vtv_fail.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_fail.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_fail.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_fail.cc?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -46,7 +46,11 @@\n #include <stdlib.h>\n #include <stdio.h>\n #include <string.h>\n+\n+#if !defined (__CYGWIN__) && !defined (__MINGW32__)\n #include <execinfo.h>\n+#endif\n+\n #include <unistd.h>\n \n #include \"vtv_utils.h\"\n@@ -102,8 +106,10 @@ log_error_message (const char *log_msg, bool generate_backtrace)\n     {\n #define STACK_DEPTH 20\n       void *callers[STACK_DEPTH];\n+#if !defined (__CYGWIN__) && !defined (__MINGW32__)\n       int actual_depth = backtrace (callers, STACK_DEPTH);\n       backtrace_symbols_fd (callers, actual_depth, vtv_failures_log_fd);\n+#endif\n     }\n }\n "}, {"sha": "4b675f40bdc047f70d658c620406f8ed44457233", "filename": "libvtv/vtv_malloc.cc", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_malloc.cc?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -33,7 +33,11 @@\n \n #include <stdlib.h>\n #include <unistd.h>\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+#include <windows.h>\n+#else\n #include <sys/mman.h>\n+#endif\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <fcntl.h>\n@@ -62,6 +66,18 @@ static void *current_chunk VTV_PROTECTED_VAR = 0;\n static size_t current_chunk_size VTV_PROTECTED_VAR = 0;\n static int malloc_initialized VTV_PROTECTED_VAR = 0;\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+//sysconf(_SC_PAGE_SIZE) port\n+long sysconf_SC_PAGE_SIZE()\n+{\n+  SYSTEM_INFO si;\n+  GetSystemInfo(&si);\n+  long pageSize = (long)si.dwPageSize;\n+  return pageSize;\n+  //return 4096; // standard usermode 32bit pagesize in bytes // FIXME\n+}\n+#endif\n+\n /* The function goes through and counts all the pages we have allocated\n    so far.  It returns the page count.  */\n \n@@ -162,8 +178,13 @@ obstack_chunk_alloc (size_t size)\n   VTV_DEBUG_ASSERT ((size & (VTV_PAGE_SIZE - 1)) == 0);\n   void *allocated;\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+  if ((allocated = VirtualAlloc(NULL, size,  MEM_RESERVE|MEM_COMMIT,\n+                         PAGE_READWRITE)) == 0)\n+#else\n   if ((allocated = mmap (NULL, size, PROT_READ | PROT_WRITE,\n                          MAP_PRIVATE | MAP_ANONYMOUS,  -1, 0)) == 0)\n+#endif\n     VTV_error ();\n \n   VTV_DEBUG_ASSERT (((unsigned long) allocated & (VTV_PAGE_SIZE - 1)) == 0);\n@@ -190,7 +211,11 @@ __vtv_malloc_init (void)\n   if (malloc_initialized)\n     return;\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+  if (VTV_PAGE_SIZE != sysconf_SC_PAGE_SIZE())\n+#else\n   if (VTV_PAGE_SIZE != sysconf (_SC_PAGE_SIZE))\n+#endif\n     VTV_error ();\n \n   obstack_chunk_size (&vtv_obstack) = VTV_PAGE_SIZE;"}, {"sha": "2af565f6e661ce6306a06d675d9fa2b962e6cfe7", "filename": "libvtv/vtv_malloc.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_malloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_malloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_malloc.h?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -95,4 +95,11 @@ extern void __vtv_malloc_stats (void);\n extern void __vtv_malloc_dump_stats (void);\n extern int __vtv_count_mmapped_pages (void);\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+extern \"C\" int mprotect (void *addr, int len, int prot);\n+\n+  #define PROT_READ 0x1\n+  #define PROT_WRITE 0x2\n+#endif\n+\n #endif /* vtv_malloc.h */"}, {"sha": "91665bc773d914284b4111b548f7c3c883999b42", "filename": "libvtv/vtv_map.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_map.h?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -26,7 +26,13 @@\n #define _VTV_MAP_H 1\n \n #include <string.h>\n+\n+#ifdef __MINGW32__\n+#include <stdint.h>\n+#include \"vtv_utils.h\"\n+#else\n #include <vtv_utils.h>\n+#endif\n \n inline uint64_t\n load8bytes (const void *p)"}, {"sha": "f5344a00687c3a7fe3e012f2f76bd699faf463cb", "filename": "libvtv/vtv_rts.cc", "status": "modified", "additions": 290, "deletions": 5, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_rts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_rts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_rts.cc?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -121,12 +121,20 @@\n #include <stdlib.h>\n #include <stdio.h>\n #include <string.h>\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+#include <windows.h>\n+#include <winternl.h>\n+#include <psapi.h>\n+#else\n #include <execinfo.h>\n+#endif\n \n #include <unistd.h>\n+#if !defined (__CYGWIN__) && !defined (__MINGW32__)\n #include <sys/mman.h>\n-#include <errno.h>\n #include <link.h>\n+#endif\n+#include <errno.h>\n #include <fcntl.h>\n #include <limits.h>\n \n@@ -143,6 +151,13 @@\n \n #include \"vtv-change-permission.h\"\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+// porting: fix link error to libc\n+void __fortify_fail (const char * msg){\n+    OutputDebugString(msg);\n+    abort();\n+}\n+#else\n extern \"C\" {\n \n   /* __fortify_fail is a function in glibc that calls __libc_message,\n@@ -159,6 +174,7 @@ extern \"C\" {\n   extern void __fortify_fail (const char *) __attribute__((noreturn));\n \n } /* extern \"C\" */\n+#endif\n \n /* The following variables are used only for debugging and performance\n    tuning purposes. Therefore they do not need to be \"protected\".\n@@ -313,10 +329,17 @@ typedef vtv_set_handle * vtv_set_handle_handle;\n \n struct sect_hdr_data\n {\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+  uintptr_t dlpi_addr;    /* The header address in the INFO record,\n+                            passed in from dl_iterate_phdr.  */\n+  uintptr_t mp_low;       /* Start address of the .vtable_map_vars\n+                            section in memory.  */\n+#else\n   ElfW (Addr) dlpi_addr; /* The header address in the INFO record,\n                             passed in from dl_iterate_phdr.  */\n   ElfW (Addr) mp_low;    /* Start address of the .vtable_map_vars\n                             section in memory.  */\n+#endif\n   size_t mp_size;        /* Size of the .vtable_map_vars section in\n                             memory.  */\n };\n@@ -336,8 +359,13 @@ unsigned int num_cache_entries VTV_PROTECTED_VAR = 0;\n    it returns the record for that entry; otherwise it returns\n    NULL.  */\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+struct sect_hdr_data *\n+search_cached_file_data (uintptr_t load_addr)\n+#else\n struct sect_hdr_data *\n search_cached_file_data (ElfW (Addr) load_addr)\n+#endif\n {\n   unsigned int i;\n   for (i = 0; i < num_cache_entries; ++i)\n@@ -401,6 +429,130 @@ log_memory_protection_data (char *message)\n   __vtv_add_to_log (log_fd, \"%s\", message);\n }\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+static void\n+read_section_offset_and_length (char *name,\n+                                uintptr_t addr,\n+                                const char *sect_name,\n+                                int mprotect_flags,\n+                                off_t *sect_offset,\n+                                WORD *sect_len)\n+{\n+  bool found = false;\n+  struct sect_hdr_data *cached_data = NULL;\n+\n+  /* Check to see if we already have the data for this file.  */\n+  cached_data = search_cached_file_data (addr);\n+\n+  if (cached_data)\n+    {\n+      *sect_offset = cached_data->mp_low;\n+      *sect_len = cached_data->mp_size;\n+      return;\n+    }\n+\n+  // check for DOS Header magic bytes\n+  if (*(WORD *)addr == 0x5A4D)\n+    {\n+      int name_len = strlen (sect_name);\n+      int fd = -1;\n+\n+      /* Attempt to open the binary file on disk.  */\n+      if (strlen (name) == 0)\n+        {\n+          return;\n+        }\n+      else\n+        fd = open (name, O_RDONLY | O_BINARY);\n+\n+      if (fd != -1)\n+        {\n+          /* Find the section header information in memory.  */\n+          PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)addr;\n+          PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((char *)addr\n+                                          + pDosHeader->e_lfanew);\n+          PIMAGE_FILE_HEADER pFileHeader = &pNtHeaders->FileHeader;\n+\n+          DWORD PointerToStringTable = pFileHeader->PointerToSymbolTable\n+                                        + (pFileHeader->NumberOfSymbols*0x12);\n+\n+          PIMAGE_SECTION_HEADER sect_hdr = \n+            (PIMAGE_SECTION_HEADER)((char *)&pNtHeaders->OptionalHeader\n+                                       + pFileHeader->SizeOfOptionalHeader);\n+\n+          /* Loop through all the section headers, looking for one whose\n+             name is \".vtable_map_vars\".  */\n+\n+          for (int i = 0; i < pFileHeader->NumberOfSections && !found; ++i)\n+            {\n+              char header_name[64];\n+\n+              /* Check if we have to get the section name from the COFF string\n+                 table. */\n+              if (sect_hdr[i].Name[0] == '/')\n+                {\n+                  if (atoi((const char*)sect_hdr[i].Name+1) == 0)\n+                    {\n+                      continue;\n+                    }\n+\n+                  off_t name_offset = PointerToStringTable\n+                                       + atoi((const char*)sect_hdr[i].Name+1);\n+\n+                  size_t bytes_read = ReadFromOffset (fd, &header_name, 64,\n+                                                      name_offset);\n+\n+                  VTV_ASSERT (bytes_read > 0);\n+                }\n+              else\n+                {\n+                  memcpy (&header_name, sect_hdr[i].Name,\n+                          sizeof (sect_hdr[i].Name));\n+                }\n+\n+              if (memcmp (header_name, sect_name, name_len) == 0)\n+                {\n+                  /* We found the section; get its load offset and\n+                     size.  */\n+                  *sect_offset = sect_hdr[i].VirtualAddress;\n+      if (sect_hdr[i].Misc.VirtualSize % VTV_PAGE_SIZE != 0)\n+        *sect_len = sect_hdr[i].Misc.VirtualSize + VTV_PAGE_SIZE\n+                     - (sect_hdr[i].Misc.VirtualSize % VTV_PAGE_SIZE);\n+      else\n+        *sect_len = sect_hdr[i].Misc.VirtualSize;\n+                  found = true;\n+                }\n+            }\n+          close (fd);\n+        }\n+    }\n+\n+  if (*sect_offset != 0 && *sect_len != 0)\n+    {\n+      /* Calculate the page location in memory, making sure the\n+         address is page-aligned.  */\n+      uintptr_t start_addr = addr + *sect_offset;\n+      *sect_offset = start_addr & ~(VTV_PAGE_SIZE - 1);\n+      *sect_len = *sect_len - 1;\n+\n+      /* Since we got this far, we must not have found these pages in\n+         the cache, so add them to it.  NOTE: We could get here either\n+         while making everything read-only or while making everything\n+         read-write.  We will only update the cache if we get here on\n+         a read-write (to make absolutely sure the cache is writable\n+         -- also the read-write pass should come before the read-only\n+         pass).  */\n+      if ((mprotect_flags & PROT_WRITE)\n+          && num_cache_entries < MAX_ENTRIES)\n+        {\n+          vtv_sect_info_cache[num_cache_entries].dlpi_addr = addr;\n+          vtv_sect_info_cache[num_cache_entries].mp_low = *sect_offset;\n+          vtv_sect_info_cache[num_cache_entries].mp_size = *sect_len;\n+          num_cache_entries++;\n+        }\n+    }\n+}\n+#else\n static void\n read_section_offset_and_length (struct dl_phdr_info *info,\n                                 const char *sect_name,\n@@ -547,7 +699,125 @@ read_section_offset_and_length (struct dl_phdr_info *info,\n         }\n     }\n }\n+#endif\n+\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+/* This function is used to iterate over all loaded modules and searches\n+   for a section called \".vtable_map_vars\". The only interaction with \n+   the binary file on disk of the module is to read section names in the\n+   COFF string table. If the module contains a \".vtable_map_vars\" section,\n+   read section offset and size from the section header of the loaded module.\n+   Call 'mprotect' on those pages, setting the protection either to\n+   read-only or read-write, depending on what's in data.\n+   The calls to change the protection occur in vtv_unprotect_vtable_vars \n+   and vtv_protect_vtable_vars.  */\n+\n+static int\n+iterate_modules (void *data)\n+{\n+  int * mprotect_flags = (int *) data;\n+  off_t map_sect_offset = 0;\n+  WORD map_sect_len = 0;\n+  char buffer[1024];\n+  const char *map_sect_name = VTV_PROTECTED_VARS_SECTION;\n+  HMODULE hMods[1024];\n+  HANDLE hProcess;\n+  DWORD cbNeeded;\n \n+  hProcess = GetCurrentProcess ();\n+\n+  if (NULL == hProcess)\n+    return 0;\n+\n+  if (EnumProcessModules (hProcess, hMods, sizeof (hMods), &cbNeeded))\n+    {\n+      /* Iterate over all loaded modules. */\n+      for (unsigned int i = 0; i < (cbNeeded / sizeof (HMODULE)); i++)\n+        {\n+          char szModName[MAX_PATH];\n+\n+          if (GetModuleFileNameExA (hProcess, hMods[i], szModName,\n+                        sizeof (szModName)))\n+            {\n+              map_sect_offset = 0;\n+              map_sect_len = 0;\n+              read_section_offset_and_length (szModName,\n+                                              (uintptr_t) hMods[i],\n+                                              map_sect_name, \n+                                              *mprotect_flags,\n+                                              &map_sect_offset,\n+                                              &map_sect_len);\n+\n+              if (debug_functions)\n+                {\n+                  snprintf (buffer, sizeof(buffer),\n+                \"  Looking at load module %s to change permissions to %s\\n\",\n+                szModName,\n+                (*mprotect_flags & PROT_WRITE) ? \"READ/WRITE\" : \"READ-ONLY\");\n+                  log_memory_protection_data (buffer);\n+                }\n+\n+              /* See if we actually found the section.  */\n+              if (map_sect_offset && map_sect_len)\n+                {\n+                  unsigned long long start;\n+                  int result;\n+\n+                  if (debug_functions)\n+                    {\n+                      snprintf (buffer, sizeof (buffer),\n+                                \"  (%s): Protecting %p to %p\\n\",\n+                                szModName,\n+                                (void *) map_sect_offset,\n+                                (void *) (map_sect_offset + map_sect_len));\n+                      log_memory_protection_data (buffer);\n+                    }\n+\n+                  /* Change the protections on the pages for the section.  */\n+\n+                  start = get_cycle_count ();\n+                  result = mprotect ((void *) map_sect_offset, map_sect_len,\n+                                     *mprotect_flags);\n+                  accumulate_cycle_count (&mprotect_cycles, start);\n+                  if (result == -1)\n+                    {\n+                      if (debug_functions)\n+                        {\n+                          snprintf (buffer, sizeof (buffer),\n+                                    \"Failed called to mprotect for %s error: \",\n+                                    (*mprotect_flags & PROT_WRITE) ?\n+                                    \"READ/WRITE\" : \"READ-ONLY\");\n+                          log_memory_protection_data (buffer);\n+                          perror(NULL);\n+                        }\n+                      VTV_error();\n+                    }\n+                  else\n+                    {\n+                      if (debug_functions)\n+                       {\n+                          snprintf (buffer, sizeof (buffer),\n+                                    \"mprotect'ed range [%p, %p]\\n\",\n+                                    (void *) map_sect_offset,\n+                                    (char *) map_sect_offset + map_sect_len);\n+                          log_memory_protection_data (buffer);\n+                        }\n+                    }\n+                  increment_num_calls (&num_calls_to_mprotect);\n+                  /* num_pages_protected += (map_sect_len + VTV_PAGE_SIZE - 1) \n+                                            / VTV_PAGE_SIZE; */\n+                  num_pages_protected += (map_sect_len + 4096 - 1) / 4096;\n+                  continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    CloseHandle(hProcess);\n+\n+  return 0;\n+}\n+#else\n /* This is the callback function used by dl_iterate_phdr (which is\n    called from vtv_unprotect_vtable_vars and vtv_protect_vtable_vars).\n    It attempts to find the binary file on disk for the INFO record\n@@ -652,6 +922,7 @@ dl_iterate_phdr_callback (struct dl_phdr_info *info, size_t, void *data)\n \n   return 0;\n }\n+#endif\n \n /* This function explicitly changes the protection (read-only or read-write)\n    on the vtv_sect_info_cache, which is used for speeding up look ups in the\n@@ -678,7 +949,7 @@ change_protections_on_phdr_cache (int protection_flag)\n   char * low_address = (char *) &(vtv_sect_info_cache);\n   size_t cache_size = MAX_ENTRIES * sizeof (struct sect_hdr_data);\n \n-  low_address = (char *) ((unsigned long) low_address & ~(VTV_PAGE_SIZE - 1));\n+  low_address = (char *) ((uintptr_t) low_address & ~(VTV_PAGE_SIZE - 1));\n   \n   if (mprotect ((void *) low_address, cache_size, protection_flag) == -1)\n     VTV_error ();\n@@ -695,7 +966,11 @@ vtv_unprotect_vtable_vars (void)\n \n   mprotect_flags = PROT_READ | PROT_WRITE;\n   change_protections_on_phdr_cache (mprotect_flags);\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+  iterate_modules ((void *) &mprotect_flags);\n+#else\n   dl_iterate_phdr (dl_iterate_phdr_callback, (void *) &mprotect_flags);\n+#endif\n }\n \n /* Protect all the vtable map vars and other side data that is used\n@@ -708,7 +983,11 @@ vtv_protect_vtable_vars (void)\n   int mprotect_flags;\n \n   mprotect_flags = PROT_READ;\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+  iterate_modules ((void *) &mprotect_flags);\n+#else\n   dl_iterate_phdr (dl_iterate_phdr_callback, (void *) &mprotect_flags);\n+#endif\n   change_protections_on_phdr_cache (mprotect_flags);\n }\n \n@@ -868,7 +1147,7 @@ const unsigned long SET_HANDLE_HANDLE_BIT = 0x2;\n static inline bool\n is_set_handle_handle (void * ptr)\n {\n-  return ((unsigned long) ptr & SET_HANDLE_HANDLE_BIT)\n+  return ((uintptr_t) ptr & SET_HANDLE_HANDLE_BIT)\n                                                       == SET_HANDLE_HANDLE_BIT;\n }\n \n@@ -878,7 +1157,7 @@ is_set_handle_handle (void * ptr)\n static inline vtv_set_handle * \n ptr_from_set_handle_handle (void * ptr)\n {\n-  return (vtv_set_handle *) ((unsigned long) ptr & ~SET_HANDLE_HANDLE_BIT);\n+  return (vtv_set_handle *) ((uintptr_t) ptr & ~SET_HANDLE_HANDLE_BIT);\n }\n \n /* Given a vtable map variable, PTR, this function sets the bit that\n@@ -888,7 +1167,7 @@ ptr_from_set_handle_handle (void * ptr)\n static inline vtv_set_handle_handle\n set_handle_handle (vtv_set_handle * ptr)\n {\n-  return (vtv_set_handle_handle) ((unsigned long) ptr | SET_HANDLE_HANDLE_BIT);\n+  return (vtv_set_handle_handle) ((uintptr_t) ptr | SET_HANDLE_HANDLE_BIT);\n }\n \n static inline void\n@@ -1362,6 +1641,7 @@ __VLTVerifyVtablePointer (void ** set_handle_ptr, const void * vtable_ptr)\n \n static int page_count_2 = 0;\n \n+#if !defined (__CYGWIN__) && !defined (__MINGW32__)\n static int\n dl_iterate_phdr_count_pages (struct dl_phdr_info *info,\n                              size_t unused __attribute__ ((__unused__)),\n@@ -1392,6 +1672,7 @@ dl_iterate_phdr_count_pages (struct dl_phdr_info *info,\n \n   return 0;\n }\n+#endif\n \n static void\n count_all_pages (void)\n@@ -1401,7 +1682,11 @@ count_all_pages (void)\n   mprotect_flags = PROT_READ;\n   page_count_2 = 0;\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+  iterate_modules ((void *) &mprotect_flags);\n+#else\n   dl_iterate_phdr (dl_iterate_phdr_count_pages, (void *) &mprotect_flags);\n+#endif\n   page_count_2 += __vtv_count_mmapped_pages ();\n }\n "}, {"sha": "ebbeaf51999f39dd9755378a87adb33ab6fe5e98", "filename": "libvtv/vtv_utils.cc", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_utils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f049fa4620ada6457ed6163b1fdf0de37a3258/libvtv%2Fvtv_utils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_utils.cc?ref=f7f049fa4620ada6457ed6163b1fdf0de37a3258", "patch": "@@ -33,7 +33,12 @@\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+#include <windows.h>\n+#else\n #include <execinfo.h>\n+#endif\n+\n #include <unistd.h>\n #include <errno.h>\n \n@@ -64,8 +69,12 @@ __vtv_open_log (const char *name)\n {\n   char log_name[1024];\n   char log_dir[512];\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+  pid_t process_id = GetCurrentProcessId ();\n+#else\n   uid_t user_id = getuid ();\n   pid_t process_id = getpid ();\n+#endif\n   char *logs_prefix;\n   bool logs_dir_specified = false;\n   int fd = -1;\n@@ -74,14 +83,29 @@ __vtv_open_log (const char *name)\n   if (logs_prefix && strlen (logs_prefix) > 0)\n     {\n       logs_dir_specified = true;\n+#ifdef __MINGW32__\n+      mkdir (logs_prefix);\n+#else\n       mkdir (logs_prefix, S_IRWXU);\n+#endif\n+\n       snprintf (log_dir, sizeof (log_dir), \"%s/vtv_logs\", logs_prefix);\n-      mkdir (log_dir, S_IRWXU);\n \n+#ifdef __MINGW32__\n+      mkdir (log_dir);\n+#else\n+      mkdir (log_dir, S_IRWXU);\n+#endif\n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+      snprintf (log_name, sizeof (log_name), \"%s_%d_%s\", log_dir,\n+\t\t(unsigned) process_id, name);\n+      fd = open (log_name, O_WRONLY | O_APPEND | O_CREAT, S_IRWXU);\n+#else\n       snprintf (log_name, sizeof (log_name), \"%s/%d_%d_%s\", log_dir,\n \t\t(unsigned) user_id, (unsigned) process_id, name);\n       fd = open (log_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW,\n \t\t S_IRWXU);\n+#endif\n     }\n   else\n     fd = dup (2);\n@@ -125,8 +149,12 @@ __vtv_add_to_log (int log_file, const char * format, ...)\n   va_list ap;\n   va_start (ap, format);\n \n+#if defined (__CYGWIN__) || defined (__MINGW32__)\n+  snprintf (output, sizeof (output), \"VTV: PID=%ld \", GetCurrentProcessId ());\n+#else\n   snprintf (output, sizeof (output), \"VTV: PID=%d PPID=%d \", getpid (),\n             getppid ());\n+#endif\n   vtv_log_write (log_file, output);\n   vsnprintf (output, sizeof (output), format, ap);\n   vtv_log_write (log_file, output);\n@@ -151,11 +179,13 @@ __vtv_log_verification_failure (const char *log_msg, bool generate_backtrace)\n \n   __vtv_add_to_log (vtv_failures_log_fd, \"%s\", log_msg);\n \n+#if !defined (__CYGWIN__) && !defined (__MINGW32__)\n   if (generate_backtrace)\n     {\n #define STACK_DEPTH 20\n       void *callers[STACK_DEPTH];\n       int actual_depth = backtrace (callers, STACK_DEPTH);\n       backtrace_symbols_fd (callers, actual_depth, vtv_failures_log_fd);\n     }\n+#endif\n }"}]}