{"sha": "272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "node_id": "C_kwDOANBUbNoAKDI3MmFkYTc0OTllNmNlOGUxYThiZDNmODJjMWNjMDMwYTUxZDA3NGU", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2022-08-17T16:50:42Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-12T08:16:49Z"}, "message": "[Ada] Parser and lexer cleanup\n\nThis patch makes various minor cleanup changes to the parser.\nNo change in behavior.\n\ngcc/ada/\n\n\t* par-tchk.adb, par-util.adb, prep.adb, prepcomp.adb, scng.adb:\n\tUse \"in\" instead of chains of \"=\" connected with \"or else\".\n\tLikewise for \"not in\", \"/=\", \"and then\". Misc cleanup.\n\t* par-ch10.adb, par-ch12.adb, par-ch13.adb, par-ch4.adb: Likewise.\n\t* par-ch8.adb, par-ch9.adb, par-endh.adb, par-sync.adb: Likewise.\n\t* par.adb\n\t(Pf_Rec): Remove filler, which was added August 25, 1993 to get\n\taround a compiler limitation that no longer exists. Minor cleanup.\n\tRemove useless qualfications.\n\t* par-ch3.adb: Remove redundant return statements.\n\t(Component_Scan_Loop): Remove loop name; there are no nested\n\tloops, so it's unnecessary and possibly misleading, and it causes\n\ttoo-long lines.\n\t* par-ch5.adb: DRY: Remove comments that repeat the comments in\n\tpar.adb.\n\t(P_Sequence_Of_Statements): It is better to initialize things on\n\tthe declaration. And constants are better than variables.\n\t(Test_Statement_Required): Remove unnecessary insertion of a null\n\tstatement.\n\t* par-ch6.adb, par-ch7.adb: DRY: Remove comments that repeat the\n\tcomments in par.adb.", "tree": {"sha": "24451793bc0d5f11414bed202922dc3440a49392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24451793bc0d5f11414bed202922dc3440a49392"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dad0ebe674d495a7e032a123d2d60c090729ef2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad0ebe674d495a7e032a123d2d60c090729ef2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad0ebe674d495a7e032a123d2d60c090729ef2c"}], "stats": {"total": 1344, "additions": 574, "deletions": 770}, "files": [{"sha": "70fd7ad70eaa6bac765a279eec5c2316d4d84196", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -279,10 +279,7 @@ package body Ch10 is\n                Set_Private_Present (Comp_Unit_Node, True);\n             end if;\n \n-         elsif Token = Tok_Procedure\n-           or else Token = Tok_Function\n-           or else Token = Tok_Generic\n-         then\n+         elsif Token in Tok_Procedure | Tok_Function | Tok_Generic then\n             Set_Private_Present (Comp_Unit_Node, True);\n          end if;\n       end if;\n@@ -300,8 +297,7 @@ package body Ch10 is\n \n          --  Allow task and protected for nice error recovery purposes\n \n-         exit when Token = Tok_Task\n-           or else Token = Tok_Protected;\n+         exit when Token in Tok_Task | Tok_Protected;\n \n          if Token = Tok_With then\n             Error_Msg_SC (\"misplaced WITH\");\n@@ -376,10 +372,7 @@ package body Ch10 is\n       elsif Token = Tok_Separate then\n          Set_Unit (Comp_Unit_Node, P_Subunit);\n \n-      elsif Token = Tok_Function\n-        or else Token = Tok_Not\n-        or else Token = Tok_Overriding\n-        or else Token = Tok_Procedure\n+      elsif Token in Tok_Function | Tok_Not | Tok_Overriding | Tok_Procedure\n       then\n          Set_Unit (Comp_Unit_Node, P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Pexp));\n \n@@ -392,10 +385,7 @@ package body Ch10 is\n \n          if SIS_Entry_Active then\n \n-            if Token = Tok_Begin\n-               or else Token = Tok_Identifier\n-               or else Token in Token_Class_Deckn\n-            then\n+            if Token in Tok_Begin | Tok_Identifier | Token_Class_Deckn then\n                Push_Scope_Stack;\n                Scopes (Scope.Last).Etyp := E_Name;\n                Scopes (Scope.Last).Sloc := SIS_Sloc;\n@@ -947,10 +937,7 @@ package body Ch10 is\n                   Save_Scan_State (Scan_State);\n                   Scan; -- past comma\n \n-                  if Token in Token_Class_Cunit\n-                    or else Token = Tok_Use\n-                    or else Token = Tok_Pragma\n-                  then\n+                  if Token in Token_Class_Cunit | Tok_Use | Tok_Pragma then\n                      Restore_Scan_State (Scan_State);\n                      exit;\n                   end if;\n@@ -1047,11 +1034,7 @@ package body Ch10 is\n \n       Ignore (Tok_Semicolon);\n \n-      if Token = Tok_Function\n-        or else Token = Tok_Not\n-        or else Token = Tok_Overriding\n-        or else Token = Tok_Procedure\n-      then\n+      if Token in Tok_Function | Tok_Not | Tok_Overriding | Tok_Procedure then\n          Body_Node := P_Subprogram (Pf_Pbod_Pexp);\n \n       elsif Token = Tok_Package then"}, {"sha": "0f124f041586e28a68bd375eb31e9f854cb686ba", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -114,10 +114,7 @@ package body Ch12 is\n \n       --  Check for generic renaming declaration case\n \n-      if Token = Tok_Package\n-        or else Token = Tok_Function\n-        or else Token = Tok_Procedure\n-      then\n+      if Token in Tok_Package | Tok_Function | Tok_Procedure then\n          Ren_Token := Token;\n          Scan; -- scan past PACKAGE, FUNCTION or PROCEDURE\n "}, {"sha": "62e58076baa965d44a63bef318efdd2c963dc25e", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -336,7 +336,7 @@ package body Ch13 is\n             --  Check for a missing aspect definition. Aspects with optional\n             --  definitions are not considered.\n \n-            if Token = Tok_Comma or else Token = Tok_Semicolon then\n+            if Token in Tok_Comma | Tok_Semicolon then\n                if not Opt then\n                   Error_Msg_Node_1 := Identifier (Aspect);\n                   Error_Msg_AP (\"aspect& requires an aspect definition\");\n@@ -367,7 +367,7 @@ package body Ch13 is\n                --  aspect Depends, Global, Refined_Depends, Refined_Global\n                --  or Refined_State lacks enclosing parentheses.\n \n-               if Token /= Tok_Left_Paren and then Token /= Tok_Null then\n+               if Token not in Tok_Left_Paren | Tok_Null then\n \n                   --  [Refined_]Depends\n \n@@ -571,7 +571,7 @@ package body Ch13 is\n                --  Attempt to detect ' or => following a potential aspect\n                --  mark.\n \n-               if Token = Tok_Apostrophe or else Token = Tok_Arrow then\n+               if Token in Tok_Apostrophe | Tok_Arrow then\n                   Restore_Scan_State (Scan_State);\n                   Error_Msg_AP -- CODEFIX\n                     (\"|missing \"\",\"\"\");\n@@ -603,7 +603,7 @@ package body Ch13 is\n \n                   --  Attempt to detect ' or => following potential aspect mark\n \n-                  if Token = Tok_Apostrophe or else Token = Tok_Arrow then\n+                  if Token in Tok_Apostrophe | Tok_Arrow then\n                      Restore_Scan_State (Scan_State);\n                      Error_Msg_SC -- CODEFIX\n                        (\"|\"\";\"\" should be \"\",\"\"\");"}, {"sha": "568483997082fe1e27366023b39203546745110f", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -145,10 +145,7 @@ package body Ch3 is\n \n       --  Here if := or something that we will take as equivalent\n \n-      elsif Token = Tok_Colon_Equal\n-        or else Token = Tok_Equal\n-        or else Token = Tok_Is\n-      then\n+      elsif Token in Tok_Colon_Equal | Tok_Equal | Tok_Is then\n          null;\n \n       --  Another possibility. If we have a literal followed by a semicolon,\n@@ -400,9 +397,7 @@ package body Ch3 is\n          --  Ada 2005 (AI-419): AARM 3.4 (2/2)\n \n          if (Ada_Version < Ada_2005 and then Token = Tok_Limited)\n-           or else Token = Tok_Private\n-           or else Token = Tok_Record\n-           or else Token = Tok_Null\n+           or else Token in Tok_Private | Tok_Record | Tok_Null\n          then\n             Error_Msg_AP (\"TAGGED expected\");\n          end if;\n@@ -610,7 +605,7 @@ package body Ch3 is\n \n                --  LIMITED RECORD or LIMITED NULL RECORD\n \n-               if Token = Tok_Record or else Token = Tok_Null then\n+               if Token in Tok_Record | Tok_Null then\n                   if Ada_Version = Ada_83 then\n                      Error_Msg_SP\n                        (\"(Ada 83) limited record declaration not allowed!\");\n@@ -1005,7 +1000,7 @@ package body Ch3 is\n       Type_Node : Node_Id;\n \n    begin\n-      if Token = Tok_Identifier or else Token = Tok_Operator_Symbol then\n+      if Token in Tok_Identifier | Tok_Operator_Symbol then\n          Type_Node := P_Subtype_Mark;\n          return P_Subtype_Indication (Type_Node, Not_Null_Present);\n \n@@ -2095,10 +2090,7 @@ package body Ch3 is\n \n       --  OK, not an aspect specification, so continue test for extension\n \n-      elsif Token = Tok_With\n-        or else Token = Tok_Record\n-        or else Token = Tok_Null\n-      then\n+      elsif Token in Tok_With | Tok_Record | Tok_Null then\n          T_With; -- past WITH or give error message\n \n          if Token = Tok_Limited then\n@@ -2279,7 +2271,7 @@ package body Ch3 is\n \n          --  Check for error of DIGITS or DELTA after a subtype mark\n \n-         elsif Token = Tok_Digits or else Token = Tok_Delta then\n+         elsif Token in Tok_Digits | Tok_Delta then\n             Error_Msg_SC\n               (\"accuracy definition not allowed in membership test\");\n             Scan; -- past DIGITS or DELTA\n@@ -2850,7 +2842,7 @@ package body Ch3 is\n                Error_Msg_GNAT_Extension (\"fixed-lower-bound array\", Token_Ptr);\n             end if;\n \n-            exit when Token = Tok_Right_Paren or else Token = Tok_Of;\n+            exit when Token in Tok_Right_Paren | Tok_Of;\n             T_Comma;\n          end loop;\n \n@@ -2865,7 +2857,7 @@ package body Ch3 is\n       --  constrained_array_definition, which will be processed further below.\n \n       elsif Prev_Token = Tok_Range\n-        and then Token /= Tok_Right_Paren and then Token /= Tok_Comma\n+        and then Token not in Tok_Right_Paren | Tok_Comma\n       then\n          --  If we have an expression followed by \"..\", then scan farther\n          --  and check for \"<>\" to see if we have a fixed-lower-bound range.\n@@ -2920,7 +2912,7 @@ package body Ch3 is\n                        (\"fixed-lower-bound array\", Token_Ptr);\n                   end if;\n \n-                  exit when Token = Tok_Right_Paren or else Token = Tok_Of;\n+                  exit when Token in Tok_Right_Paren | Tok_Of;\n                   T_Comma;\n                end loop;\n \n@@ -3382,7 +3374,7 @@ package body Ch3 is\n             Save_Scan_State (Scan_State); -- at Id\n             Scan; -- past Id\n \n-            if Token = Tok_Arrow or else Token = Tok_Vertical_Bar then\n+            if Token in Tok_Arrow | Tok_Vertical_Bar then\n                Restore_Scan_State (Scan_State); -- to Id\n                Append (P_Discriminant_Association, Constr_List);\n                goto Loop_Continue;\n@@ -3644,7 +3636,7 @@ package body Ch3 is\n          --  If we have an END or WHEN now, everything is fine, otherwise we\n          --  complain about the null, ignore it, and scan for more components.\n \n-         if Token = Tok_End or else Token = Tok_When then\n+         if Token in Tok_End | Tok_When then\n             Set_Null_Present (Component_List_Node, True);\n             return Component_List_Node;\n          else\n@@ -3657,13 +3649,11 @@ package body Ch3 is\n       P_Pragmas_Opt (Decls_List);\n \n       if Token /= Tok_Case then\n-         Component_Scan_Loop : loop\n+         loop\n             P_Component_Items (Decls_List);\n             P_Pragmas_Opt (Decls_List);\n \n-            exit Component_Scan_Loop when Token = Tok_End\n-              or else Token = Tok_Case\n-              or else Token = Tok_When;\n+            exit when Token in Tok_End | Tok_Case | Tok_When;\n \n             --  We are done if we do not have an identifier. However, if we\n             --  have a misspelled reserved identifier that is in a column to\n@@ -3679,7 +3669,7 @@ package body Ch3 is\n                   Save_Scan_State (Scan_State); -- at reserved id\n                   Scan; -- possible reserved id\n \n-                  if Token = Tok_Comma or else Token = Tok_Colon then\n+                  if Token in Tok_Comma | Tok_Colon then\n                      Restore_Scan_State (Scan_State);\n                      Scan_Reserved_Identifier (Force_Msg => True);\n \n@@ -3688,16 +3678,16 @@ package body Ch3 is\n \n                   else\n                      Restore_Scan_State (Scan_State);\n-                     exit Component_Scan_Loop;\n+                     exit;\n                   end if;\n \n                   --  Non-identifier that definitely was not reserved id\n \n                else\n-                  exit Component_Scan_Loop;\n+                  exit;\n                end if;\n             end if;\n-         end loop Component_Scan_Loop;\n+         end loop;\n       end if;\n \n       if Token = Tok_Case then\n@@ -3948,10 +3938,7 @@ package body Ch3 is\n       loop\n          P_Pragmas_Opt (Variants_List);\n \n-         if Token /= Tok_When\n-           and then Token /= Tok_If\n-           and then Token /= Tok_Others\n-         then\n+         if Token not in Tok_When | Tok_If | Tok_Others then\n             exit when Check_End;\n          end if;\n \n@@ -4267,14 +4254,12 @@ package body Ch3 is\n          Saved_State : Saved_Scan_State;\n \n       begin\n-         if Token = Tok_Identifier or else Token = Tok_Operator_Symbol then\n+         if Token in Tok_Identifier | Tok_Operator_Symbol then\n             Save_Scan_State (Saved_State);\n             Scan; -- past possible junk subprogram name\n \n-            if Token = Tok_Left_Paren or else Token = Tok_Semicolon then\n+            if Token in Tok_Left_Paren | Tok_Semicolon then\n                Error_Msg_SP (\"unexpected subprogram name ignored\");\n-               return;\n-\n             else\n                Restore_Scan_State (Saved_State);\n             end if;\n@@ -4327,7 +4312,7 @@ package body Ch3 is\n       if Prot_Flag then\n          Scan; -- past PROTECTED\n \n-         if Token /= Tok_Procedure and then Token /= Tok_Function then\n+         if Token not in Tok_Procedure | Tok_Function then\n             Error_Msg_SC -- CODEFIX\n               (\"FUNCTION or PROCEDURE expected\");\n          end if;\n@@ -4402,7 +4387,7 @@ package body Ch3 is\n          Set_Null_Exclusion_Present (Type_Def_Node, Not_Null_Present);\n          Set_Null_Excluding_Subtype (Type_Def_Node, Not_Null_Subtype);\n \n-         if Token = Tok_All or else Token = Tok_Constant then\n+         if Token in Tok_All | Tok_Constant then\n             if Ada_Version = Ada_83 then\n                Error_Msg_SC (\"(Ada 83) access modifier not allowed!\");\n             end if;\n@@ -4472,10 +4457,7 @@ package body Ch3 is\n \n       --  Ada 2005 (AI-254): Access_To_Subprogram_Definition\n \n-      if Token = Tok_Protected\n-        or else Token = Tok_Procedure\n-        or else Token = Tok_Function\n-      then\n+      if Token in Tok_Protected | Tok_Procedure | Tok_Function then\n          Error_Msg_Ada_2005_Extension (\"access-to-subprogram\");\n \n          Subp_Node := P_Access_Type_Definition (Header_Already_Parsed => True);\n@@ -4629,7 +4611,6 @@ package body Ch3 is\n                   end if;\n \n                   Done := True;\n-                  return;\n                else\n                   Append (P_Representation_Clause, Decls);\n                end if;\n@@ -4873,10 +4854,9 @@ package body Ch3 is\n                --  If reserved identifier not followed by colon or comma, then\n                --  this is most likely an assignment statement to the bad id.\n \n-               if Token /= Tok_Colon and then Token /= Tok_Comma then\n+               if Token not in Tok_Colon | Tok_Comma then\n                   Restore_Scan_State (Scan_State);\n                   Statement_When_Declaration_Expected (Decls, Done, In_Spec);\n-                  return;\n \n                --  Otherwise we have a declaration of the bad id\n \n@@ -4892,7 +4872,6 @@ package body Ch3 is\n \n             else\n                Statement_When_Declaration_Expected (Decls, Done, In_Spec);\n-               return;\n             end if;\n \n          --  The token RETURN may well also signal a missing BEGIN situation,\n@@ -4941,7 +4920,7 @@ package body Ch3 is\n                Save_Scan_State (Scan_State);\n                Scan; -- past the token\n \n-               if Token /= Tok_Colon and then Token /= Tok_Comma then\n+               if Token not in Tok_Colon | Tok_Comma then\n                   Restore_Scan_State (Scan_State);\n                   Set_Declaration_Expected;\n                   raise Error_Resync;"}, {"sha": "0dc6c8ac1086b903033e8b7778ea12d0926cf8f0", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 407, "deletions": 417, "changes": 824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -225,9 +225,7 @@ package body Ch4 is\n \n          --  If it looks like start of expression, complain and scan expression\n \n-         if Token in Token_Class_Literal\n-           or else Token = Tok_Left_Paren\n-         then\n+         if Token in Token_Class_Literal | Tok_Left_Paren then\n             Error_Msg_SC (\"name expected\");\n             return P_Expression;\n \n@@ -303,7 +301,7 @@ package body Ch4 is\n          --  The treatment for the range attribute is similar (we do not\n          --  consider x'range to be a name in this grammar).\n \n-         elsif Token = Tok_Left_Paren or else Token = Tok_Range then\n+         elsif Token in Tok_Left_Paren | Tok_Range then\n             Restore_Scan_State (Scan_State); -- to apostrophe\n             Expr_Form := EF_Simple_Name;\n             return Name_Node;\n@@ -334,495 +332,498 @@ package body Ch4 is\n \n       <<Scan_Name_Extension>>\n \n-         --  Character literal used as name cannot be extended. Also this\n-         --  cannot be a call, since the name for a call must be a designator.\n-         --  Return in these cases, or if there is no name extension\n+      --  Character literal used as name cannot be extended. Also this\n+      --  cannot be a call, since the name for a call must be a designator.\n+      --  Return in these cases, or if there is no name extension\n \n-         if Token not in Token_Class_Namext\n-           or else Prev_Token = Tok_Char_Literal\n-         then\n-            Expr_Form := EF_Name;\n-            return Name_Node;\n-         end if;\n+      if Token not in Token_Class_Namext\n+        or else Prev_Token = Tok_Char_Literal\n+      then\n+         Expr_Form := EF_Name;\n+         return Name_Node;\n+      end if;\n \n       --  Merge here when we know there is a name extension\n \n       <<Scan_Name_Extension_OK>>\n \n-         if Token = Tok_Left_Paren then\n+      case Token is\n+         when Tok_Left_Paren =>\n             Scan; -- past left paren\n             goto Scan_Name_Extension_Left_Paren;\n \n-         elsif Token = Tok_Apostrophe then\n+         when Tok_Apostrophe =>\n             Save_Scan_State (Scan_State); -- at apostrophe\n             Scan; -- past apostrophe\n             goto Scan_Name_Extension_Apostrophe;\n \n-         else -- Token = Tok_Dot\n+         when Tok_Dot =>\n             Save_Scan_State (Scan_State); -- at dot\n             Scan; -- past dot\n             goto Scan_Name_Extension_Dot;\n-         end if;\n+\n+         when others => raise Program_Error;\n+      end case;\n \n       --  Case of name extended by dot (selection), dot is already skipped\n       --  and the scan state at the point of the dot is saved in Scan_State.\n \n       <<Scan_Name_Extension_Dot>>\n \n-         --  Explicit dereference case\n+      --  Explicit dereference case\n \n-         if Token = Tok_All then\n-            Prefix_Node := Name_Node;\n-            Name_Node := New_Node (N_Explicit_Dereference, Token_Ptr);\n-            Set_Prefix (Name_Node, Prefix_Node);\n-            Scan; -- past ALL\n-            goto Scan_Name_Extension;\n+      if Token = Tok_All then\n+         Prefix_Node := Name_Node;\n+         Name_Node := New_Node (N_Explicit_Dereference, Token_Ptr);\n+         Set_Prefix (Name_Node, Prefix_Node);\n+         Scan; -- past ALL\n+         goto Scan_Name_Extension;\n \n          --  Selected component case\n \n-         elsif Token in Token_Class_Name then\n-            Prefix_Node := Name_Node;\n-            Name_Node := New_Node (N_Selected_Component, Prev_Token_Ptr);\n-            Set_Prefix (Name_Node, Prefix_Node);\n-            Set_Selector_Name (Name_Node, Token_Node);\n-            Scan; -- past selector\n-            goto Scan_Name_Extension;\n+      elsif Token in Token_Class_Name then\n+         Prefix_Node := Name_Node;\n+         Name_Node := New_Node (N_Selected_Component, Prev_Token_Ptr);\n+         Set_Prefix (Name_Node, Prefix_Node);\n+         Set_Selector_Name (Name_Node, Token_Node);\n+         Scan; -- past selector\n+         goto Scan_Name_Extension;\n \n          --  Reserved identifier as selector\n \n-         elsif Is_Reserved_Identifier then\n-            Scan_Reserved_Identifier (Force_Msg => False);\n-            Prefix_Node := Name_Node;\n-            Name_Node := New_Node (N_Selected_Component, Prev_Token_Ptr);\n-            Set_Prefix (Name_Node, Prefix_Node);\n-            Set_Selector_Name (Name_Node, Token_Node);\n-            Scan; -- past identifier used as selector\n-            goto Scan_Name_Extension;\n+      elsif Is_Reserved_Identifier then\n+         Scan_Reserved_Identifier (Force_Msg => False);\n+         Prefix_Node := Name_Node;\n+         Name_Node := New_Node (N_Selected_Component, Prev_Token_Ptr);\n+         Set_Prefix (Name_Node, Prefix_Node);\n+         Set_Selector_Name (Name_Node, Token_Node);\n+         Scan; -- past identifier used as selector\n+         goto Scan_Name_Extension;\n \n          --  If dot is at end of line and followed by nothing legal,\n          --  then assume end of name and quit (dot will be taken as\n          --  an incorrect form of some other punctuation by our caller).\n \n-         elsif Token_Is_At_Start_Of_Line then\n-            Restore_Scan_State (Scan_State);\n-            return Name_Node;\n+      elsif Token_Is_At_Start_Of_Line then\n+         Restore_Scan_State (Scan_State);\n+         return Name_Node;\n \n          --  Here if nothing legal after the dot\n \n-         else\n-            Error_Msg_AP (\"selector expected\");\n-            raise Error_Resync;\n-         end if;\n+      else\n+         Error_Msg_AP (\"selector expected\");\n+         raise Error_Resync;\n+      end if;\n \n       --  Here for an apostrophe as name extension. The scan position at the\n       --  apostrophe has already been saved, and the apostrophe scanned out.\n \n       <<Scan_Name_Extension_Apostrophe>>\n \n-         Scan_Apostrophe : declare\n-            function Apostrophe_Should_Be_Semicolon return Boolean;\n-            --  Checks for case where apostrophe should probably be\n-            --  a semicolon, and if so, gives appropriate message,\n-            --  resets the scan pointer to the apostrophe, changes\n-            --  the current token to Tok_Semicolon, and returns True.\n-            --  Otherwise returns False.\n-\n-            ------------------------------------\n-            -- Apostrophe_Should_Be_Semicolon --\n-            ------------------------------------\n-\n-            function Apostrophe_Should_Be_Semicolon return Boolean is\n-            begin\n-               if Token_Is_At_Start_Of_Line then\n-                  Restore_Scan_State (Scan_State); -- to apostrophe\n-                  Error_Msg_SC (\"|\"\"''\"\" should be \"\";\"\"\");\n-                  Token := Tok_Semicolon;\n-                  return True;\n-               else\n-                  return False;\n-               end if;\n-            end Apostrophe_Should_Be_Semicolon;\n+      Scan_Apostrophe : declare\n+         function Apostrophe_Should_Be_Semicolon return Boolean;\n+         --  Checks for case where apostrophe should probably be\n+         --  a semicolon, and if so, gives appropriate message,\n+         --  resets the scan pointer to the apostrophe, changes\n+         --  the current token to Tok_Semicolon, and returns True.\n+         --  Otherwise returns False.\n \n-         --  Start of processing for Scan_Apostrophe\n+         ------------------------------------\n+         -- Apostrophe_Should_Be_Semicolon --\n+         ------------------------------------\n \n+         function Apostrophe_Should_Be_Semicolon return Boolean is\n          begin\n-            --  Check for qualified expression case in Ada 2012 mode\n+            if Token_Is_At_Start_Of_Line then\n+               Restore_Scan_State (Scan_State); -- to apostrophe\n+               Error_Msg_SC (\"|\"\"''\"\" should be \"\";\"\"\");\n+               Token := Tok_Semicolon;\n+               return True;\n+            else\n+               return False;\n+            end if;\n+         end Apostrophe_Should_Be_Semicolon;\n \n-            if Ada_Version >= Ada_2012\n-              and then Token in Tok_Left_Paren | Tok_Left_Bracket\n-            then\n-               Name_Node := P_Qualified_Expression (Name_Node);\n-               goto Scan_Name_Extension;\n+      --  Start of processing for Scan_Apostrophe\n \n-            --  If range attribute after apostrophe, then return with Token\n-            --  pointing to the apostrophe. Note that in this case the prefix\n-            --  need not be a simple name (cases like A.all'range). Similarly\n-            --  if there is a left paren after the apostrophe, then we also\n-            --  return with Token pointing to the apostrophe (this is the\n-            --  aggregate case, or some error case).\n+      begin\n+         --  Check for qualified expression case in Ada 2012 mode\n \n-            elsif Token = Tok_Range or else Token = Tok_Left_Paren then\n-               Restore_Scan_State (Scan_State); -- to apostrophe\n-               Expr_Form := EF_Name;\n-               return Name_Node;\n+         if Ada_Version >= Ada_2012\n+           and then Token in Tok_Left_Paren | Tok_Left_Bracket\n+         then\n+            Name_Node := P_Qualified_Expression (Name_Node);\n+            goto Scan_Name_Extension;\n \n-            --  Here for cases where attribute designator is an identifier\n+         --  If range attribute after apostrophe, then return with Token\n+         --  pointing to the apostrophe. Note that in this case the prefix\n+         --  need not be a simple name (cases like A.all'range). Similarly\n+         --  if there is a left paren after the apostrophe, then we also\n+         --  return with Token pointing to the apostrophe (this is the\n+         --  aggregate case, or some error case).\n \n-            elsif Token = Tok_Identifier then\n-               Attr_Name := Token_Name;\n+         elsif Token in Tok_Range | Tok_Left_Paren then\n+            Restore_Scan_State (Scan_State); -- to apostrophe\n+            Expr_Form := EF_Name;\n+            return Name_Node;\n \n-               if not Is_Attribute_Name (Attr_Name) then\n-                  if Apostrophe_Should_Be_Semicolon then\n-                     Expr_Form := EF_Name;\n-                     return Name_Node;\n+         --  Here for cases where attribute designator is an identifier\n \n-                  --  Here for a bad attribute name\n+         elsif Token = Tok_Identifier then\n+            Attr_Name := Token_Name;\n \n-                  else\n-                     Signal_Bad_Attribute;\n-                     Scan; -- past bad identifier\n+            if not Is_Attribute_Name (Attr_Name) then\n+               if Apostrophe_Should_Be_Semicolon then\n+                  Expr_Form := EF_Name;\n+                  return Name_Node;\n \n-                     if Token = Tok_Left_Paren then\n-                        Scan; -- past left paren\n+               --  Here for a bad attribute name\n \n-                        loop\n-                           Discard_Junk_Node (P_Expression_If_OK);\n-                           exit when not Comma_Present;\n-                        end loop;\n+               else\n+                  Signal_Bad_Attribute;\n+                  Scan; -- past bad identifier\n \n-                        T_Right_Paren;\n-                     end if;\n+                  if Token = Tok_Left_Paren then\n+                     Scan; -- past left paren\n \n-                     return Error;\n+                     loop\n+                        Discard_Junk_Node (P_Expression_If_OK);\n+                        exit when not Comma_Present;\n+                     end loop;\n+\n+                     T_Right_Paren;\n                   end if;\n-               end if;\n \n-               if Style_Check then\n-                  Style.Check_Attribute_Name (False);\n+                  return Error;\n                end if;\n+            end if;\n \n-            --  Here for case of attribute designator is not an identifier\n+            if Style_Check then\n+               Style.Check_Attribute_Name (False);\n+            end if;\n \n-            else\n-               if Token = Tok_Delta then\n-                  Attr_Name := Name_Delta;\n+         --  Here for case of attribute designator is not an identifier\n \n-               elsif Token = Tok_Digits then\n-                  Attr_Name := Name_Digits;\n+         else\n+            if Token = Tok_Delta then\n+               Attr_Name := Name_Delta;\n \n-               elsif Token = Tok_Access then\n-                  Attr_Name := Name_Access;\n+            elsif Token = Tok_Digits then\n+               Attr_Name := Name_Digits;\n \n-               elsif Token = Tok_Mod and then Ada_Version >= Ada_95 then\n-                  Attr_Name := Name_Mod;\n+            elsif Token = Tok_Access then\n+               Attr_Name := Name_Access;\n \n-               elsif Apostrophe_Should_Be_Semicolon then\n-                  Expr_Form := EF_Name;\n-                  return Name_Node;\n+            elsif Token = Tok_Mod and then Ada_Version >= Ada_95 then\n+               Attr_Name := Name_Mod;\n \n-               else\n-                  Error_Msg_AP (\"attribute designator expected\");\n-                  raise Error_Resync;\n-               end if;\n+            elsif Apostrophe_Should_Be_Semicolon then\n+               Expr_Form := EF_Name;\n+               return Name_Node;\n \n-               if Style_Check then\n-                  Style.Check_Attribute_Name (True);\n-               end if;\n+            else\n+               Error_Msg_AP (\"attribute designator expected\");\n+               raise Error_Resync;\n             end if;\n \n-            --  We come here with an OK attribute scanned, and corresponding\n-            --  Attribute identifier node stored in Ident_Node.\n+            if Style_Check then\n+               Style.Check_Attribute_Name (True);\n+            end if;\n+         end if;\n \n-            Prefix_Node := Name_Node;\n-            Name_Node := New_Node (N_Attribute_Reference, Prev_Token_Ptr);\n-            Scan; -- past attribute designator\n-            Set_Prefix (Name_Node, Prefix_Node);\n-            Set_Attribute_Name (Name_Node, Attr_Name);\n+         --  We come here with an OK attribute scanned, and corresponding\n+         --  Attribute identifier node stored in Ident_Node.\n \n-            --  Scan attribute arguments/designator. We skip this if we know\n-            --  that the attribute cannot have an argument (see documentation\n-            --  of Is_Parameterless_Attribute for further details).\n+         Prefix_Node := Name_Node;\n+         Name_Node := New_Node (N_Attribute_Reference, Prev_Token_Ptr);\n+         Scan; -- past attribute designator\n+         Set_Prefix (Name_Node, Prefix_Node);\n+         Set_Attribute_Name (Name_Node, Attr_Name);\n \n-            if Token = Tok_Left_Paren\n-              and then not\n-                Is_Parameterless_Attribute (Get_Attribute_Id (Attr_Name))\n-            then\n-               --  Attribute Update contains an array or record association\n-               --  list which provides new values for various components or\n-               --  elements. The list is parsed as an aggregate, and we get\n-               --  better error handling by knowing that in the parser.\n+         --  Scan attribute arguments/designator. We skip this if we know\n+         --  that the attribute cannot have an argument (see documentation\n+         --  of Is_Parameterless_Attribute for further details).\n \n-               if Attr_Name = Name_Update then\n-                  Set_Expressions (Name_Node, New_List);\n-                  Append (P_Aggregate, Expressions (Name_Node));\n+         if Token = Tok_Left_Paren\n+           and then not\n+             Is_Parameterless_Attribute (Get_Attribute_Id (Attr_Name))\n+         then\n+            --  Attribute Update contains an array or record association\n+            --  list which provides new values for various components or\n+            --  elements. The list is parsed as an aggregate, and we get\n+            --  better error handling by knowing that in the parser.\n \n-               --  All other cases of parsing attribute arguments\n+            if Attr_Name = Name_Update then\n+               Set_Expressions (Name_Node, New_List);\n+               Append (P_Aggregate, Expressions (Name_Node));\n \n-               else\n-                  Set_Expressions (Name_Node, New_List);\n-                  Scan; -- past left paren\n-\n-                  loop\n-                     declare\n-                        Expr : constant Node_Id := P_Expression_If_OK;\n-                        Rnam : Node_Id;\n-\n-                     begin\n-                        --  Case of => for named notation\n-\n-                        if Token = Tok_Arrow then\n-\n-                           --  Named notation allowed only for the special\n-                           --  case of System'Restriction_Set (No_Dependence =>\n-                           --  unit_NAME), in which case construct a parameter\n-                           --  assocation node and append to the arguments.\n-\n-                           if Attr_Name = Name_Restriction_Set\n-                             and then Nkind (Expr) = N_Identifier\n-                             and then Chars (Expr) = Name_No_Dependence\n-                           then\n-                              Scan; -- past arrow\n-                              Rnam := P_Name;\n-                              Append_To (Expressions (Name_Node),\n-                                Make_Parameter_Association (Sloc (Rnam),\n-                                  Selector_Name             => Expr,\n-                                  Explicit_Actual_Parameter => Rnam));\n-                              exit;\n-\n-                           --  For all other cases named notation is illegal\n-\n-                           else\n-                              Error_Msg_SC\n-                                (\"named parameters not permitted \"\n-                                 & \"for attributes\");\n-                              Scan; -- past junk arrow\n-                           end if;\n-\n-                        --  Here for normal case (not => for named parameter)\n+            --  All other cases of parsing attribute arguments\n+\n+            else\n+               Set_Expressions (Name_Node, New_List);\n+               Scan; -- past left paren\n+\n+               loop\n+                  declare\n+                     Expr : constant Node_Id := P_Expression_If_OK;\n+                     Rnam : Node_Id;\n+\n+                  begin\n+                     --  Case of => for named notation\n+\n+                     if Token = Tok_Arrow then\n+\n+                        --  Named notation allowed only for the special\n+                        --  case of System'Restriction_Set (No_Dependence =>\n+                        --  unit_NAME), in which case construct a parameter\n+                        --  assocation node and append to the arguments.\n+\n+                        if Attr_Name = Name_Restriction_Set\n+                          and then Nkind (Expr) = N_Identifier\n+                          and then Chars (Expr) = Name_No_Dependence\n+                        then\n+                           Scan; -- past arrow\n+                           Rnam := P_Name;\n+                           Append_To (Expressions (Name_Node),\n+                             Make_Parameter_Association (Sloc (Rnam),\n+                               Selector_Name             => Expr,\n+                               Explicit_Actual_Parameter => Rnam));\n+                           exit;\n+\n+                        --  For all other cases named notation is illegal\n \n                         else\n-                           --  Special handling for 'Image in Ada 2012, where\n-                           --  the attribute can be parameterless and its value\n-                           --  can be the prefix of a slice. Rewrite name as a\n-                           --  slice, Expr is its low bound.\n-\n-                           if Token = Tok_Dot_Dot\n-                             and then Attr_Name = Name_Image\n-                             and then Ada_Version >= Ada_2012\n-                           then\n-                              Set_Expressions (Name_Node, No_List);\n-                              Prefix_Node := Name_Node;\n-                              Name_Node :=\n-                                New_Node (N_Slice, Sloc (Prefix_Node));\n-                              Set_Prefix (Name_Node, Prefix_Node);\n-                              Range_Node := New_Node (N_Range, Token_Ptr);\n-                              Set_Low_Bound (Range_Node, Expr);\n-                              Scan; -- past ..\n-                              Expr_Node := P_Expression;\n-                              Check_Simple_Expression (Expr_Node);\n-                              Set_High_Bound (Range_Node, Expr_Node);\n-                              Set_Discrete_Range (Name_Node, Range_Node);\n-                              T_Right_Paren;\n-\n-                              goto Scan_Name_Extension;\n-\n-                           else\n-                              Append (Expr, Expressions (Name_Node));\n-                              exit when not Comma_Present;\n-                           end if;\n+                           Error_Msg_SC\n+                             (\"named parameters not permitted \"\n+                              & \"for attributes\");\n+                           Scan; -- past junk arrow\n                         end if;\n-                     end;\n-                  end loop;\n \n-                  T_Right_Paren;\n-               end if;\n+                     --  Here for normal case (not => for named parameter)\n+\n+                     else\n+                        --  Special handling for 'Image in Ada 2012, where\n+                        --  the attribute can be parameterless and its value\n+                        --  can be the prefix of a slice. Rewrite name as a\n+                        --  slice, Expr is its low bound.\n+\n+                        if Token = Tok_Dot_Dot\n+                          and then Attr_Name = Name_Image\n+                          and then Ada_Version >= Ada_2012\n+                        then\n+                           Set_Expressions (Name_Node, No_List);\n+                           Prefix_Node := Name_Node;\n+                           Name_Node :=\n+                             New_Node (N_Slice, Sloc (Prefix_Node));\n+                           Set_Prefix (Name_Node, Prefix_Node);\n+                           Range_Node := New_Node (N_Range, Token_Ptr);\n+                           Set_Low_Bound (Range_Node, Expr);\n+                           Scan; -- past ..\n+                           Expr_Node := P_Expression;\n+                           Check_Simple_Expression (Expr_Node);\n+                           Set_High_Bound (Range_Node, Expr_Node);\n+                           Set_Discrete_Range (Name_Node, Range_Node);\n+                           T_Right_Paren;\n+\n+                           goto Scan_Name_Extension;\n+\n+                        else\n+                           Append (Expr, Expressions (Name_Node));\n+                           exit when not Comma_Present;\n+                        end if;\n+                     end if;\n+                  end;\n+               end loop;\n+\n+               T_Right_Paren;\n             end if;\n+         end if;\n \n-            goto Scan_Name_Extension;\n-         end Scan_Apostrophe;\n+         goto Scan_Name_Extension;\n+      end Scan_Apostrophe;\n \n       --  Here for left parenthesis extending name (left paren skipped)\n \n       <<Scan_Name_Extension_Left_Paren>>\n \n-         --  We now have to scan through a list of items, terminated by a\n-         --  right parenthesis. The scan is handled by a finite state\n-         --  machine. The possibilities are:\n+      --  We now have to scan through a list of items, terminated by a\n+      --  right parenthesis. The scan is handled by a finite state\n+      --  machine. The possibilities are:\n \n-         --   (discrete_range)\n+      --   (discrete_range)\n \n-         --      This is a slice. This case is handled in LP_State_Init\n+      --      This is a slice. This case is handled in LP_State_Init\n \n-         --   (expression, expression, ..)\n+      --   (expression, expression, ..)\n \n-         --      This is interpreted as an indexed component, i.e. as a\n-         --      case of a name which can be extended in the normal manner.\n-         --      This case is handled by LP_State_Name or LP_State_Expr.\n+      --      This is interpreted as an indexed component, i.e. as a\n+      --      case of a name which can be extended in the normal manner.\n+      --      This case is handled by LP_State_Name or LP_State_Expr.\n \n-         --      Note: if and case expressions (without an extra level of\n-         --      parentheses) are permitted in this context).\n+      --      Note: if and case expressions (without an extra level of\n+      --      parentheses) are permitted in this context).\n \n-         --   (..., identifier => expression , ...)\n+      --   (..., identifier => expression , ...)\n \n-         --      If there is at least one occurrence of identifier => (but\n-         --      none of the other cases apply), then we have a call.\n+      --      If there is at least one occurrence of identifier => (but\n+      --      none of the other cases apply), then we have a call.\n \n-         --  Test for Id => case\n+      --  Test for Id => case\n \n-         if Token = Tok_Identifier then\n-            Save_Scan_State (Scan_State); -- at Id\n-            Scan; -- past Id\n+      if Token = Tok_Identifier then\n+         Save_Scan_State (Scan_State); -- at Id\n+         Scan; -- past Id\n \n-            --  Test for => (allow := as an error substitute)\n+         --  Test for => (allow := as an error substitute)\n \n-            if Token = Tok_Arrow or else Token = Tok_Colon_Equal then\n-               Restore_Scan_State (Scan_State); -- to Id\n-               Arg_List := New_List;\n-               goto LP_State_Call;\n+         if Token in Tok_Arrow | Tok_Colon_Equal then\n+            Restore_Scan_State (Scan_State); -- to Id\n+            Arg_List := New_List;\n+            goto LP_State_Call;\n \n-            else\n-               Restore_Scan_State (Scan_State); -- to Id\n-            end if;\n+         else\n+            Restore_Scan_State (Scan_State); -- to Id\n          end if;\n+      end if;\n \n-         --  Here we have an expression after all\n-\n-         Expr_Node := P_Expression_Or_Range_Attribute_If_OK;\n+      --  Here we have an expression after all\n \n-         --  Check cases of discrete range for a slice\n+      Expr_Node := P_Expression_Or_Range_Attribute_If_OK;\n \n-         --  First possibility: Range_Attribute_Reference\n+      --  Check cases of discrete range for a slice\n \n-         if Expr_Form = EF_Range_Attr then\n-            Range_Node := Expr_Node;\n+      --  First possibility: Range_Attribute_Reference\n \n-         --  Second possibility: Simple_expression .. Simple_expression\n+      if Expr_Form = EF_Range_Attr then\n+         Range_Node := Expr_Node;\n \n-         elsif Token = Tok_Dot_Dot then\n-            Check_Simple_Expression (Expr_Node);\n-            Range_Node := New_Node (N_Range, Token_Ptr);\n-            Set_Low_Bound (Range_Node, Expr_Node);\n-            Scan; -- past ..\n-            Expr_Node := P_Expression;\n-            Check_Simple_Expression (Expr_Node);\n-            Set_High_Bound (Range_Node, Expr_Node);\n+      --  Second possibility: Simple_expression .. Simple_expression\n \n-         --  Third possibility: Type_name range Range\n+      elsif Token = Tok_Dot_Dot then\n+         Check_Simple_Expression (Expr_Node);\n+         Range_Node := New_Node (N_Range, Token_Ptr);\n+         Set_Low_Bound (Range_Node, Expr_Node);\n+         Scan; -- past ..\n+         Expr_Node := P_Expression;\n+         Check_Simple_Expression (Expr_Node);\n+         Set_High_Bound (Range_Node, Expr_Node);\n \n-         elsif Token = Tok_Range then\n-            if Expr_Form /= EF_Simple_Name then\n-               Error_Msg_SC (\"subtype mark must precede RANGE\");\n-               raise Error_Resync;\n-            end if;\n+      --  Third possibility: Type_name range Range\n \n-            Range_Node := P_Subtype_Indication (Expr_Node);\n+      elsif Token = Tok_Range then\n+         if Expr_Form /= EF_Simple_Name then\n+            Error_Msg_SC (\"subtype mark must precede RANGE\");\n+            raise Error_Resync;\n+         end if;\n \n-         --  Otherwise we just have an expression. It is true that we might\n-         --  have a subtype mark without a range constraint but this case\n-         --  is syntactically indistinguishable from the expression case.\n+         Range_Node := P_Subtype_Indication (Expr_Node);\n \n-         else\n-            Arg_List := New_List;\n-            goto LP_State_Expr;\n-         end if;\n+      --  Otherwise we just have an expression. It is true that we might\n+      --  have a subtype mark without a range constraint but this case\n+      --  is syntactically indistinguishable from the expression case.\n \n-         --  Fall through here with unmistakable Discrete range scanned,\n-         --  which means that we definitely have the case of a slice. The\n-         --  Discrete range is in Range_Node.\n+      else\n+         Arg_List := New_List;\n+         goto LP_State_Expr;\n+      end if;\n \n-         if Token = Tok_Comma then\n-            Error_Msg_SC (\"slice cannot have more than one dimension\");\n-            raise Error_Resync;\n+      --  Fall through here with unmistakable Discrete range scanned,\n+      --  which means that we definitely have the case of a slice. The\n+      --  Discrete range is in Range_Node.\n \n-         elsif Token /= Tok_Right_Paren then\n-            if Token = Tok_Arrow then\n+      if Token = Tok_Comma then\n+         Error_Msg_SC (\"slice cannot have more than one dimension\");\n+         raise Error_Resync;\n \n-               --  This may be an aggregate that is missing a qualification\n+      elsif Token /= Tok_Right_Paren then\n+         if Token = Tok_Arrow then\n \n-               Error_Msg_SC\n-                 (\"context of aggregate must be a qualified expression\");\n-               raise Error_Resync;\n+            --  This may be an aggregate that is missing a qualification\n \n-            else\n-               T_Right_Paren;\n-               raise Error_Resync;\n-            end if;\n+            Error_Msg_SC\n+              (\"context of aggregate must be a qualified expression\");\n+            raise Error_Resync;\n \n          else\n-            Scan; -- past right paren\n-            Prefix_Node := Name_Node;\n-            Name_Node := New_Node (N_Slice, Sloc (Prefix_Node));\n-            Set_Prefix (Name_Node, Prefix_Node);\n-            Set_Discrete_Range (Name_Node, Range_Node);\n+            T_Right_Paren;\n+            raise Error_Resync;\n+         end if;\n+\n+      else\n+         Scan; -- past right paren\n+         Prefix_Node := Name_Node;\n+         Name_Node := New_Node (N_Slice, Sloc (Prefix_Node));\n+         Set_Prefix (Name_Node, Prefix_Node);\n+         Set_Discrete_Range (Name_Node, Range_Node);\n \n-            --  An operator node is legal as a prefix to other names,\n-            --  but not for a slice.\n+         --  An operator node is legal as a prefix to other names,\n+         --  but not for a slice.\n \n-            if Nkind (Prefix_Node) = N_Operator_Symbol then\n-               Error_Msg_N (\"illegal prefix for slice\", Prefix_Node);\n-            end if;\n+         if Nkind (Prefix_Node) = N_Operator_Symbol then\n+            Error_Msg_N (\"illegal prefix for slice\", Prefix_Node);\n+         end if;\n \n-            --  If we have a name extension, go scan it\n+         --  If we have a name extension, go scan it\n \n-            if Token in Token_Class_Namext then\n-               goto Scan_Name_Extension_OK;\n+         if Token in Token_Class_Namext then\n+            goto Scan_Name_Extension_OK;\n \n-            --  Otherwise return (a slice is a name, but is not a call)\n+         --  Otherwise return (a slice is a name, but is not a call)\n \n-            else\n-               Expr_Form := EF_Name;\n-               return Name_Node;\n-            end if;\n+         else\n+            Expr_Form := EF_Name;\n+            return Name_Node;\n          end if;\n+      end if;\n \n       --  In LP_State_Expr, we have scanned one or more expressions, and\n       --  so we have a call or an indexed component which is a name. On\n       --  entry we have the expression just scanned in Expr_Node and\n       --  Arg_List contains the list of expressions encountered so far\n \n       <<LP_State_Expr>>\n-         Append (Expr_Node, Arg_List);\n+      Append (Expr_Node, Arg_List);\n \n-         if Token = Tok_Arrow then\n-            Error_Msg\n-              (\"expect identifier in parameter association\", Sloc (Expr_Node));\n-            Scan;  -- past arrow\n+      if Token = Tok_Arrow then\n+         Error_Msg\n+           (\"expect identifier in parameter association\", Sloc (Expr_Node));\n+         Scan;  -- past arrow\n \n-         elsif not Comma_Present then\n-            T_Right_Paren;\n+      elsif not Comma_Present then\n+         T_Right_Paren;\n \n-            Prefix_Node := Name_Node;\n-            Name_Node := New_Node (N_Indexed_Component, Sloc (Prefix_Node));\n-            Set_Prefix (Name_Node, Prefix_Node);\n-            Set_Expressions (Name_Node, Arg_List);\n+         Prefix_Node := Name_Node;\n+         Name_Node := New_Node (N_Indexed_Component, Sloc (Prefix_Node));\n+         Set_Prefix (Name_Node, Prefix_Node);\n+         Set_Expressions (Name_Node, Arg_List);\n \n-            goto Scan_Name_Extension;\n-         end if;\n+         goto Scan_Name_Extension;\n+      end if;\n \n-         --  Comma present (and scanned out), test for identifier => case\n-         --  Test for identifier => case\n+      --  Comma present (and scanned out), test for identifier => case\n+      --  Test for identifier => case\n \n-         if Token = Tok_Identifier then\n-            Save_Scan_State (Scan_State); -- at Id\n-            Scan; -- past Id\n+      if Token = Tok_Identifier then\n+         Save_Scan_State (Scan_State); -- at Id\n+         Scan; -- past Id\n \n-            --  Test for => (allow := as error substitute)\n+         --  Test for => (allow := as error substitute)\n \n-            if Token = Tok_Arrow or else Token = Tok_Colon_Equal then\n-               Restore_Scan_State (Scan_State); -- to Id\n-               goto LP_State_Call;\n+         if Token in Tok_Arrow | Tok_Colon_Equal then\n+            Restore_Scan_State (Scan_State); -- to Id\n+            goto LP_State_Call;\n \n-            --  Otherwise it's just an expression after all, so backup\n+         --  Otherwise it's just an expression after all, so backup\n \n-            else\n-               Restore_Scan_State (Scan_State); -- to Id\n-            end if;\n+         else\n+            Restore_Scan_State (Scan_State); -- to Id\n          end if;\n+      end if;\n \n-         --  Here we have an expression after all, so stay in this state\n+      --  Here we have an expression after all, so stay in this state\n \n-         Expr_Node := P_Expression_If_OK;\n-         goto LP_State_Expr;\n+      Expr_Node := P_Expression_If_OK;\n+      goto LP_State_Expr;\n \n       --  LP_State_Call corresponds to the situation in which at least one\n       --  instance of Id => Expression has been encountered, so we know that\n@@ -832,78 +833,78 @@ package body Ch4 is\n \n       <<LP_State_Call>>\n \n-         --  Test for case of Id => Expression (named parameter)\n+      --  Test for case of Id => Expression (named parameter)\n \n-         if Token = Tok_Identifier then\n-            Save_Scan_State (Scan_State); -- at Id\n-            Ident_Node := Token_Node;\n-            Scan; -- past Id\n+      if Token = Tok_Identifier then\n+         Save_Scan_State (Scan_State); -- at Id\n+         Ident_Node := Token_Node;\n+         Scan; -- past Id\n \n-            --  Deal with => (allow := as incorrect substitute)\n+         --  Deal with => (allow := as incorrect substitute)\n \n-            if Token = Tok_Arrow or else Token = Tok_Colon_Equal then\n-               Arg_Node := New_Node (N_Parameter_Association, Prev_Token_Ptr);\n-               Set_Selector_Name (Arg_Node, Ident_Node);\n-               T_Arrow;\n-               Set_Explicit_Actual_Parameter (Arg_Node, P_Expression);\n-               Append (Arg_Node, Arg_List);\n+         if Token in Tok_Arrow | Tok_Colon_Equal then\n+            Arg_Node := New_Node (N_Parameter_Association, Prev_Token_Ptr);\n+            Set_Selector_Name (Arg_Node, Ident_Node);\n+            T_Arrow;\n+            Set_Explicit_Actual_Parameter (Arg_Node, P_Expression);\n+            Append (Arg_Node, Arg_List);\n \n-               --  If a comma follows, go back and scan next entry\n+            --  If a comma follows, go back and scan next entry\n \n-               if Comma_Present then\n-                  goto LP_State_Call;\n+            if Comma_Present then\n+               goto LP_State_Call;\n \n-               --  Otherwise we have the end of a call\n+            --  Otherwise we have the end of a call\n \n-               else\n-                  Prefix_Node := Name_Node;\n-                  Name_Node := New_Node (N_Function_Call, Sloc (Prefix_Node));\n-                  Set_Name (Name_Node, Prefix_Node);\n-                  Set_Parameter_Associations (Name_Node, Arg_List);\n-                  T_Right_Paren;\n+            else\n+               Prefix_Node := Name_Node;\n+               Name_Node := New_Node (N_Function_Call, Sloc (Prefix_Node));\n+               Set_Name (Name_Node, Prefix_Node);\n+               Set_Parameter_Associations (Name_Node, Arg_List);\n+               T_Right_Paren;\n \n-                  if Token in Token_Class_Namext then\n-                     goto Scan_Name_Extension_OK;\n+               if Token in Token_Class_Namext then\n+                  goto Scan_Name_Extension_OK;\n \n-                  --  This is a case of a call which cannot be a name\n+               --  This is a case of a call which cannot be a name\n \n-                  else\n-                     Expr_Form := EF_Name;\n-                     return Name_Node;\n-                  end if;\n+               else\n+                  Expr_Form := EF_Name;\n+                  return Name_Node;\n                end if;\n+            end if;\n \n-            --  Not named parameter: Id started an expression after all\n+         --  Not named parameter: Id started an expression after all\n \n-            else\n-               Restore_Scan_State (Scan_State); -- to Id\n-            end if;\n+         else\n+            Restore_Scan_State (Scan_State); -- to Id\n          end if;\n+      end if;\n \n-         --  Here if entry did not start with Id => which means that it\n-         --  is a positional parameter, which is not allowed, since we\n-         --  have seen at least one named parameter already.\n+      --  Here if entry did not start with Id => which means that it\n+      --  is a positional parameter, which is not allowed, since we\n+      --  have seen at least one named parameter already.\n \n-         Error_Msg_SC\n-            (\"positional parameter association \" &\n-              \"not allowed after named one\");\n+      Error_Msg_SC\n+         (\"positional parameter association \" &\n+           \"not allowed after named one\");\n \n-         Expr_Node := P_Expression_If_OK;\n+      Expr_Node := P_Expression_If_OK;\n \n-         --  Leaving the '>' in an association is not unusual, so suggest\n-         --  a possible fix.\n+      --  Leaving the '>' in an association is not unusual, so suggest\n+      --  a possible fix.\n \n-         if Nkind (Expr_Node) = N_Op_Eq then\n-            Error_Msg_N (\"\\maybe `='>` was intended\", Expr_Node);\n-         end if;\n+      if Nkind (Expr_Node) = N_Op_Eq then\n+         Error_Msg_N (\"\\maybe `='>` was intended\", Expr_Node);\n+      end if;\n \n-         --  We go back to scanning out expressions, so that we do not get\n-         --  multiple error messages when several positional parameters\n-         --  follow a named parameter.\n+      --  We go back to scanning out expressions, so that we do not get\n+      --  multiple error messages when several positional parameters\n+      --  follow a named parameter.\n \n-         goto LP_State_Expr;\n+      goto LP_State_Expr;\n \n-         --  End of treatment for name extensions starting with left paren\n+      --  End of treatment for name extensions starting with left paren\n \n       --  End of loop through name extensions\n \n@@ -1384,7 +1385,7 @@ package body Ch4 is\n       begin\n          Save_Scan_State (Scan_State);\n          Scan;   --  past FOR\n-         Maybe := Token = Tok_All or else Token = Tok_Some;\n+         Maybe := Token in Tok_All | Tok_Some;\n          Restore_Scan_State (Scan_State);  --  to FOR\n          return Maybe;\n       end Is_Quantified_Expression;\n@@ -1609,11 +1610,8 @@ package body Ch4 is\n          then\n             Append_New (Expr_Node, Assoc_List);\n \n-         elsif Token = Tok_Comma\n-           or else Token = Tok_Right_Paren\n-           or else Token = Tok_Others\n-           or else Token in Token_Class_Lit_Or_Name\n-           or else Token = Tok_Semicolon\n+         elsif Token in Tok_Comma | Tok_Right_Paren | Tok_Others\n+           | Token_Class_Lit_Or_Name | Tok_Semicolon\n          then\n             if Present (Assoc_List) then\n                Error_Msg_BC -- CODEFIX\n@@ -1945,7 +1943,7 @@ package body Ch4 is\n \n             --  Check for case of errant comma or semicolon\n \n-            if Token = Tok_Comma or else Token = Tok_Semicolon then\n+            if Token in Tok_Comma | Tok_Semicolon then\n                declare\n                   Com        : constant Boolean := Token = Tok_Comma;\n                   Scan_State : Saved_Scan_State;\n@@ -1959,7 +1957,7 @@ package body Ch4 is\n                   --  do not deal with AND/OR because those cases get mixed up\n                   --  with the select alternatives case.\n \n-                  if Token = Tok_And or else Token = Tok_Or then\n+                  if Token in Tok_And | Tok_Or then\n                      Logop := P_Logical_Operator;\n                      Restore_Scan_State (Scan_State); -- to comma/semicolon\n \n@@ -2008,11 +2006,7 @@ package body Ch4 is\n    begin\n       --  Case of conditional, case or quantified expression\n \n-      if Token = Tok_Case\n-        or else Token = Tok_If\n-        or else Token = Tok_For\n-        or else Token = Tok_Declare\n-      then\n+      if Token in Tok_Case | Tok_If | Tok_For | Tok_Declare then\n          return P_Unparen_Cond_Expr_Etc;\n \n       --  Normal case, not case/conditional/quantified expression\n@@ -2121,11 +2115,7 @@ package body Ch4 is\n    begin\n       --  Case of conditional, case or quantified expression\n \n-      if Token = Tok_Case\n-        or else Token = Tok_If\n-        or else Token = Tok_For\n-        or else Token = Tok_Declare\n-      then\n+      if Token in Tok_Case | Tok_If | Tok_For | Tok_Declare then\n          return P_Unparen_Cond_Expr_Etc;\n \n       --  Normal case, not one of the above expression types\n@@ -2967,7 +2957,7 @@ package body Ch4 is\n                   Save_Scan_State (Scan_State);\n                   Scan;   --  past FOR\n \n-                  if Token = Tok_All or else Token = Tok_Some then\n+                  if Token in Tok_All | Tok_Some then\n                      Restore_Scan_State (Scan_State);  -- To FOR\n                      Node1 := P_Quantified_Expression;\n \n@@ -3638,7 +3628,7 @@ package body Ch4 is\n             Save_Scan_State (State);\n             Scan; -- past semicolon\n \n-            if Token = Tok_Else or else Token = Tok_Elsif then\n+            if Token in Tok_Else | Tok_Elsif then\n                Error_Msg_SP -- CODEFIX\n                  (\"|extra \"\";\"\" ignored\");\n \n@@ -3837,7 +3827,7 @@ package body Ch4 is\n          Save_Scan_State (Scan_State);\n          Scan;  --  past FOR\n \n-         if Token = Tok_All or else Token = Tok_Some then\n+         if Token in Tok_All | Tok_Some then\n             Restore_Scan_State (Scan_State);\n             Result := P_Quantified_Expression;\n "}, {"sha": "60b52bfb58aac21f511f30ed4468bd9e973f1c74", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 28, "deletions": 58, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -103,21 +103,11 @@ package body Ch5 is\n    --  | LOOP_STATEMENT       | BLOCK_STATEMENT\n    --  | ACCEPT_STATEMENT     | SELECT_STATEMENT\n \n-   --  This procedure scans a sequence of statements. The caller sets SS_Flags\n-   --  to indicate acceptable termination conditions for the sequence:\n-\n-   --    SS_Flags.Eftm Terminate on ELSIF\n-   --    SS_Flags.Eltm Terminate on ELSE\n-   --    SS_Flags.Extm Terminate on EXCEPTION\n-   --    SS_Flags.Ortm Terminate on OR\n-   --    SS_Flags.Tatm Terminate on THEN ABORT (Token = ABORT on return)\n-   --    SS_Flags.Whtm Terminate on WHEN\n-   --    SS_Flags.Unco Unconditional terminate after scanning one statement\n-\n-   --  In addition, the scan is always terminated by encountering END or the\n-   --  end of file (EOF) condition. If one of the six above terminators is\n-   --  encountered with the corresponding SS_Flags flag not set, then the\n-   --  action taken is as follows:\n+   --  This procedure scans a sequence of statements. SS_Flags indicates\n+   --  termination conditions for the sequence. In addition, the sequence is\n+   --  always terminated by encountering END or end of file. If one of the six\n+   --  above terminators is encountered with the corresponding SS_Flags flag\n+   --  not set, then the action taken is as follows:\n \n    --    If the keyword occurs to the left of the expected column of the end\n    --    for the current sequence (as recorded in the current end context),\n@@ -131,7 +121,8 @@ package body Ch5 is\n \n    --  Note that the first action means that control can return to the caller\n    --  with Token set to a terminator other than one of those specified by the\n-   --  SS parameter. The caller should treat such a case as equivalent to END.\n+   --  SS_Flags parameter. The caller should treat such a case as equivalent to\n+   --  END.\n \n    --  In addition, the flag SS_Flags.Sreq is set to True to indicate that at\n    --  least one real statement (other than a pragma) is required in the\n@@ -147,22 +138,22 @@ package body Ch5 is\n    function P_Sequence_Of_Statements\n      (SS_Flags : SS_Rec; Handled : Boolean := False) return List_Id\n    is\n-      Statement_Required : Boolean;\n+      Statement_Required : Boolean := SS_Flags.Sreq;\n       --  This flag indicates if a subsequent statement (other than a pragma)\n       --  is required. It is initialized from the Sreq flag, and modified as\n       --  statements are scanned (a statement turns it off, and a label turns\n       --  it back on again since a statement must follow a label).\n       --  Note : this final requirement is lifted in Ada 2012.\n \n-      Statement_Seen : Boolean;\n+      Statement_Seen : Boolean := False;\n       --  In Ada 2012, a label can end a sequence of statements, but the\n       --  sequence cannot contain only labels. This flag is set whenever a\n       --  label is encountered, to enforce this rule at the end of a sequence.\n \n       Scan_State_Label : Saved_Scan_State;\n       Scan_State       : Saved_Scan_State;\n \n-      Statement_List : List_Id;\n+      Statement_List : constant List_Id := New_List;\n       Block_Label    : Name_Id;\n       Id_Node        : Node_Id;\n       Name_Node      : Node_Id;\n@@ -215,13 +206,7 @@ package body Ch5 is\n                    and then Statement_Seen)\n                 or else All_Pragmas)\n             then\n-               declare\n-                  Null_Stm : constant Node_Id :=\n-                               Make_Null_Statement (Token_Ptr);\n-               begin\n-                  Set_Comes_From_Source (Null_Stm, False);\n-                  Append_To (Statement_List, Null_Stm);\n-               end;\n+               null;\n \n             --  If not Ada 2012, or not special case above, and no declaration\n             --  seen (as allowed in Ada 2020), give error message.\n@@ -236,10 +221,6 @@ package body Ch5 is\n    --  Start of processing for P_Sequence_Of_Statements\n \n    begin\n-      Statement_List := New_List;\n-      Statement_Required := SS_Flags.Sreq;\n-      Statement_Seen     := False;\n-\n       --  In Ada 2022, we allow declarative items to be mixed with\n       --  statements. The loop below alternates between calling\n       --  P_Declarative_Items to parse zero or more declarative items,\n@@ -270,7 +251,7 @@ package body Ch5 is\n             end if;\n          end;\n \n-         begin\n+         begin -- handle Error_Resync\n             if Style_Check then\n                Style.Check_Indentation;\n             end if;\n@@ -290,33 +271,23 @@ package body Ch5 is\n                   --  with the exception of the cases tested for below.\n \n                   (Token = Tok_Semicolon\n-                    and then Prev_Token /= Tok_Return\n-                    and then Prev_Token /= Tok_Null\n-                    and then Prev_Token /= Tok_Raise\n-                    and then Prev_Token /= Tok_End\n-                    and then Prev_Token /= Tok_Exit)\n+                    and then Prev_Token not in\n+                     Tok_Return | Tok_Null | Tok_Raise | Tok_End | Tok_Exit)\n \n                   --  If followed by colon, colon-equal, or dot, then we\n                   --  definitely  have an identifier (could not be reserved)\n \n-                  or else Token = Tok_Colon\n-                  or else Token = Tok_Colon_Equal\n-                  or else Token = Tok_Dot\n+                  or else Token in Tok_Colon | Tok_Colon_Equal | Tok_Dot\n \n                   --  Left paren means we have an identifier except for those\n                   --  reserved words that can legitimately be followed by a\n                   --  left paren.\n \n                   or else\n                     (Token = Tok_Left_Paren\n-                      and then Prev_Token /= Tok_Case\n-                      and then Prev_Token /= Tok_Delay\n-                      and then Prev_Token /= Tok_If\n-                      and then Prev_Token /= Tok_Elsif\n-                      and then Prev_Token /= Tok_Return\n-                      and then Prev_Token /= Tok_When\n-                      and then Prev_Token /= Tok_While\n-                      and then Prev_Token /= Tok_Separate)\n+                      and then Prev_Token not in\n+                       Tok_Case | Tok_Delay | Tok_If | Tok_Elsif | Tok_Return |\n+                       Tok_When | Tok_While | Tok_Separate)\n                then\n                   --  Here we have an apparent reserved identifier and the\n                   --  token past it is appropriate to this usage (and would\n@@ -704,11 +675,12 @@ package body Ch5 is\n                   --  instance of an incorrectly spelled keyword. If so, we\n                   --  do nothing. The Bad_Spelling_Of will have reset Token\n                   --  to the appropriate keyword, so the next time round the\n-                  --  loop we will process the modified token. Note that we\n-                  --  check for ELSIF before ELSE here. That's not accidental.\n-                  --  We don't want to identify a misspelling of ELSE as\n-                  --  ELSIF, and in particular we do not want to treat ELSEIF\n-                  --  as ELSE IF.\n+                  --  loop we will process the modified token.\n+                  --\n+                  --  Note that we check for ELSIF before ELSE here, because\n+                  --  we don't want to identify a misspelling of ELSE as ELSIF,\n+                  --  and in particular we do not want to treat ELSEIF as\n+                  --  ELSE IF.\n \n                   else\n                      Restore_Scan_State (Scan_State_Label); -- to identifier\n@@ -1452,7 +1424,7 @@ package body Ch5 is\n          --  If we have a WHEN or OTHERS, then that's fine keep going. Note\n          --  that it is a semantic check to ensure the proper use of OTHERS\n \n-         if Token = Tok_When or else Token = Tok_Others then\n+         if Token in Tok_When | Tok_Others then\n             Append (P_Case_Statement_Alternative, Alternatives_List);\n \n          --  If we have an END, then probably we are at the end of the case\n@@ -1764,7 +1736,7 @@ package body Ch5 is\n       --  expression it is an iterator specification. Ambiguity is resolved\n       --  during analysis of the loop parameter specification.\n \n-      if Token = Tok_Of or else Token = Tok_Colon then\n+      if Token in Tok_Of | Tok_Colon then\n          Error_Msg_Ada_2012_Feature (\"iterator\", Token_Ptr);\n          return P_Iterator_Specification (ID_Node);\n       end if;\n@@ -2272,9 +2244,7 @@ package body Ch5 is\n             --  END, EOF, or a token which starts declarations.\n \n             elsif Parent_Nkind = N_Package_Body\n-              and then (Token = Tok_End\n-                          or else Token = Tok_EOF\n-                          or else Token in Token_Class_Declk)\n+              and then (Token in Tok_End | Tok_EOF | Token_Class_Declk)\n             then\n                Set_Null_HSS (Parent);\n \n@@ -2384,7 +2354,7 @@ package body Ch5 is\n          TF_Then;\n       end loop;\n \n-      if Token = Tok_And or else Token = Tok_Or then\n+      if Token in Tok_And | Tok_Or then\n          Error_Msg_SC (\"unexpected logical operator\");\n          Scan; -- past logical operator\n "}, {"sha": "4f06297b4558eced2d73fa79118989800aeea3e9", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -180,21 +180,6 @@ package body Ch6 is\n    --    FUNCTION SPECIFICATION IS (EXPRESSION)\n    --      [ASPECT_SPECIFICATIONS];\n \n-   --  The value in Pf_Flags indicates which of these possible declarations\n-   --  is acceptable to the caller:\n-\n-   --    Pf_Flags.Decl                 Set if declaration OK\n-   --    Pf_Flags.Gins                 Set if generic instantiation OK\n-   --    Pf_Flags.Pbod                 Set if proper body OK\n-   --    Pf_Flags.Rnam                 Set if renaming declaration OK\n-   --    Pf_Flags.Stub                 Set if body stub OK\n-   --    Pf_Flags.Pexp                 Set if expression function OK\n-\n-   --  If an inappropriate form is encountered, it is scanned out but an\n-   --  error message indicating that it is appearing in an inappropriate\n-   --  context is issued. The only possible values for Pf_Flags are those\n-   --  defined as constants in the Par package.\n-\n    --  The caller has checked that the initial token is FUNCTION, PROCEDURE,\n    --  NOT or OVERRIDING.\n \n@@ -316,7 +301,7 @@ package body Ch6 is\n          then\n             Error_Msg_SC (\"overriding indicator not allowed here!\");\n \n-         elsif Token /= Tok_Function and then Token /= Tok_Procedure then\n+         elsif Token not in Tok_Function | Tok_Procedure then\n             Error_Msg_SC -- CODEFIX\n               (\"FUNCTION or PROCEDURE expected!\");\n          end if;\n@@ -737,22 +722,15 @@ package body Ch6 is\n                   --  or a pragma, then we definitely have a subprogram body.\n                   --  This is a common case, so worth testing first.\n \n-                  if Token = Tok_Begin\n-                    or else Token in Token_Class_Declk\n-                    or else Token = Tok_Pragma\n-                  then\n+                  if Token in Tok_Begin | Token_Class_Declk | Tok_Pragma then\n                      return False;\n \n                   --  Test for tokens which could only start an expression and\n                   --  thus signal the case of a expression function.\n \n-                  elsif Token     in Token_Class_Literal\n-                    or else Token in Token_Class_Unary_Addop\n-                    or else Token =  Tok_Left_Paren\n-                    or else Token =  Tok_Abs\n-                    or else Token =  Tok_Null\n-                    or else Token =  Tok_New\n-                    or else Token =  Tok_Not\n+                  elsif Token in\n+                    Token_Class_Literal | Token_Class_Unary_Addop |\n+                    Tok_Left_Paren | Tok_Abs | Tok_Null | Tok_New | Tok_Not\n                   then\n                      null;\n \n@@ -1161,9 +1139,8 @@ package body Ch6 is\n             Save_Scan_State (Scan_State);\n             Scan; -- past dot\n \n-            if Token = Tok_Identifier\n-              or else Token = Tok_Operator_Symbol\n-              or else Token = Tok_String_Literal\n+            if Token in\n+              Tok_Identifier | Tok_Operator_Symbol | Tok_String_Literal\n             then\n                return True;\n \n@@ -1180,8 +1157,7 @@ package body Ch6 is\n       Ident_Node := Token_Node;\n       Scan; -- past initial token\n \n-      if Prev_Token = Tok_Operator_Symbol\n-        or else Prev_Token = Tok_String_Literal\n+      if Prev_Token in Tok_Operator_Symbol | Tok_String_Literal\n         or else not Real_Dot\n       then\n          return Ident_Node;\n@@ -1216,7 +1192,7 @@ package body Ch6 is\n \n    exception\n       when Error_Resync =>\n-         while Token = Tok_Dot or else Token = Tok_Identifier loop\n+         while Token in Tok_Dot | Tok_Identifier loop\n             Scan;\n          end loop;\n \n@@ -1327,7 +1303,7 @@ package body Ch6 is\n \n    exception\n       when Error_Resync =>\n-         while Token = Tok_Dot or else Token = Tok_Identifier loop\n+         while Token in Tok_Dot | Tok_Identifier loop\n             Scan;\n          end loop;\n \n@@ -1462,10 +1438,8 @@ package body Ch6 is\n                      --  and on a right paren, e.g. Parms (X Y), and also\n                      --  on an assignment symbol, e.g. Parms (X Y := ..)\n \n-                     if Token = Tok_Semicolon\n-                       or else Token = Tok_Right_Paren\n-                       or else Token = Tok_EOF\n-                       or else Token = Tok_Colon_Equal\n+                     if Token in Tok_Semicolon | Tok_Right_Paren |\n+                       Tok_EOF | Tok_Colon_Equal\n                      then\n                         Restore_Scan_State (Scan_State);\n                         exit Ident_Loop;\n@@ -1474,9 +1448,7 @@ package body Ch6 is\n                      --  comma, e.g. Parms (A B : ...). Also assume a missing\n                      --  comma if we hit another comma, e.g. Parms (A B, C ..)\n \n-                     elsif Token = Tok_Colon\n-                       or else Token = Tok_Comma\n-                     then\n+                     elsif Token in Tok_Colon | Tok_Comma then\n                         Restore_Scan_State (Scan_State);\n                         exit Look_Ahead;\n                      end if;\n@@ -1551,7 +1523,7 @@ package body Ch6 is\n                --  Case of IN or OUT present\n \n                else\n-                  if Token = Tok_In or else Token = Tok_Out then\n+                  if Token in Tok_In | Tok_Out then\n                      if Not_Null_Present then\n                         Error_Msg\n                           (\"`NOT NULL` can only be used with `ACCESS`\",\n@@ -1627,7 +1599,7 @@ package body Ch6 is\n             --  If we have RETURN or IS after the semicolon, then assume\n             --  that semicolon should have been a right parenthesis and exit\n \n-            if Token = Tok_Is or else Token = Tok_Return then\n+            if Token in Tok_Is | Tok_Return then\n                Error_Msg_SP -- CODEFIX\n                  (\"|\"\";\"\" should be \"\")\"\"\");\n                exit Specification_Loop;"}, {"sha": "07c910a101607dee5d99c330827f9d027c0d88eb", "filename": "gcc/ada/par-ch7.adb", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch7.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -71,21 +71,6 @@ package body Ch7 is\n    --      new generic_package_NAME [GENERIC_ACTUAL_PART]\n    --        [ASPECT_SPECIFICATIONS];\n \n-   --  The value in Pf_Flags indicates which of these possible declarations\n-   --  is acceptable to the caller:\n-\n-   --    Pf_Flags.Spcn                 Set if specification OK\n-   --    Pf_Flags.Decl                 Set if declaration OK\n-   --    Pf_Flags.Gins                 Set if generic instantiation OK\n-   --    Pf_Flags.Pbod                 Set if proper body OK\n-   --    Pf_Flags.Rnam                 Set if renaming declaration OK\n-   --    Pf_Flags.Stub                 Set if body stub OK\n-\n-   --  If an inappropriate form is encountered, it is scanned out but an error\n-   --  message indicating that it is appearing in an inappropriate context is\n-   --  issued. The only possible settings for Pf_Flags are those defined as\n-   --  constants in package Par.\n-\n    --  Note: in all contexts where a package specification is required, there\n    --  is a terminating semicolon. This semicolon is scanned out in the case\n    --  where Pf_Flags is set to Pf_Spcn, even though it is not strictly part"}, {"sha": "6e9139c8eeead84b76a3337711f312f454133256", "filename": "gcc/ada/par-ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch8.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -94,7 +94,7 @@ package body Ch8 is\n    begin\n       Scan; -- past USE\n \n-      if Token = Tok_Type or else Token = Tok_All then\n+      if Token in Tok_Type | Tok_All then\n          P_Use_Type_Clause (Item_List);\n       else\n          P_Use_Package_Clause (Item_List);"}, {"sha": "310494eaf3b8740555d513fa1943504e023e3963", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -343,10 +343,7 @@ package body Ch9 is\n          --  Ada 2005 (AI-397): Reserved words NOT and OVERRIDING may begin an\n          --  entry declaration.\n \n-         elsif Token = Tok_Entry\n-           or else Token = Tok_Not\n-           or else Token = Tok_Overriding\n-         then\n+         elsif Token in Tok_Entry | Tok_Not | Tok_Overriding then\n             Append (P_Entry_Declaration, Items);\n \n          elsif Token = Tok_For then\n@@ -760,7 +757,7 @@ package body Ch9 is\n                Set_Must_Override     (Decl, Is_Overriding);\n                Set_Must_Not_Override (Decl, Not_Overriding);\n \n-            elsif Token = Tok_Function or else Token = Tok_Procedure then\n+            elsif Token in Tok_Function | Tok_Procedure then\n                Decl := P_Subprogram (Pf_Decl_Pexp);\n \n                Set_Must_Override     (Specification (Decl), Is_Overriding);\n@@ -987,7 +984,7 @@ package body Ch9 is\n \n             --  If comma or colon after Id, must be Formal_Part\n \n-            if Token = Tok_Comma or else Token = Tok_Colon then\n+            if Token in Tok_Comma | Tok_Colon then\n                Restore_Scan_State (Scan_State); -- to Id\n                Set_Parameter_Specifications (Decl_Node, P_Formal_Part);\n \n@@ -1095,7 +1092,7 @@ package body Ch9 is\n \n             --  If identifier followed by comma or colon, must be Formal_Part\n \n-            if Token = Tok_Comma or else Token = Tok_Colon then\n+            if Token in Tok_Comma | Tok_Colon then\n                Restore_Scan_State (Scan_State); -- to left paren\n                Set_Parameter_Specifications (Accept_Node, P_Parameter_Profile);\n "}, {"sha": "15b21cdddcfcf3e5b590750b816cc74ec780082b", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -242,7 +242,7 @@ package body Endh is\n             --  FOR or WHILE allowed (signalling error) to substitute for LOOP\n             --  if on the same line as the END.\n \n-            elsif (Token = Tok_For or else Token = Tok_While)\n+            elsif Token in Tok_For | Tok_While\n               and then not Token_Is_At_Start_Of_Line\n             then\n                Scan; -- past FOR or WHILE\n@@ -445,8 +445,7 @@ package body Endh is\n                --  incorrect. Same thing for a period in place of a semicolon.\n \n                elsif Token_Is_At_Start_Of_Line\n-                 or else Token = Tok_Colon\n-                 or else Token = Tok_Dot\n+                 or else Token in Tok_Colon | Tok_Dot\n                then\n                   T_Semicolon;\n \n@@ -480,10 +479,8 @@ package body Endh is\n             --  on the same line as the END\n \n             while not Token_Is_At_Start_Of_Line\n-              and then Prev_Token /= Tok_Record\n-              and then Prev_Token /= Tok_Semicolon\n-              and then Token /= Tok_End\n-              and then Token /= Tok_EOF\n+              and then Prev_Token not in Tok_Record | Tok_Semicolon\n+              and then Token not in Tok_End | Tok_EOF\n             loop\n                Scan; -- past junk\n             end loop;\n@@ -625,9 +622,8 @@ package body Endh is\n             return;\n          end if;\n \n-         if Token /= Tok_Identifier\n-           and then Token /= Tok_Operator_Symbol\n-           and then Token /= Tok_String_Literal\n+         if Token not in\n+           Tok_Identifier | Tok_Operator_Symbol | Tok_String_Literal\n          then\n             exit;\n          end if;\n@@ -655,9 +651,7 @@ package body Endh is\n       --  if there is no line end at the end of the last line of the file)\n \n       else\n-         while Token /= Tok_End\n-           and then Token /= Tok_EOF\n-           and then Token /= Tok_Semicolon\n+         while Token not in Tok_End | Tok_EOF | Tok_Semicolon\n            and then not Token_Is_At_Start_Of_Line\n          loop\n             Scan; -- past junk token on same line\n@@ -1157,9 +1151,7 @@ package body Endh is\n \n                   Scan; -- past END\n \n-                  if Token = Tok_Identifier\n-                    or else Token = Tok_Operator_Symbol\n-                  then\n+                  if Token in Tok_Identifier | Tok_Operator_Symbol then\n                      Nxt_Labl := P_Designator;\n \n                      --  We only consider it an error if the label is a match"}, {"sha": "570d22944aadba47d8a883aec0cad016b2d38c63", "filename": "gcc/ada/par-sync.adb", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-sync.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-sync.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-sync.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -58,9 +58,7 @@ package body Sync is\n    begin\n       Resync_Init;\n \n-      while Token not in Token_Class_Cunit\n-        and then Token /= Tok_EOF\n-      loop\n+      while Token not in Token_Class_Cunit | Tok_EOF loop\n          Scan;\n       end loop;\n \n@@ -92,9 +90,7 @@ package body Sync is\n \n            or else (Paren_Count = 0\n                      and then\n-                       (Token = Tok_Comma\n-                         or else Token = Tok_Right_Paren\n-                         or else Token = Tok_Vertical_Bar))\n+                       Token in Tok_Comma | Tok_Right_Paren | Tok_Vertical_Bar)\n          then\n             --  A special check: if we stop on the ELSE of OR ELSE or the\n             --  THEN of AND THEN, keep going, because this is not really an\n@@ -232,7 +228,7 @@ package body Sync is\n          --  in this category only if it does NOT appear after WITH.\n \n          elsif Token in Token_Class_After_SM\n-            and then (Token /= Tok_Private or else Prev_Token /= Tok_With)\n+           and then (Token /= Tok_Private or else Prev_Token /= Tok_With)\n          then\n             exit;\n \n@@ -274,7 +270,7 @@ package body Sync is\n \n          --  Done if we are at THEN or LOOP\n \n-         elsif Token = Tok_Then or else Token = Tok_Loop then\n+         elsif Token in Tok_Then | Tok_Loop then\n             exit;\n \n          --  Otherwise keep going\n@@ -316,10 +312,7 @@ package body Sync is\n       Paren_Count := 0;\n \n       loop\n-         if Token = Tok_EOF\n-           or else Token = Tok_Semicolon\n-           or else Token = Tok_Is\n-           or else Token in Token_Class_After_SM\n+         if Token in Tok_EOF | Tok_Semicolon | Tok_Is | Token_Class_After_SM\n          then\n             exit;\n \n@@ -386,10 +379,7 @@ package body Sync is\n       loop\n          --  Done if at semicolon, WHEN or IS\n \n-         if Token = Tok_Semicolon\n-           or else Token = Tok_When\n-           or else Token = Tok_Is\n-         then\n+         if Token in Tok_Semicolon | Tok_When | Tok_Is then\n             exit;\n \n          --  Otherwise keep going"}, {"sha": "3989cd25015ccc74a7da4238a473a6d2a55b17c9", "filename": "gcc/ada/par-tchk.adb", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-tchk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-tchk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-tchk.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -567,8 +567,7 @@ package body Tchk is\n \n          loop\n             if Prev_Token_Ptr < Current_Line_Start\n-              or else Token = Tok_Semicolon\n-              or else Token = Tok_EOF\n+              or else Token in Tok_Semicolon | Tok_EOF\n             then\n                Restore_Scan_State (Scan_State); -- to where we were\n                return;\n@@ -597,10 +596,7 @@ package body Tchk is\n \n       --  Allow OF or => or = in place of IS (with error message)\n \n-      elsif Token = Tok_Of\n-        or else Token = Tok_Arrow\n-        or else Token = Tok_Equal\n-      then\n+      elsif Token in Tok_Of | Tok_Arrow | Tok_Equal then\n          T_Is; -- give missing IS message and skip bad token\n \n       else\n@@ -609,19 +605,15 @@ package body Tchk is\n \n          loop\n             if Prev_Token_Ptr < Current_Line_Start\n-              or else Token = Tok_Semicolon\n-              or else Token = Tok_EOF\n+              or else Token in Tok_Semicolon | Tok_EOF\n             then\n                Restore_Scan_State (Scan_State); -- to where we were\n                return;\n             end if;\n \n             Scan; -- continue search\n \n-            if Token = Tok_Is\n-              or else Token = Tok_Of\n-              or else Token = Tok_Arrow\n-            then\n+            if Token in Tok_Is | Tok_Of | Tok_Arrow then\n                Scan; -- past IS or OF or =>\n                return;\n             end if;\n@@ -642,7 +634,7 @@ package body Tchk is\n \n       --  Allow DO or THEN in place of LOOP\n \n-      elsif Token = Tok_Then or else Token = Tok_Do then\n+      elsif Token in Tok_Then | Tok_Do then\n          T_Loop; -- give missing LOOP message\n \n       else\n@@ -651,16 +643,15 @@ package body Tchk is\n \n          loop\n             if Prev_Token_Ptr < Current_Line_Start\n-              or else Token = Tok_Semicolon\n-              or else Token = Tok_EOF\n+              or else Token in Tok_Semicolon | Tok_EOF\n             then\n                Restore_Scan_State (Scan_State); -- to where we were\n                return;\n             end if;\n \n             Scan; -- continue search\n \n-            if Token = Tok_Loop or else Token = Tok_Then then\n+            if Token in Tok_Loop | Tok_Then then\n                Scan; -- past loop or then (message already generated)\n                return;\n             end if;\n@@ -686,8 +677,7 @@ package body Tchk is\n \n          loop\n             if Prev_Token_Ptr < Current_Line_Start\n-              or else Token = Tok_Semicolon\n-              or else Token = Tok_EOF\n+              or else Token in Tok_Semicolon | Tok_EOF\n             then\n                Restore_Scan_State (Scan_State); -- to where we were\n                return;\n@@ -752,8 +742,7 @@ package body Tchk is\n \n          loop\n             if Prev_Token_Ptr < Current_Line_Start\n-              or else Token = Tok_EOF\n-              or else Token = Tok_End\n+              or else Token in Tok_EOF | Tok_End\n             then\n                Restore_Scan_State (Scan_State); -- to where we were\n                return;\n@@ -789,8 +778,7 @@ package body Tchk is\n \n          loop\n             if Prev_Token_Ptr < Current_Line_Start\n-              or else Token = Tok_Semicolon\n-              or else Token = Tok_EOF\n+              or else Token in Tok_Semicolon | Tok_EOF\n             then\n                Restore_Scan_State (Scan_State); -- to where we were\n                return;\n@@ -823,8 +811,7 @@ package body Tchk is\n \n          loop\n             if Prev_Token_Ptr < Current_Line_Start\n-              or else Token = Tok_Semicolon\n-              or else Token = Tok_EOF\n+              or else Token in Tok_Semicolon | Tok_EOF\n             then\n                Restore_Scan_State (Scan_State); -- to where we were\n                return;"}, {"sha": "038741853d77d46c9f9a95a55ec150efcd84175b", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -336,7 +336,7 @@ package body Util is\n             --  probably the semicolon did end the list. Indeed that is\n             --  certainly the only single error correction possible here.\n \n-            if Token = Tok_Semicolon or else Token = Tok_EOF then\n+            if Token in Tok_Semicolon | Tok_EOF then\n                Restore_Scan_State (Scan_State);\n                return False;\n \n@@ -521,44 +521,34 @@ package body Util is\n                         raise Program_Error;\n \n                      when C_Comma_Right_Paren =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Comma or else Token = Tok_Right_Paren;\n+                        OK_Next_Tok := Token in Tok_Comma | Tok_Right_Paren;\n \n                      when C_Comma_Colon =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Comma or else Token = Tok_Colon;\n+                        OK_Next_Tok := Token in Tok_Comma | Tok_Colon;\n \n                      when C_Do =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Do;\n+                        OK_Next_Tok := Token = Tok_Do;\n \n                      when C_Dot =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Dot;\n+                        OK_Next_Tok := Token = Tok_Dot;\n \n                      when C_Greater_Greater =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Greater_Greater;\n+                        OK_Next_Tok := Token = Tok_Greater_Greater;\n \n                      when C_In =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_In;\n+                        OK_Next_Tok := Token = Tok_In;\n \n                      when C_Is =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Is;\n+                        OK_Next_Tok := Token = Tok_Is;\n \n                      when C_Left_Paren_Semicolon =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Left_Paren or else Token = Tok_Semicolon;\n+                        OK_Next_Tok := Token in Tok_Left_Paren | Tok_Semicolon;\n \n                      when C_Use =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Use;\n+                        OK_Next_Tok := Token = Tok_Use;\n \n                      when C_Vertical_Bar_Arrow =>\n-                        OK_Next_Tok :=\n-                          Token = Tok_Vertical_Bar or else Token = Tok_Arrow;\n+                        OK_Next_Tok := Token in Tok_Vertical_Bar | Tok_Arrow;\n                   end case;\n \n                   Restore_Scan_State (Scan_State);\n@@ -802,7 +792,7 @@ package body Util is\n \n    function Token_Is_At_Start_Of_Line return Boolean is\n    begin\n-      return (Token_Ptr = First_Non_Blank_Location or else Token = Tok_EOF);\n+      return Token_Ptr = First_Non_Blank_Location or else Token = Tok_EOF;\n    end Token_Is_At_Start_Of_Line;\n \n    -----------------------------------"}, {"sha": "01e3c4b1a4f4737b3c98e83fca97668341f4e248", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -361,36 +361,29 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n    Expr_Form : Expr_Form_Type;\n \n-   --  The following type is used for calls to P_Subprogram, P_Package, P_Task,\n-   --  P_Protected to indicate which of several possibilities is acceptable.\n+   --  The following type is used by P_Subprogram, P_Package, to indicate which\n+   --  of several possibilities is acceptable.\n \n    type Pf_Rec is record\n-      Spcn : Boolean;                  -- True if specification OK\n-      Decl : Boolean;                  -- True if declaration OK\n-      Gins : Boolean;                  -- True if generic instantiation OK\n-      Pbod : Boolean;                  -- True if proper body OK\n-      Rnam : Boolean;                  -- True if renaming declaration OK\n-      Stub : Boolean;                  -- True if body stub OK\n-      Pexp : Boolean;                  -- True if parameterized expression OK\n-      Fil2 : Boolean;                  -- Filler to fill to 8 bits\n+      Spcn : Boolean; -- True if specification OK\n+      Decl : Boolean; -- True if declaration OK\n+      Gins : Boolean; -- True if generic instantiation OK\n+      Pbod : Boolean; -- True if proper body OK\n+      Rnam : Boolean; -- True if renaming declaration OK\n+      Stub : Boolean; -- True if body stub OK\n+      Pexp : Boolean; -- True if parameterized expression OK\n    end record;\n    pragma Pack (Pf_Rec);\n \n    function T return Boolean renames True;\n    function F return Boolean renames False;\n \n-   Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp : constant Pf_Rec :=\n-                                       Pf_Rec'(F, T, T, T, T, T, T, F);\n-   Pf_Decl_Pexp                     : constant Pf_Rec :=\n-                                       Pf_Rec'(F, T, F, F, F, F, T, F);\n-   Pf_Decl_Gins_Pbod_Rnam_Pexp      : constant Pf_Rec :=\n-                                       Pf_Rec'(F, T, T, T, T, F, T, F);\n-   Pf_Decl_Pbod_Pexp                : constant Pf_Rec :=\n-                                       Pf_Rec'(F, T, F, T, F, F, T, F);\n-   Pf_Pbod_Pexp                     : constant Pf_Rec :=\n-                                       Pf_Rec'(F, F, F, T, F, F, T, F);\n-   Pf_Spcn                         : constant Pf_Rec :=\n-                                       Pf_Rec'(T, F, F, F, F, F, F, F);\n+   Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp : constant Pf_Rec := (F, T, T, T, T, T, T);\n+   Pf_Decl_Pexp                     : constant Pf_Rec := (F, T, F, F, F, F, T);\n+   Pf_Decl_Gins_Pbod_Rnam_Pexp      : constant Pf_Rec := (F, T, T, T, T, F, T);\n+   Pf_Decl_Pbod_Pexp                : constant Pf_Rec := (F, T, F, T, F, F, T);\n+   Pf_Pbod_Pexp                     : constant Pf_Rec := (F, F, F, T, F, F, T);\n+   Pf_Spcn                          : constant Pf_Rec := (T, F, F, F, F, F, F);\n    --  The above are the only allowed values of Pf_Rec arguments\n \n    type SS_Rec is record\n@@ -405,15 +398,15 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    end record;\n    pragma Pack (SS_Rec);\n \n-   SS_Eftm_Eltm_Sreq : constant SS_Rec := SS_Rec'(T, T, F, F, T, F, F, F);\n-   SS_Eltm_Ortm_Tatm : constant SS_Rec := SS_Rec'(F, T, F, T, F, T, F, F);\n-   SS_Extm_Sreq      : constant SS_Rec := SS_Rec'(F, F, T, F, T, F, F, F);\n-   SS_None           : constant SS_Rec := SS_Rec'(F, F, F, F, F, F, F, F);\n-   SS_Ortm_Sreq      : constant SS_Rec := SS_Rec'(F, F, F, T, T, F, F, F);\n-   SS_Sreq           : constant SS_Rec := SS_Rec'(F, F, F, F, T, F, F, F);\n-   SS_Sreq_Whtm      : constant SS_Rec := SS_Rec'(F, F, F, F, T, F, T, F);\n-   SS_Whtm           : constant SS_Rec := SS_Rec'(F, F, F, F, F, F, T, F);\n-   SS_Unco           : constant SS_Rec := SS_Rec'(F, F, F, F, F, F, F, T);\n+   SS_Eftm_Eltm_Sreq : constant SS_Rec := (T, T, F, F, T, F, F, F);\n+   SS_Eltm_Ortm_Tatm : constant SS_Rec := (F, T, F, T, F, T, F, F);\n+   SS_Extm_Sreq      : constant SS_Rec := (F, F, T, F, T, F, F, F);\n+   SS_None           : constant SS_Rec := (F, F, F, F, F, F, F, F);\n+   SS_Ortm_Sreq      : constant SS_Rec := (F, F, F, T, T, F, F, F);\n+   SS_Sreq           : constant SS_Rec := (F, F, F, F, T, F, F, F);\n+   SS_Sreq_Whtm      : constant SS_Rec := (F, F, F, F, T, F, T, F);\n+   SS_Whtm           : constant SS_Rec := (F, F, F, F, F, F, T, F);\n+   SS_Unco           : constant SS_Rec := (F, F, F, F, F, F, F, T);\n \n    Goto_List : Elist_Id;\n    --  List of goto nodes appearing in the current compilation. Used to\n@@ -882,9 +875,9 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n       function P_Sequence_Of_Statements\n         (SS_Flags : SS_Rec; Handled : Boolean := False) return List_Id;\n-      --  The argument indicates the acceptable termination tokens.\n-      --  See body in Par.Ch5 for details of the use of this parameter.\n-      --  Handled is true if we are parsing a handled sequence of statements.\n+      --  SS_Flags indicates the acceptable termination tokens; see body for\n+      --  details. Handled is true if we are parsing a handled sequence of\n+      --  statements.\n \n       procedure Parse_Decls_Begin_End (Parent : Node_Id);\n       --  Parses declarations and handled statement sequence, setting"}, {"sha": "6731baeb6e1e13d07d60a8da00829c979a18deb0", "filename": "gcc/ada/prep.adb", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprep.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -461,11 +461,8 @@ package body Prep is\n \n                --  Handle relational operator\n \n-               elsif     Token = Tok_Equal\n-                 or else Token = Tok_Less\n-                 or else Token = Tok_Less_Equal\n-                 or else Token = Tok_Greater\n-                 or else Token = Tok_Greater_Equal\n+               elsif Token in Tok_Equal | Tok_Less | Tok_Less_Equal |\n+                 Tok_Greater | Tok_Greater_Equal\n                then\n                   Relop := Token;\n                   Scan.all;\n@@ -771,9 +768,7 @@ package body Prep is\n    begin\n       --  Scan until we get an end of line or we reach the end of the buffer\n \n-      while Token /= Tok_End_Of_Line\n-        and then Token /= Tok_EOF\n-      loop\n+      while Token not in Tok_End_Of_Line | Tok_EOF loop\n          Scan.all;\n       end loop;\n    end Go_To_End_Of_Line;\n@@ -1042,7 +1037,7 @@ package body Prep is\n \n                Scan.all;\n \n-               if Token /= Tok_End_Of_Line and then Token /= Tok_EOF then\n+               if Token not in Tok_End_Of_Line | Tok_EOF then\n                   Error_Msg (\"extraneous text in definition\", Token_Ptr);\n                   goto Cleanup;\n                end if;\n@@ -1056,12 +1051,12 @@ package body Prep is\n \n                Scan.all;\n \n-               if Token /= Tok_End_Of_Line and then Token /= Tok_EOF then\n+               if Token not in Tok_End_Of_Line | Tok_EOF then\n                   Error_Msg (\"extraneous text in definition\", Token_Ptr);\n                   goto Cleanup;\n                end if;\n \n-            elsif Token = Tok_End_Of_Line or else Token = Tok_EOF then\n+            elsif Token in Tok_End_Of_Line | Tok_EOF then\n                Data := (Symbol              => Symbol_Name,\n                         Original            => Original_Name,\n                         On_The_Command_Line => False,\n@@ -1093,7 +1088,7 @@ package body Prep is\n \n                Scan.all;\n \n-               if Token /= Tok_End_Of_Line and then Token /= Tok_EOF then\n+               if Token not in Tok_End_Of_Line | Tok_EOF then\n                   Error_Msg (\"extraneous text in definition\", Token_Ptr);\n                   goto Cleanup;\n                end if;\n@@ -1144,7 +1139,7 @@ package body Prep is\n             <<Cleanup>>\n                Set_Ignore_Errors (To => True);\n \n-               while Token /= Tok_End_Of_Line and then Token /= Tok_EOF loop\n+               while Token not in Tok_End_Of_Line | Tok_EOF loop\n                   Scan.all;\n                end loop;\n \n@@ -1261,9 +1256,7 @@ package body Prep is\n                         --  It is an error to have trailing characters after\n                         --  the condition or \"then\".\n \n-                        if Token /= Tok_End_Of_Line\n-                          and then Token /= Tok_EOF\n-                        then\n+                        if Token not in Tok_End_Of_Line | Tok_EOF then\n                            Error_Msg\n                              (\"extraneous text on preprocessor line\",\n                               Token_Ptr);\n@@ -1318,9 +1311,7 @@ package body Prep is\n                      --  It is an error to have trailing characters after the\n                      --  condition or \"then\".\n \n-                     if Token /= Tok_End_Of_Line\n-                       and then Token /= Tok_EOF\n-                     then\n+                     if Token not in Tok_End_Of_Line | Tok_EOF then\n                         Error_Msg\n                           (\"extraneous text on preprocessor line\",\n                            Token_Ptr);\n@@ -1384,9 +1375,7 @@ package body Prep is\n \n                      --  Error of character present after \"#else\"\n \n-                     if Token /= Tok_End_Of_Line\n-                       and then Token /= Tok_EOF\n-                     then\n+                     if Token not in Tok_End_Of_Line | Tok_EOF then\n                         Error_Msg\n                           (\"extraneous text on preprocessor line\",\n                            Token_Ptr);\n@@ -1427,9 +1416,7 @@ package body Prep is\n \n                            --  Error of character present after \"#end if;\"\n \n-                           if Token /= Tok_End_Of_Line\n-                             and then Token /= Tok_EOF\n-                           then\n+                           if Token not in Tok_End_Of_Line | Tok_EOF then\n                               Error_Msg\n                                 (\"extraneous text on preprocessor line\",\n                                  Token_Ptr);\n@@ -1496,9 +1483,7 @@ package body Prep is\n                   Go_To_End_Of_Line;\n \n                else\n-                  while Token /= Tok_End_Of_Line\n-                    and then Token /= Tok_EOF\n-                  loop\n+                  while Token not in Tok_End_Of_Line | Tok_EOF loop\n                      if Token = Tok_Special\n                        and then Special_Character = '$'\n                      then\n@@ -1564,7 +1549,7 @@ package body Prep is\n             end if;\n          end if;\n \n-         pragma Assert (Token = Tok_End_Of_Line or else Token = Tok_EOF);\n+         pragma Assert (Token in Tok_End_Of_Line | Tok_EOF);\n \n          --  At this point, the token is either end of line or EOF. The line to\n          --  possibly output stops just before the token."}, {"sha": "a1fe0254de1492babb85761f160008a24604e1c2", "filename": "gcc/ada/prepcomp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fprepcomp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fprepcomp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprepcomp.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -311,7 +311,7 @@ package body Prepcomp is\n \n          --  Check the switches that may follow\n \n-         while Token /= Tok_End_Of_Line and then Token /= Tok_EOF loop\n+         while Token not in Tok_End_Of_Line | Tok_EOF loop\n             if Token /= Tok_Minus then\n                Error_Msg -- CODEFIX\n                  (\"`'-` expected\", Token_Ptr);\n@@ -755,7 +755,7 @@ package body Prepcomp is\n    begin\n       Set_Ignore_Errors (To => True);\n \n-      while Token /= Tok_End_Of_Line and then Token /= Tok_EOF loop\n+      while Token not in Tok_End_Of_Line | Tok_EOF loop\n          Scan;\n       end loop;\n "}, {"sha": "b6698a673638626cb8208cdc67ace3e1d4b257b1", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/272ada7499e6ce8e1a8bd3f82c1cc030a51d074e/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=272ada7499e6ce8e1a8bd3f82c1cc030a51d074e", "patch": "@@ -1747,15 +1747,9 @@ package body Scng is\n             --  In Ada 2022, a target name (i.e. @) is a valid prefix of an\n             --  attribute, and functions like a name.\n \n-            if Prev_Token = Tok_All\n-              or else Prev_Token = Tok_At_Sign\n-              or else Prev_Token = Tok_Delta\n-              or else Prev_Token = Tok_Digits\n-              or else Prev_Token = Tok_Identifier\n-              or else Prev_Token = Tok_Project\n-              or else Prev_Token = Tok_Right_Paren\n-              or else Prev_Token = Tok_Right_Bracket\n-              or else Prev_Token in Token_Class_Literal\n+            if Prev_Token in Tok_All | Tok_At_Sign | Tok_Delta | Tok_Digits |\n+              Tok_Identifier | Tok_Project | Tok_Right_Paren |\n+              Tok_Right_Bracket | Token_Class_Literal\n             then\n                Token := Tok_Apostrophe;\n "}]}