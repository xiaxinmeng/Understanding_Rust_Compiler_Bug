{"sha": "61a04b5b59974a336e436f0aac7d0e4353007dc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhMDRiNWI1OTk3NGEzMzZlNDM2ZjBhYWM3ZDBlNDM1MzAwN2RjOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-02-18T20:05:00Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-02-18T20:05:00Z"}, "message": "trans-array.c (gfc_build_constant_array_constructor): When the shape of the constructor is known...\n\n\n\t* trans-array.c (gfc_build_constant_array_constructor): When the\n\tshape of the constructor is known, use that to construct the\n\tgfc_array_spec.\n\t(gfc_trans_constant_array_constructor): Initialize the \"info\"\n\tinformation for all of the dimensions of the array constructor.\n\t(constant_array_constructor_loop_size): New function.\n\t(gfc_trans_array_constructor): Use it to determine whether a\n\tloop is suitable for \"constant array constructor\" optimization.\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_anyall): Use fold_build2\n\tinstead of build2, to avoid conditions like \"(a != b) != 0\".\n\n\t* gfortran.dg/array_constructor_15.f90: New test case.\n\nFrom-SVN: r122103", "tree": {"sha": "e0bd20d27931c0f092bc30265db72ff3f635d2eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0bd20d27931c0f092bc30265db72ff3f635d2eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61a04b5b59974a336e436f0aac7d0e4353007dc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a04b5b59974a336e436f0aac7d0e4353007dc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a04b5b59974a336e436f0aac7d0e4353007dc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a04b5b59974a336e436f0aac7d0e4353007dc9/comments", "author": null, "committer": null, "parents": [{"sha": "9bffa1718a6f2edeeec1aec1f4afef0ff69584ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bffa1718a6f2edeeec1aec1f4afef0ff69584ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bffa1718a6f2edeeec1aec1f4afef0ff69584ce"}], "stats": {"total": 109, "additions": 90, "deletions": 19}, "files": [{"sha": "388bfd60cd81a9269730353c754fea973dea3a26", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=61a04b5b59974a336e436f0aac7d0e4353007dc9", "patch": "@@ -1,3 +1,17 @@\n+2007-02-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-array.c (gfc_build_constant_array_constructor): When the\n+\tshape of the constructor is known, use that to construct the\n+\tgfc_array_spec.\n+\t(gfc_trans_constant_array_constructor): Initialize the \"info\"\n+\tinformation for all of the dimensions of the array constructor.\n+\t(constant_array_constructor_loop_size): New function.\n+\t(gfc_trans_array_constructor): Use it to determine whether a\n+\tloop is suitable for \"constant array constructor\" optimization.\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_anyall): Use fold_build2\n+\tinstead of build2, to avoid conditions like \"(a != b) != 0\".\n+\n 2007-02-18  Roger Sayle  <roger@eyesopen.com>\n \t    Paul Thomas <pault@gcc.gnu.org>\n \n@@ -11,7 +25,7 @@\n \n \tPR fortran/30793\n \t* trans-decl.c (gfc_generate_function_code): Do not initialize\n-\t  pointers to derived components.\n+\tpointers to derived components.\n \n 2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Brooks Moses  <brooks.moses@codesourcery.com>"}, {"sha": "683c8bdf6e1a79735baf5c65edff99672c4cc523", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=61a04b5b59974a336e436f0aac7d0e4353007dc9", "patch": "@@ -1453,7 +1453,7 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n   gfc_constructor *c;\n   gfc_array_spec as;\n   gfc_se se;\n-\n+  int i;\n \n   /* First traverse the constructor list, converting the constants\n      to tree to build an initializer.  */\n@@ -1478,10 +1478,21 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n \n   memset (&as, 0, sizeof (gfc_array_spec));\n \n-  as.rank = 1;\n+  as.rank = expr->rank;\n   as.type = AS_EXPLICIT;\n-  as.lower[0] = gfc_int_expr (0);\n-  as.upper[0] = gfc_int_expr (nelem - 1);\n+  if (!expr->shape)\n+    {\n+      as.lower[0] = gfc_int_expr (0);\n+      as.upper[0] = gfc_int_expr (nelem - 1);\n+    }\n+  else\n+    for (i = 0; i < expr->rank; i++)\n+      {\n+\tint tmp = (int) mpz_get_si (expr->shape[i]);\n+\tas.lower[i] = gfc_int_expr (0);\n+\tas.upper[i] = gfc_int_expr (tmp - 1);\n+      }\n+\n   tmptype = gfc_get_nodesc_array_type (type, &as, 3);\n \n   init = build_constructor_from_list (tmptype, nreverse (list));\n@@ -1512,6 +1523,7 @@ gfc_trans_constant_array_constructor (gfc_loopinfo * loop,\n {\n   gfc_ss_info *info;\n   tree tmp;\n+  int i;\n \n   tmp = gfc_build_constant_array_constructor (ss->expr, type);\n \n@@ -1522,16 +1534,54 @@ gfc_trans_constant_array_constructor (gfc_loopinfo * loop,\n   info->offset = fold_build1 (NEGATE_EXPR, gfc_array_index_type,\n \t\t\t      loop->from[0]);\n \n-  info->delta[0] = gfc_index_zero_node;\n-  info->start[0] = gfc_index_zero_node;\n-  info->end[0] = gfc_index_zero_node;\n-  info->stride[0] = gfc_index_one_node;\n-  info->dim[0] = 0;\n+  for (i = 0; i < info->dimen; i++)\n+    {\n+      info->delta[i] = gfc_index_zero_node;\n+      info->start[i] = gfc_index_zero_node;\n+      info->end[i] = gfc_index_zero_node;\n+      info->stride[i] = gfc_index_one_node;\n+      info->dim[i] = i;\n+    }\n \n   if (info->dimen > loop->temp_dim)\n     loop->temp_dim = info->dimen;\n }\n \n+/* Helper routine of gfc_trans_array_constructor to determine if the\n+   bounds of the loop specified by LOOP are constant and simple enough\n+   to use with gfc_trans_constant_array_constructor.  Returns the\n+   the iteration count of the loop if suitable, and NULL_TREE otherwise.  */\n+\n+static tree\n+constant_array_constructor_loop_size (gfc_loopinfo * loop)\n+{\n+  tree size = gfc_index_one_node;\n+  tree tmp;\n+  int i;\n+\n+  for (i = 0; i < loop->dimen; i++)\n+    {\n+      /* If the bounds aren't constant, return NULL_TREE.  */\n+      if (!INTEGER_CST_P (loop->from[i]) || !INTEGER_CST_P (loop->to[i]))\n+\treturn NULL_TREE;\n+      if (!integer_zerop (loop->from[i]))\n+\t{\n+\t  /* Only allow non-zero \"from\" in one-dimensional arrays.  */\n+\t  if (loop->dimen != 1)\n+\t    return NULL_TREE;\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     loop->to[i], loop->from[i]);\n+\t}\n+      else\n+\ttmp = loop->to[i];\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t tmp, gfc_index_one_node);\n+      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+    }\n+\n+  return size;\n+}\n+\n \n /* Array constructors are handled by constructing a temporary, then using that\n    within the scalarization loop.  This is not optimal, but seems by far the\n@@ -1584,17 +1634,13 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n     }\n \n   /* Special case constant array constructors.  */\n-  if (!dynamic\n-      && loop->dimen == 1\n-      && INTEGER_CST_P (loop->from[0])\n-      && INTEGER_CST_P (loop->to[0]))\n+  if (!dynamic)\n     {\n       unsigned HOST_WIDE_INT nelem = gfc_constant_array_constructor_p (c);\n       if (nelem > 0)\n \t{\n-\t  tree diff = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t   loop->to[0], loop->from[0]);\n-\t  if (compare_tree_int (diff, nelem - 1) == 0)\n+\t  tree size = constant_array_constructor_loop_size (loop);\n+\t  if (size && compare_tree_int (size, nelem) == 0)\n \t    {\n \t      gfc_trans_constant_array_constructor (loop, ss, type);\n \t      return;"}, {"sha": "c041b630e77b2f84c3e96219aba2e80a0d26e51f", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=61a04b5b59974a336e436f0aac7d0e4353007dc9", "patch": "@@ -1604,8 +1604,8 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, int op)\n   gfc_conv_expr_val (&arrayse, actual->expr);\n \n   gfc_add_block_to_block (&body, &arrayse.pre);\n-  tmp = build2 (op, boolean_type_node, arrayse.expr,\n-\t\tbuild_int_cst (TREE_TYPE (arrayse.expr), 0));\n+  tmp = fold_build2 (op, boolean_type_node, arrayse.expr,\n+\t\t     build_int_cst (TREE_TYPE (arrayse.expr), 0));\n   tmp = build3_v (COND_EXPR, tmp, found, build_empty_stmt ());\n   gfc_add_expr_to_block (&body, tmp);\n   gfc_add_block_to_block (&body, &arrayse.post);"}, {"sha": "3151a7dfba4bd312af6be601e341afdf0ed69c31", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=61a04b5b59974a336e436f0aac7d0e4353007dc9", "patch": "@@ -1,3 +1,7 @@\n+2007-02-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gfortran.dg/array_constructor_15.f90: New test case.\n+\n 2007-02-18  Roger Sayle  <roger@eyesopen.com>\n \n         * gfortran.dg/forall_10.f90: New test case."}, {"sha": "71260169d580abfea288ef7eb823775a9f7da546", "filename": "gcc/testsuite/gfortran.dg/array_constructor_15.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a04b5b59974a336e436f0aac7d0e4353007dc9/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_15.f90?ref=61a04b5b59974a336e436f0aac7d0e4353007dc9", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+  integer :: x(2,2)\n+  if (any(x(:,:) .ne. reshape ((/ 3, 1, 4, 1 /), (/ 2, 2 /)))) call abort ()\n+end\n+! { dg-final { scan-tree-dump-times \"atmp\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}