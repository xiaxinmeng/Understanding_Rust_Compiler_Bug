{"sha": "35dfe41582cd24b566f56060ec3808a04a9a6909", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVkZmU0MTU4MmNkMjRiNTY2ZjU2MDYwZWMzODA4YTA0YTlhNjkwOQ==", "commit": {"author": {"name": "Bruce Korb", "email": "bkorb@gnu.org", "date": "2000-05-11T13:41:12Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2000-05-11T13:41:12Z"}, "message": "Added support for \"make check\" and the \"format\" c_fix\n\nFrom-SVN: r33843", "tree": {"sha": "56fe6d3cc1eea556ac96953893b16dc1559b0925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56fe6d3cc1eea556ac96953893b16dc1559b0925"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35dfe41582cd24b566f56060ec3808a04a9a6909", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35dfe41582cd24b566f56060ec3808a04a9a6909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35dfe41582cd24b566f56060ec3808a04a9a6909", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35dfe41582cd24b566f56060ec3808a04a9a6909/comments", "author": {"login": "brkorb", "id": 1242936, "node_id": "MDQ6VXNlcjEyNDI5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1242936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brkorb", "html_url": "https://github.com/brkorb", "followers_url": "https://api.github.com/users/brkorb/followers", "following_url": "https://api.github.com/users/brkorb/following{/other_user}", "gists_url": "https://api.github.com/users/brkorb/gists{/gist_id}", "starred_url": "https://api.github.com/users/brkorb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brkorb/subscriptions", "organizations_url": "https://api.github.com/users/brkorb/orgs", "repos_url": "https://api.github.com/users/brkorb/repos", "events_url": "https://api.github.com/users/brkorb/events{/privacy}", "received_events_url": "https://api.github.com/users/brkorb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e54d500c8d8760c51e20259c6aa97471e1cf04cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54d500c8d8760c51e20259c6aa97471e1cf04cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e54d500c8d8760c51e20259c6aa97471e1cf04cc"}], "stats": {"total": 736, "additions": 284, "deletions": 452}, "files": [{"sha": "e26be78c65cf55f695a6e108ba65e8fc5d9ba285", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -1,3 +1,19 @@\n+2000-05-11  Bruce Korb  <bkorb@gnu.org>\n+\n+\t* fixinc/fixfixes.c(double_slash_fix):  obsolete\n+\t(else_endif_label_fix): obsolete\n+\t(format_fix):  new, unused as yet\n+\t(main): obsolete\n+\t* fixinc/fixlib.h: added fix description struct for use by format_fix\n+\t* fixinc/fixincl.c: removed the struct & test for SIGIOT befure using\n+\t* fixinc/Makefile.in:  compile fixfixes.c and fixtests.c as separate\n+\tmodules.  Removed the vestiges of the script version.\n+\tAdded support for \"make check\".\n+\t* fixinc/check.tpl: quiet the fixup output\n+\t* fixinc/fixtests.c(main): obsolete\n+\t* fixinc/fixincl.sh:  don't bother copying fixincl to ..\n+\t* fixinc/fixincl.tpl:  provide for arguments to c_fix routines\n+\n Thu May 11 11:57:02 MET DST 2000  Jan Hubicka <jh@suse.cz>\n \n \t* toplev.c (rest_of_compilation): Remove dead code after"}, {"sha": "b1d360fd83df2a40791773caa43dd0aa6c6ead07", "filename": "gcc/fixinc/Makefile.in", "status": "modified", "additions": 40, "deletions": 60, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2FMakefile.in?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -35,13 +35,15 @@ subdir = fixinc\n \n # End of variables for you to override.\n \n-default : gen\n+default : all\n \n # Now figure out from those variables how to compile and link.\n \n # Specify the directories to be searched for header files.\n # Both . and srcdir are used, in that order.\n-INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)/../../include\n+#\n+INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. \\\n+-I$(srcdir)/../config -I$(srcdir)/../../include\n \n # Always use -I$(srcdir)/config when compiling.\n .c.o:\n@@ -60,86 +62,64 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n ## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n \n LIBERTY = ../../libiberty/libiberty.a\n-LIBOBJ  = gnu-regex.o fixlib.o $(LIBERTY)\n-FIOBJ   = fixincl.o server.o procopen.o $(LIBOBJ)\n+OBJ = fixincl.o fixtests.o fixfixes.o server.o procopen.o \\\n+      gnu-regex.o fixlib.o\n \n HDR = server.h gnu-regex.h fixlib.h machname.h\n \n-BIN_TARGET = fixincl fixfixes fixtests\n-\n-TARGETS    = $(BIN_TARGET)\n+TARGETS = fixincl\n \n all : $(TARGETS)\n gen : fixincl.x\n \n-$(FIOBJ): $(HDR)\n-\n-fixincl: $(FIOBJ)\n-\t@echo $(CC) $(FIXINC_DEFS) -o $@ $(FIOBJ) ; \\\n-\tif $(CC) $(FIXINC_DEFS) -o $@ $(FIOBJ) ; then : ; else \\\n-\trm -f $@ ; (echo \"#! /bin/sh\" ; echo exit 1 ) > $@ ; \\\n-\tchmod 777 $@ ; fi\n-\n-fixfixes: fixfixes.c $(LIBOBJ)\n-\t$(CC) -o $@ $(FIXINC_DEFS) -DMAIN \\\n-\t\t$(srcdir)/fixfixes.c $(LIBOBJ) $(LIB)\n-\n-fixtests: fixtests.c $(LIBOBJ)\n-\t$(CC) -o $@ $(FIXINC_DEFS) -DMAIN \\\n-\t\t$(srcdir)/fixtests.c $(LIBOBJ) $(LIB)\n-\n-fixincl.o : fixincl.x fixincl.c fixfixes.c fixtests.c\n-server.o : server.c server.h\n-procopen.o : procopen.c server.h\n-fixlib.o: machname.h\n-\n-fixincl.x: fixincl.tpl inclhack.def\n-\tcd $(srcdir) ; $(SHELL) ./genfixes $@\n+fixincl: $(OBJ) $(LIBERTY)\n+\t$(CC) $(FIXINC_DEFS) -o $@ $(OBJ) $(LIBERTY)\n \n-## inclhack.sh: inclhack.def inclhack.tpl hackshell.tpl\n-## \tcd $(srcdir) ; $(SHELL) ./genfixes $@\n-## \n-## # fixinc.sh, unlike the other two, has _no_ dependency on the .def file.\n-## fixincl.sh: inclhack.tpl\n-## \tcd $(srcdir) ; $(SHELL) ./genfixes $@\n+$(OBJ)      : $(HDR)\n+fixincl.o   : fixincl.x fixincl.c\n+fixtests.o  : fixtests.c\n+fixfixes.o  : fixfixes.c\n+server.o    : server.c\n+procopen.o  : procopen.c\n+gnu-regex.o : gnu-regex.c\n+fixlib.o    : fixlib.c\n \n-#  This invocation of genfixes is done from the build dir,\n-#  not the source dir (as above)\n+#  'machname.h' is built in the build directory.\n+#  'fixincl.x' in the source dir.\n #\n machname.h: ../specs\n \t$(SHELL) $(srcdir)/genfixes $@\n \n+fixincl.x: fixincl.tpl inclhack.def\n+\tcd $(srcdir) ; $(SHELL) ./genfixes $@\n+\n clean:\n-\trm -f *.o $(TARGETS) fixincl.x machname.h\n+\trm -f *.o $(TARGETS) fixincl.x machname.h *~\n \n-#  Ensure all the targets are built.  If the program \"fixincl\"\n-#  failed to compile, link or load, then we install the\n-#  \"inclhack.sh\" script.  Otherwise, we install that program\n-#  plus the wrapper script, \"fixincl.sh\".\n+#  Build the executable and copy up into gcc dir.\n+#  We still copy the script because we still have alternative scripts.\n #\n-install-bin: fixincl fixincl.sh\n-\t@if [ -f ../fixincl ] ; then rm -f ../fixincl || \\\n-\t    mv -f ../fixincl ../fixincl.$$ || exit 1 ; fi\n-\t@if [ -f ../fixinc.sh ] ; then rm -f ../fixinc.sh || \\\n-\t    mv -f ../fixinc.sh ../fixinc.sh.$$ || exit 1 ; fi\n+install-bin : fixincl\n \t./fixincl -v\n-\tcp fixincl ..\n-\tcp $(srcdir)/fixincl.sh ../fixinc.sh\n-\tchmod 755 ../fixinc.sh ../fixincl\n-\n-install-sh: fixfixes fixtests inclhack.sh\n \t@if [ -f ../fixinc.sh ] ; then rm -f ../fixinc.sh || \\\n \t    mv -f ../fixinc.sh ../fixinc.sh.$$ || exit 1 ; fi\n-\techo Could not install binary fixincludes.  ; \\\n-\techo Installing shell script instead.\n-\t@if [ -f ./inclhack.sh ] ; \\\n-\tthen echo cp ./inclhack.sh ../fixinc.sh ; \\\n-\t\tcp ./inclhack.sh ../fixinc.sh ; \\\n-\telse echo cp $(srcdir)/inclhack.sh ../fixinc.sh ; \\\n-\t\tcp $(srcdir)/inclhack.sh ../fixinc.sh ; fi\n+\t@if [ -f ./fixincl.sh ] ; \\\n+\tthen echo cp ./fixincl.sh ../fixinc.sh ; \\\n+\t\tcp ./fixincl.sh ../fixinc.sh ; \\\n+\telse echo cp $(srcdir)/fixincl.sh ../fixinc.sh ; \\\n+\t\tcp $(srcdir)/fixincl.sh ../fixinc.sh ; fi\n \tchmod 755 ../fixinc.sh\n \n Makefile: Makefile.in ../config.status\n \tcd .. \\\n \t  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= \\\n \t  $(SHELL) ./config.status\n+\n+check : fixincl\n+\tautogen4 -T $(srcdir)/check.tpl $(srcdir)/inclhack.def\n+\t$(SHELL) ./check.sh\n+\t@echo ; echo \"diff of diffs:\"\n+\t@if diff testdir/NEWDIFF $(srcdir)/check.diff ; \\\n+\tthen rm -rf ./testdir ./check.sh ; \\\n+\telse echo ; echo \"Results do not match expectations\" ; echo ; \\\n+\texit 1 ; fi"}, {"sha": "56276a0280c5350562d4132c47da2fc851706b2f", "filename": "gcc/fixinc/check.tpl", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Fcheck.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Fcheck.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fcheck.tpl?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -14,8 +14,9 @@ TARGET_MACHINE='*'\n DESTDIR=`pwd`/res\n SRCDIR=`pwd`/inc\n FIND_BASE='.'\n+VERBOSE=1\n \n-export TARGET_MACHINE DESTDIR SRCDIR FIND_BASE\n+export TARGET_MACHINE DESTDIR SRCDIR FIND_BASE VERBOSE\n \n mkdir ${DESTDIR} ${SRCDIR}\n \n@@ -39,7 +40,6 @@ cat >> inc/[=\n \n \n \t#ifndef [=hackname _up=]_CHECK\n-\t#define [=hackname _up=]_CHECK\n [=test_text \"\\t\" _prefix=]\n \t#endif  /* [=hackname _up=]_CHECK */\n _HACK_EOF_\n@@ -50,11 +50,21 @@ _HACK_EOF_\n =]\n \n cd inc\n-find . -type f | ../../fixincl\n+find . -type f | sed 's;\\./;;' | sort > ../LIST\n+../../fixincl < ../LIST\n cd ..\n-diff -cr inc res | \\\n-  sed -e 's;^\\(\\*\\*\\* inc/[^\t]*\\)\t.*$;\\1;' \\\n-      -e 's;^\\(--- res/[^\t]*\\)\t.*$;\\1;' > NEWDIFF\n+\n+while read f\n+do\n+  if [ ! -f res/$f ]\n+  then\n+    echo \"Only in inc:  inc/$f\"\n+  else\n+    diff -c inc/$f res/$f | \\\n+      sed -e '1,2s;\t.*;;'\n+  fi\n+done > NEWDIFF < LIST\n+\n echo\n echo Test output check:\n [=\n@@ -63,7 +73,7 @@ _FOR fix =][=\n \n   _IF test_text _exist =]\n fgrep [=hackname _up=]_CHECK NEWDIFF > /dev/null 2>&1 || \\\n-  echo \"[=_eval hackname _get \"#%32s test failed.  See inc/\"\n+  echo \"[=_eval hackname _get \"#%32s test failed.  See testdir/inc/\"\n           _printf =][=\n     _IF files _exist =][=\n       files[0] =][="}, {"sha": "04cd328d3f75678b2ac93ae25cee4880c030307c", "filename": "gcc/fixinc/fixfixes.c", "status": "modified", "additions": 92, "deletions": 248, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixfixes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixfixes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixfixes.c?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -72,8 +72,7 @@ typedef struct {\n } fix_entry_t;\n \n #define FIXUP_TABLE \\\n-  _FT_( \"no_double_slash\",  double_slash_fix ) \\\n-  _FT_( \"else_endif_label\", else_endif_label_fix ) \\\n+  _FT_( \"format\",           format_fix ) \\\n   _FT_( \"IO_use\",\t    IO_use_fix ) \\\n   _FT_( \"CTRL_use\",\t    CTRL_use_fix) \\\n   _FT_( \"IO_defn\",\t    IO_defn_fix ) \\\n@@ -82,9 +81,10 @@ typedef struct {\n \n \n #define FIX_PROC_HEAD( fix ) \\\n-static void fix ( filname, text ) \\\n+static void fix ( filname, text, p_fixd ) \\\n     const char* filname; \\\n-    char* text;\n+    char* text; \\\n+    tFixDesc* p_fixd;\n \n \n /*\n@@ -130,233 +130,101 @@ print_quote( q, text )\n }\n \n \n-FIX_PROC_HEAD( double_slash_fix )\n+FIX_PROC_HEAD( format_fix )\n {\n-  /*  Now look for the comment markers in the text */\n-  for (;;)\n-    {\n-      char ch = *(text++);\n-      switch (ch)\n-        {\n-        case '/':\n-          switch (*text) /* do not advance `text' here */\n-            {\n-            case '/':\n-              /*\n-                We found a \"//\" pair in open text.\n-                Delete text to New-Line\n-              */\n-              while ((*text != '\\n') && (*text != '\\0'))  text++;\n-              break;\n-\n-            case '*':\n-              {\n-                /* We found a C-style comment.  Skip forward to the end */\n-                char* pz = strstr( (--text)+2, \"*/\" );\n-                if (pz == (char*)NULL)\n-                  {\n-                    fputs( text, stdout );\n-                    goto fix_done;\n-                  }\n-                pz += 2;\n-                fwrite (text, (pz - text), 1, stdout );\n-                text = pz;\n-              }\n-              break;\n-\n-            default:\n-              fputc (ch, stdout );\n-            }\n-          break;\n-\n-        case NUL:\n-          goto fix_done;\n-\n-        case '\"':\n-        case '\\'':\n-          text = print_quote (ch, text );\n-          break;\n-\n-        default:\n-          fputc (ch, stdout );\n-        }\n-\n-    } fix_done:;\n-\n-  fclose (stdout);;\n-}\n-\n-\n-FIX_PROC_HEAD( else_endif_label_fix )\n-{\n-  static const char label_pat[] = \"^[ \\t]*#[ \\t]*(else|endif)\";\n-  static regex_t label_re;\n-\n-  char ch;\n-  char* pz_next = (char*)NULL;\n-  regmatch_t match[2];\n+    tSCC  zBad[] = \"fixincl error:  `%s' needs %s c_fix_arg\\n\";\n+    tCC*  pz_pat = p_fixd->patch_args[2];\n+    tCC*  pz_fmt = p_fixd->patch_args[1];\n+    const char *p;\n+    regex_t re;\n+    regmatch_t rm[10];\n+\n+    /*\n+     *  We must have a format\n+     */\n+    if (pz_fmt == (tCC*)NULL) {\n+        fprintf( stderr, zBad, p_fixd->fix_name, \"replacement-format\" );\n+        exit( 3 );\n+    }\n \n-  compile_re (label_pat, &label_re, 1,\n-\t      \"label pattern\", \"else_endif_label_fix\");\n+    /*\n+     *  IF we don't have a search text, then go find the first\n+     *  regular expression among the tests.\n+     */\n+    if (pz_pat == (tCC*)NULL) {\n+        tTestDesc* pTD = p_fixd->p_test_desc;\n+        int        ct  = p_fixd->test_ct;\n+        for (;;) {\n+            if (ct-- <= 0) {\n+                fprintf( stderr, zBad, p_fixd->fix_name, \"search-text\" );\n+                exit( 3 );\n+            }\n \n-  for (;;) /* entire file */\n-    {\n-      /*\n-        See if we need to advance to the next candidate directive\n-        If the scanning pointer passes over the end of the directive,\n-        then the directive is inside a comment */\n-      if (pz_next < text)\n-        {\n-          if (regexec (&label_re, text, 2, match, 0) != 0)\n-            {\n-              fputs( text, stdout );\n-              break;\n+            if (pTD->type == TT_EGREP) {\n+                pz_pat = pTD->pz_test_text;\n+                break;\n             }\n \n-          pz_next = text + match[0].rm_eo;\n+            pTD++;\n         }\n+    }\n \n-      /*\n-        IF the scan pointer has not reached the directive end, ... */\n-      if (pz_next > text)\n-        {\n-          /*\n-            Advance the scanning pointer.  If we are at the start\n-            of a quoted string or a comment, then skip the entire unit */\n-          ch = *text;\n-\n-          switch (ch)\n-            {\n-            case '/':\n-              /*\n-                Skip comments */\n-              if (text[1] == '*')\n-                {\n-                  char* pz = strstr( text+2, \"*/\" );\n-                  if (pz == (char*)NULL)\n-                    {\n-                      fputs( text, stdout );\n-                      return;\n-                    }\n-                  pz += 2;\n-                  fwrite( text, 1, (pz - text), stdout );\n-                  text = pz;\n-                  continue;\n-                }\n-              putc( ch, stdout );\n-              text++;\n-              break;\n-\n-            case '\"':\n-            case '\\'':\n-              text = print_quote( ch, text+1 );\n-              break;\n-\n-            default:\n-              putc( ch, stdout );\n-              text++;\n-            } /* switch (ch) */\n-          continue;\n-        } /* if (still shy of directive end) */\n-\n-      /*\n-         The scanning pointer (text) has reached the end of the current\n-         directive under test.  Check for bogons here.  */\n-      for (;;) /* bogon check */\n-        {\n-          char ch = *(text++);\n-          if (isspace (ch))\n-            {\n-              putc( ch, stdout );\n-              if (ch == '\\n')\n-                {\n-                  /*\n-                    It is clean.  No bogons on this directive */\n-                  pz_next = (char*)NULL; /* force a new regex search */\n-                  goto dont_fix_bogon;\n-                }\n-              continue;\n-            }\n-\n-          switch (ch)\n-            {\n-            case NUL:\n-              return;\n-\n-            case '\\\\':\n-              /*\n-                Skip escaped newlines.  Otherwise, we have a bogon */\n-              if (*text != '\\n') {\n-                text--;\n-                goto fix_the_bogon;\n-              }\n-\n-              /*\n-                Emit the escaped newline and keep scanning for possible junk */\n-              putc( '\\\\', stdout );\n-              putc( '\\n', stdout );\n-              text++;\n-              break;\n-\n-            case '/':\n-              /*\n-                Skip comments.  Otherwise, we have a bogon */\n-              if (*text == '*')\n-                {\n-                  text--;\n-                  pz_next = strstr( text+2, \"*/\" );\n-                  if (pz_next == (char*)NULL)\n-                    {\n-                      putc( '\\n', stdout );\n-                      return;\n-                    }\n-                  pz_next += 2;\n-                  fwrite( text, 1, (pz_next - text), stdout );\n-                  text = pz_next;\n-                  break;\n-                }\n-\n-              /* FALLTHROUGH */\n-\n-            default:\n-              /*\n-                GOTTA BE A BOGON */\n-              text--;\n-              goto fix_the_bogon;\n-            } /* switch (ch) */\n-        } /* for (bogon check loop) */\n-\n-    fix_the_bogon:\n-      /*\n-        `text' points to the start of the bogus data */\n-      for (;;)\n-        {\n-          /*\n-            NOT an escaped newline.  Find the end of line that\n-            is not preceeded by an escape character:  */\n-          pz_next = strchr( text, '\\n' );\n-          if (pz_next == (char*)NULL)\n-            {\n-              putc( '\\n', stdout );\n-              return;\n+    /*\n+     *  Replace every copy of the text we find\n+     */\n+    compile_re (pz_pat, &re, 1, \"format search-text\", \"format_fix\" );\n+    while (regexec (&re, text, 10, rm, 0) == 0)\n+    {\n+        char* apz[10];\n+        int   i;\n+\n+        /*\n+         *  Write the text up to the match\n+         */\n+        fwrite( text, rm[0].rm_so, 1, stdout );\n+\n+        /*\n+         *  Copy all the submatches into separate strings\n+         */\n+        for (i=0; i<10; i++) {\n+            if (rm[i].rm_so == -1) {\n+                apz[i] = (char*)NULL;\n+                break;\n             }\n-\n-          if (pz_next[-1] != '\\\\')\n             {\n-              text = pz_next;\n-              pz_next = (char*)NULL; /* force a new regex search */\n-              break;\n+                int len = rm[i].rm_eo - rm[i].rm_so;\n+                apz[i] = (char*)malloc( len + 1 );\n+                memcpy( (void*)apz[i], text+rm[i].rm_so, len );\n+                apz[i][len] = NUL;\n             }\n+        }\n \n-          /*\n-            The newline was escaped.  We gotta keep going.  */\n-          text = pz_next + 1;\n+        /*\n+         *  IF there are any submatches,\n+         *  THEN only use the submatches in the formatting\n+         */\n+        if (apz[1] != (char*)NULL)\n+            printf( pz_fmt, apz[1], apz[2], apz[3], apz[4],\n+                    apz[5], apz[6], apz[7], apz[8], apz[9] );\n+        else\n+            printf( pz_fmt, apz[0] );\n+\n+        /*\n+         *  Free our submatch strings\n+         */\n+        for (i=0; i<10; i++) {\n+            if (apz[i] == (char*)NULL)\n+                break;\n+            free( (void*)apz[i] );\n         }\n \n-    dont_fix_bogon:;\n-    } /* for (entire file) loop */\n+        text += rm[0].rm_eo;\n+    }\n \n-  return;\n+    /*\n+     *  Dump out the rest of the file\n+     */\n+    fputs (text, stdout);\n }\n \n /* Scan the input file for all occurrences of text like this:\n@@ -370,7 +238,7 @@ FIX_PROC_HEAD( else_endif_label_fix )\n    which is the required syntax per the C standard.  (The definition of\n    _IO also has to be tweaked - see below.)  'IO' is actually whatever you\n    provide in the STR argument.  */\n-void\n+static void\n fix_char_macro_uses (text, str)\n      const char *text;\n      const char *str;\n@@ -448,7 +316,7 @@ fix_char_macro_uses (text, str)\n    which is the required syntax per the C standard.  (The uses of _IO\n    also have to be tweaked - see above.)  'IO' is actually whatever\n    you provide in the STR argument.  */\n-void\n+static void\n fix_char_macro_defines (text, str)\n      const char *text;\n      const char *str;\n@@ -660,15 +528,16 @@ FIX_PROC_HEAD( machine_name_fix )\n \n */\n void\n-apply_fix( fixname, filname )\n-  const char* fixname;\n-  const char* filname;\n+apply_fix( p_fixd, filname )\n+  tFixDesc* p_fixd;\n+  tCC* filname;\n {\n #define _FT_(n,p) { n, p },\n   static fix_entry_t fix_table[] = { FIXUP_TABLE { NULL, NULL }};\n #undef _FT_\n #define FIX_TABLE_CT ((sizeof(fix_table)/sizeof(fix_table[0]))-1)\n \n+  tCC* fixname = p_fixd->patch_args[0];\n   char* buf;\n   int ct = FIX_TABLE_CT;\n   fix_entry_t* pfe = fix_table;\n@@ -687,30 +556,5 @@ apply_fix( fixname, filname )\n     }\n \n   buf = load_file_data (stdin);\n-  (*pfe->fix_proc)( filname, buf );\n+  (*pfe->fix_proc)( filname, buf, p_fixd );\n }\n-\n-#ifdef MAIN\n-\n-/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n-\n-     MAIN ROUTINE\n-\n-     This file is both included in fixincl.c and compiled as a separate\n-     program for use by the inclhack.sh script.\n-\n-*/\n-\n-int\n-main( argc, argv )\n-  int argc;\n-  char** argv;\n-{\n-  if (argc != 3)\n-    apply_fix (\"No test name provided\", NULL, NULL, 0 );\n-\n-  apply_fix (argv[2], argv[1]);\n-  return 0;\n-}\n-\n-#endif"}, {"sha": "9c39735838668b25ced222053271abce890c4b30", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 50, "deletions": 100, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -38,61 +38,6 @@ Boston, MA 02111-1307, USA.  */\n \n static const char program_id[] = \"fixincl version 1.1\";\n \n-/*  Test Descriptor\n-\n-    Each fix may have associated tests that determine\n-    whether the fix needs to be applied or not.\n-    Each test has a type (from the te_test_type enumeration);\n-    associated test text; and, if the test is TT_EGREP or\n-    the negated form TT_NEGREP, a pointer to the compiled\n-    version of the text string.\n-\n-    */\n-typedef enum\n-{\n-  TT_TEST, TT_EGREP, TT_NEGREP, TT_FUNCTION\n-} te_test_type;\n-\n-typedef struct test_desc tTestDesc;\n-\n-struct test_desc\n-{\n-  te_test_type type;\n-  const char *pz_test_text;\n-  regex_t *p_test_regex;\n-};\n-\n-typedef struct patch_desc tPatchDesc;\n-\n-/*  Fix Descriptor\n-\n-    Everything you ever wanted to know about how to apply\n-    a particular fix (which files, how to qualify them,\n-    how to actually make the fix, etc...)\n-\n-    NB:  the FD_ defines are BIT FLAGS\n-\n-    */\n-#define FD_MACH_ONLY      0x0000\n-#define FD_MACH_IFNOT     0x0001\n-#define FD_SHELL_SCRIPT   0x0002\n-#define FD_SUBROUTINE     0x0004\n-#define FD_REPLACEMENT    0x0008\n-#define FD_SKIP_TEST      0x8000\n-\n-typedef struct fix_desc tFixDesc;\n-struct fix_desc\n-{\n-  const char*   fix_name;       /* Name of the fix */\n-  const char*   file_list;      /* List of files it applies to */\n-  const char**  papz_machs;     /* List of machine/os-es it applies to */\n-  regex_t*      unused;\n-  int           test_ct;\n-  int           fd_flags;\n-  tTestDesc*    p_test_desc;\n-  const char**  patch_args;\n-};\n-\n /*  Working environment strings.  Essentially, invocation 'options'.  */\n char *pz_dest_dir = NULL;\n char *pz_src_dir = NULL;\n@@ -145,14 +90,12 @@ void do_version ();\n char *load_file  _P_((const char *));\n void process  _P_((char *, const char *));\n void run_compiles ();\n-void initialize ();\n+void initialize _P_((int argc,char** argv));\n void process ();\n \n /*  External Source Code */\n \n #include \"fixincl.x\"\n-#include \"fixtests.c\"\n-#include \"fixfixes.c\"\n \n /* * * * * * * * * * * * * * * * * * *\n  *\n@@ -165,28 +108,7 @@ main (argc, argv)\n {\n   char *file_name_buf;\n \n-  switch (argc)\n-    {\n-    case 1:\n-      break;\n-\n-    case 2:\n-      if (strcmp (argv[1], \"-v\") == 0)\n-        do_version ();\n-      if (freopen (argv[1], \"r\", stdin) == (FILE*)NULL)\n-        {\n-          fprintf (stderr, \"Error %d (%s) reopening %s as stdin\\n\",\n-                   errno, xstrerror (errno), argv[1] );\n-          exit (EXIT_FAILURE);\n-        }\n-      break;\n-\n-    default:\n-      fputs (\"fixincl ERROR:  too many command line arguments\\n\", stderr);\n-      exit (EXIT_FAILURE);\n-    }\n-\n-  initialize ();\n+  initialize ( argc, argv );\n \n   have_tty = isatty (fileno (stderr));\n \n@@ -264,8 +186,8 @@ do_version ()\n \n   /* The 'version' option is really used to test that:\n      1.  The program loads correctly (no missing libraries)\n-     2.  we can correctly run our server shell process\n-     3.  that we can compile all the regular expressions.\n+     2.  that we can compile all the regular expressions.\n+     3.  we can correctly run our server shell process\n   */\n   run_compiles ();\n   sprintf (zBuf, zFmt, program_id);\n@@ -276,12 +198,35 @@ do_version ()\n /* * * * * * * * * * * * */\n \n void\n-initialize ()\n+initialize ( argc, argv )\n+  int argc;\n+  char** argv;\n {\n   static const char var_not_found[] =\n     \"fixincl ERROR:  %s environment variable not defined\\n\\\n \\tTARGET_MACHINE, DESTDIR, SRCDIR and FIND_BASE are required\\n\";\n \n+  switch (argc)\n+    {\n+    case 1:\n+      break;\n+\n+    case 2:\n+      if (strcmp (argv[1], \"-v\") == 0)\n+        do_version ();\n+      if (freopen (argv[1], \"r\", stdin) == (FILE*)NULL)\n+        {\n+          fprintf (stderr, \"Error %d (%s) reopening %s as stdin\\n\",\n+                   errno, xstrerror (errno), argv[1] );\n+          exit (EXIT_FAILURE);\n+        }\n+      break;\n+\n+    default:\n+      fputs (\"fixincl ERROR:  too many command line arguments\\n\", stderr);\n+      exit (EXIT_FAILURE);\n+    }\n+\n   {\n     static const char var[] = \"TARGET_MACHINE\";\n     pz_machine = getenv (var);\n@@ -368,7 +313,9 @@ initialize ()\n   run_compiles ();\n \n   signal (SIGQUIT, SIG_IGN);\n+#ifdef SIGIOT\n   signal (SIGIOT,  SIG_IGN);\n+#endif\n   signal (SIGPIPE, SIG_IGN);\n   signal (SIGALRM, SIG_IGN);\n   signal (SIGTERM, SIG_IGN);\n@@ -438,7 +385,6 @@ run_compiles ()\n   int fix_ct = FIX_COUNT;\n   tTestDesc *p_test;\n   int test_ct;\n-  int re_ct = REGEX_COUNT;\n   const char *pz_err;\n   regex_t *p_re = (regex_t *) malloc (REGEX_COUNT * sizeof (regex_t));\n \n@@ -455,7 +401,12 @@ run_compiles ()\n   memset ( (void*)&incl_quote_re, '\\0', sizeof (regex_t) );\n \n   compile_re (incl_quote_pat, &incl_quote_re, 1,\n-\t      \"quoted include\", \"run_compiles\");\n+              \"quoted include\", \"run_compiles\");\n+\n+  /*  Allow machine name tests to be ignored (testing, mainly) */\n+\n+  if ((*pz_machine == '\\0') || (*pz_machine == '*'))\n+    pz_machine = (char*)NULL;\n \n   /* FOR every fixup, ...  */\n   do\n@@ -544,20 +495,21 @@ run_compiles ()\n             {\n             case TT_EGREP:\n             case TT_NEGREP:\n-              /*  You might consider putting the following under #ifdef.\n-                  The number of re's used is computed by autogen.\n-                  So, it is static and known at compile time.  */\n-\n-              if (--re_ct < 0)\n-                {\n-                  fputs (\"out of RE's\\n\", stderr);\n-                  exit (EXIT_FAILURE);\n-                }\n+#ifdef DEBUG\n+              {\n+                static int re_ct = REGEX_COUNT;\n \n+                if (--re_ct < 0)\n+                  {\n+                    fputs (\"out of RE's\\n\", stderr);\n+                    exit (EXIT_FAILURE);\n+                  }\n+              }\n+#endif\n               p_test->p_test_regex = p_re++;\n-\t      compile_re (p_test->pz_test_text, p_test->p_test_regex, 0,\n-\t\t\t  \"select test\", p_fixd->fix_name);\n-\t    }\n+              compile_re (p_test->pz_test_text, p_test->p_test_regex, 0,\n+                          \"select test\", p_fixd->fix_name);\n+            }\n           p_test++;\n         }\n     }\n@@ -890,10 +842,8 @@ internal_fix (read_fd, p_fixd)\n    */\n   fcntl (fd[1], F_DUPFD, STDOUT_FILENO);\n   fcntl (read_fd, F_DUPFD, STDIN_FILENO);\n-  fdopen (STDIN_FILENO, \"r\");\n-  fdopen (STDOUT_FILENO, \"w\");\n \n-  apply_fix (p_fixd->patch_args[0], pz_curr_file);\n+  apply_fix (p_fixd, pz_curr_file);\n   exit (0);\n }\n "}, {"sha": "287e62137b8412127d9182b3d5e9767e64045591", "filename": "gcc/fixinc/fixincl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixincl.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixincl.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.sh?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -95,7 +95,7 @@ esac\n \n # Original directory.\n ORIGDIR=`${PWDCMD}`\n-FIXINCL=${ORIGDIR}/fixincl\n+FIXINCL=${ORIGDIR}/fixinc/fixincl\n export FIXINCL\n \n # Make LIB absolute only if needed to avoid problems with the amd."}, {"sha": "fc5a4421dcd9d7152a16266a6ad27014e3732946", "filename": "gcc/fixinc/fixincl.tpl", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixincl.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixincl.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.tpl?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -158,7 +158,13 @@ const char* apz[=hackname _cap=]Patch[] = {[=\n     _ELIF shell       _exist =] \"sh\", \"-c\",\n     [=shell _krstr=],[=\n \n-    _ELIF c_fix _exist =]\"[=c_fix=]\",[=\n+    _ELIF c_fix _exist =]\n+    [=\n+      c_fix _krstr=],[=\n+\n+      _FOR c_fix_arg =]\n+    [=c_fix_arg _krstr=],[=\n+      /c_fix_arg =][=\n \n     _ELIF replace _len =]\n [=replace _krstr=],[=\n@@ -184,7 +190,7 @@ tFixDesc fixDescList[ FIX_COUNT ] = {[=\n \n _FOR fix \",\\n\" =]\n   {  z[=hackname _cap=]Name,    z[=hackname _cap=]List,\n-     apz[=hackname _cap=]Machs, (regex_t*)NULL,\n+     apz[=hackname _cap=]Machs,\n      [=hackname  _up=]_TEST_CT, [=\n        _IF not_machine _exist =]FD_MACH_IFNOT[=\n        _ELSE                  =]FD_MACH_ONLY[="}, {"sha": "d28aed6766817b59cf57b85b9255f166146b24c0", "filename": "gcc/fixinc/fixlib.h", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixlib.h?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -93,13 +93,72 @@ typedef int apply_fix_p_t;  /* Apply Fix Predicate Type */\n #define _P_(p)\t()\n #endif\n \n+/*  Test Descriptor\n+\n+    Each fix may have associated tests that determine\n+    whether the fix needs to be applied or not.\n+    Each test has a type (from the te_test_type enumeration);\n+    associated test text; and, if the test is TT_EGREP or\n+    the negated form TT_NEGREP, a pointer to the compiled\n+    version of the text string.\n+\n+    */\n+typedef enum\n+{\n+  TT_TEST, TT_EGREP, TT_NEGREP, TT_FUNCTION\n+} te_test_type;\n+\n+typedef struct test_desc tTestDesc;\n+\n+struct test_desc\n+{\n+  te_test_type type;\n+  const char *pz_test_text;\n+  regex_t *p_test_regex;\n+};\n+\n+typedef struct patch_desc tPatchDesc;\n+\n+/*  Fix Descriptor\n+\n+    Everything you ever wanted to know about how to apply\n+    a particular fix (which files, how to qualify them,\n+    how to actually make the fix, etc...)\n+\n+    NB:  the FD_ defines are BIT FLAGS\n+\n+    */\n+#define FD_MACH_ONLY      0x0000\n+#define FD_MACH_IFNOT     0x0001\n+#define FD_SHELL_SCRIPT   0x0002\n+#define FD_SUBROUTINE     0x0004\n+#define FD_REPLACEMENT    0x0008\n+#define FD_SKIP_TEST      0x8000\n+\n+typedef struct fix_desc tFixDesc;\n+struct fix_desc\n+{\n+  const char*   fix_name;       /* Name of the fix */\n+  const char*   file_list;      /* List of files it applies to */\n+  const char**  papz_machs;     /* List of machine/os-es it applies to */\n+  int           test_ct;\n+  int           fd_flags;\n+  tTestDesc*    p_test_desc;\n+  const char**  patch_args;\n+  long          unused;\n+};\n+\n /*\n  *  Exported procedures\n  */\n char * load_file_data _P_(( FILE* fp ));\n t_bool is_cxx_header  _P_(( tCC* filename, tCC* filetext ));\n void   compile_re     _P_(( tCC* pat, regex_t* re, int match,\n \t\t\t    tCC *e1, tCC *e2 ));\n+\n+void apply_fix _P_(( tFixDesc* p_fixd, tCC* filname ));\n+apply_fix_p_t run_test _P_((tCC* t_name, tCC* f_name, tCC* text ));\n+\n #ifdef MN_NAME_PAT\n void   mn_get_regexps _P_(( regex_t** label_re, regex_t** name_re,\n \t\t\t    tCC *who ));"}, {"sha": "8e8567a1cccd253e604a5fe442b63597451a576d", "filename": "gcc/fixinc/fixtests.c", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixtests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dfe41582cd24b566f56060ec3808a04a9a6909/gcc%2Ffixinc%2Ffixtests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixtests.c?ref=35dfe41582cd24b566f56060ec3808a04a9a6909", "patch": "@@ -73,7 +73,7 @@ static apply_fix_p_t test ( fname, text ) \\\n  *  a backslash.  Especially a backslash followed by octal digits.\n  *  We are not doing a correctness syntax check here.\n  */\n-tSCC*\n+static tSCC*\n skip_quote( q, text )\n   char  q;\n   char* text;\n@@ -351,36 +351,3 @@ run_test( tname, fname, text )\n            tname );\n   exit( 3 );\n }\n-\n-/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n-\n-     MAIN ROUTINE\n-\n-     This file is both included in fixincl.c and compiled as a separate\n-     program for use by the inclhack.sh script.\n-\n-*/\n-\n-#ifdef MAIN\n-\n-int\n-main( argc, argv )\n-  int argc;\n-  char** argv;\n-{\n-  char* fname = *++argv;\n-  char* tname = *++argv;\n-  char* buf;\n-\n-  if (argc != 3)\n-    return run_test( \"No test name provided\", NULL, NULL, 0 );\n-\n-  fclose( stdin );\n-  fclose( stdout );\n-\n-  buf = load_file_data (fopen (fname, \"r\"));\n-\n-  return run_test( tname, fname, buf );\n-}\n-\n-#endif"}]}