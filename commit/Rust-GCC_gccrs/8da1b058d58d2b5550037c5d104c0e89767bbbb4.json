{"sha": "8da1b058d58d2b5550037c5d104c0e89767bbbb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRhMWIwNThkNThkMmI1NTUwMDM3YzVkMTA0YzBlODk3NjdiYmJiNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-13T20:29:23Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-13T20:29:23Z"}, "message": "Initial revision\n\nFrom-SVN: r181", "tree": {"sha": "afec33a814b46eb33b5c988cd466f85500b2129a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afec33a814b46eb33b5c988cd466f85500b2129a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8da1b058d58d2b5550037c5d104c0e89767bbbb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da1b058d58d2b5550037c5d104c0e89767bbbb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da1b058d58d2b5550037c5d104c0e89767bbbb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da1b058d58d2b5550037c5d104c0e89767bbbb4/comments", "author": null, "committer": null, "parents": [{"sha": "348fd37cfc0d97803eee85b797c50d8a40afbb81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348fd37cfc0d97803eee85b797c50d8a40afbb81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348fd37cfc0d97803eee85b797c50d8a40afbb81"}], "stats": {"total": 1255, "additions": 1255, "deletions": 0}, "files": [{"sha": "909a7b3b49fe1c1e3f4bd2f58d777e5310af5bb2", "filename": "gcc/tree.h", "status": "added", "additions": 1255, "deletions": 0, "changes": 1255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da1b058d58d2b5550037c5d104c0e89767bbbb4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da1b058d58d2b5550037c5d104c0e89767bbbb4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8da1b058d58d2b5550037c5d104c0e89767bbbb4", "patch": "@@ -0,0 +1,1255 @@\n+/* Front-end tree definitions for GNU compiler.\n+   Copyright (C) 1989 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"machmode.h\"\n+\n+/* codes of tree nodes */\n+\n+#define DEFTREECODE(SYM, STRING, TYPE, NARGS)   SYM,\n+\n+enum tree_code {\n+#include \"tree.def\"\n+\n+  LAST_AND_UNUSED_TREE_CODE\t/* A convienent way to get a value for\n+\t\t\t\t   NUM_TREE_CODE.  */\n+};\n+\n+#undef DEFTREECODE\n+\n+/* Number of tree codes.  */\n+#define NUM_TREE_CODES ((int)LAST_AND_UNUSED_TREE_CODE)\n+\n+/* Indexed by enum tree_code, contains a character which is\n+   `<' for a comparison expression, `1', for a unary arithmetic\n+   expression, `2' for a binary arithmetic expression, `e' for\n+   other types of expressions, `r' for a reference, `c' for a\n+   constant, `d' for a decl, `t' for a type, `s' for a statement,\n+   and `x' for anything else (TREE_LIST, IDENTIFIER, etc).  */\n+\n+extern char **tree_code_type;\n+#define TREE_CODE_CLASS(CODE)\t(*tree_code_type[(int) (CODE)])\n+\n+/* Number of argument-words in each kind of tree-node.  */\n+\n+extern int *tree_code_length;\n+\n+/* Names of tree components.  */\n+\n+extern char **tree_code_name;\n+\f\n+/* Codes that identify the various built in functions\n+   so that expand_call can identify them quickly.  */\n+\n+enum built_in_function\n+{\n+  NOT_BUILT_IN,\n+  BUILT_IN_ALLOCA,\n+  BUILT_IN_ABS,\n+  BUILT_IN_FABS,\n+  BUILT_IN_LABS,\n+  BUILT_IN_FFS,\n+  BUILT_IN_DIV,\n+  BUILT_IN_LDIV,\n+  BUILT_IN_FFLOOR,\n+  BUILT_IN_FCEIL,\n+  BUILT_IN_FMOD,\n+  BUILT_IN_FREM,\n+  BUILT_IN_MEMCPY,\n+  BUILT_IN_MEMCMP,\n+  BUILT_IN_MEMSET,\n+  BUILT_IN_STRCPY,\n+  BUILT_IN_STRCMP,\n+  BUILT_IN_STRLEN,\n+  BUILT_IN_FSQRT,\n+  BUILT_IN_GETEXP,\n+  BUILT_IN_GETMAN,\n+  BUILT_IN_SAVEREGS,\n+  BUILT_IN_CLASSIFY_TYPE,\n+  BUILT_IN_NEXT_ARG,\n+  BUILT_IN_ARGS_INFO,\n+  BUILT_IN_CONSTANT_P,\n+  BUILT_IN_FRAME_ADDRESS,\n+  BUILT_IN_RETURN_ADDRESS,\n+  BUILT_IN_CALLER_RETURN_ADDRESS,\n+\n+  /* C++ extensions */\n+  BUILT_IN_NEW,\n+  BUILT_IN_VEC_NEW,\n+  BUILT_IN_DELETE,\n+  BUILT_IN_VEC_DELETE\n+};\n+\f\n+/* The definition of tree nodes fills the next several pages.  */\n+\n+/* A tree node can represent a data type, a variable, an expression\n+   or a statement.  Each node has a TREE_CODE which says what kind of\n+   thing it represents.  Some common codes are:\n+   INTEGER_TYPE -- represents a type of integers.\n+   ARRAY_TYPE -- represents a type of pointer.\n+   VAR_DECL -- represents a declared variable.\n+   INTEGER_CST -- represents a constant integer value.\n+   PLUS_EXPR -- represents a sum (an expression).\n+\n+   As for the contents of a tree node: there are some fields\n+   that all nodes share.  Each TREE_CODE has various special-purpose\n+   fields as well.  The fields of a node are never accessed directly,\n+   always through accessor macros.  */\n+\n+/* This type is used everywhere to refer to a tree node.  */\n+\n+typedef union tree_node *tree;\n+\n+#define NULL_TREE (tree) NULL\n+\n+/* Every kind of tree node starts with this structure,\n+   so all nodes have these fields.\n+\n+   See the accessor macros, defined below, for documentation of the fields.  */\n+\n+struct tree_common\n+{\n+  union tree_node *chain;\n+  union tree_node *type;\n+#ifdef ONLY_INT_FIELDS\n+  unsigned int code : 8;\n+#else\n+  enum tree_code code : 8;\n+#endif\n+\n+  unsigned side_effects_flag : 1;\n+  unsigned constant_flag : 1;\n+  unsigned permanent_flag : 1;\n+  unsigned addressable_flag : 1;\n+  unsigned volatile_flag : 1;\n+  unsigned readonly_flag : 1;\n+  unsigned unsigned_flag : 1;\n+  unsigned asm_written_flag: 1;\n+\n+  unsigned used_flag : 1;\n+  unsigned raises_flag : 1;\n+  unsigned static_flag : 1;\n+  unsigned public_flag : 1;\n+  unsigned private_flag : 1;\n+  unsigned protected_flag : 1;\n+\n+  unsigned lang_flag_0 : 1;\n+  unsigned lang_flag_1 : 1;\n+  unsigned lang_flag_2 : 1;\n+  unsigned lang_flag_3 : 1;\n+  unsigned lang_flag_4 : 1;\n+  unsigned lang_flag_5 : 1;\n+  unsigned lang_flag_6 : 1;\n+  /* There is room for two more flags.  */\n+};\n+\n+/* Define accessors for the fields that all tree nodes have\n+   (though some fields are not used for all kinds of nodes).  */\n+\n+/* The tree-code says what kind of node it is.\n+   Codes are defined in tree.def.  */\n+#define TREE_CODE(NODE) ((enum tree_code) (NODE)->common.code)\n+#define TREE_SET_CODE(NODE, VALUE) ((NODE)->common.code = (int) (VALUE))\n+\n+/* In all nodes that are expressions, this is the data type of the expression.\n+   In POINTER_TYPE nodes, this is the type that the pointer points to.\n+   In ARRAY_TYPE nodes, this is the type of the elements.  */\n+#define TREE_TYPE(NODE) ((NODE)->common.type)\n+\n+/* Nodes are chained together for many purposes.\n+   Types are chained together to record them for being output to the debugger\n+   (see the function `chain_type').\n+   Decls in the same scope are chained together to record the contents\n+   of the scope.\n+   Statement nodes for successive statements used to be chained together.\n+   Often lists of things are represented by TREE_LIST nodes that\n+   are chained together.  */\n+\n+#define TREE_CHAIN(NODE) ((NODE)->common.chain)\n+\n+/* Given an expression as a tree, strip any NON_LVALUE_EXPRs and NOP_EXPRs\n+   that don't change the machine mode.  */\n+\n+#define STRIP_NOPS(EXP) \\\n+  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\\\n+\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\\\n+\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n+\t && (TYPE_MODE (TREE_TYPE (EXP))\t\t\t\\\n+\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0)))))\t\\\n+    (EXP) = TREE_OPERAND (EXP, 0);\n+\f\n+/* Define many boolean fields that all tree nodes have.  */\n+\n+/* In VAR_DECL nodes, nonzero means address of this is needed.\n+   So it cannot be in a register.\n+   In a FUNCTION_DECL, nonzero means its address is needed.\n+   So it must be compiled even if it is an inline function.\n+   In CONSTRUCTOR nodes, it means object constructed must be in memory.\n+   In LABEL_DECL nodes, it means a goto for this label has been seen \n+   from a place outside all binding contours that restore stack levels.\n+   In ..._TYPE nodes, it means that objects of this type must\n+   be fully addressable.  This means that pieces of this\n+   object cannot go into register parameters, for example.\n+   In IDENTIFIER_NODEs, this means that some extern decl for this name\n+   had its address taken.  That matters for inline functions.  */\n+#define TREE_ADDRESSABLE(NODE) ((NODE)->common.addressable_flag)\n+\n+/* In a VAR_DECL, nonzero means allocate static storage.\n+   In a FUNCTION_DECL, currently nonzero if function has been defined.\n+   In a CONSTRUCTOR, nonzero means allocate static storage.  */\n+#define TREE_STATIC(NODE) ((NODE)->common.static_flag)\n+\n+/* In a CONVERT_EXPR or NOP_EXPR, this means the node was made\n+   implicitly and should not lead to an \"unused value\" warning.  */\n+#define TREE_NO_UNUSED_WARNING(NODE) ((NODE)->common.static_flag)\n+\n+/* Nonzero for a TREE_LIST or TREE_VEC node means that the derivation\n+   chain is via a `virtual' declaration.  */\n+#define TREE_VIA_VIRTUAL(NODE) ((NODE)->common.static_flag)\n+\n+/* In a VAR_DECL or FUNCTION_DECL,\n+   nonzero means name is to be accessible from outside this module.\n+   In an identifier node, nonzero means a external declaration\n+   accesible from outside this module was previously seen\n+   for this name in an inner scope.  */\n+#define TREE_PUBLIC(NODE) ((NODE)->common.public_flag)\n+\n+/* Nonzero for TREE_LIST or TREE_VEC node means that the path to the\n+   base class is via a `public' declaration, which preserves public\n+   fields from the base class as public.  */\n+#define TREE_VIA_PUBLIC(NODE) ((NODE)->common.public_flag)\n+\n+/* In any expression, nonzero means it has side effects or reevaluation\n+   of the whole expression could produce a different value.\n+   This is set if any subexpression is a function call, a side effect\n+   or a reference to a volatile variable.\n+   In a ..._DECL, this is set only if the declaration said `volatile'.  */\n+#define TREE_SIDE_EFFECTS(NODE) ((NODE)->common.side_effects_flag)\n+\n+/* Nonzero means this expression is volatile in the C sense:\n+   its address should be of type `volatile WHATEVER *'.\n+   In other words, the declared item is volatile qualified.\n+   This is used in _DECL nodes and _REF nodes.\n+\n+   In a ..._TYPE node, means this type is volatile-qualified.\n+   But use TYPE_VOLATILE instead of this macro when the node is a type,\n+   because eventually we may make that a different bit.\n+\n+   If this bit is set in an expression, so is TREE_SIDE_EFFECTS.  */\n+#define TREE_THIS_VOLATILE(NODE) ((NODE)->common.volatile_flag)\n+\n+/* In a VAR_DECL, PARM_DECL or FIELD_DECL, or any kind of ..._REF node,\n+   nonzero means it may not be the lhs of an assignment.\n+   In a ..._TYPE node, means this type is const-qualified\n+   (but the macro TYPE_READONLY should be used instead of this macro\n+   when the node is a type).  */\n+#define TREE_READONLY(NODE) ((NODE)->common.readonly_flag)\n+\n+/* Value of expression is constant.\n+   Always appears in all ..._CST nodes.\n+   May also appear in an arithmetic expression, an ADDR_EXPR or a CONSTRUCTOR\n+   if the value is constant.  */\n+#define TREE_CONSTANT(NODE) ((NODE)->common.constant_flag)\n+\n+/* Nonzero means permanent node;\n+   node will continue to exist for the entire compiler run.\n+   Otherwise it will be recycled at the end of the function.  */\n+#define TREE_PERMANENT(NODE) ((NODE)->common.permanent_flag)\n+\n+/* In INTEGER_TYPE or ENUMERAL_TYPE nodes, means an unsigned type.\n+   In FIELD_DECL nodes, means an unsigned bit field.\n+   The same bit is used in functions as DECL_BUILT_IN_NONANSI.  */\n+#define TREE_UNSIGNED(NODE) ((NODE)->common.unsigned_flag)\n+\n+/* Nonzero in a VAR_DECL means assembler code has been written.\n+   Nonzero in a FUNCTION_DECL means that the function has been compiled.\n+   This is interesting in an inline function, since it might not need\n+   to be compiled separately.\n+   Nonzero in a RECORD_TYPE, UNION_TYPE or ENUMERAL_TYPE\n+   if the sdb debugging info for the type has been written.  */\n+#define TREE_ASM_WRITTEN(NODE) ((NODE)->common.asm_written_flag)\n+\n+/* Nonzero in a _DECL if the name is used in its scope.\n+   Nonzero in an expr node means inhibit warning if value is unused.\n+   In IDENTIFIER_NODEs, this means that some extern decl for this name\n+   was used.  */\n+#define TREE_USED(NODE) ((NODE)->common.used_flag)\n+\n+/* Nonzero for a tree node whose evaluation could result\n+   in the raising of an exception.  Not implemented yet.  */\n+#define TREE_RAISES(NODE) ((NODE)->common.raises_flag)\n+\n+/* These are currently used in classes in C++.  */\n+#define TREE_PRIVATE(NODE) ((NODE)->common.private_flag)\n+#define TREE_PROTECTED(NODE) ((NODE)->common.protected_flag)\n+\n+#define TREE_LANG_FLAG_0(NODE) ((NODE)->common.lang_flag_0)\n+#define TREE_LANG_FLAG_1(NODE) ((NODE)->common.lang_flag_1)\n+#define TREE_LANG_FLAG_2(NODE) ((NODE)->common.lang_flag_2)\n+#define TREE_LANG_FLAG_3(NODE) ((NODE)->common.lang_flag_3)\n+#define TREE_LANG_FLAG_4(NODE) ((NODE)->common.lang_flag_4)\n+#define TREE_LANG_FLAG_5(NODE) ((NODE)->common.lang_flag_5)\n+#define TREE_LANG_FLAG_6(NODE) ((NODE)->common.lang_flag_6)\n+\f\n+/* Define additional fields and accessors for nodes representing constants.  */\n+\n+/* In an INTEGER_CST node.  These two together make a 64 bit integer.\n+   If the data type is signed, the value is sign-extended to 64 bits\n+   even though not all of them may really be in use.\n+   In an unsigned constant shorter than 64 bits, the extra bits are 0.  */\n+#define TREE_INT_CST_LOW(NODE) ((NODE)->int_cst.int_cst_low)\n+#define TREE_INT_CST_HIGH(NODE) ((NODE)->int_cst.int_cst_high)\n+\n+#define INT_CST_LT(A, B)  \\\n+(TREE_INT_CST_HIGH (A) < TREE_INT_CST_HIGH (B)\t\t\t\\\n+ || (TREE_INT_CST_HIGH (A) == TREE_INT_CST_HIGH (B)\t\t\\\n+     && ((unsigned) TREE_INT_CST_LOW (A) < (unsigned) TREE_INT_CST_LOW (B))))\n+\n+#define INT_CST_LT_UNSIGNED(A, B)  \\\n+((unsigned) TREE_INT_CST_HIGH (A) < (unsigned) TREE_INT_CST_HIGH (B)\t  \\\n+ || ((unsigned) TREE_INT_CST_HIGH (A) == (unsigned) TREE_INT_CST_HIGH (B) \\\n+     && ((unsigned) TREE_INT_CST_LOW (A) < (unsigned) TREE_INT_CST_LOW (B))))\n+\n+struct tree_int_cst\n+{\n+  char common[sizeof (struct tree_common)];\n+  long int_cst_low;\n+  long int_cst_high;\n+};\n+\n+/* In REAL_CST, STRING_CST, COMPLEX_CST nodes, and CONSTRUCTOR nodes,\n+   and generally in all kinds of constants that could\n+   be given labels (rather than being immediate).  */\n+\n+#define TREE_CST_RTL(NODE) ((NODE)->real_cst.rtl)\n+\n+/* In a REAL_CST node.  */\n+/* We can represent a real value as either a `double' or a string.\n+   Strings don't allow for any optimization, but they do allow\n+   for cross-compilation.  */\n+\n+#define TREE_REAL_CST(NODE) ((NODE)->real_cst.real_cst)\n+\n+#include \"real.h\"\n+\n+struct tree_real_cst\n+{\n+  char common[sizeof (struct tree_common)];\n+  struct rtx_def *rtl;\t/* acts as link to register transfer language\n+\t\t\t\t   (rtl) info */\n+  REAL_VALUE_TYPE real_cst;\n+};\n+\n+/* In a STRING_CST */\n+#define TREE_STRING_LENGTH(NODE) ((NODE)->string.length)\n+#define TREE_STRING_POINTER(NODE) ((NODE)->string.pointer)\n+\n+struct tree_string\n+{\n+  char common[sizeof (struct tree_common)];\n+  struct rtx_def *rtl;\t/* acts as link to register transfer language\n+\t\t\t\t   (rtl) info */\n+  int length;\n+  char *pointer;\n+};\n+\n+/* In a COMPLEX_CST node.  */\n+#define TREE_REALPART(NODE) ((NODE)->complex.real)\n+#define TREE_IMAGPART(NODE) ((NODE)->complex.imag)\n+\n+struct tree_complex\n+{\n+  char common[sizeof (struct tree_common)];\n+  struct rtx_def *rtl;\t/* acts as link to register transfer language\n+\t\t\t\t   (rtl) info */\n+  union tree_node *real;\n+  union tree_node *imag;\n+};\n+\f\n+/* Define fields and accessors for some special-purpose tree nodes.  */\n+\n+#define IDENTIFIER_LENGTH(NODE) ((NODE)->identifier.length)\n+#define IDENTIFIER_POINTER(NODE) ((NODE)->identifier.pointer)\n+#define IDENTIFIER_VIRTUAL_P(NODE) TREE_LANG_FLAG_1(NODE)\n+\n+struct tree_identifier\n+{\n+  char common[sizeof (struct tree_common)];\n+  int length;\n+  char *pointer;\n+};\n+\n+/* In a TREE_LIST node.  */\n+#define TREE_PURPOSE(NODE) ((NODE)->list.purpose)\n+#define TREE_VALUE(NODE) ((NODE)->list.value)\n+\n+struct tree_list\n+{\n+  char common[sizeof (struct tree_common)];\n+  union tree_node *purpose;\n+  union tree_node *value;\n+};\n+\n+/* In a TREE_VEC node.  */\n+#define TREE_VEC_LENGTH(NODE) ((NODE)->vec.length)\n+#define TREE_VEC_ELT(NODE,I) ((NODE)->vec.a[I])\n+#define TREE_VEC_END(NODE) (&((NODE)->vec.a[(NODE)->vec.length]))\n+\n+struct tree_vec\n+{\n+  char common[sizeof (struct tree_common)];\n+  int length;\n+  union tree_node *a[1];\n+};\n+\n+/* Define fields and accessors for some nodes that represent expressions.  */\n+\n+/* In a SAVE_EXPR node.  */\n+#define SAVE_EXPR_CONTEXT(NODE) TREE_OPERAND(NODE, 1)\n+#define SAVE_EXPR_RTL(NODE) (*(struct rtx_def **) &(NODE)->exp.operands[2])\n+\n+/* In a RTL_EXPR node.  */\n+#define RTL_EXPR_SEQUENCE(NODE) (*(struct rtx_def **) &(NODE)->exp.operands[0])\n+#define RTL_EXPR_RTL(NODE) (*(struct rtx_def **) &(NODE)->exp.operands[1])\n+\n+/* In a CALL_EXPR node.  */\n+#define CALL_EXPR_RTL(NODE) (*(struct rtx_def **) &(NODE)->exp.operands[2])\n+\n+/* In a CONSTRUCTOR node.  */\n+#define CONSTRUCTOR_ELTS(NODE) TREE_OPERAND (NODE, 1)\n+\n+/* In a BLOCK node.  */\n+#define BLOCK_VARS(NODE) ((NODE)->exp.operands[0])\n+#define BLOCK_TYPE_TAGS(NODE) ((NODE)->exp.operands[1])\n+#define BLOCK_SUBBLOCKS(NODE) ((NODE)->exp.operands[2])\n+#define BLOCK_SUPERCONTEXT(NODE) ((NODE)->exp.operands[3])\n+/* Note: when changing this, make sure to find the places\n+   that use chainon or nreverse.  */\n+#define BLOCK_CHAIN(NODE) TREE_CHAIN (NODE)\n+\n+/* Nonzero means that this block is prepared to handle exceptions\n+   listed in the BLOCK_VARS slot.  */\n+#define BLOCK_HANDLER_BLOCK(NODE) TREE_PROTECTED(NODE)\n+\n+/* In ordinary expression nodes.  */\n+#define TREE_OPERAND(NODE, I) ((NODE)->exp.operands[I])\n+#define TREE_COMPLEXITY(NODE) ((NODE)->exp.complexity)\n+\n+struct tree_exp\n+{\n+  char common[sizeof (struct tree_common)];\n+  int complexity;\n+  union tree_node *operands[1];\n+};\n+\f\n+/* Define fields and accessors for nodes representing data types.  */\n+\n+/* See tree.def for documentation of the use of these fields.\n+   Look at the documentation of the various ..._TYPE tree codes.  */\n+\n+#define TYPE_UID(NODE) ((NODE)->type.uid)\n+#define TYPE_SIZE(NODE) ((NODE)->type.size)\n+#define TYPE_MODE(NODE) ((NODE)->type.mode)\n+#define TYPE_ALIGN(NODE) ((NODE)->type.align)\n+#define TYPE_VALUES(NODE) ((NODE)->type.values)\n+#define TYPE_DOMAIN(NODE) ((NODE)->type.values)\n+#define TYPE_FIELDS(NODE) ((NODE)->type.values)\n+#define TYPE_METHODS(NODE) ((NODE)->type.maxval)\n+#define TYPE_VFIELD(NODE) ((NODE)->type.minval)\n+#define TYPE_ARG_TYPES(NODE) ((NODE)->type.values)\n+#define TYPE_METHOD_BASETYPE(NODE) ((NODE)->type.maxval)\n+#define TYPE_OFFSET_BASETYPE(NODE) ((NODE)->type.maxval)\n+#define TYPE_POINTER_TO(NODE) ((NODE)->type.pointer_to)\n+#define TYPE_REFERENCE_TO(NODE) ((NODE)->type.reference_to)\n+#define TYPE_MIN_VALUE(NODE) ((NODE)->type.minval)\n+#define TYPE_MAX_VALUE(NODE) ((NODE)->type.maxval)\n+#define TYPE_PRECISION(NODE) ((NODE)->type.precision)\n+#define TYPE_PARSE_INFO(NODE) ((NODE)->type.parse_info)\n+#define TYPE_SYMTAB_ADDRESS(NODE) ((NODE)->type.symtab_address)\n+#define TYPE_NAME(NODE) ((NODE)->type.name)\n+#define TYPE_NEXT_VARIANT(NODE) ((NODE)->type.next_variant)\n+#define TYPE_MAIN_VARIANT(NODE) ((NODE)->type.main_variant)\n+#define TYPE_BINFO(NODE) ((NODE)->type.binfo)\n+#define TYPE_NONCOPIED_PARTS(NODE) ((NODE)->type.noncopied_parts)\n+#define TYPE_CONTEXT(NODE) ((NODE)->type.context)\n+#define TYPE_LANG_SPECIFIC(NODE) ((NODE)->type.lang_specific)\n+\n+#define TYPE_STUB_DECL(NODE) (TREE_CHAIN (NODE))\n+\n+/* In a RECORD_TYPE or UNION_TYPE, it means the type has BLKmode\n+   only because it lacks the alignment requirement for its size.  */\n+#define TYPE_NO_FORCE_BLK(NODE) ((NODE)->type.no_force_blk_flag)\n+\n+/* Nonzero in a type considered volatile as a whole.  */\n+#define TYPE_VOLATILE(NODE) ((NODE)->common.volatile_flag)\n+\n+/* Means this type is const-qualified.  */\n+#define TYPE_READONLY(NODE) ((NODE)->common.readonly_flag)\n+\n+#define TYPE_LANG_FLAG_0(NODE) ((NODE)->type.lang_flag_0)\n+#define TYPE_LANG_FLAG_1(NODE) ((NODE)->type.lang_flag_1)\n+#define TYPE_LANG_FLAG_2(NODE) ((NODE)->type.lang_flag_2)\n+#define TYPE_LANG_FLAG_3(NODE) ((NODE)->type.lang_flag_3)\n+#define TYPE_LANG_FLAG_4(NODE) ((NODE)->type.lang_flag_4)\n+#define TYPE_LANG_FLAG_5(NODE) ((NODE)->type.lang_flag_5)\n+#define TYPE_LANG_FLAG_6(NODE) ((NODE)->type.lang_flag_6)\n+\n+struct tree_type\n+{\n+  char common[sizeof (struct tree_common)];\n+  union tree_node *values;\n+  union tree_node *size;\n+  unsigned uid;\n+\n+#ifdef ONLY_INT_FIELDS\n+  int mode : 8;\n+#else\n+  enum machine_mode mode : 8;\n+#endif\n+  unsigned char align;\n+  unsigned char precision;\n+\n+  unsigned no_force_blk_flag : 1;\n+  unsigned lang_flag_0 : 1;\n+  unsigned lang_flag_1 : 1;\n+  unsigned lang_flag_2 : 1;\n+  unsigned lang_flag_3 : 1;\n+  unsigned lang_flag_4 : 1;\n+  unsigned lang_flag_5 : 1;\n+  unsigned lang_flag_6 : 1;\n+\n+  union tree_node *pointer_to;\n+  union tree_node *reference_to;\n+  int parse_info;\n+  int symtab_address;\n+  union tree_node *name;\n+  union tree_node *minval;\n+  union tree_node *maxval;\n+  union tree_node *next_variant;\n+  union tree_node *main_variant;\n+  union tree_node *binfo;\n+  union tree_node *noncopied_parts;\n+  union tree_node *context;\n+  /* Points to a structure whose details depend on the language in use.  */\n+  struct lang_type *lang_specific;\n+};\n+\f\n+/* Define accessor macros for information about type inheritance\n+   and basetypes.\n+\n+   A \"basetype\" means a particular usage of a data type for inheritance\n+   in another type.  Each such basetype usage has its own \"binfo\"\n+   object to describe it.  The binfo object is a TREE_VEC node.\n+\n+   Inheritance is represented by the binfo nodes allocated for a\n+   given type.  For example, given types C and D, such that D is\n+   inherited by C, 3 binfo nodes will be allocated: one for describing\n+   the binfo properties of C, similarly one for D, and one for\n+   describing the binfo properties of D as a base type for C.\n+   Thus, given a pointer to class C, one can get a pointer to the binfo\n+   of D acting as a basetype for C by looking at C's binfo's basetypes.  */\n+\n+/* The actual data type node being inherited in this basetype.  */\n+#define BINFO_TYPE(NODE) TREE_TYPE (NODE)\n+\n+/* The offset where this basetype appears in its containing type.\n+   BINFO_OFFSET slot holds the offset (in bytes)\n+   from the base of the complete object to the base of the part of the\n+   object that is allocated on behalf of this `type'.\n+   This is always 0 except when there is multiple inheritance.  */\n+   \n+#define BINFO_OFFSET(NODE) TREE_VEC_ELT ((NODE), 1)\n+#define TYPE_BINFO_OFFSET(NODE) BINFO_OFFSET (TYPE_BINFO (NODE))\n+#define BINFO_OFFSET_ZEROP(NODE) (BINFO_OFFSET (NODE) == integer_zero_node)\n+\n+/* The virtual function table belonging to this basetype.  Virtual\n+   function tables provide a mechanism for run-time method dispatching.\n+   The entries of a virtual function table are language-dependent.  */\n+\n+#define BINFO_VTABLE(NODE) TREE_VEC_ELT ((NODE), 2)\n+#define TYPE_BINFO_VTABLE(NODE) BINFO_VTABLE (TYPE_BINFO (NODE))\n+\n+/* The virtual functions in the virtual function table.  This is\n+   a TREE_LIST that is used as an initial approximation for building\n+   a virtual function table for this basetype.  */\n+#define BINFO_VIRTUALS(NODE) TREE_VEC_ELT ((NODE), 3)\n+#define TYPE_BINFO_VIRTUALS(NODE) BINFO_VIRTUALS (TYPE_BINFO (NODE))\n+\n+/* A vector of additional binfos for the types inherited by this basetype.\n+\n+   If this basetype describes type D as inherited in C,\n+   and if the basetypes of D are E anf F,\n+   then this vector contains binfos for inheritance of E and F by C.\n+\n+   ??? This could probably be done by just allocating the\n+   base types at the end of this TREE_VEC (instead of using\n+   another TREE_VEC).  This would simplify the calculation\n+   of how many basetypes a given type had.  */\n+#define BINFO_BASETYPES(NODE) TREE_VEC_ELT ((NODE), 4)\n+#define TYPE_BINFO_BASETYPES(NODE) TREE_VEC_ELT (TYPE_BINFO (NODE), 4)\n+\n+/* Accessor macro to get to the Nth basetype of this basetype.  */\n+#define BINFO_BASETYPE(NODE,N) TREE_VEC_ELT (BINFO_BASETYPES (NODE), (N))\n+#define TYPE_BINFO_BASETYPE(NODE,N) BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (NODE)), (N)))\n+\n+/* Slot used to build a chain that represents a use of inheritance.\n+   For example, if X is derived from Y, and Y is derived from Z,\n+   then this field can be used to link the binfo node for X to\n+   the binfo node for X's Y to represent the use of inheritance\n+   from X to Y.  Similarly, this slot of the binfo node for X's Y\n+   can point to the Z from which Y is inherited (in X's inheritance\n+   hierarchy).  In this fashion, one can represent and traverse specific\n+   uses of inheritance using the binfo nodes themselves (instead of\n+   consing new space pointing to binfo nodes).\n+   It is up to the language-dependent front-ends to maintain\n+   this information as necessary.  */\n+#define BINFO_INHERITANCE_CHAIN(NODE) TREE_VEC_ELT ((NODE), 0)\n+\f\n+/* Define fields and accessors for nodes representing declared names.  */\n+\n+/* This is the name of the object as written by the user.\n+   It is an IDENTIFIER_NODE.  */\n+#define DECL_NAME(NODE) ((NODE)->decl.name)\n+/* This macro is marked for death.  */\n+#define DECL_PRINT_NAME(NODE) ((NODE)->decl.print_name)\n+/* This is the name of the object as the assembler will see it\n+   (but before any translations made by ASM_OUTPUT_LABELREF).\n+   Often this is the same as DECL_NAME.\n+   It is an IDENTIFIER_NODE.  */\n+#define DECL_ASSEMBLER_NAME(NODE) ((NODE)->decl.assembler_name)\n+/* The containing binding context; either a BINDING\n+   or a RECORD_TYPE or UNION_TYPE.  */\n+#define DECL_CONTEXT(NODE) ((NODE)->decl.context)\n+#define DECL_FIELD_CONTEXT(NODE) ((NODE)->decl.context)\n+/* In a FIELD_DECL, this is the field position, counting in bits,\n+   of the bit closest to the beginning of the structure.  */\n+#define DECL_FIELD_BITPOS(NODE) ((NODE)->decl.arguments)\n+/* In a FIELD_DECL, this indicates whether the field was a bit-field and\n+   if so, its type.  */\n+#define DECL_BIT_FIELD_TYPE(NODE) ((NODE)->decl.result)\n+/* In FUNCTION_DECL, a chain of ..._DECL nodes.  */\n+/* VAR_DECL and PARM_DECL reserve the arguments slot\n+   for language-specific uses.  */\n+#define DECL_ARGUMENTS(NODE) ((NODE)->decl.arguments)\n+/* In FUNCTION_DECL, holds the decl for the return value.  */\n+#define DECL_RESULT(NODE) ((NODE)->decl.result)\n+/* In PARM_DECL, holds the type as written (perhaps a function or array).  */\n+#define DECL_ARG_TYPE_AS_WRITTEN(NODE) ((NODE)->decl.result)\n+/* For a FUNCTION_DECL, holds the tree of BINDINGs.\n+   For a VAR_DECL, holds the initial value.\n+   For a PARM_DECL, not used--default\n+   values for parameters are encoded in the type of the function,\n+   not in the PARM_DECL slot.  */\n+#define DECL_INITIAL(NODE) ((NODE)->decl.initial)\n+/* For a PARM_DECL, records the data type used to pass the argument,\n+   which may be different from the type seen in the program.  */\n+#define DECL_ARG_TYPE(NODE) ((NODE)->decl.initial)   /* In PARM_DECL.  */\n+/* These two fields describe where in the source code the declaration was.  */\n+#define DECL_SOURCE_FILE(NODE) ((NODE)->decl.filename)\n+#define DECL_SOURCE_LINE(NODE) ((NODE)->decl.linenum)\n+/* Holds the size of the datum, as a tree expression.\n+   Need not be constant.  */\n+#define DECL_SIZE(NODE) ((NODE)->decl.size)\n+/* Holds the alignment required for the datum.  */\n+#define DECL_ALIGN(NODE) ((NODE)->decl.align)\n+/* Holds the machine mode of a variable or field.  */\n+#define DECL_MODE(NODE) ((NODE)->decl.mode)\n+/* Holds the RTL expression for the value of a variable or function.  */\n+#define DECL_RTL(NODE) ((NODE)->decl.rtl)\n+/* For PARM_DECL, holds an RTL for the stack slot or register\n+   where the data was actually passed.  */\n+#define DECL_INCOMING_RTL(NODE) ((NODE)->decl.saved_insns)\n+/* For FUNCTION_DECL, if it is inline, holds the saved insn chain.  */\n+#define DECL_SAVED_INSNS(NODE) ((NODE)->decl.saved_insns)\n+/* For FUNCTION_DECL for built-in function.  */\n+#define DECL_FUNCTION_CODE(NODE) \\\n+ ((enum built_in_function) (NODE)->decl.frame_size)\n+#define DECL_SET_FUNCTION_CODE(NODE,VAL) \\\n+ ((NODE)->decl.frame_size = (int) (VAL))\n+/* For FUNCTION_DECL, if it is inline,\n+   holds the size of the stack frame, as an integer.  */\n+#define DECL_FRAME_SIZE(NODE) ((NODE)->decl.frame_size)\n+\n+/* The DECL_VINDEX is used for FUNCTION_DECLS in two different ways.\n+   Before the struct containing the FUNCTION_DECL is laid out,\n+   DECL_VINDEX may point to a FUNCTION_DECL in a base class which\n+   is the FUNCTION_DECL which this FUNCTION_DECL will replace as a virtual\n+   function.  When the class is laid out, this pointer is changed\n+   to an INTEGER_CST node which is suitable for use as an index\n+   into the virtual function table.  */\n+#define DECL_VINDEX(NODE) ((NODE)->decl.vindex)\n+/* For FIELD_DECLS, DECL_FCONTEXT is the *first* baseclass in\n+   which this FIELD_DECL is defined.  This information is needed when\n+   writing debugging information about vfield and vbase decls for C++.  */\n+#define DECL_FCONTEXT(NODE) ((NODE)->decl.vindex)\n+\n+/* Nonzero in a VAR_DECL or PARM_DECL means this decl was made by inlining;\n+   suppress any warnings about shadowing some other variable.  */\n+#define DECL_FROM_INLINE(NODE) ((NODE)->decl.from_inline_flag)\n+\n+/* Nonzero if a _DECL means that the name of this decl should be ignored\n+   for symbolic debug purposes.  */\n+#define DECL_IGNORED_P(NODE) ((NODE)->decl.ignored_flag)\n+\n+#define DECL_LANG_SPECIFIC(NODE) ((NODE)->decl.lang_specific)\n+\n+/* In a VAR_DECL or FUNCTION_DECL,\n+   nonzero means external reference:\n+   do not allocate storage, and refer to a definition elsewhere.  */\n+#define TREE_EXTERNAL(NODE) ((NODE)->decl.external_flag)\n+\n+/* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.\n+   In LABEL_DECL nodes, nonzero means that an error message about\n+   jumping into such a binding contour has been printed for this label.  */\n+#define TREE_REGDECL(NODE) ((NODE)->decl.regdecl_flag)\n+\n+/* Nonzero in a ..._DECL means this variable is ref'd from a nested function.\n+   For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.\n+\n+   For LABEL_DECL nodes, nonzero if nonlocal gotos to the label are permitted.\n+\n+   Also set in some languages for variables, etc., outside the normal\n+   lexical scope, such as class instance variables.  */\n+#define TREE_NONLOCAL(NODE) ((NODE)->decl.nonlocal_flag)\n+\n+/* Nonzero in a FUNCTION_DECL means this function can be substituted\n+   where it is called.  */\n+#define TREE_INLINE(NODE) ((NODE)->decl.inline_flag)\n+\n+/* Nonzero in a FUNCTION_DECL means this is a built-in function\n+   that is not specified by ansi C and that users are supposed to be allowed\n+   to redefine for any purpose whatever.  */\n+#define DECL_BUILT_IN_NONANSI(NODE) ((NODE)->common.unsigned_flag)\n+\n+/* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed\n+   specially.  */\n+#define DECL_BIT_FIELD(NODE) ((NODE)->decl.bit_field_flag)\n+/* In a LABEL_DECL, nonzero means label was defined inside a binding\n+   contour that restored a stack level and which is now exited.  */\n+#define DECL_TOO_LATE(NODE) ((NODE)->decl.bit_field_flag)\n+/* In a FUNCTION_DECL, nonzero means a built in function.  */\n+#define DECL_BUILT_IN(NODE) ((NODE)->decl.bit_field_flag)\n+\n+/* In a METHOD_DECL, indicates a function for which each instance has a pointer.  */\n+#define DECL_VIRTUAL_P(NODE) ((NODE)->decl.virtual_flag)\n+/* In a FIELD_DECL, indicates this field should be bit-packed.  */\n+#define DECL_PACKED(NODE) ((NODE)->decl.virtual_flag)\n+\n+/* Additional flags for language-specific uses.  */\n+#define DECL_LANG_FLAG_0(NODE) ((NODE)->decl.lang_flag_0)\n+#define DECL_LANG_FLAG_1(NODE) ((NODE)->decl.lang_flag_1)\n+#define DECL_LANG_FLAG_2(NODE) ((NODE)->decl.lang_flag_2)\n+#define DECL_LANG_FLAG_3(NODE) ((NODE)->decl.lang_flag_3)\n+#define DECL_LANG_FLAG_4(NODE) ((NODE)->decl.lang_flag_4)\n+#define DECL_LANG_FLAG_5(NODE) ((NODE)->decl.lang_flag_5)\n+#define DECL_LANG_FLAG_6(NODE) ((NODE)->decl.lang_flag_6)\n+#define DECL_LANG_FLAG_7(NODE) ((NODE)->decl.lang_flag_7)\n+\n+struct tree_decl\n+{\n+  char common[sizeof (struct tree_common)];\n+  char *filename;\n+  int linenum;\n+  union tree_node *size;\n+#ifdef ONLY_INT_FIELDS\n+  int mode : 8;\n+#else\n+  enum machine_mode mode : 8;\n+#endif\n+  unsigned char align;\n+\n+  unsigned external_flag : 1;\n+  unsigned nonlocal_flag : 1;\n+  unsigned regdecl_flag : 1;\n+  unsigned inline_flag : 1;\n+  unsigned bit_field_flag : 1;\n+  unsigned virtual_flag : 1;\n+  unsigned from_inline_flag : 1;\n+  unsigned ignored_flag : 1;\n+\n+  unsigned lang_flag_0 : 1;\n+  unsigned lang_flag_1 : 1;\n+  unsigned lang_flag_2 : 1;\n+  unsigned lang_flag_3 : 1;\n+  unsigned lang_flag_4 : 1;\n+  unsigned lang_flag_5 : 1;\n+  unsigned lang_flag_6 : 1;\n+  unsigned lang_flag_7 : 1;\n+\n+  union tree_node *name;\n+  union tree_node *context;\n+  union tree_node *arguments;\n+  union tree_node *result;\n+  union tree_node *initial;\n+  /* The PRINT_NAME field is marked for death.  */\n+  char *print_name;\n+  union tree_node *assembler_name;\n+  struct rtx_def *rtl;\t/* acts as link to register transfer language\n+\t\t\t\t   (rtl) info */\n+  int frame_size;\t\t/* For FUNCTION_DECLs: size of stack frame */\n+  struct rtx_def *saved_insns;\t/* For FUNCTION_DECLs: points to insn that\n+\t\t\t\t   constitutes its definition on the\n+\t\t\t\t   permanent obstack.  */\n+  union tree_node *vindex;\n+  /* Points to a structure whose details depend on the language in use.  */\n+  struct lang_decl *lang_specific;\n+};\n+\f\n+/* Define the overall contents of a tree node.\n+   It may be any of the structures declared above\n+   for various types of node.  */\n+\n+union tree_node\n+{\n+  struct tree_common common;\n+  struct tree_int_cst int_cst;\n+  struct tree_real_cst real_cst;\n+  struct tree_string string;\n+  struct tree_complex complex;\n+  struct tree_identifier identifier;\n+  struct tree_decl decl;\n+  struct tree_type type;\n+  struct tree_list list;\n+  struct tree_vec vec;\n+  struct tree_exp exp;\n+ };\n+\n+/* Format for global names of constructor and destructor functions.  */\n+#ifndef NO_DOLLAR_IN_LABEL\n+#define CONSTRUCTOR_NAME_FORMAT \"_GLOBAL_$I$%s\"\n+#else\n+#define CONSTRUCTOR_NAME_FORMAT \"_GLOBAL_.I.%s\"\n+#endif\n+\f\n+extern char *oballoc ();\n+extern char *permalloc ();\n+extern char *savealloc ();\n+\n+/* Lowest level primitive for allocating a node.\n+   The TREE_CODE is the only argument.  Contents are initialized\n+   to zero except for a few of the common fields.  */\n+\n+extern tree make_node ();\n+\n+/* Make a copy of a node, with all the same contents except\n+   for TREE_PERMANENT.  (The copy is permanent\n+   iff nodes being made now are permanent.)  */\n+\n+extern tree copy_node ();\n+\n+/* Make a copy of a chain of TREE_LIST nodes.  */\n+\n+extern tree copy_list ();\n+\n+/* Make a TREE_VEC.  */\n+\n+extern tree make_tree_vec ();\n+\n+/* Return the (unique) IDENTIFIER_NODE node for a given name.\n+   The name is supplied as a char *.  */\n+\n+extern tree get_identifier ();\n+\n+/* Construct various types of nodes.  */\n+\n+extern tree build_int_2 ();\n+extern tree build_real ();\n+extern tree build_real_from_string ();\n+extern tree build_real_from_int_cst ();\n+extern tree build_complex ();\n+extern tree build_string ();\n+extern tree build (), build1 ();\n+extern tree build_nt (), build_parse_node ();\n+extern tree build_tree_list (), build_decl_list ();\n+extern tree build_op_identifier ();\n+extern tree build_decl ();\n+extern tree build_block ();\n+\n+/* Construct various nodes representing data types.  */\n+\n+extern tree make_signed_type ();\n+extern tree make_unsigned_type ();\n+extern tree signed_or_unsigned_type ();\n+extern void fixup_unsigned_type ();\n+extern tree build_pointer_type ();\n+extern tree build_reference_type ();\n+extern tree build_index_type (), build_index_2_type ();\n+extern tree build_array_type ();\n+extern tree build_function_type ();\n+extern tree build_method_type ();\n+extern tree build_offset_type ();\n+extern tree build_complex_type ();\n+extern tree array_type_nelts ();\n+\n+/* Construct expressions, performing type checking.  */\n+\n+extern tree build_binary_op ();\n+extern tree build_indirect_ref ();\n+extern tree build_unary_op ();\n+\f\n+/* Given a type node TYPE, and CONSTP and VOLATILEP, return a type\n+   for the same kind of data as TYPE describes.\n+   Variants point to the \"main variant\" (which has neither CONST nor VOLATILE)\n+   via TYPE_MAIN_VARIANT, and it points to a chain of other variants\n+   so that duplicate variants are never made.\n+   Only main variants should ever appear as types of expressions.  */\n+\n+extern tree build_type_variant ();\n+\n+/* Return the mode for data of a given size SIZE and mode class CLASS.\n+   If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n+   The value is BLKmode if no other mode is found.  */\n+\n+extern enum machine_mode mode_for_size ();\n+\n+/* Given a ..._TYPE node, calculate the TYPE_SIZE, TYPE_SIZE_UNIT,\n+   TYPE_ALIGN and TYPE_MODE fields.\n+   If called more than once on one node, does nothing except\n+   for the first time.  */\n+\n+extern void layout_type ();\n+\n+/* Given a hashcode and a ..._TYPE node (for which the hashcode was made),\n+   return a canonicalized ..._TYPE node, so that duplicates are not made.\n+   How the hash code is computed is up to the caller, as long as any two\n+   callers that could hash identical-looking type nodes agree.  */\n+\n+extern tree type_hash_canon ();\n+\n+/* Given a VAR_DECL, PARM_DECL, RESULT_DECL or FIELD_DECL node,\n+   calculates the DECL_SIZE, DECL_SIZE_UNIT, DECL_ALIGN and DECL_MODE\n+   fields.  Call this only once for any given decl node.\n+\n+   Second argument is the boundary that this field can be assumed to\n+   be starting at (in bits).  Zero means it can be assumed aligned\n+   on any boundary that may be needed.  */\n+\n+extern void layout_decl ();\n+\n+/* Fold constants as much as possible in an expression.\n+   Returns the simplified expression.\n+   Acts only on the top level of the expression;\n+   if the argument itself cannot be simplified, its\n+   subexpressions are not changed.  */\n+\n+extern tree fold ();\n+\n+/* Return an expr equal to X but certainly not valid as an lvalue.  */\n+\n+extern tree non_lvalue ();\n+\n+extern tree convert ();\n+extern tree size_in_bytes ();\n+extern tree size_binop ();\n+extern tree size_int ();\n+extern tree round_up ();\n+extern tree get_pending_sizes ();\n+extern tree get_permanent_types (), get_temporary_types ();\n+\n+/* Type for sizes of data-type.  */\n+\n+extern tree sizetype;\n+\n+/* Concatenate two lists (chains of TREE_LIST nodes) X and Y\n+   by making the last node in X point to Y.\n+   Returns X, except if X is 0 returns Y.  */\n+\n+extern tree chainon ();\n+\n+/* Make a new TREE_LIST node from specified PURPOSE, VALUE and CHAIN.  */\n+\n+extern tree tree_cons (), perm_tree_cons (), temp_tree_cons ();\n+extern tree saveable_tree_cons (), decl_tree_cons ();\n+\n+/* Return the last tree node in a chain.  */\n+\n+extern tree tree_last ();\n+\n+/* Reverse the order of elements in a chain, and return the new head.  */\n+\n+extern tree nreverse ();\n+\n+/* Make a copy of a chain of tree nodes.  */\n+\n+extern tree copy_chain ();\n+\n+/* Returns the length of a chain of nodes\n+   (number of chain pointers to follow before reaching a null pointer).  */\n+\n+extern int list_length ();\n+\n+/* integer_zerop (tree x) is nonzero if X is an integer constant of value 0 */\n+\n+extern int integer_zerop ();\n+\n+/* integer_onep (tree x) is nonzero if X is an integer constant of value 1 */\n+\n+extern int integer_onep ();\n+\n+/* integer_all_onesp (tree x) is nonzero if X is an integer constant\n+   all of whose significant bits are 1.  */\n+\n+extern int integer_all_onesp ();\n+\n+/* integer_pow2p (tree x) is nonzero is X is an integer constant with\n+   exactly one bit 1.  */\n+\n+extern int integer_pow2p ();\n+\n+/* type_unsigned_p (tree x) is nonzero if the type X is an unsigned type\n+   (all of its possible values are >= 0).\n+   If X is a pointer type, the value is 1.\n+   If X is a real type, the value is 0.  */\n+\n+extern int type_unsigned_p ();\n+\n+/* staticp (tree x) is nonzero if X is a reference to data allocated\n+   at a fixed address in memory.  */\n+\n+extern int staticp ();\n+\n+/* Gets an error if argument X is not an lvalue.\n+   Also returns 1 if X is an lvalue, 0 if not.  */\n+\n+extern int lvalue_or_else ();\n+\n+/* save_expr (EXP) returns an expression equivalent to EXP\n+   but it can be used multiple times within context CTX\n+   and only evaluate EXP once.  */\n+\n+extern tree save_expr ();\n+\n+/* stabilize_reference (EXP) returns an reference equivalent to EXP\n+   but it can be used multiple times\n+   and only evaluate the subexpressions once.  */\n+\n+extern tree stabilize_reference ();\n+\n+/* Return EXP, stripped of any conversions to wider types\n+   in such a way that the result of converting to type FOR_TYPE\n+   is the same as if EXP were converted to FOR_TYPE.\n+   If FOR_TYPE is 0, it signifies EXP's type.  */\n+\n+extern tree get_unwidened ();\n+\n+/* Return OP or a simpler expression for a narrower value\n+   which can be sign-extended or zero-extended to give back OP.\n+   Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended\n+   or 0 if the value should be sign-extended.  */\n+\n+extern tree get_narrower ();\n+\n+/* Given MODE and UNSIGNEDP, return a suitable type-tree\n+   with that mode.\n+   The definition of this resides in language-specific code\n+   as the repertoire of available types may vary.  */\n+\n+extern tree type_for_mode ();\n+\n+/* Given PRECISION and UNSIGNEDP, return a suitable type-tree\n+   for an integer type with at least that precision.\n+   The definition of this resides in language-specific code\n+   as the repertoire of available types may vary.  */\n+\n+extern tree type_for_size ();\n+\n+/* Given an integer type T, return a type like T but unsigned.\n+   If T is unsigned, the value is T.\n+   The definition of this resides in language-specific code\n+   as the repertoire of available types may vary.  */\n+\n+extern tree unsigned_type ();\n+\n+/* Given an integer type T, return a type like T but signed.\n+   If T is signed, the value is T.\n+   The definition of this resides in language-specific code\n+   as the repertoire of available types may vary.  */\n+\n+extern tree signed_type ();\n+\n+/* This function must be defined in the language-specific files.\n+   expand_expr calls it to build the cleanup-expression for a TARGET_EXPR.\n+   This is defined in a language-specific file.  */\n+\n+extern tree maybe_build_cleanup ();\n+\n+/* Return the floating type node for a given floating machine mode.  */\n+\n+extern tree get_floating_type ();\n+\n+/* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,\n+   look for nested component-refs or array-refs at constant positions\n+   and find the ultimate containing object, which is returned.  */\n+\n+extern tree get_inner_reference ();\n+\n+/* Return the FUNCTION_DECL which provides this _DECL with its context,\n+   or zero if none.  */\n+extern tree decl_function_context ();\n+\n+/* Return the RECORD_TYPE or UNION_TYPE which provides this _DECL\n+   with its context, or zero if none.  */\n+extern tree decl_type_context ();\n+\n+/* Given the FUNCTION_DECL for the current function,\n+   return zero if it is ok for this function to be inline.\n+   Otherwise return a warning message with a single %s\n+   for the function's name.  */\n+\n+extern char *function_cannot_inline_p ();\n+\f\n+/* Declare commonly used variables for tree structure.  */\n+\n+/* An integer constant with value 0 */\n+extern tree integer_zero_node;\n+\n+/* An integer constant with value 1 */\n+extern tree integer_one_node;\n+\n+/* An integer constant with value 0 whose type is sizetype.  */\n+extern tree size_zero_node;\n+\n+/* An integer constant with value 1 whose type is sizetype.  */\n+extern tree size_one_node;\n+\n+/* A constant of type pointer-to-int and value 0 */\n+extern tree null_pointer_node;\n+\n+/* A node of type ERROR_MARK.  */\n+extern tree error_mark_node;\n+\n+/* The type node for the void type.  */\n+extern tree void_type_node;\n+\n+/* The type node for the ordinary (signed) integer type.  */\n+extern tree integer_type_node;\n+\n+/* The type node for the unsigned integer type.  */\n+extern tree unsigned_type_node;\n+\n+/* The type node for the ordinary character type.  */\n+extern tree char_type_node;\n+\n+/* Points to the name of the input file from which the current input\n+   being parsed originally came (before it went into cpp).  */\n+extern char *input_filename;\n+\n+/* Current line number in input file.  */\n+extern int lineno;\n+\n+/* Nonzero for -pedantic switch: warn about anything\n+   that standard C forbids.  */\n+extern int pedantic;\n+\n+/* Nonzero means can safely call expand_expr now;\n+   otherwise layout_type puts variable sizes onto `pending_sizes' instead.  */\n+\n+extern int immediate_size_expand;\n+\n+/* Points to the FUNCTION_DECL of the function whose body we are reading. */\n+\n+extern tree current_function_decl;\n+\n+/* Nonzero if function being compiled can call setjmp.  */\n+\n+extern int current_function_calls_setjmp;\n+\n+/* Nonzero if function being compiled can call longjmp.  */\n+\n+extern int current_function_calls_longjmp;\n+\n+/* Nonzero means all ..._TYPE nodes should be allocated permanently.  */\n+\n+extern int all_types_permanent;\n+\n+/* Pointer to function to compute the name to use to print a declaration.  */\n+\n+extern char *(*decl_printable_name) ();\n+\f\n+/* In expmed.c */\n+extern tree make_tree ();\n+\n+/* In stmt.c */\n+\n+extern tree expand_start_stmt_expr ();\n+extern tree expand_end_stmt_expr ();\n+extern void expand_expr_stmt (), clear_last_expr ();\n+extern void expand_label (), expand_goto (), expand_asm ();\n+extern void expand_start_cond (), expand_end_cond ();\n+extern void expand_start_else (), expand_start_elseif ();\n+extern struct nesting *expand_start_loop ();\n+extern struct nesting *expand_start_loop_continue_elsewhere ();\n+extern void expand_loop_continue_here ();\n+extern void expand_end_loop ();\n+extern int expand_continue_loop ();\n+extern int expand_exit_loop (), expand_exit_loop_if_false ();\n+extern int expand_exit_something ();\n+\n+extern void expand_start_delayed_expr ();\n+extern tree expand_end_delayed_expr ();\n+extern void expand_emit_delayed_expr ();\n+\n+extern void expand_null_return (), expand_return ();\n+extern void expand_start_bindings (), expand_end_bindings ();\n+extern tree last_cleanup_this_contour ();\n+extern void expand_start_case (), expand_end_case ();\n+extern int pushcase (), pushcase_range ();\n+extern void expand_start_function (), expand_end_function ();\n+\n+/* In fold-const.c */\n+\n+extern tree invert_truthvalue ();\n+\f\n+/* The language front-end must define these functions.  */\n+\n+/* Function of no arguments for initializing lexical scanning.  */\n+extern void init_lex ();\n+/* Function of no arguments for initializing the symbol table.  */\n+extern void init_decl_processing ();\n+\n+/* Functions called with no arguments at the beginning and end or processing\n+   the input source file.  */\n+extern void lang_init ();\n+extern void lang_finish ();\n+\n+/* Function called with no arguments to parse and compile the input.  */\n+extern int yyparse ();\n+/* Function called with option as argument\n+   to decode options starting with -f or -W or +.\n+   It should return nonzero if it handles the option.  */\n+extern int lang_decode_option ();\n+\n+/* Functions for processing symbol declarations.  */\n+/* Function to enter a new lexical scope.\n+   Takes one argument: always zero when called from outside the front end.  */\n+extern void pushlevel ();\n+/* Function to exit a lexical scope.  It returns a BINDING for that scope.\n+   Takes three arguments:\n+     KEEP -- nonzero if there were declarations in this scope.\n+     REVERSE -- reverse the order of decls before returning them.\n+     FUNCTIONBODY -- nonzero if this level is the body of a function.  */\n+extern tree poplevel ();\n+/* Function to add a decl to the current scope level.\n+   Takes one argument, a decl to add.\n+   Returns that decl, or, if the same symbol is already declared, may\n+   return a different decl for that name.  */\n+extern tree pushdecl ();\n+/* Function to return the chain of decls so far in the current scope level.  */\n+extern tree getdecls ();\n+/* Function to return the chain of structure tags in the current scope level.  */\n+extern tree gettags ();"}]}