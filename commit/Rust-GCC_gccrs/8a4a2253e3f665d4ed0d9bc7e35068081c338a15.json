{"sha": "8a4a2253e3f665d4ed0d9bc7e35068081c338a15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE0YTIyNTNlM2Y2NjVkNGVkMGQ5YmM3ZTM1MDY4MDgxYzMzOGExNQ==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2003-08-22T04:02:50Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2003-08-22T04:02:50Z"}, "message": "m68k-protos.h: Convert to ISO C90.\n\n\t* config/m68k/m68k-protos.h: Convert to ISO C90.\n\t* config/m68k/m68k.c: Likewise.\n\nFrom-SVN: r70675", "tree": {"sha": "3bfb50b5c09be52bc817138de73feddbe45ecdcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bfb50b5c09be52bc817138de73feddbe45ecdcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a4a2253e3f665d4ed0d9bc7e35068081c338a15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a4a2253e3f665d4ed0d9bc7e35068081c338a15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a4a2253e3f665d4ed0d9bc7e35068081c338a15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a4a2253e3f665d4ed0d9bc7e35068081c338a15/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "896a9055f1147f298c9fb88ea2fa7a56bfe489a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896a9055f1147f298c9fb88ea2fa7a56bfe489a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896a9055f1147f298c9fb88ea2fa7a56bfe489a5"}], "stats": {"total": 327, "additions": 127, "deletions": 200}, "files": [{"sha": "a6d84223314175a40661927e560220523b25f7e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a2253e3f665d4ed0d9bc7e35068081c338a15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a2253e3f665d4ed0d9bc7e35068081c338a15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a4a2253e3f665d4ed0d9bc7e35068081c338a15", "patch": "@@ -1,3 +1,8 @@\n+2003-08-22  Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* config/m68k/m68k-protos.h: Convert to ISO C90.\n+\t* config/m68k/m68k.c: Likewise.\n+\n 2003-08-21  Bernardo Innocenti  <bernie@develer.com>\n             Paul Dale  <pauli@snapgear.com>\n             Peter Barada <peter@baradas.org>"}, {"sha": "76083a7dc7bc4c3bcd230e539f7e1a8886670545", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a2253e3f665d4ed0d9bc7e35068081c338a15/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a2253e3f665d4ed0d9bc7e35068081c338a15/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=8a4a2253e3f665d4ed0d9bc7e35068081c338a15", "patch": "@@ -21,49 +21,48 @@ Boston, MA 02111-1307, USA.  */\n /* Define functions defined in aux-output.c and used in templates.  */\n \n #ifdef RTX_CODE\n-extern const char *output_move_const_into_data_reg PARAMS ((rtx *));\n-extern const char *output_move_simode_const PARAMS ((rtx *));\n-extern const char *output_move_simode PARAMS ((rtx *));\n-extern const char *output_move_himode PARAMS ((rtx *));\n-extern const char *output_move_qimode PARAMS ((rtx *));\n-extern const char *output_move_stricthi PARAMS ((rtx *));\n-extern const char *output_move_strictqi PARAMS ((rtx *));\n-extern const char *output_move_double PARAMS ((rtx *));\n-extern const char *output_move_const_single PARAMS ((rtx *));\n-extern const char *output_move_const_double PARAMS ((rtx *));\n-extern const char *output_btst PARAMS ((rtx *, rtx, rtx, rtx, int));\n-extern const char *output_scc_di PARAMS ((rtx, rtx, rtx, rtx));\n-extern const char *output_addsi3 PARAMS ((rtx *));\n-extern const char *output_andsi3 PARAMS ((rtx *));\n-extern const char *output_iorsi3 PARAMS ((rtx *));\n-extern const char *output_xorsi3 PARAMS ((rtx *));\n-extern void output_dbcc_and_branch PARAMS ((rtx *));\n-extern int const_uint32_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_sint32_operand PARAMS ((rtx, enum machine_mode));\n-extern int floating_exact_log2 PARAMS ((rtx));\n-extern int not_sp_operand PARAMS ((rtx, enum machine_mode));\n-extern int valid_dbcc_comparison_p PARAMS ((rtx, enum machine_mode));\n-extern int extend_operator PARAMS ((rtx, enum machine_mode));\n-extern int strict_low_part_peephole_ok PARAMS ((enum machine_mode, rtx, rtx));\n+extern const char *output_move_const_into_data_reg (rtx *);\n+extern const char *output_move_simode_const (rtx *);\n+extern const char *output_move_simode (rtx *);\n+extern const char *output_move_himode (rtx *);\n+extern const char *output_move_qimode (rtx *);\n+extern const char *output_move_stricthi (rtx *);\n+extern const char *output_move_strictqi (rtx *);\n+extern const char *output_move_double (rtx *);\n+extern const char *output_move_const_single (rtx *);\n+extern const char *output_move_const_double (rtx *);\n+extern const char *output_btst (rtx *, rtx, rtx, rtx, int);\n+extern const char *output_scc_di (rtx, rtx, rtx, rtx);\n+extern const char *output_addsi3 (rtx *);\n+extern const char *output_andsi3 (rtx *);\n+extern const char *output_iorsi3 (rtx *);\n+extern const char *output_xorsi3 (rtx *);\n+extern void output_dbcc_and_branch (rtx *);\n+extern int const_uint32_operand (rtx, enum machine_mode);\n+extern int const_sint32_operand (rtx, enum machine_mode);\n+extern int floating_exact_log2 (rtx);\n+extern int not_sp_operand (rtx, enum machine_mode);\n+extern int valid_dbcc_comparison_p (rtx, enum machine_mode);\n+extern int extend_operator (rtx, enum machine_mode);\n+extern bool strict_low_part_peephole_ok (enum machine_mode mode, rtx first_insn, rtx target);\n \n /* Functions from m68k.c used in macros.  */\n-extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int standard_68881_constant_p PARAMS ((rtx));\n-extern int standard_sun_fpa_constant_p PARAMS ((rtx));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void notice_update_cc PARAMS ((rtx, rtx));\n+extern bool symbolic_operand (rtx, enum machine_mode);\n+extern int standard_68881_constant_p (rtx);\n+extern void print_operand_address (FILE *, rtx);\n+extern void print_operand (FILE *, rtx, int);\n+extern void notice_update_cc (rtx, rtx);\n #if 0\n-extern void finalize_pic PARAMS ((rtx, enum machine_mode));\n+extern void finalize_pic (rtx, enum machine_mode));\n #endif\n-extern int general_src_operand PARAMS ((rtx, enum machine_mode));\n-extern int nonimmediate_src_operand PARAMS ((rtx, enum machine_mode));\n-extern int memory_src_operand PARAMS ((rtx, enum machine_mode));\n-extern int pcrel_address PARAMS ((rtx, enum machine_mode));\n-extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n+extern int general_src_operand (rtx, enum machine_mode);\n+extern int nonimmediate_src_operand (rtx, enum machine_mode);\n+extern int memory_src_operand (rtx, enum machine_mode);\n+extern int pcrel_address (rtx, enum machine_mode);\n+extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n #endif /* RTX_CODE */\n \n-extern int flags_in_68881 PARAMS ((void));\n-extern int use_return_insn PARAMS ((void));\n-extern void override_options PARAMS ((void));\n-extern void init_68881_table PARAMS ((void));\n+extern int flags_in_68881 (void);\n+extern int use_return_insn (void);\n+extern void override_options (void);\n+extern void init_68881_table (void);"}, {"sha": "cd5311e94cd2444005f12923f418ee7da25ed6e8", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 83, "deletions": 160, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a2253e3f665d4ed0d9bc7e35068081c338a15/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a2253e3f665d4ed0d9bc7e35068081c338a15/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=8a4a2253e3f665d4ed0d9bc7e35068081c338a15", "patch": "@@ -49,23 +49,23 @@ Boston, MA 02111-1307, USA.  */\n    if SGS_SWITCH_TABLE.  */\n int switch_table_difference_label_flag;\n \n-static rtx find_addr_reg PARAMS ((rtx));\n-static const char *singlemove_string PARAMS ((rtx *));\n-static void m68k_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void m68k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void m68k_coff_asm_named_section PARAMS ((const char *, unsigned int));\n+static rtx find_addr_reg (rtx);\n+static const char *singlemove_string (rtx *);\n+static void m68k_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void m68k_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void m68k_coff_asm_named_section (const char *, unsigned int);\n #ifdef CTOR_LIST_BEGIN\n-static void m68k_svr3_asm_out_constructor PARAMS ((rtx, int));\n+static void m68k_svr3_asm_out_constructor (rtx, int);\n #endif\n #ifdef HPUX_ASM\n-static void m68k_hp320_internal_label PARAMS ((FILE *, const char *, unsigned long));\n-static void m68k_hp320_file_start PARAMS ((void));\n-#endif\n-static void m68k_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t\t  HOST_WIDE_INT, tree));\n-static int m68k_save_reg PARAMS ((unsigned int));\n-static int const_int_cost PARAMS ((rtx));\n-static bool m68k_rtx_costs PARAMS ((rtx, int, int, int *));\n+static void m68k_hp320_internal_label (FILE *, const char *, unsigned long);\n+static void m68k_hp320_file_start (void);\n+#endif\n+static void m68k_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t\t  HOST_WIDE_INT, tree);\n+static int m68k_save_reg (unsigned int);\n+static int const_int_cost (rtx);\n+static bool m68k_rtx_costs (rtx, int, int, int *);\n \f\n \n /* Alignment to use for loops and jumps */\n@@ -150,7 +150,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n \n void\n-override_options ()\n+override_options (void)\n {\n   int def_align;\n   int i;\n@@ -218,8 +218,7 @@ override_options ()\n \f\n /* Return 1 if we need to save REGNO.  */\n static int\n-m68k_save_reg (regno)\n-     unsigned int regno;\n+m68k_save_reg (unsigned int regno)\n {\n   if (flag_pic && current_function_uses_pic_offset_table\n       && regno == PIC_OFFSET_TABLE_REGNUM)\n@@ -257,9 +256,7 @@ m68k_save_reg (regno)\n    of the order for movem!  */\n \n static void\n-m68k_output_function_prologue (stream, size)\n-     FILE *stream;\n-     HOST_WIDE_INT size;\n+m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n {\n   register int regno;\n   register int mask = 0;\n@@ -604,9 +601,7 @@ use_return_insn ()\n    omit stack adjustments before returning.  */\n \n static void\n-m68k_output_function_epilogue (stream, size)\n-     FILE *stream;\n-     HOST_WIDE_INT size;\n+m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n {\n   register int regno;\n   register int mask, fmask;\n@@ -876,14 +871,12 @@ m68k_output_function_epilogue (stream, size)\n /* Similar to general_operand, but exclude stack_pointer_rtx.  */\n \n int\n-not_sp_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+not_sp_operand (rtx op, enum machine_mode mode)\n {\n   return op != stack_pointer_rtx && nonimmediate_operand (op, mode);\n }\n \n-/* Return TRUE if X is a valid comparison operator for the dbcc \n+/* Return true if X is a valid comparison operator for the dbcc \n    instruction.  \n \n    Note it rejects floating point comparison operators.\n@@ -892,9 +885,7 @@ not_sp_operand (op, mode)\n    It also rejects some comparisons when CC_NO_OVERFLOW is set.  */\n    \n int\n-valid_dbcc_comparison_p (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+valid_dbcc_comparison_p (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (x))\n     {\n@@ -913,7 +904,7 @@ valid_dbcc_comparison_p (x, mode)\n \n /* Return nonzero if flags are currently in the 68881 flag register.  */\n int\n-flags_in_68881 ()\n+flags_in_68881 (void)\n {\n   /* We could add support for these in the future */\n   return cc_status.flags & CC_IN_68881;\n@@ -926,8 +917,7 @@ flags_in_68881 ()\n    kick those out before we get here.  */\n \n void\n-output_dbcc_and_branch (operands)\n-     rtx *operands;\n+output_dbcc_and_branch (rtx *operands)\n {\n   switch (GET_CODE (operands[3]))\n     {\n@@ -1036,11 +1026,7 @@ output_dbcc_and_branch (operands)\n }\n \n const char *\n-output_scc_di(op, operand1, operand2, dest)\n-     rtx op;\n-     rtx operand1;\n-     rtx operand2;\n-     rtx dest;\n+output_scc_di(rtx op, rtx operand1, rtx operand2, rtx dest)\n {\n   rtx loperands[7];\n   enum rtx_code op_code = GET_CODE (op);\n@@ -1223,11 +1209,7 @@ output_scc_di(op, operand1, operand2, dest)\n }\n \n const char *\n-output_btst (operands, countop, dataop, insn, signpos)\n-     rtx *operands;\n-     rtx countop, dataop;\n-     rtx insn;\n-     int signpos;\n+output_btst (rtx *operands, rtx countop, rtx dataop, rtx insn, int signpos)\n {\n   operands[0] = countop;\n   operands[1] = dataop;\n@@ -1265,19 +1247,17 @@ output_btst (operands, countop, dataop, insn, signpos)\n   return \"btst %0,%1\";\n }\n \f\n-/* Returns 1 if OP is either a symbol reference or a sum of a symbol\n+/* Returns true if OP is either a symbol reference or a sum of a symbol\n    reference and a constant.  */\n \n-int\n-symbolic_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+bool\n+symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      return 1;\n+      return true;\n \n     case CONST:\n       op = XEXP (op, 0);\n@@ -1292,16 +1272,14 @@ symbolic_operand (op, mode)\n #endif\n \n     default:\n-      return 0;\n+      return false;\n     }\n }\n \f\n /* Check for sign_extend or zero_extend.  Used for bit-count operands.  */\n \n int\n-extend_operator(x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+extend_operator(rtx x, enum machine_mode mode)\n {\n     if (mode != VOIDmode && GET_MODE(x) != mode)\n \treturn 0;\n@@ -1357,9 +1335,8 @@ extend_operator(x, mode)\n    handled.  */\n \n rtx\n-legitimize_pic_address (orig, mode, reg)\n-     rtx orig, reg;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t        rtx reg)\n {\n   rtx pic_ref = orig;\n \n@@ -1409,13 +1386,12 @@ legitimize_pic_address (orig, mode, reg)\n \f\n typedef enum { MOVL, SWAP, NEGW, NOTW, NOTB, MOVQ } CONST_METHOD;\n \n-static CONST_METHOD const_method PARAMS ((rtx));\n+static CONST_METHOD const_method (rtx);\n \n #define USE_MOVQ(i)\t((unsigned)((i) + 128) <= 255)\n \n static CONST_METHOD\n-const_method (constant)\n-     rtx constant;\n+const_method (rtx constant)\n {\n   int i;\n   unsigned u;\n@@ -1448,8 +1424,7 @@ const_method (constant)\n }\n \n static int\n-const_int_cost (constant)\n-     rtx constant;\n+const_int_cost (rtx constant)\n {\n   switch (const_method (constant))\n     {\n@@ -1470,10 +1445,7 @@ const_int_cost (constant)\n }\n \n static bool\n-m68k_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+m68k_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -1596,8 +1568,7 @@ m68k_rtx_costs (x, code, outer_code, total)\n }\n \n const char *\n-output_move_const_into_data_reg (operands)\n-     rtx *operands;\n+output_move_const_into_data_reg (rtx *operands)\n {\n   int i;\n \n@@ -1629,8 +1600,7 @@ output_move_const_into_data_reg (operands)\n }\n \n const char *\n-output_move_simode_const (operands)\n-     rtx *operands;\n+output_move_simode_const (rtx *operands)\n {\n   if (operands[1] == const0_rtx\n       && (DATA_REG_P (operands[0])\n@@ -1660,8 +1630,7 @@ output_move_simode_const (operands)\n }\n \n const char *\n-output_move_simode (operands)\n-     rtx *operands;\n+output_move_simode (rtx *operands)\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n     return output_move_simode_const (operands);\n@@ -1677,8 +1646,7 @@ output_move_simode (operands)\n }\n \n const char *\n-output_move_himode (operands)\n-     rtx *operands;\n+output_move_himode (rtx *operands)\n {\n  if (GET_CODE (operands[1]) == CONST_INT)\n     {\n@@ -1740,8 +1708,7 @@ output_move_himode (operands)\n }\n \n const char *\n-output_move_qimode (operands)\n-     rtx *operands;\n+output_move_qimode (rtx *operands)\n {\n   rtx xoperands[4];\n \n@@ -1806,8 +1773,7 @@ output_move_qimode (operands)\n }\n \n const char *\n-output_move_stricthi (operands)\n-     rtx *operands;\n+output_move_stricthi (rtx *operands)\n {\n   if (operands[1] == const0_rtx\n       /* clr insns on 68000 read before writing.\n@@ -1819,8 +1785,7 @@ output_move_stricthi (operands)\n }\n \n const char *\n-output_move_strictqi (operands)\n-     rtx *operands;\n+output_move_strictqi (rtx *operands)\n {\n   if (operands[1] == const0_rtx\n       /* clr insns on 68000 read before writing.\n@@ -1835,8 +1800,7 @@ output_move_strictqi (operands)\n    for moving operands[1] into operands[0] as a fullword.  */\n \n static const char *\n-singlemove_string (operands)\n-     rtx *operands;\n+singlemove_string (rtx *operands)\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n     return output_move_simode_const (operands);\n@@ -1848,8 +1812,7 @@ singlemove_string (operands)\n    with operands OPERANDS.  */\n \n const char *\n-output_move_double (operands)\n-     rtx *operands;\n+output_move_double (rtx *operands)\n {\n   enum\n     {\n@@ -2202,8 +2165,7 @@ output_move_double (operands)\n    ADDR can be effectively incremented by incrementing REG.  */\n \n static rtx\n-find_addr_reg (addr)\n-     rtx addr;\n+find_addr_reg (rtx addr)\n {\n   while (GET_CODE (addr) == PLUS)\n     {\n@@ -2226,8 +2188,7 @@ find_addr_reg (addr)\n /* Output assembler code to perform a 32 bit 3 operand add.  */\n \n const char *\n-output_addsi3 (operands)\n-     rtx *operands;\n+output_addsi3 (rtx *operands)\n {\n   if (! operands_match_p (operands[0], operands[1]))\n     {\n@@ -2249,8 +2210,7 @@ output_addsi3 (operands)\n \treturn \"lea 0(%1,%2.l),%0\";\n       else\n \treturn \"lea %c2(%1),%0\";\n-#else /* not SGS */\n-#ifdef MOTOROLA\n+#elif defined(MOTOROLA)\n       if (GET_CODE (operands[2]) == REG)\n \treturn \"lea (%1,%2.l),%0\";\n       else\n@@ -2261,7 +2221,6 @@ output_addsi3 (operands)\n       else\n \treturn \"lea %1@(%c2),%0\";\n #endif /* not MOTOROLA */\n-#endif /* not SGS */\n     }\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -2319,9 +2278,7 @@ output_addsi3 (operands)\n    some or all of the saved cc's so they won't be used.  */\n \n void\n-notice_update_cc (exp, insn)\n-     rtx exp;\n-     rtx insn;\n+notice_update_cc (rtx exp, rtx insn)\n {\n   if (GET_CODE (exp) == SET)\n     {\n@@ -2416,8 +2373,7 @@ notice_update_cc (exp, insn)\n }\n \f\n const char *\n-output_move_const_double (operands)\n-     rtx *operands;\n+output_move_const_double (rtx *operands)\n {\n   int code = standard_68881_constant_p (operands[1]);\n \n@@ -2432,8 +2388,7 @@ output_move_const_double (operands)\n }\n \n const char *\n-output_move_const_single (operands)\n-     rtx *operands;\n+output_move_const_single (rtx *operands)\n {\n   int code = standard_68881_constant_p (operands[1]);\n \n@@ -2482,7 +2437,7 @@ REAL_VALUE_TYPE values_68881[7];\n    strings_68881 to binary.  */\n \n void\n-init_68881_table ()\n+init_68881_table (void)\n {\n   int i;\n   REAL_VALUE_TYPE r;\n@@ -2500,8 +2455,7 @@ init_68881_table ()\n }\n \n int\n-standard_68881_constant_p (x)\n-     rtx x;\n+standard_68881_constant_p (rtx x)\n {\n   REAL_VALUE_TYPE r;\n   int i;\n@@ -2539,8 +2493,7 @@ standard_68881_constant_p (x)\n    or 0 if X is not a power of 2.  */\n \n int\n-floating_exact_log2 (x)\n-     rtx x;\n+floating_exact_log2 (rtx x)\n {\n   REAL_VALUE_TYPE r, r1;\n   int exp;\n@@ -2605,10 +2558,7 @@ floating_exact_log2 (x)\n    */\n \n void\n-print_operand (file, op, letter)\n-     FILE *file;\t\t/* file to write to */\n-     rtx op;\t\t\t/* operand to print */\n-     int letter;\t\t/* %<letter> or 0 */\n+print_operand (FILE *file, rtx op, int letter)\n {\n   if (letter == '.')\n     {\n@@ -2777,9 +2727,7 @@ print_operand (file, op, letter)\n #endif /* ASM_OUTPUT_CASE_FETCH */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   register rtx reg1, reg2, breg, ireg;\n   rtx offset;\n@@ -3085,11 +3033,9 @@ print_operand_address (file, addr)\n    insn we are checking for redundancy.  TARGET is the register set by the\n    clear insn.  */\n \n-int\n-strict_low_part_peephole_ok (mode, first_insn, target)\n-     enum machine_mode mode;\n-     rtx first_insn;\n-     rtx target;\n+bool\n+strict_low_part_peephole_ok (enum machine_mode mode, rtx first_insn,\n+                             rtx target)\n {\n   rtx p;\n \n@@ -3099,7 +3045,7 @@ strict_low_part_peephole_ok (mode, first_insn, target)\n     {\n       /* If it isn't an insn, then give up.  */\n       if (GET_CODE (p) != INSN)\n-\treturn 0;\n+\treturn false;\n \n       if (reg_set_p (target, p))\n \t{\n@@ -3108,15 +3054,15 @@ strict_low_part_peephole_ok (mode, first_insn, target)\n \n \t  /* If it isn't an easy to recognize insn, then give up.  */\n \t  if (! set)\n-\t    return 0;\n+\t    return false;\n \n \t  dest = SET_DEST (set);\n \n \t  /* If this sets the entire target register to zero, then our\n \t     first_insn is redundant.  */\n \t  if (rtx_equal_p (dest, target)\n \t      && SET_SRC (set) == const0_rtx)\n-\t    return 1;\n+\t    return true;\n \t  else if (GET_CODE (dest) == STRICT_LOW_PART\n \t\t   && GET_CODE (XEXP (dest, 0)) == REG\n \t\t   && REGNO (XEXP (dest, 0)) == REGNO (target)\n@@ -3126,24 +3072,22 @@ strict_low_part_peephole_ok (mode, first_insn, target)\n \t       we are using, so it is safe.  */\n \t    ;\n \t  else\n-\t    return 0;\n+\t    return false;\n \t}\n \n       p = prev_nonnote_insn (p);\n \n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Accept integer operands in the range 0..0xffffffff.  We have to check the\n    range carefully since this predicate is used in DImode contexts.  Also, we\n    need some extra crud to make it work when hosted on 64-bit machines.  */\n \n int\n-const_uint32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+const_uint32_operand (rtx op, enum machine_mode mode)\n {\n   /* It doesn't make sense to ask this question with a mode that is\n      not larger than 32 bits.  */\n@@ -3165,9 +3109,7 @@ const_uint32_operand (op, mode)\n    contexts.  */\n \n int\n-const_sint32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+const_sint32_operand (rtx op, enum machine_mode mode)\n {\n   /* It doesn't make sense to ask this question with a mode that is\n      not larger than 32 bits.  */\n@@ -3241,9 +3183,7 @@ const_sint32_operand (op, mode)\n    is specified.  */\n \n int\n-general_src_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+general_src_operand (rtx op, enum machine_mode mode)\n {\n   if (TARGET_PCREL\n       && GET_CODE (op) == MEM\n@@ -3259,9 +3199,7 @@ general_src_operand (op, mode)\n    is specified.  */\n \n int\n-nonimmediate_src_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+nonimmediate_src_operand (rtx op, enum machine_mode mode)\n {\n   if (TARGET_PCREL && GET_CODE (op) == MEM\n       && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n@@ -3276,9 +3214,7 @@ nonimmediate_src_operand (op, mode)\n    is specified.  */\n \n int\n-memory_src_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+memory_src_operand (rtx op, enum machine_mode mode)\n {\n   if (TARGET_PCREL && GET_CODE (op) == MEM\n       && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n@@ -3293,17 +3229,14 @@ memory_src_operand (op, mode)\n    \"general_src_operand\".  */\n \n int\n-pcrel_address (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+pcrel_address (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF\n \t  || GET_CODE (op) == CONST);\n }\n \n const char *\n-output_andsi3 (operands)\n-     rtx *operands;\n+output_andsi3 (rtx *operands)\n {\n   int logval;\n   if (GET_CODE (operands[2]) == CONST_INT\n@@ -3343,8 +3276,7 @@ output_andsi3 (operands)\n }\n \n const char *\n-output_iorsi3 (operands)\n-     rtx *operands;\n+output_iorsi3 (rtx *operands)\n {\n   register int logval;\n   if (GET_CODE (operands[2]) == CONST_INT\n@@ -3380,8 +3312,7 @@ output_iorsi3 (operands)\n }\n \n const char *\n-output_xorsi3 (operands)\n-     rtx *operands;\n+output_xorsi3 (rtx *operands)\n {\n   register int logval;\n   if (GET_CODE (operands[2]) == CONST_INT\n@@ -3418,9 +3349,7 @@ output_xorsi3 (operands)\n /* Output assembly to switch to section NAME with attribute FLAGS.  */\n \n static void\n-m68k_coff_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+m68k_coff_asm_named_section (const char *name, unsigned int flags)\n {\n   char flagchar;\n \n@@ -3434,9 +3363,7 @@ m68k_coff_asm_named_section (name, flags)\n \n #ifdef CTOR_LIST_BEGIN\n static void\n-m68k_svr3_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+m68k_svr3_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   rtx xop[2];\n \n@@ -3450,10 +3377,8 @@ m68k_svr3_asm_out_constructor (symbol, priority)\n \n #ifdef HPUX_ASM\n static void\n-m68k_hp320_internal_label (stream, prefix, labelno)\n-     FILE *stream;\n-     const char *prefix;\n-     unsigned long labelno;\n+m68k_hp320_internal_label (FILE *stream, const char *prefix,\n+                           unsigned long labelno)\n {\n   if (prefix[0] == 'L' && prefix[1] == 'I')\n     fprintf(stream, \"\\tset %s%ld,.+2\\n\", prefix, labelno);\n@@ -3462,7 +3387,7 @@ m68k_hp320_internal_label (stream, prefix, labelno)\n }\n \n static void\n-m68k_hp320_file_start ()\n+m68k_hp320_file_start (void)\n {\n   /* version 1: 68010.\n              2: 68020 without FPU.\n@@ -3473,12 +3398,10 @@ m68k_hp320_file_start ()\n #endif\n \n static void\n-m68k_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n-     tree function;\n+m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n+\t\t      HOST_WIDE_INT delta,\n+\t\t      HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t      tree function)\n {\n   rtx xops[1];\n   const char *fmt;"}]}