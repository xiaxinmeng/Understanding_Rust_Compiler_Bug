{"sha": "8c6d71c06b55848838ddc5303415908492bd6b72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM2ZDcxYzA2YjU1ODQ4ODM4ZGRjNTMwMzQxNTkwODQ5MmJkNmI3Mg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-03-27T20:14:44Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-03-27T20:14:44Z"}, "message": "re PR target/50751 (SH Target: Displacement addressing does not work for QImode and HImode)\n\n\tPR target/50751\n\t* config/sh/sh.c (sh_legitimize_address, sh_legitimize_reload_address):\n\tRearrange conditional logic.  Move displacement address calculations\n\tto ...\n\t(sh_find_mov_disp_adjust): ... this new function.\n\nFrom-SVN: r185894", "tree": {"sha": "7da79fd9722a00a7529e803fb18625774be979fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7da79fd9722a00a7529e803fb18625774be979fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c6d71c06b55848838ddc5303415908492bd6b72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6d71c06b55848838ddc5303415908492bd6b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c6d71c06b55848838ddc5303415908492bd6b72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6d71c06b55848838ddc5303415908492bd6b72/comments", "author": null, "committer": null, "parents": [{"sha": "719e1e80d46004d587edb7e51f04fb7718891741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/719e1e80d46004d587edb7e51f04fb7718891741", "html_url": "https://github.com/Rust-GCC/gccrs/commit/719e1e80d46004d587edb7e51f04fb7718891741"}], "stats": {"total": 220, "additions": 129, "deletions": 91}, "files": [{"sha": "cc4f0cb3a115fdf6743d5c561916075e5f89ad4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6d71c06b55848838ddc5303415908492bd6b72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6d71c06b55848838ddc5303415908492bd6b72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c6d71c06b55848838ddc5303415908492bd6b72", "patch": "@@ -1,3 +1,11 @@\n+2012-03-27  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50751\n+\t* config/sh/sh.c (sh_legitimize_address, sh_legitimize_reload_address):\n+\tRearrange conditional logic.  Move displacement address calculations\n+\tto ...\n+\t(sh_find_mov_disp_adjust): ... this new function.\n+\n 2012-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/arm/arm.opt (mapcs): Remove MaskExists."}, {"sha": "19973005be72579b5c9e4135ea60532374c06316", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 121, "deletions": 91, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6d71c06b55848838ddc5303415908492bd6b72/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6d71c06b55848838ddc5303415908492bd6b72/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=8c6d71c06b55848838ddc5303415908492bd6b72", "patch": "@@ -9783,80 +9783,114 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n   return orig;\n }\n \n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   Otherwise, return X.\n+/* Given a (logical) mode size and an offset in bytes, try to find a the\n+   appropriate displacement value for a mov insn.  On SH the displacements\n+   are limited to max. 60 bytes for SImode, max. 30 bytes in HImode and max.\n+   15 bytes in QImode.  To compensate this we create a new base address by\n+   adding an adjustment value to it.\n+\n+   If the originally requested offset is greater than 127 we prefer using\n+   values 124..127 over 128..131 to increase opportunities to use the\n+   add #imm, Rn insn.\n+\n+   In some cases it is possible that a requested offset might seem unaligned\n+   or inappropriate for the mode size, like offset = 2 and mode size = 4.\n+   This is compensated by adjusting the base address so that the effective\n+   address of the displacement move insn will be aligned. \n+\n+   This is not the best possible way of rebasing the base address, as it\n+   does not look at other present displacement addressings around it.\n+   In some cases this can create more base address adjustments than would\n+   actually be necessary.  */\n+\n+struct disp_adjust\n+{\n+  rtx offset_adjust;\n+  rtx mov_disp;\n+  int max_mov_disp;\n+};\n+\n+static struct disp_adjust\n+sh_find_mov_disp_adjust (int mode_sz, HOST_WIDE_INT offset)\n+{\n+  struct disp_adjust res = { NULL_RTX, NULL_RTX, 0 };\n+\n+  /* The max. available mode for actual move insns is SImode.\n+     Larger accesses will be split into multiple loads/stores.  */\n+  const int max_mov_sz = GET_MODE_SIZE (SImode);\n+\n+  const int mov_insn_size = mode_sz >= max_mov_sz ? max_mov_sz : mode_sz;\n+  const HOST_WIDE_INT max_disp = 15 * mov_insn_size;\n+  HOST_WIDE_INT align_modifier = offset > 127 ? mov_insn_size : 0;\n+\n+  HOST_WIDE_INT offset_adjust;\n+\n+  /* In some cases this actually does happen and we must check for it.  */\n+  if (mode_sz < 1 || mode_sz > 8)\n+    return res;\n \n-   For the SH, if X is almost suitable for indexing, but the offset is\n-   out of range, convert it into a normal form so that CSE has a chance\n-   of reducing the number of address registers used.  */\n+  /* FIXME: HImode with displacement addressing is not supported yet.\n+     Make it purposefully fail for now.  */\n+  if (mov_insn_size == 2)\n+    return res;\n+\n+  /* Keeps the previous behavior for QImode displacement addressing.\n+     This just decides how the offset is re-based.  Removing this special\n+     case will result in slightly bigger code on average, but it's not that\n+     bad actually.  */\n+  if (mov_insn_size == 1)\n+    align_modifier = 0;\n+\n+  res.max_mov_disp = max_disp + mov_insn_size;\n+\n+  offset_adjust = ((offset + align_modifier) & ~max_disp) - align_modifier;\n+\n+  if (mode_sz + offset - offset_adjust <= res.max_mov_disp)\n+    {\n+      res.offset_adjust = GEN_INT (offset_adjust);\n+      res.mov_disp = GEN_INT (offset - offset_adjust);\n+    }\n+\n+  return res;\n+}\n+\n+/* Try to modify an illegitimate address and make it legitimate.\n+   If we find one, return the new, valid address.\n+   Otherwise, return the original address.  */\n \n static rtx\n sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n {\n   if (flag_pic)\n     x = legitimize_pic_address (oldx, mode, NULL_RTX);\n \n-  if (GET_CODE (x) == PLUS\n-      && (GET_MODE_SIZE (mode) == 4\n-\t  || GET_MODE_SIZE (mode) == 8)\n-      && CONST_INT_P (XEXP (x, 1))\n-      && BASE_REGISTER_RTX_P (XEXP (x, 0))\n-      && ! TARGET_SHMEDIA\n-      && ! ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && mode == DFmode)\n-      && ! (TARGET_SH2E && mode == SFmode))\n-    {\n-      rtx index_rtx = XEXP (x, 1);\n-      HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\n-      rtx sum;\n-\n-      /* On rare occasions, we might get an unaligned pointer\n-\t that is indexed in a way to give an aligned address.\n-\t Therefore, keep the lower two bits in offset_base.  */\n-      /* Instead of offset_base 128..131 use 124..127, so that\n-\t simple add suffices.  */\n-      if (offset > 127)\n-\toffset_base = ((offset + 4) & ~60) - 4;\n-      else\n-\toffset_base = offset & ~60;\n-\n-      /* Sometimes the normal form does not suit DImode.  We\n-\t could avoid that by using smaller ranges, but that\n-\t would give less optimized code when SImode is\n-\t prevalent.  */\n-      if (GET_MODE_SIZE (mode) + offset - offset_base <= 64)\n-\t{\n-\t  sum = expand_binop (Pmode, add_optab, XEXP (x, 0),\n-\t\t\t      GEN_INT (offset_base), NULL_RTX, 0,\n-\t\t\t      OPTAB_LIB_WIDEN);\n+  if (TARGET_SHMEDIA)\n+    return x;\n \n-\t  return gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base));\n-\t}\n-    }\n+  if (((TARGET_SH4 || TARGET_SH2A_DOUBLE) && mode == DFmode)\n+      || (TARGET_SH2E && mode == SFmode))\n+    return x;\n \n-  /* This could be generalized for SImode, HImode, QImode displacement\n-     addressing.  */\n-  if (mode == QImode && GET_CODE (x) == PLUS\n-      && BASE_REGISTER_RTX_P (XEXP (x, 0)) && CONST_INT_P (XEXP (x, 1)))\n+  if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1))\n+      && BASE_REGISTER_RTX_P (XEXP (x, 0)))\n     {\n-      rtx index_rtx = XEXP (x, 1);\n-      HOST_WIDE_INT offset = INTVAL (index_rtx);\n-      HOST_WIDE_INT offset_base = offset & ~15;\n-    \n-      if (offset - offset_base <= 16)\n+      const int mode_sz = GET_MODE_SIZE (mode);\n+      struct disp_adjust adj = sh_find_mov_disp_adjust (mode_sz,\n+\t\t\t\t\t\t\tINTVAL (XEXP (x, 1)));\n+\n+      if (adj.offset_adjust != NULL_RTX && adj.mov_disp != NULL_RTX)\n \t{\n \t  rtx sum = expand_binop (Pmode, add_optab, XEXP (x, 0),\n-\t\t\t      GEN_INT (offset_base), NULL_RTX, 0,\n-\t\t\t      OPTAB_LIB_WIDEN);\n-\n-\t  return gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base));\n+\t\t\t\t  adj.offset_adjust, NULL_RTX, 0,\n+\t\t\t\t  OPTAB_LIB_WIDEN);\n+\t  return gen_rtx_PLUS (Pmode, sum, adj.mov_disp);\n \t}\n     }\n \n   return x;\n }\n \n-/* Attempt to replace *P, which is an address that needs reloading, with\n+/* Attempt to replace *p, which is an address that needs reloading, with\n    a valid memory address for an operand of mode MODE.\n    Like for sh_legitimize_address, for the SH we try to get a normal form\n    of the address.  That will allow inheritance of the address reloads.  */\n@@ -9866,75 +9900,71 @@ sh_legitimize_reload_address (rtx *p, enum machine_mode mode, int opnum,\n \t\t\t      int itype)\n {\n   enum reload_type type = (enum reload_type) itype;\n+  const int mode_sz = GET_MODE_SIZE (mode);\n \n-  if (GET_CODE (*p) == PLUS\n-      && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n-      && CONST_INT_P (XEXP (*p, 1))\n+  if (TARGET_SHMEDIA)\n+    return false;\n+\n+  if (GET_CODE (*p) == PLUS && CONST_INT_P (XEXP (*p, 1))\n       && MAYBE_BASE_REGISTER_RTX_P (XEXP (*p, 0), true)\n-      && ! TARGET_SHMEDIA\n-      && ! (TARGET_SH4 && mode == DFmode)\n       && ! (mode == PSImode && type == RELOAD_FOR_INPUT_ADDRESS)\n       && (ALLOW_INDEXED_ADDRESS\n \t  || XEXP (*p, 0) == stack_pointer_rtx\n \t  || XEXP (*p, 0) == hard_frame_pointer_rtx))\n     {\n-      rtx index_rtx = XEXP (*p, 1);\n-      HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\n-      rtx sum;\n+      const HOST_WIDE_INT offset = INTVAL (XEXP (*p, 1));\n+      struct disp_adjust adj = sh_find_mov_disp_adjust (mode_sz, offset);\n \n       if (TARGET_SH2A && mode == DFmode && (offset & 0x7))\n \t{\n \t  push_reload (*p, NULL_RTX, p, NULL,\n \t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);\n-\t  goto win;\n+\t  return true;\n \t}\n+\n       if (TARGET_SH2E && mode == SFmode)\n \t{\n \t  *p = copy_rtx (*p);\n \t  push_reload (*p, NULL_RTX, p, NULL,\n \t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);\n-\t  goto win;\n+\t  return true;\n \t}\n-      /* Instead of offset_base 128..131 use 124..127, so that\n-\t simple add suffices.  */\n-      if (offset > 127)\n-\toffset_base = ((offset + 4) & ~60) - 4;\n-      else\n-\toffset_base = offset & ~60;\n-      /* Sometimes the normal form does not suit DImode.  We could avoid\n-\t that by using smaller ranges, but that would give less optimized\n-\t code when SImode is prevalent.  */\n-      if (GET_MODE_SIZE (mode) + offset - offset_base <= 64)\n-\t{\n-\t  sum = gen_rtx_PLUS (Pmode, XEXP (*p, 0), GEN_INT (offset_base));\n-\t  *p = gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base));\n+\n+      /* FIXME: Do not allow to legitimize QImode and HImode displacement\n+\t moves because then reload has a problem figuring the constraint\n+\t that the move insn target/source reg must be R0.\n+\t Or maybe some handling is wrong in sh_secondary_reload for this\n+\t to work properly? */\n+      if ((mode_sz == 4 || mode_sz == 8)\n+\t  && ! (TARGET_SH4 && mode == DFmode)\n+\t  && adj.offset_adjust != NULL_RTX && adj.mov_disp != NULL_RTX)\n+\t{\n+\t  rtx sum = gen_rtx_PLUS (Pmode, XEXP (*p, 0), adj.offset_adjust);\n+\t  *p = gen_rtx_PLUS (Pmode, sum, adj.mov_disp);\n \t  push_reload (sum, NULL_RTX, &XEXP (*p, 0), NULL,\n \t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);\n-\t  goto win;\n+\t  return true;\n \t}\n     }\n+\n   /* We must re-recognize what we created before.  */\n-  else if (GET_CODE (*p) == PLUS\n-\t   && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n-\t   && GET_CODE (XEXP (*p, 0)) == PLUS\n-\t   && CONST_INT_P (XEXP (XEXP (*p, 0), 1))\n-\t   && MAYBE_BASE_REGISTER_RTX_P (XEXP (XEXP (*p, 0), 0), true)\n-\t   && CONST_INT_P (XEXP (*p, 1))\n-\t   && ! TARGET_SHMEDIA\n-\t   && ! (TARGET_SH2E && mode == SFmode))\n+  if (GET_CODE (*p) == PLUS\n+      && (mode_sz == 4 || mode_sz == 8)\n+      && GET_CODE (XEXP (*p, 0)) == PLUS\n+      && CONST_INT_P (XEXP (XEXP (*p, 0), 1))\n+      && MAYBE_BASE_REGISTER_RTX_P (XEXP (XEXP (*p, 0), 0), true)\n+      && CONST_INT_P (XEXP (*p, 1))\n+      && ! (TARGET_SH2E && mode == SFmode))\n     {\n       /* Because this address is so complex, we know it must have\n \t been created by LEGITIMIZE_RELOAD_ADDRESS before; thus,\n \t it is already unshared, and needs no further unsharing.  */\n       push_reload (XEXP (*p, 0), NULL_RTX, &XEXP (*p, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);\n-      goto win;\n+      return true;\n     }\n \n   return false;\n-\n- win:\n-  return true;\n }\n \n /* In the name of slightly smaller debug output, and to cater to"}]}