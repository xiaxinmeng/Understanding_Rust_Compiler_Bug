{"sha": "5493aa17a2da3923ee306b413ada64cc09549e74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ5M2FhMTdhMmRhMzkyM2VlMzA2YjQxM2FkYTY0Y2MwOTU0OWU3NA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-06-08T06:28:41Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-06-08T06:28:41Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-06-08  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.h (gfc_statement): Add ST_LOCK and ST_UNLOCK.\n        (gfc_exec_op): Add EXEC_LOCK and EXEC_UNLOCK.\n        (gfc_code): Add expr4.\n        * match.h (gfc_match_lock, gfc_match_unlock): New prototypes.\n        * match.c (gfc_match_lock, gfc_match_unlock,\n        lock_unlock_statement): New functions.\n        (sync_statement): Bug fix, avoiding double freeing.\n        (gfc_match_if): Handle LOCK/UNLOCK statement.\n        * parse.c (decode_statement, next_statement,\n        gfc_ascii_statement): Ditto.\n        * st.c (gfc_free_statement): Handle LOCK and UNLOCK.\n        * resolve.c (resolve_lock_unlock): New function.\n        (resolve_code): Call it.\n        * dump-parse-tree.c (show_code_node): Handle LOCK/UNLOCK.\n        * frontend-passes.c (gfc_code_walker): Optimize gfc_code's expr4.\n\n2011-06-08  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_lock_1.f90: New.\n        * gfortran.dg/coarray_lock_2.f90: New.\n\nFrom-SVN: r174796", "tree": {"sha": "2bbcfee69dbbc562c058ffd1078f6f90732ef100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bbcfee69dbbc562c058ffd1078f6f90732ef100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5493aa17a2da3923ee306b413ada64cc09549e74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5493aa17a2da3923ee306b413ada64cc09549e74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5493aa17a2da3923ee306b413ada64cc09549e74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5493aa17a2da3923ee306b413ada64cc09549e74/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c2bbcb0db139ca738743376d429b0745a9b684d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2bbcb0db139ca738743376d429b0745a9b684d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2bbcb0db139ca738743376d429b0745a9b684d8"}], "stats": {"total": 346, "additions": 337, "deletions": 9}, "files": [{"sha": "c77c6edfdb642ae410501ac8e8490aec78c16f46", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -1,3 +1,21 @@\n+2011-06-08  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.h (gfc_statement): Add ST_LOCK and ST_UNLOCK.\n+\t(gfc_exec_op): Add EXEC_LOCK and EXEC_UNLOCK.\n+\t(gfc_code): Add expr4.\n+\t* match.h (gfc_match_lock, gfc_match_unlock): New prototypes.\n+\t* match.c (gfc_match_lock, gfc_match_unlock,\n+\tlock_unlock_statement): New functions.\n+\t(sync_statement): Bug fix, avoiding double freeing.\n+\t(gfc_match_if): Handle LOCK/UNLOCK statement.\n+\t* parse.c (decode_statement, next_statement,\n+\tgfc_ascii_statement): Ditto.\n+\t* st.c (gfc_free_statement): Handle LOCK and UNLOCK.\n+\t* resolve.c (resolve_lock_unlock): New function.\n+\t(resolve_code): Call it.\n+\t* dump-parse-tree.c (show_code_node): Handle LOCK/UNLOCK.\n+\n 2011-06-07  Richard Guenther  <rguenther@suse.de>\n \n \t* f95-lang.c (gfc_init_decl_processing): Do not set"}, {"sha": "87b8b68408f317fa8bd5aec965566a9aff20a1a4", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -1396,6 +1396,33 @@ show_code_node (int level, gfc_code *c)\n \t}\n       break;\n \n+    case EXEC_LOCK:\n+    case EXEC_UNLOCK:\n+      if (c->op == EXEC_LOCK)\n+\tfputs (\"LOCK \", dumpfile);\n+      else\n+\tfputs (\"UNLOCK \", dumpfile);\n+\n+      fputs (\"lock-variable=\", dumpfile);\n+      if (c->expr1 != NULL)\n+\tshow_expr (c->expr1);\n+      if (c->expr4 != NULL)\n+\t{\n+\t  fputs (\" acquired_lock=\", dumpfile);\n+\t  show_expr (c->expr4);\n+\t}\n+      if (c->expr2 != NULL)\n+\t{\n+\t  fputs (\" stat=\", dumpfile);\n+\t  show_expr (c->expr2);\n+\t}\n+      if (c->expr3 != NULL)\n+\t{\n+\t  fputs (\" errmsg=\", dumpfile);\n+\t  show_expr (c->expr3);\n+\t}\n+      break;\n+\n     case EXEC_ARITHMETIC_IF:\n       fputs (\"IF \", dumpfile);\n       show_expr (c->expr1);"}, {"sha": "f100e1fb811a7a642929c69e31a213d07256287c", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -1190,6 +1190,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t  WALK_SUBEXPR (co->expr1);\n \t  WALK_SUBEXPR (co->expr2);\n \t  WALK_SUBEXPR (co->expr3);\n+\t  WALK_SUBEXPR (co->expr4);\n \t  for (b = co->block; b; b = b->block)\n \t    {\n \t      WALK_SUBEXPR (b->expr1);"}, {"sha": "f23fbbd4d1288ad9c275408eabe20a9ec20db427", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -208,7 +208,7 @@ typedef enum\n   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n   ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_OMP_TASK, ST_OMP_END_TASK,\n   ST_OMP_TASKWAIT, ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n-  ST_GET_FCN_CHARACTERISTICS, ST_NONE\n+  ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE\n }\n gfc_statement;\n \n@@ -2056,6 +2056,7 @@ typedef enum\n   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n+  EXEC_LOCK, EXEC_UNLOCK,\n   EXEC_OMP_CRITICAL, EXEC_OMP_DO, EXEC_OMP_FLUSH, EXEC_OMP_MASTER,\n   EXEC_OMP_ORDERED, EXEC_OMP_PARALLEL, EXEC_OMP_PARALLEL_DO,\n   EXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,\n@@ -2074,7 +2075,7 @@ typedef struct gfc_code\n \n   gfc_st_label *here, *label1, *label2, *label3;\n   gfc_symtree *symtree;\n-  gfc_expr *expr1, *expr2, *expr3;\n+  gfc_expr *expr1, *expr2, *expr3, *expr4;\n   /* A name isn't sufficient to identify a subroutine, we need the actual\n      symbol for the interface definition.\n   const char *sub_name;  */"}, {"sha": "43aeb19f939269c779ec8107585cee4e862a1721", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 196, "deletions": 6, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -1561,6 +1561,7 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"go to\", gfc_match_goto, ST_GOTO)\n   match (\"if\", match_arithmetic_if, ST_ARITHMETIC_IF)\n   match (\"inquire\", gfc_match_inquire, ST_INQUIRE)\n+  match (\"lock\", gfc_match_lock, ST_LOCK)\n   match (\"nullify\", gfc_match_nullify, ST_NULLIFY)\n   match (\"open\", gfc_match_open, ST_OPEN)\n   match (\"pause\", gfc_match_pause, ST_NONE)\n@@ -1573,6 +1574,7 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"sync all\", gfc_match_sync_all, ST_SYNC_CALL);\n   match (\"sync images\", gfc_match_sync_images, ST_SYNC_IMAGES);\n   match (\"sync memory\", gfc_match_sync_memory, ST_SYNC_MEMORY);\n+  match (\"unlock\", gfc_match_unlock, ST_UNLOCK)\n   match (\"where\", match_simple_where, ST_WHERE)\n   match (\"write\", gfc_match_write, ST_WRITE)\n \n@@ -2305,6 +2307,190 @@ gfc_match_error_stop (void)\n }\n \n \n+/* Match LOCK/UNLOCK statement. Syntax:\n+     LOCK ( lock-variable [ , lock-stat-list ] )\n+     UNLOCK ( lock-variable [ , sync-stat-list ] )\n+   where lock-stat is ACQUIRED_LOCK or sync-stat\n+   and sync-stat is STAT= or ERRMSG=.  */\n+\n+static match\n+lock_unlock_statement (gfc_statement st)\n+{\n+  match m;\n+  gfc_expr *tmp, *lockvar, *acq_lock, *stat, *errmsg;\n+  bool saw_acq_lock, saw_stat, saw_errmsg;\n+\n+  tmp = lockvar = acq_lock = stat = errmsg = NULL;\n+  saw_acq_lock = saw_stat = saw_errmsg = false;\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error (\"Image control statement SYNC at %C in PURE procedure\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+    {\n+       gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+       return MATCH_ERROR;\n+    }\n+\n+  if (gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+    {\n+      gfc_error (\"Image control statement SYNC at %C in CRITICAL block\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    goto syntax;\n+\n+  if (gfc_match (\"%e\", &lockvar) != MATCH_YES)\n+    goto syntax;\n+  m = gfc_match_char (',');\n+  if (m == MATCH_ERROR)\n+    goto syntax;\n+  if (m == MATCH_NO)\n+    {\n+      m = gfc_match_char (')');\n+      if (m == MATCH_YES)\n+\tgoto done;\n+      goto syntax;\n+    }\n+\n+  for (;;)\n+    {\n+      m = gfc_match (\" stat = %v\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto syntax;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (saw_stat)\n+\t    {\n+\t      gfc_error (\"Redundant STAT tag found at %L \", &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\t  stat = tmp;\n+\t  saw_stat = true;\n+\n+\t  m = gfc_match_char (',');\n+\t  if (m == MATCH_YES)\n+\t    continue;\n+\n+\t  tmp = NULL;\n+\t  break;\n+\t}\n+\n+      m = gfc_match (\" errmsg = %v\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto syntax;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (saw_errmsg)\n+\t    {\n+\t      gfc_error (\"Redundant ERRMSG tag found at %L \", &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\t  errmsg = tmp;\n+\t  saw_errmsg = true;\n+\n+\t  m = gfc_match_char (',');\n+\t  if (m == MATCH_YES)\n+\t    continue;\n+\n+\t  tmp = NULL;\n+\t  break;\n+\t}\n+\n+      m = gfc_match (\" acquired_lock = %v\", &tmp);\n+      if (m == MATCH_ERROR || st == ST_UNLOCK)\n+\tgoto syntax;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (saw_acq_lock)\n+\t    {\n+\t      gfc_error (\"Redundant ACQUIRED_LOCK tag found at %L \",\n+\t\t\t &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\t  acq_lock = tmp;\n+\t  saw_acq_lock = true;\n+\n+\t  m = gfc_match_char (',');\n+\t  if (m == MATCH_YES)\n+\t    continue;\n+\n+\t  tmp = NULL;\n+\t  break;\n+\t}\n+\n+      break;\n+    }\n+\n+  if (m == MATCH_ERROR)\n+    goto syntax;\n+\n+  if (gfc_match (\" )%t\") != MATCH_YES)\n+    goto syntax;\n+\n+done:\n+  switch (st)\n+    {\n+    case ST_LOCK:\n+      new_st.op = EXEC_LOCK;\n+      break;\n+    case ST_UNLOCK:\n+      new_st.op = EXEC_UNLOCK;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  new_st.expr1 = lockvar;\n+  new_st.expr2 = stat;\n+  new_st.expr3 = errmsg;\n+  new_st.expr4 = acq_lock;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (st);\n+\n+cleanup:\n+  gfc_free_expr (tmp);\n+  gfc_free_expr (lockvar);\n+  gfc_free_expr (acq_lock);\n+  gfc_free_expr (stat);\n+  gfc_free_expr (errmsg);\n+\n+  return MATCH_ERROR;\n+}\n+\n+\n+match\n+gfc_match_lock (void)\n+{\n+  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: LOCK statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return lock_unlock_statement (ST_LOCK);\n+}\n+\n+\n+match\n+gfc_match_unlock (void)\n+{\n+  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: UNLOCK statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return lock_unlock_statement (ST_UNLOCK);\n+}\n+\n+\n /* Match SYNC ALL/IMAGES/MEMORY statement. Syntax:\n      SYNC ALL [(sync-stat-list)]\n      SYNC MEMORY [(sync-stat-list)]\n@@ -2345,7 +2531,7 @@ sync_statement (gfc_statement st)\n       gfc_error (\"Image control statement SYNC at %C in CRITICAL block\");\n       return MATCH_ERROR;\n     }\n-\t\n+\n   if (gfc_match_eos () == MATCH_YES)\n     {\n       if (st == ST_SYNC_IMAGES)\n@@ -2396,6 +2582,9 @@ sync_statement (gfc_statement st)\n \n \t  if (gfc_match_char (',') == MATCH_YES)\n \t    continue;\n+\n+\t  tmp = NULL;\n+\t  break;\n \t}\n \n       m = gfc_match (\" errmsg = %v\", &tmp);\n@@ -2413,16 +2602,17 @@ sync_statement (gfc_statement st)\n \n \t  if (gfc_match_char (',') == MATCH_YES)\n \t    continue;\n-\t}\n \n-      gfc_gobble_whitespace ();\n+\t  tmp = NULL;\n+\t  break;\n+\t}\n \n-      if (gfc_peek_char () == ')')\n \tbreak;\n-\n-      goto syntax;\n     }\n \n+  if (m == MATCH_ERROR)\n+    goto syntax;\n+\n   if (gfc_match (\" )%t\") != MATCH_YES)\n     goto syntax;\n "}, {"sha": "5a40d7a173a11f03d28d069753acfcc0575c5a12", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -74,6 +74,7 @@ match gfc_match_associate (void);\n match gfc_match_do (void);\n match gfc_match_cycle (void);\n match gfc_match_exit (void);\n+match gfc_match_lock (void);\n match gfc_match_pause (void);\n match gfc_match_stop (void);\n match gfc_match_error_stop (void);\n@@ -83,6 +84,7 @@ match gfc_match_goto (void);\n match gfc_match_sync_all (void);\n match gfc_match_sync_images (void);\n match gfc_match_sync_memory (void);\n+match gfc_match_unlock (void);\n \n match gfc_match_allocate (void);\n match gfc_match_nullify (void);"}, {"sha": "6013931d355b1d13f5427cbc1e7beb611bfd078f", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -398,6 +398,10 @@ decode_statement (void)\n       match (\"intrinsic\", gfc_match_intrinsic, ST_ATTR_DECL);\n       break;\n \n+    case 'l':\n+      match (\"lock\", gfc_match_lock, ST_LOCK);\n+      break;\n+\n     case 'm':\n       match (\"module% procedure\", gfc_match_modproc, ST_MODULE_PROC);\n       match (\"module\", gfc_match_module, ST_MODULE);\n@@ -449,6 +453,7 @@ decode_statement (void)\n       break;\n \n     case 'u':\n+      match (\"unlock\", gfc_match_unlock, ST_UNLOCK);\n       match (\"use\", gfc_match_use, ST_USE);\n       break;\n \n@@ -953,7 +958,8 @@ next_statement (void)\n   case ST_ASSIGNMENT: case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n   case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_ERROR_STOP: \\\n-  case ST_SYNC_ALL: case ST_SYNC_IMAGES: case ST_SYNC_MEMORY\n+  case ST_SYNC_ALL: case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: \\\n+  case ST_LOCK: case ST_UNLOCK\n \n /* Statements that mark other executable statements.  */\n \n@@ -1334,6 +1340,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_INTERFACE:\n       p = \"INTERFACE\";\n       break;\n+    case ST_LOCK:\n+      p = \"LOCK\";\n+      break;\n     case ST_PARAMETER:\n       p = \"PARAMETER\";\n       break;\n@@ -1394,6 +1403,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_TYPE:\n       p = \"TYPE\";\n       break;\n+    case ST_UNLOCK:\n+      p = \"UNLOCK\";\n+      break;\n     case ST_USE:\n       p = \"USE\";\n       break;"}, {"sha": "b2c31892eb46ca6ca554c08775866c11fef69175", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -8198,6 +8198,40 @@ find_reachable_labels (gfc_code *block)\n }\n \n \n+static void\n+resolve_lock_unlock (gfc_code *code)\n+{\n+  /* FIXME: Add more lock-variable checks. For now, always reject it.\n+     Note that ISO_FORTRAN_ENV's LOCK_TYPE is not yet available.  */\n+  /* if (code->expr2->ts.type != BT_DERIVED\n+\t || code->expr2->rank != 0\n+\t || code->expr2->expr_type != EXPR_VARIABLE)  */\n+  gfc_error (\"Lock variable at %L must be a scalar of type LOCK_TYPE\",\n+\t     &code->expr1->where);\n+\n+  /* Check STAT.  */\n+  if (code->expr2\n+      && (code->expr2->ts.type != BT_INTEGER || code->expr2->rank != 0\n+\t  || code->expr2->expr_type != EXPR_VARIABLE))\n+    gfc_error (\"STAT= argument at %L must be a scalar INTEGER variable\",\n+\t       &code->expr2->where);\n+\n+  /* Check ERRMSG.  */\n+  if (code->expr3\n+      && (code->expr3->ts.type != BT_CHARACTER || code->expr3->rank != 0\n+\t  || code->expr3->expr_type != EXPR_VARIABLE))\n+    gfc_error (\"ERRMSG= argument at %L must be a scalar CHARACTER variable\",\n+\t       &code->expr3->where);\n+\n+  /* Check ACQUIRED_LOCK.  */\n+  if (code->expr4\n+      && (code->expr4->ts.type != BT_LOGICAL || code->expr4->rank != 0\n+\t  || code->expr4->expr_type != EXPR_VARIABLE))\n+    gfc_error (\"ACQUIRED_LOCK= argument at %L must be a scalar LOGICAL \"\n+\t       \"variable\", &code->expr4->where);\n+}\n+\n+\n static void\n resolve_sync (gfc_code *code)\n {\n@@ -9065,6 +9099,11 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  resolve_sync (code);\n \t  break;\n \n+\tcase EXEC_LOCK:\n+\tcase EXEC_UNLOCK:\n+\t  resolve_lock_unlock (code);\n+\t  break;\n+\n \tcase EXEC_ENTRY:\n \t  /* Keep track of which entry we are up to.  */\n \t  current_entry_id = code->ext.entry->id;"}, {"sha": "cedb97c7d553b4aeb4716b620f1037b6503de1d5", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -113,6 +113,8 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_SYNC_ALL:\n     case EXEC_SYNC_IMAGES:\n     case EXEC_SYNC_MEMORY:\n+    case EXEC_LOCK:\n+    case EXEC_UNLOCK:\n       break;\n \n     case EXEC_BLOCK:"}, {"sha": "184dcdd9348c5f40a7226948286c74114a4e2876", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -1,3 +1,9 @@\n+2011-06-08  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_lock_1.f90: New.\n+\t* gfortran.dg/coarray_lock_2.f90: New.\n+\n 2011-06-07  Jason Merrill  <jason@redhat.com>\n \n \t* lib/prune.exp: Look for \"required\" rather than \"instantiated\"."}, {"sha": "419ba47bab1c156e2e079701d30e7d06357b7059", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_1.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -std=f2008\" }\n+!\n+! LOCK/UNLOCK intrinsics\n+!\n+! PR fortran/18918\n+!\n+integer :: a[*]\n+integer :: s\n+character(len=3) :: c\n+logical :: bool\n+\n+LOCK (a, stat=s, acquired_lock=bool, errmsg=c) ! { dg-error \"must be a scalar of type LOCK_TYPE\" }\n+UNLOCK (a, stat=s, errmsg=c) ! { dg-error \"must be a scalar of type LOCK_TYPE\" }\n+end"}, {"sha": "243024084a10774a0bf22d55b644f7fb8e877383", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5493aa17a2da3923ee306b413ada64cc09549e74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_2.f90?ref=5493aa17a2da3923ee306b413ada64cc09549e74", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -std=f2003\" }\n+!\n+! LOCK/UNLOCK intrinsics\n+!\n+! PR fortran/18918\n+!\n+integer :: a[*] ! { dg-error \"Fortran 2008: Coarray declaration\" }\n+integer :: s\n+character(len=3) :: c\n+logical :: bool\n+\n+LOCK (a, stat=s, acquired_lock=bool, errmsg=c) ! { dg-error \"Fortran 2008: LOCK statement\" }\n+UNLOCK (a, stat=s, errmsg=c) ! { dg-error \"Fortran 2008: UNLOCK statement\" }\n+end"}]}