{"sha": "5aa33bdb4f75939b9467a4580aa13bb6997f192c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFhMzNiZGI0Zjc1OTM5Yjk0NjdhNDU4MGFhMTNiYjY5OTdmMTkyYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-07-23T22:36:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-07-23T22:36:47Z"}, "message": "Makefile.in (site.exp): Add HOSTCC and HOSTCFLAGS to site.exp.\n\n\t* Makefile.in (site.exp): Add HOSTCC and HOSTCFLAGS to site.exp.\ntestsuite/\n\t* README.compat: Add RUN_ALL_COMPAT_TESTS documentation.\n\t* lib/compat.exp: Replace ^$tmpdir/? in testcase names with tmpdir-.\n\t* gcc.dg/compat/struct-layout-1.exp: New testsuite driver.\n\t* gcc.dg/compat/struct-layout-1_generate.c: New testcase generator.\n\t* gcc.dg/compat/generate-random.c: New file.\n\t* gcc.dg/compat/generate-random.h: Likewise.\n\t* gcc.dg/compat/generate-random_r.c: Likewise.\n\t* gcc.dg/compat/struct-layout-1.h: Likewise.\n\t* gcc.dg/compat/struct-layout-1_x1.h: Likewise.\n\t* gcc.dg/compat/struct-layout-1_x2.h: Likewise.\n\t* gcc.dg/compat/struct-layout-1_y1.h: Likewise.\n\t* gcc.dg/compat/struct-layout-1_y2.h: Likewise.\n\t* gcc.dg/compat/struct-layout-1_main.c: New test.\n\t* gcc.dg/compat/struct-layout-1_x.c: New file.\n\t* gcc.dg/compat/struct-layout-1_y.c: New file.\n\t* gcc.dg/compat/struct-layout-1_test.h: New file.\n\nFrom-SVN: r85098", "tree": {"sha": "6e81a136c9838c5e192cbec549d71cd4f3c193ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e81a136c9838c5e192cbec549d71cd4f3c193ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5aa33bdb4f75939b9467a4580aa13bb6997f192c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa33bdb4f75939b9467a4580aa13bb6997f192c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa33bdb4f75939b9467a4580aa13bb6997f192c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa33bdb4f75939b9467a4580aa13bb6997f192c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec5c28ece1abe76452e1c70918fb44c543b71a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5c28ece1abe76452e1c70918fb44c543b71a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5c28ece1abe76452e1c70918fb44c543b71a81"}], "stats": {"total": 3181, "additions": 3181, "deletions": 0}, "files": [{"sha": "81a50a62c60be55dbf9e3b8042cb408f2d5ce4b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -1,3 +1,7 @@\n+2004-07-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* Makefile.in (site.exp): Add HOSTCC and HOSTCFLAGS to site.exp.\n+\n 2004-07-23  Zack Weinberg  <zack@codesourcery.com>\n \n \t* print-rtl.c (print_rtx <case 'b'>): Don't attempt to print"}, {"sha": "546b69a108478fb21036ef913fb5a06426b0902e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -3417,6 +3417,8 @@ site.exp: ./config.status Makefile\n # CFLAGS is set even though it's empty to show we reserve the right to set it.\n \t@echo \"set CFLAGS \\\"\\\"\" >> ./tmp0\n \t@echo \"set CXXFLAGS \\\"\\\"\" >> ./tmp0\n+\t@echo \"set HOSTCC \\\"$(CC)\\\"\" >> ./tmp0\n+\t@echo \"set HOSTCFLAGS \\\"$(CFLAGS)\\\"\" >> ./tmp0\n \t@echo \"set TESTING_IN_BUILD_TREE 1\" >> ./tmp0\n \t@echo \"set HAVE_LIBSTDCXX_V3 1\" >> ./tmp0\n # If newlib has been configured, we need to pass -B to gcc so it can find"}, {"sha": "bc7d6f6ce78274ce12ebdf63b9e4ad0dedf94f48", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -1,3 +1,22 @@\n+2004-07-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* README.compat: Add RUN_ALL_COMPAT_TESTS documentation.\n+\t* lib/compat.exp: Replace ^$tmpdir/? in testcase names with tmpdir-.\n+\t* gcc.dg/compat/struct-layout-1.exp: New testsuite driver.\n+\t* gcc.dg/compat/struct-layout-1_generate.c: New testcase generator.\n+\t* gcc.dg/compat/generate-random.c: New file.\n+\t* gcc.dg/compat/generate-random.h: Likewise.\n+\t* gcc.dg/compat/generate-random_r.c: Likewise.\n+\t* gcc.dg/compat/struct-layout-1.h: Likewise.\n+\t* gcc.dg/compat/struct-layout-1_x1.h: Likewise.\n+\t* gcc.dg/compat/struct-layout-1_x2.h: Likewise.\n+\t* gcc.dg/compat/struct-layout-1_y1.h: Likewise.\n+\t* gcc.dg/compat/struct-layout-1_y2.h: Likewise.\n+\t* gcc.dg/compat/struct-layout-1_main.c: New test.\n+\t* gcc.dg/compat/struct-layout-1_x.c: New file.\n+\t* gcc.dg/compat/struct-layout-1_y.c: New file.\n+\t* gcc.dg/compat/struct-layout-1_test.h: New file.\n+\n 2004-07-23  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* gcc.dg/comp-return-1.c: New test"}, {"sha": "b78718ff2d6b32886332739863b87fa517f246b3", "filename": "gcc/testsuite/README.compat", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2FREADME.compat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2FREADME.compat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FREADME.compat?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -29,6 +29,11 @@ sets of compiler options.\n   varible ALT_LD_LIBRARY_PATH.  If it needs different options to build\n   a shared object, define those in ALT_SHOBJ_OPTIONS.\n \n+  Normally, only a small amount of compatibility tests is run.\n+  Setting RUN_ALL_COMPAT_TESTS=1 in the environment before running the\n+  testsuite enables running all compatibility tests, but might take\n+  significantly longer than it takes without this variable.\n+\n To run only the C++ compatibility tests, optionally specifying an\n alternate compiler and/or sets of options, do from $objdir/gcc:\n "}, {"sha": "cce21853a59511c35a00d16d201067b1e95537d9", "filename": "gcc/testsuite/gcc.dg/compat/generate-random.c", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.c?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,271 @@\n+/* Copyright (C) 1995, 2004 Free Software Foundation\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+/*\n+ * This is derived from the Berkeley source:\n+ *\t@(#)random.c\t5.5 (Berkeley) 7/6/88\n+ * It was reworked for the GNU C Library by Roland McGrath.\n+ * Rewritten to use reentrant functions by Ulrich Drepper, 1995.\n+ */\n+\n+/*\n+   Copyright (C) 1983 Regents of the University of California.\n+   All rights reserved.\n+ \n+   Redistribution and use in source and binary forms, with or without\n+   modification, are permitted provided that the following conditions\n+   are met:\n+\n+   1. Redistributions of source code must retain the above copyright\n+      notice, this list of conditions and the following disclaimer.\n+   2. Redistributions in binary form must reproduce the above copyright\n+      notice, this list of conditions and the following disclaimer in the\n+      documentation and/or other materials provided with the distribution.\n+   4. Neither the name of the University nor the names of its contributors\n+      may be used to endorse or promote products derived from this software\n+      without specific prior written permission.\n+   \n+   THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+   ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+   SUCH DAMAGE.*/\n+\n+#include \"config.h\"\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n+#include \"libiberty.h\"\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#include \"generate-random.h\"\n+\n+\n+/* An improved random number generation package.  In addition to the standard\n+   rand()/srand() like interface, this package also has a special state info\n+   interface.  The initstate() routine is called with a seed, an array of\n+   bytes, and a count of how many bytes are being passed in; this array is\n+   then initialized to contain information for random number generation with\n+   that much state information.  Good sizes for the amount of state\n+   information are 32, 64, 128, and 256 bytes.  The state can be switched by\n+   calling the setstate() function with the same array as was initialized\n+   with initstate().  By default, the package runs with 128 bytes of state\n+   information and generates far better random numbers than a linear\n+   congruential generator.  If the amount of state information is less than\n+   32 bytes, a simple linear congruential R.N.G. is used.  Internally, the\n+   state information is treated as an array of longs; the zeroth element of\n+   the array is the type of R.N.G. being used (small integer); the remainder\n+   of the array is the state information for the R.N.G.  Thus, 32 bytes of\n+   state information will give 7 longs worth of state information, which will\n+   allow a degree seven polynomial.  (Note: The zeroth word of state\n+   information also has some other information stored in it; see setstate\n+   for details).  The random number generation technique is a linear feedback\n+   shift register approach, employing trinomials (since there are fewer terms\n+   to sum up that way).  In this approach, the least significant bit of all\n+   the numbers in the state table will act as a linear feedback shift register,\n+   and will have period 2^deg - 1 (where deg is the degree of the polynomial\n+   being used, assuming that the polynomial is irreducible and primitive).\n+   The higher order bits will have longer periods, since their values are\n+   also influenced by pseudo-random carries out of the lower bits.  The\n+   total period of the generator is approximately deg*(2**deg - 1); thus\n+   doubling the amount of state information has a vast influence on the\n+   period of the generator.  Note: The deg*(2**deg - 1) is an approximation\n+   only good for large deg, when the period of the shift register is the\n+   dominant factor.  With deg equal to seven, the period is actually much\n+   longer than the 7*(2**7 - 1) predicted by this formula.  */\n+\n+\n+\n+/* For each of the currently supported random number generators, we have a\n+   break value on the amount of state information (you need at least this many\n+   bytes of state info to support this random number generator), a degree for\n+   the polynomial (actually a trinomial) that the R.N.G. is based on, and\n+   separation between the two lower order coefficients of the trinomial.  */\n+\n+/* Linear congruential.  */\n+#define\tTYPE_0\t\t0\n+#define\tBREAK_0\t\t8\n+#define\tDEG_0\t\t0\n+#define\tSEP_0\t\t0\n+\n+/* x**7 + x**3 + 1.  */\n+#define\tTYPE_1\t\t1\n+#define\tBREAK_1\t\t32\n+#define\tDEG_1\t\t7\n+#define\tSEP_1\t\t3\n+\n+/* x**15 + x + 1.  */\n+#define\tTYPE_2\t\t2\n+#define\tBREAK_2\t\t64\n+#define\tDEG_2\t\t15\n+#define\tSEP_2\t\t1\n+\n+/* x**31 + x**3 + 1.  */\n+#define\tTYPE_3\t\t3\n+#define\tBREAK_3\t\t128\n+#define\tDEG_3\t\t31\n+#define\tSEP_3\t\t3\n+\n+/* x**63 + x + 1.  */\n+#define\tTYPE_4\t\t4\n+#define\tBREAK_4\t\t256\n+#define\tDEG_4\t\t63\n+#define\tSEP_4\t\t1\n+\n+\n+/* Array versions of the above information to make code run faster.\n+   Relies on fact that TYPE_i == i.  */\n+\n+#define\tMAX_TYPES\t5\t/* Max number of types above.  */\n+\n+\n+/* Initially, everything is set up as if from:\n+\tinitstate(1, randtbl, 128);\n+   Note that this initialization takes advantage of the fact that srandom\n+   advances the front and rear pointers 10*rand_deg times, and hence the\n+   rear pointer which starts at 0 will also end up at zero; thus the zeroth\n+   element of the state information, which contains info about the current\n+   position of the rear pointer is just\n+\t(MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3.  */\n+\n+static int randtbl[DEG_3 + 1] =\n+  {\n+    TYPE_3,\n+\n+    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,\n+    1627687941, -179304937, -2073333483, 1780058412, -1989503057,\n+    -615974602, 344556628, 939512070, -1249116260, 1507946756,\n+    -812545463, 154635395, 1388815473, -1926676823, 525320961,\n+    -1009028674, 968117788, -123449607, 1284210865, 435012392,\n+    -2017506339, -911064859, -370259173, 1132637927, 1398500161,\n+    -205601318,\n+  };\n+\n+\n+static struct generate_random_data unsafe_state =\n+  {\n+/* FPTR and RPTR are two pointers into the state info, a front and a rear\n+   pointer.  These two pointers are always rand_sep places aparts, as they\n+   cycle through the state information.  (Yes, this does mean we could get\n+   away with just one pointer, but the code for random is more efficient\n+   this way).  The pointers are left positioned as they would be from the call:\n+\tinitstate(1, randtbl, 128);\n+   (The position of the rear pointer, rptr, is really 0 (as explained above\n+   in the initialization of randtbl) because the state table pointer is set\n+   to point to randtbl[1] (as explained below).)  */\n+\n+    .fptr = &randtbl[SEP_3 + 1],\n+    .rptr = &randtbl[1],\n+\n+/* The following things are the pointer to the state information table,\n+   the type of the current generator, the degree of the current polynomial\n+   being used, and the separation between the two pointers.\n+   Note that for efficiency of random, we remember the first location of\n+   the state information, not the zeroth.  Hence it is valid to access\n+   state[-1], which is used to store the type of the R.N.G.\n+   Also, we remember the last location, since this is more efficient than\n+   indexing every time to find the address of the last element to see if\n+   the front and rear pointers have wrapped.  */\n+\n+    .state = &randtbl[1],\n+\n+    .rand_type = TYPE_3,\n+    .rand_deg = DEG_3,\n+    .rand_sep = SEP_3,\n+\n+    .end_ptr = &randtbl[sizeof (randtbl) / sizeof (randtbl[0])]\n+};\n+\f\n+/* Initialize the random number generator based on the given seed.  If the\n+   type is the trivial no-state-information type, just remember the seed.\n+   Otherwise, initializes state[] based on the given \"seed\" via a linear\n+   congruential generator.  Then, the pointers are set to known locations\n+   that are exactly rand_sep places apart.  Lastly, it cycles the state\n+   information a given number of times to get rid of any initial dependencies\n+   introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]\n+   for default usage relies on values produced by this routine.  */\n+void\n+generate_srandom (unsigned int x)\n+{\n+  (void) generate_srandom_r (x, &unsafe_state);\n+}\n+\f\n+/* Initialize the state information in the given array of N bytes for\n+   future random number generation.  Based on the number of bytes we\n+   are given, and the break values for the different R.N.G.'s, we choose\n+   the best (largest) one we can and set things up for it.  srandom is\n+   then called to initialize the state information.  Note that on return\n+   from srandom, we set state[-1] to be the type multiplexed with the current\n+   value of the rear pointer; this is so successive calls to initstate won't\n+   lose this information and will be able to restart with setstate.\n+   Note: The first thing we do is save the current state, if any, just like\n+   setstate so that it doesn't matter when initstate is called.\n+   Returns a pointer to the old state.  */\n+char *\n+generate_initstate (unsigned int seed, char *arg_state, size_t n)\n+{\n+  int *ostate;\n+\n+  ostate = &unsafe_state.state[-1];\n+  generate_initstate_r (seed, arg_state, n, &unsafe_state);\n+  return (char *) ostate;\n+}\n+\f\n+/* Restore the state from the given state array.\n+   Note: It is important that we also remember the locations of the pointers\n+   in the current state information, and restore the locations of the pointers\n+   from the old state information.  This is done by multiplexing the pointer\n+   location into the zeroth word of the state information. Note that due\n+   to the order in which things are done, it is OK to call setstate with the\n+   same state as the current state\n+   Returns a pointer to the old state information.  */\n+char *\n+generate_setstate (char *arg_state)\n+{\n+  int *ostate;\n+\n+  ostate = &unsafe_state.state[-1];\n+  if (generate_setstate_r (arg_state, &unsafe_state) < 0)\n+    ostate = NULL;\n+  return (char *) ostate;\n+}\n+\f\n+/* If we are using the trivial TYPE_0 R.N.G., just do the old linear\n+   congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the\n+   same in all the other cases due to all the global variables that have been\n+   set up.  The basic operation is to add the number at the rear pointer into\n+   the one at the front pointer.  Then both pointers are advanced to the next\n+   location cyclically in the table.  The value returned is the sum generated,\n+   reduced to 31 bits by throwing away the \"least random\" low bit.\n+   Note: The code takes advantage of the fact that both the front and\n+   rear pointers can't wrap on the same call by not testing the rear\n+   pointer if the front one has wrapped.  Returns a 31-bit random number.  */\n+\n+long int\n+generate_random (void)\n+{\n+  int retval;\n+  (void) generate_random_r (&unsafe_state, &retval);\n+  return retval;\n+}"}, {"sha": "76e3afe616c75ceebf7b149cf5a53693e3bf1dfe", "filename": "gcc/testsuite/gcc.dg/compat/generate-random.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random.h?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,33 @@\n+/* Copyright (C) 2004 Free Software Foundation\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+struct generate_random_data\n+  {\n+    int *fptr, *rptr, *state;\n+    int rand_type, rand_deg, rand_sep;\n+    int *end_ptr;\n+  };\n+\n+extern void generate_srandom (unsigned int);\n+extern char *generate_initstate (unsigned int, char *, size_t);\n+extern char *generate_setstate (char *);\n+extern long int generate_random (void);\n+extern int generate_random_r (struct generate_random_data *, int *);\n+extern int generate_srandom_r (unsigned int, struct generate_random_data *);\n+extern int generate_initstate_r (unsigned int, char *, size_t,\n+\t\t\t\t struct generate_random_data *);\n+extern int generate_setstate_r (char *, struct generate_random_data *);"}, {"sha": "a909c6d071bcab2e429958c4176bf37909cd3772", "filename": "gcc/testsuite/gcc.dg/compat/generate-random_r.c", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random_r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random_r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fgenerate-random_r.c?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,391 @@\n+/* \n+   Copyright (C) 1995, 2004 Free Software Foundation\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+/*\n+   Copyright (C) 1983 Regents of the University of California.\n+   All rights reserved.\n+\n+   Redistribution and use in source and binary forms, with or without\n+   modification, are permitted provided that the following conditions\n+   are met:\n+\n+   1. Redistributions of source code must retain the above copyright\n+      notice, this list of conditions and the following disclaimer.\n+   2. Redistributions in binary form must reproduce the above copyright\n+      notice, this list of conditions and the following disclaimer in the\n+      documentation and/or other materials provided with the distribution.\n+   4. Neither the name of the University nor the names of its contributors\n+      may be used to endorse or promote products derived from this software\n+      without specific prior written permission.\n+   \n+   THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+   ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+   SUCH DAMAGE.*/\n+\n+/*\n+ * This is derived from the Berkeley source:\n+ *\t@(#)random.c\t5.5 (Berkeley) 7/6/88\n+ * It was reworked for the GNU C Library by Roland McGrath.\n+ * Rewritten to be reentrant by Ulrich Drepper, 1995\n+ */\n+\n+#include \"config.h\"\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n+#include \"libiberty.h\"\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#include \"generate-random.h\"\n+\n+\n+/* An improved random number generation package.  In addition to the standard\n+   rand()/srand() like interface, this package also has a special state info\n+   interface.  The initstate() routine is called with a seed, an array of\n+   bytes, and a count of how many bytes are being passed in; this array is\n+   then initialized to contain information for random number generation with\n+   that much state information.  Good sizes for the amount of state\n+   information are 32, 64, 128, and 256 bytes.  The state can be switched by\n+   calling the setstate() function with the same array as was initialized\n+   with initstate().  By default, the package runs with 128 bytes of state\n+   information and generates far better random numbers than a linear\n+   congruential generator.  If the amount of state information is less than\n+   32 bytes, a simple linear congruential R.N.G. is used.  Internally, the\n+   state information is treated as an array of longs; the zeroth element of\n+   the array is the type of R.N.G. being used (small integer); the remainder\n+   of the array is the state information for the R.N.G.  Thus, 32 bytes of\n+   state information will give 7 longs worth of state information, which will\n+   allow a degree seven polynomial.  (Note: The zeroth word of state\n+   information also has some other information stored in it; see setstate\n+   for details).  The random number generation technique is a linear feedback\n+   shift register approach, employing trinomials (since there are fewer terms\n+   to sum up that way).  In this approach, the least significant bit of all\n+   the numbers in the state table will act as a linear feedback shift register,\n+   and will have period 2^deg - 1 (where deg is the degree of the polynomial\n+   being used, assuming that the polynomial is irreducible and primitive).\n+   The higher order bits will have longer periods, since their values are\n+   also influenced by pseudo-random carries out of the lower bits.  The\n+   total period of the generator is approximately deg*(2**deg - 1); thus\n+   doubling the amount of state information has a vast influence on the\n+   period of the generator.  Note: The deg*(2**deg - 1) is an approximation\n+   only good for large deg, when the period of the shift register is the\n+   dominant factor.  With deg equal to seven, the period is actually much\n+   longer than the 7*(2**7 - 1) predicted by this formula.  */\n+\n+\n+\n+/* For each of the currently supported random number generators, we have a\n+   break value on the amount of state information (you need at least this many\n+   bytes of state info to support this random number generator), a degree for\n+   the polynomial (actually a trinomial) that the R.N.G. is based on, and\n+   separation between the two lower order coefficients of the trinomial.  */\n+\n+/* Linear congruential.  */\n+#define\tTYPE_0\t\t0\n+#define\tBREAK_0\t\t8\n+#define\tDEG_0\t\t0\n+#define\tSEP_0\t\t0\n+\n+/* x**7 + x**3 + 1.  */\n+#define\tTYPE_1\t\t1\n+#define\tBREAK_1\t\t32\n+#define\tDEG_1\t\t7\n+#define\tSEP_1\t\t3\n+\n+/* x**15 + x + 1.  */\n+#define\tTYPE_2\t\t2\n+#define\tBREAK_2\t\t64\n+#define\tDEG_2\t\t15\n+#define\tSEP_2\t\t1\n+\n+/* x**31 + x**3 + 1.  */\n+#define\tTYPE_3\t\t3\n+#define\tBREAK_3\t\t128\n+#define\tDEG_3\t\t31\n+#define\tSEP_3\t\t3\n+\n+/* x**63 + x + 1.  */\n+#define\tTYPE_4\t\t4\n+#define\tBREAK_4\t\t256\n+#define\tDEG_4\t\t63\n+#define\tSEP_4\t\t1\n+\n+\n+/* Array versions of the above information to make code run faster.\n+   Relies on fact that TYPE_i == i.  */\n+\n+#define\tMAX_TYPES\t5\t/* Max number of types above.  */\n+\n+struct random_poly_info\n+{\n+  int seps[MAX_TYPES];\n+  int degrees[MAX_TYPES];\n+};\n+\n+static const struct random_poly_info random_poly_info =\n+{\n+  { SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 },\n+  { DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 }\n+};\n+\n+\n+\n+\f\n+/* Initialize the random number generator based on the given seed.  If the\n+   type is the trivial no-state-information type, just remember the seed.\n+   Otherwise, initializes state[] based on the given \"seed\" via a linear\n+   congruential generator.  Then, the pointers are set to known locations\n+   that are exactly rand_sep places apart.  Lastly, it cycles the state\n+   information a given number of times to get rid of any initial dependencies\n+   introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]\n+   for default usage relies on values produced by this routine.  */\n+int\n+generate_srandom_r (unsigned int seed, struct generate_random_data *buf)\n+{\n+  int type;\n+  int *state;\n+  long int i;\n+  long int word;\n+  int *dst;\n+  int kc;\n+\n+  if (buf == NULL)\n+    goto fail;\n+  type = buf->rand_type;\n+  if ((unsigned int) type >= MAX_TYPES)\n+    goto fail;\n+\n+  state = buf->state;\n+  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */\n+  if (seed == 0)\n+    seed = 1;\n+  state[0] = seed;\n+  if (type == TYPE_0)\n+    goto done;\n+\n+  dst = state;\n+  word = seed;\n+  kc = buf->rand_deg;\n+  for (i = 1; i < kc; ++i)\n+    {\n+      /* This does:\n+\t   state[i] = (16807 * state[i - 1]) % 2147483647;\n+\t but avoids overflowing 31 bits.  */\n+      long int hi = word / 127773;\n+      long int lo = word % 127773;\n+      word = 16807 * lo - 2836 * hi;\n+      if (word < 0)\n+\tword += 2147483647;\n+      *++dst = word;\n+    }\n+\n+  buf->fptr = &state[buf->rand_sep];\n+  buf->rptr = &state[0];\n+  kc *= 10;\n+  while (--kc >= 0)\n+    {\n+      int discard;\n+      (void) generate_random_r (buf, &discard);\n+    }\n+\n+ done:\n+  return 0;\n+\n+ fail:\n+  return -1;\n+}\n+\f\n+/* Initialize the state information in the given array of N bytes for\n+   future random number generation.  Based on the number of bytes we\n+   are given, and the break values for the different R.N.G.'s, we choose\n+   the best (largest) one we can and set things up for it.  srandom is\n+   then called to initialize the state information.  Note that on return\n+   from srandom, we set state[-1] to be the type multiplexed with the current\n+   value of the rear pointer; this is so successive calls to initstate won't\n+   lose this information and will be able to restart with setstate.\n+   Note: The first thing we do is save the current state, if any, just like\n+   setstate so that it doesn't matter when initstate is called.\n+   Returns a pointer to the old state.  */\n+int\n+generate_initstate_r (unsigned int seed, char *arg_state, size_t n,\n+\t\t      struct generate_random_data *buf)\n+{\n+  int type;\n+  int degree;\n+  int separation;\n+  int *state;\n+\n+  if (buf == NULL)\n+    goto fail;\n+\n+  if (n >= BREAK_3)\n+    type = n < BREAK_4 ? TYPE_3 : TYPE_4;\n+  else if (n < BREAK_1)\n+    {\n+      if (n < BREAK_0)\n+\t{\n+\t  goto fail;\n+\t}\n+      type = TYPE_0;\n+    }\n+  else\n+    type = n < BREAK_2 ? TYPE_1 : TYPE_2;\n+\n+  degree = random_poly_info.degrees[type];\n+  separation = random_poly_info.seps[type];\n+\n+  buf->rand_type = type;\n+  buf->rand_sep = separation;\n+  buf->rand_deg = degree;\n+  state = &((int *) arg_state)[1];\t/* First location.  */\n+  /* Must set END_PTR before srandom.  */\n+  buf->end_ptr = &state[degree];\n+\n+  buf->state = state;\n+\n+  generate_srandom_r (seed, buf);\n+\n+  state[-1] = TYPE_0;\n+  if (type != TYPE_0)\n+    state[-1] = (buf->rptr - state) * MAX_TYPES + type;\n+\n+  return 0;\n+\n+ fail:\n+  return -1;\n+}\n+\f\n+/* Restore the state from the given state array.\n+   Note: It is important that we also remember the locations of the pointers\n+   in the current state information, and restore the locations of the pointers\n+   from the old state information.  This is done by multiplexing the pointer\n+   location into the zeroth word of the state information. Note that due\n+   to the order in which things are done, it is OK to call setstate with the\n+   same state as the current state\n+   Returns a pointer to the old state information.  */\n+int\n+generate_setstate_r (char *arg_state, struct generate_random_data *buf)\n+{\n+  int *new_state = 1 + (int *) arg_state;\n+  int type;\n+  int old_type;\n+  int *old_state;\n+  int degree;\n+  int separation;\n+\n+  if (arg_state == NULL || buf == NULL)\n+    goto fail;\n+\n+  old_type = buf->rand_type;\n+  old_state = buf->state;\n+  if (old_type == TYPE_0)\n+    old_state[-1] = TYPE_0;\n+  else\n+    old_state[-1] = (MAX_TYPES * (buf->rptr - old_state)) + old_type;\n+\n+  type = new_state[-1] % MAX_TYPES;\n+  if (type < TYPE_0 || type > TYPE_4)\n+    goto fail;\n+\n+  buf->rand_deg = degree = random_poly_info.degrees[type];\n+  buf->rand_sep = separation = random_poly_info.seps[type];\n+  buf->rand_type = type;\n+\n+  if (type != TYPE_0)\n+    {\n+      int rear = new_state[-1] / MAX_TYPES;\n+      buf->rptr = &new_state[rear];\n+      buf->fptr = &new_state[(rear + separation) % degree];\n+    }\n+  buf->state = new_state;\n+  /* Set end_ptr too.  */\n+  buf->end_ptr = &new_state[degree];\n+\n+  return 0;\n+\n+ fail:\n+  return -1;\n+}\n+\f\n+/* If we are using the trivial TYPE_0 R.N.G., just do the old linear\n+   congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the\n+   same in all the other cases due to all the global variables that have been\n+   set up.  The basic operation is to add the number at the rear pointer into\n+   the one at the front pointer.  Then both pointers are advanced to the next\n+   location cyclically in the table.  The value returned is the sum generated,\n+   reduced to 31 bits by throwing away the \"least random\" low bit.\n+   Note: The code takes advantage of the fact that both the front and\n+   rear pointers can't wrap on the same call by not testing the rear\n+   pointer if the front one has wrapped.  Returns a 31-bit random number.  */\n+\n+int\n+generate_random_r (struct generate_random_data *buf, int *result)\n+{\n+  int *state;\n+\n+  if (buf == NULL || result == NULL)\n+    goto fail;\n+\n+  state = buf->state;\n+\n+  if (buf->rand_type == TYPE_0)\n+    {\n+      int val = state[0];\n+      val = ((state[0] * 1103515245) + 12345) & 0x7fffffff;\n+      state[0] = val;\n+      *result = val;\n+    }\n+  else\n+    {\n+      int *fptr = buf->fptr;\n+      int *rptr = buf->rptr;\n+      int *end_ptr = buf->end_ptr;\n+      int val;\n+\n+      val = *fptr += *rptr;\n+      /* Chucking least random bit.  */\n+      *result = (val >> 1) & 0x7fffffff;\n+      ++fptr;\n+      if (fptr >= end_ptr)\n+\t{\n+\t  fptr = state;\n+\t  ++rptr;\n+\t}\n+      else\n+\t{\n+\t  ++rptr;\n+\t  if (rptr >= end_ptr)\n+\t    rptr = state;\n+\t}\n+      buf->fptr = fptr;\n+      buf->rptr = rptr;\n+    }\n+  return 0;\n+\n+ fail:\n+  return -1;\n+}"}, {"sha": "01dbf319db2582cbd7cbf000ffd7544781c5b794", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1.exp", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.exp?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,139 @@\n+# Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+#\n+# This file was written by Jakub Jelinek, <jakub@redhat.com>\n+# Based on compat.exp writte by Janis Johnson, <janis187@us.ibm.com>\n+\n+\n+# Test interoperability of two compilers that follow the same ABI.\n+#\n+# Break simple tests into two pieces and see that they work when linked\n+# together.  If an alternate compiler is specified then the two main\n+# pieces of each test are compiled with different compilers.  The\n+# alternate compiler must be installed, and is specified by defining\n+# ALT_CC_UNDER_TEST in the environment.\n+#\n+# struct-layout-1 are generated structure layout interoperability tests,\n+# so a generator first needs to be compiled on host, run there and the\n+# generated tests then compiled on build and executed on target.\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+global GCC_UNDER_TEST\n+\n+# Load procedures from common libraries. \n+load_lib standard.exp\n+load_lib gcc.exp\n+\n+#\n+# compat-use-alt-compiler -- make the alternate compiler the default\n+# \n+proc compat-use-alt-compiler { } {\n+    global GCC_UNDER_TEST ALT_CC_UNDER_TEST\n+    global same_alt\n+\n+    # We don't need to do this if the alternate compiler is actually\n+    # the same as the compiler under test.\n+    if { $same_alt == 0 } then {\n+\tset GCC_UNDER_TEST $ALT_CC_UNDER_TEST\n+    }\n+}\n+\n+#\n+# compat-use-tst-compiler -- make compiler under test the default\n+#\n+proc compat-use-tst-compiler { } {\n+    global GCC_UNDER_TEST save_gcc_under_test\n+    global same_alt\n+\n+    # We don't need to do this if the alternate compiler is actually\n+    # the same as the compiler under test.\n+\n+    if { $same_alt == 0 } then {\n+\tset GCC_UNDER_TEST $save_gcc_under_test\n+    }\n+}\n+\n+# Load the language-independent compabibility support procedures.\n+# This must be done after the compat-use-*-compiler definitions.\n+load_lib compat.exp\n+\n+gcc_init\n+\n+# Save variables for the C compiler under test, which each test will\n+# change a couple of times.  This must be done after calling gcc-init.\n+set save_gcc_under_test $GCC_UNDER_TEST\n+\n+# Define an identifier for use with this suite to avoid name conflicts\n+# with other compat tests running at the same time.\n+set sid \"c_compat\"\n+\n+# Find out whether there is an alternate compiler to test.  If the\n+# variable is defined but is set to \"same\", that means we use the same\n+# compiler twice, which is meaningful if the two parts of COMPAT_OPTIONS\n+# are different.\n+set use_alt 0\n+set same_alt 0\n+if [info exists ALT_CC_UNDER_TEST] then {\n+    set use_alt 1\n+    if [string match \"same\" $ALT_CC_UNDER_TEST] then {\n+\tset same_alt 1\n+    }\n+}\n+\n+set tstobjdir \"$tmpdir/gcc.dg-struct-layout-1\"\n+set generator \"$tmpdir/gcc.dg-struct-layout-1_generate\"\n+\n+set generator_src \"$srcdir/$subdir/struct-layout-1_generate.c\"\n+set generator_src \"$generator_src $srcdir/$subdir/generate-random.c\"\n+set generator_src \"$generator_src $srcdir/$subdir/generate-random_r.c\"\n+set generator_inc \"-I$srcdir/$subdir -I$srcdir/../../include\"\n+set generator_inc \"$generator_inc -I$rootme/../libiberty\"\n+set generator_lib \"-L$rootme/../libiberty -liberty\"\n+set generator_cmd \"-o $generator $generator_src $generator_inc $generator_lib\"\n+\n+set status [remote_exec host \"$HOSTCC $HOSTCFLAGS $generator_cmd\"]\n+set status [lindex $status 0]\n+if { $status == 0 } then {\n+    file delete -force $tstobjdir\n+    file mkdir $tstobjdir\n+    set generator_args \"-s $srcdir/$subdir -d $tstobjdir\"\n+    if [info exists env(RUN_ALL_COMPAT_TESTS) ] then {\n+\tset generator_args \"$generator_args -n 15000\"\n+    }\n+    set status [remote_exec host \"$generator $generator_args\"]\n+    set status [lindex $status 0]\n+    if { $status == 0 } then {\n+\tforeach src [lsort [find $tstobjdir *_main.c]] {\n+\t    # If we're only testing specific files and this isn't one\n+\t    # of them, skip it.\n+\t    if ![runtest_file_p $runtests $src] then {\n+\t\tcontinue\n+\t    }\n+\n+\t    compat-execute $src $sid $use_alt\n+\t}\n+    } else {\n+\twarning \"Could not execute gcc.dg/compat/struct-layout-1 generator\"\n+    }\n+} else {\n+    warning \"Could not compiler gcc.dg/compat/struct-layout-1 generator\"\n+}\n+\n+# Restore the original compiler under test.\n+compat-use-tst-compiler"}, {"sha": "3cadceb8565eff930a16e9e86713d19b1475323f", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1.h", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.h?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,501 @@\n+#include <complex.h>\n+#include <limits.h>\n+#include <stdarg.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"compat-common.h\"\n+\n+#ifndef SKIP_ATTRIBUTE\n+# include \"vector-defs.h\"\n+#else\n+typedef int qi;\n+typedef int hi;\n+typedef int si;\n+typedef int di;\n+typedef float sf;\n+typedef float df;\n+typedef int v8qi;\n+typedef int v16qi;\n+typedef int v2hi;\n+typedef int v4hi;\n+typedef int v8hi;\n+typedef int v2si;\n+typedef int v4si;\n+typedef int v1di;\n+typedef int v2di;\n+typedef int v2sf;\n+typedef int v4sf;\n+typedef int v16sf;\n+typedef int v2df;\n+typedef int u8qi;\n+typedef int u16qi;\n+typedef int u2hi;\n+typedef int u4hi;\n+typedef int u8hi;\n+typedef int u2si;\n+typedef int u4si;\n+typedef int u1di;\n+typedef int u2di;\n+typedef int u2sf;\n+typedef int u4sf;\n+typedef int u16sf;\n+typedef int u2df;\n+#endif\n+#if (defined __i386__ || defined __x86_64__) && !defined SKIP_ATTRIBUTE\n+# ifdef __MMX__\n+#  include <mmintrin.h>\n+# else\n+typedef int __m64;\n+# endif\n+# ifdef __SSE__\n+#  include <xmmintrin.h>\n+# else\n+typedef int __m128;\n+# endif\n+#else\n+typedef int __m64;\n+typedef int __m128;\n+#endif\n+\n+#define FLDS_MAX\t32\n+extern struct Info\n+{\n+  int nfields, nbitfields;\n+  void *sp, *a0p, *a3p;\n+  void *flds[FLDS_MAX];\n+  size_t sz, sizes[FLDS_MAX];\n+  size_t als, ala0, ala3, aligns[FLDS_MAX];\n+} info;\n+\n+extern int intarray[256];\n+extern int fn0 (void), fn1 (void), fn2 (void), fn3 (void), fn4 (void);\n+extern int fn5 (void), fn6 (void), fn7 (void), fn8 (void), fn9 (void);\n+\n+#ifdef DBG\n+#define FAIL(n, m) printf (\"fail %d.%d\\n\", n, m), ++fails\n+#else\n+#define FAIL(n, m) ++fails\n+#endif\n+\n+#ifdef SKIP_ATTRIBUTE\n+# define __attribute__(x)\n+#endif\n+#define atal\t\t__attribute__((aligned))\n+#define atpa\t\t__attribute__((packed))\n+#define atalpa\t\t__attribute__((aligned, packed))\n+#define atpaal\t\t__attribute__((packed, aligned))\n+#define atal1\t\t__attribute__((aligned (1)))\n+#define atal2\t\t__attribute__((aligned (2)))\n+#define atal4\t\t__attribute__((aligned (4)))\n+#define atal8\t\t__attribute__((aligned (8)))\n+#define atal16\t\t__attribute__((aligned (16)))\n+#define atal1pa\t\t__attribute__((aligned (1), packed))\n+#define atal2pa\t\t__attribute__((aligned (2), packed))\n+#define atal4pa\t\t__attribute__((aligned (4), packed))\n+#define atal8pa\t\t__attribute__((aligned (8), packed))\n+#define atal16pa\t__attribute__((aligned (16), packed))\n+#define atpaal1\t\t__attribute__((packed, aligned (1)))\n+#define atpaal2\t\t__attribute__((packed, aligned (2)))\n+#define atpaal4\t\t__attribute__((packed, aligned (4)))\n+#define atpaal8\t\t__attribute__((packed, aligned (8)))\n+#define atpaal16\t__attribute__((packed, aligned (16)))\n+\n+#define atQI\t\t__attribute__((mode (QI)))\n+#define atHI\t\t__attribute__((mode (HI)))\n+#define atSI\t\t__attribute__((mode (SI)))\n+#define atDI\t\t__attribute__((mode (DI)))\n+\n+enum E0 { e0_0 };\n+enum E1 { e1_0, e1_1 };\n+enum E2 { e2_m3 = -3, e2_m2, e2_m1, e2_0, e2_1, e2_2, e2_3 };\n+enum E3 { e3_m127 = -127, e3_m126, e3_m125, e3_0 = 0, e3_125 = 125, e3_126, e3_127 };\n+enum E4 { e4_0, e4_1, e4_2, e4_3, e4_253 = 253, e4_254, e4_255 };\n+enum E5 { e5_m32767 = -32767, e5_m32766, e5_m32765, e5_0 = 0, e5_32765 = 32765, e5_32766, e5_32767 };\n+enum E6 { e6_0, e6_1, e6_2, e6_3, e6_65533 = 65533, e6_65534, e6_65535 };\n+enum E7 { e7_m2147483647 = -2147483647, e7_m2147483646, e7_m2147483645,\n+\t  e7_0, e7_2147483645 = 2147483645, e7_2147483646, e7_2147483647 };\n+enum E8 { e8_0, e8_1, e8_2, e8_3, e8_4294967293 = 4294967293U, e8_4294967294, e8_4294967295 };\n+enum E9 { e9_m1099511627775 = -1099511627775LL, e9_m1099511627774, e9_m1099511627773,\n+\t  e9_0, e9_1099511627773 = 1099511627773LL, e9_1099511627774, e9_1099511627775 };\n+\n+typedef char Tchar;\n+typedef signed char Tschar;\n+typedef unsigned char Tuchar;\n+typedef short int Tshort;\n+typedef unsigned short int Tushort;\n+typedef int Tint;\n+typedef unsigned int Tuint;\n+typedef long int Tlong;\n+typedef unsigned long int Tulong;\n+typedef long long int Tllong;\n+typedef unsigned long long int Tullong;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tcchar;\n+typedef _Complex signed char Tcschar;\n+typedef _Complex unsigned char Tcuchar;\n+typedef _Complex short int Tcshort;\n+typedef _Complex unsigned short int Tcushort;\n+typedef _Complex int Tcint;\n+typedef _Complex unsigned int Tcuint;\n+typedef _Complex long int Tclong;\n+typedef _Complex unsigned long int Tculong;\n+typedef _Complex long long int Tcllong;\n+typedef _Complex unsigned long long int Tcullong;\n+#endif\n+typedef float Tfloat;\n+typedef double Tdouble;\n+typedef long double Tldouble;\n+typedef _Complex float Tcfloat;\n+typedef _Complex double Tcdouble;\n+typedef _Complex long double Tcldouble;\n+typedef bool Tbool;\n+typedef enum E0 TE0;\n+typedef enum E1 TE1;\n+typedef enum E2 TE2;\n+typedef enum E3 TE3;\n+typedef enum E4 TE4;\n+typedef enum E5 TE5;\n+typedef enum E6 TE6;\n+typedef enum E7 TE7;\n+typedef enum E8 TE8;\n+typedef enum E9 TE9;\n+typedef void *Tptr;\n+typedef char *Tcptr;\n+typedef int *Tiptr;\n+typedef char Talchar atal;\n+typedef signed char Talschar atal;\n+typedef unsigned char Taluchar atal;\n+typedef short int Talshort atal;\n+typedef unsigned short int Talushort atal;\n+typedef int Talint atal;\n+typedef unsigned int Taluint atal;\n+typedef long int Tallong atal;\n+typedef unsigned long int Talulong atal;\n+typedef long long int Talllong atal;\n+typedef unsigned long long int Talullong atal;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Talcchar atal;\n+typedef _Complex signed char Talcschar atal;\n+typedef _Complex unsigned char Talcuchar atal;\n+typedef _Complex short int Talcshort atal;\n+typedef _Complex unsigned short int Talcushort atal;\n+typedef _Complex int Talcint atal;\n+typedef _Complex unsigned int Talcuint atal;\n+typedef _Complex long int Talclong atal;\n+typedef _Complex unsigned long int Talculong atal;\n+typedef _Complex long long int Talcllong atal;\n+typedef _Complex unsigned long long int Talcullong atal;\n+#endif\n+typedef float Talfloat atal;\n+typedef double Taldouble atal;\n+typedef long double Talldouble atal;\n+typedef _Complex float Talcfloat atal;\n+typedef _Complex double Talcdouble atal;\n+typedef _Complex long double Talcldouble atal;\n+typedef bool Talbool atal;\n+typedef enum E0 TalE0 atal;\n+typedef enum E1 TalE1 atal;\n+typedef enum E2 TalE2 atal;\n+typedef enum E3 TalE3 atal;\n+typedef enum E4 TalE4 atal;\n+typedef enum E5 TalE5 atal;\n+typedef enum E6 TalE6 atal;\n+typedef enum E7 TalE7 atal;\n+typedef enum E8 TalE8 atal;\n+typedef enum E9 TalE9 atal;\n+typedef void *Talptr atal;\n+typedef char *Talcptr atal;\n+typedef int *Taliptr atal;\n+typedef char Tal1char atal1;\n+typedef signed char Tal1schar atal1;\n+typedef unsigned char Tal1uchar atal1;\n+typedef short int Tal1short atal1;\n+typedef unsigned short int Tal1ushort atal1;\n+typedef int Tal1int atal1;\n+typedef unsigned int Tal1uint atal1;\n+typedef long int Tal1long atal1;\n+typedef unsigned long int Tal1ulong atal1;\n+typedef long long int Tal1llong atal1;\n+typedef unsigned long long int Tal1ullong atal1;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal1cchar atal1;\n+typedef _Complex signed char Tal1cschar atal1;\n+typedef _Complex unsigned char Tal1cuchar atal1;\n+typedef _Complex short int Tal1cshort atal1;\n+typedef _Complex unsigned short int Tal1cushort atal1;\n+typedef _Complex int Tal1cint atal1;\n+typedef _Complex unsigned int Tal1cuint atal1;\n+typedef _Complex long int Tal1clong atal1;\n+typedef _Complex unsigned long int Tal1culong atal1;\n+typedef _Complex long long int Tal1cllong atal1;\n+typedef _Complex unsigned long long int Tal1cullong atal1;\n+#endif\n+typedef float Tal1float atal1;\n+typedef double Tal1double atal1;\n+typedef long double Tal1ldouble atal1;\n+typedef _Complex float Tal1cfloat atal1;\n+typedef _Complex double Tal1cdouble atal1;\n+typedef _Complex long double Tal1cldouble atal1;\n+typedef bool Tal1bool atal1;\n+typedef enum E0 Tal1E0 atal1;\n+typedef enum E1 Tal1E1 atal1;\n+typedef enum E2 Tal1E2 atal1;\n+typedef enum E3 Tal1E3 atal1;\n+typedef enum E4 Tal1E4 atal1;\n+typedef enum E5 Tal1E5 atal1;\n+typedef enum E6 Tal1E6 atal1;\n+typedef enum E7 Tal1E7 atal1;\n+typedef enum E8 Tal1E8 atal1;\n+typedef enum E9 Tal1E9 atal1;\n+typedef void *Tal1ptr atal1;\n+typedef char *Tal1cptr atal1;\n+typedef int *Tal1iptr atal1;\n+typedef char Tal2char atal2;\n+typedef signed char Tal2schar atal2;\n+typedef unsigned char Tal2uchar atal2;\n+typedef short int Tal2short atal2;\n+typedef unsigned short int Tal2ushort atal2;\n+typedef int Tal2int atal2;\n+typedef unsigned int Tal2uint atal2;\n+typedef long int Tal2long atal2;\n+typedef unsigned long int Tal2ulong atal2;\n+typedef long long int Tal2llong atal2;\n+typedef unsigned long long int Tal2ullong atal2;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal2cchar atal2;\n+typedef _Complex signed char Tal2cschar atal2;\n+typedef _Complex unsigned char Tal2cuchar atal2;\n+typedef _Complex short int Tal2cshort atal2;\n+typedef _Complex unsigned short int Tal2cushort atal2;\n+typedef _Complex int Tal2cint atal2;\n+typedef _Complex unsigned int Tal2cuint atal2;\n+typedef _Complex long int Tal2clong atal2;\n+typedef _Complex unsigned long int Tal2culong atal2;\n+typedef _Complex long long int Tal2cllong atal2;\n+typedef _Complex unsigned long long int Tal2cullong atal2;\n+#endif\n+typedef float Tal2float atal2;\n+typedef double Tal2double atal2;\n+typedef long double Tal2ldouble atal2;\n+typedef _Complex float Tal2cfloat atal2;\n+typedef _Complex double Tal2cdouble atal2;\n+typedef _Complex long double Tal2cldouble atal2;\n+typedef bool Tal2bool atal2;\n+typedef enum E0 Tal2E0 atal2;\n+typedef enum E1 Tal2E1 atal2;\n+typedef enum E2 Tal2E2 atal2;\n+typedef enum E3 Tal2E3 atal2;\n+typedef enum E4 Tal2E4 atal2;\n+typedef enum E5 Tal2E5 atal2;\n+typedef enum E6 Tal2E6 atal2;\n+typedef enum E7 Tal2E7 atal2;\n+typedef enum E8 Tal2E8 atal2;\n+typedef enum E9 Tal2E9 atal2;\n+typedef void *Tal2ptr atal2;\n+typedef char *Tal2cptr atal2;\n+typedef int *Tal2iptr atal2;\n+typedef char Tal4char atal4;\n+typedef signed char Tal4schar atal4;\n+typedef unsigned char Tal4uchar atal4;\n+typedef short int Tal4short atal4;\n+typedef unsigned short int Tal4ushort atal4;\n+typedef int Tal4int atal4;\n+typedef unsigned int Tal4uint atal4;\n+typedef long int Tal4long atal4;\n+typedef unsigned long int Tal4ulong atal4;\n+typedef long long int Tal4llong atal4;\n+typedef unsigned long long int Tal4ullong atal4;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal4cchar atal4;\n+typedef _Complex signed char Tal4cschar atal4;\n+typedef _Complex unsigned char Tal4cuchar atal4;\n+typedef _Complex short int Tal4cshort atal4;\n+typedef _Complex unsigned short int Tal4cushort atal4;\n+typedef _Complex int Tal4cint atal4;\n+typedef _Complex unsigned int Tal4cuint atal4;\n+typedef _Complex long int Tal4clong atal4;\n+typedef _Complex unsigned long int Tal4culong atal4;\n+typedef _Complex long long int Tal4cllong atal4;\n+typedef _Complex unsigned long long int Tal4cullong atal4;\n+#endif\n+typedef float Tal4float atal4;\n+typedef double Tal4double atal4;\n+typedef long double Tal4ldouble atal4;\n+typedef _Complex float Tal4cfloat atal4;\n+typedef _Complex double Tal4cdouble atal4;\n+typedef _Complex long double Tal4cldouble atal4;\n+typedef bool Tal4bool atal4;\n+typedef enum E0 Tal4E0 atal4;\n+typedef enum E1 Tal4E1 atal4;\n+typedef enum E2 Tal4E2 atal4;\n+typedef enum E3 Tal4E3 atal4;\n+typedef enum E4 Tal4E4 atal4;\n+typedef enum E5 Tal4E5 atal4;\n+typedef enum E6 Tal4E6 atal4;\n+typedef enum E7 Tal4E7 atal4;\n+typedef enum E8 Tal4E8 atal4;\n+typedef enum E9 Tal4E9 atal4;\n+typedef void *Tal4ptr atal4;\n+typedef char *Tal4cptr atal4;\n+typedef int *Tal4iptr atal4;\n+typedef char Tal8char atal8;\n+typedef signed char Tal8schar atal8;\n+typedef unsigned char Tal8uchar atal8;\n+typedef short int Tal8short atal8;\n+typedef unsigned short int Tal8ushort atal8;\n+typedef int Tal8int atal8;\n+typedef unsigned int Tal8uint atal8;\n+typedef long int Tal8long atal8;\n+typedef unsigned long int Tal8ulong atal8;\n+typedef long long int Tal8llong atal8;\n+typedef unsigned long long int Tal8ullong atal8;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal8cchar atal8;\n+typedef _Complex signed char Tal8cschar atal8;\n+typedef _Complex unsigned char Tal8cuchar atal8;\n+typedef _Complex short int Tal8cshort atal8;\n+typedef _Complex unsigned short int Tal8cushort atal8;\n+typedef _Complex int Tal8cint atal8;\n+typedef _Complex unsigned int Tal8cuint atal8;\n+typedef _Complex long int Tal8clong atal8;\n+typedef _Complex unsigned long int Tal8culong atal8;\n+typedef _Complex long long int Tal8cllong atal8;\n+typedef _Complex unsigned long long int Tal8cullong atal8;\n+#endif\n+typedef float Tal8float atal8;\n+typedef double Tal8double atal8;\n+typedef long double Tal8ldouble atal8;\n+typedef _Complex float Tal8cfloat atal8;\n+typedef _Complex double Tal8cdouble atal8;\n+typedef _Complex long double Tal8cldouble atal8;\n+typedef bool Tal8bool atal8;\n+typedef enum E0 Tal8E0 atal8;\n+typedef enum E1 Tal8E1 atal8;\n+typedef enum E2 Tal8E2 atal8;\n+typedef enum E3 Tal8E3 atal8;\n+typedef enum E4 Tal8E4 atal8;\n+typedef enum E5 Tal8E5 atal8;\n+typedef enum E6 Tal8E6 atal8;\n+typedef enum E7 Tal8E7 atal8;\n+typedef enum E8 Tal8E8 atal8;\n+typedef enum E9 Tal8E9 atal8;\n+typedef void *Tal8ptr atal8;\n+typedef char *Tal8cptr atal8;\n+typedef int *Tal8iptr atal8;\n+typedef char Tal16char atal16;\n+typedef signed char Tal16schar atal16;\n+typedef unsigned char Tal16uchar atal16;\n+typedef short int Tal16short atal16;\n+typedef unsigned short int Tal16ushort atal16;\n+typedef int Tal16int atal16;\n+typedef unsigned int Tal16uint atal16;\n+typedef long int Tal16long atal16;\n+typedef unsigned long int Tal16ulong atal16;\n+typedef long long int Tal16llong atal16;\n+typedef unsigned long long int Tal16ullong atal16;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal16cchar atal16;\n+typedef _Complex signed char Tal16cschar atal16;\n+typedef _Complex unsigned char Tal16cuchar atal16;\n+typedef _Complex short int Tal16cshort atal16;\n+typedef _Complex unsigned short int Tal16cushort atal16;\n+typedef _Complex int Tal16cint atal16;\n+typedef _Complex unsigned int Tal16cuint atal16;\n+typedef _Complex long int Tal16clong atal16;\n+typedef _Complex unsigned long int Tal16culong atal16;\n+typedef _Complex long long int Tal16cllong atal16;\n+typedef _Complex unsigned long long int Tal16cullong atal16;\n+#endif\n+typedef float Tal16float atal16;\n+typedef double Tal16double atal16;\n+typedef long double Tal16ldouble atal16;\n+typedef _Complex float Tal16cfloat atal16;\n+typedef _Complex double Tal16cdouble atal16;\n+typedef _Complex long double Tal16cldouble atal16;\n+typedef bool Tal16bool atal16;\n+typedef enum E0 Tal16E0 atal16;\n+typedef enum E1 Tal16E1 atal16;\n+typedef enum E2 Tal16E2 atal16;\n+typedef enum E3 Tal16E3 atal16;\n+typedef enum E4 Tal16E4 atal16;\n+typedef enum E5 Tal16E5 atal16;\n+typedef enum E6 Tal16E6 atal16;\n+typedef enum E7 Tal16E7 atal16;\n+typedef enum E8 Tal16E8 atal16;\n+typedef enum E9 Tal16E9 atal16;\n+typedef void *Tal16ptr atal16;\n+typedef char *Tal16cptr atal16;\n+typedef int *Tal16iptr atal16;\n+typedef int (*Tfnptr) (void);\n+\n+/* Bitfield macros.  In C, it is invalid to use numbers larger\n+   than type's bitsize, but we don't know the size when generating\n+   the testcases.  */\n+#define BN8(n) ((((n) - 1) & 7) + 1)\n+#define BN16(n) ((((n) - 1) & 15) + 1)\n+#define BN32(n) ((((n) - 1) & 31) + 1)\n+#define BN64(n) ((((n) - 1) & 63) + 1)\n+#define BCN(n) BN8 (n)\n+#if USHRT_MAX == 255\n+# define BSN(n) BN8 (n)\n+#elif USHRT_MAX == 65535\n+# define BSN(n) BN16 (n)\n+#elif USHRT_MAX == 4294967295U\n+# define BSN(n) BN32 (n)\n+#elif USHRT_MAX == 18446744073709551615ULL\n+# define BSN(n) BN64 (n)\n+#endif\n+#if UINT_MAX == 255\n+# define BIN(n) BN8 (n)\n+#elif UINT_MAX == 65535\n+# define BIN(n) BN16 (n)\n+#elif UINT_MAX == 4294967295U\n+# define BIN(n) BN32 (n)\n+#elif UINT_MAX == 18446744073709551615ULL\n+# define BIN(n) BN64 (n)\n+#endif\n+#if ULONG_MAX == 255\n+# define BLN(n) BN8 (n)\n+#elif ULONG_MAX == 65535\n+# define BLN(n) BN16 (n)\n+#elif ULONG_MAX == 4294967295U\n+# define BLN(n) BN32 (n)\n+#elif ULONG_MAX == 18446744073709551615ULL\n+# define BLN(n) BN64 (n)\n+#endif\n+#if ULONG_MAX == 255\n+# define BLN(n) BN8 (n)\n+#elif ULONG_MAX == 65535\n+# define BLN(n) BN16 (n)\n+#elif ULONG_MAX == 4294967295U\n+# define BLN(n) BN32 (n)\n+#elif ULONG_MAX == 18446744073709551615ULL\n+# define BLN(n) BN64 (n)\n+#endif\n+#if !defined ULLONG_MAX && defined __LONG_LONG_MAX__\n+# define ULLONG_MAX (__LONG_LONG_MAX__ * 2ULL + 1ULL)\n+#endif\n+#if ULLONG_MAX == 255\n+# define BQN(n) BN8 (n)\n+#elif ULLONG_MAX == 65535\n+# define BQN(n) BN16 (n)\n+#elif ULLONG_MAX == 4294967295U\n+# define BQN(n) BN32 (n)\n+#elif ULLONG_MAX == 18446744073709551615ULL\n+# define BQN(n) BN64 (n)\n+#endif\n+\n+#define T(n, fields, ops) TX(n, struct, , fields, ({ ops });)\n+#define U(n, fields, ops) TX(n, union, , fields, ({ ops });)\n+#ifdef SKIP_COMPLEX_INT\n+#define TXCI(n, type, attrs, fields, ops)\n+#define TCI(n, fields, ops)\n+#define UCI(n, fields, ops)\n+#else\n+#define TXCI(n, type, attrs, fields, ops) TX(n, type, attrs, fields, ({ ops });)\n+#define TCI(n, fields, ops) TX(n, struct, , fields, ({ ops });)\n+#define UCI(n, fields, ops) TX(n, union, , fields, ({ ops });)\n+#endif"}, {"sha": "751d43d1a55c65c1c69360fadef8c72489f65c7b", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c", "status": "added", "additions": 1562, "deletions": 0, "changes": 1562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,1562 @@\n+/* Structure layout test generator.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Compile with gcc -I$(srcdir)/../include -{I,L}$(objdir)/../libiberty/ \\\n+   -o struct-layout-1_generate{,.c} generate_random{,_r}.c -liberty */\n+\n+#include \"config.h\"\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n+#include \"libiberty.h\"\n+#include <stdio.h>\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#include \"hashtab.h\"\n+#include \"getopt.h\"\n+/* We use our own pseudo-random number generator, so that it gives the same\n+   values on all hosts.  */\n+#include \"generate-random.h\"\n+\n+#if LLONG_MAX != 9223372036854775807LL && __LONG_LONG_MAX__ != 9223372036854775807LL\n+# error Need 64-bit long long\n+#endif\n+\n+enum TYPE\n+{\n+  TYPE_INT,\n+  TYPE_UINT,\n+  TYPE_CINT,\n+  TYPE_CUINT,\n+  TYPE_FLOAT,\n+  TYPE_CFLOAT,\n+  TYPE_SENUM,\n+  TYPE_UENUM,\n+  TYPE_PTR,\n+  TYPE_FNPTR,\n+  TYPE_OTHER\n+};\n+\n+struct types\n+{\n+  const char *name;\n+  enum TYPE type;\n+  unsigned long long int maxval;\n+  char bitfld;\n+};\n+\n+struct types base_types[] = {\n+/* As we don't know whether char will be signed or not, just limit ourselves\n+   to unsigned values less than maximum signed char value.  */\n+{ \"char\", TYPE_UINT, 127, 'C' },\n+{ \"signed char\", TYPE_INT, 127, 'C' },\n+{ \"unsigned char\", TYPE_UINT, 255, 'C' },\n+{ \"short int\", TYPE_INT, 32767, 'S' },\n+{ \"unsigned short int\", TYPE_UINT, 65535, 'S' },\n+{ \"int\", TYPE_INT, 2147483647, 'I' },\n+{ \"unsigned int\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"long int\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"unsigned long int\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"long long int\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"unsigned long long int\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"bool\", TYPE_UINT, 1, 'B' },\n+{ \"void *\", TYPE_PTR, 0, 0 },\n+{ \"char *\", TYPE_PTR, 0, 0 },\n+{ \"int *\", TYPE_PTR, 0, 0 },\n+{ \"float\", TYPE_FLOAT, 0, 0 },\n+{ \"double\", TYPE_FLOAT, 0, 0 },\n+{ \"long double\", TYPE_FLOAT, 0, 0 },\n+#define NTYPES1 18\n+{ \"Tchar\", TYPE_UINT, 127, 'C' },\n+{ \"Tschar\", TYPE_INT, 127, 'C' },\n+{ \"Tuchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tshort\", TYPE_INT, 32767, 'S' },\n+{ \"Tushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tint\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tuint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tlong\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tllong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tbool\", TYPE_UINT, 1, 'B' },\n+{ \"size_t\", TYPE_UINT, 18446744073709551615ULL, 0 },\n+{ \"Tptr\", TYPE_PTR, 0, 0 },\n+{ \"Tcptr\", TYPE_PTR, 0, 0 },\n+{ \"Tiptr\", TYPE_PTR, 0, 0 },\n+{ \"Tfnptr\", TYPE_FNPTR, 0, 0 },\n+{ \"Tfloat\", TYPE_FLOAT, 0, 0 },\n+{ \"Tdouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"enum E0\", TYPE_UENUM, 0, ' ' },\n+{ \"enum E1\", TYPE_UENUM, 1, ' ' },\n+{ \"enum E2\", TYPE_SENUM, 3, ' ' },\n+{ \"enum E3\", TYPE_SENUM, 127, ' ' },\n+{ \"enum E4\", TYPE_UENUM, 255, ' ' },\n+{ \"enum E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"enum E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"enum E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"enum E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"enum E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"TE0\", TYPE_UENUM, 0, ' ' },\n+{ \"TE1\", TYPE_UENUM, 1, ' ' },\n+{ \"TE2\", TYPE_SENUM, 3, ' ' },\n+{ \"TE3\", TYPE_SENUM, 127, ' ' },\n+{ \"TE4\", TYPE_UENUM, 255, ' ' },\n+{ \"TE5\", TYPE_SENUM, 32767, ' ' },\n+{ \"TE6\", TYPE_UENUM, 65535, ' ' },\n+{ \"TE7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"TE8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"TE9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+/* vector-defs.h typedefs */\n+{ \"qi\", TYPE_INT, 127, 0 },\n+{ \"hi\", TYPE_INT, 32767, 0 },\n+{ \"si\", TYPE_INT, 2147483647, 0 },\n+{ \"di\", TYPE_INT, 9223372036854775807LL, 0 },\n+{ \"sf\", TYPE_FLOAT, 0, 0 },\n+{ \"df\", TYPE_FLOAT, 0, 0 }\n+#define NTYPES2 (sizeof (base_types) / sizeof (base_types[0]))\n+};\n+struct types complex_types[] = {\n+{ \"_Complex char\", TYPE_CUINT, 127, 0 },\n+{ \"_Complex signed char\", TYPE_CINT, 127, 0 },\n+{ \"_Complex unsigned char\", TYPE_CUINT, 255, 0 },\n+{ \"_Complex short int\", TYPE_CINT, 32767, 0 },\n+{ \"_Complex unsigned short int\", TYPE_CUINT, 65535, 0 },\n+{ \"_Complex int\", TYPE_CINT, 2147483647, 0 },\n+{ \"_Complex unsigned int\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"_Complex long int\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"_Complex unsigned long int\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"_Complex long long int\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"_Complex unsigned long long int\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"_Complex float\", TYPE_CFLOAT, 0, 0 },\n+{ \"_Complex double\", TYPE_CFLOAT, 0, 0 },\n+{ \"_Complex long double\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tcchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tcschar\", TYPE_CINT, 127, 0 },\n+{ \"Tcuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tcshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tcushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tcint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tcuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tclong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tculong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tcllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tcullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tcfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tcdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tcldouble\", TYPE_CFLOAT, 0, 0 }\n+#define NCTYPES2 (sizeof (complex_types) / sizeof (complex_types[0]))\n+};\n+struct types vector_types[] = {\n+/* vector-defs.h typedefs */\n+{ \"v8qi\", TYPE_OTHER, 0, 0 },\n+{ \"v16qi\", TYPE_OTHER, 0, 0 },\n+{ \"v2hi\", TYPE_OTHER, 0, 0 },\n+{ \"v4hi\", TYPE_OTHER, 0, 0 },\n+{ \"v8hi\", TYPE_OTHER, 0, 0 },\n+{ \"v2si\", TYPE_OTHER, 0, 0 },\n+{ \"v4si\", TYPE_OTHER, 0, 0 },\n+{ \"v1di\", TYPE_OTHER, 0, 0 },\n+{ \"v2di\", TYPE_OTHER, 0, 0 },\n+{ \"v2sf\", TYPE_OTHER, 0, 0 },\n+{ \"v4sf\", TYPE_OTHER, 0, 0 },\n+{ \"v16sf\", TYPE_OTHER, 0, 0 },\n+{ \"v2df\", TYPE_OTHER, 0, 0 },\n+{ \"u8qi\", TYPE_OTHER, 0, 0 },\n+{ \"u16qi\", TYPE_OTHER, 0, 0 },\n+{ \"u2hi\", TYPE_OTHER, 0, 0 },\n+{ \"u4hi\", TYPE_OTHER, 0, 0 },\n+{ \"u8hi\", TYPE_OTHER, 0, 0 },\n+{ \"u2si\", TYPE_OTHER, 0, 0 },\n+{ \"u4si\", TYPE_OTHER, 0, 0 },\n+{ \"u1di\", TYPE_OTHER, 0, 0 },\n+{ \"u2di\", TYPE_OTHER, 0, 0 },\n+{ \"u2sf\", TYPE_OTHER, 0, 0 },\n+{ \"u4sf\", TYPE_OTHER, 0, 0 },\n+{ \"u16sf\", TYPE_OTHER, 0, 0 },\n+{ \"u2df\", TYPE_OTHER, 0, 0 },\n+{ \"__m64\", TYPE_OTHER, 0, 0 },\n+{ \"__m128\", TYPE_OTHER, 0, 0 }\n+#define NVTYPES2 (sizeof (vector_types) / sizeof (vector_types[0]))\n+};\n+struct types attrib_types[] = {\n+{ \"Talchar\", TYPE_UINT, 127, 'C' },\n+{ \"Talschar\", TYPE_INT, 127, 'C' },\n+{ \"Taluchar\", TYPE_UINT, 255, 'C' },\n+{ \"Talshort\", TYPE_INT, 32767, 'S' },\n+{ \"Talushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talint\", TYPE_INT, 2147483647, 'I' },\n+{ \"Taluint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tallong\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talllong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talbool\", TYPE_UINT, 1, 'B' },\n+{ \"Talptr\", TYPE_PTR, 0, 0 },\n+{ \"Talcptr\", TYPE_PTR, 0, 0 },\n+{ \"Taliptr\", TYPE_PTR, 0, 0 },\n+{ \"Talfloat\", TYPE_FLOAT, 0, 0 },\n+{ \"Taldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"TalE0\", TYPE_UENUM, 0, ' ' },\n+{ \"TalE1\", TYPE_UENUM, 1, ' ' },\n+{ \"TalE2\", TYPE_SENUM, 3, ' ' },\n+{ \"TalE3\", TYPE_SENUM, 127, ' ' },\n+{ \"TalE4\", TYPE_UENUM, 255, ' ' },\n+{ \"TalE5\", TYPE_SENUM, 32767, ' ' },\n+{ \"TalE6\", TYPE_UENUM, 65535, ' ' },\n+{ \"TalE7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"TalE8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"TalE9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal1char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal1schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal1uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal1short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal1ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal1int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal1uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal1long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal1ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal1llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal1ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal1bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal1ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal1E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal1E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal1E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal1E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal1E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal1E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal1E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal1E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal1E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal2char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal2schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal2uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal2short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal2ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal2int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal2uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal2long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal2ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal2llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal2ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal2bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal2ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal2E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal2E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal2E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal2E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal2E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal2E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal2E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal2E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal2E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal4char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal4schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal4uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal4short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal4ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal4int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal4uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal4long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal4ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal4llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal4ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal4bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal4ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal4E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal4E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal4E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal4E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal4E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal4E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal4E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal4E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal4E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal8char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal8schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal8uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal8short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal8ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal8int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal8uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal8long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal8ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal8llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal8ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal8bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal8ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal8E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal8E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal8E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal8E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal8E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal8E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal8E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal8E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal8E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal16char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal16schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal16uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal16short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal16ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal16int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal16uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal16long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal16ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal16llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal16ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal16bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal16ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal16E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal16E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal16E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal16E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal16E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal16E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal16E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal16E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal16E9\", TYPE_SENUM, 1099511627775LL, ' ' }\n+#define NATYPES2 (sizeof (attrib_types) / sizeof (attrib_types[0]))\n+};\n+struct types complex_attrib_types[] = {\n+{ \"Talcchar\", TYPE_CUINT, 127, 0 },\n+{ \"Talcschar\", TYPE_CINT, 127, 0 },\n+{ \"Talcuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Talcshort\", TYPE_CINT, 32767, 0 },\n+{ \"Talcushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Talcint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talcuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talclong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talculong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talcllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talcullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talcfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talcdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talcldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal1cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal1cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal1cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal1cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal1cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal1cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal1cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal1clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal1culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal1cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal1cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal1cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal1cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal1cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal2cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal2cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal2cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal2cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal2cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal2cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal2cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal2clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal2culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal2cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal2cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal2cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal2cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal2cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal4cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal4cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal4cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal4cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal4cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal4cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal4cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal4clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal4culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal4cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal4cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal4cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal4cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal4cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal8cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal8cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal8cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal8cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal8cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal8cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal8cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal8clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal8culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal8cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal8cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal8cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal8cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal8cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal16cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal16cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal16cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal16cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal16cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal16cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal16cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal16clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal16culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal16cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal16cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal16cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal16cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal16cldouble\", TYPE_CFLOAT, 0, 0 }\n+#define NCATYPES2 (sizeof (complex_attrib_types) / sizeof (complex_attrib_types[0]))\n+};\n+\n+struct types bitfld_types[NTYPES2];\n+int n_bitfld_types;\n+struct types aligned_bitfld_types[NATYPES2];\n+int n_aligned_bitfld_types;\n+\n+const char *attributes[] = {\n+\"atal\", \n+\"atpa\", \n+\"atal1\", \n+\"atal2\", \n+\"atal4\", \n+\"atal8\", \n+\"atal16\", \n+#define NATTRIBS1 7\n+\"atalpa\", \n+\"atpaal\", \n+\"atal1pa\", \n+\"atal2pa\", \n+\"atal4pa\", \n+\"atal8pa\", \n+\"atal16pa\", \n+\"atpaal1\", \n+\"atpaal2\", \n+\"atpaal4\", \n+\"atpaal8\", \n+\"atpaal16\"\n+#define NATTRIBS2 (sizeof (attributes) / sizeof (attributes[0]))\n+};\n+\n+enum ETYPE\n+{\n+  ETYPE_TYPE,\n+  ETYPE_ARRAY,\n+  ETYPE_BITFLD,\n+  ETYPE_STRUCT,\n+  ETYPE_UNION,\n+  ETYPE_STRUCT_ARRAY,\n+  ETYPE_UNION_ARRAY\n+};\n+\n+struct entry\n+{\n+#ifdef __GNUC__\n+  enum ETYPE etype : 8;\n+#else\n+  unsigned char etype;\n+#endif\n+  unsigned short len;\n+  unsigned char arr_len;\n+  struct types *type;\n+  const char *attrib;\n+};\n+\n+static int idx, limidx, output_one;\n+static const char *destdir;\n+static const char *srcdir;\n+FILE *outfile;\n+\n+void\n+switchfiles (int fields)\n+{\n+  static int filecnt;\n+  static char *destbuf, *destptr;\n+  ++filecnt;\n+  if (outfile)\n+    fclose (outfile);\n+  if (output_one)\n+    {\n+      outfile = stdout;\n+      return;\n+    }\n+  if (destbuf == NULL)\n+    {\n+      size_t len = strlen (destdir);\n+      destbuf = xmalloc (len + 20);\n+      memcpy (destbuf, destdir, len);\n+      if (!len || destbuf[len - 1] != '/')\n+\tdestbuf[len++] = '/';\n+      destptr = destbuf + len;\n+    }\n+  sprintf (destptr, \"t%03d_main.c\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    {\n+    fail:\n+      fputs (\"failed to create test files\\n\", stderr);\n+      exit (1);\n+    }\n+  fprintf (outfile, \"\\\n+/* { dg-options \\\"-I%s\\\" } */\\n\\\n+#include \\\"struct-layout-1.h\\\"\\n\\\n+\\n\\\n+#define TX(n, type, attrs, fields, ops) extern void test##n (void);\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#undef TX\\n\\\n+\\n\\\n+int main (void)\\n\\\n+{\\n\\\n+#define TX(n, type, attrs, fields, ops)   test##n ();\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#undef TX\\n\\\n+  if (fails)\\n\\\n+    abort ();\\n\\\n+  exit (0);\\n\\\n+}\\n\", srcdir, filecnt, filecnt);\n+  fclose (outfile);\n+  sprintf (destptr, \"t%03d_x.c\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    goto fail;\n+  fprintf (outfile, \"\\\n+/* { dg-options \\\"-w -I%s\\\" } */\\n\\\n+#include \\\"struct-layout-1_x1.h\\\"\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#include \\\"struct-layout-1_x2.h\\\"\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\", srcdir, filecnt, filecnt);\n+  fclose (outfile);\n+  sprintf (destptr, \"t%03d_y.c\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    goto fail;\n+  fprintf (outfile, \"\\\n+/* { dg-options \\\"-w -I%s\\\" } */\\n\\\n+#include \\\"struct-layout-1_y1.h\\\"\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#include \\\"struct-layout-1_y2.h\\\"\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\", srcdir, filecnt, filecnt);\n+  fclose (outfile);\n+  sprintf (destptr, \"t%03d_test.h\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    goto fail;\n+  if (fields <= 2)\n+    limidx = idx + 300;\n+  else if (fields <= 4)\n+    limidx = idx + 200;\n+  else if (fields <= 6)\n+    limidx = idx + 100;\n+  else\n+    limidx = idx + 50;\n+}\n+\n+unsigned long long int\n+getrandll (void)\n+{\n+  unsigned long long int ret;\n+  ret = generate_random () & 0xffffff;\n+  ret |= (generate_random () & 0xffffffLL) << 24;\n+  ret |= ((unsigned long long int) generate_random ()) << 48;\n+  return ret;\n+}\n+\n+int\n+subfield (struct entry *e, char *letter)\n+{\n+  int i, type;\n+  char buf[20];\n+  const char *p;\n+  switch (e[0].etype)\n+    {\n+    case ETYPE_STRUCT:\n+    case ETYPE_UNION:\n+    case ETYPE_STRUCT_ARRAY:\n+    case ETYPE_UNION_ARRAY:\n+      type = e[0].attrib ? 1 + (generate_random () & 3) : 0;\n+      if (e[0].etype == ETYPE_STRUCT || e[0].etype == ETYPE_STRUCT_ARRAY)\n+\tp = \"struct\";\n+      else\n+\tp = \"union\";\n+      if (e[0].etype == ETYPE_STRUCT_ARRAY || e[0].etype == ETYPE_UNION_ARRAY)\n+\t{\n+\t  if (e[0].arr_len == 255)\n+\t    snprintf (buf, 20, \"%c[]\", *letter);\n+\t  else\n+\t    snprintf (buf, 20, \"%c[%d]\", *letter, e[0].arr_len);\n+\t}\n+      else\n+        {\n+          buf[0] = *letter;\n+          buf[1] = '\\0';\n+        }\n+      ++*letter;\n+      switch (type)\n+        {\n+        case 0:\n+        case 3:\n+        case 4:\n+          fprintf (outfile, \"%s{\", p);\n+          break;\n+        case 1:\n+          fprintf (outfile, \"%s %s{\", e[0].attrib, p);\n+          break;\n+        case 2:\n+          fprintf (outfile, \"%s %s{\", p, e[0].attrib);\n+          break;\n+        }\n+\n+      for (i = 1; i <= e[0].len; )\n+\ti += subfield (e + i, letter);\n+\n+      switch (type)\n+        {\n+        case 0:\n+        case 1:\n+        case 2:\n+          fprintf (outfile, \"}%s;\", buf);\n+          break;\n+\tcase 3:\n+\t  fprintf (outfile, \"}%s %s;\", e[0].attrib, buf);\n+\t  break;\n+\tcase 4:\n+\t  fprintf (outfile, \"}%s %s;\", buf, e[0].attrib);\n+\t  break;\n+        }\n+      return 1 + e[0].len;\n+    case ETYPE_TYPE:\n+    case ETYPE_ARRAY:\n+      if (e[0].etype == ETYPE_ARRAY)\n+\t{\n+\t  if (e[0].arr_len == 255)\n+\t    snprintf (buf, 20, \"%c[]\", *letter);\n+\t  else\n+\t    snprintf (buf, 20, \"%c[%d]\", *letter, e[0].arr_len);\n+\t}\n+      else\n+        {\n+          buf[0] = *letter;\n+          buf[1] = '\\0';\n+        }\n+      ++*letter;\n+      if (e[0].attrib)\n+\tswitch (generate_random () % 3)\n+          {\n+          case 0:\n+            fprintf (outfile, \"%s %s %s;\", e[0].attrib, e[0].type->name, buf);\n+            break;\n+          case 1:\n+            fprintf (outfile, \"%s %s %s;\", e[0].type->name, e[0].attrib, buf);\n+            break;\n+          case 2:\n+            fprintf (outfile, \"%s %s %s;\", e[0].type->name, buf, e[0].attrib);\n+            break;\n+          }\n+      else\n+\tfprintf (outfile, \"%s %s;\", e[0].type->name, buf);\n+      return 1;\n+    case ETYPE_BITFLD:\n+      if (e[0].len == 0)\n+\t{\n+\t  if (e[0].attrib)\n+\t    switch (generate_random () % 3)\n+\t      {\n+\t      case 0:\n+\t\tfprintf (outfile, \"%s %s:0;\", e[0].attrib, e[0].type->name);\n+\t\tbreak;\n+\t      case 1:\n+\t\tfprintf (outfile, \"%s %s:0;\", e[0].type->name, e[0].attrib);\n+\t\tbreak;\n+\t      case 2:\n+\t\tfprintf (outfile, \"%s:0 %s;\", e[0].type->name, e[0].attrib);\n+\t\tbreak;\n+\t      }\n+\t  else\n+\t    fprintf (outfile, \"%s:0;\", e[0].type->name);\n+\t  ++*letter;\n+\t  return 1;\n+\t}\n+      switch (e[0].type->bitfld)\n+\t{\n+\tcase 'C':\n+\tcase 'S':\n+\tcase 'I':\n+\tcase 'L':\n+\tcase 'Q':\n+\t  snprintf (buf, 20, \"B%cN(%d)\", e[0].type->bitfld, e[0].len);\n+\t  break;\n+\tcase 'B':\n+\tcase ' ':\n+\t  snprintf (buf, 20, \"%d\", e[0].len);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      if (e[0].attrib)\n+\tswitch (generate_random () % 3)\n+\t  {\n+\t  case 0:\n+\t    fprintf (outfile, \"%s %s %c:%s;\", e[0].attrib, e[0].type->name,\n+\t\t     *letter, buf);\n+\t    break;\n+\t  case 1:\n+\t    fprintf (outfile, \"%s %s %c:%s;\", e[0].type->name, e[0].attrib,\n+\t\t     *letter, buf);\n+\t    break;\n+\t  case 2:\n+\t    fprintf (outfile, \"%s %c:%s %s;\", e[0].type->name, *letter,\n+\t\t     buf, e[0].attrib);\n+\t    break;\n+\t  }\n+      else\n+\tfprintf (outfile, \"%s %c:%s;\", e[0].type->name, *letter, buf);\n+      ++*letter;\n+      return 1;\n+    default:\n+      abort ();\n+  }\n+}\n+\n+char namebuf[1024];\n+\n+void\n+output_FNB (char mode, struct entry *e)\n+{\n+  unsigned long long int l1, l2, m;\n+  int signs = 0;\n+  const char *p, *q;\n+\n+  if (e->type->type == TYPE_OTHER)\n+    {\n+      if (mode == 'B')\n+        abort ();\n+      fprintf (outfile, \"N(%d,%s)\", idx, namebuf);\n+      return;\n+    }\n+  fprintf (outfile, \"%c(%d,%s,\", mode, idx, namebuf);\n+  l1 = getrandll ();\n+  l2 = getrandll ();\n+  switch (e->type->type)\n+    {\n+    case TYPE_INT:\n+      signs = generate_random () & 3;\n+      m = e->type->maxval;\n+      if (mode == 'B')\n+\tm &= e->len > 1 ? (1ULL << (e->len - 1)) - 1 : 1;\n+      l1 &= m;\n+      l2 &= m;\n+      fprintf (outfile, \"%s%llu%s,%s%llu%s\",\n+\t       (signs & 1) ? \"-\" : \"\", l1, l1 > 2147483647 ? \"LL\" : \"\",\n+\t       (signs & 2) ? \"-\" : \"\", l2, l2 > 2147483647 ? \"LL\" : \"\");\n+      break;\n+    case TYPE_UINT:\n+      m = e->type->maxval;\n+      if (mode == 'B')\n+\tm &= (1ULL << e->len) - 1;\n+      l1 &= m;\n+      l2 &= m;\n+      fprintf (outfile, \"%lluU%s,%lluU%s\", l1, l1 > 4294967295U ? \"LL\" : \"\",\n+\t       l2, l2 > 4294967295U ? \"LL\" : \"\");\n+      break;\n+    case TYPE_FLOAT:\n+      l1 &= 0xffffff;\n+      l2 &= 0xffffff;\n+      signs = generate_random () & 3;\n+      fprintf (outfile, \"%s%f,%s%f\", (signs & 1) ? \"-\" : \"\",\n+\t       ((double) l1) / 64, (signs & 2) ? \"-\" : \"\", ((double) l2) / 64);\n+      break;\n+    case TYPE_CINT:\n+      signs = generate_random () & 3;\n+      l1 &= e->type->maxval;\n+      l2 &= e->type->maxval;\n+      fprintf (outfile, \"CINT(%s%llu%s,%s%llu%s),\",\n+\t       (signs & 1) ? \"-\" : \"\", l1, l1 > 2147483647 ? \"LL\" : \"\",\n+\t       (signs & 2) ? \"-\" : \"\", l2, l2 > 2147483647 ? \"LL\" : \"\");\n+      signs = generate_random () & 3;\n+      l1 = getrandll ();\n+      l2 = getrandll ();\n+      l1 &= e->type->maxval;\n+      l2 &= e->type->maxval;\n+      fprintf (outfile, \"CINT(%s%llu%s,%s%llu%s)\",\n+\t       (signs & 1) ? \"-\" : \"\", l1, l1 > 2147483647 ? \"LL\" : \"\",\n+\t       (signs & 2) ? \"-\" : \"\", l2, l2 > 2147483647 ? \"LL\" : \"\");\n+      break;\n+    case TYPE_CUINT:\n+      l1 &= e->type->maxval;\n+      l2 &= e->type->maxval;\n+      fprintf (outfile, \"CINT(%lluU%s,%lluU%s),\",\n+\t       l1, l1 > 4294967295U ? \"LL\" : \"\",\n+\t       l2, l2 > 4294967295U ? \"LL\" : \"\");\n+      l1 = getrandll ();\n+      l2 = getrandll ();\n+      l1 &= e->type->maxval;\n+      l2 &= e->type->maxval;\n+      fprintf (outfile, \"CINT(%lluU%s,%lluU%s)\",\n+\t       l1, l1 > 4294967295U ? \"LL\" : \"\",\n+\t       l2, l2 > 4294967295U ? \"LL\" : \"\");\n+      break;\n+    case TYPE_CFLOAT:\n+      l1 &= 0xffffff;\n+      l2 &= 0xffffff;\n+      signs = generate_random () & 3;\n+      fprintf (outfile, \"CDBL(%s%f,%s%f),\",\n+\t       (signs & 1) ? \"-\" : \"\", ((double) l1) / 64,\n+\t       (signs & 2) ? \"-\" : \"\", ((double) l2) / 64);\n+      l1 = getrandll ();\n+      l2 = getrandll ();\n+      l1 &= 0xffffff;\n+      l2 &= 0xffffff;\n+      signs = generate_random () & 3;\n+      fprintf (outfile, \"CDBL(%s%f,%s%f)\",\n+\t       (signs & 1) ? \"-\" : \"\", ((double) l1) / 64,\n+\t       (signs & 2) ? \"-\" : \"\", ((double) l2) / 64);\n+      break;\n+    case TYPE_UENUM:\n+      if (e->type->maxval == 0)\n+\tfputs (\"e0_0,e0_0\", outfile);\n+      else if (e->type->maxval == 1)\n+        fprintf (outfile, \"e1_%lld,e1_%lld\", l1 & 1, l2 & 1);\n+      else\n+        {\n+\t  p = strchr (e->type->name, '\\0');\n+\t  while (--p >= e->type->name && *p >= '0' && *p <= '9');\n+\t  p++;\n+          l1 %= 7;\n+          l2 %= 7;\n+          if (l1 > 3)\n+            l1 += e->type->maxval - 6;\n+          if (l2 > 3)\n+            l2 += e->type->maxval - 6;\n+\t  fprintf (outfile, \"e%s_%lld,e%s_%lld\", p, l1, p, l2);\n+        }\n+      break;\n+    case TYPE_SENUM:\n+      p = strchr (e->type->name, '\\0');\n+      while (--p >= e->type->name && *p >= '0' && *p <= '9');\n+      p++;\n+      l1 %= 7;\n+      l2 %= 7;\n+      fprintf (outfile, \"e%s_%s%lld,e%s_%s%lld\",\n+\t       p, l1 < 3 ? \"m\" : \"\",\n+\t       l1 == 3 ? 0LL : e->type->maxval - (l1 & 3),\n+\t       p, l2 < 3 ? \"m\" : \"\",\n+\t       l2 == 3 ? 0LL : e->type->maxval - (l2 & 3));\n+      break;\n+    case TYPE_PTR:\n+      l1 %= 256;\n+      l2 %= 256;\n+      fprintf (outfile, \"(%s)&intarray[%lld],(%s)&intarray[%lld]\",\n+\t       e->type->name, l1, e->type->name, l2);\n+      break;\n+    case TYPE_FNPTR:\n+      l1 %= 10;\n+      l2 %= 10;\n+      fprintf (outfile, \"fn%lld,fn%lld\", l1, l2);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  fputs (\")\", outfile);\n+}\n+\n+int\n+subvalues (struct entry *e, char *p, char *letter)\n+{\n+  int i, j;\n+  char *q;\n+  if (p >= namebuf + sizeof (namebuf) - 32)\n+    abort ();\n+  p[0] = *letter;\n+  p[1] = '\\0';\n+  q = p + 1;\n+  switch (e[0].etype)\n+    {\n+    case ETYPE_STRUCT_ARRAY:\n+    case ETYPE_UNION_ARRAY:\n+      if (e[0].arr_len == 0 || e[0].arr_len == 255)\n+\t{\n+\t  *letter += 1 + e[0].len;\n+\t  return 1 + e[0].len;\n+\t}\n+      i = generate_random () % e[0].arr_len;\n+      snprintf (p, sizeof (namebuf) - (p - namebuf) - 1,\n+\t\t\"%c[%d]\", *letter, i);\n+      q = strchr (p, '\\0');\n+      /* FALLTHROUGH */\n+    case ETYPE_STRUCT:\n+    case ETYPE_UNION:\n+      *q++ = '.';\n+      ++*letter;\n+      for (i = 1; i <= e[0].len; )\n+\t{\n+\t  i += subvalues (e + i, q, letter);\n+\t  if (e[0].etype == ETYPE_UNION || e[0].etype == ETYPE_UNION_ARRAY)\n+\t    {\n+\t      *letter += e[0].len - i + 1;\n+\t      break;\n+\t    }\n+\t}\n+      return 1 + e[0].len;\n+    case ETYPE_TYPE:\n+      ++*letter;\n+      output_FNB ('F', e);\n+      return 1;\n+    case ETYPE_ARRAY:\n+      if (e[0].arr_len == 0 || e[0].arr_len == 255)\n+\t{\n+\t  ++*letter;\n+\t  return 1;\n+\t}\n+      i = generate_random () % e[0].arr_len;\n+      snprintf (p, sizeof (namebuf) - (p - namebuf),\n+\t\t\"%c[%d]\", *letter, i);\n+      output_FNB ('F', e);\n+      if ((generate_random () & 7) == 0)\n+\t{\n+\t  j = generate_random () % e[0].arr_len;\n+\t  if (i != j)\n+\t    {\n+\t      snprintf (p, sizeof (namebuf) - (p - namebuf),\n+\t\t\t\"%c[%d]\", *letter, j);\n+\t      output_FNB ('F', e);\n+\t    }\n+\t}\n+      ++*letter;\n+      return 1;\n+    case ETYPE_BITFLD:\n+      ++*letter;\n+      if (e[0].len != 0)\n+\toutput_FNB ('B', e);\n+      return 1;\n+    }\n+}\n+\n+hashval_t\n+e_hash (const void *a)\n+{\n+  const struct entry *e = a;\n+  hashval_t ret = 0;\n+  int i;\n+\n+  if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n+    abort ();\n+  for (i = 0; i <= e[0].len; ++i)\n+    {\n+      int attriblen;\n+      ret = iterative_hash (&e[i], offsetof (struct entry, attrib), ret);\n+      attriblen = e[i].attrib ? strlen (e[i].attrib) : -1;\n+      ret = iterative_hash (&attriblen, sizeof (int), ret);\n+      if (e[i].attrib)\n+        ret = iterative_hash (e[i].attrib, attriblen, ret);\n+    }\n+  return ret;\n+}\n+\n+int\n+e_eq (const void *a, const void *b)\n+{\n+  const struct entry *ea = a, *eb = b;\n+  int i;\n+  if (ea[0].etype != ETYPE_STRUCT && ea[0].etype != ETYPE_UNION)\n+    abort ();\n+  if (ea[0].len != eb[0].len)\n+    return 0;\n+  for (i = 0; i <= ea[0].len; ++i)\n+    {\n+      if (ea[i].etype != eb[i].etype\n+\t  || ea[i].len != eb[i].len\n+\t  || ea[i].arr_len != eb[i].arr_len\n+\t  || ea[i].type != eb[i].type)\n+\treturn 0;\n+      if ((ea[i].attrib == NULL) ^ (eb[i].attrib == NULL))\n+\treturn 0;\n+      if (ea[i].attrib && strcmp (ea[i].attrib, eb[i].attrib) != 0)\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n+htab_t hasht;\n+\n+void\n+output (struct entry *e)\n+{\n+  int i;\n+  char c;\n+  void **p;\n+  const char *skip_cint = \"\";\n+\n+  if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n+    abort ();\n+\n+  p = htab_find_slot (hasht, e, INSERT);\n+  if (*p != NULL)\n+    return;\n+\n+  *p = malloc ((e[0].len + 1) * sizeof (struct entry));\n+  memcpy (*p, e, (e[0].len + 1) * sizeof (struct entry));\n+\n+  if (idx == limidx)\n+    switchfiles (e[0].len);\n+\n+  for (i = 1; i <= e[0].len; ++i)\n+    if ((e[i].etype == ETYPE_TYPE || e[i].etype == ETYPE_ARRAY)\n+\t&& (e[i].type->type == TYPE_CINT || e[i].type->type == TYPE_CUINT))\n+      break;\n+  if (i <= e[0].len)\n+    skip_cint = \"CI\";\n+  if (e[0].attrib)\n+    fprintf (outfile, (generate_random () & 1)\n+\t     ? \"TX%s(%d,%s %s,,\" : \"TX%s(%d,%s,%s,\", skip_cint,\n+\t     idx, e[0].etype == ETYPE_STRUCT ? \"struct\" : \"union\",\n+\t     e[0].attrib);\n+  else if (e[0].etype == ETYPE_STRUCT)\n+    fprintf (outfile, \"T%s(%d,\", skip_cint, idx);\n+  else\n+    fprintf (outfile, \"U%s(%d,\", skip_cint, idx);\n+  c = 'a';\n+  for (i = 1; i <= e[0].len; )\n+    i += subfield (e + i, &c);\n+  fputs (\",\", outfile);\n+  c = 'a';\n+  for (i = 1; i <= e[0].len; )\n+    {\n+      i += subvalues (e + i, namebuf, &c);\n+      if (e[0].etype == ETYPE_UNION)\n+        break;\n+    }\n+  fputs (\")\\n\", outfile);\n+  if (output_one && idx == limidx)\n+    exit (0);\n+  ++idx;\n+}\n+\n+enum FEATURE\n+{\n+  FEATURE_VECTOR = 1,\n+  FEATURE_COMPLEX = 2,\n+  FEATURE_ALIGNEDPACKED = 4,\n+  FEATURE_ZEROARRAY = 8,\n+  FEATURE_ZEROBITFLD = 16,\n+  ALL_FEATURES = FEATURE_COMPLEX | FEATURE_VECTOR | FEATURE_ZEROARRAY\n+\t\t | FEATURE_ALIGNEDPACKED | FEATURE_ZEROBITFLD\n+};\n+\n+void\n+singles (enum FEATURE features)\n+{\n+  struct entry e[2];\n+  int i;\n+  memset (e, 0, sizeof (e));\n+  e[0].etype = ETYPE_STRUCT;\n+  output (e);\n+  e[0].etype = ETYPE_UNION;\n+  output (e);\n+  for (i = 0;\n+       i < ((features & FEATURE_ALIGNEDPACKED) ? NATTRIBS2 : NATTRIBS1);\n+       ++i)\n+    {\n+      e[0].attrib = attributes[i];\n+      e[0].etype = ETYPE_STRUCT;\n+      output (e);\n+      e[0].etype = ETYPE_UNION;\n+      output (e);\n+    }\n+  e[0].len = 1;\n+  e[0].attrib = NULL;\n+  for (i = 0; i < NTYPES2; ++i)\n+    {\n+      e[0].etype = ETYPE_STRUCT;\n+      e[1].etype = ETYPE_TYPE;\n+      e[1].type = &base_types[i];\n+      output (e);\n+      e[0].etype = ETYPE_UNION;\n+      output (e);\n+    }\n+  if (features & FEATURE_COMPLEX)\n+    for (i = 0; i < NCTYPES2; ++i)\n+      {\n+\te[0].etype = ETYPE_STRUCT;\n+\te[1].etype = ETYPE_TYPE;\n+\te[1].type = &complex_types[i];\n+\toutput (e);\n+\te[0].etype = ETYPE_UNION;\n+\toutput (e);\n+      }\n+  if (features & FEATURE_VECTOR)\n+    for (i = 0; i < NVTYPES2; ++i)\n+      {\n+\te[0].etype = ETYPE_STRUCT;\n+\te[1].etype = ETYPE_TYPE;\n+\te[1].type = &vector_types[i];\n+\toutput (e);\n+\te[0].etype = ETYPE_UNION;\n+\toutput (e);\n+      }\n+}\n+\n+void\n+choose_type (enum FEATURE features, struct entry *e, int r)\n+{\n+  int i;\n+\n+  i = NTYPES2 - NTYPES1;\n+  if (features & FEATURE_COMPLEX)\n+    i += NCTYPES2;\n+  if (features & FEATURE_VECTOR)\n+    i += NVTYPES2;\n+  if ((r & 3) == 0)\n+    {\n+      i += NATYPES2;\n+      if (features & FEATURE_COMPLEX)\n+        i += NCATYPES2;\n+    }\n+  r >>= 2;\n+  r %= i;\n+  if (r < NTYPES2 - NTYPES1)\n+    e->type = &base_types[r + NTYPES1];\n+  r -= NTYPES2 - NTYPES1;\n+  if (e->type == NULL && (features & FEATURE_COMPLEX))\n+    {\n+      if (r < NCTYPES2)\n+\te->type = &complex_types[r];\n+      r -= NCTYPES2;\n+    }\n+  if (e->type == NULL && (features & FEATURE_VECTOR))\n+    {\n+      if (r < NVTYPES2)\n+\te->type = &vector_types[r];\n+      r -= NVTYPES2;\n+    }\n+  if (e->type == NULL)\n+    {\n+      if (r < NATYPES2)\n+\te->type = &attrib_types[r];\n+      r -= NATYPES2;\n+    }\n+  if (e->type == NULL && (features & FEATURE_COMPLEX))\n+    {\n+      if (r < NCATYPES2)\n+\te->type = &complex_attrib_types[r];\n+      r -= NCATYPES2;\n+    }\n+  if (e->type == NULL)\n+    abort ();\n+}\n+\n+void\n+generate_fields (enum FEATURE features, struct entry *e, struct entry *parent,\n+\t\t int len)\n+{\n+  int r, i, j, ret = 1, n, incr, sametype;\n+\n+  for (n = 0; n < len; n += incr)\n+    {\n+      r = generate_random ();\n+      /* 50% ETYPE_TYPE base_types NTYPES1\n+\t 12.5% ETYPE_TYPE other\n+\t 12.5% ETYPE_ARRAY\n+\t 12.5% ETYPE_BITFLD\n+\t 12.5% ETYPE_STRUCT|ETYPE_UNION|ETYPE_STRUCT_ARRAY|ETYPE_UNION_ARRAY */\n+      i = (r & 7);\n+      r >>= 3;\n+      incr = 1;\n+      switch (i)\n+\t{\n+\tcase 0:\n+\tcase 1:\n+\tcase 2:\n+\tcase 3:\n+\t  e[n].etype = ETYPE_TYPE;\n+\t  e[n].type = &base_types[r % NTYPES1];\n+\t  break;\n+\tcase 4:\n+\t  e[n].etype = ETYPE_TYPE;\n+\t  choose_type (features, &e[n], r);\n+\t  break;\n+\tcase 5:\n+\t  e[n].etype = ETYPE_ARRAY;\n+\t  i = r & 1;\n+\t  r >>= 1;\n+\t  if (i)\n+\t    e[n].type = &base_types[r % NTYPES1];\n+\t  else\n+\t    choose_type (features, &e[n], r);\n+\t  r = generate_random ();\n+\t  if ((features & FEATURE_ZEROARRAY) && (r & 3) == 0)\n+\t    {\n+\t      e[n].arr_len = 0;\n+\t      if (n == len - 1 && (r & 4)\n+\t\t  && (parent->etype == ETYPE_STRUCT\n+\t\t      || parent->etype == ETYPE_STRUCT_ARRAY))\n+\t\t{\n+\t\t  int k;\n+\t\t  for (k = 0; k < n; ++k)\n+\t\t    if (e[k].etype != ETYPE_BITFLD || e[k].len)\n+\t\t      {\n+\t\t\te[n].arr_len = 255;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\t    }\n+\t  else if ((r & 3) != 3)\n+\t    e[n].arr_len = (r >> 2) & 7;\n+\t  else\n+\t    e[n].arr_len = (r >> 2) & 31;\n+\t  break;\n+\tcase 6:\n+\t  sametype = 1;\n+\t  switch (r & 7)\n+\t    {\n+\t    case 0:\n+\t    case 1:\n+\t    case 2:\n+\t      break;\n+\t    case 3:\n+\t    case 4:\n+\t    case 5:\n+\t      incr = 1 + (r >> 3) % (len - n);\n+\t      break;\n+\t    case 6:\n+\t    case 7:\n+\t      sametype = 0;\n+\t      incr = 1 + (r >> 3) % (len - n);\n+\t      break;\n+\t    }\n+\t  for (j = n; j < n + incr; ++j)\n+\t    {\n+\t      int mi, ma;\n+\n+\t      e[j].etype = ETYPE_BITFLD;\n+\t      if (j == n || !sametype)\n+\t\t{\n+\t\t  int k;\n+\t\t  r = generate_random ();\n+\t\t  k = r & 3;\n+\t\t  r >>= 2;\n+\t\t  if (!k)\n+\t\t    e[j].type\n+\t\t      = &aligned_bitfld_types[r % n_aligned_bitfld_types];\n+\t\t  else\n+\t\t    e[j].type\n+\t\t      = &bitfld_types[r % n_bitfld_types];\n+\t\t}\n+\t      else\n+\t\te[j].type = e[n].type;\n+\t      r = generate_random ();\n+\t      mi = 0;\n+\t      ma = 0;\n+\t      switch (e[j].type->bitfld)\n+\t        {\n+\t        case 'C': ma = 8; break;\n+\t        case 'S': ma = 16; break;\n+\t        case 'I': ma = 32; break;\n+\t        case 'L':\n+\t        case 'Q': ma = 64; break;\n+\t        case 'B': ma = 1; break;\n+\t        case ' ':\n+\t\t  if (e[j].type->type == TYPE_UENUM)\n+\t\t    mi = ffsll (e[j].type->maxval + 1) - 1;\n+\t\t  else if (e[j].type->type == TYPE_SENUM)\n+\t\t    mi = ffsll (e[j].type->maxval + 1);\n+\t\t  else\n+\t\t    abort ();\n+\t\t  if (!mi)\n+\t\t    mi = 1;\n+\t\t  if (mi <= 32)\n+\t\t    ma = 32;\n+\t\t  else\n+\t\t    ma = 64;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t        }\n+\t      e[j].len = ma + 1;\n+\t      if (sametype && (r & 3) == 0 && ma > 1)\n+\t\t{\n+\t\t  int sum = 0, k;\n+\t\t  for (k = n; k < j; ++k)\n+\t\t    sum += e[k].len;\n+\t\t  sum %= ma;\n+\t\t  e[j].len = sum ? ma - sum : ma;\n+\t\t}\n+\t      r >>= 2;\n+\t      if (! (features & FEATURE_ZEROBITFLD) && mi == 0)\n+\t\tmi = 1;\n+\t      if (e[j].len < mi || e[j].len > ma)\n+\t\te[j].len = mi + (r % (ma + 1 - mi));\n+\t      r >>= 6;\n+\t      if ((features & FEATURE_ZEROBITFLD) && (r & 3) == 0\n+\t\t  && mi == 0)\n+\t\te[j].len = 0;\n+\t    }\n+\t  break;\n+\tcase 7:\n+\t  switch (r & 7)\n+\t    {\n+\t    case 0:\n+\t    case 1:\n+\t    case 2:\n+\t      e[n].etype = ETYPE_STRUCT;\n+\t      break;\n+\t    case 3:\n+\t    case 4:\n+\t      e[n].etype = ETYPE_UNION;\n+\t      break;\n+\t    case 5:\n+\t    case 6:\n+\t      e[n].etype = ETYPE_STRUCT_ARRAY;\n+\t      break;\n+\t    case 7:\n+\t      e[n].etype = ETYPE_UNION_ARRAY;\n+\t      break;\n+\t    }\n+\t  r >>= 3;\n+\t  e[n].len = r % (len - n);\n+\t  incr = 1 + e[n].len;\n+\t  generate_fields (features, &e[n + 1], &e[n], e[n].len);\n+\t  if (e[n].etype == ETYPE_STRUCT_ARRAY\n+\t      || e[n].etype == ETYPE_UNION_ARRAY)\n+\t    {\n+\t      r = generate_random ();\n+\t      if ((features & FEATURE_ZEROARRAY) && (r & 3) == 0)\n+\t\t{\n+\t\t  e[n].arr_len = 0;\n+\t\t  if (n + incr == len && (r & 4)\n+\t\t      && (parent->etype == ETYPE_STRUCT\n+\t\t\t  || parent->etype == ETYPE_STRUCT_ARRAY))\n+\t\t    {\n+\t\t      int k;\n+\t\t      for (k = 0; k < n; ++k)\n+\t\t\tif (e[k].etype != ETYPE_BITFLD || e[k].len)\n+\t\t\t  {\n+\t\t\t    e[n].arr_len = 255;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\t      else if ((r & 3) != 3)\n+\t\te[n].arr_len = (r >> 2) & 7;\n+\t      else\n+\t\te[n].arr_len = (r >> 2) & 31;\n+\t    }\n+\t  break;\n+\t}\n+      r = generate_random ();\n+      if ((r & 7) == 0)\n+\t{\n+\t  r >>= 3;\n+\t  i = (features & FEATURE_ALIGNEDPACKED) ? NATTRIBS2 : NATTRIBS1;\n+\t  e[n].attrib = attributes[r % i];\n+\t  if (! (features & FEATURE_ALIGNEDPACKED)\n+\t      && strcmp (e[n].attrib, \"atpa\") == 0\n+\t      && ((e[n].type >= &attrib_types[0]\n+\t\t   && e[n].type < &attrib_types[NATYPES2])\n+\t\t  || (e[n].type >= &complex_attrib_types[0]\n+\t\t      && e[n].type < &complex_attrib_types[NCATYPES2])\n+\t\t  || (e[n].type >= &aligned_bitfld_types[0]\n+\t\t      && e[n].type < &aligned_bitfld_types[n_aligned_bitfld_types])))\n+\t    e[n].attrib = NULL;\n+\t}\n+    }\n+}\n+\n+void\n+generate_random_tests (enum FEATURE features, int len)\n+{\n+  struct entry e[len + 1];\n+  int i, r;\n+  if (len > 'z' - 'a' + 1)\n+    abort ();\n+  memset (e, 0, sizeof (e));\n+  r = generate_random ();\n+  if ((r & 7) == 0)\n+    e[0].etype = ETYPE_UNION;\n+  else\n+    e[0].etype = ETYPE_STRUCT;\n+  r >>= 3;\n+  e[0].len = len;\n+  if ((r & 31) == 0)\n+    {\n+      r >>= 5;\n+      if (features & FEATURE_ALIGNEDPACKED)\n+\tr %= NATTRIBS2;\n+      else\n+\tr %= NATTRIBS1;\n+      e[0].attrib = attributes[r];\n+    }\n+  generate_fields (features, &e[1], &e[0], len);\n+  output (e);\n+}\n+\n+struct { const char *name; enum FEATURE f; }\n+features[] = {\n+{ \"normal\", 0 },\n+{ \"complex\", FEATURE_COMPLEX },\n+{ \"vector\", FEATURE_VECTOR },\n+{ \"[0] :0\", FEATURE_ZEROARRAY | FEATURE_ZEROBITFLD },\n+{ \"complex vector [0]\",\n+  FEATURE_COMPLEX | FEATURE_VECTOR | FEATURE_ZEROARRAY },\n+{ \"aligned packed complex vector [0] :0\",\n+  FEATURE_COMPLEX | FEATURE_VECTOR | FEATURE_ZEROARRAY\n+  | FEATURE_ALIGNEDPACKED | FEATURE_ZEROBITFLD },\n+};\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i, j, count, c, n = 3000;\n+\n+  if (sizeof (int) != 4 || sizeof (long long) != 8)\n+    return 1;\n+\n+  while ((c = getopt (argc, argv, \"d:i:n:s:\")) != -1)\n+    switch (c)\n+      {\n+      case 'n':\n+\tn = atoi (optarg);\n+\tbreak;\n+      case 'd':\n+\tdestdir = optarg;\n+\tbreak;\n+      case 's':\n+\tsrcdir = optarg;\n+\tbreak;\n+      case 'i':\n+\toutput_one = 1;\n+\tlimidx = atoi (optarg);\n+\tbreak;\n+      default:\n+\tgoto usage;\n+      }\n+\n+  if (output_one)\n+    {\n+      outfile = fopen (\"/dev/null\", \"w\");\n+      if (outfile == NULL)\n+        {\n+\t  fputs (\"could not open /dev/null\", stderr);\n+\t  return 1;\n+        }\n+      n = limidx + 1;\n+    }\n+\n+  if (destdir == NULL && !output_one)\n+    {\n+    usage:\n+      fprintf (stderr, \"Usage:\\n\\\n+%s [-s srcdir -d destdir] [-n count] [-i idx]\\n\\\n+Either -s srcdir -d destdir or -i idx must be used\\n\", argv[0]);\n+      return 1;\n+    }\n+\n+  if (srcdir == NULL && !output_one)\n+    goto usage;\n+\n+  hasht = htab_create (40000, e_hash, e_eq, NULL);\n+  for (i = 0; i < NTYPES2; ++i)\n+    if (base_types[i].bitfld)\n+      bitfld_types[n_bitfld_types++] = base_types[i];\n+  for (i = 0; i < NATYPES2; ++i)\n+    if (attrib_types[i].bitfld)\n+      aligned_bitfld_types[n_aligned_bitfld_types++] = attrib_types[i];\n+  for (i = 0; i < sizeof (features) / sizeof (features[0]); ++i)\n+    {\n+      int startidx = idx;\n+      if (! output_one)\n+\tlimidx = idx;\n+      if (!i)\n+        count = 200;\n+      else\n+        count = 20;\n+      for (j = 1; j <= 9; ++j)\n+        while (idx < startidx + j * count)\n+\t  generate_random_tests (features[i].f, j);\n+      while (idx < startidx + count * 10)\n+\tgenerate_random_tests (features[i].f, 10 + (generate_random () % 16));\n+    }\n+  for (i = 0; n > 3000 && i < sizeof (features) / sizeof (features[0]); ++i)\n+    {\n+      int startidx;\n+      startidx = idx;\n+      if (! output_one)\n+\tlimidx = idx;\n+      singles (features[i].f);\n+      if (!i)\n+\t{\n+\t  count = 1000;\n+\t  while (idx < startidx + 1000)\n+\t    generate_random_tests (features[i].f, 1);\n+\t}\n+      else\n+\t{\n+\t  startidx = idx;\n+\t  count = 100;\n+\t  while (idx < startidx + 100)\n+\t    generate_random_tests (features[i].f, 1);\n+\t}\n+      startidx = idx;\n+      for (j = 2; j <= 9; ++j)\n+\twhile (idx < startidx + (j - 1) * count)\n+\t  generate_random_tests (features[i].f, j);\n+      while (idx < startidx + count * 9)\n+        generate_random_tests (features[i].f, 10 + (generate_random () % 16));\n+    }\n+  if (! output_one)\n+    limidx = idx;\n+  while (idx < n)\n+    generate_random_tests (ALL_FEATURES, 1 + (generate_random () % 25));\n+  fclose (outfile);\n+  return 0;\n+}"}, {"sha": "0a2fb42c79247365adc30a094a2b64727b5a70fd", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_main.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_main.c?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,15 @@\n+#include \"struct-layout-1.h\"\n+\n+#define TX(n, type, attrs, fields, ops) extern void test##n (void);\n+#include \"struct-layout-1_test.h\"\n+#undef TX\n+\n+int main (void)\n+{\n+#define TX(n, type, attrs, fields, ops)   test##n ();\n+#include \"struct-layout-1_test.h\"\n+#undef TX\n+  if (fails)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "697d6b7c42919a1f938319c449d10bdddeb0e810", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_test.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_test.h?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1 @@\n+T(0,enum E2 a:31;,B(0,a,e2_m1,e2_0))"}, {"sha": "02c885c62aa805a74860add91aba569211b27703", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_x.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x.c?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-options \"-w\" } */\n+#include \"struct-layout-1_x1.h\"\n+#include \"struct-layout-1_test.h\"\n+#include \"struct-layout-1_x2.h\"\n+#include \"struct-layout-1_test.h\""}, {"sha": "a553e223a35cb23d88e6eec1ae7e3562d62e5471", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_x1.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x1.h?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,68 @@\n+#include \"struct-layout-1.h\"\n+\n+struct Info info;\n+int fails;\n+int intarray[256];\n+int fn0 (void) { return 0; }\n+int fn1 (void) { return 1; }\n+int fn2 (void) { return 2; }\n+int fn3 (void) { return 3; }\n+int fn4 (void) { return 4; }\n+int fn5 (void) { return 5; }\n+int fn6 (void) { return 6; }\n+int fn7 (void) { return 7; }\n+int fn8 (void) { return 8; }\n+int fn9 (void) { return 9; }\n+\n+/* This macro is intended for fields where their\n+   addresses/sizes/alignments and value passing should be checked.  */\n+#define F(n, x, v, w) \t\t\t\t\t\t\\\n+  info.flds[i] = &s##n.x;\t\t\t\t\t\\\n+  info.sizes[i] = sizeof (s##n.x);\t\t\t\t\\\n+  info.aligns[i] = __alignof__ (s##n.x);\t\t\t\\\n+  s##n.x = v;\t\t\t\t\t\t\t\\\n+  a##n[2].x = w;\t\t\t\t\t\t\\\n+  ++i;\n+/* This macro is for fields where just their addresses/sizes/alignments\n+   should be checked.  */\n+#define N(n, x) \t\t\t\t\t\t\\\n+  info.flds[i] = &s##n.x;\t\t\t\t\t\\\n+  info.sizes[i] = sizeof (s##n.x);\t\t\t\t\\\n+  info.aligns[i] = __alignof__ (s##n.x);\t\t\t\\\n+  ++i;\n+/* This macro is for fields where just value passing should be checked.  */\n+#define B(n, x, v, w)\t\t\t\t\t\t\\\n+  s##n.x = v;\t\t\t\t\t\t\t\\\n+  a##n[2].x = w;\t\t\t\t\t\t\\\n+  ++j;\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+type S##n { fields } attrs;\t\t\t\t\t\\\n+type S##n s##n;\t\t\t\t\t\t\t\\\n+extern type S##n a##n[5];\t\t\t\t\t\\\n+extern type S##n check##n (type S##n, type S##n *,\t\t\\\n+\t\t\t     type S##n);\t\t\t\\\n+extern void check##n##va (int i, ...);\t\t\t\t\\\n+extern void checkx##n (type S##n);\t\t\t\t\\\n+void test##n (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  int i, j;\t\t\t\t\t\t\t\\\n+  memset (&s##n, '\\0', sizeof (s##n));\t\t\t\t\\\n+  memset (a##n, '\\0', sizeof (a##n));\t\t\t\t\\\n+  memset (&info, '\\0', sizeof (info));\t\t\t\t\\\n+  info.sp = &s##n;\t\t\t\t\t\t\\\n+  info.a0p = &a##n[0];\t\t\t\t\t\t\\\n+  info.a3p = &a##n[3];\t\t\t\t\t\t\\\n+  info.sz = sizeof (s##n);\t\t\t\t\t\\\n+  info.als = __alignof__ (s##n);\t\t\t\t\\\n+  info.ala0 = __alignof__ (a##n[0]);\t\t\t\t\\\n+  info.ala3 = __alignof__ (a##n[3]);\t\t\t\t\\\n+  if (((uintptr_t) &a##n[3]) & (info.als - 1))\t\t\t\\\n+    FAIL (n, 1);\t\t\t\t\t\t\\\n+  i = 0; j = 0;\t\t\t\t\t\t\t\\\n+  ops\t\t\t\t\t\t\t\t\\\n+  info.nfields = i;\t\t\t\t\t\t\\\n+  info.nbitfields = j;\t\t\t\t\t\t\\\n+  checkx##n (check##n (s##n, &a##n[1], a##n[2]));\t\t\\\n+  check##n##va (1, 1.0, s##n, 2LL, a##n[2], a##n[2]);\t\t\\\n+  check##n##va (2, s##n, s##n, 2.0L, a##n[2], s##n);\t\t\\\n+}"}, {"sha": "907a2c9595583c8e95df052964c1cf2197c9b34f", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_x2.h", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_x2.h?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,14 @@\n+#undef F\n+#undef N\n+#undef B\n+#undef TX\n+#define F(n, x, v, w) \t\t\t\t\t\t\\\n+  if (arg.x != s##n.x) FAIL (n, 30);\n+#define N(n, x)\n+#define B(n, x, v, w)\t\t\t\t\t\t\\\n+  if (arg.x != s##n.x) FAIL (n, 30);\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+void checkx##n (type S##n arg)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  ops\t\t\t\t\t\t\t\t\\\n+}"}, {"sha": "ed95f5a50190d0a652d10072df6b8a2184760231", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_y.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y.c?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-options \"-w\" } */\n+#include \"struct-layout-1_y1.h\"\n+#include \"struct-layout-1_test.h\"\n+#include \"struct-layout-1_y2.h\"\n+#include \"struct-layout-1_test.h\""}, {"sha": "9a5d2468a6ae78351505f97c1875c9839ff84430", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_y1.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y1.h?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,76 @@\n+#include \"struct-layout-1.h\"\n+\n+#define F(n, x, v, w) \t\t\t\t\t\t\\\n+  if (info.flds[i] != &s##n.x)\t\t\t\t\t\\\n+    FAIL (n, 50);\t\t\t\t\t\t\\\n+  if (info.sizes[i] != sizeof (s##n.x))\t\t\t\t\\\n+    FAIL (n, 51);\t\t\t\t\t\t\\\n+  if (info.aligns[i] != __alignof__ (s##n.x))\t\t\t\\\n+    FAIL (n, 52);\t\t\t\t\t\t\\\n+  if (s##n.x != (__typeof__ (s##n.x)) v)\t\t\t\\\n+    FAIL (n, 53);\t\t\t\t\t\t\\\n+  if (a##n[2].x != (__typeof__ (s##n.x)) w)\t\t\t\\\n+    FAIL (n, 54);\t\t\t\t\t\t\\\n+  if (arg0.x != s##n.x)\t\t\t\t\t\t\\\n+    FAIL (n, 55);\t\t\t\t\t\t\\\n+  if (arg2.x != a##n[2].x)\t\t\t\t\t\\\n+    FAIL (n, 56);\t\t\t\t\t\t\\\n+  ret.x = s##n.x;\t\t\t\t\t\t\\\n+  ++i;\n+#define N(n, x) \t\t\t\t\t\t\\\n+  if (info.flds[i] != &s##n.x)\t\t\t\t\t\\\n+    FAIL (n, 50);\t\t\t\t\t\t\\\n+  if (info.sizes[i] != sizeof (s##n.x))\t\t\t\t\\\n+    FAIL (n, 51);\t\t\t\t\t\t\\\n+  if (info.aligns[i] != __alignof__ (s##n.x))\t\t\t\\\n+    FAIL (n, 52);\t\t\t\t\t\t\\\n+  ++i;\n+#define B(n, x, v, w) \t\t\t\t\t\t\\\n+  b1.x = v; b2.x = w;\t\t\t\t\t\t\\\n+  if (s##n.x != b1.x)\t\t\t\t\t\t\\\n+    FAIL (n, 53);\t\t\t\t\t\t\\\n+  if (a##n[2].x != b2.x)\t\t\t\t\t\\\n+    FAIL (n, 54);\t\t\t\t\t\t\\\n+  if (arg0.x != s##n.x)\t\t\t\t\t\t\\\n+    FAIL (n, 55);\t\t\t\t\t\t\\\n+  if (arg2.x != a##n[2].x)\t\t\t\t\t\\\n+    FAIL (n, 56);\t\t\t\t\t\t\\\n+  ret.x = s##n.x;\t\t\t\t\t\t\\\n+  ++j;\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+type S##n { fields } attrs;\t\t\t\t\t\\\n+extern type S##n s##n;\t\t\t\t\t\t\\\n+type S##n a##n[5];\t\t\t\t\t\t\\\n+type S##n\t\t\t\t\t\t\t\\\n+check##n (type S##n arg0, type S##n *arg1, type S##n arg2)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  type S##n ret;\t\t\t\t\t\t\\\n+  type S##n b1, b2;\t\t\t\t\t\t\\\n+  int i, j;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  memset (&ret, 0, sizeof (ret));\t\t\t\t\\\n+  memset (&b1, 0, sizeof (b1));\t\t\t\t\t\\\n+  memset (&b2, 0, sizeof (b2));\t\t\t\t\t\\\n+  if (info.sp != &s##n)\t\t\t\t\t\t\\\n+    FAIL (n, 10);\t\t\t\t\t\t\\\n+  if (info.a0p != &a##n[0])\t\t\t\t\t\\\n+    FAIL (n, 11);\t\t\t\t\t\t\\\n+  if (info.a3p != &a##n[3])\t\t\t\t\t\\\n+    FAIL (n, 12);\t\t\t\t\t\t\\\n+  if (info.sz != sizeof (s##n))\t\t\t\t\t\\\n+    FAIL (n, 13);\t\t\t\t\t\t\\\n+  if (info.als != __alignof__ (s##n))\t\t\t\t\\\n+    FAIL (n, 14);\t\t\t\t\t\t\\\n+  if (info.ala0 != __alignof__ (a##n[0]))\t\t\t\\\n+    FAIL (n, 15);\t\t\t\t\t\t\\\n+  if (info.ala3 != __alignof__ (a##n[3]))\t\t\t\\\n+    FAIL (n, 16);\t\t\t\t\t\t\\\n+  if (arg1 != &a##n[1])\t\t\t\t\t\t\\\n+    FAIL (n, 17);\t\t\t\t\t\t\\\n+  i = 0; j = 0;\t\t\t\t\t\t\t\\\n+  ops\t\t\t\t\t\t\t\t\\\n+  if (i != info.nfields || j != info.nbitfields)\t\t\\\n+    FAIL (n, 18);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  return ret;\t\t\t\t\t\t\t\\\n+}"}, {"sha": "02a341e1ccf2436055adde289c1bc945dc7e170a", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_y2.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_y2.h?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -0,0 +1,69 @@\n+#undef F\n+#undef N\n+#undef B\n+#undef TX\n+\n+#ifdef SKIP_VA\n+const int test_va = 0;\n+#else\n+const int test_va = 1;\n+#endif\n+\n+#define F(n, x, v, w) \t\t\t\t\t\t\\\n+  if (p->x != arg.x) FAIL (n, 74);\n+#define N(n, x)\n+#define B(n, x, v, w) \t\t\t\t\t\t\\\n+  if (p->x != arg.x) FAIL (n, 74);\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+check##n##va (int z, ...)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  type S##n arg, *p;\t\t\t\t\t\t\\\n+  va_list ap;\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  if (test_va)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      va_start (ap, z);\t\t\t\t\t\t\\\n+      for (i = 0; i < 5; ++i)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  p = NULL;\t\t\t\t\t\t\\\n+\t  switch ((z << 4) | i)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t    case 0x10:\t\t\t\t\t\t\\\n+\t      if (va_arg (ap, double) != 1.0)\t\t\t\\\n+\t\tFAIL (n, 70);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    case 0x12:\t\t\t\t\t\t\\\n+\t      if (va_arg (ap, long long) != 2LL)\t\t\\\n+\t\tFAIL (n, 71);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    case 0x22:\t\t\t\t\t\t\\\n+\t      if (va_arg (ap, long double) != 2.0L)\t\t\\\n+\t\tFAIL (n, 72);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    case 0x11:\t\t\t\t\t\t\\\n+\t    case 0x20:\t\t\t\t\t\t\\\n+\t    case 0x21:\t\t\t\t\t\t\\\n+\t    case 0x24:\t\t\t\t\t\t\\\n+\t      p = &s##n;\t\t\t\t\t\\\n+\t      arg = va_arg (ap, type S##n);\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    case 0x13:\t\t\t\t\t\t\\\n+\t    case 0x14:\t\t\t\t\t\t\\\n+\t    case 0x23:\t\t\t\t\t\t\\\n+\t      p = &a##n[2];\t\t\t\t\t\\\n+\t      arg = va_arg (ap, type S##n);\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\t\\\n+\t      FAIL (n, 73);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  if (p)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      ops\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      va_end (ap);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}"}, {"sha": "9bf71d78d26c725a0f76ef8a1bdfec866c9009ec", "filename": "gcc/testsuite/lib/compat.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Flib%2Fcompat.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa33bdb4f75939b9467a4580aa13bb6997f192c/gcc%2Ftestsuite%2Flib%2Fcompat.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fcompat.exp?ref=5aa33bdb4f75939b9467a4580aa13bb6997f192c", "patch": "@@ -277,6 +277,7 @@ proc compat-execute { src1 sid use_alt } {\n \n     # Get the base name of this test, for use in messages.\n     regsub \"^$srcdir/?\" $src1 \"\" testcase\n+    regsub \"^$tmpdir/?\" $testcase \"tmpdir-\" testcase\n     regsub \"_main.*\" $testcase \"\" testcase\n     # Set up the base name of executable files so they'll be unique.\n     regsub -all \"\\[./\\]\" $testcase \"-\" execbase"}]}