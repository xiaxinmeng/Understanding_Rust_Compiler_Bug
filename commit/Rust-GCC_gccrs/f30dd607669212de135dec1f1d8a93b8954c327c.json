{"sha": "f30dd607669212de135dec1f1d8a93b8954c327c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMwZGQ2MDc2NjkyMTJkZTEzNWRlYzFmMWQ4YTkzYjg5NTRjMzI3Yw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2020-01-08T09:31:07Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2020-01-08T09:31:07Z"}, "message": "Implement 64-bit double functions.\n\ngcc/\n\tPR target/92055\n\t* config.gcc (tm_defines) [target=avr]: Support --with-libf7,\n\t--with-double-comparison.\n\t* doc/install.texi: Document them.\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins)\n\t<WITH_LIBF7_LIBGCC, WITH_LIBF7_MATH, WITH_LIBF7_MATH_SYMBOLS>\n\t<WITH_DOUBLE_COMPARISON>: New built-in defines.\n\t* doc/invoke.texi (AVR Built-in Macros): Document them.\n\t* config/avr/avr-protos.h (avr_float_lib_compare_returns_bool): New.\n\t* config/avr/avr.c (avr_float_lib_compare_returns_bool): New function.\n\t* config/avr/avr.h (FLOAT_LIB_COMPARE_RETURNS_BOOL): New macro.\nlibgcc/\n\tPR target/92055\n\t* config.host (tmake_file) [target=avr]: Add t-libf7,\n\tt-libf7-math, t-libf7-math-symbols as specified by --with-libf7=.\n\t* config/avr/t-avrlibc: Don't copy libgcc.a if there are modules\n\tdepending on sizeof (double) or sizeof (long double).\n\t* config/avr/libf7: New folder.\nlibgcc/config/avr/libf7/\n\tPR target/92055\n\t* t-libf7: New file.\n\t* t-libf7-math: New file.\n\t* t-libf7-math-symbols: New file.\n\t* libf7-common.mk: New file.\n\t* libf7-asm-object.mk: New file.\n\t* libf7-c-object.mk: New file.\n\t* asm-defs.h: New file.\n\t* libf7.h: New file.\n\t* libf7.c: New file.\n\t* libf7-asm.sx: New file.\n\t* libf7-array.def: New file.\n\t* libf7-const.def: New file.\n\t* libf7-constdef.h: New file.\n\t* f7renames.sh: New script.\n\t* f7wraps.sh: New script.\n\t* f7-renames.h: New generated file.\n\t* f7-wraps.h: New generated file.\n\nFrom-SVN: r279994", "tree": {"sha": "497248e433c158b74b956765c29800219a4f94e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/497248e433c158b74b956765c29800219a4f94e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f30dd607669212de135dec1f1d8a93b8954c327c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30dd607669212de135dec1f1d8a93b8954c327c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f30dd607669212de135dec1f1d8a93b8954c327c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30dd607669212de135dec1f1d8a93b8954c327c/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5bc18085c8b0344e7b53febc3cd3cc681a98ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5bc18085c8b0344e7b53febc3cd3cc681a98ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5bc18085c8b0344e7b53febc3cd3cc681a98ea3"}], "stats": {"total": 7151, "additions": 7141, "deletions": 10}, "files": [{"sha": "12bf61ffe252cd732543d576b84f02e57d797890", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -1,3 +1,19 @@\n+2020-01-08  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tImplement 64-bit double functions.\n+\n+\tPR target/92055\n+\t* config.gcc (tm_defines) [target=avr]: Support --with-libf7,\n+\t--with-double-comparison.\n+\t* doc/install.texi: Document them.\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins)\n+\t<WITH_LIBF7_LIBGCC, WITH_LIBF7_MATH, WITH_LIBF7_MATH_SYMBOLS>\n+\t<WITH_DOUBLE_COMPARISON>: New built-in defines.\n+\t* doc/invoke.texi (AVR Built-in Macros): Document them.\n+\t* config/avr/avr-protos.h (avr_float_lib_compare_returns_bool): New.\n+\t* config/avr/avr.c (avr_float_lib_compare_returns_bool): New function.\n+\t* config/avr/avr.h (FLOAT_LIB_COMPARE_RETURNS_BOOL): New macro.\n+\n 2020-01-08  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/93188"}, {"sha": "6c957c417b992f2e94b0dfc68ec826df6b8a32d3", "filename": "gcc/config.gcc", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -1336,8 +1336,48 @@ avr-*-*)\n \t    tm_file=\"${tm_file} ${cpu_type}/avrlibc.h\"\n \t    tm_defines=\"${tm_defines} WITH_AVRLIBC\"\n \tfi\n+\t# Work out avr_double_comparison which is 2 or 3 and is used in\n+\t# target hook FLOAT_LIB_COMPARE_RETURNS_BOOL to determine whether\n+\t# DFmode comparisons return 3-state or 2-state results.\n+\tcase y${with_double_comparison} in\n+\t    y | ytristate)\n+\t\tavr_double_comparison=3\n+\t\t;;\n+\t    ybool | ylibf7)\n+\t\tavr_double_comparison=2\n+\t\t;;\n+\t    *)\n+\t\techo \"Error: --with-double-comparison= can only be used with: 'tristate', 'bool', 'libf7'\" 1>&2\n+\t\texit 1\n+\t\t;;\n+\tesac\n+\tcase \"y${with_libf7}\" in\n+\t    yno)\n+\t\t# avr_double_comparison as set above.\n+\t\t;;\n+\t    ylibgcc)\n+\t\tavr_double_comparison=2\n+\t\ttm_defines=\"${tm_defines} WITH_LIBF7_LIBGCC\"\n+\t\t;;\n+\t    y | yyes | ymath-symbols)\n+\t\tavr_double_comparison=2\n+\t\ttm_defines=\"${tm_defines} WITH_LIBF7_LIBGCC\"\n+\t\ttm_defines=\"${tm_defines} WITH_LIBF7_MATH\"\n+\t\ttm_defines=\"${tm_defines} WITH_LIBF7_MATH_SYMBOLS\"\n+\t\t;;\n+\t    ymath)\n+\t\tavr_double_comparison=2\n+\t\ttm_defines=\"${tm_defines} WITH_LIBF7_LIBGCC\"\n+\t\ttm_defines=\"${tm_defines} WITH_LIBF7_MATH\"\n+\t\t;;\n+\t    *)\n+\t\techo \"Error: --with-libf7=${with_libf7} but can only be used with: 'libgcc', 'math', 'math-symbols', 'yes', 'no'\" 1>&2\n+\t\texit 1\n+\t\t;;\n+\tesac\n+\ttm_defines=\"${tm_defines} WITH_DOUBLE_COMPARISON=${avr_double_comparison}\"\n \tcase y${with_double} in\n-\t    y | y32)\n+\t    y32)\n \t\tavr_double=32\n \t\ttm_defines=\"${tm_defines} HAVE_DOUBLE32\"\n \t\t;;\n@@ -1352,7 +1392,7 @@ avr-*-*)\n \t\ttm_defines=\"${tm_defines} HAVE_DOUBLE64\"\n \t\ttm_defines=\"${tm_defines} HAVE_DOUBLE_MULTILIB\"\n \t\t;;\n-\t    y32,64)\n+\t    y | y32,64)\n \t\tavr_double=32\n \t\tavr_double_multilib=1\n \t\ttm_defines=\"${tm_defines} HAVE_DOUBLE32\"\n@@ -1365,15 +1405,15 @@ avr-*-*)\n \t\t;;\n \tesac\n \tcase y${with_long_double} in\n-\t    y | y32)\n+\t    y32)\n \t\tavr_long_double=32\n \t\ttm_defines=\"${tm_defines} HAVE_LONG_DOUBLE32\"\n \t\t;;\n \t    y64)\n \t\tavr_long_double=64\n \t\ttm_defines=\"${tm_defines} HAVE_LONG_DOUBLE64\"\n \t\t;;\n-\t    y64,32)\n+\t    y | y64,32)\n \t\tavr_long_double=64\n \t\tavr_long_double_multilib=1\n \t\ttm_defines=\"${tm_defines} HAVE_LONG_DOUBLE32\""}, {"sha": "35f3e7ea6ac1a61f45fd5762637aed68fd06215e", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -390,6 +390,20 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   cpp_define (pfile, \"__WITH_AVRLIBC__\");\n #endif /* WITH_AVRLIBC */\n \n+  // From configure --with-libf7={|libgcc|math|math-symbols|yes|no}\n+\n+#ifdef WITH_LIBF7_LIBGCC\n+  cpp_define (pfile, \"__WITH_LIBF7_LIBGCC__\");\n+#endif /* WITH_LIBF7_LIBGCC */\n+\n+#ifdef WITH_LIBF7_MATH\n+  cpp_define (pfile, \"__WITH_LIBF7_MATH__\");\n+#endif /* WITH_LIBF7_MATH */\n+\n+#ifdef WITH_LIBF7_MATH_SYMBOLS\n+  cpp_define (pfile, \"__WITH_LIBF7_MATH_SYMBOLS__\");\n+#endif /* WITH_LIBF7_MATH_SYMBOLS */\n+\n   // From configure --with-double={|32|32,64|64,32|64}\n \n #ifdef HAVE_DOUBLE_MULTILIB\n@@ -438,7 +452,23 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n #error \"align this with config.gcc\"\n #endif\n \n-  \n+  // From configure --with-double-comparison={2|3} --with-libf7.\n+\n+#if defined (WITH_DOUBLE_COMPARISON)\n+#if WITH_DOUBLE_COMPARISON == 2 || WITH_DOUBLE_COMPARISON == 3\n+  /* The number of states a DFmode comparison libcall might take and\n+     reflects what avr.c:FLOAT_LIB_COMPARE_RETURNS_BOOL returns for\n+     DFmode.  GCC's default is 3-state, but some libraries like LibF7\n+     implement true / false (2-state).  */\n+  cpp_define_formatted (pfile, \"__WITH_DOUBLE_COMPARISON__=%d\",\n+\t\t\tWITH_DOUBLE_COMPARISON);\n+#else\n+#error \"align this with config.gcc\"\n+#endif\n+#else\n+#error \"align this with config.gcc\"\n+#endif\n+\n   /* Define builtin macros so that the user can easily query whether\n      non-generic address spaces (and which) are supported or not.\n      This is only supported for C.  For C++, a language extension is needed"}, {"sha": "16c894ce3c346fb4d9503bfcbca5454184da793d", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -128,6 +128,8 @@ extern bool avr_xload_libgcc_p (machine_mode);\n extern rtx avr_eval_addr_attrib (rtx x);\n extern bool avr_casei_sequence_check_operands (rtx *xop);\n \n+extern bool avr_float_lib_compare_returns_bool (machine_mode, enum rtx_code);\n+\n static inline unsigned\n regmask (machine_mode mode, unsigned regno)\n {"}, {"sha": "61168edfdaee17193baad6499348557b253367a1", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -14575,6 +14575,23 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n   return NULL_TREE;\n }\n \n+\n+/* Worker function for `FLOAT_LIB_COMPARE_RETURNS_BOOL'.  */\n+\n+bool\n+avr_float_lib_compare_returns_bool (machine_mode mode, enum rtx_code)\n+{\n+  if (mode == DFmode)\n+    {\n+#if WITH_DOUBLE_COMPARISON == 2\n+      return true;\n+#endif\n+    }\n+\n+  // This is the GCC default and also what AVR-LibC implements.\n+  return false;\n+}\n+\n \f\n \n /* Initialize the GCC target structure.  */"}, {"sha": "c723b8aaeebaa997df922d188da61baee273b2e4", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -107,6 +107,9 @@ FIXME: DRIVER_SELF_SPECS has changed.\n #define BYTES_BIG_ENDIAN 0\n #define WORDS_BIG_ENDIAN 0\n \n+#define FLOAT_LIB_COMPARE_RETURNS_BOOL(mode, comparison) \\\n+  avr_float_lib_compare_returns_bool (mode, comparison)\n+\n #ifdef IN_LIBGCC2\n /* This is to get correct SI and DI modes in libgcc2.c (32 and 64 bits).  */\n #define UNITS_PER_WORD 4"}, {"sha": "9001217633784a3b1c479d34d4fbf5f30c3cb491", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -2309,9 +2309,10 @@ as a multilib option.\n If @option{--with-long-double=double} is specified, @samp{double} and\n @samp{long double} will have the same layout.\n @item\n-If the configure option is not set, it defaults to @samp{32} which\n-is compatible with older versions of the compiler that use non-standard\n-32-bit types for @samp{double} and @samp{long double}.\n+The defaults are @option{--with-long-double=64,32} and\n+@option{--with-double=32,64}.  The default @samp{double} layout imposed by\n+the latter is compatible with older versions of the compiler that implement\n+@samp{double} as a 32-bit type, which does not comply to the language standard.\n @end itemize\n Not all combinations of @option{--with-double=} and\n @option{--with-long-double=} are valid.  For example, the combination\n@@ -2321,6 +2322,28 @@ multilibs for @samp{double}, whereas the second option implies\n that @samp{long double} --- and hence also @samp{double} --- is always\n 32@tie{}bits wide.\n \n+@item --with-double-comparison=@{tristate|3|bool|2|libf7@}\n+Only supported for the AVR target since version@tie{}10.\n+Specify what result format is returned by library functions that\n+compare 64-bit floating point values (@code{DFmode}).\n+The GCC default is @samp{tristate}.  If the floating point\n+implementation returns a boolean instead, set it to @samp{bool}.\n+\n+@item --with-libf7=@{libgcc|math|math-symbols|no@}\n+Only supported for the AVR target since version@tie{}10.\n+Specify to which degree code from LibF7 is included in libgcc.\n+LibF7 is an ad-hoc, AVR-specific, 64-bit floating point emulation\n+written in C and (inline) assembly. @samp{libgcc} adds support\n+for functions that one would usually expect in libgcc like double addition,\n+double comparisons and double conversions. @samp{math} also adds routines\n+that one would expect in @file{libm.a}, but with @code{__} (two underscores)\n+prepended to the symbol names as specified by @file{math.h}.\n+@samp{math-symbols} also defines weak aliases for the functions\n+declared in @file{math.h}.  However, @code{--with-libf7} won't\n+install no @file{math.h} header file whatsoever, this file must come\n+from elsewhere.  This option sets @option{--with-double-comparison}\n+to @samp{bool}.\n+\n @item --with-nds32-lib=@var{library}\n Specifies that @var{library} setting is used for building @file{libgcc.a}.\n Currently, the valid @var{library} is @samp{newlib} or @samp{mculib}."}, {"sha": "ea0c42b29a38cced4be4a132a929a29b0df4a15a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -18421,9 +18421,9 @@ subroutines.  Code size is smaller.\n @opindex mdouble\n @opindex mlong-double\n Set the size (in bits) of the @code{double} or @code{long double} type,\n-respectively.  Possible values for @var{bits} are 32 an 64.\n+respectively.  Possible values for @var{bits} are 32 and 64.\n Whether or not a specific value for @var{bits} is allowed depends on\n-the @code{--with--double=} and @code{--with-long-double=}\n+the @code{--with-double=} and @code{--with-long-double=}\n @w{@uref{https://gcc.gnu.org/install/configure.html#avr,configure options}},\n and the same applies for the default values of the options.\n \n@@ -18886,6 +18886,36 @@ features like attribute @code{progmem} and @code{pgm_read_*}.\n The compiler is configured to be used together with AVR-Libc.\n See the @option{--with-avrlibc} configure option.\n \n+@item __HAVE_DOUBLE_MULTILIB__\n+Defined if @option{-mdouble=} acts as a multilib option.\n+\n+@item __HAVE_DOUBLE32__\n+@itemx __HAVE_DOUBLE64__\n+Defined if the compiler supports 32-bit double resp. 64-bit double.\n+The actual layout is specified by option @option{-mdouble=}.\n+\n+@item __DEFAULT_DOUBLE__\n+The size in bits of @code{double} if @option{-mdouble=} is not set.\n+To test the layout of @code{double} in a program, use the built-in\n+macro @code{__SIZEOF_DOUBLE__}.\n+\n+@item __HAVE_LONG_DOUBLE32__\n+@itemx __HAVE_LONG_DOUBLE64__\n+@itemx __HAVE_LONG_DOUBLE_MULTILIB__\n+@itemx __DEFAULT_LONG_DOUBLE__\n+Same as above, but for @code{long double} instead of @code{double}.\n+\n+@item __WITH_DOUBLE_COMPARISON__\n+Reflects the @code{--with-double-comparison=@{tristate|bool|libf7@}}\n+@w{@uref{https://gcc.gnu.org/install/configure.html#avr,configure option}}\n+and is defined to @code{2} or @code{3}.\n+\n+@item __WITH_LIBF7_LIBGCC__\n+@itemx __WITH_LIBF7_MATH__\n+@itemx __WITH_LIBF7_MATH_SYMBOLS__\n+Reflects the @code{--with-libf7=@{libgcc|math|math-symbols@}}\n+@w{@uref{https://gcc.gnu.org/install/configure.html#avr,configure option}}.\n+\n @end table\n \n @node Blackfin Options"}, {"sha": "08e96e5c051dea2d4b9fee5cb2a1915a99eb41f4", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -1,3 +1,14 @@\n+2020-01-08  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tImplement 64-bit double functions.\n+\n+\tPR target/92055\n+\t* config.host (tmake_file) [target=avr]: Add t-libf7,\n+\tt-libf7-math, t-libf7-math-symbols as specified by --with-libf7=.\n+\t* config/avr/t-avrlibc: Don't copy libgcc.a if there are modules\n+\tdepending on sizeof (double) or sizeof (long double).\n+\t* config/avr/libf7: New folder.\n+\n 2020-01-05  Olivier Hainque  <hainque@adacore.com>\n \n \t* config/gthr-vxworks.h: Guard #include vxAtomicLib.h"}, {"sha": "8f0ea90af579fb4ee3fbd29a3ac186fd4b05942c", "filename": "libgcc/config.host", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -514,6 +514,29 @@ arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-rtems*)\n avr-*-*)\n \t# Make HImode functions for AVR\n \ttmake_file=\"${cpu_type}/t-avr t-fpbit\"\n+\t# Make some DFmode functions from libf7, part of avr-libgcc.\n+\t# This must be prior to adding t-avrlibc.\n+\tcase \"y${with_libf7}\" in\n+\t    yno)\n+\t        # No libf7 support.\n+\t        ;;\n+\t    ylibgcc)\n+\t\ttmake_file=\"$tmake_file ${cpu_type}/libf7/t-libf7\"\n+\t\t;;\n+\t    ymath)\n+\t\ttmake_file=\"$tmake_file ${cpu_type}/libf7/t-libf7-math\"\n+\t\ttmake_file=\"$tmake_file ${cpu_type}/libf7/t-libf7\"\n+\t\t;;\n+\t    ymath-symbols | yyes | y)\n+\t\ttmake_file=\"$tmake_file ${cpu_type}/libf7/t-libf7-math-symbols\"\n+\t\ttmake_file=\"$tmake_file ${cpu_type}/libf7/t-libf7-math\"\n+\t\ttmake_file=\"$tmake_file ${cpu_type}/libf7/t-libf7\"\n+\t\t;;\n+\t    *)\n+\t\techo \"Error: --with-libf7=${with_libf7} but can only be used with: 'libgcc', 'math', 'math-symbols', 'yes', 'no'\" 1>&2\n+\t\texit 1\n+\t\t;;\n+\tesac\n \tif test x${with_avrlibc} != xno; then\n \t    tmake_file=\"$tmake_file ${cpu_type}/t-avrlibc\"\n \tfi"}, {"sha": "1ec47357ebedbb4b5248595378cbad6785e6fd62", "filename": "libgcc/config/avr/libf7/ChangeLog", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2FChangeLog?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,22 @@\n+2020-01-08  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tImplement 64-bit double functions.\n+\n+\tPR target/92055\n+\t* t-libf7: New file.\n+\t* t-libf7-math: New file.\n+\t* t-libf7-math-symbols: New file.\n+\t* libf7-common.mk: New file.\n+\t* libf7-asm-object.mk: New file.\n+\t* libf7-c-object.mk: New file.\n+\t* asm-defs.h: New file.\n+\t* libf7.h: New file.\n+\t* libf7.c: New file.\n+\t* libf7-asm.sx: New file.\n+\t* libf7-array.def: New file.\n+\t* libf7-const.def: New file.\n+\t* libf7-constdef.h: New file.\n+\t* f7renames.sh: New script.\n+\t* f7wraps.sh: New script.\n+\t* f7-renames.h: New generated file.\n+\t* f7-wraps.h: New generated file."}, {"sha": "aea245a0dfd24b3980a98f94e62ff1b00896b987", "filename": "libgcc/config/avr/libf7/asm-defs.h", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Fasm-defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Fasm-defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Fasm-defs.h?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,237 @@\n+/* Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of LIBF7, which is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef ASM_DEFS_H\n+#define ASM_DEFS_H\n+\n+#ifdef __AVR__\n+#ifdef __ASSEMBLER__\n+/*****************************************************************/\n+/* Stuff for Assembler-only                                      */\n+/*****************************************************************/\n+\n+#if defined (__AVR_TINY__)\n+    #define __tmp_reg__  16\n+    #define __zero_reg__ 17\n+#else\n+    #define __tmp_reg__  0\n+    #define __zero_reg__ 1\n+#endif /* AVR_TINY */\n+\n+#define __SREG__ 0x3f\n+#define __SP_L__ 0x3d\n+#if defined (__AVR_HAVE_SPH__)\n+#define __SP_H__ 0x3e\n+#endif\n+\n+#if !defined ASM_DEFS_HAVE_DEFUN\n+.macro DEFUN name\n+    .global \\name\n+    .func \\name\n+    \\name:\n+.endm\n+\n+.macro ENDF name\n+    .size \\name, .-\\name\n+    .endfunc\n+.endm\n+\n+.macro LABEL name\n+    .global \\name\n+    \\name:\n+.endm\n+#endif /* HAVE_DEFUN */\n+\n+\n+#if defined (__AVR_HAVE_JMP_CALL__)\n+    #define XCALL call\n+    #define XJMP  jmp\n+#else\n+    #define XCALL rcall\n+    #define XJMP  rjmp\n+#endif\n+\n+#if defined (__AVR_HAVE_EIJMP_EICALL__)\n+    #define XICALL  eicall\n+    #define XIJMP   eijmp\n+    #define PC_SIZE 3\n+#else\n+    #define XICALL  icall\n+    #define XIJMP   ijmp\n+    #define PC_SIZE 2\n+#endif\n+\n+.macro skipnext\n+    cpse r16, r16\n+.endm\n+\n+/*\n+    Factor out support of MOVW.  Usage is like\n+\n+        wmov  30, 24\n+\n+    to move R25:R24 to R31:R30, i.e. plain register numbers\n+    are required and no register prefix 'R'.\n+*/\n+\n+#if defined (__AVR_HAVE_MOVW__)\n+#define wmov    movw\n+#else\n+    .macro  wmov dst src\n+    ..dst = \\dst\n+    ..src = \\src\n+    ..regno = 0\n+    .irp    reg,                                                \\\n+            r0,  r1,  r2,  r3,  r4,  r5,  r6,   r7,  r8,  r9,   \\\n+            r10, r11, r12, r13, r14, r15, r16, r17, r18, r19,   \\\n+            r20, r21, r22, r23, r24, r25, r26, r27, r28, r29,   \\\n+            r30, r31\n+        .ifc  \\reg,\\dst\n+            ..dst = ..regno\n+        .endif\n+        .ifc  \\reg,\\src\n+            ..src = ..regno\n+        .endif\n+        ..regno = ..regno + 1\n+    .endr\n+\n+    ..regno = 0\n+\n+    .irp    reg,                                                \\\n+            R0,  R1,  R2,  R3,  R4,  R5,  R6,   R7,  R8,  R9,   \\\n+            R10, R11, R12, R13, R14, R15, R16, R17, R18, R19,   \\\n+            R20, R21, R22, R23, R24, R25, R26, R27, R28, R29,   \\\n+            R30, R31\n+        .ifc  \\reg,\\dst\n+            ..dst = ..regno\n+        .endif\n+        .ifc  \\reg,\\src\n+            ..src = ..regno\n+        .endif\n+        ..regno = ..regno + 1\n+    .endr\n+\n+    ..regno = 0\n+\n+    .irp    reg,                        \\\n+            X, x, XL, xl, Xl, xL, x, x  \\\n+            Y, y, YL, yl, Yl, yL, y, y, \\\n+            Z, z, ZL, zl, Zl, zL, z, z\n+        .ifc  \\reg,\\dst\n+            ..dst = (..regno / 8) + 26\n+        .endif\n+        .ifc  \\reg,\\src\n+            ..src = (..regno / 8) + 26\n+        .endif\n+        ..regno = ..regno + 1\n+    .endr\n+\n+    mov     ..dst+0, ..src+0\n+    mov     ..dst+1, ..src+1\n+    .endm\n+#endif /* MOVW */\n+\n+\n+#if !defined (__AVR_TINY__)\n+/*\n+    Convenience macro for easy use of __prologue_saves__ from libgcc.\n+    Push the N_PUSHED callee-saved registers  Y, R17, R16, R15, ...\n+    with 0 <= N_PUSHED <= 18.  The frame pointer (Y) is set up according\n+    to a frame size of N_FRAME.  Clobbers TMP_REG.\n+    For the code of __prologue_saves__ from libgcc see\n+    http://gcc.gnu.org/viewcvs/gcc/trunk/libgcc/config/avr/lib1funcs.S?revision=267494&view=markup#l2159\n+*/\n+\n+.macro do_prologue_saves n_pushed n_frame=0\n+    ldi r26, lo8(\\n_frame)\n+    ldi r27, hi8(\\n_frame)\n+    ldi r30, lo8(gs(.L_prologue_saves.\\@))\n+    ldi r31, hi8(gs(.L_prologue_saves.\\@))\n+    XJMP __prologue_saves__ + ((18 - (\\n_pushed)) * 2)\n+.L_prologue_saves.\\@:\n+.endm\n+\n+/*\n+    Convenience macro for easy use of __epilogue_restores__ from libgcc.\n+    Undo the effect of __prologue_saves__.  Clobbers TMP_REG.\n+    For the code of __epilogue_restores__ from libgcc see\n+    http://gcc.gnu.org/viewcvs/gcc/trunk/libgcc/config/avr/lib1funcs.S?revision=267494&view=markup#l2216\n+*/\n+\n+.macro do_epilogue_restores n_pushed n_frame=0\n+    in      r28, __SP_L__\n+#ifdef __AVR_HAVE_SPH__\n+    in      r29, __SP_H__\n+.if \\n_frame > 63\n+    subi    r28, lo8(-\\n_frame)\n+    sbci    r29, hi8(-\\n_frame)\n+.elseif \\n_frame > 0\n+    adiw    r28, \\n_frame\n+.endif\n+#else\n+    clr     r29\n+.if \\n_frame > 0\n+    subi    r28, lo8(-\\n_frame)\n+.endif\n+#endif /* HAVE SPH */\n+    ldi     r30, \\n_pushed\n+    XJMP __epilogue_restores__ + ((18 - (\\n_pushed)) * 2)\n+.endm\n+\n+#endif /* AVR_TINY */\n+\n+#else /* Assembler */\n+/*****************************************************************/\n+/* Space for C/C++ only Stuff                                    */\n+/*****************************************************************/\n+#endif /* Assembler */\n+\n+/*****************************************************************/\n+/* Space for Generic Stuff (Assembler, C, C++)                   */\n+/*****************************************************************/\n+\n+#ifdef __AVR_PM_BASE_ADDRESS__\n+    /*\n+        Devices with a linear address space:  Flash memory is seen in the\n+        RAM address space at an offset of __AVR_PM_BASE_ADDRESS__ and can\n+        be accessed by LD*.  This is the case for devices like ATtiny40\n+        (avrtiny) or ATtiny1616 and ATmega4808 (avrxmega3).  The default\n+        linker script locates .rodata in the .text output section and\n+        at the required offset.\n+    */\n+    #define RODATA_SECTION  .rodata.asm\n+    #define USE_LD  1\n+    #define USE_LPM 0\n+#else /* PM_BASE_ADDRESS */\n+    /*\n+        No linear address space.  As .rodata is located in RAM, we have to\n+        use .progmem.data (located in flash) and LPM to read the data.\n+        This will also work for devices from avrxmega3.\n+    */\n+    #define RODATA_SECTION  .progmem.data.asm\n+    #define USE_LD  0\n+    #define USE_LPM 1\n+#endif /* PM_BASE_ADDRESS */\n+\n+#endif /* target AVR */\n+#endif /* ASM_DEFS_H */"}, {"sha": "e4c0c0d8fc0049cee571b2333992360bae702fe9", "filename": "libgcc/config/avr/libf7/f7-renames.h", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7-renames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7-renames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7-renames.h?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,234 @@\n+/*\n+   Auto-generated file, do not change by hand.\n+\n+   Generated by:    f7renames.sh.\n+   Generated using: F7_PREFIX = __f7_ from t-libf7.\n+                    F7F, F7F_cst, F7F_asm from libf7-common.mk.\n+   Included by:     libf7.h.\n+   Used by:         libf7.c, libf7.h, libf7-asm.sx, f7-wraps.h.\n+*/\n+\n+#ifndef F7_RENAMES_H\n+#define F7_RENAMES_H\n+\n+#define F7_(name)  __f7_##name\n+#define F7P        __f7_\n+ \n+/* Renames for libf7.c, libf7.h.  */\n+ \n+#define f7_fabs __f7_fabs\n+#define f7_neg __f7_neg\n+#define f7_add __f7_add\n+#define f7_sub __f7_sub\n+#define f7_addsub __f7_addsub\n+#define f7_div __f7_div\n+#define f7_div1 __f7_div1\n+#define f7_divx __f7_divx\n+#define f7_fmod __f7_fmod\n+#define f7_sqrt __f7_sqrt\n+#define f7_cbrt __f7_cbrt\n+#define f7_square __f7_square\n+#define f7_mul __f7_mul\n+#define f7_mulx __f7_mulx\n+#define f7_madd_msub __f7_madd_msub\n+#define f7_madd __f7_madd\n+#define f7_msub __f7_msub\n+#define f7_hypot __f7_hypot\n+#define f7_Ineg __f7_Ineg\n+#define f7_Iadd __f7_Iadd\n+#define f7_Isub __f7_Isub\n+#define f7_Imul __f7_Imul\n+#define f7_Idiv __f7_Idiv\n+#define f7_IRsub __f7_IRsub\n+#define f7_Isquare __f7_Isquare\n+#define f7_Ildexp __f7_Ildexp\n+#define f7_Isqrt __f7_Isqrt\n+#define f7_le __f7_le\n+#define f7_lt __f7_lt\n+#define f7_gt __f7_gt\n+#define f7_ge __f7_ge\n+#define f7_ne __f7_ne\n+#define f7_eq __f7_eq\n+#define f7_cmp __f7_cmp\n+#define f7_cmp_abs __f7_cmp_abs\n+#define f7_ordered __f7_ordered\n+#define f7_unordered __f7_unordered\n+#define f7_cmp_unordered __f7_cmp_unordered\n+#define f7_lt_impl __f7_lt_impl\n+#define f7_gt_impl __f7_gt_impl\n+#define f7_le_impl __f7_le_impl\n+#define f7_ge_impl __f7_ge_impl\n+#define f7_eq_impl __f7_eq_impl\n+#define f7_ne_impl __f7_ne_impl\n+#define f7_unord_impl __f7_unord_impl\n+#define f7_lrint __f7_lrint\n+#define f7_ldexp __f7_ldexp\n+#define f7_frexp __f7_frexp\n+#define f7_exp __f7_exp\n+#define f7_logx __f7_logx\n+#define f7_log __f7_log\n+#define f7_log10 __f7_log10\n+#define f7_log2 __f7_log2\n+#define f7_minmax __f7_minmax\n+#define f7_fmax __f7_fmax\n+#define f7_fmin __f7_fmin\n+#define f7_floor __f7_floor\n+#define f7_ceil __f7_ceil\n+#define f7_round __f7_round\n+#define f7_lround __f7_lround\n+#define f7_trunc __f7_trunc\n+#define f7_truncx __f7_truncx\n+#define f7_horner __f7_horner\n+#define f7_pow10 __f7_pow10\n+#define f7_exp10 __f7_exp10\n+#define f7_pow __f7_pow\n+#define f7_powi __f7_powi\n+#define f7_sin __f7_sin\n+#define f7_cos __f7_cos\n+#define f7_tan __f7_tan\n+#define f7_cotan __f7_cotan\n+#define f7_sincos __f7_sincos\n+#define f7_sinh __f7_sinh\n+#define f7_cosh __f7_cosh\n+#define f7_tanh __f7_tanh\n+#define f7_sinhcosh __f7_sinhcosh\n+#define f7_asinacos __f7_asinacos\n+#define f7_asin __f7_asin\n+#define f7_acos __f7_acos\n+#define f7_atan __f7_atan\n+#define f7_atan2 __f7_atan2\n+#define f7_mul_noround __f7_mul_noround\n+#define f7_sqrt16_round __f7_sqrt16_round\n+#define f7_sqrt16_floor __f7_sqrt16_floor\n+#define f7_clr_mant_lsbs __f7_clr_mant_lsbs\n+#define f7_abscmp_msb_ge __f7_abscmp_msb_ge\n+#define f7_lshrdi3 __f7_lshrdi3\n+#define f7_ashldi3 __f7_ashldi3\n+#define f7_assert __f7_assert\n+#define f7_classify __f7_classify\n+#define f7_class_inf __f7_class_inf\n+#define f7_class_nan __f7_class_nan\n+#define f7_class_number __f7_class_number\n+#define f7_class_zero __f7_class_zero\n+#define f7_class_nonzero __f7_class_nonzero\n+#define f7_class_sign __f7_class_sign\n+#define f7_signbit __f7_signbit\n+#define f7_set_sign __f7_set_sign\n+#define f7_set_nan __f7_set_nan\n+#define f7_set_inf __f7_set_inf\n+#define f7_is_inf __f7_is_inf\n+#define f7_is_nan __f7_is_nan\n+#define f7_is_number __f7_is_number\n+#define f7_is_zero __f7_is_zero\n+#define f7_is_nonzero __f7_is_nonzero\n+#define f7_clr __f7_clr\n+#define f7_copy __f7_copy\n+#define f7_copy_P __f7_copy_P\n+#define f7_copy_mant __f7_copy_mant\n+#define f7_msbit __f7_msbit\n+#define f7_is0 __f7_is0\n+#define f7_cmp_mant __f7_cmp_mant\n+#define f7_store_expo __f7_store_expo\n+#define f7_abs __f7_abs\n+#define f7_set_s64 __f7_set_s64\n+#define f7_set_s32 __f7_set_s32\n+#define f7_set_s16 __f7_set_s16\n+#define f7_set_s16_impl __f7_set_s16_impl\n+#define f7_set_u16_worker __f7_set_u16_worker\n+#define f7_set_u64 __f7_set_u64\n+#define f7_set_u32 __f7_set_u32\n+#define f7_set_u16 __f7_set_u16\n+#define f7_set_u16_impl __f7_set_u16_impl\n+#define f7_set_float __f7_set_float\n+#define f7_set_pdouble __f7_set_pdouble\n+#define f7_set_double_impl __f7_set_double_impl\n+#define f7_set_double __f7_set_double\n+#define f7_init_impl __f7_init_impl\n+#define f7_init __f7_init\n+#define f7_get_s16 __f7_get_s16\n+#define f7_get_s32 __f7_get_s32\n+#define f7_get_s64 __f7_get_s64\n+#define f7_get_float __f7_get_float\n+#define f7_get_u16 __f7_get_u16\n+#define f7_get_u32 __f7_get_u32\n+#define f7_get_u64 __f7_get_u64\n+#define f7_get_double __f7_get_double\n+#define f7_set_eps __f7_set_eps\n+#define f7_set_1pow2 __f7_set_1pow2\n+#define f7_min __f7_min\n+#define f7_max __f7_max\n+#define f7_exp10 __f7_exp10\n+#define f7_floatunsidf __f7_floatunsidf\n+#define f7_floatsidf __f7_floatsidf\n+#define f7_extendsfdf2 __f7_extendsfdf2\n+#define f7_fixdfsi __f7_fixdfsi\n+#define f7_fixdfdi __f7_fixdfdi\n+#define f7_fixunsdfdi __f7_fixunsdfdi\n+#define f7_fixunsdfsi __f7_fixunsdfsi\n+#define f7_truncdfsf2 __f7_truncdfsf2\n+#define f7_le_impl __f7_le_impl\n+#define f7_lt_impl __f7_lt_impl\n+#define f7_gt_impl __f7_gt_impl\n+#define f7_ge_impl __f7_ge_impl\n+#define f7_ne_impl __f7_ne_impl\n+#define f7_eq_impl __f7_eq_impl\n+#define f7_unord_impl __f7_unord_impl\n+ \n+/* Renames for libf7.c, libf7.h.  */\n+ \n+#define f7_const_1   __f7_const_1\n+#define f7_const_1_P __f7_const_1_P\n+#define f7_const_2   __f7_const_2\n+#define f7_const_2_P __f7_const_2_P\n+#define f7_const_1_2   __f7_const_1_2\n+#define f7_const_1_2_P __f7_const_1_2_P\n+#define f7_const_1_3   __f7_const_1_3\n+#define f7_const_1_3_P __f7_const_1_3_P\n+#define f7_const_m1   __f7_const_m1\n+#define f7_const_m1_P __f7_const_m1_P\n+#define f7_const_pi   __f7_const_pi\n+#define f7_const_pi_P __f7_const_pi_P\n+#define f7_const_ln2   __f7_const_ln2\n+#define f7_const_ln2_P __f7_const_ln2_P\n+#define f7_const_ln10   __f7_const_ln10\n+#define f7_const_ln10_P __f7_const_ln10_P\n+#define f7_const_1_ln2   __f7_const_1_ln2\n+#define f7_const_1_ln2_P __f7_const_1_ln2_P\n+#define f7_const_1_ln10   __f7_const_1_ln10\n+#define f7_const_1_ln10_P __f7_const_1_ln10_P\n+#define f7_const_sqrt2   __f7_const_sqrt2\n+#define f7_const_sqrt2_P __f7_const_sqrt2_P\n+ \n+/* Renames for libf7-asm.sx, f7-wraps.h.  */\n+ \n+#define f7_classify_asm __f7_classify_asm\n+#define f7_store_expo_asm __f7_store_expo_asm\n+#define f7_clr_asm __f7_clr_asm\n+#define f7_copy_asm __f7_copy_asm\n+#define f7_copy_P_asm __f7_copy_P_asm\n+#define f7_copy_mant_asm __f7_copy_mant_asm\n+#define f7_cmp_mant_asm __f7_cmp_mant_asm\n+#define f7_normalize_asm __f7_normalize_asm\n+#define f7_store_expo_asm __f7_store_expo_asm\n+#define f7_set_u64_asm __f7_set_u64_asm\n+#define f7_set_s64_asm __f7_set_s64_asm\n+#define f7_addsub_mant_scaled_asm __f7_addsub_mant_scaled_asm\n+#define f7_mul_mant_asm __f7_mul_mant_asm\n+#define f7_to_integer_asm __f7_to_integer_asm\n+#define f7_to_unsigned_asm __f7_to_unsigned_asm\n+#define f7_clr_mant_lsbs_asm __f7_clr_mant_lsbs_asm\n+#define f7_div_asm __f7_div_asm\n+#define f7_sqrt_approx_asm __f7_sqrt_approx_asm\n+#define f7_sqrt16_round_asm __f7_sqrt16_round_asm\n+#define f7_sqrt16_floor_asm __f7_sqrt16_floor_asm\n+#define f7_lshrdi3_asm __f7_lshrdi3_asm\n+#define f7_ashldi3_asm __f7_ashldi3_asm\n+#define f7_class_D_asm __f7_class_D_asm\n+#define f7_call_ddd_asm __f7_call_ddd_asm\n+#define f7_call_xdd_asm __f7_call_xdd_asm\n+#define f7_call_ddx_asm __f7_call_ddx_asm\n+#define f7_call_dd_asm __f7_call_dd_asm\n+#define f7_call_xd_asm __f7_call_xd_asm\n+#define f7_call_dx_asm __f7_call_dx_asm\n+\n+#endif /* F7_RENAMES_H */"}, {"sha": "9de5267237f6619d4f953ca3ecb262258f997a3d", "filename": "libgcc/config/avr/libf7/f7-wraps.h", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7-wraps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7-wraps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7-wraps.h?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,638 @@\n+;; Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+;;\n+;; This file is part of LIBF7, which is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; Under Section 7 of GPL version 3, you are granted additional\n+;; permissions described in the GCC Runtime Library Exception, version\n+;; 3.1, as published by the Free Software Foundation.\n+;;\n+;; You should have received a copy of the GNU General Public License and\n+;; a copy of the GCC Runtime Library Exception along with this program;\n+;; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; Auto-generated file, do not change by hand.\n+;;\n+;; Wrappers for double and long double functions to use functions that\n+;; operate on f7_t, and get f7_t* and const f7_t*.\n+;;\n+;; Generated by: f7wraps.sh\n+;; Included by : libf7-asm.sx\n+;; WITH_LIBF7_MATH_FUNCTIONS=1\n+;; WITH_LIBF7_MATH_SYMBOLS=1\n+\n+;; Functions that usually live in libgcc: __<name>df3 for <name> in:\n+;; add sub mul div\n+\n+;; double __adddf3 (double, double)  ; add\n+#ifdef F7MOD_D_add_\n+_DEFUN __adddf3\n+    ALIAS __add\n+    .global F7_NAME(add)\n+    ldi     ZH,     hi8(gs(F7_NAME(add)))\n+    ldi     ZL,     lo8(gs(F7_NAME(add)))\n+    F7jmp   call_ddd\n+_ENDF __adddf3\n+#endif /* F7MOD_D_add_ */\n+\n+;; double __subdf3 (double, double)  ; sub\n+#ifdef F7MOD_D_sub_\n+_DEFUN __subdf3\n+    ALIAS __sub\n+    .global F7_NAME(sub)\n+    ldi     ZH,     hi8(gs(F7_NAME(sub)))\n+    ldi     ZL,     lo8(gs(F7_NAME(sub)))\n+    F7jmp   call_ddd\n+_ENDF __subdf3\n+#endif /* F7MOD_D_sub_ */\n+\n+;; double __muldf3 (double, double)  ; mul\n+#ifdef F7MOD_D_mul_\n+_DEFUN __muldf3\n+    ALIAS __mul\n+    .global F7_NAME(mul)\n+    ldi     ZH,     hi8(gs(F7_NAME(mul)))\n+    ldi     ZL,     lo8(gs(F7_NAME(mul)))\n+    F7jmp   call_ddd\n+_ENDF __muldf3\n+#endif /* F7MOD_D_mul_ */\n+\n+;; double __divdf3 (double, double)  ; div\n+#ifdef F7MOD_D_div_\n+_DEFUN __divdf3\n+    ALIAS __div\n+    .global F7_NAME(div)\n+    ldi     ZH,     hi8(gs(F7_NAME(div)))\n+    ldi     ZL,     lo8(gs(F7_NAME(div)))\n+    F7jmp   call_ddd\n+_ENDF __divdf3\n+#endif /* F7MOD_D_div_ */\n+\n+;; Functions that usually live in libgcc: __<name>df2 for <name> in:\n+;; le lt ge gt ne eq unord\n+\n+;; bool __ledf2 (double, double)  ; le\n+#ifdef F7MOD_D_le_\n+_DEFUN __ledf2\n+    .global F7_NAME(le_impl)\n+    ldi     ZH,     hi8(gs(F7_NAME(le_impl)))\n+    ldi     ZL,     lo8(gs(F7_NAME(le_impl)))\n+    F7jmp   call_xdd\n+_ENDF __ledf2\n+#endif /* F7MOD_D_le_ */\n+\n+;; bool __ltdf2 (double, double)  ; lt\n+#ifdef F7MOD_D_lt_\n+_DEFUN __ltdf2\n+    .global F7_NAME(lt_impl)\n+    ldi     ZH,     hi8(gs(F7_NAME(lt_impl)))\n+    ldi     ZL,     lo8(gs(F7_NAME(lt_impl)))\n+    F7jmp   call_xdd\n+_ENDF __ltdf2\n+#endif /* F7MOD_D_lt_ */\n+\n+;; bool __gedf2 (double, double)  ; ge\n+#ifdef F7MOD_D_ge_\n+_DEFUN __gedf2\n+    .global F7_NAME(ge_impl)\n+    ldi     ZH,     hi8(gs(F7_NAME(ge_impl)))\n+    ldi     ZL,     lo8(gs(F7_NAME(ge_impl)))\n+    F7jmp   call_xdd\n+_ENDF __gedf2\n+#endif /* F7MOD_D_ge_ */\n+\n+;; bool __gtdf2 (double, double)  ; gt\n+#ifdef F7MOD_D_gt_\n+_DEFUN __gtdf2\n+    .global F7_NAME(gt_impl)\n+    ldi     ZH,     hi8(gs(F7_NAME(gt_impl)))\n+    ldi     ZL,     lo8(gs(F7_NAME(gt_impl)))\n+    F7jmp   call_xdd\n+_ENDF __gtdf2\n+#endif /* F7MOD_D_gt_ */\n+\n+;; bool __nedf2 (double, double)  ; ne\n+#ifdef F7MOD_D_ne_\n+_DEFUN __nedf2\n+    .global F7_NAME(ne_impl)\n+    ldi     ZH,     hi8(gs(F7_NAME(ne_impl)))\n+    ldi     ZL,     lo8(gs(F7_NAME(ne_impl)))\n+    F7jmp   call_xdd\n+_ENDF __nedf2\n+#endif /* F7MOD_D_ne_ */\n+\n+;; bool __eqdf2 (double, double)  ; eq\n+#ifdef F7MOD_D_eq_\n+_DEFUN __eqdf2\n+    .global F7_NAME(eq_impl)\n+    ldi     ZH,     hi8(gs(F7_NAME(eq_impl)))\n+    ldi     ZL,     lo8(gs(F7_NAME(eq_impl)))\n+    F7jmp   call_xdd\n+_ENDF __eqdf2\n+#endif /* F7MOD_D_eq_ */\n+\n+;; bool __unorddf2 (double, double)  ; unord\n+#ifdef F7MOD_D_unord_\n+_DEFUN __unorddf2\n+    .global F7_NAME(unord_impl)\n+    ldi     ZH,     hi8(gs(F7_NAME(unord_impl)))\n+    ldi     ZL,     lo8(gs(F7_NAME(unord_impl)))\n+    F7jmp   call_xdd\n+_ENDF __unorddf2\n+#endif /* F7MOD_D_unord_ */\n+\n+;; Functions that usually live in libgcc: __<name> for <name> in:\n+;; fixdfsi fixdfdi fixunsdfdi fixunsdfsi truncdfsf2\n+\n+;; type_t __fixdfsi (double)  ; fixdfsi\n+#ifdef F7MOD_D_fixdfsi_\n+_DEFUN __fixdfsi\n+    .global F7_NAME(fixdfsi)\n+    ldi     ZH,     hi8(gs(F7_NAME(fixdfsi)))\n+    ldi     ZL,     lo8(gs(F7_NAME(fixdfsi)))\n+    F7jmp   call_xd\n+_ENDF __fixdfsi\n+#endif /* F7MOD_D_fixdfsi_ */\n+\n+;; type_t __fixdfdi (double)  ; fixdfdi\n+#ifdef F7MOD_D_fixdfdi_\n+_DEFUN __fixdfdi\n+    .global F7_NAME(fixdfdi)\n+    ldi     ZH,     hi8(gs(F7_NAME(fixdfdi)))\n+    ldi     ZL,     lo8(gs(F7_NAME(fixdfdi)))\n+    F7jmp   call_xd\n+_ENDF __fixdfdi\n+#endif /* F7MOD_D_fixdfdi_ */\n+\n+;; type_t __fixunsdfdi (double)  ; fixunsdfdi\n+#ifdef F7MOD_D_fixunsdfdi_\n+_DEFUN __fixunsdfdi\n+    .global F7_NAME(fixunsdfdi)\n+    ldi     ZH,     hi8(gs(F7_NAME(fixunsdfdi)))\n+    ldi     ZL,     lo8(gs(F7_NAME(fixunsdfdi)))\n+    F7jmp   call_xd\n+_ENDF __fixunsdfdi\n+#endif /* F7MOD_D_fixunsdfdi_ */\n+\n+;; type_t __fixunsdfsi (double)  ; fixunsdfsi\n+#ifdef F7MOD_D_fixunsdfsi_\n+_DEFUN __fixunsdfsi\n+    .global F7_NAME(fixunsdfsi)\n+    ldi     ZH,     hi8(gs(F7_NAME(fixunsdfsi)))\n+    ldi     ZL,     lo8(gs(F7_NAME(fixunsdfsi)))\n+    F7jmp   call_xd\n+_ENDF __fixunsdfsi\n+#endif /* F7MOD_D_fixunsdfsi_ */\n+\n+;; type_t __truncdfsf2 (double)  ; truncdfsf2\n+#ifdef F7MOD_D_truncdfsf2_\n+_DEFUN __truncdfsf2\n+    .global F7_NAME(truncdfsf2)\n+    ldi     ZH,     hi8(gs(F7_NAME(truncdfsf2)))\n+    ldi     ZL,     lo8(gs(F7_NAME(truncdfsf2)))\n+    F7jmp   call_xd\n+_ENDF __truncdfsf2\n+#endif /* F7MOD_D_truncdfsf2_ */\n+\n+;; Functions that usually live in libgcc: __<name> for <name> in:\n+;; floatunsidf floatsidf extendsfdf2\n+\n+;; double __floatunsidf (type_t)  ; floatunsidf\n+#ifdef F7MOD_D_floatunsidf_\n+_DEFUN __floatunsidf\n+    .global F7_NAME(floatunsidf)\n+    ldi     ZH,     hi8(gs(F7_NAME(floatunsidf)))\n+    ldi     ZL,     lo8(gs(F7_NAME(floatunsidf)))\n+    F7jmp   call_dx\n+_ENDF __floatunsidf\n+#endif /* F7MOD_D_floatunsidf_ */\n+\n+;; double __floatsidf (type_t)  ; floatsidf\n+#ifdef F7MOD_D_floatsidf_\n+_DEFUN __floatsidf\n+    .global F7_NAME(floatsidf)\n+    ldi     ZH,     hi8(gs(F7_NAME(floatsidf)))\n+    ldi     ZL,     lo8(gs(F7_NAME(floatsidf)))\n+    F7jmp   call_dx\n+_ENDF __floatsidf\n+#endif /* F7MOD_D_floatsidf_ */\n+\n+;; double __extendsfdf2 (type_t)  ; extendsfdf2\n+#ifdef F7MOD_D_extendsfdf2_\n+_DEFUN __extendsfdf2\n+    .global F7_NAME(extendsfdf2)\n+    ldi     ZH,     hi8(gs(F7_NAME(extendsfdf2)))\n+    ldi     ZL,     lo8(gs(F7_NAME(extendsfdf2)))\n+    F7jmp   call_dx\n+_ENDF __extendsfdf2\n+#endif /* F7MOD_D_extendsfdf2_ */\n+\n+;; Functions that usually live in libm:  Depending on [long] double layout,\n+;; define <name> and <name>l as weak alias(es) of __<name> for <name> in:\n+;; pow fmin fmax fmod hypot atan2\n+\n+;; double __pow (double, double)\n+#ifdef F7MOD_D_pow_\n+_DEFUN __pow\n+    DALIAS pow\n+    LALIAS powl\n+    .global F7_NAME(pow)\n+    ldi     ZH,     hi8(gs(F7_NAME(pow)))\n+    ldi     ZL,     lo8(gs(F7_NAME(pow)))\n+    F7jmp   call_ddd\n+_ENDF __pow\n+#endif /* F7MOD_D_pow_ */\n+\n+;; double __fmin (double, double)\n+#ifdef F7MOD_D_fmin_\n+_DEFUN __fmin\n+    DALIAS fmin\n+    LALIAS fminl\n+    .global F7_NAME(fmin)\n+    ldi     ZH,     hi8(gs(F7_NAME(fmin)))\n+    ldi     ZL,     lo8(gs(F7_NAME(fmin)))\n+    F7jmp   call_ddd\n+_ENDF __fmin\n+#endif /* F7MOD_D_fmin_ */\n+\n+;; double __fmax (double, double)\n+#ifdef F7MOD_D_fmax_\n+_DEFUN __fmax\n+    DALIAS fmax\n+    LALIAS fmaxl\n+    .global F7_NAME(fmax)\n+    ldi     ZH,     hi8(gs(F7_NAME(fmax)))\n+    ldi     ZL,     lo8(gs(F7_NAME(fmax)))\n+    F7jmp   call_ddd\n+_ENDF __fmax\n+#endif /* F7MOD_D_fmax_ */\n+\n+;; double __fmod (double, double)\n+#ifdef F7MOD_D_fmod_\n+_DEFUN __fmod\n+    DALIAS fmod\n+    LALIAS fmodl\n+    .global F7_NAME(fmod)\n+    ldi     ZH,     hi8(gs(F7_NAME(fmod)))\n+    ldi     ZL,     lo8(gs(F7_NAME(fmod)))\n+    F7jmp   call_ddd\n+_ENDF __fmod\n+#endif /* F7MOD_D_fmod_ */\n+\n+;; double __hypot (double, double)\n+#ifdef F7MOD_D_hypot_\n+_DEFUN __hypot\n+    DALIAS hypot\n+    LALIAS hypotl\n+    .global F7_NAME(hypot)\n+    ldi     ZH,     hi8(gs(F7_NAME(hypot)))\n+    ldi     ZL,     lo8(gs(F7_NAME(hypot)))\n+    F7jmp   call_ddd\n+_ENDF __hypot\n+#endif /* F7MOD_D_hypot_ */\n+\n+;; double __atan2 (double, double)\n+#ifdef F7MOD_D_atan2_\n+_DEFUN __atan2\n+    DALIAS atan2\n+    LALIAS atan2l\n+    .global F7_NAME(atan2)\n+    ldi     ZH,     hi8(gs(F7_NAME(atan2)))\n+    ldi     ZL,     lo8(gs(F7_NAME(atan2)))\n+    F7jmp   call_ddd\n+_ENDF __atan2\n+#endif /* F7MOD_D_atan2_ */\n+\n+;; Functions that usually live in libm:  Depending on [long] double layout,\n+;; define <name> and <name>l as weak alias(es) of __<name> for <name> in:\n+;; ldexp frexp\n+\n+;; double __ldexp (double, word_t)\n+#ifdef F7MOD_D_ldexp_\n+_DEFUN __ldexp\n+    DALIAS ldexp\n+    LALIAS ldexpl\n+    .global F7_NAME(ldexp)\n+    ldi     ZH,     hi8(gs(F7_NAME(ldexp)))\n+    ldi     ZL,     lo8(gs(F7_NAME(ldexp)))\n+    F7jmp   call_ddx\n+_ENDF __ldexp\n+#endif /* F7MOD_D_ldexp_ */\n+\n+;; double __frexp (double, word_t)\n+#ifdef F7MOD_D_frexp_\n+_DEFUN __frexp\n+    DALIAS frexp\n+    LALIAS frexpl\n+    .global F7_NAME(frexp)\n+    ldi     ZH,     hi8(gs(F7_NAME(frexp)))\n+    ldi     ZL,     lo8(gs(F7_NAME(frexp)))\n+    F7jmp   call_ddx\n+_ENDF __frexp\n+#endif /* F7MOD_D_frexp_ */\n+\n+;; Functions that usually live in libm:  Depending on [long] double layout,\n+;; define <name> and <name>l as weak alias(es) of __<name> for <name> in:\n+;; sqrt cbrt exp exp10 pow10 log log10 log2 sin cos tan cotan asin acos atan ceil floor trunc round sinh cosh tanh\n+\n+;; double __sqrt (double)\n+#ifdef F7MOD_D_sqrt_\n+_DEFUN __sqrt\n+    DALIAS sqrt\n+    LALIAS sqrtl\n+    .global F7_NAME(sqrt)\n+    ldi     ZH,     hi8(gs(F7_NAME(sqrt)))\n+    ldi     ZL,     lo8(gs(F7_NAME(sqrt)))\n+    F7jmp   call_dd\n+_ENDF __sqrt\n+#endif /* F7MOD_D_sqrt_ */\n+\n+;; double __cbrt (double)\n+#ifdef F7MOD_D_cbrt_\n+_DEFUN __cbrt\n+    DALIAS cbrt\n+    LALIAS cbrtl\n+    .global F7_NAME(cbrt)\n+    ldi     ZH,     hi8(gs(F7_NAME(cbrt)))\n+    ldi     ZL,     lo8(gs(F7_NAME(cbrt)))\n+    F7jmp   call_dd\n+_ENDF __cbrt\n+#endif /* F7MOD_D_cbrt_ */\n+\n+;; double __exp (double)\n+#ifdef F7MOD_D_exp_\n+_DEFUN __exp\n+    DALIAS exp\n+    LALIAS expl\n+    .global F7_NAME(exp)\n+    ldi     ZH,     hi8(gs(F7_NAME(exp)))\n+    ldi     ZL,     lo8(gs(F7_NAME(exp)))\n+    F7jmp   call_dd\n+_ENDF __exp\n+#endif /* F7MOD_D_exp_ */\n+\n+;; double __exp10 (double)\n+#ifdef F7MOD_D_exp10_\n+_DEFUN __exp10\n+    DALIAS exp10\n+    LALIAS exp10l\n+    .global F7_NAME(exp10)\n+    ldi     ZH,     hi8(gs(F7_NAME(exp10)))\n+    ldi     ZL,     lo8(gs(F7_NAME(exp10)))\n+    F7jmp   call_dd\n+_ENDF __exp10\n+#endif /* F7MOD_D_exp10_ */\n+\n+;; double __pow10 (double)\n+#ifdef F7MOD_D_pow10_\n+_DEFUN __pow10\n+    DALIAS pow10\n+    LALIAS pow10l\n+    .global F7_NAME(pow10)\n+    ldi     ZH,     hi8(gs(F7_NAME(pow10)))\n+    ldi     ZL,     lo8(gs(F7_NAME(pow10)))\n+    F7jmp   call_dd\n+_ENDF __pow10\n+#endif /* F7MOD_D_pow10_ */\n+\n+;; double __log (double)\n+#ifdef F7MOD_D_log_\n+_DEFUN __log\n+    DALIAS log\n+    LALIAS logl\n+    .global F7_NAME(log)\n+    ldi     ZH,     hi8(gs(F7_NAME(log)))\n+    ldi     ZL,     lo8(gs(F7_NAME(log)))\n+    F7jmp   call_dd\n+_ENDF __log\n+#endif /* F7MOD_D_log_ */\n+\n+;; double __log10 (double)\n+#ifdef F7MOD_D_log10_\n+_DEFUN __log10\n+    DALIAS log10\n+    LALIAS log10l\n+    .global F7_NAME(log10)\n+    ldi     ZH,     hi8(gs(F7_NAME(log10)))\n+    ldi     ZL,     lo8(gs(F7_NAME(log10)))\n+    F7jmp   call_dd\n+_ENDF __log10\n+#endif /* F7MOD_D_log10_ */\n+\n+;; double __log2 (double)\n+#ifdef F7MOD_D_log2_\n+_DEFUN __log2\n+    DALIAS log2\n+    LALIAS log2l\n+    .global F7_NAME(log2)\n+    ldi     ZH,     hi8(gs(F7_NAME(log2)))\n+    ldi     ZL,     lo8(gs(F7_NAME(log2)))\n+    F7jmp   call_dd\n+_ENDF __log2\n+#endif /* F7MOD_D_log2_ */\n+\n+;; double __sin (double)\n+#ifdef F7MOD_D_sin_\n+_DEFUN __sin\n+    DALIAS sin\n+    LALIAS sinl\n+    .global F7_NAME(sin)\n+    ldi     ZH,     hi8(gs(F7_NAME(sin)))\n+    ldi     ZL,     lo8(gs(F7_NAME(sin)))\n+    F7jmp   call_dd\n+_ENDF __sin\n+#endif /* F7MOD_D_sin_ */\n+\n+;; double __cos (double)\n+#ifdef F7MOD_D_cos_\n+_DEFUN __cos\n+    DALIAS cos\n+    LALIAS cosl\n+    .global F7_NAME(cos)\n+    ldi     ZH,     hi8(gs(F7_NAME(cos)))\n+    ldi     ZL,     lo8(gs(F7_NAME(cos)))\n+    F7jmp   call_dd\n+_ENDF __cos\n+#endif /* F7MOD_D_cos_ */\n+\n+;; double __tan (double)\n+#ifdef F7MOD_D_tan_\n+_DEFUN __tan\n+    DALIAS tan\n+    LALIAS tanl\n+    .global F7_NAME(tan)\n+    ldi     ZH,     hi8(gs(F7_NAME(tan)))\n+    ldi     ZL,     lo8(gs(F7_NAME(tan)))\n+    F7jmp   call_dd\n+_ENDF __tan\n+#endif /* F7MOD_D_tan_ */\n+\n+;; double __cotan (double)\n+#ifdef F7MOD_D_cotan_\n+_DEFUN __cotan\n+    DALIAS cotan\n+    LALIAS cotanl\n+    .global F7_NAME(cotan)\n+    ldi     ZH,     hi8(gs(F7_NAME(cotan)))\n+    ldi     ZL,     lo8(gs(F7_NAME(cotan)))\n+    F7jmp   call_dd\n+_ENDF __cotan\n+#endif /* F7MOD_D_cotan_ */\n+\n+;; double __asin (double)\n+#ifdef F7MOD_D_asin_\n+_DEFUN __asin\n+    DALIAS asin\n+    LALIAS asinl\n+    .global F7_NAME(asin)\n+    ldi     ZH,     hi8(gs(F7_NAME(asin)))\n+    ldi     ZL,     lo8(gs(F7_NAME(asin)))\n+    F7jmp   call_dd\n+_ENDF __asin\n+#endif /* F7MOD_D_asin_ */\n+\n+;; double __acos (double)\n+#ifdef F7MOD_D_acos_\n+_DEFUN __acos\n+    DALIAS acos\n+    LALIAS acosl\n+    .global F7_NAME(acos)\n+    ldi     ZH,     hi8(gs(F7_NAME(acos)))\n+    ldi     ZL,     lo8(gs(F7_NAME(acos)))\n+    F7jmp   call_dd\n+_ENDF __acos\n+#endif /* F7MOD_D_acos_ */\n+\n+;; double __atan (double)\n+#ifdef F7MOD_D_atan_\n+_DEFUN __atan\n+    DALIAS atan\n+    LALIAS atanl\n+    .global F7_NAME(atan)\n+    ldi     ZH,     hi8(gs(F7_NAME(atan)))\n+    ldi     ZL,     lo8(gs(F7_NAME(atan)))\n+    F7jmp   call_dd\n+_ENDF __atan\n+#endif /* F7MOD_D_atan_ */\n+\n+;; double __ceil (double)\n+#ifdef F7MOD_D_ceil_\n+_DEFUN __ceil\n+    DALIAS ceil\n+    LALIAS ceill\n+    .global F7_NAME(ceil)\n+    ldi     ZH,     hi8(gs(F7_NAME(ceil)))\n+    ldi     ZL,     lo8(gs(F7_NAME(ceil)))\n+    F7jmp   call_dd\n+_ENDF __ceil\n+#endif /* F7MOD_D_ceil_ */\n+\n+;; double __floor (double)\n+#ifdef F7MOD_D_floor_\n+_DEFUN __floor\n+    DALIAS floor\n+    LALIAS floorl\n+    .global F7_NAME(floor)\n+    ldi     ZH,     hi8(gs(F7_NAME(floor)))\n+    ldi     ZL,     lo8(gs(F7_NAME(floor)))\n+    F7jmp   call_dd\n+_ENDF __floor\n+#endif /* F7MOD_D_floor_ */\n+\n+;; double __trunc (double)\n+#ifdef F7MOD_D_trunc_\n+_DEFUN __trunc\n+    DALIAS trunc\n+    LALIAS truncl\n+    .global F7_NAME(trunc)\n+    ldi     ZH,     hi8(gs(F7_NAME(trunc)))\n+    ldi     ZL,     lo8(gs(F7_NAME(trunc)))\n+    F7jmp   call_dd\n+_ENDF __trunc\n+#endif /* F7MOD_D_trunc_ */\n+\n+;; double __round (double)\n+#ifdef F7MOD_D_round_\n+_DEFUN __round\n+    DALIAS round\n+    LALIAS roundl\n+    .global F7_NAME(round)\n+    ldi     ZH,     hi8(gs(F7_NAME(round)))\n+    ldi     ZL,     lo8(gs(F7_NAME(round)))\n+    F7jmp   call_dd\n+_ENDF __round\n+#endif /* F7MOD_D_round_ */\n+\n+;; double __sinh (double)\n+#ifdef F7MOD_D_sinh_\n+_DEFUN __sinh\n+    DALIAS sinh\n+    LALIAS sinhl\n+    .global F7_NAME(sinh)\n+    ldi     ZH,     hi8(gs(F7_NAME(sinh)))\n+    ldi     ZL,     lo8(gs(F7_NAME(sinh)))\n+    F7jmp   call_dd\n+_ENDF __sinh\n+#endif /* F7MOD_D_sinh_ */\n+\n+;; double __cosh (double)\n+#ifdef F7MOD_D_cosh_\n+_DEFUN __cosh\n+    DALIAS cosh\n+    LALIAS coshl\n+    .global F7_NAME(cosh)\n+    ldi     ZH,     hi8(gs(F7_NAME(cosh)))\n+    ldi     ZL,     lo8(gs(F7_NAME(cosh)))\n+    F7jmp   call_dd\n+_ENDF __cosh\n+#endif /* F7MOD_D_cosh_ */\n+\n+;; double __tanh (double)\n+#ifdef F7MOD_D_tanh_\n+_DEFUN __tanh\n+    DALIAS tanh\n+    LALIAS tanhl\n+    .global F7_NAME(tanh)\n+    ldi     ZH,     hi8(gs(F7_NAME(tanh)))\n+    ldi     ZL,     lo8(gs(F7_NAME(tanh)))\n+    F7jmp   call_dd\n+_ENDF __tanh\n+#endif /* F7MOD_D_tanh_ */\n+\n+;; Functions that usually live in libm:  Depending on [long] double layout,\n+;; define <name> and <name>l as weak alias(es) of __<name> for <name> in:\n+;; lrint lround\n+\n+;; type_t __lrint (double)\n+#ifdef F7MOD_D_lrint_\n+_DEFUN __lrint\n+    DALIAS lrint\n+    LALIAS lrintl\n+    .global F7_NAME(lrint)\n+    ldi     ZH,     hi8(gs(F7_NAME(lrint)))\n+    ldi     ZL,     lo8(gs(F7_NAME(lrint)))\n+    F7jmp   call_xd\n+_ENDF __lrint\n+#endif /* F7MOD_D_lrint_ */\n+\n+;; type_t __lround (double)\n+#ifdef F7MOD_D_lround_\n+_DEFUN __lround\n+    DALIAS lround\n+    LALIAS lroundl\n+    .global F7_NAME(lround)\n+    ldi     ZH,     hi8(gs(F7_NAME(lround)))\n+    ldi     ZL,     lo8(gs(F7_NAME(lround)))\n+    F7jmp   call_xd\n+_ENDF __lround\n+#endif /* F7MOD_D_lround_ */"}, {"sha": "7ef251e44c997284ed5d02d7233a5f1aadd5f715", "filename": "libgcc/config/avr/libf7/f7renames.sh", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7renames.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7renames.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7renames.sh?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,80 @@\n+#!/usr/bin/env sh\n+\n+# The first command argument tells us which flavour to generate for\n+# the rest of the command line arguments.\n+\n+what=$1\n+shift\n+\n+# The second command argument is the prefix to prepend to all functions.\n+# It is defined by F7_PREFIX in $2.\n+\n+PRE=$1\n+shift\n+\n+case ${what} in\n+    head)\n+        cat << EOF\n+/*\n+   Auto-generated file, do not change by hand.\n+\n+   Generated by:    `basename $0`.\n+   Generated using: F7_PREFIX = ${PRE} from $1.\n+\t\t    F7F, F7F_cst, F7F_asm from libf7-common.mk.\n+   Included by:\t    libf7.h.\n+   Used by: \t    libf7.c, libf7.h, libf7-asm.sx, f7-wraps.h.\n+*/\n+\n+#ifndef F7_RENAMES_H\n+#define F7_RENAMES_H\n+\n+#define F7_(name)  ${PRE}##name\n+#define F7P\t   ${PRE}\n+EOF\n+        ;;\n+\n+    c)\n+        if [ x${PRE} != xf7_ ]; then\n+            echo \" \"\n+            echo \"/* Renames for libf7.c, libf7.h.  */\"\n+            echo \" \"\n+            for x in $*; do\n+                echo \"#define f7_$x ${PRE}$x\"\n+            done\n+        fi\n+        ;;\n+\n+    cst)\n+        if [ x${PRE} != xf7_ ]; then\n+            echo \" \"\n+            echo \"/* Renames for libf7.c, libf7.h.  */\"\n+            echo \" \"\n+            for x in $*; do\n+                echo \"#define f7_const_${x}   ${PRE}const_${x}\"\n+                echo \"#define f7_const_${x}_P ${PRE}const_${x}_P\"\n+            done\n+        fi\n+        ;;\n+\n+    asm)\n+        if [ x${PRE} != xf7_ ]; then\n+            echo \" \"\n+            echo \"/* Renames for libf7-asm.sx, f7-wraps.h.  */\"\n+            echo \" \"\n+            for x in $*; do\n+                echo \"#define f7_${x}_asm ${PRE}${x}_asm\"\n+            done\n+        fi\n+        ;;\n+\n+    tail)\n+        cat << EOF\n+\n+#endif /* F7_RENAMES_H */\n+EOF\n+        ;;\n+\n+    *)\n+        exit 1\n+        ;;\n+esac"}, {"sha": "8536010f387e3361d65abbdea24edf92936f5392", "filename": "libgcc/config/avr/libf7/f7wraps.sh", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7wraps.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7wraps.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Ff7wraps.sh?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,244 @@\n+#!/usr/bin/env sh\n+\n+# The first command argument $1 tells us which flavour to generate for\n+# the rest of the command line arguments.\n+\n+what=$1\n+shift\n+\n+if [ \"x$*\" = \"x\" ]; then\n+    none=\"(none)\"\n+fi\n+\n+case ${what} in\n+    header)\n+            cat << EOF\n+;; Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+;;\n+;; This file is part of LIBF7, which is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; Under Section 7 of GPL version 3, you are granted additional\n+;; permissions described in the GCC Runtime Library Exception, version\n+;; 3.1, as published by the Free Software Foundation.\n+;;\n+;; You should have received a copy of the GNU General Public License and\n+;; a copy of the GCC Runtime Library Exception along with this program;\n+;; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; Auto-generated file, do not change by hand.\n+;;\n+;; Wrappers for double and long double functions to use functions that\n+;; operate on f7_t, and get f7_t* and const f7_t*.\n+;;\n+;; Generated by: `basename $0`\n+;; Included by : libf7-asm.sx\n+EOF\n+        for n in $*; do\n+            echo \";; $n\"\n+        done\n+        ;;\n+\n+    xd_libgcc)\n+        cat << EOF\n+\n+;; Functions that usually live in libgcc: __<name> for <name> in:\n+;; $*${none}\n+EOF\n+        for n in $*; do\n+            cat << EOF\n+\n+;; type_t __${n} (double)  ; $n\n+#ifdef F7MOD_D_${n}_\n+_DEFUN __${n}\n+    .global F7_NAME($n)\n+    ldi     ZH,     hi8(gs(F7_NAME($n)))\n+    ldi     ZL,     lo8(gs(F7_NAME($n)))\n+    F7jmp   call_xd\n+_ENDF __${n}\n+#endif /* F7MOD_D_${n}_ */\n+EOF\n+        done\n+        ;;\n+\n+    dx_libgcc)\n+        cat << EOF\n+\n+;; Functions that usually live in libgcc: __<name> for <name> in:\n+;; $*${none}\n+EOF\n+        for n in $*; do\n+            cat << EOF\n+\n+;; double __${n} (type_t)  ; $n\n+#ifdef F7MOD_D_${n}_\n+_DEFUN __${n}\n+    .global F7_NAME($n)\n+    ldi     ZH,     hi8(gs(F7_NAME($n)))\n+    ldi     ZL,     lo8(gs(F7_NAME($n)))\n+    F7jmp   call_dx\n+_ENDF __${n}\n+#endif /* F7MOD_D_${n}_ */\n+EOF\n+        done\n+        ;;\n+\n+    ddd_libgcc)\n+        cat << EOF\n+\n+;; Functions that usually live in libgcc: __<name>df3 for <name> in:\n+;; $*${none}\n+EOF\n+        for n in $*; do\n+            cat << EOF\n+\n+;; double __${n}df3 (double, double)  ; $n\n+#ifdef F7MOD_D_${n}_\n+_DEFUN __${n}df3\n+    ALIAS __$n\n+    .global F7_NAME($n)\n+    ldi     ZH,     hi8(gs(F7_NAME($n)))\n+    ldi     ZL,     lo8(gs(F7_NAME($n)))\n+    F7jmp   call_ddd\n+_ENDF __${n}df3\n+#endif /* F7MOD_D_${n}_ */\n+EOF\n+        done\n+        ;;\n+\n+    xdd_libgcc_cmp)\n+        cat << EOF\n+\n+;; Functions that usually live in libgcc: __<name>df2 for <name> in:\n+;; $*${none}\n+EOF\n+        for n in $*; do\n+            cat << EOF\n+\n+;; bool __${n}df2 (double, double)  ; $n\n+#ifdef F7MOD_D_${n}_\n+_DEFUN __${n}df2\n+    .global F7_NAME(${n}_impl)\n+    ldi     ZH,     hi8(gs(F7_NAME(${n}_impl)))\n+    ldi     ZL,     lo8(gs(F7_NAME(${n}_impl)))\n+    F7jmp   call_xdd\n+_ENDF __${n}df2\n+#endif /* F7MOD_D_${n}_ */\n+EOF\n+        done\n+        ;;\n+\n+    dd_math)\n+        cat << EOF\n+\n+;; Functions that usually live in libm:  Depending on [long] double layout,\n+;; define <name> and <name>l as weak alias(es) of __<name> for <name> in:\n+;; $*${none}\n+EOF\n+        for n in $*; do\n+            cat << EOF\n+\n+;; double __${n} (double)\n+#ifdef F7MOD_D_${n}_\n+_DEFUN __${n}\n+    DALIAS $n\n+    LALIAS ${n}l\n+    .global F7_NAME($n)\n+    ldi     ZH,     hi8(gs(F7_NAME($n)))\n+    ldi     ZL,     lo8(gs(F7_NAME($n)))\n+    F7jmp   call_dd\n+_ENDF __${n}\n+#endif /* F7MOD_D_${n}_ */\n+EOF\n+        done\n+        ;;\n+\n+    xd_math)\n+        cat << EOF\n+\n+;; Functions that usually live in libm:  Depending on [long] double layout,\n+;; define <name> and <name>l as weak alias(es) of __<name> for <name> in:\n+;; $*${none}\n+EOF\n+        for n in $*; do\n+            cat << EOF\n+\n+;; type_t __${n} (double)\n+#ifdef F7MOD_D_${n}_\n+_DEFUN __${n}\n+    DALIAS $n\n+    LALIAS ${n}l\n+    .global F7_NAME($n)\n+    ldi     ZH,     hi8(gs(F7_NAME($n)))\n+    ldi     ZL,     lo8(gs(F7_NAME($n)))\n+    F7jmp   call_xd\n+_ENDF __${n}\n+#endif /* F7MOD_D_${n}_ */\n+EOF\n+        done\n+        ;;\n+\n+    ddd_math)\n+        cat << EOF\n+\n+;; Functions that usually live in libm:  Depending on [long] double layout,\n+;; define <name> and <name>l as weak alias(es) of __<name> for <name> in:\n+;; $*${none}\n+EOF\n+        for n in $*; do\n+            cat << EOF\n+\n+;; double __${n} (double, double)\n+#ifdef F7MOD_D_${n}_\n+_DEFUN __${n}\n+    DALIAS $n\n+    LALIAS ${n}l\n+    .global F7_NAME($n)\n+    ldi     ZH,     hi8(gs(F7_NAME($n)))\n+    ldi     ZL,     lo8(gs(F7_NAME($n)))\n+    F7jmp   call_ddd\n+_ENDF __${n}\n+#endif /* F7MOD_D_${n}_ */\n+EOF\n+        done\n+        ;;\n+\n+    ddx_math)\n+        cat << EOF\n+\n+;; Functions that usually live in libm:  Depending on [long] double layout,\n+;; define <name> and <name>l as weak alias(es) of __<name> for <name> in:\n+;; $*${none}\n+EOF\n+        for n in $*; do\n+            cat << EOF\n+\n+;; double __${n} (double, word_t)\n+#ifdef F7MOD_D_${n}_\n+_DEFUN __${n}\n+    DALIAS $n\n+    LALIAS ${n}l\n+    .global F7_NAME($n)\n+    ldi     ZH,     hi8(gs(F7_NAME($n)))\n+    ldi     ZL,     lo8(gs(F7_NAME($n)))\n+    F7jmp   call_ddx\n+_ENDF __${n}\n+#endif /* F7MOD_D_${n}_ */\n+EOF\n+        done\n+        ;;\n+\n+    *)\n+        exit 1\n+        ;;\n+esac"}, {"sha": "7f4eeacd308c0f0f5a91f84e6d1f3b863839c09a", "filename": "libgcc/config/avr/libf7/libf7-array.def", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-array.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-array.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-array.def?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of LIBF7, which is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+static const F7_PGMSPACE f7_t ARRAY_NAME[] =\n+{\n+    #define F7_CONST_DEF(NAME, FLAGS, M6, M5, M4, M3, M2, M1, M0, EXPO) \\\n+    { .flags = FLAGS, .mant = { M0, M1, M2, M3, M4, M5, M6 }, .expo = EXPO },\n+    #include \"libf7-const.def\"\n+    #undef F7_CONST_DEF\n+};\n+\n+// static const uint8_t n_ARRAY_NAME = <Entries in ARRAY_NAME[]>.\n+\n+#define F7_n_NAME2(X) n_##X\n+#define F7_n_NAME1(X) F7_n_NAME2(X)\n+\n+F7_UNUSED static const uint8_t F7_n_NAME1 (ARRAY_NAME) =\n+    #define F7_CONST_DEF(NAME, FLAGS, M6, M5, M4, M3, M2, M1, M0, EXPO) \\\n+    + 1\n+    #include \"libf7-const.def\"\n+    #undef F7_CONST_DEF\n+;\n+\n+#undef F7_n_NAME1\n+#undef F7_n_NAME2"}, {"sha": "c577512a267e1d4d051274c87e1605a5c8a1bd3c", "filename": "libgcc/config/avr/libf7/libf7-asm-object.mk", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-asm-object.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-asm-object.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-asm-object.mk?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,20 @@\n+# This file is included several times in a row, once for each element of\n+# $(iter-items).  On each inclusion, we advance $o to the next element.\n+# $(iter-labels) is also advanced.\n+# This works similar to $(srcdir)/siditi-object.mk.\n+\n+o := $(firstword $(iter-items))\n+iter-items := $(filter-out $o,$(iter-items))\n+\n+$o-label := $(firstword $(iter-labels))\n+iter-labels := $(wordlist 2,$(words $(iter-labels)),$(iter-labels))\n+\n+f7_asm_$o$(objext): f7_asm_%$(objext): $(libf7)/libf7-asm.sx\n+\t$(gcc_compile) -DF7MOD_$($*-label)_ $(F7_ASM_FLAGS) \\\n+\t\t-c $<\n+\n+ifeq ($(enable_shared),yes)\n+f7_asm_$(o)_s$(objext): f7_asm_%_s$(objext): $(libf7)/libf7-asm.sx\n+\t$(gcc_s_compile) -DF7MOD_$($*-label)_ $(F7_ASM_FLAGS) \\\n+\t\t-c $<\n+endif"}, {"sha": "7972557d31ceac5a6ef5954b8787a6ac2e838357", "filename": "libgcc/config/avr/libf7/libf7-asm.sx", "status": "added", "additions": 1664, "deletions": 0, "changes": 1664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-asm.sx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-asm.sx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-asm.sx?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,1664 @@\n+;; Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+;;\n+;; This file is part of LIBF7, which is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; Under Section 7 of GPL version 3, you are granted additional\n+;; permissions described in the GCC Runtime Library Exception, version\n+;; 3.1, as published by the Free Software Foundation.\n+;;\n+;; You should have received a copy of the GNU General Public License and\n+;; a copy of the GCC Runtime Library Exception along with this program;\n+;; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __AVR_TINY__\n+\n+#define ASM_DEFS_HAVE_DEFUN\n+\n+#include \"asm-defs.h\"\n+#include \"libf7.h\"\n+\n+#define ZERO __zero_reg__\n+#define TMP  __tmp_reg__\n+\n+#define F7(name)   F7_(name##_asm)\n+\n+.macro F7call name\n+    .global F7(\\name\\())\n+    XCALL   F7(\\name\\())\n+.endm\n+\n+.macro F7jmp name\n+    .global F7(\\name\\())\n+    XJMP    F7(\\name\\())\n+.endm\n+\n+;; Just for visibility in disassembly.\n+.macro LLL name\n+    .global LLL.\\name\n+    LLL.\\name:\n+    nop\n+.endm\n+\n+.macro DEFUN name\n+    .section .text.libf7.asm.\\name, \"ax\", @progbits\n+    .global F7(\\name\\())\n+    .func F7(\\name\\())\n+    F7(\\name\\()) :\n+.endm\n+\n+.macro ENDF name\n+    .size F7(\\name\\()), . - F7(\\name\\())\n+    .endfunc\n+.endm\n+\n+.macro LABEL name\n+    .global F7(\\name\\())\n+    F7(\\name\\()) :\n+.endm\n+\n+.macro _DEFUN name\n+    .section .text.libf7.asm.\\name, \"ax\", @progbits\n+    .weak \\name\n+    .type \\name, @function\n+    \\name :\n+.endm\n+\n+.macro _ENDF name\n+    .size \\name, . - \\name\n+.endm\n+\n+.macro _LABEL name\n+    .weak \\name\n+    .type \\name, @function\n+    \\name :\n+.endm\n+\n+#define F7_NAME(X)   F7_(X)\n+\n+;; Make a weak alias.\n+.macro  ALIAS  sym\n+    .weak \\sym\n+    .type \\sym, @function\n+    \\sym:\n+.endm\n+\n+;; Make a weak alias if double is 64 bits wide.\n+.macro  DALIAS  sym\n+#if defined (WITH_LIBF7_MATH_SYMBOLS) && __SIZEOF_DOUBLE__ == 8\n+ALIAS \\sym\n+#endif\n+.endm\n+\n+;; Make a weak alias if long double is 64 bits wide.\n+.macro  LALIAS  sym\n+#if defined (WITH_LIBF7_MATH_SYMBOLS) && __SIZEOF_LONG_DOUBLE__ == 8\n+ALIAS \\sym\n+#endif\n+.endm\n+\n+#define     Off 1\n+#define     Expo (Off + F7_MANT_BYTES)\n+\n+#ifdef F7MOD_classify_\n+;;  r24 = classify (*Z)\n+;;  NaN  ->  F7_FLAG_nan\n+;;  INF  ->  F7_FLAG_inf [ | F7_FLAG_sign ]\n+;;  ==0  ->  F7_FLAG_zero\n+;;  ...  ->  0 [ | F7_FLAG_sign ]\n+\n+;; Clobbers:  None (no TMP, no T).\n+DEFUN classify\n+\n+    ld      r24,    Z\n+    lsr     r24\n+    brne .Lnan_or_inf\n+\n+    ldd     r24,    Z+6+Off\n+    tst     r24\n+    brpl 0f\n+    sbc     r24,    r24\n+    andi    r24,    F7_FLAG_sign\n+    ret\n+\n+0:  ldi     r24,    F7_FLAG_zero\n+    ret\n+\n+.Lnan_or_inf:\n+    rol     r24\n+    ret\n+\n+ENDF classify\n+#endif /* F7MOD_classify_ */\n+\n+#ifdef F7MOD_clr_\n+DEFUN clr\n+    std     Z+0,     ZERO\n+    std     Z+0+Off, ZERO\n+    std     Z+1+Off, ZERO\n+    std     Z+2+Off, ZERO\n+    std     Z+3+Off, ZERO\n+    std     Z+4+Off, ZERO\n+    std     Z+5+Off, ZERO\n+    std     Z+6+Off, ZERO\n+    std     Z+0+Expo, ZERO\n+    std     Z+1+Expo, ZERO\n+    ret\n+ENDF clr\n+\n+#endif /* F7MOD_clr_ */\n+\n+#ifdef F7MOD_clz_\n+;; The libcc CLZ implementations like __clzsi2 aka. __builtin_clzl are\n+;; not very well suited for out purpose, so implement our own.\n+\n+#define ZBITS   r26\n+.macro  .test.byte  reg\n+    or      ZERO,   \\reg\n+    brne    .Loop_bit\n+    subi    ZBITS, -8\n+.endm\n+\n+;; R26 = CLZ (uint64_t R18);  CLZ (0) = 64.\n+;; Unchanged: T\n+DEFUN clzdi2\n+    clr     ZBITS\n+    ;; Catch the common case of normalized .mant for speed-up.\n+    tst     r25\n+    brmi 9f\n+    .test.byte  r25\n+    .test.byte  r24\n+    .test.byte  r23\n+    .test.byte  r22\n+    .test.byte  r21\n+    .test.byte  r20\n+    .test.byte  r19\n+    .test.byte  r18\n+.Ldone:\n+    clr     ZERO\n+9:  ret\n+\n+.Loop_bit:\n+    lsl     ZERO\n+    brcs .Ldone\n+    inc     ZBITS\n+    rjmp .Loop_bit\n+\n+ENDF clzdi2\n+#undef  ZBITS\n+#endif /* F7MOD_clz_ */\n+\n+#ifdef F7MOD_cmp_mant_\n+DEFUN cmp_mant\n+\n+    adiw    X,   6 + Off\n+    ld      r24, X      $ ldd   TMP, Z+6+Off    $ SUB   r24, TMP\n+    brne .Lunequal\n+\n+    sbiw    X,  6\n+    ld      r24, X+     $ ldd   TMP, Z+0+Off    $ SUB   r24, TMP\n+    ld      r24, X+     $ ldd   TMP, Z+1+Off    $ sbc   r24, TMP\n+    ld      r24, X+     $ ldd   TMP, Z+2+Off    $ sbc   r24, TMP\n+    ld      r24, X+     $ ldd   TMP, Z+3+Off    $ sbc   r24, TMP\n+    ld      r24, X+     $ ldd   TMP, Z+4+Off    $ sbc   r24, TMP\n+    ld      r24, X+     $ ldd   TMP, Z+5+Off    $ sbc   r24, TMP\n+    ;; MSBs are already known to be equal\n+    breq 9f\n+.Lunequal:\n+    sbc     r24,    r24\n+    sbci    r24,    -1\n+9:  sbiw    X,      6 + Off\n+    ret\n+ENDF cmp_mant\n+#endif /* F7MOD_cmp_mant_ */\n+\n+#define     CA      18\n+#define     C0      CA+1\n+#define     C1      C0+1\n+#define     C2      C0+2\n+#define     C3      C0+3\n+#define     C4      C0+4\n+#define     C5      C0+5\n+#define     C6      C0+6\n+#define     Carry   r16\n+#define     Flags   18\n+\n+#ifdef F7MOD_store_\n+;; Z->flags = CA.\n+;; Z->mant  = C[7].\n+DEFUN store_mant.with_flags\n+    st      Z,      CA\n+\n+;; Z->mant = C[7].\n+LABEL store_mant\n+    std     Z+0+Off, C0\n+    std     Z+1+Off, C1\n+    std     Z+2+Off, C2\n+    std     Z+3+Off, C3\n+    std     Z+4+Off, C4\n+    std     Z+5+Off, C5\n+    std     Z+6+Off, C6\n+    ret\n+ENDF store_mant.with_flags\n+#endif /* F7MOD_store_ */\n+\n+#ifdef F7MOD_load_\n+;; CA   = Z->flags\n+;; C[7] = Z->mant\n+DEFUN load_mant.with_flags\n+    ld      CA,     Z\n+    skipnext\n+\n+;; CA   = 0\n+;; C[7] = Z->mant\n+LABEL load_mant.clr_CA\n+LABEL load_mant.clr_flags\n+    clr     CA      ; May be skipped\n+\n+;; C[7] = Z->mant\n+LABEL load_mant\n+    ldd     C0,     Z+0+Off\n+    ldd     C1,     Z+1+Off\n+    ldd     C2,     Z+2+Off\n+    ldd     C3,     Z+3+Off\n+    ldd     C4,     Z+4+Off\n+    ldd     C5,     Z+5+Off\n+    ldd     C6,     Z+6+Off\n+    ret\n+ENDF load_mant.with_flags\n+#endif /* F7MOD_load_ */\n+\n+#ifdef F7MOD_copy_\n+DEFUN copy\n+    cp      XL,     ZL\n+    cpc     XH,     ZH\n+    breq 9f\n+    adiw    XL,     10\n+    adiw    ZL,     10\n+    set\n+    bld     ZERO,   1\n+    bld     ZERO,   3   ; ZERO = 0b1010 = 10.\n+.Loop:\n+    ld      TMP,    -X\n+    st      -Z,     TMP\n+    dec     ZERO\n+    brne .Loop\n+9:  ret\n+ENDF copy\n+#endif /* F7MOD_copy_ */\n+\n+#ifdef F7MOD_copy_P_\n+DEFUN copy_P\n+    set\n+    bld     ZERO,   1\n+    bld     ZERO,   3   ; ZERO = 0b1010 = 10.\n+.Loop:\n+#ifdef __AVR_HAVE_LPMX__\n+    lpm     TMP,    Z+\n+#else\n+    lpm\n+    adiw    Z,      1\n+#endif /* Have LPMx */\n+    st      X+,     TMP\n+    dec     ZERO\n+    brne .Loop\n+    sbiw    X,      10\n+    sbiw    Z,      10\n+    ret\n+ENDF copy_P\n+#endif /* F7MOD_copy_P_ */\n+\n+#ifdef F7MOD_copy_mant_\n+DEFUN copy_mant\n+    cp      XL,     ZL\n+    cpc     XH,     ZH\n+    breq 9f\n+    adiw    XL,     1\n+    adiw    ZL,     1\n+    set\n+    bld     ZERO,   3\n+    dec     ZERO        ; ZERO = 7\n+.Loop:\n+    ld      TMP,    X+\n+    st      Z+,     TMP\n+    dec     ZERO\n+    brne    .Loop\n+    sbiw    XL,     8\n+    sbiw    ZL,     8\n+9:  ret\n+ENDF copy_mant\n+#endif /* F7MOD_copy_mant_ */\n+\n+\n+#ifdef F7MOD_clr_mant_lsbs_\n+DEFUN clr_mant_lsbs\n+    push    r16\n+    mov     r16,    r20\n+    wmov    XL,     r24\n+\n+    wmov    ZL,     r22\n+    F7call  load_mant\n+\n+    F7call  lshrdi3\n+\n+    clr     CA\n+\n+    F7call   ashldi3\n+\n+    pop     r16\n+\n+    wmov    ZL,     XL\n+    F7jmp  store_mant\n+\n+ENDF clr_mant_lsbs\n+#endif /* F7MOD_clr_mant_lsbs_ */\n+\n+\n+#ifdef F7MOD_normalize_with_carry_\n+;; Z = &f7_t\n+;; C[] = .mant may be not normalized\n+;; Carry === r16 = Addend to Z->expo in [-64, 128).\n+;; Normalize C[], set Flags, and adjust Z->expo.\n+;; Return CA (after normalization) in TMP.\n+;; Unchanged: T\n+#define Addend  r17\n+#define Zbits   r26\n+#define expL    r26\n+#define expH    r27\n+DEFUN normalize_with_carry\n+    mov     Addend, Carry\n+    tst     C6\n+    brmi .Lshift.0\n+    ;; r26 = CLZ (uint64_t R18)\n+    F7call  clzdi2\n+    cpi     Zbits,  64\n+    breq .Lclr\n+    sub     Addend, Zbits\n+    mov     r16,    Zbits\n+\n+    F7call  ashldi3\n+    ;; Assert (R25.7 == 1)\n+.Lshift.0:\n+    mov     TMP,    CA\n+    ld      Flags,  Z\n+\n+    ;; .expo += Addend\n+    ldd     expL,   Z+0+Expo\n+    ldd     expH,   Z+1+Expo\n+    ;; Sign-extend Addend\n+    clr     r16\n+    sbrc    Addend, 7\n+    com     r16\n+\n+    ;; exp += (int8_t) Addend, i.e. sign-extend Addend.\n+    add     expL,   Addend\n+    adc     expH,   r16\n+    brvc .Lnormal\n+    tst     r16\n+    brmi .Lclr\n+    ;; Overflow\n+#if F7_HAVE_Inf == 1\n+    ori     Flags,  F7_FLAG_inf\n+#else\n+    ldi     Flags,  F7_FLAG_nan\n+#endif /* Have Inf */\n+    ret\n+\n+.Lnormal:\n+    std     Z+0+Expo,   expL\n+    std     Z+1+Expo,   expH\n+    ret\n+\n+.Lclr:\n+    ;; Underflow or Zero.\n+    clr     TMP\n+    .global __clr_8\n+    XJMP    __clr_8\n+\n+LABEL normalize.store_with_flags\n+    ;; no rounding\n+    set\n+    skipnext\n+LABEL normalize.round.store_with_flags\n+    ;; with rounding\n+    clt     ; skipped ?\n+LABEL normalize.maybe_round.store_with_flags\n+    F7call  normalize_with_carry\n+    ;; We have:\n+    ;; Z   = &f7_t\n+    ;; X   = .expo\n+    ;; C[] = .mant\n+    ;; R18 = .flags\n+    ;; TMP = byte below .mant after normalization\n+    ;; T = 1  =>  no rounding.\n+    brts .Lstore\n+    lsl     TMP\n+    adc     C0,     ZERO\n+    brcc .Lstore\n+    adc     C1,     ZERO\n+    adc     C2,     ZERO\n+    adc     C3,     ZERO\n+    adc     C4,     ZERO\n+    adc     C5,     ZERO\n+    adc     C6,     ZERO\n+    brcc .Lstore\n+    ;; We only come here if C6 overflowed, i.e. C[] is 0 now.\n+    ;; .mant = 1.0 by restoring the MSbit.\n+    ror     C6\n+    ;; .expo += 1 and override the .expo stored during normalize.\n+    adiw    expL,   1\n+    std     Z+0+Expo,   expL\n+    std     Z+1+Expo,   expH\n+\n+.Lstore:\n+    F7call  store_mant.with_flags\n+\n+    ;; Return the byte below .mant after normalization.\n+    ;; This is only useful without rounding; the caller will know.\n+    mov     R24,    TMP\n+    ret\n+ENDF normalize_with_carry\n+#endif /* F7MOD_normalize_with_carry_ */\n+\n+\n+#ifdef F7MOD_normalize_\n+;; Using above functionality from C.\n+;; f7_t* normalize (f7_t *cc)\n+;; Adjusts cc->expo\n+;; Clears cc->flags\n+DEFUN normalize\n+    push    r17\n+    push    r16\n+    wmov    ZL,     r24\n+    F7call  load_mant.clr_CA\n+    clr     Carry\n+    st      Z,      ZERO\n+    F7call  normalize.store_with_flags\n+    wmov    r24,    Z\n+    pop     r16\n+    pop     r17\n+    ret\n+ENDF normalize\n+#endif /* F7MOD_normalize_ */\n+\n+\n+#ifdef F7MOD_store_expo_\n+#define Done    r24\n+#define expLO   r24\n+#define expHI   r25\n+;; expo == INT16_MAX  =>  *Z = Inf,         return Done = true.\n+;; expo == INT16_MIN  =>  *Z = 0x0,         return Done = true.\n+;; else               =>  Z->expo = expo,   return Done = false.\n+DEFUN store_expo\n+    cpi     expHI,   0x80\n+    cpc     expLO,  ZERO\n+    breq .Ltiny\n+    adiw    expLO,  1\n+    brvs .Lhuge\n+    sbiw    expLO,  1\n+    std     Z+0+Expo,   expLO\n+    std     Z+1+Expo,   expHI\n+    ldi     Done,   0\n+    ret\n+\n+.Lhuge:\n+#if F7_HAVE_Inf == 1\n+    ld      Done,   Z\n+    andi    Done,   F7_FLAG_sign\n+    ori     Done,   F7_FLAG_inf\n+#else\n+    ldi     Done,   F7_FLAG_nan\n+#endif /* Have Inf */\n+    st      Z,      Done\n+    ldi     Done,   1\n+    ret\n+\n+.Ltiny:\n+    ldi     Done,   1\n+    F7jmp   clr\n+ENDF store_expo\n+#endif /* F7MOD_store_expo_ */\n+\n+\n+#ifdef F7MOD_set_u64_\n+DEFUN set_s64\n+    set\n+    skipnext\n+    ;; ...\n+LABEL set_u64\n+    clt     ; Skipped?\n+    wmov    Zl,     r16\n+    ;; TMP holds .flags.\n+    clr     TMP\n+    brtc .Lnot.negative\n+\n+    bst     C6,     7\n+    brtc .Lnot.negative\n+    bld     TMP,    F7_FLAGNO_sign\n+    .global __negdi2\n+    XCALL   __negdi2\n+\n+.Lnot.negative:\n+    st      Z,          TMP\n+    std     Z+0+Expo,   ZERO\n+    std     Z+1+Expo,   ZERO\n+    ldi     Carry,      63\n+    F7call  normalize.round.store_with_flags\n+    wmov    r24,        Z\n+    wmov    r16,        Z   ; Unclobber r16.\n+    ret\n+ENDF set_s64\n+#endif /* F7MOD_set_u64_ */\n+\n+\n+#ifdef F7MOD_to_integer_\n+#define Mask    r26\n+DEFUN to_integer\n+    wmov    ZL,     r24\n+    mov     Mask,   r22\n+\n+    F7call  load_mant.with_flags\n+\n+    sbrc    Flags, F7_FLAGNO_nan\n+    rjmp .Lset_0x8000\n+\n+    sbrc    Flags, F7_FLAGNO_inf\n+    rjmp .Lsaturate\n+\n+    sbrs    C6, 7\n+    rjmp .Lset_0x0000\n+\n+    bst     Flags, F7_FLAGNO_sign\n+    ldd     r27,    Z+0+Expo\n+    ;; Does .expo have bits outside Mask? ...\n+    mov     TMP,    Mask\n+    com     TMP\n+    and     TMP,    r27\n+    ldd     r27,    Z+1+Expo\n+    tst     r27\n+    brmi .Lset_0x0000       ; ...yes: .expo is < 0  =>  return 0\n+    or      TMP,    r27\n+    brne .Lsaturate.T       ; ...yes: .expo > Mask  =>  saturate\n+\n+    ;; ...no:  Shift right to meet .expo = 0.\n+    PUSH    r16\n+    ldd     r16,    Z+0+Expo\n+    eor     r16,    Mask\n+    and     r16,    Mask\n+    clr     CA\n+    F7call  lshrdi3\n+    POP     r16\n+    tst     C6\n+    brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate\n+\n+    rcall   .Lround\n+    brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate\n+\n+    brtc 9f                 ;   >= 0         =>  return\n+    sbrc    Mask,   5\n+    .global __negdi2\n+    XJMP    __negdi2\n+    sbrc    Mask,   4\n+    .global __negsi2\n+    XJMP    __negsi2\n+    neg     C6\n+    neg     C5\n+    sbci    C6,     0\n+9:  ret\n+\n+.Lsaturate:\n+    bst     Flags, F7_FLAGNO_sign\n+.Lsaturate.T:\n+\n+#if F7_HAVE_Inf\n+    brtc .Lset_0x7fff\n+    ;; -Inf  =>  return 1 + INTxx_MIN\n+    mov     ZL,     Flags\n+    .global __clr_8\n+    XCALL   __clr_8\n+    ldi     C6,     0x80\n+\n+    ldi     CA+0,   0x01\n+\n+    sbrs    Mask,   5\n+    ldi     CA+4,   0x01\n+\n+    sbrs    Mask,   4\n+    ldi     CA+6,   0x01\n+    ret\n+\n+.Lset_0x7fff:\n+    ;; +Inf  =>  return INTxx_MAX\n+    sec\n+    .global __sbc_8\n+    XCALL   __sbc_8\n+    ldi     C6,     0x7f\n+    ret\n+#endif /* F7_HAVE_Inf */\n+\n+.Lset_0x8000:\n+    ;; NaN  =>  return INTxx_MIN\n+    .global __clr_8\n+    XCALL   __clr_8\n+    ldi     C6,     0x80\n+    ret\n+\n+.Lset_0x0000:\n+    ;; Small value  =>  return 0x0\n+    .global __clr_8\n+    XJMP    __clr_8\n+\n+.Lround:\n+    ;; C6.7 is known to be 0 here.\n+    ;; Return N = 1 iff we have to saturate.\n+    cpi     Mask,   0xf\n+    breq .Lround16\n+    cpi     Mask,   0x1f\n+    breq .Lround32\n+\n+    ;; For now, no rounding in the 64-bit case.  This rounding\n+    ;; would have to be integrated into the right-shift.\n+    cln\n+    ret\n+\n+.Lround32:\n+    rol     C2\n+    adc     C3,     ZERO\n+    adc     C4,     ZERO\n+    rjmp 2f\n+\n+.Lround16:\n+    rol     C4\n+2:  adc     C5,     ZERO\n+    adc     C6,     ZERO\n+    ret\n+ENDF to_integer\n+#endif /* F7MOD_to_integer_ */\n+\n+\n+#ifdef F7MOD_to_unsigned_\n+#define Mask    r26\n+DEFUN to_unsigned\n+    wmov    ZL,     r24\n+    mov     Mask,   r22\n+\n+    F7call  load_mant.with_flags\n+\n+    sbrc    Flags, F7_FLAGNO_nan\n+    rjmp .Lset_0xffff\n+\n+    sbrc    Flags, F7_FLAGNO_sign\n+    rjmp .Lset_0x0000\n+\n+    sbrc    Flags, F7_FLAGNO_inf\n+    rjmp .Lset_0xffff\n+\n+    sbrs    C6, 7\n+    rjmp .Lset_0x0000\n+\n+    ldd     r27,    Z+0+Expo\n+    ;; Does .expo have bits outside Mask? ...\n+    mov     TMP,    Mask\n+    com     TMP\n+    and     TMP,    r27\n+    ldd     r27,    Z+1+Expo\n+    tst     r27\n+    brmi .Lset_0x0000       ; ...yes: .expo is < 0  =>  return 0\n+    or      TMP,    r27\n+    brne .Lset_0xffff       ; ...yes: .expo > Mask  =>  saturate\n+\n+    ;; ...no:  Shift right to meet .expo = 0.\n+    PUSH    r16\n+    ldd     r16,    Z+0+Expo\n+    eor     r16,    Mask\n+    and     r16,    Mask\n+    clr     CA\n+    F7call  lshrdi3\n+    POP     r16\n+\n+    ;; Rounding\n+    ;; ??? C6.7 is known to be 0 here.\n+    cpi     Mask,   0xf\n+    breq .Lround16\n+    cpi     Mask,   0x1f\n+    breq .Lround32\n+\n+    ;; For now, no rounding in the 64-bit case.  This rounding\n+    ;; would have to be integrated into the right-shift.\n+    ret\n+\n+.Lround32:\n+    rol     C2\n+    adc     C3,     ZERO\n+    adc     C4,     ZERO\n+    rjmp 2f\n+\n+.Lround16:\n+    rol     C4\n+2:  adc     C5,     ZERO\n+    adc     C6,     ZERO\n+    brcs    .Lset_0xffff    ; Rounding overflow  =>  saturate\n+    ret\n+\n+.Lset_0xffff:\n+    ;; return UINTxx_MAX\n+    sec\n+    .global __sbc_8\n+    XJMP    __sbc_8\n+\n+.Lset_0x0000:\n+    ;; Small value  =>  return 0x0\n+    .global __clr_8\n+    XJMP    __clr_8\n+\n+ENDF to_unsigned\n+#endif /* F7MOD_to_unsigned_ */\n+\n+\n+#ifdef F7MOD_addsub_mant_scaled_\n+;; int8_t f7_addsub_mant_scaled_asm (f7_t *r24, const f7_t *r22, const f7_t 20*,\n+;;                                   uint8_t r18);\n+;; R18.0 = 1 : ADD\n+;; R18.0 = 0 : SUB\n+;; R18[7..1] : Scale\n+;; Compute *R24 = *R22 + *R20 >> R18[7..1].\n+\n+#define     BA      10\n+#define     B0      BA+1\n+#define     B1      B0+1\n+#define     B2      B0+2\n+#define     B3      B0+3\n+#define     B4      B0+4\n+#define     B5      B0+5\n+#define     B6      B0+6\n+\n+DEFUN addsub_mant_scaled\n+    do_prologue_saves  10\n+\n+    bst     r18,    0  ;; ADD ?\n+    lsr     r18\n+    mov     r16,    r18\n+\n+    wmov    ZL,     r20\n+    wmov    YL,     r22\n+    ;; C[] = bb >> shift\n+    wmov    XL,     r24\n+\n+    F7call  load_mant.clr_CA\n+    F7call  lshrdi3\n+\n+    wmov    BA,     CA\n+    wmov    B1,     C1\n+    wmov    B3,     C3\n+    wmov    B5,     C5\n+    wmov    ZL,     YL\n+    F7call  load_mant.clr_CA\n+\n+    wmov    ZL,     XL\n+\n+    brts .Ladd\n+\n+    .global __subdi3\n+    XCALL   __subdi3\n+\n+    breq .Lzero\n+    brcc .Lround\n+    ;; C = 1: Can underflow happen at all ?\n+.Lzero:\n+    F7call  clr\n+    rjmp .Lepilogue\n+\n+.Ladd:\n+    .global __adddi3\n+    XCALL   __adddi3\n+    brcc .Lround\n+    ldi     Carry,  1\n+    .global __lshrdi3\n+    XCALL   __lshrdi3\n+    ori     C6, 1 << 7\n+    skipnext\n+.Lround:\n+    clr     Carry   ; skipped?\n+    F7call  normalize.round.store_with_flags\n+\n+.Lepilogue:\n+    do_epilogue_restores 10\n+\n+ENDF addsub_mant_scaled\n+\n+#if !defined (__AVR_HAVE_MOVW__) || !defined (__AVR_HAVE_JMP_CALL__)\n+DEFUN lshrdi3\n+    .global __lshrdi3\n+    XJMP    __lshrdi3\n+ENDF lshrdi3\n+DEFUN ashldi3\n+    .global __ashldi3\n+    XJMP    __ashldi3\n+ENDF ashldi3\n+#else\n+\n+# Basically just a wrapper around libgcc's __lshrdi3.\n+DEFUN lshrdi3\n+    ;; Handle bit 5 of shift offset.\n+    sbrs    r16,    5\n+    rjmp 4f\n+    wmov    CA,     C3\n+    wmov    C1,     C5\n+    clr     C6          $   clr     C5  $   wmov    C3, C5\n+4:\n+    ;; Handle bit 4 of shift offset.\n+    sbrs    r16,    4\n+    rjmp 3f\n+    wmov CA, C1\n+    wmov C1, C3\n+    wmov C3, C5\n+    clr     C6          $   clr     C5\n+3:\n+    ;; Handle bits 3...0 of shift offset.\n+    push    r16\n+    andi    r16,    0xf\n+    breq 0f\n+\n+    .global __lshrdi3\n+    XCALL   __lshrdi3\n+0:\n+    pop     r16\n+    ret\n+ENDF lshrdi3\n+\n+# Basically just a wrapper around libgcc's __ashldi3.\n+DEFUN ashldi3\n+    ;; Handle bit 5 of shift offset.\n+    sbrs    r16,    5\n+    rjmp 4f\n+    wmov    C5,     C1\n+    wmov    C3,     CA\n+    clr     C2          $   clr     C1  $   wmov    CA, C1\n+4:\n+    ;; Handle bit 4 of shift offset.\n+    sbrs    r16,    4\n+    rjmp 3f\n+    wmov C5, C3\n+    wmov C3, C1\n+    wmov C1, CA\n+    clr     CA          $   clr     C0\n+3:\n+    ;; Handle bits 3...0 of shift offset.\n+    push    r16\n+    andi    r16,    0xf\n+    breq 0f\n+\n+    .global __ashldi3\n+    XCALL   __ashldi3\n+0:\n+    pop     r16\n+    ret\n+ENDF ashldi3\n+#endif /* Small device */\n+\n+#endif /* F7MOD_addsub_mant_scaled_ */\n+\n+#if defined F7MOD_mul_mant_ && defined (__AVR_HAVE_MUL__)\n+    #define     A0      11\n+    #define     A1      A0+1\n+    #define     A2      A0+2\n+    #define     A3      A0+3\n+    #define     A4      A0+4\n+    #define     A5      A0+5\n+    #define     A6      A0+6\n+\n+    #define     TT0     26\n+    #define     TT1     TT0+1\n+    #define     TT2     28\n+    #define     TT3     TT2+1\n+\n+    #define     BB      10\n+\n+;; R18.0 = 1: No rounding.\n+\n+DEFUN mul_mant\n+    do_prologue_saves 10\n+    bst     r18,    0\n+    push    r25\n+    push    r24\n+    movw    ZL,     r22\n+    LDD     A0,     Z+0+Off\n+    LDD     A1,     Z+1+Off\n+    LDD     A2,     Z+2+Off\n+    LDD     A3,     Z+3+Off\n+    LDD     A4,     Z+4+Off\n+    LDD     A5,     Z+5+Off\n+    LDD     A6,     Z+6+Off\n+    movw    ZL,     r20\n+\n+    ;; 6 * 6 -> 6:5\n+    ;; 4 * 6 -> 4:3\n+    ;; 2 * 6 -> 2:1\n+    ;; 0 * 6 -> 0:a\n+    ldd     BB, Z+6+Off\n+    mul     A6, BB      $   movw    C5, r0\n+    mul     A4, BB      $   movw    C3, r0\n+    mul     A2, BB      $   movw    C1, r0\n+    mul     A0, BB      $   movw    CA, r0\n+\n+    ;; 5 * 6 -> 5:4\n+    ;; 3 * 6 -> 3:2\n+    ;; 1 * 6 -> 1:0\n+    mul     A5, BB      $   movw    TT2, r0\n+    mul     A3, BB      $   movw    TT0, r0\n+    mul     A1, BB\n+    ADD     C0, r0      $   adc     C1, r1\n+    adc     C2, TT0     $   adc     C3, TT1\n+    adc     C4, TT2     $   adc     C5, TT3     $   clr ZERO\n+    adc     C6, ZERO\n+    ;; Done B6\n+\n+    ;; 3 * 3 -> 0:a\n+    ;; 4 * 4 -> 2:1\n+    ;; 5 * 5 -> 4:3\n+    ldd     BB, Z+3+Off $   mul     A3, BB      $   movw    TT0, r0\n+    ldd     BB, Z+4+Off $   mul     A4, BB      $   movw    TT2, r0\n+    ldd     BB, Z+5+Off $   mul     A5, BB\n+\n+    ADD     CA, TT0     $   adc     C0, TT1\n+    adc     C1, TT2     $   adc     C2, TT3\n+    adc     C3, r0      $   adc     C4, r1\n+    brcc .+2\n+    adiw    C5, 1\n+\n+    ;; 6 * 5 -> 5:4\n+    ;; 4 * 5 -> 3:2\n+    ;; 2 * 5 -> 1:0\n+    ;; 0 * 5 -> a:-\n+    mul     A0, BB\n+    ;; A0 done\n+#define Atmp A0\n+\n+    mov     Atmp, r1\n+    mul     A6, BB      $   movw    TT2, r0\n+    mul     A4, BB      $   movw    TT0, r0\n+    mul     A2, BB\n+\n+    ADD     CA, Atmp\n+    adc     C0, r0      $   adc     C1, r1\n+    adc     C2, TT0     $   adc     C3, TT1\n+    adc     C4, TT2     $   adc     C5, TT3     $   clr ZERO\n+    adc     C6, ZERO\n+\n+    ;; 1 * 5 -> 0:a\n+    ;; 3 * 5 -> 2:1\n+    ;; 6 * 4 -> 4:3\n+    mul     A1, BB      $   movw    TT0, r0\n+    mul     A3, BB      $   movw    TT2, r0\n+    ldd     BB, Z+4+Off\n+    mul     A6, BB\n+\n+    ADD     CA, TT0     $   adc     C0, TT1\n+    adc     C1, TT2     $   adc     C2, TT3\n+    adc     C3, r0      $   adc     C4, r1      $   clr ZERO\n+    adc     C5, ZERO    $   adc     C6, ZERO\n+    ;; B5 done\n+\n+    ;; 6 * 3 -> 3:2\n+    ;; 6 * 1 -> 1:0\n+    ;; 4 * 1 -> a:-\n+    mov     TT0, A6     $   ldd TMP,  Z+3+Off\n+    mov     BB,  A4     $   ldd Atmp, Z+1+Off\n+    rcall   .Lmul.help.3\n+\n+    ;; 5 * 4 -> 3:2\n+    ;; 5 * 2 -> 1:0\n+    ;; 3 * 2 -> a:-\n+    mov     TT0, A5     $   ldd TMP,  Z+4+Off\n+    mov     BB,  A3     $   ldd Atmp, Z+2+Off\n+    rcall   .Lmul.help.3\n+\n+    ;; 4 *   -> 3:2 (=0)\n+    ;; 4 * 3 -> 1:0\n+    ;; 2 * 3 -> a:-\n+    mov     TT0, A4     $   clr TMP\n+    mov     BB,  A2     $   ldd Atmp, Z+3+Off\n+    rcall   .Lmul.help.3\n+\n+    ;; 3 * . -> 3:2 (=0)\n+    ;; 3 * 4 -> 1:0\n+    ;; 1 * 4 -> a:-\n+    mov     TT0, A3     $   clr TMP\n+    mov     BB,  A1     $   ldd Atmp, Z+4+Off\n+    rcall   .Lmul.help.3\n+\n+    ;; . * ? -> 3:2 (=0)\n+    ;; . * 0 -> 1:0 (=0)\n+    ;; 5 * 0 -> a:-\n+    clr     TT0\n+    mov     BB,  A5     $   ldd Atmp, Z+0+Off\n+    rcall   .Lmul.help.3\n+\n+    clr TT3  ;; Asserted by .Lmul.help.2\n+    ;; 6 * 2 -> 2:1\n+    ;; 6 * 0 -> 0:a\n+                        $   ldd TMP,  Z+2+Off\n+    mov     BB, A6     ;$   ldd Atmp, Z+0+Off\n+    rcall   .Lmul.help.2\n+\n+    ;; 5 * 3 -> 2:1\n+    ;; 5 * 1 -> 0:a\n+                        $   ldd TMP,  Z+3+Off\n+    mov     BB, A5      $   ldd Atmp, Z+1+Off\n+    rcall   .Lmul.help.2\n+\n+    ;; 4 * . -> 2:1 (=0)\n+    ;; 4 * 2 -> 0:a\n+                        $   clr TMP\n+    mov     BB, A4      $   ldd Atmp, Z+2+Off\n+    rcall   .Lmul.help.2\n+\n+    ;; 2 * . -> 2:1 (=0)\n+    ;; 2 * 4 -> 0:a\n+                        $   clr TMP\n+    mov     BB, A2      $   ldd Atmp, Z+4+Off\n+    rcall   .Lmul.help.2\n+\n+    ;; Finally...\n+\n+    pop     ZL\n+    pop     ZH\n+    ;; The high byte is at least 0x40 and at most 0xfe.\n+    ;; The result has to be left-shifted by one in order to scale it\n+    ;; correctly.\n+\n+    ldi     Carry,  1\n+    F7call  normalize.maybe_round.store_with_flags\n+\n+    do_epilogue_restores 10\n+\n+;; TT0 * Tmp  -> 3:2\n+;; TT0 * Atmp -> 1:0\n+;; BB  * Atmp -> a:-\n+;;\n+;; Clobbers : TMP, TT0...TT3.\n+;; Sets     : ZERO = 0.\n+.Lmul.help.3:\n+    mul     TT0, TMP    $   movw    TT2, r0\n+    mul     TT0, Atmp   $   movw    TT0, r0\n+    mul     BB,  Atmp\n+\n+    ADD     CA, r1\n+    adc     C0, TT0     $   adc     C1, TT1\n+    adc     C2, TT2\n+.Lmul.help.3.C3:        $   adc     C3, TT3     $ clr ZERO\n+    adc     C4, ZERO    $   adc     C5, ZERO\n+    adc     C6, ZERO\n+    ret\n+\n+;; BB * TMP  -> 2:1\n+;; BB * Atmp -> 0:a\n+;;\n+;; Asserts  : TT3 = 0\n+;; Clobbers : TMP, TT0, TT1.\n+;; Sets     : ZERO = 0.\n+.Lmul.help.2:\n+    mul     BB, TMP     $   movw    TT0, r0\n+    mul     BB, Atmp\n+    ADD     CA, r0      $   adc     C0, r1\n+    adc     C1, TT0     $   adc     C2, TT1\n+    rjmp .Lmul.help.3.C3\n+\n+ENDF mul_mant\n+#endif /* F7MOD_mul_mant_ && MUL */\n+\n+\n+#if defined (F7MOD_div_)\n+\n+;; Dividend is C[]\n+\n+;; Divisor\n+#define A0       9\n+#define A1      10\n+#define A2      11\n+#define A3      12\n+#define A4      13\n+#define A5      14\n+#define A6      15\n+\n+;; Quotient\n+#define Q0      0       /* === TMP  */\n+#define Q1      Q0+1    /* === ZERO */\n+#define Q2      26\n+#define Q3      Q2+1\n+#define Q4      28\n+#define Q5      Q4+1\n+#define Q6      16\n+#define Q7      Q6+1\n+\n+#define Cnt     CA\n+#define QBits   r8\n+\n+DEFUN div\n+    do_prologue_saves 12\n+\n+    ;; Number of bits requested for the quotient.\n+    ;; This is usually 2 + F7_MANT_BITS.\n+    mov     QBits,  r20\n+    wmov    ZL,     r22\n+    LDD     A0,     Z+0+Off\n+    LDD     A1,     Z+1+Off\n+    LDD     A2,     Z+2+Off\n+    LDD     A3,     Z+3+Off\n+    LDD     A4,     Z+4+Off\n+    LDD     A5,     Z+5+Off\n+    LDD     A6,     Z+6+Off\n+    wmov    ZL,     r24\n+    F7call  load_mant\n+\n+    ;; Clear quotient Q[].\n+    clr     Q0      ; === TMP\n+    ;clr    Q1      ; === ZERO\n+    wmov    Q2,     Q0\n+    wmov    Q4,     Q0\n+    wmov    Q6,     Q0\n+\n+    ;; C[] and A[] are valid mantissae, i.e. their MSBit is set.  Therefore,\n+    ;; quotient Q[] will be in  [0x0.ff..., 0x0.40...]  and to adjust Q[] we\n+    ;; need at most 1 left-shift.  Compute F7_MANT_BITS + 2 bits of the\n+    ;; quotient:  One bit is used for rounding, and one bit might be consumed\n+    ;; by the mentioned left-shift.\n+    mov     Cnt,    QBits\n+    rjmp .Loop_start\n+\n+.Loop:\n+    ;; Shift dividend.\n+    LSL     C0\n+    rol     C1\n+    rol     C2\n+    rol     C3\n+    rol     C4\n+    rol     C5\n+    rol     C6\n+    brcs .Lfits\n+    ;; Compare dividend against divisor.\n+.Loop_start:\n+    CP      C0,     A0\n+    cpc     C1,     A1\n+    cpc     C2,     A2\n+    cpc     C3,     A3\n+    cpc     C4,     A4\n+    cpc     C5,     A5\n+    cpc     C6,     A6\n+    ;; Shift 0 into quotient.\n+    brlo 1f\n+.Lfits:\n+    ;; Divisor fits into dividend.\n+    SUB     C0,     A0\n+    sbc     C1,     A1\n+    sbc     C2,     A2\n+    sbc     C3,     A3\n+    sbc     C4,     A4\n+    sbc     C5,     A5\n+    sbc     C6,     A6\n+    ;; Shift 1 into quotient.\n+    sec\n+    rol     Q0\n+    skipnext\n+1:  lsl     Q0\n+    rol     Q1\n+    rol     Q2\n+    rol     Q3\n+    rol     Q4\n+    rol     Q5\n+    rol     Q6\n+    rol     Q7\n+    dec     Cnt\n+    brne .Loop\n+\n+    wmov    CA,     Q0\n+    wmov    C1,     Q2\n+    wmov    C3,     Q4\n+    wmov    C5,     Q6\n+    clr     ZERO\n+\n+    ldi     Carry,  64\n+    sub     Carry,  QBits\n+    F7call  normalize.round.store_with_flags\n+\n+    do_epilogue_restores 12\n+ENDF div\n+\n+#endif /* F7MOD_div_ */\n+\n+\n+#if defined (F7MOD_sqrt16_) && defined (__AVR_HAVE_MUL__)\n+\n+#define     Mask    C6\n+#define     Q0      C3      /*  = R22  */\n+#define     Q1      C4      /*  = R23  */\n+\n+;; uint16_t R24 = sqrt16_XXX (uint16_t R24);\n+;; Clobbers:   R22, R23, TMP.\n+;;\n+;; XXX = floor:  Return integral part of square-root of R25:R24 with R25 = 0.\n+;;               Error is in [0, -1 LSB).\n+;; XXX = round:  Return quare-root of R25:R24 rounded to nearest integer.\n+;;               R25 = (Q[] >= 65281) = (Q > 0xff00),  i.e. if Q[] is not\n+;;               bigger than 0xff00, then the result fits in 8 bits.\n+;;               Return C = 0 if the result is the same as for XXX = floor,\n+;;               error in [0, -1/2 LSB)\n+;;               Return C = 1 if the result is one higher than for XXX = floor,\n+;;               error in [1/2 LSB, 0).\n+DEFUN sqrt16_round\n+    set\n+    skipnext\n+    ;; ...\n+LABEL sqrt16_floor\n+    clt ; Skipped?\n+    movw    Q0,     r24\n+    clr     C5\n+    ldi     Mask,   1 << 7\n+\n+.Loop_mask:\n+    add     C5,     Mask\n+    mul     C5,     C5\n+    cp      Q0,     R0\n+    cpc     Q1,     R1\n+    brsh 1f\n+    sub     C5,     Mask\n+1:  lsr     Mask\n+    brne .Loop_mask\n+\n+    brtc .Ldone             ; No rounding  =>  C6 will be 0.\n+\n+    ;; Rounding:  (X + 1/2)^2  =  X^2 + X + 1/4,  thus probing\n+    ;; for bit -1 is testing Q[] against  C5^2 + C5.\n+    mul     C5,     C5\n+    add     R0,     C5\n+    adc     R1,     C6      ; Exploit C6 === Mask = 0.\n+    cp      R0,     Q0\n+    cpc     R1,     Q1\n+    brcc .Ldone\n+    ;; If  C5^2 + C5 + 1/4  fits into Q[], then round up and C = 1.\n+    adiw    C5,     1       ; Exploit C6 === Mask = 0.\n+    sec\n+\n+.Ldone:\n+    clr     __zero_reg__\n+    ret\n+ENDF sqrt16_round\n+#undef Mask\n+#undef Q0\n+#undef Q1\n+#endif /* F7MOD_sqrt16_ && MUL */\n+\n+#ifdef F7MOD_sqrt_approx_\n+DEFUN sqrt_approx\n+    push    r17\n+    push    r16\n+    wmov    XL,     r24\n+    wmov    ZL,     r22\n+\n+    ;; C[] = 0.\n+    .global __clr_8\n+    XCALL   __clr_8\n+\n+    ldd     C5,     Z+5+Off\n+    ldd     C6,     Z+6+Off\n+\n+    ldd     Carry,  Z+0+Expo\n+    ldd     TMP,    Z+1+Expo\n+    wmov    ZL,     XL\n+\n+    st      Z,      ZERO\n+\n+    asr     TMP\n+    ror     Carry\n+    std     Z+1+Expo,   TMP\n+    std     Z+0+Expo,   Carry\n+\n+    ;; Re-interpreting our Q-format 1.xx mantissa as Q2.yy, we have to shift\n+    ;; the mantissa to the right by 1.  As we need an even exponent, multiply\n+    ;; the mantissa by 2 for odd exponents, i.e. only right-shift if .expo\n+    ;; is even.\n+\n+    brcs 1f\n+    lsr     C6\n+    ror     C5\n+\n+1:\n+    F7call  sqrt16_round\n+\n+    ;; sqrt16_round() returns:   C = 0:  error in [0, -1/2 LSB).\n+    ;;                           C = 1:  error in [1/2 LSB, 0)\n+\n+    brcc 2f\n+    ;; Undo the round-up from sqrt16_round(); this will transform to\n+    ;; error in [-1/2 LSB, -1 LSB).\n+    sbiw    C5,     1\n+    ;; Together with the correct bit C4.7, the error is in  [0, -1/2 LSB).\n+    ori     C4,     1 << 7\n+\n+2:  ;; Setting C4.6 adds 1/4 LSB and the error is now in [1/4 LSB, -1/4 LSB)\n+    ;; in either case.\n+    ori     C4,     1 << 6\n+\n+    ;; ????????????\n+    ;; sqrt16_round() runs on integers which means that it computes the\n+    ;; square root of  mant * 2^14  if we regard  mant as Q-format 2.yy,\n+    ;; i.e. 2 integral bits.  The result is  sqrt(mant) * 2^7,\n+    ;; and in order to get the same scaling like the input, .expo has to\n+    ;; be adjusted by 7. ???????????????\n+\n+    ldi     Carry,  8\n+    F7call  normalize.store_with_flags\n+\n+    pop     r16\n+    pop     r17\n+    ret\n+\n+ENDF sqrt_approx\n+#endif /* F7MOD_sqrt_approx_ */\n+\n+\n+#undef CA\n+#undef C0\n+#undef C1\n+#undef C2\n+#undef C3\n+#undef C4\n+#undef C5\n+#undef C6\n+#undef Carry\n+\n+\n+#ifdef F7MOD_D_fabs_\n+_DEFUN __fabs\n+    DALIAS fabs\n+    LALIAS fabsl\n+    andi    R25,    0b01111111\n+    ret\n+_ENDF __fabs\n+#endif /* F7MOD_D_fabs_ */\n+\n+\n+#ifdef F7MOD_D_neg_\n+_DEFUN __neg\n+_LABEL __negdf2\n+    subi    R25,    0b10000000\n+    ret\n+_ENDF __neg\n+#endif /* F7MOD_D_neg_ */\n+\n+\n+#ifdef F7MOD_D_signbit_\n+_DEFUN __signbit\n+    DALIAS signbit\n+    LALIAS signbitl\n+    bst     R25,    7\n+    clr     R25\n+    clr     R24\n+    bld     R24,    0\n+    ret\n+_ENDF __signbit\n+#endif /* F7MOD_D_signbit_ */\n+\n+\n+#ifdef F7MOD_D_copysign_\n+_DEFUN __copysign\n+    DALIAS copysign\n+    LALIAS copysignl\n+    bst     R17,    7\n+    bld     R25,    7\n+    ret\n+_ENDF __copysign\n+#endif /* F7MOD_D_copysign_ */\n+\n+\n+#ifdef F7MOD_D_isinf_\n+_DEFUN __isinf\n+    DALIAS isinf\n+    LALIAS isinfl\n+    F7call  class_D\n+    ;; Inf: T = Z = 1.\n+    brtc 0f\n+    ldi     R24,    1\n+    breq 1f\n+0:\n+    clr     R24\n+1:\n+    clr     R25\n+    ret\n+_ENDF __isinf\n+#endif /* F7MOD_D_isinf_ */\n+\n+\n+#ifdef F7MOD_D_isnan_\n+_DEFUN __isnan\n+    DALIAS isnan\n+    LALIAS isnanl\n+    F7call  class_D\n+    ;; NaN: T = 1, Z = 0.\n+    brtc 0f\n+    ldi     R24,    1\n+    brne 1f\n+0:\n+    clr     R24\n+1:\n+    clr     R25\n+    ret\n+_ENDF __isnan\n+#endif /* F7MOD_D_isnan_ */\n+\n+\n+#ifdef F7MOD_D_isfinite_\n+_DEFUN __isfinite\n+    DALIAS isfinite\n+    LALIAS isfinitel\n+    F7call  class_D\n+    ;; Number <=> T = 0.\n+    bld     R24,    0\n+    com     R24\n+    andi    R24,    1\n+    clr     R25\n+    ret\n+_ENDF __isfinite\n+#endif /* F7MOD_D_isfinite_ */\n+\n+\n+#ifdef F7MOD_D_class_\n+;; The encoded exponent has 11 Bits.\n+#define MAX_BIASED_EXPO 0b0111111111110000\n+\n+;; Classify a double in R18[]\n+;; Number: T-Flag = 0.\n+;; +-Inf : T-Flag = 1, Z-Flag = 1.\n+;; NaN   : T-Flag = 1, Z-Flag = 0.\n+DEFUN class_D\n+    wmov    R26,    R24\n+    andi    R26,    lo8 (MAX_BIASED_EXPO)\n+    andi    R27,    hi8 (MAX_BIASED_EXPO)\n+    subi    R26,    lo8 (MAX_BIASED_EXPO)\n+    sbci    R27,    hi8 (MAX_BIASED_EXPO)\n+    clt\n+    brne .L.number\n+    set\n+    ;; Set sign and expo to 0.\n+    clr     R25\n+    andi    R24,    lo8 (~MAX_BIASED_EXPO)\n+    ;; What remains is the mantissa.\n+    ;; Mantissa == 0  =>  +/-Inf.\n+    ;; Mantissa != 0  =>  NaN.\n+    ;; Compare R18[] against sign_extend(R26) with R26 = 0.\n+    .global __cmpdi2_s8\n+    XJMP    __cmpdi2_s8\n+.L.number:\n+    ret\n+\n+ENDF class_D\n+#endif /* F7MOD_D_class_ */\n+\n+\n+#ifdef F7MOD_call_dd_\n+\n+;; Provide double wrappers for functions that operate on f7_t and get f7_t*.\n+;;\n+;; We set up a frame of sizeof(f7_t), convert the input double in R18[] to\n+;; f7_t in that frame location, then call *Z and finally convert the result f7_t\n+;; to double R18[] if that's requested.\n+;;\n+;; call_dd:     double func (double A)\n+;;              void (*Z) (f7_t *aa, const f7_t *aa)\n+;;\n+;; call_dx:     double func (type_t A)  , sizeof(type_t) <= 4\n+;;              void (*Z) (f7_t *aa, type_t)\n+;;\n+;; call_xd:     type_t func (double A)\n+;;              type_t (*Z) (const f7_t *aa)\n+;;\n+;; call_ddx:    double func (double A, word_t)  , sizeof (word_t) <= 2\n+;;              void (*Z) (f7_t *aa, const f7_t *aa, word_t)\n+\n+#define WHAT    R13\n+\n+DEFUN call_dd   ; WHAT = R13 = 3\n+    inc     ZERO\n+LABEL call_xd   ; WHAT = R13 = 2\n+    inc     ZERO\n+LABEL call_ddx  ; WHAT = R13 = 1\n+    inc     ZERO\n+LABEL call_dx   ; WHAT = R13 = 0\n+    push    WHAT\n+    mov     WHAT,   ZERO\n+    clr     ZERO\n+    ;; R14/R15 hold Z, the address of the f7_worker function, until we need it.\n+    push    r14\n+    push    r15\n+    wmov    r14,     Z\n+\n+#define n_pushed    4\n+#define n_frame     10\n+\n+    do_prologue_saves n_pushed, n_frame\n+    ;; Y = FramePointer + 1\n+    adiw    Y,      1\n+    dec     WHAT\n+    brmi .Ldx                   ; WHAT was initially 0.\n+    ;; FP + 1 = (f7_t) arg1\n+    wmov    r16,    Y\n+    ;; The double argument is in R18[].\n+    XCALL   F7_NAME (set_double_impl)\n+    tst     WHAT\n+    brne .Lno.ddx               ; WHAT was initially != 1.\n+    ;; call_ddx: Set R20/21 to the 2-byte scalar / pointer argument.\n+    ;; Fetch it from where prologue_saves put it.\n+    ldd     r20,    Y + n_frame + 3     ; Saved R16\n+    ldd     r21,    Y + n_frame + 2     ; Saved R17\n+.Lno.ddx:\n+    wmov    r22,    Y           ; &arg1 (input)\n+.Ldo.dx:\n+    wmov    r24,    Y           ; &arg1 (output)\n+    wmov    Z,      r14\n+    XICALL\n+    dec     WHAT\n+    breq .Lepilogue             ; WHAT was initially 2: Return non-double.\n+    wmov    r24,    Y           ; &arg1\n+    XCALL   F7_NAME (get_double)\n+.Lepilogue:\n+    ;; + 3 to account for R13...R15 pushed prior to do_prologue_saves.\n+    do_epilogue_restores n_pushed + 3, n_frame\n+\n+.Ldx:\n+    ;; call_dx: Copy the 4-byte input scalar from R22[4] to R20[4].\n+    wmov    r20,    r22\n+    wmov    r22,    r24\n+    rjmp .Ldo.dx\n+\n+ENDF call_dd\n+#endif /* F7MOD_call_dd_ */\n+\n+\n+#ifdef F7MOD_call_ddd_\n+\n+;; Provide double wrappers for functions that operate on f7_t and get f7_t*.\n+;;\n+;; We set up a frame of 2 * sizeof(f7_t), convert the input doubles in R18[]\n+;; and R10[] to f7_t in these frame locations, then call *Z and finally\n+;; convert the result f7_t to double R18[] if that's requested.\n+;;\n+;; call_ddd:    double func (double A, double B)\n+;;              void (*Z) (f7_t *aa, const f7_t *aa, const f7_t *bb)\n+;;\n+;; call_xdd:    type_t func (double A, double B)\n+;;              type_t (*Z) (const f7_t *aa, const f7_t *bb)\n+\n+DEFUN call_ddd\n+    inc     ZERO\n+LABEL call_xdd\n+    ;; R8/R9 hold Z, the address of the f7_worker function, until we need it.\n+    push    r9\n+    push    r8\n+    wmov    r8,     Z\n+    ;; This is an argument to call.2 and will be accessed by the arg pointer.\n+    push    ZERO\n+    clr     ZERO\n+    rcall   call.2\n+    pop     TMP\n+    pop     r8\n+    pop     r9\n+    ret\n+\n+#define n_pushed    4\n+#define n_frame     20\n+\n+call.2:\n+    do_prologue_saves n_pushed, n_frame\n+    ;; Y = FramePointer + 1\n+    adiw    Y,      1\n+    ;; FP + 1 = (f7_t) arg1\n+    wmov    r16,    Y\n+    ;; First double argument is already in R18[].\n+    XCALL   F7_NAME (set_double_impl)\n+    ;; FP + 11 = (f7_t) arg2\n+    wmov    r16,    Y\n+    subi    r16,    lo8 (-10)\n+    sbci    r17,    hi8 (-10)\n+    ;; Move second double argument to R18[].\n+    wmov    r18,    r10\n+    wmov    r20,    r12\n+    wmov    r22,    r14\n+    ;; Get high word of arg2 from where prologue_saves put it.\n+    ldd     r24,    Y + n_frame + 3     ; Saved R16\n+    ldd     r25,    Y + n_frame + 2     ; Saved R17\n+    XCALL   F7_NAME (set_double_impl)\n+    ;; Z (f7_t *arg1, const f7_t *arg1, const f7_t *arg2)\n+    wmov    Z,      r8\n+    wmov    r24,    Y                   ; &arg1\n+    ;; WHAT == 0  =>  call_xdd\n+    ;; WHAT != 0  =>  call_ddd\n+    ldd     TMP,    Y + n_frame + n_pushed + PC_SIZE\n+    tst     TMP\n+    breq .Lxdd\n+    wmov    r22,    Y                   ; &arg1\n+    wmov    r20,    r16                 ; &arg2\n+    XICALL\n+    wmov    r24,    Y                   ; &arg1\n+    XCALL   F7_NAME (get_double)\n+.Lepilogue:\n+    do_epilogue_restores n_pushed, n_frame\n+.Lxdd:\n+    wmov    r22,    r16                 ; &arg2\n+    XICALL\n+    rjmp .Lepilogue\n+ENDF call_ddd\n+#endif /* F7MOD_call_ddd_ */\n+\n+#include \"f7-wraps.h\"\n+\n+#endif /* !AVR_TINY */"}, {"sha": "0424cba95f1f824218b68dcaed5dd46ba6e1f13c", "filename": "libgcc/config/avr/libf7/libf7-c-object.mk", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-c-object.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-c-object.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-c-object.mk?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,20 @@\n+# This file is included several times in a row, once for each element of\n+# $(iter-items).  On each inclusion, we advance $o to the next element.\n+# $(iter-labels) is also advanced.\n+# This works similar to $(srcdir)/siditi-object.mk.\n+\n+o := $(firstword $(iter-items))\n+iter-items := $(filter-out $o,$(iter-items))\n+\n+$o-label := $(firstword $(iter-labels))\n+iter-labels := $(wordlist 2,$(words $(iter-labels)),$(iter-labels))\n+\n+f7_c_$o$(objext): f7_c_%$(objext): $(libf7)/libf7.c\n+\t$(gcc_compile) -DF7MOD_$($*-label)_ $(F7_C_FLAGS) \\\n+\t\t-c $<\n+\n+ifeq ($(enable_shared),yes)\n+f7_c_$(o)_s$(objext): %_s$(objext): $(libf7)/libf7.c\n+\t$(gcc_s_compile) -DF7MOD_$($*-label)_ $(F7_C_FLAGS) \\\n+\t\t-c $<\n+endif"}, {"sha": "28663b52e6c87070a3e6d76b8c323161d51b4b17", "filename": "libgcc/config/avr/libf7/libf7-common.mk", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-common.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-common.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-common.mk?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,102 @@\n+# f7_c_*.o modules from libf7.c.\n+F7_C_PARTS += set_s16 set_u16 set_s32 set_u32 init\n+F7_C_PARTS += get_s16 get_u16 get_s32 get_u32 get_s64 get_u64\n+F7_C_PARTS += lrint ldexp frexp madd_msub madd msub hypot\n+F7_C_PARTS += addsub add sub mulx mul square divx div div1 fmod sqrt cbrt\n+F7_C_PARTS += Ineg Iadd Isub Imul Idiv IRsub Isquare Ildexp Isqrt\n+F7_C_PARTS += set_float get_float get_double set_double set_pdouble\n+F7_C_PARTS += fabs neg fmin fmax minmax truncx trunc floor ceil round lround\n+F7_C_PARTS += horner logx log log10 log2 exp pow10 pow powi\n+F7_C_PARTS += sin cos tan cotan sincos sinh cosh tanh sinhcosh\n+F7_C_PARTS += asinacos asin acos atan atan2\n+F7_C_PARTS += abscmp_msb_ge cmp cmp_abs cmp_unordered\n+\n+F7_C_PARTS += const_1 const_1_2 const_1_3\n+F7_C_PARTS += const_pi const_ln2 const_1_ln2 const_ln10 const_1_ln10 const_sqrt2\n+F7_C_PARTS += # const_m1 const_2 const_sqrt2\n+\n+# f7_asm_*.o modules from libf7-asm.sx.\n+F7_ASM_PARTS += classify clr mul_mant cmp_mant set_u64\n+F7_ASM_PARTS += copy copy_P copy_mant clr_mant_lsbs\n+F7_ASM_PARTS += addsub_mant_scaled store load\n+F7_ASM_PARTS += to_integer to_unsigned clz normalize_with_carry normalize\n+F7_ASM_PARTS += store_expo sqrt16 sqrt_approx div\n+\n+F7_ASM_PARTS += D_class\n+F7_ASM_PARTS += D_isnan D_isinf D_isfinite D_signbit D_copysign D_neg D_fabs\n+\n+F7_ASM_PARTS += call_dd call_ddd\n+\n+# Stuff that will be wrapped in f7-wraps.h (included by libf7-asm.sx)\n+# and give f7_asm_D_*.o modules.\n+g_ddd += add sub mul div\n+g_xdd_cmp += le lt ge gt ne eq unord\n+g_dx += floatunsidf floatsidf extendsfdf2\n+g_xd += fixdfsi fixdfdi fixunsdfdi fixunsdfsi truncdfsf2\n+\n+m_ddd += pow fmin fmax fmod hypot atan2\n+m_ddx += ldexp frexp\n+m_dd += sqrt cbrt exp exp10 pow10 log log10 log2 sin cos tan cotan asin acos atan\n+m_dd += ceil floor trunc round sinh cosh tanh\n+m_xd += lrint lround\n+\n+# -mcall-prologues\n+CALL_PROLOGUES += divx sqrt cbrt get_double set_double logx exp exp10 pow10\n+CALL_PROLOGUES += put_C truncx round minmax sincos tan cotan pow powi fmod\n+CALL_PROLOGUES += atan asinacos madd_msub hypot init horner sinhcosh tanh\n+\n+# -mstrict-X\n+STRICT_X += log addsub truncx ldexp exp\n+\n+# Renames used when building f7-renames.h.\n+F7F += fabs neg add sub addsub div div1 divx fmod sqrt cbrt\n+F7F += square mul mulx madd_msub madd msub hypot\n+F7F += Ineg Iadd Isub Imul Idiv IRsub Isquare Ildexp Isqrt\n+F7F += le lt gt ge ne eq cmp cmp_abs ordered unordered cmp_unordered\n+F7F += lt_impl gt_impl le_impl ge_impl eq_impl ne_impl unord_impl\n+\n+F7F += lrint ldexp frexp exp logx log log10 log2\n+F7F += minmax fmax fmin floor ceil round lround trunc truncx\n+F7F += horner pow10 exp10 pow powi\n+F7F += sin cos tan cotan sincos sinh cosh tanh sinhcosh\n+F7F += asinacos asin acos atan atan2\n+F7F += mul_noround sqrt16_round sqrt16_floor\n+F7F += clr_mant_lsbs abscmp_msb_ge lshrdi3 ashldi3\n+F7F += assert\n+\n+F7F += classify\n+\n+F7F += class_inf class_nan class_number class_zero class_nonzero class_sign\n+F7F += signbit set_sign set_nan set_inf\n+F7F += is_inf is_nan is_number is_zero is_nonzero\n+F7F += clr copy copy_P copy_mant msbit is0 cmp_mant store_expo\n+F7F += abs\n+\n+F7F += set_s64 set_s32 set_s16 set_s16_impl set_u16_worker\n+F7F += set_u64 set_u32 set_u16 set_u16_impl\n+F7F += set_float set_pdouble set_double_impl set_double init_impl init\n+F7F += get_s16 get_s32 get_s64 get_float\n+F7F += get_u16 get_u32 get_u64 get_double\n+\n+F7F += set_eps set_1pow2\n+\n+# Renames for ALIASes without own module.\n+F7F += min max exp10\n+F7F += floatunsidf floatsidf extendsfdf2\n+F7F += fixdfsi fixdfdi fixunsdfdi fixunsdfsi truncdfsf2\n+\n+# Renames for f7-const.def.\n+F7F_cst += 1 2 1_2 1_3 m1 pi ln2 ln10 1_ln2 1_ln10 sqrt2\n+\n+F7F_asm += classify\n+F7F_asm += store_expo clr copy copy_P copy_mant\n+F7F_asm += cmp_mant normalize store_expo\n+F7F_asm += set_u64 set_s64 addsub_mant_scaled mul_mant\n+F7F_asm += to_integer to_unsigned clr_mant_lsbs\n+F7F_asm += div sqrt_approx sqrt16_round sqrt16_floor\n+F7F_asm += lshrdi3 ashldi3\n+\n+F7F_asm += class_D\n+\n+F7F_asm += call_ddd call_xdd call_ddx\n+F7F_asm += call_dd  call_xd  call_dx"}, {"sha": "ff07cdbf7251c74f6f6ceb6a0ec08c36cb3310ec", "filename": "libgcc/config/avr/libf7/libf7-const.def", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-const.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-const.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-const.def?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,201 @@\n+/* Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of LIBF7, which is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef ONLY_CONST_WITH_ID\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_1_2_)\n+F7_CONST_DEF (1_2,  0,  0x80,0,0,0,0,0,0,   -1)\n+#endif /* 1/2 */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_1_)\n+F7_CONST_DEF (1,    0,  0x80,0,0,0,0,0,0,   0)\n+#endif /* 1 */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_2_)\n+F7_CONST_DEF (2,    0,  0x80,0,0,0,0,0,0,   1)\n+#endif /* 2 */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_1_3_)\n+F7_CONST_DEF (1_3,  0,  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xab, -2)\n+#endif /* 1/3 */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_1_ln2_)\n+F7_CONST_DEF (1_ln2,  0,  0xb8,0xaa,0x3b,0x29,0x5c,0x17,0xf1, 0)\n+#endif /* 1 / ln2 */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_1_ln10_)\n+F7_CONST_DEF (1_ln10,  0,  0xde,0x5b,0xd8,0xa9,0x37,0x28,0x72, -2)\n+#endif /* 1 / ln10 */\n+#endif /* const with ID */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_m1_)\n+F7_CONST_DEF (m1,   1,  0x80,0,0,0,0,0,0,   0)\n+#endif /* -1 */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_pi_)\n+F7_CONST_DEF (pi,   0,  0xc9,0x0f,0xda,0xa2,0x21,0x68,0xc2, 1)\n+#endif /* pi */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_ln2_)\n+F7_CONST_DEF (ln2,  0,  0xb1,0x72,0x17,0xf7,0xd1,0xcf,0x7a, -1)\n+#endif /* ln2 */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_ln10_)\n+F7_CONST_DEF (ln10,  0,  0x93,0x5d,0x8d,0xdd,0xaa,0xa8,0xac, 1)\n+#endif /* ln10 */\n+\n+#if defined IN_LIBF7_H || defined (F7MOD_const_) || defined (F7MOD_const_sqrt2_)\n+F7_CONST_DEF (sqrt2,    0,  0xb5,0x04,0xf3,0x33,0xf9,0xde,0x65, 0)\n+#endif /* sqrt2 */\n+\n+#if !defined (IN_LIBF7_H) && !defined (F7MOD_const_)\n+\n+#if defined (F7MOD_logx_)\n+// 2.00000000000000000287938058543222037939 + 0.666666666666667653654896829047862109605x + 0.399999999996639180070480580779767357622x^2 + 0.285714286985476106491309914245597720749x^3 + 0.222222024077476110197597399876978069272x^4 + 0.181833876328594532366358057253631240618x^5 + 0.153181571233880298729095145342556944283x^6 + 0.147580071554569676223389696418304199218x^7\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 1)\n+F7_CONST_DEF (X, 0, 0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xf2, -1)\n+F7_CONST_DEF (X, 0, 0xcc,0xcc,0xcc,0xcc,0xc5,0x68,0xd4, -2)\n+F7_CONST_DEF (X, 0, 0x92,0x49,0x24,0x9d,0x34,0x85,0x25, -2)\n+F7_CONST_DEF (X, 0, 0xe3,0x8e,0x2b,0x97,0x74,0x69,0xb3, -3)\n+F7_CONST_DEF (X, 0, 0xba,0x32,0xa8,0xe0,0x8b,0x7d,0xcc, -3)\n+F7_CONST_DEF (X, 0, 0x9c,0xdb,0xa1,0x3b,0x32,0x98,0x9a, -3)\n+F7_CONST_DEF (X, 0, 0x97,0x1f,0x3a,0xf3,0x79,0x0d,0xc8, -3)\n+\n+#elif defined (F7MOD_exp_)\n+#ifdef ARRAY_NAME\n+// Intended for |X| < ln2 / 8\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 0)\n+// f(x) = (e^x - 1) / x  and  f -> 1 + x*f  by means of const_1 above.\n+// 0.99999999999999993104781692731238623644199 + 0.50000000000000018681311888335564572558345x + 0.16666666666696003026683736262180526042594x^2 + 0.041666666666489887893617892155331720764329x^3 + 0.0083333331383434741356242595738508060753717x^4 + 0.0013888889242082668539796357369837122917246x^5 + 0.00019845416752769938401628433087258224774248x^6 + 0.000024801569801689274979195020335136136418918x^7\n+F7_CONST_DEF (X, 0, 0xff,0xff,0xff,0xff,0xff,0xff,0xfb, -1)\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x0d, -1)\n+F7_CONST_DEF (X, 0, 0xaa,0xaa,0xaa,0xaa,0xab,0xf4,0xf7, -3)\n+F7_CONST_DEF (X, 0, 0xaa,0xaa,0xaa,0xaa,0xa7,0x8e,0x87, -5)\n+F7_CONST_DEF (X, 0, 0x88,0x88,0x88,0x52,0xef,0x57,0x81, -7)\n+F7_CONST_DEF (X, 0, 0xb6,0x0b,0x61,0x03,0xb6,0x6b,0x82, -10)\n+F7_CONST_DEF (X, 0, 0xd0,0x18,0x22,0x8c,0x6f,0xde,0x72, -13)\n+F7_CONST_DEF (X, 0, 0xd0,0x0c,0xf7,0x31,0x28,0xba,0xb5, -16)\n+#else\n+// Negative because f7_const_ln2 is ln2 rounded up.\n+F7_CONST_DEF (ln2_low, 1,\t0xa8,0x6c,0x38,0x98,0xcf,0xf8,0x1a, -58)\n+#endif\n+\n+#elif defined (F7MOD_atan_)\n+\n+#if defined (MINIMAX_6_6_IN_0_1)\n+// https://www.mikrocontroller.net/topic/480840#6003520\n+#if defined (FOR_NUMERATOR)\n+// 1209.7470017580907217240715 + 3031.0745956115083044212807x + 2761.7198246138834959053784x^2 + 1114.1290728455183546172942x^3 + 192.5792014481559613474286x^4 + 11.3221594116764655236245x^5 + 0.09762721591717633036983x^6\n+// p = Poly ([Decimal('1209.7470017580907217240715'), Decimal('3031.0745956115083044212807'), Decimal('2761.7198246138834959053784'), Decimal('1114.1290728455183546172942'), Decimal('192.5792014481559613474286'), Decimal('11.3221594116764655236245'), Decimal('0.09762721591717633036983')])\n+F7_CONST_DEF (X, 0, 0x97,0x37,0xe7,0x70,0x3b,0x21,0xbc, 10)\n+F7_CONST_DEF (X, 0, 0xbd,0x71,0x31,0x8b,0x2a,0xfd,0xa7, 11)\n+F7_CONST_DEF (X, 0, 0xac,0x9b,0x84,0x66,0xd0,0x77,0xc4, 11)\n+F7_CONST_DEF (X, 0, 0x8b,0x44,0x21,0x5d,0x60,0x49,0xb2, 10)\n+F7_CONST_DEF (X, 0, 0xc0,0x94,0x46,0x8b,0xcd,0xa0,0x2d, 7)\n+F7_CONST_DEF (X, 0, 0xb5,0x27,0x90,0xa0,0x93,0xfb,0xfc, 3)\n+F7_CONST_DEF (X, 0, 0xc7,0xf0,0xc7,0x1c,0x82,0xab,0x23, -4)\n+#elif defined (FOR_DENOMINATOR)\n+// 1209.7470017580907287514197 + 3434.3235961975351716547069x + 3664.5449563283749893504796x^2 + 1821.6003392918464941509225x^3 + 423.0716464809047804524206x^4 + 39.9178842486537981501999x^5 + x^6\n+// q = Poly ([Decimal('1209.7470017580907287514197'), Decimal('3434.3235961975351716547069'), Decimal('3664.5449563283749893504796'), Decimal('1821.6003392918464941509225'), Decimal('423.0716464809047804524206'), Decimal('39.9178842486537981501999'), Decimal('1.0')])\n+F7_CONST_DEF (X, 0, 0x97,0x37,0xe7,0x70,0x3b,0x21,0xbc, 10)\n+F7_CONST_DEF (X, 0, 0xd6,0xa5,0x2d,0x73,0x34,0xd8,0x60, 11)\n+F7_CONST_DEF (X, 0, 0xe5,0x08,0xb8,0x24,0x20,0x81,0xe7, 11)\n+F7_CONST_DEF (X, 0, 0xe3,0xb3,0x35,0xfa,0xbf,0x1f,0x81, 10)\n+F7_CONST_DEF (X, 0, 0xd3,0x89,0x2b,0xb6,0x3e,0x2e,0x05, 8)\n+F7_CONST_DEF (X, 0, 0x9f,0xab,0xe9,0xd9,0x35,0xed,0x27, 5)\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 0)\n+#endif\n+\n+#elif defined (SWIFT_3_4)\n+// My [3,4] MiniMax\n+#if defined (FOR_NUMERATOR)\n+// 0.999999999999999998080178351225003952632 + 1.51597040589722809277543885223133087789x + 0.636928974763539784860899545005247736093x^2 + 0.0638944455799886571709448345524306512048x^3\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 0)\n+F7_CONST_DEF (X, 0, 0xc2,0x0b,0x51,0x79,0x84,0x27,0x00, 0)\n+F7_CONST_DEF (X, 0, 0xa3,0x0d,0xc6,0xfc,0x7b,0xf5,0x5d, -1)\n+F7_CONST_DEF (X, 0, 0x82,0xdb,0x17,0x51,0x4b,0xfc,0xad, -4)\n+#elif defined (FOR_DENOMINATOR)\n+// 1 + 1.84930373923056200945453682584178320362x + 1.05336355450697082895016644607427716580x^2 + 0.188012025422931152047197803304030906006x^3 + 0.00507310235929401206762490897042543192106x^4\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 0)\n+F7_CONST_DEF (X, 0, 0xec,0xb5,0xfc,0x24,0x2e,0xd1,0xc0, 0)\n+F7_CONST_DEF (X, 0, 0x86,0xd4,0x9d,0xf0,0xb3,0xef,0xb8, 0)\n+F7_CONST_DEF (X, 0, 0xc0,0x86,0x39,0x71,0xc8,0xeb,0x3d, -3)\n+F7_CONST_DEF (X, 0, 0xa6,0x3c,0x44,0x5c,0x78,0x87,0x2d, -8)\n+#else\n+F7_CONST_DEF (1_sqrt3,  0,  0x93,0xCD,0x3A,0x2C,0x81,0x98,0xE2, -1)\n+F7_CONST_DEF (pi_6, 0,  0x86,0x0a,0x91,0xc1,0x6b,0x9b,0x2c, -1)\n+#endif\n+#endif // which MiniMax\n+\n+#elif defined (F7MOD_asinacos_)\n+// Relative error < 5.6E-18, quality = 1.00000037 (ideal = 1).\n+#if defined (FOR_NUMERATOR)\n+// 0.99999999999999999442491073135027586203 - 1.035234033892197627842731209x + 0.35290206232981519813422591897720574012x^2 - 0.04333483170641685705612351801x^3 + 0.0012557428614630796315205218507940285622x^4 + 0.0000084705471128435769021718764878041684288x^5\n+// p = Poly ([Decimal('0.99999999999999999442491073135027586203'), Decimal('-1.0352340338921976278427312087167692142'), Decimal('0.35290206232981519813422591897720574012'), Decimal('-0.043334831706416857056123518013656946650'), Decimal('0.0012557428614630796315205218507940285622'), Decimal('0.0000084705471128435769021718764878041684288')])\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 0)\n+F7_CONST_DEF (X, 1, 0x84,0x82,0x8c,0x7f,0xa2,0xf6,0x65, 0)\n+F7_CONST_DEF (X, 0, 0xb4,0xaf,0x94,0x40,0xcb,0x86,0x69, -2)\n+F7_CONST_DEF (X, 1, 0xb1,0x7f,0xdd,0x4f,0x4e,0xbe,0x1d, -5)\n+F7_CONST_DEF (X, 0, 0xa4,0x97,0xbd,0x0b,0x59,0xc9,0x25, -10)\n+F7_CONST_DEF (X, 0, 0x8e,0x1c,0xb9,0x0b,0x50,0x6c,0xce, -17)\n+#elif defined (FOR_DENOMINATOR)\n+// 1 - 1.118567367225532923662371649x + 0.42736600959872448854098334016758333519x^2 - 0.06355588484963171659942148390x^3 + 0.0028820878185134035637440105959294542908x^4\n+// q = Poly ([Decimal('1'), Decimal('-1.1185673672255329236623716486696411533'), Decimal('0.42736600959872448854098334016758333519'), Decimal('-0.063555884849631716599421483898013782858'), Decimal('0.0028820878185134035637440105959294542908')])\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 0)\n+F7_CONST_DEF (X, 1, 0x8f,0x2d,0x37,0x2a,0x4d,0xa1,0x57, 0)\n+F7_CONST_DEF (X, 0, 0xda,0xcf,0xb7,0xb5,0x4c,0x0d,0xee, -2)\n+F7_CONST_DEF (X, 1, 0x82,0x29,0x96,0x77,0x2e,0x19,0xc7, -4)\n+F7_CONST_DEF (X, 0, 0xbc,0xe1,0x68,0xec,0xba,0x20,0x29, -9)\n+#endif\n+\n+#elif defined (F7MOD_sincos_)\n+#if defined (FOR_SIN)\n+// sin(sqrt(x)) / sqrt(x)  in  [0, pi^2/16] ~ [0, 0.6169].\n+// Error < 3.313E-18, quality@quot ~ 1.\n+// p = Poly ([Decimal('0.9999999999999999966879566228039012'), Decimal('-0.1666666666666661475365354492822562'), Decimal('0.008333333333320002444252560522892007'), Decimal('-0.0001984126982840212992698250499618594'), Decimal('0.000002755731329901509333692668814721451'), Decimal('-2.505070584638448064973439248538648E-8'), Decimal('1.589413637225924008237178592214358E-10')])\n+// 0.9999999999999999966879566228039012 - 0.1666666666666661475365354492822562x + 0.008333333333320002444252560522892007x^2 - 0.0001984126982840212992698250499618594x^3 + 0.000002755731329901509333692668814721451x^4 - 2.505070584638448064973439248538648E-8x^5 + 1.589413637225924008237178592214358E-10x^6\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 0)\n+F7_CONST_DEF (X, 1, 0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x15, -3)\n+F7_CONST_DEF (X, 0, 0x88,0x88,0x88,0x88,0x87,0x98,0x63, -7)\n+F7_CONST_DEF (X, 1, 0xd0,0x0d,0x00,0xcd,0xc9,0x7e,0x34, -13)\n+F7_CONST_DEF (X, 0, 0xb8,0xef,0x1a,0x8f,0x9e,0x91,0xa2, -19)\n+F7_CONST_DEF (X, 1, 0xd7,0x2f,0x15,0xb0,0x7c,0x11,0x7a, -26)\n+F7_CONST_DEF (X, 0, 0xae,0xc2,0x04,0x43,0x51,0x29,0xe8, -33)\n+#elif defined (FOR_COS)\n+// cos(sqrt(x))  in  [0, pi^2/16] ~ [0, 0.6169].\n+// Error < 3.6E-20, quality@quot ~ 1.\n+// p = Poly ([Decimal('0.999999999999999999964159204335255989833'), Decimal('-0.499999999999999992843598630174036090975'), Decimal('0.0416666666666664302574165741342831192783'), Decimal('-0.00138888888888589604372397206213200172560'), Decimal('0.0000248015872828994642415389301648196400167'), Decimal('-2.75573128656963697259081300852869272237E-7'), Decimal('2.08755551457127352241183195408105664857E-9'), Decimal('-1.13521232075810109334454849167561526185E-11')])\n+// 0.999999999999999999964159204335255989833 - 0.499999999999999992843598630174036090975x + 0.0416666666666664302574165741342831192783x^2 - 0.00138888888888589604372397206213200172560x^3 + 0.0000248015872828994642415389301648196400167x^4 - 2.75573128656963697259081300852869272237E-7x^5 + 2.08755551457127352241183195408105664857E-9x^6 - 1.13521232075810109334454849167561526185E-11x^7\n+F7_CONST_DEF (X, 0, 0x80,0x00,0x00,0x00,0x00,0x00,0x00, 0)\n+F7_CONST_DEF (X, 1, 0xff,0xff,0xff,0xff,0xff,0xff,0xff, -2)\n+F7_CONST_DEF (X, 0, 0xaa,0xaa,0xaa,0xaa,0xaa,0xa9,0x9a, -5)\n+F7_CONST_DEF (X, 1, 0xb6,0x0b,0x60,0xb6,0x09,0xb1,0x66, -10)\n+F7_CONST_DEF (X, 0, 0xd0,0x0d,0x00,0xcd,0x6b,0xb3,0xf0, -16)\n+F7_CONST_DEF (X, 1, 0x93,0xf2,0x7b,0x7f,0x10,0xce,0x3d, -22)\n+F7_CONST_DEF (X, 0, 0x8f,0x74,0xaa,0x3c,0xcf,0x51,0x3d, -29)\n+F7_CONST_DEF (X, 1, 0xc7,0xb5,0x6a,0xf8,0x0e,0x32,0x07, -37)\n+#else\n+F7_CONST_DEF (pi_low,0, 0xd3,0x13,0x19,0x8a,0x2e,0x03,0x70, 1 - F7_MANT_BITS-2)\n+#endif\n+\n+#endif\n+#endif /* ! IN_LIBF7_H && ! F7MOD_const_ */"}, {"sha": "8419f3b8740ee478a301bbf098bd3cbbb46af43c", "filename": "libgcc/config/avr/libf7/libf7-constdef.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-constdef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-constdef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7-constdef.h?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of LIBF7, which is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#if !defined STATIC\n+#define STATIC /* empty */\n+#endif\n+\n+#if USE_LPM\n+#define F7_CONST_DEF(NAME, FLAGS, M6, M5, M4, M3, M2, M1, M0, EXPO) \\\n+  STATIC const __attribute__((__progmem__))\t\t\t    \\\n+  f7_t F7_(const_ ## NAME ## _P) =\t\t\t\t    \\\n+  { .flags = FLAGS, .mant = { M0, M1, M2, M3, M4, M5, M6 }, .expo = EXPO };\n+  #include \"libf7-const.def\"\n+#undef F7_CONST_DEF\n+#else\n+#define F7_CONST_DEF(NAME, FLAGS, M6, M5, M4, M3, M2, M1, M0, EXPO) \\\n+  STATIC const f7_t F7_(const_ ## NAME) =\t\t\t    \\\n+  { .flags = FLAGS, .mant = { M0, M1, M2, M3, M4, M5, M6 }, .expo = EXPO };\n+  #include \"libf7-const.def\"\n+#undef F7_CONST_DEF\n+#endif // USE_LPM\n+\n+#undef STATIC"}, {"sha": "d1e3348c2e2207ac0c972fcca7f155cc20f8e9d2", "filename": "libgcc/config/avr/libf7/libf7.c", "status": "added", "additions": 2501, "deletions": 0, "changes": 2501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7.c?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,2501 @@\n+/* Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of LIBF7, which is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libf7.h\"\n+\n+#ifndef __AVR_TINY__\n+\n+#define ALIAS(X, Y) \\\n+  F7_WEAK __attribute__((__alias__(F7_STRINGY(X)))) __typeof__(X) Y;\n+\n+#define DALIAS(...) // empty\n+#define LALIAS(...) // empty\n+\n+#ifndef IN_LIBGCC2\n+\n+#include <stdio.h>\n+#include <assert.h>\n+\n+#define in_libgcc false\n+\n+_Static_assert (sizeof (f7_t) == 10 && F7_MANT_BYTES == 7,\n+\t\t\"libf7 will only work with 7-byte mantissa.\");\n+#else\n+\n+#define in_libgcc true\n+\n+#if __SIZEOF_DOUBLE__ == 8\n+#undef  DALIAS\n+#define DALIAS(X,Y) \\\n+  F7_WEAK __attribute__((__alias__(F7_STRINGY(X)))) __typeof__(X) Y;\n+#endif\n+\n+#if __SIZEOF_LONG_DOUBLE__ == 8\n+#undef  LALIAS\n+#define LALIAS(X,Y) \\\n+  F7_WEAK __attribute__((__alias__(F7_STRINGY(X)))) __typeof__(X) Y;\n+#endif\n+\n+#endif // in libgcc\n+\n+static F7_INLINE\n+void f7_assert (bool x)\n+{\n+  if (!in_libgcc && !x)\n+    __builtin_abort();\n+}\n+\n+static F7_INLINE\n+int16_t abs_ssat16 (int16_t a)\n+{\n+  _Sat _Fract sa = __builtin_avr_rbits (a);\n+  return __builtin_avr_bitsr (__builtin_avr_absr (sa));\n+}\n+\n+static F7_INLINE\n+int16_t add_ssat16 (int16_t a, int16_t b)\n+{\n+  _Sat _Fract sa = __builtin_avr_rbits (a);\n+  _Sat _Fract sb = __builtin_avr_rbits (b);\n+  return __builtin_avr_bitsr (sa + sb);\n+}\n+\n+static F7_INLINE\n+int16_t sub_ssat16 (int16_t a, int16_t b)\n+{\n+  _Sat _Fract sa = __builtin_avr_rbits (a);\n+  _Sat _Fract sb = __builtin_avr_rbits (b);\n+  return __builtin_avr_bitsr (sa - sb);\n+}\n+\n+static F7_INLINE\n+int8_t ssat8_range (int16_t a, int8_t range)\n+{\n+  if (a >= range)\n+    return range;\n+  if (a <= -range)\n+    return -range;\n+  return a;\n+}\n+\n+\n+#define IN_LIBF7_H\n+  #define F7_CONST_DEF(NAME, FLAGS, M6, M5, M4, M3, M2, M1, M0, EXPO) \\\n+    F7_UNUSED static const uint8_t F7_(const_##NAME##_msb)  = M6;     \\\n+    F7_UNUSED static const int16_t F7_(const_##NAME##_expo) = EXPO;\n+  #include \"libf7-const.def\"\n+  #undef F7_CONST_DEF\n+#undef IN_LIBF7_H\n+\n+\n+/*\n+  libgcc naming converntions for conversions:\n+\n+   __float<fmode><fmode>  : Convert float modes.\n+   __floatun<imode><fmode>: Convert unsigned integral to float.\n+   __fix<fmode><imode>    : Convert float to signed integral.\n+   __fixuns<fmode><imode> : Convert float to unsigned integral.\n+*/\n+\n+\n+#ifdef F7MOD_floatundidf_\n+F7_WEAK\n+f7_double_t __floatundidf (uint64_t x)\n+{\n+  f7_t xx;\n+  f7_set_u64 (&xx, x);\n+  return f7_get_double (&xx);\n+}\n+#endif // F7MOD_floatundidf_\n+\n+\n+#ifdef F7MOD_floatdidf_\n+F7_WEAK\n+f7_double_t __floatdidf (int64_t x)\n+{\n+  f7_t xx;\n+  f7_set_s64 (&xx, x);\n+  return f7_get_double (&xx);\n+}\n+#endif // F7MOD_floatdidf_\n+\n+\n+#ifdef F7MOD_init_\n+f7_t* f7_init_impl (uint64_t mant, uint8_t flags, f7_t *cc, int16_t expo)\n+{\n+  flags &= F7_FLAGS;\n+  if (f7_class_number (flags))\n+    {\n+      uint8_t msb;\n+      while ((__builtin_memcpy (&msb, (uint8_t*) &mant + 7, 1), msb))\n+\t{\n+\t  mant >>= 1;\n+\t  expo = add_ssat16 (expo, 1);\n+\t}\n+      *(uint64_t*) cc->mant = mant;\n+      cc->expo = add_ssat16 (expo, F7_MANT_BITS-1);\n+\n+      cc = f7_normalize_asm (cc);\n+    }\n+\n+  cc->flags = flags;\n+\n+  return cc;\n+}\n+#endif // F7MOD_init_\n+\n+\n+#ifdef F7MOD_set_s16_\n+f7_t* f7_set_s16_impl (f7_t *cc, int16_t i16)\n+{\n+  uint16_t u16 = (uint16_t) i16;\n+  uint8_t flags = 0;\n+  if (i16 < 0)\n+    {\n+      u16 = -u16;\n+      flags = F7_FLAG_sign;\n+    }\n+  f7_set_u16_impl (cc, u16);\n+  cc->flags = flags;\n+  return cc;\n+}\n+#endif // F7MOD_set_s16_\n+\n+\n+#ifdef F7MOD_set_u16_\n+f7_t* f7_set_u16_impl (f7_t *cc, uint16_t u16)\n+{\n+  f7_clr (cc);\n+  F7_MANT_HI2 (cc) = u16;\n+  cc->expo = 15;\n+  return f7_normalize_asm (cc);\n+}\n+#endif // F7MOD_set_u16_\n+\n+\n+#ifdef F7MOD_set_s32_\n+f7_t* f7_set_s32 (f7_t *cc, int32_t i32)\n+{\n+  uint32_t u32 = (uint32_t) i32;\n+  uint8_t flags = 0;\n+  if (i32 < 0)\n+    {\n+      u32 = -u32;\n+      flags = F7_FLAG_sign;\n+    }\n+  cc = f7_set_u32 (cc, u32);\n+  cc->flags = flags;\n+  return cc;\n+}\n+ALIAS (f7_set_s32, f7_floatsidf)\n+#endif // F7MOD_set_s32_\n+\n+\n+#ifdef F7MOD_set_u32_\n+f7_t* f7_set_u32 (f7_t *cc, uint32_t u32)\n+{\n+  f7_clr (cc);\n+  F7_MANT_HI4 (cc) = u32;\n+  cc->expo = 31;\n+  return f7_normalize_asm (cc);\n+}\n+ALIAS (f7_set_u32, f7_floatunsidf)\n+#endif // F7MOD_set_u32_\n+\n+\n+// IEEE 754 single\n+// float =  s  bbbbbbbb mmmmmmmmmmmmmmmmmmmmmmm\n+//\t   31\n+// s = sign\n+// b = biased exponent, bias = 127\n+// m = mantissa\n+\n+// +0\t      =\t 0 0 0\n+// -0\t      =\t 1 0 0\n+// Inf\t      =\t S B 0\t=  S * Inf, B = 0xff\n+// NaN\t      =\t S B M,\t   B = 0xff, M != 0\n+// Sub-normal =\t S 0 M\t=  S * 0.M * 2^{1 - bias}, M != 0\n+// Normal     =  S B M  =  S * 1.M * 2^{B - bias}, B = 1 ... 0xfe\n+\n+#define FLT_DIG_EXP   8\n+#define FLT_DIG_MANT  (31 - FLT_DIG_EXP)\n+#define FLT_MAX_EXP   ((1 << FLT_DIG_EXP) - 1)\n+#define FLT_EXP_BIAS  (FLT_MAX_EXP >> 1)\n+\n+#ifdef F7MOD_set_float_\n+F7_WEAK\n+void f7_set_float (f7_t *cc, float f)\n+{\n+  uint32_t val32;\n+\n+  _Static_assert (__SIZEOF_FLOAT__ == 4, \"\");\n+  _Static_assert (__FLT_MANT_DIG__ == 24, \"\");\n+  __builtin_memcpy (&val32, &f, __SIZEOF_FLOAT__);\n+\n+  uint16_t val16 = val32 >> 16;\n+  val16 >>= FLT_DIG_MANT - 16;\n+\n+  uint8_t expo_biased = val16 & FLT_MAX_EXP;\n+  bool sign = val16 & (1u << FLT_DIG_EXP);\n+\n+  f7_clr (cc);\n+\n+  uint32_t mant = val32 & ((1ul << FLT_DIG_MANT) -1);\n+\n+  if (mant == 0)\n+    {\n+      if (expo_biased == 0)\n+\treturn;\n+      if (expo_biased >= FLT_MAX_EXP)\n+\treturn f7_set_inf (cc, sign);\n+    }\n+\n+  if (expo_biased == 0)\n+    expo_biased = 1;   // Sub-normal: biased expo of 1 was encoded as 0.\n+  else if (expo_biased < FLT_MAX_EXP)\n+    mant |= (1ul << FLT_DIG_MANT);\n+  else\n+    return f7_set_nan (cc);\n+\n+  __builtin_memcpy (& F7_MANT_HI4 (cc), &mant, 4);\n+\n+  cc->expo = expo_biased - FLT_EXP_BIAS + 31 - FLT_DIG_MANT;\n+  f7_normalize_asm (cc);\n+  f7_set_sign (cc, sign);\n+}\n+ALIAS (f7_set_float, f7_extendsfdf2)\n+#endif // F7MOD_set_float_\n+\n+\n+#ifdef F7MOD_get_float_\n+static F7_INLINE\n+float make_float (uint32_t x)\n+{\n+  float ff;\n+  __builtin_memcpy (&ff, &x, 4);\n+  return ff;\n+\n+}\n+\n+F7_WEAK\n+float f7_get_float (const f7_t *aa)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  if (f7_class_nan (a_class))\n+    return make_float (0xffc00000 /* NaN: Biased expo = 0xff, mant != 0 */);\n+\n+  uint32_t mant;\n+  __builtin_memcpy (&mant, &F7_MANT_CONST_HI4 (aa), 4);\n+\n+  uint8_t expo8 = 0;\n+  uint8_t mant_offset = FLT_DIG_EXP;\n+  int16_t c_expo = add_ssat16 (aa->expo, FLT_EXP_BIAS);\n+\n+  if (f7_class_zero (a_class) || c_expo <= -FLT_DIG_MANT)\n+    {\n+      // Zero or tiny.\n+      return 0.0f;\n+    }\n+  else if (c_expo >= FLT_MAX_EXP || f7_class_inf (a_class))\n+    {\n+      // Inf or overflow.\n+      expo8 = FLT_MAX_EXP;\n+      mant = 0;\n+    }\n+  else if (c_expo > 0)\n+    {\n+      // Normal.\n+      expo8 = c_expo;\n+    }\n+  else\n+    {\n+      // Sub-normal:  -DIG_MANT < c_expo <= 0.\n+      // Encoding of 0 represents a biased exponent of 1.\n+      // mant_offset in 9...31.\n+      expo8 = 0;\n+      mant_offset += 1 - c_expo;\n+    }\n+\n+  uint16_t expo16 = expo8 << (FLT_DIG_MANT - 16);\n+\n+  if (f7_class_sign (a_class))\n+    expo16 |= 1u << (FLT_DIG_EXP + FLT_DIG_MANT - 16);\n+\n+  mant >>= mant_offset;\n+\n+  __asm (\"cbr %T0%t2, 1 << (7 & %2)\"  \"\\n\\t\"\n+\t \"or  %C0, %A1\"\t\t      \"\\n\\t\"\n+\t \"or  %D0, %B1\"\n+\t : \"+d\" (mant)\n+\t : \"r\" (expo16), \"n\" (FLT_DIG_MANT));\n+\n+  return make_float (mant);\n+}\n+F7_PURE ALIAS (f7_get_float, f7_truncdfsf2)\n+#endif // F7MOD_get_float_\n+\n+#define DBL_DIG_EXP   11\n+#define DBL_DIG_MANT  (63 - DBL_DIG_EXP)\n+#define DBL_MAX_EXP   ((1 << DBL_DIG_EXP) - 1)\n+#define DBL_EXP_BIAS  (DBL_MAX_EXP >> 1)\n+\n+\n+#ifdef F7MOD_set_double_\n+void f7_set_double_impl (f7_double_t val64, f7_t *cc)\n+{\n+  f7_clr (cc);\n+  register uint64_t mant __asm (\"r18\") = val64 & ((1ull << DBL_DIG_MANT) -1);\n+\n+  uint16_t val16 = 3[(uint16_t*) & val64];\n+  val16 >>= DBL_DIG_MANT - 48;\n+\n+  uint16_t expo_biased = val16 & DBL_MAX_EXP;\n+  bool sign = val16 & (1u << DBL_DIG_EXP);\n+\n+  if (mant == 0)\n+    {\n+      if (expo_biased == 0)\n+\treturn;\n+      if (expo_biased >= DBL_MAX_EXP)\n+\treturn f7_set_inf (cc, sign);\n+    }\n+  __asm (\"\" : \"+r\" (mant));\n+\n+  if (expo_biased == 0)\n+    expo_biased = 1;   // Sub-normal: biased expo of 1 was encoded as 0.\n+  else if (expo_biased < DBL_MAX_EXP)\n+    mant |= (1ull << DBL_DIG_MANT);\n+  else\n+    return f7_set_nan (cc);\n+\n+  *(uint64_t*) & cc->mant = mant;\n+\n+  cc->expo = expo_biased - DBL_EXP_BIAS + 63 - DBL_DIG_MANT - 8;\n+  f7_normalize_asm (cc);\n+  f7_set_sign (cc, sign);\n+}\n+#endif // F7MOD_set_double_\n+\n+\n+#ifdef F7MOD_set_pdouble_\n+void f7_set_pdouble (f7_t *cc, const f7_double_t *val64)\n+{\n+  f7_set_double (cc, *val64);\n+}\n+#endif // F7MOD_set_pdouble_\n+\n+\n+#ifdef F7MOD_get_double_\n+static F7_INLINE\n+uint64_t clr_r18 (void)\n+{\n+  extern void __clr_8 (void);\n+  register uint64_t r18 __asm (\"r18\");\n+  __asm (\"%~call %x[f]\" : \"=r\" (r18) : [f] \"i\" (__clr_8));\n+  return r18;\n+}\n+\n+static F7_INLINE\n+f7_double_t make_double (uint64_t x)\n+{\n+  register f7_double_t r18 __asm (\"r18\") = x;\n+  __asm (\"\" : \"+r\" (r18));\n+  return r18;\n+}\n+\n+F7_WEAK\n+f7_double_t f7_get_double (const f7_t *aa)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  if (f7_class_nan (a_class))\n+    {\n+      uint64_t nan = clr_r18() | (0x7fffull << 48);\n+      return make_double (nan);\n+    }\n+\n+  uint64_t mant;\n+  __builtin_memcpy (&mant, & aa->mant, 8);\n+\n+  mant &= 0x00ffffffffffffff;\n+\n+  // FIXME: For subnormals, rounding is premature and should be\n+  //\t    done *after* the mantissa has been shifted into place\n+  //\t    (or the round value be shifted left accordingly).\n+  // Round.\n+  mant += 1u << (F7_MANT_BITS - (1 + DBL_DIG_MANT) - 1);\n+\n+  uint8_t dex;\n+  register uint64_t r18 __asm (\"r18\") = mant;\n+  // dex = Overflow ? 1 : 0.\n+  __asm (\"bst %T[mant]%T[bitno]\"  \"\\n\\t\"\n+\t \"clr %0\"\t\t  \"\\n\\t\"\n+\t \"bld %0,0\"\n+\t : \"=r\" (dex), [mant] \"+r\" (r18)\n+\t : [bitno] \"n\" (64 - 8));\n+\n+  mant = r18 >> dex;\n+\n+  uint16_t expo16 = 0;\n+  uint16_t mant_offset = DBL_DIG_EXP - 8;\n+  int16_t c_expo = add_ssat16 (aa->expo, DBL_EXP_BIAS + dex);\n+\n+  if (f7_class_zero (a_class) || c_expo <= -DBL_DIG_MANT)\n+    {\n+      // Zero or tiny.\n+      return make_double (clr_r18());\n+    }\n+  else if (c_expo >= DBL_MAX_EXP || f7_class_inf (a_class))\n+    {\n+      // Inf or overflow.\n+      expo16 = DBL_MAX_EXP;\n+      mant = clr_r18();\n+    }\n+  else if (c_expo > 0)\n+    {\n+      // Normal.\n+      expo16 = c_expo;\n+    }\n+  else\n+    {\n+      // Sub-normal:  -DIG_MANT < c_expo <= 0.\n+      // Encoding expo of 0 represents a biased exponent of 1.\n+      // mant_offset in 5...55 = 63-8.\n+      mant_offset += 1 - c_expo;\n+    }\n+\n+  expo16 <<= (DBL_DIG_MANT - 48);\n+\n+  if (f7_class_sign (a_class))\n+    expo16 |= 1u << (DBL_DIG_EXP + DBL_DIG_MANT - 48);\n+\n+  // mant >>= mant_offset;\n+  mant = f7_lshrdi3 (mant, mant_offset);\n+\n+  r18 = mant;\n+  __asm (\"cbr %T0%t2, 1 << (7 & %2)\"  \"\\n\\t\"\n+\t \"or  %r0+6, %A1\"\t      \"\\n\\t\"\n+\t \"or  %r0+7, %B1\"\n+\t : \"+r\" (r18)\n+\t : \"r\" (expo16), \"n\" (DBL_DIG_MANT));\n+\n+  return make_double (r18);\n+}\n+#endif // F7MOD_get_double_\n+\n+\n+#ifdef F7MOD_fabs_\n+F7_WEAK\n+void f7_fabs (f7_t *cc, const f7_t *aa)\n+{\n+  f7_abs (cc, aa);\n+}\n+#endif // F7MOD_fabs_\n+\n+\n+#ifdef F7MOD_neg_\n+F7_WEAK\n+f7_t* f7_neg (f7_t *cc, const f7_t *aa)\n+{\n+  f7_copy (cc, aa);\n+\n+  uint8_t c_class = f7_classify (cc);\n+\n+  if (! f7_class_zero (c_class))\n+    cc->sign = ! f7_class_sign (c_class);\n+\n+  return cc;\n+}\n+#endif // F7MOD_neg_\n+\n+\n+#ifdef F7MOD_frexp_\n+F7_WEAK\n+void f7_frexp (f7_t *cc, const f7_t *aa, int *expo)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  if (f7_class_nan (a_class))\n+    return f7_set_nan (cc);\n+\n+  if (f7_class_inf (a_class) || aa->expo == INT16_MAX)\n+    return f7_set_inf (cc, f7_class_sign (a_class));\n+\n+  if (! f7_msbit (aa))\n+    {\n+      *expo = 0;\n+      return f7_clr (cc);\n+    }\n+\n+  *expo = 1 + aa->expo;\n+  cc->flags = a_class & F7_FLAG_sign;\n+  cc->expo = -1;\n+  f7_copy_mant (cc, aa);\n+}\n+#endif // F7MOD_frexp_\n+\n+#ifdef F7MOD_get_s16_\n+F7_WEAK\n+int16_t f7_get_s16 (const f7_t *aa)\n+{\n+  extern int16_t to_s16 (const f7_t*, uint8_t) F7ASM(f7_to_integer_asm);\n+  return to_s16 (aa, 0xf);\n+}\n+#endif // F7MOD_get_s16_\n+\n+\n+#ifdef F7MOD_get_s32_\n+F7_WEAK\n+int32_t f7_get_s32 (const f7_t *aa)\n+{\n+  extern int32_t to_s32 (const f7_t*, uint8_t) F7ASM(f7_to_integer_asm);\n+  return to_s32 (aa, 0x1f);\n+}\n+F7_PURE ALIAS (f7_get_s32, f7_fixdfsi)\n+#endif // F7MOD_get_s32_\n+\n+\n+#ifdef F7MOD_get_s64_\n+  F7_WEAK\n+  int64_t f7_get_s64 (const f7_t *aa)\n+{\n+  extern int64_t to_s64 (const f7_t*, uint8_t) F7ASM(f7_to_integer_asm);\n+  return to_s64 (aa, 0x3f);\n+}\n+F7_PURE ALIAS (f7_get_s64, f7_fixdfdi)\n+#endif // F7MOD_get_s64_\n+\n+#ifdef F7MOD_get_u16_\n+  F7_WEAK\n+  uint16_t f7_get_u16 (const f7_t *aa)\n+{\n+  extern uint16_t to_u16 (const f7_t*, uint8_t) F7ASM(f7_to_unsigned_asm);\n+  return to_u16 (aa, 0xf);\n+}\n+#endif // F7MOD_get_u16_\n+\n+\n+#ifdef F7MOD_get_u32_\n+F7_WEAK\n+uint32_t f7_get_u32 (const f7_t *aa)\n+{\n+  extern uint32_t to_u32 (const f7_t*, uint8_t) F7ASM(f7_to_unsigned_asm);\n+  return to_u32 (aa, 0x1f);\n+}\n+F7_PURE ALIAS (f7_get_u32, f7_fixunsdfsi)\n+#endif // F7MOD_get_u32_\n+\n+\n+#ifdef F7MOD_get_u64_\n+F7_WEAK\n+uint64_t f7_get_u64 (const f7_t *aa)\n+{\n+  extern int64_t to_u64 (const f7_t*, uint8_t) F7ASM(f7_to_unsigned_asm);\n+  return to_u64 (aa, 0x3f);\n+}\n+F7_PURE ALIAS (f7_get_u64, f7_fixunsdfdi)\n+#endif // F7MOD_get_u64_\n+\n+\n+#ifdef F7MOD_cmp_unordered_\n+F7_NOINLINE\n+static int8_t cmp_u8 (uint8_t a_class, uint8_t b_class, bool sign_a);\n+\n+F7_WEAK\n+int8_t f7_cmp_unordered (const f7_t *aa, const f7_t *bb, bool with_sign)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+  uint8_t b_class = f7_classify (bb);\n+\n+  uint8_t a_sign = f7_class_sign (a_class) & with_sign;\n+  uint8_t b_sign = f7_class_sign (b_class) & with_sign;\n+  uint8_t ab_class = a_class | b_class;\n+  ab_class &= with_sign - 2;\n+\n+  if (f7_class_nan (ab_class))\n+    return INT8_MIN;\n+\n+  if (a_sign != b_sign)\n+    return b_sign - a_sign;\n+\n+  if (f7_class_inf (ab_class))\n+    return cmp_u8 (a_class, b_class, a_sign);\n+\n+  if (f7_class_zero (ab_class))\n+    return cmp_u8 (b_class, a_class, a_sign);\n+\n+  if (aa->expo < bb->expo)\n+    return a_sign ? 1 : -1;\n+\n+  if (aa->expo > bb->expo)\n+    return a_sign ? -1 : 1;\n+\n+  return cmp_u8 (1 + f7_cmp_mant (aa, bb), 1, a_sign);\n+}\n+\n+\n+int8_t cmp_u8 (uint8_t a_class, uint8_t b_class, bool sign_a)\n+{\n+  int8_t c;\n+  __asm (\"sub  %[a], %[b]\"    \"\\n\\t\"\n+\t \"breq 1f\"\t      \"\\n\\t\"\n+\t \"sbc  %[c], %[c]\"    \"\\n\\t\"\n+\t \"sbci %[c], -1\"      \"\\n\\t\"\n+\t \"sbrc %[s], 0\"\t      \"\\n\\t\"\n+\t \"neg  %[c]\"\t      \"\\n\\t\"\n+\t \"1:\"\n+\t : [c] \"=d\" (c)\n+\t : [a] \"0\" (a_class), [b] \"r\" (b_class), [s] \"r\" (sign_a));\n+  return c;\n+}\n+#endif // F7MOD_cmp_unordered_\n+\n+\n+#ifdef F7MOD_cmp_abs_\n+F7_WEAK\n+int8_t f7_cmp_abs (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_cmp_unordered (aa, bb, false /* no signs */);\n+}\n+#endif // F7MOD_cmp_abs_\n+\n+\n+#ifdef F7MOD_cmp_\n+F7_WEAK\n+int8_t f7_cmp (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_cmp_unordered (aa, bb, true /* with signs */);\n+}\n+#endif // F7MOD_cmp_\n+\n+\n+#ifdef F7MOD_abscmp_msb_ge_\n+// Compare absolute value of Number aa against a f7_t represented\n+// by msb and expo.\n+F7_WEAK\n+bool f7_abscmp_msb_ge (const f7_t *aa, uint8_t msb, int16_t expo)\n+{\n+  uint8_t a_msb = aa->mant[F7_MANT_BYTES - 1];\n+\n+  if (0 == (0x80 & a_msb))\n+    // 0 or subnormal.\n+    return false;\n+\n+  return aa->expo == expo\n+    ? a_msb >= msb\n+    : aa->expo > expo;\n+}\n+#endif // F7MOD_abscmp_msb_ge_\n+\n+#ifdef F7MOD_lt_\n+F7_WEAK\n+bool f7_lt_impl (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_lt (aa, bb);\n+}\n+#endif // F7MOD_lt_\n+\n+#ifdef F7MOD_le_\n+F7_WEAK\n+bool f7_le_impl (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_le (aa, bb);\n+}\n+#endif // F7MOD_le_\n+\n+#ifdef F7MOD_gt_\n+F7_WEAK\n+bool f7_gt_impl (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_gt (aa, bb);\n+}\n+#endif // F7MOD_gt_\n+\n+#ifdef F7MOD_ge_\n+F7_WEAK\n+bool f7_ge_impl (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_ge (aa, bb);\n+}\n+#endif // F7MOD_ge_\n+\n+#ifdef F7MOD_ne_\n+F7_WEAK\n+bool f7_ne_impl (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_ne (aa, bb);\n+}\n+#endif // F7MOD_ne_\n+\n+#ifdef F7MOD_eq_\n+F7_WEAK\n+bool f7_eq_impl (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_eq (aa, bb);\n+}\n+#endif // F7MOD_eq_\n+\n+\n+#ifdef F7MOD_unord_\n+F7_WEAK\n+bool f7_unord_impl (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_unordered (aa, bb);\n+}\n+#endif // F7MOD_unord_\n+\n+\n+#ifdef F7MOD_minmax_\n+F7_WEAK\n+f7_t* f7_minmax (f7_t *cc, const f7_t *aa, const f7_t *bb, bool do_min)\n+{\n+  int8_t cmp = f7_cmp_unordered (aa, bb, true /* with signs */);\n+\n+  if (cmp == INT8_MIN)\n+    return (f7_set_nan (cc), cc);\n+\n+  if (do_min)\n+    cmp = -cmp;\n+\n+  return f7_copy (cc, cmp >= 0 ? aa : bb);\n+}\n+#endif // F7MOD_minmax_\n+\n+\n+#ifdef F7MOD_fmax_\n+F7_WEAK\n+f7_t* f7_fmax (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_minmax (cc, aa, bb, false);\n+}\n+ALIAS (f7_fmax, f7_max)\n+#endif // F7MOD_fmax_\n+\n+\n+#ifdef F7MOD_fmin_\n+F7_WEAK\n+f7_t* f7_fmin (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_minmax (cc, aa, bb, true);\n+}\n+ALIAS (f7_fmin, f7_min)\n+#endif // F7MOD_fmin_\n+\n+\n+#ifdef F7MOD_mulx_\n+F7_WEAK\n+uint8_t f7_mulx (f7_t *cc, const f7_t *aa, const f7_t *bb, bool no_rounding)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+  uint8_t b_class = f7_classify (bb);\n+  // From this point on, no more access aa->flags or bb->flags\n+  // to avoid early-clobber when writing cc->flags.\n+\n+  uint8_t ab_class = a_class | b_class;\n+  // If either value is NaN, return NaN.\n+  if (f7_class_nan (ab_class)\n+      // Any combination of Inf and 0.\n+      || (f7_class_zero (ab_class) && f7_class_inf (ab_class)))\n+    {\n+      cc->flags = F7_FLAG_nan;\n+      return 0;\n+    }\n+  // If either value is 0.0, return 0.0.\n+  if (f7_class_zero (ab_class))\n+    {\n+      f7_clr (cc);\n+      return 0;\n+    }\n+  // We have 2 non-zero numbers-or-INF.\n+\n+  uint8_t c_sign = (a_class ^ b_class) & F7_FLAG_sign;\n+  uint8_t c_inf  = ab_class & F7_FLAG_inf;\n+  cc->flags = c_sign | c_inf;\n+  if (c_inf)\n+    return 0;\n+\n+  int16_t expo = add_ssat16 (aa->expo, bb->expo);\n+  // Store expo and handle expo = INT16_MIN  and INT16_MAX.\n+  if (f7_store_expo (cc, expo))\n+    return 0;\n+\n+  return f7_mul_mant_asm (cc, aa, bb, no_rounding);\n+}\n+#endif // F7MOD_mulx_\n+\n+\n+#ifdef F7MOD_square_\n+F7_WEAK\n+void f7_square (f7_t *cc, const f7_t *aa)\n+{\n+  f7_mul (cc, aa, aa);\n+}\n+#endif // F7MOD_square_\n+\n+\n+#ifdef F7MOD_mul_\n+F7_WEAK\n+void f7_mul (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+  f7_mulx (cc, aa, bb, false);\n+}\n+#endif // F7MOD_mul_\n+\n+\n+#ifdef F7MOD_Iadd_\n+F7_WEAK void f7_Iadd (f7_t *cc, const f7_t *aa) { f7_add (cc, cc, aa); }\n+#endif\n+\n+#ifdef F7MOD_Isub_\n+F7_WEAK void f7_Isub (f7_t *cc, const f7_t *aa) { f7_sub (cc, cc, aa); }\n+#endif\n+\n+#ifdef F7MOD_Imul_\n+F7_WEAK void f7_Imul (f7_t *cc, const f7_t *aa) { f7_mul (cc, cc, aa); }\n+#endif\n+\n+#ifdef F7MOD_Idiv_\n+F7_WEAK void f7_Idiv (f7_t *cc, const f7_t *aa) { f7_div (cc, cc, aa); }\n+#endif\n+\n+#ifdef F7MOD_IRsub_\n+F7_WEAK void f7_IRsub (f7_t *cc, const f7_t *aa) { f7_sub (cc, aa, cc); }\n+#endif\n+\n+#ifdef F7MOD_Ineg_\n+F7_WEAK void f7_Ineg (f7_t *cc) { f7_neg (cc, cc); }\n+#endif\n+\n+#ifdef F7MOD_Isqrt_\n+F7_WEAK void f7_Isqrt (f7_t *cc) { f7_sqrt (cc, cc); }\n+#endif\n+\n+#ifdef F7MOD_Isquare_\n+F7_WEAK void f7_Isquare (f7_t *cc) { f7_square (cc, cc); }\n+#endif\n+\n+#ifdef F7MOD_Ildexp_\n+F7_WEAK f7_t* f7_Ildexp (f7_t *cc, int ex) { return f7_ldexp (cc, cc, ex); }\n+#endif\n+\n+\n+#ifdef F7MOD_add_\n+F7_WEAK\n+void f7_add (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+  f7_addsub (cc, aa, bb, false);\n+}\n+#endif // F7MOD_add_\n+\n+\n+#ifdef F7MOD_sub_\n+F7_WEAK\n+void f7_sub (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+  f7_addsub (cc, aa, bb, true);\n+}\n+#endif // F7MOD_sub_\n+\n+\n+#ifdef F7MOD_addsub_\n+static void return_with_sign (f7_t *cc, const f7_t *aa, int8_t c_sign)\n+{\n+  __asm (\";;; return with sign\");\n+  f7_copy (cc, aa);\n+  if (c_sign != -1)\n+    f7_set_sign (cc, c_sign);\n+}\n+\n+F7_WEAK\n+void f7_addsub (f7_t *cc, const f7_t *aa, const f7_t *bb, bool neg_b)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+  uint8_t b_class = f7_classify (bb);\n+  // From this point on, no more access aa->flags or bb->flags\n+  // to avoid early-clobber when writing cc->flags.\n+\n+  // Hande NaNs.\n+  if (f7_class_nan (a_class | b_class))\n+    return f7_set_nan (cc);\n+\n+  bool a_sign = f7_class_sign (a_class);\n+  bool b_sign = f7_class_sign (b_class) ^ neg_b;\n+\n+  // Add the mantissae?\n+  bool do_add = a_sign == b_sign;\n+\n+  // Handle +Infs and -Infs.\n+  bool a_inf = f7_class_inf (a_class);\n+  bool b_inf = f7_class_inf (b_class);\n+\n+  if (a_inf && b_inf)\n+    {\n+      if (do_add)\n+\treturn f7_set_inf (cc, a_sign);\n+      else\n+\treturn f7_set_nan (cc);\n+    }\n+  else if (a_inf)\n+    return f7_set_inf (cc, a_sign);\n+  else if (b_inf)\n+    return f7_set_inf (cc, b_sign);\n+\n+  int16_t shift16 = sub_ssat16 (aa->expo, bb->expo);\n+\n+  // aa + 0 = aa.\n+  // Also check MSBit to get rid of Subnormals and 0.\n+  if (shift16 > F7_MANT_BITS || f7_is0 (bb))\n+    return return_with_sign (cc, aa, -1);\n+\n+  // 0 + bb = bb.\n+  // 0 - bb = -bb.\n+  // Also check MSBit to get rid of Subnormals and 0.\n+  if (shift16 < -F7_MANT_BITS || f7_is0 (aa))\n+    return return_with_sign (cc, bb, b_sign);\n+\n+  // Now aa and bb are non-zero, non-NaN, non-Inf.\n+  // shift > 0 ==> |a| > |b|\n+  // shift < 0 ==> |a| < |b|\n+  int8_t shift = (int8_t) shift16;\n+  bool c_sign = a_sign;\n+  if (shift < 0\n+      || (shift == 0 && f7_cmp_mant (aa, bb) < 0))\n+    {\n+      const f7_t *p = aa; aa = bb; bb = p;\n+      c_sign = b_sign;\n+      shift = -shift;\n+    }\n+  uint8_t shift2 = (uint8_t) (shift << 1);\n+\n+  cc->expo = aa->expo;\n+  // From this point on, no more access aa->expo or bb->expo\n+  // to avoid early-clobber when writing cc->expo.\n+\n+  cc->flags = c_sign;  _Static_assert (F7_FLAGNO_sign == 0, \"\");\n+\n+  // This function uses neither .expo nor .flags from either aa or bb,\n+  // hence there is early-clobber for cc->expo and cc->flags.\n+  f7_addsub_mant_scaled_asm (cc, aa, bb, shift2 | do_add);\n+}\n+#endif // F7MOD_addsub_\n+\n+\n+#ifdef F7MOD_madd_msub_\n+F7_WEAK\n+void f7_madd_msub (f7_t *cc, const f7_t *aa, const f7_t *bb, const f7_t *dd,\n+                   bool neg_d)\n+{\n+  f7_t xx7, *xx = &xx7;\n+  uint8_t x_lsb = f7_mulx (xx, aa, bb, true /* no rounding */);\n+  uint8_t x_sign = f7_signbit (xx);\n+  int16_t x_expo = xx->expo;\n+  f7_addsub (xx, xx, dd, neg_d);\n+  // Now add LSB.  If cancellation occured in the add / sub, then we have the\n+  // chance of extra 8 bits of precision.  Turn LSByte into f7_t.\n+  f7_clr (cc);\n+  cc->expo = sub_ssat16 (x_expo, F7_MANT_BITS);\n+  cc->mant[F7_MANT_BYTES - 1] = x_lsb;\n+  cc = f7_normalize_asm (cc);\n+  cc->flags = x_sign;\n+  f7_Iadd (cc, xx);\n+}\n+#endif // F7MOD_madd_msub_\n+\n+#ifdef F7MOD_madd_\n+F7_WEAK\n+void f7_madd (f7_t *cc, const f7_t *aa, const f7_t *bb, const f7_t *dd)\n+{\n+  f7_madd_msub (cc, aa, bb, dd, false);\n+}\n+#endif // F7MOD_madd_\n+\n+#ifdef F7MOD_msub_\n+F7_WEAK\n+void f7_msub (f7_t *cc, const f7_t *aa, const f7_t *bb, const f7_t *dd)\n+{\n+  f7_madd_msub (cc, aa, bb, dd, true);\n+}\n+#endif // F7MOD_msub_\n+\n+\n+#ifdef F7MOD_ldexp_\n+F7_WEAK\n+f7_t* f7_ldexp (f7_t *cc, const f7_t *aa, int delta)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  cc->flags = a_class;\n+\n+  // Inf and NaN.\n+  if (! f7_class_number (a_class))\n+    return cc;\n+\n+  if (f7_msbit (aa) == 0)\n+    return (f7_clr (cc), cc);\n+\n+  int16_t expo = add_ssat16 (delta, aa->expo);\n+  // Store expo and handle expo = INT16_MIN  and INT16_MAX.\n+  if (! f7_store_expo (cc, expo))\n+    f7_copy_mant (cc, aa);\n+\n+  return cc;\n+}\n+#endif // F7MOD_ldexp_\n+\n+\n+#if USE_LPM\n+#elif USE_LD\n+#else\n+#error need include \"asm-defs.h\"\n+#endif // USE_LPM\n+\n+/*\n+  Handling constants:\n+\n+  F7_PCONST (PVAR, X)\n+\n+      Set  f7_t [const] *PVAR  to an LD address for one\n+      of the  f7_const_X[_P]  constants.\n+      PVAR might be set to point to a local auto that serves\n+      as temporary storage for f7_const_X_P.  PVAR is only\n+      valid in the current block.\n+\n+  const f7_t* F7_PCONST_U16 (PVAR, <ident> X)       // USE_LD\n+  f7_t*       F7_PCONST_U16 (PVAR, uint16_t X)      // USE_LPM\n+\n+      Set  f7_t [const] *PVAR  to an LD address for one of the\n+      f7_const_X[_P]  constants.  PVAR might be set to point to a\n+      local auto that serves as temporary storage for X.  PVAR is\n+      only valid in the current block.\n+\n+  F7_PCONST_VAR (PVAR, VAR)\n+\n+      VAR is a pointer variable holding the address of some f7_const_X[_P]\n+      constant.  Set  [const] f7_t *PVAR  to a respective LD address.\n+      PVAR might be set to point to a local auto that serves\n+      as temporary storage for f7_const_X_P.  PVAR is only\n+      valid in the current block.\n+\n+  F7_CONST_ADDR (<ident> CST, f7_t* PTMP)\n+\n+      Return an LD address to for some f7_const_X[_P] constant.\n+      *PTMP might be needed to hold a copy of f7_const_X_P in RAM.\n+\n+  f7_t*       F7_U16_ADDR (uint16_t     X, f7_t* PTMP)   // USE_LPM\n+  const f7_t* F7_U16_ADDR (<cst-ident>  X, <unused>)     // USE_LD\n+\n+      Return an LD address to compile-time constant  uint16_t X  which is\n+      also known as  f7_const_X[_P].  *PTMP might be set to  (f7_t) X.\n+\n+  f7_t* f7_const (f7_t *PVAR, <cst-ident> X)\n+\n+      Copy  f7_const_X[_P]  to *PVAR.\n+\n+  f7_t* f7_copy_flash (f7_t *DST, const f7_t *SRC)\n+\n+      Copy to *DST with LD (from .rodata in flash) if the address\n+      space is linear, or with  LPM (from .progmem.data) if the\n+      address space is not linear.\n+\n+  f7_t* f7_copy (f7_t *DST, const f7_t* SRC)\n+\n+      Copy to RAM using LD.\n+\n+  f7_t* f7_copy_P (f7_t *DST, const f7_t *SRC)\n+\n+      Copy to RAM using LPM.\n+*/\n+\n+#if USE_LPM\n+  #define F7_RAW_CONST_ADDR(CST) \\\n+      & F7_(const_##CST##_P)\n+\n+  #define F7_PCONST(PVAR, CST)\t\t\t\t    \\\n+      f7_t _var_for_##CST;\t\t\t\t    \\\n+      f7_copy_P (& _var_for_##CST, & F7_(const_##CST##_P)); \\\n+      PVAR = & _var_for_##CST\n+\n+  #define F7_PCONST_U16(PVAR, CST)\t\t\\\n+      f7_t _var_for_##CST;\t\t\t\\\n+      PVAR = f7_set_u16 (& _var_for_##CST, CST)\n+\n+  #define F7_PCONST_VAR(PVAR, VAR)\t\t\\\n+      f7_t _var_for_##VAR;\t\t\t\\\n+      f7_copy_P (& _var_for_##VAR, VAR);\t\\\n+      PVAR = & _var_for_##VAR\n+\n+  #define MAYBE_const // empty\n+\n+  #define F7_CONST_ADDR(CST, PTMP) \\\n+      f7_copy_P ((PTMP), & F7_(const_##CST##_P))\n+\n+  #define F7_U16_ADDR(CST, PTMP)   \\\n+      f7_set_u16 ((PTMP), CST)\n+\n+#elif USE_LD\n+  #define F7_RAW_CONST_ADDR(CST)   \\\n+      & F7_(const_##CST)\n+\n+  #define F7_PCONST(PVAR, CST)\t   \\\n+      PVAR = & F7_(const_##CST)\n+\n+  #define F7_PCONST_U16(PVAR, CST) \\\n+      PVAR = & F7_(const_##CST)\n+\n+  #define F7_PCONST_VAR(PVAR, VAR) \\\n+      PVAR = (VAR)\n+\n+  #define F7_CONST_ADDR(CST, PTMP) \\\n+      (& F7_(const_##CST))\n+\n+  #define F7_U16_ADDR(CST, PTMP)   \\\n+      (& F7_(const_##CST))\n+\n+  #define MAYBE_const const\n+#endif\n+\n+\n+\n+#define DD(str, X)\t\t\\\n+  do {\t\t\t\t\\\n+    LOG_PSTR (PSTR (str));\t\\\n+    f7_dump (X);\t\t\\\n+  } while (0)\n+\n+#undef DD\n+#define DD(...) (void) 0\n+\n+\n+#ifdef F7MOD_sqrt_\n+static void sqrt_worker (f7_t *cc, const f7_t *rr)\n+{\n+  f7_t tmp7, *tmp = &tmp7;\n+  f7_t aa7, *aa = &aa7;\n+\n+  // aa in  [1/2, 2)  =>  aa->expo in { -1, 0 }.\n+  int16_t a_expo = -(rr->expo & 1);\n+  int16_t c_expo = (rr->expo - a_expo) >> 1;  // FIXME: r_expo = INT_MAX???\n+\n+  __asm (\"\" : \"+r\" (aa));\n+\n+  f7_copy (aa, rr);\n+  aa->expo = a_expo;\n+\n+  // No use of rr or *cc past this point:  We may use cc as temporary.\n+  // Approximate square-root of  A  by  X <-- (X + A / X) / 2.\n+\n+  f7_sqrt_approx_asm (cc, aa);\n+\n+  // Iterate  X <-- (X + A / X) / 2.\n+  // 3 Iterations with 16, 32, 58 bits of precision for the quotient.\n+\n+  for (uint8_t prec = 16; (prec & 0x80) == 0; prec <<= 1)\n+    {\n+      f7_divx (tmp, aa, cc, (prec & 64) ? 2 + F7_MANT_BITS : prec);\n+      f7_Iadd (cc, tmp);\n+      // This will never underflow because |c_expo| is small.\n+      cc->expo--;\n+    }\n+\n+  // Similar: |c_expo| is small, hence no ldexp needed.\n+  cc->expo += c_expo;\n+}\n+\n+F7_WEAK\n+void f7_sqrt (f7_t *cc, const f7_t *aa)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  if (f7_class_nan (a_class) || f7_class_sign (a_class))\n+    return f7_set_nan (cc);\n+\n+  if (f7_class_inf (a_class))\n+    return f7_set_inf (cc, 0);\n+\n+  if (f7_class_zero (a_class))\n+    return f7_clr (cc);\n+\n+  sqrt_worker (cc, aa);\n+}\n+#endif // F7MOD_sqrt_\n+\n+\n+#ifdef F7MOD_hypot_\n+F7_WEAK\n+void f7_hypot (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+  f7_t xx7, *xx = &xx7;\n+\n+  f7_square (xx, aa);\n+  f7_square (cc, bb);\n+  f7_Iadd (cc, xx);\n+  f7_Isqrt (cc);\n+}\n+#endif // F7MOD_hypot_\n+\n+\n+#ifdef F7MOD_const_m1_\n+#include \"libf7-constdef.h\"\n+#endif // -1\n+\n+#ifdef F7MOD_const_1_2_\n+#include \"libf7-constdef.h\"\n+#endif // 1/2\n+\n+#ifdef F7MOD_const_1_3_\n+#include \"libf7-constdef.h\"\n+#endif // 1/3\n+\n+#ifdef F7MOD_const_ln2_\n+#include \"libf7-constdef.h\"\n+#endif // ln2\n+\n+#ifdef F7MOD_const_1_ln2_\n+#include \"libf7-constdef.h\"\n+#endif // 1_ln2\n+\n+#ifdef F7MOD_const_ln10_\n+#include \"libf7-constdef.h\"\n+#endif // ln10\n+\n+#ifdef F7MOD_const_1_ln10_\n+#include \"libf7-constdef.h\"\n+#endif // 1_ln10\n+\n+#ifdef F7MOD_const_1_\n+#include \"libf7-constdef.h\"\n+#endif // 1\n+\n+#ifdef F7MOD_const_sqrt2_\n+#include \"libf7-constdef.h\"\n+#endif // sqrt2\n+\n+#ifdef F7MOD_const_2_\n+#include \"libf7-constdef.h\"\n+#endif // 2\n+\n+#ifdef F7MOD_const_pi_\n+#include \"libf7-constdef.h\"\n+#endif // pi\n+\n+\n+#ifdef F7MOD_divx_\n+\n+// C /= A\n+extern void f7_div_asm (f7_t*, const f7_t*, uint8_t);\n+\n+F7_WEAK\n+void f7_divx (f7_t *cc, const f7_t *aa, const f7_t *bb, uint8_t quot_bits)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+  uint8_t b_class = f7_classify (bb);\n+  // From this point on, no more access aa->flags or bb->flags\n+  // to avoid early-clobber when writing cc->flags.\n+\n+  // If either value is NaN, return NaN.\n+  if (f7_class_nan (a_class | b_class)\n+      // If both values are Inf or both are 0, return NaN.\n+      || f7_class_zero (a_class & b_class)\n+      || f7_class_inf (a_class & b_class)\n+      // Inf / 0 = NaN.\n+      || (f7_class_inf (a_class) && f7_class_zero (b_class)))\n+    {\n+      return f7_set_nan (cc);\n+    }\n+\n+  // 0 / B   = 0  for non-zero, non-NaN B.\n+  // A / Inf = 0  for non-zero numbers A.\n+  if (f7_class_zero (a_class) || f7_class_inf (b_class))\n+    return f7_clr (cc);\n+\n+  uint8_t c_sign = (a_class ^ b_class) & F7_FLAG_sign;\n+\n+  if (f7_class_inf (a_class) || f7_class_zero (b_class))\n+    return f7_set_inf (cc, c_sign);\n+\n+  cc->flags = c_sign;     _Static_assert (F7_FLAGNO_sign == 0, \"\");\n+  int16_t expo = sub_ssat16 (aa->expo, bb->expo);\n+\n+  // Store expo and handle expo = INT16_MIN  and INT16_MAX.\n+  if (f7_store_expo (cc, expo))\n+    return;\n+\n+  f7_t ss7, *ss = &ss7;\n+  ss->flags = cc->flags;\n+  ss->expo  = cc->expo;\n+\n+  f7_copy_mant (ss, aa);\n+  f7_div_asm (ss, bb, quot_bits);\n+  f7_copy (cc, ss);\n+}\n+#endif // F7MOD_divx_\n+\n+\n+#ifdef F7MOD_div_\n+F7_WEAK\n+void f7_div (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+  /* When f7_divx calls f7_div_asm, dividend and divisor are valid\n+     mantissae, i.e. their MSBit is set.  Therefore, the quotient will\n+     be in  [0x0.ff..., 0x0.40...]  and to adjust it, at most 1 left-shift\n+     is needed.  Compute F7_MANT_BITS + 2 bits of the quotient:\n+     One bit is used for rounding, and one bit might be consumed by the\n+     mentioned left-shift.  */\n+\n+  f7_divx (cc, aa, bb, 2 + F7_MANT_BITS);\n+}\n+#endif // F7MOD_div_\n+\n+\n+#ifdef F7MOD_div1_\n+F7_WEAK\n+void f7_div1 (f7_t *cc, const f7_t *aa)\n+{\n+  F7_PCONST_U16 (const f7_t *one, 1);\n+  f7_div (cc, one, aa);\n+}\n+#endif // F7MOD_div_\n+\n+\n+#ifdef F7MOD_fmod_\n+F7_WEAK\n+void f7_fmod (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+  uint8_t b_class = f7_classify (bb);\n+\n+  if (! f7_class_number (a_class)\n+      || f7_class_nan (b_class)\n+      || f7_class_zero (b_class))\n+    {\n+      return f7_set_nan (cc);\n+    }\n+\n+  // A == 0 and B != 0  =>  0.\n+  if (f7_class_zero (a_class))\n+    return f7_clr (cc);\n+\n+  f7_t zz7, *zz = & zz7;\n+\n+  f7_div (zz, aa, bb);\n+\n+  // Z in Z,  |Z| <= |A/B|.\n+  f7_trunc (zz, zz);\n+\n+  // C = A - Z * B.\n+  f7_msub (cc, zz, bb, aa);\n+  cc->flags ^= F7_FLAG_sign;\n+}\n+#endif // F7MOD_fmod_\n+\n+\n+#ifdef F7MOD_truncx_\n+F7_WEAK\n+f7_t* f7_truncx (f7_t *cc, const f7_t *aa, bool do_floor)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  if (! f7_class_nonzero (a_class))\n+    return f7_copy (cc, aa);\n+\n+  bool sign = f7_class_sign (a_class);\n+\n+  int16_t a_expo = aa->expo;\n+\n+  if (a_expo < 0)\n+    {\n+      // |A| < 1.\n+      if (sign & do_floor)\n+\treturn f7_set_s16 (cc, -1);\n+\n+      f7_clr (cc);\n+      return cc;\n+    }\n+  else if (a_expo >= F7_MANT_BITS - 1)\n+    // A == floor (A).\n+    return f7_copy (cc, aa);\n+\n+  f7_t tmp7, *tmp = &tmp7;\n+\n+  // Needed if aa === cc.\n+  f7_copy (tmp, aa);\n+\n+  cc->flags = sign;\n+  cc->expo = a_expo;\n+  f7_clr_mant_lsbs (cc, aa, F7_MANT_BITS - 1 - a_expo);\n+\n+  if (do_floor && cc->sign && f7_cmp_mant (cc, tmp) != 0)\n+    {\n+      F7_PCONST_U16 (const f7_t *one, 1);\n+      f7_Isub (cc, one);\n+    }\n+\n+  return cc;\n+}\n+#endif // F7MOD_truncx_\n+\n+\n+#ifdef F7MOD_floor_\n+F7_WEAK\n+f7_t* f7_floor (f7_t *cc, const f7_t *aa)\n+{\n+  return f7_truncx (cc, aa, true);\n+}\n+#endif // F7MOD_floor_\n+\n+\n+#ifdef F7MOD_trunc_\n+F7_WEAK\n+f7_t* f7_trunc (f7_t *cc, const f7_t *aa)\n+{\n+  return f7_truncx (cc, aa, false);\n+}\n+#endif // F7MOD_trunc_\n+\n+\n+#ifdef F7MOD_ceil_\n+F7_WEAK\n+void f7_ceil (f7_t *cc, const f7_t *aa)\n+{\n+  cc = f7_copy (cc, aa);\n+  cc->flags ^= F7_FLAG_sign;\n+  cc = f7_floor (cc, cc);\n+  f7_Ineg (cc);\n+}\n+#endif // F7MOD_ceil_\n+\n+\n+#ifdef F7MOD_round_\n+F7_WEAK\n+void f7_round (f7_t *cc, const f7_t *aa)\n+{\n+  f7_t tmp;\n+  (void) tmp;\n+  const f7_t *half = F7_CONST_ADDR (1_2, &tmp);\n+\n+  f7_addsub   (cc, aa, half, f7_signbit (aa));\n+  f7_trunc (cc, cc);\n+}\n+#endif // F7MOD_round_\n+\n+\n+#ifdef F7MOD_horner_\n+\n+// Assertion when using this function is that either cc != xx,\n+// or if cc == xx, then tmp1 must be non-NULL and tmp1 != xx.\n+// In General, the calling functions have a spare f7_t object available\n+// and can pass it down to save some stack.\n+// Moreover, the power series must have degree 1 at least.\n+\n+F7_WEAK\n+void f7_horner (f7_t *cc, const f7_t *xx, uint8_t n_coeff, const f7_t *coeff,\n+                f7_t *tmp1)\n+{\n+  f7_assert (n_coeff > 1);\n+\n+  if (cc != xx)\n+    tmp1 = cc;\n+  else\n+    f7_assert (tmp1 != NULL && tmp1 != xx);\n+\n+  f7_t *yy = tmp1;\n+  f7_t tmp27, *tmp2 = &tmp27;\n+\n+  n_coeff--;\n+  const f7_t *pcoeff = coeff + n_coeff;\n+\n+  f7_copy_flash (yy, pcoeff);\n+\n+  while (1)\n+    {\n+      --pcoeff;\n+#if 1\n+      f7_Imul (yy, xx);\n+      const f7_t *cst = USE_LD ? pcoeff : f7_copy_P (tmp2, pcoeff);\n+      if (coeff == pcoeff)\n+\treturn f7_add (cc, yy, cst);\n+      f7_Iadd (yy, cst);\n+#else\n+      const f7_t *cst = USE_LD ? pcoeff : f7_copy_P (tmp2, pcoeff);\n+      f7_madd (yy, yy, xx, cst);\n+      if (coeff == pcoeff)\n+        {\n+\t  f7_copy (cc, yy);\n+\t  return;\n+        }\n+#endif\n+    }\n+\n+  __builtin_unreachable();\n+}\n+#endif // F7MOD_horner_\n+\n+\n+#ifdef F7MOD_log_\n+F7_WEAK\n+void f7_log (f7_t *cc, const f7_t *aa)\n+{\n+    f7_logx (cc, aa, NULL);\n+}\n+#endif // F7MOD_log_\n+\n+\n+#ifdef F7MOD_log2_\n+F7_WEAK\n+void f7_log2 (f7_t *cc, const f7_t *aa)\n+{\n+  f7_logx (cc, aa, F7_RAW_CONST_ADDR (1_ln2));\n+}\n+#endif // F7MOD_log2_\n+\n+\n+#ifdef F7MOD_log10_\n+F7_WEAK\n+void f7_log10 (f7_t *cc, const f7_t *aa)\n+{\n+  f7_logx (cc, aa, F7_RAW_CONST_ADDR (1_ln10));\n+}\n+#endif // F7MOD_log10_\n+\n+\n+#ifdef F7MOD_logx_\n+\n+#define ARRAY_NAME coeff_artanh\n+#include \"libf7-array.def\"\n+#undef ARRAY_NAME\n+\n+// Compute P * ln(A)  if P != NULL and ln(A), otherwise.\n+// P is a LD-address if USE_LD and a LPM-address if USE_LPM.\n+// Assumption is that P > 0.\n+\n+F7_WEAK\n+void f7_logx (f7_t *cc, const f7_t *aa, const f7_t *p)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  if (f7_class_nan (a_class) || f7_class_sign (a_class))\n+    return f7_set_nan (cc);\n+\n+  if (f7_class_inf (a_class))\n+    return f7_set_inf (cc, 0);\n+\n+  if (f7_class_zero (a_class))\n+    return f7_set_inf (cc, 1);\n+\n+  f7_t *yy = cc;\n+  f7_t xx7, *xx = &xx7;\n+  f7_t tmp7, *tmp = &tmp7;\n+\n+  // Y in [1, 2]  =  A * 2 ^ (-a_expo).\n+  int16_t a_expo = aa->expo;\n+  f7_copy (yy, aa);\n+  yy->expo = 0;\n+\n+  // Y in [1 / sqrt2, sqrt2].\n+\n+  if (f7_abscmp_msb_ge (yy, F7_(const_sqrt2_msb), F7_(const_sqrt2_expo)))\n+    {\n+      yy->expo = -1;\n+      a_expo = add_ssat16 (a_expo, 1);\n+    }\n+\n+  const f7_t *one = F7_U16_ADDR (1, & tmp7);\n+\n+  // X := (Y - 1) / (Y + 1),  |X| <= (sqrt2 - 1) / (sqrt2 + 1)  ~  0.172.\n+  f7_sub (xx, yy, one);\n+  f7_Iadd (yy, one);\n+  f7_Idiv (xx, yy);\n+\n+  // Y := X^2,  |Y| < 0.03.\n+  f7_square (yy, xx);\n+\n+  // Y := artanh (X^2) / X\n+  f7_horner (yy, yy, n_coeff_artanh, coeff_artanh, tmp);\n+\n+  // C = X * Y = ln A - a_expo * ln2.\n+  f7_mul (cc, xx, yy);\n+\n+  // X := a_expo * ln2.\n+  f7_set_s16 (xx, a_expo);\n+  f7_Imul (xx, F7_CONST_ADDR (ln2, & tmp7));\n+\n+  // C = ln A.\n+  f7_Iadd (cc, xx);\n+\n+  if (p && USE_LPM)\n+    f7_Imul (cc, f7_copy_P (tmp, p));\n+  if (p && USE_LD)\n+    f7_Imul (cc, p);\n+}\n+#endif // F7MOD_logx_\n+\n+\n+#ifdef F7MOD_exp_\n+\n+#define ARRAY_NAME coeff_exp\n+#include \"libf7-array.def\"\n+#undef ARRAY_NAME\n+\n+#define STATIC static\n+#include \"libf7-constdef.h\" // ln2_low\n+#undef STATIC\n+\n+F7_WEAK\n+void f7_exp (f7_t *cc, const f7_t *aa)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  if (f7_class_nan (a_class))\n+    return f7_set_nan (cc);\n+\n+  /* The maximal exponent of 2 for a double is 1023, hence we may limit\n+     to  |A| < 1023 * ln2 ~ 709.  We limit to  1024 ~ 1.99 * 2^9  */\n+\n+  if (f7_class_inf (a_class)\n+      || (f7_class_nonzero (a_class) && aa->expo >= 9))\n+    {\n+      if (f7_class_sign (a_class))\n+\treturn f7_clr (cc);\n+      else\n+\treturn f7_set_inf (cc, 0);\n+    }\n+\n+  f7_t const *cst;\n+  f7_t qq7, *qq = &qq7;\n+\n+  F7_PCONST (cst, ln2);\n+\n+  // We limited |A| to 1024 and are now dividing by ln2, hence Q will\n+  // be at most 1024 / ln2 ~ 1477 and fit into 11 bits.  We will\n+  // round Q anyway, hence only request 11 bits from the division and\n+  // one additional bit that might be needed to normalize the quotient.\n+  f7_divx (qq, aa, cst, 1 + 11);\n+\n+  // Use the smallest (by absolute value) remainder system.\n+  f7_round (qq, qq);\n+  int16_t q = f7_get_s16 (qq);\n+\n+  // Reducing A mod ln2 gives |C| <= ln2 / 2,  C = -A mod ln2.\n+  f7_msub (cc, qq, cst, aa);\n+\n+  // Corrigendum:  We added Q * ln2; now add Q times the low part of ln2\n+  // for better precision.  Due to |C| < |A| this is not a no-op in general.\n+  const f7_t *yy = F7_CONST_ADDR (ln2_low, &_var_for_ln2);\n+  f7_madd (cc, qq, yy, cc);\n+\n+  // Because we computed C = -A mod ...\n+  cc->flags ^= F7_FLAG_sign;\n+\n+  // Reduce further to |C| < ln2 / 8 which is the range of our MiniMax poly.\n+  const uint8_t MAX_LN2_RED = 3;\n+  int8_t scal2 = 0;\n+\n+  while (f7_abscmp_msb_ge (cc, F7_(const_ln2_msb),\n+\t\t\t   F7_(const_ln2_expo) - MAX_LN2_RED))\n+    {\n+      scal2++;\n+      cc->expo--;\n+    }\n+\n+  f7_horner (cc, cc, n_coeff_exp, coeff_exp, qq);\n+\n+  while (--scal2 >= 0)\n+    f7_Isquare (cc);\n+\n+  f7_Ildexp (cc, q);\n+}\n+#endif // F7MOD_exp_\n+\n+\n+#ifdef F7MOD_pow10_\n+F7_WEAK\n+void f7_pow10 (f7_t *cc, const f7_t *aa)\n+{\n+  const f7_t *p_ln10;\n+  F7_PCONST (p_ln10, ln10);\n+  f7_mul (cc, aa, p_ln10);\n+  f7_exp (cc, cc);\n+}\n+ALIAS (f7_pow10, f7_exp10)\n+#endif // F7MOD_pow10_\n+\n+\n+#ifdef F7MOD_cbrt_\n+F7_WEAK\n+void f7_cbrt (f7_t *cc, const f7_t *aa)\n+{\n+  f7_copy (cc, aa);\n+  const f7_t *p_1_3;\n+  uint8_t c_flags = cc->flags;\n+  cc->flags &= ~F7_FLAG_sign;\n+  f7_log (cc, cc);\n+  F7_PCONST (p_1_3, 1_3);\n+  f7_Imul (cc, p_1_3);\n+  f7_exp (cc, cc);\n+\n+  if (c_flags & F7_FLAG_sign)\n+    cc->flags |= F7_FLAG_sign;\n+}\n+#endif // F7MOD_cbrt_\n+\n+\n+#ifdef F7MOD_pow_\n+F7_WEAK\n+void f7_pow (f7_t *cc, const f7_t *aa, const f7_t *bb)\n+{\n+#if 0\n+  f7_t slots[cc == bb];\n+  f7_t *yy = cc == bb ? slots : cc;\n+#else\n+  f7_t yy7, *yy = &yy7;\n+#endif\n+  f7_log (yy, aa);\n+  f7_Imul (yy, bb);\n+  f7_exp (cc, yy);\n+}\n+#endif // F7MOD_pow_\n+\n+\n+#ifdef F7MOD_powi_\n+F7_WEAK\n+void f7_powi (f7_t *cc, const f7_t *aa, int ii)\n+{\n+  uint16_t u16 = ii;\n+  f7_t xx27, *xx2 = &xx27;\n+\n+  if (ii < 0)\n+    u16 = -u16;\n+\n+  f7_copy (xx2, aa);\n+\n+  f7_set_u16 (cc, 1);\n+\n+  while (1)\n+    {\n+      if (u16 & 1)\n+\tf7_Imul (cc, xx2);\n+\n+      if (! f7_is_nonzero (cc))\n+\tbreak;\n+\n+      u16 >>= 1;\n+      if (u16 == 0)\n+\tbreak;\n+      f7_Isquare (xx2);\n+    }\n+\n+  if (ii < 0)\n+    f7_div1 (xx2, aa);\n+}\n+#endif // F7MOD_powi_\n+\n+\n+#ifdef F7MOD_sincos_\n+\n+#define ARRAY_NAME coeff_sin\n+  #define FOR_SIN\n+  #include \"libf7-array.def\"\n+  #undef  FOR_SIN\n+#undef ARRAY_NAME\n+\n+#define ARRAY_NAME coeff_cos\n+  #define FOR_COS\n+  #include \"libf7-array.def\"\n+  #undef  FOR_COS\n+#undef ARRAY_NAME\n+\n+#define STATIC static\n+#include \"libf7-constdef.h\" // pi_low\n+#undef STATIC\n+\n+typedef union\n+{\n+  struct\n+  {\n+    bool    neg_sin : 1; // Must be bit F7_FLAGNO_sign.\n+    bool    neg_cos : 1;\n+    bool    do_sin: 1;\n+    bool    do_cos: 1;\n+    bool    swap_sincos : 1;\n+    uint8_t res : 3;\n+  };\n+  uint8_t bits;\n+} sincos_t;\n+\n+\n+F7_WEAK\n+void f7_sincos (f7_t *ss, f7_t *cc, const f7_t *aa)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+\n+  sincos_t sc = { .bits = a_class & F7_FLAG_sign };\n+  if (ss != NULL) sc.do_sin = 1;\n+  if (cc != NULL) sc.do_cos = 1;\n+\n+  if (f7_class_nan (a_class) || f7_class_inf (a_class))\n+    {\n+      if (sc.do_sin)  f7_set_nan (ss);\n+      if (sc.do_cos)  f7_set_nan (cc);\n+      return;\n+    }\n+\n+  f7_t pi7, *pi = &pi7;\n+  f7_t xx7, *xx = &xx7;\n+  f7_t yy7, *yy = &yy7;\n+  f7_t *hh = sc.do_sin ? ss : cc;\n+\n+  // X = |A|\n+  f7_copy (xx, aa);\n+  xx->flags = 0;\n+\n+  // Y is how often we subtract PI from X.\n+  f7_clr (yy);\n+  f7_const (pi, pi);\n+\n+  if (f7_abscmp_msb_ge (xx, F7_(const_pi_msb), F7_(const_pi_expo) + 1))\n+    {\n+      pi->expo = 1 + F7_(const_pi_expo);  // 2*pi\n+\n+      // Y = X / 2pi.\n+      f7_div (yy, xx, pi);\n+\n+      // The integral part of |A| / pi mod 2 is bit 55 - x_expo.\n+      if (yy->expo >= F7_MANT_BITS && !f7_is_zero (yy))\n+        {\n+\t  // Too big for sensible calculation:  Should this be NaN instead?\n+\t  if (sc.do_sin)  f7_clr (ss);\n+\t  if (sc.do_cos)  f7_clr (cc);\n+\t  return;\n+        }\n+\n+      // X -= 2pi * [ X / 2pi ]\n+      f7_floor (yy, yy);\n+\n+      f7_msub (xx, yy, pi, xx);\n+      xx->flags ^= F7_FLAG_sign;\n+\n+      // We divided by 2pi, but Y should count times we subtracted pi.\n+      yy->expo++;\n+    }\n+\n+  pi->expo = F7_(const_pi_expo); // pi\n+  f7_sub (hh, xx, pi);\n+  if (!f7_signbit (hh))\n+    {\n+      // H = X - pi >= 0  =>  X >= pi\n+      // sin(x) = -sin(x - pi)\n+      // cos(x) = -cos(x - pi)\n+      f7_copy (xx, hh);\n+      // Y: We subtracted pi one more time.\n+      f7_Iadd (yy, f7_set_u16 (hh, 1));\n+      sc.neg_sin ^= 1;\n+      sc.neg_cos ^= 1;\n+    }\n+\n+  pi->expo = F7_(const_pi_expo) - 1; // pi/2\n+  if (f7_gt (xx, pi))\n+    {\n+      // x > pi/2\n+      // sin(x) =  sin(pi - x)\n+      // cos(x) = -cos(pi - x)\n+      pi->expo = F7_(const_pi_expo); // pi\n+      f7_IRsub (xx, pi);\n+      // Y: We subtracted pi one more time (and then negated).\n+      f7_Iadd (yy, f7_set_u16 (hh, 1));\n+      yy->flags ^= F7_FLAG_sign;\n+      sc.neg_cos ^= 1;\n+    }\n+\n+  pi->expo = F7_(const_pi_expo) - 2; // pi/4\n+  if (f7_gt (xx, pi))\n+    {\n+      // x > pi/4\n+      // sin(x) = cos(pi/2 - x)\n+      // cos(x) = sin(pi/2 - x)\n+      pi->expo = F7_(const_pi_expo) - 1; // pi/2\n+      f7_IRsub (xx, pi);\n+      // Y: We subtracted pi/2 one more time (and then negated).\n+      f7_Iadd (yy, f7_set_1pow2 (hh, -1, 0));\n+      yy->flags ^= F7_FLAG_sign;\n+      sc.swap_sincos = 1;\n+    }\n+\n+  if (!f7_is0 (yy))\n+    {\n+      // Y counts how often we subtracted pi from X in order to\n+      // get 0 <= X < pi/4 as small as possible (Y is 0 mod 0.5).\n+      // Now also subtract the low part of pi:\n+      // f7_const_pi_low = pi - f7_const_pi  in order to get more precise\n+      // results in the cases where the final result is close to 0.\n+      const f7_t *pi_low = F7_CONST_ADDR (pi_low, pi);\n+      //f7_const (pi, pi_low);\n+      f7_Imul (yy, pi_low);\n+      f7_Isub (xx, yy);\n+    }\n+\n+  // X   in [0, pi/4].\n+  // X^2 in [0, pi^2/16] ~ [0, 0.6169]\n+\n+  f7_square (yy, xx);\n+\n+  f7_t *x_sin = xx;\n+  f7_t *x_cos = yy;\n+\n+  if ((sc.do_sin && !sc.swap_sincos)\n+      || (sc.do_cos && sc.swap_sincos))\n+    {\n+      f7_horner (hh, yy, n_coeff_sin, coeff_sin, NULL);\n+      f7_mul (x_sin, hh, xx);\n+    }\n+\n+  if ((sc.do_cos && !sc.swap_sincos)\n+      || (sc.do_sin && sc.swap_sincos))\n+    {\n+      f7_horner (x_cos, yy, n_coeff_cos, coeff_cos, hh);\n+    }\n+\n+  if (sc.swap_sincos)\n+    {\n+      x_sin = yy;\n+      x_cos = xx;\n+    }\n+\n+  if (sc.do_sin)\n+    {\n+      x_sin->flags ^= sc.bits;\n+      x_sin->flags &= F7_FLAG_sign;\n+      f7_copy (ss, x_sin);\n+    }\n+\n+  if (sc.do_cos)\n+    {\n+      x_cos->flags = sc.neg_cos;\n+      f7_copy (cc, x_cos);\n+    }\n+}\n+#endif // F7MOD_sincos_\n+\n+#ifdef F7MOD_sin_\n+F7_WEAK\n+void f7_sin (f7_t *ss, const f7_t *aa)\n+{\n+  f7_sincos (ss, NULL, aa);\n+}\n+#endif // F7MOD_sin_\n+\n+#ifdef F7MOD_cos_\n+F7_WEAK\n+void f7_cos (f7_t *cc, const f7_t *aa)\n+{\n+  f7_sincos (NULL, cc, aa);\n+}\n+#endif // F7MOD_cos_\n+\n+\n+#ifdef F7MOD_tan_\n+F7_WEAK\n+void f7_tan (f7_t *tt, const f7_t *aa)\n+{\n+  f7_t xcos;\n+  f7_sincos (tt, & xcos, aa);\n+  f7_Idiv (tt, & xcos);\n+}\n+#endif // F7MOD_tan_\n+\n+\n+#ifdef F7MOD_cotan_\n+F7_WEAK\n+void f7_cotan (f7_t *ct, const f7_t *aa)\n+{\n+  f7_t xcos;\n+  f7_sincos (ct, & xcos, aa);\n+  f7_div (ct, & xcos, ct);\n+}\n+#endif // F7MOD_cotan_\n+\n+\n+#ifdef F7MOD_sinhcosh_\n+F7_WEAK\n+void f7_sinhcosh (f7_t *cc, const f7_t *aa, bool do_sinh)\n+{\n+  f7_t xx7, *xx = &xx7;\n+  // C = exp(A)\n+  f7_exp (cc, aa);\n+  // X = exp(-A)\n+  f7_div (xx, f7_set_u16 (xx, 1), cc);\n+  // sinh(A) = (exp(A) - exp(-A)) / 2\n+  // cosh(A) = (exp(A) + exp(-A)) / 2\n+  f7_addsub (cc, cc, xx, do_sinh);\n+  cc->expo--;\n+}\n+#endif // F7MOD_sinhcosh_\n+\n+\n+#ifdef F7MOD_sinh_\n+F7_WEAK\n+void f7_sinh (f7_t *cc, const f7_t *aa)\n+{\n+  f7_sinhcosh (cc, aa, true);\n+}\n+#endif // F7MOD_sinh_\n+\n+\n+#ifdef F7MOD_cosh_\n+F7_WEAK\n+void f7_cosh (f7_t *cc, const f7_t *aa)\n+{\n+  f7_sinhcosh (cc, aa, false);\n+}\n+#endif // F7MOD_cosh_\n+\n+\n+#ifdef F7MOD_tanh_\n+F7_WEAK\n+void f7_tanh (f7_t *cc, const f7_t *aa)\n+{\n+  // tanh(A) = (exp(2A) - 1) / (exp(2A) + 1)\n+  f7_t xx7, *xx = &xx7;\n+  F7_PCONST_U16 (const f7_t *one, 1);\n+  // C = 2A\n+  f7_copy (cc, aa);\n+  cc->expo++;\n+  // C = exp(2A)\n+  f7_exp (cc, cc);\n+  // X = exp(2A) + 1\n+  f7_add (xx, cc, one);\n+  // C = exp(2A) - 1\n+  f7_Isub (cc, one);\n+  // C = tanh(A)\n+  f7_Idiv (cc, xx);\n+}\n+#endif // F7MOD_tanh_\n+\n+\n+#ifdef F7MOD_atan_\n+\n+#define MINIMAX_6_6_IN_0_1\n+\n+#define ARRAY_NAME coeff_atan_zahler\n+#define FOR_NUMERATOR\n+#include \"libf7-array.def\"\n+#undef FOR_NUMERATOR\n+#undef ARRAY_NAME\n+\n+#define ARRAY_NAME coeff_atan_nenner\n+#define FOR_DENOMINATOR\n+#include \"libf7-array.def\"\n+#undef FOR_DENOMINATOR\n+#undef ARRAY_NAME\n+\n+#include \"libf7-constdef.h\"\n+\n+F7_WEAK\n+void f7_atan (f7_t *cc, const f7_t *aa)\n+{\n+  uint8_t a_class = f7_classify (aa);\n+  uint8_t flags = a_class & F7_FLAG_sign;\n+\n+  if (f7_class_nan (a_class))\n+    return f7_set_nan (cc);\n+\n+  f7_t yy7, *yy = &yy7;\n+  f7_t zz7, *zz = &zz7;\n+\n+  if (f7_class_inf (a_class))\n+    {\n+      f7_set_u16 (cc, 0);\n+      goto do_Inf;\n+    }\n+\n+  // C = |A|\n+  f7_copy (cc, aa);\n+  cc->flags = 0;\n+\n+  if (!f7_class_zero (a_class) && cc->expo >= 0)\n+    {\n+      // C >= 1:  use  atan (x) + atan (1/x) = pi / 2  to reduce to [0, 1].\n+      flags |= 1 << 1;\n+      f7_div (cc, f7_set_u16 (yy, 1), cc);\n+    }\n+#if !defined (MINIMAX_6_6_IN_0_1)\n+  const uint8_t const_a_msb = 0x89;\n+  const int16_t const_a_expo = -2;\n+  if (f7_abscmp_msb_ge (cc, const_a_msb, const_a_expo))\n+    {\n+      // We have C in [0, 1] and we want to use argument reduction by means\n+      // of addition theorem  atan(x) - atan(y) = atan((x - y) / (1 + xy)).\n+      // We want to split [0, 1] into  [0, a] u [a, 1]  in such a way that\n+      // the upper interval will be mapped to  [-a, a].  The system is easy\n+      // to solve and yiels\n+      //    y = 1 / sqrt (3)       ~  0.57735     atan(y) = pi / 6\n+      //    a = (1 - y) / (1 + y)  ~  0.26795  ~  0x0.8930A2F * 2^-1.\n+      flags |= 1 << 2;\n+      // C <- (C - Y) / (1 + C * Y)  in  [-a, a]\n+      const f7_t *cst = F7_CONST_ADDR (1_sqrt3, zz);\n+      f7_mul (yy, cc, cst);\n+      f7_Isub (cc, cst);\n+      f7_Iadd (yy, F7_U16_ADDR (1, zz));\n+      f7_Idiv (cc, yy);\n+    }\n+#endif\n+  // C <- C * p(C^2) / q(C^2)\n+  f7_square (yy, cc);\n+  f7_horner (zz, yy, n_coeff_atan_zahler, coeff_atan_zahler, NULL);\n+  f7_Imul (zz, cc);\n+  f7_horner (cc, yy, n_coeff_atan_nenner, coeff_atan_nenner, NULL);\n+  f7_div (cc, zz, cc);\n+\n+#if !defined (MINIMAX_6_6_IN_0_1)\n+  if (flags & (1 << 2))\n+    f7_Iadd (cc, F7_CONST_ADDR (pi_6, yy));\n+#endif\n+\n+  if (flags & (1 << 1))\n+    {\n+    do_Inf:;\n+      // Y = pi / 2\n+      f7_const (yy, pi);\n+      yy->expo = F7_(const_pi_expo) - 1;\n+      f7_IRsub (cc, yy);\n+    }\n+\n+  cc->flags = a_class & F7_FLAG_sign;\n+}\n+#undef MINIMAX_6_6_IN_0_1\n+#endif // F7MOD_atan_\n+\n+\n+#ifdef F7MOD_asinacos_\n+\n+#define ARRAY_NAME coeff_func_a_zahler\n+#define FOR_NUMERATOR\n+#include \"libf7-array.def\"\n+#undef  FOR_NUMERATOR\n+#undef  ARRAY_NAME\n+\n+#define ARRAY_NAME coeff_func_a_nenner\n+#define FOR_DENOMINATOR\n+#include \"libf7-array.def\"\n+#undef  FOR_DENOMINATOR\n+#undef  ARRAY_NAME\n+\n+typedef union\n+{\n+  struct\n+  {\n+    bool    sign : 1;       // Must be bit F7_FLAGNO_sign.\n+    bool    do_acos : 1;    // From caller.\n+    bool    have_acos : 1;  // What we compute from rational approx p/q.\n+    uint8_t res : 5;\n+  };\n+  uint8_t bits;\n+} asinacos_t;\n+\n+F7_WEAK\n+void f7_asinacos (f7_t *cc, const f7_t *aa, uint8_t what)\n+{\n+  f7_t xx7, *xx = &xx7;\n+  f7_t xx27, *xx2 = &xx27;\n+\n+  asinacos_t flags = { .bits = what | f7_signbit (aa) };\n+\n+  f7_abs (xx, aa);\n+\n+  int8_t cmp = f7_cmp (xx, f7_set_u16 (cc, 1));\n+\n+  if (cmp == INT8_MIN\n+      || cmp > 0)\n+    {\n+      return f7_set_nan (cc);\n+    }\n+\n+  if (xx->expo <= -2 || f7_is_zero (xx))\n+    {\n+      // |A| < 1/2:  asin(x) = x * a(2*x^2)\n+      f7_square (xx2, xx);\n+      xx2->expo ++;\n+    }\n+  else\n+    {\n+      // |A| > 1/2: acos (1-x) = sqrt(2*x) * a(x)\n+      // C is 1 from above.\n+      f7_IRsub (xx, cc);\n+      f7_copy (xx2, xx);\n+      flags.have_acos = 1;\n+    }\n+\n+  // MiniMax [5/4] numerator.\n+  f7_horner (cc, xx2, n_coeff_func_a_zahler, coeff_func_a_zahler, NULL);\n+\n+  if (flags.have_acos)\n+    {\n+      xx->expo ++;\n+      f7_Isqrt (xx);\n+    }\n+  f7_Imul (cc, xx);\n+\n+  // MiniMax [5/4] denominator.\n+  f7_horner (xx, xx2, n_coeff_func_a_nenner, coeff_func_a_nenner, NULL);\n+\n+  f7_Idiv (cc, xx);\n+\n+  /*\n+      With the current value of C, we have:\n+\n+\t\t|\t     |\t      do_asin\t    |\t    do_acos\n+\t\t|     C\t     |\tA <= 0\t |  A >= 0  |  A <= 0  |  A >= 0\n+      ----------+------------+-----------+----------+----------+----------\n+      have_asin | asin (|A|) |\t  -C\t |    C\t    | pi/2 + C | pi/2 - C\n+      have_acos | acos (|A|) | -pi/2 + C | pi/2 - C |  pi - C  |     C\n+\n+      Result = n_pi2 * pi/2 + C * (c_sign ? -1 : 1)\n+      Result (A, do_asin) = asin (A)\n+      Result (A, do_acos) = acos (A)\n+\n+      with\n+\t  c_sign = do_acos ^ have_acos ^ a_sign\n+\t  n_pi2\t = do_acos + have_acos * (a_sign ^ do_acos) ? (-1 : 1)\n+\t  n_pi2 in { -1, 0, 1, 2 }\n+  */\n+\n+  // All what matters for c_sign is bit 0.\n+  uint8_t c_sign = flags.bits;\n+  int8_t n_pi2 = flags.do_acos;\n+  c_sign ^= flags.do_acos;\n+  if (flags.have_acos)\n+    {\n+      n_pi2++;\n+      __asm (\"\" : \"+r\" (n_pi2));\n+      if (c_sign & 1)  // c_sign & 1  =  a_sign ^ do_acos\n+\tn_pi2 -= 2;\n+      c_sign++;\n+    }\n+\n+  cc->flags = c_sign & F7_FLAG_sign;\n+\n+  if (n_pi2)\n+    {\n+      f7_const (xx, pi);\n+      if (n_pi2 < 0)\n+\txx->sign = 1;\n+      if (n_pi2 != 2)\n+\txx->expo = F7_(const_pi_expo) - 1;\n+\n+      f7_Iadd (cc, xx);\n+    }\n+}\n+#endif // F7MOD_asinacos_\n+\n+\n+#ifdef F7MOD_asin_\n+F7_WEAK\n+void f7_asin (f7_t *cc, const f7_t *aa)\n+{\n+  f7_asinacos (cc, aa, 0);\n+}\n+#endif // F7MOD_asin_\n+\n+\n+#ifdef F7MOD_acos_\n+F7_WEAK\n+void f7_acos (f7_t *cc, const f7_t *aa)\n+{\n+  f7_asinacos (cc, aa, 1 << 1);\n+}\n+#endif // F7MOD_acos_\n+\n+\n+#ifndef IN_LIBGCC2\n+\n+#ifdef F7MOD_put_C_\n+\n+#include <stdio.h>\n+#include <avr/pgmspace.h>\n+\n+static F7_INLINE\n+uint8_t f7_hex_digit (uint8_t nibble)\n+{\n+  nibble = (uint8_t) (nibble + '0');\n+  if (nibble > '9')\n+    nibble = (uint8_t) (nibble + ('a' - '0' - 10));\n+  return nibble;\n+}\n+\n+static void f7_put_hex2 (uint8_t x, FILE *stream)\n+{\n+  putc ('0', stream);\n+  if (x)\n+    {\n+      putc ('x', stream);\n+      putc (f7_hex_digit (x >> 4), stream);\n+      putc (f7_hex_digit (x & 0xf), stream);\n+    }\n+}\n+\n+#define XPUT(str) \\\n+  fputs_P (PSTR (str), stream)\n+\n+// Write to STREAM a line that is appropriate for usage in libf7-const.def.\n+\n+F7_WEAK\n+void f7_put_CDEF (const char *name, const f7_t *aa, FILE *stream)\n+{\n+  char buf[7];\n+  XPUT (\"F7_CONST_DEF (\");\n+  fputs (name, stream);\n+  XPUT (\",\\t\");\n+  uint8_t a_class = f7_classify (aa);\n+  if (! f7_class_nonzero (a_class))\n+    {\n+      f7_put_hex2 (a_class & F7_FLAGS, stream);\n+      XPUT (\",\\t0,0,0,0,0,0,0,\\t0)\");\n+      return;\n+    }\n+  putc ('0' + (a_class & F7_FLAGS), stream);\n+  XPUT (\",\\t\");\n+\n+  for (uint8_t i = 0; i < F7_MANT_BYTES; i++)\n+    {\n+      f7_put_hex2 (aa->mant[F7_MANT_BYTES-1 - i], stream);\n+      putc (',', stream);\n+    }\n+  putc ('\\t', stream);\n+\n+  itoa (aa->expo, buf, 10);\n+  fputs (buf, stream);\n+  XPUT (\")\");\n+}\n+\n+void f7_put_C (const f7_t *aa, FILE *stream)\n+{\n+  char buf[7];\n+\n+  uint8_t a_class = f7_classify (aa);\n+  if (f7_class_nan (a_class))\n+    {\n+      XPUT (\"{ .is_nan = 1 }\");\n+      return;\n+    }\n+  bool sign = a_class & F7_FLAG_sign;\n+\n+  if (f7_class_inf (a_class))\n+    {\n+      XPUT (\"{ .is_nan = 1, .sign = \");\n+      putc ('0' + sign, stream);\n+      XPUT (\" }\");\n+      return;\n+    }\n+\n+  XPUT (\"{ .sign = \");\n+  putc ('0' + sign, stream);\n+\n+  XPUT (\", .mant = { \");\n+  for (uint8_t i = 0; i < F7_MANT_BYTES; i++)\n+    {\n+      f7_put_hex2 (aa->mant[F7_MANT_BYTES-1 - i], stream);\n+      if (i != F7_MANT_BYTES - 1)\n+\tputc (',', stream);\n+    }\n+\n+  XPUT (\" }, .expo = \");\n+  itoa (aa->expo, buf, 10);\n+  fputs (buf, stream);\n+  XPUT (\" }\");\n+}\n+#endif //F7MOD_put_C_\n+\n+\n+#ifdef F7MOD_dump_\n+\n+#include <avr/pgmspace.h>\n+\n+#ifndef AVRTEST_H\n+\n+#include <stdio.h>\n+\n+static void LOG_PSTR (const char *str)\n+{\n+  fputs_P (str, stdout);\n+}\n+\n+static void LOG_PFMT_U16 (const char *fmt, uint16_t x)\n+{\n+  printf_P (fmt, x);\n+}\n+\n+static void LOG_PFMT_FLOAT (const char *fmt, float x)\n+{\n+  printf_P (fmt, x);\n+}\n+\n+#define LOG_X8(X)               LOG_PFMT_U16 (PSTR (\" 0x%02x \"), (uint8_t)(X))\n+#define LOG_PFMT_S16(FMT, X)    LOG_PFMT_U16 (FMT, (unsigned)(X))\n+#define LOG_PFMT_ADDR(FMT, X)   LOG_PFMT_U16 (FMT, (unsigned)(X))\n+\n+#endif // AVRTEST_H\n+\n+static void dump_byte (uint8_t b)\n+{\n+  LOG_PSTR (PSTR (\" \"));\n+  for (uint8_t i = 0; i < 8; i++)\n+    {\n+      LOG_PSTR ((b & 0x80) ? PSTR (\"1\") : PSTR (\"0\"));\n+      b = (uint8_t) (b << 1);\n+    }\n+}\n+\n+void f7_dump_mant (const f7_t *aa)\n+{\n+  LOG_PSTR (PSTR (\"\\tmant   =\"));\n+  for (int i = F7_MANT_BYTES - 1; i >= 0; i--)\n+    LOG_X8 (aa->mant[i]);\n+  LOG_PSTR (PSTR (\"\\n\\t       =\"));\n+\n+  for (int i = F7_MANT_BYTES - 1; i >= 0; i--)\n+    dump_byte (aa->mant[i]);\n+  LOG_PSTR (PSTR (\"\\n\"));\n+}\n+\n+void f7_dump (const f7_t *aa)\n+{\n+  LOG_PFMT_ADDR (PSTR (\"\\n0x%04x\\tflags  = \"), aa);\n+  dump_byte (aa->flags);\n+  uint8_t a_class = f7_classify (aa);\n+  LOG_PSTR (PSTR (\"  = \"));\n+  LOG_PSTR (f7_class_sign (a_class) ? PSTR (\"-\") : PSTR (\"+\"));\n+  if (f7_class_inf (a_class))    LOG_PSTR (PSTR (\"Inf \"));\n+  if (f7_class_nan (a_class))    LOG_PSTR (PSTR (\"NaN \"));\n+  if (f7_class_zero (a_class))   LOG_PSTR (PSTR (\"0 \"));\n+  if (f7_class_number (a_class)) LOG_PSTR (PSTR (\"Number \"));\n+\n+  LOG_PFMT_FLOAT (PSTR (\" = %.10g\\n\"), f7_get_float (aa));\n+  LOG_PFMT_S16 (PSTR (\"\\texpo   = %d\\n\"), aa->expo);\n+\n+  f7_dump_mant (aa);\n+}\n+#endif // F7MOD_dump_\n+\n+#endif // ! libgcc\n+\n+#endif // !AVR_TINY"}, {"sha": "73eafe08630f30f13956f894a497506352cf20c0", "filename": "libgcc/config/avr/libf7/libf7.h", "status": "added", "additions": 687, "deletions": 0, "changes": 687, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Flibf7.h?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,687 @@\n+/* Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of LIBF7, which is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBF7_H\n+#define LIBF7_H\n+#define IN_LIBF7_H\n+\n+#include \"f7-renames.h\"\n+\n+#define F7_MANT_BYTES 7\n+#define F7_MANT_BITS (8 * F7_MANT_BYTES)\n+\n+/*  Using the following GCC features:\n+    --  Unnamed structs / unions (GNU-C)\n+    --  Fixed-point types (GNU-C)\n+    --  Inline asm\n+    --  Setting assembler names by means of __asm (GNU-C).\n+    --  Attributes: alias, always_inline, const, noinline, unused,\n+                    progmem, pure, weak, warning\n+    --  GCC built-ins: __builtin_abort, __builtin_constant_p\n+    --  AVR built-ins: __builtin_avr_bitsr, __builtin_avr_rbits\n+*/\n+\n+/* We have 2 kinds of flags:\n+\n+   A)  The flags that are stored in f7_t.flags:\n+       --  f7_t.is_nan (NaN)\n+       --  f7_t.is_inf (+Inf or -Inf)\n+       --  f7_t.sign (negative or -Inf).\n+\n+   B)  The flags that are returned by f7_classify().  This are the\n+       flags from A) together with\n+       --  _zero: indicate that a number is zero.\n+*/\n+\n+#define F7_FLAGNO_sign  0\n+#define F7_FLAGNO_zero  1\n+#define F7_FLAGNO_nan   2\n+#define F7_FLAGNO_inf   7\n+\n+#define F7_HAVE_Inf 1\n+\n+// Flags that might be set by f7_classify().\n+#define F7_FLAG_sign            (1 << F7_FLAGNO_sign)\n+#define F7_FLAG_zero            (1 << F7_FLAGNO_zero)\n+#define F7_FLAG_nan             (1 << F7_FLAGNO_nan)\n+#define F7_FLAG_inf   (F7_HAVE_Inf << F7_FLAGNO_inf)\n+\n+// Flags that might be set in f7_t.flags.\n+#define F7_FLAGS (F7_FLAG_inf | F7_FLAG_nan | F7_FLAG_sign)\n+\n+#if !defined __ASSEMBLER__\n+\n+#ifndef IN_LIBGCC2\n+#include <stdint.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#else\n+/* Do not assume that we have std headers when we build libgcc.  */\n+\n+typedef __UINT64_TYPE__ uint64_t;\n+typedef __UINT32_TYPE__ uint32_t;\n+typedef __UINT16_TYPE__ uint16_t;\n+typedef __UINT8_TYPE__  uint8_t;\n+typedef __INT64_TYPE__ int64_t;\n+typedef __INT32_TYPE__ int32_t;\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT8_TYPE__  int8_t;\n+typedef _Bool bool;\n+#define false 0\n+#define true  1\n+#define INT8_MIN  (-1 - __INT8_MAX__)\n+#define INT16_MAX __INT16_MAX__\n+#define NULL ((void*) 0)\n+#endif /* IN_LIBGCC2 */\n+\n+#include \"asm-defs.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#define _Static_assert(X, Y) static_assert (X)\n+#endif // C++\n+\n+#define F7_INLINE   inline __attribute__((__always_inline__))\n+#define F7_NOINLINE __attribute__((__noinline__))\n+#define F7_WEAK     __attribute__((__weak__))\n+#define F7_PURE     __attribute__((__pure__))\n+#define F7_UNUSED   __attribute__((__unused__))\n+#define F7_CONST    __attribute__((__const__))\n+\n+#define F7_STRINGY2(X)  #X\n+#define F7_STRINGY(X)   F7_STRINGY2(X)\n+#define F7ASM(X)        __asm (F7_STRINGY2(X))\n+\n+typedef struct f7_t\n+{\n+  union\n+  {\n+    struct\n+    {\n+      uint8_t sign        :1;\n+      uint8_t reserved1   :1;\n+      uint8_t is_nan      :1;\n+      uint8_t reserved2   :4;\n+      uint8_t is_inf      :1;\n+    };\n+    uint8_t flags;\n+  };\n+\n+  uint8_t mant[7];\n+  int16_t expo;\n+} f7_t;\n+\n+typedef uint64_t f7_double_t;\n+\n+#define F7_MANT_HI4(X) \\\n+  (*(uint32_t*) & (X)->mant[F7_MANT_BYTES - 4])\n+\n+#define F7_MANT_CONST_HI4(X) \\\n+  (*(const uint32_t*) & (X)->mant[F7_MANT_BYTES - 4])\n+\n+#define F7_MANT_HI2(X) \\\n+  (*(uint16_t*) & (X)->mant[F7_MANT_BYTES - 2])\n+\n+static F7_INLINE F7_PURE\n+uint8_t f7_classify (const f7_t *aa)\n+{\n+  extern void f7_classify_asm (void);\n+  register uint8_t rclass __asm (\"r24\");\n+  __asm (\"%~call %x[f]\"\n+\t : \"=r\" (rclass)\n+\t : [f] \"i\" (f7_classify_asm), \"z\" (aa));\n+  return rclass;\n+}\n+\n+\n+// +Inf or -Inf\n+static F7_INLINE\n+bool f7_class_inf (uint8_t c)\n+{\n+#if defined (F7_HAVE_Inf) && F7_HAVE_Inf == 1\n+  return c >= F7_FLAG_inf;\n+#elif defined (F7_HAVE_Inf) && F7_HAVE_Inf == 0\n+  (void) c;\n+  return false;\n+#else\n+#error macro F7_HAVE_Inf must be defined to 0 or to 1.\n+#endif // Have Inf\n+}\n+\n+static F7_INLINE\n+bool f7_is_inf (const f7_t *aa)\n+{\n+  return f7_class_inf (aa->flags);\n+}\n+\n+// Not-a-Number (NaN).\n+static F7_INLINE\n+bool f7_class_nan (uint8_t c)\n+{\n+  return c & F7_FLAG_nan;\n+}\n+\n+static F7_INLINE\n+bool f7_is_nan (const f7_t *aa)\n+{\n+  return f7_class_nan (aa->flags);\n+}\n+\n+// Some number\n+static F7_INLINE\n+bool f7_class_number (uint8_t c)\n+{\n+  return c <= (F7_FLAG_sign | F7_FLAG_zero);\n+}\n+\n+static F7_INLINE\n+bool f7_is_number (const f7_t *aa)\n+{\n+  return f7_class_number (f7_classify (aa));\n+}\n+\n+// Zero\n+static F7_INLINE\n+bool f7_class_zero (uint8_t c)\n+{\n+  return c & F7_FLAG_zero;\n+}\n+\n+static F7_INLINE\n+bool f7_is_zero (const f7_t *aa)\n+{\n+  return f7_class_zero (f7_classify (aa));\n+}\n+\n+// A non-zero number.\n+static F7_INLINE\n+bool f7_class_nonzero (uint8_t c)\n+{\n+  return c <= F7_FLAG_sign;\n+}\n+\n+static F7_INLINE\n+bool f7_is_nonzero (const f7_t *aa)\n+{\n+  return f7_class_nonzero (f7_classify (aa));\n+}\n+\n+static F7_INLINE\n+bool f7_class_sign (uint8_t c)\n+{\n+  return c & F7_FLAG_sign;\n+}\n+\n+static F7_INLINE\n+bool f7_signbit (const f7_t *aa)\n+{\n+  return aa->flags & F7_FLAG_sign;\n+}\n+\n+static F7_INLINE\n+void f7_set_sign (f7_t *cc, bool sign)\n+{\n+  _Static_assert (F7_FLAGNO_sign == 0, \"\");\n+  cc->flags &= ~F7_FLAG_sign;\n+  cc->flags |= sign;\n+}\n+\n+static F7_INLINE\n+void f7_set_nan (f7_t *cc)\n+{\n+  cc->flags = F7_FLAG_nan;\n+}\n+\n+static F7_INLINE\n+void f7_clr (f7_t *cc)\n+{\n+  extern void f7_clr_asm (void);\n+  __asm (\"%~call %x[f]\"\n+\t :\n+\t : [f] \"i\" (f7_clr_asm), \"z\" (cc)\n+\t : \"memory\");\n+}\n+\n+static F7_INLINE\n+f7_t* f7_copy (f7_t *cc, const f7_t *aa)\n+{\n+  extern void f7_copy_asm (void);\n+  __asm (\"%~call %x[f]\"\n+\t :\n+\t : [f] \"i\" (f7_copy_asm), \"z\" (cc), \"x\" (aa)\n+\t : \"memory\");\n+  return cc;\n+}\n+\n+static F7_INLINE\n+f7_t* f7_copy_P (f7_t *cc, const f7_t *aa)\n+{\n+  extern void f7_copy_P_asm (void);\n+  __asm (\"%~call %x[f]\"\n+\t :\n+\t : [f] \"i\" (f7_copy_P_asm), \"x\" (cc), \"z\" (aa)\n+\t : \"memory\");\n+  return cc;\n+}\n+\n+static F7_INLINE\n+void f7_copy_mant (f7_t *cc, const f7_t *aa)\n+{\n+  extern void f7_copy_mant_asm (void);\n+  __asm (\"%~call %x[f]\"\n+\t :\n+\t : [f] \"i\" (f7_copy_mant_asm), \"z\" (cc), \"x\" (aa)\n+\t : \"memory\");\n+}\n+\n+static F7_INLINE\n+void f7_set_inf (f7_t *cc, bool sign)\n+{\n+#if F7_HAVE_Inf == 1\n+  cc->flags = F7_FLAG_inf | sign;\n+#else\n+  (void) sign;\n+  cc->flags = F7_FLAG_nan;\n+#endif // Have Inf\n+}\n+\n+\n+static F7_INLINE\n+bool f7_msbit (const f7_t *aa)\n+{\n+  return aa->mant[F7_MANT_BYTES - 1] & 0x80;\n+}\n+\n+// Quick test against 0 if A is known to be a number (neither NaN nor Inf).\n+static F7_INLINE\n+bool f7_is0 (const f7_t *aa)\n+{\n+  return 0 == f7_msbit (aa);\n+}\n+\n+\n+static F7_INLINE\n+int8_t f7_cmp_mant (const f7_t *aa, const f7_t *bb)\n+{\n+  extern void f7_cmp_mant_asm (void);\n+  register int8_t r24 __asm (\"r24\");\n+  __asm (\"%~call %x[f] ;; %1 %3\"\n+\t : \"=r\" (r24)\n+\t : [f] \"i\" (f7_cmp_mant_asm), \"x\" (aa), \"z\" (bb));\n+  return r24;\n+}\n+\n+static F7_INLINE\n+bool f7_store_expo (f7_t *cc, int16_t expo)\n+{\n+  extern void f7_store_expo_asm (void);\n+  register bool r24 __asm (\"r24\");\n+  register int16_t rexpo __asm (\"r24\") = expo;\n+  __asm (\"%~call %x[f] ;; %0 %2 %3\"\n+\t : \"=r\" (r24)\n+\t : [f] \"i\" (f7_store_expo_asm), \"z\" (cc), \"r\" (rexpo));\n+  return r24;\n+}\n+\n+static F7_INLINE\n+f7_t* f7_abs (f7_t *cc, const f7_t *aa)\n+{\n+  f7_copy (cc, aa);\n+  f7_set_sign (cc, 0);\n+\n+  return cc;\n+}\n+\n+\n+F7_PURE extern int8_t f7_cmp (const f7_t*, const f7_t*);\n+F7_PURE extern bool f7_lt_impl (const f7_t*, const f7_t*);\n+F7_PURE extern bool f7_le_impl (const f7_t*, const f7_t*);\n+F7_PURE extern bool f7_gt_impl (const f7_t*, const f7_t*);\n+F7_PURE extern bool f7_ge_impl (const f7_t*, const f7_t*);\n+F7_PURE extern bool f7_ne_impl (const f7_t*, const f7_t*);\n+F7_PURE extern bool f7_eq_impl (const f7_t*, const f7_t*);\n+F7_PURE extern bool f7_unord_impl (const f7_t*, const f7_t*);\n+\n+static F7_INLINE\n+bool f7_lt (const f7_t *aa, const f7_t *bb)\n+{\n+  return 2 & f7_cmp (aa, bb);\n+}\n+\n+static F7_INLINE\n+bool f7_gt (const f7_t *aa, const f7_t *bb)\n+{\n+  return 1 == f7_cmp (aa, bb);\n+}\n+\n+static F7_INLINE\n+bool f7_le (const f7_t *aa, const f7_t *bb)\n+{\n+  int8_t c = f7_cmp (aa, bb);\n+  return (uint8_t) (c + 1) <= 1;\n+}\n+\n+static F7_INLINE\n+bool f7_ge (const f7_t *aa, const f7_t *bb)\n+{\n+  return f7_cmp (aa, bb) >= 0;\n+}\n+\n+static F7_INLINE\n+bool f7_unordered (const f7_t *aa, const f7_t *bb)\n+{\n+  return INT8_MIN == f7_cmp (aa, bb);\n+}\n+\n+static F7_INLINE\n+bool f7_ordered (const f7_t *aa, const f7_t *bb)\n+{\n+  return INT8_MIN != f7_cmp (aa, bb);\n+}\n+\n+static F7_INLINE\n+bool f7_eq (const f7_t *aa, const f7_t *bb)\n+{\n+  return 0 == f7_cmp (aa, bb);\n+}\n+\n+static F7_INLINE\n+bool f7_ne (const f7_t *aa, const f7_t *bb)\n+{\n+  return 1 & f7_cmp (aa, bb);\n+}\n+\n+extern void f7_clr (f7_t*);\n+\n+__attribute__((warning (\"foo_u16\"))) void foo_u16 (void);\n+__attribute__((warning (\"foo_s16\"))) void foo_s16 (void);\n+\n+extern f7_t* f7_set_s16_impl (f7_t*, int16_t);\n+extern f7_t* f7_set_u16_impl (f7_t*, uint16_t);\n+\n+static F7_INLINE\n+f7_t* f7_set_u16_worker (f7_t *cc, uint16_t u16)\n+{\n+  if (__builtin_constant_p (u16))\n+    {\n+      if (u16 == 0)\n+\treturn cc;\n+\n+      uint8_t off = __builtin_clz (u16);\n+      if (15 - off)\n+\t* (uint8_t*) & cc->expo = (uint8_t) (15 - off);\n+      u16 <<= off;\n+      if (u16 & 0xff)\n+\tcc->mant[5] = (uint8_t) u16;\n+      if (u16 & 0xff00)\n+\tcc->mant[6] = (uint8_t) (u16 >> 8);\n+\n+      return cc;\n+    }\n+  else\n+    {\n+      foo_u16();\n+      __builtin_abort();\n+      return NULL;\n+    }\n+}\n+\n+static F7_INLINE\n+f7_t* f7_set_u16 (f7_t *cc, uint16_t u16)\n+{\n+  if (__builtin_constant_p (u16))\n+    {\n+      f7_clr (cc);\n+      return f7_set_u16_worker (cc, u16);\n+    }\n+\n+  return f7_set_u16_impl (cc, u16);\n+}\n+\n+static F7_INLINE\n+f7_t* f7_set_s16 (f7_t *cc, int16_t s16)\n+{\n+  if (__builtin_constant_p (s16))\n+    {\n+      f7_clr (cc);\n+\n+      uint16_t u16 = (uint16_t) s16;\n+\n+      if (s16 < 0)\n+        {\n+\t  u16 = -u16;\n+\t  cc->flags = F7_FLAG_sign;\n+        }\n+\n+      return f7_set_u16_worker (cc, u16);\n+    }\n+\n+  return f7_set_s16_impl (cc, s16);\n+}\n+\n+static F7_INLINE\n+void f7_set_eps (f7_t *cc, uint8_t eps, bool sign)\n+{\n+  cc = f7_set_u16 (cc, 1);\n+  if (!__builtin_constant_p (sign) || sign)\n+    cc->flags = sign;\n+  cc->mant[0] = eps;\n+}\n+\n+static F7_INLINE\n+f7_t* f7_set_1pow2 (f7_t *cc, int16_t expo, bool sign)\n+{\n+  cc = f7_set_u16 (cc, 1);\n+  cc->expo = expo;\n+  if (!__builtin_constant_p (sign) || sign)\n+    cc->flags = sign;\n+  return cc;\n+}\n+\n+static F7_INLINE\n+f7_t* f7_set_u64 (f7_t *cc, uint64_t u64)\n+{\n+  extern f7_t* f7_set_u64_asm (uint64_t, f7_t*);\n+  return f7_set_u64_asm (u64, cc);\n+}\n+\n+static F7_INLINE\n+f7_t* f7_set_s64 (f7_t *cc, int64_t s64)\n+{\n+  extern f7_t* f7_set_s64_asm (int64_t, f7_t*);\n+  return f7_set_s64_asm (s64, cc);\n+}\n+\n+extern void f7_set_double_impl (f7_double_t, f7_t*);\n+static F7_INLINE\n+void f7_set_double (f7_t *cc, f7_double_t val64)\n+{\n+  f7_set_double_impl (val64, cc);\n+}\n+\n+extern f7_t* f7_init_impl (uint64_t, uint8_t, f7_t*, int16_t);\n+\n+static F7_INLINE\n+f7_t* f7_init (f7_t *cc, uint8_t flags, uint64_t mant, int16_t expo)\n+{\n+  return f7_init_impl (mant, flags, cc, expo);\n+}\n+\n+extern f7_t* f7_set_s32 (f7_t*, int32_t);\n+extern f7_t* f7_set_u16 (f7_t*, uint16_t);\n+extern f7_t* f7_set_u32 (f7_t*, uint32_t);\n+extern void f7_set_float (f7_t*, float);\n+extern void f7_set_pdouble (f7_t*, const f7_double_t*);\n+\n+F7_PURE extern int16_t f7_get_s16 (const f7_t*);\n+F7_PURE extern int32_t f7_get_s32 (const f7_t*);\n+F7_PURE extern int64_t f7_get_s64 (const f7_t*);\n+F7_PURE extern uint16_t f7_get_u16 (const f7_t*);\n+F7_PURE extern uint32_t f7_get_u32 (const f7_t*);\n+F7_PURE extern uint64_t f7_get_u64 (const f7_t*);\n+F7_PURE extern float f7_get_float (const f7_t*);\n+F7_PURE extern f7_double_t f7_get_double (const f7_t*);\n+\n+#if USE_LPM == 1\n+  #define F7_PGMSPACE     __attribute__((__progmem__))\n+  #define f7_copy_flash   f7_copy_P\n+\n+  #define f7_const(X, NAME) \\\n+    f7_copy_P ((X), & F7_(const_ ## NAME ## _P))\n+\n+  #define F7_CONST_DEF(NAME, FLAGS, M0, M1, M2, M3, M4, M5, M6, EXPO) \\\n+    extern const f7_t F7_(const_ ## NAME ## _P);\n+  #include \"libf7-const.def\"\n+  #undef F7_CONST_DEF\n+#else\n+  #define F7_PGMSPACE     // Empty\n+  #define f7_copy_flash   f7_copy\n+\n+  #define f7_const(X, NAME) \\\n+    f7_copy ((X), & F7_(const_ ## NAME))\n+\n+  #define F7_CONST_DEF(NAME, FLAGS, M0, M1, M2, M3, M4, M5, M6, EXPO) \\\n+    extern const f7_t F7_(const_ ## NAME);\n+  #include \"libf7-const.def\"\n+  #undef F7_CONST_DEF\n+#endif // USE_LPM\n+\n+\n+// Basic floating point arithmetic:\n+// double output <=> f7_t*\n+// double input  <=> const f7_t*\n+extern f7_t* f7_neg (f7_t*, const f7_t*);\n+extern void f7_add (f7_t*, const f7_t*, const f7_t*);\n+extern void f7_sub (f7_t*, const f7_t*, const f7_t*);\n+extern void f7_mul (f7_t*, const f7_t*, const f7_t*);\n+extern void f7_div (f7_t*, const f7_t*, const f7_t*);\n+\n+// Analogies of functions from math.h:\n+// double output <=> f7_t*\n+// double input  <=> const f7_t*\n+extern void f7_fabs (f7_t*, const f7_t*);\n+extern void f7_fmod (f7_t*, const f7_t*, const f7_t*);\n+extern void f7_frexp (f7_t*, const f7_t*, int*);\n+extern void f7_exp (f7_t*, const f7_t*);\n+extern void f7_log (f7_t*, const f7_t*);\n+extern void f7_pow (f7_t*, const f7_t*, const f7_t*);\n+extern void f7_sqrt (f7_t*, const f7_t*);\n+extern void f7_cbrt (f7_t*, const f7_t*);\n+extern void f7_hypot (f7_t*, const f7_t*, const f7_t*);\n+extern f7_t* f7_ldexp (f7_t*, const f7_t*, int);\n+extern f7_t* f7_fmax (f7_t*, const f7_t*, const f7_t*);\n+extern f7_t* f7_fmin (f7_t*, const f7_t*, const f7_t*);\n+extern f7_t* f7_trunc (f7_t*, const f7_t*);\n+extern f7_t* f7_floor (f7_t*, const f7_t*);\n+extern void f7_ceil (f7_t*, const f7_t*);\n+extern void f7_round (f7_t*, const f7_t*);\n+extern void f7_sin (f7_t*, const f7_t*);\n+extern void f7_cos (f7_t*, const f7_t*);\n+extern void f7_tan (f7_t*, const f7_t*);\n+extern void f7_atan (f7_t*, const f7_t*);\n+extern void f7_asin (f7_t*, const f7_t*);\n+extern void f7_acos (f7_t*, const f7_t*);\n+extern void f7_tanh (f7_t*, const f7_t*);\n+extern void f7_sinh (f7_t*, const f7_t*);\n+extern void f7_cosh (f7_t*, const f7_t*);\n+extern void f7_log2 (f7_t*, const f7_t*);\n+extern void f7_log10 (f7_t*, const f7_t*);\n+extern void f7_exp10 (f7_t*, const f7_t*);\n+extern void f7_pow10 (f7_t*, const f7_t*);\n+\n+// Just prototypes, not implemented yet.\n+extern void f7_atan2 (f7_t*, const f7_t*, const f7_t*);\n+extern long f7_lrint (const f7_t*);\n+extern long f7_lround (const f7_t*);\n+\n+// Helper functions, aliases, convenience.\n+extern void f7_div1 (f7_t*, const f7_t*);\n+extern void f7_square (f7_t*, const f7_t*);\n+\n+extern void f7_powi (f7_t*, const f7_t*, int);\n+extern f7_t* f7_max (f7_t*, const f7_t*, const f7_t*);\n+extern f7_t* f7_min (f7_t*, const f7_t*, const f7_t*);\n+extern f7_t* f7_truncx (f7_t*, const f7_t*, bool);\n+extern void f7_cotan (f7_t*, const f7_t*);\n+extern void f7_sincos (f7_t*, f7_t*, const f7_t*);\n+extern void f7_asinacos (f7_t*, const f7_t*, uint8_t);\n+extern void f7_sinhcosh (f7_t*, const f7_t*, bool);\n+\n+extern void f7_horner (f7_t*, const f7_t*, uint8_t, const f7_t *coeff, f7_t*);\n+extern void f7_mul_noround (f7_t*, const f7_t*, const f7_t*);\n+extern void f7_clr_mant_lsbs (f7_t*, const f7_t*, uint8_t) F7ASM(f7_clr_mant_lsbs_asm);\n+\n+F7_PURE extern int8_t f7_cmp_unordered (const f7_t*, const f7_t*, bool);\n+F7_PURE extern int8_t f7_cmp_abs (const f7_t*, const f7_t*);\n+\n+F7_PURE extern bool f7_abscmp_msb_ge (const f7_t*, uint8_t msb, int16_t expo);\n+extern void f7_addsub (f7_t*, const f7_t*, const f7_t*, bool neg_b);\n+extern void f7_madd_msub (f7_t*, const f7_t*, const f7_t*, const f7_t*, bool);\n+extern void f7_madd (f7_t*, const f7_t*, const f7_t*, const f7_t*);\n+extern void f7_msub (f7_t*, const f7_t*, const f7_t*, const f7_t*);\n+extern uint8_t f7_mulx (f7_t*, const f7_t*, const f7_t*, bool);\n+extern void f7_divx (f7_t*, const f7_t*, const f7_t*, uint8_t);\n+extern void f7_logx (f7_t*, const f7_t*, const f7_t*);\n+extern f7_t* f7_minmax (f7_t*, const f7_t*, const f7_t*, bool);\n+\n+// Idem:\n+//    f7_Ifunc (y)    = f7_func (y, y)\n+//    f7_Ifunc (y, x) = f7_func (y, y, x)\n+extern void f7_Iadd (f7_t*, const f7_t*);\n+extern void f7_Isub (f7_t*, const f7_t*);\n+extern void f7_Imul (f7_t*, const f7_t*);\n+extern void f7_Idiv (f7_t*, const f7_t*);\n+extern void f7_IRsub (f7_t*, const f7_t*);\n+extern void f7_Ineg (f7_t*);\n+extern void f7_Isqrt (f7_t*);\n+extern void f7_Isquare (f7_t*);\n+extern f7_t* f7_Ildexp (f7_t*, int);\n+\n+// Protoypes for some functions from libf7-asm.sx.\n+F7_CONST extern uint16_t f7_sqrt16_round (uint16_t) F7ASM(f7_sqrt16_round_asm);\n+F7_CONST extern uint8_t  f7_sqrt16_floor (uint16_t) F7ASM(f7_sqrt16_floor_asm);\n+extern void f7_addsub_mant_scaled_asm (f7_t*, const f7_t*, const f7_t*, uint8_t);\n+extern uint8_t f7_mul_mant_asm (f7_t*, const f7_t*, const f7_t*, uint8_t);\n+extern void f7_sqrt_approx_asm (f7_t*, const f7_t*);\n+extern uint64_t f7_lshrdi3 (uint64_t, uint8_t) F7ASM(f7_lshrdi3_asm);\n+extern uint64_t f7_ashldi3 (uint64_t, uint8_t) F7ASM(f7_ashldi3_asm);\n+// Normalize a non-Inf, non-NaN value.  Sets .sign to 0.\n+extern f7_t* f7_normalize_asm (f7_t*);\n+\n+// Dumping.\n+#ifndef IN_LIBGCC2\n+extern void f7_dump (const f7_t*);\n+extern void f7_dump_mant (const f7_t*);\n+extern void f7_put_C (const f7_t*, FILE*);\n+extern void f7_put_CDEF (const char *name, const f7_t*, FILE*);\n+#endif /* IN_LIBGCC2 */\n+\n+#ifdef __cplusplus\n+} // extern \"C\"\n+#include \"libf7-class.h\"\n+#endif // C++\n+\n+#endif /* __ASSEMBLER__ */\n+#undef IN_LIBF7_H\n+#endif /* LIBF7_H */"}, {"sha": "92a27eb712518d77fb2670c083bef54663661d4a", "filename": "libgcc/config/avr/libf7/t-libf7", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,159 @@\n+# Used except --with-libf7=no\n+\n+avrsrc := $(srcdir)/config/avr\n+\n+libf7 := $(avrsrc)/libf7\n+\n+F7_PREFIX = __f7_\n+\n+include $(libf7)/libf7-common.mk\n+\n+LIBF7_DF_CONV +=  floatundidf floatdidf # floatunsidf floatsidf\n+\n+# Wrappers like f7_lt_impl for f7_lt etc. because the latter is inline.\n+LIBF7_DF_CMP  += lt le gt ge ne eq unord\n+\n+F7_C_PARTS += $(LIBF7_DF_CONV) $(LIBF7_DF_CMP)\n+\n+# -mcall-prologues\n+CALL_PROLOGUES += $(LIBF7_DF_CONV)\n+\n+# -Wno-missing-prototypes\n+NO_PROTO += $(LIBF7_DF_CONV)\n+\n+F7F += le_impl lt_impl gt_impl ge_impl ne_impl eq_impl unord_impl\n+\n+\n+$(libf7)/f7-renames.h: $(libf7)/f7renames.sh $(libf7)/libf7-common.mk\n+\t$< head $(F7_PREFIX) t-libf7    > $@\n+\t$< c    $(F7_PREFIX) $(F7F)     >> $@\n+\t$< cst  $(F7_PREFIX) $(F7F_cst) >> $@\n+\t$< asm  $(F7_PREFIX) $(F7F_asm) >> $@\n+\t$< tail $(F7_PREFIX)            >> $@\n+\n+# The right-hand sides like g_ddd come from libf7-common.mk.\n+# The _m_ wraps are added by t-libf7-math\n+\n+# __adddf3, ...\n+F7_ASM_WRAPS_g_ddd += $(g_ddd)\n+\n+# __ltdf2, ...\n+F7_ASM_WRAPS_g_xdd_cmp += $(g_xdd_cmp)\n+\n+# __floatsidf, ...\n+F7_ASM_WRAPS_g_dx += $(g_dx)\n+\n+# __fixdfsi, ...\n+F7_ASM_WRAPS_g_xd += $(g_xd)\n+\n+$(libf7)/f7-wraps.h: $(libf7)/f7wraps.sh \\\n+\t\t$(libf7)/libf7-common.mk $(libf7)/t-libf7-math\n+\t$< header \"WITH_LIBF7_MATH_FUNCTIONS=$(WITH_LIBF7_MATH_FUNCTIONS)\" \"WITH_LIBF7_MATH_SYMBOLS=$(WITH_LIBF7_MATH_SYMBOLS)\" > $@\n+\t$< ddd_libgcc     $(F7_ASM_WRAPS_g_ddd)      >> $@\n+\t$< xdd_libgcc_cmp $(F7_ASM_WRAPS_g_xdd_cmp)  >> $@\n+\t$< xd_libgcc      $(F7_ASM_WRAPS_g_xd)       >> $@\n+\t$< dx_libgcc      $(F7_ASM_WRAPS_g_dx)       >> $@\n+\t$< ddd_math       $(F7_ASM_WRAPS_m_ddd)      >> $@\n+\t$< ddx_math       $(F7_ASM_WRAPS_m_ddx)      >> $@\n+\t$< dd_math        $(F7_ASM_WRAPS_m_dd)       >> $@\n+\t$< xd_math        $(F7_ASM_WRAPS_m_xd)       >> $@\n+\n+F7_ASM_WRAPS += $(F7_ASM_WRAPS_g_xd)\n+F7_ASM_WRAPS += $(F7_ASM_WRAPS_g_dx)\n+F7_ASM_WRAPS += $(F7_ASM_WRAPS_g_ddd)\n+F7_ASM_WRAPS += $(F7_ASM_WRAPS_g_xdd_cmp)\n+F7_ASM_WRAPS += $(F7_ASM_WRAPS_m_ddd)\n+F7_ASM_WRAPS += $(F7_ASM_WRAPS_m_ddx)\n+F7_ASM_WRAPS += $(F7_ASM_WRAPS_m_dd)\n+F7_ASM_WRAPS += $(F7_ASM_WRAPS_m_xd)\n+\n+F7_ASM_PARTS += $(patsubst %, D_%, $(F7_ASM_WRAPS))\n+\n+# Options\n+F7_FLAGS   += -I $(libf7) -save-temps=obj\n+\n+# t-avr::HOST_LIBGCC2_CFLAGS sets -mcall-prologues which will inhibits\n+# tail-call optimizations.  The user could get it with -mrelax, but we\n+# just switch it off here and then explicitly on again for the\n+# CALL_PROLOGUES modules.\n+\n+F7_C_FLAGS +=   $(F7_FLAGS) \\\n+\t\t-dp -g0 \\\n+\t\t-mno-call-prologues \\\n+\t\t-fno-lto -Os \\\n+\t\t-fdata-sections -ffunction-sections \\\n+\t\t-fno-reorder-blocks \\\n+\t\t-fno-tree-loop-optimize \\\n+\t\t-fno-tree-loop-im -fno-move-loop-invariants\n+\n+F7_ASM_FLAGS +=\t$(F7_FLAGS)\n+\n+$(patsubst %, f7_c_%.o, $(CALL_PROLOGUES)) \\\n+\t: F7_C_FLAGS += -mcall-prologues\n+\n+$(patsubst %, f7_c_%.o, $(STRICT_X)) \\\n+\t: F7_C_FLAGS += -mstrict-X\n+\n+$(patsubst %, f7_c_%.o, $(NO_PROTO)) \\\n+\t: F7_C_FLAGS += -Wno-missing-prototypes\n+\n+# Depends will be worked out by the libgcc build system.\n+\n+F7_C_OBJECTS   = $(patsubst %, f7_c_%$(objext),   $(F7_C_PARTS))\n+F7_ASM_OBJECTS = $(patsubst %, f7_asm_%$(objext), $(F7_ASM_PARTS))\n+\n+$(F7_ASM_OBJECTS) $(F7_C_OBJECTS) : $(libf7)/t-libf7\n+$(F7_ASM_OBJECTS) $(F7_C_OBJECTS) : $(libf7)/t-libf7-math\n+$(F7_ASM_OBJECTS) $(F7_C_OBJECTS) : $(libf7)/t-libf7-math-symbols\n+\n+.PHONY: log_vars\n+\n+all: log_vars\n+\n+log_vars:\n+\t$(info # libf7: WITH_LIBF7_MATH_FUNCTIONS = $(WITH_LIBF7_MATH_FUNCTIONS))\n+\t$(info # libf7: WITH_LIBF7_MATH_SYMBOLS = $(WITH_LIBF7_MATH_SYMBOLS))\n+\t$(info # libf7: F7_C_PARTS = $(F7_C_PARTS))\n+\t$(info # libf7: F7_C_OBJECTS = $(F7_C_OBJECTS))\n+\t$(info # libf7: F7_ASM_PARTS = $(F7_ASM_PARTS))\n+\t$(info # libf7: F7_ASM_OBJECTS = $(F7_ASM_OBJECTS))\n+\n+# Build the libf7 C objects and add them to libgcc.a.\n+\n+f7_parts := $(F7_C_PARTS)\n+\n+iter-items  := $(f7_parts)\n+iter-labels := $(f7_parts)\n+\n+include $(srcdir)/empty.mk $(patsubst %,$(libf7)/libf7-c-object.mk,$(iter-items))\n+\n+libgcc-objects += $(patsubst %,f7_c_%$(objext),$(F7_C_PARTS))\n+\n+# Build the libf7 ASM objects and add them to libgcc.a.\n+\n+f7_parts := $(F7_ASM_PARTS)\n+\n+iter-items  := $(f7_parts)\n+iter-labels := $(f7_parts)\n+\n+include $(srcdir)/empty.mk $(patsubst %,$(libf7)/libf7-asm-object.mk,$(iter-items))\n+\n+libgcc-objects += $(patsubst %,f7_asm_%$(objext),$(F7_ASM_PARTS))\n+\n+.PHONY: clean-f7\n+\n+clean: clean-f7\n+\n+clean-f7:\n+\trm -f $(wildcard f7_*.i f7_*.s f7_*.o)\n+\n+# Get rid if any DFmode remains.\n+\n+LIB2FUNCS_EXCLUDE +=\t\\\n+\t_sf_to_df\t\\\n+\t_fixdfdi\t\\\n+\t_fixunsdfsi\t\\\n+\t_floatundidf\t\\\n+\t_fixunsdfdi\t\\\n+\t_floatdidf\t\\\n+\t_powidf2"}, {"sha": "6eb144d2edde266a318e496c2914171bfcb5ed15", "filename": "libgcc/config/avr/libf7/t-libf7-math", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7-math", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7-math", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7-math?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,21 @@\n+# Triggered by --with-libf7=math or --with-libf7=math-symbols\n+#\n+# We provide weak double wrappers for functions specified in math.h,\n+# but with __ prepended to the symbol name used for the double function.\n+# For example we provide double __sin (double) but neither sin nor sinl.\n+# To get weak symbols according to math.h, t-libf7-math-symbols has to\n+# be used which is triggered by --with-libf7=math-symbols.\n+\n+WITH_LIBF7_MATH_FUNCTIONS = 1\n+\n+# __sin, ...\n+F7_ASM_WRAPS_m_dd  += $(m_dd)\n+\n+# __pow, __fmin, ...\n+F7_ASM_WRAPS_m_ddd += $(m_ddd)\n+\n+# __ldexp, ...\n+F7_ASM_WRAPS_m_ddx += $(m_ddx)\n+\n+# __lrint, ...\n+F7_ASM_WRAPS_m_xd += $(m_xd)"}, {"sha": "c79e2b6ca718febeb35ff5d4fa98fa9b41f1b49f", "filename": "libgcc/config/avr/libf7/t-libf7-math-symbols", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7-math-symbols", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7-math-symbols", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flibf7%2Ft-libf7-math-symbols?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -0,0 +1,11 @@\n+# Triggered by --with-libf7=math-symbols\n+#\n+# We have at least one module in libgcc that depends on __SIZEOF_DOUBLE__\n+# or __SIZEOF_LONG_DOUBLE__ which means that t-avrlibc must not copy\n+# double32/64 or long-double32/64 variants from the vanilla one.\n+# This occurs when some module(s) define(s) weak aliases for functions\n+# that usually live in libm.\n+\n+WITH_LIBF7_MATH_SYMBOLS = 1\n+\n+F7_FLAGS += -DWITH_LIBF7_MATH_SYMBOLS"}, {"sha": "661a518c0fd8ddfa46c68e9528a32a3c9f322ba1", "filename": "libgcc/config/avr/t-avrlibc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Ft-avrlibc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30dd607669212de135dec1f1d8a93b8954c327c/libgcc%2Fconfig%2Favr%2Ft-avrlibc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avrlibc?ref=f30dd607669212de135dec1f1d8a93b8954c327c", "patch": "@@ -65,6 +65,12 @@ LIB2FUNCS_EXCLUDE += \\\n \t_fixunssfdi \\\n \t_floatdisf _floatundisf\n \n+ifeq (,$(WITH_LIBF7_MATH_SYMBOLS))\n+\n+# No modules depend on __SIZEOF_LONG_DOUBLE__ or __SIZEOF_DOUBLE__\n+# which means we might have an opportunity to copy libgcc.a.\n+# WITH_LIBF7_MATH_SYMBOLS is set by libf7/t-libf7-math-symbols.\n+\n ifneq (,$(findstring avr,$(MULTISUBDIR)))\n \n # We are not in the avr2 (default) subdir, hence copying will work.\n@@ -95,3 +101,4 @@ Makefile: t-copy-libgcc.dep\n \n endif\n endif\n+endif"}]}