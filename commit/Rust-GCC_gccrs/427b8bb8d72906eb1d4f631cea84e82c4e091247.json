{"sha": "427b8bb8d72906eb1d4f631cea84e82c4e091247", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI3YjhiYjhkNzI5MDZlYjFkNGY2MzFjZWE4NGU4MmM0ZTA5MTI0Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-09-04T19:11:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-09-04T19:11:37Z"}, "message": "bb-reorder.c (gate_handle_reorder_blocks): Move around.\n\n\t* bb-reorder.c (gate_handle_reorder_blocks): Move around.\n\t(rest_of_handle_reorder_blocks): Likewise.\n\t(pass_reorder_blocks): Likewise.\n\t(gate_handle_partition_blocks): Likewise.\n\nFrom-SVN: r190948", "tree": {"sha": "59d7e93313f8b550a3874f6cdd9599f20a384ad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59d7e93313f8b550a3874f6cdd9599f20a384ad3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/427b8bb8d72906eb1d4f631cea84e82c4e091247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/427b8bb8d72906eb1d4f631cea84e82c4e091247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/427b8bb8d72906eb1d4f631cea84e82c4e091247", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/427b8bb8d72906eb1d4f631cea84e82c4e091247/comments", "author": null, "committer": null, "parents": [{"sha": "88a8ba9581f3b873c8687ec519a01ac771542b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a8ba9581f3b873c8687ec519a01ac771542b64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88a8ba9581f3b873c8687ec519a01ac771542b64"}], "stats": {"total": 158, "additions": 81, "deletions": 77}, "files": [{"sha": "ce1252da717be893df3afdd226ea9aad35569d96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/427b8bb8d72906eb1d4f631cea84e82c4e091247/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/427b8bb8d72906eb1d4f631cea84e82c4e091247/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=427b8bb8d72906eb1d4f631cea84e82c4e091247", "patch": "@@ -1,3 +1,10 @@\n+2012-09-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* bb-reorder.c (gate_handle_reorder_blocks): Move around.\n+\t(rest_of_handle_reorder_blocks): Likewise.\n+\t(pass_reorder_blocks): Likewise.\n+\t(gate_handle_partition_blocks): Likewise.\n+\n 2012-09-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR rtl-optimization/54456"}, {"sha": "3ebfa139d30d66f746fda55ee674ba349ec7c077", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/427b8bb8d72906eb1d4f631cea84e82c4e091247/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/427b8bb8d72906eb1d4f631cea84e82c4e091247/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=427b8bb8d72906eb1d4f631cea84e82c4e091247", "patch": "@@ -2037,6 +2037,65 @@ insert_section_boundary_note (void)\n     }\n }\n \n+static bool\n+gate_handle_reorder_blocks (void)\n+{\n+  if (targetm.cannot_modify_jumps_p ())\n+    return false;\n+  /* Don't reorder blocks when optimizing for size because extra jump insns may\n+     be created; also barrier may create extra padding.\n+\n+     More correctly we should have a block reordering mode that tried to\n+     minimize the combined size of all the jumps.  This would more or less\n+     automatically remove extra jumps, but would also try to use more short\n+     jumps instead of long jumps.  */\n+  if (!optimize_function_for_speed_p (cfun))\n+    return false;\n+  return (optimize > 0\n+\t  && (flag_reorder_blocks || flag_reorder_blocks_and_partition));\n+}\n+\n+static unsigned int\n+rest_of_handle_reorder_blocks (void)\n+{\n+  basic_block bb;\n+\n+  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+     splitting possibly introduced more crossjumping opportunities.  */\n+  cfg_layout_initialize (CLEANUP_EXPENSIVE);\n+\n+  reorder_basic_blocks ();\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+  FOR_EACH_BB (bb)\n+    if (bb->next_bb != EXIT_BLOCK_PTR)\n+      bb->aux = bb->next_bb;\n+  cfg_layout_finalize ();\n+\n+  /* Add NOTE_INSN_SWITCH_TEXT_SECTIONS notes.  */\n+  insert_section_boundary_note ();\n+  return 0;\n+}\n+\n+struct rtl_opt_pass pass_reorder_blocks =\n+{\n+ {\n+  RTL_PASS,\n+  \"bbro\",                               /* name */\n+  gate_handle_reorder_blocks,           /* gate */\n+  rest_of_handle_reorder_blocks,        /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_REORDER_BLOCKS,                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_verify_rtl_sharing,              /* todo_flags_finish */\n+ }\n+};\n+\n /* Duplicate the blocks containing computed gotos.  This basically unfactors\n    computed gotos that were factored early on in the compilation process to\n    speed up edge based data flow.  We used to not unfactoring them again,\n@@ -2178,6 +2237,21 @@ struct rtl_opt_pass pass_duplicate_computed_gotos =\n  }\n };\n \n+static bool\n+gate_handle_partition_blocks (void)\n+{\n+  /* The optimization to partition hot/cold basic blocks into separate\n+     sections of the .o file does not work well with linkonce or with\n+     user defined section attributes.  Don't call it if either case\n+     arises.  */\n+  return (flag_reorder_blocks_and_partition\n+          && optimize\n+\t  /* See gate_handle_reorder_blocks.  We should not partition if\n+\t     we are going to omit the reordering.  */\n+\t  && optimize_function_for_speed_p (cfun)\n+\t  && !DECL_ONE_ONLY (current_function_decl)\n+\t  && !user_defined_section_attribute);\n+}\n \n /* This function is the main 'entrance' for the optimization that\n    partitions hot and cold basic blocks into separate sections of the\n@@ -2346,83 +2420,6 @@ partition_hot_cold_basic_blocks (void)\n \n   return TODO_verify_flow | TODO_verify_rtl_sharing;\n }\n-\f\n-static bool\n-gate_handle_reorder_blocks (void)\n-{\n-  if (targetm.cannot_modify_jumps_p ())\n-    return false;\n-  /* Don't reorder blocks when optimizing for size because extra jump insns may\n-     be created; also barrier may create extra padding.\n-\n-     More correctly we should have a block reordering mode that tried to\n-     minimize the combined size of all the jumps.  This would more or less\n-     automatically remove extra jumps, but would also try to use more short\n-     jumps instead of long jumps.  */\n-  if (!optimize_function_for_speed_p (cfun))\n-    return false;\n-  return (optimize > 0\n-\t  && (flag_reorder_blocks || flag_reorder_blocks_and_partition));\n-}\n-\n-\n-/* Reorder basic blocks.  */\n-static unsigned int\n-rest_of_handle_reorder_blocks (void)\n-{\n-  basic_block bb;\n-\n-  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-     splitting possibly introduced more crossjumping opportunities.  */\n-  cfg_layout_initialize (CLEANUP_EXPENSIVE);\n-\n-  reorder_basic_blocks ();\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n-      bb->aux = bb->next_bb;\n-  cfg_layout_finalize ();\n-\n-  /* Add NOTE_INSN_SWITCH_TEXT_SECTIONS notes.  */\n-  insert_section_boundary_note ();\n-  return 0;\n-}\n-\n-struct rtl_opt_pass pass_reorder_blocks =\n-{\n- {\n-  RTL_PASS,\n-  \"bbro\",                               /* name */\n-  gate_handle_reorder_blocks,           /* gate */\n-  rest_of_handle_reorder_blocks,        /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REORDER_BLOCKS,                    /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing,              /* todo_flags_finish */\n- }\n-};\n-\n-static bool\n-gate_handle_partition_blocks (void)\n-{\n-  /* The optimization to partition hot/cold basic blocks into separate\n-     sections of the .o file does not work well with linkonce or with\n-     user defined section attributes.  Don't call it if either case\n-     arises.  */\n-  return (flag_reorder_blocks_and_partition\n-          && optimize\n-\t  /* See gate_handle_reorder_blocks.  We should not partition if\n-\t     we are going to omit the reordering.  */\n-\t  && optimize_function_for_speed_p (cfun)\n-\t  && !DECL_ONE_ONLY (current_function_decl)\n-\t  && !user_defined_section_attribute);\n-}\n \n struct rtl_opt_pass pass_partition_blocks =\n {"}]}