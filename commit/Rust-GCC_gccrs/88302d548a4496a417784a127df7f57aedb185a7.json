{"sha": "88302d548a4496a417784a127df7f57aedb185a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgzMDJkNTQ4YTQ0OTZhNDE3Nzg0YTEyN2RmN2Y1N2FlZGIxODVhNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-27T15:08:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-27T15:08:00Z"}, "message": "sched-ebb.c: Rename struct deps to struct deps_desc.\n\n\n\t* sched-ebb.c: Rename struct deps to struct deps_desc.\n\t* ddg.c: Likewise.\n\t* sel-sched-ir.c: Likewise.\n\t* sched-deps.c: Likewise.\n\t* sched-int.h: Likewise.\n\t* sched-rgn.c: Likewise.\n\nFrom-SVN: r159923", "tree": {"sha": "68682fab584c02bf97095da96bcf11d8fa082ce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68682fab584c02bf97095da96bcf11d8fa082ce4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88302d548a4496a417784a127df7f57aedb185a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88302d548a4496a417784a127df7f57aedb185a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88302d548a4496a417784a127df7f57aedb185a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88302d548a4496a417784a127df7f57aedb185a7/comments", "author": null, "committer": null, "parents": [{"sha": "9bb8145323498ee3265e4e1d544d8bd2344999d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb8145323498ee3265e4e1d544d8bd2344999d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb8145323498ee3265e4e1d544d8bd2344999d6"}], "stats": {"total": 101, "additions": 55, "deletions": 46}, "files": [{"sha": "d1872bfc5a7f9dd26fd479f459b79a896f04d70b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88302d548a4496a417784a127df7f57aedb185a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88302d548a4496a417784a127df7f57aedb185a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88302d548a4496a417784a127df7f57aedb185a7", "patch": "@@ -1,4 +1,13 @@\n-2010-05-27  Jon `:wqBeniston <jon@beniston.com\n+2010-05-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* sched-ebb.c: Rename struct deps to struct deps_desc.\n+\t* ddg.c: Likewise.\n+\t* sel-sched-ir.c: Likewise.\n+\t* sched-deps.c: Likewise.\n+\t* sched-int.h: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\n+2010-05-27  Jon Beniston <jon@beniston.com>\n \n \tPR 43726\n \t* config/lm32/lm32.h: Remove definition of "}, {"sha": "09932ae3c7464d74321e8440e1505ad54e8bdc49", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=88302d548a4496a417784a127df7f57aedb185a7", "patch": "@@ -390,7 +390,7 @@ build_intra_loop_deps (ddg_ptr g)\n {\n   int i;\n   /* Hold the dependency analysis state during dependency calculations.  */\n-  struct deps tmp_deps;\n+  struct deps_desc tmp_deps;\n   rtx head, tail;\n \n   /* Build the dependence information, using the sched_analyze function.  */"}, {"sha": "9abb92de4d98caf19778b18a090279312cbfd865", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=88302d548a4496a417784a127df7f57aedb185a7", "patch": "@@ -442,15 +442,15 @@ static int cache_size;\n \n static int deps_may_trap_p (const_rtx);\n static void add_dependence_list (rtx, rtx, int, enum reg_note);\n-static void add_dependence_list_and_free (struct deps *, rtx,\n+static void add_dependence_list_and_free (struct deps_desc *, rtx,\n \t\t\t\t\t  rtx *, int, enum reg_note);\n static void delete_all_dependences (rtx);\n static void fixup_sched_groups (rtx);\n \n-static void flush_pending_lists (struct deps *, rtx, int, int);\n-static void sched_analyze_1 (struct deps *, rtx, rtx);\n-static void sched_analyze_2 (struct deps *, rtx, rtx);\n-static void sched_analyze_insn (struct deps *, rtx, rtx);\n+static void flush_pending_lists (struct deps_desc *, rtx, int, int);\n+static void sched_analyze_1 (struct deps_desc *, rtx, rtx);\n+static void sched_analyze_2 (struct deps_desc *, rtx, rtx);\n+static void sched_analyze_insn (struct deps_desc *, rtx, rtx);\n \n static bool sched_has_condition_p (const_rtx);\n static int conditions_mutex_p (const_rtx, const_rtx, bool, bool);\n@@ -1402,7 +1402,7 @@ add_dependence_list (rtx insn, rtx list, int uncond, enum reg_note dep_type)\n    is not readonly.  */\n \n static void\n-add_dependence_list_and_free (struct deps *deps, rtx insn, rtx *listp,\n+add_dependence_list_and_free (struct deps_desc *deps, rtx insn, rtx *listp,\n                               int uncond, enum reg_note dep_type)\n {\n   rtx list, next;\n@@ -1541,7 +1541,7 @@ fixup_sched_groups (rtx insn)\n    so that we can do memory aliasing on it.  */\n \n static void\n-add_insn_mem_dependence (struct deps *deps, bool read_p,\n+add_insn_mem_dependence (struct deps_desc *deps, bool read_p,\n \t\t\t rtx insn, rtx mem)\n {\n   rtx *insn_list;\n@@ -1580,7 +1580,7 @@ add_insn_mem_dependence (struct deps *deps, bool read_p,\n    dependencies for a read operation, similarly with FOR_WRITE.  */\n \n static void\n-flush_pending_lists (struct deps *deps, rtx insn, int for_read,\n+flush_pending_lists (struct deps_desc *deps, rtx insn, int for_read,\n \t\t     int for_write)\n {\n   if (for_write)\n@@ -1764,7 +1764,7 @@ create_insn_reg_set (int regno, rtx insn)\n \n /* Set up insn register uses for INSN and dependency context DEPS.  */\n static void\n-setup_insn_reg_uses (struct deps *deps, rtx insn)\n+setup_insn_reg_uses (struct deps_desc *deps, rtx insn)\n {\n   unsigned i;\n   reg_set_iterator rsi;\n@@ -2058,7 +2058,7 @@ static bool can_start_lhs_rhs_p;\n /* Extend reg info for the deps context DEPS given that\n    we have just generated a register numbered REGNO.  */\n static void\n-extend_deps_reg_info (struct deps *deps, int regno)\n+extend_deps_reg_info (struct deps_desc *deps, int regno)\n {\n   int max_regno = regno + 1;\n \n@@ -2107,7 +2107,7 @@ maybe_extend_reg_info_p (void)\n    CLOBBER, PRE_DEC, POST_DEC, PRE_INC, POST_INC or USE.  */\n \n static void\n-sched_analyze_reg (struct deps *deps, int regno, enum machine_mode mode,\n+sched_analyze_reg (struct deps_desc *deps, int regno, enum machine_mode mode,\n \t\t   enum rtx_code ref, rtx insn)\n {\n   /* We could emit new pseudos in renaming.  Extend the reg structures.  */\n@@ -2186,7 +2186,7 @@ sched_analyze_reg (struct deps *deps, int regno, enum machine_mode mode,\n    destination of X, and reads of everything mentioned.  */\n \n static void\n-sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n+sched_analyze_1 (struct deps_desc *deps, rtx x, rtx insn)\n {\n   rtx dest = XEXP (x, 0);\n   enum rtx_code code = GET_CODE (x);\n@@ -2358,7 +2358,7 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \n /* Analyze the uses of memory and registers in rtx X in INSN.  */\n static void\n-sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n+sched_analyze_2 (struct deps_desc *deps, rtx x, rtx insn)\n {\n   int i;\n   int j;\n@@ -2609,7 +2609,7 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \n /* Analyze an INSN with pattern X to find all dependencies.  */\n static void\n-sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n+sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n {\n   RTX_CODE code = GET_CODE (x);\n   rtx link;\n@@ -3224,7 +3224,7 @@ call_may_noreturn_p (rtx insn)\n \n /* Analyze INSN with DEPS as a context.  */\n void\n-deps_analyze_insn (struct deps *deps, rtx insn)\n+deps_analyze_insn (struct deps_desc *deps, rtx insn)\n {\n   if (sched_deps_info->start_insn)\n     sched_deps_info->start_insn (insn);\n@@ -3357,7 +3357,7 @@ deps_analyze_insn (struct deps *deps, rtx insn)\n \n /* Initialize DEPS for the new block beginning with HEAD.  */\n void\n-deps_start_bb (struct deps *deps, rtx head)\n+deps_start_bb (struct deps_desc *deps, rtx head)\n {\n   gcc_assert (!deps->readonly);\n \n@@ -3378,7 +3378,7 @@ deps_start_bb (struct deps *deps, rtx head)\n /* Analyze every insn between HEAD and TAIL inclusive, creating backward\n    dependencies for each insn.  */\n void\n-sched_analyze (struct deps *deps, rtx head, rtx tail)\n+sched_analyze (struct deps_desc *deps, rtx head, rtx tail)\n {\n   rtx insn;\n \n@@ -3463,10 +3463,10 @@ sched_free_deps (rtx head, rtx tail, bool resolved_p)\n \f\n /* Initialize variables for region data dependence analysis.\n    When LAZY_REG_LAST is true, do not allocate reg_last array\n-   of struct deps immediately.  */\n+   of struct deps_desc immediately.  */\n \n void\n-init_deps (struct deps *deps, bool lazy_reg_last)\n+init_deps (struct deps_desc *deps, bool lazy_reg_last)\n {\n   int max_reg = (reload_completed ? FIRST_PSEUDO_REGISTER : max_reg_num ());\n \n@@ -3498,7 +3498,7 @@ init_deps (struct deps *deps, bool lazy_reg_last)\n /* Init only reg_last field of DEPS, which was not allocated before as\n    we inited DEPS lazily.  */\n void\n-init_deps_reg_last (struct deps *deps)\n+init_deps_reg_last (struct deps_desc *deps)\n {\n   gcc_assert (deps && deps->max_reg > 0);\n   gcc_assert (deps->reg_last == NULL);\n@@ -3510,7 +3510,7 @@ init_deps_reg_last (struct deps *deps)\n /* Free insn lists found in DEPS.  */\n \n void\n-free_deps (struct deps *deps)\n+free_deps (struct deps_desc *deps)\n {\n   unsigned i;\n   reg_set_iterator rsi;\n@@ -3559,7 +3559,7 @@ free_deps (struct deps *deps)\n /* Remove INSN from dependence contexts DEPS.  Caution: reg_conditional_sets\n    is not handled.  */\n void\n-remove_from_deps (struct deps *deps, rtx insn)\n+remove_from_deps (struct deps_desc *deps, rtx insn)\n {\n   int removed;\n   unsigned i;"}, {"sha": "534df4ad0f7b9c5326fdaf1fbf3befba9f57c6ba", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=88302d548a4496a417784a127df7f57aedb185a7", "patch": "@@ -463,7 +463,7 @@ static basic_block\n schedule_ebb (rtx head, rtx tail)\n {\n   basic_block first_bb, target_bb;\n-  struct deps tmp_deps;\n+  struct deps_desc tmp_deps;\n \n   first_bb = BLOCK_FOR_INSN (head);\n   last_bb = BLOCK_FOR_INSN (tail);"}, {"sha": "147e264848aa3aaa5bd6415c059ce34cdd57ee73", "filename": "gcc/sched-int.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=88302d548a4496a417784a127df7f57aedb185a7", "patch": "@@ -448,7 +448,7 @@ struct deps_reg\n };\n \n /* Describe state of dependencies used during sched_analyze phase.  */\n-struct deps\n+struct deps_desc\n {\n   /* The *_insns and *_mems are paired lists.  Each pending memory operation\n      will have a pointer to the MEM rtx on one list and a pointer to the\n@@ -546,7 +546,7 @@ struct deps\n   BOOL_BITFIELD readonly : 1;\n };\n \n-typedef struct deps *deps_t;\n+typedef struct deps_desc *deps_t;\n \n /* This structure holds some state of the current scheduling pass, and\n    contains some function pointers that abstract out some of the non-generic\n@@ -1198,14 +1198,14 @@ extern struct sched_deps_info_def *sched_deps_info;\n extern bool sched_insns_conditions_mutex_p (const_rtx, const_rtx);\n extern bool sched_insn_is_legitimate_for_speculation_p (const_rtx, ds_t);\n extern void add_dependence (rtx, rtx, enum reg_note);\n-extern void sched_analyze (struct deps *, rtx, rtx);\n-extern void init_deps (struct deps *, bool);\n-extern void init_deps_reg_last (struct deps *);\n-extern void free_deps (struct deps *);\n+extern void sched_analyze (struct deps_desc *, rtx, rtx);\n+extern void init_deps (struct deps_desc *, bool);\n+extern void init_deps_reg_last (struct deps_desc *);\n+extern void free_deps (struct deps_desc *);\n extern void init_deps_global (void);\n extern void finish_deps_global (void);\n-extern void deps_analyze_insn (struct deps *, rtx);\n-extern void remove_from_deps (struct deps *, rtx);\n+extern void deps_analyze_insn (struct deps_desc *, rtx);\n+extern void remove_from_deps (struct deps_desc *, rtx);\n \n extern dw_t get_dep_weak_1 (ds_t, ds_t);\n extern dw_t get_dep_weak (ds_t, ds_t);\n@@ -1227,7 +1227,7 @@ extern void haifa_note_reg_use (int);\n \n extern void maybe_extend_reg_info_p (void);\n \n-extern void deps_start_bb (struct deps *, rtx);\n+extern void deps_start_bb (struct deps_desc *, rtx);\n extern enum reg_note ds_to_dt (ds_t);\n \n extern bool deps_pools_are_empty_p (void);\n@@ -1337,7 +1337,7 @@ extern void debug_dependencies (rtx, rtx);\n extern void free_rgn_deps (void);\n extern int contributes_to_priority (rtx, rtx);\n extern void extend_rgns (int *, int *, sbitmap, int *);\n-extern void deps_join (struct deps *, struct deps *);\n+extern void deps_join (struct deps_desc *, struct deps_desc *);\n \n extern void rgn_setup_common_sched_info (void);\n extern void rgn_setup_sched_infos (void);"}, {"sha": "11dc83cd805f3a7cc8a5f527ca64bf2443ace67d", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=88302d548a4496a417784a127df7f57aedb185a7", "patch": "@@ -237,7 +237,7 @@ static void compute_block_dependences (int);\n static void schedule_region (int);\n static rtx concat_INSN_LIST (rtx, rtx);\n static void concat_insn_mem_list (rtx, rtx, rtx *, rtx *);\n-static void propagate_deps (int, struct deps *);\n+static void propagate_deps (int, struct deps_desc *);\n static void free_pending_lists (void);\n \n /* Functions for construction of the control flow graph.  */\n@@ -2567,7 +2567,7 @@ add_branch_dependences (rtx head, rtx tail)\n    the variables of its predecessors.  When the analysis for a bb completes,\n    we save the contents to the corresponding bb_deps[bb] variable.  */\n \n-static struct deps *bb_deps;\n+static struct deps_desc *bb_deps;\n \n /* Duplicate the INSN_LIST elements of COPY and prepend them to OLD.  */\n \n@@ -2601,7 +2601,7 @@ concat_insn_mem_list (rtx copy_insns, rtx copy_mems, rtx *old_insns_p,\n \n /* Join PRED_DEPS to the SUCC_DEPS.  */\n void\n-deps_join (struct deps *succ_deps, struct deps *pred_deps)\n+deps_join (struct deps_desc *succ_deps, struct deps_desc *pred_deps)\n {\n   unsigned reg;\n   reg_set_iterator rsi;\n@@ -2660,7 +2660,7 @@ deps_join (struct deps *succ_deps, struct deps *pred_deps)\n /* After computing the dependencies for block BB, propagate the dependencies\n    found in TMP_DEPS to the successors of the block.  */\n static void\n-propagate_deps (int bb, struct deps *pred_deps)\n+propagate_deps (int bb, struct deps_desc *pred_deps)\n {\n   basic_block block = BASIC_BLOCK (BB_TO_BLOCK (bb));\n   edge_iterator ei;\n@@ -2715,7 +2715,7 @@ static void\n compute_block_dependences (int bb)\n {\n   rtx head, tail;\n-  struct deps tmp_deps;\n+  struct deps_desc tmp_deps;\n \n   tmp_deps = bb_deps[bb];\n \n@@ -3150,7 +3150,7 @@ sched_rgn_compute_dependencies (int rgn)\n       init_deps_global ();\n \n       /* Initializations for region data dependence analysis.  */\n-      bb_deps = XNEWVEC (struct deps, current_nr_blocks);\n+      bb_deps = XNEWVEC (struct deps_desc, current_nr_blocks);\n       for (bb = 0; bb < current_nr_blocks; bb++)\n \tinit_deps (bb_deps + bb, false);\n "}, {"sha": "e11968e2b49695dc39f35e3168350e072a1c686a", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=88302d548a4496a417784a127df7f57aedb185a7", "patch": "@@ -426,7 +426,7 @@ reset_target_context (tc_t tc, bool clean_p)\n }\n \f\n /* Functions to work with dependence contexts.\n-   Dc (aka deps context, aka deps_t, aka struct deps *) is short for dependence\n+   Dc (aka deps context, aka deps_t, aka struct deps_desc *) is short for dependence\n    context.  It accumulates information about processed insns to decide if\n    current insn is dependent on the processed ones.  */\n \n@@ -442,7 +442,7 @@ copy_deps_context (deps_t to, deps_t from)\n static deps_t\n alloc_deps_context (void)\n {\n-  return XNEW (struct deps);\n+  return XNEW (struct deps_desc);\n }\n \n /* Allocate and initialize dep context.  */\n@@ -2674,7 +2674,7 @@ init_id_from_df (idata_t id, insn_t insn, bool force_unique_p)\n static void\n deps_init_id (idata_t id, insn_t insn, bool force_unique_p)\n {\n-  struct deps _dc, *dc = &_dc;\n+  struct deps_desc _dc, *dc = &_dc;\n \n   deps_init_id_data.where = DEPS_IN_NOWHERE;\n   deps_init_id_data.id = id;\n@@ -3229,7 +3229,7 @@ has_dependence_p (expr_t expr, insn_t pred, ds_t **has_dep_pp)\n {\n   int i;\n   ds_t ds;\n-  struct deps *dc;\n+  struct deps_desc *dc;\n \n   if (INSN_SIMPLEJUMP_P (pred))\n     /* Unconditional jump is just a transfer of control flow."}, {"sha": "ee9061f6d729dc1bb78ab0dc632f5de65e729abc", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88302d548a4496a417784a127df7f57aedb185a7/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=88302d548a4496a417784a127df7f57aedb185a7", "patch": "@@ -727,7 +727,7 @@ struct _sel_insn_data\n   htab_t transformed_insns;\n \n   /* A context incapsulating this insn.  */\n-  struct deps deps_context;\n+  struct deps_desc deps_context;\n \n   /* This field is initialized at the beginning of scheduling and is used\n      to handle sched group instructions.  If it is non-null, then it points"}]}