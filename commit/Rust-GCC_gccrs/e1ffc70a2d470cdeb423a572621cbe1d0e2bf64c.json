{"sha": "e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmZmM3MGEyZDQ3MGNkZWI0MjNhNTcyNjIxY2JlMWQwZTJiZjY0Yw==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@nerim.fr", "date": "2003-10-27T12:26:19Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2003-10-27T12:26:19Z"}, "message": "m68hc11.c: Convert to ISO C90.\n\n\t* config/m68hc11/m68hc11.c: Convert to ISO C90.\n\t* config/m68hc11/m68hc11-protos.h: Likewise.\n\nFrom-SVN: r72981", "tree": {"sha": "cff1ebb7bcc37835a9282dc56d5ad6ddd65109e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cff1ebb7bcc37835a9282dc56d5ad6ddd65109e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c/comments", "author": null, "committer": null, "parents": [{"sha": "65b193498b397cc3d4a39ac2412ca06ab7631ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b193498b397cc3d4a39ac2412ca06ab7631ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65b193498b397cc3d4a39ac2412ca06ab7631ba2"}], "stats": {"total": 633, "additions": 245, "deletions": 388}, "files": [{"sha": "4353ee7e28a7e15cf60988d35c77908abcdefc1f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "patch": "@@ -1,3 +1,8 @@\n+2003-10-27  Stephane Carrez  <stcarrez@nerim.fr>\n+\n+\t* config/m68hc11/m68hc11.c: Convert to ISO C90.\n+\t* config/m68hc11/m68hc11-protos.h: Likewise.\n+\n 2003-10-27  Jan Hubicka  <jh@suse.cz>\n \t    Eric Botcazou  <ebotcazou@libertysurf.fr>\n "}, {"sha": "d4582ab803ddffead1379a4897326019afa25bfe", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 89, "deletions": 97, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "patch": "@@ -20,126 +20,118 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-extern int m68hc11_override_options PARAMS((void));\n-extern int m68hc11_optimization_options PARAMS((int,int));\n-extern void m68hc11_conditional_register_usage PARAMS((void));\n-extern int hard_regno_mode_ok PARAMS((int, enum machine_mode));\n-extern int m68hc11_hard_regno_rename_ok PARAMS((int, int));\n+extern int m68hc11_override_options (void);\n+extern int m68hc11_optimization_options (int,int);\n+extern void m68hc11_conditional_register_usage (void);\n+extern int hard_regno_mode_ok (int, enum machine_mode);\n+extern int m68hc11_hard_regno_rename_ok (int, int);\n \n-extern int m68hc11_total_frame_size PARAMS((void));\n-extern int m68hc11_initial_frame_pointer_offset PARAMS((void));\n-extern int m68hc11_initial_elimination_offset PARAMS((int, int));\n+extern int m68hc11_total_frame_size (void);\n+extern int m68hc11_initial_frame_pointer_offset (void);\n+extern int m68hc11_initial_elimination_offset (int, int);\n \n-extern void expand_prologue PARAMS((void));\n-extern void expand_epilogue PARAMS((void));\n+extern void expand_prologue (void);\n+extern void expand_epilogue (void);\n \n #ifdef TREE_CODE\n-extern void m68hc11_function_arg_advance PARAMS((CUMULATIVE_ARGS*,\n-                                                 enum machine_mode,\n-                                                 tree,\n-                                                 int));\n+extern void m68hc11_function_arg_advance (CUMULATIVE_ARGS*,\n+                                          enum machine_mode,\n+                                          tree,\n+                                          int);\n #endif\n \n #ifdef RTX_CODE\n-extern void m68hc11_initialize_trampoline PARAMS((rtx, rtx, rtx));\n+extern void m68hc11_initialize_trampoline (rtx, rtx, rtx);\n \n-extern rtx m68hc11_expand_compare_and_branch PARAMS((enum rtx_code,\n-                                                     rtx, rtx, rtx));\n-extern enum reg_class preferred_reload_class PARAMS((rtx, enum reg_class));\n+extern rtx m68hc11_expand_compare_and_branch (enum rtx_code, rtx, rtx, rtx);\n+extern enum reg_class preferred_reload_class (rtx, enum reg_class);\n \n-extern int m68hc11_go_if_legitimate_address PARAMS((rtx,\n-                                                    enum machine_mode,\n-                                                    int));\n+extern int m68hc11_go_if_legitimate_address (rtx, enum machine_mode, int);\n \n-extern int m68hc11_legitimize_address PARAMS((rtx*, rtx, enum machine_mode));\n+extern int m68hc11_legitimize_address (rtx*, rtx, enum machine_mode);\n \n-extern void m68hc11_notice_update_cc PARAMS((rtx, rtx));\n-extern void m68hc11_notice_keep_cc PARAMS((rtx));\n+extern void m68hc11_notice_update_cc (rtx, rtx);\n+extern void m68hc11_notice_keep_cc (rtx);\n \n-extern void m68hc11_gen_movqi PARAMS((rtx, rtx*));\n-extern void m68hc11_gen_movhi PARAMS((rtx, rtx*));\n-extern void m68hc11_gen_rotate PARAMS((enum rtx_code, rtx, rtx*));\n+extern void m68hc11_gen_movqi (rtx, rtx*);\n+extern void m68hc11_gen_movhi (rtx, rtx*);\n+extern void m68hc11_gen_rotate (enum rtx_code, rtx, rtx*);\n \n-extern void m68hc11_output_swap PARAMS((rtx,rtx*));\n+extern void m68hc11_output_swap (rtx, rtx*);\n \n-extern int next_insn_test_reg PARAMS((rtx,rtx));\n+extern int next_insn_test_reg (rtx, rtx);\n \n-extern void print_operand PARAMS((FILE*,rtx,int));\n-extern void print_operand_address PARAMS((FILE*,rtx));\n+extern void print_operand (FILE*, rtx, int);\n+extern void print_operand_address (FILE*, rtx);\n \n-extern int m68hc11_reload_operands PARAMS((rtx*));\n+extern int m68hc11_reload_operands (rtx*);\n \n-extern int dead_register_here PARAMS((rtx, rtx));\n+extern int dead_register_here (rtx, rtx);\n \n-extern int push_pop_operand_p PARAMS((rtx));\n-extern void m68hc11_split_move PARAMS((rtx, rtx, rtx));\n-extern void m68hc11_split_compare_and_branch PARAMS((enum rtx_code,\n-                                                     rtx, rtx, rtx));\n-extern void aux_restore_IX_IY PARAMS((rtx));\n-extern void aux_validate_IX_IY PARAMS((rtx));\n+extern int push_pop_operand_p (rtx);\n+extern void m68hc11_split_move (rtx, rtx, rtx);\n+extern void m68hc11_split_compare_and_branch (enum rtx_code,\n+                                              rtx, rtx, rtx);\n \n-extern rtx m68hc11_gen_lowpart PARAMS((enum machine_mode, rtx));\n-extern rtx m68hc11_gen_highpart PARAMS((enum machine_mode, rtx));\n+extern rtx m68hc11_gen_lowpart (enum machine_mode, rtx);\n+extern rtx m68hc11_gen_highpart (enum machine_mode, rtx);\n \n #ifdef HAVE_MACHINE_MODES\n-extern int m68hc11_memory_move_cost PARAMS((enum machine_mode, enum reg_class,\n-                                           int));\n-extern int m68hc11_register_move_cost PARAMS((enum machine_mode,\n-\t\t\t\t\t      enum reg_class, enum reg_class));\n-\n-extern void m68hc11_emit_libcall PARAMS((const char*, enum rtx_code,\n-                                         enum machine_mode, enum machine_mode,\n-                                         int, rtx*));\n-extern int m68hc11_small_indexed_indirect_p PARAMS((rtx, enum machine_mode));\n-extern int m68hc11_symbolic_p PARAMS((rtx, enum machine_mode));\n-extern int m68hc11_indirect_p PARAMS((rtx, enum machine_mode));\n-extern int go_if_legitimate_address2 PARAMS((rtx, enum machine_mode, int));\n-\n-extern int reg_or_indexed_operand PARAMS((rtx,enum machine_mode));\n-extern int tst_operand PARAMS((rtx,enum machine_mode));\n-extern int cmp_operand PARAMS((rtx,enum machine_mode));\n-extern int memory_indexed_operand PARAMS((rtx, enum machine_mode));\n-\n-extern void m68hc11_split_logical PARAMS((enum machine_mode, int, rtx*));\n-\n-extern int m68hc11_register_indirect_p PARAMS((rtx, enum machine_mode));\n-\n-extern int symbolic_memory_operand PARAMS((rtx, enum machine_mode));\n-\n-extern int memory_reload_operand PARAMS((rtx, enum machine_mode));\n-extern int stack_register_operand PARAMS((rtx, enum machine_mode));\n-extern int d_register_operand PARAMS((rtx, enum machine_mode));\n-extern int hard_addr_reg_operand PARAMS((rtx, enum machine_mode));\n-extern int arith_src_operand PARAMS((rtx, enum machine_mode));\n-extern int m68hc11_logical_operator PARAMS((rtx, enum machine_mode));\n-extern int m68hc11_arith_operator PARAMS((rtx, enum machine_mode));\n-extern int m68hc11_non_shift_operator PARAMS((rtx, enum machine_mode));\n-extern int m68hc11_shift_operator PARAMS((rtx, enum machine_mode));\n-extern int m68hc11_unary_operator PARAMS((rtx, enum machine_mode));\n-extern int m68hc11_eq_compare_operator PARAMS((rtx, enum machine_mode));\n-extern int non_push_operand PARAMS((rtx, enum machine_mode));\n-extern int hard_reg_operand PARAMS((rtx, enum machine_mode));\n-extern int soft_reg_operand PARAMS((rtx, enum machine_mode));\n-extern int reg_or_some_mem_operand PARAMS((rtx, enum machine_mode));\n+extern int m68hc11_memory_move_cost (enum machine_mode, enum reg_class, int);\n+extern int m68hc11_register_move_cost (enum machine_mode,\n+                                       enum reg_class, enum reg_class);\n+\n+extern void m68hc11_emit_libcall (const char*, enum rtx_code,\n+                                  enum machine_mode, enum machine_mode,\n+                                  int, rtx*);\n+extern int m68hc11_small_indexed_indirect_p (rtx, enum machine_mode);\n+extern int m68hc11_symbolic_p (rtx, enum machine_mode);\n+extern int m68hc11_indirect_p (rtx, enum machine_mode);\n+extern int go_if_legitimate_address2 (rtx, enum machine_mode, int);\n+\n+extern int reg_or_indexed_operand (rtx,enum machine_mode);\n+extern int tst_operand (rtx,enum machine_mode);\n+extern int cmp_operand (rtx,enum machine_mode);\n+extern int memory_indexed_operand (rtx, enum machine_mode);\n+\n+extern void m68hc11_split_logical (enum machine_mode, int, rtx*);\n+\n+extern int m68hc11_register_indirect_p (rtx, enum machine_mode);\n+\n+extern int symbolic_memory_operand (rtx, enum machine_mode);\n+\n+extern int memory_reload_operand (rtx, enum machine_mode);\n+extern int stack_register_operand (rtx, enum machine_mode);\n+extern int d_register_operand (rtx, enum machine_mode);\n+extern int hard_addr_reg_operand (rtx, enum machine_mode);\n+extern int arith_src_operand (rtx, enum machine_mode);\n+extern int m68hc11_logical_operator (rtx, enum machine_mode);\n+extern int m68hc11_arith_operator (rtx, enum machine_mode);\n+extern int m68hc11_non_shift_operator (rtx, enum machine_mode);\n+extern int m68hc11_shift_operator (rtx, enum machine_mode);\n+extern int m68hc11_unary_operator (rtx, enum machine_mode);\n+extern int m68hc11_eq_compare_operator (rtx, enum machine_mode);\n+extern int non_push_operand (rtx, enum machine_mode);\n+extern int hard_reg_operand (rtx, enum machine_mode);\n+extern int soft_reg_operand (rtx, enum machine_mode);\n+extern int reg_or_some_mem_operand (rtx, enum machine_mode);\n \n #if defined TREE_CODE\n-extern void m68hc11_init_cumulative_args PARAMS((CUMULATIVE_ARGS*,\n-                                                 tree,\n-                                                 rtx));\n-\n-extern rtx m68hc11_function_arg PARAMS((const CUMULATIVE_ARGS* ,\n-                                        enum machine_mode,\n-                                        tree, int));\n-extern int m68hc11_function_arg_pass_by_reference PARAMS((const CUMULATIVE_ARGS*,\n-                                                          enum machine_mode,\n-                                                          tree,\n-                                                          int));\n-extern int m68hc11_function_arg_padding PARAMS((enum machine_mode, tree));\n-\n-extern void m68hc11_function_epilogue PARAMS((FILE*,int));\n-\n-extern int m68hc11_is_far_symbol PARAMS((rtx));\n-extern int m68hc11_is_trap_symbol PARAMS((rtx));\n+extern void m68hc11_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx);\n+\n+extern rtx m68hc11_function_arg (const CUMULATIVE_ARGS* ,\n+                                 enum machine_mode,\n+                                 tree, int);\n+extern int m68hc11_function_arg_pass_by_reference (const CUMULATIVE_ARGS*,\n+                                                   enum machine_mode,\n+                                                   tree,\n+                                                   int);\n+extern int m68hc11_function_arg_padding (enum machine_mode, tree);\n+\n+extern void m68hc11_function_epilogue (FILE*,int);\n+\n+extern int m68hc11_is_far_symbol (rtx);\n+extern int m68hc11_is_trap_symbol (rtx);\n \n #endif /* TREE_CODE */\n "}, {"sha": "9a8651dd4409ba7368a59d59cb817109e6d80fe3", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 151, "deletions": 291, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "patch": "@@ -59,34 +59,34 @@ Boston, MA 02111-1307, USA.\n #include \"target.h\"\n #include \"target-def.h\"\n \n-static void emit_move_after_reload PARAMS ((rtx, rtx, rtx));\n-static rtx simplify_logical PARAMS ((enum machine_mode, int, rtx, rtx *));\n-static void m68hc11_emit_logical PARAMS ((enum machine_mode, int, rtx *));\n-static void m68hc11_reorg PARAMS ((void));\n-static int go_if_legitimate_address_internal PARAMS((rtx, enum machine_mode,\n-                                                     int));\n-static int register_indirect_p PARAMS((rtx, enum machine_mode, int));\n-static rtx m68hc11_expand_compare PARAMS((enum rtx_code, rtx, rtx));\n-static int must_parenthesize PARAMS ((rtx));\n-static int m68hc11_address_cost PARAMS ((rtx));\n-static int m68hc11_shift_cost PARAMS ((enum machine_mode, rtx, int));\n-static int m68hc11_rtx_costs_1 PARAMS ((rtx, enum rtx_code, enum rtx_code));\n-static bool m68hc11_rtx_costs PARAMS ((rtx, int, int, int *));\n-static int m68hc11_auto_inc_p PARAMS ((rtx));\n-static tree m68hc11_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static void emit_move_after_reload (rtx, rtx, rtx);\n+static rtx simplify_logical (enum machine_mode, int, rtx, rtx *);\n+static void m68hc11_emit_logical (enum machine_mode, int, rtx *);\n+static void m68hc11_reorg (void);\n+static int go_if_legitimate_address_internal (rtx, enum machine_mode, int);\n+static int register_indirect_p (rtx, enum machine_mode, int);\n+static rtx m68hc11_expand_compare (enum rtx_code, rtx, rtx);\n+static int must_parenthesize (rtx);\n+static int m68hc11_address_cost (rtx);\n+static int m68hc11_shift_cost (enum machine_mode, rtx, int);\n+static int m68hc11_rtx_costs_1 (rtx, enum rtx_code, enum rtx_code);\n+static bool m68hc11_rtx_costs (rtx, int, int, int *);\n+static int m68hc11_auto_inc_p (rtx);\n+static tree m68hc11_handle_fntype_attribute (tree *, tree, tree, int, bool *);\n const struct attribute_spec m68hc11_attribute_table[];\n \n-void create_regs_rtx PARAMS ((void));\n+void create_regs_rtx (void);\n \n-static void asm_print_register PARAMS ((FILE *, int));\n-static void m68hc11_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void m68hc11_asm_out_constructor PARAMS ((rtx, int));\n-static void m68hc11_asm_out_destructor PARAMS ((rtx, int));\n-static void m68hc11_file_start PARAMS ((void));\n-static void m68hc11_encode_section_info PARAMS((tree, rtx, int));\n-static int autoinc_mode PARAMS((rtx));\n-static int m68hc11_make_autoinc_notes PARAMS((rtx *, void *));\n-static void m68hc11_init_libfuncs PARAMS ((void));\n+static void asm_print_register (FILE *, int);\n+static void m68hc11_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void m68hc11_asm_out_constructor (rtx, int);\n+static void m68hc11_asm_out_destructor (rtx, int);\n+static void m68hc11_file_start (void);\n+static void m68hc11_encode_section_info (tree, rtx, int);\n+static unsigned int m68hc11_section_type_flags (tree, const char*, int);\n+static int autoinc_mode (rtx);\n+static int m68hc11_make_autoinc_notes (rtx *, void *);\n+static void m68hc11_init_libfuncs (void);\n \n /* Must be set to 1 to produce debug messages.  */\n int debug_m6811 = 0;\n@@ -240,6 +240,9 @@ static int nb_soft_regs;\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO  m68hc11_encode_section_info\n \n+#undef TARGET_SECTION_TYPE_FLAGS\n+#define TARGET_SECTION_TYPE_FLAGS m68hc11_section_type_flags\n+\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS m68hc11_rtx_costs\n #undef TARGET_ADDRESS_COST\n@@ -254,7 +257,7 @@ static int nb_soft_regs;\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n int\n-m68hc11_override_options ()\n+m68hc11_override_options (void)\n {\n   memset (m68hc11_reg_valid_for_index, 0,\n \t  sizeof (m68hc11_reg_valid_for_index));\n@@ -320,7 +323,7 @@ m68hc11_override_options ()\n \n \n void\n-m68hc11_conditional_register_usage ()\n+m68hc11_conditional_register_usage (void)\n {\n   int i;\n   int cnt = atoi (m68hc11_soft_reg_count);\n@@ -353,7 +356,7 @@ static const char *const reg_class_names[] = REG_CLASS_NAMES;\n \n \n void\n-create_regs_rtx ()\n+create_regs_rtx (void)\n {\n   /*  regs_inited = 1; */\n   ix_reg = gen_rtx (REG, HImode, HARD_X_REGNUM);\n@@ -379,9 +382,7 @@ create_regs_rtx ()\n       registers.  They may be stored in soft registers if there are\n       enough of them.  */\n int\n-hard_regno_mode_ok (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n+hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n   switch (GET_MODE_SIZE (mode))\n     {\n@@ -409,8 +410,7 @@ hard_regno_mode_ok (regno, mode)\n }\n \n int\n-m68hc11_hard_regno_rename_ok (reg1, reg2)\n-     int reg1, reg2;\n+m68hc11_hard_regno_rename_ok (int reg1, int reg2)\n {\n   /* Don't accept renaming to Z register.  We will replace it to\n      X,Y or D during machine reorg pass.  */\n@@ -426,9 +426,7 @@ m68hc11_hard_regno_rename_ok (reg1, reg2)\n }\n \n enum reg_class\n-preferred_reload_class (operand, class)\n-     rtx operand;\n-     enum reg_class class;\n+preferred_reload_class (rtx operand, enum reg_class class)\n {\n   enum machine_mode mode;\n \n@@ -546,10 +544,7 @@ preferred_reload_class (operand, class)\n    For 68hc11:  n,r    with n in [0..255] and r in A_REGS class\n    For 68hc12:  n,r    no constraint on the constant, r in A_REGS class.  */\n static int\n-register_indirect_p (operand, mode, strict)\n-     rtx operand;\n-     enum machine_mode mode;\n-     int strict;\n+register_indirect_p (rtx operand, enum machine_mode mode, int strict)\n {\n   rtx base, offset;\n \n@@ -611,9 +606,7 @@ register_indirect_p (operand, mode, strict)\n /* Returns 1 if the operand fits in a 68HC11 indirect mode or in\n    a 68HC12 1-byte index addressing mode.  */\n int\n-m68hc11_small_indexed_indirect_p (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+m68hc11_small_indexed_indirect_p (rtx operand, enum machine_mode mode)\n {\n   rtx base, offset;\n \n@@ -674,9 +667,7 @@ m68hc11_small_indexed_indirect_p (operand, mode)\n }\n \n int\n-m68hc11_register_indirect_p (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+m68hc11_register_indirect_p (rtx operand, enum machine_mode mode)\n {\n   if (GET_CODE (operand) != MEM)\n     return 0;\n@@ -687,10 +678,8 @@ m68hc11_register_indirect_p (operand, mode)\n }\n \n static int\n-go_if_legitimate_address_internal (operand, mode, strict)\n-     rtx operand;\n-     enum machine_mode mode;\n-     int strict;\n+go_if_legitimate_address_internal (rtx operand, enum machine_mode mode,\n+                                   int strict)\n {\n   if (CONSTANT_ADDRESS_P (operand) && TARGET_M6812)\n     {\n@@ -717,10 +706,8 @@ go_if_legitimate_address_internal (operand, mode, strict)\n }\n \n int\n-m68hc11_go_if_legitimate_address (operand, mode, strict)\n-     rtx operand;\n-     enum machine_mode mode;\n-     int strict;\n+m68hc11_go_if_legitimate_address (rtx operand, enum machine_mode mode,\n+                                  int strict)\n {\n   int result;\n \n@@ -752,18 +739,16 @@ m68hc11_go_if_legitimate_address (operand, mode, strict)\n }\n \n int\n-m68hc11_legitimize_address (operand, old_operand, mode)\n-     rtx *operand ATTRIBUTE_UNUSED;\n-     rtx old_operand ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m68hc11_legitimize_address (rtx *operand ATTRIBUTE_UNUSED,\n+                            rtx old_operand ATTRIBUTE_UNUSED,\n+                            enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n \n \n int\n-m68hc11_reload_operands (operands)\n-     rtx operands[];\n+m68hc11_reload_operands (rtx operands[])\n {\n   enum machine_mode mode;\n \n@@ -858,13 +843,9 @@ m68hc11_reload_operands (operands)\n }\n \n void\n-m68hc11_emit_libcall (name, code, dmode, smode, noperands, operands)\n-     const char *name;\n-     enum rtx_code code;\n-     enum machine_mode dmode;\n-     enum machine_mode smode;\n-     int noperands;\n-     rtx *operands;\n+m68hc11_emit_libcall (const char *name, enum rtx_code code,\n+                      enum machine_mode dmode, enum machine_mode smode,\n+                      int noperands, rtx *operands)\n {\n   rtx ret;\n   rtx insns;\n@@ -902,8 +883,7 @@ m68hc11_emit_libcall (name, code, dmode, smode, noperands, operands)\n    (same as auto_inc_p() in rtlanal.c but do not take into\n    account the stack).  */\n static int\n-m68hc11_auto_inc_p (x)\n-     rtx x;\n+m68hc11_auto_inc_p (rtx x)\n {\n   return GET_CODE (x) == PRE_DEC\n     || GET_CODE (x) == POST_INC\n@@ -914,9 +894,7 @@ m68hc11_auto_inc_p (x)\n /* Predicates for machine description.  */\n \n int\n-memory_reload_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+memory_reload_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (operand) == MEM\n     && GET_CODE (XEXP (operand, 0)) == PLUS\n@@ -927,9 +905,7 @@ memory_reload_operand (operand, mode)\n }\n \n int\n-tst_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+tst_operand (rtx operand, enum machine_mode mode)\n {\n   if (GET_CODE (operand) == MEM && reload_completed == 0)\n     {\n@@ -941,9 +917,7 @@ tst_operand (operand, mode)\n }\n \n int\n-cmp_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+cmp_operand (rtx operand, enum machine_mode mode)\n {\n   if (GET_CODE (operand) == MEM)\n     {\n@@ -955,9 +929,7 @@ cmp_operand (operand, mode)\n }\n \n int\n-non_push_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+non_push_operand (rtx operand, enum machine_mode mode)\n {\n   if (general_operand (operand, mode) == 0)\n     return 0;\n@@ -968,9 +940,7 @@ non_push_operand (operand, mode)\n }\n \n int\n-reg_or_some_mem_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+reg_or_some_mem_operand (rtx operand, enum machine_mode mode)\n {\n   if (GET_CODE (operand) == MEM)\n     {\n@@ -992,9 +962,7 @@ reg_or_some_mem_operand (operand, mode)\n }\n \n int\n-m68hc11_symbolic_p (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+m68hc11_symbolic_p (rtx operand, enum machine_mode mode)\n {\n   if (GET_CODE (operand) == MEM)\n     {\n@@ -1007,9 +975,7 @@ m68hc11_symbolic_p (operand, mode)\n }\n \n int\n-m68hc11_indirect_p (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+m68hc11_indirect_p (rtx operand, enum machine_mode mode)\n {\n   if (GET_CODE (operand) == MEM)\n     {\n@@ -1028,17 +994,13 @@ m68hc11_indirect_p (operand, mode)\n }\n \n int\n-stack_register_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+stack_register_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return SP_REG_P (operand);\n }\n \n int\n-d_register_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+d_register_operand (rtx operand, enum machine_mode mode)\n {\n   if (GET_MODE (operand) != mode && mode != VOIDmode)\n     return 0;\n@@ -1053,9 +1015,7 @@ d_register_operand (operand, mode)\n }\n \n int\n-hard_addr_reg_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+hard_addr_reg_operand (rtx operand, enum machine_mode mode)\n {\n   if (GET_MODE (operand) != mode && mode != VOIDmode)\n     return 0;\n@@ -1070,9 +1030,7 @@ hard_addr_reg_operand (operand, mode)\n }\n \n int\n-hard_reg_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+hard_reg_operand (rtx operand, enum machine_mode mode)\n {\n   if (GET_MODE (operand) != mode && mode != VOIDmode)\n     return 0;\n@@ -1086,9 +1044,7 @@ hard_reg_operand (operand, mode)\n }\n \n int\n-memory_indexed_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+memory_indexed_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (operand) != MEM)\n     return 0;\n@@ -1107,8 +1063,7 @@ memory_indexed_operand (operand, mode)\n }\n \n int\n-push_pop_operand_p (operand)\n-     rtx operand;\n+push_pop_operand_p (rtx operand)\n {\n   if (GET_CODE (operand) != MEM)\n     {\n@@ -1122,9 +1077,7 @@ push_pop_operand_p (operand)\n    reference and a constant.  */\n \n int\n-symbolic_memory_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+symbolic_memory_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n@@ -1152,25 +1105,19 @@ symbolic_memory_operand (op, mode)\n }\n \n int\n-m68hc11_eq_compare_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m68hc11_eq_compare_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == EQ || GET_CODE (op) == NE;\n }\n \n int\n-m68hc11_logical_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m68hc11_logical_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR;\n }\n \n int\n-m68hc11_arith_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m68hc11_arith_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR\n     || GET_CODE (op) == PLUS || GET_CODE (op) == MINUS\n@@ -1180,29 +1127,23 @@ m68hc11_arith_operator (op, mode)\n }\n \n int\n-m68hc11_non_shift_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m68hc11_non_shift_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR\n     || GET_CODE (op) == PLUS || GET_CODE (op) == MINUS;\n }\n \n /* Return true if op is a shift operator.  */\n int\n-m68hc11_shift_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m68hc11_shift_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == ROTATE || GET_CODE (op) == ROTATERT\n     || GET_CODE (op) == LSHIFTRT || GET_CODE (op) == ASHIFT\n     || GET_CODE (op) == ASHIFTRT;\n }\n \n int\n-m68hc11_unary_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m68hc11_unary_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == NEG || GET_CODE (op) == NOT\n     || GET_CODE (op) == SIGN_EXTEND || GET_CODE (op) == ZERO_EXTEND;\n@@ -1218,10 +1159,7 @@ m68hc11_unary_operator (op, mode)\n \n */\n void\n-m68hc11_initialize_trampoline (tramp, fnaddr, cxt)\n-     rtx tramp;\n-     rtx fnaddr;\n-     rtx cxt;\n+m68hc11_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n {\n   const char *static_chain_reg = reg_names[STATIC_CHAIN_REGNUM];\n \n@@ -1276,12 +1214,10 @@ static rtx trap_handler_symbol = 0;\n /* Handle an attribute requiring a FUNCTION_TYPE, FIELD_DECL or TYPE_DECL;\n    arguments as in struct attribute_spec.handler.  */\n static tree\n-m68hc11_handle_fntype_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+m68hc11_handle_fntype_attribute (tree *node, tree name,\n+                                 tree args ATTRIBUTE_UNUSED,\n+                                 int flags ATTRIBUTE_UNUSED,\n+                                 bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_TYPE\n       && TREE_CODE (*node) != METHOD_TYPE\n@@ -1301,10 +1237,7 @@ m68hc11_handle_fntype_attribute (node, name, args, flags, no_add_attrs)\n    in SYMBOL_REF_FLAG.  */\n \n static void\n-m68hc11_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first ATTRIBUTE_UNUSED;\n+m68hc11_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n {\n   tree func_attr;\n   int trap_handler;\n@@ -1337,9 +1270,21 @@ m68hc11_encode_section_info (decl, rtl, first)\n   SYMBOL_REF_FLAG (XEXP (rtl, 0)) = is_far;\n }\n \n+static unsigned int\n+m68hc11_section_type_flags (tree decl, const char *name, int reloc)\n+{\n+  unsigned int flags = default_section_type_flags (decl, name, reloc);\n+\n+  if (strncmp (name, \".eeprom\", 7) == 0)\n+    {\n+      flags |= SECTION_WRITE | SECTION_CODE | SECTION_OVERRIDE;\n+    }\n+\n+  return flags;\n+}\n+\n int\n-m68hc11_is_far_symbol (sym)\n-     rtx sym;\n+m68hc11_is_far_symbol (rtx sym)\n {\n   if (GET_CODE (sym) == MEM)\n     sym = XEXP (sym, 0);\n@@ -1348,8 +1293,7 @@ m68hc11_is_far_symbol (sym)\n }\n \n int\n-m68hc11_is_trap_symbol (sym)\n-     rtx sym;\n+m68hc11_is_trap_symbol (rtx sym)\n {\n   if (GET_CODE (sym) == MEM)\n     sym = XEXP (sym, 0);\n@@ -1366,11 +1310,10 @@ m68hc11_is_trap_symbol (sym)\n    SCz: I tried to pass DImode by reference but it seems that this\n    does not work very well.  */\n int\n-m68hc11_function_arg_pass_by_reference (cum, mode, type, named)\n-     const CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+m68hc11_function_arg_pass_by_reference (const CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+                                        enum machine_mode mode ATTRIBUTE_UNUSED,\n+                                        tree type,\n+                                        int named ATTRIBUTE_UNUSED)\n {\n   return ((type && TREE_CODE (type) == ARRAY_TYPE)\n \t  /* Consider complex values as aggregates, so care for TCmode.  */\n@@ -1382,9 +1325,7 @@ m68hc11_function_arg_pass_by_reference (cum, mode, type, named)\n /* Define the offset between two registers, one to be eliminated, and the\n    other its replacement, at the start of a routine.  */\n int\n-m68hc11_initial_elimination_offset (from, to)\n-     int from;\n-     int to;\n+m68hc11_initial_elimination_offset (int from, int to)\n {\n   int trap_handler;\n   tree func_attr;\n@@ -1451,10 +1392,7 @@ m68hc11_initial_elimination_offset (from, to)\n    For a library call, FNTYPE is 0.  */\n \n void\n-m68hc11_init_cumulative_args (cum, fntype, libname)\n-     CUMULATIVE_ARGS *cum;\n-     tree fntype;\n-     rtx libname;\n+m68hc11_init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx libname)\n {\n   tree ret_type;\n \n@@ -1507,11 +1445,8 @@ m68hc11_init_cumulative_args (cum, fntype, libname)\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n void\n-m68hc11_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+m68hc11_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                              tree type, int named ATTRIBUTE_UNUSED)\n {\n   if (mode != BLKmode)\n     {\n@@ -1548,11 +1483,8 @@ m68hc11_function_arg_advance (cum, mode, type, named)\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n struct rtx_def *\n-m68hc11_function_arg (cum, mode, type, named)\n-     const CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type ATTRIBUTE_UNUSED;\n-     int named ATTRIBUTE_UNUSED;\n+m68hc11_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                      tree type ATTRIBUTE_UNUSED, int named ATTRIBUTE_UNUSED)\n {\n   if (cum->words != 0)\n     {\n@@ -1580,9 +1512,7 @@ m68hc11_function_arg (cum, mode, type, named)\n \n    Structures are stored left shifted in their argument slot.  */\n int\n-m68hc11_function_arg_padding (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+m68hc11_function_arg_padding (enum machine_mode mode, tree type)\n {\n   if (type != 0 && AGGREGATE_TYPE_P (type))\n     return upward;\n@@ -1597,8 +1527,7 @@ m68hc11_function_arg_padding (mode, type)\n /* Emit a move after the reload pass has completed.  This is used to\n    emit the prologue and epilogue.  */\n static void\n-emit_move_after_reload (to, from, scratch)\n-     rtx to, from, scratch;\n+emit_move_after_reload (rtx to, rtx from, rtx scratch)\n {\n   rtx insn;\n \n@@ -1640,7 +1569,7 @@ emit_move_after_reload (to, from, scratch)\n }\n \n int\n-m68hc11_total_frame_size ()\n+m68hc11_total_frame_size (void)\n {\n   int size;\n   int regno;\n@@ -1661,17 +1590,16 @@ m68hc11_total_frame_size ()\n }\n \n static void\n-m68hc11_output_function_epilogue (out, size)\n-     FILE *out ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+m68hc11_output_function_epilogue (FILE *out ATTRIBUTE_UNUSED,\n+                                  HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   /* We catch the function epilogue generation to have a chance\n      to clear the z_replacement_completed flag.  */\n   z_replacement_completed = 0;\n }\n \n void\n-expand_prologue ()\n+expand_prologue (void)\n {\n   tree func_attr;\n   int size;\n@@ -1775,7 +1703,7 @@ expand_prologue ()\n }\n \n void\n-expand_epilogue ()\n+expand_epilogue (void)\n {\n   int size;\n   register int regno;\n@@ -1888,9 +1816,7 @@ expand_epilogue ()\n    fixed to work for constants and 68HC11 specific registers.  */\n \n rtx\n-m68hc11_gen_lowpart (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+m68hc11_gen_lowpart (enum machine_mode mode, rtx x)\n {\n   /* We assume that the low part of an auto-inc mode is the same with\n      the mode changed and that the caller split the larger mode in the\n@@ -1965,9 +1891,7 @@ m68hc11_gen_lowpart (mode, x)\n }\n \n rtx\n-m68hc11_gen_highpart (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+m68hc11_gen_highpart (enum machine_mode mode, rtx x)\n {\n   /* We assume that the high part of an auto-inc mode is the same with\n      the mode changed and that the caller split the larger mode in the\n@@ -2086,9 +2010,7 @@ m68hc11_gen_highpart (mode, x)\n    of code when we know that some register dies or can be clobbered.  */\n \n int\n-dead_register_here (x, reg)\n-     rtx x;\n-     rtx reg;\n+dead_register_here (rtx x, rtx reg)\n {\n   rtx x_reg;\n   rtx p;\n@@ -2166,9 +2088,7 @@ dead_register_here (x, reg)\n \n /* Print the name of register 'regno' in the assembly file.  */\n static void\n-asm_print_register (file, regno)\n-     FILE *file;\n-     int regno;\n+asm_print_register (FILE *file, int regno)\n {\n   const char *name = reg_names[regno];\n \n@@ -2211,10 +2131,7 @@ asm_print_register (file, regno)\n        ignored.  */\n \n void\n-print_operand (file, op, letter)\n-     FILE *file;\n-     rtx op;\n-     int letter;\n+print_operand (FILE *file, rtx op, int letter)\n {\n   if (letter == 't')\n     {\n@@ -2367,8 +2284,7 @@ print_operand (file, op, letter)\n    around it.  This must be done only if there is a symbol whose name\n    is a processor register.  */\n static int\n-must_parenthesize (op)\n-     rtx op;\n+must_parenthesize (rtx op)\n {\n   const char *name;\n \n@@ -2414,9 +2330,7 @@ must_parenthesize (op)\n    reference whose address is ADDR.  ADDR is an RTL expression.  */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   rtx base;\n   rtx offset;\n@@ -2567,9 +2481,7 @@ print_operand_address (file, addr)\n /* Splitting of some instructions.  */\n \n static rtx\n-m68hc11_expand_compare (code, op0, op1)\n-     enum rtx_code code;\n-     rtx op0, op1;\n+m68hc11_expand_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx ret = 0;\n \n@@ -2586,9 +2498,8 @@ m68hc11_expand_compare (code, op0, op1)\n }\n \n rtx\n-m68hc11_expand_compare_and_branch (code, op0, op1, label)\n-     enum rtx_code code;\n-     rtx op0, op1, label;\n+m68hc11_expand_compare_and_branch (enum rtx_code code, rtx op0, rtx op1,\n+                                   rtx label)\n {\n   rtx tmp;\n \n@@ -2740,8 +2651,7 @@ m68hc11_expand_compare_and_branch (code, op0, op1, label)\n /* Return the increment/decrement mode of a MEM if it is such.\n    Return CONST if it is anything else.  */\n static int\n-autoinc_mode (x)\n-     rtx x;\n+autoinc_mode (rtx x)\n {\n   if (GET_CODE (x) != MEM)\n     return CONST;\n@@ -2757,9 +2667,7 @@ autoinc_mode (x)\n }\n \n static int\n-m68hc11_make_autoinc_notes (x, data)\n-     rtx *x;\n-     void *data;\n+m68hc11_make_autoinc_notes (rtx *x, void *data)\n {\n   rtx insn;\n   \n@@ -2783,8 +2691,7 @@ m68hc11_make_autoinc_notes (x, data)\n    The scratch register 'scratch' is used as a temporary to load\n    store intermediate values.  It must be a hard register.  */\n void\n-m68hc11_split_move (to, from, scratch)\n-     rtx to, from, scratch;\n+m68hc11_split_move (rtx to, rtx from, rtx scratch)\n {\n   rtx low_to, low_from;\n   rtx high_to, high_from;\n@@ -2990,11 +2897,7 @@ m68hc11_split_move (to, from, scratch)\n }\n \n static rtx\n-simplify_logical (mode, code, operand, result)\n-     enum machine_mode mode;\n-     int code;\n-     rtx operand;\n-     rtx *result;\n+simplify_logical (enum machine_mode mode, int code, rtx operand, rtx *result)\n {\n   int val;\n   int mask;\n@@ -3034,10 +2937,7 @@ simplify_logical (mode, code, operand, result)\n }\n \n static void\n-m68hc11_emit_logical (mode, code, operands)\n-     enum machine_mode mode;\n-     int code;\n-     rtx *operands;\n+m68hc11_emit_logical (enum machine_mode mode, int code, rtx *operands)\n {\n   rtx result;\n   int need_copy;\n@@ -3106,10 +3006,7 @@ m68hc11_emit_logical (mode, code, operands)\n }\n \n void\n-m68hc11_split_logical (mode, code, operands)\n-     enum machine_mode mode;\n-     int code;\n-     rtx *operands;\n+m68hc11_split_logical (enum machine_mode mode, int code, rtx *operands)\n {\n   rtx low[4];\n   rtx high[4];\n@@ -3157,9 +3054,7 @@ m68hc11_split_logical (mode, code, operands)\n /* Code generation.  */\n \n void\n-m68hc11_output_swap (insn, operands)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx operands[];\n+m68hc11_output_swap (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n {\n   /* We have to be careful with the cc_status.  An address register swap\n      is generated for some comparison.  The comparison is made with D\n@@ -3211,9 +3106,7 @@ m68hc11_output_swap (insn, operands)\n    This is used to decide whether a move that set flags should be used\n    instead.  */\n int\n-next_insn_test_reg (insn, reg)\n-     rtx insn;\n-     rtx reg;\n+next_insn_test_reg (rtx insn, rtx reg)\n {\n   rtx body;\n \n@@ -3234,9 +3127,7 @@ next_insn_test_reg (insn, reg)\n /* Generate the code to move a 16-bit operand into another one.  */\n \n void\n-m68hc11_gen_movhi (insn, operands)\n-     rtx insn;\n-     rtx *operands;\n+m68hc11_gen_movhi (rtx insn, rtx *operands)\n {\n   int reg;\n \n@@ -3650,9 +3541,7 @@ m68hc11_gen_movhi (insn, operands)\n }\n \n void\n-m68hc11_gen_movqi (insn, operands)\n-     rtx insn;\n-     rtx *operands;\n+m68hc11_gen_movqi (rtx insn, rtx *operands)\n {\n   /* Move a register or memory to the same location.\n      This is possible because such insn can appear\n@@ -3932,10 +3821,7 @@ m68hc11_gen_movqi (insn, operands)\n    The source and destination must be D or A and the shift must\n    be a constant.  */\n void\n-m68hc11_gen_rotate (code, insn, operands)\n-     enum rtx_code code;\n-     rtx insn;\n-     rtx operands[];\n+m68hc11_gen_rotate (enum rtx_code code, rtx insn, rtx operands[])\n {\n   int val;\n   \n@@ -4014,9 +3900,7 @@ m68hc11_gen_rotate (code, insn, operands)\n    Do not alter them if the instruction would not alter the cc's.  */\n \n void\n-m68hc11_notice_update_cc (exp, insn)\n-     rtx exp;\n-     rtx insn ATTRIBUTE_UNUSED;\n+m68hc11_notice_update_cc (rtx exp, rtx insn ATTRIBUTE_UNUSED)\n {\n   /* recognize SET insn's.  */\n   if (GET_CODE (exp) == SET)\n@@ -4116,8 +4000,7 @@ m68hc11_notice_update_cc (exp, insn)\n    the register 'reg'.  See if the previous flags can be kept for the\n    next instruction to avoid a comparison.  */\n void\n-m68hc11_notice_keep_cc (reg)\n-     rtx reg;\n+m68hc11_notice_keep_cc (rtx reg)\n {\n   if (reg == 0\n       || cc_prev_status.value1 == 0\n@@ -4192,10 +4075,10 @@ struct replace_info\n   int z_loaded_with_sp;\n };\n \n-static int m68hc11_check_z_replacement PARAMS ((rtx, struct replace_info *));\n-static void m68hc11_find_z_replacement PARAMS ((rtx, struct replace_info *));\n-static void m68hc11_z_replacement PARAMS ((rtx));\n-static void m68hc11_reassign_regs PARAMS ((rtx));\n+static int m68hc11_check_z_replacement (rtx, struct replace_info *);\n+static void m68hc11_find_z_replacement (rtx, struct replace_info *);\n+static void m68hc11_z_replacement (rtx);\n+static void m68hc11_reassign_regs (rtx);\n \n int z_replacement_completed = 0;\n \n@@ -4205,9 +4088,7 @@ int z_replacement_completed = 0;\n    continue replacement in next insns.  */\n \n static int\n-m68hc11_check_z_replacement (insn, info)\n-     rtx insn;\n-     struct replace_info *info;\n+m68hc11_check_z_replacement (rtx insn, struct replace_info *info)\n {\n   int this_insn_uses_ix;\n   int this_insn_uses_iy;\n@@ -4770,9 +4651,7 @@ m68hc11_check_z_replacement (insn, info)\n }\n \n static void\n-m68hc11_find_z_replacement (insn, info)\n-     rtx insn;\n-     struct replace_info *info;\n+m68hc11_find_z_replacement (rtx insn, struct replace_info *info)\n {\n   int reg;\n \n@@ -4883,8 +4762,7 @@ m68hc11_find_z_replacement (insn, info)\n    Z and of the replacement register.  */\n \n static void\n-m68hc11_z_replacement (insn)\n-     rtx insn;\n+m68hc11_z_replacement (rtx insn)\n {\n   rtx replace_reg_qi;\n   rtx replace_reg;\n@@ -5094,8 +4972,7 @@ m68hc11_z_replacement (insn)\n       on the instruction.  */\n \n static void\n-m68hc11_reassign_regs (first)\n-     rtx first;\n+m68hc11_reassign_regs (rtx first)\n {\n   rtx insn;\n \n@@ -5159,7 +5036,7 @@ m68hc11_reassign_regs (first)\n    'z_replacement_completed' is set to 2.  */\n \n static void\n-m68hc11_reorg ()\n+m68hc11_reorg (void)\n {\n   int split_done = 0;\n   rtx insn, first;\n@@ -5277,10 +5154,8 @@ m68hc11_init_libfuncs (void)\n \n /* Cost of moving memory.  */\n int\n-m68hc11_memory_move_cost (mode, class, in)\n-     enum machine_mode mode;\n-     enum reg_class class;\n-     int in ATTRIBUTE_UNUSED;\n+m68hc11_memory_move_cost (enum machine_mode mode, enum reg_class class,\n+                          int in ATTRIBUTE_UNUSED)\n {\n   if (class <= H_REGS && class > NO_REGS)\n     {\n@@ -5304,10 +5179,8 @@ m68hc11_memory_move_cost (mode, class, in)\n    have a move cost of 2.  Setting a higher cost will force reload to check\n    the constraints.  */\n int\n-m68hc11_register_move_cost (mode, from, to)\n-     enum machine_mode mode;\n-     enum reg_class from;\n-     enum reg_class to;\n+m68hc11_register_move_cost (enum machine_mode mode, enum reg_class from,\n+                            enum reg_class to)\n {\n   /* All costs are symmetric, so reduce cases by putting the\n      lower number class as the destination.  */\n@@ -5329,8 +5202,7 @@ m68hc11_register_move_cost (mode, from, to)\n    If ADDR is not a valid address, its cost is irrelevant.  */\n \n static int\n-m68hc11_address_cost (addr)\n-     rtx addr;\n+m68hc11_address_cost (rtx addr)\n {\n   int cost = 4;\n \n@@ -5411,10 +5283,7 @@ m68hc11_address_cost (addr)\n }\n \n static int\n-m68hc11_shift_cost (mode, x, shift)\n-     enum machine_mode mode;\n-     rtx x;\n-     int shift;\n+m68hc11_shift_cost (enum machine_mode mode, rtx x, int shift)\n {\n   int total;\n \n@@ -5443,10 +5312,8 @@ m68hc11_shift_cost (mode, x, shift)\n }\n \n static int\n-m68hc11_rtx_costs_1 (x, code, outer_code)\n-     rtx x;\n-     enum rtx_code code;\n-     enum rtx_code outer_code ATTRIBUTE_UNUSED;\n+m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n+                     enum rtx_code outer_code ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = GET_MODE (x);\n   int extra_cost = 0;\n@@ -5579,10 +5446,7 @@ m68hc11_rtx_costs_1 (x, code, outer_code)\n }\n \n static bool\n-m68hc11_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+m68hc11_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -5634,7 +5498,7 @@ m68hc11_rtx_costs (x, code, outer_code, total)\n \f\n \n static void\n-m68hc11_file_start ()\n+m68hc11_file_start (void)\n {\n   default_file_start ();\n   \n@@ -5643,18 +5507,14 @@ m68hc11_file_start ()\n \n \n static void\n-m68hc11_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+m68hc11_asm_out_constructor (rtx symbol, int priority)\n {\n   default_ctor_section_asm_out_constructor (symbol, priority);\n   fprintf (asm_out_file, \"\\t.globl\\t__do_global_ctors\\n\");\n }\n \n static void\n-m68hc11_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+m68hc11_asm_out_destructor (rtx symbol, int priority)\n {\n   default_dtor_section_asm_out_destructor (symbol, priority);\n   fprintf (asm_out_file, \"\\t.globl\\t__do_global_dtors\\n\");"}]}