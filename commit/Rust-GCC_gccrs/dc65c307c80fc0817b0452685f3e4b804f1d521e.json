{"sha": "dc65c307c80fc0817b0452685f3e4b804f1d521e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM2NWMzMDdjODBmYzA4MTdiMDQ1MjY4NWYzZTRiODA0ZjFkNTIxZQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-06-27T21:10:17Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-06-27T21:10:17Z"}, "message": "s390.h (SECONDARY_OUTPUT_RELOAD_CLASS): Define.\n\ngcc/ChangeLog:\n\n\t* config/s390/s390.h (SECONDARY_OUTPUT_RELOAD_CLASS): Define.\n\t* config/s390/s390.c (s390_secondary_output_reload_class): New function.\n\t* config/s390/s390-protos.h (s390_secondary_output_reload_class):\n\tDeclare it.\n\t* config/s390/s390.md (\"reload_outti\", \"reload_outdi\",\n\t\"reload_outdf\"): New expanders.\n\n\t* config/s390/s390.md (\"movti\" + splitters): Handle non-offsettable\n\tmemory operands as source.\n\t(\"movdi\" + splitters): Likewise.\n\t(\"movdf\" + splitters): Likewise.\n\t* config/s390/s390.c (s390_split_ok_p): New function.\n\t* config/s390/s390-protos.h (s390_split_ok_p): Declare it.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/20030627-1.c: New test.\n\nFrom-SVN: r68607", "tree": {"sha": "68fab34b88702b49fc7577b098abc9faec381d81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68fab34b88702b49fc7577b098abc9faec381d81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc65c307c80fc0817b0452685f3e4b804f1d521e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc65c307c80fc0817b0452685f3e4b804f1d521e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc65c307c80fc0817b0452685f3e4b804f1d521e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc65c307c80fc0817b0452685f3e4b804f1d521e/comments", "author": null, "committer": null, "parents": [{"sha": "5bbd6c3ee0886c0dbd5c056aad8c950f13e35e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bbd6c3ee0886c0dbd5c056aad8c950f13e35e82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bbd6c3ee0886c0dbd5c056aad8c950f13e35e82"}], "stats": {"total": 304, "additions": 208, "deletions": 96}, "files": [{"sha": "8a6872fc14e23a94fbc2673d8259b0b60daa5353", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc65c307c80fc0817b0452685f3e4b804f1d521e", "patch": "@@ -1,3 +1,19 @@\n+2003-06-27  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.h (SECONDARY_OUTPUT_RELOAD_CLASS): Define.\n+\t* config/s390/s390.c (s390_secondary_output_reload_class): New function.\n+\t* config/s390/s390-protos.h (s390_secondary_output_reload_class): \n+\tDeclare it.\n+\t* config/s390/s390.md (\"reload_outti\", \"reload_outdi\", \n+\t\"reload_outdf\"): New expanders.\n+\n+\t* config/s390/s390.md (\"movti\" + splitters): Handle non-offsettable\n+\tmemory operands as source.\n+\t(\"movdi\" + splitters): Likewise.\n+\t(\"movdf\" + splitters): Likewise.\n+\t* config/s390/s390.c (s390_split_ok_p): New function.\n+\t* config/s390/s390-protos.h (s390_split_ok_p): Declare it.\n+\n 2003-06-27  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* combine.c (force_to_mode): Replace the equality comparison"}, {"sha": "c33018f3a3119d8e54abe0e41169a875077fa1c1", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=dc65c307c80fc0817b0452685f3e4b804f1d521e", "patch": "@@ -42,6 +42,7 @@ extern int s390_single_hi PARAMS ((rtx, enum machine_mode, int));\n extern int s390_extract_hi PARAMS ((rtx, enum machine_mode, int));\n extern int s390_single_qi PARAMS ((rtx, enum machine_mode, int));\n extern int s390_extract_qi PARAMS ((rtx, enum machine_mode, int));\n+extern bool s390_split_ok_p PARAMS ((rtx, rtx, enum machine_mode, int));\n extern int tls_symbolic_operand PARAMS ((rtx));\n \n extern int s390_match_ccmode PARAMS ((rtx, enum machine_mode));\n@@ -60,6 +61,7 @@ extern rtx legitimize_pic_address PARAMS ((rtx, rtx));\n extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern enum reg_class s390_preferred_reload_class PARAMS ((rtx, enum reg_class));\n extern enum reg_class s390_secondary_input_reload_class PARAMS ((enum reg_class, enum machine_mode, rtx));\n+extern enum reg_class s390_secondary_output_reload_class PARAMS ((enum reg_class, enum machine_mode, rtx));\n extern int s390_plus_operand PARAMS ((rtx, enum machine_mode));\n extern void s390_expand_plus_operand PARAMS ((rtx, rtx, rtx));\n extern void emit_symbolic_move PARAMS ((rtx *));"}, {"sha": "dc02d229153318cdb114ca7d280e5822de353e89", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=dc65c307c80fc0817b0452685f3e4b804f1d521e", "patch": "@@ -863,6 +863,42 @@ s390_extract_qi (op, mode, part)\n   abort ();\n }\n \n+/* Check whether we can (and want to) split a double-word \n+   move in mode MODE from SRC to DST into two single-word \n+   moves, moving the subword FIRST_SUBWORD first.  */\n+\n+bool\n+s390_split_ok_p (dst, src, mode, first_subword)\n+     rtx dst;\n+     rtx src;\n+     enum machine_mode mode;\n+     int first_subword;\n+{\n+  /* Floating point registers cannot be split.  */\n+  if (FP_REG_P (src) || FP_REG_P (dst))\n+    return false;\n+\n+  /* We don't need to split if operands are directly accessable.  */\n+  if (s_operand (src, mode) || s_operand (dst, mode))\n+    return false;\n+\n+  /* Non-offsettable memory references cannot be split.  */\n+  if ((GET_CODE (src) == MEM && !offsettable_memref_p (src))\n+      || (GET_CODE (dst) == MEM && !offsettable_memref_p (dst)))\n+    return false;\n+\n+  /* Moving the first subword must not clobber a register\n+     needed to move the second subword.  */\n+  if (register_operand (dst, mode))\n+    {\n+      rtx subreg = operand_subword (dst, first_subword, 0, mode);\n+      if (reg_overlap_mentioned_p (subreg, src))\n+        return false;\n+    }\n+\n+  return true;\n+}\n+\n \n /* Change optimizations to be performed, depending on the \n    optimization level.\n@@ -1715,6 +1751,29 @@ s390_secondary_input_reload_class (class, mode, in)\n   return NO_REGS;\n }\n \n+/* Return the register class of a scratch register needed to\n+   store a register of class CLASS in MODE into OUT:\n+\n+   We need a temporary when storing a double-word to a \n+   non-offsettable memory address.  */\n+\n+enum reg_class\n+s390_secondary_output_reload_class (class, mode, out)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx out;\n+{\n+  if ((TARGET_64BIT ? mode == TImode\n+                    : (mode == DImode || mode == DFmode))\n+      && reg_classes_intersect_p (GENERAL_REGS, class)\n+      && GET_CODE (out) == MEM\n+      && !offsettable_memref_p (out)\n+      && !s_operand (out, VOIDmode))\n+    return ADDR_REGS;\n+\n+  return NO_REGS;\n+}\n+\n /* Return true if OP is a PLUS that is not a legitimate\n    operand for the LA instruction. \n    OP is the current operation."}, {"sha": "7848d7d971f5ac483eda820ba790be31bb8951c7", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=dc65c307c80fc0817b0452685f3e4b804f1d521e", "patch": "@@ -460,6 +460,11 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\\\n   s390_secondary_input_reload_class ((CLASS), (MODE), (IN))\n \n+/* We need a secondary reload when storing a double-word\n+   to a non-offsettable memory address.  */\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, OUT)\t\\\n+  s390_secondary_output_reload_class ((CLASS), (MODE), (OUT))\n+\n /* We need secondary memory to move data between GPRs and FPRs.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n  ((CLASS1) != (CLASS2) && ((CLASS1) == FP_REGS || (CLASS2) == FP_REGS))"}, {"sha": "b5a222be1269da678521f8694f78fba2327979be", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 102, "deletions": 96, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=dc65c307c80fc0817b0452685f3e4b804f1d521e", "patch": "@@ -905,7 +905,7 @@\n \n (define_insn \"movti\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,Q,d,o,Q\")\n-        (match_operand:TI 1 \"general_operand\" \"Q,d,dKo,d,Q\"))]\n+        (match_operand:TI 1 \"general_operand\" \"Q,d,dKm,d,Q\"))]\n   \"TARGET_64BIT\"\n   \"@\n    lmg\\\\t%0,%N0,%1\n@@ -920,49 +920,53 @@\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TI 1 \"general_operand\" \"\"))]\n   \"TARGET_64BIT && reload_completed\n-   && !s_operand (operands[0], VOIDmode)\n-   && !s_operand (operands[1], VOIDmode)\n-   && (register_operand (operands[0], VOIDmode)\n-       || register_operand (operands[1], VOIDmode))\n-   && (!register_operand (operands[0], VOIDmode)\n-       || !reg_overlap_mentioned_p (operand_subword (operands[0], 0, 0, TImode),\n-                                    operands[1])\n-       || !reg_overlap_mentioned_p (operand_subword (operands[0], 1, 0, TImode),\n-                                    operands[1]))\"\n+   && s390_split_ok_p (operands[0], operands[1], TImode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n-  \"\n {\n-  if (!register_operand (operands[0], VOIDmode)\n-      || !reg_overlap_mentioned_p (operand_subword (operands[0], 0, 0, TImode),\n-                                   operands[1]))\n-    {\n-      operands[2] = operand_subword (operands[0], 0, 0, TImode);\n-      operands[3] = operand_subword (operands[0], 1, 0, TImode);\n-      operands[4] = operand_subword (operands[1], 0, 0, TImode);\n-      operands[5] = operand_subword (operands[1], 1, 0, TImode);\n-    }\n-  else\n-    {\n-      operands[2] = operand_subword (operands[0], 1, 0, TImode);\n-      operands[3] = operand_subword (operands[0], 0, 0, TImode);\n-      operands[4] = operand_subword (operands[1], 1, 0, TImode);\n-      operands[5] = operand_subword (operands[1], 0, 0, TImode);\n-    }\n-}\")\n+  operands[2] = operand_subword (operands[0], 0, 0, TImode);\n+  operands[3] = operand_subword (operands[0], 1, 0, TImode);\n+  operands[4] = operand_subword (operands[1], 0, 0, TImode);\n+  operands[5] = operand_subword (operands[1], 1, 0, TImode);\n+})\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TI 1 \"general_operand\" \"\"))]\n+  \"TARGET_64BIT && reload_completed\n+   && s390_split_ok_p (operands[0], operands[1], TImode, 1)\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = operand_subword (operands[0], 1, 0, TImode);\n+  operands[3] = operand_subword (operands[0], 0, 0, TImode);\n+  operands[4] = operand_subword (operands[1], 1, 0, TImode);\n+  operands[5] = operand_subword (operands[1], 0, 0, TImode);\n+})\n \n (define_split\n   [(set (match_operand:TI 0 \"register_operand\" \"\")\n         (match_operand:TI 1 \"memory_operand\" \"\"))]\n   \"TARGET_64BIT && reload_completed\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n-  \"\n {\n   rtx addr = operand_subword (operands[0], 1, 0, TImode);\n   s390_load_address (addr, XEXP (operands[1], 0));\n   operands[1] = replace_equiv_address (operands[1], addr);\n-}\")\n+})\n+\n+(define_expand \"reload_outti\"\n+  [(parallel [(match_operand:TI 0 \"memory_operand\" \"\")\n+              (match_operand:TI 1 \"register_operand\" \"d\")\n+              (match_operand:DI 2 \"register_operand\" \"=&a\")])]\n+  \"TARGET_64BIT\"\n+{\n+  s390_load_address (operands[2], XEXP (operands[0], 0));\n+  operands[0] = replace_equiv_address (operands[0], operands[2]);\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n \n ;\n ; movdi instruction pattern(s).\n@@ -1044,7 +1048,7 @@\n \n (define_insn \"*movdi_31\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,Q,d,o,!*f,!*f,!m,Q\")\n-        (match_operand:DI 1 \"general_operand\" \"Q,d,dKo,d,*f,m,*f,Q\"))]\n+        (match_operand:DI 1 \"general_operand\" \"Q,d,dKm,d,*f,m,*f,Q\"))]\n   \"!TARGET_64BIT\"\n   \"@\n    lm\\\\t%0,%N0,%1\n@@ -1062,53 +1066,54 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && !FP_REG_P (operands[0])\n-   && !FP_REG_P (operands[1])\n-   && !s_operand (operands[0], VOIDmode)\n-   && !s_operand (operands[1], VOIDmode)\n-   && (register_operand (operands[0], VOIDmode)\n-       || register_operand (operands[1], VOIDmode))\n-   && (!register_operand (operands[0], VOIDmode)\n-       || !reg_overlap_mentioned_p (operand_subword (operands[0], 0, 0, DImode),\n-                                    operands[1])\n-       || !reg_overlap_mentioned_p (operand_subword (operands[0], 1, 0, DImode),\n-                                    operands[1]))\"\n+   && s390_split_ok_p (operands[0], operands[1], DImode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n-  \"\n {\n-  if (!register_operand (operands[0], VOIDmode)\n-      || !reg_overlap_mentioned_p (operand_subword (operands[0], 0, 0, DImode),\n-                                   operands[1]))\n-    {\n-      operands[2] = operand_subword (operands[0], 0, 0, DImode);\n-      operands[3] = operand_subword (operands[0], 1, 0, DImode);\n-      operands[4] = operand_subword (operands[1], 0, 0, DImode);\n-      operands[5] = operand_subword (operands[1], 1, 0, DImode);\n-    }\n-  else\n-    {\n-      operands[2] = operand_subword (operands[0], 1, 0, DImode);\n-      operands[3] = operand_subword (operands[0], 0, 0, DImode);\n-      operands[4] = operand_subword (operands[1], 1, 0, DImode);\n-      operands[5] = operand_subword (operands[1], 0, 0, DImode);\n-    }\n-}\")\n+  operands[2] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[3] = operand_subword (operands[0], 1, 0, DImode);\n+  operands[4] = operand_subword (operands[1], 0, 0, DImode);\n+  operands[5] = operand_subword (operands[1], 1, 0, DImode);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"!TARGET_64BIT && reload_completed\n+   && s390_split_ok_p (operands[0], operands[1], DImode, 1)\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = operand_subword (operands[0], 1, 0, DImode);\n+  operands[3] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[4] = operand_subword (operands[1], 1, 0, DImode);\n+  operands[5] = operand_subword (operands[1], 0, 0, DImode);\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"memory_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n    && !FP_REG_P (operands[0])\n-   && !FP_REG_P (operands[1])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n-  \"\n {\n   rtx addr = operand_subword (operands[0], 1, 0, DImode);\n   s390_load_address (addr, XEXP (operands[1], 0));\n   operands[1] = replace_equiv_address (operands[1], addr);\n-}\")\n+})\n+\n+(define_expand \"reload_outdi\"\n+  [(parallel [(match_operand:DI 0 \"memory_operand\" \"\")\n+              (match_operand:DI 1 \"register_operand\" \"d\")\n+              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n+  \"!TARGET_64BIT\"\n+{\n+  s390_load_address (operands[2], XEXP (operands[0], 0));\n+  operands[0] = replace_equiv_address (operands[0], operands[2]);\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n \n (define_peephole2\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -1354,7 +1359,7 @@\n \n (define_insn \"*movdf_31\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,m,d,Q,d,o,Q\")\n-        (match_operand:DF 1 \"general_operand\" \"f,m,f,Q,d,dKo,d,Q\"))]\n+        (match_operand:DF 1 \"general_operand\" \"f,m,f,Q,d,dKm,d,Q\"))]\n   \"!TARGET_64BIT\"\n   \"@\n    ldr\\\\t%0,%1\n@@ -1372,53 +1377,54 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DF 1 \"general_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && !FP_REG_P (operands[0])\n-   && !FP_REG_P (operands[1])\n-   && !s_operand (operands[0], VOIDmode)\n-   && !s_operand (operands[1], VOIDmode)\n-   && (register_operand (operands[0], VOIDmode)\n-       || register_operand (operands[1], VOIDmode))\n-   && (!register_operand (operands[0], VOIDmode)\n-       || !reg_overlap_mentioned_p (operand_subword (operands[0], 0, 0, DFmode),\n-                                    operands[1])\n-       || !reg_overlap_mentioned_p (operand_subword (operands[0], 1, 0, DFmode),\n-                                    operands[1]))\"\n+   && s390_split_ok_p (operands[0], operands[1], DFmode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n-  \"\n {\n-  if (!register_operand (operands[0], VOIDmode)\n-      || !reg_overlap_mentioned_p (operand_subword (operands[0], 0, 0, DFmode),\n-                                   operands[1]))\n-    {\n-      operands[2] = operand_subword (operands[0], 0, 0, DFmode);\n-      operands[3] = operand_subword (operands[0], 1, 0, DFmode);\n-      operands[4] = operand_subword (operands[1], 0, 0, DFmode);\n-      operands[5] = operand_subword (operands[1], 1, 0, DFmode);\n-    }\n-  else\n-    {\n-      operands[2] = operand_subword (operands[0], 1, 0, DFmode);\n-      operands[3] = operand_subword (operands[0], 0, 0, DFmode);\n-      operands[4] = operand_subword (operands[1], 1, 0, DFmode);\n-      operands[5] = operand_subword (operands[1], 0, 0, DFmode);\n-    }\n-}\")\n+  operands[2] = operand_subword (operands[0], 0, 0, DFmode);\n+  operands[3] = operand_subword (operands[0], 1, 0, DFmode);\n+  operands[4] = operand_subword (operands[1], 0, 0, DFmode);\n+  operands[5] = operand_subword (operands[1], 1, 0, DFmode);\n+})\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"!TARGET_64BIT && reload_completed\n+   && s390_split_ok_p (operands[0], operands[1], DFmode, 1)\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = operand_subword (operands[0], 1, 0, DFmode);\n+  operands[3] = operand_subword (operands[0], 0, 0, DFmode);\n+  operands[4] = operand_subword (operands[1], 1, 0, DFmode);\n+  operands[5] = operand_subword (operands[1], 0, 0, DFmode);\n+})\n \n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (match_operand:DF 1 \"memory_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n    && !FP_REG_P (operands[0])\n-   && !FP_REG_P (operands[1])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n-  \"\n {\n   rtx addr = operand_subword (operands[0], 1, 0, DFmode);\n   s390_load_address (addr, XEXP (operands[1], 0));\n   operands[1] = replace_equiv_address (operands[1], addr);\n-}\")\n+})\n+\n+(define_expand \"reload_outdf\"\n+  [(parallel [(match_operand:DF 0 \"memory_operand\" \"\")\n+              (match_operand:DF 1 \"register_operand\" \"d\")\n+              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n+  \"!TARGET_64BIT\"\n+{\n+  s390_load_address (operands[2], XEXP (operands[0], 0));\n+  operands[0] = replace_equiv_address (operands[0], operands[2]);\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n \n ;\n ; movsf instruction pattern(s)."}, {"sha": "930031bf95a0460d9d4cef2c74884b67eb093cd1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc65c307c80fc0817b0452685f3e4b804f1d521e", "patch": "@@ -1,3 +1,7 @@\n+2003-06-27  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* gcc.dg/20030627-1.c: New test.\n+\n 2003-06-26  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/11332"}, {"sha": "4135f71e3c41a5e19f82a92b9e4fcc4fbd31c717", "filename": "gcc/testsuite/gcc.dg/20030627-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Ftestsuite%2Fgcc.dg%2F20030627-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65c307c80fc0817b0452685f3e4b804f1d521e/gcc%2Ftestsuite%2Fgcc.dg%2F20030627-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030627-1.c?ref=dc65c307c80fc0817b0452685f3e4b804f1d521e", "patch": "@@ -0,0 +1,20 @@\n+/* This tests whether non-offsettable memory operands are reloaded \n+   correctly in certain corner cases on s390 targets.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu89\" } */\n+\n+void test_inout (char *bd, int xd, char *bs, int xs)\n+{\n+  *(long long *)(bd + xd + 4093) = *(long long *)(bs + xs + 4093);\n+}\n+\n+void test_in (char *bd, int xd, char *bs, int xs)\n+{\n+  *(long long *)(bd + xd) = *(long long *)(bs + xs + 4093);\n+}\n+\n+void test_out (char *bd, int xd, char *bs, int xs)\n+{\n+  *(long long *)(bd + xd + 4093) = *(long long *)(bs + xs);\n+}\n+"}]}