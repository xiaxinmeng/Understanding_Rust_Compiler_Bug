{"sha": "57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdmY2Q0ZjRlNGYxMmIxZWRlMjRmMDUzODUxODNkM2YyZGM3YWNmYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-03-17T02:37:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-03-17T02:37:09Z"}, "message": "re PR c++/52748 ([C++11] N3276 changes to decltype)\n\n\tN3276\n\tPR c++/52748\n\t* cp-tree.h (tsubst_flags): Add tf_decltype.\n\t* call.c (build_cxx_call): Don't build a temporary if it's set.\n\t(build_over_call): Make sure it's only passed to build_cxx_call.\n\t* parser.c (cp_parser_primary_expression): Add decltype_p parm.\n\t(cp_parser_unary_expression): Likewise.\n\t(cp_parser_cast_expression): Likewise.\n\t(cp_parser_binary_expression): Likewise.\n\t(cp_parser_assignment_expression): Likewise.\n\t(cp_parser_postfix_expression): Likewise.  Pass tf_decltype.\n\t(cp_parser_explicit_instantiation): Add decltype_p.  Force a\n\ttemporary for a call on the LHS of a comma.\n\t(cp_parser_decltype): Pass true to decltype_p parms.\n\t* pt.c (tsubst) [DECLTYPE_TYPE]: Pass tf_decltype.\n\t(tsubst_copy_and_build): Pass tf_decltype down only for\n\tCALL_EXPR and the RHS of COMPOUND_EXPR.\n\t* tree.c (build_cplus_new): Call complete_type_or_maybe_complain.\n\nFrom-SVN: r196736", "tree": {"sha": "c09183570e99438a8ee808eb03a342623d63c77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c09183570e99438a8ee808eb03a342623d63c77f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2df663ccedf750ffe5ac481b3fe2aaff0d985a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df663ccedf750ffe5ac481b3fe2aaff0d985a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df663ccedf750ffe5ac481b3fe2aaff0d985a7f"}], "stats": {"total": 238, "additions": 203, "deletions": 35}, "files": [{"sha": "580208a2ff4967c0ccf866ad57a8f987b6e0821a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "patch": "@@ -1,5 +1,24 @@\n 2013-03-16  Jason Merrill  <jason@redhat.com>\n \n+\tN3276\n+\tPR c++/52748\n+\t* cp-tree.h (tsubst_flags): Add tf_decltype.\n+\t* call.c (build_cxx_call): Don't build a temporary if it's set.\n+\t(build_over_call): Make sure it's only passed to build_cxx_call.\n+\t* parser.c (cp_parser_primary_expression): Add decltype_p parm.\n+\t(cp_parser_unary_expression): Likewise.\n+\t(cp_parser_cast_expression): Likewise.\n+\t(cp_parser_binary_expression): Likewise.\n+\t(cp_parser_assignment_expression): Likewise.\n+\t(cp_parser_postfix_expression): Likewise.  Pass tf_decltype.\n+\t(cp_parser_explicit_instantiation): Add decltype_p.  Force a\n+\ttemporary for a call on the LHS of a comma.\n+\t(cp_parser_decltype): Pass true to decltype_p parms.\n+\t* pt.c (tsubst) [DECLTYPE_TYPE]: Pass tf_decltype.\n+\t(tsubst_copy_and_build): Pass tf_decltype down only for\n+\tCALL_EXPR and the RHS of COMPOUND_EXPR.\n+\t* tree.c (build_cplus_new): Call complete_type_or_maybe_complain.\n+\n \t* cp-tree.h (abstract_class_use): New enum.\n \t* typeck2.c (pending_abstract_type): Add use field.\n \t(abstract_virtuals_error_sfinae): Add overloads taking"}, {"sha": "8362c756c399439e4d3b7b7d2197a90ab0835d85", "filename": "gcc/cp/call.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "patch": "@@ -6693,6 +6693,10 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       /* else continue to get conversion error.  */\n     }\n \n+  /* N3276 magic doesn't apply to nested calls.  */\n+  int decltype_flag = (complain & tf_decltype);\n+  complain &= ~tf_decltype;\n+\n   /* Find maximum size of vector to hold converted arguments.  */\n   parmlen = list_length (parm);\n   nargs = vec_safe_length (args) + (first_arg != NULL_TREE ? 1 : 0);\n@@ -7064,7 +7068,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \treturn error_mark_node;\n     }\n \n-  return build_cxx_call (fn, nargs, argarray, complain);\n+  return build_cxx_call (fn, nargs, argarray, complain|decltype_flag);\n }\n \n /* Build and return a call to FN, using NARGS arguments in ARGARRAY.\n@@ -7106,12 +7110,20 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n   if (VOID_TYPE_P (TREE_TYPE (fn)))\n     return fn;\n \n-  fn = require_complete_type_sfinae (fn, complain);\n-  if (fn == error_mark_node)\n-    return error_mark_node;\n+  /* 5.2.2/11: If a function call is a prvalue of object type: if the\n+     function call is either the operand of a decltype-specifier or the\n+     right operand of a comma operator that is the operand of a\n+     decltype-specifier, a temporary object is not introduced for the\n+     prvalue. The type of the prvalue may be incomplete.  */\n+  if (!(complain & tf_decltype))\n+    {\n+      fn = require_complete_type_sfinae (fn, complain);\n+      if (fn == error_mark_node)\n+\treturn error_mark_node;\n \n-  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (fn)))\n-    fn = build_cplus_new (TREE_TYPE (fn), fn, complain);\n+      if (MAYBE_CLASS_TYPE_P (TREE_TYPE (fn)))\n+\tfn = build_cplus_new (TREE_TYPE (fn), fn, complain);\n+    }\n   return convert_from_reference (fn);\n }\n "}, {"sha": "39fb3dfeba4c2c7662db4cbd49d25497cf2f406f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "patch": "@@ -4203,6 +4203,9 @@ enum tsubst_flags {\n \t\t\t\t    conversion might be permissible,\n \t\t\t\t    not actually performing the\n \t\t\t\t    conversion.  */\n+  tf_decltype = 1 << 7,          /* We are the operand of decltype.\n+\t\t\t\t    Used to implement the special rules\n+\t\t\t\t    for calls in decltype (5.2.2/11).  */\n   tf_partial = 1 << 8,\t\t /* Doing initial explicit argument\n \t\t\t\t    substitution in fn_type_unification.  */\n   /* Convenient substitution flags combinations.  */"}, {"sha": "3f56ff1f75e3162602dd5ab405da8e3a183a111d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "patch": "@@ -1802,7 +1802,7 @@ static tree cp_parser_nested_name_specifier\n static tree cp_parser_qualifying_entity\n   (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_postfix_expression\n-  (cp_parser *, bool, bool, bool, cp_id_kind *);\n+  (cp_parser *, bool, bool, bool, bool, cp_id_kind *);\n static tree cp_parser_postfix_open_square_expression\n   (cp_parser *, tree, bool);\n static tree cp_parser_postfix_dot_deref_expression\n@@ -1832,7 +1832,7 @@ static vec<tree, va_gc> *cp_parser_new_initializer\n static tree cp_parser_delete_expression\n   (cp_parser *);\n static tree cp_parser_cast_expression\n-  (cp_parser *, bool, bool, cp_id_kind *);\n+  (cp_parser *, bool, bool, bool, cp_id_kind *);\n static tree cp_parser_binary_expression\n   (cp_parser *, bool, bool, enum cp_parser_prec, cp_id_kind *);\n static tree cp_parser_question_colon_clause\n@@ -1843,6 +1843,8 @@ static enum tree_code cp_parser_assignment_operator_opt\n   (cp_parser *);\n static tree cp_parser_expression\n   (cp_parser *, bool, cp_id_kind *);\n+static tree cp_parser_expression\n+  (cp_parser *, bool, bool, cp_id_kind *);\n static tree cp_parser_constant_expression\n   (cp_parser *, bool, bool *);\n static tree cp_parser_builtin_offsetof\n@@ -3900,6 +3902,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t\t      bool address_p,\n \t\t\t      bool cast_p,\n \t\t\t      bool template_arg_p,\n+\t\t\t      bool decltype_p,\n \t\t\t      cp_id_kind *idk)\n {\n   cp_token *token = NULL;\n@@ -4051,7 +4054,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \telse\n \t  {\n \t    /* Parse the parenthesized expression.  */\n-\t    expr = cp_parser_expression (parser, cast_p, idk);\n+\t    expr = cp_parser_expression (parser, cast_p, decltype_p, idk);\n \t    /* Let the front end know that this expression was\n \t       enclosed in parentheses. This matters in case, for\n \t       example, the expression is of the form `A::B', since\n@@ -4403,6 +4406,17 @@ cp_parser_primary_expression (cp_parser *parser,\n     }\n }\n \n+static inline tree\n+cp_parser_primary_expression (cp_parser *parser,\n+\t\t\t      bool address_p,\n+\t\t\t      bool cast_p,\n+\t\t\t      bool template_arg_p,\n+\t\t\t      cp_id_kind *idk)\n+{\n+  return cp_parser_primary_expression (parser, address_p, cast_p, template_arg_p,\n+\t\t\t\t       /*decltype*/false, idk);\n+}\n+\n /* Parse an id-expression.\n \n    id-expression:\n@@ -5364,7 +5378,7 @@ cp_parser_qualifying_entity (cp_parser *parser,\n \n static tree\n cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n-                              bool member_access_only_p,\n+                              bool member_access_only_p, bool decltype_p,\n \t\t\t      cp_id_kind * pidk_return)\n {\n   cp_token *token;\n@@ -5625,11 +5639,17 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tpostfix_expression\n \t  = cp_parser_primary_expression (parser, address_p, cast_p,\n \t\t\t\t\t  /*template_arg_p=*/false,\n+\t\t\t\t\t  decltype_p,\n \t\t\t\t\t  &idk);\n       }\n       break;\n     }\n \n+  /* Note that we don't need to worry about calling build_cplus_new on a\n+     class-valued CALL_EXPR in decltype when it isn't the end of the\n+     postfix-expression; unary_complex_lvalue will take care of that for\n+     all these cases.  */\n+\n   /* Keep looping until the postfix-expression is complete.  */\n   while (true)\n     {\n@@ -5668,8 +5688,12 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    bool is_builtin_constant_p;\n \t    bool saved_integral_constant_expression_p = false;\n \t    bool saved_non_integral_constant_expression_p = false;\n+\t    int complain = tf_warning_or_error;\n \t    vec<tree, va_gc> *args;\n \n+\t    if (decltype_p)\n+\t      complain |= tf_decltype;\n+\n             is_member_access = false;\n \n \t    is_builtin_constant_p\n@@ -5726,7 +5750,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t  postfix_expression\n \t\t\t    = perform_koenig_lookup (postfix_expression, args,\n \t\t\t\t\t\t     /*include_std=*/false,\n-\t\t\t\t\t\t     tf_warning_or_error);\n+\t\t\t\t\t\t     complain);\n \t\t      }\n \t\t    else\n \t\t      postfix_expression\n@@ -5752,7 +5776,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t  postfix_expression\n \t\t\t    = perform_koenig_lookup (postfix_expression, args,\n \t\t\t\t\t\t     /*include_std=*/false,\n-\t\t\t\t\t\t     tf_warning_or_error);\n+\t\t\t\t\t\t     complain);\n \t\t      }\n \t\t  }\n \t      }\n@@ -5784,36 +5808,36 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t ? LOOKUP_NORMAL|LOOKUP_NONVIRTUAL\n \t\t\t : LOOKUP_NORMAL),\n \t\t\t/*fn_p=*/NULL,\n-\t\t\ttf_warning_or_error));\n+\t\t\tcomplain));\n \t\t  }\n \t\telse\n \t\t  postfix_expression\n \t\t    = finish_call_expr (postfix_expression, &args,\n \t\t\t\t\t/*disallow_virtual=*/false,\n \t\t\t\t\t/*koenig_p=*/false,\n-\t\t\t\t\ttf_warning_or_error);\n+\t\t\t\t\tcomplain);\n \t      }\n \t    else if (TREE_CODE (postfix_expression) == OFFSET_REF\n \t\t     || TREE_CODE (postfix_expression) == MEMBER_REF\n \t\t     || TREE_CODE (postfix_expression) == DOTSTAR_EXPR)\n \t      postfix_expression = (build_offset_ref_call_from_tree\n \t\t\t\t    (postfix_expression, &args,\n-\t\t\t\t     tf_warning_or_error));\n+\t\t\t\t     complain));\n \t    else if (idk == CP_ID_KIND_QUALIFIED)\n \t      /* A call to a static class member, or a namespace-scope\n \t\t function.  */\n \t      postfix_expression\n \t\t= finish_call_expr (postfix_expression, &args,\n \t\t\t\t    /*disallow_virtual=*/true,\n \t\t\t\t    koenig_p,\n-\t\t\t\t    tf_warning_or_error);\n+\t\t\t\t    complain);\n \t    else\n \t      /* All other function calls.  */\n \t      postfix_expression\n \t\t= finish_call_expr (postfix_expression, &args,\n \t\t\t\t    /*disallow_virtual=*/false,\n \t\t\t\t    koenig_p,\n-\t\t\t\t    tf_warning_or_error);\n+\t\t\t\t    complain);\n \n \t    /* The POSTFIX_EXPRESSION is certainly no longer an id.  */\n \t    idk = CP_ID_KIND_NONE;\n@@ -6414,7 +6438,7 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n \n static tree\n cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n-\t\t\t    cp_id_kind * pidk)\n+\t\t\t    bool decltype_p, cp_id_kind * pidk)\n {\n   cp_token *token;\n   enum tree_code unary_operator;\n@@ -6635,7 +6659,9 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n       cast_expression\n \t= cp_parser_cast_expression (parser,\n \t\t\t\t     unary_operator == ADDR_EXPR,\n-\t\t\t\t     /*cast_p=*/false, pidk);\n+\t\t\t\t     /*cast_p=*/false,\n+\t\t\t\t     /*decltype*/false,\n+\t\t\t\t     pidk);\n       /* Now, build an appropriate representation.  */\n       switch (unary_operator)\n \t{\n@@ -6681,9 +6707,18 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n   return cp_parser_postfix_expression (parser, address_p, cast_p,\n                                        /*member_access_only_p=*/false,\n+\t\t\t\t       decltype_p,\n \t\t\t\t       pidk);\n }\n \n+static inline tree\n+cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n+\t\t\t    cp_id_kind * pidk)\n+{\n+  return cp_parser_unary_expression (parser, address_p, cast_p,\n+\t\t\t\t     /*decltype*/false, pidk);\n+}\n+\n /* Returns ERROR_MARK if TOKEN is not a unary-operator.  If TOKEN is a\n    unary-operator, the corresponding tree code is returned.  */\n \n@@ -7162,7 +7197,7 @@ cp_parser_tokens_start_cast_expression (cp_parser *parser)\n \n static tree\n cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n-\t\t\t   cp_id_kind * pidk)\n+\t\t\t   bool decltype_p, cp_id_kind * pidk)\n {\n   /* If it's a `(', then we might be looking at a cast.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n@@ -7236,7 +7271,9 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  cp_parser_parse_definitely (parser);\n \t  expr = cp_parser_cast_expression (parser,\n \t\t\t\t\t    /*address_p=*/false,\n-\t\t\t\t\t    /*cast_p=*/true, pidk);\n+\t\t\t\t\t    /*cast_p=*/true,\n+\t\t\t\t\t    /*decltype_p=*/false,\n+\t\t\t\t\t    pidk);\n \n \t  /* Warn about old-style casts, if so requested.  */\n \t  if (warn_old_style_cast\n@@ -7262,7 +7299,8 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n   /* If we get here, then it's not a cast, so it must be a\n      unary-expression.  */\n-  return cp_parser_unary_expression (parser, address_p, cast_p, pidk);\n+  return cp_parser_unary_expression (parser, address_p, cast_p,\n+\t\t\t\t     decltype_p, pidk);\n }\n \n /* Parse a binary expression of the general form:\n@@ -7347,6 +7385,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n static tree\n cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t\t\t     bool no_toplevel_fold_p,\n+\t\t\t     bool decltype_p,\n \t\t\t     enum cp_parser_prec prec,\n \t\t\t     cp_id_kind * pidk)\n {\n@@ -7361,7 +7400,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \n   /* Parse the first expression.  */\n   current.lhs = cp_parser_cast_expression (parser, /*address_p=*/false,\n-\t\t\t\t\t   cast_p, pidk);\n+\t\t\t\t\t   cast_p, decltype_p, pidk);\n   current.lhs_type = ERROR_MARK;\n   current.prec = prec;\n \n@@ -7498,6 +7537,15 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n   return current.lhs;\n }\n \n+static tree\n+cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n+\t\t\t     bool no_toplevel_fold_p,\n+\t\t\t     enum cp_parser_prec prec,\n+\t\t\t     cp_id_kind * pidk)\n+{\n+  return cp_parser_binary_expression (parser, cast_p, no_toplevel_fold_p,\n+\t\t\t\t      /*decltype*/false, prec, pidk);\n+}\n \n /* Parse the `? expression : assignment-expression' part of a\n    conditional-expression.  The LOGICAL_OR_EXPR is the\n@@ -7567,12 +7615,13 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n      throw-expression\n \n    CAST_P is true if this expression is the target of a cast.\n+   DECLTYPE_P is true if this expression is the operand of decltype.\n \n    Returns a representation for the expression.  */\n \n static tree\n cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n-\t\t\t\t cp_id_kind * pidk)\n+\t\t\t\t bool decltype_p, cp_id_kind * pidk)\n {\n   tree expr;\n \n@@ -7586,6 +7635,7 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n     {\n       /* Parse the binary expressions (logical-or-expression).  */\n       expr = cp_parser_binary_expression (parser, cast_p, false,\n+\t\t\t\t\t  decltype_p,\n \t\t\t\t\t  PREC_NOT_OPERATOR, pidk);\n       /* If the next token is a `?' then we're actually looking at a\n \t conditional-expression.  */\n@@ -7631,6 +7681,14 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n   return expr;\n }\n \n+static tree\n+cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n+\t\t\t\t cp_id_kind * pidk)\n+{\n+  return cp_parser_assignment_expression (parser, cast_p,\n+\t\t\t\t\t  /*decltype*/false, pidk);\n+}\n+\n /* Parse an (optional) assignment-operator.\n \n    assignment-operator: one of\n@@ -7722,11 +7780,14 @@ cp_parser_assignment_operator_opt (cp_parser* parser)\n      expression , assignment-expression\n \n    CAST_P is true if this expression is the target of a cast.\n+   DECLTYPE_P is true if this expression is the immediate operand of decltype,\n+     except possibly parenthesized or on the RHS of a comma (N3276).\n \n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_expression (cp_parser* parser, bool cast_p, cp_id_kind * pidk)\n+cp_parser_expression (cp_parser* parser, bool cast_p, bool decltype_p,\n+\t\t      cp_id_kind * pidk)\n {\n   tree expression = NULL_TREE;\n   location_t loc = UNKNOWN_LOCATION;\n@@ -7737,7 +7798,19 @@ cp_parser_expression (cp_parser* parser, bool cast_p, cp_id_kind * pidk)\n \n       /* Parse the next assignment-expression.  */\n       assignment_expression\n-\t= cp_parser_assignment_expression (parser, cast_p, pidk);\n+\t= cp_parser_assignment_expression (parser, cast_p, decltype_p, pidk);\n+\n+      /* We don't create a temporary for a call that is the immediate operand\n+\t of decltype or on the RHS of a comma.  But when we see a comma, we\n+\t need to create a temporary for a call on the LHS.  */\n+      if (decltype_p && !processing_template_decl\n+\t  && TREE_CODE (assignment_expression) == CALL_EXPR\n+\t  && CLASS_TYPE_P (TREE_TYPE (assignment_expression))\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tassignment_expression\n+\t  = build_cplus_new (TREE_TYPE (assignment_expression),\n+\t\t\t     assignment_expression, tf_warning_or_error);\n+\n       /* If this is the first assignment-expression, we can just\n \t save it away.  */\n       if (!expression)\n@@ -7761,6 +7834,12 @@ cp_parser_expression (cp_parser* parser, bool cast_p, cp_id_kind * pidk)\n   return expression;\n }\n \n+static inline tree\n+cp_parser_expression (cp_parser* parser, bool cast_p, cp_id_kind * pidk)\n+{\n+  return cp_parser_expression (parser, cast_p, /*decltype*/false, pidk);\n+}\n+\n /* Parse a constant-expression.\n \n    constant-expression:\n@@ -11287,7 +11366,7 @@ cp_parser_decltype (cp_parser *parser)\n \n       /* Parse a class member access.  */\n       expr = cp_parser_postfix_expression (parser, /*address_p=*/false,\n-                                           /*cast_p=*/false,\n+                                           /*cast_p=*/false, /*decltype*/true,\n                                            /*member_access_only_p=*/true, NULL);\n \n       if (expr \n@@ -11315,7 +11394,8 @@ cp_parser_decltype (cp_parser *parser)\n       parser->greater_than_is_operator_p = true;\n \n       /* Parse a full expression.  */\n-      expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      expr = cp_parser_expression (parser, /*cast_p=*/false,\n+\t\t\t\t   /*decltype*/true, NULL);\n \n       /* The `>' token might be the end of a template-id or\n \t template-parameter-list now.  */\n@@ -22034,7 +22114,7 @@ static tree\n cp_parser_simple_cast_expression (cp_parser *parser)\n {\n   return cp_parser_cast_expression (parser, /*address_p=*/false,\n-\t\t\t\t    /*cast_p=*/false, NULL);\n+\t\t\t\t    /*cast_p=*/false, /*decltype*/false, NULL);\n }\n \n /* Parse a functional cast to TYPE.  Returns an expression\n@@ -26831,7 +26911,7 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n       op = (token->type == CPP_PLUS_PLUS\n \t    ? PREINCREMENT_EXPR : PREDECREMENT_EXPR);\n       cp_lexer_consume_token (parser->lexer);\n-      lhs = cp_parser_cast_expression (parser, false, false, NULL);\n+      lhs = cp_parser_simple_cast_expression (parser);\n       if (lhs != decl)\n \treturn error_mark_node;\n       return build2 (op, TREE_TYPE (decl), decl, NULL_TREE);"}, {"sha": "4ffc353ed0e8e652993748b513d828a2b7f2bb0a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "patch": "@@ -11781,7 +11781,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t++c_inhibit_evaluation_warnings;\n \n \ttype = tsubst_expr (DECLTYPE_TYPE_EXPR (t), args,\n-\t\t\t    complain, in_decl,\n+\t\t\t    complain|tf_decltype, in_decl,\n \t\t\t    /*integral_constant_expression_p=*/false);\n \n \t--cp_unevaluated_operand;\n@@ -13417,6 +13417,12 @@ tsubst_copy_and_build (tree t,\n   if (EXPR_HAS_LOCATION (t))\n     input_location = EXPR_LOCATION (t);\n \n+  /* N3276 decltype magic only applies to calls at the top level or on the\n+     right side of a comma.  */\n+  if (TREE_CODE (t) != CALL_EXPR\n+      && TREE_CODE (t) != COMPOUND_EXPR)\n+    complain &= ~tf_decltype;\n+\n   switch (TREE_CODE (t))\n     {\n     case USING_DECL:\n@@ -13848,10 +13854,16 @@ tsubst_copy_and_build (tree t,\n \tcomplain));\n \n     case COMPOUND_EXPR:\n-      RETURN (build_x_compound_expr (EXPR_LOCATION (t),\n-\t\t\t\t    RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t\t    RECUR (TREE_OPERAND (t, 1)),\n-                                    complain));\n+      {\n+\ttree op0 = tsubst_copy_and_build (TREE_OPERAND (t, 0), args,\n+\t\t\t\t\t  complain & ~tf_decltype, in_decl,\n+\t\t\t\t\t  /*function_p=*/false,\n+\t\t\t\t\t  integral_constant_expression_p);\n+\tRETURN (build_x_compound_expr (EXPR_LOCATION (t),\n+\t\t\t\t       op0,\n+\t\t\t\t       RECUR (TREE_OPERAND (t, 1)),\n+\t\t\t\t       complain));\n+      }\n \n     case CALL_EXPR:\n       {\n@@ -13862,6 +13874,10 @@ tsubst_copy_and_build (tree t,\n \tbool koenig_p;\n \ttree ret;\n \n+\t/* Don't pass tf_decltype down to subexpressions.  */\n+\ttsubst_flags_t decltype_flag = (complain & tf_decltype);\n+\tcomplain &= ~tf_decltype;\n+\n \tfunction = CALL_EXPR_FN (t);\n \t/* When we parsed the expression,  we determined whether or\n \t   not Koenig lookup should be performed.  */\n@@ -14028,6 +14044,9 @@ tsubst_copy_and_build (tree t,\n \tif (DECL_P (function))\n \t  mark_used (function);\n \n+\t/* Put back tf_decltype for the actual call.  */\n+\tcomplain |= decltype_flag;\n+\n \tif (TREE_CODE (function) == OFFSET_REF)\n \t  ret = build_offset_ref_call_from_tree (function, &call_args,\n \t\t\t\t\t\t complain);"}, {"sha": "6dc33b9493fc6dd6a4cd16459a71b3965477aac2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "patch": "@@ -469,6 +469,9 @@ build_cplus_new (tree type, tree init, tsubst_flags_t complain)\n   tree rval = build_aggr_init_expr (type, init);\n   tree slot;\n \n+  if (!complete_type_or_maybe_complain (type, init, complain))\n+    return error_mark_node;\n+\n   /* Make sure that we're not trying to create an instance of an\n      abstract class.  */\n   if (abstract_virtuals_error_sfinae (NULL_TREE, type, complain))"}, {"sha": "2616bb09046d6fdf70d1eed3b2dd21b37be108ff", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype-call1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-call1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-call1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-call1.C?ref=57fcd4f4e4f12b1ede24f05385183d3f2dc7acfa", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/52748\n+// N3276\n+// { dg-do compile { target c++11 } }\n+\n+struct A;\t\t\t// { dg-error \"forward declaration\" }\n+A f();\n+\n+decltype(f()) g1();\t\t // OK\n+decltype(((f()))) g2b();\t // OK\n+decltype(42,f()) g3();\t\t // OK\n+decltype(42,45,f()) g3b();\t // OK\n+decltype(42,45,(f())) g3c();\t // OK\n+decltype(42,((45,(f())))) g3c(); // OK\n+\n+decltype(f(),42) g4();\t\t // { dg-error \"\" }\n+decltype(45,f(),42) g4b();\t // { dg-error \"\" }\n+\n+class B\n+{\n+  ~B();\t\t\t\t// { dg-error \"private\" }\n+public:\n+  int i;\n+  void operator[](int);\n+};\n+B h();\n+\n+void i(const B&);\n+\n+decltype(h()) g5a();\t\t// OK\n+decltype(h().i) g5();\t\t// { dg-error \"\" }\n+decltype(h()[0]) g6();\t\t// { dg-error \"\" }\n+decltype(i(h())) g7();\t\t// { dg-error \"\" }"}]}