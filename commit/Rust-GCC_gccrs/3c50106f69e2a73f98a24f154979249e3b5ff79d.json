{"sha": "3c50106f69e2a73f98a24f154979249e3b5ff79d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M1MDEwNmY2OWUyYTczZjk4YTI0ZjE1NDk3OTI0OWUzYjVmZjc5ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-01-28T04:46:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-01-28T04:46:33Z"}, "message": "Makefile.in (cse.o): Depend on TARGET_H.\n\n\t* Makefile.in (cse.o): Depend on TARGET_H.\n\t* cse.c (rtx_cost): Use targetm.rtx_costs.\n\t* system.h (CONST_COSTS RTX_COSTS DEFAULT_RTX_COSTS): Poison.\n\t* doc/tm.texi: Update.\n\n\t* target.h (targetm.rtx_costs): New.\n\t* target-def.h (TARGET_RTX_COSTS): New.\n\t* hooks.c (hook_bool_rtx_int_int_intp_false): New.\n\t* hooks.h: Update.\n\n\t* config/alpha/alpha.c (alpha_rtx_cost_data): New.\n\t(alpha_rtx_costs, TARGET_RTX_COSTS): New.\n\t* config/alpha/alpha.h (PROCESSOR_MAX): New.\n\t(CONST_COSTS, RTX_COSTS): Remove.\n\n\t* config/arc/arc.c, config/arc/arc.h, config/c4x/c4x.c,\n\tconfig/c4x/c4x.h, config/cris/cris.c, config/cris/cris.h,\n\tconfig/d30v/d30v.c, config/d30v/d30v.h, config/dsp16xx/dsp16xx.c,\n\tconfig/dsp16xx/dsp16xx.h, config/frv/frv.c, config/frv/frv.h,\n\tconfig/h8300/h8300.c, config/h8300/h8300.h, config/i370/i370.c,\n\tconfig/i370/i370.h, config/i386/i386.c, config/i386/i386.h,\n\tconfig/i960/i960.c, config/i960/i960.h, config/ia64/ia64.c,\n\tconfig/ia64/ia64.h, config/m32r/m32r.c, config/m32r/m32r.h,\n\tconfig/m68k/m68k.c, config/m68k/m68k.h, config/m88k/m88k.c,\n\tconfig/m88k/m88k.h, config/mcore/mcore.c, config/mcore/mcore.h,\n\tconfig/mips/mips.c, config/mips/mips.h, config/mn10200/mn10200.c,\n\tconfig/mn10200/mn10200.h, config/mn10300/mn10300.c,\n\tconfig/mn10300/mn10300.h, config/ns32k/ns32k.c, config/ns32k/ns32k.h,\n\tconfig/pa/pa.c, config/pa/pa.h, config/pdp11/pdp11.c,\n\tconfig/pdp11/pdp11.h, config/romp/romp.c, config/romp/romp.h,\n\tconfig/rs6000/rs6000.c, config/rs6000/rs6000.h, config/s390/s390.c,\n\tconfig/s390/s390.h, config/sh/sh.c, config/sh/sh.h,\n\tconfig/stormy16/stormy16.c, config/stormy16/stormy16.h,\n\tconfig/v850/v850.c, config/v850/v850.h,\n\tconfig/xtensa/xtensa.c, config/xtensa/xtensa.h\n\t(CONST_COSTS, RTX_COSTS): Move code ...\n\t(foo_rtx_costs, TARGET_RTX_COSTS): ... here.\n\n\t* config/arm/arm.c (arm_rtx_costs_1): Rename from arm_rtx_costs.\n\t(arm_rtx_costs, TARGET_RTX_COSTS): New.\n\t* config/arm/arm-protos.h: Update.\n\t* config/arm/arm.h (DEFAULT_RTX_COSTS): Remove.\n\n\t* config/avr/avr.h (CONST_COSTS): Move code ...\n\t* config/avr/avr.c (avr_rtx_costs): ... here.\n\t(default_rtx_costs): Make static.\n\t* config/avr/avr-protos.h: Update.\n\n\t* config/h8300/h8300.c (const_costs): Make static.\n\t(h8300_and_costs, h8300_shift_costs): Likewise.\n\t* config/h8300/h8300-protos.h: Update.\n\n\t* config/ip2k/ip2k.h (DEFAULT_RTX_COSTS): Remove.\n\t(CONST_COSTS): Move code ...\n\t* config/ip2k/ip2k.c (ip2k_rtx_costs): ... here.  Rename from\n\tdefault_rtx_costs; update for signature change.\n\t* config/ip2k/ip2k-protos.h: Update.\n\n\t* config/m68hc11/m68hc11.h (RTX_COSTS): Remove.\n\t(CONST_COSTS): Move code ...\n\t* config/m68hc11/m68hc11.c (m68hc11_rtx_costs): ... here.\n\t(TARGET_RTX_COSTS): New.\n\t(m68hc11_rtx_costs_1): Rename from m68hc11_rtx_costs; make static.\n\t* config/m68hc11/m68hc11-protos.h: Update.\n\n\t* config/m68k/m68k.c (const_int_cost): Make static.\n\t* config/m68k/m68k-protos.h: Update.\n\n\t* config/mcore/mcore.c (mcore_const_costs): Make static.\n\t(mcore_and_cost, mcore_ior_cost): Likewise.\n\t* config/mcore/mcore-protos.h: Update.\n\n\t* config/mmix/mmix.c (mmix_rtx_costs, TARGET_RTX_COSTS): New.\n\t(mmix_rtx_cost_recalculated): Remove.\n\t* config/mmix/mmix.h (DEFAULT_RTX_COSTS): Remove.\n\t* config/mmix/mmix-protos.h: Update.\n\n\t* config/sh/sh.c (shiftcosts): Make static.\n\t(addsubcosts, andcosts, multcosts): Likewise.\n\t* config/sh/sh-protos.h: Update.\n\n\t* config/sparc/sparc.c (TARGET_RTX_COSTS): New.\n\t(sparc_rtx_costs): Make static; update for change in signature.\n\t* config/sparc/sparc.h (RTX_COSTS_CASES, RTX_COSTS): Remove.\n\t* config/sparc/sparc-protos.h: Update.\n\n\t* config/v850/v850.c (const_costs): Make static.\n\t* config/v850/v850-protos.h: Update.\n\n\t* config/vax/vax.h (RTX_COSTS): Remove.\n\t(CONST_COSTS): Move code ...\n\t* config/vax/vax.c (vax_rtx_costs_1): ... here; rename\n\tfrom vax_rtx_cost.\n\t(vax_rtx_costs, TARGET_RTX_COSTS): New.\n\nFrom-SVN: r61954", "tree": {"sha": "1eaff917ba37b6f409082db1a76c42c218320c5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eaff917ba37b6f409082db1a76c42c218320c5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c50106f69e2a73f98a24f154979249e3b5ff79d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c50106f69e2a73f98a24f154979249e3b5ff79d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c50106f69e2a73f98a24f154979249e3b5ff79d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c50106f69e2a73f98a24f154979249e3b5ff79d/comments", "author": null, "committer": null, "parents": [{"sha": "5ca9898002fc6c777cd25caa42e58ece40fe9978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca9898002fc6c777cd25caa42e58ece40fe9978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca9898002fc6c777cd25caa42e58ece40fe9978"}], "stats": {"total": 6144, "additions": 3449, "deletions": 2695}, "files": [{"sha": "5bb0bad637bdcbdff5adacef751f05b8801a680f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1,3 +1,100 @@\n+2003-01-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.in (cse.o): Depend on TARGET_H.\n+\t* cse.c (rtx_cost): Use targetm.rtx_costs.\n+\t* system.h (CONST_COSTS RTX_COSTS DEFAULT_RTX_COSTS): Poison.\n+\t* doc/tm.texi: Update.\n+\t\n+\t* target.h (targetm.rtx_costs): New.\n+\t* target-def.h (TARGET_RTX_COSTS): New.\n+\t* hooks.c (hook_bool_rtx_int_int_intp_false): New.\n+\t* hooks.h: Update.\n+\n+\t* config/alpha/alpha.c (alpha_rtx_cost_data): New.\n+\t(alpha_rtx_costs, TARGET_RTX_COSTS): New.\n+\t* config/alpha/alpha.h (PROCESSOR_MAX): New.\n+\t(CONST_COSTS, RTX_COSTS): Remove.\n+\n+\t* config/arc/arc.c, config/arc/arc.h, config/c4x/c4x.c,\n+\tconfig/c4x/c4x.h, config/cris/cris.c, config/cris/cris.h,\n+\tconfig/d30v/d30v.c, config/d30v/d30v.h, config/dsp16xx/dsp16xx.c,\n+\tconfig/dsp16xx/dsp16xx.h, config/frv/frv.c, config/frv/frv.h,\n+\tconfig/h8300/h8300.c, config/h8300/h8300.h, config/i370/i370.c,\n+\tconfig/i370/i370.h, config/i386/i386.c, config/i386/i386.h,\n+\tconfig/i960/i960.c, config/i960/i960.h, config/ia64/ia64.c,\n+\tconfig/ia64/ia64.h, config/m32r/m32r.c, config/m32r/m32r.h,\n+\tconfig/m68k/m68k.c, config/m68k/m68k.h, config/m88k/m88k.c,\n+\tconfig/m88k/m88k.h, config/mcore/mcore.c, config/mcore/mcore.h,\n+\tconfig/mips/mips.c, config/mips/mips.h, config/mn10200/mn10200.c,\n+\tconfig/mn10200/mn10200.h, config/mn10300/mn10300.c,\n+\tconfig/mn10300/mn10300.h, config/ns32k/ns32k.c, config/ns32k/ns32k.h,\n+\tconfig/pa/pa.c, config/pa/pa.h, config/pdp11/pdp11.c,\n+\tconfig/pdp11/pdp11.h, config/romp/romp.c, config/romp/romp.h,\n+\tconfig/rs6000/rs6000.c, config/rs6000/rs6000.h, config/s390/s390.c,\n+\tconfig/s390/s390.h, config/sh/sh.c, config/sh/sh.h,\n+\tconfig/stormy16/stormy16.c, config/stormy16/stormy16.h,\n+\tconfig/v850/v850.c, config/v850/v850.h,\n+\tconfig/xtensa/xtensa.c, config/xtensa/xtensa.h\n+\t(CONST_COSTS, RTX_COSTS): Move code ...\n+\t(foo_rtx_costs, TARGET_RTX_COSTS): ... here.\n+\n+\t* config/arm/arm.c (arm_rtx_costs_1): Rename from arm_rtx_costs.\n+\t(arm_rtx_costs, TARGET_RTX_COSTS): New.\n+\t* config/arm/arm-protos.h: Update.\n+\t* config/arm/arm.h (DEFAULT_RTX_COSTS): Remove.\n+\n+\t* config/avr/avr.h (CONST_COSTS): Move code ...\n+\t* config/avr/avr.c (avr_rtx_costs): ... here.\n+\t(default_rtx_costs): Make static.\n+\t* config/avr/avr-protos.h: Update.\n+\n+\t* config/h8300/h8300.c (const_costs): Make static.\n+\t(h8300_and_costs, h8300_shift_costs): Likewise.\n+\t* config/h8300/h8300-protos.h: Update.\n+\n+\t* config/ip2k/ip2k.h (DEFAULT_RTX_COSTS): Remove.\n+\t(CONST_COSTS): Move code ...\n+\t* config/ip2k/ip2k.c (ip2k_rtx_costs): ... here.  Rename from\n+\tdefault_rtx_costs; update for signature change.\n+\t* config/ip2k/ip2k-protos.h: Update.\n+\n+\t* config/m68hc11/m68hc11.h (RTX_COSTS): Remove.\n+\t(CONST_COSTS): Move code ...\n+\t* config/m68hc11/m68hc11.c (m68hc11_rtx_costs): ... here.\n+\t(TARGET_RTX_COSTS): New.\n+\t(m68hc11_rtx_costs_1): Rename from m68hc11_rtx_costs; make static.\n+\t* config/m68hc11/m68hc11-protos.h: Update.\n+\n+\t* config/m68k/m68k.c (const_int_cost): Make static.\n+\t* config/m68k/m68k-protos.h: Update.\n+\n+\t* config/mcore/mcore.c (mcore_const_costs): Make static.\n+\t(mcore_and_cost, mcore_ior_cost): Likewise.\n+\t* config/mcore/mcore-protos.h: Update.\n+\n+\t* config/mmix/mmix.c (mmix_rtx_costs, TARGET_RTX_COSTS): New.\n+\t(mmix_rtx_cost_recalculated): Remove.\n+\t* config/mmix/mmix.h (DEFAULT_RTX_COSTS): Remove.\n+\t* config/mmix/mmix-protos.h: Update.\n+\n+\t* config/sh/sh.c (shiftcosts): Make static.\n+\t(addsubcosts, andcosts, multcosts): Likewise.\n+\t* config/sh/sh-protos.h: Update.\n+\n+\t* config/sparc/sparc.c (TARGET_RTX_COSTS): New.\n+\t(sparc_rtx_costs): Make static; update for change in signature.\n+\t* config/sparc/sparc.h (RTX_COSTS_CASES, RTX_COSTS): Remove.\n+\t* config/sparc/sparc-protos.h: Update.\n+\n+\t* config/v850/v850.c (const_costs): Make static.\n+\t* config/v850/v850-protos.h: Update.\n+\n+\t* config/vax/vax.h (RTX_COSTS): Remove.\n+\t(CONST_COSTS): Move code ...\n+\t* config/vax/vax.c (vax_rtx_costs_1): ... here; rename\n+\tfrom vax_rtx_cost.\n+\t(vax_rtx_costs, TARGET_RTX_COSTS): New.\n+\n 2003-01-27  Richard Henderson  <rth@redhat.com>\n \n \t* config/vax/vax.h (ASM_OUTPUT_MI_THUNK): Remove.  Really."}, {"sha": "d75db8f72ed343da72d13425866ac36e25d507e4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1543,8 +1543,9 @@ cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h\n cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n-   hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h \\\n-   function.h $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) except.h\n+   hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n+   output.h function.h $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \\\n+   except.h $(TARGET_H)\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h ggc.h $(RECOG_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) function.h output.h toplev.h $(TM_P_H) $(PARAMS_H) except.h gt-gcse.h"}, {"sha": "d10396e6c0a4b2bae88b669f0705302b87cbcb56", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -123,6 +123,54 @@ extern GTY(()) int alpha_this_gpdisp_sequence_number;\n int alpha_this_literal_sequence_number;\n int alpha_this_gpdisp_sequence_number;\n \n+/* Costs of various operations on the different architectures.  */\n+\n+struct alpha_rtx_cost_data\n+{\n+  unsigned char fp_add;\n+  unsigned char fp_mult;\n+  unsigned char fp_div_sf;\n+  unsigned char fp_div_df;\n+  unsigned char int_mult_si;\n+  unsigned char int_mult_di;\n+  unsigned char int_shift;\n+  unsigned char int_cmov;\n+};\n+\n+static struct alpha_rtx_cost_data const alpha_rtx_cost_data[PROCESSOR_MAX] =\n+{\n+  { /* EV4 */\n+    COSTS_N_INSNS (6),\t\t/* fp_add */\n+    COSTS_N_INSNS (6),\t\t/* fp_mult */\n+    COSTS_N_INSNS (34),\t\t/* fp_div_sf */\n+    COSTS_N_INSNS (63),\t\t/* fp_div_df */\n+    COSTS_N_INSNS (23),\t\t/* int_mult_si */\n+    COSTS_N_INSNS (23),\t\t/* int_mult_di */\n+    COSTS_N_INSNS (2),\t\t/* int_shift */\n+    COSTS_N_INSNS (2),\t\t/* int_cmov */\n+  },\n+  { /* EV5 */\n+    COSTS_N_INSNS (4),\t\t/* fp_add */\n+    COSTS_N_INSNS (4),\t\t/* fp_mult */\n+    COSTS_N_INSNS (15),\t\t/* fp_div_sf */\n+    COSTS_N_INSNS (22),\t\t/* fp_div_df */\n+    COSTS_N_INSNS (8),\t\t/* int_mult_si */\n+    COSTS_N_INSNS (12),\t\t/* int_mult_di */\n+    COSTS_N_INSNS (1) + 1,\t/* int_shift */\n+    COSTS_N_INSNS (1),\t\t/* int_cmov */\n+  },\n+  { /* EV6 */\n+    COSTS_N_INSNS (4),\t\t/* fp_add */\n+    COSTS_N_INSNS (4),\t\t/* fp_mult */\n+    COSTS_N_INSNS (12),\t\t/* fp_div_sf */\n+    COSTS_N_INSNS (15),\t\t/* fp_div_df */\n+    COSTS_N_INSNS (7),\t\t/* int_mult_si */\n+    COSTS_N_INSNS (7),\t\t/* int_mult_di */\n+    COSTS_N_INSNS (1),\t\t/* int_shift */\n+    COSTS_N_INSNS (2),\t\t/* int_cmov */\n+  },\n+};\n+\n /* Declarations of static functions.  */\n static bool alpha_function_ok_for_sibcall\n   PARAMS ((tree, tree));\n@@ -144,6 +192,8 @@ static int some_small_symbolic_operand_1\n   PARAMS ((rtx *, void *));\n static int split_small_symbolic_operand_1\n   PARAMS ((rtx *, void *));\n+static bool alpha_rtx_costs\n+  PARAMS ((rtx, int, int, int *));\n static void alpha_set_memflags_1\n   PARAMS ((rtx, int, int, int));\n static rtx alpha_emit_set_const_1\n@@ -319,6 +369,9 @@ static void unicosmk_unique_section PARAMS ((tree, int));\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n #endif\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS alpha_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Parse target option strings.  */\n@@ -2474,6 +2527,150 @@ alpha_legitimize_reload_address (x, mode, opnum, type, ind_levels)\n   return NULL_RTX;\n }\n \f\n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+alpha_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  bool float_mode_p = FLOAT_MODE_P (mode);\n+\n+  switch (code)\n+    {\n+      /* If this is an 8-bit constant, return zero since it can be used\n+\t nearly anywhere with no cost.  If it is a valid operand for an\n+\t ADD or AND, likewise return 0 if we know it will be used in that\n+\t context.  Otherwise, return 2 since it might be used there later.\n+\t All other constants take at least two insns.  */\n+    case CONST_INT:\n+      if (INTVAL (x) >= 0 && INTVAL (x) < 256)\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST_DOUBLE:\n+      if (x == CONST0_RTX (mode))\n+\t*total = 0;\n+      else if ((outer_code == PLUS && add_operand (x, VOIDmode))\n+\t       || (outer_code == AND && and_operand (x, VOIDmode)))\n+\t*total = 0;\n+      else if (add_operand (x, VOIDmode) || and_operand (x, VOIDmode))\n+\t*total = 2;\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+      \n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      if (TARGET_EXPLICIT_RELOCS && small_symbolic_operand (x, VOIDmode))\n+\t*total = COSTS_N_INSNS (outer_code != MEM);\n+      else if (TARGET_EXPLICIT_RELOCS && local_symbolic_operand (x, VOIDmode))\n+\t*total = COSTS_N_INSNS (1 + (outer_code != MEM));\n+      else if (tls_symbolic_operand_type (x))\n+\t/* Estimate of cost for call_pal rduniq.  */\n+\t*total = COSTS_N_INSNS (15);\n+      else\n+\t/* Otherwise we do a load from the GOT.  */\n+\t*total = COSTS_N_INSNS (alpha_memory_latency);\n+      return true;\n+    \n+    case PLUS:\n+    case MINUS:\n+      if (float_mode_p)\n+\t*total = alpha_rtx_cost_data[alpha_cpu].fp_add;\n+      else if (GET_CODE (XEXP (x, 0)) == MULT\n+\t       && const48_operand (XEXP (XEXP (x, 0), 1), VOIDmode))\n+\t{\n+\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0), outer_code)\n+\t\t    + rtx_cost (XEXP (x, 1), outer_code) + 2);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case MULT:\n+      if (float_mode_p)\n+\t*total = alpha_rtx_cost_data[alpha_cpu].fp_mult;\n+      else if (mode == DImode)\n+\t*total = alpha_rtx_cost_data[alpha_cpu].int_mult_di;\n+      else\n+\t*total = alpha_rtx_cost_data[alpha_cpu].int_mult_si;\n+      return false;\n+\n+    case ASHIFT:\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) <= 3)\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      *total = alpha_rtx_cost_data[alpha_cpu].int_shift;\n+      return false;\n+\n+    case IF_THEN_ELSE:\n+      if (float_mode_p)\n+        *total = alpha_rtx_cost_data[alpha_cpu].fp_add;\n+      else\n+        *total = alpha_rtx_cost_data[alpha_cpu].int_cmov;\n+      return false;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      if (!float_mode_p)\n+\t*total = COSTS_N_INSNS (70);\t/* ??? */\n+      else if (mode == SFmode)\n+        *total = alpha_rtx_cost_data[alpha_cpu].fp_div_sf;\n+      else\n+        *total = alpha_rtx_cost_data[alpha_cpu].fp_div_df;\n+      return false;\n+\n+    case MEM:\n+      *total = COSTS_N_INSNS (alpha_memory_latency);\n+      return true;\n+\n+    case NEG:\n+      if (! float_mode_p)\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+\n+    case ABS:\n+      if (! float_mode_p)\n+\t{\n+\t  *total = COSTS_N_INSNS (1) + alpha_rtx_cost_data[alpha_cpu].int_cmov;\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+\n+    case FLOAT:\n+    case UNSIGNED_FLOAT:\n+    case FIX:\n+    case UNSIGNED_FIX:\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+      *total = alpha_rtx_cost_data[alpha_cpu].fp_add;\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\f\n /* REF is an alignable memory location.  Place an aligned SImode\n    reference into *PALIGNED_MEM and the number of bits to shift into\n    *PBITNUM.  SCRATCH is a free register for use in reloading out"}, {"sha": "ae28dd2729d6e621b57970881e9c764fe6e942d7", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 5, "deletions": 158, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -112,9 +112,12 @@ Boston, MA 02111-1307, USA.  */\n    mirrors this list, so changes to alpha.md must be made at the same time.  */\n \n enum processor_type\n- {PROCESSOR_EV4,\t\t\t/* 2106[46]{a,} */\n+{\n+  PROCESSOR_EV4,\t\t\t/* 2106[46]{a,} */\n   PROCESSOR_EV5,\t\t\t/* 21164{a,pc,} */\n-  PROCESSOR_EV6};\t\t\t/* 21264 */\n+  PROCESSOR_EV6,\t\t\t/* 21264 */\n+  PROCESSOR_MAX\n+};\n \n extern enum processor_type alpha_cpu;\n \n@@ -1543,162 +1546,6 @@ do {\t\t\t\t\t\t\t\t\t     \\\n /* Define this to be nonzero if shift instructions ignore all but the low-order\n    few bits.  */\n #define SHIFT_COUNT_TRUNCATED 1\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.\n-\n-   If this is an 8-bit constant, return zero since it can be used\n-   nearly anywhere with no cost.  If it is a valid operand for an\n-   ADD or AND, likewise return 0 if we know it will be used in that\n-   context.  Otherwise, return 2 since it might be used there later.\n-   All other constants take at least two insns.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (INTVAL (RTX) >= 0 && INTVAL (RTX) < 256)\t\t\\\n-      return 0;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    if ((RTX) == CONST0_RTX (GET_MODE (RTX)))\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\\\n-    else if (((OUTER_CODE) == PLUS && add_operand (RTX, VOIDmode)) \\\n-\t|| ((OUTER_CODE) == AND && and_operand (RTX, VOIDmode))) \\\n-      return 0;\t\t\t\t\t\t\t\\\n-    else if (add_operand (RTX, VOIDmode) || and_operand (RTX, VOIDmode)) \\\n-      return 2;\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  switch (alpha_cpu)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-    case PROCESSOR_EV4:\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (3);\t\t\t\t\t\\\n-    case PROCESSOR_EV5:\t\t\t\t\t\t\\\n-    case PROCESSOR_EV6:\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-    default: abort();\t\t\t\t\t\t\\\n-    }\n-    \n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  */\n-   \n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n-  case PLUS:  case MINUS:\t\t\t\t\\\n-    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\\\n-      switch (alpha_cpu)\t\t\t\t\\\n-        {\t\t\t\t\t\t\\\n-        case PROCESSOR_EV4:\t\t\t\t\\\n-          return COSTS_N_INSNS (6);\t\t\t\\\n-        case PROCESSOR_EV5:\t\t\t\t\\\n-        case PROCESSOR_EV6:\t\t\t\t\\\n-          return COSTS_N_INSNS (4); \t\t\t\\\n-\tdefault: abort();\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-    else if (GET_CODE (XEXP (X, 0)) == MULT\t\t\\\n-\t     && const48_operand (XEXP (XEXP (X, 0), 1), VOIDmode)) \\\n-      return (2 + rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\\\n-\t      + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\\\n-    break;\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    switch (alpha_cpu)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case PROCESSOR_EV4:\t\t\t\t\\\n-        if (FLOAT_MODE_P (GET_MODE (X)))\t\t\\\n-          return COSTS_N_INSNS (6);\t\t\t\\\n-        return COSTS_N_INSNS (23);\t\t\t\\\n-      case PROCESSOR_EV5:\t\t\t\t\\\n-        if (FLOAT_MODE_P (GET_MODE (X)))\t\t\\\n-          return COSTS_N_INSNS (4);\t\t\t\\\n-        else if (GET_MODE (X) == DImode)\t\t\\\n-          return COSTS_N_INSNS (12);\t\t\t\\\n-        else\t\t\t\t\t\t\\\n-          return COSTS_N_INSNS (8);\t\t\t\\\n-      case PROCESSOR_EV6:\t\t\t\t\\\n-\tif (FLOAT_MODE_P (GET_MODE (X)))\t\t\\\n-\t  return COSTS_N_INSNS (4);\t\t\t\\\n-\telse \t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (7);\t\t\t\\\n-      default: abort();\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n-\t&& INTVAL (XEXP (X, 1)) <= 3)\t\t\t\\\n-      break;\t\t\t\t\t\t\\\n-    /* ... fall through ...  */\t\t\t\t\\\n-  case ASHIFTRT:  case LSHIFTRT:\t\t\t\\\n-    switch (alpha_cpu)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case PROCESSOR_EV4:\t\t\t\t\\\n-        return COSTS_N_INSNS (2);\t\t\t\\\n-      case PROCESSOR_EV5:\t\t\t\t\\\n-      case PROCESSOR_EV6:\t\t\t\t\\\n-        return COSTS_N_INSNS (1); \t\t\t\\\n-      default: abort();\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  case IF_THEN_ELSE:\t\t\t\t\t\\\n-    switch (alpha_cpu)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case PROCESSOR_EV4:\t\t\t\t\\\n-      case PROCESSOR_EV6:\t\t\t\t\\\n-        return COSTS_N_INSNS (2);\t\t\t\\\n-      case PROCESSOR_EV5:\t\t\t\t\\\n-        return COSTS_N_INSNS (1); \t\t\t\\\n-      default: abort();\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  case DIV:  case UDIV:  case MOD:  case UMOD:\t\t\\\n-    switch (alpha_cpu)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case PROCESSOR_EV4:\t\t\t\t\\\n-        if (GET_MODE (X) == SFmode)\t\t\t\\\n-          return COSTS_N_INSNS (34);\t\t\t\\\n-        else if (GET_MODE (X) == DFmode)\t\t\\\n-          return COSTS_N_INSNS (63);\t\t\t\\\n-        else\t\t\t\t\t\t\\\n-          return COSTS_N_INSNS (70);\t\t\t\\\n-      case PROCESSOR_EV5:\t\t\t\t\\\n-        if (GET_MODE (X) == SFmode)\t\t\t\\\n-          return COSTS_N_INSNS (15);\t\t\t\\\n-        else if (GET_MODE (X) == DFmode)\t\t\\\n-          return COSTS_N_INSNS (22);\t\t\t\\\n-        else\t\t\t\t\t\t\\\n-          return COSTS_N_INSNS (70);\t/* ??? */\t\\\n-      case PROCESSOR_EV6:\t\t\t\t\\\n-\tif (GET_MODE (X) == SFmode)\t\t\t\\\n-\t  return COSTS_N_INSNS (12);\t\t\t\\\n-        else if (GET_MODE (X) == DFmode)\t\t\\\n-          return COSTS_N_INSNS (15);\t\t\t\\\n-        else\t\t\t\t\t\t\\\n-          return COSTS_N_INSNS (70);\t/* ??? */\t\\\n-      default: abort();\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\\\n-    switch (alpha_cpu)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case PROCESSOR_EV4:\t\t\t\t\\\n-      case PROCESSOR_EV6:\t\t\t\t\\\n-        return COSTS_N_INSNS (3);\t\t\t\\\n-      case PROCESSOR_EV5:\t\t\t\t\\\n-        return COSTS_N_INSNS (2); \t\t\t\\\n-      default: abort();\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  case NEG:  case ABS:\t\t\t\t\t\\\n-    if (! FLOAT_MODE_P (GET_MODE (X)))\t\t\t\\\n-      break;\t\t\t\t\t\t\\\n-    /* ... fall through ...  */\t\t\t\t\\\n-  case FLOAT:  case UNSIGNED_FLOAT:  case FIX:  case UNSIGNED_FIX: \\\n-  case FLOAT_EXTEND:  case FLOAT_TRUNCATE:\t\t\\\n-    switch (alpha_cpu)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case PROCESSOR_EV4:\t\t\t\t\\\n-        return COSTS_N_INSNS (6);\t\t\t\\\n-      case PROCESSOR_EV5:\t\t\t\t\\\n-      case PROCESSOR_EV6:\t\t\t\t\\\n-        return COSTS_N_INSNS (4); \t\t\t\\\n-      default: abort();\t\t\t\t\t\\\n-      }\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "2048bd3e06efa97dc8c05de870d44be79e33f998", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -96,6 +96,7 @@ static void arc_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void arc_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void arc_encode_section_info PARAMS ((tree, int));\n static void arc_internal_label PARAMS ((FILE *, const char *, unsigned long));\n+static bool arc_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -114,7 +115,10 @@ static void arc_internal_label PARAMS ((FILE *, const char *, unsigned long));\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO arc_encode_section_info\n #undef TARGET_ASM_INTERNAL_LABEL\n-#define  TARGET_ASM_INTERNAL_LABEL arc_internal_label\n+#define TARGET_ASM_INTERNAL_LABEL arc_internal_label\n+\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS arc_rtx_costs\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -2376,3 +2380,61 @@ arc_internal_label (stream, prefix, labelno)\n   arc_ccfsm_at_label (prefix, labelno);\n   default_internal_label (stream, prefix, labelno);\n }\n+\f\n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+arc_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code;\n+     int outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+      /* Small integers are as cheap as registers.  4 byte values can\n+\t be fetched as immediate constants - let's give that the cost\n+\t of an extra insn.  */\n+    case CONST_INT:\n+      if (SMALL_INT (INTVAL (x)))\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      {\n+        rtx high, low;\n+        split_double (x, &high, &low);\n+\t*total = COSTS_N_INSNS (!SMALL_INT (INTVAL (high))\n+\t\t\t\t+ !SMALL_INT (INTVAL (low)));\n+\treturn true;\n+      }\n+\n+    /* Encourage synth_mult to find a synthetic multiply when reasonable.\n+       If we need more than 12 insns to do a multiply, then go out-of-line,\n+       since the call overhead will be < 10% of the cost of the multiply.  */\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (TARGET_SHIFTER)\n+        *total = COSTS_N_INSNS (1);\n+      else if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+        *total = COSTS_N_INSNS (16);\n+      else\n+        *total = COSTS_N_INSNS (INTVAL (XEXP ((x), 1)));\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "4d7b6338cb0fa4d14d3545f3c094d9ee201c90aa", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -995,34 +995,6 @@ arc_select_cc_mode (OP, X, Y)\n \f\n /* Costs.  */\n \n-/* An insn is define to cost 4 \"units\", and we work from there.\n-   COSTS_N_INSNS (N) is defined as (N) * 4 - 2 so that seems reasonable.\n-   Some values are supposed to be defined relative to each other and thus\n-   aren't necessarily related to COSTS_N_INSNS.  */\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-/* Small integers are as cheap as registers.  4 byte values can be fetched\n-   as immediate constants - let's give that the cost of an extra insn.  */\n-#define CONST_COSTS(X, CODE, OUTER_CODE) \\\n-  case CONST_INT :\t\t\t\t\t\t\\\n-    if (SMALL_INT (INTVAL (X)))\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\\\n-  case CONST :\t\t\t\t\t\t\t\\\n-  case LABEL_REF :\t\t\t\t\t\t\\\n-  case SYMBOL_REF :\t\t\t\t\t\t\\\n-    return 4;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE :\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      rtx high, low;\t\t\t\t\t\t\\\n-      split_double (X, &high, &low);\t\t\t\t\\\n-      return 4 * (!SMALL_INT (INTVAL (high))\t\t\t\\\n-\t\t  + !SMALL_INT (INTVAL (low)));\t\t\t\\\n-    }\n-\n /* Compute the cost of an address.  */\n #define ADDRESS_COST(ADDR) (REG_P (ADDR) ? 1 : arc_address_cost (ADDR))\n \n@@ -1041,22 +1013,6 @@ arc_select_cc_mode (OP, X, Y)\n    expensive than reg->reg moves.  */\n #define BRANCH_COST 2\n \n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  The purpose for the cost of MULT is to encourage\n-   `synth_mult' to find a synthetic multiply when reasonable.\n-\n-   If we need more than 12 insns to do a multiply, then go out-of-line,\n-   since the call overhead will be < 10% of the cost of the multiply.  */\n-#define RTX_COSTS(X, CODE, OUTER_CODE) \\\n-  case ASHIFT :\t\t\t\t\t\t\\\n-  case ASHIFTRT :\t\t\t\t\t\\\n-  case LSHIFTRT :\t\t\t\t\t\\\n-    if (TARGET_SHIFTER)\t\t\t\t\t\\\n-      return COSTS_N_INSNS (1);\t\t\t\t\\\n-    if (GET_CODE (XEXP ((X), 1)) != CONST_INT)\t\t\\\n-      return COSTS_N_INSNS (16);\t\t\t\\\n-    return COSTS_N_INSNS (INTVAL (XEXP ((X), 1)));\n-\n /* Nonzero if access to memory by bytes is slow and undesirable.\n    For RISC chips, it means that access to memory by bytes is no\n    better than access by words when possible, so grab a whole word"}, {"sha": "5fed1df3efc2bfd05bdcc384ac95aa3fcd2a5c53", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -57,7 +57,6 @@ extern int    thumb_legitimate_address_p PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t\t  int));\n extern int    thumb_legitimate_offset_p\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t HOST_WIDE_INT));\n-extern int    arm_rtx_costs\t\tPARAMS ((rtx, RTX_CODE, RTX_CODE));\n extern int    const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n extern int    neg_const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n "}, {"sha": "5bbe6acc90948e565f6b78322a8884717abde1ae", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -140,6 +140,9 @@ static void\t arm_internal_label\t\tPARAMS ((FILE *, const char *, unsigned long));\n static void arm_output_mi_thunk\t\t\tPARAMS ((FILE *, tree,\n \t\t\t\t\t\t\t HOST_WIDE_INT,\n \t\t\t\t\t\t\t HOST_WIDE_INT, tree));\n+static int arm_rtx_costs_1\t\t\tPARAMS ((rtx, enum rtx_code,\n+\t\t\t\t\t\t\t enum rtx_code));\n+static bool arm_rtx_costs\t\t\tPARAMS ((rtx, int, int, int*));\n \n #undef Hint\n #undef Mmode\n@@ -213,6 +216,9 @@ static void arm_output_mi_thunk\t\t\tPARAMS ((FILE *, tree,\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS arm_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -2909,8 +2915,8 @@ thumb_legitimate_offset_p (mode, val)\n #define COSTS_N_INSNS(N) ((N) * 4 - 2)\n #endif\n \n-int\n-arm_rtx_costs (x, code, outer)\n+static inline int\n+arm_rtx_costs_1 (x, code, outer)\n      rtx x;\n      enum rtx_code code;\n      enum rtx_code outer;\n@@ -3294,6 +3300,16 @@ arm_rtx_costs (x, code, outer)\n     }\n }\n \n+static bool\n+arm_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  *total = arm_rtx_costs_1 (x, code, outer_code);\n+  return true;\n+}\n+\n static int\n arm_adjust_cost (insn, link, dep, cost)\n      rtx insn;"}, {"sha": "c2afa4dc21122cf020aa7cbd58714db3473dfdd5", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2138,9 +2138,6 @@ typedef struct\n   (   (X) == frame_pointer_rtx || (X) == stack_pointer_rtx\t\\\n    || (X) == arg_pointer_rtx)\n \n-#define DEFAULT_RTX_COSTS(X, CODE, OUTER_CODE)\t\t\\\n-  return arm_rtx_costs (X, CODE, OUTER_CODE);\n-\n /* Moves to and from memory are quite expensive */\n #define MEMORY_MOVE_COST(M, CLASS, IN)\t\t\t\\\n   (TARGET_ARM ? 10 :\t\t\t\t\t\\"}, {"sha": "b721b3e5a54f9373cbaab4fd80ae76dfb1c567b6", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -114,8 +114,6 @@ extern const char * output_reload_inhi PARAMS ((rtx insn, rtx *operands,\n \t\t\t\t\t\tint *len));\n extern const char * output_reload_insisf PARAMS ((rtx insn, rtx *operands,\n \t\t\t\t\t\tint *len));\n-extern int    default_rtx_costs      PARAMS ((rtx X, RTX_CODE code,\n-\t\t\t\t\t     RTX_CODE outer_code));\n extern enum reg_class secondary_input_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t\t   enum machine_mode,\n \t\t\t\t\t\t\t   rtx));"}, {"sha": "037801243ba7d1bb8f9d43bcb919d852697dde62", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -71,6 +71,8 @@ static unsigned int avr_section_type_flags PARAMS ((tree, const char *, int));\n \n static void   avr_asm_out_ctor PARAMS ((rtx, int));\n static void   avr_asm_out_dtor PARAMS ((rtx, int));\n+static int default_rtx_costs PARAMS ((rtx, enum rtx_code, enum rtx_code));\n+static bool avr_rtx_costs PARAMS ((rtx, int, int, int *));\n \n /* Allocate registers from r25 to r8 for parameters for function calls */\n #define FIRST_CUM_REG 26\n@@ -227,6 +229,8 @@ int avr_case_values_threshold = 30000;\n #define TARGET_ENCODE_SECTION_INFO avr_encode_section_info\n #undef TARGET_SECTION_TYPE_FLAGS\n #define TARGET_SECTION_TYPE_FLAGS avr_section_type_flags\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS avr_rtx_costs\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -4978,7 +4982,7 @@ order_regs_for_local_alloc ()\n /* Calculate the cost of X code of the expression in which it is contained,\n    found in OUTER_CODE */\n \n-int\n+static int\n default_rtx_costs (X, code, outer_code)\n      rtx X;\n      enum rtx_code code;\n@@ -5037,6 +5041,56 @@ default_rtx_costs (X, code, outer_code)\n   return cost;\n }\n \n+static bool\n+avr_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  int cst;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (outer_code == PLUS\n+\t  || outer_code == IOR\n+\t  || outer_code == AND\n+\t  || outer_code == MINUS\n+\t  || outer_code == SET\n+\t  || INTVAL (x) == 0)\n+\t{\n+          *total = 2;\n+\t  return true;\n+\t}\n+      if (outer_code == COMPARE\n+\t  && INTVAL (x) >= 0\n+\t  && INTVAL (x) <= 255)\n+\t{\n+\t  *total = 2;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+      *total = 4;\n+      return true;\n+\n+    default:\n+      cst = default_rtx_costs (x, code, outer_code);\n+      if (cst > 0)\n+\t{\n+\t  *total = cst;\n+\t  return true;\n+\t}\n+      else if (cst < 0)\n+\t*total += -cst;\n+      return false;\n+    }\n+}\n+\n /* Calculate the cost of a memory address */\n \n int"}, {"sha": "126a6fdb7b8ee6e6b188b387148820175ebcfcd5", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1521,59 +1521,6 @@ do {\t\t\t\t\t\t\t\t\t    \\\n    is a suitable definition for this macro on machines where anything\n    `CONSTANT_P' is valid.  */\n \n-#define CONST_COSTS(x,CODE,OUTER_CODE)\t\t\\\n-    case CONST_INT:\t\t\t\t\\\n-      if (OUTER_CODE == PLUS\t\t\t\\\n-\t  || OUTER_CODE == IOR\t\t\t\\\n-\t  || OUTER_CODE == AND\t\t\t\\\n-\t  || OUTER_CODE == MINUS\t\t\\\n-\t  || OUTER_CODE == SET\t\t\t\\\n-\t  || INTVAL (x) == 0)\t\t\t\\\n-        return 2;\t\t\t\t\\\n-      if (OUTER_CODE == COMPARE\t\t\t\\\n-\t  && INTVAL (x) >= 0\t\t\t\\\n-\t  && INTVAL (x) <= 255)\t\t\t\\\n-        return 2;\t\t\t\t\\\n-    case CONST:\t\t\t\t\t\\\n-    case LABEL_REF:\t\t\t\t\\\n-    case SYMBOL_REF:\t\t\t\t\\\n-      return 4;\t\t\t\t\t\\\n-    case CONST_DOUBLE:\t\t\t\t\\\n-      return 4;\n-\n-/* A part of a C `switch' statement that describes the relative costs\n-   of constant RTL expressions.  It must contain `case' labels for\n-   expression codes `const_int', `const', `symbol_ref', `label_ref'\n-   and `const_double'.  Each case must ultimately reach a `return'\n-   statement to return the relative cost of the use of that kind of\n-   constant value in an expression.  The cost may depend on the\n-   precise value of the constant, which is available for examination\n-   in X, and the rtx code of the expression in which it is contained,\n-   found in OUTER_CODE.\n-\n-   CODE is the expression code--redundant, since it can be obtained\n-   with `GET_CODE (X)'.  */\n-\n-#define DEFAULT_RTX_COSTS(x, code, outer_code)\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  int cst = default_rtx_costs (x, code, outer_code);\t\\\n-  if (cst>0)\t\t\t\t\t\t\\\n-    return cst;\t\t\t                \\\n-  else if (cst<0)\t\t\t\t\t\\\n-    total += -cst;\t\t\t                \\\n-  break;\t\t\t\t\t\t\\\n-}\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n-   This can be used, for example, to indicate how costly a multiply\n-   instruction is.  In writing this macro, you can use the construct\n-   `COSTS_N_INSNS (N)' to specify a cost equal to N fast\n-   instructions.  OUTER_CODE is the code of the expression in which X\n-   is contained.\n-\n-   This macro is optional; do not define it if the default cost\n-   assumptions are adequate for the target machine.  */\n-\n #define ADDRESS_COST(ADDRESS) avr_address_cost (ADDRESS)\n \n /* An expression giving the cost of an addressing mode that contains"}, {"sha": "2d83a8c9b663804c3b1b3666ed395540d02146de", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -197,6 +197,7 @@ static void c4x_asm_named_section PARAMS ((const char *, unsigned int));\n static int c4x_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static void c4x_encode_section_info PARAMS ((tree, int));\n static void c4x_globalize_label PARAMS ((FILE *, const char *));\n+static bool c4x_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_BYTE_OP\n@@ -227,6 +228,9 @@ static void c4x_globalize_label PARAMS ((FILE *, const char *));\n #undef TARGET_ASM_GLOBALIZE_LABEL\n #define TARGET_ASM_GLOBALIZE_LABEL c4x_globalize_label\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS c4x_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Override command line options.\n@@ -5062,3 +5066,98 @@ c4x_globalize_label (stream, name)\n   default_globalize_label (stream, name);\n   c4x_global_label (name);\n }\n+\f\n+#define SHIFT_CODE_P(C) \\\n+  ((C) == ASHIFT || (C) == ASHIFTRT || (C) == LSHIFTRT)\n+#define LOGICAL_CODE_P(C) \\\n+  ((C) == NOT || (C) == AND || (C) == IOR || (C) == XOR)\n+\n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+c4x_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  HOST_WIDE_INT val;\n+\n+  switch (code)\n+    {\n+      /* Some small integers are effectively free for the C40.  We should\n+         also consider if we are using the small memory model.  With\n+         the big memory model we require an extra insn for a constant\n+         loaded from memory.  */\n+\n+    case CONST_INT:\n+      val = INTVAL (x);\n+      if (c4x_J_constant (x))\n+\t*total = 0;\n+      else if (! TARGET_C3X\n+\t       && outer_code == AND\n+\t       && (val == 255 || val == 65535))\n+\t*total = 0;\n+      else if (! TARGET_C3X\n+\t       && (outer_code == ASHIFTRT || outer_code == LSHIFTRT)\n+\t       && (val == 16 || val == 24))\n+\t*total = 0;\n+      else if (TARGET_C3X && SHIFT_CODE_P (outer_code))\n+\t*total = 3;\n+      else if (LOGICAL_CODE_P (outer_code)\n+               ? c4x_L_constant (x) : c4x_I_constant (x))\n+\t*total = 2;\n+      else\n+\t*total = 4;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = 4;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (c4x_H_constant (x))\n+\t*total = 2;\n+      else if (GET_MODE (x) == QFmode)\n+\t*total = 4;\n+      else\n+\t*total = 8;\n+      return true;\n+\n+    /* ??? Note that we return true, rather than false so that rtx_cost\n+       doesn't include the constant costs.  Otherwise expand_mult will\n+       think that it is cheaper to synthesize a multiply rather than to\n+       use a multiply instruction.  I think this is because the algorithm\n+       synth_mult doesn't take into account the loading of the operands,\n+       whereas the calculation of mult_cost does.  */\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case MULT:\n+      *total = COSTS_N_INSNS (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n+\t\t\t      || TARGET_MPYI ? 1 : 14);\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n+\t\t\t      ? 15 : 50);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "891ed4bf200d890ca8424410668384622998002e", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 3, "deletions": 96, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1461,103 +1461,10 @@ CUMULATIVE_ARGS;\n \n /* Descripting Relative Cost of Operations.  */\n \n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE. \n-\n-   Note that we return, rather than break so that rtx_cost doesn't\n-   include CONST_COSTS otherwise expand_mult will think that it is\n-   cheaper to synthesize a multiply rather than to use a multiply\n-   instruction.  I think this is because the algorithm synth_mult\n-   doesn't take into account the loading of the operands, whereas the\n-   calculation of mult_cost does. \n-*/\n-\n-\n-#define RTX_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\t\\\n-    case PLUS:\t\t\t\t\t\t\t\t\\\n-    case MINUS:\t\t\t\t\t\t\t\t\\\n-    case AND:\t\t\t\t\t\t\t\t\\\n-    case IOR:\t\t\t\t\t\t\t\t\\\n-    case XOR:\t\t\t\t\t\t\t\t\\\n-    case ASHIFT:\t\t\t\t\t\t\t\\\n-    case ASHIFTRT:\t\t\t\t\t\t\t\\\n-    case LSHIFTRT:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-    case MULT:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (GET_MODE_CLASS (GET_MODE (RTX)) == MODE_FLOAT \\\n-\t\t\t  || TARGET_MPYI ? 1 : 14);\t\t\t\\\n-    case DIV:\t\t\t\t\t\t\t\t\\\n-    case UDIV:\t\t\t\t\t\t\t\t\\\n-    case MOD: \t\t\t\t\t\t\t\t\\\n-    case UMOD:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (GET_MODE_CLASS (GET_MODE (RTX)) == MODE_FLOAT\t\\\n-\t\t\t  ? 15 : 50);\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.\n-\n-   An insn is assumed to cost 4 units.\n-   COSTS_N_INSNS (N) is defined as (N) * 4 - 2.\n-\n-   Some small integers are effectively free for the C40.  We should\n-   also consider if we are using the small memory model.  With\n-   the big memory model we require an extra insn for a constant\n-   loaded from memory.  \n-\n-   This is used by expand_binop to decide whether to force a constant\n-   into a register.  If the cost is greater than 2 and the constant\n-   is used within a short loop, it gets forced into a register.  \n-   Ideally, there should be some weighting as to how mnay times it is used\n-   within the loop.  */\n-\n-#define SHIFT_CODE_P(C) ((C) == ASHIFT || (C) == ASHIFTRT || (C) == LSHIFTRT)\n-\n-#define LOGICAL_CODE_P(C) ((C) == NOT || (C) == AND \\\n-                           || (C) == IOR || (C) == XOR)\n-\n-#define NON_COMMUTATIVE_CODE_P ((C) == MINUS || (C) == COMPARE)\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\\\n-\tcase CONST_INT:\t\t\t\t\t\t\\\n-           if (c4x_J_constant (RTX))\t\t\t\t\\\n-\t     return 0;\t\t\t\t\t\t\\\n-\t   if (! TARGET_C3X\t\t\t\t\t\\\n-\t       && OUTER_CODE == AND\t\t\t\t\\\n-               && GET_CODE (RTX) == CONST_INT\t\t\t\\\n-\t       && (INTVAL (RTX) == 255 || INTVAL (RTX) == 65535))\t\\\n-\t     return 0;\t\t\t\t\t\t\\\n-\t   if (! TARGET_C3X\t\t\t\t\t\\\n-\t       && (OUTER_CODE == ASHIFTRT || OUTER_CODE == LSHIFTRT)\t\\\n-               && GET_CODE (RTX) == CONST_INT\t\t\t\\\n-\t       && (INTVAL (RTX) == 16 || INTVAL (RTX) == 24))\t\\\n-\t     return 0;\t\t\t\t\t\t\\\n-           if (TARGET_C3X && SHIFT_CODE_P (OUTER_CODE))\t\t\\\n-\t     return 3;\t\t\t\t\t\t\\\n-           if (LOGICAL_CODE_P (OUTER_CODE) \t\t\t\\\n-               ? c4x_L_constant (RTX) : c4x_I_constant (RTX))\t\\\n-\t     return 2;\t\t\t\t\t\t\\\n-\tcase CONST:\t\t\t\t\t\t\\\n-\tcase LABEL_REF:\t\t\t\t\t\t\\\n-\tcase SYMBOL_REF:\t\t\t\t\t\\\n-\t   return 4;\t\t\t\t\t\t\\\n-\tcase CONST_DOUBLE:\t\t\t\t\t\\\n-\t   if (c4x_H_constant (RTX))\t\t\t\t\\\n-\t     return 2;\t\t\t\t\t\t\\\n-           if (GET_MODE (RTX) == QFmode)\t\t\t\\\n-\t     return 4;\t\t\t\t\t\t\\\n-           else\t\t\t\t\t\t\t\\\n-\t     return 8;\n-\n /* Compute the cost of an address.  This is meant to approximate the size\n-   and/or execution delay of an insn using that address.  If the cost is\n-   approximated by the RTL complexity, including CONST_COSTS above, as\n-   is usually the case for CISC machines, this macro should not be defined.\n-   For aggressively RISCy machines, only one insn format is allowed, so\n-   this macro should be a constant.  The value of this macro only matters\n-   for valid addresses.  We handle the most common address without \n-   a call to c4x_address_cost.  */\n+   and/or execution delay of an insn using that address.  The value of this\n+   macro only matters for valid addresses.  We handle the most common address\n+   without a call to c4x_address_cost.  */\n \n #define ADDRESS_COST(ADDR) (REG_P (ADDR) ? 1 : c4x_address_cost (ADDR))\n "}, {"sha": "6842dfebda01bc2cc0cad0596030f6376cbbe0f5", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2082,6 +2082,115 @@ cris_simple_epilogue ()\n   return 1;\n }\n \n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+cris_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      {\n+\tHOST_WIDE_INT val = INTVAL (x);\n+\tif (val == 0)\n+\t  *total = 0;\n+\telse if (val < 32 && val >= -32)\n+\t  *total = 1;\n+\t/* Eight or 16 bits are a word and cycle more expensive.  */\n+\telse if (val <= 32767 && val >= -32768)\n+\t  *total = 2;\n+\t/* A 32 bit constant (or very seldom, unsigned 16 bits) costs\n+\t   another word.  FIXME: This isn't linear to 16 bits.  */\n+\telse\n+\t  *total = 4;\n+\treturn true;\n+      }\n+\n+    case LABEL_REF:\n+      *total = 6;\n+      return true;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+      /* For PIC, we need a prefix (if it isn't already there),\n+\t and the PIC register.  For a global PIC symbol, we also\n+\t need a read of the GOT.  */\n+      if (flag_pic)\n+\tif (cris_got_symbol (x))\n+\t  *total = 2 + 4 + 6;\n+\telse\n+\t  *total = 2 + 6;\n+      else\n+\t*total = 6;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (x != CONST0_RTX (GET_MODE (x) == VOIDmode ? DImode : GET_MODE (x)))\n+\t*total = 12;\n+      else\n+        /* Make 0.0 cheap, else test-insns will not be used.  */\n+\t*total = 0;\n+      return true;\n+\n+    case MULT:\n+      /* Identify values that are no powers of two.  Powers of 2 are\n+         taken care of already and those values should not be changed.  */\n+      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+          || exact_log2 (INTVAL (XEXP (x, 1)) < 0))\n+\t{\n+\t  /* If we have a multiply insn, then the cost is between\n+\t     1 and 2 \"fast\" instructions.  */\n+\t  if (TARGET_HAS_MUL_INSNS)\n+\t    {\n+\t      *total = COSTS_N_INSNS (1) + COSTS_N_INSNS (1) / 2;\n+\t      return true;\n+\t    }\n+\n+\t  /* Estimate as 4 + 4 * #ofbits.  */\n+\t  *total = COSTS_N_INSNS (132);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+    case DIV:\n+      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+          || exact_log2 (INTVAL (XEXP (X, 1)) < 0))\n+\t{\n+\t  /* Estimate this as 4 + 8 * #of bits.  */\n+\t  *total = COSTS_N_INSNS (260);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case AND:\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+          /* Two constants may actually happen before optimization.  */\n+          && GET_CODE (XEXP (x, 0)) != CONST_INT\n+          && !CONST_OK_FOR_LETTER_P (INTVAL (XEXP (x, 1)), 'I'))\n+\t{\n+\t  *total = (rtx_cost (XEXP (x, 0), outer_code) + 2\n+\t\t    + 2 * GET_MODE_NUNITS (GET_MODE (XEXP (x, 0))));\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case ZERO_EXTEND: case SIGN_EXTEND:\n+      *total = rtx_cost (XEXP (x, 0), outer_code);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* The ADDRESS_COST worker.  */\n \n int"}, {"sha": "38449c7bc812311c445dc551c9ab1b350828e5d6", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1336,73 +1336,6 @@ struct cum_args {int regs;};\n \n /* Node: Costs */\n \n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\t\\\n- case CONST_INT:\t\t\t\t\t\t\t\\\n-   if (INTVAL (RTX) == 0)\t\t\t\t\t\t\\\n-     return 0;\t\t\t\t\t\t\t\t\\\n-   if (INTVAL (RTX) < 32 && INTVAL (RTX) >= -32)\t\t\t\\\n-     return 1;\t\t\t\t\t\t\t\t\\\n-   /* Eight or 16 bits are a word and cycle more expensive.  */\t\t\\\n-   if (INTVAL (RTX) <= 32767 && INTVAL (RTX) >= -32768)\t\t\t\\\n-     return 2;\t\t\t\t\t\t\t\t\\\n-   /* A 32 bit constant (or very seldom, unsigned 16 bits) costs\t\\\n-      another word.  FIXME: This isn't linear to 16 bits.  */\t\t\\\n-   return 4;\t\t\t\t\t\t\t\t\\\n- case LABEL_REF:\t\t\t\t\t\t\t\\\n-   return 6;\t\t\t\t\t\t\t\t\\\n- case CONST:\t\t\t\t\t\t\t\t\\\n- case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-   /* For PIC, we need a prefix (if it isn't already there),\t\t\\\n-      and the PIC register.  For a global PIC symbol, we also need a\t\\\n-      read of the GOT.  */\t\t\t\t\t\t\\\n-   return\t\t\t\t\t\t\t\t\\\n-     flag_pic ? (cris_got_symbol (RTX) ? (2 + 4 + 6) : (2 + 6)) : 6;\t\\\n- case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-   if (RTX != CONST0_RTX (GET_MODE (RTX) == VOIDmode ? DImode\t\t\\\n-\t\t\t  : GET_MODE (RTX)))\t\t\t\t\\\n-     return 12;\t\t\t\t\t\t\t\t\\\n-   /* Make 0.0 cheap, else test-insns will not be used.  */\t\t\\\n-   return 0;\n-\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n- case MULT:\t\t\t\t\t\t\t\t\\\n-   /* Identify values that are no powers of two.  Powers of 2 are\t\\\n-      taken care of already and those values should not be\t\t\\\n-      changed.  */\t\t\t\t\t\t\t\\\n-   if (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\t\\\n-       || exact_log2 (INTVAL (XEXP (X, 1)) < 0))\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\t\\\n-\t/* If we have a multiply insn, then the cost is between\t\t\\\n-\t   1 and 2 \"fast\" instructions.  */\t\t\t\t\\\n-\tif (TARGET_HAS_MUL_INSNS)\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (1) + COSTS_N_INSNS (1) /2;\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t/* Estimate as 4 + 4 * #ofbits.  */\t\t\t\t\\\n-\treturn COSTS_N_INSNS (132);\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\t\\\n-     break;\t\t\t\t\t\t\t\t\\\n- case UDIV:\t\t\t\t\t\t\t\t\\\n- case MOD:\t\t\t\t\t\t\t\t\\\n- case UMOD:\t\t\t\t\t\t\t\t\\\n- case DIV:\t\t\t\t\t\t\t\t\\\n-   if (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\t\\\n-       || exact_log2 (INTVAL (XEXP (X, 1)) < 0))\t\t\t\\\n-     /* Estimate this as 4 + 8 * #of bits.  */\t\t\t\t\\\n-     return COSTS_N_INSNS (260);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n- case AND:\t\t\t\t\t\t\t\t\\\n-   if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-       /* Two constants may actually happen before optimization.  */\t\\\n-       && GET_CODE (XEXP (X, 0)) != CONST_INT\t\t\t\t\\\n-       && !CONST_OK_FOR_LETTER_P (INTVAL (XEXP (X, 1)), 'I'))\t\t\\\n-     return\t\t\t\t\t\t\t\t\\\n-       rtx_cost (XEXP (X, 0), OUTER_CODE) + 2\t\t\t\t\\\n-       + 2 * GET_MODE_NUNITS (GET_MODE (XEXP (X, 0)));\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n- case ZERO_EXTEND: case SIGN_EXTEND:\t\t\t\t\t\\\n-   /* Same as move. If embedded in other insn, cost is 0.  */\t\t\\\n-   return rtx_cost (XEXP (X, 0), OUTER_CODE);\n-\n #define ADDRESS_COST(X) cris_address_cost (X)\n \n /* FIXME: Need to define REGISTER_MOVE_COST when more register classes are"}, {"sha": "b3b72cd21cd4cc5233ac2dbf548f8fa7c3a8fedc", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -54,6 +54,7 @@ static void d30v_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void d30v_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static int d30v_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int d30v_issue_rate PARAMS ((void));\n+static bool d30v_rtx_costs PARAMS ((rtx, int, int, int *));\n \n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  */\n@@ -99,6 +100,9 @@ enum reg_class reg_class_from_letter[256];\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE d30v_issue_rate\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS d30v_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -3505,3 +3509,23 @@ d30v_return_addr ()\n {\n   return get_hard_reg_initial_val (Pmode, GPR_LINK);\n }\n+\f\n+static bool\n+d30v_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code;\n+     int outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case MULT:\n+      *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t\t       && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n+\t\t\t      ? 1 : 2);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "db0e120de28d5a508ab33a3c0c8c52da56920c88", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2426,55 +2426,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Describing Relative Costs of Operations */\n \n-/* A part of a C `switch' statement that describes the relative costs of\n-   constant RTL expressions.  It must contain `case' labels for expression\n-   codes `const_int', `const', `symbol_ref', `label_ref' and `const_double'.\n-   Each case must ultimately reach a `return' statement to return the relative\n-   cost of the use of that kind of constant value in an expression.  The cost\n-   may depend on the precise value of the constant, which is available for\n-   examination in X, and the rtx code of the expression in which it is\n-   contained, found in OUTER_CODE.\n-\n-   CODE is the expression code--redundant, since it can be obtained with\n-   `GET_CODE (X)'.  */\n-\n-/* On the d30v, consider operatnds that fit in a short instruction very\n-   cheap.  However, at this time, it causes cse to generate incorrect\n-   code, so disable it for now.  */\n-#if 0\n-#define CONST_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    if (IN_RANGE_P (INTVAL (X), 0, 31))\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    else if ((OUTER_CODE) == LEU && (OUTER_CODE) == LTU\t\t\t\\\n-\t     && (OUTER_CODE) == GEU && (OUTER_CODE) == GTU)\t\t\\\n-      return IN_RANGE_P (INTVAL (X), 32, 63) ? 0 : COSTS_N_INSNS (2);\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      return IN_RANGE_P (INTVAL (X), -31, -1) ? 0 : COSTS_N_INSNS (2);\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_MODE (X) == SFmode) ? 2 : 4);\n-#else\n-#define CONST_COSTS(X, CODE, OUTER_CODE)\n-#endif\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.  This can be\n-   used, for example, to indicate how costly a multiply instruction is.  In\n-   writing this macro, you can use the construct `COSTS_N_INSNS (N)' to specify\n-   a cost equal to N fast instructions.  OUTER_CODE is the code of the\n-   expression in which X is contained.\n-\n-   This macro is optional; do not define it if the default cost assumptions are\n-   adequate for the target machine.  */\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT\t\t\\\n-\t\t\t   && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\t\\\n-\t\t\t  ? 1 : 2);\n-\n /* An expression giving the cost of an addressing mode that contains ADDRESS.\n    If not defined, the cost is computed from the ADDRESS expression and the\n    `CONST_COSTS' values."}, {"sha": "6d402bf6e3fdba2e6efe422f40fd234ce2759d5d", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -151,8 +151,10 @@ static const char *const lshift_right_asm_first[] =\n static int reg_save_size PARAMS ((void));\n static void dsp16xx_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void dsp16xx_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-\n+static bool dsp16xx_rtx_costs PARAMS ((rtx, int, int, int *));\n+\f\n /* Initialize the GCC target structure.  */\n+\n #undef TARGET_ASM_BYTE_OP\n #define TARGET_ASM_BYTE_OP \"\\tint\\t\"\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -165,6 +167,9 @@ static void dsp16xx_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE dsp16xx_output_function_epilogue\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS dsp16xx_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n int \n@@ -2569,3 +2574,88 @@ signed_comparison_operator (op, mode)\n \n   return 0;\n }\n+\f\n+static bool\n+dsp16xx_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code;\n+     int outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      *total = (unsigned HOST_WIDE_INT) INTVAL (x) < 65536 ? 0 : 2;\n+      return true;\n+\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case MEM:\n+      *total = COSTS_N_INSNS (GET_MODE (x) == QImode ? 2 : 4);\n+      return true;\n+\n+    case DIV:\n+    case MOD:\n+      *total = COSTS_N_INSNS (38);\n+      return true;\n+\n+    case MULT:\n+      if (GET_MODE (x) == QImode)\n+        *total = COSTS_N_INSNS (2);\n+      else\n+\t*total = COSTS_N_INSNS (38);\n+      return true;\n+\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+\t{\n+\t  *total = 1;\n+\t  return false;\n+\t}\n+      else\n+\t{\n+          *total = COSTS_N_INSNS (38);\n+\t  return true;\n+\t}\n+\n+    case NEG:\n+    case NOT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT number = INTVAL (XEXP (x, 1));\n+\t  if (number == 1 || number == 4 || number == 8\n+\t      || number == 16)\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else if (TARGET_BMU)\n+            *total = COSTS_N_INSNS (2);\n+          else\n+            *total = COSTS_N_INSNS (num_1600_core_shifts (number));\n+\t  return true;\n+\t}\n+      break;\n+    }\n+\n+  if (TARGET_BMU)\n+    *total = COSTS_N_INSNS (1);\n+  else\n+    *total = COSTS_N_INSNS (15);\n+  return true;\n+}"}, {"sha": "d80213a7a68a5ba7c239e2915d459ac8d7c5e62e", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1431,76 +1431,6 @@ extern struct dsp16xx_frame_info current_frame_info;\n \f\n /* DESCRIBING RELATIVE COSTS OF OPERATIONS */\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  */\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE)                                \\\n-  case CONST_INT:\t\t\t\t\t\t        \\\n-    return (unsigned) INTVAL (RTX) < 65536 ? 0 : 2;                     \\\n-  case LABEL_REF:\t\t\t\t\t\t        \\\n-  case SYMBOL_REF:\t\t\t\t\t\t        \\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-                                                                        \\\n-  case CONST_DOUBLE:\t\t\t\t\t\t        \\\n-    return COSTS_N_INSNS (2);\n-\n-/* Like CONST_COSTS but applies to nonconstant RTL expressions.\n-   This can be used, for example to indicate how costly a multiply\n-   instruction is.  */\n-#define RTX_COSTS(X,CODE,OUTER_CODE)                            \\\n-  case MEM:                                                     \\\n-    return GET_MODE (X) == QImode ? COSTS_N_INSNS (2) :         \\\n-                                    COSTS_N_INSNS (4);          \\\n-  case DIV:                                                     \\\n-  case MOD:                                                     \\\n-    return COSTS_N_INSNS (38);                                  \\\n-  case MULT:                                                    \\\n-    if (GET_MODE (X) == QImode)                                 \\\n-        return COSTS_N_INSNS (2);                               \\\n-    else                                                        \\\n-        return COSTS_N_INSNS (38);                              \\\n-  case PLUS:                                                    \\\n-  case MINUS:                                                   \\\n-    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)              \\\n-        {                                                       \\\n-          return (1 +                                           \\\n-                  rtx_cost (XEXP (X, 0), CODE) +                \\\n-                  rtx_cost (XEXP (X, 1), CODE));                \\\n-        }                                                       \\\n-    else                                                        \\\n-        return COSTS_N_INSNS (38);                              \\\n-                                                                \\\n-  case AND: case IOR: case XOR:                                 \\\n-        return (1 +                                             \\\n-                rtx_cost (XEXP (X, 0), CODE) +                  \\\n-                rtx_cost (XEXP (X, 1), CODE));                  \\\n-                                                                \\\n-  case NEG: case NOT:                                           \\\n-    return COSTS_N_INSNS (1);                                   \\\n-  case ASHIFT:                                                  \\\n-  case ASHIFTRT:                                                \\\n-  case LSHIFTRT:                                                \\\n-    if (GET_CODE (XEXP (X,1)) == CONST_INT)                     \\\n-      {                                                         \\\n-        int number = INTVAL(XEXP (X,1));                        \\\n-        if (number == 1 || number == 4 || number == 8 ||        \\\n-            number == 16)                                       \\\n-            return COSTS_N_INSNS (1);                           \\\n-        else                                                    \\\n-\t{                                                       \\\n-          if (TARGET_BMU)                                       \\\n-            return COSTS_N_INSNS (2);                           \\\n-          else                                                  \\\n-            return COSTS_N_INSNS (num_1600_core_shifts(number)); \\\n-\t}                                                       \\\n-      }                                                         \\\n-    if (TARGET_BMU)                                             \\\n-      return COSTS_N_INSNS (1);                                 \\\n-    else                                                        \\\n-      return COSTS_N_INSNS (15);\n-\n /* An expression giving the cost of an addressing mode that contains\n    address.  */\n #define ADDRESS_COST(ADDR)  dsp16xx_address_cost (ADDR)"}, {"sha": "1c8f56686719c3bd23e0e1ee71d5d99faeb4073c", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -283,6 +283,7 @@ static rtx frv_expand_builtin\t\t\tPARAMS ((tree, rtx, rtx, enum machine_mode, int)\n static bool frv_in_small_data_p\t\t\tPARAMS ((tree));\n static void frv_asm_output_mi_thunk\n   PARAMS ((FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n+static bool frv_rtx_costs\t\t\tPARAMS ((rtx, int, int, int*));\n \f\n /* Initialize the GCC target structure.  */\n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n@@ -301,6 +302,8 @@ static void frv_asm_output_mi_thunk\n #define TARGET_EXPAND_BUILTIN frv_expand_builtin\n #undef TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P frv_in_small_data_p\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS frv_rtx_costs\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK frv_asm_output_mi_thunk\n@@ -9788,3 +9791,65 @@ frv_in_small_data_p (decl)\n   return symbol_ref_small_data_p (XEXP (DECL_RTL (decl), 0))\n     && size > 0 && size <= g_switch_value;\n }\n+\f\n+static bool\n+frv_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      /* Make 12 bit integers really cheap.  */\n+      if (IN_RANGE_P (INTVAL (x), -2048, 2047))\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case NOT:\n+    case NEG:\n+    case COMPARE:\n+      if (GET_MODE (x) == SImode)\n+\t*total = COSTS_N_INSNS (1);\n+      else if (GET_MODE (x) == DImode)\n+        *total = COSTS_N_INSNS (2);\n+      else\n+        *total = COSTS_N_INSNS (3);\n+      return true;\n+\n+    case MULT:\n+      if (GET_MODE (x) == SImode)\n+        *total = COSTS_N_INSNS (2);\n+      else\n+        *total = COSTS_N_INSNS (6);\t/* guess */\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (18);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "64aa29e72c289a2590feacd627c209a082926e6c", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2541,65 +2541,6 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n \f\n /* Describing Relative Costs of Operations.  */\n \n-/* A part of a C `switch' statement that describes the relative costs of\n-   constant RTL expressions.  It must contain `case' labels for expression\n-   codes `const_int', `const', `symbol_ref', `label_ref' and `const_double'.\n-   Each case must ultimately reach a `return' statement to return the relative\n-   cost of the use of that kind of constant value in an expression.  The cost\n-   may depend on the precise value of the constant, which is available for\n-   examination in X, and the rtx code of the expression in which it is\n-   contained, found in OUTER_CODE.\n-\n-   CODE is the expression code--redundant, since it can be obtained with\n-   `GET_CODE (X)'.  */\n-#define CONST_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    /* Make 12 bit integers really cheap */\t\t\t\t\\\n-    return IN_RANGE_P (INTVAL (X), -2048, 2047) ? 0 : COSTS_N_INSNS (2); \\\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.  This can be\n-   used, for example, to indicate how costly a multiply instruction is.  In\n-   writing this macro, you can use the construct `COSTS_N_INSNS (N)' to specify\n-   a cost equal to N fast instructions.  OUTER_CODE is the code of the\n-   expression in which X is contained.\n-\n-   This macro is optional; do not define it if the default cost assumptions are\n-   adequate for the target machine.  */\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n-  case AND:\t\t\t\t\t\t\t\t\\\n-  case IOR:\t\t\t\t\t\t\t\t\\\n-  case XOR:\t\t\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-  case NOT:\t\t\t\t\t\t\t\t\\\n-  case NEG:\t\t\t\t\t\t\t\t\\\n-  case COMPARE:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == SImode)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-    else if (GET_MODE (X) == DImode)\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (3);\t/* guess */\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == SImode)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (6);\t/* guess */\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (18);\n-\n /* A C expression for the cost of moving data from a register in class FROM to\n    one in class TO.  The classes are expressed using the enumeration values\n    such as `GENERAL_REGS'.  A value of 4 is the default; other values are"}, {"sha": "436ddb788374e3ded94d4e08465325b5224c6add", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -34,9 +34,6 @@ extern unsigned int compute_a_shift_length PARAMS ((rtx, rtx *));\n extern const char *emit_a_rotate PARAMS ((enum rtx_code, rtx *));\n extern const char *output_simode_bld PARAMS ((int, rtx[]));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern int const_costs PARAMS ((rtx, enum rtx_code, enum rtx_code));\n-extern int h8300_and_costs PARAMS ((rtx));\n-extern int h8300_shift_costs PARAMS ((rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void final_prescan_insn PARAMS ((rtx, rtx *, int));\n extern int do_movsi PARAMS ((rtx[]));"}, {"sha": "e59e87776f4ed8ede7b5fc2c2da682c47ce93170", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -69,6 +69,10 @@ static void h8300_asm_named_section PARAMS ((const char *, unsigned int));\n static void h8300_encode_label PARAMS ((tree));\n static void h8300_encode_section_info PARAMS ((tree, int));\n static const char *h8300_strip_name_encoding PARAMS ((const char *));\n+static int const_costs PARAMS ((rtx, enum rtx_code, enum rtx_code));\n+static int h8300_and_costs PARAMS ((rtx));\n+static int h8300_shift_costs PARAMS ((rtx));\n+static bool h8300_rtx_costs PARAMS ((rtx, int, int, int *));\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n@@ -113,6 +117,9 @@ const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES h8300_insert_attributes\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS h8300_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* See below where shifts are handled for explanation of this enum.  */\n@@ -1097,7 +1104,7 @@ function_arg (cum, mode, type, named)\n \f\n /* Return the cost of the rtx R with code CODE.  */\n \n-int\n+static int\n const_costs (r, c, outer_code)\n      rtx r;\n      enum rtx_code c;\n@@ -1144,7 +1151,7 @@ const_costs (r, c, outer_code)\n     }\n }\n \n-int\n+static int\n h8300_and_costs (x)\n      rtx x;\n {\n@@ -1164,7 +1171,7 @@ h8300_and_costs (x)\n   return compute_logical_op_length (GET_MODE (x), operands);\n }\n \n-int\n+static int\n h8300_shift_costs (x)\n      rtx x;\n {\n@@ -1181,6 +1188,49 @@ h8300_shift_costs (x)\n   operands[3] = x;\n   return compute_a_shift_length (NULL, operands);\n }\n+\n+static bool\n+h8300_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case AND:\n+      *total = COSTS_N_INSNS (h8300_and_costs (x));\n+      return true;\n+\n+    /* We say that MOD and DIV are so expensive because otherwise we'll\n+       generate some really horrible code for division of a power of two.  */\n+    case MOD:\n+    case DIV:\n+      *total = 60;\n+      return true;\n+\n+    case MULT:\n+      *total = 20;\n+      return true;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      *total = COSTS_N_INSNS (h8300_shift_costs (x));\n+      return true;\n+\n+    case ROTATE:\n+    case ROTATERT:\n+      if (GET_MODE (x) == HImode)\n+\t*total = 2;\n+      else\n+\t*total = 8;\n+      return true;\n+\n+    default:\n+      *total = const_costs (x, code, outer_code);\n+      return true;\n+    }\n+}\n \f\n /* Documentation for the machine specific operand escapes:\n "}, {"sha": "70e8b6601eeb1225b3c7595bc4b4622467d8a29d", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1010,39 +1010,8 @@ struct cum_arg\n #define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n   LENGTH += h8300_adjust_insn_length (INSN, LENGTH);\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define DEFAULT_RTX_COSTS(RTX, CODE, OUTER_CODE) \\\n-  return (const_costs (RTX, CODE, OUTER_CODE));\n-\n #define BRANCH_COST 0\n \n-/* We say that MOD and DIV are so cheap because otherwise we'll\n-   generate some really horrible code for division of a power of two.  */\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  */\n-\n-#define RTX_COSTS(RTX, CODE, OUTER_CODE)\t\t\\\n-  case AND:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (h8300_and_costs (RTX));\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\\\n-    return 60;\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    return 20;\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\\\n-    return COSTS_N_INSNS (h8300_shift_costs (RTX));\t\\\n-  case ROTATE:\t\t\t\t\t\t\\\n-  case ROTATERT:\t\t\t\t\t\\\n-    if (GET_MODE (RTX) == HImode) return 2;\t\t\\\n-    return 8;\n-\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status"}, {"sha": "e83fa7ad7f1fc0db26207a70d6fae4d24c328108", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -112,6 +112,7 @@ static int mvs_hash_alias PARAMS ((const char *));\n #endif\n static void i370_encode_section_info PARAMS ((tree, int));\n static void i370_internal_label PARAMS ((FILE *, const char *, unsigned long));\n+static bool i370_rtx_costs PARAMS ((rtx, int, int, int *));\n \n /* ===================================================== */\n /* defines and functions specific to the HLASM assembler */\n@@ -317,6 +318,8 @@ static const unsigned char ebcasc[256] =\n #define TARGET_ENCODE_SECTION_INFO i370_encode_section_info\n #undef TARGET_ASM_INTERNAL_LABEL\n #define  TARGET_ASM_INTERNAL_LABEL i370_internal_label\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS i370_rtx_costs\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -1613,3 +1616,35 @@ i370_internal_label (stream, prefix, labelno)\n \n   default_internal_label (stream, prefix, labelno);\n }\n+\n+static bool\n+i370_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code;\n+     int outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if ((unsigned HOST_WIDE_INT) INTVAL (x) < 0xfff)\n+\t{\n+\t  *total = 1;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = 2;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      *total = 4;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "61f296d71a5ee2eb47996a93774de0f43d49a1e4", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -901,21 +901,6 @@ enum reg_class\n \n #define FUNCTION_MODE QImode\n \n-/* Compute the cost of computing a constant rtl expression RTX whose\n-   rtx-code is CODE.  The body of this macro is a portion of a switch\n-   statement.  If the code is computed here, return it with a return\n-   statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX, CODE, OUTERCODE)\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    if ((unsigned) INTVAL (RTX) < 0xfff) return 1;\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-    return 2;\t\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    return 4;\n-\n /*   A C statement (sans semicolon) to update the integer variable COST\n      based on the relationship between INSN that is dependent on\n      DEP_INSN through the dependence LINK.  The default is to make no"}, {"sha": "0f0a3a76282de7824eef830027dbfbf35216cab0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -50,6 +50,14 @@ Boston, MA 02111-1307, USA.  */\n #define CHECK_STACK_LIMIT (-1)\n #endif\n \n+/* Return index of given mode in mult and division cost tables.  */\n+#define MODE_INDEX(mode)\t\t\t\t\t\\\n+  ((mode) == QImode ? 0\t\t\t\t\t\t\\\n+   : (mode) == HImode ? 1\t\t\t\t\t\\\n+   : (mode) == SImode ? 2\t\t\t\t\t\\\n+   : (mode) == DImode ? 3\t\t\t\t\t\\\n+   : 4)\n+\n /* Processor costs (relative to an add) */\n static const\n struct processor_costs size_cost = {\t/* costs for tunning for size */\n@@ -872,6 +880,7 @@ static int ix86_value_regno PARAMS ((enum machine_mode));\n static bool ix86_ms_bitfield_layout_p PARAMS ((tree));\n static tree ix86_handle_struct_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static int extended_reg_mentioned_1 PARAMS ((rtx *, void *));\n+static bool ix86_rtx_costs PARAMS ((rtx, int, int, int *));\n \n #if defined (DO_GLOBAL_CTORS_BODY) && defined (HAS_INIT_SECTION)\n static void ix86_svr3_asm_out_constructor PARAMS ((rtx, int));\n@@ -988,6 +997,9 @@ static enum x86_64_reg_class merge_classes PARAMS ((enum x86_64_reg_class,\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK x86_can_output_mi_thunk\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS ix86_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -14458,6 +14470,257 @@ ix86_memory_move_cost (mode, class, in)\n     }\n }\n \n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+ix86_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      if (TARGET_64BIT && !x86_64_sign_extended_value (x))\n+\t*total = 3;\n+      else if (TARGET_64BIT && !x86_64_zero_extended_value (x))\n+\t*total = 2;\n+      else if (flag_pic && SYMBOLIC_CONST (x))\n+\t*total = 1;\n+      else\n+\t*total = 0;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (mode == VOIDmode)\n+\t*total = 0;\n+      else\n+\tswitch (standard_80387_constant_p (x))\n+\t  {\n+\t  case 1: /* 0.0 */\n+\t    *total = 1;\n+\t    break;\n+\t  case 2: /* 1.0 */\n+\t    *total = 2;\n+\t    break;\n+\t  default:\n+\t    /* Start with (MEM (SYMBOL_REF)), since that's where\n+\t       it'll probably end up.  Add a penalty for size.  */\n+\t    *total = (COSTS_N_INSNS (1)\n+\t\t      + (flag_pic != 0)\n+\t\t      + (mode == SFmode ? 0 : mode == DFmode ? 1 : 2));\n+\t    break;\n+\t  }\n+      return true;\n+\n+    case ZERO_EXTEND:\n+      /* The zero extensions is often completely free on x86_64, so make\n+\t it as cheap as possible.  */\n+      if (TARGET_64BIT && mode == DImode\n+\t  && GET_MODE (XEXP (x, 0)) == SImode)\n+\t*total = 1;\n+      else if (TARGET_ZERO_EXTEND_WITH_AND)\n+\t*total = COSTS_N_INSNS (ix86_cost->add);\n+      else\n+\t*total = COSTS_N_INSNS (ix86_cost->movzx);\n+      return false;\n+\n+    case SIGN_EXTEND:\n+      *total = COSTS_N_INSNS (ix86_cost->movsx);\n+      return false;\n+\n+    case ASHIFT:\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && (GET_MODE (XEXP (x, 0)) != DImode || TARGET_64BIT))\n+\t{\n+\t  HOST_WIDE_INT value = INTVAL (XEXP (x, 1));\n+\t  if (value == 1)\n+\t    {\n+\t      *total = COSTS_N_INSNS (ix86_cost->add);\n+\t      return false;\n+\t    }\n+\t  if ((value == 2 || value == 3)\n+\t      && !TARGET_DECOMPOSE_LEA\n+\t      && ix86_cost->lea <= ix86_cost->shift_const)\n+\t    {\n+\t      *total = COSTS_N_INSNS (ix86_cost->lea);\n+\t      return false;\n+\t    }\n+\t}\n+      /* FALLTHRU */\n+\n+    case ROTATE:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case ROTATERT:\n+      if (!TARGET_64BIT && GET_MODE (XEXP (x, 0)) == DImode)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t    {\n+\t      if (INTVAL (XEXP (x, 1)) > 32)\n+\t\t*total = COSTS_N_INSNS(ix86_cost->shift_const + 2);\n+\t      else\n+\t\t*total = COSTS_N_INSNS(ix86_cost->shift_const * 2);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (GET_CODE (XEXP (x, 1)) == AND)\n+\t\t*total = COSTS_N_INSNS(ix86_cost->shift_var * 2);\n+\t      else\n+\t\t*total = COSTS_N_INSNS(ix86_cost->shift_var * 6 + 2);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t    *total = COSTS_N_INSNS (ix86_cost->shift_const);\n+\t  else\n+\t    *total = COSTS_N_INSNS (ix86_cost->shift_var);\n+\t}\n+      return false;\n+\n+    case MULT:\n+      if (FLOAT_MODE_P (mode))\n+\t*total = COSTS_N_INSNS (ix86_cost->fmul);\n+      else if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  unsigned HOST_WIDE_INT value = INTVAL (XEXP (x, 1));\n+\t  int nbits;\n+\n+\t  for (nbits = 0; value != 0; value >>= 1)\n+\t    nbits++;\n+\n+\t  *total = COSTS_N_INSNS (ix86_cost->mult_init[MODE_INDEX (mode)]\n+\t\t\t          + nbits * ix86_cost->mult_bit);\n+\t}\n+      else\n+\t{\n+\t  /* This is arbitrary */\n+\t  *total = COSTS_N_INSNS (ix86_cost->mult_init[MODE_INDEX (mode)]\n+\t\t\t          + 7 * ix86_cost->mult_bit);\n+\t}\n+      return false;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      if (FLOAT_MODE_P (mode))\n+\t*total = COSTS_N_INSNS (ix86_cost->fdiv);\n+      else\n+\t*total = COSTS_N_INSNS (ix86_cost->divide[MODE_INDEX (mode)]);\n+      return false;\n+\n+    case PLUS:\n+      if (FLOAT_MODE_P (mode))\n+\t*total = COSTS_N_INSNS (ix86_cost->fadd);\n+      else if (!TARGET_DECOMPOSE_LEA\n+\t       && GET_MODE_CLASS (mode) == MODE_INT\n+\t       && GET_MODE_BITSIZE (mode) <= GET_MODE_BITSIZE (Pmode))\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n+\t      && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n+\t      && CONSTANT_P (XEXP (x, 1)))\n+\t    {\n+\t      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1));\n+\t      if (val == 2 || val == 4 || val == 8)\n+\t\t{\n+\t\t  *total = COSTS_N_INSNS (ix86_cost->lea);\n+\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 1), outer_code);\n+\t\t  *total += rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t      outer_code);\n+\t\t  *total += rtx_cost (XEXP (x, 1), outer_code);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (XEXP (x, 0)) == MULT\n+\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\t    {\n+\t      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (x, 0), 1));\n+\t      if (val == 2 || val == 4 || val == 8)\n+\t\t{\n+\t\t  *total = COSTS_N_INSNS (ix86_cost->lea);\n+\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code);\n+\t\t  *total += rtx_cost (XEXP (x, 1), outer_code);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (XEXP (x, 0)) == PLUS)\n+\t    {\n+\t      *total = COSTS_N_INSNS (ix86_cost->lea);\n+\t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code);\n+\t      *total += rtx_cost (XEXP (XEXP (x, 0), 1), outer_code);\n+\t      *total += rtx_cost (XEXP (x, 1), outer_code);\n+\t      return true;\n+\t    }\n+\t}\n+      /* FALLTHRU */\n+\n+    case MINUS:\n+      if (FLOAT_MODE_P (mode))\n+\t{\n+\t  *total = COSTS_N_INSNS (ix86_cost->fadd);\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (!TARGET_64BIT && mode == DImode)\n+\t{\n+\t  *total = (COSTS_N_INSNS (ix86_cost->add) * 2\n+\t\t    + (rtx_cost (XEXP (x, 0), outer_code)\n+\t\t       << (GET_MODE (XEXP (x, 0)) != DImode))\n+\t\t    + (rtx_cost (XEXP (x, 1), outer_code)\n+ \t               << (GET_MODE (XEXP (x, 1)) != DImode)));\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case NEG:\n+      if (FLOAT_MODE_P (mode))\n+\t{\n+\t  *total = COSTS_N_INSNS (ix86_cost->fchs);\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+\n+    case NOT:\n+      if (!TARGET_64BIT && mode == DImode)\n+\t*total = COSTS_N_INSNS (ix86_cost->add * 2);\n+      else\n+\t*total = COSTS_N_INSNS (ix86_cost->add);\n+      return false;\n+\n+    case FLOAT_EXTEND:\n+      if (!TARGET_SSE_MATH || !VALID_SSE_REG_MODE (mode))\n+\t*total = 0;\n+      return false;\n+\n+    case ABS:\n+      if (FLOAT_MODE_P (mode))\n+\t*total = COSTS_N_INSNS (ix86_cost->fabs);\n+      return false;\n+\n+    case SQRT:\n+      if (FLOAT_MODE_P (mode))\n+\t*total = COSTS_N_INSNS (ix86_cost->fsqrt);\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n #if defined (DO_GLOBAL_CTORS_BODY) && defined (HAS_INIT_SECTION)\n static void\n ix86_svr3_asm_out_constructor (symbol, priority)"}, {"sha": "32eb8ad6f6fcec27604293c4af0b1d7a0cb8b1da", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2585,254 +2585,6 @@ do {\t\t\t\t\t\t\t\\\n    so give the MEM rtx a byte's mode.  */\n #define FUNCTION_MODE QImode\n \f\n-/* A part of a C `switch' statement that describes the relative costs\n-   of constant RTL expressions.  It must contain `case' labels for\n-   expression codes `const_int', `const', `symbol_ref', `label_ref'\n-   and `const_double'.  Each case must ultimately reach a `return'\n-   statement to return the relative cost of the use of that kind of\n-   constant value in an expression.  The cost may depend on the\n-   precise value of the constant, which is available for examination\n-   in X, and the rtx code of the expression in which it is contained,\n-   found in OUTER_CODE.\n-\n-   CODE is the expression code--redundant, since it can be obtained\n-   with `GET_CODE (X)'.  */\n-\n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    if (TARGET_64BIT && !x86_64_sign_extended_value (RTX))\t\\\n-      return 3;\t\t\t\t\t\t\t\\\n-    if (TARGET_64BIT && !x86_64_zero_extended_value (RTX))\t\\\n-      return 2;\t\t\t\t\t\t\t\\\n-    return flag_pic && SYMBOLIC_CONST (RTX) ? 1 : 0;\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    if (GET_MODE (RTX) == VOIDmode)\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\\\n-    switch (standard_80387_constant_p (RTX))\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-      case 1: /* 0.0 */\t\t\t\t\t\t\\\n-\treturn 1;\t\t\t\t\t\t\\\n-      case 2: /* 1.0 */\t\t\t\t\t\t\\\n-\treturn 2;\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\\\n-\t/* Start with (MEM (SYMBOL_REF)), since that's where\t\\\n-\t   it'll probably end up.  Add a penalty for size.  */\t\\\n-\treturn (COSTS_N_INSNS (1) + (flag_pic != 0)\t\t\\\n-\t\t+ (GET_MODE (RTX) == SFmode ? 0\t\t\t\\\n-\t\t   : GET_MODE (RTX) == DFmode ? 1 : 2));\t\\\n-      }\n-\n-/* Delete the definition here when TOPLEVEL_COSTS_N_INSNS gets added to cse.c */\n-#define TOPLEVEL_COSTS_N_INSNS(N) \\\n-  do { total = COSTS_N_INSNS (N); goto egress_rtx_costs; } while (0)\n-\n-/* Return index of given mode in mult and division cost tables.  */\n-#define MODE_INDEX(mode)\t\t\t\t\t\\\n-  ((mode) == QImode ? 0\t\t\t\t\t\t\\\n-   : (mode) == HImode ? 1\t\t\t\t\t\\\n-   : (mode) == SImode ? 2\t\t\t\t\t\\\n-   : (mode) == DImode ? 3\t\t\t\t\t\\\n-   : 4)\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n-   This can be used, for example, to indicate how costly a multiply\n-   instruction is.  In writing this macro, you can use the construct\n-   `COSTS_N_INSNS (N)' to specify a cost equal to N fast\n-   instructions.  OUTER_CODE is the code of the expression in which X\n-   is contained.\n-\n-   This macro is optional; do not define it if the default cost\n-   assumptions are adequate for the target machine.  */\n-\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n-  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n-    /* The zero extensions is often completely free on x86_64, so make\t\\\n-       it as cheap as possible.  */\t\t\t\t\t\\\n-    if (TARGET_64BIT && GET_MODE (X) == DImode\t\t\t\t\\\n-\t&& GET_MODE (XEXP (X, 0)) == SImode)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\ttotal = 1; goto egress_rtx_costs;\t\t\t\t\\\n-      } \t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (TARGET_ZERO_EXTEND_WITH_AND ?\t\t\\\n-\t\t\t      ix86_cost->add : ix86_cost->movzx);\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n-    TOPLEVEL_COSTS_N_INSNS (ix86_cost->movsx);\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-\t&& (GET_MODE (XEXP (X, 0)) != DImode || TARGET_64BIT))\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tHOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\t\\\n-\tif (value == 1)\t\t\t\t\t\t\t\\\n-\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\\\n-\tif ((value == 2 || value == 3)\t\t\t\t\t\\\n-\t    && !TARGET_DECOMPOSE_LEA\t\t\t\t\t\\\n-\t    && ix86_cost->lea <= ix86_cost->shift_const)\t\t\\\n-\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->lea);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\t\\\n-\t\t  \t\t\t\t\t\t\t\\\n-  case ROTATE:\t\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-  case ROTATERT:\t\t\t\t\t\t\t\\\n-    if (!TARGET_64BIT && GET_MODE (XEXP (X, 0)) == DImode)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (INTVAL (XEXP (X, 1)) > 32)\t\t\t\t\\\n-\t      TOPLEVEL_COSTS_N_INSNS(ix86_cost->shift_const + 2);\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      TOPLEVEL_COSTS_N_INSNS(ix86_cost->shift_const * 2);\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (X, 1)) == AND)\t\t\t\t\\\n-\t      TOPLEVEL_COSTS_N_INSNS(ix86_cost->shift_var * 2);\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      TOPLEVEL_COSTS_N_INSNS(ix86_cost->shift_var * 6 + 2);\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n-\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->shift_const);\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->shift_var);\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fmul);\t\t\t\t\\\n-    else if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tunsigned HOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\\\n-\tint nbits = 0;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\twhile (value != 0)\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    nbits++;\t\t\t\t\t\t\t\\\n-\t    value >>= 1;\t\t\t\t\t\t\\\n-\t  } \t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tTOPLEVEL_COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n-\t\t\t\t[MODE_INDEX (GET_MODE (X))]\t\t\\\n-\t\t\t        + nbits * ix86_cost->mult_bit);\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t/* This is arbitrary */\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n-\t\t\t      [MODE_INDEX (GET_MODE (X))]\t\t\\\n-\t\t\t      + 7 * ix86_cost->mult_bit);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\t\\\n-    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fdiv);\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->divide\t\t\t\t\\\n-\t\t\t      [MODE_INDEX (GET_MODE (X))]);\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fadd);\t\t\t\t\\\n-    else if (!TARGET_DECOMPOSE_LEA\t\t\t\t\t\\\n-\t&& INTEGRAL_MODE_P (GET_MODE (X))\t\t\t\t\\\n-\t&& GET_MODE_BITSIZE (GET_MODE (X)) <= GET_MODE_BITSIZE (Pmode))\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        if (GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n-\t    && GET_CODE (XEXP (XEXP (X, 0), 0)) == MULT\t\t\t\\\n-\t    && GET_CODE (XEXP (XEXP (XEXP (X, 0), 0), 1)) == CONST_INT\t\\\n-\t    && CONSTANT_P (XEXP (X, 1)))\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    HOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (X, 0), 0), 1));\\\n-\t    if (val == 2 || val == 4 || val == 8)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\treturn (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n-\t\t\t+ rtx_cost (XEXP (XEXP (X, 0), 1),\t\t\\\n-\t\t\t\t    (OUTER_CODE))\t\t\t\\\n-\t\t\t+ rtx_cost (XEXP (XEXP (XEXP (X, 0), 0), 0),\t\\\n-\t\t\t\t    (OUTER_CODE))\t\t\t\\\n-\t\t\t+ rtx_cost (XEXP (X, 1), (OUTER_CODE)));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (GET_CODE (XEXP (X, 0)) == MULT\t\t\t\t\\\n-\t\t && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    HOST_WIDE_INT val = INTVAL (XEXP (XEXP (X, 0), 1));\t\t\\\n-\t    if (val == 2 || val == 4 || val == 8)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\treturn (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n-\t\t\t+ rtx_cost (XEXP (XEXP (X, 0), 0),\t\t\\\n-\t\t\t\t    (OUTER_CODE))\t\t\t\\\n-\t\t\t+ rtx_cost (XEXP (X, 1), (OUTER_CODE)));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (GET_CODE (XEXP (X, 0)) == PLUS)\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    return (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n-\t\t    + rtx_cost (XEXP (XEXP (X, 0), 0), (OUTER_CODE))\t\\\n-\t\t    + rtx_cost (XEXP (XEXP (X, 0), 1), (OUTER_CODE))\t\\\n-\t\t    + rtx_cost (XEXP (X, 1), (OUTER_CODE)));\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n-    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fadd);\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case AND:\t\t\t\t\t\t\t\t\\\n-  case IOR:\t\t\t\t\t\t\t\t\\\n-  case XOR:\t\t\t\t\t\t\t\t\\\n-    if (!TARGET_64BIT && GET_MODE (X) == DImode)\t\t\t\\\n-      return (COSTS_N_INSNS (ix86_cost->add) * 2\t\t\t\\\n-\t      + (rtx_cost (XEXP (X, 0), (OUTER_CODE))\t\t\t\\\n-\t         << (GET_MODE (XEXP (X, 0)) != DImode))\t\t\t\\\n-\t      + (rtx_cost (XEXP (X, 1), (OUTER_CODE))\t\t\t\\\n- \t         << (GET_MODE (XEXP (X, 1)) != DImode)));\t\t\\\n-    /* fall through */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case NEG:\t\t\t\t\t\t\t\t\\\n-    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fchs);\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case NOT:\t\t\t\t\t\t\t\t\\\n-    if (!TARGET_64BIT && GET_MODE (X) == DImode)\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->add * 2);\t\t\t\\\n-    TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case FLOAT_EXTEND:\t\t\t\t\t\t\t\\\n-    if (!TARGET_SSE_MATH\t\t\t\t\t\t\\\n-\t|| !VALID_SSE_REG_MODE (GET_MODE (X)))\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (0);\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ABS:\t\t\t\t\t\t\t\t\\\n-    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fabs);\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case SQRT:\t\t\t\t\t\t\t\t\\\n-    if (FLOAT_MODE_P (GET_MODE (X)))\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->fsqrt);\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  egress_rtx_costs:\t\t\t\t\t\t\t\\\n-    break;\n-\n-\n /* An expression giving the cost of an addressing mode that contains\n    ADDRESS.  If not defined, the cost is computed from the ADDRESS\n    expression and the `CONST_COSTS' values."}, {"sha": "35b72e258118d84f6626eccdc559bec0a06a1ca2", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -50,6 +50,7 @@ static void i960_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void i960_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void i960_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t  HOST_WIDE_INT, tree));\n+static bool i960_rtx_costs PARAMS ((rtx, int, int, int *));\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -107,6 +108,9 @@ static int ret_label = 0;\n #undef TARGET_CAN_ASM_OUTPUT_MI_THUNK\n #define TARGET_CAN_ASM_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS i960_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Override conflicting target switch options.\n@@ -2856,3 +2860,52 @@ i960_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n   assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\t\n   fprintf (file, \"\\n\");\t\t\t\t\t\t\t\n }\n+\n+static bool\n+i960_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+      /* Constants that can be (non-ldconst) insn operands are cost 0.\n+\t Constants that can be non-ldconst operands in rare cases are cost 1.\n+         Other constants have higher costs.\n+\n+         Must check for OUTER_CODE of SET for power2_operand, because\n+         reload_cse_move2add calls us with OUTER_CODE of PLUS to decide\n+\t when to replace set with add.  */\n+\n+    case CONST_INT:\n+      if ((INTVAL (x) >= 0 && INTVAL (x) < 32)\n+\t  || (outer_code == SET && power2_operand (x, VOIDmode)))\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      else if (INTVAL (x) >= -31 && INTVAL (x) < 0)\n+\t{\n+\t  *total = 1;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = (TARGET_C_SERIES ? 6 : 8);\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (x == CONST0_RTX (DFmode) || x == CONST0_RTX (SFmode)\n+\t  || x == CONST1_RTX (DFmode) || x == CONST1_RTX (SFmode))\n+\t*total = 1;\n+      else\n+\t*total = 12;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "534f5254dbdc665a52a6b561c8a6f626f2845b59", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1154,36 +1154,6 @@ extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n #define\tTARGET_MEM_FUNCTIONS\t1\n #endif\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-/* Constants that can be (non-ldconst) insn operands are cost 0.  Constants\n-   that can be non-ldconst operands in rare cases are cost 1.  Other constants\n-   have higher costs.  */\n-\n-/* Must check for OUTER_CODE of SET for power2_operand, because\n-   reload_cse_move2add calls us with OUTER_CODE of PLUS to decide when\n-   to replace set with add.  */\n-\n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    if ((INTVAL (RTX) >= 0 && INTVAL (RTX) < 32)\t\t\t\\\n-\t|| (OUTER_CODE == SET && power2_operand (RTX, VOIDmode)))\t\\\n-      return 0; \t\t\t\t\t\t\t\\\n-    else if (INTVAL (RTX) >= -31 && INTVAL (RTX) < 0)\t\t\t\\\n-      return 1;\t\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-    return (TARGET_C_SERIES ? 6 : 8);\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    if ((RTX) == CONST0_RTX (DFmode) || (RTX) == CONST0_RTX (SFmode)\t\\\n-\t|| (RTX) == CONST1_RTX (DFmode) || (RTX) == CONST1_RTX (SFmode))\\\n-      return 1;\t\t\t\t\t\t\t\t\\\n-    return 12;\n-\n /* The i960 offers addressing modes which are \"as cheap as a register\".\n    See i960.c (or gcc.texinfo) for details.  */\n "}, {"sha": "9a671a9edeeed8a09dd1de57e93df873b51210bc", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -147,6 +147,7 @@ static rtx gen_fr_spill_x PARAMS ((rtx, rtx, rtx));\n static rtx gen_fr_restore_x PARAMS ((rtx, rtx, rtx));\n \n static enum machine_mode hfa_element_mode PARAMS ((tree, int));\n+static bool ia64_rtx_costs PARAMS ((rtx, int, int, int *));\n static void fix_range PARAMS ((const char *));\n static struct machine_function * ia64_init_machine_status PARAMS ((void));\n static void emit_insn_group_barriers PARAMS ((FILE *, rtx));\n@@ -314,6 +315,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS ia64_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -3972,6 +3976,85 @@ ia64_print_operand (file, x, code)\n   return;\n }\n \f\n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+/* ??? This is incomplete.  */\n+\n+static bool\n+ia64_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      switch (outer_code)\n+        {\n+        case SET:\n+\t  *total = CONST_OK_FOR_J (INTVAL (x)) ? 0 : COSTS_N_INSNS (1);\n+\t  return true;\n+        case PLUS:\n+\t  if (CONST_OK_FOR_I (INTVAL (x)))\n+\t    *total = 0;\n+\t  else if (CONST_OK_FOR_J (INTVAL (x)))\n+\t    *total = 1;\n+\t  else\n+\t    *total = COSTS_N_INSNS (1);\n+\t  return true;\n+        default:\n+\t  if (CONST_OK_FOR_K (INTVAL (x)) || CONST_OK_FOR_L (INTVAL (x)))\n+\t    *total = 0;\n+\t  else\n+\t    *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      *total = COSTS_N_INSNS (3);\n+      return true;\n+\n+    case MULT:\n+      /* For multiplies wider than HImode, we have to go to the FPU,\n+         which normally involves copies.  Plus there's the latency\n+         of the multiply itself, and the latency of the instructions to\n+         transfer integer regs to FP regs.  */\n+      /* ??? Check for FP mode.  */\n+      if (GET_MODE_SIZE (GET_MODE (x)) > 2)\n+        *total = COSTS_N_INSNS (10);\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case PLUS:\n+    case MINUS:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      /* We make divide expensive, so that divide-by-constant will be\n+         optimized to a multiply.  */\n+      *total = COSTS_N_INSNS (60);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Calculate the cost of moving data from a register in class FROM to\n    one in class TO, using MODE.  */\n "}, {"sha": "425d451b8ab66331669100d28cf12cf623fc2d08", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1673,62 +1673,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Describing Relative Costs of Operations */\n \n-/* A part of a C `switch' statement that describes the relative costs of\n-   constant RTL expressions.  */\n-\n-/* ??? This is incomplete.  */\n-\n-#define CONST_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    if ((X) == const0_rtx)\t\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    switch (OUTER_CODE)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-      case SET:\t\t\t\t\t\t\t\t\\\n-\treturn CONST_OK_FOR_J (INTVAL (X)) ? 0 : COSTS_N_INSNS (1);\t\\\n-      case PLUS:\t\t\t\t\t\t\t\\\n-\tif (CONST_OK_FOR_I (INTVAL (X)))\t\t\t\t\\\n-\t  return 0;\t\t\t\t\t\t\t\\\n-\tif (CONST_OK_FOR_J (INTVAL (X)))\t\t\t\t\\\n-\t  return 1;\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tif (CONST_OK_FOR_K (INTVAL (X)) || CONST_OK_FOR_L (INTVAL (X)))\t\\\n-\t  return 0;\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (3);\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.  */\n-\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    /* For multiplies wider than HImode, we have to go to the FPU,\t\\\n-       which normally involves copies.  Plus there's the latency\t\\\n-       of the multiply itself, and the latency of the instructions to\t\\\n-       transfer integer regs to FP regs.  */\t\t\t\t\\\n-    if (GET_MODE_SIZE (GET_MODE (X)) > 2)\t\t\t\t\\\n-      return COSTS_N_INSNS (10);\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\t\\\n-    /* We make divide expensive, so that divide-by-constant will be\t\\\n-       optimized to a multiply.  */\t\t\t\t\t\\\n-    return COSTS_N_INSNS (60);\n-\n /* An expression giving the cost of an addressing mode that contains ADDRESS.\n    If not defined, the cost is computed from the ADDRESS expression and the\n    `CONST_COSTS' values.  */"}, {"sha": "48c2c4a750e473831ea89d15625643937c5a8a3f", "filename": "gcc/config/ip2k/ip2k-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -43,7 +43,6 @@ extern int ip2k_address_cost PARAMS ((rtx));\n extern int ip2k_extra_constraint PARAMS ((rtx, int));\n extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode, rtx));\n extern int adjust_insn_length PARAMS ((rtx insn, int len));\n-extern int default_rtx_costs PARAMS ((rtx, enum rtx_code, enum rtx_code));\n extern void asm_output_char PARAMS ((FILE *, rtx));\n extern void asm_output_short PARAMS ((FILE *, rtx));\n extern void asm_output_byte PARAMS ((FILE *, int));"}, {"sha": "cb1a0952c5f7ede4300c32b25cb907cb0907de01", "filename": "gcc/config/ip2k/ip2k.c", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -78,6 +78,8 @@ static tree ip2k_handle_progmem_attribute PARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t   bool *));\n static tree ip2k_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t  bool *));\n+static bool ip2k_rtx_costs PARAMS ((rtx, int, int, int *));\n+\n const struct attribute_spec ip2k_attribute_table[];\n \n \n@@ -100,6 +102,9 @@ const struct attribute_spec ip2k_attribute_table[];\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE ip2k_attribute_table\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS ip2k_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Commands in the functions prologues in the compiled file.  */\n@@ -3273,23 +3278,34 @@ asm_file_end (file)\n \n /* Cost functions.  */\n \n-/* Calculate the cost of X code of the expression in which it is contained,\n-   found in OUTER_CODE.  */\n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n \n-int\n-default_rtx_costs (x, code, outer_code)\n+static bool\n+ip2k_rtx_costs (x, code, outer_code, total)\n      rtx x;\n-     enum rtx_code code;\n-     enum rtx_code outer_code;\n+     int code, outer_code;\n+     int *total;\n {\n   enum machine_mode mode = GET_MODE (x);\n   int extra_cost = 0;\n-  int total;\n \n   switch (code)\n     {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case LABEL_REF:\n+      *total = 0;\n+      return true;\n+    case CONST:\n+    case SYMBOL_REF:\n+      *total = 8;\n+      return true;\n+\n     case MEM:\n-      return ip2k_address_cost (XEXP (x, 0));\n+      *total = ip2k_address_cost (XEXP (x, 0));\n+      return true;\n \n     case ROTATE:\n     case ROTATERT:\n@@ -3311,45 +3327,47 @@ default_rtx_costs (x, code, outer_code)\n \t  /* Sign-preserving shifts require 2 extra instructions.  */\n \t  if (code == ASHIFT)\n             cost += COSTS_N_INSNS (2);\n-\t  return cost;\n+\n+\t  *total = cost;\n+\t  return true;\n \t}\n-      total = rtx_cost (XEXP (x, 0), code);\n-      total += COSTS_N_INSNS (GET_MODE_SIZE (mode) * 8);\n-      return total;\n+      *total = rtx_cost (XEXP (x, 0), code);\n+      *total += COSTS_N_INSNS (GET_MODE_SIZE (mode) * 8);\n+      return true;\n \n     case MINUS:\n     case PLUS:\n     case AND:\n     case XOR:\n     case IOR:\n-      total = rtx_cost (XEXP (x, 0), code)\n-\t+ rtx_cost (XEXP (x, 1), code);\n-      total += COSTS_N_INSNS (GET_MODE_SIZE (mode) * 3);\n-      return total;\n+      *total = COSTS_N_INSNS (GET_MODE_SIZE (mode) * 3);\n+      return false;\n \n     case MOD:\n     case DIV:\n       if (mode == QImode)\n-\treturn COSTS_N_INSNS (20);\n-      if (mode == HImode)\n-\treturn COSTS_N_INSNS (60);\n+\t*total = COSTS_N_INSNS (20);\n+      else if (mode == HImode)\n+\t*total = COSTS_N_INSNS (60);\n       else if (mode == SImode)\n-\treturn COSTS_N_INSNS (180);\n+\t*total = COSTS_N_INSNS (180);\n       else\n-\treturn COSTS_N_INSNS (540);\n+\t*total = COSTS_N_INSNS (540);\n+      return true;\n \n     case MULT:\n       /* These costs are OK, but should really handle subtle cases\n          where we're using sign or zero extended args as these are\n \t *much* cheaper than those given below!  */\n       if (mode == QImode)\n-\treturn COSTS_N_INSNS (4);\n-      if (mode == HImode)\n-\treturn COSTS_N_INSNS (12);\n-      if (mode == SImode)\n-\treturn COSTS_N_INSNS (36);\n+\t*total = COSTS_N_INSNS (4);\n+      else if (mode == HImode)\n+\t*total = COSTS_N_INSNS (12);\n+      else if (mode == SImode)\n+\t*total = COSTS_N_INSNS (36);\n       else\n-        return COSTS_N_INSNS (108);\n+        *total = COSTS_N_INSNS (108);\n+      return true;\n \n     case NEG:\n     case SIGN_EXTEND:\n@@ -3359,20 +3377,25 @@ default_rtx_costs (x, code, outer_code)\n     case NOT:\n     case COMPARE:\n     case ABS:\n-      total = rtx_cost (XEXP (x, 0), code);\n-      return total + extra_cost + COSTS_N_INSNS (GET_MODE_SIZE (mode) * 2);\n+      *total = extra_cost + COSTS_N_INSNS (GET_MODE_SIZE (mode) * 2);\n+      return false;\n \n     case TRUNCATE:\n     case ZERO_EXTEND:\n       if (outer_code == SET)\n-\treturn rtx_cost (XEXP (x, 0), code)\n-\t       + COSTS_N_INSNS (GET_MODE_SIZE (mode) * 3 / 2);\n+\t{\n+\t  *total = COSTS_N_INSNS (GET_MODE_SIZE (mode) * 3 / 2);\n+\t  return false;\n+\t}\n       else\n-\treturn -(COSTS_N_INSNS (GET_MODE_SIZE (mode)) / 2);\n+\t{\n+\t  *total = -(COSTS_N_INSNS (GET_MODE_SIZE (mode)) / 2);\n+\t  return true;\n+\t}\n \n     case IF_THEN_ELSE:\n-      return rtx_cost (XEXP (x, 0), code)\n-\t     + COSTS_N_INSNS (2);\n+      *total = rtx_cost (XEXP (x, 0), code) + COSTS_N_INSNS (2);\n+      return true;\n \n     case EQ:\n     case NE:\n@@ -3384,11 +3407,12 @@ default_rtx_costs (x, code, outer_code)\n     case GT:\n     case LE:\n     case GE:\n-      return rtx_cost (XEXP (x, 0), code)\n-\t     + rtx_cost (XEXP (x, 1), code);\n+      *total = 0;\n+      return false;\n \n     default:\n-      return COSTS_N_INSNS (4);\n+      *total = COSTS_N_INSNS (4);\n+      return true;\n     }\n }\n "}, {"sha": "c656e4a4becc58368d6f18b3aeeddc10901981a3", "filename": "gcc/config/ip2k/ip2k.h", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1765,44 +1765,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    is a suitable definition for this macro on machines where anything\n    `CONSTANT_P' is valid.  */\n \n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t \\\n-    return 0;\t\t\t\t \\\n-  case CONST:\t\t\t\t \\\n-    return 8;                            \\\n-  case LABEL_REF:\t\t\t \\\n-    return 0;\t\t\t\t \\\n-  case SYMBOL_REF:\t\t\t \\\n-    return 8;\t\t\t\t \\\n-  case CONST_DOUBLE:\t\t\t \\\n-    return 0;\n-\n-/* A part of a C `switch' statement that describes the relative costs\n-   of constant RTL expressions.  It must contain `case' labels for\n-   expression codes `const_int', `const', `symbol_ref', `label_ref'\n-   and `const_double'.  Each case must ultimately reach a `return'\n-   statement to return the relative cost of the use of that kind of\n-   constant value in an expression.  The cost may depend on the\n-   precise value of the constant, which is available for examination\n-   in X, and the rtx code of the expression in which it is contained,\n-   found in OUTER_CODE.\n-\n-   CODE is the expression code--redundant, since it can be obtained\n-   with `GET_CODE (X)'.  */\n-\n-#define DEFAULT_RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n-  return default_rtx_costs ((X), (CODE), (OUTER_CODE))\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n-   This can be used, for example, to indicate how costly a multiply\n-   instruction is.  In writing this macro, you can use the construct\n-   `COSTS_N_INSNS (N)' to specify a cost equal to N fast\n-   instructions.  OUTER_CODE is the code of the expression in which X\n-   is contained.\n-\n-   This macro is optional; do not define it if the default cost\n-   assumptions are adequate for the target machine.  */\n-\n #define ADDRESS_COST(ADDRESS) ip2k_address_cost (ADDRESS)\n \n /* An expression giving the cost of an addressing mode that contains"}, {"sha": "6d4f2a30e1f21550f1486ecac49f02b7294af4f7", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -80,6 +80,7 @@ static void m32r_select_section PARAMS ((tree, int, unsigned HOST_WIDE_INT));\n static void m32r_encode_section_info PARAMS ((tree, int));\n static const char *m32r_strip_name_encoding PARAMS ((const char *));\n static void init_idents PARAMS ((void));\n+static bool m32r_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -113,6 +114,9 @@ static void init_idents PARAMS ((void));\n #undef TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING m32r_strip_name_encoding\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS m32r_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Called by OVERRIDE_OPTIONS to initialize various things.  */\n@@ -1751,6 +1755,56 @@ m32r_variable_issue (stream, verbose, insn, how_many)\n \f\n /* Cost functions.  */\n \n+static bool\n+m32r_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+      /* Small integers are as cheap as registers.  4 byte values can be\n+         fetched as immediate constants - let's give that the cost of an\n+         extra insn.  */\n+    case CONST_INT:\n+      if (INT16_P (INTVAL (x)))\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      {\n+\trtx high, low;\n+\tsplit_double (x, &high, &low);\n+\t*total = COSTS_N_INSNS (!INT16_P (INTVAL (high))\n+\t\t\t        + !INT16_P (INTVAL (low)));\n+\treturn true;\n+      }\n+\n+    case MULT:\n+      *total = COSTS_N_INSNS (3);\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (10);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Provide the costs of an addressing mode that contains ADDR.\n    If ADDR is not a valid address, its cost is irrelevant.\n "}, {"sha": "22bf095f72cd1ce8370c22db707f706360739a91", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1420,36 +1420,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Costs.  */\n \n-/* ??? I'm quite sure I don't understand enough of the subtleties involved\n-   in choosing the right numbers to use here, but there doesn't seem to be\n-   enough documentation on this.  What I've done is define an insn to cost\n-   4 \"units\" and work from there.  COSTS_N_INSNS (N) is defined as (N) * 4 - 2\n-   so that seems reasonable.  Some values are supposed to be defined relative\n-   to each other and thus aren't necessarily related to COSTS_N_INSNS.  */\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-/* Small integers are as cheap as registers.  4 byte values can be fetched\n-   as immediate constants - let's give that the cost of an extra insn.  */\n-#define CONST_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n-  case CONST_INT :\t\t\t\t\t\t\\\n-    if (INT16_P (INTVAL (X)))\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\\\n-  case CONST :\t\t\t\t\t\t\t\\\n-  case LABEL_REF :\t\t\t\t\t\t\\\n-  case SYMBOL_REF :\t\t\t\t\t\t\\\n-    return 4;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE :\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      rtx high, low;\t\t\t\t\t\t\\\n-      split_double (X, &high, &low);\t\t\t\t\\\n-      return 4 * (!INT16_P (INTVAL (high))\t\t\t\\\n-\t\t  + !INT16_P (INTVAL (low)));\t\t\t\\\n-    }\n-\n /* Compute the cost of an address.  */\n #define ADDRESS_COST(ADDR) m32r_address_cost (ADDR)\n \n@@ -1469,21 +1439,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    we define this as 1.  Defining it as 2 had a heavy hit in fp-bit.c.  */\n #define BRANCH_COST ((TARGET_BRANCH_COST) ? 2 : 1)\n \n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  The purpose for the cost of MULT is to encourage\n-   `synth_mult' to find a synthetic multiply when reasonable.\n-\n-   If we need more than 12 insns to do a multiply, then go out-of-line,\n-   since the call overhead will be < 10% of the cost of the multiply.  */\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\\\n-  case MULT :\t\t\t\t\\\n-    return COSTS_N_INSNS (3);\t\t\\\n-  case DIV :\t\t\t\t\\\n-  case UDIV :\t\t\t\t\\\n-  case MOD :\t\t\t\t\\\n-  case UMOD :\t\t\t\t\\\n-    return COSTS_N_INSNS (10);\n-\n /* Nonzero if access to memory by bytes is slow and undesirable.\n    For RISC chips, it means that access to memory by bytes is no\n    better than access by words when possible, so grab a whole word"}, {"sha": "2d78bed2f00095fc8236fa2e3ab8c0123f20f025", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -89,7 +89,6 @@ extern int m68hc11_memory_move_cost PARAMS((enum machine_mode, enum reg_class,\n                                            int));\n extern int m68hc11_register_move_cost PARAMS((enum machine_mode,\n \t\t\t\t\t      enum reg_class, enum reg_class));\n-extern int m68hc11_rtx_costs PARAMS((rtx, enum rtx_code, enum rtx_code));\n extern int m68hc11_address_cost PARAMS((rtx));\n \n "}, {"sha": "0a50c4cc2e641b55b9d5903c196552cec95b6f77", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -68,6 +68,8 @@ static int register_indirect_p PARAMS((rtx, enum machine_mode, int));\n static rtx m68hc11_expand_compare PARAMS((enum rtx_code, rtx, rtx));\n static int must_parenthesize PARAMS ((rtx));\n static int m68hc11_shift_cost PARAMS ((enum machine_mode, rtx, int));\n+static int m68hc11_rtx_costs_1 PARAMS ((rtx, enum rtx_code, enum rtx_code));\n+static bool m68hc11_rtx_costs PARAMS ((rtx, int, int, int *));\n static int m68hc11_auto_inc_p PARAMS ((rtx));\n static tree m68hc11_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bool *));\n const struct attribute_spec m68hc11_attribute_table[];\n@@ -229,6 +231,9 @@ static int nb_soft_regs;\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO  m68hc11_encode_section_info\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS m68hc11_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n int\n@@ -5335,8 +5340,8 @@ m68hc11_shift_cost (mode, x, shift)\n   return total;\n }\n \n-int\n-m68hc11_rtx_costs (x, code, outer_code)\n+static int\n+m68hc11_rtx_costs_1 (x, code, outer_code)\n      rtx x;\n      enum rtx_code code;\n      enum rtx_code outer_code ATTRIBUTE_UNUSED;\n@@ -5470,6 +5475,63 @@ m68hc11_rtx_costs (x, code, outer_code)\n       return COSTS_N_INSNS (4);\n     }\n }\n+\n+static bool\n+m68hc11_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+      /* Constants are cheap.  Moving them in registers must be avoided\n+         because most instructions do not handle two register operands.  */\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+      /* Logical and arithmetic operations with a constant operand are\n+\t better because they are not supported with two registers.  */\n+      /* 'clr' is slow */\n+      if (outer_code == SET && x == const0_rtx)\n+\t /* After reload, the reload_cse pass checks the cost to change\n+\t    a SET into a PLUS.  Make const0 cheap then.  */\n+\t*total = 1 - reload_completed;\n+      else\n+\t*total = 0;\n+      return true;\n+    \n+       if (outer_code == SET)\n+\t *total = 1 - reload_completed;\n+\n+    case ROTATE:\n+    case ROTATERT:\n+    case ASHIFT:\n+    case LSHIFTRT:\n+    case ASHIFTRT:\n+    case MINUS:\n+    case PLUS:\n+    case AND:\n+    case XOR:\n+    case IOR:\n+    case UDIV:\n+    case DIV:\n+    case MOD:\n+    case MULT:\n+    case NEG:\n+    case SIGN_EXTEND:\n+    case NOT:\n+    case COMPARE:\n+    case ZERO_EXTEND:\n+    case IF_THEN_ELSE:\n+      *total = m68hc11_rtx_costs_1 (x, code, outer_code);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n \f\n \n /* print_options - called at the start of the code generation for a"}, {"sha": "8f3740cb27dac5c118c5abc9b6ce9014e3046cfc", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1391,60 +1391,8 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n #define NOTICE_UPDATE_CC(EXP, INSN) \\\n \tm68hc11_notice_update_cc ((EXP), (INSN))\n \n-/* Compute the cost of computing a constant rtl expression RTX whose rtx-code\n-   is CODE.  The body of this macro is a portion of a switch statement.  If\n-   the code is computed here, return it with a return statement.  Otherwise,\n-   break from the switch.\n-\n-   Constants are cheap.  Moving them in registers must be avoided\n-   because most instructions do not handle two register operands.  */\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\\\n- case CONST_INT:\t\t\t\t\t\t\\\n-     /* Logical and arithmetic operations with a constant  */\t\\\n-     /* operand are better because they are not supported  */\t\\\n-     /* with two registers.  */\t\t\t\t\t\\\n-     /* 'clr' is slow */\t\t\t\t\t\\\n-   if ((OUTER_CODE) == SET && (RTX) == const0_rtx)\t\t\\\n-     /* After reload, the reload_cse pass checks the cost */    \\\n-     /* to change a SET into a PLUS.  Make const0 cheap.  */    \\\n-     return 1 - reload_completed;\t\t\t\t\\\n-   else\t\t\t\t\t\t\t\t\\\n-     return 0;\t\t\t\t\t\t\t\\\n- case CONST:\t\t\t\t\t\t\t\\\n- case LABEL_REF:\t\t\t\t\t\t\\\n- case SYMBOL_REF:\t\t\t\t\t\t\\\n-   if ((OUTER_CODE) == SET)\t\t\t\t\t\\\n-      return 1 - reload_completed;\t\t\t\t\\\n-   return 0;\t\t\t\t\t\t\t\\\n- case CONST_DOUBLE:\t\t\t\t\t\t\\\n-   return 0;\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\\\n- case ROTATE:\t\t\t\t\t\t\t\\\n- case ROTATERT:\t\t\t\t\t\t\t\\\n- case ASHIFT:\t\t\t\t\t\t\t\\\n- case LSHIFTRT:\t\t\t\t\t\t\t\\\n- case ASHIFTRT:\t\t\t\t\t\t\t\\\n- case MINUS:\t\t\t\t\t\t\t\\\n- case PLUS:\t\t\t\t\t\t\t\\\n- case AND:\t\t\t\t\t\t\t\\\n- case XOR:\t\t\t\t\t\t\t\\\n- case IOR:\t\t\t\t\t\t\t\\\n- case UDIV:\t\t\t\t\t\t\t\\\n- case DIV:\t\t\t\t\t\t\t\\\n- case MOD:\t\t\t\t\t\t\t\\\n- case MULT:\t\t\t\t\t\t\t\\\n- case NEG:\t\t\t\t\t\t\t\\\n- case SIGN_EXTEND:\t\t\t\t\t\t\\\n- case NOT:\t\t\t\t\t\t\t\\\n- case COMPARE:\t\t\t\t\t\t\t\\\n- case ZERO_EXTEND:\t\t\t\t\t\t\\\n- case IF_THEN_ELSE:\t\t\t\t\t\t\\\n-   return m68hc11_rtx_costs (X, CODE, OUTER_CODE);\n-\n /* An expression giving the cost of an addressing mode that contains\n-   ADDRESS.  If not defined, the cost is computed from the ADDRESS\n-   expression and the `CONST_COSTS' values.  */\n+   ADDRESS.  */\n \n #define ADDRESS_COST(RTX) m68hc11_address_cost (RTX)\n "}, {"sha": "e0ffee80eb733e86a9083ae2272c55c6725105ae", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -48,7 +48,6 @@ extern int strict_low_part_peephole_ok PARAMS ((enum machine_mode, rtx, rtx));\n \n /* Functions from m68k.c used in macros.  */\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_int_cost PARAMS ((rtx));\n extern int standard_68881_constant_p PARAMS ((rtx));\n extern int standard_sun_fpa_constant_p PARAMS ((rtx));\n extern void print_operand_address PARAMS ((FILE *, rtx));"}, {"sha": "cb94d2329233044585c31d911c615073eb603f32", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 125, "deletions": 1, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -73,6 +73,8 @@ static void m68k_hp320_internal_label PARAMS ((FILE *, const char *, unsigned lo\n static void m68k_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t  HOST_WIDE_INT, tree));\n static int m68k_save_reg PARAMS ((unsigned int));\n+static int const_int_cost PARAMS ((rtx));\n+static bool m68k_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n \n /* Alignment to use for loops and jumps */\n@@ -139,6 +141,9 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS m68k_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -1708,7 +1713,7 @@ const_method (constant)\n   return MOVL;\n }\n \n-int\n+static int\n const_int_cost (constant)\n      rtx constant;\n {\n@@ -1730,6 +1735,125 @@ const_int_cost (constant)\n     }\n }\n \n+static bool\n+m68k_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      /* Constant zero is super cheap due to clr instruction.  */\n+      if (x == const0_rtx)\n+\t*total = 0;\n+      else\n+        *total = const_int_cost (x);\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = 3;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      /* Make 0.0 cheaper than other floating constants to\n+         encourage creating tstsf and tstdf insns.  */\n+      if (outer_code == COMPARE\n+          && (x == CONST0_RTX (SFmode) || x == CONST0_RTX (DFmode)))\n+\t*total = 4;\n+      else\n+\t*total = 5;\n+      return true;\n+\n+    /* These are vaguely right for a 68020.  */\n+    /* The costs for long multiply have been adjusted to work properly\n+       in synth_mult on the 68020, relative to an average of the time\n+       for add and the time for shift, taking away a little more because\n+       sometimes move insns are needed.  */\n+    /* div?.w is relatively cheaper on 68000 counted in COSTS_N_INSNS terms.  */\n+#define MULL_COST (TARGET_68060 ? 2 : TARGET_68040 ? 5 : 13)\n+#define MULW_COST (TARGET_68060 ? 2 : TARGET_68040 ? 3 : TARGET_68020 ? 8 : 5)\n+#define DIVW_COST (TARGET_68020 ? 27 : 12)\n+\n+    case PLUS:\n+      /* An lea costs about three times as much as a simple add.  */\n+      if (GET_MODE (x) == SImode\n+\t  && GET_CODE (XEXP (x, 1)) == REG\n+\t  && GET_CODE (XEXP (x, 0)) == MULT\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && (INTVAL (XEXP (XEXP (x, 0), 1)) == 2\n+\t      || INTVAL (XEXP (XEXP (x, 0), 1)) == 4\n+\t      || INTVAL (XEXP (XEXP (x, 0), 1)) == 8))\n+\t*total = COSTS_N_INSNS (3);\t /* lea an@(dx:l:i),am */\n+      return false;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (TARGET_68060)\n+\t{\n+          *total = COSTS_N_INSNS(1);\n+\t  return true;\n+\t}\n+      if (! TARGET_68020)\n+        {\n+\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t    {\n+\t      if (INTVAL (XEXP (x, 1)) < 16)\n+\t        *total = COSTS_N_INSNS (2) + INTVAL (XEXP (x, 1)) / 2;\n+\t      else\n+\t        /* We're using clrw + swap for these cases.  */\n+\t        *total = COSTS_N_INSNS (4) + (INTVAL (XEXP (x, 1)) - 16) / 2;\n+\t    }\n+\t  else\n+\t    *total = COSTS_N_INSNS (10); /* worst case */\n+\t  return true;\n+        }\n+      /* A shift by a big integer takes an extra instruction.  */\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && (INTVAL (XEXP (x, 1)) == 16))\n+\t{\n+\t  *total = COSTS_N_INSNS (2);\t /* clrw;swap */\n+\t  return true;\n+\t}\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && !(INTVAL (XEXP (x, 1)) > 0\n+\t       && INTVAL (XEXP (x, 1)) <= 8))\n+\t{\n+\t  *total = COSTS_N_INSNS (3);\t /* lsr #i,dn */\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case MULT:\n+      if ((GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n+\t   || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)\n+\t  && GET_MODE (x) == SImode)\n+        *total = COSTS_N_INSNS (MULW_COST);\n+      else if (GET_MODE (x) == QImode || GET_MODE (x) == HImode)\n+        *total = COSTS_N_INSNS (MULW_COST);\n+      else\n+        *total = COSTS_N_INSNS (MULL_COST);\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      if (GET_MODE (x) == QImode || GET_MODE (x) == HImode)\n+        *total = COSTS_N_INSNS (DIVW_COST);\t/* div.w */\n+      else\n+\t*total = COSTS_N_INSNS (43);\t\t/* div.l */\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n const char *\n output_move_const_into_data_reg (operands)\n      rtx *operands;"}, {"sha": "3ba717b064c24f84bc1bea7293c0debfb2139019", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1520,96 +1520,6 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n    so give the MEM rtx a byte's mode.  */\n #define FUNCTION_MODE QImode\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    /* Constant zero is super cheap due to clr instruction.  */\t\\\n-    if (RTX == const0_rtx) return 0;\t\t\t\t\\\n-    /* if ((OUTER_CODE) == SET) */\t\t\t\t\\\n-      return const_int_cost(RTX);\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 3;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    /* Make 0.0 cheaper than other floating constants to\t\\\n-       encourage creating tstsf and tstdf insns.  */\t\t\\\n-    if ((OUTER_CODE) == COMPARE\t\t\t\t\t\\\n-        && ((RTX) == CONST0_RTX (SFmode)\t\t\t\\\n-\t    || (RTX) == CONST0_RTX (DFmode)))\t\t\t\\\n-      return 4;\t\t\t\t\t\t\t\\\n-    return 5;\n-\n-/* Compute the cost of various arithmetic operations.\n-   These are vaguely right for a 68020.  */\n-/* The costs for long multiply have been adjusted to\n-   work properly in synth_mult on the 68020,\n-   relative to an average of the time for add and the time for shift,\n-   taking away a little more because sometimes move insns are needed.  */\n-/* div?.w is relatively cheaper on 68000 counted in COSTS_N_INSNS terms.  */\n-#define MULL_COST (TARGET_68060 ? 2 : TARGET_68040 ? 5 : 13)\n-#define MULW_COST (TARGET_68060 ? 2 : TARGET_68040 ? 3 : TARGET_68020 ? 8 : 5)\n-#define DIVW_COST (TARGET_68020 ? 27 : 12)\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\\\n-    /* An lea costs about three times as much as a simple add.  */  \\\n-    if (GET_MODE (X) == SImode\t\t\t\t\t\\\n-\t&& GET_CODE (XEXP (X, 1)) == REG\t\t\t\\\n-\t&& GET_CODE (XEXP (X, 0)) == MULT\t\t\t\\\n-\t&& GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\\\n-\t&& GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\\\n-\t&& (INTVAL (XEXP (XEXP (X, 0), 1)) == 2\t\t\t\\\n-\t    || INTVAL (XEXP (XEXP (X, 0), 1)) == 4\t\t\\\n-\t    || INTVAL (XEXP (XEXP (X, 0), 1)) == 8))\t\t\\\n-      return COSTS_N_INSNS (3);\t /* lea an@(dx:l:i),am */\t\\\n-    break;\t\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\\\n-    if (TARGET_68060)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS(1);\t\t\t\t\t\\\n-    if (! TARGET_68020)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (INTVAL (XEXP (X, 1)) < 16)\t\t\t\t\\\n-\t      return COSTS_N_INSNS (2) + INTVAL (XEXP (X, 1)) / 2;\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      /* We're using clrw + swap for these cases.  */\t\t\\\n-\t      return COSTS_N_INSNS (4) + (INTVAL (XEXP (X, 1)) - 16) / 2; \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (10); /* worst case */\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* A shift by a big integer takes an extra instruction.  */ \\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t&& (INTVAL (XEXP (X, 1)) == 16))\t\t\t\\\n-      return COSTS_N_INSNS (2);\t /* clrw;swap */\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t&& !(INTVAL (XEXP (X, 1)) > 0\t\t\t\t\\\n-\t     && INTVAL (XEXP (X, 1)) <= 8))\t\t\t\\\n-      return COSTS_N_INSNS (3);\t /* lsr #i,dn */\t\t\\\n-    break;\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\\\n-    if ((GET_CODE (XEXP (X, 0)) == ZERO_EXTEND\t\t\t\\\n-\t || GET_CODE (XEXP (X, 0)) == SIGN_EXTEND)\t\t\\\n-\t&& GET_MODE (X) == SImode)\t\t\t\t\\\n-      return COSTS_N_INSNS (MULW_COST);\t\t\t\t\\\n-    if (GET_MODE (X) == QImode || GET_MODE (X) == HImode)\t\\\n-      return COSTS_N_INSNS (MULW_COST);\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (MULL_COST);\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == QImode || GET_MODE (X) == HImode)\t\\\n-      return COSTS_N_INSNS (DIVW_COST); /* div.w */\t\t\\\n-    return COSTS_N_INSNS (43);\t /* div.l */\n \f\n /* Tell final.c how to eliminate redundant test instructions.  */\n "}, {"sha": "5a8f26864e8b7f5841b8f0d0c05a4ca520d2f577", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -79,6 +79,7 @@ static void m88k_encode_section_info PARAMS ((tree, int));\n #ifdef AS_BUG_DOT_LABELS\n static void m88k_internal_label PARAMS ((FILE *, const char *, unsigned long));\n #endif\n+static bool m88k_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_BYTE_OP\n@@ -111,6 +112,9 @@ static void m88k_internal_label PARAMS ((FILE *, const char *, unsigned long));\n #define  TARGET_ASM_INTERNAL_LABEL m88k_internal_label\n #endif\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS m88k_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Determine what instructions are needed to manufacture the integer VALUE\n@@ -3362,3 +3366,66 @@ m88k_internal_label (stream, prefix, labelno)\n \t   prefix, labelno, INTERNAL_ASM_OP, prefix, labelno);\n }\n #endif\n+\n+static bool\n+m88k_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    /* We assume that any 16 bit integer can easily be recreated, so we\n+       indicate 0 cost, in an attempt to get GCC not to optimize things\n+       like comparison against a constant.  */\n+    case CONST_INT:\n+      if (SMALL_INT (x))\n+        *total = 0;\n+      else if (SMALL_INTVAL (- INTVAL (x)))\n+        *total = 2;\n+      else if (classify_integer (SImode, INTVAL (x)) != m88k_oru_or)\n+        *total = 4;\n+      else\n+        *total = 7;\n+      return true;\n+\n+    case HIGH:\n+      *total = 2;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      if (flag_pic)\n+        *total = (flag_pic == 2) ? 11 : 8;\n+      else\n+\t*total = 5;\n+      return true;\n+\n+    /* The cost of CONST_DOUBLE is zero (if it can be placed in an insn, it\n+       is as good as a register; since it can't be placed in any insn, it\n+       won't do anything in cse, but it will cause expand_binop to pass the\n+       constant to the define_expands).  */\n+    case CONST_DOUBLE:\n+      *total = 0;\n+      return true;\n+\n+    case MEM:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case MULT:\n+      *total = COSTS_N_INSNS (3);\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (38);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "4001927e655926d4b41aeab54877f4821223b8ca", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1504,39 +1504,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n    state with CC_STATUS_INIT for now.  */\n #define CC_STATUS_INIT m88k_volatile_code = '\\0'\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.\n-\n-   We assume that any 16 bit integer can easily be recreated, so we\n-   indicate 0 cost, in an attempt to get GCC not to optimize things\n-   like comparison against a constant.\n-\n-   The cost of CONST_DOUBLE is zero (if it can be placed in an insn, it\n-   is as good as a register; since it can't be placed in any insn, it\n-   won't do anything in cse, but it will cause expand_binop to pass the\n-   constant to the define_expands).  */\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\\\n-  case CONST_INT:\t\t\t\t\t\\\n-    if (SMALL_INT (RTX))\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\\\n-    else if (SMALL_INTVAL (- INTVAL (RTX)))\t\t\\\n-      return 2;\t\t\t\t\t\t\\\n-    else if (classify_integer (SImode, INTVAL (RTX)) != m88k_oru_or) \\\n-      return 4;\t\t\t\t\t\t\\\n-    return 7;\t\t\t\t\t\t\\\n-  case HIGH:\t\t\t\t\t\t\\\n-    return 2;\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\\\n-    if (flag_pic)\t\t\t\t\t\\\n-      return (flag_pic == 2) ? 11 : 8;\t\t\t\\\n-    return 5;\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\\\n-    return 0;\n-\n /* Provide the costs of an addressing mode that contains ADDR.\n    If ADDR is not a valid address, its cost is irrelevant.\n    REG+REG is made slightly more expensive because it might keep\n@@ -1549,19 +1516,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n    GET_CODE (ADDR) != PLUS ? 4 :\t\t\t\\\n    (REG_P (XEXP (ADDR, 0)) && REG_P (XEXP (ADDR, 1))) ? 2 : 1)\n \n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  */\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (3);\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (38);\n-\n /* A C expressions returning the cost of moving data of MODE from a register\n    to or from memory.  This is more costly than between registers.  */\n #define MEMORY_MOVE_COST(MODE,CLASS,IN) 4"}, {"sha": "8b995811c51e94a823f7f44148d46397d6c6e4d1", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -61,9 +61,6 @@ extern int          mcore_expand_insv            \tPARAMS ((rtx *));\n extern int          mcore_modify_comparison      \tPARAMS ((RTX_CODE));\n extern void         mcore_expand_block_move      \tPARAMS ((rtx, rtx, rtx *));\n extern void         mcore_dependent_reorg        \tPARAMS ((rtx));\n-extern int          mcore_const_costs            \tPARAMS ((rtx, RTX_CODE));\n-extern int          mcore_and_cost               \tPARAMS ((rtx));\n-extern int          mcore_ior_cost               \tPARAMS ((rtx));\n extern const char * mcore_output_andn          \t\tPARAMS ((rtx, rtx *));\n extern void         mcore_print_operand_address  \tPARAMS ((FILE *, rtx));\n extern void         mcore_print_operand          \tPARAMS ((FILE *, rtx, int));"}, {"sha": "cb24e937f3ef99812fa6e14800b5aa86219bb927", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -141,6 +141,10 @@ static void\t  mcore_asm_named_section      PARAMS ((const char *,\n static void       mcore_unique_section\t       PARAMS ((tree, int));\n static void mcore_encode_section_info\t\tPARAMS ((tree, int));\n static const char *mcore_strip_name_encoding\tPARAMS ((const char *));\n+static int        mcore_const_costs            \tPARAMS ((rtx, RTX_CODE));\n+static int        mcore_and_cost               \tPARAMS ((rtx));\n+static int        mcore_ior_cost               \tPARAMS ((rtx));\n+static bool       mcore_rtx_costs\t\tPARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n@@ -164,6 +168,9 @@ static const char *mcore_strip_name_encoding\tPARAMS ((const char *));\n #undef TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING mcore_strip_name_encoding\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS mcore_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Adjust the stack and return the number of bytes taken to do it.  */\n@@ -368,7 +375,7 @@ mcore_print_operand (stream, x, code)\n \n /* What does a constant cost ?  */\n \n-int\n+static int\n mcore_const_costs (exp, code)\n      rtx exp;\n      enum rtx_code code;\n@@ -399,7 +406,7 @@ mcore_const_costs (exp, code)\n    have been relaxed.   We want to ensure that cse will cse relaxed immeds\n    out.  Otherwise we'll get bad code (multiple reloads of the same const).  */\n \n-int\n+static int\n mcore_and_cost (x)\n      rtx x;\n {\n@@ -426,7 +433,7 @@ mcore_and_cost (x)\n \n /* What does an or cost - see and_cost().  */\n \n-int\n+static int\n mcore_ior_cost (x)\n      rtx x;\n {\n@@ -451,6 +458,48 @@ mcore_ior_cost (x)\n   return 5;\n }\n \n+static bool\n+mcore_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      *total = mcore_const_costs (x, outer_code);\n+      return true;\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = 5;\n+      return true;\n+    case CONST_DOUBLE:\n+      *total = 10;\n+      return true;\n+\n+    case AND:\n+      *total = COSTS_N_INSNS (mcore_and_cost (x));\n+      return true;\n+\n+    case IOR:\n+      *total = COSTS_N_INSNS (mcore_ior_cost (x));\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+    case FLOAT:\n+    case FIX:\n+      *total = COSTS_N_INSNS (100);\n+      return true;\n+  \n+    default:\n+      return false;\n+    }\n+}\n+\n /* Check to see if a comparison against a constant can be made more efficient\n    by incrementing/decrementing the constant to get one that is more efficient\n    to load.  */"}, {"sha": "42d2d45f9745e81c60113d90b0f48ac18a8c7880", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1004,37 +1004,10 @@ extern const enum reg_class reg_class_from_letter[];\n #define Pmode          SImode\n #define FUNCTION_MODE  Pmode\n \n-/* The relative costs of various types of constants.  Note that cse.c defines\n-   REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)      \\\n-  case CONST_INT:\t\t\t\t\\\n-    return mcore_const_costs (RTX, OUTER_CODE); \\\n-  case CONST: \t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\\\n-    return 5;\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\\\n-      return 10;\n-\n /* provide the cost for an address calculation.\n    All addressing modes cost the same on the MCore.  */\n #define\tADDRESS_COST(RTX)\t1\n \n-/* Provide the cost of an rtl expression. */\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n-  case AND:                                             \\\n-    return COSTS_N_INSNS (mcore_and_cost (X));          \\\n-  case IOR:                                             \\\n-    return COSTS_N_INSNS (mcore_ior_cost (X));          \\\n-  case DIV:\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (100);\t\t\t\t\\\n-  case FLOAT:\t\t\t\t\t\t\\\n-  case FIX:\t\t\t\t\t\t\\\n-    return 100;\n-\n /* Compute extra cost of moving data between one register class\n    and another.  All register moves are cheap.  */\n #define REGISTER_MOVE_COST(MODE, SRCCLASS, DSTCLASS) 2"}, {"sha": "4dcf5248ab57f4938f146dab924b6a99931f9014", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -155,6 +155,8 @@ static void mips_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t     unsigned HOST_WIDE_INT));\n static int mips_use_dfa_pipeline_interface      PARAMS ((void));\n static void mips_encode_section_info\t\tPARAMS ((tree, int));\n+static bool mips_rtx_costs\t\t\tPARAMS ((rtx, int, int, int *));\n+\n \n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -670,6 +672,8 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n \n #undef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE mips_valid_pointer_mode\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS mips_rtx_costs\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -2986,6 +2990,337 @@ mips_move_2words (operands, insn)\n   return ret;\n }\n \f\n+static bool\n+mips_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (! TARGET_MIPS16)\n+\t{\n+\t  /* Always return 0, since we don't have different sized insns,\n+\t     hence different costs according to Richard Kenner.  */\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+\n+      if (outer_code == SET)\n+\t{\n+\t  if (INTVAL (x) >= 0 && INTVAL (x) < 0x100)\n+\t    *total = 0;\n+\t  else if ((INTVAL (x) >= 0 && INTVAL (x) < 0x10000)\n+\t\t   || (INTVAL (x) < 0 && INTVAL (x) > -0x100))\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    *total = COSTS_N_INSNS (2);\n+\t  return true;\n+\t}\n+\n+      /* A PLUS could be an address.  We don't want to force an address\n+\t to use a register, so accept any signed 16 bit value without\n+\t complaint.  */\n+      if (outer_code == PLUS\n+\t  && INTVAL (x) >= -0x8000 && INTVAL (x) < 0x8000)\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+\n+      /* A number between 1 and 8 inclusive is efficient for a shift.\n+\t Otherwise, we will need an extended instruction.  */\n+      if (outer_code == ASHIFT || outer_code == ASHIFTRT\n+\t  || outer_code == LSHIFTRT)\n+\t{\n+\t  if (INTVAL (x) >= 1 && INTVAL (x) <= 8)\n+\t    *total = 0;\n+\t  else\n+\t    *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+\n+      /* We can use cmpi for an xor with an unsigned 16 bit value.  */\n+      if (outer_code == XOR\n+\t  && INTVAL (x) >= 0 && INTVAL (x) < 0x10000)\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+\n+      /* We may be able to use slt or sltu for a comparison with a\n+\t signed 16 bit value.  (The boundary conditions aren't quite\n+\t right, but this is just a heuristic anyhow.)  */\n+      if ((outer_code == LT || outer_code == LE\n+\t   || outer_code == GE || outer_code == GT\n+\t   || outer_code == LTU || outer_code == LEU\n+\t   || outer_code == GEU || outer_code == GTU)\n+\t  && INTVAL (x) >= -0x8000 && INTVAL (x) < 0x8000)\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+\n+      /* Equality comparisons with 0 are cheap.  */\n+      if ((outer_code == EQ || outer_code == NE)\n+\t  && INTVAL (x) == 0)\n+\treturn 0;\n+\n+      /* Otherwise, work out the cost to load the value into a\n+\t register.  */\n+      if (INTVAL (x) >= 0 && INTVAL (x) < 0x100)\n+\t*total = COSTS_N_INSNS (1);\n+      else if ((INTVAL (x) >= 0 && INTVAL (x) < 0x10000)\n+\t       || (INTVAL (x) < 0 && INTVAL (x) > -0x100))\n+\t*total = COSTS_N_INSNS (2);\n+      else\n+\t*total = COSTS_N_INSNS (3);\n+      return true;\n+\n+    case LABEL_REF:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case CONST:\n+      {\n+\trtx offset = const0_rtx;\n+\trtx symref = eliminate_constant_term (XEXP (x, 0), &offset);\n+\n+\tif (TARGET_MIPS16 && mips16_gp_offset_p (x))\n+\t  {\n+\t    /* Treat this like a signed 16 bit CONST_INT.  */\n+\t    if (outer_code == PLUS)\n+\t      *total = 0;\n+\t    else if (outer_code == SET)\n+\t      *total = COSTS_N_INSNS (1);\n+\t    else\n+\t      *total = COSTS_N_INSNS (2);\n+\t    return true;\n+\t  }\n+\n+\tif (GET_CODE (symref) == LABEL_REF)\n+\t  *total = COSTS_N_INSNS (2);\n+\telse if (GET_CODE (symref) != SYMBOL_REF)\n+\t  *total = COSTS_N_INSNS (4);\n+\telse if (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)\n+\t  *total = COSTS_N_INSNS (2);\n+\telse\n+\t  *total = COSTS_N_INSNS (SYMBOL_REF_FLAG (symref) ? 1 : 2);\n+\n+\treturn true;\n+      }\n+\n+    case SYMBOL_REF:\n+      *total = COSTS_N_INSNS (SYMBOL_REF_FLAG (x) ? 1 : 2);\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      {\n+\trtx high, low;\n+\tif (TARGET_MIPS16)\n+\t  {\n+\t    *total = COSTS_N_INSNS (4);\n+\t    return true;\n+\t  }\n+\n+\tsplit_double (x, &high, &low);\n+\t*total = COSTS_N_INSNS ((high == CONST0_RTX (GET_MODE (high))\n+\t\t\t\t || low == CONST0_RTX (GET_MODE (low)))\n+\t\t\t\t? 2 : 4);\n+\treturn true;\n+      }\n+\n+    case MEM:\n+      {\n+\tint num_words = (GET_MODE_SIZE (mode) > UNITS_PER_WORD) ? 2 : 1;\n+\tif (simple_memory_operand (x, mode))\n+\t  *total = COSTS_N_INSNS (num_words);\n+\telse\n+\t  *total = COSTS_N_INSNS (2*num_words);\n+\treturn true;\n+      }\n+\n+    case FFS:\n+      *total = COSTS_N_INSNS (6);\n+      return true;\n+\n+    case NOT:\n+      *total = COSTS_N_INSNS ((mode == DImode && !TARGET_64BIT) ? 2 : 1);\n+      return true;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (mode == DImode && !TARGET_64BIT)\n+\t{\n+\t  *total = COSTS_N_INSNS (2);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (mode == DImode && !TARGET_64BIT)\n+\t{\n+\t  *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t\t\t\t  ? 4 : 12);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case ABS:\n+      if (mode == SFmode || mode == DFmode)\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t*total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    case PLUS:\n+    case MINUS:\n+      if (mode == SFmode || mode == DFmode)\n+\t{\n+\t  if (TUNE_MIPS3000 || TUNE_MIPS3900)\n+\t    *total = COSTS_N_INSNS (2);\n+\t  else if (TUNE_MIPS6000)\n+\t    *total = COSTS_N_INSNS (3);\n+\t  else\n+\t    *total = COSTS_N_INSNS (6);\n+\t  return true;\n+\t}\n+      if (mode == DImode && !TARGET_64BIT)\n+\t{\n+\t  *total = COSTS_N_INSNS (4);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case NEG:\n+      if (mode == DImode && !TARGET_64BIT)\n+\t{\n+\t  *total = 4;\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case MULT:\n+      if (mode == SFmode)\n+\t{\n+\t  if (TUNE_MIPS3000\n+\t      || TUNE_MIPS3900\n+\t      || TUNE_MIPS5000)\n+\t    *total = COSTS_N_INSNS (4);\n+\t  else if (TUNE_MIPS6000\n+\t\t   || TUNE_MIPS5400\n+\t\t   || TUNE_MIPS5500)\n+\t    *total = COSTS_N_INSNS (5);\n+\t  else\n+\t    *total = COSTS_N_INSNS (7);\n+\t  return true;\n+\t}\n+\n+      if (mode == DFmode)\n+\t{\n+\t  if (TUNE_MIPS3000\n+\t      || TUNE_MIPS3900\n+\t      || TUNE_MIPS5000)\n+\t    *total = COSTS_N_INSNS (5);\n+\t  else if (TUNE_MIPS6000\n+\t\t   || TUNE_MIPS5400\n+\t\t   || TUNE_MIPS5500)\n+\t    *total = COSTS_N_INSNS (6);\n+\t  else\n+\t    *total = COSTS_N_INSNS (8);\n+\t  return true;\n+\t}\n+\n+      if (TUNE_MIPS3000)\n+\t*total = COSTS_N_INSNS (12);\n+      else if (TUNE_MIPS3900)\n+\t*total = COSTS_N_INSNS (2);\n+      else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n+\t*total = COSTS_N_INSNS ((mode == DImode) ? 4 : 3);\n+      else if (TUNE_MIPS6000)\n+\t*total = COSTS_N_INSNS (17);\n+      else if (TUNE_MIPS5000)\n+\t*total = COSTS_N_INSNS (5);\n+      else\n+\t*total = COSTS_N_INSNS (10);\n+      return true;\n+\n+    case DIV:\n+    case MOD:\n+      if (mode == SFmode)\n+\t{\n+\t  if (TUNE_MIPS3000\n+\t      || TUNE_MIPS3900)\n+\t    *total = COSTS_N_INSNS (12);\n+\t  else if (TUNE_MIPS6000)\n+\t    *total = COSTS_N_INSNS (15);\n+\t  else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n+\t    *total = COSTS_N_INSNS (30);\n+\t  else\n+\t    *total = COSTS_N_INSNS (23);\n+\t  return true;\n+\t}\n+\n+      if (mode == DFmode)\n+\t{\n+\t  if (TUNE_MIPS3000\n+\t      || TUNE_MIPS3900)\n+\t    *total = COSTS_N_INSNS (19);\n+\t  else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n+\t    *total = COSTS_N_INSNS (59);\n+\t  else if (TUNE_MIPS6000)\n+\t    *total = COSTS_N_INSNS (16);\n+\t  else\n+\t    *total = COSTS_N_INSNS (36);\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case UDIV:\n+    case UMOD:\n+      if (TUNE_MIPS3000\n+\t  || TUNE_MIPS3900)\n+\t*total = COSTS_N_INSNS (35);\n+      else if (TUNE_MIPS6000)\n+\t*total = COSTS_N_INSNS (38);\n+      else if (TUNE_MIPS5000)\n+\t*total = COSTS_N_INSNS (36);\n+      else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n+\t*total = COSTS_N_INSNS ((mode == SImode) ? 42 : 74);\n+      else\n+\t*total = COSTS_N_INSNS (69);\n+      return true;\n+\n+    case SIGN_EXTEND:\n+      /* A sign extend from SImode to DImode in 64 bit mode is often\n+\t zero instructions, because the result can often be used\n+\t directly by another instruction; we'll call it one.  */\n+      if (TARGET_64BIT && mode == DImode\n+\t  && GET_MODE (XEXP (x, 0)) == SImode)\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case ZERO_EXTEND:\n+      if (TARGET_64BIT && mode == DImode\n+\t  && GET_MODE (XEXP (x, 0)) == SImode)\n+\t*total = COSTS_N_INSNS (2);\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Provide the costs of an addressing mode that contains ADDR.\n    If ADDR is not a valid address, its cost is irrelevant.  */\n "}, {"sha": "696aff2be2f852e057f22a3186c5a81e3125ddc3", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 310, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -3385,316 +3385,6 @@ typedef struct mips_args {\n #define FUNCTION_MODE (Pmode == DImode ? DImode : SImode)\n \n \f\n-/* A part of a C `switch' statement that describes the relative\n-   costs of constant RTL expressions.  It must contain `case'\n-   labels for expression codes `const_int', `const', `symbol_ref',\n-   `label_ref' and `const_double'.  Each case must ultimately reach\n-   a `return' statement to return the relative cost of the use of\n-   that kind of constant value in an expression.  The cost may\n-   depend on the precise value of the constant, which is available\n-   for examination in X.\n-\n-   CODE is the expression code--redundant, since it can be obtained\n-   with `GET_CODE (X)'.  */\n-\n-#define CONST_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    if (! TARGET_MIPS16)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t/* Always return 0, since we don't have different sized\t\t\\\n-\t   instructions, hence different costs according to Richard\t\\\n-\t   Kenner */\t\t\t\t\t\t\t\\\n-\treturn 0;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if ((OUTER_CODE) == SET)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (INTVAL (X) >= 0 && INTVAL (X) < 0x100)\t\t\t\\\n-\t  return 0;\t\t\t\t\t\t\t\\\n-\telse if ((INTVAL (X) >= 0 && INTVAL (X) < 0x10000)\t\t\\\n-\t\t || (INTVAL (X) < 0 && INTVAL (X) > -0x100))\t\t\\\n-\t  return COSTS_N_INSNS (1);\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* A PLUS could be an address.  We don't want to force an address\t\\\n-       to use a register, so accept any signed 16 bit value without\t\\\n-       complaint.  */\t\t\t\t\t\t\t\\\n-    if ((OUTER_CODE) == PLUS\t\t\t\t\t\t\\\n-\t&& INTVAL (X) >= -0x8000 && INTVAL (X) < 0x8000)\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    /* A number between 1 and 8 inclusive is efficient for a shift.\t\\\n-       Otherwise, we will need an extended instruction.  */\t\t\\\n-    if ((OUTER_CODE) == ASHIFT || (OUTER_CODE) == ASHIFTRT\t\t\\\n-\t|| (OUTER_CODE) == LSHIFTRT)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (INTVAL (X) >= 1 && INTVAL (X) <= 8)\t\t\t\t\\\n-\t  return 0;\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* We can use cmpi for an xor with an unsigned 16 bit value.  */\t\\\n-    if ((OUTER_CODE) == XOR\t\t\t\t\t\t\\\n-\t&& INTVAL (X) >= 0 && INTVAL (X) < 0x10000)\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    /* We may be able to use slt or sltu for a comparison with a\t\\\n-       signed 16 bit value.  (The boundary conditions aren't quite\t\\\n-       right, but this is just a heuristic anyhow.)  */\t\t\t\\\n-    if (((OUTER_CODE) == LT || (OUTER_CODE) == LE\t\t\t\\\n-\t || (OUTER_CODE) == GE || (OUTER_CODE) == GT\t\t\t\\\n-\t || (OUTER_CODE) == LTU || (OUTER_CODE) == LEU\t\t\t\\\n-\t || (OUTER_CODE) == GEU || (OUTER_CODE) == GTU)\t\t\t\\\n-\t&& INTVAL (X) >= -0x8000 && INTVAL (X) < 0x8000)\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    /* Equality comparisons with 0 are cheap.  */\t\t\t\\\n-    if (((OUTER_CODE) == EQ || (OUTER_CODE) == NE)\t\t\t\\\n-\t&& INTVAL (X) == 0)\t\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* Otherwise, work out the cost to load the value into a\t\t\\\n-       register.  */\t\t\t\t\t\t\t\\\n-    if (INTVAL (X) >= 0 && INTVAL (X) < 0x100)\t\t\t\t\\\n-      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-    else if ((INTVAL (X) >= 0 && INTVAL (X) < 0x10000)\t\t\t\\\n-\t     || (INTVAL (X) < 0 && INTVAL (X) > -0x100))\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx offset = const0_rtx;\t\t\t\t\t\t\\\n-      rtx symref = eliminate_constant_term (XEXP (X, 0), &offset);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (TARGET_MIPS16 && mips16_gp_offset_p (X))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  /* Treat this like a signed 16 bit CONST_INT.  */\t\t\\\n-\t  if ((OUTER_CODE) == PLUS)\t\t\t\t\t\\\n-\t    return 0;\t\t\t\t\t\t\t\\\n-\t  else if ((OUTER_CODE) == SET)\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (1);\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (symref) == LABEL_REF)\t\t\t\t\\\n-\treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (symref) != SYMBOL_REF)\t\t\t\t\\\n-\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* let's be paranoid....  */\t\t\t\t\t\\\n-      if (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)\t\t\\\n-\treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (SYMBOL_REF_FLAG (symref) ? 1 : 2);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (SYMBOL_REF_FLAG (X) ? 1 : 2);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx high, low;\t\t\t\t\t\t\t\\\n-      if (TARGET_MIPS16)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n-      split_double (X, &high, &low);\t\t\t\t\t\\\n-      return COSTS_N_INSNS ((high == CONST0_RTX (GET_MODE (high))\t\\\n-\t\t\t     || low == CONST0_RTX (GET_MODE (low)))\t\\\n-\t\t\t    ? 2 : 4);\t\t\t\t\t\\\n-    }\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n-   This can be used, for example, to indicate how costly a multiply\n-   instruction is.  In writing this macro, you can use the construct\n-   `COSTS_N_INSNS (N)' to specify a cost equal to N fast instructions.\n-\n-   This macro is optional; do not define it if the default cost\n-   assumptions are adequate for the target machine.\n-\n-   If -mdebugd is used, change the multiply cost to 2, so multiply by\n-   a constant isn't converted to a series of shifts.  This helps\n-   strength reduction, and also makes it easier to identify what the\n-   compiler is doing.  */\n-\n-/* ??? Fix this to be right for the R8000.  */\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int num_words = (GET_MODE_SIZE (GET_MODE (X)) > UNITS_PER_WORD) ? 2 : 1; \\\n-      if (simple_memory_operand (X, GET_MODE (X)))\t\t\t\\\n-\treturn COSTS_N_INSNS (num_words);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2*num_words);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case FFS:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (6);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case NOT:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_MODE (X) == DImode && !TARGET_64BIT) ? 2 : 1); \\\n-\t\t\t\t\t\t\t\t\t\\\n-  case AND:\t\t\t\t\t\t\t\t\\\n-  case IOR:\t\t\t\t\t\t\t\t\\\n-  case XOR:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode && !TARGET_64BIT)\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode && !TARGET_64BIT)\t\t\t\\\n-      return COSTS_N_INSNS ((GET_CODE (XEXP (X, 1)) == CONST_INT) ? 4 : 12); \\\n-\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ABS:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-      if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n-\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-      if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (TUNE_MIPS3000                                             \\\n-              || TUNE_MIPS3900)         \t\t\t\t\\\n-\t    return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-\t  else if (TUNE_MIPS6000)       \t\t\t\t\\\n-\t    return COSTS_N_INSNS (3);\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (6);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (xmode == DImode && !TARGET_64BIT)\t\t\t\t\\\n-\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case NEG:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode && !TARGET_64BIT)\t\t\t\\\n-      return 4;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-      if (xmode == SFmode)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (TUNE_MIPS3000\t\t\t\t\t\t\\\n-\t      || TUNE_MIPS3900\t\t\t\t\t\t\\\n-\t      || TUNE_MIPS5000)\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (4);\t\t\t\t\t\\\n-\t  else if (TUNE_MIPS6000                                        \\\n-\t\t   || TUNE_MIPS5400                                     \\\n-\t\t   || TUNE_MIPS5500)\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (5);\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (7);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (xmode == DFmode)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (TUNE_MIPS3000\t\t\t\t\t\t\\\n-\t      || TUNE_MIPS3900\t\t\t\t\t\t\\\n-\t      || TUNE_MIPS5000)\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (5);\t\t\t\t\t\\\n-\t  else if (TUNE_MIPS6000                                        \\\n-\t\t   || TUNE_MIPS5400                                     \\\n-\t\t   || TUNE_MIPS5500)\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (6);\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (8);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (TUNE_MIPS3000)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (12);\t\t\t\t\t\\\n-      else if (TUNE_MIPS3900)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n-     else if (TUNE_MIPS5400 || TUNE_MIPS5500)                           \\\n-        return COSTS_N_INSNS ((xmode == DImode) ? 4 : 3);               \\\n-      else if (TUNE_MIPS6000)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (17);\t\t\t\t\t\\\n-      else if (TUNE_MIPS5000)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (5);\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (10);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-      if (xmode == SFmode)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (TUNE_MIPS3000\t\t\t\t\t\t\\\n-              || TUNE_MIPS3900)\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (12);\t\t\t\t\t\\\n-\t  else if (TUNE_MIPS6000)\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (15);\t\t\t\t\t\\\n-         else if (TUNE_MIPS5400 || TUNE_MIPS5500)                       \\\n-            return COSTS_N_INSNS (30);                                  \\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (23);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (xmode == DFmode)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (TUNE_MIPS3000\t\t\t\t\t\t\\\n-              || TUNE_MIPS3900)\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (19);\t\t\t\t\t\\\n-          else if (TUNE_MIPS5400 || TUNE_MIPS5500)                      \\\n-            return COSTS_N_INSNS (59);                                  \\\n-\t  else if (TUNE_MIPS6000)\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (16);\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    return COSTS_N_INSNS (36);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\t\\\n-    if (TUNE_MIPS3000\t\t\t\t\t\t\t\\\n-        || TUNE_MIPS3900)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (35);\t\t\t\t\t\\\n-    else if (TUNE_MIPS6000)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (38);\t\t\t\t\t\\\n-    else if (TUNE_MIPS5000)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (36);\t\t\t\t\t\\\n-    else if (TUNE_MIPS5400 || TUNE_MIPS5500)                            \\\n-      return COSTS_N_INSNS ((GET_MODE (X) == SImode) ? 42 : 74);        \\\n-    else\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (69);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n-    /* A sign extend from SImode to DImode in 64 bit mode is often\t\\\n-       zero instructions, because the result can often be used\t\t\\\n-       directly by another instruction; we'll call it one.  */\t\t\\\n-    if (TARGET_64BIT && GET_MODE (X) == DImode\t\t\t\t\\\n-\t&& GET_MODE (XEXP (X, 0)) == SImode)\t\t\t\t\\\n-      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n-    if (TARGET_64BIT && GET_MODE (X) == DImode\t\t\t\t\\\n-\t&& GET_MODE (XEXP (X, 0)) == SImode)\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (1);\n-\n /* An expression giving the cost of an addressing mode that\n    contains ADDRESS.  If not defined, the cost is computed from the\n    form of the ADDRESS expression and the `CONST_COSTS' values."}, {"sha": "e6c22f093f932aae5ffd6bfc3fa4d9b8c08142c2", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -109,8 +109,6 @@ extern void mmix_setup_frame_addresses PARAMS ((void));\n /* Needs to be ifdef:d for sake of enum rtx_code.  */\n extern enum machine_mode mmix_select_cc_mode PARAMS ((enum rtx_code, rtx, rtx));\n extern void mmix_canonicalize_comparison PARAMS ((enum rtx_code *, rtx *, rtx *));\n-extern int mmix_rtx_cost_recalculated\n-  PARAMS ((rtx, enum rtx_code, enum rtx_code, int *));\n extern int mmix_valid_comparison PARAMS ((enum rtx_code, enum machine_mode, rtx));\n extern rtx mmix_gen_compare_reg PARAMS ((enum rtx_code, rtx, rtx));\n #endif"}, {"sha": "b8cc2fbd2b9e4c604199cdb688ca81794ee3bb77", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -134,6 +134,8 @@ static void mmix_target_asm_function_epilogue\n   PARAMS ((FILE *, HOST_WIDE_INT));\n static void mmix_asm_output_mi_thunk\n   PARAMS ((FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n+static bool mmix_rtx_costs\n+  PARAMS ((rtx, int, int, int *));\n \n \n /* Target structure macros.  Listed by node.  See `Using and Porting GCC'\n@@ -171,6 +173,9 @@ static void mmix_asm_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS mmix_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Functions that are expansions for target macros.\n@@ -1189,19 +1194,19 @@ mmix_reversible_cc_mode (mode)\n   return mode != CC_FPmode;\n }\n \n-/* DEFAULT_RTX_COSTS.  */\n+/* TARGET_RTX_COSTS.  */\n \n-int\n-mmix_rtx_cost_recalculated (x, code, outer_code, costp)\n+static bool\n+mmix_rtx_costs (x, code, outer_code, total)\n      rtx x ATTRIBUTE_UNUSED;\n-     RTX_CODE code ATTRIBUTE_UNUSED;\n-     RTX_CODE outer_code ATTRIBUTE_UNUSED;\n-     int *costp ATTRIBUTE_UNUSED;\n+     int code ATTRIBUTE_UNUSED;\n+     int outer_code ATTRIBUTE_UNUSED;\n+     int *total ATTRIBUTE_UNUSED;\n {\n   /* For the time being, this is just a stub and we'll accept the\n      generic calculations, until we can do measurements, at least.\n      Say we did not modify any calculated costs.  */\n-  return 0;\n+  return false;\n }\n \n /* ADDRESS_COST.  */"}, {"sha": "7549f590cdc0c28416fa309572ea8e73d7076b5d", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -881,15 +881,6 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n \n /* Node: Costs */\n \n-/* This one takes on both the RTX_COSTS and CONST_COSTS tasks.  */\n-#define DEFAULT_RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n- {\t\t\t\t\t\t\t\t\\\n-   int mmix_rtx_cost;\t\t\t\t\t\t\\\n-   if (mmix_rtx_cost_recalculated (X, CODE, OUTER_CODE, \t\\\n-\t\t\t\t   &mmix_rtx_cost))\t\t\\\n-     return mmix_rtx_cost;\t\t\t\t\t\\\n- }\n-\n #define ADDRESS_COST(ADDRESS) mmix_address_cost (ADDRESS)\n \n /* The special registers can only move to and from general regs, and we"}, {"sha": "4116c016e556345224f0de9892e4cfc3bb3ec062", "filename": "gcc/config/mn10200/mn10200.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -65,6 +65,7 @@ rtx zero_dreg;\n rtx zero_areg;\n \n static void count_tst_insns PARAMS ((int *));\n+static bool mn10200_rtx_costs PARAMS ((rtx, int, int, int *));\n \n /* Note whether or not we need an out of line epilogue.  */\n static int out_of_line_epilogue;\n@@ -73,6 +74,9 @@ static int out_of_line_epilogue;\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS mn10200_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Indicate this file was compiled by gcc and what optimization\n@@ -1600,3 +1604,59 @@ extendpsi_operand (op, mode)\n \t      && XEXP (op, 0) == stack_pointer_rtx\n \t      && general_operand (XEXP (op, 1), VOIDmode)));\n }\n+\f\n+static bool\n+mn10200_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      /* Zeros are extremely cheap.  */\n+      if (INTVAL (x) == 0)\n+\t*total = 0;\n+      /* If it fits in 8 bits, then it's still relatively cheap.  */\n+      else if (INT_8_BITS (INTVAL (x)))\n+\t*total = 1;\n+      /* This is the \"base\" cost, includes constants where either the\n+\t upper or lower 16bits are all zeros.  */\n+      else if (INT_16_BITS (INTVAL (x))\n+\t       || (INTVAL (x) & 0xffff) == 0\n+\t       || (INTVAL (x) & 0xffff0000) == 0)\n+\t*total = 2;\n+      else\n+\t*total = 4;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      /* These are more costly than a CONST_INT, but we can relax them,\n+\t so they're less costly than a CONST_DOUBLE.  */\n+      *total = 6;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      /* We don't optimize CONST_DOUBLEs well nor do we relax them well,\n+\t so their cost is very high.  */\n+      *total = 8;\n+      return true;\n+\n+   /* ??? This probably needs more work.  The definitions below were first\n+      taken from the H8 port, then tweaked slightly to improve code density\n+      on various sample codes.  */\n+    case MOD:\n+    case DIV:\n+      *total = 8;\n+      return true;\n+\n+    case MULT:\n+      *total = (GET_MODE (x) == SImode ? 20 : 8);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "58099cb5887e3f7ba1ee4277d50dbd044e9b9423", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -730,55 +730,10 @@ struct cum_arg { int nbytes; };\n    addresses generally makes code worse due to register pressure.  */\n #define NO_FUNCTION_CSE\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    /* Zeros are extremely cheap.  */\t\t\t\t\t\\\n-    if (INTVAL (RTX) == 0)\t\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    /* If it fits in 8 bits, then it's still relatively cheap.  */\t\\\n-    if (INT_8_BITS (INTVAL (RTX)))\t\t\t\t\t\\\n-      return 1;\t\t\t\t\t\t\t\t\\\n-    /* This is the \"base\" cost, includes constants where either the\t\\\n-       upper or lower 16bits are all zeros.  */\t\t\t\t\\\n-    if (INT_16_BITS (INTVAL (RTX))\t\t\t\t\t\\\n-\t|| (INTVAL (RTX) & 0xffff) == 0\t\t\t\t\t\\\n-\t|| (INTVAL (RTX) & 0xffff0000) == 0)\t\t\t\t\\\n-      return 2;\t\t\t\t\t\t\t\t\\\n-    return 4;\t\t\t\t\t\t\t\t\\\n-  /* These are more costly than a CONST_INT, but we can relax them,\t\\\n-     so they're less costly than a CONST_DOUBLE.  */\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-    return 6;\t\t\t\t\t\t\t\t\\\n-  /* We don't optimize CONST_DOUBLEs well nor do we relax them well,\t\\\n-     so their cost is very high.  */\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    return 8;\n-\n /* Make moves between different classes more expensive than moves\n    within the same class.  */\n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)  (CLASS1 != CLASS2 ? 4 : 2)\n \n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE. \n-\n-   ?!? This probably needs more work.  The definitions below were first\n-   taken from the H8 port, then tweaked slightly to improve code density\n-   on various sample codes.  */\n-\n-#define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case MOD:\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\\\n-    return 8;\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    return (GET_MODE (RTX) == SImode ? 20 : 8);\n-\n /* Nonzero if access to memory by bytes or half words is no faster\n    than accessing full words.  */\n #define SLOW_BYTE_ACCESS 1"}, {"sha": "7f524ae134c06cd2c07a980c85587b97b09505e5", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -53,11 +53,18 @@ Boston, MA 02111-1307, USA.  */\n \t\t\t+ 4 * regs_ever_live[7] \\\n \t\t\t+ 16 * (regs_ever_live[14] || regs_ever_live[15] \\\n \t\t\t\t|| regs_ever_live[16] || regs_ever_live[17]))\n+\n+\n+static bool mn10300_rtx_costs PARAMS ((rtx, int, int, int *));\n+\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS mn10300_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n@@ -1324,3 +1331,54 @@ mn10300_address_cost (x, unsig)\n \n     }\n }\n+\n+static bool\n+mn10300_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      /* Zeros are extremely cheap.  */\n+      if (INTVAL (x) == 0 && outer_code == SET)\n+\t*total = 0;\n+      /* If it fits in 8 bits, then it's still relatively cheap.  */\n+      else if (INT_8_BITS (INTVAL (x)))\n+\t*total = 1;\n+      /* This is the \"base\" cost, includes constants where either the\n+\t upper or lower 16bits are all zeros.  */\n+      else if (INT_16_BITS (INTVAL (x))\n+\t       || (INTVAL (x) & 0xffff) == 0\n+\t       || (INTVAL (x) & 0xffff0000) == 0)\n+\t*total = 2;\n+      else\n+\t*total = 4;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      /* These are more costly than a CONST_INT, but we can relax them,\n+\t so they're less costly than a CONST_DOUBLE.  */\n+      *total = 6;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      /* We don't optimize CONST_DOUBLEs well nor do we relax them well,\n+\t so their cost is very high.  */\n+      *total = 8;\n+      return true;\n+\n+   /* ??? This probably needs more work.  */\n+    case MOD:\n+    case DIV:\n+    case MULT:\n+      *total = 8;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "67dc1ebee3f8f3c2febfba6f0f8cc14f5bc7674c", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -800,37 +800,6 @@ struct cum_arg {int nbytes; };\n #define CC_NO_CARRY CC_NO_OVERFLOW\n #define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    /* Zeros are extremely cheap.  */\t\t\t\t\t\\\n-    if (INTVAL (RTX) == 0 && OUTER_CODE == SET)\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    /* If it fits in 8 bits, then it's still relatively cheap.  */\t\\\n-    if (INT_8_BITS (INTVAL (RTX)))\t\t\t\t\t\\\n-      return 1;\t\t\t\t\t\t\t\t\\\n-    /* This is the \"base\" cost, includes constants where either the\t\\\n-       upper or lower 16bits are all zeros.  */\t\t\t\t\\\n-    if (INT_16_BITS (INTVAL (RTX))\t\t\t\t\t\\\n-\t|| (INTVAL (RTX) & 0xffff) == 0\t\t\t\t\t\\\n-\t|| (INTVAL (RTX) & 0xffff0000) == 0)\t\t\t\t\\\n-      return 2;\t\t\t\t\t\t\t\t\\\n-    return 4;\t\t\t\t\t\t\t\t\\\n-  /* These are more costly than a CONST_INT, but we can relax them,\t\\\n-     so they're less costly than a CONST_DOUBLE.  */\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-    return 6;\t\t\t\t\t\t\t\t\\\n-  /* We don't optimize CONST_DOUBLEs well nor do we relax them well,\t\\\n-     so their cost is very high.  */\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    return 8;\n-\n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n   ((CLASS1 == CLASS2 && (CLASS1 == ADDRESS_REGS || CLASS1 == DATA_REGS)) ? 2 :\\\n    ((CLASS1 == ADDRESS_REGS || CLASS1 == DATA_REGS) && \\\n@@ -845,19 +814,6 @@ struct cum_arg {int nbytes; };\n \n #define ADDRESS_COST(X) mn10300_address_cost((X), 0)\n \n-/* A crude cut at RTX_COSTS for the MN10300.  */\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  */\n-#define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case UMOD:\t\t\\\n-  case UDIV:\t\t\\\n-  case MOD:\t\t\\\n-  case DIV:\t\t\\\n-    return 8;\t\t\\\n-  case MULT:\t\t\\\n-    return 8;\n-\n /* Nonzero if access to memory by bytes or half words is no faster\n    than accessing full words.  */\n #define SLOW_BYTE_ACCESS 1"}, {"sha": "58650c4c924bdd9f05599b2ea59da7d20e2639d2", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -72,6 +72,7 @@ const struct attribute_spec ns32k_attribute_table[];\n static void ns32k_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ns32k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ns32k_encode_section_info PARAMS ((tree, int));\n+static bool ns32k_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -92,6 +93,9 @@ static void ns32k_encode_section_info PARAMS ((tree, int));\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO ns32k_encode_section_info\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS ns32k_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Generate the assembly code for function entry.  FILE is a stdio\n@@ -490,6 +494,38 @@ hard_regno_mode_ok (regno, mode)\n   return 0;\n }\n \n+static bool\n+ns32k_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (INTVAL (x) <= 7 && INTVAL (x) >= -8)\n+\t*total = 0;\n+      else if (INTVAL (x) < 0x2000 && INTVAL (x) >= -0x2000)\n+        *total = 1;\n+      else\n+\t*total = 3;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = 3;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      *total = 5;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n int register_move_cost (CLASS1, CLASS2)\n      enum reg_class CLASS1;\n      enum reg_class CLASS2;"}, {"sha": "36c23f2640f92f591684b98740885aead78b5689", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1166,22 +1166,6 @@ __transfer_from_trampoline ()\t\t\\\n \n #define ADDRESS_COST(RTX) calc_address_cost (RTX)\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (INTVAL (RTX) <= 7 && INTVAL (RTX) >= -8) return 0;\t\\\n-    if (INTVAL (RTX) < 0x2000 && INTVAL (RTX) >= -0x2000)\t\\\n-      return 1;\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 3;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 5;\n \f\n /* Tell final.c how to eliminate redundant test instructions.  */\n "}, {"sha": "9b2f98ef041e4e9eaee28c8834a445bbd0d89120", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -97,6 +97,7 @@ hppa_fpstore_bypass_p (out_insn, in_insn)\n #endif\n #endif\n \n+static bool hppa_rtx_costs PARAMS ((rtx, int, int, int *));\n static inline rtx force_mode PARAMS ((enum machine_mode, rtx));\n static void pa_combine_instructions PARAMS ((rtx));\n static int pa_can_combine_p PARAMS ((rtx, rtx, rtx, int, rtx, rtx, rtx));\n@@ -220,6 +221,9 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_ASM_DESTRUCTOR pa_asm_out_destructor\n #endif\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS hppa_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n@@ -1315,6 +1319,87 @@ hppa_address_cost (X)\n   return 4;\n }\n \n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+hppa_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (INTVAL (x) == 0)\n+\t*total = 0;\n+      else if (INT_14_BITS (x))\n+\t*total = 1;\n+      else\n+\t*total = 2;\n+      return true;\n+\n+    case HIGH:\n+      *total = 2;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = 4;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if ((x == CONST0_RTX (DFmode) || x == CONST0_RTX (SFmode))\n+\t  && outer_code != SET)\n+\t*total = 0;\n+      else\n+        *total = 8;\n+      return true;\n+\n+    case MULT:\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+        *total = COSTS_N_INSNS (3);\n+      else if (TARGET_PA_11 && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT)\n+\t*total = COSTS_N_INSNS (8);\n+      else\n+\t*total = COSTS_N_INSNS (20);\n+      return true;\n+\n+    case DIV:\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+\t{\n+\t  *total = COSTS_N_INSNS (14);\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (60);\n+      return true;\n+\n+    case PLUS: /* this includes shNadd insns */\n+    case MINUS:\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+\t*total = COSTS_N_INSNS (3);\n+      else\n+        *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Ensure mode of ORIG, a REG rtx, is MODE.  Returns either ORIG or a\n    new rtx with the correct mode.  */\n static inline rtx"}, {"sha": "8be8d88e3a0d3f74b163bee88f0b928ab39c4d5a", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1595,28 +1595,6 @@ do { \t\t\t\t\t\t\t\t\t\\\n    few bits.  */\n #define SHIFT_COUNT_TRUNCATED 1\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    if (INTVAL (RTX) == 0) return 0;\t\t\t\t\t\\\n-    if (INT_14_BITS (RTX)) return 1;\t\t\t\t\t\\\n-  case HIGH:\t\t\t\t\t\t\t\t\\\n-    return 2;\t\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-    return 4;\t\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    if ((RTX == CONST0_RTX (DFmode) || RTX == CONST0_RTX (SFmode))\t\\\n-\t&& OUTER_CODE != SET)\t\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      return 8;\n-\n #define ADDRESS_COST(RTX) \\\n   (GET_CODE (RTX) == REG ? 1 : hppa_address_cost (RTX))\n \n@@ -1636,34 +1614,6 @@ do { \t\t\t\t\t\t\t\t\t\\\n   : FP_REG_CLASS_P (CLASS2) && ! FP_REG_CLASS_P (CLASS1) ? 16\t\\\n   : 2)\n \n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  The purpose for the cost of MULT is to encourage\n-   `synth_mult' to find a synthetic multiply when reasonable.  */\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\t\t\\\n-      return COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n-    return (TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT) \\\n-\t    ? COSTS_N_INSNS (8) : COSTS_N_INSNS (20);\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\t\t\\\n-      return COSTS_N_INSNS (14);\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (60);\t\t\t\t\t\t\\\n-  case PLUS: /* this includes shNadd insns */\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\t\t\\\n-      return COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\n-\n /* Adjust the cost of branches.  */\n #define BRANCH_COST (pa_cpu == PROCESSOR_8000 ? 2 : 1)\n "}, {"sha": "231509651515be0403ff8f49819912c749ab4bcd", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -59,6 +59,7 @@ static const char *singlemove_string PARAMS ((rtx *));\n static bool pdp11_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void pdp11_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void pdp11_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+static bool pdp11_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_BYTE_OP\n@@ -80,6 +81,9 @@ static void pdp11_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n #undef TARGET_ASM_CLOSE_PAREN\n #define TARGET_ASM_CLOSE_PAREN \"]\"\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS pdp11_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Nonzero if OP is a valid second operand for an arithmetic insn.  */\n@@ -1015,6 +1019,116 @@ register_move_cost(c1, c2)\n     return move_costs[(int)c1][(int)c2];\n }\n \n+static bool\n+pdp11_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (INTVAL (x) == 0 || INTVAL (x) == -1 || INTVAL (x) == 1)\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      /* Twice as expensive as REG.  */\n+      *total = 2;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      /* Twice (or 4 times) as expensive as 16 bit.  */\n+      *total = 4;\n+      return true;\n+\n+    case MULT:\n+      /* ??? There is something wrong in MULT because MULT is not \n+         as cheap as total = 2 even if we can shift!  */\n+      /* If optimizing for size make mult etc cheap, but not 1, so when \n+         in doubt the faster insn is chosen.  */\n+      if (optimize_size)\n+        *total = COSTS_N_INSNS (2);\n+      else\n+        *total = COSTS_N_INSNS (11);\n+      return false;\n+\n+    case DIV:\n+      if (optimize_size)\n+        *total = COSTS_N_INSNS (2);\n+      else\n+        *total = COSTS_N_INSNS (25);\n+      return false;\n+\n+    case MOD:\n+      if (optimize_size)\n+        *total = COSTS_N_INSNS (2);\n+      else\n+        *total = COSTS_N_INSNS (26);\n+      return false;\n+\n+    case ABS:\n+      /* Equivalent to length, so same for optimize_size.  */\n+      *total = COSTS_N_INSNS (3);\n+      return false;\n+\n+    case ZERO_EXTEND:\n+      /* Only used for qi->hi.  */\n+      *total = COSTS_N_INSNS (1);\n+      return false;\n+\n+    case SIGN_EXTEND:\n+      if (GET_MODE (x) == HImode)\n+      \t*total = COSTS_N_INSNS (1);\n+      else if (GET_MODE (x) == SImode)\n+\t*total = COSTS_N_INSNS (6);\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return false;\n+\n+    case ASHIFT:\n+    case LSHIFTRT:\n+    case ASHIFTRT:\n+      if (optimize_size)\n+        *total = COSTS_N_INSNS (1);\n+      else if (GET_MODE (x) ==  QImode)\n+        {\n+          if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+   \t    *total = COSTS_N_INSNS (8); /* worst case */\n+          else\n+\t    *total = COSTS_N_INSNS (INTVAL (XEXP (x, 1)));\n+        }\n+      else if (GET_MODE (x) == HImode)\n+        {\n+          if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+            {\n+\t      if (abs (INTVAL (XEXP (x, 1))) == 1)\n+                *total = COSTS_N_INSNS (1);\n+              else\n+\t        *total = COSTS_N_INSNS (2.5 + 0.5 * INTVAL (XEXP (x, 1)));\n+            }\n+          else\n+            *total = COSTS_N_INSNS (10); /* worst case */\n+        }\n+      else if (GET_MODE (x) == SImode)\n+        {\n+          if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t    *total = COSTS_N_INSNS (2.5 + 0.5 * INTVAL (XEXP (x, 1)));\n+          else /* worst case */\n+            *total = COSTS_N_INSNS (18);\n+        }\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n const char *\n output_jump(pos, neg, length)\n   const char *pos, *neg;"}, {"sha": "147b6ba67ce9c7efe31990f41d4f9e052c420ee9", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -934,28 +934,6 @@ extern int may_call_alloca;\n    but a CALL with constant address is cheap.  */\n /* #define NO_FUNCTION_CSE */\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch. \n-\n-   -1, 0, 1 are cheaper for add, sub ... \n-*/\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (INTVAL(RTX) == 0\t\t\t\t\t\\\n-\t|| INTVAL(RTX) == -1\t\t\t\t\t\\\n-\t|| INTVAL(RTX) == 1)\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    /* twice as expensive as REG */\t\t\t\t\\\n-    return 2;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    /* twice (or 4 times) as expensive as 16 bit */\t\t\\\n-    return 4;\n \f\n /* cost of moving one register class to another */\n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n@@ -1212,89 +1190,6 @@ JMP\tFUNCTION\t0x0058  0x0000 <- FUNCTION\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE. \n-\n-   we don't say how expensive SImode is - pretty expensive!!!\n-\n-   there is something wrong in MULT because MULT is not \n-   as cheap as total = 2 even if we can shift!\n-\n-   if optimizing for size make mult etc cheap, but not 1, so when \n-   in doubt the faster insn is chosen.\n-*/\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE) \\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    if (optimize_size)\t\t\t\t\t\t\t\\\n-      total = COSTS_N_INSNS(2);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      total = COSTS_N_INSNS (11);\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-    if (optimize_size)\t\t\t\t\t\t\t\\\n-      total = COSTS_N_INSNS(2);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      total = COSTS_N_INSNS (25);\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-    if (optimize_size)\t\t\t\t\t\t\t\\\n-      total = COSTS_N_INSNS(2);\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      total = COSTS_N_INSNS (26);\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case ABS:\t\t\t\t\t\t\t\t\\\n-    /* equivalent to length, so same for optimize_size */\t\t\\\n-    total = COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n-    /* only used for: qi->hi */\t\t\t\t\t\t\\\n-    total = COSTS_N_INSNS(1);\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n-    if (GET_MODE(X) == HImode)\t\t\t\t\t\t\\\n-      \ttotal = COSTS_N_INSNS(1);\t\t\t\t\t\\\n-    else if (GET_MODE(X) == SImode)\t\t\t\t\t\\\n-\ttotal = COSTS_N_INSNS(6);\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-\ttotal = COSTS_N_INSNS(2);\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  /* case LSHIFT: */\t\t       \t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-    if (optimize_size)\t\t\t\t\t\t\t\\\n-      total = COSTS_N_INSNS(1);\t\t\t\t\t\t\\\n-    else if (GET_MODE(X) ==  QImode)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE(XEXP (X,1)) != CONST_INT)\t\t\t\t\\\n-   \ttotal = COSTS_N_INSNS(8); /* worst case */ \t\t\t\\\n-      else                                                              \\\n-\ttotal = COSTS_N_INSNS(INTVAL(XEXP (X,1)));\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    else if (GET_MODE(X) == HImode)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE(XEXP (X,1)) == CONST_INT)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (abs (INTVAL (XEXP (X, 1))) == 1)\t\t\t\t\\\n-          total = COSTS_N_INSNS(1);\t\t\t\t\t\\\n-        else\t\t\t\t\t\t\t\t\\\n-\t  total = COSTS_N_INSNS(2.5 + 0.5 *INTVAL(XEXP(X,1)));\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-      else /* worst case */\t\t\t\t\t\t\\\n-        total = COSTS_N_INSNS (10);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    else if (GET_MODE(X) == SImode)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE(XEXP (X,1)) == CONST_INT)\t\t\t\t\\\n-\t  total = COSTS_N_INSNS(2.5 + 0.5 *INTVAL(XEXP(X,1)));\t\t\\\n-      else /* worst case */\t\t\t\t\t\t\\\n-        total = COSTS_N_INSNS(18);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    break;\n-\n-\n /* there is no point in avoiding branches on a pdp, \n    since branches are really cheap - I just want to find out\n    how much difference the BRANCH_COST macro makes in code */"}, {"sha": "36e8b54b1607e56bf3f970397c137be1881a351a", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -59,6 +59,7 @@ static void romp_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void romp_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t     unsigned HOST_WIDE_INT));\n static void romp_encode_section_info PARAMS ((tree, int));\n+static bool romp_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n@@ -69,6 +70,8 @@ static void romp_encode_section_info PARAMS ((tree, int));\n #define TARGET_ASM_SELECT_RTX_SECTION romp_select_rtx_section\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO romp_encode_section_info\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS romp_rtx_costs\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -2099,3 +2102,66 @@ romp_encode_section_info (decl, first)\n   if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)\n     SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n }\n+\n+static bool\n+romp_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (x)\n+    {\n+    case CONST_INT:\n+      if ((outer_code == IOR && exact_log2 (INTVAL (x)) >= 0)\n+\t  || (outer_code == AND && exact_log2 (~INTVAL (x)) >= 0)\n+\t  || ((outer_code == PLUS || outer_code == MINUS)\n+\t      && (unsigned HOST_WIDE_INT) (INTVAL (x) + 15) < 31)\n+\t  || (outer_code == SET && (unsigned HOST_WIDE_INT) INTVAL (x) < 16))\n+\t*total = 0;\n+      else if ((unsigned HOST_WIDE_INT) (INTVAL (x) + 0x8000) < 0x10000\n+\t       || (INTVAL (x) & 0xffff0000) == 0)\n+\t*total = 0;\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      if (current_function_operand (x, Pmode))\n+\t*total = 0;\n+      else\n+        *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (x == CONST0_RTX (GET_MODE (x)))\n+\t*total = 2;\n+      else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+\t*total = COSTS_N_INSNS (5)\n+      else\n+\t*total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    case MEM:\n+      *total = current_function_operand (x, Pmode) ? 0 : COSTS_N_INSNS (2);\n+      return true;\n+\n+    case MULT:\n+      if (TARGET_IN_LINE_MUL && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)\n+\t*total = COSTS_N_INSNS (19);\n+      else\n+\t*total = COSTS_N_INSNS (25);\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (45);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "16b543dfa80249c7d168efd46c53186c5e696f1e", "filename": "gcc/config/romp/romp.h", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1162,50 +1162,6 @@ struct rt_cargs {int gregs, fregs; };\n \n /* #define SHIFT_COUNT_TRUNCATED */\n \n-/* Compute the cost of computing a constant rtl expression RTX whose\n-   rtx-code is CODE, contained within an expression of code OUTER_CODE.\n-   The body of this macro is a portion of a switch statement.  If the\n-   code is computed here, return it with a return statement.  Otherwise,\n-   break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (((OUTER_CODE) == IOR && exact_log2 (INTVAL (RTX)) >= 0)\t\\\n-\t|| ((OUTER_CODE) == AND && exact_log2 (~INTVAL (RTX)) >= 0) \\\n-\t|| (((OUTER_CODE) == PLUS || (OUTER_CODE) == MINUS)\t\\\n-\t    && (unsigned int) (INTVAL (RTX) + 15) < 31)\t\t\\\n-\t|| ((OUTER_CODE) == SET && (unsigned int) INTVAL (RTX) < 16))\\\n-      return 0;\t\t\t\t\t\t\t\\\n-    return ((unsigned int) (INTVAL(RTX) + 0x8000) < 0x10000\t\t\\\n-\t    || (INTVAL (RTX) & 0xffff0000) == 0) ? 0 : COSTS_N_INSNS (2);\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    if (current_function_operand (RTX, Pmode)) return 0;\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    if ((RTX) == CONST0_RTX (GET_MODE (RTX))) return 2;\t\t\\\n-    return ((GET_MODE_CLASS (GET_MODE (RTX)) == MODE_FLOAT)\t\\\n-\t    ? COSTS_N_INSNS (5) : COSTS_N_INSNS (4));\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE. \n-\n-   References to our own data area are really references to r14, so they\n-   are very cheap.  Multiples and divides are very expensive.  */\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\\\n-    return current_function_operand (X, Pmode) ? 0 : COSTS_N_INSNS (2);\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    return (TARGET_IN_LINE_MUL && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)\\\n-\t   ? COSTS_N_INSNS (19) : COSTS_N_INSNS (25);\t\\\n-  case DIV:\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (45);\n-\n /* Compute the cost of an address.  This is meant to approximate the size\n    and/or execution delay of an insn using that address.  If the cost is\n    approximated by the RTL complexity, including CONST_COSTS above, as"}, {"sha": "69fda814afbd410e1454adba6bb19f3e8e3045fc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -227,6 +227,7 @@ static unsigned int rs6000_xcoff_section_type_flags PARAMS ((tree, const char *,\n static void rs6000_xcoff_encode_section_info PARAMS ((tree, int))\n      ATTRIBUTE_UNUSED;\n static bool rs6000_binds_local_p PARAMS ((tree));\n+static bool rs6000_rtx_costs PARAMS ((rtx, int, int, int *));\n static int rs6000_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int rs6000_adjust_priority PARAMS ((rtx, int));\n static int rs6000_issue_rate PARAMS ((void));\n@@ -404,6 +405,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL rs6000_function_ok_for_sibcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS rs6000_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Override command line options.  Mostly we process the processor\n@@ -13230,6 +13234,210 @@ rs6000_binds_local_p (decl)\n   return default_binds_local_p_1 (decl, flag_pic || rs6000_flag_pic);\n }\n \n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+rs6000_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+      /* On the RS/6000, if it is valid in the insn, it is free.\n+\t So this always returns 0.  */\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+    case HIGH:\n+      *total = 0;\n+      return true;\n+\n+    case PLUS:\n+      *total = ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1))\n+\t\t\t\t\t       + 0x8000) >= 0x10000)\n+\t\t && ((INTVAL (XEXP (x, 1)) & 0xffff) != 0))\n+\t\t? COSTS_N_INSNS (2)\n+\t\t: COSTS_N_INSNS (1));\n+      return true;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      *total = ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t && (INTVAL (XEXP (x, 1)) & (~ (HOST_WIDE_INT) 0xffff)) != 0\n+\t\t && ((INTVAL (XEXP (x, 1)) & 0xffff) != 0))\n+\t\t? COSTS_N_INSNS (2)\n+\t\t: COSTS_N_INSNS (1));\n+      return true;\n+\n+    case MULT:\n+      if (optimize_size)\n+\t{\n+\t  *total = COSTS_N_INSNS (2);\n+\t  return true;\n+\t}\n+      switch (rs6000_cpu)\n+\t{\n+\tcase PROCESSOR_RIOS1:\n+\tcase PROCESSOR_PPC405:\n+\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t\t    ? COSTS_N_INSNS (5)\n+\t\t    : (INTVAL (XEXP (x, 1)) >= -256\n+\t\t       && INTVAL (XEXP (x, 1)) <= 255)\n+\t\t    ? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\n+\t  return true;\n+\n+\tcase PROCESSOR_RS64A:\n+\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t\t    ? GET_MODE (XEXP (x, 1)) != DImode\n+\t\t    ? COSTS_N_INSNS (20) : COSTS_N_INSNS (34)\n+\t\t    : (INTVAL (XEXP (x, 1)) >= -256\n+\t\t       && INTVAL (XEXP (x, 1)) <= 255)\n+\t\t    ? COSTS_N_INSNS (8) : COSTS_N_INSNS (12));\n+\t  return true;\n+\n+\tcase PROCESSOR_RIOS2:\n+\tcase PROCESSOR_MPCCORE:\n+\tcase PROCESSOR_PPC604e:\n+\t  *total = COSTS_N_INSNS (2);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC601:\n+\t  *total = COSTS_N_INSNS (5);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC603:\n+\tcase PROCESSOR_PPC7400:\n+\tcase PROCESSOR_PPC750:\n+\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t\t    ? COSTS_N_INSNS (5)\n+\t\t    : (INTVAL (XEXP (x, 1)) >= -256\n+\t\t       && INTVAL (XEXP (x, 1)) <= 255)\n+\t\t    ? COSTS_N_INSNS (2) : COSTS_N_INSNS (3));\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC7450:\n+\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t\t    ? COSTS_N_INSNS (4)\n+\t\t    : COSTS_N_INSNS (3));\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC403:\n+\tcase PROCESSOR_PPC604:\n+\tcase PROCESSOR_PPC8540:\n+\t  *total = COSTS_N_INSNS (4);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC620:\n+\tcase PROCESSOR_PPC630:\n+\tcase PROCESSOR_POWER4:\n+\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t\t    ? GET_MODE (XEXP (x, 1)) != DImode\n+\t\t    ? COSTS_N_INSNS (5) : COSTS_N_INSNS (7)\n+\t\t    : (INTVAL (XEXP (x, 1)) >= -256\n+\t\t       && INTVAL (XEXP (x, 1)) <= 255)\n+\t\t    ? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\n+\t  return true;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+    case DIV:\n+    case MOD:\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n+\t{\n+\t  *total = COSTS_N_INSNS (2);\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case UDIV:\n+    case UMOD:\n+      switch (rs6000_cpu)\n+\t{\n+\tcase PROCESSOR_RIOS1:\n+\t  *total = COSTS_N_INSNS (19);\n+\t  return true;\n+\n+\tcase PROCESSOR_RIOS2:\n+\t  *total = COSTS_N_INSNS (13);\n+\t  return true;\n+\n+\tcase PROCESSOR_RS64A:\n+\t  *total = (GET_MODE (XEXP (x, 1)) != DImode\n+\t\t    ? COSTS_N_INSNS (65)\n+\t\t    : COSTS_N_INSNS (67));\n+\t  return true;\n+\n+\tcase PROCESSOR_MPCCORE:\n+\t  *total = COSTS_N_INSNS (6);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC403:\n+\t  *total = COSTS_N_INSNS (33);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC405:\n+\t  *total = COSTS_N_INSNS (35);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC601:\n+\t  *total = COSTS_N_INSNS (36);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC603:\n+\t  *total = COSTS_N_INSNS (37);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC604:\n+\tcase PROCESSOR_PPC604e:\n+\t  *total = COSTS_N_INSNS (20);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC620:\n+\tcase PROCESSOR_PPC630:\n+\tcase PROCESSOR_POWER4:\n+\t  *total = (GET_MODE (XEXP (x, 1)) != DImode\n+\t\t    ? COSTS_N_INSNS (21)\n+\t\t    : COSTS_N_INSNS (37));\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC750:\n+\tcase PROCESSOR_PPC8540:\n+\tcase PROCESSOR_PPC7400:\n+\t  *total = COSTS_N_INSNS (19);\n+\t  return true;\n+\n+\tcase PROCESSOR_PPC7450:\n+\t  *total = COSTS_N_INSNS (23);\n+\t  return true;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+    case FFS:\n+      *total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    case MEM:\n+      /* MEM should be slightly more expensive than (plus (reg) (const)) */\n+      *total = 5;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* A C expression returning the cost of moving data from a register of class\n    CLASS1 to one of CLASS2.  */\n "}, {"sha": "71288817dc5bf9e57a5695f58eb09c998a29f9ce", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2291,139 +2291,6 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n #define SHIFT_COUNT_TRUNCATED (TARGET_POWER ? 1 : 0)\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.\n-\n-   On the RS/6000, if it is valid in the insn, it is free.  So this\n-   always returns 0.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-  case HIGH:\t\t\t\t\t\t\t\\\n-    return 0;\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  */\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-    return ((GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t     && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (X, 1))\t\t\\\n-\t\t\t\t\t   + 0x8000) >= 0x10000)\t\\\n-\t     && ((INTVAL (XEXP (X, 1)) & 0xffff) != 0))\t\t\t\\\n-\t    ? COSTS_N_INSNS (2)\t\t\t\t\t\t\\\n-\t    : COSTS_N_INSNS (1));\t\t\t\t\t\\\n-  case AND:\t\t\t\t\t\t\t\t\\\n-  case IOR:\t\t\t\t\t\t\t\t\\\n-  case XOR:\t\t\t\t\t\t\t\t\\\n-    return ((GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t     && (INTVAL (XEXP (X, 1)) & (~ (HOST_WIDE_INT) 0xffff)) != 0 \\\n-\t     && ((INTVAL (XEXP (X, 1)) & 0xffff) != 0))\t\t\t\\\n-\t    ? COSTS_N_INSNS (2)\t\t\t\t\t\t\\\n-\t    : COSTS_N_INSNS (1));\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    if (optimize_size)\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-    switch (rs6000_cpu)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-      case PROCESSOR_RIOS1:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC405:\t\t\t\t\t\t\\\n-        return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n-\t\t? COSTS_N_INSNS (5)\t\t\t\t\t\\\n-\t\t: INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n-\t\t? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\t\t\\\n-      case PROCESSOR_RS64A:\t\t\t\t\t\t\\\n-        return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n-\t\t? GET_MODE (XEXP (X, 1)) != DImode\t\t\t\\\n-\t\t? COSTS_N_INSNS (20) : COSTS_N_INSNS (34)\t\t\\\n-\t\t: INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n-\t\t? COSTS_N_INSNS (8) : COSTS_N_INSNS (12));\t\t\\\n-      case PROCESSOR_RIOS2:\t\t\t\t\t\t\\\n-      case PROCESSOR_MPCCORE:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC604e:\t\t\t\t\t\t\\\n-        return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-      case PROCESSOR_PPC601:\t\t\t\t\t\t\\\n-        return COSTS_N_INSNS (5);\t\t\t\t\t\\\n-      case PROCESSOR_PPC603:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC7400:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC750:\t\t\t\t\t\t\\\n-        return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n-\t\t? COSTS_N_INSNS (5)\t\t\t\t\t\\\n-\t\t: INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n-\t\t? COSTS_N_INSNS (2) : COSTS_N_INSNS (3));\t\t\\\n-      case PROCESSOR_PPC7450:\t\t\t\t\t\t\\\n-        return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n-\t\t? COSTS_N_INSNS (4)\t\t\t\t\t\\\n-\t\t: COSTS_N_INSNS (3));\t\t\t    \t\t\\\n-      case PROCESSOR_PPC403:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC604:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC8540:\t\t\t\t\t\t\\\n-        return COSTS_N_INSNS (4);\t\t\t\t\t\\\n-      case PROCESSOR_PPC620:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC630:\t\t\t\t\t\t\\\n-      case PROCESSOR_POWER4:\t\t\t\t\t\t\\\n-        return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n-\t\t? GET_MODE (XEXP (X, 1)) != DImode\t\t\t\\\n-\t\t? COSTS_N_INSNS (5) : COSTS_N_INSNS (7)\t\t\t\\\n-\t\t: INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n-\t\t? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-\t&& exact_log2 (INTVAL (XEXP (X, 1))) >= 0)\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-    /* otherwise fall through to normal divide.  */\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\t\\\n-    switch (rs6000_cpu)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-      case PROCESSOR_RIOS1:\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (19);\t\t\t\t\t\\\n-      case PROCESSOR_RIOS2:\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (13);\t\t\t\t\t\\\n-      case PROCESSOR_RS64A:\t\t\t\t\t\t\\\n-        return (GET_MODE (XEXP (X, 1)) != DImode\t\t\t\\\n-\t\t? COSTS_N_INSNS (65)\t\t\t\t\t\\\n-\t\t: COSTS_N_INSNS (67));\t\t\t\t\t\\\n-      case PROCESSOR_MPCCORE:\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (6);\t\t\t\t\t\\\n-      case PROCESSOR_PPC403:\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (33);\t\t\t\t\t\\\n-      case PROCESSOR_PPC405:\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (35);\t\t\t\t\t\\\n-      case PROCESSOR_PPC601:\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (36);\t\t\t\t\t\\\n-      case PROCESSOR_PPC603:\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (37);\t\t\t\t\t\\\n-      case PROCESSOR_PPC604:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC604e:\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (20);\t\t\t\t\t\\\n-      case PROCESSOR_PPC620:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC630:\t\t\t\t\t\t\\\n-      case PROCESSOR_POWER4:\t\t\t\t\t\t\\\n-        return (GET_MODE (XEXP (X, 1)) != DImode\t\t\t\\\n-\t\t? COSTS_N_INSNS (21)\t\t\t\t\t\\\n-\t\t: COSTS_N_INSNS (37));\t\t\t\t\t\\\n-      case PROCESSOR_PPC750:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC8540:\t\t\t\t\t\t\\\n-      case PROCESSOR_PPC7400:\t\t\t\t\t\t\\\n-        return COSTS_N_INSNS (19);\t\t\t\t\t\\\n-      case PROCESSOR_PPC7450:\t\t\t\t\t\t\\\n-        return COSTS_N_INSNS (23);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  case FFS:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\t\t\\\n-    /* MEM should be slightly more expensive than (plus (reg) (const)) */ \\\n-    return 5;\n-\n /* Compute the cost of an address.  This is meant to approximate the size\n    and/or execution delay of an insn using that address.  If the cost is\n    approximated by the RTL complexity, including CONST_COSTS above, as"}, {"sha": "7149ae90f751ac6e67e81bd8378661e86603f609", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -66,6 +66,7 @@ static enum attr_type s390_safe_attr_type PARAMS ((rtx));\n static int s390_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int s390_issue_rate PARAMS ((void));\n static int s390_use_dfa_pipeline_interface PARAMS ((void));\n+static bool s390_rtx_costs PARAMS ((rtx, int, int, int *));\n \n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n@@ -113,6 +114,8 @@ static int s390_use_dfa_pipeline_interface PARAMS ((void));\n #undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE s390_use_dfa_pipeline_interface\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS s390_rtx_costs\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n@@ -1192,6 +1195,79 @@ q_constraint (op)\n   return 1;\n }\n \n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+s390_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST:\n+      if (GET_CODE (XEXP (x, 0)) == MINUS\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) != CONST_INT)\n+\t*total = 1000;\n+      else\n+\t*total = 0;\n+      return true;\n+\n+    case CONST_INT:\n+      /* Force_const_mem does not work out of reload, because the\n+\t saveable_obstack is set to reload_obstack, which does not\n+\t live long enough.  Because of this we cannot use force_const_mem\n+\t in addsi3.  This leads to problems with gen_add2_insn with a\n+\t constant greater than a short. Because of that we give an\n+\t addition of greater constants a cost of 3 (reload1.c 10096).  */\n+      /* ??? saveable_obstack no longer exists.  */\n+      if (outer_code == PLUS\n+\t  && (INTVAL (x) > 32767 || INTVAL (x) < -32768))\n+\t*total = COSTS_N_INSNS (3);\n+      else\n+\t*total = 0;\n+      return true;\n+\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+      *total = 0;\n+      return true;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case PLUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case MINUS:\n+    case NEG:\n+    case NOT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case MULT:\n+      if (GET_MODE (XEXP (x, 0)) == DImode)\n+        *total = COSTS_N_INSNS (40);\n+      else\n+        *total = COSTS_N_INSNS (7);\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (33);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Return the cost of an address rtx ADDR.  */\n \n int"}, {"sha": "066f2cf36706cdcf08cd2a072e3900a099b27dac", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -812,72 +812,6 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n \n /* Relative costs of operations.  */\n \n-/* A part of a C `switch' statement that describes the relative costs\n-   of constant RTL expressions.  It must contain `case' labels for\n-   expression codes `const_int', `const', `symbol_ref', `label_ref'\n-   and `const_double'.  Each case must ultimately reach a `return'\n-   statement to return the relative cost of the use of that kind of\n-   constant value in an expression.  The cost may depend on the\n-   precise value of the constant, which is available for examination\n-   in X, and the rtx code of the expression in which it is contained,\n-   found in OUTER_CODE.\n-\n-   CODE is the expression code--redundant, since it can be obtained\n-   with `GET_CODE (X)'.  */\n-/* Force_const_mem does not work out of reload, because the saveable_obstack\n-   is set to reload_obstack, which does not live long enough. \n-   Because of this we cannot use force_const_mem in addsi3.\n-   This leads to problems with gen_add2_insn with a constant greater\n-   than a short. Because of that we give an addition of greater\n-   constants a cost of 3 (reload1.c 10096).  */\n-\n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)                      \\\n-  case CONST:                                                   \\\n-    if ((GET_CODE (XEXP (RTX, 0)) == MINUS) &&                  \\\n-\t(GET_CODE (XEXP (XEXP (RTX, 0), 1)) != CONST_INT))      \\\n-     return 1000;                                               \\\n-  case CONST_INT:                                               \\\n-       if ((OUTER_CODE == PLUS) &&                              \\\n-\t   ((INTVAL (RTX) > 32767) ||                           \\\n-\t   (INTVAL (RTX) < -32768))) \t                        \\\n-         return COSTS_N_INSNS (3);                              \\\n-  case LABEL_REF:                                               \\\n-  case SYMBOL_REF:                                              \\\n-  case CONST_DOUBLE:                                            \\\n-    return 0;                                                   \\\n-\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n-   This can be used, for example, to indicate how costly a multiply\n-   instruction is.  In writing this macro, you can use the construct\n-   `COSTS_N_INSNS (N)' to specify a cost equal to N fast\n-   instructions.  OUTER_CODE is the code of the expression in which X\n-   is contained.  */\n-\n-#define RTX_COSTS(X, CODE, OUTER_CODE)                                  \\\n-  case ASHIFT:                                                          \\\n-  case ASHIFTRT:                                                        \\\n-  case LSHIFTRT:                                                        \\\n-  case PLUS:                                                            \\\n-  case AND:                                                             \\\n-  case IOR:                                                             \\\n-  case XOR:                                                             \\\n-  case MINUS:                                                           \\\n-  case NEG:                                                             \\\n-  case NOT:                                                             \\\n-    return COSTS_N_INSNS (1);                                           \\\n-  case MULT:                                                            \\\n-    if (GET_MODE (XEXP (X, 0)) == DImode)                               \\\n-      return COSTS_N_INSNS (40);                                        \\\n-    else                                                                \\\n-      return COSTS_N_INSNS (7);                                         \\\n-  case DIV:                                                             \\\n-  case UDIV:                                                            \\\n-  case MOD:                                                             \\\n-  case UMOD:                                                            \\\n-    return COSTS_N_INSNS (33);\n-\n-\n /* An expression giving the cost of an addressing mode that contains\n    ADDRESS.  If not defined, the cost is computed from the ADDRESS\n    expression and the `CONST_COSTS' values.  */"}, {"sha": "535fb30687aa911cd3b407c9f9f26b3855f111ef", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -56,10 +56,6 @@ extern int expand_block_move PARAMS ((rtx *));\n extern int prepare_move_operands PARAMS ((rtx[], enum machine_mode mode));\n extern void from_compare PARAMS ((rtx *, int));\n extern int shift_insns_rtx PARAMS ((rtx));\n-extern int shiftcosts PARAMS ((rtx));\n-extern int addsubcosts PARAMS ((rtx));\n-extern int andcosts PARAMS ((rtx));\n-extern int multcosts PARAMS ((rtx));\n extern void gen_ashift PARAMS ((int, int, rtx));\n extern void gen_ashift_hi PARAMS ((int, int, rtx));\n extern void gen_shifty_op PARAMS ((int, rtx *));"}, {"sha": "93e7978c0207264b92790eda2dac06a7b4ef098c", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 107, "deletions": 5, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -214,7 +214,11 @@ static void sh_media_init_builtins PARAMS ((void));\n static rtx sh_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n static int flow_dependent_p PARAMS ((rtx, rtx));\n static void flow_dependent_p_1 PARAMS ((rtx, rtx, void *));\n-\n+static int shiftcosts PARAMS ((rtx));\n+static int andcosts PARAMS ((rtx));\n+static int addsubcosts PARAMS ((rtx));\n+static int multcosts PARAMS ((rtx));\n+static bool sh_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -266,6 +270,9 @@ static void flow_dependent_p_1 PARAMS ((rtx, rtx, void *));\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL sh_function_ok_for_sibcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS sh_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -1274,7 +1281,7 @@ shift_insns_rtx (insn)\n \n /* Return the cost of a shift.  */\n \n-int\n+static inline int\n shiftcosts (x)\n      rtx x;\n {\n@@ -1314,7 +1321,7 @@ shiftcosts (x)\n \n /* Return the cost of an AND operation.  */\n \n-int\n+static inline int\n andcosts (x)\n      rtx x;\n {\n@@ -1354,7 +1361,7 @@ andcosts (x)\n \n /* Return the cost of an addition or a subtraction.  */\n \n-int\n+static inline int\n addsubcosts (x)\n      rtx x;\n {\n@@ -1395,7 +1402,7 @@ addsubcosts (x)\n }\n \n /* Return the cost of a multiply.  */\n-int\n+static inline int\n multcosts (x)\n      rtx x ATTRIBUTE_UNUSED;\n {\n@@ -1421,6 +1428,101 @@ multcosts (x)\n   return 20;\n }\n \n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+sh_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code, *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (TARGET_SHMEDIA)\n+        {\n+\t  if (INTVAL (x) == 0)\n+\t    *total = 0;\n+\t  else if (outer_code == AND && and_operand ((x), DImode))\n+\t    *total = 0;\n+\t  else if ((outer_code == IOR || outer_code == XOR\n+\t            || outer_code == PLUS)\n+\t\t   && CONST_OK_FOR_P (INTVAL (x)))\n+\t    *total = 0;\n+\t  else if (CONST_OK_FOR_J (INTVAL (x)))\n+            *total = COSTS_N_INSNS (outer_code != SET);\n+\t  else if (CONST_OK_FOR_J (INTVAL (x) >> 16))\n+\t    *total = COSTS_N_INSNS (2);\n+\t  else if (CONST_OK_FOR_J ((INTVAL (x) >> 16) >> 16))\n+\t    *total = COSTS_N_INSNS (3);\n+          else\n+\t    *total = COSTS_N_INSNS (4);\n+\t  return true;\n+        }\n+      if (CONST_OK_FOR_I (INTVAL (x)))\n+        *total = 0;\n+      else if ((outer_code == AND || outer_code == IOR || outer_code == XOR)\n+\t       && CONST_OK_FOR_L (INTVAL (x)))\n+        *total = 1;\n+      else\n+        *total = 8;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      if (TARGET_SHMEDIA64)\n+        *total = COSTS_N_INSNS (4);\n+      else if (TARGET_SHMEDIA32)\n+        *total = COSTS_N_INSNS (2);\n+      else\n+\t*total = 5;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (TARGET_SHMEDIA)\n+        *total = COSTS_N_INSNS (4);\n+      else\n+        *total = 10;\n+      return true;\n+\n+    case PLUS:\n+      *total = COSTS_N_INSNS (addsubcosts (x));\n+      return true;\n+\n+    case AND:\n+      *total = COSTS_N_INSNS (andcosts (x));\n+      return true;\n+\n+    case MULT:\n+      *total = COSTS_N_INSNS (multcosts (x));\n+      return true;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      *total = COSTS_N_INSNS (shiftcosts (x));\n+      return true;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (20);\n+      return true;\n+\n+    case FLOAT:\n+    case FIX:\n+      *total = 100;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+\n /* Code to expand a shift.  */\n \n void"}, {"sha": "7213933ad367316e35acb6b3ea991b7961d50c0f", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2690,70 +2690,6 @@ while (0)\n #define Pmode  (TARGET_SHMEDIA64 ? DImode : SImode)\n #define FUNCTION_MODE  Pmode\n \n-/* The relative costs of various types of constants.  */\n-\n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\\\n-  case CONST_INT:\t\t\t\t\\\n-    if (TARGET_SHMEDIA)\t\t\t\t\\\n-      {\t\t\t\t\t\t\\\n-\tif (INTVAL (RTX) == 0)\t\t\t\\\n-\t  return 0;\t\t\t\t\\\n-\tif ((OUTER_CODE) == AND && and_operand ((RTX), DImode)) \\\n-\t  return 0;\t\t\t\t\\\n-\tif (((OUTER_CODE) == IOR || (OUTER_CODE) == XOR \\\n-\t     || (OUTER_CODE) == PLUS) \\\n-\t    && CONST_OK_FOR_P (INTVAL (RTX)))\t\\\n-\t  return 0;\t\t\t\t\\\n-\tif (CONST_OK_FOR_J (INTVAL (RTX)))\t\\\n-          return COSTS_N_INSNS ((OUTER_CODE) != SET);\t\t\\\n-\telse if (CONST_OK_FOR_J (INTVAL (RTX) >> 16)) \\\n-\t  return COSTS_N_INSNS (2);\t\t\\\n-\telse if (CONST_OK_FOR_J ((INTVAL (RTX) >> 16) >> 16)) \\\n-\t  return COSTS_N_INSNS (3);\t\t\\\n-        else\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (4);\t\t\\\n-      }\t\t\t\t\t\t\\\n-    if (CONST_OK_FOR_I (INTVAL (RTX)))\t\t\\\n-      return 0;\t\t\t\t\t\\\n-    else if (((OUTER_CODE) == AND || (OUTER_CODE) == IOR || (OUTER_CODE) == XOR) \\\n-\t     && CONST_OK_FOR_L (INTVAL (RTX)))\t\\\n-      return 1;\t\t\t\t\t\\\n-    else\t\t\t\t\t\\\n-      return 8;\t\t\t\t\t\\\n-  case CONST: \t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\\\n-    if (TARGET_SHMEDIA64)\t\t\t\\\n-      return COSTS_N_INSNS (4);\t\t\t\\\n-    if (TARGET_SHMEDIA32)\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\\\n-    return 5;\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\\\n-    if (TARGET_SHMEDIA)\t\t\t\t\\\n-      return COSTS_N_INSNS (4);\t\t\t\\\n-    else\t\t\t\t\t\\\n-      return 10;\n-\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (addsubcosts (X));\t\t\\\n-  case AND:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (andcosts (X));\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (multcosts (X));\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\\\n-    return COSTS_N_INSNS (shiftcosts (X));\t\t\\\n-  case DIV:\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (20);\t\t\t\t\\\n-  case FLOAT:\t\t\t\t\t\t\\\n-  case FIX:\t\t\t\t\t\t\\\n-    return 100;\n-\n /* The multiply insn on the SH1 and the divide insns on the SH1 and SH2\n    are actually function calls with some special constraints on arguments\n    and register usage."}, {"sha": "31e0a2ccc6ce514c7cae7facbe555e6f68d440b6", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -120,7 +120,6 @@ extern char *sparc_v8plus_shift PARAMS ((rtx *, rtx, const char *));\n extern int sparc_check_64 PARAMS ((rtx, rtx));\n extern rtx gen_df_reg PARAMS ((rtx, int));\n extern int sparc_extra_constraint_check PARAMS ((rtx, int, int));\n-extern int sparc_rtx_costs PARAMS ((rtx, enum rtx_code, enum rtx_code));\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "a769ca9d2e7f0e9de3d62e2a81aed004da6200db", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 135, "deletions": 79, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -181,6 +181,7 @@ static void sparc_encode_section_info PARAMS ((tree, int));\n static bool sparc_function_ok_for_sibcall PARAMS ((tree, tree));\n static void sparc_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t   HOST_WIDE_INT, tree));\n+static bool sparc_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Option handling.  */\n \n@@ -252,6 +253,9 @@ enum processor_type sparc_cpu;\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS sparc_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Validate and override various options, and do some machine dependent\n@@ -8156,10 +8160,10 @@ sparc_extra_constraint_check (op, c, strict)\n    ??? scheduler description.  Some day, teach genautomata to output\n    ??? the latencies and then CSE will just use that.  */\n \n-int\n-sparc_rtx_costs (x, code, outer_code)\n+static bool\n+sparc_rtx_costs (x, code, outer_code, total)\n      rtx x;\n-     enum rtx_code code, outer_code;\n+     int code, outer_code, *total;\n {\n   switch (code)\n     {\n@@ -8173,50 +8177,61 @@ sparc_rtx_costs (x, code, outer_code)\n \t    {\n \t    case PROCESSOR_ULTRASPARC:\n \t    case PROCESSOR_ULTRASPARC3:\n-\t      return COSTS_N_INSNS (4);\n+\t      *total = COSTS_N_INSNS (4);\n+\t      return true;\n \n \t    case PROCESSOR_SUPERSPARC:\n-\t      return COSTS_N_INSNS (3);\n+\t      *total = COSTS_N_INSNS (3);\n+\t      return true;\n \n \t    case PROCESSOR_CYPRESS:\n-\t      return COSTS_N_INSNS (5);\n+\t      *total = COSTS_N_INSNS (5);\n+\t      return true;\n \n \t    case PROCESSOR_HYPERSPARC:\n \t    case PROCESSOR_SPARCLITE86X:\n \t    default:\n-\t      return COSTS_N_INSNS (1);\n+\t      *total = COSTS_N_INSNS (1);\n+\t      return true;\n \t    }\n \t}\n \n-      return COSTS_N_INSNS (1);\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n \n     case SQRT:\n       switch (sparc_cpu)\n \t{\n \tcase PROCESSOR_ULTRASPARC:\n \t  if (GET_MODE (x) == SFmode)\n-\t    return COSTS_N_INSNS (13);\n+\t    *total = COSTS_N_INSNS (13);\n \t  else\n-\t    return COSTS_N_INSNS (23);\n+\t    *total = COSTS_N_INSNS (23);\n+\t  return true;\n \n \tcase PROCESSOR_ULTRASPARC3:\n \t  if (GET_MODE (x) == SFmode)\n-\t    return COSTS_N_INSNS (20);\n+\t    *total = COSTS_N_INSNS (20);\n \t  else\n-\t    return COSTS_N_INSNS (29);\n+\t    *total = COSTS_N_INSNS (29);\n+\t  return true;\n \n \tcase PROCESSOR_SUPERSPARC:\n-\t  return COSTS_N_INSNS (12);\n+\t  *total = COSTS_N_INSNS (12);\n+\t  return true;\n \n \tcase PROCESSOR_CYPRESS:\n-\t  return COSTS_N_INSNS (63);\n+\t  *total = COSTS_N_INSNS (63);\n+\t  return true;\n \n \tcase PROCESSOR_HYPERSPARC:\n \tcase PROCESSOR_SPARCLITE86X:\n-\t  return COSTS_N_INSNS (17);\n+\t  *total = COSTS_N_INSNS (17);\n+\t  return true;\n \n \tdefault:\n-\t  return COSTS_N_INSNS (30);\n+\t  *total = COSTS_N_INSNS (30);\n+\t  return true;\n \t}\n \n     case COMPARE:\n@@ -8226,26 +8241,31 @@ sparc_rtx_costs (x, code, outer_code)\n \t    {\n \t    case PROCESSOR_ULTRASPARC:\n \t    case PROCESSOR_ULTRASPARC3:\n-\t      return COSTS_N_INSNS (1);\n+\t      *total = COSTS_N_INSNS (1);\n+\t      return true;\n \n \t    case PROCESSOR_SUPERSPARC:\n-\t      return COSTS_N_INSNS (3);\n+\t      *total = COSTS_N_INSNS (3);\n+\t      return true;\n \n \t    case PROCESSOR_CYPRESS:\n-\t      return COSTS_N_INSNS (5);\n+\t      *total = COSTS_N_INSNS (5);\n+\t      return true;\n \n \t    case PROCESSOR_HYPERSPARC:\n \t    case PROCESSOR_SPARCLITE86X:\n \t    default:\n-\t      return COSTS_N_INSNS (1);\n+\t      *total = COSTS_N_INSNS (1);\n+\t      return true;\n \t    }\n \t}\n \n       /* ??? Maybe mark integer compares as zero cost on\n \t ??? all UltraSPARC processors because the result\n \t ??? can be bypassed to a branch in the same group.  */\n \n-      return COSTS_N_INSNS (1);\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n \n     case MULT:\n       if (FLOAT_MODE_P (GET_MODE (x)))\n@@ -8254,20 +8274,25 @@ sparc_rtx_costs (x, code, outer_code)\n \t    {\n \t    case PROCESSOR_ULTRASPARC:\n \t    case PROCESSOR_ULTRASPARC3:\n-\t      return COSTS_N_INSNS (4);\n+\t      *total = COSTS_N_INSNS (4);\n+\t      return true;\n \n \t    case PROCESSOR_SUPERSPARC:\n-\t      return COSTS_N_INSNS (3);\n+\t      *total = COSTS_N_INSNS (3);\n+\t      return true;\n \n \t    case PROCESSOR_CYPRESS:\n-\t      return COSTS_N_INSNS (7);\n+\t      *total = COSTS_N_INSNS (7);\n+\t      return true;\n \n \t    case PROCESSOR_HYPERSPARC:\n \t    case PROCESSOR_SPARCLITE86X:\n-\t      return COSTS_N_INSNS (1);\n+\t      *total = COSTS_N_INSNS (1);\n+\t      return true;\n \n \t    default:\n-\t      return COSTS_N_INSNS (5);\n+\t      *total = COSTS_N_INSNS (5);\n+\t      return true;\n \t    }\n \t}\n \n@@ -8304,20 +8329,28 @@ sparc_rtx_costs (x, code, outer_code)\n \t Since we do not play any such tricks currently the\n \t safest thing to do is report the worst case latency.  */\n       if (sparc_cpu == PROCESSOR_ULTRASPARC)\n-\treturn (GET_MODE (x) == DImode ?\n-\t\tCOSTS_N_INSNS (34) : COSTS_N_INSNS (19));\n+\t{\n+\t  *total = (GET_MODE (x) == DImode\n+\t\t    ? COSTS_N_INSNS (34) : COSTS_N_INSNS (19));\n+\t  return true;\n+\t}\n \n       /* Multiply latency on Ultra-III, fortunately, is constant.  */\n       if (sparc_cpu == PROCESSOR_ULTRASPARC3)\n-\treturn COSTS_N_INSNS (6);\n+\t{\n+\t  *total = COSTS_N_INSNS (6);\n+\t  return true;\n+\t}\n \n       if (sparc_cpu == PROCESSOR_HYPERSPARC\n \t  || sparc_cpu == PROCESSOR_SPARCLITE86X)\n-\treturn COSTS_N_INSNS (17);\n+\t{\n+\t  *total = COSTS_N_INSNS (17);\n+\t  return true;\n+\t}\n \n-      return (TARGET_HARD_MUL\n-\t      ? COSTS_N_INSNS (5)\n-\t      : COSTS_N_INSNS (25));\n+      *total = (TARGET_HARD_MUL ? COSTS_N_INSNS (5) : COSTS_N_INSNS (25));\n+      return true;\n \n     case DIV:\n     case UDIV:\n@@ -8329,57 +8362,67 @@ sparc_rtx_costs (x, code, outer_code)\n \t    {\n \t    case PROCESSOR_ULTRASPARC:\n \t      if (GET_MODE (x) == SFmode)\n-\t\treturn COSTS_N_INSNS (13);\n+\t\t*total = COSTS_N_INSNS (13);\n \t      else\n-\t\treturn COSTS_N_INSNS (23);\n+\t\t*total = COSTS_N_INSNS (23);\n+\t      return true;\n \n \t    case PROCESSOR_ULTRASPARC3:\n \t      if (GET_MODE (x) == SFmode)\n-\t\treturn COSTS_N_INSNS (17);\n+\t\t*total = COSTS_N_INSNS (17);\n \t      else\n-\t\treturn COSTS_N_INSNS (20);\n+\t\t*total = COSTS_N_INSNS (20);\n+\t      return true;\n \n \t    case PROCESSOR_SUPERSPARC:\n \t      if (GET_MODE (x) == SFmode)\n-\t\treturn COSTS_N_INSNS (6);\n+\t\t*total = COSTS_N_INSNS (6);\n \t      else\n-\t\treturn COSTS_N_INSNS (9);\n+\t\t*total = COSTS_N_INSNS (9);\n+\t      return true;\n \n \t    case PROCESSOR_HYPERSPARC:\n \t    case PROCESSOR_SPARCLITE86X:\n \t      if (GET_MODE (x) == SFmode)\n-\t\treturn COSTS_N_INSNS (8);\n+\t\t*total = COSTS_N_INSNS (8);\n \t      else\n-\t\treturn COSTS_N_INSNS (12);\n+\t\t*total = COSTS_N_INSNS (12);\n+\t      return true;\n \n \t    default:\n-\t      return COSTS_N_INSNS (7);\n+\t      *total = COSTS_N_INSNS (7);\n+\t      return true;\n \t    }\n \t}\n \n       if (sparc_cpu == PROCESSOR_ULTRASPARC)\n-\treturn (GET_MODE (x) == DImode ?\n-\t\tCOSTS_N_INSNS (68) : COSTS_N_INSNS (37));\n-      if (sparc_cpu == PROCESSOR_ULTRASPARC3)\n-\treturn (GET_MODE (x) == DImode ?\n-\t\tCOSTS_N_INSNS (71) : COSTS_N_INSNS (40));\n-      return COSTS_N_INSNS (25);\n+\t*total = (GET_MODE (x) == DImode\n+\t\t  ? COSTS_N_INSNS (68) : COSTS_N_INSNS (37));\n+      else if (sparc_cpu == PROCESSOR_ULTRASPARC3)\n+\t*total = (GET_MODE (x) == DImode\n+\t\t  ? COSTS_N_INSNS (71) : COSTS_N_INSNS (40));\n+      else\n+\t*total = COSTS_N_INSNS (25);\n+      return true;\n \n     case IF_THEN_ELSE:\n       /* Conditional moves. */\n       switch (sparc_cpu)\n \t{\n \tcase PROCESSOR_ULTRASPARC:\n-\t  return COSTS_N_INSNS (2);\n+\t  *total = COSTS_N_INSNS (2);\n+\t  return true;\n \n \tcase PROCESSOR_ULTRASPARC3:\n \t  if (FLOAT_MODE_P (GET_MODE (x)))\n-\t    return COSTS_N_INSNS (3);\n+\t    *total = COSTS_N_INSNS (3);\n \t  else\n-\t    return COSTS_N_INSNS (2);\n+\t    *total = COSTS_N_INSNS (2);\n+\t  return true;\n \n \tdefault:\n-\t  return COSTS_N_INSNS (1);\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return true;\n \t}\n \n     case MEM:\n@@ -8390,85 +8433,98 @@ sparc_rtx_costs (x, code, outer_code)\n \t{\n \tcase PROCESSOR_ULTRASPARC:\n \t  if (outer_code == ZERO_EXTEND)\n-\t    return COSTS_N_INSNS (1);\n+\t    *total = COSTS_N_INSNS (1);\n \t  else\n-\t    return COSTS_N_INSNS (2);\n+\t    *total = COSTS_N_INSNS (2);\n+\t  return true;\n \n \tcase PROCESSOR_ULTRASPARC3:\n \t  if (outer_code == ZERO_EXTEND)\n \t    {\n \t      if (GET_MODE (x) == QImode\n \t\t  || GET_MODE (x) == HImode\n \t\t  || outer_code == SIGN_EXTEND)\n-\t\treturn COSTS_N_INSNS (2);\n+\t\t*total = COSTS_N_INSNS (2);\n \t      else\n-\t\treturn COSTS_N_INSNS (1);\n+\t\t*total = COSTS_N_INSNS (1);\n \t    }\n \t  else\n \t    {\n \t      /* This handles sign extension (3 cycles)\n \t\t and everything else (2 cycles).  */\n-\t      return COSTS_N_INSNS (2);\n+\t      *total = COSTS_N_INSNS (2);\n \t    }\n+\t  return true;\n \n \tcase PROCESSOR_SUPERSPARC:\n \t  if (FLOAT_MODE_P (GET_MODE (x))\n \t      || outer_code == ZERO_EXTEND\n \t      || outer_code == SIGN_EXTEND)\n-\t    return COSTS_N_INSNS (0);\n+\t    *total = COSTS_N_INSNS (0);\n \t  else\n-\t    return COSTS_N_INSNS (1);\n+\t    *total = COSTS_N_INSNS (1);\n+\t  return true;\n \n \tcase PROCESSOR_TSC701:\n \t  if (outer_code == ZERO_EXTEND\n \t      || outer_code == SIGN_EXTEND)\n-\t    return COSTS_N_INSNS (2);\n+\t    *total = COSTS_N_INSNS (2);\n \t  else\n-\t    return COSTS_N_INSNS (3);\n+\t    *total = COSTS_N_INSNS (3);\n+\t  return true;\n \t  \n \tcase PROCESSOR_CYPRESS:\n \t  if (outer_code == ZERO_EXTEND\n \t      || outer_code == SIGN_EXTEND)\n-\t    return COSTS_N_INSNS (1);\n+\t    *total = COSTS_N_INSNS (1);\n \t  else\n-\t    return COSTS_N_INSNS (2);\n+\t    *total = COSTS_N_INSNS (2);\n+\t  return true;\n \t  \n \tcase PROCESSOR_HYPERSPARC:\n \tcase PROCESSOR_SPARCLITE86X:\n \tdefault:\n \t  if (outer_code == ZERO_EXTEND\n \t      || outer_code == SIGN_EXTEND)\n-\t    return COSTS_N_INSNS (0);\n+\t    *total = COSTS_N_INSNS (0);\n \t  else\n-\t    return COSTS_N_INSNS (1);\n+\t    *total = COSTS_N_INSNS (1);\n+\t  return true;\n \t}\n \n     case CONST_INT:\n       if (INTVAL (x) < 0x1000 && INTVAL (x) >= -0x1000)\n-\treturn 0;\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n \n-    /* fallthru */\n     case HIGH:\n-      return 2;\n+      *total = 2;\n+      return true;\n \n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-      return 4;\n+      *total = 4;\n+      return true;\n \n     case CONST_DOUBLE:\n-      if (GET_MODE (x) == DImode)\n-\tif ((XINT (x, 3) == 0\n-\t     && (unsigned) XINT (x, 2) < 0x1000)\n-\t    || (XINT (x, 3) == -1\n-\t\t&& XINT (x, 2) < 0\n-\t\t&& XINT (x, 2) >= -0x1000))\n-\t  return 0;\n-      return 8;\n+      if (GET_MODE (x) == DImode\n+\t  && ((XINT (x, 3) == 0\n+\t       && (unsigned HOST_WIDE_INT) XINT (x, 2) < 0x1000)\n+\t      || (XINT (x, 3) == -1\n+\t\t  && XINT (x, 2) < 0\n+\t\t  && XINT (x, 2) >= -0x1000)))\n+\t*total = 0;\n+      else\n+\t*total = 8;\n+      return true;\n \n     default:\n-      abort();\n-    };\n+      return false;\n+    }\n }\n \n /* If we are referencing a function make the SYMBOL_REF special.  In"}, {"sha": "95a97d240cafe82d3958d554918db5ed82c57631", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2608,27 +2608,6 @@ do {                                                                    \\\n          : (sparc_cpu == PROCESSOR_ULTRASPARC3 \\\n             ? 9 : 3))\n \n-/* The cases that RTX_COSTS handles.  */\n-\n-#define RTX_COSTS_CASES\t\\\n-case PLUS: case MINUS: case ABS: case NEG: \\\n-case FLOAT: case UNSIGNED_FLOAT: \\\n-case FIX: case UNSIGNED_FIX: \\\n-case FLOAT_EXTEND: case FLOAT_TRUNCATE: \\\n-case SQRT: \\\n-case COMPARE: case IF_THEN_ELSE: \\\n-case MEM: \\\n-case MULT: case DIV: case UDIV: case MOD: case UMOD: \\\n-case CONST_INT: case HIGH: case CONST: \\\n-case LABEL_REF: case SYMBOL_REF: case CONST_DOUBLE:\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  */\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n-  RTX_COSTS_CASES\t\t\t\t\t\\\n-    return sparc_rtx_costs(X,CODE,OUTER_CODE);\n-\n #define ADDRESS_COST(RTX)  1\n \n #define PREFETCH_BLOCK \\"}, {"sha": "7a034626dd9efbaf270a910f6c73ff9c9c28eff2", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -57,6 +57,7 @@ static void xstormy16_asm_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \n static void xstormy16_init_builtins PARAMS ((void));\n static rtx xstormy16_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n+static bool xstormy16_rtx_costs PARAMS ((rtx, int, int, int *));\n \n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  */\n@@ -97,6 +98,47 @@ inequality_operator (op, mode)\n   return comparison_operator (op, mode) && ! equality_operator (op, mode);\n }\n \n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+xstormy16_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code ATTRIBUTE_UNUSED;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (INTVAL (x) < 16 && INTVAL (x) >= 0)\n+        *total = COSTS_N_INSNS (1) / 2;\n+      else if (INTVAL (x) < 256 && INTVAL (x) >= 0)\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      *total = COSTS_N_INSNS(2);\n+      return true;\n+\n+    case MULT:\n+      *total = COSTS_N_INSNS (35 + 6);\n+      return true;\n+    case DIV:\n+      *total = COSTS_N_INSNS (51 - 6);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+\n /* Branches are handled as follows:\n \n    1. HImode compare-and-branches.  The machine supports these\n@@ -2165,4 +2207,7 @@ xstormy16_expand_builtin(exp, target, subtarget, mode, ignore)\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS xstormy16_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "b8a90c49f47018f354e29654412246f638312dee", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -2197,43 +2197,6 @@ do {\t\t\t\t\t\t\t\\\n \f\n /* Describing Relative Costs of Operations */\n \n-/* A part of a C `switch' statement that describes the relative costs of\n-   constant RTL expressions.  It must contain `case' labels for expression\n-   codes `const_int', `const', `symbol_ref', `label_ref' and `const_double'.\n-   Each case must ultimately reach a `return' statement to return the relative\n-   cost of the use of that kind of constant value in an expression.  The cost\n-   may depend on the precise value of the constant, which is available for\n-   examination in X, and the rtx code of the expression in which it is\n-   contained, found in OUTER_CODE.\n-\n-   CODE is the expression code--redundant, since it can be obtained with\n-   `GET_CODE (X)'.  */\n-#define CONST_COSTS(X, CODE, OUTER_CODE)\t\\\n-  case CONST_INT:\t\t\t\t\\\n-    if (INTVAL (X) < 16 && INTVAL (X) >= 0)\t\\\n-      return COSTS_N_INSNS (1)/2;\t\t\\\n-    if (INTVAL (X) < 256 && INTVAL (X) >= 0)\t\\\n-      return COSTS_N_INSNS (1);\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\\\n-     return COSTS_N_INSNS(2);\n-\n-/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.  This can be\n-   used, for example, to indicate how costly a multiply instruction is.  In\n-   writing this macro, you can use the construct `COSTS_N_INSNS (N)' to specify\n-   a cost equal to N fast instructions.  OUTER_CODE is the code of the\n-   expression in which X is contained.\n-\n-   This macro is optional; do not define it if the default cost assumptions are\n-   adequate for the target machine.  */\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\\\n-  case MULT:\t\t\t\t\t\\\n-    return COSTS_N_INSNS (35 + 6);\t\t\\\n-  case DIV:\t\t\t\t\t\\\n-    return COSTS_N_INSNS (51 - 6);\n-\n /* An expression giving the cost of an addressing mode that contains ADDRESS.\n    If not defined, the cost is computed from the ADDRESS expression and the\n    `CONST_COSTS' values."}, {"sha": "296b6722ddec300484c5931217160008ade3c73f", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -46,7 +46,6 @@ extern int    v850_output_addr_const_extra  PARAMS ((FILE *, rtx));\n extern rtx    v850_return_addr              PARAMS ((int));\n extern void   print_operand                 PARAMS ((FILE *, rtx, int ));\n extern void   print_operand_address         PARAMS ((FILE *, rtx));\n-extern int    const_costs                   PARAMS ((rtx, enum rtx_code));\n extern const char *output_move_double       PARAMS ((rtx *));\n extern const char *output_move_single       PARAMS ((rtx *));\n extern void   v850_reorg                    PARAMS ((rtx));"}, {"sha": "f16114ec6c99f3aa91b6e7a529e2b45bed581fae", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -51,6 +51,8 @@\n /* Function prototypes for stupid compilers:  */\n static void const_double_split       PARAMS ((rtx, HOST_WIDE_INT *, HOST_WIDE_INT *));\n static int  const_costs_int          PARAMS ((HOST_WIDE_INT, int));\n+static int  const_costs\t\t     PARAMS ((rtx, enum rtx_code));\n+static bool v850_rtx_costs\t     PARAMS ((rtx, int, int, int *));\n static void substitute_ep_register   PARAMS ((rtx, rtx, int, int, rtx *, rtx *));\n static int  ep_memory_offset         PARAMS ((enum machine_mode, int));\n static void v850_set_data_area       PARAMS ((tree, v850_data_area));\n@@ -105,6 +107,9 @@ static int v850_interrupt_p = FALSE;\n #undef TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING v850_strip_name_encoding\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS v850_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -322,7 +327,7 @@ const_costs_int (value, zero_cost)\n     return 4;\n }\n \n-int\n+static int\n const_costs (r, c)\n      rtx r;\n      enum rtx_code c;\n@@ -354,6 +359,55 @@ const_costs (r, c)\n     }\n }\n \n+static bool\n+v850_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code ATTRIBUTE_UNUSED, *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      *total = COSTS_N_INSNS (const_costs (x, code));\n+      return true;\n+\n+    case MOD:\n+    case DIV:\n+    case UMOD:\n+    case UDIV:\n+      if (TARGET_V850E && optimize_size)\n+        *total = 6;\n+      else\n+\t*total = 60;\n+      return true;\n+\n+    case MULT:\n+      if (TARGET_V850E\n+\t  && (   GET_MODE (x) == SImode\n+\t      || GET_MODE (x) == HImode\n+\t      || GET_MODE (x) == QImode))\n+        {\n+\t  if (GET_CODE (XEXP (x, 1)) == REG)\n+\t    *total = 4;\n+\t  else if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t    {\n+\t      if (CONST_OK_FOR_O (INTVAL (XEXP (x, 1))))\n+\t        *total = 6;\n+\t      else if (CONST_OK_FOR_K (INTVAL (XEXP (x, 1))))\n+\t        *total = 10;\n+\t    }\n+        }\n+      else\n+\t*total = 20;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n \f\n /* Print operand X using operand code CODE to assembly language output file\n    FILE.  */"}, {"sha": "447e247ea36d15cc71e46cf10a350f60601aa1d7", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1025,64 +1025,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define CC_NO_CARRY CC_NO_OVERFLOW\n #define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n \n-/* A part of a C `switch' statement that describes the relative costs\n-   of constant RTL expressions.  It must contain `case' labels for\n-   expression codes `const_int', `const', `symbol_ref', `label_ref'\n-   and `const_double'.  Each case must ultimately reach a `return'\n-   statement to return the relative cost of the use of that kind of\n-   constant value in an expression.  The cost may depend on the\n-   precise value of the constant, which is available for examination\n-   in X, and the rtx code of the expression in which it is contained,\n-   found in OUTER_CODE.\n-\n-   CODE is the expression code--redundant, since it can be obtained\n-   with `GET_CODE (X)'. */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int _zxy = const_costs(RTX, CODE);\t\t\t\t\\\n-      return (_zxy) ? COSTS_N_INSNS (_zxy) : 0;\t\t\t\t\\\n-    }\n-\n-/* A crude cut at RTX_COSTS for the V850.  */\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE. \n-\n-   There aren't DImode MOD, DIV or MULT operations, so call them\n-   very expensive.  Everything else is pretty much a constant cost.  */\n-\n-#define RTX_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-    if (TARGET_V850E && optimize_size)\t\t\t\t\t\\\n-      return 6;\t\t\t\t\t\t\t\t\\\n-    return 60;\t\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    if (TARGET_V850E\t\t\t\t\t\t\t\\\n-\t&& (   GET_MODE (RTX) == SImode\t\t\t\t\t\\\n-\t    || GET_MODE (RTX) == HImode\t\t\t\t\t\\\n-\t    || GET_MODE (RTX) == QImode))\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (RTX, 1)) == REG)\t\t\t\t\\\n-\t  return 4;\t\t\t\t\t\t\t\\\n-\telse if (GET_CODE (XEXP (RTX, 1)) == CONST_INT)\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (CONST_OK_FOR_O (INTVAL (XEXP (RTX, 1))))\t\t\\\n-\t      return 6;\t\t\t\t\t\t\t\\\n-\t    else if (CONST_OK_FOR_K (INTVAL (XEXP (RTX, 1))))\t\t\\\n-\t      return 10;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    return 20;\n-\n /* All addressing modes have the same cost on the V850 series.  */\n #define ADDRESS_COST(ADDR) 1\n "}, {"sha": "9bff82b15e8fd4f265834d39a082b6ea4ec13681", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -45,6 +45,8 @@ static int follows_p PARAMS ((rtx, rtx));\n static void vax_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void vax_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, tree));\n+static int vax_rtx_costs_1 PARAMS ((rtx, enum rtx_code, enum rtx_code));\n+static bool vax_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -58,6 +60,9 @@ static void vax_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS vax_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Set global variables as needed for the options enabled.  */\n@@ -482,23 +487,56 @@ vax_address_cost (addr)\n   return reg + indexed + indir + offset + predec;\n }\n \n-\n /* Cost of an expression on a VAX.  This version has costs tuned for the\n    CVAX chip (found in the VAX 3 series) with comments for variations on\n    other models.  */\n \n-int\n-vax_rtx_cost (x)\n+static int\n+vax_rtx_costs_1 (x, code, outer_code)\n     register rtx x;\n+    enum rtx_code code, outer_code;\n {\n-  register enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n   register int c;\n   int i = 0;\t\t\t\t/* may be modified in switch */\n   const char *fmt = GET_RTX_FORMAT (code); /* may be modified in switch */\n \n   switch (code)\n     {\n+      /* On a VAX, constants from 0..63 are cheap because they can use the\n+         1 byte literal constant format.  compare to -1 should be made cheap\n+         so that decrement-and-branch insns can be formed more easily (if\n+         the value -1 is copied to a register some decrement-and-branch\n+\t patterns will not match).  */\n+    case CONST_INT:\n+      if (INTVAL (x) == 0)\n+\treturn 0;\n+      if (outer_code == AND)\n+        return ((unsigned HOST_WIDE_INT) ~INTVAL (x) <= 077) ? 1 : 2;\n+      if ((unsigned HOST_WIDE_INT) INTVAL (x) <= 077)\n+\treturn 1;\n+      if (outer_code == COMPARE && INTVAL (x) == -1)\n+        return 1;\n+      if (outer_code == PLUS && (unsigned HOST_WIDE_INT) -INTVAL (x) <= 077)\n+        return 1;\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      return 3;\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+        return vax_float_literal (x) ? 5 : 8;\n+      else\n+        return (((CONST_DOUBLE_HIGH (x) == 0\n+\t\t  && (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x) < 64)\n+\t         || (outer_code == PLUS\n+\t\t     && CONST_DOUBLE_HIGH (x) == -1\t\t\\\n+\t\t     && (unsigned HOST_WIDE_INT)-CONST_DOUBLE_LOW (x) < 64))\n+\t        ? 2 : 5);\n+ \n     case POST_INC:\n       return 2;\n     case PRE_DEC:\n@@ -617,7 +655,6 @@ vax_rtx_cost (x)\n       break;\n     }\n \n-\n   /* Now look inside the expression.  Operands which are not registers or\n      short constants add to the cost.\n \n@@ -678,6 +715,16 @@ vax_rtx_cost (x)\n     }\n   return c;\n }\n+\n+static bool\n+vax_rtx_costs (x, code, outer_code, total)\n+    rtx x;\n+    int code, outer_code;\n+    int *total;\n+{\n+  *total = vax_rtx_costs_1 (x, code, outer_code);\n+  return true;\n+}\n \f\n /* Return 1 if insn A follows B.  */\n "}, {"sha": "e2a1d95e13de1194dee675c0cfbf35b255d16f50", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -848,49 +848,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define TARGET_FLOAT_FORMAT VAX_FLOAT_FORMAT\n \n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-/* On a VAX, constants from 0..63 are cheap because they can use the\n-   1 byte literal constant format.  compare to -1 should be made cheap\n-   so that decrement-and-branch insns can be formed more easily (if\n-   the value -1 is copied to a register some decrement-and-branch patterns\n-   will not match).  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (INTVAL (RTX) == 0) return 0;\t\t\t\t\\\n-    if ((OUTER_CODE) == AND)\t\t\t\t\t\\\n-      return ((unsigned) ~INTVAL (RTX) <= 077) ? 1 : 2;\t\t\\\n-    if ((unsigned) INTVAL (RTX) <= 077) return 1;\t\t\\\n-    if ((OUTER_CODE) == COMPARE && INTVAL (RTX) == -1)\t\t\\\n-      return 1;\t\t\t\t\t\t\t\\\n-    if ((OUTER_CODE) == PLUS && (unsigned) -INTVAL (RTX) <= 077)\\\n-      return 1;\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 3;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    if (GET_MODE_CLASS (GET_MODE (RTX)) == MODE_FLOAT)\t\t\\\n-      return vax_float_literal (RTX) ? 5 : 8;\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      return (((CONST_DOUBLE_HIGH (RTX) == 0\t\t\t\\\n-\t\t&& (unsigned) CONST_DOUBLE_LOW (RTX) < 64)\t\\\n-\t       || ((OUTER_CODE) == PLUS\t\t\t\t\\\n-\t\t   && CONST_DOUBLE_HIGH (RTX) == -1\t\t\\\n-\t\t   && (unsigned)-CONST_DOUBLE_LOW (RTX) < 64))\t\\\n-\t      ? 2 : 5);\n-\n-#define RTX_COSTS(RTX,CODE,OUTER_CODE) case FIX: case FLOAT:\t\\\n- case MULT: case DIV: case UDIV: case MOD: case UMOD:\t\t\\\n- case ASHIFT: case LSHIFTRT: case ASHIFTRT:\t\t\t\\\n- case ROTATE: case ROTATERT: case PLUS: case MINUS: case IOR:\t\\\n- case XOR: case AND: case NEG: case NOT: case ZERO_EXTRACT:\t\\\n- case SIGN_EXTRACT: case MEM: return vax_rtx_cost(RTX)\n-\n #define\tADDRESS_COST(RTX) (1 + (GET_CODE (RTX) == REG ? 0 : vax_address_cost(RTX)))\n \n /* Specify the cost of a branch insn; roughly the number of extra insns that"}, {"sha": "645ad1adbfd646e5c1115fb0bc06c66a7ce5041c", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -204,6 +204,7 @@ static unsigned int xtensa_multibss_section_type_flags\n static void xtensa_select_rtx_section\n   PARAMS ((enum machine_mode, rtx, unsigned HOST_WIDE_INT));\n static void xtensa_encode_section_info PARAMS ((tree, int));\n+static bool xtensa_rtx_costs PARAMS ((rtx, int, int, int *));\n \n static rtx frame_size_const;\n static int current_function_arg_words;\n@@ -240,6 +241,9 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO  xtensa_encode_section_info\n \n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS xtensa_rtx_costs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -2838,4 +2842,216 @@ xtensa_encode_section_info (decl, first)\n     SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n }\n \n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+xtensa_rtx_costs (x, code, outer_code, total)\n+     rtx x;\n+     int code, outer_code;\n+     int *total;\n+{\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      switch (outer_code)\n+\t{\n+\tcase SET:\n+\t  if (xtensa_simm12b (INTVAL (x)))\n+\t    {\n+\t      *total = 4;\n+\t      return true;\n+\t    }\n+\t  break;\n+\tcase PLUS:\n+\t  if (xtensa_simm8 (INTVAL (x))\n+\t      || xtensa_simm8x256 (INTVAL (x)))\n+\t    {\n+\t      *total = 0;\n+\t      return true;\n+\t    }\n+\t  break;\n+\tcase AND:\n+\t  if (xtensa_mask_immediate (INTVAL (x)))\n+\t    {\n+\t      *total = 0;\n+\t      return true;\n+\t    }\n+\t  break;\n+\tcase COMPARE:\n+\t  if ((INTVAL (x) == 0) || xtensa_b4const (INTVAL (x)))\n+\t    {\n+\t      *total = 0;\n+\t      return true;\n+\t    }\n+\t  break;\n+\tcase ASHIFT:\n+\tcase ASHIFTRT:\n+\tcase LSHIFTRT:\n+\tcase ROTATE:\n+\tcase ROTATERT:\n+\t  /* no way to tell if X is the 2nd operand so be conservative */\n+\tdefault: break;\n+\t}\n+      if (xtensa_simm12b (INTVAL (x)))\n+\t*total = 5;\n+      else\n+\t*total = 6;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = 5;\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      *total = 7;\n+      return true;\n+\n+    case MEM:\n+      {\n+\tint num_words =\n+\t  (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD) ?  2 : 1;\n+\n+\tif (memory_address_p (GET_MODE (x), XEXP ((x), 0)))\n+\t  *total = COSTS_N_INSNS (num_words);\n+\telse\n+\t  *total = COSTS_N_INSNS (2*num_words);\n+\treturn true;\n+      }\n+\n+    case FFS:\n+      *total = COSTS_N_INSNS (TARGET_NSA ? 5 : 50);\n+      return true;\n+\n+    case NOT:\n+      *total = COSTS_N_INSNS ((GET_MODE (x) == DImode) ? 3 : 2);\n+      return true;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (GET_MODE (x) == DImode)\n+\t*total = COSTS_N_INSNS (2);\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (GET_MODE (x) == DImode)\n+\t*total = COSTS_N_INSNS (50);\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case ABS:\n+      {\n+\tenum machine_mode xmode = GET_MODE (x);\n+\tif (xmode == SFmode)\n+\t  *total = COSTS_N_INSNS (TARGET_HARD_FLOAT ? 1 : 50);\n+\telse if (xmode == DFmode)\n+\t  *total = COSTS_N_INSNS (50);\n+\telse\n+\t  *total = COSTS_N_INSNS (4);\n+\treturn true;\n+      }\n+\n+    case PLUS:\n+    case MINUS:\n+      {\n+\tenum machine_mode xmode = GET_MODE (x);\n+\tif (xmode == SFmode)\n+\t  *total = COSTS_N_INSNS (TARGET_HARD_FLOAT ? 1 : 50);\n+\telse if (xmode == DFmode || xmode == DImode)\n+\t  *total = COSTS_N_INSNS (50);\n+\telse\n+\t  *total = COSTS_N_INSNS (1);\n+\treturn true;\n+      }\n+\n+    case NEG:\n+      *total = COSTS_N_INSNS ((GET_MODE (x) == DImode) ? 4 : 2);\n+      return true;\n+\n+    case MULT:\n+      {\n+\tenum machine_mode xmode = GET_MODE (x);\n+\tif (xmode == SFmode)\n+\t  *total = COSTS_N_INSNS (TARGET_HARD_FLOAT ? 4 : 50);\n+\telse if (xmode == DFmode || xmode == DImode)\n+\t  *total = COSTS_N_INSNS (50);\n+\telse if (TARGET_MUL32)\n+\t  *total = COSTS_N_INSNS (4);\n+\telse if (TARGET_MAC16)\n+\t  *total = COSTS_N_INSNS (16);\n+\telse if (TARGET_MUL16)\n+\t  *total = COSTS_N_INSNS (12);\n+\telse\n+\t  *total = COSTS_N_INSNS (50);\n+\treturn true;\n+      }\n+\n+    case DIV:\n+    case MOD:\n+      {\n+\tenum machine_mode xmode = GET_MODE (x);\n+\tif (xmode == SFmode)\n+\t  {\n+\t    *total = COSTS_N_INSNS (TARGET_HARD_FLOAT_DIV ? 8 : 50);\n+\t    return true;\n+\t  }\n+\telse if (xmode == DFmode)\n+\t  {\n+\t    *total = COSTS_N_INSNS (50);\n+\t    return true;\n+\t  }\n+      }\n+      /* fall through */\n+\n+    case UDIV:\n+    case UMOD:\n+      {\n+\tenum machine_mode xmode = GET_MODE (x);\n+\tif (xmode == DImode)\n+\t  *total = COSTS_N_INSNS (50);\n+\telse if (TARGET_DIV32)\n+\t  *total = COSTS_N_INSNS (32);\n+\telse\n+\t  *total = COSTS_N_INSNS (50);\n+\treturn true;\n+      }\n+\n+    case SQRT:\n+      if (GET_MODE (x) == SFmode)\n+\t*total = COSTS_N_INSNS (TARGET_HARD_FLOAT_SQRT ? 8 : 50);\n+      else\n+\t*total = COSTS_N_INSNS (50);\n+      return true;\n+\n+    case SMIN:\n+    case UMIN:\n+    case SMAX:\n+    case UMAX:\n+      *total = COSTS_N_INSNS (TARGET_MINMAX ? 1 : 50);\n+      return true;\n+\n+    case SIGN_EXTRACT:\n+    case SIGN_EXTEND:\n+      *total = COSTS_N_INSNS (TARGET_SEXT ? 1 : 2);\n+      return true;\n+\n+    case ZERO_EXTRACT:\n+    case ZERO_EXTEND:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n #include \"gt-xtensa.h\""}, {"sha": "3ae66f1240ee9e67e488d6065c18f061d249d333", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -1281,153 +1281,6 @@ typedef struct xtensa_args {\n    indexing purposes) so give the MEM rtx a words's mode.  */\n #define FUNCTION_MODE SImode\n \n-/* Xtensa constant costs.  */\n-#define CONST_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\t\\\n-    switch (OUTER_CODE)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-      case SET:\t\t\t\t\t\t\t\t\\\n-\tif (xtensa_simm12b (INTVAL (X))) return 4;\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case PLUS:\t\t\t\t\t\t\t\\\n-\tif (xtensa_simm8 (INTVAL (X))) return 0;\t\t\t\\\n-\tif (xtensa_simm8x256 (INTVAL (X))) return 0;\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case AND:\t\t\t\t\t\t\t\t\\\n-\tif (xtensa_mask_immediate (INTVAL (X))) return 0;\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case COMPARE:\t\t\t\t\t\t\t\\\n-\tif ((INTVAL (X) == 0) || xtensa_b4const (INTVAL (X))) return 0;\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case ASHIFT:\t\t\t\t\t\t\t\\\n-      case ASHIFTRT:\t\t\t\t\t\t\t\\\n-      case LSHIFTRT:\t\t\t\t\t\t\t\\\n-      case ROTATE:\t\t\t\t\t\t\t\\\n-      case ROTATERT:\t\t\t\t\t\t\t\\\n-        /* no way to tell if X is the 2nd operand so be conservative */\t\\\n-      default: break;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (xtensa_simm12b (INTVAL (X))) return 5;\t\t\t\t\\\n-    return 6;\t\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-    return 5;\t\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n-    return 7;\n-\n-/* Costs of various Xtensa operations.  */\n-#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-\tint num_words =\t\t\t\t\t\t\t\\\n-\t  (GET_MODE_SIZE (GET_MODE (X)) > UNITS_PER_WORD) ?  2 : 1;\t\\\n-\tif (memory_address_p (GET_MODE (X), XEXP ((X), 0)))\t\t\\\n-\t  return COSTS_N_INSNS (num_words);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (2*num_words);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case FFS:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (TARGET_NSA ? 5 : 50);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case NOT:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_MODE (X) == DImode) ? 3 : 2);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case AND:\t\t\t\t\t\t\t\t\\\n-  case IOR:\t\t\t\t\t\t\t\t\\\n-  case XOR:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode) return COSTS_N_INSNS (2);\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode) return COSTS_N_INSNS (50);\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ABS:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-\tif (xmode == SFmode)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (TARGET_HARD_FLOAT ? 1 : 50);\t\t\\\n-\tif (xmode == DFmode)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (50);\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-\tif (xmode == SFmode)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (TARGET_HARD_FLOAT ? 1 : 50);\t\t\\\n-\tif (xmode == DFmode || xmode == DImode)\t\t\t\t\\\n-\t  return COSTS_N_INSNS (50);\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case NEG:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_MODE (X) == DImode) ? 4 : 2);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-\tif (xmode == SFmode)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (TARGET_HARD_FLOAT ? 4 : 50);\t\t\\\n-\tif (xmode == DFmode || xmode == DImode)\t\t\t\t\\\n-\t    return COSTS_N_INSNS (50);\t\t\t\t\t\\\n-\tif (TARGET_MUL32)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (4);\t\t\t\t\t\\\n-\tif (TARGET_MAC16)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (16);\t\t\t\t\t\\\n-\tif (TARGET_MUL16)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (12);\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (50);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-\tif (xmode == SFmode)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (TARGET_HARD_FLOAT_DIV ? 8 : 50);\t\\\n-\tif (xmode == DFmode)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (50);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    /* fall through */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n-\tif (xmode == DImode)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (50);\t\t\t\t\t\\\n-\tif (TARGET_DIV32)\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (32);\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (50);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case SQRT:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == SFmode)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (TARGET_HARD_FLOAT_SQRT ? 8 : 50);\t\t\\\n-    return COSTS_N_INSNS (50);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case SMIN:\t\t\t\t\t\t\t\t\\\n-  case UMIN:\t\t\t\t\t\t\t\t\\\n-  case SMAX:\t\t\t\t\t\t\t\t\\\n-  case UMAX:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (TARGET_MINMAX ? 1 : 50);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case SIGN_EXTRACT:\t\t\t\t\t\t\t\\\n-  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (TARGET_SEXT ? 1 : 2);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case ZERO_EXTRACT:\t\t\t\t\t\t\t\\\n-  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\n-\n-\n /* An expression giving the cost of an addressing mode that\n    contains ADDRESS.  */\n #define ADDRESS_COST(ADDR) 1"}, {"sha": "84210babcbd5fb7494574899eed60ab33981b456", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -41,6 +41,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"timevar.h\"\n #include \"except.h\"\n+#include \"target.h\"\n \n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n@@ -832,7 +833,7 @@ rtx_cost (x, outer_code)\n     return 0;\n \n   /* Compute the default costs of certain things.\n-     Note that RTX_COSTS can override the defaults.  */\n+     Note that targetm.rtx_costs can override the defaults.  */\n \n   code = GET_CODE (x);\n   switch (code)\n@@ -867,17 +868,9 @@ rtx_cost (x, outer_code)\n \t\t\t      + GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD);\n       break;\n \n-#ifdef RTX_COSTS\n-      RTX_COSTS (x, code, outer_code);\n-#endif\n-#ifdef CONST_COSTS\n-      CONST_COSTS (x, code, outer_code);\n-#endif\n-\n     default:\n-#ifdef DEFAULT_RTX_COSTS\n-      DEFAULT_RTX_COSTS (x, code, outer_code);\n-#endif\n+      if ((*targetm.rtx_costs) (x, code, outer_code, &total))\n+\treturn total;\n       break;\n     }\n "}, {"sha": "84dc1de0c15a87d9405f4d2f864e8f1459700feb", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 21, "deletions": 43, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -5264,49 +5264,6 @@ These macros let you describe the relative speed of various operations\n on the target machine.\n \n @table @code\n-@findex CONST_COSTS\n-@item CONST_COSTS (@var{x}, @var{code}, @var{outer_code})\n-A part of a C @code{switch} statement that describes the relative costs\n-of constant RTL expressions.  It must contain @code{case} labels for\n-expression codes @code{const_int}, @code{const}, @code{symbol_ref},\n-@code{label_ref} and @code{const_double}.  Each case must ultimately\n-reach a @code{return} statement to return the relative cost of the use\n-of that kind of constant value in an expression.  The cost may depend on\n-the precise value of the constant, which is available for examination in\n-@var{x}, and the rtx code of the expression in which it is contained,\n-found in @var{outer_code}.\n-\n-@var{code} is the expression code---redundant, since it can be\n-obtained with @code{GET_CODE (@var{x})}.\n-\n-@findex RTX_COSTS\n-@findex COSTS_N_INSNS\n-@item RTX_COSTS (@var{x}, @var{code}, @var{outer_code})\n-Like @code{CONST_COSTS} but applies to nonconstant RTL expressions.\n-This can be used, for example, to indicate how costly a multiply\n-instruction is.  In writing this macro, you can use the construct\n-@code{COSTS_N_INSNS (@var{n})} to specify a cost equal to @var{n} fast\n-instructions.  @var{outer_code} is the code of the expression in which\n-@var{x} is contained.\n-\n-This macro is optional; do not define it if the default cost assumptions\n-are adequate for the target machine.\n-\n-@findex DEFAULT_RTX_COSTS\n-@item DEFAULT_RTX_COSTS (@var{x}, @var{code}, @var{outer_code})\n-This macro, if defined, is called for any case not handled by the\n-@code{RTX_COSTS} or @code{CONST_COSTS} macros.  This eliminates the need\n-to put case labels into the macro, but the code, or any functions it\n-calls, must assume that the RTL in @var{x} could be of any type that has\n-not already been handled.  The arguments are the same as for\n-@code{RTX_COSTS}, and the macro should execute a return statement giving\n-the cost of any RTL expressions that it can handle.  The default cost\n-calculation is used for any RTL for which this macro does not return a\n-value.\n-\n-This macro is optional; do not define it if the default cost assumptions\n-are adequate for the target machine.\n-\n @findex ADDRESS_COST\n @item ADDRESS_COST (@var{address})\n An expression giving the cost of an addressing mode that contains\n@@ -5551,6 +5508,27 @@ itself with an explicit address than to call an address kept in a\n register.\n @end table\n \n+@deftypefn {Target Hook} bool TARGET_RTX_COSTS (rtx @var{x}, int @var{code}, int @var{outer_code}, int *@var{total})\n+This target hook describes the relative costs of RTL expressions.\n+\n+The cost may depend on the precise form of the expression, which is\n+available for examination in @var{x}, and the rtx code of the expression\n+in which it is contained, found in @var{outer_code}.  @var{code} is the\n+expression code---redundant, since it can be obtained with\n+@code{GET_CODE (@var{x})}.\n+\n+In implementing this hook, you can use the construct\n+@code{COSTS_N_INSNS (@var{n})} to specify a cost equal to @var{n} fast\n+instructions.\n+\n+On entry to the hook, @code{*@var{total}} contains a default estimate\n+for the cost of the expression.  The hook should modify this value as\n+necessary.\n+\n+The hook returns true when all subexpressions of @var{x} have been\n+processed, and false when @code{rtx_cost} should recurse.\n+@end deftypefn\n+\n @node Scheduling\n @section Adjusting the Instruction Scheduler\n "}, {"sha": "5911716766567910c00ae592a25495aaa2ca28e3", "filename": "gcc/hooks.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -131,3 +131,14 @@ hook_bool_rtx_false (a)\n {\n   return false;\n }\n+\n+bool\n+hook_bool_rtx_int_int_intp_false (a, b, c, d)\n+     rtx a ATTRIBUTE_UNUSED;\n+     int b ATTRIBUTE_UNUSED;\n+     int c ATTRIBUTE_UNUSED;\n+     int *d ATTRIBUTE_UNUSED;\n+{\n+  return false;\n+}\n+"}, {"sha": "954f2181ead4993a461c9cfb88fb831afbb63e41", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -29,6 +29,7 @@ bool hook_bool_tree_hwi_hwi_tree_false\n bool hook_bool_tree_hwi_hwi_tree_true\n   PARAMS ((tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n bool hook_bool_rtx_false PARAMS ((rtx));\n+bool hook_bool_rtx_int_int_intp_false PARAMS ((rtx, int, int, int *));\n \n void hook_void_tree_int PARAMS ((tree, int));\n void hook_void_void PARAMS ((void));"}, {"sha": "6858d30f04906555aaf81f4fb3e9fe1fa1550e95", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -613,7 +613,7 @@ typedef char _Bool;\n \tASM_OUTPUT_DESTRUCTOR SIGNED_CHAR_SPEC MAX_CHAR_TYPE_SIZE\t\\\n \tWCHAR_UNSIGNED UNIQUE_SECTION SELECT_SECTION SELECT_RTX_SECTION\t\\\n \tENCODE_SECTION_INFO STRIP_NAME_ENCODING ASM_GLOBALIZE_LABEL\t\\\n-\tASM_OUTPUT_MI_THUNK\n+\tASM_OUTPUT_MI_THUNK CONST_COSTS RTX_COSTS DEFAULT_RTX_COSTS\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "a6f1357921532871dc6910dcf2fc1337b8faac3d", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -262,6 +262,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_INSERT_ATTRIBUTES hook_void_tree_treeptr\n #define TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P hook_bool_tree_false\n #define TARGET_MS_BITFIELD_LAYOUT_P hook_bool_tree_false\n+/* #define TARGET_RTX_COSTS hook_bool_rtx_int_int_intp_false */\n \n #ifndef TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P hook_bool_tree_false\n@@ -295,6 +296,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_ENCODE_SECTION_INFO,\t\t\t\\\n   TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n   TARGET_VALID_POINTER_MODE,                    \\\n+  TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n   TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n   TARGET_HAVE_TLS,\t\t\t\t\\"}, {"sha": "933da66b5268514e6b74babcee18e7ddcb95661f", "filename": "gcc/target.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c50106f69e2a73f98a24f154979249e3b5ff79d/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=3c50106f69e2a73f98a24f154979249e3b5ff79d", "patch": "@@ -311,7 +311,16 @@ struct gcc_target\n   /* Undo the effects of encode_section_info on the symbol string.  */\n   const char * (* strip_name_encoding) PARAMS ((const char *));\n \n+  /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n   bool (* valid_pointer_mode) PARAMS ((enum machine_mode mode));\n+\n+  /* Compute a (partial) cost for rtx X.  Return true if the complete\n+     cost has been computed, and false if subexpressions should be\n+     scanned.  In either case, *TOTAL contains the cost result.  */\n+  /* Note that CODE and OUTER_CODE ought to be RTX_CODE, but that's\n+     not necessarily defined at this point.  */\n+  bool (* rtx_costs) PARAMS ((rtx x, int code, int outer_code, int *total));\n+\n   /* Leave the boolean fields at the end.  */\n \n   /* True if arbitrary sections are supported.  */"}]}