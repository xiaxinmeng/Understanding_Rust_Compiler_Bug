{"sha": "10a855c7f4b3347a55198395ff12f8847f0c33c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBhODU1YzdmNGIzMzQ3YTU1MTk4Mzk1ZmYxMmY4ODQ3ZjBjMzNjNg==", "commit": {"author": {"name": "Oskar Liljeblad", "email": "osk@hem.passagen.se", "date": "2001-01-09T11:21:12Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2001-01-09T11:21:12Z"}, "message": "re PR libgcj/1338 (StreamTokenizer does not handle /* comments correctly)\n\n2001-01-09  Oskar Liljeblad <osk@hem.passagen.se>\n\n\tFix for PR libgcj/1338:\n\t* java/io/StreamTokenizer.java (nextToken): Handle // and /* before\n\tcommentChar.  Fixed typos in comments.\n\nFrom-SVN: r38830", "tree": {"sha": "fea566a4cc1e53463bd374ccc3a5e377e5076266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fea566a4cc1e53463bd374ccc3a5e377e5076266"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10a855c7f4b3347a55198395ff12f8847f0c33c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a855c7f4b3347a55198395ff12f8847f0c33c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a855c7f4b3347a55198395ff12f8847f0c33c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a855c7f4b3347a55198395ff12f8847f0c33c6/comments", "author": null, "committer": null, "parents": [{"sha": "9f56ed15ce8b4fbacd1a4e1474cca34761ad8f0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f56ed15ce8b4fbacd1a4e1474cca34761ad8f0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f56ed15ce8b4fbacd1a4e1474cca34761ad8f0f"}], "stats": {"total": 104, "additions": 55, "deletions": 49}, "files": [{"sha": "880d2d72247225483c7648ab753bafbcd4de0b29", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a855c7f4b3347a55198395ff12f8847f0c33c6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a855c7f4b3347a55198395ff12f8847f0c33c6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=10a855c7f4b3347a55198395ff12f8847f0c33c6", "patch": "@@ -1,3 +1,9 @@\n+2001-01-09  Oskar Liljeblad <osk@hem.passagen.se>\n+\n+\tFix for PR libgcj/1338:\n+\t* java/io/StreamTokenizer.java (nextToken): Handle // and /* before\n+\tcommentChar.  Fixed typos in comments.\n+\n 2001-01-08  Warren Levy  <warrenl@redhat.com>\n \n \tFix for PR libgcj/1411:"}, {"sha": "347f1937ff4b085685eb7914d28eb53fbedd218e", "filename": "libjava/java/io/StreamTokenizer.java", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a855c7f4b3347a55198395ff12f8847f0c33c6/libjava%2Fjava%2Fio%2FStreamTokenizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a855c7f4b3347a55198395ff12f8847f0c33c6/libjava%2Fjava%2Fio%2FStreamTokenizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStreamTokenizer.java?ref=10a855c7f4b3347a55198395ff12f8847f0c33c6", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -231,7 +231,7 @@ private boolean isComment(int ch)\n    * The start of a comment also terminates a word.  Any character with a \n    * non-alphabetic and non-numeric attribute (such as white space, a quote,\n    * or a commet) are treated as non-alphabetic and terminate the word.\n-   * <li>If a comment charcters is parsed, then all remaining characters on\n+   * <li>If a comment character is parsed, then all remaining characters on\n    * the current line are skipped and another token is parsed.  Any EOL or\n    * EOF's encountered are not discarded, but rather terminate the comment.\n    * <li>If a quote character is parsed, then all characters up to the \n@@ -289,6 +289,50 @@ public int nextToken() throws IOException\n \t    return (ttype = TT_EOL);\n \t}\n \n+    if (ch == '/')\n+      if ((ch = in.read()) == '/' && slashSlash)\n+\t{\n+\t  while ((ch = in.read()) != '\\n' && ch != '\\r' && ch != TT_EOF)\n+\t    ;\n+\t  if (ch != TT_EOF)\n+\t    in.unread(ch);\n+\t  return nextToken(); // Recursive, but not too deep in normal cases\n+\t}\n+      else if (ch == '*' && slashStar) \n+\t{\n+\t  while (true)\n+\t    {\n+\t      ch = in.read();\n+\t      if (ch == '*')\n+\t\t{\n+\t\t  if ((ch = in.read()) == '/')\n+\t\t    break;\n+\t\t  else if (ch != TT_EOF)\n+\t\t    in.unread(ch);\n+\t\t}\n+\t      else if (ch == '\\n' || ch == '\\r')\n+\t\t{\n+\t\t  lineNumber++;\n+\t\t  if (ch == '\\r' && (ch = in.read()) != '\\n')\n+\t\t    {\n+\t\t      if (ch != TT_EOF)\n+\t\t\tin.unread(ch);\n+\t\t    }\n+\t\t}\n+\t      else if (ch == TT_EOF)\n+\t\t{\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  return nextToken(); // Recursive, but not too deep in normal cases\n+\t}\n+      else\n+\t{\n+\t  if (ch != TT_EOF)\n+\t    in.unread(ch);\n+\t  ch = '/';\n+\t}\n+\n     if (ch == TT_EOF)\n       ttype = TT_EOF;\n     else if (isNumeric(ch))\n@@ -419,50 +463,6 @@ else if (isQuote(ch))\n       }\n     else\n       {\n-        if (ch == '/')\n-\t  if ((ch = in.read()) == '/' && slashSlash)\n-\t    {\n-\t      while ((ch = in.read()) != '\\n' && ch != '\\r' && ch != TT_EOF)\n-\t\t;\n-\t      if (ch != TT_EOF)\n-\t\tin.unread(ch);\n-\t      return nextToken(); // Recursive, but not too deep in normal cases\n-\t    }\n-\t  else if (ch == '*' && slashStar) \n-\t    {\n-\t      while (true)\n-\t\t{\n-\t          ch = in.read();\n-\t\t  if (ch == '*')\n-\t\t    {\n-\t\t      if ((ch = in.read()) == '/')\n-\t\t\tbreak;\n-\t\t      else if (ch != TT_EOF)\n-\t\t\tin.unread(ch);\n-\t\t    }\n-\t\t  else if (ch == '\\n' || ch == '\\r')\n-\t\t    {\n-\t\t      lineNumber++;\n-\t\t      if (ch == '\\r' && (ch = in.read()) != '\\n')\n-\t\t\t{\n-\t\t          if (ch != TT_EOF)\n-\t\t\t    in.unread(ch);\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (ch == TT_EOF)\n-\t\t    {\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      return nextToken(); // Recursive, but not too deep in normal cases\n-\t    }\n-\t  else\n-\t    {\n-\t      if (ch != TT_EOF)\n-\t\tin.unread(ch);\n-\t      ch = '/';\n-\t    }\n-\n \tttype = ch;\n       }\n \n@@ -481,7 +481,7 @@ private void resetChar(int ch)\n    * quote, or comment) will be set on this character.  This character will\n    * parse as its own token.\n    *\n-   * @param c The charcter to make ordinary, passed as an int\n+   * @param c The character to make ordinary, passed as an int\n    */\n   public void ordinaryChar(int ch)\n   {\n@@ -626,7 +626,7 @@ else if (ttype == TT_NONE)\n   }\n \n   /**\n-   * This method sets the whitespace attribute for all charcters in the\n+   * This method sets the whitespace attribute for all characters in the\n    * specified range, range terminators included.\n    *\n    * @param low The low end of the range of values to set the whitespace\n@@ -645,7 +645,7 @@ public void whitespaceChars(int low, int hi)\n   }\n \n   /**\n-   * This method sets the alphabetic attribute for all charcters in the\n+   * This method sets the alphabetic attribute for all characters in the\n    * specified range, range terminators included.\n    *\n    * @param low The low end of the range of values to set the alphabetic"}]}