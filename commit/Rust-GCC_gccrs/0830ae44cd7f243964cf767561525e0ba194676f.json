{"sha": "0830ae44cd7f243964cf767561525e0ba194676f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgzMGFlNDRjZDdmMjQzOTY0Y2Y3Njc1NjE1MjVlMGJhMTk0Njc2Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-08-07T13:57:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-08-07T13:57:06Z"}, "message": "re PR c++/3820 (GCC 3.0 crashes with empty base class)\n\ncp:\n\tPR c++/3820\n\tStop using TYPE_NONCOPIED_PARTS.\n\t* call.c (build_over_call): Be careful when copy constructing\n\tor assigning to an empty class.\n\t* class.c (check_bases_and_members): It has a\n\tCOMPLEX_ASSIGN_REF if it has a vptr.\n\t(layout_class_type): Don't add empty class padding to\n\tTYPE_NONCOPIED_PARTS.\n\t(finish_struct_1): Don't add the VFIELD either.\n\t* cp-tree.h (TYPE_HAS_TRIVIAL_INIT_REF): Mention _copy_\n\tinitialization.\ntestsuite:\n\t* g++.dg/abi/empty4.C: New test.\n\nFrom-SVN: r44691", "tree": {"sha": "be17021c95979d0552d64010022af0cefd41ff1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be17021c95979d0552d64010022af0cefd41ff1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0830ae44cd7f243964cf767561525e0ba194676f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0830ae44cd7f243964cf767561525e0ba194676f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0830ae44cd7f243964cf767561525e0ba194676f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0830ae44cd7f243964cf767561525e0ba194676f/comments", "author": null, "committer": null, "parents": [{"sha": "24a285841212403389646af2198d1a34fd0b01e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a285841212403389646af2198d1a34fd0b01e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a285841212403389646af2198d1a34fd0b01e6"}], "stats": {"total": 166, "additions": 125, "deletions": 41}, "files": [{"sha": "b2d3d3ca53c43a29f27554ada429eeaf37c45e09", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0830ae44cd7f243964cf767561525e0ba194676f", "patch": "@@ -1,3 +1,17 @@\n+2001-08-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/3820\n+\tStop using TYPE_NONCOPIED_PARTS.\n+\t* call.c (build_over_call): Be careful when copy constructing\n+\tor assigning to an empty class.\n+\t* class.c (check_bases_and_members): It has a\n+\tCOMPLEX_ASSIGN_REF if it has a vptr.\n+\t(layout_class_type): Don't add empty class padding to\n+\tTYPE_NONCOPIED_PARTS.\n+\t(finish_struct_1): Don't add the VFIELD either.\n+\t* cp-tree.h (TYPE_HAS_TRIVIAL_INIT_REF): Mention _copy_\n+\tinitialization.\n+\n 2001-08-07  Jason Merrill  <jason_merrill@redhat.com>\n \n \t* tree.c (walk_tree): Walk siblings even if !walk_subtrees."}, {"sha": "6278095b83488b5b8a23a3893add16b26ea443b3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0830ae44cd7f243964cf767561525e0ba194676f", "patch": "@@ -4259,30 +4259,19 @@ build_over_call (cand, args, flags)\n \t    return build_target_expr_with_type (arg, DECL_CONTEXT (fn));\n \t}\n       else if (! real_lvalue_p (arg)\n-\t       || TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n+\t       /* Empty classes have padding which can be hidden\n+\t          inside an (empty) base of the class. This must not\n+\t          be touched as it might overlay things. When the\n+\t          gcc core learns about empty classes, we can treat it\n+\t          like other classes. */\n+\t       || (!is_empty_class (DECL_CONTEXT (fn))\n+\t\t   && TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn))))\n \t{\n \t  tree address;\n \t  tree to = stabilize_reference\n \t    (build_indirect_ref (TREE_VALUE (args), 0));\n \n-\t  /* If we're initializing an empty class, then we actually\n-\t     have to use a MODIFY_EXPR rather than an INIT_EXPR.  The\n-\t     reason is that the dummy padding member in the target may\n-\t     not actually be allocated if TO is a base class\n-\t     subobject.  Since we've set TYPE_NONCOPIED_PARTS on the\n-\t     padding, a MODIFY_EXPR will preserve its value, which is\n-\t     the right thing to do if it's not really padding at all.\n-\t  \n-\t     It's not safe to just throw away the ARG if we're looking\n-\t     at an empty class because the ARG might contain a\n-\t     TARGET_EXPR which wants to be bound to TO.  If it is not,\n-\t     expand_expr will assign a dummy slot for the TARGET_EXPR,\n-\t     and we will call a destructor for it, which is wrong,\n-\t     because we will also destroy TO, but will never have\n-\t     constructed it.  */\n-\t  val = build (is_empty_class (DECL_CONTEXT (fn))\n-\t\t       ? MODIFY_EXPR : INIT_EXPR, \n-\t\t       DECL_CONTEXT (fn), to, arg);\n+\t  val = build (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n \t  address = build_unary_op (ADDR_EXPR, val, 0);\n \t  /* Avoid a warning about this expression, if the address is\n \t     never used.  */\n@@ -4298,8 +4287,14 @@ build_over_call (cand, args, flags)\n \t(build_indirect_ref (TREE_VALUE (converted_args), 0));\n \n       arg = build_indirect_ref (TREE_VALUE (TREE_CHAIN (converted_args)), 0);\n+      if (is_empty_class (TREE_TYPE (to)))\n+\t{\n+\t  TREE_USED (arg) = 1;\n \n-      val = build (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n+\t  val = build (COMPOUND_EXPR, DECL_CONTEXT (fn), arg, to);\n+\t}\n+      else\n+\tval = build (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n       return val;\n     }\n "}, {"sha": "a187bc36418d420b4436e66c17bf3324518e8668", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0830ae44cd7f243964cf767561525e0ba194676f", "patch": "@@ -4386,7 +4386,7 @@ check_bases_and_members (t, empty_p)\n \t|| TYPE_HAS_ASSIGN_REF (t));\n   TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n-    |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);\n+    |= TYPE_HAS_ASSIGN_REF (t) || TYPE_CONTAINS_VPTR_P (t);\n \n   /* Synthesize any needed methods.  Note that methods will be synthesized\n      for anonymous unions; grok_x_components undoes that.  */\n@@ -4877,8 +4877,7 @@ layout_class_type (t, empty_p, vfuns_p,\n     CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n   \n   /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n-     we have to save this before we start modifying\n-     TYPE_NONCOPIED_PARTS.  */\n+     we have to save this before we zap TYPE_NONCOPIED_PARTS.  */\n   fixup_inline_methods (t);\n \n   /* Layout the non-static data members.  */\n@@ -4974,9 +4973,6 @@ layout_class_type (t, empty_p, vfuns_p,\n \n       padding = build_decl (FIELD_DECL, NULL_TREE, char_type_node);\n       place_field (rli, padding);\n-      TYPE_NONCOPIED_PARTS (t) \n-\t= tree_cons (NULL_TREE, padding, TYPE_NONCOPIED_PARTS (t));\n-      TREE_STATIC (TYPE_NONCOPIED_PARTS (t)) = 1;\n     }\n \n   /* Let the back-end lay out the type. Note that at this point we\n@@ -5233,20 +5229,9 @@ finish_struct_1 (t)\n   /* Build the VTT for T.  */\n   build_vtt (t);\n \n-  if (TYPE_VFIELD (t))\n-    {\n-      /* In addition to this one, all the other vfields should be listed.  */\n-      /* Before that can be done, we have to have FIELD_DECLs for them, and\n-\t a place to find them.  */\n-      TYPE_NONCOPIED_PARTS (t) \n-\t= tree_cons (default_conversion (TYPE_BINFO_VTABLE (t)),\n-\t\t     TYPE_VFIELD (t), TYPE_NONCOPIED_PARTS (t));\n-\n-      if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (t)\n-\t  && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1)) == NULL_TREE)\n-\tcp_warning (\"`%#T' has virtual functions but non-virtual destructor\",\n-\t\t    t);\n-    }\n+  if (warn_nonvdtor && TYPE_POLYMORPHIC_P (t) && TYPE_HAS_DESTRUCTOR (t)\n+      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1)) == NULL_TREE)\n+    cp_warning (\"`%#T' has virtual functions but non-virtual destructor\", t);\n \n   hack_incomplete_structures (t);\n "}, {"sha": "fd079d232abe6ac37c501fd914dd5bc273403544", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0830ae44cd7f243964cf767561525e0ba194676f", "patch": "@@ -2469,7 +2469,7 @@ extern int flag_new_for_scope;\n #define TYPE_HAS_NONTRIVIAL_DESTRUCTOR(NODE) \\\n   (TYPE_LANG_FLAG_4(NODE))\n \n-/* Nonzero for class type means that initialization of this type can use\n+/* Nonzero for class type means that copy initialization of this type can use\n    a bitwise copy.  */\n #define TYPE_HAS_TRIVIAL_INIT_REF(NODE) \\\n   (TYPE_HAS_INIT_REF (NODE) && ! TYPE_HAS_COMPLEX_INIT_REF (NODE))"}, {"sha": "c5058bd70d5bcf0d326d5222bdb4578b5910078b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0830ae44cd7f243964cf767561525e0ba194676f", "patch": "@@ -1,3 +1,7 @@\n+2001-08-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/abi/empty4.C: New test.\n+\n 2001-08-06  David Billinghurst  <David.Billinghurst@riotinto.com>\n \n \t* g77.f-torture/execute/f90-intrinsic-bit.x: XFAIL on irix6.* and"}, {"sha": "39ab9c5e437c847f4c830c8ae946e9a9b34ebca9", "filename": "gcc/testsuite/g++.dg/abi/empty4.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830ae44cd7f243964cf767561525e0ba194676f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty4.C?ref=0830ae44cd7f243964cf767561525e0ba194676f", "patch": "@@ -0,0 +1,86 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 31 Jul 2001 <nathan@codesourcery.com>\n+\n+// Bug 3820. We were bit copying empty bases including the\n+// padding. Which clobbers whatever they overlay.\n+\n+struct Empty {};\n+\n+struct Inter : Empty {};\n+\n+int now = 0;\n+\n+struct NonPod\n+{\n+  int m;\n+\n+  NonPod () {m = 0x12345678;}\n+  NonPod (int m_) {m = m_;}\n+  NonPod &operator= (NonPod const &src) {now = m; m = src.m;}\n+  NonPod (NonPod const &src) {m = src.m;}\n+};\n+\n+struct A : Inter\n+{\n+  A (int c) {m = c;}\n+  \n+  NonPod m;\n+};\n+\n+struct B\n+{\n+  Inter empty;\n+  NonPod m;\n+\n+  B (int c) {m = c;}\n+};\n+\n+struct C : NonPod, Inter\n+{\n+  C (int c) : NonPod (c), Inter () {}\n+};\n+\n+int main ()\n+{\n+  A a (0x12131415);\n+  \n+  int was = a.m.m;\n+  \n+  a = 0x22232425;\n+\n+  if (was != now)\n+    return 1;\t// we copied the empty base which clobbered a.m.m's\n+\t\t// original value.\n+  \n+  A b (0x32333435);\n+  *(Inter *)&a = *(Inter *)&b;\n+  \n+  if (a.m.m != 0x22232425)\n+    return 2;\t// we copied padding, which clobbered a.m.m\n+\n+  A b2 (0x32333435);\n+  (Inter &)b2 = Inter ();\n+  if (b2.m.m != 0x32333435)\n+    return 2;\t// we copied padding, which clobbered b2.m.m\n+  \n+  B c (0x12131415);\n+  was = c.m.m;\n+  c = 0x22232425;\n+  if (was != now)\n+    return 3;\n+  \n+  B d (0x32333435);\n+  c.empty = d.empty;\n+\n+  if (c.m.m != 0x22232425)\n+    return 4;\n+\n+  C e (0x32333435);\n+\n+  if (e.m != 0x32333435)\n+    return 2;\t// we copied padding\n+  \n+  return 0;\n+}"}]}