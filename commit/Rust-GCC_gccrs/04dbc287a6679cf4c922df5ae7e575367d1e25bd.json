{"sha": "04dbc287a6679cf4c922df5ae7e575367d1e25bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRkYmMyODdhNjY3OWNmNGM5MjJkZjVhZTdlNTc1MzY3ZDFlMjViZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2011-12-30T18:08:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-12-30T18:08:56Z"}, "message": "libgcov.c (gcov_crc32): Remove global var.\n\n\t* libgcov.c (gcov_crc32): Remove global var.\n\t(free_fn_data): New function.\n\t(buffer_fn_data): Pass in filename, more robust error recovery.\n\t(crc32_unsigned): New function.\n\t(gcov_exit): More robust detection of new program. More robust\n\terror recovery.\n\t(__gcov_init): Do not update program's crc here.\n\nFrom-SVN: r182743", "tree": {"sha": "c7ea31b85836773aaf801df12303fd2c6f04d6f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7ea31b85836773aaf801df12303fd2c6f04d6f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04dbc287a6679cf4c922df5ae7e575367d1e25bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04dbc287a6679cf4c922df5ae7e575367d1e25bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04dbc287a6679cf4c922df5ae7e575367d1e25bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04dbc287a6679cf4c922df5ae7e575367d1e25bd/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "84de2982de7e43702bcb161191179b79406ae39c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84de2982de7e43702bcb161191179b79406ae39c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84de2982de7e43702bcb161191179b79406ae39c"}], "stats": {"total": 238, "additions": 145, "deletions": 93}, "files": [{"sha": "51cd7179c7493e78aa52e6fb3686cdebd72ef10c", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dbc287a6679cf4c922df5ae7e575367d1e25bd/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dbc287a6679cf4c922df5ae7e575367d1e25bd/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=04dbc287a6679cf4c922df5ae7e575367d1e25bd", "patch": "@@ -1,3 +1,13 @@\n+2011-12-30  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* libgcov.c (gcov_crc32): Remove global var.\n+\t(free_fn_data): New function.\n+\t(buffer_fn_data): Pass in filename, more robust error recovery.\n+\t(crc32_unsigned): New function.\n+\t(gcov_exit): More robust detection of new program. More robust\n+\terror recovery.\n+\t(__gcov_init): Do not update program's crc here.\n+\n 2011-12-21  Tristan Gingold  <gingold@adacore.com>\n \n \t* config/ia64/fde-vms.c (UNW_IVMS_MODE): Define."}, {"sha": "810175aafcfaaebdeb1cd362dfb26c8368eb6079", "filename": "libgcc/libgcov.c", "status": "modified", "additions": 135, "deletions": 93, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dbc287a6679cf4c922df5ae7e575367d1e25bd/libgcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dbc287a6679cf4c922df5ae7e575367d1e25bd/libgcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.c?ref=04dbc287a6679cf4c922df5ae7e575367d1e25bd", "patch": "@@ -89,10 +89,6 @@ struct gcov_fn_buffer\n /* Chain of per-object gcov structures.  */\n static struct gcov_info *gcov_list;\n \n-/* A program checksum allows us to distinguish program data for an\n-   object file included in multiple programs.  */\n-static gcov_unsigned_t gcov_crc32;\n-\n /* Size of the longest file name. */\n static size_t gcov_max_filename = 0;\n \n@@ -143,22 +139,41 @@ create_file_directory (char *filename)\n #endif\n }\n \n+static struct gcov_fn_buffer *\n+free_fn_data (const struct gcov_info *gi_ptr, struct gcov_fn_buffer *buffer,\n+\t      unsigned limit)\n+{\n+  struct gcov_fn_buffer *next;\n+  unsigned ix, n_ctr = 0;\n+  \n+  if (!buffer)\n+    return 0;\n+  next = buffer->next;\n+\n+  for (ix = 0; ix != limit; ix++)\n+    if (gi_ptr->merge[ix])\n+      free (buffer->info.ctrs[n_ctr++].values);\n+  free (buffer);\n+  return next;\n+}\n+  \n static struct gcov_fn_buffer **\n-buffer_fn_data (struct gcov_info *gi_ptr, struct gcov_fn_buffer **end_ptr,\n-\t\tunsigned fn_ix)\n+buffer_fn_data (const char *filename, const struct gcov_info *gi_ptr,\n+\t\tstruct gcov_fn_buffer **end_ptr, unsigned fn_ix)\n {\n-  unsigned n_ctrs = 0, ix;\n+  unsigned n_ctrs = 0, ix = 0;\n   struct gcov_fn_buffer *fn_buffer;\n+  unsigned len;\n \n   for (ix = GCOV_COUNTERS; ix--;)\n     if (gi_ptr->merge[ix])\n       n_ctrs++;\n \n-  fn_buffer = (struct gcov_fn_buffer *)malloc\n-    (sizeof (*fn_buffer) + sizeof (fn_buffer->info.ctrs[0]) * n_ctrs);\n+  len = sizeof (*fn_buffer) + sizeof (fn_buffer->info.ctrs[0]) * n_ctrs;\n+  fn_buffer = (struct gcov_fn_buffer *)malloc (len);\n \n   if (!fn_buffer)\n-    return 0; /* We'll horribly fail.  */\n+    goto fail;\n   \n   fn_buffer->next = 0;\n   fn_buffer->fn_ix = fn_ix;\n@@ -175,16 +190,17 @@ buffer_fn_data (struct gcov_info *gi_ptr, struct gcov_fn_buffer **end_ptr,\n \tcontinue;\n       \n       if (gcov_read_unsigned () != GCOV_TAG_FOR_COUNTER (ix))\n-\tgoto fail;\n-\n-      length = GCOV_TAG_COUNTER_NUM (gcov_read_unsigned ());\n-      values = (gcov_type *)malloc (length * sizeof (gcov_type));\n-      if (!values)\n \t{\n-\t  while (n_ctrs--)\n-\t    free (fn_buffer->info.ctrs[n_ctrs].values);\n+\t  len = 0;\n \t  goto fail;\n \t}\n+\n+      length = GCOV_TAG_COUNTER_NUM (gcov_read_unsigned ());\n+      len = length * sizeof (gcov_type);\n+      values = (gcov_type *)malloc (len);\n+      if (!values)\n+\tgoto fail;\n+      \n       fn_buffer->info.ctrs[n_ctrs].num = length;\n       fn_buffer->info.ctrs[n_ctrs].values = values;\n \n@@ -197,8 +213,29 @@ buffer_fn_data (struct gcov_info *gi_ptr, struct gcov_fn_buffer **end_ptr,\n   return &fn_buffer->next;\n \n  fail:\n-  free (fn_buffer);\n-  return 0;\n+  fprintf (stderr, \"profiling:%s:Function %u %s %u \\n\", filename, fn_ix,\n+\t   len ? \"cannot allocate\" : \"counter mismatch\", len ? len : ix);\n+\n+  return (struct gcov_fn_buffer **)free_fn_data (gi_ptr, fn_buffer, ix);\n+}\n+\n+/* Add an unsigned value to the current crc */\n+\n+static gcov_unsigned_t\n+crc32_unsigned (gcov_unsigned_t crc32, gcov_unsigned_t value)\n+{\n+  unsigned ix;\n+\n+  for (ix = 32; ix--; value <<= 1)\n+    {\n+      unsigned feedback;\n+\n+      feedback = (value ^ crc32) & 0x80000000 ? 0x04c11db7 : 0;\n+      crc32 <<= 1;\n+      crc32 ^= feedback;\n+    }\n+\n+  return crc32;\n }\n \n /* Check if VERSION of the info block PTR matches libgcov one.\n@@ -241,41 +278,56 @@ gcov_exit (void)\n   struct gcov_summary all_prg;  /* summary for all instances of program.  */\n   struct gcov_ctr_summary *cs_ptr;\n   const struct gcov_ctr_info *ci_ptr;\n-  unsigned t_ix, f_ix;\n+  unsigned t_ix;\n+  int f_ix;\n   gcov_unsigned_t c_num;\n   const char *gcov_prefix;\n   int gcov_prefix_strip = 0;\n   size_t prefix_length;\n   char *gi_filename, *gi_filename_up;\n+  gcov_unsigned_t crc32 = 0;\n \n   memset (&all_prg, 0, sizeof (all_prg));\n   /* Find the totals for this execution.  */\n   memset (&this_prg, 0, sizeof (this_prg));\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n-    for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n-      {\n-\tgfi_ptr = gi_ptr->functions[f_ix];\n-\t\n-\tif (!gfi_ptr || gfi_ptr->key != gi_ptr)\n-\t  continue;\n-\t\n-\tci_ptr = gfi_ptr->ctrs;\n-\tfor (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n-\t  {\n-\t    if (!gi_ptr->merge[t_ix])\n-\t      continue;\n+    {\n+      crc32 = crc32_unsigned (crc32, gi_ptr->stamp);\n+      crc32 = crc32_unsigned (crc32, gi_ptr->n_functions);\n+      \n+      for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n+\t{\n+\t  gfi_ptr = gi_ptr->functions[f_ix];\n \n-\t    cs_ptr = &this_prg.ctrs[t_ix];\n-\t    cs_ptr->num += ci_ptr->num;\n-\t    for (c_num = 0; c_num < ci_ptr->num; c_num++)\n-\t      {\n-\t\tcs_ptr->sum_all += ci_ptr->values[c_num];\n-\t\tif (cs_ptr->run_max < ci_ptr->values[c_num])\n-\t\t  cs_ptr->run_max = ci_ptr->values[c_num];\n-\t      }\n-\t    ci_ptr++;\n-\t  }\n-      }\n+\t  if (gfi_ptr && gfi_ptr->key != gi_ptr)\n+\t    gfi_ptr = 0;\n+\t  \n+\t  crc32 = crc32_unsigned (crc32, gfi_ptr ? gfi_ptr->cfg_checksum : 0);\n+\t  crc32 = crc32_unsigned (crc32,\n+\t\t\t\t  gfi_ptr ? gfi_ptr->lineno_checksum : 0);\n+\t  if (!gfi_ptr)\n+\t    continue;\n+\n+\t  ci_ptr = gfi_ptr->ctrs;\n+\t  for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n+\t    {\n+\t      if (!gi_ptr->merge[t_ix])\n+\t\tcontinue;\n+\n+\t      cs_ptr = &this_prg.ctrs[t_ix];\n+\t      cs_ptr->num += ci_ptr->num;\n+\t      crc32 = crc32_unsigned (crc32, ci_ptr->num);\n+\t      \n+\t      for (c_num = 0; c_num < ci_ptr->num; c_num++)\n+\t\t{\n+\t\t  cs_ptr->sum_all += ci_ptr->values[c_num];\n+\t\t  if (cs_ptr->run_max < ci_ptr->values[c_num])\n+\t\t    cs_ptr->run_max = ci_ptr->values[c_num];\n+\t\t}\n+\t      ci_ptr++;\n+\t    }\n+\t}\n+    }\n \n   {\n     /* Check if the level of dirs to strip off specified. */\n@@ -400,7 +452,7 @@ gcov_exit (void)\n \t    goto rewrite;\n \n \t  /* Look for program summary.  */\n-\t  for (f_ix = ~0u;;)\n+\t  for (f_ix = 0;;)\n \t    {\n \t      struct gcov_summary tmp;\n \t      \n@@ -409,29 +461,35 @@ gcov_exit (void)\n \t      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n \t\tbreak;\n \n+\t      f_ix--;\n \t      length = gcov_read_unsigned ();\n \t      if (length != GCOV_TAG_SUMMARY_LENGTH)\n \t\tgoto read_mismatch;\n \t      gcov_read_summary (&tmp);\n \t      if ((error = gcov_is_error ()))\n \t\tgoto read_error;\n-\t      if (!summary_pos && tmp.checksum == gcov_crc32)\n-\t\t{\n-\t\t  prg = tmp;\n-\t\t  summary_pos = eof_pos;\n-\t\t}\n+\t      if (summary_pos || tmp.checksum != crc32)\n+\t\tgoto next_summary;\n+\t      \n+\t      for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n+\t\tif (tmp.ctrs[t_ix].num != this_prg.ctrs[t_ix].num)\n+\t\t  goto next_summary;\n+\t      prg = tmp;\n+\t      summary_pos = eof_pos;\n+\n+\t    next_summary:;\n \t    }\n \t  \n \t  /* Merge execution counts for each function.  */\n-\t  for (f_ix = 0; f_ix != gi_ptr->n_functions;\n+\t  for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions;\n \t       f_ix++, tag = gcov_read_unsigned ())\n \t    {\n \t      gfi_ptr = gi_ptr->functions[f_ix];\n \n \t      if (tag != GCOV_TAG_FUNCTION)\n \t\tgoto read_mismatch;\n-\t      length = gcov_read_unsigned ();\n \n+\t      length = gcov_read_unsigned ();\n \t      if (!length)\n \t\t/* This function did not appear in the other program.\n \t\t   We have nothing to merge.  */\n@@ -447,15 +505,23 @@ gcov_exit (void)\n \t\t     it back out -- we'll be inserting data before\n \t\t     this point, so cannot simply keep the data in the\n \t\t     file.  */\n-\t\t  fn_tail = buffer_fn_data (gi_ptr, fn_tail, f_ix);\n+\t\t  fn_tail = buffer_fn_data (gi_filename,\n+\t\t\t\t\t    gi_ptr, fn_tail, f_ix);\n \t\t  if (!fn_tail)\n \t\t    goto read_mismatch;\n \t\t  continue;\n \t\t}\n \n-\t      if (gcov_read_unsigned () != gfi_ptr->ident\n-\t\t  || gcov_read_unsigned () != gfi_ptr->lineno_checksum\n-\t\t  || gcov_read_unsigned () != gfi_ptr->cfg_checksum)\n+\t      length = gcov_read_unsigned ();\n+\t      if (length != gfi_ptr->ident)\n+\t\tgoto read_mismatch;\n+\t      \n+\t      length = gcov_read_unsigned ();\n+\t      if (length != gfi_ptr->lineno_checksum)\n+\t\tgoto read_mismatch;\n+\t      \n+\t      length = gcov_read_unsigned ();\n+\t      if (length != gfi_ptr->cfg_checksum)\n \t\tgoto read_mismatch;\n \t      \n \t      ci_ptr = gfi_ptr->ctrs;\n@@ -481,8 +547,9 @@ gcov_exit (void)\n \t  if (tag)\n \t    {\n \t    read_mismatch:;\n-\t      fprintf (stderr, \"profiling:%s:Merge mismatch for %s\\n\",\n-\t\t       gi_filename, f_ix + 1 ? \"function\" : \"summaries\");\n+\t      fprintf (stderr, \"profiling:%s:Merge mismatch for %s %u\\n\",\n+\t\t       gi_filename, f_ix >= 0 ? \"function\" : \"summary\",\n+\t\t       f_ix < 0 ? -1 - f_ix : f_ix);\n \t      goto read_fatal;\n \t    }\n \t}\n@@ -492,9 +559,7 @@ gcov_exit (void)\n       fprintf (stderr, \"profiling:%s:%s merging\\n\", gi_filename,\n \t       error < 0 ? \"Overflow\": \"Error\");\n \n-    read_fatal:;\n-      gcov_close ();\n-      continue;\n+      goto read_fatal;\n \n     rewrite:;\n       gcov_rewrite ();\n@@ -515,8 +580,6 @@ gcov_exit (void)\n \t    {\n \t      if (!cs_prg->runs++)\n \t\tcs_prg->num = cs_tprg->num;\n-\t      else if (cs_prg->num != cs_tprg->num)\n-\t\tgoto read_mismatch;\n \t      cs_prg->sum_all += cs_tprg->sum_all;\n \t      if (cs_prg->run_max < cs_tprg->run_max)\n \t\tcs_prg->run_max = cs_tprg->run_max;\n@@ -538,7 +601,7 @@ gcov_exit (void)\n \t    }\n \t}\n \n-      prg.checksum = gcov_crc32;\n+      prg.checksum = crc32;\n \n       /* Write out the data.  */\n       if (!eof_pos)\n@@ -557,11 +620,11 @@ gcov_exit (void)\n \tgcov_seek (eof_pos);\n \n       /* Write execution counts for each function.  */\n-      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n+      for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n \t{\n \t  unsigned buffered = 0;\n \n-\t  if (fn_buffer && fn_buffer->fn_ix == f_ix)\n+\t  if (fn_buffer && fn_buffer->fn_ix == (unsigned)f_ix)\n \t    {\n \t      /* Buffered data from another program.  */\n \t      buffered = 1;\n@@ -597,19 +660,18 @@ gcov_exit (void)\n \t      gcov_type *c_ptr = ci_ptr->values;\n \t      while (n_counts--)\n \t\tgcov_write_counter (*c_ptr++);\n-\t      if (buffered)\n-\t\tfree (ci_ptr->values);\n \t      ci_ptr++;\n \t    }\n \t  if (buffered)\n-\t    {\n-\t      struct gcov_fn_buffer *tmp = fn_buffer;\n-\t      fn_buffer = fn_buffer->next;\n-\t      free (tmp);\n-\t    }\n+\t    fn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);\n \t}\n \n       gcov_write_unsigned (0);\n+\n+    read_fatal:;\n+      while (fn_buffer)\n+\tfn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);\n+\n       if ((error = gcov_close ()))\n \t  fprintf (stderr, error  < 0 ?\n \t\t   \"profiling:%s:Overflow writing\\n\" :\n@@ -628,32 +690,12 @@ __gcov_init (struct gcov_info *info)\n     return;\n   if (gcov_version (info, info->version, 0))\n     {\n-      const char *ptr = info->filename;\n-      gcov_unsigned_t crc32 = gcov_crc32;\n-      size_t filename_length =  strlen(info->filename);\n+      size_t filename_length = strlen(info->filename);\n \n       /* Refresh the longest file name information */\n       if (filename_length > gcov_max_filename)\n         gcov_max_filename = filename_length;\n \n-      do\n-\t{\n-\t  unsigned ix;\n-\t  gcov_unsigned_t value = *ptr << 24;\n-\n-\t  for (ix = 8; ix--; value <<= 1)\n-\t    {\n-\t      gcov_unsigned_t feedback;\n-\n-\t      feedback = (value ^ crc32) & 0x80000000 ? 0x04c11db7 : 0;\n-\t      crc32 <<= 1;\n-\t      crc32 ^= feedback;\n-\t    }\n-\t}\n-      while (*ptr++);\n-\n-      gcov_crc32 = crc32;\n-\n       if (!gcov_list)\n \tatexit (gcov_exit);\n "}]}