{"sha": "ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQzY2Q5NDM1YzEyZmJiNzJlMDE2ZjY2ZDc2NmVjZjNiYzE2ZWM1Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-21T00:11:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-21T00:11:53Z"}, "message": "compiler: Only make function descriptors if needed.\n\nFrom-SVN: r200273", "tree": {"sha": "8ba3b0e226b435f1bd100cda1a3a66dbefeab8c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ba3b0e226b435f1bd100cda1a3a66dbefeab8c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/comments", "author": null, "committer": null, "parents": [{"sha": "07a6825b5f49ab65ea4ca12ecd41f26409e80f54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a6825b5f49ab65ea4ca12ecd41f26409e80f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a6825b5f49ab65ea4ca12ecd41f26409e80f54"}], "stats": {"total": 361, "additions": 252, "deletions": 109}, "files": [{"sha": "240e4558d9d83c26fc22da2bf55e385d426bcdfa", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 37, "deletions": 55, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "patch": "@@ -1385,62 +1385,24 @@ Expression::make_func_reference(Named_object* function, Expression* closure,\n   return new Func_expression(function, closure, location);\n }\n \n-// A function descriptor.  A function descriptor is a struct with a\n-// single field pointing to the function code.  This is used for\n-// functions without closures.\n+// Class Func_descriptor_expression.\n \n-class Func_descriptor_expression : public Expression\n-{\n- public:\n-  Func_descriptor_expression(Named_object* fn, Named_object* dfn)\n-    : Expression(EXPRESSION_FUNC_DESCRIPTOR, fn->location()),\n-      fn_(fn), dfn_(dfn), dvar_(NULL)\n-  {\n-    go_assert(!fn->is_function() || !fn->func_value()->needs_closure());\n-  }\n-\n-  // Make the function descriptor type, so that it can be converted.\n-  static void\n-  make_func_descriptor_type();\n-\n- protected:\n-  int\n-  do_traverse(Traverse*)\n-  { return TRAVERSE_CONTINUE; }\n-\n-  Type*\n-  do_type();\n-\n-  void\n-  do_determine_type(const Type_context*)\n-  { }\n-\n-  Expression*\n-  do_copy()\n-  { return Expression::make_func_descriptor(this->fn_, this->dfn_); }\n-\n-  bool\n-  do_is_addressable() const\n-  { return true; }\n+// Constructor.\n \n-  tree\n-  do_get_tree(Translate_context*);\n+Func_descriptor_expression::Func_descriptor_expression(Named_object* fn)\n+  : Expression(EXPRESSION_FUNC_DESCRIPTOR, fn->location()),\n+    fn_(fn), dfn_(NULL), dvar_(NULL)\n+{\n+  go_assert(!fn->is_function() || !fn->func_value()->needs_closure());\n+}\n \n-  void\n-  do_dump_expression(Ast_dump_context* context) const\n-  { context->ostream() << \"[descriptor \" << this->fn_->name() << \"]\"; }\n+// Traversal.\n \n- private:\n-  // The type of all function descriptors.\n-  static Type* descriptor_type;\n-\n-  // The function for which this is the descriptor.\n-  Named_object* fn_;\n-  // The descriptor function.\n-  Named_object* dfn_;\n-  // The descriptor variable.\n-  Bvariable* dvar_;\n-};\n+int\n+Func_descriptor_expression::do_traverse(Traverse*)\n+{\n+  return TRAVERSE_CONTINUE;\n+}\n \n // All function descriptors have the same type.\n \n@@ -1464,6 +1426,18 @@ Func_descriptor_expression::do_type()\n   return Func_descriptor_expression::descriptor_type;\n }\n \n+// Copy a Func_descriptor_expression;\n+\n+Expression*\n+Func_descriptor_expression::do_copy()\n+{\n+  Func_descriptor_expression* fde =\n+    Expression::make_func_descriptor(this->fn_);\n+  if (this->dfn_ != NULL)\n+    fde->set_descriptor_wrapper(this->dfn_);\n+  return fde;\n+}\n+\n // The tree for a function descriptor.\n \n tree\n@@ -1519,12 +1493,20 @@ Func_descriptor_expression::do_get_tree(Translate_context* context)\n   return var_to_tree(bvar);\n }\n \n+// Print a function descriptor expression.\n+\n+void\n+Func_descriptor_expression::do_dump_expression(Ast_dump_context* context) const\n+{\n+  context->ostream() << \"[descriptor \" << this->fn_->name() << \"]\";\n+}\n+\n // Make a function descriptor expression.\n \n-Expression*\n-Expression::make_func_descriptor(Named_object* fn, Named_object* dfn)\n+Func_descriptor_expression*\n+Expression::make_func_descriptor(Named_object* fn)\n {\n-  return new Func_descriptor_expression(fn, dfn);\n+  return new Func_descriptor_expression(fn);\n }\n \n // Make the function descriptor type, so that it can be converted."}, {"sha": "133b23789b55a286331a2c900f1f99c5a5c40263", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 61, "deletions": 4, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "patch": "@@ -32,6 +32,7 @@ class String_expression;\n class Binary_expression;\n class Call_expression;\n class Func_expression;\n+class Func_descriptor_expression;\n class Unknown_expression;\n class Index_expression;\n class Map_index_expression;\n@@ -161,10 +162,9 @@ class Expression\n   // Make a function descriptor, an immutable struct with a single\n   // field that points to the function code.  This may only be used\n   // with functions that do not have closures.  FN is the function for\n-  // which we are making the descriptor.  DFN is the descriptor\n-  // function wrapper.\n-  static Expression*\n-  make_func_descriptor(Named_object* fn, Named_object* dfn);\n+  // which we are making the descriptor.\n+  static Func_descriptor_expression*\n+  make_func_descriptor(Named_object* fn);\n \n   // Make a reference to the code of a function.  This is used to set\n   // descriptor and closure fields.\n@@ -1562,6 +1562,63 @@ class Func_expression : public Expression\n   Expression* closure_;\n };\n \n+// A function descriptor.  A function descriptor is a struct with a\n+// single field pointing to the function code.  This is used for\n+// functions without closures.\n+\n+class Func_descriptor_expression : public Expression\n+{\n+ public:\n+  Func_descriptor_expression(Named_object* fn);\n+\n+  // Set the descriptor wrapper.\n+  void\n+  set_descriptor_wrapper(Named_object* dfn)\n+  {\n+    go_assert(this->dfn_ == NULL);\n+    this->dfn_ = dfn;\n+  }\n+\n+  // Make the function descriptor type, so that it can be converted.\n+  static void\n+  make_func_descriptor_type();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy();\n+\n+  bool\n+  do_is_addressable() const\n+  { return true; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+  void\n+  do_dump_expression(Ast_dump_context* context) const;\n+\n+ private:\n+  // The type of all function descriptors.\n+  static Type* descriptor_type;\n+\n+  // The function for which this is the descriptor.\n+  Named_object* fn_;\n+  // The descriptor function.\n+  Named_object* dfn_;\n+  // The descriptor variable.\n+  Bvariable* dvar_;\n+};\n+\n // A reference to an unknown name.\n \n class Unknown_expression : public Parser_expression"}, {"sha": "55b4dca857929b5082b7fe20041bf8409f732082", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "patch": "@@ -91,6 +91,9 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n   // form which is easier to use.\n   ::gogo->lower_parse_tree();\n \n+  // Create function descriptors as needed.\n+  ::gogo->create_function_descriptors();\n+\n   // Write out queued up functions for hash and comparison of types.\n   ::gogo->write_specific_type_functions();\n "}, {"sha": "d005fb86156e6b563b27f7d55f89ee09c07f3e52", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 142, "deletions": 45, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "patch": "@@ -1608,14 +1608,6 @@ Lower_parse_tree::function(Named_object* no)\n {\n   no->func_value()->set_closure_type();\n \n-  // Make sure that every externally visible function has a\n-  // descriptor, so that packages that import this one can refer to\n-  // it.\n-  if (!Gogo::is_hidden_name(no->name())\n-      && !no->func_value()->is_method()\n-      && !no->func_value()->is_descriptor_wrapper())\n-    no->func_value()->descriptor(this->gogo_, no);\n-\n   go_assert(this->function_ == NULL);\n   this->function_ = no;\n   int t = no->func_value()->traverse(this);\n@@ -1703,28 +1695,6 @@ Lower_parse_tree::expression(Expression** pexpr)\n void\n Gogo::lower_parse_tree()\n {\n-  // Create a function descriptor for any function that is declared in\n-  // this package.  This is so that we have a descriptor for functions\n-  // written in assembly.  Gather the descriptors first so that we\n-  // don't add declarations while looping over them.\n-  std::vector<Named_object*> fndecls;\n-  Bindings* b = this->package_->bindings();\n-  for (Bindings::const_declarations_iterator p = b->begin_declarations();\n-       p != b->end_declarations();\n-       ++p)\n-    {\n-      Named_object* no = p->second;\n-      if (no->is_function_declaration()\n-\t  && !no->func_declaration_value()->type()->is_method()\n-\t  && !Linemap::is_predeclared_location(no->location()))\n-\tfndecls.push_back(no);\n-    }\n-  for (std::vector<Named_object*>::const_iterator p = fndecls.begin();\n-       p != fndecls.end();\n-       ++p)\n-    (*p)->func_declaration_value()->descriptor(this, *p);\n-  fndecls.clear();\n-\n   Lower_parse_tree lower_parse_tree(this, NULL);\n   this->traverse(&lower_parse_tree);\n }\n@@ -1763,6 +1733,121 @@ Gogo::lower_constant(Named_object* no)\n   lower.constant(no, false);\n }\n \n+// Traverse the tree to create function descriptors as needed.\n+\n+class Create_function_descriptors : public Traverse\n+{\n+ public:\n+  Create_function_descriptors(Gogo* gogo)\n+    : Traverse(traverse_functions | traverse_expressions),\n+      gogo_(gogo)\n+  { }\n+\n+  int\n+  function(Named_object*);\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  Gogo* gogo_;\n+};\n+\n+// Create a descriptor for every top-level exported function.\n+\n+int\n+Create_function_descriptors::function(Named_object* no)\n+{\n+  if (no->is_function()\n+      && no->func_value()->enclosing() == NULL\n+      && !no->func_value()->is_method()\n+      && !no->func_value()->is_descriptor_wrapper()\n+      && !Gogo::is_hidden_name(no->name()))\n+    no->func_value()->descriptor(this->gogo_, no);\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// If we see a function referenced in any way other than calling it,\n+// create a descriptor for it.\n+\n+int\n+Create_function_descriptors::expression(Expression** pexpr)\n+{\n+  Expression* expr = *pexpr;\n+\n+  Func_expression* fe = expr->func_expression();\n+  if (fe != NULL)\n+    {\n+      // We would not get here for a call to this function, so this is\n+      // a reference to a function other than calling it.  We need a\n+      // descriptor.\n+      if (fe->closure() != NULL)\n+\treturn TRAVERSE_CONTINUE;\n+      Named_object* no = fe->named_object();\n+      if (no->is_function() && !no->func_value()->is_method())\n+\tno->func_value()->descriptor(this->gogo_, no);\n+      else if (no->is_function_declaration()\n+\t       && !no->func_declaration_value()->type()->is_method()\n+\t       && !Linemap::is_predeclared_location(no->location()))\n+\tno->func_declaration_value()->descriptor(this->gogo_, no);\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n+  Call_expression* ce = expr->call_expression();\n+  if (ce != NULL)\n+    {\n+      Expression* fn = ce->fn();\n+      if (fn->func_expression() != NULL)\n+\t{\n+\t  // Traverse the arguments but not the function.\n+\t  Expression_list* args = ce->args();\n+\t  if (args != NULL)\n+\t    {\n+\t      if (args->traverse(this) == TRAVERSE_EXIT)\n+\t\treturn TRAVERSE_EXIT;\n+\t    }\n+\t  return TRAVERSE_SKIP_COMPONENTS;\n+\t}\n+    }\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Create function descriptors as needed.  We need a function\n+// descriptor for all exported functions and for all functions that\n+// are referenced without being called.\n+\n+void\n+Gogo::create_function_descriptors()\n+{\n+  // Create a function descriptor for any exported function that is\n+  // declared in this package.  This is so that we have a descriptor\n+  // for functions written in assembly.  Gather the descriptors first\n+  // so that we don't add declarations while looping over them.\n+  std::vector<Named_object*> fndecls;\n+  Bindings* b = this->package_->bindings();\n+  for (Bindings::const_declarations_iterator p = b->begin_declarations();\n+       p != b->end_declarations();\n+       ++p)\n+    {\n+      Named_object* no = p->second;\n+      if (no->is_function_declaration()\n+\t  && !no->func_declaration_value()->type()->is_method()\n+\t  && !Linemap::is_predeclared_location(no->location())\n+\t  && !Gogo::is_hidden_name(no->name()))\n+\tfndecls.push_back(no);\n+    }\n+  for (std::vector<Named_object*>::const_iterator p = fndecls.begin();\n+       p != fndecls.end();\n+       ++p)\n+    (*p)->func_declaration_value()->descriptor(this, *p);\n+  fndecls.clear();\n+\n+  Create_function_descriptors cfd(this);\n+  this->traverse(&cfd);\n+}\n+\n // Look for interface types to finalize methods of inherited\n // interfaces.\n \n@@ -3559,7 +3644,9 @@ Function::make_descriptor_wrapper(Gogo* gogo, Named_object* no,\n     }\n \n   gogo->add_statement(s);\n-  gogo->add_block(gogo->finish_block(loc), loc);\n+  Block* b = gogo->finish_block(loc);\n+  gogo->add_block(b, loc);\n+  gogo->lower_block(dno, b);\n   gogo->finish_function(loc);\n \n   return dno;\n@@ -3576,13 +3663,18 @@ Function::descriptor(Gogo* gogo, Named_object* no)\n   go_assert(!this->is_descriptor_wrapper_);\n   if (this->descriptor_ == NULL)\n     {\n-      Named_object* dno;\n-      if (no->package() != NULL\n-\t  || Linemap::is_predeclared_location(no->location()))\n-\tdno = NULL;\n-      else\n-\tdno = Function::make_descriptor_wrapper(gogo, no, this->type_);\n-      this->descriptor_ = Expression::make_func_descriptor(no, dno);\n+      // Make and record the descriptor first, so that when we lower\n+      // the descriptor wrapper we don't try to make it again.\n+      Func_descriptor_expression* descriptor =\n+\tExpression::make_func_descriptor(no);\n+      this->descriptor_ = descriptor;\n+      if (no->package() == NULL\n+\t  && !Linemap::is_predeclared_location(no->location()))\n+\t{\n+\t  Named_object* dno = Function::make_descriptor_wrapper(gogo, no,\n+\t\t\t\t\t\t\t\tthis->type_);\n+\t  descriptor->set_descriptor_wrapper(dno);\n+\t}\n     }\n   return this->descriptor_;\n }\n@@ -4127,13 +4219,18 @@ Function_declaration::descriptor(Gogo* gogo, Named_object* no)\n   go_assert(!this->fntype_->is_method());\n   if (this->descriptor_ == NULL)\n     {\n-      Named_object* dno;\n-      if (no->package() != NULL\n-\t  || Linemap::is_predeclared_location(no->location()))\n-\tdno = NULL;\n-      else\n-\tdno = Function::make_descriptor_wrapper(gogo, no, this->fntype_);\n-      this->descriptor_ = Expression::make_func_descriptor(no, dno);\n+      // Make and record the descriptor first, so that when we lower\n+      // the descriptor wrapper we don't try to make it again.\n+      Func_descriptor_expression* descriptor =\n+\tExpression::make_func_descriptor(no);\n+      this->descriptor_ = descriptor;\n+      if (no->package() == NULL\n+\t  && !Linemap::is_predeclared_location(no->location()))\n+\t{\n+\t  Named_object* dno = Function::make_descriptor_wrapper(gogo, no,\n+\t\t\t\t\t\t\t\tthis->fntype_);\n+\t  descriptor->set_descriptor_wrapper(dno);\n+\t}\n     }\n   return this->descriptor_;\n }"}, {"sha": "4a840758cac7c4384658e33f5db1a90ffa894571", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cd9435c12fbb72e016f66d766ecf3bc16ec57/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=ed3cd9435c12fbb72e016f66d766ecf3bc16ec57", "patch": "@@ -476,6 +476,10 @@ class Gogo\n   void\n   lower_constant(Named_object*);\n \n+  // Create all necessary function descriptors.\n+  void\n+  create_function_descriptors();\n+\n   // Finalize the method lists and build stub methods for named types.\n   void\n   finalize_methods();\n@@ -1164,15 +1168,15 @@ class Function\n   // is NULL unless we actually need a defer stack.\n   Temporary_statement* defer_stack_;\n   // True if the result variables are named.\n-  bool results_are_named_;\n+  bool results_are_named_ : 1;\n   // True if this method should not be included in the type descriptor.\n-  bool nointerface_;\n+  bool nointerface_ : 1;\n   // True if this function calls the predeclared recover function.\n-  bool calls_recover_;\n+  bool calls_recover_ : 1;\n   // True if this a thunk built for a function which calls recover.\n-  bool is_recover_thunk_;\n+  bool is_recover_thunk_ : 1;\n   // True if this function already has a recover thunk.\n-  bool has_recover_thunk_;\n+  bool has_recover_thunk_ : 1;\n   // True if this function should be put in a unique section.  This is\n   // turned on for field tracking.\n   bool in_unique_section_ : 1;"}]}