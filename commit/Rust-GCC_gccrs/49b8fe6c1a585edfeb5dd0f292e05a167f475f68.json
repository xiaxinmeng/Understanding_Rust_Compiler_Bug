{"sha": "49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDliOGZlNmMxYTU4NWVkZmViNWRkMGYyOTJlMDVhMTY3ZjQ3NWY2OA==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@samsung.com", "date": "2015-07-18T01:11:05Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-07-18T01:11:05Z"}, "message": "fix pr46851 and pr60340: remove unmaintained omega dependence test\n\nRegstrapped on amd64-linux.\n\n2015-07-18  Sebastian Pop  <s.pop@samsung.com>\n\n\tPR middle-end/46851\n\tPR middle-end/60340\n\t* Makefile.in: Removed omega.o.\n\t* common.opt: Remove flag fcheck-data-deps.\n\t* doc/invoke.texi: Remove documentation for fcheck-data-deps and\n\tits associated params: omega-max-vars, omega-max-geqs,\n\tomega-max-eqs, omega-max-wild-cards, omega-hash-table-size,\n\tomega-max-keys, omega-eliminate-redundant-constraints.\n\t* doc/loop.texi: Remove all the section on Omega.\n\t* graphite-blocking.c: Include missing params.h: it used to be\n\tincluded through tree-data-ref.h and omega.h.\n\t* graphite-isl-ast-to-gimple.c: Same.\n\t* graphite-optimize-isl.c: Same.\n\t* graphite-sese-to-poly.c: Same.\n\t* graphite.c: Same.\n\t* omega.c: Remove.\n\t* omega.h: Remove.\n\t* params.def: Removed PARAM_OMEGA_MAX_VARS, PARAM_OMEGA_MAX_GEQS,\n\tPARAM_OMEGA_MAX_EQS, PARAM_OMEGA_MAX_WILD_CARDS,\n\tPARAM_OMEGA_HASH_TABLE_SIZE, PARAM_OMEGA_MAX_KEYS, and\n\tPARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS.\n\t* passes.def: Remove pass_check_data_deps.\n\t* tree-data-ref.c (dump_affine_function): Declare DEBUG_FUNCTION.\n\t(dump_conflict_function): Same.\n\t(dump_subscript): Same.\n\t(print_direction_vector): Same.\n\t(print_dir_vectors): Same.\n\t(print_lambda_vector): Same.\n\t(print_dist_vectors): Same.\n\t(dump_data_dependence_relation): Same.\n\t(dump_data_dependence_relations): Same.\n\t(dump_dist_dir_vectors): Same.\n\t(dump_ddrs): Same.\n\t(init_omega_eq_with_af): Removed.\n\t(omega_extract_distance_vectors): Removed.\n\t(omega_setup_subscript): Removed.\n\t(init_omega_for_ddr_1): Removed.\n\t(init_omega_for_ddr): Removed.\n\t(ddr_consistent_p): Removed.\n\t(compute_affine_dependence): Do not use omega to check data\n\tdependences.\n\t(compute_data_dependences_for_bb): Removed.\n\t(analyze_all_data_dependences): Removed.\n\t(tree_check_data_deps): Removed.\n\t* tree-data-ref.h: Do not include omega.h.\n\t(compute_data_dependences_for_bb): Removed.\n\t(tree_check_data_deps): Removed.\n\t* tree-ssa-loop.c (pass_check_data_deps): Removed.\n\t(make_pass_check_data_deps): Removed.\n\t* tree-ssa-phiopt.c: Include params.h.\n\t* tree-vect-data-refs.c: Same.\n\t* tree-vect-slp.c: Same.\n\ntestsuite/\n\t* gcc.dg/tree-ssa/pr42327.c: Removed.\n\t* g++.dg/other/pr35011.C: Removed.\n\nFrom-SVN: r225979", "tree": {"sha": "7c7e5d29ca26c8c3726613d8e8864a766d53a632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c7e5d29ca26c8c3726613d8e8864a766d53a632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca4b5dbd8a483d8560d05f69f057b5727924c067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4b5dbd8a483d8560d05f69f057b5727924c067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4b5dbd8a483d8560d05f69f057b5727924c067"}], "stats": {"total": 6822, "additions": 84, "deletions": 6738}, "files": [{"sha": "98fb37bb2a8e5f754d7af2687093260ccc0d77f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -1,3 +1,58 @@\n+2015-07-18  Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR middle-end/46851\n+\tPR middle-end/60340\n+\t* Makefile.in: Removed omega.o.\n+\t* common.opt: Document flag fcheck-data-deps as deprecated.\n+\t* doc/invoke.texi: Remove documentation for fcheck-data-deps and\n+\tits associated params: omega-max-vars, omega-max-geqs,\n+\tomega-max-eqs, omega-max-wild-cards, omega-hash-table-size,\n+\tomega-max-keys, omega-eliminate-redundant-constraints.\n+\t* doc/loop.texi: Remove all the section on Omega.\n+\t* graphite-blocking.c: Include missing params.h: it used to be\n+\tincluded through tree-data-ref.h and omega.h.\n+\t* graphite-isl-ast-to-gimple.c: Same.\n+\t* graphite-optimize-isl.c: Same.\n+\t* graphite-sese-to-poly.c: Same.\n+\t* graphite.c: Same.\n+\t* omega.c: Remove.\n+\t* omega.h: Remove.\n+\t* params.def: Removed PARAM_OMEGA_MAX_VARS, PARAM_OMEGA_MAX_GEQS,\n+\tPARAM_OMEGA_MAX_EQS, PARAM_OMEGA_MAX_WILD_CARDS,\n+\tPARAM_OMEGA_HASH_TABLE_SIZE, PARAM_OMEGA_MAX_KEYS, and\n+\tPARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS.\n+\t* passes.def: Remove pass_check_data_deps.\n+\t* tree-data-ref.c (dump_affine_function): Declare DEBUG_FUNCTION.\n+\t(dump_conflict_function): Same.\n+\t(dump_subscript): Same.\n+\t(print_direction_vector): Same.\n+\t(print_dir_vectors): Same.\n+\t(print_lambda_vector): Same.\n+\t(print_dist_vectors): Same.\n+\t(dump_data_dependence_relation): Same.\n+\t(dump_data_dependence_relations): Same.\n+\t(dump_dist_dir_vectors): Same.\n+\t(dump_ddrs): Same.\n+\t(init_omega_eq_with_af): Removed.\n+\t(omega_extract_distance_vectors): Removed.\n+\t(omega_setup_subscript): Removed.\n+\t(init_omega_for_ddr_1): Removed.\n+\t(init_omega_for_ddr): Removed.\n+\t(ddr_consistent_p): Removed.\n+\t(compute_affine_dependence): Do not use omega to check data\n+\tdependences.\n+\t(compute_data_dependences_for_bb): Removed.\n+\t(analyze_all_data_dependences): Removed.\n+\t(tree_check_data_deps): Removed.\n+\t* tree-data-ref.h: Do not include omega.h.\n+\t(compute_data_dependences_for_bb): Removed.\n+\t(tree_check_data_deps): Removed.\n+\t* tree-ssa-loop.c (pass_check_data_deps): Removed.\n+\t(make_pass_check_data_deps): Removed.\n+\t* tree-ssa-phiopt.c: Include params.h.\n+\t* tree-vect-data-refs.c: Same.\n+\t* tree-vect-slp.c: Same.\n+\n 2015-07-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (pushsf splitter): Pass curr_insn to"}, {"sha": "333461b5ccb9b23df3445e10549ab6acd8334f9a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -1347,7 +1347,6 @@ OBJS = \\\n \tmcf.o \\\n \tmode-switching.o \\\n \tmodulo-sched.o \\\n-\tomega.o \\\n \tomp-low.o \\\n \toptabs.o \\\n \toptions-save.o \\"}, {"sha": "8f25f8b35cf698e69a59b233113b7f37079cea1e", "filename": "gcc/common.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -987,7 +987,7 @@ Save registers around function calls\n \n fcheck-data-deps\n Common Report Var(flag_check_data_deps)\n-Compare the results of several data dependence analyzers.\n+This switch is deprecated; do not use.\n \n fcheck-new\n Common Var(flag_check_new)"}, {"sha": "a62c8b33e9253dff6900596ab5c95cae78c6d402", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -385,7 +385,7 @@ Objective-C and Objective-C++ Dialects}.\n -fauto-inc-dec -fbranch-probabilities @gol\n -fbranch-target-load-optimize -fbranch-target-load-optimize2 @gol\n -fbtr-bb-exclusive -fcaller-saves @gol\n--fcheck-data-deps -fcombine-stack-adjustments -fconserve-stack @gol\n+-fcombine-stack-adjustments -fconserve-stack @gol\n -fcompare-elim -fcprop-registers -fcrossjumping @gol\n -fcse-follow-jumps -fcse-skip-blocks -fcx-fortran-rules @gol\n -fcx-limited-range @gol\n@@ -8812,11 +8812,6 @@ be parallelized.  Parallelize all the loops that can be analyzed to\n not contain loop carried dependences without checking that it is\n profitable to parallelize the loops.\n \n-@item -fcheck-data-deps\n-@opindex fcheck-data-deps\n-Compare the results of several data dependence analyzers.  This option\n-is used for debugging the data dependence analyzers.\n-\n @item -ftree-loop-if-convert\n @opindex ftree-loop-if-convert\n Attempt to transform conditional jumps in the innermost loops to\n@@ -10475,34 +10470,6 @@ Large expressions slow the analyzer.\n Bound on the complexity of the expressions in the scalar evolutions analyzer.\n Complex expressions slow the analyzer.\n \n-@item omega-max-vars\n-The maximum number of variables in an Omega constraint system.\n-The default value is 128.\n-\n-@item omega-max-geqs\n-The maximum number of inequalities in an Omega constraint system.\n-The default value is 256.\n-\n-@item omega-max-eqs\n-The maximum number of equalities in an Omega constraint system.\n-The default value is 128.\n-\n-@item omega-max-wild-cards\n-The maximum number of wildcard variables that the Omega solver is\n-able to insert.  The default value is 18.\n-\n-@item omega-hash-table-size\n-The size of the hash table in the Omega solver.  The default value is\n-550.\n-\n-@item omega-max-keys\n-The maximal number of keys used by the Omega solver.  The default\n-value is 500.\n-\n-@item omega-eliminate-redundant-constraints\n-When set to 1, use expensive methods to eliminate all redundant\n-constraints.  The default value is 0.\n-\n @item vect-max-version-for-alignment-checks\n The maximum number of run-time checks that can be performed when\n doing loop versioning for alignment in the vectorizer."}, {"sha": "18f8b6514785be2db3fab07ea4e23dfe9923df5b", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -25,7 +25,6 @@ variable analysis and number of iterations analysis).\n * loop-iv::                     Induction variables on RTL.\n * Number of iterations::        Number of iterations analysis.\n * Dependency analysis::         Data dependency analysis.\n-* Omega::                       A solver for linear programming problems.\n @end menu\n \n @node Loop representation\n@@ -602,33 +601,3 @@ maximum verbosity the details of a data dependence relations array,\n direction vectors for a data dependence relations array, and\n @code{dump_data_references} prints the details of the data references\n contained in a data reference array.\n-\n-\n-@node Omega\n-@section Omega a solver for linear programming problems\n-@cindex Omega a solver for linear programming problems\n-\n-The data dependence analysis contains several solvers triggered\n-sequentially from the less complex ones to the more sophisticated.\n-For ensuring the consistency of the results of these solvers, a data\n-dependence check pass has been implemented based on two different\n-solvers.  The second method that has been integrated to GCC is based\n-on the Omega dependence solver, written in the 1990's by William Pugh\n-and David Wonnacott.  Data dependence tests can be formulated using a\n-subset of the Presburger arithmetics that can be translated to linear\n-constraint systems.  These linear constraint systems can then be\n-solved using the Omega solver.\n-\n-The Omega solver is using Fourier-Motzkin's algorithm for variable\n-elimination: a linear constraint system containing @code{n} variables\n-is reduced to a linear constraint system with @code{n-1} variables.\n-The Omega solver can also be used for solving other problems that can\n-be expressed under the form of a system of linear equalities and\n-inequalities.  The Omega solver is known to have an exponential worst\n-case, also known under the name of ``omega nightmare'' in the\n-literature, but in practice, the omega test is known to be efficient\n-for the common data dependence tests.\n-\n-The interface used by the Omega solver for describing the linear\n-programming problems is described in @file{omega.h}, and the solver is\n-@code{omega_solve_problem}."}, {"sha": "d9d16e8f15a93d2db87509ad4ff37554abeb9c3a", "filename": "gcc/graphite-blocking.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite-blocking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite-blocking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-blocking.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfghooks.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n+#include \"params.h\"\n #include \"fold-const.h\"\n #include \"gimple-iterator.h\"\n #include \"tree-ssa-loop.h\""}, {"sha": "b620a4880509eeeb621a43bd33b54b4aa0c72f57", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -44,6 +44,7 @@ extern \"C\" {\n #include \"cfghooks.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n+#include \"params.h\"\n #include \"fold-const.h\"\n #include \"gimple-iterator.h\"\n #include \"tree-ssa-loop.h\""}, {"sha": "87536b2a17614600e8e642e47d490c3fbf123af7", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-data-ref.h\"\n #include \"graphite-poly.h\"\n+#include \"params.h\"\n \n static isl_union_set *\n scop_get_domains (scop_p scop ATTRIBUTE_UNUSED)"}, {"sha": "8960c3fca260886cfca151eb0e49dd03f1cb1058", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -47,6 +47,7 @@ extern \"C\" {\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"ssa.h\"\n+#include \"params.h\"\n #include \"fold-const.h\"\n #include \"gimple-iterator.h\"\n #include \"gimplify.h\""}, {"sha": "6417da2721527b741b5395f0abe670d23d469c60", "filename": "gcc/graphite.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"cfgloop.h\"\n #include \"tree-pass.h\"\n+#include \"params.h\"\n \n #ifdef HAVE_isl\n #include \"cfghooks.h\""}, {"sha": "55ed77d6b89452c79e5e878a68bfac47d74b315f", "filename": "gcc/omega.c", "status": "removed", "additions": 0, "deletions": 5524, "changes": 5524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4b5dbd8a483d8560d05f69f057b5727924c067/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4b5dbd8a483d8560d05f69f057b5727924c067/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=ca4b5dbd8a483d8560d05f69f057b5727924c067"}, {"sha": "33361b863636dd64d462152680a6e7e71281698c", "filename": "gcc/omega.h", "status": "removed", "additions": 0, "deletions": 341, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4b5dbd8a483d8560d05f69f057b5727924c067/gcc%2Fomega.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4b5dbd8a483d8560d05f69f057b5727924c067/gcc%2Fomega.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.h?ref=ca4b5dbd8a483d8560d05f69f057b5727924c067", "patch": "@@ -1,341 +0,0 @@\n-/* Source code for an implementation of the Omega test, an integer\n-   programming algorithm for dependence analysis, by William Pugh,\n-   appeared in Supercomputing '91 and CACM Aug 92.\n-\n-   This code has no license restrictions, and is considered public\n-   domain.\n-\n-   Changes copyright (C) 2005-2015 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@inria.fr>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#ifndef GCC_OMEGA_H\n-#define GCC_OMEGA_H\n-\n-#include \"params.h\"\n-\n-#define OMEGA_MAX_VARS PARAM_VALUE (PARAM_OMEGA_MAX_VARS)\n-#define OMEGA_MAX_GEQS PARAM_VALUE (PARAM_OMEGA_MAX_GEQS)\n-#define OMEGA_MAX_EQS PARAM_VALUE (PARAM_OMEGA_MAX_EQS)\n-\n-#define pos_infinity (0x7ffffff)\n-#define neg_infinity (-0x7ffffff)\n-\n-/* Results of the Omega solver.  */\n-enum omega_result {\n-  omega_false = 0,\n-  omega_true = 1,\n-\n-  /* Value returned when the solver is unable to determine an\n-     answer.  */\n-  omega_unknown = 2,\n-\n-  /* Value used for asking the solver to simplify the system.  */\n-  omega_simplify = 3\n-};\n-\n-/* Values used for labeling equations.  Private (not used outside the\n-   solver).  */\n-enum omega_eqn_color {\n-  omega_black = 0,\n-  omega_red = 1\n-};\n-\n-/* Structure for equations.  */\n-typedef struct eqn_d\n-{\n-  int key;\n-  int touched;\n-  enum omega_eqn_color color;\n-\n-  /* Array of coefficients for the equation.  The layout of the data\n-     is as follows: coef[0] is the constant, coef[i] for 1 <= i <=\n-     OMEGA_MAX_VARS, are the coefficients for each dimension.  Examples:\n-     the equation 0 = 9 + x + 0y + 5z is encoded as [9 1 0 5], the\n-     inequality 0 <= -8 + x + 2y + 3z is encoded as [-8 1 2 3].  */\n-  int *coef;\n-} *eqn;\n-\n-typedef struct omega_pb_d\n-{\n-  /* The number of variables in the system of equations.  */\n-  int num_vars;\n-\n-  /* Safe variables are not eliminated during the Fourier-Motzkin\n-     simplification of the system.  Safe variables are all those\n-     variables that are placed at the beginning of the array of\n-     variables: PB->var[1, ..., SAFE_VARS].  PB->var[0] is not used,\n-     as PB->eqs[x]->coef[0] represents the constant of the equation.  */\n-  int safe_vars;\n-\n-  /* Number of elements in eqs[].  */\n-  int num_eqs;\n-  /* Number of elements in geqs[].  */\n-  int num_geqs;\n-  /* Number of elements in subs[].  */\n-  int num_subs;\n-\n-  int hash_version;\n-  bool variables_initialized;\n-  bool variables_freed;\n-\n-  /* Index or name of variables.  Negative integers are reserved for\n-     wildcard variables.  Maps the index of variables in the original\n-     problem to the new index of the variable.  The index for a\n-     variable in the coef array of an equation can change as some\n-     variables are eliminated.  */\n-  int *var;\n-\n-  int *forwarding_address;\n-\n-  /* Inequalities in the system of constraints.  */\n-  eqn geqs;\n-\n-  /* Equations in the system of constraints.  */\n-  eqn eqs;\n-\n-  /* A map of substituted variables.  */\n-  eqn subs;\n-} *omega_pb;\n-\n-extern void omega_initialize (void);\n-extern omega_pb omega_alloc_problem (int, int);\n-extern enum omega_result omega_solve_problem (omega_pb, enum omega_result);\n-extern enum omega_result omega_simplify_problem (omega_pb);\n-extern enum omega_result omega_simplify_approximate (omega_pb);\n-extern enum omega_result omega_constrain_variable_sign (omega_pb,\n-\t\t\t\t\t\t\tenum omega_eqn_color,\n-\t\t\t\t\t\t\tint, int);\n-extern void debug (omega_pb_d &ref);\n-extern void debug (omega_pb_d *ptr);\n-extern void debug_omega_problem (omega_pb);\n-extern void omega_print_problem (FILE *, omega_pb);\n-extern void omega_print_red_equations (FILE *, omega_pb);\n-extern int omega_count_red_equations (omega_pb);\n-extern void omega_pretty_print_problem (FILE *, omega_pb);\n-extern void omega_unprotect_variable (omega_pb, int var);\n-extern void omega_negate_geq (omega_pb, int);\n-extern void omega_convert_eq_to_geqs (omega_pb, int eq);\n-extern void omega_print_eqn (FILE *, omega_pb, eqn, bool, int);\n-extern bool omega_problem_has_red_equations (omega_pb);\n-extern enum omega_result omega_eliminate_redundant (omega_pb, bool);\n-extern void omega_eliminate_red (omega_pb, bool);\n-extern void omega_constrain_variable_value (omega_pb, enum omega_eqn_color,\n-\t\t\t\t\t    int, int);\n-extern bool omega_query_variable (omega_pb, int, int *, int *);\n-extern int omega_query_variable_signs (omega_pb, int, int, int, int,\n-\t\t\t\t       int, int, bool *, int *);\n-extern bool omega_query_variable_bounds (omega_pb, int, int *, int *);\n-extern void (*omega_when_reduced) (omega_pb);\n-extern void omega_no_procedure (omega_pb);\n-\n-/* Return true when variable I in problem PB is a wildcard.  */\n-\n-static inline bool\n-omega_wildcard_p (omega_pb pb, int i)\n-{\n-  return (pb->var[i] < 0);\n-}\n-\n-/* Return true when variable I in problem PB is a safe variable.  */\n-\n-static inline bool\n-omega_safe_var_p (omega_pb pb, int i)\n-{\n-  /* The constant of an equation is not a variable.  */\n-  gcc_assert (0 < i);\n-  return (i <= pb->safe_vars);\n-}\n-\n-/* Print to FILE equality E from PB.  */\n-\n-static inline void\n-omega_print_eq (FILE *file, omega_pb pb, eqn e)\n-{\n-  omega_print_eqn (file, pb, e, false, 0);\n-}\n-\n-/* Print to FILE inequality E from PB.  */\n-\n-static inline void\n-omega_print_geq (FILE *file, omega_pb pb, eqn e)\n-{\n-  omega_print_eqn (file, pb, e, true, 0);\n-}\n-\n-/* Print to FILE inequality E from PB.  */\n-\n-static inline void\n-omega_print_geq_extra (FILE *file, omega_pb pb, eqn e)\n-{\n-  omega_print_eqn (file, pb, e, true, 1);\n-}\n-\n-/* E1 = E2, make a copy of E2 into E1.  Equations contain S variables.  */\n-\n-static inline void\n-omega_copy_eqn (eqn e1, eqn e2, int s)\n-{\n-  e1->key = e2->key;\n-  e1->touched = e2->touched;\n-  e1->color = e2->color;\n-\n-  memcpy (e1->coef, e2->coef, (s + 1) * sizeof (int));\n-}\n-\n-/* Initialize E = 0.  Equation E contains S variables.  */\n-\n-static inline void\n-omega_init_eqn_zero (eqn e, int s)\n-{\n-  e->key = 0;\n-  e->touched = 0;\n-  e->color = omega_black;\n-\n-  memset (e->coef, 0, (s + 1) * sizeof (int));\n-}\n-\n-/* Allocate N equations with S variables.  */\n-\n-static inline eqn\n-omega_alloc_eqns (int s, int n)\n-{\n-  int i;\n-  eqn res = (eqn) (xcalloc (n, sizeof (struct eqn_d)));\n-\n-  for (i = n - 1; i >= 0; i--)\n-    {\n-      res[i].coef = (int *) (xcalloc (OMEGA_MAX_VARS + 1, sizeof (int)));\n-      omega_init_eqn_zero (&res[i], s);\n-    }\n-\n-  return res;\n-}\n-\n-/* Free N equations from array EQ.  */\n-\n-static inline void\n-omega_free_eqns (eqn eq, int n)\n-{\n-  int i;\n-\n-  for (i = n - 1; i >= 0; i--)\n-    free (eq[i].coef);\n-\n-  free (eq);\n-}\n-\n-/* Returns true when E is an inequality with a single variable.  */\n-\n-static inline bool\n-single_var_geq (eqn e, int nv ATTRIBUTE_UNUSED)\n-{\n-  return (e->key != 0\n-\t  && -OMEGA_MAX_VARS <= e->key && e->key <= OMEGA_MAX_VARS);\n-}\n-\n-/* Allocate a new equality with all coefficients 0, and tagged with\n-   COLOR.  Return the index of this equality in problem PB.  */\n-\n-static inline int\n-omega_add_zero_eq (omega_pb pb, enum omega_eqn_color color)\n-{\n-  int idx = pb->num_eqs++;\n-\n-  gcc_assert (pb->num_eqs <= OMEGA_MAX_EQS);\n-  omega_init_eqn_zero (&pb->eqs[idx], pb->num_vars);\n-  pb->eqs[idx].color = color;\n-  return idx;\n-}\n-\n-/* Allocate a new inequality with all coefficients 0, and tagged with\n-   COLOR.  Return the index of this inequality in problem PB.  */\n-\n-static inline int\n-omega_add_zero_geq (omega_pb pb, enum omega_eqn_color color)\n-{\n-  int idx = pb->num_geqs;\n-\n-  pb->num_geqs++;\n-  gcc_assert (pb->num_geqs <= OMEGA_MAX_GEQS);\n-  omega_init_eqn_zero (&pb->geqs[idx], pb->num_vars);\n-  pb->geqs[idx].touched = 1;\n-  pb->geqs[idx].color = color;\n-  return idx;\n-}\n-\n-/* Initialize variables for problem PB.  */\n-\n-static inline void\n-omega_initialize_variables (omega_pb pb)\n-{\n-  int i;\n-\n-  for (i = pb->num_vars; i >= 0; i--)\n-    pb->forwarding_address[i] = pb->var[i] = i;\n-\n-  pb->variables_initialized = true;\n-}\n-\n-/* Free problem PB.  */\n-\n-static inline void\n-omega_free_problem (omega_pb pb)\n-{\n-  free (pb->var);\n-  free (pb->forwarding_address);\n-  omega_free_eqns (pb->geqs, OMEGA_MAX_GEQS);\n-  omega_free_eqns (pb->eqs, OMEGA_MAX_EQS);\n-  omega_free_eqns (pb->subs, OMEGA_MAX_VARS + 1);\n-  free (pb);\n-}\n-\n-/* Copy omega problems: P1 = P2.  */\n-\n-static inline void\n-omega_copy_problem (omega_pb p1, omega_pb p2)\n-{\n-  int e, i;\n-\n-  p1->num_vars = p2->num_vars;\n-  p1->hash_version = p2->hash_version;\n-  p1->variables_initialized = p2->variables_initialized;\n-  p1->variables_freed = p2->variables_freed;\n-  p1->safe_vars = p2->safe_vars;\n-  p1->num_eqs = p2->num_eqs;\n-  p1->num_subs = p2->num_subs;\n-  p1->num_geqs = p2->num_geqs;\n-\n-  for (e = p2->num_eqs - 1; e >= 0; e--)\n-    omega_copy_eqn (&(p1->eqs[e]), &(p2->eqs[e]), p2->num_vars);\n-\n-  for (e = p2->num_geqs - 1; e >= 0; e--)\n-    omega_copy_eqn (&(p1->geqs[e]), &(p2->geqs[e]), p2->num_vars);\n-\n-  for (e = p2->num_subs - 1; e >= 0; e--)\n-    omega_copy_eqn (&(p1->subs[e]), &(p2->subs[e]), p2->num_vars);\n-\n-  for (i = p2->num_vars; i >= 0; i--)\n-    p1->var[i] = p2->var[i];\n-\n-  for (i = OMEGA_MAX_VARS; i >= 0; i--)\n-    p1->forwarding_address[i] = p2->forwarding_address[i];\n-}\n-\n-#endif /* GCC_OMEGA_H */"}, {"sha": "0ca345133dc8bf791fb7781ddc2eca2ceee2f0ae", "filename": "gcc/params.def", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -525,41 +525,6 @@ DEFPARAM(PARAM_SCEV_MAX_EXPR_COMPLEXITY,\n \t \"Bound on the complexity of the expressions in the scalar evolutions analyzer\",\n \t 10, 0, 0)\n \n-DEFPARAM(PARAM_OMEGA_MAX_VARS,\n- \t \"omega-max-vars\",\n-\t \"Bound on the number of variables in Omega constraint systems\",\n-\t 128, 0, 0)\n-\n-DEFPARAM(PARAM_OMEGA_MAX_GEQS,\n- \t \"omega-max-geqs\",\n-\t \"Bound on the number of inequalities in Omega constraint systems\",\n-\t 256, 0, 0)\n-\n-DEFPARAM(PARAM_OMEGA_MAX_EQS,\n- \t \"omega-max-eqs\",\n-\t \"Bound on the number of equalities in Omega constraint systems\",\n-\t 128, 0, 0)\n-\n-DEFPARAM(PARAM_OMEGA_MAX_WILD_CARDS,\n- \t \"omega-max-wild-cards\",\n-\t \"Bound on the number of wild cards in Omega constraint systems\",\n-\t 18, 0, 0)\n-\n-DEFPARAM(PARAM_OMEGA_HASH_TABLE_SIZE,\n- \t \"omega-hash-table-size\",\n-\t \"Bound on the size of the hash table in Omega constraint systems\",\n-\t 550, 0, 0)\n-\n-DEFPARAM(PARAM_OMEGA_MAX_KEYS,\n- \t \"omega-max-keys\",\n-\t \"Bound on the number of keys in Omega constraint systems\",\n-\t 500, 0, 0)\n-\n-DEFPARAM(PARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS,\n- \t \"omega-eliminate-redundant-constraints\",\n-\t \"When set to 1, use expensive methods to eliminate all redundant constraints\",\n-\t 0, 0, 1)\n-\n DEFPARAM(PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS,\n          \"vect-max-version-for-alignment-checks\",\n          \"Bound on number of runtime checks inserted by the vectorizer's loop versioning for alignment check\","}, {"sha": "6b66f8f539650653c32aad1d7a511387bef83dc4", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -233,7 +233,6 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_tree_unswitch);\n \t  NEXT_PASS (pass_scev_cprop);\n \t  NEXT_PASS (pass_record_bounds);\n-\t  NEXT_PASS (pass_check_data_deps);\n \t  NEXT_PASS (pass_loop_distribution);\n \t  NEXT_PASS (pass_copy_prop);\n \t  NEXT_PASS (pass_graphite);"}, {"sha": "a9b34ba71f1623920a9db1c5e425d3da2b8276db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -1,3 +1,10 @@\n+2015-07-18  Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR middle-end/46851\n+\tPR middle-end/60340\n+\t* gcc.dg/tree-ssa/pr42327.c: Removed.\n+\t* g++.dg/other/pr35011.C: Removed.\n+\n 2015-07-17  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/66906"}, {"sha": "ca75516d6e1f7513ade41a8e716c4f736ed22c91", "filename": "gcc/testsuite/g++.dg/other/pr35011.C", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4b5dbd8a483d8560d05f69f057b5727924c067/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr35011.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4b5dbd8a483d8560d05f69f057b5727924c067/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr35011.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr35011.C?ref=ca4b5dbd8a483d8560d05f69f057b5727924c067", "patch": "@@ -1,26 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-O3 -fcheck-data-deps\" }\n-\n-double foo(const double* p0, const double* p1, const double* q0)\n-{\n-  double d;\n-  for (; p0 != p1; ++p0, ++q0)\n-    d += *p0 * *q0;\n-  return d;\n-}\n-\n-struct A\n-{\n-  double x[3];\n-  const double* begin() const { return x; }\n-};\n-\n-struct B\n-{\n-  A a0, a1;\n-  double d;\n-  B(const A&);\n-};\n-\n-B::B(const A& a) : a0(a), a1(a), d(foo(a0.begin(), a0.begin()+3, a1.begin()))\n-{}"}, {"sha": "c0d3811b2494e4e9569a2d4ddb8607dd2160386b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr42327.c", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4b5dbd8a483d8560d05f69f057b5727924c067/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr42327.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4b5dbd8a483d8560d05f69f057b5727924c067/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr42327.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr42327.c?ref=ca4b5dbd8a483d8560d05f69f057b5727924c067", "patch": "@@ -1,7 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O1 -fcheck-data-deps\" } */\n-\n-void foo(char *str)\n-{\n-   while (*str != 0) *str++ = 0;\n-}"}, {"sha": "d0b7aa21eacaaa9fb467cd7d6af1c43d23d4f42e", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 12, "deletions": 683, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -249,7 +249,7 @@ debug (data_reference *ptr)\n \n /* Dumps the affine function described by FN to the file OUTF.  */\n \n-static void\n+DEBUG_FUNCTION void\n dump_affine_function (FILE *outf, affine_fn fn)\n {\n   unsigned i;\n@@ -266,7 +266,7 @@ dump_affine_function (FILE *outf, affine_fn fn)\n \n /* Dumps the conflict function CF to the file OUTF.  */\n \n-static void\n+DEBUG_FUNCTION void\n dump_conflict_function (FILE *outf, conflict_function *cf)\n {\n   unsigned i;\n@@ -290,7 +290,7 @@ dump_conflict_function (FILE *outf, conflict_function *cf)\n \n /* Dump function for a SUBSCRIPT structure.  */\n \n-static void\n+DEBUG_FUNCTION void\n dump_subscript (FILE *outf, struct subscript *subscript)\n {\n   conflict_function *cf = SUB_CONFLICTS_IN_A (subscript);\n@@ -322,7 +322,7 @@ dump_subscript (FILE *outf, struct subscript *subscript)\n \n /* Print the classic direction vector DIRV to OUTF.  */\n \n-static void\n+DEBUG_FUNCTION void\n print_direction_vector (FILE *outf,\n \t\t\tlambda_vector dirv,\n \t\t\tint length)\n@@ -367,7 +367,7 @@ print_direction_vector (FILE *outf,\n \n /* Print a vector of direction vectors.  */\n \n-static void\n+DEBUG_FUNCTION void\n print_dir_vectors (FILE *outf, vec<lambda_vector> dir_vects,\n \t\t   int length)\n {\n@@ -380,7 +380,7 @@ print_dir_vectors (FILE *outf, vec<lambda_vector> dir_vects,\n \n /* Print out a vector VEC of length N to OUTFILE.  */\n \n-static inline void\n+DEBUG_FUNCTION void\n print_lambda_vector (FILE * outfile, lambda_vector vector, int n)\n {\n   int i;\n@@ -392,7 +392,7 @@ print_lambda_vector (FILE * outfile, lambda_vector vector, int n)\n \n /* Print a vector of distance vectors.  */\n \n-static void\n+DEBUG_FUNCTION void\n print_dist_vectors (FILE *outf, vec<lambda_vector> dist_vects,\n \t\t    int length)\n {\n@@ -405,7 +405,7 @@ print_dist_vectors (FILE *outf, vec<lambda_vector> dist_vects,\n \n /* Dump function for a DATA_DEPENDENCE_RELATION structure.  */\n \n-static void\n+DEBUG_FUNCTION void\n dump_data_dependence_relation (FILE *outf,\n \t\t\t       struct data_dependence_relation *ddr)\n {\n@@ -488,7 +488,7 @@ debug_data_dependence_relation (struct data_dependence_relation *ddr)\n \n /* Dump into FILE all the dependence relations from DDRS.  */\n \n-void\n+DEBUG_FUNCTION void\n dump_data_dependence_relations (FILE *file,\n \t\t\t\tvec<ddr_p> ddrs)\n {\n@@ -528,7 +528,7 @@ debug_data_dependence_relations (vec<ddr_p> ddrs)\n    dependence vectors, or in other words the number of loops in the\n    considered nest.  */\n \n-static void\n+DEBUG_FUNCTION void\n dump_dist_dir_vectors (FILE *file, vec<ddr_p> ddrs)\n {\n   unsigned int i, j;\n@@ -558,7 +558,7 @@ dump_dist_dir_vectors (FILE *file, vec<ddr_p> ddrs)\n \n /* Dumps the data dependence relations DDRS in FILE.  */\n \n-static void\n+DEBUG_FUNCTION void\n dump_ddrs (FILE *file, vec<ddr_p> ddrs)\n {\n   unsigned int i;\n@@ -3682,531 +3682,6 @@ access_functions_are_affine_or_constant_p (const struct data_reference *a,\n   return true;\n }\n \n-/* Initializes an equation for an OMEGA problem using the information\n-   contained in the ACCESS_FUN.  Returns true when the operation\n-   succeeded.\n-\n-   PB is the omega constraint system.\n-   EQ is the number of the equation to be initialized.\n-   OFFSET is used for shifting the variables names in the constraints:\n-   a constrain is composed of 2 * the number of variables surrounding\n-   dependence accesses.  OFFSET is set either to 0 for the first n variables,\n-   then it is set to n.\n-   ACCESS_FUN is expected to be an affine chrec.  */\n-\n-static bool\n-init_omega_eq_with_af (omega_pb pb, unsigned eq,\n-\t\t       unsigned int offset, tree access_fun,\n-\t\t       struct data_dependence_relation *ddr)\n-{\n-  switch (TREE_CODE (access_fun))\n-    {\n-    case POLYNOMIAL_CHREC:\n-      {\n-\ttree left = CHREC_LEFT (access_fun);\n-\ttree right = CHREC_RIGHT (access_fun);\n-\tint var = CHREC_VARIABLE (access_fun);\n-\tunsigned var_idx;\n-\n-\tif (TREE_CODE (right) != INTEGER_CST)\n-\t  return false;\n-\n-\tvar_idx = index_in_loop_nest (var, DDR_LOOP_NEST (ddr));\n-\tpb->eqs[eq].coef[offset + var_idx + 1] = int_cst_value (right);\n-\n-\t/* Compute the innermost loop index.  */\n-\tDDR_INNER_LOOP (ddr) = MAX (DDR_INNER_LOOP (ddr), var_idx);\n-\n-\tif (offset == 0)\n-\t  pb->eqs[eq].coef[var_idx + DDR_NB_LOOPS (ddr) + 1]\n-\t    += int_cst_value (right);\n-\n-\tswitch (TREE_CODE (left))\n-\t  {\n-\t  case POLYNOMIAL_CHREC:\n-\t    return init_omega_eq_with_af (pb, eq, offset, left, ddr);\n-\n-\t  case INTEGER_CST:\n-\t    pb->eqs[eq].coef[0] += int_cst_value (left);\n-\t    return true;\n-\n-\t  default:\n-\t    return false;\n-\t  }\n-      }\n-\n-    case INTEGER_CST:\n-      pb->eqs[eq].coef[0] += int_cst_value (access_fun);\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* As explained in the comments preceding init_omega_for_ddr, we have\n-   to set up a system for each loop level, setting outer loops\n-   variation to zero, and current loop variation to positive or zero.\n-   Save each lexico positive distance vector.  */\n-\n-static void\n-omega_extract_distance_vectors (omega_pb pb,\n-\t\t\t\tstruct data_dependence_relation *ddr)\n-{\n-  int eq, geq;\n-  unsigned i, j;\n-  struct loop *loopi, *loopj;\n-  enum omega_result res;\n-\n-  /* Set a new problem for each loop in the nest.  The basis is the\n-     problem that we have initialized until now.  On top of this we\n-     add new constraints.  */\n-  for (i = 0; i <= DDR_INNER_LOOP (ddr)\n-              && DDR_LOOP_NEST (ddr).iterate (i, &loopi); i++)\n-    {\n-      int dist = 0;\n-      omega_pb copy = omega_alloc_problem (2 * DDR_NB_LOOPS (ddr),\n-\t\t\t\t\t   DDR_NB_LOOPS (ddr));\n-\n-      omega_copy_problem (copy, pb);\n-\n-      /* For all the outer loops \"loop_j\", add \"dj = 0\".  */\n-      for (j = 0; j < i && DDR_LOOP_NEST (ddr).iterate (j, &loopj); j++)\n-\t{\n-\t  eq = omega_add_zero_eq (copy, omega_black);\n-\t  copy->eqs[eq].coef[j + 1] = 1;\n-\t}\n-\n-      /* For \"loop_i\", add \"0 <= di\".  */\n-      geq = omega_add_zero_geq (copy, omega_black);\n-      copy->geqs[geq].coef[i + 1] = 1;\n-\n-      /* Reduce the constraint system, and test that the current\n-\t problem is feasible.  */\n-      res = omega_simplify_problem (copy);\n-      if (res == omega_false\n-\t  || res == omega_unknown\n-\t  || copy->num_geqs > (int) DDR_NB_LOOPS (ddr))\n-\tgoto next_problem;\n-\n-      for (eq = 0; eq < copy->num_subs; eq++)\n-\tif (copy->subs[eq].key == (int) i + 1)\n-\t  {\n-\t    dist = copy->subs[eq].coef[0];\n-\t    goto found_dist;\n-\t  }\n-\n-      if (dist == 0)\n-\t{\n-\t  /* Reinitialize problem...  */\n-\t  omega_copy_problem (copy, pb);\n-\t  for (j = 0; j < i && DDR_LOOP_NEST (ddr).iterate (j, &loopj); j++)\n-\t    {\n-\t      eq = omega_add_zero_eq (copy, omega_black);\n-\t      copy->eqs[eq].coef[j + 1] = 1;\n-\t    }\n-\n-\t  /* ..., but this time \"di = 1\".  */\n-\t  eq = omega_add_zero_eq (copy, omega_black);\n-\t  copy->eqs[eq].coef[i + 1] = 1;\n-\t  copy->eqs[eq].coef[0] = -1;\n-\n-\t  res = omega_simplify_problem (copy);\n-\t  if (res == omega_false\n-\t      || res == omega_unknown\n-\t      || copy->num_geqs > (int) DDR_NB_LOOPS (ddr))\n-\t    goto next_problem;\n-\n-\t  for (eq = 0; eq < copy->num_subs; eq++)\n-\t    if (copy->subs[eq].key == (int) i + 1)\n-\t      {\n-\t\tdist = copy->subs[eq].coef[0];\n-\t\tgoto found_dist;\n-\t      }\n-\t}\n-\n-    found_dist:;\n-      /* Save the lexicographically positive distance vector.  */\n-      if (dist >= 0)\n-\t{\n-\t  lambda_vector dist_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n-\t  lambda_vector dir_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n-\n-\t  dist_v[i] = dist;\n-\n-\t  for (eq = 0; eq < copy->num_subs; eq++)\n-\t    if (copy->subs[eq].key > 0)\n-\t      {\n-\t\tdist = copy->subs[eq].coef[0];\n-\t\tdist_v[copy->subs[eq].key - 1] = dist;\n-\t      }\n-\n-\t  for (j = 0; j < DDR_NB_LOOPS (ddr); j++)\n-\t    dir_v[j] = dir_from_dist (dist_v[j]);\n-\n-\t  save_dist_v (ddr, dist_v);\n-\t  save_dir_v (ddr, dir_v);\n-\t}\n-\n-    next_problem:;\n-      omega_free_problem (copy);\n-    }\n-}\n-\n-/* This is called for each subscript of a tuple of data references:\n-   insert an equality for representing the conflicts.  */\n-\n-static bool\n-omega_setup_subscript (tree access_fun_a, tree access_fun_b,\n-\t\t       struct data_dependence_relation *ddr,\n-\t\t       omega_pb pb, bool *maybe_dependent)\n-{\n-  int eq;\n-  tree type = signed_type_for_types (TREE_TYPE (access_fun_a),\n-\t\t\t\t     TREE_TYPE (access_fun_b));\n-  tree fun_a = chrec_convert (type, access_fun_a, NULL);\n-  tree fun_b = chrec_convert (type, access_fun_b, NULL);\n-  tree difference = chrec_fold_minus (type, fun_a, fun_b);\n-  tree minus_one;\n-\n-  /* When the fun_a - fun_b is not constant, the dependence is not\n-     captured by the classic distance vector representation.  */\n-  if (TREE_CODE (difference) != INTEGER_CST)\n-    return false;\n-\n-  /* ZIV test.  */\n-  if (ziv_subscript_p (fun_a, fun_b) && !integer_zerop (difference))\n-    {\n-      /* There is no dependence.  */\n-      *maybe_dependent = false;\n-      return true;\n-    }\n-\n-  minus_one = build_int_cst (type, -1);\n-  fun_b = chrec_fold_multiply (type, fun_b, minus_one);\n-\n-  eq = omega_add_zero_eq (pb, omega_black);\n-  if (!init_omega_eq_with_af (pb, eq, DDR_NB_LOOPS (ddr), fun_a, ddr)\n-      || !init_omega_eq_with_af (pb, eq, 0, fun_b, ddr))\n-    /* There is probably a dependence, but the system of\n-       constraints cannot be built: answer \"don't know\".  */\n-    return false;\n-\n-  /* GCD test.  */\n-  if (DDR_NB_LOOPS (ddr) != 0 && pb->eqs[eq].coef[0]\n-      && !int_divides_p (lambda_vector_gcd\n-\t\t\t ((lambda_vector) &(pb->eqs[eq].coef[1]),\n-\t\t\t  2 * DDR_NB_LOOPS (ddr)),\n-\t\t\t pb->eqs[eq].coef[0]))\n-    {\n-      /* There is no dependence.  */\n-      *maybe_dependent = false;\n-      return true;\n-    }\n-\n-  return true;\n-}\n-\n-/* Helper function, same as init_omega_for_ddr but specialized for\n-   data references A and B.  */\n-\n-static bool\n-init_omega_for_ddr_1 (struct data_reference *dra, struct data_reference *drb,\n-\t\t      struct data_dependence_relation *ddr,\n-\t\t      omega_pb pb, bool *maybe_dependent)\n-{\n-  unsigned i;\n-  int ineq;\n-  struct loop *loopi;\n-  unsigned nb_loops = DDR_NB_LOOPS (ddr);\n-\n-  /* Insert an equality per subscript.  */\n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n-    {\n-      if (!omega_setup_subscript (DR_ACCESS_FN (dra, i), DR_ACCESS_FN (drb, i),\n-\t\t\t\t  ddr, pb, maybe_dependent))\n-\treturn false;\n-      else if (*maybe_dependent == false)\n-\t{\n-\t  /* There is no dependence.  */\n-\t  DDR_ARE_DEPENDENT (ddr) = chrec_known;\n-\t  return true;\n-\t}\n-    }\n-\n-  /* Insert inequalities: constraints corresponding to the iteration\n-     domain, i.e. the loops surrounding the references \"loop_x\" and\n-     the distance variables \"dx\".  The layout of the OMEGA\n-     representation is as follows:\n-     - coef[0] is the constant\n-     - coef[1..nb_loops] are the protected variables that will not be\n-     removed by the solver: the \"dx\"\n-     - coef[nb_loops + 1, 2*nb_loops] are the loop variables: \"loop_x\".\n-  */\n-  for (i = 0; i <= DDR_INNER_LOOP (ddr)\n-\t      && DDR_LOOP_NEST (ddr).iterate (i, &loopi); i++)\n-    {\n-      HOST_WIDE_INT nbi = max_stmt_executions_int (loopi);\n-\n-      /* 0 <= loop_x */\n-      ineq = omega_add_zero_geq (pb, omega_black);\n-      pb->geqs[ineq].coef[i + nb_loops + 1] = 1;\n-\n-      /* 0 <= loop_x + dx */\n-      ineq = omega_add_zero_geq (pb, omega_black);\n-      pb->geqs[ineq].coef[i + nb_loops + 1] = 1;\n-      pb->geqs[ineq].coef[i + 1] = 1;\n-\n-      if (nbi != -1)\n-\t{\n-\t  /* loop_x <= nb_iters */\n-\t  ineq = omega_add_zero_geq (pb, omega_black);\n-\t  pb->geqs[ineq].coef[i + nb_loops + 1] = -1;\n-\t  pb->geqs[ineq].coef[0] = nbi;\n-\n-\t  /* loop_x + dx <= nb_iters */\n-\t  ineq = omega_add_zero_geq (pb, omega_black);\n-\t  pb->geqs[ineq].coef[i + nb_loops + 1] = -1;\n-\t  pb->geqs[ineq].coef[i + 1] = -1;\n-\t  pb->geqs[ineq].coef[0] = nbi;\n-\n-\t  /* A step \"dx\" bigger than nb_iters is not feasible, so\n-\t     add \"0 <= nb_iters + dx\",  */\n-\t  ineq = omega_add_zero_geq (pb, omega_black);\n-\t  pb->geqs[ineq].coef[i + 1] = 1;\n-\t  pb->geqs[ineq].coef[0] = nbi;\n-\t  /* and \"dx <= nb_iters\".  */\n-\t  ineq = omega_add_zero_geq (pb, omega_black);\n-\t  pb->geqs[ineq].coef[i + 1] = -1;\n-\t  pb->geqs[ineq].coef[0] = nbi;\n-\t}\n-    }\n-\n-  omega_extract_distance_vectors (pb, ddr);\n-\n-  return true;\n-}\n-\n-/* Sets up the Omega dependence problem for the data dependence\n-   relation DDR.  Returns false when the constraint system cannot be\n-   built, ie. when the test answers \"don't know\".  Returns true\n-   otherwise, and when independence has been proved (using one of the\n-   trivial dependence test), set MAYBE_DEPENDENT to false, otherwise\n-   set MAYBE_DEPENDENT to true.\n-\n-   Example: for setting up the dependence system corresponding to the\n-   conflicting accesses\n-\n-   | loop_i\n-   |   loop_j\n-   |     A[i, i+1] = ...\n-   |     ... A[2*j, 2*(i + j)]\n-   |   endloop_j\n-   | endloop_i\n-\n-   the following constraints come from the iteration domain:\n-\n-   0 <= i <= Ni\n-   0 <= i + di <= Ni\n-   0 <= j <= Nj\n-   0 <= j + dj <= Nj\n-\n-   where di, dj are the distance variables.  The constraints\n-   representing the conflicting elements are:\n-\n-   i = 2 * (j + dj)\n-   i + 1 = 2 * (i + di + j + dj)\n-\n-   For asking that the resulting distance vector (di, dj) be\n-   lexicographically positive, we insert the constraint \"di >= 0\".  If\n-   \"di = 0\" in the solution, we fix that component to zero, and we\n-   look at the inner loops: we set a new problem where all the outer\n-   loop distances are zero, and fix this inner component to be\n-   positive.  When one of the components is positive, we save that\n-   distance, and set a new problem where the distance on this loop is\n-   zero, searching for other distances in the inner loops.  Here is\n-   the classic example that illustrates that we have to set for each\n-   inner loop a new problem:\n-\n-   | loop_1\n-   |   loop_2\n-   |     A[10]\n-   |   endloop_2\n-   | endloop_1\n-\n-   we have to save two distances (1, 0) and (0, 1).\n-\n-   Given two array references, refA and refB, we have to set the\n-   dependence problem twice, refA vs. refB and refB vs. refA, and we\n-   cannot do a single test, as refB might occur before refA in the\n-   inner loops, and the contrary when considering outer loops: ex.\n-\n-   | loop_0\n-   |   loop_1\n-   |     loop_2\n-   |       T[{1,+,1}_2][{1,+,1}_1]  // refA\n-   |       T[{2,+,1}_2][{0,+,1}_1]  // refB\n-   |     endloop_2\n-   |   endloop_1\n-   | endloop_0\n-\n-   refB touches the elements in T before refA, and thus for the same\n-   loop_0 refB precedes refA: ie. the distance vector (0, 1, -1)\n-   but for successive loop_0 iterations, we have (1, -1, 1)\n-\n-   The Omega solver expects the distance variables (\"di\" in the\n-   previous example) to come first in the constraint system (as\n-   variables to be protected, or \"safe\" variables), the constraint\n-   system is built using the following layout:\n-\n-   \"cst | distance vars | index vars\".\n-*/\n-\n-static bool\n-init_omega_for_ddr (struct data_dependence_relation *ddr,\n-\t\t    bool *maybe_dependent)\n-{\n-  omega_pb pb;\n-  bool res = false;\n-\n-  *maybe_dependent = true;\n-\n-  if (same_access_functions (ddr))\n-    {\n-      unsigned j;\n-      lambda_vector dir_v;\n-\n-      /* Save the 0 vector.  */\n-      save_dist_v (ddr, lambda_vector_new (DDR_NB_LOOPS (ddr)));\n-      dir_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n-      for (j = 0; j < DDR_NB_LOOPS (ddr); j++)\n-\tdir_v[j] = dir_equal;\n-      save_dir_v (ddr, dir_v);\n-\n-      /* Save the dependences carried by outer loops.  */\n-      pb = omega_alloc_problem (2 * DDR_NB_LOOPS (ddr), DDR_NB_LOOPS (ddr));\n-      res = init_omega_for_ddr_1 (DDR_A (ddr), DDR_B (ddr), ddr, pb,\n-\t\t\t\t  maybe_dependent);\n-      omega_free_problem (pb);\n-      return res;\n-    }\n-\n-  /* Omega expects the protected variables (those that have to be kept\n-     after elimination) to appear first in the constraint system.\n-     These variables are the distance variables.  In the following\n-     initialization we declare NB_LOOPS safe variables, and the total\n-     number of variables for the constraint system is 2*NB_LOOPS.  */\n-  pb = omega_alloc_problem (2 * DDR_NB_LOOPS (ddr), DDR_NB_LOOPS (ddr));\n-  res = init_omega_for_ddr_1 (DDR_A (ddr), DDR_B (ddr), ddr, pb,\n-\t\t\t      maybe_dependent);\n-  omega_free_problem (pb);\n-\n-  /* Stop computation if not decidable, or no dependence.  */\n-  if (res == false || *maybe_dependent == false)\n-    return res;\n-\n-  pb = omega_alloc_problem (2 * DDR_NB_LOOPS (ddr), DDR_NB_LOOPS (ddr));\n-  res = init_omega_for_ddr_1 (DDR_B (ddr), DDR_A (ddr), ddr, pb,\n-\t\t\t      maybe_dependent);\n-  omega_free_problem (pb);\n-\n-  return res;\n-}\n-\n-/* Return true when DDR contains the same information as that stored\n-   in DIR_VECTS and in DIST_VECTS, return false otherwise.   */\n-\n-static bool\n-ddr_consistent_p (FILE *file,\n-\t\t  struct data_dependence_relation *ddr,\n-\t\t  vec<lambda_vector> dist_vects,\n-\t\t  vec<lambda_vector> dir_vects)\n-{\n-  unsigned int i, j;\n-\n-  /* If dump_file is set, output there.  */\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    file = dump_file;\n-\n-  if (dist_vects.length () != DDR_NUM_DIST_VECTS (ddr))\n-    {\n-      lambda_vector b_dist_v;\n-      fprintf (file, \"\\n(Number of distance vectors differ: Banerjee has %d, Omega has %d.\\n\",\n-\t       dist_vects.length (),\n-\t       DDR_NUM_DIST_VECTS (ddr));\n-\n-      fprintf (file, \"Banerjee dist vectors:\\n\");\n-      FOR_EACH_VEC_ELT (dist_vects, i, b_dist_v)\n-\tprint_lambda_vector (file, b_dist_v, DDR_NB_LOOPS (ddr));\n-\n-      fprintf (file, \"Omega dist vectors:\\n\");\n-      for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n-\tprint_lambda_vector (file, DDR_DIST_VECT (ddr, i), DDR_NB_LOOPS (ddr));\n-\n-      fprintf (file, \"data dependence relation:\\n\");\n-      dump_data_dependence_relation (file, ddr);\n-\n-      fprintf (file, \")\\n\");\n-      return false;\n-    }\n-\n-  if (dir_vects.length () != DDR_NUM_DIR_VECTS (ddr))\n-    {\n-      fprintf (file, \"\\n(Number of direction vectors differ: Banerjee has %d, Omega has %d.)\\n\",\n-\t       dir_vects.length (),\n-\t       DDR_NUM_DIR_VECTS (ddr));\n-      return false;\n-    }\n-\n-  for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n-    {\n-      lambda_vector a_dist_v;\n-      lambda_vector b_dist_v = DDR_DIST_VECT (ddr, i);\n-\n-      /* Distance vectors are not ordered in the same way in the DDR\n-\t and in the DIST_VECTS: search for a matching vector.  */\n-      FOR_EACH_VEC_ELT (dist_vects, j, a_dist_v)\n-\tif (lambda_vector_equal (a_dist_v, b_dist_v, DDR_NB_LOOPS (ddr)))\n-\t  break;\n-\n-      if (j == dist_vects.length ())\n-\t{\n-\t  fprintf (file, \"\\n(Dist vectors from the first dependence analyzer:\\n\");\n-\t  print_dist_vectors (file, dist_vects, DDR_NB_LOOPS (ddr));\n-\t  fprintf (file, \"not found in Omega dist vectors:\\n\");\n-\t  print_dist_vectors (file, DDR_DIST_VECTS (ddr), DDR_NB_LOOPS (ddr));\n-\t  fprintf (file, \"data dependence relation:\\n\");\n-\t  dump_data_dependence_relation (file, ddr);\n-\t  fprintf (file, \")\\n\");\n-\t}\n-    }\n-\n-  for (i = 0; i < DDR_NUM_DIR_VECTS (ddr); i++)\n-    {\n-      lambda_vector a_dir_v;\n-      lambda_vector b_dir_v = DDR_DIR_VECT (ddr, i);\n-\n-      /* Direction vectors are not ordered in the same way in the DDR\n-\t and in the DIR_VECTS: search for a matching vector.  */\n-      FOR_EACH_VEC_ELT (dir_vects, j, a_dir_v)\n-\tif (lambda_vector_equal (a_dir_v, b_dir_v, DDR_NB_LOOPS (ddr)))\n-\t  break;\n-\n-      if (j == dist_vects.length ())\n-\t{\n-\t  fprintf (file, \"\\n(Dir vectors from the first dependence analyzer:\\n\");\n-\t  print_dir_vectors (file, dir_vects, DDR_NB_LOOPS (ddr));\n-\t  fprintf (file, \"not found in Omega dir vectors:\\n\");\n-\t  print_dir_vectors (file, DDR_DIR_VECTS (ddr), DDR_NB_LOOPS (ddr));\n-\t  fprintf (file, \"data dependence relation:\\n\");\n-\t  dump_data_dependence_relation (file, ddr);\n-\t  fprintf (file, \")\\n\");\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n /* This computes the affine dependence relation between A and B with\n    respect to LOOP_NEST.  CHREC_KNOWN is used for representing the\n    independence between two accesses, while CHREC_DONT_KNOW is used\n@@ -4239,55 +3714,13 @@ compute_affine_dependence (struct data_dependence_relation *ddr,\n \n       if (access_functions_are_affine_or_constant_p (dra, loop_nest)\n \t  && access_functions_are_affine_or_constant_p (drb, loop_nest))\n-\t{\n-\t  subscript_dependence_tester (ddr, loop_nest);\n-\n-\t  if (flag_check_data_deps)\n-\t    {\n-\t      /* Dump the dependences from the first algorithm.  */\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"\\n\\nBanerjee Analyzer\\n\");\n-\t\t  dump_data_dependence_relation (dump_file, ddr);\n-\t\t}\n-\n-\t      if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n-\t\t{\n-\t\t  bool maybe_dependent;\n-\t\t  vec<lambda_vector> dir_vects, dist_vects;\n-\n-\t\t  /* Save the result of the first DD analyzer.  */\n-\t\t  dist_vects = DDR_DIST_VECTS (ddr);\n-\t\t  dir_vects = DDR_DIR_VECTS (ddr);\n-\n-\t\t  /* Reset the information.  */\n-\t\t  DDR_DIST_VECTS (ddr).create (0);\n-\t\t  DDR_DIR_VECTS (ddr).create (0);\n-\n-\t\t  /* Compute the same information using Omega.  */\n-\t\t  if (!init_omega_for_ddr (ddr, &maybe_dependent))\n-\t\t    goto csys_dont_know;\n-\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Omega Analyzer\\n\");\n-\t\t      dump_data_dependence_relation (dump_file, ddr);\n-\t\t    }\n-\n-\t\t  /* Check that we get the same information.  */\n-\t\t  if (maybe_dependent)\n-\t\t    gcc_assert (ddr_consistent_p (stderr, ddr, dist_vects,\n-\t\t\t\t\t\t  dir_vects));\n-\t\t}\n-\t    }\n-\t}\n+\tsubscript_dependence_tester (ddr, loop_nest);\n \n       /* As a last case, if the dependence cannot be determined, or if\n \t the dependence is considered too difficult to determine, answer\n \t \"don't know\".  */\n       else\n \t{\n-\tcsys_dont_know:;\n \t  dependence_stats.num_dependence_undetermined++;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -4731,110 +4164,6 @@ compute_data_dependences_for_loop (struct loop *loop,\n   return res;\n }\n \n-/* Returns true when the data dependences for the basic block BB have been\n-   computed, false otherwise.\n-   DATAREFS is initialized to all the array elements contained in this basic\n-   block, DEPENDENCE_RELATIONS contains the relations between the data\n-   references. Compute read-read and self relations if\n-   COMPUTE_SELF_AND_READ_READ_DEPENDENCES is TRUE.  */\n-bool\n-compute_data_dependences_for_bb (basic_block bb,\n-                                 bool compute_self_and_read_read_dependences,\n-                                 vec<data_reference_p> *datarefs,\n-                                 vec<ddr_p> *dependence_relations)\n-{\n-  if (find_data_references_in_bb (NULL, bb, datarefs) == chrec_dont_know)\n-    return false;\n-\n-  return compute_all_dependences (*datarefs, dependence_relations, vNULL,\n-\t\t\t\t  compute_self_and_read_read_dependences);\n-}\n-\n-/* Entry point (for testing only).  Analyze all the data references\n-   and the dependence relations in LOOP.\n-\n-   The data references are computed first.\n-\n-   A relation on these nodes is represented by a complete graph.  Some\n-   of the relations could be of no interest, thus the relations can be\n-   computed on demand.\n-\n-   In the following function we compute all the relations.  This is\n-   just a first implementation that is here for:\n-   - for showing how to ask for the dependence relations,\n-   - for the debugging the whole dependence graph,\n-   - for the dejagnu testcases and maintenance.\n-\n-   It is possible to ask only for a part of the graph, avoiding to\n-   compute the whole dependence graph.  The computed dependences are\n-   stored in a knowledge base (KB) such that later queries don't\n-   recompute the same information.  The implementation of this KB is\n-   transparent to the optimizer, and thus the KB can be changed with a\n-   more efficient implementation, or the KB could be disabled.  */\n-static void\n-analyze_all_data_dependences (struct loop *loop)\n-{\n-  unsigned int i;\n-  int nb_data_refs = 10;\n-  vec<data_reference_p> datarefs;\n-  datarefs.create (nb_data_refs);\n-  vec<ddr_p> dependence_relations;\n-  dependence_relations.create (nb_data_refs * nb_data_refs);\n-  vec<loop_p> loop_nest;\n-  loop_nest.create (3);\n-\n-  /* Compute DDs on the whole function.  */\n-  compute_data_dependences_for_loop (loop, false, &loop_nest, &datarefs,\n-\t\t\t\t     &dependence_relations);\n-\n-  if (dump_file)\n-    {\n-      dump_data_dependence_relations (dump_file, dependence_relations);\n-      fprintf (dump_file, \"\\n\\n\");\n-\n-      if (dump_flags & TDF_DETAILS)\n-\tdump_dist_dir_vectors (dump_file, dependence_relations);\n-\n-      if (dump_flags & TDF_STATS)\n-\t{\n-\t  unsigned nb_top_relations = 0;\n-\t  unsigned nb_bot_relations = 0;\n-\t  unsigned nb_chrec_relations = 0;\n-\t  struct data_dependence_relation *ddr;\n-\n-\t  FOR_EACH_VEC_ELT (dependence_relations, i, ddr)\n-\t    {\n-\t      if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr)))\n-\t\tnb_top_relations++;\n-\n-\t      else if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n-\t\tnb_bot_relations++;\n-\n-\t      else\n-\t\tnb_chrec_relations++;\n-\t    }\n-\n-\t  gather_stats_on_scev_database ();\n-\t}\n-    }\n-\n-  loop_nest.release ();\n-  free_dependence_relations (dependence_relations);\n-  free_data_refs (datarefs);\n-}\n-\n-/* Computes all the data dependences and check that the results of\n-   several analyzers are the same.  */\n-\n-void\n-tree_check_data_deps (void)\n-{\n-  struct loop *loop_nest;\n-\n-  FOR_EACH_LOOP (loop_nest, 0)\n-    analyze_all_data_dependences (loop_nest);\n-}\n-\n /* Free the memory used by a data dependence relation DDR.  */\n \n void"}, {"sha": "18bcc5c89bb8e436c5becc6a6cada77672991233", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_DATA_REF_H\n \n #include \"graphds.h\"\n-#include \"omega.h\"\n #include \"tree-chrec.h\"\n \n /*\n@@ -301,9 +300,6 @@ extern bool compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       vec<loop_p> *,\n \t\t\t\t\t       vec<data_reference_p> *,\n \t\t\t\t\t       vec<ddr_p> *);\n-extern bool compute_data_dependences_for_bb (basic_block, bool,\n-                                             vec<data_reference_p> *,\n-                                             vec<ddr_p> *);\n extern void debug_ddrs (vec<ddr_p> );\n extern void dump_data_reference (FILE *, struct data_reference *);\n extern void debug (data_reference &ref);\n@@ -343,8 +339,6 @@ extern bool dr_may_alias_p (const struct data_reference *,\n \t\t\t    const struct data_reference *, bool);\n extern bool dr_equal_offsets_p (struct data_reference *,\n                                 struct data_reference *);\n-extern void tree_check_data_deps (void);\n-\n \n /* Return true when the base objects of data references A and B are\n    the same memory object.  */"}, {"sha": "078b1d128c70966851a3cb363508520cb3a99d32", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -286,54 +286,6 @@ make_pass_vectorize (gcc::context *ctxt)\n   return new pass_vectorize (ctxt);\n }\n \n-/* Check the correctness of the data dependence analyzers.  */\n-\n-namespace {\n-\n-const pass_data pass_data_check_data_deps =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"ckdd\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  TV_CHECK_DATA_DEPS, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_check_data_deps : public gimple_opt_pass\n-{\n-public:\n-  pass_check_data_deps (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_check_data_deps, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_check_data_deps != 0; }\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_check_data_deps\n-\n-unsigned int\n-pass_check_data_deps::execute (function *fun)\n-{\n-  if (number_of_loops (fun) <= 1)\n-    return 0;\n-\n-  tree_check_data_deps ();\n-  return 0;\n-}\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_check_data_deps (gcc::context *ctxt)\n-{\n-  return new pass_check_data_deps (ctxt);\n-}\n-\n /* Propagation of constants using scev.  */\n \n namespace {"}, {"sha": "633ccc7edf23c14aa592c5b6ad8a037aa1b799ee", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-inline.h\"\n+#include \"params.h\"\n \n static unsigned int tree_ssa_phiopt_worker (bool, bool);\n static bool conditional_replacement (basic_block, basic_block,"}, {"sha": "731fe7decc51a14d72a6106909ea1d14ee65a542", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-codes.h\"\n #include \"optabs.h\"\n #include \"builtins.h\"\n+#include \"params.h\"\n \n /* Return true if load- or store-lanes optab OPTAB is implemented for\n    COUNT vectors of type VECTYPE.  NAME is the name of OPTAB.  */"}, {"sha": "2face16501fff7e7f3158a6a84466131a44db4b9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b8fe6c1a585edfeb5dd0f292e05a167f475f68/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=49b8fe6c1a585edfeb5dd0f292e05a167f475f68", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backend.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n+#include \"params.h\"\n #include \"rtl.h\"\n #include \"ssa.h\"\n #include \"alias.h\""}]}