{"sha": "cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YzNTY2N2UyMzEyZWZlNGNjYTMyMjZhN2M1YTAzZGMxYmM5ZTVmYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-13T15:12:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-13T15:12:02Z"}, "message": "tree-vrp.c (vrp_meet): Properly meet equivalent ranges.\n\n2012-06-13  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (vrp_meet): Properly meet equivalent ranges.\n\tHandle meeting two VR_RANGE to an VR_ANTI_RANGE.  Implement\n\tall possible meetings of VR_RANGE with VR_ANTI_RANGE and\n\tVR_ANTI_RANGE with VR_ANTI_RANGE.\n\nFrom-SVN: r188517", "tree": {"sha": "d7620c3d583ed70475ddfa861a04ff8f8a1a9b3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7620c3d583ed70475ddfa861a04ff8f8a1a9b3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31e3bc1b6c6bffd7785e223cf7b70203d71ff08f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f"}], "stats": {"total": 218, "additions": 149, "deletions": 69}, "files": [{"sha": "094c25b739ec30848f445074ab82a1b1cbc54351", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb", "patch": "@@ -1,3 +1,10 @@\n+2012-06-13  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (vrp_meet): Properly meet equivalent ranges.\n+\tHandle meeting two VR_RANGE to an VR_ANTI_RANGE.  Implement\n+\tall possible meetings of VR_RANGE with VR_ANTI_RANGE and\n+\tVR_ANTI_RANGE with VR_ANTI_RANGE.\n+\n 2012-06-13  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config.gcc (unsupported): Move obsoleted FPA-based configurations"}, {"sha": "65ddb0fda577d0f24627a2333301f21c70bd7769", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 142, "deletions": 69, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=cf35667e2312efe4cca3226a7c5a03dc1bc9e5fb", "patch": "@@ -6914,94 +6914,167 @@ vrp_meet (value_range_t *vr0, value_range_t *vr1)\n       return;\n     }\n \n-  if (vr0->type == VR_RANGE && vr1->type == VR_RANGE)\n+  if (vr0->type == vr1->type\n+      && compare_values (vr0->min, vr1->min) == 0\n+      && compare_values (vr0->max, vr1->max) == 0)\n+    {\n+      /* If the value-ranges are identical just insersect\n+\t their equivalencies.  */\n+    }\n+  else if (vr0->type == VR_RANGE && vr1->type == VR_RANGE)\n     {\n       int cmp;\n       tree min, max;\n \n-      /* Compute the convex hull of the ranges.  The lower limit of\n-         the new range is the minimum of the two ranges.  If they\n+      /* If the two ranges represent an anti-range produce a\n+\t VR_RANGE with swapped min/max and let the range canonicalization\n+\t fix things up.  */\n+      if (vrp_val_is_min (vr0->min) && !is_overflow_infinity (vr0->min)\n+\t  && vrp_val_is_max (vr1->max) && !is_overflow_infinity (vr1->max)\n+\t  && TREE_CODE (vr1->min) == INTEGER_CST\n+\t  && TREE_CODE (vr0->max) == INTEGER_CST\n+\t  && compare_values (vr0->max, vr1->min) == -1)\n+\t{\n+\t  min = vr1->min;\n+\t  max = vr0->max;\n+\t}\n+      else if (vrp_val_is_min (vr1->min) && !is_overflow_infinity (vr1->min)\n+\t       && vrp_val_is_max (vr0->max) && !is_overflow_infinity (vr0->max)\n+\t       && TREE_CODE (vr1->max) == INTEGER_CST\n+\t       && TREE_CODE (vr0->min) == INTEGER_CST\n+\t       && compare_values (vr1->max, vr0->min) == -1)\n+\t{\n+\t  max = vr1->max;\n+\t  min = vr0->min;\n+\t}\n+      /* Otherwise compute the convex hull of the ranges.  The lower limit of\n+\t the new range is the minimum of the two ranges.  If they\n \t cannot be compared, then give up.  */\n-      cmp = compare_values (vr0->min, vr1->min);\n-      if (cmp == 0 || cmp == 1)\n-        min = vr1->min;\n-      else if (cmp == -1)\n-        min = vr0->min;\n-      else\n-\tgoto give_up;\n-\n-      /* Similarly, the upper limit of the new range is the maximum\n-         of the two ranges.  If they cannot be compared, then\n-\t give up.  */\n-      cmp = compare_values (vr0->max, vr1->max);\n-      if (cmp == 0 || cmp == -1)\n-        max = vr1->max;\n-      else if (cmp == 1)\n-        max = vr0->max;\n       else\n-\tgoto give_up;\n-\n-      /* Check for useless ranges.  */\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (min))\n-\t  && ((vrp_val_is_min (min) || is_overflow_infinity (min))\n-\t      && (vrp_val_is_max (max) || is_overflow_infinity (max))))\n-\tgoto give_up;\n-\n-      /* The resulting set of equivalences is the intersection of\n-\t the two sets.  */\n-      if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n-        bitmap_and_into (vr0->equiv, vr1->equiv);\n-      else if (vr0->equiv && !vr1->equiv)\n-        bitmap_clear (vr0->equiv);\n-\n-      set_value_range (vr0, vr0->type, min, max, vr0->equiv);\n-    }\n-  else if (vr0->type == VR_ANTI_RANGE && vr1->type == VR_ANTI_RANGE)\n-    {\n-      /* Two anti-ranges meet only if their complements intersect.\n-         Only handle the case of identical ranges.  */\n-      if (compare_values (vr0->min, vr1->min) == 0\n-\t  && compare_values (vr0->max, vr1->max) == 0\n-\t  && compare_values (vr0->min, vr0->max) == 0)\n \t{\n-\t  /* The resulting set of equivalences is the intersection of\n-\t     the two sets.  */\n-\t  if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n-\t    bitmap_and_into (vr0->equiv, vr1->equiv);\n-\t  else if (vr0->equiv && !vr1->equiv)\n-\t    bitmap_clear (vr0->equiv);\n+\t  cmp = compare_values (vr0->min, vr1->min);\n+\t  if (cmp == 0 || cmp == 1)\n+\t    min = vr1->min;\n+\t  else if (cmp == -1)\n+\t    min = vr0->min;\n+\t  else\n+\t    goto give_up;\n+\n+\t  /* Similarly, the upper limit of the new range is the maximum\n+\t     of the two ranges.  If they cannot be compared, then\n+\t     give up.  */\n+\t  cmp = compare_values (vr0->max, vr1->max);\n+\t  if (cmp == 0 || cmp == -1)\n+\t    max = vr1->max;\n+\t  else if (cmp == 1)\n+\t    max = vr0->max;\n+\t  else\n+\t    goto give_up;\n+\n+\t  /* Check for useless ranges.  */\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (min))\n+\t      && ((vrp_val_is_min (min) || is_overflow_infinity (min))\n+\t\t  && (vrp_val_is_max (max) || is_overflow_infinity (max))))\n+\t    goto give_up;\n \t}\n-      else\n-\tgoto give_up;\n+\n+      set_and_canonicalize_value_range (vr0, vr0->type, min, max, vr0->equiv);\n     }\n   else if (vr0->type == VR_ANTI_RANGE || vr1->type == VR_ANTI_RANGE)\n     {\n-      /* For a numeric range [VAL1, VAL2] and an anti-range ~[VAL3, VAL4],\n-         only handle the case where the ranges have an empty intersection.\n-\t The result of the meet operation is the anti-range.  */\n-      if (!symbolic_range_p (vr0)\n-\t  && !symbolic_range_p (vr1)\n-\t  && !value_ranges_intersect_p (vr0, vr1))\n-\t{\n-\t  /* Copy most of VR1 into VR0.  Don't copy VR1's equivalence\n-\t     set.  We need to compute the intersection of the two\n-\t     equivalence sets.  */\n-\t  if (vr1->type == VR_ANTI_RANGE)\n-\t    set_value_range (vr0, vr1->type, vr1->min, vr1->max, vr0->equiv);\n+      if (symbolic_range_p (vr0)\n+\t  || symbolic_range_p (vr1))\n+\tgoto give_up;\n \n-\t  /* The resulting set of equivalences is the intersection of\n-\t     the two sets.  */\n-\t  if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n-\t    bitmap_and_into (vr0->equiv, vr1->equiv);\n-\t  else if (vr0->equiv && !vr1->equiv)\n-\t    bitmap_clear (vr0->equiv);\n+      /* [] is vr0, () is vr1 in the following classification comments.  */\n+      if (operand_less_p (vr0->max, vr1->min) == 1\n+\t  || operand_less_p (vr1->max, vr0->min) == 1)\n+\t{\n+\t  /* [ ] ( ) or ( ) [ ]\n+\t     If the ranges have an empty intersection, result of the meet\n+\t     operation is the anti-range or if both are anti-ranges\n+\t     it covers all.  */\n+\t  if (vr0->type == VR_ANTI_RANGE\n+\t      && vr1->type == VR_ANTI_RANGE)\n+\t    goto give_up;\n+\t  else if (vr1->type == VR_ANTI_RANGE)\n+\t    set_value_range (vr0, vr1->type, vr1->min, vr1->max, vr0->equiv);\n+\t}\n+      else if (operand_less_p (vr1->max, vr0->max) == 1\n+\t       && operand_less_p (vr0->min, vr1->min) == 1)\n+\t{\n+\t  /* [ (  ) ]\n+\t     Arbitrarily choose the left or inner gap.  */\n+\t  if (vr0->type == VR_ANTI_RANGE\n+\t      && vr1->type == VR_ANTI_RANGE)\n+\t    set_value_range (vr0, vr1->type, vr1->min, vr1->max, vr0->equiv);\n+\t  else if (vr0->type == VR_ANTI_RANGE)\n+\t    set_and_canonicalize_value_range (vr0, vr0->type, vr0->min,\n+\t\t      int_const_binop (MINUS_EXPR, vr1->min, integer_one_node),\n+\t\t\t\t\t      vr0->equiv);\n+\t  else\n+\t    goto give_up;\n+\t}\n+      else if (operand_less_p (vr0->max, vr1->max) == 1\n+\t       && operand_less_p (vr1->min, vr0->min) == 1)\n+\t{\n+\t  /* ( [  ] )\n+\t     Arbitrarily choose the left or inner gap.  */\n+\t  if (vr0->type == VR_ANTI_RANGE\n+\t      && vr1->type == VR_ANTI_RANGE)\n+\t    /* Nothing to do.  */;\n+\t  else if (vr1->type == VR_ANTI_RANGE)\n+\t    set_and_canonicalize_value_range (vr0, vr1->type, vr1->min,\n+\t\t      int_const_binop (MINUS_EXPR, vr0->min, integer_one_node),\n+\t\t\t\t\t      vr0->equiv);\n+\t  else\n+\t    goto give_up;\n+\t}\n+      else if (operand_less_p (vr1->min, vr0->max) == 1\n+\t       && operand_less_p (vr0->max, vr1->max) == 1)\n+\t{\n+\t  /* [  ( ]  ) */\n+\t  if (vr0->type == VR_ANTI_RANGE\n+\t      && vr1->type == VR_ANTI_RANGE)\n+\t    set_value_range (vr0, vr0->type, vr1->min, vr0->max, vr0->equiv);\n+\t  else if (vr0->type == VR_ANTI_RANGE)\n+\t    set_and_canonicalize_value_range (vr0, vr0->type, vr0->min,\n+\t\t      int_const_binop (MINUS_EXPR, vr1->min, integer_one_node),\n+\t\t\t\t\t      vr0->equiv);\n+\t  else\n+\t    set_and_canonicalize_value_range (vr0, vr1->type,\n+\t\t      int_const_binop (PLUS_EXPR, vr0->max, integer_one_node),\n+\t\t\t\t\t      vr1->max, vr0->equiv);\n+\t}\n+      else if (operand_less_p (vr0->min, vr1->max) == 1\n+\t       && operand_less_p (vr1->max, vr0->max) == 1)\n+\t{\n+\t  /* (  [ )  ] */\n+\t  if (vr0->type == VR_ANTI_RANGE\n+\t      && vr1->type == VR_ANTI_RANGE)\n+\t    set_value_range (vr0, vr1->type, vr0->min, vr1->max, vr0->equiv);\n+\t  else if (vr0->type == VR_ANTI_RANGE)\n+\t    set_and_canonicalize_value_range (vr0, vr0->type,\n+\t\t      int_const_binop (PLUS_EXPR, vr1->max, integer_one_node),\n+\t\t\t\t\t      vr0->max, vr0->equiv);\n+\t  else\n+\t    set_and_canonicalize_value_range (vr0, vr1->type, vr1->min,\n+\t\t      int_const_binop (MINUS_EXPR, vr0->min, integer_one_node),\n+\t\t\t\t\t      vr0->equiv);\n \t}\n       else\n \tgoto give_up;\n     }\n   else\n     gcc_unreachable ();\n \n+  /* The resulting set of equivalences is always the intersection of\n+     the two sets.  Above we always left the equivalency set of vr0 as-is.  */\n+  if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n+    bitmap_and_into (vr0->equiv, vr1->equiv);\n+  else if (vr0->equiv && !vr1->equiv)\n+    bitmap_clear (vr0->equiv);\n+\n   return;\n \n give_up:"}]}