{"sha": "012309e6a8dbb77cea4e916d8328ba7e63a592f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyMzA5ZTZhOGRiYjc3Y2VhNGU5MTZkODMyOGJhN2U2M2E1OTJmNA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-06-06T18:55:59Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-06-06T18:55:59Z"}, "message": "tree-ssa-reassoc.o: New.\n\n\n2005-06-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-reassoc.o: New.\n\t(OBJS-common): Add tree-ssa-reassoc.o\n\t* timevar.def: Add TV_TREE_REASSOC\n\t* tree-optimize.c (pass_reassoc): Add call.\n\t* tree-pass.h (pass_reassoc): Add.\n\t* tree-ssa-reassoc.c: New file.\n\nFrom-SVN: r100671", "tree": {"sha": "11c324a5288dcd4957b6284d04b14fb936edf89d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11c324a5288dcd4957b6284d04b14fb936edf89d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/012309e6a8dbb77cea4e916d8328ba7e63a592f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012309e6a8dbb77cea4e916d8328ba7e63a592f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/012309e6a8dbb77cea4e916d8328ba7e63a592f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012309e6a8dbb77cea4e916d8328ba7e63a592f4/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08fd6d04199ac8d1f1571d1f807853b8ff7f2fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08fd6d04199ac8d1f1571d1f807853b8ff7f2fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08fd6d04199ac8d1f1571d1f807853b8ff7f2fc0"}], "stats": {"total": 693, "additions": 689, "deletions": 4}, "files": [{"sha": "fa63fbb261c60bc3e48a6f1da54c93a9789b4155", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -1,3 +1,12 @@\n+2005-06-06  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-reassoc.o: New.\n+\t(OBJS-common): Add tree-ssa-reassoc.o\n+\t* timevar.def: Add TV_TREE_REASSOC\n+\t* tree-optimize.c (pass_reassoc): Add call.\n+\t* tree-pass.h (pass_reassoc): Add.\n+\t* tree-ssa-reassoc.c: New file.\n+\n 2005-06-06  Eric Christopher  <echristo@redhat.com>\n \n \ttarget/21927"}, {"sha": "5146c78c19b098b7b76dc888fe8674c27bb758f5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -962,7 +962,8 @@ OBJS-common = \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n  lambda-trans.o lambda-code.o tree-loop-linear.o tree-ssa-sink.o           \\\n- tree-vrp.o tree-stdarg.o tree-cfgcleanup.o\n+ tree-vrp.o tree-stdarg.o tree-cfgcleanup.o tree-ssa-reassoc.o\n+\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1736,8 +1737,8 @@ tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \\\n-   alloc-pool.h $(BASIC_BLOCK_H) bitmap.h $(FIBHEAP_H) $(HASHTAB_H) \\\n-   langhooks.h real.h $(TREE_GIMPLE_H) tree-inline.h tree-iterator.h\n+   alloc-pool.h $(BASIC_BLOCK_H) bitmap.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n+   tree-inline.h tree-iterator.h\n tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(TREE_H) $(TREE_FLOW_H) $(HASHTAB_H) langhooks.h tree-pass.h \\\n    $(TREE_DUMP_H) $(DIAGNOSTIC_H)\n@@ -1836,6 +1837,10 @@ tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \\\n    $(TREE_DUMP_H) tree-pass.h $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    hard-reg-set.h $(TREE_GIMPLE_H) vec.h\n+tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \\\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\\\n+   $(BASIC_BLOCK_H) $(HASHTAB_H) $(TREE_GIMPLE_H) tree-inline.h\n tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n    $(FLAGS_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) toplev.h \\"}, {"sha": "a4597b196d71db420e32014c96f9313d7f356556", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-7.c?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -31,5 +31,5 @@ int xxx (void)\n    Calls to cst_fun2 and pure_fun2 should not be, since calling\n    with k = 0 may be invalid.  */\n \n-/* { dg-final { scan-tree-dump-times \"Moving statement\" 2 \"lim\" } } */\n+/* { dg-final { scan-tree-dump-times \"Moving statement\" 3 \"lim\" } } */\n /* { dg-final { cleanup-tree-dump \"lim\" } } */"}, {"sha": "b9cdff36285f901e42dbf18456ce0ff52a983fbb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+int a, b, c, d;\n+extern int printf (const char *, ...);\n+int main(void)\n+{\n+  int e;\n+  int f;\n+  /* We should be able to transform these into the same expression, and only have two additions.  */\n+  e = a + b;\n+  e = e + c;\n+  f = c + a;\n+  f = f + b;\n+  printf (\"%d %d\\n\", e, f);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"a \\\\\\+ b\" 1 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "6171fb903e571264833a9bcaf27725bbcf9d5ee3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-reassoc-details\" } */\n+extern int a0, a1, a2, a3, a4; \n+int f () \n+{ \n+int b0, b1, b2, b3, b4; \n+  /* this can be optimized to four additions... */ \n+  b4 = a4 + a3 + a2 + a1 + a0; \n+  b3 = a3 + a2 + a1 + a0; \n+  b2 = a2 + a1 + a0; \n+  b1 = a1 + a0; \n+  /* This is actually 0 */\n+  return b4 - b3 + b2 - b1 - a4 - a2;\n+} \n+/* { dg-final { scan-tree-dump-times \"Reassociating by rank\" 3 \"reassoc\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc\" } } */"}, {"sha": "9b706abc361da81ee8dc2049407cd1538dccbeef", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -82,6 +82,7 @@ DEFTIMEVAR (TV_TREE_SRA              , \"tree SRA\")\n DEFTIMEVAR (TV_TREE_STORE_CCP\t     , \"tree STORE-CCP\")\n DEFTIMEVAR (TV_TREE_CCP\t\t     , \"tree CCP\")\n DEFTIMEVAR (TV_TREE_SPLIT_EDGES      , \"tree split crit edges\")\n+DEFTIMEVAR (TV_TREE_REASSOC          , \"tree reassociation\")\n DEFTIMEVAR (TV_TREE_PRE\t\t     , \"tree PRE\")\n DEFTIMEVAR (TV_TREE_REDPHI\t     , \"tree redundant PHIs\")\n DEFTIMEVAR (TV_TREE_FRE\t\t     , \"tree FRE\")"}, {"sha": "76357fc921225b1c4c30193aa0b86f98dde49615", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -439,6 +439,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_cse_reciprocals);\n   NEXT_PASS (pass_split_crit_edges);\n+  NEXT_PASS (pass_reassoc);\n   NEXT_PASS (pass_pre);\n   NEXT_PASS (pass_sink_code);\n   NEXT_PASS (pass_loop);"}, {"sha": "12e2a58f203d35dd38a57752668a6530a5179330", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -221,7 +221,9 @@ extern struct tree_opt_pass pass_store_copy_prop;\n extern struct tree_opt_pass pass_vrp;\n extern struct tree_opt_pass pass_create_structure_vars;\n extern struct tree_opt_pass pass_uncprop;\n+extern struct tree_opt_pass pass_reassoc;\n \n+/* IPA Passes */\n extern struct tree_opt_pass pass_ipa_inline;\n \n #endif /* GCC_TREE_PASS_H */"}, {"sha": "4f033e91070136d4934b0c5f489c959bae1712a8", "filename": "gcc/tree-ssa-reassoc.c", "status": "added", "additions": 631, "deletions": 0, "changes": 631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012309e6a8dbb77cea4e916d8328ba7e63a592f4/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=012309e6a8dbb77cea4e916d8328ba7e63a592f4", "patch": "@@ -0,0 +1,631 @@\n+/* Reassociation for trees.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dan@dberlin.org>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-inline.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"hashtab.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-pass.h\"\n+\n+/*  This is a simple global reassociation pass that uses a combination\n+    of heuristics and a hashtable to try to expose more operations to\n+    CSE.  \n+\n+    The basic idea behind the heuristic is to rank expressions by\n+    depth of the computation tree and loop depth, and try to produce\n+    expressions consisting of small rank operations, as they are more\n+    likely to reoccur.  In addition, we use a hashtable to try to see\n+    if we can transpose an operation into something we have seen\n+    before.\n+\n+    Note that the way the hashtable is structured will sometimes find\n+    matches that will not expose additional redundancies, since it is\n+    not unwound as we traverse back up one branch of the dominator\n+    tree and down another.  However, the cost of improving this is\n+    probably not worth the additional benefits it will bring.  */\n+\n+/* Statistics */\n+static struct\n+{\n+  int reassociated_by_rank;\n+  int reassociated_by_match;\n+} reassociate_stats;\n+\n+\n+\n+/* Seen binary operator hashtable.  */\n+static htab_t seen_binops;\n+\n+/* Binary operator struct. */\n+\n+typedef struct seen_binop_d\n+{\n+  tree op1;\n+  tree op2;\n+} *seen_binop_t;\n+\n+/* Return a SEEN_BINOP_T if we have seen an associative binary\n+   operator with OP1 and OP2 in it.  */\n+\n+static seen_binop_t\n+find_seen_binop (tree op1, tree op2)\n+{\n+  void **slot;\n+  struct seen_binop_d sbd;\n+  sbd.op1 = op1;\n+  sbd.op2 = op2;\n+  slot = htab_find_slot (seen_binops, &sbd, NO_INSERT);\n+  if (!slot)\n+    return NULL;\n+  return ((seen_binop_t) *slot);\n+}\n+\n+/* Insert a binary operator consisting of OP1 and OP2 into the\n+   SEEN_BINOP table.  */\n+\n+static void\n+insert_seen_binop (tree op1, tree op2)\n+{\n+  void **slot;\n+  seen_binop_t new_pair = xmalloc (sizeof (*new_pair));\n+  new_pair->op1 = op1;\n+  new_pair->op2 = op2;\n+  slot = htab_find_slot (seen_binops, new_pair, INSERT);\n+  if (*slot != NULL)\n+    free (*slot);\n+  *slot = new_pair;\n+}\n+\n+/* Return the hash value for a seen binop structure pointed to by P.\n+   Because all the binops we consider are associative, we just add the\n+   hash value for op1 and op2.  */\n+\n+static hashval_t\n+seen_binop_hash (const void *p)\n+{\n+  const seen_binop_t sb = (seen_binop_t) p;\n+  return iterative_hash_expr (sb->op1, 0) + iterative_hash_expr (sb->op2, 0);\n+}\n+\n+/* Return true if two seen binop structures pointed to by P1 and P2 are equal.\n+   We have to check the operators both ways because we don't know what\n+   order they appear in the table.  */\n+\n+static int\n+seen_binop_eq (const void *p1, const void *p2)\n+{\n+  const seen_binop_t sb1 = (seen_binop_t) p1;\n+  const seen_binop_t sb2 = (seen_binop_t) p2;\n+  return (sb1->op1 == sb2->op1 && sb1->op2 == sb2->op2)\n+    || (sb1->op2 == sb2->op1 && sb1->op1 == sb2->op2);\n+}\n+\n+/* Value rank structure.  */\n+\n+typedef struct valrank_d\n+{\n+  tree e;   \n+  unsigned int rank;  \n+} *valrank_t;\n+\n+/* Starting rank number for a given basic block, so that we can rank\n+   operations using unmovable instructions in that BB based on the bb\n+   depth.  */\n+static unsigned int *bb_rank;\n+\n+/* Value rank hashtable.  */\n+static htab_t value_rank;\n+\n+\n+/* Look up the value rank structure for expression E.  */\n+\n+static valrank_t\n+find_value_rank (tree e)\n+{\n+  void **slot;\n+  struct valrank_d vrd;\n+  vrd.e = e;\n+  slot = htab_find_slot (value_rank, &vrd, NO_INSERT);\n+  if (!slot)\n+    return NULL;\n+  return ((valrank_t) *slot);\n+}\n+\n+/* Insert {E,RANK} into the value rank hashtable.  */\n+\n+static void\n+insert_value_rank (tree e, unsigned int rank)\n+{\n+  void **slot;\n+  valrank_t new_pair = xmalloc (sizeof (*new_pair));\n+  new_pair->e = e;\n+  new_pair->rank = rank;\n+  slot = htab_find_slot (value_rank, new_pair, INSERT);\n+  gcc_assert (*slot == NULL);\n+  *slot = new_pair;\n+\n+}\n+\n+\n+/* Return the hash value for a value rank structure  */\n+\n+static hashval_t\n+valrank_hash (const void *p)\n+{\n+  const valrank_t vr = (valrank_t) p;\n+  return iterative_hash_expr (vr->e, 0);\n+}\n+\n+/* Return true if two value rank structures are equal.  */\n+\n+static int\n+valrank_eq (const void *p1, const void *p2)\n+{\n+  const valrank_t vr1 = (valrank_t) p1;\n+  const valrank_t vr2 = (valrank_t) p2;\n+  return vr1->e == vr2->e;\n+}\n+\n+\n+/* Initialize the reassociation pass.  */\n+\n+static void\n+init_reassoc (void)\n+{\n+  int i;\n+  unsigned int rank = 2;\n+  \n+  tree param;\n+  int *bbs = xmalloc ((last_basic_block + 1) * sizeof (int));\n+  \n+  memset (&reassociate_stats, 0, sizeof (reassociate_stats));\n+\n+  /* Reverse RPO (Reverse Post Order) will give us something where\n+     deeper loops come later.  */\n+  flow_reverse_top_sort_order_compute (bbs);\n+  bb_rank = xcalloc (last_basic_block + 1, sizeof (unsigned int));\n+  value_rank = htab_create (511, valrank_hash,\n+\t\t\t    valrank_eq, free);\n+  seen_binops = htab_create (511, seen_binop_hash,\n+\t\t\t     seen_binop_eq, free);\n+\n+  /* Give each argument a distinct rank.   */\n+  for (param = DECL_ARGUMENTS (current_function_decl);\n+       param;\n+       param = TREE_CHAIN (param))\n+    {\n+      if (default_def (param) != NULL)\n+\t{\n+\t  tree def = default_def (param);\n+\t  insert_value_rank (def, ++rank);\n+\t}\n+    }\n+  \n+  /* Set up rank for each BB  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    bb_rank[bbs[i]] = ++rank  << 16;\n+\n+  free (bbs);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+}\n+\n+/* Cleanup after the reassociation pass, and print stats if\n+   requested.  */\n+\n+static void\n+fini_reassoc (void)\n+{\n+\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    {\n+      fprintf (dump_file, \"Reassociation stats:\\n\");\n+      fprintf (dump_file, \"Reassociated by rank: %d\\n\", reassociate_stats.reassociated_by_rank);\n+      fprintf (dump_file, \"Reassociated by match: %d\\n\", reassociate_stats.reassociated_by_match);\n+    }\n+  htab_delete (value_rank);\n+  htab_delete (seen_binops);\n+  free (bb_rank);\n+}\n+\n+/* Given an expression E, return the rank of the expression.  */\n+\n+static unsigned int\n+get_rank (tree e)\n+{\n+  valrank_t vr;\n+\n+  /* Constants have rank 0.  */  \n+  if (is_gimple_min_invariant (e))\n+    return 0;\n+  \n+  /* SSA_NAME's have the rank of the expression they are the result\n+     of.\n+     For globals and uninitialized values, the rank is 0.\n+     For function arguments, use the pre-setup rank.\n+     For PHI nodes, stores, asm statements, etc, we use the rank of\n+     the BB.\n+     For simple operations, the rank is the maximum rank of any of\n+     its operands, or the bb_rank, whichever is less.\n+     I make no claims that this is optimal, however, it gives good\n+     results.  */\n+\n+  if (TREE_CODE (e) == SSA_NAME)\n+    {\n+      tree stmt;\n+      tree rhs;      \n+      unsigned int rank, maxrank;\n+      int i;\n+      \n+      if (TREE_CODE (SSA_NAME_VAR (e)) == PARM_DECL\n+\t  && e == default_def (SSA_NAME_VAR (e)))\n+\treturn find_value_rank (e)->rank;\n+      \n+      stmt = SSA_NAME_DEF_STMT (e);\n+      if (bb_for_stmt (stmt) == NULL)\n+\treturn 0;\n+      \n+      if (TREE_CODE (stmt) != MODIFY_EXPR\n+\t  || !ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n+\treturn bb_rank[bb_for_stmt (stmt)->index];\n+\n+      /* If we already have a rank for this expression, use that.  */\n+      vr = find_value_rank (e);\n+      if (vr)\n+\treturn vr->rank;\n+\n+      /* Otherwise, find the maximum rank for the operands, or the bb\n+\t rank, whichever is less.   */\n+      rank = 0;\n+      maxrank = bb_rank[bb_for_stmt(stmt)->index];\n+      rhs = TREE_OPERAND (stmt, 1);\n+      if (TREE_CODE_LENGTH (TREE_CODE (rhs)) == 0)\n+\trank = MAX (rank, get_rank (rhs));\n+      else \n+\t{\n+\t  for (i = 0; \n+\t       i < TREE_CODE_LENGTH (TREE_CODE (rhs)) \n+\t\t && TREE_OPERAND (rhs, i)\n+\t\t && rank != maxrank; i++)\n+\t    rank = MAX(rank, get_rank (TREE_OPERAND (rhs, i)));\n+\t}\n+      \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Rank for \");\n+\t  print_generic_expr (dump_file, e, 0);\n+\t  fprintf (dump_file, \" is %d\\n\", (rank + 1));\n+\t}\n+      \n+      /* Note the rank in the hashtable so we don't recompute it.  */\n+      insert_value_rank (e, (rank + 1));\n+      return (rank + 1);\n+    }\n+\n+  /* Globals, etc,  are rank 0 */\n+  return 0;\n+}\n+\n+\n+/* Decide whether we should transpose RHS and some operand of\n+   LHSDEFOP.\n+   If yes, then return true and set TAKEOP to the operand number of LHSDEFOP to\n+   switch RHS for.\n+   Otherwise, return false.  */\n+\n+static bool\n+should_transpose (tree rhs ATTRIBUTE_UNUSED, \n+\t\t  unsigned int rhsrank,\n+\t\t  tree lhsdefop, unsigned int *takeop)\n+{\n+  /* Attempt to expose the low ranked\n+     arguments to CSE if we have something like:\n+     a = <rank 2> + c (rank 1)\n+     b = a (rank 3) + d (rank 1)\n+     We want to transform this into:\n+     a = c + d\n+     b = <rank 2> + <rank 3>\n+     \n+     The op finding part wouldn't be necessary if\n+\t\t\t we could swap the operands above and not have\n+\t\t\t update_stmt change them back on us.\n+  */\n+  unsigned int lowrankop;\n+  unsigned int lowrank;\n+  unsigned int highrank;\n+  unsigned int highrankop;\n+  unsigned int temp;\n+  \n+  lowrankop = 0;\n+  *takeop = 1;\n+  lowrank = get_rank (TREE_OPERAND (lhsdefop, 0));\n+  temp = get_rank (TREE_OPERAND (lhsdefop, 1));\n+  highrank = temp;\n+  highrankop = 1;\n+  if (temp < lowrank)\n+    {\n+      lowrankop = 1;\n+      highrankop = 0;\n+      *takeop = 0;\n+      highrank = lowrank;\n+      lowrank = temp;\n+    }\n+  \n+  /* If highrank == lowrank, then we had something\n+     like:\n+     a = <rank 1> + <rank 1> \n+     already, so there is no guarantee that\n+     swapping our argument in is going to be\n+     better.\n+     If we run reassoc twice, we could probably\n+     have a flag that switches this behavior on,\n+     so that we try once without it, and once with\n+     it, so that redundancy elimination sees it\n+     both ways.\n+  */\t\t      \n+  \n+  if (lowrank == rhsrank && highrank != lowrank)\n+    return true;\n+\n+  /* Also, see if the LHS's high ranked op should be switched with our\n+     RHS simply because it is greater in rank than our current RHS.  */\n+  if (TREE_CODE (TREE_OPERAND (lhsdefop, 0)) == SSA_NAME)\n+    {\n+      tree iop = SSA_NAME_DEF_STMT (TREE_OPERAND (lhsdefop, highrankop));\n+      if (TREE_CODE (iop) == MODIFY_EXPR)\n+\tiop = TREE_OPERAND (iop, 1);\n+      if (TREE_CODE (iop) == TREE_CODE (lhsdefop))\n+\t*takeop = 1;\n+      if (rhsrank < get_rank (TREE_OPERAND (lhsdefop, *takeop)))\n+\treturn true;\n+    }\t\t  \n+  \n+  return false;\n+}\n+\n+/* Attempt to reassociate the associative binary operator BEXPR, which\n+   is in the statement pointed to by CURRBSI.  Return true if we\n+   changed the statement.  */\n+\n+static bool\n+reassociate_expr (tree bexpr, block_stmt_iterator *currbsi)\n+{\n+  tree lhs = TREE_OPERAND (bexpr, 0);\n+  tree rhs = TREE_OPERAND (bexpr, 1);\n+  tree lhsdef;\n+  tree lhsi;\n+  bool changed = false;\n+  unsigned int lhsrank = get_rank (lhs);\n+  unsigned int rhsrank = get_rank (rhs);\n+\n+  /* I don't want to get into the business of floating point\n+     reassociation.  */\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n+    return false;\n+    \n+  /* We want the greater ranked operand to be our \"LHS\" for simplicity\n+     sake.  There is no point in actually modifying the expression, as\n+     update_stmt will simply resort the operands anyway. */\n+  if (lhsrank < rhsrank)\n+    {\n+      tree temp;\n+      unsigned int temp1;\n+      temp = lhs;\n+      lhs = rhs;\n+      rhs = temp;\n+      temp1 = lhsrank;\n+      lhsrank = rhsrank;\n+      rhsrank = temp1;\n+    }\n+\n+  /* If the high ranked operand is an SSA_NAME, and the binary\n+     operator is not something we've already seen somewhere else\n+     (i.e., it may be redundant), attempt to reassociate it.\n+     \n+     We can't reassociate expressions unless the expression we are\n+     going to reassociate with is only used in our current expression,\n+     or else we may screw up other computations, like so:\n+\n+     a = b + c\n+     e = a + d\n+     \n+     g = a + f\n+     \n+     We cannot reassociate and rewrite the \"a = ...\" , \n+     because that would change the value of the computation of \n+     \"g = a + f\".  */\n+  if (TREE_CODE (lhs) == SSA_NAME && !find_seen_binop (lhs, rhs))\n+    {\n+      lhsdef = SSA_NAME_DEF_STMT (lhs);\n+      if (TREE_CODE (lhsdef) == MODIFY_EXPR)\n+\t{\n+\t  lhsi = TREE_OPERAND (lhsdef, 1);\n+\t  if (TREE_CODE (lhsi) == TREE_CODE (bexpr))\n+\t    {\n+\t      use_operand_p use;\n+\t      tree usestmt;\n+\t      if (single_imm_use (lhs, &use, &usestmt))\n+\t\t{\n+\t\t  unsigned int takeop = 0;\n+\t\t  unsigned int otherop = 1;\n+\t\t  bool foundmatch = false;\n+\t\t  bool foundrank = false;\n+\n+\t\t  /* If we can easily transpose this into an operation\n+\t\t     we've already seen, let's do that.\n+\t\t     otherwise, let's try to expose low ranked ops to\n+\t\t     CSE.  */\n+\t\t  if (find_seen_binop (TREE_OPERAND (lhsi, 1), rhs))\n+\t\t    {\n+\t\t      takeop = 0;\n+\t\t      otherop = 1;\n+\t\t      foundmatch = true;\n+\t\t    }\n+\t\t  else if (find_seen_binop (TREE_OPERAND (lhsi, 0),\n+\t\t\t\t\t    rhs))\n+\t\t    {\n+\t\t      takeop = 1;\n+\t\t      otherop = 0;\n+\t\t      foundmatch = true;\n+\t\t    }\n+\t\t  else if (should_transpose (rhs, rhsrank, lhsi,\n+\t\t\t\t\t     &takeop))\n+\t\t    {\n+\t\t      foundrank = true;\n+\t\t    }\t\t  \n+\t\t  if (foundmatch || foundrank)\n+\t\t    {\n+\t\t      block_stmt_iterator lhsbsi = bsi_for_stmt (lhsdef);\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (dump_file, \"Reassociating by %s\\n\",\n+\t\t\t\t   foundmatch ? \"match\" : \"rank\");\n+\t\t\t  fprintf (dump_file, \"Before LHS:\");\n+\t\t\t  print_generic_stmt (dump_file, lhsi, 0);\n+\t\t\t  fprintf (dump_file, \"Before curr expr:\");\n+\t\t\t  print_generic_stmt (dump_file, bexpr, 0);\n+\t\t\t}\n+\t\t      TREE_OPERAND (bexpr, 0) = TREE_OPERAND (lhsi, takeop);\n+\t\t      TREE_OPERAND (lhsi, takeop) = rhs;\n+\t\t      TREE_OPERAND (bexpr, 1) = TREE_OPERAND (lhsdef, 0);\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (dump_file, \"After LHS:\");\n+\t\t\t  print_generic_stmt (dump_file, lhsi, 0);\n+\t\t\t  fprintf (dump_file, \"After curr expr:\");\n+\t\t\t  print_generic_stmt (dump_file, bexpr, 0);\n+\t\t\t}\n+\t\t      bsi_move_before (&lhsbsi, currbsi);\n+\t\t      update_stmt (lhsdef);\n+\t\t      update_stmt (bsi_stmt (*currbsi));\n+\t\t      lhsbsi = bsi_for_stmt (lhsdef);\n+\t\t      update_stmt (bsi_stmt (lhsbsi));\n+\n+\t\t      /* If update_stmt didn't reorder our operands,\n+\t\t\t we'd like to recurse on the expression we\n+\t\t\t just reassociated and reassociate it\n+\t\t\t top-down, exposing further opportunities.\n+\t\t\t Unfortunately, update_stmt does reorder them,\n+\t\t\t so we can't do this cheaply.  */\n+\t\t      if (!foundmatch)\n+\t\t\treassociate_stats.reassociated_by_rank++;\n+\t\t      else\n+\t\t\treassociate_stats.reassociated_by_match++;\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return changed;\n+}\n+\n+/* Reassociate expressions in basic block BB and its dominator as\n+   children , return true if any\n+   expressions changed.  */\n+\n+static bool\n+reassociate_bb (basic_block bb)\n+{\n+  bool changed = false;\n+  block_stmt_iterator bsi;\n+  basic_block son;\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+      \n+      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t{\n+\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\t  if (associative_tree_code (TREE_CODE (rhs)))\n+\t    {\n+\t      if (reassociate_expr (rhs, &bsi))\n+\t\t{\n+\t\t  changed = true;\n+\t\t  update_stmt (stmt);\t\t  \n+\t\t}\n+\t      insert_seen_binop (TREE_OPERAND (rhs, 0),\n+\t\t\t\t TREE_OPERAND (rhs, 1));\n+\t    }\n+\t}\n+    }\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    {\n+      changed |= reassociate_bb (son);\n+    }\n+  return changed;  \n+}\n+\n+\t\n+static bool\n+do_reassoc (void)\n+{  \n+  bool changed = false;\n+  \n+  changed = reassociate_bb (ENTRY_BLOCK_PTR);\n+\n+  return changed;  \n+}\n+\n+\n+/* Gate and execute functions for Reassociation.  */\n+\n+static void\n+execute_reassoc (void)\n+{\n+  init_reassoc ();\n+  do_reassoc ();\n+  fini_reassoc ();\n+}\n+\n+struct tree_opt_pass pass_reassoc =\n+{\n+  \"reassoc\",\t\t\t\t/* name */\n+  NULL,\t\t\t\t/* gate */\n+  execute_reassoc,\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_REASSOC,\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_update_ssa | TODO_dump_func \n+  | TODO_ggc_collect | TODO_verify_ssa, /* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}]}