{"sha": "686a56a85d39750cd5c0c42f2ea747c8632e519e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2YTU2YTg1ZDM5NzUwY2Q1YzBjNDJmMmVhNzQ3Yzg2MzJlNTE5ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-06-07T08:15:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-06-07T08:15:00Z"}, "message": "common.opt (flto-odr-type-merging): Ignore.\n\n\n\t* common.opt (flto-odr-type-merging): Ignore.\n\t* invoke.texi (-flto-odr-type-merging): Remove.\n\t* ipa-devirt.c (odr_vtable_hasher:odr_name_hasher): Remove.\n\t(can_be_vtable_hashed_p): Remove.\n\t(hash_odr_vtable): Remove.\n\t(odr_vtable_hasher::hash): Remove.\n\t(types_same_for_odr): Remove.\n\t(types_odr_comparable): Remove.\n\t(odr_vtable_hasher::equal): Remove.\n\t(odr_vtable_hash_type, odr_vtable_hash): Remove.\t\n\t(add_type_duplicate): Do not synchronize vtable and name hashtables.\n\t(get_odr_type): Do not use vtable hash.\n\t(dump_odr_type): Remove commented out code.\n\t(build_type_inheritance_graph): Do not allocate vtable hash.\n\t(rebuild_type_inheritance_graph): Do not delete vtable hash.\n\t* ipa-utils.h (type_with_linkage_p): Drop vtable hash path.\n\t(odr_type_p): Likewise.\n\t* tree.c (need_assembler_name_p): Remove flag_lto_odr_type_mering\n\ttest.\n\nFrom-SVN: r272037", "tree": {"sha": "cc3b9894ef2bc23014230964b6d23de0f912bba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc3b9894ef2bc23014230964b6d23de0f912bba7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/686a56a85d39750cd5c0c42f2ea747c8632e519e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686a56a85d39750cd5c0c42f2ea747c8632e519e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/686a56a85d39750cd5c0c42f2ea747c8632e519e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686a56a85d39750cd5c0c42f2ea747c8632e519e/comments", "author": null, "committer": null, "parents": [{"sha": "06dd9b3d4e86b2c12ba55144147272ac05eeed40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06dd9b3d4e86b2c12ba55144147272ac05eeed40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06dd9b3d4e86b2c12ba55144147272ac05eeed40"}], "stats": {"total": 296, "additions": 43, "deletions": 253}, "files": [{"sha": "dbcf512b643bc7b51d93922c88e10b0231fbbc6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=686a56a85d39750cd5c0c42f2ea747c8632e519e", "patch": "@@ -1,3 +1,25 @@\n+2019-06-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* common.opt (flto-odr-type-merging): Ignore.\n+\t* invoke.texi (-flto-odr-type-merging): Remove.\n+\t* ipa-devirt.c (odr_vtable_hasher:odr_name_hasher): Remove.\n+\t(can_be_vtable_hashed_p): Remove.\n+\t(hash_odr_vtable): Remove.\n+\t(odr_vtable_hasher::hash): Remove.\n+\t(types_same_for_odr): Remove.\n+\t(types_odr_comparable): Remove.\n+\t(odr_vtable_hasher::equal): Remove.\n+\t(odr_vtable_hash_type, odr_vtable_hash): Remove.\t\n+\t(add_type_duplicate): Do not synchronize vtable and name hashtables.\n+\t(get_odr_type): Do not use vtable hash.\n+\t(dump_odr_type): Remove commented out code.\n+\t(build_type_inheritance_graph): Do not allocate vtable hash.\n+\t(rebuild_type_inheritance_graph): Do not delete vtable hash.\n+\t* ipa-utils.h (type_with_linkage_p): Drop vtable hash path.\n+\t(odr_type_p): Likewise.\n+\t* tree.c (need_assembler_name_p): Remove flag_lto_odr_type_mering\n+\ttest.\n+\n 2019-06-07  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree-ssa-alias.c (aliasing_component_refs_p): Do not give up"}, {"sha": "e1404165febc936b37b31333f9a890f6799454a9", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=686a56a85d39750cd5c0c42f2ea747c8632e519e", "patch": "@@ -1888,8 +1888,8 @@ Common Joined RejectNegative UInteger Var(flag_lto_compression_level) Init(-1) I\n -flto-compression-level=<number>\tUse zlib compression level <number> for IL.\n \n flto-odr-type-merging\n-Common Report Var(flag_lto_odr_type_mering) Init(1)\n-Merge C++ types using One Definition Rule.\n+Common Ignore\n+Does nothing.  Preserved for backward compatibility.\n \n flto-report\n Common Report Var(flag_lto_report) Init(0)"}, {"sha": "3103f86ce98404fbb725d3ada41898b4c932d83f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=686a56a85d39750cd5c0c42f2ea747c8632e519e", "patch": "@@ -7357,7 +7357,7 @@ Do not warn about compile-time overflow in constant expressions.\n @opindex Wno-odr\n @opindex Wodr\n Warn about One Definition Rule violations during link-time optimization.\n-Requires @option{-flto-odr-type-merging} to be enabled.  Enabled by default.\n+Enabled by default.\n \n @item -Wopenmp-simd\n @opindex Wopenmp-simd\n@@ -10353,12 +10353,6 @@ The value @samp{one} specifies that exactly one partition should be\n used while the value @samp{none} bypasses partitioning and executes\n the link-time optimization step directly from the WPA phase.\n \n-@item -flto-odr-type-merging\n-@opindex flto-odr-type-merging\n-Enable streaming of mangled types names of C++ types and their unification\n-at link time.  This increases size of LTO object files, but enables\n-diagnostics about One Definition Rule violations.\n-\n @item -flto-compression-level=@var{n}\n @opindex flto-compression-level\n This option specifies the level of compression used for intermediate"}, {"sha": "a4c8b0de86f7ab62e436f877da78f606c1f5ed4c", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 13, "deletions": 218, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=686a56a85d39750cd5c0c42f2ea747c8632e519e", "patch": "@@ -284,16 +284,6 @@ struct odr_name_hasher : pointer_hash <odr_type_d>\n   static inline void remove (odr_type_d *);\n };\n \n-/* Has used to unify ODR types based on their associated virtual table.\n-   This hash is needed to keep -fno-lto-odr-type-merging to work and contains\n-   only polymorphic types.  Types with mangled names are inserted to both.  */\n-\n-struct odr_vtable_hasher:odr_name_hasher\n-{\n-  static inline hashval_t hash (const odr_type_d *);\n-  static inline bool equal (const odr_type_d *, const tree_node *);\n-};\n-\n static bool\n can_be_name_hashed_p (tree t)\n {\n@@ -329,51 +319,6 @@ odr_name_hasher::hash (const odr_type_d *odr_type)\n   return hash_odr_name (odr_type->type);\n }\n \n-static bool\n-can_be_vtable_hashed_p (tree t)\n-{\n-  /* vtable hashing can distinguish only main variants.  */\n-  if (TYPE_MAIN_VARIANT (t) != t)\n-    return false;\n-  /* Anonymous namespace types are always handled by name hash.  */\n-  if (type_with_linkage_p (t) && type_in_anonymous_namespace_p (t))\n-    return false;\n-  return (TREE_CODE (t) == RECORD_TYPE\n-\t  && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)));\n-}\n-\n-/* Hash type by assembler name of its vtable.  */\n-\n-static hashval_t\n-hash_odr_vtable (const_tree t)\n-{\n-  tree v = BINFO_VTABLE (TYPE_BINFO (TYPE_MAIN_VARIANT (t)));\n-  inchash::hash hstate;\n-\n-  gcc_checking_assert (in_lto_p);\n-  gcc_checking_assert (!type_in_anonymous_namespace_p (t));\n-  gcc_checking_assert (TREE_CODE (t) == RECORD_TYPE\n-\t\t       && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)));\n-  gcc_checking_assert (TYPE_MAIN_VARIANT (t) == t);\n-\n-  if (TREE_CODE (v) == POINTER_PLUS_EXPR)\n-    {\n-      add_expr (TREE_OPERAND (v, 1), hstate);\n-      v = TREE_OPERAND (TREE_OPERAND (v, 0), 0);\n-    }\n-\n-  hstate.add_hwi (IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME (v)));\n-  return hstate.end ();\n-}\n-\n-/* Return the computed hashcode for ODR_TYPE.  */\n-\n-inline hashval_t\n-odr_vtable_hasher::hash (const odr_type_d *odr_type)\n-{\n-  return hash_odr_vtable (odr_type->type);\n-}\n-\n /* For languages with One Definition Rule, work out if\n    types are the same based on their name.\n \n@@ -404,60 +349,6 @@ types_same_for_odr (const_tree type1, const_tree type2)\n       || (type_with_linkage_p (type2) && type_in_anonymous_namespace_p (type2)))\n     return false;\n \n-\n-  /* ODR name of the type is set in DECL_ASSEMBLER_NAME of its TYPE_NAME.\n-\n-     Ideally we should never need types without ODR names here.  It can however\n-     happen in two cases:\n-\n-       1) for builtin types that are not streamed but rebuilt in lto/lto-lang.c\n-          Here testing for equivalence is safe, since their MAIN_VARIANTs are\n-          unique.\n-       2) for units streamed with -fno-lto-odr-type-merging.  Here we can't\n-\t  establish precise ODR equivalency, but for correctness we care only\n-\t  about equivalency on complete polymorphic types.  For these we can\n-\t  compare assembler names of their virtual tables.  */\n-  if ((!TYPE_NAME (type1) || !DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (type1)))\n-      || (!TYPE_NAME (type2) || !DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (type2))))\n-    {\n-      /* See if types are obviously different (i.e. different codes\n-\t or polymorphic wrt non-polymorphic).  This is not strictly correct\n-\t for ODR violating programs, but we can't do better without streaming\n-\t ODR names.  */\n-      if (TREE_CODE (type1) != TREE_CODE (type2))\n-\treturn false;\n-      if (TREE_CODE (type1) == RECORD_TYPE\n-\t  && (TYPE_BINFO (type1) == NULL_TREE)\n-\t      != (TYPE_BINFO (type2) == NULL_TREE))\n-\treturn false;\n-      if (TREE_CODE (type1) == RECORD_TYPE && TYPE_BINFO (type1)\n-\t  && (BINFO_VTABLE (TYPE_BINFO (type1)) == NULL_TREE)\n-\t     != (BINFO_VTABLE (TYPE_BINFO (type2)) == NULL_TREE))\n-\treturn false;\n-\n-      /* At the moment we have no way to establish ODR equivalence at LTO\n-\t other than comparing virtual table pointers of polymorphic types.\n-\t Eventually we should start saving mangled names in TYPE_NAME.\n-\t Then this condition will become non-trivial.  */\n-\n-      if (TREE_CODE (type1) == RECORD_TYPE\n-\t  && TYPE_BINFO (type1) && TYPE_BINFO (type2)\n-\t  && BINFO_VTABLE (TYPE_BINFO (type1))\n-\t  && BINFO_VTABLE (TYPE_BINFO (type2)))\n-\t{\n-\t  tree v1 = BINFO_VTABLE (TYPE_BINFO (type1));\n-\t  tree v2 = BINFO_VTABLE (TYPE_BINFO (type2));\n-\t  gcc_assert (TREE_CODE (v1) == POINTER_PLUS_EXPR\n-\t\t      && TREE_CODE (v2) == POINTER_PLUS_EXPR);\n-\t  return (operand_equal_p (TREE_OPERAND (v1, 1),\n-\t\t\t\t   TREE_OPERAND (v2, 1), 0)\n-\t\t  && DECL_ASSEMBLER_NAME\n-\t\t\t (TREE_OPERAND (TREE_OPERAND (v1, 0), 0))\n-\t\t     == DECL_ASSEMBLER_NAME\n-\t\t\t (TREE_OPERAND (TREE_OPERAND (v2, 0), 0)));\n-\t}\n-      gcc_unreachable ();\n-    }\n   return (DECL_ASSEMBLER_NAME (TYPE_NAME (type1))\n \t  == DECL_ASSEMBLER_NAME (TYPE_NAME (type2)));\n }\n@@ -473,11 +364,7 @@ types_odr_comparable (tree t1, tree t2)\n   return (!in_lto_p\n \t  || TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2)\n \t  || (odr_type_p (TYPE_MAIN_VARIANT (t1))\n-\t      && odr_type_p (TYPE_MAIN_VARIANT (t2)))\n-\t  || (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE\n-\t      && TYPE_BINFO (t1) && TYPE_BINFO (t2)\n-\t      && polymorphic_type_binfo_p (TYPE_BINFO (t1))\n-\t      && polymorphic_type_binfo_p (TYPE_BINFO (t2))));\n+\t      && odr_type_p (TYPE_MAIN_VARIANT (t2))));\n }\n \n /* Return true if T1 and T2 are ODR equivalent.  If ODR equivalency is not\n@@ -569,31 +456,6 @@ odr_name_hasher::equal (const odr_type_d *o1, const tree_node *t2)\n \t  == DECL_ASSEMBLER_NAME (TYPE_NAME (t2)));\n }\n \n-/* Compare types T1 and T2 and return true if they are\n-   equivalent.  */\n-\n-inline bool\n-odr_vtable_hasher::equal (const odr_type_d *o1, const tree_node *t2)\n-{\n-  tree t1 = o1->type;\n-\n-  gcc_checking_assert (TYPE_MAIN_VARIANT (t2) == t2);\n-  gcc_checking_assert (TYPE_MAIN_VARIANT (t1) == t1);\n-  gcc_checking_assert (in_lto_p);\n-  t1 = TYPE_MAIN_VARIANT (t1);\n-  t2 = TYPE_MAIN_VARIANT (t2);\n-  if (t1 == t2)\n-    return true;\n-  tree v1 = BINFO_VTABLE (TYPE_BINFO (t1));\n-  tree v2 = BINFO_VTABLE (TYPE_BINFO (t2));\n-  return (operand_equal_p (TREE_OPERAND (v1, 1),\n-\t\t\t   TREE_OPERAND (v2, 1), 0)\n-\t  && DECL_ASSEMBLER_NAME\n-\t\t (TREE_OPERAND (TREE_OPERAND (v1, 0), 0))\n-\t     == DECL_ASSEMBLER_NAME\n-\t\t (TREE_OPERAND (TREE_OPERAND (v2, 0), 0)));\n-}\n-\n /* Free ODR type V.  */\n \n inline void\n@@ -610,8 +472,6 @@ odr_name_hasher::remove (odr_type_d *v)\n \n typedef hash_table<odr_name_hasher> odr_hash_type;\n static odr_hash_type *odr_hash;\n-typedef hash_table<odr_vtable_hasher> odr_vtable_hash_type;\n-static odr_vtable_hash_type *odr_vtable_hash;\n \n /* ODR types are also stored into ODR_TYPE vector to allow consistent\n    walking.  Bases appear before derived types.  Vector is garbage collected\n@@ -1750,12 +1610,8 @@ add_type_duplicate (odr_type val, tree type)\n \n   val->types_set->add (type);\n \n-  /* If we now have a mangled name, be sure to record it to val->type\n-     so ODR hash can work.  */\n-\n-  if (can_be_name_hashed_p (type) && !can_be_name_hashed_p (val->type))\n-    SET_DECL_ASSEMBLER_NAME (TYPE_NAME (val->type),\n-\t\t\t     DECL_ASSEMBLER_NAME (TYPE_NAME (type)));\n+  gcc_checking_assert (can_be_name_hashed_p (type)\n+\t\t       && can_be_name_hashed_p (val->type));\n \n   bool merge = true;\n   bool base_mismatch = false;\n@@ -2034,7 +1890,6 @@ odr_type\n get_odr_type (tree type, bool insert)\n {\n   odr_type_d **slot = NULL;\n-  odr_type_d **vtable_slot = NULL;\n   odr_type val = NULL;\n   hashval_t hash;\n   bool build_bases = false;\n@@ -2045,68 +1900,23 @@ get_odr_type (tree type, bool insert)\n   if (!in_lto_p && !TYPE_STRUCTURAL_EQUALITY_P (type))\n     type = TYPE_CANONICAL (type);\n \n-  gcc_checking_assert (can_be_name_hashed_p (type)\n-\t\t       || can_be_vtable_hashed_p (type));\n+  gcc_checking_assert (can_be_name_hashed_p (type));\n \n-  /* Lookup entry, first try name hash, fallback to vtable hash.  */\n-  if (can_be_name_hashed_p (type))\n-    {\n-      hash = hash_odr_name (type);\n-      slot = odr_hash->find_slot_with_hash (type, hash,\n-\t\t\t\t\t    insert ? INSERT : NO_INSERT);\n-    }\n-  if ((!slot || !*slot) && in_lto_p && can_be_vtable_hashed_p (type))\n-    {\n-      hash = hash_odr_vtable (type);\n-      if (!odr_vtable_hash)\n-        odr_vtable_hash = new odr_vtable_hash_type (23);\n-      vtable_slot = odr_vtable_hash->find_slot_with_hash (type, hash,\n-\t\t\t\t\t           insert ? INSERT : NO_INSERT);\n-    }\n+  hash = hash_odr_name (type);\n+  slot = odr_hash->find_slot_with_hash (type, hash,\n+\t\t\t\t\tinsert ? INSERT : NO_INSERT);\n \n-  if (!slot && !vtable_slot)\n+  if (!slot)\n     return NULL;\n \n   /* See if we already have entry for type.  */\n-  if ((slot && *slot) || (vtable_slot && *vtable_slot))\n+  if (*slot)\n     {\n-      if (slot && *slot)\n-\t{\n-\t  val = *slot;\n-\t  if (flag_checking\n-\t      && in_lto_p && can_be_vtable_hashed_p (type))\n-\t    {\n-\t      hash = hash_odr_vtable (type);\n-\t      vtable_slot = odr_vtable_hash->find_slot_with_hash (type, hash,\n-\t\t\t\t\t\t                  NO_INSERT);\n-\t      gcc_assert (!vtable_slot || *vtable_slot == *slot);\n-\t      vtable_slot = NULL;\n-\t    }\n-\t}\n-      else if (*vtable_slot)\n-\tval = *vtable_slot;\n+      val = *slot;\n \n       if (val->type != type && insert\n \t  && (!val->types_set || !val->types_set->add (type)))\n-\t{\n-\t  /* We have type duplicate, but it may introduce vtable name or\n- \t     mangled name; be sure to keep hashes in sync.  */\n-\t  if (in_lto_p && can_be_vtable_hashed_p (type)\n-\t      && (!vtable_slot || !*vtable_slot))\n-\t    {\n-\t      if (!vtable_slot)\n-\t\t{\n-\t\t  hash = hash_odr_vtable (type);\n-\t\t  vtable_slot = odr_vtable_hash->find_slot_with_hash\n-\t\t\t     (type, hash, INSERT);\n-\t\t  gcc_checking_assert (!*vtable_slot || *vtable_slot == val);\n-\t\t}\n-\t      *vtable_slot = val;\n-\t    }\n-\t  if (slot && !*slot)\n-\t    *slot = val;\n-\t  build_bases = add_type_duplicate (val, type);\n-\t}\n+\tbuild_bases = add_type_duplicate (val, type);\n     }\n   else\n     {\n@@ -2120,10 +1930,7 @@ get_odr_type (tree type, bool insert)\n \tval->anonymous_namespace = 0;\n       build_bases = COMPLETE_TYPE_P (val->type);\n       insert_to_odr_array = true;\n-      if (slot)\n-        *slot = val;\n-      if (vtable_slot)\n-\t*vtable_slot = val;\n+      *slot = val;\n     }\n \n   if (build_bases && TREE_CODE (type) == RECORD_TYPE && TYPE_BINFO (type)\n@@ -2196,11 +2003,7 @@ void\n register_odr_type (tree type)\n {\n   if (!odr_hash)\n-    {\n-      odr_hash = new odr_hash_type (23);\n-      if (in_lto_p)\n-        odr_vtable_hash = new odr_vtable_hash_type (23);\n-    }\n+    odr_hash = new odr_hash_type (23);\n   if (type == TYPE_MAIN_VARIANT (type))\n     {\n       /* To get ODR warings right, first register all sub-types.  */\n@@ -2258,9 +2061,6 @@ dump_odr_type (FILE *f, odr_type t, int indent=0)\n   fprintf (f, \"%s\\n\", t->all_derivations_known ? \" (derivations known)\":\"\");\n   if (TYPE_NAME (t->type))\n     {\n-      /*fprintf (f, \"%*s defined at: %s:%i\\n\", indent * 2, \"\",\n-\t       DECL_SOURCE_FILE (TYPE_NAME (t->type)),\n-\t       DECL_SOURCE_LINE (TYPE_NAME (t->type)));*/\n       if (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t->type)))\n         fprintf (f, \"%*s mangled name: %s\\n\", indent * 2, \"\",\n \t\t IDENTIFIER_POINTER\n@@ -2400,8 +2200,6 @@ build_type_inheritance_graph (void)\n   timevar_push (TV_IPA_INHERITANCE);\n   inheritance_dump_file = dump_begin (TDI_inheritance, &flags);\n   odr_hash = new odr_hash_type (23);\n-  if (in_lto_p)\n-    odr_vtable_hash = new odr_vtable_hash_type (23);\n \n   /* We reconstruct the graph starting of types of all methods seen in the\n      unit.  */\n@@ -2892,10 +2690,7 @@ rebuild_type_inheritance_graph ()\n   if (!odr_hash)\n     return;\n   delete odr_hash;\n-  if (in_lto_p)\n-    delete odr_vtable_hash;\n   odr_hash = NULL;\n-  odr_vtable_hash = NULL;\n   odr_types_ptr = NULL;\n   free_polymorphic_call_targets_hash ();\n }"}, {"sha": "4a39d4ad74e0c467b727cd23e929dbdc7653daad", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=686a56a85d39750cd5c0c42f2ea747c8632e519e", "patch": "@@ -187,19 +187,14 @@ type_with_linkage_p (const_tree t)\n   if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL)\n     return false;\n \n-  /* To support -fno-lto-odr-type-merigng recognize types with vtables\n-     to have linkage.  */\n-  if (RECORD_OR_UNION_TYPE_P (t)\n-      && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n-    return true;\n-\n-  /* After free_lang_data was run and -flto-odr-type-merging we can recongize\n+  /* After free_lang_data was run we can recongize\n      types with linkage by presence of mangled name.  */\n   if (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n     return true;\n \n   if (in_lto_p)\n     return false;\n+\n   /* We used to check for TYPE_STUB_DECL but that is set to NULL for forward\n      declarations.  */\n \n@@ -243,23 +238,8 @@ odr_type_p (const_tree t)\n   /* We do not have this information when not in LTO, but we do not need\n      to care, since it is used only for type merging.  */\n   gcc_checking_assert (in_lto_p || flag_lto);\n-\n-  if (!type_with_linkage_p (t))\n-    return false;\n-\n-  /* To support -fno-lto-odr-type-merging consider types with vtables ODR.  */\n-  if (type_in_anonymous_namespace_p (t))\n-    return true;\n-\n-  if (TYPE_NAME (t) && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n-    {\n-      /* C++ FE uses magic <anon> as assembler names of anonymous types.\n- \t verify that this match with type_in_anonymous_namespace_p.  */\n-      gcc_checking_assert (strcmp (\"<anon>\",\n-\t\t\t\t   IDENTIFIER_POINTER\n-\t\t\t\t   (DECL_ASSEMBLER_NAME (TYPE_NAME (t)))));\n-      return true;\n-    }\n+  return TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n+         && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t));\n   return false;\n }\n "}, {"sha": "43ce44fcee46fa5cdadebb35311450047a4dfd66", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686a56a85d39750cd5c0c42f2ea747c8632e519e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=686a56a85d39750cd5c0c42f2ea747c8632e519e", "patch": "@@ -5590,8 +5590,7 @@ need_assembler_name_p (tree decl)\n \n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n-      if (flag_lto_odr_type_mering\n-\t  && DECL_NAME (decl)\n+      if (DECL_NAME (decl)\n \t  && decl == TYPE_NAME (TREE_TYPE (decl))\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (decl)) == TREE_TYPE (decl)\n \t  && !TYPE_ARTIFICIAL (TREE_TYPE (decl))"}]}