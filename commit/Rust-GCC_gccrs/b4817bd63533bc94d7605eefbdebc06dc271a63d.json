{"sha": "b4817bd63533bc94d7605eefbdebc06dc271a63d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4MTdiZDYzNTMzYmM5NGQ3NjA1ZWVmYmRlYmMwNmRjMjcxYTYzZA==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2016-06-13T11:21:45Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2016-06-13T11:21:45Z"}, "message": "Move optimize_minmax_comparison to match.pd\n\n2016-06-13  Marc Glisse  <marc.glisse@inria.fr>\n\n\t* fold-const.c (optimize_minmax_comparison): Remove.\n\t(fold_comparison): Remove call to the above.\n\t* match.pd (MIN (X, Y) == X, MIN (X, 5) == 0, MIN (X, C1) < C2):\n\tNew transformations.\n\nFrom-SVN: r237376", "tree": {"sha": "75eb715e32ceaf45a547f7361431eb2526795c04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75eb715e32ceaf45a547f7361431eb2526795c04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4817bd63533bc94d7605eefbdebc06dc271a63d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4817bd63533bc94d7605eefbdebc06dc271a63d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4817bd63533bc94d7605eefbdebc06dc271a63d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4817bd63533bc94d7605eefbdebc06dc271a63d/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "915794eb26eaafe970c4c9f9d7774b55c4b772b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915794eb26eaafe970c4c9f9d7774b55c4b772b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/915794eb26eaafe970c4c9f9d7774b55c4b772b5"}], "stats": {"total": 157, "additions": 39, "deletions": 118}, "files": [{"sha": "9c02bea3dd29784fad2e6f2d0858f8c430df0d53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4817bd63533bc94d7605eefbdebc06dc271a63d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4817bd63533bc94d7605eefbdebc06dc271a63d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4817bd63533bc94d7605eefbdebc06dc271a63d", "patch": "@@ -1,3 +1,10 @@\n+2016-06-13  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* fold-const.c (optimize_minmax_comparison): Remove.\n+\t(fold_comparison): Remove call to the above.\n+\t* match.pd (MIN (X, Y) == X, MIN (X, 5) == 0, MIN (X, C1) < C2):\n+\tNew transformations.\n+\n 2016-06-13  Alan Hayward  <alan.hayward@arm.com>\n \n \tPR tree-optimization/71416"}, {"sha": "26c1435ed0c50b2d2f21844ac92fe07295ad9a55", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4817bd63533bc94d7605eefbdebc06dc271a63d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4817bd63533bc94d7605eefbdebc06dc271a63d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b4817bd63533bc94d7605eefbdebc06dc271a63d", "patch": "@@ -128,8 +128,6 @@ static tree range_successor (tree);\n static tree fold_range_test (location_t, enum tree_code, tree, tree, tree);\n static tree fold_cond_expr_with_comparison (location_t, tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n-static tree optimize_minmax_comparison (location_t, enum tree_code,\n-\t\t\t\t\ttree, tree, tree);\n static tree extract_muldiv (tree, tree, enum tree_code, tree, bool *);\n static tree extract_muldiv_1 (tree, tree, enum tree_code, tree, bool *);\n static tree fold_binary_op_with_conditional_arg (location_t,\n@@ -5979,110 +5977,6 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n \t\t     const_binop (BIT_IOR_EXPR, l_const, r_const));\n }\n \f\n-/* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a\n-   constant.  */\n-\n-static tree\n-optimize_minmax_comparison (location_t loc, enum tree_code code, tree type,\n-\t\t\t    tree op0, tree op1)\n-{\n-  tree arg0 = op0;\n-  enum tree_code op_code;\n-  tree comp_const;\n-  tree minmax_const;\n-  int consts_equal, consts_lt;\n-  tree inner;\n-\n-  STRIP_SIGN_NOPS (arg0);\n-\n-  op_code = TREE_CODE (arg0);\n-  minmax_const = TREE_OPERAND (arg0, 1);\n-  comp_const = fold_convert_loc (loc, TREE_TYPE (arg0), op1);\n-  consts_equal = tree_int_cst_equal (minmax_const, comp_const);\n-  consts_lt = tree_int_cst_lt (minmax_const, comp_const);\n-  inner = TREE_OPERAND (arg0, 0);\n-\n-  /* If something does not permit us to optimize, return the original tree.  */\n-  if ((op_code != MIN_EXPR && op_code != MAX_EXPR)\n-      || TREE_CODE (comp_const) != INTEGER_CST\n-      || TREE_OVERFLOW (comp_const)\n-      || TREE_CODE (minmax_const) != INTEGER_CST\n-      || TREE_OVERFLOW (minmax_const))\n-    return NULL_TREE;\n-\n-  /* Now handle all the various comparison codes.  We only handle EQ_EXPR\n-     and GT_EXPR, doing the rest with recursive calls using logical\n-     simplifications.  */\n-  switch (code)\n-    {\n-    case NE_EXPR:  case LT_EXPR:  case LE_EXPR:\n-      {\n-\ttree tem\n-\t  = optimize_minmax_comparison (loc,\n-\t\t\t\t\tinvert_tree_comparison (code, false),\n-\t\t\t\t\ttype, op0, op1);\n-\tif (tem)\n-\t  return invert_truthvalue_loc (loc, tem);\n-\treturn NULL_TREE;\n-      }\n-\n-    case GE_EXPR:\n-      return\n-\tfold_build2_loc (loc, TRUTH_ORIF_EXPR, type,\n-\t\t     optimize_minmax_comparison\n-\t\t     (loc, EQ_EXPR, type, arg0, comp_const),\n-\t\t     optimize_minmax_comparison\n-\t\t     (loc, GT_EXPR, type, arg0, comp_const));\n-\n-    case EQ_EXPR:\n-      if (op_code == MAX_EXPR && consts_equal)\n-\t/* MAX (X, 0) == 0  ->  X <= 0  */\n-\treturn fold_build2_loc (loc, LE_EXPR, type, inner, comp_const);\n-\n-      else if (op_code == MAX_EXPR && consts_lt)\n-\t/* MAX (X, 0) == 5  ->  X == 5   */\n-\treturn fold_build2_loc (loc, EQ_EXPR, type, inner, comp_const);\n-\n-      else if (op_code == MAX_EXPR)\n-\t/* MAX (X, 0) == -1  ->  false  */\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, inner);\n-\n-      else if (consts_equal)\n-\t/* MIN (X, 0) == 0  ->  X >= 0  */\n-\treturn fold_build2_loc (loc, GE_EXPR, type, inner, comp_const);\n-\n-      else if (consts_lt)\n-\t/* MIN (X, 0) == 5  ->  false  */\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, inner);\n-\n-      else\n-\t/* MIN (X, 0) == -1  ->  X == -1  */\n-\treturn fold_build2_loc (loc, EQ_EXPR, type, inner, comp_const);\n-\n-    case GT_EXPR:\n-      if (op_code == MAX_EXPR && (consts_equal || consts_lt))\n-\t/* MAX (X, 0) > 0  ->  X > 0\n-\t   MAX (X, 0) > 5  ->  X > 5  */\n-\treturn fold_build2_loc (loc, GT_EXPR, type, inner, comp_const);\n-\n-      else if (op_code == MAX_EXPR)\n-\t/* MAX (X, 0) > -1  ->  true  */\n-\treturn omit_one_operand_loc (loc, type, integer_one_node, inner);\n-\n-      else if (op_code == MIN_EXPR && (consts_equal || consts_lt))\n-\t/* MIN (X, 0) > 0  ->  false\n-\t   MIN (X, 0) > 5  ->  false  */\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, inner);\n-\n-      else\n-\t/* MIN (X, 0) > -1  ->  X > -1  */\n-\treturn fold_build2_loc (loc, GT_EXPR, type, inner, comp_const);\n-\n-    default:\n-      return NULL_TREE;\n-    }\n-}\n-\f\n /* T is an integer expression that is being multiplied, divided, or taken a\n    modulus (CODE says which and what kind of divide or modulus) by a\n    constant C.  See if we can eliminate that operation by folding it with\n@@ -8721,18 +8615,6 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n   if (tem)\n     return tem;\n \n-  /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n-     constant, we can simplify it.  */\n-  if (TREE_CODE (arg1) == INTEGER_CST\n-      && (TREE_CODE (arg0) == MIN_EXPR\n-\t  || TREE_CODE (arg0) == MAX_EXPR)\n-      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-    {\n-      tem = optimize_minmax_comparison (loc, code, type, op0, op1);\n-      if (tem)\n-\treturn tem;\n-    }\n-\n   /* If we are comparing an expression that just has comparisons\n      of two integer values, arithmetic expressions of those comparisons,\n      and constants, we can simplify it.  There are only three cases"}, {"sha": "980b73b9a191469caf47504556ba2c0c80792a22", "filename": "gcc/match.pd", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4817bd63533bc94d7605eefbdebc06dc271a63d/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4817bd63533bc94d7605eefbdebc06dc271a63d/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b4817bd63533bc94d7605eefbdebc06dc271a63d", "patch": "@@ -1312,6 +1312,38 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (minmax (bit_not:s@2 @0) (bit_not:s@3 @1))\n   (bit_not (maxmin @0 @1))))\n \n+/* MIN (X, Y) == X -> X <= Y  */\n+(for minmax (min min max max)\n+     cmp    (eq  ne  eq  ne )\n+     out    (le  gt  ge  lt )\n+ (simplify\n+  (cmp:c (minmax:c @0 @1) @0)\n+  (if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0)))\n+   (out @0 @1))))\n+/* MIN (X, 5) == 0 -> X == 0\n+   MIN (X, 5) == 7 -> false  */\n+(for cmp (eq ne)\n+ (simplify\n+  (cmp (min @0 INTEGER_CST@1) INTEGER_CST@2)\n+  (if (wi::lt_p (@1, @2, TYPE_SIGN (TREE_TYPE (@0))))\n+   { constant_boolean_node (cmp == NE_EXPR, type); }\n+   (if (wi::gt_p (@1, @2, TYPE_SIGN (TREE_TYPE (@0))))\n+    (cmp @0 @2)))))\n+(for cmp (eq ne)\n+ (simplify\n+  (cmp (max @0 INTEGER_CST@1) INTEGER_CST@2)\n+  (if (wi::gt_p (@1, @2, TYPE_SIGN (TREE_TYPE (@0))))\n+   { constant_boolean_node (cmp == NE_EXPR, type); }\n+   (if (wi::lt_p (@1, @2, TYPE_SIGN (TREE_TYPE (@0))))\n+    (cmp @0 @2)))))\n+/* MIN (X, C1) < C2 -> X < C2 || C1 < C2  */\n+(for minmax (min     min     max     max     min     min     max     max    )\n+     cmp    (lt      le      gt      ge      gt      ge      lt      le     )\n+     comb   (bit_ior bit_ior bit_ior bit_ior bit_and bit_and bit_and bit_and)\n+ (simplify\n+  (cmp (minmax @0 INTEGER_CST@1) INTEGER_CST@2)\n+  (comb (cmp @0 @2) (cmp @1 @2))))\n+\n /* Simplifications of shift and rotates.  */\n \n (for rotate (lrotate rrotate)"}]}