{"sha": "e01857197b5fbd660903fe8c0b4c6387780afe10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAxODU3MTk3YjVmYmQ2NjA5MDNmZThjMGI0YzYzODc3ODBhZmUxMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-28T14:50:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-28T14:50:19Z"}, "message": "Fix previous commit (that included unrelated changes)\n\nThis patch fixes profile updates while cloning.  When new clone is produced\nits global profile is subtracted from the original function.  If the original\nfunction profile drops to 0 we want to switch from global profiles to global0\nprofiles which is implemented by combine_with_ipa_count_within.\n\nHowever this is done on all edges independnetly and it may happen that we end\nup combining global and globa0 profiles in one functions which is not a good\nidea.\n\nThis implements profile_count::combine_with_ipa_count_within which is able\nto take into account that the counter is inside function with a given count.\n\n\t* profile-count.h (profile_count::combine_with_ipa_count_within):\n\tDeclare.\n\t* profile-count.c (profile_count::combine_with_ipa_count_within):\n\tNew.\n\t* cgraphclones.c (cgraph_edge::clone, cgraph_node::create_clone): Use\n\tit.\n\nFrom-SVN: r278811", "tree": {"sha": "bcb009c889eab215f1a3f29ff8e10bb1a0bca295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcb009c889eab215f1a3f29ff8e10bb1a0bca295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e01857197b5fbd660903fe8c0b4c6387780afe10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01857197b5fbd660903fe8c0b4c6387780afe10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01857197b5fbd660903fe8c0b4c6387780afe10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01857197b5fbd660903fe8c0b4c6387780afe10/comments", "author": null, "committer": null, "parents": [{"sha": "b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb"}], "stats": {"total": 105, "additions": 5, "deletions": 100}, "files": [{"sha": "a79491e0b88b96f75d2167997ef6230fb3195d5c", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01857197b5fbd660903fe8c0b4c6387780afe10/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01857197b5fbd660903fe8c0b4c6387780afe10/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=e01857197b5fbd660903fe8c0b4c6387780afe10", "patch": "@@ -80,11 +80,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"dumpfile.h\"\n #include \"gimple-pretty-print.h\"\n-#include \"alloc-pool.h\"\n-#include \"symbol-summary.h\"\n-#include \"tree-vrp.h\"\n-#include \"ipa-prop.h\"\n-#include \"ipa-fnsummary.h\"\n \n /* Create clone of edge in the node N represented by CALL_EXPR\n    the callgraph.  */\n@@ -274,8 +269,6 @@ cgraph_node::expand_all_artificial_thunks ()\n \t    thunk->thunk.thunk_p = false;\n \t    thunk->analyze ();\n \t  }\n-\tipa_analyze_node (thunk);\n-\tinline_analyze_function (thunk);\n \tthunk->expand_all_artificial_thunks ();\n       }\n     else"}, {"sha": "e91f9cbd26dcd1f6d6915b5aad8271755eb7a7bc", "filename": "gcc/profile-count.c", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01857197b5fbd660903fe8c0b4c6387780afe10/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01857197b5fbd660903fe8c0b4c6387780afe10/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=e01857197b5fbd660903fe8c0b4c6387780afe10", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"wide-int.h\"\n #include \"sreal.h\"\n-#include \"selftest.h\"\n \n /* Names from profile_quality enum values.  */\n \n@@ -292,7 +291,6 @@ profile_count::to_cgraph_frequency (profile_count entry_bb_count) const\n     return 0;\n   gcc_checking_assert (entry_bb_count.initialized_p ());\n   uint64_t scale;\n-  gcc_checking_assert (compatible_p (entry_bb_count));\n   if (!safe_scale_64bit (!entry_bb_count.m_val ? m_val + 1 : m_val,\n \t\t\t CGRAPH_FREQ_BASE, MAX (1, entry_bb_count.m_val), &scale))\n     return CGRAPH_FREQ_MAX;\n@@ -330,7 +328,6 @@ profile_count::to_sreal_scale (profile_count in, bool *known) const\n     return 0;\n   if (m_val == in.m_val)\n     return 1;\n-  gcc_checking_assert (compatible_p (in));\n \n   if (!in.m_val)\n     {\n@@ -376,8 +373,6 @@ profile_count::adjust_for_ipa_scaling (profile_count *num,\n profile_count\n profile_count::combine_with_ipa_count (profile_count ipa)\n {\n-  if (!initialized_p ())\n-    return *this;\n   ipa = ipa.ipa ();\n   if (ipa.nonzero_p ())\n     return ipa;\n@@ -447,65 +442,3 @@ profile_probability::combine_with_count (profile_count count1,\n   else\n     return *this * even () + other * even ();\n }\n-\n-#if CHECKING_P\n-namespace selftest {\n-\n-/* Verify non-trivial type conversions for IPA scaling.  This happens often\n-   during inlining.  */\n-\n-static void\n-profile_count_verify_ipa_scaling (void)\n-{\n-  profile_count cnt1 = profile_count::from_gcov_type (4).global0 ();\n-  profile_count cnt2 = profile_count::from_gcov_type (2);\n-  profile_count cnt3 = profile_count::from_gcov_type (8);\n-  profile_count cnt4 = cnt3.apply_scale (cnt1, cnt2);\n-\n-  /* Result should be 16 with GUESSED_GLOBAL0.  */\n-  ASSERT_EQ (cnt4.ipa (), profile_count::zero ());\n-  ASSERT_EQ (cnt4.to_gcov_type (), 16);\n-\n-  cnt1 = profile_count::from_gcov_type (4).global0adjusted ();\n-  cnt4 = cnt3.apply_scale (cnt1, cnt2);\n-  /* Result should be 16 with GUESSED_GLOBAL0_ADJUSTED.  */\n-  ASSERT_EQ (cnt4.ipa (), profile_count::adjusted_zero ());\n-  ASSERT_EQ (cnt4.to_gcov_type (), 16);\n-}\n-\n-/* Verify non-trivial cases of sreal scale calculations.  */\n-\n-static void\n-profile_count_verify_to_sreal_scale (void)\n-{\n-  profile_count cnt1 = profile_count::from_gcov_type (4).global0 ();\n-  profile_count cnt2 = profile_count::from_gcov_type (8);\n-\n-  /* If count is globally 0 it should have 0 scale in non-zero global count.  */\n-  ASSERT_EQ (cnt1.to_sreal_scale (cnt2), 0);\n-}\n-\n-/* Verify non-trivial cases of probability_in calculations.  */\n-\n-static void\n-profile_count_verify_probability_in (void)\n-{\n-  /*profile_count cnt1 = profile_count::from_gcov_type (4).global0 ();\n-  profile_count cnt2 = profile_count::from_gcov_type (8);*/\n-\n-  /* If count is globally 0 it should have 0 probability in non-zero global\n-     count.  */\n-  /*ASSERT_EQ (cnt1.probability_in (cnt2), profile_probability::never ());*/\n-}\n-\n-/* Run all of the selftests within this file.  */\n-\n-void profile_count_c_tests (void)\n-{\n-  profile_count_verify_ipa_scaling ();\n-  profile_count_verify_to_sreal_scale ();\n-  profile_count_verify_probability_in ();\n-}\n-\n-}\n-#endif"}, {"sha": "967c5ec1a128a66d4333b06f698f741731dec130", "filename": "gcc/profile-count.h", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01857197b5fbd660903fe8c0b4c6387780afe10/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01857197b5fbd660903fe8c0b4c6387780afe10/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=e01857197b5fbd660903fe8c0b4c6387780afe10", "patch": "@@ -700,7 +700,6 @@ struct GTY(()) profile_count\n   uint64_t UINT64_BIT_FIELD_ALIGN m_val : n_bits;\n #undef UINT64_BIT_FIELD_ALIGN\n   enum profile_quality m_quality : 3;\n-public:\n \n   /* Return true if both values can meaningfully appear in single function\n      body.  We have either all counters in function local or global, otherwise\n@@ -712,18 +711,9 @@ struct GTY(()) profile_count\n       if (*this == zero ()\n \t  || other == zero ())\n \treturn true;\n-      /* Do not allow nonzero global profile together with local guesses\n-\t that are globally0.  */\n-      if (ipa ().nonzero_p ()\n-\t  && !(other.ipa () == other))\n-\treturn false;\n-      if (other.ipa ().nonzero_p ()\n-\t  && !(ipa () == *this))\n-\treturn false;\n-\t\n       return ipa_p () == other.ipa_p ();\n     }\n-\n+public:\n   /* Used for counters which are expected to be never executed.  */\n   static profile_count zero ()\n     {\n@@ -1002,14 +992,6 @@ struct GTY(()) profile_count\n \n   profile_count max (profile_count other) const\n     {\n-      profile_count val = *this;\n-\n-      /* Always prefer nonzero IPA counts over local counts.  */\n-      if (ipa ().nonzero_p () || other.ipa ().nonzero_p ())\n-\t{\n-\t  val = ipa ();\n-\t  other = other.ipa ();\n-\t}\n       if (!initialized_p ())\n \treturn other;\n       if (!other.initialized_p ())\n@@ -1019,8 +1001,8 @@ struct GTY(()) profile_count\n       if (other == zero ())\n \treturn *this;\n       gcc_checking_assert (compatible_p (other));\n-      if (val.m_val < other.m_val || (m_val == other.m_val\n-\t\t\t\t      && val.m_quality < other.m_quality))\n+      if (m_val < other.m_val || (m_val == other.m_val\n+\t\t\t\t  && m_quality < other.m_quality))\n \treturn other;\n       return *this;\n     }\n@@ -1079,7 +1061,6 @@ struct GTY(()) profile_count\n     {\n       if (*this == zero ())\n \treturn *this;\n-\n       if (num == zero ())\n \treturn num;\n       if (!initialized_p () || !num.initialized_p () || !den.initialized_p ())\n@@ -1094,9 +1075,7 @@ struct GTY(()) profile_count\n       ret.m_val = MIN (val, max_count);\n       ret.m_quality = MIN (MIN (MIN (m_quality, ADJUSTED),\n \t\t\t        num.m_quality), den.m_quality);\n-      /* Be sure that ret is not local or global0 type \n-\t if num is global.  */\n-      if (num.ipa_p () && (!ret.ipa_p () || !(ret.ipa () == ret)))\n+      if (num.ipa_p () && !ret.ipa_p ())\n \tret.m_quality = MIN (num.m_quality, GUESSED);\n       return ret;\n     }\n@@ -1174,8 +1153,8 @@ struct GTY(()) profile_count\n       if (*this == overall && m_quality == PRECISE)\n \treturn profile_probability::always ();\n       profile_probability ret;\n-\n       gcc_checking_assert (compatible_p (overall));\n+\n       if (overall.m_val < m_val)\n \t{\n \t  ret.m_val = profile_probability::max_probability;"}]}