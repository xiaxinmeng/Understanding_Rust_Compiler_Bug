{"sha": "7a504f3390ecfe3457d37b9d716262a14d5d1938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E1MDRmMzM5MGVjZmUzNDU3ZDM3YjlkNzE2MjYyYTE0ZDVkMTkzOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:13:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:13:13Z"}, "message": "[34/77] Add a SCALAR_INT_TYPE_MODE macro\n\nThis patch adds a SCALAR_INT_TYPE_MODE macro that asserts\nthat the type has a scalar integer mode and returns it as\na scalar_int_mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree.h (SCALAR_INT_TYPE_MODE): New macro.\n\t* builtins.c (expand_builtin_signbit): Use it.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t(do_compare_and_jump): Likewise.\n\t* dwarf2cfi.c (expand_builtin_init_dwarf_reg_sizes): Likewise.\n\t* expmed.c (make_tree): Likewise.\n\t* expr.c (expand_expr_real_2): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t(try_casesi): Likewise.\n\t* fold-const-call.c (fold_const_call_ss): Likewise.\n\t* fold-const.c (unextend): Likewise.\n\t(extract_muldiv_1): Likewise.\n\t(fold_single_bit_test): Likewise.\n\t(native_encode_int): Likewise.\n\t(native_encode_string): Likewise.\n\t(native_interpret_int): Likewise.\n\t* gimple-fold.c (gimple_fold_builtin_memset): Likewise.\n\t* internal-fn.c (expand_addsub_overflow): Likewise.\n\t(expand_neg_overflow): Likewise.\n\t(expand_mul_overflow): Likewise.\n\t(expand_arith_overflow): Likewise.\n\t* match.pd: Likewise.\n\t* stor-layout.c (layout_type): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_ternary): Likewise.\n\t* tree-ssa-math-opts.c (convert_mult_to_widen): Likewise.\n\t* tree-ssanames.c (get_range_info): Likewise.\n\t* tree-switch-conversion.c (array_value_type) Likewise.\n\t* tree-vect-patterns.c (vect_recog_rotate_pattern): Likewise.\n\t(vect_recog_divmod_pattern): Likewise.\n\t(vect_recog_mixed_size_cond_pattern): Likewise.\n\t* tree-vrp.c (extract_range_basic): Likewise.\n\t(simplify_float_conversion_using_ranges): Likewise.\n\t* tree.c (int_fits_type_p): Likewise.\n\t* ubsan.c (instrument_bool_enum_load): Likewise.\n\t* varasm.c (mergeable_string_section): Likewise.\n\t(narrowing_initializer_constant_valid_p): Likewise.\n\t(output_constant): Likewise.\n\ngcc/cp/\n\t* cvt.c (cp_convert_to_pointer): Use SCALAR_INT_TYPE_MODE.\n\ngcc/fortran/\n\t* target-memory.c (size_integer): Use SCALAR_INT_TYPE_MODE.\n\t(size_logical): Likewise.\n\ngcc/objc/\n\t* objc-encoding.c (encode_type): Use SCALAR_INT_TYPE_MODE.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251486", "tree": {"sha": "b82ca3c1c102db705f30f93ae7aedc8c75c391c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b82ca3c1c102db705f30f93ae7aedc8c75c391c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a504f3390ecfe3457d37b9d716262a14d5d1938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a504f3390ecfe3457d37b9d716262a14d5d1938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a504f3390ecfe3457d37b9d716262a14d5d1938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a504f3390ecfe3457d37b9d716262a14d5d1938/comments", "author": null, "committer": null, "parents": [{"sha": "e72b0ef4b787599b87cd16b0d929d5d75c6da6bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72b0ef4b787599b87cd16b0d929d5d75c6da6bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72b0ef4b787599b87cd16b0d929d5d75c6da6bc"}], "stats": {"total": 262, "additions": 166, "deletions": 96}, "files": [{"sha": "37e7b70d20224a3251628ffce183636b08e379d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1,3 +1,46 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree.h (SCALAR_INT_TYPE_MODE): New macro.\n+\t* builtins.c (expand_builtin_signbit): Use it.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t(do_compare_and_jump): Likewise.\n+\t* dwarf2cfi.c (expand_builtin_init_dwarf_reg_sizes): Likewise.\n+\t* expmed.c (make_tree): Likewise.\n+\t* expr.c (expand_expr_real_2): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t(try_casesi): Likewise.\n+\t* fold-const-call.c (fold_const_call_ss): Likewise.\n+\t* fold-const.c (unextend): Likewise.\n+\t(extract_muldiv_1): Likewise.\n+\t(fold_single_bit_test): Likewise.\n+\t(native_encode_int): Likewise.\n+\t(native_encode_string): Likewise.\n+\t(native_interpret_int): Likewise.\n+\t* gimple-fold.c (gimple_fold_builtin_memset): Likewise.\n+\t* internal-fn.c (expand_addsub_overflow): Likewise.\n+\t(expand_neg_overflow): Likewise.\n+\t(expand_mul_overflow): Likewise.\n+\t(expand_arith_overflow): Likewise.\n+\t* match.pd: Likewise.\n+\t* stor-layout.c (layout_type): Likewise.\n+\t* tree-cfg.c (verify_gimple_assign_ternary): Likewise.\n+\t* tree-ssa-math-opts.c (convert_mult_to_widen): Likewise.\n+\t* tree-ssanames.c (get_range_info): Likewise.\n+\t* tree-switch-conversion.c (array_value_type) Likewise.\n+\t* tree-vect-patterns.c (vect_recog_rotate_pattern): Likewise.\n+\t(vect_recog_divmod_pattern): Likewise.\n+\t(vect_recog_mixed_size_cond_pattern): Likewise.\n+\t* tree-vrp.c (extract_range_basic): Likewise.\n+\t(simplify_float_conversion_using_ranges): Likewise.\n+\t* tree.c (int_fits_type_p): Likewise.\n+\t* ubsan.c (instrument_bool_enum_load): Likewise.\n+\t* varasm.c (mergeable_string_section): Likewise.\n+\t(narrowing_initializer_constant_valid_p): Likewise.\n+\t(output_constant): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "1343e9ddc07a3680ead4f36da6d4e419b27ea6dc", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -5314,7 +5314,7 @@ expand_builtin_signbit (tree exp, rtx target)\n \n   arg = CALL_EXPR_ARG (exp, 0);\n   fmode = SCALAR_FLOAT_TYPE_MODE (TREE_TYPE (arg));\n-  rmode = TYPE_MODE (TREE_TYPE (exp));\n+  rmode = SCALAR_INT_TYPE_MODE (TREE_TYPE (exp));\n   fmt = REAL_MODE_FORMAT (fmode);\n \n   arg = builtin_save_expr (arg);"}, {"sha": "8e93ce83bda9a284f72d31da34c31a55a463aa1a", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -4139,7 +4139,7 @@ expand_debug_expr (tree exp)\n   machine_mode inner_mode = VOIDmode;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n   addr_space_t as;\n-  scalar_int_mode op0_mode, op1_mode;\n+  scalar_int_mode op0_mode, op1_mode, addr_mode;\n \n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n@@ -4914,7 +4914,8 @@ expand_debug_expr (tree exp)\n \t}\n \n       as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)));\n-      op0 = convert_debug_memory_address (mode, XEXP (op0, 0), as);\n+      addr_mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (exp));\n+      op0 = convert_debug_memory_address (addr_mode, XEXP (op0, 0), as);\n \n       return op0;\n "}, {"sha": "42375e9c90281a4b0db5498f81f5490c0b9fd051", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1,3 +1,9 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Use SCALAR_INT_TYPE_MODE.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a3bd4a137d82a04411683a2a80d17168dd00373f", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -236,8 +236,8 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n       /* Modes may be different but sizes should be the same.  There\n \t is supposed to be some integral type that is the same width\n \t as a pointer.  */\n-      gcc_assert (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr)))\n-\t\t  == GET_MODE_SIZE (TYPE_MODE (type)));\n+      gcc_assert (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (expr)))\n+\t\t  == GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (type)));\n \n       return convert_to_pointer_maybe_fold (type, expr, dofold);\n     }"}, {"sha": "151d2cb6606a9c696c49d4eb932f48c4442e0961", "filename": "gcc/dojump.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -571,7 +571,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n \t      if (TREE_CODE (shift) == INTEGER_CST\n \t\t  && compare_tree_int (shift, 0) >= 0\n \t\t  && compare_tree_int (shift, HOST_BITS_PER_WIDE_INT) < 0\n-\t\t  && prefer_and_bit_test (TYPE_MODE (argtype),\n+\t\t  && prefer_and_bit_test (SCALAR_INT_TYPE_MODE (argtype),\n \t\t\t\t\t  TREE_INT_CST_LOW (shift)))\n \t\t{\n \t\t  unsigned HOST_WIDE_INT mask\n@@ -1190,17 +1190,14 @@ do_compare_and_jump (tree treeop0, tree treeop1, enum rtx_code signed_code,\n     return;\n \n   type = TREE_TYPE (treeop0);\n-  mode = TYPE_MODE (type);\n   if (TREE_CODE (treeop0) == INTEGER_CST\n       && (TREE_CODE (treeop1) != INTEGER_CST\n-          || (GET_MODE_BITSIZE (mode)\n-              > GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (treeop1))))))\n-    {\n-      /* op0 might have been replaced by promoted constant, in which\n-         case the type of second argument should be used.  */\n-      type = TREE_TYPE (treeop1);\n-      mode = TYPE_MODE (type);\n-    }\n+\t  || (GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (type))\n+\t      > GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (treeop1))))))\n+    /* op0 might have been replaced by promoted constant, in which\n+       case the type of second argument should be used.  */\n+    type = TREE_TYPE (treeop1);\n+  mode = TYPE_MODE (type);\n   unsignedp = TYPE_UNSIGNED (type);\n   code = unsignedp ? unsigned_code : signed_code;\n "}, {"sha": "8c934842bf8b5d1ebb31008f7fb9881dee5cddd0", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -299,7 +299,7 @@ void\n expand_builtin_init_dwarf_reg_sizes (tree address)\n {\n   unsigned int i;\n-  machine_mode mode = TYPE_MODE (char_type_node);\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (char_type_node);\n   rtx addr = expand_normal (address);\n   rtx mem = gen_rtx_MEM (BLKmode, addr);\n "}, {"sha": "1cae1000cdc6c6f4f649612f41ea738e3c5636f7", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -5250,7 +5250,7 @@ make_tree (tree type, rtx x)\n \t address mode to pointer mode.  */\n       if (POINTER_TYPE_P (type))\n \tx = convert_memory_address_addr_space\n-\t      (TYPE_MODE (type), x, TYPE_ADDR_SPACE (TREE_TYPE (type)));\n+\t  (SCALAR_INT_TYPE_MODE (type), x, TYPE_ADDR_SPACE (TREE_TYPE (type)));\n \n       /* Note that we do *not* use SET_DECL_RTL here, because we do not\n \t want set_decl_rtl to go adjusting REG_ATTRS for this temporary.  */"}, {"sha": "b68402fe9d6fa520b6513f07421e47ae90ff5a12", "filename": "gcc/expr.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -9077,11 +9077,12 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t instead.  */\n       if (reduce_bit_field && TYPE_UNSIGNED (type))\n \t{\n+\t  int_mode = SCALAR_INT_TYPE_MODE (type);\n \t  wide_int mask = wi::mask (TYPE_PRECISION (type),\n-\t\t\t\t    false, GET_MODE_PRECISION (mode));\n+\t\t\t\t    false, GET_MODE_PRECISION (int_mode));\n \n-\t  temp = expand_binop (mode, xor_optab, op0,\n-\t\t\t       immed_wide_int_const (mask, mode),\n+\t  temp = expand_binop (int_mode, xor_optab, op0,\n+\t\t\t       immed_wide_int_const (mask, int_mode),\n \t\t\t       target, 1, OPTAB_LIB_WIDEN);\n \t}\n       else\n@@ -9181,7 +9182,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t    if (is_gimple_assign (def)\n \t\t&& gimple_assign_rhs_code (def) == NOP_EXPR)\n \t      {\n-\t\tmachine_mode rmode = TYPE_MODE\n+\t\tscalar_int_mode rmode = SCALAR_INT_TYPE_MODE\n \t\t  (TREE_TYPE (gimple_assign_rhs1 (def)));\n \n \t\tif (GET_MODE_SIZE (rmode) < GET_MODE_SIZE (int_mode)\n@@ -9949,15 +9950,16 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n       return decl_rtl;\n \n     case INTEGER_CST:\n-      /* Given that TYPE_PRECISION (type) is not always equal to\n-         GET_MODE_PRECISION (TYPE_MODE (type)), we need to extend from\n-         the former to the latter according to the signedness of the\n-         type. */\n-      temp = immed_wide_int_const (wi::to_wide\n-\t\t\t\t   (exp,\n-\t\t\t\t    GET_MODE_PRECISION (TYPE_MODE (type))),\n-\t\t\t\t   TYPE_MODE (type));\n-      return temp;\n+      {\n+\t/* Given that TYPE_PRECISION (type) is not always equal to\n+\t   GET_MODE_PRECISION (TYPE_MODE (type)), we need to extend from\n+\t   the former to the latter according to the signedness of the\n+\t   type.  */\n+\tscalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);\n+\ttemp = immed_wide_int_const\n+\t  (wi::to_wide (exp, GET_MODE_PRECISION (mode)), mode);\n+\treturn temp;\n+      }\n \n     case VECTOR_CST:\n       {\n@@ -10416,7 +10418,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\tif (DECL_BIT_FIELD (field))\n \t\t  {\n \t\t    HOST_WIDE_INT bitsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n-\t\t    machine_mode imode = TYPE_MODE (TREE_TYPE (field));\n+\t\t    scalar_int_mode imode\n+\t\t      = SCALAR_INT_TYPE_MODE (TREE_TYPE (field));\n \n \t\t    if (TYPE_UNSIGNED (TREE_TYPE (field)))\n \t\t      {\n@@ -11546,10 +11549,10 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n   if (! targetm.have_casesi ())\n     return 0;\n \n-  /* Convert the index to SImode.  */\n-  if (GET_MODE_BITSIZE (TYPE_MODE (index_type)) > GET_MODE_BITSIZE (index_mode))\n+  /* The index must be some form of integer.  Convert it to SImode.  */\n+  scalar_int_mode omode = SCALAR_INT_TYPE_MODE (index_type);\n+  if (GET_MODE_BITSIZE (omode) > GET_MODE_BITSIZE (index_mode))\n     {\n-      machine_mode omode = TYPE_MODE (index_type);\n       rtx rangertx = expand_normal (range);\n \n       /* We must handle the endpoints in the original mode.  */\n@@ -11566,7 +11569,7 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n     }\n   else\n     {\n-      if (TYPE_MODE (index_type) != index_mode)\n+      if (omode != index_mode)\n \t{\n \t  index_type = lang_hooks.types.type_for_mode (index_mode, 0);\n \t  index_expr = fold_convert (index_type, index_expr);"}, {"sha": "71f0b52468040ae4a5faa11a51f9cd4bc0e41119", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -844,7 +844,8 @@ fold_const_call_ss (wide_int *result, combined_fn fn, const wide_int_ref &arg,\n \tint tmp;\n \tif (wi::ne_p (arg, 0))\n \t  tmp = wi::clz (arg);\n-\telse if (! CLZ_DEFINED_VALUE_AT_ZERO (TYPE_MODE (arg_type), tmp))\n+\telse if (!CLZ_DEFINED_VALUE_AT_ZERO (SCALAR_INT_TYPE_MODE (arg_type),\n+\t\t\t\t\t     tmp))\n \t  tmp = TYPE_PRECISION (arg_type);\n \t*result = wi::shwi (tmp, precision);\n \treturn true;\n@@ -855,7 +856,8 @@ fold_const_call_ss (wide_int *result, combined_fn fn, const wide_int_ref &arg,\n \tint tmp;\n \tif (wi::ne_p (arg, 0))\n \t  tmp = wi::ctz (arg);\n-\telse if (! CTZ_DEFINED_VALUE_AT_ZERO (TYPE_MODE (arg_type), tmp))\n+\telse if (!CTZ_DEFINED_VALUE_AT_ZERO (SCALAR_INT_TYPE_MODE (arg_type),\n+\t\t\t\t\t     tmp))\n \t  tmp = TYPE_PRECISION (arg_type);\n \t*result = wi::shwi (tmp, precision);\n \treturn true;"}, {"sha": "d4d3c444297e3db61dc613c7bc7bd70df202201b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -5441,7 +5441,7 @@ static tree\n unextend (tree c, int p, int unsignedp, tree mask)\n {\n   tree type = TREE_TYPE (c);\n-  int modesize = GET_MODE_BITSIZE (TYPE_MODE (type));\n+  int modesize = GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (type));\n   tree temp;\n \n   if (p == modesize || unsignedp)\n@@ -6031,8 +6031,9 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n {\n   tree type = TREE_TYPE (t);\n   enum tree_code tcode = TREE_CODE (t);\n-  tree ctype = (wide_type != 0 && (GET_MODE_SIZE (TYPE_MODE (wide_type))\n-\t\t\t\t   > GET_MODE_SIZE (TYPE_MODE (type)))\n+  tree ctype = (wide_type != 0\n+\t\t&& (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (wide_type))\n+\t\t    > GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (type)))\n \t\t? wide_type : type);\n   tree t1, t2;\n   int same_p = tcode == code;\n@@ -6669,7 +6670,7 @@ fold_single_bit_test (location_t loc, enum tree_code code,\n       tree inner = TREE_OPERAND (arg0, 0);\n       tree type = TREE_TYPE (arg0);\n       int bitnum = tree_log2 (TREE_OPERAND (arg0, 1));\n-      machine_mode operand_mode = TYPE_MODE (type);\n+      scalar_int_mode operand_mode = SCALAR_INT_TYPE_MODE (type);\n       int ops_unsigned;\n       tree signed_type, unsigned_type, intermediate_type;\n       tree tem, one;\n@@ -6980,7 +6981,7 @@ static int\n native_encode_int (const_tree expr, unsigned char *ptr, int len, int off)\n {\n   tree type = TREE_TYPE (expr);\n-  int total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n+  int total_bytes = GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (type));\n   int byte, offset, word, words;\n   unsigned char value;\n \n@@ -7190,7 +7191,8 @@ native_encode_string (const_tree expr, unsigned char *ptr, int len, int off)\n \n   if (TREE_CODE (type) != ARRAY_TYPE\n       || TREE_CODE (TREE_TYPE (type)) != INTEGER_TYPE\n-      || GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (type))) != BITS_PER_UNIT\n+      || (GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (type)))\n+\t  != BITS_PER_UNIT)\n       || !tree_fits_shwi_p (TYPE_SIZE_UNIT (type)))\n     return 0;\n   total_bytes = tree_to_shwi (TYPE_SIZE_UNIT (type));\n@@ -7262,7 +7264,7 @@ native_encode_expr (const_tree expr, unsigned char *ptr, int len, int off)\n static tree\n native_interpret_int (tree type, const unsigned char *ptr, int len)\n {\n-  int total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n+  int total_bytes = GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (type));\n \n   if (total_bytes > len\n       || total_bytes * BITS_PER_UNIT > HOST_BITS_PER_DOUBLE_INT)"}, {"sha": "c0d684b4f10af9d1096b1a3821032aef5494b9e7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target-memory.c (size_integer): Use SCALAR_INT_TYPE_MODE.\n+\t(size_logical): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "ceca3accd9390ed41bf41e4360a27fce3e80e9a4", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n static size_t\n size_integer (int kind)\n {\n-  return GET_MODE_SIZE (TYPE_MODE (gfc_get_int_type (kind)));;\n+  return GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (gfc_get_int_type (kind)));\n }\n \n \n@@ -60,7 +60,7 @@ size_complex (int kind)\n static size_t\n size_logical (int kind)\n {\n-  return GET_MODE_SIZE (TYPE_MODE (gfc_get_logical_type (kind)));;\n+  return GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (gfc_get_logical_type (kind)));\n }\n \n "}, {"sha": "367b35c5c9ba6f70f89d0e4314a86f4a1cf84076", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1230,7 +1230,7 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n     return NULL_TREE;\n \n   length = tree_to_uhwi (len);\n-  if (GET_MODE_SIZE (TYPE_MODE (etype)) != length\n+  if (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (etype)) != length\n       || get_pointer_alignment (dest) / BITS_PER_UNIT < length)\n     return NULL_TREE;\n "}, {"sha": "724ada357192dde11e6000190db522f22ed7270a", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -645,7 +645,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n   do_pending_stack_adjust ();\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n-  machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg0));\n   int prec = GET_MODE_PRECISION (mode);\n   rtx sgn = immed_wide_int_const (wi::min_value (prec, SIGNED), mode);\n   bool do_xor = false;\n@@ -1097,7 +1097,7 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan,\n   do_pending_stack_adjust ();\n   op1 = expand_normal (arg1);\n \n-  machine_mode mode = TYPE_MODE (TREE_TYPE (arg1));\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg1));\n   if (lhs)\n     {\n       target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n@@ -1192,7 +1192,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n   op0 = expand_normal (arg0);\n   op1 = expand_normal (arg1);\n \n-  machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg0));\n   bool uns = unsr_p;\n   if (lhs)\n     {\n@@ -2120,7 +2120,7 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n \t  /* The infinity precision result will always fit into result.  */\n \t  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \t  write_complex_part (target, const0_rtx, true);\n-\t  machine_mode mode = TYPE_MODE (type);\n+\t  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);\n \t  struct separate_ops ops;\n \t  ops.code = code;\n \t  ops.type = type;"}, {"sha": "ff8f7b18f6a6bdd74b0a6603d3f327a3d4210d59", "filename": "gcc/match.pd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -3397,7 +3397,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t     associated with the mode of @1, so the sign bit is\n \t     specified by this mode.  Check that @1 is the signed\n \t     max associated with this sign bit.  */\n-\t  && prec == GET_MODE_PRECISION (TYPE_MODE (arg1_type))\n+\t  && prec == GET_MODE_PRECISION (SCALAR_INT_TYPE_MODE (arg1_type))\n \t  /* signed_type does not work on pointer types.  */\n \t  && INTEGRAL_TYPE_P (arg1_type))\n       /* The following case also applies to X < signed_max+1"}, {"sha": "d5929493fe3cf4ee63f7a3e8c34c0b3599f7bbc2", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1,3 +1,9 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* objc-encoding.c (encode_type): Use SCALAR_INT_TYPE_MODE.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "9f46d57ac8ca5f10c08aa6c59a496dfbde361ab4", "filename": "gcc/objc/objc-encoding.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fobjc%2Fobjc-encoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fobjc%2Fobjc-encoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-encoding.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -626,7 +626,7 @@ encode_type (tree type, int curtype, int format)\n     case INTEGER_TYPE:\n       {\n \tchar c;\n-\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\tswitch (GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (type)))\n \t  {\n \t  case 8:  c = TYPE_UNSIGNED (type) ? 'C' : 'c'; break;\n \t  case 16: c = TYPE_UNSIGNED (type) ? 'S' : 's'; break;"}, {"sha": "e37c15f3dad406e508ce96ffae50703a17bf5ae1", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -2309,7 +2309,7 @@ layout_type (tree type)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       {\n-\tmachine_mode mode = TYPE_MODE (type);\n+\tscalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);\n \tTYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (mode));\n \tTYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (mode));\n \tTYPE_UNSIGNED (type) = 1;"}, {"sha": "c156b81b186d55b5d8f7194d18a6078dcc6a0a92", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -4191,7 +4191,7 @@ verify_gimple_assign_ternary (gassign *stmt)\n \t}\n \n       if (TREE_CODE (TREE_TYPE (rhs3_type)) != INTEGER_TYPE\n-\t  || GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (rhs3_type)))\n+\t  || GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (rhs3_type)))\n \t     != GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (rhs1_type))))\n \t{\n \t  error (\"invalid mask type in vector permute expression\");"}, {"sha": "86a1559050de5c6d5eb8b6a10e3baee77054629c", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -3256,8 +3256,8 @@ convert_mult_to_widen (gimple *stmt, gimple_stmt_iterator *gsi)\n   if (!is_widening_mult_p (stmt, &type1, &rhs1, &type2, &rhs2))\n     return false;\n \n-  to_mode = TYPE_MODE (type);\n-  from_mode = TYPE_MODE (type1);\n+  to_mode = SCALAR_INT_TYPE_MODE (type);\n+  from_mode = SCALAR_INT_TYPE_MODE (type1);\n   from_unsigned1 = TYPE_UNSIGNED (type1);\n   from_unsigned2 = TYPE_UNSIGNED (type2);\n "}, {"sha": "5c96075a05e86033bbe44d4a471a1d026da5c8d3", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -405,7 +405,7 @@ get_range_info (const_tree name, wide_int *min, wide_int *max)\n \n   /* Return VR_VARYING for SSA_NAMEs with NULL RANGE_INFO or SSA_NAMEs\n      with integral types width > 2 * HOST_BITS_PER_WIDE_INT precision.  */\n-  if (!ri || (GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (name)))\n+  if (!ri || (GET_MODE_PRECISION (SCALAR_INT_TYPE_MODE (TREE_TYPE (name)))\n \t      > 2 * HOST_BITS_PER_WIDE_INT))\n     return VR_VARYING;\n "}, {"sha": "82961d8985c8f71694dc3f785cf12bf192676eb2", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1050,7 +1050,7 @@ array_value_type (gswitch *swtch, tree type, int num,\n   if (!INTEGRAL_TYPE_P (type))\n     return type;\n \n-  machine_mode type_mode = TYPE_MODE (type);\n+  scalar_int_mode type_mode = SCALAR_INT_TYPE_MODE (type);\n   machine_mode mode = get_narrowest_mode (type_mode);\n   if (GET_MODE_SIZE (type_mode) <= GET_MODE_SIZE (mode))\n     return type;\n@@ -1097,8 +1097,8 @@ array_value_type (gswitch *swtch, tree type, int num,\n   if (sign == 0)\n     sign = TYPE_UNSIGNED (type) ? 1 : -1;\n   smaller_type = lang_hooks.types.type_for_mode (mode, sign >= 0);\n-  if (GET_MODE_SIZE (TYPE_MODE (type))\n-      <= GET_MODE_SIZE (TYPE_MODE (smaller_type)))\n+  if (GET_MODE_SIZE (type_mode)\n+      <= GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (smaller_type)))\n     return type;\n \n   return smaller_type;"}, {"sha": "6bc4f7ed7adef04e864aadb744f294360f694afa", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1883,13 +1883,14 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n     }\n \n   def = NULL_TREE;\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);\n   if (TREE_CODE (oprnd1) == INTEGER_CST\n-      || TYPE_MODE (TREE_TYPE (oprnd1)) == TYPE_MODE (type))\n+      || TYPE_MODE (TREE_TYPE (oprnd1)) == mode)\n     def = oprnd1;\n   else if (def_stmt && gimple_assign_cast_p (def_stmt))\n     {\n       tree rhs1 = gimple_assign_rhs1 (def_stmt);\n-      if (TYPE_MODE (TREE_TYPE (rhs1)) == TYPE_MODE (type)\n+      if (TYPE_MODE (TREE_TYPE (rhs1)) == mode\n \t  && TYPE_PRECISION (TREE_TYPE (rhs1))\n \t     == TYPE_PRECISION (type))\n \tdef = rhs1;\n@@ -1910,16 +1911,16 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n \tappend_pattern_def_seq (stmt_vinfo, def_stmt);\n     }\n   stype = TREE_TYPE (def);\n+  scalar_int_mode smode = SCALAR_INT_TYPE_MODE (stype);\n \n   if (TREE_CODE (def) == INTEGER_CST)\n     {\n       if (!tree_fits_uhwi_p (def)\n-\t  || tree_to_uhwi (def) >= GET_MODE_PRECISION (TYPE_MODE (type))\n+\t  || tree_to_uhwi (def) >= GET_MODE_PRECISION (mode)\n \t  || integer_zerop (def))\n \treturn NULL;\n       def2 = build_int_cst (stype,\n-\t\t\t    GET_MODE_PRECISION (TYPE_MODE (type))\n-\t\t\t    - tree_to_uhwi (def));\n+\t\t\t    GET_MODE_PRECISION (mode) - tree_to_uhwi (def));\n     }\n   else\n     {\n@@ -1945,8 +1946,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n \t}\n \n       def2 = vect_recog_temp_ssa_var (stype, NULL);\n-      tree mask\n-\t= build_int_cst (stype, GET_MODE_PRECISION (TYPE_MODE (stype)) - 1);\n+      tree mask = build_int_cst (stype, GET_MODE_PRECISION (smode) - 1);\n       def_stmt = gimple_build_assign (def2, BIT_AND_EXPR,\n \t\t\t\t      gimple_assign_lhs (def_stmt), mask);\n       if (ext_def)\n@@ -2588,6 +2588,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n       || !type_has_mode_precision_p (itype))\n     return NULL;\n \n+  scalar_int_mode itype_mode = SCALAR_INT_TYPE_MODE (itype);\n   vectype = get_vectype_for_scalar_type (itype);\n   if (vectype == NULL_TREE)\n     return NULL;\n@@ -2655,7 +2656,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \t\t= build_nonstandard_integer_type (prec, 1);\n \t      tree vecutype = get_vectype_for_scalar_type (utype);\n \t      tree shift\n-\t\t= build_int_cst (utype, GET_MODE_BITSIZE (TYPE_MODE (itype))\n+\t\t= build_int_cst (utype, GET_MODE_BITSIZE (itype_mode)\n \t\t\t\t\t- tree_log2 (oprnd1));\n \t      tree var = vect_recog_temp_ssa_var (utype, NULL);\n \n@@ -2721,7 +2722,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n       unsigned HOST_WIDE_INT mh, ml;\n       int pre_shift, post_shift;\n       unsigned HOST_WIDE_INT d = (TREE_INT_CST_LOW (oprnd1)\n-\t\t\t\t  & GET_MODE_MASK (TYPE_MODE (itype)));\n+\t\t\t\t  & GET_MODE_MASK (itype_mode));\n       tree t1, t2, t3, t4;\n \n       if (d >= (HOST_WIDE_INT_1U << (prec - 1)))\n@@ -3066,7 +3067,8 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n   HOST_WIDE_INT cmp_mode_size\n     = GET_MODE_UNIT_BITSIZE (TYPE_MODE (comp_vectype));\n \n-  if (GET_MODE_BITSIZE (TYPE_MODE (type)) == cmp_mode_size)\n+  scalar_int_mode type_mode = SCALAR_INT_TYPE_MODE (type);\n+  if (GET_MODE_BITSIZE (type_mode) == cmp_mode_size)\n     return NULL;\n \n   vectype = get_vectype_for_scalar_type (type);\n@@ -3091,7 +3093,7 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n   if (!expand_vec_cond_expr_p (vecitype, comp_vectype, TREE_CODE (cond_expr)))\n     return NULL;\n \n-  if (GET_MODE_BITSIZE (TYPE_MODE (type)) > cmp_mode_size)\n+  if (GET_MODE_BITSIZE (type_mode) > cmp_mode_size)\n     {\n       if ((TREE_CODE (then_clause) == INTEGER_CST\n \t   && !int_fits_type_p (then_clause, itype))"}, {"sha": "dc5f00ed0ec0f3e1d6d89198970fe4b4d0976b4d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -3572,6 +3572,7 @@ extract_range_basic (value_range *vr, gimple *stmt)\n       int mini, maxi, zerov = 0, prec;\n       enum tree_code subcode = ERROR_MARK;\n       combined_fn cfn = gimple_call_combined_fn (stmt);\n+      scalar_int_mode mode;\n \n       switch (cfn)\n \t{\n@@ -3632,10 +3633,9 @@ extract_range_basic (value_range *vr, gimple *stmt)\n \t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n \t  mini = 0;\n \t  maxi = prec;\n-\t  if (optab_handler (clz_optab, TYPE_MODE (TREE_TYPE (arg)))\n-\t      != CODE_FOR_nothing\n-\t      && CLZ_DEFINED_VALUE_AT_ZERO (TYPE_MODE (TREE_TYPE (arg)),\n-\t\t\t\t\t    zerov)\n+\t  mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n+\t  if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n+\t      && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov)\n \t      /* Handle only the single common value.  */\n \t      && zerov != prec)\n \t    /* Magic value to give up, unless vr0 proves\n@@ -3684,10 +3684,9 @@ extract_range_basic (value_range *vr, gimple *stmt)\n \t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n \t  mini = 0;\n \t  maxi = prec - 1;\n-\t  if (optab_handler (ctz_optab, TYPE_MODE (TREE_TYPE (arg)))\n-\t      != CODE_FOR_nothing\n-\t      && CTZ_DEFINED_VALUE_AT_ZERO (TYPE_MODE (TREE_TYPE (arg)),\n-\t\t\t\t\t    zerov))\n+\t  mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n+\t  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n+\t      && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov))\n \t    {\n \t      /* Handle only the two common values.  */\n \t      if (zerov == -1)\n@@ -10107,13 +10106,13 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n     return false;\n \n   /* First check if we can use a signed type in place of an unsigned.  */\n+  scalar_int_mode rhs_mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (rhs1));\n   if (TYPE_UNSIGNED (TREE_TYPE (rhs1))\n-      && (can_float_p (fltmode, TYPE_MODE (TREE_TYPE (rhs1)), 0)\n-\t  != CODE_FOR_nothing)\n+      && can_float_p (fltmode, rhs_mode, 0) != CODE_FOR_nothing\n       && range_fits_type_p (vr, TYPE_PRECISION (TREE_TYPE (rhs1)), SIGNED))\n-    mode = TYPE_MODE (TREE_TYPE (rhs1));\n+    mode = rhs_mode;\n   /* If we can do the conversion in the current input mode do nothing.  */\n-  else if (can_float_p (fltmode, TYPE_MODE (TREE_TYPE (rhs1)),\n+  else if (can_float_p (fltmode, rhs_mode,\n \t\t\tTYPE_UNSIGNED (TREE_TYPE (rhs1))) != CODE_FOR_nothing)\n     return false;\n   /* Otherwise search for a mode we can use, starting from the narrowest"}, {"sha": "67be31f6684d85bf7188a20501ce7566aa9f8bd0", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -8461,7 +8461,7 @@ int_fits_type_p (const_tree c, const_tree type)\n   /* Third, unsigned integers with top bit set never fit signed types.  */\n   if (!TYPE_UNSIGNED (type) && sgn_c == UNSIGNED)\n     {\n-      int prec = GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (c))) - 1;\n+      int prec = GET_MODE_PRECISION (SCALAR_INT_TYPE_MODE (TREE_TYPE (c))) - 1;\n       if (prec < TYPE_PRECISION (TREE_TYPE (c)))\n \t{\n \t  /* When a tree_cst is converted to a wide-int, the precision"}, {"sha": "8347669b414fe497402b94930fdea704b3fd2563", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1849,6 +1849,8 @@ extern void protected_set_expr_location (tree, location_t);\n #define TYPE_MODE(NODE) \\\n   (VECTOR_TYPE_P (TYPE_CHECK (NODE)) \\\n    ? vector_type_mode (NODE) : (NODE)->type_common.mode)\n+#define SCALAR_INT_TYPE_MODE(NODE) \\\n+  (as_a <scalar_int_mode> (TYPE_CHECK (NODE)->type_common.mode))\n #define SCALAR_FLOAT_TYPE_MODE(NODE) \\\n   (as_a <scalar_float_mode> (TYPE_CHECK (NODE)->type_common.mode))\n #define SET_TYPE_MODE(NODE, MODE) \\"}, {"sha": "9b2083ff42bca831842bb2fe200c768d868f543d", "filename": "gcc/ubsan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -1659,15 +1659,15 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n \t   && TREE_TYPE (type) != NULL_TREE\n \t   && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n \t   && (TYPE_PRECISION (TREE_TYPE (type))\n-\t       < GET_MODE_PRECISION (TYPE_MODE (type))))\n+\t       < GET_MODE_PRECISION (SCALAR_INT_TYPE_MODE (type))))\n     {\n       minv = TYPE_MIN_VALUE (TREE_TYPE (type));\n       maxv = TYPE_MAX_VALUE (TREE_TYPE (type));\n     }\n   else\n     return;\n \n-  int modebitsize = GET_MODE_BITSIZE (TYPE_MODE (type));\n+  int modebitsize = GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (type));\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n   machine_mode mode;\n@@ -1679,7 +1679,7 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n   if ((VAR_P (base) && DECL_HARD_REGISTER (base))\n       || (bitpos % modebitsize) != 0\n       || bitsize != modebitsize\n-      || GET_MODE_BITSIZE (TYPE_MODE (utype)) != modebitsize\n+      || GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (utype)) != modebitsize\n       || TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n     return;\n "}, {"sha": "04f19e6c8ecc4dd493d3434759c786cbbabe7c98", "filename": "gcc/varasm.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a504f3390ecfe3457d37b9d716262a14d5d1938/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7a504f3390ecfe3457d37b9d716262a14d5d1938", "patch": "@@ -785,15 +785,15 @@ mergeable_string_section (tree decl ATTRIBUTE_UNUSED,\n       && (len = int_size_in_bytes (TREE_TYPE (decl))) > 0\n       && TREE_STRING_LENGTH (decl) >= len)\n     {\n-      machine_mode mode;\n+      scalar_int_mode mode;\n       unsigned int modesize;\n       const char *str;\n       HOST_WIDE_INT i;\n       int j, unit;\n       const char *prefix = function_mergeable_rodata_prefix ();\n       char *name = (char *) alloca (strlen (prefix) + 30);\n \n-      mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (decl)));\n+      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (TREE_TYPE (decl)));\n       modesize = GET_MODE_BITSIZE (mode);\n       if (modesize >= 8 && modesize <= 256\n \t  && (modesize & (modesize - 1)) == 0)\n@@ -4328,8 +4328,8 @@ narrowing_initializer_constant_valid_p (tree value, tree endtype, tree *cache)\n       tree inner = TREE_OPERAND (op0, 0);\n       if (inner == error_mark_node\n \t  || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))\n-\t  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0)))\n-\t      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (inner)))))\n+\t  || (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (op0)))\n+\t      > GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (inner)))))\n \tbreak;\n       op0 = inner;\n     }\n@@ -4340,8 +4340,8 @@ narrowing_initializer_constant_valid_p (tree value, tree endtype, tree *cache)\n       tree inner = TREE_OPERAND (op1, 0);\n       if (inner == error_mark_node\n \t  || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))\n-\t  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op1)))\n-\t      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (inner)))))\n+\t  || (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (op1)))\n+\t      > GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (inner)))))\n \tbreak;\n       op1 = inner;\n     }\n@@ -4766,7 +4766,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align,\n   if (TREE_CODE (exp) == NOP_EXPR\n       && POINTER_TYPE_P (TREE_TYPE (exp))\n       && targetm.addr_space.valid_pointer_mode\n-\t   (TYPE_MODE (TREE_TYPE (exp)),\n+\t   (SCALAR_INT_TYPE_MODE (TREE_TYPE (exp)),\n \t    TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)))))\n     {\n       tree saved_type = TREE_TYPE (exp);\n@@ -4776,7 +4776,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align,\n       while (TREE_CODE (exp) == NOP_EXPR\n \t     && POINTER_TYPE_P (TREE_TYPE (exp))\n \t     && targetm.addr_space.valid_pointer_mode\n-\t\t  (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t  (SCALAR_INT_TYPE_MODE (TREE_TYPE (exp)),\n \t\t   TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)))))\n \texp = TREE_OPERAND (exp, 0);\n "}]}