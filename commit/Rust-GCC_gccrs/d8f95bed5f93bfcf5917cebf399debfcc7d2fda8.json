{"sha": "d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhmOTViZWQ1ZjkzYmZjZjU5MTdjZWJmMzk5ZGViZmNjN2QyZmRhOA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-12-14T07:26:19Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-12-14T07:26:19Z"}, "message": "re PR target/13054 (compile/980310-3.f: insn does not satisfy its constraints)\n\n\tPR target/13054\n\t* pa-protos.h (indexed_memory_operand, borx_reg_operand,\n\tmove_dest_operand, move_src_operand): New protypes.\n\t(basereg_operand, move_operand, reg_or_nonsymb_mem_operand): Deleted.\n\t* pa.c (copy_reg_pointer, indexed_memory_operand, move_dest_operand,\n\tmove_src_operand): New functions.\n\t(basereg_operand, reg_or_nonsymb_mem_operand, move_operand): Delete.\n\t(reg_or_0_or_nonsymb_mem_operand): Return false for unscaled indexed\n\taddress until cse is not expected on targets with non-equivalent\n\tspace registers.\n\t(hppa_legitimize_address): Canonicalize unscaled indexed addresses\n\ton targets non-equivalent space registers.\n\t(emit_move_sequence): Break out indexed addresses from destination\n\toperand.  Similarly, break out unscaled indexed addresses from\n\tsource operand on targets with non-equivalent space registers.  Fix\n\tREG_POINTER flag when possible.  Mark register pointer when creating\n\tnew pointers.\n\t(print_operand): Handle unscaled index addresses.\n\t* pa.h (IS_INDEX_ADDR_P, IS_LO_SUM_DLT_ADDR_P): New macro subroutines\n\tfor EXTRA_CONSTRAINT.\n\t(EXTRA_CONSTRAINT): Rework to make more readable.\n\t(MODE_OK_FOR_SCALED_INDEXING_P, MODE_OK_FOR_UNSCALED_INDEXING_P): New\n\tsubroutines for GO_IF_LEGITIMATE_ADDRESS.\n\t(GO_IF_LEGITIMATE_ADDRESS): Rework using new subroutines.  Allow scaled\n\tand unscaled addresses.  Canonicalize unscaled indexed addresses on\n\ttargets with non-equivalent space registers.  Document issues in\n\thandling indexed address modes on PA-RISC.\n\t(PREDICATE_CODES): Update for new and deleted predicates.\n\t* pa.md (move_dest_operand, move_src_operand, indexed_memory_operand):\n\tUse new predicates in move patterns.\n\tAdd peephole2 patterns to optimize floating point stores.  Fix\n\tconstrain preferencing in move patterns.  Delete patterns for handling\n\tunscaled indexed memory loads.  Add missing load and store with\n\tbase-register modification patterns.  Correct SFmode floating point\n\tstore pattern.  Add missing zero extension loads.\n\nFrom-SVN: r74614", "tree": {"sha": "3112b57849d016c6c7ff338d03b3d70ac5b472fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3112b57849d016c6c7ff338d03b3d70ac5b472fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/comments", "author": null, "committer": null, "parents": [{"sha": "9ec31db31a833f6e5530387df6b13d559f2e50af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec31db31a833f6e5530387df6b13d559f2e50af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ec31db31a833f6e5530387df6b13d559f2e50af"}], "stats": {"total": 1818, "additions": 1287, "deletions": 531}, "files": [{"sha": "f43d14b3021adfff0453041013aa2792033fe103", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "patch": "@@ -1,3 +1,41 @@\n+2003-12-14  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/13054\n+\t* pa-protos.h (indexed_memory_operand, borx_reg_operand,\n+\tmove_dest_operand, move_src_operand): New protypes.\n+\t(basereg_operand, move_operand, reg_or_nonsymb_mem_operand): Deleted.\n+\t* pa.c (copy_reg_pointer, indexed_memory_operand, move_dest_operand,\n+\tmove_src_operand): New functions.\n+\t(basereg_operand, reg_or_nonsymb_mem_operand, move_operand): Delete.\n+\t(reg_or_0_or_nonsymb_mem_operand): Return false for unscaled indexed\n+\taddress until cse is not expected on targets with non-equivalent\n+\tspace registers.\n+\t(hppa_legitimize_address): Canonicalize unscaled indexed addresses\n+\ton targets non-equivalent space registers.\n+\t(emit_move_sequence): Break out indexed addresses from destination\n+\toperand.  Similarly, break out unscaled indexed addresses from\n+\tsource operand on targets with non-equivalent space registers.  Fix\n+\tREG_POINTER flag when possible.  Mark register pointer when creating\n+\tnew pointers.\n+\t(print_operand): Handle unscaled index addresses.\n+\t* pa.h (IS_INDEX_ADDR_P, IS_LO_SUM_DLT_ADDR_P): New macro subroutines\n+\tfor EXTRA_CONSTRAINT.\n+\t(EXTRA_CONSTRAINT): Rework to make more readable.\n+\t(MODE_OK_FOR_SCALED_INDEXING_P, MODE_OK_FOR_UNSCALED_INDEXING_P): New\n+\tsubroutines for GO_IF_LEGITIMATE_ADDRESS.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Rework using new subroutines.  Allow scaled\n+\tand unscaled addresses.  Canonicalize unscaled indexed addresses on\n+\ttargets with non-equivalent space registers.  Document issues in\n+\thandling indexed address modes on PA-RISC.\n+\t(PREDICATE_CODES): Update for new and deleted predicates.\n+\t* pa.md (move_dest_operand, move_src_operand, indexed_memory_operand):\n+\tUse new predicates in move patterns.\n+\tAdd peephole2 patterns to optimize floating point stores.  Fix\n+\tconstrain preferencing in move patterns.  Delete patterns for handling\n+\tunscaled indexed memory loads.  Add missing load and store with\n+\tbase-register modification patterns.  Correct SFmode floating point\n+\tstore pattern.  Add missing zero extension loads.\n+\n 2003-12-13  Steven Bosscher  <stevenb@suse.de>\n \n \t* ggc-zone.c (struct alloc_zone): Don't pre-declare, it already"}, {"sha": "9bf5e97e32cb7220ea5cdca081f7ab82c490d5e8", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "patch": "@@ -64,6 +64,7 @@ extern struct rtx_def *gen_cmp_fp (enum rtx_code, rtx, rtx);\n extern void hppa_encode_label (rtx);\n extern int arith11_operand (rtx, enum machine_mode);\n extern int adddi3_operand (rtx, enum machine_mode);\n+extern int indexed_memory_operand (rtx, enum machine_mode);\n extern int symbolic_expression_p (rtx);\n extern int symbolic_memory_operand (rtx, enum machine_mode);\n extern int pa_adjust_insn_length (rtx, int);\n@@ -73,16 +74,16 @@ extern int arith5_operand (rtx, enum machine_mode);\n extern int uint5_operand (rtx, enum machine_mode);\n extern int pic_label_operand (rtx, enum machine_mode);\n extern int plus_xor_ior_operator (rtx, enum machine_mode);\n-extern int basereg_operand (rtx, enum machine_mode);\n+extern int borx_reg_operand (rtx, enum machine_mode);\n extern int shadd_operand (rtx, enum machine_mode);\n extern int arith_operand (rtx, enum machine_mode);\n extern int read_only_operand (rtx, enum machine_mode);\n-extern int move_operand (rtx, enum machine_mode);\n+extern int move_dest_operand (rtx, enum machine_mode);\n+extern int move_src_operand (rtx, enum machine_mode);\n extern int and_operand (rtx, enum machine_mode);\n extern int ior_operand (rtx, enum machine_mode);\n extern int arith32_operand (rtx, enum machine_mode);\n extern int uint32_operand (rtx, enum machine_mode);\n-extern int reg_or_nonsymb_mem_operand (rtx, enum machine_mode);\n extern int reg_before_reload_operand (rtx, enum machine_mode);\n extern int reg_or_0_operand (rtx, enum machine_mode);\n extern int reg_or_0_or_nonsymb_mem_operand (rtx, enum machine_mode);"}, {"sha": "6cc3deb57e015d4858d1bb315d41b81bd65523c4", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 260, "deletions": 91, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "patch": "@@ -94,6 +94,7 @@ hppa_fpstore_bypass_p (rtx out_insn, rtx in_insn)\n #endif\n #endif\n \n+static void copy_reg_pointer (rtx, rtx);\n static int hppa_address_cost (rtx);\n static bool hppa_rtx_costs (rtx, int, int, int *);\n static inline rtx force_mode (enum machine_mode, rtx);\n@@ -381,6 +382,16 @@ pa_init_builtins (void)\n #endif\n }\n \n+/* If FROM is a probable pointer register, mark TO as a probable\n+   pointer register with the same pointer alignment as FROM.  */\n+\n+static void\n+copy_reg_pointer (rtx to, rtx from)\n+{\n+  if (REG_POINTER (from))\n+    mark_reg_pointer (to, REGNO_POINTER_ALIGN (REGNO (from)));\n+}\n+\n /* Return nonzero only if OP is a register of mode MODE,\n    or CONST0_RTX.  */\n int\n@@ -448,21 +459,6 @@ symbolic_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n }\n \n-/* Return 1 if the operand is either a register or a memory operand that is\n-   not symbolic.  */\n-\n-int\n-reg_or_nonsymb_mem_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (memory_operand (op, mode) && ! symbolic_memory_operand (op, mode))\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* Return 1 if the operand is either a register, zero, or a memory operand\n    that is not symbolic.  */\n \n@@ -475,10 +471,24 @@ reg_or_0_or_nonsymb_mem_operand (rtx op, enum machine_mode mode)\n   if (op == CONST0_RTX (mode))\n     return 1;\n \n-  if (memory_operand (op, mode) && ! symbolic_memory_operand (op, mode))\n-    return 1;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n \n-  return 0;\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  /* Until problems with management of the REG_POINTER flag are resolved,\n+     we need to delay creating move insns with unscaled indexed addresses\n+     until CSE is not expected.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (op, 0), 0))\n+      && REG_P (XEXP (XEXP (op, 0), 1)))\n+    return 0;\n+\n+  return (!symbolic_memory_operand (op, mode)\n+\t  && memory_address_p (mode, XEXP (op, 0)));\n }\n \n /* Return 1 if the operand is a register operand or a non-symbolic memory\n@@ -499,7 +509,7 @@ reg_before_reload_operand (rtx op, enum machine_mode mode)\n \n   if (reload_completed\n       && memory_operand (op, mode)\n-      && ! symbolic_memory_operand (op, mode))\n+      && !symbolic_memory_operand (op, mode))\n     return 1;\n \n   return 0;\n@@ -516,10 +526,54 @@ cint_ok_for_move (HOST_WIDE_INT intval)\n \t  || CONST_OK_FOR_LETTER_P (intval, 'K'));\n }\n \n-/* Accept anything that can be moved in one instruction into a general\n-   register.  */\n+/* Return 1 iff OP is an indexed memory operand.  */\n+int\n+indexed_memory_operand (rtx op, enum machine_mode mode)\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  /* Before reload, a (SUBREG (MEM...)) forces reloading into a register.  */\n+  if (reload_completed && GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  return (memory_address_p (mode, op) && IS_INDEX_ADDR_P (op));\n+}\n+\n+/* Accept anything that can be used as a destination operand for a\n+   move instruction.  We don't accept indexed memory operands since\n+   they are supported only for floating point stores.  */\n+int\n+move_dest_operand (rtx op, enum machine_mode mode)\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  return (memory_address_p (mode, op)\n+\t  && !IS_INDEX_ADDR_P (op)\n+\t  && !IS_LO_SUM_DLT_ADDR_P (op));\n+}\n+\n+/* Accept anything that can be used as a source operand for a move\n+   instruction.  */\n int\n-move_operand (rtx op, enum machine_mode mode)\n+move_src_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -530,41 +584,26 @@ move_operand (rtx op, enum machine_mode mode)\n   if (GET_CODE (op) == CONST_INT)\n     return cint_ok_for_move (INTVAL (op));\n \n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n+\n   if (GET_CODE (op) != MEM)\n     return 0;\n \n-  op = XEXP (op, 0);\n-\n-  /* We consider a LO_SUM DLT reference a move_operand now since it has\n-     been merged into the normal movsi/movdi patterns.  */\n-  if (GET_CODE (op) == LO_SUM\n-      && GET_CODE (XEXP (op, 0)) == REG\n-      && REG_OK_FOR_BASE_P (XEXP (op, 0))\n-      && GET_CODE (XEXP (op, 1)) == UNSPEC\n-      && GET_MODE (op) == Pmode)\n-    return 1;\n-\n-  /* Since move_operand is only used for source operands, we can always\n-     allow scaled indexing!  */\n-  if (! TARGET_DISABLE_INDEXING\n-      && GET_CODE (op) == PLUS\n-      && ((GET_CODE (XEXP (op, 0)) == MULT\n-\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n-\t   && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-\t   && INTVAL (XEXP (XEXP (op, 0), 1))\n-\t      == (HOST_WIDE_INT) GET_MODE_SIZE (mode)\n-\t   && GET_CODE (XEXP (op, 1)) == REG)\n-\t  || (GET_CODE (XEXP (op, 1)) == MULT\n-\t      &&GET_CODE (XEXP (XEXP (op, 1), 0)) == REG\n-\t      && GET_CODE (XEXP (XEXP (op, 1), 1)) == CONST_INT\n-\t      && INTVAL (XEXP (XEXP (op, 1), 1))\n-\t\t == (HOST_WIDE_INT) GET_MODE_SIZE (mode)\n-\t      && GET_CODE (XEXP (op, 0)) == REG)))\n-    return 1;\n+  /* Until problems with management of the REG_POINTER flag are resolved,\n+     we need to delay creating move insns with unscaled indexed addresses\n+     until CSE is not expected.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (op, 0), 0))\n+      && REG_P (XEXP (XEXP (op, 0), 1)))\n+    return 0;\n \n-  return memory_address_p (mode, op);\n+  return memory_address_p (mode, XEXP (op, 0));\n }\n \n /* Accept REG and any CONST_INT that can be moved in one instruction into a\n@@ -575,10 +614,7 @@ reg_or_cint_move_operand (rtx op, enum machine_mode mode)\n   if (register_operand (op, mode))\n     return 1;\n \n-  if (GET_CODE (op) == CONST_INT)\n-    return cint_ok_for_move (INTVAL (op));\n-\n-  return 0;\n+  return (GET_CODE (op) == CONST_INT && cint_ok_for_move (INTVAL (op)));\n }\n \n int\n@@ -831,6 +867,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \n \t So instead we just emit the raw set, which avoids the movXX\n \t expanders completely.  */\n+      mark_reg_pointer (reg, BITS_PER_UNIT);\n       emit_insn (gen_rtx_SET (VOIDmode, reg, orig));\n       current_function_uses_pic_offset_table = 1;\n       return reg;\n@@ -861,6 +898,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       current_function_uses_pic_offset_table = 1;\n       MEM_NOTRAP_P (pic_ref) = 1;\n       RTX_UNCHANGING_P (pic_ref) = 1;\n+      mark_reg_pointer (reg, BITS_PER_UNIT);\n       insn = emit_move_insn (reg, pic_ref);\n \n       /* Put a REG_EQUAL note on this insn, so that it can be optimized.  */\n@@ -885,7 +923,9 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t  orig = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n \t\t\t\t\t base == reg ? 0 : reg);\n \t}\n-      else abort ();\n+      else\n+\tabort ();\n+\n       if (GET_CODE (orig) == CONST_INT)\n \t{\n \t  if (INT_14_BITS (orig))\n@@ -895,6 +935,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       pic_ref = gen_rtx_PLUS (Pmode, base, orig);\n       /* Likewise, should we set special REG_NOTEs here?  */\n     }\n+\n   return pic_ref;\n }\n \n@@ -955,6 +996,18 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n {\n   rtx orig = x;\n \n+  /* We need to canonicalize the order of operands in unscaled indexed\n+     addresses since the code that checks if an address is valid doesn't\n+     always try both orders.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && GET_CODE (x) == PLUS\n+      && GET_MODE (x) == Pmode\n+      && REG_P (XEXP (x, 0))\n+      && REG_P (XEXP (x, 1))\n+      && REG_POINTER (XEXP (x, 0))\n+      && !REG_POINTER (XEXP (x, 1)))\n+    return gen_rtx_PLUS (Pmode, XEXP (x, 1), XEXP (x, 0));\n+\n   if (flag_pic)\n     return legitimize_pic_address (x, mode, gen_reg_rtx (Pmode));\n \n@@ -1423,6 +1476,36 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n   register rtx operand1 = operands[1];\n   register rtx tem;\n \n+  /* We can only handle indexed addresses in the destination operand\n+     of floating point stores.  Thus, we need to break out indexed\n+     addresses from the destination operand.  */\n+  if (GET_CODE (operand0) == MEM && IS_INDEX_ADDR_P (XEXP (operand0, 0)))\n+    {\n+      /* This is only safe up to the beginning of life analysis.  */\n+      if (no_new_pseudos)\n+\tabort ();\n+\n+      tem = copy_to_mode_reg (Pmode, XEXP (operand0, 0));\n+      operand0 = replace_equiv_address (operand0, tem);\n+    }\n+\n+  /* On targets with non-equivalent space registers, break out unscaled\n+     indexed addresses from the source operand before the final CSE.\n+     We have to do this because the REG_POINTER flag is not correctly\n+     carried through various optimization passes and CSE may substitute\n+     a pseudo without the pointer set for one with the pointer set.  As\n+     a result, we loose various opportunites to create insns with\n+     unscaled indexed addresses.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (operand1) == MEM\n+      && GET_CODE (XEXP (operand1, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (operand1, 0), 0))\n+      && REG_P (XEXP (XEXP (operand1, 0), 1)))\n+    operand1\n+      = replace_equiv_address (operand1,\n+\t\t\t       copy_to_mode_reg (Pmode, XEXP (operand1, 0)));\n+\n   if (scratch_reg\n       && reload_in_progress && GET_CODE (operand0) == REG\n       && REGNO (operand0) >= FIRST_PSEUDO_REGISTER)\n@@ -1461,6 +1544,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n       && ((tem = find_replacement (&XEXP (operand0, 0)))\n \t  != XEXP (operand0, 0)))\n     operand0 = gen_rtx_MEM (GET_MODE (operand0), tem);\n+\n   if (scratch_reg && reload_in_progress && GET_CODE (operand1) == MEM\n       && ((tem = find_replacement (&XEXP (operand1, 0)))\n \t  != XEXP (operand1, 0)))\n@@ -1471,7 +1555,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n      (subreg (mem (addr))) cases.  */\n   if (fp_reg_operand (operand0, mode)\n       && ((GET_CODE (operand1) == MEM\n-\t   && ! memory_address_p (DFmode, XEXP (operand1, 0)))\n+\t   && !memory_address_p (DFmode, XEXP (operand1, 0)))\n \t  || ((GET_CODE (operand1) == SUBREG\n \t       && GET_CODE (XEXP (operand1, 0)) == MEM\n \t       && !memory_address_p (DFmode, XEXP (XEXP (operand1, 0), 0)))))\n@@ -1490,10 +1574,11 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n       if (!memory_address_p (Pmode, XEXP (operand1, 0)))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\n-\t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),\n-\t\t\t\t\t\t       Pmode,\n-\t\t\t\t\t\t       XEXP (XEXP (operand1, 0), 0),\n-\t\t\t\t\t\t       scratch_reg));\n+\t  emit_move_insn (scratch_reg,\n+\t\t\t  gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),\n+\t\t\t\t\t  Pmode,\n+\t\t\t\t\t  XEXP (XEXP (operand1, 0), 0),\n+\t\t\t\t\t  scratch_reg));\n \t}\n       else\n \temit_move_insn (scratch_reg, XEXP (operand1, 0));\n@@ -1506,7 +1591,8 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t\t&& ! memory_address_p (DFmode, XEXP (operand0, 0)))\n \t       || ((GET_CODE (operand0) == SUBREG)\n \t\t   && GET_CODE (XEXP (operand0, 0)) == MEM\n-\t\t   && !memory_address_p (DFmode, XEXP (XEXP (operand0, 0), 0))))\n+\t\t   && !memory_address_p (DFmode,\n+\t\t\t   \t\t XEXP (XEXP (operand0, 0), 0))))\n \t   && scratch_reg)\n     {\n       if (GET_CODE (operand0) == SUBREG)\n@@ -1618,7 +1704,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n       emit_move_insn (operand0, scratch_reg);\n       return 1;\n     }\n-  /* Handle most common case: storing into a register.  */\n+  /* Handle the most common case: storing into a register.  */\n   else if (register_operand (operand0, mode))\n     {\n       if (register_operand (operand1, mode)\n@@ -1630,7 +1716,67 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t  /* Only `general_operands' can come here, so MEM is ok.  */\n \t  || GET_CODE (operand1) == MEM)\n \t{\n-\t  /* Run this case quickly.  */\n+\t  /* Various sets are created during RTL generation which don't\n+\t     have the REG_POINTER flag correctly set.  After the CSE pass,\n+\t     instruction recognition can fail if we don't consistently\n+\t     set this flag when performing register copies.  This should\n+\t     also improve the opportunities for creating insns that use\n+\t     unscaled indexing.  */\n+\t  if (REG_P (operand0) && REG_P (operand1))\n+\t    {\n+\t      if (REG_POINTER (operand1)\n+\t\t  && !REG_POINTER (operand0)\n+\t\t  && !HARD_REGISTER_P (operand0))\n+\t\tcopy_reg_pointer (operand0, operand1);\n+\t      else if (REG_POINTER (operand0)\n+\t\t       && !REG_POINTER (operand1)\n+\t\t       && !HARD_REGISTER_P (operand1))\n+\t\tcopy_reg_pointer (operand1, operand0);\n+\t    }\n+\t  \n+\t  /* When MEMs are broken out, the REG_POINTER flag doesn't\n+\t     get set.  In some cases, we can set the REG_POINTER flag\n+\t     from the declaration for the MEM.  */\n+\t  if (REG_P (operand0)\n+\t      && GET_CODE (operand1) == MEM\n+\t      && !REG_POINTER (operand0))\n+\t    {\n+\t      tree decl = MEM_EXPR (operand1);\n+\n+\t      /* Set the register pointer flag and register alignment\n+\t\t if the declaration for this memory reference is a\n+\t\t pointer type.  Fortran indirect argument references\n+\t\t are ignored.  */\n+\t      if (decl\n+\t\t  && !(flag_argument_noalias > 1\n+\t\t       && TREE_CODE (decl) == INDIRECT_REF\n+\t\t       && TREE_CODE (TREE_OPERAND (decl, 0)) == PARM_DECL))\n+\t\t{\n+\t\t  tree type;\n+\n+\t\t  /* If this is a COMPONENT_REF, use the FIELD_DECL from\n+\t\t     tree operand 1.  */\n+\t\t  if (TREE_CODE (decl) == COMPONENT_REF)\n+\t\t    decl = TREE_OPERAND (decl, 1);\n+\n+\t\t  type = TREE_TYPE (decl);\n+\t\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t\t    type = get_inner_array_type (type);\n+\n+\t\t  if (POINTER_TYPE_P (type))\n+\t\t    {\n+\t\t      int align;\n+\n+\t\t      type = TREE_TYPE (type);\n+\t\t      /* Using TYPE_ALIGN_OK is rather conservative as\n+\t\t\t only the ada frontend actually sets it.  */\n+\t\t      align = (TYPE_ALIGN_OK (type) ? TYPE_ALIGN (type)\n+\t\t\t       : BITS_PER_UNIT);\n+\t\t      mark_reg_pointer (operand0, align);\n+\t\t    }\n+\t\t}\n+\t    }\n+\n \t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operand1));\n \t  return 1;\n \t}\n@@ -1777,6 +1923,8 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t      else\n \t\t{\n \t\t  operands[1] = legitimize_pic_address (operand1, mode, temp);\n+\t\t  if (REG_P (operand0) && REG_P (operands[1]))\n+\t\t    copy_reg_pointer (operand0, operands[1]);\n \t\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operands[1]));\n \t\t}\n \t    }\n@@ -1804,9 +1952,10 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t\t Don't mark hard registers though.  That loses.  */\n \t      if (GET_CODE (operand0) == REG\n \t\t  && REGNO (operand0) >= FIRST_PSEUDO_REGISTER)\n-\t\tREG_POINTER (operand0) = 1;\n+\t\tmark_reg_pointer (operand0, BITS_PER_UNIT);\n \t      if (REGNO (temp) >= FIRST_PSEUDO_REGISTER)\n-\t\tREG_POINTER (temp) = 1;\n+\t\tmark_reg_pointer (temp, BITS_PER_UNIT);\n+\n \t      if (ishighonly)\n \t\tset = gen_rtx_SET (mode, operand0, temp);\n \t      else\n@@ -4829,8 +4978,14 @@ print_operand (FILE *file, rtx x, int code)\n \t    fputs (\",ma\", file);\n \t  break;\n \tcase PLUS:\n-\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n-\t      || GET_CODE (XEXP (XEXP (x, 0), 1)) == MULT)\n+\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == REG)\n+\t    {\n+\t      if (ASSEMBLER_DIALECT == 0)\n+\t\tfputs (\"x\", file);\n+\t    }\n+\t  else if (GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n+\t\t   || GET_CODE (XEXP (XEXP (x, 0), 1)) == MULT)\n \t    {\n \t      if (ASSEMBLER_DIALECT == 0)\n \t\tfputs (\"x,s\", file);\n@@ -4905,20 +5060,33 @@ print_operand (FILE *file, rtx x, int code)\n           base = XEXP (XEXP (x, 0), 0);\n \t  fprintf (file, \"%d(%s)\", size, reg_names [REGNO (base)]);\n \t  break;\n-\tdefault:\n-\t  if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT)\n+\tcase PLUS:\n+\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT)\n \t    fprintf (file, \"%s(%s)\",\n \t\t     reg_names [REGNO (XEXP (XEXP (XEXP (x, 0), 0), 0))],\n \t\t     reg_names [REGNO (XEXP (XEXP (x, 0), 1))]);\n-\t  else if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == MULT)\n+\t  else if (GET_CODE (XEXP (XEXP (x, 0), 1)) == MULT)\n \t    fprintf (file, \"%s(%s)\",\n \t\t     reg_names [REGNO (XEXP (XEXP (XEXP (x, 0), 1), 0))],\n \t\t     reg_names [REGNO (XEXP (XEXP (x, 0), 0))]);\n+\t  else if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == REG)\n+\t    {\n+\t      /* Because the REG_POINTER flag can get lost during reload,\n+\t\t GO_IF_LEGITIMATE_ADDRESS canonicalizes the order of the\n+\t\t index and base registers in the combined move patterns.  */\n+\t      rtx base = XEXP (XEXP (x, 0), 1);\n+\t      rtx index = XEXP (XEXP (x, 0), 0);\n+\n+\t      fprintf (file, \"%s(%s)\",\n+\t\t       reg_names [REGNO (index)], reg_names [REGNO (base)]);\n+\t    }\n \t  else\n \t    output_address (XEXP (x, 0));\n \t  break;\n+\tdefault:\n+\t  output_address (XEXP (x, 0));\n+\t  break;\n \t}\n     }\n   else\n@@ -7844,32 +8012,33 @@ shadd_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return (GET_CODE (op) == CONST_INT && shadd_constant_p (INTVAL (op)));\n }\n \n-/* Return 1 if OP is valid as a base register in a reg + reg address.  */\n+/* Return 1 if OP is valid as a base or index register in a\n+   REG+REG address.  */\n \n int\n-basereg_operand (rtx op, enum machine_mode mode)\n+borx_reg_operand (rtx op, enum machine_mode mode)\n {\n-  /* cse will create some unscaled indexed addresses, however; it\n-     generally isn't a win on the PA, so avoid creating unscaled\n-     indexed addresses until after cse is finished.  */\n-  if (!cse_not_expected)\n+  if (GET_CODE (op) != REG)\n     return 0;\n \n-  /* Allow any register when TARGET_NO_SPACE_REGS is in effect since\n-     we don't have to worry about the braindamaged implicit space\n-     register selection from the basereg.  */\n-  if (TARGET_NO_SPACE_REGS)\n-    return (GET_CODE (op) == REG);\n+  /* We must reject virtual registers as the only expressions that\n+     can be instantiated are REG and REG+CONST.  */\n+  if (op == virtual_incoming_args_rtx\n+      || op == virtual_stack_vars_rtx\n+      || op == virtual_stack_dynamic_rtx\n+      || op == virtual_outgoing_args_rtx\n+      || op == virtual_cfa_rtx)\n+    return 0;\n \n   /* While it's always safe to index off the frame pointer, it's not\n-     always profitable, particularly when the frame pointer is being\n-     eliminated.  */\n-  if (! flag_omit_frame_pointer && op == frame_pointer_rtx)\n-    return 1;\n+     profitable to do so when the frame pointer is being eliminated.  */\n+  if (!reload_completed\n+      && flag_omit_frame_pointer\n+      && !current_function_calls_alloca\n+      && op == frame_pointer_rtx)\n+    return 0;\n \n-  return (GET_CODE (op) == REG\n-          && REG_POINTER (op)\n-          && register_operand (op, mode));\n+  return register_operand (op, mode);\n }\n \n /* Return 1 if this operand is anything other than a hard register.  */"}, {"sha": "5c33a3b2abb2c0562ec748f301e58a68d7af356c", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 226, "deletions": 158, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "patch": "@@ -641,9 +641,9 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n    in some cases it is preferable to use a more restrictive class.  */\n #define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n \n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly\n-   NO_REGS is returned. \n+/* Return the register class of a scratch register needed to copy\n+   IN into a register in CLASS in MODE, or a register in CLASS in MODE\n+   to IN.  If it can be done directly NO_REGS is returned. \n \n   Avoid doing any work for the common case calls.  */\n \n@@ -1199,83 +1199,87 @@ extern int may_call_alloca;\n \t     || cint_ok_for_move (INTVAL (X))))\t\t\t\\\n    && !function_label_operand (X, VOIDmode))\n \n-/* Subroutine for EXTRA_CONSTRAINT.\n+/* Subroutines for EXTRA_CONSTRAINT.\n \n    Return 1 iff OP is a pseudo which did not get a hard register and\n    we are running the reload pass.  */\n-\n #define IS_RELOADING_PSEUDO_P(OP) \\\n   ((reload_in_progress\t\t\t\t\t\\\n     && GET_CODE (OP) == REG\t\t\t\t\\\n     && REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n     && reg_renumber [REGNO (OP)] < 0))\n \n+/* Return 1 iff OP is a scaled or unscaled index address.  */\n+#define IS_INDEX_ADDR_P(OP) \\\n+  (GET_CODE (OP) == PLUS\t\t\t\t\\\n+   && GET_MODE (OP) == Pmode\t\t\t\t\\\n+   && (GET_CODE (XEXP (OP, 0)) == MULT\t\t\t\\\n+       || GET_CODE (XEXP (OP, 1)) == MULT\t\t\\\n+       || (REG_P (XEXP (OP, 0))\t\t\t\t\\\n+\t   && REG_P (XEXP (OP, 1)))))\n+\n+/* Return 1 iff OP is a LO_SUM DLT address.  */\n+#define IS_LO_SUM_DLT_ADDR_P(OP) \\\n+  (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n+   && GET_MODE (OP) == Pmode\t\t\t\t\\\n+   && REG_P (XEXP (OP, 0))\t\t\t\t\\\n+   && REG_OK_FOR_BASE_P (XEXP (OP, 0))\t\t\t\\\n+   && GET_CODE (XEXP (OP, 1)) == UNSPEC)\n+\n /* Optional extra constraints for this machine. Borrowed from sparc.h.\n \n-   For the HPPA, `Q' means that this is a memory operand but not a\n-   symbolic memory operand.  Note that an unassigned pseudo register\n-   is such a memory operand.  Needed because reload will generate\n-   these things in insns and then not re-recognize the insns, causing\n-   constrain_operands to fail.\n+   `A' is a LO_SUM DLT memory operand.\n+\n+   `Q' is any memory operand that isn't a symbolic, indexed or lo_sum\n+       memory operand.  Note that an unassigned pseudo register is such a\n+       memory operand.  Needed because reload will generate these things\n+       and then not re-recognize the insn, causing constrain_operands to\n+       fail.\n \n-   `R' is used for scaled indexed addresses.\n+   `R' is a scaled/unscaled indexed memory operand.\n \n    `S' is the constant 31.\n \n-   `T' is for fp loads and stores.  */\n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q' ?\t\t\t\t\t\t\\\n-   (IS_RELOADING_PSEUDO_P (OP)\t\t\t\t\\\n-    || (GET_CODE (OP) == MEM\t\t\t\t\\\n-\t&& (memory_address_p (GET_MODE (OP), XEXP (OP, 0))\\\n-\t    || reload_in_progress)\t\t\t\\\n-\t&& ! symbolic_memory_operand (OP, VOIDmode)\t\\\n-        && !(GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n-\t     && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\\\n-\t\t || GET_CODE (XEXP (XEXP (OP, 0), 1)) == MULT))))\\\n-   : ((C) == 'R' ?\t\t\t\t\t\\\n-     (GET_CODE (OP) == MEM\t\t\t\t\\\n-      && GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n-      && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\t\\\n-\t  || GET_CODE (XEXP (XEXP (OP, 0), 1)) == MULT)\t\\\n-      && (move_operand (OP, GET_MODE (OP))\t\t\\\n-\t  || memory_address_p (GET_MODE (OP), XEXP (OP, 0))\\\n-\t  || reload_in_progress))\t\t\t\\\n-   : ((C) == 'T' ? \t\t\t\t\t\\\n-      (GET_CODE (OP) == MEM\t\t\t\t\\\n-       /* Using DFmode forces only short displacements\t\\\n-\t  to be recognized as valid in reg+d addresses. \\\n-\t  However, this is not necessary for PA2.0 since\\\n-\t  it has long FP loads/stores.\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-\t  FIXME: the ELF32 linker clobbers the LSB of\t\\\n-\t  the FP register number in {fldw,fstw} insns.\t\\\n-\t  Thus, we only allow long FP loads/stores on\t\\\n-\t  TARGET_64BIT.  */\t\t\t\t\\\n-       && memory_address_p ((TARGET_PA_20\t\t\\\n-\t\t\t     && !TARGET_ELF32\t\t\\\n-\t\t\t     ? GET_MODE (OP)\t\t\\\n-\t\t\t     : DFmode),\t\t\t\\\n-\t\t\t    XEXP (OP, 0))\t\t\\\n-       && !(GET_CODE (XEXP (OP, 0)) == LO_SUM\t\t\\\n-\t    && GET_CODE (XEXP (XEXP (OP, 0), 0)) == REG \\\n-\t    && REG_OK_FOR_BASE_P (XEXP (XEXP (OP, 0), 0))\\\n-\t    && GET_CODE (XEXP (XEXP (OP, 0), 1)) == UNSPEC\\\n-\t    && GET_MODE (XEXP (OP, 0)) == Pmode)\t\\\n-       && !(GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n-\t    && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\\\n-\t\t|| GET_CODE (XEXP (XEXP (OP, 0), 1)) == MULT)))\\\n-   : ((C) == 'U' ?\t\t\t\t\t\\\n-      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 63)\t\\\n-   : ((C) == 'A' ?\t\t\t\t\t\\\n-      (GET_CODE (OP) == MEM\t\t\t\t\\\n-       && GET_CODE (XEXP (OP, 0)) == LO_SUM\t\t\\\n-       && GET_CODE (XEXP (XEXP (OP, 0), 0)) == REG\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (XEXP (OP, 0), 0))\t\\\n-       && GET_CODE (XEXP (XEXP (OP, 0), 1)) == UNSPEC\t\t\\\n-       && GET_MODE (XEXP (OP, 0)) == Pmode)\t\t\t\\\n-   : ((C) == 'S' ?\t\t\t\t\t\\\n-      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 31) : 0))))))\n+   `T' is for fp loads and stores.\n+\n+   `U' is the constant 63.  */\n+\n+#define EXTRA_CONSTRAINT(OP, C) \\\n+  ((C) == 'Q' ?\t\t\t\t\t\t\t\t\\\n+   (IS_RELOADING_PSEUDO_P (OP)\t\t\t\t\t\t\\\n+    || (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n+\t&& (reload_in_progress\t\t\t\t\t\t\\\n+\t    || memory_address_p (GET_MODE (OP), XEXP (OP, 0)))\t\t\\\n+\t&& !symbolic_memory_operand (OP, VOIDmode)\t\t\t\\\n+\t&& !IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n+\t&& !IS_INDEX_ADDR_P (XEXP (OP, 0))))\t\t\t\t\\\n+   : ((C) == 'A' ?\t\t\t\t\t\t\t\\\n+      (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n+       && IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0)))\t\t\t\t\\\n+   : ((C) == 'R' ?\t\t\t\t\t\t\t\\\n+      (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n+       && IS_INDEX_ADDR_P (XEXP (OP, 0)))\t\t\t\t\\\n+   : ((C) == 'T' ? \t\t\t\t\t\t\t\\\n+      (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n+       && !IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n+       && !IS_INDEX_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n+       /* Using DFmode forces only short displacements\t\t\t\\\n+\t  to be recognized as valid in reg+d addresses. \t\t\\\n+\t  However, this is not necessary for PA2.0 since\t\t\\\n+\t  it has long FP loads/stores.\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  FIXME: the ELF32 linker clobbers the LSB of\t\t\t\\\n+\t  the FP register number in {fldw,fstw} insns.\t\t\t\\\n+\t  Thus, we only allow long FP loads/stores on\t\t\t\\\n+\t  TARGET_64BIT.  */\t\t\t\t\t\t\\\n+       && memory_address_p ((TARGET_PA_20 && !TARGET_ELF32\t\t\\\n+\t\t\t     ? GET_MODE (OP)\t\t\t\t\\\n+\t\t\t     : DFmode),\t\t\t\t\t\\\n+\t\t\t    XEXP (OP, 0)))\t\t\t\t\\\n+   : ((C) == 'S' ?\t\t\t\t\t\t\t\\\n+      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 31)\t\t\t\\\n+   : ((C) == 'U' ?\t\t\t\t\t\t\t\\\n+      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 63) : 0))))))\n \t\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -1311,16 +1315,53 @@ extern int may_call_alloca;\n \n #endif\n \f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On the HP-PA, the actual legitimate addresses must be\n-   REG+REG, REG+(REG*SCALE) or REG+SMALLINT.\n-   But we can treat a SYMBOL_REF as legitimate if it is part of this\n-   function's constant-pool, because such addresses can actually\n-   be output as REG+SMALLINT. \n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n+   valid memory address for an instruction.  The MODE argument is the\n+   machine mode for the MEM expression that wants to use this address.\n+\n+   On HP PA-RISC, the legitimate address forms are REG+SMALLINT,\n+   REG+REG, and REG+(REG*SCALE).  The indexed address forms are only\n+   available with floating point loads and stores, and integer loads.\n+   We get better code by allowing indexed addresses in the initial\n+   RTL generation.\n+\n+   The acceptance of indexed addresses as legitimate implies that we\n+   must provide patterns for doing indexed integer stores, or the move\n+   expanders must force the address of an indexed store to a register.\n+   We have adopted the latter approach.\n+   \n+   Another function of GO_IF_LEGITIMATE_ADDRESS is to ensure that\n+   the base register is a valid pointer for indexed instructions.\n+   On targets that have non-equivalent space registers, we have to\n+   know at the time of assembler output which register in a REG+REG\n+   pair is the base register.  The REG_POINTER flag is sometimes lost\n+   in reload and the following passes, so it can't be relied on during\n+   code generation.  Thus, we either have to canonicalize the order\n+   of the registers in REG+REG indexed addresses, or treat REG+REG\n+   addresses separately and provide patterns for both permutations.\n+\n+   The latter approach requires several hundred additional lines of\n+   code in pa.md.  The downside to canonicalizing is that a PLUS\n+   in the wrong order can't combine to form to make a scaled indexed\n+   memory operand.  As we won't need to canonicalize the operands if\n+   the REG_POINTER lossage can be fixed, it seems better canonicalize.\n+\n+   We initially break out scaled indexed addresses in canonical order\n+   in emit_move_sequence.  LEGITIMIZE_ADDRESS also canonicalizes\n+   scaled indexed addresses during RTL generation.  However, fold_rtx\n+   has its own opinion on how the operands of a PLUS should be ordered.\n+   If one of the operands is equivalent to a constant, it will make\n+   that operand the second operand.  As the base register is likely to\n+   be equivalent to a SYMBOL_REF, we have made it the second operand.\n+\n+   GO_IF_LEGITIMATE_ADDRESS accepts REG+REG as legitimate when the\n+   operands are in the order INDEX+BASE on targets with non-equivalent\n+   space registers, and in any order on targets with equivalent space\n+   registers.  It accepts both MULT+BASE and BASE+MULT for scaled indexing.\n+\n+   We treat a SYMBOL_REF as legitimate if it is part of the current\n+   function's constant-pool, because such addresses can actually be\n+   output as REG+SMALLINT. \n \n    Note we only allow 5 bit immediates for access to a constant address;\n    doing so avoids losing for loading/storing a FP register at an address\n@@ -1338,87 +1379,114 @@ extern int may_call_alloca;\n #define VAL_14_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) + 0x2000 < 0x4000)\n #define INT_14_BITS(X) VAL_14_BITS_P (INTVAL (X))\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{\t\t\t\t\t\t\t\\\n-  if ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\\\n+/* These are the modes that we allow for scaled indexing.  */\n+#define MODE_OK_FOR_SCALED_INDEXING_P(MODE) \\\n+  ((TARGET_64BIT && (MODE) == DImode)\t\t\t\t\t\\\n+   || (MODE) == SImode\t\t\t\t\t\t\t\\\n+   || (MODE) == HImode\t\t\t\t\t\t\t\\\n+   || (!TARGET_SOFT_FLOAT && ((MODE) == DFmode || (MODE) == SFmode)))\n+\n+/* These are the modes that we allow for unscaled indexing.  */\n+#define MODE_OK_FOR_UNSCALED_INDEXING_P(MODE) \\\n+  ((TARGET_64BIT && (MODE) == DImode)\t\t\t\t\t\\\n+   || (MODE) == SImode\t\t\t\t\t\t\t\\\n+   || (MODE) == HImode\t\t\t\t\t\t\t\\\n+   || (MODE) == QImode\t\t\t\t\t\t\t\\\n+   || (!TARGET_SOFT_FLOAT && ((MODE) == DFmode || (MODE) == SFmode)))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n       || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_DEC\t\t\\\n \t   || GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_INC)\t\\\n-\t  && REG_P (XEXP (X, 0))\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 0))))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      rtx base = 0, index = 0;\t\t\t\t\\\n-      if (REG_P (XEXP (X, 0))\t\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n-\tbase = XEXP (X, 0), index = XEXP (X, 1);\t\\\n-      else if (REG_P (XEXP (X, 1))\t\t\t\\\n-\t       && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\\\n-\tbase = XEXP (X, 1), index = XEXP (X, 0);\t\\\n-      if (base != 0)\t\t\t\t\t\\\n-\tif (GET_CODE (index) == CONST_INT\t\t\\\n-\t    && ((INT_14_BITS (index)\t\t\t\\\n-\t\t && (TARGET_SOFT_FLOAT\t\t\t\\\n-\t\t     || (TARGET_PA_20\t\t\t\\\n-\t\t\t && ((MODE == SFmode\t\t\\\n-\t\t\t      && (INTVAL (index) % 4) == 0)\\\n-\t\t\t     || (MODE == DFmode\t\t\\\n-\t\t\t\t && (INTVAL (index) % 8) == 0)))\\\n-\t\t     || ((MODE) != SFmode && (MODE) != DFmode))) \\\n-\t\t|| INT_5_BITS (index)))\t\t\t\\\n-\t  goto ADDR;\t\t\t\t\t\\\n-      if (! TARGET_SOFT_FLOAT\t\t\t\t\\\n-\t  && ! TARGET_DISABLE_INDEXING\t\t\t\\\n-\t  && base\t\t\t\t\t\\\n-\t  && ((MODE) == SFmode || (MODE) == DFmode)\t\\\n-\t  && GET_CODE (index) == MULT\t\t\t\\\n-\t  && GET_CODE (XEXP (index, 0)) == REG\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (index, 0))\t\\\n-\t  && GET_CODE (XEXP (index, 1)) == CONST_INT\t\\\n-\t  && INTVAL (XEXP (index, 1)) == ((MODE) == SFmode ? 4 : 8))\\\n-\tgoto ADDR;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == LO_SUM\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n-\t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n-\t   && CONSTANT_P (XEXP (X, 1))\t\t\t\\\n-\t   && (TARGET_SOFT_FLOAT\t\t\t\\\n-\t       /* We can allow symbolic LO_SUM addresses\\\n-\t\t  for PA2.0.  */\t\t\t\\\n-\t       || (TARGET_PA_20\t\t\t\t\\\n-\t\t   && !TARGET_ELF32\t\t\t\\\n-\t           && GET_CODE (XEXP (X, 1)) != CONST_INT)\\\n-\t       || ((MODE) != SFmode\t\t\t\\\n-\t\t   && (MODE) != DFmode)))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == LO_SUM\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == SUBREG\t\t\\\n-\t   && GET_CODE (SUBREG_REG (XEXP (X, 0))) == REG\\\n-\t   && REG_OK_FOR_BASE_P (SUBREG_REG (XEXP (X, 0)))\\\n-\t   && CONSTANT_P (XEXP (X, 1))\t\t\t\\\n-\t   && (TARGET_SOFT_FLOAT\t\t\t\\\n-\t       /* We can allow symbolic LO_SUM addresses\\\n-\t\t  for PA2.0.  */\t\t\t\\\n-\t       || (TARGET_PA_20\t\t\t\t\\\n-\t\t   && !TARGET_ELF32\t\t\t\\\n-\t           && GET_CODE (XEXP (X, 1)) != CONST_INT)\\\n-\t       || ((MODE) != SFmode\t\t\t\\\n-\t\t   && (MODE) != DFmode)))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == LABEL_REF\t\t\t\\\n-\t   || (GET_CODE (X) == CONST_INT\t\t\\\n-\t       && INT_5_BITS (X)))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  /* Needed for -fPIC */\t\t\t\t\\\n-  else if (GET_CODE (X) == LO_SUM\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG             \\\n-\t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n-\t   && GET_CODE (XEXP (X, 1)) == UNSPEC\t\t\\\n-\t   && (TARGET_SOFT_FLOAT\t\t\t\\\n-\t       || (TARGET_PA_20\t&& !TARGET_ELF32)\t\\\n-\t       || ((MODE) != SFmode\t\t\t\\\n-\t\t   && (MODE) != DFmode)))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n+\t  && REG_P (XEXP (X, 0))\t\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0))))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx base = 0, index = 0;\t\t\t\t\t\t\\\n+      if (REG_P (XEXP (X, 1))\t\t\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\t\t\\\n+\tbase = XEXP (X, 1), index = XEXP (X, 0);\t\t\t\\\n+      else if (REG_P (XEXP (X, 0))\t\t\t\t\t\\\n+\t       && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n+\tbase = XEXP (X, 0), index = XEXP (X, 1);\t\t\t\\\n+      if (base\t\t\t\t\t\t\t\t\\\n+\t  && GET_CODE (index) == CONST_INT\t\t\t\t\\\n+\t  && ((INT_14_BITS (index)\t\t\t\t\t\\\n+\t       && (TARGET_SOFT_FLOAT\t\t\t\t\t\\\n+\t\t   || (TARGET_PA_20\t\t\t\t\t\\\n+\t\t       && ((MODE == SFmode\t\t\t\t\\\n+\t\t\t    && (INTVAL (index) % 4) == 0)\t\t\\\n+\t\t\t   || (MODE == DFmode\t\t\t\t\\\n+\t\t\t       && (INTVAL (index) % 8) == 0)))\t\t\\\n+\t\t   || ((MODE) != SFmode && (MODE) != DFmode)))\t\t\\\n+\t       || INT_5_BITS (index)))\t\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+      if (!TARGET_DISABLE_INDEXING\t\t\t\t\t\\\n+\t  /* Only accept the \"canonical\" INDEX+BASE operand order\t\\\n+\t     on targets with non-equivalent space registers.  */\t\\\n+\t  && (TARGET_NO_SPACE_REGS\t\t\t\t\t\\\n+\t      ? (base && REG_P (index))\t\t\t\t\t\\\n+\t      : (base == XEXP (X, 1) && REG_P (index)\t\t\t\\\n+\t\t && REG_POINTER (base) && !REG_POINTER (index)))\t\\\n+\t  && MODE_OK_FOR_UNSCALED_INDEXING_P (MODE)\t\t\t\\\n+\t  && REG_OK_FOR_INDEX_P (index)\t\t\t\t\t\\\n+\t  && borx_reg_operand (base, Pmode)\t\t\t\t\\\n+\t  && borx_reg_operand (index, Pmode))\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+      if (!TARGET_DISABLE_INDEXING\t\t\t\t\t\\\n+\t  && base\t\t\t\t\t\t\t\\\n+\t  && GET_CODE (index) == MULT\t\t\t\t\t\\\n+\t  && MODE_OK_FOR_SCALED_INDEXING_P (MODE)\t\t\t\\\n+\t  && REG_P (XEXP (index, 0))\t\t\t\t\t\\\n+\t  && GET_MODE (XEXP (index, 0)) == Pmode\t\t\t\\\n+\t  && REG_OK_FOR_INDEX_P (XEXP (index, 0))\t\t\t\\\n+\t  && GET_CODE (XEXP (index, 1)) == CONST_INT\t\t\t\\\n+\t  && INTVAL (XEXP (index, 1))\t\t\t\t\t\\\n+\t     == (HOST_WIDE_INT) GET_MODE_SIZE (MODE)\t\t\t\\\n+\t  && borx_reg_operand (base, Pmode))\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+\t   && CONSTANT_P (XEXP (X, 1))\t\t\t\t\t\\\n+\t   && (TARGET_SOFT_FLOAT\t\t\t\t\t\\\n+\t       /* We can allow symbolic LO_SUM addresses for PA2.0.  */\t\\\n+\t       || (TARGET_PA_20\t\t\t\t\t\t\\\n+\t\t   && !TARGET_ELF32\t\t\t\t\t\\\n+\t           && GET_CODE (XEXP (X, 1)) != CONST_INT)\t\t\\\n+\t       || ((MODE) != SFmode\t\t\t\t\t\\\n+\t\t   && (MODE) != DFmode)))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == SUBREG\t\t\t\t\\\n+\t   && GET_CODE (SUBREG_REG (XEXP (X, 0))) == REG\t\t\\\n+\t   && REG_OK_FOR_BASE_P (SUBREG_REG (XEXP (X, 0)))\t\t\\\n+\t   && CONSTANT_P (XEXP (X, 1))\t\t\t\t\t\\\n+\t   && (TARGET_SOFT_FLOAT\t\t\t\t\t\\\n+\t       /* We can allow symbolic LO_SUM addresses for PA2.0.  */\t\\\n+\t       || (TARGET_PA_20\t\t\t\t\t\t\\\n+\t\t   && !TARGET_ELF32\t\t\t\t\t\\\n+\t           && GET_CODE (XEXP (X, 1)) != CONST_INT)\t\t\\\n+\t       || ((MODE) != SFmode\t\t\t\t\t\\\n+\t\t   && (MODE) != DFmode)))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n+\t   || (GET_CODE (X) == CONST_INT\t\t\t\t\\\n+\t       && INT_5_BITS (X)))\t\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  /* Needed for -fPIC */\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG             \t\t\\\n+\t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 1)) == UNSPEC\t\t\t\t\\\n+\t   && (TARGET_SOFT_FLOAT\t\t\t\t\t\\\n+\t       || (TARGET_PA_20\t&& !TARGET_ELF32)\t\t\t\\\n+\t       || ((MODE) != SFmode\t\t\t\t\t\\\n+\t\t   && (MODE) != DFmode)))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n }\n \n /* Look for machine dependent ways to make the invalid address AD a\n@@ -1872,16 +1940,17 @@ do { \t\t\t\t\t\t\t\t\t\\\n #define JMP_BUF_SIZE 50\n \n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t\\\n   {\"call_operand_address\", {LABEL_REF, SYMBOL_REF, CONST_INT,\t\t\\\n \t\t\t    CONST_DOUBLE, CONST, HIGH, CONSTANT_P_RTX}}, \\\n+  {\"indexed_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n   {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n   {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n   {\"reg_before_reload_operand\", {REG, MEM}},\t\t\t\t\\\n-  {\"reg_or_nonsymb_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n   {\"reg_or_0_or_nonsymb_mem_operand\", {SUBREG, REG, MEM, CONST_INT,\t\\\n \t\t\t\t       CONST_DOUBLE}},\t\t\t\\\n-  {\"move_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, MEM}},\t\\\n+  {\"move_dest_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n+  {\"move_src_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, MEM}},\t\\\n   {\"reg_or_cint_move_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"pic_label_operand\", {LABEL_REF, CONST}},\t\t\t\t\\\n   {\"fp_reg_operand\", {REG}},\t\t\t\t\t\t\\\n@@ -1905,7 +1974,6 @@ do { \t\t\t\t\t\t\t\t\t\\\n   {\"pc_or_label_operand\", {PC, LABEL_REF}},\t\t\t\t\\\n   {\"plus_xor_ior_operator\", {PLUS, XOR, IOR}},\t\t\t\t\\\n   {\"shadd_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"basereg_operand\", {REG}},\t\t\t\t\t\t\\\n   {\"div_operand\", {REG, CONST_INT}},\t\t\t\t\t\\\n   {\"ireg_operand\", {REG}},\t\t\t\t\t\t\\\n   {\"cmpib_comparison_operator\", {EQ, NE, LT, LE, LEU,\t\t\t\\"}, {"sha": "310a248bc12b0f1f9a1bcbc9899596269660aac4", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 759, "deletions": 279, "changes": 1038, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f95bed5f93bfcf5917cebf399debfcc7d2fda8/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=d8f95bed5f93bfcf5917cebf399debfcc7d2fda8", "patch": "@@ -2263,13 +2263,13 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t\t\"=r,r,r,r,r,r,Q,!*q,!f,f,*TR\")\n-\t(match_operand:SI 1 \"move_operand\"\n-\t\t\t\t\"A,r,J,N,K,RQ,rM,!rM,!fM,*RT,f\"))]\n+  [(set (match_operand:SI 0 \"move_dest_operand\"\n+\t\t\t  \"=r,r,r,r,r,r,Q,!*q,!*f,*f,T\")\n+\t(match_operand:SI 1 \"move_src_operand\"\n+\t\t\t  \"A,r,J,N,K,RQ,rM,!rM,!*fM,RT,*f\"))]\n   \"(register_operand (operands[0], SImode)\n     || reg_or_0_operand (operands[1], SImode))\n-   && ! TARGET_SOFT_FLOAT\"\n+   && !TARGET_SOFT_FLOAT\"\n   \"@\n    ldw RT'%A1,%0\n    copy %1,%0\n@@ -2287,10 +2287,155 @@\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t\t\"=r,r,r,r,r,r,Q,!*q\")\n-\t(match_operand:SI 1 \"move_operand\"\n-\t\t\t\t\"A,r,J,N,K,RQ,rM,!rM\"))]\n+  [(set (match_operand:SI 0 \"indexed_memory_operand\" \"=R\")\n+\t(match_operand:SI 1 \"register_operand\" \"f\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && !TARGET_DISABLE_INDEXING\n+   && reload_completed\"\n+  \"fstw%F0 %1,%0\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4\")])\n+\n+; Rewrite RTL using an indexed store.  This will allow the insn that\n+; computes the address to be deleted if the register it sets is dead.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 4))\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:SI (match_dup 0))\n+        (match_operand:SI 3 \"reg_or_0_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SI (plus:SI (mult:SI (match_dup 1) (const_int 4)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (mult:SI (match_dup 1) (const_int 4))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 4))))\n+   (set (mem:SI (match_dup 0))\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SI (plus:SI (mult:SI (match_dup 1) (const_int 4)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (mult:SI (match_dup 1) (const_int 4))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 4))\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:SI (match_dup 0))\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SI (plus:DI (mult:DI (match_dup 1) (const_int 4)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (const_int 4))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 2 \"register_operand\" \"\")\n+\t\t (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 4))))\n+   (set (mem:SI (match_dup 0))\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SI (plus:DI (mult:DI (match_dup 1) (const_int 4)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (const_int 4))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:SI (match_dup 0))\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[1])\n+   && (TARGET_NO_SPACE_REGS\n+       || (!REG_POINTER (operands[1]) && REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SI (plus:SI (match_dup 1) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:SI (match_dup 0))\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && (TARGET_NO_SPACE_REGS\n+       || (REG_POINTER (operands[1]) && !REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SI (plus:SI (match_dup 2) (match_dup 1)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (match_dup 2) (match_dup 1)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:SI (match_dup 0))\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[1])\n+   && (TARGET_NO_SPACE_REGS\n+       || (!REG_POINTER (operands[1]) && REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SI (plus:DI (match_dup 1) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:SI (match_dup 0))\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && (TARGET_NO_SPACE_REGS\n+       || (REG_POINTER (operands[1]) && !REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SI (plus:DI (match_dup 2) (match_dup 1)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (match_dup 2) (match_dup 1)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"move_dest_operand\"\n+\t\t\t  \"=r,r,r,r,r,r,Q,!*q\")\n+\t(match_operand:SI 1 \"move_src_operand\"\n+\t\t\t  \"A,r,J,N,K,RQ,rM,!rM\"))]\n   \"(register_operand (operands[0], SImode)\n     || reg_or_0_operand (operands[1], SImode))\n    && TARGET_SOFT_FLOAT\"\n@@ -2307,26 +2452,32 @@\n    (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n+;; Load or store with base-register modification.\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldwx|ldw} %2(%1),%0\"\n+\t(mem:SI (plus:DI (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:DI 2 \"int5_operand\" \"L\"))))\n+   (set (match_dup 1)\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldw,mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+; And a zero extended variant.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldwx|ldw} %1(%2),%0\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (mem:SI\n+\t\t\t  (plus:DI\n+\t\t\t    (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t    (match_operand:DI 2 \"int5_operand\" \"L\")))))\n+   (set (match_dup 1)\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldw,mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n-;; Load or store with base-register modification.\n-\n (define_expand \"pre_load\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t      (mem (plus (match_operand 1 \"register_operand\" \"\")\n@@ -2715,8 +2866,10 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q,!*q,!*f\")\n-\t(match_operand:HI 1 \"move_operand\" \"r,J,N,K,RQ,rM,!rM,!*fM\"))]\n+  [(set (match_operand:HI 0 \"move_dest_operand\"\n+\t \t\t  \"=r,r,r,r,r,Q,!*q,!*f\")\n+\t(match_operand:HI 1 \"move_src_operand\"\n+\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*fM\"))]\n   \"register_operand (operands[0], HImode)\n    || reg_or_0_operand (operands[1], HImode)\"\n   \"@\n@@ -2734,67 +2887,63 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mem:HI (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldhx|ldh} %2(%1),%0\"\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\"))))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"{ldhs|ldh},mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldhx|ldh} %1(%2),%0\"\n+\t(mem:HI (plus:DI (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:DI 2 \"int5_operand\" \"L\"))))\n+   (set (match_dup 1)\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldh,mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n-; Now zero extended variants.\n+; And a zero extended variant.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (mem:HI\n-\t\t\t  (plus:SI\n-\t\t\t    (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldhx|ldh} %2(%1),%0\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (mem:HI\n+\t\t\t  (plus:DI\n+\t\t\t    (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t    (match_operand:DI 2 \"int5_operand\" \"L\")))))\n+   (set (match_dup 1)\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldh,mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI (mem:HI\n \t\t\t  (plus:SI\n-\t\t\t     (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t     (match_operand:SI 2 \"basereg_operand\" \"r\")))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldhx|ldh} %1(%2),%0\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"+r\")\n-\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\"))))\n+\t\t\t    (match_operand:SI 1 \"register_operand\" \"+r\")\n+\t\t\t    (match_operand:SI 2 \"int5_operand\" \"L\")))))\n    (set (match_dup 1)\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"{ldhs|ldh},mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n-; And a zero extended variant.\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI (mem:HI\n-\t\t\t  (plus:SI\n-\t\t\t    (match_operand:SI 1 \"register_operand\" \"+r\")\n-\t\t\t    (match_operand:SI 2 \"int5_operand\" \"L\")))))\n+\t\t\t  (plus:DI\n+\t\t\t    (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t    (match_operand:DI 2 \"int5_operand\" \"L\")))))\n    (set (match_dup 1)\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"{ldhs|ldh},mb %2(%1),%0\"\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldh,mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n@@ -2809,6 +2958,17 @@\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"\"\n+  [(set (mem:HI (plus:DI (match_operand:DI 0 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:DI 1 \"int5_operand\" \"L\")))\n+\t(match_operand:HI 2 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_dup 0)\n+\t(plus:DI (match_dup 0) (match_dup 1)))]\n+  \"TARGET_64BIT\"\n+  \"sth,mb %r2,%1(%0)\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"r\")\n@@ -2830,8 +2990,10 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q,!*q,!*f\")\n-\t(match_operand:QI 1 \"move_operand\" \"r,J,N,K,RQ,rM,!rM,!*fM\"))]\n+  [(set (match_operand:QI 0 \"move_dest_operand\"\n+\t\t\t  \"=r,r,r,r,r,Q,!*q,!*f\")\n+\t(match_operand:QI 1 \"move_src_operand\"\n+\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*fM\"))]\n   \"register_operand (operands[0], QImode)\n    || reg_or_0_operand (operands[1], QImode)\"\n   \"@\n@@ -2849,86 +3011,55 @@\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldbx|ldb} %2(%1),%0\"\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\"))))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"{ldbs|ldb},mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldbx|ldb} %1(%2),%0\"\n+\t(mem:QI (plus:DI (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:DI 2 \"int5_operand\" \"L\"))))\n+   (set (match_dup 1) (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldb,mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n-; Indexed byte load with zero extension to SImode or HImode.\n+; Now the same thing with zero extensions.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (mem:QI\n-\t\t\t  (plus:SI\n-\t\t\t    (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldbx|ldb} %2(%1),%0\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (mem:QI (plus:DI\n+\t\t\t\t  (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t\t  (match_operand:DI 2 \"int5_operand\" \"L\")))))\n+   (set (match_dup 1) (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldb,mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (mem:QI\n-\t\t\t  (plus:SI\n-\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t    (match_operand:SI 2 \"basereg_operand\" \"r\")))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldbx|ldb} %1(%2),%0\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:HI (mem:QI\n-\t\t\t  (plus:SI\n-\t\t\t    (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldbx|ldb} %2(%1),%0\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:HI (mem:QI\n-\t\t\t  (plus:SI\n-\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t    (match_operand:SI 2 \"basereg_operand\" \"r\")))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"{ldbx|ldb} %1(%2),%0\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"+r\")\n-\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\"))))\n+\t(zero_extend:SI (mem:QI (plus:SI\n+\t\t\t\t  (match_operand:SI 1 \"register_operand\" \"+r\")\n+\t\t\t\t  (match_operand:SI 2 \"int5_operand\" \"L\")))))\n    (set (match_dup 1) (plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"{ldbs|ldb},mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n-; Now the same thing with zero extensions.\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (mem:QI (plus:SI\n-\t\t\t\t  (match_operand:SI 1 \"register_operand\" \"+r\")\n-\t\t\t\t  (match_operand:SI 2 \"int5_operand\" \"L\")))))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"{ldbs|ldb},mb %2(%1),%0\"\n+\t(zero_extend:SI (mem:QI (plus:DI\n+\t\t\t\t  (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t\t  (match_operand:DI 2 \"int5_operand\" \"L\")))))\n+   (set (match_dup 1) (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldb,mb %2(%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n@@ -2943,6 +3074,17 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (mem:QI (plus:DI\n+\t\t\t\t  (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t\t  (match_operand:DI 2 \"int5_operand\" \"L\")))))\n+   (set (match_dup 1) (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldb,mb %2(%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (mem:QI (plus:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n \t\t\t (match_operand:SI 1 \"int5_operand\" \"L\")))\n@@ -2954,6 +3096,17 @@\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"\"\n+  [(set (mem:QI (plus:DI (match_operand:DI 0 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:DI 1 \"int5_operand\" \"L\")))\n+\t(match_operand:QI 2 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_dup 0)\n+\t(plus:DI (match_dup 0) (match_dup 1)))]\n+  \"TARGET_64BIT\"\n+  \"stb,mb %r2,%1(%0)\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; The definition of this insn does not really explain what it does,\n ;; but it should suffice that anything generated as this insn will be\n ;; recognized as a movstrsi operation, and that it will not successfully\n@@ -3503,7 +3656,7 @@\n   \"GET_CODE (operands[1]) == CONST_DOUBLE\n    && operands[1] != CONST0_RTX (DFmode)\n    && !TARGET_64BIT\n-   && ! TARGET_SOFT_FLOAT\"\n+   && !TARGET_SOFT_FLOAT\"\n   \"* return (which_alternative == 0 ? output_move_double (operands)\n \t\t\t\t    : \\\"fldd%F1 %1,%0\\\");\"\n   [(set_attr \"type\" \"move,fpload\")\n@@ -3516,7 +3669,7 @@\n   \"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE && TARGET_64BIT)\n-      operands[1] = force_const_mem (DFmode, operands[1]);\n+    operands[1] = force_const_mem (DFmode, operands[1]);\n \n   if (emit_move_sequence (operands, DFmode, 0))\n     DONE;\n@@ -3556,16 +3709,16 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=f,*r,RQ,?o,?Q,f,*r,*r\")\n+  [(set (match_operand:DF 0 \"move_dest_operand\"\n+\t\t\t  \"=f,*r,Q,?o,?Q,f,*r,*r\")\n \t(match_operand:DF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n \t\t\t  \"fG,*rG,f,*r,*r,RQ,o,RQ\"))]\n   \"(register_operand (operands[0], DFmode)\n     || reg_or_0_operand (operands[1], DFmode))\n-   && ! (GET_CODE (operands[1]) == CONST_DOUBLE\n-\t && GET_CODE (operands[0]) == MEM)\n-   && ! TARGET_64BIT\n-   && ! TARGET_SOFT_FLOAT\"\n+   && !(GET_CODE (operands[1]) == CONST_DOUBLE\n+\t&& GET_CODE (operands[0]) == MEM)\n+   && !TARGET_64BIT\n+   && !TARGET_SOFT_FLOAT\"\n   \"*\n {\n   if (FP_REG_P (operands[0]) || FP_REG_P (operands[1])\n@@ -3577,13 +3730,156 @@\n    (set_attr \"length\" \"4,8,4,8,16,4,8,16\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n+  [(set (match_operand:DF 0 \"indexed_memory_operand\" \"=R\")\n+\t(match_operand:DF 1 \"reg_or_0_operand\" \"f\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && !TARGET_DISABLE_INDEXING\n+   && reload_completed\"\n+  \"fstd%F0 %1,%0\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 8))\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:DF (match_dup 0))\n+        (match_operand:DF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DF (plus:SI (mult:SI (match_dup 1) (const_int 8)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (mult:SI (match_dup 1) (const_int 8))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 8))))\n+   (set (mem:DF (match_dup 0))\n+        (match_operand:DF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DF (plus:SI (mult:SI (match_dup 1) (const_int 8)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (mult:SI (match_dup 1) (const_int 8))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 8))\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:DF (match_dup 0))\n+        (match_operand:DF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DF (plus:DI (mult:DI (match_dup 1) (const_int 8)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (const_int 8))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 2 \"register_operand\" \"\")\n+\t\t (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 8))))\n+   (set (mem:DF (match_dup 0))\n+        (match_operand:DF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DF (plus:DI (mult:DI (match_dup 1) (const_int 8)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (const_int 8))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:DF (match_dup 0))\n+        (match_operand:DF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[1])\n+   && (TARGET_NO_SPACE_REGS\n+       || (!REG_POINTER (operands[1]) && REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DF (plus:SI (match_dup 1) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:DF (match_dup 0))\n+        (match_operand:DF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && (TARGET_NO_SPACE_REGS\n+       || (REG_POINTER (operands[1]) && !REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DF (plus:SI (match_dup 2) (match_dup 1)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (match_dup 2) (match_dup 1)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:DF (match_dup 0))\n+        (match_operand:DF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[1])\n+   && (TARGET_NO_SPACE_REGS\n+       || (!REG_POINTER (operands[1]) && REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DF (plus:DI (match_dup 1) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:DF (match_dup 0))\n+        (match_operand:DF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && (TARGET_NO_SPACE_REGS\n+       || (REG_POINTER (operands[1]) && !REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DF (plus:DI (match_dup 2) (match_dup 1)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (match_dup 2) (match_dup 1)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"move_dest_operand\"\n \t\t\t  \"=r,?o,?Q,r,r\")\n \t(match_operand:DF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"rG,r,r,o,Q\"))]\n+\t\t\t  \"rG,r,r,o,RQ\"))]\n   \"(register_operand (operands[0], DFmode)\n     || reg_or_0_operand (operands[1], DFmode))\n-   && ! TARGET_64BIT\n+   && !TARGET_64BIT\n    && TARGET_SOFT_FLOAT\"\n   \"*\n {\n@@ -3593,13 +3889,13 @@\n    (set_attr \"length\" \"8,8,16,8,16\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t\t\"=r,r,r,r,r,Q,!*q,!f,f,*TR\")\n-\t(match_operand:DF 1 \"move_operand\"\n-\t\t\t\t\"r,J,N,K,RQ,rM,!rM,!fM,*RT,f\"))]\n+  [(set (match_operand:DF 0 \"move_dest_operand\"\n+\t\t\t  \"=!*r,*r,*r,*r,*r,Q,!*q,f,f,T\")\n+\t(match_operand:DF 1 \"move_src_operand\"\n+\t\t\t  \"!*r,J,N,K,RQ,*rM,!*rM,fM,RT,f\"))]\n   \"(register_operand (operands[0], DFmode)\n     || reg_or_0_operand (operands[1], DFmode))\n-   && ! TARGET_SOFT_FLOAT && TARGET_64BIT\"\n+   && !TARGET_SOFT_FLOAT && TARGET_64BIT\"\n   \"@\n    copy %1,%0\n    ldi %1,%0\n@@ -3615,50 +3911,15 @@\n    (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=fx\")\n-\t(mem:DF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"{flddx|fldd} %2(%1),%0\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=fx\")\n-\t(mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"{flddx|fldd} %1(%2),%0\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (mem:DF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n-\t(match_operand:DF 0 \"register_operand\" \"fx\"))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"{fstdx|fstd} %0,%2(%1)\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\")))\n-\t(match_operand:DF 0 \"register_operand\" \"fx\"))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"{fstdx|fstd} %0,%1(%2)\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"4\")])\n-\n+\f\n (define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE && TARGET_64BIT)\n-      operands[1] = force_const_mem (DImode, operands[1]);\n+    operands[1] = force_const_mem (DImode, operands[1]);\n \n   if (emit_move_sequence (operands, DImode, 0))\n     DONE;\n@@ -3733,14 +3994,14 @@\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=r,o,Q,r,r,r,f,f,*TR\")\n+  [(set (match_operand:DI 0 \"move_dest_operand\"\n+\t\t\t  \"=r,o,Q,r,r,r,*f,*f,T\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t\t\t  \"rM,r,r,o*R,Q,i,fM,*TR,f\"))]\n+\t\t\t  \"rM,r,r,o*R,Q,i,*fM,RT,*f\"))]\n   \"(register_operand (operands[0], DImode)\n     || reg_or_0_operand (operands[1], DImode))\n-   && ! TARGET_64BIT\n-   && ! TARGET_SOFT_FLOAT\"\n+   && !TARGET_64BIT\n+   && !TARGET_SOFT_FLOAT\"\n   \"*\n {\n   if (FP_REG_P (operands[0]) || FP_REG_P (operands[1])\n@@ -3752,13 +4013,13 @@\n    (set_attr \"length\" \"8,8,16,8,16,16,4,4,4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t\t\"=r,r,r,r,r,r,Q,!*q,!f,f,*TR\")\n-\t(match_operand:DI 1 \"move_operand\"\n-\t\t\t\t\"A,r,J,N,K,RQ,rM,!rM,!fM,*RT,f\"))]\n+  [(set (match_operand:DI 0 \"move_dest_operand\"\n+\t\t\t  \"=r,r,r,r,r,r,Q,!*q,!*f,*f,T\")\n+\t(match_operand:DI 1 \"move_src_operand\"\n+\t\t\t  \"A,r,J,N,K,RQ,rM,!rM,!*fM,RT,*f\"))]\n   \"(register_operand (operands[0], DImode)\n     || reg_or_0_operand (operands[1], DImode))\n-   && ! TARGET_SOFT_FLOAT && TARGET_64BIT\"\n+   && !TARGET_SOFT_FLOAT && TARGET_64BIT\"\n   \"@\n    ldd RT'%A1,%0\n    copy %1,%0\n@@ -3776,13 +4037,93 @@\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n+  [(set (match_operand:DI 0 \"indexed_memory_operand\" \"=R\")\n+\t(match_operand:DI 1 \"register_operand\" \"f\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && !TARGET_DISABLE_INDEXING\n+   && reload_completed\"\n+  \"fstd%F0 %1,%0\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 8))\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:DI (match_dup 0))\n+        (match_operand:DI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DI (plus:DI (mult:DI (match_dup 1) (const_int 8)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (const_int 8))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 2 \"register_operand\" \"\")\n+\t\t (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 8))))\n+   (set (mem:DI (match_dup 0))\n+        (match_operand:DI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DI (plus:DI (mult:DI (match_dup 1) (const_int 8)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (const_int 8))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:DI (match_dup 0))\n+        (match_operand:DI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[1])\n+   && (TARGET_NO_SPACE_REGS\n+       || (!REG_POINTER (operands[1]) && REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DI (plus:DI (match_dup 1) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:DI (match_dup 0))\n+        (match_operand:DI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && (TARGET_NO_SPACE_REGS\n+       || (REG_POINTER (operands[1]) && !REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:DI (plus:DI (match_dup 2) (match_dup 1)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (match_dup 2) (match_dup 1)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"move_dest_operand\"\n \t\t\t  \"=r,o,Q,r,r,r\")\n \t(match_operand:DI 1 \"general_operand\"\n \t\t\t  \"rM,r,r,o,Q,i\"))]\n   \"(register_operand (operands[0], DImode)\n     || reg_or_0_operand (operands[1], DImode))\n-   && ! TARGET_64BIT\n+   && !TARGET_64BIT\n    && TARGET_SOFT_FLOAT\"\n   \"*\n {\n@@ -3873,26 +4214,169 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=f,r,f,r,RQ,Q\")\n+  [(set (match_operand:SF 0 \"move_dest_operand\"\n+\t\t\t  \"=f,!*r,f,*r,Q,Q\")\n \t(match_operand:SF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"fG,rG,RQ,RQ,f,rG\"))]\n+\t\t\t  \"fG,!*rG,RQ,RQ,f,*rG\"))]\n   \"(register_operand (operands[0], SFmode)\n     || reg_or_0_operand (operands[1], SFmode))\n-   && ! TARGET_SOFT_FLOAT\"\n+   && !TARGET_SOFT_FLOAT\"\n   \"@\n    fcpy,sgl %f1,%0\n    copy %r1,%0\n    fldw%F1 %1,%0\n    ldw%M1 %1,%0\n-   fstw%F0 %r1,%0\n+   fstw%F0 %1,%0\n    stw%M0 %r1,%0\"\n   [(set_attr \"type\" \"fpalu,move,fpload,load,fpstore,store\")\n    (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4,4,4,4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\"\n+  [(set (match_operand:SF 0 \"indexed_memory_operand\" \"=R\")\n+\t(match_operand:SF 1 \"register_operand\" \"f\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && !TARGET_DISABLE_INDEXING\n+   && reload_completed\"\n+  \"fstw%F0 %1,%0\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 4))\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:SF (match_dup 0))\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SF (plus:SI (mult:SI (match_dup 1) (const_int 4)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (mult:SI (match_dup 1) (const_int 4))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 4))))\n+   (set (mem:SF (match_dup 0))\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SF (plus:SI (mult:SI (match_dup 1) (const_int 4)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (mult:SI (match_dup 1) (const_int 4))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 4))\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:SF (match_dup 0))\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SF (plus:DI (mult:DI (match_dup 1) (const_int 4)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (const_int 4))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 2 \"register_operand\" \"\")\n+\t\t (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t  (const_int 4))))\n+   (set (mem:SF (match_dup 0))\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SF (plus:DI (mult:DI (match_dup 1) (const_int 4)) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (const_int 4))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:SF (match_dup 0))\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[1])\n+   && (TARGET_NO_SPACE_REGS\n+       || (!REG_POINTER (operands[1]) && REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SF (plus:SI (match_dup 1) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (mem:SF (match_dup 0))\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && (TARGET_NO_SPACE_REGS\n+       || (REG_POINTER (operands[1]) && !REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SF (plus:SI (match_dup 2) (match_dup 1)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:SI (match_dup 2) (match_dup 1)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:SF (match_dup 0))\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[1])\n+   && (TARGET_NO_SPACE_REGS\n+       || (!REG_POINTER (operands[1]) && REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SF (plus:DI (match_dup 1) (match_dup 2)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (mem:SF (match_dup 0))\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\n+   && REG_OK_FOR_BASE_P (operands[2])\n+   && (TARGET_NO_SPACE_REGS\n+       || (REG_POINTER (operands[1]) && !REG_POINTER (operands[2])))\n+   && FP_REGNO_P (REGNO (operands[3]))\"\n+  [(set (mem:SF (plus:DI (match_dup 2) (match_dup 1)))\n+\t(match_dup 3))\n+   (set (match_dup 0) (plus:DI (match_dup 2) (match_dup 1)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"move_dest_operand\"\n \t\t\t  \"=r,r,Q\")\n \t(match_operand:SF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n \t\t\t  \"rG,RQ,rG\"))]\n@@ -3907,41 +4391,6 @@\n    (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=fx\")\n-\t(mem:SF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"{fldwx|fldw} %2(%1),%0\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=fx\")\n-\t(mem:SF (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"{fldwx|fldw} %1(%2),%0\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"\"\n-  [(set (mem:SF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n-      (match_operand:SF 0 \"register_operand\" \"fx\"))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"{fstwx|fstw} %0,%2(%1)\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"4\")])\n-\f\n-(define_insn \"\"\n-  [(set (mem:SF (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\")))\n-      (match_operand:SF 0 \"register_operand\" \"fx\"))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"{fstwx|fstw} %0,%1(%2)\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"4\")])\n \f\n \n ;;- zero extension instructions\n@@ -3950,24 +4399,6 @@\n ;; memory operands.  This gives us better overall code than just\n ;; having a pattern that does or does not accept memory operands.\n \n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"move_operand\" \"r,RQ\")))]\n-  \"GET_CODE (operands[1]) != CONST_INT\"\n-  \"@\n-   {extru|extrw,u} %1,31,16,%0\n-   ldh%M1 %1,%0\"\n-  [(set_attr \"type\" \"shift,load\")\n-   (set_attr \"length\" \"4,4\")])\n-\n (define_expand \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(zero_extend:HI\n@@ -3978,7 +4409,7 @@\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:HI\n-\t (match_operand:QI 1 \"move_operand\" \"r,RQ\")))]\n+\t (match_operand:QI 1 \"move_src_operand\" \"r,RQ\")))]\n   \"GET_CODE (operands[1]) != CONST_INT\"\n   \"@\n    {extru|extrw,u} %1,31,8,%0\n@@ -3996,37 +4427,85 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"move_operand\" \"r,RQ\")))]\n+\t (match_operand:QI 1 \"move_src_operand\" \"r,RQ\")))]\n   \"GET_CODE (operands[1]) != CONST_INT\"\n   \"@\n    {extru|extrw,u} %1,31,8,%0\n    ldb%M1 %1,%0\"\n   [(set_attr \"type\" \"shift,load\")\n    (set_attr \"length\" \"4,4\")])\n \n-(define_insn \"zero_extendqidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"move_src_operand\" \"r,RQ\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   {extru|extrw,u} %1,31,16,%0\n+   ldh%M1 %1,%0\"\n+  [(set_attr \"type\" \"shift,load\")\n+   (set_attr \"length\" \"4,4\")])\n+\n+(define_expand \"zero_extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI\n+\t (match_operand:QI 1 \"register_operand\" \"\")))]\n   \"TARGET_64BIT\"\n-  \"extrd,u %1,63,8,%0\"\n-  [(set_attr \"type\" \"shift\") \n-  (set_attr \"length\" \"4\")])\n+  \"\")\n \n-(define_insn \"zero_extendhidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI\n+\t (match_operand:QI 1 \"move_src_operand\" \"r,RQ\")))]\n+  \"TARGET_64BIT && GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   extrd,u %1,63,8,%0\n+   ldb%M1 %1,%0\"\n+  [(set_attr \"type\" \"shift,load\")\n+   (set_attr \"length\" \"4,4\")])\n+\n+(define_expand \"zero_extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI\n+\t (match_operand:HI 1 \"register_operand\" \"\")))]\n   \"TARGET_64BIT\"\n-  \"extrd,u %1,63,16,%0\"\n-  [(set_attr \"type\" \"shift\") \n-  (set_attr \"length\" \"4\")])\n+  \"\")\n \n-(define_insn \"zero_extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI\n+\t (match_operand:HI 1 \"move_src_operand\" \"r,RQ\")))]\n+  \"TARGET_64BIT && GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   extrd,u %1,63,16,%0\n+   ldh%M1 %1,%0\"\n+  [(set_attr \"type\" \"shift,load\")\n+   (set_attr \"length\" \"4,4\")])\n+\n+(define_expand \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI\n+\t (match_operand:SI 1 \"register_operand\" \"\")))]\n   \"TARGET_64BIT\"\n-  \"extrd,u %1,63,32,%0\"\n-  [(set_attr \"type\" \"shift\") \n-  (set_attr \"length\" \"4\")])\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI\n+\t (match_operand:SI 1 \"move_src_operand\" \"r,RQ\")))]\n+  \"TARGET_64BIT && GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   extrd,u %1,63,32,%0\n+   ldw%M1 %1,%0\"\n+  [(set_attr \"type\" \"shift,load\")\n+   (set_attr \"length\" \"4,4\")])\n \n ;;- sign extension instructions\n \n@@ -4331,7 +4810,7 @@\n \t\t (match_operand:DI 2 \"arith_operand\" \"r,J\")))]\n   \"TARGET_64BIT\"\n   \"@\n-   {addl|add,l} %1,%2,%0\n+   add,l %1,%2,%0\n    ldo %2(%1),%0\"\n   [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"pa_combine_type\" \"addmove\")\n@@ -4496,8 +4975,8 @@\n \n ;; The mulsi3 insns set up registers for the millicode call.\n (define_expand \"mulsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_src_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_src_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_dup 3))\n \t      (clobber (reg:SI 26))\n@@ -4508,14 +4987,15 @@\n   \"\n {\n   operands[4] = gen_rtx_REG (SImode, TARGET_64BIT ? 2 : 31);\n-  if (TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT)\n+  if (TARGET_PA_11 && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT)\n     {\n       rtx scratch = gen_reg_rtx (DImode);\n       operands[1] = force_reg (SImode, operands[1]);\n       operands[2] = force_reg (SImode, operands[2]);\n       emit_insn (gen_umulsidi3 (scratch, operands[1], operands[2]));\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t      gen_rtx_SUBREG (SImode, scratch, GET_MODE_SIZE (SImode))));\n+      emit_insn (gen_movsi (operands[0],\n+\t\t\t    gen_rtx_SUBREG (SImode, scratch,\n+\t\t\t\t\t    GET_MODE_SIZE (SImode))));\n       DONE;\n     }\n   operands[3] = gen_reg_rtx (SImode);\n@@ -4620,8 +5100,8 @@\n \n ;;; Division and mod.\n (define_expand \"divsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_src_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_src_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (div:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_dup 4))\n@@ -4676,8 +5156,8 @@\n    (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_expand \"udivsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_src_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_src_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (udiv:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_dup 4))\n@@ -4733,8 +5213,8 @@\n    (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_expand \"modsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_src_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_src_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_dup 4))\n@@ -4785,8 +5265,8 @@\n    (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_expand \"umodsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_src_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_src_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (umod:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_dup 4))\n@@ -8274,11 +8754,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n ;; Clean up turds left by reload.\n (define_peephole\n-  [(set (match_operand 0 \"reg_or_nonsymb_mem_operand\" \"\")\n+  [(set (match_operand 0 \"move_dest_operand\" \"\")\n \t(match_operand 1 \"register_operand\" \"fr\"))\n    (set (match_operand 2 \"register_operand\" \"fr\")\n \t(match_dup 0))]\n-  \"! TARGET_SOFT_FLOAT\n+  \"!TARGET_SOFT_FLOAT\n    && GET_CODE (operands[0]) == MEM\n    && ! MEM_VOLATILE_P (operands[0])\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n@@ -8314,10 +8794,10 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n (define_peephole\n   [(set (match_operand 0 \"register_operand\" \"fr\")\n-\t(match_operand 1 \"reg_or_nonsymb_mem_operand\" \"\"))\n+\t(match_operand 1 \"move_src_operand\" \"\"))\n    (set (match_operand 2 \"register_operand\" \"fr\")\n \t(match_dup 1))]\n-  \"! TARGET_SOFT_FLOAT\n+  \"!TARGET_SOFT_FLOAT\n    && GET_CODE (operands[1]) == MEM\n    && ! MEM_VOLATILE_P (operands[1])\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])"}]}