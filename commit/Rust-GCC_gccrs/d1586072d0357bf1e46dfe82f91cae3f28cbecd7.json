{"sha": "d1586072d0357bf1e46dfe82f91cae3f28cbecd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1ODYwNzJkMDM1N2JmMWU0NmRmZTgyZjkxY2FlM2YyOGNiZWNkNw==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2005-12-09T17:17:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:17:51Z"}, "message": "trans.c (tree_transform, emit_check): Adjust calls to build_call_raise, passing the now expected GNAT_NODE argument.\n\n2005-12-05  Olivier Hainque  <hainque@adacore.com>\n\t    Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* trans.c (tree_transform, emit_check): Adjust calls to\n\tbuild_call_raise, passing the now expected GNAT_NODE argument.\n\n\t* gigi.h (build_call_raise): Add a GNAT_NODE argument to convey better\n\tsource line information than what the current global locus indicates\n\twhen appropriate.\n\n\t* utils2.c (build_simple_component_ref): Return 0 if the offset of the\n\tfield has overflowed.\n\t(build_call_raise): Add a GNAT_NODE argument to convey better source\n\tline information than what the current global locus indicates when\n\tappropriate.\n\t(build_component_ref): Adjust call to build_call_raise.\n\nFrom-SVN: r108290", "tree": {"sha": "6fb302ccd8f67f6f9f83ab43088041df9bc19d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fb302ccd8f67f6f9f83ab43088041df9bc19d03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1586072d0357bf1e46dfe82f91cae3f28cbecd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1586072d0357bf1e46dfe82f91cae3f28cbecd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1586072d0357bf1e46dfe82f91cae3f28cbecd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1586072d0357bf1e46dfe82f91cae3f28cbecd7/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52739835a1902dfe18f439c64a30e15374619e29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52739835a1902dfe18f439c64a30e15374619e29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52739835a1902dfe18f439c64a30e15374619e29"}], "stats": {"total": 90, "additions": 63, "deletions": 27}, "files": [{"sha": "2552e5683567c610a68711a44152c78ab1ecac0d", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1586072d0357bf1e46dfe82f91cae3f28cbecd7/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1586072d0357bf1e46dfe82f91cae3f28cbecd7/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=d1586072d0357bf1e46dfe82f91cae3f28cbecd7", "patch": "@@ -710,8 +710,12 @@ extern tree build_call_2_expr (tree fundecl, tree arg1, tree arg2);\n extern tree build_call_0_expr (tree fundecl);\n \n /* Call a function that raises an exception and pass the line number and file\n-   name, if requested.  MSG says which exception function to call.  */\n-extern tree build_call_raise (int msg);\n+   name, if requested.  MSG says which exception function to call.\n+\n+   GNAT_NODE is the gnat node conveying the source location for which the\n+   error should be signaled, or Empty in which case the error is signaled on\n+   the current ref_file_name/input_line.  */\n+extern tree build_call_raise (int msg, Node_Id gnat_node);\n \n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  This is not the\n    same as build_constructor in the language-independent tree.c.  */"}, {"sha": "38862293a43c8e5bc4dc74869d183814753f8f9d", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1586072d0357bf1e46dfe82f91cae3f28cbecd7/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1586072d0357bf1e46dfe82f91cae3f28cbecd7/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=d1586072d0357bf1e46dfe82f91cae3f28cbecd7", "patch": "@@ -1546,14 +1546,18 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t   gnat_actual = Next_Actual (gnat_actual))\n \tadd_stmt (gnat_to_gnu (gnat_actual));\n \n-      if (Nkind (gnat_node) == N_Function_Call && !gnu_target)\n-\t{\n-\t  *gnu_result_type_p = TREE_TYPE (gnu_subprog_type);\n-\t  return build1 (NULL_EXPR, *gnu_result_type_p,\n-\t\t\t build_call_raise (PE_Stubbed_Subprogram_Called));\n-\t}\n-      else\n-\treturn build_call_raise (PE_Stubbed_Subprogram_Called);\n+      {\n+\ttree call_expr\n+\t  = build_call_raise (PE_Stubbed_Subprogram_Called, gnat_node);\n+\n+\tif (Nkind (gnat_node) == N_Function_Call && !gnu_target)\n+\t  {\n+\t    *gnu_result_type_p = TREE_TYPE (gnu_subprog_type);\n+\t    return build1 (NULL_EXPR, *gnu_result_type_p, call_expr);\n+\t  }\n+\telse\n+\t  return call_expr;\n+      }\n     }\n \n   /* If we are calling by supplying a pointer to a target, set up that\n@@ -2515,7 +2519,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       && Nkind (gnat_node) != N_Identifier\n       && !Compile_Time_Known_Value (gnat_node))\n     return build1 (NULL_EXPR, get_unpadded_type (Etype (gnat_node)),\n-\t\t   build_call_raise (CE_Range_Check_Failed));\n+\t\t   build_call_raise (CE_Range_Check_Failed, gnat_node));\n \n   /* If this is a Statement and we are at top level, it must be part of the\n      elaboration procedure, so mark us as being in that procedure and push our\n@@ -3463,7 +3467,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t Storage_Error: execution shouldn't have gotten here anyway.  */\n       if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))) == INTEGER_CST\n \t   && TREE_OVERFLOW (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))))\n-\tgnu_result = build_call_raise (SE_Object_Too_Large);\n+\tgnu_result = build_call_raise (SE_Object_Too_Large, gnat_node);\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call\n \t       && !Do_Range_Check (Expression (gnat_node)))\n \tgnu_result = call_to_gnu (Expression (gnat_node),\n@@ -4037,7 +4041,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t}\n \n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n-      gnu_result = build_call_raise (UI_To_Int (Reason (gnat_node)));\n+      gnu_result\n+\t= build_call_raise (UI_To_Int (Reason (gnat_node)), gnat_node);\n \n       /* If the type is VOID, this is a statement, so we need to\n \t generate the code for the call.  Handle a Condition, if there\n@@ -4148,7 +4153,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       gnu_result\n \t= build1 (NULL_EXPR, gnu_result_type,\n-\t\t  build_call_raise (CE_Overflow_Check_Failed));\n+\t\t  build_call_raise (CE_Overflow_Check_Failed, gnat_node));\n     }\n \n   /* If our result has side-effects and is of an unconstrained type,\n@@ -5207,7 +5212,7 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason)\n   tree gnu_call;\n   tree gnu_result;\n \n-  gnu_call = build_call_raise (reason);\n+  gnu_call = build_call_raise (reason, Empty);\n \n   /* Use an outer COMPOUND_EXPR to make sure that GNU_EXPR will get evaluated\n      in front of the comparison in case it ends up being a SAVE_EXPR.  Put the"}, {"sha": "f9d87dc13355acc07668663c911afdfc325f8935", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1586072d0357bf1e46dfe82f91cae3f28cbecd7/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1586072d0357bf1e46dfe82f91cae3f28cbecd7/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=d1586072d0357bf1e46dfe82f91cae3f28cbecd7", "patch": "@@ -37,6 +37,7 @@\n #include \"types.h\"\n #include \"atree.h\"\n #include \"stringt.h\"\n+#include \"namet.h\"\n #include \"uintp.h\"\n #include \"fe.h\"\n #include \"elists.h\"\n@@ -854,7 +855,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t       && TREE_CODE (right_operand) == CONSTRUCTOR\n \t       && integer_zerop (VEC_index (constructor_elt,\n \t\t\t\t\t    CONSTRUCTOR_ELTS (right_operand),\n-\t\t\t\t\t    0)->value))\n+\t\t\t\t\t    0)\n+\t\t\t\t ->value))\n \t{\n \t  right_operand = build_component_ref (left_operand, NULL_TREE,\n \t\t\t\t\t       TYPE_FIELDS (left_base_type),\n@@ -1107,13 +1109,13 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t     a pointer to our type.  */\n \t  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n \t    {\n-\t      result = VEC_index (constructor_elt,\n-\t\t\t\t  CONSTRUCTOR_ELTS (operand),\n-\t\t\t\t  0)->value;\n-\t      result\n-\t\t= build_unary_op (ADDR_EXPR, NULL_TREE, result);\n+\t      result = (VEC_index (constructor_elt,\n+\t\t\t\t   CONSTRUCTOR_ELTS (operand),\n+\t\t\t\t   0)\n+\t\t\t->value);\n+\n \t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n-\t\t\t\tresult);\n+\t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n \t      break;\n \t    }\n \n@@ -1443,17 +1445,34 @@ build_call_0_expr (tree fundecl)\n }\n \f\n /* Call a function that raises an exception and pass the line number and file\n-   name, if requested.  MSG says which exception function to call.  */\n+   name, if requested.  MSG says which exception function to call.\n+\n+   GNAT_NODE is the gnat node conveying the source location for which the\n+   error should be signaled, or Empty in which case the error is signaled on\n+   the current ref_file_name/input_line.  */\n \n tree\n-build_call_raise (int msg)\n+build_call_raise (int msg, Node_Id gnat_node)\n {\n   tree fndecl = gnat_raise_decls[msg];\n+\n   const char *str\n-    = (Debug_Flag_NN || Exception_Locations_Suppressed) ? \"\" : ref_filename;\n+    = (Debug_Flag_NN || Exception_Locations_Suppressed)\n+      ? \"\"\n+      : (gnat_node != Empty)\n+        ? IDENTIFIER_POINTER\n+          (get_identifier (Get_Name_String\n+\t\t\t   (Debug_Source_Name\n+\t\t\t    (Get_Source_File_Index (Sloc (gnat_node))))))\n+        : ref_filename;\n+\n   int len = strlen (str) + 1;\n   tree filename = build_string (len, str);\n \n+  int line_number\n+    = (gnat_node != Empty)\n+      ? Get_Logical_Line_Number (Sloc(gnat_node)) : input_line;\n+\n   TREE_TYPE (filename)\n     = build_array_type (char_type_node,\n \t\t\tbuild_index_type (build_int_cst (NULL_TREE, len)));\n@@ -1462,7 +1481,7 @@ build_call_raise (int msg)\n     build_call_2_expr (fndecl,\n \t\t       build1 (ADDR_EXPR, build_pointer_type (char_type_node),\n \t\t\t       filename),\n-\t\t       build_int_cst (NULL_TREE, input_line));\n+\t\t       build_int_cst (NULL_TREE, line_number));\n }\n \f\n /* qsort comparer for the bit positions of two constructor elements\n@@ -1631,6 +1650,14 @@ build_simple_component_ref (tree record_variable, tree component,\n   if (!field)\n     return NULL_TREE;\n \n+  /* If the field's offset has overflowed, do not attempt to access it\n+     as doing so may trigger sanity checks deeper in the back-end.\n+     Note that we don't need to warn since this will be done on trying\n+     to declare the object.  */\n+  if (TREE_CODE (DECL_FIELD_OFFSET (field)) == INTEGER_CST\n+      && TREE_CONSTANT_OVERFLOW (DECL_FIELD_OFFSET (field)))\n+    return NULL_TREE;\n+\n   /* It would be nice to call \"fold\" here, but that can lose a type\n      we need to tag a PLACEHOLDER_EXPR with, so we can't do it.  */\n   ref = build3 (COMPONENT_REF, TREE_TYPE (field), record_variable, field,\n@@ -1663,7 +1690,7 @@ build_component_ref (tree record_variable, tree component,\n      abort.  */\n   gcc_assert (field);\n   return build1 (NULL_EXPR, TREE_TYPE (field),\n-\t\t build_call_raise (CE_Discriminant_Check_Failed));\n+\t\t build_call_raise (CE_Discriminant_Check_Failed, Empty));\n }\n \f\n /* Build a GCC tree to call an allocation or deallocation function."}]}