{"sha": "105b7136967d687fbb900a2d25e4fe6a876db57d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1YjcxMzY5NjdkNjg3ZmJiOTAwYTJkMjVlNGZlNmE4NzZkYjU3ZA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-09-26T06:19:42Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-09-26T06:19:42Z"}, "message": "re PR fortran/37498 (Incorrect array value returned - 4.3 ABI Broken)\n\n2008-09-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org\n\n\tPR libfortran/37498\n\t* list_read.c (eat_separator): Revert previous patch and move\n\tdelim_status, decimal_status, and pad_status to gfc_unit.\n\t(parse_real): Ditto. (read_real): Ditto.\n\t* read.c (read_a): Likewise. (read_a_char4): Likewise.\n\t(read_f): Likewise.\n\t* inquire.c (inquire_via_unit): Add missing check for\n\tIOPARM_INQUIRE_HAS_FLAGS2. (inquire_via_filename): Likewise.\n\t* io.h (unit_sign_s): Move delim_status, decimal_status, and pad_status\n\tto gfc_unit.\n\t* transfer.c (read_sf): Ditto. (read_block_form): Ditto.\n\t(formatted_transfer_scalar): Ditto. (data_transfer_init): Ditto.\n\t* write.c (write_default_char4): Ditto. (write_utf8_char4): Ditto.\n\t(write_character): Ditto. (write_real_g0): Ditto.\n\t(list_formatted_write_scalar): Ditto. (nml_write_obj): Ditto.\n\t(namelist_write): Ditto.\n\t* write_float.def (calculate_sign): Ditto. (output_float): Ditto.\n\nFrom-SVN: r140684", "tree": {"sha": "43e49465ce4691d29bcfe44a26c6ad96f9dac836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43e49465ce4691d29bcfe44a26c6ad96f9dac836"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/105b7136967d687fbb900a2d25e4fe6a876db57d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105b7136967d687fbb900a2d25e4fe6a876db57d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105b7136967d687fbb900a2d25e4fe6a876db57d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105b7136967d687fbb900a2d25e4fe6a876db57d/comments", "author": null, "committer": null, "parents": [{"sha": "5e1bdeb75f6f1f724a5e046c4ac39254dbf8ab0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e1bdeb75f6f1f724a5e046c4ac39254dbf8ab0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e1bdeb75f6f1f724a5e046c4ac39254dbf8ab0f"}], "stats": {"total": 494, "additions": 228, "deletions": 266}, "files": [{"sha": "150fc15b93a74b59aef432e099cd7d6ceec90434", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=105b7136967d687fbb900a2d25e4fe6a876db57d", "patch": "@@ -1,3 +1,23 @@\n+2008-09-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org\n+\n+\tPR libfortran/37498\n+\t* list_read.c (eat_separator): Revert previous patch and move\n+\tdelim_status, decimal_status, and pad_status to gfc_unit.\n+\t(parse_real): Ditto. (read_real): Ditto.\n+\t* read.c (read_a): Likewise. (read_a_char4): Likewise.\n+\t(read_f): Likewise.\n+\t* inquire.c (inquire_via_unit): Add missing check for\n+\tIOPARM_INQUIRE_HAS_FLAGS2. (inquire_via_filename): Likewise.\n+\t* io.h (unit_sign_s): Move delim_status, decimal_status, and pad_status\n+\tto gfc_unit.\n+\t* transfer.c (read_sf): Ditto. (read_block_form): Ditto.\n+\t(formatted_transfer_scalar): Ditto. (data_transfer_init): Ditto.\n+\t* write.c (write_default_char4): Ditto. (write_utf8_char4): Ditto.\n+\t(write_character): Ditto. (write_real_g0): Ditto.\n+\t(list_formatted_write_scalar): Ditto. (nml_write_obj): Ditto.\n+\t(namelist_write): Ditto.\n+\t* write_float.def (calculate_sign): Ditto. (output_float): Ditto.\n+\n 2008-09-24  Tobias Burnus  <burnus@net-b.de>\n \n \t* runtime/compile_options.c (init_compile_options):"}, {"sha": "3b5f3f74473ae144e10ef4a309e63cec9321739d", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 134, "deletions": 128, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=105b7136967d687fbb900a2d25e4fe6a876db57d", "patch": "@@ -252,125 +252,128 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n       cf_strcpy (iqp->pad, iqp->pad_len, p);\n     }\n \n-  if ((cf2 & IOPARM_INQUIRE_HAS_PENDING) != 0)\n-    *iqp->pending = 0;\n-  \n-  if ((cf2 & IOPARM_INQUIRE_HAS_ID) != 0)\n-    *iqp->id = 0;\n-\n-  if ((cf2 & IOPARM_INQUIRE_HAS_ENCODING) != 0)\n+  if (cf & IOPARM_INQUIRE_HAS_FLAGS2)\n     {\n-      if (u == NULL || u->flags.form != FORM_FORMATTED)\n-\tp = undefined;\n-      else\n-\tswitch (u->flags.encoding)\n-\t  {\n-\t  case ENCODING_DEFAULT:\n-\t    p = \"UNKNOWN\";\n-\t    break;\n-\t  case ENCODING_UTF8:\n-\t    p = \"UTF-8\";\n-\t    break;\n-\t  default:\n-\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad encoding\");\n-\t  }\n-\n-      cf_strcpy (iqp->encoding, iqp->encoding_len, p);\n-    }\n-\n-  if ((cf2 & IOPARM_INQUIRE_HAS_DECIMAL) != 0)\n-    {\n-      if (u == NULL || u->flags.form != FORM_FORMATTED)\n-\tp = undefined;\n-      else\n-\tswitch (u->flags.decimal)\n-\t  {\n-\t  case DECIMAL_POINT:\n-\t    p = \"POINT\";\n-\t    break;\n-\t  case DECIMAL_COMMA:\n-\t    p = \"COMMA\";\n-\t    break;\n-\t  default:\n-\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad comma\");\n-\t  }\n-\n-      cf_strcpy (iqp->decimal, iqp->decimal_len, p);\n-    }\n-\n-  if ((cf2 & IOPARM_INQUIRE_HAS_ASYNCHRONOUS) != 0)\n-    {\n-      if (u == NULL)\n-\tp = undefined;\n-      else\n-\tswitch (u->flags.async)\n-\t  {\n-\t  case ASYNC_YES:\n-\t    p = \"YES\";\n-\t    break;\n-\t  case ASYNC_NO:\n-\t    p = \"NO\";\n-\t    break;\n-\t  default:\n-\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad async\");\n-\t  }\n+      if ((cf2 & IOPARM_INQUIRE_HAS_PENDING) != 0)\n+\t*iqp->pending = 0;\n+  \n+      if ((cf2 & IOPARM_INQUIRE_HAS_ID) != 0)\n+        *iqp->id = 0;\n \n-      cf_strcpy (iqp->asynchronous, iqp->asynchronous_len, p);\n-    }\n+      if ((cf2 & IOPARM_INQUIRE_HAS_ENCODING) != 0)\n+\t{\n+\t  if (u == NULL || u->flags.form != FORM_FORMATTED)\n+\t    p = undefined;\n+          else\n+\t    switch (u->flags.encoding)\n+\t      {\n+\t      case ENCODING_DEFAULT:\n+\t\tp = \"UNKNOWN\";\n+\t\tbreak;\n+\t      case ENCODING_UTF8:\n+\t\tp = \"UTF-8\";\n+\t\tbreak;\n+\t      default:\n+\t\tinternal_error (&iqp->common, \"inquire_via_unit(): Bad encoding\");\n+\t      }\n+\n+\t  cf_strcpy (iqp->encoding, iqp->encoding_len, p);\n+\t}\n \n-  if ((cf2 & IOPARM_INQUIRE_HAS_SIGN) != 0)\n-    {\n-      if (u == NULL)\n-\tp = undefined;\n-      else\n-\tswitch (u->flags.sign)\n-\t  {\n-\t  case SIGN_PROCDEFINED:\n-\t    p = \"PROCESSOR_DEFINED\";\n-\t    break;\n-\t  case SIGN_SUPPRESS:\n-\t    p = \"SUPPRESS\";\n-\t    break;\n-\t  case SIGN_PLUS:\n-\t    p = \"PLUS\";\n-\t    break;\n-\t  default:\n-\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad sign\");\n-\t  }\n+      if ((cf2 & IOPARM_INQUIRE_HAS_DECIMAL) != 0)\n+\t{\n+\t  if (u == NULL || u->flags.form != FORM_FORMATTED)\n+\t    p = undefined;\n+\t  else\n+\t    switch (u->flags.decimal)\n+\t      {\n+\t      case DECIMAL_POINT:\n+\t\tp = \"POINT\";\n+\t\tbreak;\n+\t      case DECIMAL_COMMA:\n+\t\tp = \"COMMA\";\n+\t\tbreak;\n+\t      default:\n+\t\tinternal_error (&iqp->common, \"inquire_via_unit(): Bad comma\");\n+\t      }\n+\n+\t  cf_strcpy (iqp->decimal, iqp->decimal_len, p);\n+\t}\n \n-      cf_strcpy (iqp->sign, iqp->sign_len, p);\n-    }\n+      if ((cf2 & IOPARM_INQUIRE_HAS_ASYNCHRONOUS) != 0)\n+\t{\n+\t  if (u == NULL)\n+\t    p = undefined;\n+\t  else\n+\t    switch (u->flags.async)\n+\t    {\n+\t      case ASYNC_YES:\n+\t\tp = \"YES\";\n+\t\tbreak;\n+\t      case ASYNC_NO:\n+\t\tp = \"NO\";\n+\t\tbreak;\n+\t      default:\n+\t\tinternal_error (&iqp->common, \"inquire_via_unit(): Bad async\");\n+\t    }\n+\n+\t  cf_strcpy (iqp->asynchronous, iqp->asynchronous_len, p);\n+\t}\n \n-  if ((cf2 & IOPARM_INQUIRE_HAS_ROUND) != 0)\n-    {\n-      if (u == NULL)\n-\tp = undefined;\n-      else\n-\tswitch (u->flags.round)\n-\t  {\n-\t  case ROUND_UP:\n-\t    p = \"UP\";\n-\t    break;\n-\t  case ROUND_DOWN:\n-\t    p = \"DOWN\";\n-\t    break;\n-\t  case ROUND_ZERO:\n-\t    p = \"ZERO\";\n-\t    break;\n-\t  case ROUND_NEAREST:\n-\t    p = \"NEAREST\";\n-\t    break;\n-\t  case ROUND_COMPATIBLE:\n-\t    p = \"COMPATIBLE\";\n-\t    break;\n-\t  case ROUND_PROCDEFINED:\n-\t    p = \"PROCESSOR_DEFINED\";\n-\t    break;\n-\t  default:\n-\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad round\");\n-\t  }\n+      if ((cf2 & IOPARM_INQUIRE_HAS_SIGN) != 0)\n+\t{\n+\t  if (u == NULL)\n+\t    p = undefined;\n+\t  else\n+\t    switch (u->flags.sign)\n+\t    {\n+\t      case SIGN_PROCDEFINED:\n+\t\tp = \"PROCESSOR_DEFINED\";\n+\t\tbreak;\n+\t      case SIGN_SUPPRESS:\n+\t\tp = \"SUPPRESS\";\n+\t\tbreak;\n+\t      case SIGN_PLUS:\n+\t\tp = \"PLUS\";\n+\t\tbreak;\n+\t      default:\n+\t\tinternal_error (&iqp->common, \"inquire_via_unit(): Bad sign\");\n+\t    }\n+\n+\t  cf_strcpy (iqp->sign, iqp->sign_len, p);\n+\t}\n \n-      cf_strcpy (iqp->round, iqp->round_len, p);\n+      if ((cf2 & IOPARM_INQUIRE_HAS_ROUND) != 0)\n+\t{\n+\t  if (u == NULL)\n+\t    p = undefined;\n+\t  else\n+\t    switch (u->flags.round)\n+\t    {\n+\t      case ROUND_UP:\n+\t\tp = \"UP\";\n+\t\tbreak;\n+\t      case ROUND_DOWN:\n+\t\tp = \"DOWN\";\n+\t\tbreak;\n+\t      case ROUND_ZERO:\n+\t\tp = \"ZERO\";\n+\t\tbreak;\n+\t      case ROUND_NEAREST:\n+\t\tp = \"NEAREST\";\n+\t\tbreak;\n+\t      case ROUND_COMPATIBLE:\n+\t\tp = \"COMPATIBLE\";\n+\t\tbreak;\n+\t      case ROUND_PROCDEFINED:\n+\t\tp = \"PROCESSOR_DEFINED\";\n+\t\tbreak;\n+\t      default:\n+\t\tinternal_error (&iqp->common, \"inquire_via_unit(): Bad round\");\n+\t    }\n+\n+\t  cf_strcpy (iqp->round, iqp->round_len, p);\n+\t}\n     }\n \n   if ((cf & IOPARM_INQUIRE_HAS_POSITION) != 0)\n@@ -581,14 +584,26 @@ inquire_via_filename (st_parameter_inquire *iqp)\n   if ((cf & IOPARM_INQUIRE_HAS_PAD) != 0)\n     cf_strcpy (iqp->pad, iqp->pad_len, undefined);\n \n-  if ((cf2 & IOPARM_INQUIRE_HAS_ENCODING) != 0)\n-    cf_strcpy (iqp->encoding, iqp->encoding_len, undefined);\n+  if (cf & IOPARM_INQUIRE_HAS_FLAGS2)\n+    {\n+      if ((cf2 & IOPARM_INQUIRE_HAS_ENCODING) != 0)\n+\tcf_strcpy (iqp->encoding, iqp->encoding_len, undefined);\n   \n-  if ((cf2 & IOPARM_INQUIRE_HAS_DELIM) != 0)\n-    cf_strcpy (iqp->delim, iqp->delim_len, undefined);\n+      if ((cf2 & IOPARM_INQUIRE_HAS_DELIM) != 0)\n+\tcf_strcpy (iqp->delim, iqp->delim_len, undefined);\n+\n+      if ((cf2 & IOPARM_INQUIRE_HAS_DECIMAL) != 0)\n+\tcf_strcpy (iqp->decimal, iqp->decimal_len, undefined);\n \n-  if ((cf2 & IOPARM_INQUIRE_HAS_DECIMAL) != 0)\n-    cf_strcpy (iqp->decimal, iqp->decimal_len, undefined);\n+      if ((cf2 & IOPARM_INQUIRE_HAS_DELIM) != 0)\n+\tcf_strcpy (iqp->delim, iqp->delim_len, undefined);\n+\n+      if ((cf2 & IOPARM_INQUIRE_HAS_PAD) != 0)\n+\tcf_strcpy (iqp->pad, iqp->pad_len, undefined);\n+  \n+      if ((cf2 & IOPARM_INQUIRE_HAS_ENCODING) != 0)\n+\tcf_strcpy (iqp->encoding, iqp->encoding_len, undefined);\n+    }\n \n   if ((cf & IOPARM_INQUIRE_HAS_POSITION) != 0)\n     cf_strcpy (iqp->position, iqp->position_len, undefined);\n@@ -613,15 +628,6 @@ inquire_via_filename (st_parameter_inquire *iqp)\n       p = inquire_read (iqp->file, iqp->file_len);\n       cf_strcpy (iqp->readwrite, iqp->readwrite_len, p);\n     }\n-\n-  if ((cf2 & IOPARM_INQUIRE_HAS_DELIM) != 0)\n-    cf_strcpy (iqp->delim, iqp->delim_len, undefined);\n-\n-  if ((cf2 & IOPARM_INQUIRE_HAS_PAD) != 0)\n-    cf_strcpy (iqp->pad, iqp->pad_len, undefined);\n-  \n-  if ((cf2 & IOPARM_INQUIRE_HAS_ENCODING) != 0)\n-    cf_strcpy (iqp->encoding, iqp->encoding_len, undefined);\n }\n \n "}, {"sha": "710224de21dec0691a152589402d0c35ebbd7b9b", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=105b7136967d687fbb900a2d25e4fe6a876db57d", "patch": "@@ -541,9 +541,6 @@ typedef struct st_parameter_44\n      kind.  */\n   char value[32];\n   gfc_offset size_used;\n-  unit_pad pad_status;\n-  unit_decimal decimal_status;\n-  unit_delim delim_status;\n } st_parameter_44;\n \n typedef struct st_parameter_dt\n@@ -646,6 +643,9 @@ typedef struct gfc_unit\n \n   unit_mode mode;\n   unit_flags flags;\n+  unit_pad pad_status;\n+  unit_decimal decimal_status;\n+  unit_delim delim_status;\n \n   /* recl                 -- Record length of the file.\n      last_record          -- Last record number read or written"}, {"sha": "bcde3e1d49b4f50cdfb3d76c631aef05a82bf957", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=105b7136967d687fbb900a2d25e4fe6a876db57d", "patch": "@@ -324,8 +324,7 @@ eat_separator (st_parameter_dt *dtp)\n   switch (c)\n     {\n     case ',':\n-      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t  && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+      if (dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n \t{\n \t  unget_char (dtp, c);\n \t  break;\n@@ -935,8 +934,8 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n     default:\n       if (dtp->u.p.namelist_mode)\n \t{\n-\t  if (dtp->u.p.delim_status == DELIM_APOSTROPHE\n-\t      || dtp->u.p.delim_status == DELIM_QUOTE\n+\t  if (dtp->u.p.current_unit->delim_status == DELIM_APOSTROPHE\n+\t      || dtp->u.p.current_unit->delim_status == DELIM_QUOTE\n \t      || c == '&' || c == '$' || c == '/')\n \t    {\n \t      unget_char (dtp, c);\n@@ -1117,8 +1116,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n       c = next_char (dtp);\n     }\n \n-  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-      && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+  if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n     c = '.';\n   \n   if (!isdigit (c) && c != '.')\n@@ -1136,8 +1134,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n-      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t  && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+      if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n \tc = '.';\n       switch (c)\n \t{\n@@ -1308,17 +1305,9 @@ read_complex (st_parameter_dt *dtp, int kind, size_t size)\n   else\n     unget_char (dtp, c);\n \n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    {\n-      if (next_char (dtp)\n-\t  !=  (dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';'))\n-\tgoto bad_complex;\n-    }\n-  else\n-    {\n-      if (next_char (dtp) != ',')\n-\tgoto bad_complex;\n-    }\n+  if (next_char (dtp)\n+      !=  (dtp->u.p.current_unit->decimal_status == DECIMAL_POINT ? ',' : ';'))\n+    goto bad_complex;\n \n eol_2:\n   eat_spaces (dtp);\n@@ -1371,8 +1360,7 @@ read_real (st_parameter_dt *dtp, int length)\n   seen_dp = 0;\n \n   c = next_char (dtp);\n-  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-      && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+  if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n     c = '.';\n   switch (c)\n     {\n@@ -1409,8 +1397,7 @@ read_real (st_parameter_dt *dtp, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n-      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t  && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+      if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n \tc = '.';\n       switch (c)\n \t{\n@@ -1476,8 +1463,7 @@ read_real (st_parameter_dt *dtp, int length)\n       c = next_char (dtp);\n     }\n \n-  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-      && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+  if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n     c = '.';\n \n   if (!isdigit (c) && c != '.')\n@@ -1502,8 +1488,7 @@ read_real (st_parameter_dt *dtp, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n-      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t  && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+      if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n \tc = '.';\n       switch (c)\n \t{"}, {"sha": "5fb1e3cb98ffa425a6b37ae2f04e7b3943eeb48b", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=105b7136967d687fbb900a2d25e4fe6a876db57d", "patch": "@@ -440,9 +440,8 @@ read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n   else\n     read_default_char1 (dtp, p, length, w);\n \n-  dtp->u.p.sf_read_comma = 1;\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    dtp->u.p.sf_read_comma = dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+  dtp->u.p.sf_read_comma =\n+    dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;\n }\n \n \n@@ -468,9 +467,8 @@ read_a_char4 (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n   else\n     read_default_char4 (dtp, p, length, w);\n   \n-  dtp->u.p.sf_read_comma = 1;\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    dtp->u.p.sf_read_comma = dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+  dtp->u.p.sf_read_comma =\n+    dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;\n }\n \n /* eat_leading_spaces()-- Given a character pointer and a width,\n@@ -842,9 +840,9 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n       switch (*p)\n \t{\n \tcase ',':\n-\t  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t      && (dtp->u.p.decimal_status == DECIMAL_COMMA && *p == ','))\n-\t\t*p = '.';\n+\t  if (dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA\n+               && *p == ',')\n+\t    *p = '.';\n \t  else\n \t    goto bad_float;\n \t  /* Fall through */\n@@ -1079,17 +1077,9 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n void\n read_x (st_parameter_dt * dtp, int n)\n {\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    {\n-      if ((dtp->u.p.pad_status == PAD_NO || is_internal_unit (dtp))\n-\t  && dtp->u.p.current_unit->bytes_left < n)\n-\tn = dtp->u.p.current_unit->bytes_left;\n-    }\n-  else\n-    {\n-      if (is_internal_unit (dtp) && dtp->u.p.current_unit->bytes_left < n)\n-\tn = dtp->u.p.current_unit->bytes_left;\n-    }\n+  if ((dtp->u.p.current_unit->pad_status == PAD_NO || is_internal_unit (dtp))\n+       && dtp->u.p.current_unit->bytes_left < n)\n+    n = dtp->u.p.current_unit->bytes_left;\n \n   dtp->u.p.sf_read_comma = 0;\n   if (n > 0)"}, {"sha": "cf93a286f981c63fb4eec7103b246e0d09388650", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=105b7136967d687fbb900a2d25e4fe6a876db57d", "patch": "@@ -264,8 +264,7 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t  /* Without padding, terminate the I/O statement without assigning\n \t     the value.  With padding, the value still needs to be assigned,\n \t     so we can just continue with a short read.  */\n-\t  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t      && dtp->u.p.pad_status == PAD_NO)\n+\t  if (dtp->u.p.current_unit->pad_status == PAD_NO)\n \t    {\n \t      if (no_error)\n \t\tbreak;\n@@ -333,8 +332,7 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n             dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n \t  else\n \t    {\n-\t      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t\t  && dtp->u.p.pad_status == PAD_NO)\n+\t      if (dtp->u.p.current_unit->pad_status == PAD_NO)\n \t\t{\n \t\t  /* Not enough data left.  */\n \t\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n@@ -381,8 +379,7 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n   if (nread != *nbytes)\n     {\t\t\t\t/* Short read, this shouldn't happen.  */\n-      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t  && dtp->u.p.pad_status == PAD_YES)\n+      if (dtp->u.p.current_unit->pad_status == PAD_YES)\n \t*nbytes = nread;\n       else\n \t{\n@@ -953,10 +950,8 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   /* Set this flag so that commas in reads cause the read to complete before\n      the entire field has been read.  The next read field will start right after\n      the comma in the stream.  (Set to 0 for character reads).  */\n-  dtp->u.p.sf_read_comma = 1;\n-\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    dtp->u.p.sf_read_comma = dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+  dtp->u.p.sf_read_comma =\n+    dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;\n \n   dtp->u.p.line_buffer = scratch;\n \n@@ -1375,12 +1370,12 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \n \tcase FMT_DC:\n \t  consume_data_flag = 0;\n-\t  dtp->u.p.decimal_status = DECIMAL_COMMA;\n+\t  dtp->u.p.current_unit->decimal_status = DECIMAL_COMMA;\n \t  break;\n \n \tcase FMT_DP:\n \t  consume_data_flag = 0;\n-\t  dtp->u.p.decimal_status = DECIMAL_POINT;\n+\t  dtp->u.p.current_unit->decimal_status = DECIMAL_POINT;\n \t  break;\n \n \tcase FMT_P:\n@@ -2073,57 +2068,52 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   if (dtp->u.p.advance_status == ADVANCE_UNSPECIFIED)\n     dtp->u.p.advance_status = ADVANCE_YES;\n \n-  /* To maintain ABI check these only if we have the F2003 flag set.  */\n-  if(cf & IOPARM_DT_HAS_F2003)\n-    {\n-      /* Check the decimal mode.  */\n-      dtp->u.p.decimal_status\n+  /* Check the decimal mode.  */\n+  dtp->u.p.current_unit->decimal_status\n \t= !(cf & IOPARM_DT_HAS_DECIMAL) ? DECIMAL_UNSPECIFIED :\n \t  find_option (&dtp->common, dtp->u.p.decimal, dtp->u.p.decimal_len,\n \t\t\tdecimal_opt, \"Bad DECIMAL parameter in data transfer \"\n \t\t\t\"statement\");\n \n-      if (dtp->u.p.decimal_status == DECIMAL_UNSPECIFIED)\n-\tdtp->u.p.decimal_status = dtp->u.p.current_unit->flags.decimal;\n+  if (dtp->u.p.current_unit->decimal_status == DECIMAL_UNSPECIFIED)\n+\tdtp->u.p.current_unit->decimal_status = dtp->u.p.current_unit->flags.decimal;\n \n-      /* Check the sign mode. */\n-      dtp->u.p.sign_status\n+  /* Check the sign mode. */\n+  dtp->u.p.sign_status\n \t= !(cf & IOPARM_DT_HAS_SIGN) ? SIGN_UNSPECIFIED :\n \t  find_option (&dtp->common, dtp->u.p.sign, dtp->u.p.sign_len, sign_opt,\n \t\t\t\"Bad SIGN parameter in data transfer statement\");\n   \n-      if (dtp->u.p.sign_status == SIGN_UNSPECIFIED)\n+  if (dtp->u.p.sign_status == SIGN_UNSPECIFIED)\n \tdtp->u.p.sign_status = dtp->u.p.current_unit->flags.sign;\n \n-      /* Check the blank mode.  */\n-      dtp->u.p.blank_status\n+  /* Check the blank mode.  */\n+  dtp->u.p.blank_status\n \t= !(cf & IOPARM_DT_HAS_BLANK) ? BLANK_UNSPECIFIED :\n \t  find_option (&dtp->common, dtp->u.p.blank, dtp->u.p.blank_len,\n \t\t\tblank_opt,\n \t\t\t\"Bad BLANK parameter in data transfer statement\");\n   \n-      if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)\n+  if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)\n \tdtp->u.p.blank_status = dtp->u.p.current_unit->flags.blank;\n   \n-      /* Check the delim mode.  */\n-      dtp->u.p.delim_status\n+  /* Check the delim mode.  */\n+  dtp->u.p.current_unit->delim_status\n \t= !(cf & IOPARM_DT_HAS_DELIM) ? DELIM_UNSPECIFIED :\n \t  find_option (&dtp->common, dtp->u.p.delim, dtp->u.p.delim_len,\n-\t\t\tdelim_opt,\n-\t\t\t\"Bad DELIM parameter in data transfer statement\");\n+\t  delim_opt, \"Bad DELIM parameter in data transfer statement\");\n   \n-      if (dtp->u.p.delim_status == DELIM_UNSPECIFIED)\n-\tdtp->u.p.delim_status = dtp->u.p.current_unit->flags.delim;\n+  if (dtp->u.p.current_unit->delim_status == DELIM_UNSPECIFIED)\n+    dtp->u.p.current_unit->delim_status = dtp->u.p.current_unit->flags.delim;\n \n-      /* Check the pad mode.  */\n-      dtp->u.p.pad_status\n+  /* Check the pad mode.  */\n+  dtp->u.p.current_unit->pad_status\n \t= !(cf & IOPARM_DT_HAS_PAD) ? PAD_UNSPECIFIED :\n \t  find_option (&dtp->common, dtp->u.p.pad, dtp->u.p.pad_len, pad_opt,\n \t\t\t\"Bad PAD parameter in data transfer statement\");\n   \n-      if (dtp->u.p.pad_status == PAD_UNSPECIFIED)\n-\tdtp->u.p.pad_status = dtp->u.p.current_unit->flags.pad;\n-    }\n+  if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)\n+\tdtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;\n \n   /* Sanity checks on the record number.  */\n   if ((cf & IOPARM_DT_HAS_REC) != 0)"}, {"sha": "020f473da7ff5e07326443769570913ef3ba50a7", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 22, "deletions": 48, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=105b7136967d687fbb900a2d25e4fe6a876db57d", "patch": "@@ -65,9 +65,7 @@ write_default_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n     }\n \n   /* Get ready to handle delimiters if needed.  */\n-  d = ' ';\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-  switch (dtp->u.p.delim_status)\n+  switch (dtp->u.p.current_unit->delim_status)\n     {\n     case DELIM_APOSTROPHE:\n       d = '\\'';\n@@ -129,9 +127,7 @@ write_utf8_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n     }\n \n   /* Get ready to handle delimiters if needed.  */\n-  d = ' ';\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-  switch (dtp->u.p.delim_status)\n+  switch (dtp->u.p.current_unit->delim_status)\n     {\n     case DELIM_APOSTROPHE:\n       d = '\\'';\n@@ -882,9 +878,7 @@ write_character (st_parameter_dt *dtp, const char *source, int kind, int length)\n   int i, extra;\n   char *p, d;\n \n-  d = ' ';\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-  switch (dtp->u.p.delim_status)\n+  switch (dtp->u.p.current_unit->delim_status)\n     {\n     case DELIM_APOSTROPHE:\n       d = '\\'';\n@@ -1022,10 +1016,8 @@ write_real_g0 (st_parameter_dt *dtp, const char *source, int length, int d)\n static void\n write_complex (st_parameter_dt *dtp, const char *source, int kind, size_t size)\n {\n-  char semi_comma = ',';\n-\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    semi_comma = dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';';\n+  char semi_comma =\n+\tdtp->u.p.current_unit->decimal_status == DECIMAL_POINT ? ',' : ';';\n \n   if (write_char (dtp, '('))\n     return;\n@@ -1072,17 +1064,9 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n     }\n   else\n     {\n-      if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t{\n-\t  if (type != BT_CHARACTER || !dtp->u.p.char_flag ||\n-\t      dtp->u.p.delim_status != DELIM_NONE)\n-\t    write_separator (dtp);\n-\t}\n-      else\n-\t{\n-          if (type != BT_CHARACTER || !dtp->u.p.char_flag)\n-\t    write_separator (dtp);\n-\t}\n+      if (type != BT_CHARACTER || !dtp->u.p.char_flag ||\n+\tdtp->u.p.current_unit->delim_status != DELIM_NONE)\n+      write_separator (dtp);\n     }\n \n   switch (type)\n@@ -1197,10 +1181,8 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   /* Set the character to be used to separate values\n      to a comma or semi-colon.  */\n \n-  char semi_comma = ',';\n-\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    semi_comma = dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';';\n+  char semi_comma =\n+\tdtp->u.p.current_unit->decimal_status == DECIMAL_POINT ? ',' : ';';\n \n   /* Write namelist variable names in upper case. If a derived type,\n      nothing is output.  If a component, base and base_name are set.  */\n@@ -1315,25 +1297,20 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n               break;\n \n \t    case GFC_DTYPE_CHARACTER:\n-\t      if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-\t\t{\n-\t\t  tmp_delim = dtp->u.p.delim_status;\n-\t\t  if (dtp->u.p.nml_delim == '\"')\n-\t\t    dtp->u.p.delim_status = DELIM_QUOTE;\n-\t\t  if (dtp->u.p.nml_delim == '\\'')\n-\t\t    dtp->u.p.delim_status = DELIM_APOSTROPHE;\n-\t\t  write_character (dtp, p, 1, obj->string_length);\n-\t\t  dtp->u.p.delim_status = tmp_delim;\n-\t\t}\n-\t      else\n-\t\twrite_character (dtp, p, 1, obj->string_length);\n+\t      tmp_delim = dtp->u.p.current_unit->delim_status;\n+\t      if (dtp->u.p.nml_delim == '\"')\n+\t\tdtp->u.p.current_unit->delim_status = DELIM_QUOTE;\n+\t      if (dtp->u.p.nml_delim == '\\'')\n+\t\tdtp->u.p.current_unit->delim_status = DELIM_APOSTROPHE;\n+\t      write_character (dtp, p, 1, obj->string_length);\n+\t\tdtp->u.p.current_unit->delim_status = tmp_delim;\n               break;\n \n \t    case GFC_DTYPE_REAL:\n \t      write_real (dtp, p, len);\n               break;\n \n-\t    case GFC_DTYPE_COMPLEX:\n+\t   case GFC_DTYPE_COMPLEX:\n \t      dtp->u.p.no_leading_blank = 0;\n \t      num++;\n               write_complex (dtp, p, len, obj_size);\n@@ -1464,9 +1441,7 @@ namelist_write (st_parameter_dt *dtp)\n   unit_delim tmp_delim = DELIM_UNSPECIFIED;\n \n   /* Set the delimiter for namelist output.  */\n-if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-  {\n-  tmp_delim = dtp->u.p.delim_status;\n+  tmp_delim = dtp->u.p.current_unit->delim_status;\n   switch (tmp_delim)\n     {\n     case (DELIM_QUOTE):\n@@ -1483,8 +1458,8 @@ if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n     }\n \n   /* Temporarily disable namelist delimters.  */\n-  dtp->u.p.delim_status = DELIM_NONE;\n-  }\n+  dtp->u.p.current_unit->delim_status = DELIM_NONE;\n+\n   write_character (dtp, \"&\", 1, 1);\n \n   /* Write namelist name in upper case - f95 std.  */\n@@ -1507,8 +1482,7 @@ if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n   write_character (dtp, \"  /\", 1, 3);\n   namelist_write_newline (dtp);\n   /* Restore the original delimiter.  */\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    dtp->u.p.delim_status = tmp_delim;\n+  dtp->u.p.current_unit->delim_status = tmp_delim;\n }\n \n #undef NML_DIGITS"}, {"sha": "0ee8f3560c4373d914caf8d3862c980826e02c6a", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b7136967d687fbb900a2d25e4fe6a876db57d/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=105b7136967d687fbb900a2d25e4fe6a876db57d", "patch": "@@ -404,10 +404,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n       out += nbefore;\n     }\n   /* Output the decimal point.  */\n-  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n-    *(out++) = dtp->u.p.decimal_status == DECIMAL_POINT ? '.' : ',';\n-  else\n-    *(out++) = '.';\n+  *(out++) = dtp->u.p.current_unit->decimal_status == DECIMAL_POINT ? '.' : ',';\n \n   /* Output leading zeros after the decimal point.  */\n   if (nzero > 0)"}]}