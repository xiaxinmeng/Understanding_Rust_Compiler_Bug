{"sha": "75df257b38bd4cdcb750fc893c5023363230cfe8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkZjI1N2IzOGJkNGNkY2I3NTBmYzg5M2M1MDIzMzYzMjMwY2ZlOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-05-12T11:28:01Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-05-12T11:28:01Z"}, "message": "Accept code attributes as rtx codes in .md files\n\nThe recent AArch64 absolute difference patterns had to go through\nsome hoops to pair max/min rtx codes with the same signedness.\nI also need to pair signed/unsigned codes with sign/zero extension\nfor some SVE ACLE patterns.\n\nThis patch therefore supports <...> as rtx codes, like we already\ndo for modes.\n\n2019-05-12  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* doc/md.texi: Document use of code attributes in rtx patterns.\n\t* read-md.h (rtx_reader::rtx_alloc_for_name): New member function.\n\t* read-rtl.c (find_code): Split out search loops into...\n\t(maybe_find_code): ...this new function.\n\t(check_code_iterator): Make the error message more informative.\n\t(check_code_attribute): New function.\n\t(rtx_reader::rtx_alloc_for_name): Likewise.\n\t(rtx_reader::read_rtx_code): Use rtx_alloc_for_name.\n\t* config/aarch64/predicates.md (aarch64_smin, aarch64_umin): Delete.\n\t* config/aarch64/aarch64-simd.md (*aarch64_<su>abd<mode>_3): Use\n\t<max_opp> directly as an rtx code instead of via a match_operator.\n\t* config/aarch64/aarch64-sve.md (aarch64_<su>abd<mode>_3): Likewise.\n\t(<su>abd<mode>_3): Update accordingly.\n\nFrom-SVN: r271107", "tree": {"sha": "c3e45e445fd98056a3ab6ec685befd4449426000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3e45e445fd98056a3ab6ec685befd4449426000"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75df257b38bd4cdcb750fc893c5023363230cfe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75df257b38bd4cdcb750fc893c5023363230cfe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75df257b38bd4cdcb750fc893c5023363230cfe8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75df257b38bd4cdcb750fc893c5023363230cfe8/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c0164573e213045052ca6bc3113d7d63cf62816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c0164573e213045052ca6bc3113d7d63cf62816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c0164573e213045052ca6bc3113d7d63cf62816"}], "stats": {"total": 188, "additions": 145, "deletions": 43}, "files": [{"sha": "1a9c8c1e181915debc1c232093dff2dc964c7ffc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75df257b38bd4cdcb750fc893c5023363230cfe8", "patch": "@@ -1,3 +1,19 @@\n+2019-05-12  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/md.texi: Document use of code attributes in rtx patterns.\n+\t* read-md.h (rtx_reader::rtx_alloc_for_name): New member function.\n+\t* read-rtl.c (find_code): Split out search loops into...\n+\t(maybe_find_code): ...this new function.\n+\t(check_code_iterator): Make the error message more informative.\n+\t(check_code_attribute): New function.\n+\t(rtx_reader::rtx_alloc_for_name): Likewise.\n+\t(rtx_reader::read_rtx_code): Use rtx_alloc_for_name.\n+\t* config/aarch64/predicates.md (aarch64_smin, aarch64_umin): Delete.\n+\t* config/aarch64/aarch64-simd.md (*aarch64_<su>abd<mode>_3): Use\n+\t<max_opp> directly as an rtx code instead of via a match_operator.\n+\t* config/aarch64/aarch64-sve.md (aarch64_<su>abd<mode>_3): Likewise.\n+\t(<su>abd<mode>_3): Update accordingly.\n+\n 2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/rs6000/rs6000.c (debug_stack_info): When -mdebug=stack"}, {"sha": "2b7a0029146df4559ea1bfc3c0090954d6923682", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=75df257b38bd4cdcb750fc893c5023363230cfe8", "patch": "@@ -716,9 +716,9 @@\n \t  (USMAX:VDQ_BHSI\n \t    (match_operand:VDQ_BHSI 1 \"register_operand\" \"w\")\n \t    (match_operand:VDQ_BHSI 2 \"register_operand\" \"w\"))\n-\t  (match_operator 3 \"aarch64_<max_opp>\"\n-\t    [(match_dup 1)\n-\t     (match_dup 2)])))]\n+\t  (<max_opp>:VDQ_BHSI\n+\t    (match_dup 1)\n+\t    (match_dup 2))))]\n   \"TARGET_SIMD\"\n   \"<su>abd\\t%0.<Vtype>, %1.<Vtype>, %2.<Vtype>\"\n   [(set_attr \"type\" \"neon_abd<q>\")]"}, {"sha": "b9cb1fae98c1e67c04a6279e615e0130fa4f68f8", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=75df257b38bd4cdcb750fc893c5023363230cfe8", "patch": "@@ -3149,18 +3149,16 @@\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n-;; Helper expander for aarch64_<su>abd<mode>_3 to save the callers\n-;; the hassle of constructing the other arm of the MINUS.\n+;; Unpredicated integer absolute difference.\n (define_expand \"<su>abd<mode>_3\"\n   [(use (match_operand:SVE_I 0 \"register_operand\"))\n    (USMAX:SVE_I (match_operand:SVE_I 1 \"register_operand\")\n \t\t(match_operand:SVE_I 2 \"register_operand\"))]\n   \"TARGET_SVE\"\n   {\n     rtx pred = force_reg (<VPRED>mode, CONSTM1_RTX (<VPRED>mode));\n-    rtx other_arm = gen_rtx_<MAX_OPP> (<MODE>mode, operands[1], operands[2]);\n     emit_insn (gen_aarch64_<su>abd<mode>_3 (operands[0], pred, operands[1],\n-\t\t\t\t\t    operands[2], other_arm));\n+\t\t\t\t\t    operands[2]));\n     DONE;\n   }\n )\n@@ -3174,9 +3172,9 @@\n \t     (USMAX:SVE_I\n \t       (match_operand:SVE_I 2 \"register_operand\" \"0, w\")\n \t       (match_operand:SVE_I 3 \"register_operand\" \"w, w\"))\n-\t     (match_operator 4 \"aarch64_<max_opp>\"\n-\t       [(match_dup 2)\n-\t\t(match_dup 3)]))]\n+\t     (<max_opp>:SVE_I\n+\t       (match_dup 2)\n+\t       (match_dup 3)))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@"}, {"sha": "10100ca830a0cd753ef5759e3ce09914b1046d26", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=75df257b38bd4cdcb750fc893c5023363230cfe8", "patch": "@@ -323,12 +323,6 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"const_scalar_int_operand\")))\n \n-(define_predicate \"aarch64_smin\"\n-  (match_code \"smin\"))\n-\n-(define_predicate \"aarch64_umin\"\n-  (match_code \"umin\"))\n-\n ;; True for integer comparisons and for FP comparisons other than LTGT or UNEQ.\n (define_special_predicate \"aarch64_comparison_operator\"\n   (match_code \"eq,ne,le,lt,ge,gt,geu,gtu,leu,ltu,unordered,"}, {"sha": "b35bcaace00f72d0c0dcd99ae2d1a739f4408067", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=75df257b38bd4cdcb750fc893c5023363230cfe8", "patch": "@@ -10979,6 +10979,27 @@ Other attributes are defined using:\n (define_code_attr @var{name} [(@var{code1} \"@var{value1}\") @dots{} (@var{coden} \"@var{valuen}\")])\n @end smallexample\n \n+Instruction patterns can use code attributes as rtx codes, which can be\n+useful if two sets of codes act in tandem.  For example, the following\n+@code{define_insn} defines two patterns, one calculating a signed absolute\n+difference and another calculating an unsigned absolute difference:\n+\n+@smallexample\n+(define_code_iterator any_max [smax umax])\n+(define_code_attr paired_min [(smax \"smin\") (umax \"umin\")])\n+(define_insn @dots{}\n+  [(set (match_operand:SI 0 @dots{})\n+        (minus:SI (any_max:SI (match_operand:SI 1 @dots{})\n+                              (match_operand:SI 2 @dots{}))\n+                  (<paired_min>:SI (match_dup 1) (match_dup 2))))]\n+  @dots{})\n+@end smallexample\n+\n+The signed version of the instruction uses @code{smax} and @code{smin}\n+while the unsigned version uses @code{umax} and @code{umin}.  There\n+are no versions that pair @code{smax} with @code{umin} or @code{umax}\n+with @code{smin}.\n+\n Here's an example of code iterators in action, taken from the MIPS port:\n \n @smallexample"}, {"sha": "327f378eac0345ffcac48d5ce157abd94e8b255f", "filename": "gcc/read-md.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=75df257b38bd4cdcb750fc893c5023363230cfe8", "patch": "@@ -337,6 +337,7 @@ class rtx_reader : public md_reader\n   ~rtx_reader ();\n \n   bool read_rtx (const char *rtx_name, vec<rtx> *rtxen);\n+  rtx rtx_alloc_for_name (const char *);\n   rtx read_rtx_code (const char *code_name);\n   virtual rtx read_rtx_operand (rtx return_rtx, int idx);\n   rtx read_nested_rtx ();"}, {"sha": "f72b2c35c7db01a90a908872154a5b109c117e64", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 99, "deletions": 27, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df257b38bd4cdcb750fc893c5023363230cfe8/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=75df257b38bd4cdcb750fc893c5023363230cfe8", "patch": "@@ -194,22 +194,31 @@ static const compact_insn_name compact_insn_names[] = {\n   { NOTE, \"cnote\" }\n };\n \n-/* Implementations of the iterator_group callbacks for codes.  */\n+/* Return the rtx code for NAME, or UNKNOWN if NAME isn't a valid rtx code.  */\n \n-static int\n-find_code (const char *name)\n+static rtx_code\n+maybe_find_code (const char *name)\n {\n-  int i;\n-\n-  for (i = 0; i < NUM_RTX_CODE; i++)\n+  for (int i = 0; i < NUM_RTX_CODE; i++)\n     if (strcmp (GET_RTX_NAME (i), name) == 0)\n-      return i;\n+      return (rtx_code) i;\n \n-  for (i = 0; i < (signed)ARRAY_SIZE (compact_insn_names); i++)\n+  for (int i = 0; i < (signed)ARRAY_SIZE (compact_insn_names); i++)\n     if (strcmp (compact_insn_names[i].name, name) == 0)\n       return compact_insn_names[i].code;\n \n-  fatal_with_file_and_line (\"unknown rtx code `%s'\", name);\n+  return UNKNOWN;\n+}\n+\n+/* Implementations of the iterator_group callbacks for codes.  */\n+\n+static int\n+find_code (const char *name)\n+{\n+  rtx_code code = maybe_find_code (name);\n+  if (code == UNKNOWN)\n+    fatal_with_file_and_line (\"unknown rtx code `%s'\", name);\n+  return code;\n }\n \n static void\n@@ -1306,7 +1315,37 @@ check_code_iterator (struct mapping *iterator)\n   for (v = iterator->values->next; v != 0; v = v->next)\n     if (strcmp (GET_RTX_FORMAT (bellwether), GET_RTX_FORMAT (v->number)) != 0)\n       fatal_with_file_and_line (\"code iterator `%s' combines \"\n-\t\t\t\t\"different rtx formats\", iterator->name);\n+\t\t\t\t\"`%s' and `%s', which have different \"\n+\t\t\t\t\"rtx formats\", iterator->name,\n+\t\t\t\tGET_RTX_NAME (bellwether),\n+\t\t\t\tGET_RTX_NAME (v->number));\n+}\n+\n+/* Check that all values of attribute ATTR are rtx codes that have a\n+   consistent format.  Return a representative code.  */\n+\n+static rtx_code\n+check_code_attribute (mapping *attr)\n+{\n+  rtx_code bellwether = UNKNOWN;\n+  for (map_value *v = attr->values; v != 0; v = v->next)\n+    {\n+      rtx_code code = maybe_find_code (v->string);\n+      if (code == UNKNOWN)\n+\tfatal_with_file_and_line (\"code attribute `%s' contains \"\n+\t\t\t\t  \"unrecognized rtx code `%s'\",\n+\t\t\t\t  attr->name, v->string);\n+      if (bellwether == UNKNOWN)\n+\tbellwether = code;\n+      else if (strcmp (GET_RTX_FORMAT (bellwether),\n+\t\t       GET_RTX_FORMAT (code)) != 0)\n+\tfatal_with_file_and_line (\"code attribute `%s' combines \"\n+\t\t\t\t  \"`%s' and `%s', which have different \"\n+\t\t\t\t  \"rtx formats\", attr->name,\n+\t\t\t\t  GET_RTX_NAME (bellwether),\n+\t\t\t\t  GET_RTX_NAME (code));\n+    }\n+  return bellwether;\n }\n \n /* Read an rtx-related declaration from the MD file, given that it\n@@ -1467,6 +1506,54 @@ parse_reg_note_name (const char *string)\n   fatal_with_file_and_line (\"unrecognized REG_NOTE name: `%s'\", string);\n }\n \n+/* Allocate an rtx for code NAME.  If NAME is a code iterator or code\n+   attribute, record its use for later and use one of its possible\n+   values as an interim rtx code.  */\n+\n+rtx\n+rtx_reader::rtx_alloc_for_name (const char *name)\n+{\n+#ifdef GENERATOR_FILE\n+  size_t len = strlen (name);\n+  if (name[0] == '<' && name[len - 1] == '>')\n+    {\n+      /* Copy the attribute string into permanent storage, without the\n+\t angle brackets around it.  */\n+      obstack *strings = get_string_obstack ();\n+      obstack_grow0 (strings, name + 1, len - 2);\n+      char *deferred_name = XOBFINISH (strings, char *);\n+\n+      /* Find the name of the attribute.  */\n+      const char *attr = strchr (deferred_name, ':');\n+      if (!attr)\n+\tattr = deferred_name;\n+\n+      /* Find the attribute itself.  */\n+      mapping *m = (mapping *) htab_find (codes.attrs, &attr);\n+      if (!m)\n+\tfatal_with_file_and_line (\"unknown code attribute `%s'\", attr);\n+\n+      /* Pick the first possible code for now, and record the attribute\n+\t use for later.  */\n+      rtx x = rtx_alloc (check_code_attribute (m));\n+      record_attribute_use (&codes, x, 0, deferred_name);\n+      return x;\n+    }\n+\n+  mapping *iterator = (mapping *) htab_find (codes.iterators, &name);\n+  if (iterator != 0)\n+    {\n+      /* Pick the first possible code for now, and record the iterator\n+\t use for later.  */\n+      rtx x = rtx_alloc (rtx_code (iterator->values->number));\n+      record_iterator_use (iterator, x, 0);\n+      return x;\n+    }\n+#endif\n+\n+  return rtx_alloc (rtx_code (codes.find_builtin (name)));\n+}\n+\n /* Subroutine of read_rtx and read_nested_rtx.  CODE_NAME is the name of\n    either an rtx code or a code iterator.  Parse the rest of the rtx and\n    return it.  */\n@@ -1475,7 +1562,6 @@ rtx\n rtx_reader::read_rtx_code (const char *code_name)\n {\n   RTX_CODE code;\n-  struct mapping *iterator = NULL;\n   const char *format_ptr;\n   struct md_name name;\n   rtx return_rtx;\n@@ -1509,20 +1595,9 @@ rtx_reader::read_rtx_code (const char *code_name)\n       return return_rtx;\n     }\n \n-  /* If this code is an iterator, build the rtx using the iterator's\n-     first value.  */\n-#ifdef GENERATOR_FILE\n-  iterator = (struct mapping *) htab_find (codes.iterators, &code_name);\n-  if (iterator != 0)\n-    code = (enum rtx_code) iterator->values->number;\n-  else\n-    code = (enum rtx_code) codes.find_builtin (code_name);\n-#else\n-    code = (enum rtx_code) codes.find_builtin (code_name);\n-#endif\n-\n   /* If we end up with an insn expression then we free this space below.  */\n-  return_rtx = rtx_alloc (code);\n+  return_rtx = rtx_alloc_for_name (code_name);\n+  code = GET_CODE (return_rtx);\n   format_ptr = GET_RTX_FORMAT (code);\n   memset (return_rtx, 0, RTX_CODE_SIZE (code));\n   PUT_CODE (return_rtx, code);\n@@ -1534,9 +1609,6 @@ rtx_reader::read_rtx_code (const char *code_name)\n       m_reuse_rtx_by_id[reuse_id] = return_rtx;\n     }\n \n-  if (iterator)\n-    record_iterator_use (iterator, return_rtx, 0);\n-\n   /* Check for flags. */\n   read_flags (return_rtx);\n "}]}