{"sha": "124f60ab29f46aefdf892a4fcf981e4e292eb08c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI0ZjYwYWIyOWY0NmFlZmRmODkyYTRmY2Y5ODFlNGUyOTJlYjA4Yw==", "commit": {"author": {"name": "Bradley Smith", "email": "brad@brad-smith.co.uk", "date": "2009-12-26T04:21:07Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2009-12-26T04:21:07Z"}, "message": "avr32 libffi port\n\nFrom-SVN: r155469", "tree": {"sha": "984389db502cb8627d3aa23e9674f5c9aefa6d7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/984389db502cb8627d3aa23e9674f5c9aefa6d7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/124f60ab29f46aefdf892a4fcf981e4e292eb08c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124f60ab29f46aefdf892a4fcf981e4e292eb08c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/124f60ab29f46aefdf892a4fcf981e4e292eb08c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124f60ab29f46aefdf892a4fcf981e4e292eb08c/comments", "author": {"login": "brads55", "id": 8070284, "node_id": "MDQ6VXNlcjgwNzAyODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8070284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brads55", "html_url": "https://github.com/brads55", "followers_url": "https://api.github.com/users/brads55/followers", "following_url": "https://api.github.com/users/brads55/following{/other_user}", "gists_url": "https://api.github.com/users/brads55/gists{/gist_id}", "starred_url": "https://api.github.com/users/brads55/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brads55/subscriptions", "organizations_url": "https://api.github.com/users/brads55/orgs", "repos_url": "https://api.github.com/users/brads55/repos", "events_url": "https://api.github.com/users/brads55/events{/privacy}", "received_events_url": "https://api.github.com/users/brads55/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8b9b505f2700ba50e83636ba98d87c4e86c9790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8b9b505f2700ba50e83636ba98d87c4e86c9790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8b9b505f2700ba50e83636ba98d87c4e86c9790"}], "stats": {"total": 790, "additions": 763, "deletions": 27}, "files": [{"sha": "01052cd4fe0b9d005ad4316e3d885d36702855ae", "filename": "libffi/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=124f60ab29f46aefdf892a4fcf981e4e292eb08c", "patch": "@@ -1,3 +1,10 @@\n+2009-12-25  Bradley Smith  <brad@brad-smith.co.uk>\n+\n+\t* configure.ac, Makefile.am, src/avr32/ffi.c,\n+\tsrc/avr32/ffitarget.h,\n+\tsrc/avr32/sysv.S: Add AVR32 port.\n+\t* configure, Makefile.in: Rebuilt.\n+\n 2009-12-21  Andreas Tobler  <a.tobler@schweiz.org>\n \n \t* configure.ac: Make i?86 build on FreeBSD and OpenBSD."}, {"sha": "98b34acfa4ab189a22ebd45c2211295a441bddff", "filename": "libffi/Makefile.am", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=124f60ab29f46aefdf892a4fcf981e4e292eb08c", "patch": "@@ -8,6 +8,7 @@ SUBDIRS = include testsuite man\n EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host \\\n \tsrc/alpha/ffi.c src/alpha/osf.S src/alpha/ffitarget.h \\\n \tsrc/arm/ffi.c src/arm/sysv.S src/arm/ffitarget.h \\\n+\tsrc/avr32/ffi.c src/avr32/sysv.S src/avr32/ffitarget.h \\\n \tsrc/cris/ffi.c src/cris/sysv.S src/cris/ffitarget.h \\\n \tsrc/ia64/ffi.c src/ia64/ffitarget.h src/ia64/ia64_flags.h \\\n \tsrc/ia64/unix.S \\\n@@ -132,6 +133,9 @@ endif\n if ARM\n nodist_libffi_la_SOURCES += src/arm/sysv.S src/arm/ffi.c\n endif\n+if AVR32\n+nodist_libffi_la_SOURCES += src/avr32/sysv.S src/avr32/ffi.c\n+endif\n if LIBFFI_CRIS\n nodist_libffi_la_SOURCES += src/cris/sysv.S src/cris/ffi.c\n endif"}, {"sha": "e5ef5413b5f3df06750d943f42e667bfde85bc39", "filename": "libffi/Makefile.in", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=124f60ab29f46aefdf892a4fcf981e4e292eb08c", "patch": "@@ -51,14 +51,15 @@ target_triplet = @target@\n @POWERPC_DARWIN_TRUE@am__append_14 = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n @POWERPC_FREEBSD_TRUE@am__append_15 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n @ARM_TRUE@am__append_16 = src/arm/sysv.S src/arm/ffi.c\n-@LIBFFI_CRIS_TRUE@am__append_17 = src/cris/sysv.S src/cris/ffi.c\n-@FRV_TRUE@am__append_18 = src/frv/eabi.S src/frv/ffi.c\n-@S390_TRUE@am__append_19 = src/s390/sysv.S src/s390/ffi.c\n-@X86_64_TRUE@am__append_20 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n-@SH_TRUE@am__append_21 = src/sh/sysv.S src/sh/ffi.c\n-@SH64_TRUE@am__append_22 = src/sh64/sysv.S src/sh64/ffi.c\n-@PA_LINUX_TRUE@am__append_23 = src/pa/linux.S src/pa/ffi.c\n-@PA_HPUX_TRUE@am__append_24 = src/pa/hpux32.S src/pa/ffi.c\n+@AVR32_TRUE@am__append_17 = src/avr32/sysv.S src/avr32/ffi.c\n+@LIBFFI_CRIS_TRUE@am__append_18 = src/cris/sysv.S src/cris/ffi.c\n+@FRV_TRUE@am__append_19 = src/frv/eabi.S src/frv/ffi.c\n+@S390_TRUE@am__append_20 = src/s390/sysv.S src/s390/ffi.c\n+@X86_64_TRUE@am__append_21 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n+@SH_TRUE@am__append_22 = src/sh/sysv.S src/sh/ffi.c\n+@SH64_TRUE@am__append_23 = src/sh64/sysv.S src/sh64/ffi.c\n+@PA_LINUX_TRUE@am__append_24 = src/pa/linux.S src/pa/ffi.c\n+@PA_HPUX_TRUE@am__append_25 = src/pa/hpux32.S src/pa/ffi.c\n subdir = .\n DIST_COMMON = README $(am__configure_deps) $(srcdir)/../compile \\\n \t$(srcdir)/../config.guess $(srcdir)/../config.sub \\\n@@ -139,15 +140,16 @@ am_libffi_la_OBJECTS = src/debug.lo src/prep_cif.lo src/types.lo \\\n @POWERPC_FREEBSD_TRUE@\tsrc/powerpc/sysv.lo \\\n @POWERPC_FREEBSD_TRUE@\tsrc/powerpc/ppc_closure.lo\n @ARM_TRUE@am__objects_16 = src/arm/sysv.lo src/arm/ffi.lo\n-@LIBFFI_CRIS_TRUE@am__objects_17 = src/cris/sysv.lo src/cris/ffi.lo\n-@FRV_TRUE@am__objects_18 = src/frv/eabi.lo src/frv/ffi.lo\n-@S390_TRUE@am__objects_19 = src/s390/sysv.lo src/s390/ffi.lo\n-@X86_64_TRUE@am__objects_20 = src/x86/ffi64.lo src/x86/unix64.lo \\\n+@AVR32_TRUE@am__objects_17 = src/avr32/sysv.lo src/avr32/ffi.lo\n+@LIBFFI_CRIS_TRUE@am__objects_18 = src/cris/sysv.lo src/cris/ffi.lo\n+@FRV_TRUE@am__objects_19 = src/frv/eabi.lo src/frv/ffi.lo\n+@S390_TRUE@am__objects_20 = src/s390/sysv.lo src/s390/ffi.lo\n+@X86_64_TRUE@am__objects_21 = src/x86/ffi64.lo src/x86/unix64.lo \\\n @X86_64_TRUE@\tsrc/x86/ffi.lo src/x86/sysv.lo\n-@SH_TRUE@am__objects_21 = src/sh/sysv.lo src/sh/ffi.lo\n-@SH64_TRUE@am__objects_22 = src/sh64/sysv.lo src/sh64/ffi.lo\n-@PA_LINUX_TRUE@am__objects_23 = src/pa/linux.lo src/pa/ffi.lo\n-@PA_HPUX_TRUE@am__objects_24 = src/pa/hpux32.lo src/pa/ffi.lo\n+@SH_TRUE@am__objects_22 = src/sh/sysv.lo src/sh/ffi.lo\n+@SH64_TRUE@am__objects_23 = src/sh64/sysv.lo src/sh64/ffi.lo\n+@PA_LINUX_TRUE@am__objects_24 = src/pa/linux.lo src/pa/ffi.lo\n+@PA_HPUX_TRUE@am__objects_25 = src/pa/hpux32.lo src/pa/ffi.lo\n nodist_libffi_la_OBJECTS = $(am__objects_1) $(am__objects_2) \\\n \t$(am__objects_3) $(am__objects_4) $(am__objects_5) \\\n \t$(am__objects_6) $(am__objects_7) $(am__objects_8) \\\n@@ -156,25 +158,26 @@ nodist_libffi_la_OBJECTS = $(am__objects_1) $(am__objects_2) \\\n \t$(am__objects_15) $(am__objects_16) $(am__objects_17) \\\n \t$(am__objects_18) $(am__objects_19) $(am__objects_20) \\\n \t$(am__objects_21) $(am__objects_22) $(am__objects_23) \\\n-\t$(am__objects_24)\n+\t$(am__objects_24) $(am__objects_25)\n libffi_la_OBJECTS = $(am_libffi_la_OBJECTS) \\\n \t$(nodist_libffi_la_OBJECTS)\n libffi_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n \t$(libffi_la_LDFLAGS) $(LDFLAGS) -o $@\n libffi_convenience_la_LIBADD =\n-am__objects_25 = src/debug.lo src/prep_cif.lo src/types.lo \\\n+am__objects_26 = src/debug.lo src/prep_cif.lo src/types.lo \\\n \tsrc/raw_api.lo src/java_raw_api.lo src/closures.lo\n-am_libffi_convenience_la_OBJECTS = $(am__objects_25)\n-am__objects_26 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n+am_libffi_convenience_la_OBJECTS = $(am__objects_26)\n+am__objects_27 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n \t$(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n \t$(am__objects_16) $(am__objects_17) $(am__objects_18) \\\n \t$(am__objects_19) $(am__objects_20) $(am__objects_21) \\\n-\t$(am__objects_22) $(am__objects_23) $(am__objects_24)\n-nodist_libffi_convenience_la_OBJECTS = $(am__objects_26)\n+\t$(am__objects_22) $(am__objects_23) $(am__objects_24) \\\n+\t$(am__objects_25)\n+nodist_libffi_convenience_la_OBJECTS = $(am__objects_27)\n libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \\\n \t$(nodist_libffi_convenience_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -388,6 +391,7 @@ SUBDIRS = include testsuite man\n EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host \\\n \tsrc/alpha/ffi.c src/alpha/osf.S src/alpha/ffitarget.h \\\n \tsrc/arm/ffi.c src/arm/sysv.S src/arm/ffitarget.h \\\n+\tsrc/avr32/ffi.c src/avr32/sysv.S src/avr32/ffitarget.h \\\n \tsrc/cris/ffi.c src/cris/sysv.S src/cris/ffitarget.h \\\n \tsrc/ia64/ffi.c src/ia64/ffitarget.h src/ia64/ia64_flags.h \\\n \tsrc/ia64/unix.S \\\n@@ -463,7 +467,7 @@ nodist_libffi_la_SOURCES = $(am__append_1) $(am__append_2) \\\n \t$(am__append_15) $(am__append_16) $(am__append_17) \\\n \t$(am__append_18) $(am__append_19) $(am__append_20) \\\n \t$(am__append_21) $(am__append_22) $(am__append_23) \\\n-\t$(am__append_24)\n+\t$(am__append_24) $(am__append_25)\n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)\n AM_CFLAGS = -Wall -g -fexceptions\n@@ -701,6 +705,16 @@ src/arm/sysv.lo: src/arm/$(am__dirstamp) \\\n \tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n src/arm/ffi.lo: src/arm/$(am__dirstamp) \\\n \tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n+src/avr32/$(am__dirstamp):\n+\t@$(MKDIR_P) src/avr32\n+\t@: > src/avr32/$(am__dirstamp)\n+src/avr32/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/avr32/$(DEPDIR)\n+\t@: > src/avr32/$(DEPDIR)/$(am__dirstamp)\n+src/avr32/sysv.lo: src/avr32/$(am__dirstamp) \\\n+\tsrc/avr32/$(DEPDIR)/$(am__dirstamp)\n+src/avr32/ffi.lo: src/avr32/$(am__dirstamp) \\\n+\tsrc/avr32/$(DEPDIR)/$(am__dirstamp)\n src/cris/$(am__dirstamp):\n \t@$(MKDIR_P) src/cris\n \t@: > src/cris/$(am__dirstamp)\n@@ -778,6 +792,10 @@ mostlyclean-compile:\n \t-rm -f src/arm/ffi.lo\n \t-rm -f src/arm/sysv.$(OBJEXT)\n \t-rm -f src/arm/sysv.lo\n+\t-rm -f src/avr32/ffi.$(OBJEXT)\n+\t-rm -f src/avr32/ffi.lo\n+\t-rm -f src/avr32/sysv.$(OBJEXT)\n+\t-rm -f src/avr32/sysv.lo\n \t-rm -f src/closures.$(OBJEXT)\n \t-rm -f src/closures.lo\n \t-rm -f src/cris/ffi.$(OBJEXT)\n@@ -892,6 +910,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@src/alpha/$(DEPDIR)/osf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/sysv.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/avr32/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/avr32/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/cris/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/cris/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/frv/$(DEPDIR)/eabi.Plo@am__quote@\n@@ -993,6 +1013,7 @@ clean-libtool:\n \t-rm -rf src/.libs src/_libs\n \t-rm -rf src/alpha/.libs src/alpha/_libs\n \t-rm -rf src/arm/.libs src/arm/_libs\n+\t-rm -rf src/avr32/.libs src/avr32/_libs\n \t-rm -rf src/cris/.libs src/cris/_libs\n \t-rm -rf src/frv/.libs src/frv/_libs\n \t-rm -rf src/ia64/.libs src/ia64/_libs\n@@ -1371,6 +1392,8 @@ distclean-generic:\n \t-rm -f src/alpha/$(am__dirstamp)\n \t-rm -f src/arm/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/arm/$(am__dirstamp)\n+\t-rm -f src/avr32/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/avr32/$(am__dirstamp)\n \t-rm -f src/cris/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/cris/$(am__dirstamp)\n \t-rm -f src/frv/$(DEPDIR)/$(am__dirstamp)\n@@ -1408,7 +1431,7 @@ clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n \n distclean: distclean-multi distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf src/$(DEPDIR) src/alpha/$(DEPDIR) src/arm/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/mips/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/x86/$(DEPDIR)\n+\t-rm -rf src/$(DEPDIR) src/alpha/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/mips/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/x86/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-hdr distclean-libtool distclean-tags\n@@ -1456,7 +1479,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf src/$(DEPDIR) src/alpha/$(DEPDIR) src/arm/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/mips/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/x86/$(DEPDIR)\n+\t-rm -rf src/$(DEPDIR) src/alpha/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/mips/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/x86/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n "}, {"sha": "f8456c9f4b70e0fafac7a635989ffdd0b6648dc6", "filename": "libffi/configure", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=124f60ab29f46aefdf892a4fcf981e4e292eb08c", "patch": "@@ -628,6 +628,8 @@ FRV_FALSE\n FRV_TRUE\n LIBFFI_CRIS_FALSE\n LIBFFI_CRIS_TRUE\n+AVR32_FALSE\n+AVR32_TRUE\n ARM_FALSE\n ARM_TRUE\n POWERPC_FREEBSD_FALSE\n@@ -10771,7 +10773,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10774 \"configure\"\n+#line 10776 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -10877,7 +10879,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10880 \"configure\"\n+#line 10882 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11329,6 +11331,10 @@ case \"$host\" in\n \tTARGET=X86_64; TARGETDIR=x86\n \t;;\n \n+  avr32*-*-*)\n+\tTARGET=AVR32; TARGETDIR=avr32\n+\t;;\n+\n   cris-*-*)\n \tTARGET=LIBFFI_CRIS; TARGETDIR=cris\n \t;;\n@@ -11563,6 +11569,14 @@ else\n   ARM_FALSE=\n fi\n \n+ if test x$TARGET = xAVR32; then\n+  AVR32_TRUE=\n+  AVR32_FALSE='#'\n+else\n+  AVR32_TRUE='#'\n+  AVR32_FALSE=\n+fi\n+\n  if test x$TARGET = xLIBFFI_CRIS; then\n   LIBFFI_CRIS_TRUE=\n   LIBFFI_CRIS_FALSE='#'\n@@ -12723,6 +12737,10 @@ if test -z \"${ARM_TRUE}\" && test -z \"${ARM_FALSE}\"; then\n   as_fn_error \"conditional \\\"ARM\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${AVR32_TRUE}\" && test -z \"${AVR32_FALSE}\"; then\n+  as_fn_error \"conditional \\\"AVR32\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${LIBFFI_CRIS_TRUE}\" && test -z \"${LIBFFI_CRIS_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBFFI_CRIS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "a1a016cf08271584578a1e69a54277c755502647", "filename": "libffi/configure.ac", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=124f60ab29f46aefdf892a4fcf981e4e292eb08c", "patch": "@@ -55,6 +55,10 @@ case \"$host\" in\n \tTARGET=X86_64; TARGETDIR=x86\n \t;;\n \n+  avr32*-*-*)\n+\tTARGET=AVR32; TARGETDIR=avr32\n+\t;;\n+\n   cris-*-*)\n \tTARGET=LIBFFI_CRIS; TARGETDIR=cris\n \t;;\n@@ -177,6 +181,7 @@ AM_CONDITIONAL(POWERPC_AIX, test x$TARGET = xPOWERPC_AIX)\n AM_CONDITIONAL(POWERPC_DARWIN, test x$TARGET = xPOWERPC_DARWIN)\n AM_CONDITIONAL(POWERPC_FREEBSD, test x$TARGET = xPOWERPC_FREEBSD)\n AM_CONDITIONAL(ARM, test x$TARGET = xARM)\n+AM_CONDITIONAL(AVR32, test x$TARGET = xAVR32)\n AM_CONDITIONAL(LIBFFI_CRIS, test x$TARGET = xLIBFFI_CRIS)\n AM_CONDITIONAL(FRV, test x$TARGET = xFRV)\n AM_CONDITIONAL(S390, test x$TARGET = xS390)"}, {"sha": "39fba2b03b6d259dacd5e68cd6773949ae90412b", "filename": "libffi/src/avr32/ffi.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fsrc%2Favr32%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fsrc%2Favr32%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Favr32%2Fffi.c?ref=124f60ab29f46aefdf892a4fcf981e4e292eb08c", "patch": "@@ -0,0 +1,421 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>\n+\n+   AVR32 Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <asm/unistd.h>\n+\n+/* #define DEBUG */\n+\n+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n+    unsigned int, unsigned int, unsigned int*, unsigned int,\n+    void (*fn)(void));\n+extern void ffi_closure_SYSV (ffi_closure *);\n+\n+unsigned int pass_struct_on_stack(ffi_type *type)\n+{\n+    if(type->type != FFI_TYPE_STRUCT)\n+        return 0;\n+\n+    if(type->alignment < type->size &&\n+        !(type->size == 4 || type->size == 8) &&\n+        !(type->size == 8 && type->alignment >= 4))\n+        return 1;\n+\n+    if(type->size == 3 || type->size == 5 || type->size == 6 ||\n+        type->size == 7)\n+        return 1;\n+\n+    return 0;\n+}\n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+ * has been allocated for the function's arguments\n+ *\n+ * This is annoyingly complex since we need to keep track of used\n+ * registers.\n+ */\n+\n+void ffi_prep_args(char *stack, extended_cif *ecif)\n+{\n+    unsigned int i;\n+    void **p_argv;\n+    ffi_type **p_arg;\n+    char *reg_base = stack;\n+    char *stack_base = stack + 20;\n+    unsigned int stack_offset = 0;\n+    unsigned int reg_mask = 0;\n+\n+    p_argv = ecif->avalue;\n+\n+    /* If cif->flags is struct then we know it's not passed in registers */\n+    if(ecif->cif->flags == FFI_TYPE_STRUCT)\n+    {\n+        *(void**)reg_base = ecif->rvalue;\n+        reg_mask |= 1;\n+    }\n+\n+    for(i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs;\n+        i++, p_arg++)\n+    {\n+        size_t z = (*p_arg)->size;\n+        int alignment = (*p_arg)->alignment;\n+        int type = (*p_arg)->type;\n+        char *addr = 0;\n+\n+        if(z % 4 != 0)\n+            z += (4 - z % 4);\n+\n+        if(reg_mask != 0x1f)\n+        {\n+            if(pass_struct_on_stack(*p_arg))\n+            {\n+                addr = stack_base + stack_offset;\n+                stack_offset += z;\n+            }\n+            else if(z == sizeof(int))\n+            {\n+                char index = 0;\n+\n+                while((reg_mask >> index) & 1)\n+                    index++;\n+\n+                addr = reg_base + (index * 4);\n+                reg_mask |= (1 << index);\n+            }\n+            else if(z == 2 * sizeof(int))\n+            {\n+                if(!((reg_mask >> 1) & 1))\n+                {\n+                    addr = reg_base + 4;\n+                    reg_mask |= (3 << 1);\n+                }\n+                else if(!((reg_mask >> 3) & 1))\n+                {\n+                    addr = reg_base + 12;\n+                    reg_mask |= (3 << 3);\n+                }\n+            }\n+        }\n+\n+        if(!addr)\n+        {\n+            addr = stack_base + stack_offset;\n+            stack_offset += z;\n+        }\n+\n+        if(type == FFI_TYPE_STRUCT && (*p_arg)->elements[1] == NULL)\n+            type = (*p_arg)->elements[0]->type;\n+\n+        switch(type)\n+        {\n+        case FFI_TYPE_UINT8:\n+            *(unsigned int *)addr = (unsigned int)*(UINT8 *)(*p_argv);\n+            break;\n+        case FFI_TYPE_SINT8:\n+            *(signed int *)addr = (signed int)*(SINT8 *)(*p_argv);\n+            break;\n+        case FFI_TYPE_UINT16:\n+            *(unsigned int *)addr = (unsigned int)*(UINT16 *)(*p_argv);\n+            break;\n+        case FFI_TYPE_SINT16:\n+            *(signed int *)addr = (signed int)*(SINT16 *)(*p_argv);\n+            break;\n+        default:\n+            memcpy(addr, *p_argv, z);\n+        }\n+\n+        p_argv++;\n+    }\n+\n+#ifdef DEBUG\n+    /* Debugging */\n+    for(i = 0; i < 5; i++)\n+    {\n+        if((reg_mask & (1 << i)) == 0)\n+            printf(\"r%d: (unused)\\n\", 12 - i);\n+        else\n+            printf(\"r%d: 0x%08x\\n\", 12 - i, ((unsigned int*)reg_base)[i]);\n+    }\n+\n+    for(i = 0; i < stack_offset / 4; i++)\n+    {\n+        printf(\"sp+%d: 0x%08x\\n\", i*4, ((unsigned int*)stack_base)[i]);\n+    }\n+#endif\n+}\n+\n+/* Perform machine dependent cif processing */\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+    /* Round the stack up to a multiple of 8 bytes.  This isn't needed\n+     * everywhere, but it is on some platforms, and it doesn't harm\n+     * anything when it isn't needed. */\n+    cif->bytes = (cif->bytes + 7) & ~7;\n+\n+    /* Flag to indicate that he return value is in fact a struct */\n+    cif->rstruct_flag = 0;\n+\n+    /* Set the return type flag */\n+    switch(cif->rtype->type)\n+    {\n+    case FFI_TYPE_SINT8:\n+    case FFI_TYPE_UINT8:\n+        cif->flags = (unsigned)FFI_TYPE_UINT8;\n+        break;\n+    case FFI_TYPE_SINT16:\n+    case FFI_TYPE_UINT16:\n+        cif->flags = (unsigned)FFI_TYPE_UINT16;\n+        break;\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_POINTER:\n+        cif->flags = (unsigned)FFI_TYPE_UINT32;\n+        break;\n+    case FFI_TYPE_DOUBLE:\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+        cif->flags = (unsigned)FFI_TYPE_UINT64;\n+        break;\n+    case FFI_TYPE_STRUCT:\n+        cif->rstruct_flag = 1;\n+        if(!pass_struct_on_stack(cif->rtype))\n+        {\n+            if(cif->rtype->size <= 1)\n+                cif->flags = (unsigned)FFI_TYPE_UINT8;\n+            else if(cif->rtype->size <= 2)\n+                cif->flags = (unsigned)FFI_TYPE_UINT16;\n+            else if(cif->rtype->size <= 4)\n+                cif->flags = (unsigned)FFI_TYPE_UINT32;\n+            else if(cif->rtype->size <= 8)\n+                cif->flags = (unsigned)FFI_TYPE_UINT64;\n+            else\n+                cif->flags = (unsigned)cif->rtype->type;\n+        }\n+        else\n+            cif->flags = (unsigned)cif->rtype->type;\n+        break;\n+    default:\n+        cif->flags = (unsigned)cif->rtype->type;\n+        break;\n+    }\n+\n+    return FFI_OK;\n+}\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+    extended_cif ecif;\n+\n+    unsigned int size = 0, i = 0;\n+    ffi_type **p_arg;\n+\n+    ecif.cif = cif;\n+    ecif.avalue = avalue;\n+\n+    for(i = 0, p_arg = cif->arg_types; i < cif->nargs; i++, p_arg++)\n+        size += (*p_arg)->size + (4 - (*p_arg)->size % 4);\n+\n+    /* If the return value is a struct and we don't have a return value\n+     * address then we need to make one */\n+\n+    /* If cif->flags is struct then it's not suitable for registers */\n+    if((rvalue == NULL) && (cif->flags == FFI_TYPE_STRUCT))\n+        ecif.rvalue = alloca(cif->rtype->size);\n+    else\n+        ecif.rvalue = rvalue;\n+\n+    switch(cif->abi)\n+    {\n+    case FFI_SYSV:\n+        ffi_call_SYSV(ffi_prep_args, &ecif, size, cif->flags,\n+            ecif.rvalue, cif->rstruct_flag, fn);\n+        break;\n+    default:\n+        FFI_ASSERT(0);\n+        break;\n+    }\n+}\n+\n+static void ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n+    void **avalue, ffi_cif *cif)\n+{\n+    register unsigned int i, reg_mask = 0;\n+    register void **p_argv;\n+    register ffi_type **p_arg;\n+    register char *reg_base = stack;\n+    register char *stack_base = stack + 20;\n+    register unsigned int stack_offset = 0;\n+\n+#ifdef DEBUG\n+    /* Debugging */\n+    for(i = 0; i < cif->nargs + 7; i++)\n+    {\n+        printf(\"sp+%d: 0x%08x\\n\", i*4, ((unsigned int*)stack)[i]);\n+    }\n+#endif\n+\n+    /* If cif->flags is struct then we know it's not passed in registers */\n+    if(cif->flags == FFI_TYPE_STRUCT)\n+    {\n+        *rvalue = *(void **)reg_base;\n+        reg_mask |= 1;\n+    }\n+\n+    p_argv = avalue;\n+\n+    for(i = 0, p_arg = cif->arg_types; i < cif->nargs; i++, p_arg++)\n+    {\n+        size_t z = (*p_arg)->size;\n+        int alignment = (*p_arg)->alignment;\n+\n+        *p_argv = 0;\n+\n+        if(z % 4 != 0)\n+            z += (4 - z % 4);\n+\n+        if(reg_mask != 0x1f)\n+        {\n+            if(pass_struct_on_stack(*p_arg))\n+            {\n+                *p_argv = (void*)stack_base + stack_offset;\n+                stack_offset += z;\n+            }\n+            else if(z <= sizeof(int))\n+            {\n+                char index = 0;\n+\n+                while((reg_mask >> index) & 1)\n+                    index++;\n+\n+                *p_argv = (void*)reg_base + (index * 4);\n+                reg_mask |= (1 << index);\n+            }\n+            else if(z == 2 * sizeof(int))\n+            {\n+                if(!((reg_mask >> 1) & 1))\n+                {\n+                    *p_argv = (void*)reg_base + 4;\n+                    reg_mask |= (3 << 1);\n+                }\n+                else if(!((reg_mask >> 3) & 1))\n+                {\n+                    *p_argv = (void*)reg_base + 12;\n+                    reg_mask |= (3 << 3);\n+                }\n+            }\n+        }\n+\n+        if(!*p_argv)\n+        {\n+            *p_argv = (void*)stack_base + stack_offset;\n+            stack_offset += z;\n+        }\n+\n+        if((*p_arg)->type != FFI_TYPE_STRUCT ||\n+            (*p_arg)->elements[1] == NULL)\n+        {\n+            if(alignment == 1)\n+                **(unsigned int**)p_argv <<= 24;\n+            else if(alignment == 2)\n+                **(unsigned int**)p_argv <<= 16;\n+        }\n+\n+        p_argv++;\n+    }\n+\n+#ifdef DEBUG\n+    /* Debugging */\n+    for(i = 0; i < cif->nargs; i++)\n+    {\n+        printf(\"sp+%d: 0x%08x\\n\", i*4, *(((unsigned int**)avalue)[i]));\n+    }\n+#endif\n+}\n+\n+/* This function is jumped to by the trampoline */\n+\n+unsigned int ffi_closure_SYSV_inner(ffi_closure *closure, void **respp,\n+    void *args)\n+{\n+    ffi_cif *cif;\n+    void **arg_area;\n+    unsigned int i, size = 0;\n+    ffi_type **p_arg;\n+\n+    cif = closure->cif;\n+\n+    for(i = 0, p_arg = cif->arg_types; i < cif->nargs; i++, p_arg++)\n+        size += (*p_arg)->size + (4 - (*p_arg)->size % 4);\n+\n+    arg_area = (void **)alloca(size);\n+\n+    /* this call will initialize ARG_AREA, such that each element in that\n+     * array points to the corresponding value on the stack; and if the\n+     * function returns a structure, it will re-set RESP to point to the\n+     * structure return address. */\n+\n+    ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif);\n+\n+    (closure->fun)(cif, *respp, arg_area, closure->user_data);\n+\n+    return cif->flags;\n+}\n+\n+ffi_status ffi_prep_closure_loc(ffi_closure* closure, ffi_cif* cif,\n+    void (*fun)(ffi_cif*, void*, void**, void*), void *user_data,\n+    void *codeloc)\n+{\n+    FFI_ASSERT(cif->abi == FFI_SYSV);\n+\n+    unsigned char *__tramp = (unsigned char*)(&closure->tramp[0]);\n+    unsigned int  __fun = (unsigned int)(&ffi_closure_SYSV);\n+    unsigned int  __ctx = (unsigned int)(codeloc);\n+    unsigned int  __rstruct_flag = (unsigned int)(cif->rstruct_flag);\n+    unsigned int  __inner = (unsigned int)(&ffi_closure_SYSV_inner);\n+    *(unsigned int*) &__tramp[0] = 0xebcd1f00;    /* pushm  r8-r12 */\n+    *(unsigned int*) &__tramp[4] = 0xfefc0010;    /* ld.w   r12, pc[16] */\n+    *(unsigned int*) &__tramp[8] = 0xfefb0010;    /* ld.w   r11, pc[16] */\n+    *(unsigned int*) &__tramp[12] = 0xfefa0010;   /* ld.w   r10, pc[16] */\n+    *(unsigned int*) &__tramp[16] = 0xfeff0010;   /* ld.w   pc, pc[16] */\n+    *(unsigned int*) &__tramp[20] = __ctx;\n+    *(unsigned int*) &__tramp[24] = __rstruct_flag;\n+    *(unsigned int*) &__tramp[28] = __inner;\n+    *(unsigned int*) &__tramp[32] = __fun;\n+    syscall(__NR_cacheflush, 0, (&__tramp[0]), 36);\n+\n+    closure->cif = cif;\n+    closure->user_data = user_data;\n+    closure->fun  = fun;\n+\n+    return FFI_OK;\n+}\n+"}, {"sha": "1c799b1de720f9e6e346fab4ca730d847912cba5", "filename": "libffi/src/avr32/ffitarget.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fsrc%2Favr32%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fsrc%2Favr32%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Favr32%2Fffitarget.h?ref=124f60ab29f46aefdf892a4fcf981e4e292eb08c", "patch": "@@ -0,0 +1,50 @@\n+/* -----------------------------------------------------------------*-C-*-\n+   ffitarget.h - Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>\n+   Target configuration macros for AVR32.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed long            ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_SYSV,\n+  FFI_DEFAULT_ABI = FFI_SYSV,\n+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+} ffi_abi;\n+#endif\n+\n+#define FFI_EXTRA_CIF_FIELDS unsigned int rstruct_flag\n+\n+/* Definitions for closures */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 36\n+#define FFI_NATIVE_RAW_API 0\n+\n+#endif"}, {"sha": "a984b3c88a3095a737bb8fdace60d48f92401515", "filename": "libffi/src/avr32/sysv.S", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fsrc%2Favr32%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124f60ab29f46aefdf892a4fcf981e4e292eb08c/libffi%2Fsrc%2Favr32%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Favr32%2Fsysv.S?ref=124f60ab29f46aefdf892a4fcf981e4e292eb08c", "patch": "@@ -0,0 +1,208 @@\n+/* -----------------------------------------------------------------------\n+   sysv.S - Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>\n+\n+   AVR32 Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+   --------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+    /* r12:  ffi_prep_args\n+     * r11:  &ecif\n+     * r10:  size\n+     * r9:   cif->flags\n+     * r8:   ecif.rvalue\n+     * sp+0: cif->rstruct_flag\n+     * sp+4: fn */\n+\n+    .text\n+    .align  1\n+    .globl  ffi_call_SYSV\n+    .type   ffi_call_SYSV, @function\n+ffi_call_SYSV:\n+    stm     --sp, r0,r1,lr\n+    stm     --sp, r8-r12\n+    mov     r0, sp\n+\n+    /* Make room for all of the new args. */\n+    sub     sp, r10\n+    /* Pad to make way for potential skipped registers */\n+    sub     sp, 20\n+\n+    /* Call ffi_prep_args(stack, &ecif). */\n+    /* r11 already set */\n+    mov     r1, r12\n+    mov     r12, sp\n+    icall   r1\n+\n+    /* Save new argument size */\n+    mov     r1, r12\n+\n+    /* Move first 5 parameters in registers. */\n+    ldm     sp++, r8-r12\n+\n+    /* call (fn) (...). */\n+    ld.w    r1, r0[36]\n+    icall   r1\n+\n+    /* Remove the space we pushed for the args. */\n+    mov     sp, r0\n+\n+    /* Load r1 with the rstruct flag. */\n+    ld.w    r1, sp[32]\n+\n+    /* Load r9 with the return type code. */\n+    ld.w    r9, sp[12]\n+\n+    /* Load r8 with the return value pointer. */\n+    ld.w    r8, sp[16]\n+\n+    /* If the return value pointer is NULL, assume no return value. */\n+    cp.w    r8, 0\n+    breq    .Lend\n+\n+    /* Check if return type is actually a struct */\n+    cp.w    r1, 0\n+    breq    1f\n+\n+    /* Return 8bit */\n+    cp.w    r9, FFI_TYPE_UINT8\n+    breq    .Lstore8\n+\n+    /* Return 16bit */\n+    cp.w    r9, FFI_TYPE_UINT16\n+    breq    .Lstore16\n+\n+1:\n+    /* Return 32bit */\n+    cp.w    r9, FFI_TYPE_UINT32\n+    breq    .Lstore32\n+    cp.w    r9, FFI_TYPE_UINT16\n+    breq    .Lstore32\n+    cp.w    r9, FFI_TYPE_UINT8\n+    breq    .Lstore32\n+\n+    /* Return 64bit */\n+    cp.w    r9, FFI_TYPE_UINT64\n+    breq    .Lstore64\n+\n+    /* Didn't match anything */\n+    bral    .Lend\n+\n+.Lstore64:\n+    st.w    r8[0], r11\n+    st.w    r8[4], r10\n+    bral    .Lend\n+\n+.Lstore32:\n+    st.w    r8[0], r12\n+    bral    .Lend\n+\n+.Lstore16:\n+    st.h    r8[0], r12\n+    bral    .Lend\n+\n+.Lstore8:\n+    st.b    r8[0], r12\n+    bral    .Lend\n+\n+.Lend:\n+    sub     sp, -20\n+    ldm     sp++, r0,r1,pc\n+\n+    .size   ffi_call_SYSV, . - ffi_call_SYSV\n+\n+\n+    /* r12:  __ctx\n+     * r11:  __rstruct_flag\n+     * r10:  __inner */\n+\n+    .align  1\n+    .globl  ffi_closure_SYSV\n+    .type   ffi_closure_SYSV, @function\n+ffi_closure_SYSV:\n+    stm     --sp, r0,lr\n+    mov     r0, r11\n+    mov     r8, r10\n+    sub     r10, sp, -8\n+    sub     sp, 12\n+    st.w    sp[8], sp\n+    sub     r11, sp, -8\n+    icall   r8\n+\n+    /* Check if return type is actually a struct */\n+    cp.w    r0, 0\n+    breq    1f\n+\n+    /* Return 8bit */\n+    cp.w    r12, FFI_TYPE_UINT8\n+    breq    .Lget8\n+\n+    /* Return 16bit */\n+    cp.w    r12, FFI_TYPE_UINT16\n+    breq    .Lget16\n+\n+1:\n+    /* Return 32bit */\n+    cp.w    r12, FFI_TYPE_UINT32\n+    breq    .Lget32\n+    cp.w    r12, FFI_TYPE_UINT16\n+    breq    .Lget32\n+    cp.w    r12, FFI_TYPE_UINT8\n+    breq    .Lget32\n+\n+    /* Return 64bit */\n+    cp.w    r12, FFI_TYPE_UINT64\n+    breq    .Lget64\n+\n+    /* Didn't match anything */\n+    bral    .Lclend\n+\n+.Lget64:\n+    ld.w    r11, sp[0]\n+    ld.w    r10, sp[4]\n+    bral    .Lclend\n+\n+.Lget32:\n+    ld.w    r12, sp[0]\n+    bral    .Lclend\n+\n+.Lget16:\n+    ld.uh   r12, sp[0]\n+    bral    .Lclend\n+\n+.Lget8:\n+    ld.ub   r12, sp[0]\n+    bral    .Lclend\n+\n+.Lclend:\n+    sub     sp, -12\n+    ldm     sp++, r0,lr\n+    sub     sp, -20\n+    mov     pc, lr\n+\n+    .size   ffi_closure_SYSV, . - ffi_closure_SYSV\n+\n+#if defined __ELF__ && defined __linux__\n+    .section    .note.GNU-stack,\"\",@progbits\n+#endif"}]}