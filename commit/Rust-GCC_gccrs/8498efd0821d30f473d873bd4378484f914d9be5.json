{"sha": "8498efd0821d30f473d873bd4378484f914d9be5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ5OGVmZDA4MjFkMzBmNDczZDg3M2JkNDM3ODQ4NGY5MTRkOWJlNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-07-28T17:12:33Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-07-28T17:12:33Z"}, "message": "(expand_call): For unaligned arguments on\nBYTES_BIG_ENDIAN machines, correct bitfield offset calculations.\n\nFrom-SVN: r5013", "tree": {"sha": "4ecd48a57a442512fc6daa2e334c103cf346da60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ecd48a57a442512fc6daa2e334c103cf346da60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8498efd0821d30f473d873bd4378484f914d9be5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8498efd0821d30f473d873bd4378484f914d9be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8498efd0821d30f473d873bd4378484f914d9be5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8498efd0821d30f473d873bd4378484f914d9be5/comments", "author": null, "committer": null, "parents": [{"sha": "0eb61c19ed94cea01e7e8e0540a932f15acf7ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb61c19ed94cea01e7e8e0540a932f15acf7ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb61c19ed94cea01e7e8e0540a932f15acf7ac7"}], "stats": {"total": 14, "additions": 10, "deletions": 4}, "files": [{"sha": "d9ec9daf3a6364f5c6ee1109d149e4218e04cd18", "filename": "gcc/calls.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8498efd0821d30f473d873bd4378484f914d9be5/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8498efd0821d30f473d873bd4378484f914d9be5/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=8498efd0821d30f473d873bd4378484f914d9be5", "patch": "@@ -1623,6 +1623,7 @@ expand_call (exp, target, ignore)\n \t    < MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))\n       {\n \tint bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n+\tint big_endian_correction = 0;\n \n \targs[i].n_aligned_regs\n \t  = args[i].partial ? args[i].partial\n@@ -1631,6 +1632,13 @@ expand_call (exp, target, ignore)\n \targs[i].aligned_regs = (rtx *) alloca (sizeof (rtx)\n \t\t\t\t\t       * args[i].n_aligned_regs);\n \n+\t/* Structures smaller than a word are aligned to the least signifcant\n+\t   byte (to the right).  On a BYTES_BIG_ENDIAN machine, this means we\n+\t   must skip the empty high order bytes when calculating the bit\n+\t   offset.  */\n+\tif (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n+\t  big_endian_correction = (BITS_PER_WORD  - (bytes * BITS_PER_UNIT));\n+\n \tfor (j = 0; j < args[i].n_aligned_regs; j++)\n \t  {\n \t    rtx reg = gen_reg_rtx (word_mode);\n@@ -1651,12 +1659,10 @@ expand_call (exp, target, ignore)\n \t\t bitpos < BITS_PER_WORD && bytes > 0;\n \t\t bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n \t      {\n-\t\tint xbitpos = (BYTES_BIG_ENDIAN\n-\t\t\t       ? BITS_PER_WORD - bitpos - bitsize\n-\t\t\t       : bitpos);\n+\t\tint xbitpos = bitpos + big_endian_correction;\n \n \t\tstore_bit_field (reg, bitsize, xbitpos, word_mode,\n-\t\t\t\t extract_bit_field (word, bitsize, xbitpos, 1,\n+\t\t\t\t extract_bit_field (word, bitsize, bitpos, 1,\n \t\t\t\t\t\t    NULL_RTX, word_mode,\n \t\t\t\t\t\t    word_mode,\n \t\t\t\t\t\t    bitsize / BITS_PER_UNIT,"}]}