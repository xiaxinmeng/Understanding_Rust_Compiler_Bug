{"sha": "95baeff8c0c8cb810972d5ced10f8508260dc70e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTViYWVmZjhjMGM4Y2I4MTA5NzJkNWNlZDEwZjg1MDgyNjBkYzcwZQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-11-25T04:55:25Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T04:55:25Z"}, "message": "graphite-interchange.c (lst_apply_interchange): New.\n\n2009-10-06  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-interchange.c (lst_apply_interchange): New.\n\t(lst_interchange_profitable_p): New.\n\t(lst_try_interchange_loops): New.\n\t(lst_try_interchange): New.\n\t(lst_do_interchange): New.\n\t(pbb_do_interchange): Removed.\n\t(scop_do_interchange): Call lst_do_interchange.\n\nFrom-SVN: r154563", "tree": {"sha": "6b949ccba6a80c23103690b42521d923d52651fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b949ccba6a80c23103690b42521d923d52651fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95baeff8c0c8cb810972d5ced10f8508260dc70e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95baeff8c0c8cb810972d5ced10f8508260dc70e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95baeff8c0c8cb810972d5ced10f8508260dc70e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95baeff8c0c8cb810972d5ced10f8508260dc70e/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a36d12e2779468da79e41d35c1049e8635121bde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a36d12e2779468da79e41d35c1049e8635121bde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a36d12e2779468da79e41d35c1049e8635121bde"}], "stats": {"total": 166, "additions": 140, "deletions": 26}, "files": [{"sha": "57db61d46be8e26ab811911e33d19b41e1ccac50", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95baeff8c0c8cb810972d5ced10f8508260dc70e/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95baeff8c0c8cb810972d5ced10f8508260dc70e/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=95baeff8c0c8cb810972d5ced10f8508260dc70e", "patch": "@@ -1,3 +1,13 @@\n+2009-10-06  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-interchange.c (lst_apply_interchange): New.\n+\t(lst_interchange_profitable_p): New.\n+\t(lst_try_interchange_loops): New.\n+\t(lst_try_interchange): New.\n+\t(lst_do_interchange): New.\n+\t(pbb_do_interchange): Removed.\n+\t(scop_do_interchange): Call lst_do_interchange.\n+\n 2009-10-06  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-poly.c (print_scop): Print SCOP_ORIGINAL_SCHEDULE and"}, {"sha": "43655f66f736cc36bd764be431904a1e8cd1c148", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 130, "deletions": 26, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95baeff8c0c8cb810972d5ced10f8508260dc70e/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95baeff8c0c8cb810972d5ced10f8508260dc70e/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=95baeff8c0c8cb810972d5ced10f8508260dc70e", "patch": "@@ -305,50 +305,153 @@ pbb_interchange_loop_depths (graphite_dim_t depth1, graphite_dim_t depth2, poly_\n   free (map);\n }\n \n-/* Interchanges all the loop depths that are considered profitable for PBB.  */\n+/* Apply the interchange of loops at depths DEPTH1 and DEPTH2 to all\n+   the statements below LST.  */\n+\n+static void\n+lst_apply_interchange (lst_p lst, int depth1, int depth2)\n+{\n+  if (!lst)\n+    return;\n+\n+  if (LST_LOOP_P (lst))\n+    {\n+      int i;\n+      lst_p l;\n+\n+      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+\tlst_apply_interchange (l, depth1, depth2);\n+    }\n+  else\n+    pbb_interchange_loop_depths (depth1, depth2, LST_PBB (lst));\n+}\n+\n+/* Return true when the interchange of loops at depths DEPTH1 and\n+   DEPTH2 to all the statements below LST is profitable.  */\n \n static bool\n-pbb_do_interchange (poly_bb_p pbb, scop_p scop)\n+lst_interchange_profitable_p (lst_p lst, int depth1, int depth2)\n {\n-  graphite_dim_t i, j;\n-  bool transform_done = false;\n+  if (!lst)\n+    return false;\n \n-  for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n-    for (j = i + 1; j < pbb_dim_iter_domain (pbb); j++)\n-      if (pbb_interchange_profitable_p (i, j, pbb))\n+  if (LST_LOOP_P (lst))\n+    {\n+      int i;\n+      lst_p l;\n+      bool res = false;\n+\n+      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n \t{\n-\t  pbb_interchange_loop_depths (i, j, pbb);\n-\n-\t  if (graphite_legal_transform (scop))\n-\t    {\n-\t      transform_done = true;\n-\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file,\n-\t\t\t \"PBB %d: loops at depths %d and %d will be interchanged.\\n\",\n-\t\t\t pbb_index (pbb), (int) i, (int) j);\n-\t    }\n-\t  else\n-\t    /* Undo the transform.  */\n-\t    pbb_interchange_loop_depths (j, i, pbb);\n+\t  bool profitable = lst_interchange_profitable_p (l, depth1, depth2);\n+\n+\t  if (profitable && !LST_LOOP_P (lst)\n+\t      && dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Interchanging loops at depths %d and %d is profitable for stmt_%d.\\n\",\n+\t\t     depth1, depth2, pbb_index (LST_PBB (lst)));\n+\n+\t  res |= profitable;\n \t}\n \n-  return transform_done;\n+      return res;\n+    }\n+  else\n+    return pbb_interchange_profitable_p (depth1, depth2, LST_PBB (lst));\n+}\n+\n+\n+/* Try to interchange LOOP1 with LOOP2 for all the statements of the\n+   body of LOOP2.  LOOP1 contains LOOP2.  Return true if it did the\n+   interchange.  */\n+\n+static bool\n+lst_try_interchange_loops (scop_p scop, lst_p loop1, lst_p loop2)\n+{\n+  int depth1 = lst_depth (loop1);\n+  int depth2 = lst_depth (loop2);\n+\n+  if (!lst_interchange_profitable_p (loop2, depth1, depth2))\n+    return false;\n+\n+  lst_apply_interchange (loop2, depth1, depth2);\n+\n+  if (graphite_legal_transform (scop))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Loops at depths %d and %d will be interchanged.\\n\",\n+\t\t depth1, depth2);\n+\n+      return true;\n+    }\n+\n+  /* Undo the transform.  */\n+  lst_apply_interchange (loop2, depth2, depth1);\n+  return false;\n+}\n+\n+/* Try to interchange LOOP with all the loops contained in the body of\n+   LST.  Return true if it did interchanged some loops.  */\n+\n+static bool\n+lst_try_interchange (scop_p scop, lst_p loop, lst_p lst)\n+{\n+  if (!lst)\n+    return false;\n+\n+  if (LST_LOOP_P (lst))\n+    {\n+      int i;\n+      lst_p l;\n+      bool res = lst_try_interchange_loops (scop, loop, lst);\n+\n+      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+\tres |= lst_try_interchange (scop, loop, l);\n+\n+      return res;\n+    }\n+\n+  return false;\n+}\n+\n+/* Interchanges all the loops of LST that are considered profitable to\n+   interchange.  Return true if it did interchanged some loops.  */\n+\n+static bool\n+lst_do_interchange (scop_p scop, lst_p lst)\n+{\n+  if (!lst)\n+    return false;\n+\n+  if (LST_LOOP_P (lst))\n+    {\n+      int i;\n+      lst_p l;\n+      bool res = false;\n+\n+      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+\tres |= lst_try_interchange (scop, lst, l);\n+\n+      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+\tres |= lst_do_interchange (scop, l);\n+\n+      return res;\n+    }\n+\n+  return false;\n }\n \n /* Interchanges all the loop depths that are considered profitable for SCOP.  */\n \n bool\n scop_do_interchange (scop_p scop)\n {\n-  int i;\n-  poly_bb_p pbb;\n   bool transform_done = false;\n \n   store_scattering (scop);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n-    transform_done |= pbb_do_interchange (pbb, scop);\n+  transform_done = lst_do_interchange (scop, SCOP_TRANSFORMED_SCHEDULE (scop));\n \n   if (!transform_done)\n     return false;\n@@ -362,5 +465,6 @@ scop_do_interchange (scop_p scop)\n   return transform_done;\n }\n \n+\n #endif\n "}]}