{"sha": "1cbfdb1f9c65719d1e57bb214674c3751a551e60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiZmRiMWY5YzY1NzE5ZDFlNTdiYjIxNDY3NGMzNzUxYTU1MWU2MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2001-09-18T16:24:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2001-09-18T16:24:32Z"}, "message": "mips.c (mips_frame_set): New.\n\n\t* config/mips/mips.c (mips_frame_set): New.\n\t(mips_emit_frame_related_store): When storing two 32-bit FPRs, use\n\ta parallel frame-related expression with a set for each register.\n\nFrom-SVN: r45678", "tree": {"sha": "a2353a7a7968b2ac3b394dd32dc9962ed65c8a37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2353a7a7968b2ac3b394dd32dc9962ed65c8a37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cbfdb1f9c65719d1e57bb214674c3751a551e60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbfdb1f9c65719d1e57bb214674c3751a551e60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cbfdb1f9c65719d1e57bb214674c3751a551e60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbfdb1f9c65719d1e57bb214674c3751a551e60/comments", "author": null, "committer": null, "parents": [{"sha": "b9bc4bf6de6b9ee79b92d2702fa5137c387c249c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9bc4bf6de6b9ee79b92d2702fa5137c387c249c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9bc4bf6de6b9ee79b92d2702fa5137c387c249c"}], "stats": {"total": 50, "additions": 45, "deletions": 5}, "files": [{"sha": "178137419c8aeaf806631bf9395e3630c61221b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbfdb1f9c65719d1e57bb214674c3751a551e60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbfdb1f9c65719d1e57bb214674c3751a551e60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cbfdb1f9c65719d1e57bb214674c3751a551e60", "patch": "@@ -1,3 +1,9 @@\n+2001-09-18  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_frame_set): New.\n+\t(mips_emit_frame_related_store): When storing two 32-bit FPRs, use\n+\ta parallel frame-related expression with a set for each register.\n+\n 2001-09-18  Philip Blundell  <philb@gnu.org>\n \n \t* config/arm/lib1funcs.asm (L_dvmd_lnx): Don't rely on kernel"}, {"sha": "92d4e84b39c3cdec0c21279f4f58f9072598f02a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbfdb1f9c65719d1e57bb214674c3751a551e60/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbfdb1f9c65719d1e57bb214674c3751a551e60/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=1cbfdb1f9c65719d1e57bb214674c3751a551e60", "patch": "@@ -94,6 +94,8 @@ static void block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT,\n \t\t\t\t\t\t\t FILE *));\n static void mips_annotate_frame_insn\t\tPARAMS ((rtx, rtx));\n+static rtx mips_frame_set\t\t\tPARAMS ((enum machine_mode,\n+\t\t\t\t\t\t\t int, int));\n static void mips_emit_frame_related_store\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t HOST_WIDE_INT));\n static void save_restore_insns\t\t\tPARAMS ((int, rtx,\n@@ -6599,20 +6601,52 @@ mips_annotate_frame_insn (insn, dwarf_pattern)\n \t\t\t\t      REG_NOTES (insn));\n }\n \n+/* Return a frame-related rtx that stores register REGNO at (SP + OFFSET).\n+   The expression should only be used to store single registers.  */\n+\n+static rtx\n+mips_frame_set (mode, regno, offset)\n+     enum machine_mode mode;\n+     int regno;\n+     int offset;\n+{\n+  rtx address = plus_constant (stack_pointer_rtx, offset);\n+  rtx set = gen_rtx_SET (mode,\n+\t\t\t gen_rtx_MEM (mode, address),\n+\t\t\t gen_rtx_REG (mode, regno));\n+  RTX_FRAME_RELATED_P (set) = 1;\n+  return set;\n+}\n+\n+\n /* Emit a move instruction that stores REG in MEM.  Make the instruction\n-   frame related and note that it stores REG at (SP + OFFSET).  */\n+   frame related and note that it stores REG at (SP + OFFSET).  This\n+   function may be asked to store an FPR pair.  */\n \n static void\n mips_emit_frame_related_store (mem, reg, offset)\n      rtx mem;\n      rtx reg;\n      HOST_WIDE_INT offset;\n {\n-  rtx dwarf_address = plus_constant (stack_pointer_rtx, offset);\n-  rtx dwarf_mem = gen_rtx_MEM (GET_MODE (reg), dwarf_address);\n+  rtx dwarf_expr;\n \n-  mips_annotate_frame_insn (emit_move_insn (mem, reg),\n-\t\t\t    gen_rtx_SET (GET_MODE (reg), dwarf_mem, reg));\n+  if (GET_MODE (reg) == DFmode && ! TARGET_FLOAT64)\n+    {\n+      /* Two registers are being stored, so the frame-related expression\n+\t must be a PARALLEL rtx with one SET for each register.  The\n+\t higher numbered register is stored in the lower address on\n+\t big-endian targets.  */\n+      int regno1 = TARGET_BIG_ENDIAN ? REGNO (reg) + 1 : REGNO (reg);\n+      int regno2 = TARGET_BIG_ENDIAN ? REGNO (reg) : REGNO (reg) + 1;\n+      rtx set1 = mips_frame_set (SFmode, regno1, offset);\n+      rtx set2 = mips_frame_set (SFmode, regno2, offset + UNITS_PER_FPREG);\n+      dwarf_expr = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set1, set2));\n+    }\n+  else\n+    dwarf_expr = mips_frame_set (GET_MODE (reg), REGNO (reg), offset);\n+      \n+  mips_annotate_frame_insn (emit_move_insn (mem, reg), dwarf_expr);\n }\n \n static void"}]}