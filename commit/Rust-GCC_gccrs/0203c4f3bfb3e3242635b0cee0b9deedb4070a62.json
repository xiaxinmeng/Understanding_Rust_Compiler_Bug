{"sha": "0203c4f3bfb3e3242635b0cee0b9deedb4070a62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIwM2M0ZjNiZmIzZTMyNDI2MzViMGNlZTBiOWRlZWRiNDA3MGE2Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-14T14:58:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-14T14:58:21Z"}, "message": "Use consistent compatibility checks in vectorizable_shift\n\nThe validation phase of vectorizable_shift used TYPE_MODE to check\nwhether the shift amount vector was compatible with the shifted vector:\n\n      if ((op1_vectype == NULL_TREE\n\t   || TYPE_MODE (op1_vectype) != TYPE_MODE (vectype))\n \t  && (!slp_node\n \t      || SLP_TREE_DEF_TYPE\n \t\t   (SLP_TREE_CHILDREN (slp_node)[1]) != vect_constant_def))\n\nBut the generation phase was stricter and required the element types to\nbe equivalent:\n\n\t\t   && !useless_type_conversion_p (TREE_TYPE (vectype),\n\t\t\t\t\t\t  TREE_TYPE (op1)))\n\nThis difference led to an ICE with a later patch.\n\nThe first condition seems a bit too lax given that the function\nsupports vect_worthwhile_without_simd_p, where two different vector\ntypes could have the same integer mode.  But it seems too strict\nto reject signed shifts by unsigned amounts or unsigned shifts by\nsigned amounts; verify_gimple_assign_binary is happy with those.\n\nThis patch therefore goes for a middle ground of checking both TYPE_MODE\nand TYPE_VECTOR_SUBPARTS, using the same condition in both places.\n\n2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-stmts.c (vectorizable_shift): Check the number\n\tof vector elements as well as the type mode when deciding\n\twhether an op1_vectype is compatible.  Reuse the result of\n\tthis check when generating vector statements.\n\nFrom-SVN: r278235", "tree": {"sha": "63619b1cbf82629c2813b07094e310e23df0e5cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63619b1cbf82629c2813b07094e310e23df0e5cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0203c4f3bfb3e3242635b0cee0b9deedb4070a62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0203c4f3bfb3e3242635b0cee0b9deedb4070a62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0203c4f3bfb3e3242635b0cee0b9deedb4070a62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0203c4f3bfb3e3242635b0cee0b9deedb4070a62/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95da266b86fcdeff84fcadc5e3cde3d0027e571d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95da266b86fcdeff84fcadc5e3cde3d0027e571d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95da266b86fcdeff84fcadc5e3cde3d0027e571d"}], "stats": {"total": 20, "additions": 15, "deletions": 5}, "files": [{"sha": "70e50ae3fcfe174d6467519d9ac899aa25094422", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0203c4f3bfb3e3242635b0cee0b9deedb4070a62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0203c4f3bfb3e3242635b0cee0b9deedb4070a62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0203c4f3bfb3e3242635b0cee0b9deedb4070a62", "patch": "@@ -1,3 +1,10 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-stmts.c (vectorizable_shift): Check the number\n+\tof vector elements as well as the type mode when deciding\n+\twhether an op1_vectype is compatible.  Reuse the result of\n+\tthis check when generating vector statements.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-stmts.c (get_vectype_for_scalar_type_and_size): If"}, {"sha": "15c798d1fa24e4dbbcdf061c7c92ce5a6d8d3501", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0203c4f3bfb3e3242635b0cee0b9deedb4070a62/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0203c4f3bfb3e3242635b0cee0b9deedb4070a62/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=0203c4f3bfb3e3242635b0cee0b9deedb4070a62", "patch": "@@ -5544,6 +5544,7 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   bool scalar_shift_arg = true;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n+  bool incompatible_op1_vectype_p = false;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -5688,8 +5689,12 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n       if (!op1_vectype)\n \top1_vectype = get_same_sized_vectype (TREE_TYPE (op1), vectype_out);\n-      if ((op1_vectype == NULL_TREE\n-\t   || TYPE_MODE (op1_vectype) != TYPE_MODE (vectype))\n+      incompatible_op1_vectype_p\n+\t= (op1_vectype == NULL_TREE\n+\t   || maybe_ne (TYPE_VECTOR_SUBPARTS (op1_vectype),\n+\t\t\tTYPE_VECTOR_SUBPARTS (vectype))\n+\t   || TYPE_MODE (op1_vectype) != TYPE_MODE (vectype));\n+      if (incompatible_op1_vectype_p\n \t  && (!slp_node\n \t      || SLP_TREE_DEF_TYPE\n \t\t   (SLP_TREE_CHILDREN (slp_node)[1]) != vect_constant_def))\n@@ -5835,9 +5840,7 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n                     }\n                 }\n             }\n-\t  else if (slp_node\n-\t\t   && !useless_type_conversion_p (TREE_TYPE (vectype),\n-\t\t\t\t\t\t  TREE_TYPE (op1)))\n+\t  else if (slp_node && incompatible_op1_vectype_p)\n \t    {\n \t      if (was_scalar_shift_arg)\n \t\t{"}]}