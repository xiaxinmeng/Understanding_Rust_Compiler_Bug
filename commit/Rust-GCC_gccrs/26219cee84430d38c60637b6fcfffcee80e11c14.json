{"sha": "26219cee84430d38c60637b6fcfffcee80e11c14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYyMTljZWU4NDQzMGQzOGM2MDYzN2I2ZmNmZmZjZWU4MGUxMWMxNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-03-11T22:25:11Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-03-11T22:25:11Z"}, "message": "re PR fortran/84546 (Bad sourced allocation of CLASS(*) with source with CLASS(*) component)\n\n2018-03-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/84546\n\t* trans-array.c (structure_alloc_comps): Make sure that the\n\tvptr is copied and that the unlimited polymorphic _len is used\n\tto compute the size to be allocated.\n\t* trans-expr.c (gfc_get_class_array_ref): If unlimited, use the\n\tunlimited polymorphic _len for the offset to the element.\n\t(gfc_copy_class_to_class): Set the new 'unlimited' argument.\n\t* trans.h : Add the boolean 'unlimited' to the prototype.\n\n2018-03-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/84546\n\t* gfortran.dg/unlimited_polymorphic_29.f90 : New test.\n\nFrom-SVN: r258438", "tree": {"sha": "967c16a73c8b9dd9bc89ae8e0c84a1baf6462d69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/967c16a73c8b9dd9bc89ae8e0c84a1baf6462d69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26219cee84430d38c60637b6fcfffcee80e11c14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26219cee84430d38c60637b6fcfffcee80e11c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26219cee84430d38c60637b6fcfffcee80e11c14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26219cee84430d38c60637b6fcfffcee80e11c14/comments", "author": null, "committer": null, "parents": [{"sha": "1813c97a6fd41062e5154e1fb0e7e2cc762306a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1813c97a6fd41062e5154e1fb0e7e2cc762306a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1813c97a6fd41062e5154e1fb0e7e2cc762306a5"}], "stats": {"total": 166, "additions": 154, "deletions": 12}, "files": [{"sha": "e767908ed02df1630deadbce2c418ff5bbb6d73d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=26219cee84430d38c60637b6fcfffcee80e11c14", "patch": "@@ -1,3 +1,13 @@\n+2018-03-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/84546\n+\t* trans-array.c (structure_alloc_comps): Make sure that the\n+\tvptr is copied and that the unlimited polymorphic _len is used\n+\tto compute the size to be allocated.\n+\t* trans-expr.c (gfc_get_class_array_ref): If unlimited, use the\n+\tunlimited polymorphic _len for the offset to the element.\n+\t(gfc_copy_class_to_class): Set the new 'unlimited' argument.\n+\t* trans.h : Add the boolean 'unlimited' to the prototype.\n \n 2018-03-11  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n@@ -86,7 +96,7 @@\n \tPR fortran/66128\n \t* simplify.c (is_size_zero_array): New function to check for size\n \tzero array.\n-\t(gfc_simplify_all, gfc_simplify_any, gfc_simplify_count, \n+\t(gfc_simplify_all, gfc_simplify_any, gfc_simplify_count,\n \t gfc_simplify_iall, gfc_simplify_iany, gfc_simplify_iparity,\n \t gfc_simplify_minval, gfc_simplify_maxval, gfc_simplify_norm2,\n \t gfc_simplify_product, gfc_simplify_sum): Use it, and implement"}, {"sha": "bd731689031811a0d0353755b12d6a19e2c40b7b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=26219cee84430d38c60637b6fcfffcee80e11c14", "patch": "@@ -8883,6 +8883,31 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t      gfc_init_block (&tmpblock);\n \n+\t      gfc_add_modify (&tmpblock, gfc_class_vptr_get (dcmp),\n+\t\t\t      gfc_class_vptr_get (comp));\n+\n+\t      /* Copy the unlimited '_len' field. If it is greater than zero\n+\t\t (ie. a character(_len)), multiply it by size and use this\n+\t\t for the malloc call.  */\n+\t      if (UNLIMITED_POLY (c))\n+\t\t{\n+\t\t  tree ctmp;\n+\t\t  gfc_add_modify (&tmpblock, gfc_class_len_get (dcmp),\n+\t\t\t\t  gfc_class_len_get (comp));\n+\n+\t\t  size = gfc_evaluate_now (size, &tmpblock);\n+\t\t  tmp = gfc_class_len_get (comp);\n+\t\t  ctmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t  size_type_node, size,\n+\t\t\t\t\t  fold_convert (size_type_node, tmp));\n+\t\t  tmp = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t\t logical_type_node, tmp,\n+\t\t\t\t\t build_zero_cst (TREE_TYPE (tmp)));\n+\t\t  size = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t  size_type_node, tmp, ctmp, size);\n+\t\t  size = gfc_evaluate_now (size, &tmpblock);\n+\t\t}\n+\n \t      /* Coarray component have to have the same allocation status and\n \t\t shape/type-parameter/effective-type on the LHS and RHS of an\n \t\t intrinsic assignment. Hence, we did not deallocated them - and"}, {"sha": "54bda1d019b7ec4fe97748e3f88939634808e221", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=26219cee84430d38c60637b6fcfffcee80e11c14", "patch": "@@ -1185,15 +1185,32 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n    of the referenced element.  */\n \n tree\n-gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp)\n+gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp,\n+\t\t\t bool unlimited)\n {\n-  tree data = data_comp != NULL_TREE ? data_comp :\n-\t\t\t\t       gfc_class_data_get (class_decl);\n-  tree size = gfc_class_vtab_size_get (class_decl);\n-  tree offset = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t gfc_array_index_type,\n-\t\t\t\t index, size);\n-  tree ptr;\n+  tree data, size, tmp, ctmp, offset, ptr;\n+\n+  data = data_comp != NULL_TREE ? data_comp :\n+\t\t\t\t  gfc_class_data_get (class_decl);\n+  size = gfc_class_vtab_size_get (class_decl);\n+\n+  if (unlimited)\n+    {\n+      tmp = fold_convert (gfc_array_index_type,\n+\t\t\t  gfc_class_len_get (class_decl));\n+      ctmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t      gfc_array_index_type, size, tmp);\n+      tmp = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t     logical_type_node, tmp,\n+\t\t\t     build_zero_cst (TREE_TYPE (tmp)));\n+      size = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t      gfc_array_index_type, tmp, ctmp, size);\n+    }\n+\n+  offset = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t    gfc_array_index_type,\n+\t\t\t    index, size);\n+\n   data = gfc_conv_descriptor_data_get (data);\n   ptr = fold_convert (pvoid_type_node, data);\n   ptr = fold_build_pointer_plus_loc (input_location, ptr, offset);\n@@ -1295,14 +1312,15 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \n       if (is_from_desc)\n \t{\n-\t  from_ref = gfc_get_class_array_ref (index, from, from_data);\n+\t  from_ref = gfc_get_class_array_ref (index, from, from_data,\n+\t\t\t\t\t      unlimited);\n \t  vec_safe_push (args, from_ref);\n \t}\n       else\n         vec_safe_push (args, from_data);\n \n       if (is_to_class)\n-\tto_ref = gfc_get_class_array_ref (index, to, to_data);\n+\tto_ref = gfc_get_class_array_ref (index, to, to_data, unlimited);\n       else\n \t{\n \t  tmp = gfc_conv_array_data (to);"}, {"sha": "1bd8206bc459bb1f9c55fd8a3c84fd6a0474dc0b", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=26219cee84430d38c60637b6fcfffcee80e11c14", "patch": "@@ -431,7 +431,7 @@ tree gfc_vptr_deallocate_get (tree);\n void gfc_reset_vptr (stmtblock_t *, gfc_expr *);\n void gfc_reset_len (stmtblock_t *, gfc_expr *);\n tree gfc_get_vptr_from_expr (tree);\n-tree gfc_get_class_array_ref (tree, tree, tree);\n+tree gfc_get_class_array_ref (tree, tree, tree, bool);\n tree gfc_copy_class_to_class (tree, tree, tree, bool);\n bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);\n bool gfc_add_comp_finalizer_call (stmtblock_t *, tree, gfc_component *, bool);"}, {"sha": "883fbb0c6a0215599f4f8aca0c390f93646696ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26219cee84430d38c60637b6fcfffcee80e11c14", "patch": "@@ -1,3 +1,8 @@\n+2018-03-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/84546\n+\t* gfortran.dg/unlimited_polymorphic_29.f90 : New test.\n+\n 2018-03-11  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/83939"}, {"sha": "d4ad39cda1e6e6782048d1c9d8d5f6ca00605fd0", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_29.f90", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_29.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26219cee84430d38c60637b6fcfffcee80e11c14/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_29.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_29.f90?ref=26219cee84430d38c60637b6fcfffcee80e11c14", "patch": "@@ -0,0 +1,84 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR84546 in which the failing cases would\n+! have x%vec = ['foo','b   '].\n+!\n+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>\n+!\n+module any_vector_type\n+\n+  type :: any_vector\n+    class(*), allocatable :: vec(:)\n+  end type\n+\n+  interface any_vector\n+    procedure any_vector1\n+  end interface\n+\n+contains\n+\n+  function any_vector1(vec) result(this)\n+    class(*), intent(in) :: vec(:)\n+    type(any_vector) :: this\n+    allocate(this%vec, source=vec)\n+  end function\n+\n+end module\n+\n+program main\n+\n+  use any_vector_type\n+  implicit none\n+\n+  class(*), allocatable :: x\n+  character(*), parameter :: vec(2) = ['foo','bar']\n+  integer :: vec1(3) = [7,8,9]\n+\n+  call foo1\n+  call foo2\n+  call foo3\n+  call foo4\n+\n+contains\n+\n+  subroutine foo1 ! This always worked\n+    allocate (any_vector :: x)\n+    select type (x)\n+      type is (any_vector)\n+        x = any_vector(vec)\n+    end select\n+    call bar(1)\n+    deallocate (x)\n+  end\n+\n+  subroutine foo2 ! Failure found during diagnosis\n+    x = any_vector (vec)\n+    call bar(2)\n+    deallocate (x)\n+  end\n+\n+  subroutine foo3 ! Original failure\n+    allocate (x, source = any_vector (vec))\n+    call bar(3)\n+    deallocate (x)\n+  end\n+\n+  subroutine foo4 ! This always worked\n+    allocate (x, source = any_vector (vec1))\n+    call bar(4)\n+    deallocate (x)\n+  end\n+\n+  subroutine bar (stop_flag)\n+    integer :: stop_flag\n+    select type (x)\n+      type is (any_vector)\n+        select type (xvec => x%vec)\n+          type is (character(*))\n+            if (any(xvec /= vec)) stop stop_flag\n+          type is (integer)\n+            if (any(xvec /= (vec1))) stop stop_flag\n+        end select\n+    end select\n+  end\n+end program"}]}