{"sha": "8e509cf9e36e99fef90e9cfb70882199222fb262", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU1MDljZjllMzZlOTlmZWY5MGU5Y2ZiNzA4ODIxOTkyMjJmYjI2Mg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-10-23T16:32:43Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-10-23T16:32:43Z"}, "message": "linux.h (CC1_SPEC, [...]): Remove.\n\n\t* config/s390/linux.h (CC1_SPEC, CC1PLUS_SPEC): Remove.\n\t* config/s390/s390.c (optimization_options): Disable -fcaller-saves.\n\n\t* config/s390/s390-protos.h (fp_operand): Remove.\n\t* config/s390/s390.c (fp_operand): Remove.\n\t* config/s390/s390.md (\"movdi\"): Replace fp_operand by FP_REG_P.\n\t(\"*movdi_lhi\", \"*movdi_lli\", \"*movdi_larl\"): Likewise.\n\t(\"movsi\", \"*movsi_lhi\", \"*movsi_lli\"): Likewise.\n\t(movdi_31, movdf_31 splitters): Likewise.\n\n\t* config/s390/s390.h (IEEE_FLOAT): Remove.\n\t(TARGET_FLOAT_FORMAT): Define in terms of TARGET_IEEE_FLOAT.\n\t(INT_REGNO_P): Rename to ...\n\t(GENERAL_REGNO_P): ... this.\n\t(FLOAT_REGNO_P): Rename to ...\n\t(FP_REGNO_P): ... this.\n\t(ADDR_REGNO_P): New macro.\n\t(GENERAL_REG_P, ADDR_REG_P, FP_REG_P, CC_REG_P): New macros.\n\t(REGNO_OK_FOR_DATA_P, REGNO_OK_FOR_FP_P): Remove.\n\t(DATA_REG_P, FP_REG_P, ADDRESS_REG_P): Likewise.\n\t(HARD_REGNO_NREGS): Adapt to macro renaming.\n\t(HARD_REGNO_MODE_OK): Likewise.\n\nFrom-SVN: r58458", "tree": {"sha": "8341771b8c729b5c8086e558bcede53cae04fb51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8341771b8c729b5c8086e558bcede53cae04fb51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e509cf9e36e99fef90e9cfb70882199222fb262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e509cf9e36e99fef90e9cfb70882199222fb262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e509cf9e36e99fef90e9cfb70882199222fb262", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e509cf9e36e99fef90e9cfb70882199222fb262/comments", "author": null, "committer": null, "parents": [{"sha": "3eb6b2b040fe10e4647b0f96ceb8eea38c878383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb6b2b040fe10e4647b0f96ceb8eea38c878383", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb6b2b040fe10e4647b0f96ceb8eea38c878383"}], "stats": {"total": 148, "additions": 61, "deletions": 87}, "files": [{"sha": "e7c4e9a8be9e59e05c0248bf3644d6d8a6e2f00c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e509cf9e36e99fef90e9cfb70882199222fb262", "patch": "@@ -1,3 +1,28 @@\n+2002-10-23  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/linux.h (CC1_SPEC, CC1PLUS_SPEC): Remove.\n+\t* config/s390/s390.c (optimization_options): Disable -fcaller-saves.\n+\n+\t* config/s390/s390-protos.h (fp_operand): Remove.\n+\t* config/s390/s390.c (fp_operand): Remove.\n+\t* config/s390/s390.md (\"movdi\"): Replace fp_operand by FP_REG_P.\n+\t(\"*movdi_lhi\", \"*movdi_lli\", \"*movdi_larl\"): Likewise.\n+\t(\"movsi\", \"*movsi_lhi\", \"*movsi_lli\"): Likewise.\n+\t(movdi_31, movdf_31 splitters): Likewise.\n+\t\n+\t* config/s390/s390.h (IEEE_FLOAT): Remove.\n+\t(TARGET_FLOAT_FORMAT): Define in terms of TARGET_IEEE_FLOAT.\n+\t(INT_REGNO_P): Rename to ...\n+\t(GENERAL_REGNO_P): ... this.\n+\t(FLOAT_REGNO_P): Rename to ...\n+\t(FP_REGNO_P): ... this.\n+\t(ADDR_REGNO_P): New macro.\n+\t(GENERAL_REG_P, ADDR_REG_P, FP_REG_P, CC_REG_P): New macros.\n+\t(REGNO_OK_FOR_DATA_P, REGNO_OK_FOR_FP_P): Remove.\n+\t(DATA_REG_P, FP_REG_P, ADDRESS_REG_P): Likewise.\n+\t(HARD_REGNO_NREGS): Adapt to macro renaming.\n+\t(HARD_REGNO_MODE_OK): Likewise.\n+\n 2002-10-23  David Edelsohn  <edelsohn@gnu.org>\n \t    Geoff Keating  <geoffk@apple.com>\n "}, {"sha": "d3e88072254e1f0676e67f22b3093ccf749f3c42", "filename": "gcc/config/s390/linux.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux.h?ref=8e509cf9e36e99fef90e9cfb70882199222fb262", "patch": "@@ -68,15 +68,6 @@ Boston, MA 02111-1307, USA.  */\n   while (0)\n \n \n-/* Target specific compiler settings.  */\n-\n-/* ??? -fcaller-saves sometimes doesn't work.  Fix this! */\n-#undef  CC1_SPEC\n-#define CC1_SPEC \"-fno-caller-saves\"\n-#undef  CC1PLUS_SPEC\n-#define CC1PLUS_SPEC \"-fno-caller-saves\"\n-\n-\n /* Target specific assembler settings.  */\n \n #ifdef DEFAULT_TARGET_64BIT"}, {"sha": "556402555aaba4409f4cfd8d06348bc820261478", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=8e509cf9e36e99fef90e9cfb70882199222fb262", "patch": "@@ -34,7 +34,6 @@ extern int q_constraint PARAMS ((rtx));\n extern int const0_operand PARAMS ((rtx, enum machine_mode));\n extern int consttable_operand PARAMS ((rtx, enum machine_mode));\n extern int larl_operand PARAMS ((rtx, enum machine_mode));\n-extern int fp_operand PARAMS ((rtx, enum machine_mode));\n extern int s_operand PARAMS ((rtx, enum machine_mode));\n extern int s_imm_operand PARAMS ((rtx, enum machine_mode));\n extern int bras_sym_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "f73f6aaa387fc5c9ab92f9c19cf7ea7e809dd6c0", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8e509cf9e36e99fef90e9cfb70882199222fb262", "patch": "@@ -814,6 +814,8 @@ optimization_options (level, size)\n      int level ATTRIBUTE_UNUSED;\n      int size ATTRIBUTE_UNUSED;\n {\n+  /* ??? There are apparently still problems with -fcaller-saves.  */\n+  flag_caller_saves = 0;\n }\n \n void\n@@ -934,24 +936,6 @@ larl_operand (op, mode)\n   return 0;\n }\n \n-/* Return true if OP is a valid FP-Register.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-fp_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  register enum rtx_code code = GET_CODE (op);\n-  if (! check_mode (op, &mode))\n-    return 0;\n-  if (code == REG && REGNO_OK_FOR_FP_P (REGNO (op)))\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n /* Helper routine to implement s_operand and s_imm_operand.\n    OP is the current operation.\n    MODE is the current operation mode."}, {"sha": "132db083b3e19fe7dbeb2ccb0ce352b143ef2271", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=8e509cf9e36e99fef90e9cfb70882199222fb262", "patch": "@@ -45,6 +45,10 @@ extern int target_flags;\n #define TARGET_64BIT               (target_flags & 16)\n #define TARGET_MVCLE               (target_flags & 32)\n \n+/* ??? Once this actually works, it could be made a runtime option.  */\n+#define TARGET_IBM_FLOAT           0\n+#define TARGET_IEEE_FLOAT          1\n+\n #ifdef DEFAULT_TARGET_64BIT\n #define TARGET_DEFAULT             0x13\n #define TARGET_VERSION fprintf (stderr, \" (zSeries)\");\n@@ -96,11 +100,6 @@ extern int target_flags;\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* Defines for real.c.  */\n-#define IEEE_FLOAT 1\n-#define TARGET_IBM_FLOAT           0\n-#define TARGET_IEEE_FLOAT          1 \n-\n /* The amount of space used for outgoing arguments.  */\n \n extern int current_function_outgoing_args_size;\n@@ -212,13 +211,8 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n #define STRICT_ALIGNMENT 0\n \n /* Define target floating point format.  */\n-\n-#undef TARGET_FLOAT_FORMAT\n-#ifdef IEEE_FLOAT\n-#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n-#else\n-#define TARGET_FLOAT_FORMAT IBM_FLOAT_FORMAT\n-#endif\n+#define TARGET_FLOAT_FORMAT \\\n+\t(TARGET_IEEE_FLOAT? IEEE_FLOAT_FORMAT : IBM_FLOAT_FORMAT)\n \n /* Define if special allocation order desired.  */\n \n@@ -230,13 +224,15 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n \n /* Standard register usage.  */\n  \n-#define INT_REGNO_P(N)   ( (int)(N) >= 0 && (N) < 16 )\n-#ifdef IEEE_FLOAT\n-#define FLOAT_REGNO_P(N) ( (N) >= 16 && (N) < 32 )\n-#else\n-#define FLOAT_REGNO_P(N) ( (N) >= 16 && (N) < 20 )\n-#endif\n-#define CC_REGNO_P(N)    ( (N) == 33 )\n+#define GENERAL_REGNO_P(N)\t((int)(N) >= 0 && (N) < 16)\n+#define ADDR_REGNO_P(N)\t\t((N) >= 1 && (N) < 16)\n+#define FP_REGNO_P(N)\t\t((N) >= 16 && (N) < (TARGET_IEEE_FLOAT? 32 : 20))\n+#define CC_REGNO_P(N)\t\t((N) == 33)\n+\n+#define GENERAL_REG_P(X)\t(REG_P (X) && GENERAL_REGNO_P (REGNO (X)))\n+#define ADDR_REG_P(X)\t\t(REG_P (X) && ADDR_REGNO_P (REGNO (X)))\n+#define FP_REG_P(X)\t\t(REG_P (X) && FP_REGNO_P (REGNO (X)))\n+#define CC_REG_P(X)\t\t(REG_P (X) && CC_REGNO_P (REGNO (X)))\n \n /* Number of actual hardware registers.  The hardware registers are\n    assigned numbers for the compiler from 0 to just below\n@@ -364,9 +360,9 @@ do\t\t\t\t\t\t\t\t\\\n    but can be less for certain modes in special long registers.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)                           \\\n-  (FLOAT_REGNO_P(REGNO)?                                        \\\n+  (FP_REGNO_P(REGNO)?                                           \\\n     (GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :      \\\n-   INT_REGNO_P(REGNO)?                                          \\\n+   GENERAL_REGNO_P(REGNO)?                                      \\\n     ((GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD) : \\\n    1)\n \n@@ -376,11 +372,11 @@ do\t\t\t\t\t\t\t\t\\\n    The floating point registers can hold DF, SF, DC and SC.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)                             \\\n-  (FLOAT_REGNO_P(REGNO)?                                            \\\n+  (FP_REGNO_P(REGNO)?                                               \\\n    ((MODE) == SImode || (MODE) == DImode ||                         \\\n     GET_MODE_CLASS(MODE) == MODE_FLOAT ||                           \\\n     GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT) :                   \\\n-   INT_REGNO_P(REGNO)?                                              \\\n+   GENERAL_REGNO_P(REGNO)?                                          \\\n     (HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1)) :        \\\n    CC_REGNO_P(REGNO)?                                               \\\n      GET_MODE_CLASS (MODE) == MODE_CC :                             \\\n@@ -877,27 +873,6 @@ CUMULATIVE_ARGS;\n \n #define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P (REGNO)\n \n-#define REGNO_OK_FOR_DATA_P(REGNO)                                      \\\n-  ((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n-\n-#define REGNO_OK_FOR_FP_P(REGNO)                                        \\\n-  FLOAT_REGNO_P (REGNO)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.  */\n-\n-/* 1 if X is a data register.  */\n-\n-#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n-\n-/* 1 if X is an address register.  */\n-\n-#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n-\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n #define MAX_REGS_PER_ADDRESS 2"}, {"sha": "475e6fa87e433669f3fe5027db5b71d1e0a12a87", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e509cf9e36e99fef90e9cfb70882199222fb262/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=8e509cf9e36e99fef90e9cfb70882199222fb262", "patch": "@@ -862,7 +862,7 @@\n   if ((reload_in_progress || reload_completed)\n       && CONSTANT_P (operands[1]) \n       && (!legitimate_reload_constant_p (operands[1])\n-          || fp_operand (operands[0], VOIDmode)))\n+          || FP_REG_P (operands[0])))\n     operands[1] = force_const_mem (DImode, operands[1]);\n }\")\n \n@@ -872,7 +872,7 @@\n   \"TARGET_64BIT\n    && GET_CODE (operands[1]) == CONST_INT\n    && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K')\n-   && !fp_operand (operands[0], VOIDmode)\"\n+   && !FP_REG_P (operands[0])\"\n   \"lghi\\\\t%0,%h1\"\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"atype\"   \"reg\")])\n@@ -881,7 +881,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (match_operand:DI 1 \"immediate_operand\" \"n\"))]\n   \"TARGET_64BIT && s390_single_hi (operands[1], DImode, 0) >= 0\n-   && !fp_operand (operands[0], VOIDmode)\"\n+   && !FP_REG_P (operands[0])\"\n   \"*\n {\n   int part = s390_single_hi (operands[1], DImode, 0);\n@@ -903,7 +903,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (match_operand:DI 1 \"larl_operand\" \"X\"))]\n   \"TARGET_64BIT\n-   && !fp_operand (operands[0], VOIDmode)\"\n+   && !FP_REG_P (operands[0])\"\n   \"larl\\\\t%0,%1\"\n    [(set_attr \"op_type\" \"RIL\")\n     (set_attr \"atype\"   \"reg\")\n@@ -944,8 +944,8 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && !fp_operand (operands[0], VOIDmode)\n-   && !fp_operand (operands[1], VOIDmode)\n+   && !FP_REG_P (operands[0])\n+   && !FP_REG_P (operands[1])\n    && !s_operand (operands[0], VOIDmode)\n    && !s_operand (operands[1], VOIDmode)\n    && (register_operand (operands[0], VOIDmode)\n@@ -981,8 +981,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"memory_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && !fp_operand (operands[0], VOIDmode)\n-   && !fp_operand (operands[1], VOIDmode)\n+   && !FP_REG_P (operands[0])\n+   && !FP_REG_P (operands[1])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n   \"\n@@ -1027,7 +1027,7 @@\n   if ((reload_in_progress || reload_completed)\n       && CONSTANT_P (operands[1]) \n       && (!legitimate_reload_constant_p (operands[1])\n-          || fp_operand (operands[0], VOIDmode)))\n+          || FP_REG_P (operands[0])))\n     operands[1] = force_const_mem (SImode, operands[1]);\n }\")\n \n@@ -1036,15 +1036,15 @@\n         (match_operand:SI 1 \"immediate_operand\" \"K\"))]\n   \"GET_CODE (operands[1]) == CONST_INT\n    && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K')\n-   && !fp_operand (operands[0], VOIDmode)\"\n+   && !FP_REG_P (operands[0])\"\n   \"lhi\\\\t%0,%h1\"\n   [(set_attr \"op_type\" \"RI\")])\n \n (define_insn \"*movsi_lli\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (match_operand:SI 1 \"immediate_operand\" \"n\"))]\n   \"TARGET_64BIT && s390_single_hi (operands[1], SImode, 0) >= 0\n-   && !fp_operand (operands[0], VOIDmode)\"\n+   && !FP_REG_P (operands[0])\"\n   \"*\n {\n   int part = s390_single_hi (operands[1], SImode, 0);\n@@ -1220,8 +1220,8 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DF 1 \"general_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && !fp_operand (operands[0], VOIDmode)\n-   && !fp_operand (operands[1], VOIDmode)\n+   && !FP_REG_P (operands[0])\n+   && !FP_REG_P (operands[1])\n    && !s_operand (operands[0], VOIDmode)\n    && !s_operand (operands[1], VOIDmode)\n    && (register_operand (operands[0], VOIDmode)\n@@ -1257,8 +1257,8 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (match_operand:DF 1 \"memory_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && !fp_operand (operands[0], VOIDmode)\n-   && !fp_operand (operands[1], VOIDmode)\n+   && !FP_REG_P (operands[0])\n+   && !FP_REG_P (operands[1])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n   \""}]}