{"sha": "71ad0b5dde449ee1f6b755a99f5c52152e375835", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFhZDBiNWRkZTQ0OWVlMWY2Yjc1NWE5OWY1YzUyMTUyZTM3NTgzNQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-16T20:04:01Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-16T20:04:01Z"}, "message": "Detect conflicts between incompatible uses of the same attribute (PR c/78666).\n\nResolves:\nPR c/78666 - conflicting attribute alloc_size accepted\nPR c/96126 - conflicting attribute section accepted on redeclaration\n\ngcc/c-family/ChangeLog:\n\n\tPR c/78666\n\tPR c/96126\n\t* c-attribs.c (validate_attr_args): New function.\n\t(validate_attr_arg): Same.\n\t(handle_section_attribute): Call it.  Introduce a local variable.\n\t(handle_alloc_size_attribute):  Same.\n\t(handle_alloc_align_attribute): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/78666\n\tPR c/96126\n\t* gcc.dg/attr-alloc_align-5.c: New test.\n\t* gcc.dg/attr-alloc_size-13.c: New test.\n\t* gcc.dg/attr-section.c: New test.\n\t* c-c++-common/builtin-has-attribute-3.c: Add xfails due to expected\n\twarnings to be cleaned up.", "tree": {"sha": "d8aacb3f5738c5779118020e1777dae5e2e45bcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8aacb3f5738c5779118020e1777dae5e2e45bcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71ad0b5dde449ee1f6b755a99f5c52152e375835", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71ad0b5dde449ee1f6b755a99f5c52152e375835", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71ad0b5dde449ee1f6b755a99f5c52152e375835", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71ad0b5dde449ee1f6b755a99f5c52152e375835/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31dd5cd6344bfbbe122fb512993b128e11236d35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31dd5cd6344bfbbe122fb512993b128e11236d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31dd5cd6344bfbbe122fb512993b128e11236d35"}], "stats": {"total": 281, "additions": 248, "deletions": 33}, "files": [{"sha": "8c898adc39733de1ee4febb9a90cc5fbae120751", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 169, "deletions": 24, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=71ad0b5dde449ee1f6b755a99f5c52152e375835", "patch": "@@ -720,6 +720,134 @@ positional_argument (const_tree fntype, const_tree atname, tree pos,\n   return pos;\n }\n \n+/* Return the first of DECL or TYPE attributes installed in NODE if it's\n+   a DECL, or TYPE attributes if it's a TYPE, or null otherwise.  */\n+\n+static tree\n+decl_or_type_attrs (tree node)\n+{\n+  if (DECL_P (node))\n+    {\n+      if (tree attrs = DECL_ATTRIBUTES (node))\n+\treturn attrs;\n+\n+      tree type = TREE_TYPE (node);\n+      return TYPE_ATTRIBUTES (type);\n+    }\n+\n+  if (TYPE_P (node))\n+    return TYPE_ATTRIBUTES (node);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Given a pair of NODEs for arbitrary DECLs or TYPEs, validate one or\n+   two integral or string attribute arguments NEWARGS to be applied to\n+   NODE[0] for the absence of conflicts with the same attribute arguments\n+   already applied to NODE[1]. Issue a warning for conflicts and return\n+   false.  Otherwise, when no conflicts are found, return true.  */\n+\n+static bool\n+validate_attr_args (tree node[2], tree name, tree newargs[2])\n+{\n+  /* First validate the arguments against those already applied to\n+     the same declaration (or type).  */\n+  tree self[2] = { node[0], node[0] };\n+  if (node[0] != node[1] && !validate_attr_args (self, name, newargs))\n+    return false;\n+\n+  if (!node[1])\n+    return true;\n+\n+  /* Extract the same attribute from the previous declaration or type.  */\n+  tree prevattr = decl_or_type_attrs (node[1]);\n+  const char* const namestr = IDENTIFIER_POINTER (name);\n+  prevattr = lookup_attribute (namestr, prevattr);\n+  if (!prevattr)\n+    return true;\n+\n+  /* Extract one or both attribute arguments.  */\n+  tree prevargs[2];\n+  prevargs[0] = TREE_VALUE (TREE_VALUE (prevattr));\n+  prevargs[1] = TREE_CHAIN (TREE_VALUE (prevattr));\n+  if (prevargs[1])\n+    prevargs[1] = TREE_VALUE (prevargs[1]);\n+\n+  /* Both arguments must be equal or, for the second pair, neither must\n+     be provided to succeed.  */\n+  bool arg1eq, arg2eq;\n+  if (TREE_CODE (newargs[0]) == INTEGER_CST)\n+    {\n+      arg1eq = tree_int_cst_equal (newargs[0], prevargs[0]);\n+      if (newargs[1] && prevargs[1])\n+\targ2eq = tree_int_cst_equal (newargs[1], prevargs[1]);\n+      else\n+\targ2eq = newargs[1] == prevargs[1];\n+    }\n+  else if (TREE_CODE (newargs[0]) == STRING_CST)\n+    {\n+      const char *s0 = TREE_STRING_POINTER (newargs[0]);\n+      const char *s1 = TREE_STRING_POINTER (prevargs[0]);\n+      arg1eq = strcmp (s0, s1) == 0;\n+      if (newargs[1] && prevargs[1])\n+\t{\n+\t  s0 = TREE_STRING_POINTER (newargs[1]);\n+\t  s1 = TREE_STRING_POINTER (prevargs[1]);\n+\t  arg2eq = strcmp (s0, s1) == 0;\n+\t}\n+      else\n+\targ2eq = newargs[1] == prevargs[1];\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  if (arg1eq && arg2eq)\n+    return true;\n+\n+  /* If the two locations are different print a note pointing to\n+     the previous one.  */\n+  const location_t curloc = input_location;\n+  const location_t prevloc =\n+    DECL_P (node[1]) ? DECL_SOURCE_LOCATION (node[1]) : curloc;\n+\n+  /* Format the attribute specification for convenience.  */\n+  char newspec[80], prevspec[80];\n+  if (newargs[1])\n+    snprintf (newspec, sizeof newspec, \"%s (%s, %s)\", namestr,\n+\t      print_generic_expr_to_str (newargs[0]),\n+\t      print_generic_expr_to_str (newargs[1]));\n+  else\n+    snprintf (newspec, sizeof newspec, \"%s (%s)\", namestr,\n+\t      print_generic_expr_to_str (newargs[0]));\n+\n+  if (prevargs[1])\n+    snprintf (prevspec, sizeof prevspec, \"%s (%s, %s)\", namestr,\n+\t      print_generic_expr_to_str (prevargs[0]),\n+\t      print_generic_expr_to_str (prevargs[1]));\n+  else\n+    snprintf (prevspec, sizeof prevspec, \"%s (%s)\", namestr,\n+\t      print_generic_expr_to_str (prevargs[0]));\n+\n+  if (warning_at (curloc, OPT_Wattributes,\n+\t\t  \"ignoring attribute %qs because it conflicts \"\n+\t\t  \"with previous %qs\",\n+\t\t  newspec, prevspec)\n+      && curloc != prevloc)\n+    inform (prevloc, \"previous declaration here\");\n+\n+  return false;\n+}\n+\n+/* Convenience wrapper for validate_attr_args to validate a single\n+   attribute argument.  Used by handlers for attributes that take\n+   just a single argument.  */\n+\n+static bool\n+validate_attr_arg (tree node[2], tree name, tree newarg)\n+{\n+  tree argarray[2] = { newarg, NULL_TREE };\n+  return validate_attr_args (node, name, argarray);\n+}\n \n /* Attribute handlers common to C front ends.  */\n \n@@ -1889,11 +2017,13 @@ handle_mode_attribute (tree *node, tree name, tree args,\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n-\t\t\t  int ARG_UNUSED (flags), bool *no_add_attrs)\n+handle_section_attribute (tree *node, tree name, tree args,\n+\t\t\t  int flags, bool *no_add_attrs)\n {\n   tree decl = *node;\n   tree res = NULL_TREE;\n+  tree argval = TREE_VALUE (args);\n+  const char* new_section_name;\n \n   if (!targetm_common.have_named_sections)\n     {\n@@ -1908,7 +2038,7 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       goto fail;\n     }\n \n-  if (TREE_CODE (TREE_VALUE (args)) != STRING_CST)\n+  if (TREE_CODE (argval) != STRING_CST)\n     {\n       error (\"section attribute argument not a string constant\");\n       goto fail;\n@@ -1923,15 +2053,17 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       goto fail;\n     }\n \n+  new_section_name = TREE_STRING_POINTER (argval);\n+\n   /* The decl may have already been given a section attribute\n      from a previous declaration.  Ensure they match.  */\n-  if (DECL_SECTION_NAME (decl) != NULL\n-      && strcmp (DECL_SECTION_NAME (decl),\n-\t\t TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n-    {\n-      error (\"section of %q+D conflicts with previous declaration\", *node);\n-      goto fail;\n-    }\n+  if (const char* const old_section_name = DECL_SECTION_NAME (decl))\n+    if (strcmp (old_section_name, new_section_name) != 0)\n+      {\n+\terror (\"section of %q+D conflicts with previous declaration\",\n+\t       *node);\n+\tgoto fail;\n+      }\n \n   if (VAR_P (decl)\n       && !targetm.have_tls && targetm.emutls.tmpl_section\n@@ -1941,14 +2073,17 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       goto fail;\n     }\n \n+  if (!validate_attr_arg (node, name, argval))\n+    goto fail;\n+\n   res = targetm.handle_generic_attribute (node, name, args, flags,\n \t\t\t\t\t  no_add_attrs);\n \n   /* If the back end confirms the attribute can be added then continue onto\n      final processing.  */\n   if (!(*no_add_attrs))\n     {\n-      set_decl_section_name (decl, TREE_STRING_POINTER (TREE_VALUE (args)));\n+      set_decl_section_name (decl, new_section_name);\n       return res;\n     }\n \n@@ -2905,15 +3040,15 @@ handle_malloc_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   return NULL_TREE;\n }\n \n-/* Handle a \"alloc_size\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n+/* Handle the \"alloc_size (argpos1 [, argpos2])\" function type attribute.\n+   *NODE is the type of the function the attribute is being applied to.  */\n \n static tree\n handle_alloc_size_attribute (tree *node, tree name, tree args,\n \t\t\t     int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n-  tree decl = *node;\n-  tree rettype = TREE_TYPE (decl);\n+  tree fntype = *node;\n+  tree rettype = TREE_TYPE (fntype);\n   if (!POINTER_TYPE_P (rettype))\n     {\n       warning (OPT_Wattributes,\n@@ -2923,6 +3058,7 @@ handle_alloc_size_attribute (tree *node, tree name, tree args,\n       return NULL_TREE;\n     }\n \n+  tree newargs[2] = { NULL_TREE, NULL_TREE };\n   for (int i = 1; args; ++i)\n     {\n       tree pos = TREE_VALUE (args);\n@@ -2931,30 +3067,36 @@ handle_alloc_size_attribute (tree *node, tree name, tree args,\n \t the argument number in diagnostics (since there's just one\n \t mentioning it is unnecessary and coule be confusing).  */\n       tree next = TREE_CHAIN (args);\n-      if (tree val = positional_argument (decl, name, pos, INTEGER_TYPE,\n+      if (tree val = positional_argument (fntype, name, pos, INTEGER_TYPE,\n \t\t\t\t\t  next || i > 1 ? i : 0))\n-\tTREE_VALUE (args) = val;\n+\t{\n+\t  TREE_VALUE (args) = val;\n+\t  newargs[i - 1] = val;\n+\t}\n       else\n \t{\n \t  *no_add_attrs = true;\n-\t  break;\n+\t  return NULL_TREE;\n \t}\n \n       args = next;\n     }\n \n+  if (!validate_attr_args (node, name, newargs))\n+    *no_add_attrs = true;\n+\n   return NULL_TREE;\n }\n \n-/* Handle a \"alloc_align\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n+\n+/* Handle an \"alloc_align (argpos)\" attribute.  */\n \n static tree\n handle_alloc_align_attribute (tree *node, tree name, tree args, int,\n \t\t\t      bool *no_add_attrs)\n {\n-  tree decl = *node;\n-  tree rettype = TREE_TYPE (decl);\n+  tree fntype = *node;\n+  tree rettype = TREE_TYPE (fntype);\n   if (!POINTER_TYPE_P (rettype))\n     {\n       warning (OPT_Wattributes,\n@@ -2964,9 +3106,12 @@ handle_alloc_align_attribute (tree *node, tree name, tree args, int,\n       return NULL_TREE;\n     }\n \n-  if (!positional_argument (*node, name, TREE_VALUE (args), INTEGER_TYPE))\n-    *no_add_attrs = true;\n+  if (tree val = positional_argument (*node, name, TREE_VALUE (args),\n+\t\t\t\t      INTEGER_TYPE))\n+    if (validate_attr_arg (node, name, val))\n+      return NULL_TREE;\n \n+  *no_add_attrs = true;\n   return NULL_TREE;\n }\n "}, {"sha": "5736bab94432bb8d7d0787cbd5ce7158c8236f63", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-3.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c?ref=71ad0b5dde449ee1f6b755a99f5c52152e375835", "patch": "@@ -75,7 +75,7 @@ void test_alloc_align (void)\n   A (0, fnone, alloc_align (1));        /* { dg-warning \"\\\\\\[-Wattributes\" } */\n   A (0, falloc_size_1, alloc_align (1));\n   A (1, falloc_align_1, alloc_align (1));\n-  A (0, falloc_align_2, alloc_align (1));\n+  A (0, falloc_align_2, alloc_align (1));   /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n   A (1, falloc_align_2, alloc_align (2));\n }\n \n@@ -88,26 +88,26 @@ void test_alloc_size_malloc (void)\n   A (0, falloc_align_1, alloc_size (1));\n   A (0, falloc_align_2, alloc_size (1));\n   A (1, falloc_size_1, alloc_size (1));\n-  A (0, falloc_size_1, alloc_size (2));\n-  A (0, falloc_size_2, alloc_size (1));\n+  A (0, falloc_size_1, alloc_size (2));     /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n+  A (0, falloc_size_2, alloc_size (1));     /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n   A (1, falloc_size_2, alloc_size (2));\n \n   A (1, falloc_size_2_4, alloc_size);\n   /* It would probably make more sense to have the built-in return\n      true only when both alloc_size arguments match, not just one\n      or the other.  */\n-  A (0, falloc_size_2_4, alloc_size (1));\n-  A (1, falloc_size_2_4, alloc_size (2));\n-  A (0, falloc_size_2_4, alloc_size (3));\n-  A (1, falloc_size_2_4, alloc_size (4));\n+  A (0, falloc_size_2_4, alloc_size (1));   /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n+  A (1, falloc_size_2_4, alloc_size (2));   /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n+  A (0, falloc_size_2_4, alloc_size (3));   /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n+  A (1, falloc_size_2_4, alloc_size (4));   /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n   A (1, falloc_size_2_4, alloc_size (2, 4));\n \n   extern ATTR (alloc_size (3))\n     void* fmalloc_size_3 (int, int, int);\n \n   A (1, fmalloc_size_3, alloc_size);\n-  A (0, fmalloc_size_3, alloc_size (1));\n-  A (0, fmalloc_size_3, alloc_size (2));\n+  A (0, fmalloc_size_3, alloc_size (1));    /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n+  A (0, fmalloc_size_3, alloc_size (2));    /* { dg-bogus \"\\\\\\[-Wattributes\" \"pr?????\" { xfail *-*-* } }\" */\n   A (1, fmalloc_size_3, alloc_size (3));\n   A (0, fmalloc_size_3, malloc);\n "}, {"sha": "d6f2bc19da8ce04dd99f20581c5ccda178aee2b6", "filename": "gcc/testsuite/gcc.dg/attr-alloc_align-5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-5.c?ref=71ad0b5dde449ee1f6b755a99f5c52152e375835", "patch": "@@ -0,0 +1,23 @@\n+/* PR c/78666 - conflicting attribute alloc_size accepted\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define A(pos) __attribute__ ((alloc_align (pos)))\n+\n+A (1) char* f2_1 (int, int);\n+A (1) char* f2_1 (int, int);            // { dg-message \"previous declaration here\" }\n+\n+A (2) char* f2_1 (int, int);            // { dg-warning \"ignoring attribute 'alloc_align \\\\\\(2\\\\\\)' because it conflicts with previous 'alloc_align \\\\\\(1\\\\\\)'\" }\n+\n+\n+A (2) char* f2_2 (int, int);\n+A (2) char* f2_2 (int, int);            // { dg-message \"previous declaration here\" }\n+\n+A (1) char* f2_2 (int, int);            // { dg-warning \"ignoring attribute 'alloc_align \\\\\\(1\\\\\\)' because it conflicts with previous 'alloc_align \\\\\\(2\\\\\\)'\" }\n+\n+\n+A (1) char* f3_1 (int, int, int);\n+A (1) char* f3_1 (int, int, int);       // { dg-message \"previous declaration here\" }\n+\n+A (2) char* f3_1 (int, int, int);       // { dg-warning \"ignoring attribute 'alloc_align \\\\\\(2\\\\\\)' because it conflicts with previous 'alloc_align \\\\\\(1\\\\\\)'\" }\n+A (3) char* f3_1 (int, int, int);       // { dg-warning \"ignoring attribute 'alloc_align \\\\\\(3\\\\\\)' because it conflicts with previous 'alloc_align \\\\\\(1\\\\\\)'\" }"}, {"sha": "df44f479e07c0ecfb5e75c9c2751f22e7f7757d9", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-13.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-13.c?ref=71ad0b5dde449ee1f6b755a99f5c52152e375835", "patch": "@@ -0,0 +1,34 @@\n+/* PR c/78666 - conflicting attribute alloc_size accepted\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define A(...) __attribute__ ((alloc_size (__VA_ARGS__)))\n+\n+A (1) char* f2_1 (int, int);\n+A (1) A (1) char* f2_1 (int, int);\n+\n+A (1) char* f2_1 (int, int);            // { dg-message \"previous declaration here\" }\n+\n+A (2) char* f2_1 (int, int);            // { dg-warning \"ignoring attribute 'alloc_size \\\\\\(2\\\\\\)' because it conflicts with previous 'alloc_size \\\\\\(1\\\\\\)'\" }\n+\n+\n+A (2) char* f2_2 (int, int);\n+A (2) char* f2_2 (int, int);            // { dg-message \"previous declaration here\" }\n+\n+A (1) char* f2_2 (int, int);            // { dg-warning \"ignoring attribute 'alloc_size \\\\\\(1\\\\\\)' because it conflicts with previous 'alloc_size \\\\\\(2\\\\\\)'\" }\n+\n+\n+A (1) char* f3_1 (int, int, int);\n+A (1) char* f3_1 (int, int, int);       // { dg-message \"previous declaration here\" }\n+\n+A (2) char* f3_1 (int, int, int);       // { dg-warning \"ignoring attribute 'alloc_size \\\\\\(2\\\\\\)' because it conflicts with previous 'alloc_size \\\\\\(1\\\\\\)'\" }\n+A (3) char* f3_1 (int, int, int);       // { dg-warning \"ignoring attribute 'alloc_size \\\\\\(3\\\\\\)' because it conflicts with previous 'alloc_size \\\\\\(1\\\\\\)'\" }\n+A (1, 2) char* f3_1 (int, int, int);    // { dg-warning \"ignoring attribute 'alloc_size \\\\\\(1, 2\\\\\\)' because it conflicts with previous 'alloc_size \\\\\\(1\\\\\\)'\" }\n+A (1, 3) char* f3_1 (int, int, int);    // { dg-warning \"ignoring attribute 'alloc_size \\\\\\(1, 3\\\\\\)' because it conflicts with previous 'alloc_size \\\\\\(1\\\\\\)'\" }\n+\n+\n+typedef A (2, 3) char* F3_2_3 (int, int, int);\n+typedef A (2, 3) char* F3_2_3 (int, int, int);\n+typedef A (2, 3) A (2, 3) char* F3_2_3 (int, int, int);\n+\n+typedef A (1) char* F3_2_3 (int, int, int);   // { dg-warning \"ignoring attribute 'alloc_size \\\\\\(1\\\\\\)' because it conflicts with previous 'alloc_size \\\\\\(2, 3\\\\\\)'\" }"}, {"sha": "0062b544c718e751970245d1be84c23b2a2c59ad", "filename": "gcc/testsuite/gcc.dg/attr-section.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-section.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71ad0b5dde449ee1f6b755a99f5c52152e375835/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-section.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-section.c?ref=71ad0b5dde449ee1f6b755a99f5c52152e375835", "patch": "@@ -0,0 +1,13 @@\n+/* PR c/96126 - conflicting attribute section accepted on redeclaration\n+   { dg-do compile }\n+   { dg-options \"-Wall\" }\n+   { dg-require-named-sections \"\" } */\n+\n+__attribute__ ((section (\"s1\"))) void f1 (void);\n+__attribute__ ((section (\"s2\"))) void f1 (void);  // { dg-warning \"ignoring attribute 'section \\\\\\(\\\"s2\\\"\\\\\\)' because it conflicts with previous 'section \\\\\\(\\\"s1\\\"\\\\\\)'\" }\n+\n+__attribute__ ((section (\"s3\"), section (\"s4\")))\n+void f2 (void);                                   // { dg-error \"conflicts\" }\n+\n+__attribute__ ((section (\"s5\"))) __attribute ((section (\"s6\")))\n+void f3 (void);                                   // { dg-error \"conflicts\" }"}]}