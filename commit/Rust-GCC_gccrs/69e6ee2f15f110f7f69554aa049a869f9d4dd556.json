{"sha": "69e6ee2f15f110f7f69554aa049a869f9d4dd556", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjllNmVlMmYxNWYxMTBmN2Y2OTU1NGFhMDQ5YTg2OWY5ZDRkZDU1Ng==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-03T08:14:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-03T08:14:57Z"}, "message": "[Ada] ABE checks v3.0, foundations of Elaboration order v4.0\n\n------------------------\n-- Elaboration checks --\n------------------------\n\nThe dynamic ABE checks model now emits the same diagnostics as those of the\nstatic ABE checks model.\n\nThe ABE checks mechanism has been redesigned and refactored in the face of\nincreasing requirements. Most of the functionality can now be toggled, thus\nallowing for various combinations of behavior. The combinations are defined\nas \"initial states\" and may be further altered.\n\nScenarios and targets have been distinctly separated at the higher level,\ninstead of directly working with nodes and entitites. Scenarios and targets\nnow carry a representation which removes the need to constantly recompute\nrelevant attributes, and offers a common interface for the various processors.\n\nMost processing has now been refactored into \"services\" which perform a single\nABE-related function.\n\n-----------------------\n-- Elaboration order --\n-----------------------\n\nA new elaboration order mechanism based on the use of an invocation graph to\nprovide extra information about the flow of execution at elaboration time has\nbeen introduced.\n\nThe ABE checks mechanism has been altered to encode pieces of the invocation\ngraph in the associated ALI files of units.\n\nThe new elaboration order mechanism reconstructs the full invocation graph at\nbind time, and coupled with the library item graph, determines the elaboration\norder of units.\n\nThe new elaboration order mechanism is currently inaccessible.\n\n------------\n-- Source --\n------------\n\n--  pack.ads\n\npackage Pack is\n   procedure ABE_Proc;\n   procedure Safe_Proc;\nend Pack;\n\n--  pack.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\npackage body Pack is\n   function Call_Proc (ABE : Boolean) return Integer;\n\n   procedure Safe_Proc is\n   begin\n      Put_Line (\"safe\");\n   end Safe_Proc;\n\n   function Call_Proc (ABE : Boolean) return Integer is\n   begin\n      if ABE then\n         ABE_Proc;\n      else\n         Safe_Proc;\n      end if;\n\n      return 0;\n   end Call_Proc;\n\n   Elab_1 : constant Integer := Call_Proc (ABE => False);\n   Elab_2 : constant Integer := Call_Proc (ABE => True);\n\n   procedure ABE_Proc is\n   begin\n      Put_Line (\"ABE\");\n   end ABE_Proc;\nend Pack;\n\n--  main.adb\n\nwith Pack;\n\nprocedure Main is begin null; end Main;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -f -q -gnatE main.adb\n$ ./main\n$ gnatmake -f -q -gnatE main.adb -gnatDG -gnatwL\n$ grep -c \"safeE\" pack.adb.dg\npack.adb:14:10: warning: cannot call \"ABE_Proc\" before body seen\npack.adb:14:10: warning: Program_Error may be raised at run time\npack.adb:14:10: warning:   body of unit \"Pack\" elaborated\npack.adb:14:10: warning:   function \"Call_Proc\" called at line 22\npack.adb:14:10: warning:   procedure \"ABE_Proc\" called at line 14\npack.adb:14:10: warning: cannot call \"ABE_Proc\" before body seen\npack.adb:14:10: warning: Program_Error may be raised at run time\npack.adb:14:10: warning:   body of unit \"Pack\" elaborated\npack.adb:14:10: warning:   function \"Call_Proc\" called at line 23\npack.adb:14:10: warning:   procedure \"ABE_Proc\" called at line 14\nsafe\n\nraised PROGRAM_ERROR : pack.adb:14 access before elaboration\n0\n\n2019-07-03  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* ali.adb: Add with and use clauses for GNAT,\n\tGNAT.Dynamic_HTables, and Snames.  Add a map from invocation\n\tsignature records to invocation signature ids.  Add various\n\tencodings of invocation-related attributes.  Sort and update\n\ttable Known_ALI_Lines.\n\t(Add_Invocation_Construct, Add_Invocation_Relation,\n\tBody_Placement_Kind_To_Code, Code_To_Body_Placement_Kind,\n\tCode_To_Invocation_Construct_Kind, Code_To_Invocation_Kind,\n\tCode_To_Invocation_Graph_Line_Kind, Destroy, Hash): New\n\troutines.\n\t(Initialize_ALI): Sort the initialization sequence. Add\n\tinitialization for all invocation-related tables.\n\t(Invocation_Construct_Kind_To_Code,\n\tInvocation_Graph_Line_Kind_To_Code, Invocation_Kind_To_Code,\n\tInvocation_Signature_Of, Present): New routines.\n\t(Scan_ALI): Add the default values for invocation-related ids.\n\tScan invocation graph lines.\n\t(Scan_Invocation_Graph_Line): New routine.\n\t* ali.ads: Add with clause for GNAT.Dynamic_Tables.  Add types\n\tfor invocation constructs, relations, and signatures.  Add\n\ttables for invocation constructs, relations, and signatures.\n\tUpdate Unit_Record to capture invocation-related ids.  Relocate\n\ttable Unit_Id_Tables and subtypes Unit_Id_Table, Unit_Id_Array\n\tfrom Binde.\n\t(Add_Invocation_Construct, Add_Invocation_Relation,\n\tBody_Placement_Kind_To_Code, Code_To_Body_Placement_Kind,\n\tCode_To_Invocation_Construct_Kind, Code_To_Invocation_Kind,\n\tCode_To_Invocation_Graph_Line_Kind,\n\tInvocation_Construct_Kind_To_Code,\n\tInvocation_Graph_Line_Kind_To_Code, Invocation_Kind_To_Code,\n\tInvocation_Signature_Of, Present): New routines.\n\t* binde.adb: Add with and use clause for Types.  Add use clause\n\tfor ALI.Unit_Id_Tables;\n\t* binde.ads: Relocate table Unit_Id_Tables and subtypes\n\tUnit_Id_Table, Unit_Id_Array to ALI.\n\t* bindgen.adb: Remove with and use clause for ALI.\n\t* bindgen.ads: Remove with and use clause for Binde.  Add with\n\tand use clause for ALI.\n\t* bindo.adb,  bindo.ads, bindo-augmentors.adb,\n\tbindo-augmentors.ads, bindo-builders.adb, bindo-builders.ads,\n\tbindo-diagnostics.adb, bindo-diagnostics.ads,\n\tbindo-elaborators.adb, bindo-elaborators.ads, bindo-graphs.adb,\n\tbindo-graphs.ads, bindo-units.adb, bindo-units.ads,\n\tbindo-validators.adb, bindo-validators.ads, bindo-writers.adb,\n\tbindo-writers.ads: New units.\n\t* debug.adb: Use and describe GNAT debug switches -gnatd_F and\n\t-gnatd_G.  Add GNATbind debug switches in the ranges dA .. dZ,\n\td.a .. d.z, d.A .. d.Z, d.1 .. d.9, d_a .. d_z, d_A .. d_Z, and\n\td_1 .. d_9.  Use and describe GNATbind debug switches -d_A,\n\t-d_I, -d_L, -d_N, -d_O, -d_T, and -d_V.\n\t* exp_util.adb, exp_util.ads (Exceptions_OK): Relocate to\n\tSem_Util.\n\t* gnatbind.adb: Add with and use clause for Bindo.  Use the new\n\tBindo elaboration order only when -d_N is in effect.\n\t* lib-writ.adb\n\t(Column, Extra, Invoker, Kind, Line, Locations, Name, Placement,\n\tScope, Signature, Target): New routines.\n\t(Write_ALI): Output all invocation-related data.\n\t(Write_Invocation_Graph): New routine.\n\t* lib-writ.ads: Document the invocation graph ALI line.\n\t* namet.adb, namet.ads (Present): New routines.\n\t* sem_ch8.adb (Find_Direct_Name): Capture the status of\n\telaboration checks and warnings of an identifier.\n\t(Find_Expanded_Name): Capture the status of elaboration checks\n\tand warnings of an expanded name.\n\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Ensure\n\tthat invocation graph-related data within the body of the main\n\tunit is encoded in the ALI file.\n\t(Analyze_Generic_Subprogram_Declaration): Ensure that invocation\n\tgraph-related data within the body of the main unit is encoded\n\tin the ALI file.\n\t(Analyze_Package_Instantiation): Perform minimal decoration of\n\tthe instance entity.\n\t(Analyze_Subprogram_Instantiation): Perform minimal decoration\n\tof the instance entity.\n\t* sem_elab.adb: Perform heavy refactoring of all code. The unit\n\tis now split into \"services\" which specialize in one area of ABE\n\tchecks.  Add processing in order to capture invocation-graph\n\trelated attributes of the main unit, and encode them in the ALI\n\tfile.  The Processing phase can now operate in multiple modes,\n\tall described by type Processing_Kind.  Scenarios and targets\n\tare now distinct at the higher level, and carry their own\n\trepresentations. This eliminates the need to constantly\n\trecompute their attributes, and offers the various processors a\n\tuniform interface.  The various initial states of the Processing\n\tphase are now encoded using type Processing_In_State, and\n\txxx_State constants.\n\t* sem_elab.ads: Update the literals of type\n\tEnclosing_Level_Kind.  Add Inline pragmas on several routines.\n\t* sem_prag.adb (Process_Inline): Ensure that invocation\n\tgraph-related data within the body of the main unit is encoded\n\tin the ALI file.\n\t* sem_util.adb (Enclosing_Generic_Body, Enclosing_Generic_Unit):\n\tCode clean up.\n\t(Exceptions_OK): Relocated from Sem_Util.\n\t(Mark_Save_Invocation_Graph_Of_Body): New routine.\n\t* sem_util.ads (Exceptions_OK): Relocated from Sem_Util.\n\t(Mark_Save_Invocation_Graph_Of_Body): New routine.\n\t* sinfo.adb (Is_Elaboration_Checks_OK_Node): Now applicable to\n\tN_Variable_Reference_Marker.\n\t(Is_Elaboration_Warnings_OK_Node): Now applicable to\n\tN_Expanded_Name, N_Identifier, N_Variable_Reference_Marker.\n\t(Is_Read): Use Flag4.\n\t(Is_SPARK_Mode_On_Node): New applicable to\n\tN_Variable_Reference_Marker.\n\t(Is_Write): Use Flag5.\n\t(Save_Invocation_Graph_Of_Body): New routine.\n\t(Set_Is_Elaboration_Checks_OK_Node): Now applicable to\n\tN_Variable_Reference_Marker.\n\t(Set_Is_Elaboration_Warnings_OK_Node): Now applicable to\n\tN_Expanded_Name, N_Identifier, N_Variable_Reference_Marker.\n\t(Set_Is_SPARK_Mode_On_Node): New applicable to\n\tN_Variable_Reference_Marker.\n\t(Set_Save_Invocation_Graph_Of_Body): New routine.\n\t* sinfo.ads: Update the documentation of attributes\n\tIs_Elaboration_Checks_OK_Node, Is_Elaboration_Warnings_OK_Node,\n\tIs_SPARK_Mode_On_Node.  Update the flag usage of attributes\n\tIs_Read, Is_Write.  Add attribute Save_Invocation_Graph_Of_Body\n\tand update its occurrence in nodes.\n\t(Save_Invocation_Graph_Of_Body): New routine along with pragma\n\tInline.\n\t(Set_Save_Invocation_Graph_Of_Body): New routine along with\n\tpragma Inline.\n\t* switch-b.adb (Scan_Binder_Switches): Refactor the scanning of\n\tdebug switches.\n\t(Scan_Debug_Switches): New routine.\n\t* libgnat/g-dynhta.adb, libgnat/g-dynhta.ads (Contains): New routine.\n\t* libgnat/g-graphs.adb (Associate_Vertices): Update the use of\n\tComponent_Vertex_Iterator.\n\t(Contains_Component, Contains_Edge, Contains_Vertex, Has_Next):\n\tReimplemented.\n\t(Iterate_Component_Vertices): New routine.\n\t(Iterate_Vertices): Removed.\n\t(Next): Update the parameter profile.\n\t(Number_Of_Component_Vertices, Number_Of_Outgoing_Edges): New\n\troutines.\n\t* libgnat/g-graphs.ads: Update the initialization of\n\tNo_Component.  Add type Component_Vertex_Iterator.  Remove type\n\tVertex_Iterator.\n\t(Has_Next): Add new versions and remove old ones.\n\t(Iterate_Component_Vertices): New routine.\n\t(Iterate_Vertices): Removed.\n\t(Next): Add new versions and remove old ones.\n\t(Number_Of_Component_Vertices, Number_Of_Outgoing_Edges): New\n\troutines.\n\t* libgnat/g-sets.adb (Contains): Reimplemented.\n\t* gcc-interface/Make-lang.in (GNATBIND_OBJS): Add\n\tGNAT.Dynamic_HTables, GNAT.Graphs and Bindo units.\n\t* rtsfind.ads: Remove extra space.\n\nFrom-SVN: r272976", "tree": {"sha": "7c604261c0a82b7d002026e6d7f9081e8f559369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c604261c0a82b7d002026e6d7f9081e8f559369"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69e6ee2f15f110f7f69554aa049a869f9d4dd556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69e6ee2f15f110f7f69554aa049a869f9d4dd556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69e6ee2f15f110f7f69554aa049a869f9d4dd556", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69e6ee2f15f110f7f69554aa049a869f9d4dd556/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14bc12f0b188c847976c747e8c8389977a37187e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14bc12f0b188c847976c747e8c8389977a37187e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14bc12f0b188c847976c747e8c8389977a37187e"}], "stats": {"total": 33138, "additions": 24692, "deletions": 8446}, "files": [{"sha": "15d40a5e399fe4dc86c8349b1acb7925c3a6a727", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -1,3 +1,155 @@\n+2019-07-03  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* ali.adb: Add with and use clauses for GNAT,\n+\tGNAT.Dynamic_HTables, and Snames.  Add a map from invocation\n+\tsignature records to invocation signature ids.  Add various\n+\tencodings of invocation-related attributes.  Sort and update\n+\ttable Known_ALI_Lines.\n+\t(Add_Invocation_Construct, Add_Invocation_Relation,\n+\tBody_Placement_Kind_To_Code, Code_To_Body_Placement_Kind,\n+\tCode_To_Invocation_Construct_Kind, Code_To_Invocation_Kind,\n+\tCode_To_Invocation_Graph_Line_Kind, Destroy, Hash): New\n+\troutines.\n+\t(Initialize_ALI): Sort the initialization sequence. Add\n+\tinitialization for all invocation-related tables.\n+\t(Invocation_Construct_Kind_To_Code,\n+\tInvocation_Graph_Line_Kind_To_Code, Invocation_Kind_To_Code,\n+\tInvocation_Signature_Of, Present): New routines.\n+\t(Scan_ALI): Add the default values for invocation-related ids.\n+\tScan invocation graph lines.\n+\t(Scan_Invocation_Graph_Line): New routine.\n+\t* ali.ads: Add with clause for GNAT.Dynamic_Tables.  Add types\n+\tfor invocation constructs, relations, and signatures.  Add\n+\ttables for invocation constructs, relations, and signatures.\n+\tUpdate Unit_Record to capture invocation-related ids.  Relocate\n+\ttable Unit_Id_Tables and subtypes Unit_Id_Table, Unit_Id_Array\n+\tfrom Binde.\n+\t(Add_Invocation_Construct, Add_Invocation_Relation,\n+\tBody_Placement_Kind_To_Code, Code_To_Body_Placement_Kind,\n+\tCode_To_Invocation_Construct_Kind, Code_To_Invocation_Kind,\n+\tCode_To_Invocation_Graph_Line_Kind,\n+\tInvocation_Construct_Kind_To_Code,\n+\tInvocation_Graph_Line_Kind_To_Code, Invocation_Kind_To_Code,\n+\tInvocation_Signature_Of, Present): New routines.\n+\t* binde.adb: Add with and use clause for Types.  Add use clause\n+\tfor ALI.Unit_Id_Tables;\n+\t* binde.ads: Relocate table Unit_Id_Tables and subtypes\n+\tUnit_Id_Table, Unit_Id_Array to ALI.\n+\t* bindgen.adb: Remove with and use clause for ALI.\n+\t* bindgen.ads: Remove with and use clause for Binde.  Add with\n+\tand use clause for ALI.\n+\t* bindo.adb,  bindo.ads, bindo-augmentors.adb,\n+\tbindo-augmentors.ads, bindo-builders.adb, bindo-builders.ads,\n+\tbindo-diagnostics.adb, bindo-diagnostics.ads,\n+\tbindo-elaborators.adb, bindo-elaborators.ads, bindo-graphs.adb,\n+\tbindo-graphs.ads, bindo-units.adb, bindo-units.ads,\n+\tbindo-validators.adb, bindo-validators.ads, bindo-writers.adb,\n+\tbindo-writers.ads: New units.\n+\t* debug.adb: Use and describe GNAT debug switches -gnatd_F and\n+\t-gnatd_G.  Add GNATbind debug switches in the ranges dA .. dZ,\n+\td.a .. d.z, d.A .. d.Z, d.1 .. d.9, d_a .. d_z, d_A .. d_Z, and\n+\td_1 .. d_9.  Use and describe GNATbind debug switches -d_A,\n+\t-d_I, -d_L, -d_N, -d_O, -d_T, and -d_V.\n+\t* exp_util.adb, exp_util.ads (Exceptions_OK): Relocate to\n+\tSem_Util.\n+\t* gnatbind.adb: Add with and use clause for Bindo.  Use the new\n+\tBindo elaboration order only when -d_N is in effect.\n+\t* lib-writ.adb\n+\t(Column, Extra, Invoker, Kind, Line, Locations, Name, Placement,\n+\tScope, Signature, Target): New routines.\n+\t(Write_ALI): Output all invocation-related data.\n+\t(Write_Invocation_Graph): New routine.\n+\t* lib-writ.ads: Document the invocation graph ALI line.\n+\t* namet.adb, namet.ads (Present): New routines.\n+\t* sem_ch8.adb (Find_Direct_Name): Capture the status of\n+\telaboration checks and warnings of an identifier.\n+\t(Find_Expanded_Name): Capture the status of elaboration checks\n+\tand warnings of an expanded name.\n+\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Ensure\n+\tthat invocation graph-related data within the body of the main\n+\tunit is encoded in the ALI file.\n+\t(Analyze_Generic_Subprogram_Declaration): Ensure that invocation\n+\tgraph-related data within the body of the main unit is encoded\n+\tin the ALI file.\n+\t(Analyze_Package_Instantiation): Perform minimal decoration of\n+\tthe instance entity.\n+\t(Analyze_Subprogram_Instantiation): Perform minimal decoration\n+\tof the instance entity.\n+\t* sem_elab.adb: Perform heavy refactoring of all code. The unit\n+\tis now split into \"services\" which specialize in one area of ABE\n+\tchecks.  Add processing in order to capture invocation-graph\n+\trelated attributes of the main unit, and encode them in the ALI\n+\tfile.  The Processing phase can now operate in multiple modes,\n+\tall described by type Processing_Kind.  Scenarios and targets\n+\tare now distinct at the higher level, and carry their own\n+\trepresentations. This eliminates the need to constantly\n+\trecompute their attributes, and offers the various processors a\n+\tuniform interface.  The various initial states of the Processing\n+\tphase are now encoded using type Processing_In_State, and\n+\txxx_State constants.\n+\t* sem_elab.ads: Update the literals of type\n+\tEnclosing_Level_Kind.  Add Inline pragmas on several routines.\n+\t* sem_prag.adb (Process_Inline): Ensure that invocation\n+\tgraph-related data within the body of the main unit is encoded\n+\tin the ALI file.\n+\t* sem_util.adb (Enclosing_Generic_Body, Enclosing_Generic_Unit):\n+\tCode clean up.\n+\t(Exceptions_OK): Relocated from Sem_Util.\n+\t(Mark_Save_Invocation_Graph_Of_Body): New routine.\n+\t* sem_util.ads (Exceptions_OK): Relocated from Sem_Util.\n+\t(Mark_Save_Invocation_Graph_Of_Body): New routine.\n+\t* sinfo.adb (Is_Elaboration_Checks_OK_Node): Now applicable to\n+\tN_Variable_Reference_Marker.\n+\t(Is_Elaboration_Warnings_OK_Node): Now applicable to\n+\tN_Expanded_Name, N_Identifier, N_Variable_Reference_Marker.\n+\t(Is_Read): Use Flag4.\n+\t(Is_SPARK_Mode_On_Node): New applicable to\n+\tN_Variable_Reference_Marker.\n+\t(Is_Write): Use Flag5.\n+\t(Save_Invocation_Graph_Of_Body): New routine.\n+\t(Set_Is_Elaboration_Checks_OK_Node): Now applicable to\n+\tN_Variable_Reference_Marker.\n+\t(Set_Is_Elaboration_Warnings_OK_Node): Now applicable to\n+\tN_Expanded_Name, N_Identifier, N_Variable_Reference_Marker.\n+\t(Set_Is_SPARK_Mode_On_Node): New applicable to\n+\tN_Variable_Reference_Marker.\n+\t(Set_Save_Invocation_Graph_Of_Body): New routine.\n+\t* sinfo.ads: Update the documentation of attributes\n+\tIs_Elaboration_Checks_OK_Node, Is_Elaboration_Warnings_OK_Node,\n+\tIs_SPARK_Mode_On_Node.  Update the flag usage of attributes\n+\tIs_Read, Is_Write.  Add attribute Save_Invocation_Graph_Of_Body\n+\tand update its occurrence in nodes.\n+\t(Save_Invocation_Graph_Of_Body): New routine along with pragma\n+\tInline.\n+\t(Set_Save_Invocation_Graph_Of_Body): New routine along with\n+\tpragma Inline.\n+\t* switch-b.adb (Scan_Binder_Switches): Refactor the scanning of\n+\tdebug switches.\n+\t(Scan_Debug_Switches): New routine.\n+\t* libgnat/g-dynhta.adb, libgnat/g-dynhta.ads (Contains): New routine.\n+\t* libgnat/g-graphs.adb (Associate_Vertices): Update the use of\n+\tComponent_Vertex_Iterator.\n+\t(Contains_Component, Contains_Edge, Contains_Vertex, Has_Next):\n+\tReimplemented.\n+\t(Iterate_Component_Vertices): New routine.\n+\t(Iterate_Vertices): Removed.\n+\t(Next): Update the parameter profile.\n+\t(Number_Of_Component_Vertices, Number_Of_Outgoing_Edges): New\n+\troutines.\n+\t* libgnat/g-graphs.ads: Update the initialization of\n+\tNo_Component.  Add type Component_Vertex_Iterator.  Remove type\n+\tVertex_Iterator.\n+\t(Has_Next): Add new versions and remove old ones.\n+\t(Iterate_Component_Vertices): New routine.\n+\t(Iterate_Vertices): Removed.\n+\t(Next): Add new versions and remove old ones.\n+\t(Number_Of_Component_Vertices, Number_Of_Outgoing_Edges): New\n+\troutines.\n+\t* libgnat/g-sets.adb (Contains): Reimplemented.\n+\t* gcc-interface/Make-lang.in (GNATBIND_OBJS): Add\n+\tGNAT.Dynamic_HTables, GNAT.Graphs and Bindo units.\n+\t* rtsfind.ads: Remove extra space.\n+\n 2019-07-03  Yannick Moy  <moy@adacore.com>\n \n \t* sem_spark.adb: Add support for locally borrowing and observing"}, {"sha": "978fb3d73a1bb4237c4b443a09764e867c20ee36", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 687, "deletions": 57, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -29,39 +29,328 @@ with Fname;  use Fname;\n with Opt;    use Opt;\n with Osint;  use Osint;\n with Output; use Output;\n+with Snames; use Snames;\n+\n+with GNAT;                 use GNAT;\n+with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n \n package body ALI is\n \n    use ASCII;\n    --  Make control characters visible\n \n+   ---------------------\n+   -- Data structures --\n+   ---------------------\n+\n+   procedure Destroy (IS_Id : in out Invocation_Signature_Id);\n+   --  Destroy an invocation signature with id IS_Id\n+\n+   function Hash\n+     (IS_Rec : Invocation_Signature_Record) return Bucket_Range_Type;\n+   --  Obtain the hash of key IS_Rec\n+\n+   package Sig_Map is new Dynamic_Hash_Tables\n+     (Key_Type              => Invocation_Signature_Record,\n+      Value_Type            => Invocation_Signature_Id,\n+      No_Value              => No_Invocation_Signature,\n+      Expansion_Threshold   => 1.5,\n+      Expansion_Factor      => 2,\n+      Compression_Threshold => 0.3,\n+      Compression_Factor    => 2,\n+      \"=\"                   => \"=\",\n+      Destroy_Value         => Destroy,\n+      Hash                  => Hash);\n+\n+   --  The following map relates invocation signature records to invocation\n+   --  signature ids.\n+\n+   Sig_To_Sig_Map : constant Sig_Map.Dynamic_Hash_Table :=\n+                      Sig_Map.Create (500);\n+\n+   --  The folowing table maps body placement kinds to character codes for\n+   --  invocation construct encoding in ALI files.\n+\n+   Body_Placement_Codes :\n+     constant array (Body_Placement_Kind) of Character :=\n+       (In_Body           => 'b',\n+        In_Spec           => 's',\n+        No_Body_Placement => 'Z');\n+\n+   --  The following table maps invocation kinds to character codes for\n+   --  invocation relation encoding in ALI files.\n+\n+   Invocation_Codes :\n+     constant array (Invocation_Kind) of Character :=\n+       (Accept_Alternative                     => 'a',\n+        Access_Taken                           => 'b',\n+        Call                                   => 'c',\n+        Controlled_Adjustment                  => 'd',\n+        Controlled_Finalization                => 'e',\n+        Controlled_Initialization              => 'f',\n+        Default_Initial_Condition_Verification => 'g',\n+        Initial_Condition_Verification         => 'h',\n+        Instantiation                          => 'i',\n+        Internal_Controlled_Adjustment         => 'j',\n+        Internal_Controlled_Finalization       => 'k',\n+        Internal_Controlled_Initialization     => 'l',\n+        Invariant_Verification                 => 'm',\n+        Postcondition_Verification             => 'n',\n+        Protected_Entry_Call                   => 'o',\n+        Protected_Subprogram_Call              => 'p',\n+        Task_Activation                        => 'q',\n+        Task_Entry_Call                        => 'r',\n+        Type_Initialization                    => 's',\n+        No_Invocation                          => 'Z');\n+\n+   --  The following table maps invocation construct kinds to character codes\n+   --  for invocation construct encoding in ALI files.\n+\n+   Invocation_Construct_Codes :\n+     constant array (Invocation_Construct_Kind) of Character :=\n+       (Elaborate_Body_Procedure => 'b',\n+        Elaborate_Spec_Procedure => 's',\n+        Regular_Construct        => 'Z');\n+\n+   --  The following table maps invocation graph line kinds to character codes\n+   --  used in ALI files.\n+\n+   Invocation_Graph_Line_Codes :\n+     constant array (Invocation_Graph_Line_Kind) of Character :=\n+       (Invocation_Construct_Line => 'c',\n+        Invocation_Relation_Line  => 'r');\n+\n    --  The following variable records which characters currently are used as\n    --  line type markers in the ALI file. This is used in Scan_ALI to detect\n    --  (or skip) invalid lines. The following letters are still available:\n    --\n-   --    B F G H J K O Q Z\n+   --    B F H J K O Q Z\n \n    Known_ALI_Lines : constant array (Character range 'A' .. 'Z') of Boolean :=\n-     ('V'    => True,   -- version\n-      'M'    => True,   -- main program\n-      'A'    => True,   -- argument\n-      'P'    => True,   -- program\n-      'R'    => True,   -- restriction\n-      'I'    => True,   -- interrupt\n-      'U'    => True,   -- unit\n-      'W'    => True,   -- with\n-      'L'    => True,   -- linker option\n-      'N'    => True,   -- notes\n-      'E'    => True,   -- external\n-      'D'    => True,   -- dependency\n-      'X'    => True,   -- xref\n-      'S'    => True,   -- specific dispatching\n-      'Y'    => True,   -- limited_with\n-      'Z'    => True,   -- implicit with from instantiation\n-      'C'    => True,   -- SCO information\n-      'T'    => True,   -- task stack information\n+     ('A'    => True,  --  argument\n+      'C'    => True,  --  SCO information\n+      'D'    => True,  --  dependency\n+      'E'    => True,  --  external\n+      'G'    => True,  --  invocation graph\n+      'I'    => True,  --  interrupt\n+      'L'    => True,  --  linker option\n+      'M'    => True,  --  main program\n+      'N'    => True,  --  notes\n+      'P'    => True,  --  program\n+      'R'    => True,  --  restriction\n+      'S'    => True,  --  specific dispatching\n+      'T'    => True,  --  task stack information\n+      'U'    => True,  --  unit\n+      'V'    => True,  --  version\n+      'W'    => True,  --  with\n+      'X'    => True,  --  xref\n+      'Y'    => True,  --  limited_with\n+      'Z'    => True,  --  implicit with from instantiation\n       others => False);\n \n+   ------------------------------\n+   -- Add_Invocation_Construct --\n+   ------------------------------\n+\n+   procedure Add_Invocation_Construct\n+     (IC_Rec       : Invocation_Construct_Record;\n+      Update_Units : Boolean := True)\n+   is\n+      IC_Id : Invocation_Construct_Id;\n+\n+   begin\n+      pragma Assert (Present (IC_Rec.Signature));\n+\n+      --  Create a invocation construct from the scanned attributes\n+\n+      Invocation_Constructs.Append (IC_Rec);\n+      IC_Id := Invocation_Constructs.Last;\n+\n+      --  Update the invocation construct counter of the current unit only when\n+      --  requested by the caller.\n+\n+      if Update_Units then\n+         declare\n+            Curr_Unit : Unit_Record renames Units.Table (Units.Last);\n+\n+         begin\n+            Curr_Unit.Last_Invocation_Construct := IC_Id;\n+         end;\n+      end if;\n+   end Add_Invocation_Construct;\n+\n+   -----------------------------\n+   -- Add_Invocation_Relation --\n+   -----------------------------\n+\n+   procedure Add_Invocation_Relation\n+     (IR_Rec       : Invocation_Relation_Record;\n+      Update_Units : Boolean := True)\n+   is\n+      IR_Id : Invocation_Relation_Id;\n+\n+   begin\n+      pragma Assert (Present (IR_Rec.Invoker));\n+      pragma Assert (Present (IR_Rec.Target));\n+      pragma Assert (IR_Rec.Kind /= No_Invocation);\n+\n+      --  Create an invocation relation from the scanned attributes\n+\n+      Invocation_Relations.Append (IR_Rec);\n+      IR_Id := Invocation_Relations.Last;\n+\n+      --  Update the invocation relation counter of the current unit only when\n+      --  requested by the caller.\n+\n+      if Update_Units then\n+         declare\n+            Curr_Unit : Unit_Record renames Units.Table (Units.Last);\n+\n+         begin\n+            Curr_Unit.Last_Invocation_Relation := IR_Id;\n+         end;\n+      end if;\n+   end Add_Invocation_Relation;\n+\n+   ---------------------------------\n+   -- Body_Placement_Kind_To_Code --\n+   ---------------------------------\n+\n+   function Body_Placement_Kind_To_Code\n+     (Kind : Body_Placement_Kind) return Character\n+   is\n+   begin\n+      return Body_Placement_Codes (Kind);\n+   end Body_Placement_Kind_To_Code;\n+\n+   ---------------------------------\n+   -- Code_To_Body_Placement_Kind --\n+   ---------------------------------\n+\n+   function Code_To_Body_Placement_Kind\n+     (Code : Character) return Body_Placement_Kind\n+   is\n+   begin\n+      --  Determine which body placement kind corresponds to the character code\n+      --  by traversing the contents of the mapping table.\n+\n+      for Kind in Body_Placement_Kind loop\n+         if Body_Placement_Codes (Kind) = Code then\n+            return Kind;\n+         end if;\n+      end loop;\n+\n+      raise Program_Error;\n+   end Code_To_Body_Placement_Kind;\n+\n+   ---------------------------------------\n+   -- Code_To_Invocation_Construct_Kind --\n+   ---------------------------------------\n+\n+   function Code_To_Invocation_Construct_Kind\n+     (Code : Character) return Invocation_Construct_Kind\n+   is\n+   begin\n+      --  Determine which invocation construct kind matches the character code\n+      --  by traversing the contents of the mapping table.\n+\n+      for Kind in Invocation_Construct_Kind loop\n+         if Invocation_Construct_Codes (Kind) = Code then\n+            return Kind;\n+         end if;\n+      end loop;\n+\n+      raise Program_Error;\n+   end Code_To_Invocation_Construct_Kind;\n+\n+   -----------------------------\n+   -- Code_To_Invocation_Kind --\n+   -----------------------------\n+\n+   function Code_To_Invocation_Kind\n+     (Code : Character) return Invocation_Kind\n+   is\n+   begin\n+      --  Determine which invocation kind corresponds to the character code by\n+      --  traversing the contents of the mapping table.\n+\n+      for Kind in Invocation_Kind loop\n+         if Invocation_Codes (Kind) = Code then\n+            return Kind;\n+         end if;\n+      end loop;\n+\n+      raise Program_Error;\n+   end Code_To_Invocation_Kind;\n+\n+   ----------------------------------------\n+   -- Code_To_Invocation_Graph_Line_Kind --\n+   ----------------------------------------\n+\n+   function Code_To_Invocation_Graph_Line_Kind\n+     (Code : Character) return Invocation_Graph_Line_Kind\n+   is\n+   begin\n+      --  Determine which invocation graph line kind matches the character\n+      --  code by traversing the contents of the mapping table.\n+\n+      for Kind in Invocation_Graph_Line_Kind loop\n+         if Invocation_Graph_Line_Codes (Kind) = Code then\n+            return Kind;\n+         end if;\n+      end loop;\n+\n+      raise Program_Error;\n+   end Code_To_Invocation_Graph_Line_Kind;\n+\n+   -------------\n+   -- Destroy --\n+   -------------\n+\n+   procedure Destroy (IS_Id : in out Invocation_Signature_Id) is\n+      pragma Unreferenced (IS_Id);\n+   begin\n+      null;\n+   end Destroy;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash\n+     (IS_Rec : Invocation_Signature_Record) return Bucket_Range_Type\n+   is\n+      Buffer : Bounded_String (2052);\n+      IS_Nam : Name_Id;\n+\n+   begin\n+      --  The hash is obtained in the following manner:\n+      --\n+      --    * A String signature based on the scope, name, line number, column\n+      --      number, and locations, in the following format:\n+      --\n+      --         scope__name__line_column__locations\n+      --\n+      --    * The String is converted into a Name_Id\n+      --    * The Name_Id is used as the hash\n+\n+      Append (Buffer, IS_Rec.Scope);\n+      Append (Buffer, \"__\");\n+      Append (Buffer, IS_Rec.Name);\n+      Append (Buffer, \"__\");\n+      Append (Buffer, IS_Rec.Line);\n+      Append (Buffer, '_');\n+      Append (Buffer, IS_Rec.Column);\n+\n+      if IS_Rec.Locations /= No_Name then\n+         Append (Buffer, \"__\");\n+         Append (Buffer, IS_Rec.Locations);\n+      end if;\n+\n+      IS_Nam := Name_Find (Buffer);\n+      return Bucket_Range_Type (IS_Nam);\n+   end Hash;\n+\n    --------------------\n    -- Initialize_ALI --\n    --------------------\n@@ -90,16 +379,19 @@ package body ALI is\n       --  Initialize all tables\n \n       ALIs.Init;\n+      Invocation_Constructs.Init;\n+      Invocation_Relations.Init;\n+      Invocation_Signatures.Init;\n+      Linker_Options.Init;\n       No_Deps.Init;\n+      Notes.Init;\n+      Sdep.Init;\n       Units.Init;\n+      Version_Ref.Reset;\n       Withs.Init;\n-      Sdep.Init;\n-      Linker_Options.Init;\n-      Notes.Init;\n-      Xref_Section.Init;\n       Xref_Entity.Init;\n       Xref.Init;\n-      Version_Ref.Reset;\n+      Xref_Section.Init;\n \n       --  Add dummy zero'th item in Linker_Options and Notes for sort calls\n \n@@ -125,6 +417,131 @@ package body ALI is\n       Zero_Cost_Exceptions_Specified         := False;\n    end Initialize_ALI;\n \n+   ---------------------------------------\n+   -- Invocation_Construct_Kind_To_Code --\n+   ---------------------------------------\n+\n+   function Invocation_Construct_Kind_To_Code\n+     (Kind : Invocation_Construct_Kind) return Character\n+   is\n+   begin\n+      return Invocation_Construct_Codes (Kind);\n+   end Invocation_Construct_Kind_To_Code;\n+\n+   ----------------------------------------\n+   -- Invocation_Graph_Line_Kind_To_Code --\n+   ----------------------------------------\n+\n+   function Invocation_Graph_Line_Kind_To_Code\n+     (Kind : Invocation_Graph_Line_Kind) return Character\n+   is\n+   begin\n+      return Invocation_Graph_Line_Codes (Kind);\n+   end Invocation_Graph_Line_Kind_To_Code;\n+\n+   -----------------------------\n+   -- Invocation_Kind_To_Code --\n+   -----------------------------\n+\n+   function Invocation_Kind_To_Code\n+     (Kind : Invocation_Kind) return Character\n+   is\n+   begin\n+      return Invocation_Codes (Kind);\n+   end Invocation_Kind_To_Code;\n+\n+   -----------------------------\n+   -- Invocation_Signature_Of --\n+   -----------------------------\n+\n+   function Invocation_Signature_Of\n+     (Column    : Nat;\n+      Line      : Nat;\n+      Locations : Name_Id;\n+      Name      : Name_Id;\n+      Scope     : Name_Id) return Invocation_Signature_Id\n+   is\n+      IS_Rec : constant Invocation_Signature_Record :=\n+                 (Column    => Column,\n+                  Line      => Line,\n+                  Locations => Locations,\n+                  Name      => Name,\n+                  Scope     => Scope);\n+      IS_Id  : Invocation_Signature_Id;\n+\n+   begin\n+      IS_Id := Sig_Map.Get (Sig_To_Sig_Map, IS_Rec);\n+\n+      --  The invocation signature lacks an id. This indicates that it\n+      --  is encountered for the first time during the construction of\n+      --  the graph.\n+\n+      if not Present (IS_Id) then\n+         Invocation_Signatures.Append (IS_Rec);\n+         IS_Id := Invocation_Signatures.Last;\n+\n+         --  Map the invocation signature record to its corresponding id\n+\n+         Sig_Map.Put (Sig_To_Sig_Map, IS_Rec, IS_Id);\n+      end if;\n+\n+      return IS_Id;\n+   end Invocation_Signature_Of;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (IC_Id : Invocation_Construct_Id) return Boolean is\n+   begin\n+      return IC_Id /= No_Invocation_Construct;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (IR_Id : Invocation_Relation_Id) return Boolean is\n+   begin\n+      return IR_Id /= No_Invocation_Relation;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (IS_Id : Invocation_Signature_Id) return Boolean is\n+   begin\n+      return IS_Id /= No_Invocation_Signature;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (Dep : Sdep_Id) return Boolean is\n+   begin\n+      return Dep /= No_Sdep_Id;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (U_Id : Unit_Id) return Boolean is\n+   begin\n+      return U_Id /= No_Unit_Id;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (W_Id : With_Id) return Boolean is\n+   begin\n+      return W_Id /= No_With_Id;\n+   end Present;\n+\n    --------------\n    -- Scan_ALI --\n    --------------\n@@ -256,6 +673,9 @@ package body ALI is\n          Standard_Entity : out Name_Id);\n       --  Parse the definition of a typeref (<...>, {...} or (...))\n \n+      procedure Scan_Invocation_Graph_Line;\n+      --  Parse a single line which encodes a piece of the invocation graph\n+\n       procedure Skip_Eol;\n       --  Skip past spaces, then skip past end of line (fatal error if not\n       --  at end of line). Also skips past any following blank lines.\n@@ -771,6 +1191,202 @@ package body ALI is\n          return T (P);\n       end Nextc;\n \n+      --------------------------------\n+      -- Scan_Invocation_Graph_Line --\n+      --------------------------------\n+\n+      procedure Scan_Invocation_Graph_Line is\n+         procedure Scan_Invocation_Construct_Line;\n+         pragma Inline (Scan_Invocation_Construct_Line);\n+         --  Parse an invocation construct line and construct the corresponding\n+         --  construct. The following data structures are updated:\n+         --\n+         --    * Invocation_Constructs\n+         --    * Units\n+\n+         procedure Scan_Invocation_Relation_Line;\n+         pragma Inline (Scan_Invocation_Relation_Line);\n+         --  Parse an invocation relation line and construct the corresponding\n+         --  relation. The following data structures are updated:\n+         --\n+         --    * Invocation_Relations\n+         --    * Units\n+\n+         function Scan_Invocation_Signature return Invocation_Signature_Id;\n+         pragma Inline (Scan_Invocation_Signature);\n+         --  Parse a single invocation signature while populating the following\n+         --  data structures:\n+         --\n+         --    * Invocation_Signatures\n+         --    * Sig_To_Sig_Map\n+\n+         ------------------------------------\n+         -- Scan_Invocation_Construct_Line --\n+         ------------------------------------\n+\n+         procedure Scan_Invocation_Construct_Line is\n+            IC_Rec : Invocation_Construct_Record;\n+\n+         begin\n+            --  construct-kind\n+\n+            IC_Rec.Kind := Code_To_Invocation_Construct_Kind (Getc);\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  construct-body-placement\n+\n+            IC_Rec.Placement := Code_To_Body_Placement_Kind (Getc);\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  construct-signature\n+\n+            IC_Rec.Signature := Scan_Invocation_Signature;\n+            pragma Assert (Present (IC_Rec.Signature));\n+\n+            Skip_Eol;\n+\n+            Add_Invocation_Construct (IC_Rec);\n+         end Scan_Invocation_Construct_Line;\n+\n+         -----------------------------------\n+         -- Scan_Invocation_Relation_Line --\n+         -----------------------------------\n+\n+         procedure Scan_Invocation_Relation_Line is\n+            IR_Rec : Invocation_Relation_Record;\n+\n+         begin\n+            --  relation-kind\n+\n+            IR_Rec.Kind := Code_To_Invocation_Kind (Getc);\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  (extra-name | \"none\")\n+\n+            IR_Rec.Extra := Get_Name;\n+\n+            if IR_Rec.Extra = Name_None then\n+               IR_Rec.Extra := No_Name;\n+            end if;\n+\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  invoker-signature\n+\n+            IR_Rec.Invoker := Scan_Invocation_Signature;\n+            pragma Assert (Present (IR_Rec.Invoker));\n+\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  target-signature\n+\n+            IR_Rec.Target := Scan_Invocation_Signature;\n+            pragma Assert (Present (IR_Rec.Target));\n+\n+            Skip_Eol;\n+\n+            Add_Invocation_Relation (IR_Rec);\n+         end Scan_Invocation_Relation_Line;\n+\n+         -------------------------------\n+         -- Scan_Invocation_Signature --\n+         -------------------------------\n+\n+         function Scan_Invocation_Signature return Invocation_Signature_Id is\n+            Column    : Nat;\n+            Line      : Nat;\n+            Locations : Name_Id;\n+            Name      : Name_Id;\n+            Scope     : Name_Id;\n+\n+         begin\n+            --  [\n+\n+            Checkc ('[');\n+\n+            --  name\n+\n+            Name := Get_Name;\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  scope\n+\n+            Scope := Get_Name;\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  line\n+\n+            Line := Get_Nat;\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  column\n+\n+            Column := Get_Nat;\n+            Checkc (' ');\n+            Skip_Space;\n+\n+            --  (locations | \"none\")\n+\n+            Locations := Get_Name;\n+\n+            if Locations = Name_None then\n+               Locations := No_Name;\n+            end if;\n+\n+            --  ]\n+\n+            Checkc (']');\n+\n+            --  Create an invocation signature from the scanned attributes\n+\n+            return\n+              Invocation_Signature_Of\n+                (Column    => Column,\n+                 Line      => Line,\n+                 Locations => Locations,\n+                 Name      => Name,\n+                 Scope     => Scope);\n+         end Scan_Invocation_Signature;\n+\n+         --  Local variables\n+\n+         Line : Invocation_Graph_Line_Kind;\n+\n+      --  Start of processing for Scan_Invocation_Graph_Line\n+\n+      begin\n+         if Ignore ('G') then\n+            return;\n+         end if;\n+\n+         Checkc (' ');\n+         Skip_Space;\n+\n+         --  line-kind\n+\n+         Line := Code_To_Invocation_Graph_Line_Kind (Getc);\n+         Checkc (' ');\n+         Skip_Space;\n+\n+         --  line-attributes\n+\n+         if Line = Invocation_Construct_Line then\n+            Scan_Invocation_Construct_Line;\n+\n+         else\n+            pragma Assert (Line = Invocation_Relation_Line);\n+            Scan_Invocation_Relation_Line;\n+         end if;\n+      end Scan_Invocation_Graph_Line;\n+\n       --------------\n       -- Skip_Eol --\n       --------------\n@@ -1716,38 +2332,42 @@ package body ALI is\n             UL : Unit_Record renames Units.Table (Units.Last);\n \n          begin\n-            UL.Uname                    := Get_Unit_Name;\n-            UL.Predefined               := Is_Predefined_Unit;\n-            UL.Internal                 := Is_Internal_Unit;\n-            UL.My_ALI                   := Id;\n-            UL.Sfile                    := Get_File_Name (Lower => True);\n-            UL.Pure                     := False;\n-            UL.Preelab                  := False;\n-            UL.No_Elab                  := False;\n-            UL.Shared_Passive           := False;\n-            UL.RCI                      := False;\n-            UL.Remote_Types             := False;\n-            UL.Serious_Errors           := False;\n-            UL.Has_RACW                 := False;\n-            UL.Init_Scalars             := False;\n-            UL.Is_Generic               := False;\n-            UL.Icasing                  := Mixed_Case;\n-            UL.Kcasing                  := All_Lower_Case;\n-            UL.Dynamic_Elab             := False;\n-            UL.Elaborate_Body           := False;\n-            UL.Set_Elab_Entity          := False;\n-            UL.Version                  := \"00000000\";\n-            UL.First_With               := Withs.Last + 1;\n-            UL.First_Arg                := First_Arg;\n-            UL.Elab_Position            := 0;\n-            UL.SAL_Interface            := ALIs.Table (Id).SAL_Interface;\n-            UL.Directly_Scanned         := Directly_Scanned;\n-            UL.Body_Needed_For_SAL      := False;\n-            UL.Elaborate_Body_Desirable := False;\n-            UL.Optimize_Alignment       := 'O';\n-            UL.Has_Finalizer            := False;\n-            UL.Primary_Stack_Count      := 0;\n-            UL.Sec_Stack_Count          := 0;\n+            UL.Uname                      := Get_Unit_Name;\n+            UL.Predefined                 := Is_Predefined_Unit;\n+            UL.Internal                   := Is_Internal_Unit;\n+            UL.My_ALI                     := Id;\n+            UL.Sfile                      := Get_File_Name (Lower => True);\n+            UL.Pure                       := False;\n+            UL.Preelab                    := False;\n+            UL.No_Elab                    := False;\n+            UL.Shared_Passive             := False;\n+            UL.RCI                        := False;\n+            UL.Remote_Types               := False;\n+            UL.Serious_Errors             := False;\n+            UL.Has_RACW                   := False;\n+            UL.Init_Scalars               := False;\n+            UL.Is_Generic                 := False;\n+            UL.Icasing                    := Mixed_Case;\n+            UL.Kcasing                    := All_Lower_Case;\n+            UL.Dynamic_Elab               := False;\n+            UL.Elaborate_Body             := False;\n+            UL.Set_Elab_Entity            := False;\n+            UL.Version                    := \"00000000\";\n+            UL.First_With                 := Withs.Last + 1;\n+            UL.First_Arg                  := First_Arg;\n+            UL.First_Invocation_Construct := Invocation_Constructs.Last + 1;\n+            UL.Last_Invocation_Construct  := No_Invocation_Construct;\n+            UL.First_Invocation_Relation  := Invocation_Relations.Last + 1;\n+            UL.Last_Invocation_Relation   := No_Invocation_Relation;\n+            UL.Elab_Position              := 0;\n+            UL.SAL_Interface              := ALIs.Table (Id).SAL_Interface;\n+            UL.Directly_Scanned           := Directly_Scanned;\n+            UL.Body_Needed_For_SAL        := False;\n+            UL.Elaborate_Body_Desirable   := False;\n+            UL.Optimize_Alignment         := 'O';\n+            UL.Has_Finalizer              := False;\n+            UL.Primary_Stack_Count        := 0;\n+            UL.Sec_Stack_Count            := 0;\n \n             if Debug_Flag_U then\n                Write_Str (\" ----> reading unit \");\n@@ -2444,6 +3064,17 @@ package body ALI is\n \n       ALIs.Table (Id).Last_Sdep := Sdep.Last;\n \n+      --  Loop through invocation graph lines\n+\n+      G_Loop : loop\n+         Check_Unknown_Line;\n+         exit G_Loop when C /= 'G';\n+\n+         Scan_Invocation_Graph_Line;\n+\n+         C := Getc;\n+      end loop G_Loop;\n+\n       --  We must at this stage be at an Xref line or the end of file\n \n       if C = EOF then\n@@ -2786,7 +3417,6 @@ package body ALI is\n             --  Record last entity\n \n             XS.Last_Entity := Xref_Entity.Last;\n-\n          end Read_Refs_For_One_File;\n \n          C := Getc;"}, {"sha": "79eabb173d2b1bfe8237d1b6790b20d46a0b0c62", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -34,6 +34,7 @@ with Rident;  use Rident;\n with Table;\n with Types;   use Types;\n \n+with GNAT.Dynamic_Tables;\n with GNAT.HTable; use GNAT.HTable;\n \n package ALI is\n@@ -66,6 +67,39 @@ package ALI is\n    type Priority_Specific_Dispatching_Id is range 0 .. 99_999_999;\n    --  Id values used for Priority_Specific_Dispatching table entries\n \n+   type Invocation_Construct_Id is range 0 .. 99_999_999;\n+   --  Id values used for Invocation_Constructs table entries\n+\n+   type Invocation_Relation_Id is range 0 .. 99_999_999;\n+   --  Id values used for Invocation_Relations table entries\n+\n+   type Invocation_Signature_Id is range 0 .. 99_999_999;\n+   --  Id values used for Invocation_Signatures table entries\n+\n+   function Present (IC_Id : Invocation_Construct_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether invocation construct IC_Id exists\n+\n+   function Present (IR_Id : Invocation_Relation_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether invocation relation IR_Id exists\n+\n+   function Present (IS_Id : Invocation_Signature_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether invocation signature IS_Id exists\n+\n+   function Present (Dep : Sdep_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether dependant Dep exists\n+\n+   function Present (U_Id : Unit_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether unit U_Id exists\n+\n+   function Present (W_Id : With_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether with W_Id exists\n+\n    --------------------\n    -- ALI File Table --\n    --------------------\n@@ -334,6 +368,18 @@ package ALI is\n       Last_Arg : Arg_Id;\n       --  Id of last args table entry for this file\n \n+      First_Invocation_Construct : Invocation_Construct_Id;\n+      --  Id of the first invocation construct for this unit\n+\n+      Last_Invocation_Construct : Invocation_Construct_Id;\n+      --  Id of the last invocation construct for this unit\n+\n+      First_Invocation_Relation : Invocation_Relation_Id;\n+      --  Id of the first invocation relation for this unit\n+\n+      Last_Invocation_Relation : Invocation_Relation_Id;\n+      --  Id of the last invocation relation for this unit\n+\n       Utype : Unit_Type;\n       --  Type of entry\n \n@@ -408,6 +454,16 @@ package ALI is\n      Table_Increment      => 200,\n      Table_Name           => \"Unit\");\n \n+   package Unit_Id_Tables is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Unit_Id,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 500,\n+      Table_Increment      => 200);\n+\n+   subtype Unit_Id_Table is Unit_Id_Tables.Instance;\n+   subtype Unit_Id_Array is Unit_Id_Tables.Table_Type;\n+\n    ---------------------------\n    -- Interrupt State Table --\n    ---------------------------\n@@ -794,6 +850,7 @@ package ALI is\n \n       Unit_Name : Name_Id;\n       --  Name_Id for the unit name if not a subunit (No_Name for a subunit)\n+\n       Rfile : File_Name_Type;\n       --  Reference file name. Same as Sfile unless a Source_Reference pragma\n       --  was used, in which case it reflects the name used in the pragma.\n@@ -1026,6 +1083,265 @@ package ALI is\n      Table_Increment      => 300,\n      Table_Name           => \"Xref\");\n \n+   ----------------------------\n+   -- Invocation Graph Types --\n+   ----------------------------\n+\n+   --  The following type identifies an invocation signature\n+\n+   No_Invocation_Signature    : constant Invocation_Signature_Id :=\n+                                  Invocation_Signature_Id'First;\n+   First_Invocation_Signature : constant Invocation_Signature_Id :=\n+                                  No_Invocation_Signature + 1;\n+\n+   --  The following type represents an invocation signature. Its purpose is\n+   --  to uniquely identify an invocation construct within the ALI space. The\n+   --  signature is comprised out of several pieces, some of which are used in\n+   --  error diagnostics by the binder. Identification issues are resolved as\n+   --  follows:\n+   --\n+   --    * The Column, Line, and Locations attributes together differentiate\n+   --      between homonyms. In most cases, the Column and Line are sufficient\n+   --      except when generic instantiations are involved. Together, the three\n+   --      attributes offer a sequence of column-line pairs which eventually\n+   --      reflect the location within the generic template.\n+   --\n+   --    * The Name attribute differentiates between invocation constructs at\n+   --      the scope level. Since it is illegal for two entities with the same\n+   --      name to coexist in the same scope, the Name attribute is sufficient\n+   --      to distinguish them. Overloaded entities are already handled by the\n+   --      Column, Line, and Locations attributes.\n+   --\n+   --    * The Scope attribute differentiates between invocation constructs at\n+   --      various levels of nesting.\n+\n+   type Invocation_Signature_Record is record\n+      Column : Nat := 0;\n+      --  The column number where the invocation construct is declared\n+\n+      Line : Nat := 0;\n+      --  The line number where the invocation construct is declared\n+\n+      Locations : Name_Id := No_Name;\n+      --  Sequence of column and line numbers within nested instantiations\n+\n+      Name : Name_Id := No_Name;\n+      --  The name of the invocation construct\n+\n+      Scope : Name_Id := No_Name;\n+      --  The qualified name of the scope where the invocation construct is\n+      --  declared.\n+   end record;\n+\n+   --  The following type enumerates all possible placements of an invocation\n+   --  construct's body body with respect to the unit it is declared in.\n+\n+   type Body_Placement_Kind is\n+     (In_Body,\n+      --  The body of the invocation construct is within the body of the unit\n+      --  it is declared in.\n+\n+      In_Spec,\n+      --  The body of the invocation construct is within the spec of the unit\n+      --  it is declared in.\n+\n+      No_Body_Placement);\n+      --  The invocation construct does not have a body\n+\n+   --  The following type enumerates all possible invocation construct kinds\n+\n+   type Invocation_Construct_Kind is\n+     (Elaborate_Body_Procedure,\n+      --  The invocation construct denotes the procedure which elaborates a\n+      --  package body.\n+\n+      Elaborate_Spec_Procedure,\n+      --  The invocation construct denotes the procedure which elaborates a\n+      --  package spec.\n+\n+      Regular_Construct);\n+      --  The invocation construct is a normal invocation construct\n+\n+   --  The following type identifies an invocation construct\n+\n+   No_Invocation_Construct    : constant Invocation_Construct_Id :=\n+                                  Invocation_Construct_Id'First;\n+   First_Invocation_Construct : constant Invocation_Construct_Id :=\n+                                  No_Invocation_Construct + 1;\n+\n+   --  The following type represents an invocation construct\n+\n+   type Invocation_Construct_Record is record\n+      Kind : Invocation_Construct_Kind := Regular_Construct;\n+      --  The nature of the invocation construct\n+\n+      Placement : Body_Placement_Kind := No_Body_Placement;\n+      --  The location of the invocation construct's body with respect to the\n+      --  body of the unit it is declared in.\n+\n+      Signature : Invocation_Signature_Id := No_Invocation_Signature;\n+      --  The invocation signature which uniquely identifies the invocation\n+      --  construct in the ALI space.\n+   end record;\n+\n+   --  The following type identifies an invocation relation\n+\n+   No_Invocation_Relation    : constant Invocation_Relation_Id :=\n+                                 Invocation_Relation_Id'First;\n+   First_Invocation_Relation : constant Invocation_Relation_Id :=\n+                                 No_Invocation_Relation + 1;\n+\n+   --  The following type enumerates all possible invocation kinds\n+\n+   type Invocation_Kind is\n+     (Accept_Alternative,\n+      Access_Taken,\n+      Call,\n+      Controlled_Adjustment,\n+      Controlled_Finalization,\n+      Controlled_Initialization,\n+      Default_Initial_Condition_Verification,\n+      Initial_Condition_Verification,\n+      Instantiation,\n+      Internal_Controlled_Adjustment,\n+      Internal_Controlled_Finalization,\n+      Internal_Controlled_Initialization,\n+      Invariant_Verification,\n+      Postcondition_Verification,\n+      Protected_Entry_Call,\n+      Protected_Subprogram_Call,\n+      Task_Activation,\n+      Task_Entry_Call,\n+      Type_Initialization,\n+      No_Invocation);\n+\n+   subtype Internal_Controlled_Invocation_Kind is Invocation_Kind range\n+       Internal_Controlled_Adjustment ..\n+   --  Internal_Controlled_Finalization\n+       Internal_Controlled_Initialization;\n+\n+   --  The following type represents an invocation relation. It associates an\n+   --  invoker which activates/calls/instantiates with a target.\n+\n+   type Invocation_Relation_Record is record\n+      Extra : Name_Id := No_Name;\n+      --  The name of an additional entity used in error diagnostics\n+\n+      Invoker : Invocation_Signature_Id := No_Invocation_Signature;\n+      --  The invocation signature which uniquely identifies the invoker within\n+      --  the ALI space.\n+\n+      Kind : Invocation_Kind := No_Invocation;\n+      --  The nature of the invocation\n+\n+      Target : Invocation_Signature_Id := No_Invocation_Signature;\n+      --  The invocation signature which uniquely identifies the target within\n+      --  the ALI space.\n+   end record;\n+\n+   --  The following type enumerates all possible invocation graph ALI lines\n+\n+   type Invocation_Graph_Line_Kind is\n+     (Invocation_Construct_Line,\n+      Invocation_Relation_Line);\n+\n+   --------------------------------------\n+   -- Invocation Graph Data Structures --\n+   --------------------------------------\n+\n+   package Invocation_Constructs is new Table.Table\n+     (Table_Index_Type     => Invocation_Construct_Id,\n+      Table_Component_Type => Invocation_Construct_Record,\n+      Table_Low_Bound      => First_Invocation_Construct,\n+      Table_Initial        => 2500,\n+      Table_Increment      => 200,\n+      Table_Name           => \"Invocation_Constructs\");\n+\n+   package Invocation_Relations is new Table.Table\n+     (Table_Index_Type     => Invocation_Relation_Id,\n+      Table_Component_Type => Invocation_Relation_Record,\n+      Table_Low_Bound      => First_Invocation_Relation,\n+      Table_Initial        => 2500,\n+      Table_Increment      => 200,\n+      Table_Name           => \"Invocation_Relation\");\n+\n+   package Invocation_Signatures is new Table.Table\n+     (Table_Index_Type     => Invocation_Signature_Id,\n+      Table_Component_Type => Invocation_Signature_Record,\n+      Table_Low_Bound      => First_Invocation_Signature,\n+      Table_Initial        => 2500,\n+      Table_Increment      => 200,\n+      Table_Name           => \"Invocation_Signatures\");\n+\n+   ----------------------------------\n+   -- Invocation Graph Subprograms --\n+   ----------------------------------\n+\n+   procedure Add_Invocation_Construct\n+     (IC_Rec       : Invocation_Construct_Record;\n+      Update_Units : Boolean := True);\n+   pragma Inline (Add_Invocation_Construct);\n+   --  Add invocation construct attributes IC_Rec to internal data structures.\n+   --  Flag Undate_Units should be set when this addition must be reflected in\n+   --  the attributes of the current unit.\n+\n+   procedure Add_Invocation_Relation\n+     (IR_Rec       : Invocation_Relation_Record;\n+      Update_Units : Boolean := True);\n+   pragma Inline (Add_Invocation_Relation);\n+   --  Add invocation relation attributes IR_Rec to internal data structures.\n+   --  Flag Undate_Units should be set when this addition must be reflected in\n+   --  the attributes of the current unit.\n+\n+   function Body_Placement_Kind_To_Code\n+     (Kind : Body_Placement_Kind) return Character;\n+   pragma Inline (Body_Placement_Kind_To_Code);\n+   --  Obtain the character encoding of body placement kind Kind\n+\n+   function Code_To_Body_Placement_Kind\n+     (Code : Character) return Body_Placement_Kind;\n+   pragma Inline (Code_To_Body_Placement_Kind);\n+   --  Obtain the body placement kind of character encoding Code\n+\n+   function Code_To_Invocation_Construct_Kind\n+     (Code : Character) return Invocation_Construct_Kind;\n+   pragma Inline (Code_To_Invocation_Construct_Kind);\n+   --  Obtain the invocation construct kind of character encoding Code\n+\n+   function Code_To_Invocation_Kind\n+     (Code : Character) return Invocation_Kind;\n+   pragma Inline (Code_To_Invocation_Kind);\n+   --  Obtain the invocation kind of character encoding Code\n+\n+   function Code_To_Invocation_Graph_Line_Kind\n+     (Code : Character) return Invocation_Graph_Line_Kind;\n+   pragma Inline (Code_To_Invocation_Graph_Line_Kind);\n+   --  Obtain the invocation graph line kind of character encoding Code\n+\n+   function Invocation_Construct_Kind_To_Code\n+     (Kind : Invocation_Construct_Kind) return Character;\n+   pragma Inline (Invocation_Construct_Kind_To_Code);\n+   --  Obtain the character encoding of invocation kind Kind\n+\n+   function Invocation_Graph_Line_Kind_To_Code\n+     (Kind : Invocation_Graph_Line_Kind) return Character;\n+   pragma Inline (Invocation_Graph_Line_Kind_To_Code);\n+   --  Obtain the character encoding for invocation like kind Kind\n+\n+   function Invocation_Kind_To_Code\n+     (Kind : Invocation_Kind) return Character;\n+   pragma Inline (Invocation_Kind_To_Code);\n+   --  Obtain the character encoding of invocation kind Kind\n+\n+   function Invocation_Signature_Of\n+     (Column    : Nat;\n+      Line      : Nat;\n+      Locations : Name_Id;\n+      Name      : Name_Id;\n+      Scope     : Name_Id) return Invocation_Signature_Id;\n+   pragma Inline (Invocation_Signature_Of);\n+   --  Obtain the invocation signature that corresponds to the input attributes\n+\n    --------------------------------------\n    -- Subprograms for Reading ALI File --\n    --------------------------------------"}, {"sha": "d060fd88a74fe7ae9f65392444846144478d97c2", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -23,20 +23,22 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Binderr;  use Binderr;\n-with Butil;    use Butil;\n-with Debug;    use Debug;\n-with Fname;    use Fname;\n-with Opt;      use Opt;\n+with Binderr; use Binderr;\n+with Butil;   use Butil;\n+with Debug;   use Debug;\n+with Fname;   use Fname;\n+with Opt;     use Opt;\n with Osint;\n-with Output;   use Output;\n+with Output;  use Output;\n with Table;\n+with Types;   use Types;\n \n with System.Case_Util; use System.Case_Util;\n with System.HTable;\n with System.OS_Lib;\n \n package body Binde is\n+   use Unit_Id_Tables;\n \n    --  We now have Elab_New, a new elaboration-order algorithm.\n    --"}, {"sha": "bdea7dc7fb76c88c334067aad978a93bf8fcf880", "filename": "gcc/ada/binde.ads", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbinde.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbinde.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -28,23 +28,9 @@\n \n with ALI;   use ALI;\n with Namet; use Namet;\n-with Types; use Types;\n-\n-with GNAT.Dynamic_Tables;\n \n package Binde is\n \n-   package Unit_Id_Tables is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Unit_Id,\n-      Table_Index_Type     => Nat,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 500,\n-      Table_Increment      => 200);\n-   use Unit_Id_Tables;\n-\n-   subtype Unit_Id_Table is Unit_Id_Tables.Instance;\n-   subtype Unit_Id_Array is Unit_Id_Tables.Table_Type;\n-\n    procedure Find_Elab_Order\n      (Elab_Order          : out Unit_Id_Table;\n       First_Main_Lib_File : File_Name_Type);"}, {"sha": "e1355400ab0d6ee57d74c13948e0428800406b82", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -23,7 +23,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with ALI;      use ALI;\n with Casing;   use Casing;\n with Fname;    use Fname;\n with Gnatvsn;  use Gnatvsn;"}, {"sha": "722cfad5b09d508768900f9d2a942563512e1b71", "filename": "gcc/ada/bindgen.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindgen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindgen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -32,10 +32,9 @@\n \n --  See the body for exact details of the file that is generated\n \n-with Binde; use Binde;\n+with ALI; use ALI;\n \n package Bindgen is\n-\n    procedure Gen_Output_File\n      (Filename   : String;\n       Elab_Order : Unit_Id_Array);"}, {"sha": "b94ff7ab139c50c55b40581bb2b4fb67a4ed1b70", "filename": "gcc/ada/bindo-augmentors.adb", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-augmentors.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-augmentors.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-augmentors.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,372 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      B I N D O . A U G M E N T O R S                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;  use Debug;\n+with Output; use Output;\n+with Types;  use Types;\n+\n+with Bindo.Writers; use Bindo.Writers;\n+\n+with GNAT;      use GNAT;\n+with GNAT.Sets; use GNAT.Sets;\n+\n+package body Bindo.Augmentors is\n+\n+   ------------------------------\n+   -- Library_Graph_Augmentors --\n+   ------------------------------\n+\n+   package body Library_Graph_Augmentors is\n+\n+      -----------------\n+      -- Visited set --\n+      -----------------\n+\n+      package VS is new Membership_Sets\n+        (Element_Type => Invocation_Graph_Vertex_Id,\n+         \"=\"          => \"=\",\n+         Hash         => Hash_Invocation_Graph_Vertex);\n+      use VS;\n+\n+      -----------------\n+      -- Global data --\n+      -----------------\n+\n+      Inv_Graph : Invocation_Graph := Invocation_Graphs.Nil;\n+      Lib_Graph : Library_Graph    := Library_Graphs.Nil;\n+      Visited   : Membership_Set   := VS.Nil;\n+\n+      ----------------\n+      -- Statistics --\n+      ----------------\n+\n+      Longest_Path : Natural := 0;\n+      --  The length of the longest path found during the traversal of the\n+      --  invocation graph.\n+\n+      Total_Visited : Natural := 0;\n+      --  The number of visited invocation graph vertices during the process\n+      --  of augmentation.\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      function Is_Visited\n+        (IGV_Id : Invocation_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Visited);\n+      --  Determine whether invocation graph vertex IGV_Id has been visited\n+      --  during the traversal.\n+\n+      procedure Set_Is_Visited\n+        (IGV_Id : Invocation_Graph_Vertex_Id;\n+         Val    : Boolean := True);\n+      pragma Inline (Set_Is_Visited);\n+      --  Mark invocation graph vertex IGV_Id as visited during the traversal\n+      --  depending on value Val.\n+\n+      procedure Visit_Elaboration_Root (Root : Invocation_Graph_Vertex_Id);\n+      pragma Inline (Visit_Elaboration_Root);\n+      --  Start a DFS traversal from elaboration root Root to:\n+      --\n+      --    * Detect transitions between units.\n+      --\n+      --    * Create invocation edges for each such transition where the\n+      --      successor is Root.\n+\n+      procedure Visit_Elaboration_Roots;\n+      pragma Inline (Visit_Elaboration_Roots);\n+      --  Start a DFS traversal from all elaboration roots to:\n+      --\n+      --    * Detect transitions between units.\n+      --\n+      --    * Create invocation edges for each such transition where the\n+      --      successor is the current root.\n+\n+      procedure Visit_Vertex\n+        (Curr_IGV_Id   : Invocation_Graph_Vertex_Id;\n+         Last_LGV_Id   : Library_Graph_Vertex_Id;\n+         Root_LGV_Id   : Library_Graph_Vertex_Id;\n+         Internal_Ctrl : Boolean;\n+         Path          : Natural);\n+      pragma Inline (Visit_Vertex);\n+      --  Visit invocation graph vertex Curr_IGV_Id to:\n+      --\n+      --    * Detect a transition from the last library graph vertex denoted by\n+      --      Last_LGV_Id to the library graph vertex of Curr_IGV_Id.\n+      --\n+      --    * Create an invocation edge in library graph Lib_Graph to reflect\n+      --      the transition, where the predecessor is the library graph vertex\n+      --      or Curr_IGV_Id, and the successor is Root_LGV_Id.\n+      --\n+      --    * Visit the neighbours of Curr_IGV_Id.\n+      --\n+      --  Flag Internal_Ctrl should be set when the DFS traversal visited an\n+      --  internal controlled invocation edge. Path denotes is the length of\n+      --  the path.\n+\n+      procedure Write_Statistics;\n+      pragma Inline (Write_Statistics);\n+      --  Write the statistical information of the augmentation to standard\n+      --  output.\n+\n+      ---------------------------\n+      -- Augment_Library_Graph --\n+      ---------------------------\n+\n+      procedure Augment_Library_Graph\n+        (Inv_G : Invocation_Graph;\n+         Lib_G : Library_Graph)\n+      is\n+      begin\n+         pragma Assert (Present (Lib_G));\n+\n+         --  Nothing to do when there is no invocation graph\n+\n+         if not Present (Inv_G) then\n+            return;\n+         end if;\n+\n+         --  Prepare the global data. Note that Visited is initialized for each\n+         --  elaboration root.\n+\n+         Inv_Graph     := Inv_G;\n+         Lib_Graph     := Lib_G;\n+         Longest_Path  := 0;\n+         Total_Visited := 0;\n+\n+         Visit_Elaboration_Roots;\n+         Write_Statistics;\n+      end Augment_Library_Graph;\n+\n+      ----------------\n+      -- Is_Visited --\n+      ----------------\n+\n+      function Is_Visited\n+        (IGV_Id : Invocation_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (Visited));\n+         pragma Assert (Present (IGV_Id));\n+\n+         return Contains (Visited, IGV_Id);\n+      end Is_Visited;\n+\n+      --------------------\n+      -- Set_Is_Visited --\n+      --------------------\n+\n+      procedure Set_Is_Visited\n+        (IGV_Id : Invocation_Graph_Vertex_Id;\n+         Val    : Boolean := True)\n+      is\n+      begin\n+         pragma Assert (Present (Visited));\n+         pragma Assert (Present (IGV_Id));\n+\n+         if Val then\n+            Insert (Visited, IGV_Id);\n+         else\n+            Delete (Visited, IGV_Id);\n+         end if;\n+      end Set_Is_Visited;\n+\n+      ----------------------------\n+      -- Visit_Elaboration_Root --\n+      ----------------------------\n+\n+      procedure Visit_Elaboration_Root (Root : Invocation_Graph_Vertex_Id) is\n+         pragma Assert (Present (Inv_Graph));\n+         pragma Assert (Present (Root));\n+         pragma Assert (Present (Lib_Graph));\n+\n+         Root_LGV_Id : constant Library_Graph_Vertex_Id :=\n+                         Lib_Vertex (Inv_Graph, Root);\n+\n+         pragma Assert (Present (Root_LGV_Id));\n+\n+      begin\n+         --  Prepare the global data\n+\n+         Visited := Create (Number_Of_Vertices (Inv_Graph));\n+\n+         Visit_Vertex\n+           (Curr_IGV_Id   => Root,\n+            Last_LGV_Id   => Root_LGV_Id,\n+            Root_LGV_Id   => Root_LGV_Id,\n+            Internal_Ctrl => False,\n+            Path          => 0);\n+\n+         Destroy (Visited);\n+      end Visit_Elaboration_Root;\n+\n+      -----------------------------\n+      -- Visit_Elaboration_Roots --\n+      -----------------------------\n+\n+      procedure Visit_Elaboration_Roots is\n+         Iter : Elaboration_Root_Iterator;\n+         Root : Invocation_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (Inv_Graph));\n+\n+         Iter := Iterate_Elaboration_Roots (Inv_Graph);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Root);\n+            pragma Assert (Present (Root));\n+\n+            Visit_Elaboration_Root (Root);\n+         end loop;\n+      end Visit_Elaboration_Roots;\n+\n+      ------------------\n+      -- Visit_Vertex --\n+      ------------------\n+\n+      procedure Visit_Vertex\n+        (Curr_IGV_Id   : Invocation_Graph_Vertex_Id;\n+         Last_LGV_Id   : Library_Graph_Vertex_Id;\n+         Root_LGV_Id   : Library_Graph_Vertex_Id;\n+         Internal_Ctrl : Boolean;\n+         Path          : Natural)\n+      is\n+         New_Path : constant Natural := Path + 1;\n+\n+         Curr_LGV_Id : Library_Graph_Vertex_Id;\n+         IGE_Id      : Invocation_Graph_Edge_Id;\n+         Iter        : Edges_To_Targets_Iterator;\n+         Targ        : Invocation_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (Inv_Graph));\n+         pragma Assert (Present (Curr_IGV_Id));\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (Last_LGV_Id));\n+         pragma Assert (Present (Root_LGV_Id));\n+\n+         --  Nothing to do when the current invocation graph vertex has already\n+         --  been visited.\n+\n+         if Is_Visited (Curr_IGV_Id) then\n+            return;\n+         end if;\n+\n+         Set_Is_Visited (Curr_IGV_Id);\n+\n+         --  Update the statictics\n+\n+         Longest_Path  := Natural'Max (Longest_Path, New_Path);\n+         Total_Visited := Total_Visited + 1;\n+\n+         --  The library graph vertex of the current invocation graph vertex\n+         --  differs from that of the previous invocation graph vertex. This\n+         --  indicates that elaboration is transitioning from one unit to\n+         --  another. Add a library graph edge to capture this dependency.\n+\n+         Curr_LGV_Id := Lib_Vertex (Inv_Graph, Curr_IGV_Id);\n+         pragma Assert (Present (Curr_LGV_Id));\n+\n+         if Curr_LGV_Id /= Last_LGV_Id then\n+\n+            --  The path ultimately reaches back into the unit where the root\n+            --  resides, resulting in a self dependency. In most cases this is\n+            --  a valid circularity, except when the path went through one of\n+            --  the Deep_xxx finalization-related routines. Do not create a\n+            --  library graph edge because the circularity is the result of\n+            --  expansion and thus spurious.\n+\n+            if Curr_LGV_Id = Root_LGV_Id and then Internal_Ctrl then\n+               null;\n+\n+            --  Otherwise create the library graph edge, even if this results\n+            --  in a self dependency.\n+\n+            else\n+               Add_Edge\n+                 (G    => Lib_Graph,\n+                  Pred => Curr_LGV_Id,\n+                  Succ => Root_LGV_Id,\n+                  Kind => Invocation_Edge);\n+            end if;\n+         end if;\n+\n+         --  Extend the DFS traversal to all targets of the invocation graph\n+         --  vertex.\n+\n+         Iter := Iterate_Edges_To_Targets (Inv_Graph, Curr_IGV_Id);\n+         while Has_Next (Iter) loop\n+            Next (Iter, IGE_Id);\n+            pragma Assert (Present (IGE_Id));\n+\n+            Targ := Target (Inv_Graph, IGE_Id);\n+            pragma Assert (Present (Targ));\n+\n+            Visit_Vertex\n+              (Curr_IGV_Id   => Targ,\n+               Last_LGV_Id   => Curr_LGV_Id,\n+               Root_LGV_Id   => Root_LGV_Id,\n+               Internal_Ctrl =>\n+                 Internal_Ctrl\n+                   or else Kind (Inv_Graph, IGE_Id) in\n+                             Internal_Controlled_Invocation_Kind,\n+               Path          => New_Path);\n+         end loop;\n+      end Visit_Vertex;\n+\n+      ----------------------\n+      -- Write_Statistics --\n+      ----------------------\n+\n+      procedure Write_Statistics is\n+      begin\n+         --  Nothing to do when switch -d_L (output library item graph) is no\n+         --  in effect.\n+\n+         if not Debug_Flag_Underscore_LL then\n+            return;\n+         end if;\n+\n+         Write_Str (\"Library Graph Augmentation\");\n+         Write_Eol;\n+         Write_Eol;\n+\n+         Write_Str (\"Vertices visited   : \");\n+         Write_Num (Int (Total_Visited));\n+         Write_Eol;\n+\n+         Write_Str (\"Longest path length: \");\n+         Write_Num (Int (Longest_Path));\n+         Write_Eol;\n+         Write_Eol;\n+\n+         Write_Str (\"Library Graph Augmentation end\");\n+         Write_Eol;\n+         Write_Eol;\n+      end Write_Statistics;\n+   end Library_Graph_Augmentors;\n+\n+end Bindo.Augmentors;"}, {"sha": "0efae6199246b5504761b52b8c2eb9d50a87246a", "filename": "gcc/ada/bindo-augmentors.ads", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-augmentors.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-augmentors.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-augmentors.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,62 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      B I N D O . A U G M E N T O R S                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  For full architecture, see unit Bindo.\n+\n+--  The following unit contains facilities to enhance the library graph which\n+--  reflects source dependencies between units with information obtained from\n+--  the invocation graph which reflects all activations of tasks, calls, and\n+--  instantiations within units.\n+\n+with Bindo.Graphs;\n+use  Bindo.Graphs;\n+use  Bindo.Graphs.Invocation_Graphs;\n+use  Bindo.Graphs.Library_Graphs;\n+\n+package Bindo.Augmentors is\n+\n+   ------------------------------\n+   -- Library_Graph_Augmentors --\n+   ------------------------------\n+\n+   package Library_Graph_Augmentors is\n+      procedure Augment_Library_Graph\n+        (Inv_G : Invocation_Graph;\n+         Lib_G : Library_Graph);\n+      --  Augment library graph Lib_G with information from invocation graph\n+      --  Inv_G as follows:\n+      --\n+      --    1) Traverse the invocation graph starting from each elaboration\n+      --       procedure of unit Root.\n+      --\n+      --    2) Each time the traversal transitions from one unit into another\n+      --       unit Curr, add an invocation edge between predecessor Curr and\n+      --       successor Root in the library graph.\n+      --\n+      --    3) Do the above steps for all units with an elaboration procedure.\n+\n+   end Library_Graph_Augmentors;\n+\n+end Bindo.Augmentors;"}, {"sha": "33adede21d18ef898f7c6492dc447f02c2b91e9e", "filename": "gcc/ada/bindo-builders.adb", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-builders.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-builders.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-builders.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,488 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        B I N D O . B U I L D E R S                       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Bindo.Units; use Bindo.Units;\n+\n+package body Bindo.Builders is\n+\n+   -------------------------------\n+   -- Invocation_Graph_Builders --\n+   -------------------------------\n+\n+   package body Invocation_Graph_Builders is\n+\n+      -----------------\n+      -- Global data --\n+      -----------------\n+\n+      Inv_Graph : Invocation_Graph := Invocation_Graphs.Nil;\n+      Lib_Graph : Library_Graph    := Library_Graphs.Nil;\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Create_Edge (IR_Id : Invocation_Relation_Id);\n+      pragma Inline (Create_Edge);\n+      --  Create a new edge for invocation relation IR_Id in invocation graph\n+      --  Inv_Graph.\n+\n+      procedure Create_Edges (U_Id : Unit_Id);\n+      pragma Inline (Create_Edges);\n+      --  Create new edges for all invocation relations of unit U_Id\n+\n+      procedure Create_Vertex\n+        (IC_Id  : Invocation_Construct_Id;\n+         LGV_Id : Library_Graph_Vertex_Id);\n+      pragma Inline (Create_Vertex);\n+      --  Create a new vertex for invocation construct IC_Id in invocation\n+      --  graph Inv_Graph. The vertex is linked to vertex LGV_Id of library\n+      --  graph Lib_Graph.\n+\n+      procedure Create_Vertices (U_Id : Unit_Id);\n+      pragma Inline (Create_Vertices);\n+      --  Create new vertices for all invocation constructs of unit U_Id in\n+      --  invocation graph Inv_Graph.\n+\n+      ----------------------------\n+      -- Build_Invocation_Graph --\n+      ----------------------------\n+\n+      function Build_Invocation_Graph\n+        (Lib_G : Library_Graph) return Invocation_Graph\n+      is\n+      begin\n+         pragma Assert (Present (Lib_G));\n+\n+         --  Prepare the global data\n+\n+         Inv_Graph :=\n+           Create (Initial_Vertices => Number_Of_Elaborable_Units,\n+                   Initial_Edges    => Number_Of_Elaborable_Units);\n+         Lib_Graph := Lib_G;\n+\n+         For_Each_Elaborable_Unit (Create_Vertices'Access);\n+         For_Each_Elaborable_Unit (Create_Edges'Access);\n+\n+         return Inv_Graph;\n+      end Build_Invocation_Graph;\n+\n+      -----------------\n+      -- Create_Edge --\n+      -----------------\n+\n+      procedure Create_Edge (IR_Id : Invocation_Relation_Id) is\n+         pragma Assert (Present (Inv_Graph));\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (IR_Id));\n+\n+         IR_Rec : Invocation_Relation_Record renames\n+                    Invocation_Relations.Table (IR_Id);\n+\n+         pragma Assert (Present (IR_Rec.Invoker));\n+         pragma Assert (Present (IR_Rec.Target));\n+\n+         Invoker : Invocation_Graph_Vertex_Id;\n+         Target  : Invocation_Graph_Vertex_Id;\n+\n+      begin\n+         --  Nothing to do when the target denotes an invocation construct that\n+         --  resides in a unit which will never be elaborated.\n+\n+         if not Needs_Elaboration (IR_Rec.Target) then\n+            return;\n+         end if;\n+\n+         Invoker := Corresponding_Vertex (Inv_Graph, IR_Rec.Invoker);\n+         Target  := Corresponding_Vertex (Inv_Graph, IR_Rec.Target);\n+\n+         pragma Assert (Present (Invoker));\n+         pragma Assert (Present (Target));\n+\n+         Add_Edge\n+           (G      => Inv_Graph,\n+            Source => Invoker,\n+            Target => Target,\n+            IR_Id  => IR_Id);\n+      end Create_Edge;\n+\n+      ------------------\n+      -- Create_Edges --\n+      ------------------\n+\n+      procedure Create_Edges (U_Id : Unit_Id) is\n+         pragma Assert (Present (Inv_Graph));\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         for IR_Id in U_Rec.First_Invocation_Relation ..\n+                      U_Rec.Last_Invocation_Relation\n+         loop\n+            Create_Edge (IR_Id);\n+         end loop;\n+      end Create_Edges;\n+\n+      -------------------\n+      -- Create_Vertex --\n+      -------------------\n+\n+      procedure Create_Vertex\n+        (IC_Id  : Invocation_Construct_Id;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+      is\n+         pragma Assert (Present (Inv_Graph));\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (IC_Id));\n+         pragma Assert (Present (LGV_Id));\n+\n+         IC_Rec : Invocation_Construct_Record renames\n+                    Invocation_Constructs.Table (IC_Id);\n+\n+         Body_LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         --  Determine the proper library graph vertex which holds the body of\n+         --  the invocation construct.\n+\n+         if IC_Rec.Placement = In_Body then\n+            Body_LGV_Id := Proper_Body (Lib_Graph, LGV_Id);\n+         else\n+            pragma Assert (IC_Rec.Placement = In_Spec);\n+            Body_LGV_Id := Proper_Spec (Lib_Graph, LGV_Id);\n+         end if;\n+\n+         pragma Assert (Present (Body_LGV_Id));\n+\n+         Add_Vertex\n+           (G      => Inv_Graph,\n+            IC_Id  => IC_Id,\n+            LGV_Id => Body_LGV_Id);\n+      end Create_Vertex;\n+\n+      ---------------------\n+      -- Create_Vertices --\n+      ---------------------\n+\n+      procedure Create_Vertices (U_Id : Unit_Id) is\n+         pragma Assert (Present (Inv_Graph));\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec  : Unit_Record renames ALI.Units.Table (U_Id);\n+         LGV_Id : constant Library_Graph_Vertex_Id :=\n+                    Corresponding_Vertex (Lib_Graph, U_Id);\n+\n+         pragma Assert (Present (LGV_Id));\n+\n+      begin\n+         for IC_Id in U_Rec.First_Invocation_Construct ..\n+                      U_Rec.Last_Invocation_Construct\n+         loop\n+            Create_Vertex (IC_Id, LGV_Id);\n+         end loop;\n+      end Create_Vertices;\n+   end Invocation_Graph_Builders;\n+\n+   ----------------------------\n+   -- Library_Graph_Builders --\n+   ----------------------------\n+\n+   package body Library_Graph_Builders is\n+\n+      -----------------\n+      -- Global data --\n+      -----------------\n+\n+      Lib_Graph : Library_Graph := Library_Graphs.Nil;\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Create_Spec_And_Body_Edge (U_Id : Unit_Id);\n+      pragma Inline (Create_Spec_And_Body_Edge);\n+      --  Establish a link between the spec and body of unit U_Id. In certain\n+      --  cases this may result in a new edge which is added to library graph\n+      --  Lib_Graph.\n+\n+      procedure Create_Vertex (U_Id : Unit_Id);\n+      pragma Inline (Create_Vertex);\n+      --  Create a new vertex for unit U_Id in library graph Lib_Graph\n+\n+      procedure Create_With_Edge\n+        (W_Id : With_Id;\n+         Succ : Library_Graph_Vertex_Id);\n+      pragma Inline (Create_With_Edge);\n+      --  Create a new edge for with W_Id where the predecessor is the library\n+      --  graph vertex of the withed unit, and the successor is Succ. The edge\n+      --  is added to library graph Lib_Graph.\n+\n+      procedure Create_With_Edges (U_Id : Unit_Id);\n+      pragma Inline (Create_With_Edges);\n+      --  Establish links between unit U_Id and its predecessor units. The new\n+      --  edges are added to library graph Lib_Graph.\n+\n+      procedure Create_With_Edges\n+        (U_Id : Unit_Id;\n+         Succ : Library_Graph_Vertex_Id);\n+      pragma Inline (Create_With_Edges);\n+      --  Create new edges for all withs of unit U_Id where the predecessor is\n+      --  some withed unit, and the successor is Succ. The edges are added to\n+      --  library graph Lib_Graph.\n+\n+      function Is_Significant_With (W_Id : With_Id) return Boolean;\n+      pragma Inline (Is_Significant_With);\n+      --  Determine whether with W_Id plays a significant role in elaboration\n+\n+      -------------------------\n+      -- Build_Library_Graph --\n+      -------------------------\n+\n+      function Build_Library_Graph return Library_Graph is\n+      begin\n+         --  Prepare the global data\n+\n+         Lib_Graph :=\n+           Create (Initial_Vertices => Number_Of_Elaborable_Units,\n+                   Initial_Edges    => Number_Of_Elaborable_Units);\n+\n+         For_Each_Elaborable_Unit (Create_Vertex'Access);\n+         For_Each_Elaborable_Unit (Create_Spec_And_Body_Edge'Access);\n+         For_Each_Elaborable_Unit (Create_With_Edges'Access);\n+\n+         return Lib_Graph;\n+      end Build_Library_Graph;\n+\n+      -------------------------------\n+      -- Create_Spec_And_Body_Edge --\n+      -------------------------------\n+\n+      procedure Create_Spec_And_Body_Edge (U_Id : Unit_Id) is\n+         Aux_LGV_Id : Library_Graph_Vertex_Id;\n+         LGV_Id     : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (U_Id));\n+\n+         LGV_Id := Corresponding_Vertex (Lib_Graph, U_Id);\n+         pragma Assert (Present (LGV_Id));\n+\n+         --  The unit denotes a body that completes a previous spec. Link the\n+         --  spec and body. Add an edge between the predecessor spec and the\n+         --  successor body.\n+\n+         if Is_Body_With_Spec (Lib_Graph, LGV_Id) then\n+            Aux_LGV_Id :=\n+              Corresponding_Vertex (Lib_Graph, Corresponding_Spec (U_Id));\n+            pragma Assert (Present (Aux_LGV_Id));\n+\n+            Set_Corresponding_Item (Lib_Graph, LGV_Id, Aux_LGV_Id);\n+\n+            Add_Edge\n+              (G    => Lib_Graph,\n+               Pred => Aux_LGV_Id,\n+               Succ => LGV_Id,\n+               Kind => Spec_Before_Body_Edge);\n+\n+         --  The unit denotes a spec with a completing body. Link the spec and\n+         --  body.\n+\n+         elsif Is_Spec_With_Body (Lib_Graph, LGV_Id) then\n+            Aux_LGV_Id :=\n+              Corresponding_Vertex (Lib_Graph, Corresponding_Body (U_Id));\n+            pragma Assert (Present (Aux_LGV_Id));\n+\n+            Set_Corresponding_Item (Lib_Graph, LGV_Id, Aux_LGV_Id);\n+         end if;\n+      end Create_Spec_And_Body_Edge;\n+\n+      -------------------\n+      -- Create_Vertex --\n+      -------------------\n+\n+      procedure Create_Vertex (U_Id : Unit_Id) is\n+      begin\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (U_Id));\n+\n+         Add_Vertex\n+           (G    => Lib_Graph,\n+            U_Id => U_Id);\n+      end Create_Vertex;\n+\n+      ----------------------\n+      -- Create_With_Edge --\n+      ----------------------\n+\n+      procedure Create_With_Edge\n+        (W_Id : With_Id;\n+         Succ : Library_Graph_Vertex_Id)\n+      is\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (W_Id));\n+         pragma Assert (Present (Succ));\n+\n+         Withed_Rec  : With_Record renames Withs.Table (W_Id);\n+         Withed_U_Id : constant Unit_Id :=\n+                         Corresponding_Unit (Withed_Rec.Uname);\n+\n+         pragma Assert (Present (Withed_U_Id));\n+\n+         Aux_LGV_Id    : Library_Graph_Vertex_Id;\n+         Kind          : Library_Graph_Edge_Kind;\n+         Withed_LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         --  Nothing to do when the withed unit does not need to be elaborated.\n+         --  This prevents spurious dependencies that can never be satisfied.\n+\n+         if not Needs_Elaboration (Withed_U_Id) then\n+            return;\n+         end if;\n+\n+         Withed_LGV_Id := Corresponding_Vertex (Lib_Graph, Withed_U_Id);\n+         pragma Assert (Present (Withed_LGV_Id));\n+\n+         --  The with comes with pragma Elaborate\n+\n+         if Withed_Rec.Elaborate then\n+            Kind := Elaborate_Edge;\n+\n+            --  The withed unit is a spec with a completing body. Add an edge\n+            --  between the body of the withed predecessor and the withing\n+            --  successor.\n+\n+            if Is_Spec_With_Body (Lib_Graph, Withed_LGV_Id) then\n+               Aux_LGV_Id :=\n+                 Corresponding_Vertex\n+                   (Lib_Graph, Corresponding_Body (Withed_U_Id));\n+               pragma Assert (Present (Aux_LGV_Id));\n+\n+               Add_Edge\n+                 (G    => Lib_Graph,\n+                  Pred => Aux_LGV_Id,\n+                  Succ => Succ,\n+                  Kind => Kind);\n+            end if;\n+\n+         --  The with comes with pragma Elaborate_All\n+\n+         elsif Withed_Rec.Elaborate_All then\n+            Kind := Elaborate_All_Edge;\n+\n+         --  Otherwise this is a regular with\n+\n+         else\n+            Kind := With_Edge;\n+         end if;\n+\n+         --  Add an edge between the withed predecessor unit and the withing\n+         --  successor.\n+\n+         Add_Edge\n+           (G    => Lib_Graph,\n+            Pred => Withed_LGV_Id,\n+            Succ => Succ,\n+            Kind => Kind);\n+      end Create_With_Edge;\n+\n+      -----------------------\n+      -- Create_With_Edges --\n+      -----------------------\n+\n+      procedure Create_With_Edges (U_Id : Unit_Id) is\n+         LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (U_Id));\n+\n+         LGV_Id := Corresponding_Vertex (Lib_Graph, U_Id);\n+         pragma Assert (Present (LGV_Id));\n+\n+         Create_With_Edges\n+           (U_Id => U_Id,\n+            Succ => LGV_Id);\n+      end Create_With_Edges;\n+\n+      -----------------------\n+      -- Create_With_Edges --\n+      -----------------------\n+\n+      procedure Create_With_Edges\n+        (U_Id : Unit_Id;\n+         Succ : Library_Graph_Vertex_Id)\n+      is\n+         pragma Assert (Present (Lib_Graph));\n+         pragma Assert (Present (U_Id));\n+         pragma Assert (Present (Succ));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         for W_Id in U_Rec.First_With .. U_Rec.Last_With loop\n+            if Is_Significant_With (W_Id) then\n+               Create_With_Edge (W_Id, Succ);\n+            end if;\n+         end loop;\n+      end Create_With_Edges;\n+\n+      -------------------------\n+      -- Is_Significant_With --\n+      -------------------------\n+\n+      function Is_Significant_With (W_Id : With_Id) return Boolean is\n+         pragma Assert (Present (W_Id));\n+\n+         Withed_Rec  : With_Record renames Withs.Table (W_Id);\n+         Withed_U_Id : constant Unit_Id :=\n+                         Corresponding_Unit (Withed_Rec.Uname);\n+\n+      begin\n+         --  Nothing to do for a unit which does not exist any more\n+\n+         if not Present (Withed_U_Id) then\n+            return False;\n+\n+         --  Nothing to do for a limited with\n+\n+         elsif Withed_Rec.Limited_With then\n+            return False;\n+\n+         --  Nothing to do when the unit does not need to be elaborated\n+\n+         elsif not Needs_Elaboration (Withed_U_Id) then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Is_Significant_With;\n+   end Library_Graph_Builders;\n+\n+end Bindo.Builders;"}, {"sha": "39cde4ff34874f46f5aac7972d8e1c812a9fdda1", "filename": "gcc/ada/bindo-builders.ads", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-builders.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-builders.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-builders.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,65 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        B I N D O . B U I L D E R S                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  For full architecture, see unit Bindo.\n+\n+--  The following unit contains facilities to create various graphs that\n+--  reflect dependencies between units, as well as activations of tasks,\n+--  calls, and instantiations within them.\n+\n+with Bindo.Graphs;\n+use  Bindo.Graphs;\n+use  Bindo.Graphs.Invocation_Graphs;\n+use  Bindo.Graphs.Library_Graphs;\n+\n+package Bindo.Builders is\n+\n+   -------------------------------\n+   -- Invocation_Graph_Builders --\n+   -------------------------------\n+\n+   package Invocation_Graph_Builders is\n+      function Build_Invocation_Graph\n+        (Lib_G : Library_Graph) return Invocation_Graph;\n+      --  Return a new invocation graph which reflects the activations of\n+      --  tasks, calls, and instantiations in all units of the bind. Each\n+      --  invocation graph vertex is linked with the corresponding vertex\n+      --  of library graph Lib_G which contains the body of the activated\n+      --  task, invoked subprogram, or instantiated generic.\n+\n+   end Invocation_Graph_Builders;\n+\n+   ----------------------------\n+   -- Library_Graph_Builders --\n+   ----------------------------\n+\n+   package Library_Graph_Builders is\n+      function Build_Library_Graph return Library_Graph;\n+      --  Return a new library graph which reflects the dependencies between\n+      --  all units of the bind.\n+\n+   end Library_Graph_Builders;\n+\n+end Bindo.Builders;"}, {"sha": "bf11d39a942d3de568bceb9a48e7adf8624cd179", "filename": "gcc/ada/bindo-diagnostics.adb", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-diagnostics.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-diagnostics.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-diagnostics.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,72 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     B I N D O . D I A G N O S T I C S                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Bindo.Diagnostics is\n+\n+   -----------------------\n+   -- Cycle_Diagnostics --\n+   -----------------------\n+\n+   package body Cycle_Diagnostics is\n+\n+      -----------------------------\n+      -- Has_Elaborate_All_Cycle --\n+      -----------------------------\n+\n+      function Has_Elaborate_All_Cycle (G : Library_Graph) return Boolean is\n+         Has_Cycle : Boolean;\n+         Iter      : All_Edge_Iterator;\n+         LGE_Id    : Library_Graph_Edge_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Assume that the graph lacks a cycle\n+\n+         Has_Cycle := False;\n+\n+         --  The library graph has an Elaborate_All cycle when one of its edges\n+         --  represents a with clause for a unit with pragma Elaborate_All, and\n+         --  both the predecessor and successor reside in the same component.\n+         --  Note that the iteration must run to completion in order to unlock\n+         --  the graph.\n+\n+         Iter := Iterate_All_Edges (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGE_Id);\n+            pragma Assert (Present (LGE_Id));\n+\n+            if Kind (G, LGE_Id) = Elaborate_All_Edge\n+              and then Links_Vertices_In_Same_Component (G, LGE_Id)\n+            then\n+               Has_Cycle := True;\n+            end if;\n+         end loop;\n+\n+         return Has_Cycle;\n+      end Has_Elaborate_All_Cycle;\n+   end Cycle_Diagnostics;\n+\n+end Bindo.Diagnostics;"}, {"sha": "3b1d01cba46fe07c6b82448aca5277b2aa0e99ea", "filename": "gcc/ada/bindo-diagnostics.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-diagnostics.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-diagnostics.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-diagnostics.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     B I N D O . D I A G N O S T I C S                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  For full architecture, see unit Bindo.\n+\n+--  The following unit contains facilities to diagnose various issues with the\n+--  elaboration order.\n+\n+with Bindo.Graphs;\n+use  Bindo.Graphs;\n+use  Bindo.Graphs.Library_Graphs;\n+\n+package Bindo.Diagnostics is\n+\n+   -----------\n+   -- Types --\n+   -----------\n+\n+   --  The following type enumerates all possible statuses of the elaboration\n+   --  order.\n+\n+   type Elaboration_Order_Status is\n+     (Order_Has_Circularity,\n+      Order_Has_Elaborate_All_Circularity,\n+      Order_OK);\n+\n+   -----------------------\n+   -- Cycle_Diagnostics --\n+   -----------------------\n+\n+   package Cycle_Diagnostics is\n+      function Has_Elaborate_All_Cycle (G : Library_Graph) return Boolean;\n+      pragma Inline (Has_Elaborate_All_Cycle);\n+      --  Determine whether library graph G contains a cycle where pragma\n+      --  Elaborate_All appears within a component.\n+\n+   end Cycle_Diagnostics;\n+\n+end Bindo.Diagnostics;"}, {"sha": "42b5b6d7ad86205663f0f0919275384a0d824c81", "filename": "gcc/ada/bindo-elaborators.adb", "status": "added", "additions": 1418, "deletions": 0, "changes": 1418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-elaborators.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-elaborators.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-elaborators.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,1418 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     B I N D O . E L A B O R A T O R S                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Binderr; use Binderr;\n+with Butil;   use Butil;\n+with Debug;   use Debug;\n+with Output;  use Output;\n+with Types;   use Types;\n+\n+with Bindo.Augmentors;\n+use  Bindo.Augmentors;\n+use  Bindo.Augmentors.Library_Graph_Augmentors;\n+\n+with Bindo.Builders;\n+use  Bindo.Builders;\n+use  Bindo.Builders.Invocation_Graph_Builders;\n+use  Bindo.Builders.Library_Graph_Builders;\n+\n+with Bindo.Diagnostics;\n+use  Bindo.Diagnostics;\n+use  Bindo.Diagnostics.Cycle_Diagnostics;\n+\n+with Bindo.Units;\n+use  Bindo.Units;\n+\n+with Bindo.Validators;\n+use  Bindo.Validators;\n+use  Bindo.Validators.Elaboration_Order_Validators;\n+use  Bindo.Validators.Invocation_Graph_Validators;\n+use  Bindo.Validators.Library_Graph_Validators;\n+\n+with Bindo.Writers;\n+use  Bindo.Writers;\n+use  Bindo.Writers.ALI_Writers;\n+use  Bindo.Writers.Elaboration_Order_Writers;\n+use  Bindo.Writers.Invocation_Graph_Writers;\n+use  Bindo.Writers.Library_Graph_Writers;\n+use  Bindo.Writers.Unit_Closure_Writers;\n+\n+with GNAT;        use GNAT;\n+with GNAT.Graphs; use GNAT.Graphs;\n+with GNAT.Sets;   use GNAT.Sets;\n+\n+package body Bindo.Elaborators is\n+\n+   --  The following type defines the advancement of the elaboration order\n+   --  algorithm in terms of steps.\n+\n+   type Elaboration_Order_Step is new Natural;\n+\n+   Initial_Step : constant Elaboration_Order_Step :=\n+                    Elaboration_Order_Step'First;\n+\n+   ----------------------------------------------\n+   -- Invocation_And_Library_Graph_Elaborators --\n+   ----------------------------------------------\n+\n+   package body Invocation_And_Library_Graph_Elaborators is\n+      Add_To_All_Candidates_Msg  : aliased String :=\n+                                     \"add vertex to all candidates\";\n+      Add_To_Comp_Candidates_Msg : aliased String :=\n+                                     \"add vertex to component candidates\";\n+\n+      -----------\n+      -- Types --\n+      -----------\n+\n+      type String_Ptr is access all String;\n+\n+      -----------------\n+      -- Visited set --\n+      -----------------\n+\n+      package VS is new Membership_Sets\n+        (Element_Type => Library_Graph_Vertex_Id,\n+         \"=\"          => \"=\",\n+         Hash         => Hash_Library_Graph_Vertex);\n+      use VS;\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Add_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Set    : Membership_Set;\n+         Msg    : String;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level);\n+      pragma Inline (Add_Vertex);\n+      --  Add vertex LGV_Id of library graph G to membership set Set. Msg is\n+      --  a message emitted for traching purposes. Step is the current step\n+      --  in the elaboration order. Indent is the desired indentation level\n+      --  for tracing.\n+\n+      procedure Add_Vertex_If_Elaborable\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Set    : Membership_Set;\n+         Msg    : String;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level);\n+      pragma Inline (Add_Vertex_If_Elaborable);\n+      --  Add vertex LGV_Id of library graph G to membership set Set if it can\n+      --  be elaborated. Msg is a message emitted for traching purposes. Step\n+      --  is the current step in the elaboration order. Indent is the desired\n+      --  indentation level for tracing.\n+\n+      function Create_All_Candidates_Set\n+        (G    : Library_Graph;\n+         Step : Elaboration_Order_Step) return Membership_Set;\n+      pragma Inline (Create_All_Candidates_Set);\n+      --  Collect all elaborable candidate vertices of library graph G in a\n+      --  set. Step is the current step in the elaboration order.\n+\n+      function Create_Component_Candidates_Set\n+        (G    : Library_Graph;\n+         Comp : Component_Id;\n+         Step : Elaboration_Order_Step) return Membership_Set;\n+      pragma Inline (Create_Component_Candidates_Set);\n+      --  Collect all elaborable candidate vertices that appear in component\n+      --  Comp of library graph G in a set. Step is the current step in the\n+      --  elaboration order.\n+\n+      procedure Elaborate_Component\n+        (G                  : Library_Graph;\n+         Comp               : Component_Id;\n+         All_Candidates     : Membership_Set;\n+         Remaining_Vertices : in out Natural;\n+         Order              : in out Unit_Id_Table;\n+         Step               : Elaboration_Order_Step);\n+      pragma Inline (Elaborate_Component);\n+      --  Elaborate as many vertices as possible which appear in component\n+      --  Comp of library graph G. All_Candidates is the set of all elaborable\n+      --  vertices across the whole library graph. Remaining_Vertices is the\n+      --  number of vertices that remain to be elaborated. Order denotes the\n+      --  elaboration order. Step is the current step in the elaboration order.\n+\n+      procedure Elaborate_Library_Graph\n+        (G      : Library_Graph;\n+         Order  : out Unit_Id_Table;\n+         Status : out Elaboration_Order_Status);\n+      pragma Inline (Elaborate_Library_Graph);\n+      --  Elaborate as many vertices as possible of library graph G. Order is\n+      --  the elaboration order. Status is the condition of the elaboration\n+      --  order.\n+\n+      procedure Elaborate_Units_Common\n+        (Use_Inv_Graph : Boolean;\n+         Inv_Graph     : out Invocation_Graph;\n+         Lib_Graph     : out Library_Graph;\n+         Order         : out Unit_Id_Table;\n+         Status        : out Elaboration_Order_Status);\n+      pragma Inline (Elaborate_Units_Common);\n+      --  Find the elaboration order of all units in the bind. Use_Inv_Graph\n+      --  should be set when library graph Lib_Graph is to be augmented with\n+      --  information from invocation graph Inv_Graph. Order is the elaboration\n+      --  order. Status is the condition of the elaboration order.\n+\n+      procedure Elaborate_Units_Dynamic (Order : out Unit_Id_Table);\n+      pragma Inline (Elaborate_Units_Dynamic);\n+      --  Find the elaboration order of all units in the bind using the dynamic\n+      --  model. Order is the elaboration order. In the event where no ordering\n+      --  is possible, this routine diagnoses the issue(s) and raises exception\n+      --  Unrecoverable_Error.\n+\n+      procedure Elaborate_Units_Static (Order : out Unit_Id_Table);\n+      pragma Inline (Elaborate_Units_Static);\n+      --  Find the elaboration order of all units in the bind using the static\n+      --  model. Order is the elaboration order. In the event where no ordering\n+      --  is possible, this routine diagnoses the issue(s) and raises exception\n+      --  Unrecoverable_Error.\n+\n+      procedure Elaborate_Vertex\n+        (G                  : Library_Graph;\n+         LGV_Id             : Library_Graph_Vertex_Id;\n+         All_Candidates     : Membership_Set;\n+         Comp_Candidates    : Membership_Set;\n+         Remaining_Vertices : in out Natural;\n+         Order              : in out Unit_Id_Table;\n+         Step               : Elaboration_Order_Step;\n+         Indent             : Indentation_Level);\n+      pragma Inline (Elaborate_Vertex);\n+      --  Elaborate vertex LGV_Id of library graph G by adding its unit to\n+      --  elaboration order Order. The routine updates awaiting successors\n+      --  where applicable. All_Candidates denotes the set of all elaborable\n+      --  vertices across the whole library graph. Comp_Candidates is the set\n+      --  of all elaborable vertices in the component of LGV_Id. Parameter\n+      --  Remaining_Vertices denotes the number of vertices that remain to\n+      --  be elaborated. Step is the current step in the elaboration order.\n+      --  Indent is the desired indentation level for tracing.\n+\n+      function Find_Best_Candidate\n+        (G      : Library_Graph;\n+         Set    : Membership_Set;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level) return Library_Graph_Vertex_Id;\n+      pragma Inline (Find_Best_Candidate);\n+      --  Find the most suitable vertex of library graph G for elaboration from\n+      --  membership set Set. Step denotes the current step in the elaboration\n+      --  order. Indent is the desired indentation level for tracing.\n+\n+      function Is_Better_Candidate\n+        (G           : Library_Graph;\n+         Best_Candid : Library_Graph_Vertex_Id;\n+         New_Candid  : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Better_Candidate);\n+      --  Determine whether new candidate vertex New_Candid of library graph\n+      --  G is a more suitable choice for elaboration compared to the current\n+      --  best candidate Best_Candid.\n+\n+      procedure Trace_Candidate_Vertices\n+        (G    : Library_Graph;\n+         Set  : Membership_Set;\n+         Step : Elaboration_Order_Step);\n+      pragma Inline (Trace_Candidate_Vertices);\n+      --  Write the candidate vertices of library graph G present in membership\n+      --  set Set to standard output. Formal Step denotes the current step in\n+      --  the elaboration order.\n+\n+      procedure Trace_Component\n+        (G    : Library_Graph;\n+         Comp : Component_Id;\n+         Msg  : String;\n+         Step : Elaboration_Order_Step);\n+      pragma Inline (Trace_Component);\n+      --  Write elaboration-related information for component Comp of library\n+      --  graph G to standard output, starting with message Msg. Step is the\n+      --  current step in the elaboration order.\n+\n+      procedure Trace_Step (Step : Elaboration_Order_Step);\n+      pragma Inline (Trace_Step);\n+      --  Write current step Step of the elaboration order to standard output\n+\n+      procedure Trace_Unelaborated_Vertices\n+        (G     : Library_Graph;\n+         Count : Natural;\n+         Step  : Elaboration_Order_Step);\n+      pragma Inline (Trace_Unelaborated_Vertices);\n+      --  Write the remaining unelaborated vertices of library graph G to\n+      --  standard output. Count is the number of vertices that remain to\n+      --  be elaborated. Step is the current step in the elaboration order.\n+\n+      procedure Trace_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Msg    : String;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level);\n+      pragma Inline (Trace_Vertex);\n+      --  Write elaboration-related information for vertex LGV_Id of library\n+      --  graph G to standard output, starting with message Msg. Step is the\n+      --  current step in the elaboration order. Indent denotes the desired\n+      --  indentation level for tracing.\n+\n+      procedure Update_Successor\n+        (G               : Library_Graph;\n+         Pred            : Library_Graph_Vertex_Id;\n+         Succ            : Library_Graph_Vertex_Id;\n+         All_Candidates  : Membership_Set;\n+         Comp_Candidates : Membership_Set;\n+         Step            : Elaboration_Order_Step;\n+         Indent          : Indentation_Level);\n+      pragma Inline (Update_Successor);\n+      --  Notify successor vertex Succ of library graph G along with its\n+      --  component that their predecessor Pred has just been elaborated.\n+      --  This may cause new vertices to become elaborable, and thus be added\n+      --  to one of the two sets. All_Candidates is the set of all elaborable\n+      --  vertices across the whole library graph. Comp_Candidates is the set\n+      --  of all elaborable vertices in the component of Pred. Step is the\n+      --  current step in the elaboration order. Indent denotes the desired\n+      --  indentation level for tracing.\n+\n+      procedure Update_Successors\n+        (G               : Library_Graph;\n+         Pred            : Library_Graph_Vertex_Id;\n+         All_Candidates  : Membership_Set;\n+         Comp_Candidates : Membership_Set;\n+         Step            : Elaboration_Order_Step;\n+         Indent          : Indentation_Level);\n+      pragma Inline (Update_Successors);\n+      --  Notify all successors along with their components that their\n+      --  predecessor vertex Pred of ligrary graph G has just been elaborated.\n+      --  This may cause new vertices to become elaborable, and thus be added\n+      --  to one of the two sets. All_Candidates is the set of all elaborable\n+      --  vertices across the whole library graph. Comp_Candidates is the set\n+      --  of all elaborable vertices in the component of Pred. Step is the\n+      --  current step in the elaboration order. Indent denotes the desired\n+      --  indentation level for tracing.\n+\n+      ----------------\n+      -- Add_Vertex --\n+      ----------------\n+\n+      procedure Add_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Set    : Membership_Set;\n+         Msg    : String;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level)\n+      is\n+      begin\n+         pragma Assert (Present (LGV_Id));\n+         pragma Assert (Needs_Elaboration (G, LGV_Id));\n+         pragma Assert (Present (Set));\n+\n+         --  Add vertex only when it is not present in the set. This is not\n+         --  strictly necessary because the set implementation handles this\n+         --  case, however the check eliminates spurious traces.\n+\n+         if not Contains (Set, LGV_Id) then\n+            Trace_Vertex\n+              (G      => G,\n+               LGV_Id => LGV_Id,\n+               Msg    => Msg,\n+               Step   => Step,\n+               Indent => Indent);\n+\n+            Insert (Set, LGV_Id);\n+         end if;\n+      end Add_Vertex;\n+\n+      ------------------------------\n+      -- Add_Vertex_If_Elaborable --\n+      ------------------------------\n+\n+      procedure Add_Vertex_If_Elaborable\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Set    : Membership_Set;\n+         Msg    : String;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level)\n+      is\n+         Aux_LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+         pragma Assert (Needs_Elaboration (G, LGV_Id));\n+         pragma Assert (Present (Set));\n+\n+         if Is_Elaborable_Vertex (G, LGV_Id) then\n+            Add_Vertex\n+              (G      => G,\n+               LGV_Id => LGV_Id,\n+               Set    => Set,\n+               Msg    => Msg,\n+               Step   => Step,\n+               Indent => Indent);\n+\n+            --  Assume that there is no extra vertex that needs to be added\n+\n+            Aux_LGV_Id := No_Library_Graph_Vertex;\n+\n+            --  A spec-body pair where the spec carries pragma Elaborate_Body\n+            --  must be treated as one vertex for elaboration purposes. If one\n+            --  of them is elaborable, then the other is also elaborable. This\n+            --  property is guaranteed by predicate Is_Elaborable_Vertex.\n+\n+            if Is_Body_Of_Spec_With_Elaborate_Body (G, LGV_Id) then\n+               Aux_LGV_Id := Proper_Spec (G, LGV_Id);\n+               pragma Assert (Present (Aux_LGV_Id));\n+\n+            elsif Is_Spec_With_Elaborate_Body (G, LGV_Id) then\n+               Aux_LGV_Id := Proper_Body (G, LGV_Id);\n+               pragma Assert (Present (Aux_LGV_Id));\n+            end if;\n+\n+            if Present (Aux_LGV_Id) then\n+               pragma Assert (Needs_Elaboration (G, Aux_LGV_Id));\n+\n+               Add_Vertex\n+                 (G      => G,\n+                  LGV_Id => Aux_LGV_Id,\n+                  Set    => Set,\n+                  Msg    => Msg,\n+                  Step   => Step,\n+                  Indent => Indent);\n+            end if;\n+         end if;\n+      end Add_Vertex_If_Elaborable;\n+\n+      -------------------------------\n+      -- Create_All_Candidates_Set --\n+      -------------------------------\n+\n+      function Create_All_Candidates_Set\n+        (G    : Library_Graph;\n+         Step : Elaboration_Order_Step) return Membership_Set\n+      is\n+         Iter   : Library_Graphs.All_Vertex_Iterator;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Set    : Membership_Set;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Set  := Create (Number_Of_Vertices (G));\n+         Iter := Iterate_All_Vertices (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGV_Id);\n+            pragma Assert (Present (LGV_Id));\n+\n+            Add_Vertex_If_Elaborable\n+              (G      => G,\n+               LGV_Id => LGV_Id,\n+               Set    => Set,\n+               Msg    => Add_To_All_Candidates_Msg,\n+               Step   => Step,\n+               Indent => No_Indentation);\n+         end loop;\n+\n+         return Set;\n+      end Create_All_Candidates_Set;\n+\n+      -------------------------------------\n+      -- Create_Component_Candidates_Set --\n+      -------------------------------------\n+\n+      function Create_Component_Candidates_Set\n+        (G    : Library_Graph;\n+         Comp : Component_Id;\n+         Step : Elaboration_Order_Step) return Membership_Set\n+      is\n+         Iter   : Component_Vertex_Iterator;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Set    : Membership_Set;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         Set  := Create (Number_Of_Component_Vertices (G, Comp));\n+         Iter := Iterate_Component_Vertices (G, Comp);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGV_Id);\n+            pragma Assert (Present (LGV_Id));\n+\n+            Add_Vertex_If_Elaborable\n+              (G      => G,\n+               LGV_Id => LGV_Id,\n+               Set    => Set,\n+               Msg    => Add_To_Comp_Candidates_Msg,\n+               Step   => Step,\n+               Indent => No_Indentation);\n+         end loop;\n+\n+         return Set;\n+      end Create_Component_Candidates_Set;\n+\n+      -------------------------\n+      -- Elaborate_Component --\n+      -------------------------\n+\n+      procedure Elaborate_Component\n+        (G                  : Library_Graph;\n+         Comp               : Component_Id;\n+         All_Candidates     : Membership_Set;\n+         Remaining_Vertices : in out Natural;\n+         Order              : in out Unit_Id_Table;\n+         Step               : Elaboration_Order_Step)\n+      is\n+         Candidate       : Library_Graph_Vertex_Id;\n+         Comp_Candidates : Membership_Set;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+         pragma Assert (Present (All_Candidates));\n+\n+         Trace_Component\n+           (G    => G,\n+            Comp => Comp,\n+            Msg  => \"elaborating component\",\n+            Step => Step);\n+\n+         Comp_Candidates := Create_Component_Candidates_Set (G, Comp, Step);\n+\n+         loop\n+            Candidate :=\n+              Find_Best_Candidate\n+                (G      => G,\n+                 Set    => Comp_Candidates,\n+                 Step   => Step,\n+                 Indent => Nested_Indentation);\n+\n+            --  Stop the elaboration of the component when there is no suitable\n+            --  candidate. This indicates that either all vertices within the\n+            --  component have been elaborated, or the library graph contains a\n+            --  circularity.\n+\n+            exit when not Present (Candidate);\n+\n+            Elaborate_Vertex\n+              (G                  => G,\n+               LGV_Id             => Candidate,\n+               All_Candidates     => All_Candidates,\n+               Comp_Candidates    => Comp_Candidates,\n+               Remaining_Vertices => Remaining_Vertices,\n+               Order              => Order,\n+               Step               => Step,\n+               Indent             => Nested_Indentation);\n+         end loop;\n+\n+         Destroy (Comp_Candidates);\n+      end Elaborate_Component;\n+\n+      -----------------------------\n+      -- Elaborate_Library_Graph --\n+      -----------------------------\n+\n+      procedure Elaborate_Library_Graph\n+        (G      : Library_Graph;\n+         Order  : out Unit_Id_Table;\n+         Status : out Elaboration_Order_Status)\n+      is\n+         All_Candidates     : Membership_Set;\n+         Candidate          : Library_Graph_Vertex_Id;\n+         Comp               : Component_Id;\n+         Remaining_Vertices : Natural;\n+         Step               : Elaboration_Order_Step;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Step := Initial_Step;\n+\n+         All_Candidates     := Create_All_Candidates_Set (G, Step);\n+         Remaining_Vertices := Number_Of_Vertices (G);\n+\n+         loop\n+            Step := Step + 1;\n+\n+            Trace_Candidate_Vertices\n+              (G    => G,\n+               Set  => All_Candidates,\n+               Step => Step);\n+\n+            Trace_Unelaborated_Vertices\n+              (G     => G,\n+               Count => Remaining_Vertices,\n+               Step  => Step);\n+\n+            Candidate :=\n+              Find_Best_Candidate\n+                (G      => G,\n+                 Set    => All_Candidates,\n+                 Step   => Step,\n+                 Indent => No_Indentation);\n+\n+            --  Stop the elaboration when there is no suitable candidate. This\n+            --  indicates that either all units were elaborated or the library\n+            --  graph contains a circularity.\n+\n+            exit when not Present (Candidate);\n+\n+            --  Elaborate the component of the candidate vertex by trying to\n+            --  elaborate as many vertices within the component as possible.\n+            --  Each successful elaboration signals the appropriate successors\n+            --  and their components that they have one less predecessor to\n+            --  wait on. This may add new candidates to set All_Candidates.\n+\n+            Comp := Component (G, Candidate);\n+            pragma Assert (Present (Comp));\n+\n+            Elaborate_Component\n+              (G                  => G,\n+               Comp               => Comp,\n+               All_Candidates     => All_Candidates,\n+               Remaining_Vertices => Remaining_Vertices,\n+               Order              => Order,\n+               Step               => Step);\n+         end loop;\n+\n+         Destroy (All_Candidates);\n+\n+         --  The library graph contains an Elaborate_All circularity when\n+         --  at least one edge subject to the related pragma appears in a\n+         --  component.\n+\n+         if Has_Elaborate_All_Cycle (G) then\n+            Status := Order_Has_Elaborate_All_Circularity;\n+\n+         --  The library contains a circularity when at least one vertex failed\n+         --  to elaborate.\n+\n+         elsif Remaining_Vertices /= 0 then\n+            Status := Order_Has_Circularity;\n+\n+         --  Otherwise the elaboration order is satisfactory\n+\n+         else\n+            Status := Order_OK;\n+         end if;\n+      end Elaborate_Library_Graph;\n+\n+      ---------------------\n+      -- Elaborate_Units --\n+      ---------------------\n+\n+      procedure Elaborate_Units\n+        (Order         : out Unit_Id_Table;\n+         Main_Lib_File : File_Name_Type)\n+      is\n+         Main_Lib_Unit : constant Unit_Id :=\n+                           Corresponding_Unit (Unit_Name_Type (Main_Lib_File));\n+\n+      begin\n+         pragma Assert (Present (Main_Lib_Unit));\n+\n+         --  Initialize all unit-related data structures and gather all units\n+         --  that need elaboration.\n+\n+         Initialize_Units;\n+         Collect_Elaborable_Units;\n+\n+         Write_ALI_Tables;\n+\n+         --  Choose the proper elaboration strategy based on whether the main\n+         --  library unit was compiled with dynamic elaboration checks.\n+\n+         if Is_Dynamically_Elaborated (Main_Lib_Unit) then\n+            Elaborate_Units_Dynamic (Order);\n+         else\n+            Elaborate_Units_Static (Order);\n+         end if;\n+\n+         Validate_Elaboration_Order (Order);\n+         Write_Elaboration_Order    (Order);\n+\n+         --  Enumerate the sources referenced in the closure of the order\n+\n+         Write_Unit_Closure (Order);\n+\n+         --  Destroy all unit-delated data structures\n+\n+         Finalize_Units;\n+\n+      exception\n+         when others =>\n+            Finalize_Units;\n+            raise;\n+      end Elaborate_Units;\n+\n+      ----------------------------\n+      -- Elaborate_Units_Common --\n+      ----------------------------\n+\n+      procedure Elaborate_Units_Common\n+        (Use_Inv_Graph : Boolean;\n+         Inv_Graph     : out Invocation_Graph;\n+         Lib_Graph     : out Library_Graph;\n+         Order         : out Unit_Id_Table;\n+         Status        : out Elaboration_Order_Status)\n+      is\n+      begin\n+         --  Create, validate, and output the library graph which captures the\n+         --  dependencies between library items.\n+\n+         Lib_Graph := Build_Library_Graph;\n+         Validate_Library_Graph (Lib_Graph);\n+         Write_Library_Graph    (Lib_Graph);\n+\n+         --  Create, validate, output, and use the invocation graph which\n+         --  represents the flow of execusion only when requested by the\n+         --  caller.\n+\n+         if Use_Inv_Graph then\n+            Inv_Graph := Build_Invocation_Graph (Lib_Graph);\n+            Validate_Invocation_Graph (Inv_Graph);\n+            Write_Invocation_Graph    (Inv_Graph);\n+\n+         --  Otherwise the invocation graph is not used. Create a dummy graph\n+         --  as this allows for a uniform behavior on the caller side.\n+\n+         else\n+            Inv_Graph :=\n+              Invocation_Graphs.Create\n+                (Initial_Vertices => 1,\n+                 Initial_Edges    => 1);\n+         end if;\n+\n+         --  Traverse the invocation graph starting from elaboration code in\n+         --  order to discover transitions of the execution flow from a unit\n+         --  to a unit which result in extra edges within the library graph.\n+\n+         Augment_Library_Graph (Inv_Graph, Lib_Graph);\n+\n+         --  Create and output the component graph by collapsing all library\n+         --  items into library units and traversing the library graph.\n+\n+         Find_Components     (Lib_Graph);\n+         Write_Library_Graph (Lib_Graph);\n+\n+         --  Traverse the library graph to determine the elaboration order of\n+         --  units.\n+\n+         Elaborate_Library_Graph\n+           (G      => Lib_Graph,\n+            Order  => Order,\n+            Status => Status);\n+      end Elaborate_Units_Common;\n+\n+      -----------------------------\n+      -- Elaborate_Units_Dynamic --\n+      -----------------------------\n+\n+      procedure Elaborate_Units_Dynamic (Order : out Unit_Id_Table) is\n+         Dyn_Inv_Graph : Invocation_Graph;\n+         Dyn_Lib_Graph : Library_Graph;\n+         Dyn_Order     : Unit_Id_Table;\n+         Mix_Inv_Graph : Invocation_Graph;\n+         Mix_Lib_Graph : Library_Graph;\n+         Mix_Order     : Unit_Id_Table;\n+         Status        : Elaboration_Order_Status;\n+\n+      begin\n+         --  Attempt to elaborate the units in the library graph by mixing in\n+         --  the information from the invocation graph. This assumes that all\n+         --  invocations will take place at elaboration time.\n+\n+         Elaborate_Units_Common\n+           (Use_Inv_Graph => True,\n+            Inv_Graph     => Mix_Inv_Graph,\n+            Lib_Graph     => Mix_Lib_Graph,\n+            Order         => Mix_Order,\n+            Status        => Status);\n+\n+         --  The elaboration order is satisfactory\n+\n+         if Status = Order_OK then\n+            Order := Mix_Order;\n+\n+         --  The library graph contains an Elaborate_All circularity. There is\n+         --  no point in re-elaborating the units without the information from\n+         --  the invocation graph because the circularity will persist.\n+\n+         elsif Status = Order_Has_Elaborate_All_Circularity then\n+            Error_Msg (\"elaboration circularity detected\");\n+\n+            --  Report error here\n+\n+         --  Otherwise the library graph contains a circularity, or the extra\n+         --  information provided by the invocation graph caused a circularity.\n+         --  Re-elaborate the units without using the invocation graph. This\n+         --  assumes that all invocations will not take place at elaboration\n+         --  time.\n+\n+         else\n+            pragma Assert (Status = Order_Has_Circularity);\n+\n+            Elaborate_Units_Common\n+              (Use_Inv_Graph => False,\n+               Inv_Graph     => Dyn_Inv_Graph,\n+               Lib_Graph     => Dyn_Lib_Graph,\n+               Order         => Dyn_Order,\n+               Status        => Status);\n+\n+            --  The elaboration order is satisfactory. The elaboration of the\n+            --  program may still fail at runtime with an ABE.\n+\n+            if Status = Order_OK then\n+               Order := Dyn_Order;\n+\n+            --  Otherwise the library graph contains a circularity without the\n+            --  extra information provided by the invocation graph. Diagnose\n+            --  the circularity.\n+\n+            else\n+               Error_Msg (\"elaboration circularity detected\");\n+\n+               --  Report error here\n+            end if;\n+\n+            Destroy (Dyn_Inv_Graph);\n+            Destroy (Dyn_Lib_Graph);\n+         end if;\n+\n+         Destroy (Mix_Inv_Graph);\n+         Destroy (Mix_Lib_Graph);\n+\n+         --  Halt the bind as there is no satisfactory elaboration order\n+\n+         if Status /= Order_OK then\n+            raise Unrecoverable_Error;\n+         end if;\n+      end Elaborate_Units_Dynamic;\n+\n+      ----------------------------\n+      -- Elaborate_Units_Static --\n+      ----------------------------\n+\n+      procedure Elaborate_Units_Static (Order : out Unit_Id_Table) is\n+         Inv_Graph : Invocation_Graph;\n+         Lib_Graph : Library_Graph;\n+         Status    : Elaboration_Order_Status;\n+\n+      begin\n+         --  Attempt to elaborate the units in the library graph by mixing in\n+         --  the information from the invocation graph. This assumes that all\n+         --  invocations will take place at elaboration time.\n+\n+         Elaborate_Units_Common\n+           (Use_Inv_Graph => True,\n+            Inv_Graph     => Inv_Graph,\n+            Lib_Graph     => Lib_Graph,\n+            Order         => Order,\n+            Status        => Status);\n+\n+         --  The augmented library graph contains a circularity\n+\n+         if Status /= Order_OK then\n+            Error_Msg (\"elaboration circularity detected\");\n+\n+            --  Report error here\n+         end if;\n+\n+         Destroy (Inv_Graph);\n+         Destroy (Lib_Graph);\n+\n+         --  Halt the bind as there is no satisfactory elaboration order\n+\n+         if Status /= Order_OK then\n+            raise Unrecoverable_Error;\n+         end if;\n+      end Elaborate_Units_Static;\n+\n+      ----------------------\n+      -- Elaborate_Vertex --\n+      ----------------------\n+\n+      procedure Elaborate_Vertex\n+        (G                  : Library_Graph;\n+         LGV_Id             : Library_Graph_Vertex_Id;\n+         All_Candidates     : Membership_Set;\n+         Comp_Candidates    : Membership_Set;\n+         Remaining_Vertices : in out Natural;\n+         Order              : in out Unit_Id_Table;\n+         Step               : Elaboration_Order_Step;\n+         Indent             : Indentation_Level)\n+      is\n+         Body_LGV_Id : Library_Graph_Vertex_Id;\n+         U_Id        : Unit_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+         pragma Assert (Needs_Elaboration (G, LGV_Id));\n+         pragma Assert (Present (All_Candidates));\n+         pragma Assert (Present (Comp_Candidates));\n+\n+         Trace_Vertex\n+           (G      => G,\n+            LGV_Id => LGV_Id,\n+            Msg    => \"elaborating vertex\",\n+            Step   => Step,\n+            Indent => Indent);\n+\n+         --  Remove the vertex from both candidate sets. This is needed when\n+         --  the vertex is both an overall best candidate among all vertices,\n+         --  and the best candidate within the component. There is no need to\n+         --  check that the vertex is present in either set because the set\n+         --  implementation handles this case.\n+\n+         Delete (All_Candidates,  LGV_Id);\n+         Delete (Comp_Candidates, LGV_Id);\n+\n+         --  Mark the vertex as elaborated in order to prevent further attempts\n+         --  to re-elaborate it.\n+\n+         Set_In_Elaboration_Order (G, LGV_Id);\n+\n+         --  Add the unit represented by the vertex to the elaboration order\n+\n+         U_Id := Unit (G, LGV_Id);\n+         pragma Assert (Present (U_Id));\n+\n+         Unit_Id_Tables.Append (Order, U_Id);\n+\n+         --  There is now one fewer vertex to elaborate\n+\n+         Remaining_Vertices := Remaining_Vertices - 1;\n+\n+         --  Notify all successors and their components that they have one\n+         --  fewer predecessor to wait on. This may cause some successors to\n+         --  be included in one of the sets.\n+\n+         Update_Successors\n+           (G               => G,\n+            Pred            => LGV_Id,\n+            All_Candidates  => All_Candidates,\n+            Comp_Candidates => Comp_Candidates,\n+            Step            => Step,\n+            Indent          => Indent + Nested_Indentation);\n+\n+         --  The vertex denotes a spec with a completing body, and is subject\n+         --  to pragma Elaborate_Body. Elaborate the body in order to satisfy\n+         --  the semantics of the pragma.\n+\n+         if Is_Spec_With_Elaborate_Body (G, LGV_Id) then\n+            Body_LGV_Id := Proper_Body (G, LGV_Id);\n+            pragma Assert (Present (Body_LGV_Id));\n+\n+            Elaborate_Vertex\n+              (G                  => G,\n+               LGV_Id             => Body_LGV_Id,\n+               All_Candidates     => All_Candidates,\n+               Comp_Candidates    => Comp_Candidates,\n+               Remaining_Vertices => Remaining_Vertices,\n+               Order              => Order,\n+               Step               => Step,\n+               Indent             => Indent);\n+         end if;\n+      end Elaborate_Vertex;\n+\n+      -------------------------\n+      -- Find_Best_Candidate --\n+      -------------------------\n+\n+      function Find_Best_Candidate\n+        (G      : Library_Graph;\n+         Set    : Membership_Set;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level) return Library_Graph_Vertex_Id\n+      is\n+         Best : Library_Graph_Vertex_Id;\n+         Curr : Library_Graph_Vertex_Id;\n+         Iter : Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Set));\n+\n+         --  Assume that there is no candidate\n+\n+         Best := No_Library_Graph_Vertex;\n+\n+         --  Inspect all vertices in the set, looking for the best candidate to\n+         --  elaborate.\n+\n+         Iter := Iterate (Set);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Curr);\n+\n+            pragma Assert (Present (Curr));\n+            pragma Assert (Needs_Elaboration (G, Curr));\n+\n+            --  Update the best candidate when there is no such candidate\n+\n+            if not Present (Best) then\n+               Best := Curr;\n+\n+               Trace_Vertex\n+                 (G      => G,\n+                  LGV_Id => Best,\n+                  Msg    => \"initial best candidate vertex\",\n+                  Step   => Step,\n+                  Indent => Indent);\n+\n+            --  Update the best candidate when the current vertex is a better\n+            --  choice.\n+\n+            elsif Is_Better_Candidate\n+                    (G           => G,\n+                     Best_Candid => Best,\n+                     New_Candid  => Curr)\n+            then\n+               Best := Curr;\n+\n+               Trace_Vertex\n+                 (G      => G,\n+                  LGV_Id => Best,\n+                  Msg    => \"best candidate vertex\",\n+                  Step   => Step,\n+                  Indent => Indent);\n+            end if;\n+         end loop;\n+\n+         return Best;\n+      end Find_Best_Candidate;\n+\n+      -------------------------\n+      -- Is_Better_Candidate --\n+      -------------------------\n+\n+      function Is_Better_Candidate\n+        (G           : Library_Graph;\n+         Best_Candid : Library_Graph_Vertex_Id;\n+         New_Candid  : Library_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Best_Candid));\n+         pragma Assert (Present (New_Candid));\n+\n+         --  Prefer a predefined unit over a non-predefined unit\n+\n+         if Is_Predefined_Unit (G, Best_Candid)\n+           and then not Is_Predefined_Unit (G, New_Candid)\n+         then\n+            return False;\n+\n+         elsif not Is_Predefined_Unit (G, Best_Candid)\n+           and then Is_Predefined_Unit (G, New_Candid)\n+         then\n+            return True;\n+\n+         --  Prefer an internal unit over a non-iternal unit\n+\n+         elsif Is_Internal_Unit (G, Best_Candid)\n+           and then not Is_Internal_Unit (G, New_Candid)\n+         then\n+            return False;\n+\n+         elsif not Is_Internal_Unit (G, Best_Candid)\n+           and then Is_Internal_Unit (G, New_Candid)\n+         then\n+            return True;\n+\n+         --  Prefer a preelaborated unit over a non-preelaborated unit\n+\n+         elsif Is_Preelaborated_Unit (G, Best_Candid)\n+           and then not Is_Preelaborated_Unit (G, New_Candid)\n+         then\n+            return False;\n+\n+         elsif not Is_Preelaborated_Unit (G, Best_Candid)\n+           and then Is_Preelaborated_Unit (G, New_Candid)\n+         then\n+            return True;\n+\n+         --  Otherwise default to lexicographical order to ensure deterministic\n+         --  behavior.\n+\n+         else\n+            return Uname_Less (Name (G, Best_Candid), Name (G, New_Candid));\n+         end if;\n+      end Is_Better_Candidate;\n+\n+      ------------------------------\n+      -- Trace_Candidate_Vertices --\n+      ------------------------------\n+\n+      procedure Trace_Candidate_Vertices\n+        (G    : Library_Graph;\n+         Set  : Membership_Set;\n+         Step : Elaboration_Order_Step)\n+      is\n+         Iter   : Iterator;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Set));\n+\n+         --  Nothing to do when switch -d_T (output elaboration order trace\n+         --  information) is not in effect.\n+\n+         if not Debug_Flag_Underscore_TT then\n+            return;\n+         end if;\n+\n+         Trace_Step (Step);\n+         Write_Str  (\"candidate vertices: \");\n+         Write_Int  (Int (Size (Set)));\n+         Write_Eol;\n+\n+         Iter := Iterate (Set);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGV_Id);\n+            pragma Assert (Present (LGV_Id));\n+\n+            Trace_Vertex\n+              (G      => G,\n+               LGV_Id => LGV_Id,\n+               Msg    => \"candidate vertex\",\n+               Step   => Step,\n+               Indent => Nested_Indentation);\n+         end loop;\n+      end Trace_Candidate_Vertices;\n+\n+      ---------------------\n+      -- Trace_Component --\n+      ---------------------\n+\n+      procedure Trace_Component\n+        (G    : Library_Graph;\n+         Comp : Component_Id;\n+         Msg  : String;\n+         Step : Elaboration_Order_Step)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         --  Nothing to do when switch -d_T (output elaboration order trace\n+         --  information) is not in effect.\n+\n+         if not Debug_Flag_Underscore_TT then\n+            return;\n+         end if;\n+\n+         Trace_Step (Step);\n+         Write_Str  (Msg);\n+         Write_Str  (\" (Comp_Id_\");\n+         Write_Int  (Int (Comp));\n+         Write_Str  (\")\");\n+         Write_Eol;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Nested_Indentation);\n+         Write_Str  (\"pending predecessors: \");\n+         Write_Num  (Int (Pending_Predecessors (G, Comp)));\n+         Write_Eol;\n+      end Trace_Component;\n+\n+      ----------------\n+      -- Trace_Step --\n+      ----------------\n+\n+      procedure Trace_Step (Step : Elaboration_Order_Step) is\n+      begin\n+         --  Nothing to do when switch -d_T (output elaboration order trace\n+         --  information) is not in effect.\n+\n+         if not Debug_Flag_Underscore_TT then\n+            return;\n+         end if;\n+\n+         Write_Num\n+           (Val        => Int (Step),\n+            Val_Indent => Step_Column);\n+         Write_Str (\": \");\n+      end Trace_Step;\n+\n+      ---------------------------------\n+      -- Trace_Unelaborated_Vertices --\n+      ---------------------------------\n+\n+      procedure Trace_Unelaborated_Vertices\n+        (G     : Library_Graph;\n+         Count : Natural;\n+         Step  : Elaboration_Order_Step)\n+      is\n+         Iter   : Library_Graphs.All_Vertex_Iterator;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Nothing to do when switch -d_T (output elaboration order trace\n+         --  information) is not in effect.\n+\n+         if not Debug_Flag_Underscore_TT then\n+            return;\n+         end if;\n+\n+         Trace_Step (Step);\n+         Write_Str  (\"remaining unelaborated vertices: \");\n+         Write_Int  (Int (Count));\n+         Write_Eol;\n+\n+         Iter := Iterate_All_Vertices (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGV_Id);\n+            pragma Assert (Present (LGV_Id));\n+\n+            if Needs_Elaboration (G, LGV_Id)\n+              and then not In_Elaboration_Order (G, LGV_Id)\n+            then\n+               Trace_Vertex\n+                 (G      => G,\n+                  LGV_Id => LGV_Id,\n+                  Msg    => \"remaining vertex\",\n+                  Step   => Step,\n+                  Indent => Nested_Indentation);\n+            end if;\n+         end loop;\n+      end Trace_Unelaborated_Vertices;\n+\n+      ------------------\n+      -- Trace_Vertex --\n+      ------------------\n+\n+      procedure Trace_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Msg    : String;\n+         Step   : Elaboration_Order_Step;\n+         Indent : Indentation_Level)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Comp : constant Component_Id := Component (G, LGV_Id);\n+\n+         pragma Assert (Present (Comp));\n+\n+      begin\n+         --  Nothing to do when switch -d_T (output elaboration order trace\n+         --  information) is not in effect.\n+\n+         if not Debug_Flag_Underscore_TT then\n+            return;\n+         end if;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Indent);\n+         Write_Str  (Msg);\n+         Write_Str  (\" (LGV_Id_\");\n+         Write_Int  (Int (LGV_Id));\n+         Write_Str  (\")\");\n+         Write_Eol;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Indent + Nested_Indentation);\n+         Write_Str  (\"name = \");\n+         Write_Name (Name (G, LGV_Id));\n+         Write_Eol;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Indent + Nested_Indentation);\n+         Write_Str  (\"Component (Comp_Id_\");\n+         Write_Int  (Int (Comp));\n+         Write_Str  (\")\");\n+         Write_Eol;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Indent + Nested_Indentation);\n+         Write_Str  (\"pending predecessors: \");\n+         Write_Num  (Int (Pending_Predecessors (G, LGV_Id)));\n+         Write_Eol;\n+\n+         Trace_Step (Step);\n+         Indent_By  (Indent + Nested_Indentation);\n+         Write_Str  (\"pending components  : \");\n+         Write_Num  (Int (Pending_Predecessors (G, Comp)));\n+         Write_Eol;\n+      end Trace_Vertex;\n+\n+      ----------------------\n+      -- Update_Successor --\n+      ----------------------\n+\n+      procedure Update_Successor\n+        (G               : Library_Graph;\n+         Pred            : Library_Graph_Vertex_Id;\n+         Succ            : Library_Graph_Vertex_Id;\n+         All_Candidates  : Membership_Set;\n+         Comp_Candidates : Membership_Set;\n+         Step            : Elaboration_Order_Step;\n+         Indent          : Indentation_Level)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Needs_Elaboration (G, Pred));\n+         pragma Assert (Present (Succ));\n+         pragma Assert (Needs_Elaboration (G, Succ));\n+         pragma Assert (Present (All_Candidates));\n+         pragma Assert (Present (Comp_Candidates));\n+\n+         Pred_Comp : constant Component_Id := Component (G, Pred);\n+         Succ_Comp : constant Component_Id := Component (G, Succ);\n+\n+         pragma Assert (Present (Pred_Comp));\n+         pragma Assert (Present (Succ_Comp));\n+\n+         In_Different_Components : constant Boolean := Pred_Comp /= Succ_Comp;\n+\n+         Candidate : Library_Graph_Vertex_Id;\n+         Iter      : Component_Vertex_Iterator;\n+         Msg       : String_Ptr;\n+         Set       : Membership_Set;\n+\n+      begin\n+         Trace_Vertex\n+           (G      => G,\n+            LGV_Id => Succ,\n+            Msg    => \"updating successor\",\n+            Step   => Step,\n+            Indent => Indent);\n+\n+         --  Notify the successor that it has one less predecessor to wait on.\n+         --  This effectively eliminates the edge that links the two.\n+\n+         Decrement_Pending_Predecessors (G, Succ);\n+\n+         --  The predecessor and successor reside in different components.\n+         --  Notify the successor component it has one fewer components to\n+         --  wait on.\n+\n+         if In_Different_Components then\n+            Decrement_Pending_Predecessors (G, Succ_Comp);\n+         end if;\n+\n+         --  At this point the successor may become elaborable when its final\n+         --  predecessor or final predecessor component is elaborated.\n+\n+         --  The predecessor and successor reside in different components.\n+         --  The successor must not be added to the candidates of Pred's\n+         --  component because this will mix units from the two components.\n+         --  Instead, the successor is added to the set of all candidates\n+         --  that must be elaborated.\n+\n+         if In_Different_Components then\n+            Msg := Add_To_All_Candidates_Msg'Access;\n+            Set := All_Candidates;\n+\n+         --  Otherwise the predecessor and successor reside within the same\n+         --  component. Pred's component gains another elaborable node.\n+\n+         else\n+            Msg := Add_To_Comp_Candidates_Msg'Access;\n+            Set := Comp_Candidates;\n+         end if;\n+\n+         Add_Vertex_If_Elaborable\n+           (G      => G,\n+            LGV_Id => Succ,\n+            Set    => Set,\n+            Msg    => Msg.all,\n+            Step   => Step,\n+            Indent => Indent + Nested_Indentation);\n+\n+         --  At this point the successor component may become elaborable when\n+         --  its final predecessor component is elaborated. This in turn may\n+         --  allow vertices of the successor component to be elaborated.\n+\n+         if In_Different_Components\n+           and then Is_Elaborable_Component (G, Succ_Comp)\n+         then\n+            Iter := Iterate_Component_Vertices (G, Succ_Comp);\n+            while Has_Next (Iter) loop\n+               Next (Iter, Candidate);\n+               pragma Assert (Present (Candidate));\n+\n+               Add_Vertex_If_Elaborable\n+                 (G      => G,\n+                  LGV_Id => Candidate,\n+                  Set    => All_Candidates,\n+                  Msg    => Add_To_All_Candidates_Msg,\n+                  Step   => Step,\n+                  Indent => Indent + Nested_Indentation);\n+            end loop;\n+         end if;\n+      end Update_Successor;\n+\n+      -----------------------\n+      -- Update_Successors --\n+      -----------------------\n+\n+      procedure Update_Successors\n+        (G               : Library_Graph;\n+         Pred            : Library_Graph_Vertex_Id;\n+         All_Candidates  : Membership_Set;\n+         Comp_Candidates : Membership_Set;\n+         Step            : Elaboration_Order_Step;\n+         Indent          : Indentation_Level)\n+      is\n+         Iter   : Edges_To_Successors_Iterator;\n+         LGE_Id : Library_Graph_Edge_Id;\n+         Succ   : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Needs_Elaboration (G, Pred));\n+         pragma Assert (Present (All_Candidates));\n+         pragma Assert (Present (Comp_Candidates));\n+\n+         Iter := Iterate_Edges_To_Successors (G, Pred);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGE_Id);\n+\n+            pragma Assert (Present (LGE_Id));\n+            pragma Assert (Predecessor (G, LGE_Id) = Pred);\n+\n+            Succ := Successor (G, LGE_Id);\n+            pragma Assert (Present (Succ));\n+\n+            Update_Successor\n+              (G               => G,\n+               Pred            => Pred,\n+               Succ            => Succ,\n+               All_Candidates  => All_Candidates,\n+               Comp_Candidates => Comp_Candidates,\n+               Step            => Step,\n+               Indent          => Indent);\n+         end loop;\n+      end Update_Successors;\n+   end Invocation_And_Library_Graph_Elaborators;\n+\n+end Bindo.Elaborators;"}, {"sha": "c65f593df0e0b6bfbe6a18c15239b67fd0394bd5", "filename": "gcc/ada/bindo-elaborators.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-elaborators.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-elaborators.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-elaborators.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     B I N D O . E L A B O R A T O R S                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  For full architecture, see unit Bindo.\n+\n+--  The following unit contains facilities to find the elaboration order of\n+--  units based on various graphs.\n+\n+with Bindo.Graphs;\n+use  Bindo.Graphs;\n+use  Bindo.Graphs.Invocation_Graphs;\n+use  Bindo.Graphs.Library_Graphs;\n+\n+package Bindo.Elaborators is\n+\n+   ----------------------------------------------\n+   -- Invocation_And_Library_Graph_Elaborators --\n+   ----------------------------------------------\n+\n+   package Invocation_And_Library_Graph_Elaborators is\n+      procedure Elaborate_Units\n+        (Order         : out Unit_Id_Table;\n+         Main_Lib_File : File_Name_Type);\n+      --  Find an order of all units in the bind that need to be elaborated\n+      --  such that elaboration code flow, pragmas Elaborate, Elaborate_All,\n+      --  and Elaborate_Body, and with clause dependencies are all honoured.\n+      --  Main_Lib_File is the argument of the bind. If a satisfactory order\n+      --  exists, it is returned in Order, otherwise Unrecoverable_Error is\n+      --  raised.\n+\n+   end Invocation_And_Library_Graph_Elaborators;\n+\n+end Bindo.Elaborators;"}, {"sha": "ec99fe419e7f16df2890f601bb76e600fa37f045", "filename": "gcc/ada/bindo-graphs.adb", "status": "added", "additions": 2890, "deletions": 0, "changes": 2890, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,2890 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         B I N D O . G R A P H S                          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with GNAT.Lists; use GNAT.Lists;\n+\n+package body Bindo.Graphs is\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   function Sequence_Next_IGE_Id return Invocation_Graph_Edge_Id;\n+   pragma Inline (Sequence_Next_IGE_Id);\n+   --  Generate a new unique invocation graph edge handle\n+\n+   function Sequence_Next_IGV_Id return Invocation_Graph_Vertex_Id;\n+   pragma Inline (Sequence_Next_IGV_Id);\n+   --  Generate a new unique invocation graph vertex handle\n+\n+   function Sequence_Next_LGE_Id return Library_Graph_Edge_Id;\n+   pragma Inline (Sequence_Next_LGE_Id);\n+   --  Generate a new unique library graph edge handle\n+\n+   function Sequence_Next_LGV_Id return Library_Graph_Vertex_Id;\n+   pragma Inline (Sequence_Next_LGV_Id);\n+   --  Generate a new unique library graph vertex handle\n+\n+   --------------------------------\n+   -- Hash_Invocation_Graph_Edge --\n+   --------------------------------\n+\n+   function Hash_Invocation_Graph_Edge\n+     (IGE_Id : Invocation_Graph_Edge_Id) return Bucket_Range_Type\n+   is\n+   begin\n+      pragma Assert (Present (IGE_Id));\n+\n+      return Bucket_Range_Type (IGE_Id);\n+   end Hash_Invocation_Graph_Edge;\n+\n+   ----------------------------------\n+   -- Hash_Invocation_Graph_Vertex --\n+   ----------------------------------\n+\n+   function Hash_Invocation_Graph_Vertex\n+     (IGV_Id : Invocation_Graph_Vertex_Id) return Bucket_Range_Type\n+   is\n+   begin\n+      pragma Assert (Present (IGV_Id));\n+\n+      return Bucket_Range_Type (IGV_Id);\n+   end Hash_Invocation_Graph_Vertex;\n+\n+   -----------------------------\n+   -- Hash_Library_Graph_Edge --\n+   -----------------------------\n+\n+   function Hash_Library_Graph_Edge\n+     (LGE_Id : Library_Graph_Edge_Id) return Bucket_Range_Type\n+   is\n+   begin\n+      pragma Assert (Present (LGE_Id));\n+\n+      return Bucket_Range_Type (LGE_Id);\n+   end Hash_Library_Graph_Edge;\n+\n+   -------------------------------\n+   -- Hash_Library_Graph_Vertex --\n+   -------------------------------\n+\n+   function Hash_Library_Graph_Vertex\n+     (LGV_Id : Library_Graph_Vertex_Id) return Bucket_Range_Type\n+   is\n+   begin\n+      pragma Assert (Present (LGV_Id));\n+\n+      return Bucket_Range_Type (LGV_Id);\n+   end Hash_Library_Graph_Vertex;\n+\n+   -----------------------\n+   -- Invocation_Graphs --\n+   -----------------------\n+\n+   package body Invocation_Graphs is\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation\n+              (Invocation_Graph_Attributes, Invocation_Graph);\n+\n+      function Get_IGE_Attributes\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id)\n+         return Invocation_Graph_Edge_Attributes;\n+      pragma Inline (Get_IGE_Attributes);\n+      --  Obtain the attributes of edge IGE_Id of invocation graph G\n+\n+      function Get_IGV_Attributes\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id)\n+         return Invocation_Graph_Vertex_Attributes;\n+      pragma Inline (Get_IGV_Attributes);\n+      --  Obtain the attributes of vertex IGV_Id of invocation graph G\n+\n+      procedure Increment_Invocation_Graph_Edge_Count\n+        (G    : Invocation_Graph;\n+         Kind : Invocation_Kind);\n+      pragma Inline (Increment_Invocation_Graph_Edge_Count);\n+      --  Increment the number of edges of king Kind in invocation graph G by\n+      --  one.\n+\n+      function Is_Elaboration_Root\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Elaboration_Root);\n+      --  Determine whether vertex IGV_Id of invocation graph denotes the\n+      --  elaboration procedure of a spec or a body.\n+\n+      function Is_Existing_Source_Target_Relation\n+        (G   : Invocation_Graph;\n+         Rel : Source_Target_Relation) return Boolean;\n+      pragma Inline (Is_Existing_Source_Target_Relation);\n+      --  Determine whether a source vertex and a target vertex desctibed by\n+      --  relation Rel are already related in invocation graph G.\n+\n+      procedure Save_Elaboration_Root\n+        (G    : Invocation_Graph;\n+         Root : Invocation_Graph_Vertex_Id);\n+      pragma Inline (Save_Elaboration_Root);\n+      --  Save elaboration root Root of invocation graph G\n+\n+      procedure Set_Corresponding_Vertex\n+        (G      : Invocation_Graph;\n+         IS_Id  : Invocation_Signature_Id;\n+         IGV_Id : Invocation_Graph_Vertex_Id);\n+      pragma Inline (Set_Corresponding_Vertex);\n+      --  Associate vertex IGV_Id of invocation graph G with signature IS_Id\n+\n+      procedure Set_Is_Existing_Source_Target_Relation\n+        (G   : Invocation_Graph;\n+         Rel : Source_Target_Relation;\n+         Val : Boolean := True);\n+      pragma Inline (Set_Is_Existing_Source_Target_Relation);\n+      --  Mark a source vertex and a target vertex desctibed by relation Rel as\n+      --  already related in invocation graph G depending on value Val.\n+\n+      procedure Set_IGE_Attributes\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id;\n+         Val    : Invocation_Graph_Edge_Attributes);\n+      pragma Inline (Set_IGE_Attributes);\n+      --  Set the attributes of edge IGE_Id of invocation graph G to value Val\n+\n+      procedure Set_IGV_Attributes\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id;\n+         Val    : Invocation_Graph_Vertex_Attributes);\n+      pragma Inline (Set_IGV_Attributes);\n+      --  Set the attributes of vertex IGV_Id of invocation graph G to value\n+      --  Val.\n+\n+      --------------\n+      -- Add_Edge --\n+      --------------\n+\n+      procedure Add_Edge\n+        (G      : Invocation_Graph;\n+         Source : Invocation_Graph_Vertex_Id;\n+         Target : Invocation_Graph_Vertex_Id;\n+         IR_Id  : Invocation_Relation_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Source));\n+         pragma Assert (Present (Target));\n+         pragma Assert (Present (IR_Id));\n+\n+         Rel : constant Source_Target_Relation :=\n+                 (Source => Source,\n+                  Target => Target);\n+\n+         IR_Rec : Invocation_Relation_Record renames\n+                    Invocation_Relations.Table (IR_Id);\n+\n+         IGE_Id : Invocation_Graph_Edge_Id;\n+\n+      begin\n+         --  Nothing to do when the source and target are already related by an\n+         --  edge.\n+\n+         if Is_Existing_Source_Target_Relation (G, Rel) then\n+            return;\n+         end if;\n+\n+         IGE_Id := Sequence_Next_IGE_Id;\n+\n+         --  Add the edge to the underlying graph\n+\n+         DG.Add_Edge\n+           (G           => G.Graph,\n+            E           => IGE_Id,\n+            Source      => Source,\n+            Destination => Target);\n+\n+         --  Build and save the attributes of the edge\n+\n+         Set_IGE_Attributes\n+           (G      => G,\n+            IGE_Id => IGE_Id,\n+            Val    => (Relation => IR_Id));\n+\n+         --  Mark the source and target as related by the new edge. This\n+         --  prevents all further attempts to link the same source and target.\n+\n+         Set_Is_Existing_Source_Target_Relation (G, Rel);\n+\n+         --  Update the edge statistics\n+\n+         Increment_Invocation_Graph_Edge_Count (G, IR_Rec.Kind);\n+      end Add_Edge;\n+\n+      ----------------\n+      -- Add_Vertex --\n+      ----------------\n+\n+      procedure Add_Vertex\n+        (G      : Invocation_Graph;\n+         IC_Id  : Invocation_Construct_Id;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IC_Id));\n+         pragma Assert (Present (LGV_Id));\n+\n+         IC_Rec : Invocation_Construct_Record renames\n+                    Invocation_Constructs.Table (IC_Id);\n+\n+         pragma Assert (Present (IC_Rec.Signature));\n+\n+         IGV_Id : Invocation_Graph_Vertex_Id;\n+\n+      begin\n+         --  Nothing to do when the construct already has a vertex\n+\n+         if Present (Corresponding_Vertex (G, IC_Rec.Signature)) then\n+            return;\n+         end if;\n+\n+         IGV_Id := Sequence_Next_IGV_Id;\n+\n+         --  Add the vertex to the underlying graph\n+\n+         DG.Add_Vertex (G.Graph, IGV_Id);\n+\n+         --  Build and save the attributes of the vertex\n+\n+         Set_IGV_Attributes\n+           (G      => G,\n+            IGV_Id => IGV_Id,\n+            Val    => (Construct  => IC_Id,\n+                       Lib_Vertex => LGV_Id));\n+\n+         --  Associate the construct with its corresponding vertex\n+\n+         Set_Corresponding_Vertex (G, IC_Rec.Signature, IGV_Id);\n+\n+         --  Save the vertex for later processing when it denotes a spec or\n+         --  body elaboration procedure.\n+\n+         if Is_Elaboration_Root (G, IGV_Id) then\n+            Save_Elaboration_Root (G, IGV_Id);\n+         end if;\n+      end Add_Vertex;\n+\n+      ---------------\n+      -- Construct --\n+      ---------------\n+\n+      function Construct\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Invocation_Construct_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         return Get_IGV_Attributes (G, IGV_Id).Construct;\n+      end Construct;\n+\n+      --------------------------\n+      -- Corresponding_Vertex --\n+      --------------------------\n+\n+      function Corresponding_Vertex\n+        (G     : Invocation_Graph;\n+         IS_Id : Invocation_Signature_Id) return Invocation_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IS_Id));\n+\n+         return SV.Get (G.Signature_To_Vertex, IS_Id);\n+      end Corresponding_Vertex;\n+\n+      ------------\n+      -- Create --\n+      ------------\n+\n+      function Create\n+        (Initial_Vertices : Positive;\n+         Initial_Edges    : Positive) return Invocation_Graph\n+      is\n+         G : constant Invocation_Graph := new Invocation_Graph_Attributes;\n+\n+      begin\n+         G.Edge_Attributes     := EA.Create (Initial_Edges);\n+         G.Graph               :=\n+           DG.Create\n+             (Initial_Vertices => Initial_Vertices,\n+              Initial_Edges    => Initial_Edges);\n+         G.Relations           := ST.Create (Initial_Edges);\n+         G.Roots               := ER.Create (Initial_Vertices);\n+         G.Signature_To_Vertex := SV.Create (Initial_Vertices);\n+         G.Vertex_Attributes   := VA.Create (Initial_Vertices);\n+\n+         return G;\n+      end Create;\n+\n+      -------------\n+      -- Destroy --\n+      -------------\n+\n+      procedure Destroy (G : in out Invocation_Graph) is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         EA.Destroy (G.Edge_Attributes);\n+         DG.Destroy (G.Graph);\n+         ST.Destroy (G.Relations);\n+         ER.Destroy (G.Roots);\n+         SV.Destroy (G.Signature_To_Vertex);\n+         VA.Destroy (G.Vertex_Attributes);\n+\n+         Free (G);\n+      end Destroy;\n+\n+      -----------------------------------\n+      -- Destroy_Invocation_Graph_Edge --\n+      -----------------------------------\n+\n+      procedure Destroy_Invocation_Graph_Edge\n+        (IGE_Id : in out Invocation_Graph_Edge_Id)\n+      is\n+         pragma Unreferenced (IGE_Id);\n+      begin\n+         null;\n+      end Destroy_Invocation_Graph_Edge;\n+\n+      ----------------------------------------------\n+      -- Destroy_Invocation_Graph_Edge_Attributes --\n+      ----------------------------------------------\n+\n+      procedure Destroy_Invocation_Graph_Edge_Attributes\n+        (Attrs : in out Invocation_Graph_Edge_Attributes)\n+      is\n+         pragma Unreferenced (Attrs);\n+      begin\n+         null;\n+      end Destroy_Invocation_Graph_Edge_Attributes;\n+\n+      -------------------------------------\n+      -- Destroy_Invocation_Graph_Vertex --\n+      -------------------------------------\n+\n+      procedure Destroy_Invocation_Graph_Vertex\n+        (IGV_Id : in out Invocation_Graph_Vertex_Id)\n+      is\n+         pragma Unreferenced (IGV_Id);\n+      begin\n+         null;\n+      end Destroy_Invocation_Graph_Vertex;\n+\n+      ------------------------------------------------\n+      -- Destroy_Invocation_Graph_Vertex_Attributes --\n+      ------------------------------------------------\n+\n+      procedure Destroy_Invocation_Graph_Vertex_Attributes\n+        (Attrs : in out Invocation_Graph_Vertex_Attributes)\n+      is\n+         pragma Unreferenced (Attrs);\n+      begin\n+         null;\n+      end Destroy_Invocation_Graph_Vertex_Attributes;\n+\n+      ------------------------\n+      -- Get_IGE_Attributes --\n+      ------------------------\n+\n+      function Get_IGE_Attributes\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id)\n+         return Invocation_Graph_Edge_Attributes\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGE_Id));\n+\n+         return EA.Get (G.Edge_Attributes, IGE_Id);\n+      end Get_IGE_Attributes;\n+\n+      ------------------------\n+      -- Get_IGV_Attributes --\n+      ------------------------\n+\n+      function Get_IGV_Attributes\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id)\n+         return Invocation_Graph_Vertex_Attributes\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         return VA.Get (G.Vertex_Attributes, IGV_Id);\n+      end Get_IGV_Attributes;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : All_Edge_Iterator) return Boolean is\n+      begin\n+         return DG.Has_Next (DG.All_Edge_Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : All_Vertex_Iterator) return Boolean is\n+      begin\n+         return DG.Has_Next (DG.All_Vertex_Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Edges_To_Targets_Iterator) return Boolean is\n+      begin\n+         return DG.Has_Next (DG.Outgoing_Edge_Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Elaboration_Root_Iterator) return Boolean is\n+      begin\n+         return ER.Has_Next (ER.Iterator (Iter));\n+      end Has_Next;\n+\n+      -------------------------------\n+      -- Hash_Invocation_Signature --\n+      -------------------------------\n+\n+      function Hash_Invocation_Signature\n+        (IS_Id : Invocation_Signature_Id) return Bucket_Range_Type\n+      is\n+      begin\n+         pragma Assert (Present (IS_Id));\n+\n+         return Bucket_Range_Type (IS_Id);\n+      end Hash_Invocation_Signature;\n+\n+      ---------------------------------\n+      -- Hash_Source_Target_Relation --\n+      ---------------------------------\n+\n+      function Hash_Source_Target_Relation\n+        (Rel : Source_Target_Relation) return Bucket_Range_Type\n+      is\n+      begin\n+         pragma Assert (Present (Rel.Source));\n+         pragma Assert (Present (Rel.Target));\n+\n+         return\n+           Hash_Two_Keys\n+             (Bucket_Range_Type (Rel.Source),\n+              Bucket_Range_Type (Rel.Target));\n+      end Hash_Source_Target_Relation;\n+\n+      -------------------------------------------\n+      -- Increment_Invocation_Graph_Edge_Count --\n+      -------------------------------------------\n+\n+      procedure Increment_Invocation_Graph_Edge_Count\n+        (G    : Invocation_Graph;\n+         Kind : Invocation_Kind)\n+      is\n+         pragma Assert (Present (G));\n+\n+         Count : Natural renames G.Counts (Kind);\n+\n+      begin\n+         Count := Count + 1;\n+      end Increment_Invocation_Graph_Edge_Count;\n+\n+      ---------------------------------\n+      -- Invocation_Graph_Edge_Count --\n+      ---------------------------------\n+\n+      function Invocation_Graph_Edge_Count\n+        (G    : Invocation_Graph;\n+         Kind : Invocation_Kind) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return G.Counts (Kind);\n+      end Invocation_Graph_Edge_Count;\n+\n+      -------------------------\n+      -- Is_Elaboration_Root --\n+      -------------------------\n+\n+      function Is_Elaboration_Root\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         IC_Id : constant Invocation_Construct_Id := Construct (G, IGV_Id);\n+\n+         pragma Assert (Present (IC_Id));\n+\n+         IC_Rec : Invocation_Construct_Record renames\n+                    Invocation_Constructs.Table (IC_Id);\n+\n+      begin\n+         return\n+           IC_Rec.Kind = Elaborate_Body_Procedure\n+             or else\n+           IC_Rec.Kind = Elaborate_Spec_Procedure;\n+      end Is_Elaboration_Root;\n+\n+      ----------------------------------------\n+      -- Is_Existing_Source_Target_Relation --\n+      ----------------------------------------\n+\n+      function Is_Existing_Source_Target_Relation\n+        (G   : Invocation_Graph;\n+         Rel : Source_Target_Relation) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return ST.Contains (G.Relations, Rel);\n+      end Is_Existing_Source_Target_Relation;\n+\n+      -----------------------\n+      -- Iterate_All_Edges --\n+      -----------------------\n+\n+      function Iterate_All_Edges\n+        (G : Invocation_Graph) return All_Edge_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return All_Edge_Iterator (DG.Iterate_All_Edges (G.Graph));\n+      end Iterate_All_Edges;\n+\n+      --------------------------\n+      -- Iterate_All_Vertices --\n+      --------------------------\n+\n+      function Iterate_All_Vertices\n+        (G : Invocation_Graph) return All_Vertex_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return All_Vertex_Iterator (DG.Iterate_All_Vertices (G.Graph));\n+      end Iterate_All_Vertices;\n+\n+      ------------------------------\n+      -- Iterate_Edges_To_Targets --\n+      ------------------------------\n+\n+      function Iterate_Edges_To_Targets\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Edges_To_Targets_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         return\n+           Edges_To_Targets_Iterator\n+             (DG.Iterate_Outgoing_Edges (G.Graph, IGV_Id));\n+      end Iterate_Edges_To_Targets;\n+\n+      -------------------------------\n+      -- Iterate_Elaboration_Roots --\n+      -------------------------------\n+\n+      function Iterate_Elaboration_Roots\n+        (G : Invocation_Graph) return Elaboration_Root_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return Elaboration_Root_Iterator (ER.Iterate (G.Roots));\n+      end Iterate_Elaboration_Roots;\n+\n+      ----------\n+      -- Kind --\n+      ----------\n+\n+      function Kind\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Kind\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGE_Id));\n+\n+         IR_Id : constant Invocation_Relation_Id := Relation (G, IGE_Id);\n+\n+         pragma Assert (Present (IR_Id));\n+\n+         IR_Rec : Invocation_Relation_Record renames\n+                    Invocation_Relations.Table (IR_Id);\n+\n+      begin\n+         return IR_Rec.Kind;\n+      end Kind;\n+\n+      ----------------\n+      -- Lib_Vertex --\n+      ----------------\n+\n+      function Lib_Vertex\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         return Get_IGV_Attributes (G, IGV_Id).Lib_Vertex;\n+      end Lib_Vertex;\n+\n+      ----------\n+      -- Name --\n+      ----------\n+\n+      function Name\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Name_Id\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         IC_Id : constant Invocation_Construct_Id := Construct (G, IGV_Id);\n+\n+         pragma Assert (Present (IC_Id));\n+\n+         IC_Rec : Invocation_Construct_Record renames\n+                    Invocation_Constructs.Table (IC_Id);\n+\n+         pragma Assert (Present (IC_Rec.Signature));\n+\n+         IS_Rec : Invocation_Signature_Record renames\n+                    Invocation_Signatures.Table (IC_Rec.Signature);\n+\n+      begin\n+         return IS_Rec.Name;\n+      end Name;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter   : in out All_Edge_Iterator;\n+         IGE_Id : out Invocation_Graph_Edge_Id)\n+      is\n+      begin\n+         DG.Next (DG.All_Edge_Iterator (Iter), IGE_Id);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter   : in out All_Vertex_Iterator;\n+         IGV_Id : out Invocation_Graph_Vertex_Id)\n+      is\n+      begin\n+         DG.Next (DG.All_Vertex_Iterator (Iter), IGV_Id);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter   : in out Edges_To_Targets_Iterator;\n+         IGE_Id : out Invocation_Graph_Edge_Id)\n+      is\n+      begin\n+         DG.Next (DG.Outgoing_Edge_Iterator (Iter), IGE_Id);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter : in out Elaboration_Root_Iterator;\n+         Root : out Invocation_Graph_Vertex_Id)\n+      is\n+      begin\n+         ER.Next (ER.Iterator (Iter), Root);\n+      end Next;\n+\n+      ---------------------\n+      -- Number_Of_Edges --\n+      ---------------------\n+\n+      function Number_Of_Edges (G : Invocation_Graph) return Natural is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return DG.Number_Of_Edges (G.Graph);\n+      end Number_Of_Edges;\n+\n+      --------------------------------\n+      -- Number_Of_Edges_To_Targets --\n+      --------------------------------\n+\n+      function Number_Of_Edges_To_Targets\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         return DG.Number_Of_Outgoing_Edges (G.Graph, IGV_Id);\n+      end Number_Of_Edges_To_Targets;\n+\n+      ---------------------------------\n+      -- Number_Of_Elaboration_Roots --\n+      ---------------------------------\n+\n+      function Number_Of_Elaboration_Roots\n+        (G : Invocation_Graph) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return ER.Size (G.Roots);\n+      end Number_Of_Elaboration_Roots;\n+\n+      ------------------------\n+      -- Number_Of_Vertices --\n+      ------------------------\n+\n+      function Number_Of_Vertices (G : Invocation_Graph) return Natural is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return DG.Number_Of_Vertices (G.Graph);\n+      end Number_Of_Vertices;\n+\n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (G : Invocation_Graph) return Boolean is\n+      begin\n+         return G /= Nil;\n+      end Present;\n+\n+      --------------\n+      -- Relation --\n+      --------------\n+\n+      function Relation\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Relation_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGE_Id));\n+\n+         return Get_IGE_Attributes (G, IGE_Id).Relation;\n+      end Relation;\n+\n+      ---------------------------\n+      -- Save_Elaboration_Root --\n+      ---------------------------\n+\n+      procedure Save_Elaboration_Root\n+        (G    : Invocation_Graph;\n+         Root : Invocation_Graph_Vertex_Id)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Root));\n+\n+         ER.Insert (G.Roots, Root);\n+      end Save_Elaboration_Root;\n+\n+      ------------------------------\n+      -- Set_Corresponding_Vertex --\n+      ------------------------------\n+\n+      procedure Set_Corresponding_Vertex\n+        (G      : Invocation_Graph;\n+         IS_Id  : Invocation_Signature_Id;\n+         IGV_Id : Invocation_Graph_Vertex_Id)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IS_Id));\n+         pragma Assert (Present (IGV_Id));\n+\n+         SV.Put (G.Signature_To_Vertex, IS_Id, IGV_Id);\n+      end Set_Corresponding_Vertex;\n+\n+      --------------------------------------------\n+      -- Set_Is_Existing_Source_Target_Relation --\n+      --------------------------------------------\n+\n+      procedure Set_Is_Existing_Source_Target_Relation\n+        (G   : Invocation_Graph;\n+         Rel : Source_Target_Relation;\n+         Val : Boolean := True)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Rel.Source));\n+         pragma Assert (Present (Rel.Target));\n+\n+         if Val then\n+            ST.Insert (G.Relations, Rel);\n+         else\n+            ST.Delete (G.Relations, Rel);\n+         end if;\n+      end Set_Is_Existing_Source_Target_Relation;\n+\n+      ------------------------\n+      -- Set_IGE_Attributes --\n+      ------------------------\n+\n+      procedure Set_IGE_Attributes\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id;\n+         Val    : Invocation_Graph_Edge_Attributes)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGE_Id));\n+\n+         EA.Put (G.Edge_Attributes, IGE_Id, Val);\n+      end Set_IGE_Attributes;\n+\n+      ------------------------\n+      -- Set_IGV_Attributes --\n+      ------------------------\n+\n+      procedure Set_IGV_Attributes\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id;\n+         Val    : Invocation_Graph_Vertex_Attributes)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         VA.Put (G.Vertex_Attributes, IGV_Id, Val);\n+      end Set_IGV_Attributes;\n+\n+      ------------\n+      -- Target --\n+      ------------\n+\n+      function Target\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGE_Id));\n+\n+         return DG.Destination_Vertex (G.Graph, IGE_Id);\n+      end Target;\n+   end Invocation_Graphs;\n+\n+   --------------------\n+   -- Library_Graphs --\n+   --------------------\n+\n+   package body Library_Graphs is\n+\n+      ---------------\n+      -- Edge list --\n+      ---------------\n+\n+      package EL is new Doubly_Linked_Lists\n+        (Element_Type    => Library_Graph_Edge_Id,\n+         \"=\"             => \"=\",\n+         Destroy_Element => Destroy_Library_Graph_Edge);\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Add_Body_Before_Spec_Edge\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Edges  : EL.Doubly_Linked_List);\n+      pragma Inline (Add_Body_Before_Spec_Edge);\n+      --  Create a new edge in library graph G between vertex LGV_Id and its\n+      --  corresponding spec or body, where the body is a predecessor and the\n+      --  spec a successor. Add the edge to list Edges.\n+\n+      procedure Add_Body_Before_Spec_Edges\n+        (G     : Library_Graph;\n+         Edges : EL.Doubly_Linked_List);\n+      pragma Inline (Add_Body_Before_Spec_Edges);\n+      --  Create new edges in library graph G for all vertices and their\n+      --  corresponding specs or bodies, where the body is a predecessor\n+      --  and the spec is a successor. Add all edges to list Edges.\n+\n+      function Add_Edge_With_Return\n+        (G    : Library_Graph;\n+         Pred : Library_Graph_Vertex_Id;\n+         Succ : Library_Graph_Vertex_Id;\n+         Kind : Library_Graph_Edge_Kind) return Library_Graph_Edge_Id;\n+      pragma Inline (Add_Edge_With_Return);\n+      --  Create a new edge in library graph G with source vertex Pred and\n+      --  destination vertex Succ, and return its handle. Kind denotes the\n+      --  nature of the edge. If Pred and Succ are already related, no edge\n+      --  is created and No_Library_Graph_Edge is returned.\n+\n+      procedure Decrement_Library_Graph_Edge_Count\n+        (G    : Library_Graph;\n+         Kind : Library_Graph_Edge_Kind);\n+      pragma Inline (Decrement_Library_Graph_Edge_Count);\n+      --  Decrement the number of edges of kind King in library graph G by one\n+\n+      procedure Delete_Body_Before_Spec_Edges\n+        (G     : Library_Graph;\n+         Edges : EL.Doubly_Linked_List);\n+      pragma Inline (Delete_Body_Before_Spec_Edges);\n+      --  Delete all edges in list Edges from library graph G, that link spec\n+      --  and bodies, where the body acts as the predecessor and the spec as a\n+      --  successor.\n+\n+      procedure Delete_Edge\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id);\n+      pragma Inline (Delete_Edge);\n+      --  Delete edge LGE_Id from library graph G\n+\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation\n+              (Library_Graph_Attributes, Library_Graph);\n+\n+      function Get_Component_Attributes\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Component_Attributes;\n+      pragma Inline (Get_Component_Attributes);\n+      --  Obtain the attributes of component Comp of library graph G\n+\n+      function Get_LGE_Attributes\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id)\n+         return Library_Graph_Edge_Attributes;\n+      pragma Inline (Get_LGE_Attributes);\n+      --  Obtain the attributes of edge LGE_Id of library graph G\n+\n+      function Get_LGV_Attributes\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+         return Library_Graph_Vertex_Attributes;\n+      pragma Inline (Get_LGV_Attributes);\n+      --  Obtain the attributes of vertex LGE_Id of library graph G\n+\n+      function Has_Elaborate_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Has_Elaborate_Body);\n+      --  Determine whether vertex LGV_Id of library graph G is subject to\n+      --  pragma Elaborate_Body.\n+\n+      procedure Increment_Library_Graph_Edge_Count\n+        (G    : Library_Graph;\n+         Kind : Library_Graph_Edge_Kind);\n+      pragma Inline (Increment_Library_Graph_Edge_Count);\n+      --  Increment the number of edges of king Kind in library graph G by one\n+\n+      procedure Increment_Pending_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id);\n+      pragma Inline (Increment_Pending_Predecessors);\n+      --  Increment the number of pending precedessors component Comp of\n+      --  library graph G must wait on before it can be elaborated by one.\n+\n+      procedure Increment_Pending_Predecessors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id);\n+      pragma Inline (Increment_Pending_Predecessors);\n+      --  Increment the number of pending precedessors vertex LGV_Id of library\n+      --  graph G must wait on before it can be elaborated by one.\n+\n+      procedure Initialize_Components (G : Library_Graph);\n+      pragma Inline (Initialize_Components);\n+      --  Initialize on the initial call or re-initialize on subsequent calls\n+      --  all components of library graph G.\n+\n+      function Is_Elaborable_Vertex\n+        (G            : Library_Graph;\n+         LGV_Id       : Library_Graph_Vertex_Id;\n+         Predecessors : Natural) return Boolean;\n+      pragma Inline (Is_Elaborable_Vertex);\n+      --  Determine whether vertex LGV_Id of library graph G can be elaborated\n+      --  given that it meets number of predecessors Predecessors.\n+\n+      function Is_Existing_Predecessor_Successor_Relation\n+        (G   : Library_Graph;\n+         Rel : Predecessor_Successor_Relation) return Boolean;\n+      pragma Inline (Is_Existing_Predecessor_Successor_Relation);\n+      --  Determine whether a predecessor vertex and a successor vertex\n+      --  desctibed by relation Rel are already related in library graph G.\n+\n+      procedure Set_Component_Attributes\n+        (G    : Library_Graph;\n+         Comp : Component_Id;\n+         Val  : Component_Attributes);\n+      pragma Inline (Set_Component_Attributes);\n+      --  Set the attributes of component Comp of library graph G to value Val\n+\n+      procedure Set_Corresponding_Vertex\n+        (G    : Library_Graph;\n+         U_Id : Unit_Id;\n+         Val  : Library_Graph_Vertex_Id);\n+      pragma Inline (Set_Corresponding_Vertex);\n+      --  Associate vertex Val of library graph G with unit U_Id\n+\n+      procedure Set_Is_Existing_Predecessor_Successor_Relation\n+        (G   : Library_Graph;\n+         Rel : Predecessor_Successor_Relation;\n+         Val : Boolean := True);\n+      pragma Inline (Set_Is_Existing_Predecessor_Successor_Relation);\n+      --  Mark a a predecessor vertex and a successor vertex desctibed by\n+      --  relation Rel as already related depending on value Val.\n+\n+      procedure Set_LGE_Attributes\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id;\n+         Val    : Library_Graph_Edge_Attributes);\n+      pragma Inline (Set_LGE_Attributes);\n+      --  Set the attributes of edge LGE_Id of library graph G to value Val\n+\n+      procedure Set_LGV_Attributes\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Val    : Library_Graph_Vertex_Attributes);\n+      pragma Inline (Set_LGV_Attributes);\n+      --  Set the attributes of vertex LGV_Id of library graph G to value Val\n+\n+      procedure Update_Pending_Predecessors_Of_Components (G : Library_Graph);\n+      pragma Inline (Update_Pending_Predecessors_Of_Components);\n+      --  Update the number of pending predecessors all components of library\n+      --  graph G must wait on before they can be elaborated.\n+\n+      procedure Update_Pending_Predecessors_Of_Components\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id);\n+      pragma Inline (Update_Pending_Predecessors_Of_Components);\n+      --  Update the number of pending predecessors the component of edge\n+      --  LGE_Is's successor vertex of library graph G must wait on before\n+      --  it can be elaborated.\n+\n+      -------------------------------\n+      -- Add_Body_Before_Spec_Edge --\n+      -------------------------------\n+\n+      procedure Add_Body_Before_Spec_Edge\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Edges  : EL.Doubly_Linked_List)\n+      is\n+         LGE_Id : Library_Graph_Edge_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+         pragma Assert (EL.Present (Edges));\n+\n+         --  A vertex requires a special Body_Before_Spec edge to its\n+         --  Corresponging_Item when it either denotes a\n+         --\n+         --    * Body that completes a previous spec\n+         --\n+         --    * Spec with a completing body\n+         --\n+         --  The edge creates an intentional circularity between the spec and\n+         --  body in order to emulate a library unit, and guarantees that both\n+         --  will appear in the same component.\n+         --\n+         --  Due to the structure of the library graph, either the spec or\n+         --  the body may be visited first, yet Corresponding_Item will still\n+         --  attempt to create the Body_Before_Spec edge. This is OK because\n+         --  successor and predecessor are kept consistent in both cases, and\n+         --  Add_Edge_With_Return will prevent the creation of the second edge.\n+\n+         --  Assume that that no Body_Before_Spec is necessary\n+\n+         LGE_Id := No_Library_Graph_Edge;\n+\n+         --  A body that completes a previous spec\n+\n+         if Is_Body_With_Spec (G, LGV_Id) then\n+            LGE_Id :=\n+              Add_Edge_With_Return\n+                (G    => G,\n+                 Pred => LGV_Id,                           --  body\n+                 Succ => Corresponding_Item (G, LGV_Id),   --  spec\n+                 Kind => Body_Before_Spec_Edge);\n+\n+         --  A spec with a completing body\n+\n+         elsif Is_Spec_With_Body (G, LGV_Id) then\n+            LGE_Id :=\n+              Add_Edge_With_Return\n+                (G    => G,\n+                 Pred => Corresponding_Item (G, LGV_Id),   --  body\n+                 Succ => LGV_Id,                           --  spec\n+                 Kind => Body_Before_Spec_Edge);\n+         end if;\n+\n+         if Present (LGE_Id) then\n+            EL.Append (Edges, LGE_Id);\n+         end if;\n+      end Add_Body_Before_Spec_Edge;\n+\n+      --------------------------------\n+      -- Add_Body_Before_Spec_Edges --\n+      --------------------------------\n+\n+      procedure Add_Body_Before_Spec_Edges\n+        (G     : Library_Graph;\n+         Edges : EL.Doubly_Linked_List)\n+      is\n+         Iter   : Elaborable_Units_Iterator;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         U_Id   : Unit_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (EL.Present (Edges));\n+\n+         Iter := Iterate_Elaborable_Units;\n+         while Has_Next (Iter) loop\n+            Next (Iter, U_Id);\n+\n+            LGV_Id := Corresponding_Vertex (G, U_Id);\n+            pragma Assert (Present (LGV_Id));\n+\n+            Add_Body_Before_Spec_Edge (G, LGV_Id, Edges);\n+         end loop;\n+      end Add_Body_Before_Spec_Edges;\n+\n+      --------------\n+      -- Add_Edge --\n+      --------------\n+\n+      procedure Add_Edge\n+        (G    : Library_Graph;\n+         Pred : Library_Graph_Vertex_Id;\n+         Succ : Library_Graph_Vertex_Id;\n+         Kind : Library_Graph_Edge_Kind)\n+      is\n+         LGE_Id : Library_Graph_Edge_Id;\n+         pragma Unreferenced (LGE_Id);\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Present (Succ));\n+         pragma Assert (Kind /= No_Edge);\n+\n+         LGE_Id :=\n+           Add_Edge_With_Return\n+             (G    => G,\n+              Pred => Pred,\n+              Succ => Succ,\n+              Kind => Kind);\n+      end Add_Edge;\n+\n+      --------------------------\n+      -- Add_Edge_With_Return --\n+      --------------------------\n+\n+      function Add_Edge_With_Return\n+        (G    : Library_Graph;\n+         Pred : Library_Graph_Vertex_Id;\n+         Succ : Library_Graph_Vertex_Id;\n+         Kind : Library_Graph_Edge_Kind) return Library_Graph_Edge_Id\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Present (Succ));\n+         pragma Assert (Kind /= No_Edge);\n+\n+         Rel : constant Predecessor_Successor_Relation :=\n+                 (Predecessor => Pred,\n+                  Successor   => Succ);\n+\n+         LGE_Id : Library_Graph_Edge_Id;\n+\n+      begin\n+         --  Nothing to do when the predecessor and successor are already\n+         --  related by an edge.\n+\n+         if Is_Existing_Predecessor_Successor_Relation (G, Rel) then\n+            return No_Library_Graph_Edge;\n+         end if;\n+\n+         LGE_Id := Sequence_Next_LGE_Id;\n+\n+         --  Add the edge to the underlying graph. Note that the predecessor\n+         --  is the source of the edge because it will later need to notify\n+         --  all its successors that it has been elaborated.\n+\n+         DG.Add_Edge\n+           (G           => G.Graph,\n+            E           => LGE_Id,\n+            Source      => Pred,\n+            Destination => Succ);\n+\n+         --  Construct and save the attributes of the edge\n+\n+         Set_LGE_Attributes\n+           (G      => G,\n+            LGE_Id => LGE_Id,\n+            Val    => (Kind => Kind));\n+\n+         --  Mark the predecessor and successor as related by the new edge.\n+         --  This prevents all further attempts to link the same predecessor\n+         --  and successor.\n+\n+         Set_Is_Existing_Predecessor_Successor_Relation (G, Rel);\n+\n+         --  Update the number of pending predecessors the successor must wait\n+         --  on before it is elaborated.\n+\n+         Increment_Pending_Predecessors (G, Succ);\n+\n+         --  Update the edge statistics\n+\n+         Increment_Library_Graph_Edge_Count (G, Kind);\n+\n+         return LGE_Id;\n+      end Add_Edge_With_Return;\n+\n+      ----------------\n+      -- Add_Vertex --\n+      ----------------\n+\n+      procedure Add_Vertex\n+        (G    : Library_Graph;\n+         U_Id : Unit_Id)\n+      is\n+         LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (U_Id));\n+\n+         --  Nothing to do when the unit already has a vertex\n+\n+         if Present (Corresponding_Vertex (G, U_Id)) then\n+            return;\n+         end if;\n+\n+         LGV_Id := Sequence_Next_LGV_Id;\n+\n+         --  Add the vertex to the underlying graph\n+\n+         DG.Add_Vertex (G.Graph, LGV_Id);\n+\n+         --  Construct and save the attributes of the vertex\n+\n+         Set_LGV_Attributes\n+           (G      => G,\n+            LGV_Id => LGV_Id,\n+            Val    => (Corresponding_Item   => No_Library_Graph_Vertex,\n+                       In_Elaboration_Order => False,\n+                       Pending_Predecessors => 0,\n+                       Unit                 => U_Id));\n+\n+         --  Associate the unit with its corresponding vertex\n+\n+         Set_Corresponding_Vertex (G, U_Id, LGV_Id);\n+      end Add_Vertex;\n+\n+      ---------------\n+      -- Component --\n+      ---------------\n+\n+      function Component\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Component_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         return DG.Component (G.Graph, LGV_Id);\n+      end Component;\n+\n+      ------------------------\n+      -- Corresponding_Item --\n+      ------------------------\n+\n+      function Corresponding_Item\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         return Get_LGV_Attributes (G, LGV_Id).Corresponding_Item;\n+      end Corresponding_Item;\n+\n+      --------------------------\n+      -- Corresponding_Vertex --\n+      --------------------------\n+\n+      function Corresponding_Vertex\n+        (G    : Library_Graph;\n+         U_Id : Unit_Id) return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (U_Id));\n+\n+         return UV.Get (G.Unit_To_Vertex, U_Id);\n+      end Corresponding_Vertex;\n+\n+      ------------\n+      -- Create --\n+      ------------\n+\n+      function Create\n+        (Initial_Vertices : Positive;\n+         Initial_Edges    : Positive) return Library_Graph\n+      is\n+         G : constant Library_Graph := new Library_Graph_Attributes;\n+\n+      begin\n+         G.Component_Attributes := CA.Create (Initial_Vertices);\n+         G.Edge_Attributes      := EA.Create (Initial_Edges);\n+         G.Graph                :=\n+           DG.Create\n+             (Initial_Vertices => Initial_Vertices,\n+              Initial_Edges    => Initial_Edges);\n+         G.Relations            := PS.Create (Initial_Edges);\n+         G.Unit_To_Vertex       := UV.Create (Initial_Vertices);\n+         G.Vertex_Attributes    := VA.Create (Initial_Vertices);\n+\n+         return G;\n+      end Create;\n+\n+      ----------------------------------------\n+      -- Decrement_Library_Graph_Edge_Count --\n+      ----------------------------------------\n+\n+      procedure Decrement_Library_Graph_Edge_Count\n+        (G    : Library_Graph;\n+         Kind : Library_Graph_Edge_Kind)\n+      is\n+         pragma Assert (Present (G));\n+\n+         Count : Natural renames G.Counts (Kind);\n+\n+      begin\n+         Count := Count - 1;\n+      end Decrement_Library_Graph_Edge_Count;\n+\n+      ------------------------------------\n+      -- Decrement_Pending_Predecessors --\n+      ------------------------------------\n+\n+      procedure Decrement_Pending_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id)\n+      is\n+         Attrs : Component_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         Attrs := Get_Component_Attributes (G, Comp);\n+         Attrs.Pending_Predecessors := Attrs.Pending_Predecessors - 1;\n+         Set_Component_Attributes (G, Comp, Attrs);\n+      end Decrement_Pending_Predecessors;\n+\n+      ------------------------------------\n+      -- Decrement_Pending_Predecessors --\n+      ------------------------------------\n+\n+      procedure Decrement_Pending_Predecessors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+      is\n+         Attrs : Library_Graph_Vertex_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Attrs := Get_LGV_Attributes (G, LGV_Id);\n+         Attrs.Pending_Predecessors := Attrs.Pending_Predecessors - 1;\n+         Set_LGV_Attributes (G, LGV_Id, Attrs);\n+      end Decrement_Pending_Predecessors;\n+\n+      -----------------------------------\n+      -- Delete_Body_Before_Spec_Edges --\n+      -----------------------------------\n+\n+      procedure Delete_Body_Before_Spec_Edges\n+        (G     : Library_Graph;\n+         Edges : EL.Doubly_Linked_List)\n+      is\n+         Iter   : EL.Iterator;\n+         LGE_Id : Library_Graph_Edge_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (EL.Present (Edges));\n+\n+         Iter := EL.Iterate (Edges);\n+         while EL.Has_Next (Iter) loop\n+            EL.Next (Iter, LGE_Id);\n+            pragma Assert (Present (LGE_Id));\n+            pragma Assert (Kind (G, LGE_Id) = Body_Before_Spec_Edge);\n+\n+            Delete_Edge (G, LGE_Id);\n+         end loop;\n+      end Delete_Body_Before_Spec_Edges;\n+\n+      -----------------\n+      -- Delete_Edge --\n+      -----------------\n+\n+      procedure Delete_Edge\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         Pred : constant Library_Graph_Vertex_Id := Predecessor (G, LGE_Id);\n+         Succ : constant Library_Graph_Vertex_Id := Successor   (G, LGE_Id);\n+\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Present (Succ));\n+\n+         Rel : constant Predecessor_Successor_Relation :=\n+                 (Predecessor => Pred,\n+                  Successor   => Succ);\n+\n+      begin\n+         --  Update the edge statistics\n+\n+         Decrement_Library_Graph_Edge_Count (G, Kind (G, LGE_Id));\n+\n+         --  Update the number of pending predecessors the successor must wait\n+         --  on before it is elaborated.\n+\n+         Decrement_Pending_Predecessors (G, Succ);\n+\n+         --  Delete the link between the predecessor and successor. This allows\n+         --  for further attempts to link the same predecessor and successor.\n+\n+         PS.Delete (G.Relations, Rel);\n+\n+         --  Delete the attributes of the edge\n+\n+         EA.Delete (G.Edge_Attributes, LGE_Id);\n+\n+         --  Delete the edge from the underlying graph\n+\n+         DG.Delete_Edge (G.Graph, LGE_Id);\n+      end Delete_Edge;\n+\n+      -------------\n+      -- Destroy --\n+      -------------\n+\n+      procedure Destroy (G : in out Library_Graph) is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         CA.Destroy (G.Component_Attributes);\n+         EA.Destroy (G.Edge_Attributes);\n+         DG.Destroy (G.Graph);\n+         PS.Destroy (G.Relations);\n+         UV.Destroy (G.Unit_To_Vertex);\n+         VA.Destroy (G.Vertex_Attributes);\n+\n+         Free (G);\n+      end Destroy;\n+\n+      ----------------------------------\n+      -- Destroy_Component_Attributes --\n+      ----------------------------------\n+\n+      procedure Destroy_Component_Attributes\n+        (Attrs : in out Component_Attributes)\n+      is\n+         pragma Unreferenced (Attrs);\n+      begin\n+         null;\n+      end Destroy_Component_Attributes;\n+\n+      --------------------------------\n+      -- Destroy_Library_Graph_Edge --\n+      --------------------------------\n+\n+      procedure Destroy_Library_Graph_Edge\n+        (LGE_Id : in out Library_Graph_Edge_Id)\n+      is\n+         pragma Unreferenced (LGE_Id);\n+      begin\n+         null;\n+      end Destroy_Library_Graph_Edge;\n+\n+      -------------------------------------------\n+      -- Destroy_Library_Graph_Edge_Attributes --\n+      -------------------------------------------\n+\n+      procedure Destroy_Library_Graph_Edge_Attributes\n+        (Attrs : in out Library_Graph_Edge_Attributes)\n+      is\n+         pragma Unreferenced (Attrs);\n+      begin\n+         null;\n+      end Destroy_Library_Graph_Edge_Attributes;\n+\n+      ----------------------------------\n+      -- Destroy_Library_Graph_Vertex --\n+      ----------------------------------\n+\n+      procedure Destroy_Library_Graph_Vertex\n+        (LGV_Id : in out Library_Graph_Vertex_Id)\n+      is\n+         pragma Unreferenced (LGV_Id);\n+      begin\n+         null;\n+      end Destroy_Library_Graph_Vertex;\n+\n+      ---------------------------------------------\n+      -- Destroy_Library_Graph_Vertex_Attributes --\n+      ---------------------------------------------\n+\n+      procedure Destroy_Library_Graph_Vertex_Attributes\n+        (Attrs : in out Library_Graph_Vertex_Attributes)\n+      is\n+         pragma Unreferenced (Attrs);\n+      begin\n+         null;\n+      end Destroy_Library_Graph_Vertex_Attributes;\n+\n+      ---------------------\n+      -- Find_Components --\n+      ---------------------\n+\n+      procedure Find_Components (G : Library_Graph) is\n+         Edges : EL.Doubly_Linked_List;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Initialize or reinitialize the components of the graph\n+\n+         Initialize_Components (G);\n+\n+         --  Create a set of special edges that link a predecessor body with a\n+         --  successor spec. This is an illegal dependency, however using such\n+         --  edges eliminates the need to create yet another graph, where both\n+         --  spec and body are collapsed into a single vertex.\n+\n+         Edges := EL.Create;\n+         Add_Body_Before_Spec_Edges (G, Edges);\n+\n+         DG.Find_Components (G.Graph);\n+\n+         --  Remove the special edges that link a predecessor body with a\n+         --  successor spec because they cause unresolvable circularities.\n+\n+         Delete_Body_Before_Spec_Edges (G, Edges);\n+         EL.Destroy (Edges);\n+\n+         --  Update the number of predecessors various components must wait on\n+         --  before they can be elaborated.\n+\n+         Update_Pending_Predecessors_Of_Components (G);\n+      end Find_Components;\n+\n+      ------------------------------\n+      -- Get_Component_Attributes --\n+      ------------------------------\n+\n+      function Get_Component_Attributes\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Component_Attributes\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         return CA.Get (G.Component_Attributes, Comp);\n+      end Get_Component_Attributes;\n+\n+      ------------------------\n+      -- Get_LGE_Attributes --\n+      ------------------------\n+\n+      function Get_LGE_Attributes\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id)\n+         return Library_Graph_Edge_Attributes\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         return EA.Get (G.Edge_Attributes, LGE_Id);\n+      end Get_LGE_Attributes;\n+\n+      ------------------------\n+      -- Get_LGV_Attributes --\n+      ------------------------\n+\n+      function Get_LGV_Attributes\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+         return Library_Graph_Vertex_Attributes\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         return VA.Get (G.Vertex_Attributes, LGV_Id);\n+      end Get_LGV_Attributes;\n+\n+      ------------------------\n+      -- Has_Elaborate_Body --\n+      ------------------------\n+\n+      function Has_Elaborate_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         return U_Rec.Elaborate_Body;\n+      end Has_Elaborate_Body;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : All_Edge_Iterator) return Boolean is\n+      begin\n+         return DG.Has_Next (DG.All_Edge_Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : All_Vertex_Iterator) return Boolean is\n+      begin\n+         return DG.Has_Next (DG.All_Vertex_Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Component_Iterator) return Boolean is\n+      begin\n+         return DG.Has_Next (DG.Component_Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Component_Vertex_Iterator) return Boolean is\n+      begin\n+         return DG.Has_Next (DG.Component_Vertex_Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Edges_To_Successors_Iterator) return Boolean is\n+      begin\n+         return DG.Has_Next (DG.Outgoing_Edge_Iterator (Iter));\n+      end Has_Next;\n+\n+      -----------------------------------------\n+      -- Hash_Predecessor_Successor_Relation --\n+      -----------------------------------------\n+\n+      function Hash_Predecessor_Successor_Relation\n+        (Rel : Predecessor_Successor_Relation) return Bucket_Range_Type\n+      is\n+      begin\n+         pragma Assert (Present (Rel.Predecessor));\n+         pragma Assert (Present (Rel.Successor));\n+\n+         return\n+           Hash_Two_Keys\n+             (Bucket_Range_Type (Rel.Predecessor),\n+              Bucket_Range_Type (Rel.Successor));\n+      end Hash_Predecessor_Successor_Relation;\n+\n+      --------------------------\n+      -- In_Elaboration_Order --\n+      --------------------------\n+\n+      function In_Elaboration_Order\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         return Get_LGV_Attributes (G, LGV_Id).In_Elaboration_Order;\n+      end In_Elaboration_Order;\n+\n+      ----------------------------------------\n+      -- Increment_Library_Graph_Edge_Count --\n+      ----------------------------------------\n+\n+      procedure Increment_Library_Graph_Edge_Count\n+        (G    : Library_Graph;\n+         Kind : Library_Graph_Edge_Kind)\n+      is\n+         pragma Assert (Present (G));\n+\n+         Count : Natural renames G.Counts (Kind);\n+\n+      begin\n+         Count := Count + 1;\n+      end Increment_Library_Graph_Edge_Count;\n+\n+      ------------------------------------\n+      -- Increment_Pending_Predecessors --\n+      ------------------------------------\n+\n+      procedure Increment_Pending_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id)\n+      is\n+         Attrs : Component_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         Attrs := Get_Component_Attributes (G, Comp);\n+         Attrs.Pending_Predecessors := Attrs.Pending_Predecessors + 1;\n+         Set_Component_Attributes (G, Comp, Attrs);\n+      end Increment_Pending_Predecessors;\n+\n+      ------------------------------------\n+      -- Increment_Pending_Predecessors --\n+      ------------------------------------\n+\n+      procedure Increment_Pending_Predecessors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+      is\n+         Attrs : Library_Graph_Vertex_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Attrs := Get_LGV_Attributes (G, LGV_Id);\n+         Attrs.Pending_Predecessors := Attrs.Pending_Predecessors + 1;\n+         Set_LGV_Attributes (G, LGV_Id, Attrs);\n+      end Increment_Pending_Predecessors;\n+\n+      ---------------------------\n+      -- Initialize_Components --\n+      ---------------------------\n+\n+      procedure Initialize_Components (G : Library_Graph) is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  The graph already contains a set of components. Reinitialize\n+         --  them in order to accomodate the new set of components about to\n+         --  be computed.\n+\n+         if Number_Of_Components (G) > 0 then\n+            CA.Destroy (G.Component_Attributes);\n+            G.Component_Attributes := CA.Create (Number_Of_Vertices (G));\n+         end if;\n+      end Initialize_Components;\n+\n+      -------------\n+      -- Is_Body --\n+      -------------\n+\n+      function Is_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         return U_Rec.Utype = Is_Body or else U_Rec.Utype = Is_Body_Only;\n+      end Is_Body;\n+\n+      -----------------------------------------\n+      -- Is_Body_Of_Spec_With_Elaborate_Body --\n+      -----------------------------------------\n+\n+      function Is_Body_Of_Spec_With_Elaborate_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         Spec_LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         if Is_Body_With_Spec (G, LGV_Id) then\n+            Spec_LGV_Id := Proper_Spec (G, LGV_Id);\n+            pragma Assert (Present (Spec_LGV_Id));\n+\n+            return Is_Spec_With_Elaborate_Body (G, Spec_LGV_Id);\n+         end if;\n+\n+         return False;\n+      end Is_Body_Of_Spec_With_Elaborate_Body;\n+\n+      -----------------------\n+      -- Is_Body_With_Spec --\n+      -----------------------\n+\n+      function Is_Body_With_Spec\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         return U_Rec.Utype = Is_Body;\n+      end Is_Body_With_Spec;\n+\n+      -----------------------------\n+      -- Is_Elaborable_Component --\n+      -----------------------------\n+\n+      function Is_Elaborable_Component\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         --  A component can be elaborated when\n+         --\n+         --    * The component is no longer wanting on any of its predecessors\n+         --      to be elaborated.\n+\n+         return Pending_Predecessors (G, Comp) = 0;\n+      end Is_Elaborable_Component;\n+\n+      --------------------------\n+      -- Is_Elaborable_Vertex --\n+      --------------------------\n+\n+      function Is_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         Check_LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Check_LGV_Id := LGV_Id;\n+\n+         --  A spec-body pair where the spec carries pragma Elaborate_Body must\n+         --  be treated as one vertex for elaboration purposes. Use the spec as\n+         --  the point of reference for the composite vertex.\n+\n+         if Is_Body_Of_Spec_With_Elaborate_Body (G, Check_LGV_Id) then\n+            Check_LGV_Id := Proper_Spec (G, Check_LGV_Id);\n+            pragma Assert (Present (Check_LGV_Id));\n+         end if;\n+\n+         return\n+           Is_Elaborable_Vertex\n+             (G            => G,\n+              LGV_Id       => Check_LGV_Id,\n+              Predecessors => 0);\n+      end Is_Elaborable_Vertex;\n+\n+      --------------------------\n+      -- Is_Elaborable_Vertex --\n+      --------------------------\n+\n+      function Is_Elaborable_Vertex\n+        (G            : Library_Graph;\n+         LGV_Id       : Library_Graph_Vertex_Id;\n+         Predecessors : Natural) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Comp : constant Component_Id := Component (G, LGV_Id);\n+\n+         pragma Assert (Present (Comp));\n+\n+         Body_LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         --  The vertex must not be re-elaborated once it has been elaborated\n+\n+         if In_Elaboration_Order (G, LGV_Id) then\n+            return False;\n+\n+         --  The vertex must not be waiting on more precedessors than requested\n+         --  to be elaborated.\n+\n+         elsif Pending_Predecessors (G, LGV_Id) /= Predecessors then\n+            return False;\n+\n+         --  The component where the vertex resides must not be waiting on any\n+         --  of its precedessors to be elaborated.\n+\n+         elsif not Is_Elaborable_Component (G, Comp) then\n+            return False;\n+\n+         --  The vertex denotes a spec with a completing body, and is subject\n+         --  to pragma Elaborate_Body. The body must be elaborable for the\n+         --  vertex to be elaborated. Account for the sole predecessor of the\n+         --  body which is the vertex itself.\n+\n+         elsif Is_Spec_With_Elaborate_Body (G, LGV_Id) then\n+            Body_LGV_Id := Proper_Body (G, LGV_Id);\n+            pragma Assert (Present (Body_LGV_Id));\n+\n+            return\n+              Is_Elaborable_Vertex\n+                (G            => G,\n+                 LGV_Id       => Body_LGV_Id,\n+                 Predecessors => 1);\n+         end if;\n+\n+         --  At this point it is known that the vertex can be elaborated\n+\n+         return True;\n+      end Is_Elaborable_Vertex;\n+\n+      ------------------------------------------------\n+      -- Is_Existing_Predecessor_Successor_Relation --\n+      ------------------------------------------------\n+\n+      function Is_Existing_Predecessor_Successor_Relation\n+        (G   : Library_Graph;\n+         Rel : Predecessor_Successor_Relation) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Rel.Predecessor));\n+         pragma Assert (Present (Rel.Successor));\n+\n+         return PS.Contains (G.Relations, Rel);\n+      end Is_Existing_Predecessor_Successor_Relation;\n+\n+      ----------------------\n+      -- Is_Internal_Unit --\n+      ----------------------\n+\n+      function Is_Internal_Unit\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         return U_Rec.Internal;\n+      end Is_Internal_Unit;\n+\n+      ------------------------\n+      -- Is_Predefined_Unit --\n+      ------------------------\n+\n+      function Is_Predefined_Unit\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         return U_Rec.Predefined;\n+      end Is_Predefined_Unit;\n+\n+      ---------------------------\n+      -- Is_Preelaborated_Unit --\n+      ---------------------------\n+\n+      function Is_Preelaborated_Unit\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         return U_Rec.Preelab or else U_Rec.Pure;\n+      end Is_Preelaborated_Unit;\n+\n+      -------------\n+      -- Is_Spec --\n+      -------------\n+\n+      function Is_Spec\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         return U_Rec.Utype = Is_Spec or else U_Rec.Utype = Is_Spec_Only;\n+      end Is_Spec;\n+\n+      -----------------------\n+      -- Is_Spec_With_Body --\n+      -----------------------\n+\n+      function Is_Spec_With_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         return U_Rec.Utype = Is_Spec;\n+      end Is_Spec_With_Body;\n+\n+      ---------------------------------\n+      -- Is_Spec_With_Elaborate_Body --\n+      ---------------------------------\n+\n+      function Is_Spec_With_Elaborate_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         return\n+           Is_Spec_With_Body (G, LGV_Id)\n+             and then Has_Elaborate_Body (G, LGV_Id);\n+      end Is_Spec_With_Elaborate_Body;\n+\n+      -----------------------\n+      -- Iterate_All_Edges --\n+      -----------------------\n+\n+      function Iterate_All_Edges\n+        (G : Library_Graph) return All_Edge_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return All_Edge_Iterator (DG.Iterate_All_Edges (G.Graph));\n+      end Iterate_All_Edges;\n+\n+      --------------------------\n+      -- Iterate_All_Vertices --\n+      --------------------------\n+\n+      function Iterate_All_Vertices\n+        (G : Library_Graph) return All_Vertex_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return All_Vertex_Iterator (DG.Iterate_All_Vertices (G.Graph));\n+      end Iterate_All_Vertices;\n+\n+      ------------------------\n+      -- Iterate_Components --\n+      ------------------------\n+\n+      function Iterate_Components\n+        (G : Library_Graph) return Component_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return Component_Iterator (DG.Iterate_Components (G.Graph));\n+      end Iterate_Components;\n+\n+      --------------------------------\n+      -- Iterate_Component_Vertices --\n+      --------------------------------\n+\n+      function Iterate_Component_Vertices\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Component_Vertex_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         return\n+           Component_Vertex_Iterator\n+             (DG.Iterate_Component_Vertices (G.Graph, Comp));\n+      end Iterate_Component_Vertices;\n+\n+      ---------------------------------\n+      -- Iterate_Edges_To_Successors --\n+      ---------------------------------\n+\n+      function Iterate_Edges_To_Successors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+         return Edges_To_Successors_Iterator\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         return\n+           Edges_To_Successors_Iterator\n+             (DG.Iterate_Outgoing_Edges (G.Graph, LGV_Id));\n+      end Iterate_Edges_To_Successors;\n+\n+      ----------\n+      -- Kind --\n+      ----------\n+\n+      function Kind\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Edge_Kind\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         return Get_LGE_Attributes (G, LGE_Id).Kind;\n+      end Kind;\n+\n+      ------------------------------\n+      -- Library_Graph_Edge_Count --\n+      ------------------------------\n+\n+      function Library_Graph_Edge_Count\n+        (G    : Library_Graph;\n+         Kind : Library_Graph_Edge_Kind) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return G.Counts (Kind);\n+      end Library_Graph_Edge_Count;\n+\n+      --------------------------------------\n+      -- Links_Vertices_In_Same_Component --\n+      --------------------------------------\n+\n+      function Links_Vertices_In_Same_Component\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         Pred : constant Library_Graph_Vertex_Id := Predecessor (G, LGE_Id);\n+         Succ : constant Library_Graph_Vertex_Id := Successor   (G, LGE_Id);\n+\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Present (Succ));\n+\n+         Pred_Comp : constant Component_Id := Component (G, Pred);\n+         Succ_Comp : constant Component_Id := Component (G, Succ);\n+\n+         pragma Assert (Present (Pred_Comp));\n+         pragma Assert (Present (Succ_Comp));\n+\n+      begin\n+         return Pred_Comp = Succ_Comp;\n+      end Links_Vertices_In_Same_Component;\n+\n+      ----------\n+      -- Name --\n+      ----------\n+\n+      function Name\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Unit_Name_Type\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+      begin\n+         return Name (U_Id);\n+      end Name;\n+\n+      -----------------------\n+      -- Needs_Elaboration --\n+      -----------------------\n+\n+      function Needs_Elaboration\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+      begin\n+         return Needs_Elaboration (U_Id);\n+      end Needs_Elaboration;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter   : in out All_Edge_Iterator;\n+         LGE_Id : out Library_Graph_Edge_Id)\n+      is\n+      begin\n+         DG.Next (DG.All_Edge_Iterator (Iter), LGE_Id);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter   : in out All_Vertex_Iterator;\n+         LGV_Id : out Library_Graph_Vertex_Id)\n+      is\n+      begin\n+         DG.Next (DG.All_Vertex_Iterator (Iter), LGV_Id);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter : in out Component_Iterator;\n+         Comp : out Component_Id)\n+      is\n+      begin\n+         DG.Next (DG.Component_Iterator (Iter), Comp);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter   : in out Edges_To_Successors_Iterator;\n+         LGE_Id : out Library_Graph_Edge_Id)\n+      is\n+      begin\n+         DG.Next (DG.Outgoing_Edge_Iterator (Iter), LGE_Id);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter   : in out Component_Vertex_Iterator;\n+         LGV_Id : out Library_Graph_Vertex_Id)\n+      is\n+      begin\n+         DG.Next (DG.Component_Vertex_Iterator (Iter), LGV_Id);\n+      end Next;\n+\n+      ----------------------------------\n+      -- Number_Of_Component_Vertices --\n+      ----------------------------------\n+\n+      function Number_Of_Component_Vertices\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         return DG.Number_Of_Component_Vertices (G.Graph, Comp);\n+      end Number_Of_Component_Vertices;\n+\n+      --------------------------\n+      -- Number_Of_Components --\n+      --------------------------\n+\n+      function Number_Of_Components (G : Library_Graph) return Natural is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return DG.Number_Of_Components (G.Graph);\n+      end Number_Of_Components;\n+\n+      ---------------------\n+      -- Number_Of_Edges --\n+      ---------------------\n+\n+      function Number_Of_Edges (G : Library_Graph) return Natural is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return DG.Number_Of_Edges (G.Graph);\n+      end Number_Of_Edges;\n+\n+      -----------------------------------\n+      -- Number_Of_Edges_To_Successors --\n+      -----------------------------------\n+\n+      function Number_Of_Edges_To_Successors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return DG.Number_Of_Outgoing_Edges (G.Graph, LGV_Id);\n+      end Number_Of_Edges_To_Successors;\n+\n+      ------------------------\n+      -- Number_Of_Vertices --\n+      ------------------------\n+\n+      function Number_Of_Vertices (G : Library_Graph) return Natural is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return DG.Number_Of_Vertices (G.Graph);\n+      end Number_Of_Vertices;\n+\n+      --------------------------\n+      -- Pending_Predecessors --\n+      --------------------------\n+\n+      function Pending_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         return Get_Component_Attributes (G, Comp).Pending_Predecessors;\n+      end Pending_Predecessors;\n+\n+      --------------------------\n+      -- Pending_Predecessors --\n+      --------------------------\n+\n+      function Pending_Predecessors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Natural\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         return Get_LGV_Attributes (G, LGV_Id).Pending_Predecessors;\n+      end Pending_Predecessors;\n+\n+      -----------------\n+      -- Predecessor --\n+      -----------------\n+\n+      function Predecessor\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         return DG.Source_Vertex (G.Graph, LGE_Id);\n+      end Predecessor;\n+\n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (G : Library_Graph) return Boolean is\n+      begin\n+         return G /= Nil;\n+      end Present;\n+\n+      -----------------\n+      -- Proper_Body --\n+      -----------------\n+\n+      function Proper_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         --  When the vertex denotes a spec with a completing body, return the\n+         --  body.\n+\n+         if Is_Spec_With_Body (G, LGV_Id) then\n+            return Corresponding_Item (G, LGV_Id);\n+\n+         --  Otherwise the vertex must be a body\n+\n+         else\n+            pragma Assert (Is_Body (G, LGV_Id));\n+            return LGV_Id;\n+         end if;\n+      end Proper_Body;\n+\n+      -----------------\n+      -- Proper_Spec --\n+      -----------------\n+\n+      function Proper_Spec\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         --  When the vertex denotes a body that completes a spec, return the\n+         --  spec.\n+\n+         if Is_Body_With_Spec (G, LGV_Id) then\n+            return Corresponding_Item (G, LGV_Id);\n+\n+         --  Otherwise the vertex must denote a spec\n+\n+         else\n+            pragma Assert (Is_Spec (G, LGV_Id));\n+            return LGV_Id;\n+         end if;\n+      end Proper_Spec;\n+\n+      ------------------------------\n+      -- Set_Component_Attributes --\n+      ------------------------------\n+\n+      procedure Set_Component_Attributes\n+        (G    : Library_Graph;\n+         Comp : Component_Id;\n+         Val  : Component_Attributes)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         CA.Put (G.Component_Attributes, Comp, Val);\n+      end Set_Component_Attributes;\n+\n+      ----------------------------\n+      -- Set_Corresponding_Item --\n+      ----------------------------\n+\n+      procedure Set_Corresponding_Item\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Val    : Library_Graph_Vertex_Id)\n+      is\n+         Attrs : Library_Graph_Vertex_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Attrs := Get_LGV_Attributes (G, LGV_Id);\n+         Attrs.Corresponding_Item := Val;\n+         Set_LGV_Attributes (G, LGV_Id, Attrs);\n+      end Set_Corresponding_Item;\n+\n+      ------------------------------\n+      -- Set_Corresponding_Vertex --\n+      ------------------------------\n+\n+      procedure Set_Corresponding_Vertex\n+        (G    : Library_Graph;\n+         U_Id : Unit_Id;\n+         Val  : Library_Graph_Vertex_Id)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (U_Id));\n+\n+         UV.Put (G.Unit_To_Vertex, U_Id, Val);\n+      end Set_Corresponding_Vertex;\n+\n+      ------------------------------\n+      -- Set_In_Elaboration_Order --\n+      ------------------------------\n+\n+      procedure Set_In_Elaboration_Order\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Val    : Boolean := True)\n+      is\n+         Attrs : Library_Graph_Vertex_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Attrs := Get_LGV_Attributes (G, LGV_Id);\n+         Attrs.In_Elaboration_Order := Val;\n+         Set_LGV_Attributes (G, LGV_Id, Attrs);\n+      end Set_In_Elaboration_Order;\n+\n+      ----------------------------------------------------\n+      -- Set_Is_Existing_Predecessor_Successor_Relation --\n+      ----------------------------------------------------\n+\n+      procedure Set_Is_Existing_Predecessor_Successor_Relation\n+        (G   : Library_Graph;\n+         Rel : Predecessor_Successor_Relation;\n+         Val : Boolean := True)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Rel.Predecessor));\n+         pragma Assert (Present (Rel.Successor));\n+\n+         if Val then\n+            PS.Insert (G.Relations, Rel);\n+         else\n+            PS.Delete (G.Relations, Rel);\n+         end if;\n+      end Set_Is_Existing_Predecessor_Successor_Relation;\n+\n+      ------------------------\n+      -- Set_LGE_Attributes --\n+      ------------------------\n+\n+      procedure Set_LGE_Attributes\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id;\n+         Val    : Library_Graph_Edge_Attributes)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         EA.Put (G.Edge_Attributes, LGE_Id, Val);\n+      end Set_LGE_Attributes;\n+\n+      ------------------------\n+      -- Set_LGV_Attributes --\n+      ------------------------\n+\n+      procedure Set_LGV_Attributes\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Val    : Library_Graph_Vertex_Attributes)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         VA.Put (G.Vertex_Attributes, LGV_Id, Val);\n+      end Set_LGV_Attributes;\n+\n+      ---------------\n+      -- Successor --\n+      ---------------\n+\n+      function Successor\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Vertex_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         return DG.Destination_Vertex (G.Graph, LGE_Id);\n+      end Successor;\n+\n+      ----------\n+      -- Unit --\n+      ----------\n+\n+      function Unit\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Unit_Id\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         return Get_LGV_Attributes (G, LGV_Id).Unit;\n+      end Unit;\n+\n+      -----------------------------------------------\n+      -- Update_Pending_Predecessors_Of_Components --\n+      -----------------------------------------------\n+\n+      procedure Update_Pending_Predecessors_Of_Components\n+        (G : Library_Graph)\n+      is\n+         Iter   : All_Edge_Iterator;\n+         LGE_Id : Library_Graph_Edge_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Iter := Iterate_All_Edges (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGE_Id);\n+            pragma Assert (Present (LGE_Id));\n+\n+            Update_Pending_Predecessors_Of_Components (G, LGE_Id);\n+         end loop;\n+      end Update_Pending_Predecessors_Of_Components;\n+\n+      -----------------------------------------------\n+      -- Update_Pending_Predecessors_Of_Components --\n+      -----------------------------------------------\n+\n+      procedure Update_Pending_Predecessors_Of_Components\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         Pred : constant Library_Graph_Vertex_Id := Predecessor (G, LGE_Id);\n+         Succ : constant Library_Graph_Vertex_Id := Successor   (G, LGE_Id);\n+\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Present (Succ));\n+\n+         Pred_Comp : constant Component_Id := Component (G, Pred);\n+         Succ_Comp : constant Component_Id := Component (G, Succ);\n+\n+         pragma Assert (Present (Pred_Comp));\n+         pragma Assert (Present (Succ_Comp));\n+\n+      begin\n+         --  The edge links a successor and a predecessor coming from two\n+         --  different SCCs. This indicates that the SCC of the successor\n+         --  must wait on another predecessor until it can be elaborated.\n+\n+         if Pred_Comp /= Succ_Comp then\n+            Increment_Pending_Predecessors (G, Succ_Comp);\n+         end if;\n+      end Update_Pending_Predecessors_Of_Components;\n+   end Library_Graphs;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (IGE_Id : Invocation_Graph_Edge_Id) return Boolean is\n+   begin\n+      return IGE_Id /= No_Invocation_Graph_Edge;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (IGV_Id : Invocation_Graph_Vertex_Id) return Boolean is\n+   begin\n+      return IGV_Id /= No_Invocation_Graph_Vertex;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (LGE_Id : Library_Graph_Edge_Id) return Boolean is\n+   begin\n+      return LGE_Id /= No_Library_Graph_Edge;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (LGV_Id : Library_Graph_Vertex_Id) return Boolean is\n+   begin\n+      return LGV_Id /= No_Library_Graph_Vertex;\n+   end Present;\n+\n+   --------------------------\n+   -- Sequence_Next_IGE_Id --\n+   --------------------------\n+\n+   IGE_Sequencer : Invocation_Graph_Edge_Id := First_Invocation_Graph_Edge;\n+   --  The counter for invocation graph edges. Do not directly manipulate its\n+   --  value.\n+\n+   function Sequence_Next_IGE_Id return Invocation_Graph_Edge_Id is\n+      IGE_Id : constant Invocation_Graph_Edge_Id := IGE_Sequencer;\n+\n+   begin\n+      IGE_Sequencer := IGE_Sequencer + 1;\n+      return IGE_Id;\n+   end Sequence_Next_IGE_Id;\n+\n+   --------------------------\n+   -- Sequence_Next_IGV_Id --\n+   --------------------------\n+\n+   IGV_Sequencer : Invocation_Graph_Vertex_Id := First_Invocation_Graph_Vertex;\n+   --  The counter for invocation graph vertices. Do not directly manipulate\n+   --  its value.\n+\n+   --------------------------\n+   -- Sequence_Next_IGV_Id --\n+   --------------------------\n+\n+   function Sequence_Next_IGV_Id return Invocation_Graph_Vertex_Id is\n+      IGV_Id : constant Invocation_Graph_Vertex_Id := IGV_Sequencer;\n+\n+   begin\n+      IGV_Sequencer := IGV_Sequencer + 1;\n+      return IGV_Id;\n+   end Sequence_Next_IGV_Id;\n+\n+   --------------------------\n+   -- Sequence_Next_LGE_Id --\n+   --------------------------\n+\n+   LGE_Sequencer : Library_Graph_Edge_Id := First_Library_Graph_Edge;\n+   --  The counter for library graph edges. Do not directly manipulate its\n+   --  value.\n+\n+   function Sequence_Next_LGE_Id return Library_Graph_Edge_Id is\n+      LGE_Id : constant Library_Graph_Edge_Id := LGE_Sequencer;\n+\n+   begin\n+      LGE_Sequencer := LGE_Sequencer + 1;\n+      return LGE_Id;\n+   end Sequence_Next_LGE_Id;\n+\n+   --------------------------\n+   -- Sequence_Next_LGV_Id --\n+   --------------------------\n+\n+   LGV_Sequencer : Library_Graph_Vertex_Id := First_Library_Graph_Vertex;\n+   --  The counter for library graph vertices. Do not directly manipulate its\n+   --  value.\n+\n+   function Sequence_Next_LGV_Id return Library_Graph_Vertex_Id is\n+      LGV_Id : constant Library_Graph_Vertex_Id := LGV_Sequencer;\n+\n+   begin\n+      LGV_Sequencer := LGV_Sequencer + 1;\n+      return LGV_Id;\n+   end Sequence_Next_LGV_Id;\n+\n+end Bindo.Graphs;"}, {"sha": "3f550275bdc6d5568b5bb080164a56cc167974d5", "filename": "gcc/ada/bindo-graphs.ads", "status": "added", "additions": 1248, "deletions": 0, "changes": 1248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,1248 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         B I N D O . G R A P H S                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  For full architecture, see unit Bindo.\n+\n+--  The following unit defines the various graphs used in determining the\n+--  elaboration order of units.\n+\n+with Bindo.Units; use Bindo.Units;\n+\n+with GNAT;                 use GNAT;\n+with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n+with GNAT.Graphs;          use GNAT.Graphs;\n+with GNAT.Sets;            use GNAT.Sets;\n+\n+package Bindo.Graphs is\n+\n+   ---------------------------\n+   -- Invocation graph edge --\n+   ---------------------------\n+\n+   --  The following type denotes an invocation graph edge handle\n+\n+   type Invocation_Graph_Edge_Id is new Natural;\n+   No_Invocation_Graph_Edge    : constant Invocation_Graph_Edge_Id :=\n+                                   Invocation_Graph_Edge_Id'First;\n+   First_Invocation_Graph_Edge : constant Invocation_Graph_Edge_Id :=\n+                                   No_Invocation_Graph_Edge + 1;\n+\n+   function Hash_Invocation_Graph_Edge\n+     (IGE_Id : Invocation_Graph_Edge_Id) return Bucket_Range_Type;\n+   pragma Inline (Hash_Invocation_Graph_Edge);\n+   --  Obtain the hash value of key IGE_Id\n+\n+   function Present (IGE_Id : Invocation_Graph_Edge_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether invocation graph edge IGE_Id exists\n+\n+   ------------------------------\n+   --  Invocation graph vertex --\n+   ------------------------------\n+\n+   --  The following type denotes an invocation graph vertex handle\n+\n+   type Invocation_Graph_Vertex_Id is new Natural;\n+   No_Invocation_Graph_Vertex    : constant Invocation_Graph_Vertex_Id :=\n+                                     Invocation_Graph_Vertex_Id'First;\n+   First_Invocation_Graph_Vertex : constant Invocation_Graph_Vertex_Id :=\n+                                     No_Invocation_Graph_Vertex + 1;\n+\n+   function Hash_Invocation_Graph_Vertex\n+     (IGV_Id : Invocation_Graph_Vertex_Id) return Bucket_Range_Type;\n+   pragma Inline (Hash_Invocation_Graph_Vertex);\n+   --  Obtain the hash value of key IGV_Id\n+\n+   function Present (IGV_Id : Invocation_Graph_Vertex_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether invocation graph vertex IGV_Id exists\n+\n+   ------------------------\n+   -- Library graph edge --\n+   ------------------------\n+\n+   --  The following type denotes a library graph edge handle\n+\n+   type Library_Graph_Edge_Id is new Natural;\n+   No_Library_Graph_Edge    : constant Library_Graph_Edge_Id :=\n+                                Library_Graph_Edge_Id'First;\n+   First_Library_Graph_Edge : constant Library_Graph_Edge_Id :=\n+                                No_Library_Graph_Edge + 1;\n+\n+   function Hash_Library_Graph_Edge\n+     (LGE_Id : Library_Graph_Edge_Id) return Bucket_Range_Type;\n+   pragma Inline (Hash_Library_Graph_Edge);\n+   --  Obtain the hash value of key LGE_Id\n+\n+   function Present (LGE_Id : Library_Graph_Edge_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether library graph edge LGE_Id exists\n+\n+   --------------------------\n+   -- Library graph vertex --\n+   --------------------------\n+\n+   --  The following type denotes a library graph vertex handle\n+\n+   type Library_Graph_Vertex_Id is new Natural;\n+   No_Library_Graph_Vertex    : constant Library_Graph_Vertex_Id :=\n+                                  Library_Graph_Vertex_Id'First;\n+   First_Library_Graph_Vertex : constant Library_Graph_Vertex_Id :=\n+                                  No_Library_Graph_Vertex + 1;\n+\n+   function Hash_Library_Graph_Vertex\n+     (LGV_Id : Library_Graph_Vertex_Id) return Bucket_Range_Type;\n+   pragma Inline (Hash_Library_Graph_Vertex);\n+   --  Obtain the hash value of key LGV_Id\n+\n+   function Present (LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether library graph vertex LGV_Id exists\n+\n+   -----------------------\n+   -- Invocation_Graphs --\n+   -----------------------\n+\n+   package Invocation_Graphs is\n+\n+      -----------\n+      -- Graph --\n+      -----------\n+\n+      --  The following type denotes an invocation graph handle. Each instance\n+      --  must be created using routine Create.\n+\n+      type Invocation_Graph is private;\n+      Nil : constant Invocation_Graph;\n+\n+      ----------------------\n+      -- Graph operations --\n+      ----------------------\n+\n+      procedure Add_Edge\n+        (G      : Invocation_Graph;\n+         Source : Invocation_Graph_Vertex_Id;\n+         Target : Invocation_Graph_Vertex_Id;\n+         IR_Id  : Invocation_Relation_Id);\n+      pragma Inline (Add_Edge);\n+      --  Create a new edge in invocation graph G with source vertex Source and\n+      --  destination vertex Target. IR_Id is the invocation relation the edge\n+      --  describes.\n+\n+      procedure Add_Vertex\n+        (G      : Invocation_Graph;\n+         IC_Id  : Invocation_Construct_Id;\n+         LGV_Id : Library_Graph_Vertex_Id);\n+      pragma Inline (Add_Vertex);\n+      --  Create a new vertex in invocation graph G. IC_Id is the invocation\n+      --  construct the vertex describes. LGV_Id is the library graph vertex\n+      --  where the invocation construct appears.\n+\n+      function Create\n+        (Initial_Vertices : Positive;\n+         Initial_Edges    : Positive) return Invocation_Graph;\n+      pragma Inline (Create);\n+      --  Create a new empty graph with vertex capacity Initial_Vertices and\n+      --  edge capacity Initial_Edges.\n+\n+      procedure Destroy (G : in out Invocation_Graph);\n+      pragma Inline (Destroy);\n+      --  Destroy the contents of invocation graph G, rendering it unusable\n+\n+      function Present (G : Invocation_Graph) return Boolean;\n+      pragma Inline (Present);\n+      --  Determine whether invocation graph G exists\n+\n+      -----------------------\n+      -- Vertex attributes --\n+      -----------------------\n+\n+      function Construct\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Invocation_Construct_Id;\n+      pragma Inline (Construct);\n+      --  Obtain the invocation construct vertex IGV_Id of invocation graph G\n+      --  describes.\n+\n+      function Corresponding_Vertex\n+        (G     : Invocation_Graph;\n+         IS_Id : Invocation_Signature_Id) return Invocation_Graph_Vertex_Id;\n+      pragma Inline (Corresponding_Vertex);\n+      --  Obtain the vertex of invocation graph G that corresponds to signature\n+      --  IS_Id.\n+\n+      function Lib_Vertex\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Lib_Vertex);\n+      --  Obtain the library graph vertex where vertex IGV_Id of invocation\n+      --  graph appears.\n+\n+      function Name\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Name_Id;\n+      pragma Inline (Name);\n+      --  Obtain the name of the construct vertex IGV_Id of invocation graph G\n+      --  describes.\n+\n+      ---------------------\n+      -- Edge attributes --\n+      ---------------------\n+\n+      function Kind\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Kind;\n+      pragma Inline (Kind);\n+      --  Obtain the nature of edge IGE_Id of invocation graph G\n+\n+      function Relation\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Relation_Id;\n+      pragma Inline (Relation);\n+      --  Obtain the relation edge IGE_Id of invocation graph G describes\n+\n+      function Target\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id) return Invocation_Graph_Vertex_Id;\n+      pragma Inline (Target);\n+      --  Obtain the target vertex edge IGE_Id of invocation graph G designates\n+\n+      ----------------\n+      -- Statistics --\n+      ----------------\n+\n+      function Invocation_Graph_Edge_Count\n+        (G    : Invocation_Graph;\n+         Kind : Invocation_Kind) return Natural;\n+      pragma Inline (Invocation_Graph_Edge_Count);\n+      --  Obtain the total number of edges of kind Kind in invocation graph G\n+\n+      function Number_Of_Edges (G : Invocation_Graph) return Natural;\n+      pragma Inline (Number_Of_Edges);\n+      --  Obtain the total number of edges in invocation graph G\n+\n+      function Number_Of_Edges_To_Targets\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Natural;\n+      pragma Inline (Number_Of_Edges_To_Targets);\n+      --  Obtain the total number of edges to targets vertex IGV_Id of\n+      --  invocation graph G has.\n+\n+      function Number_Of_Elaboration_Roots\n+        (G : Invocation_Graph) return Natural;\n+      pragma Inline (Number_Of_Elaboration_Roots);\n+      --  Obtain the total number of elaboration roots in invocation graph G\n+\n+      function Number_Of_Vertices (G : Invocation_Graph) return Natural;\n+      pragma Inline (Number_Of_Vertices);\n+      --  Obtain the total number of vertices in invocation graph G\n+\n+      ---------------\n+      -- Iterators --\n+      ---------------\n+\n+      --  The following type represents an iterator over all edges of an\n+      --  invocation graph.\n+\n+      type All_Edge_Iterator is private;\n+\n+      function Has_Next (Iter : All_Edge_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more edges to examine\n+\n+      function Iterate_All_Edges\n+        (G : Invocation_Graph) return All_Edge_Iterator;\n+      pragma Inline (Iterate_All_Edges);\n+      --  Obtain an iterator over all edges of invocation graph G\n+\n+      procedure Next\n+        (Iter   : in out All_Edge_Iterator;\n+         IGE_Id : out Invocation_Graph_Edge_Id);\n+      pragma Inline (Next);\n+      --  Return the current edge referenced by iterator Iter and advance to\n+      --  the next available edge.\n+\n+      --  The following type represents an iterator over all vertices of an\n+      --  invocation graph.\n+\n+      type All_Vertex_Iterator is private;\n+\n+      function Has_Next (Iter : All_Vertex_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more vertices to examine\n+\n+      function Iterate_All_Vertices\n+        (G : Invocation_Graph) return All_Vertex_Iterator;\n+      pragma Inline (Iterate_All_Vertices);\n+      --  Obtain an iterator over all vertices of invocation graph G\n+\n+      procedure Next\n+        (Iter   : in out All_Vertex_Iterator;\n+         IGV_Id : out Invocation_Graph_Vertex_Id);\n+      pragma Inline (Next);\n+      --  Return the current vertex referenced by iterator Iter and advance\n+      --  to the next available vertex.\n+\n+      --  The following type represents an iterator over all edges that reach\n+      --  targets starting from a particular source vertex.\n+\n+      type Edges_To_Targets_Iterator is private;\n+\n+      function Has_Next (Iter : Edges_To_Targets_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more edges to examine\n+\n+      function Iterate_Edges_To_Targets\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id) return Edges_To_Targets_Iterator;\n+      pragma Inline (Iterate_Edges_To_Targets);\n+      --  Obtain an iterator over all edges to targets with source vertex\n+      --  IGV_Id of invocation graph G.\n+\n+      procedure Next\n+        (Iter   : in out Edges_To_Targets_Iterator;\n+         IGE_Id : out Invocation_Graph_Edge_Id);\n+      pragma Inline (Next);\n+      --  Return the current edge referenced by iterator Iter and advance to\n+      --  the next available edge.\n+\n+      --  The following type represents an iterator over all vertices of an\n+      --  invocation graph that denote the elaboration procedure or a spec or\n+      --  a body, referred to as elaboration root.\n+\n+      type Elaboration_Root_Iterator is private;\n+\n+      function Has_Next (Iter : Elaboration_Root_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more elaboration roots to examine\n+\n+      function Iterate_Elaboration_Roots\n+        (G : Invocation_Graph) return Elaboration_Root_Iterator;\n+      pragma Inline (Iterate_Elaboration_Roots);\n+      --  Obtain an iterator over all elaboration roots of invocation graph G\n+\n+      procedure Next\n+        (Iter : in out Elaboration_Root_Iterator;\n+         Root : out Invocation_Graph_Vertex_Id);\n+      pragma Inline (Next);\n+      --  Return the current elaboration root referenced by iterator Iter and\n+      --  advance to the next available elaboration root.\n+\n+   private\n+\n+      --------------\n+      -- Vertices --\n+      --------------\n+\n+      procedure Destroy_Invocation_Graph_Vertex\n+        (IGV_Id : in out Invocation_Graph_Vertex_Id);\n+      pragma Inline (Destroy_Invocation_Graph_Vertex);\n+      --  Destroy invocation graph vertex IGV_Id\n+\n+      --  The following type represents the attributes of an invocation graph\n+      --  vertex.\n+\n+      type Invocation_Graph_Vertex_Attributes is record\n+         Construct : Invocation_Construct_Id := No_Invocation_Construct;\n+         --  Reference to the invocation construct this vertex represents\n+\n+         Lib_Vertex : Library_Graph_Vertex_Id := No_Library_Graph_Vertex;\n+         --  Reference to the library graph vertex where this vertex resides\n+      end record;\n+\n+      No_Invocation_Graph_Vertex_Attributes :\n+        constant Invocation_Graph_Vertex_Attributes :=\n+          (Construct  => No_Invocation_Construct,\n+           Lib_Vertex => No_Library_Graph_Vertex);\n+\n+      procedure Destroy_Invocation_Graph_Vertex_Attributes\n+        (Attrs : in out Invocation_Graph_Vertex_Attributes);\n+      pragma Inline (Destroy_Invocation_Graph_Vertex_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      package VA is new Dynamic_Hash_Tables\n+        (Key_Type              => Invocation_Graph_Vertex_Id,\n+         Value_Type            => Invocation_Graph_Vertex_Attributes,\n+         No_Value              => No_Invocation_Graph_Vertex_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Invocation_Graph_Vertex_Attributes,\n+         Hash                  => Hash_Invocation_Graph_Vertex);\n+\n+      -----------\n+      -- Edges --\n+      -----------\n+\n+      procedure Destroy_Invocation_Graph_Edge\n+        (IGE_Id : in out Invocation_Graph_Edge_Id);\n+      pragma Inline (Destroy_Invocation_Graph_Edge);\n+      --  Destroy invocation graph edge IGE_Id\n+\n+      --  The following type represents the attributes of an invocation graph\n+      --  edge.\n+\n+      type Invocation_Graph_Edge_Attributes is record\n+         Relation : Invocation_Relation_Id := No_Invocation_Relation;\n+         --  Reference to the invocation relation this edge represents\n+      end record;\n+\n+      No_Invocation_Graph_Edge_Attributes :\n+        constant Invocation_Graph_Edge_Attributes :=\n+          (Relation => No_Invocation_Relation);\n+\n+      procedure Destroy_Invocation_Graph_Edge_Attributes\n+        (Attrs : in out Invocation_Graph_Edge_Attributes);\n+      pragma Inline (Destroy_Invocation_Graph_Edge_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      package EA is new Dynamic_Hash_Tables\n+        (Key_Type              => Invocation_Graph_Edge_Id,\n+         Value_Type            => Invocation_Graph_Edge_Attributes,\n+         No_Value              => No_Invocation_Graph_Edge_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Invocation_Graph_Edge_Attributes,\n+         Hash                  => Hash_Invocation_Graph_Edge);\n+\n+      ---------------\n+      -- Relations --\n+      ---------------\n+\n+      --  The following type represents a relation between a source and target\n+      --  vertices.\n+\n+      type Source_Target_Relation is record\n+         Source : Invocation_Graph_Vertex_Id := No_Invocation_Graph_Vertex;\n+         --  The source vertex\n+\n+         Target : Invocation_Graph_Vertex_Id := No_Invocation_Graph_Vertex;\n+         --  The destination vertex\n+      end record;\n+\n+      No_Source_Target_Relation :\n+        constant Source_Target_Relation :=\n+          (Source => No_Invocation_Graph_Vertex,\n+           Target => No_Invocation_Graph_Vertex);\n+\n+      function Hash_Source_Target_Relation\n+        (Rel : Source_Target_Relation) return Bucket_Range_Type;\n+      pragma Inline (Hash_Source_Target_Relation);\n+      --  Obtain the hash value of key Rel\n+\n+      package ST is new Membership_Sets\n+        (Element_Type => Source_Target_Relation,\n+         \"=\"          => \"=\",\n+         Hash         => Hash_Source_Target_Relation);\n+\n+      ----------------\n+      -- Statistics --\n+      ----------------\n+\n+      type Invocation_Graph_Edge_Counts is array (Invocation_Kind) of Natural;\n+\n+      ----------------\n+      -- Signatures --\n+      ----------------\n+\n+      function Hash_Invocation_Signature\n+        (IS_Id : Invocation_Signature_Id) return Bucket_Range_Type;\n+      pragma Inline (Hash_Invocation_Signature);\n+      --  Obtain the hash value of key IS_Id\n+\n+      package SV is new Dynamic_Hash_Tables\n+        (Key_Type              => Invocation_Signature_Id,\n+         Value_Type            => Invocation_Graph_Vertex_Id,\n+         No_Value              => No_Invocation_Graph_Vertex,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Invocation_Graph_Vertex,\n+         Hash                  => Hash_Invocation_Signature);\n+\n+      -----------------------\n+      -- Elaboration roots --\n+      -----------------------\n+\n+      package ER is new Membership_Sets\n+        (Element_Type => Invocation_Graph_Vertex_Id,\n+         \"=\"          => \"=\",\n+         Hash         => Hash_Invocation_Graph_Vertex);\n+\n+      -----------\n+      -- Graph --\n+      -----------\n+\n+      package DG is new Directed_Graphs\n+        (Vertex_Id   => Invocation_Graph_Vertex_Id,\n+         No_Vertex   => No_Invocation_Graph_Vertex,\n+         Hash_Vertex => Hash_Invocation_Graph_Vertex,\n+         Same_Vertex => \"=\",\n+         Edge_id     => Invocation_Graph_Edge_Id,\n+         No_Edge     => No_Invocation_Graph_Edge,\n+         Hash_Edge   => Hash_Invocation_Graph_Edge,\n+         Same_Edge   => \"=\");\n+\n+      --  The following type represents the attributes of an invocation graph\n+\n+      type Invocation_Graph_Attributes is record\n+         Counts : Invocation_Graph_Edge_Counts := (others => 0);\n+         --  Edge statistics\n+\n+         Edge_Attributes : EA.Dynamic_Hash_Table := EA.Nil;\n+         --  The map of edge -> edge attributes for all edges in the graph\n+\n+         Graph : DG.Directed_Graph := DG.Nil;\n+         --  The underlying graph describing the relations between edges and\n+         --  vertices.\n+\n+         Relations : ST.Membership_Set := ST.Nil;\n+         --  The set of relations between source and targets, used to prevent\n+         --  duplicate edges in the graph.\n+\n+         Roots : ER.Membership_Set := ER.Nil;\n+         --  The set of elaboration root vertices\n+\n+         Signature_To_Vertex : SV.Dynamic_Hash_Table := SV.Nil;\n+         --  The map of signature -> vertex\n+\n+         Vertex_Attributes : VA.Dynamic_Hash_Table := VA.Nil;\n+         --  The map of vertex -> vertex attributes for all vertices in the\n+         --  graph.\n+      end record;\n+\n+      type Invocation_Graph is access Invocation_Graph_Attributes;\n+      Nil : constant Invocation_Graph := null;\n+\n+      ---------------\n+      -- Iterators --\n+      ---------------\n+\n+      type All_Edge_Iterator         is new DG.All_Edge_Iterator;\n+      type All_Vertex_Iterator       is new DG.All_Vertex_Iterator;\n+      type Edges_To_Targets_Iterator is new DG.Outgoing_Edge_Iterator;\n+      type Elaboration_Root_Iterator is new ER.Iterator;\n+   end Invocation_Graphs;\n+\n+   --------------------\n+   -- Library_Graphs --\n+   --------------------\n+\n+   package Library_Graphs is\n+\n+      --  The following type represents the various kinds of library edges\n+\n+      type Library_Graph_Edge_Kind is\n+        (Body_Before_Spec_Edge,\n+         --  Successor denotes spec, Predecessor denotes a body. This is a\n+         --  special edge kind used only during the discovery of components.\n+         --  Note that a body can never be elaborated before its spec.\n+\n+         Elaborate_Edge,\n+         --  Successor withs Predecessor, and has pragma Elaborate for it\n+\n+         Elaborate_All_Edge,\n+         --  Successor withs Predecessor, and has pragma Elaborate_All for it\n+\n+--       Forced_Edge,\n+         --  Successor is forced to with Predecessor by virtue of an existing\n+         --  elaboration order provided in a file.\n+\n+         Invocation_Edge,\n+         --  An invocation construct in unit Successor invokes a target in unit\n+         --  Predecessor.\n+\n+         Spec_Before_Body_Edge,\n+         --  Successor denotes a body, Predecessor denotes a spec\n+\n+         With_Edge,\n+         --  Successor withs Predecessor\n+\n+         No_Edge);\n+\n+      -----------\n+      -- Graph --\n+      -----------\n+\n+      --  The following type denotes a library graph handle. Each instance must\n+      --  be created using routine Create.\n+\n+      type Library_Graph is private;\n+      Nil : constant Library_Graph;\n+\n+      ----------------------\n+      -- Graph operations --\n+      ----------------------\n+\n+      procedure Add_Edge\n+        (G    : Library_Graph;\n+         Pred : Library_Graph_Vertex_Id;\n+         Succ : Library_Graph_Vertex_Id;\n+         Kind : Library_Graph_Edge_Kind);\n+      pragma Inline (Add_Edge);\n+      --  Create a new edge in library graph G with source vertex Pred and\n+      --  destination vertex Succ. Kind denotes the nature of the edge.\n+\n+      procedure Add_Vertex\n+        (G    : Library_Graph;\n+         U_Id : Unit_Id);\n+      pragma Inline (Add_Vertex);\n+      --  Create a new vertex in library graph G. U_Id is the unit the vertex\n+      --  describes.\n+\n+      function Create\n+        (Initial_Vertices : Positive;\n+         Initial_Edges    : Positive) return Library_Graph;\n+      pragma Inline (Create);\n+      --  Create a new empty graph with vertex capacity Initial_Vertices and\n+      --  edge capacity Initial_Edges.\n+\n+      procedure Destroy (G : in out Library_Graph);\n+      pragma Inline (Destroy);\n+      --  Destroy the contents of library graph G, rendering it unusable\n+\n+      procedure Find_Components (G : Library_Graph);\n+      pragma Inline (Find_Components);\n+      --  Find all components in library graph G\n+\n+      function Present (G : Library_Graph) return Boolean;\n+      pragma Inline (Present);\n+      --  Determine whether library graph G exists\n+\n+      -----------------------\n+      -- Vertex attributes --\n+      -----------------------\n+\n+      function Component\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Component_Id;\n+      pragma Inline (Component);\n+      --  Obtain the component where vertex LGV_Id of library graph G resides\n+\n+      function Corresponding_Item\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Corresponding_Item);\n+      --  Obtain the complementary vertex which represents the corresponding\n+      --  spec or body of vertex LGV_Id of library graph G.\n+\n+      function Corresponding_Vertex\n+        (G    : Library_Graph;\n+         U_Id : Unit_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Corresponding_Vertex);\n+      --  Obtain the corresponding vertex of library graph G which represents\n+      --  unit U_Id.\n+\n+      procedure Decrement_Pending_Predecessors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id);\n+      pragma Inline (Decrement_Pending_Predecessors);\n+      --  Decrease the number of pending predecessors vertex LGV_Id of library\n+      --  graph G must wait on until it can be elaborated.\n+\n+      function In_Elaboration_Order\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (In_Elaboration_Order);\n+      --  Determine whether vertex LGV_Id of library graph G is already in some\n+      --  elaboration order.\n+\n+      function Name\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Unit_Name_Type;\n+      pragma Inline (Name);\n+      --  Obtain the name of the unit which vertex LGV_Id of library graph G\n+      --  represents.\n+\n+      function Pending_Predecessors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Natural;\n+      pragma Inline (Pending_Predecessors);\n+      --  Obtain the number of pending predecessors vertex LGV_Id of library\n+      --  graph G must wait on until it can be elaborated.\n+\n+      procedure Set_Corresponding_Item\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Val    : Library_Graph_Vertex_Id);\n+      pragma Inline (Set_Corresponding_Item);\n+      --  Set the complementary vertex which represents the corresponding\n+      --  spec or body of vertex LGV_Id of library graph G to value Val.\n+\n+      procedure Set_In_Elaboration_Order\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+         Val    : Boolean := True);\n+      pragma Inline (Set_In_Elaboration_Order);\n+      --  Mark vertex LGV_Id of library graph G as included in some elaboration\n+      --  order depending on value Val.\n+\n+      function Unit\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Unit_Id;\n+      pragma Inline (Unit);\n+      --  Obtain the unit vertex LGV_Id of library graph G represents\n+\n+      ---------------------\n+      -- Edge attributes --\n+      ---------------------\n+\n+      function Kind\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Edge_Kind;\n+      pragma Inline (Kind);\n+      --  Obtain the nature of edge LGE_Id of library graph G\n+\n+      function Predecessor\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Predecessor);\n+      --  Obtain the predecessor vertex of edge LGE_Id of library graph G\n+\n+      function Successor\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Successor);\n+      --  Obtain the successor vertex of edge LGE_Id of library graph G\n+\n+      --------------------------\n+      -- Component attributes --\n+      --------------------------\n+\n+      procedure Decrement_Pending_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id);\n+      pragma Inline (Decrement_Pending_Predecessors);\n+      --  Decrease the number of pending predecessors component Comp of library\n+      --  graph G must wait on until it can be elaborated.\n+\n+      function Pending_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Natural;\n+      pragma Inline (Pending_Predecessors);\n+      --  Obtain the number of pending predecessors component Comp of library\n+      --  graph G must wait on until it can be elaborated.\n+\n+      ---------------\n+      -- Semantics --\n+      ---------------\n+\n+      function Is_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Body);\n+      --  Determine whether vertex LGV_Id of library graph G denotes a body\n+\n+      function Is_Body_Of_Spec_With_Elaborate_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Body_Of_Spec_With_Elaborate_Body);\n+      --  Determine whether vertex LGV_Id of library graph G denotes a body\n+      --  with a corresponding spec, and the spec has pragma Elaborate_Body.\n+\n+      function Is_Body_With_Spec\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Body_With_Spec);\n+      --  Determine whether vertex LGV_Id of library graph G denotes a body\n+      --  with a corresponding spec.\n+\n+      function Is_Elaborable_Component\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Boolean;\n+      pragma Inline (Is_Elaborable_Component);\n+      --  Determine whether component Comp of library graph G can be elaborated\n+\n+      function Is_Elaborable_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Elaborable_Vertex);\n+      --  Determine whether vertex LGV_Id of library graph G can be elaborated\n+\n+      function Is_Internal_Unit\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Internal_Unit);\n+      --  Determine whether vertex LGV_Id of library graph G denotes an\n+      --  internal unit.\n+\n+      function Is_Predefined_Unit\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Predefined_Unit);\n+      --  Determine whether vertex LGV_Id of library graph G denotes a\n+      --  predefined unit.\n+\n+      function Is_Preelaborated_Unit\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Preelaborated_Unit);\n+      --  Determine whether vertex LGV_Id of library graph G denotes a unit\n+      --  subjec to pragma Pure or Preelaborable.\n+\n+      function Is_Spec\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Spec);\n+      --  Determine whether vertex LGV_Id of library graph G denotes a spec\n+\n+      function Is_Spec_With_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Spec_With_Body);\n+      --  Determine whether vertex LGV_Id of library graph G denotes a spec\n+      --  with a corresponding body.\n+\n+      function Is_Spec_With_Elaborate_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Spec_With_Elaborate_Body);\n+      --  Determine whether vertex LGV_Id of library graph G denotes a spec\n+      --  with a corresponding body, and is subject to pragma Elaborate_Body.\n+\n+      function Links_Vertices_In_Same_Component\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) return Boolean;\n+      pragma Inline (Links_Vertices_In_Same_Component);\n+      --  Determine whether edge LGE_Id of library graph G links a predecessor\n+      --  and a successor that reside within the same component.\n+\n+      function Needs_Elaboration\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Needs_Elaboration);\n+      --  Determine whether vertex LGV_Id of library graph G represents a unit\n+      --  that needs to be elaborated.\n+\n+      function Proper_Body\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Proper_Body);\n+      --  Obtain the body of vertex LGV_Id of library graph G\n+\n+      function Proper_Spec\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Library_Graph_Vertex_Id;\n+      pragma Inline (Proper_Spec);\n+      --  Obtain the spec of vertex LGV_Id of library graph G\n+\n+      ----------------\n+      -- Statistics --\n+      ----------------\n+\n+      function Library_Graph_Edge_Count\n+        (G    : Library_Graph;\n+         Kind : Library_Graph_Edge_Kind) return Natural;\n+      pragma Inline (Library_Graph_Edge_Count);\n+      --  Obtain the total number of edges of kind Kind in library graph G\n+\n+      function Number_Of_Component_Vertices\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Natural;\n+      pragma Inline (Number_Of_Component_Vertices);\n+      --  Obtain the total number of vertices component Comp of library graph\n+      --  contains.\n+\n+      function Number_Of_Components (G : Library_Graph) return Natural;\n+      pragma Inline (Number_Of_Components);\n+      --  Obtain the total number of components in library graph G\n+\n+      function Number_Of_Edges (G : Library_Graph) return Natural;\n+      pragma Inline (Number_Of_Edges);\n+      --  Obtain the total number of edges in library graph G\n+\n+      function Number_Of_Edges_To_Successors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Natural;\n+      pragma Inline (Number_Of_Edges_To_Successors);\n+      --  Obtain the total number of edges to successors vertex LGV_Id of\n+      --  library graph G has.\n+\n+      function Number_Of_Vertices (G : Library_Graph) return Natural;\n+      pragma Inline (Number_Of_Vertices);\n+      --  Obtain the total number of vertices in library graph G\n+\n+      ---------------\n+      -- Iterators --\n+      ---------------\n+\n+      --  The following type represents an iterator over all edges of a library\n+      --  graph.\n+\n+      type All_Edge_Iterator is private;\n+\n+      function Has_Next (Iter : All_Edge_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more edges to examine\n+\n+      function Iterate_All_Edges (G : Library_Graph) return All_Edge_Iterator;\n+      pragma Inline (Iterate_All_Edges);\n+      --  Obtain an iterator over all edges of library graph G\n+\n+      procedure Next\n+        (Iter   : in out All_Edge_Iterator;\n+         LGE_Id : out Library_Graph_Edge_Id);\n+      pragma Inline (Next);\n+      --  Return the current edge referenced by iterator Iter and advance to\n+      --  the next available edge.\n+\n+      --  The following type represents an iterator over all vertices of a\n+      --  library graph.\n+\n+      type All_Vertex_Iterator is private;\n+\n+      function Has_Next (Iter : All_Vertex_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more vertices to examine\n+\n+      function Iterate_All_Vertices\n+        (G : Library_Graph) return All_Vertex_Iterator;\n+      pragma Inline (Iterate_All_Vertices);\n+      --  Obtain an iterator over all vertices of library graph G\n+\n+      procedure Next\n+        (Iter   : in out All_Vertex_Iterator;\n+         LGV_Id : out Library_Graph_Vertex_Id);\n+      pragma Inline (Next);\n+      --  Return the current vertex referenced by iterator Iter and advance\n+      --  to the next available vertex.\n+\n+      --  The following type represents an iterator over all components of a\n+      --  library graph.\n+\n+      type Component_Iterator is private;\n+\n+      function Has_Next (Iter : Component_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more components to examine\n+\n+      function Iterate_Components\n+        (G : Library_Graph) return Component_Iterator;\n+      pragma Inline (Iterate_Components);\n+      --  Obtain an iterator over all components of library graph G\n+\n+      procedure Next\n+        (Iter : in out Component_Iterator;\n+         Comp : out Component_Id);\n+      pragma Inline (Next);\n+      --  Return the current component referenced by iterator Iter and advance\n+      --  to the next available component.\n+\n+      --  The following type represents an iterator over all vertices of a\n+      --  component.\n+\n+      type Component_Vertex_Iterator is private;\n+\n+      function Has_Next (Iter : Component_Vertex_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more vertices to examine\n+\n+      function Iterate_Component_Vertices\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Component_Vertex_Iterator;\n+      pragma Inline (Iterate_Component_Vertices);\n+      --  Obtain an iterator over all vertices of component Comp of library\n+      --  graph G.\n+\n+      procedure Next\n+        (Iter   : in out Component_Vertex_Iterator;\n+         LGV_Id : out Library_Graph_Vertex_Id);\n+      pragma Inline (Next);\n+      --  Return the current vertex referenced by iterator Iter and advance\n+      --  to the next available vertex.\n+\n+      --  The following type represents an iterator over all edges that reach\n+      --  successors starting from a particular predecessor vertex.\n+\n+      type Edges_To_Successors_Iterator is private;\n+\n+      function Has_Next (Iter : Edges_To_Successors_Iterator) return Boolean;\n+      pragma Inline (Has_Next);\n+      --  Determine whether iterator Iter has more edges to examine\n+\n+      function Iterate_Edges_To_Successors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) return Edges_To_Successors_Iterator;\n+      pragma Inline (Iterate_Components);\n+      --  Obtain an iterator over all edges to successors with predecessor\n+      --  vertex LGV_Id of library graph G.\n+\n+      procedure Next\n+        (Iter   : in out Edges_To_Successors_Iterator;\n+         LGE_Id : out Library_Graph_Edge_Id);\n+      pragma Inline (Next);\n+      --  Return the current edge referenced by iterator Iter and advance to\n+      --  the next available edge.\n+\n+   private\n+\n+      --------------\n+      -- Vertices --\n+      --------------\n+\n+      procedure Destroy_Library_Graph_Vertex\n+        (LGV_Id : in out Library_Graph_Vertex_Id);\n+      pragma Inline (Destroy_Library_Graph_Vertex);\n+      --  Destroy library graph vertex LGV_Id\n+\n+      --  The following type represents the attributes of a library graph\n+      --  vertex.\n+\n+      type Library_Graph_Vertex_Attributes is record\n+         Corresponding_Item : Library_Graph_Vertex_Id :=\n+                                No_Library_Graph_Vertex;\n+         --  The reference to the corresponding spec or body. This attribute is\n+         --  set as follows:\n+         --\n+         --    * If predicate Is_Body_With_Spec is True, the reference denotes\n+         --      the corresponding spec.\n+         --\n+         --    * If predicate Is_Spec_With_Body is True, the reference denotes\n+         --      the corresponding body.\n+         --\n+         --    * Otherwise the attribute remains empty.\n+\n+         In_Elaboration_Order : Boolean := False;\n+         --  Set when this vertex is elaborated\n+\n+         Pending_Predecessors : Natural := 0;\n+         --  The number of pending predecessor vertices this vertex must wait\n+         --  on before it can be elaborated.\n+\n+         Unit : Unit_Id := No_Unit_Id;\n+         --  The reference to unit this vertex represents\n+      end record;\n+\n+      No_Library_Graph_Vertex_Attributes :\n+        constant Library_Graph_Vertex_Attributes :=\n+          (Corresponding_Item   => No_Library_Graph_Vertex,\n+           In_Elaboration_Order => False,\n+           Pending_Predecessors => 0,\n+           Unit                 => No_Unit_Id);\n+\n+      procedure Destroy_Library_Graph_Vertex_Attributes\n+        (Attrs : in out Library_Graph_Vertex_Attributes);\n+      pragma Inline (Destroy_Library_Graph_Vertex_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      package VA is new Dynamic_Hash_Tables\n+        (Key_Type              => Library_Graph_Vertex_Id,\n+         Value_Type            => Library_Graph_Vertex_Attributes,\n+         No_Value              => No_Library_Graph_Vertex_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Library_Graph_Vertex_Attributes,\n+         Hash                  => Hash_Library_Graph_Vertex);\n+\n+      -----------\n+      -- Edges --\n+      -----------\n+\n+      procedure Destroy_Library_Graph_Edge\n+        (LGE_Id : in out Library_Graph_Edge_Id);\n+      pragma Inline (Destroy_Library_Graph_Edge);\n+      --  Destroy library graph edge LGE_Id\n+\n+      --  The following type represents the attributes of a library graph edge\n+\n+      type Library_Graph_Edge_Attributes is record\n+         Kind : Library_Graph_Edge_Kind := No_Edge;\n+         --  The nature of the library graph edge\n+      end record;\n+\n+      No_Library_Graph_Edge_Attributes :\n+        constant Library_Graph_Edge_Attributes :=\n+          (Kind => No_Edge);\n+\n+      procedure Destroy_Library_Graph_Edge_Attributes\n+        (Attrs : in out Library_Graph_Edge_Attributes);\n+      pragma Inline (Destroy_Library_Graph_Edge_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      package EA is new Dynamic_Hash_Tables\n+        (Key_Type              => Library_Graph_Edge_Id,\n+         Value_Type            => Library_Graph_Edge_Attributes,\n+         No_Value              => No_Library_Graph_Edge_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Library_Graph_Edge_Attributes,\n+         Hash                  => Hash_Library_Graph_Edge);\n+\n+      ----------------\n+      -- Components --\n+      ----------------\n+\n+      --  The following type represents the attributes of a component\n+\n+      type Component_Attributes is record\n+         Pending_Predecessors : Natural := 0;\n+         --  The number of pending predecessor components this component must\n+         --  wait on before it can be elaborated.\n+      end record;\n+\n+      No_Component_Attributes : constant Component_Attributes :=\n+        (Pending_Predecessors => 0);\n+\n+      procedure Destroy_Component_Attributes\n+        (Attrs : in out Component_Attributes);\n+      pragma Inline (Destroy_Component_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      package CA is new Dynamic_Hash_Tables\n+        (Key_Type              => Component_Id,\n+         Value_Type            => Component_Attributes,\n+         No_Value              => No_Component_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Component_Attributes,\n+         Hash                  => Hash_Component);\n+\n+      ---------------\n+      -- Relations --\n+      ---------------\n+\n+      --  The following type represents a relation between a predecessor and\n+      --  successor vertices.\n+\n+      type Predecessor_Successor_Relation is record\n+         Predecessor : Library_Graph_Vertex_Id := No_Library_Graph_Vertex;\n+         --  The source vertex\n+\n+         Successor : Library_Graph_Vertex_Id := No_Library_Graph_Vertex;\n+         --  The destination vertex\n+      end record;\n+\n+      No_Predecessor_Successor_Relation :\n+        constant Predecessor_Successor_Relation :=\n+          (Predecessor => No_Library_Graph_Vertex,\n+           Successor   => No_Library_Graph_Vertex);\n+\n+      function Hash_Predecessor_Successor_Relation\n+        (Rel : Predecessor_Successor_Relation) return Bucket_Range_Type;\n+      pragma Inline (Hash_Predecessor_Successor_Relation);\n+      --  Obtain the hash value of key Rel\n+\n+      package PS is new Membership_Sets\n+        (Element_Type => Predecessor_Successor_Relation,\n+         \"=\"          => \"=\",\n+         Hash         => Hash_Predecessor_Successor_Relation);\n+\n+      ----------------\n+      -- Statistics --\n+      ----------------\n+\n+      type Library_Graph_Edge_Counts is\n+        array (Library_Graph_Edge_Kind) of Natural;\n+\n+      -----------\n+      -- Units --\n+      -----------\n+\n+      package UV is new Dynamic_Hash_Tables\n+        (Key_Type              => Unit_Id,\n+         Value_Type            => Library_Graph_Vertex_Id,\n+         No_Value              => No_Library_Graph_Vertex,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Library_Graph_Vertex,\n+         Hash                  => Hash_Unit);\n+\n+      -----------\n+      -- Graph --\n+      -----------\n+\n+      package DG is new Directed_Graphs\n+        (Vertex_Id   => Library_Graph_Vertex_Id,\n+         No_Vertex   => No_Library_Graph_Vertex,\n+         Hash_Vertex => Hash_Library_Graph_Vertex,\n+         Same_Vertex => \"=\",\n+         Edge_Id     => Library_Graph_Edge_Id,\n+         No_Edge     => No_Library_Graph_Edge,\n+         Hash_Edge   => Hash_Library_Graph_Edge,\n+         Same_Edge   => \"=\");\n+\n+      --  The following type represents the attributes of a library graph\n+\n+      type Library_Graph_Attributes is record\n+         Component_Attributes : CA.Dynamic_Hash_Table := CA.Nil;\n+         --  The map of component -> component attributes for all components in\n+         --  the graph.\n+\n+         Counts : Library_Graph_Edge_Counts := (others => 0);\n+         --  Edge statistics\n+\n+         Edge_Attributes : EA.Dynamic_Hash_Table := EA.Nil;\n+         --  The map of edge -> edge attributes for all edges in the graph\n+\n+         Graph : DG.Directed_Graph := DG.Nil;\n+         --  The underlying graph describing the relations between edges and\n+         --  vertices.\n+\n+         Relations : PS.Membership_Set := PS.Nil;\n+         --  The set of relations between successors and predecessors, used to\n+         --  prevent duplicate edges in the graph.\n+\n+         Unit_To_Vertex : UV.Dynamic_Hash_Table := UV.Nil;\n+         --  The map of unit -> vertex\n+\n+         Vertex_Attributes : VA.Dynamic_Hash_Table := VA.Nil;\n+         --  The map of vertex -> vertex attributes for all vertices in the\n+         --  graph.\n+      end record;\n+\n+      type Library_Graph is access Library_Graph_Attributes;\n+      Nil : constant Library_Graph := null;\n+\n+      ---------------\n+      -- Iterators --\n+      ---------------\n+\n+      type All_Edge_Iterator            is new DG.All_Edge_Iterator;\n+      type All_Vertex_Iterator          is new DG.All_Vertex_Iterator;\n+      type Component_Iterator           is new DG.Component_Iterator;\n+      type Component_Vertex_Iterator    is new DG.Component_Vertex_Iterator;\n+      type Edges_To_Successors_Iterator is new DG.Outgoing_Edge_Iterator;\n+   end Library_Graphs;\n+\n+end Bindo.Graphs;"}, {"sha": "04471fa8dac89bc2c5af161c4b6fda0400f56f73", "filename": "gcc/ada/bindo-units.adb", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-units.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-units.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-units.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,384 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          B I N D O . U N I T S                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Bindo.Units is\n+\n+   -------------------\n+   -- Signature set --\n+   -------------------\n+\n+   package SS is new Membership_Sets\n+     (Element_Type => Invocation_Signature_Id,\n+      \"=\"          => \"=\",\n+      Hash         => Hash_Invocation_Signature);\n+\n+   -----------------\n+   -- Global data --\n+   -----------------\n+\n+   --  The following set stores all invocation signatures that appear in\n+   --  elaborable units.\n+\n+   Elaborable_Constructs : SS.Membership_Set := SS.Nil;\n+\n+   --  The following set stores all units the need to be elaborated\n+\n+   Elaborable_Units : US.Membership_Set := US.Nil;\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   function Corresponding_Unit (Nam : Name_Id) return Unit_Id;\n+   pragma Inline (Corresponding_Unit);\n+   --  Obtain the unit which corresponds to name Nam\n+\n+   function Is_Stand_Alone_Library_Unit (U_Id : Unit_Id) return Boolean;\n+   pragma Inline (Is_Stand_Alone_Library_Unit);\n+   --  Determine whether unit U_Id is part of a stand-alone library\n+\n+   procedure Process_Invocation_Construct (IC_Id : Invocation_Construct_Id);\n+   pragma Inline (Process_Invocation_Construct);\n+   --  Process invocation construct IC_Id by adding its signature to set\n+   --  Elaborable_Constructs_Set.\n+\n+   procedure Process_Invocation_Constructs (U_Id : Unit_Id);\n+   pragma Inline (Process_Invocation_Constructs);\n+   --  Process all invocation constructs of unit U_Id for classification\n+   --  purposes.\n+\n+   procedure Process_Unit (U_Id : Unit_Id);\n+   pragma Inline (Process_Unit);\n+   --  Process unit U_Id for unit classification purposes\n+\n+   ------------------------------\n+   -- Collect_Elaborable_Units --\n+   ------------------------------\n+\n+   procedure Collect_Elaborable_Units is\n+   begin\n+      for U_Id in ALI.Units.First .. ALI.Units.Last loop\n+         Process_Unit (U_Id);\n+      end loop;\n+   end Collect_Elaborable_Units;\n+\n+   ------------------------\n+   -- Corresponding_Body --\n+   ------------------------\n+\n+   function Corresponding_Body (U_Id : Unit_Id) return Unit_Id is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      pragma Assert (U_Rec.Utype = Is_Spec);\n+      return U_Id - 1;\n+   end Corresponding_Body;\n+\n+   ------------------------\n+   -- Corresponding_Spec --\n+   ------------------------\n+\n+   function Corresponding_Spec (U_Id : Unit_Id) return Unit_Id is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      pragma Assert (U_Rec.Utype = Is_Body);\n+      return U_Id + 1;\n+   end Corresponding_Spec;\n+\n+   ------------------------\n+   -- Corresponding_Unit --\n+   ------------------------\n+\n+   function Corresponding_Unit (FNam : File_Name_Type) return Unit_Id is\n+   begin\n+      return Corresponding_Unit (Name_Id (FNam));\n+   end Corresponding_Unit;\n+\n+   ------------------------\n+   -- Corresponding_Unit --\n+   ------------------------\n+\n+   function Corresponding_Unit (Nam : Name_Id) return Unit_Id is\n+   begin\n+      return Unit_Id (Get_Name_Table_Int (Nam));\n+   end Corresponding_Unit;\n+\n+   ------------------------\n+   -- Corresponding_Unit --\n+   ------------------------\n+\n+   function Corresponding_Unit (UNam : Unit_Name_Type) return Unit_Id is\n+   begin\n+      return Corresponding_Unit (Name_Id (UNam));\n+   end Corresponding_Unit;\n+\n+   --------------------\n+   -- Finalize_Units --\n+   --------------------\n+\n+   procedure Finalize_Units is\n+   begin\n+      SS.Destroy (Elaborable_Constructs);\n+      US.Destroy (Elaborable_Units);\n+   end Finalize_Units;\n+\n+   ------------------------------\n+   -- For_Each_Elaborable_Unit --\n+   ------------------------------\n+\n+   procedure For_Each_Elaborable_Unit (Processor : Unit_Processor_Ptr) is\n+      Iter : Elaborable_Units_Iterator;\n+      U_Id : Unit_Id;\n+\n+   begin\n+      Iter := Iterate_Elaborable_Units;\n+      while Has_Next (Iter) loop\n+         Next (Iter, U_Id);\n+\n+         Processor.all (U_Id);\n+      end loop;\n+   end For_Each_Elaborable_Unit;\n+\n+   -------------------\n+   -- For_Each_Unit --\n+   -------------------\n+\n+   procedure For_Each_Unit (Processor : Unit_Processor_Ptr) is\n+   begin\n+      for U_Id in ALI.Units.First .. ALI.Units.Last loop\n+         Processor.all (U_Id);\n+      end loop;\n+   end For_Each_Unit;\n+\n+   --------------\n+   -- Has_Next --\n+   --------------\n+\n+   function Has_Next (Iter : Elaborable_Units_Iterator) return Boolean is\n+   begin\n+      return US.Has_Next (US.Iterator (Iter));\n+   end Has_Next;\n+\n+   -------------------------------\n+   -- Hash_Invocation_Signature --\n+   -------------------------------\n+\n+   function Hash_Invocation_Signature\n+     (IS_Id : Invocation_Signature_Id) return Bucket_Range_Type\n+   is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+\n+      return Bucket_Range_Type (IS_Id);\n+   end Hash_Invocation_Signature;\n+\n+   ---------------\n+   -- Hash_Unit --\n+   ---------------\n+\n+   function Hash_Unit (U_Id : Unit_Id) return Bucket_Range_Type is\n+   begin\n+      pragma Assert (Present (U_Id));\n+\n+      return Bucket_Range_Type (U_Id);\n+   end Hash_Unit;\n+\n+   ----------------------\n+   -- Initialize_Units --\n+   ----------------------\n+\n+   procedure Initialize_Units is\n+   begin\n+      Elaborable_Constructs := SS.Create (Number_Of_Units);\n+      Elaborable_Units      := US.Create (Number_Of_Units);\n+   end Initialize_Units;\n+\n+   -------------------------------\n+   -- Is_Dynamically_Elaborated --\n+   -------------------------------\n+\n+   function Is_Dynamically_Elaborated (U_Id : Unit_Id) return Boolean is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      return U_Rec.Dynamic_Elab;\n+   end Is_Dynamically_Elaborated;\n+\n+   ---------------------------------\n+   -- Is_Stand_Alone_Library_Unit --\n+   ---------------------------------\n+\n+   function Is_Stand_Alone_Library_Unit (U_Id : Unit_Id) return Boolean is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      return U_Rec.SAL_Interface;\n+   end Is_Stand_Alone_Library_Unit;\n+\n+   ------------------------------\n+   -- Iterate_Elaborable_Units --\n+   ------------------------------\n+\n+   function Iterate_Elaborable_Units return Elaborable_Units_Iterator is\n+   begin\n+      return Elaborable_Units_Iterator (US.Iterate (Elaborable_Units));\n+   end Iterate_Elaborable_Units;\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (U_Id : Unit_Id) return Unit_Name_Type is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      return U_Rec.Uname;\n+   end Name;\n+\n+   -----------------------\n+   -- Needs_Elaboration --\n+   -----------------------\n+\n+   function Needs_Elaboration\n+     (IS_Id : Invocation_Signature_Id) return Boolean\n+   is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+\n+      return SS.Contains (Elaborable_Constructs, IS_Id);\n+   end Needs_Elaboration;\n+\n+   -----------------------\n+   -- Needs_Elaboration --\n+   -----------------------\n+\n+   function Needs_Elaboration (U_Id : Unit_Id) return Boolean is\n+   begin\n+      pragma Assert (Present (U_Id));\n+\n+      return US.Contains (Elaborable_Units, U_Id);\n+   end Needs_Elaboration;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next\n+     (Iter : in out Elaborable_Units_Iterator;\n+      U_Id : out Unit_Id)\n+   is\n+   begin\n+      US.Next (US.Iterator (Iter), U_Id);\n+   end Next;\n+\n+   --------------------------------\n+   -- Number_Of_Elaborable_Units --\n+   --------------------------------\n+\n+   function Number_Of_Elaborable_Units return Natural is\n+   begin\n+      return US.Size (Elaborable_Units);\n+   end Number_Of_Elaborable_Units;\n+\n+   ---------------------\n+   -- Number_Of_Units --\n+   ---------------------\n+\n+   function Number_Of_Units return Natural is\n+   begin\n+      return Natural (ALI.Units.Last) - Natural (ALI.Units.First) + 1;\n+   end Number_Of_Units;\n+\n+   ----------------------------------\n+   -- Process_Invocation_Construct --\n+   ----------------------------------\n+\n+   procedure Process_Invocation_Construct (IC_Id : Invocation_Construct_Id) is\n+      pragma Assert (Present (IC_Id));\n+\n+      IC_Rec : Invocation_Construct_Record renames\n+                 Invocation_Constructs.Table (IC_Id);\n+      IC_Sig : constant Invocation_Signature_Id := IC_Rec.Signature;\n+\n+      pragma Assert (Present (IC_Sig));\n+\n+   begin\n+      SS.Insert (Elaborable_Constructs, IC_Sig);\n+   end Process_Invocation_Construct;\n+\n+   -----------------------------------\n+   -- Process_Invocation_Constructs --\n+   -----------------------------------\n+\n+   procedure Process_Invocation_Constructs (U_Id : Unit_Id) is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      for IC_Id in U_Rec.First_Invocation_Construct ..\n+                   U_Rec.Last_Invocation_Construct\n+      loop\n+         Process_Invocation_Construct (IC_Id);\n+      end loop;\n+   end Process_Invocation_Constructs;\n+\n+   ------------------\n+   -- Process_Unit --\n+   ------------------\n+\n+   procedure Process_Unit (U_Id : Unit_Id) is\n+   begin\n+      pragma Assert (Present (U_Id));\n+\n+      --  A stand-alone library unit must not be elaborated as part of the\n+      --  current compilation because the library already carries its own\n+      --  elaboration code.\n+\n+      if Is_Stand_Alone_Library_Unit (U_Id) then\n+         null;\n+\n+      --  Otherwise the unit needs to be elaborated. Add it to the set\n+      --  of units that require elaboration, as well as all invocation\n+      --  signatures of constructs it declares.\n+\n+      else\n+         US.Insert (Elaborable_Units, U_Id);\n+         Process_Invocation_Constructs (U_Id);\n+      end if;\n+   end Process_Unit;\n+\n+end Bindo.Units;"}, {"sha": "0c1d901035b63184e718fa9f603da638b4c6f393", "filename": "gcc/ada/bindo-units.ads", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-units.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-units.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-units.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,146 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          B I N D O . U N I T S                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  For full architecture, see unit Bindo.\n+\n+--  The following unit contains facilities to collect all elaborable units in\n+--  the bind and inspect their properties.\n+\n+with GNAT;      use GNAT;\n+with GNAT.Sets; use GNAT.Sets;\n+\n+package Bindo.Units is\n+\n+   procedure Collect_Elaborable_Units;\n+   pragma Inline (Collect_Elaborable_Units);\n+   --  Gather all units in the bind that require elaboration. The units are\n+   --  accessible via iterator Elaborable_Units_Iterator.\n+\n+   function Corresponding_Body (U_Id : Unit_Id) return Unit_Id;\n+   pragma Inline (Corresponding_Body);\n+   --  Return the body of a spec unit U_Id\n+\n+   function Corresponding_Spec (U_Id : Unit_Id) return Unit_Id;\n+   pragma Inline (Corresponding_Spec);\n+   --  Return the spec of a body unit U_Id\n+\n+   function Corresponding_Unit (FNam : File_Name_Type) return Unit_Id;\n+   pragma Inline (Corresponding_Unit);\n+   --  Obtain the unit which corresponds to name FNam\n+\n+   function Corresponding_Unit (UNam : Unit_Name_Type) return Unit_Id;\n+   pragma Inline (Corresponding_Unit);\n+   --  Obtain the unit which corresponds to name FNam\n+\n+   type Unit_Processor_Ptr is access procedure (U_Id : Unit_Id);\n+\n+   procedure For_Each_Elaborable_Unit (Processor : Unit_Processor_Ptr);\n+   pragma Inline (For_Each_Elaborable_Unit);\n+   --  Invoke Processor on each elaborable unit in the bind\n+\n+   procedure For_Each_Unit (Processor : Unit_Processor_Ptr);\n+   pragma Inline (For_Each_Unit);\n+   --  Invoke Processor on each unit in the bind\n+\n+   function Hash_Invocation_Signature\n+     (IS_Id : Invocation_Signature_Id) return Bucket_Range_Type;\n+   pragma Inline (Hash_Invocation_Signature);\n+   --  Obtain the hash value of key IS_Id\n+\n+   function Hash_Unit (U_Id : Unit_Id) return Bucket_Range_Type;\n+   pragma Inline (Hash_Unit);\n+   --  Obtain the hash value of key U_Id\n+\n+   function Is_Dynamically_Elaborated (U_Id : Unit_Id) return Boolean;\n+   pragma Inline (Is_Dynamically_Elaborated);\n+   --  Determine whether unit U_Id was compiled using the dynamic elaboration\n+   --  model.\n+\n+   function Name (U_Id : Unit_Id) return Unit_Name_Type;\n+   pragma Inline (Name);\n+   --  Obtain the name of unit U_Id\n+\n+   function Needs_Elaboration (IS_Id : Invocation_Signature_Id) return Boolean;\n+   pragma Inline (Needs_Elaboration);\n+   --  Determine whether invocation signature IS_Id belongs to a construct that\n+   --  appears in a unit which needs to be elaborated.\n+\n+   function Needs_Elaboration (U_Id : Unit_Id) return Boolean;\n+   pragma Inline (Needs_Elaboration);\n+   --  Determine whether unit U_Id needs to be elaborated\n+\n+   function Number_Of_Elaborable_Units return Natural;\n+   pragma Inline (Number_Of_Elaborable_Units);\n+   --  Obtain the number of units in the bind that need to be elaborated\n+\n+   function Number_Of_Units return Natural;\n+   pragma Inline (Number_Of_Units);\n+   --  Obtain the number of units in the bind\n+\n+   ---------------\n+   -- Iterators --\n+   ---------------\n+\n+   --  The following type represents an iterator over all units that need to be\n+   --  elaborated.\n+\n+   type Elaborable_Units_Iterator is private;\n+\n+   function Has_Next (Iter : Elaborable_Units_Iterator) return Boolean;\n+   pragma Inline (Has_Next);\n+   --  Determine whether iterator Iter has more units to examine\n+\n+   function Iterate_Elaborable_Units return Elaborable_Units_Iterator;\n+   pragma Inline (Iterate_Elaborable_Units);\n+   --  Obtain an iterator over all units that need to be elaborated\n+\n+   procedure Next\n+     (Iter : in out Elaborable_Units_Iterator;\n+      U_Id : out Unit_Id);\n+   pragma Inline (Next);\n+   --  Return the current unit referenced by iterator Iter and advance to the\n+   --  next available unit.\n+\n+   -----------------\n+   -- Maintenance --\n+   -----------------\n+\n+   procedure Finalize_Units;\n+   pragma Inline (Finalize_Units);\n+   --  Destroy the internal structures of this unit\n+\n+   procedure Initialize_Units;\n+   pragma Inline (Initialize_Units);\n+   --  Initialize the internal structures of this unit\n+\n+private\n+   package US is new Membership_Sets\n+     (Element_Type => Unit_Id,\n+      \"=\"          => \"=\",\n+      Hash         => Hash_Unit);\n+\n+   type Elaborable_Units_Iterator is new US.Iterator;\n+\n+end Bindo.Units;"}, {"sha": "54d2fc6643ab796c98fea6d8d8d0257f123102dc", "filename": "gcc/ada/bindo-validators.adb", "status": "added", "additions": 679, "deletions": 0, "changes": 679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-validators.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-validators.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-validators.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,679 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      B I N D O . V A L I D A T O R S                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;  use Debug;\n+with Output; use Output;\n+with Types;  use Types;\n+\n+with Bindo.Units; use Bindo.Units;\n+\n+with GNAT;      use GNAT;\n+with GNAT.Sets; use GNAT.Sets;\n+\n+package body Bindo.Validators is\n+\n+   ----------------------------------\n+   -- Elaboration_Order_Validators --\n+   ----------------------------------\n+\n+   package body Elaboration_Order_Validators is\n+      package US is new Membership_Sets\n+        (Element_Type => Unit_Id,\n+         \"=\"          => \"=\",\n+         Hash         => Hash_Unit);\n+      use US;\n+\n+      Has_Invalid_Data : Boolean := False;\n+      --  Flag set when the elaboration order contains invalid data\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      function Build_Elaborable_Unit_Set return Membership_Set;\n+      pragma Inline (Build_Elaborable_Unit_Set);\n+      --  Create a set from all units that need to be elaborated\n+\n+      procedure Report_Missing_Elaboration (U_Id : Unit_Id);\n+      pragma Inline (Report_Missing_Elaboration);\n+      --  Emit an error concerning unit U_Id that must be elaborated, but was\n+      --  not.\n+\n+      procedure Report_Missing_Elaborations (Set : Membership_Set);\n+      pragma Inline (Report_Missing_Elaborations);\n+      --  Emit errors on all units in set Set that must be elaborated, but were\n+      --  not.\n+\n+      procedure Report_Spurious_Elaboration (U_Id : Unit_Id);\n+      pragma Inline (Report_Spurious_Elaboration);\n+      --  Emit an error concerning unit U_Id that is incorrectly elaborated\n+\n+      procedure Validate_Unit (U_Id : Unit_Id; Elab_Set : Membership_Set);\n+      pragma Inline (Validate_Unit);\n+      --  Validate the elaboration status of unit U_Id. Elab_Set is the set of\n+      --  all units that need to be elaborated.\n+\n+      procedure Validate_Units (Order : Unit_Id_Table);\n+      pragma Inline (Validate_Units);\n+      --  Validate all units in elaboration order Order\n+\n+      procedure Write_Error (Msg : String);\n+      pragma Inline (Write_Error);\n+      --  Write error message Msg to standard output and signal that the\n+      --  elaboration order is incorrect.\n+\n+      -------------------------------\n+      -- Build_Elaborable_Unit_Set --\n+      -------------------------------\n+\n+      function Build_Elaborable_Unit_Set return Membership_Set is\n+         Iter : Elaborable_Units_Iterator;\n+         Set  : Membership_Set;\n+         U_Id : Unit_Id;\n+\n+      begin\n+         Set  := Create (Number_Of_Elaborable_Units);\n+         Iter := Iterate_Elaborable_Units;\n+         while Has_Next (Iter) loop\n+            Next (Iter, U_Id);\n+            pragma Assert (Present (U_Id));\n+\n+            Insert (Set, U_Id);\n+         end loop;\n+\n+         return Set;\n+      end Build_Elaborable_Unit_Set;\n+\n+      --------------------------------\n+      -- Report_Missing_Elaboration --\n+      --------------------------------\n+\n+      procedure Report_Missing_Elaboration (U_Id : Unit_Id) is\n+         Msg : constant String := \"Report_Missing_Elaboration\";\n+\n+      begin\n+         pragma Assert (Present (U_Id));\n+         Write_Error (Msg);\n+\n+         Write_Str  (\"unit (U_Id_\");\n+         Write_Int  (Int (U_Id));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (U_Id));\n+         Write_Str  (\" must be elaborated\");\n+         Write_Eol;\n+      end Report_Missing_Elaboration;\n+\n+      ---------------------------------\n+      -- Report_Missing_Elaborations --\n+      ---------------------------------\n+\n+      procedure Report_Missing_Elaborations (Set : Membership_Set) is\n+         Iter : Iterator;\n+         U_Id : Unit_Id;\n+\n+      begin\n+         Iter := Iterate (Set);\n+         while Has_Next (Iter) loop\n+            Next (Iter, U_Id);\n+            pragma Assert (Present (U_Id));\n+\n+            Report_Missing_Elaboration (U_Id);\n+         end loop;\n+      end Report_Missing_Elaborations;\n+\n+      ---------------------------------\n+      -- Report_Spurious_Elaboration --\n+      ---------------------------------\n+\n+      procedure Report_Spurious_Elaboration (U_Id : Unit_Id) is\n+         Msg : constant String := \"Report_Spurious_Elaboration\";\n+\n+      begin\n+         pragma Assert (Present (U_Id));\n+         Write_Error (Msg);\n+\n+         Write_Str  (\"unit (U_Id_\");\n+         Write_Int  (Int (U_Id));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (U_Id));\n+         Write_Str  (\" must not be elaborated\");\n+      end Report_Spurious_Elaboration;\n+\n+      --------------------------------\n+      -- Validate_Elaboration_Order --\n+      --------------------------------\n+\n+      procedure Validate_Elaboration_Order (Order : Unit_Id_Table) is\n+      begin\n+         --  Nothing to do when switch -d_V (validate bindo graphs and order)\n+         --  is not in effect.\n+\n+         if not Debug_Flag_Underscore_VV then\n+            return;\n+         end if;\n+\n+         Validate_Units (Order);\n+\n+         if Has_Invalid_Data then\n+            raise Invalid_Elaboration_Order;\n+         end if;\n+      end Validate_Elaboration_Order;\n+\n+      -------------------\n+      -- Validate_Unit --\n+      -------------------\n+\n+      procedure Validate_Unit (U_Id : Unit_Id; Elab_Set : Membership_Set) is\n+      begin\n+         pragma Assert (Present (U_Id));\n+\n+         --  The current unit in the elaboration order appears within the set\n+         --  of units that require elaboration. Remove it from the set.\n+\n+         if Contains (Elab_Set, U_Id) then\n+            Delete (Elab_Set, U_Id);\n+\n+         --  Otherwise the current unit in the elaboration order must not be\n+         --  elaborated.\n+\n+         else\n+            Report_Spurious_Elaboration (U_Id);\n+         end if;\n+      end Validate_Unit;\n+\n+      --------------------\n+      -- Validate_Units --\n+      --------------------\n+\n+      procedure Validate_Units (Order : Unit_Id_Table) is\n+         Elab_Set : Membership_Set;\n+\n+      begin\n+         --  Collect all units in the compilation that need to be elaborated\n+         --  in a set.\n+\n+         Elab_Set := Build_Elaborable_Unit_Set;\n+\n+         --  Validate each unit in the elaboration order against the set of\n+         --  units that need to be elaborated.\n+\n+         for Index in Unit_Id_Tables.First ..  Unit_Id_Tables.Last (Order) loop\n+            Validate_Unit\n+              (U_Id     => Order.Table (Index),\n+               Elab_Set => Elab_Set);\n+         end loop;\n+\n+         --  At this point all units that need to be elaborated should have\n+         --  been eliminated from the set. Report any units that are missing\n+         --  their elaboration.\n+\n+         Report_Missing_Elaborations (Elab_Set);\n+         Destroy (Elab_Set);\n+      end Validate_Units;\n+\n+      -----------------\n+      -- Write_Error --\n+      -----------------\n+\n+      procedure Write_Error (Msg : String) is\n+      begin\n+         Has_Invalid_Data := True;\n+\n+         Write_Str (\"ERROR: \");\n+         Write_Str (Msg);\n+         Write_Eol;\n+      end Write_Error;\n+   end Elaboration_Order_Validators;\n+\n+   ---------------------------------\n+   -- Invocation_Graph_Validators --\n+   ---------------------------------\n+\n+   package body Invocation_Graph_Validators is\n+      Has_Invalid_Data : Boolean := False;\n+      --  Flag set when the invocation graph contains invalid data\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Validate_Invocation_Graph_Edge\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id);\n+      pragma Inline (Validate_Invocation_Graph_Edge);\n+      --  Verify that the attributes of edge IGE_Id of invocation graph G are\n+      --  properly set.\n+\n+      procedure Validate_Invocation_Graph_Edges (G : Invocation_Graph);\n+      pragma Inline (Validate_Invocation_Graph_Edges);\n+      --  Verify that the attributes of all edges of invocation graph G are\n+      --  properly set.\n+\n+      procedure Validate_Invocation_Graph_Vertex\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id);\n+      pragma Inline (Validate_Invocation_Graph_Vertex);\n+      --  Verify that the attributes of vertex IGV_Id of inbocation graph G are\n+      --  properly set.\n+\n+      procedure Validate_Invocation_Graph_Vertices (G : Invocation_Graph);\n+      pragma Inline (Validate_Invocation_Graph_Vertices);\n+      --  Verify that the attributes of all vertices of invocation graph G are\n+      --  properly set.\n+\n+      procedure Write_Error (Msg : String);\n+      pragma Inline (Write_Error);\n+      --  Write error message Msg to standard output and signal that the\n+      --  invocation graph is incorrect.\n+\n+      -------------------------------\n+      -- Validate_Invocation_Graph --\n+      -------------------------------\n+\n+      procedure Validate_Invocation_Graph (G : Invocation_Graph) is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Nothing to do when switch -d_V (validate bindo graphs and order)\n+         --  is not in effect.\n+\n+         if not Debug_Flag_Underscore_VV then\n+            return;\n+         end if;\n+\n+         Validate_Invocation_Graph_Vertices (G);\n+         Validate_Invocation_Graph_Edges (G);\n+\n+         if Has_Invalid_Data then\n+            raise Invalid_Invocation_Graph;\n+         end if;\n+      end Validate_Invocation_Graph;\n+\n+      ------------------------------------\n+      -- Validate_Invocation_Graph_Edge --\n+      ------------------------------------\n+\n+      procedure Validate_Invocation_Graph_Edge\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id)\n+      is\n+         Msg : constant String := \"Validate_Invocation_Graph_Edge\";\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         if not Present (IGE_Id) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  emply invocation graph edge\");\n+            Write_Eol;\n+            Write_Eol;\n+            return;\n+         end if;\n+\n+         if not Present (Relation (G, IGE_Id)) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  invocation graph edge (IGE_Id_\");\n+            Write_Int (Int (IGE_Id));\n+            Write_Str (\") lacks Relation\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+\n+         if not Present (Target (G, IGE_Id)) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  invocation graph edge (IGE_Id_\");\n+            Write_Int (Int (IGE_Id));\n+            Write_Str (\") lacks Target\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+      end Validate_Invocation_Graph_Edge;\n+\n+      -------------------------------------\n+      -- Validate_Invocation_Graph_Edges --\n+      -------------------------------------\n+\n+      procedure Validate_Invocation_Graph_Edges (G : Invocation_Graph) is\n+         IGE_Id : Invocation_Graph_Edge_Id;\n+         Iter   : Invocation_Graphs.All_Edge_Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Iter := Iterate_All_Edges (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, IGE_Id);\n+\n+            Validate_Invocation_Graph_Edge (G, IGE_Id);\n+         end loop;\n+      end Validate_Invocation_Graph_Edges;\n+\n+      --------------------------------------\n+      -- Validate_Invocation_Graph_Vertex --\n+      --------------------------------------\n+\n+      procedure Validate_Invocation_Graph_Vertex\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id)\n+      is\n+         Msg : constant String := \"Validate_Invocation_Graph_Vertex\";\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         if not Present (IGV_Id) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  emply invocation graph vertex\");\n+            Write_Eol;\n+            Write_Eol;\n+            return;\n+         end if;\n+\n+         if not Present (Construct (G, IGV_Id)) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  invocation graph vertex (IGV_Id_\");\n+            Write_Int (Int (IGV_Id));\n+            Write_Str (\") lacks Construct\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+\n+         if not Present (Lib_Vertex (G, IGV_Id)) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  invocation graph vertex (IGV_Id_\");\n+            Write_Int (Int (IGV_Id));\n+            Write_Str (\") lacks Lib_Vertex\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+      end Validate_Invocation_Graph_Vertex;\n+\n+      ----------------------------------------\n+      -- Validate_Invocation_Graph_Vertices --\n+      ----------------------------------------\n+\n+      procedure Validate_Invocation_Graph_Vertices (G : Invocation_Graph) is\n+         IGV_Id : Invocation_Graph_Vertex_Id;\n+         Iter   : Invocation_Graphs.All_Vertex_Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Iter := Iterate_All_Vertices (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, IGV_Id);\n+\n+            Validate_Invocation_Graph_Vertex (G, IGV_Id);\n+         end loop;\n+      end Validate_Invocation_Graph_Vertices;\n+\n+      -----------------\n+      -- Write_Error --\n+      -----------------\n+\n+      procedure Write_Error (Msg : String) is\n+      begin\n+         Has_Invalid_Data := True;\n+\n+         Write_Str (\"ERROR: \");\n+         Write_Str (Msg);\n+         Write_Eol;\n+      end Write_Error;\n+   end Invocation_Graph_Validators;\n+\n+   ------------------------------\n+   -- Library_Graph_Validators --\n+   ------------------------------\n+\n+   package body Library_Graph_Validators is\n+      Has_Invalid_Data : Boolean := False;\n+      --  Flag set when the library graph contains invalid data\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Validate_Library_Graph_Edge\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id);\n+      pragma Inline (Validate_Library_Graph_Edge);\n+      --  Verify that the attributes of edge LGE_Id of library graph G are\n+      --  properly set.\n+\n+      procedure Validate_Library_Graph_Edges (G : Library_Graph);\n+      pragma Inline (Validate_Library_Graph_Edges);\n+      --  Verify that the attributes of all edges of library graph G are\n+      --  properly set.\n+\n+      procedure Validate_Library_Graph_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id);\n+      pragma Inline (Validate_Library_Graph_Vertex);\n+      --  Verify that the attributes of vertex LGV_Id of library graph G are\n+      --  properly set.\n+\n+      procedure Validate_Library_Graph_Vertices (G : Library_Graph);\n+      pragma Inline (Validate_Library_Graph_Vertices);\n+      --  Verify that the attributes of all vertices of library graph G are\n+      --  properly set.\n+\n+      procedure Write_Error (Msg : String);\n+      pragma Inline (Write_Error);\n+      --  Write error message Msg to standard output and signal that the\n+      --  library graph is incorrect.\n+\n+      ----------------------------\n+      -- Validate_Library_Graph --\n+      ----------------------------\n+\n+      procedure Validate_Library_Graph (G : Library_Graph) is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Nothing to do when switch -d_V (validate bindo graphs and order)\n+         --  is not in effect.\n+\n+         if not Debug_Flag_Underscore_VV then\n+            return;\n+         end if;\n+\n+         Validate_Library_Graph_Vertices (G);\n+         Validate_Library_Graph_Edges (G);\n+\n+         if Has_Invalid_Data then\n+            raise Invalid_Library_Graph;\n+         end if;\n+      end Validate_Library_Graph;\n+\n+      ---------------------------------\n+      -- Validate_Library_Graph_Edge --\n+      ---------------------------------\n+\n+      procedure Validate_Library_Graph_Edge\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id)\n+      is\n+         Msg : constant String := \"Validate_Library_Graph_Edge\";\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         if not Present (LGE_Id) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  emply library graph edge\");\n+            Write_Eol;\n+            Write_Eol;\n+            return;\n+         end if;\n+\n+         if Kind (G, LGE_Id) = No_Edge then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  library graph edge (LGE_Id_\");\n+            Write_Int (Int (LGE_Id));\n+            Write_Str (\") is not a valid edge\");\n+            Write_Eol;\n+            Write_Eol;\n+\n+         elsif Kind (G, LGE_Id) = Body_Before_Spec_Edge then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  library graph edge (LGE_Id_\");\n+            Write_Int (Int (LGE_Id));\n+            Write_Str (\") is a Body_Before_Spec edge\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+\n+         if not Present (Predecessor (G, LGE_Id)) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  library graph edge (LGE_Id_\");\n+            Write_Int (Int (LGE_Id));\n+            Write_Str (\") lacks Predecessor\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+\n+         if not Present (Successor (G, LGE_Id)) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  library graph edge (LGE_Id_\");\n+            Write_Int (Int (LGE_Id));\n+            Write_Str (\") lacks Successor\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+      end Validate_Library_Graph_Edge;\n+\n+      ----------------------------------\n+      -- Validate_Library_Graph_Edges --\n+      ----------------------------------\n+\n+      procedure Validate_Library_Graph_Edges (G : Library_Graph) is\n+         Iter   : Library_Graphs.All_Edge_Iterator;\n+         LGE_Id : Library_Graph_Edge_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Iter := Iterate_All_Edges (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGE_Id);\n+            pragma Assert (Present (LGE_Id));\n+\n+            Validate_Library_Graph_Edge (G, LGE_Id);\n+         end loop;\n+      end Validate_Library_Graph_Edges;\n+\n+      -----------------------------------\n+      -- Validate_Library_Graph_Vertex --\n+      -----------------------------------\n+\n+      procedure Validate_Library_Graph_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+      is\n+         Msg : constant String := \"Validate_Library_Graph_Vertex\";\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         if not Present (LGV_Id) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  empty library graph vertex\");\n+            Write_Eol;\n+            Write_Eol;\n+            return;\n+         end if;\n+\n+         if (Is_Body_With_Spec (G, LGV_Id)\n+               or else\n+             Is_Spec_With_Body (G, LGV_Id))\n+           and then not Present (Corresponding_Item (G, LGV_Id))\n+         then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  library graph vertex (LGV_Id_\");\n+            Write_Int (Int (LGV_Id));\n+            Write_Str (\") lacks Corresponding_Item\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+\n+         if not Present (Unit (G, LGV_Id)) then\n+            Write_Error (Msg);\n+\n+            Write_Str (\"  library graph vertex (LGV_Id_\");\n+            Write_Int (Int (LGV_Id));\n+            Write_Str (\") lacks Unit\");\n+            Write_Eol;\n+            Write_Eol;\n+         end if;\n+      end Validate_Library_Graph_Vertex;\n+\n+      -------------------------------------\n+      -- Validate_Library_Graph_Vertices --\n+      -------------------------------------\n+\n+      procedure Validate_Library_Graph_Vertices (G : Library_Graph) is\n+         Iter   : Library_Graphs.All_Vertex_Iterator;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Iter := Iterate_All_Vertices (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGV_Id);\n+            pragma Assert (Present (LGV_Id));\n+\n+            Validate_Library_Graph_Vertex (G, LGV_Id);\n+         end loop;\n+      end Validate_Library_Graph_Vertices;\n+\n+      -----------------\n+      -- Write_Error --\n+      -----------------\n+\n+      procedure Write_Error (Msg : String) is\n+      begin\n+         Has_Invalid_Data := True;\n+\n+         Write_Str (\"ERROR: \");\n+         Write_Str (Msg);\n+         Write_Eol;\n+      end Write_Error;\n+   end Library_Graph_Validators;\n+\n+end Bindo.Validators;"}, {"sha": "39fccc6641399d3741fc0587658567b2a4cad332", "filename": "gcc/ada/bindo-validators.ads", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-validators.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-validators.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-validators.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,95 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      B I N D O . V A L I D A T O R S                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  For full architecture, see unit Bindo.\n+\n+--  The following unit contains facilities to verify the validity of the\n+--  various graphs used in determining the elaboration order of units.\n+\n+with Bindo.Graphs;\n+use  Bindo.Graphs;\n+use  Bindo.Graphs.Invocation_Graphs;\n+use  Bindo.Graphs.Library_Graphs;\n+\n+package Bindo.Validators is\n+\n+   ----------------------------------\n+   -- Elaboration_Order_Validators --\n+   ----------------------------------\n+\n+   package Elaboration_Order_Validators is\n+      Invalid_Elaboration_Order : exception;\n+      --  Exception raised when the elaboration order contains invalid data\n+\n+      procedure Validate_Elaboration_Order (Order : Unit_Id_Table);\n+      --  Ensure that elaboration order Order meets the following requirements:\n+      --\n+      --    * All units that must be elaborated appear in the order\n+      --    * No other units appear in the order\n+      --\n+      --  Diagnose issues and raise Invalid_Elaboration_Order if this is not\n+      --  the case.\n+\n+   end Elaboration_Order_Validators;\n+\n+   ---------------------------------\n+   -- Invocation_Graph_Validators --\n+   ---------------------------------\n+\n+   package Invocation_Graph_Validators is\n+      Invalid_Invocation_Graph : exception;\n+      --  Exception raised when the invocation graph contains invalid data\n+\n+      procedure Validate_Invocation_Graph (G : Invocation_Graph);\n+      --  Ensure that invocation graph G meets the following requirements:\n+      --\n+      --    * All attributes of edges are properly set\n+      --    * All attributes of vertices are properly set\n+      --\n+      --  Diagnose issues and raise Invalid_Invocation_Graph if this is not the\n+      --  case.\n+\n+   end Invocation_Graph_Validators;\n+\n+   ------------------------------\n+   -- Library_Graph_Validators --\n+   ------------------------------\n+\n+   package Library_Graph_Validators is\n+      Invalid_Library_Graph : exception;\n+      --  Exception raised when the library graph contains invalid data\n+\n+      procedure Validate_Library_Graph (G : Library_Graph);\n+      --  Ensure that library graph G meets the following requirements:\n+      --\n+      --    * All attributes edges are properly set\n+      --    * All attributes of vertices are properly set\n+      --\n+      --  Diagnose issues and raise Invalid_Library_Graph if this is not the\n+      --  case.\n+\n+   end Library_Graph_Validators;\n+\n+end Bindo.Validators;"}, {"sha": "7450c15f8f3fef9b7834c1cf04ab2be5c1699114", "filename": "gcc/ada/bindo-writers.adb", "status": "added", "additions": 1333, "deletions": 0, "changes": 1333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-writers.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-writers.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,1333 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        B I N D O . W R I T E R S                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;  use Debug;\n+with Fname;  use Fname;\n+with Opt;    use Opt;\n+with Output; use Output;\n+\n+with Bindo.Units; use Bindo.Units;\n+\n+with GNAT;        use GNAT;\n+with GNAT.Graphs; use GNAT.Graphs;\n+with GNAT.Sets;   use GNAT.Sets;\n+\n+package body Bindo.Writers is\n+\n+   -----------------\n+   -- ALI_Writers --\n+   -----------------\n+\n+   package body ALI_Writers is\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Write_All_Units;\n+      pragma Inline (Write_All_Units);\n+      --  Write the common form of units to standard output\n+\n+      procedure Write_Invocation_Construct (IC_Id : Invocation_Construct_Id);\n+      pragma Inline (Write_Invocation_Construct);\n+      --  Write invocation construct IC_Id to standard output\n+\n+      procedure Write_Invocation_Relation (IR_Id : Invocation_Relation_Id);\n+      pragma Inline (Write_Invocation_Relation);\n+      --  Write invocation relation IR_Id to standard output\n+\n+      procedure Write_Invocation_Signature (IS_Id : Invocation_Signature_Id);\n+      pragma Inline (Write_Invocation_Signature);\n+      --  Write invocation signature IS_Id to standard output\n+\n+      procedure Write_Statistics;\n+      pragma Inline (Write_Statistics);\n+      --  Write the statistical information of units to standard output\n+\n+      procedure Write_Unit (U_Id : Unit_Id);\n+      pragma Inline (Write_Unit);\n+      --  Write the invocation constructs and relations of unit U_Id to\n+      --  standard output.\n+\n+      procedure Write_Unit_Common (U_Id : Unit_Id);\n+      pragma Inline (Write_Unit_Common);\n+      --  Write the common form of unit U_Id to standard output\n+\n+      -----------\n+      -- Debug --\n+      -----------\n+\n+      procedure pau renames Write_All_Units;\n+      pragma Unreferenced (pau);\n+\n+      procedure pu (U_Id : Unit_Id) renames Write_Unit_Common;\n+      pragma Unreferenced (pu);\n+\n+      ----------------------\n+      -- Write_ALI_Tables --\n+      ----------------------\n+\n+      procedure Write_ALI_Tables is\n+      begin\n+         --  Nothing to do when switch -d_A (output invocation tables) is not\n+         --  in effect.\n+\n+         if not Debug_Flag_Underscore_AA then\n+            return;\n+         end if;\n+\n+         Write_Str (\"ALI Tables\");\n+         Write_Eol;\n+         Write_Eol;\n+\n+         Write_Statistics;\n+         For_Each_Unit (Write_Unit'Access);\n+\n+         Write_Str (\"ALI Tables end\");\n+         Write_Eol;\n+         Write_Eol;\n+      end Write_ALI_Tables;\n+\n+      ---------------------\n+      -- Write_All_Units --\n+      ---------------------\n+\n+      procedure Write_All_Units is\n+      begin\n+         For_Each_Unit (Write_Unit_Common'Access);\n+      end Write_All_Units;\n+\n+      --------------------------------\n+      -- Write_Invocation_Construct --\n+      --------------------------------\n+\n+      procedure Write_Invocation_Construct (IC_Id : Invocation_Construct_Id) is\n+         pragma Assert (Present (IC_Id));\n+\n+         IC_Rec : Invocation_Construct_Record renames\n+                    Invocation_Constructs.Table (IC_Id);\n+\n+      begin\n+         Write_Str (\"  invocation construct (IC_Id_\");\n+         Write_Int (Int (IC_Id));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"    Kind = \");\n+         Write_Str (IC_Rec.Kind'Img);\n+         Write_Eol;\n+\n+         Write_Str (\"    Placement = \");\n+         Write_Str (IC_Rec.Placement'Img);\n+         Write_Eol;\n+\n+         Write_Invocation_Signature (IC_Rec.Signature);\n+         Write_Eol;\n+      end Write_Invocation_Construct;\n+\n+      -------------------------------\n+      -- Write_Invocation_Relation --\n+      -------------------------------\n+\n+      procedure Write_Invocation_Relation (IR_Id : Invocation_Relation_Id) is\n+         pragma Assert (Present (IR_Id));\n+\n+         IR_Rec : Invocation_Relation_Record renames\n+                    Invocation_Relations.Table (IR_Id);\n+\n+      begin\n+         Write_Str (\"  invocation relation (IR_Id_\");\n+         Write_Int (Int (IR_Id));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         if Present (IR_Rec.Extra) then\n+            Write_Str  (\"    Extra = \");\n+            Write_Name (IR_Rec.Extra);\n+         else\n+            Write_Str (\"    Extra = none\");\n+         end if;\n+\n+         Write_Eol;\n+         Write_Str (\"    Invoker\");\n+         Write_Eol;\n+\n+         Write_Invocation_Signature (IR_Rec.Invoker);\n+\n+         Write_Str (\"    Kind = \");\n+         Write_Str (IR_Rec.Kind'Img);\n+         Write_Eol;\n+\n+         Write_Str (\"    Target\");\n+         Write_Eol;\n+\n+         Write_Invocation_Signature (IR_Rec.Target);\n+         Write_Eol;\n+      end Write_Invocation_Relation;\n+\n+      --------------------------------\n+      -- Write_Invocation_Signature --\n+      --------------------------------\n+\n+      procedure Write_Invocation_Signature (IS_Id : Invocation_Signature_Id) is\n+         pragma Assert (Present (IS_Id));\n+\n+         IS_Rec : Invocation_Signature_Record renames\n+                    Invocation_Signatures.Table (IS_Id);\n+\n+      begin\n+         Write_Str (\"    Signature (IS_Id_\");\n+         Write_Int (Int (IS_Id));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"      Column = \");\n+         Write_Int (Int (IS_Rec.Column));\n+         Write_Eol;\n+\n+         Write_Str (\"      Line = \");\n+         Write_Int (Int (IS_Rec.Line));\n+         Write_Eol;\n+\n+         if Present (IS_Rec.Locations) then\n+            Write_Str  (\"      Locations = \");\n+            Write_Name (IS_Rec.Locations);\n+         else\n+            Write_Str (\"      Locations = none\");\n+         end if;\n+\n+         Write_Eol;\n+         Write_Str  (\"      Name = \");\n+         Write_Name (IS_Rec.Name);\n+         Write_Eol;\n+\n+         Write_Str  (\"      Scope = \");\n+         Write_Name (IS_Rec.Scope);\n+         Write_Eol;\n+      end Write_Invocation_Signature;\n+\n+      ----------------------\n+      -- Write_Statistics --\n+      ----------------------\n+\n+      procedure Write_Statistics is\n+      begin\n+         Write_Str (\"Units             : \");\n+         Write_Num (Int (Number_Of_Units));\n+         Write_Eol;\n+\n+         Write_Str (\"Units to elaborate: \");\n+         Write_Num (Int (Number_Of_Elaborable_Units));\n+         Write_Eol;\n+         Write_Eol;\n+      end Write_Statistics;\n+\n+      ----------------\n+      -- Write_Unit --\n+      ----------------\n+\n+      procedure Write_Unit (U_Id : Unit_Id) is\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         Write_Unit_Common (U_Id);\n+\n+         Write_Str (\"  First_Invocation_Construct (IC_Id_\");\n+         Write_Int (Int (U_Rec.First_Invocation_Construct));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"  Last_Invocation_Construct  (IC_Id_\");\n+         Write_Int (Int (U_Rec.Last_Invocation_Construct));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"  First_Invocation_Relation  (IR_Id_\");\n+         Write_Int (Int (U_Rec.First_Invocation_Relation));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"  Last_Invocation_Relation   (IR_Id_\");\n+         Write_Int (Int (U_Rec.Last_Invocation_Relation));\n+         Write_Str (\")\");\n+         Write_Eol;\n+         Write_Eol;\n+\n+         for IC_Id in U_Rec.First_Invocation_Construct ..\n+                      U_Rec.Last_Invocation_Construct\n+         loop\n+            Write_Invocation_Construct (IC_Id);\n+         end loop;\n+\n+         for IR_Id in U_Rec.First_Invocation_Relation ..\n+                      U_Rec.Last_Invocation_Relation\n+         loop\n+            Write_Invocation_Relation (IR_Id);\n+         end loop;\n+      end Write_Unit;\n+\n+      -----------------------\n+      -- Write_Unit_Common --\n+      -----------------------\n+\n+      procedure Write_Unit_Common (U_Id : Unit_Id) is\n+         pragma Assert (Present (U_Id));\n+\n+         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+      begin\n+         Write_Str  (\"unit (U_Id_\");\n+         Write_Int  (Int (U_Id));\n+         Write_Str  (\") name = \");\n+         Write_Name (U_Rec.Uname);\n+         Write_Eol;\n+\n+         if U_Rec.SAL_Interface then\n+            Write_Str (\"  SAL_Interface = True\");\n+            Write_Eol;\n+         end if;\n+      end Write_Unit_Common;\n+   end ALI_Writers;\n+\n+   -------------------------------\n+   -- Elaboration_Order_Writers --\n+   -------------------------------\n+\n+   package body Elaboration_Order_Writers is\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Write_Unit (U_Id : Unit_Id);\n+      pragma Inline (Write_Unit);\n+      --  Write unit U_Id to standard output\n+\n+      procedure Write_Units (Order : Unit_Id_Table);\n+      pragma Inline (Write_Units);\n+      --  Write all units found in elaboration order Order to standard output\n+\n+      -----------------------------\n+      -- Write_Elaboration_Order --\n+      -----------------------------\n+\n+      procedure Write_Elaboration_Order (Order : Unit_Id_Table) is\n+      begin\n+         --  Nothing to do when switch -d_O (output elaboration order) is not\n+         --  in effect.\n+\n+         if not Debug_Flag_Underscore_OO then\n+            return;\n+         end if;\n+\n+         Write_Str (\"Elaboration Order\");\n+         Write_Eol;\n+         Write_Eol;\n+\n+         Write_Units (Order);\n+\n+         Write_Eol;\n+         Write_Str (\"Elaboration Order end\");\n+         Write_Eol;\n+\n+         Write_Eol;\n+      end Write_Elaboration_Order;\n+\n+      ----------------\n+      -- Write_Unit --\n+      ----------------\n+\n+      procedure Write_Unit (U_Id : Unit_Id) is\n+      begin\n+         pragma Assert (Present (U_Id));\n+\n+         Write_Str  (\"unit (U_Id_\");\n+         Write_Int  (Int (U_Id));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (U_Id));\n+         Write_Eol;\n+      end Write_Unit;\n+\n+      -----------------\n+      -- Write_Units --\n+      -----------------\n+\n+      procedure Write_Units (Order : Unit_Id_Table) is\n+      begin\n+         for Index in Unit_Id_Tables.First .. Unit_Id_Tables.Last (Order) loop\n+            Write_Unit (Order.Table (Index));\n+         end loop;\n+      end Write_Units;\n+   end Elaboration_Order_Writers;\n+\n+   ---------------\n+   -- Indent_By --\n+   ---------------\n+\n+   procedure Indent_By (Indent : Indentation_Level) is\n+   begin\n+      for Count in 1 .. Indent loop\n+         Write_Char (' ');\n+      end loop;\n+   end Indent_By;\n+\n+   ------------------------------\n+   -- Invocation_Graph_Writers --\n+   ------------------------------\n+\n+   package body Invocation_Graph_Writers is\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Write_Elaboration_Root\n+        (G    : Invocation_Graph;\n+         Root : Invocation_Graph_Vertex_Id);\n+      pragma Inline (Write_Elaboration_Root);\n+      --  Write elaboration root Root of invocation graph G to standard output\n+\n+      procedure Write_Elaboration_Roots (G : Invocation_Graph);\n+      pragma Inline (Write_Elaboration_Roots);\n+      --  Write all elaboration roots of invocation graph G to standard output\n+\n+      procedure Write_Invocation_Graph_Edge\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id);\n+      pragma Inline (Write_Invocation_Graph_Edge);\n+      --  Write edge IGE_Id of invocation graph G to standard output\n+\n+      procedure Write_Invocation_Graph_Edges\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id);\n+      pragma Inline (Write_Invocation_Graph_Edges);\n+      --  Write all edges of invocation graph G to standard output\n+\n+      procedure Write_Invocation_Graph_Vertex\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id);\n+      pragma Inline (Write_Invocation_Graph_Vertex);\n+      --  Write vertex IGV_Id of invocation graph G to standard output\n+\n+      procedure Write_Invocation_Graph_Vertices (G : Invocation_Graph);\n+      pragma Inline (Write_Invocation_Graph_Vertices);\n+      --  Write all vertices of invocation graph G to standard output\n+\n+      procedure Write_Statistics (G : Invocation_Graph);\n+      pragma Inline (Write_Statistics);\n+      --  Write the statistical information of invocation graph G to standard\n+      --  output.\n+\n+      -----------\n+      -- Debug --\n+      -----------\n+\n+      procedure pige\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id)\n+         renames Write_Invocation_Graph_Edge;\n+      pragma Unreferenced (pige);\n+\n+      procedure pigv\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id)\n+         renames Write_Invocation_Graph_Vertex;\n+      pragma Unreferenced (pigv);\n+\n+      ----------------------------\n+      -- Write_Elaboration_Root --\n+      ----------------------------\n+\n+      procedure Write_Elaboration_Root\n+        (G    : Invocation_Graph;\n+         Root : Invocation_Graph_Vertex_Id)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Root));\n+\n+         Write_Str  (\"elaboration root (IGV_Id_\");\n+         Write_Int  (Int (Root));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (G, Root));\n+         Write_Eol;\n+      end Write_Elaboration_Root;\n+\n+      -----------------------------\n+      -- Write_Elaboration_Roots --\n+      -----------------------------\n+\n+      procedure Write_Elaboration_Roots (G : Invocation_Graph) is\n+         pragma Assert (Present (G));\n+\n+         Num_Of_Roots : constant Natural := Number_Of_Elaboration_Roots (G);\n+\n+         Iter : Elaboration_Root_Iterator;\n+         Root : Invocation_Graph_Vertex_Id;\n+\n+      begin\n+         Write_Str (\"Elaboration roots: \");\n+         Write_Int (Int (Num_Of_Roots));\n+         Write_Eol;\n+\n+         if Num_Of_Roots > 0 then\n+            Iter := Iterate_Elaboration_Roots (G);\n+            while Has_Next (Iter) loop\n+               Next (Iter, Root);\n+               pragma Assert (Present (Root));\n+\n+               Write_Elaboration_Root (G, Root);\n+            end loop;\n+         else\n+            Write_Eol;\n+         end if;\n+      end Write_Elaboration_Roots;\n+\n+      ----------------------------\n+      -- Write_Invocation_Graph --\n+      ----------------------------\n+\n+      procedure Write_Invocation_Graph (G : Invocation_Graph) is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Nothing to do when switch -d_I (output invocation graph) is not in\n+         --  effect.\n+\n+         if not Debug_Flag_Underscore_II then\n+            return;\n+         end if;\n+\n+         Write_Str (\"Invocation Graph\");\n+         Write_Eol;\n+         Write_Eol;\n+\n+         Write_Statistics (G);\n+         Write_Invocation_Graph_Vertices (G);\n+         Write_Elaboration_Roots (G);\n+\n+         Write_Str (\"Invocation Graph end\");\n+         Write_Eol;\n+\n+         Write_Eol;\n+      end Write_Invocation_Graph;\n+\n+      ---------------------------------\n+      -- Write_Invocation_Graph_Edge --\n+      ---------------------------------\n+\n+      procedure Write_Invocation_Graph_Edge\n+        (G      : Invocation_Graph;\n+         IGE_Id : Invocation_Graph_Edge_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGE_Id));\n+\n+         Targ : constant Invocation_Graph_Vertex_Id := Target (G, IGE_Id);\n+\n+         pragma Assert (Present (Targ));\n+\n+      begin\n+         Write_Str (\"    invocation graph edge (IGE_Id_\");\n+         Write_Int (Int (IGE_Id));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"      Relation (IR_Id_\");\n+         Write_Int (Int (Relation (G, IGE_Id)));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"      Target (IGV_Id_\");\n+         Write_Int (Int (Targ));\n+         Write_Str (\") name = \");\n+         Write_Name (Name (G, Targ));\n+         Write_Eol;\n+\n+         Write_Eol;\n+      end Write_Invocation_Graph_Edge;\n+\n+      ----------------------------------\n+      -- Write_Invocation_Graph_Edges --\n+      ----------------------------------\n+\n+      procedure Write_Invocation_Graph_Edges\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         Num_Of_Edges : constant Natural :=\n+                          Number_Of_Edges_To_Targets (G, IGV_Id);\n+\n+         IGE_Id : Invocation_Graph_Edge_Id;\n+         Iter   : Invocation_Graphs.Edges_To_Targets_Iterator;\n+\n+      begin\n+         Write_Str (\"  Edges to targets: \");\n+         Write_Int (Int (Num_Of_Edges));\n+         Write_Eol;\n+\n+         if Num_Of_Edges > 0 then\n+            Iter := Iterate_Edges_To_Targets (G, IGV_Id);\n+            while Has_Next (Iter) loop\n+               Next (Iter, IGE_Id);\n+               pragma Assert (Present (IGE_Id));\n+\n+               Write_Invocation_Graph_Edge (G, IGE_Id);\n+            end loop;\n+         else\n+            Write_Eol;\n+         end if;\n+      end Write_Invocation_Graph_Edges;\n+\n+      -----------------------------------\n+      -- Write_Invocation_Graph_Vertex --\n+      -----------------------------------\n+\n+      procedure Write_Invocation_Graph_Vertex\n+        (G      : Invocation_Graph;\n+         IGV_Id : Invocation_Graph_Vertex_Id)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (IGV_Id));\n+\n+         Write_Str  (\"invocation graph vertex (IGV_Id_\");\n+         Write_Int  (Int (IGV_Id));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (G, IGV_Id));\n+         Write_Eol;\n+\n+         Write_Str (\"  Construct (IC_Id_\");\n+         Write_Int (Int (Construct (G, IGV_Id)));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"  Lib_Vertex (LGV_Id_\");\n+         Write_Int (Int (Lib_Vertex (G, IGV_Id)));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Invocation_Graph_Edges (G, IGV_Id);\n+      end Write_Invocation_Graph_Vertex;\n+\n+      -------------------------------------\n+      -- Write_Invocation_Graph_Vertices --\n+      -------------------------------------\n+\n+      procedure Write_Invocation_Graph_Vertices (G : Invocation_Graph) is\n+         IGV_Id : Invocation_Graph_Vertex_Id;\n+         Iter   : Invocation_Graphs.All_Vertex_Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Iter := Iterate_All_Vertices (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, IGV_Id);\n+            pragma Assert (Present (IGV_Id));\n+\n+            Write_Invocation_Graph_Vertex (G, IGV_Id);\n+         end loop;\n+      end Write_Invocation_Graph_Vertices;\n+\n+      ----------------------\n+      -- Write_Statistics --\n+      ----------------------\n+\n+      procedure Write_Statistics (G : Invocation_Graph) is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Write_Str (\"Edges   : \");\n+         Write_Num (Int (Number_Of_Edges (G)));\n+         Write_Eol;\n+\n+         Write_Str (\"Roots   : \");\n+         Write_Num (Int (Number_Of_Elaboration_Roots (G)));\n+         Write_Eol;\n+\n+         Write_Str (\"Vertices: \");\n+         Write_Num (Int (Number_Of_Vertices (G)));\n+         Write_Eol;\n+         Write_Eol;\n+\n+         for Kind in Invocation_Kind'Range loop\n+            Write_Str (\"  \");\n+            Write_Num (Int (Invocation_Graph_Edge_Count (G, Kind)));\n+            Write_Str (\" - \");\n+            Write_Str (Kind'Img);\n+            Write_Eol;\n+         end loop;\n+\n+         Write_Eol;\n+      end Write_Statistics;\n+   end Invocation_Graph_Writers;\n+\n+   ---------------------------\n+   -- Library_Graph_Writers --\n+   ---------------------------\n+\n+   package body Library_Graph_Writers is\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Write_Component\n+        (G    : Library_Graph;\n+         Comp : Component_Id);\n+      pragma Inline (Write_Component);\n+      --  Write component Comp of library graph G to standard output\n+\n+      procedure Write_Component_Vertices\n+        (G    : Library_Graph;\n+         Comp : Component_Id);\n+      pragma Inline (Write_Component_Vertices);\n+      --  Write all vertices of component Comp of library graph G to standard\n+      --  output.\n+\n+      procedure Write_Components (G : Library_Graph);\n+      pragma Inline (Write_Components);\n+      --  Write all components of library graph G to standard output\n+\n+      procedure Write_Edges_To_Successors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id);\n+      pragma Inline (Write_Edges_To_Successors);\n+      --  Write all edges to successors of predecessor LGV_Id of library graph\n+      --  G to standard output.\n+\n+      procedure Write_Library_Graph_Edge\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id);\n+      pragma Inline (Write_Library_Graph_Edge);\n+      --  Write edge LGE_Id of library graph G to standard output\n+\n+      procedure Write_Library_Graph_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id);\n+      pragma Inline (Write_Library_Graph_Vertex);\n+      --  Write vertex LGV_Id of library graph G to standard output\n+\n+      procedure Write_Library_Graph_Vertices (G : Library_Graph);\n+      pragma Inline (Write_Library_Graph_Vertices);\n+      --  Write all vertices of library graph G to standard output\n+\n+      procedure Write_Statistics (G : Library_Graph);\n+      pragma Inline (Write_Statistics);\n+      --  Write the statistical information of library graph G to standard\n+      --  output.\n+\n+      -----------\n+      -- Debug --\n+      -----------\n+\n+      procedure pc\n+        (G    : Library_Graph;\n+         Comp : Component_Id) renames Write_Component;\n+      pragma Unreferenced (pc);\n+\n+      procedure plge\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id) renames Write_Library_Graph_Edge;\n+      pragma Unreferenced (plge);\n+\n+      procedure plgv\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id) renames Write_Library_Graph_Vertex;\n+      pragma Unreferenced (plgv);\n+\n+      ---------------------\n+      -- Write_Component --\n+      ---------------------\n+\n+      procedure Write_Component\n+        (G    : Library_Graph;\n+         Comp : Component_Id)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         Write_Str (\"component (Comp_\");\n+         Write_Int (Int (Comp));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"  Pending_Predecessors = \");\n+         Write_Int (Int (Pending_Predecessors (G, Comp)));\n+         Write_Eol;\n+\n+         Write_Component_Vertices (G, Comp);\n+      end Write_Component;\n+\n+      ------------------------------\n+      -- Write_Component_Vertices --\n+      ------------------------------\n+\n+      procedure Write_Component_Vertices\n+        (G    : Library_Graph;\n+         Comp : Component_Id)\n+      is\n+         Iter   : Component_Vertex_Iterator;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         Iter := Iterate_Component_Vertices (G, Comp);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGV_Id);\n+            pragma Assert (Present (LGV_Id));\n+\n+            Write_Str  (\"    library graph vertex (LGV_Id_\");\n+            Write_Int  (Int (LGV_Id));\n+            Write_Str  (\") name = \");\n+            Write_Name (Name (G, LGV_Id));\n+            Write_Eol;\n+         end loop;\n+\n+         Write_Eol;\n+      end Write_Component_Vertices;\n+\n+      ----------------------\n+      -- Write_Components --\n+      ----------------------\n+\n+      procedure Write_Components (G : Library_Graph) is\n+         pragma Assert (Present (G));\n+\n+         Num_Of_Comps : constant Natural := Number_Of_Components (G);\n+\n+         Comp : Component_Id;\n+         Iter : Component_Iterator;\n+\n+      begin\n+         if Num_Of_Comps > 0 then\n+            Iter := Iterate_Components (G);\n+            while Has_Next (Iter) loop\n+               Next (Iter, Comp);\n+               pragma Assert (Present (Comp));\n+\n+               Write_Component (G, Comp);\n+            end loop;\n+         else\n+            Write_Eol;\n+         end if;\n+      end Write_Components;\n+\n+      -------------------------------\n+      -- Write_Edges_To_Successors --\n+      -------------------------------\n+\n+      procedure Write_Edges_To_Successors\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Num_Of_Edges : constant Natural :=\n+                          Number_Of_Edges_To_Successors (G, LGV_Id);\n+\n+         Iter   : Edges_To_Successors_Iterator;\n+         LGE_Id : Library_Graph_Edge_Id;\n+\n+      begin\n+         Write_Str (\"  Edges to successors: \");\n+         Write_Int (Int (Num_Of_Edges));\n+         Write_Eol;\n+\n+         if Num_Of_Edges > 0 then\n+            Iter := Iterate_Edges_To_Successors (G, LGV_Id);\n+            while Has_Next (Iter) loop\n+               Next (Iter, LGE_Id);\n+               pragma Assert (Present (LGE_Id));\n+\n+               Write_Library_Graph_Edge (G, LGE_Id);\n+            end loop;\n+         else\n+            Write_Eol;\n+         end if;\n+      end Write_Edges_To_Successors;\n+\n+      -------------------------\n+      -- Write_Library_Graph --\n+      -------------------------\n+\n+      procedure Write_Library_Graph (G : Library_Graph) is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Nothing to do when switch -d_L (output library item graph) is not\n+         --  in effect.\n+\n+         if not Debug_Flag_Underscore_LL then\n+            return;\n+         end if;\n+\n+         Write_Str (\"Library Graph\");\n+         Write_Eol;\n+         Write_Eol;\n+\n+         Write_Statistics (G);\n+         Write_Library_Graph_Vertices (G);\n+         Write_Components (G);\n+\n+         Write_Str (\"Library Graph end\");\n+         Write_Eol;\n+\n+         Write_Eol;\n+      end Write_Library_Graph;\n+\n+      ------------------------------\n+      -- Write_Library_Graph_Edge --\n+      ------------------------------\n+\n+      procedure Write_Library_Graph_Edge\n+        (G      : Library_Graph;\n+         LGE_Id : Library_Graph_Edge_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGE_Id));\n+\n+         Pred : constant Library_Graph_Vertex_Id := Predecessor (G, LGE_Id);\n+         Succ : constant Library_Graph_Vertex_Id := Successor   (G, LGE_Id);\n+\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Present (Succ));\n+\n+      begin\n+         Write_Str (\"    library graph edge (LGE_Id_\");\n+         Write_Int (Int (LGE_Id));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str (\"      Kind = \");\n+         Write_Str (Kind (G, LGE_Id)'Img);\n+         Write_Eol;\n+\n+         Write_Str  (\"      Predecessor (LGV_Id_\");\n+         Write_Int  (Int (Pred));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (G, Pred));\n+         Write_Eol;\n+\n+         Write_Str  (\"      Successor   (LGV_Id_\");\n+         Write_Int  (Int (Succ));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (G, Succ));\n+         Write_Eol;\n+\n+         Write_Eol;\n+      end Write_Library_Graph_Edge;\n+\n+      --------------------------------\n+      -- Write_Library_Graph_Vertex --\n+      --------------------------------\n+\n+      procedure Write_Library_Graph_Vertex\n+        (G      : Library_Graph;\n+         LGV_Id : Library_Graph_Vertex_Id)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (LGV_Id));\n+\n+         Item : constant Library_Graph_Vertex_Id :=\n+                  Corresponding_Item (G, LGV_Id);\n+         U_Id : constant Unit_Id := Unit (G, LGV_Id);\n+\n+         pragma Assert (Present (U_Id));\n+\n+      begin\n+         Write_Str  (\"library graph vertex (LGV_Id_\");\n+         Write_Int  (Int (LGV_Id));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (G, LGV_Id));\n+         Write_Eol;\n+\n+         if Present (Item) then\n+            Write_Str  (\"  Corresponding_Item (LGV_Id_\");\n+            Write_Int  (Int (Item));\n+            Write_Str  (\") name = \");\n+            Write_Name (Name (G, Item));\n+         else\n+            Write_Str (\"  Corresponding_Item = none\");\n+         end if;\n+\n+         Write_Eol;\n+         Write_Str (\"  In_Elaboration_Order = \");\n+\n+         if In_Elaboration_Order (G, LGV_Id) then\n+            Write_Str (\"True\");\n+         else\n+            Write_Str (\"False\");\n+         end if;\n+\n+         Write_Eol;\n+         Write_Str (\"  Pending_Predecessors = \");\n+         Write_Int (Int (Pending_Predecessors (G, LGV_Id)));\n+         Write_Eol;\n+\n+         Write_Str (\"  Component (Comp_Id_\");\n+         Write_Int (Int (Component (G, LGV_Id)));\n+         Write_Str (\")\");\n+         Write_Eol;\n+\n+         Write_Str  (\"  Unit (U_Id_\");\n+         Write_Int  (Int (U_Id));\n+         Write_Str  (\") name = \");\n+         Write_Name (Name (U_Id));\n+         Write_Eol;\n+\n+         Write_Edges_To_Successors (G, LGV_Id);\n+      end Write_Library_Graph_Vertex;\n+\n+      ----------------------------------\n+      -- Write_Library_Graph_Vertices --\n+      ----------------------------------\n+\n+      procedure Write_Library_Graph_Vertices (G : Library_Graph) is\n+         Iter   : Library_Graphs.All_Vertex_Iterator;\n+         LGV_Id : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         Iter := Iterate_All_Vertices (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, LGV_Id);\n+            pragma Assert (Present (LGV_Id));\n+\n+            Write_Library_Graph_Vertex (G, LGV_Id);\n+         end loop;\n+      end Write_Library_Graph_Vertices;\n+\n+      ----------------------\n+      -- Write_Statistics --\n+      ----------------------\n+\n+      procedure Write_Statistics (G : Library_Graph) is\n+      begin\n+         Write_Str (\"Components: \");\n+         Write_Num (Int (Number_Of_Components (G)));\n+         Write_Eol;\n+\n+         Write_Str (\"Edges     : \");\n+         Write_Num (Int (Number_Of_Edges (G)));\n+         Write_Eol;\n+\n+         Write_Str (\"Vertices  : \");\n+         Write_Num (Int (Number_Of_Vertices (G)));\n+         Write_Eol;\n+         Write_Eol;\n+\n+         for Kind in Library_Graph_Edge_Kind'Range loop\n+            Write_Str (\"  \");\n+            Write_Num (Int (Library_Graph_Edge_Count (G, Kind)));\n+            Write_Str (\" - \");\n+            Write_Str (Kind'Img);\n+            Write_Eol;\n+         end loop;\n+\n+         Write_Eol;\n+      end Write_Statistics;\n+   end Library_Graph_Writers;\n+\n+   --------------------------\n+   -- Unit_Closure_Writers --\n+   --------------------------\n+\n+   package body Unit_Closure_Writers is\n+      function Hash_File_Name (Nam : File_Name_Type) return Bucket_Range_Type;\n+      pragma Inline (Hash_File_Name);\n+      --  Obtain the hash value of key Nam\n+\n+      package FS is new Membership_Sets\n+        (Element_Type => File_Name_Type,\n+         \"=\"          => \"=\",\n+         Hash         => Hash_File_Name);\n+      use FS;\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Write_File_Name (Nam : File_Name_Type);\n+      pragma Inline (Write_File_Name);\n+      --  Write file name Nam to standard output\n+\n+      procedure Write_Subunit_Closure\n+        (Dep : Sdep_Id;\n+         Set : Membership_Set);\n+      pragma Inline (Write_Subunit_Closure);\n+      --  Write the subunit which corresponds to dependency Dep to standard\n+      --  output if it does not appear in set Set.\n+\n+      procedure Write_Subunits_Closure (Set : Membership_Set);\n+      pragma Inline (Write_Subunits_Closure);\n+      --  Write all subunits to standard output if they do not appear in set\n+      --  Set.\n+\n+      procedure Write_Unit_Closure\n+        (U_Id : Unit_Id;\n+         Set  : Membership_Set);\n+      pragma Inline (Write_Unit_Closure);\n+      --  Write unit U_Id to standard output if it does not appear in set Set\n+\n+      procedure Write_Units_Closure\n+        (Order : Unit_Id_Table;\n+         Set   : Membership_Set);\n+      pragma Inline (Write_Units_Closure);\n+      --  Write all units of elaboration order Order to standard output if they\n+      --  do not appear in set Set.\n+\n+      --------------------\n+      -- Hash_File_Name --\n+      --------------------\n+\n+      function Hash_File_Name\n+        (Nam : File_Name_Type) return Bucket_Range_Type\n+      is\n+      begin\n+         pragma Assert (Present (Nam));\n+\n+         return Bucket_Range_Type (Nam);\n+      end Hash_File_Name;\n+\n+      ---------------------\n+      -- Write_File_Name --\n+      ---------------------\n+\n+      procedure Write_File_Name (Nam : File_Name_Type) is\n+      begin\n+         pragma Assert (Present (Nam));\n+\n+         if not Zero_Formatting then\n+            Write_Str (\"   \");\n+         end if;\n+\n+         Write_Line (Get_Name_String (Nam));\n+      end Write_File_Name;\n+\n+      ---------------------------\n+      -- Write_Subunit_Closure --\n+      ---------------------------\n+\n+      procedure Write_Subunit_Closure\n+        (Dep : Sdep_Id;\n+         Set : Membership_Set)\n+      is\n+         pragma Assert (Present (Dep));\n+         pragma Assert (Present (Set));\n+\n+         Dep_Rec : Sdep_Record renames Sdep.Table (Dep);\n+         Source  : constant File_Name_Type := Dep_Rec.Sfile;\n+\n+         pragma Assert (Present (Source));\n+\n+      begin\n+         --  Nothing to do when the source file has already been written\n+\n+         if Contains (Set, Source) then\n+            return;\n+\n+         --  Nothing to do when the source file does not denote a non-internal\n+         --  subunit.\n+\n+         elsif not Present (Dep_Rec.Subunit_Name)\n+           or else Is_Internal_File_Name (Source)\n+         then\n+            return;\n+         end if;\n+\n+         --  Mark the subunit as written\n+\n+         Insert (Set, Source);\n+         Write_File_Name (Source);\n+      end Write_Subunit_Closure;\n+\n+      ----------------------------\n+      -- Write_Subunits_Closure --\n+      ----------------------------\n+\n+      procedure Write_Subunits_Closure (Set : Membership_Set) is\n+      begin\n+         pragma Assert (Present (Set));\n+\n+         for Dep in Sdep.First .. Sdep.Last loop\n+            Write_Subunit_Closure (Dep, Set);\n+         end loop;\n+      end Write_Subunits_Closure;\n+\n+      ------------------------\n+      -- Write_Unit_Closure --\n+      ------------------------\n+\n+      procedure Write_Unit_Closure (Order : Unit_Id_Table) is\n+         Set : Membership_Set;\n+\n+      begin\n+         --  Nothing to do when switch -R (list sources referenced in closure)\n+         --  is not in effect.\n+\n+         if not List_Closure then\n+            return;\n+         end if;\n+\n+         if not Zero_Formatting then\n+            Write_Eol;\n+            Write_Line (\"REFERENCED SOURCES\");\n+         end if;\n+\n+         --  Use a set to avoid writing duplicate units and subunits\n+\n+         Set := Create (Number_Of_Elaborable_Units);\n+\n+         Write_Units_Closure (Order, Set);\n+         Write_Subunits_Closure (Set);\n+\n+         Destroy (Set);\n+\n+         if not Zero_Formatting then\n+            Write_Eol;\n+         end if;\n+      end Write_Unit_Closure;\n+\n+      ------------------------\n+      -- Write_Unit_Closure --\n+      ------------------------\n+\n+      procedure Write_Unit_Closure\n+        (U_Id : Unit_Id;\n+         Set  : Membership_Set)\n+      is\n+         pragma Assert (Present (U_Id));\n+         pragma Assert (Present (Set));\n+\n+         U_Rec  : Unit_Record renames ALI.Units.Table (U_Id);\n+         Source : constant File_Name_Type := U_Rec.Sfile;\n+\n+         pragma Assert (Present (Source));\n+\n+      begin\n+         --  Nothing to do when the source file has already been written\n+\n+         if Contains (Set, Source) then\n+            return;\n+\n+         --  Nothing to do for internal source files unless switch -Ra (???) is\n+         --  in effect.\n+\n+         elsif Is_Internal_File_Name (Source)\n+           and then not List_Closure_All\n+         then\n+            return;\n+         end if;\n+\n+         --  Mark the source file as written\n+\n+         Insert (Set, Source);\n+         Write_File_Name (Source);\n+      end Write_Unit_Closure;\n+\n+      -------------------------\n+      -- Write_Units_Closure --\n+      -------------------------\n+\n+      procedure Write_Units_Closure\n+        (Order : Unit_Id_Table;\n+         Set   : Membership_Set)\n+      is\n+      begin\n+         pragma Assert (Present (Set));\n+\n+         for Index in reverse Unit_Id_Tables.First ..\n+                              Unit_Id_Tables.Last (Order)\n+         loop\n+            Write_Unit_Closure\n+              (U_Id => Order.Table (Index),\n+               Set  => Set);\n+         end loop;\n+      end Write_Units_Closure;\n+   end Unit_Closure_Writers;\n+\n+   ---------------\n+   -- Write_Num --\n+   ---------------\n+\n+   procedure Write_Num\n+     (Val        : Int;\n+      Val_Indent : Indentation_Level := Number_Column)\n+   is\n+      function Digits_Indentation return Indentation_Level;\n+      pragma Inline (Digits_Indentation);\n+      --  Determine the level of indentation the number requies in order to\n+      --  be right-justified by Val_Indent.\n+\n+      ------------------------\n+      -- Digits_Indentation --\n+      ------------------------\n+\n+      function Digits_Indentation return Indentation_Level is\n+         Indent : Indentation_Level;\n+         Num    : Int;\n+\n+      begin\n+         --  Treat zero as a single digit\n+\n+         if Val = 0 then\n+            Indent := 1;\n+\n+         else\n+            Indent := 0;\n+            Num    := Val;\n+\n+            --  Shrink the input value by dividing it until all of its digits\n+            --  are exhausted.\n+\n+            while Num /= 0 loop\n+               Indent := Indent + 1;\n+               Num    := Num / 10;\n+            end loop;\n+         end if;\n+\n+         return Val_Indent - Indent;\n+      end Digits_Indentation;\n+\n+   --  Start of processing for Write_Num\n+\n+   begin\n+      Indent_By (Digits_Indentation);\n+      Write_Int (Val);\n+   end Write_Num;\n+\n+end Bindo.Writers;"}, {"sha": "9ed598e9981e9208bec3fbcf1a37a2887aa78784", "filename": "gcc/ada/bindo-writers.ads", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-writers.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo-writers.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,125 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        B I N D O . W R I T E R S                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  For full architecture, see unit Bindo.\n+\n+--  The following unit contains facilities to output the various graphs used in\n+--  determining the elaboration order, as well as the elaboration order itself\n+--  to standard output.\n+\n+with Types; use Types;\n+\n+with Bindo.Graphs;\n+use  Bindo.Graphs;\n+use  Bindo.Graphs.Invocation_Graphs;\n+use  Bindo.Graphs.Library_Graphs;\n+\n+package Bindo.Writers is\n+\n+   -----------------\n+   -- Indentation --\n+   -----------------\n+\n+   --  The following type defines the level of indentation used in various\n+   --  output routines.\n+\n+   type Indentation_Level is new Natural;\n+   No_Indentation : constant Indentation_Level := Indentation_Level'First;\n+\n+   Nested_Indentation : constant Indentation_Level := 2;\n+   --  The level of indentation for a nested new line\n+\n+   Number_Column : constant Indentation_Level := 6;\n+   --  The level of right justification of numbers\n+\n+   Step_Column : constant Indentation_Level := 4;\n+   --  The level of right justification of the elaboration order step\n+\n+   procedure Indent_By (Indent : Indentation_Level);\n+   pragma Inline (Indent_By);\n+   --  Indent the current line by Indent spaces\n+\n+   procedure Write_Num\n+     (Val        : Int;\n+      Val_Indent : Indentation_Level := Number_Column);\n+   pragma Inline (Write_Num);\n+   --  Output integer value Val in a right-justified form based on the value of\n+   --  Val_Col.\n+\n+   -----------------\n+   -- ALI_Writers --\n+   -----------------\n+\n+   package ALI_Writers is\n+      procedure Write_ALI_Tables;\n+      --  Write the contents of the following tables to standard output:\n+      --\n+      --    * ALI.Invocation_Constructs\n+      --    * ALI.Invocation_Relations\n+\n+   end ALI_Writers;\n+\n+   -------------------------------\n+   -- Elaboration_Order_Writers --\n+   -------------------------------\n+\n+   package Elaboration_Order_Writers is\n+      procedure Write_Elaboration_Order (Order : Unit_Id_Table);\n+      --  Write elaboration order Order to standard output\n+\n+   end Elaboration_Order_Writers;\n+\n+   ------------------------------\n+   -- Invocation_Graph_Writers --\n+   ------------------------------\n+\n+   package Invocation_Graph_Writers is\n+      procedure Write_Invocation_Graph (G : Invocation_Graph);\n+      --  Write invocation graph G to standard output\n+\n+   end Invocation_Graph_Writers;\n+\n+   ---------------------------\n+   -- Library_Graph_Writers --\n+   ---------------------------\n+\n+   package Library_Graph_Writers is\n+      procedure Write_Library_Graph (G : Library_Graph);\n+      --  Write library graph G to standard output\n+\n+   end Library_Graph_Writers;\n+\n+   --------------------------\n+   -- Unit_Closure_Writers --\n+   --------------------------\n+\n+   package Unit_Closure_Writers is\n+      procedure Write_Unit_Closure (Order : Unit_Id_Table);\n+      --  Write all sources in the closure of the main unit as enumerated in\n+      --  elaboration order Order.\n+\n+   end Unit_Closure_Writers;\n+\n+end Bindo.Writers;"}, {"sha": "7d26476c86b798d40554ad47f07a2113cdb4a61d", "filename": "gcc/ada/bindo.adb", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,287 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                B I N D O                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Bindo.Elaborators;\n+use  Bindo.Elaborators.Invocation_And_Library_Graph_Elaborators;\n+\n+package body Bindo is\n+\n+   ---------------------------------\n+   -- Elaboration order mechanism --\n+   ---------------------------------\n+\n+   --  The elaboration order (EO) mechanism implemented in this unit and its\n+   --  children has the following objectives:\n+   --\n+   --    * Find an ordering of all library items (historically referred to as\n+   --      \"units\") in the bind which require elaboration, taking into account:\n+   --\n+   --        - The dependencies between units expressed in the form of with\n+   --          clauses.\n+   --\n+   --        - Pragmas Elaborate, Elaborate_All, Elaborate_Body, Preelaborable,\n+   --          and Pure.\n+   --\n+   --        - The flow of execution at elaboration time.\n+   --\n+   --        - Additional dependencies between units supplied to the binder by\n+   --          means of a file.\n+   --\n+   --      The high-level idea is to construct two graphs:\n+   --\n+   --        - Invocation graph - Models the flow of execution at elaboration\n+   --          time.\n+   --\n+   --        - Library graph - Represents with clause and pragma dependencies\n+   --          between units.\n+   --\n+   --      The library graph is further augmented with additional information\n+   --      from the invocation graph by exploring the execution paths from a\n+   --      unit with elaboration code to other external units. All strongly\n+   --      connected components of the library graph are discovered. Finally,\n+   --      the order is obtained via a topological sort-like algorithm which\n+   --      attempts to order available units while enabling other units to be\n+   --      ordered.\n+   --\n+   --    * Diagnose elaboration circularities between units\n+   --\n+   --      The library graph may contain at least one cycle, in which case no\n+   --      ordering is possible.\n+   --\n+   --      ??? more on this later\n+\n+   -----------------\n+   -- Terminology --\n+   -----------------\n+\n+   --  * Component - A strongly connected component of a graph.\n+   --\n+   --  * Elaboration root - A special invocation construct which denotes the\n+   --    elaboration procedure of a unit.\n+   --\n+   --  * Invocation - The act of activating a task, calling a subprogram, or\n+   --    instantiating a generic.\n+   --\n+   --  * Invocation construct - An entry declaration, [single] protected type,\n+   --    subprogram declaration, subprogram instantiation, or a [single] task\n+   --    type declared in the visible, private, or body declarations of some\n+   --    unit. The construct is encoded in the ALI file of the related unit.\n+   --\n+   --  * Invocation graph - A directed graph which models the flow of execution\n+   --    at elaboration time.\n+   --\n+   --      - Vertices - Invocation constructs plus extra information. Certain\n+   --        vertices act as elaboration roots.\n+   --\n+   --      - Edges - Invocation relations plus extra information.\n+   --\n+   --  * Invocation relation - A flow link between two invocation constructs.\n+   --    This link is encoded in the ALI file of unit that houses the invoker.\n+   --\n+   --  * Invocation signature - A set of attributes that uniquely identify an\n+   --    invocation construct within the namespace of all ALI files.\n+   --\n+   --  * Invoker - The source construct of an invocation relation (the caller,\n+   --    instantiator, or task activator).\n+   --\n+   --  * Library graph - A directed graph which captures with clause and pragma\n+   --    dependencies between units.\n+   --\n+   --      - Vertices - Units plus extra information.\n+   --\n+   --      - Edges - With clause, pragma, and additional dependencies between\n+   --        units.\n+   --\n+   --  * Pending predecessor - A vertex that must be elaborated before another\n+   --    vertex can be elaborated.\n+   --\n+   --  * Target - The destination construct of an invocation relation (the\n+   --    generic, subprogram, or task type).\n+\n+   ------------------\n+   -- Architecture --\n+   ------------------\n+\n+   --     Find_Elaboration_Order\n+   --     |\n+   --     +--> Collect_Elaborable_Units\n+   --     +--> Write_ALI_Tables\n+   --     +--> Elaborate_Units\n+   --          |\n+   --  +------ | -------------- Construction phase ------------------------+\n+   --  |       |                                                           |\n+   --  |       +--> Build_Library_Graph                                    |\n+   --  |       +--> Validate_Library_Graph                                 |\n+   --  |       +--> Write_Library_Graph                                    |\n+   --  |       |                                                           |\n+   --  |       +--> Build_Invocation_Graph                                 |\n+   --  |       +--> Validate_Invocation_Graph                              |\n+   --  |       +--> Write_Invocation_Graph                                 |\n+   --  |       |                                                           |\n+   --  +------ | ----------------------------------------------------------+\n+   --          |\n+   --  +------ | -------------- Augmentation phase ------------------------+\n+   --  |       |                                                           |\n+   --  |       +--> Augment_Library_Graph                                  |\n+   --  |       |                                                           |\n+   --  +------ | ----------------------------------------------------------+\n+   --          |\n+   --  +------ | -------------- Ordering phase ----------------------------+\n+   --  |       |                                                           |\n+   --  |       +--> Find_Components                                        |\n+   --  |       |                                                           |\n+   --  |       +--> Elaborate_Library_Graph                                |\n+   --  |       +--> Validate_Elaboration_Order                             |\n+   --  |       +--> Write_Elaboration_Order                                |\n+   --  |       |                                                           |\n+   --  |       +--> Write_Unit_Closure                                     |\n+   --  |       |                                                           |\n+   --  +------ | ----------------------------------------------------------+\n+   --          |\n+   --  +------ | -------------- Diagnostics phase -------------------------+\n+   --  |       |                                                           |\n+   --  |       +--> ??? more on this later                                 |\n+   --  |                                                                   |\n+   --  +-------------------------------------------------------------------+\n+\n+   ------------------------\n+   -- Construction phase --\n+   ------------------------\n+\n+   --  The Construction phase has the following objectives:\n+   --\n+   --    * Build the library graph by inspecting the ALI file of each unit that\n+   --      requires elaboration.\n+   --\n+   --    * Validate the consistency of the library graph, only when switch -d_V\n+   --      is in effect.\n+   --\n+   --    * Write the contents of the invocation graph in human-readable form to\n+   --      standard output when switch -d_L is in effect.\n+   --\n+   --    * Build the invocation graph by inspecting invocation constructs and\n+   --      relations in the ALI file of each unit that requires elaboration.\n+   --\n+   --    * Validate the consistency of the invocation graph, only when switch\n+   --      -d_V is in effect.\n+   --\n+   --    * Write the contents of the invocation graph in human-readable form to\n+   --      standard output when switch -d_I is in effect.\n+\n+   ------------------------\n+   -- Augmentation phase --\n+   ------------------------\n+\n+   --  The Augmentation phase has the following objectives:\n+   --\n+   --    * Discover transitions of the elaboration flow from a unit with an\n+   --      elaboration root to other units. Augment the library graph with\n+   --      extra edges for each such transition.\n+\n+   --------------------\n+   -- Ordering phase --\n+   --------------------\n+\n+   --  The Ordering phase has the following objectives:\n+   --\n+   --    * Discover all components of the library graph by treating specs and\n+   --      bodies as single vertices.\n+   --\n+   --    * Try to order as many vertices of the library graph as possible by\n+   --      peforming a topological sort based on the pending predecessors of\n+   --      vertices across all components and within a single component.\n+   --\n+   --    * Validate the consistency of the order, only when switch -d_V is in\n+   --      effect.\n+   --\n+   --    * Write the contents of the order in human-readable form to standard\n+   --      output when switch -d_O is in effect.\n+   --\n+   --    * Write the sources of the order closure when switch -R is in effect.\n+\n+   -----------------------\n+   -- Diagnostics phase --\n+   -----------------------\n+\n+   --  ??? more on this later\n+\n+   --------------\n+   -- Switches --\n+   --------------\n+\n+   --  -d_A  Output ALI invocation tables\n+   --\n+   --        GNATbind outputs the contents of ALI table Invocation_Constructs\n+   --        and Invocation_Edges in textual format to standard output.\n+   --\n+   --  -d_I  Output invocation graph\n+   --\n+   --        GNATbind outputs the invocation graph in text format to standard\n+   --        output.\n+   --\n+   --  -d_L  Output library graph\n+   --\n+   --        GNATbind outputs the library graph in textual format to standard\n+   --        output.\n+   --\n+   --  -d_N  New bindo order\n+   --\n+   --        GNATbind utilizes the new bindo elaboration order\n+   --\n+   --  -d_O  Output elaboration order\n+   --\n+   --        GNATbind outputs the elaboration order in text format to standard\n+   --        output.\n+   --\n+   --  -d_T  Output elaboration order trace information\n+   --\n+   --        GNATbind outputs trace information on elaboration order activities\n+   --        to standard output.\n+   --\n+   --  -d_V  Validate bindo graphs and order\n+   --\n+   --        GNATbind validates the invocation graph, library graph, SCC graph\n+   --        and elaboration order by detecting inconsistencies and producing\n+   --        error reports.\n+\n+   ----------------------------------------\n+   -- Debugging elaboration order issues --\n+   ----------------------------------------\n+\n+   --  ??? more on this later\n+\n+   ----------------------------\n+   -- Find_Elaboration_Order --\n+   ----------------------------\n+\n+   procedure Find_Elaboration_Order\n+     (Order         : out Unit_Id_Table;\n+      Main_Lib_File : File_Name_Type)\n+   is\n+   begin\n+      Elaborate_Units (Order, Main_Lib_File);\n+   end Find_Elaboration_Order;\n+\n+end Bindo;"}, {"sha": "39cf7a49373263be284cd1f8b70297e1e413ebca", "filename": "gcc/ada/bindo.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fbindo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -0,0 +1,44 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                B I N D O                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2019, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The following unit contains the main entry point into the elaboration order\n+--  mechanism. See the body for details.\n+\n+with ALI;   use ALI;\n+with Namet; use Namet;\n+\n+package Bindo is\n+\n+   procedure Find_Elaboration_Order\n+     (Order         : out Unit_Id_Table;\n+      Main_Lib_File : File_Name_Type);\n+   --  Find an order of all units in the bind that need to be elaborated\n+   --  such that elaboration code flow, pragmas Elaborate, Elaborate_All,\n+   --  and Elaborate_Body, and with clause dependencies are all honoured.\n+   --  Main_Lib_File is the argument of the bind. If a satisfactory order\n+   --  exists, it is returned in Order, otherwise Unrecoverable_Error is\n+   --  raised.\n+\n+end Bindo;"}, {"sha": "d76d93d69483d5b4942171722768aa17be801c74", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 190, "deletions": 8, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -177,8 +177,8 @@ package body Debug is\n    --  d_C\n    --  d_D\n    --  d_E\n-   --  d_F\n-   --  d_G\n+   --  d_F  Encode full invocation paths in ALI files\n+   --  d_G  Encode invocation graph in ALI files\n    --  d_H\n    --  d_I\n    --  d_J\n@@ -191,7 +191,7 @@ package body Debug is\n    --  d_Q\n    --  d_R\n    --  d_S\n-   --  d_T\n+   --  d_T  Output trace information on invocation path recording\n    --  d_U\n    --  d_V\n    --  d_W\n@@ -258,6 +258,160 @@ package body Debug is\n    --  dy\n    --  dz\n \n+   --  dA\n+   --  dB\n+   --  dC\n+   --  dD\n+   --  dE\n+   --  dF\n+   --  dG\n+   --  dH\n+   --  dI\n+   --  dJ\n+   --  dK\n+   --  dL\n+   --  dM\n+   --  dN\n+   --  dO\n+   --  dP\n+   --  dQ\n+   --  dR\n+   --  dS\n+   --  dT\n+   --  dU\n+   --  dV\n+   --  dW\n+   --  dX\n+   --  dY\n+   --  dZ\n+\n+   --  d.a\n+   --  d.b\n+   --  d.c\n+   --  d.d\n+   --  d.e\n+   --  d.f\n+   --  d.g\n+   --  d.h\n+   --  d.i\n+   --  d.j\n+   --  d.k\n+   --  d.l\n+   --  d.m\n+   --  d.n\n+   --  d.o\n+   --  d.p\n+   --  d.q\n+   --  d.r\n+   --  d.s\n+   --  d.t\n+   --  d.u\n+   --  d.v\n+   --  d.w\n+   --  d.x\n+   --  d.y\n+   --  d.z\n+\n+   --  d.A\n+   --  d.B\n+   --  d.C\n+   --  d.D\n+   --  d.E\n+   --  d.F\n+   --  d.G\n+   --  d.H\n+   --  d.I\n+   --  d.J\n+   --  d.K\n+   --  d.L\n+   --  d.M\n+   --  d.N\n+   --  d.O\n+   --  d.P\n+   --  d.Q\n+   --  d.R\n+   --  d.S\n+   --  d.T\n+   --  d.U\n+   --  d.V\n+   --  d.W\n+   --  d.X\n+   --  d.Y\n+   --  d.Z\n+\n+   --  d.1\n+   --  d.2\n+   --  d.3\n+   --  d.4\n+   --  d.5\n+   --  d.6\n+   --  d.7\n+   --  d.8\n+   --  d.9\n+\n+   --  d_a\n+   --  d_b\n+   --  d_c\n+   --  d_d\n+   --  d_e\n+   --  d_f\n+   --  d_g\n+   --  d_h\n+   --  d_i\n+   --  d_j\n+   --  d_k\n+   --  d_l\n+   --  d_m\n+   --  d_n\n+   --  d_o\n+   --  d_p\n+   --  d_q\n+   --  d_r\n+   --  d_s\n+   --  d_t\n+   --  d_u\n+   --  d_v\n+   --  d_w\n+   --  d_x\n+   --  d_y\n+   --  d_z\n+\n+   --  d_A  Output ALI invocation tables\n+   --  d_B\n+   --  d_C\n+   --  d_D\n+   --  d_F\n+   --  d_G\n+   --  d_H\n+   --  d_I  Output invocation graph\n+   --  d_J\n+   --  d_K\n+   --  d_L  Output library graph\n+   --  d_M\n+   --  d_N  New bindo order\n+   --  d_O  Output elaboration order\n+   --  d_P\n+   --  d_Q\n+   --  d_R\n+   --  d_S\n+   --  d_T  Output elaboration order trace information\n+   --  d_U\n+   --  d_V  Validate bindo graphs and order\n+   --  d_W\n+   --  d_X\n+   --  d_Y\n+   --  d_Z\n+\n+   --  d_1\n+   --  d_2\n+   --  d_3\n+   --  d_4\n+   --  d_5\n+   --  d_6\n+   --  d_7\n+   --  d_8\n+   --  d_9\n+\n    --  Debug flags used in package Make and its clients (e.g. GNATMAKE)\n \n    --  da\n@@ -850,11 +1004,21 @@ package body Debug is\n \n    --  d_A  Do not generate ALI files by setting Opt.Disable_ALI_File.\n \n+   --  d_F  The compiler encodes the full path from an invocation construct to\n+   --       an external target, offering additional information to GNATBIND for\n+   --       purposes of error diagnostics.\n+\n+   --  d_G  The compiler encodes the invocation graph of a unit in its ALI\n+   --       file.\n+\n    --  d_L  Output trace information on elaboration checking. This debug switch\n    --       causes output to be generated showing each call or instantiation as\n    --       it is checked, and the progress of the recursive trace through\n    --       elaboration calls at compile time.\n \n+   --  d_T  The compiler outputs trance information to standard output whenever\n+   --       an invocation path is recorded.\n+\n    --  d1   Error messages have node numbers where possible. Normally error\n    --       messages have only source locations. This option is useful when\n    --       debugging errors caused by expanded code, where the source location\n@@ -954,11 +1118,10 @@ package body Debug is\n    --      dependencies) except that internal units are included in the\n    --      listing.\n \n-   --  di  Normally gnatbind calls Read_Ali with Ignore_Errors set to\n-   --      False, since the binder really needs correct version ALI\n-   --      files to do its job. This debug flag causes Ignore_Errors\n-   --      mode to be set for the binder (and is particularly useful\n-   --      for testing ignore errors mode).\n+   --  di  Normally GNATBIND calls Read_Ali with Ignore_Errors set to False,\n+   --      since the binder really needs correct version ALI files to do its\n+   --      job. This debug flag causes Ignore_Errors mode to be set for the\n+   --      binder (and is particularly useful for testing ignore errors mode).\n \n    --  dn  List details of manipulation of Num_Pred values during execution of\n    --      the algorithm used to determine a correct order of elaboration. This\n@@ -985,6 +1148,25 @@ package body Debug is\n    --  dx  Force the binder to read (and then ignore) the xref information\n    --      in ali files (used to check that read circuit is working OK).\n \n+   --  d_A  GNATBIND output the contents of all ALI invocation-related tables\n+   --       in textual format to standard output.\n+   --\n+   --  d_I  GNATBIND outputs the contents of the invocation graph in textual\n+   --       format to standard output.\n+   --\n+   --  d_L  GNATBIND outputs the contents of the library graph in textual\n+   --       format to standard output.\n+   --\n+   --  d_N  GNATBIND utilizes the elaboration order provided by bindo\n+   --\n+   --  d_O  GNATBIND outputs the elaboration order of units to standard output\n+   --\n+   --  d_T  GNATBIND outputs trace information of elaboration order activities\n+   --       to standard output.\n+   --\n+   --  d_V  GNATBIND validates the invocation graph, library graph, SCC graph\n+   --       and elaboration order.\n+\n    --------------------------------------------\n    -- Documentation for gnatmake Debug Flags --\n    --------------------------------------------"}, {"sha": "420609067c9cb96292e21229e7f397b512b37363", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -4940,18 +4940,6 @@ package body Exp_Util is\n       end if;\n    end Evolve_Or_Else;\n \n-   -------------------\n-   -- Exceptions_OK --\n-   -------------------\n-\n-   function Exceptions_OK return Boolean is\n-   begin\n-      return\n-        not (Restriction_Active (No_Exception_Handlers)    or else\n-             Restriction_Active (No_Exception_Propagation) or else\n-             Restriction_Active (No_Exceptions));\n-   end Exceptions_OK;\n-\n    -----------------------------------------\n    -- Expand_Static_Predicates_In_Choices --\n    -----------------------------------------"}, {"sha": "7cb9d2de73a4f37839f8c03eb454c908e24a22fe", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -559,10 +559,6 @@ package Exp_Util is\n    --  indicating that no checks were required). The Sloc field of the\n    --  constructed N_Or_Else node is copied from Cond1.\n \n-   function Exceptions_OK return Boolean;\n-   --  Determine whether exceptions are allowed to be caught, propagated, or\n-   --  raised.\n-\n    procedure Expand_Static_Predicates_In_Choices (N : Node_Id);\n    --  N is either a case alternative or a variant. The Discrete_Choices field\n    --  of N points to a list of choices. If any of these choices is the name"}, {"sha": "dd90c7b7c9a2a37d3f731ef800e5b9b33a90bb28", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -320,8 +320,8 @@ GNAT_ADA_OBJS =\t\\\n  ada/libgnat/g-graphs.o \\\n  ada/libgnat/g-hesora.o\t\\\n  ada/libgnat/g-htable.o\t\\\n- ada/libgnat/g-lists.o \\\n- ada/libgnat/g-sets.o \\\n+ ada/libgnat/g-lists.o\t\\\n+ ada/libgnat/g-sets.o\t\\\n  ada/libgnat/g-spchge.o\t\\\n  ada/libgnat/g-speche.o\t\\\n  ada/libgnat/g-u3spch.o\t\\\n@@ -508,6 +508,15 @@ GNATBIND_OBJS = \\\n  ada/binde.o      \\\n  ada/binderr.o    \\\n  ada/bindgen.o    \\\n+ ada/bindo.o      \\\n+ ada/bindo-augmentors.o   \\\n+ ada/bindo-builders.o     \\\n+ ada/bindo-diagnostics.o  \\\n+ ada/bindo-elaborators.o  \\\n+ ada/bindo-graphs.o       \\\n+ ada/bindo-units.o        \\\n+ ada/bindo-validators.o   \\\n+ ada/bindo-writers.o      \\\n  ada/bindusg.o    \\\n  ada/butil.o      \\\n  ada/casing.o     \\\n@@ -527,8 +536,12 @@ GNATBIND_OBJS = \\\n  ada/fname-uf.o   \\\n  ada/fname.o      \\\n  ada/libgnat/g-byorma.o   \\\n+ ada/libgnat/g-dynhta.o   \\\n+ ada/libgnat/g-graphs.o   \\\n  ada/libgnat/g-hesora.o   \\\n  ada/libgnat/g-htable.o   \\\n+ ada/libgnat/g-lists.o    \\\n+ ada/libgnat/g-sets.o     \\\n  ada/libgnat/gnat.o       \\\n  ada/gnatbind.o   \\\n  ada/gnatvsn.o    \\"}, {"sha": "41541c3423bf89aa167bcce0db0b55a005c8cd89", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -29,6 +29,7 @@ with Bcheck;   use Bcheck;\n with Binde;    use Binde;\n with Binderr;  use Binderr;\n with Bindgen;  use Bindgen;\n+with Bindo;    use Bindo;\n with Bindusg;\n with Casing;   use Casing;\n with Csets;\n@@ -878,11 +879,18 @@ begin\n \n       if Errors_Detected = 0 then\n          declare\n-            Elab_Order : Unit_Id_Table;\n             use Unit_Id_Tables;\n+            Elab_Order : Unit_Id_Table;\n \n          begin\n-            Find_Elab_Order (Elab_Order, First_Main_Lib_File);\n+            --  Use the invocation and library graph-based elaboration order\n+            --  when switch -d_N (new bindo order) is in effect.\n+\n+            if Debug_Flag_Underscore_NN then\n+               Find_Elaboration_Order (Elab_Order, First_Main_Lib_File);\n+            else\n+               Find_Elab_Order (Elab_Order, First_Main_Lib_File);\n+            end if;\n \n             if Errors_Detected = 0 and then not Check_Only then\n                Gen_Output_File\n@@ -892,12 +900,12 @@ begin\n          end;\n       end if;\n \n-      Total_Errors := Total_Errors + Errors_Detected;\n+      Total_Errors   := Total_Errors   + Errors_Detected;\n       Total_Warnings := Total_Warnings + Warnings_Detected;\n \n    exception\n       when Unrecoverable_Error =>\n-         Total_Errors := Total_Errors + Errors_Detected;\n+         Total_Errors   := Total_Errors   + Errors_Detected;\n          Total_Warnings := Total_Warnings + Warnings_Detected;\n    end;\n "}, {"sha": "ffd6a9001ea8e85c647535ed137b4723c1ef88f5", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -62,6 +62,63 @@ package body Lib.Writ is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Column (IS_Id : Invocation_Signature_Id) return Nat;\n+   pragma Inline (Column);\n+   --  Obtain attribute Column of an invocation signature with id IS_Id\n+\n+   function Extra (IR_Id : Invocation_Relation_Id) return Name_Id;\n+   pragma Inline (Extra);\n+   --  Obtain attribute Extra of an invocation relation with id IR_Id\n+\n+   function Invoker\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id;\n+   pragma Inline (Invoker);\n+   --  Obtain attribute Invoker of an invocation relation with id IR_Id\n+\n+   function Kind\n+     (IC_Id : Invocation_Construct_Id) return Invocation_Construct_Kind;\n+   pragma Inline (Kind);\n+   --  Obtain attribute Kind of an invocation construct with id IC_Id\n+\n+   function Kind (IR_Id : Invocation_Relation_Id) return Invocation_Kind;\n+   pragma Inline (Kind);\n+   --  Obtain attribute Kind of an invocation relation with id IR_Id\n+\n+   function Line (IS_Id : Invocation_Signature_Id) return Nat;\n+   pragma Inline (Line);\n+   --  Obtain attribute Line of an invocation signature with id IS_Id\n+\n+   function Locations (IS_Id : Invocation_Signature_Id) return Name_Id;\n+   pragma Inline (Locations);\n+   --  Obtain attribute Locations of an invocation signature with id IS_Id\n+\n+   function Name (IS_Id : Invocation_Signature_Id) return Name_Id;\n+   pragma Inline (Name);\n+   --  Obtain attribute Name of an invocation signature with id IS_Id\n+\n+   function Placement\n+     (IC_Id : Invocation_Construct_Id) return Body_Placement_Kind;\n+   pragma Inline (Placement);\n+   --  Obtain attribute Placement of an invocation construct with id IC_Id\n+\n+   function Present (N_Id : Name_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether a name with id N_Id exists\n+\n+   function Scope (IS_Id : Invocation_Signature_Id) return Name_Id;\n+   pragma Inline (Scope);\n+   --  Obtain attribute Scope of an invocation signature with id IS_Id\n+\n+   function Signature\n+     (IC_Id : Invocation_Construct_Id) return Invocation_Signature_Id;\n+   pragma Inline (Signature);\n+   --  Obtain attribute Signature of an invocation construct with id IC_Id\n+\n+   function Target\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id;\n+   pragma Inline (Target);\n+   --  Obtain attribute Target of an invocation relation with id IR_Id\n+\n    procedure Write_Unit_Name (N : Node_Id);\n    --  Used to write out the unit name for R (pragma Restriction) lines\n    --  for uses of Restriction (No_Dependence => unit-name).\n@@ -104,6 +161,16 @@ package body Lib.Writ is\n          OA_Setting             => 'O');\n    end Add_Preprocessing_Dependency;\n \n+   ------------\n+   -- Column --\n+   ------------\n+\n+   function Column (IS_Id : Invocation_Signature_Id) return Nat is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Column;\n+   end Column;\n+\n    ------------------------------\n    -- Ensure_System_Dependency --\n    ------------------------------\n@@ -185,6 +252,135 @@ package body Lib.Writ is\n       end;\n    end Ensure_System_Dependency;\n \n+   -----------\n+   -- Extra --\n+   -----------\n+\n+   function Extra (IR_Id : Invocation_Relation_Id) return Name_Id is\n+   begin\n+      pragma Assert (Present (IR_Id));\n+      return Invocation_Relations.Table (IR_Id).Extra;\n+   end Extra;\n+\n+   -------------\n+   -- Invoker --\n+   -------------\n+\n+   function Invoker\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id\n+   is\n+   begin\n+      pragma Assert (Present (IR_Id));\n+      return Invocation_Relations.Table (IR_Id).Invoker;\n+   end Invoker;\n+\n+   ----------\n+   -- Kind --\n+   ----------\n+\n+   function Kind\n+     (IC_Id : Invocation_Construct_Id) return Invocation_Construct_Kind\n+   is\n+   begin\n+      pragma Assert (Present (IC_Id));\n+      return Invocation_Constructs.Table (IC_Id).Kind;\n+   end Kind;\n+\n+   ----------\n+   -- Kind --\n+   ----------\n+\n+   function Kind (IR_Id : Invocation_Relation_Id) return Invocation_Kind is\n+   begin\n+      pragma Assert (Present (IR_Id));\n+      return Invocation_Relations.Table (IR_Id).Kind;\n+   end Kind;\n+\n+   ----------\n+   -- Line --\n+   ----------\n+\n+   function Line (IS_Id : Invocation_Signature_Id) return Nat is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Line;\n+   end Line;\n+\n+   ---------------\n+   -- Locations --\n+   ---------------\n+\n+   function Locations (IS_Id : Invocation_Signature_Id) return Name_Id is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Locations;\n+   end Locations;\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (IS_Id : Invocation_Signature_Id) return Name_Id is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Name;\n+   end Name;\n+\n+   ---------------\n+   -- Placement --\n+   ---------------\n+\n+   function Placement\n+     (IC_Id : Invocation_Construct_Id) return Body_Placement_Kind\n+   is\n+   begin\n+      pragma Assert (Present (IC_Id));\n+      return Invocation_Constructs.Table (IC_Id).Placement;\n+   end Placement;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (N_Id : Name_Id) return Boolean is\n+   begin\n+      return N_Id /= No_Name;\n+   end Present;\n+\n+   -----------\n+   -- Scope --\n+   -----------\n+\n+   function Scope (IS_Id : Invocation_Signature_Id) return Name_Id is\n+   begin\n+      pragma Assert (Present (IS_Id));\n+      return Invocation_Signatures.Table (IS_Id).Scope;\n+   end Scope;\n+\n+   ---------------\n+   -- Signature --\n+   ---------------\n+\n+   function Signature\n+     (IC_Id : Invocation_Construct_Id) return Invocation_Signature_Id\n+   is\n+   begin\n+      pragma Assert (Present (IC_Id));\n+      return Invocation_Constructs.Table (IC_Id).Signature;\n+   end Signature;\n+\n+   ------------\n+   -- Target --\n+   ------------\n+\n+   function Target\n+     (IR_Id : Invocation_Relation_Id) return Invocation_Signature_Id\n+   is\n+   begin\n+      pragma Assert (Present (IR_Id));\n+      return Invocation_Relations.Table (IR_Id).Target;\n+   end Target;\n+\n    ---------------\n    -- Write_ALI --\n    ---------------\n@@ -245,6 +441,9 @@ package body Lib.Writ is\n       --  this file (using Scan_ALI) and returns True. If no file exists,\n       --  or the file is not up to date, then False is returned.\n \n+      procedure Write_Invocation_Graph;\n+      --  Write out the invocation graph\n+\n       procedure Write_Unit_Information (Unit_Num : Unit_Number_Type);\n       --  Write out the library information for one unit for which code is\n       --  generated (includes unit line and with lines).\n@@ -433,6 +632,175 @@ package body Lib.Writ is\n          end loop;\n       end Update_Tables_From_ALI_File;\n \n+      ----------------------------\n+      -- Write_Invocation_Graph --\n+      ----------------------------\n+\n+      procedure Write_Invocation_Graph is\n+         procedure Write_Invocation_Construct\n+           (IC_Id : Invocation_Construct_Id);\n+         pragma Inline (Write_Invocation_Construct);\n+         --  Write invocation construct IC_Id to the ALI file\n+\n+         procedure Write_Invocation_Relation (IR_Id : Invocation_Relation_Id);\n+         pragma Inline (Write_Invocation_Relation);\n+         --  Write invocation relation IR_Id to the ALI file\n+\n+         procedure Write_Invocation_Signature\n+           (IS_Id : Invocation_Signature_Id);\n+         pragma Inline (Write_Invocation_Signature);\n+         --  Write invocation signature IS_Id to the ALI file\n+\n+         --------------------------------\n+         -- Write_Invocation_Construct --\n+         --------------------------------\n+\n+         procedure Write_Invocation_Construct\n+           (IC_Id : Invocation_Construct_Id)\n+         is\n+         begin\n+            --  G header\n+\n+            Write_Info_Initiate ('G');\n+            Write_Info_Char     (' ');\n+\n+            --  line-kind\n+\n+            Write_Info_Char\n+              (Invocation_Graph_Line_Kind_To_Code (Invocation_Construct_Line));\n+            Write_Info_Char (' ');\n+\n+            --  construct-kind\n+\n+            Write_Info_Char (Invocation_Construct_Kind_To_Code (Kind (IC_Id)));\n+            Write_Info_Char (' ');\n+\n+            --  construct-body-placement\n+\n+            Write_Info_Char (Body_Placement_Kind_To_Code (Placement (IC_Id)));\n+            Write_Info_Char (' ');\n+\n+            --  construct-signature\n+\n+            Write_Invocation_Signature (Signature (IC_Id));\n+            Write_Info_EOL;\n+         end Write_Invocation_Construct;\n+\n+         -------------------------------\n+         -- Write_Invocation_Relation --\n+         -------------------------------\n+\n+         procedure Write_Invocation_Relation\n+           (IR_Id : Invocation_Relation_Id)\n+         is\n+         begin\n+            --  G header\n+\n+            Write_Info_Initiate ('G');\n+            Write_Info_Char     (' ');\n+\n+            --  line-kind\n+\n+            Write_Info_Char\n+              (Invocation_Graph_Line_Kind_To_Code (Invocation_Relation_Line));\n+            Write_Info_Char (' ');\n+\n+            --  relation-kind\n+\n+            Write_Info_Char (Invocation_Kind_To_Code (Kind (IR_Id)));\n+            Write_Info_Char (' ');\n+\n+            --  (extra-name | \"none\")\n+\n+            if Present (Extra (IR_Id)) then\n+               Write_Info_Name (Extra (IR_Id));\n+            else\n+               Write_Info_Str (\"none\");\n+            end if;\n+\n+            Write_Info_Char (' ');\n+\n+            --  invoker-signature\n+\n+            Write_Invocation_Signature (Invoker (IR_Id));\n+            Write_Info_Char (' ');\n+\n+            --  target-signature\n+\n+            Write_Invocation_Signature (Target (IR_Id));\n+\n+            Write_Info_EOL;\n+         end Write_Invocation_Relation;\n+\n+         --------------------------------\n+         -- Write_Invocation_Signature --\n+         --------------------------------\n+\n+         procedure Write_Invocation_Signature\n+           (IS_Id : Invocation_Signature_Id)\n+         is\n+         begin\n+            --  [\n+\n+            Write_Info_Char ('[');\n+\n+            --  name\n+\n+            Write_Info_Name (Name (IS_Id));\n+            Write_Info_Char (' ');\n+\n+            --  scope\n+\n+            Write_Info_Name (Scope (IS_Id));\n+            Write_Info_Char (' ');\n+\n+            --  line\n+\n+            Write_Info_Nat  (Line (IS_Id));\n+            Write_Info_Char (' ');\n+\n+            --  column\n+\n+            Write_Info_Nat  (Column (IS_Id));\n+            Write_Info_Char (' ');\n+\n+            --  (locations | \"none\")\n+\n+            if Present (Locations (IS_Id)) then\n+               Write_Info_Name (Locations (IS_Id));\n+            else\n+               Write_Info_Str (\"none\");\n+            end if;\n+\n+            --  ]\n+\n+            Write_Info_Char (']');\n+         end Write_Invocation_Signature;\n+\n+      --  Start of processing for Write_Invocation_Graph\n+\n+      begin\n+         --  First write out all invocation constructs declared within the\n+         --  current unit. This ensures that when this invocation is read,\n+         --  the invocation constructs are materialized before they are\n+         --  referenced by invocation relations.\n+\n+         for IC_Id in Invocation_Constructs.First ..\n+                      Invocation_Constructs.Last\n+         loop\n+            Write_Invocation_Construct (IC_Id);\n+         end loop;\n+\n+         --  Write out all invocation relations that originate from invocation\n+         --  constructs delared in the current unit.\n+\n+         for IR_Id in Invocation_Relations.First ..\n+                      Invocation_Relations.Last\n+         loop\n+            Write_Invocation_Relation (IR_Id);\n+         end loop;\n+      end Write_Invocation_Graph;\n+\n       ----------------------------\n       -- Write_Unit_Information --\n       ----------------------------\n@@ -1618,6 +1986,10 @@ package body Lib.Writ is\n          end loop;\n       end;\n \n+      --  Output the invocation graph\n+\n+      Write_Invocation_Graph;\n+\n       --  Output cross-references\n \n       if Opt.Xref_Active then"}, {"sha": "c17233a726ebd9e0e6c61ca1fafe114d37ccb68b", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -846,6 +846,94 @@ package Lib.Writ is\n    --      dependency checking, but must be present for proper interpretation\n    --      of the cross-reference data.\n \n+   --  -------------------------\n+   --  -- G  Invocation Graph --\n+   --  -------------------------\n+\n+   --  An invocation graph line has the following format:\n+   --\n+   --    G line-kind line-attributes\n+   --\n+   --      Attribute line-kind is a Character which denotes the nature of the\n+   --      line. Table ALI.Invocation_Graph_Line_Codes lists all legal values.\n+   --\n+   --      Attribute line-attributes depends on the value of line-kind, and is\n+   --      contents are described further below.\n+   --\n+   --  An invocation signature uniquely identifies an invocation construct in\n+   --  the ALI file namespace, and has the following format:\n+   --\n+   --      [ name scope line column (locations | \"none\") ]\n+   --\n+   --      Attribute name is a String which denotes the name of the construct\n+   --\n+   --      Attribute scope is a String which denotes the qualified name of the\n+   --      scope where the construct is declared.\n+   --\n+   --      Attribute line is a Positive which denotes the line number where the\n+   --      initial declaration of the construct appears.\n+   --\n+   --      Attribute column is a Positive which denotes the column number where\n+   --      the initial declaration of the construct appears.\n+   --\n+   --      Attribute locations is a String which denotes the line and column\n+   --      locations of all instances where the initial declaration of the\n+   --      construct appears.\n+   --\n+   --  When the line-kind denotes an invocation construct, line-attributes are\n+   --  set as follows:\n+   --\n+   --      construct-kind construct-body-placement construct-signature\n+   --\n+   --      Attribute construct-kind is a Character which denotes the nature of\n+   --      the construct. Table ALI.Invocation_Construct_Codes lists all legal\n+   --      values.\n+   --\n+   --      Attribute construct-body-placement is a Character which denotes the\n+   --      placement of the construct's body within the unit. All legal values\n+   --      are listed in table ALI.Body_Placement_Codes.\n+   --\n+   --      Attribute construct-signature is the invocation signature of the\n+   --      construct.\n+   --\n+   --  When the line-kind denotes an invocation relation, line-attributes are\n+   --  set as follows:\n+   --\n+   --      relation-kind (extra-name | \"none\") invoker-signature\n+   --         target-signature\n+   --\n+   --      Attribute relation-kind is a Character which denotes the nature of\n+   --      the relation. All legal values are listed in ALI.Invocation_Codes.\n+   --\n+   --      Attribute extra-name is a String which denotes the name of an extra\n+   --      entity used for error diagnostics. The value of extra-name depends\n+   --      on the relation-kind as follows:\n+   --\n+   --        Accept_Alternative                     - related entry\n+   --        Access_Taken                           - related subprogram\n+   --        Call                                   - not present\n+   --        Controlled_Adjustment                  - related controlled type\n+   --        Controlled_Finalization                - related controlled type\n+   --        Controlled_Initialization              - related controlled type\n+   --        Default_Initial_Condition_Verification - related private type\n+   --        Initial_Condition_Verification         - not present\n+   --        Instantiation                          - not present\n+   --        Internal_Controlled_Adjustment         - related controlled type\n+   --        Internal_Controlled_Finalization       - related controlled type\n+   --        Internal_Controlled_Initialization     - related controlled type\n+   --        Invariant_Verification                 - related private type\n+   --        Postcondition_Verification             - related routine\n+   --        Protected_Entry_Call                   - not present\n+   --        Protected_Subprogram_Call              - not present\n+   --        Task_Activation                        - related task object\n+   --        Task_Entry_Call                        - not present\n+   --        Type_Initialization                    - related type\n+   --\n+   --      Attribute invoker-signature is the invocation signature of the\n+   --      invoker.\n+   --\n+   --      Attribute target-signature is the invocation signature of the target\n+\n    --------------------------\n    -- Cross-Reference Data --\n    --------------------------"}, {"sha": "84dcc3045782b415f04cd8931dd90f3231513078", "filename": "gcc/ada/libgnat/g-dynhta.adb", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -33,6 +33,34 @@ with Ada.Unchecked_Deallocation;\n \n package body GNAT.Dynamic_HTables is\n \n+   -------------------\n+   -- Hash_Two_Keys --\n+   -------------------\n+\n+   function Hash_Two_Keys\n+     (Left  : Bucket_Range_Type;\n+      Right : Bucket_Range_Type) return Bucket_Range_Type\n+   is\n+      Half : constant := 2 ** (Bucket_Range_Type'Size / 2);\n+      Mask : constant := Half - 1;\n+\n+   begin\n+      --  The hash is obtained in the following manner:\n+      --\n+      --    1) The low bits of Left are obtained, then shifted over to the high\n+      --       bits position.\n+      --\n+      --    2) The low bits of Right are obtained\n+      --\n+      --  The results from 1) and 2) are or-ed to produce a value within the\n+      --  range of Bucket_Range_Type.\n+\n+      return\n+        ((Left  and Mask) * Half)\n+            or\n+         (Right and Mask);\n+   end Hash_Two_Keys;\n+\n    -------------------\n    -- Static_HTable --\n    -------------------\n@@ -485,6 +513,32 @@ package body GNAT.Dynamic_HTables is\n       pragma Inline (Unlock);\n       --  Unlock all mutation functionality of hash table T\n \n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains\n+        (T   : Dynamic_Hash_Table;\n+         Key : Key_Type) return Boolean\n+      is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created (T);\n+\n+         --  Obtain the dummy head of the bucket which should house the\n+         --  key-value pair.\n+\n+         Head := Find_Bucket (T.Buckets, Key);\n+\n+         --  Try to find a node in the bucket which matches the key\n+\n+         Nod := Find_Node (Head, Key);\n+\n+         return Is_Valid (Nod, Head);\n+      end Contains;\n+\n       ------------\n       -- Create --\n       ------------"}, {"sha": "107c4c0c1f8afc4261247ffaf3b969cdcde7f96e", "filename": "gcc/ada/libgnat/g-dynhta.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -50,6 +50,12 @@ pragma Compiler_Unit_Warning;\n \n package GNAT.Dynamic_HTables is\n \n+   function Hash_Two_Keys\n+     (Left  : Bucket_Range_Type;\n+      Right : Bucket_Range_Type) return Bucket_Range_Type;\n+   pragma Inline (Hash_Two_Keys);\n+   --  Obtain the hash value of keys Left and Right\n+\n    -------------------\n    -- Static_HTable --\n    -------------------\n@@ -345,6 +351,11 @@ package GNAT.Dynamic_HTables is\n       type Dynamic_Hash_Table is private;\n       Nil : constant Dynamic_Hash_Table;\n \n+      function Contains\n+        (T   : Dynamic_Hash_Table;\n+         Key : Key_Type) return Boolean;\n+      --  Determine whether key Key exists in hash table T\n+\n       function Create (Initial_Size : Positive) return Dynamic_Hash_Table;\n       --  Create a new table with bucket capacity Initial_Size. This routine\n       --  must be called at the start of a hash table's lifetime."}, {"sha": "1049641ae5e3f10dafe8b3466d9d3a9de69f6185", "filename": "gcc/ada/libgnat/g-graphs.adb", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-graphs.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -262,7 +262,7 @@ package body GNAT.Graphs is\n       begin\n          Ensure_Created (G);\n \n-         return Get_Component_Attributes (G, Comp) /= No_Component_Attributes;\n+         return Component_Map.Contains (G.Components, Comp);\n       end Contains_Component;\n \n       -------------------\n@@ -276,7 +276,7 @@ package body GNAT.Graphs is\n       begin\n          Ensure_Created (G);\n \n-         return Get_Edge_Attributes (G, E) /= No_Edge_Attributes;\n+         return Edge_Map.Contains (G.All_Edges, E);\n       end Contains_Edge;\n \n       ---------------------\n@@ -290,7 +290,7 @@ package body GNAT.Graphs is\n       begin\n          Ensure_Created (G);\n \n-         return Get_Vertex_Attributes (G, V) /= No_Vertex_Attributes;\n+         return Vertex_Map.Contains (G.All_Vertices, V);\n       end Contains_Vertex;\n \n       ------------\n@@ -517,7 +517,7 @@ package body GNAT.Graphs is\n             --  Lowest visitation number\n \n             On_Stack : Boolean := False;\n-            --  Set when the library item appears in Stack\n+            --  Set when the corresponding vertex appears on the Stack\n          end record;\n \n          No_Tarjan_Attributes : constant Tarjan_Attributes :=\n@@ -673,11 +673,11 @@ package body GNAT.Graphs is\n          ------------------------\n \n          procedure Associate_Vertices (Comp : Component_Id) is\n-            Iter : Vertex_Iterator;\n+            Iter : Component_Vertex_Iterator;\n             V    : Vertex_Id;\n \n          begin\n-            Iter := Iterate_Vertices (G, Comp);\n+            Iter := Iterate_Component_Vertices (G, Comp);\n             while Has_Next (Iter) loop\n                Next (Iter, V);\n \n@@ -1150,18 +1150,18 @@ package body GNAT.Graphs is\n       -- Has_Next --\n       --------------\n \n-      function Has_Next (Iter : Outgoing_Edge_Iterator) return Boolean is\n+      function Has_Next (Iter : Component_Vertex_Iterator) return Boolean is\n       begin\n-         return Edge_Set.Has_Next (Edge_Set.Iterator (Iter));\n+         return Vertex_List.Has_Next (Vertex_List.Iterator (Iter));\n       end Has_Next;\n \n       --------------\n       -- Has_Next --\n       --------------\n \n-      function Has_Next (Iter : Vertex_Iterator) return Boolean is\n+      function Has_Next (Iter : Outgoing_Edge_Iterator) return Boolean is\n       begin\n-         return Vertex_List.Has_Next (Vertex_List.Iterator (Iter));\n+         return Edge_Set.Has_Next (Edge_Set.Iterator (Iter));\n       end Has_Next;\n \n       --------------\n@@ -1216,6 +1216,23 @@ package body GNAT.Graphs is\n          return Component_Iterator (Component_Map.Iterate (G.Components));\n       end Iterate_Components;\n \n+      --------------------------------\n+      -- Iterate_Component_Vertices --\n+      --------------------------------\n+\n+      function Iterate_Component_Vertices\n+        (G    : Directed_Graph;\n+         Comp : Component_Id) return Component_Vertex_Iterator\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, Comp);\n+\n+         return\n+           Component_Vertex_Iterator\n+             (Vertex_List.Iterate (Get_Vertices (G, Comp)));\n+      end Iterate_Component_Vertices;\n+\n       ----------------------------\n       -- Iterate_Outgoing_Edges --\n       ----------------------------\n@@ -1233,21 +1250,6 @@ package body GNAT.Graphs is\n              (Edge_Set.Iterate (Get_Outgoing_Edges (G, V)));\n       end Iterate_Outgoing_Edges;\n \n-      ----------------------\n-      -- Iterate_Vertices --\n-      ----------------------\n-\n-      function Iterate_Vertices\n-        (G    : Directed_Graph;\n-         Comp : Component_Id) return Vertex_Iterator\n-      is\n-      begin\n-         Ensure_Created (G);\n-         Ensure_Present (G, Comp);\n-\n-         return Vertex_Iterator (Vertex_List.Iterate (Get_Vertices (G, Comp)));\n-      end Iterate_Vertices;\n-\n       ----------\n       -- Next --\n       ----------\n@@ -1289,25 +1291,40 @@ package body GNAT.Graphs is\n       ----------\n \n       procedure Next\n-        (Iter : in out Outgoing_Edge_Iterator;\n-         E    : out Edge_Id)\n+        (Iter : in out Component_Vertex_Iterator;\n+         V    : out Vertex_Id)\n       is\n       begin\n-         Edge_Set.Next (Edge_Set.Iterator (Iter), E);\n+         Vertex_List.Next (Vertex_List.Iterator (Iter), V);\n       end Next;\n \n       ----------\n       -- Next --\n       ----------\n \n       procedure Next\n-        (Iter : in out Vertex_Iterator;\n-         V    : out Vertex_Id)\n+        (Iter : in out Outgoing_Edge_Iterator;\n+         E    : out Edge_Id)\n       is\n       begin\n-         Vertex_List.Next (Vertex_List.Iterator (Iter), V);\n+         Edge_Set.Next (Edge_Set.Iterator (Iter), E);\n       end Next;\n \n+      ----------------------------------\n+      -- Number_Of_Component_Vertices --\n+      ----------------------------------\n+\n+      function Number_Of_Component_Vertices\n+        (G    : Directed_Graph;\n+         Comp : Component_Id) return Natural\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, Comp);\n+\n+         return Vertex_List.Size (Get_Vertices (G, Comp));\n+      end Number_Of_Component_Vertices;\n+\n       --------------------------\n       -- Number_Of_Components --\n       --------------------------\n@@ -1330,6 +1347,21 @@ package body GNAT.Graphs is\n          return Edge_Map.Size (G.All_Edges);\n       end Number_Of_Edges;\n \n+      ------------------------------\n+      -- Number_Of_Outgoing_Edges --\n+      ------------------------------\n+\n+      function Number_Of_Outgoing_Edges\n+        (G : Directed_Graph;\n+         V : Vertex_Id) return Natural\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, V);\n+\n+         return Edge_Set.Size (Get_Outgoing_Edges (G, V));\n+      end Number_Of_Outgoing_Edges;\n+\n       ------------------------\n       -- Number_Of_Vertices --\n       ------------------------"}, {"sha": "3b6552212923385b68b90b90a7491bee42072d00", "filename": "gcc/ada/libgnat/g-graphs.ads", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-graphs.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -45,7 +45,7 @@ package GNAT.Graphs is\n    --  (referred to as simply \"component\") in a graph.\n \n    type Component_Id is new Natural;\n-   No_Component : constant Component_Id;\n+   No_Component : constant Component_Id := Component_Id'First;\n \n    function Hash_Component (Comp : Component_Id) return Bucket_Range_Type;\n    --  Map component Comp into the range of buckets\n@@ -230,12 +230,22 @@ package GNAT.Graphs is\n       function Is_Empty (G : Directed_Graph) return Boolean;\n       --  Determine whether graph G is empty\n \n+      function Number_Of_Component_Vertices\n+        (G    : Directed_Graph;\n+         Comp : Component_Id) return Natural;\n+      --  Obtain the total number of vertices of component Comp of graph G\n+\n       function Number_Of_Components (G : Directed_Graph) return Natural;\n       --  Obtain the total number of components of graph G\n \n       function Number_Of_Edges (G : Directed_Graph) return Natural;\n       --  Obtain the total number of edges of graph G\n \n+      function Number_Of_Outgoing_Edges\n+        (G : Directed_Graph;\n+         V : Vertex_Id) return Natural;\n+      --  Obtain the total number of outgoing edges of vertex V of graph G\n+\n       function Number_Of_Vertices (G : Directed_Graph) return Natural;\n       --  Obtain the total number of vertices of graph G\n \n@@ -329,6 +339,29 @@ package GNAT.Graphs is\n       --    * Iterator_Exhausted, when the iterator has been exhausted and\n       --      further attempts are made to advance it.\n \n+      --  The following type prepresents an iterator over all vertices of a\n+      --  component.\n+\n+      type Component_Vertex_Iterator is private;\n+\n+      function Has_Next (Iter : Component_Vertex_Iterator) return Boolean;\n+      --  Determine whether iterator Iter has more vertices to examine\n+\n+      function Iterate_Component_Vertices\n+        (G    : Directed_Graph;\n+         Comp : Component_Id) return Component_Vertex_Iterator;\n+      --  Obtain an iterator over all vertices that comprise component Comp of\n+      --  graph G.\n+\n+      procedure Next\n+        (Iter : in out Component_Vertex_Iterator;\n+         V    : out Vertex_Id);\n+      --  Return the current vertex referenced by iterator Iter and advance to\n+      --  the next vertex. This action raises the following exceptions:\n+      --\n+      --    * Iterator_Exhausted, when the iterator has been exhausted and\n+      --      further attempts are made to advance it.\n+\n       --  The following type represents an iterator over all outgoing edges of\n       --  a vertex.\n \n@@ -353,29 +386,6 @@ package GNAT.Graphs is\n       --    * Iterator_Exhausted, when the iterator has been exhausted and\n       --      further attempts are made to advance it.\n \n-      --  The following type prepresents an iterator over all vertices of a\n-      --  component.\n-\n-      type Vertex_Iterator is private;\n-\n-      function Has_Next (Iter : Vertex_Iterator) return Boolean;\n-      --  Determine whether iterator Iter has more vertices to examine\n-\n-      function Iterate_Vertices\n-        (G    : Directed_Graph;\n-         Comp : Component_Id) return Vertex_Iterator;\n-      --  Obtain an iterator over all vertices that comprise component Comp of\n-      --  graph G.\n-\n-      procedure Next\n-        (Iter : in out Vertex_Iterator;\n-         V    : out Vertex_Id);\n-      --  Return the current vertex referenced by iterator Iter and advance to\n-      --  the next vertex. This action raises the following exceptions:\n-      --\n-      --    * Iterator_Exhausted, when the iterator has been exhausted and\n-      --      further attempts are made to advance it.\n-\n    private\n       pragma Unreferenced (No_Edge);\n \n@@ -513,15 +523,14 @@ package GNAT.Graphs is\n       -- Iterators --\n       ---------------\n \n-      type All_Edge_Iterator      is new Edge_Map.Iterator;\n-      type All_Vertex_Iterator    is new Vertex_Map.Iterator;\n-      type Component_Iterator     is new Component_Map.Iterator;\n-      type Outgoing_Edge_Iterator is new Edge_Set.Iterator;\n-      type Vertex_Iterator        is new Vertex_List.Iterator;\n+      type All_Edge_Iterator         is new Edge_Map.Iterator;\n+      type All_Vertex_Iterator       is new Vertex_Map.Iterator;\n+      type Component_Iterator        is new Component_Map.Iterator;\n+      type Component_Vertex_Iterator is new Vertex_List.Iterator;\n+      type Outgoing_Edge_Iterator    is new Edge_Set.Iterator;\n    end Directed_Graphs;\n \n private\n-   No_Component    : constant Component_Id := Component_Id'First;\n    First_Component : constant Component_Id := No_Component + 1;\n \n end GNAT.Graphs;"}, {"sha": "b58888043aeed6ec58f396cadb372298fd98aa70", "filename": "gcc/ada/libgnat/g-sets.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-sets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Flibgnat%2Fg-sets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sets.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -46,7 +46,7 @@ package body GNAT.Sets is\n          Elem : Element_Type) return Boolean\n       is\n       begin\n-         return Hashed_Set.Get (Hashed_Set.Dynamic_Hash_Table (S), Elem);\n+         return Hashed_Set.Contains (Hashed_Set.Dynamic_Hash_Table (S), Elem);\n       end Contains;\n \n       ------------"}, {"sha": "51c7cf46302d3b9a359c2f5fee8865344b8e427b", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -1497,6 +1497,24 @@ package body Namet is\n       return N1 = N2 or else Get_Name_String (N1) = Get_Name_String (N2);\n    end Name_Equals;\n \n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (Nam : File_Name_Type) return Boolean is\n+   begin\n+      return Nam /= No_File;\n+   end Present;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (Nam : Name_Id) return Boolean is\n+   begin\n+      return Nam /= No_Name;\n+   end Present;\n+\n    ------------------\n    -- Reinitialize --\n    ------------------"}, {"sha": "a788b55256f5f0e9e9db7469c1392c56f49503e0", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -204,6 +204,10 @@ package Namet is\n    subtype Valid_Name_Id is Name_Id range First_Name_Id .. Name_Id'Last;\n    --  All but No_Name and Error_Name\n \n+   function Present (Nam : Name_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether name Nam exists\n+\n    ------------------------------\n    -- Name_Id Membership Tests --\n    ------------------------------\n@@ -626,6 +630,10 @@ package Namet is\n    --  Constant used to indicate no file is present (this is used for example\n    --  when a search for a file indicates that no file of the name exists).\n \n+   function Present (Nam : File_Name_Type) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether file name Nam exists\n+\n    Error_File_Name : constant File_Name_Type := File_Name_Type (Error_Name);\n    --  The special File_Name_Type value Error_File_Name is used to indicate\n    --  a unit name where some previous processing has found an error."}, {"sha": "47ad8743571b13cd04070c38d9a8facf45a0e5fb", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -3155,7 +3155,7 @@ package Rtsfind is\n    --  immediately, since obviously Ent cannot be the entity in question if the\n    --  corresponding unit has not been loaded.\n \n-   function Is_RTU (Ent : Entity_Id;  U : RTU_Id) return Boolean;\n+   function Is_RTU (Ent : Entity_Id; U : RTU_Id) return Boolean;\n    pragma Inline (Is_RTU);\n    --  This function determines if the given entity corresponds to the entity\n    --  for the unit referenced by U. If this unit has not been loaded, the"}, {"sha": "bf85b2810202f5feceea7c4a2615e180137c5322", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -3473,6 +3473,17 @@ package body Sem_Ch12 is\n    begin\n       Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n \n+      --  A generic may grant access to its private enclosing context depending\n+      --  on the placement of its corresponding body. From elaboration point of\n+      --  view, the flow of execution may enter this private context, and then\n+      --  reach an external unit, thus producing a dependency on that external\n+      --  unit. For such a path to be properly discovered and encoded in the\n+      --  ALI file of the main unit, let the ABE mechanism process the body of\n+      --  the main unit, and encode all relevant invocation constructs and the\n+      --  relations between them.\n+\n+      Mark_Save_Invocation_Graph_Of_Body;\n+\n       --  We introduce a renaming of the enclosing package, to have a usable\n       --  entity as the prefix of an expanded name for a local entity of the\n       --  form Par.P.Q, where P is the generic package. This is because a local\n@@ -3668,6 +3679,17 @@ package body Sem_Ch12 is\n    begin\n       Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n \n+      --  A generic may grant access to its private enclosing context depending\n+      --  on the placement of its corresponding body. From elaboration point of\n+      --  view, the flow of execution may enter this private context, and then\n+      --  reach an external unit, thus producing a dependency on that external\n+      --  unit. For such a path to be properly discovered and encoded in the\n+      --  ALI file of the main unit, let the ABE mechanism process the body of\n+      --  the main unit, and encode all relevant invocation constructs and the\n+      --  relations between them.\n+\n+      Mark_Save_Invocation_Graph_Of_Body;\n+\n       --  Create copy of generic unit, and save for instantiation. If the unit\n       --  is a child unit, do not copy the specifications for the parent, which\n       --  are not part of the generic tree.\n@@ -3899,8 +3921,8 @@ package body Sem_Ch12 is\n       --  Local declarations\n \n       Gen_Id         : constant Node_Id    := Name (N);\n-      Is_Actual_Pack : constant Boolean    :=\n-                         Is_Internal (Defining_Entity (N));\n+      Inst_Id        : constant Entity_Id  := Defining_Entity (N);\n+      Is_Actual_Pack : constant Boolean    := Is_Internal (Inst_Id);\n       Loc            : constant Source_Ptr := Sloc (N);\n \n       Saved_GM   : constant Ghost_Mode_Type := Ghost_Mode;\n@@ -4109,6 +4131,9 @@ package body Sem_Ch12 is\n          goto Leave;\n \n       else\n+         Set_Ekind (Inst_Id, E_Package);\n+         Set_Scope (Inst_Id, Current_Scope);\n+\n          --  If the context of the instance is subject to SPARK_Mode \"off\" or\n          --  the annotation is altogether missing, set the global flag which\n          --  signals Analyze_Pragma to ignore all SPARK_Mode pragmas within\n@@ -5156,14 +5181,13 @@ package body Sem_Ch12 is\n      (N : Node_Id;\n       K : Entity_Kind)\n    is\n-      Loc    : constant Source_Ptr := Sloc (N);\n-      Gen_Id : constant Node_Id    := Name (N);\n-      Errs   : constant Nat        := Serious_Errors_Detected;\n-\n-      Anon_Id : constant Entity_Id :=\n-                  Make_Defining_Identifier (Sloc (Defining_Entity (N)),\n-                    Chars => New_External_Name\n-                               (Chars (Defining_Entity (N)), 'R'));\n+      Errs    : constant Nat        := Serious_Errors_Detected;\n+      Gen_Id  : constant Node_Id    := Name (N);\n+      Inst_Id : constant Entity_Id  := Defining_Entity (N);\n+      Anon_Id : constant Entity_Id  :=\n+                  Make_Defining_Identifier (Sloc (Inst_Id),\n+                    Chars => New_External_Name (Chars (Inst_Id), 'R'));\n+      Loc     : constant Source_Ptr := Sloc (N);\n \n       Act_Decl_Id : Entity_Id := Empty; -- init to avoid warning\n       Act_Decl    : Node_Id;\n@@ -5489,6 +5513,9 @@ package body Sem_Ch12 is\n          Error_Msg_NE (\"instantiation of & within itself\", N, Gen_Unit);\n \n       else\n+         Set_Ekind (Inst_Id, K);\n+         Set_Scope (Inst_Id, Current_Scope);\n+\n          Set_Entity (Gen_Id, Gen_Unit);\n          Set_Is_Instantiated (Gen_Unit);\n "}, {"sha": "5f515bcf42299c14a0d87dc1510cf10dfec9f7ec", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -5489,8 +5489,10 @@ package body Sem_Ch8 is\n \n       if Nkind (N) = N_Identifier then\n          Mark_Elaboration_Attributes\n-           (N_Id  => N,\n-            Modes => True);\n+           (N_Id     => N,\n+            Checks   => True,\n+            Modes    => True,\n+            Warnings => True);\n       end if;\n \n       --  Here if Entity pointer was not set, we need full visibility analysis\n@@ -6514,8 +6516,10 @@ package body Sem_Ch8 is\n       --  resolution, and expansion are over.\n \n       Mark_Elaboration_Attributes\n-        (N_Id  => N,\n-         Modes => True);\n+        (N_Id     => N,\n+         Checks   => True,\n+         Modes    => True,\n+         Warnings => True);\n \n       --  Set appropriate type\n "}, {"sha": "f57b3b1151ab92e11ec21f47f2e104155659b92a", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 12485, "deletions": 8128, "changes": 20613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556"}, {"sha": "f47d5254f3b15ede1a92adcfe760d0175fe4638c", "filename": "gcc/ada/sem_elab.ads", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_elab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_elab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -30,25 +30,9 @@ with Types; use Types;\n \n package Sem_Elab is\n \n-   procedure Build_Call_Marker (N : Node_Id);\n-   --  Create a call marker for call or requeue statement N and record it for\n-   --  later processing by the ABE mechanism.\n-\n-   procedure Build_Variable_Reference_Marker\n-     (N     : Node_Id;\n-      Read  : Boolean;\n-      Write : Boolean);\n-   --  Create a variable reference marker for arbitrary node N if it mentions a\n-   --  variable, and record it for later processing by the ABE mechanism. Flag\n-   --  Read should be set when the reference denotes a read. Flag Write should\n-   --  be set when the reference denotes a write.\n-\n-   procedure Check_Elaboration_Scenarios;\n-   --  Examine each scenario recorded during analysis/resolution and apply the\n-   --  Ada or SPARK elaboration rules taking into account the model in effect.\n-   --  This processing detects and diagnoses ABE issues, installs conditional\n-   --  ABE checks or guaranteed ABE failures, and ensures the elaboration of\n-   --  units.\n+   -----------\n+   -- Types --\n+   -----------\n \n    --  The following type classifies the various enclosing levels used in ABE\n    --  diagnostics.\n@@ -64,24 +48,24 @@ package Sem_Elab is\n       --          package Nested is              --  enclosing package ignored\n       --             X ...                       --  at declaration level\n \n-      Generic_Package_Spec,\n-      Generic_Package_Body,\n-      --  A construct is at the \"generic library level\" when it appears in a\n+      Generic_Spec_Level,\n+      Generic_Body_Level,\n+      --  A construct is at the \"generic level\" when it appears in a\n       --  generic package library unit, ignoring enclosing packages. Example:\n \n       --    generic\n       --    package Pack is                      --  generic package spec\n       --       package Nested is                 --  enclosing package ignored\n       --          X ...                          --  at generic library level\n \n-      Instantiation,\n+      Instantiation_Level,\n       --  A construct is at the \"instantiation library level\" when it appears\n       --  in a library unit which is also an instantiation. Example:\n \n       --    package Inst is new Gen;             --  at instantiation level\n \n-      Package_Spec,\n-      Package_Body,\n+      Library_Spec_Level,\n+      Library_Body_Level,\n       --  A construct is at the \"library level\" when it appears in a package\n       --  library unit, ignoring enclosing packages. Example:\n \n@@ -93,26 +77,46 @@ package Sem_Elab is\n       --  This value is used to indicate that none of the levels above are in\n       --  effect.\n \n-   subtype Any_Library_Level is Enclosing_Level_Kind range\n-     Generic_Package_Spec ..\n-     Package_Body;\n-\n-   subtype Generic_Library_Level is Enclosing_Level_Kind range\n-     Generic_Package_Spec ..\n-     Generic_Package_Body;\n+   subtype Generic_Level is Enclosing_Level_Kind range\n+     Generic_Spec_Level ..\n+     Generic_Body_Level;\n \n    subtype Library_Level is Enclosing_Level_Kind range\n-     Package_Spec ..\n-     Package_Body;\n+     Library_Spec_Level ..\n+     Library_Body_Level;\n \n    subtype Library_Or_Instantiation_Level is Enclosing_Level_Kind range\n-     Instantiation ..\n-     Package_Body;\n+     Instantiation_Level ..\n+     Library_Body_Level;\n+\n+   procedure Build_Call_Marker (N : Node_Id);\n+   pragma Inline (Build_Call_Marker);\n+   --  Create a call marker for call or requeue statement N and record it for\n+   --  later processing by the ABE mechanism.\n+\n+   procedure Build_Variable_Reference_Marker\n+     (N     : Node_Id;\n+      Read  : Boolean;\n+      Write : Boolean);\n+   pragma Inline (Build_Variable_Reference_Marker);\n+   --  Create a variable reference marker for arbitrary node N if it mentions a\n+   --  variable, and record it for later processing by the ABE mechanism. Flag\n+   --  Read should be set when the reference denotes a read. Flag Write should\n+   --  be set when the reference denotes a write.\n+\n+   procedure Check_Elaboration_Scenarios;\n+   --  Examine each scenario recorded during analysis/resolution and apply the\n+   --  Ada or SPARK elaboration rules taking into account the model in effect.\n+   --  This processing detects and diagnoses ABE issues, installs conditional\n+   --  ABE checks or guaranteed ABE failures, and ensures the elaboration of\n+   --  units.\n \n    function Find_Enclosing_Level (N : Node_Id) return Enclosing_Level_Kind;\n+   pragma Inline (Find_Enclosing_Level);\n    --  Determine the enclosing level of arbitrary node N\n \n    procedure Initialize;\n+   pragma Inline (Initialize);\n    --  Initialize the internal structures of this unit\n \n    procedure Kill_Elaboration_Scenario (N : Node_Id);\n@@ -121,9 +125,10 @@ package Sem_Elab is\n    --  dead code.\n \n    procedure Record_Elaboration_Scenario (N : Node_Id);\n+   pragma Inline (Record_Elaboration_Scenario);\n    --  Determine whether atribtray node N denotes a scenario which requires\n-   --  ABE diagnostics or runtime checks. If this is the case, store N into\n-   --  a table for later processing.\n+   --  ABE diagnostics or runtime checks. If this is the case, store N for\n+   --  later processing.\n \n    ---------------------------------------------------------------------------\n    --                                                                       --"}, {"sha": "b499dbd158400e4aaca2710bb16acbb8188483dc", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -9861,6 +9861,17 @@ package body Sem_Prag is\n       --  Start of processing for Process_Inline\n \n       begin\n+         --  An inlined subprogram may grant access to its private enclosing\n+         --  context depending on the placement of its body. From elaboration\n+         --  point of view, the flow of execution may enter this private\n+         --  context, and then reach an external unit, thus producing a\n+         --  dependency on that external unit. For such a path to be properly\n+         --  discovered and encoded in the ALI file of the main unit, let the\n+         --  ABE mechanism process the body of the main unit, and encode all\n+         --  relevant invocation constructs and the relations between them.\n+\n+         Mark_Save_Invocation_Graph_Of_Body;\n+\n          Check_No_Identifiers;\n          Check_At_Least_N_Arguments (1);\n "}, {"sha": "77eefdc25c39083279d6652a1ef67e0f2923425e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 81, "deletions": 42, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -6721,33 +6721,26 @@ package body Sem_Util is\n    -- Enclosing_Generic_Body --\n    ----------------------------\n \n-   function Enclosing_Generic_Body\n-     (N : Node_Id) return Node_Id\n-   is\n-      P    : Node_Id;\n-      Decl : Node_Id;\n-      Spec : Node_Id;\n+   function Enclosing_Generic_Body (N : Node_Id) return Node_Id is\n+      Par     : Node_Id;\n+      Spec_Id : Entity_Id;\n \n    begin\n-      P := Parent (N);\n-      while Present (P) loop\n-         if Nkind (P) = N_Package_Body\n-           or else Nkind (P) = N_Subprogram_Body\n-         then\n-            Spec := Corresponding_Spec (P);\n-\n-            if Present (Spec) then\n-               Decl := Unit_Declaration_Node (Spec);\n+      Par := Parent (N);\n+      while Present (Par) loop\n+         if Nkind_In (Par, N_Package_Body, N_Subprogram_Body) then\n+            Spec_Id := Corresponding_Spec (Par);\n \n-               if Nkind (Decl) = N_Generic_Package_Declaration\n-                 or else Nkind (Decl) = N_Generic_Subprogram_Declaration\n-               then\n-                  return P;\n-               end if;\n+            if Present (Spec_Id)\n+              and then Nkind_In (Unit_Declaration_Node (Spec_Id),\n+                                 N_Generic_Package_Declaration,\n+                                 N_Generic_Subprogram_Declaration)\n+            then\n+               return Par;\n             end if;\n          end if;\n \n-         P := Parent (P);\n+         Par := Parent (Par);\n       end loop;\n \n       return Empty;\n@@ -6757,38 +6750,34 @@ package body Sem_Util is\n    -- Enclosing_Generic_Unit --\n    ----------------------------\n \n-   function Enclosing_Generic_Unit\n-     (N : Node_Id) return Node_Id\n-   is\n-      P    : Node_Id;\n-      Decl : Node_Id;\n-      Spec : Node_Id;\n+   function Enclosing_Generic_Unit (N : Node_Id) return Node_Id is\n+      Par       : Node_Id;\n+      Spec_Decl : Node_Id;\n+      Spec_Id   : Entity_Id;\n \n    begin\n-      P := Parent (N);\n-      while Present (P) loop\n-         if Nkind (P) = N_Generic_Package_Declaration\n-           or else Nkind (P) = N_Generic_Subprogram_Declaration\n+      Par := Parent (N);\n+      while Present (Par) loop\n+         if Nkind_In (Par, N_Generic_Package_Declaration,\n+                           N_Generic_Subprogram_Declaration)\n          then\n-            return P;\n+            return Par;\n \n-         elsif Nkind (P) = N_Package_Body\n-           or else Nkind (P) = N_Subprogram_Body\n-         then\n-            Spec := Corresponding_Spec (P);\n+         elsif Nkind_In (Par, N_Package_Body, N_Subprogram_Body) then\n+            Spec_Id := Corresponding_Spec (Par);\n \n-            if Present (Spec) then\n-               Decl := Unit_Declaration_Node (Spec);\n+            if Present (Spec_Id) then\n+               Spec_Decl := Unit_Declaration_Node (Spec_Id);\n \n-               if Nkind (Decl) = N_Generic_Package_Declaration\n-                 or else Nkind (Decl) = N_Generic_Subprogram_Declaration\n+               if Nkind_In (Spec_Decl, N_Generic_Package_Declaration,\n+                                       N_Generic_Subprogram_Declaration)\n                then\n-                  return Decl;\n+                  return Spec_Decl;\n                end if;\n             end if;\n          end if;\n \n-         P := Parent (P);\n+         Par := Parent (Par);\n       end loop;\n \n       return Empty;\n@@ -7579,6 +7568,18 @@ package body Sem_Util is\n       end loop;\n    end Examine_Array_Bounds;\n \n+   -------------------\n+   -- Exceptions_OK --\n+   -------------------\n+\n+   function Exceptions_OK return Boolean is\n+   begin\n+      return\n+        not (Restriction_Active (No_Exception_Handlers)    or else\n+             Restriction_Active (No_Exception_Propagation) or else\n+             Restriction_Active (No_Exceptions));\n+   end Exceptions_OK;\n+\n    --------------------------\n    -- Explain_Limited_Type --\n    --------------------------\n@@ -18900,6 +18901,44 @@ package body Sem_Util is\n       end if;\n    end Mark_Elaboration_Attributes;\n \n+   ----------------------------------------\n+   -- Mark_Save_Invocation_Graph_Of_Body --\n+   ----------------------------------------\n+\n+   procedure Mark_Save_Invocation_Graph_Of_Body is\n+      Main      : constant Node_Id := Cunit (Main_Unit);\n+      Main_Unit : constant Node_Id := Unit (Main);\n+      Aux_Id    : Entity_Id;\n+\n+   begin\n+      Set_Save_Invocation_Graph_Of_Body (Main);\n+\n+      --  Assume that the main unit does not have a complimentary unit\n+\n+      Aux_Id := Empty;\n+\n+      --  Obtain the complimentary unit of the main unit\n+\n+      if Nkind_In (Main_Unit, N_Generic_Package_Declaration,\n+                              N_Generic_Subprogram_Declaration,\n+                              N_Package_Declaration,\n+                              N_Subprogram_Declaration)\n+      then\n+         Aux_Id := Corresponding_Body (Main_Unit);\n+\n+      elsif Nkind_In (Main_Unit, N_Package_Body,\n+                                 N_Subprogram_Body,\n+                                 N_Subprogram_Renaming_Declaration)\n+      then\n+         Aux_Id := Corresponding_Spec (Main_Unit);\n+      end if;\n+\n+      if Present (Aux_Id) then\n+         Set_Save_Invocation_Graph_Of_Body\n+           (Parent (Unit_Declaration_Node (Aux_Id)));\n+      end if;\n+   end Mark_Save_Invocation_Graph_Of_Body;\n+\n    ----------------------------------\n    -- Matching_Static_Array_Bounds --\n    ----------------------------------"}, {"sha": "3f8d2e75d68d2dc9dae060e081bcccfe1f13e29c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -708,6 +708,10 @@ package Sem_Util is\n    --  If no suitable entity is available, return Empty. This routine carries\n    --  out actions that are tied to SPARK semantics.\n \n+   function Exceptions_OK return Boolean;\n+   --  Determine whether exceptions are allowed to be caught, propagated, or\n+   --  raised.\n+\n    procedure Explain_Limited_Type (T : Entity_Id; N : Node_Id);\n    --  This procedure is called after issuing a message complaining about an\n    --  inappropriate use of limited type T. If useful, it adds additional\n@@ -2182,6 +2186,10 @@ package Sem_Util is\n    --    Modes    - Save the Ghost and SPARK modes in effect (if applicable)\n    --    Warnings - Save the status of Elab_Warnings\n \n+   procedure Mark_Save_Invocation_Graph_Of_Body;\n+   --  Notify the body of the main unit that the invocation constructs and\n+   --  relations expressed within it must be recorded by the ABE mechanism.\n+\n    function Matching_Static_Array_Bounds\n      (L_Typ : Node_Id;\n       R_Typ : Node_Id) return Boolean;"}, {"sha": "d24938c2ed72e3254d9147d21c1264c8e1a23a24", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -1913,7 +1913,8 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Package_Instantiation\n         or else NT (N).Nkind = N_Procedure_Call_Statement\n         or else NT (N).Nkind = N_Procedure_Instantiation\n-        or else NT (N).Nkind = N_Requeue_Statement);\n+        or else NT (N).Nkind = N_Requeue_Statement\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n       return Flag1 (N);\n    end Is_Elaboration_Checks_OK_Node;\n \n@@ -1932,12 +1933,15 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Attribute_Reference\n         or else NT (N).Nkind = N_Call_Marker\n         or else NT (N).Nkind = N_Entry_Call_Statement\n+        or else NT (N).Nkind = N_Expanded_Name\n         or else NT (N).Nkind = N_Function_Call\n         or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Identifier\n         or else NT (N).Nkind = N_Package_Instantiation\n         or else NT (N).Nkind = N_Procedure_Call_Statement\n         or else NT (N).Nkind = N_Procedure_Instantiation\n-        or else NT (N).Nkind = N_Requeue_Statement);\n+        or else NT (N).Nkind = N_Requeue_Statement\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n       return Flag3 (N);\n    end Is_Elaboration_Warnings_OK_Node;\n \n@@ -2130,7 +2134,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Variable_Reference_Marker);\n-      return Flag1 (N);\n+      return Flag4 (N);\n    end Is_Read;\n \n    function Is_Source_Call\n@@ -2156,7 +2160,8 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Package_Instantiation\n         or else NT (N).Nkind = N_Procedure_Call_Statement\n         or else NT (N).Nkind = N_Procedure_Instantiation\n-        or else NT (N).Nkind = N_Requeue_Statement);\n+        or else NT (N).Nkind = N_Requeue_Statement\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n       return Flag2 (N);\n    end Is_SPARK_Mode_On_Node;\n \n@@ -2216,7 +2221,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Variable_Reference_Marker);\n-      return Flag2 (N);\n+      return Flag5 (N);\n    end Is_Write;\n \n    function Iteration_Scheme\n@@ -3091,6 +3096,14 @@ package body Sinfo is\n       return Flag18 (N);\n    end Rounded_Result;\n \n+   function Save_Invocation_Graph_Of_Body\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Compilation_Unit);\n+      return Flag1 (N);\n+   end Save_Invocation_Graph_Of_Body;\n+\n    function SCIL_Controlling_Tag\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -5387,7 +5400,8 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Package_Instantiation\n         or else NT (N).Nkind = N_Procedure_Call_Statement\n         or else NT (N).Nkind = N_Procedure_Instantiation\n-        or else NT (N).Nkind = N_Requeue_Statement);\n+        or else NT (N).Nkind = N_Requeue_Statement\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n       Set_Flag1 (N, Val);\n    end Set_Is_Elaboration_Checks_OK_Node;\n \n@@ -5406,12 +5420,15 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Attribute_Reference\n         or else NT (N).Nkind = N_Call_Marker\n         or else NT (N).Nkind = N_Entry_Call_Statement\n+        or else NT (N).Nkind = N_Expanded_Name\n         or else NT (N).Nkind = N_Function_Call\n         or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Identifier\n         or else NT (N).Nkind = N_Package_Instantiation\n         or else NT (N).Nkind = N_Procedure_Call_Statement\n         or else NT (N).Nkind = N_Procedure_Instantiation\n-        or else NT (N).Nkind = N_Requeue_Statement);\n+        or else NT (N).Nkind = N_Requeue_Statement\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n       Set_Flag3 (N, Val);\n    end Set_Is_Elaboration_Warnings_OK_Node;\n \n@@ -5604,7 +5621,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Variable_Reference_Marker);\n-      Set_Flag1 (N, Val);\n+      Set_Flag4 (N, Val);\n    end Set_Is_Read;\n \n    procedure Set_Is_Source_Call\n@@ -5630,7 +5647,8 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Package_Instantiation\n         or else NT (N).Nkind = N_Procedure_Call_Statement\n         or else NT (N).Nkind = N_Procedure_Instantiation\n-        or else NT (N).Nkind = N_Requeue_Statement);\n+        or else NT (N).Nkind = N_Requeue_Statement\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n       Set_Flag2 (N, Val);\n    end Set_Is_SPARK_Mode_On_Node;\n \n@@ -5692,7 +5710,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Variable_Reference_Marker);\n-      Set_Flag2 (N, Val);\n+      Set_Flag5 (N, Val);\n    end Set_Is_Write;\n \n    procedure Set_Iteration_Scheme\n@@ -6567,6 +6585,14 @@ package body Sinfo is\n       Set_Flag18 (N, Val);\n    end Set_Rounded_Result;\n \n+   procedure Set_Save_Invocation_Graph_Of_Body\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Compilation_Unit);\n+      Set_Flag1 (N, Val);\n+   end Set_Save_Invocation_Graph_Of_Body;\n+\n    procedure Set_SCIL_Controlling_Tag\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "75883f015befadc0d9a15bf7610d09ef790bf46e", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -1762,6 +1762,7 @@ package Sinfo is\n    --      procedure call statement\n    --      procedure instantiation\n    --      requeue statement\n+   --      variable reference marker\n    --\n    --    Set when the node appears within a context which allows the generation\n    --    of run-time ABE checks. This flag detemines whether the ABE Processing\n@@ -1778,12 +1779,15 @@ package Sinfo is\n    --      attribute reference\n    --      call marker\n    --      entry call statement\n+   --      expanded name\n    --      function call\n    --      function instantiation\n+   --      identifier\n    --      package instantiation\n    --      procedure call statement\n    --      procedure instantiation\n    --      requeue statement\n+   --      variable reference marker\n    --\n    --    Set when the node appears within a context where elaboration warnings\n    --    are enabled. This flag determines whether the ABE processing phase\n@@ -1941,7 +1945,7 @@ package Sinfo is\n    --    the resolution of accidental overloading of binary or unary operators\n    --    which may occur in instances.\n \n-   --  Is_Read (Flag1-Sem)\n+   --  Is_Read (Flag4-Sem)\n    --    Present in variable reference markers. Set when the original variable\n    --    reference constitues a read of the variable.\n \n@@ -1950,13 +1954,25 @@ package Sinfo is\n    --    source.\n \n    --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n-   --    Present in nodes which represent an elaboration scenario. Those are\n-   --    assignment statement, attribute reference, call marker, entry call\n-   --    statement, expanded name, function call, identifier, instantiation,\n-   --    procedure call statement, and requeue statement nodes. Set when the\n-   --    node appears within a context subject to SPARK_Mode On. This flag\n-   --    determines when the SPARK model of elaboration be activated by the\n-   --    ABE Processing phase.\n+   --    Present in the following nodes:\n+   --\n+   --      assignment statement\n+   --      attribute reference\n+   --      call marker\n+   --      entry call statement\n+   --      expanded name\n+   --      function call\n+   --      function instantiation\n+   --      identifier\n+   --      package instantiation\n+   --      procedure call statement\n+   --      procedure instantiation\n+   --      requeue statement\n+   --      variable reference marker\n+   --\n+   --    Set when the node appears within a context subject to SPARK_Mode On.\n+   --    This flag determines when the SPARK model of elaboration be activated\n+   --    by the ABE Processing phase.\n \n    --  Is_Static_Coextension (Flag14-Sem)\n    --    Present in N_Allocator nodes. Set if the allocator is a coextension\n@@ -1989,7 +2005,7 @@ package Sinfo is\n    --    indicate that the construct is a task master (i.e. has declared tasks\n    --    or declares an access to a task type).\n \n-   --  Is_Write (Flag2-Sem)\n+   --  Is_Write (Flag5-Sem)\n    --    Present in variable reference markers. Set when the original variable\n    --    reference constitues a write of the variable.\n \n@@ -2328,6 +2344,11 @@ package Sinfo is\n    --    are the result of expansion of rounded fixed-point divide, conversion\n    --    and multiplication operations.\n \n+   --  Save_Invocation_Graph_Of_Body (Flag1-Sem)\n+   --    Present in compilation unit nodes. Set when the elaboration mechanism\n+   --    must record all invocation constructs and invocation relations within\n+   --    the body of the compilation unit.\n+   --\n    --  SCIL_Entity (Node4-Sem)\n    --    Present in SCIL nodes. References the specific tagged type associated\n    --    with the SCIL node (for an N_SCIL_Dispatching_Call node, this is\n@@ -2606,6 +2627,7 @@ package Sinfo is\n       --  Original_Discriminant (Node2-Sem)\n       --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n       --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Is_Elaboration_Warnings_OK_Node (Flag3-Sem)\n       --  Has_Private_View (Flag11-Sem) (set in generic units)\n       --  Redundant_Use (Flag13-Sem)\n       --  Atomic_Sync_Required (Flag14-Sem)\n@@ -6634,17 +6656,18 @@ package Sinfo is\n \n       --  N_Compilation_Unit\n       --  Sloc points to first token of defining unit name\n-      --  Library_Unit (Node4-Sem) corresponding/parent spec/body\n       --  Context_Items (List1) context items and pragmas preceding unit\n       --  Private_Present (Flag15) set if library unit has private keyword\n       --  Unit (Node2) library item or subunit\n       --  Aux_Decls_Node (Node5) points to the N_Compilation_Unit_Aux node\n-      --  Has_No_Elaboration_Code (Flag17-Sem)\n-      --  Body_Required (Flag13-Sem) set for spec if body is required\n-      --  Acts_As_Spec (Flag4-Sem) flag for subprogram body with no spec\n-      --  Context_Pending (Flag16-Sem)\n       --  First_Inlined_Subprogram (Node3-Sem)\n+      --  Library_Unit (Node4-Sem) corresponding/parent spec/body\n+      --  Save_Invocation_Graph_Of_Body (Flag1-Sem)\n+      --  Acts_As_Spec (Flag4-Sem) flag for subprogram body with no spec\n+      --  Body_Required (Flag13-Sem) set for spec if body is required\n       --  Has_Pragma_Suppress_All (Flag14-Sem)\n+      --  Context_Pending (Flag16-Sem)\n+      --  Has_No_Elaboration_Code (Flag17-Sem)\n \n       --  N_Compilation_Unit_Aux\n       --  Sloc is a copy of the Sloc from the N_Compilation_Unit node\n@@ -8051,6 +8074,7 @@ package Sinfo is\n       --  Associated_Node (Node4-Sem)\n       --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n       --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Is_Elaboration_Warnings_OK_Node (Flag3-Sem)\n       --  Has_Private_View (Flag11-Sem) set in generic units\n       --  Redundant_Use (Flag13-Sem)\n       --  Atomic_Sync_Required (Flag14-Sem)\n@@ -8576,8 +8600,11 @@ package Sinfo is\n       --  N_Variable_Reference_Marker\n       --  Sloc points to Sloc of original variable reference\n       --  Target (Node1-Sem)\n-      --  Is_Read (Flag1-Sem)\n-      --  Is_Write (Flag2-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Is_Elaboration_Warnings_OK_Node (Flag3-Sem)\n+      --  Is_Read (Flag4-Sem)\n+      --  Is_Write (Flag5-Sem)\n \n    -----------\n    -- Empty --\n@@ -9868,7 +9895,7 @@ package Sinfo is\n      (N : Node_Id) return Boolean;    -- Flag4\n \n    function Is_Read\n-     (N : Node_Id) return Boolean;    -- Flag1\n+     (N : Node_Id) return Boolean;    -- Flag4\n \n    function Is_Source_Call\n      (N : Node_Id) return Boolean;    -- Flag4\n@@ -9895,7 +9922,7 @@ package Sinfo is\n      (N : Node_Id) return Boolean;    -- Flag5\n \n    function Is_Write\n-     (N : Node_Id) return Boolean;    -- Flag2\n+     (N : Node_Id) return Boolean;    -- Flag5\n \n    function Iteration_Scheme\n      (N : Node_Id) return Node_Id;    -- Node2\n@@ -10164,6 +10191,9 @@ package Sinfo is\n    function Rounded_Result\n      (N : Node_Id) return Boolean;    -- Flag18\n \n+   function Save_Invocation_Graph_Of_Body\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n    function SCIL_Controlling_Tag\n      (N : Node_Id) return Node_Id;    -- Node5\n \n@@ -10972,7 +11002,7 @@ package Sinfo is\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n    procedure Set_Is_Read\n-     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+     (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n    procedure Set_Is_Source_Call\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n@@ -10999,7 +11029,7 @@ package Sinfo is\n      (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n    procedure Set_Is_Write\n-     (N : Node_Id; Val : Boolean := True);    -- Flag2\n+     (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n    procedure Set_Iteration_Scheme\n      (N : Node_Id; Val : Node_Id);            -- Node2\n@@ -11268,6 +11298,9 @@ package Sinfo is\n    procedure Set_Rounded_Result\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n+   procedure Set_Save_Invocation_Graph_Of_Body\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n    procedure Set_SCIL_Controlling_Tag\n      (N : Node_Id; Val : Node_Id);            -- Node5\n \n@@ -13566,6 +13599,7 @@ package Sinfo is\n    pragma Inline (Reverse_Present);\n    pragma Inline (Right_Opnd);\n    pragma Inline (Rounded_Result);\n+   pragma Inline (Save_Invocation_Graph_Of_Body);\n    pragma Inline (SCIL_Controlling_Tag);\n    pragma Inline (SCIL_Entity);\n    pragma Inline (SCIL_Tag_Value);\n@@ -13930,6 +13964,7 @@ package Sinfo is\n    pragma Inline (Set_Reverse_Present);\n    pragma Inline (Set_Right_Opnd);\n    pragma Inline (Set_Rounded_Result);\n+   pragma Inline (Set_Save_Invocation_Graph_Of_Body);\n    pragma Inline (Set_SCIL_Controlling_Tag);\n    pragma Inline (Set_SCIL_Entity);\n    pragma Inline (Set_SCIL_Tag_Value);"}, {"sha": "dc62ec2051002823de07d018de38d636f24f8ca3", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 68, "deletions": 21, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e6ee2f15f110f7f69554aa049a869f9d4dd556/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=69e6ee2f15f110f7f69554aa049a869f9d4dd556", "patch": "@@ -51,6 +51,9 @@ package body Switch.B is\n       --  Used for -d and -D to scan stack size including handling k/m. S is\n       --  set to 'd' or 'D' to indicate the switch being scanned.\n \n+      procedure Scan_Debug_Switches;\n+      --  Scan out debug switches\n+\n       ---------------------------\n       -- Get_Optional_Filename --\n       ---------------------------\n@@ -114,6 +117,70 @@ package body Switch.B is\n          return Result;\n       end Get_Stack_Size;\n \n+      -------------------------\n+      -- Scan_Debug_Switches --\n+      -------------------------\n+\n+      procedure Scan_Debug_Switches is\n+         Dot        : Boolean := False;\n+         Underscore : Boolean := False;\n+\n+      begin\n+         while Ptr <= Max loop\n+            C := Switch_Chars (Ptr);\n+\n+            --  Binder debug flags come in the following forms:\n+            --\n+            --       letter\n+            --     . letter\n+            --     _ letter\n+            --\n+            --       digit\n+            --     . digit\n+            --     _ digit\n+            --\n+            --  Note that the processing of switch -d aleady takes care of the\n+            --  case where the first flag is a digit (default stack size).\n+\n+            if C in '1' .. '9' or else\n+               C in 'a' .. 'z' or else\n+               C in 'A' .. 'Z'\n+            then\n+               --  . letter\n+               --  . digit\n+\n+               if Dot then\n+                  Set_Dotted_Debug_Flag (C);\n+                  Dot := False;\n+\n+               --  _ letter\n+               --  _ digit\n+\n+               elsif Underscore then\n+                  Set_Underscored_Debug_Flag (C);\n+                  Underscore := False;\n+\n+               --    letter\n+               --    digit\n+\n+               else\n+                  Set_Debug_Flag (C);\n+               end if;\n+\n+            elsif C = '.' then\n+               Dot := True;\n+\n+            elsif C = '_' then\n+               Underscore := True;\n+\n+            else\n+               Bad_Switch (Switch_Chars);\n+            end if;\n+\n+            Ptr := Ptr + 1;\n+         end loop;\n+      end Scan_Debug_Switches;\n+\n    --  Start of processing for Scan_Binder_Switches\n \n    begin\n@@ -170,7 +237,6 @@ package body Switch.B is\n          --  Processing for d switch\n \n          when 'd' =>\n-\n             if Ptr = Max then\n                Bad_Switch (Switch_Chars);\n             end if;\n@@ -189,26 +255,7 @@ package body Switch.B is\n             --  Case where character after -d is not digit (debug flags)\n \n             else\n-               --  Note: for the debug switch, the remaining characters in this\n-               --  switch field must all be debug flags, since all valid switch\n-               --  characters are also valid debug characters. This switch is\n-               --  not documented on purpose because it is only used by the\n-               --  implementors.\n-\n-               --  Loop to scan out debug flags\n-\n-               loop\n-                  C := Switch_Chars (Ptr);\n-\n-                  if C in 'a' .. 'z' or else C in 'A' .. 'Z' then\n-                     Set_Debug_Flag (C);\n-                  else\n-                     Bad_Switch (Switch_Chars);\n-                  end if;\n-\n-                  Ptr := Ptr + 1;\n-                  exit when Ptr > Max;\n-               end loop;\n+               Scan_Debug_Switches;\n             end if;\n \n          --  Processing for D switch"}]}