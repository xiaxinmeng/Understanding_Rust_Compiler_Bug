{"sha": "c25d317cf7d4ea8df0402feb939ce286e5f42988", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI1ZDMxN2NmN2Q0ZWE4ZGYwNDAyZmViOTM5Y2UyODZlNWY0Mjk4OA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-10-28T00:13:46Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-10-28T00:17:29Z"}, "message": "Tweaks to ranger API routines.\n\nRemove the gcc_assert wrappers that contain statements that need to be\nexecuted.\nAudit routines to ensure range is set to UNDEFINED when false is returned.\n\n\t* gimple-range-gori.cc (gori_compute_cache::cache_stmt): Accumulate\n\treturn values and only set cache when everything returned true.\n\t* gimple-range.cc (get_tree_range): Set the return range to UNDEFINED\n\twhen the range isn't supported.\n\t(gimple_ranger::calc_stmt): Return varying if the type is supported,\n\teven if the stmt processing failed.  False otherwise.\n\t(range_of_builtin_ubsan_call): Don't use gcc_assert.\n\t(range_of_builtin_call): Ditto.\n\t(gimple_ranger::range_of_cond_expr): Ditto.\n\t(gimple_ranger::range_of_expr): Ditto\n\t(gimple_ranger::range_on_entry): Ditto.\n\t(gimple_ranger::range_on_exit): Ditto.\n\t(gimple_ranger::range_on_edge): DItto.\n\t(gimple_ranger::range_of_stmt): Don't use gcc_assert, and initialize\n\treturn value to UNDEFINED.", "tree": {"sha": "606a076c0c7303648e51b6af80110f42bfeff0c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/606a076c0c7303648e51b6af80110f42bfeff0c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c25d317cf7d4ea8df0402feb939ce286e5f42988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25d317cf7d4ea8df0402feb939ce286e5f42988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25d317cf7d4ea8df0402feb939ce286e5f42988", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25d317cf7d4ea8df0402feb939ce286e5f42988/comments", "author": null, "committer": null, "parents": [{"sha": "89bb01e7cbd82cdf318202d8185d765dcc338915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89bb01e7cbd82cdf318202d8185d765dcc338915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89bb01e7cbd82cdf318202d8185d765dcc338915"}], "stats": {"total": 94, "additions": 50, "deletions": 44}, "files": [{"sha": "54385baa62919d3e845a58d64a6e2610fd3f795a", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25d317cf7d4ea8df0402feb939ce286e5f42988/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25d317cf7d4ea8df0402feb939ce286e5f42988/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=c25d317cf7d4ea8df0402feb939ce286e5f42988", "patch": "@@ -1313,13 +1313,15 @@ gori_compute_cache::cache_stmt (gimple *stmt)\n   else if (tree cached_name = m_cache->same_cached_name (op1, op2))\n     {\n       tf_range op1_range, op2_range;\n-      gcc_assert (m_cache->get_range (op1_range, op1, cached_name));\n-      gcc_assert (m_cache->get_range (op2_range, op2, cached_name));\n-      gcc_assert (logical_combine (r_true_side, code, m_bool_one,\n-\t\t\t\t   op1_range, op2_range));\n-      gcc_assert (logical_combine (r_false_side, code, m_bool_zero,\n-\t\t\t\t   op1_range, op2_range));\n-      m_cache->set_range (lhs, cached_name,\n-\t\t\t  tf_range (r_true_side, r_false_side));\n+      bool ok = m_cache->get_range (op1_range, op1, cached_name);\n+      ok = ok && m_cache->get_range (op2_range, op2, cached_name);\n+      ok = ok && logical_combine (r_true_side, code, m_bool_one,\n+\t\t\t\t  op1_range, op2_range);\n+      ok = ok && logical_combine (r_false_side, code, m_bool_zero,\n+\t\t\t\t  op1_range, op2_range);\n+      gcc_checking_assert (ok);\n+      if (ok)\n+\tm_cache->set_range (lhs, cached_name,\n+\t\t\t    tf_range (r_true_side, r_false_side));\n     }\n }"}, {"sha": "cf979845acffad6c6e71d187e18ce1ade34d1b1e", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25d317cf7d4ea8df0402feb939ce286e5f42988/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25d317cf7d4ea8df0402feb939ce286e5f42988/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=c25d317cf7d4ea8df0402feb939ce286e5f42988", "patch": "@@ -144,7 +144,7 @@ gimple_range_adjustment (irange &res, const gimple *stmt)\n }\n \n // Return a range in R for the tree EXPR.  Return true if a range is\n-// representable.\n+// representable, and UNDEFINED/false if not.\n \n bool\n get_tree_range (irange &r, tree expr)\n@@ -157,7 +157,10 @@ get_tree_range (irange &r, tree expr)\n \n   // Return false if the type isn't suported.\n   if (!irange::supports_type_p (type))\n-    return false;\n+    {\n+      r.set_undefined ();\n+      return false;\n+    }\n \n   switch (TREE_CODE (expr))\n     {\n@@ -373,7 +376,8 @@ gimple_ranger::calc_stmt (irange &r, gimple *s, tree name)\n     res = range_of_call (r, as_a<gcall *> (s));\n   else if (is_a<gassign *> (s) && gimple_assign_rhs_code (s) == COND_EXPR)\n     res = range_of_cond_expr (r, as_a<gassign *> (s));\n-  else\n+\n+  if (!res)\n     {\n       // If no name is specified, try the expression kind.\n       if (!name)\n@@ -384,25 +388,24 @@ gimple_ranger::calc_stmt (irange &r, gimple *s, tree name)\n \t  r.set_varying (t);\n \t  return true;\n \t}\n+      if (!gimple_range_ssa_p (name))\n+\treturn false;\n       // We don't understand the stmt, so return the global range.\n       r = gimple_range_global (name);\n       return true;\n     }\n-  if (res)\n+\n+  if (r.undefined_p ())\n+    return true;\n+\n+  // We sometimes get compatible types copied from operands, make sure\n+  // the correct type is being returned.\n+  if (name && TREE_TYPE (name) != r.type ())\n     {\n-      if (r.undefined_p ())\n-\treturn true;\n-      // We sometimes get compatible types copied from operands, make sure\n-      // the correct type is being returned.\n-      if (name && TREE_TYPE (name) != r.type ())\n-\t{\n-\t  gcc_checking_assert (range_compatible_p (r.type (),\n-\t\t\t\t\t\t   TREE_TYPE (name)));\n-\t  range_cast (r, TREE_TYPE (name));\n-\t}\n-      return true;\n+      gcc_checking_assert (range_compatible_p (r.type (), TREE_TYPE (name)));\n+      range_cast (r, TREE_TYPE (name));\n     }\n-  return false;\n+  return true;\n }\n \n // Calculate a range for range_op statement S and return it in R.  If any\n@@ -582,8 +585,8 @@ range_of_builtin_ubsan_call (range_query &query, irange &r, gcall *call,\n   int_range_max ir0, ir1;\n   tree arg0 = gimple_call_arg (call, 0);\n   tree arg1 = gimple_call_arg (call, 1);\n-  gcc_assert (query.range_of_expr (ir0, arg0, call));\n-  gcc_assert (query.range_of_expr (ir1, arg1, call));\n+  query.range_of_expr (ir0, arg0, call);\n+  query.range_of_expr (ir1, arg1, call);\n \n   bool saved_flag_wrapv = flag_wrapv;\n   // Pretend the arithmetic is wrapping.  If there is any overflow,\n@@ -638,7 +641,7 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n       prec = TYPE_PRECISION (TREE_TYPE (arg));\n       mini = 0;\n       maxi = prec;\n-      gcc_assert (query.range_of_expr (r, arg, call));\n+      query.range_of_expr (r, arg, call);\n       // If arg is non-zero, then ffs or popcount are non-zero.\n       if (!range_includes_zero_p (&r))\n \tmini = 1;\n@@ -682,7 +685,7 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n \t    }\n \t}\n \n-      gcc_assert (query.range_of_expr (r, arg, call));\n+      query.range_of_expr (r, arg, call);\n       // From clz of minimum we can compute result maximum.\n       if (r.constant_p ())\n \t{\n@@ -747,7 +750,7 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n \t\tmini = -2;\n \t    }\n \t}\n-      gcc_assert (query.range_of_expr (r, arg, call));\n+      query.range_of_expr (r, arg, call);\n       if (!r.undefined_p ())\n \t{\n \t  if (r.lower_bound () != 0)\n@@ -864,9 +867,9 @@ gimple_ranger::range_of_cond_expr  (irange &r, gassign *s)\n   if (!irange::supports_type_p (TREE_TYPE (op1)))\n     return false;\n \n-  gcc_assert (range_of_expr (cond_range, cond, s));\n-  gcc_assert (range_of_expr (range1, op1, s));\n-  gcc_assert (range_of_expr (range2, op2, s));\n+  range_of_expr (cond_range, cond, s);\n+  range_of_expr (range1, op1, s);\n+  range_of_expr (range2, op2, s);\n \n   // If the condition is known, choose the appropriate expression.\n   if (cond_range.singleton_p ())\n@@ -904,7 +907,7 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n \n   // If name is defined in this block, try to get an range from S.\n   if (def_stmt && gimple_bb (def_stmt) == bb)\n-    gcc_assert (range_of_stmt (r, def_stmt, expr));\n+    range_of_stmt (r, def_stmt, expr);\n   else\n     // Otherwise OP comes from outside this block, use range on entry.\n     range_on_entry (r, bb, expr);\n@@ -933,7 +936,7 @@ gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n   gcc_checking_assert (gimple_range_ssa_p (name));\n \n   // Start with any known range\n-  gcc_assert (range_of_stmt (r, SSA_NAME_DEF_STMT (name), name));\n+  range_of_stmt (r, SSA_NAME_DEF_STMT (name), name);\n \n   // Now see if there is any on_entry value which may refine it.\n   if (m_cache.block_range (entry_range, bb, name))\n@@ -948,6 +951,7 @@ gimple_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n {\n   // on-exit from the exit block?\n   gcc_checking_assert (bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n+  gcc_checking_assert (gimple_range_ssa_p (name));\n \n   gimple *s = last_stmt (bb);\n   // If there is no statement in the block and this isn't the entry\n@@ -956,7 +960,7 @@ gimple_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n   if (!s && bb != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     range_on_entry (r, bb, name);\n   else\n-    gcc_assert (range_of_expr (r, name, s));\n+    range_of_expr (r, name, s);\n   gcc_checking_assert (r.undefined_p ()\n \t\t       || range_compatible_p (r.type (), TREE_TYPE (name)));\n }\n@@ -971,10 +975,7 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n \n   // PHI arguments can be constants, catch these here.\n   if (!gimple_range_ssa_p (name))\n-    {\n-      gcc_assert (range_of_expr (r, name));\n-      return true;\n-    }\n+    return range_of_expr (r, name);\n \n   range_on_exit (r, e->src, name);\n   gcc_checking_assert  (r.undefined_p ()\n@@ -991,29 +992,32 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n // provided it represents the SSA_NAME on the LHS of the statement.\n // It is only required if there is more than one lhs/output.  Check\n // the global cache for NAME first to see if the evaluation can be\n-// avoided.  If a range cannot be calculated, return false.\n+// avoided.  If a range cannot be calculated, return false and UNDEFINED.\n \n bool\n gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n {\n-  // If no name, simply call the base routine.\n+  r.set_undefined ();\n+\n   if (!name)\n     name = gimple_get_lhs (s);\n \n+  // If no name, simply call the base routine.\n   if (!name)\n     return calc_stmt (r, s, NULL_TREE);\n \n-  gcc_checking_assert (TREE_CODE (name) == SSA_NAME &&\n-\t\t       irange::supports_type_p (TREE_TYPE (name)));\n+  if (!gimple_range_ssa_p (name))\n+    return false;\n \n   // If this STMT has already been processed, return that value.\n   if (m_cache.m_globals.get_global_range (r, name))\n     return true;\n+\n   // Avoid infinite recursion by initializing global cache\n   int_range_max tmp = gimple_range_global (name);\n   m_cache.m_globals.set_global_range (name, tmp);\n \n-  gcc_assert (calc_stmt (r, s, name));\n+  calc_stmt (r, s, name);\n \n   if (is_a<gphi *> (s))\n     r.intersect (tmp);"}]}