{"sha": "dc80d5e887ea4fa0e1e950db5f6bdd765c960c22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM4MGQ1ZTg4N2VhNGZhMGUxZTk1MGRiNWY2YmRkNzY1Yzk2MGMyMg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-04-16T16:40:44Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-04-26T16:20:38Z"}, "message": "Keep VR_UNDEFINED and VR_VARYING in sync (speeds up evrp by 8.47%).\n\nCurrently multi-ranges calculate the undefined and varying bits on the\nfly, whereas legacy uses the m_kind field.  Since we will always have\nspace in the irange class for a kind field, might as well keep it in\nsync as ranges are created, thus speeding up lookups.\n\nThis patch, along with an upcoming ones for num_pairs(), speeds up EVRP\nby 8.47%, VRP proper by 1.84% and overall compilation by 0.24%.\n\nFWIW, since evrp is such a fast pass, and is hard to measure clock-wise,\nwe've been using callgrind to estimate improvements.  This has coincided\nmore or less with -ftime-report numbers (albeit having to run -ftime-report\nhalf a dozen times and use the average).\n\ngcc/ChangeLog:\n\n\t* value-range.cc (irange::operator=): Set m_kind.\n\t(irange::copy_to_legacy): Handle varying and undefined sources\n\tas a legacy copy since they can be easily copied.\n\t(irange::irange_set): Set m_kind.\n\t(irange::irange_set_anti_range): Same.\n\t(irange::set): Rename normalize_min_max to normalize_kind.\n\t(irange::verify_range): Adjust for multi-ranges having the\n\tm_kind field set.\n\t(irange::irange_union): Set m_kind.\n\t(irange::irange_intersect): Same.\n\t(irange::invert): Same.\n\t* value-range.h (irange::kind): Always return m_kind.\n\t(irange::varying_p): Rename to...\n\t(irange::varying_comptaible_p): ...this.\n\t(irange::undefined_p): Only look at m_kind.\n\t(irange::irange): Always set VR_UNDEFINED if applicable.\n\t(irange::set_undefined): Always set VR_UNDEFINED.\n\t(irange::set_varying): Always set m_kind to VR_VARYING.\n\t(irange::normalize_min_max): Rename to...\n\t(irange::normalize_kind): ...this.", "tree": {"sha": "5745ec11b2ec0767dd0b33991dd425012b541d45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5745ec11b2ec0767dd0b33991dd425012b541d45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc80d5e887ea4fa0e1e950db5f6bdd765c960c22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc80d5e887ea4fa0e1e950db5f6bdd765c960c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc80d5e887ea4fa0e1e950db5f6bdd765c960c22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc80d5e887ea4fa0e1e950db5f6bdd765c960c22/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "694c956b6b877e48323cf86c90c09237b7b0e8c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694c956b6b877e48323cf86c90c09237b7b0e8c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/694c956b6b877e48323cf86c90c09237b7b0e8c8"}], "stats": {"total": 135, "additions": 63, "deletions": 72}, "files": [{"sha": "297dd6043a9a5caacb70cd576598f842ca7379bd", "filename": "gcc/value-range.cc", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc80d5e887ea4fa0e1e950db5f6bdd765c960c22/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc80d5e887ea4fa0e1e950db5f6bdd765c960c22/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=dc80d5e887ea4fa0e1e950db5f6bdd765c960c22", "patch": "@@ -59,6 +59,7 @@ irange::operator= (const irange &src)\n     m_base[x - 1] = src.m_base[src.m_num_ranges * 2 - 1];\n \n   m_num_ranges = lim;\n+  m_kind = src.m_kind;\n   return *this;\n }\n \n@@ -106,8 +107,8 @@ void\n irange::copy_to_legacy (const irange &src)\n {\n   gcc_checking_assert (legacy_mode_p ());\n-  // Copy legacy to legacy.\n-  if (src.legacy_mode_p ())\n+  // Handle legacy to legacy and other things that are easy to copy.\n+  if (src.legacy_mode_p () || src.varying_p () || src.undefined_p ())\n     {\n       m_num_ranges = src.m_num_ranges;\n       m_base[0] = src.m_base[0];\n@@ -116,11 +117,7 @@ irange::copy_to_legacy (const irange &src)\n       return;\n     }\n   // Copy multi-range to legacy.\n-  if (src.undefined_p ())\n-    set_undefined ();\n-  else if (src.varying_p ())\n-    set_varying (src.type ());\n-  else if (src.maybe_anti_range ())\n+  if (src.maybe_anti_range ())\n     {\n       int_range<3> r (src);\n       r.invert ();\n@@ -180,6 +177,9 @@ irange::irange_set (tree min, tree max)\n   m_base[0] = min;\n   m_base[1] = max;\n   m_num_ranges = 1;\n+  m_kind = VR_RANGE;\n+  normalize_kind ();\n+\n   if (flag_checking)\n     verify_range ();\n }\n@@ -247,6 +247,10 @@ irange::irange_set_anti_range (tree min, tree max)\n       m_base[m_num_ranges * 2 + 1] = type_range.tree_upper_bound (0);\n       ++m_num_ranges;\n     }\n+\n+  m_kind = VR_RANGE;\n+  normalize_kind ();\n+\n   if (flag_checking)\n     verify_range ();\n }\n@@ -353,7 +357,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n   m_base[0] = min;\n   m_base[1] = max;\n   m_num_ranges = 1;\n-  normalize_min_max ();\n+  normalize_kind ();\n   if (flag_checking)\n     verify_range ();\n }\n@@ -363,9 +367,22 @@ irange::set (tree min, tree max, value_range_kind kind)\n void\n irange::verify_range ()\n {\n+  if (m_kind == VR_UNDEFINED)\n+    {\n+      gcc_assert (m_num_ranges == 0);\n+      return;\n+    }\n+  gcc_assert (m_num_ranges != 0);\n+\n+  if (m_kind == VR_VARYING)\n+    {\n+      gcc_checking_assert (m_num_ranges == 1);\n+      gcc_checking_assert (varying_compatible_p ());\n+      return;\n+    }\n   if (!legacy_mode_p ())\n     {\n-      gcc_checking_assert (m_kind == VR_RANGE);\n+      gcc_checking_assert (!varying_compatible_p ());\n       for (unsigned i = 0; i < m_num_ranges; ++i)\n \t{\n \t  tree lb = tree_lower_bound (i);\n@@ -375,28 +392,11 @@ irange::verify_range ()\n \t}\n       return;\n     }\n-\n-  switch (m_kind)\n+  if (m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n     {\n-    case VR_UNDEFINED:\n-      gcc_assert (m_num_ranges == 0);\n-      break;\n-\n-    case VR_VARYING:\n       gcc_assert (m_num_ranges == 1);\n-      break;\n-\n-    case VR_ANTI_RANGE:\n-    case VR_RANGE:\n-      {\n-\tgcc_assert (m_num_ranges == 1);\n-\tint cmp = compare_values (tree_lower_bound (0), tree_upper_bound (0));\n-\tgcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n-\treturn;\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n+      int cmp = compare_values (tree_lower_bound (0), tree_upper_bound (0));\n+      gcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n     }\n }\n \n@@ -1667,6 +1667,9 @@ irange::irange_union (const irange &r)\n     m_base[j] = res [j];\n   m_num_ranges = i / 2;\n \n+  m_kind = VR_RANGE;\n+  normalize_kind ();\n+\n   if (flag_checking)\n     verify_range ();\n }\n@@ -1758,6 +1761,10 @@ irange::irange_intersect (const irange &r)\n   // At the exit of this loop, it is one of 2 things:\n   // ran out of r1, or r2, but either means we are done.\n   m_num_ranges = bld_pair;\n+\n+  m_kind = VR_RANGE;\n+  normalize_kind ();\n+\n   if (flag_checking)\n     verify_range ();\n }\n@@ -1890,6 +1897,10 @@ irange::invert ()\n     }\n   m_num_ranges = nitems / 2;\n \n+  // We disallow undefined or varying coming in, so the result can\n+  // only be a VR_RANGE.\n+  gcc_checking_assert (m_kind == VR_RANGE);\n+\n   if (flag_checking)\n     verify_range ();\n }"}, {"sha": "e000432c15ee234fdef6c631efaed6c16ae94011", "filename": "gcc/value-range.h", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc80d5e887ea4fa0e1e950db5f6bdd765c960c22/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc80d5e887ea4fa0e1e950db5f6bdd765c960c22/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=dc80d5e887ea4fa0e1e950db5f6bdd765c960c22", "patch": "@@ -111,7 +111,7 @@ class irange\n   void irange_set (tree, tree);\n   void irange_set_anti_range (tree, tree);\n \n-  void normalize_min_max ();\n+  void normalize_kind ();\n \n   bool legacy_mode_p () const;\n   bool legacy_equal_p (const irange &) const;\n@@ -128,6 +128,7 @@ class irange\n \n private:\n   void irange_set_1bit_anti_range (tree, tree);\n+  bool varying_compatible_p () const;\n \n   unsigned char m_num_ranges;\n   unsigned char m_max_ranges;\n@@ -198,16 +199,7 @@ extern bool vrp_operand_equal_p (const_tree, const_tree);\n inline value_range_kind\n irange::kind () const\n {\n-  if (legacy_mode_p ())\n-    return m_kind;\n-\n-  if (undefined_p ())\n-    return VR_UNDEFINED;\n-\n-  if (varying_p ())\n-    return VR_VARYING;\n-\n-  return VR_RANGE;\n+  return m_kind;\n }\n \n // Number of sub-ranges in a range.\n@@ -271,17 +263,18 @@ irange::max () const\n }\n \n inline bool\n-irange::varying_p () const\n+irange::varying_compatible_p () const\n {\n-  if (legacy_mode_p ())\n-    return m_kind == VR_VARYING;\n-\n   if (m_num_ranges != 1)\n     return false;\n \n   tree l = m_base[0];\n   tree u = m_base[1];\n   tree t = TREE_TYPE (l);\n+\n+  if (m_kind == VR_VARYING && t == error_mark_node)\n+    return true;\n+\n   unsigned prec = TYPE_PRECISION (t);\n   signop sign = TYPE_SIGN (t);\n   if (INTEGRAL_TYPE_P (t))\n@@ -291,22 +284,17 @@ irange::varying_p () const\n     return (wi::to_wide (l) == 0\n \t    && wi::to_wide (u) == wi::max_value (prec, sign));\n   return true;\n+}\n \n+inline bool\n+irange::varying_p () const\n+{\n+  return m_kind == VR_VARYING;\n }\n \n inline bool\n irange::undefined_p () const\n {\n-  if (!legacy_mode_p ())\n-    return m_num_ranges == 0;\n-\n-  if (CHECKING_P && legacy_mode_p ())\n-    {\n-      if (m_kind == VR_UNDEFINED)\n-\tgcc_checking_assert (m_num_ranges == 0);\n-      else\n-\tgcc_checking_assert (m_num_ranges != 0);\n-    }\n   return m_kind == VR_UNDEFINED;\n }\n \n@@ -389,10 +377,7 @@ irange::irange (tree *base, unsigned nranges)\n   m_base = base;\n   m_num_ranges = 0;\n   m_max_ranges = nranges;\n-  if (legacy_mode_p ())\n-    m_kind = VR_UNDEFINED;\n-  else\n-    m_kind = VR_RANGE;\n+  m_kind = VR_UNDEFINED;\n }\n \n // Constructors for int_range<>.\n@@ -459,18 +444,16 @@ irange::set (tree val)\n inline void\n irange::set_undefined ()\n {\n+  m_kind = VR_UNDEFINED;\n   m_num_ranges = 0;\n-  if (legacy_mode_p ())\n-    m_kind = VR_UNDEFINED;\n }\n \n inline void\n irange::set_varying (tree type)\n {\n-  if (legacy_mode_p ())\n-    m_kind = VR_VARYING;\n-\n+  m_kind = VR_VARYING;\n   m_num_ranges = 1;\n+\n   if (INTEGRAL_TYPE_P (type))\n     {\n       wide_int min = wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n@@ -574,17 +557,14 @@ irange::set_zero (tree type)\n // Normalize a range to VARYING or UNDEFINED if possible.\n \n inline void\n-irange::normalize_min_max ()\n-{\n-  gcc_checking_assert (legacy_mode_p ());\n-  gcc_checking_assert (!undefined_p ());\n-  unsigned prec = TYPE_PRECISION (type ());\n-  signop sign = TYPE_SIGN (type ());\n-  if (wi::eq_p (wi::to_wide (min ()), wi::min_value (prec, sign))\n-      && wi::eq_p (wi::to_wide (max ()), wi::max_value (prec, sign)))\n+irange::normalize_kind ()\n+{\n+  if (m_num_ranges == 0)\n+    m_kind = VR_UNDEFINED;\n+  else if (varying_compatible_p ())\n     {\n       if (m_kind == VR_RANGE)\n-\tset_varying (type ());\n+\tm_kind = VR_VARYING;\n       else if (m_kind == VR_ANTI_RANGE)\n \tset_undefined ();\n       else"}]}