{"sha": "7cc7f3aa68b852b217c511e7d841458b0bdd532a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NjN2YzYWE2OGI4NTJiMjE3YzUxMWU3ZDg0MTQ1OGIwYmRkNTMyYQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-08T15:17:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-08T15:17:43Z"}, "message": "sem_disp.adb (Is_Inherited_Public_Operation): Extend the functionality of this routine to handle multiple levels of derivations.\n\ngcc/ada/\n\n2017-11-08  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_disp.adb (Is_Inherited_Public_Operation): Extend the\n\tfunctionality of this routine to handle multiple levels of derivations.\n\n2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb: Elist36 is now used as Nested_Scenarios.\n\t(Nested_Scenarios): New routine.\n\t(Set_Nested_Scenarios): New routine.\n\t(Write_Field36_Name): New routine.\n\t* einfo.ads: Add new attribute Nested_Scenarios along with occurrences\n\tin entities.\n\t(Nested_Scenarios): New routine along with pragma Inline.\n\t(Set_Nested_Scenarios): New routine along with pragma Inline.\n\t* sem_elab.adb (Find_And_Process_Nested_Scenarios): New routine.\n\t(Process_Nested_Scenarios): New routine.\n\t(Traverse_Body): When a subprogram body is traversed for the first\n\ttime, find, save, and process all suitable scenarios found within.\n\tSubsequent traversals of the same subprogram body utilize the saved\n\tscenarios.\n\n2017-11-08  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* lib-xref-spark_specific.adb (Add_SPARK_Scope): Remove detection of\n\tprotected operations.\n\t(Add_SPARK_Xrefs): Simplify detection of empty entities.\n\t* get_spark_xrefs.ads, get_spark_xrefs.adb, put_spark_xrefs.ads,\n\tput_spark_xrefs.adb, spark_xrefs_test.adb: Remove code for writing,\n\treading and testing SPARK cross-references stored in the ALI files.\n\t* lib-xref.ads (Output_SPARK_Xrefs): Remove.\n\t* lib-writ.adb (Write_ALI): Do not write SPARK cross-references to the\n\tALI file.\n\t* spark_xrefs.ads, spark_xrefs.adb (pspark): Remove, together\n\twith description of the SPARK xrefs ALI format.\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Remove get_spark_refs.o\n\tand put_spark_refs.o.\n\n2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Apply_Accessibility_Check): Do not finalize the object\n\twhen the associated access type is subject to pragma\n\tNo_Heap_Finalization.\n\t* exp_intr.adb (Expand_Unc_Deallocation): Use the available view of the\n\tdesignated type in case it comes from a limited withed unit.\n\ngcc/testsuite/\n\n2017-11-08  Javier Miranda  <miranda@adacore.com>\n\n\t* gnat.dg/overriding_ops2.adb, gnat.dg/overriding_ops2.ads,\n\tgnat.dg/overriding_ops2_pkg.ads, gnat.dg/overriding_ops2_pkg-high.ads:\n\tNew testcase.\n\nFrom-SVN: r254532", "tree": {"sha": "56f546624848f4160ac2976a6355c5bcedf0f61c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56f546624848f4160ac2976a6355c5bcedf0f61c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cc7f3aa68b852b217c511e7d841458b0bdd532a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc7f3aa68b852b217c511e7d841458b0bdd532a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc7f3aa68b852b217c511e7d841458b0bdd532a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc7f3aa68b852b217c511e7d841458b0bdd532a/comments", "author": null, "committer": null, "parents": [{"sha": "daf82dd806519e567ca6420b5e1c04ec5b732615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf82dd806519e567ca6420b5e1c04ec5b732615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daf82dd806519e567ca6420b5e1c04ec5b732615"}], "stats": {"total": 1750, "additions": 311, "deletions": 1439}, "files": [{"sha": "8826c77bb93d12ed2daf78218cd0b6568ee77c83", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -1,3 +1,49 @@\n+2017-11-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_disp.adb (Is_Inherited_Public_Operation): Extend the\n+\tfunctionality of this routine to handle multiple levels of derivations.\n+\n+2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb: Elist36 is now used as Nested_Scenarios.\n+\t(Nested_Scenarios): New routine.\n+\t(Set_Nested_Scenarios): New routine.\n+\t(Write_Field36_Name): New routine.\n+\t* einfo.ads: Add new attribute Nested_Scenarios along with occurrences\n+\tin entities.\n+\t(Nested_Scenarios): New routine along with pragma Inline.\n+\t(Set_Nested_Scenarios): New routine along with pragma Inline.\n+\t* sem_elab.adb (Find_And_Process_Nested_Scenarios): New routine.\n+\t(Process_Nested_Scenarios): New routine.\n+\t(Traverse_Body): When a subprogram body is traversed for the first\n+\ttime, find, save, and process all suitable scenarios found within.\n+\tSubsequent traversals of the same subprogram body utilize the saved\n+\tscenarios.\n+\n+2017-11-08  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* lib-xref-spark_specific.adb (Add_SPARK_Scope): Remove detection of\n+\tprotected operations.\n+\t(Add_SPARK_Xrefs): Simplify detection of empty entities.\n+\t* get_spark_xrefs.ads, get_spark_xrefs.adb, put_spark_xrefs.ads,\n+\tput_spark_xrefs.adb, spark_xrefs_test.adb: Remove code for writing,\n+\treading and testing SPARK cross-references stored in the ALI files.\n+\t* lib-xref.ads (Output_SPARK_Xrefs): Remove.\n+\t* lib-writ.adb (Write_ALI): Do not write SPARK cross-references to the\n+\tALI file.\n+\t* spark_xrefs.ads, spark_xrefs.adb (pspark): Remove, together\n+\twith description of the SPARK xrefs ALI format.\n+\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Remove get_spark_refs.o\n+\tand put_spark_refs.o.\n+\n+2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Apply_Accessibility_Check): Do not finalize the object\n+\twhen the associated access type is subject to pragma\n+\tNo_Heap_Finalization.\n+\t* exp_intr.adb (Expand_Unc_Deallocation): Use the available view of the\n+\tdesignated type in case it comes from a limited withed unit.\n+\n 2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch3.adb (Expand_N_Object_Declaration): Save and restore relevant"}, {"sha": "94e326184eb06bf89ed1559a68e711a6b3d7f61b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -273,6 +273,7 @@ package body Einfo is\n    --    Entry_Max_Queue_Lengths_Array   Node35\n    --    Import_Pragma                   Node35\n \n+   --    Nested_Scenarios                Elist36\n    --    Validated_Object                Node36\n \n    --    Class_Wide_Clone                Node38\n@@ -2867,6 +2868,14 @@ package body Einfo is\n       return Flag22 (Id);\n    end Needs_No_Actuals;\n \n+   function Nested_Scenarios (Id : E) return L is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function,\n+                                   E_Procedure,\n+                                   E_Subprogram_Body));\n+      return Elist36 (Id);\n+   end Nested_Scenarios;\n+\n    function Never_Set_In_Source (Id : E) return B is\n    begin\n       return Flag115 (Id);\n@@ -6071,6 +6080,14 @@ package body Einfo is\n       Set_Flag22 (Id, V);\n    end Set_Needs_No_Actuals;\n \n+   procedure Set_Nested_Scenarios (Id : E; V : L) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function,\n+                                   E_Procedure,\n+                                   E_Subprogram_Body));\n+      Set_Elist36 (Id, V);\n+   end Set_Nested_Scenarios;\n+\n    procedure Set_Never_Set_In_Source (Id : E; V : B := True) is\n    begin\n       Set_Flag115 (Id, V);\n@@ -11118,6 +11135,12 @@ package body Einfo is\n    procedure Write_Field36_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Function\n+            | E_Procedure\n+            | E_Subprogram_Body\n+         =>\n+            Write_Str (\"Nested_Scenarios\");\n+\n          when E_Variable =>\n             Write_Str (\"Validated_Object\");\n "}, {"sha": "7bcf3f9298d73a0870938f5bbc34239cad7d294d", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -3531,6 +3531,14 @@ package Einfo is\n --       interpreted as an indexing of the result of the call. It is also\n --       used to resolve various cases of entry calls.\n \n+--    Nested_Scenarios (Elist36)\n+--       Present in [stand alone] subprogram bodies. The list contains all\n+--       nested scenarios (see the terminology in Sem_Elab) which appear within\n+--       the declarations, statements, and exception handlers of the subprogram\n+--       body. The list improves the performance of the ABE Processing phase by\n+--       avoiding a full tree traversal when the same subprogram body is part\n+--       of several distinct paths in the elaboration graph.\n+\n --    Never_Set_In_Source (Flag115)\n --       Defined in all entities, but can be set only for variables and\n --       parameters. This flag is set if the object is never assigned a value\n@@ -6076,6 +6084,7 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n+   --    Nested_Scenarios                    (Elist36)\n    --    Class_Wide_Clone                    (Node38)\n    --    Protected_Subprogram                (Node39)   (non-generic case only)\n    --    SPARK_Pragma                        (Node40)\n@@ -6398,6 +6407,7 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n+   --    Nested_Scenarios                    (Elist36)\n    --    Class_Wide_Clone                    (Node38)\n    --    Protected_Subprogram                (Node39)   (non-generic case only)\n    --    SPARK_Pragma                        (Node40)\n@@ -6592,6 +6602,7 @@ package Einfo is\n    --    Extra_Formals                       (Node28)\n    --    Anonymous_Masters                   (Elist29)\n    --    Contract                            (Node34)\n+   --    Nested_Scenarios                    (Elist36)\n    --    SPARK_Pragma                        (Node40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    SPARK_Pragma_Inherited              (Flag265)\n@@ -7308,6 +7319,7 @@ package Einfo is\n    function Must_Have_Preelab_Init              (Id : E) return B;\n    function Needs_Debug_Info                    (Id : E) return B;\n    function Needs_No_Actuals                    (Id : E) return B;\n+   function Nested_Scenarios                    (Id : E) return L;\n    function Never_Set_In_Source                 (Id : E) return B;\n    function Next_Inlined_Subprogram             (Id : E) return E;\n    function No_Dynamic_Predicate_On_Actual      (Id : E) return B;\n@@ -8005,6 +8017,7 @@ package Einfo is\n    procedure Set_Must_Have_Preelab_Init          (Id : E; V : B := True);\n    procedure Set_Needs_Debug_Info                (Id : E; V : B := True);\n    procedure Set_Needs_No_Actuals                (Id : E; V : B := True);\n+   procedure Set_Nested_Scenarios                (Id : E; V : L);\n    procedure Set_Never_Set_In_Source             (Id : E; V : B := True);\n    procedure Set_Next_Inlined_Subprogram         (Id : E; V : E);\n    procedure Set_No_Dynamic_Predicate_On_Actual  (Id : E; V : B := True);\n@@ -8857,6 +8870,7 @@ package Einfo is\n    pragma Inline (Must_Have_Preelab_Init);\n    pragma Inline (Needs_Debug_Info);\n    pragma Inline (Needs_No_Actuals);\n+   pragma Inline (Nested_Scenarios);\n    pragma Inline (Never_Set_In_Source);\n    pragma Inline (Next_Index);\n    pragma Inline (Next_Inlined_Subprogram);\n@@ -9343,6 +9357,7 @@ package Einfo is\n    pragma Inline (Set_Must_Have_Preelab_Init);\n    pragma Inline (Set_Needs_Debug_Info);\n    pragma Inline (Set_Needs_No_Actuals);\n+   pragma Inline (Set_Nested_Scenarios);\n    pragma Inline (Set_Never_Set_In_Source);\n    pragma Inline (Set_Next_Inlined_Subprogram);\n    pragma Inline (Set_No_Dynamic_Predicate_On_Actual);"}, {"sha": "0ef99799a1e510d736fbfb69ee0c8e0409fff584", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -630,7 +630,9 @@ package body Exp_Ch4 is\n \n             --    [Deep_]Finalize (Obj_Ref.all);\n \n-            if Needs_Finalization (DesigT) then\n+            if Needs_Finalization (DesigT)\n+              and then not No_Heap_Finalization (PtrT)\n+            then\n                Fin_Call :=\n                  Make_Final_Call\n                    (Obj_Ref =>"}, {"sha": "bca7301449f4038309004fb3e67eeea247773afc", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -924,7 +924,8 @@ package body Exp_Intr is\n       Arg       : constant Node_Id    := First_Actual (N);\n       Loc       : constant Source_Ptr := Sloc (N);\n       Typ       : constant Entity_Id  := Etype (Arg);\n-      Desig_Typ : constant Entity_Id  := Designated_Type (Typ);\n+      Desig_Typ : constant Entity_Id  :=\n+                    Available_View (Designated_Type (Typ));\n       Needs_Fin : constant Boolean    := Needs_Finalization (Desig_Typ);\n       Root_Typ  : constant Entity_Id  := Underlying_Type (Root_Type (Typ));\n       Pool      : constant Entity_Id  := Associated_Storage_Pool (Root_Typ);"}, {"sha": "d51d3973b4d15dbd70c57a17e92b2c9e786715c7", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -322,7 +322,6 @@ GNAT_ADA_OBJS =\t\\\n  ada/libgnat/g-spchge.o\t\\\n  ada/libgnat/g-speche.o\t\\\n  ada/libgnat/g-u3spch.o\t\\\n- ada/get_spark_xrefs.o\t\\\n  ada/get_targ.o\t\\\n  ada/ghost.o\t\\\n  ada/libgnat/gnat.o\t\\\n@@ -352,7 +351,6 @@ GNAT_ADA_OBJS =\t\\\n  ada/par_sco.o\t\\\n  ada/prep.o\t\\\n  ada/prepcomp.o\t\\\n- ada/put_spark_xrefs.o\t\\\n  ada/put_scos.o\t\\\n  ada/repinfo.o\t\\\n  ada/restrict.o\t\\"}, {"sha": "9b82d5bfdd1d089f63ae820cc20a4b8fc40e112a", "filename": "gcc/ada/get_spark_xrefs.adb", "status": "removed", "additions": 0, "deletions": 493, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fget_spark_xrefs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fget_spark_xrefs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_spark_xrefs.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -1,493 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       G E T _ S P A R K _ X R E F S                      --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with SPARK_Xrefs; use SPARK_Xrefs;\n-with Types;       use Types;\n-\n-with Ada.IO_Exceptions; use Ada.IO_Exceptions;\n-\n-procedure Get_SPARK_Xrefs is\n-   C : Character;\n-\n-   use ASCII;\n-   --  For CR/LF\n-\n-   Cur_File : Nat;\n-   --  Dependency number for the current file\n-\n-   Cur_Scope : Nat;\n-   --  Scope number for the current scope entity\n-\n-   Cur_File_Idx : File_Index;\n-   --  Index in SPARK_File_Table of the current file\n-\n-   Cur_Scope_Idx : Scope_Index;\n-   --  Index in SPARK_Scope_Table of the current scope\n-\n-   Name_Str : String (1 .. 32768);\n-   Name_Len : Natural := 0;\n-   --  Local string used to store name of File/entity scanned as\n-   --  Name_Str (1 .. Name_Len).\n-\n-   File_Name : String_Ptr;\n-   Unit_File_Name : String_Ptr;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function At_EOL return Boolean;\n-   --  Skips any spaces, then checks if at the end of a line. If so, returns\n-   --  True (but does not skip the EOL sequence). If not, then returns False.\n-\n-   procedure Check (C : Character);\n-   --  Checks that file is positioned at given character, and if so skips past\n-   --  it, If not, raises Data_Error.\n-\n-   function Get_Nat return Nat;\n-   --  On entry the file is positioned to a digit. On return, the file is\n-   --  positioned past the last digit, and the returned result is the decimal\n-   --  value read. Data_Error is raised for overflow (value greater than\n-   --  Int'Last), or if the initial character is not a digit.\n-\n-   procedure Get_Name;\n-   --  On entry the file is positioned to a name. On return, the file is\n-   --  positioned past the last character, and the name scanned is returned\n-   --  in Name_Str (1 .. Name_Len).\n-\n-   procedure Skip_EOL;\n-   --  Called with the current character about to be read being LF or CR. Skips\n-   --  past CR/LF characters until either a non-CR/LF character is found, or\n-   --  the end of file is encountered.\n-\n-   procedure Skip_Spaces;\n-   --  Skips zero or more spaces at the current position, leaving the file\n-   --  positioned at the first non-blank character (or Types.EOF).\n-\n-   ------------\n-   -- At_EOL --\n-   ------------\n-\n-   function At_EOL return Boolean is\n-   begin\n-      Skip_Spaces;\n-      return Nextc = CR or else Nextc = LF;\n-   end At_EOL;\n-\n-   -----------\n-   -- Check --\n-   -----------\n-\n-   procedure Check (C : Character) is\n-   begin\n-      if Nextc = C then\n-         Skipc;\n-      else\n-         raise Data_Error;\n-      end if;\n-   end Check;\n-\n-   -------------\n-   -- Get_Nat --\n-   -------------\n-\n-   function Get_Nat return Nat is\n-      C   : Character := Nextc;\n-      Val : Nat := 0;\n-\n-   begin\n-      if C not in '0' .. '9' then\n-         raise Data_Error;\n-      end if;\n-\n-      --  Loop to read digits of integer value\n-\n-      loop\n-         declare\n-            pragma Unsuppress (Overflow_Check);\n-         begin\n-            Val := Val * 10 + (Character'Pos (C) - Character'Pos ('0'));\n-         end;\n-\n-         Skipc;\n-         C := Nextc;\n-\n-         exit when C not in '0' .. '9';\n-      end loop;\n-\n-      return Val;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Get_Nat;\n-\n-   --------------\n-   -- Get_Name --\n-   --------------\n-\n-   procedure Get_Name is\n-      N : Natural := 0;\n-\n-   begin\n-      while Nextc > ' ' loop\n-         N := N + 1;\n-         Name_Str (N) := Getc;\n-      end loop;\n-\n-      Name_Len := N;\n-   end Get_Name;\n-\n-   --------------\n-   -- Skip_EOL --\n-   --------------\n-\n-   procedure Skip_EOL is\n-      C : Character;\n-\n-   begin\n-      loop\n-         Skipc;\n-         C := Nextc;\n-         exit when C /= LF and then C /= CR;\n-\n-         if C = ' ' then\n-            Skip_Spaces;\n-            C := Nextc;\n-            exit when C /= LF and then C /= CR;\n-         end if;\n-      end loop;\n-   end Skip_EOL;\n-\n-   -----------------\n-   -- Skip_Spaces --\n-   -----------------\n-\n-   procedure Skip_Spaces is\n-   begin\n-      while Nextc = ' ' loop\n-         Skipc;\n-      end loop;\n-   end Skip_Spaces;\n-\n---  Start of processing for Get_SPARK_Xrefs\n-\n-begin\n-   Initialize_SPARK_Tables;\n-\n-   Cur_File      := 0;\n-   Cur_Scope     := 0;\n-   Cur_File_Idx  := 1;\n-   Cur_Scope_Idx := 0;\n-\n-   --  Loop through lines of SPARK cross-reference information\n-\n-   while Nextc = 'F' loop\n-      Skipc;\n-\n-      C := Getc;\n-\n-      --  Make sure first line is a File line\n-\n-      if SPARK_File_Table.Last = 0 and then C /= 'D' then\n-         raise Data_Error;\n-      end if;\n-\n-      --  Otherwise dispatch on type of line\n-\n-      case C is\n-\n-         --  Header entry for scope section\n-\n-         when 'D' =>\n-\n-            --  Complete previous entry if any\n-\n-            if SPARK_File_Table.Last /= 0 then\n-               SPARK_File_Table.Table (SPARK_File_Table.Last).To_Scope :=\n-                 SPARK_Scope_Table.Last;\n-            end if;\n-\n-            --  Scan out dependency number and file name\n-\n-            Skip_Spaces;\n-            Cur_File := Get_Nat;\n-            Skip_Spaces;\n-\n-            Get_Name;\n-            File_Name := new String'(Name_Str (1 .. Name_Len));\n-            Skip_Spaces;\n-\n-            --  Scan out unit file name when present (for subunits)\n-\n-            if Nextc = '-' then\n-               Skipc;\n-               Check ('>');\n-               Skip_Spaces;\n-               Get_Name;\n-               Unit_File_Name := new String'(Name_Str (1 .. Name_Len));\n-\n-            else\n-               Unit_File_Name := null;\n-            end if;\n-\n-            --  Make new File table entry (will fill in To_Scope later)\n-\n-            SPARK_File_Table.Append (\n-              (File_Name      => File_Name,\n-               Unit_File_Name => Unit_File_Name,\n-               File_Num       => Cur_File,\n-               From_Scope     => SPARK_Scope_Table.Last + 1,\n-               To_Scope       => 0));\n-\n-            --  Initialize counter for scopes\n-\n-            Cur_Scope := 1;\n-\n-         --  Scope entry\n-\n-         when 'S' =>\n-            declare\n-               Spec_File  : Nat;\n-               Spec_Scope : Nat;\n-               Scope      : Nat;\n-               Line       : Nat;\n-               Col        : Nat;\n-               Typ        : Character;\n-\n-            begin\n-               --  Scan out location\n-\n-               Skip_Spaces;\n-               Check ('.');\n-               Scope := Get_Nat;\n-               Check (' ');\n-               Line  := Get_Nat;\n-               Typ   := Getc;\n-               Col   := Get_Nat;\n-\n-               pragma Assert (Scope = Cur_Scope);\n-\n-               --  Scan out scope entity name\n-\n-               Skip_Spaces;\n-               Get_Name;\n-               Skip_Spaces;\n-\n-               if Nextc = '-' then\n-                  Skipc;\n-                  Check ('>');\n-                  Skip_Spaces;\n-                  Spec_File := Get_Nat;\n-                  Check ('.');\n-                  Spec_Scope := Get_Nat;\n-\n-               else\n-                  Spec_File  := 0;\n-                  Spec_Scope := 0;\n-               end if;\n-\n-               --  Make new scope table entry (will fill in From_Xref and\n-               --  To_Xref later). Initial range (From_Xref .. To_Xref) is\n-               --  empty for scopes without entities.\n-\n-               SPARK_Scope_Table.Append (\n-                 (Scope_Entity   => Empty,\n-                  Scope_Name     => new String'(Name_Str (1 .. Name_Len)),\n-                  File_Num       => Cur_File,\n-                  Scope_Num      => Cur_Scope,\n-                  Spec_File_Num  => Spec_File,\n-                  Spec_Scope_Num => Spec_Scope,\n-                  Line           => Line,\n-                  Stype          => Typ,\n-                  Col            => Col,\n-                  From_Xref      => 1,\n-                  To_Xref        => 0));\n-            end;\n-\n-            --  Update counter for scopes\n-\n-            Cur_Scope := Cur_Scope + 1;\n-\n-         --  Header entry for cross-ref section\n-\n-         when 'X' =>\n-\n-            --  Scan out dependency number and file name (ignored)\n-\n-            Skip_Spaces;\n-            Cur_File := Get_Nat;\n-            Skip_Spaces;\n-            Get_Name;\n-\n-            --  Update component From_Xref of current file if first reference\n-            --  in this file.\n-\n-            while SPARK_File_Table.Table (Cur_File_Idx).File_Num /= Cur_File\n-            loop\n-               Cur_File_Idx := Cur_File_Idx + 1;\n-            end loop;\n-\n-            --  Scan out scope entity number and entity name (ignored)\n-\n-            Skip_Spaces;\n-            Check ('.');\n-            Cur_Scope := Get_Nat;\n-            Skip_Spaces;\n-            Get_Name;\n-\n-            --  Update component To_Xref of previous scope\n-\n-            if Cur_Scope_Idx /= 0 then\n-               SPARK_Scope_Table.Table (Cur_Scope_Idx).To_Xref :=\n-                 SPARK_Xref_Table.Last;\n-            end if;\n-\n-            --  Update component From_Xref of current scope\n-\n-            Cur_Scope_Idx := SPARK_File_Table.Table (Cur_File_Idx).From_Scope;\n-\n-            while SPARK_Scope_Table.Table (Cur_Scope_Idx).Scope_Num /=\n-              Cur_Scope\n-            loop\n-               Cur_Scope_Idx := Cur_Scope_Idx + 1;\n-            end loop;\n-\n-            SPARK_Scope_Table.Table (Cur_Scope_Idx).From_Xref :=\n-              SPARK_Xref_Table.Last + 1;\n-\n-         --  Cross reference entry\n-\n-         when ' ' =>\n-            declare\n-               XR_Entity      : String_Ptr;\n-               XR_Entity_Line : Nat;\n-               XR_Entity_Col  : Nat;\n-               XR_Entity_Typ  : Character;\n-\n-               XR_File : Nat;\n-               --  Keeps track of the current file (changed by nn|)\n-\n-               XR_Scope : Nat;\n-               --  Keeps track of the current scope (changed by nn:)\n-\n-            begin\n-               XR_File  := Cur_File;\n-               XR_Scope := Cur_Scope;\n-\n-               XR_Entity_Line := Get_Nat;\n-               XR_Entity_Typ  := Getc;\n-               XR_Entity_Col  := Get_Nat;\n-\n-               Skip_Spaces;\n-               Get_Name;\n-               XR_Entity := new String'(Name_Str (1 .. Name_Len));\n-\n-               --  Initialize to scan items on one line\n-\n-               Skip_Spaces;\n-\n-               --  Loop through cross-references for this entity\n-\n-               loop\n-                  declare\n-                     Line  : Nat;\n-                     Col   : Nat;\n-                     N     : Nat;\n-                     Rtype : Character;\n-\n-                  begin\n-                     Skip_Spaces;\n-\n-                     if At_EOL then\n-                        Skip_EOL;\n-                        exit when Nextc /= '.';\n-                        Skipc;\n-                        Skip_Spaces;\n-                     end if;\n-\n-                     if Nextc = '.' then\n-                        Skipc;\n-                        XR_Scope := Get_Nat;\n-                        Check (':');\n-\n-                     else\n-                        N := Get_Nat;\n-\n-                        if Nextc = '|' then\n-                           XR_File := N;\n-                           Skipc;\n-\n-                        else\n-                           Line  := N;\n-                           Rtype := Getc;\n-                           Col   := Get_Nat;\n-\n-                           pragma Assert\n-                             (Rtype = 'r' or else\n-                              Rtype = 'c' or else\n-                              Rtype = 'm' or else\n-                              Rtype = 's');\n-\n-                           SPARK_Xref_Table.Append (\n-                             (Entity_Name => XR_Entity,\n-                              Entity_Line => XR_Entity_Line,\n-                              Etype       => XR_Entity_Typ,\n-                              Entity_Col  => XR_Entity_Col,\n-                              File_Num    => XR_File,\n-                              Scope_Num   => XR_Scope,\n-                              Line        => Line,\n-                              Rtype       => Rtype,\n-                              Col         => Col));\n-                        end if;\n-                     end if;\n-                  end;\n-               end loop;\n-            end;\n-\n-         --  No other SPARK lines are possible\n-\n-         when others =>\n-            raise Data_Error;\n-      end case;\n-\n-      --  For cross reference lines, the EOL character has been skipped already\n-\n-      if C /= ' ' then\n-         Skip_EOL;\n-      end if;\n-   end loop;\n-\n-   --  Here with all Xrefs stored, complete last entries in File/Scope tables\n-\n-   if SPARK_File_Table.Last /= 0 then\n-      SPARK_File_Table.Table (SPARK_File_Table.Last).To_Scope :=\n-        SPARK_Scope_Table.Last;\n-   end if;\n-\n-   if Cur_Scope_Idx /= 0 then\n-      SPARK_Scope_Table.Table (Cur_Scope_Idx).To_Xref := SPARK_Xref_Table.Last;\n-   end if;\n-end Get_SPARK_Xrefs;"}, {"sha": "22af7edccc20fe67dfbf259a5e028655bd723abd", "filename": "gcc/ada/get_spark_xrefs.ads", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fget_spark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fget_spark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_spark_xrefs.ads?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -1,60 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       G E T _ S P A R K _ X R E F S                      --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains the function used to read SPARK cross-reference\n---  information from an ALI file and populate the tables defined in package\n---  SPARK_Xrefs with the result.\n-\n-generic\n-   --  These subprograms provide access to the ALI file. Locating, opening and\n-   --  providing access to the ALI file is the callers' responsibility.\n-\n-   with function Getc return Character is <>;\n-   --  Get next character, positioning the ALI file ready to read the following\n-   --  character (equivalent to calling Nextc, then Skipc). If the end of file\n-   --  is encountered, the value Types.EOF is returned.\n-\n-   with function Nextc return Character is <>;\n-   --  Look at the next character, and return it, leaving the position of the\n-   --  file unchanged, so that a subsequent call to Getc or Nextc will return\n-   --  this same character. If the file is positioned at the end of file, then\n-   --  Types.EOF is returned.\n-\n-   with procedure Skipc is <>;\n-   --  Skip past the current character (which typically was read with Nextc),\n-   --  and position to the next character, which will be returned by the next\n-   --  call to Getc or Nextc.\n-\n-procedure Get_SPARK_Xrefs;\n---  Load SPARK cross-reference information from ALI file text format into\n---  internal SPARK tables (SPARK_Xrefs.SPARK_Xref_Table,\n---  SPARK_Xrefs.SPARK_Scope_Table and SPARK_Xrefs.SPARK_File_Table). On entry\n---  the input file is positioned to the initial 'F' of the first SPARK specific\n---  line in the ALI file. On return, the file is positioned either to the end\n---  of file, or to the first character of the line following the SPARK specific\n---  information (which will never start with an 'F').\n---\n---  If a format error is detected in the input, then an exception is raised\n---  (Ada.IO_Exceptions.Data_Error), with the file positioned to the error."}, {"sha": "19e05d4541b0b2514bd91f318d63e43d240d0766", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -1572,7 +1572,6 @@ package body Lib.Writ is\n       if Opt.Xref_Active and then GNATprove_Mode then\n          SPARK_Specific.Collect_SPARK_Xrefs (Sdep_Table => Sdep_Table,\n                                              Num_Sdep   => Num_Sdep);\n-         SPARK_Specific.Output_SPARK_Xrefs;\n       end if;\n \n       --  Output final blank line and we are done. This final blank line is"}, {"sha": "c3bad8d784dd0a4a355c77016b3e46aa9d03d4ab", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -139,30 +139,17 @@ package body SPARK_Specific is\n          case Ekind (E) is\n             when E_Entry\n                | E_Entry_Family\n+               | E_Function\n                | E_Generic_Function\n                | E_Generic_Package\n                | E_Generic_Procedure\n                | E_Package\n+               | E_Procedure\n                | E_Protected_Type\n                | E_Task_Type\n             =>\n                Typ := Xref_Entity_Letters (Ekind (E));\n \n-            when E_Function\n-               | E_Procedure\n-            =>\n-               --  In SPARK we need to distinguish protected functions and\n-               --  procedures from ordinary subprograms, but there are no\n-               --  special Xref letters for them. Since this distiction is\n-               --  only needed to detect protected calls, we pretend that\n-               --  such calls are entry calls.\n-\n-               if Ekind (Scope (E)) = E_Protected_Type then\n-                  Typ := Xref_Entity_Letters (E_Entry);\n-               else\n-                  Typ := Xref_Entity_Letters (Ekind (E));\n-               end if;\n-\n             when E_Package_Body\n                | E_Protected_Body\n                | E_Subprogram_Body\n@@ -670,7 +657,6 @@ package body SPARK_Specific is\n       Prev_Loc   : Source_Ptr;\n       Prev_Typ   : Character;\n       Ref_Count  : Nat;\n-      Ref_Id     : Entity_Id;\n       Ref_Name   : String_Ptr;\n       Scope_Id   : Scope_Index;\n \n@@ -795,7 +781,6 @@ package body SPARK_Specific is\n          return;\n       end if;\n \n-      Ref_Id     := Empty;\n       Scope_Id   := 1;\n       From_Index := 1;\n \n@@ -833,7 +818,7 @@ package body SPARK_Specific is\n                pragma Assert (Scope_Id <= SPARK_Scope_Table.Last);\n             end loop;\n \n-            if Ref.Ent /= Ref_Id then\n+            if Present (Ref.Ent) then\n                Ref_Name := new String'(Unique_Name (Ref.Ent));\n             end if;\n "}, {"sha": "513d5924126cd12ee9c4a2ef2e50bd643fcaa002", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -27,6 +27,7 @@ with Atree;    use Atree;\n with Csets;    use Csets;\n with Elists;   use Elists;\n with Errout;   use Errout;\n+with Lib.Util; use Lib.Util;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Restrict; use Restrict;"}, {"sha": "f827eb449796acf87ea81369fb2240360de4b4c6", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -26,9 +26,7 @@\n --  This package contains for collecting and outputting cross-reference\n --  information.\n \n-with Einfo;           use Einfo;\n-with Lib.Util;        use Lib.Util;\n-with Put_SPARK_Xrefs;\n+with Einfo; use Einfo;\n \n package Lib.Xref is\n \n@@ -647,11 +645,6 @@ package Lib.Xref is\n       --  files and scopes) and from shared cross-references. Fill in the\n       --  tables in library package called SPARK_Xrefs.\n \n-      procedure Output_SPARK_Xrefs is new Put_SPARK_Xrefs;\n-      --  Output SPARK cross-reference information to the ALI files, based on\n-      --  the information collected in the tables in library package called\n-      --  SPARK_Xrefs, and using routines in Lib.Util.\n-\n       generic\n          with procedure Process (N : Node_Id) is <>;\n       procedure Traverse_Compilation_Unit"}, {"sha": "a65fa8a92909b311b7ce85c9981c65eaf12c3261", "filename": "gcc/ada/put_spark_xrefs.adb", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fput_spark_xrefs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fput_spark_xrefs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_spark_xrefs.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -1,194 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       P U T _ S P A R K _ X R E F S                      --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with SPARK_Xrefs; use SPARK_Xrefs;\n-\n-procedure Put_SPARK_Xrefs is\n-begin\n-   --  Loop through entries in SPARK_File_Table\n-\n-   for J in 1 .. SPARK_File_Table.Last loop\n-      declare\n-         F : SPARK_File_Record renames SPARK_File_Table.Table (J);\n-\n-      begin\n-         Write_Info_Initiate ('F');\n-         Write_Info_Char ('D');\n-         Write_Info_Char (' ');\n-         Write_Info_Nat (F.File_Num);\n-         Write_Info_Char (' ');\n-\n-         Write_Info_Str (F.File_Name.all);\n-\n-         --  If file is a subunit, print the file name for the unit\n-\n-         if F.Unit_File_Name /= null then\n-            Write_Info_Str (\" -> \" & F.Unit_File_Name.all);\n-         end if;\n-\n-         Write_Info_Terminate;\n-\n-         --  Loop through scope entries for this file\n-\n-         for J in F.From_Scope .. F.To_Scope loop\n-            declare\n-               S : SPARK_Scope_Record renames SPARK_Scope_Table.Table (J);\n-\n-            begin\n-               Write_Info_Initiate ('F');\n-               Write_Info_Char ('S');\n-               Write_Info_Char (' ');\n-               Write_Info_Char ('.');\n-               Write_Info_Nat (S.Scope_Num);\n-               Write_Info_Char (' ');\n-               Write_Info_Nat (S.Line);\n-               Write_Info_Char (S.Stype);\n-               Write_Info_Nat (S.Col);\n-               Write_Info_Char (' ');\n-\n-               pragma Assert (S.Scope_Name.all /= \"\");\n-\n-               Write_Info_Str (S.Scope_Name.all);\n-\n-               if S.Spec_File_Num /= 0 then\n-                  Write_Info_Str (\" -> \");\n-                  Write_Info_Nat (S.Spec_File_Num);\n-                  Write_Info_Char ('.');\n-                  Write_Info_Nat (S.Spec_Scope_Num);\n-               end if;\n-\n-               Write_Info_Terminate;\n-            end;\n-         end loop;\n-      end;\n-   end loop;\n-\n-   --  Loop through entries in SPARK_File_Table\n-\n-   for J in 1 .. SPARK_File_Table.Last loop\n-      declare\n-         F           : SPARK_File_Record renames SPARK_File_Table.Table (J);\n-         File        : Nat;\n-         Scope       : Nat;\n-         Entity_Line : Nat;\n-         Entity_Col  : Nat;\n-\n-      begin\n-         --  Loop through scope entries for this file\n-\n-         for K in F.From_Scope .. F.To_Scope loop\n-            Output_One_Scope : declare\n-               S : SPARK_Scope_Record renames SPARK_Scope_Table.Table (K);\n-\n-            begin\n-               --  Write only non-empty tables\n-\n-               if S.From_Xref <= S.To_Xref then\n-\n-                  Write_Info_Initiate ('F');\n-                  Write_Info_Char ('X');\n-                  Write_Info_Char (' ');\n-                  Write_Info_Nat (F.File_Num);\n-                  Write_Info_Char (' ');\n-\n-                  Write_Info_Str (F.File_Name.all);\n-\n-                  Write_Info_Char (' ');\n-                  Write_Info_Char ('.');\n-                  Write_Info_Nat (S.Scope_Num);\n-                  Write_Info_Char (' ');\n-\n-                  Write_Info_Str (S.Scope_Name.all);\n-\n-                  --  Default value of (0,0) is used for the special __HEAP\n-                  --  variable so use another default value.\n-\n-                  Entity_Line := 0;\n-                  Entity_Col  := 1;\n-\n-                  --  Loop through cross reference entries for this scope\n-\n-                  for X in S.From_Xref .. S.To_Xref loop\n-\n-                     Output_One_Xref : declare\n-                        R : SPARK_Xref_Record renames\n-                              SPARK_Xref_Table.Table (X);\n-\n-                     begin\n-                        if R.Entity_Line /= Entity_Line\n-                          or else R.Entity_Col /= Entity_Col\n-                        then\n-                           Write_Info_Terminate;\n-\n-                           Write_Info_Initiate ('F');\n-                           Write_Info_Char (' ');\n-                           Write_Info_Nat (R.Entity_Line);\n-                           Write_Info_Char (R.Etype);\n-                           Write_Info_Nat (R.Entity_Col);\n-                           Write_Info_Char (' ');\n-\n-                           Write_Info_Str (R.Entity_Name.all);\n-\n-                           Entity_Line := R.Entity_Line;\n-                           Entity_Col  := R.Entity_Col;\n-                           File        := F.File_Num;\n-                           Scope       := S.Scope_Num;\n-                        end if;\n-\n-                        if Write_Info_Col > 72 then\n-                           Write_Info_Terminate;\n-                           Write_Info_Initiate ('.');\n-                        end if;\n-\n-                        Write_Info_Char (' ');\n-\n-                        if R.File_Num /= File then\n-                           Write_Info_Nat (R.File_Num);\n-                           Write_Info_Char ('|');\n-                           File  := R.File_Num;\n-                           Scope := 0;\n-                        end if;\n-\n-                        if R.Scope_Num /= Scope then\n-                           Write_Info_Char ('.');\n-                           Write_Info_Nat (R.Scope_Num);\n-                           Write_Info_Char (':');\n-                           Scope := R.Scope_Num;\n-                        end if;\n-\n-                        Write_Info_Nat (R.Line);\n-                        Write_Info_Char (R.Rtype);\n-                        Write_Info_Nat (R.Col);\n-                     end Output_One_Xref;\n-\n-                  end loop;\n-\n-                  Write_Info_Terminate;\n-               end if;\n-            end Output_One_Scope;\n-         end loop;\n-      end;\n-   end loop;\n-end Put_SPARK_Xrefs;"}, {"sha": "fa4a4bc04e0cb2052dd9a81af2e8f81720f772cb", "filename": "gcc/ada/put_spark_xrefs.ads", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fput_spark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fput_spark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_spark_xrefs.ads?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -1,62 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       P U T _ S P A R K _ X R E F S                      --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains the function used to read SPARK cross-reference\n---  information from the internal tables defined in package SPARK_Xrefs, and\n---  output text information for the ALI file. The interface allows control over\n---  the destination of the output, so that this routine can also be used for\n---  debugging purposes.\n-\n-with Types; use Types;\n-\n-generic\n-   --  The following procedures are used to output text information. The\n-   --  destination of the text information is thus under control of the\n-   --  particular instantiation. In particular, this procedure is used to\n-   --  write output to the ALI file, and also for debugging output.\n-\n-   with function Write_Info_Col return Positive is <>;\n-   --  Return the column in which the next character will be written\n-\n-   with procedure Write_Info_Char (C : Character) is <>;\n-   --  Output one character\n-\n-   with procedure Write_Info_Str (Val : String) is <>;\n-   --  Output string stored in string pointer\n-\n-   with procedure Write_Info_Initiate (Key : Character) is <>;\n-   --  Initiate write of new line to output file, the parameter is the\n-   --  keyword character for the line.\n-\n-   with procedure Write_Info_Nat (N : Nat) is <>;\n-   --  Write image of N to output file with no leading or trailing blanks\n-\n-   with procedure Write_Info_Terminate is <>;\n-   --  Terminate current info line and output lines built in Info_Buffer\n-\n-procedure Put_SPARK_Xrefs;\n---  Read information from SPARK tables (SPARK_Xrefs.SPARK_Xref_Table,\n---  SPARK_Xrefs.SPARK_Scope_Table and SPARK_Xrefs.SPARK_File_Table) and output\n---  corresponding information in ALI format using the Write_Info procedures."}, {"sha": "1e140ee82109ce4d6976621bf99ecf391fc8fe68", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -2371,11 +2371,19 @@ package body Sem_Disp is\n    -----------------------------------\n \n    function Is_Inherited_Public_Operation (Op : Entity_Id) return Boolean is\n-      Prim      : constant Entity_Id := Alias (Op);\n-      Scop      : constant Entity_Id := Scope (Prim);\n+      Prim      : Entity_Id := Op;\n+      Scop      : Entity_Id := Prim;\n       Pack_Decl : Node_Id;\n \n    begin\n+      --  Locate the ultimate non-hidden alias entity\n+\n+      while Present (Alias (Prim)) and then not Is_Hidden (Alias (Prim)) loop\n+         pragma Assert (Alias (Prim) /= Prim);\n+         Prim := Alias (Prim);\n+         Scop := Scope (Prim);\n+      end loop;\n+\n       if Comes_From_Source (Prim) and then Ekind (Scop) = E_Package then\n          Pack_Decl := Unit_Declaration_Node (Scop);\n          return Nkind (Pack_Decl) = N_Package_Declaration"}, {"sha": "2fb8289eef36d57a0487b7bf4938d860b837b165", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 160, "deletions": 62, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -26,6 +26,7 @@\n with Atree;    use Atree;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Tss;  use Exp_Tss;\n@@ -8502,84 +8503,172 @@ package body Sem_Elab is\n       In_Partial_Fin : Boolean;\n       In_Task_Body   : Boolean)\n    is\n-      function Is_Potential_Scenario (Nod : Node_Id) return Traverse_Result;\n-      --  Determine whether arbitrary node Nod denotes a suitable scenario and\n-      --  if so, process it.\n+      procedure Find_And_Process_Nested_Scenarios;\n+      pragma Inline (Find_And_Process_Nested_Scenarios);\n+      --  Examine the declarations and statements of subprogram body N for\n+      --  suitable scenarios. Save each discovered scenario and process it\n+      --  accordingly.\n+\n+      procedure Process_Nested_Scenarios (Nested : Elist_Id);\n+      pragma Inline (Process_Nested_Scenarios);\n+      --  Invoke Process_Scenario on each individual scenario whith appears in\n+      --  list Nested.\n+\n+      ---------------------------------------\n+      -- Find_And_Process_Nested_Scenarios --\n+      ---------------------------------------\n+\n+      procedure Find_And_Process_Nested_Scenarios is\n+         Body_Id : constant Entity_Id := Defining_Entity (N);\n+\n+         function Is_Potential_Scenario\n+           (Nod : Node_Id) return Traverse_Result;\n+         --  Determine whether arbitrary node Nod denotes a suitable scenario.\n+         --  If it does, save it in the Nested_Scenarios list of the subprogram\n+         --  body, and process it.\n+\n+         procedure Save_Scenario (Nod : Node_Id);\n+         pragma Inline (Save_Scenario);\n+         --  Save scenario Nod in the Nested_Scenarios list of the subprogram\n+         --  body.\n \n-      procedure Traverse_Potential_Scenarios is\n-        new Traverse_Proc (Is_Potential_Scenario);\n+         procedure Traverse_List (List : List_Id);\n+         pragma Inline (Traverse_List);\n+         --  Invoke Traverse_Potential_Scenarios on each node in list List\n \n-      procedure Traverse_List (List : List_Id);\n-      --  Inspect list List for suitable elaboration scenarios and process them\n+         procedure Traverse_Potential_Scenarios is\n+           new Traverse_Proc (Is_Potential_Scenario);\n \n-      ---------------------------\n-      -- Is_Potential_Scenario --\n-      ---------------------------\n+         ---------------------------\n+         -- Is_Potential_Scenario --\n+         ---------------------------\n \n-      function Is_Potential_Scenario (Nod : Node_Id) return Traverse_Result is\n-      begin\n-         --  Special cases\n+         function Is_Potential_Scenario\n+           (Nod : Node_Id) return Traverse_Result\n+         is\n+         begin\n+            --  Special cases\n \n-         --  Skip constructs which do not have elaboration of their own and\n-         --  need to be elaborated by other means such as invocation, task\n-         --  activation, etc.\n+            --  Skip constructs which do not have elaboration of their own and\n+            --  need to be elaborated by other means such as invocation, task\n+            --  activation, etc.\n \n-         if Is_Non_Library_Level_Encapsulator (Nod) then\n-            return Skip;\n+            if Is_Non_Library_Level_Encapsulator (Nod) then\n+               return Skip;\n \n-         --  Terminate the traversal of a task body with an accept statement\n-         --  when no entry calls in elaboration are allowed because the task\n-         --  will block at run-time and none of the remaining statements will\n-         --  be executed.\n+            --  Terminate the traversal of a task body with an accept statement\n+            --  when no entry calls in elaboration are allowed because the task\n+            --  will block at run-time and the remaining statements will not be\n+            --  executed.\n \n-         elsif Nkind_In (Original_Node (Nod), N_Accept_Statement,\n-                                              N_Selective_Accept)\n-           and then Restriction_Active (No_Entry_Calls_In_Elaboration_Code)\n-         then\n-            return Abandon;\n+            elsif Nkind_In (Original_Node (Nod), N_Accept_Statement,\n+                                                 N_Selective_Accept)\n+              and then Restriction_Active (No_Entry_Calls_In_Elaboration_Code)\n+            then\n+               return Abandon;\n \n-         --  Certain nodes carry semantic lists which act as repositories until\n-         --  expansion transforms the node and relocates the contents. Examine\n-         --  these lists in case expansion is disabled.\n+            --  Certain nodes carry semantic lists which act as repositories\n+            --  until expansion transforms the node and relocates the contents.\n+            --  Examine these lists in case expansion is disabled.\n \n-         elsif Nkind_In (Nod, N_And_Then, N_Or_Else) then\n-            Traverse_List (Actions (Nod));\n+            elsif Nkind_In (Nod, N_And_Then, N_Or_Else) then\n+               Traverse_List (Actions (Nod));\n \n-         elsif Nkind_In (Nod, N_Elsif_Part, N_Iteration_Scheme) then\n-            Traverse_List (Condition_Actions (Nod));\n+            elsif Nkind_In (Nod, N_Elsif_Part, N_Iteration_Scheme) then\n+               Traverse_List (Condition_Actions (Nod));\n \n-         elsif Nkind (Nod) = N_If_Expression then\n-            Traverse_List (Then_Actions (Nod));\n-            Traverse_List (Else_Actions (Nod));\n+            elsif Nkind (Nod) = N_If_Expression then\n+               Traverse_List (Then_Actions (Nod));\n+               Traverse_List (Else_Actions (Nod));\n \n-         elsif Nkind_In (Nod, N_Component_Association,\n-                              N_Iterated_Component_Association)\n-         then\n-            Traverse_List (Loop_Actions (Nod));\n+            elsif Nkind_In (Nod, N_Component_Association,\n+                                 N_Iterated_Component_Association)\n+            then\n+               Traverse_List (Loop_Actions (Nod));\n \n-         --  General case\n+            --  General case\n \n-         elsif Is_Suitable_Scenario (Nod) then\n-            Process_Scenario (Nod, In_Partial_Fin, In_Task_Body);\n-         end if;\n+            --  Save a suitable scenario in the Nested_Scenarios list of the\n+            --  subprogram body. As a result any subsequent traversals of the\n+            --  subprogram body started from a different top level scenario no\n+            --  longer need to reexamine the tree.\n+\n+            elsif Is_Suitable_Scenario (Nod) then\n+               Save_Scenario (Nod);\n+               Process_Scenario (Nod, In_Partial_Fin, In_Task_Body);\n+            end if;\n \n-         return OK;\n-      end Is_Potential_Scenario;\n+            return OK;\n+         end Is_Potential_Scenario;\n \n-      -------------------\n-      -- Traverse_List --\n-      -------------------\n+         -------------------\n+         -- Save_Scenario --\n+         -------------------\n \n-      procedure Traverse_List (List : List_Id) is\n-         Item : Node_Id;\n+         procedure Save_Scenario (Nod : Node_Id) is\n+            Nested : Elist_Id;\n+\n+         begin\n+            Nested := Nested_Scenarios (Body_Id);\n+\n+            if No (Nested) then\n+               Nested := New_Elmt_List;\n+               Set_Nested_Scenarios (Body_Id, Nested);\n+            end if;\n+\n+            Append_Elmt (Nod, Nested);\n+         end Save_Scenario;\n+\n+         -------------------\n+         -- Traverse_List --\n+         -------------------\n+\n+         procedure Traverse_List (List : List_Id) is\n+            Item : Node_Id;\n+\n+         begin\n+            Item := First (List);\n+            while Present (Item) loop\n+               Traverse_Potential_Scenarios (Item);\n+               Next (Item);\n+            end loop;\n+         end Traverse_List;\n+\n+      --  Start of processing for Find_And_Process_Nested_Scenarios\n \n       begin\n-         Item := First (List);\n-         while Present (Item) loop\n-            Traverse_Potential_Scenarios (Item);\n-            Next (Item);\n+         --  Examine the declarations for suitable scenarios\n+\n+         Traverse_List (Declarations (N));\n+\n+         --  Examine the handled sequence of statements. This also includes any\n+         --  exceptions handlers.\n+\n+         Traverse_Potential_Scenarios (Handled_Statement_Sequence (N));\n+      end Find_And_Process_Nested_Scenarios;\n+\n+      ------------------------------\n+      -- Process_Nested_Scenarios --\n+      ------------------------------\n+\n+      procedure Process_Nested_Scenarios (Nested : Elist_Id) is\n+         Nested_Elmt : Elmt_Id;\n+\n+      begin\n+         Nested_Elmt := First_Elmt (Nested);\n+         while Present (Nested_Elmt) loop\n+            Process_Scenario\n+              (N              => Node (Nested_Elmt),\n+               In_Partial_Fin => In_Partial_Fin,\n+               In_Task_Body   => In_Task_Body);\n+\n+            Next_Elmt (Nested_Elmt);\n          end loop;\n-      end Traverse_List;\n+      end Process_Nested_Scenarios;\n+\n+      --  Local variables\n+\n+      Nested : Elist_Id;\n \n    --  Start of processing for Traverse_Body\n \n@@ -8605,14 +8694,23 @@ package body Sem_Elab is\n          Visited_Bodies.Set (N, True);\n       end if;\n \n-      --  Examine the declarations for suitable scenarios\n+      Nested := Nested_Scenarios (Defining_Entity (N));\n \n-      Traverse_List (Declarations (N));\n+      --  The subprogram body was already examined as part of the elaboration\n+      --  graph starting from a different top level scenario. There is no need\n+      --  to traverse the declarations and statements again because this will\n+      --  yield the exact same scenarios. Use the nested scenarios collected\n+      --  during the first inspection of the body.\n \n-      --  Examine the handled sequence of statements. This also includes any\n-      --  exceptions handlers.\n+      if Present (Nested) then\n+         Process_Nested_Scenarios (Nested);\n \n-      Traverse_Potential_Scenarios (Handled_Statement_Sequence (N));\n+      --  Otherwise examine the declarations and statements of the subprogram\n+      --  body for suitable scenarios, save and process them accordingly.\n+\n+      else\n+         Find_And_Process_Nested_Scenarios;\n+      end if;\n    end Traverse_Body;\n \n    ---------------------------------"}, {"sha": "ca4e69daba65f0da690d1cd4240d3a76138c852d", "filename": "gcc/ada/spark_xrefs.adb", "status": "modified", "additions": 2, "deletions": 53, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fspark_xrefs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fspark_xrefs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,8 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Output;          use Output;\n-with Put_SPARK_Xrefs;\n+with Output; use Output;\n \n package body SPARK_Xrefs is\n \n@@ -153,54 +152,4 @@ package body SPARK_Xrefs is\n       SPARK_Xref_Table.Init;\n    end Initialize_SPARK_Tables;\n \n-   ------------\n-   -- pspark --\n-   ------------\n-\n-   procedure pspark is\n-\n-      procedure Write_Info_Char (C : Character) renames Write_Char;\n-      --  Write one character\n-\n-      procedure Write_Info_Str (Val : String) renames Write_Str;\n-      --  Write string\n-\n-      function Write_Info_Col return Positive;\n-      --  Return next column for writing\n-\n-      procedure Write_Info_Initiate (Key : Character) renames Write_Char;\n-      --  Start new one and write one character;\n-\n-      procedure Write_Info_Nat (N : Nat);\n-      --  Write value of N\n-\n-      procedure Write_Info_Terminate renames Write_Eol;\n-      --  Terminate current line\n-\n-      --------------------\n-      -- Write_Info_Col --\n-      --------------------\n-\n-      function Write_Info_Col return Positive is\n-      begin\n-         return Positive (Column);\n-      end Write_Info_Col;\n-\n-      --------------------\n-      -- Write_Info_Nat --\n-      --------------------\n-\n-      procedure Write_Info_Nat (N : Nat) is\n-      begin\n-         Write_Int (N);\n-      end Write_Info_Nat;\n-\n-      procedure Debug_Put_SPARK_Xrefs is new Put_SPARK_Xrefs;\n-\n-   --  Start of processing for pspark\n-\n-   begin\n-      Debug_Put_SPARK_Xrefs;\n-   end pspark;\n-\n end SPARK_Xrefs;"}, {"sha": "7fb29392564509dec4c79063eeda1b8777b30f41", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 5, "deletions": 161, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -25,173 +25,21 @@\n \n --  This package defines tables used to store information needed for the SPARK\n --  mode. It is used by procedures in Lib.Xref.SPARK_Specific to build the\n---  SPARK-specific cross-reference information before writing it to the ALI\n---  file, and by Get_SPARK_Xrefs/Put_SPARK_Xrefs to read/write the textual\n---  representation that is stored in the ALI file.\n+--  SPARK-specific cross-reference information.\n \n with Table;\n-with Types;      use Types;\n+with Types; use Types;\n \n package SPARK_Xrefs is\n \n-   --  SPARK cross-reference information can exist in one of two forms. In\n-   --  the ALI file, it is represented using a text format that is described\n-   --  in this specification. Internally it is stored using three tables:\n-   --  SPARK_Xref_Table, SPARK_Scope_Table and SPARK_File_Table, which are\n-   --  also defined in this unit.\n+   --  SPARK cross-reference information is stored internally using three\n+   --  tables: SPARK_Xref_Table, SPARK_Scope_Table and SPARK_File_Table, which\n+   --  are defined in this unit.\n \n    --  Lib.Xref.SPARK_Specific is part of the compiler. It extracts SPARK\n    --  cross-reference information from the complete set of cross-references\n    --  generated during compilation.\n \n-   --  Get_SPARK_Xrefs reads the text lines in ALI format and populates the\n-   --  internal tables with corresponding information.\n-\n-   --  Put_SPARK_Xrefs reads the internal tables and generates text lines in\n-   --  the ALI format.\n-\n-   ----------------------------\n-   -- SPARK Xrefs ALI Format --\n-   ----------------------------\n-\n-   --  SPARK cross-reference information is generated on a unit-by-unit basis\n-   --  in the ALI file, using lines that start with the identifying character F\n-   --  (\"Formal\"). These lines are generated if GNATprove_Mode is True.\n-\n-   --  The SPARK cross-reference information comes after the shared\n-   --  cross-reference information, so it can be ignored by tools like\n-   --  gnatbind, gnatmake, etc.\n-\n-   --  -------------------\n-   --  -- Scope Section --\n-   --  -------------------\n-\n-   --  A first section defines the scopes in which entities are defined and\n-   --  referenced. A scope is a package/subprogram/protected_type/task_type\n-   --  declaration/body. Note that a package declaration and body define two\n-   --  different scopes. Similarly, a subprogram, protected type and task type\n-   --  declaration and body, when both present, define two different scopes.\n-\n-   --    FD dependency-number filename (-> unit-filename)?\n-\n-   --      This header precedes scope information for the unit identified by\n-   --      dependency number and file name. The dependency number is the index\n-   --      into the generated D lines and is ones-origin (e.g. 2 = reference to\n-   --      second generated D line).\n-\n-   --      The list of FD lines should match the list of D lines defined in the\n-   --      ALI file, in the same order.\n-\n-   --      Note that the filename here will reflect the original name if a\n-   --      Source_Reference pragma was encountered (since all line number\n-   --      references will be with respect to the original file).\n-\n-   --      Note: the filename is redundant in that it could be deduced from the\n-   --      corresponding D line, but it is convenient at least for human\n-   --      reading of the SPARK cross-reference information, and means that\n-   --      the SPARK cross-reference information can stand on its own without\n-   --      needing other parts of the ALI file.\n-\n-   --      The optional unit filename is given only for subunits.\n-\n-   --    FS . scope line type col entity (-> spec-file . spec-scope)?\n-\n-   --      (The ? mark stands for an optional entry in the syntax)\n-\n-   --      scope is the ones-origin scope number for the current file (e.g. 2 =\n-   --      reference to the second FS line in this FD block).\n-\n-   --      line is the line number of the scope entity. The name of the entity\n-   --      starts in column col. Columns are numbered from one, and if\n-   --      horizontal tab characters are present, the column number is computed\n-   --      assuming standard 1,9,17,.. tab stops. For example, if the entity is\n-   --      the first token on the line, and is preceded by space-HT-space, then\n-   --      the column would be column 10.\n-\n-   --      type is a single letter identifying the type of the entity, using\n-   --      the same code as in cross-references:\n-\n-   --        K = package (k = generic package)\n-   --        V = function (v = generic function)\n-   --        U = procedure (u = generic procedure)\n-   --        Y = entry\n-\n-   --      col is the column number of the scope entity\n-\n-   --      entity is the name of the scope entity, with casing in the canonical\n-   --      casing for the source file where it is defined.\n-\n-   --      spec-file and spec-scope are respectively the file and scope for the\n-   --      spec corresponding to the current body scope, when they differ.\n-\n-   --  ------------------\n-   --  -- Xref Section --\n-   --  ------------------\n-\n-   --  A second section defines cross-references useful for computing global\n-   --  variables read/written in each subprogram/package/protected_type/\n-   --  task_type.\n-\n-   --    FX dependency-number filename . entity-number entity\n-\n-   --      dependency-number and filename identify a file in FD lines\n-\n-   --      entity-number and entity identify a scope in FS lines\n-   --      for the previously identified file.\n-\n-   --      (filename and entity are just a textual representations of\n-   --       dependency-number and entity-number)\n-\n-   --    F line typ col entity ref*\n-\n-   --      line is the line number of the referenced entity\n-\n-   --      typ is the type of the referenced entity, using a code similar to\n-   --      the one used for cross-references:\n-\n-   --        > = IN parameter\n-   --        < = OUT parameter\n-   --        = = IN OUT parameter\n-   --        * = all other cases\n-\n-   --      col is the column number of the referenced entity\n-\n-   --      entity is the name of the referenced entity as written in the source\n-   --      file where it is defined.\n-\n-   --  There may be zero or more ref entries on each line\n-\n-   --    (file |)? ((. scope :)? line type col)*\n-\n-   --      file is the dependency number of the file with the reference. It and\n-   --      the following vertical bar are omitted if the file is the same as\n-   --      the previous ref, and the refs for the current file are first (and\n-   --      do not need a bar).\n-\n-   --      scope is the scope number of the scope with the reference. It and\n-   --      the following colon are omitted if the scope is the same as the\n-   --      previous ref, and the refs for the current scope are first (and do\n-   --      not need a colon).\n-\n-   --      line is the line number of the reference\n-\n-   --      col is the column number of the reference\n-\n-   --      type is one of the following, using the same code as in\n-   --      cross-references:\n-\n-   --        m = modification\n-   --        r = reference\n-   --        c = reference to constant object\n-   --        s = subprogram reference in a static call\n-\n-   --  Special entries for reads and writes to memory reference a special\n-   --  variable called \"__HEAP\". These special entries are present in every\n-   --  scope where reads and writes to memory are present. Line and column for\n-   --  this special variable are always 0.\n-\n-   --    Examples: ??? add examples here\n-\n    --  -------------------------------\n    --  -- Generated Globals Section --\n    --  -------------------------------\n@@ -389,8 +237,4 @@ package SPARK_Xrefs is\n    --  Debug routine to dump internal SPARK cross-reference tables. This is a\n    --  raw format dump showing exactly what the tables contain.\n \n-   procedure pspark;\n-   --  Debugging procedure to output contents of SPARK cross-reference binary\n-   --  tables in the format in which they appear in an ALI file.\n-\n end SPARK_Xrefs;"}, {"sha": "6ad4de2c158e1d0acae52cff0108cdb8cf308460", "filename": "gcc/ada/spark_xrefs_test.adb", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fspark_xrefs_test.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fspark_xrefs_test.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs_test.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -1,321 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                          GNAT SYSTEM UTILITIES                           --\n---                                                                          --\n---                     S P A R K _ X R E F S _ T E S T                      --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This utility program is used to test proper operation of the\n---  Get_SPARK_Xrefs and Put_SPARK_Xrefs units. To run it, compile any source\n---  file with switch -gnatd.E or -gnatd.F to get an ALI file file.ALI\n---  containing SPARK information. Then run this utility using:\n-\n---     spark_xrefs_test file.ali\n-\n---  This test will read the SPARK cross-reference information from the ALI\n---  file, and use Get_SPARK_Xrefs to store this in binary form in the internal\n---  tables in SPARK_Xrefs. Then Put_SPARK_Xrefs is used to write the\n---  information from these tables back into text form. This output is compared\n---  with the original SPARK cross-reference information in the ALI file and the\n---  two should be identical. If not an error message is output.\n-\n-with Get_SPARK_Xrefs;\n-with Put_SPARK_Xrefs;\n-\n-with SPARK_Xrefs;           use SPARK_Xrefs;\n-with Types;                 use Types;\n-\n-with Ada.Command_Line;      use Ada.Command_Line;\n-with Ada.Streams;           use Ada.Streams;\n-with Ada.Streams.Stream_IO; use Ada.Streams.Stream_IO;\n-with Ada.Text_IO;\n-\n-with GNAT.OS_Lib;           use GNAT.OS_Lib;\n-\n-procedure SPARK_Xrefs_Test is\n-   Infile    : File_Type;\n-   Name1     : String_Access;\n-   Outfile_1 : File_Type;\n-   Name2     : String_Access;\n-   Outfile_2 : File_Type;\n-   C         : Character;\n-\n-   Stop : exception;\n-   --  Terminate execution\n-\n-   Diff_Exec   : constant String_Access := Locate_Exec_On_Path (\"diff\");\n-   Diff_Result : Integer;\n-\n-   use ASCII;\n-\n-begin\n-   if Argument_Count /= 1 then\n-      Ada.Text_IO.Put_Line (\"Usage: spark_xrefs_test FILE.ali\");\n-      raise Stop;\n-   end if;\n-\n-   Name1 := new String'(Argument (1) & \".1\");\n-   Name2 := new String'(Argument (1) & \".2\");\n-\n-   Open   (Infile,    In_File,  Argument (1));\n-   Create (Outfile_1, Out_File, Name1.all);\n-   Create (Outfile_2, Out_File, Name2.all);\n-\n-   --  Read input file till we get to first 'F' line\n-\n-   Process : declare\n-      Output_Col : Positive := 1;\n-\n-      function Get_Char (F : File_Type) return Character;\n-      --  Read one character from specified  file\n-\n-      procedure Put_Char (F : File_Type; C : Character);\n-      --  Write one character to specified file\n-\n-      function Get_Output_Col return Positive;\n-      --  Return current column in output file, where each line starts at\n-      --  column 1 and terminate with LF, and HT is at columns 1, 9, etc.\n-      --  All output is supposed to be carried through Put_Char.\n-\n-      --------------\n-      -- Get_Char --\n-      --------------\n-\n-      function Get_Char (F : File_Type) return Character is\n-         Item : Stream_Element_Array (1 .. 1);\n-         Last : Stream_Element_Offset;\n-\n-      begin\n-         Read (F, Item, Last);\n-\n-         if Last /= 1 then\n-            return Types.EOF;\n-         else\n-            return Character'Val (Item (1));\n-         end if;\n-      end Get_Char;\n-\n-      --------------------\n-      -- Get_Output_Col --\n-      --------------------\n-\n-      function Get_Output_Col return Positive is\n-      begin\n-         return Output_Col;\n-      end Get_Output_Col;\n-\n-      --------------\n-      -- Put_Char --\n-      --------------\n-\n-      procedure Put_Char (F : File_Type; C : Character) is\n-         Item : Stream_Element_Array (1 .. 1);\n-\n-      begin\n-         if C /= CR and then C /= EOF then\n-            if C = LF then\n-               Output_Col := 1;\n-            elsif C = HT then\n-               Output_Col := ((Output_Col + 6) / 8) * 8 + 1;\n-            else\n-               Output_Col := Output_Col + 1;\n-            end if;\n-\n-            Item (1) := Character'Pos (C);\n-            Write (F, Item);\n-         end if;\n-      end Put_Char;\n-\n-      --  Subprograms used by Get_SPARK_Xrefs (these also copy the output to\n-      --  Outfile_1 for later comparison with the output generated by\n-      --  Put_SPARK_Xrefs).\n-\n-      function  Getc  return Character;\n-      function  Nextc return Character;\n-      procedure Skipc;\n-\n-      ----------\n-      -- Getc --\n-      ----------\n-\n-      function Getc  return Character is\n-         C : Character;\n-      begin\n-         C := Get_Char (Infile);\n-         Put_Char (Outfile_1, C);\n-         return C;\n-      end Getc;\n-\n-      -----------\n-      -- Nextc --\n-      -----------\n-\n-      function Nextc return Character is\n-         C : Character;\n-\n-      begin\n-         C := Get_Char (Infile);\n-\n-         if C /= EOF then\n-            Set_Index (Infile, Index (Infile) - 1);\n-         end if;\n-\n-         return C;\n-      end Nextc;\n-\n-      -----------\n-      -- Skipc --\n-      -----------\n-\n-      procedure Skipc is\n-         C : Character;\n-         pragma Unreferenced (C);\n-      begin\n-         C := Getc;\n-      end Skipc;\n-\n-      --  Subprograms used by Put_SPARK_Xrefs, which write information to\n-      --  Outfile_2.\n-\n-      function Write_Info_Col return Positive;\n-      procedure Write_Info_Char (C : Character);\n-      procedure Write_Info_Initiate (Key : Character);\n-      procedure Write_Info_Nat (N : Nat);\n-      procedure Write_Info_Terminate;\n-\n-      --------------------\n-      -- Write_Info_Col --\n-      --------------------\n-\n-      function Write_Info_Col return Positive is\n-      begin\n-         return Get_Output_Col;\n-      end Write_Info_Col;\n-\n-      ---------------------\n-      -- Write_Info_Char --\n-      ---------------------\n-\n-      procedure Write_Info_Char (C : Character) is\n-      begin\n-         Put_Char (Outfile_2, C);\n-      end Write_Info_Char;\n-\n-      -------------------------\n-      -- Write_Info_Initiate --\n-      -------------------------\n-\n-      procedure Write_Info_Initiate (Key : Character) is\n-      begin\n-         Write_Info_Char (Key);\n-      end Write_Info_Initiate;\n-\n-      --------------------\n-      -- Write_Info_Nat --\n-      --------------------\n-\n-      procedure Write_Info_Nat (N : Nat) is\n-      begin\n-         if N > 9 then\n-            Write_Info_Nat (N / 10);\n-         end if;\n-\n-         Write_Info_Char (Character'Val (48 + N mod 10));\n-      end Write_Info_Nat;\n-\n-      --------------------------\n-      -- Write_Info_Terminate --\n-      --------------------------\n-\n-      procedure Write_Info_Terminate is\n-      begin\n-         Write_Info_Char (LF);\n-      end Write_Info_Terminate;\n-\n-      --  Local instantiations of Put_SPARK_Xrefs and Get_SPARK_Xrefs\n-\n-      procedure Get_SPARK_Xrefs_Info is new Get_SPARK_Xrefs;\n-      procedure Put_SPARK_Xrefs_Info is new Put_SPARK_Xrefs;\n-\n-   --  Start of processing for Process\n-\n-   begin\n-      --  Loop to skip till first 'F' line\n-\n-      loop\n-         C := Get_Char (Infile);\n-\n-         if C = EOF then\n-            raise Stop;\n-\n-         elsif C = LF or else C = CR then\n-            loop\n-               C := Get_Char (Infile);\n-               exit when C /= LF and then C /= CR;\n-            end loop;\n-\n-            exit when C = 'F';\n-         end if;\n-      end loop;\n-\n-      --  Position back to initial 'F' of first 'F' line\n-\n-      Set_Index (Infile, Index (Infile) - 1);\n-\n-      --  Read SPARK cross-reference information to internal SPARK tables, also\n-      --  copying SPARK xrefs info to Outfile_1.\n-\n-      Initialize_SPARK_Tables;\n-      Get_SPARK_Xrefs_Info;\n-\n-      --  Write SPARK cross-reference information from internal SPARK tables to\n-      --  Outfile_2.\n-\n-      Put_SPARK_Xrefs_Info;\n-\n-      --  Junk blank line (see comment at end of Lib.Writ)\n-\n-      Write_Info_Terminate;\n-\n-      --  Flush to disk\n-\n-      Close (Outfile_1);\n-      Close (Outfile_2);\n-\n-      --  Now Outfile_1 and Outfile_2 should be identical\n-\n-      Diff_Result :=\n-        Spawn (Diff_Exec.all,\n-               Argument_String_To_List\n-                 (\"-u \" & Name1.all & \" \" & Name2.all).all);\n-\n-      if Diff_Result /= 0 then\n-         Ada.Text_IO.Put_Line (\"diff(1) exit status\" & Diff_Result'Img);\n-      end if;\n-\n-      OS_Exit (Diff_Result);\n-\n-   end Process;\n-\n-exception\n-   when Stop =>\n-      null;\n-end SPARK_Xrefs_Test;"}, {"sha": "2b42d041c12f698c2aaf4e240f4d2640188e911d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -1,3 +1,9 @@\n+2017-11-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* gnat.dg/overriding_ops2.adb, gnat.dg/overriding_ops2.ads,\n+\tgnat.dg/overriding_ops2_pkg.ads, gnat.dg/overriding_ops2_pkg-high.ads:\n+\tNew testcase.\n+\n 2017-11-08  Andreas Schwab  <schwab@suse.de>\n \n \t* c-c++-common/torture/aarch64-vect-lane-2.c (search_line_fast):"}, {"sha": "9ab2f5c507e525f983d36954f5ac1682f24bccf6", "filename": "gcc/testsuite/gnat.dg/overriding_ops2.adb", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2.adb?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -0,0 +1,8 @@\n+--  { dg-do compile }\n+\n+package body Overriding_Ops2 is\n+   overriding procedure Finalize (Self : in out Consumer) is\n+   begin\n+      null;\n+   end Finalize;\n+end Overriding_Ops2;"}, {"sha": "695cffb1947a4d3f09d6fb168bc351ffdb9af3b8", "filename": "gcc/testsuite/gnat.dg/overriding_ops2.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2.ads?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -0,0 +1,12 @@\n+with Overriding_Ops2_Pkg.High;\n+\n+package Overriding_Ops2 is\n+   type Consumer is tagged limited private;\n+private\n+   type Consumer is\n+      limited\n+      new Overriding_Ops2_Pkg.High.High_Level_Session\n+   with null record;\n+\n+   overriding procedure Finalize (Self : in out Consumer);\n+end Overriding_Ops2;"}, {"sha": "46eb4629f4e7d6a41bdaeabed454b1d9edab7daa", "filename": "gcc/testsuite/gnat.dg/overriding_ops2_pkg-high.ads", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2_pkg-high.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2_pkg-high.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2_pkg-high.ads?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -0,0 +1,5 @@\n+package Overriding_Ops2_Pkg.High is\n+   type High_Level_Session is new Session_Type with private;\n+private\n+   type High_Level_Session is new Session_Type with null record;\n+end Overriding_Ops2_Pkg.High;"}, {"sha": "85c8f0b6afb6ec2c8e8dfb71fb8bcb65b28064de", "filename": "gcc/testsuite/gnat.dg/overriding_ops2_pkg.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc7f3aa68b852b217c511e7d841458b0bdd532a/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foverriding_ops2_pkg.ads?ref=7cc7f3aa68b852b217c511e7d841458b0bdd532a", "patch": "@@ -0,0 +1,9 @@\n+with Ada.Finalization;\n+\n+package Overriding_Ops2_Pkg is\n+   type Session_Type is abstract tagged limited private;\n+   procedure Finalize (Session : in out Session_Type);\n+private\n+   type Session_Type is\n+     abstract new Ada.Finalization.Limited_Controlled with null record;\n+end Overriding_Ops2_Pkg;"}]}