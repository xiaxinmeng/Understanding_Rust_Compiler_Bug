{"sha": "8d1628eb33d4f53832d6d4be2b0021353057a370", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQxNjI4ZWIzM2Q0ZjUzODMyZDZkNGJlMmIwMDIxMzUzMDU3YTM3MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-07-19T12:31:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-07-19T12:31:59Z"}, "message": "re PR tree-optimization/81346 (Missed constant propagation into comparison)\n\n\tPR tree-optimization/81346\n\t* fold-const.h (fold_div_compare, range_check_type): Declare.\n\t* fold-const.c (range_check_type): New function.\n\t(build_range_check): Use range_check_type.\n\t(fold_div_compare): No longer static, rewritten into\n\ta match.pd helper function.\n\t(fold_comparison): Don't call fold_div_compare here.\n\t* match.pd (X / C1 op C2): New optimization using fold_div_compare\n\tas helper function.\n\n\t* gcc.dg/tree-ssa/pr81346-1.c: New test.\n\t* gcc.dg/tree-ssa/pr81346-2.c: New test.\n\t* gcc.dg/tree-ssa/pr81346-3.c: New test.\n\t* gcc.dg/tree-ssa/pr81346-4.c: New test.\n\t* gcc.target/i386/umod-3.c: Hide comparison against 1 from the\n\tcompiler to avoid X / C1 op C2 optimization to trigger.\n\nFrom-SVN: r250338", "tree": {"sha": "d094faeffd74258f4d93793acf99507d3bb801ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d094faeffd74258f4d93793acf99507d3bb801ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d1628eb33d4f53832d6d4be2b0021353057a370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1628eb33d4f53832d6d4be2b0021353057a370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1628eb33d4f53832d6d4be2b0021353057a370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1628eb33d4f53832d6d4be2b0021353057a370/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20deef65ae6058143c29199c1aab12d94e75181c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20deef65ae6058143c29199c1aab12d94e75181c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20deef65ae6058143c29199c1aab12d94e75181c"}], "stats": {"total": 577, "additions": 430, "deletions": 147}, "files": [{"sha": "e6e7f9d01b1664f37a612f6a70bb69bba7b25875", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -1,3 +1,15 @@\n+2017-07-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/81346\n+\t* fold-const.h (fold_div_compare, range_check_type): Declare.\n+\t* fold-const.c (range_check_type): New function.\n+\t(build_range_check): Use range_check_type.\n+\t(fold_div_compare): No longer static, rewritten into\n+\ta match.pd helper function.\n+\t(fold_comparison): Don't call fold_div_compare here.\n+\t* match.pd (X / C1 op C2): New optimization using fold_div_compare\n+\tas helper function.\n+\n 2017-07-19  Nathan Sidwell  <nathan@acm.org>\n \n \t* tree.h (TYPE_MINVAL, TYPE_MAXVAL): Rename to ..."}, {"sha": "d702de2f97f07621e53eb853b1143d14a2d36714", "filename": "gcc/fold-const.c", "status": "modified", "additions": 84, "deletions": 144, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -132,7 +132,6 @@ static tree fold_binary_op_with_conditional_arg (location_t,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t tree, tree,\n \t\t\t\t\t\t tree, tree, int);\n-static tree fold_div_compare (location_t, enum tree_code, tree, tree, tree);\n static tree fold_negate_const (tree, tree);\n static tree fold_not_const (const_tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n@@ -4787,6 +4786,39 @@ maskable_range_p (const_tree low, const_tree high, tree type, tree *mask,\n   return true;\n }\n \f\n+/* Helper routine for build_range_check and match.pd.  Return the type to\n+   perform the check or NULL if it shouldn't be optimized.  */\n+\n+tree\n+range_check_type (tree etype)\n+{\n+  /* First make sure that arithmetics in this type is valid, then make sure\n+     that it wraps around.  */\n+  if (TREE_CODE (etype) == ENUMERAL_TYPE || TREE_CODE (etype) == BOOLEAN_TYPE)\n+    etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),\n+\t\t\t\t\t    TYPE_UNSIGNED (etype));\n+\n+  if (TREE_CODE (etype) == INTEGER_TYPE && !TYPE_OVERFLOW_WRAPS (etype))\n+    {\n+      tree utype, minv, maxv;\n+\n+      /* Check if (unsigned) INT_MAX + 1 == (unsigned) INT_MIN\n+\t for the type in question, as we rely on this here.  */\n+      utype = unsigned_type_for (etype);\n+      maxv = fold_convert (utype, TYPE_MAX_VALUE (etype));\n+      maxv = range_binop (PLUS_EXPR, NULL_TREE, maxv, 1,\n+\t\t\t  build_int_cst (TREE_TYPE (maxv), 1), 1);\n+      minv = fold_convert (utype, TYPE_MIN_VALUE (etype));\n+\n+      if (integer_zerop (range_binop (NE_EXPR, integer_type_node,\n+\t\t\t\t      minv, 1, maxv, 1)))\n+\tetype = utype;\n+      else\n+\treturn NULL_TREE;\n+    }\n+  return etype;\n+}\n+\n /* Given a range, LOW, HIGH, and IN_P, an expression, EXP, and a result\n    type, TYPE, return an expression to test if EXP is in (or out of, depending\n    on IN_P) the range.  Return 0 if the test couldn't be created.  */\n@@ -4869,31 +4901,10 @@ build_range_check (location_t loc, tree type, tree exp, int in_p,\n     }\n \n   /* Optimize (c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low).\n-     This requires wrap-around arithmetics for the type of the expression.\n-     First make sure that arithmetics in this type is valid, then make sure\n-     that it wraps around.  */\n-  if (TREE_CODE (etype) == ENUMERAL_TYPE || TREE_CODE (etype) == BOOLEAN_TYPE)\n-    etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),\n-\t\t\t\t\t    TYPE_UNSIGNED (etype));\n-\n-  if (TREE_CODE (etype) == INTEGER_TYPE && !TYPE_OVERFLOW_WRAPS (etype))\n-    {\n-      tree utype, minv, maxv;\n-\n-      /* Check if (unsigned) INT_MAX + 1 == (unsigned) INT_MIN\n-\t for the type in question, as we rely on this here.  */\n-      utype = unsigned_type_for (etype);\n-      maxv = fold_convert_loc (loc, utype, TYPE_MAX_VALUE (etype));\n-      maxv = range_binop (PLUS_EXPR, NULL_TREE, maxv, 1,\n-\t\t\t  build_int_cst (TREE_TYPE (maxv), 1), 1);\n-      minv = fold_convert_loc (loc, utype, TYPE_MIN_VALUE (etype));\n-\n-      if (integer_zerop (range_binop (NE_EXPR, integer_type_node,\n-\t\t\t\t      minv, 1, maxv, 1)))\n-\tetype = utype;\n-      else\n-\treturn 0;\n-    }\n+     This requires wrap-around arithmetics for the type of the expression.  */\n+  etype = range_check_type (etype);\n+  if (etype == NULL_TREE)\n+    return NULL_TREE;\n \n   high = fold_convert_loc (loc, etype, high);\n   low = fold_convert_loc (loc, etype, low);\n@@ -6548,65 +6559,55 @@ fold_real_zero_addition_p (const_tree type, const_tree addend, int negate)\n   return negate && !HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type));\n }\n \n-/* Subroutine of fold() that optimizes comparisons of a division by\n+/* Subroutine of match.pd that optimizes comparisons of a division by\n    a nonzero integer constant against an integer constant, i.e.\n    X/C1 op C2.\n \n    CODE is the comparison operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR,\n-   GE_EXPR or LE_EXPR.  TYPE is the type of the result and ARG0 and ARG1\n-   are the operands of the comparison.  ARG1 must be a TREE_REAL_CST.\n-\n-   The function returns the constant folded tree if a simplification\n-   can be made, and NULL_TREE otherwise.  */\n+   GE_EXPR or LE_EXPR.  ARG01 and ARG1 must be a INTEGER_CST.  */\n \n-static tree\n-fold_div_compare (location_t loc,\n-\t\t  enum tree_code code, tree type, tree arg0, tree arg1)\n+enum tree_code\n+fold_div_compare (enum tree_code code, tree c1, tree c2, tree *lo,\n+\t\t  tree *hi, bool *neg_overflow)\n {\n-  tree prod, tmp, hi, lo;\n-  tree arg00 = TREE_OPERAND (arg0, 0);\n-  tree arg01 = TREE_OPERAND (arg0, 1);\n-  signop sign = TYPE_SIGN (TREE_TYPE (arg0));\n-  bool neg_overflow = false;\n+  tree prod, tmp, type = TREE_TYPE (c1);\n+  signop sign = TYPE_SIGN (type);\n   bool overflow;\n \n   /* We have to do this the hard way to detect unsigned overflow.\n-     prod = int_const_binop (MULT_EXPR, arg01, arg1);  */\n-  wide_int val = wi::mul (arg01, arg1, sign, &overflow);\n-  prod = force_fit_type (TREE_TYPE (arg00), val, -1, overflow);\n-  neg_overflow = false;\n+     prod = int_const_binop (MULT_EXPR, c1, c2);  */\n+  wide_int val = wi::mul (c1, c2, sign, &overflow);\n+  prod = force_fit_type (type, val, -1, overflow);\n+  *neg_overflow = false;\n \n   if (sign == UNSIGNED)\n     {\n-      tmp = int_const_binop (MINUS_EXPR, arg01,\n-                             build_int_cst (TREE_TYPE (arg01), 1));\n-      lo = prod;\n+      tmp = int_const_binop (MINUS_EXPR, c1, build_int_cst (type, 1));\n+      *lo = prod;\n \n-      /* Likewise hi = int_const_binop (PLUS_EXPR, prod, tmp).  */\n+      /* Likewise *hi = int_const_binop (PLUS_EXPR, prod, tmp).  */\n       val = wi::add (prod, tmp, sign, &overflow);\n-      hi = force_fit_type (TREE_TYPE (arg00), val,\n-\t\t\t   -1, overflow | TREE_OVERFLOW (prod));\n+      *hi = force_fit_type (type, val, -1, overflow | TREE_OVERFLOW (prod));\n     }\n-  else if (tree_int_cst_sgn (arg01) >= 0)\n+  else if (tree_int_cst_sgn (c1) >= 0)\n     {\n-      tmp = int_const_binop (MINUS_EXPR, arg01,\n-\t\t\t     build_int_cst (TREE_TYPE (arg01), 1));\n-      switch (tree_int_cst_sgn (arg1))\n+      tmp = int_const_binop (MINUS_EXPR, c1, build_int_cst (type, 1));\n+      switch (tree_int_cst_sgn (c2))\n \t{\n \tcase -1:\n-\t  neg_overflow = true;\n-\t  lo = int_const_binop (MINUS_EXPR, prod, tmp);\n-\t  hi = prod;\n+\t  *neg_overflow = true;\n+\t  *lo = int_const_binop (MINUS_EXPR, prod, tmp);\n+\t  *hi = prod;\n \t  break;\n \n-\tcase  0:\n-\t  lo = fold_negate_const (tmp, TREE_TYPE (arg0));\n-\t  hi = tmp;\n+\tcase 0:\n+\t  *lo = fold_negate_const (tmp, type);\n+\t  *hi = tmp;\n \t  break;\n \n-\tcase  1:\n-          hi = int_const_binop (PLUS_EXPR, prod, tmp);\n-\t  lo = prod;\n+\tcase 1:\n+\t  *hi = int_const_binop (PLUS_EXPR, prod, tmp);\n+\t  *lo = prod;\n \t  break;\n \n \tdefault:\n@@ -6618,88 +6619,41 @@ fold_div_compare (location_t loc,\n       /* A negative divisor reverses the relational operators.  */\n       code = swap_tree_comparison (code);\n \n-      tmp = int_const_binop (PLUS_EXPR, arg01,\n-\t\t\t     build_int_cst (TREE_TYPE (arg01), 1));\n-      switch (tree_int_cst_sgn (arg1))\n+      tmp = int_const_binop (PLUS_EXPR, c1, build_int_cst (type, 1));\n+      switch (tree_int_cst_sgn (c2))\n \t{\n \tcase -1:\n-\t  hi = int_const_binop (MINUS_EXPR, prod, tmp);\n-\t  lo = prod;\n+\t  *hi = int_const_binop (MINUS_EXPR, prod, tmp);\n+\t  *lo = prod;\n \t  break;\n \n-\tcase  0:\n-\t  hi = fold_negate_const (tmp, TREE_TYPE (arg0));\n-\t  lo = tmp;\n+\tcase 0:\n+\t  *hi = fold_negate_const (tmp, type);\n+\t  *lo = tmp;\n \t  break;\n \n-\tcase  1:\n-\t  neg_overflow = true;\n-\t  lo = int_const_binop (PLUS_EXPR, prod, tmp);\n-\t  hi = prod;\n+\tcase 1:\n+\t  *neg_overflow = true;\n+\t  *lo = int_const_binop (PLUS_EXPR, prod, tmp);\n+\t  *hi = prod;\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n     }\n \n-  switch (code)\n-    {\n-    case EQ_EXPR:\n-      if (TREE_OVERFLOW (lo) && TREE_OVERFLOW (hi))\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg00);\n-      if (TREE_OVERFLOW (hi))\n-\treturn fold_build2_loc (loc, GE_EXPR, type, arg00, lo);\n-      if (TREE_OVERFLOW (lo))\n-\treturn fold_build2_loc (loc, LE_EXPR, type, arg00, hi);\n-      return build_range_check (loc, type, arg00, 1, lo, hi);\n+  if (code != EQ_EXPR && code != NE_EXPR)\n+    return code;\n \n-    case NE_EXPR:\n-      if (TREE_OVERFLOW (lo) && TREE_OVERFLOW (hi))\n-\treturn omit_one_operand_loc (loc, type, integer_one_node, arg00);\n-      if (TREE_OVERFLOW (hi))\n-\treturn fold_build2_loc (loc, LT_EXPR, type, arg00, lo);\n-      if (TREE_OVERFLOW (lo))\n-\treturn fold_build2_loc (loc, GT_EXPR, type, arg00, hi);\n-      return build_range_check (loc, type, arg00, 0, lo, hi);\n+  if (TREE_OVERFLOW (*lo)\n+      || operand_equal_p (*lo, TYPE_MIN_VALUE (type), 0))\n+    *lo = NULL_TREE;\n+  if (TREE_OVERFLOW (*hi)\n+      || operand_equal_p (*hi, TYPE_MAX_VALUE (type), 0))\n+    *hi = NULL_TREE;\n \n-    case LT_EXPR:\n-      if (TREE_OVERFLOW (lo))\n-\t{\n-\t  tmp = neg_overflow ? integer_zero_node : integer_one_node;\n-\t  return omit_one_operand_loc (loc, type, tmp, arg00);\n-\t}\n-      return fold_build2_loc (loc, LT_EXPR, type, arg00, lo);\n-\n-    case LE_EXPR:\n-      if (TREE_OVERFLOW (hi))\n-\t{\n-\t  tmp = neg_overflow ? integer_zero_node : integer_one_node;\n-\t  return omit_one_operand_loc (loc, type, tmp, arg00);\n-\t}\n-      return fold_build2_loc (loc, LE_EXPR, type, arg00, hi);\n-\n-    case GT_EXPR:\n-      if (TREE_OVERFLOW (hi))\n-\t{\n-\t  tmp = neg_overflow ? integer_one_node : integer_zero_node;\n-\t  return omit_one_operand_loc (loc, type, tmp, arg00);\n-\t}\n-      return fold_build2_loc (loc, GT_EXPR, type, arg00, hi);\n-\n-    case GE_EXPR:\n-      if (TREE_OVERFLOW (lo))\n-\t{\n-\t  tmp = neg_overflow ? integer_one_node : integer_zero_node;\n-\t  return omit_one_operand_loc (loc, type, tmp, arg00);\n-\t}\n-      return fold_build2_loc (loc, GE_EXPR, type, arg00, lo);\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n+  return code;\n }\n \n \n@@ -8793,20 +8747,6 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t}\n     }\n \n-  /* We can fold X/C1 op C2 where C1 and C2 are integer constants\n-     into a single range test.  */\n-  if (TREE_CODE (arg0) == TRUNC_DIV_EXPR\n-      && TREE_CODE (arg1) == INTEGER_CST\n-      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-      && !integer_zerop (TREE_OPERAND (arg0, 1))\n-      && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n-      && !TREE_OVERFLOW (arg1))\n-    {\n-      tem = fold_div_compare (loc, code, type, arg0, arg1);\n-      if (tem != NULL_TREE)\n-\treturn tem;\n-    }\n-\n   return NULL_TREE;\n }\n "}, {"sha": "780e5c781b78deea4431ccea2fbe692f99ba9b6e", "filename": "gcc/fold-const.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -88,6 +88,8 @@ extern void fold_undefer_overflow_warnings (bool, const gimple *, int);\n extern void fold_undefer_and_ignore_overflow_warnings (void);\n extern bool fold_deferring_overflow_warnings_p (void);\n extern void fold_overflow_warning (const char*, enum warn_strict_overflow_code);\n+extern enum tree_code fold_div_compare (enum tree_code, tree, tree,\n+\t\t\t\t\ttree *, tree *, bool *);\n extern int operand_equal_p (const_tree, const_tree, unsigned int);\n extern int multiple_of_p (tree, const_tree, const_tree);\n #define omit_one_operand(T1,T2,T3)\\\n@@ -175,6 +177,7 @@ extern bool tree_expr_nonnegative_warnv_p (tree, bool *, int = 0);\n extern tree make_range (tree, int *, tree *, tree *, bool *);\n extern tree make_range_step (location_t, enum tree_code, tree, tree, tree,\n \t\t\t     tree *, tree *, int *, bool *);\n+extern tree range_check_type (tree);\n extern tree build_range_check (location_t, tree, tree, int, tree, tree);\n extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,\n \t\t\t  tree, tree);"}, {"sha": "fe270934c03fe3519fbffefc79577569ec810d2c", "filename": "gcc/match.pd", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -1132,6 +1132,60 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (if (wi::gt_p(@2, 0, TYPE_SIGN (TREE_TYPE (@2))))\n    (cmp @0 @1))))\n \n+/* X / C1 op C2 into a simple range test.  */\n+(for cmp (simple_comparison)\n+ (simplify\n+  (cmp (trunc_div:s @0 INTEGER_CST@1) INTEGER_CST@2)\n+  (if (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && integer_nonzerop (@1)\n+       && !TREE_OVERFLOW (@1)\n+       && !TREE_OVERFLOW (@2))\n+   (with { tree lo, hi; bool neg_overflow;\n+\t   enum tree_code code = fold_div_compare (cmp, @1, @2, &lo, &hi,\n+\t\t\t\t\t\t   &neg_overflow); }\n+    (switch\n+     (if (code == LT_EXPR || code == GE_EXPR)\n+       (if (TREE_OVERFLOW (lo))\n+\t{ build_int_cst (type, (code == LT_EXPR) ^ neg_overflow); }\n+\t(if (code == LT_EXPR)\n+\t (lt @0 { lo; })\n+\t (ge @0 { lo; }))))\n+     (if (code == LE_EXPR || code == GT_EXPR)\n+       (if (TREE_OVERFLOW (hi))\n+\t{ build_int_cst (type, (code == LE_EXPR) ^ neg_overflow); }\n+\t(if (code == LE_EXPR)\n+\t (le @0 { hi; })\n+\t (gt @0 { hi; }))))\n+     (if (!lo && !hi)\n+      { build_int_cst (type, code == NE_EXPR); })\n+     (if (code == EQ_EXPR && !hi)\n+      (ge @0 { lo; }))\n+     (if (code == EQ_EXPR && !lo)\n+      (le @0 { hi; }))\n+     (if (code == NE_EXPR && !hi)\n+      (lt @0 { lo; }))\n+     (if (code == NE_EXPR && !lo)\n+      (gt @0 { hi; }))\n+     (if (GENERIC)\n+      { build_range_check (UNKNOWN_LOCATION, type, @0, code == EQ_EXPR,\n+\t\t\t   lo, hi); })\n+     (with\n+      {\n+\ttree etype = range_check_type (TREE_TYPE (@0));\n+\tif (etype)\n+\t  {\n+\t    if (! TYPE_UNSIGNED (etype))\n+\t      etype = unsigned_type_for (etype);\n+\t    hi = fold_convert (etype, hi);\n+\t    lo = fold_convert (etype, lo);\n+\t    hi = const_binop (MINUS_EXPR, etype, hi, lo);\n+\t  }\n+      }\n+      (if (etype && hi && !TREE_OVERFLOW (hi))\n+       (if (code == EQ_EXPR)\n+\t(le (minus (convert:etype @0) { lo; }) { hi; })\n+\t(gt (minus (convert:etype @0) { lo; }) { hi; })))))))))\n+\n /* X + Z < Y + Z is the same as X < Y when there is no overflow.  */\n (for op (lt le ge gt)\n  (simplify"}, {"sha": "cad1ade6ea8b360c20765ba3fd0b266ef1f4a079", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -1,3 +1,13 @@\n+2017-07-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/81346\n+\t* gcc.dg/tree-ssa/pr81346-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr81346-2.c: New test.\n+\t* gcc.dg/tree-ssa/pr81346-3.c: New test.\n+\t* gcc.dg/tree-ssa/pr81346-4.c: New test.\n+\t* gcc.target/i386/umod-3.c: Hide comparison against 1 from the\n+\tcompiler to avoid X / C1 op C2 optimization to trigger.\n+\n 2017-07-19  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/63361"}, {"sha": "c766d6ff996a57d0c203ceaccd80affd730e05f6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81346-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-1.c?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -0,0 +1,37 @@\n+/* PR tree-optimization/81346 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \"return 1;\" 32 \"optimized\" } } */\n+\n+int f00 (int x) { return x / 49152 > -49152; }\n+int f01 (int x) { int a = 49152, b = -49152; return x / a > b; }\n+int f02 (int x) { return x / 49152 >= -49152; }\n+int f03 (int x) { int a = 49152, b = -49152; return x / a >= b; }\n+int f04 (int x) { return x / 49152 < 49152; }\n+int f05 (int x) { int a = 49152, b = 49152; return x / a < b; }\n+int f06 (int x) { return x / 49152 <= 49152; }\n+int f07 (int x) { int a = 49152, b = 49152; return x / a <= b; }\n+int f08 (int x) { return x / 46340 >= -46341; }\n+int f09 (int x) { int a = 46340, b = -46341; return x / a >= b; }\n+int f10 (int x) { return x / 46340 <= 46341; }\n+int f11 (int x) { int a = 46340, b = 46341; return x / a <= b; }\n+int f12 (int x) { return x / 49152 != -49152; }\n+int f13 (int x) { int a = 49152, b = -49152; return x / a != b; }\n+int f14 (int x) { return x / 49152 != 49152; }\n+int f15 (int x) { int a = 49152, b = 49152; return x / a != b; }\n+int f16 (int x) { return x / -49152 > -49152; }\n+int f17 (int x) { int a = -49152, b = -49152; return x / a > b; }\n+int f18 (int x) { return x / -49152 >= -49152; }\n+int f19 (int x) { int a = -49152, b = -49152; return x / a >= b; }\n+int f20 (int x) { return x / -49152 < 49152; }\n+int f21 (int x) { int a = -49152, b = 49152; return x / a < b; }\n+int f22 (int x) { return x / -49152 <= 49152; }\n+int f23 (int x) { int a = -49152, b = 49152; return x / a <= b; }\n+int f24 (int x) { return x / -46340 >= -46341; }\n+int f25 (int x) { int a = -46340, b = -46341; return x / a >= b; }\n+int f26 (int x) { return x / -46340 <= 46341; }\n+int f27 (int x) { int a = -46340, b = 46341; return x / a <= b; }\n+int f28 (int x) { return x / -49152 != 49152; }\n+int f29 (int x) { int a = -49152, b = 49152; return x / a != b; }\n+int f30 (int x) { return x / -49152 != -49152; }\n+int f31 (int x) { int a = -49152, b = -49152; return x / a != b; }"}, {"sha": "87bad395c3b776818f2e0790c4eab7b7a1323129", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81346-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-2.c?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -0,0 +1,37 @@\n+/* PR tree-optimization/81346 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \"return 0;\" 32 \"optimized\" } } */\n+\n+int f00 (int x) { return x / 49152 > 49152; }\n+int f01 (int x) { int a = 49152, b = 49152; return x / a > b; }\n+int f02 (int x) { return x / 49152 >= 49152; }\n+int f03 (int x) { int a = 49152, b = 49152; return x / a >= b; }\n+int f04 (int x) { return x / 49152 < -49152; }\n+int f05 (int x) { int a = 49152, b = -49152; return x / a < b; }\n+int f06 (int x) { return x / 49152 <= -49152; }\n+int f07 (int x) { int a = 49152, b = -49152; return x / a <= b; }\n+int f08 (int x) { return x / 46340 > 46341; }\n+int f09 (int x) { int a = 46340, b = 46341; return x / a > b; }\n+int f10 (int x) { return x / 46340 < -46341; }\n+int f11 (int x) { int a = 46340, b = -46341; return x / a < b; }\n+int f12 (int x) { return x / 49152 == -49152; }\n+int f13 (int x) { int a = 49152, b = -49152; return x / a == b; }\n+int f14 (int x) { return x / 49152 == 49152; }\n+int f15 (int x) { int a = 49152, b = 49152; return x / a == b; }\n+int f16 (int x) { return x / -49152 > 49152; }\n+int f17 (int x) { int a = -49152, b = 49152; return x / a > b; }\n+int f18 (int x) { return x / -49152 >= 49152; }\n+int f19 (int x) { int a = -49152, b = 49152; return x / a >= b; }\n+int f20 (int x) { return x / -49152 < -49152; }\n+int f21 (int x) { int a = -49152, b = -49152; return x / a < b; }\n+int f22 (int x) { return x / -49152 <= -49152; }\n+int f23 (int x) { int a = -49152, b = -49152; return x / a <= b; }\n+int f24 (int x) { return x / -46340 > 46341; }\n+int f25 (int x) { int a = -46340, b = 46341; return x / a > b; }\n+int f26 (int x) { return x / -46340 < -46341; }\n+int f27 (int x) { int a = -46340, b = -46341; return x / a < b; }\n+int f28 (int x) { return x / -49152 == 49152; }\n+int f29 (int x) { int a = -49152, b = 49152; return x / a == b; }\n+int f30 (int x) { return x / -49152 == -49152; }\n+int f31 (int x) { int a = -49152, b = -49152; return x / a == b; }"}, {"sha": "bef64a8746a367c263a6f90f3db0a2e02ec2b1ab", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81346-3.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-3.c?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -0,0 +1,109 @@\n+/* PR tree-optimization/81346 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" / \" \"optimized\" } } */\n+\n+__attribute__((noinline, noclone)) int f00 (int x) { return x / 46340 > -46341; }\n+__attribute__((noinline, noclone)) int f01 (int x) { int a = 46340, b = -46341; return x / a > b; }\n+__attribute__((noinline, noclone)) int f02 (int x) { return x / 46340 >= 46341; }\n+__attribute__((noinline, noclone)) int f03 (int x) { int a = 46340, b = 46341; return x / a >= b; }\n+__attribute__((noinline, noclone)) int f04 (int x) { return x / 46340 < 46341; }\n+__attribute__((noinline, noclone)) int f05 (int x) { int a = 46340, b = 46341; return x / a < b; }\n+__attribute__((noinline, noclone)) int f06 (int x) { return x / 46340 <= -46341; }\n+__attribute__((noinline, noclone)) int f07 (int x) { int a = 46340, b = -46341; return x / a <= b; }\n+__attribute__((noinline, noclone)) int f08 (int x) { return x / 46340 == -46341; }\n+__attribute__((noinline, noclone)) int f09 (int x) { int a = 46340, b = -46341; return x / a == b; }\n+__attribute__((noinline, noclone)) int f10 (int x) { return x / 46340 == 46341; }\n+__attribute__((noinline, noclone)) int f11 (int x) { int a = 46340, b = 46341; return x / a == b; }\n+__attribute__((noinline, noclone)) int f12 (int x) { return x / 46340 != -46341; }\n+__attribute__((noinline, noclone)) int f13 (int x) { int a = 46340, b = -46341; return x / a != b; }\n+__attribute__((noinline, noclone)) int f14 (int x) { return x / 46340 != 46341; }\n+__attribute__((noinline, noclone)) int f15 (int x) { int a = 46340, b = 46341; return x / a != b; }\n+__attribute__((noinline, noclone)) int f16 (int x) { return x / 15 > -15; }\n+__attribute__((noinline, noclone)) int f17 (int x) { int a = 15, b = -15; return x / a > b; }\n+__attribute__((noinline, noclone)) int f18 (int x) { return x / 15 > 15; }\n+__attribute__((noinline, noclone)) int f19 (int x) { int a = 15, b = 15; return x / a > b; }\n+__attribute__((noinline, noclone)) int f20 (int x) { return x / 15 >= -15; }\n+__attribute__((noinline, noclone)) int f21 (int x) { int a = 15, b = -15; return x / a >= b; }\n+__attribute__((noinline, noclone)) int f22 (int x) { return x / 15 >= 15; }\n+__attribute__((noinline, noclone)) int f23 (int x) { int a = 15, b = 15; return x / a >= b; }\n+__attribute__((noinline, noclone)) int f24 (int x) { return x / 15 < -15; }\n+__attribute__((noinline, noclone)) int f25 (int x) { int a = 15, b = -15; return x / a < b; }\n+__attribute__((noinline, noclone)) int f26 (int x) { return x / 15 < 15; }\n+__attribute__((noinline, noclone)) int f27 (int x) { int a = 15, b = 15; return x / a < b; }\n+__attribute__((noinline, noclone)) int f28 (int x) { return x / 15 <= -15; }\n+__attribute__((noinline, noclone)) int f29 (int x) { int a = 15, b = -15; return x / a <= b; }\n+__attribute__((noinline, noclone)) int f30 (int x) { return x / 15 <= 15; }\n+__attribute__((noinline, noclone)) int f31 (int x) { int a = 15, b = 15; return x / a <= b; }\n+__attribute__((noinline, noclone)) int f32 (int x) { return x / 15 == -15; }\n+__attribute__((noinline, noclone)) int f33 (int x) { int a = 15, b = -15; return x / a == b; }\n+__attribute__((noinline, noclone)) int f34 (int x) { return x / 15 == 15; }\n+__attribute__((noinline, noclone)) int f35 (int x) { int a = 15, b = 15; return x / a == b; }\n+__attribute__((noinline, noclone)) int f36 (int x) { return x / 15 != -15; }\n+__attribute__((noinline, noclone)) int f37 (int x) { int a = 15, b = -15; return x / a != b; }\n+__attribute__((noinline, noclone)) int f38 (int x) { return x / 15 != 15; }\n+__attribute__((noinline, noclone)) int f39 (int x) { int a = 15, b = 15; return x / a != b; }\n+__attribute__((noinline, noclone)) int f40 (int x) { return x / -46340 > -46341; }\n+__attribute__((noinline, noclone)) int f41 (int x) { int a = -46340, b = -46341; return x / a > b; }\n+__attribute__((noinline, noclone)) int f42 (int x) { return x / -46340 >= 46341; }\n+__attribute__((noinline, noclone)) int f43 (int x) { int a = -46340, b = 46341; return x / a >= b; }\n+__attribute__((noinline, noclone)) int f44 (int x) { return x / -46340 < 46341; }\n+__attribute__((noinline, noclone)) int f45 (int x) { int a = -46340, b = 46341; return x / a < b; }\n+__attribute__((noinline, noclone)) int f46 (int x) { return x / -46340 <= -46341; }\n+__attribute__((noinline, noclone)) int f47 (int x) { int a = -46340, b = -46341; return x / a <= b; }\n+__attribute__((noinline, noclone)) int f48 (int x) { return x / -46340 == 46341; }\n+__attribute__((noinline, noclone)) int f49 (int x) { int a = -46340, b = 46341; return x / a == b; }\n+__attribute__((noinline, noclone)) int f50 (int x) { return x / -46340 == -46341; }\n+__attribute__((noinline, noclone)) int f51 (int x) { int a = -46340, b = -46341; return x / a == b; }\n+__attribute__((noinline, noclone)) int f52 (int x) { return x / -46340 != 46341; }\n+__attribute__((noinline, noclone)) int f53 (int x) { int a = -46340, b = 46341; return x / a != b; }\n+__attribute__((noinline, noclone)) int f54 (int x) { return x / -46340 != -46341; }\n+__attribute__((noinline, noclone)) int f55 (int x) { int a = -46340, b = -46341; return x / a != b; }\n+__attribute__((noinline, noclone)) int f56 (int x) { return x / -15 > 15; }\n+__attribute__((noinline, noclone)) int f57 (int x) { int a = -15, b = 15; return x / a > b; }\n+__attribute__((noinline, noclone)) int f58 (int x) { return x / -15 > -15; }\n+__attribute__((noinline, noclone)) int f59 (int x) { int a = -15, b = -15; return x / a > b; }\n+__attribute__((noinline, noclone)) int f60 (int x) { return x / -15 >= 15; }\n+__attribute__((noinline, noclone)) int f61 (int x) { int a = -15, b = 15; return x / a >= b; }\n+__attribute__((noinline, noclone)) int f62 (int x) { return x / -15 >= -15; }\n+__attribute__((noinline, noclone)) int f63 (int x) { int a = -15, b = -15; return x / a >= b; }\n+__attribute__((noinline, noclone)) int f64 (int x) { return x / -15 < 15; }\n+__attribute__((noinline, noclone)) int f65 (int x) { int a = -15, b = 15; return x / a < b; }\n+__attribute__((noinline, noclone)) int f66 (int x) { return x / -15 < -15; }\n+__attribute__((noinline, noclone)) int f67 (int x) { int a = -15, b = -15; return x / a < b; }\n+__attribute__((noinline, noclone)) int f68 (int x) { return x / -15 <= 15; }\n+__attribute__((noinline, noclone)) int f69 (int x) { int a = -15, b = 15; return x / a <= b; }\n+__attribute__((noinline, noclone)) int f70 (int x) { return x / -15 <= -15; }\n+__attribute__((noinline, noclone)) int f71 (int x) { int a = -15, b = -15; return x / a <= b; }\n+__attribute__((noinline, noclone)) int f72 (int x) { return x / -15 == 15; }\n+__attribute__((noinline, noclone)) int f73 (int x) { int a = -15, b = 15; return x / a == b; }\n+__attribute__((noinline, noclone)) int f74 (int x) { return x / -15 == -15; }\n+__attribute__((noinline, noclone)) int f75 (int x) { int a = -15, b = -15; return x / a == b; }\n+__attribute__((noinline, noclone)) int f76 (int x) { return x / -15 != 15; }\n+__attribute__((noinline, noclone)) int f77 (int x) { int a = -15, b = 15; return x / a != b; }\n+__attribute__((noinline, noclone)) int f78 (int x) { return x / -15 != -15; }\n+__attribute__((noinline, noclone)) int f79 (int x) { int a = -15, b = -15; return x / a != b; }\n+__attribute__((noinline, noclone)) int f80 (int x) { return x / -15 > 0; }\n+__attribute__((noinline, noclone)) int f81 (int x) { int a = -15, b = 0; return x / a > b; }\n+__attribute__((noinline, noclone)) int f82 (int x) { return x / 15 > 0; }\n+__attribute__((noinline, noclone)) int f83 (int x) { int a = 15, b = 0; return x / a > b; }\n+__attribute__((noinline, noclone)) int f84 (int x) { return x / -15 >= 0; }\n+__attribute__((noinline, noclone)) int f85 (int x) { int a = -15, b = 0; return x / a >= b; }\n+__attribute__((noinline, noclone)) int f86 (int x) { return x / 15 >= 0; }\n+__attribute__((noinline, noclone)) int f87 (int x) { int a = 15, b = 0; return x / a >= b; }\n+__attribute__((noinline, noclone)) int f88 (int x) { return x / -15 < 0; }\n+__attribute__((noinline, noclone)) int f89 (int x) { int a = -15, b = 0; return x / a < b; }\n+__attribute__((noinline, noclone)) int f90 (int x) { return x / 15 < 0; }\n+__attribute__((noinline, noclone)) int f91 (int x) { int a = 15, b = 0; return x / a < b; }\n+__attribute__((noinline, noclone)) int f92 (int x) { return x / -15 <= 0; }\n+__attribute__((noinline, noclone)) int f93 (int x) { int a = -15, b = 0; return x / a <= b; }\n+__attribute__((noinline, noclone)) int f94 (int x) { return x / 15 <= 0; }\n+__attribute__((noinline, noclone)) int f95 (int x) { int a = 15, b = 0; return x / a <= b; }\n+__attribute__((noinline, noclone)) int f96 (int x) { return x / -15 == 0; }\n+__attribute__((noinline, noclone)) int f97 (int x) { int a = -15, b = 0; return x / a == b; }\n+__attribute__((noinline, noclone)) int f98 (int x) { return x / 15 == 0; }\n+__attribute__((noinline, noclone)) int f99 (int x) { int a = 15, b = 0; return x / a == b; }\n+__attribute__((noinline, noclone)) int f100 (int x) { return x / -15 != 0; }\n+__attribute__((noinline, noclone)) int f101 (int x) { int a = -15, b = 0; return x / a != b; }\n+__attribute__((noinline, noclone)) int f102 (int x) { return x / 15 != 0; }\n+__attribute__((noinline, noclone)) int f103 (int x) { int a = 15, b = 0; return x / a != b; }"}, {"sha": "f93ad468c3f1774cda5d1fd684f766ccb52ad17d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81346-4.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81346-4.c?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -0,0 +1,79 @@\n+/* PR tree-optimization/81346 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"pr81346-3.c\"\n+\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+  if (__CHAR_BIT__ != 8 || __SIZEOF_INT__ != 4)\n+    return 0;\n+#define TEST(fn1, fn2, v1, v2) \\\n+  do { \\\n+    int w1 = v1; int w2 = v2; \\\n+    int in = 1; if (w1 > w2) { in = w1; w1 = w2; w2 = in; in = 0; } \\\n+    if (w1 != INT_MIN) { if (fn1 (w1 - 1) != !in || fn2 (w1 - 1) != !in) abort (); } \\\n+    if (fn1 (w1) != in || fn2 (w1) != in) abort (); \\\n+    if (fn1 (w2) != in || fn2 (w2) != in) abort (); \\\n+    if (w2 != INT_MAX) { if (fn1 (w2 + 1) != !in || fn2 (w2 + 1) != !in) abort (); } \\\n+  } while (0)\n+TEST (f00, f01, -2147441939, INT_MAX);\n+TEST (f02, f03, 2147441940, INT_MAX);\n+TEST (f04, f05, INT_MIN, 2147441939);\n+TEST (f06, f07, INT_MIN, -2147441940);\n+TEST (f08, f09, INT_MIN, -2147441940);\n+TEST (f10, f11, 2147441940, INT_MAX);\n+TEST (f12, f13, -2147441939, INT_MAX);\n+TEST (f14, f15, INT_MIN, 2147441939);\n+TEST (f16, f17, -224, INT_MAX);\n+TEST (f18, f19, 240, INT_MAX);\n+TEST (f20, f21, -239, INT_MAX);\n+TEST (f22, f23, 225, INT_MAX);\n+TEST (f24, f25, INT_MIN, -240);\n+TEST (f26, f27, INT_MIN, 224);\n+TEST (f28, f29, INT_MIN, -225);\n+TEST (f30, f31, INT_MIN, 239);\n+TEST (f32, f33, -239, -225);\n+TEST (f34, f35, 225, 239);\n+TEST (f36, f37, -225, -239);\n+TEST (f38, f39, 239, 225);\n+TEST (f40, f41, INT_MIN, 2147441939);\n+TEST (f42, f43, INT_MIN, -2147441940);\n+TEST (f44, f45, -2147441939, INT_MAX);\n+TEST (f46, f47, 2147441940, INT_MAX);\n+TEST (f48, f49, INT_MIN, -2147441940);\n+TEST (f50, f51, 2147441940, INT_MAX);\n+TEST (f52, f53, -2147441939, INT_MAX);\n+TEST (f54, f55, INT_MIN, 2147441939);\n+TEST (f56, f57, INT_MIN, -240);\n+TEST (f58, f59, INT_MIN, 224);\n+TEST (f60, f61, INT_MIN, -225);\n+TEST (f62, f63, INT_MIN, 239);\n+TEST (f64, f65, -224, INT_MAX);\n+TEST (f66, f67, 240, INT_MAX);\n+TEST (f68, f69, -239, INT_MAX);\n+TEST (f70, f71, 225, INT_MAX);\n+TEST (f72, f73, -239, -225);\n+TEST (f74, f75, 225, 239);\n+TEST (f76, f77, -225, -239);\n+TEST (f78, f79, 239, 225);\n+TEST (f80, f81, INT_MIN, -15);\n+TEST (f82, f83, 15, INT_MAX);\n+TEST (f84, f85, INT_MIN, 14);\n+TEST (f86, f87, -14, INT_MAX);\n+TEST (f88, f89, 15, INT_MAX);\n+TEST (f90, f91, INT_MIN, -15);\n+TEST (f92, f93, -14, INT_MAX);\n+TEST (f94, f95, INT_MIN, 14);\n+TEST (f96, f97, -14, 14);\n+TEST (f98, f99, -14, 14);\n+TEST (f100, f101, 14, -14);\n+TEST (f102, f103, 14, -14);\n+  return 0;\n+}"}, {"sha": "609ab5207128830b936596c579f98afe7c6a7de5", "filename": "gcc/testsuite/gcc.target/i386/umod-3.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fumod-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1628eb33d4f53832d6d4be2b0021353057a370/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fumod-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fumod-3.c?ref=8d1628eb33d4f53832d6d4be2b0021353057a370", "patch": "@@ -9,9 +9,11 @@ int\n main ()\n {\n   unsigned char cy;\n-  \n-  cy = cx / 6; if (cy != 1) exit (1);\n-  cy = cx % 6; if (cy != 1) exit (1);\n+  unsigned char cz = 1;\n+  asm (\"\" : \"+q\" (cz));\n+\n+  cy = cx / 6; if (cy != cz) exit (1);\n+  cy = cx % 6; if (cy != cz) exit (1);\n \n   exit(0);\n }"}]}