{"sha": "ac7c5af52f44884c7839377279f6f76b97f080ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM3YzVhZjUyZjQ0ODg0Yzc4MzkzNzcyNzlmNmY3NmI5N2YwODBhYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-10T20:18:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-10T20:18:59Z"}, "message": "s/        /<tab>/g\n\nFrom-SVN: r25675", "tree": {"sha": "cc9c4e3d005aedc1834f5e20be6959c393d494f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc9c4e3d005aedc1834f5e20be6959c393d494f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac7c5af52f44884c7839377279f6f76b97f080ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7c5af52f44884c7839377279f6f76b97f080ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7c5af52f44884c7839377279f6f76b97f080ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7c5af52f44884c7839377279f6f76b97f080ab/comments", "author": null, "committer": null, "parents": [{"sha": "f4e584dc0f98043ee3f9e72b337f16d1e3f25125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e584dc0f98043ee3f9e72b337f16d1e3f25125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4e584dc0f98043ee3f9e72b337f16d1e3f25125"}], "stats": {"total": 212, "additions": 106, "deletions": 106}, "files": [{"sha": "4c981a42555887ea5f9e215f81c206c180d41abf", "filename": "gcc/gcse.c", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7c5af52f44884c7839377279f6f76b97f080ab/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7c5af52f44884c7839377279f6f76b97f080ab/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ac7c5af52f44884c7839377279f6f76b97f080ab", "patch": "@@ -510,112 +510,112 @@ static sbitmap *rd_kill, *rd_gen, *reaching_defs, *rd_out;\n /* for available exprs */\n static sbitmap *ae_kill, *ae_gen, *ae_in, *ae_out;\n \f\n-static void compute_can_copy          PROTO ((void));\n-\n-static char *gmalloc                  PROTO ((unsigned int));\n-static char *grealloc                 PROTO ((char *, unsigned int));\n-static char *gcse_alloc               PROTO ((unsigned long));\n-static void alloc_gcse_mem            PROTO ((rtx));\n-static void free_gcse_mem             PROTO ((void));\n-extern void dump_cuid_table           PROTO ((FILE *));\n-\n-static void alloc_reg_set_mem         PROTO ((int));\n-static void free_reg_set_mem          PROTO ((void));\n-static void record_one_set            PROTO ((int, rtx));\n-static void record_set_info           PROTO ((rtx, rtx));\n-static void compute_sets              PROTO ((rtx));\n-\n-static void hash_scan_insn            PROTO ((rtx, int, int));\n-static void hash_scan_set             PROTO ((rtx, rtx, int));\n-static void hash_scan_clobber         PROTO ((rtx, rtx));\n-static void hash_scan_call            PROTO ((rtx, rtx));\n-static void maybe_set_rd_gen          PROTO ((int, rtx));\n-static int want_to_gcse_p             PROTO ((rtx));\n-static int oprs_unchanged_p           PROTO ((rtx, rtx, int));\n+static void compute_can_copy\t  PROTO ((void));\n+\n+static char *gmalloc\t\t  PROTO ((unsigned int));\n+static char *grealloc\t\t PROTO ((char *, unsigned int));\n+static char *gcse_alloc\t       PROTO ((unsigned long));\n+static void alloc_gcse_mem\t    PROTO ((rtx));\n+static void free_gcse_mem\t     PROTO ((void));\n+extern void dump_cuid_table\t   PROTO ((FILE *));\n+\n+static void alloc_reg_set_mem\t PROTO ((int));\n+static void free_reg_set_mem\t  PROTO ((void));\n+static void record_one_set\t    PROTO ((int, rtx));\n+static void record_set_info\t   PROTO ((rtx, rtx));\n+static void compute_sets\t      PROTO ((rtx));\n+\n+static void hash_scan_insn\t    PROTO ((rtx, int, int));\n+static void hash_scan_set\t     PROTO ((rtx, rtx, int));\n+static void hash_scan_clobber\t PROTO ((rtx, rtx));\n+static void hash_scan_call\t    PROTO ((rtx, rtx));\n+static void maybe_set_rd_gen\t  PROTO ((int, rtx));\n+static int want_to_gcse_p\t     PROTO ((rtx));\n+static int oprs_unchanged_p\t   PROTO ((rtx, rtx, int));\n static int oprs_anticipatable_p       PROTO ((rtx, rtx));\n-static int oprs_available_p           PROTO ((rtx, rtx));\n+static int oprs_available_p\t   PROTO ((rtx, rtx));\n static void insert_expr_in_table      PROTO ((rtx, enum machine_mode, rtx, int, int));\n static void insert_set_in_table       PROTO ((rtx, rtx));\n-static unsigned int hash_expr         PROTO ((rtx, enum machine_mode, int *, int));\n+static unsigned int hash_expr\t PROTO ((rtx, enum machine_mode, int *, int));\n static unsigned int hash_expr_1       PROTO ((rtx, enum machine_mode, int *));\n-static unsigned int hash_set          PROTO ((int, int));\n-static int expr_equiv_p               PROTO ((rtx, rtx));\n+static unsigned int hash_set\t  PROTO ((int, int));\n+static int expr_equiv_p\t       PROTO ((rtx, rtx));\n static void record_last_reg_set_info  PROTO ((rtx, int));\n static void record_last_mem_set_info  PROTO ((rtx));\n static void record_last_set_info      PROTO ((rtx, rtx));\n-static void compute_hash_table        PROTO ((rtx, int));\n+static void compute_hash_table\tPROTO ((rtx, int));\n static void alloc_set_hash_table      PROTO ((int));\n static void free_set_hash_table       PROTO ((void));\n static void compute_set_hash_table    PROTO ((rtx));\n static void alloc_expr_hash_table     PROTO ((int));\n static void free_expr_hash_table      PROTO ((void));\n static void compute_expr_hash_table   PROTO ((rtx));\n-static void dump_hash_table           PROTO ((FILE *, const char *, struct expr **, int, int));\n+static void dump_hash_table\t   PROTO ((FILE *, const char *, struct expr **, int, int));\n static struct expr *lookup_expr       PROTO ((rtx));\n-static struct expr *lookup_set        PROTO ((int, rtx));\n-static struct expr *next_set          PROTO ((int, struct expr *));\n+static struct expr *lookup_set\tPROTO ((int, rtx));\n+static struct expr *next_set\t  PROTO ((int, struct expr *));\n static void reset_opr_set_tables      PROTO ((void));\n-static int oprs_not_set_p             PROTO ((rtx, rtx));\n-static void mark_call                 PROTO ((rtx, rtx));\n-static void mark_set                  PROTO ((rtx, rtx));\n-static void mark_clobber              PROTO ((rtx, rtx));\n-static void mark_oprs_set             PROTO ((rtx));\n-\n-static void alloc_rd_mem              PROTO ((int, int));\n-static void free_rd_mem               PROTO ((void));\n-static void compute_kill_rd           PROTO ((void));\n-static void handle_rd_kill_set        PROTO ((rtx, int, int));\n-static void compute_rd                PROTO ((void));\n-extern void dump_rd_table             PROTO ((FILE *, char *, sbitmap *));\n+static int oprs_not_set_p\t     PROTO ((rtx, rtx));\n+static void mark_call\t\t PROTO ((rtx, rtx));\n+static void mark_set\t\t  PROTO ((rtx, rtx));\n+static void mark_clobber\t      PROTO ((rtx, rtx));\n+static void mark_oprs_set\t     PROTO ((rtx));\n+\n+static void alloc_rd_mem\t      PROTO ((int, int));\n+static void free_rd_mem\t       PROTO ((void));\n+static void compute_kill_rd\t   PROTO ((void));\n+static void handle_rd_kill_set\tPROTO ((rtx, int, int));\n+static void compute_rd\t\tPROTO ((void));\n+extern void dump_rd_table\t     PROTO ((FILE *, char *, sbitmap *));\n \n static void alloc_avail_expr_mem      PROTO ((int, int));\n static void free_avail_expr_mem       PROTO ((void));\n-static void compute_ae_gen            PROTO ((void));\n-static void compute_ae_kill           PROTO ((void));\n-static int expr_killed_p              PROTO ((rtx, int));\n-static void compute_available         PROTO ((void));\n+static void compute_ae_gen\t    PROTO ((void));\n+static void compute_ae_kill\t   PROTO ((void));\n+static int expr_killed_p\t      PROTO ((rtx, int));\n+static void compute_available\t PROTO ((void));\n \n-static int expr_reaches_here_p        PROTO ((struct occr *, struct expr *,\n+static int expr_reaches_here_p\tPROTO ((struct occr *, struct expr *,\n \t\t\t\t\t      int, int, char *));\n-static rtx computing_insn             PROTO ((struct expr *, rtx));\n-static int def_reaches_here_p         PROTO ((rtx, rtx));\n+static rtx computing_insn\t     PROTO ((struct expr *, rtx));\n+static int def_reaches_here_p\t PROTO ((rtx, rtx));\n static int can_disregard_other_sets   PROTO ((struct reg_set **, rtx, int));\n-static int handle_avail_expr          PROTO ((rtx, struct expr *));\n-static int classic_gcse               PROTO ((void));\n+static int handle_avail_expr\t  PROTO ((rtx, struct expr *));\n+static int classic_gcse\t       PROTO ((void));\n static int one_classic_gcse_pass      PROTO ((rtx, int));\n \n-static void alloc_cprop_mem           PROTO ((int, int));\n-static void free_cprop_mem            PROTO ((void));\n-extern void dump_cprop_data           PROTO ((FILE *));\n-static void compute_transp            PROTO ((rtx, int, sbitmap *, int));\n+static void alloc_cprop_mem\t   PROTO ((int, int));\n+static void free_cprop_mem\t    PROTO ((void));\n+extern void dump_cprop_data\t   PROTO ((FILE *));\n+static void compute_transp\t    PROTO ((rtx, int, sbitmap *, int));\n static void compute_cprop_local_properties PROTO ((void));\n static void compute_cprop_avinout     PROTO ((void));\n-static void compute_cprop_data        PROTO ((void));\n-static void find_used_regs            PROTO ((rtx));\n-static int try_replace_reg            PROTO ((rtx, rtx, rtx));\n+static void compute_cprop_data\tPROTO ((void));\n+static void find_used_regs\t    PROTO ((rtx));\n+static int try_replace_reg\t    PROTO ((rtx, rtx, rtx));\n static struct expr *find_avail_set    PROTO ((int, rtx));\n-static int cprop_insn                 PROTO ((rtx));\n-static int cprop                      PROTO ((void));\n-static int one_cprop_pass             PROTO ((rtx, int));\n+static int cprop_insn\t\t PROTO ((rtx));\n+static int cprop\t\t      PROTO ((void));\n+static int one_cprop_pass\t     PROTO ((rtx, int));\n \n-static void alloc_pre_mem             PROTO ((int, int));\n-static void free_pre_mem              PROTO ((void));\n-extern void dump_pre_data             PROTO ((FILE *));\n+static void alloc_pre_mem\t     PROTO ((int, int));\n+static void free_pre_mem\t      PROTO ((void));\n+extern void dump_pre_data\t     PROTO ((FILE *));\n static void compute_pre_local_properties PROTO ((void));\n static void compute_pre_avinout       PROTO ((void));\n static void compute_pre_antinout      PROTO ((void));\n static void compute_pre_pavinout      PROTO ((void));\n static void compute_pre_ppinout       PROTO ((void));\n-static void compute_pre_data          PROTO ((void));\n+static void compute_pre_data\t  PROTO ((void));\n static int pre_expr_reaches_here_p    PROTO ((struct occr *, struct expr *,\n \t\t\t\t\t      int, char *));\n-static void pre_insert_insn           PROTO ((struct expr *, int));\n-static void pre_insert                PROTO ((struct expr **));\n+static void pre_insert_insn\t   PROTO ((struct expr *, int));\n+static void pre_insert\t\tPROTO ((struct expr **));\n static void pre_insert_copy_insn      PROTO ((struct expr *, rtx));\n-static void pre_insert_copies         PROTO ((void));\n-static int pre_delete                 PROTO ((void));\n-static int pre_gcse                   PROTO ((void));\n-static int one_pre_gcse_pass          PROTO ((rtx, int));\n+static void pre_insert_copies\t PROTO ((void));\n+static int pre_delete\t\t PROTO ((void));\n+static int pre_gcse\t\t   PROTO ((void));\n+static int one_pre_gcse_pass\t  PROTO ((rtx, int));\n \n static void add_label_notes\t      PROTO ((rtx, rtx));\n \f\n@@ -2515,29 +2515,29 @@ compute_kill_rd ()\n \n   /* For each block\n        For each set bit in `gen' of the block (i.e each insn which\n-           generates a definition in the block)\n-         Call the reg set by the insn corresponding to that bit regx\n-         Look at the linked list starting at reg_set_table[regx]\n-         For each setting of regx in the linked list, which is not in\n-             this block\n-           Set the bit in `kill' corresponding to that insn\n+\t   generates a definition in the block)\n+\t Call the reg set by the insn corresponding to that bit regx\n+\t Look at the linked list starting at reg_set_table[regx]\n+\t For each setting of regx in the linked list, which is not in\n+\t     this block\n+\t   Set the bit in `kill' corresponding to that insn\n     */\n \n   for (bb = 0; bb < n_basic_blocks; bb++)\n     {\n       for (cuid = 0; cuid < max_cuid; cuid++)\n \t{\n \t  if (TEST_BIT (rd_gen[bb], cuid))\n-            {\n+\t    {\n \t      rtx insn = CUID_INSN (cuid);\n \t      rtx pat = PATTERN (insn);\n \n \t      if (GET_CODE (insn) == CALL_INSN)\n-                {\n+\t\t{\n \t\t  int regno;\n \n \t\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-                    {\n+\t\t    {\n \t\t      if ((call_used_regs[regno]\n \t\t\t   && regno != STACK_POINTER_REGNUM\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n@@ -2553,8 +2553,8 @@ compute_kill_rd ()\n \t\t\t   && regno != FRAME_POINTER_REGNUM)\n \t\t\t  || global_regs[regno])\n \t\t\thandle_rd_kill_set (insn, regno, bb);\n-                    }\n-                }\n+\t\t    }\n+\t\t}\n \n \t      if (GET_CODE (pat) == PARALLEL)\n \t\t{\n@@ -2579,9 +2579,9 @@ compute_kill_rd ()\n \t\t\t must be marked in the set of kills in this block.  */\n \t\t      handle_rd_kill_set (insn, REGNO (SET_DEST (pat)), bb);\n \t\t    }\n-                }\n+\t\t}\n \t      /* FIXME: CLOBBER? */\n-            }\n+\t    }\n \t}\n     }\n }\n@@ -2605,12 +2605,12 @@ compute_rd ()\n     {\n       changed = 0;\n       for (bb = 0; bb < n_basic_blocks; bb++)\n-        {\n+\t{\n \t  sbitmap_union_of_predecessors (reaching_defs[bb], rd_out,\n \t\t\t\t\t bb, s_preds);\n \t  changed |= sbitmap_union_of_diff (rd_out[bb], rd_gen[bb],\n \t\t\t\t\t    reaching_defs[bb], rd_kill[bb]);\n-        }\n+\t}\n       passes++;\n     }\n \n@@ -2858,20 +2858,20 @@ expr_reaches_here_p (occr, expr, bb, check_self_loop, visited)\n       int pred_bb = INT_LIST_VAL (pred);\n \n       if (visited[pred_bb])\n-        {\n+\t{\n \t  /* This predecessor has already been visited.\n \t     Nothing to do.  */\n \t  ;\n \t}\n       else if (pred_bb == bb)\n-        {\n+\t{\n \t  /* BB loops on itself.  */\n \t  if (check_self_loop\n \t      && TEST_BIT (ae_gen[pred_bb], expr->bitmap_index)\n \t      && BLOCK_NUM (occr->insn) == pred_bb)\n \t    return 1;\n \t  visited[pred_bb] = 1;\n-        }\n+\t}\n       /* Ignore this predecessor if it kills the expression.  */\n       else if (TEST_BIT (ae_kill[pred_bb], expr->bitmap_index))\n \tvisited[pred_bb] = 1;\n@@ -2887,11 +2887,11 @@ expr_reaches_here_p (occr, expr, bb, check_self_loop, visited)\n \t}\n       /* Neither gen nor kill.  */\n       else\n-        {\n+\t{\n \t  visited[pred_bb] = 1;\n \t  if (expr_reaches_here_p (occr, expr, pred_bb, check_self_loop, visited))\n \t    return 1;\n-        }\n+\t}\n     }\n \n   /* All paths have been checked.  */\n@@ -2983,7 +2983,7 @@ def_reaches_here_p (insn, def_insn)\n   if (BLOCK_NUM (insn) == BLOCK_NUM (def_insn))\n     {\n       if (INSN_CUID (def_insn) < INSN_CUID (insn))\n-        {\n+\t{\n \t  if (GET_CODE (PATTERN (def_insn)) == PARALLEL)\n \t    return 1;\n \t  if (GET_CODE (PATTERN (def_insn)) == CLOBBER)\n@@ -3166,13 +3166,13 @@ handle_avail_expr (insn, expr)\n \n       gcse_create_count++;\n       if (gcse_file != NULL)\n-        {\n+\t{\n \t  fprintf (gcse_file, \"GCSE: Creating insn %d to copy value of reg %d, computed in insn %d,\\n\",\n \t\t   INSN_UID (NEXT_INSN (insn_computes_expr)),\n \t\t   REGNO (SET_SRC (PATTERN (NEXT_INSN (insn_computes_expr)))),\n \t\t   INSN_UID (insn_computes_expr));\n \t  fprintf (gcse_file, \"      into newly allocated reg %d\\n\", REGNO (to));\n-        }\n+\t}\n \n       pat = PATTERN (insn);\n \n@@ -3252,7 +3252,7 @@ classic_gcse ()\n \t  /* ??? Need to be careful w.r.t. mods done to INSN.  */\n \t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t    mark_oprs_set (insn);\n-        }\n+\t}\n     }\n \n   return changed;\n@@ -3534,7 +3534,7 @@ compute_cprop_avinout ()\n     {\n       changed = 0;\n       for (bb = 0; bb < n_basic_blocks; bb++)\n-        {\n+\t{\n \t  if (bb != 0)\n \t    sbitmap_intersect_of_predecessors (cprop_avin[bb], cprop_avout,\n \t\t\t\t\t       bb, s_preds);\n@@ -3906,7 +3906,7 @@ cprop ()\n \t      /* ??? Need to be careful w.r.t. mods done to INSN.  */\n \t      mark_oprs_set (insn);\n \t    }\n-        }\n+\t}\n     }\n \n   if (gcse_file != NULL)\n@@ -4152,7 +4152,7 @@ compute_pre_avinout ()\n     {\n       changed = 0;\n       for (bb = 0; bb < n_basic_blocks; bb++)\n-        {\n+\t{\n \t  if (bb != 0)\n \t    sbitmap_intersect_of_predecessors (pre_avin[bb], pre_avout,\n \t\t\t\t\t       bb, s_preds);\n@@ -4184,7 +4184,7 @@ compute_pre_antinout ()\n       /* We scan the blocks in the reverse order to speed up\n \t the convergence.  */\n       for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n-        {\n+\t{\n \t  if (bb != n_basic_blocks - 1)\n \t    sbitmap_intersect_of_successors (pre_antout[bb], pre_antin,\n \t\t\t\t\t     bb, s_succs);\n@@ -4215,7 +4215,7 @@ compute_pre_pavinout ()\n     {\n       changed = 0;\n       for (bb = 0; bb < n_basic_blocks; bb++)\n-        {\n+\t{\n \t  if (bb != 0)\n \t    sbitmap_union_of_predecessors (pre_pavin[bb], pre_pavout,\n \t\t\t\t\t   bb, s_preds);\n@@ -4447,7 +4447,7 @@ pre_expr_reaches_here_p (occr, expr, bb, visited)\n       if (pred_bb == ENTRY_BLOCK\n \t  /* Has predecessor has already been visited?  */\n \t  || visited[pred_bb])\n-        {\n+\t{\n \t  /* Nothing to do.  */\n \t}\n       /* Does this predecessor generate this expression?  */\n@@ -4465,11 +4465,11 @@ pre_expr_reaches_here_p (occr, expr, bb, visited)\n \tvisited[pred_bb] = 1;\n       /* Neither gen nor kill.  */\n       else\n-        {\n+\t{\n \t  visited[pred_bb] = 1;\n \t  if (pre_expr_reaches_here_p (occr, expr, pred_bb, visited))\n \t    return 1;\n-        }\n+\t}\n     }\n \n   /* All paths have been checked.  */\n@@ -4943,10 +4943,10 @@ add_label_notes (x, insn)\n   if (code == LABEL_REF && !LABEL_REF_NONLOCAL_P (x))\n     {\n       /* This code used to ignore labels that referred to dispatch tables to\n-         avoid flow generating (slighly) worse code.\n+\t avoid flow generating (slighly) worse code.\n \n-         We no longer ignore such label references (see LABEL_REF handling in\n-         mark_jump_label for additional information).  */\n+\t We no longer ignore such label references (see LABEL_REF handling in\n+\t mark_jump_label for additional information).  */\n       REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL, XEXP (x, 0),\n \t\t\t\t\t    REG_NOTES (insn));\n       return;"}]}