{"sha": "9fec18623e1a937863f86cc25fa855e65e91d473", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZlYzE4NjIzZTFhOTM3ODYzZjg2Y2MyNWZhODU1ZTY1ZTkxZDQ3Mw==", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-05-02T17:19:32Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T19:09:39Z"}, "message": "This sets up the conversion from AST to GCC\n\nIt will crash when compiling but its the code setup i want to get in sooner\nthan later.\n\nAddresses #15", "tree": {"sha": "929d973fb3cf1cddfb994fe1d95cc18b5f6d92a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/929d973fb3cf1cddfb994fe1d95cc18b5f6d92a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fec18623e1a937863f86cc25fa855e65e91d473", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fec18623e1a937863f86cc25fa855e65e91d473", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fec18623e1a937863f86cc25fa855e65e91d473", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fec18623e1a937863f86cc25fa855e65e91d473/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e2f81b35a5f1b2be33379a8d91455b6cc68f3a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2f81b35a5f1b2be33379a8d91455b6cc68f3a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e2f81b35a5f1b2be33379a8d91455b6cc68f3a7"}], "stats": {"total": 1604, "additions": 1129, "deletions": 475}, "files": [{"sha": "0b867a4a8ecf8596bb06c29761c7cb4e5adef2b8", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=9fec18623e1a937863f86cc25fa855e65e91d473", "patch": "@@ -70,6 +70,7 @@ GRS_OBJS = \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n     rust/rust-resolution.o \\\n+    rust/rust-compile.o \\\n     $(END)\n # removed object files from here \n \n@@ -209,7 +210,7 @@ CFLAGS-rust/rust-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n \t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n \n # cross-folder includes - add new folders later\n-RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast -I $(srcdir)/rust/analysis\n+RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast -I $(srcdir)/rust/analysis -I $(srcdir)/rust/backend\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)\n@@ -238,3 +239,8 @@ rust/%.o: rust/ast/%.cc\n rust/%.o: rust/analysis/%.cc\n \t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n+\n+# build rust/backend files in rust folder\n+rust/%.o: rust/backend/%.cc\n+\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)"}, {"sha": "4ed96418e10526cc3030236a3107bb959233abb0", "filename": "gcc/rust/backend/rust-compile.cc", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=9fec18623e1a937863f86cc25fa855e65e91d473", "patch": "@@ -0,0 +1,647 @@\n+#include \"rust-compile.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+Compilation::Compilation (AST::Crate &crate, ::Backend *backend)\n+  : scope (), crate (crate), backend (backend)\n+{}\n+\n+Compilation::~Compilation () {}\n+\n+bool\n+Compilation::Compile (AST::Crate &crate, ::Backend *backend)\n+{\n+  Compilation resolver (crate, backend);\n+  return resolver.go ();\n+}\n+\n+bool\n+Compilation::go ()\n+{\n+  scope.Push ();\n+  for (auto &item : crate.items)\n+    {\n+      item->accept_vis (*this);\n+    }\n+  scope.Pop ();\n+\n+  // Define all globally declared values.\n+  if (!saw_errors ())\n+    backend->write_global_definitions (type_decls, const_decls, func_decls,\n+\t\t\t\t       var_decls);\n+\n+  return true;\n+}\n+\n+void\n+Compilation::visit (AST::Token &tok)\n+{}\n+\n+void\n+Compilation::visit (AST::DelimTokenTree &delim_tok_tree)\n+{}\n+\n+void\n+Compilation::visit (AST::AttrInputMetaItemContainer &input)\n+{}\n+\n+void\n+Compilation::visit (AST::IdentifierExpr &ident_expr)\n+{}\n+\n+void\n+Compilation::visit (AST::Lifetime &lifetime)\n+{}\n+\n+void\n+Compilation::visit (AST::LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+Compilation::visit (AST::MacroInvocationSemi &macro)\n+{}\n+\n+// rust-path.h\n+void\n+Compilation::visit (AST::PathInExpression &path)\n+{}\n+void\n+Compilation::visit (AST::TypePathSegment &segment)\n+{}\n+void\n+Compilation::visit (AST::TypePathSegmentGeneric &segment)\n+{}\n+void\n+Compilation::visit (AST::TypePathSegmentFunction &segment)\n+{}\n+void\n+Compilation::visit (AST::TypePath &path)\n+{}\n+void\n+Compilation::visit (AST::QualifiedPathInExpression &path)\n+{}\n+void\n+Compilation::visit (AST::QualifiedPathInType &path)\n+{}\n+\n+// rust-expr.h\n+void\n+Compilation::visit (AST::LiteralExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::AttrInputLiteral &attr_input)\n+{}\n+void\n+Compilation::visit (AST::MetaItemLitExpr &meta_item)\n+{}\n+void\n+Compilation::visit (AST::MetaItemPathLit &meta_item)\n+{}\n+void\n+Compilation::visit (AST::BorrowExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::DereferenceExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::ErrorPropagationExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::NegationExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::ComparisonExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::LazyBooleanExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::TypeCastExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::AssignmentExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::CompoundAssignmentExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::GroupedExpr &expr)\n+{}\n+// void Compilation::visit(ArrayElems& elems) {}\n+void\n+Compilation::visit (AST::ArrayElemsValues &elems)\n+{}\n+void\n+Compilation::visit (AST::ArrayElemsCopied &elems)\n+{}\n+void\n+Compilation::visit (AST::ArrayExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::ArrayIndexExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::TupleExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::TupleIndexExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::StructExprStruct &expr)\n+{}\n+// void Compilation::visit(StructExprField& field) {}\n+void\n+Compilation::visit (AST::StructExprFieldIdentifier &field)\n+{}\n+void\n+Compilation::visit (AST::StructExprFieldIdentifierValue &field)\n+{}\n+void\n+Compilation::visit (AST::StructExprFieldIndexValue &field)\n+{}\n+void\n+Compilation::visit (AST::StructExprStructFields &expr)\n+{}\n+void\n+Compilation::visit (AST::StructExprStructBase &expr)\n+{}\n+void\n+Compilation::visit (AST::StructExprTuple &expr)\n+{}\n+void\n+Compilation::visit (AST::StructExprUnit &expr)\n+{}\n+// void Compilation::visit(EnumExprField& field) {}\n+void\n+Compilation::visit (AST::EnumExprFieldIdentifier &field)\n+{}\n+void\n+Compilation::visit (AST::EnumExprFieldIdentifierValue &field)\n+{}\n+void\n+Compilation::visit (AST::EnumExprFieldIndexValue &field)\n+{}\n+void\n+Compilation::visit (AST::EnumExprStruct &expr)\n+{}\n+void\n+Compilation::visit (AST::EnumExprTuple &expr)\n+{}\n+void\n+Compilation::visit (AST::EnumExprFieldless &expr)\n+{}\n+void\n+Compilation::visit (AST::CallExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::MethodCallExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::FieldAccessExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::ClosureExprInner &expr)\n+{}\n+void\n+Compilation::visit (AST::BlockExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::ClosureExprInnerTyped &expr)\n+{}\n+void\n+Compilation::visit (AST::ContinueExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::BreakExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::RangeFromToExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::RangeFromExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::RangeToExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::RangeFullExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::RangeFromToInclExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::RangeToInclExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::ReturnExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::UnsafeBlockExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::LoopExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::WhileLoopExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::WhileLetLoopExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::ForLoopExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::IfExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::IfExprConseqElse &expr)\n+{}\n+void\n+Compilation::visit (AST::IfExprConseqIf &expr)\n+{}\n+void\n+Compilation::visit (AST::IfExprConseqIfLet &expr)\n+{}\n+void\n+Compilation::visit (AST::IfLetExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::IfLetExprConseqElse &expr)\n+{}\n+void\n+Compilation::visit (AST::IfLetExprConseqIf &expr)\n+{}\n+void\n+Compilation::visit (AST::IfLetExprConseqIfLet &expr)\n+{}\n+// void Compilation::visit(MatchCase& match_case) {}\n+void\n+Compilation::visit (AST::MatchCaseBlockExpr &match_case)\n+{}\n+void\n+Compilation::visit (AST::MatchCaseExpr &match_case)\n+{}\n+void\n+Compilation::visit (AST::MatchExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::AwaitExpr &expr)\n+{}\n+void\n+Compilation::visit (AST::AsyncBlockExpr &expr)\n+{}\n+\n+// rust-item.h\n+void\n+Compilation::visit (AST::TypeParam &param)\n+{}\n+// void Compilation::visit(WhereClauseItem& item) {}\n+void\n+Compilation::visit (AST::LifetimeWhereClauseItem &item)\n+{}\n+void\n+Compilation::visit (AST::TypeBoundWhereClauseItem &item)\n+{}\n+void\n+Compilation::visit (AST::Method &method)\n+{}\n+void\n+Compilation::visit (AST::ModuleBodied &module)\n+{}\n+void\n+Compilation::visit (AST::ModuleNoBody &module)\n+{}\n+void\n+Compilation::visit (AST::ExternCrate &crate)\n+{}\n+// void Compilation::visit(UseTree& use_tree) {}\n+void\n+Compilation::visit (AST::UseTreeGlob &use_tree)\n+{}\n+void\n+Compilation::visit (AST::UseTreeList &use_tree)\n+{}\n+void\n+Compilation::visit (AST::UseTreeRebind &use_tree)\n+{}\n+void\n+Compilation::visit (AST::UseDeclaration &use_decl)\n+{}\n+\n+void\n+Compilation::visit (AST::Function &function)\n+{\n+  scope.Insert (function.function_name, function.return_type.get ());\n+\n+  scope.Push ();\n+  printf (\"INSIDE FUNCTION: %s\\n\", function.function_name.c_str ());\n+\n+  if (!function.has_function_return_type ())\n+    {\n+      // TODO\n+      // auto fntype = backend->function_type ();\n+\n+      auto mangled_asm_name = \"\"; // TODO\n+      currentFndecl\n+\t= backend->function (backend->void_type (), function.function_name,\n+\t\t\t     mangled_asm_name, 0, function.locus);\n+    }\n+  else\n+    {\n+      translatedType = NULL;\n+      function.return_type->accept_vis (*this);\n+      if (translatedType == NULL)\n+\t{\n+\t  rust_error_at (function.locus, \"Unable to compile type\");\n+\t  return;\n+\t}\n+\n+      auto mangled_asm_name = \"\"; // TODO\n+      currentFndecl = backend->function (translatedType, function.function_name,\n+\t\t\t\t\t mangled_asm_name, 0, function.locus);\n+    }\n+\n+  std::vector< ::Bvariable *> params;\n+  for (auto &param : function.function_params)\n+    {\n+      printf (\"FUNC PARAM: %s\\n\", param.as_string ().c_str ());\n+      // TODO\n+    }\n+\n+  if (params.size () == 0 && function.function_params.size () > 0)\n+    {\n+      rust_error_at (function.locus, \"Unable to compile parameters\");\n+      return;\n+    }\n+  else if (params.size () > 0)\n+    {\n+      backend->function_set_parameters (currentFndecl, params);\n+    }\n+\n+  /*\n+    // walk the expression body\n+    Bstatement *body;\n+    for (auto &stmt : function.function_body->statements)\n+      {\n+\tstmt->accept_vis (*this);\n+      }\n+\n+      backend->function_set_body (fndecl, body);*/\n+\n+  func_decls.push_back (currentFndecl);\n+  currentFndecl = NULL;\n+\n+  scope.Pop ();\n+}\n+\n+void\n+Compilation::visit (AST::TypeAlias &type_alias)\n+{}\n+void\n+Compilation::visit (AST::StructStruct &struct_item)\n+{}\n+void\n+Compilation::visit (AST::TupleStruct &tuple_struct)\n+{}\n+void\n+Compilation::visit (AST::EnumItem &item)\n+{}\n+void\n+Compilation::visit (AST::EnumItemTuple &item)\n+{}\n+void\n+Compilation::visit (AST::EnumItemStruct &item)\n+{}\n+void\n+Compilation::visit (AST::EnumItemDiscriminant &item)\n+{}\n+void\n+Compilation::visit (AST::Enum &enum_item)\n+{}\n+void\n+Compilation::visit (AST::Union &union_item)\n+{}\n+void\n+Compilation::visit (AST::ConstantItem &const_item)\n+{}\n+void\n+Compilation::visit (AST::StaticItem &static_item)\n+{}\n+void\n+Compilation::visit (AST::TraitItemFunc &item)\n+{}\n+void\n+Compilation::visit (AST::TraitItemMethod &item)\n+{}\n+void\n+Compilation::visit (AST::TraitItemConst &item)\n+{}\n+void\n+Compilation::visit (AST::TraitItemType &item)\n+{}\n+void\n+Compilation::visit (AST::Trait &trait)\n+{}\n+void\n+Compilation::visit (AST::InherentImpl &impl)\n+{}\n+void\n+Compilation::visit (AST::TraitImpl &impl)\n+{}\n+// void Compilation::visit(ExternalItem& item) {}\n+void\n+Compilation::visit (AST::ExternalStaticItem &item)\n+{}\n+void\n+Compilation::visit (AST::ExternalFunctionItem &item)\n+{}\n+void\n+Compilation::visit (AST::ExternBlock &block)\n+{}\n+\n+// rust-macro.h\n+void\n+Compilation::visit (AST::MacroMatchFragment &match)\n+{}\n+void\n+Compilation::visit (AST::MacroMatchRepetition &match)\n+{}\n+void\n+Compilation::visit (AST::MacroMatcher &matcher)\n+{}\n+void\n+Compilation::visit (AST::MacroRulesDefinition &rules_def)\n+{}\n+void\n+Compilation::visit (AST::MacroInvocation &macro_invoc)\n+{}\n+void\n+Compilation::visit (AST::MetaItemPath &meta_item)\n+{}\n+void\n+Compilation::visit (AST::MetaItemSeq &meta_item)\n+{}\n+void\n+Compilation::visit (AST::MetaWord &meta_item)\n+{}\n+void\n+Compilation::visit (AST::MetaNameValueStr &meta_item)\n+{}\n+void\n+Compilation::visit (AST::MetaListPaths &meta_item)\n+{}\n+void\n+Compilation::visit (AST::MetaListNameValueStr &meta_item)\n+{}\n+\n+// rust-pattern.h\n+void\n+Compilation::visit (AST::LiteralPattern &pattern)\n+{\n+  printf (\"LiteralPattern: %s\\n\", pattern.as_string ().c_str ());\n+}\n+\n+void\n+Compilation::visit (AST::IdentifierPattern &pattern)\n+{\n+  printf (\"IdentifierPattern: %s\\n\", pattern.as_string ().c_str ());\n+  letPatternBuffer.push_back (pattern);\n+}\n+\n+void\n+Compilation::visit (AST::WildcardPattern &pattern)\n+{}\n+// void Compilation::visit(RangePatternBound& bound) {}\n+void\n+Compilation::visit (AST::RangePatternBoundLiteral &bound)\n+{}\n+void\n+Compilation::visit (AST::RangePatternBoundPath &bound)\n+{}\n+void\n+Compilation::visit (AST::RangePatternBoundQualPath &bound)\n+{}\n+void\n+Compilation::visit (AST::RangePattern &pattern)\n+{}\n+void\n+Compilation::visit (AST::ReferencePattern &pattern)\n+{}\n+// void Compilation::visit(StructPatternField& field) {}\n+void\n+Compilation::visit (AST::StructPatternFieldTuplePat &field)\n+{}\n+void\n+Compilation::visit (AST::StructPatternFieldIdentPat &field)\n+{}\n+void\n+Compilation::visit (AST::StructPatternFieldIdent &field)\n+{}\n+void\n+Compilation::visit (AST::StructPattern &pattern)\n+{}\n+// void Compilation::visit(TupleStructItems& tuple_items) {}\n+void\n+Compilation::visit (AST::TupleStructItemsNoRange &tuple_items)\n+{}\n+void\n+Compilation::visit (AST::TupleStructItemsRange &tuple_items)\n+{}\n+void\n+Compilation::visit (AST::TupleStructPattern &pattern)\n+{}\n+// void Compilation::visit(TuplePatternItems& tuple_items) {}\n+void\n+Compilation::visit (AST::TuplePatternItemsMultiple &tuple_items)\n+{}\n+void\n+Compilation::visit (AST::TuplePatternItemsRanged &tuple_items)\n+{}\n+void\n+Compilation::visit (AST::TuplePattern &pattern)\n+{}\n+void\n+Compilation::visit (AST::GroupedPattern &pattern)\n+{}\n+void\n+Compilation::visit (AST::SlicePattern &pattern)\n+{}\n+\n+// rust-stmt.h\n+void\n+Compilation::visit (AST::EmptyStmt &stmt)\n+{}\n+void\n+\n+Compilation::visit (AST::LetStmt &stmt)\n+{\n+  printf (\"Within LetStmt: %s\\n\", stmt.as_string ().c_str ());\n+\n+  stmt.variables_pattern->accept_vis (*this);\n+\n+  for (auto it = letPatternBuffer.begin (); it != letPatternBuffer.end (); it++)\n+    {\n+      // scope.Insert (it->first., stmt.type.get ());\n+    }\n+\n+  letPatternBuffer.clear ();\n+}\n+\n+void\n+Compilation::visit (AST::ExprStmtWithoutBlock &stmt)\n+{}\n+void\n+Compilation::visit (AST::ExprStmtWithBlock &stmt)\n+{}\n+\n+// rust-type.h\n+void\n+Compilation::visit (AST::TraitBound &bound)\n+{}\n+void\n+Compilation::visit (AST::ImplTraitType &type)\n+{}\n+void\n+Compilation::visit (AST::TraitObjectType &type)\n+{}\n+void\n+Compilation::visit (AST::ParenthesisedType &type)\n+{}\n+void\n+Compilation::visit (AST::ImplTraitTypeOneBound &type)\n+{}\n+void\n+Compilation::visit (AST::TraitObjectTypeOneBound &type)\n+{}\n+void\n+Compilation::visit (AST::TupleType &type)\n+{}\n+void\n+Compilation::visit (AST::NeverType &type)\n+{}\n+void\n+Compilation::visit (AST::RawPointerType &type)\n+{}\n+void\n+Compilation::visit (AST::ReferenceType &type)\n+{}\n+void\n+Compilation::visit (AST::ArrayType &type)\n+{}\n+void\n+Compilation::visit (AST::SliceType &type)\n+{}\n+void\n+Compilation::visit (AST::InferredType &type)\n+{}\n+void\n+Compilation::visit (AST::BareFunctionType &type)\n+{}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "85658477bc54c0576dbc2d53b4f659c2ead88ab0", "filename": "gcc/rust/backend/rust-compile.h", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Fbackend%2Frust-compile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Fbackend%2Frust-compile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.h?ref=9fec18623e1a937863f86cc25fa855e65e91d473", "patch": "@@ -0,0 +1,246 @@\n+#pragma once\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-backend.h\"\n+#include \"scope.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class Compilation : public AST::ASTVisitor\n+{\n+public:\n+  static bool Compile (AST::Crate &crate, ::Backend *backend);\n+\n+  ~Compilation ();\n+\n+  // visitor impl\n+  // rust-ast.h\n+  // virtual void visit(AttrInput& attr_input);\n+  // virtual void visit(TokenTree& token_tree);\n+  // virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (AST::Token &tok);\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree);\n+  virtual void visit (AST::AttrInputMetaItemContainer &input);\n+  // virtual void visit(MetaItem& meta_item);\n+  // virtual void vsit(Stmt& stmt);\n+  // virtual void visit(Expr& expr);\n+  virtual void visit (AST::IdentifierExpr &ident_expr);\n+  // virtual void visit(Pattern& pattern);\n+  // virtual void visit(Type& type);\n+  // virtual void visit(TypeParamBound& type_param_bound);\n+  virtual void visit (AST::Lifetime &lifetime);\n+  // virtual void visit(GenericParam& generic_param);\n+  virtual void visit (AST::LifetimeParam &lifetime_param);\n+  // virtual void visit(TraitItem& trait_item);\n+  // virtual void visit(InherentImplItem& inherent_impl_item);\n+  // virtual void visit(TraitImplItem& trait_impl_item);\n+  virtual void visit (AST::MacroInvocationSemi &macro);\n+\n+  // rust-path.h\n+  virtual void visit (AST::PathInExpression &path);\n+  virtual void visit (AST::TypePathSegment &segment);\n+  virtual void visit (AST::TypePathSegmentGeneric &segment);\n+  virtual void visit (AST::TypePathSegmentFunction &segment);\n+  virtual void visit (AST::TypePath &path);\n+  virtual void visit (AST::QualifiedPathInExpression &path);\n+  virtual void visit (AST::QualifiedPathInType &path);\n+\n+  // rust-expr.h\n+  virtual void visit (AST::LiteralExpr &expr);\n+  virtual void visit (AST::AttrInputLiteral &attr_input);\n+  virtual void visit (AST::MetaItemLitExpr &meta_item);\n+  virtual void visit (AST::MetaItemPathLit &meta_item);\n+  virtual void visit (AST::BorrowExpr &expr);\n+  virtual void visit (AST::DereferenceExpr &expr);\n+  virtual void visit (AST::ErrorPropagationExpr &expr);\n+  virtual void visit (AST::NegationExpr &expr);\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr);\n+  virtual void visit (AST::ComparisonExpr &expr);\n+  virtual void visit (AST::LazyBooleanExpr &expr);\n+  virtual void visit (AST::TypeCastExpr &expr);\n+  virtual void visit (AST::AssignmentExpr &expr);\n+  virtual void visit (AST::CompoundAssignmentExpr &expr);\n+  virtual void visit (AST::GroupedExpr &expr);\n+  // virtual void visit(ArrayElems& elems);\n+  virtual void visit (AST::ArrayElemsValues &elems);\n+  virtual void visit (AST::ArrayElemsCopied &elems);\n+  virtual void visit (AST::ArrayExpr &expr);\n+  virtual void visit (AST::ArrayIndexExpr &expr);\n+  virtual void visit (AST::TupleExpr &expr);\n+  virtual void visit (AST::TupleIndexExpr &expr);\n+  virtual void visit (AST::StructExprStruct &expr);\n+  // virtual void visit(StructExprField& field);\n+  virtual void visit (AST::StructExprFieldIdentifier &field);\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field);\n+  virtual void visit (AST::StructExprFieldIndexValue &field);\n+  virtual void visit (AST::StructExprStructFields &expr);\n+  virtual void visit (AST::StructExprStructBase &expr);\n+  virtual void visit (AST::StructExprTuple &expr);\n+  virtual void visit (AST::StructExprUnit &expr);\n+  // virtual void visit(EnumExprField& field);\n+  virtual void visit (AST::EnumExprFieldIdentifier &field);\n+  virtual void visit (AST::EnumExprFieldIdentifierValue &field);\n+  virtual void visit (AST::EnumExprFieldIndexValue &field);\n+  virtual void visit (AST::EnumExprStruct &expr);\n+  virtual void visit (AST::EnumExprTuple &expr);\n+  virtual void visit (AST::EnumExprFieldless &expr);\n+  virtual void visit (AST::CallExpr &expr);\n+  virtual void visit (AST::MethodCallExpr &expr);\n+  virtual void visit (AST::FieldAccessExpr &expr);\n+  virtual void visit (AST::ClosureExprInner &expr);\n+  virtual void visit (AST::BlockExpr &expr);\n+  virtual void visit (AST::ClosureExprInnerTyped &expr);\n+  virtual void visit (AST::ContinueExpr &expr);\n+  virtual void visit (AST::BreakExpr &expr);\n+  virtual void visit (AST::RangeFromToExpr &expr);\n+  virtual void visit (AST::RangeFromExpr &expr);\n+  virtual void visit (AST::RangeToExpr &expr);\n+  virtual void visit (AST::RangeFullExpr &expr);\n+  virtual void visit (AST::RangeFromToInclExpr &expr);\n+  virtual void visit (AST::RangeToInclExpr &expr);\n+  virtual void visit (AST::ReturnExpr &expr);\n+  virtual void visit (AST::UnsafeBlockExpr &expr);\n+  virtual void visit (AST::LoopExpr &expr);\n+  virtual void visit (AST::WhileLoopExpr &expr);\n+  virtual void visit (AST::WhileLetLoopExpr &expr);\n+  virtual void visit (AST::ForLoopExpr &expr);\n+  virtual void visit (AST::IfExpr &expr);\n+  virtual void visit (AST::IfExprConseqElse &expr);\n+  virtual void visit (AST::IfExprConseqIf &expr);\n+  virtual void visit (AST::IfExprConseqIfLet &expr);\n+  virtual void visit (AST::IfLetExpr &expr);\n+  virtual void visit (AST::IfLetExprConseqElse &expr);\n+  virtual void visit (AST::IfLetExprConseqIf &expr);\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr);\n+  // virtual void visit(MatchCase& match_case);\n+  virtual void visit (AST::MatchCaseBlockExpr &match_case);\n+  virtual void visit (AST::MatchCaseExpr &match_case);\n+  virtual void visit (AST::MatchExpr &expr);\n+  virtual void visit (AST::AwaitExpr &expr);\n+  virtual void visit (AST::AsyncBlockExpr &expr);\n+\n+  // rust-item.h\n+  virtual void visit (AST::TypeParam &param);\n+  // virtual void visit(WhereClauseItem& item);\n+  virtual void visit (AST::LifetimeWhereClauseItem &item);\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item);\n+  virtual void visit (AST::Method &method);\n+  virtual void visit (AST::ModuleBodied &module);\n+  virtual void visit (AST::ModuleNoBody &module);\n+  virtual void visit (AST::ExternCrate &crate);\n+  // virtual void visit(UseTree& use_tree);\n+  virtual void visit (AST::UseTreeGlob &use_tree);\n+  virtual void visit (AST::UseTreeList &use_tree);\n+  virtual void visit (AST::UseTreeRebind &use_tree);\n+  virtual void visit (AST::UseDeclaration &use_decl);\n+  virtual void visit (AST::Function &function);\n+  virtual void visit (AST::TypeAlias &type_alias);\n+  virtual void visit (AST::StructStruct &struct_item);\n+  virtual void visit (AST::TupleStruct &tuple_struct);\n+  virtual void visit (AST::EnumItem &item);\n+  virtual void visit (AST::EnumItemTuple &item);\n+  virtual void visit (AST::EnumItemStruct &item);\n+  virtual void visit (AST::EnumItemDiscriminant &item);\n+  virtual void visit (AST::Enum &enum_item);\n+  virtual void visit (AST::Union &union_item);\n+  virtual void visit (AST::ConstantItem &const_item);\n+  virtual void visit (AST::StaticItem &static_item);\n+  virtual void visit (AST::TraitItemFunc &item);\n+  virtual void visit (AST::TraitItemMethod &item);\n+  virtual void visit (AST::TraitItemConst &item);\n+  virtual void visit (AST::TraitItemType &item);\n+  virtual void visit (AST::Trait &trait);\n+  virtual void visit (AST::InherentImpl &impl);\n+  virtual void visit (AST::TraitImpl &impl);\n+  // virtual void visit(ExternalItem& item);\n+  virtual void visit (AST::ExternalStaticItem &item);\n+  virtual void visit (AST::ExternalFunctionItem &item);\n+  virtual void visit (AST::ExternBlock &block);\n+\n+  // rust-macro.h\n+  virtual void visit (AST::MacroMatchFragment &match);\n+  virtual void visit (AST::MacroMatchRepetition &match);\n+  virtual void visit (AST::MacroMatcher &matcher);\n+  virtual void visit (AST::MacroRulesDefinition &rules_def);\n+  virtual void visit (AST::MacroInvocation &macro_invoc);\n+  virtual void visit (AST::MetaItemPath &meta_item);\n+  virtual void visit (AST::MetaItemSeq &meta_item);\n+  virtual void visit (AST::MetaWord &meta_item);\n+  virtual void visit (AST::MetaNameValueStr &meta_item);\n+  virtual void visit (AST::MetaListPaths &meta_item);\n+  virtual void visit (AST::MetaListNameValueStr &meta_item);\n+\n+  // rust-pattern.h\n+  virtual void visit (AST::LiteralPattern &pattern);\n+  virtual void visit (AST::IdentifierPattern &pattern);\n+  virtual void visit (AST::WildcardPattern &pattern);\n+  // virtual void visit(RangePatternBound& bound);\n+  virtual void visit (AST::RangePatternBoundLiteral &bound);\n+  virtual void visit (AST::RangePatternBoundPath &bound);\n+  virtual void visit (AST::RangePatternBoundQualPath &bound);\n+  virtual void visit (AST::RangePattern &pattern);\n+  virtual void visit (AST::ReferencePattern &pattern);\n+  // virtual void visit(StructPatternField& field);\n+  virtual void visit (AST::StructPatternFieldTuplePat &field);\n+  virtual void visit (AST::StructPatternFieldIdentPat &field);\n+  virtual void visit (AST::StructPatternFieldIdent &field);\n+  virtual void visit (AST::StructPattern &pattern);\n+  // virtual void visit(TupleStructItems& tuple_items);\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items);\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items);\n+  virtual void visit (AST::TupleStructPattern &pattern);\n+  // virtual void visit(TuplePatternItems& tuple_items);\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items);\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items);\n+  virtual void visit (AST::TuplePattern &pattern);\n+  virtual void visit (AST::GroupedPattern &pattern);\n+  virtual void visit (AST::SlicePattern &pattern);\n+\n+  // rust-stmt.h\n+  virtual void visit (AST::EmptyStmt &stmt);\n+  virtual void visit (AST::LetStmt &stmt);\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt);\n+  virtual void visit (AST::ExprStmtWithBlock &stmt);\n+\n+  // rust-type.h\n+  virtual void visit (AST::TraitBound &bound);\n+  virtual void visit (AST::ImplTraitType &type);\n+  virtual void visit (AST::TraitObjectType &type);\n+  virtual void visit (AST::ParenthesisedType &type);\n+  virtual void visit (AST::ImplTraitTypeOneBound &type);\n+  virtual void visit (AST::TraitObjectTypeOneBound &type);\n+  virtual void visit (AST::TupleType &type);\n+  virtual void visit (AST::NeverType &type);\n+  virtual void visit (AST::RawPointerType &type);\n+  virtual void visit (AST::ReferenceType &type);\n+  virtual void visit (AST::ArrayType &type);\n+  virtual void visit (AST::SliceType &type);\n+  virtual void visit (AST::InferredType &type);\n+  virtual void visit (AST::BareFunctionType &type);\n+\n+private:\n+  Compilation (AST::Crate &crate, Backend *backend);\n+\n+  bool go ();\n+\n+  Analysis::Scope scope;\n+  AST::Crate &crate;\n+  Backend *backend;\n+\n+  /* we need lots of members to be buffers for translation of the AST */\n+  std::vector<AST::IdentifierPattern> letPatternBuffer;\n+\n+  ::Bfunction *currentFndecl;\n+  ::Btype *translatedType;\n+\n+  std::vector< ::Btype *> type_decls;\n+  std::vector< ::Bvariable *> var_decls;\n+  std::vector< ::Bexpression *> const_decls;\n+  std::vector< ::Bfunction *> func_decls;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "ccc5e4756fa83abc9effd04f5c08cb65df348bf4", "filename": "gcc/rust/rust-backend.h", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=9fec18623e1a937863f86cc25fa855e65e91d473", "patch": "@@ -6,6 +6,9 @@\n \n #include \"operator.h\"\n \n+extern bool\n+saw_errors (void);\n+\n // TODO: Will have to be significantly modified to work with Rust and current\n // setup of gccrs\n ", "previous_filename": "gcc/rust/backend.h"}, {"sha": "474986d7ef3b2870c3e10c28c4dcd3bd2cb6837c", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 2, "deletions": 293, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=9fec18623e1a937863f86cc25fa855e65e91d473", "patch": "@@ -46,7 +46,7 @@\n \n #include \"rust-location.h\"\n #include \"rust-linemap.h\"\n-#include \"backend.h\"\n+#include \"rust-backend.h\"\n #include \"rust-object-export.h\"\n \n // TODO: this will have to be significantly modified to work with Rust\n@@ -428,7 +428,6 @@ class Gcc_backend : public Backend\n   tree convert_tree (tree, tree, Location);\n \n private:\n-<<<<<<< HEAD\n   static const int builtin_const = 1 << 0;\n   static const int builtin_noreturn = 1 << 1;\n   static const int builtin_novops = 1 << 2;\n@@ -437,13 +436,6 @@ class Gcc_backend : public Backend\n \t\t       const char *libname, tree fntype, int flags);\n \n   // A mapping of the GCC built-ins exposed to GCCRust.\n-=======\n-  void define_builtin (built_in_function bcode, const char *name,\n-\t\t       const char *libname, tree fntype, bool const_p,\n-\t\t       bool noreturn_p);\n-\n-  // A mapping of the GCC built-ins exposed to GCCGo.\n->>>>>>> 12e994a7967... Fix indentation\n   std::map<std::string, Bfunction *> builtin_functions_;\n };\n \n@@ -464,141 +456,84 @@ Gcc_backend::Gcc_backend ()\n   tree t = this->integer_type (true, BITS_PER_UNIT)->get_tree ();\n   tree p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n   this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_1, \"__sync_fetch_and_add_1\",\n-<<<<<<< HEAD\n \t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-=======\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE),\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = this->integer_type (true, BITS_PER_UNIT * 2)->get_tree ();\n   p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n   this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_2, \"__sync_fetch_and_add_2\",\n-<<<<<<< HEAD\n \t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-=======\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE),\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = this->integer_type (true, BITS_PER_UNIT * 4)->get_tree ();\n   p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n   this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_4, \"__sync_fetch_and_add_4\",\n-<<<<<<< HEAD\n \t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-=======\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE),\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = this->integer_type (true, BITS_PER_UNIT * 8)->get_tree ();\n   p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n   this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_8, \"__sync_fetch_and_add_8\",\n-<<<<<<< HEAD\n \t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-=======\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE),\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_expect for magic import functions.\n   this->define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n \t\t\tbuild_function_type_list (long_integer_type_node,\n \t\t\t\t\t\t  long_integer_type_node,\n \t\t\t\t\t\t  long_integer_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n-=======\n-\t\t\ttrue, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_memcmp for struct comparisons.\n   this->define_builtin (BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t\t  size_type_node, NULL_TREE),\n-<<<<<<< HEAD\n \t\t\t0);\n-=======\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_memmove for copying data.\n   this->define_builtin (BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n \t\t\tbuild_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t\t  size_type_node, NULL_TREE),\n-<<<<<<< HEAD\n \t\t\t0);\n-=======\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_memset for zeroing data.\n   this->define_builtin (BUILT_IN_MEMSET, \"__builtin_memset\", \"memset\",\n \t\t\tbuild_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\t\t\t  integer_type_node,\n \t\t\t\t\t\t  size_type_node, NULL_TREE),\n-<<<<<<< HEAD\n \t\t\t0);\n-=======\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // Used by runtime/internal/sys and math/bits.\n   this->define_builtin (BUILT_IN_CTZ, \"__builtin_ctz\", \"ctz\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n-=======\n-\t\t\ttrue, false);\n->>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_CTZLL, \"__builtin_ctzll\", \"ctzll\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  long_long_unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n-=======\n-\t\t\ttrue, false);\n->>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_CLZ, \"__builtin_clz\", \"clz\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n-=======\n-\t\t\ttrue, false);\n->>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_CLZLL, \"__builtin_clzll\", \"clzll\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  long_long_unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n-=======\n-\t\t\ttrue, false);\n->>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_POPCOUNT, \"__builtin_popcount\", \"popcount\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n-=======\n-\t\t\ttrue, false);\n->>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_POPCOUNTLL, \"__builtin_popcountll\",\n \t\t\t\"popcountll\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  long_long_unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n   this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n \t\t\tbuild_function_type_list (uint16_type_node,\n@@ -612,21 +547,6 @@ Gcc_backend::Gcc_backend ()\n \t\t\tbuild_function_type_list (uint64_type_node,\n \t\t\t\t\t\t  uint64_type_node, NULL_TREE),\n \t\t\tbuiltin_const);\n-=======\n-\t\t\ttrue, false);\n-  this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n-\t\t\tbuild_function_type_list (uint16_type_node,\n-\t\t\t\t\t\t  uint16_type_node, NULL_TREE),\n-\t\t\ttrue, false);\n-  this->define_builtin (BUILT_IN_BSWAP32, \"__builtin_bswap32\", \"bswap32\",\n-\t\t\tbuild_function_type_list (uint32_type_node,\n-\t\t\t\t\t\t  uint32_type_node, NULL_TREE),\n-\t\t\ttrue, false);\n-  this->define_builtin (BUILT_IN_BSWAP64, \"__builtin_bswap64\", \"bswap64\",\n-\t\t\tbuild_function_type_list (uint64_type_node,\n-\t\t\t\t\t\t  uint64_type_node, NULL_TREE),\n-\t\t\ttrue, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // We provide some functions for the math library.\n   tree math_function_type\n@@ -641,7 +561,6 @@ Gcc_backend::Gcc_backend ()\n     = build_function_type_list (long_double_type_node, long_double_type_node,\n \t\t\t\tlong_double_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ACOS, \"__builtin_acos\", \"acos\",\n-<<<<<<< HEAD\n \t\t\tmath_function_type, builtin_const);\n   this->define_builtin (BUILT_IN_ACOSL, \"__builtin_acosl\", \"acosl\",\n \t\t\tmath_function_type_long, builtin_const);\n@@ -685,65 +604,15 @@ Gcc_backend::Gcc_backend ()\n \t\t\tmath_function_type_two, builtin_const);\n   this->define_builtin (BUILT_IN_FMODL, \"__builtin_fmodl\", \"fmodl\",\n \t\t\tmath_function_type_long_two, builtin_const);\n-=======\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_ACOSL, \"__builtin_acosl\", \"acosl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_ASIN, \"__builtin_asin\", \"asin\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_ASINL, \"__builtin_asinl\", \"asinl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_ATAN, \"__builtin_atan\", \"atan\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_ATANL, \"__builtin_atanl\", \"atanl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_ATAN2, \"__builtin_atan2\", \"atan2\",\n-\t\t\tmath_function_type_two, true, false);\n-  this->define_builtin (BUILT_IN_ATAN2L, \"__builtin_atan2l\", \"atan2l\",\n-\t\t\tmath_function_type_long_two, true, false);\n-  this->define_builtin (BUILT_IN_CEIL, \"__builtin_ceil\", \"ceil\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_CEILL, \"__builtin_ceill\", \"ceill\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_COS, \"__builtin_cos\", \"cos\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_COSL, \"__builtin_cosl\", \"cosl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_EXP, \"__builtin_exp\", \"exp\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_EXPL, \"__builtin_expl\", \"expl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_EXPM1, \"__builtin_expm1\", \"expm1\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_EXPM1L, \"__builtin_expm1l\", \"expm1l\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_FABS, \"__builtin_fabs\", \"fabs\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_FABSL, \"__builtin_fabsl\", \"fabsl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_FLOOR, \"__builtin_floor\", \"floor\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_FLOORL, \"__builtin_floorl\", \"floorl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_FMOD, \"__builtin_fmod\", \"fmod\",\n-\t\t\tmath_function_type_two, true, false);\n-  this->define_builtin (BUILT_IN_FMODL, \"__builtin_fmodl\", \"fmodl\",\n-\t\t\tmath_function_type_long_two, true, false);\n->>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_LDEXP, \"__builtin_ldexp\", \"ldexp\",\n \t\t\tbuild_function_type_list (double_type_node,\n \t\t\t\t\t\t  double_type_node,\n \t\t\t\t\t\t  integer_type_node, NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n-=======\n-\t\t\ttrue, false);\n->>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_LDEXPL, \"__builtin_ldexpl\", \"ldexpl\",\n \t\t\tbuild_function_type_list (long_double_type_node,\n \t\t\t\t\t\t  long_double_type_node,\n \t\t\t\t\t\t  integer_type_node, NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const);\n   this->define_builtin (BUILT_IN_LOG, \"__builtin_log\", \"log\",\n \t\t\tmath_function_type, builtin_const);\n@@ -777,47 +646,11 @@ Gcc_backend::Gcc_backend ()\n \t\t\tmath_function_type, builtin_const);\n   this->define_builtin (BUILT_IN_TRUNCL, \"__builtin_truncl\", \"truncl\",\n \t\t\tmath_function_type_long, builtin_const);\n-=======\n-\t\t\ttrue, false);\n-  this->define_builtin (BUILT_IN_LOG, \"__builtin_log\", \"log\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_LOGL, \"__builtin_logl\", \"logl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_LOG1P, \"__builtin_log1p\", \"log1p\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_LOG1PL, \"__builtin_log1pl\", \"log1pl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_LOG10, \"__builtin_log10\", \"log10\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_LOG10L, \"__builtin_log10l\", \"log10l\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_LOG2, \"__builtin_log2\", \"log2\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_LOG2L, \"__builtin_log2l\", \"log2l\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_SIN, \"__builtin_sin\", \"sin\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_SINL, \"__builtin_sinl\", \"sinl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_SQRT, \"__builtin_sqrt\", \"sqrt\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_SQRTL, \"__builtin_sqrtl\", \"sqrtl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_TAN, \"__builtin_tan\", \"tan\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_TANL, \"__builtin_tanl\", \"tanl\",\n-\t\t\tmath_function_type_long, true, false);\n-  this->define_builtin (BUILT_IN_TRUNC, \"__builtin_trunc\", \"trunc\",\n-\t\t\tmath_function_type, true, false);\n-  this->define_builtin (BUILT_IN_TRUNCL, \"__builtin_truncl\", \"truncl\",\n-\t\t\tmath_function_type_long, true, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_return_address in the thunk we build for\n   // functions which call recover, and for runtime.getcallerpc.\n   t = build_function_type_list (ptr_type_node, unsigned_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_RETURN_ADDRESS, \"__builtin_return_address\",\n-<<<<<<< HEAD\n \t\t\tNULL, t, 0);\n \n   // The runtime calls __builtin_dwarf_cfa for runtime.getcallersp.\n@@ -829,176 +662,94 @@ Gcc_backend::Gcc_backend ()\n   this->define_builtin (\n     BUILT_IN_EXTRACT_RETURN_ADDR, \"__builtin_extract_return_addr\", NULL,\n     build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE), 0);\n-=======\n-\t\t\tNULL, t, false, false);\n-\n-  // The runtime calls __builtin_dwarf_cfa for runtime.getcallersp.\n-  t = build_function_type_list (ptr_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_DWARF_CFA, \"__builtin_dwarf_cfa\", NULL, t,\n-\t\t\tfalse, false);\n-\n-  // The runtime calls __builtin_extract_return_addr when recording\n-  // the address to which a function returns.\n-  this->define_builtin (BUILT_IN_EXTRACT_RETURN_ADDR,\n-\t\t\t\"__builtin_extract_return_addr\", NULL,\n-\t\t\tbuild_function_type_list (ptr_type_node, ptr_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // The compiler uses __builtin_trap for some exception handling\n   // cases.\n   this->define_builtin (BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n \t\t\tbuild_function_type (void_type_node, void_list_node),\n-<<<<<<< HEAD\n \t\t\tbuiltin_noreturn);\n-=======\n-\t\t\tfalse, true);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // The runtime uses __builtin_prefetch.\n   this->define_builtin (BUILT_IN_PREFETCH, \"__builtin_prefetch\", NULL,\n \t\t\tbuild_varargs_function_type_list (void_type_node,\n \t\t\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t\t\t  NULL_TREE),\n-<<<<<<< HEAD\n \t\t\tbuiltin_novops);\n-=======\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // The compiler uses __builtin_unreachable for cases that cannot\n   // occur.\n   this->define_builtin (BUILT_IN_UNREACHABLE, \"__builtin_unreachable\", NULL,\n \t\t\tbuild_function_type (void_type_node, void_list_node),\n-<<<<<<< HEAD\n \t\t\tbuiltin_const | builtin_noreturn);\n-=======\n-\t\t\ttrue, true);\n->>>>>>> 12e994a7967... Fix indentation\n \n   // We provide some atomic functions.\n   t = build_function_type_list (uint32_type_node, ptr_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n-<<<<<<< HEAD\n   this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t, 0);\n \n   t = build_function_type_list (uint64_type_node, ptr_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t, 0);\n-=======\n-  this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t,\n-\t\t\tfalse, false);\n-\n-  t = build_function_type_list (uint64_type_node, ptr_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t,\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (void_type_node, ptr_type_node, uint32_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\", NULL, t,\n-<<<<<<< HEAD\n \t\t\t0);\n-=======\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (void_type_node, ptr_type_node, uint64_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\", NULL, t,\n-<<<<<<< HEAD\n \t\t\t0);\n-=======\n-\t\t\tfalse, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (uint32_type_node, ptr_type_node,\n \t\t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_4, \"__atomic_exchange_4\", NULL,\n-<<<<<<< HEAD\n \t\t\tt, 0);\n-=======\n-\t\t\tt, false, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (uint64_type_node, ptr_type_node,\n \t\t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_8, \"__atomic_exchange_8\", NULL,\n-<<<<<<< HEAD\n \t\t\tt, 0);\n-=======\n-\t\t\tt, false, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (boolean_type_node, ptr_type_node, ptr_type_node,\n \t\t\t\tuint32_type_node, boolean_type_node,\n \t\t\t\tinteger_type_node, integer_type_node,\n \t\t\t\tNULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,\n-<<<<<<< HEAD\n \t\t\t\"__atomic_compare_exchange_4\", NULL, t, 0);\n-=======\n-\t\t\t\"__atomic_compare_exchange_4\", NULL, t, false, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (boolean_type_node, ptr_type_node, ptr_type_node,\n \t\t\t\tuint64_type_node, boolean_type_node,\n \t\t\t\tinteger_type_node, integer_type_node,\n \t\t\t\tNULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,\n-<<<<<<< HEAD\n \t\t\t\"__atomic_compare_exchange_8\", NULL, t, 0);\n-=======\n-\t\t\t\"__atomic_compare_exchange_8\", NULL, t, false, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (uint32_type_node, ptr_type_node,\n \t\t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_4, \"__atomic_add_fetch_4\",\n-<<<<<<< HEAD\n \t\t\tNULL, t, 0);\n-=======\n-\t\t\tNULL, t, false, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (uint64_type_node, ptr_type_node,\n \t\t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_8, \"__atomic_add_fetch_8\",\n-<<<<<<< HEAD\n \t\t\tNULL, t, 0);\n-=======\n-\t\t\tNULL, t, false, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n \t\t\t\tunsigned_char_type_node, integer_type_node,\n \t\t\t\tNULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_AND_FETCH_1, \"__atomic_and_fetch_1\",\n-<<<<<<< HEAD\n \t\t\tNULL, t, 0);\n   this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n \t\t\tNULL, t, 0);\n-=======\n-\t\t\tNULL, t, false, false);\n-  this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n-\t\t\tNULL, t, false, false);\n->>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n \t\t\t\tunsigned_char_type_node, integer_type_node,\n \t\t\t\tNULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\", NULL,\n-<<<<<<< HEAD\n \t\t\tt, 0);\n   this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\", NULL,\n \t\t\tt, 0);\n-=======\n-\t\t\tt, false, false);\n-  this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\", NULL,\n-\t\t\tt, false, false);\n->>>>>>> 12e994a7967... Fix indentation\n }\n \n // Get an unnamed integer type.\n@@ -1385,13 +1136,9 @@ Gcc_backend::named_type (const std::string &name, Btype *btype,\n   if (type == error_mark_node)\n     return this->error_type ();\n \n-  // The middle-end expects a basic type to have a name.  In Rust every\n+  // The middle-end expects a basic type to have a name.  In Go every\n   // basic type will have a name.  The first time we see a basic type,\n-<<<<<<< HEAD\n-  // give it whatever Rust name we have at this point.\n-=======\n   // give it whatever Go name we have at this point.\n->>>>>>> 12e994a7967... Fix indentation\n   if (TYPE_NAME (type) == NULL_TREE\n       && location.gcc_location () == BUILTINS_LOCATION\n       && (TREE_CODE (type) == INTEGER_TYPE || TREE_CODE (type) == REAL_TYPE\n@@ -1837,11 +1584,7 @@ Gcc_backend::unary_expression (Operator op, Bexpression *expr,\n   enum tree_code code;\n   switch (op)\n     {\n-<<<<<<< HEAD\n-      case OPERATOR_MINUS: {\n-=======\n       case OPERATOR_MINUS: {\n->>>>>>> 12e994a7967... Fix indentation\n \ttree computed_type = excess_precision_type (type_tree);\n \tif (computed_type != NULL_TREE)\n \t  {\n@@ -2173,13 +1916,8 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n   // This is to support builtin math functions when using 80387 math.\n   tree excess_type = NULL_TREE;\n   if (optimize && TREE_CODE (fndecl) == FUNCTION_DECL\n-<<<<<<< HEAD\n       && fndecl_built_in_p (fndecl, BUILT_IN_NORMAL)\n       && DECL_IS_UNDECLARED_BUILTIN (fndecl) && nargs > 0\n-=======\n-      && fndecl_built_in_p (fndecl, BUILT_IN_NORMAL) && DECL_IS_BUILTIN (fndecl)\n-      && nargs > 0\n->>>>>>> 12e994a7967... Fix indentation\n       && ((SCALAR_FLOAT_TYPE_P (rettype)\n \t   && SCALAR_FLOAT_TYPE_P (TREE_TYPE (args[0])))\n \t  || (COMPLEX_FLOAT_TYPE_P (rettype)\n@@ -2682,19 +2420,11 @@ Gcc_backend::non_zero_size_type (tree type)\n \t  DECL_CONTEXT (field) = type;\n \t  TYPE_FIELDS (type) = field;\n \t  layout_type (type);\n-<<<<<<< HEAD\n \t  rust_non_zero_struct = type;\n-=======\n-\t  go_non_zero_struct = type;\n->>>>>>> 12e994a7967... Fix indentation\n \t}\n       return rust_non_zero_struct;\n \n-<<<<<<< HEAD\n-      case ARRAY_TYPE: {\n-=======\n       case ARRAY_TYPE: {\n->>>>>>> 12e994a7967... Fix indentation\n \ttree element_type = non_zero_size_type (TREE_TYPE (type));\n \treturn build_array_type_nelts (element_type, 1);\n       }\n@@ -2802,11 +2532,7 @@ Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n   if (symtab_node::get (var_decl)\n       && symtab_node::get (var_decl)->implicit_section)\n     {\n-<<<<<<< HEAD\n       set_decl_section_name (var_decl, (const char *) NULL);\n-=======\n-      set_decl_section_name (var_decl, NULL);\n->>>>>>> 12e994a7967... Fix indentation\n       resolve_unique_section (var_decl, compute_reloc_for_constant (expr_tree),\n \t\t\t      1);\n     }\n@@ -2921,22 +2647,14 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n       else\n \tpush_cfun (DECL_STRUCT_FUNCTION (decl));\n \n-<<<<<<< HEAD\n       var = create_tmp_var (type_tree, \"RUSTTMP\");\n-=======\n-      var = create_tmp_var (type_tree, \"GOTMP\");\n->>>>>>> 12e994a7967... Fix indentation\n       pop_cfun ();\n     }\n   else\n     {\n       gcc_assert (bblock != NULL);\n       var = build_decl (location.gcc_location (), VAR_DECL,\n-<<<<<<< HEAD\n \t\t\tcreate_tmp_var_name (\"RUSTTMP\"), type_tree);\n-=======\n-\t\t\tcreate_tmp_var_name (\"GOTMP\"), type_tree);\n->>>>>>> 12e994a7967... Fix indentation\n       DECL_ARTIFICIAL (var) = 1;\n       DECL_IGNORED_P (var) = 1;\n       TREE_USED (var) = 1;\n@@ -3330,24 +3048,15 @@ Gcc_backend::function (Btype *fntype, const std::string &name,\n       if (pos == name.length ())\n \t{\n \t  struct cl_optimization cur_opts;\n-<<<<<<< HEAD\n \t  cl_optimization_save (&cur_opts, &global_options,\n \t\t\t\t&global_options_set);\n-=======\n-\t  cl_optimization_save (&cur_opts, &global_options);\n->>>>>>> 12e994a7967... Fix indentation\n \t  global_options.x_optimize_size = 1;\n \t  global_options.x_optimize_fast = 0;\n \t  global_options.x_optimize_debug = 0;\n \t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl)\n-<<<<<<< HEAD\n \t    = build_optimization_node (&global_options, &global_options_set);\n \t  cl_optimization_restore (&global_options, &global_options_set,\n \t\t\t\t   &cur_opts);\n-=======\n-\t    = build_optimization_node (&global_options);\n-\t  cl_optimization_restore (&global_options, &cur_opts);\n->>>>>>> 12e994a7967... Fix indentation\n \t}\n     }\n "}, {"sha": "91c77bceff46e1f6641edf9cc7eb77431fa65126", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=9fec18623e1a937863f86cc25fa855e65e91d473", "patch": "@@ -155,7 +155,6 @@ grs_langhook_parse_file (void)\n {\n   fprintf (stderr, \"Preparing to parse files. \\n\");\n \n-  // grs_parse_files(num_in_fnames, in_fnames);\n   session.parse_files (num_in_fnames, in_fnames);\n }\n \n@@ -183,7 +182,7 @@ grs_langhook_type_for_mode (machine_mode mode, int unsignedp)\n     return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n   if (mode\n       == TYPE_MODE (\n-\t   intDI_type_node)) // double integer mode - eight-byte integer\n+\tintDI_type_node)) // double integer mode - eight-byte integer\n     return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n   if (mode\n       == TYPE_MODE (intTI_type_node)) // tetra integer mode - 16-byte integer"}, {"sha": "1e49271995c907e23b021189e99727176b5d654f", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=9fec18623e1a937863f86cc25fa855e65e91d473", "patch": "@@ -10,6 +10,7 @@\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n #include \"rust-resolution.h\"\n+#include \"rust-compile.h\"\n \n #include \"rust-target.h\"\n \n@@ -18,6 +19,9 @@\n extern Linemap *\n rust_get_linemap ();\n \n+extern Backend *\n+rust_get_backend ();\n+\n namespace Rust {\n // Simple wrapper for FILE* that simplifies destruction.\n struct RAIIFile\n@@ -410,6 +414,8 @@ Session::parse_file (const char *filename)\n       fatal_error (UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n     }\n \n+  Backend *backend = rust_get_backend ();\n+\n   // parse file here\n   // create lexer and parser - these are file-specific and so aren't instance\n   // variables\n@@ -487,6 +493,9 @@ Session::parse_file (const char *filename)\n       // TODO: what do I dump here? resolved names? AST with resolved names?\n       return;\n     }\n+\n+  // do compile\n+  Compile::Compilation::Compile (parsed_crate, backend);\n }\n \n // Checks whether 'cfg' attribute prevents compilation."}, {"sha": "2352267092a6e36831b793a1a13fb29dcbe5e7b6", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 214, "deletions": 179, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fec18623e1a937863f86cc25fa855e65e91d473/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=9fec18623e1a937863f86cc25fa855e65e91d473", "patch": "@@ -9,7 +9,7 @@\n #include \"rust-system.h\"\n \n #include \"rust-linemap.h\"\n-#include \"backend.h\"\n+#include \"rust-backend.h\"\n \n #include <string>\n #include <unordered_map>\n@@ -18,184 +18,219 @@\n #include <utility>\n \n namespace Rust {\n-    // parser forward decl\n-    class Parser;\n-    // crate forward decl\n-    namespace AST {\n-        struct Crate;\n-    }\n-\n-    // Data related to target, most useful for conditional compilation and whatever.\n-    struct TargetOptions {\n-        // TODO: maybe make private and access through helpers to allow changes to impl\n-        std::unordered_map<std::string, std::unordered_set<std::string>> features;\n-\n-      public:\n-        // Returns whether a key is defined in the feature set.\n-        bool has_key(std::string key) const {\n-            return features.find(key) != features.end();\n-        }\n-\n-        // Returns whether a key exists with the given value in the feature set.\n-        bool has_key_value_pair(std::string key, std::string value) const {\n-            auto it = features.find(key);\n-            if (it != features.end()) {\n-                auto set = it->second;\n-                auto it2 = set.find(value);\n-                if (it2 != set.end())\n-                    return true;\n-            }\n-            return false;\n-        }\n-\n-        // Returns the singular value from the key, or if the key has multiple, an empty string.\n-        std::string get_singular_value(std::string key) const {\n-            auto it = features.find(key);\n-            if (it != features.end()) {\n-                auto set = it->second;\n-                if (set.size() == 1)\n-                    return *set.begin();\n-            }\n-            return \"\";\n-        }\n-\n-        // Returns all values associated with a key (including none), or an empty set if no key is found.\n-        std::unordered_set< ::std::string> get_values_for_key(std::string key) const {\n-            auto it = features.find(key);\n-            if (it != features.end()) {\n-                return it->second;\n-            }\n-            return {};\n-        }\n-\n-        /* Inserts a key (no value) into the feature set. This will do nothing if the key already exists. \n-         * This returns whether the insertion was successful (i.e. whether key already existed). */\n-        bool insert_key(std::string key) {\n-            return features.insert(std::make_pair(key, std::unordered_set<std::string>())).second;\n-        }\n-\n-        // Inserts a key-value pair into the feature set. \n-        void insert_key_value_pair(std::string key, std::string value) {\n-            auto existing_set = get_values_for_key(key);\n-            existing_set.insert(std::move(value));\n-            features[std::move(key)] = std::move(existing_set);\n-        }\n-\n-        // Dump all target options to stderr.\n-        void dump_target_options() const; \n-\n-        // Creates derived values and implicit enables after all target info is added (e.g. \"unix\").\n-        void init_derived_values();\n-\n-        // Enables all requirements for the feature given, and will enable feature itself if not enabled.\n-        void enable_implicit_feature_reqs(std::string feature);\n-\n-        /* According to reference, Rust uses either multi-map key-values or just values (although\n-         * values may be aliases for a key-value value). This seems like overkill. Thus, depending on\n-         * whether the attributes used in cfg are fixed or not, I think I'll either put each\n-         * non-multimap \"key-value\" as a separate field and have the multimap \"key-values\" in a\n-         * regular map for that one key, or actually use a multimap.\n-         *\n-         * rustc itself uses a set of key-value tuples where the second tuple element is optional.\n-         * This gets rid of the requirement to make a multi-map, I guess, but seems like it might make\n-         * search slow (unless all \"is defined\"-only ones have empty string as second element). */\n-        /* cfg attributes:\n-         * - target_arch: single value\n-         * - target_feature: multiple values possible\n-         * - target_os: single value\n-         * - target_family: single value (or no value?)\n-         * - unix: set when target_family = \"unix\"\n-         * - windows: set when target_family = \"windows\"\n-         *  - if these are just syntactic sugar, then maybe have a separate set or map for this kind\n-         * of stuff\n-         * - target_env: set when needed for disambiguation about ABI - usually empty string for GNU,\n-         * complicated\n-         *  - seems to be a single value (if any)\n-         * - target_endian: single value; \"little\" or \"big\"\n-         * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n-         * - target_vendor, single value\n-         * - test: set when testing is being done\n-         *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like unix\n-         * - debug_assertions: seems to \"is defined\"\n-         * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is defined\" */\n-    };\n-\n-    // Defines compiler options (e.g. dump, etc.).\n-    struct CompileOptions {\n-        // TODO: use bitfield for smaller memory requirements?\n-\n-        // FIXME: this is set up for \"instead of\" dumping - in future, dumps should not inhibit\n-        // compilation\n-        enum DumpOptions {\n-            NO_DUMP,\n-            LEXER_DUMP,\n-            PARSER_AST_DUMP,\n-            REGISTER_PLUGINS_DUMP,\n-            INJECTION_DUMP,\n-            EXPANSION_DUMP,\n-            NAME_RESOLUTION_DUMP,\n-            TARGET_OPTION_DUMP,\n-            // TODO: add more?\n-        } dump_option;\n-\n-        // configuration options - actually useful for conditional compilation and whatever\n-        // data related to target arch, features, os, family, env, endian, pointer width, vendor\n-        TargetOptions target_data;\n-        bool enable_test = false;\n-        bool debug_assertions = false;\n-        bool proc_macro = false;\n-    };\n-\n-    /* Defines a compiler session. This is for a single compiler invocation, so potentially includes\n-     * parsing multiple crates. */\n-    struct Session {\n-        CompileOptions options;\n-        // This should really be in a per-crate storage area but it is wiped with every file so eh.\n-        ::std::string injected_crate_name;\n-\n-        // backend wrapper to GCC GENERIC\n-        Backend* backend;\n-\n-        // backend linemap\n-        Linemap* linemap;\n-\n-        // TODO: replace raw pointers with smart pointers?\n-\n-      public:\n-        /* Initialise compiler session. Corresponds to langhook grs_langhook_init(). Note that this is\n-         * called after option handling. */\n-        void init();\n-        bool handle_option(enum opt_code code, const char* arg, HOST_WIDE_INT value, int kind,\n-          location_t loc, const struct cl_option_handlers* handlers);\n-        void parse_files(int num_files, const char** files);\n-        void init_options();\n-\n-      private:\n-        // TODO: should this be private or public?\n-        void parse_file(const char* filename);\n-        bool enable_dump(::std::string arg);\n-\n-        void debug_dump_load_crates(Parser& parser);\n-\n-        void implicitly_enable_feature(::std::string feature_name);\n-        void enable_features();\n-\n-        // pipeline stages - TODO maybe move?\n-        /* Register plugins pipeline stage. TODO maybe move to another object? Currently dummy stage.\n-         * In future will handle attribute injection (top-level inner attribute creation from command\n-         * line arguments), setting options maybe, registering lints maybe, loading plugins maybe. */\n-        void register_plugins(AST::Crate& crate);\n-        /* Injection pipeline stage. TODO maybe move to another object? Maybe have some lint checks\n-         * (in future, obviously), register builtin macros, crate injection. */\n-        void injection(AST::Crate& crate);\n-        /* Expansion pipeline stage. TODO maybe move to another object? Expands all macros, maybe\n-         * build test harness in future, AST validation, maybe create macro crate (if not rustdoc).*/\n-        void expansion(AST::Crate& crate);\n-        /* Name resolution pipeline stage. TODO maybe move to another object. Performs name\n-         * resolution, maybe complete gated feature checking, maybe create buffered lints in future.\n-         */\n-        void name_resolution(AST::Crate& crate);\n-    };\n+// parser forward decl\n+class Parser;\n+// crate forward decl\n+namespace AST {\n+struct Crate;\n }\n \n+// Data related to target, most useful for conditional compilation and\n+// whatever.\n+struct TargetOptions\n+{\n+  // TODO: maybe make private and access through helpers to allow changes to\n+  // impl\n+  std::unordered_map<std::string, std::unordered_set<std::string> > features;\n+\n+public:\n+  // Returns whether a key is defined in the feature set.\n+  bool has_key (std::string key) const\n+  {\n+    return features.find (key) != features.end ();\n+  }\n+\n+  // Returns whether a key exists with the given value in the feature set.\n+  bool has_key_value_pair (std::string key, std::string value) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      {\n+\tauto set = it->second;\n+\tauto it2 = set.find (value);\n+\tif (it2 != set.end ())\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n+  // Returns the singular value from the key, or if the key has multiple, an\n+  // empty string.\n+  std::string get_singular_value (std::string key) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      {\n+\tauto set = it->second;\n+\tif (set.size () == 1)\n+\t  return *set.begin ();\n+      }\n+    return \"\";\n+  }\n+\n+  // Returns all values associated with a key (including none), or an empty set\n+  // if no key is found.\n+  std::unordered_set< ::std::string> get_values_for_key (std::string key) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      {\n+\treturn it->second;\n+      }\n+    return {};\n+  }\n+\n+  /* Inserts a key (no value) into the feature set. This will do nothing if the\n+   * key already exists.\n+   * This returns whether the insertion was successful (i.e. whether key already\n+   * existed). */\n+  bool insert_key (std::string key)\n+  {\n+    return features\n+      .insert (std::make_pair (key, std::unordered_set<std::string> ()))\n+      .second;\n+  }\n+\n+  // Inserts a key-value pair into the feature set.\n+  void insert_key_value_pair (std::string key, std::string value)\n+  {\n+    auto existing_set = get_values_for_key (key);\n+    existing_set.insert (std::move (value));\n+    features[std::move (key)] = std::move (existing_set);\n+  }\n+\n+  // Dump all target options to stderr.\n+  void dump_target_options () const;\n+\n+  // Creates derived values and implicit enables after all target info is added\n+  // (e.g. \"unix\").\n+  void init_derived_values ();\n+\n+  // Enables all requirements for the feature given, and will enable feature\n+  // itself if not enabled.\n+  void enable_implicit_feature_reqs (std::string feature);\n+\n+  /* According to reference, Rust uses either multi-map key-values or just\n+   * values (although values may be aliases for a key-value value). This seems\n+   * like overkill. Thus, depending on whether the attributes used in cfg are\n+   * fixed or not, I think I'll either put each non-multimap \"key-value\" as a\n+   * separate field and have the multimap \"key-values\" in a regular map for that\n+   * one key, or actually use a multimap.\n+   *\n+   * rustc itself uses a set of key-value tuples where the second tuple element\n+   * is optional. This gets rid of the requirement to make a multi-map, I guess,\n+   * but seems like it might make\n+   * search slow (unless all \"is defined\"-only ones have empty string as second\n+   * element). */\n+  /* cfg attributes:\n+   * - target_arch: single value\n+   * - target_feature: multiple values possible\n+   * - target_os: single value\n+   * - target_family: single value (or no value?)\n+   * - unix: set when target_family = \"unix\"\n+   * - windows: set when target_family = \"windows\"\n+   *  - if these are just syntactic sugar, then maybe have a separate set or map\n+   * for this kind of stuff\n+   * - target_env: set when needed for disambiguation about ABI - usually empty\n+   * string for GNU, complicated\n+   *  - seems to be a single value (if any)\n+   * - target_endian: single value; \"little\" or \"big\"\n+   * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n+   * - target_vendor, single value\n+   * - test: set when testing is being done\n+   *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like\n+   * unix\n+   * - debug_assertions: seems to \"is defined\"\n+   * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is defined\"\n+   */\n+};\n+\n+// Defines compiler options (e.g. dump, etc.).\n+struct CompileOptions\n+{\n+  // TODO: use bitfield for smaller memory requirements?\n+\n+  // FIXME: this is set up for \"instead of\" dumping - in future, dumps should\n+  // not inhibit compilation\n+  enum DumpOptions\n+  {\n+    NO_DUMP,\n+    LEXER_DUMP,\n+    PARSER_AST_DUMP,\n+    REGISTER_PLUGINS_DUMP,\n+    INJECTION_DUMP,\n+    EXPANSION_DUMP,\n+    NAME_RESOLUTION_DUMP,\n+    TARGET_OPTION_DUMP,\n+    // TODO: add more?\n+  } dump_option;\n+\n+  // configuration options - actually useful for conditional compilation and\n+  // whatever data related to target arch, features, os, family, env, endian,\n+  // pointer width, vendor\n+  TargetOptions target_data;\n+  bool enable_test = false;\n+  bool debug_assertions = false;\n+  bool proc_macro = false;\n+};\n+\n+/* Defines a compiler session. This is for a single compiler invocation, so\n+ * potentially includes parsing multiple crates. */\n+struct Session\n+{\n+  CompileOptions options;\n+  // This should really be in a per-crate storage area but it is wiped with\n+  // every file so eh.\n+  ::std::string injected_crate_name;\n+\n+  // backend wrapper to GCC GENERIC\n+  Backend *backend;\n+\n+  // backend linemap\n+  Linemap *linemap;\n+\n+  // TODO: replace raw pointers with smart pointers?\n+\n+public:\n+  /* Initialise compiler session. Corresponds to langhook grs_langhook_init().\n+   * Note that this is called after option handling. */\n+  void init ();\n+  bool handle_option (enum opt_code code, const char *arg, HOST_WIDE_INT value,\n+\t\t      int kind, location_t loc,\n+\t\t      const struct cl_option_handlers *handlers);\n+  void parse_files (int num_files, const char **files);\n+  void init_options ();\n+\n+private:\n+  // TODO: should this be private or public?\n+  void parse_file (const char *filename);\n+  bool enable_dump (::std::string arg);\n+\n+  void debug_dump_load_crates (Parser &parser);\n+\n+  void implicitly_enable_feature (::std::string feature_name);\n+  void enable_features ();\n+\n+  // pipeline stages - TODO maybe move?\n+  /* Register plugins pipeline stage. TODO maybe move to another object?\n+   * Currently dummy stage. In future will handle attribute injection (top-level\n+   * inner attribute creation from command line arguments), setting options\n+   * maybe, registering lints maybe, loading plugins maybe. */\n+  void register_plugins (AST::Crate &crate);\n+  /* Injection pipeline stage. TODO maybe move to another object? Maybe have\n+   * some lint checks (in future, obviously), register builtin macros, crate\n+   * injection. */\n+  void injection (AST::Crate &crate);\n+  /* Expansion pipeline stage. TODO maybe move to another object? Expands all\n+   * macros, maybe build test harness in future, AST validation, maybe create\n+   * macro crate (if not rustdoc).*/\n+  void expansion (AST::Crate &crate);\n+  /* Name resolution pipeline stage. TODO maybe move to another object. Performs\n+   * name resolution, maybe complete gated feature checking, maybe create\n+   * buffered lints in future.\n+   */\n+  void name_resolution (AST::Crate &crate);\n+};\n+} // namespace Rust\n+\n #endif"}]}