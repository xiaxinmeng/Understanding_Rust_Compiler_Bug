{"sha": "bd544141e09187ded0b02cac4ee5ce56ca38622c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ1NDQxNDFlMDkxODdkZWQwYjAyY2FjNGVlNWNlNTZjYTM4NjIyYw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-08-24T23:35:48Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-08-24T23:35:48Z"}, "message": "Add flag -ftree-loop-if-convert-stores.\n\nThis patch adds a flag that controls the replacement of the memory\nwrites that are in predicated basic blocks with a full write:\n\nfor (...)\n  if (cond)\n    A[i] = foo\n\nis replaced with:\n\nfor (...)\n  A[i] = cond ? foo : A[i]\n\nIn order to do this, we have to call gimple_could_trap_p instead of\ngimple_assign_rhs_could_trap_p, as we have to also check that the LHS\nof assign stmts does not trap.\n\n\t* common.opt (ftree-loop-if-convert-stores): New flag.\n\t* doc/invoke.texi (ftree-loop-if-convert-stores): Documented.\n\t* tree-if-conv.c (ifc_temp_var): Pass an extra parameter GSI.  Insert\n\tthe created statement before GSI.\n\t(if_convertible_phi_p): Allow virtual phi nodes when\n\tflag_loop_if_convert_stores is set.\n\t(if_convertible_gimple_assign_stmt_p): Allow memory reads and writes\n\tDo not handle types that do not match is_gimple_reg_type.\n\tRemove loop and bb parameters.  Call gimple_could_trap_p instead of\n\twhen flag_loop_if_convert_stores is set, as LHS can contain\n\tmemory refs.\n\t(if_convertible_stmt_p): Remove loop and bb parameters.  Update calls\n\tto if_convertible_gimple_assign_stmt_p.\n\t(if_convertible_loop_p): Update call to if_convertible_stmt_p.\n\t(replace_phi_with_cond_gimple_assign_stmt): Renamed\n\tpredicate_scalar_phi.  Do not handle virtual phi nodes.\n\t(ifconvert_phi_nodes): Renamed predicate_all_scalar_phis.\n\tCall predicate_scalar_phi.\n\t(insert_gimplified_predicates): Insert the gimplified predicate of a BB\n\tjust after the labels for flag_loop_if_convert_stores, otherwise\n\tinsert the predicate in the end of the BB.\n\t(predicate_mem_writes): New.\n\t(combine_blocks): Call predicate_all_scalar_phis.  When\n\tflag_loop_if_convert_stores is set, call predicate_mem_writes.\n\t(tree_if_conversion): Call mark_sym_for_renaming when\n\tflag_loop_if_convert_stores is set.\n\t(main_tree_if_conversion): Return TODO_update_ssa_only_virtuals when\n\tflag_loop_if_convert_stores is set.\n\n\t* gcc.dg/tree-ssa/ifc-4.c: New.\n\t* gcc.dg/tree-ssa/ifc-7.c: New.\n\nFrom-SVN: r163530", "tree": {"sha": "98e3e8412290ce628f63d66548ba9b9cdb10c1ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98e3e8412290ce628f63d66548ba9b9cdb10c1ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd544141e09187ded0b02cac4ee5ce56ca38622c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd544141e09187ded0b02cac4ee5ce56ca38622c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd544141e09187ded0b02cac4ee5ce56ca38622c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd544141e09187ded0b02cac4ee5ce56ca38622c/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a9abc98c235676b9268f9bce3ee37a50266557d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9abc98c235676b9268f9bce3ee37a50266557d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a9abc98c235676b9268f9bce3ee37a50266557d"}], "stats": {"total": 444, "additions": 389, "deletions": 55}, "files": [{"sha": "b092e5715c113e78ba64ead03469b3e9b7b2a9af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd544141e09187ded0b02cac4ee5ce56ca38622c", "patch": "@@ -1,3 +1,34 @@\n+2010-08-24  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* common.opt (ftree-loop-if-convert-stores): New flag.\n+\t* doc/invoke.texi (ftree-loop-if-convert-stores): Documented.\n+\t* tree-if-conv.c (ifc_temp_var): Pass an extra parameter GSI.  Insert\n+\tthe created statement before GSI.\n+\t(if_convertible_phi_p): Allow virtual phi nodes when\n+\tflag_loop_if_convert_stores is set.\n+\t(if_convertible_gimple_assign_stmt_p): Allow memory reads and writes\n+\tDo not handle types that do not match is_gimple_reg_type.\n+\tRemove loop and bb parameters.  Call gimple_could_trap_p instead of\n+\twhen flag_loop_if_convert_stores is set, as LHS can contain\n+\tmemory refs.\n+\t(if_convertible_stmt_p): Remove loop and bb parameters.  Update calls\n+\tto if_convertible_gimple_assign_stmt_p.\n+\t(if_convertible_loop_p): Update call to if_convertible_stmt_p.\n+\t(replace_phi_with_cond_gimple_assign_stmt): Renamed\n+\tpredicate_scalar_phi.  Do not handle virtual phi nodes.\n+\t(ifconvert_phi_nodes): Renamed predicate_all_scalar_phis.\n+\tCall predicate_scalar_phi.\n+\t(insert_gimplified_predicates): Insert the gimplified predicate of a BB\n+\tjust after the labels for flag_loop_if_convert_stores, otherwise\n+\tinsert the predicate in the end of the BB.\n+\t(predicate_mem_writes): New.\n+\t(combine_blocks): Call predicate_all_scalar_phis.  When\n+\tflag_loop_if_convert_stores is set, call predicate_mem_writes.\n+\t(tree_if_conversion): Call mark_sym_for_renaming when\n+\tflag_loop_if_convert_stores is set.\n+\t(main_tree_if_conversion): Return TODO_update_ssa_only_virtuals when\n+\tflag_loop_if_convert_stores is set.\n+\n 2010-08-24  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/pa/pa.c (hppa_register_move_cost, pa_libcall_value,"}, {"sha": "675ca353cf0d83b024778f4d53ddce4b7c1bdb9f", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=bd544141e09187ded0b02cac4ee5ce56ca38622c", "patch": "@@ -712,6 +712,10 @@ ftree-loop-if-convert\n Common Report Var(flag_tree_loop_if_convert) Init(-1) Optimization\n Convert conditional jumps in innermost loops to branchless equivalents\n \n+ftree-loop-if-convert-stores\n+Common Report Var(flag_tree_loop_if_convert_stores) Optimization\n+Also if-convert conditional jumps containing memory writes\n+\n ; -finhibit-size-directive inhibits output of .size for ELF.\n ; This is used only for compiling crtstuff.c,\n ; and it may be extended to other effects"}, {"sha": "7e069f09e719b069fa6c4c72f23ede7222833620", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bd544141e09187ded0b02cac4ee5ce56ca38622c", "patch": "@@ -383,7 +383,8 @@ Objective-C and Objective-C++ Dialects}.\n -fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer -ftree-bit-ccp @gol\n -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-copy-prop @gol\n -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse @gol\n--ftree-forwprop -ftree-fre -ftree-loop-if-convert -ftree-loop-im @gol\n+-ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol\n+-ftree-loop-if-convert-memory-writes -ftree-loop-im @gol\n -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-pta -ftree-reassoc @gol\n@@ -6931,6 +6932,23 @@ the innermost loops in order to improve the ability of the\n vectorization pass to handle these loops.  This is enabled by default\n if vectorization is enabled.\n \n+@item -ftree-loop-if-convert-stores\n+Attempt to also if-convert conditional jumps containing memory writes.\n+This transformation can be unsafe for multi-threaded programs as it\n+transforms conditional memory writes into unconditional memory writes.\n+For example,\n+@smallexample\n+for (i = 0; i < N; i++)\n+  if (cond)\n+    A[i] = expr;\n+@end smallexample\n+would be transformed to\n+@smallexample\n+for (i = 0; i < N; i++)\n+  A[i] = cond ? expr : A[i];\n+@end smallexample\n+potentially producing data races.\n+\n @item -ftree-loop-distribution\n Perform loop distribution.  This flag can improve cache performance on\n big loop bodies and allow further loop optimizations, like"}, {"sha": "22ca79d81eba4e8f4bc6f83b11b92bf4ca7499b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bd544141e09187ded0b02cac4ee5ce56ca38622c", "patch": "@@ -1,3 +1,8 @@\n+2010-08-24  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* gcc.dg/tree-ssa/ifc-4.c: New.\n+\t* gcc.dg/tree-ssa/ifc-7.c: New.\n+\n 2010-08-24  Mingjie Xing  <mingjie.xing@gmail.com>\n \n \t* gcc.dg/vect/vect.exp: Check loongson targets"}, {"sha": "beb1a0e6071f2e8a90f480ecdd9cf67feac81fb9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-4.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-4.c?ref=bd544141e09187ded0b02cac4ee5ce56ca38622c", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-c -O2 -ftree-vectorize -fdump-tree-ifcvt-stats\" { target *-*-* } } */\n+\n+struct ht\n+{\n+  void * (*alloc_subobject) (int);\n+};\n+typedef struct cpp_reader cpp_reader;\n+typedef struct cpp_token cpp_token;\n+typedef struct cpp_macro cpp_macro;\n+enum cpp_ttype\n+{\n+    CPP_PASTE,\n+};\n+struct cpp_token {\n+  __extension__ enum cpp_ttype type : 8;\n+} cpp_comment_table;\n+struct cpp_macro {\n+  union cpp_macro_u\n+  {\n+    cpp_token * tokens;\n+  } exp;\n+  unsigned int count;\n+};\n+struct cpp_reader\n+{\n+  struct ht *hash_table;\n+};\n+create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n+{\n+  unsigned int num_extra_tokens = 0;\n+  {\n+    cpp_token *tokns =\n+      (cpp_token *) pfile->hash_table->alloc_subobject (sizeof (cpp_token)\n+\t\t\t\t\t\t\t* macro->count);\n+    {\n+      cpp_token *normal_dest = tokns;\n+      cpp_token *extra_dest = tokns + macro->count - num_extra_tokens;\n+      unsigned int i;\n+      for (i = 0; i < macro->count; i++)\n+\t{\n+\t  if (macro->exp.tokens[i].type == CPP_PASTE)\n+\t    *extra_dest++ = macro->exp.tokens[i];\n+\t  else\n+\t    *normal_dest++ = macro->exp.tokens[i];\n+\t}\n+    }\n+  }\n+}\n+\n+/* This cannot be if-converted because the stores are to aggregate types.  */\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 0 \"ifcvt\" } } */\n+/* { dg-final { cleanup-tree-dump \"ifcvt\" } } */"}, {"sha": "4d26dc7650d595991bb3d2b82e8396f66a92928f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-7.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-7.c?ref=bd544141e09187ded0b02cac4ee5ce56ca38622c", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-c -O2 -ftree-vectorize\" { target *-*-* } } */\n+\n+typedef struct eqn_d\n+{\n+  int *coef;\n+} *eqn;\n+typedef struct omega_pb_d\n+{\n+  eqn subs;\n+} *omega_pb;\n+\n+omega_pb omega_solve_problem (omega_pb);\n+\n+omega_pb\n+omega_solve_geq (omega_pb pb, int n)\n+{\n+  int i, e;\n+  int j = 0;\n+\n+  for (e = n - 1; e >= 0; e--)\n+    if (pb->subs[e].coef[i] != pb->subs[e].coef[j])\n+      {\n+\tpb->subs[e].coef[i] = j;\n+\tpb->subs[e].coef[j] = i;\n+      }\n+\n+  return omega_solve_problem (pb);\n+}"}, {"sha": "ac60cef1e609d7bc50c3781b2e713b10241c2e3e", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 248, "deletions": 54, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd544141e09187ded0b02cac4ee5ce56ca38622c/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=bd544141e09187ded0b02cac4ee5ce56ca38622c", "patch": "@@ -213,11 +213,13 @@ reset_bb_predicate (basic_block bb)\n   init_bb_predicate (bb);\n }\n \n-/* Create a new temp variable of type TYPE.  Add GIMPLE_ASSIGN to assign EXP\n-   to the new variable.  */\n+/* Returns a new SSA_NAME of type TYPE that is assigned the value of\n+   the expression EXPR.  Inserts the statement created for this\n+   computation before GSI and leaves the iterator GSI at the same\n+   statement.  */\n \n-static gimple\n-ifc_temp_var (tree type, tree exp)\n+static tree\n+ifc_temp_var (tree type, tree expr, gimple_stmt_iterator *gsi)\n {\n   const char *name = \"_ifc_\";\n   tree var, new_name;\n@@ -227,8 +229,8 @@ ifc_temp_var (tree type, tree exp)\n   var = create_tmp_var (type, name);\n   add_referenced_var (var);\n \n-  /* Build new statement to assign EXP to new variable.  */\n-  stmt = gimple_build_assign (var, exp);\n+  /* Build new statement to assign EXPR to new variable.  */\n+  stmt = gimple_build_assign (var, expr);\n \n   /* Get SSA name for the new variable and set make new statement\n      its definition statement.  */\n@@ -237,7 +239,8 @@ ifc_temp_var (tree type, tree exp)\n   SSA_NAME_DEF_STMT (new_name) = stmt;\n   update_stmt (stmt);\n \n-  return stmt;\n+  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+  return gimple_assign_lhs (stmt);\n }\n \n /* Return true when COND is a true predicate.  */\n@@ -388,9 +391,12 @@ bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n    and it belongs to basic block BB.\n \n    PHI is not if-convertible if:\n-   - it has more than 2 arguments,\n-   - virtual PHI is immediately used in another PHI node,\n-   - virtual PHI on BB other than header.  */\n+   - it has more than 2 arguments.\n+\n+   When the flag_tree_loop_if_convert_stores is not set, PHI is not\n+   if-convertible if:\n+   - a virtual PHI is immediately used in another PHI node,\n+   - there is a virtual PHI in a BB other than the loop->header.  */\n \n static bool\n if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n@@ -408,6 +414,12 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n       return false;\n     }\n \n+  if (flag_tree_loop_if_convert_stores)\n+    return true;\n+\n+  /* When the flag_tree_loop_if_convert_stores is not set, check\n+     that there are no memory writes in the branches of the loop to be\n+     if-converted.  */\n   if (!is_gimple_reg (SSA_NAME_VAR (gimple_phi_result (phi))))\n     {\n       imm_use_iterator imm_iter;\n@@ -416,9 +428,10 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n       if (bb != loop->header)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Virtual phi not on loop header.\\n\");\n+\t    fprintf (dump_file, \"Virtual phi not on loop->header.\\n\");\n \t  return false;\n \t}\n+\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_phi_result (phi))\n \t{\n \t  if (gimple_code (USE_STMT (use_p)) == GIMPLE_PHI)\n@@ -438,22 +451,23 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n    GIMPLE_ASSIGN statement is not if-convertible if,\n    - it is not movable,\n    - it could trap,\n-   - LHS is not var decl.\n-\n-   GIMPLE_ASSIGN is part of block BB, which is inside loop LOOP.  */\n+   - LHS is not var decl.  */\n \n static bool\n-if_convertible_gimple_assign_stmt_p (struct loop *loop, basic_block bb,\n-    \t\t\t\t     gimple stmt)\n+if_convertible_gimple_assign_stmt_p (gimple stmt)\n {\n   tree lhs = gimple_assign_lhs (stmt);\n+  basic_block bb;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"-------------------------\\n\");\n       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n     }\n \n+  if (!is_gimple_reg_type (TREE_TYPE (lhs)))\n+    return false;\n+\n   /* Some of these constrains might be too conservative.  */\n   if (stmt_ends_bb_p (stmt)\n       || gimple_has_volatile_ops (stmt)\n@@ -466,16 +480,29 @@ if_convertible_gimple_assign_stmt_p (struct loop *loop, basic_block bb,\n       return false;\n     }\n \n+  if (flag_tree_loop_if_convert_stores)\n+    {\n+      if (gimple_could_trap_p (stmt))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"tree could trap...\\n\");\n+\t  return false;\n+\t}\n+      return true;\n+    }\n+\n   if (gimple_assign_rhs_could_trap_p (stmt))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"tree could trap...\\n\");\n       return false;\n     }\n \n+  bb = gimple_bb (stmt);\n+\n   if (TREE_CODE (lhs) != SSA_NAME\n-      && bb != loop->header\n-      && !bb_with_exit_edge_p (loop, bb))\n+      && bb != bb->loop_father->header\n+      && !bb_with_exit_edge_p (bb->loop_father, bb))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -492,12 +519,10 @@ if_convertible_gimple_assign_stmt_p (struct loop *loop, basic_block bb,\n \n    A statement is if-convertible if:\n    - it is an if-convertible GIMPLE_ASSGIN,\n-   - it is a GIMPLE_LABEL or a GIMPLE_COND.\n-\n-   STMT is inside BB, which is inside loop LOOP.  */\n+   - it is a GIMPLE_LABEL or a GIMPLE_COND.  */\n \n static bool\n-if_convertible_stmt_p (struct loop *loop, basic_block bb, gimple stmt)\n+if_convertible_stmt_p (gimple stmt)\n {\n   switch (gimple_code (stmt))\n     {\n@@ -507,7 +532,7 @@ if_convertible_stmt_p (struct loop *loop, basic_block bb, gimple stmt)\n       return true;\n \n     case GIMPLE_ASSIGN:\n-      return if_convertible_gimple_assign_stmt_p (loop, bb, stmt);\n+      return if_convertible_gimple_assign_stmt_p (stmt);\n \n     default:\n       /* Don't know what to do with 'em so don't do anything.  */\n@@ -878,7 +903,7 @@ if_convertible_loop_p (struct loop *loop)\n \tcontinue;\n \n       for (itr = gsi_start_bb (bb); !gsi_end_p (itr); gsi_next (&itr))\n-\tif (!if_convertible_stmt_p (loop, bb, gsi_stmt (itr)))\n+\tif (!if_convertible_stmt_p (gsi_stmt (itr)))\n \t  return false;\n     }\n \n@@ -898,7 +923,7 @@ if_convertible_loop_p (struct loop *loop)\n static basic_block\n find_phi_replacement_condition (struct loop *loop,\n \t\t\t\tbasic_block bb, tree *cond,\n-                                gimple_stmt_iterator *gsi)\n+\t\t\t\tgimple_stmt_iterator *gsi)\n {\n   edge first_edge, second_edge;\n   tree tmp_cond;\n@@ -970,21 +995,16 @@ find_phi_replacement_condition (struct loop *loop,\n \t\t\t\t    false, NULL_TREE,\n \t\t\t\t    true, GSI_SAME_STMT);\n   if (!is_gimple_reg (*cond) && !is_gimple_condexpr (*cond))\n-    {\n-      gimple new_stmt;\n-\n-      new_stmt = ifc_temp_var (TREE_TYPE (*cond), unshare_expr (*cond));\n-      gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n-      *cond = gimple_assign_lhs (new_stmt);\n-    }\n+    *cond = ifc_temp_var (TREE_TYPE (*cond), unshare_expr (*cond), gsi);\n \n   gcc_assert (*cond);\n \n   return first_edge->src;\n }\n \n-/* Replace PHI node with conditional modify expr using COND.  This\n-   routine does not handle PHI nodes with more than two arguments.\n+/* Replace a scalar PHI node with a COND_EXPR using COND as condition.\n+   This routine does not handle PHI nodes with more than two\n+   arguments.\n \n    For example,\n      S1: A = PHI <x1(1), x2(5)\n@@ -996,18 +1016,22 @@ find_phi_replacement_condition (struct loop *loop,\n    TRUE_BB is selected.  */\n \n static void\n-replace_phi_with_cond_gimple_assign_stmt (gimple phi, tree cond,\n-    \t\t\t\t\t  basic_block true_bb,\n-                                   \t  gimple_stmt_iterator *gsi)\n+predicate_scalar_phi (gimple phi, tree cond,\n+\t\t      basic_block true_bb,\n+\t\t      gimple_stmt_iterator *gsi)\n {\n   gimple new_stmt;\n   basic_block bb;\n-  tree rhs;\n-  tree arg;\n+  tree rhs, res, arg;\n \n   gcc_assert (gimple_code (phi) == GIMPLE_PHI\n \t      && gimple_phi_num_args (phi) == 2);\n \n+  res = gimple_phi_result (phi);\n+  /* Do not handle virtual phi nodes.  */\n+  if (!is_gimple_reg (SSA_NAME_VAR (res)))\n+    return;\n+\n   bb = gimple_bb (phi);\n \n   arg = degenerate_phi_result (phi);\n@@ -1029,11 +1053,11 @@ replace_phi_with_cond_gimple_assign_stmt (gimple phi, tree cond,\n \t}\n \n       /* Build new RHS using selected condition and arguments.  */\n-      rhs = build3 (COND_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n+      rhs = build3 (COND_EXPR, TREE_TYPE (res),\n \t\t    unshare_expr (cond), arg_0, arg_1);\n     }\n \n-  new_stmt = gimple_build_assign (PHI_RESULT (phi), rhs);\n+  new_stmt = gimple_build_assign (res, rhs);\n   SSA_NAME_DEF_STMT (gimple_phi_result (phi)) = new_stmt;\n   gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n   update_stmt (new_stmt);\n@@ -1045,11 +1069,11 @@ replace_phi_with_cond_gimple_assign_stmt (gimple phi, tree cond,\n     }\n }\n \n-/* Replaces in LOOP all the phi nodes other than those in the\n+/* Replaces in LOOP all the scalar phi nodes other than those in the\n    LOOP->header block with conditional modify expressions.  */\n \n static void\n-ifconvert_phi_nodes (struct loop *loop)\n+predicate_all_scalar_phis (struct loop *loop)\n {\n   basic_block bb;\n   unsigned int orig_loop_num_nodes = loop->num_nodes;\n@@ -1078,7 +1102,7 @@ ifconvert_phi_nodes (struct loop *loop)\n       while (!gsi_end_p (phi_gsi))\n \t{\n \t  phi = gsi_stmt (phi_gsi);\n-\t  replace_phi_with_cond_gimple_assign_stmt (phi, cond, true_bb, &gsi);\n+\t  predicate_scalar_phi (phi, cond, true_bb, &gsi);\n \t  release_phi_node (phi);\n \t  gsi_next (&phi_gsi);\n \t}\n@@ -1098,7 +1122,7 @@ insert_gimplified_predicates (loop_p loop)\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       basic_block bb = ifc_bbs[i];\n-      gimple_seq stmts = bb_predicate_gimplified_stmts (bb);\n+      gimple_seq stmts;\n \n       if (!is_predicated (bb))\n \t{\n@@ -1109,22 +1133,177 @@ insert_gimplified_predicates (loop_p loop)\n \t  continue;\n \t}\n \n+      stmts = bb_predicate_gimplified_stmts (bb);\n       if (stmts)\n \t{\n-\t  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-\n-\t  if (gsi_end_p (gsi)\n-\t      || gimple_code (gsi_stmt (gsi)) == GIMPLE_COND)\n-\t    gsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+\t  if (flag_tree_loop_if_convert_stores)\n+\t    {\n+\t      /* Insert the predicate of the BB just after the label,\n+\t\t as the if-conversion of memory writes will use this\n+\t\t predicate.  */\n+\t      gimple_stmt_iterator gsi = gsi_after_labels (bb);\n+\t      gsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+\t    }\n \t  else\n-\t    gsi_insert_seq_after (&gsi, stmts, GSI_SAME_STMT);\n+\t    {\n+\t      /* Insert the predicate of the BB at the end of the BB\n+\t\t as this would reduce the register pressure: the only\n+\t\t use of this predicate will be in successor BBs.  */\n+\t      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\n+\t      if (gsi_end_p (gsi)\n+\t\t  || stmt_ends_bb_p (gsi_stmt (gsi)))\n+\t\tgsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+\t      else\n+\t\tgsi_insert_seq_after (&gsi, stmts, GSI_SAME_STMT);\n+\t    }\n \n \t  /* Once the sequence is code generated, set it to NULL.  */\n \t  set_bb_predicate_gimplified_stmts (bb, NULL);\n \t}\n     }\n }\n \n+/* Predicate each write to memory in LOOP.\n+\n+   This function transforms control flow constructs containing memory\n+   writes of the form:\n+\n+   | for (i = 0; i < N; i++)\n+   |   if (cond)\n+   |     A[i] = expr;\n+\n+   into the following form that does not contain control flow:\n+\n+   | for (i = 0; i < N; i++)\n+   |   A[i] = cond ? expr : A[i];\n+\n+   The original CFG looks like this:\n+\n+   | bb_0\n+   |   i = 0\n+   | end_bb_0\n+   |\n+   | bb_1\n+   |   if (i < N) goto bb_5 else goto bb_2\n+   | end_bb_1\n+   |\n+   | bb_2\n+   |   cond = some_computation;\n+   |   if (cond) goto bb_3 else goto bb_4\n+   | end_bb_2\n+   |\n+   | bb_3\n+   |   A[i] = expr;\n+   |   goto bb_4\n+   | end_bb_3\n+   |\n+   | bb_4\n+   |   goto bb_1\n+   | end_bb_4\n+\n+   insert_gimplified_predicates inserts the computation of the COND\n+   expression at the beginning of the destination basic block:\n+\n+   | bb_0\n+   |   i = 0\n+   | end_bb_0\n+   |\n+   | bb_1\n+   |   if (i < N) goto bb_5 else goto bb_2\n+   | end_bb_1\n+   |\n+   | bb_2\n+   |   cond = some_computation;\n+   |   if (cond) goto bb_3 else goto bb_4\n+   | end_bb_2\n+   |\n+   | bb_3\n+   |   cond = some_computation;\n+   |   A[i] = expr;\n+   |   goto bb_4\n+   | end_bb_3\n+   |\n+   | bb_4\n+   |   goto bb_1\n+   | end_bb_4\n+\n+   predicate_mem_writes is then predicating the memory write as follows:\n+\n+   | bb_0\n+   |   i = 0\n+   | end_bb_0\n+   |\n+   | bb_1\n+   |   if (i < N) goto bb_5 else goto bb_2\n+   | end_bb_1\n+   |\n+   | bb_2\n+   |   if (cond) goto bb_3 else goto bb_4\n+   | end_bb_2\n+   |\n+   | bb_3\n+   |   cond = some_computation;\n+   |   A[i] = cond ? expr : A[i];\n+   |   goto bb_4\n+   | end_bb_3\n+   |\n+   | bb_4\n+   |   goto bb_1\n+   | end_bb_4\n+\n+   and finally combine_blocks removes the basic block boundaries making\n+   the loop vectorizable:\n+\n+   | bb_0\n+   |   i = 0\n+   |   if (i < N) goto bb_5 else goto bb_1\n+   | end_bb_0\n+   |\n+   | bb_1\n+   |   cond = some_computation;\n+   |   A[i] = cond ? expr : A[i];\n+   |   if (i < N) goto bb_5 else goto bb_4\n+   | end_bb_1\n+   |\n+   | bb_4\n+   |   goto bb_1\n+   | end_bb_4\n+*/\n+\n+static void\n+predicate_mem_writes (loop_p loop)\n+{\n+  unsigned int i, orig_loop_num_nodes = loop->num_nodes;\n+\n+  for (i = 1; i < orig_loop_num_nodes; i++)\n+    {\n+      gimple_stmt_iterator gsi;\n+      basic_block bb = ifc_bbs[i];\n+      tree cond = bb_predicate (bb);\n+      gimple stmt;\n+\n+      if (is_true_predicate (cond))\n+\tcontinue;\n+\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\tif ((stmt = gsi_stmt (gsi))\n+\t    && gimple_assign_single_p (stmt)\n+\t    && gimple_vdef (stmt))\n+\t  {\n+\t    tree lhs = gimple_assign_lhs (stmt);\n+\t    tree rhs = gimple_assign_rhs1 (stmt);\n+\t    tree type = TREE_TYPE (lhs);\n+\n+\t    lhs = ifc_temp_var (type, unshare_expr (lhs), &gsi);\n+\t    rhs = ifc_temp_var (type, unshare_expr (rhs), &gsi);\n+\t    rhs = build3 (COND_EXPR, type, unshare_expr (cond), rhs, lhs);\n+\t    gimple_assign_set_rhs1 (stmt, ifc_temp_var (type, rhs, &gsi));\n+\t    update_stmt (stmt);\n+\t  }\n+    }\n+}\n+\n /* Remove all GIMPLE_CONDs and GIMPLE_LABELs of all the basic blocks\n    other than the exit and latch of the LOOP.  Also resets the\n    GIMPLE_DEBUG information.  */\n@@ -1181,7 +1360,10 @@ combine_blocks (struct loop *loop)\n \n   remove_conditions_and_labels (loop);\n   insert_gimplified_predicates (loop);\n-  ifconvert_phi_nodes (loop);\n+  predicate_all_scalar_phis (loop);\n+\n+  if (flag_tree_loop_if_convert_stores)\n+    predicate_mem_writes (loop);\n \n   /* Merge basic blocks: first remove all the edges in the loop,\n      except for those from the exit block.  */\n@@ -1283,6 +1465,10 @@ tree_if_conversion (struct loop *loop)\n      blocks into one huge basic block doing the if-conversion\n      on-the-fly.  */\n   combine_blocks (loop);\n+\n+  if (flag_tree_loop_if_convert_stores)\n+    mark_sym_for_renaming (gimple_vop (cfun));\n+\n   changed = true;\n \n  cleanup:\n@@ -1308,14 +1494,21 @@ main_tree_if_conversion (void)\n   loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n+  unsigned todo = 0;\n \n   if (number_of_loops () <= 1)\n     return 0;\n \n   FOR_EACH_LOOP (li, loop, 0)\n     changed |= tree_if_conversion (loop);\n \n-  return changed ? TODO_cleanup_cfg : 0;\n+  if (changed)\n+    todo |= TODO_cleanup_cfg;\n+\n+  if (changed && flag_tree_loop_if_convert_stores)\n+    todo |= TODO_update_ssa_only_virtuals;\n+\n+  return todo;\n }\n \n /* Returns true when the if-conversion pass is enabled.  */\n@@ -1324,7 +1517,8 @@ static bool\n gate_tree_if_conversion (void)\n {\n   return ((flag_tree_vectorize && flag_tree_loop_if_convert != 0)\n-\t  || flag_tree_loop_if_convert == 1);\n+\t  || flag_tree_loop_if_convert == 1\n+\t  || flag_tree_loop_if_convert_stores == 1);\n }\n \n struct gimple_opt_pass pass_if_conversion ="}]}