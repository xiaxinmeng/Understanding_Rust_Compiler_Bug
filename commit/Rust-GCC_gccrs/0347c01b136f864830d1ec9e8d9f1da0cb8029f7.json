{"sha": "0347c01b136f864830d1ec9e8d9f1da0cb8029f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM0N2MwMWIxMzZmODY0ODMwZDFlYzllOGQ5ZjFkYTBjYjgwMjlmNw==", "commit": {"author": {"name": "Raphael Amiard", "email": "amiard@adacore.com", "date": "2018-05-24T13:05:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-24T13:05:43Z"}, "message": "[Ada] Update Ada.Containers.Hashed_Maps documentation with Ada RM doc.\n\n2018-05-24  Raphael Amiard  <amiard@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-cohama.ads: Add documentation.\n\nFrom-SVN: r260656", "tree": {"sha": "da08bcf21e14b4086df329775ace54de80ae7fbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da08bcf21e14b4086df329775ace54de80ae7fbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0347c01b136f864830d1ec9e8d9f1da0cb8029f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0347c01b136f864830d1ec9e8d9f1da0cb8029f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0347c01b136f864830d1ec9e8d9f1da0cb8029f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0347c01b136f864830d1ec9e8d9f1da0cb8029f7/comments", "author": {"login": "raph-amiard", "id": 478727, "node_id": "MDQ6VXNlcjQ3ODcyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/478727?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raph-amiard", "html_url": "https://github.com/raph-amiard", "followers_url": "https://api.github.com/users/raph-amiard/followers", "following_url": "https://api.github.com/users/raph-amiard/following{/other_user}", "gists_url": "https://api.github.com/users/raph-amiard/gists{/gist_id}", "starred_url": "https://api.github.com/users/raph-amiard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raph-amiard/subscriptions", "organizations_url": "https://api.github.com/users/raph-amiard/orgs", "repos_url": "https://api.github.com/users/raph-amiard/repos", "events_url": "https://api.github.com/users/raph-amiard/events{/privacy}", "received_events_url": "https://api.github.com/users/raph-amiard/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f1b88f82b9cbfd134544fd2230a6f3e5c82acce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce"}], "stats": {"total": 257, "additions": 175, "deletions": 82}, "files": [{"sha": "b30baad65bb188fc7a0c328e7c2fc6286754e481", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0347c01b136f864830d1ec9e8d9f1da0cb8029f7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0347c01b136f864830d1ec9e8d9f1da0cb8029f7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0347c01b136f864830d1ec9e8d9f1da0cb8029f7", "patch": "@@ -1,3 +1,7 @@\n+2018-05-24  Raphael Amiard  <amiard@adacore.com>\n+\n+\t* libgnat/a-cohama.ads: Add documentation.\n+\n 2018-05-24  Raphael Amiard  <amiard@adacore.com>\n \n \t* libgnat/a-convec.ads: Add documentation."}, {"sha": "4613240447e545fd91a4a3e21a82b0536bc73299", "filename": "gcc/ada/libgnat/a-cohama.ads", "status": "modified", "additions": 171, "deletions": 82, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0347c01b136f864830d1ec9e8d9f1da0cb8029f7/gcc%2Fada%2Flibgnat%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0347c01b136f864830d1ec9e8d9f1da0cb8029f7/gcc%2Fada%2Flibgnat%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cohama.ads?ref=0347c01b136f864830d1ec9e8d9f1da0cb8029f7", "patch": "@@ -37,14 +37,57 @@ private with Ada.Containers.Hash_Tables;\n private with Ada.Finalization;\n private with Ada.Streams;\n \n+--  The language-defined generic package Containers.Hashed_Maps provides\n+--  private types Map and Cursor, and a set of operations for each type. A map\n+--  container allows an arbitrary type to be used as a key to find the element\n+--  associated with that key. A hashed map uses a hash function to organize the\n+--  keys.\n+--\n+--  A map contains pairs of keys and elements, called nodes. Map cursors\n+--  designate nodes, but also can be thought of as designating an element (the\n+--  element contained in the node) for consistency with the other containers.\n+--  There exists an equivalence relation on keys, whose definition is different\n+--  for hashed maps and ordered maps. A map never contains two or more nodes\n+--  with equivalent keys. The length of a map is the number of nodes it\n+--  contains.\n+--\n+--  Each nonempty map has two particular nodes called the first node and the\n+--  last node (which may be the same). Each node except for the last node has a\n+--  successor node. If there are no other intervening operations, starting with\n+--  the first node and repeatedly going to the successor node will visit each\n+--  node in the map exactly once until the last node is reached.\n+\n generic\n    type Key_Type is private;\n    type Element_Type is private;\n \n    with function Hash (Key : Key_Type) return Hash_Type;\n+   --  The actual function for the generic formal function Hash is expected to\n+   --  return the same value each time it is called with a particular key\n+   --  value. For any two equivalent key values, the actual for Hash is\n+   --  expected to return the same value. If the actual for Hash behaves in\n+   --  some other manner, the behavior of this package is unspecified. Which\n+   --  subprograms of this package call Hash, and how many times they call it,\n+   --  is unspecified.\n+\n    with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+   --  The actual function for the generic formal function Equivalent_Keys on\n+   --  Key_Type values is expected to return the same value each time it is\n+   --  called with a particular pair of key values. It should define an\n+   --  equivalence relationship, that is, be reflexive, symmetric, and\n+   --  transitive. If the actual for Equivalent_Keys behaves in some other\n+   --  manner, the behavior of this package is unspecified. Which subprograms\n+   --  of this package call Equivalent_Keys, and how many times they call it,\n+   --  is unspecified.\n \n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+   --  The actual function for the generic formal function \"=\" on Element_Type\n+   --  values is expected to define a reflexive and symmetric relationship and\n+   --  return the same result value each time it is called with a particular\n+   --  pair of values.  If it behaves in some other manner, the function \"=\" on\n+   --  map values returns an unspecified value. The exact arguments and number\n+   --  of calls of this generic formal function by the function \"=\" on map\n+   --  values are unspecified.\n package Ada.Containers.Hashed_Maps is\n    pragma Annotate (CodePeer, Skip_Analysis);\n    pragma Preelaborate;\n@@ -71,21 +114,27 @@ package Ada.Containers.Hashed_Maps is\n    --  initialized to the value No_Element.\n \n    function Has_Element (Position : Cursor) return Boolean;\n-   --  Equivalent to Position /= No_Element\n+   --  Returns True if Position designates an element, and returns False\n+   --  otherwise.\n \n    package Map_Iterator_Interfaces is new\n      Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    function \"=\" (Left, Right : Map) return Boolean;\n-   --  For each key/element pair in Left, equality attempts to find the key in\n-   --  Right; if a search fails the equality returns False. The search works by\n-   --  calling Hash to find the bucket in the Right map that corresponds to the\n-   --  Left key. If bucket is non-empty, then equality calls Equivalent_Keys\n-   --  to compare the key (in Left) to the key of each node in the bucket (in\n-   --  Right); if the keys are equivalent, then the equality test for this\n-   --  key/element pair (in Left) completes by calling the element equality\n-   --  operator to compare the element (in Left) to the element of the node\n-   --  (in Right) whose key matched.\n+   --  If Left and Right denote the same map object, then the function returns\n+   --  True. If Left and Right have different lengths, then the function\n+   --  returns False. Otherwise, for each key K in Left, the function returns\n+   --  False if:\n+   --\n+   --  * a key equivalent to K is not present in Right; or\n+   --\n+   --  * the element associated with K in Left is not equal to the\n+   --    element associated with K in Right (using the generic formal\n+   --    equality operator for elements).\n+   --\n+   --  If the function has not returned a result after checking all of the\n+   --  keys, it returns True. Any exception raised during evaluation of key\n+   --  equivalence or element equality is propagated.\n \n    function Capacity (Container : Map) return Count_Type;\n    --  Returns the current capacity of the map. Capacity is the maximum length\n@@ -111,31 +160,55 @@ package Ada.Containers.Hashed_Maps is\n    --  Removes all of the items from the map\n \n    function Key (Position : Cursor) return Key_Type;\n-   --  Returns the key of the node designated by the cursor\n+   --  Key returns the key component of the node designated by Position.\n+   --\n+   --  If Position equals No_Element, then Constraint_Error is propagated.\n \n    function Element (Position : Cursor) return Element_Type;\n-   --  Returns the element of the node designated by the cursor\n+   --  Element returns the element component of the node designated\n+   --  by Position.\n+   --\n+   --  If Position equals No_Element, then Constraint_Error is propagated.\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n-   --  Assigns the value New_Item to the element designated by the cursor\n+   --  Replace_Element assigns New_Item to the element of the node designated\n+   --  by Position.\n+   --\n+   --  If Position equals No_Element, then Constraint_Error is propagated; if\n+   --  Position does not designate an element in Container, then Program_Error\n+   --  is propagated.\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access\n                    procedure (Key : Key_Type; Element : Element_Type));\n-   --  Calls Process with the key and element (both having only a constant\n-   --  view) of the node designed by the cursor.\n+   --  Query_Element calls Process.all with the key and element from the node\n+   --  designated by Position as the arguments.\n+   --\n+   --  If Position equals No_Element, then Constraint_Error is propagated.\n+   --\n+   --  Tampering with the elements of the map that contains the element\n+   --  designated by Position is prohibited during the execution of the call on\n+   --  Process.all. Any exception raised by Process.all is propagated.\n \n    procedure Update_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       Process   : not null access\n                     procedure (Key : Key_Type; Element : in out Element_Type));\n-   --  Calls Process with the key (with only a constant view) and element (with\n-   --  a variable view) of the node designed by the cursor.\n+   --  Update_Element calls Process.all with the key and element from the node\n+   --  designated by Position as the arguments.\n+   --\n+   --  If Position equals No_Element, then Constraint_Error is propagated; if\n+   --  Position does not designate an element in Container, then Program_Error\n+   --  is propagated.\n+   --\n+   --  Tampering with the elements of Container is prohibited during the\n+   --  execution of the call on Process.all. Any exception raised by\n+   --  Process.all is propagated.\n \n    type Constant_Reference_Type\n       (Element : not null access constant Element_Type) is private\n@@ -150,135 +223,147 @@ package Ada.Containers.Hashed_Maps is\n      (Container : aliased Map;\n       Position  : Cursor) return Constant_Reference_Type;\n    pragma Inline (Constant_Reference);\n+   --  This function (combined with the Constant_Indexing and\n+   --  Implicit_Dereference aspects) provides a convenient way to gain read\n+   --  access to an individual element of a map given a cursor.\n+   --  Constant_Reference returns an object whose discriminant is an access\n+   --  value that designates the element designated by Position.\n+   --\n+   --  If Position equals No_Element, then Constraint_Error is propagated; if\n+   --  Position does not designate an element in Container, then Program_Error\n+   --  is propagated.\n+   --\n+   --  Tampering with the elements of Container is prohibited\n+   --  while the object returned by Constant_Reference exists and has not been\n+   --  finalized.\n \n    function Reference\n      (Container : aliased in out Map;\n       Position  : Cursor) return Reference_Type;\n    pragma Inline (Reference);\n+   --  This function (combined with the Variable_Indexing and\n+   --  Implicit_Dereference aspects) provides a convenient way to gain read and\n+   --  write access to an individual element of a map given a cursor.\n+   --  Reference returns an object whose discriminant is an access value that\n+   --  designates the element designated by Position.\n+   --\n+   --  If Position equals No_Element, then Constraint_Error is propagated; if\n+   --  Position does not designate an element in Container, then Program_Error\n+   --  is propagated.\n+   --\n+   --  Tampering with the elements of Container is prohibited while the object\n+   --  returned by Reference exists and has not been finalized.\n \n    function Constant_Reference\n      (Container : aliased Map;\n       Key       : Key_Type) return Constant_Reference_Type;\n    pragma Inline (Constant_Reference);\n+   --  Equivalent to Constant_Reference (Container, Find (Container, Key)).\n \n    function Reference\n      (Container : aliased in out Map;\n       Key       : Key_Type) return Reference_Type;\n    pragma Inline (Reference);\n+   --  Equivalent to Reference (Container, Find (Container, Key)).\n \n    procedure Assign (Target : in out Map; Source : Map);\n+   --  If Target denotes the same object as Source, the operation has no\n+   --  effect. Otherwise, the key/element pairs of Source are copied to Target\n+   --  as for an assignment_statement assigning Source to Target.\n \n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map;\n \n    procedure Move (Target : in out Map; Source : in out Map);\n-   --  Clears Target (if it's not empty), and then moves (not copies) the\n-   --  buckets array and nodes from Source to Target.\n+   --  If Target denotes the same object as Source, then the operation has no\n+   --  effect. Otherwise, the operation is equivalent to Assign (Target,\n+   --  Source) followed by Clear (Source).\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n-   --  Conditionally inserts New_Item into the map. If Key is already in the\n-   --  map, then Inserted returns False and Position designates the node\n-   --  containing the existing key/element pair (neither of which is modified).\n-   --  If Key is not already in the map, the Inserted returns True and Position\n-   --  designates the newly-inserted node container Key and New_Item. The\n-   --  search for the key works as follows. Hash is called to determine Key's\n-   --  bucket; if the bucket is non-empty, then Equivalent_Keys is called to\n-   --  compare Key to each node in that bucket. If the bucket is empty, or\n-   --  there were no matching keys in the bucket, the search \"fails\" and the\n-   --  key/item pair is inserted in the map (and Inserted returns True);\n-   --  otherwise, the search \"succeeds\" (and Inserted returns False).\n+   --  Insert checks if a node with a key equivalent to Key is already present\n+   --  in Container. If a match is found, Inserted is set to False and Position\n+   --  designates the element with the matching key.  Otherwise, Insert\n+   --  allocates a new node, initializes it to Key and New_Item, and adds it to\n+   --  Container; Inserted is set to True and Position designates the\n+   --  newly-inserted node. Any exception raised during allocation is\n+   --  propagated and Container is not modified.\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n-   --  The same as the (conditional) Insert that accepts an element parameter,\n-   --  with the difference that if Inserted returns True, then the element of\n-   --  the newly-inserted node is initialized to its default value.\n+   --  Insert inserts Key into Container as per the five-parameter Insert, with\n+   --  the difference that an element initialized by default (see 3.3.1) is\n+   --  inserted.\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n-   --  Attempts to insert Key into the map, performing the usual search (which\n-   --  involves calling both Hash and Equivalent_Keys); if the search succeeds\n-   --  (because Key is already in the map), then it raises Constraint_Error.\n-   --  (This version of Insert is similar to Replace, but having the opposite\n-   --  exception behavior. It is intended for use when you want to assert that\n-   --  Key is not already in the map.)\n+   --  Insert inserts Key and New_Item into Container as per the five-parameter\n+   --  Insert, with the difference that if a node with a key equivalent to Key\n+   --  is already in the map, then Constraint_Error is propagated.\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n-   --  Attempts to insert Key into the map. If Key is already in the map, then\n-   --  both the existing key and element are assigned the values of Key and\n-   --  New_Item, respectively. (This version of Insert only raises an exception\n-   --  if cursor tampering occurs. It is intended for use when you want to\n-   --  insert the key/element pair in the map, and you don't care whether Key\n-   --  is already present.)\n+   --  Include inserts Key and New_Item into Container as per the\n+   --  five-parameter Insert, with the difference that if a node with a key\n+   --  equivalent to Key is already in the map, then this operation assigns Key\n+   --  and New_Item to the matching node. Any exception raised during\n+   --  assignment is propagated.\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n-   --  Searches for Key in the map; if the search fails (because Key was not in\n-   --  the map), then it raises Constraint_Error. Otherwise, both the existing\n-   --  key and element are assigned the values of Key and New_Item rsp. (This\n-   --  is similar to Insert, but with the opposite exception behavior. It is to\n-   --  be used when you want to assert that Key is already in the map.)\n+   --  Replace checks if a node with a key equivalent to Key is present in\n+   --  Container. If a match is found, Replace assigns Key and New_Item to the\n+   --  matching node; otherwise, Constraint_Error is propagated.\n \n    procedure Exclude (Container : in out Map; Key : Key_Type);\n-   --  Searches for Key in the map, and if found, removes its node from the map\n-   --  and then deallocates it. The search works as follows. The operation\n-   --  calls Hash to determine the key's bucket; if the bucket is not empty, it\n-   --  calls Equivalent_Keys to compare Key to each key in the bucket. (This is\n-   --  the deletion analog of Include. It is intended for use when you want to\n-   --  remove the item from the map, but don't care whether the key is already\n-   --  in the map.)\n+   --  Exclude checks if a node with a key equivalent to Key is present in\n+   --  Container. If a match is found, Exclude removes the node from the map.\n \n    procedure Delete (Container : in out Map; Key : Key_Type);\n-   --  Searches for Key in the map (which involves calling both Hash and\n-   --  Equivalent_Keys). If the search fails, then the operation raises\n-   --  Constraint_Error. Otherwise it removes the node from the map and then\n-   --  deallocates it. (This is the deletion analog of non-conditional\n-   --  Insert. It is intended for use when you want to assert that the item is\n-   --  already in the map.)\n+   --  Delete checks if a node with a key equivalent to Key is present in\n+   --  Container. If a match is found, Delete removes the node from the map;\n+   --  otherwise, Constraint_Error is propagated.\n \n    procedure Delete (Container : in out Map; Position : in out Cursor);\n-   --  Removes the node designated by Position from the map, and then\n-   --  deallocates the node. The operation calls Hash to determine the bucket,\n-   --  and then compares Position to each node in the bucket until there's a\n-   --  match (it does not call Equivalent_Keys).\n+   --  Delete removes the node designated by Position from the map. Position is\n+   --  set to No_Element on return.\n+   --\n+   --  If Position equals No_Element, then Constraint_Error is propagated. If\n+   --  Position does not designate an element in Container, then Program_Error\n+   --  is propagated.\n \n    function First (Container : Map) return Cursor;\n-   --  Returns a cursor that designates the first non-empty bucket, by\n-   --  searching from the beginning of the buckets array.\n+   --  If Length (Container) = 0, then First returns No_Element.  Otherwise,\n+   --  First returns a cursor that designates the first node in Container.\n \n    function Next (Position : Cursor) return Cursor;\n-   --  Returns a cursor that designates the node that follows the current one\n-   --  designated by Position. If Position designates the last node in its\n-   --  bucket, the operation calls Hash to compute the index of this bucket,\n-   --  and searches the buckets array for the first non-empty bucket, starting\n-   --  from that index; otherwise, it simply follows the link to the next node\n-   --  in the same bucket.\n+   --  Returns a cursor that designates the successor of the node designated by\n+   --  Position. If Position designates the last node, then No_Element is\n+   --  returned. If Position equals No_Element, then No_Element is returned.\n \n    procedure Next (Position : in out Cursor);\n    --  Equivalent to Position := Next (Position)\n \n    function Find (Container : Map; Key : Key_Type) return Cursor;\n-   --  Searches for Key in the map. Find calls Hash to determine the key's\n-   --  bucket; if the bucket is not empty, it calls Equivalent_Keys to compare\n-   --  Key to each key in the bucket. If the search succeeds, Find returns a\n-   --  cursor designating the matching node; otherwise, it returns No_Element.\n+   --  If Length (Container) equals 0, then Find returns No_Element.\n+   --  Otherwise, Find checks if a node with a key equivalent to Key is present\n+   --  in Container. If a match is found, a cursor designating the matching\n+   --  node is returned; otherwise, No_Element is returned.\n \n    function Contains (Container : Map; Key : Key_Type) return Boolean;\n-   --  Equivalent to Find (Container, Key) /= No_Element\n+   --  Equivalent to Find (Container, Key) /= No_Element.\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type;\n    --  Equivalent to Element (Find (Container, Key))\n@@ -298,7 +383,11 @@ package Ada.Containers.Hashed_Maps is\n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n-   --  Calls Process for each node in the map\n+   --  Iterate calls Process.all with a cursor that designates each node in\n+   --  Container, starting with the first node and moving the cursor according\n+   --  to the successor relation. Tampering with the cursors of Container is\n+   --  prohibited during the execution of a call on Process.all. Any exception\n+   --  raised by Process.all is propagated.\n \n    function Iterate\n      (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'Class;"}]}