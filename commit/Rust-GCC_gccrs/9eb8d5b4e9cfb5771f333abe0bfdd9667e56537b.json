{"sha": "9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWViOGQ1YjRlOWNmYjU3NzFmMzMzYWJlMGJmZGQ5NjY3ZTU2NTM3Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T12:07:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T12:07:34Z"}, "message": "[multiple changes]\n\n2017-01-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch4.adb (P_Aggregate_Or_Parent_Expr): Recognize delta\n\taggregate construct.\n\t(P_Record_Or_Array_Component_Association): An array aggregate\n\tcan start with an Iterated_Component_Association.\n\t* scng.adb: Modify error message on improper use of @ in earlier\n\tversions of the language.\n\t* sinfo.ads: New node kind N_Delta_Aggregate.\n\t* sinfo.adb: An N_Delta_Aggregate has component associations and\n\tan expression.\n\t* sem_res.adb (Resolve): Call Resolve_Delta_Aggregate.\n\t* sem_aggr.ads, sem_aggr.adb (Resolve_Iterated_Component_Association):\n\tCreate a new index for each one of the choices in the association,\n\tto prevent spurious homonyms in the scope.\n\t(Resolve_Delta_Aggregate): New.\n\t* sem.adb: An N_Delta_Aggregate is analyzed like an aggregate.\n\t* exp_util.adb (Insert_Actions): Take into account\n\tN_Delta_Aggregate.\n\t* exp_aggr.ads: New procedure Expand_N_Delta_Aggregate.\n\t* exp_aggr.adb: New procedure Expand_N_Delta_Aggregate,\n\tand local procedures Expand_Delta_Array_Aggregate and\n\texpand_Delta_Record_Aggregate.\n\t* sprint.adb: Handle N_Delta_Aggregate.\n\n2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch11.adb (Expand_N_Exception_Declaration): Generate an\n\tempty name when the exception declaration is subject to pragma\n\tDiscard_Names.\n\t(Null_String): New routine.\n\n2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* par-ch9.adb (P_Protected_Definition): Parse\n\tany optional and potentially illegal pragmas which appear in\n\ta protected operation declaration list.\n\t(P_Task_Items): Parse\n\tany optional and potentially illegal pragmas which appear in a\n\ttask item list.\n\nFrom-SVN: r244794", "tree": {"sha": "690646e0d60ca67a7d2f7ac6694350a82e4ae18a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/690646e0d60ca67a7d2f7ac6694350a82e4ae18a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/comments", "author": null, "committer": null, "parents": [{"sha": "f6b9f2ffc190054ca8f4dad110d85613964d2006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b9f2ffc190054ca8f4dad110d85613964d2006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6b9f2ffc190054ca8f4dad110d85613964d2006"}], "stats": {"total": 517, "additions": 484, "deletions": 33}, "files": [{"sha": "8a8c290cad9c404533ad93140e504a00fd0a2932", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -1,3 +1,44 @@\n+2017-01-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch4.adb (P_Aggregate_Or_Parent_Expr): Recognize delta\n+\taggregate construct.\n+\t(P_Record_Or_Array_Component_Association): An array aggregate\n+\tcan start with an Iterated_Component_Association.\n+\t* scng.adb: Modify error message on improper use of @ in earlier\n+\tversions of the language.\n+\t* sinfo.ads: New node kind N_Delta_Aggregate.\n+\t* sinfo.adb: An N_Delta_Aggregate has component associations and\n+\tan expression.\n+\t* sem_res.adb (Resolve): Call Resolve_Delta_Aggregate.\n+\t* sem_aggr.ads, sem_aggr.adb (Resolve_Iterated_Component_Association):\n+\tCreate a new index for each one of the choices in the association,\n+\tto prevent spurious homonyms in the scope.\n+\t(Resolve_Delta_Aggregate): New.\n+\t* sem.adb: An N_Delta_Aggregate is analyzed like an aggregate.\n+\t* exp_util.adb (Insert_Actions): Take into account\n+\tN_Delta_Aggregate.\n+\t* exp_aggr.ads: New procedure Expand_N_Delta_Aggregate.\n+\t* exp_aggr.adb: New procedure Expand_N_Delta_Aggregate,\n+\tand local procedures Expand_Delta_Array_Aggregate and\n+\texpand_Delta_Record_Aggregate.\n+\t* sprint.adb: Handle N_Delta_Aggregate.\n+\n+2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch11.adb (Expand_N_Exception_Declaration): Generate an\n+\tempty name when the exception declaration is subject to pragma\n+\tDiscard_Names.\n+\t(Null_String): New routine.\n+\n+2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* par-ch9.adb (P_Protected_Definition): Parse\n+\tany optional and potentially illegal pragmas which appear in\n+\ta protected operation declaration list.\n+\t(P_Task_Items): Parse\n+\tany optional and potentially illegal pragmas which appear in a\n+\ttask item list.\n+\n 2017-01-23  Pascal Obry  <obry@adacore.com>\n \n \t* s-taprop-mingw.adb (Enter_Task): Initialize the Thread handle which"}, {"sha": "a41bfa08aeda8fa80dbc2f7ed10b2b66b0fbe14e", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -84,6 +84,9 @@ package body Exp_Aggr is\n    --  expression with actions, which becomes the Initialization_Statements for\n    --  Obj.\n \n+   procedure Expand_Delta_Array_Aggregate  (N : Node_Id; Deltas : List_Id);\n+   procedure Expand_Delta_Record_Aggregate (N : Node_Id; Deltas : List_Id);\n+\n    function Has_Default_Init_Comps (N : Node_Id) return Boolean;\n    --  N is an aggregate (record or array). Checks the presence of default\n    --  initialization (<>) in any component (Ada 2005: AI-287).\n@@ -6436,6 +6439,151 @@ package body Exp_Aggr is\n          return;\n    end Expand_N_Aggregate;\n \n+   ------------------------------\n+   -- Expand_N_Delta_Aggregate --\n+   ------------------------------\n+\n+   procedure Expand_N_Delta_Aggregate (N : Node_Id) is\n+      Loc :  constant Source_Ptr := Sloc (N);\n+      Temp : constant Entity_Id := Make_Temporary (Loc, 'T');\n+      Typ  : constant Entity_Id := Etype (N);\n+      Decl : Node_Id;\n+\n+   begin\n+      Decl := Make_Object_Declaration (Loc,\n+         Defining_Identifier => Temp,\n+         Object_Definition => New_Occurrence_Of (Typ, Loc),\n+         Expression => New_Copy_Tree (Expression (N)));\n+\n+      if Is_Array_Type (Etype (N)) then\n+         Expand_Delta_Array_Aggregate (N, New_List (Decl));\n+      else\n+         Expand_Delta_Record_Aggregate (N, New_List (Decl));\n+      end if;\n+   end Expand_N_Delta_Aggregate;\n+\n+   ----------------------------------\n+   -- Expand_Delta_Array_Aggregate --\n+   ----------------------------------\n+\n+   procedure Expand_Delta_Array_Aggregate (N : Node_Id; Deltas : List_Id) is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Temp   : constant Entity_Id  := Defining_Identifier (First (Deltas));\n+      Assoc  : Node_Id;\n+      Choice : Node_Id;\n+      function Generate_Loop (C : Node_Id) return Node_Id;\n+      --  Generate a loop containing individual component assignments for\n+      --  choices that are ranges, subtype indications, subtype names, and\n+      --  iterated component associations.\n+\n+      function Generate_Loop (C : Node_Id) return Node_Id is\n+         Sl : constant Source_Ptr := Sloc (C);\n+         Ix : Entity_Id;\n+\n+      begin\n+         if Nkind (Parent (C)) = N_Iterated_Component_Association then\n+            Ix :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => (Chars (Defining_Identifier (Parent (C)))));\n+         else\n+            Ix := Make_Temporary (Sl, 'I');\n+         end if;\n+\n+         return\n+           Make_Loop_Statement (Loc,\n+              Iteration_Scheme => Make_Iteration_Scheme (Sl,\n+                Loop_Parameter_Specification =>\n+                Make_Loop_Parameter_Specification (Sl,\n+                  Defining_Identifier => Ix,\n+                  Discrete_Subtype_Definition => New_Copy_Tree (C))),\n+              End_Label => Empty,\n+              Statements =>\n+                New_List (\n+                  Make_Assignment_Statement (Sl,\n+                    Name       => Make_Indexed_Component (Sl,\n+                      Prefix      => New_Occurrence_Of (Temp, Sl),\n+                      Expressions => New_List (New_Occurrence_Of (Ix, Sl))),\n+                    Expression => New_Copy_Tree (Expression (Assoc)))));\n+      end Generate_Loop;\n+\n+   begin\n+      Assoc := First (Component_Associations (N));\n+      while Present (Assoc) loop\n+         Choice := First (Choice_List (Assoc));\n+         if Nkind (Assoc) = N_Iterated_Component_Association then\n+            while Present (Choice) loop\n+               Append_To (Deltas, Generate_Loop (Choice));\n+               Next (Choice);\n+            end loop;\n+\n+         else\n+            while Present (Choice) loop\n+\n+               --  Choice can be given by a range, a subtype indication, a\n+               --  subtype name, a scalar value, or an entity.\n+\n+               if Nkind (Choice) = N_Range\n+                 or else (Is_Entity_Name (Choice)\n+                   and then Is_Type (Entity (Choice)))\n+               then\n+                  Append_To (Deltas, Generate_Loop (Choice));\n+\n+               elsif Nkind (Choice) = N_Subtype_Indication then\n+                  Append_To (Deltas,\n+                    Generate_Loop (Range_Expression (Constraint (Choice))));\n+\n+               else\n+                  Append_To (Deltas,\n+                     Make_Assignment_Statement (Sloc (Choice),\n+                       Name => Make_Indexed_Component (Sloc (Choice),\n+                         Prefix => New_Occurrence_Of (Temp, Loc),\n+                         Expressions => New_List (New_Copy_Tree (Choice))),\n+                       Expression => New_Copy_Tree (Expression (Assoc))));\n+               end if;\n+\n+               Next (Choice);\n+            end loop;\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+\n+      Insert_Actions (N, Deltas);\n+      Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+   end Expand_Delta_Array_Aggregate;\n+\n+   -----------------------------------\n+   -- Expand_Delta_Record_Aggregate --\n+   -----------------------------------\n+\n+   procedure Expand_Delta_Record_Aggregate (N : Node_Id; Deltas : List_Id) is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Temp   : constant Entity_Id  := Defining_Identifier (First (Deltas));\n+      Assoc  : Node_Id;\n+      Choice : Node_Id;\n+\n+   begin\n+      Assoc := First (Component_Associations (N));\n+\n+      while Present (Assoc) loop\n+         Choice := First (Choice_List (Assoc));\n+         while Present (Choice) loop\n+            Append_To (Deltas,\n+               Make_Assignment_Statement (Sloc (Choice),\n+                 Name => Make_Selected_Component (Sloc (Choice),\n+                   Prefix => New_Occurrence_Of (Temp, Loc),\n+                   Selector_Name => Make_Identifier (Loc, Chars (Choice))),\n+                 Expression => New_Copy_Tree (Expression (Assoc))));\n+            Next (Choice);\n+         end loop;\n+\n+         Next (Assoc);\n+      end loop;\n+\n+      Insert_Actions (N, Deltas);\n+      Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+   end Expand_Delta_Record_Aggregate;\n+\n    ----------------------------------\n    -- Expand_N_Extension_Aggregate --\n    ----------------------------------"}, {"sha": "b9441fde4c0ee7ef1a1cca7d1af1a46a00472da2", "filename": "gcc/ada/exp_aggr.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fexp_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fexp_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.ads?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -28,6 +28,7 @@ with Types; use Types;\n package Exp_Aggr is\n \n    procedure Expand_N_Aggregate           (N : Node_Id);\n+   procedure Expand_N_Delta_Aggregate     (N : Node_Id);\n    procedure Expand_N_Extension_Aggregate (N : Node_Id);\n \n    function Is_Delayed_Aggregate (N : Node_Id) return Boolean;"}, {"sha": "8711c89d0eb483b2c2aa67052f4a11cf5fff7d01", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -1171,11 +1171,8 @@ package body Exp_Ch11 is\n    --     end if;\n \n    procedure Expand_N_Exception_Declaration (N : Node_Id) is\n-      Id      : constant Entity_Id  := Defining_Identifier (N);\n-      Loc     : constant Source_Ptr := Sloc (N);\n-      Ex_Id   : Entity_Id;\n-      Flag_Id : Entity_Id;\n-      L       : List_Id;\n+      Id  : constant Entity_Id  := Defining_Identifier (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n \n       procedure Force_Static_Allocation_Of_Referenced_Objects\n         (Aggregate : Node_Id);\n@@ -1205,6 +1202,9 @@ package body Exp_Ch11 is\n       --  references to other local (non-hoisted) objects (e.g., in the initial\n       --  value expression).\n \n+      function Null_String return String_Id;\n+      --  Build a null-terminated empty string\n+\n       ---------------------------------------------------\n       -- Force_Static_Allocation_Of_Referenced_Objects --\n       ---------------------------------------------------\n@@ -1248,6 +1248,24 @@ package body Exp_Ch11 is\n          Fixup_Tree (Aggregate);\n       end Force_Static_Allocation_Of_Referenced_Objects;\n \n+      -----------------\n+      -- Null_String --\n+      -----------------\n+\n+      function Null_String return String_Id is\n+      begin\n+         Start_String;\n+         Store_String_Char (Get_Char_Code (ASCII.NUL));\n+         return End_String;\n+      end Null_String;\n+\n+      --  Local variables\n+\n+      Ex_Id   : Entity_Id;\n+      Ex_Val  : String_Id;\n+      Flag_Id : Entity_Id;\n+      L       : List_Id;\n+\n    --  Start of processing for Expand_N_Exception_Declaration\n \n    begin\n@@ -1262,14 +1280,25 @@ package body Exp_Ch11 is\n       Ex_Id :=\n         Make_Defining_Identifier (Loc, New_External_Name (Chars (Id), 'E'));\n \n+      --  Do not generate an external name if the exception declaration is\n+      --  subject to pragma Discard_Names. Use a null-terminated empty name\n+      --  to ensure that Ada.Exceptions.Exception_Name functions properly.\n+\n+      if Global_Discard_Names or else Discard_Names (Ex_Id) then\n+         Ex_Val := Null_String;\n+\n+      --  Otherwise generate the fully qualified name of the exception\n+\n+      else\n+         Ex_Val := Fully_Qualified_Name_String (Id);\n+      end if;\n+\n       Insert_Action (N,\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Ex_Id,\n           Constant_Present    => True,\n           Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n-          Expression          =>\n-            Make_String_Literal (Loc,\n-              Strval => Fully_Qualified_Name_String (Id))));\n+          Expression          => Make_String_Literal (Loc, Ex_Val)));\n \n       Set_Is_Statically_Allocated (Ex_Id);\n "}, {"sha": "3a1d98587c7e27cfc6d57a7d456c703125f4fccb", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -5831,6 +5831,7 @@ package body Exp_Util is\n                | N_Defining_Operator_Symbol\n                | N_Defining_Program_Unit_Name\n                | N_Delay_Alternative\n+               | N_Delta_Aggregate\n                | N_Delta_Constraint\n                | N_Derived_Type_Definition\n                | N_Designator"}, {"sha": "e9a3a23b3fb06093e06ef4972a98343bddfba77a", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -1381,7 +1381,7 @@ package body Ch4 is\n             Expr_Node := P_Expression_Or_Range_Attribute_If_OK;\n          end if;\n \n-         --  Extension aggregate\n+         --  Extension or Delta aggregate\n \n          if Token = Tok_With then\n             if Nkind (Expr_Node) = N_Attribute_Reference\n@@ -1395,9 +1395,18 @@ package body Ch4 is\n                Error_Msg_SC (\"(Ada 83) extension aggregate not allowed\");\n             end if;\n \n-            Aggregate_Node := New_Node (N_Extension_Aggregate, Lparen_Sloc);\n-            Set_Ancestor_Part (Aggregate_Node, Expr_Node);\n             Scan; -- past WITH\n+            if Token = Tok_Delta then\n+               Scan; -- past DELTA\n+               Aggregate_Node := New_Node (N_Delta_Aggregate, Lparen_Sloc);\n+               Set_Expression (Aggregate_Node, Expr_Node);\n+               Expr_Node := Empty;\n+               goto Aggregate;\n+\n+            else\n+               Aggregate_Node := New_Node (N_Extension_Aggregate, Lparen_Sloc);\n+               Set_Ancestor_Part (Aggregate_Node, Expr_Node);\n+            end if;\n \n             --  Deal with WITH NULL RECORD case\n \n@@ -1586,7 +1595,11 @@ package body Ch4 is\n       --  All component associations (positional and named) have been scanned\n \n       T_Right_Paren;\n-      Set_Expressions (Aggregate_Node, Expr_List);\n+\n+      if Nkind (Aggregate_Node) /= N_Delta_Aggregate then\n+         Set_Expressions (Aggregate_Node, Expr_List);\n+      end if;\n+\n       Set_Component_Associations (Aggregate_Node, Assoc_List);\n       return Aggregate_Node;\n    end P_Aggregate_Or_Paren_Expr;\n@@ -1622,6 +1635,10 @@ package body Ch4 is\n       Assoc_Node : Node_Id;\n \n    begin\n+      if Token = Tok_For then\n+         return P_Iterated_Component_Association;\n+      end if;\n+\n       Assoc_Node := New_Node (N_Component_Association, Token_Ptr);\n       Set_Choices (Assoc_Node, P_Discrete_Choice_List);\n       Set_Sloc (Assoc_Node, Token_Ptr);"}, {"sha": "11b6542e54d178148f67921be1fcbc2155dc6f41", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -338,10 +338,10 @@ package body Ch9 is\n          Decl_Sloc := Token_Ptr;\n \n          if Token = Tok_Pragma then\n-            Append (P_Pragma, Items);\n+            P_Pragmas_Opt (Items);\n \n-         --  Ada 2005 (AI-397): Reserved words NOT and OVERRIDING\n-         --  may begin an entry declaration.\n+         --  Ada 2005 (AI-397): Reserved words NOT and OVERRIDING may begin an\n+         --  entry declaration.\n \n          elsif Token = Tok_Entry\n            or else Token = Tok_Not\n@@ -350,8 +350,9 @@ package body Ch9 is\n             Append (P_Entry_Declaration, Items);\n \n          elsif Token = Tok_For then\n-            --  Representation clause in task declaration. The only rep\n-            --  clause which is legal in a protected is an address clause,\n+\n+            --  Representation clause in task declaration. The only rep clause\n+            --  which is legal in a protected declaration is an address clause,\n             --  so that is what we try to scan out.\n \n             Item_Node := P_Representation_Clause;\n@@ -617,8 +618,10 @@ package body Ch9 is\n    --  Error recovery: cannot raise Error_Resync\n \n    function P_Protected_Definition return Node_Id is\n-      Def_Node  : Node_Id;\n-      Item_Node : Node_Id;\n+      Def_Node   : Node_Id;\n+      Item_Node  : Node_Id;\n+      Priv_Decls : List_Id;\n+      Vis_Decls  : List_Id;\n \n    begin\n       Def_Node := New_Node (N_Protected_Definition, Token_Ptr);\n@@ -631,33 +634,63 @@ package body Ch9 is\n \n       --  Loop to scan visible declarations (protected operation declarations)\n \n-      Set_Visible_Declarations (Def_Node, New_List);\n+      Vis_Decls := New_List;\n+      Set_Visible_Declarations (Def_Node, Vis_Decls);\n+\n+      --  Flag and discard all pragmas which cannot appear in the protected\n+      --  definition. Note that certain pragmas are still allowed as long as\n+      --  they apply to entries, entry families, or protected subprograms.\n+\n+      P_Pragmas_Opt (Vis_Decls);\n \n       loop\n          Item_Node := P_Protected_Operation_Declaration_Opt;\n+\n+         if Present (Item_Node) then\n+            Append (Item_Node, Vis_Decls);\n+         end if;\n+\n+         P_Pragmas_Opt (Vis_Decls);\n+\n          exit when No (Item_Node);\n-         Append (Item_Node, Visible_Declarations (Def_Node));\n       end loop;\n \n       --  Deal with PRIVATE part (including graceful handling of multiple\n       --  PRIVATE parts).\n \n       Private_Loop : while Token = Tok_Private loop\n-         if No (Private_Declarations (Def_Node)) then\n-            Set_Private_Declarations (Def_Node, New_List);\n-         else\n+         Priv_Decls := Private_Declarations (Def_Node);\n+\n+         if Present (Priv_Decls) then\n             Error_Msg_SC (\"duplicate private part\");\n+         else\n+            Priv_Decls := New_List;\n+            Set_Private_Declarations (Def_Node, Priv_Decls);\n          end if;\n \n          Scan; -- past PRIVATE\n \n+         --  Flag and discard all pragmas which cannot appear in the protected\n+         --  definition. Note that certain pragmas are still allowed as long as\n+         --  they apply to entries, entry families, or protected subprograms.\n+\n+         P_Pragmas_Opt (Priv_Decls);\n+\n          Declaration_Loop : loop\n             if Token = Tok_Identifier then\n-               P_Component_Items (Private_Declarations (Def_Node));\n+               P_Component_Items (Priv_Decls);\n+               P_Pragmas_Opt (Priv_Decls);\n+\n             else\n                Item_Node := P_Protected_Operation_Declaration_Opt;\n+\n+               if Present (Item_Node) then\n+                  Append (Item_Node, Priv_Decls);\n+               end if;\n+\n+               P_Pragmas_Opt (Priv_Decls);\n+\n                exit Declaration_Loop when No (Item_Node);\n-               Append (Item_Node, Private_Declarations (Def_Node));\n             end if;\n          end loop Declaration_Loop;\n       end loop Private_Loop;"}, {"sha": "ae09cc8e43bd76b83b3cefd0b3f8c2518cd8379a", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -1613,7 +1613,7 @@ package body Scng is\n \n          when '@' =>\n             if Ada_Version < Ada_2020 then\n-               Error_Illegal_Character;\n+               Error_Msg (\"target_name is an Ada2020 feature\", Scan_Ptr);\n                Scan_Ptr := Scan_Ptr + 1;\n \n             else"}, {"sha": "bae89ad5ad11a5d50e7e4f14cb74867ff727aa85", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -196,6 +196,9 @@ package body Sem is\n          when N_Delay_Relative_Statement =>\n             Analyze_Delay_Relative (N);\n \n+         when N_Delta_Aggregate =>\n+            Analyze_Aggregate (N);\n+\n          when N_Delay_Until_Statement =>\n             Analyze_Delay_Until (N);\n "}, {"sha": "65d586da32afa785ea53ea2b4a3adb5bee49eac5", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 150, "deletions": 4, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -1678,10 +1678,16 @@ package body Sem_Aggr is\n          Set_Etype  (Ent, Standard_Void_Type);\n          Set_Parent (Ent, Parent (N));\n \n-         Enter_Name (Id);\n-         Set_Etype (Id, Index_Typ);\n-         Set_Ekind (Id, E_Variable);\n-         Set_Scope (Id, Ent);\n+         --  Decorate the index variable in the current scope. The association\n+         --  may have several choices, each one leading to a loop, so we create\n+         --  this variable only once to prevent homonyms in this scope.\n+\n+         if No (Scope (Id)) then\n+            Enter_Name (Id);\n+            Set_Etype (Id, Index_Typ);\n+            Set_Ekind (Id, E_Variable);\n+            Set_Scope (Id, Ent);\n+         end if;\n \n          Push_Scope (Ent);\n          Dummy := Resolve_Aggr_Expr (Expression (N), False);\n@@ -2082,6 +2088,9 @@ package body Sem_Aggr is\n                      return Failure;\n                   end if;\n \n+               elsif Nkind (Assoc) = N_Iterated_Component_Association then\n+                  null;   --  handled above, in a loop context.\n+\n                elsif not Resolve_Aggr_Expr\n                            (Expression (Assoc), Single_Elmt => Single_Choice)\n                then\n@@ -2726,6 +2735,143 @@ package body Sem_Aggr is\n       return Success;\n    end Resolve_Array_Aggregate;\n \n+   -----------------------------\n+   -- Resolve_Delta_Aggregate --\n+   -----------------------------\n+\n+   procedure Resolve_Delta_Aggregate (N : Node_Id; Typ : Entity_Id) is\n+      Base       : constant Node_Id   := Expression (N);\n+      Deltas     : constant List_Id   := Component_Associations (N);\n+      Assoc      : Node_Id;\n+      Choice     : Node_Id;\n+      Comp_Type  : Entity_Id;\n+      Index_Type : Entity_Id;\n+\n+      function Get_Component_Type (Nam : Node_Id) return Entity_Id;\n+\n+      ------------------------\n+      -- Get_Component_Type --\n+      ------------------------\n+\n+      function Get_Component_Type (Nam : Node_Id) return Entity_Id is\n+         Comp : Entity_Id;\n+\n+      begin\n+         Comp := First_Entity (Typ);\n+\n+         while Present (Comp) loop\n+            if Chars (Comp) = Chars (Nam) then\n+               if Ekind (Comp) = E_Discriminant then\n+                  Error_Msg_N (\"delta cannot apply to discriminant\", Nam);\n+               end if;\n+\n+               return Etype (Comp);\n+            end if;\n+\n+            Comp := Next_Entity (Comp);\n+         end loop;\n+\n+         Error_Msg_NE (\"type& has no component with this name\", Nam, Typ);\n+         return Any_Type;\n+      end Get_Component_Type;\n+\n+   begin\n+      if not Is_Composite_Type (Typ) then\n+         Error_Msg_N (\"not a composite type\", N);\n+      end if;\n+\n+      Analyze_And_Resolve (Base, Typ);\n+      if Is_Array_Type (Typ) then\n+         Index_Type := Etype (First_Index (Typ));\n+         Assoc := First (Deltas);\n+         while Present (Assoc) loop\n+            if Nkind (Assoc) = N_Iterated_Component_Association then\n+               Choice := First (Choice_List (Assoc));\n+               while Present (Choice) loop\n+                  if Nkind (Choice) = N_Others_Choice then\n+                     Error_Msg_N\n+                       (\"others not allowed in delta aggregate\", Choice);\n+\n+                  else\n+                     Analyze_And_Resolve (Choice, Index_Type);\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+\n+               declare\n+                  Id  : constant Entity_Id  := Defining_Identifier (Assoc);\n+                  Ent : constant Entity_Id  :=\n+                    New_Internal_Entity\n+                      (E_Loop, Current_Scope, Sloc (Assoc), 'L');\n+\n+               begin\n+                  Set_Etype  (Ent, Standard_Void_Type);\n+                  Set_Parent (Ent, Assoc);\n+\n+                  if No (Scope (Id)) then\n+                     Enter_Name (Id);\n+                     Set_Etype (Id, Index_Type);\n+                     Set_Ekind (Id, E_Variable);\n+                     Set_Scope (Id, Ent);\n+                  end if;\n+\n+                  Push_Scope (Ent);\n+                  Analyze_And_Resolve\n+                    (New_Copy_Tree (Expression (Assoc)), Component_Type (Typ));\n+                  End_Scope;\n+               end;\n+\n+            else\n+               Choice := First (Choice_List (Assoc));\n+               while Present (Choice) loop\n+                  if Nkind (Choice) = N_Others_Choice then\n+                     Error_Msg_N\n+                       (\"others not allowed in delta aggregate\", Choice);\n+\n+                  else\n+                     Analyze (Choice);\n+                     if Is_Entity_Name (Choice)\n+                       and then Is_Type (Entity (Choice))\n+                     then\n+                        --  Choice covers a range of values.\n+                        if Base_Type (Entity (Choice)) /=\n+                           Base_Type (Index_Type)\n+                        then\n+                           Error_Msg_NE (\"choice does mat match index type of\",\n+                             Choice, Typ);\n+                        end if;\n+                     else\n+                        Resolve (Choice, Index_Type);\n+                     end if;\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+\n+               Analyze_And_Resolve (Expression (Assoc), Component_Type (Typ));\n+            end if;\n+\n+            Next (Assoc);\n+         end loop;\n+\n+      else\n+         Assoc := First (Deltas);\n+         while Present (Assoc) loop\n+            Choice := First (Choice_List (Assoc));\n+            while Present (Choice) loop\n+               Comp_Type := Get_Component_Type (Choice);\n+               Next (Choice);\n+            end loop;\n+\n+            Analyze_And_Resolve (Expression (Assoc), Comp_Type);\n+            Next (Assoc);\n+         end loop;\n+      end if;\n+\n+      Set_Etype (N, Typ);\n+   end Resolve_Delta_Aggregate;\n+\n    ---------------------------------\n    -- Resolve_Extension_Aggregate --\n    ---------------------------------"}, {"sha": "8e795291c3641602eb2d5bac289f30e5e3752d4b", "filename": "gcc/ada/sem_aggr.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsem_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsem_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.ads?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,6 +30,7 @@ with Types; use Types;\n \n package Sem_Aggr is\n \n+   procedure Resolve_Delta_Aggregate     (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Aggregate           (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Extension_Aggregate (N : Node_Id; Typ : Entity_Id);\n "}, {"sha": "3d6c39583c84886567680e0cbbb80cca51825116", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -2870,6 +2870,9 @@ package body Sem_Res is\n             when N_Character_Literal =>\n                Resolve_Character_Literal         (N, Ctx_Type);\n \n+            when N_Delta_Aggregate =>\n+               Resolve_Delta_Aggregate           (N, Ctx_Type);\n+\n             when N_Expanded_Name =>\n                Resolve_Entity_Name               (N, Ctx_Type);\n "}, {"sha": "fc88da8e0120f2612d8adae99e27c4f06f5caf3f", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -466,6 +466,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Aggregate\n+        or else NT (N).Nkind = N_Delta_Aggregate\n         or else NT (N).Nkind = N_Extension_Aggregate);\n       return List2 (N);\n    end Component_Associations;\n@@ -1265,6 +1266,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Component_Declaration\n         or else NT (N).Nkind = N_Delay_Relative_Statement\n         or else NT (N).Nkind = N_Delay_Until_Statement\n+        or else NT (N).Nkind = N_Delta_Aggregate\n         or else NT (N).Nkind = N_Discriminant_Association\n         or else NT (N).Nkind = N_Discriminant_Specification\n         or else NT (N).Nkind = N_Exception_Declaration\n@@ -3775,6 +3777,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Aggregate\n+        or else NT (N).Nkind = N_Delta_Aggregate\n         or else NT (N).Nkind = N_Extension_Aggregate);\n       Set_List2_With_Parent (N, Val);\n    end Set_Component_Associations;\n@@ -4565,6 +4568,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Component_Declaration\n         or else NT (N).Nkind = N_Delay_Relative_Statement\n         or else NT (N).Nkind = N_Delay_Until_Statement\n+        or else NT (N).Nkind = N_Delta_Aggregate\n         or else NT (N).Nkind = N_Discriminant_Association\n         or else NT (N).Nkind = N_Discriminant_Specification\n         or else NT (N).Nkind = N_Exception_Declaration"}, {"sha": "69f283759b52bec610ee7a9813790cae8a4a4608", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -4133,6 +4133,15 @@ package Sinfo is\n       --  Note that Box_Present is always False, but it is intentionally added\n       --  for completeness.\n \n+      ----------------------------\n+      --  4.3.4 Delta Aggregate --\n+      ----------------------------\n+\n+      --  N_Delta_Aggregate\n+      --  Sloc points to left parenthesis\n+      --  Expression (Node3)\n+      --  Component_Associations (List2)\n+\n       --------------------------------------------------\n       -- 4.4  Expression/Relation/Term/Factor/Primary --\n       --------------------------------------------------\n@@ -8475,6 +8484,7 @@ package Sinfo is\n       N_Aggregate,\n       N_Allocator,\n       N_Case_Expression,\n+      N_Delta_Aggregate,\n       N_Extension_Aggregate,\n       N_Raise_Expression,\n       N_Range,\n@@ -11524,6 +11534,13 @@ package Sinfo is\n         4 => True,    --  Discrete_Choices (List4)\n         5 => False),  --  unused\n \n+     N_Delta_Aggregate =>\n+       (1 => False,   --  Expressions (List1)\n+        2 => True,    --  Component_Associations (List2)\n+        3 => True,    --  Expression (Node3)\n+        4 => False,   --  Unused\n+        5 => False),  --  Etype (Node5-Sem)\n+\n      N_Extension_Aggregate =>\n        (1 => True,    --  Expressions (List1)\n         2 => True,    --  Component_Associations (List2)"}, {"sha": "f10ff039f8daeaba5469982419b34837340f6efc", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=9eb8d5b4e9cfb5771f333abe0bfdd9667e56537b", "patch": "@@ -1775,6 +1775,13 @@ package body Sprint is\n                Write_Indent_Str (\";\");\n             end if;\n \n+         when N_Delta_Aggregate =>\n+            Write_Str_With_Col_Check_Sloc (\"(\");\n+            Sprint_Node (Expression (Node));\n+            Write_Str_With_Col_Check (\" with delta \");\n+            Sprint_Comma_List (Component_Associations (Node));\n+            Write_Char (')');\n+\n          when N_Extension_Aggregate =>\n             Write_Str_With_Col_Check_Sloc (\"(\");\n             Sprint_Node (Ancestor_Part (Node));"}]}