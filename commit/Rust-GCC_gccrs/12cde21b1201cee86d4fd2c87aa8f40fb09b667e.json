{"sha": "12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjZGUyMWIxMjAxY2VlODZkNGZkMmM4N2FhOGY0MGZiMDliNjY3ZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-10-06T04:22:42Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-10-06T04:22:42Z"}, "message": "re PR libstdc++/17780 (std::allocator vs. static init)\n\n\n2004-10-05  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/17780\n\t* include/ext/mt_allocator.h (__pool_base::_Tune): Add default\n\toptions as compile-time constant enums.\n\t(__pool_base::_Tune::is_default): New.\n\t(__pool_base::_Block_address): New.\n\t(__pool_base): Rearrange data members.\n\t(__pool::_M_reserve_memory): To _M_reserve_block.\n\t(__pool::_M_reclaim_memory): To _M_reclaim_block.\n\t(__pool::_Bin_record): Add _Block_address data member.\n\t(__pool<false>): Add _M_thread_freelist_initial.\n\t(__pool::~__pool): Declare.\n\t(__common_pool_policy): Move static data member to...\n\t(__common_pool_policy::_S_get_pool): ...here, make static local.\n\t(__per_type_pool_policy): Move static data member to...\n\t(__per_type_pool_policy::_S_get_pool): ...here, make static local.\n\t(__mt_alloc::__mt_alloc): Call __policy_type::_S_get_pool.\n\tRemove static member definitions. Use define for __default_policy.\n\t* src/mt_allocator.cc: Same.\n\t* config/linker-map.gnu: Don't export _S_get_pool. Renames.\n\t* testsuite/ext/new_allocator: New.\n\t* testsuite/ext/new_allocator/instantiate.cc: New.\n\t* testsuite/ext/new_allocator/check_new.cc: New.\n\t* testsuite/ext/new_allocator/deallocate_global.cc: New.\n\t* testsuite/ext/new_allocator/deallocate_local.cc: New.\n\t* testsuite/ext/mt_allocator/instantiate.cc: Instantiate all\n\ttemplate arguments.\n\t* testsuite/ext/mt_allocator/deallocate_global-1.cc: New.\n\t* testsuite/ext/mt_allocator/deallocate_global-2.cc: New.\n\t* testsuite/ext/mt_allocator/deallocate_global-3.cc: New.\n\t* testsuite/ext/mt_allocator/deallocate_global-4.cc: New.\n\t* testsuite/ext/mt_allocator/deallocate_local-1.cc: New.\n\t* testsuite/ext/mt_allocator/deallocate_local-2.cc: New.\n\t* testsuite/ext/mt_allocator/deallocate_local-3.cc: New.\n\t* testsuite/ext/mt_allocator/deallocate_local-4.cc: New.\n\t* testsuite/ext/mt_allocator/deallocate.cc: New.\n\t* testsuite/ext/malloc_allocator/deallocate.cc: New.\n\t* testsuite/ext/malloc_allocator/deallocate_global.cc: New.\n\t* testsuite/ext/malloc_allocator/deallocate_local.cc: New.\n\nFrom-SVN: r88589", "tree": {"sha": "337086b8283d037310840150a3c1b468e056007b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/337086b8283d037310840150a3c1b468e056007b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/comments", "author": null, "committer": null, "parents": [{"sha": "743eeb5a817d2557e813a65b3fc49ac92714c49c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/743eeb5a817d2557e813a65b3fc49ac92714c49c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/743eeb5a817d2557e813a65b3fc49ac92714c49c"}], "stats": {"total": 1596, "additions": 1350, "deletions": 246}, "files": [{"sha": "e26f127670e176b93fc71c82bc6e5c3c86fc6d31", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -1,3 +1,44 @@\n+2004-10-05  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/17780\n+\t* include/ext/mt_allocator.h (__pool_base::_Tune): Add default\n+\toptions as compile-time constant enums.\n+\t(__pool_base::_Tune::is_default): New.\n+\t(__pool_base::_Block_address): New.\n+\t(__pool_base): Rearrange data members.\n+\t(__pool::_M_reserve_memory): To _M_reserve_block.\n+\t(__pool::_M_reclaim_memory): To _M_reclaim_block.\t\n+\t(__pool::_Bin_record): Add _Block_address data member.\n+\t(__pool<false>): Add _M_thread_freelist_initial.\n+\t(__pool::~__pool): Declare.\t\n+\t(__common_pool_policy): Move static data member to...\n+\t(__common_pool_policy::_S_get_pool): ...here, make static local.\n+\t(__per_type_pool_policy): Move static data member to...\n+\t(__per_type_pool_policy::_S_get_pool): ...here, make static local.\n+\t(__mt_alloc::__mt_alloc): Call __policy_type::_S_get_pool.\n+\tRemove static member definitions. Use define for __default_policy.\n+\t* src/mt_allocator.cc: Same.\n+\t* config/linker-map.gnu: Don't export _S_get_pool. Renames.\n+\t* testsuite/ext/new_allocator: New.\n+\t* testsuite/ext/new_allocator/instantiate.cc: New.\n+\t* testsuite/ext/new_allocator/check_new.cc: New.\n+\t* testsuite/ext/new_allocator/deallocate_global.cc: New.\n+\t* testsuite/ext/new_allocator/deallocate_local.cc: New.\n+\t* testsuite/ext/mt_allocator/instantiate.cc: Instantiate all\n+\ttemplate arguments.\n+\t* testsuite/ext/mt_allocator/deallocate_global-1.cc: New.\n+\t* testsuite/ext/mt_allocator/deallocate_global-2.cc: New.\n+\t* testsuite/ext/mt_allocator/deallocate_global-3.cc: New.\n+\t* testsuite/ext/mt_allocator/deallocate_global-4.cc: New.\n+\t* testsuite/ext/mt_allocator/deallocate_local-1.cc: New.\n+\t* testsuite/ext/mt_allocator/deallocate_local-2.cc: New.\n+\t* testsuite/ext/mt_allocator/deallocate_local-3.cc: New.\n+\t* testsuite/ext/mt_allocator/deallocate_local-4.cc: New.\n+\t* testsuite/ext/mt_allocator/deallocate.cc: New.\n+\t* testsuite/ext/malloc_allocator/deallocate.cc: New.\t\n+\t* testsuite/ext/malloc_allocator/deallocate_global.cc: New.\n+\t* testsuite/ext/malloc_allocator/deallocate_local.cc: New.\n+\t\n 2004-10-05  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* configure.host (abi_baseline_pair): Define for s390-*-linux* and"}, {"sha": "f6861c87b6fd74cbfddd1bb17e66489c772b61d4", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -267,9 +267,9 @@ GLIBCXX_3.4.3 {\n     _ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE;\n     _ZN9__gnu_cxx6__poolILb1EE21_M_destroy_thread_keyEPv;\n     _ZN9__gnu_cxx6__poolILb1EE16_M_get_thread_idEv;\n-    _ZN9__gnu_cxx6__poolILb[01]EE17_M_reserve_memoryE[jm][jm];\n-    _ZN9__gnu_cxx6__poolILb[01]EE17_M_reclaim_memoryEPc[jm];\n-    _ZN9__gnu_cxx20__common_pool_policyILb[01]EE11_S_get_poolEv;\n+    _ZN9__gnu_cxx6__poolILb[01]EE16_M_reserve_blockE[jm][jm];\n+    _ZN9__gnu_cxx6__poolILb[01]EE16_M_reclaim_blockEPc[jm];\n+    _ZN9__gnu_cxx6__poolILb[01]EED[12]Ev;\n  \n     # stub functions from libmath\n     acosf;"}, {"sha": "f377d4071c728b8d919161492b7f6038e90b3344", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 120, "deletions": 79, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -56,17 +56,28 @@ namespace __gnu_cxx\n   typedef void (*__destroy_handler)(void*);\n   typedef void (*__create_handler)(void);\n \n-  class __pool_base\n+  struct __pool_base\n   {\n-  public:\n+    // Using short int as type for the binmap implies we are never\n+    // caching blocks larger than 65535 with this allocator.\n+    typedef unsigned short int _Binmap_type;\n+\n     // Variables used to configure the behavior of the allocator,\n     // assigned and explained in detail below.\n     struct _Tune\n     {\n+      // Compile time constants for the default _Tune values.\n+      enum { _S_align = 8 };\n+      enum { _S_max_bytes = 128 };\n+      enum { _S_min_bin = 8 };\n+      enum { _S_chunk_size = 4096 - 4 * sizeof(void*) };\n+      enum { _S_max_threads = 4096 };\n+      enum { _S_freelist_headroom = 10 };\n+\n       // Alignment needed.\n       // NB: In any case must be >= sizeof(_Block_record), that\n       // is 4 on 32 bit machines and 8 on 64 bit machines.\n-      size_t  _M_align;\n+      size_t\t_M_align;\n       \n       // Allocation requests (after round-up to power of 2) below\n       // this value will be handled by the allocator. A raw new/\n@@ -75,14 +86,14 @@ namespace __gnu_cxx\n       \n       // Size in bytes of the smallest bin.\n       // NB: Must be a power of 2 and >= _M_align.\n-      size_t  _M_min_bin;\n+      size_t\t_M_min_bin;\n       \n       // In order to avoid fragmenting and minimize the number of\n       // new() calls we always request new memory using this\n       // value. Based on previous discussions on the libstdc++\n       // mailing list we have choosen the value below.\n       // See http://gcc.gnu.org/ml/libstdc++/2001-07/msg00077.html\n-      size_t \t_M_chunk_size;\n+      size_t\t_M_chunk_size;\n       \n       // The maximum number of supported threads. For\n       // single-threaded operation, use one. Maximum values will\n@@ -105,9 +116,9 @@ namespace __gnu_cxx\n       \n       explicit\n       _Tune()\n-      : _M_align(8), _M_max_bytes(128), _M_min_bin(8),\n-      _M_chunk_size(4096 - 4 * sizeof(void*)), \n-      _M_max_threads(4096), _M_freelist_headroom(10), \n+      : _M_align(_S_align), _M_max_bytes(_S_max_bytes), _M_min_bin(_S_min_bin),\n+      _M_chunk_size(_S_chunk_size), _M_max_threads(_S_max_threads), \n+      _M_freelist_headroom(_S_freelist_headroom), \n       _M_force_new(getenv(\"GLIBCXX_FORCE_NEW\") ? true : false)\n       { }\n \n@@ -118,6 +129,25 @@ namespace __gnu_cxx\n       _M_chunk_size(__chunk), _M_max_threads(__maxthreads),\n       _M_freelist_headroom(__headroom), _M_force_new(__force)\n       { }\n+      \n+      bool\n+      is_default() const\n+      {\n+\tbool __ret = true;\n+\t__ret &= _M_align == _S_align;\n+\t__ret &= _M_max_bytes == _S_max_bytes;\n+\t__ret &= _M_min_bin == _S_min_bin;\n+\t__ret &= _M_chunk_size == _S_chunk_size;\n+\t__ret &= _M_max_threads == _S_max_threads;\n+\t__ret &= _M_freelist_headroom == _S_freelist_headroom;\n+\treturn __ret;\n+      }\n+    };\n+    \n+    struct _Block_address\n+    {\n+      void* \t\t\t_M_initial;\n+      _Block_address* \t\t_M_next;\n     };\n     \n     const _Tune&\n@@ -140,20 +170,17 @@ namespace __gnu_cxx\n     { return _M_binmap[__bytes]; }\n \n     explicit __pool_base() \n-    : _M_init(false), _M_options(_Tune()), _M_binmap(NULL) { }\n+    : _M_options(_Tune()), _M_binmap(NULL), _M_init(false) { }\n \n   protected:\n-    // We need to create the initial lists and set up some variables\n-    // before we can answer to the first request for memory.\n-    bool \t\t\t_M_init;\n-    \n     // Configuration options.\n     _Tune \t       \t\t_M_options;\n     \n-    // Using short int as type for the binmap implies we are never\n-    // caching blocks larger than 65535 with this allocator.\n-    typedef unsigned short int  _Binmap_type;\n     _Binmap_type* \t\t_M_binmap;\n+\n+    // We need to create the initial lists and set up some variables\n+    // before we can answer to the first request for memory.\n+    bool \t\t\t_M_init;\n   };\n \n   // Data describing the underlying memory pool, parameterized on\n@@ -204,10 +231,13 @@ namespace __gnu_cxx\n       struct _Bin_record\n       {\n \t// An \"array\" of pointers to the first free block for each\n-\t// thread id. Memory to this \"array\" is allocated in _S_initialize()\n-\t// for _S_max_threads + global pool 0.\n+\t// thread id. Memory to this \"array\" is allocated in\n+\t// _S_initialize() for _S_max_threads + global pool 0.\n \t_Block_record** volatile        _M_first;\n \t\n+\t// A list of the initial addresses of all allocated blocks.\n+\t_Block_address*\t\t     \t_M_address;\n+\n \t// An \"array\" of counters used to keep track of the amount of\n \t// blocks that are on the freelist/used for each thread id.\n \t// Memory to these \"arrays\" is allocated in _S_initialize() for\n@@ -242,10 +272,10 @@ namespace __gnu_cxx\n       }\n \n       char* \n-      _M_reserve_memory(size_t __bytes, const size_t __thread_id);\n+      _M_reserve_block(size_t __bytes, const size_t __thread_id);\n     \n       void\n-      _M_reclaim_memory(char* __p, size_t __bytes);\n+      _M_reclaim_block(char* __p, size_t __bytes);\n     \n       const _Bin_record&\n       _M_get_bin(size_t __which)\n@@ -277,6 +307,8 @@ namespace __gnu_cxx\n \t_M_once = __tmp;\n       }\n \n+      ~__pool();\n+\n     private:\n       // An \"array\" of bin_records each of which represents a specific\n       // power of 2 size. Memory to this \"array\" is allocated in\n@@ -289,6 +321,7 @@ namespace __gnu_cxx\n       __gthread_once_t \t\t_M_once;\n       \n       _Thread_record* \t\t_M_thread_freelist;\n+      void*\t\t\t_M_thread_freelist_initial;\n     };\n #endif\n \n@@ -302,13 +335,14 @@ namespace __gnu_cxx\n \t// Points to the block_record of the next free block.\n \t_Block_record* volatile         _M_next;\n       };\n-      \n+\n       struct _Bin_record\n       {\n-\t// An \"array\" of pointers to the first free block for each\n-\t// thread id. Memory to this \"array\" is allocated in _S_initialize()\n-\t// for _S_max_threads + global pool 0.\n+\t// An \"array\" of pointers to the first free block.\n \t_Block_record** volatile        _M_first;\n+\n+\t// A list of the initial addresses of all allocated blocks.\n+\t_Block_address*\t\t     \t_M_address;\n       };\n       \n       void\n@@ -319,10 +353,10 @@ namespace __gnu_cxx\n       }\n \n       char* \n-      _M_reserve_memory(size_t __bytes, const size_t __thread_id);\n+      _M_reserve_block(size_t __bytes, const size_t __thread_id);\n     \n       void\n-      _M_reclaim_memory(char* __p, size_t __bytes);\n+      _M_reclaim_block(char* __p, size_t __bytes);\n     \n       size_t \n       _M_get_thread_id() { return 0; }\n@@ -337,7 +371,9 @@ namespace __gnu_cxx\n \n       explicit __pool() \n       : _M_bin(NULL), _M_bin_size(1) { }\n-      \n+\n+      ~__pool();\n+\n     private:\n       // An \"array\" of bin_records each of which represents a specific\n       // power of 2 size. Memory to this \"array\" is allocated in\n@@ -351,10 +387,11 @@ namespace __gnu_cxx\n       _M_initialize();\n   };\n \n-\n   template<bool _Thread>\n     struct __common_pool_policy \n     {\n+      typedef __pool<_Thread> __pool_type;\n+\n       template<typename _Tp1, bool _Thread1 = _Thread>\n         struct _M_rebind;\n \n@@ -366,11 +403,12 @@ namespace __gnu_cxx\n         struct _M_rebind<_Tp1, false>\n         { typedef __common_pool_policy<false> other; };\n \n-      typedef __pool<_Thread> __pool_type;\n-      static __pool_type\t_S_data;\n-\n       static __pool_type&\n-      _S_get_pool();\n+      _S_get_pool()\n+      { \n+\tstatic __pool_type _S_pool;\n+\treturn _S_pool;\n+      }\n \n       static void\n       _S_initialize_once() \n@@ -391,6 +429,8 @@ namespace __gnu_cxx\n   template<>\n     struct __common_pool_policy<true>\n     {\n+      typedef __pool<true> __pool_type;\n+\n       template<typename _Tp1, bool _Thread1 = true>\n         struct _M_rebind;\n \n@@ -402,11 +442,12 @@ namespace __gnu_cxx\n         struct _M_rebind<_Tp1, false>\n         { typedef __common_pool_policy<false> other; };\n \n-      typedef __pool<true> __pool_type;\n-      static __pool_type\t_S_data;\n-\n       static __pool_type&\n-      _S_get_pool();\n+      _S_get_pool()\n+      { \n+\tstatic __pool_type _S_pool;\n+\treturn _S_pool;\n+      }\n \n       static void\n       _S_destroy_thread_key(void* __freelist_pos)\n@@ -429,9 +470,12 @@ namespace __gnu_cxx\n    };\n #endif\n \n+\n   template<typename _Tp, bool _Thread>\n     struct __per_type_pool_policy\n     {\n+      typedef __pool<_Thread> __pool_type;\n+\n       template<typename _Tp1, bool _Thread1 = _Thread>\n         struct _M_rebind;\n \n@@ -443,11 +487,13 @@ namespace __gnu_cxx\n         struct _M_rebind<_Tp1, true>\n         { typedef __per_type_pool_policy<_Tp1, true> other; };\n \n-      typedef __pool<_Thread> __pool_type;\n-      static __pool_type\t_S_data;\n-\n+      // Avoid static initialization ordering issues.\n       static __pool_type&\n-      _S_get_pool( ) { return _S_data; }\n+      _S_get_pool() \n+      { \n+\tstatic __pool_type _S_pool;\n+\treturn _S_pool;\n+      }\n \n       static void\n       _S_initialize_once() \n@@ -461,17 +507,15 @@ namespace __gnu_cxx\n       }\n     };\n \n-  template<typename _Tp, bool _Thread>\n-    __pool<_Thread>\n-    __per_type_pool_policy<_Tp, _Thread>::_S_data;\n-\n   template<typename _Tp>\n     struct __per_type_pool_policy<_Tp, true>;\n \n #ifdef __GTHREADS\n   template<typename _Tp>\n     struct __per_type_pool_policy<_Tp, true>\n     {\n+      typedef __pool<true> __pool_type;\n+\n       template<typename _Tp1, bool _Thread1 = true>\n         struct _M_rebind;\n \n@@ -483,11 +527,13 @@ namespace __gnu_cxx\n         struct _M_rebind<_Tp1, true>\n         { typedef __per_type_pool_policy<_Tp1, true> other; };\n \n-      typedef __pool<true> __pool_type;\n-      static __pool_type\t_S_data;\n-\n+      // Avoid static initialization ordering issues.\n       static __pool_type&\n-      _S_get_pool( ) { return _S_data; }\n+      _S_get_pool( ) \n+      { \n+\tstatic __pool_type _S_pool;\n+\treturn _S_pool;\n+      }\n \n       static void\n       _S_destroy_thread_key(void* __freelist_pos)\n@@ -508,16 +554,6 @@ namespace __gnu_cxx\n \t  }\n       }\n     };\n-\n-  template<typename _Tp>\n-    __pool<true>\n-    __per_type_pool_policy<_Tp, true>::_S_data;\n-#endif\n-\n-#ifdef __GTHREADS\n-  typedef __common_pool_policy<true> __default_policy;\n-#else\n-  typedef __common_pool_policy<false> __default_policy;\n #endif\n \n   template<typename _Tp>\n@@ -554,8 +590,14 @@ namespace __gnu_cxx\n       destroy(pointer __p) { __p->~_Tp(); }\n     };\n \n+#ifdef __GTHREADS\n+#define __default_policy __common_pool_policy<true>\n+#else\n+#define __default_policy __common_pool_policy<false>\n+#endif\n+\n   template<typename _Tp, typename _Poolp = __default_policy>\n-    class __mt_alloc : public __mt_alloc_base<_Tp>,  _Poolp\n+    class __mt_alloc : public __mt_alloc_base<_Tp>, _Poolp\n     {\n     public:\n       typedef size_t                    size_type;\n@@ -575,21 +617,18 @@ namespace __gnu_cxx\n \t  typedef __mt_alloc<_Tp1, pol_type> other;\n \t};\n \n+      // Create pool instance so that order of construction will be\n+      // pool_type first, then allocator. This is necessary for\n+      // correct global and static object construction/destruction.\n       __mt_alloc() throw() \n-      {\n-\t// XXX\n-      }\n+      { __policy_type::_S_get_pool(); }\n \n       __mt_alloc(const __mt_alloc&) throw() \n-      {\n-\t// XXX\n-      }\n+      { __policy_type::_S_get_pool(); }\n \n       template<typename _Tp1, typename _Poolp1>\n         __mt_alloc(const __mt_alloc<_Tp1, _Poolp1>& obj) throw()  \n-        {\n-\t  // XXX\n-\t}\n+        { __policy_type::_S_get_pool(); }\n \n       ~__mt_alloc() throw() { }\n \n@@ -620,38 +659,38 @@ namespace __gnu_cxx\n \n       // Requests larger than _M_max_bytes are handled by new/delete\n       // directly.\n-      __pool_type& __pl = this->_S_get_pool();\n+      __pool_type& __pool = this->_S_get_pool();\n       const size_t __bytes = __n * sizeof(_Tp);\n-      if (__pl._M_check_threshold(__bytes))\n+      if (__pool._M_check_threshold(__bytes))\n \t{\n \t  void* __ret = ::operator new(__bytes);\n \t  return static_cast<_Tp*>(__ret);\n \t}\n \n       // Round up to power of 2 and figure out which bin to use.\n-      const size_t __which = __pl._M_get_binmap(__bytes);\n-      const size_t __thread_id = __pl._M_get_thread_id();\n+      const size_t __which = __pool._M_get_binmap(__bytes);\n+      const size_t __thread_id = __pool._M_get_thread_id();\n       \n       // Find out if we have blocks on our freelist.  If so, go ahead\n       // and use them directly without having to lock anything.\n       char* __c;\n       typedef typename __pool_type::_Bin_record _Bin_record;\n-      const _Bin_record& __bin = __pl._M_get_bin(__which);\n+      const _Bin_record& __bin = __pool._M_get_bin(__which);\n       if (__bin._M_first[__thread_id])\n \t{\n \t  // Already reserved.\n \t  typedef typename __pool_type::_Block_record _Block_record;\n \t  _Block_record* __block = __bin._M_first[__thread_id];\n \t  __bin._M_first[__thread_id] = __bin._M_first[__thread_id]->_M_next;\n \t  \n-\t  __pl._M_adjust_freelist(__bin, __block, __thread_id);\n-\t  const __pool_base::_Tune& __options = __pl._M_get_options();\n+\t  __pool._M_adjust_freelist(__bin, __block, __thread_id);\n+\t  const __pool_base::_Tune& __options = __pool._M_get_options();\n \t  __c = reinterpret_cast<char*>(__block) + __options._M_align;\n \t}\n       else\n \t{\n \t  // Null, reserve.\n-\t  __c = __pl._M_reserve_memory(__bytes, __thread_id);\n+\t  __c = __pool._M_reserve_block(__bytes, __thread_id);\n \t}\n       return static_cast<_Tp*>(static_cast<void*>(__c));\n     }\n@@ -663,12 +702,12 @@ namespace __gnu_cxx\n     {\n       // Requests larger than _M_max_bytes are handled by operators\n       // new/delete directly.\n-      __pool_type& __pl = this->_S_get_pool();\n+      __pool_type& __pool = this->_S_get_pool();\n       const size_t __bytes = __n * sizeof(_Tp);\n-      if (__pl._M_check_threshold(__bytes))\n+      if (__pool._M_check_threshold(__bytes))\n \t::operator delete(__p);\n       else\n-\t__pl._M_reclaim_memory(reinterpret_cast<char*>(__p), __bytes);\n+\t__pool._M_reclaim_block(reinterpret_cast<char*>(__p), __bytes);\n     }\n   \n   template<typename _Tp, typename _Poolp>\n@@ -680,6 +719,8 @@ namespace __gnu_cxx\n     inline bool\n     operator!=(const __mt_alloc<_Tp, _Poolp>&, const __mt_alloc<_Tp, _Poolp>&)\n     { return false; }\n+\n+#undef __default_policy\n } // namespace __gnu_cxx\n \n #endif"}, {"sha": "066726b03679780ad34e4a159ccb669d529aa7c3", "filename": "libstdc++-v3/src/mt_allocator.cc", "status": "modified", "additions": 207, "deletions": 163, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -32,8 +32,8 @@\n //\n \n #include <bits/c++config.h>\n-#include <ext/mt_allocator.h>\n #include <bits/concurrence.h>\n+#include <ext/mt_allocator.h>\n \n namespace __gnu_internal\n {\n@@ -46,18 +46,185 @@ namespace __gnu_internal\n \n namespace __gnu_cxx\n {\n+  __pool<false>::~__pool()\n+  {\n+    if (_M_init && !_M_options._M_force_new)\n+      {\n+\tfor (size_t __n = 0; __n < _M_bin_size; ++__n)\n+\t  {\n+\t    _Bin_record& __bin = _M_bin[__n];\n+\t    while (__bin._M_address)\n+\t      {\n+\t\t_Block_address* __tmp = __bin._M_address->_M_next;\n+\t\t::operator delete(__bin._M_address->_M_initial);\n+\t\tdelete __bin._M_address;\n+\t\t__bin._M_address = __tmp;\n+\t      }\n+\t    delete __bin._M_first;\n+\t  }\n+\tdelete _M_bin;\n+\tdelete _M_binmap;\n+      }\n+  }\n+\n+  void\n+  __pool<false>::_M_reclaim_block(char* __p, size_t __bytes)\n+  {\n+    // Round up to power of 2 and figure out which bin to use.\n+    const size_t __which = _M_binmap[__bytes];\n+    _Bin_record& __bin = _M_bin[__which];\n+\n+    const _Tune& __options = _M_get_options();\n+    char* __c = __p - __options._M_align;\n+    _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n+      \n+    // Single threaded application - return to global pool.\n+    __block->_M_next = __bin._M_first[0];\n+    __bin._M_first[0] = __block;\n+  }\n+\n+  char* \n+  __pool<false>::_M_reserve_block(size_t __bytes, const size_t __thread_id)\n+  {\n+    // Round up to power of 2 and figure out which bin to use.\n+    const size_t __which = _M_binmap[__bytes];\n+    const _Tune& __options = _M_get_options();\n+    const size_t __bin_size = ((__options._M_min_bin << __which) \n+\t\t\t       + __options._M_align);\n+    size_t __block_count = __options._M_chunk_size / __bin_size;\t  \n+\n+    // Get a new block dynamically, set it up for use.\n+    void* __v = ::operator new(__options._M_chunk_size);\n+    _Block_record* __block = static_cast<_Block_record*>(__v);\n+    --__block_count;\n+    _Block_record* __tmp = __block;\n+    while (__block_count-- > 0)\n+      {\n+\tchar* __c = reinterpret_cast<char*>(__tmp) + __bin_size;\n+\t__tmp->_M_next = reinterpret_cast<_Block_record*>(__c);\n+\t__tmp = __tmp->_M_next;\n+      }\n+    __tmp->_M_next = NULL;\n+\n+    // Update _Bin_record fields.\n+    _Bin_record& __bin = _M_bin[__which];\n+    __bin._M_first[__thread_id] = __block->_M_next;\n+    _Block_address* __address = new _Block_address;\n+    __address->_M_initial = __v;\n+    __address->_M_next = __bin._M_address;\n+    __bin._M_address = __address;\n+\n+    // NB: For alignment reasons, we can't use the first _M_align\n+    // bytes, even when sizeof(_Block_record) < _M_align.\n+    return reinterpret_cast<char*>(__block) + __options._M_align;\n+  }\n+\n+  void\n+  __pool<false>::_M_initialize()\n+  {\n+    // _M_force_new must not change after the first allocate(), which\n+    // in turn calls this method, so if it's false, it's false forever\n+    // and we don't need to return here ever again.\n+    if (_M_options._M_force_new) \n+      {\n+\t_M_init = true;\n+\treturn;\n+      }\n+      \n+    // Create the bins.\n+    // Calculate the number of bins required based on _M_max_bytes.\n+    // _M_bin_size is statically-initialized to one.\n+    size_t __bin_size = _M_options._M_min_bin;\n+    while (_M_options._M_max_bytes > __bin_size)\n+      {\n+\t__bin_size <<= 1;\n+\t++_M_bin_size;\n+      }\n+      \n+    // Setup the bin map for quick lookup of the relevant bin.\n+    const size_t __j = (_M_options._M_max_bytes + 1) * sizeof(_Binmap_type);\n+    _M_binmap = static_cast<_Binmap_type*>(::operator new(__j));\n+    _Binmap_type* __bp = _M_binmap;\n+    _Binmap_type __bin_max = _M_options._M_min_bin;\n+    _Binmap_type __bint = 0;\n+    for (_Binmap_type __ct = 0; __ct <= _M_options._M_max_bytes; ++__ct)\n+      {\n+\tif (__ct > __bin_max)\n+\t  {\n+\t    __bin_max <<= 1;\n+\t    ++__bint;\n+\t  }\n+\t*__bp++ = __bint;\n+      }\n+      \n+    // Initialize _M_bin and its members.\n+    void* __v = ::operator new(sizeof(_Bin_record) * _M_bin_size);\n+    _M_bin = static_cast<_Bin_record*>(__v);\n+    for (size_t __n = 0; __n < _M_bin_size; ++__n)\n+      {\n+\t_Bin_record& __bin = _M_bin[__n];\n+\t__v = ::operator new(sizeof(_Block_record*));\n+\t__bin._M_first = static_cast<_Block_record**>(__v);\n+\t__bin._M_first[0] = NULL;\n+\t__bin._M_address = NULL;\n+      }\n+    _M_init = true;\n+  }\n+  \n #ifdef __GTHREADS\n+  __pool<true>::~__pool()\n+  {\n+    if (_M_init && !_M_options._M_force_new)\n+      {\n+\tif (__gthread_active_p())\n+\t  {\n+\t    for (size_t __n = 0; __n < _M_bin_size; ++__n)\n+\t      {\n+\t\t_Bin_record& __bin = _M_bin[__n];\n+\t\twhile (__bin._M_address)\n+\t\t  {\n+\t\t    _Block_address* __tmp = __bin._M_address->_M_next;\n+\t\t    ::operator delete(__bin._M_address->_M_initial);\n+\t\t    delete __bin._M_address;\n+\t\t    __bin._M_address = __tmp;\n+\t\t  }\n+\t\tdelete __bin._M_first;\n+\t\tdelete __bin._M_free;\n+\t\tdelete __bin._M_used;\n+\t\tdelete __bin._M_mutex;\n+\t      }\n+\t    ::operator delete(_M_thread_freelist_initial);\n+\t  }\n+\telse\n+\t  {\n+\t    for (size_t __n = 0; __n < _M_bin_size; ++__n)\n+\t      {\n+\t\t_Bin_record& __bin = _M_bin[__n];\n+\t\twhile (__bin._M_address)\n+\t\t  {\n+\t\t    _Block_address* __tmp = __bin._M_address->_M_next;\n+\t\t    ::operator delete(__bin._M_address->_M_initial);\n+\t\t    delete __bin._M_address;\n+\t\t    __bin._M_address = __tmp;\n+\t\t  }\n+\t\tdelete __bin._M_first;\n+\t      }\n+\t  }\n+\tdelete _M_bin;\n+\tdelete _M_binmap;\n+      }\n+  }\n+\n   void\n-  __pool<true>::_M_reclaim_memory(char* __p, size_t __bytes)\n+  __pool<true>::_M_reclaim_block(char* __p, size_t __bytes)\n   {\n     // Round up to power of 2 and figure out which bin to use.\n     const size_t __which = _M_binmap[__bytes];\n     const _Bin_record& __bin = _M_bin[__which];\n+\n     const _Tune& __options = _M_get_options();\n-    \n     char* __c = __p - __options._M_align;\n     _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n-    \n     if (__gthread_active_p())\n       {\n \t// Calculate the number of records to remove from our freelist:\n@@ -106,38 +273,13 @@ namespace __gnu_cxx\n \t__bin._M_first[0] = __block;\n       }\n   }\n-#endif\n-\n-  void\n-  __pool<false>::_M_reclaim_memory(char* __p, size_t __bytes)\n-  {\n-    // Round up to power of 2 and figure out which bin to use.\n-    const size_t __which = _M_binmap[__bytes];\n-    const _Bin_record& __bin = _M_bin[__which];\n-    const _Tune& __options = _M_get_options();\n-      \n-    char* __c = __p - __options._M_align;\n-    _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n-      \n-    // Single threaded application - return to global pool.\n-    __block->_M_next = __bin._M_first[0];\n-    __bin._M_first[0] = __block;\n-  }\n \n-#ifdef __GTHREADS\n   char* \n-  __pool<true>::_M_reserve_memory(size_t __bytes, const size_t __thread_id)\n+  __pool<true>::_M_reserve_block(size_t __bytes, const size_t __thread_id)\n   {\n     // Round up to power of 2 and figure out which bin to use.\n     const size_t __which = _M_binmap[__bytes];\n-      \n-    // If here, there are no blocks on our freelist.\n     const _Tune& __options = _M_get_options();\n-    _Block_record* __block = NULL;\n-    const _Bin_record& __bin = _M_bin[__which];\n-\n-    // NB: For alignment reasons, we can't use the first _M_align\n-    // bytes, even when sizeof(_Block_record) < _M_align.\n     const size_t __bin_size = ((__options._M_min_bin << __which)\n \t\t\t       + __options._M_align);\n     size_t __block_count = __options._M_chunk_size / __bin_size;\t  \n@@ -152,19 +294,17 @@ namespace __gnu_cxx\n     //   no need to lock or change ownership but check for free\n     //   blocks on global list (and if not add new ones) and\n     //   get the first one.\n+    _Bin_record& __bin = _M_bin[__which];\n+    _Block_record* __block = NULL;\n     if (__gthread_active_p())\n       {\n-\t__gthread_mutex_lock(__bin._M_mutex);\n \tif (__bin._M_first[0] == NULL)\n \t  {\n-\t    // No need to hold the lock when we are adding a\n-\t    // whole chunk to our own list.\n-\t    __gthread_mutex_unlock(__bin._M_mutex);\n-\t    \n+\t    // No need to hold the lock when we are adding a whole\n+\t    // chunk to our own list.\n \t    void* __v = ::operator new(__options._M_chunk_size);\n \t    __bin._M_first[__thread_id] = static_cast<_Block_record*>(__v);\n \t    __bin._M_free[__thread_id] = __block_count;\n-\t    \n \t    --__block_count;\n \t    __block = __bin._M_first[__thread_id];\n \t    while (__block_count-- > 0)\n@@ -174,12 +314,20 @@ namespace __gnu_cxx\n \t\t__block = __block->_M_next;\n \t      }\n \t    __block->_M_next = NULL;\n+\n+\t    __gthread_mutex_lock(__bin._M_mutex);\n+\t    _Block_address* __address = new _Block_address;\n+\t    __address->_M_initial = __v;\n+\t    __address->_M_next = __bin._M_address;\n+\t    __bin._M_address = __address;\n+\t    __gthread_mutex_unlock(__bin._M_mutex);\n \t  }\n \telse\n \t  {\n-\t    // Is the number of required blocks greater than or\n-\t    // equal to the number that can be provided by the\n-\t    // global free list?\n+\t    // Is the number of required blocks greater than or equal\n+\t    // to the number that can be provided by the global free\n+\t    // list?\n+\t    __gthread_mutex_lock(__bin._M_mutex);\n \t    __bin._M_first[__thread_id] = __bin._M_first[0];\n \t    if (__block_count >= __bin._M_free[0])\n \t      {\n@@ -204,17 +352,21 @@ namespace __gnu_cxx\n     else\n       {\n \tvoid* __v = ::operator new(__options._M_chunk_size);\n-\t__bin._M_first[0] = static_cast<_Block_record*>(__v);\n-\t\n+\t__block = static_cast<_Block_record*>(__v);\n+\t__bin._M_first[0] = __block;\n \t--__block_count;\n-\t__block = __bin._M_first[0];\n \twhile (__block_count-- > 0)\n \t  {\n \t    char* __c = reinterpret_cast<char*>(__block) + __bin_size;\n \t    __block->_M_next = reinterpret_cast<_Block_record*>(__c);\n \t    __block = __block->_M_next;\n \t  }\n \t__block->_M_next = NULL;\n+\n+\t_Block_address* __address = new _Block_address;\n+\t__address->_M_initial = __v;\n+\t__address->_M_next = __bin._M_address;\n+\t__bin._M_address = __address;\n       }\n       \n     __block = __bin._M_first[__thread_id];\n@@ -226,53 +378,15 @@ namespace __gnu_cxx\n \t--__bin._M_free[__thread_id];\n \t++__bin._M_used[__thread_id];\n       }\n-    return reinterpret_cast<char*>(__block) + __options._M_align;\n-  }\n-#endif\n \n-  char* \n-  __pool<false>::_M_reserve_memory(size_t __bytes, const size_t __thread_id)\n-  {\n-    // Round up to power of 2 and figure out which bin to use.\n-    const size_t __which = _M_binmap[__bytes];\n-      \n-    // If here, there are no blocks on our freelist.\n-    const _Tune& __options = _M_get_options();\n-    _Block_record* __block = NULL;\n-    const _Bin_record& __bin = _M_bin[__which];\n-    \n     // NB: For alignment reasons, we can't use the first _M_align\n     // bytes, even when sizeof(_Block_record) < _M_align.\n-    const size_t __bin_size = ((__options._M_min_bin << __which) \n-\t\t\t       + __options._M_align);\n-    size_t __block_count = __options._M_chunk_size / __bin_size;\t  \n-\t  \n-    // Not using threads.\n-    void* __v = ::operator new(__options._M_chunk_size);\n-    __bin._M_first[0] = static_cast<_Block_record*>(__v);\n-    \n-    --__block_count;\n-    __block = __bin._M_first[0];\n-    while (__block_count-- > 0)\n-      {\n-\tchar* __c = reinterpret_cast<char*>(__block) + __bin_size;\n-\t__block->_M_next = reinterpret_cast<_Block_record*>(__c);\n-\t__block = __block->_M_next;\n-      }\n-    __block->_M_next = NULL;\n-      \n-    __block = __bin._M_first[__thread_id];\n-    __bin._M_first[__thread_id] = __bin._M_first[__thread_id]->_M_next;\n     return reinterpret_cast<char*>(__block) + __options._M_align;\n   }\n \n-#ifdef __GTHREADS\n  void\n   __pool<true>::_M_initialize(__destroy_handler __d)\n   {\n-    // This method is called on the first allocation (when _M_init\n-    // is still false) to create the bins.\n-    \n     // _M_force_new must not change after the first allocate(),\n     // which in turn calls this method, so if it's false, it's false\n     // forever and we don't need to return here ever again.\n@@ -282,6 +396,7 @@ namespace __gnu_cxx\n \treturn;\n       }\n       \n+    // Create the bins.\n     // Calculate the number of bins required based on _M_max_bytes.\n     // _M_bin_size is statically-initialized to one.\n     size_t __bin_size = _M_options._M_min_bin;\n@@ -294,7 +409,6 @@ namespace __gnu_cxx\n     // Setup the bin map for quick lookup of the relevant bin.\n     const size_t __j = (_M_options._M_max_bytes + 1) * sizeof(_Binmap_type);\n     _M_binmap = static_cast<_Binmap_type*>(::operator new(__j));\n-      \n     _Binmap_type* __bp = _M_binmap;\n     _Binmap_type __bin_max = _M_options._M_min_bin;\n     _Binmap_type __bint = 0;\n@@ -320,6 +434,7 @@ namespace __gnu_cxx\n \tconst size_t __k = sizeof(_Thread_record) * _M_options._M_max_threads;\n \t__v = ::operator new(__k);\n \t_M_thread_freelist = static_cast<_Thread_record*>(__v);\n+\t_M_thread_freelist_initial = __v;\n \t  \n \t// NOTE! The first assignable thread id is 1 since the\n \t// global pool uses id 0\n@@ -345,7 +460,9 @@ namespace __gnu_cxx\n \t    _Bin_record& __bin = _M_bin[__n];\n \t    __v = ::operator new(sizeof(_Block_record*) * __max_threads);\n \t    __bin._M_first = static_cast<_Block_record**>(__v);\n-\t      \n+\n+\t    __bin._M_address = NULL;\n+\n \t    __v = ::operator new(sizeof(size_t) * __max_threads);\n \t    __bin._M_free = static_cast<size_t*>(__v);\n \t      \n@@ -364,9 +481,7 @@ namespace __gnu_cxx\n #else\n \t    { __GTHREAD_MUTEX_INIT_FUNCTION(__bin._M_mutex); }\n #endif\n-\t      \n-\t    for (size_t __threadn = 0; __threadn < __max_threads;\n-\t\t ++__threadn)\n+\t    for (size_t __threadn = 0; __threadn < __max_threads; ++__threadn)\n \t      {\n \t\t__bin._M_first[__threadn] = NULL;\n \t\t__bin._M_free[__threadn] = 0;\n@@ -375,73 +490,19 @@ namespace __gnu_cxx\n \t  }\n       }\n     else\n-      for (size_t __n = 0; __n < _M_bin_size; ++__n)\n-\t{\n-\t  _Bin_record& __bin = _M_bin[__n];\n-\t  __v = ::operator new(sizeof(_Block_record*));\n-\t  __bin._M_first = static_cast<_Block_record**>(__v);\n-\t  __bin._M_first[0] = NULL;\n-\t}\n-    _M_init = true;\n-  }\n-#endif\n-\n-  void\n-  __pool<false>::_M_initialize()\n-  {\n-    // This method is called on the first allocation (when _M_init\n-    // is still false) to create the bins.\n-    \n-    // _M_force_new must not change after the first allocate(),\n-    // which in turn calls this method, so if it's false, it's false\n-    // forever and we don't need to return here ever again.\n-    if (_M_options._M_force_new) \n-      {\n-\t_M_init = true;\n-\treturn;\n-      }\n-      \n-    // Calculate the number of bins required based on _M_max_bytes.\n-    // _M_bin_size is statically-initialized to one.\n-    size_t __bin_size = _M_options._M_min_bin;\n-    while (_M_options._M_max_bytes > __bin_size)\n-      {\n-\t__bin_size <<= 1;\n-\t++_M_bin_size;\n-      }\n-      \n-    // Setup the bin map for quick lookup of the relevant bin.\n-    const size_t __j = (_M_options._M_max_bytes + 1) * sizeof(_Binmap_type);\n-    _M_binmap = static_cast<_Binmap_type*>(::operator new(__j));\n-      \n-    _Binmap_type* __bp = _M_binmap;\n-    _Binmap_type __bin_max = _M_options._M_min_bin;\n-    _Binmap_type __bint = 0;\n-    for (_Binmap_type __ct = 0; __ct <= _M_options._M_max_bytes; ++__ct)\n       {\n-\tif (__ct > __bin_max)\n+\tfor (size_t __n = 0; __n < _M_bin_size; ++__n)\n \t  {\n-\t    __bin_max <<= 1;\n-\t    ++__bint;\n+\t    _Bin_record& __bin = _M_bin[__n];\n+\t    __v = ::operator new(sizeof(_Block_record*));\n+\t    __bin._M_first = static_cast<_Block_record**>(__v);\n+\t    __bin._M_first[0] = NULL;\n+\t    __bin._M_address = NULL;\n \t  }\n-\t*__bp++ = __bint;\n-      }\n-      \n-    // Initialize _M_bin and its members.\n-    void* __v = ::operator new(sizeof(_Bin_record) * _M_bin_size);\n-    _M_bin = static_cast<_Bin_record*>(__v);\n-      \n-    for (size_t __n = 0; __n < _M_bin_size; ++__n)\n-      {\n-\t_Bin_record& __bin = _M_bin[__n];\n-\t__v = ::operator new(sizeof(_Block_record*));\n-\t__bin._M_first = static_cast<_Block_record**>(__v);\n-\t__bin._M_first[0] = NULL;\n       }\n     _M_init = true;\n   }\n-  \n-#ifdef __GTHREADS\n+\n   size_t\n   __pool<true>::_M_get_thread_id()\n   {\n@@ -486,23 +547,6 @@ namespace __gnu_cxx\n   }\n #endif\n \n-  // Definitions for non-exported bits of __common_pool.\n-#ifdef __GTHREADS\n-  __pool<true>\n-  __common_pool_policy<true>::_S_data = __pool<true>();\n-\n-  __pool<true>&\n-  __common_pool_policy<true>::_S_get_pool() { return _S_data; }\n-#endif\n-\n-  template<>\n-    __pool<false>\n-    __common_pool_policy<false>::_S_data = __pool<false>();\n-\n-  template<>\n-    __pool<false>&\n-    __common_pool_policy<false>::_S_get_pool() { return _S_data; }\n-\n   // Instantiations.\n   template class __mt_alloc<char>;\n   template class __mt_alloc<wchar_t>;"}, {"sha": "4b462bf0e04cd1980bee17c77211dece2bc8c999", "filename": "libstdc++-v3/testsuite/ext/malloc_allocator/deallocate_global.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fdeallocate_global.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fdeallocate_global.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fdeallocate_global.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,74 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/malloc_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::malloc_allocator<char_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+string_t s(\"bayou bend\");\n+\n+int main()\n+{\n+  return 0;\n+}"}, {"sha": "69cbb383a0ddfd729ebbc59354cc1dc967a09003", "filename": "libstdc++-v3/testsuite/ext/malloc_allocator/deallocate_local.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fdeallocate_local.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fdeallocate_local.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fdeallocate_local.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,65 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <ext/malloc_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t alloc_cnt;\n+ \n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  alloc_cnt++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  alloc_cnt--;\n+  if (alloc_cnt == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", alloc_cnt);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::malloc_allocator<char_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  {\n+    string_t s;\n+    s += \"bayou bend\";\n+  }\n+  VERIFY( alloc_cnt == 0 );\n+  return 0;\n+}"}, {"sha": "1f0ac281af77a038511f7510a1ad0a699f10282e", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/deallocate_global-1.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-1.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,75 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::__common_pool_policy<true> pool_t;\n+typedef __gnu_cxx::__mt_alloc<char_t, pool_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+string_t s(\"bayou bend\");\n+\n+int main()\n+{\n+  return 0;\n+}"}, {"sha": "f048487298972ebbcd4476b4babbc9b383861e2b", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/deallocate_global-2.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-2.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,75 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::exception();\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::__common_pool_policy<false> pool_t;\n+typedef __gnu_cxx::__mt_alloc<char_t, pool_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+string_t s(\"bayou bend\");\n+\n+int main()\n+{\n+  return 0;\n+}"}, {"sha": "10efea66ec60a73f57490b38e7524dd5466a1c78", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/deallocate_global-3.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-3.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,75 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::__per_type_pool_policy<char_t, true> pool_t;\n+typedef __gnu_cxx::__mt_alloc<char_t, pool_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+string_t s(\"bayou bend\");\n+\n+int main()\n+{\n+  return 0;\n+}"}, {"sha": "02c6a4c4c685104bbfacd4ed46bd92603214f4bb", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/deallocate_global-4.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_global-4.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,75 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::__per_type_pool_policy<char_t, false> pool_t;\n+typedef __gnu_cxx::__mt_alloc<char_t, pool_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+string_t s(\"bayou bend\");\n+\n+int main()\n+{\n+  return 0;\n+}"}, {"sha": "5664d3caff87e068947ca46aa8af1b98f7366e72", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/deallocate_local-1.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-1.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,78 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::__common_pool_policy<true> pool_t;\n+typedef __gnu_cxx::__mt_alloc<char_t, pool_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  {\n+    string_t s;\n+    s += \"bayou bend\";\n+  }\n+  return 0;\n+}"}, {"sha": "a6af89f11f05033a4c82c6d6c6ba23e2d69bf9cf", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/deallocate_local-2.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-2.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,78 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::__common_pool_policy<false> pool_t;\n+typedef __gnu_cxx::__mt_alloc<char_t, pool_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  {\n+    string_t s;\n+    s += \"bayou bend\";\n+  }\n+  return 0;\n+}"}, {"sha": "973f758d98df6945632f6d457049606c48eb0e52", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/deallocate_local-3.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-3.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,78 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::__per_type_pool_policy<char_t, true> pool_t;\n+typedef __gnu_cxx::__mt_alloc<char_t, pool_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  {\n+    string_t s;\n+    s += \"bayou bend\";\n+  }\n+  return 0;\n+}"}, {"sha": "c194b977d577cfb9172f8b5f42b1e97f8eaf9297", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/deallocate_local-4.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fdeallocate_local-4.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,78 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::__per_type_pool_policy<char_t, false> pool_t;\n+typedef __gnu_cxx::__mt_alloc<char_t, pool_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  {\n+    string_t s;\n+    s += \"bayou bend\";\n+  }\n+  return 0;\n+}"}, {"sha": "579b8bcf18dfa86c24bbf3de59fc1ed25ae5eb8a", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/instantiate.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Finstantiate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Finstantiate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Finstantiate.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -25,4 +25,9 @@\n #include <cstdlib>\n #include <ext/mt_allocator.h>\n \n-template class __gnu_cxx::__mt_alloc<int>;\n+using namespace __gnu_cxx;\n+template class __mt_alloc<int>;\n+template class __mt_alloc<short, __common_pool_policy<true> >;\n+template class __mt_alloc<short, __common_pool_policy<false> >;\n+template class __mt_alloc<short, __per_type_pool_policy<short, true> >;\n+template class __mt_alloc<short, __per_type_pool_policy<short, false> >;"}, {"sha": "e2be5743fdba5664735e2101f3b6d613b6c97676", "filename": "libstdc++-v3/testsuite/ext/new_allocator/check_new.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fcheck_new.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fcheck_new.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fcheck_new.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,55 @@\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/new_allocator.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_cxx::new_allocator;\n+\n+void* \n+operator new(std::size_t n) throw(std::bad_alloc)\n+{\n+  new_called = true;\n+  requested = n;\n+  return std::malloc(n);\n+}\n+\n+void\n+operator delete(void *v) throw()\n+{\n+  delete_called = true;\n+  return std::free(v);\n+}\n+\n+// These just help tracking down error messages.\n+bool test01() \n+{ \n+  typedef new_allocator<unsigned int> allocator_type;\n+  return (__gnu_test::check_new<allocator_type, true>() == true); \n+}\n+\n+int main()\n+{\n+  return test01();\n+}\n+"}, {"sha": "6f1451dccf27c6c26b66e11c99d066e6bc56714f", "filename": "libstdc++-v3/testsuite/ext/new_allocator/deallocate_global.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fdeallocate_global.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fdeallocate_global.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fdeallocate_global.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,74 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <stdexcept>\n+#include <ext/new_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t count;\n+\n+struct count_check\n+{\n+  count_check() {}\n+  ~count_check()\n+  {\n+    if (count != 0)\n+      throw std::runtime_error(\"count isn't zero\");\n+  }\n+};\n+ \n+static count_check check;\n+\n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  count++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  count--;\n+  if (count == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", count);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::new_allocator<char_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+string_t s(\"bayou bend\");\n+\n+int main()\n+{\n+  return 0;\n+}"}, {"sha": "bc934c6f9ee74ffbd9f85460d4869209a950171c", "filename": "libstdc++-v3/testsuite/ext/new_allocator/deallocate_local.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fdeallocate_local.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fdeallocate_local.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Fdeallocate_local.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,65 @@\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <string>\n+#include <ext/new_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+static size_t alloc_cnt;\n+ \n+void* operator new(size_t size) throw(std::bad_alloc)\n+{\n+  printf(\"operator new is called \\n\");\n+  void* p = malloc(size);\n+  if (p == NULL)\n+    throw std::bad_alloc();\n+  alloc_cnt++;\n+  return p;\n+}\n+ \n+void operator delete(void* p) throw()\n+{\n+  printf(\"operator delete is called \\n\");\n+  if (p == NULL)\n+    return;\n+  alloc_cnt--;\n+  if (alloc_cnt == 0)\n+    printf(\"All memory released \\n\");\n+  else\n+    printf(\"%u allocations to be released \\n\", alloc_cnt);\n+  free(p);\n+}\n+\n+typedef char char_t;\n+typedef std::char_traits<char_t> traits_t;\n+typedef __gnu_cxx::new_allocator<char_t> allocator_t;\n+typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  {\n+    string_t s;\n+    s += \"bayou bend\";\n+  }\n+  VERIFY( alloc_cnt == 0 );\n+  return 0;\n+}"}, {"sha": "45bd988f315427ab47fa0505afb3819f9f7e6164", "filename": "libstdc++-v3/testsuite/ext/new_allocator/instantiate.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Finstantiate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cde21b1201cee86d4fd2c87aa8f40fb09b667e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Finstantiate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2Finstantiate.cc?ref=12cde21b1201cee86d4fd2c87aa8f40fb09b667e", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/new_allocator.h>\n+\n+template class __gnu_cxx::new_allocator<int>;"}]}