{"sha": "a31895d78b4e9873da76cb58b278e3216ca6fcc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMxODk1ZDc4YjRlOTg3M2RhNzZjYjU4YjI3OGUzMjE2Y2E2ZmNjNw==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-11-01T12:42:01Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-11-01T12:42:01Z"}, "message": "re PR tree-optimization/50908 (building emacs-23.3; gives msg: indent.c:1140:1: internal compiler error: in verify_dominators, at dominance.c:1041)\n\n2011-11-01  Tom de Vries  <tom@codesourcery.com>\n\n\tPR tree-optimization/50908\n\t* tree-ssa-tail-merge.c (update_vuses): Now that edges are removed\n\tbefore update_vuses, test for 1 predecessor rather than two.\n\t(delete_block_update_dominator_info): New function, part of it factored\n\tout of ...\n\t(replace_block_by): Use delete_block_update_dominator_info.  Call\n\tupdate_vuses after deleting bb1 and updating dominator info, instead of\n\tbefore.\n\nFrom-SVN: r180737", "tree": {"sha": "1e0216df9bdefbbf6c0539c7dd654e0c5d8a8081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e0216df9bdefbbf6c0539c7dd654e0c5d8a8081"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a31895d78b4e9873da76cb58b278e3216ca6fcc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31895d78b4e9873da76cb58b278e3216ca6fcc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a31895d78b4e9873da76cb58b278e3216ca6fcc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31895d78b4e9873da76cb58b278e3216ca6fcc7/comments", "author": null, "committer": null, "parents": [{"sha": "eb6a1e56e01872ae6c9f3ae0d912d4787d2cf97b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6a1e56e01872ae6c9f3ae0d912d4787d2cf97b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6a1e56e01872ae6c9f3ae0d912d4787d2cf97b"}], "stats": {"total": 120, "additions": 104, "deletions": 16}, "files": [{"sha": "af01b0e7f947e89d5c2de2e61ad836205e922ede", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31895d78b4e9873da76cb58b278e3216ca6fcc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31895d78b4e9873da76cb58b278e3216ca6fcc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a31895d78b4e9873da76cb58b278e3216ca6fcc7", "patch": "@@ -1,3 +1,14 @@\n+2011-11-01  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/50908\n+\t* tree-ssa-tail-merge.c (update_vuses): Now that edges are removed\n+\tbefore update_vuses, test for 1 predecessor rather than two.\n+\t(delete_block_update_dominator_info): New function, part of it factored\n+\tout of ...\n+\t(replace_block_by): Use delete_block_update_dominator_info.  Call\n+\tupdate_vuses after deleting bb1 and updating dominator info, instead of\n+\tbefore.\n+\n 2011-11-01  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/sparc.c (sparc_expand_vcond): New function."}, {"sha": "17e7f374b05a1ec2b736dc6363908e32326344ed", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 93, "deletions": 16, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31895d78b4e9873da76cb58b278e3216ca6fcc7/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31895d78b4e9873da76cb58b278e3216ca6fcc7/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=a31895d78b4e9873da76cb58b278e3216ca6fcc7", "patch": "@@ -1458,7 +1458,7 @@ update_vuses (bool vuse1_phi_args, tree vuse1, tree vuse2, basic_block bb2,\n \t      if (!dominated_by_p (CDI_DOMINATORS, pred, bb2))\n \t\tcontinue;\n \n-\t      if (pred == bb2 && EDGE_COUNT (gimple_bb (stmt)->preds) == 2)\n+\t      if (pred == bb2 && EDGE_COUNT (gimple_bb (stmt)->preds) == 1)\n \t\t{\n \t\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n \t\t  unlink_virtual_phi (stmt, lhs);\n@@ -1526,6 +1526,88 @@ vop_at_entry (basic_block bb)\n \t  : NULL_TREE);\n }\n \n+/* Given that all incoming edges of BB1 have been redirected to BB2, delete BB1\n+   and recompute dominator info.  */\n+\n+static void\n+delete_block_update_dominator_info (basic_block bb1, basic_block bb2)\n+{\n+  VEC (basic_block,heap) *fix_dom_bb;\n+  unsigned int i;\n+  basic_block bb, dom;\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* Consider the following cfg, where A is the direct dominator of I:\n+\n+                A\n+               / \\\n+              B   \\\n+             / \\   \\\n+                C   D\n+               /|   |\\\n+                E   F\n+                |\\ /|\n+                | x |\n+                |/ \\|\n+                G   H\n+                 \\ /\n+                  I\n+\n+     Say E and F are duplicates, and F is removed.  The cfg then looks like\n+     this:\n+\n+                A\n+               / \\\n+              B   \\\n+             / \\   \\\n+                C   D\n+               / \\ / \\\n+                  E\n+                 / \\\n+                G   H\n+                 \\ /\n+                  I\n+\n+     E is now the new direct dominator of I.\n+\n+     In order to calculate the new dominator info, we take the nearest common\n+     dominator (A) of bb1 (F) and bb2 (E), and get the set of bbs immediately\n+     dominated by it.  Some of this set may now be directly dominated by bb2.\n+\n+     Ideally we would have a means to determine which bbs in the set are now\n+     dominated by bb2, and call set_immediate_dominator for those bbs, but we\n+     don't, so instead we let iterate_fix_dominators figure it out.  */\n+\n+  /* Add bbs immediately dominated by the most common dominator.  */\n+  dom = nearest_common_dominator (CDI_DOMINATORS, bb1, bb2);\n+  fix_dom_bb = get_dominated_by (CDI_DOMINATORS, dom);\n+\n+  if (get_immediate_dominator (CDI_DOMINATORS, bb1) == dom)\n+    for (i = 0; VEC_iterate (basic_block, fix_dom_bb, i, bb); ++i)\n+      {\n+\tif (bb != bb1)\n+\t  continue;\n+\tVEC_unordered_remove (basic_block, fix_dom_bb, i);\n+\tbreak;\n+      }\n+\n+  /* Add bb2, but not twice.  */\n+  if (get_immediate_dominator (CDI_DOMINATORS, bb2) != dom)\n+    VEC_safe_push (basic_block, heap, fix_dom_bb, bb2);\n+  /* Add succs of bb2, but not twice.  */\n+  FOR_EACH_EDGE (e, ei, bb2->succs)\n+    if (get_immediate_dominator (CDI_DOMINATORS, e->dest) != dom)\n+      VEC_safe_push (basic_block, heap, fix_dom_bb, e->dest);\n+\n+  delete_basic_block (bb1);\n+  iterate_fix_dominators (CDI_DOMINATORS, fix_dom_bb, false);\n+#if defined (ENABLE_CHECKING)\n+  verify_dominators (CDI_DOMINATORS);\n+#endif\n+  VEC_free (basic_block, heap, fix_dom_bb);\n+}\n+\n /* Redirect all edges from BB1 to BB2, marks BB1 for removal, and if\n    UPDATE_VOPS, inserts vop phis.  */\n \n@@ -1539,7 +1621,6 @@ replace_block_by (basic_block bb1, basic_block bb2, bool update_vops)\n   edge e;\n   edge_iterator ei;\n   bool vuse1_phi_args = false;\n-  VEC (basic_block,heap) *fix_dom_bb;\n \n   phi_vuse2 = vop_at_entry (bb2);\n   if (phi_vuse2 != NULL_TREE && TREE_CODE (phi_vuse2) != SSA_NAME)\n@@ -1550,7 +1631,8 @@ replace_block_by (basic_block bb1, basic_block bb2, bool update_vops)\n       /* Find the vops at entry of bb1 and bb2.  */\n       phi_vuse1 = vop_at_entry (bb1);\n \n-      /* If both are not found, it means there's no need to update.  */\n+      /* If both are not found, it means there's no need to update.  Uses old\n+\t dominator info.  */\n       if (phi_vuse1 == NULL_TREE && phi_vuse2 == NULL_TREE)\n \tupdate_vops = false;\n       else if (phi_vuse1 == NULL_TREE)\n@@ -1591,25 +1673,20 @@ replace_block_by (basic_block bb1, basic_block bb2, bool update_vops)\n \t\t     pred_edge, UNKNOWN_LOCATION);\n     }\n \n-  /* Update the vops.  */\n+  /* Do updates that use bb1, before deleting bb1.  */\n+  if (!update_vops)\n+    release_last_vdef (bb1);\n+  same_succ_flush_bb (bb1);\n+\n+  delete_block_update_dominator_info (bb1, bb2);\n+\n+  /* Update the vops.  Uses new dominator info.  */\n   if (update_vops)\n     {\n       update_vuses (vuse1_phi_args, phi_vuse1, phi_vuse2, bb2,\n \t\t    redirected_edges);\n       VEC_free (edge, heap, redirected_edges);\n     }\n-  else\n-    release_last_vdef (bb1);\n-\n-  same_succ_flush_bb (bb1);\n-  delete_basic_block (bb1);\n-\n-  fix_dom_bb = VEC_alloc (basic_block, heap, 2);\n-  VEC_safe_push (basic_block, heap, fix_dom_bb, bb2);\n-  FOR_EACH_EDGE (e, ei, bb2->succs)\n-    VEC_safe_push (basic_block, heap, fix_dom_bb, e->dest);\n-  iterate_fix_dominators (CDI_DOMINATORS, fix_dom_bb, false);\n-  VEC_free (basic_block, heap, fix_dom_bb);\n }\n \n /* Bbs for which update_debug_stmt need to be called.  */"}]}