{"sha": "87e11268b6574b6002b6a8b9ba28531e4173273e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlMTEyNjhiNjU3NGI2MDAyYjZhOGI5YmEyODUzMWU0MTczMjczZQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-01-18T08:53:41Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-01-18T08:53:41Z"}, "message": "cpplib.c (special_symbol): Qualify a char* with the `const' keyword.\n\n        * cpplib.c (special_symbol): Qualify a char* with the `const' keyword.\n        Instead of writing to const char *buf directly, use a non-const\n        variable `wbuf' to allocate and write a string, then set buf = wbuf.\n        * cppulp.c (user_label_prefix): Qualify a char* with the `const'\n        keyword.\n        * dyn-string.c (dyn_string_append): Likewise.\n        * dyn-string.h (dyn_string_append): Likewise.\n        * final.c (end_final, output_operand_lossage, asm_fprintf): Likewise.\n        * output.h (end_final, output_operand_lossage, asm_fprintf,\n        named_section, decode_reg_name, make_decl_rtl, user_label_prefix):\n        Likewise.\n        * profile.c (init_branch_prob): Likewise.\n        * toplev.c (set_target_switch, vmessage,\n        v_message_with_file_and_line, v_message_with_decl,\n        v_error_with_file_and_line, v_error_with_decl, v_error_for_asm,\n        verror, vfatal, v_warning_with_file_and_line, v_warning_with_decl,\n        v_warning_for_asm, vwarning, vpedwarn, v_pedwarn_with_decl,\n        v_pedwarn_with_file_and_line, vsorry, v_really_sorry,\n        open_dump_file, dump_rtl, clean_dump_file,\n        print_version, print_single_switch, print_switch_values,\n        dump_base_name, debug_args, lang_independent_options,\n        user_label_prefix, documented_lang_options, target_switches,\n        target_options, print_time, pfatal_with_name, fatal_io_error,\n        fatal_insn, default_print_error_function, print_error_function,\n        report_error_function, error_with_file_and_line, error_with_decl,\n        error_for_asm, error, fatal, warning_with_file_and_line,\n        warning_with_decl, warning_for_asm, warning, pedwarn,\n        pedwarn_with_decl, pedwarn_with_file_and_line, sorry,\n        really_sorry, botch, output_quoted_string, output_file_directive,\n        open_dump_file, rest_of_decl_compilation, display_help, main):\n        Likewise.\n        * toplev.h (print_time, fatal, fatal_io_error, pfatal_with_name,\n        fatal_insn, warning, error, pedwarn, pedwarn_with_file_and_line,\n        warning_with_file_and_line, error_with_file_and_line, sorry,\n        really_sorry, default_print_error_function, report_error_function,\n        rest_of_decl_compilation, pedwarn_with_decl, warning_with_decl,\n        error_with_decl, error_for_asm, warning_for_asm, output_quoted_string,\n        output_file_directive, botch): Likewise.\n        * tree.h (make_decl_rtl): Likewise.\n        * varasm.c (strip_reg_name, named_section, decode_reg_name,\n        make_decl_rtl): Likewise.\n\nFrom-SVN: r24743", "tree": {"sha": "da93e20e14614c525df0a055e8e04e6c1e3306ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da93e20e14614c525df0a055e8e04e6c1e3306ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e11268b6574b6002b6a8b9ba28531e4173273e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e11268b6574b6002b6a8b9ba28531e4173273e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e11268b6574b6002b6a8b9ba28531e4173273e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e11268b6574b6002b6a8b9ba28531e4173273e/comments", "author": null, "committer": null, "parents": [{"sha": "6b106e7db721422dc10e5efed084ffb146a1257e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b106e7db721422dc10e5efed084ffb146a1257e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b106e7db721422dc10e5efed084ffb146a1257e"}], "stats": {"total": 538, "additions": 306, "deletions": 232}, "files": [{"sha": "1ec2ec5cddd59acb82a67b57f385a27402d1e152", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,3 +1,57 @@\n+Mon Jan 18 11:48:28 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cpplib.c (special_symbol): Qualify a char* with the `const' keyword.\n+\tInstead of writing to const char *buf directly, use a non-const\n+ \tvariable `wbuf' to allocate and write a string, then set buf = wbuf.\n+\n+\t* cppulp.c (user_label_prefix): Qualify a char* with the `const'\n+\tkeyword.\n+\n+\t* dyn-string.c (dyn_string_append): Likewise.\n+\n+\t* dyn-string.h (dyn_string_append): Likewise.\n+\n+\t* final.c (end_final, output_operand_lossage, asm_fprintf): Likewise.\n+\n+\t* output.h (end_final, output_operand_lossage, asm_fprintf,\n+\tnamed_section, decode_reg_name, make_decl_rtl, user_label_prefix):\n+\tLikewise.\n+\n+\t* profile.c (init_branch_prob): Likewise.\n+\n+\t* toplev.c (set_target_switch, vmessage,\n+ \tv_message_with_file_and_line, v_message_with_decl,\n+ \tv_error_with_file_and_line, v_error_with_decl, v_error_for_asm,\n+ \tverror, vfatal, v_warning_with_file_and_line, v_warning_with_decl,\n+ \tv_warning_for_asm, vwarning, vpedwarn, v_pedwarn_with_decl,\n+ \tv_pedwarn_with_file_and_line, vsorry, v_really_sorry,\n+\topen_dump_file, dump_rtl, clean_dump_file, \n+\tprint_version, print_single_switch, print_switch_values,\n+\tdump_base_name, debug_args, lang_independent_options,\n+\tuser_label_prefix, documented_lang_options, target_switches,\n+\ttarget_options, print_time, pfatal_with_name, fatal_io_error,\n+\tfatal_insn, default_print_error_function, print_error_function,\n+\treport_error_function, error_with_file_and_line, error_with_decl,\n+\terror_for_asm, error, fatal, warning_with_file_and_line,\n+\twarning_with_decl, warning_for_asm, warning, pedwarn,\n+\tpedwarn_with_decl, pedwarn_with_file_and_line, sorry,\n+\treally_sorry, botch, output_quoted_string, output_file_directive,\n+\topen_dump_file, rest_of_decl_compilation, display_help, main):\n+\tLikewise.\n+\n+\t* toplev.h (print_time, fatal, fatal_io_error, pfatal_with_name,\n+\tfatal_insn, warning, error, pedwarn, pedwarn_with_file_and_line,\n+\twarning_with_file_and_line, error_with_file_and_line, sorry,\n+        really_sorry, default_print_error_function, report_error_function,\n+\trest_of_decl_compilation, pedwarn_with_decl, warning_with_decl,\n+\terror_with_decl, error_for_asm, warning_for_asm, output_quoted_string,\n+\toutput_file_directive, botch): Likewise.\n+\n+\t* tree.h (make_decl_rtl): Likewise.\n+\n+\t* varasm.c (strip_reg_name, named_section, decode_reg_name,\n+\tmake_decl_rtl): Likewise.\n+\t\n Mon Jan 18 11:35:49 1999  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* Makefile.in (TCL_LIBRARY): Use 'cd' to find the library"}, {"sha": "aa343f51d043ede49f0270d1676f0ba77da8500a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -2054,7 +2054,8 @@ special_symbol (hp, pfile)\n      HASHNODE *hp;\n      cpp_reader *pfile;\n {\n-  char *buf;\n+  const char *buf;\n+  char *wbuf;\n   int len;\n   int true_indepth;\n   cpp_buffer *ip = NULL;\n@@ -2108,13 +2109,15 @@ special_symbol (hp, pfile)\n \tif (ip->fname != NULL)\n \t  true_indepth++;\n \n-      buf = (char *) alloca (8); /* Eight bytes ought to be more than enough */\n-      sprintf (buf, \"%d\", true_indepth - 1);\n+      wbuf = (char *) alloca (8); /* Eight bytes ought to be more than enough*/\n+      sprintf (wbuf, \"%d\", true_indepth - 1);\n+      buf = wbuf;\n       break;\n \n   case T_VERSION:\n-      buf = (char *) alloca (3 + strlen (version_string));\n-      sprintf (buf, \"\\\"%s\\\"\", version_string);\n+      wbuf = (char *) alloca (3 + strlen (version_string));\n+      sprintf (wbuf, \"\\\"%s\\\"\", version_string);\n+      buf = wbuf;\n       break;\n \n #ifndef NO_BUILTIN_SIZE_TYPE\n@@ -2142,19 +2145,20 @@ special_symbol (hp, pfile)\n       break;\n \n   case T_CONST:\n-      buf = (char *) alloca (4 * sizeof (int));\n-      sprintf (buf, \"%d\", hp->value.ival);\n+      wbuf = (char *) alloca (4 * sizeof (int));\n+      sprintf (wbuf, \"%d\", hp->value.ival);\n #ifdef STDC_0_IN_SYSTEM_HEADERS\n       if (ip->system_header_p\n \t  && hp->length == 8 && bcmp (hp->name, \"__STDC__\", 8) == 0\n \t  && ! cpp_lookup (pfile, (U_CHAR *) \"__STRICT_ANSI__\", -1, -1))\n-\tstrcpy (buf, \"0\");\n+\tstrcpy (wbuf, \"0\");\n #endif\n #if 0\n       if (pcp_inside_if && pcp_outfile)\n \t/* Output a precondition for this macro use */\n \tfprintf (pcp_outfile, \"#define %s %d\\n\", hp->name, hp->value.ival);\n #endif\n+      buf = wbuf;\n       break;\n \n     case T_SPECLINE:\n@@ -2163,21 +2167,23 @@ special_symbol (hp, pfile)\n \tlong col = ip->colno;\n \tadjust_position (CPP_LINE_BASE (ip), ip->cur, &line, &col);\n \n-\tbuf = (char *) alloca (10);\n-\tsprintf (buf, \"%ld\", line);\n+\twbuf = (char *) alloca (10);\n+\tsprintf (wbuf, \"%ld\", line);\n+\tbuf = wbuf;\n       }\n       break;\n \n     case T_DATE:\n     case T_TIME:\n-      buf = (char *) alloca (20);\n+      wbuf = (char *) alloca (20);\n       timebuf = timestamp (pfile);\n       if (hp->type == T_DATE)\n-\tsprintf (buf, \"\\\"%s %2d %4d\\\"\", monthnames[timebuf->tm_mon],\n+\tsprintf (wbuf, \"\\\"%s %2d %4d\\\"\", monthnames[timebuf->tm_mon],\n \t\t timebuf->tm_mday, timebuf->tm_year + 1900);\n       else\n-\tsprintf (buf, \"\\\"%02d:%02d:%02d\\\"\", timebuf->tm_hour, timebuf->tm_min,\n+\tsprintf (wbuf, \"\\\"%02d:%02d:%02d\\\"\", timebuf->tm_hour, timebuf->tm_min,\n \t\t timebuf->tm_sec);\n+      buf = wbuf;\n       break;\n \n     case T_SPEC_DEFINED:"}, {"sha": "7e7457c68c0867381d5e9776fc2940061115e467", "filename": "gcc/cppulp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fcppulp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fcppulp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppulp.c?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,5 +1,5 @@\n /* CPP Library.\n-   Copyright (C) 1986, 87, 89, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1986, 87, 89, 92-98, 1999 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -23,4 +23,4 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n #include \"output.h\"\n \n-char *user_label_prefix = 0;\n+const char *user_label_prefix = 0;"}, {"sha": "c9edfcb076ebef8a96f4f8bd140b340f8c1b3453", "filename": "gcc/dyn-string.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fdyn-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fdyn-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdyn-string.c?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,5 +1,5 @@\n /* An abstract string datatype.\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Mark Mitchell (mark@markmitchell.com).\n \n This file is part of GNU CC.\n@@ -62,7 +62,7 @@ dyn_string_delete (ds)\n dyn_string_t \n dyn_string_append (ds, s)\n      dyn_string_t ds;\n-     char *s;\n+     const char *s;\n {\n   int len = strlen (s);\n   dyn_string_resize (ds, ds->length + len + 1 /* '\\0' */);"}, {"sha": "9f9330886ca395649784dc41e53dee3ff995c03a", "filename": "gcc/dyn-string.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fdyn-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fdyn-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdyn-string.h?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,5 +1,5 @@\n /* An abstract string datatype.\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Mark Mitchell (mark@markmitchell.com).\n \n This file is part of GNU CC.\n@@ -28,5 +28,5 @@ typedef struct dyn_string\n \n extern dyn_string_t dyn_string_new      PROTO((int));\n extern void dyn_string_delete           PROTO((dyn_string_t));\n-extern dyn_string_t dyn_string_append   PROTO((dyn_string_t, char*));\n+extern dyn_string_t dyn_string_append   PROTO((dyn_string_t, const char*));\n extern dyn_string_t dyn_string_resize   PROTO((dyn_string_t, int));"}, {"sha": "6026d319c257473435329043d374d99887d9f39d", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,5 +1,5 @@\n /* Convert RTL to assembler code and output it, for GNU compiler.\n-   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -335,7 +335,7 @@ init_final (filename)\n \n void\n end_final (filename)\n-     char *filename;\n+  const char *filename;\n {\n   int i;\n \n@@ -3300,7 +3300,7 @@ alter_cond (cond)\n \n void\n output_operand_lossage (str)\n-     char *str;\n+  const char *str;\n {\n   if (this_is_asm_operands)\n     error_for_asm (this_is_asm_operands, \"invalid `asm': %s\", str);\n@@ -3680,11 +3680,11 @@ output_addr_const (file, x)\n    We handle alternate assembler dialects here, just like output_asm_insn.  */\n \n void\n-asm_fprintf VPROTO((FILE *file, char *p, ...))\n+asm_fprintf VPROTO((FILE *file, const char *p, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   FILE *file;\n-  char *p;\n+  const char *p;\n #endif\n   va_list argptr;\n   char buf[10];\n@@ -3694,7 +3694,7 @@ asm_fprintf VPROTO((FILE *file, char *p, ...))\n \n #ifndef ANSI_PROTOTYPES\n   file = va_arg (argptr, FILE *);\n-  p = va_arg (argptr, char *);\n+  p = va_arg (argptr, const char *);\n #endif\n \n   buf[0] = '%';"}, {"sha": "d677c012e0548a12d35c8a14242320567d55cf09", "filename": "gcc/output.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,6 +1,6 @@\n /* Declarations for insn-output.c.  These functions are defined in recog.c,\n    final.c, and varasm.c.\n-   Copyright (C) 1987, 1991, 1994, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1994, 97-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -24,7 +24,7 @@ extern void init_final\t\tPROTO((char *));\n \n /* Called at end of source file,\n    to output the block-profiling table for this entire compilation.  */\n-extern void end_final\t\tPROTO((char *));\n+extern void end_final\t\tPROTO((const char *));\n \n /* Enable APP processing of subsequent output.\n    Used before the output from an `asm' statement.  */\n@@ -77,7 +77,7 @@ extern rtx alter_subreg PROTO((rtx));\n \n /* Report inconsistency between the assembler template and the operands.\n    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\n-extern void output_operand_lossage  PROTO((char *));\n+extern void output_operand_lossage  PROTO((const char *));\n \n /* Output a string of assembler code, substituting insn operands.\n    Defined in final.c.  */\n@@ -106,7 +106,7 @@ extern void output_addr_const PROTO((FILE *, rtx));\n \n /* Output a string of assembler code, substituting numbers, strings\n    and fixed syntactic prefixes.  */\n-extern void asm_fprintf\t\tPROTO(PVPROTO((FILE *file, char *p, ...)));\n+extern void asm_fprintf\t\tPVPROTO((FILE *file, const char *p, ...));\n \n /* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n    words.  */\n@@ -161,7 +161,7 @@ extern void eh_frame_section\t\tPROTO ((void));\n    If DECL is NULL, just switch to section NAME.\n    If NAME is NULL, get the name from DECL.\n    If RELOC is 1, the initializer for DECL contains relocs.  */\n-extern void named_section\t\tPROTO((tree, char *, int));\n+extern void named_section\t\tPROTO((tree, const char *, int));\n \n /* Tell assembler to switch to the section for function DECL.  */\n extern void function_section\t\tPROTO((tree));\n@@ -188,7 +188,7 @@ extern void weak_finish\t\t\tPROTO ((void));\n    or -4 if ASMSPEC is `memory' and is not recognized.\n    Accept an exact spelling or a decimal number.\n    Prefixes such as % are optional.  */\n-extern int decode_reg_name\t\tPROTO((char *));\n+extern int decode_reg_name\t\tPROTO((const char *));\n \n #ifdef TREE_CODE\n /* Create the DECL_RTL for a declaration for a static or external variable\n@@ -198,7 +198,7 @@ extern int decode_reg_name\t\tPROTO((char *));\n    TOP_LEVEL is nonzero if this is a file-scope variable.\n \n    This is never called for PARM_DECL nodes.  */\n-extern void make_decl_rtl\t\tPROTO((tree, char *, int));\n+extern void make_decl_rtl\t\tPROTO((tree, const char *, int));\n \n /* Make the rtl for variable VAR be volatile.\n    Use this only for static variables.  */\n@@ -487,4 +487,4 @@ extern FILE *rtl_dump_file;\n    && ! (RELOC && (flag_pic || DECL_ONE_ONLY (DECL))))\n \n /* User label prefix in effect for this compilation.  */\n-extern char *user_label_prefix;\n+extern const char *user_label_prefix;"}, {"sha": "4809d7fbe54345dca8aa128299b6b2ed5db876cc", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,5 +1,5 @@\n /* Calculate branch probabilities, and basic block execution counts. \n-   Copyright (C) 1990, 91-94, 96, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 91-94, 96-98, 1999 Free Software Foundation, Inc.\n    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n    based on some ideas from Dain Samples of UC Berkeley.\n    Further mangling by Bob Manson, Cygnus Support.\n@@ -1407,7 +1407,7 @@ expand_spanning_tree (block)\n \n void\n init_branch_prob (filename)\n-     char *filename;\n+  const char *filename;\n {\n   long len;\n   int i;"}, {"sha": "f50c37248f97a0e3ee259d4700aa58c5cfff62cc", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,5 +1,5 @@\n /* Register Transfer Language (RTL) definitions for GNU C-Compiler\n-   Copyright (C) 1987, 91-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1467,7 +1467,7 @@ extern int reload\t\t\tPROTO ((rtx, int, FILE *));\n extern void init_caller_save\t\tPROTO ((void));\n \n /* In profile.c */\n-extern void init_branch_prob\t\tPROTO ((char *));\n+extern void init_branch_prob\t\tPROTO ((const char *));\n #ifdef BUFSIZ\n extern void branch_prob\t\t\tPROTO ((rtx, FILE *));\n extern void end_branch_prob\t\tPROTO ((FILE *));"}, {"sha": "8df7be5ef981be38839095ddee093c67507fb962", "filename": "gcc/toplev.c", "status": "modified", "additions": 156, "deletions": 157, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -1,5 +1,5 @@\n /* Top level of GNU C compiler\n-   Copyright (C) 1987, 88, 89, 92-8, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -162,56 +162,51 @@ extern void print_rtl ();\n extern void print_rtl_with_bb ();\n \n void rest_of_decl_compilation ();\n-void error_with_file_and_line PVPROTO((char *file, int line, char *s, ...));\n-void error_with_decl PVPROTO((tree decl, char *s, ...));\n-void error PVPROTO((char *s, ...));\n-void fatal PVPROTO((char *s, ...));\n-void warning_with_file_and_line PVPROTO((char *file, int line, char *s, ...));\n-void warning_with_decl PVPROTO((tree decl, char *s, ...));\n-void warning PVPROTO((char *s, ...));\n-void pedwarn PVPROTO((char *s, ...));\n-void pedwarn_with_decl PVPROTO((tree decl, char *s, ...));\n-void pedwarn_with_file_and_line PVPROTO((char *file, int line, char *s, ...));\n-void sorry PVPROTO((char *s, ...));\n-static void set_target_switch PROTO((char *));\n+static void set_target_switch PROTO((const char *));\n static char *decl_name PROTO((tree, int));\n-static void vmessage PROTO((char *, char *, va_list));\n-static void v_message_with_file_and_line PROTO((char *, int, char *,\n-\t\t\t\t\t\tchar *, va_list));\n-static void v_message_with_decl PROTO((tree, char *, char *, va_list));\n+static void vmessage PROTO((const char *, const char *, va_list));\n+static void v_message_with_file_and_line PROTO((const char *, int,\n+\t\t\t\t\t\tconst char *, const char *,\n+\t\t\t\t\t\tva_list));\n+static void v_message_with_decl PROTO((tree, const char *,\n+\t\t\t\t       const char *, va_list));\n static void file_and_line_for_asm PROTO((rtx, char **, int *));\n-static void v_error_with_file_and_line PROTO((char *, int, char *, va_list));\n-static void v_error_with_decl PROTO((tree, char *, va_list));\n-static void v_error_for_asm PROTO((rtx, char *, va_list));\n-static void verror PROTO((char *, va_list));\n-static void vfatal PROTO((char *, va_list)) ATTRIBUTE_NORETURN;\n-static void v_warning_with_file_and_line PROTO ((char *, int, char *, va_list));\n-static void v_warning_with_decl PROTO((tree, char *, va_list));\n-static void v_warning_for_asm PROTO((rtx, char *, va_list));\n-static void vwarning PROTO((char *, va_list));\n-static void vpedwarn PROTO((char *, va_list));\n-static void v_pedwarn_with_decl PROTO((tree, char *, va_list));\n-static void v_pedwarn_with_file_and_line PROTO((char *, int, char *, va_list));\n-static void vsorry PROTO((char *, va_list));\n-static void v_really_sorry PROTO((char *, va_list)) ATTRIBUTE_NORETURN;\n+static void v_error_with_file_and_line PROTO((const char *, int,\n+\t\t\t\t\t      const char *, va_list));\n+static void v_error_with_decl PROTO((tree, const char *, va_list));\n+static void v_error_for_asm PROTO((rtx, const char *, va_list));\n+static void verror PROTO((const char *, va_list));\n+static void vfatal PROTO((const char *, va_list)) ATTRIBUTE_NORETURN;\n+static void v_warning_with_file_and_line PROTO ((const char *, int,\n+\t\t\t\t\t\t const char *, va_list));\n+static void v_warning_with_decl PROTO((tree, const char *, va_list));\n+static void v_warning_for_asm PROTO((rtx, const char *, va_list));\n+static void vwarning PROTO((const char *, va_list));\n+static void vpedwarn PROTO((const char *, va_list));\n+static void v_pedwarn_with_decl PROTO((tree, const char *, va_list));\n+static void v_pedwarn_with_file_and_line PROTO((const char *, int,\n+\t\t\t\t\t\tconst char *, va_list));\n+static void vsorry PROTO((const char *, va_list));\n+static void v_really_sorry PROTO((const char *, va_list)) ATTRIBUTE_NORETURN;\n static void float_signal PROTO((int)) ATTRIBUTE_NORETURN;\n static void pipe_closed PROTO((int)) ATTRIBUTE_NORETURN;\n #ifdef ASM_IDENTIFY_LANGUAGE\n /* This might or might not be used in ASM_IDENTIFY_LANGUAGE. */\n static void output_lang_identify PROTO((FILE *)) ATTRIBUTE_UNUSED;\n #endif\n-static void open_dump_file PROTO((char *, char *));\n+static void open_dump_file PROTO((const char *, const char *));\n static void close_dump_file PROTO((void (*) (FILE *, rtx), rtx));\n-static void dump_rtl PROTO((char *, tree, void (*) (FILE *, rtx), rtx));\n-static void clean_dump_file PROTO((char *));\n+static void dump_rtl PROTO((const char *, tree, void (*) (FILE *, rtx), rtx));\n+static void clean_dump_file PROTO((const char *));\n static void compile_file PROTO((char *));\n static void display_help PROTO ((void));\n \n-static void print_version PROTO((FILE *, char *));\n-static int print_single_switch PROTO((FILE *, int, int, char *, char *, char *,\n-\t\t\t\t      char *, char *));\n-static void print_switch_values PROTO((FILE *, int, int, char *, char *,\n-\t\t\t\t       char *));\n+static void print_version PROTO((FILE *, const char *));\n+static int print_single_switch PROTO((FILE *, int, int, const char *,\n+\t\t\t\t      const char *, const char *,\n+\t\t\t\t      const char *, const char *));\n+static void print_switch_values PROTO((FILE *, int, int, const char *,\n+\t\t\t\t       const char *, const char *));\n \n void print_rtl_graph_with_bb PROTO ((const char *, const char *, rtx));\n void clean_graph_dump_file PROTO ((const char *, const char *));\n@@ -258,7 +253,7 @@ extern tree current_function_decl;\n \n /* Name to use as base of names for dump output files.  */\n \n-char *dump_base_name;\n+const char *dump_base_name;\n \n /* Bit flags that specify the machine subtype we are compiling for.\n    Bits are tested using macros TARGET_... defined in the tm.h file\n@@ -737,12 +732,12 @@ int flag_instrument_function_entry_exit = 0;\n /* Table of supported debugging formats.  */\n static struct\n {\n-  char * arg;\n+  const char * arg;\n   /* Since PREFERRED_DEBUGGING_TYPE isn't necessarily a\n      constant expression, we use NO_DEBUG in its place.  */\n   enum debug_info_type debug_type;\n   int use_extensions_p;\n-  char * description;\n+  const char * description;\n } *da,\n debug_args[] =\n {\n@@ -773,18 +768,18 @@ debug_args[] =\n \n typedef struct\n {\n-  char * string;\n+  const char * string;\n   int *  variable;\n   int    on_value;\n-  char * description;\n+  const char * description;\n }\n lang_independent_options;\n \n /* Add or remove a leading underscore from user symbols.  */\n int flag_leading_underscore = -1;\n \n /* The user symbol prefix after having resolved same.  */\n-char *user_label_prefix;\n+const char *user_label_prefix;\n \n /* A default for same.  */\n #ifndef USER_LABEL_PREFIX\n@@ -946,8 +941,8 @@ lang_independent_options f_options[] =\n \n static struct lang_opt\n {\n-  char * option;\n-  char * description;\n+  const char * option;\n+  const char * description;\n }\n documented_lang_options[] =\n {\n@@ -1115,9 +1110,9 @@ documented_lang_options[] =\n \n struct\n {\n-  char * name;\n+  const char * name;\n   int    value;\n-  char * description;\n+  const char * description;\n }\n target_switches [] = TARGET_SWITCHES;\n \n@@ -1126,9 +1121,9 @@ target_switches [] = TARGET_SWITCHES;\n #ifdef TARGET_OPTIONS\n struct\n {\n-  char *  prefix;\n-  char ** variable;\n-  char *  description;\n+  const char *  prefix;\n+  const char ** variable;\n+  const char *  description;\n }\n target_options [] = TARGET_OPTIONS;\n #endif\n@@ -1323,7 +1318,7 @@ do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while\n \n void\n print_time (str, total)\n-     char *str;\n+     const char *str;\n      int total;\n {\n   fprintf (stderr,\n@@ -1362,7 +1357,7 @@ count_error (warningp)\n \n void\n pfatal_with_name (name)\n-     char *name;\n+  const char *name;\n {\n   fprintf (stderr, \"%s: \", progname);\n   perror (name);\n@@ -1371,7 +1366,7 @@ pfatal_with_name (name)\n \n void\n fatal_io_error (name)\n-     char *name;\n+  const char *name;\n {\n   fprintf (stderr, \"%s: %s: I/O error\\n\", progname, name);\n   exit (FATAL_EXIT_CODE);\n@@ -1382,7 +1377,7 @@ fatal_io_error (name)\n \n void\n fatal_insn (message, insn)\n-     char *message;\n+     const char *message;\n      rtx insn;\n {\n   error (message);\n@@ -1456,11 +1451,11 @@ announce_function (decl)\n \n void\n default_print_error_function (file)\n-     char *file;\n+  const char *file;\n {\n   if (last_error_function != current_function_decl)\n     {\n-      char *kind = \"function\";\n+      const char *kind = \"function\";\n       if (current_function_decl != 0\n \t  && TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n \tkind = \"method\";\n@@ -1483,14 +1478,15 @@ default_print_error_function (file)\n /* Called by report_error_function to print out function name.\n  * Default may be overridden by language front-ends.  */\n \n-void (*print_error_function) PROTO((char *)) = default_print_error_function;\n+void (*print_error_function) PROTO((const char *)) =\n+  default_print_error_function;\n \n /* Prints out, if necessary, the name of the current function\n   that caused an error.  Called from all error and warning functions.  */\n \n void\n report_error_function (file)\n-     char *file;\n+  const char *file;\n {\n   struct file_stack *p;\n \n@@ -1522,8 +1518,8 @@ report_error_function (file)\n \n static void\n vmessage (prefix, s, ap)\n-     char *prefix;\n-     char *s;\n+     const char *prefix;\n+     const char *s;\n      va_list ap;\n {\n   if (prefix)\n@@ -1536,10 +1532,10 @@ vmessage (prefix, s, ap)\n \n static void\n v_message_with_file_and_line (file, line, prefix, s, ap)\n-     char *file;\n+     const char *file;\n      int line;\n-     char *prefix;\n-     char *s;\n+     const char *prefix;\n+     const char *s;\n      va_list ap;\n {\n   if (file)\n@@ -1556,11 +1552,11 @@ v_message_with_file_and_line (file, line, prefix, s, ap)\n static void\n v_message_with_decl (decl, prefix, s, ap)\n      tree decl;\n-     char *prefix;\n-     char *s;\n+     const char *prefix;\n+     const char *s;\n      va_list ap;\n {\n-  char *p;\n+  const char *p;\n \n   fprintf (stderr, \"%s:%d: \",\n \t   DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));\n@@ -1595,7 +1591,7 @@ v_message_with_decl (decl, prefix, s, ap)\n \n   if (*p == '%')\t\t/* Print the name.  */\n     {\n-      char *n = (DECL_NAME (decl)\n+      const char *n = (DECL_NAME (decl)\n \t\t ? (*decl_printable_name) (decl, 2)\n \t\t : \"((anonymous))\");\n       fputs (n, stderr);\n@@ -1654,9 +1650,9 @@ file_and_line_for_asm (insn, pfile, pline)\n \n static void\n v_error_with_file_and_line (file, line, s, ap)\n-     char *file;\n+     const char *file;\n      int line;\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   count_error (0);\n@@ -1665,21 +1661,22 @@ v_error_with_file_and_line (file, line, s, ap)\n }\n \n void\n-error_with_file_and_line VPROTO((char *file, int line, char *s, ...))\n+error_with_file_and_line VPROTO((const char *file, int line,\n+\t\t\t\t const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *file;\n+  const char *file;\n   int line;\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  file = va_arg (ap, char *);\n+  file = va_arg (ap, const char *);\n   line = va_arg (ap, int);\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_error_with_file_and_line (file, line, s, ap);\n@@ -1693,7 +1690,7 @@ error_with_file_and_line VPROTO((char *file, int line, char *s, ...))\n static void\n v_error_with_decl (decl, s, ap)\n      tree decl;\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   count_error (0);\n@@ -1702,19 +1699,19 @@ v_error_with_decl (decl, s, ap)\n }\n \n void\n-error_with_decl VPROTO((tree decl, char *s, ...))\n+error_with_decl VPROTO((tree decl, const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n   decl = va_arg (ap, tree);\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_error_with_decl (decl, s, ap);\n@@ -1728,7 +1725,7 @@ error_with_decl VPROTO((tree decl, char *s, ...))\n static void\n v_error_for_asm (insn, s, ap)\n      rtx insn;\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   char *file;\n@@ -1741,19 +1738,19 @@ v_error_for_asm (insn, s, ap)\n }\n \n void\n-error_for_asm VPROTO((rtx insn, char *s, ...))\n+error_for_asm VPROTO((rtx insn, const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx insn;\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n   insn = va_arg (ap, rtx);\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_error_for_asm (insn, s, ap);\n@@ -1764,24 +1761,24 @@ error_for_asm VPROTO((rtx insn, char *s, ...))\n \n static void\n verror (s, ap)\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   v_error_with_file_and_line (input_filename, lineno, s, ap);\n }\n \n void\n-error VPROTO((char *s, ...))\n+error VPROTO((const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   verror (s, ap);\n@@ -1792,25 +1789,25 @@ error VPROTO((char *s, ...))\n \n static void\n vfatal (s, ap)\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   verror (s, ap);\n   exit (FATAL_EXIT_CODE);\n }\n \n void\n-fatal VPROTO((char *s, ...))\n+fatal VPROTO((const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   vfatal (s, ap);\n@@ -1821,9 +1818,9 @@ fatal VPROTO((char *s, ...))\n \n static void\n v_warning_with_file_and_line (file, line, s, ap)\n-     char *file;\n+     const char *file;\n      int line;\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   if (count_error (1))\n@@ -1834,21 +1831,22 @@ v_warning_with_file_and_line (file, line, s, ap)\n }\n \n void\n-warning_with_file_and_line VPROTO((char *file, int line, char *s, ...))\n+warning_with_file_and_line VPROTO((const char *file, int line,\n+\t\t\t\t   const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *file;\n+  const char *file;\n   int line;\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  file = va_arg (ap, char *);\n+  file = va_arg (ap, const char *);\n   line = va_arg (ap, int);\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_warning_with_file_and_line (file, line, s, ap);\n@@ -1862,7 +1860,7 @@ warning_with_file_and_line VPROTO((char *file, int line, char *s, ...))\n static void\n v_warning_with_decl (decl, s, ap)\n      tree decl;\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   if (count_error (1))\n@@ -1873,19 +1871,19 @@ v_warning_with_decl (decl, s, ap)\n }\n \n void\n-warning_with_decl VPROTO((tree decl, char *s, ...))\n+warning_with_decl VPROTO((tree decl, const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n   decl = va_arg (ap, tree);\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_warning_with_decl (decl, s, ap);\n@@ -1899,7 +1897,7 @@ warning_with_decl VPROTO((tree decl, char *s, ...))\n static void\n v_warning_for_asm (insn, s, ap)\n      rtx insn;\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   if (count_error (1))\n@@ -1914,19 +1912,19 @@ v_warning_for_asm (insn, s, ap)\n }\n \n void\n-warning_for_asm VPROTO((rtx insn, char *s, ...))\n+warning_for_asm VPROTO((rtx insn, const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx insn;\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n   insn = va_arg (ap, rtx);\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_warning_for_asm (insn, s, ap);\n@@ -1937,24 +1935,24 @@ warning_for_asm VPROTO((rtx insn, char *s, ...))\n \n static void\n vwarning (s, ap)\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   v_warning_with_file_and_line (input_filename, lineno, s, ap);\n }\n \n void\n-warning VPROTO((char *s, ...))\n+warning VPROTO((const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   vwarning (s, ap);\n@@ -1966,7 +1964,7 @@ warning VPROTO((char *s, ...))\n \n static void\n vpedwarn (s, ap)\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   if (flag_pedantic_errors)\n@@ -1976,17 +1974,17 @@ vpedwarn (s, ap)\n }\n \n void\n-pedwarn VPROTO((char *s, ...))\n+pedwarn VPROTO((const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   vpedwarn (s, ap);\n@@ -1996,7 +1994,7 @@ pedwarn VPROTO((char *s, ...))\n static void\n v_pedwarn_with_decl (decl, s, ap)\n      tree decl;\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   /* We don't want -pedantic-errors to cause the compilation to fail from\n@@ -2016,19 +2014,19 @@ v_pedwarn_with_decl (decl, s, ap)\n }\n \n void\n-pedwarn_with_decl VPROTO((tree decl, char *s, ...))\n+pedwarn_with_decl VPROTO((tree decl, const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n   decl = va_arg (ap, tree);\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_pedwarn_with_decl (decl, s, ap);\n@@ -2037,9 +2035,9 @@ pedwarn_with_decl VPROTO((tree decl, char *s, ...))\n \n static void\n v_pedwarn_with_file_and_line (file, line, s, ap)\n-     char *file;\n+     const char *file;\n      int line;\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   if (flag_pedantic_errors)\n@@ -2049,21 +2047,22 @@ v_pedwarn_with_file_and_line (file, line, s, ap)\n }\n \n void\n-pedwarn_with_file_and_line VPROTO((char *file, int line, char *s, ...))\n+pedwarn_with_file_and_line VPROTO((const char *file, int line,\n+\t\t\t\t   const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *file;\n+  const char *file;\n   int line;\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  file = va_arg (ap, char *);\n+  file = va_arg (ap, const char *);\n   line = va_arg (ap, int);\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_pedwarn_with_file_and_line (file, line, s, ap);\n@@ -2074,7 +2073,7 @@ pedwarn_with_file_and_line VPROTO((char *file, int line, char *s, ...))\n \n static void\n vsorry (s, ap)\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   sorrycount++;\n@@ -2087,17 +2086,17 @@ vsorry (s, ap)\n }\n \n void\n-sorry VPROTO((char *s, ...))\n+sorry VPROTO((const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   vsorry (s, ap);\n@@ -2108,7 +2107,7 @@ sorry VPROTO((char *s, ...))\n \n static void\n v_really_sorry (s, ap)\n-     char *s;\n+     const char *s;\n      va_list ap;\n {\n   sorrycount++;\n@@ -2121,17 +2120,17 @@ v_really_sorry (s, ap)\n }\n \n void\n-really_sorry VPROTO((char *s, ...))\n+really_sorry VPROTO((const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *s;\n+  const char *s;\n #endif\n   va_list ap;\n \n   VA_START (ap, s);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, char *);\n+  s = va_arg (ap, const char *);\n #endif\n \n   v_really_sorry (s, ap);\n@@ -2166,7 +2165,7 @@ do_abort ()\n \n void\n botch (s)\n-  char * s ATTRIBUTE_UNUSED;\n+  const char * s ATTRIBUTE_UNUSED;\n {\n   abort ();\n }\n@@ -2382,7 +2381,7 @@ strip_off_ending (name, len)\n void\n output_quoted_string (asm_file, string)\n      FILE *asm_file;\n-     char *string;\n+     const char *string;\n {\n #ifdef OUTPUT_QUOTED_STRING\n   OUTPUT_QUOTED_STRING (asm_file, string);\n@@ -2405,10 +2404,10 @@ output_quoted_string (asm_file, string)\n void\n output_file_directive (asm_file, input_name)\n      FILE *asm_file;\n-     char *input_name;\n+     const char *input_name;\n {\n   int len = strlen (input_name);\n-  char *na = input_name + len;\n+  const char *na = input_name + len;\n \n   /* NA gets INPUT_NAME sans directory names.  */\n   while (na > input_name)\n@@ -2451,8 +2450,8 @@ output_lang_identify (asm_out_file)\n /* Routine to open a dump file.  */\n static void\n open_dump_file (suffix, function_name)\n-     char *suffix;\n-     char *function_name;\n+     const char *suffix;\n+     const char *function_name;\n {\n   char *dumpname;\n \n@@ -2505,7 +2504,7 @@ close_dump_file (func, insns)\n /* Routine to dump rtl into a file.  */\n static void\n dump_rtl (suffix, decl, func, insns)\n-     char *suffix;\n+     const char *suffix;\n      tree   decl;\n      void (*func) PROTO ((FILE *, rtx));\n      rtx    insns;\n@@ -2517,7 +2516,7 @@ dump_rtl (suffix, decl, func, insns)\n /* Routine to empty a dump file.  */\n static void\n clean_dump_file (suffix)\n-     char *suffix;\n+  const char *suffix;\n {\n   char *dumpname;\n \n@@ -3301,7 +3300,7 @@ compile_file (name)\n void\n rest_of_decl_compilation (decl, asmspec, top_level, at_end)\n      tree decl;\n-     char *asmspec;\n+     const char *asmspec;\n      int top_level;\n      int at_end;\n {\n@@ -4254,7 +4253,7 @@ display_help ()\n {\n   int    undoc;\n   unsigned long\t i;\n-  char * lang;\n+  const char * lang;\n   \n #ifndef USE_CPPLIB  \n   printf (\"Usage: %s input [switches]\\n\", progname);\n@@ -4266,7 +4265,7 @@ display_help ()\n \n   for (i = NUM_ELEM (f_options); i--;)\n     {\n-      char * description = f_options[i].description;\n+      const char * description = f_options[i].description;\n       \n       if (description != NULL && * description != 0)\n \tprintf (\"  -f%-21s %s\\n\",\n@@ -4282,7 +4281,7 @@ display_help ()\n   \n   for (i = NUM_ELEM (W_options); i--;)\n     {\n-      char * description = W_options[i].description;\n+      const char * description = W_options[i].description;\n       \n       if (description != NULL && * description != 0)\n \tprintf (\"  -W%-21s %s\\n\",\n@@ -4335,8 +4334,8 @@ display_help ()\n \n       for (i = 0; i < NUM_ELEM (documented_lang_options); i++)\n \t{\n-\t  char * description = documented_lang_options[i].description;\n-\t  char * option      = documented_lang_options[i].option;\n+\t  const char * description = documented_lang_options[i].description;\n+\t  const char * option      = documented_lang_options[i].option;\n \n \t  if (description == NULL)\n \t    {\n@@ -4381,8 +4380,8 @@ display_help ()\n \n       for (i = NUM_ELEM (target_switches); i--;)\n \t{\n-\t  char * option      = target_switches[i].name;\n-\t  char * description = target_switches[i].description;\n+\t  const char * option      = target_switches[i].name;\n+\t  const char * description = target_switches[i].description;\n \n \t  if (option == NULL || * option == 0)\n \t    continue;\n@@ -4400,8 +4399,8 @@ display_help ()\n #ifdef TARGET_OPTIONS      \n       for (i = NUM_ELEM (target_options); i--;)\n \t{\n-\t  char * option      = target_options[i].prefix;\n-\t  char * description = target_options[i].description;\n+\t  const char * option      = target_options[i].prefix;\n+\t  const char * description = target_options[i].description;\n \n \t  if (option == NULL || * option == 0)\n \t    continue;\n@@ -4982,7 +4981,7 @@ main (argc, argv)\n \t\t -gdwarf -g3 is equivalent to -gdwarf3.  */\n \t      static int type_explicitly_set_p = 0;\n \t      /* Indexed by enum debug_info_type.  */\n-\t      static char *debug_type_names[] =\n+\t      static const char *debug_type_names[] =\n \t      {\n \t\t\"none\", \"stabs\", \"coff\", \"dwarf-1\", \"dwarf-2\", \"xcoff\"\n \t      };\n@@ -5223,7 +5222,7 @@ main (argc, argv)\n \n static void\n set_target_switch (name)\n-     char *name;\n+  const char *name;\n {\n   register size_t j;\n   int valid = 0;\n@@ -5262,7 +5261,7 @@ set_target_switch (name)\n static void\n print_version (file, indent)\n      FILE *file;\n-     char *indent;\n+     const char *indent;\n {\n   fprintf (file, \"%s%s%s version %s\", indent, *indent != 0 ? \" \" : \"\",\n \t   language_string, version_string);\n@@ -5285,7 +5284,7 @@ static int\n print_single_switch (file, pos, max, indent, sep, term, type, name)\n      FILE *file;\n      int pos, max;\n-     char *indent, *sep, *term, *type, *name;\n+     const char *indent, *sep, *term, *type, *name;\n {\n   /* The ultrix fprintf returns 0 on success, so compute the result we want\n      here since we need it for the following test.  */\n@@ -5316,7 +5315,7 @@ static void\n print_switch_values (file, pos, max, indent, sep, term)\n      FILE *file;\n      int pos, max;\n-     char *indent, *sep, *term;\n+     const char *indent, *sep, *term;\n {\n   size_t j;\n   char **p;"}, {"sha": "807fb25eaea411e5cb4029b1617d866acc80d9d5", "filename": "gcc/toplev.h", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -28,63 +28,78 @@ struct rtx_def;\n \n extern int count_error\t\t\tPROTO ((int));\n extern void strip_off_ending\t\tPROTO ((char *, int));\n-extern void print_time\t\t\tPROTO ((char *, int));\n+extern void print_time\t\t\tPROTO ((const char *, int));\n extern void debug_start_source_file\tPROTO ((char *));\n extern void debug_end_source_file\tPROTO ((unsigned));\n extern void debug_define\t\tPROTO ((unsigned, char *));\n extern void debug_undef\t\t\tPROTO ((unsigned, char *));\n-extern void fatal\t\t\tPVPROTO ((char *, ...))\n+extern void fatal\t\t\tPVPROTO ((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void fatal_io_error\t\tPROTO ((char *)) ATTRIBUTE_NORETURN;\n-extern void pfatal_with_name\t\tPROTO ((char *)) ATTRIBUTE_NORETURN;\n+extern void fatal_io_error\t\tPROTO ((const char *))\n+  ATTRIBUTE_NORETURN;\n+extern void pfatal_with_name\t\tPROTO ((const char *))\n+  ATTRIBUTE_NORETURN;\n extern void fatal_insn_not_found\tPROTO ((struct rtx_def *))\n   ATTRIBUTE_NORETURN;\n-extern void fatal_insn\t\t\tPROTO ((char *, struct rtx_def *))\n+extern void fatal_insn\t\t\tPROTO ((const char *, struct rtx_def *))\n   ATTRIBUTE_NORETURN;\n-extern void warning\t\t\tPVPROTO ((char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern void error\t\t\tPVPROTO ((char *, ...))\n+extern void warning\t\t\tPVPROTO ((const char *, ...))\n \t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern void pedwarn\t\t\tPVPROTO ((char *, ...))\n+extern void error\t\t\tPVPROTO ((const char *, ...))\n \t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern void pedwarn_with_file_and_line\tPVPROTO ((char *, int, char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_3;\n-extern void warning_with_file_and_line\tPVPROTO ((char *, int, char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_3;\n-extern void error_with_file_and_line\tPVPROTO ((char *, int, char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_3;\n-extern void sorry\t\t\tPVPROTO ((char *s, ...))\n+extern void pedwarn\t\t\tPVPROTO ((const char *, ...))\n \t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern void really_sorry\t\tPVPROTO((char *s, ...))\n+extern void pedwarn_with_file_and_line\tPVPROTO ((const char *, int,\n+\t\t\t\t\t\t  const char *, ...))\n+  ATTRIBUTE_PRINTF_3;\n+extern void warning_with_file_and_line\tPVPROTO ((const char *, int,\n+\t\t\t\t\t\t  const char *, ...))\n+  ATTRIBUTE_PRINTF_3;\n+extern void error_with_file_and_line\tPVPROTO ((const char *, int,\n+\t\t\t\t\t\t  const char *, ...))\n+  ATTRIBUTE_PRINTF_3;\n+extern void sorry\t\t\tPVPROTO ((const char *, ...))\n+  ATTRIBUTE_PRINTF_1;\n+extern void really_sorry\t\tPVPROTO((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void default_print_error_function PROTO ((char *));\n-extern void report_error_function\tPROTO ((char *));\n+extern void default_print_error_function PROTO ((const char *));\n+extern void report_error_function\tPROTO ((const char *));\n \n-extern void rest_of_decl_compilation\tPROTO ((union tree_node *, char *, int, int));\n+extern void rest_of_decl_compilation\tPROTO ((union tree_node *,\n+\t\t\t\t\t\tconst char *, int, int));\n extern void rest_of_type_compilation\tPROTO ((union tree_node *, int));\n extern void rest_of_compilation\t\tPROTO ((union tree_node *));\n-extern void pedwarn_with_decl\t\tPVPROTO ((union tree_node *, char *, ...));\n-extern void warning_with_decl\t\tPVPROTO ((union tree_node *, char *, ...));\n-extern void error_with_decl\t\tPVPROTO ((union tree_node *, char *, ...));\n+\n+/* The *_with_decl functions aren't suitable for ATTRIBUTE_PRINTF. */\n+extern void pedwarn_with_decl\t\tPVPROTO ((union tree_node *,\n+\t\t\t\t\t\t  const char *, ...));\n+extern void warning_with_decl\t\tPVPROTO ((union tree_node *,\n+\t\t\t\t\t\t  const char *, ...));\n+extern void error_with_decl\t\tPVPROTO ((union tree_node *,\n+\t\t\t\t\t\t  const char *, ...));\n+\n extern void announce_function\t\tPROTO ((union tree_node *));\n \n-extern void error_for_asm\t\tPVPROTO((struct rtx_def *, char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_2;\n-extern void warning_for_asm\t\tPVPROTO((struct rtx_def *, char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_2;\n+extern void error_for_asm\t\tPVPROTO((struct rtx_def *,\n+\t\t\t\t\t\t const char *, ...))\n+  ATTRIBUTE_PRINTF_2;\n+extern void warning_for_asm\t\tPVPROTO((struct rtx_def *,\n+\t\t\t\t\t\t const char *, ...))\n+  ATTRIBUTE_PRINTF_2;\n #if defined (_JBLEN) || defined (setjmp)\n extern void set_float_handler PROTO((jmp_buf));\n extern int push_float_handler PROTO((jmp_buf, jmp_buf));\n extern void pop_float_handler PROTO((int, jmp_buf));\n #endif\n \n #ifdef BUFSIZ\n-extern void output_quoted_string\tPROTO ((FILE *, char *));\n-extern void output_file_directive\tPROTO ((FILE *, char *));\n+extern void output_quoted_string\tPROTO ((FILE *, const char *));\n+extern void output_file_directive\tPROTO ((FILE *, const char *));\n #endif\n \n extern void fancy_abort\t\t\tPROTO ((void)) ATTRIBUTE_NORETURN;\n extern void do_abort\t\t\tPROTO ((void)) ATTRIBUTE_NORETURN;\n-extern void botch\t\t\tPROTO ((char *)) ATTRIBUTE_NORETURN;\n+extern void botch\t\t\tPROTO ((const char *))\n+  ATTRIBUTE_NORETURN;\n \n #endif /* __GCC_TOPLEV_H */"}, {"sha": "1e8ed4d35e725b65ed1eaccba5ea2283a4374f47", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -2258,7 +2258,7 @@ extern void set_yydebug\t\t\tPROTO ((int));\n extern void fixup_signed_type\t\tPROTO ((tree));\n \n /* varasm.c */\n-extern void make_decl_rtl\t\tPROTO ((tree, char *, int));\n+extern void make_decl_rtl\t\tPROTO ((tree, const char *, int));\n extern void make_decl_one_only\t\tPROTO ((tree));\n extern int supports_one_only\t\tPROTO ((void));\n extern void variable_section\t\tPROTO ((tree, int));"}, {"sha": "e3910b065d9b8512f4b0573e93be0982ff56eb90", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e11268b6574b6002b6a8b9ba28531e4173273e/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=87e11268b6574b6002b6a8b9ba28531e4173273e", "patch": "@@ -125,7 +125,7 @@ struct constant_descriptor;\n struct rtx_const;\n struct pool_constant;\n \n-static char *strip_reg_name\t\tPROTO((char *));\n+static const char *strip_reg_name\tPROTO((const char *));\n static int contains_pointers_p\t\tPROTO((tree));\n static void decode_addr_const\t\tPROTO((tree, struct addr_const *));\n static int const_hash\t\t\tPROTO((tree));\n@@ -263,7 +263,7 @@ in_data_section ()\n void\n named_section (decl, name, reloc)\n      tree decl;\n-     char *name;\n+     const char *name;\n      int reloc;\n {\n   if (decl != NULL_TREE\n@@ -549,9 +549,9 @@ make_function_rtl (decl)\n \n /* Given NAME, a putative register name, discard any customary prefixes.  */\n \n-static char *\n+static const char *\n strip_reg_name (name)\n-     char *name;\n+  const char *name;\n {\n #ifdef REGISTER_PREFIX\n   if (!strncmp (name, REGISTER_PREFIX, strlen (REGISTER_PREFIX)))\n@@ -572,7 +572,7 @@ strip_reg_name (name)\n \n int\n decode_reg_name (asmspec)\n-     char *asmspec;\n+  const char *asmspec;\n {\n   if (asmspec != 0)\n     {\n@@ -601,7 +601,7 @@ decode_reg_name (asmspec)\n \n #ifdef ADDITIONAL_REGISTER_NAMES\n       {\n-\tstatic struct { char *name; int number; } table[]\n+\tstatic struct { const char *name; int number; } table[]\n \t  = ADDITIONAL_REGISTER_NAMES;\n \n \tfor (i = 0; i < (int)(sizeof (table) / sizeof (table[0])); i++)\n@@ -633,7 +633,7 @@ decode_reg_name (asmspec)\n void\n make_decl_rtl (decl, asmspec, top_level)\n      tree decl;\n-     char *asmspec;\n+     const char *asmspec;\n      int top_level;\n {\n   register char *name = 0;"}]}