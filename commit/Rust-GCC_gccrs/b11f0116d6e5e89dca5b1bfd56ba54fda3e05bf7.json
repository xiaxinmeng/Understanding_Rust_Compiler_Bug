{"sha": "b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjExZjAxMTZkNmU1ZTg5ZGNhNWIxYmZkNTZiYTU0ZmRhM2UwNWJmNw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2012-10-19T05:42:24Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2012-10-19T05:42:24Z"}, "message": "common.opt (flag_ira_hoist_pressure): New.\n\n\tgcc/ChangeLog\n\t* common.opt (flag_ira_hoist_pressure): New.\n\t* doc/invoke.texi (-fira-hoist-pressure): Describe.\n\t* ira-costs.c (ira_set_pseudo_classes): New parameter.\n\t* ira.h: Update copyright dates.\n\t(ira_set_pseudo_classes): Update prototype.\n\t* haifa-sched.c (sched_init): Update call.\n\t* ira.c (ira): Update call.\n\t* regmove.c: Update copyright dates.\n\t(regmove_optimize): Update call.\n\t* loop-invariant.c: Update copyright dates.\n\t(move_loop_invariants): Update call.\n\t* gcse.c: (struct bb_data): New structure.\n\t(BB_DATA): New macro.\n\t(curr_bb, curr_reg_pressure): New static variables.\n\t(should_hoist_expr_to_dom): Rename from hoist_expr_reaches_here_p.\n\tChange parameter expr_index to expr.\n\tNew parameters pressure_class, nregs and hoisted_bbs.\n\tUse reg pressure to determine the distance expr can be hoisted.\n\t(hoist_code): Use reg pressure to direct the hoist process.\n\t(get_regno_pressure_class, get_pressure_class_and_nregs)\n\t(change_pressure, calculate_bb_reg_pressure): New.\n\t(one_code_hoisting_pass): Calculate register pressure. Allocate\n\tand free data.\n\n\tgcc/testsuite/ChangeLog\n\t* testsuite/gcc.dg/hoist-register-pressure.c: New test.\n\nFrom-SVN: r192604", "tree": {"sha": "9423fd10c44761618c568365bb200032573cfdf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9423fd10c44761618c568365bb200032573cfdf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/comments", "author": null, "committer": null, "parents": [{"sha": "8cba9a053644b2bfcbe64d644d01cf697b51b9c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cba9a053644b2bfcbe64d644d01cf697b51b9c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cba9a053644b2bfcbe64d644d01cf697b51b9c2"}], "stats": {"total": 472, "additions": 430, "deletions": 42}, "files": [{"sha": "9b09aaa638afdb807234b3613c4d4d1f7f40c240", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -1,3 +1,29 @@\n+2012-10-19  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* common.opt (flag_ira_hoist_pressure): New.\n+\t* doc/invoke.texi (-fira-hoist-pressure): Describe.\n+\t* ira-costs.c (ira_set_pseudo_classes): New parameter.\n+\t* ira.h: Update copyright dates.\n+\t(ira_set_pseudo_classes): Update prototype.\n+\t* haifa-sched.c (sched_init): Update call.\n+\t* ira.c (ira): Update call.\n+\t* regmove.c: Update copyright dates.\n+\t(regmove_optimize): Update call.\n+\t* loop-invariant.c: Update copyright dates.\n+\t(move_loop_invariants): Update call.\n+\t* gcse.c: (struct bb_data): New structure.\n+\t(BB_DATA): New macro.\n+\t(curr_bb, curr_reg_pressure): New static variables.\n+\t(should_hoist_expr_to_dom): Rename from hoist_expr_reaches_here_p.\n+\tChange parameter expr_index to expr.\n+\tNew parameters pressure_class, nregs and hoisted_bbs.\n+\tUse reg pressure to determine the distance expr can be hoisted.\n+\t(hoist_code): Use reg pressure to direct the hoist process.\n+\t(get_regno_pressure_class, get_pressure_class_and_nregs)\n+\t(change_pressure, calculate_bb_reg_pressure): New.\n+\t(one_code_hoisting_pass): Calculate register pressure. Allocate\n+\tand free data.\n+\n 2012-10-19  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcse.c: Update copyright dates."}, {"sha": "5b69aff2febbd29ec3904dd2280257c5a5be6298", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -1392,6 +1392,11 @@ Enum(ira_region) String(all) Value(IRA_REGION_ALL)\n EnumValue\n Enum(ira_region) String(mixed) Value(IRA_REGION_MIXED)\n \n+fira-hoist-pressure\n+Common Report Var(flag_ira_hoist_pressure) Init(1) Optimization\n+Use IRA based register pressure calculation\n+in RTL hoist optimizations.\n+\n fira-loop-pressure\n Common Report Var(flag_ira_loop_pressure)\n Use IRA based register pressure calculation"}, {"sha": "a66dff1353fd8f540ff20cd2ad47a16263efbaf9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -372,7 +372,7 @@ Objective-C and Objective-C++ Dialects}.\n -finline-small-functions -fipa-cp -fipa-cp-clone @gol\n -fipa-pta -fipa-profile -fipa-pure-const -fipa-reference @gol\n -fira-algorithm=@var{algorithm} @gol\n--fira-region=@var{region} @gol\n+-fira-region=@var{region} -fira-hoist-pressure @gol\n -fira-loop-pressure -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n@@ -6996,6 +6996,14 @@ This typically results in the smallest code size, and is enabled by default for\n \n @end table\n \n+@item -fira-hoist-pressure\n+@opindex fira-hoist-pressure\n+Use IRA to evaluate register pressure in the code hoisting pass for\n+decisions to hoist expressions.  This option usually results in smaller\n+code, but it can slow the compiler down.\n+\n+This option is enabled at level @option{-Os} for all targets.\n+\n @item -fira-loop-pressure\n @opindex fira-loop-pressure\n Use IRA to evaluate register pressure in loops for decisions to move"}, {"sha": "99e7685cdbab91bbb8cb97fa8a9a8b64bc70548b", "filename": "gcc/gcse.c", "status": "modified", "additions": 340, "deletions": 30, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -20,9 +20,11 @@ along with GCC; see the file COPYING3.  If not see\n \n /* TODO\n    - reordering of memory allocation and freeing to be more space efficient\n-   - do rough calc of how many regs are needed in each block, and a rough\n-     calc of how many regs are available in each class and use that to\n-     throttle back the code in cases where RTX_COST is minimal.\n+   - simulate register pressure change of each basic block accurately during\n+     hoist process.  But I doubt the benefit since most expressions hoisted\n+     are constant or address, which usually won't reduce register pressure.\n+   - calc rough register pressure information and use the info to drive all\n+     kinds of code motion (including code hoisting) in a unified way.\n */\n \n /* References searched while implementing this.\n@@ -141,11 +143,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"toplev.h\"\n \n+#include \"hard-reg-set.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"tm_p.h\"\n #include \"regs.h\"\n-#include \"hard-reg-set.h\"\n+#include \"ira.h\"\n #include \"flags.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n@@ -412,6 +415,22 @@ static bool doing_code_hoisting_p = false;\n /* For available exprs */\n static sbitmap *ae_kill;\n \f\n+/* Data stored for each basic block.  */\n+struct bb_data\n+{\n+  /* Maximal register pressure inside basic block for given register class\n+     (defined only for the pressure classes).  */\n+  int max_reg_pressure[N_REG_CLASSES];\n+};\n+\n+#define BB_DATA(bb) ((struct bb_data *) (bb)->aux)\n+\n+static basic_block curr_bb;\n+\n+/* Current register pressure for each pressure class.  */\n+static int curr_reg_pressure[N_REG_CLASSES];\n+\f\n+\n static void compute_can_copy (void);\n static void *gmalloc (size_t) ATTRIBUTE_MALLOC;\n static void *gcalloc (size_t, size_t) ATTRIBUTE_MALLOC;\n@@ -460,9 +479,11 @@ static void alloc_code_hoist_mem (int, int);\n static void free_code_hoist_mem (void);\n static void compute_code_hoist_vbeinout (void);\n static void compute_code_hoist_data (void);\n-static int hoist_expr_reaches_here_p (basic_block, int, basic_block, sbitmap,\n-\t\t\t\t      int, int *);\n+static int should_hoist_expr_to_dom (basic_block, struct expr *, basic_block,\n+\t\t\t\t     sbitmap, int, int *, enum reg_class,\n+\t\t\t\t     int *, bitmap);\n static int hoist_code (void);\n+static enum reg_class get_pressure_class_and_nregs (rtx insn, int *nregs);\n static int one_code_hoisting_pass (void);\n static rtx process_insert_insn (struct expr *);\n static int pre_edge_insert (struct edge_list *, struct expr **);\n@@ -1858,7 +1879,7 @@ prune_expressions (bool pre_p)\n \t a basic block we should account for any side-effects of a subsequent\n \t jump instructions that could clobber the expression.  It would\n \t be best to implement this check along the lines of\n-\t hoist_expr_reaches_here_p where the target block is already known\n+\t should_hoist_expr_to_dom where the target block is already known\n \t and, hence, there's no need to conservatively prune expressions on\n \t \"intermediate\" set-and-jump instructions.  */\n       FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -2826,10 +2847,21 @@ compute_code_hoist_data (void)\n     fprintf (dump_file, \"\\n\");\n }\n \n-/* Determine if the expression identified by EXPR_INDEX would\n-   reach BB unimpared if it was placed at the end of EXPR_BB.\n-   Stop the search if the expression would need to be moved more\n-   than DISTANCE instructions.\n+/* Determine if the expression EXPR should be hoisted to EXPR_BB up in\n+   flow graph, if it can reach BB unimpared.  Stop the search if the\n+   expression would need to be moved more than DISTANCE instructions.\n+\n+   DISTANCE is the number of instructions through which EXPR can be\n+   hoisted up in flow graph.\n+\n+   BB_SIZE points to an array which contains the number of instructions\n+   for each basic block.\n+\n+   PRESSURE_CLASS and NREGS are register class and number of hard registers\n+   for storing EXPR.\n+\n+   HOISTED_BBS points to a bitmap indicating basic blocks through which\n+   EXPR is hoisted.\n \n    It's unclear exactly what Muchnick meant by \"unimpared\".  It seems\n    to me that the expression must either be computed or transparent in\n@@ -2842,18 +2874,32 @@ compute_code_hoist_data (void)\n    paths.  */\n \n static int\n-hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n-\t\t\t   sbitmap visited, int distance, int *bb_size)\n+should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n+\t\t\t  basic_block bb, sbitmap visited, int distance,\n+\t\t\t  int *bb_size, enum reg_class pressure_class,\n+\t\t\t  int *nregs, bitmap hoisted_bbs)\n {\n+  unsigned int i;\n   edge pred;\n   edge_iterator ei;\n+  sbitmap_iterator sbi;\n   int visited_allocated_locally = 0;\n \n   /* Terminate the search if distance, for which EXPR is allowed to move,\n      is exhausted.  */\n   if (distance > 0)\n     {\n-      distance -= bb_size[bb->index];\n+      /* Let EXPR be hoisted through basic block at no cost if the block\n+\t has low register pressure.  An exception is constant expression,\n+\t because hoisting constant expr aggressively results in worse code.\n+\t The exception is made by the observation of CSiBE on ARM target,\n+\t while it has no obvious effect on other targets like x86, x86_64,\n+\t mips and powerpc.  */\n+      if (!flag_ira_hoist_pressure\n+\t  || (BB_DATA (bb)->max_reg_pressure[pressure_class]\n+\t\t>= ira_class_hard_regs_num[pressure_class]\n+\t      || CONST_INT_P (expr->expr)))\n+\tdistance -= bb_size[bb->index];\n \n       if (distance <= 0)\n \treturn 0;\n@@ -2878,21 +2924,35 @@ hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n \tcontinue;\n       else if (TEST_BIT (visited, pred_bb->index))\n \tcontinue;\n-\n-      else if (! TEST_BIT (transp[pred_bb->index], expr_index))\n+      else if (! TEST_BIT (transp[pred_bb->index], expr->bitmap_index))\n \tbreak;\n-\n       /* Not killed.  */\n       else\n \t{\n \t  SET_BIT (visited, pred_bb->index);\n-\t  if (! hoist_expr_reaches_here_p (expr_bb, expr_index, pred_bb,\n-\t\t\t\t\t   visited, distance, bb_size))\n+\t  if (! should_hoist_expr_to_dom (expr_bb, expr, pred_bb,\n+\t\t\t\t\t  visited, distance, bb_size,\n+\t\t\t\t\t  pressure_class, nregs, hoisted_bbs))\n \t    break;\n \t}\n     }\n   if (visited_allocated_locally)\n-    sbitmap_free (visited);\n+    {\n+      /* If EXPR can be hoisted to expr_bb, record basic blocks through\n+\t which EXPR is hoisted in hoisted_bbs.  Also update register\n+\t pressure for basic blocks newly added in hoisted_bbs.  */\n+      if (flag_ira_hoist_pressure && !pred)\n+\t{\n+\t  EXECUTE_IF_SET_IN_SBITMAP (visited, 0, i, sbi)\n+\t    if (!bitmap_bit_p (hoisted_bbs, i))\n+\t      {\n+\t\tbitmap_set_bit (hoisted_bbs, i);\n+\t\tBB_DATA (BASIC_BLOCK (i))->max_reg_pressure[pressure_class]\n+\t\t    += *nregs;\n+\t      }\n+\t}\n+      sbitmap_free (visited);\n+    }\n \n   return (pred == NULL);\n }\n@@ -2909,7 +2969,44 @@ find_occr_in_bb (struct occr *occr, basic_block bb)\n   return occr;\n }\n \n-/* Actually perform code hoisting.  */\n+/* Actually perform code hoisting.\n+\n+   The code hoisting pass can hoist multiple computations of the same\n+   expression along dominated path to a dominating basic block, like\n+   from b2/b3 to b1 as depicted below:\n+\n+          b1      ------\n+          /\\         |\n+         /  \\        |\n+        bx   by   distance\n+       /      \\      |\n+      /        \\     |\n+     b2        b3 ------\n+\n+   Unfortunately code hoisting generally extends the live range of an\n+   output pseudo register, which increases register pressure and hurts\n+   register allocation.  To address this issue, an attribute MAX_DISTANCE\n+   is computed and attached to each expression.  The attribute is computed\n+   from rtx cost of the corresponding expression and it's used to control\n+   how long the expression can be hoisted up in flow graph.  As the\n+   expression is hoisted up in flow graph, GCC decreases its DISTANCE\n+   and stops the hoist if DISTANCE reaches 0.\n+\n+   Option \"-fira-hoist-pressure\" implements register pressure directed\n+   hoist based on upper method.  The rationale is:\n+     1. Calculate register pressure for each basic block by reusing IRA\n+\tfacility.\n+     2. When expression is hoisted through one basic block, GCC checks\n+\tregister pressure of the basic block and decrease DISTANCE only\n+\twhen the register pressure is high.  In other words, expression\n+\twill be hoisted through basic block with low register pressure\n+\tat no cost.\n+     3. Update register pressure information for basic blocks through\n+ \twhich expression is hoisted.\n+\tTODO: It is possible to have register pressure decreased because\n+\tof shrinked live ranges of input pseudo registers when hoisting\n+\tan expression.  For now, this effect is not simulated and we just\n+\tincrease register pressure for hoisted expressions.  */\n \n static int\n hoist_code (void)\n@@ -2918,12 +3015,18 @@ hoist_code (void)\n   VEC (basic_block, heap) *dom_tree_walk;\n   unsigned int dom_tree_walk_index;\n   VEC (basic_block, heap) *domby;\n-  unsigned int i,j;\n+  unsigned int i, j, k;\n   struct expr **index_map;\n   struct expr *expr;\n   int *to_bb_head;\n   int *bb_size;\n   int changed = 0;\n+  struct bb_data *data;\n+  /* Basic blocks that have occurrences reachable from BB.  */\n+  bitmap from_bbs;\n+  /* Basic blocks through which expr is hoisted.  */\n+  bitmap hoisted_bbs = NULL;\n+  bitmap_iterator bi;\n \n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n@@ -2961,6 +3064,10 @@ hoist_code (void)\n \t      && (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest\n \t\t  == ENTRY_BLOCK_PTR->next_bb));\n \n+  from_bbs = BITMAP_ALLOC (NULL);\n+  if (flag_ira_hoist_pressure)\n+    hoisted_bbs = BITMAP_ALLOC (NULL);\n+\n   dom_tree_walk = get_all_dominated_blocks (CDI_DOMINATORS,\n \t\t\t\t\t    ENTRY_BLOCK_PTR->next_bb);\n \n@@ -2979,21 +3086,19 @@ hoist_code (void)\n \t{\n \t  if (TEST_BIT (hoist_vbeout[bb->index], i))\n \t    {\n+\t      int nregs = 0;\n+\t      enum reg_class pressure_class = NO_REGS;\n \t      /* Current expression.  */\n \t      struct expr *expr = index_map[i];\n \t      /* Number of occurrences of EXPR that can be hoisted to BB.  */\n \t      int hoistable = 0;\n-\t      /* Basic blocks that have occurrences reachable from BB.  */\n-\t      bitmap_head _from_bbs, *from_bbs = &_from_bbs;\n \t      /* Occurrences reachable from BB.  */\n \t      VEC (occr_t, heap) *occrs_to_hoist = NULL;\n \t      /* We want to insert the expression into BB only once, so\n \t\t note when we've inserted it.  */\n \t      int insn_inserted_p;\n \t      occr_t occr;\n \n-\t      bitmap_initialize (from_bbs, 0);\n-\n \t      /* If an expression is computed in BB and is available at end of\n \t\t BB, hoist all occurrences dominated by BB to BB.  */\n \t      if (TEST_BIT (comp[bb->index], i))\n@@ -3047,13 +3152,18 @@ hoist_code (void)\n \t\t    max_distance += (bb_size[dominated->index]\n \t\t\t\t     - to_bb_head[INSN_UID (occr->insn)]);\n \n-\t\t  /* Note if the expression would reach the dominated block\n-\t\t     unimpared if it was placed at the end of BB.\n+\t\t  pressure_class = get_pressure_class_and_nregs (occr->insn,\n+\t\t\t\t\t\t\t\t &nregs);\n+\n+\t\t  /* Note if the expression should be hoisted from the dominated\n+\t\t     block to BB if it can reach DOMINATED unimpared.\n \n \t\t     Keep track of how many times this expression is hoistable\n \t\t     from a dominated block into BB.  */\n-\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL,\n-\t\t\t\t\t\t max_distance, bb_size))\n+\t\t  if (should_hoist_expr_to_dom (bb, expr, dominated, NULL,\n+\t\t\t\t\t\tmax_distance, bb_size,\n+\t\t\t\t\t\tpressure_class,\t&nregs,\n+\t\t\t\t\t\thoisted_bbs))\n \t\t    {\n \t\t      hoistable++;\n \t\t      VEC_safe_push (occr_t, heap,\n@@ -3094,6 +3204,28 @@ hoist_code (void)\n \t\t/* Punt, no point hoisting a single occurence.  */\n \t\tVEC_free (occr_t, heap, occrs_to_hoist);\n \n+\t      if (flag_ira_hoist_pressure\n+\t\t  && !VEC_empty (occr_t, occrs_to_hoist))\n+\t\t{\n+\t\t  /* Update register pressure for basic block to which expr\n+\t\t     is hoisted.  */\n+\t\t  data = BB_DATA (bb);\n+\t\t  data->max_reg_pressure[pressure_class] += nregs;\n+\t\t}\n+\t      else if (flag_ira_hoist_pressure)\n+\t\t{\n+\t\t  /* Restore register pressure of basic block recorded in\n+\t\t     hoisted_bbs when expr will not be hoisted.  */\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (hoisted_bbs, 0, k, bi)\n+\t\t    {\n+\t\t      data = BB_DATA (BASIC_BLOCK (k));\n+\t\t      data->max_reg_pressure[pressure_class] -= nregs;\n+\t\t    }\n+\t\t}\n+\n+\t      if (flag_ira_hoist_pressure)\n+\t\tbitmap_clear (hoisted_bbs);\n+\n \t      insn_inserted_p = 0;\n \n \t      /* Walk through occurrences of I'th expressions we want\n@@ -3142,13 +3274,176 @@ hoist_code (void)\n     }\n \n   VEC_free (basic_block, heap, dom_tree_walk);\n+  BITMAP_FREE (from_bbs);\n+  if (flag_ira_hoist_pressure)\n+    BITMAP_FREE (hoisted_bbs);\n+\n   free (bb_size);\n   free (to_bb_head);\n   free (index_map);\n \n   return changed;\n }\n \n+/* Return pressure class and number of needed hard registers (through\n+   *NREGS) of register REGNO.  */\n+static enum reg_class\n+get_regno_pressure_class (int regno, int *nregs)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      enum reg_class pressure_class;\n+\n+      pressure_class = reg_allocno_class (regno);\n+      pressure_class = ira_pressure_class_translate[pressure_class];\n+      *nregs\n+\t= ira_reg_class_max_nregs[pressure_class][PSEUDO_REGNO_MODE (regno)];\n+      return pressure_class;\n+    }\n+  else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno)\n+\t   && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n+    {\n+      *nregs = 1;\n+      return ira_pressure_class_translate[REGNO_REG_CLASS (regno)];\n+    }\n+  else\n+    {\n+      *nregs = 0;\n+      return NO_REGS;\n+    }\n+}\n+\n+/* Return pressure class and number of hard registers (through *NREGS)\n+   for destination of INSN. */\n+static enum reg_class\n+get_pressure_class_and_nregs (rtx insn, int *nregs)\n+{\n+  rtx reg;\n+  enum reg_class pressure_class;\n+  rtx set = single_set (insn);\n+\n+  /* Considered invariant insns have only one set.  */\n+  gcc_assert (set != NULL_RTX);\n+  reg = SET_DEST (set);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  if (MEM_P (reg))\n+    {\n+      *nregs = 0;\n+      pressure_class = NO_REGS;\n+    }\n+  else\n+    {\n+      gcc_assert (REG_P (reg));\n+      pressure_class = reg_allocno_class (REGNO (reg));\n+      pressure_class = ira_pressure_class_translate[pressure_class];\n+      *nregs\n+\t= ira_reg_class_max_nregs[pressure_class][GET_MODE (SET_SRC (set))];\n+    }\n+  return pressure_class;\n+}\n+\n+/* Increase (if INCR_P) or decrease current register pressure for\n+   register REGNO.  */\n+static void\n+change_pressure (int regno, bool incr_p)\n+{\n+  int nregs;\n+  enum reg_class pressure_class;\n+\n+  pressure_class = get_regno_pressure_class (regno, &nregs);\n+  if (! incr_p)\n+    curr_reg_pressure[pressure_class] -= nregs;\n+  else\n+    {\n+      curr_reg_pressure[pressure_class] += nregs;\n+      if (BB_DATA (curr_bb)->max_reg_pressure[pressure_class]\n+\t  < curr_reg_pressure[pressure_class])\n+\tBB_DATA (curr_bb)->max_reg_pressure[pressure_class]\n+\t  = curr_reg_pressure[pressure_class];\n+    }\n+}\n+\n+/* Calculate register pressure for each basic block by walking insns\n+   from last to first.  */\n+static void\n+calculate_bb_reg_pressure (void)\n+{\n+  int i;\n+  unsigned int j;\n+  rtx insn;\n+  basic_block bb;\n+  bitmap curr_regs_live;\n+  bitmap_iterator bi;\n+\n+\n+  ira_setup_eliminable_regset ();\n+  curr_regs_live = BITMAP_ALLOC (&reg_obstack);\n+  FOR_EACH_BB (bb)\n+    {\n+      curr_bb = bb;\n+      bitmap_copy (curr_regs_live, DF_LR_OUT (bb));\n+      for (i = 0; i < ira_pressure_classes_num; i++)\n+\tcurr_reg_pressure[ira_pressure_classes[i]] = 0;\n+      EXECUTE_IF_SET_IN_BITMAP (curr_regs_live, 0, j, bi)\n+\tchange_pressure (j, true);\n+\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+\t{\n+\t  rtx dreg;\n+\t  int regno;\n+\t  df_ref *def_rec, *use_rec;\n+\n+\t  if (! NONDEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    {\n+\t      dreg = DF_REF_REAL_REG (*def_rec);\n+\t      gcc_assert (REG_P (dreg));\n+\t      regno = REGNO (dreg);\n+\t      if (!(DF_REF_FLAGS (*def_rec) \n+\t\t    & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\t\t{\n+\t\t  if (bitmap_clear_bit (curr_regs_live, regno))\n+\t\t    change_pressure (regno, false);\n+\t\t}\n+\t    }\n+\n+\t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t    {\n+\t      dreg = DF_REF_REAL_REG (*use_rec);\n+\t      gcc_assert (REG_P (dreg));\n+\t      regno = REGNO (dreg);\n+\t      if (bitmap_set_bit (curr_regs_live, regno))\n+\t\tchange_pressure (regno, true);\n+\t    }\n+\t}\n+    }\n+  BITMAP_FREE (curr_regs_live);\n+\n+  if (dump_file == NULL)\n+    return;\n+\n+  fprintf (dump_file, \"\\nRegister Pressure: \\n\");\n+  FOR_EACH_BB (bb)\n+    {\n+      fprintf (dump_file, \"  Basic block %d: \\n\", bb->index);\n+      for (i = 0; (int) i < ira_pressure_classes_num; i++)\n+\t{\n+\t  enum reg_class pressure_class;\n+\n+\t  pressure_class = ira_pressure_classes[i];\n+\t  if (BB_DATA (bb)->max_reg_pressure[pressure_class] == 0)\n+\t    continue;\n+\n+\t  fprintf (dump_file, \"    %s=%d\\n\", reg_class_names[pressure_class],\n+\t\t   BB_DATA (bb)->max_reg_pressure[pressure_class]);\n+\t}\n+    }\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n /* Top level routine to perform one code hoisting (aka unification) pass\n \n    Return nonzero if a change was made.  */\n@@ -3168,6 +3463,16 @@ one_code_hoisting_pass (void)\n \n   doing_code_hoisting_p = true;\n \n+  /* Calculate register pressure for each basic block.  */\n+  if (flag_ira_hoist_pressure)\n+    {\n+      regstat_init_n_sets_and_refs ();\n+      ira_set_pseudo_classes (false, dump_file);\n+      alloc_aux_for_blocks (sizeof (struct bb_data));\n+      calculate_bb_reg_pressure ();\n+      regstat_free_n_sets_and_refs ();\n+    }\n+\n   /* We need alias.  */\n   init_alias_analysis ();\n \n@@ -3188,6 +3493,11 @@ one_code_hoisting_pass (void)\n       free_code_hoist_mem ();\n     }\n \n+  if (flag_ira_hoist_pressure)\n+    {\n+      free_aux_for_blocks ();\n+      free_reg_info ();\n+    }\n   free_hash_table (&expr_hash_table);\n   free_gcse_mem ();\n   obstack_free (&gcse_obstack, NULL);"}, {"sha": "838d3a5161d8c45f84e6cd6c8d46aad5d9866db0", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -6633,7 +6633,7 @@ sched_init (void)\n \t/* We need info about pseudos for rtl dumps about pseudo\n \t   classes and costs.  */\n \tregstat_init_n_sets_and_refs ();\n-      ira_set_pseudo_classes (sched_verbose ? sched_dump : NULL);\n+      ira_set_pseudo_classes (true, sched_verbose ? sched_dump : NULL);\n       sched_regno_pressure_class\n \t= (enum reg_class *) xmalloc (max_regno * sizeof (enum reg_class));\n       for (i = 0; i < max_regno; i++)"}, {"sha": "034eff831ed8b613089fec83a32fa0fce5c69fc1", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -2048,9 +2048,10 @@ ira_costs (void)\n   ira_free (total_allocno_costs);\n }\n \n-/* Entry function which defines classes for pseudos.  */\n+/* Entry function which defines classes for pseudos.\n+   Set pseudo_classes_defined_p only if DEFINE_PSEUDO_CLASSES is true.  */\n void\n-ira_set_pseudo_classes (FILE *dump_file)\n+ira_set_pseudo_classes (bool define_pseudo_classes, FILE *dump_file)\n {\n   allocno_p = false;\n   internal_flag_ira_verbose = flag_ira_verbose;\n@@ -2059,7 +2060,9 @@ ira_set_pseudo_classes (FILE *dump_file)\n   initiate_regno_cost_classes ();\n   find_costs_and_classes (dump_file);\n   finish_regno_cost_classes ();\n-  pseudo_classes_defined_p = true;\n+  if (define_pseudo_classes)\n+    pseudo_classes_defined_p = true;\n+\n   finish_costs ();\n }\n "}, {"sha": "78b3f92db00fb4173ce14649b0fcd6e65ecf7244", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -4186,7 +4186,7 @@ ira (FILE *f)\n   crtl->is_leaf = leaf_function_p ();\n \n   if (resize_reg_info () && flag_ira_loop_pressure)\n-    ira_set_pseudo_classes (ira_dump_file);\n+    ira_set_pseudo_classes (true, ira_dump_file);\n \n   rebuild_p = update_equiv_regs ();\n "}, {"sha": "0cafdf4a94cccd999bd04ff3ea71c735585dc11a", "filename": "gcc/ira.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -1,6 +1,6 @@\n /* Communication between the Integrated Register Allocator (IRA) and\n    the rest of the compiler.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n \n@@ -131,7 +131,7 @@ extern void ira_init (void);\n extern void ira_finish_once (void);\n extern void ira_setup_eliminable_regset (void);\n extern rtx ira_eliminate_regs (rtx, enum machine_mode);\n-extern void ira_set_pseudo_classes (FILE *);\n+extern void ira_set_pseudo_classes (bool, FILE *);\n extern void ira_implicitly_set_insn_hard_regs (HARD_REG_SET *);\n \n extern void ira_sort_regnos_for_alter_reg (int *, int, unsigned int *);"}, {"sha": "996e6e3a645442cdb9bb0ab20be33a28a3f101a1", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -1,5 +1,5 @@\n /* RTL-level loop invariant motion.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1939,7 +1939,7 @@ move_loop_invariants (void)\n     {\n       df_analyze ();\n       regstat_init_n_sets_and_refs ();\n-      ira_set_pseudo_classes (dump_file);\n+      ira_set_pseudo_classes (true, dump_file);\n       calculate_loop_reg_pressure ();\n       regstat_free_n_sets_and_refs ();\n     }"}, {"sha": "408366d9d2b4e13f8e694c5063be43c194d9c926", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -1,6 +1,7 @@\n /* Move registers around to reduce number of move instructions needed.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2012\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1237,7 +1238,7 @@ regmove_optimize (void)\n   regstat_compute_ri ();\n \n   if (flag_ira_loop_pressure)\n-    ira_set_pseudo_classes (dump_file);\n+    ira_set_pseudo_classes (true, dump_file);\n \n   regno_src_regno = XNEWVEC (int, nregs);\n   for (i = nregs; --i >= 0; )"}, {"sha": "57d4383f1746f4da765de51566c1d55ba19b5210", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -1,3 +1,7 @@\n+2012-10-19  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* testsuite/gcc.dg/hoist-register-pressure.c: New test.\n+\n 2012-10-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/54501"}, {"sha": "6077f1e578228f71c25e1084907854b43623a4d2", "filename": "gcc/testsuite/gcc.dg/hoist-register-pressure.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure.c?ref=b11f0116d6e5e89dca5b1bfd56ba54fda3e05bf7", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-options \"-Os -fdump-rtl-hoist\" }  */\n+/* { dg-final { scan-rtl-dump \"PRE/HOIST: end of bb .* copying expression\" \"hoist\" } } */\n+\n+#define BUF 100\n+int a[BUF];\n+\n+void com (int);\n+void bar (int);\n+\n+int foo (int x, int y, int z)\n+{\n+  /* \"x+y\" won't be hoisted if \"-fira-hoist-pressure\" is disabled,\n+     because its rtx_cost is too small.  */\n+  if (z)\n+    {\n+      a[1] = a[0] + a[2];\n+      a[2] = a[1] + a[3];\n+      a[3] = a[2] + a[4];\n+      a[4] = a[3] + a[5];\n+      a[5] = a[4] + a[6];\n+      a[6] = a[5] + a[7];\n+      a[7] = a[6] + a[8];\n+      com (x+y);\n+    }\n+  else\n+    {\n+      bar (x+y);\n+    }\n+\n+  return 0;\n+}"}]}