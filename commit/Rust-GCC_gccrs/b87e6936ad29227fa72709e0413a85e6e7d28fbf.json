{"sha": "b87e6936ad29227fa72709e0413a85e6e7d28fbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg3ZTY5MzZhZDI5MjI3ZmE3MjcwOWUwNDEzYTg1ZTZlN2QyOGZiZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-13T15:51:08Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-13T15:51:08Z"}, "message": "builtins.c (fold_trunc_transparent_mathfn, [...]): Use TYPE (TYPE (fndecl)) instead of TREE_TYPE (exp).\n\n\t* builtins.c (fold_trunc_transparent_mathfn,\n\tfold_fixed_mathfn, fold_builtin_atan, fold_builtin_trunc,\n\tfold_builtin_floor, fold_builtin_ceil, fold_builtin_round,\n\tfold_builtin_lround, fold_builtin_bitop, fold_builtin_memcpy,\n\tfold_builtin_strcpy, fold_builtin_strncpy,\n\tfold_builtin_signbit): Use TYPE (TYPE (fndecl)) instead of\n\tTREE_TYPE (exp).\n\nFrom-SVN: r96371", "tree": {"sha": "29378a09dc59fdbb2eaa941921e1c6e0ba4aabfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29378a09dc59fdbb2eaa941921e1c6e0ba4aabfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b87e6936ad29227fa72709e0413a85e6e7d28fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87e6936ad29227fa72709e0413a85e6e7d28fbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b87e6936ad29227fa72709e0413a85e6e7d28fbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87e6936ad29227fa72709e0413a85e6e7d28fbf/comments", "author": null, "committer": null, "parents": [{"sha": "13d21cb725650e19a583498a1ca60ba2cf97bcf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13d21cb725650e19a583498a1ca60ba2cf97bcf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13d21cb725650e19a583498a1ca60ba2cf97bcf4"}], "stats": {"total": 53, "additions": 36, "deletions": 17}, "files": [{"sha": "0fd69f9f34707df55b7bc983907f78e47fadbf9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87e6936ad29227fa72709e0413a85e6e7d28fbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87e6936ad29227fa72709e0413a85e6e7d28fbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b87e6936ad29227fa72709e0413a85e6e7d28fbf", "patch": "@@ -9,6 +9,14 @@\n \t* c-decl.c (c_init_decl_processing): Remove useless calls to\n \tbuild_function_type.\n \n+\t* builtins.c (fold_trunc_transparent_mathfn,\n+\tfold_fixed_mathfn, fold_builtin_atan, fold_builtin_trunc,\n+\tfold_builtin_floor, fold_builtin_ceil, fold_builtin_round,\n+\tfold_builtin_lround, fold_builtin_bitop, fold_builtin_memcpy,\n+\tfold_builtin_strcpy, fold_builtin_strncpy,\n+\tfold_builtin_signbit): Use TYPE (TYPE (fndecl)) instead of\n+\tTREE_TYPE (exp).\n+\n 2005-03-13  Andy Hutchinson  <HutchinsonAndy@netscape.net>\n \n \tPR target/18251"}, {"sha": "0185c676bf67d01f994312294de7d691bbb6622f", "filename": "gcc/builtins.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87e6936ad29227fa72709e0413a85e6e7d28fbf/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87e6936ad29227fa72709e0413a85e6e7d28fbf/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b87e6936ad29227fa72709e0413a85e6e7d28fbf", "patch": "@@ -6091,7 +6091,7 @@ fold_trunc_transparent_mathfn (tree exp)\n   if (optimize)\n     {\n       tree arg0 = strip_float_extensions (arg);\n-      tree ftype = TREE_TYPE (exp);\n+      tree ftype = TREE_TYPE (TREE_TYPE (fndecl));\n       tree newtype = TREE_TYPE (arg0);\n       tree decl;\n \n@@ -6126,7 +6126,7 @@ fold_fixed_mathfn (tree exp)\n   /* If argument is already integer valued, and we don't need to worry\n      about setting errno, there's no need to perform rounding.  */\n   if (! flag_errno_math && integer_valued_real_p (arg))\n-    return fold (build1 (FIX_TRUNC_EXPR, TREE_TYPE (exp), arg));\n+    return fold (build1 (FIX_TRUNC_EXPR, TREE_TYPE (TREE_TYPE (fndecl)), arg));\n \n   if (optimize)\n     {\n@@ -6504,6 +6504,7 @@ fold_builtin_atan (tree arglist, tree type)\n static tree\n fold_builtin_trunc (tree exp)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree arg;\n \n@@ -6515,7 +6516,7 @@ fold_builtin_trunc (tree exp)\n   if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n     {\n       REAL_VALUE_TYPE r, x;\n-      tree type = TREE_TYPE (exp);\n+      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n \n       x = TREE_REAL_CST (arg);\n       real_trunc (&r, TYPE_MODE (type), &x);\n@@ -6531,6 +6532,7 @@ fold_builtin_trunc (tree exp)\n static tree\n fold_builtin_floor (tree exp)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree arg;\n \n@@ -6546,7 +6548,7 @@ fold_builtin_floor (tree exp)\n       x = TREE_REAL_CST (arg);\n       if (! REAL_VALUE_ISNAN (x) || ! flag_errno_math)\n \t{\n-\t  tree type = TREE_TYPE (exp);\n+\t  tree type = TREE_TYPE (TREE_TYPE (fndecl));\n \t  REAL_VALUE_TYPE r;\n \n \t  real_floor (&r, TYPE_MODE (type), &x);\n@@ -6563,6 +6565,7 @@ fold_builtin_floor (tree exp)\n static tree\n fold_builtin_ceil (tree exp)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree arg;\n \n@@ -6578,7 +6581,7 @@ fold_builtin_ceil (tree exp)\n       x = TREE_REAL_CST (arg);\n       if (! REAL_VALUE_ISNAN (x) || ! flag_errno_math)\n \t{\n-\t  tree type = TREE_TYPE (exp);\n+\t  tree type = TREE_TYPE (TREE_TYPE (fndecl));\n \t  REAL_VALUE_TYPE r;\n \n \t  real_ceil (&r, TYPE_MODE (type), &x);\n@@ -6595,6 +6598,7 @@ fold_builtin_ceil (tree exp)\n static tree\n fold_builtin_round (tree exp)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree arg;\n \n@@ -6610,7 +6614,7 @@ fold_builtin_round (tree exp)\n       x = TREE_REAL_CST (arg);\n       if (! REAL_VALUE_ISNAN (x) || ! flag_errno_math)\n \t{\n-\t  tree type = TREE_TYPE (exp);\n+\t  tree type = TREE_TYPE (TREE_TYPE (fndecl));\n \t  REAL_VALUE_TYPE r;\n \n \t  real_round (&r, TYPE_MODE (type), &x);\n@@ -6628,6 +6632,7 @@ fold_builtin_round (tree exp)\n static tree\n fold_builtin_lround (tree exp)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree arg;\n \n@@ -6642,7 +6647,8 @@ fold_builtin_lround (tree exp)\n \n       if (! REAL_VALUE_ISNAN (x) && ! REAL_VALUE_ISINF (x))\n \t{\n-\t  tree itype = TREE_TYPE (exp), ftype = TREE_TYPE (arg), result;\n+\t  tree itype = TREE_TYPE (TREE_TYPE (fndecl));\n+\t  tree ftype = TREE_TYPE (arg), result;\n \t  HOST_WIDE_INT hi, lo;\n \t  REAL_VALUE_TYPE r;\n \n@@ -6757,7 +6763,7 @@ fold_builtin_bitop (tree exp)\n \t  gcc_unreachable ();\n \t}\n \n-      return build_int_cst (TREE_TYPE (exp), result);\n+      return build_int_cst (TREE_TYPE (TREE_TYPE (fndecl)), result);\n     }\n \n   return NULL_TREE;\n@@ -7160,6 +7166,7 @@ fold_builtin_exponent (tree fndecl, tree arglist,\n static tree\n fold_builtin_memcpy (tree exp)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree dest, src, len;\n \n@@ -7173,11 +7180,11 @@ fold_builtin_memcpy (tree exp)\n \n   /* If the LEN parameter is zero, return DEST.  */\n   if (integer_zerop (len))\n-    return omit_one_operand (TREE_TYPE (exp), dest, src);\n+    return omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, src);\n \n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n   if (operand_equal_p (src, dest, 0))\n-    return omit_one_operand (TREE_TYPE (exp), dest, len);\n+    return omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, len);\n \n   return 0;\n }\n@@ -7251,6 +7258,7 @@ fold_builtin_memmove (tree arglist, tree type)\n tree\n fold_builtin_strcpy (tree exp, tree len)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree dest, src, fn;\n \n@@ -7263,7 +7271,7 @@ fold_builtin_strcpy (tree exp, tree len)\n \n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n   if (operand_equal_p (src, dest, 0))\n-    return fold_convert (TREE_TYPE (exp), dest);\n+    return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)), dest);\n \n   if (optimize_size)\n     return 0;\n@@ -7283,7 +7291,7 @@ fold_builtin_strcpy (tree exp, tree len)\n   arglist = build_tree_list (NULL_TREE, len);\n   arglist = tree_cons (NULL_TREE, src, arglist);\n   arglist = tree_cons (NULL_TREE, dest, arglist);\n-  return fold_convert (TREE_TYPE (exp),\n+  return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)),\n \t\t       build_function_call_expr (fn, arglist));\n }\n \n@@ -7294,6 +7302,7 @@ fold_builtin_strcpy (tree exp, tree len)\n tree\n fold_builtin_strncpy (tree exp, tree slen)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree dest, src, len, fn;\n \n@@ -7307,7 +7316,7 @@ fold_builtin_strncpy (tree exp, tree slen)\n \n   /* If the LEN parameter is zero, return DEST.  */\n   if (integer_zerop (len))\n-    return omit_one_operand (TREE_TYPE (exp), dest, src);\n+    return omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, src);\n \n   /* We can't compare slen with len as constants below if len is not a\n      constant.  */\n@@ -7333,7 +7342,7 @@ fold_builtin_strncpy (tree exp, tree slen)\n   fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n   if (!fn)\n     return 0;\n-  return fold_convert (TREE_TYPE (exp),\n+  return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)),\n \t\t       build_function_call_expr (fn, arglist));\n }\n \n@@ -7556,7 +7565,9 @@ fold_builtin_strncmp (tree arglist)\n static tree\n fold_builtin_signbit (tree exp)\n {\n+  tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n+  tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   tree arg, temp;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n@@ -7572,16 +7583,16 @@ fold_builtin_signbit (tree exp)\n \n       c = TREE_REAL_CST (arg);\n       temp = REAL_VALUE_NEGATIVE (c) ? integer_one_node : integer_zero_node;\n-      return fold_convert (TREE_TYPE (exp), temp);\n+      return fold_convert (type, temp);\n     }\n \n   /* If ARG is non-negative, the result is always zero.  */\n   if (tree_expr_nonnegative_p (arg))\n-    return omit_one_operand (TREE_TYPE (exp), integer_zero_node, arg);\n+    return omit_one_operand (type, integer_zero_node, arg);\n \n   /* If ARG's format doesn't have signed zeros, return \"arg < 0.0\".  */\n   if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg))))\n-    return fold (build2 (LT_EXPR, TREE_TYPE (exp), arg,\n+    return fold (build2 (LT_EXPR, type, arg,\n \t\t\t build_real (TREE_TYPE (arg), dconst0)));\n \n   return NULL_TREE;"}]}