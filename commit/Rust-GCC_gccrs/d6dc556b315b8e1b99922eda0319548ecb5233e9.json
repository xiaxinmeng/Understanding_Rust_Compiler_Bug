{"sha": "d6dc556b315b8e1b99922eda0319548ecb5233e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkYzU1NmIzMTViOGUxYjk5OTIyZWRhMDMxOTU0OGVjYjUyMzNlOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-05-22T22:25:15Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-05-22T22:25:15Z"}, "message": "builtins.c (expand_builtin_strstr, [...]): Replace calls to build with calls to build2, build3 or omit_one_operand.\n\n\n\t* builtins.c (expand_builtin_strstr, expand_builtin_strchr,\n\texpand_builtin_strrchr, expand_builtin_strpbrk,\n\texpand_builtin_mempcpy, expand_builtin_memcmp,\n\texpand_builtin_strcmp, expand_builtin_strncmp,\n\texpand_builtin_strcat, std_expand_builtin_va_start,\n\tstd_expand_builtin_va_arg, expand_builtin_va_copy,\n\texpand_builtin_signbit, fold_builtin_cabs,\n\tfold_builtin_logarithm, fold_builtin_mempcpy,\n\tfold_builtin_signbit, fold_builtin_isascii,\n\tfold_builtin_toascii, fold_builtin_isdigit,\n\tfold_builtin_1, build_function_call_expr,\n\tsimplify_builtin_strchr, simplify_builtin_strrchr,\n\tsimplify_builtin_strpbrk, simplify_builtin_strncpy,\n\tsimplify_builtin_memcmp, simplify_builtin_strcmp,\n\tsimplify_builtin_strncmp, simplify_builtin_strncat,\n\tsimplify_builtin_strspn, simplify_builtin_strcspn,\n\tsimplify_builtin_fputs, simplify_builtin_sprintf): Replace calls\n\tto build with calls to build2, build3 or omit_one_operand.\n\nFrom-SVN: r82151", "tree": {"sha": "848f21b5e8c21b0a279789eabf1115c5891d227e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/848f21b5e8c21b0a279789eabf1115c5891d227e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6dc556b315b8e1b99922eda0319548ecb5233e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6dc556b315b8e1b99922eda0319548ecb5233e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6dc556b315b8e1b99922eda0319548ecb5233e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6dc556b315b8e1b99922eda0319548ecb5233e9/comments", "author": null, "committer": null, "parents": [{"sha": "f4a1faa55f8f157e36e9b6194055c6dc8fbe2763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a1faa55f8f157e36e9b6194055c6dc8fbe2763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a1faa55f8f157e36e9b6194055c6dc8fbe2763"}], "stats": {"total": 298, "additions": 156, "deletions": 142}, "files": [{"sha": "e3a273dd248cc7dbe689075173b4632587067728", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dc556b315b8e1b99922eda0319548ecb5233e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dc556b315b8e1b99922eda0319548ecb5233e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6dc556b315b8e1b99922eda0319548ecb5233e9", "patch": "@@ -1,3 +1,24 @@\n+2004-05-22  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (expand_builtin_strstr, expand_builtin_strchr,\n+\texpand_builtin_strrchr, expand_builtin_strpbrk,\n+\texpand_builtin_mempcpy, expand_builtin_memcmp,\n+\texpand_builtin_strcmp, expand_builtin_strncmp,\n+\texpand_builtin_strcat, std_expand_builtin_va_start,\n+\tstd_expand_builtin_va_arg, expand_builtin_va_copy,\n+\texpand_builtin_signbit, fold_builtin_cabs,\n+\tfold_builtin_logarithm, fold_builtin_mempcpy,\n+\tfold_builtin_signbit, fold_builtin_isascii,\n+\tfold_builtin_toascii, fold_builtin_isdigit,\n+\tfold_builtin_1, build_function_call_expr,\n+\tsimplify_builtin_strchr, simplify_builtin_strrchr,\n+\tsimplify_builtin_strpbrk, simplify_builtin_strncpy,\n+\tsimplify_builtin_memcmp, simplify_builtin_strcmp,\n+\tsimplify_builtin_strncmp, simplify_builtin_strncat,\n+\tsimplify_builtin_strspn, simplify_builtin_strcspn,\n+\tsimplify_builtin_fputs, simplify_builtin_sprintf): Replace calls\n+\tto build with calls to build2, build3 or omit_one_operand.\n+\n 2004-05-22  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_file_start): Emit a .gcc_compiled_longXX"}, {"sha": "2457d66142110d05b5bc5a4006b96a776a3c856b", "filename": "gcc/builtins.c", "status": "modified", "additions": 135, "deletions": 142, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dc556b315b8e1b99922eda0319548ecb5233e9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dc556b315b8e1b99922eda0319548ecb5233e9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d6dc556b315b8e1b99922eda0319548ecb5233e9", "patch": "@@ -2458,7 +2458,7 @@ expand_builtin_strstr (tree arglist, rtx target, enum machine_mode mode)\n   else\n     {\n       tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree fn;\n+      tree fn, tmp;\n       const char *p1, *p2;\n \n       p2 = c_getstr (s2);\n@@ -2474,10 +2474,10 @@ expand_builtin_strstr (tree arglist, rtx target, enum machine_mode mode)\n \t    return const0_rtx;\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1), s1,\n-\t\t\t\t\t   fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t\t\t ssize_int (r - p1)))),\n-\t\t\t      target, mode, EXPAND_NORMAL);\n+\t  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (s1), s1,\n+\t\t\t      fold_convert (TREE_TYPE (s1),\n+\t\t\t\t\t    ssize_int (r - p1))));\n+\t  return expand_expr (tmp, target, mode, EXPAND_NORMAL);\n \t}\n \n       if (p2[0] == '\\0')\n@@ -2522,6 +2522,7 @@ expand_builtin_strchr (tree arglist, rtx target, enum machine_mode mode)\n \t{\n \t  char c;\n \t  const char *r;\n+\t  tree tmp;\n \n \t  if (target_char_cast (s2, &c))\n \t    return 0;\n@@ -2532,10 +2533,10 @@ expand_builtin_strchr (tree arglist, rtx target, enum machine_mode mode)\n \t    return const0_rtx;\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1), s1,\n-\t\t\t\t\t   fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t\t\t ssize_int (r - p1)))),\n-\t\t\t      target, mode, EXPAND_NORMAL);\n+\t  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (s1), s1,\n+\t\t\t      fold_convert (TREE_TYPE (s1),\n+\t\t\t\t\t    ssize_int (r - p1))));\n+\t  return expand_expr (tmp, target, mode, EXPAND_NORMAL);\n \t}\n \n       /* FIXME: Should use here strchrM optab so that ports can optimize\n@@ -2556,7 +2557,7 @@ expand_builtin_strrchr (tree arglist, rtx target, enum machine_mode mode)\n   else\n     {\n       tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree fn;\n+      tree fn, tmp;\n       const char *p1;\n \n       if (TREE_CODE (s2) != INTEGER_CST)\n@@ -2577,10 +2578,10 @@ expand_builtin_strrchr (tree arglist, rtx target, enum machine_mode mode)\n \t    return const0_rtx;\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1), s1,\n-\t\t\t\t\t   fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t\t\t ssize_int (r - p1)))),\n-\t\t\t      target, mode, EXPAND_NORMAL);\n+\t  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (s1), s1,\n+\t\t\t      fold_convert (TREE_TYPE (s1),\n+\t\t\t\t\t    ssize_int (r - p1))));\n+\t  return expand_expr (tmp, target, mode, EXPAND_NORMAL);\n \t}\n \n       if (! integer_zerop (s2))\n@@ -2608,7 +2609,7 @@ expand_builtin_strpbrk (tree arglist, rtx target, enum machine_mode mode)\n   else\n     {\n       tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree fn;\n+      tree fn, tmp;\n       const char *p1, *p2;\n \n       p2 = c_getstr (s2);\n@@ -2624,10 +2625,10 @@ expand_builtin_strpbrk (tree arglist, rtx target, enum machine_mode mode)\n \t    return const0_rtx;\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  return expand_expr (fold (build (PLUS_EXPR, TREE_TYPE (s1), s1,\n-\t\t\t\t\t   fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t\t\t ssize_int (r - p1)))),\n-\t\t\t      target, mode, EXPAND_NORMAL);\n+\t  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (s1), s1,\n+\t\t\t      fold_convert (TREE_TYPE (s1),\n+\t\t\t\t\t    ssize_int (r - p1))));\n+\t  return expand_expr (tmp, target, mode, EXPAND_NORMAL);\n \t}\n \n       if (p2[0] == '\\0')\n@@ -2812,10 +2813,10 @@ expand_builtin_mempcpy (tree arglist, rtx target, enum machine_mode mode,\n \t    }\n \n \t  if (endp == 2)\n-\t    len = fold (build (MINUS_EXPR, TREE_TYPE (len), dest,\n-\t\t\t       integer_one_node));\n+\t    len = fold (build2 (MINUS_EXPR, TREE_TYPE (len), len,\n+\t\t\t\tinteger_one_node));\n \t  len = fold_convert (TREE_TYPE (dest), len);\n-\t  expr = fold (build (PLUS_EXPR, TREE_TYPE (dest), dest, len));\n+\t  expr = fold (build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len));\n \t  return expand_expr (expr, target, mode, EXPAND_NORMAL);\n \t}\n \n@@ -3369,7 +3370,7 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n       fold (build1 (CONVERT_EXPR, integer_type_node,\n \t\t    build1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t    fold_convert (cst_uchar_ptr_node, arg2))));\n-      tree result = fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      tree result = fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n@@ -3497,7 +3498,7 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n \tfold (build1 (CONVERT_EXPR, integer_type_node,\n \t\t      build1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t      fold_convert (cst_uchar_ptr_node, arg2))));\n-      tree result = fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      tree result = fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n@@ -3662,7 +3663,7 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n \tfold (build1 (CONVERT_EXPR, integer_type_node,\n \t\t      build1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t      fold_convert (cst_uchar_ptr_node, arg2))));\n-      tree result = fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      tree result = fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n@@ -3721,7 +3722,7 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n       return 0;\n \n     /* The actual new length parameter is MIN(len,arg3).  */\n-    len = fold (build (MIN_EXPR, TREE_TYPE (len), len, arg3));\n+    len = fold (build2 (MIN_EXPR, TREE_TYPE (len), len, arg3));\n \n     /* If we don't have POINTER_TYPE, call the function.  */\n     if (arg1_align == 0 || arg2_align == 0)\n@@ -3815,7 +3816,7 @@ expand_builtin_strcat (tree arglist, rtx target, enum machine_mode mode)\n \t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t\t dst)));\n \t      /* Create (dst + strlen (dst)).  */\n-\t      newdst = fold (build (PLUS_EXPR, TREE_TYPE (dst), dst, newdst));\n+\t      newdst = fold (build2 (PLUS_EXPR, TREE_TYPE (dst), dst, newdst));\n \n \t      /* Prepend the new dst argument.  */\n \t      arglist = tree_cons (NULL_TREE, newdst, arglist);\n@@ -4144,8 +4145,8 @@ std_expand_builtin_va_start (tree valist, rtx nextarg)\n {\n   tree t;\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t     make_tree (ptr_type_node, nextarg));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t      make_tree (ptr_type_node, nextarg));\n   TREE_SIDE_EFFECTS (t) = 1;\n \n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -4200,15 +4201,15 @@ std_expand_builtin_va_arg (tree valist, tree type)\n     {\n       if (!PAD_VARARGS_DOWN)\n \t{\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t\t     build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t\t    build_int_2 (boundary / BITS_PER_UNIT - 1, 0)));\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t      build2 (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t\t      build_int_2 (boundary / BITS_PER_UNIT - 1, 0)));\n \t  TREE_SIDE_EFFECTS (t) = 1;\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t}\n-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t\t build (BIT_AND_EXPR, TREE_TYPE (valist), valist,\n-\t\t\tbuild_int_2 (~(boundary / BITS_PER_UNIT - 1), -1)));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t  build2 (BIT_AND_EXPR, TREE_TYPE (valist), valist,\n+\t\t\t  build_int_2 (~(boundary / BITS_PER_UNIT - 1), -1)));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -4217,27 +4218,29 @@ std_expand_builtin_va_arg (tree valist, tree type)\n       || TREE_OVERFLOW (type_size))\n     rounded_size = size_zero_node;\n   else\n-    rounded_size = fold (build (MULT_EXPR, sizetype,\n-\t\t\t\tfold (build (TRUNC_DIV_EXPR, sizetype,\n-\t\t\t\t\t     fold (build (PLUS_EXPR, sizetype,\n-\t\t\t\t\t\t\t  type_size, alignm1)),\n-\t\t\t\t\t     align)),\n-\t\t\t\talign));\n+    {\n+      rounded_size = fold (build2 (PLUS_EXPR, sizetype, type_size, alignm1));\n+      rounded_size = fold (build2 (TRUNC_DIV_EXPR, sizetype,\n+\t\t\t\t   rounded_size, align));\n+      rounded_size = fold (build2 (MULT_EXPR, sizetype,\n+\t\t\t\t   rounded_size, align));\n+    }\n \n   /* Get AP.  */\n   addr_tree = valist;\n   if (PAD_VARARGS_DOWN && ! integer_zerop (rounded_size))\n     {\n       /* Small args are padded downward.  */\n-      addr_tree = fold (build (PLUS_EXPR, TREE_TYPE (addr_tree), addr_tree,\n-\t\t\t       fold (build (COND_EXPR, sizetype,\n-\t\t\t\t\t    fold (build (GT_EXPR, sizetype,\n-\t\t\t\t\t\t\t rounded_size,\n-\t\t\t\t\t\t\t align)),\n-\t\t\t\t\t    size_zero_node,\n-\t\t\t\t\t    fold (build (MINUS_EXPR, sizetype,\n-\t\t\t\t\t\t\t rounded_size,\n-\t\t\t\t\t\t\t type_size))))));\n+      addr_tree = fold (build2 (PLUS_EXPR, TREE_TYPE (addr_tree), addr_tree,\n+\t\t\t\tfold (build3 (COND_EXPR, sizetype,\n+\t\t\t\t\t      fold (build2 (GT_EXPR, sizetype,\n+\t\t\t\t\t\t\t    rounded_size,\n+\t\t\t\t\t\t\t    align)),\n+\t\t\t\t\t      size_zero_node,\n+\t\t\t\t\t      fold (build2 (MINUS_EXPR,\n+\t\t\t\t\t\t\t    sizetype,\n+\t\t\t\t\t\t\t    rounded_size,\n+\t\t\t\t\t\t\t    type_size))))));\n     }\n \n   addr = expand_expr (addr_tree, NULL_RTX, Pmode, EXPAND_NORMAL);\n@@ -4246,9 +4249,9 @@ std_expand_builtin_va_arg (tree valist, tree type)\n   /* Compute new value for AP.  */\n   if (! integer_zerop (rounded_size))\n     {\n-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t\t build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t\trounded_size));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t  build2 (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t\t  rounded_size));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -4387,7 +4390,7 @@ expand_builtin_va_copy (tree arglist)\n \n   if (TREE_CODE (va_list_type_node) != ARRAY_TYPE)\n     {\n-      t = build (MODIFY_EXPR, va_list_type_node, dst, src);\n+      t = build2 (MODIFY_EXPR, va_list_type_node, dst, src);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -5261,8 +5264,8 @@ expand_builtin_signbit (tree exp, rtx target)\n     if (fmt->has_signed_zero && HONOR_SIGNED_ZEROS (fmode))\n       return 0;\n \n-    arg = fold (build (LT_EXPR, TREE_TYPE (exp), arg,\n-\t\tbuild_real (TREE_TYPE (arg), dconst0)));\n+    arg = fold (build2 (LT_EXPR, TREE_TYPE (exp), arg,\n+\t\t\tbuild_real (TREE_TYPE (arg), dconst0)));\n     return expand_expr (arg, target, VOIDmode, EXPAND_NORMAL);\n   }\n \n@@ -6458,11 +6461,11 @@ fold_builtin_cabs (tree arglist, tree type)\n \t  rpart = builtin_save_expr (rpart);\n \t  ipart = builtin_save_expr (ipart);\n \n-\t  result = fold (build (PLUS_EXPR, type,\n-\t\t\t\tfold (build (MULT_EXPR, type,\n-\t\t\t\t\t     rpart, rpart)),\n-\t\t\t\tfold (build (MULT_EXPR, type,\n-\t\t\t\t\t     ipart, ipart))));\n+\t  result = fold (build2 (PLUS_EXPR, type,\n+\t\t\t\t fold (build2 (MULT_EXPR, type,\n+\t\t\t\t\t       rpart, rpart)),\n+\t\t\t\t fold (build2 (MULT_EXPR, type,\n+\t\t\t\t\t       ipart, ipart))));\n \n \t  arglist = build_tree_list (NULL_TREE, result);\n \t  return build_function_call_expr (sqrtfn, arglist);\n@@ -6864,7 +6867,7 @@ fold_builtin_logarithm (tree exp, const REAL_VALUE_TYPE *value)\n \t      tree logfn;\n \t      arglist = build_tree_list (NULL_TREE, x);\n \t      logfn = build_function_call_expr (fndecl, arglist);\n-\t      return fold (build (MULT_EXPR, type, exponent, logfn));\n+\t      return fold (build2 (MULT_EXPR, type, exponent, logfn));\n \t    }\n \t}\n     }\n@@ -6999,7 +7002,7 @@ fold_builtin_mempcpy (tree exp)\n   if (operand_equal_p (src, dest, 0))\n     {\n       tree temp = fold_convert (TREE_TYPE (dest), len);\n-      temp = fold (build (PLUS_EXPR, TREE_TYPE (dest), dest, temp));\n+      temp = fold (build2 (PLUS_EXPR, TREE_TYPE (dest), dest, temp));\n       return fold_convert (TREE_TYPE (exp), temp);\n     }\n \n@@ -7231,8 +7234,8 @@ fold_builtin_signbit (tree exp)\n \n   /* If ARG's format doesn't have signed zeros, return \"arg < 0.0\".  */\n   if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg))))\n-    return fold (build (LT_EXPR, TREE_TYPE (exp), arg,\n-\t\t\tbuild_real (TREE_TYPE (arg), dconst0)));\n+    return fold (build2 (LT_EXPR, TREE_TYPE (exp), arg,\n+\t\t\t build_real (TREE_TYPE (arg), dconst0)));\n \n   return NULL_TREE;\n }\n@@ -7249,11 +7252,11 @@ fold_builtin_isascii (tree arglist)\n       /* Transform isascii(c) -> ((c & ~0x7f) == 0).  */\n       tree arg = TREE_VALUE (arglist);\n       \n-      arg = fold (build (EQ_EXPR, integer_type_node,\n-\t\t\t build (BIT_AND_EXPR, integer_type_node, arg,\n-\t\t\t\tbuild_int_2 (~ (unsigned HOST_WIDE_INT) 0x7f,\n-\t\t\t\t\t     ~ (HOST_WIDE_INT) 0)),\n-\t\t\t integer_zero_node));\n+      arg = fold (build2 (EQ_EXPR, integer_type_node,\n+\t\t\t  build2 (BIT_AND_EXPR, integer_type_node, arg,\n+\t\t\t\t  build_int_2 (~ (unsigned HOST_WIDE_INT) 0x7f,\n+\t\t\t\t\t       ~ (HOST_WIDE_INT) 0)),\n+\t\t\t  integer_zero_node));\n       \n       if (in_gimple_form && !TREE_CONSTANT (arg))\n         return NULL_TREE;\n@@ -7274,8 +7277,8 @@ fold_builtin_toascii (tree arglist)\n       /* Transform toascii(c) -> (c & 0x7f).  */\n       tree arg = TREE_VALUE (arglist);\n       \n-      return fold (build (BIT_AND_EXPR, integer_type_node, arg,\n-\t\t\t  build_int_2 (0x7f, 0)));\n+      return fold (build2 (BIT_AND_EXPR, integer_type_node, arg,\n+\t\t\t   build_int_2 (0x7f, 0)));\n     }\n }\n \n@@ -7292,11 +7295,11 @@ fold_builtin_isdigit (tree arglist)\n       /* According to the C standard, isdigit is unaffected by locale.  */\n       tree arg = TREE_VALUE (arglist);\n       arg = fold_convert (unsigned_type_node, arg);\n-      arg = build (MINUS_EXPR, unsigned_type_node, arg,\n-\t\t   fold_convert (unsigned_type_node,\n-\t\t\t\t build_int_2 (TARGET_DIGIT0, 0)));\n-      arg = build (LE_EXPR, integer_type_node, arg,\n-\t\t   fold_convert (unsigned_type_node, build_int_2 (9, 0)));\n+      arg = build2 (MINUS_EXPR, unsigned_type_node, arg,\n+\t\t    fold_convert (unsigned_type_node,\n+\t\t\t\t  build_int_2 (TARGET_DIGIT0, 0)));\n+      arg = build2 (LE_EXPR, integer_type_node, arg,\n+\t\t    fold_convert (unsigned_type_node, build_int_2 (9, 0)));\n       arg = fold (arg);\n       if (in_gimple_form && !TREE_CONSTANT (arg))\n         return NULL_TREE;\n@@ -7380,9 +7383,9 @@ fold_builtin_1 (tree exp)\n \t  if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n \t    {\n \t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-\t      arg = fold (build (MULT_EXPR, type,\n-\t\t\t\t TREE_VALUE (TREE_OPERAND (arg, 1)),\n-\t\t\t\t build_real (type, dconsthalf)));\n+\t      arg = fold (build2 (MULT_EXPR, type,\n+\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg, 1)),\n+\t\t\t\t  build_real (type, dconsthalf)));\n \t      arglist = build_tree_list (NULL_TREE, arg);\n \t      return build_function_call_expr (expfn, arglist);\n \t    }\n@@ -7419,8 +7422,8 @@ fold_builtin_1 (tree exp)\n \t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n \t      tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n \t      tree arg1 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg, 1)));\n-\t      tree narg1 = fold (build (MULT_EXPR, type, arg1,\n-\t\t\t\t\tbuild_real (type, dconsthalf)));\n+\t      tree narg1 = fold (build2 (MULT_EXPR, type, arg1,\n+\t\t\t\t\t build_real (type, dconsthalf)));\n \t      arglist = tree_cons (NULL_TREE, arg0,\n \t\t\t\t   build_tree_list (NULL_TREE, narg1));\n \t      return build_function_call_expr (powfn, arglist);\n@@ -7446,9 +7449,9 @@ fold_builtin_1 (tree exp)\n \t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n \t      const REAL_VALUE_TYPE third_trunc =\n \t\treal_value_truncate (TYPE_MODE (type), dconstthird);\n-\t      arg = fold (build (MULT_EXPR, type,\n-\t\t\t\t TREE_VALUE (TREE_OPERAND (arg, 1)),\n-\t\t\t\t build_real (type, third_trunc)));\n+\t      arg = fold (build2 (MULT_EXPR, type,\n+\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg, 1)),\n+\t\t\t\t  build_real (type, third_trunc)));\n \t      arglist = build_tree_list (NULL_TREE, arg);\n \t      return build_function_call_expr (expfn, arglist);\n \t    }\n@@ -7618,9 +7621,8 @@ fold_builtin_1 (tree exp)\n \n \t      /* Optimize pow(x,-1.0) = 1.0/x.  */\n \t      if (REAL_VALUES_EQUAL (c, dconstm1))\n-\t\treturn fold (build (RDIV_EXPR, type,\n-\t\t\t\t    build_real (type, dconst1),\n-\t\t\t\t    arg0));\n+\t\treturn fold (build2 (RDIV_EXPR, type,\n+\t\t\t\t     build_real (type, dconst1), arg0));\n \n \t      /* Optimize pow(x,0.5) = sqrt(x).  */\n \t      if (flag_unsafe_math_optimizations\n@@ -7664,7 +7666,7 @@ fold_builtin_1 (tree exp)\n \t    {\n \t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n \t      tree arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      arg = fold (build (MULT_EXPR, type, arg, arg1));\n+\t      arg = fold (build2 (MULT_EXPR, type, arg, arg1));\n \t      arglist = build_tree_list (NULL_TREE, arg);\n \t      return build_function_call_expr (expfn, arglist);\n \t    }\n@@ -7673,8 +7675,8 @@ fold_builtin_1 (tree exp)\n \t  if (flag_unsafe_math_optimizations && BUILTIN_SQRT_P (fcode))\n \t    {\n \t      tree narg0 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      tree narg1 = fold (build (MULT_EXPR, type, arg1,\n-\t\t\t\t\tbuild_real (type, dconsthalf)));\n+\t      tree narg1 = fold (build2 (MULT_EXPR, type, arg1,\n+\t\t\t\t\t build_real (type, dconsthalf)));\n \n \t      arglist = tree_cons (NULL_TREE, narg0,\n \t\t\t\t   build_tree_list (NULL_TREE, narg1));\n@@ -7689,7 +7691,7 @@ fold_builtin_1 (tree exp)\n \t    {\n \t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n \t      tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n-\t      tree narg1 = fold (build (MULT_EXPR, type, arg01, arg1));\n+\t      tree narg1 = fold (build2 (MULT_EXPR, type, arg01, arg1));\n \t      arglist = tree_cons (NULL_TREE, arg00,\n \t\t\t\t   build_tree_list (NULL_TREE, narg1));\n \t      return build_function_call_expr (fndecl, arglist);\n@@ -7849,8 +7851,8 @@ build_function_call_expr (tree fn, tree arglist)\n   tree call_expr;\n \n   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t     call_expr, arglist, NULL_TREE);\n+  call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t      call_expr, arglist, NULL_TREE);\n   return fold (call_expr);\n }\n \n@@ -8133,9 +8135,9 @@ simplify_builtin_strchr (tree arglist)\n \t    return fold_convert (TREE_TYPE (s1), integer_zero_node);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  return fold (build (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t      s1, fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t\tssize_int (r - p1))));\n+\t  return fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t       s1, fold_convert (TREE_TYPE (s1),\n+\t\t\t\t\t\t ssize_int (r - p1))));\n \t}\n \n       /* FIXME: Should use here strchrM optab so that ports can optimize\n@@ -8190,9 +8192,9 @@ simplify_builtin_strrchr (tree arglist)\n \t    return fold_convert (TREE_TYPE (s1), integer_zero_node);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  return fold (build (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t      s1, fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t\tssize_int (r - p1))));\n+\t  return fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t       s1, fold_convert (TREE_TYPE (s1),\n+\t\t\t\t\t\t ssize_int (r - p1))));\n \t}\n \n       if (! integer_zerop (s2))\n@@ -8248,19 +8250,15 @@ simplify_builtin_strpbrk (tree arglist)\n \t    return fold_convert (TREE_TYPE (s1), integer_zero_node);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  return fold (build (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t      s1, fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t\tssize_int (r - p1))));\n+\t  return fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t       s1, fold_convert (TREE_TYPE (s1),\n+\t\t\t\t\t\t ssize_int (r - p1))));\n \t}\n \n       if (p2[0] == '\\0')\n-\t{\n-\t  /* strpbrk(x, \"\") == NULL.\n-\t     Evaluate and ignore the arguments in case they had\n-\t     side-effects.  */\n-\t  return build (COMPOUND_EXPR, integer_type_node, s1,\n-\t\t\tinteger_zero_node);\n-\t}\n+\t/* strpbrk(x, \"\") == NULL.\n+\t   Evaluate and ignore s1 in case it had side-effects.  */\n+\treturn omit_one_operand (TREE_TYPE (s1), integer_zero_node, s1);\n \n       if (p2[1] != '\\0')\n \treturn 0;  /* Really call strpbrk.  */\n@@ -8358,13 +8356,11 @@ simplify_builtin_strncpy (tree arglist, tree slen)\n \n       /* If the len parameter is zero, return the dst parameter.  */\n       if (integer_zerop (len))\n-\t{\n-\t  /* Evaluate and ignore the src argument in case it has\n-\t     side-effects and return the dst parameter.  */\n-\t  return build (COMPOUND_EXPR, TREE_TYPE (TREE_VALUE (arglist)),\n-\t\t\tTREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t\tTREE_VALUE (arglist));\n-\t}\n+\t/* Evaluate and ignore the src argument in case it has\n+\t   side-effects and return the dst parameter.  */\n+\treturn omit_one_operand (TREE_TYPE (TREE_VALUE (arglist)),\n+\t\t\t\t TREE_VALUE (arglist),\n+\t\t\t\t TREE_VALUE (TREE_CHAIN (arglist)));\n \n       if (!slen)\n         slen = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)), 0);\n@@ -8425,9 +8421,9 @@ simplify_builtin_memcmp (tree arglist)\n     {\n       /* Evaluate and ignore arg1 and arg2 in case they have\n          side-effects.  */\n-      return build (COMPOUND_EXPR, integer_type_node, arg1,\n-\t\t    build (COMPOUND_EXPR, integer_type_node,\n-\t\t\t   arg2, integer_zero_node));\n+      return build2 (COMPOUND_EXPR, integer_type_node, arg1,\n+\t\t     build2 (COMPOUND_EXPR, integer_type_node,\n+\t\t\t     arg2, integer_zero_node));\n     }\n \n   p1 = c_getstr (arg1);\n@@ -8460,7 +8456,7 @@ simplify_builtin_memcmp (tree arglist)\n       fold (build1 (CONVERT_EXPR, integer_type_node,\n \t\t    build1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t    build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n-      return fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n     }\n \n   return 0;\n@@ -8524,7 +8520,7 @@ simplify_builtin_strcmp (tree arglist)\n \tfold (build1 (CONVERT_EXPR, integer_type_node,\n \t\t      build1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n-      return fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n     }\n \n   return 0;\n@@ -8566,17 +8562,15 @@ simplify_builtin_strncmp (tree arglist)\n     {\n       /* Evaluate and ignore arg1 and arg2 in case they have\n \t side-effects.  */\n-      return build (COMPOUND_EXPR, integer_type_node, arg1,\n-\t\t    build (COMPOUND_EXPR, integer_type_node,\n-\t\t\t   arg2, integer_zero_node));\n+      return build2 (COMPOUND_EXPR, integer_type_node, arg1,\n+\t\t     build2 (COMPOUND_EXPR, integer_type_node,\n+\t\t\t     arg2, integer_zero_node));\n     }\n \n   /* If arg1 and arg2 are equal (and not volatile), return zero.  */\n   if (operand_equal_p (arg1, arg2, 0))\n-    {\n-      /* Evaluate and ignore arg3 in case it has side-effects.  */\n-      return build (COMPOUND_EXPR, integer_type_node, arg3, integer_zero_node);\n-    }\n+    /* Evaluate and ignore arg3 in case it has side-effects.  */\n+    return omit_one_operand (integer_type_node, integer_zero_node, arg3);\n \n   p1 = c_getstr (arg1);\n   p2 = c_getstr (arg2);\n@@ -8607,7 +8601,7 @@ simplify_builtin_strncmp (tree arglist)\n \tfold (build1 (CONVERT_EXPR, integer_type_node,\n \t\t      build1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n-      return fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n     }\n \n   return 0;\n@@ -8682,8 +8676,8 @@ simplify_builtin_strncat (tree arglist)\n       /* If the requested length is zero, or the src parameter string\n           length is zero, return the dst parameter.  */\n       if (integer_zerop (len) || (p && *p == '\\0'))\n-\treturn build (COMPOUND_EXPR, TREE_TYPE (dst), src,\n-\t\t      build (COMPOUND_EXPR, integer_type_node, len, dst));\n+\treturn build2 (COMPOUND_EXPR, TREE_TYPE (dst), src,\n+\t\t       build2 (COMPOUND_EXPR, integer_type_node, len, dst));\n \n       /* If the requested len is greater than or equal to the string\n          length, call strcat.  */\n@@ -8744,9 +8738,9 @@ simplify_builtin_strspn (tree arglist)\n \t{\n \t  /* Evaluate and ignore both arguments in case either one has\n \t     side-effects.  */\n-\t  return build (COMPOUND_EXPR, integer_type_node, s1,\n-\t\t\tbuild (COMPOUND_EXPR, integer_type_node,\n-\t\t\t       s2, integer_zero_node));\n+\t  return build2 (COMPOUND_EXPR, integer_type_node, s1,\n+\t\t\t build2 (COMPOUND_EXPR, integer_type_node,\n+\t\t\t\t s2, integer_zero_node));\n \t}\n       return 0;\n     }\n@@ -8791,8 +8785,8 @@ simplify_builtin_strcspn (tree arglist)\n \t{\n \t  /* Evaluate and ignore argument s2 in case it has\n \t     side-effects.  */\n-\t  return build (COMPOUND_EXPR, integer_type_node,\n-\t\t\ts2, integer_zero_node);\n+\t  return omit_one_operand (integer_type_node,\n+\t\t\t\t   integer_zero_node, s2);\n \t}\n \n       /* If the second argument is \"\", return __builtin_strlen(s1).  */\n@@ -8862,10 +8856,9 @@ simplify_builtin_fputs (tree arglist, int ignore, int unlocked, tree known_len)\n   switch (compare_tree_int (len, 1))\n     {\n     case -1: /* length is 0, delete the call entirely .  */\n-      {\n-\treturn build (COMPOUND_EXPR, integer_type_node,\n-\t\t      TREE_VALUE (TREE_CHAIN (arglist)), integer_zero_node);\n-      }\n+      return omit_one_operand (integer_type_node, integer_zero_node,\n+\t\t\t       TREE_VALUE (TREE_CHAIN (arglist)));\n+\n     case 0: /* length is 1, call fputc.  */\n       {\n \tconst char *p = c_getstr (TREE_VALUE (arglist));\n@@ -9028,7 +9021,7 @@ simplify_builtin_sprintf (tree arglist, int ignored)\n       retval = convert\n \t(TREE_TYPE (TREE_TYPE (implicit_built_in_decls[BUILT_IN_SPRINTF])),\n \t retval);\n-      return build (COMPOUND_EXPR, TREE_TYPE (retval), call, retval);\n+      return build2 (COMPOUND_EXPR, TREE_TYPE (retval), call, retval);\n     }\n   else\n     return call;"}]}