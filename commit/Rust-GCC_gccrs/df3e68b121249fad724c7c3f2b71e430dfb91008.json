{"sha": "df3e68b121249fad724c7c3f2b71e430dfb91008", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYzZTY4YjEyMTI0OWZhZDcyNGM3YzNmMmI3MWU0MzBkZmI5MTAwOA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2011-08-03T14:36:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T14:36:26Z"}, "message": "a-except.adb, [...] (Raise_From_Controlled_Operation): Rewritten to create the message strings when...\n\n2011-08-03  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-except.adb, a-except-2005.adb (Raise_From_Controlled_Operation):\n\tRewritten to create the message strings when the exception is not\n\traised by an abort during finalization.\n\t* a-except.ads, a-except-2005.ads: Add pragma Export for procedure\n\tRaise_From_Controlled_Operation and update its associated comment.\n\t* a-fihema.ads, a-fihema.adb: New GNAT unit.\n\tAda.Finalization.Heap_Management provides key functionality\n\tassociated with controlled objects on the heap, their creation,\n\tfinalization and reclamation. Type Finalization_Collection is\n\teffectively a wrapper which sits ontop of a storage pool and performs\n\tall necessary bookkeeping for all the objects it contains. Each\n\taccess-to-controlled or access-to-class-wide type receives a collection\n\tas part of its expansion. The compiler generates buffer code and\n\tinvokes Allocate / Deallocate to create and destroy allocated\n\tcontrolled objects.\n\t* a-finali.adb (\"=\"): Removed.\n\t* a-finali.ads (\"=\"): Removed. Controlled types no longer carry hidden\n\tfields Prev and Next.\n\t* ali.adb (Scan_ALI): Add parsing code to process PF / Has_Finalizer.\n\tA library unit with at least one controlled object on the library level\n\thas a special finalizer which is invoked by the binder. To signal this,\n\tali files carry field PF.\n\t* ali.ads: New field in type Unit_Record called Has_Finalizer. Add\n\tassociated comment on field usage.\n\t* a-tags.adb (Get_RC_Offset): Removed.\n\t(Needs_Finalization): New routine.\n\t* a-tags.ads: Update the structure of the GNAT dispatch tables.\n\tDispatch tables now carry field Needs_Finalization which provides\n\truntime indication whether a type is controlled or has controlled\n\tcomponents or both. Remove field RC_Offset.\n\t(Get_RC_Offset): Removed along with its associated pragma Export.\n\tSince tagged types with controlled components no longer carry hidden\n\tfield _controller, the special mechanism to retrieve its location is no\n\tlonger needed.\n\t(Needs_Finalization): New routine.\n\t* atree.ads, atree.adb (Elist24): New routine.\n\t(Set_Elist24): New routine.\n\t* atree.h: Add a define clause for Elist24.\n\t* bindgen.adb New library-level variable Lib_Final_Built.\n\t(Gen_Adafinal_Ada): Reimplemented. Depending on the restrictions or the\n\tpresence of a VM target, the routine generates calls to the proper\n\tlibrary finalization routine.\n\t(Gen_Adainit_Ada): Import Finalize_Library_Objects only on non-VM\n\ttargets. Set the correct library finalization routine depending on\n\twhether the library has controlled objects or this is a VM compilation.\n\t(Gen_Finalize_Library_Ada): New routine. This procedure generates calls\n\tto library-level finalizers of compiled units in reverse order of\n\telaboration. It also produces exception management code and reraises a\n\tpotential exception after all units have been finalized.\n\t(Gen_Finalize_Library_C): New routine. This procedure generates calls to\n\tlibrary-level finalizers of compiled units in reverse order of\n\telaboration.\n\t(Gen_Finalize_Library_Defs_C): New routine. This procedure generates the\n\tdefinitions of all library-level finalizers available to the compilation\n\t(Gen_Main_Ada): Directly call Adafinal which now contails all target\n\tdependent code.\n\t(Gen_Main_C): Add new local constant Needs_Library_Finalization. Call\n\tSystem.Standard_Library.Adafinal directly. If the library needs\n\tfinalization actions, create the sequence of finalization calls.\n\t(Gen_Output_File_Ada): Alphabetize local variables and constants.\n\tGenerate a with clause for System.Soft_Links when compiling for a VM.\n\tRemove the code which imports System.Standard_Library.Adafinal as\n\tDo_Finalize. Generate the library finalization routine.\n\t(Gen_Output_File_C): Add new local constant Needs_Library_Finalization.\n\tIf the library needs finalization actions, create all the definitions\n\tof library- level finalizers.\n\t(Has_Finalizer): New routine. Determines whether at least one compiled\n\tunit has a library-level finalizer.\n\tAdd type Qualification_Mode.\n\t(Set_Unit_Name): Add a formal which controls the replacement of a dot.\n\t* einfo.adb: New usage of field 15 as Return_Flag.\n\tRemove Finalization_Chain_Entity from the usages of field 19.\n\tRemove Associated_Final_Chain from the usages of field 23.\n\tNew usage of field 23 as Associated_Collection.\n\tNew usage of field 24 as Finalizer.\n\tNew usage of flag 252 as Is_Processed_Transient.\n\t(Associated_Final_Chain): Removed.\n\t(Associated_Collection): New routine.\n\t(Finalization_Chain_Entity): Removed.\n\t(Finalizer): New routine.\n\t(Is_Finalizer): New routine.\n\t(Is_Processed_Transient): New routine.\n\t(Return_Flag): New routine.\n\t(Set_Associated_Final_Chain): Removed.\n\t(Set_Associated_Collection): New routine.\n\t(Set_Finalization_Chain_Entity): Removed.\n\t(Set_Finalizer): New routine.\n\t(Set_Is_Processed_Transient): New routine.\n\t(Set_Return_Flag): New routine.\n\t(Write_Entity_Flags): Include Is_Processed_Transient to the list of\n\tdisplayed flags.\n\t(Write_Field8_Name): Alphabetize the output.\n\t(Write_Field11_Name): Alphabetize the output.\n\t(Write_Field12_Name): Alphabetize the output.\n\t(Write_Field13_Name): Alphabetize the output.\n\t(Write_Field14_Name): Alphabetize the output.\n\t(Write_Field15_Name): Alphabetize the output.\n\t(Write_Field16_Name): Alphabetize the output.\n\t(Write_Field17_Name): Alphabetize the output.\n\t(Write_Field18_Name): Alphabetize the output.\n\t(Write_Field19_Name): Alphabetize the output. Remove the output of\n\tFinalization_Chain_Entity.\n\t(Write_Field20_Name): Alphabetize the output.\n\t(Write_Field21_Name): Alphabetize the output.\n\t(Write_Field22_Name): Alphabetize the output.\n\t(Write_Field23_Name): Alphabetize the output. Remove the output of\n\tAssociated_Final_Chain. Add output for Associated_Collection.\n\t(Write_Field24_Name): Alphabetize the output.\n\t(Write_Field25_Name): Add output for Finalizer.\n\t(Write_Field26_Name): Alphabetize the output.\n\t(Write_Field27_Name): Alphabetize the output.\n\t(Write_Field28_Name): Alphabetize the output.\n\t* einfo.ads: Add new field description for Associated_Collection and\n\tits uses in nodes.\n\tRemove Associated_Final_Chain and its uses in nodes.\n\tRemove Finalization_Chain_Entity and its uses in nodes.\n\tAdd new field description for Finalizer and its uses in nodes.\n\tAdd new synthesized attribute Is_Finalizer.\n\tAdd new flag description for Is_Processed_Transient and its uses in\n\tnodes.\n\tAdd new field description for Return_Flag and its uses in nodes.\n\t(Associated_Final_Chain): Removed along with its pragma Inline.\n\t(Associated_Collection): New routine and pragma Inline.\n\t(Finalization_Chain_Entity): Removed along with its pragma Inline.\n\t(Finalizer): New routine and pragma Inline.\n\t(Is_Finalizer): New routine and pragma Inline.\n\t(Is_Processed_Transient): New routine and pragma Inline.\n\t(Return_Flag): New routine and pragma Inline.\n\t(Set_Associated_Final_Chain): Removed along with its pragma Inline.\n\t(Set_Associated_Collection): New routine and pragma Inline.\n\t(Set_Finalization_Chain_Entity): Removed along with its pragma Inline.\n\t(Set_Finalizer): New routine and pragma Inline.\n\t(Set_Is_Processed_Transient): New routine and pragma Inline.\n\t(Set_Return_Flag): New routine and pragma Inline.\n\t* exp_aggr.adb: Alphabetize subprograms.\n\t(Build_Array_Aggr_Code): Remove formal Flist and its associated comment.\n\t(Build_Record_Aggr_Code): Remove formals Flist and Obj along with their\n\tassociated comments. Remove local variables External_Final_List and\n\tAttach.\n\tRename Ctrl_Stuff_Done to Finalization_Done. Rename local variable A to\n\tAncestor. Remove the retrieval of finalization lists. Update the call to\n\tMake_Adjust_Call.\n\t(Convert_Aggr_In_Allocator): Remove the retrieval of finalization\n\tlists. Update the call to Late_Expansion.\n\t(Convert_Aggr_In_Assignment): Update the call to Late_Expansion.\n\t(Convert_Aggr_In_Object_Decl): Update the call to Late_Expansion.\n\t(Gen_Assign): Remove the retrieval of the finalization list used to\n\tbuild the assignment. Update the calls to Make_Init_Call and\n\tMake_Adjust_Call.\n\t(Gen_Ctrl_Actions_For_Aggr): Renamed to Generate_Finalization_Actions.\n\tRemove the mechanism to determine attachment levels and finalization\n\tlist retrieval. Remove the processing for coextensions.\n\t(Init_Controller): Removed. Controllers no longer exist.\n\t(Late_Expansion): Remove formals Flist and Obj along with their\n\tassociated comments. Update the calls to Build_Record_Aggr_Code and\n\tBuild_Array_Aggr_Code.\n\t* exp_ch13.adb (Expand_N_Free_Statement): New routine.\n\t(Expand_N_Freeze_Entity): Add special processing for finalizers which\n\tappear in entry bodies, protected subprograms and task bodies.\n\t* exp_ch13.ads (Expand_N_Free_Statement): New routine.\n\t* exp_ch3.adb (Add_Final_Chain): Removed.\n\t(Build_Array_Init_Proc): Alphabetize local variables.\n\t(Build_Assignment): Alphabetize local variables. Update the call to\n\tMaked_Adjust_Call.\n\t(Build_Class_Wide_Master): Rename local variables to better reflect\n\ttheir role.\n\t(Build_Discriminant_Assignments): Code reformatting.\n\t(Build_Init_Call_Thru): Code reformatting.\n\t(Build_Init_Procedure): Code reformatting. Generate a special version\n\tof Deep_Finalize which is capable of finalizing all initialized\n\tcomponents and ignore the rest.\n\t(Build_Init_Statements): Rename local variables to better reflect their\n\trole.\n\tReimplement the mechanism to include the creation and update of an index\n\tvariable called a \"counter\". It is used as a bookmark for tracing\n\tinitialized and non-initialized components.\n\t(Build_Initialization_Call): Remove local variable Controller_Typ.\n\tAlphabetize all local variables. Remove the initialization of the\n\trecord controller and update the call to Make_Init_Call.\n\t(Build_Record_Init_Proc): Rename formal Pe to Rec_Ent.\n\tNew local variable Counter.\n\t(Constrain_Array): Alphabetize.\n\t(Expand_Freeze_Array_Type): Create a collection instead of a\n\tfinalization list.\n\t(Expand_Freeze_Class_Wide_Type): New routine. Creates TSS primitive\n\tFinalize_Address which is used in conjunction with allocated controlled\n\tobjects.\n\t(Expand_N_Object_Declaration): Remove the creation of a finalization\n\tlist for anonymous access types. Update the calls to Make_Init_Call and\n\tMake_Adjust_Call.\n\t(Expand_Freeze_Record_Type): Remove local variable Flist. Remove the\n\tretrieval of finalization lists. Remove the expansion of the record\n\tcontroller. Create TSS primitive Finalize_Address used in conjunction\n\twith controlled objects on the heap. Create finalization collections\n\tfor access-to-controlled record components.\n\t(Expand_Record_Controller): Removed.\n\t(Freeze_Type): Remove the freezing of record controllers. Freezing of\n\tclass-wide types now requires additional processing. Create\n\tfinalization collections for access-to-controlled types.\n\t(Increment_Counter): New routine.\n\t(Make_Counter): New routine.\n\t(Make_Eq_If): Remove the mention of Name_uController.\n\t(Make_Predefined_Primitive_Specs): There is no longer need to skip\n\ttypes coming from System.Finalization_Root.\n\t(Predef_Deep_Spec): Reimplemented to reflect the new parameter profiles.\n\t(Predefined_Primitive_Bodies): There is no longer need to skip types\n\tcoming from System.Finalization_Root.\n\t(Stream_Operation_OK): Do not generate stream routines for\n\ttype Ada.Finalization.Heap_Management.Finalization_Collection.\n\t* exp_ch3.ads: Alphabetize subprograms.\n\t* exp_ch4.adb: Remove with and use clause for Sem_Ch8.\n\tAdd with and use clause for Lib.\n\t(Complete_Coextension_Finalization): Removed.\n\t(Complete_Controlled_Allocation): New routine. Create a finalization\n\tcollection for anonymous access-to-controlled types. Create a custom\n\tAllocate which interfaces with the back end and the machinery in\n\tHeap_Management.\n\t(Expand_Allocator_Expression): Add necessary calls to\n\tComplete_Controlled_Allocation. Remove the retrieval of finalization\n\tlists. Update the calls to Make_Adjust_Call. Generate a call to\n\tAda.Finalization.Heap_Management.Set_Finalize_Address_Ptr to decorate\n\tthe associated collection.\n\t(Expand_N_Allocator): Remove the processing for dynamic coextensions.\n\tCode clean up. Remove the retrieval of finalization lists and\n\tattachment levels.\n\tUpdate the call to Make_Init_Call. Generate a call to\n\tAda.Finalization.Heap_Management.Set_Finalize_Address_Ptr to decorate\n\tthe associated collection.\n\t(Get_Allocator_Final_List): Removed. Finalization lists are not\n\tavailable.\n\t(Suitable_Element): Remove the mention of Name_uController.\n\t* exp_ch5.adb: Remove with and use clauses for Ttypes and Uintp.\n\t(Make_Tag_Ctrl_Assignment): Rewritten to simply do a finalization of\n\tthe left hand side, carry out the assignment and adjust the left hand\n\tside.\n\t* exp_ch6.adb (Add_Final_List_Actual_To_Build_In_Place_Call): Removed.\n\t(Add_Collection_Actual_To_Build_In_Place_Call): New routine.\n\t(BIP_Formal_Suffix): Rename BIP_Final_List and BIPfinallist to\n\tBIP_Collection and BIPcollection.\n\t(Build_Heap_Allocator): New routine used to allocate the return object\n\tof a build-in-place function onto a collection.\n\t(Expand_Ctrl_Function_Call): Moved from Exp_Ch7.\n\t(Expand_Call): Do not replace direct calls to Deep routines with their\n\taliases.\n\t(Expand_N_Extended_Return_Statement): Give all variables shorter names\n\tand update their occurrences. Add a special return flag to monitor the\n\t[ab]normal execution of the function. The flag is set right before the\n\treturn statement.\n\tRewrite the mechanism used to allocate a build-in-place return object\n\ton the heap or on a storage pool.\n\t(Is_Direct_Deep_Call): New routine.\n\t(Make_Build_In_Place_Call_In_Allocator): Add a collection to a\n\tbuild-in-place function call instead of a final list. Build a call to\n\tSet_Finalize_Address_Ptr to decorate the associated collection.\n\t(Make_Build_In_Place_Call_In_Anonymous_Context): Create a temporary in\n\torder to name the build-in-place function call's result for later\n\tfinalization. Add a collection to a build-in-place function call\n\tinstead of a final list.\n\t(Make_Build_In_Place_Call_In_Assignment): Add a collection to a\n\tbuild-in-place function call instead of a final list. Remove the code\n\twhich moves one final list and transforms it into the actual in a\n\tnested build-in-place call.\n\t(Make_Build_In_Place_Call_In_Object_Declaration): Add a collection to a\n\tbuild-in-place function call instead of a final list.\n\t(Move_Final_List): Removed.\n\t(Needs_BIP_Collection): New routine.\n\t(Needs_BIP_Final_List): Removed.\n\t* exp_ch6.ads: Replace BIP_Final_List with BIP_Collection in\n\tenumeration type BIP_Formal_Kind.\n\tUpdate the related comment.\n\t(Needs_BIP_Collection): New routine.\n\t(Needs_BIP_Final_List): Removed.\n\t* exp_ch7.adb: Add with and use clauses for Elists, Exp_Ch6, Stringt\n\tand Ttypes. Remove with and use clauses for Sem_Type. Alphabetize the\n\tmajority of subprograms in this unit. Add Name_Finalize_Address to\n\tarray Name_Of and TSS_Finalize_Address to array Deep_Name_Of.\n\t(Build_Adjust_Or_Finalize_Statements): Create the adjust or finalization\n\tstatements for an array type.\n\t(Build_Adjust_Statements): Create the adjust statements for a record\n\ttype.\n\t(Build_Cleanup_Statements): New routine. A procedure which given any\n\tconstruct containing asynchronous calls, references to _master, or is a\n\ttask body, a task allocation or a protected body produces the necessary\n\truntime calls to clean up these constructs.\n\t(Build_Exception_Handler): New routine.\n\t(Build_Final_List): Removed.\n\t(Build_Finalization_Collection): New routine. A core procedure which\n\tcreates a collection to service heap allocated controlled objects\n\tassociated with an access-to-controlled type.\n\t(Build_Finalize_Statements): Create the finalization statements for a\n\trecord types.\n\t(Build_Finalizer): New routine. A core procedure which given any\n\tconstruct with declarations and/or statements detects all objects which\n\tneed any type of clean up (controlled objects, protected objects) and\n\tgenerates all necessary code to clean up the said objects in the proper\n\torder.\n\t(Build_Finalizer_Call): New routine.\n\t(Build_Initialize_Statements): Create the initialization statements for\n\tan array type. The generated routine contains code to finalize partially\n\tinitialized arrays.\n\t(Build_Object_Declarations): New routine.\n\t(Build_Raise_Statement): New routine.\n\t(Clean_Simple_Protected_Objects): Removed.\n\t(Controller_Component): Removed.\n\t(Enclosing_Function): New routine.\n\t(Expand_Cleanup_Actions): Create a finalizer for a construct which has\n\teither declarations or statements or both.\n\t(Expand_N_Package_Body): Create a finalizer for a non-generic package.\n\t(Expand_N_Package_Declaration): Create a finalizer for a non-generic\n\tpackage.\n\t(Find_Final_List): Removed.\n\t(Global_Flist_Ref): Removed.\n\t(In_Finalization_Root): Removed.\n\t(Insert_Actions_In_Scope_Around): Determine the range of the transient\n\tscope in terms of tree nodes. Process all transient variables within\n\tthat range.\n\t(Make_Adjust_Call): Rewritten. There is no longer an attach call\n\tgenerated after the adjust.\n\t(Make_Attach_Call): Removed.\n\t(Make_Call): New routine.\n\t(Make_Clean): Removed.\n\t(Make_Deep_Array_Body): Rewritten to simply invoke the appropriate\n\tbuild routines.\n\t(Make_Deep_Proc): Rewritten to generate the new profile signature used\n\tin Deep routines.\n\t(Make_Deep_Record_Body): Rewritten to simply invoke the appropriate\n\tbuild routines.\n\t(Make_Final_Call): Modified to simply create a call to either\n\tDeep_Finalize or Finalize.\n\t(Make_Finalize_Address_Body): New routine.\n\t(Make_Finalize_Address_Stmts): New routine. A function which produces\n\tTSS primitive Finalize_Address used in conjunction with heap allocated\n\tcontrolled objects.\n\t(Make_Handler_For_Ctrl_Operation): Add specialized code for .NET/JVM.\n\t(Make_Init_Call): Rewritten. There is no longer an attach call\n\tgenerated after initialization.\n\t(Make_Local_Deep_Finalize): New routine.\n\t(Make_Set_Finalize_Address_Ptr_Call): New routine.\n\t(Make_Transient_Block): Remove the finalization list retrieval and\n\tmanipulation.\n\t(Needs_Finalization): Moved to Exp_Util.\n\t(Parent_Field_Type): New routine.\n\t(Preprocess_Components): New routine.\n\t(Process_Transient_Objects): New routine.\n\t(Wrap_HSS_In_Block): New routine.\n\t(Wrap_Transient_Declaration): Remove finalization list management and\n\tcontroller insertion.\n\t(Wrap_Transient_Expression): Code reformatting.\n\t(Wrap_Transient_Statement): Code reformatting.\n\t* exp_ch7.ads (Build_Final_List): Removed.\n\t(Build_Finalization_Collection): New routine.\n\t(Build_Raise_Statement): New routine.\n\t(Controller_Component): Removed.\n\t(Expand_Ctrl_Function_Call): Moved to Exp_Ch6.\n\t(Find_Final_List): Removed.\n\t(In_Finalization_Root): Removed.\n\t(Is_Simple_Protected_Type): Update related comment.\n\t(Make_Adjust_Call): New parameter profile and associated comments.\n\t(Make_Attach_Call): Removed.\n\t(Make_Final_Call): New parameter profile and associated comments.\n\t(Make_Finalize_Address_Body): New routine.\n\t(Make_Init_Call): New parameter profile and associated comments.\n\t(Make_Local_Deep_Finalize): New routine.\n\t(Make_Set_Finalize_Address_Ptr_Call): New routine.\n\t(Needs_Finalization): Moved to Exp_Util.\n\t* exp_ch9.adb (Add_Object_Pointer): Code reformatting.\n\t(Expand_N_Protected_Body): Remove the handling of finalization lists.\n\t(Find_Protection_Type): Moved to Exp_Util.\n\t* exp_disp.adb: Remove with and use clauses for Exp_Ch7.\n\t(Make_DT): Update sequence of dispatch table initialization. Remove the\n\tinitialization of field RC_Offset. Add initialization of field Needs_\n\tFinalization.\n\t* exp_intr.adb (Expand_Unc_Deallocation): Code reformatting.\n\tReimplement how an object is first finalized, then deallocated.\n\t* exp_strm.adb (Build_Record_Or_Elementary_Input_Function):\n\tCode reformatting.\n\t* exp_tss.ads: Add special suffix for TSS primitive Finalize_Address.\n\tRegister TSS_Finalize_Address with type TSS_Names.\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): New routine. This core\n\tprocedure provides the interface between an allocation / deallocation\n\tand the support machinery in Ada.Finalization.Heap_Management.\n\t(Find_Init_Call): Code reformatting.\n\t(Find_Init_Call_In_List): Code reformatting.\n\t(Find_Protection_Type): Moved from Exp_Ch9.\n\t(Find_Prim_Op): Reimplement to add preference of recovered primitive.\n\t(Has_Controlled_Coextensions): Removed.\n\t(Has_Controlled_Objects): New routine.\n\t(In_Library_Level_Package_Body): New routine.\n\t(Insert_Action_After): New routine.\n\t(Is_Finalizable_Transient): New routine. This predicate determines\n\twhether an object declaration is one of the many variants of controlled\n\ttransients.\n\t(Is_Null_Access_BIP_Func_Call): New routine.\n\t(Is_Non_BIP_Func_Call): New routine.\n\t(Is_Related_To_Func_Return): New routine.\n\t(Needs_Finalization): Moved from Exp_Ch7.\n\t* exp_util.ads (Build_Allocate_Deallocate_Proc): New routine.\n\t(Find_Protection_Type): Moved from Exp_Ch9.\n\t(Has_Controlled_Coextensions): Removed.\n\t(Has_Controlled_Objects): New routine.\n\t(In_Library_Level_Package_Body): New routine.\n\t(Insert_Action_After): New routine.\n\t(Is_Finalizable_Transient): New routine.\n\t(Is_Null_Access_BIP_Func_Call): New routine.\n\t(Is_Non_BIP_Func_Call): New routine.\n\t(Is_Related_To_Func_Return): New routine.\n\t(Needs_Finalization): Moved from Exp_ch7.\n\t* expander.adb (Expand): Add a case for N_Free_Statement.\n\t* freeze.adb (Freeze_All): Replace the generation of a finalization\n\tlist with a collection for access-to-controlled types.\n\t(Freeze_Entity): Code reformatting.\n\t(Freeze_Record_Type): Remove the freezing of a record controller\n\tcomponent.\n\t(Freeze_Subprogram): Code reformatting.\n\t* inline.adb (Cleanup_Scopes): Remove the reset of the scope\n\tfinalization list.\n\t* lib-writ.adb (Write_Unit_Information): Output \"PF\" when a package\n\thas a library-level finalizer.\n\t* lib-writ.ads: Add \"PF\" to the sequence of unit attributes.\n\t* a-filico.ads, a-filico.adb, s-finimp.ads, s-finimp.adb: Removed.\n\t* Makefile.rtl: Remove a-filico and s-finimp from the list of object\n\tfiles. Add a-fihema to the list of object files.\n\t* par-ch4.adb:\n\tAlphabetize the associations in type Is_Parameterless_Attribute.\n\t* rtsfind.ads: Ada.Finalization_List.Controller and\n\tSystem.Finalization_Implementation are no longer a GNAT unit.\n\tUpdate the range of type Ada_Finalization_Child. Remove the following\n\trecoverable entities:\n\t\n\t   RE_Attach_To_Final_List\n\t   RE_Deep_Tag_Attach\n\t   RE_Finalize_List\n\t   RE_Finalize_One\n\t   RE_Finalizable_Ptr_Ptr\n\t   RE_Global_Final_List\n\t   RE_Limited_Record_Controller\n\t   RE_List_Controller\n\t   RE_Move_Final_List\n\t   RE_Record_Controller\n\t   RE_Simple_List_Controller\n\t\n\tAdd the following recoverable entities:\n\t\n\t   RE_Add_Offset_To_Address\n\t   RE_Allocate\n\t   RE_Base_Pool\n\t   RE_Deallocate\n\t   RE_Exception_Identity\n\t   RE_Finalization_Collection\n\t   RE_Finalization_Collection_Ptr\n\t   RE_Needs_Finalization\n\t   RE_Save_Library_Occurrence\n\t   RE_Set_Finalize_Address_Ptr\n\t   RE_Set_Storage_Pool_Ptr\n\t   RE_Storage_Count\n\t* sem_aggr.adb (Resolve_Record_Aggregate): Remove mention of\n\tName_uController.\n\t* sem_aux.adb (First_Discriminant): Remove mention of Name_uController.\n\t(First_Stored_Discriminant): Remove the mention of Name_uController.\n\t* sem_aux.ads: Comment reformatting.\n\t* sem_ch10.adb (Build_Chain): Signal the class-wide creation machinery\n\tto redecorate an already existing class-wide type.\n\t(Decorate_Tagged_Type): New parameter profile and associated comment.\n\tCreate a \"shadow class-wide type\" for a shadow entity.\n\t* sem_ch11.adb (Analyze_Exception_Handlers): Remove the dubious setting\n\tof the final chain along with the associated comment.\n\t* sem_ch3.adb (Access_Type_Declaration): Add new local variable\n\tFull_Desig and set it to the full view of the designated type.\n\tInitialize the finalization collection to empty.\n\t(Build_Derived_Record_Type): Alphabetize local variables. Code\n\treformatting.\n\t(Collect_Fixed_Components): Remove the mention of Name_uController.\n\t(Create_Constrained_Components): Remove the mention of Name_uController.\n\t(Make_Class_Wide_Type): Add specialized code to redecorate an existing\n\tclass-wide type of a shadow entity.\n\t(Process_Full_View): Update the machinery which marks type\n\tLimited_Controlled's entity as limited.\n\t* sem_ch4.adb (Analyze_One_Call): Code reformatting.\n\t* sem_ch6.adb (Create_Extra_Formals): Do not generate a finalization\n\tlist, instead make a collection build-in-place formal.\n\t* sem_ch8.adb (Analyze_Object_Renaming): Look at the available view of\n\ta designated type in order to establish a match between the renaming\n\tand the renamed entity.\n\t(Find_Selected_Component): Add guard to prevent spurious exceptions\n\tfrom being raised on .NET/JVM.\n\t* sem_disp.adb (Check_Dispatching_Operation): Include Finalize_Address\n\tto the list of primitive that need special processing. Update arrays\n\tC_Names and D_Names.\n\t(Replace_Types): Handle class-wide types.\n\t* sem_elab.adb (Check_A_Call): Since Deep_Initialize now has a\n\tdifferent parameter profile, look at the first formal.\n\t* sem_prag.adb: Remove with and use clauses for Exp_Ch7. Add with and\n\tuse clauses for Exp_Util.\n\t* sem_res.adb: Remove with and use clauses for Elists.\n\t(Propagate_Coextensions): Removed.\n\t(Resolve_Allocator): Do not propagate the list of coextensions from one\n\tallocator to another.\n\t* sem_util.adb (Build_Actual_Subtype_Of_Component): Rename variable\n\tDeaccessed_T to Desig_Typ.\n\t(Enter_Name): Remove the mention of Name_uController.\n\t(Gather_Components): Remove the mention of Name_uController.\n\t(Incomplete_Or_Private_View): New routine.\n\t(Is_Coextension_Root): Removed.\n\t(Is_Fully_Initialized_Type): Remove the mention of Name_uController.\n\t* sem_util.ads (Incomplete_Or_Private_View): New routine.\n\t(Is_Coextension_Root): Removed.\n\t* s-finroo.ads: Remove with clause for Ada.Unchecked_Conversion.\n\tControlled types are now derived from a null tagged record. Remove\n\ttypes Finalizable_Ptr, Finalizable and Empty_Root_Controlled.\n\t* sinfo.adb (Coextensions): Removed.\n\t(Set_Coextensions): Removed.\n\t* sinfo.ads: Remove Coextensions from the explanation of node fields\n\tand its uses in nodes.\n\tUpdate the field usage of N_Allocator.\n\t(Coextensions): Removed along with its pragma Inline.\n\t(Set_Coextensions): Removed along with its pragma Inline.\n\t* snames.ads-tmpl: Remove names\n\t\n\t  Name_uClean\n\t  Name_uController\n\t  Name_uFinal_List\n\t  Name_uLocal_Final_List\n\t  Name_Finalization_Root\n\t  Name_Next\n\t  Name_Prev\n\t\n\tAdd names\n\t\n\t  Name_uFinalizer\n\t  Name_Finalize_Address\n\t* s-pooglo.adb (Allocate): Add overriding indicator.\n\t(Deallocate): Add overriding indicator.\n\t(Storage_Size): Add overriding indicator.\n\t* s-soflin.adb (Adafinal_NT): Invoke Finalize_Library_Objects rather\n\tthan Finalize_Global_List.\n\t(Null_Finalize_Global_List): Removed.\n\t(Save_Library_Occurrence): New routine.\n\t* s-soflin.ads: Remove variable Finalize_Global_List along with its\n\tinitialization. Add variable Finalize_Library_Objects along with its\n\tpragma Export. Add variables Library_Exception and\n\tLibrary_Exception_Set along with their pragma Export.\n\t(Null_Finalize_Global_List): Removed.\n\t(Save_Library_Occurrence): New routine.\n\t* s-tassta.adb (Finalize_Global_Tasks): Call Finalize_Library_Objects\n\trather than Finalize_Global_List.\n\t* tbuild.adb (Unchecked_Convert_To): Capture and set the parent field\n\tof the constructed node.\n\nFrom-SVN: r177275", "tree": {"sha": "3a155e8b2ced397467e576bd84bd23e0fd58fd91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a155e8b2ced397467e576bd84bd23e0fd58fd91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df3e68b121249fad724c7c3f2b71e430dfb91008", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3e68b121249fad724c7c3f2b71e430dfb91008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3e68b121249fad724c7c3f2b71e430dfb91008", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3e68b121249fad724c7c3f2b71e430dfb91008/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de29d8500c2f9f5f164032ae5c3a5477dcc45c51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de29d8500c2f9f5f164032ae5c3a5477dcc45c51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de29d8500c2f9f5f164032ae5c3a5477dcc45c51"}], "stats": {"total": 20107, "additions": 12515, "deletions": 7592}, "files": [{"sha": "b526c8282c34087da0df23baea2d48b041faf3ba", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 550, "deletions": 0, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -1,3 +1,553 @@\n+2011-08-03  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-except.adb, a-except-2005.adb (Raise_From_Controlled_Operation):\n+\tRewritten to create the message strings when the exception is not\n+\traised by an abort during finalization.\n+\t* a-except.ads, a-except-2005.ads: Add pragma Export for procedure\n+\tRaise_From_Controlled_Operation and update its associated comment.\n+\t* a-fihema.ads, a-fihema.adb: New GNAT unit.\n+\tAda.Finalization.Heap_Management provides key functionality\n+\tassociated with controlled objects on the heap, their creation,\n+\tfinalization and reclamation. Type Finalization_Collection is\n+\teffectively a wrapper which sits ontop of a storage pool and performs\n+\tall necessary bookkeeping for all the objects it contains. Each\n+\taccess-to-controlled or access-to-class-wide type receives a collection\n+\tas part of its expansion. The compiler generates buffer code and\n+\tinvokes Allocate / Deallocate to create and destroy allocated\n+\tcontrolled objects.\n+\t* a-finali.adb (\"=\"): Removed.\n+\t* a-finali.ads (\"=\"): Removed. Controlled types no longer carry hidden\n+\tfields Prev and Next.\n+\t* ali.adb (Scan_ALI): Add parsing code to process PF / Has_Finalizer.\n+\tA library unit with at least one controlled object on the library level\n+\thas a special finalizer which is invoked by the binder. To signal this,\n+\tali files carry field PF.\n+\t* ali.ads: New field in type Unit_Record called Has_Finalizer. Add\n+\tassociated comment on field usage.\n+\t* a-tags.adb (Get_RC_Offset): Removed.\n+\t(Needs_Finalization): New routine.\n+\t* a-tags.ads: Update the structure of the GNAT dispatch tables.\n+\tDispatch tables now carry field Needs_Finalization which provides\n+\truntime indication whether a type is controlled or has controlled\n+\tcomponents or both. Remove field RC_Offset.\n+\t(Get_RC_Offset): Removed along with its associated pragma Export.\n+\tSince tagged types with controlled components no longer carry hidden\n+\tfield _controller, the special mechanism to retrieve its location is no\n+\tlonger needed.\n+\t(Needs_Finalization): New routine.\n+\t* atree.ads, atree.adb (Elist24): New routine.\n+\t(Set_Elist24): New routine.\n+\t* atree.h: Add a define clause for Elist24.\n+\t* bindgen.adb New library-level variable Lib_Final_Built.\n+\t(Gen_Adafinal_Ada): Reimplemented. Depending on the restrictions or the\n+\tpresence of a VM target, the routine generates calls to the proper\n+\tlibrary finalization routine.\n+\t(Gen_Adainit_Ada): Import Finalize_Library_Objects only on non-VM\n+\ttargets. Set the correct library finalization routine depending on\n+\twhether the library has controlled objects or this is a VM compilation.\n+\t(Gen_Finalize_Library_Ada): New routine. This procedure generates calls\n+\tto library-level finalizers of compiled units in reverse order of\n+\telaboration. It also produces exception management code and reraises a\n+\tpotential exception after all units have been finalized.\n+\t(Gen_Finalize_Library_C): New routine. This procedure generates calls to\n+\tlibrary-level finalizers of compiled units in reverse order of\n+\telaboration.\n+\t(Gen_Finalize_Library_Defs_C): New routine. This procedure generates the\n+\tdefinitions of all library-level finalizers available to the compilation\n+\t(Gen_Main_Ada): Directly call Adafinal which now contails all target\n+\tdependent code.\n+\t(Gen_Main_C): Add new local constant Needs_Library_Finalization. Call\n+\tSystem.Standard_Library.Adafinal directly. If the library needs\n+\tfinalization actions, create the sequence of finalization calls.\n+\t(Gen_Output_File_Ada): Alphabetize local variables and constants.\n+\tGenerate a with clause for System.Soft_Links when compiling for a VM.\n+\tRemove the code which imports System.Standard_Library.Adafinal as\n+\tDo_Finalize. Generate the library finalization routine.\n+\t(Gen_Output_File_C): Add new local constant Needs_Library_Finalization.\n+\tIf the library needs finalization actions, create all the definitions\n+\tof library- level finalizers.\n+\t(Has_Finalizer): New routine. Determines whether at least one compiled\n+\tunit has a library-level finalizer.\n+\tAdd type Qualification_Mode.\n+\t(Set_Unit_Name): Add a formal which controls the replacement of a dot.\n+\t* einfo.adb: New usage of field 15 as Return_Flag.\n+\tRemove Finalization_Chain_Entity from the usages of field 19.\n+\tRemove Associated_Final_Chain from the usages of field 23.\n+\tNew usage of field 23 as Associated_Collection.\n+\tNew usage of field 24 as Finalizer.\n+\tNew usage of flag 252 as Is_Processed_Transient.\n+\t(Associated_Final_Chain): Removed.\n+\t(Associated_Collection): New routine.\n+\t(Finalization_Chain_Entity): Removed.\n+\t(Finalizer): New routine.\n+\t(Is_Finalizer): New routine.\n+\t(Is_Processed_Transient): New routine.\n+\t(Return_Flag): New routine.\n+\t(Set_Associated_Final_Chain): Removed.\n+\t(Set_Associated_Collection): New routine.\n+\t(Set_Finalization_Chain_Entity): Removed.\n+\t(Set_Finalizer): New routine.\n+\t(Set_Is_Processed_Transient): New routine.\n+\t(Set_Return_Flag): New routine.\n+\t(Write_Entity_Flags): Include Is_Processed_Transient to the list of\n+\tdisplayed flags.\n+\t(Write_Field8_Name): Alphabetize the output.\n+\t(Write_Field11_Name): Alphabetize the output.\n+\t(Write_Field12_Name): Alphabetize the output.\n+\t(Write_Field13_Name): Alphabetize the output.\n+\t(Write_Field14_Name): Alphabetize the output.\n+\t(Write_Field15_Name): Alphabetize the output.\n+\t(Write_Field16_Name): Alphabetize the output.\n+\t(Write_Field17_Name): Alphabetize the output.\n+\t(Write_Field18_Name): Alphabetize the output.\n+\t(Write_Field19_Name): Alphabetize the output. Remove the output of\n+\tFinalization_Chain_Entity.\n+\t(Write_Field20_Name): Alphabetize the output.\n+\t(Write_Field21_Name): Alphabetize the output.\n+\t(Write_Field22_Name): Alphabetize the output.\n+\t(Write_Field23_Name): Alphabetize the output. Remove the output of\n+\tAssociated_Final_Chain. Add output for Associated_Collection.\n+\t(Write_Field24_Name): Alphabetize the output.\n+\t(Write_Field25_Name): Add output for Finalizer.\n+\t(Write_Field26_Name): Alphabetize the output.\n+\t(Write_Field27_Name): Alphabetize the output.\n+\t(Write_Field28_Name): Alphabetize the output.\n+\t* einfo.ads: Add new field description for Associated_Collection and\n+\tits uses in nodes.\n+\tRemove Associated_Final_Chain and its uses in nodes.\n+\tRemove Finalization_Chain_Entity and its uses in nodes.\n+\tAdd new field description for Finalizer and its uses in nodes.\n+\tAdd new synthesized attribute Is_Finalizer.\n+\tAdd new flag description for Is_Processed_Transient and its uses in\n+\tnodes.\n+\tAdd new field description for Return_Flag and its uses in nodes.\n+\t(Associated_Final_Chain): Removed along with its pragma Inline.\n+\t(Associated_Collection): New routine and pragma Inline.\n+\t(Finalization_Chain_Entity): Removed along with its pragma Inline.\n+\t(Finalizer): New routine and pragma Inline.\n+\t(Is_Finalizer): New routine and pragma Inline.\n+\t(Is_Processed_Transient): New routine and pragma Inline.\n+\t(Return_Flag): New routine and pragma Inline.\n+\t(Set_Associated_Final_Chain): Removed along with its pragma Inline.\n+\t(Set_Associated_Collection): New routine and pragma Inline.\n+\t(Set_Finalization_Chain_Entity): Removed along with its pragma Inline.\n+\t(Set_Finalizer): New routine and pragma Inline.\n+\t(Set_Is_Processed_Transient): New routine and pragma Inline.\n+\t(Set_Return_Flag): New routine and pragma Inline.\n+\t* exp_aggr.adb: Alphabetize subprograms.\n+\t(Build_Array_Aggr_Code): Remove formal Flist and its associated comment.\n+\t(Build_Record_Aggr_Code): Remove formals Flist and Obj along with their\n+\tassociated comments. Remove local variables External_Final_List and\n+\tAttach.\n+\tRename Ctrl_Stuff_Done to Finalization_Done. Rename local variable A to\n+\tAncestor. Remove the retrieval of finalization lists. Update the call to\n+\tMake_Adjust_Call.\n+\t(Convert_Aggr_In_Allocator): Remove the retrieval of finalization\n+\tlists. Update the call to Late_Expansion.\n+\t(Convert_Aggr_In_Assignment): Update the call to Late_Expansion.\n+\t(Convert_Aggr_In_Object_Decl): Update the call to Late_Expansion.\n+\t(Gen_Assign): Remove the retrieval of the finalization list used to\n+\tbuild the assignment. Update the calls to Make_Init_Call and\n+\tMake_Adjust_Call.\n+\t(Gen_Ctrl_Actions_For_Aggr): Renamed to Generate_Finalization_Actions.\n+\tRemove the mechanism to determine attachment levels and finalization\n+\tlist retrieval. Remove the processing for coextensions.\n+\t(Init_Controller): Removed. Controllers no longer exist.\n+\t(Late_Expansion): Remove formals Flist and Obj along with their\n+\tassociated comments. Update the calls to Build_Record_Aggr_Code and\n+\tBuild_Array_Aggr_Code.\n+\t* exp_ch13.adb (Expand_N_Free_Statement): New routine.\n+\t(Expand_N_Freeze_Entity): Add special processing for finalizers which\n+\tappear in entry bodies, protected subprograms and task bodies.\n+\t* exp_ch13.ads (Expand_N_Free_Statement): New routine.\n+\t* exp_ch3.adb (Add_Final_Chain): Removed.\n+\t(Build_Array_Init_Proc): Alphabetize local variables.\n+\t(Build_Assignment): Alphabetize local variables. Update the call to\n+\tMaked_Adjust_Call.\n+\t(Build_Class_Wide_Master): Rename local variables to better reflect\n+\ttheir role.\n+\t(Build_Discriminant_Assignments): Code reformatting.\n+\t(Build_Init_Call_Thru): Code reformatting.\n+\t(Build_Init_Procedure): Code reformatting. Generate a special version\n+\tof Deep_Finalize which is capable of finalizing all initialized\n+\tcomponents and ignore the rest.\n+\t(Build_Init_Statements): Rename local variables to better reflect their\n+\trole.\n+\tReimplement the mechanism to include the creation and update of an index\n+\tvariable called a \"counter\". It is used as a bookmark for tracing\n+\tinitialized and non-initialized components.\n+\t(Build_Initialization_Call): Remove local variable Controller_Typ.\n+\tAlphabetize all local variables. Remove the initialization of the\n+\trecord controller and update the call to Make_Init_Call.\n+\t(Build_Record_Init_Proc): Rename formal Pe to Rec_Ent.\n+\tNew local variable Counter.\n+\t(Constrain_Array): Alphabetize.\n+\t(Expand_Freeze_Array_Type): Create a collection instead of a\n+\tfinalization list.\n+\t(Expand_Freeze_Class_Wide_Type): New routine. Creates TSS primitive\n+\tFinalize_Address which is used in conjunction with allocated controlled\n+\tobjects.\n+\t(Expand_N_Object_Declaration): Remove the creation of a finalization\n+\tlist for anonymous access types. Update the calls to Make_Init_Call and\n+\tMake_Adjust_Call.\n+\t(Expand_Freeze_Record_Type): Remove local variable Flist. Remove the\n+\tretrieval of finalization lists. Remove the expansion of the record\n+\tcontroller. Create TSS primitive Finalize_Address used in conjunction\n+\twith controlled objects on the heap. Create finalization collections\n+\tfor access-to-controlled record components.\n+\t(Expand_Record_Controller): Removed.\n+\t(Freeze_Type): Remove the freezing of record controllers. Freezing of\n+\tclass-wide types now requires additional processing. Create\n+\tfinalization collections for access-to-controlled types.\n+\t(Increment_Counter): New routine.\n+\t(Make_Counter): New routine.\n+\t(Make_Eq_If): Remove the mention of Name_uController.\n+\t(Make_Predefined_Primitive_Specs): There is no longer need to skip\n+\ttypes coming from System.Finalization_Root.\n+\t(Predef_Deep_Spec): Reimplemented to reflect the new parameter profiles.\n+\t(Predefined_Primitive_Bodies): There is no longer need to skip types\n+\tcoming from System.Finalization_Root.\n+\t(Stream_Operation_OK): Do not generate stream routines for\n+\ttype Ada.Finalization.Heap_Management.Finalization_Collection.\n+\t* exp_ch3.ads: Alphabetize subprograms.\n+\t* exp_ch4.adb: Remove with and use clause for Sem_Ch8.\n+\tAdd with and use clause for Lib.\n+\t(Complete_Coextension_Finalization): Removed.\n+\t(Complete_Controlled_Allocation): New routine. Create a finalization\n+\tcollection for anonymous access-to-controlled types. Create a custom\n+\tAllocate which interfaces with the back end and the machinery in\n+\tHeap_Management.\n+\t(Expand_Allocator_Expression): Add necessary calls to\n+\tComplete_Controlled_Allocation. Remove the retrieval of finalization\n+\tlists. Update the calls to Make_Adjust_Call. Generate a call to\n+\tAda.Finalization.Heap_Management.Set_Finalize_Address_Ptr to decorate\n+\tthe associated collection.\n+\t(Expand_N_Allocator): Remove the processing for dynamic coextensions.\n+\tCode clean up. Remove the retrieval of finalization lists and\n+\tattachment levels.\n+\tUpdate the call to Make_Init_Call. Generate a call to\n+\tAda.Finalization.Heap_Management.Set_Finalize_Address_Ptr to decorate\n+\tthe associated collection.\n+\t(Get_Allocator_Final_List): Removed. Finalization lists are not\n+\tavailable.\n+\t(Suitable_Element): Remove the mention of Name_uController.\n+\t* exp_ch5.adb: Remove with and use clauses for Ttypes and Uintp.\n+\t(Make_Tag_Ctrl_Assignment): Rewritten to simply do a finalization of\n+\tthe left hand side, carry out the assignment and adjust the left hand\n+\tside.\n+\t* exp_ch6.adb (Add_Final_List_Actual_To_Build_In_Place_Call): Removed.\n+\t(Add_Collection_Actual_To_Build_In_Place_Call): New routine.\n+\t(BIP_Formal_Suffix): Rename BIP_Final_List and BIPfinallist to\n+\tBIP_Collection and BIPcollection.\n+\t(Build_Heap_Allocator): New routine used to allocate the return object\n+\tof a build-in-place function onto a collection.\n+\t(Expand_Ctrl_Function_Call): Moved from Exp_Ch7.\n+\t(Expand_Call): Do not replace direct calls to Deep routines with their\n+\taliases.\n+\t(Expand_N_Extended_Return_Statement): Give all variables shorter names\n+\tand update their occurrences. Add a special return flag to monitor the\n+\t[ab]normal execution of the function. The flag is set right before the\n+\treturn statement.\n+\tRewrite the mechanism used to allocate a build-in-place return object\n+\ton the heap or on a storage pool.\n+\t(Is_Direct_Deep_Call): New routine.\n+\t(Make_Build_In_Place_Call_In_Allocator): Add a collection to a\n+\tbuild-in-place function call instead of a final list. Build a call to\n+\tSet_Finalize_Address_Ptr to decorate the associated collection.\n+\t(Make_Build_In_Place_Call_In_Anonymous_Context): Create a temporary in\n+\torder to name the build-in-place function call's result for later\n+\tfinalization. Add a collection to a build-in-place function call\n+\tinstead of a final list.\n+\t(Make_Build_In_Place_Call_In_Assignment): Add a collection to a\n+\tbuild-in-place function call instead of a final list. Remove the code\n+\twhich moves one final list and transforms it into the actual in a\n+\tnested build-in-place call.\n+\t(Make_Build_In_Place_Call_In_Object_Declaration): Add a collection to a\n+\tbuild-in-place function call instead of a final list.\n+\t(Move_Final_List): Removed.\n+\t(Needs_BIP_Collection): New routine.\n+\t(Needs_BIP_Final_List): Removed.\n+\t* exp_ch6.ads: Replace BIP_Final_List with BIP_Collection in\n+\tenumeration type BIP_Formal_Kind.\n+\tUpdate the related comment.\n+\t(Needs_BIP_Collection): New routine.\n+\t(Needs_BIP_Final_List): Removed.\n+\t* exp_ch7.adb: Add with and use clauses for Elists, Exp_Ch6, Stringt\n+\tand Ttypes. Remove with and use clauses for Sem_Type. Alphabetize the\n+\tmajority of subprograms in this unit. Add Name_Finalize_Address to\n+\tarray Name_Of and TSS_Finalize_Address to array Deep_Name_Of.\n+\t(Build_Adjust_Or_Finalize_Statements): Create the adjust or finalization\n+\tstatements for an array type.\n+\t(Build_Adjust_Statements): Create the adjust statements for a record\n+\ttype.\n+\t(Build_Cleanup_Statements): New routine. A procedure which given any\n+\tconstruct containing asynchronous calls, references to _master, or is a\n+\ttask body, a task allocation or a protected body produces the necessary\n+\truntime calls to clean up these constructs.\n+\t(Build_Exception_Handler): New routine.\n+\t(Build_Final_List): Removed.\n+\t(Build_Finalization_Collection): New routine. A core procedure which\n+\tcreates a collection to service heap allocated controlled objects\n+\tassociated with an access-to-controlled type.\n+\t(Build_Finalize_Statements): Create the finalization statements for a\n+\trecord types.\n+\t(Build_Finalizer): New routine. A core procedure which given any\n+\tconstruct with declarations and/or statements detects all objects which\n+\tneed any type of clean up (controlled objects, protected objects) and\n+\tgenerates all necessary code to clean up the said objects in the proper\n+\torder.\n+\t(Build_Finalizer_Call): New routine.\n+\t(Build_Initialize_Statements): Create the initialization statements for\n+\tan array type. The generated routine contains code to finalize partially\n+\tinitialized arrays.\n+\t(Build_Object_Declarations): New routine.\n+\t(Build_Raise_Statement): New routine.\n+\t(Clean_Simple_Protected_Objects): Removed.\n+\t(Controller_Component): Removed.\n+\t(Enclosing_Function): New routine.\n+\t(Expand_Cleanup_Actions): Create a finalizer for a construct which has\n+\teither declarations or statements or both.\n+\t(Expand_N_Package_Body): Create a finalizer for a non-generic package.\n+\t(Expand_N_Package_Declaration): Create a finalizer for a non-generic\n+\tpackage.\n+\t(Find_Final_List): Removed.\n+\t(Global_Flist_Ref): Removed.\n+\t(In_Finalization_Root): Removed.\n+\t(Insert_Actions_In_Scope_Around): Determine the range of the transient\n+\tscope in terms of tree nodes. Process all transient variables within\n+\tthat range.\n+\t(Make_Adjust_Call): Rewritten. There is no longer an attach call\n+\tgenerated after the adjust.\n+\t(Make_Attach_Call): Removed.\n+\t(Make_Call): New routine.\n+\t(Make_Clean): Removed.\n+\t(Make_Deep_Array_Body): Rewritten to simply invoke the appropriate\n+\tbuild routines.\n+\t(Make_Deep_Proc): Rewritten to generate the new profile signature used\n+\tin Deep routines.\n+\t(Make_Deep_Record_Body): Rewritten to simply invoke the appropriate\n+\tbuild routines.\n+\t(Make_Final_Call): Modified to simply create a call to either\n+\tDeep_Finalize or Finalize.\n+\t(Make_Finalize_Address_Body): New routine.\n+\t(Make_Finalize_Address_Stmts): New routine. A function which produces\n+\tTSS primitive Finalize_Address used in conjunction with heap allocated\n+\tcontrolled objects.\n+\t(Make_Handler_For_Ctrl_Operation): Add specialized code for .NET/JVM.\n+\t(Make_Init_Call): Rewritten. There is no longer an attach call\n+\tgenerated after initialization.\n+\t(Make_Local_Deep_Finalize): New routine.\n+\t(Make_Set_Finalize_Address_Ptr_Call): New routine.\n+\t(Make_Transient_Block): Remove the finalization list retrieval and\n+\tmanipulation.\n+\t(Needs_Finalization): Moved to Exp_Util.\n+\t(Parent_Field_Type): New routine.\n+\t(Preprocess_Components): New routine.\n+\t(Process_Transient_Objects): New routine.\n+\t(Wrap_HSS_In_Block): New routine.\n+\t(Wrap_Transient_Declaration): Remove finalization list management and\n+\tcontroller insertion.\n+\t(Wrap_Transient_Expression): Code reformatting.\n+\t(Wrap_Transient_Statement): Code reformatting.\n+\t* exp_ch7.ads (Build_Final_List): Removed.\n+\t(Build_Finalization_Collection): New routine.\n+\t(Build_Raise_Statement): New routine.\n+\t(Controller_Component): Removed.\n+\t(Expand_Ctrl_Function_Call): Moved to Exp_Ch6.\n+\t(Find_Final_List): Removed.\n+\t(In_Finalization_Root): Removed.\n+\t(Is_Simple_Protected_Type): Update related comment.\n+\t(Make_Adjust_Call): New parameter profile and associated comments.\n+\t(Make_Attach_Call): Removed.\n+\t(Make_Final_Call): New parameter profile and associated comments.\n+\t(Make_Finalize_Address_Body): New routine.\n+\t(Make_Init_Call): New parameter profile and associated comments.\n+\t(Make_Local_Deep_Finalize): New routine.\n+\t(Make_Set_Finalize_Address_Ptr_Call): New routine.\n+\t(Needs_Finalization): Moved to Exp_Util.\n+\t* exp_ch9.adb (Add_Object_Pointer): Code reformatting.\n+\t(Expand_N_Protected_Body): Remove the handling of finalization lists.\n+\t(Find_Protection_Type): Moved to Exp_Util.\n+\t* exp_disp.adb: Remove with and use clauses for Exp_Ch7.\n+\t(Make_DT): Update sequence of dispatch table initialization. Remove the\n+\tinitialization of field RC_Offset. Add initialization of field Needs_\n+\tFinalization.\n+\t* exp_intr.adb (Expand_Unc_Deallocation): Code reformatting.\n+\tReimplement how an object is first finalized, then deallocated.\n+\t* exp_strm.adb (Build_Record_Or_Elementary_Input_Function):\n+\tCode reformatting.\n+\t* exp_tss.ads: Add special suffix for TSS primitive Finalize_Address.\n+\tRegister TSS_Finalize_Address with type TSS_Names.\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): New routine. This core\n+\tprocedure provides the interface between an allocation / deallocation\n+\tand the support machinery in Ada.Finalization.Heap_Management.\n+\t(Find_Init_Call): Code reformatting.\n+\t(Find_Init_Call_In_List): Code reformatting.\n+\t(Find_Protection_Type): Moved from Exp_Ch9.\n+\t(Find_Prim_Op): Reimplement to add preference of recovered primitive.\n+\t(Has_Controlled_Coextensions): Removed.\n+\t(Has_Controlled_Objects): New routine.\n+\t(In_Library_Level_Package_Body): New routine.\n+\t(Insert_Action_After): New routine.\n+\t(Is_Finalizable_Transient): New routine. This predicate determines\n+\twhether an object declaration is one of the many variants of controlled\n+\ttransients.\n+\t(Is_Null_Access_BIP_Func_Call): New routine.\n+\t(Is_Non_BIP_Func_Call): New routine.\n+\t(Is_Related_To_Func_Return): New routine.\n+\t(Needs_Finalization): Moved from Exp_Ch7.\n+\t* exp_util.ads (Build_Allocate_Deallocate_Proc): New routine.\n+\t(Find_Protection_Type): Moved from Exp_Ch9.\n+\t(Has_Controlled_Coextensions): Removed.\n+\t(Has_Controlled_Objects): New routine.\n+\t(In_Library_Level_Package_Body): New routine.\n+\t(Insert_Action_After): New routine.\n+\t(Is_Finalizable_Transient): New routine.\n+\t(Is_Null_Access_BIP_Func_Call): New routine.\n+\t(Is_Non_BIP_Func_Call): New routine.\n+\t(Is_Related_To_Func_Return): New routine.\n+\t(Needs_Finalization): Moved from Exp_ch7.\n+\t* expander.adb (Expand): Add a case for N_Free_Statement.\n+\t* freeze.adb (Freeze_All): Replace the generation of a finalization\n+\tlist with a collection for access-to-controlled types.\n+\t(Freeze_Entity): Code reformatting.\n+\t(Freeze_Record_Type): Remove the freezing of a record controller\n+\tcomponent.\n+\t(Freeze_Subprogram): Code reformatting.\n+\t* inline.adb (Cleanup_Scopes): Remove the reset of the scope\n+\tfinalization list.\n+\t* lib-writ.adb (Write_Unit_Information): Output \"PF\" when a package\n+\thas a library-level finalizer.\n+\t* lib-writ.ads: Add \"PF\" to the sequence of unit attributes.\n+\t* a-filico.ads, a-filico.adb, s-finimp.ads, s-finimp.adb: Removed.\n+\t* Makefile.rtl: Remove a-filico and s-finimp from the list of object\n+\tfiles. Add a-fihema to the list of object files.\n+\t* par-ch4.adb:\n+\tAlphabetize the associations in type Is_Parameterless_Attribute.\n+\t* rtsfind.ads: Ada.Finalization_List.Controller and\n+\tSystem.Finalization_Implementation are no longer a GNAT unit.\n+\tUpdate the range of type Ada_Finalization_Child. Remove the following\n+\trecoverable entities:\n+\t\n+\t   RE_Attach_To_Final_List\n+\t   RE_Deep_Tag_Attach\n+\t   RE_Finalize_List\n+\t   RE_Finalize_One\n+\t   RE_Finalizable_Ptr_Ptr\n+\t   RE_Global_Final_List\n+\t   RE_Limited_Record_Controller\n+\t   RE_List_Controller\n+\t   RE_Move_Final_List\n+\t   RE_Record_Controller\n+\t   RE_Simple_List_Controller\n+\t\n+\tAdd the following recoverable entities:\n+\t\n+\t   RE_Add_Offset_To_Address\n+\t   RE_Allocate\n+\t   RE_Base_Pool\n+\t   RE_Deallocate\n+\t   RE_Exception_Identity\n+\t   RE_Finalization_Collection\n+\t   RE_Finalization_Collection_Ptr\n+\t   RE_Needs_Finalization\n+\t   RE_Save_Library_Occurrence\n+\t   RE_Set_Finalize_Address_Ptr\n+\t   RE_Set_Storage_Pool_Ptr\n+\t   RE_Storage_Count\n+\t* sem_aggr.adb (Resolve_Record_Aggregate): Remove mention of\n+\tName_uController.\n+\t* sem_aux.adb (First_Discriminant): Remove mention of Name_uController.\n+\t(First_Stored_Discriminant): Remove the mention of Name_uController.\n+\t* sem_aux.ads: Comment reformatting.\n+\t* sem_ch10.adb (Build_Chain): Signal the class-wide creation machinery\n+\tto redecorate an already existing class-wide type.\n+\t(Decorate_Tagged_Type): New parameter profile and associated comment.\n+\tCreate a \"shadow class-wide type\" for a shadow entity.\n+\t* sem_ch11.adb (Analyze_Exception_Handlers): Remove the dubious setting\n+\tof the final chain along with the associated comment.\n+\t* sem_ch3.adb (Access_Type_Declaration): Add new local variable\n+\tFull_Desig and set it to the full view of the designated type.\n+\tInitialize the finalization collection to empty.\n+\t(Build_Derived_Record_Type): Alphabetize local variables. Code\n+\treformatting.\n+\t(Collect_Fixed_Components): Remove the mention of Name_uController.\n+\t(Create_Constrained_Components): Remove the mention of Name_uController.\n+\t(Make_Class_Wide_Type): Add specialized code to redecorate an existing\n+\tclass-wide type of a shadow entity.\n+\t(Process_Full_View): Update the machinery which marks type\n+\tLimited_Controlled's entity as limited.\n+\t* sem_ch4.adb (Analyze_One_Call): Code reformatting.\n+\t* sem_ch6.adb (Create_Extra_Formals): Do not generate a finalization\n+\tlist, instead make a collection build-in-place formal.\n+\t* sem_ch8.adb (Analyze_Object_Renaming): Look at the available view of\n+\ta designated type in order to establish a match between the renaming\n+\tand the renamed entity.\n+\t(Find_Selected_Component): Add guard to prevent spurious exceptions\n+\tfrom being raised on .NET/JVM.\n+\t* sem_disp.adb (Check_Dispatching_Operation): Include Finalize_Address\n+\tto the list of primitive that need special processing. Update arrays\n+\tC_Names and D_Names.\n+\t(Replace_Types): Handle class-wide types.\n+\t* sem_elab.adb (Check_A_Call): Since Deep_Initialize now has a\n+\tdifferent parameter profile, look at the first formal.\n+\t* sem_prag.adb: Remove with and use clauses for Exp_Ch7. Add with and\n+\tuse clauses for Exp_Util.\n+\t* sem_res.adb: Remove with and use clauses for Elists.\n+\t(Propagate_Coextensions): Removed.\n+\t(Resolve_Allocator): Do not propagate the list of coextensions from one\n+\tallocator to another.\n+\t* sem_util.adb (Build_Actual_Subtype_Of_Component): Rename variable\n+\tDeaccessed_T to Desig_Typ.\n+\t(Enter_Name): Remove the mention of Name_uController.\n+\t(Gather_Components): Remove the mention of Name_uController.\n+\t(Incomplete_Or_Private_View): New routine.\n+\t(Is_Coextension_Root): Removed.\n+\t(Is_Fully_Initialized_Type): Remove the mention of Name_uController.\n+\t* sem_util.ads (Incomplete_Or_Private_View): New routine.\n+\t(Is_Coextension_Root): Removed.\n+\t* s-finroo.ads: Remove with clause for Ada.Unchecked_Conversion.\n+\tControlled types are now derived from a null tagged record. Remove\n+\ttypes Finalizable_Ptr, Finalizable and Empty_Root_Controlled.\n+\t* sinfo.adb (Coextensions): Removed.\n+\t(Set_Coextensions): Removed.\n+\t* sinfo.ads: Remove Coextensions from the explanation of node fields\n+\tand its uses in nodes.\n+\tUpdate the field usage of N_Allocator.\n+\t(Coextensions): Removed along with its pragma Inline.\n+\t(Set_Coextensions): Removed along with its pragma Inline.\n+\t* snames.ads-tmpl: Remove names\n+\t\n+\t  Name_uClean\n+\t  Name_uController\n+\t  Name_uFinal_List\n+\t  Name_uLocal_Final_List\n+\t  Name_Finalization_Root\n+\t  Name_Next\n+\t  Name_Prev\n+\t\n+\tAdd names\n+\t\n+\t  Name_uFinalizer\n+\t  Name_Finalize_Address\n+\t* s-pooglo.adb (Allocate): Add overriding indicator.\n+\t(Deallocate): Add overriding indicator.\n+\t(Storage_Size): Add overriding indicator.\n+\t* s-soflin.adb (Adafinal_NT): Invoke Finalize_Library_Objects rather\n+\tthan Finalize_Global_List.\n+\t(Null_Finalize_Global_List): Removed.\n+\t(Save_Library_Occurrence): New routine.\n+\t* s-soflin.ads: Remove variable Finalize_Global_List along with its\n+\tinitialization. Add variable Finalize_Library_Objects along with its\n+\tpragma Export. Add variables Library_Exception and\n+\tLibrary_Exception_Set along with their pragma Export.\n+\t(Null_Finalize_Global_List): Removed.\n+\t(Save_Library_Occurrence): New routine.\n+\t* s-tassta.adb (Finalize_Global_Tasks): Call Finalize_Library_Objects\n+\trather than Finalize_Global_List.\n+\t* tbuild.adb (Unchecked_Convert_To): Capture and set the parent field\n+\tof the constructed node.\n+\n 2011-08-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* link.c: Include \"auto-host.h\" before system headers."}, {"sha": "0c8dac0a1093b6975c8189db20d86e19b093ff23", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -150,7 +150,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-envvar$(objext) \\\n   a-except$(objext) \\\n   a-exctra$(objext) \\\n-  a-filico$(objext) \\\n+  a-fihema$(objext) \\\n   a-finali$(objext) \\\n   a-flteio$(objext) \\\n   a-fwteio$(objext) \\\n@@ -490,7 +490,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-ficobl$(objext) \\\n   s-fileio$(objext) \\\n   s-filofl$(objext) \\\n-  s-finimp$(objext) \\\n   s-finroo$(objext) \\\n   s-fishfl$(objext) \\\n   s-fore$(objext)   \\"}, {"sha": "e69e859b82fc51e264206937f40ad038dc41dc37", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -880,36 +880,61 @@ package body Ada.Exceptions is\n    procedure Raise_From_Controlled_Operation\n      (X : Ada.Exceptions.Exception_Occurrence)\n    is\n-      Prefix   : constant String := \"adjust/finalize raised \";\n-      Orig_Msg : constant String := Exception_Message (X);\n-      New_Msg  : constant String := Prefix & Exception_Name (X);\n+      Prev_Exc  : constant EOA := Get_Current_Excep.all;\n \n    begin\n-      if Orig_Msg'Length >= Prefix'Length\n-        and then\n-          Orig_Msg (Orig_Msg'First .. Orig_Msg'First + Prefix'Length - 1) =\n-                                                                     Prefix\n-      then\n-         --  Message already has proper prefix, just re-reraise PROGRAM_ERROR\n+      --  We're raising an exception during finalization. If the finalization\n+      --  was triggered by an abort, as indicated by Not_Handled_By_Others,\n+      --  then we don't want to raise Program_Error; we want to continue with\n+      --  the Abort_Signal exception. Note that the original exception\n+      --  occurrence that triggered the finalization is saved before calling\n+      --  the Finalize procedures, and then restored afterward, so in the case\n+      --  of abort, the original Abort_Signal will be the current one.\n \n-         Raise_Exception_No_Defer\n-           (E       => Program_Error'Identity,\n-            Message => Orig_Msg);\n+      if Prev_Exc.Id /= null and then Prev_Exc.Id.Not_Handled_By_Others then\n+         Raise_Current_Excep (Prev_Exc.Id);\n \n-      elsif Orig_Msg = \"\" then\n-\n-         --  No message present: just provide our own\n-\n-         Raise_Exception_No_Defer\n-           (E       => Program_Error'Identity,\n-            Message => New_Msg);\n+      --  Otherwise, raise Program_Error\n \n       else\n-         --  Message present, add informational prefix\n-\n-         Raise_Exception_No_Defer\n-           (E       => Program_Error'Identity,\n-            Message => New_Msg & \": \" & Orig_Msg);\n+         declare\n+            Prefix             : constant String := \"adjust/finalize raised \";\n+            Orig_Msg           : constant String := Exception_Message (X);\n+            Orig_Prefix_Length : constant Natural :=\n+              Integer'Min (Prefix'Length, Orig_Msg'Length);\n+            Orig_Prefix        : String renames Orig_Msg\n+              (Orig_Msg'First .. Orig_Msg'First + Orig_Prefix_Length - 1);\n+\n+         begin\n+            --  Message already has the proper prefix, just re-reraise\n+\n+            if Orig_Prefix = Prefix then\n+               Raise_Exception_No_Defer\n+                 (E       => Program_Error'Identity,\n+                  Message => Orig_Msg);\n+\n+            else\n+               declare\n+                  New_Msg  : constant String := Prefix & Exception_Name (X);\n+\n+               begin\n+                  --  No message present, just provide our own\n+\n+                  if Orig_Msg = \"\" then\n+                     Raise_Exception_No_Defer\n+                       (E       => Program_Error'Identity,\n+                        Message => New_Msg);\n+\n+                  --  Message present, add informational prefix\n+\n+                  else\n+                     Raise_Exception_No_Defer\n+                       (E       => Program_Error'Identity,\n+                        Message => New_Msg & \": \" & Orig_Msg);\n+                  end if;\n+               end;\n+            end if;\n+         end;\n       end if;\n    end Raise_From_Controlled_Operation;\n "}, {"sha": "a17d6558e8509a419a29756ba33d8ba5cd0c79b3", "filename": "gcc/ada/a-except-2005.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-except-2005.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-except-2005.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -232,8 +232,13 @@ private\n    procedure Raise_From_Controlled_Operation\n      (X : Ada.Exceptions.Exception_Occurrence);\n    pragma No_Return (Raise_From_Controlled_Operation);\n+   pragma Export\n+     (Ada, Raise_From_Controlled_Operation,\n+           \"__gnat_raise_from_controlled_operation\");\n    --  Raise Program_Error, providing information about X (an exception raised\n-   --  during a controlled operation) in the exception message.\n+   --  during a controlled operation) in the exception message. However, if the\n+   --  finalization was triggered by abort, keep aborting instead of raising\n+   --  Program_Error.\n \n    procedure Reraise_Occurrence_Always (X : Exception_Occurrence);\n    pragma No_Return (Reraise_Occurrence_Always);"}, {"sha": "2b51c1f1989f6e94680a1b00066739437c364bd9", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -852,36 +852,61 @@ package body Ada.Exceptions is\n    procedure Raise_From_Controlled_Operation\n      (X : Ada.Exceptions.Exception_Occurrence)\n    is\n-      Prefix   : constant String := \"adjust/finalize raised \";\n-      Orig_Msg : constant String := Exception_Message (X);\n-      New_Msg  : constant String := Prefix & Exception_Name (X);\n+      Prev_Exc  : constant EOA := Get_Current_Excep.all;\n \n    begin\n-      if Orig_Msg'Length >= Prefix'Length\n-        and then\n-          Orig_Msg (Orig_Msg'First .. Orig_Msg'First + Prefix'Length - 1) =\n-                                                                     Prefix\n-      then\n-         --  Message already has proper prefix, just re-reraise PROGRAM_ERROR\n+      --  We're raising an exception during finalization. If the finalization\n+      --  was triggered by an abort, as indicated by Not_Handled_By_Others,\n+      --  then we don't want to raise Program_Error; we want to continue with\n+      --  the Abort_Signal exception. Note that the original exception\n+      --  occurrence that triggered the finalization is saved before calling\n+      --  the Finalize procedures, and then restored afterward, so in the case\n+      --  of abort, the original Abort_Signal will be the current one.\n \n-         Raise_Exception_No_Defer\n-           (E       => Program_Error'Identity,\n-            Message => Orig_Msg);\n+      if Prev_Exc.Id /= null and then Prev_Exc.Id.Not_Handled_By_Others then\n+         Raise_Current_Excep (Prev_Exc.Id);\n \n-      elsif Orig_Msg = \"\" then\n-\n-         --  No message present: just provide our own\n-\n-         Raise_Exception_No_Defer\n-           (E       => Program_Error'Identity,\n-            Message => New_Msg);\n+      --  Otherwise, raise Program_Error\n \n       else\n-         --  Message present, add informational prefix\n-\n-         Raise_Exception_No_Defer\n-           (E       => Program_Error'Identity,\n-            Message => New_Msg & \": \" & Orig_Msg);\n+         declare\n+            Prefix             : constant String := \"adjust/finalize raised \";\n+            Orig_Msg           : constant String := Exception_Message (X);\n+            Orig_Prefix_Length : constant Natural :=\n+              Integer'Min (Prefix'Length, Orig_Msg'Length);\n+            Orig_Prefix        : String renames Orig_Msg\n+              (Orig_Msg'First .. Orig_Msg'First + Orig_Prefix_Length - 1);\n+\n+         begin\n+            --  Message already has proper prefix, just re-reraise\n+\n+            if Orig_Prefix = Prefix then\n+               Raise_Exception_No_Defer\n+                 (E       => Program_Error'Identity,\n+                  Message => Orig_Msg);\n+\n+            else\n+               declare\n+                  New_Msg  : constant String := Prefix & Exception_Name (X);\n+\n+               begin\n+                  --  No message present, just provide our own\n+\n+                  if Orig_Msg = \"\" then\n+                     Raise_Exception_No_Defer\n+                       (E       => Program_Error'Identity,\n+                        Message => New_Msg);\n+\n+                  --  Message present, add informational prefix\n+\n+                  else\n+                     Raise_Exception_No_Defer\n+                       (E       => Program_Error'Identity,\n+                        Message => New_Msg & \": \" & Orig_Msg);\n+                  end if;\n+               end;\n+            end if;\n+         end;\n       end if;\n    end Raise_From_Controlled_Operation;\n "}, {"sha": "1fa0d1c72d9a474276e5e424c7ef534564feb133", "filename": "gcc/ada/a-except.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -201,8 +201,13 @@ private\n    procedure Raise_From_Controlled_Operation\n      (X : Ada.Exceptions.Exception_Occurrence);\n    pragma No_Return (Raise_From_Controlled_Operation);\n-   --  Raise Program_Error, providing information about X (an exception\n-   --  raised during a controlled operation) in the exception message.\n+   pragma Export\n+     (Ada, Raise_From_Controlled_Operation,\n+           \"__gnat_raise_from_controlled_operation\");\n+   --  Raise Program_Error, providing information about X (an exception raised\n+   --  during a controlled operation) in the exception message. However, if the\n+   --  finalization was triggered by abort, keep aborting instead of raising\n+   --  Program_Error.\n \n    procedure Reraise_Occurrence_Always (X : Exception_Occurrence);\n    pragma No_Return (Reraise_Occurrence_Always);"}, {"sha": "cc800f38086c6605c3d0b196f12cc173dd101a06", "filename": "gcc/ada/a-fihema.adb", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-fihema.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-fihema.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -0,0 +1,513 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--     A D A . F I N A L I Z A T I O N . H E A P _ M A N A G E M E N T      --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--          Copyright (C) 2008-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Exceptions;          use Ada.Exceptions;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+\n+with GNAT.IO;                 use GNAT.IO;\n+\n+with System;                  use System;\n+with System.Address_Image;\n+with System.Storage_Elements; use System.Storage_Elements;\n+with System.Storage_Pools;    use System.Storage_Pools;\n+\n+package body Ada.Finalization.Heap_Management is\n+\n+   Header_Size   : constant Storage_Count  := Node'Size / Storage_Unit;\n+   Header_Offset : constant Storage_Offset := Header_Size;\n+\n+   function Address_To_Node_Ptr is\n+     new Ada.Unchecked_Conversion (Address, Node_Ptr);\n+\n+   procedure Attach (N : Node_Ptr; L : Node_Ptr);\n+   --  Prepend a node to a list\n+\n+   procedure Detach (N : Node_Ptr);\n+   --  Unhook a node from an arbitrary list\n+\n+   procedure Free is new Ada.Unchecked_Deallocation (Node, Node_Ptr);\n+\n+   ---------------------------\n+   -- Add_Offset_To_Address --\n+   ---------------------------\n+\n+   function Add_Offset_To_Address\n+     (Addr   : System.Address;\n+      Offset : System.Storage_Elements.Storage_Offset) return System.Address\n+   is\n+   begin\n+      return System.Storage_Elements.\"+\" (Addr, Offset);\n+   end Add_Offset_To_Address;\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   procedure Allocate\n+     (Collection   : in out Finalization_Collection;\n+      Addr         : out System.Address;\n+      Storage_Size : System.Storage_Elements.Storage_Count;\n+      Alignment    : System.Storage_Elements.Storage_Count;\n+      Needs_Header : Boolean := True)\n+   is\n+   begin\n+      --  Allocation of a controlled object\n+\n+      if Needs_Header then\n+\n+         --  Do not allow the allocation of controlled objects while the\n+         --  associated collection is being finalized.\n+\n+         if Collection.Finalization_Started then\n+            raise Program_Error with \"allocation after finalization started\";\n+         end if;\n+\n+         declare\n+            N_Addr : Address;\n+            N_Ptr  : Node_Ptr;\n+\n+         begin\n+            --  Use the underlying pool to allocate enough space for the object\n+            --  and the list header. The returned address points to the list\n+            --  header.\n+\n+            Allocate\n+              (Collection.Base_Pool.all,\n+               N_Addr,\n+               Storage_Size + Header_Size,\n+               Alignment);\n+\n+            --  Map the allocated memory into a Node record. This converts the\n+            --  top of the allocated bits into a list header.\n+\n+            N_Ptr := Address_To_Node_Ptr (N_Addr);\n+            Attach (N_Ptr, Collection.Objects);\n+\n+            --  Move the address from Prev to the start of the object. This\n+            --  operation effectively hides the list header.\n+\n+            Addr := N_Addr + Header_Offset;\n+         end;\n+\n+      --  Allocation of a non-controlled object\n+\n+      else\n+         Allocate\n+           (Collection.Base_Pool.all,\n+            Addr,\n+            Storage_Size,\n+            Alignment);\n+      end if;\n+   end Allocate;\n+\n+   ------------\n+   -- Attach --\n+   ------------\n+\n+   procedure Attach (N : Node_Ptr; L : Node_Ptr) is\n+   begin\n+      L.Next.Prev := N;\n+      N.Next := L.Next;\n+      L.Next := N;\n+      N.Prev := L;\n+   end Attach;\n+\n+   ---------------\n+   -- Base_Pool --\n+   ---------------\n+\n+   function Base_Pool\n+     (Collection : Finalization_Collection) return Any_Storage_Pool_Ptr\n+   is\n+   begin\n+      return Collection.Base_Pool;\n+   end Base_Pool;\n+\n+   ----------------\n+   -- Deallocate --\n+   ----------------\n+\n+   procedure Deallocate\n+     (Collection   : in out Finalization_Collection;\n+      Addr         : System.Address;\n+      Storage_Size : System.Storage_Elements.Storage_Count;\n+      Alignment    : System.Storage_Elements.Storage_Count;\n+      Has_Header   : Boolean := True)\n+   is\n+   begin\n+      --  Deallocation of a controlled object\n+\n+      if Has_Header then\n+         declare\n+            N_Addr : Address;\n+            N_Ptr  : Node_Ptr;\n+\n+         begin\n+            --  Move the address from the object to the beginning of the list\n+            --  header.\n+\n+            N_Addr := Addr - Header_Offset;\n+\n+            --  Converts the bits preceding the object into a list header\n+\n+            N_Ptr := Address_To_Node_Ptr (N_Addr);\n+            Detach (N_Ptr);\n+\n+            --  Use the underlying pool to destroy the object along with the\n+            --  list header.\n+\n+            Deallocate\n+              (Collection.Base_Pool.all,\n+               N_Addr,\n+               Storage_Size + Header_Size,\n+               Alignment);\n+         end;\n+\n+      --  Deallocation of a non-controlled object\n+\n+      else\n+         Deallocate\n+           (Collection.Base_Pool.all,\n+            Addr,\n+            Storage_Size,\n+            Alignment);\n+      end if;\n+   end Deallocate;\n+\n+   ------------\n+   -- Detach --\n+   ------------\n+\n+   procedure Detach (N : Node_Ptr) is\n+   begin\n+      if N.Prev /= null\n+        and then N.Next /= null\n+      then\n+         N.Prev.Next := N.Next;\n+         N.Next.Prev := N.Prev;\n+         N.Prev := null;\n+         N.Next := null;\n+      end if;\n+   end Detach;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   overriding procedure Finalize\n+     (Collection : in out Finalization_Collection)\n+   is\n+      function Head (L : Node_Ptr) return Node_Ptr;\n+      --  Return the node which comes after the dummy head\n+\n+      function Is_Dummy_Head (N : Node_Ptr) return Boolean;\n+      --  Determine whether a node acts as a dummy head. Such nodes do not\n+      --  have an actual \"object\" attached to them and point to themselves.\n+\n+      function Is_Empty_List (L : Node_Ptr) return Boolean;\n+      --  Determine whether a list is empty\n+\n+      function Node_Ptr_To_Address (N : Node_Ptr) return Address;\n+      --  Not the reverse of Address_To_Node_Ptr. Return the address of the\n+      --  object following the list header.\n+\n+      ----------\n+      -- Head --\n+      ----------\n+\n+      function Head (L : Node_Ptr) return Node_Ptr is\n+      begin\n+         return L.Next;\n+      end Head;\n+\n+      -------------------\n+      -- Is_Dummy_Head --\n+      -------------------\n+\n+      function Is_Dummy_Head (N : Node_Ptr) return Boolean is\n+      begin\n+         --  To be a dummy head, the node must point to itself in both\n+         --  directions.\n+\n+         return\n+           N.Next /= null\n+             and then N.Next = N\n+             and then N.Prev /= null\n+             and then N.Prev = N;\n+      end Is_Dummy_Head;\n+\n+      -------------------\n+      -- Is_Empty_List --\n+      -------------------\n+\n+      function Is_Empty_List (L : Node_Ptr) return Boolean is\n+      begin\n+         return L = null or else Is_Dummy_Head (L);\n+      end Is_Empty_List;\n+\n+      -------------------------\n+      -- Node_Ptr_To_Address --\n+      -------------------------\n+\n+      function Node_Ptr_To_Address (N : Node_Ptr) return Address is\n+      begin\n+         return N.all'Address + Header_Offset;\n+      end Node_Ptr_To_Address;\n+\n+      Curr_Ptr : Node_Ptr;\n+      Ex_Occur : Exception_Occurrence;\n+      Next_Ptr : Node_Ptr;\n+      Raised   : Boolean := False;\n+\n+   --  Start of processing for Finalize\n+\n+   begin\n+      --  Lock the collection to prevent any allocations while the objects are\n+      --  being finalized. The collection remains locked because the associated\n+      --  access type is about to go out of scope.\n+\n+      Collection.Finalization_Started := True;\n+\n+      while not Is_Empty_List (Collection.Objects) loop\n+\n+         --  Find the real head of the collection, skipping the dummy head\n+\n+         Curr_Ptr := Head (Collection.Objects);\n+\n+         --  If the dummy head is the only remaining node, all real objects\n+         --  have already been detached and finalized.\n+\n+         if Is_Dummy_Head (Curr_Ptr) then\n+            exit;\n+         end if;\n+\n+         --  Store the next node now since the detachment will destroy the\n+         --  reference to it.\n+\n+         Next_Ptr := Curr_Ptr.Next;\n+\n+         --  Remove the current node from the list\n+\n+         Detach (Curr_Ptr);\n+\n+         --  ??? Kludge: Don't do anything until the proper place to set\n+         --  primitive Finalize_Address has been determined.\n+\n+         if Collection.Finalize_Address /= null then\n+            begin\n+               Collection.Finalize_Address (Node_Ptr_To_Address (Curr_Ptr));\n+\n+            exception\n+               when Fin_Except : others =>\n+                  if not Raised then\n+                     Raised := True;\n+                     Save_Occurrence (Ex_Occur, Fin_Except);\n+                  end if;\n+            end;\n+         end if;\n+\n+         Curr_Ptr := Next_Ptr;\n+      end loop;\n+\n+      --  Deallocate the dummy head\n+\n+      Free (Collection.Objects);\n+\n+      --  If the finalization of a particular node raised an exception, reraise\n+      --  it after the remainder of the list has been finalized.\n+\n+      if Raised then\n+         Reraise_Occurrence (Ex_Occur);\n+      end if;\n+   end Finalize;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   overriding procedure Initialize\n+     (Collection : in out Finalization_Collection)\n+   is\n+   begin\n+      Collection.Objects := new Node;\n+\n+      --  The dummy head must point to itself in both directions\n+\n+      Collection.Objects.Next := Collection.Objects;\n+      Collection.Objects.Prev := Collection.Objects;\n+   end Initialize;\n+\n+   ----------\n+   -- pcol --\n+   ----------\n+\n+   procedure pcol (Collection : Finalization_Collection) is\n+      Head_Seen : Boolean := False;\n+      N_Ptr     : Node_Ptr;\n+\n+   begin\n+      --  Output the basic contents of the collection\n+\n+      --    Collection: 0x123456789\n+      --    Base_Pool : null <or> 0x123456789\n+      --    Fin_Addr  : null <or> 0x123456789\n+      --    Fin_Start : TRUE <or> FALSE\n+\n+      Put (\"Collection: \");\n+      Put_Line (Address_Image (Collection'Address));\n+\n+      Put (\"Base_Pool : \");\n+      if Collection.Base_Pool = null then\n+         Put_Line (\" null\");\n+      else\n+         Put_Line (Address_Image (Collection.Base_Pool'Address));\n+      end if;\n+\n+      Put (\"Fin_Addr  : \");\n+      if Collection.Finalize_Address = null then\n+         Put_Line (\"null\");\n+      else\n+         Put_Line (Address_Image (Collection.Finalize_Address'Address));\n+      end if;\n+\n+      Put (\"Fin_Start : \");\n+      Put_Line (Collection.Finalization_Started'Img);\n+\n+      --  Output all chained elements. The format is the following:\n+\n+      --    ^ <or> ? <or> null\n+      --    |Header: 0x123456789 (dummy head)\n+      --    |  Prev: 0x123456789\n+      --    |  Next: 0x123456789\n+      --    V\n+\n+      --  ^ - the current element points back to the correct element\n+      --  ? - the current element points back to an erroneous element\n+      --  n - the current element points back to null\n+\n+      --  Header - the address of the list header\n+      --  Prev   - the address of the list header which the current element\n+      --         - points back to\n+      --  Next   - the address of the list header which the current element\n+      --         - points to\n+      --  (dummy head) - present if dummy head\n+\n+      N_Ptr := Collection.Objects;\n+\n+      while N_Ptr /= null loop\n+         Put_Line (\"V\");\n+\n+         --  The current node is the head. If we have already traversed the\n+         --  chain, the head will be encountered again since the chain is\n+         --  circular.\n+\n+         if N_Ptr = Collection.Objects then\n+            if Head_Seen then\n+               exit;\n+            else\n+               Head_Seen := True;\n+            end if;\n+         end if;\n+\n+         --  The current element points back to null. This should never happen\n+         --  since the list is circular.\n+\n+         if N_Ptr.Prev = null then\n+            Put_Line (\"null (ERROR)\");\n+\n+         --  The current element points back to the correct element\n+\n+         elsif N_Ptr.Prev.Next = N_Ptr then\n+            Put_Line (\"^\");\n+\n+         --  The current element points back to an erroneous element\n+\n+         else\n+            Put_Line (\"? (ERROR)\");\n+         end if;\n+\n+         --  Output the header and fields\n+\n+         Put (\"|Header: \");\n+         Put (Address_Image (N_Ptr.all'Address));\n+\n+         --  Detect the dummy head\n+\n+         if N_Ptr = Collection.Objects then\n+            Put_Line (\" (dummy head)\");\n+         else\n+            Put_Line (\"\");\n+         end if;\n+\n+         Put (\"|  Prev: \");\n+         if N_Ptr.Prev = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (N_Ptr.Prev.all'Address));\n+         end if;\n+\n+         Put (\"|  Next: \");\n+         if N_Ptr.Next = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (N_Ptr.Next.all'Address));\n+         end if;\n+\n+         N_Ptr := N_Ptr.Next;\n+      end loop;\n+   end pcol;\n+\n+   ------------------------------\n+   -- Set_Finalize_Address_Ptr --\n+   ------------------------------\n+\n+   procedure Set_Finalize_Address_Ptr\n+     (Collection : in out Finalization_Collection;\n+      Proc_Ptr   : Finalize_Address_Ptr)\n+   is\n+   begin\n+      Collection.Finalize_Address := Proc_Ptr;\n+   end Set_Finalize_Address_Ptr;\n+\n+   --------------------------\n+   -- Set_Storage_Pool_Ptr --\n+   --------------------------\n+\n+   procedure Set_Storage_Pool_Ptr\n+     (Collection : in out Finalization_Collection;\n+      Pool_Ptr   : Any_Storage_Pool_Ptr)\n+   is\n+   begin\n+      Collection.Base_Pool := Pool_Ptr;\n+   end Set_Storage_Pool_Ptr;\n+\n+end Ada.Finalization.Heap_Management;"}, {"sha": "028d77189a2295247b17d750b39b99f4fe91a7f7", "filename": "gcc/ada/a-fihema.ads", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-fihema.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-fihema.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -0,0 +1,150 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--     A D A . F I N A L I Z A T I O N . H E A P _ M A N A G E M E N T      --\n+--                                                                          --\n+--                                S p e c                                   --\n+--                                                                          --\n+--          Copyright (C) 2008-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with System.Storage_Elements;\n+with System.Storage_Pools;\n+\n+package Ada.Finalization.Heap_Management is\n+\n+   --  A reference to any derivation of Root_Storage_Pool. Since this type may\n+   --  not be used to allocate objects, its storage size is zero.\n+\n+   type Any_Storage_Pool_Ptr is\n+     access System.Storage_Pools.Root_Storage_Pool'Class;\n+   for Any_Storage_Pool_Ptr'Storage_Size use 0;\n+\n+   --  ??? Comment needed on overall mechanism\n+\n+   type Finalization_Collection is\n+     new Ada.Finalization.Limited_Controlled with private;\n+\n+   type Finalization_Collection_Ptr is access all Finalization_Collection;\n+   for Finalization_Collection_Ptr'Storage_Size use 0;\n+\n+   --  A reference used to describe primitive Finalize_Address\n+\n+   type Finalize_Address_Ptr is access procedure (Obj : System.Address);\n+\n+   --  Since RTSfind cannot contain names of the form RE_\"+\", the following\n+   --  routine serves as a wrapper around System.Storage_Elements.\"+\".\n+\n+   function Add_Offset_To_Address\n+     (Addr   : System.Address;\n+      Offset : System.Storage_Elements.Storage_Offset) return System.Address;\n+\n+   procedure Allocate\n+     (Collection   : in out Finalization_Collection;\n+      Addr         : out System.Address;\n+      Storage_Size : System.Storage_Elements.Storage_Count;\n+      Alignment    : System.Storage_Elements.Storage_Count;\n+      Needs_Header : Boolean := True);\n+   --  Allocate a chunk of memory described by Storage_Size and Alignment on\n+   --  Collection's underlying storage pool. Return the address of the chunk.\n+   --  The routine creates a list header which precedes the chunk of memory is\n+   --  flag Needs_Header is set. If allocated, the header is attached to the\n+   --  Collection's objects. The interface to this routine is provided by\n+   --  Build_Allocate_Deallocate_Proc.\n+\n+   function Base_Pool\n+     (Collection : Finalization_Collection) return Any_Storage_Pool_Ptr;\n+   --  Return a reference to the underlying storage pool of Collection\n+\n+   procedure Deallocate\n+     (Collection   : in out Finalization_Collection;\n+      Addr         : System.Address;\n+      Storage_Size : System.Storage_Elements.Storage_Count;\n+      Alignment    : System.Storage_Elements.Storage_Count;\n+      Has_Header   : Boolean := True);\n+   --  Deallocate a chunk of memory described by Storage_Size and Alignment\n+   --  from Collection's underlying storage pool. The beginning of the memory\n+   --  chunk is designated by Addr. The routine detaches and destroys the\n+   --  preceding list header if flag Has_Header is set. The interface to this\n+   --  routine is provided by Build_Allocate_Deallocate_Proc.\n+\n+   overriding procedure Finalize\n+     (Collection : in out Finalization_Collection);\n+   --  Traverse the objects of Collection, invoking Finalize_Address on eanch\n+   --  of them. In the end, the routine destroys its dummy head and tail.\n+\n+   overriding procedure Initialize\n+     (Collection : in out Finalization_Collection);\n+   --  Create a new Collection by allocating a dummy head and tal\n+\n+   procedure Set_Finalize_Address_Ptr\n+     (Collection : in out Finalization_Collection;\n+      Proc_Ptr   : Finalize_Address_Ptr);\n+   --  Set the finalization address routine of a finalization collection\n+\n+   procedure Set_Storage_Pool_Ptr\n+     (Collection : in out Finalization_Collection;\n+      Pool_Ptr   : Any_Storage_Pool_Ptr);\n+   --  Set the underlying storage pool of a finalization collection\n+\n+private\n+   --  Homogeneous collection types\n+\n+   type Node;\n+   type Node_Ptr is access all Node;\n+   pragma No_Strict_Aliasing (Node_Ptr);\n+\n+   type Node is record\n+      Prev : Node_Ptr;\n+      Next : Node_Ptr;\n+   end record;\n+\n+   type Finalization_Collection is\n+     new Ada.Finalization.Limited_Controlled with\n+   record\n+      Base_Pool : Any_Storage_Pool_Ptr;\n+      --  All objects and node headers are allocated on this underlying pool,\n+      --  the collection is simply a wrapper around it.\n+\n+      Objects : Node_Ptr;\n+      --  The head of a doubly linked list\n+\n+      Finalize_Address : Finalize_Address_Ptr;\n+      --  A reference to a routine which finalizes an object denoted by its\n+      --  address. The collection must be homogenious since the same routine\n+      --  will be invoked for every allocated object when the pool is\n+      --  finalized.\n+\n+      Finalization_Started : Boolean := False;\n+      --  When the finalization of a collection takes place, any allocations on\n+      --  the same collection are prohibited and the action must raise Program_\n+      --  Error.\n+   end record;\n+\n+   procedure pcol (Collection : Finalization_Collection);\n+   --  Output the contents of a collection in a readable form. Intended for\n+   --  debugging purposes.\n+\n+end Ada.Finalization.Heap_Management;"}, {"sha": "f6bd78dd23eb5ace66775ea72a4b97385699ca36", "filename": "gcc/ada/a-filico.adb", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de29d8500c2f9f5f164032ae5c3a5477dcc45c51/gcc%2Fada%2Fa-filico.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de29d8500c2f9f5f164032ae5c3a5477dcc45c51/gcc%2Fada%2Fa-filico.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-filico.adb?ref=de29d8500c2f9f5f164032ae5c3a5477dcc45c51", "patch": "@@ -1,80 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---     A D A . F I N A L I Z A T I O N . L I S T _ C O N T R O L L E R      --\n---                                                                          --\n---                                B o d y                                   --\n---                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with System.Finalization_Implementation;\n-package body Ada.Finalization.List_Controller is\n-\n-   package SFI renames System.Finalization_Implementation;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (Object : in out List_Controller) is\n-      use type SFR.Finalizable_Ptr;\n-\n-      Last_Ptr : constant SFR.Finalizable_Ptr := Object.Last'Unchecked_Access;\n-\n-   begin\n-      --  First take note of the fact that finalization of this collection has\n-      --  started.\n-\n-      Object.F := SFI.Collection_Finalization_Started;\n-\n-      --  Then finalize all the objects. Note that finalization can call\n-      --  Unchecked_Deallocation on other objects in the same collection,\n-      --  which will cause them to be removed from the list if we have not\n-      --  gotten to them yet. However, allocation in the collection will raise\n-      --  Program_Error, due to the above Collection_Finalization_Started.\n-\n-      while Object.First.Next /= Last_Ptr loop\n-         SFI.Finalize_One (Object.First.Next.all);\n-      end loop;\n-   end Finalize;\n-\n-   procedure Finalize (Object : in out Simple_List_Controller) is\n-   begin\n-      SFI.Finalize_List (Object.F);\n-      Object.F := null;\n-   end Finalize;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Object : in out List_Controller) is\n-   begin\n-      Object.F          := Object.First'Unchecked_Access;\n-      Object.First.Next := Object.Last 'Unchecked_Access;\n-      Object.Last.Prev  := Object.First'Unchecked_Access;\n-   end Initialize;\n-\n-end Ada.Finalization.List_Controller;"}, {"sha": "566d0dfd10989015fb5a2ec70d87ec5a4cc31020", "filename": "gcc/ada/a-filico.ads", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de29d8500c2f9f5f164032ae5c3a5477dcc45c51/gcc%2Fada%2Fa-filico.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de29d8500c2f9f5f164032ae5c3a5477dcc45c51/gcc%2Fada%2Fa-filico.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-filico.ads?ref=de29d8500c2f9f5f164032ae5c3a5477dcc45c51", "patch": "@@ -1,102 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---     A D A . F I N A L I Z A T I O N . L I S T _ C O N T R O L L E R      --\n---                                                                          --\n---                                S p e c                                   --\n---                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with System.Finalization_Root;\n-\n-package Ada.Finalization.List_Controller is\n-   pragma Elaborate_Body;\n-\n-   package SFR renames System.Finalization_Root;\n-\n-   ----------------------------\n-   -- Simple_List_Controller --\n-   ----------------------------\n-\n-   type Simple_List_Controller is new Ada.Finalization.Limited_Controlled\n-     with record\n-        F : SFR.Finalizable_Ptr;\n-     end record;\n-      --  Used by the compiler to carry a list of temporary objects that\n-      --  needs to be finalized after having being used. This list is\n-      --  embedded in a controlled type so that if an exception is raised\n-      --  while those temporaries are still in use, they will be reclaimed\n-      --  by the normal finalization mechanism.\n-\n-   overriding procedure Finalize (Object : in out Simple_List_Controller);\n-\n-   ---------------------\n-   -- List_Controller --\n-   ---------------------\n-\n-   --  Management of a bidirectional linked heterogeneous list of\n-   --  dynamically Allocated objects. To simplify the management of the\n-   --  linked list, the First and Last elements are statically part of the\n-   --  original List controller:\n-   --\n-   --        +------------+\n-   --        |          --|-->--\n-   --        +------------+\n-   --        |--<--       |                      record with ctrl components\n-   --        |------------|                         +----------+\n-   --     +--|--   L      |                         |          |\n-   --     |  |------------|                         |          |\n-   --     |  |+--------+  |       +--------+        |+--------+|\n-   --     +->||  prev  | F|---<---|--      |----<---||--      ||--<--+\n-   --        ||--------| i|       |--------|        ||--------||     |\n-   --        || next   | r|--->---|      --|---->---||      --||--------+\n-   --        |+--------+ s|       |--------|        ||--------||     |  |\n-   --        |           t|       | ctrl   |        ||        ||     |  |\n-   --        |            |       :        :        |+--------+|     |  |\n-   --        |            |       : object :        |rec       |     |  |\n-   --        |            |       :        :        |controller|     |  |\n-   --        |            |       |        |        |          |     |  v\n-   --        |+--------+  |       +--------+        +----------+     |  |\n-   --        ||  prev -|-L|--------------------->--------------------+  |\n-   --        ||--------| a|                                             |\n-   --        || next   | s|-------------------<-------------------------+\n-   --        |+--------+ t|\n-   --        |            |\n-   --        +------------+\n-\n-   type List_Controller is new Ada.Finalization.Limited_Controlled\n-     with record\n-        F    :  SFR.Finalizable_Ptr;\n-        First,\n-        Last : aliased SFR.Root_Controlled;\n-     end record;\n-   --  Controls the chains of dynamically allocated controlled\n-   --  objects makes sure that they get finalized upon exit from\n-   --  the access type that defined them\n-\n-   overriding procedure Initialize (Object : in out List_Controller);\n-   overriding procedure Finalize   (Object : in out List_Controller);\n-\n-end Ada.Finalization.List_Controller;"}, {"sha": "dc2cdf78891e73eec21afa24d15784399130ddef", "filename": "gcc/ada/a-finali.adb", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-finali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-finali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-finali.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,19 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Finalization_Root; use System.Finalization_Root;\n-\n package body Ada.Finalization is\n \n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   overriding function \"=\" (A, B : Controlled) return Boolean is\n-   begin\n-      return Empty_Root_Controlled (A) = Empty_Root_Controlled (B);\n-   end \"=\";\n-\n    ------------\n    -- Adjust --\n    ------------"}, {"sha": "d5cada210e20800098d9d0b00219d5b58e7c6768", "filename": "gcc/ada/a-finali.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-finali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-finali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-finali.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -61,9 +61,9 @@ private\n \n    type Controlled is abstract new SFR.Root_Controlled with null record;\n \n-   overriding function \"=\" (A, B : Controlled) return Boolean;\n-   --  Need to be defined explicitly because we don't want to compare the\n-   --  hidden pointers.\n+   --  In order to simplify the implementation, the mechanism in Process_Full_\n+   --  View ensures that the full view is limited even though the parent type\n+   --  is not.\n \n    type Limited_Controlled is\n      abstract new SFR.Root_Controlled with null record;"}, {"sha": "3473b4d5f993487946ec061edd33a41229b5cd05", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -529,19 +529,6 @@ package body Ada.Tags is\n       end if;\n    end Get_Offset_Index;\n \n-   -------------------\n-   -- Get_RC_Offset --\n-   -------------------\n-\n-   function Get_RC_Offset (T : Tag) return SSE.Storage_Offset is\n-      TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n-      TSD     : constant Type_Specific_Data_Ptr :=\n-                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n-   begin\n-      return TSD.RC_Offset;\n-   end Get_RC_Offset;\n-\n    ---------------------\n    -- Get_Tagged_Kind --\n    ---------------------\n@@ -769,6 +756,19 @@ package body Ada.Tags is\n       end if;\n    end Offset_To_Top;\n \n+   ------------------------\n+   -- Needs_Finalization --\n+   ------------------------\n+\n+   function Needs_Finalization (T : Tag) return Boolean is\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD     : constant Type_Specific_Data_Ptr :=\n+                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+   begin\n+      return TSD.Needs_Finalization;\n+   end Needs_Finalization;\n+\n    -----------------\n    -- Parent_Size --\n    -----------------"}, {"sha": "99ee5aa1aecb7792d365f5c7fb22182b263609b4", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -108,7 +108,7 @@ private\n    --                                    +-------------------+\n    --                                    |  type_is_abstract |\n    --                                    +-------------------+\n-   --                                    | rec ctrler offset |\n+   --                                    | needs finalization|\n    --                                    +-------------------+\n    --                                    |   Ifaces_Table   ---> Interface Data\n    --                                    +-------------------+   +------------+\n@@ -288,9 +288,8 @@ private\n       Type_Is_Abstract : Boolean;\n       --  True if the type is abstract (Ada 2012: AI05-0173)\n \n-      RC_Offset : SSE.Storage_Offset;\n-      --  Controller Offset: Used to give support to tagged controlled objects\n-      --  (see Get_Deep_Controller at s-finimp)\n+      Needs_Finalization : Boolean;\n+      --  Used to dynamically check whether an object is controlled or not\n \n       Size_Func : Size_Ptr;\n       --  Pointer to the subprogram computing the _size of the object. Used by\n@@ -455,15 +454,6 @@ private\n    --  Ada 2005 (AI-251): Return a primitive operation's kind given a dispatch\n    --  table T and a position of a primitive operation in T.\n \n-   function Get_RC_Offset (T : Tag) return SSE.Storage_Offset;\n-   --  Return the Offset of the implicit record controller when the object\n-   --  has controlled components, returns zero if no controlled components.\n-\n-   pragma Export (Ada, Get_RC_Offset, \"ada__tags__get_rc_offset\");\n-   --  This procedure is used in s-finimp to compute the deep routines. It is\n-   --  exported manually in order to avoid completely changing the organization\n-   --  of the run time.\n-\n    function Get_Tagged_Kind (T : Tag) return Tagged_Kind;\n    --  Ada 2005 (AI-345): Given a pointer to either a primary or a secondary\n    --  dispatch table, return the tagged kind of a type in the context of\n@@ -490,6 +480,11 @@ private\n    --  of the tagged type has discriminants this value is stored in a record\n    --  component just immediately after the tag component.\n \n+   function Needs_Finalization (T : Tag) return Boolean;\n+   --  A helper routine used in conjunction with finalization collections which\n+   --  service class-wide types. The function dynamically determines whether an\n+   --  object is controlled or has controlled components.\n+\n    function Parent_Size\n      (Obj : System.Address;\n       T   : Tag) return SSE.Storage_Count;"}, {"sha": "e998aeee0aa7fdd377b876a4c9c840c40aa24469", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -1443,6 +1443,7 @@ package body ALI is\n             UL.Body_Needed_For_SAL      := False;\n             UL.Elaborate_Body_Desirable := False;\n             UL.Optimize_Alignment       := 'O';\n+            UL.Has_Finalizer            := False;\n \n             if Debug_Flag_U then\n                Write_Str (\" ----> reading unit \");\n@@ -1628,12 +1629,14 @@ package body ALI is\n                   Fatal_Error_Ignore;\n                end if;\n \n-            --  PR/PU/PK parameters\n+            --  PF/PR/PU/PK parameters\n \n             elsif C = 'P' then\n                C := Getc;\n \n-               if C = 'R' then\n+               if C = 'F' then\n+                  Units.Table (Units.Last).Has_Finalizer := True;\n+               elsif C = 'R' then\n                   Units.Table (Units.Last).Preelab := True;\n                elsif C = 'U' then\n                   Units.Table (Units.Last).Pure := True;"}, {"sha": "0a808179fde7c3048d53faf14adaa43c032d0878", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,8 +24,8 @@\n ------------------------------------------------------------------------------\n \n --  This package defines the internal data structures used for representation\n---  of Ada Library Information (ALI) acquired from the ALI files generated\n---  by the front end.\n+--  of Ada Library Information (ALI) acquired from the ALI files generated by\n+--  the front end.\n \n with Casing;  use Casing;\n with Gnatvsn; use Gnatvsn;\n@@ -372,6 +372,9 @@ package ALI is\n       Optimize_Alignment : Character;\n       --  Optimize_Alignment setting. Set to L/S/T/O for OL/OS/OT/OO present\n \n+      Has_Finalizer : Boolean;\n+      --  Indicates whether a package body or a spec has a library-level\n+      --  finalization routine.\n    end record;\n \n    package Units is new Table.Table ("}, {"sha": "0df415d859f7fcc89a477e7d2a4fb003be36170e", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2552,6 +2552,17 @@ package body Atree is\n          end if;\n       end Elist23;\n \n+      function Elist24 (N : Node_Id) return Elist_Id is\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Value : constant Union_Id := Nodes.Table (N + 4).Field6;\n+      begin\n+         if Value = 0 then\n+            return No_Elist;\n+         else\n+            return Elist_Id (Value);\n+         end if;\n+      end Elist24;\n+\n       function Elist25 (N : Node_Id) return Elist_Id is\n          pragma Assert (Nkind (N) in N_Entity);\n          Value : constant Union_Id := Nodes.Table (N + 4).Field7;\n@@ -4756,6 +4767,12 @@ package body Atree is\n          Nodes.Table (N + 3).Field10 := Union_Id (Val);\n       end Set_Elist23;\n \n+      procedure Set_Elist24 (N : Node_Id; Val : Elist_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 4).Field6 := Union_Id (Val);\n+      end Set_Elist24;\n+\n       procedure Set_Elist25 (N : Node_Id; Val : Elist_Id) is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);"}, {"sha": "6538a19cf6c35f4e2fccc2cd1af2135e91dc574d", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1138,6 +1138,9 @@ package Atree is\n       function Elist23 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist23);\n \n+      function Elist24 (N : Node_Id) return Elist_Id;\n+      pragma Inline (Elist24);\n+\n       function Elist25 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist25);\n \n@@ -2207,6 +2210,9 @@ package Atree is\n       procedure Set_Elist23 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist23);\n \n+      procedure Set_Elist24 (N : Node_Id; Val : Elist_Id);\n+      pragma Inline (Set_Elist24);\n+\n       procedure Set_Elist25 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist25);\n "}, {"sha": "31df7e9c54ff755011974d35875d0f3c0c827868", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -440,6 +440,7 @@ extern Node_Id Current_Error_Node;\n #define Elist18(N)    Field18 (N)\n #define Elist21(N)    Field21 (N)\n #define Elist23(N)    Field23 (N)\n+#define Elist24(N)    Field24 (N)\n #define Elist25(N)    Field25 (N)\n #define Elist26(N)    Field26 (N)\n "}, {"sha": "eeec4708bc0dae4ee115606f573a1185970bc69b", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 473, "deletions": 75, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,6 +71,8 @@ package body Bindgen is\n    --  to do this unconditionally, since it drags in the System.Restrictions\n    --  unit unconditionally, which is unpleasand, especially for ZFP etc.)\n \n+   Lib_Final_Built : Boolean := False;\n+\n    ----------------------------------\n    -- Interface_State Pragma Table --\n    ----------------------------------\n@@ -249,14 +251,23 @@ package body Bindgen is\n    --  Generate sequence of elaboration calls (C code case)\n \n    procedure Gen_Elab_Order_Ada;\n-   --  Generate comments showing elaboration order chosen (Ada case)\n+   --  Generate comments showing elaboration order chosen (Ada code case)\n \n    procedure Gen_Elab_Order_C;\n-   --  Generate comments showing elaboration order chosen (C case)\n+   --  Generate comments showing elaboration order chosen (C code case)\n \n    procedure Gen_Elab_Defs_C;\n    --  Generate sequence of definitions for elaboration routines (C code case)\n \n+   procedure Gen_Finalize_Library_Ada;\n+   --  Generate a sequence of finalization calls to elaborated packages (Ada)\n+\n+   procedure Gen_Finalize_Library_C;\n+   --  Generate a sequence of finalization calls to elaborated packages (C)\n+\n+   procedure Gen_Finalize_Library_Defs_C;\n+   --  Generate a sequence of defininitions for package finalizers (C case)\n+\n    procedure Gen_Main_Ada;\n    --  Generate procedure main (Ada code case)\n \n@@ -309,6 +320,10 @@ package body Bindgen is\n    --  the encoding method used for the main program source. If there is no\n    --  main program source (-z switch used), returns brackets ('b').\n \n+   function Has_Finalizer return Boolean;\n+   --  Determine whether the current unit has at least one library-level\n+   --  finalizer.\n+\n    function Lt_Linker_Option (Op1, Op2 : Natural) return Boolean;\n    --  Compare linker options, when sorting, first according to\n    --  Is_Internal_File (internal files come later) and then by\n@@ -358,10 +373,13 @@ package body Bindgen is\n    --  the characters of S. The caller must ensure that these characters do\n    --  in fact exist in the Statement_Buffer.\n \n-   procedure Set_Unit_Name;\n-   --  Given a unit name in the Name_Buffer, copies it to Statement_Buffer,\n-   --  starting at the Last + 1 position, and updating last past the value.\n-   --  changing periods to double underscores, and updating Last appropriately.\n+   type Qualification_Mode is (Dollar_Sign, Dot, Double_Underscores);\n+\n+   procedure Set_Unit_Name (Mode : Qualification_Mode := Double_Underscores);\n+   --  Given a unit name in the Name_Buffer, copy it into Statement_Buffer,\n+   --  starting at the Last + 1 position and update Last past the value.\n+   --  Depending on parameter Mode, a dot (.) can be qualified into double\n+   --  underscores (__), a dollar sign ($) or left as is.\n \n    procedure Set_Unit_Number (U : Unit_Id);\n    --  Sets unit number (first unit is 1, leading zeroes output to line\n@@ -401,25 +419,33 @@ package body Bindgen is\n \n    procedure Gen_Adafinal_Ada is\n    begin\n-      WBI (\"\");\n       WBI (\"   procedure \" & Ada_Final_Name.all & \" is\");\n-      WBI (\"   begin\");\n \n-      --  If compiling for the JVM, we directly call Adafinal because\n-      --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n+      --  Do nothing if finalization is disabled\n \n-      if VM_Target /= No_VM then\n-         WBI (\"      System.Standard_Library.Adafinal;\");\n+      if Cumulative_Restrictions.Set (No_Finalization) then\n+         WBI (\"   begin\");\n+         WBI (\"      null;\");\n \n-      --  If there is no finalization, there is nothing to do\n+      --  General case\n+\n+      elsif VM_Target = No_VM then\n+         WBI (\"      procedure s_stalib_adafinal;\");\n+         WBI (\"      pragma Import (C, s_stalib_adafinal, \" &\n+              \"\"\"system__standard_library__adafinal\"\");\");\n+         WBI (\"   begin\");\n+         WBI (\"      s_stalib_adafinal;\");\n+\n+      --  Pragma Import C cannot be used on virtual machine targets, therefore\n+      --  call the runtime finalization routine directly.\n \n-      elsif Cumulative_Restrictions.Set (No_Finalization) then\n-         WBI (\"      null;\");\n       else\n-         WBI (\"      Do_Finalize;\");\n+         WBI (\"   begin\");\n+         WBI (\"      System.Standard_Library.Adafinal;\");\n       end if;\n \n       WBI (\"   end \" & Ada_Final_Name.all & \";\");\n+      WBI (\"\");\n    end Gen_Adafinal_Ada;\n \n    --------------------\n@@ -638,6 +664,18 @@ package body Bindgen is\n          WBI (\"      pragma Import (C, Handler_Installed, \" &\n               \"\"\"__gnat_handler_installed\"\");\");\n \n+         --  The import of the soft link which performs library-level object\n+         --  finalization is not needed for VM targets. Regular Ada is used in\n+         --  that case.\n+\n+         if VM_Target = No_VM then\n+            WBI (\"\");\n+            WBI (\"      type No_Param_Proc is access procedure;\");\n+            WBI (\"      Finalize_Library_Objects : No_Param_Proc;\");\n+            WBI (\"      pragma Import (C, Finalize_Library_Objects, \" &\n+                 \"\"\"__gnat_finalize_library_objects\"\");\");\n+         end if;\n+\n          --  Import entry point for environment feature enable/disable\n          --  routine, and indication that it's been called previously.\n \n@@ -888,6 +926,34 @@ package body Bindgen is\n          WBI (\"      Initialize_Stack_Limit;\");\n       end if;\n \n+      --  Attach Finalize_Library to the right softlink\n+\n+      if not Suppress_Standard_Library_On_Target then\n+         WBI (\"\");\n+\n+         if VM_Target = No_VM then\n+            if Lib_Final_Built then\n+               Set_String (\"      Finalize_Library_Objects := \");\n+               Set_String (\"Finalize_Library'access;\");\n+            else\n+               Set_String (\"      Finalize_Library_Objects := null;\");\n+            end if;\n+\n+         --  On VM targets use regular Ada to set the soft link\n+\n+         else\n+            if Lib_Final_Built then\n+               Set_String (\"      System.Soft_Links.Finalize_Library_Objects\");\n+               Set_String (\" := Finalize_Library'access;\");\n+            else\n+               Set_String (\"      System.Soft_Links.Finalize_Library_Objects\");\n+               Set_String (\" := null;\");\n+            end if;\n+         end if;\n+\n+         Write_Statement_Buffer;\n+      end if;\n+\n       --  Generate elaboration calls\n \n       WBI (\"\");\n@@ -913,6 +979,7 @@ package body Bindgen is\n       end if;\n \n       WBI (\"   end \" & Ada_Init_Name.all & \";\");\n+      WBI (\"\");\n    end Gen_Adainit_Ada;\n \n    -------------------\n@@ -1200,6 +1267,7 @@ package body Bindgen is\n       WBI (\"\");\n       Gen_Elab_Calls_C;\n       WBI (\"}\");\n+      WBI (\"\");\n    end Gen_Adainit_C;\n \n    ------------------------\n@@ -1450,6 +1518,8 @@ package body Bindgen is\n \n    procedure Gen_Elab_Defs_C is\n    begin\n+      WBI (\"/* BEGIN ELABORATION DEFINITIONS */\");\n+\n       for E in Elab_Order.First .. Elab_Order.Last loop\n \n          --  Generate declaration of elaboration procedure if elaboration\n@@ -1464,9 +1534,7 @@ package body Bindgen is\n             Set_String (\" (void);\");\n             Write_Statement_Buffer;\n          end if;\n-\n       end loop;\n-\n       WBI (\"\");\n    end Gen_Elab_Defs_C;\n \n@@ -1476,7 +1544,6 @@ package body Bindgen is\n \n    procedure Gen_Elab_Order_Ada is\n    begin\n-      WBI (\"\");\n       WBI (\"   --  BEGIN ELABORATION ORDER\");\n \n       for J in Elab_Order.First .. Elab_Order.Last loop\n@@ -1487,6 +1554,7 @@ package body Bindgen is\n       end loop;\n \n       WBI (\"   --  END ELABORATION ORDER\");\n+      WBI (\"\");\n    end Gen_Elab_Order_Ada;\n \n    ----------------------\n@@ -1495,7 +1563,6 @@ package body Bindgen is\n \n    procedure Gen_Elab_Order_C is\n    begin\n-      WBI (\"\");\n       WBI (\"/* BEGIN ELABORATION ORDER\");\n \n       for J in Elab_Order.First .. Elab_Order.Last loop\n@@ -1505,16 +1572,319 @@ package body Bindgen is\n       end loop;\n \n       WBI (\"   END ELABORATION ORDER */\");\n+      WBI (\"\");\n    end Gen_Elab_Order_C;\n \n+   ------------------------------\n+   -- Gen_Finalize_Library_Ada --\n+   ------------------------------\n+\n+   procedure Gen_Finalize_Library_Ada is\n+      Count : Int := 1;\n+      U     : Unit_Record;\n+      Uspec : Unit_Record;\n+      Unum  : Unit_Id;\n+\n+   begin\n+      for E in reverse Elab_Order.First .. Elab_Order.Last loop\n+         Unum := Elab_Order.Table (E);\n+         U    := Units.Table (Unum);\n+\n+         --  We are only interested in non-generic packages\n+\n+         if U.Unit_Kind = 'p'\n+           and then U.Has_Finalizer\n+           and then not U.Is_Generic\n+           and then not U.No_Elab\n+         then\n+            if not Lib_Final_Built then\n+               Lib_Final_Built := True;\n+\n+               WBI (\"   procedure Finalize_Library is\");\n+\n+               --  The following flag is used to check for library-level\n+               --  exceptions raised during finalization. The symbol comes\n+               --  from System.Soft_Links. VM targets use regular Ada to\n+               --  reference the entity.\n+\n+               if VM_Target = No_VM then\n+                  WBI (\"      LE_Set : Boolean;\");\n+\n+                  Set_String (\"      pragma Import (Ada, LE_Set, \");\n+                  Set_String (\"\"\"__gnat_library_exception_set\"\");\");\n+                  Write_Statement_Buffer;\n+               end if;\n+\n+               WBI (\"   begin\");\n+            end if;\n+\n+            --  Generate:\n+            --    declare\n+            --       procedure F<Count>;\n+\n+            Set_String (\"      declare\");\n+            Write_Statement_Buffer;\n+\n+            Set_String (\"         procedure F\");\n+            Set_Int    (Count);\n+            Set_Char   (';');\n+            Write_Statement_Buffer;\n+\n+            --  Generate:\n+            --    pragma Import (CIL, F<Count>, \"xx.yy_pkg.Finalize[B/S]\");\n+            --    --  for .NET targets\n+\n+            --    pragma Import (Java, F<Count>, \"xx$yy.Finalize[B/S]\");\n+            --    --  for JVM targets\n+\n+            --    pragma Import (Ada, F<Count>, \"xx__yy__Finalize[B/S]\");\n+            --    --  for default targets\n+\n+            if VM_Target = CLI_Target then\n+               Set_String (\"         pragma Import (CIL, F\");\n+            elsif VM_Target = JVM_Target then\n+               Set_String (\"         pragma Import (Java, F\");\n+            else\n+               Set_String (\"         pragma Import (Ada, F\");\n+            end if;\n+\n+            Set_Int (Count);\n+            Set_String (\", \"\"\");\n+\n+            --  Dealing with package bodies is a little complicated. In such\n+            --  cases we must retrieve the package spec since it contains the\n+            --  spec of the body finalizer.\n+\n+            if U.Utype = Is_Body then\n+               Unum  := Unum + 1;\n+               Uspec := Units.Table (Unum);\n+            else\n+               Uspec := U;\n+            end if;\n+\n+            Get_Name_String (Uspec.Uname);\n+\n+            --  Perform name construction\n+\n+            --  .NET   xx.yy_pkg.finalize\n+\n+            if VM_Target = CLI_Target then\n+               Set_Unit_Name (Mode => Dot);\n+               Set_String (\"_pkg.finalize\");\n+\n+            --  JVM   xx$yy.finalize\n+\n+            elsif VM_Target = JVM_Target then\n+               Set_Unit_Name (Mode => Dollar_Sign);\n+               Set_String (\".finalize\");\n+\n+            --  Default   xx__yy__finalize\n+\n+            else\n+               Set_Unit_Name;\n+               Set_String (\"__finalize\");\n+            end if;\n+\n+            --  Package spec processing\n+\n+            if U.Utype = Is_Spec\n+              or else U.Utype = Is_Spec_Only\n+            then\n+               Set_Char ('S');\n+\n+            --  Package body processing\n+\n+            else\n+               Set_Char ('B');\n+            end if;\n+\n+            Set_String (\"\"\");\");\n+            Write_Statement_Buffer;\n+\n+            WBI (\"      begin\");\n+\n+            --  Generate:\n+            --       F<Count>;\n+            --    end;\n+\n+            Set_String (\"         F\");\n+            Set_Int    (Count);\n+            Set_Char   (';');\n+            Write_Statement_Buffer;\n+            WBI (\"      end;\");\n+\n+            Count := Count + 1;\n+         end if;\n+      end loop;\n+\n+      if Lib_Final_Built then\n+\n+         --  It is possible that the finalization of a library-level object\n+         --  raised an exception. In that case import the actual exception\n+         --  and the routine necessary to raise it.\n+\n+         if VM_Target = No_VM then\n+            WBI (\"      if LE_Set then\");\n+            WBI (\"         declare\");\n+            WBI (\"            LE : Ada.Exceptions.Exception_Occurrence;\");\n+\n+            Set_String (\"            pragma Import (Ada, LE, \");\n+            Set_String (\"\"\"__gnat_library_exception\"\");\");\n+            Write_Statement_Buffer;\n+\n+            Set_String (\"            procedure Raise_Controlled \");\n+            Set_String (\"(E : Ada.Exceptions.Exception_Occurrence);\");\n+            Write_Statement_Buffer;\n+\n+            Set_String (\"            pragma Import (Ada, Raise_Controlled, \");\n+            Set_String (\"\"\"__gnat_raise_from_controlled_operation\"\");\");\n+            Write_Statement_Buffer;\n+\n+            WBI (\"         begin\");\n+            WBI (\"            Raise_Controlled (LE);\");\n+            WBI (\"         end;\");\n+\n+         --  VM-specific code, use regular Ada to produce the desired behavior\n+\n+         else\n+            WBI (\"      if System.Soft_Links.Library_Exception_Set then\");\n+\n+            Set_String (\"         Ada.Exceptions.Reraise_Occurrence (\");\n+            Set_String (\"System.Soft_Links.Library_Exception);\");\n+            Write_Statement_Buffer;\n+         end if;\n+\n+         WBI (\"      end if;\");\n+         WBI (\"   end Finalize_Library;\");\n+         WBI (\"\");\n+      end if;\n+   end Gen_Finalize_Library_Ada;\n+\n+   ----------------------------\n+   -- Gen_Finalize_Library_C --\n+   ----------------------------\n+\n+   procedure Gen_Finalize_Library_C is\n+      U     : Unit_Record;\n+      Uspec : Unit_Record;\n+      Unum  : Unit_Id;\n+\n+   begin\n+      WBI (\"   /* BEGIN FINALIZE */\");\n+\n+      for E in reverse Elab_Order.First .. Elab_Order.Last loop\n+         Unum := Elab_Order.Table (E);\n+         U    := Units.Table (Unum);\n+\n+         --  We are only interested in non-generic packages\n+\n+         if U.Unit_Kind = 'p'\n+           and then U.Has_Finalizer\n+           and then not U.Is_Generic\n+           and then not U.No_Elab\n+         then\n+            Set_String (\"   \");\n+\n+            --  Dealing with package bodies is a little complicated. In such\n+            --  cases we must retrieve the package spec since it contains the\n+            --  spec of the body finalizer.\n+\n+            if U.Utype = Is_Body then\n+               Unum  := Unum + 1;\n+               Uspec := Units.Table (Unum);\n+            else\n+               Uspec := U;\n+            end if;\n+\n+            Get_Name_String (Uspec.Uname);\n+            Set_Unit_Name;\n+            Set_String (\"__finalize\");\n+\n+            --  Package spec processing\n+\n+            if U.Utype = Is_Spec\n+              or else U.Utype = Is_Spec_Only\n+            then\n+               Set_Char ('S');\n+\n+            --  Package body processing\n+\n+            else\n+               Set_Char ('B');\n+            end if;\n+\n+            Set_String (\" ();\");\n+\n+            Write_Statement_Buffer;\n+         end if;\n+      end loop;\n+\n+      WBI (\"   /* END FINALIZE */\");\n+      WBI (\"\");\n+   end Gen_Finalize_Library_C;\n+\n+   ---------------------------------\n+   -- Gen_Finalize_Library_Defs_C --\n+   ---------------------------------\n+\n+   procedure Gen_Finalize_Library_Defs_C is\n+      U     : Unit_Record;\n+      Uspec : Unit_Record;\n+      Unum  : Unit_Id;\n+\n+   begin\n+      WBI (\"/* BEGIN FINALIZE DEFINITIONS */\");\n+\n+      for E in reverse Elab_Order.First .. Elab_Order.Last loop\n+         Unum := Elab_Order.Table (E);\n+         U    := Units.Table (Unum);\n+\n+         --  We are only interested in non-generic packages\n+\n+         if U.Unit_Kind = 'p'\n+           and then U.Has_Finalizer\n+           and then not U.Is_Generic\n+           and then not U.No_Elab\n+         then\n+            --  Dealing with package bodies is a little complicated. In such\n+            --  cases we must retrieve the package spec since it contains the\n+            --  spec of the body finalizer.\n+\n+            if U.Utype = Is_Body then\n+               Unum  := Unum + 1;\n+               Uspec := Units.Table (Unum);\n+            else\n+               Uspec := U;\n+            end if;\n+\n+            Set_String (\"extern void \");\n+            Get_Name_String (Uspec.Uname);\n+            Set_Unit_Name;\n+            Set_String (\"__finalize\");\n+\n+            if U.Utype = Is_Spec\n+              or else U.Utype = Is_Spec_Only\n+            then\n+               Set_Char ('S');\n+            else\n+               Set_Char ('B');\n+            end if;\n+\n+            Set_String (\" (void);\");\n+            Write_Statement_Buffer;\n+         end if;\n+      end loop;\n+\n+      WBI (\"/* END FINALIZE DEFINITIONS */\");\n+      WBI (\"\");\n+   end Gen_Finalize_Library_Defs_C;\n+\n    ------------------\n    -- Gen_Main_Ada --\n    ------------------\n \n    procedure Gen_Main_Ada is\n    begin\n-      WBI (\"\");\n-\n       if Exit_Status_Supported_On_Target then\n          Set_String (\"   function \");\n       else\n@@ -1558,11 +1928,11 @@ package body Bindgen is\n       --  Initialize and Finalize\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n-         WBI (\"      procedure initialize (Addr : System.Address);\");\n-         WBI (\"      pragma Import (C, initialize, \"\"__gnat_initialize\"\");\");\n+         WBI (\"      procedure Initialize (Addr : System.Address);\");\n+         WBI (\"      pragma Import (C, Initialize, \"\"__gnat_initialize\"\");\");\n          WBI (\"\");\n-         WBI (\"      procedure finalize;\");\n-         WBI (\"      pragma Import (C, finalize, \"\"__gnat_finalize\"\");\");\n+         WBI (\"      procedure Finalize;\");\n+         WBI (\"      pragma Import (C, Finalize, \"\"__gnat_finalize\"\");\");\n       end if;\n \n       --  If we want to analyze the stack, we have to import corresponding\n@@ -1711,15 +2081,7 @@ package body Bindgen is\n       --  Adafinal call is skipped if no finalization\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n-\n-         --  If compiling for the JVM, we directly call Adafinal because\n-         --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n-\n-         if VM_Target = No_VM then\n-            WBI (\"      Do_Finalize;\");\n-         else\n-            WBI (\"      System.Standard_Library.Adafinal;\");\n-         end if;\n+         WBI (\"      adafinal;\");\n       end if;\n \n       --  Prints the result of static stack analysis\n@@ -1747,13 +2109,16 @@ package body Bindgen is\n       end if;\n \n       WBI (\"   end;\");\n+      WBI (\"\");\n    end Gen_Main_Ada;\n \n    ----------------\n    -- Gen_Main_C --\n    ----------------\n \n    procedure Gen_Main_C is\n+      Needs_Library_Finalization : constant Boolean := Has_Finalizer;\n+\n    begin\n       if Exit_Status_Supported_On_Target then\n          WBI (\"#include <stdlib.h>\");\n@@ -1890,9 +2255,10 @@ package body Bindgen is\n \n       --  Call adafinal if finalization active\n \n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n-         WBI (\" \");\n-         WBI (\"   system__standard_library__adafinal ();\");\n+      if not Cumulative_Restrictions.Set (No_Finalization)\n+        and then Needs_Library_Finalization\n+      then\n+         Gen_Finalize_Library_C;\n       end if;\n \n       --  Outputs the dynamic stack measurement if needed\n@@ -1943,6 +2309,7 @@ package body Bindgen is\n       end if;\n \n       WBI (\"}\");\n+      WBI (\"\");\n    end Gen_Main_C;\n \n    ------------------------------\n@@ -2013,7 +2380,6 @@ package body Bindgen is\n    --  Start of processing for Gen_Object_Files_Options\n \n    begin\n-      WBI (\"\");\n       Write_Info_Ada_C (\"-- \", \"/* \", \" BEGIN Object file/option list\");\n \n       if Object_List_Filename /= null then\n@@ -2268,16 +2634,18 @@ package body Bindgen is\n \n    procedure Gen_Output_File_Ada (Filename : String) is\n \n+      Ada_Main : constant String := Get_Ada_Main_Name;\n+      --  Name to be used for generated Ada main program. See the body of\n+      --  function Get_Ada_Main_Name for details on the form of the name.\n+\n+      Needs_Library_Finalization : constant Boolean := Has_Finalizer;\n+\n       Bfiles : Name_Id;\n       --  Name of generated bind file (spec)\n \n       Bfileb : Name_Id;\n       --  Name of generated bind file (body)\n \n-      Ada_Main : constant String := Get_Ada_Main_Name;\n-      --  Name to be used for generated Ada main program. See the body of\n-      --  function Get_Ada_Main_Name for details on the form of the name.\n-\n    begin\n       --  Create spec first\n \n@@ -2327,15 +2695,14 @@ package body Bindgen is\n \n       Resolve_Binder_Options;\n \n-      if VM_Target /= No_VM then\n-         if not Suppress_Standard_Library_On_Target then\n-\n-            --  Usually, adafinal is called using a pragma Import C. Since\n-            --  Import C doesn't have the same semantics for JGNAT, we use\n-            --  standard Ada.\n+      --  Usually, adafinal is called using a pragma Import C. Since Import C\n+      --  doesn't have the same semantics for JGNAT, we use standard Ada.\n \n-            WBI (\"with System.Standard_Library;\");\n-         end if;\n+      if VM_Target /= No_VM\n+        and then not Suppress_Standard_Library_On_Target\n+      then\n+         WBI (\"with System.Soft_Links;\");\n+         WBI (\"with System.Standard_Library;\");\n       end if;\n \n       WBI (\"package \" & Ada_Main & \" is\");\n@@ -2544,27 +2911,14 @@ package body Bindgen is\n          WBI (\"with System.Restrictions;\");\n       end if;\n \n+      if Needs_Library_Finalization then\n+         WBI (\"with Ada.Exceptions;\");\n+      end if;\n+\n       WBI (\"\");\n       WBI (\"package body \" & Ada_Main & \" is\");\n       WBI (\"   pragma Warnings (Off);\");\n \n-      --  Import the finalization procedure only if finalization active\n-\n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n-\n-         --  In the Java case, pragma Import C cannot be used, so the standard\n-         --  Ada constructs will be used instead.\n-\n-         if VM_Target = No_VM then\n-            WBI (\"\");\n-            WBI (\"   procedure Do_Finalize;\");\n-            WBI\n-              (\"   pragma Import (C, Do_Finalize, \" &\n-               \"\"\"system__standard_library__adafinal\"\");\");\n-            WBI (\"\");\n-         end if;\n-      end if;\n-\n       if not Suppress_Standard_Library_On_Target then\n \n          --  Generate Priority_Specific_Dispatching pragma string\n@@ -2592,14 +2946,18 @@ package body Bindgen is\n          WBI (\"\");\n       end if;\n \n-      Gen_Adainit_Ada;\n-\n       --  Generate the adafinal routine unless there is no finalization to do\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n          Gen_Adafinal_Ada;\n+\n+         if Needs_Library_Finalization then\n+            Gen_Finalize_Library_Ada;\n+         end if;\n       end if;\n \n+      Gen_Adainit_Ada;\n+\n       if Bind_Main_Program and then VM_Target = No_VM then\n \n          --  When suppressing the standard library then generate dummy body\n@@ -2631,6 +2989,9 @@ package body Bindgen is\n    -----------------------\n \n    procedure Gen_Output_File_C (Filename : String) is\n+\n+      Needs_Library_Finalization : constant Boolean := Has_Finalizer;\n+\n       Bfile : Name_Id;\n       pragma Warnings (Off, Bfile);\n       --  Name of generated bind file (not referenced)\n@@ -2722,6 +3083,10 @@ package body Bindgen is\n \n       Gen_Elab_Defs_C;\n \n+      if Needs_Library_Finalization then\n+         Gen_Finalize_Library_Defs_C;\n+      end if;\n+\n       --  Imported variables used only when we have a runtime\n \n       if not Suppress_Standard_Library_On_Target then\n@@ -3283,6 +3648,33 @@ package body Bindgen is\n       end if;\n    end Get_WC_Encoding;\n \n+   -------------------\n+   -- Has_Finalizer --\n+   -------------------\n+\n+   function Has_Finalizer return Boolean is\n+      U     : Unit_Record;\n+      Unum  : Unit_Id;\n+\n+   begin\n+      for E in reverse Elab_Order.First .. Elab_Order.Last loop\n+         Unum := Elab_Order.Table (E);\n+         U    := Units.Table (Unum);\n+\n+         --  We are only interested in non-generic packages\n+\n+         if U.Unit_Kind = 'p'\n+           and then U.Has_Finalizer\n+           and then not U.Is_Generic\n+           and then not U.No_Elab\n+         then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Has_Finalizer;\n+\n    ----------------------\n    -- Lt_Linker_Option --\n    ----------------------\n@@ -3508,13 +3900,19 @@ package body Bindgen is\n    -- Set_Unit_Name --\n    -------------------\n \n-   procedure Set_Unit_Name is\n+   procedure Set_Unit_Name (Mode : Qualification_Mode := Double_Underscores) is\n    begin\n       for J in 1 .. Name_Len - 2 loop\n-         if Name_Buffer (J) /= '.' then\n-            Set_Char (Name_Buffer (J));\n+         if Name_Buffer (J) = '.' then\n+            if Mode = Double_Underscores then\n+               Set_String (\"__\");\n+            elsif Mode = Dot then\n+               Set_Char ('.');\n+            else\n+               Set_Char ('$');\n+            end if;\n          else\n-            Set_String (\"__\");\n+            Set_Char (Name_Buffer (J));\n          end if;\n       end loop;\n    end Set_Unit_Name;"}, {"sha": "9478ae3a0fb5d6e8cccda23c8ae01ec844e56677", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 277, "deletions": 227, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -123,6 +123,7 @@ package body Einfo is\n    --    Extra_Formal                    Node15\n    --    Lit_Indexes                     Node15\n    --    Related_Instance                Node15\n+   --    Return_Flag                     Node15\n    --    Scale_Value                     Uint15\n    --    Storage_Size_Variable           Node15\n    --    String_Literal_Low_Bound        Node15\n@@ -160,7 +161,6 @@ package body Einfo is\n \n    --    Body_Entity                     Node19\n    --    Corresponding_Discriminant      Node19\n-   --    Finalization_Chain_Entity       Node19\n    --    Parent_Subtype                  Node19\n    --    Related_Array_Object            Node19\n    --    Size_Check_Code                 Node19\n@@ -195,7 +195,7 @@ package body Einfo is\n    --    Scope_Depth_Value               Uint22\n    --    Shared_Var_Procs_Instance       Node22\n \n-   --    Associated_Final_Chain          Node23\n+   --    Associated_Collection           Node23\n    --    CR_Discriminant                 Node23\n    --    Entry_Cancel_Parameter          Node23\n    --    Enum_Pos_To_Rep                 Node23\n@@ -207,6 +207,7 @@ package body Einfo is\n    --    Protection_Object               Node23\n    --    Stored_Constraint               Elist23\n \n+   --    Finalizer                       Node24\n    --    Related_Expression              Node24\n    --    Spec_PPC_List                   Node24\n \n@@ -519,7 +520,7 @@ package body Einfo is\n    --    Has_Predicates                  Flag250\n \n    --    Body_Is_In_ALFA                 Flag251\n-   --    (unused)                        Flag252\n+   --    Is_Processed_Transient          Flag252\n    --    (unused)                        Flag253\n    --    (unused)                        Flag254\n \n@@ -582,7 +583,7 @@ package body Einfo is\n    function Actual_Subtype (Id : E) return E is\n    begin\n       pragma Assert\n-         (Ekind_In (Id, E_Constant, E_Variable, E_Generic_In_Out_Parameter)\n+        (Ekind_In (Id, E_Constant, E_Variable, E_Generic_In_Out_Parameter)\n            or else Is_Formal (Id));\n       return Node17 (Id);\n    end Actual_Subtype;\n@@ -610,11 +611,11 @@ package body Einfo is\n       return Uint14 (Id);\n    end Alignment;\n \n-   function Associated_Final_Chain (Id : E) return E is\n+   function Associated_Collection (Id : E) return E is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n       return Node23 (Id);\n-   end Associated_Final_Chain;\n+   end Associated_Collection;\n \n    function Associated_Formal_Package (Id : E) return E is\n    begin\n@@ -1058,9 +1059,9 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n-          or else Ekind_In (Id, E_Entry_Family,\n-                                E_Subprogram_Body,\n-                                E_Subprogram_Type));\n+           or else Ekind_In (Id, E_Entry_Family,\n+                                 E_Subprogram_Body,\n+                                 E_Subprogram_Type));\n       return Node28 (Id);\n    end Extra_Formals;\n \n@@ -1070,17 +1071,20 @@ package body Einfo is\n       return Flag229 (Base_Type (Id));\n    end Can_Use_Internal_Rep;\n \n-   function Finalization_Chain_Entity (Id : E) return E is\n-   begin\n-      return Node19 (Id);\n-   end Finalization_Chain_Entity;\n-\n    function Finalize_Storage_Only (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n       return Flag158 (Base_Type (Id));\n    end Finalize_Storage_Only;\n \n+   function Finalizer (Id : E) return E is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Package\n+          or else Ekind (Id) = E_Package_Body);\n+      return Node24 (Id);\n+   end Finalizer;\n+\n    function First_Entity (Id : E) return E is\n    begin\n       return Node17 (Id);\n@@ -1987,7 +1991,7 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n-         or else Ekind_In (Id, E_Generic_Function, E_Generic_Procedure));\n+           or else Ekind_In (Id, E_Generic_Function, E_Generic_Procedure));\n       return Flag218 (Id);\n    end Is_Primitive;\n \n@@ -2014,6 +2018,12 @@ package body Einfo is\n       return Flag245 (Id);\n    end Is_Private_Primitive;\n \n+   function Is_Processed_Transient (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      return Flag252 (Id);\n+   end Is_Processed_Transient;\n+\n    function Is_Public (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -2265,7 +2275,7 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n-          or else Ekind_In (Id, E_Subprogram_Type, E_Entry_Family));\n+           or else Ekind_In (Id, E_Subprogram_Type, E_Entry_Family));\n       return Flag22 (Id);\n    end Needs_No_Actuals;\n \n@@ -2543,6 +2553,12 @@ package body Einfo is\n       return Flag213 (Id);\n    end Requires_Overriding;\n \n+   function Return_Flag (Id : E) return N is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      return Node15 (Id);\n+   end Return_Flag;\n+\n    function Return_Present (Id : E) return B is\n    begin\n       return Flag54 (Id);\n@@ -3033,11 +3049,11 @@ package body Einfo is\n       Set_Elist16 (Id, V);\n    end Set_Access_Disp_Table;\n \n-   procedure Set_Associated_Final_Chain (Id : E; V : E) is\n+   procedure Set_Associated_Collection (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n       Set_Node23 (Id, V);\n-   end Set_Associated_Final_Chain;\n+   end Set_Associated_Collection;\n \n    procedure Set_Associated_Formal_Package (Id : E; V : E) is\n    begin\n@@ -3058,7 +3074,7 @@ package body Einfo is\n    procedure Set_Actual_Subtype (Id : E; V : E) is\n    begin\n       pragma Assert\n-         (Ekind_In (Id, E_Constant, E_Variable, E_Generic_In_Out_Parameter)\n+        (Ekind_In (Id, E_Constant, E_Variable, E_Generic_In_Out_Parameter)\n            or else Is_Formal (Id));\n       Set_Node17 (Id, V);\n    end Set_Actual_Subtype;\n@@ -3078,11 +3094,11 @@ package body Einfo is\n    procedure Set_Alignment (Id : E; V : U) is\n    begin\n       pragma Assert (Is_Type (Id)\n-                      or else Is_Formal (Id)\n-                      or else Ekind_In (Id, E_Loop_Parameter,\n-                                            E_Constant,\n-                                            E_Exception,\n-                                            E_Variable));\n+                       or else Is_Formal (Id)\n+                       or else Ekind_In (Id, E_Loop_Parameter,\n+                                             E_Constant,\n+                                             E_Exception,\n+                                             E_Variable));\n       Set_Uint14 (Id, V);\n    end Set_Alignment;\n \n@@ -3114,8 +3130,8 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Ekind (Id) = E_Package\n-          or else Is_Subprogram (Id)\n-          or else Is_Generic_Unit (Id));\n+           or else Is_Subprogram (Id)\n+           or else Is_Generic_Unit (Id));\n       Set_Flag40 (Id, V);\n    end Set_Body_Needed_For_SAL;\n \n@@ -3267,6 +3283,7 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Subprogram (Id) or else Ekind_In (Id, E_Package, E_Package_Body));\n+\n       Set_Flag50 (Id, V);\n    end Set_Delay_Subprogram_Descriptors;\n \n@@ -3509,9 +3526,9 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n-          or else Ekind_In (Id, E_Entry_Family,\n-                                E_Subprogram_Body,\n-                                E_Subprogram_Type));\n+           or else Ekind_In (Id, E_Entry_Family,\n+                                 E_Subprogram_Body,\n+                                 E_Subprogram_Type));\n       Set_Node28 (Id, V);\n    end Set_Extra_Formals;\n \n@@ -3522,17 +3539,20 @@ package body Einfo is\n       Set_Flag229 (Id, V);\n    end Set_Can_Use_Internal_Rep;\n \n-   procedure Set_Finalization_Chain_Entity (Id : E; V : E) is\n-   begin\n-      Set_Node19 (Id, V);\n-   end Set_Finalization_Chain_Entity;\n-\n    procedure Set_Finalize_Storage_Only (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id) and then Is_Base_Type (Id));\n       Set_Flag158 (Id, V);\n    end Set_Finalize_Storage_Only;\n \n+   procedure Set_Finalizer (Id : E; V : E) is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Package\n+          or else Ekind (Id) = E_Package_Body);\n+      Set_Node24 (Id, V);\n+   end Set_Finalizer;\n+\n    procedure Set_First_Entity (Id : E; V : E) is\n    begin\n       Set_Node17 (Id, V);\n@@ -3565,7 +3585,7 @@ package body Einfo is\n    procedure Set_First_Private_Entity (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind_In (Id, E_Package, E_Generic_Package)\n-                      or else Ekind (Id) in Concurrent_Kind);\n+                       or else Ekind (Id) in Concurrent_Kind);\n       Set_Node16 (Id, V);\n    end Set_First_Private_Entity;\n \n@@ -3589,7 +3609,7 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Type (Id)\n-          or else Ekind (Id) = E_Package);\n+           or else Ekind (Id) = E_Package);\n       Set_Flag159 (Id, V);\n    end Set_From_With_Type;\n \n@@ -4068,8 +4088,8 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Internal (Id)\n-          and then Is_Hidden (Id)\n-          and then (Ekind_In (Id, E_Procedure, E_Function)));\n+           and then Is_Hidden (Id)\n+           and then (Ekind_In (Id, E_Procedure, E_Function)));\n       Set_Node25 (Id, V);\n    end Set_Interface_Alias;\n \n@@ -4167,7 +4187,6 @@ package body Einfo is\n    begin\n       pragma Assert ((not V)\n         or else (Is_Array_Type (Id) and then Is_Base_Type (Id)));\n-\n       Set_Flag122 (Id, V);\n    end Set_Is_Bit_Packed_Array;\n \n@@ -4490,7 +4509,7 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n-          or else Ekind_In (Id, E_Generic_Function, E_Generic_Procedure));\n+           or else Ekind_In (Id, E_Generic_Function, E_Generic_Procedure));\n       Set_Flag218 (Id, V);\n    end Set_Is_Primitive;\n \n@@ -4517,6 +4536,12 @@ package body Einfo is\n       Set_Flag245 (Id, V);\n    end Set_Is_Private_Primitive;\n \n+   procedure Set_Is_Processed_Transient (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      Set_Flag252 (Id, V);\n+   end Set_Is_Processed_Transient;\n+\n    procedure Set_Is_Public (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -4581,10 +4606,10 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Type (Id)\n-          or else Ekind_In (Id, E_Exception,\n-                                E_Variable,\n-                                E_Constant,\n-                                E_Void));\n+           or else Ekind_In (Id, E_Exception,\n+                                 E_Variable,\n+                                 E_Constant,\n+                                 E_Void));\n       Set_Flag28 (Id, V);\n    end Set_Is_Statically_Allocated;\n \n@@ -4773,7 +4798,7 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n-          or else Ekind_In (Id, E_Subprogram_Type, E_Entry_Family));\n+           or else Ekind_In (Id, E_Subprogram_Type, E_Entry_Family));\n       Set_Flag22 (Id, V);\n    end Set_Needs_No_Actuals;\n \n@@ -5064,6 +5089,12 @@ package body Einfo is\n       Set_Flag213 (Id, V);\n    end Set_Requires_Overriding;\n \n+   procedure Set_Return_Flag (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      Set_Node15 (Id, V);\n+   end Set_Return_Flag;\n+\n    procedure Set_Return_Present (Id : E; V : B := True) is\n    begin\n       Set_Flag54 (Id, V);\n@@ -5315,7 +5346,7 @@ package body Einfo is\n    procedure Set_Wrapped_Entity (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind_In (Id, E_Function, E_Procedure)\n-                      and then Is_Primitive_Wrapper (Id));\n+                       and then Is_Primitive_Wrapper (Id));\n       Set_Node27 (Id, V);\n    end Set_Wrapped_Entity;\n \n@@ -5810,9 +5841,9 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n-          or else Ekind_In (Id, E_Entry_Family,\n-                                E_Subprogram_Body,\n-                                E_Subprogram_Type));\n+           or else Ekind_In (Id, E_Entry_Family,\n+                                 E_Subprogram_Body,\n+                                 E_Subprogram_Type));\n \n       if Ekind (Id) = E_Enumeration_Literal then\n          return Empty;\n@@ -5838,9 +5869,9 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n-                        or else Ekind_In (Id, E_Entry_Family,\n-                                              E_Subprogram_Body,\n-                                              E_Subprogram_Type));\n+           or else Ekind_In (Id, E_Entry_Family,\n+                                 E_Subprogram_Body,\n+                                 E_Subprogram_Type));\n \n       if Ekind (Id) = E_Enumeration_Literal then\n          return Empty;\n@@ -6267,7 +6298,7 @@ package body Einfo is\n    function Is_Discriminal (Id : E) return B is\n    begin\n       return (Ekind_In (Id, E_Constant, E_In_Parameter)\n-               and then Present (Discriminal_Link (Id)));\n+                and then Present (Discriminal_Link (Id)));\n    end Is_Discriminal;\n \n    ----------------------\n@@ -6321,6 +6352,16 @@ package body Einfo is\n                   and then Is_Entity_Attribute_Name (Attribute_Name (N)));\n    end Is_Entity_Name;\n \n+   ------------------\n+   -- Is_Finalizer --\n+   ------------------\n+\n+   function Is_Finalizer (Id : E) return B is\n+   begin\n+      return Ekind (Id) = E_Procedure\n+        and then Chars (Id) = Name_uFinalizer;\n+   end Is_Finalizer;\n+\n    -----------------------------------\n    -- Is_Package_Or_Generic_Package --\n    -----------------------------------\n@@ -6367,7 +6408,7 @@ package body Einfo is\n    function Is_Prival (Id : E) return B is\n    begin\n       return (Ekind_In (Id, E_Constant, E_Variable)\n-                         and then Present (Prival_Link (Id)));\n+                and then Present (Prival_Link (Id)));\n    end Is_Prival;\n \n    ----------------------------\n@@ -6498,7 +6539,7 @@ package body Einfo is\n    function Is_Wrapper_Package (Id : E) return B is\n    begin\n       return (Ekind (Id) = E_Package\n-               and then Present (Related_Instance (Id)));\n+                and then Present (Related_Instance (Id)));\n    end Is_Wrapper_Package;\n \n    -----------------\n@@ -6718,7 +6759,7 @@ package body Einfo is\n          D := Next_Entity (D);\n          if No (D)\n            or else (Ekind (D) /= E_Discriminant\n-                     and then not Is_Itype (D))\n+                      and then not Is_Itype (D))\n          then\n             return Empty;\n          end if;\n@@ -7529,6 +7570,7 @@ package body Einfo is\n       W (\"Is_Private_Composite\",            Flag107 (Id));\n       W (\"Is_Private_Descendant\",           Flag53  (Id));\n       W (\"Is_Private_Primitive\",            Flag245 (Id));\n+      W (\"Is_Processed_Transient\",          Flag252 (Id));\n       W (\"Is_Public\",                       Flag10  (Id));\n       W (\"Is_Pure\",                         Flag44  (Id));\n       W (\"Is_Pure_Unit_Access_Type\",        Flag189 (Id));\n@@ -7761,33 +7803,33 @@ package body Einfo is\n    procedure Write_Field8_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Component                                  |\n-              E_Discriminant                               =>\n-            Write_Str (\"Normalized_First_Bit\");\n-\n-         when Formal_Kind                                  |\n-              E_Function                                   |\n-              E_Subprogram_Body                            =>\n-            Write_Str (\"Mechanism\");\n-\n          when Type_Kind                                    =>\n             Write_Str (\"Associated_Node_For_Itype\");\n \n+         when E_Package                                    =>\n+            Write_Str (\"Dependent_Instances\");\n+\n          when E_Loop                                       =>\n             Write_Str (\"First_Exit_Statement\");\n \n-         when E_Package                                    =>\n-            Write_Str (\"Dependent_Instances\");\n+         when E_Variable                                   =>\n+            Write_Str (\"Hiding_Loop_Variable\");\n+\n+         when Formal_Kind                                  |\n+              E_Function                                   |\n+              E_Subprogram_Body                            =>\n+            Write_Str (\"Mechanism\");\n+\n+         when E_Component                                  |\n+              E_Discriminant                               =>\n+            Write_Str (\"Normalized_First_Bit\");\n \n          when E_Procedure                                  =>\n             Write_Str (\"Postcondition_Proc\");\n \n          when E_Return_Statement                           =>\n             Write_Str (\"Return_Applies_To\");\n \n-         when E_Variable                                   =>\n-            Write_Str (\"Hiding_Loop_Variable\");\n-\n          when others                                       =>\n             Write_Str (\"Field8??\");\n       end case;\n@@ -7803,6 +7845,9 @@ package body Einfo is\n          when Type_Kind                                    =>\n             Write_Str (\"Class_Wide_Type\");\n \n+         when Object_Kind                                  =>\n+            Write_Str (\"Current_Value\");\n+\n          when E_Function                                   |\n               E_Generic_Function                           |\n               E_Generic_Package                            |\n@@ -7811,9 +7856,6 @@ package body Einfo is\n               E_Procedure                                  =>\n             Write_Str (\"Renaming_Map\");\n \n-         when Object_Kind                                  =>\n-            Write_Str (\"Current_Value\");\n-\n          when others                                       =>\n             Write_Str (\"Field9??\");\n       end case;\n@@ -7863,34 +7905,32 @@ package body Einfo is\n    procedure Write_Field11_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when Formal_Kind                                  =>\n-            Write_Str (\"Entry_Component\");\n+         when E_Block                                      =>\n+            Write_Str (\"Block_Node\");\n \n          when E_Component                                  |\n               E_Discriminant                               =>\n             Write_Str (\"Component_Bit_Offset\");\n \n-         when E_Constant                                   =>\n-            Write_Str (\"Full_View\");\n+         when Formal_Kind                                  =>\n+            Write_Str (\"Entry_Component\");\n \n          when E_Enumeration_Literal                        =>\n             Write_Str (\"Enumeration_Pos\");\n \n-         when E_Block                                      =>\n-            Write_Str (\"Block_Node\");\n+         when Type_Kind                                    |\n+              E_Constant                                   =>\n+            Write_Str (\"Full_View\");\n+\n+         when E_Generic_Package                            =>\n+            Write_Str (\"Generic_Homonym\");\n \n          when E_Function                                   |\n               E_Procedure                                  |\n               E_Entry                                      |\n               E_Entry_Family                               =>\n             Write_Str (\"Protected_Body_Subprogram\");\n \n-         when E_Generic_Package                            =>\n-            Write_Str (\"Generic_Homonym\");\n-\n-         when Type_Kind                                    =>\n-            Write_Str (\"Full_View\");\n-\n          when others                                       =>\n             Write_Str (\"Field11??\");\n       end case;\n@@ -7903,6 +7943,9 @@ package body Einfo is\n    procedure Write_Field12_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Package                                    =>\n+            Write_Str (\"Associated_Formal_Package\");\n+\n          when Entry_Kind                                   =>\n             Write_Str (\"Barrier_Function\");\n \n@@ -7925,9 +7968,6 @@ package body Einfo is\n               E_Procedure                                  =>\n             Write_Str (\"Next_Inlined_Subprogram\");\n \n-         when E_Package                                    =>\n-            Write_Str (\"Associated_Formal_Package\");\n-\n          when others                                       =>\n             Write_Str (\"Field12??\");\n       end case;\n@@ -7940,9 +7980,6 @@ package body Einfo is\n    procedure Write_Field13_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when Type_Kind                                    =>\n-            Write_Str (\"RM_Size\");\n-\n          when E_Component                                  |\n               E_Discriminant                               =>\n             Write_Str (\"Component_Clause\");\n@@ -7961,15 +7998,18 @@ package body Einfo is\n                Write_Str (\"Field13??\");\n             end if;\n \n-         when Formal_Kind                                  |\n-              E_Variable                                   =>\n-            Write_Str (\"Extra_Accessibility\");\n-\n          when E_Procedure                                  |\n               E_Package                                    |\n               Generic_Unit_Kind                            =>\n             Write_Str (\"Elaboration_Entity\");\n \n+         when Formal_Kind                                  |\n+              E_Variable                                   =>\n+            Write_Str (\"Extra_Accessibility\");\n+\n+         when Type_Kind                                    =>\n+            Write_Str (\"RM_Size\");\n+\n          when others                                       =>\n             Write_Str (\"Field13??\");\n       end case;\n@@ -7990,14 +8030,14 @@ package body Einfo is\n               E_Loop_Parameter                             =>\n             Write_Str (\"Alignment\");\n \n-         when E_Component                                  |\n-              E_Discriminant                               =>\n-            Write_Str (\"Normalized_Position\");\n-\n          when E_Function                                   |\n               E_Procedure                                  =>\n             Write_Str (\"First_Optional_Parameter\");\n \n+         when E_Component                                  |\n+              E_Discriminant                               =>\n+            Write_Str (\"Normalized_Position\");\n+\n          when E_Package                                    |\n               E_Generic_Package                            =>\n             Write_Str (\"Shadow_Entities\");\n@@ -8014,38 +8054,42 @@ package body Einfo is\n    procedure Write_Field15_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when Access_Kind                                  |\n-              Task_Kind                                    =>\n-            Write_Str (\"Storage_Size_Variable\");\n-\n-         when E_Component                                  =>\n-            Write_Str (\"DT_Entry_Count\");\n-\n-         when Decimal_Fixed_Point_Kind                     =>\n-            Write_Str (\"Scale_Value\");\n-\n          when E_Discriminant                               =>\n             Write_Str (\"Discriminant_Number\");\n \n-         when Formal_Kind                                  =>\n-            Write_Str (\"Extra_Formal\");\n+         when E_Component                                  =>\n+            Write_Str (\"DT_Entry_Count\");\n \n          when E_Function                                   |\n               E_Procedure                                  =>\n             Write_Str (\"DT_Position\");\n \n+         when E_Protected_Type                             =>\n+            Write_Str (\"Entry_Bodies_Array\");\n+\n          when Entry_Kind                                   =>\n             Write_Str (\"Entry_Parameters_Type\");\n \n+         when Formal_Kind                                  =>\n+            Write_Str (\"Extra_Formal\");\n+\n          when Enumeration_Kind                             =>\n             Write_Str (\"Lit_Indexes\");\n \n          when E_Package                                    |\n               E_Package_Body                               =>\n             Write_Str (\"Related_Instance\");\n \n-         when E_Protected_Type                             =>\n-            Write_Str (\"Entry_Bodies_Array\");\n+         when E_Constant                                   |\n+              E_Variable                                   =>\n+            Write_Str (\"Return_Flag\");\n+\n+         when Decimal_Fixed_Point_Kind                     =>\n+            Write_Str (\"Scale_Value\");\n+\n+         when Access_Kind                                  |\n+              Task_Kind                                    =>\n+            Write_Str (\"Storage_Size_Variable\");\n \n          when E_String_Literal_Subtype                     =>\n             Write_Str (\"String_Literal_Low_Bound\");\n@@ -8062,36 +8106,36 @@ package body Einfo is\n    procedure Write_Field16_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Component                                  =>\n-            Write_Str (\"Entry_Formal\");\n+         when E_Record_Type                                |\n+              E_Record_Type_With_Private                   =>\n+            Write_Str (\"Access_Disp_Table\");\n+\n+         when E_Record_Subtype                             |\n+              E_Class_Wide_Subtype                         =>\n+            Write_Str (\"Cloned_Subtype\");\n \n          when E_Function                                   |\n               E_Procedure                                  =>\n             Write_Str (\"DTC_Entity\");\n \n+         when E_Component                                  =>\n+            Write_Str (\"Entry_Formal\");\n+\n          when E_Package                                    |\n               E_Generic_Package                            |\n               Concurrent_Kind                              =>\n             Write_Str (\"First_Private_Entity\");\n \n-         when E_Record_Type                                |\n-              E_Record_Type_With_Private                   =>\n-            Write_Str (\"Access_Disp_Table\");\n+         when Enumeration_Kind                             =>\n+            Write_Str (\"Lit_Strings\");\n \n          when E_String_Literal_Subtype                     =>\n             Write_Str (\"String_Literal_Length\");\n \n-         when Enumeration_Kind                             =>\n-            Write_Str (\"Lit_Strings\");\n-\n          when E_Variable                                   |\n               E_Out_Parameter                              =>\n             Write_Str (\"Unset_Reference\");\n \n-         when E_Record_Subtype                             |\n-              E_Class_Wide_Subtype                         =>\n-            Write_Str (\"Cloned_Subtype\");\n-\n          when others                                       =>\n             Write_Str (\"Field16??\");\n       end case;\n@@ -8104,12 +8148,15 @@ package body Einfo is\n    procedure Write_Field17_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when Formal_Kind                                  |\n+              E_Constant                                   |\n+              E_Generic_In_Out_Parameter                   |\n+              E_Variable                                   =>\n+            Write_Str (\"Actual_Subtype\");\n+\n          when Digits_Kind                                  =>\n             Write_Str (\"Digits_Value\");\n \n-         when E_Component                                  =>\n-            Write_Str (\"Prival\");\n-\n          when E_Discriminant                               =>\n             Write_Str (\"Discriminal\");\n \n@@ -8147,12 +8194,6 @@ package body Einfo is\n          when Modular_Integer_Kind                         =>\n             Write_Str (\"Modulus\");\n \n-         when Formal_Kind                                  |\n-              E_Constant                                   |\n-              E_Generic_In_Out_Parameter                   |\n-              E_Variable                                   =>\n-            Write_Str (\"Actual_Subtype\");\n-\n          when E_Incomplete_Type                            =>\n             Write_Str (\"Non_Limited_View\");\n \n@@ -8161,6 +8202,9 @@ package body Einfo is\n                Write_Str (\"Non_Limited_View\");\n             end if;\n \n+         when E_Component                                  =>\n+            Write_Str (\"Prival\");\n+\n          when others                                       =>\n             Write_Str (\"Field17??\");\n       end case;\n@@ -8185,6 +8229,14 @@ package body Einfo is\n          when E_Subprogram_Body                            =>\n             Write_Str (\"Corresponding_Protected_Entry\");\n \n+         when Concurrent_Kind                              =>\n+            Write_Str (\"Corresponding_Record_Type\");\n+\n+         when E_Label                                      |\n+              E_Loop                                       |\n+              E_Block                                      =>\n+            Write_Str (\"Enclosing_Scope\");\n+\n          when E_Entry_Index_Parameter                      =>\n             Write_Str (\"Entry_Index_Constant\");\n \n@@ -8198,6 +8250,10 @@ package body Einfo is\n          when Fixed_Point_Kind                             =>\n             Write_Str (\"Delta_Value\");\n \n+         when Incomplete_Or_Private_Kind                   |\n+              E_Record_Subtype                             =>\n+            Write_Str (\"Private_Dependents\");\n+\n          when Object_Kind                                  =>\n             Write_Str (\"Renamed_Object\");\n \n@@ -8208,18 +8264,6 @@ package body Einfo is\n               E_Generic_Package                            =>\n             Write_Str (\"Renamed_Entity\");\n \n-         when Incomplete_Or_Private_Kind                   |\n-              E_Record_Subtype                             =>\n-            Write_Str (\"Private_Dependents\");\n-\n-         when Concurrent_Kind                              =>\n-            Write_Str (\"Corresponding_Record_Type\");\n-\n-         when E_Label                                      |\n-              E_Loop                                       |\n-              E_Block                                      =>\n-            Write_Str (\"Enclosing_Scope\");\n-\n          when others                                       =>\n             Write_Str (\"Field18??\");\n       end case;\n@@ -8232,38 +8276,31 @@ package body Einfo is\n    procedure Write_Field19_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Package                                    |\n+              E_Generic_Package                            =>\n+            Write_Str (\"Body_Entity\");\n+\n+         when E_Discriminant                               =>\n+            Write_Str (\"Corresponding_Discriminant\");\n+\n+         when E_Record_Type                                =>\n+            Write_Str (\"Parent_Subtype\");\n+\n          when E_Array_Type                                 |\n               E_Array_Subtype                              =>\n             Write_Str (\"Related_Array_Object\");\n \n-         when E_Block                                      |\n-              Concurrent_Kind                              |\n-              E_Function                                   |\n-              E_Procedure                                  |\n-              E_Return_Statement                           |\n-              Entry_Kind                                   =>\n-            Write_Str (\"Finalization_Chain_Entity\");\n-\n-         when E_Constant | E_Variable                      =>\n+         when E_Constant                                   |\n+              E_Variable                                   =>\n             Write_Str (\"Size_Check_Code\");\n \n-         when E_Discriminant                               =>\n-            Write_Str (\"Corresponding_Discriminant\");\n-\n-         when E_Package                                    |\n-              E_Generic_Package                            =>\n-            Write_Str (\"Body_Entity\");\n-\n          when E_Package_Body                               |\n               Formal_Kind                                  =>\n             Write_Str (\"Spec_Entity\");\n \n          when Private_Kind                                 =>\n             Write_Str (\"Underlying_Full_View\");\n \n-         when E_Record_Type                                =>\n-            Write_Str (\"Parent_Subtype\");\n-\n          when others                                       =>\n             Write_Str (\"Field19??\");\n       end case;\n@@ -8289,10 +8326,6 @@ package body Einfo is\n          when E_Component                                  =>\n             Write_Str (\"Discriminant_Checking_Func\");\n \n-         when E_Constant                                   |\n-              E_Variable                                   =>\n-            Write_Str (\"Prival_Link\");\n-\n          when E_Discriminant                               =>\n             Write_Str (\"Discriminant_Default_Value\");\n \n@@ -8318,6 +8351,10 @@ package body Einfo is\n               E_Subprogram_Type                            =>\n             Write_Str (\"Last_Entity\");\n \n+         when E_Constant                                   |\n+              E_Variable                                   =>\n+            Write_Str (\"Prival_Link\");\n+\n          when Scalar_Kind                                  =>\n             Write_Str (\"Scalar_Range\");\n \n@@ -8336,14 +8373,11 @@ package body Einfo is\n    procedure Write_Field21_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Constant                                   |\n-              E_Exception                                  |\n-              E_Function                                   |\n-              E_Generic_Function                           |\n-              E_Procedure                                  |\n-              E_Generic_Procedure                          |\n-              E_Variable                                   =>\n-            Write_Str (\"Interface_Name\");\n+         when Entry_Kind                                   =>\n+            Write_Str (\"Accept_Address\");\n+\n+         when E_In_Parameter                               =>\n+            Write_Str (\"Default_Expr_Function\");\n \n          when Concurrent_Kind                              |\n               Incomplete_Or_Private_Kind                   |\n@@ -8352,19 +8386,22 @@ package body Einfo is\n               E_Record_Subtype                             =>\n             Write_Str (\"Discriminant_Constraint\");\n \n-         when Entry_Kind                                   =>\n-            Write_Str (\"Accept_Address\");\n-\n-         when Fixed_Point_Kind                             =>\n-            Write_Str (\"Small_Value\");\n-\n-         when E_In_Parameter                               =>\n-            Write_Str (\"Default_Expr_Function\");\n+         when E_Constant                                   |\n+              E_Exception                                  |\n+              E_Function                                   |\n+              E_Generic_Function                           |\n+              E_Procedure                                  |\n+              E_Generic_Procedure                          |\n+              E_Variable                                   =>\n+            Write_Str (\"Interface_Name\");\n \n          when Array_Kind                                   |\n               Modular_Integer_Kind                         =>\n             Write_Str (\"Original_Array_Type\");\n \n+         when Fixed_Point_Kind                             =>\n+            Write_Str (\"Small_Value\");\n+\n          when others                                       =>\n             Write_Str (\"Field21??\");\n       end case;\n@@ -8383,6 +8420,9 @@ package body Einfo is\n          when Array_Kind                                   =>\n             Write_Str (\"Component_Size\");\n \n+         when E_Record_Type                                =>\n+            Write_Str (\"Corresponding_Remote_Type\");\n+\n          when E_Component                                  |\n               E_Discriminant                               =>\n             Write_Str (\"Original_Record_Component\");\n@@ -8393,12 +8433,17 @@ package body Einfo is\n          when E_Exception                                  =>\n             Write_Str (\"Exception_Code\");\n \n+         when E_Record_Type_With_Private                   |\n+              E_Record_Subtype_With_Private                |\n+              E_Private_Type                               |\n+              E_Private_Subtype                            |\n+              E_Limited_Private_Type                       |\n+              E_Limited_Private_Subtype                    =>\n+            Write_Str (\"Private_View\");\n+\n          when Formal_Kind                                  =>\n             Write_Str (\"Protected_Formal\");\n \n-         when E_Record_Type                                =>\n-            Write_Str (\"Corresponding_Remote_Type\");\n-\n          when E_Block                                      |\n               E_Entry                                      |\n               E_Entry_Family                               |\n@@ -8416,14 +8461,6 @@ package body Einfo is\n               E_Task_Type                                  =>\n             Write_Str (\"Scope_Depth_Value\");\n \n-         when E_Record_Type_With_Private                   |\n-              E_Record_Subtype_With_Private                |\n-              E_Private_Type                               |\n-              E_Private_Subtype                            |\n-              E_Limited_Private_Type                       |\n-              E_Limited_Private_Subtype                    =>\n-            Write_Str (\"Private_View\");\n-\n          when E_Variable                                   =>\n             Write_Str (\"Shared_Var_Procs_Instance\");\n \n@@ -8440,17 +8477,14 @@ package body Einfo is\n    begin\n       case Ekind (Id) is\n          when Access_Kind                                  =>\n-            Write_Str (\"Associated_Final_Chain\");\n+            Write_Str (\"Associated_Collection\");\n \n-         when Array_Kind                                   =>\n-            Write_Str (\"Packed_Array_Type\");\n+         when E_Discriminant                               =>\n+            Write_Str (\"CR_Discriminant\");\n \n          when E_Block                                      =>\n             Write_Str (\"Entry_Cancel_Parameter\");\n \n-         when E_Discriminant                               =>\n-            Write_Str (\"CR_Discriminant\");\n-\n          when E_Enumeration_Type                           =>\n             Write_Str (\"Enum_Pos_To_Rep\");\n \n@@ -8463,6 +8497,12 @@ package body Einfo is\n               E_Generic_Procedure                          =>\n             Write_Str (\"Inner_Instances\");\n \n+         when Array_Kind                                   =>\n+            Write_Str (\"Packed_Array_Type\");\n+\n+         when Entry_Kind                                   =>\n+            Write_Str (\"Protection_Object\");\n+\n          when Concurrent_Kind                              |\n               Incomplete_Or_Private_Kind                   |\n               Class_Wide_Kind                              |\n@@ -8487,9 +8527,6 @@ package body Einfo is\n                Write_Str (\"Limited_View\");\n             end if;\n \n-         when Entry_Kind                                   =>\n-            Write_Str (\"Protection_Object\");\n-\n          when others                                       =>\n             Write_Str (\"Field23??\");\n       end case;\n@@ -8502,12 +8539,18 @@ package body Einfo is\n    procedure Write_Field24_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when Subprogram_Kind                              =>\n-            Write_Str (\"Spec_PPC_List\");\n+         when E_Package                                    |\n+              E_Package_Body                               =>\n+            Write_Str (\"Finalizer\");\n \n-         when E_Variable | E_Constant | Type_Kind          =>\n+         when E_Constant                                   |\n+              E_Variable                                   |\n+              Type_Kind                                    =>\n             Write_Str (\"Related_Expression\");\n \n+         when Subprogram_Kind                              =>\n+            Write_Str (\"Spec_PPC_List\");\n+\n          when others                                       =>\n             Write_Str (\"Field24???\");\n       end case;\n@@ -8520,6 +8563,9 @@ package body Einfo is\n    procedure Write_Field25_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Variable                                   =>\n+            Write_Str (\"Debug_Renaming_Link\");\n+\n          when E_Component                                  =>\n             Write_Str (\"DT_Offset_To_Top_Func\");\n \n@@ -8536,9 +8582,6 @@ package body Einfo is\n          when Task_Kind                                    =>\n             Write_Str (\"Task_Body_Procedure\");\n \n-         when E_Variable                                   =>\n-            Write_Str (\"Debug_Renaming_Link\");\n-\n          when E_Entry                                      |\n               E_Entry_Family                               =>\n             Write_Str (\"PPC_Wrapper\");\n@@ -8560,13 +8603,29 @@ package body Einfo is\n    procedure Write_Field26_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Record_Type                                |\n+              E_Record_Type_With_Private                   =>\n+            Write_Str (\"Dispatch_Table_Wrappers\");\n+\n+         when E_In_Out_Parameter                           |\n+              E_Out_Parameter                              |\n+              E_Variable                                   =>\n+            Write_Str (\"Last_Assignment\");\n+\n          when E_Access_Subprogram_Type                     =>\n             Write_Str (\"Original_Access_Type\");\n \n          when E_Generic_Package                            |\n               E_Package                                    =>\n             Write_Str (\"Package_Instantiation\");\n \n+         when E_Component                                  |\n+              E_Constant                                   =>\n+            Write_Str (\"Related_Type\");\n+\n+         when Task_Kind                                    =>\n+            Write_Str (\"Relative_Deadline_Variable\");\n+\n          when E_Procedure                                  |\n               E_Function                                   =>\n             if Ekind (Id) = E_Procedure\n@@ -8577,18 +8636,6 @@ package body Einfo is\n                Write_Str (\"Overridden_Operation\");\n             end if;\n \n-         when E_Record_Type                                |\n-              E_Record_Type_With_Private                   =>\n-            Write_Str (\"Dispatch_Table_Wrappers\");\n-\n-         when E_In_Out_Parameter                           |\n-              E_Out_Parameter                              |\n-              E_Variable                                   =>\n-            Write_Str (\"Last_Assignment\");\n-\n-         when Task_Kind                                    =>\n-            Write_Str (\"Relative_Deadline_Variable\");\n-\n          when others                                       =>\n             Write_Str (\"Field26??\");\n       end case;\n@@ -8601,6 +8648,10 @@ package body Einfo is\n    procedure Write_Field27_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Package                                    |\n+              Type_Kind                                    =>\n+            Write_Str (\"Current_Use_Clause\");\n+\n          when E_Component                                  |\n               E_Constant                                   |\n               E_Variable                                   =>\n@@ -8609,9 +8660,6 @@ package body Einfo is\n          when E_Procedure                                  =>\n             Write_Str (\"Wrapped_Entity\");\n \n-         when E_Package | Type_Kind                        =>\n-            Write_Str (\"Current_Use_Clause\");\n-\n          when others                                       =>\n             Write_Str (\"Field27??\");\n       end case;\n@@ -8624,7 +8672,9 @@ package body Einfo is\n    procedure Write_Field28_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Procedure | E_Function | E_Entry           =>\n+         when E_Procedure                                  |\n+              E_Function                                   |\n+              E_Entry                                      =>\n             Write_Str (\"Extra_Formals\");\n \n          when E_Record_Type =>"}, {"sha": "3fa3751970110415595147c571e56fe687184f1c", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 133, "deletions": 81, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -427,6 +427,12 @@ package Einfo is\n --       definition clause with an (obsolescent) mod clause is converted\n --       into an attribute definition clause for this purpose.\n \n+--    Associated_Collection (Node23)\n+--       Present in non-subprogram access type entities. Contains the entity of\n+--       the finalization collection on which dynamically allocated objects\n+--       referenced by the access type are stored. Empty when the access type\n+--       cannot reference a controlled object.\n+\n --    Associated_Formal_Package (Node12)\n --       Present in packages that are the actuals of formal_packages. Points\n --       to the entity in the declaration for the formal package.\n@@ -450,12 +456,6 @@ package Einfo is\n --       only in the root type, since derived types must have the same pool\n --       as the parent type.\n \n---    Associated_Final_Chain (Node23)\n---       Present in simple and general access type entities. References the\n---       List_Controller object that holds the finalization chain on which\n---       are attached dynamically allocated objects referenced by the access\n---       type. Empty when the access type cannot reference a controlled object.\n-\n --    Barrier_Function (Node12)\n --       Present in protected entries and entry families. This is the\n --       subprogram declaration for the body of the function that returns\n@@ -521,6 +521,37 @@ package Einfo is\n --       ??? This is also set on some access types, eg the Etype of the\n --       anonymous access type of a controlling formal.\n \n+--    Can_Use_Internal_Rep (Flag229) [base type only]\n+--       Present in Access_Subprogram_Kind nodes. This flag is set by the\n+--       front end and used by the back end. False means that the back end\n+--       must represent the type in the same way as Convention-C types (and\n+--       other foreign-convention types). On many targets, this means that\n+--       the back end will use dynamically generated trampolines for nested\n+--       subprograms. True means that the back end can represent the type in\n+--       some internal way. On the aforementioned targets, this means that the\n+--       back end will not use dynamically generated trampolines. This flag\n+--       must be False if Has_Foreign_Convention is True; otherwise, the front\n+--       end is free to set the policy.\n+--\n+--       Setting this False in all cases corresponds to the traditional back\n+--       end strategy, where all access-to-subprogram types are represented the\n+--       same way, independent of the Convention. See also\n+--       Always_Compatible_Rep in Targparm.\n+--\n+--       Efficiency note: On targets that use dynamically generated\n+--       trampolines, False generally favors efficiency of top-level\n+--       subprograms, whereas True generally favors efficiency of nested\n+--       ones. On other targets, this flag has little or no effect on\n+--       efficiency. The front end should take this into account. In\n+--       particular, pragma Favor_Top_Level gives a hint that the flag should\n+--       be False.\n+--\n+--       Note: We considered using Convention-C for this purpose, but we need\n+--       this separate flag, because Convention-C implies that for\n+--       P'[Unrestricted_]Access, P also have convention C. Sometimes we want\n+--       to have Can_Use_Internal_Rep False for an access type, but allow P to\n+--       have convention Ada.\n+\n --    Chars (Name1)\n --       Present in all entities. This field contains an entry into the names\n --       table that has the character string of the identifier, character\n@@ -1111,49 +1142,6 @@ package Einfo is\n --       must be retrieved through the entity designed by this field instead of\n --       being computed.\n \n---    Can_Use_Internal_Rep (Flag229) [base type only]\n---       Present in Access_Subprogram_Kind nodes. This flag is set by the\n---       front end and used by the back end. False means that the back end\n---       must represent the type in the same way as Convention-C types (and\n---       other foreign-convention types). On many targets, this means that\n---       the back end will use dynamically generated trampolines for nested\n---       subprograms. True means that the back end can represent the type in\n---       some internal way. On the aforementioned targets, this means that the\n---       back end will not use dynamically generated trampolines. This flag\n---       must be False if Has_Foreign_Convention is True; otherwise, the front\n---       end is free to set the policy.\n---\n---       Setting this False in all cases corresponds to the traditional back\n---       end strategy, where all access-to-subprogram types are represented the\n---       same way, independent of the Convention. See also\n---       Always_Compatible_Rep in Targparm.\n---\n---       Efficiency note: On targets that use dynamically generated\n---       trampolines, False generally favors efficiency of top-level\n---       subprograms, whereas True generally favors efficiency of nested\n---       ones. On other targets, this flag has little or no effect on\n---       efficiency. The front end should take this into account. In\n---       particular, pragma Favor_Top_Level gives a hint that the flag should\n---       be False.\n---\n---       Note: We considered using Convention-C for this purpose, but we need\n---       this separate flag, because Convention-C implies that for\n---       P'[Unrestricted_]Access, P also have convention C. Sometimes we want\n---       to have Can_Use_Internal_Rep False for an access type, but allow P to\n---       have convention Ada.\n-\n---    Finalization_Chain_Entity (Node19)\n---       Present in scopes that can have finalizable entities (blocks,\n---       functions, procedures, tasks, entries, return statements). When this\n---       field is empty it means that there are no finalization actions to\n---       perform on exit of the scope. When this field contains 'Error', it\n---       means that no finalization actions should happen at this level and\n---       the finalization chain of a parent scope shall be used (??? this is\n---       an improper use of 'Error' and should be changed). Otherwise it\n---       contains an entity of type Finalizable_Ptr that is the head of the\n---       list of objects to finalize on exit. See \"Finalization Management\"\n---       section in exp_ch7.adb for more details.\n-\n --    Finalize_Storage_Only (Flag158) [base type only]\n --       Present in all types. Set on direct controlled types to which a\n --       valid Finalize_Storage_Only pragma applies. This flag is also set on\n@@ -1163,6 +1151,11 @@ package Einfo is\n --       the Finalize_Storage_Only pragma is required at each level of\n --       derivation.\n \n+--    Finalizer (Node24)\n+--       Applies to package declarations and bodies. Contains the entity of the\n+--       library-level program which finalizes all package-level controlled\n+--       objects.\n+\n --    First_Component (synthesized)\n --       Applies to record types. Returns the first component by following the\n --       chain of declared entities for the record until a component is found\n@@ -1564,13 +1557,6 @@ package Einfo is\n --       control wrapping of the body in Exp_Ch6 to ensure that the program\n --       error exception is correctly raised in this case at runtime.\n \n---    Has_Up_Level_Access (Flag215)\n---      Present in E_Variable and E_Constant entities. Set if the entity\n---      is a local variable declared in a subprogram p and is accessed in\n---      a subprogram nested inside p. Currently this flag is only set when\n---      VM_Target /= No_VM, for efficiency, since only the .NET back-end\n---      makes use of it to generate proper code for up-level references.\n-\n --    Has_Nested_Block_With_Handler (Flag101)\n --       Present in scope entities. Set if there is a nested block within the\n --       scope that has an exception handler and the two scopes are in the\n@@ -1838,6 +1824,13 @@ package Einfo is\n --       on the partial view, to insure that discriminants are properly\n --       inherited in certain contexts.\n \n+--    Has_Up_Level_Access (Flag215)\n+--      Present in E_Variable and E_Constant entities. Set if the entity\n+--      is a local variable declared in a subprogram p and is accessed in\n+--      a subprogram nested inside p. Currently this flag is only set when\n+--      VM_Target /= No_VM, for efficiency, since only the .NET back-end\n+--      makes use of it to generate proper code for up-level references.\n+\n --    Has_Volatile_Components (Flag87) [implementation base type only]\n --       Present in all types and objects. Set only for an array type or array\n --       object if a valid pragma Volatile_Components or a valid pragma\n@@ -2185,6 +2178,10 @@ package Einfo is\n --       and variables, but that may well change later on. Exceptions can only\n --       be exported in the OpenVMS and Java VM implementations of GNAT.\n \n+--    Is_Finalizer (synthesized)\n+--       Applies to all entities, true for procedures containing finalization\n+--       code to process local or library level objects.\n+\n --    Is_First_Subtype (Flag70)\n --       Present in all entities. True for first subtypes (RM 3.2.1(6)),\n --       i.e. the entity in the type declaration that introduced the type.\n@@ -2618,6 +2615,12 @@ package Einfo is\n --       Applies to all entities, true for private types and subtypes,\n --       as well as for record with private types as subtypes\n \n+--    Is_Processed_Transient (Flag252)\n+--      Present in entities of variables and constants. Set when a transient\n+--      object needs to be finalized and it has already been processed by the\n+--      transient scope machinery. This flag signals the general finalization\n+--      mechanism to ignore the transient object.\n+\n --    Is_Protected_Component (synthesized)\n --       Applicable to all entities, true if the entity denotes a private\n --       component of a protected type.\n@@ -3480,6 +3483,12 @@ package Einfo is\n --       is True only for implicitly declare subprograms; it is not set on the\n --       parent type's subprogram. See also Is_Abstract_Subprogram.\n \n+--    Return_Flag (Node15)\n+--       Applies to variables and constants. Set for objects which act as the\n+--       return value of an extended return statement. The node contains the\n+--       entity of a locally declared flag which controls the finalization of\n+--       the return object should the function fail.\n+\n --    Return_Present (Flag54)\n --       Present in function and generic function entities. Set if the\n --       function contains a return statement (used for error checking).\n@@ -3869,7 +3878,40 @@ package Einfo is\n \n --    Wrapped_Entity (Node27)\n --       Present in functions and procedures which have been classified as\n---       Is_Primitive_Wrapper. Set to the entity being wrapped.\n+--       Is_Primitive_Wrapper. Set to the entity being wrapper.\n+\n+--------------------------------------\n+-- Delayed Freezing and Elaboration --\n+--------------------------------------\n+\n+--  The flag Has_Delayed_Freeze indicates that an entity carries an explicit\n+--  freeze node, which appears later in the expanded tree.\n+\n+--  a)   The flag is used by the front-end to trigger expansion actions\n+--  which include the generation of that freeze node. Typically this happens at\n+--  the end of the current compilation unit, or before the first subprogram\n+--  body is encountered in the current unit. See files freeze and exp_ch13 for\n+--  details on the actions triggered by a freeze node, which include the\n+--  construction of initialization procedures and dispatch tables.\n+\n+--  b) The flag is used by the backend to defer elaboration of the entity until\n+--  its freeze node is seen.  In the absence of an explicit freeze node, an\n+--  entity is frozen (and elaborated) at the point of declaration.\n+\n+--  For object declarations, the flag is set when an address clause for the\n+--  object is encountered. Legality checks on the address expression only\n+--  take place at the freeze point of the object.\n+\n+--  Most types have an explicit freeze node, because they cannot be elaborated\n+--  until all representation and operational items that apply to them have been\n+--  analyzed. Private types and incomplete types have the flag set as well, as\n+--  do task and protected types.\n+\n+--  Implicit base types created for type derivations, as well as classwide\n+--  types created for all tagged types, have the flag set.\n+\n+--  If a subprogram has an access parameter whose designated type is incomplete\n+--  the subprogram has the flag set.\n \n    ------------------\n    -- Access Kinds --\n@@ -4903,8 +4945,8 @@ package Einfo is\n    --    Storage_Size_Variable               (Node15)   (base type only)\n    --    Master_Id                           (Node17)\n    --    Directly_Designated_Type            (Node20)\n-   --    Associated_Storage_Pool             (Node22)   (root type only)\n-   --    Associated_Final_Chain              (Node23)\n+   --    Associated_Storage_Pool             (Node22)   (base type only)\n+   --    Associated_Collection               (Node23)   (base type only)\n    --    Has_Pragma_Controlled               (Flag27)   (base type only)\n    --    Has_Storage_Size_Clause             (Flag23)   (base type only)\n    --    Is_Access_Constant                  (Flag69)\n@@ -4932,6 +4974,7 @@ package Einfo is\n    --  E_Anonymous_Access_Type\n    --    Storage_Size_Variable               (Node15)   ??? is this needed ???\n    --    Directly_Designated_Type            (Node20)\n+   --    Associated_Collection               (Node23)\n    --    (plus type attributes)\n \n    --  E_Array_Type\n@@ -4955,7 +4998,6 @@ package Einfo is\n    --    Block_Node                          (Node11)\n    --    First_Entity                        (Node17)\n    --    Last_Entity                         (Node20)\n-   --    Finalization_Chain_Entity           (Node19)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Entry_Cancel_Parameter              (Node23)\n    --    Delay_Cleanups                      (Flag114)\n@@ -5011,6 +5053,7 @@ package Einfo is\n    --    Full_View                           (Node11)\n    --    Esize                               (Uint12)\n    --    Alignment                           (Uint14)\n+   --    Return_Flag                         (Node15)   (constants only)\n    --    Actual_Subtype                      (Node17)\n    --    Renamed_Object                      (Node18)\n    --    Size_Check_Code                     (Node19)   (constants only)\n@@ -5027,6 +5070,7 @@ package Einfo is\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n+   --    Is_Processed_Transient              (Flag252)  (constants only)\n    --    Is_Return_Object                    (Flag209)\n    --    Is_True_Constant                    (Flag163)\n    --    Is_Volatile                         (Flag16)\n@@ -5079,7 +5123,6 @@ package Einfo is\n    --    Entry_Parameters_Type               (Node15)\n    --    First_Entity                        (Node17)\n    --    Alias                               (Node18)   (for entry only. Empty)\n-   --    Finalization_Chain_Entity           (Node19)\n    --    Last_Entity                         (Node20)\n    --    Accept_Address                      (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n@@ -5178,7 +5221,6 @@ package Einfo is\n    --    First_Entity                        (Node17)\n    --    Alias                               (Node18)   (non-generic case only)\n    --    Renamed_Entity                      (Node18)   (generic case only)\n-   --    Finalization_Chain_Entity           (Node19)\n    --    Last_Entity                         (Node20)\n    --    Interface_Name                      (Node21)\n    --    Scope_Depth_Value                   (Uint22)\n@@ -5239,7 +5281,7 @@ package Einfo is\n    --    Master_Id                           (Node17)\n    --    Directly_Designated_Type            (Node20)\n    --    Associated_Storage_Pool             (Node22)   (root type only)\n-   --    Associated_Final_Chain              (Node23)\n+   --    Associated_Collection               (Node23)\n    --    (plus type attributes)\n \n    --  E_Generic_In_Parameter\n@@ -5377,6 +5419,7 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Limited_View                        (Node23)   (non-generic/instance)\n+   --    Finalizer                           (Node24)   (non-generic case only)\n    --    Current_Use_Clause                  (Node27)\n    --    Package_Instantiation               (Node26)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n@@ -5408,6 +5451,7 @@ package Einfo is\n    --    Spec_Entity                         (Node19)\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n+   --    Finalizer                           (Node24)   (non-generic case only)\n    --    Scope_Depth                         (synth)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Has_Subprogram_Descriptor           (Flag93)\n@@ -5441,7 +5485,6 @@ package Einfo is\n    --    First_Entity                        (Node17)\n    --    Alias                               (Node18)   (non-generic case only)\n    --    Renamed_Entity                      (Node18)   (generic case only)\n-   --    Finalization_Chain_Entity           (Node19)\n    --    Last_Entity                         (Node20)\n    --    Interface_Name                      (Node21)\n    --    Scope_Depth_Value                   (Uint22)\n@@ -5493,6 +5536,7 @@ package Einfo is\n    --    Address_Clause                      (synth)\n    --    First_Formal                        (synth)\n    --    First_Formal_With_Extras            (synth)\n+   --    Is_Finalizer                        (synth)\n    --    Last_Formal                         (synth)\n    --    Number_Formals                      (synth)\n \n@@ -5508,7 +5552,6 @@ package Einfo is\n    --    First_Private_Entity                (Node16)\n    --    First_Entity                        (Node17)\n    --    Corresponding_Record_Type           (Node18)\n-   --    Finalization_Chain_Entity           (Node19)\n    --    Last_Entity                         (Node20)\n    --    Discriminant_Constraint             (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n@@ -5581,7 +5624,6 @@ package Einfo is\n \n    --  E_Return_Statement\n    --    Return_Applies_To                   (Node8)\n-   --    Finalization_Chain_Entity           (Node19)\n \n    --  E_Signed_Integer_Type\n    --  E_Signed_Integer_Subtype\n@@ -5634,7 +5676,6 @@ package Einfo is\n    --    First_Private_Entity                (Node16)\n    --    First_Entity                        (Node17)\n    --    Corresponding_Record_Type           (Node18)\n-   --    Finalization_Chain_Entity           (Node19)\n    --    Last_Entity                         (Node20)\n    --    Discriminant_Constraint             (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n@@ -5657,6 +5698,7 @@ package Einfo is\n    --    Esize                               (Uint12)\n    --    Extra_Accessibility                 (Node13)\n    --    Alignment                           (Uint14)\n+   --    Return_Flag                         (Node15)   (transient object only)\n    --    Unset_Reference                     (Node16)\n    --    Actual_Subtype                      (Node17)\n    --    Renamed_Object                      (Node18)\n@@ -5678,6 +5720,7 @@ package Einfo is\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n+   --    Is_Processed_Transient              (Flag252)\n    --    Is_Safe_To_Reevaluate               (Flag249)\n    --    Is_Shared_Passive                   (Flag60)\n    --    Is_True_Constant                    (Flag163)\n@@ -5932,7 +5975,7 @@ package Einfo is\n    function Address_Taken                       (Id : E) return B;\n    function Alias                               (Id : E) return E;\n    function Alignment                           (Id : E) return U;\n-   function Associated_Final_Chain              (Id : E) return E;\n+   function Associated_Collection               (Id : E) return E;\n    function Associated_Formal_Package           (Id : E) return E;\n    function Associated_Node_For_Itype           (Id : E) return N;\n    function Associated_Storage_Pool             (Id : E) return E;\n@@ -6008,8 +6051,8 @@ package Einfo is\n    function Extra_Formal                        (Id : E) return E;\n    function Extra_Formals                       (Id : E) return E;\n    function Can_Use_Internal_Rep                (Id : E) return B;\n-   function Finalization_Chain_Entity           (Id : E) return E;\n    function Finalize_Storage_Only               (Id : E) return B;\n+   function Finalizer                           (Id : E) return E;\n    function First_Entity                        (Id : E) return E;\n    function First_Exit_Statement                (Id : E) return N;\n    function First_Index                         (Id : E) return N;\n@@ -6047,6 +6090,7 @@ package Einfo is\n    function Has_Enumeration_Rep_Clause          (Id : E) return B;\n    function Has_Exit                            (Id : E) return B;\n    function Has_External_Tag_Rep_Clause         (Id : E) return B;\n+   function Has_Forward_Instantiation           (Id : E) return B;\n    function Has_Fully_Qualified_Name            (Id : E) return B;\n    function Has_Gigi_Rep_Item                   (Id : E) return B;\n    function Has_Homonym                         (Id : E) return B;\n@@ -6058,8 +6102,6 @@ package Einfo is\n    function Has_Master_Entity                   (Id : E) return B;\n    function Has_Missing_Return                  (Id : E) return B;\n    function Has_Nested_Block_With_Handler       (Id : E) return B;\n-   function Has_Forward_Instantiation           (Id : E) return B;\n-   function Has_Up_Level_Access                 (Id : E) return B;\n    function Has_Non_Standard_Rep                (Id : E) return B;\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Per_Object_Constraint           (Id : E) return B;\n@@ -6099,6 +6141,7 @@ package Einfo is\n    function Has_Thunks                          (Id : E) return B;\n    function Has_Unchecked_Union                 (Id : E) return B;\n    function Has_Unknown_Discriminants           (Id : E) return B;\n+   function Has_Up_Level_Access                 (Id : E) return B;\n    function Has_Volatile_Components             (Id : E) return B;\n    function Has_Xref_Entry                      (Id : E) return B;\n    function Hiding_Loop_Variable                (Id : E) return E;\n@@ -6177,6 +6220,7 @@ package Einfo is\n    function Is_Private_Composite                (Id : E) return B;\n    function Is_Private_Descendant               (Id : E) return B;\n    function Is_Private_Primitive                (Id : E) return B;\n+   function Is_Processed_Transient              (Id : E) return B;\n    function Is_Public                           (Id : E) return B;\n    function Is_Pure                             (Id : E) return B;\n    function Is_Pure_Unit_Access_Type            (Id : E) return B;\n@@ -6271,6 +6315,7 @@ package Einfo is\n    function Renamed_Object                      (Id : E) return N;\n    function Renaming_Map                        (Id : E) return U;\n    function Requires_Overriding                 (Id : E) return B;\n+   function Return_Flag                         (Id : E) return E;\n    function Return_Present                      (Id : E) return B;\n    function Return_Applies_To                   (Id : E) return N;\n    function Returns_By_Ref                      (Id : E) return B;\n@@ -6402,6 +6447,7 @@ package Einfo is\n    function Is_Constant_Object                  (Id : E) return B;\n    function Is_Discriminal                      (Id : E) return B;\n    function Is_Dynamic_Scope                    (Id : E) return B;\n+   function Is_Finalizer                        (Id : E) return B;\n    function Is_Package_Or_Generic_Package       (Id : E) return B;\n    function Is_Prival                           (Id : E) return B;\n    function Is_Protected_Component              (Id : E) return B;\n@@ -6519,7 +6565,7 @@ package Einfo is\n    procedure Set_Address_Taken                   (Id : E; V : B := True);\n    procedure Set_Alias                           (Id : E; V : E);\n    procedure Set_Alignment                       (Id : E; V : U);\n-   procedure Set_Associated_Final_Chain          (Id : E; V : E);\n+   procedure Set_Associated_Collection           (Id : E; V : E);\n    procedure Set_Associated_Formal_Package       (Id : E; V : E);\n    procedure Set_Associated_Node_For_Itype       (Id : E; V : N);\n    procedure Set_Associated_Storage_Pool         (Id : E; V : E);\n@@ -6593,8 +6639,8 @@ package Einfo is\n    procedure Set_Extra_Formal                    (Id : E; V : E);\n    procedure Set_Extra_Formals                   (Id : E; V : E);\n    procedure Set_Can_Use_Internal_Rep            (Id : E; V : B := True);\n-   procedure Set_Finalization_Chain_Entity       (Id : E; V : E);\n    procedure Set_Finalize_Storage_Only           (Id : E; V : B := True);\n+   procedure Set_Finalizer                       (Id : E; V : E);\n    procedure Set_First_Entity                    (Id : E; V : E);\n    procedure Set_First_Exit_Statement            (Id : E; V : N);\n    procedure Set_First_Index                     (Id : E; V : N);\n@@ -6632,6 +6678,7 @@ package Einfo is\n    procedure Set_Has_Enumeration_Rep_Clause      (Id : E; V : B := True);\n    procedure Set_Has_Exit                        (Id : E; V : B := True);\n    procedure Set_Has_External_Tag_Rep_Clause     (Id : E; V : B := True);\n+   procedure Set_Has_Forward_Instantiation       (Id : E; V : B := True);\n    procedure Set_Has_Fully_Qualified_Name        (Id : E; V : B := True);\n    procedure Set_Has_Gigi_Rep_Item               (Id : E; V : B := True);\n    procedure Set_Has_Homonym                     (Id : E; V : B := True);\n@@ -6642,8 +6689,6 @@ package Einfo is\n    procedure Set_Has_Master_Entity               (Id : E; V : B := True);\n    procedure Set_Has_Missing_Return              (Id : E; V : B := True);\n    procedure Set_Has_Nested_Block_With_Handler   (Id : E; V : B := True);\n-   procedure Set_Has_Forward_Instantiation       (Id : E; V : B := True);\n-   procedure Set_Has_Up_Level_Access             (Id : E; V : B := True);\n    procedure Set_Has_Non_Standard_Rep            (Id : E; V : B := True);\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint       (Id : E; V : B := True);\n@@ -6684,6 +6729,7 @@ package Einfo is\n    procedure Set_Has_Thunks                      (Id : E; V : B := True);\n    procedure Set_Has_Unchecked_Union             (Id : E; V : B := True);\n    procedure Set_Has_Unknown_Discriminants       (Id : E; V : B := True);\n+   procedure Set_Has_Up_Level_Access             (Id : E; V : B := True);\n    procedure Set_Has_Volatile_Components         (Id : E; V : B := True);\n    procedure Set_Has_Xref_Entry                  (Id : E; V : B := True);\n    procedure Set_Hiding_Loop_Variable            (Id : E; V : E);\n@@ -6768,6 +6814,7 @@ package Einfo is\n    procedure Set_Is_Private_Composite            (Id : E; V : B := True);\n    procedure Set_Is_Private_Descendant           (Id : E; V : B := True);\n    procedure Set_Is_Private_Primitive            (Id : E; V : B := True);\n+   procedure Set_Is_Processed_Transient          (Id : E; V : B := True);\n    procedure Set_Is_Public                       (Id : E; V : B := True);\n    procedure Set_Is_Pure                         (Id : E; V : B := True);\n    procedure Set_Is_Pure_Unit_Access_Type        (Id : E; V : B := True);\n@@ -6862,6 +6909,7 @@ package Einfo is\n    procedure Set_Renamed_Object                  (Id : E; V : N);\n    procedure Set_Renaming_Map                    (Id : E; V : U);\n    procedure Set_Requires_Overriding             (Id : E; V : B := True);\n+   procedure Set_Return_Flag                     (Id : E; V : E);\n    procedure Set_Return_Present                  (Id : E; V : B := True);\n    procedure Set_Return_Applies_To               (Id : E; V : N);\n    procedure Set_Returns_By_Ref                  (Id : E; V : B := True);\n@@ -7213,7 +7261,7 @@ package Einfo is\n    pragma Inline (Address_Taken);\n    pragma Inline (Alias);\n    pragma Inline (Alignment);\n-   pragma Inline (Associated_Final_Chain);\n+   pragma Inline (Associated_Collection);\n    pragma Inline (Associated_Formal_Package);\n    pragma Inline (Associated_Node_For_Itype);\n    pragma Inline (Associated_Storage_Pool);\n@@ -7289,7 +7337,7 @@ package Einfo is\n    pragma Inline (Extra_Formal);\n    pragma Inline (Extra_Formals);\n    pragma Inline (Can_Use_Internal_Rep);\n-   pragma Inline (Finalization_Chain_Entity);\n+   pragma Inline (Finalizer);\n    pragma Inline (First_Entity);\n    pragma Inline (First_Exit_Statement);\n    pragma Inline (First_Index);\n@@ -7326,6 +7374,7 @@ package Einfo is\n    pragma Inline (Has_Enumeration_Rep_Clause);\n    pragma Inline (Has_Exit);\n    pragma Inline (Has_External_Tag_Rep_Clause);\n+   pragma Inline (Has_Forward_Instantiation);\n    pragma Inline (Has_Fully_Qualified_Name);\n    pragma Inline (Has_Gigi_Rep_Item);\n    pragma Inline (Has_Homonym);\n@@ -7336,7 +7385,6 @@ package Einfo is\n    pragma Inline (Has_Master_Entity);\n    pragma Inline (Has_Missing_Return);\n    pragma Inline (Has_Nested_Block_With_Handler);\n-   pragma Inline (Has_Forward_Instantiation);\n    pragma Inline (Has_Non_Standard_Rep);\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Per_Object_Constraint);\n@@ -7495,6 +7543,7 @@ package Einfo is\n    pragma Inline (Is_Private_Descendant);\n    pragma Inline (Is_Private_Primitive);\n    pragma Inline (Is_Private_Type);\n+   pragma Inline (Is_Processed_Transient);\n    pragma Inline (Is_Protected_Type);\n    pragma Inline (Is_Public);\n    pragma Inline (Is_Pure);\n@@ -7598,6 +7647,7 @@ package Einfo is\n    pragma Inline (Renamed_Object);\n    pragma Inline (Renaming_Map);\n    pragma Inline (Requires_Overriding);\n+   pragma Inline (Return_Flag);\n    pragma Inline (Return_Present);\n    pragma Inline (Return_Applies_To);\n    pragma Inline (Returns_By_Ref);\n@@ -7655,7 +7705,7 @@ package Einfo is\n    pragma Inline (Set_Address_Taken);\n    pragma Inline (Set_Alias);\n    pragma Inline (Set_Alignment);\n-   pragma Inline (Set_Associated_Final_Chain);\n+   pragma Inline (Set_Associated_Collection);\n    pragma Inline (Set_Associated_Formal_Package);\n    pragma Inline (Set_Associated_Node_For_Itype);\n    pragma Inline (Set_Associated_Storage_Pool);\n@@ -7730,7 +7780,7 @@ package Einfo is\n    pragma Inline (Set_Extra_Formal);\n    pragma Inline (Set_Extra_Formals);\n    pragma Inline (Set_Can_Use_Internal_Rep);\n-   pragma Inline (Set_Finalization_Chain_Entity);\n+   pragma Inline (Set_Finalizer);\n    pragma Inline (Set_First_Entity);\n    pragma Inline (Set_First_Exit_Statement);\n    pragma Inline (Set_First_Index);\n@@ -7767,6 +7817,7 @@ package Einfo is\n    pragma Inline (Set_Has_Enumeration_Rep_Clause);\n    pragma Inline (Set_Has_Exit);\n    pragma Inline (Set_Has_External_Tag_Rep_Clause);\n+   pragma Inline (Set_Has_Forward_Instantiation);\n    pragma Inline (Set_Has_Fully_Qualified_Name);\n    pragma Inline (Set_Has_Gigi_Rep_Item);\n    pragma Inline (Set_Has_Homonym);\n@@ -7777,7 +7828,6 @@ package Einfo is\n    pragma Inline (Set_Has_Master_Entity);\n    pragma Inline (Set_Has_Missing_Return);\n    pragma Inline (Set_Has_Nested_Block_With_Handler);\n-   pragma Inline (Set_Has_Forward_Instantiation);\n    pragma Inline (Set_Has_Non_Standard_Rep);\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Per_Object_Constraint);\n@@ -7903,6 +7953,7 @@ package Einfo is\n    pragma Inline (Set_Is_Private_Composite);\n    pragma Inline (Set_Is_Private_Descendant);\n    pragma Inline (Set_Is_Private_Primitive);\n+   pragma Inline (Set_Is_Processed_Transient);\n    pragma Inline (Set_Is_Public);\n    pragma Inline (Set_Is_Pure);\n    pragma Inline (Set_Is_Pure_Unit_Access_Type);\n@@ -7995,6 +8046,7 @@ package Einfo is\n    pragma Inline (Set_Renamed_Object);\n    pragma Inline (Set_Renaming_Map);\n    pragma Inline (Set_Requires_Overriding);\n+   pragma Inline (Set_Return_Flag);\n    pragma Inline (Set_Return_Present);\n    pragma Inline (Set_Return_Applies_To);\n    pragma Inline (Set_Returns_By_Ref);"}, {"sha": "a38eb597f0880f9b859b5a18f5263df603dab8cb", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 155, "deletions": 625, "changes": 780, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -73,6 +73,14 @@ package body Exp_Aggr is\n    type Case_Table_Type is array (Nat range <>) of Case_Bounds;\n    --  Table type used by Check_Case_Choices procedure\n \n+   function Has_Default_Init_Comps (N : Node_Id) return Boolean;\n+   --  N is an aggregate (record or array). Checks the presence of default\n+   --  initialization (<>) in any component (Ada 2005: AI-287).\n+\n+   function Is_Static_Dispatch_Table_Aggregate (N : Node_Id) return Boolean;\n+   --  Returns true if N is an aggregate used to initialize the components\n+   --  of an statically allocated dispatch table.\n+\n    function Must_Slide\n      (Obj_Type : Entity_Id;\n       Typ      : Entity_Id) return Boolean;\n@@ -93,18 +101,29 @@ package body Exp_Aggr is\n    --  statement of variant part will usually be small and probably in near\n    --  sorted order.\n \n-   function Has_Default_Init_Comps (N : Node_Id) return Boolean;\n-   --  N is an aggregate (record or array). Checks the presence of default\n-   --  initialization (<>) in any component (Ada 2005: AI-287).\n-\n-   function Is_Static_Dispatch_Table_Aggregate (N : Node_Id) return Boolean;\n-   --  Returns true if N is an aggregate used to initialize the components\n-   --  of an statically allocated dispatch table.\n-\n    ------------------------------------------------------\n    -- Local subprograms for Record Aggregate Expansion --\n    ------------------------------------------------------\n \n+   function Build_Record_Aggr_Code\n+     (N                             : Node_Id;\n+      Typ                           : Entity_Id;\n+      Lhs                           : Node_Id;\n+      Is_Limited_Ancestor_Expansion : Boolean   := False) return List_Id;\n+   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of the\n+   --  aggregate. Target is an expression containing the location on which the\n+   --  component by component assignments will take place. Returns the list of\n+   --  assignments plus all other adjustments needed for tagged and controlled\n+   --  types. Is_Limited_Ancestor_Expansion indicates that the function has\n+   --  been called recursively to expand the limited ancestor to avoid copying\n+   --  it.\n+\n+   procedure Convert_To_Assignments (N : Node_Id; Typ : Entity_Id);\n+   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of the\n+   --  aggregate (which can only be a record type, this procedure is only used\n+   --  for record types). Transform the given aggregate into a sequence of\n+   --  assignments performed component by component.\n+\n    procedure Expand_Record_Aggregate\n      (N           : Node_Id;\n       Orig_Tag    : Node_Id := Empty;\n@@ -122,37 +141,6 @@ package body Exp_Aggr is\n    --    Parent_Expr is the ancestor part of the original extension\n    --      aggregate\n \n-   procedure Convert_To_Assignments (N : Node_Id; Typ : Entity_Id);\n-   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of the\n-   --  aggregate (which can only be a record type, this procedure is only used\n-   --  for record types). Transform the given aggregate into a sequence of\n-   --  assignments performed component by component.\n-\n-   function Build_Record_Aggr_Code\n-     (N                             : Node_Id;\n-      Typ                           : Entity_Id;\n-      Lhs                           : Node_Id;\n-      Flist                         : Node_Id   := Empty;\n-      Obj                           : Entity_Id := Empty;\n-      Is_Limited_Ancestor_Expansion : Boolean   := False) return List_Id;\n-   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of the\n-   --  aggregate. Target is an expression containing the location on which the\n-   --  component by component assignments will take place. Returns the list of\n-   --  assignments plus all other adjustments needed for tagged and controlled\n-   --  types. Flist is an expression representing the finalization list on\n-   --  which to attach the controlled components if any. Obj is present in the\n-   --  object declaration and dynamic allocation cases, it contains an entity\n-   --  that allows to know if the value being created needs to be attached to\n-   --  the final list in case of pragma Finalize_Storage_Only.\n-   --\n-   --  ???\n-   --  The meaning of the Obj formal is extremely unclear. *What* entity\n-   --  should be passed? For the object declaration case we may guess that\n-   --  this is the object being declared, but what about the allocator case?\n-   --\n-   --  Is_Limited_Ancestor_Expansion indicates that the function has been\n-   --  called recursively to expand the limited ancestor to avoid copying it.\n-\n    function Has_Mutable_Components (Typ : Entity_Id) return Boolean;\n    --  Return true if one of the component is of a discriminated type with\n    --  defaults. An aggregate for a type with mutable components must be\n@@ -185,6 +173,35 @@ package body Exp_Aggr is\n    --  appear in a non-static context. Even if the component value is static,\n    --  such an aggregate must be expanded into an assignment.\n \n+   function Backend_Processing_Possible (N : Node_Id) return Boolean;\n+   --  This function checks if array aggregate N can be processed directly\n+   --  by the backend. If this is the case True is returned.\n+\n+   function Build_Array_Aggr_Code\n+     (N           : Node_Id;\n+      Ctype       : Entity_Id;\n+      Index       : Node_Id;\n+      Into        : Node_Id;\n+      Scalar_Comp : Boolean;\n+      Indexes     : List_Id := No_List) return List_Id;\n+   --  This recursive routine returns a list of statements containing the\n+   --  loops and assignments that are needed for the expansion of the array\n+   --  aggregate N.\n+   --\n+   --    N is the (sub-)aggregate node to be expanded into code. This node has\n+   --    been fully analyzed, and its Etype is properly set.\n+   --\n+   --    Index is the index node corresponding to the array sub-aggregate N\n+   --\n+   --    Into is the target expression into which we are copying the aggregate.\n+   --    Note that this node may not have been analyzed yet, and so the Etype\n+   --    field may not be set.\n+   --\n+   --    Scalar_Comp is True if the component type of the aggregate is scalar\n+   --\n+   --    Indexes is the current list of expressions used to index the object we\n+   --    are writing into.\n+\n    procedure Convert_Array_Aggr_In_Allocator\n      (Decl   : Node_Id;\n       Aggr   : Node_Id;\n@@ -218,60 +235,16 @@ package body Exp_Aggr is\n    --  This is the top-level routine to perform array aggregate expansion.\n    --  N is the N_Aggregate node to be expanded.\n \n-   function Backend_Processing_Possible (N : Node_Id) return Boolean;\n-   --  This function checks if array aggregate N can be processed directly\n-   --  by the backend. If this is the case True is returned.\n-\n-   function Build_Array_Aggr_Code\n-     (N           : Node_Id;\n-      Ctype       : Entity_Id;\n-      Index       : Node_Id;\n-      Into        : Node_Id;\n-      Scalar_Comp : Boolean;\n-      Indexes     : List_Id := No_List;\n-      Flist       : Node_Id := Empty) return List_Id;\n-   --  This recursive routine returns a list of statements containing the\n-   --  loops and assignments that are needed for the expansion of the array\n-   --  aggregate N.\n-   --\n-   --    N is the (sub-)aggregate node to be expanded into code. This node\n-   --    has been fully analyzed, and its Etype is properly set.\n-   --\n-   --    Index is the index node corresponding to the array sub-aggregate N.\n-   --\n-   --    Into is the target expression into which we are copying the aggregate.\n-   --    Note that this node may not have been analyzed yet, and so the Etype\n-   --    field may not be set.\n-   --\n-   --    Scalar_Comp is True if the component type of the aggregate is scalar.\n-   --\n-   --    Indexes is the current list of expressions used to index the\n-   --    object we are writing into.\n-   --\n-   --    Flist is an expression representing the finalization list on which\n-   --    to attach the controlled components if any.\n-\n-   function Number_Of_Choices (N : Node_Id) return Nat;\n-   --  Returns the number of discrete choices (not including the others choice\n-   --  if present) contained in (sub-)aggregate N.\n-\n    function Late_Expansion\n      (N      : Node_Id;\n       Typ    : Entity_Id;\n-      Target : Node_Id;\n-      Flist  : Node_Id := Empty;\n-      Obj    : Entity_Id := Empty) return List_Id;\n-   --  N is a nested (record or array) aggregate that has been marked with\n-   --  'Delay_Expansion'. Typ is the expected type of the aggregate and Target\n-   --  is a (duplicable) expression that will hold the result of the aggregate\n-   --  expansion. Flist is the finalization list to be used to attach\n-   --  controlled components. 'Obj' when non empty, carries the original\n-   --  object being initialized in order to know if it needs to be attached to\n-   --  the previous parameter which may not be the case in the case where\n-   --  Finalize_Storage_Only is set. Basically this procedure is used to\n-   --  implement top-down expansions of nested aggregates. This is necessary\n-   --  for avoiding temporaries at each level as well as for propagating the\n-   --  right internal finalization list.\n+      Target : Node_Id) return List_Id;\n+   --  This routine implements top-down expansion of nested aggregates. In\n+   --  doing so, it avoids the generation of temporaries at each level. N is a\n+   --  nested (record or array) aggregate that has been marked with 'Delay_\n+   --  Expansion'. Typ is the expected type of the aggregate. Target is a\n+   --  (duplicable) expression that will hold the result of the aggregate\n+   --  expansion.\n \n    function Make_OK_Assignment_Statement\n      (Sloc       : Source_Ptr;\n@@ -282,6 +255,10 @@ package body Exp_Aggr is\n    --  use this routine. This is needed to deal with assignments to\n    --  initialized constants that are done in place.\n \n+   function Number_Of_Choices (N : Node_Id) return Nat;\n+   --  Returns the number of discrete choices (not including the others choice\n+   --  if present) contained in (sub-)aggregate N.\n+\n    function Packed_Array_Aggregate_Handled (N : Node_Id) return Boolean;\n    --  Given an array aggregate, this function handles the case of a packed\n    --  array aggregate with all constant values, where the aggregate can be\n@@ -700,8 +677,7 @@ package body Exp_Aggr is\n       Index       : Node_Id;\n       Into        : Node_Id;\n       Scalar_Comp : Boolean;\n-      Indexes     : List_Id := No_List;\n-      Flist       : Node_Id := Empty) return List_Id\n+      Indexes     : List_Id := No_List) return List_Id\n    is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Index_Base   : constant Entity_Id  := Base_Type (Etype (Index));\n@@ -938,7 +914,6 @@ package body Exp_Aggr is\n \n       function Gen_Assign (Ind : Node_Id; Expr : Node_Id) return List_Id is\n          L : constant List_Id := New_List;\n-         F : Entity_Id;\n          A : Node_Id;\n \n          New_Indexes  : List_Id;\n@@ -989,21 +964,6 @@ package body Exp_Aggr is\n \n          Append_To (New_Indexes, Ind);\n \n-         if Present (Flist) then\n-            F := New_Copy_Tree (Flist);\n-\n-         elsif Present (Etype (N)) and then Needs_Finalization (Etype (N)) then\n-            if Is_Entity_Name (Into)\n-              and then Present (Scope (Entity (Into)))\n-            then\n-               F := Find_Final_List (Scope (Entity (Into)));\n-            else\n-               F := Find_Final_List (Current_Scope);\n-            end if;\n-         else\n-            F := Empty;\n-         end if;\n-\n          if Present (Next_Index (Index)) then\n             return\n               Add_Loop_Actions (\n@@ -1013,8 +973,7 @@ package body Exp_Aggr is\n                    Index       => Next_Index (Index),\n                    Into        => Into,\n                    Scalar_Comp => Scalar_Comp,\n-                   Indexes     => New_Indexes,\n-                   Flist       => F));\n+                   Indexes     => New_Indexes));\n          end if;\n \n          --  If we get here then we are at a bottom-level (sub-)aggregate\n@@ -1120,8 +1079,7 @@ package body Exp_Aggr is\n                else\n                   return\n                     Add_Loop_Actions (\n-                      Late_Expansion (\n-                        Expr_Q, Etype (Expr_Q), Indexed_Comp, F));\n+                      Late_Expansion (Expr_Q, Etype (Expr_Q), Indexed_Comp));\n                end if;\n             end if;\n          end if;\n@@ -1155,12 +1113,10 @@ package body Exp_Aggr is\n             end if;\n \n             if Needs_Finalization (Ctype) then\n-               Append_List_To (L,\n+               Append_To (L,\n                  Make_Init_Call (\n-                   Ref         => New_Copy_Tree (Indexed_Comp),\n-                   Typ         => Ctype,\n-                   Flist_Ref   => Find_Final_List (Current_Scope),\n-                   With_Attach => Make_Integer_Literal (Loc, 1)));\n+                   Obj_Ref => New_Copy_Tree (Indexed_Comp),\n+                   Typ     => Ctype));\n             end if;\n \n          else\n@@ -1252,12 +1208,10 @@ package body Exp_Aggr is\n                    and then Is_Controlled (Component_Type (Comp_Type))\n                    and then Nkind (Expr) = N_Aggregate)\n             then\n-               Append_List_To (L,\n+               Append_To (L,\n                  Make_Adjust_Call (\n-                   Ref         => New_Copy_Tree (Indexed_Comp),\n-                   Typ         => Comp_Type,\n-                   Flist_Ref   => F,\n-                   With_Attach => Make_Integer_Literal (Loc, 1)));\n+                   Obj_Ref => New_Copy_Tree (Indexed_Comp),\n+                   Typ     => Comp_Type));\n             end if;\n          end if;\n \n@@ -1780,9 +1734,7 @@ package body Exp_Aggr is\n      (N                             : Node_Id;\n       Typ                           : Entity_Id;\n       Lhs                           : Node_Id;\n-      Flist                         : Node_Id   := Empty;\n-      Obj                           : Entity_Id := Empty;\n-      Is_Limited_Ancestor_Expansion : Boolean   := False) return List_Id\n+      Is_Limited_Ancestor_Expansion : Boolean := False) return List_Id\n    is\n       Loc     : constant Source_Ptr := Sloc (N);\n       L       : constant List_Id    := New_List;\n@@ -1792,30 +1744,25 @@ package body Exp_Aggr is\n       Instr     : Node_Id;\n       Ref       : Node_Id;\n       Target    : Entity_Id;\n-      F         : Node_Id;\n       Comp_Type : Entity_Id;\n       Selector  : Entity_Id;\n       Comp_Expr : Node_Id;\n       Expr_Q    : Node_Id;\n \n-      Internal_Final_List : Node_Id := Empty;\n-\n       --  If this is an internal aggregate, the External_Final_List is an\n       --  expression for the controller record of the enclosing type.\n \n       --  If the current aggregate has several controlled components, this\n       --  expression will appear in several calls to attach to the finali-\n       --  zation list, and it must not be shared.\n \n-      External_Final_List      : Node_Id;\n       Ancestor_Is_Expression   : Boolean := False;\n       Ancestor_Is_Subtype_Mark : Boolean := False;\n \n       Init_Typ : Entity_Id := Empty;\n-      Attach   : Node_Id;\n \n-      Ctrl_Stuff_Done : Boolean := False;\n-      --  True if Gen_Ctrl_Actions_For_Aggr has already been called; calls\n+      Finalization_Done : Boolean := False;\n+      --  True if Generate_Finalization_Actions has already been called; calls\n       --  after the first do nothing.\n \n       function Ancestor_Discriminant_Value (Disc : Entity_Id) return Node_Id;\n@@ -1835,25 +1782,14 @@ package body Exp_Aggr is\n       --  Return true if Agg_Bounds are equal or within Typ_Bounds. It is\n       --  assumed that both bounds are integer ranges.\n \n-      procedure Gen_Ctrl_Actions_For_Aggr;\n+      procedure Generate_Finalization_Actions;\n       --  Deal with the various controlled type data structure initializations\n       --  (but only if it hasn't been done already).\n \n       function Get_Constraint_Association (T : Entity_Id) return Node_Id;\n       --  Returns the first discriminant association in the constraint\n       --  associated with T, if any, otherwise returns Empty.\n \n-      function Init_Controller\n-        (Target  : Node_Id;\n-         Typ     : Entity_Id;\n-         F       : Node_Id;\n-         Attach  : Node_Id;\n-         Init_Pr : Boolean) return List_Id;\n-      --  Returns the list of statements necessary to initialize the internal\n-      --  controller of the (possible) ancestor typ into target and attach it\n-      --  to finalization list F. Init_Pr conditions the call to the init proc\n-      --  since it may already be done due to ancestor initialization.\n-\n       procedure Init_Hidden_Discriminants (Typ : Entity_Id; List : List_Id);\n       --  If Typ is derived, and constrains discriminants of the parent type,\n       --  these discriminants are not components of the aggregate, and must be\n@@ -2064,103 +2000,6 @@ package body Exp_Aggr is\n          return Empty;\n       end Get_Constraint_Association;\n \n-      ---------------------\n-      -- Init_Controller --\n-      ---------------------\n-\n-      function Init_Controller\n-        (Target  : Node_Id;\n-         Typ     : Entity_Id;\n-         F       : Node_Id;\n-         Attach  : Node_Id;\n-         Init_Pr : Boolean) return List_Id\n-      is\n-         L           : constant List_Id := New_List;\n-         Ref         : Node_Id;\n-         RC          : RE_Id;\n-         Target_Type : Entity_Id;\n-\n-      begin\n-         --  Generate:\n-         --     init-proc (target._controller);\n-         --     initialize (target._controller);\n-         --     Attach_to_Final_List (target._controller, F);\n-\n-         Ref :=\n-           Make_Selected_Component (Loc,\n-             Prefix        => Convert_To (Typ, New_Copy_Tree (Target)),\n-             Selector_Name => Make_Identifier (Loc, Name_uController));\n-         Set_Assignment_OK (Ref);\n-\n-         --  Ada 2005 (AI-287): Give support to aggregates of limited types.\n-         --  If the type is intrinsically limited the controller is limited as\n-         --  well. If it is tagged and limited then so is the controller.\n-         --  Otherwise an untagged type may have limited components without its\n-         --  full view being limited, so the controller is not limited.\n-\n-         if Nkind (Target) = N_Identifier then\n-            Target_Type := Etype (Target);\n-\n-         elsif Nkind (Target) = N_Selected_Component then\n-            Target_Type := Etype (Selector_Name (Target));\n-\n-         elsif Nkind (Target) = N_Unchecked_Type_Conversion then\n-            Target_Type := Etype (Target);\n-\n-         elsif Nkind (Target) = N_Unchecked_Expression\n-           and then Nkind (Expression (Target)) = N_Indexed_Component\n-         then\n-            Target_Type := Etype (Prefix (Expression (Target)));\n-\n-         else\n-            Target_Type := Etype (Target);\n-         end if;\n-\n-         --  If the target has not been analyzed yet, as will happen with\n-         --  delayed expansion, use the given type (either the aggregate type\n-         --  or an ancestor) to determine limitedness.\n-\n-         if No (Target_Type) then\n-            Target_Type := Typ;\n-         end if;\n-\n-         if (Is_Tagged_Type (Target_Type))\n-           and then Is_Limited_Type (Target_Type)\n-         then\n-            RC := RE_Limited_Record_Controller;\n-\n-         elsif Is_Immutably_Limited_Type (Target_Type) then\n-            RC := RE_Limited_Record_Controller;\n-\n-         else\n-            RC := RE_Record_Controller;\n-         end if;\n-\n-         if Init_Pr then\n-            Append_List_To (L,\n-              Build_Initialization_Call (Loc,\n-                Id_Ref       => Ref,\n-                Typ          => RTE (RC),\n-                In_Init_Proc => Within_Init_Proc));\n-         end if;\n-\n-         Append_To (L,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               New_Reference_To (\n-                 Find_Prim_Op (RTE (RC), Name_Initialize), Loc),\n-             Parameter_Associations =>\n-               New_List (New_Copy_Tree (Ref))));\n-\n-         Append_To (L,\n-           Make_Attach_Call (\n-             Obj_Ref     => New_Copy_Tree (Ref),\n-             Flist_Ref   => F,\n-             With_Attach => Attach));\n-\n-         return L;\n-      end Init_Controller;\n-\n       -------------------------------\n       -- Init_Hidden_Discriminants --\n       -------------------------------\n@@ -2222,254 +2061,40 @@ package body Exp_Aggr is\n            and then Nkind (High_Bound (Bounds)) = N_Integer_Literal;\n       end Is_Int_Range_Bounds;\n \n-      -------------------------------\n-      -- Gen_Ctrl_Actions_For_Aggr --\n-      -------------------------------\n-\n-      procedure Gen_Ctrl_Actions_For_Aggr is\n-         Alloc : Node_Id := Empty;\n+      -----------------------------------\n+      -- Generate_Finalization_Actions --\n+      -----------------------------------\n \n+      procedure Generate_Finalization_Actions is\n       begin\n          --  Do the work only the first time this is called\n \n-         if Ctrl_Stuff_Done then\n+         if Finalization_Done then\n             return;\n          end if;\n \n-         Ctrl_Stuff_Done := True;\n-\n-         if Present (Obj)\n-           and then Finalize_Storage_Only (Typ)\n-           and then\n-             (Is_Library_Level_Entity (Obj)\n-                or else Entity (Constant_Value (RTE (RE_Garbage_Collected))) =\n-                                                          Standard_True)\n-\n-            --  why not Is_True (Expr_Value (RTE (RE_Garbaage_Collected) ???\n-         then\n-            Attach := Make_Integer_Literal (Loc, 0);\n-\n-         elsif Nkind (Parent (N)) = N_Qualified_Expression\n-           and then Nkind (Parent (Parent (N))) = N_Allocator\n-         then\n-            Alloc  := Parent (Parent (N));\n-            Attach := Make_Integer_Literal (Loc, 2);\n-\n-         else\n-            Attach := Make_Integer_Literal (Loc, 1);\n-         end if;\n+         Finalization_Done := True;\n \n          --  Determine the external finalization list. It is either the\n          --  finalization list of the outer-scope or the one coming from\n-         --  an outer aggregate.  When the target is not a temporary, the\n+         --  an outer aggregate. When the target is not a temporary, the\n          --  proper scope is the scope of the target rather than the\n          --  potentially transient current scope.\n \n-         if Needs_Finalization (Typ) then\n-\n-            --  The current aggregate belongs to an allocator which creates\n-            --  an object through an anonymous access type or acts as the root\n-            --  of a coextension chain.\n-\n-            if Present (Alloc)\n-              and then\n-                (Is_Coextension_Root (Alloc)\n-                   or else Ekind (Etype (Alloc)) = E_Anonymous_Access_Type)\n-            then\n-               if No (Associated_Final_Chain (Etype (Alloc))) then\n-                  Build_Final_List (Alloc, Etype (Alloc));\n-               end if;\n-\n-               External_Final_List :=\n-                 Make_Selected_Component (Loc,\n-                   Prefix =>\n-                     New_Reference_To (\n-                       Associated_Final_Chain (Etype (Alloc)), Loc),\n-                   Selector_Name => Make_Identifier (Loc, Name_F));\n-\n-            elsif Present (Flist) then\n-               External_Final_List := New_Copy_Tree (Flist);\n-\n-            elsif Is_Entity_Name (Target)\n-              and then Present (Scope (Entity (Target)))\n-            then\n-               External_Final_List :=\n-                 Find_Final_List (Scope (Entity (Target)));\n-\n-            else\n-               External_Final_List := Find_Final_List (Current_Scope);\n-            end if;\n-         else\n-            External_Final_List := Empty;\n-         end if;\n-\n-         --  Initialize and attach the outer object in the is_controlled case\n-\n-         if Is_Controlled (Typ) then\n-            if Ancestor_Is_Subtype_Mark then\n-               Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n-               Set_Assignment_OK (Ref);\n-               Append_To (L,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name =>\n-                     New_Reference_To\n-                       (Find_Prim_Op (Init_Typ, Name_Initialize), Loc),\n-                   Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n-            end if;\n-\n-            if not Has_Controlled_Component (Typ) then\n-               Ref := New_Copy_Tree (Target);\n-               Set_Assignment_OK (Ref);\n-\n-               --  This is an aggregate of a coextension. Do not produce a\n-               --  finalization call, but rather attach the reference of the\n-               --  aggregate to its coextension chain.\n-\n-               if Present (Alloc)\n-                 and then Is_Dynamic_Coextension (Alloc)\n-               then\n-                  if No (Coextensions (Alloc)) then\n-                     Set_Coextensions (Alloc, New_Elmt_List);\n-                  end if;\n-\n-                  Append_Elmt (Ref, Coextensions (Alloc));\n-               else\n-                  Append_To (L,\n-                    Make_Attach_Call (\n-                      Obj_Ref     => Ref,\n-                      Flist_Ref   => New_Copy_Tree (External_Final_List),\n-                      With_Attach => Attach));\n-               end if;\n-            end if;\n-         end if;\n-\n-         --  In the Has_Controlled component case, all the intermediate\n-         --  controllers must be initialized.\n-\n-         if Has_Controlled_Component (Typ)\n-           and not Is_Limited_Ancestor_Expansion\n+         if Is_Controlled (Typ)\n+           and then Ancestor_Is_Subtype_Mark\n          then\n-            declare\n-               Inner_Typ : Entity_Id;\n-               Outer_Typ : Entity_Id;\n-               At_Root   : Boolean;\n-\n-            begin\n-               --  Find outer type with a controller\n-\n-               Outer_Typ := Base_Type (Typ);\n-               while Outer_Typ /= Init_Typ\n-                 and then not Has_New_Controlled_Component (Outer_Typ)\n-               loop\n-                  Outer_Typ := Etype (Outer_Typ);\n-               end loop;\n-\n-               --  Attach it to the outer record controller to the external\n-               --  final list.\n-\n-               if Outer_Typ = Init_Typ then\n-                  Append_List_To (L,\n-                    Init_Controller (\n-                      Target  => Target,\n-                      Typ     => Outer_Typ,\n-                      F       => External_Final_List,\n-                      Attach  => Attach,\n-                      Init_Pr => False));\n-\n-                  At_Root   := True;\n-                  Inner_Typ := Init_Typ;\n-\n-               else\n-                  Append_List_To (L,\n-                    Init_Controller (\n-                      Target  => Target,\n-                      Typ     => Outer_Typ,\n-                      F       => External_Final_List,\n-                      Attach  => Attach,\n-                      Init_Pr => True));\n-\n-                  Inner_Typ := Etype (Outer_Typ);\n-                  At_Root   :=\n-                    not Is_Tagged_Type (Typ) or else Inner_Typ = Outer_Typ;\n-               end if;\n-\n-               --  The outer object has to be attached as well\n-\n-               if Is_Controlled (Typ) then\n-                  Ref := New_Copy_Tree (Target);\n-                  Set_Assignment_OK (Ref);\n-                  Append_To (L,\n-                    Make_Attach_Call (\n-                      Obj_Ref     => Ref,\n-                      Flist_Ref   => New_Copy_Tree (External_Final_List),\n-                      With_Attach => New_Copy_Tree (Attach)));\n-               end if;\n-\n-               --  Initialize the internal controllers for tagged types with\n-               --  more than one controller.\n-\n-               while not At_Root and then Inner_Typ /= Init_Typ loop\n-                  if Has_New_Controlled_Component (Inner_Typ) then\n-                     F :=\n-                       Make_Selected_Component (Loc,\n-                         Prefix =>\n-                           Convert_To (Outer_Typ, New_Copy_Tree (Target)),\n-                         Selector_Name =>\n-                           Make_Identifier (Loc, Name_uController));\n-                     F :=\n-                       Make_Selected_Component (Loc,\n-                         Prefix => F,\n-                         Selector_Name => Make_Identifier (Loc, Name_F));\n-\n-                     Append_List_To (L,\n-                       Init_Controller (\n-                         Target  => Target,\n-                         Typ     => Inner_Typ,\n-                         F       => F,\n-                         Attach  => Make_Integer_Literal (Loc, 1),\n-                         Init_Pr => True));\n-                     Outer_Typ := Inner_Typ;\n-                  end if;\n-\n-                  --  Stop at the root\n-\n-                  At_Root := Inner_Typ = Etype (Inner_Typ);\n-                  Inner_Typ := Etype (Inner_Typ);\n-               end loop;\n-\n-               --  If not done yet attach the controller of the ancestor part\n-\n-               if Outer_Typ /= Init_Typ\n-                 and then Inner_Typ = Init_Typ\n-                 and then Has_Controlled_Component (Init_Typ)\n-               then\n-                  F :=\n-                    Make_Selected_Component (Loc,\n-                      Prefix => Convert_To (Outer_Typ, New_Copy_Tree (Target)),\n-                      Selector_Name =>\n-                        Make_Identifier (Loc, Name_uController));\n-                  F :=\n-                    Make_Selected_Component (Loc,\n-                      Prefix        => F,\n-                      Selector_Name => Make_Identifier (Loc, Name_F));\n-\n-                  Attach := Make_Integer_Literal (Loc, 1);\n-                  Append_List_To (L,\n-                    Init_Controller (\n-                      Target  => Target,\n-                      Typ     => Init_Typ,\n-                      F       => F,\n-                      Attach  => Attach,\n-                      Init_Pr => False));\n-\n-                     --  Note: Init_Pr is False because the ancestor part has\n-                     --  already been initialized either way (by default, if\n-                     --  given by a type name, otherwise from the expression).\n-\n-               end if;\n-            end;\n+            Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n+            Set_Assignment_OK (Ref);\n+\n+            Append_To (L,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To\n+                    (Find_Prim_Op (Init_Typ, Name_Initialize), Loc),\n+                Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n          end if;\n-      end Gen_Ctrl_Actions_For_Aggr;\n+      end Generate_Finalization_Actions;\n \n       function Rewrite_Discriminant (Expr : Node_Id) return Traverse_Result;\n       --  If default expression of a component mentions a discriminant of the\n@@ -2574,21 +2199,23 @@ package body Exp_Aggr is\n \n       if Nkind (N) = N_Extension_Aggregate then\n          declare\n-            A      : constant Node_Id := Ancestor_Part (N);\n-            Assign : List_Id;\n+            Ancestor : constant Node_Id := Ancestor_Part (N);\n+            Assign   : List_Id;\n \n          begin\n             --  If the ancestor part is a subtype mark \"T\", we generate\n \n-            --     init-proc (T(tmp));  if T is constrained and\n-            --     init-proc (S(tmp));  where S applies an appropriate\n-            --                          constraint if T is unconstrained\n+            --     init-proc (T (tmp));  if T is constrained and\n+            --     init-proc (S (tmp));  where S applies an appropriate\n+            --                           constraint if T is unconstrained\n \n-            if Is_Entity_Name (A) and then Is_Type (Entity (A)) then\n+            if Is_Entity_Name (Ancestor)\n+              and then Is_Type (Entity (Ancestor))\n+            then\n                Ancestor_Is_Subtype_Mark := True;\n \n-               if Is_Constrained (Entity (A)) then\n-                  Init_Typ := Entity (A);\n+               if Is_Constrained (Entity (Ancestor)) then\n+                  Init_Typ := Entity (Ancestor);\n \n                --  For an ancestor part given by an unconstrained type mark,\n                --  create a subtype constrained by appropriate corresponding\n@@ -2597,9 +2224,9 @@ package body Exp_Aggr is\n                --  be used to generate the correct default value for the\n                --  ancestor part.\n \n-               elsif Has_Discriminants (Entity (A)) then\n+               elsif Has_Discriminants (Entity (Ancestor)) then\n                   declare\n-                     Anc_Typ    : constant Entity_Id := Entity (A);\n+                     Anc_Typ    : constant Entity_Id := Entity (Ancestor);\n                      Anc_Constr : constant List_Id   := New_List;\n                      Discrim    : Entity_Id;\n                      Disc_Value : Node_Id;\n@@ -2650,17 +2277,17 @@ package body Exp_Aggr is\n                                              or else\n                                            Has_Task (Base_Type (Init_Typ))));\n \n-                  if Is_Constrained (Entity (A))\n-                    and then Has_Discriminants (Entity (A))\n+                  if Is_Constrained (Entity (Ancestor))\n+                    and then Has_Discriminants (Entity (Ancestor))\n                   then\n-                     Check_Ancestor_Discriminants (Entity (A));\n+                     Check_Ancestor_Discriminants (Entity (Ancestor));\n                   end if;\n                end if;\n \n             --  Handle calls to C++ constructors\n \n-            elsif Is_CPP_Constructor_Call (A) then\n-               Init_Typ := Etype (A);\n+            elsif Is_CPP_Constructor_Call (Ancestor) then\n+               Init_Typ := Etype (Ancestor);\n                Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n                Set_Assignment_OK (Ref);\n \n@@ -2670,7 +2297,7 @@ package body Exp_Aggr is\n                    Typ               => Init_Typ,\n                    In_Init_Proc      => Within_Init_Proc,\n                    With_Default_Init => Has_Default_Init_Comps (N),\n-                   Constructor_Ref   => A));\n+                   Constructor_Ref   => Ancestor));\n \n             --  Ada 2005 (AI-287): If the ancestor part is an aggregate of\n             --  limited type, a recursive call expands the ancestor. Note that\n@@ -2681,30 +2308,28 @@ package body Exp_Aggr is\n             --  transformed into an explicit dereference) or a qualification\n             --  of one such.\n \n-            elsif Is_Limited_Type (Etype (A))\n-              and then Nkind_In (Unqualify (A), N_Aggregate,\n-                                                N_Extension_Aggregate)\n+            elsif Is_Limited_Type (Etype (Ancestor))\n+              and then Nkind_In (Unqualify (Ancestor), N_Aggregate,\n+                                                    N_Extension_Aggregate)\n             then\n                Ancestor_Is_Expression := True;\n \n                --  Set up  finalization data for enclosing record, because\n                --  controlled subcomponents of the ancestor part will be\n                --  attached to it.\n \n-               Gen_Ctrl_Actions_For_Aggr;\n+               Generate_Finalization_Actions;\n \n                Append_List_To (L,\n                   Build_Record_Aggr_Code (\n-                    N                             => Unqualify (A),\n-                    Typ                           => Etype (Unqualify (A)),\n-                    Lhs                           => Target,\n-                    Flist                         => Flist,\n-                    Obj                           => Obj,\n+                    N   => Unqualify (Ancestor),\n+                    Typ => Etype (Unqualify (Ancestor)),\n+                    Lhs => Target,\n                     Is_Limited_Ancestor_Expansion => True));\n \n             --  If the ancestor part is an expression \"E\", we generate\n \n-            --     T(tmp) := E;\n+            --     T (tmp) := E;\n \n             --  In Ada 2005, this includes the case of a (possibly qualified)\n             --  limited function call. The assignment will turn into a\n@@ -2713,16 +2338,16 @@ package body Exp_Aggr is\n \n             else\n                Ancestor_Is_Expression := True;\n-               Init_Typ := Etype (A);\n+               Init_Typ := Etype (Ancestor);\n \n                --  If the ancestor part is an aggregate, force its full\n                --  expansion, which was delayed.\n \n-               if Nkind_In (Unqualify (A), N_Aggregate,\n-                                           N_Extension_Aggregate)\n+               if Nkind_In (Unqualify (Ancestor), N_Aggregate,\n+                                               N_Extension_Aggregate)\n                then\n-                  Set_Analyzed (A, False);\n-                  Set_Analyzed (Expression (A), False);\n+                  Set_Analyzed (Ancestor, False);\n+                  Set_Analyzed (Expression (Ancestor), False);\n                end if;\n \n                Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n@@ -2735,7 +2360,7 @@ package body Exp_Aggr is\n                Assign := New_List (\n                  Make_OK_Assignment_Statement (Loc,\n                    Name       => Ref,\n-                   Expression => A));\n+                   Expression => Ancestor));\n                Set_No_Ctrl_Actions (First (Assign));\n \n                --  Assign the tag now to make sure that the dispatching call in\n@@ -2775,16 +2400,13 @@ package body Exp_Aggr is\n \n                --  Call Adjust manually\n \n-               if Needs_Finalization (Etype (A))\n-                 and then not Is_Limited_Type (Etype (A))\n+               if Needs_Finalization (Etype (Ancestor))\n+                 and then not Is_Limited_Type (Etype (Ancestor))\n                then\n-                  Append_List_To (Assign,\n+                  Append_To (Assign,\n                     Make_Adjust_Call (\n-                      Ref         => New_Copy_Tree (Ref),\n-                      Typ         => Etype (A),\n-                      Flist_Ref   => New_Reference_To (\n-                        RTE (RE_Global_Final_List), Loc),\n-                      With_Attach => Make_Integer_Literal (Loc, 0)));\n+                      Obj_Ref => New_Copy_Tree (Ref),\n+                      Typ     => Etype (Ancestor)));\n                end if;\n \n                Append_To (L,\n@@ -2946,7 +2568,7 @@ package body Exp_Aggr is\n            and then Has_Non_Null_Base_Init_Proc (Etype (Selector))\n          then\n             if Ekind (Selector) /= E_Discriminant then\n-               Gen_Ctrl_Actions_For_Aggr;\n+               Generate_Finalization_Actions;\n             end if;\n \n             --  Ada 2005 (AI-287): If the component type has tasks then\n@@ -2997,7 +2619,7 @@ package body Exp_Aggr is\n             --  controllers. Their position may depend on the discriminants.\n \n             if Ekind (Selector) /= E_Discriminant then\n-               Gen_Ctrl_Actions_For_Aggr;\n+               Generate_Finalization_Actions;\n             end if;\n \n             Comp_Type := Underlying_Type (Etype (Selector));\n@@ -3012,30 +2634,6 @@ package body Exp_Aggr is\n                Expr_Q := Expression (Comp);\n             end if;\n \n-            --  The controller is the one of the parent type defining the\n-            --  component (in case of inherited components).\n-\n-            if Needs_Finalization (Comp_Type) then\n-               Internal_Final_List :=\n-                 Make_Selected_Component (Loc,\n-                   Prefix        => Convert_To\n-                     (Scope (Original_Record_Component (Selector)),\n-                      New_Copy_Tree (Target)),\n-                   Selector_Name => Make_Identifier (Loc, Name_uController));\n-\n-               Internal_Final_List :=\n-                 Make_Selected_Component (Loc,\n-                   Prefix        => Internal_Final_List,\n-                   Selector_Name => Make_Identifier (Loc, Name_F));\n-\n-               --  The internal final list can be part of a constant object\n-\n-               Set_Assignment_OK (Internal_Final_List);\n-\n-            else\n-               Internal_Final_List := Empty;\n-            end if;\n-\n             --  Now either create the assignment or generate the code for the\n             --  inner aggregate top-down.\n \n@@ -3114,31 +2712,21 @@ package body Exp_Aggr is\n \n                      Append_List_To (L,\n                        Late_Expansion (Expr_Q, Comp_Type,\n-                         New_Reference_To (TmpE, Loc), Internal_Final_List));\n+                         New_Reference_To (TmpE, Loc)));\n \n                      --  Slide\n \n                      Append_To (L,\n                        Make_Assignment_Statement (Loc,\n                          Name       => New_Copy_Tree (Comp_Expr),\n                          Expression => New_Reference_To (TmpE, Loc)));\n-\n-                     --  Do not pass the original aggregate to Gigi as is,\n-                     --  since it will potentially clobber the front or the end\n-                     --  of the array. Setting the expression to empty is safe\n-                     --  since all aggregates are expanded into assignments.\n-\n-                     if Present (Obj) then\n-                        Set_Expression (Parent (Obj), Empty);\n-                     end if;\n                   end;\n \n                --  Normal case (sliding not required)\n \n                else\n                   Append_List_To (L,\n-                    Late_Expansion (Expr_Q, Comp_Type, Comp_Expr,\n-                      Internal_Final_List));\n+                    Late_Expansion (Expr_Q, Comp_Type, Comp_Expr));\n                end if;\n \n             --  Expr_Q is not delayed aggregate\n@@ -3183,21 +2771,16 @@ package body Exp_Aggr is\n                   Append_To (L, Instr);\n                end if;\n \n-               --  Adjust and Attach the component to the proper controller\n-\n-               --     Adjust (tmp.comp);\n-               --     Attach_To_Final_List (tmp.comp,\n-               --       comp_typ (tmp)._record_controller.f)\n+               --  Generate:\n+               --    Adjust (tmp.comp);\n \n                if Needs_Finalization (Comp_Type)\n                  and then not Is_Limited_Type (Comp_Type)\n                then\n-                  Append_List_To (L,\n+                  Append_To (L,\n                     Make_Adjust_Call (\n-                      Ref         => New_Copy_Tree (Comp_Expr),\n-                      Typ         => Comp_Type,\n-                      Flist_Ref   => Internal_Final_List,\n-                      With_Attach => Make_Integer_Literal (Loc, 1)));\n+                      Obj_Ref => New_Copy_Tree (Comp_Expr),\n+                      Typ     => Comp_Type));\n                end if;\n             end if;\n \n@@ -3320,7 +2903,7 @@ package body Exp_Aggr is\n       --  If the controllers have not been initialized yet (by lack of non-\n       --  discriminant components), let's do it now.\n \n-      Gen_Ctrl_Actions_For_Aggr;\n+      Generate_Finalization_Actions;\n \n       return L;\n    end Build_Record_Aggr_Code;\n@@ -3343,40 +2926,7 @@ package body Exp_Aggr is\n                  Make_Explicit_Dereference (Loc,\n                    New_Reference_To (Temp, Loc)));\n \n-      Access_Type : constant Entity_Id := Etype (Temp);\n-      Flist       : Entity_Id;\n-\n    begin\n-      --  If the allocator is for an access discriminant, there is no\n-      --  finalization list for the anonymous access type, and the eventual\n-      --  finalization of the object is handled through the coextension\n-      --  mechanism. If the enclosing object is not dynamically allocated,\n-      --  the access discriminant is itself placed on the stack. Otherwise,\n-      --  some other finalization list is used (see exp_ch4.adb).\n-\n-      --  Decl has been inserted in the code ahead of the allocator, using\n-      --  Insert_Actions. We use Insert_Actions below as well, to ensure that\n-      --  subsequent insertions are done in the proper order. Using (for\n-      --  example) Insert_Actions_After to place the expanded aggregate\n-      --  immediately after Decl may lead to out-of-order references if the\n-      --  allocator has generated a finalization list, as when the designated\n-      --  object is controlled and there is an open transient scope.\n-\n-      if Ekind (Access_Type) = E_Anonymous_Access_Type\n-        and then Nkind (Associated_Node_For_Itype (Access_Type)) =\n-                                              N_Discriminant_Specification\n-      then\n-         Flist := Empty;\n-\n-      elsif Needs_Finalization (Typ) then\n-         Flist := Find_Final_List (Access_Type);\n-\n-      --  Otherwise there are no controlled actions to be performed.\n-\n-      else\n-         Flist := Empty;\n-      end if;\n-\n       if Is_Array_Type (Typ) then\n          Convert_Array_Aggr_In_Allocator (Decl, Aggr, Occ);\n \n@@ -3386,14 +2936,7 @@ package body Exp_Aggr is\n             Init_Stmts : List_Id;\n \n          begin\n-            Init_Stmts :=\n-              Late_Expansion\n-                (Aggr, Typ, Occ,\n-                 Flist,\n-                 Associated_Final_Chain (Base_Type (Access_Type)));\n-\n-            --  ??? Dubious actual for Obj: expect 'the original object being\n-            --  initialized'\n+            Init_Stmts := Late_Expansion (Aggr, Typ, Occ);\n \n             if Has_Task (Typ) then\n                Build_Task_Allocate_Block_With_Init_Stmts (L, Aggr, Init_Stmts);\n@@ -3404,14 +2947,7 @@ package body Exp_Aggr is\n          end;\n \n       else\n-         Insert_Actions (Alloc,\n-           Late_Expansion\n-             (Aggr, Typ, Occ, Flist,\n-              Associated_Final_Chain (Base_Type (Access_Type))));\n-\n-         --  ??? Dubious actual for Obj: expect 'the original object being\n-         --  initialized'\n-\n+         Insert_Actions (Alloc, Late_Expansion (Aggr, Typ, Occ));\n       end if;\n    end Convert_Aggr_In_Allocator;\n \n@@ -3429,10 +2965,7 @@ package body Exp_Aggr is\n          Aggr := Expression (Aggr);\n       end if;\n \n-      Insert_Actions_After (N,\n-        Late_Expansion\n-          (Aggr, Typ, Occ,\n-           Find_Final_List (Typ, New_Copy_Tree (Occ))));\n+      Insert_Actions_After (N, Late_Expansion (Aggr, Typ, Occ));\n    end Convert_Aggr_In_Assignment;\n \n    ---------------------------------\n@@ -3551,7 +3084,7 @@ package body Exp_Aggr is\n               Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n       end if;\n \n-      Insert_Actions_After (N, Late_Expansion (Aggr, Typ, Occ, Obj => Obj));\n+      Insert_Actions_After (N, Late_Expansion (Aggr, Typ, Occ));\n       Set_No_Initialization (N);\n       Initialize_Discriminants (N, Typ);\n    end Convert_Aggr_In_Object_Decl;\n@@ -3688,8 +3221,8 @@ package body Exp_Aggr is\n         and then Nkind (Parent (N)) = N_Assignment_Statement\n       then\n          Target_Expr := New_Copy_Tree (Name (Parent (N)));\n-         Insert_Actions\n-           (Parent (N), Build_Record_Aggr_Code (N, Typ, Target_Expr));\n+         Insert_Actions (Parent (N),\n+           Build_Record_Aggr_Code (N, Typ, Target_Expr));\n          Rewrite (Parent (N), Make_Null_Statement (Loc));\n \n       else\n@@ -6169,13 +5702,11 @@ package body Exp_Aggr is\n    function Late_Expansion\n      (N      : Node_Id;\n       Typ    : Entity_Id;\n-      Target : Node_Id;\n-      Flist  : Node_Id   := Empty;\n-      Obj    : Entity_Id := Empty) return List_Id\n+      Target : Node_Id) return List_Id\n    is\n    begin\n       if Is_Record_Type (Etype (N)) then\n-         return Build_Record_Aggr_Code (N, Typ, Target, Flist, Obj);\n+         return Build_Record_Aggr_Code (N, Typ, Target);\n \n       else pragma Assert (Is_Array_Type (Etype (N)));\n          return\n@@ -6185,8 +5716,7 @@ package body Exp_Aggr is\n               Index       => First_Index (Typ),\n               Into        => Target,\n               Scalar_Comp => Is_Scalar_Type (Component_Type (Typ)),\n-              Indexes     => No_List,\n-              Flist       => Flist);\n+              Indexes     => No_List);\n       end if;\n    end Late_Expansion;\n "}, {"sha": "d2143c19387bedc54a77599dc887b797fcbfc745", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -205,6 +205,77 @@ package body Exp_Ch13 is\n       end case;\n    end Expand_N_Attribute_Definition_Clause;\n \n+   -----------------------------\n+   -- Expand_N_Free_Statement --\n+   -----------------------------\n+\n+   procedure Expand_N_Free_Statement (N : Node_Id) is\n+      Expr : constant Node_Id := Expression (N);\n+      Typ  : Entity_Id := Etype (Expr);\n+\n+   begin\n+      --  Use the base type to perform the collection check\n+\n+      if Ekind (Typ) = E_Access_Subtype then\n+         Typ := Etype (Typ);\n+      end if;\n+\n+      --  Handle private access types\n+\n+      if Is_Private_Type (Typ)\n+        and then Present (Full_View (Typ))\n+      then\n+         Typ := Full_View (Typ);\n+      end if;\n+\n+      --  Do not create a custom Deallocate when freeing an object with\n+      --  suppressed finalization. In such cases the object is never attached\n+      --  to a collection, so it does not need to be detached. Use a regular\n+      --  free statement instead.\n+\n+      if No (Associated_Collection (Typ)) then\n+         return;\n+      end if;\n+\n+      --  Use a temporary to store the result of a complex expression. Perform\n+      --  the following transformation:\n+      --\n+      --     Free (Complex_Expression);\n+      --\n+      --     Temp : constant Type_Of_Expression := Complex_Expression;\n+      --     Free (Temp);\n+\n+      if Nkind (Expr) /= N_Identifier then\n+         declare\n+            Expr_Typ : constant Entity_Id  := Etype (Expr);\n+            Loc      : constant Source_Ptr := Sloc (N);\n+            New_Expr : Node_Id;\n+            Temp_Id  : Entity_Id;\n+\n+         begin\n+            Temp_Id := Make_Temporary (Loc, 'T');\n+            Insert_Action (N,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp_Id,\n+                Object_Definition =>\n+                  New_Reference_To (Expr_Typ, Loc),\n+                Expression =>\n+                  Relocate_Node (Expr)));\n+\n+            New_Expr := New_Reference_To (Temp_Id, Loc);\n+            Set_Etype (New_Expr, Expr_Typ);\n+\n+            Set_Expression (N, New_Expr);\n+         end;\n+      end if;\n+\n+      --  Create a custom Deallocate for a controlled object. This routine\n+      --  ensures that the hidden list header will be deallocated along with\n+      --  the actual object.\n+\n+      Build_Allocate_Deallocate_Proc (N, Is_Allocate => False);\n+   end Expand_N_Free_Statement;\n+\n    ----------------------------\n    -- Expand_N_Freeze_Entity --\n    ----------------------------\n@@ -324,7 +395,39 @@ package body Exp_Ch13 is\n \n       if In_Other_Scope then\n          Push_Scope (E_Scope);\n-         Install_Visible_Declarations (E_Scope);\n+\n+         --  Finalizers are little odd in terms of freezing. The spec of the\n+         --  procedure appears in the declarations while the body appears in\n+         --  the statement part of a single construct. Since the finalizer must\n+         --  be called by the At_End handler of the construct, the spec is\n+         --  manually frozen right after its declaration. The only side effect\n+         --  of this action appears in contexts where the construct is not in\n+         --  its final resting place. These contexts are:\n+\n+         --    * Entry bodies - The declarations and statements are moved to\n+         --      the procedure equivalen of the entry.\n+         --    * Protected subprograms - The declarations and statements are\n+         --      moved to the non-protected version of the subprogram.\n+         --    * Task bodies - The declarations and statements are moved to the\n+         --      task body procedure.\n+\n+         --  Visible declarations do not need to be installed in these three\n+         --  cases since it does not make semantic sense to do so. All entities\n+         --  referenced by a finalizer are visible and already resolved, plus\n+         --  the enclosing scope may not have visible declarations at all.\n+\n+         if Ekind (E) = E_Procedure\n+           and then Is_Finalizer (E)\n+           and then\n+             (Is_Entry (E_Scope)\n+                or else (Is_Subprogram (E_Scope)\n+                           and then Is_Protected_Type (Scope (E_Scope)))\n+                or else Is_Task_Type (E_Scope))\n+         then\n+            null;\n+         else\n+            Install_Visible_Declarations (E_Scope);\n+         end if;\n \n          if Is_Package_Or_Generic_Package (E_Scope) or else\n             Is_Protected_Type (E_Scope)             or else"}, {"sha": "484fe641910b68335b2f0b35e60a608ffdf27360", "filename": "gcc/ada/exp_ch13.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,6 +30,7 @@ with Types; use Types;\n package Exp_Ch13 is\n \n    procedure Expand_N_Attribute_Definition_Clause  (N : Node_Id);\n+   procedure Expand_N_Free_Statement               (N : Node_Id);\n    procedure Expand_N_Freeze_Entity                (N : Node_Id);\n    procedure Expand_N_Record_Representation_Clause (N : Node_Id);\n "}, {"sha": "682ae94a18d98f71cd71d9984f2dfe8ccc198de6", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 690, "deletions": 827, "changes": 1517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -77,10 +77,6 @@ package body Exp_Ch3 is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Add_Final_Chain (Def_Id : Entity_Id) return Entity_Id;\n-   --  Add the declaration of a finalization list to the freeze actions for\n-   --  Def_Id, and return its defining identifier.\n-\n    procedure Adjust_Discriminants (Rtype : Entity_Id);\n    --  This is used when freezing a record type. It attempts to construct\n    --  more restrictive subtypes for discriminants so that the max size of\n@@ -132,9 +128,9 @@ package body Exp_Ch3 is\n    --  declaration of the designated type that contains tasks. The renaming\n    --  declaration is inserted before N, and after the Master declaration.\n \n-   procedure Build_Record_Init_Proc (N : Node_Id; Pe : Entity_Id);\n+   procedure Build_Record_Init_Proc (N : Node_Id; Rec_Ent : Entity_Id);\n    --  Build record initialization procedure. N is the type declaration\n-   --  node, and Pe is the corresponding entity for the record type.\n+   --  node, and Rec_Ent is the corresponding entity for the record type.\n \n    procedure Build_Slice_Assignment (Typ : Entity_Id);\n    --  Build assignment procedure for one-dimensional arrays of controlled\n@@ -171,17 +167,16 @@ package body Exp_Ch3 is\n    --  the value of the access to the Dispatch table. This procedure is only\n    --  called on root type, the _Tag field being inherited by the descendants.\n \n-   procedure Expand_Record_Controller (T : Entity_Id);\n-   --  T must be a record type that Has_Controlled_Component. Add a field\n-   --  _controller of type Record_Controller or Limited_Record_Controller\n-   --  in the record T.\n-\n    procedure Expand_Freeze_Array_Type (N : Node_Id);\n    --  Freeze an array type. Deals with building the initialization procedure,\n    --  creating the packed array type for a packed array and also with the\n    --  creation of the controlling procedures for the controlled case. The\n    --  argument N is the N_Freeze_Entity node for the type.\n \n+   procedure Expand_Freeze_Class_Wide_Type (N : Node_Id);\n+   --  Freeze a class-wide type. Build routine Finalize_Address for the purpose\n+   --  of finalizing controlled derivations from the class-wide's root type.\n+\n    procedure Expand_Freeze_Enumeration_Type (N : Node_Id);\n    --  Freeze enumeration type with non-standard representation. Builds the\n    --  array and function needed to convert between enumeration pos and\n@@ -370,28 +365,6 @@ package body Exp_Ch3 is\n    --  the generation of these operations, as a useful optimization or for\n    --  certification purposes.\n \n-   ---------------------\n-   -- Add_Final_Chain --\n-   ---------------------\n-\n-   function Add_Final_Chain (Def_Id : Entity_Id) return Entity_Id is\n-      Loc   : constant Source_Ptr := Sloc (Def_Id);\n-      Flist : Entity_Id;\n-\n-   begin\n-      Flist :=\n-        Make_Defining_Identifier (Loc,\n-          New_External_Name (Chars (Def_Id), 'L'));\n-\n-      Append_Freeze_Action (Def_Id,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Flist,\n-          Object_Definition   =>\n-            New_Reference_To (RTE (RE_List_Controller), Loc)));\n-\n-      return Flist;\n-   end Add_Final_Chain;\n-\n    --------------------------\n    -- Adjust_Discriminants --\n    --------------------------\n@@ -554,10 +527,10 @@ package body Exp_Ch3 is\n    procedure Build_Array_Init_Proc (A_Type : Entity_Id; Nod : Node_Id) is\n       Loc              : constant Source_Ptr := Sloc (Nod);\n       Comp_Type        : constant Entity_Id  := Component_Type (A_Type);\n-      Index_List       : List_Id;\n-      Proc_Id          : Entity_Id;\n       Body_Stmts       : List_Id;\n       Has_Default_Init : Boolean;\n+      Index_List       : List_Id;\n+      Proc_Id          : Entity_Id;\n \n       function Init_Component return List_Id;\n       --  Create one statement to initialize one array component, designated\n@@ -809,12 +782,12 @@ package body Exp_Ch3 is\n    -----------------------------\n \n    procedure Build_Class_Wide_Master (T : Entity_Id) is\n-      Loc  : constant Source_Ptr := Sloc (T);\n-      M_Id : Entity_Id;\n-      Decl : Node_Id;\n-      P    : Node_Id;\n-      Par  : Node_Id;\n-      Scop : Entity_Id;\n+      Loc          : constant Source_Ptr := Sloc (T);\n+      Master_Id    : Entity_Id;\n+      Master_Scope : Entity_Id;\n+      Name_Id      : Node_Id;\n+      Related_Node : Node_Id;\n+      Ren_Decl     : Node_Id;\n \n    begin\n       --  Nothing to do if there is no task hierarchy\n@@ -823,77 +796,107 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n-      --  Find declaration that created the access type: either a type\n-      --  declaration, or an object declaration with an access definition,\n+      --  Find the declaration that created the access type. It is either a\n+      --  type declaration, or an object declaration with an access definition,\n       --  in which case the type is anonymous.\n \n       if Is_Itype (T) then\n-         P := Associated_Node_For_Itype (T);\n+         Related_Node := Associated_Node_For_Itype (T);\n       else\n-         P := Parent (T);\n+         Related_Node := Parent (T);\n       end if;\n \n-      Scop := Find_Master_Scope (T);\n+      Master_Scope := Find_Master_Scope (T);\n \n-      --  Nothing to do if we already built a master entity for this scope\n+      --  Nothing to do if the master scope already contains a _master entity.\n+      --  The only exception to this is the following scenario:\n \n-      if not Has_Master_Entity (Scop) then\n+      --    Source_Scope\n+      --       Transient_Scope_1\n+      --          _master\n \n-         --  First build the master entity\n-         --    _Master : constant Master_Id := Current_Master.all;\n-         --  and insert it just before the current declaration.\n+      --       Transient_Scope_2\n+      --          use of master\n \n-         Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_uMaster),\n-             Constant_Present => True,\n-             Object_Definition => New_Reference_To (Standard_Integer, Loc),\n-             Expression =>\n-               Make_Explicit_Dereference (Loc,\n-                 New_Reference_To (RTE (RE_Current_Master), Loc)));\n+      --  In this case the source scope is marked as having the master entity\n+      --  even though the actual declaration appears inside an inner scope. If\n+      --  the second transient scope requires a _master, it cannot use the one\n+      --  already declared because the entity is not visible.\n \n-         Set_Has_Master_Entity (Scop);\n-         Insert_Action (P, Decl);\n-         Analyze (Decl);\n+      Name_Id := Make_Identifier (Loc, Name_uMaster);\n \n-         --  Now mark the containing scope as a task master. Masters\n-         --  associated with return statements are already marked at\n-         --  this stage (see Analyze_Subprogram_Body).\n+      if not Has_Master_Entity (Master_Scope)\n+        or else No (Current_Entity_In_Scope (Name_Id))\n+      then\n+         declare\n+            Master_Decl : Node_Id;\n \n-         if Ekind (Current_Scope) /= E_Return_Statement then\n-            Par := P;\n-            while Nkind (Par) /= N_Compilation_Unit loop\n-               Par := Parent (Par);\n+         begin\n+            Set_Has_Master_Entity (Master_Scope);\n \n-            --  If we fall off the top, we are at the outer level, and the\n-            --  environment task is our effective master, so nothing to mark.\n+            --  Generate:\n+            --    _master : constant Integer := Current_Master.all;\n+\n+            Master_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uMaster),\n+                Constant_Present => True,\n+                Object_Definition =>\n+                  New_Reference_To (Standard_Integer, Loc),\n+                Expression =>\n+                  Make_Explicit_Dereference (Loc,\n+                    New_Reference_To (RTE (RE_Current_Master), Loc)));\n \n-               if Nkind_In\n-                   (Par, N_Task_Body, N_Block_Statement, N_Subprogram_Body)\n-               then\n-                  Set_Is_Task_Master (Par, True);\n-                  exit;\n-               end if;\n-            end loop;\n-         end if;\n-      end if;\n+            Insert_Action (Related_Node, Master_Decl);\n+            Analyze (Master_Decl);\n \n-      --  Now define the renaming of the master_id\n+            --  Mark the containing scope as a task master. Masters associated\n+            --  with return statements are already marked at this stage (see\n+            --  Analyze_Subprogram_Body).\n \n-      M_Id :=\n+            if Ekind (Current_Scope) /= E_Return_Statement then\n+               declare\n+                  Par : Node_Id := Related_Node;\n+\n+               begin\n+                  while Nkind (Par) /= N_Compilation_Unit loop\n+                     Par := Parent (Par);\n+\n+                     --  If we fall off the top, we are at the outer level, and\n+                     --  the environment task is our effective master, so\n+                     --  nothing to mark.\n+\n+                     if Nkind_In (Par, N_Block_Statement,\n+                                       N_Subprogram_Body,\n+                                       N_Task_Body)\n+                     then\n+                        Set_Is_Task_Master (Par);\n+                        exit;\n+                     end if;\n+                  end loop;\n+               end;\n+            end if;\n+         end;\n+      end if;\n+\n+      Master_Id :=\n         Make_Defining_Identifier (Loc,\n           New_External_Name (Chars (T), 'M'));\n \n-      Decl :=\n+      --  Generate:\n+      --    Mnn renames _master;\n+\n+      Ren_Decl :=\n         Make_Object_Renaming_Declaration (Loc,\n-          Defining_Identifier => M_Id,\n+          Defining_Identifier => Master_Id,\n           Subtype_Mark        => New_Reference_To (Standard_Integer, Loc),\n-          Name                => Make_Identifier (Loc, Name_uMaster));\n-      Insert_Before (P, Decl);\n-      Analyze (Decl);\n+          Name                => Name_Id);\n \n-      Set_Master_Id (T, M_Id);\n+      Insert_Before (Related_Node, Ren_Decl);\n+      Analyze (Ren_Decl);\n+\n+      Set_Master_Id (T, Master_Id);\n \n    exception\n       when RE_Not_Available =>\n@@ -1422,9 +1425,8 @@ package body Exp_Ch3 is\n       Res            : constant List_Id := New_List;\n       Arg            : Node_Id;\n       Args           : List_Id;\n-      Controller_Typ : Entity_Id;\n-      Decl           : Node_Id;\n       Decls          : List_Id;\n+      Decl           : Node_Id;\n       Discr          : Entity_Id;\n       First_Arg      : Node_Id;\n       Full_Init_Type : Entity_Id;\n@@ -1656,41 +1658,10 @@ package body Exp_Ch3 is\n         and then Nkind (Id_Ref) = N_Selected_Component\n       then\n          if Chars (Selector_Name (Id_Ref)) /= Name_uParent then\n-            Append_List_To (Res,\n-              Make_Init_Call (\n-                Ref         => New_Copy_Tree (First_Arg),\n-                Typ         => Typ,\n-                Flist_Ref   =>\n-                  Find_Final_List (Typ, New_Copy_Tree (First_Arg)),\n-                With_Attach => Make_Integer_Literal (Loc, 1)));\n-\n-         --  If the enclosing type is an extension with new controlled\n-         --  components, it has his own record controller. If the parent\n-         --  also had a record controller, attach it to the new one.\n-\n-         --  Build_Init_Statements relies on the fact that in this specific\n-         --  case the last statement of the result is the attach call to\n-         --  the controller. If this is changed, it must be synchronized.\n-\n-         elsif Present (Enclos_Type)\n-           and then Has_New_Controlled_Component (Enclos_Type)\n-           and then Has_Controlled_Component (Typ)\n-         then\n-            if Is_Immutably_Limited_Type (Typ) then\n-               Controller_Typ := RTE (RE_Limited_Record_Controller);\n-            else\n-               Controller_Typ := RTE (RE_Record_Controller);\n-            end if;\n-\n-            Append_List_To (Res,\n+            Append_To (Res,\n               Make_Init_Call (\n-                Ref       =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix        => New_Copy_Tree (First_Arg),\n-                    Selector_Name => Make_Identifier (Loc, Name_uController)),\n-                Typ       => Controller_Typ,\n-                Flist_Ref => Find_Final_List (Typ, New_Copy_Tree (First_Arg)),\n-                With_Attach => Make_Integer_Literal (Loc, 1)));\n+                Obj_Ref => New_Copy_Tree (First_Arg),\n+                Typ     => Typ));\n          end if;\n       end if;\n \n@@ -1764,29 +1735,32 @@ package body Exp_Ch3 is\n    -- Build_Record_Init_Proc --\n    ----------------------------\n \n-   procedure Build_Record_Init_Proc (N : Node_Id; Pe : Entity_Id) is\n-      Loc       : Source_Ptr := Sloc (N);\n-      Discr_Map : constant Elist_Id := New_Elmt_List;\n-      Proc_Id   : Entity_Id;\n-      Rec_Type  : Entity_Id;\n-      Set_Tag   : Entity_Id := Empty;\n+   procedure Build_Record_Init_Proc (N : Node_Id; Rec_Ent : Entity_Id) is\n+      Decls       : constant List_Id  := New_List;\n+      Discr_Map   : constant Elist_Id := New_Elmt_List;\n+      Counter     : Int := 0;\n+      Loc         : Source_Ptr := Sloc (N);\n+      Proc_Id     : Entity_Id;\n+      Rec_Type    : Entity_Id;\n+      Set_Tag     : Entity_Id := Empty;\n \n       function Build_Assignment (Id : Entity_Id; N : Node_Id) return List_Id;\n-      --  Build a assignment statement node which assigns to record component\n-      --  its default expression if defined. The assignment left hand side is\n-      --  marked Assignment_OK so that initialization of limited private\n-      --  records works correctly, Return also the adjustment call for\n-      --  controlled objects\n+      --  Build an assignment statement which assigns the default expression\n+      --  to its corresponding record component if defined. The left hand side\n+      --  of the assignment is marked Assignment_OK so that initialization of\n+      --  limited private records works correctly. This routine may also build\n+      --  an adjustment call if the component is controlled.\n \n       procedure Build_Discriminant_Assignments (Statement_List : List_Id);\n-      --  If the record has discriminants, adds assignment statements to\n-      --  statement list to initialize the discriminant values from the\n+      --  If the record has discriminants, add assignment statements to\n+      --  Statement_List to initialize the discriminant values from the\n       --  arguments of the initialization procedure.\n \n       function Build_Init_Statements (Comp_List : Node_Id) return List_Id;\n       --  Build a list representing a sequence of statements which initialize\n       --  components of the given component list. This may involve building\n-      --  case statements for the variant parts.\n+      --  case statements for the variant parts. Append any locally declared\n+      --  objects on list Decls.\n \n       function Build_Init_Call_Thru (Parameters : List_Id) return List_Id;\n       --  Given a non-tagged type-derivation that declares discriminants,\n@@ -1798,9 +1772,9 @@ package body Exp_Ch3 is\n       --\n       --  we make the _init_proc of D be\n       --\n-      --       procedure _init_proc(X : D; D1 : Integer) is\n+      --       procedure _init_proc (X : D; D1 : Integer) is\n       --       begin\n-      --          _init_proc( R(X), 1, D1);\n+      --          _init_proc (R (X), 1, D1);\n       --       end _init_proc;\n       --\n       --  This function builds the call statement in this _init_proc.\n@@ -1813,13 +1787,12 @@ package body Exp_Ch3 is\n \n       procedure Build_Init_Procedure;\n       --  Build the tree corresponding to the procedure specification and body\n-      --  of the initialization procedure (by calling all the preceding\n-      --  auxiliary routines), and install it as the _init TSS.\n+      --  of the initialization procedure and install it as the _init TSS.\n \n       procedure Build_Offset_To_Top_Functions;\n       --  Ada 2005 (AI-251): Build the tree corresponding to the procedure spec\n-      --  and body of the Offset_To_Top function that is generated when the\n-      --  parent of a type with discriminants has secondary dispatch tables.\n+      --  and body of Offset_To_Top, a function used in conjuction with types\n+      --  having secondary dispatch tables.\n \n       procedure Build_Record_Checks (S : Node_Id; Check_List : List_Id);\n       --  Add range checks to components of discriminated records. S is a\n@@ -1828,48 +1801,28 @@ package body Exp_Ch3 is\n \n       function Component_Needs_Simple_Initialization\n         (T : Entity_Id) return Boolean;\n-      --  Determines if a component needs simple initialization, given its type\n-      --  T. This is the same as Needs_Simple_Initialization except for the\n-      --  following difference: the types Tag and Interface_Tag, that are\n-      --  access types which would normally require simple initialization to\n-      --  null, do not require initialization as components, since they are\n-      --  explicitly initialized by other means.\n-\n-      procedure Constrain_Array\n-        (SI         : Node_Id;\n-         Check_List : List_Id);\n-      --  Called from Build_Record_Checks.\n-      --  Apply a list of index constraints to an unconstrained array type.\n-      --  The first parameter is the entity for the resulting subtype.\n-      --  Check_List is a list to which the check actions are appended.\n-\n-      procedure Constrain_Index\n-        (Index      : Node_Id;\n-         S          : Node_Id;\n-         Check_List : List_Id);\n-      --  Process an index constraint in a constrained array declaration.\n-      --  The constraint can be a subtype name, or a range with or without\n-      --  an explicit subtype mark. The index is the corresponding index of the\n-      --  unconstrained array. S is the range expression. Check_List is a list\n-      --  to which the check actions are appended (called from\n-      --  Build_Record_Checks).\n+      --  Determine if a component needs simple initialization, given its type\n+      --  T. This routine is the same as Needs_Simple_Initialization except for\n+      --  components of type Tag and Interface_Tag. These two access types do\n+      --  not require initialization since they are explicitly initialized by\n+      --  other means.\n \n       function Parent_Subtype_Renaming_Discrims return Boolean;\n       --  Returns True for base types N that rename discriminants, else False\n \n       function Requires_Init_Proc (Rec_Id : Entity_Id) return Boolean;\n-      --  Determines whether a record initialization procedure needs to be\n+      --  Determine whether a record initialization procedure needs to be\n       --  generated for the given record type.\n \n       ----------------------\n       -- Build_Assignment --\n       ----------------------\n \n       function Build_Assignment (Id : Entity_Id; N : Node_Id) return List_Id is\n-         Exp  : Node_Id := N;\n-         Lhs  : Node_Id;\n          Typ  : constant Entity_Id := Underlying_Type (Etype (Id));\n+         Exp  : Node_Id := N;\n          Kind : Node_Kind := Nkind (N);\n+         Lhs  : Node_Id;\n          Res  : List_Id;\n \n       begin\n@@ -1886,7 +1839,7 @@ package body Exp_Ch3 is\n          --  the expression being given by such an attribute, but does not\n          --  cover uses nested within an initial value expression. Nested\n          --  uses are unlikely to occur in practice, but are theoretically\n-         --  possible. It is not clear how to handle them without fully\n+         --  possible.) It is not clear how to handle them without fully\n          --  traversing the expression. ???\n \n          if Kind = N_Attribute_Reference\n@@ -1899,7 +1852,8 @@ package body Exp_Ch3 is\n          then\n             Exp :=\n               Make_Attribute_Reference (Loc,\n-                Prefix         => Make_Identifier (Loc, Name_uInit),\n+                Prefix =>\n+                  Make_Identifier (Loc, Name_uInit),\n                 Attribute_Name => Name_Unrestricted_Access);\n          end if;\n \n@@ -1921,12 +1875,15 @@ package body Exp_Ch3 is\n          --  Suppress the tag adjustment when VM_Target because VM tags are\n          --  represented implicitly in objects.\n \n-         if Is_Tagged_Type (Typ) and then Tagged_Type_Expansion then\n+         if Is_Tagged_Type (Typ)\n+           and then Tagged_Type_Expansion\n+         then\n             Append_To (Res,\n               Make_Assignment_Statement (Loc,\n                 Name =>\n                   Make_Selected_Component (Loc,\n-                    Prefix =>  New_Copy_Tree (Lhs, New_Scope => Proc_Id),\n+                    Prefix =>\n+                      New_Copy_Tree (Lhs, New_Scope => Proc_Id),\n                     Selector_Name =>\n                       New_Reference_To (First_Tag_Component (Typ), Loc)),\n \n@@ -1950,17 +1907,10 @@ package body Exp_Ch3 is\n            and then not (Nkind_In (Kind, N_Aggregate, N_Extension_Aggregate))\n            and then not Is_Immutably_Limited_Type (Typ)\n          then\n-            declare\n-               Ref : constant Node_Id :=\n-                       New_Copy_Tree (Lhs, New_Scope => Proc_Id);\n-            begin\n-               Append_List_To (Res,\n-                 Make_Adjust_Call (\n-                  Ref          => Ref,\n-                  Typ          => Etype (Id),\n-                  Flist_Ref    => Find_Final_List (Etype (Id), Ref),\n-                  With_Attach  => Make_Integer_Literal (Loc, 1)));\n-            end;\n+            Append_To (Res,\n+              Make_Adjust_Call (\n+                Obj_Ref => New_Copy_Tree (Lhs),\n+                Typ     => Etype (Id)));\n          end if;\n \n          return Res;\n@@ -1975,24 +1925,23 @@ package body Exp_Ch3 is\n       ------------------------------------\n \n       procedure Build_Discriminant_Assignments (Statement_List : List_Id) is\n-         D         : Entity_Id;\n          Is_Tagged : constant Boolean := Is_Tagged_Type (Rec_Type);\n+         D         : Entity_Id;\n \n       begin\n          if Has_Discriminants (Rec_Type)\n            and then not Is_Unchecked_Union (Rec_Type)\n          then\n             D := First_Discriminant (Rec_Type);\n-\n             while Present (D) loop\n \n                --  Don't generate the assignment for discriminants in derived\n                --  tagged types if the discriminant is a renaming of some\n                --  ancestor discriminant. This initialization will be done\n                --  when initializing the _parent field of the derived record.\n \n-               if Is_Tagged and then\n-                 Present (Corresponding_Discriminant (D))\n+               if Is_Tagged\n+                 and then Present (Corresponding_Discriminant (D))\n                then\n                   null;\n \n@@ -2024,10 +1973,10 @@ package body Exp_Ch3 is\n \n          First_Discr_Param : Node_Id;\n \n-         Parent_Discr : Entity_Id;\n-         First_Arg    : Node_Id;\n-         Args         : List_Id;\n          Arg          : Node_Id;\n+         Args         : List_Id;\n+         First_Arg    : Node_Id;\n+         Parent_Discr : Entity_Id;\n          Res          : List_Id;\n \n       begin\n@@ -2080,12 +2029,12 @@ package body Exp_Ch3 is\n                --  directly.\n \n                declare\n-                  Discr_Value : Elmt_Id :=\n-                                  First_Elmt\n-                                    (Stored_Constraint (Rec_Type));\n-\n                   Discr       : Entity_Id :=\n                                   First_Stored_Discriminant (Uparent_Type);\n+\n+                  Discr_Value : Elmt_Id :=\n+                                  First_Elmt (Stored_Constraint (Rec_Type));\n+\n                begin\n                   while Original_Record_Component (Parent_Discr) /= Discr loop\n                      Next_Stored_Discriminant (Discr);\n@@ -2118,10 +2067,11 @@ package body Exp_Ch3 is\n          end if;\n \n          Res :=\n-            New_List (\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (Parent_Proc, Loc),\n-                Parameter_Associations => Args));\n+           New_List (\n+             Make_Procedure_Call_Statement (Loc,\n+               Name =>\n+                 New_Occurrence_Of (Parent_Proc, Loc),\n+               Parameter_Associations => Args));\n \n          return Res;\n       end Build_Init_Call_Thru;\n@@ -2159,9 +2109,11 @@ package body Exp_Ch3 is\n             Set_Defining_Unit_Name (Spec_Node, Func_Id);\n             Set_Parameter_Specifications (Spec_Node, New_List (\n               Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Make_Defining_Identifier (Loc, Name_uO),\n-                In_Present          => True,\n-                Parameter_Type      => New_Reference_To (Rec_Type, Loc))));\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uO),\n+                In_Present => True,\n+                Parameter_Type =>\n+                  New_Reference_To (Rec_Type, Loc))));\n             Set_Result_Definition (Spec_Node,\n               New_Reference_To (RTE (RE_Storage_Offset), Loc));\n \n@@ -2202,9 +2154,9 @@ package body Exp_Ch3 is\n \n          --  Local variables\n \n-         Ifaces_Comp_List : Elist_Id;\n-         Iface_Comp_Elmt  : Elmt_Id;\n          Iface_Comp       : Node_Id;\n+         Iface_Comp_Elmt  : Elmt_Id;\n+         Ifaces_Comp_List : Elist_Id;\n \n       --  Start of processing for Build_Offset_To_Top_Functions\n \n@@ -2349,13 +2301,13 @@ package body Exp_Ch3 is\n       --------------------------\n \n       procedure Build_Init_Procedure is\n+         Body_Stmts            : List_Id;\n          Body_Node             : Node_Id;\n          Handled_Stmt_Node     : Node_Id;\n+         Init_Tags_List        : List_Id;\n          Parameters            : List_Id;\n          Proc_Spec_Node        : Node_Id;\n-         Body_Stmts            : List_Id;\n          Record_Extension_Node : Node_Id;\n-         Init_Tags_List        : List_Id;\n \n       begin\n          Body_Stmts := New_List;\n@@ -2380,23 +2332,22 @@ package body Exp_Ch3 is\n             Append_To (Parameters,\n               Make_Parameter_Specification (Loc,\n                 Defining_Identifier => Set_Tag,\n-                Parameter_Type => New_Occurrence_Of (Standard_Boolean, Loc),\n-                Expression => New_Occurrence_Of (Standard_True, Loc)));\n+                Parameter_Type =>\n+                  New_Occurrence_Of (Standard_Boolean, Loc),\n+                Expression =>\n+                  New_Occurrence_Of (Standard_True, Loc)));\n          end if;\n \n          Set_Parameter_Specifications (Proc_Spec_Node, Parameters);\n          Set_Specification (Body_Node, Proc_Spec_Node);\n-         Set_Declarations (Body_Node, New_List);\n-\n-         if Parent_Subtype_Renaming_Discrims then\n+         Set_Declarations (Body_Node, Decls);\n \n-            --  N is a Derived_Type_Definition that renames the parameters\n-            --  of the ancestor type. We initialize it by expanding our\n-            --  discriminants and call the ancestor _init_proc with a\n-            --  type-converted object\n+         --  N is a Derived_Type_Definition that renames the parameters of the\n+         --  ancestor type. We initialize it by expanding our discriminants and\n+         --  call the ancestor _init_proc with a type-converted object.\n \n-            Append_List_To (Body_Stmts,\n-              Build_Init_Call_Thru (Parameters));\n+         if Parent_Subtype_Renaming_Discrims then\n+            Append_List_To (Body_Stmts, Build_Init_Call_Thru (Parameters));\n \n          elsif Nkind (Type_Definition (N)) = N_Record_Definition then\n             Build_Discriminant_Assignments (Body_Stmts);\n@@ -2407,11 +2358,11 @@ package body Exp_Ch3 is\n                    Component_List (Type_Definition (N))));\n             end if;\n \n-         else\n-            --  N is a Derived_Type_Definition with a possible non-empty\n-            --  extension. The initialization of a type extension consists\n-            --  in the initialization of the components in the extension.\n+         --  N is a Derived_Type_Definition with a possible non-empty\n+         --  extension. The initialization of a type extension consists in the\n+         --  initialization of the components in the extension.\n \n+         else\n             Build_Discriminant_Assignments (Body_Stmts);\n \n             Record_Extension_Node :=\n@@ -2626,7 +2577,48 @@ package body Exp_Ch3 is\n \n          Handled_Stmt_Node := New_Node (N_Handled_Sequence_Of_Statements, Loc);\n          Set_Statements (Handled_Stmt_Node, Body_Stmts);\n-         Set_Exception_Handlers (Handled_Stmt_Node, No_List);\n+\n+         --  Generate:\n+         --    Local_DF_Id (_init, C1, ..., CN);\n+         --    raise;\n+\n+         if Counter > 0\n+           and then Needs_Finalization (Rec_Type)\n+           and then not Is_Abstract_Type (Rec_Type)\n+           and then not Restriction_Active (No_Exception_Propagation)\n+         then\n+            declare\n+               Local_DF_Id : Entity_Id;\n+\n+            begin\n+               --  Create a local version of Deep_Finalize which has indication\n+               --  of partial initialization state.\n+\n+               Local_DF_Id := Make_Temporary (Loc, 'F');\n+\n+               Append_To (Decls,\n+                 Make_Local_Deep_Finalize (Rec_Type, Local_DF_Id));\n+\n+               Set_Exception_Handlers (Handled_Stmt_Node, New_List (\n+                 Make_Exception_Handler (Loc,\n+                   Exception_Choices => New_List (\n+                     Make_Others_Choice (Loc)),\n+\n+                   Statements => New_List (\n+                     Make_Procedure_Call_Statement (Loc,\n+                       Name =>\n+                         New_Reference_To (Local_DF_Id, Loc),\n+\n+                       Parameter_Associations => New_List (\n+                         Make_Identifier (Loc, Name_uInit),\n+                         New_Reference_To (Standard_False, Loc))),\n+\n+                     Make_Raise_Statement (Loc)))));\n+            end;\n+         else\n+            Set_Exception_Handlers (Handled_Stmt_Node, Empty_List);\n+         end if;\n+\n          Set_Handled_Statement_Sequence (Body_Node, Handled_Stmt_Node);\n \n          if not Debug_Generated_Code then\n@@ -2662,48 +2654,73 @@ package body Exp_Ch3 is\n       ---------------------------\n \n       function Build_Init_Statements (Comp_List : Node_Id) return List_Id is\n-         Check_List     : constant List_Id := New_List;\n-         Alt_List       : List_Id;\n-         Decl           : Node_Id;\n-         Id             : Entity_Id;\n-         Names          : Node_Id;\n-         Statement_List : List_Id;\n-         Stmts          : List_Id;\n-         Typ            : Entity_Id;\n-         Variant        : Node_Id;\n-\n-         Per_Object_Constraint_Components : Boolean;\n-\n-         function Has_Access_Constraint (E : Entity_Id) return Boolean;\n-         --  Components with access discriminants that depend on the current\n-         --  instance must be initialized after all other components.\n-\n-         ---------------------------\n-         -- Has_Access_Constraint --\n-         ---------------------------\n-\n-         function Has_Access_Constraint (E : Entity_Id) return Boolean is\n-            Disc : Entity_Id;\n-            T    : constant Entity_Id := Etype (E);\n+         Checks     : constant List_Id := New_List;\n+         Actions    : List_Id   := No_List;\n+         Counter_Id : Entity_Id := Empty;\n+         Decl       : Node_Id;\n+         Has_POC    : Boolean;\n+         Id         : Entity_Id;\n+         Names      : Node_Id;\n+         Stmts      : List_Id;\n+         Typ        : Entity_Id;\n+\n+         procedure Increment_Counter;\n+         --  Generate an \"increment by one\" statement for the current counter\n+         --  and append it to the list Stmts.\n+\n+         procedure Make_Counter;\n+         --  Create a new counter for the current component list. The routine\n+         --  creates a new defining Id, adds an object declaration and sets\n+         --  the Id generator for the next variant.\n+\n+         -----------------------\n+         -- Increment_Counter --\n+         -----------------------\n+\n+         procedure Increment_Counter is\n+         begin\n+            --  Generate:\n+            --    Counter := Counter + 1;\n \n+            Append_To (Stmts,\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (Counter_Id, Loc),\n+                Expression =>\n+                  Make_Op_Add (Loc,\n+                    Left_Opnd =>\n+                      New_Reference_To (Counter_Id, Loc),\n+                    Right_Opnd =>\n+                      Make_Integer_Literal (Loc, 1))));\n+         end Increment_Counter;\n+\n+         ------------------\n+         -- Make_Counter --\n+         ------------------\n+\n+         procedure Make_Counter is\n          begin\n-            if Has_Per_Object_Constraint (E)\n-              and then Has_Discriminants (T)\n-            then\n-               Disc := First_Discriminant (T);\n-               while Present (Disc) loop\n-                  if Is_Access_Type (Etype (Disc)) then\n-                     return True;\n-                  end if;\n+            --  Increment the Id generator\n \n-                  Next_Discriminant (Disc);\n-               end loop;\n+            Counter := Counter + 1;\n \n-               return False;\n-            else\n-               return False;\n-            end if;\n-         end Has_Access_Constraint;\n+            --  Create the entity and declaration\n+\n+            Counter_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name ('C', Counter));\n+\n+            --  Generate:\n+            --    Cnn : Integer := 0;\n+\n+            Append_To (Decls,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Counter_Id,\n+                Object_Definition =>\n+                  New_Reference_To (Standard_Integer, Loc),\n+                Expression =>\n+                  Make_Integer_Literal (Loc, 0)));\n+         end Make_Counter;\n \n       --  Start of processing for Build_Init_Statements\n \n@@ -2712,7 +2729,7 @@ package body Exp_Ch3 is\n             return New_List (Make_Null_Statement (Loc));\n          end if;\n \n-         Statement_List := New_List;\n+         Stmts := New_List;\n \n          --  Loop through visible declarations of task types and protected\n          --  types moving any expanded code from the spec to the body of the\n@@ -2745,7 +2762,7 @@ package body Exp_Ch3 is\n                        or else Nkind (N2) in N_Raise_xxx_Error\n                        or else Nkind (N2) = N_Procedure_Call_Statement\n                      then\n-                        Append_To (Statement_List,\n+                        Append_To (Stmts,\n                           New_Copy_Tree (N2, New_Scope => Proc_Id));\n                         Rewrite (N2, Make_Null_Statement (Sloc (N2)));\n                         Analyze (N2);\n@@ -2760,32 +2777,35 @@ package body Exp_Ch3 is\n          --  components have per object constraints, and no explicit initia-\n          --  lization.\n \n-         Per_Object_Constraint_Components := False;\n+         Has_POC := False;\n \n-         --  First step : regular components\n+         --  First pass : regular components\n \n          Decl := First_Non_Pragma (Component_Items (Comp_List));\n          while Present (Decl) loop\n             Loc := Sloc (Decl);\n             Build_Record_Checks\n-              (Subtype_Indication (Component_Definition (Decl)), Check_List);\n+              (Subtype_Indication (Component_Definition (Decl)), Checks);\n \n             Id := Defining_Identifier (Decl);\n             Typ := Etype (Id);\n \n+            --  Leave any processing of per-object constrained component for\n+            --  the second pass.\n+\n             if Has_Access_Constraint (Id)\n               and then No (Expression (Decl))\n             then\n-               --  Skip processing for now and ask for a second pass\n+               Has_POC := True;\n \n-               Per_Object_Constraint_Components := True;\n+            --  Regular component cases\n \n             else\n-               --  Case of explicit initialization\n+               --  Explicit initialization\n \n                if Present (Expression (Decl)) then\n                   if Is_CPP_Constructor_Call (Expression (Decl)) then\n-                     Stmts :=\n+                     Actions :=\n                        Build_Initialization_Call\n                          (Loc,\n                           Id_Ref          =>\n@@ -2799,65 +2819,59 @@ package body Exp_Ch3 is\n                           Discr_Map       => Discr_Map,\n                           Constructor_Ref => Expression (Decl));\n                   else\n-                     Stmts := Build_Assignment (Id, Expression (Decl));\n+                     Actions := Build_Assignment (Id, Expression (Decl));\n                   end if;\n \n-               --  Case of composite component with its own Init_Proc\n+               --  Composite component with its own Init_Proc\n \n                elsif not Is_Interface (Typ)\n                  and then Has_Non_Null_Base_Init_Proc (Typ)\n                then\n-                  Stmts :=\n+                  Actions :=\n                     Build_Initialization_Call\n                       (Loc,\n-                       Id_Ref       =>\n-                         Make_Selected_Component (Loc,\n-                           Prefix        => Make_Identifier (Loc, Name_uInit),\n-                           Selector_Name => New_Occurrence_Of (Id, Loc)),\n-                       Typ          => Typ,\n+                       Make_Selected_Component (Loc,\n+                         Prefix =>\n+                           Make_Identifier (Loc, Name_uInit),\n+                         Selector_Name =>\n+                           New_Occurrence_Of (Id, Loc)),\n+                       Typ,\n                        In_Init_Proc => True,\n                        Enclos_Type  => Rec_Type,\n                        Discr_Map    => Discr_Map);\n \n                   Clean_Task_Names (Typ, Proc_Id);\n \n-               --  Case of component needing simple initialization\n+               --  Simple initialization\n \n                elsif Component_Needs_Simple_Initialization (Typ) then\n-                  Stmts :=\n+                  Actions :=\n                     Build_Assignment\n                       (Id, Get_Simple_Init_Val (Typ, N, Esize (Id)));\n \n                --  Nothing needed for this case\n \n                else\n-                  Stmts := No_List;\n+                  Actions := No_List;\n                end if;\n \n-               if Present (Check_List) then\n-                  Append_List_To (Statement_List, Check_List);\n+               if Present (Checks) then\n+                  Append_List_To (Stmts, Checks);\n                end if;\n \n-               if Present (Stmts) then\n-\n-                  --  Add the initialization of the record controller before\n-                  --  the _Parent field is attached to it when the attachment\n-                  --  can occur. It does not work to simply initialize the\n-                  --  controller first: it must be initialized after the parent\n-                  --  if the parent holds discriminants that can be used to\n-                  --  compute the offset of the controller. We assume here that\n-                  --  the last statement of the initialization call is the\n-                  --  attachment of the parent (see Build_Initialization_Call)\n-\n-                  if Chars (Id) = Name_uController\n-                    and then Rec_Type /= Etype (Rec_Type)\n-                    and then Has_Controlled_Component (Etype (Rec_Type))\n-                    and then Has_New_Controlled_Component (Rec_Type)\n-                    and then Present (Last (Statement_List))\n+               if Present (Actions) then\n+                  Append_List_To (Stmts, Actions);\n+\n+                  --  Preserve the initialization state in the current counter\n+\n+                  if Chars (Id) /= Name_uParent\n+                    and then Needs_Finalization (Typ)\n                   then\n-                     Insert_List_Before (Last (Statement_List), Stmts);\n-                  else\n-                     Append_List_To (Statement_List, Stmts);\n+                     if No (Counter_Id) then\n+                        Make_Counter;\n+                     end if;\n+\n+                     Increment_Counter;\n                   end if;\n                end if;\n             end if;\n@@ -2871,29 +2885,31 @@ package body Exp_Ch3 is\n          --  components) is initialized, because the initialization of these\n          --  components may reference the enclosing concurrent object.\n \n-         --  For a task record type, add the task create call and calls\n-         --  to bind any interrupt (signal) entries.\n+         --  For a task record type, add the task create call and calls to bind\n+         --  any interrupt (signal) entries.\n \n          if Is_Task_Record_Type (Rec_Type) then\n \n             --  In the case of the restricted run time the ATCB has already\n             --  been preallocated.\n \n             if Restricted_Profile then\n-               Append_To (Statement_List,\n+               Append_To (Stmts,\n                  Make_Assignment_Statement (Loc,\n-                   Name => Make_Selected_Component (Loc,\n-                     Prefix        => Make_Identifier (Loc, Name_uInit),\n-                     Selector_Name => Make_Identifier (Loc, Name_uTask_Id)),\n-                   Expression => Make_Attribute_Reference (Loc,\n-                     Prefix =>\n-                       Make_Selected_Component (Loc,\n-                         Prefix        => Make_Identifier (Loc, Name_uInit),\n-                         Selector_Name => Make_Identifier (Loc, Name_uATCB)),\n-                     Attribute_Name => Name_Unchecked_Access)));\n+                   Name =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix        => Make_Identifier (Loc, Name_uInit),\n+                       Selector_Name => Make_Identifier (Loc, Name_uTask_Id)),\n+                   Expression =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix =>\n+                         Make_Selected_Component (Loc,\n+                           Prefix        => Make_Identifier (Loc, Name_uInit),\n+                           Selector_Name => Make_Identifier (Loc, Name_uATCB)),\n+                       Attribute_Name => Name_Unchecked_Access)));\n             end if;\n \n-            Append_To (Statement_List, Make_Task_Create_Call (Rec_Type));\n+            Append_To (Stmts, Make_Task_Create_Call (Rec_Type));\n \n             --  Generate the statements which map a string entry name to a\n             --  task entry index. Note that the task may not have entries.\n@@ -2902,7 +2918,7 @@ package body Exp_Ch3 is\n                Names := Build_Entry_Names (Rec_Type);\n \n                if Present (Names) then\n-                  Append_To (Statement_List, Names);\n+                  Append_To (Stmts, Names);\n                end if;\n             end if;\n \n@@ -2911,8 +2927,8 @@ package body Exp_Ch3 is\n                              Corresponding_Concurrent_Type (Rec_Type);\n                Task_Decl : constant Node_Id := Parent (Task_Type);\n                Task_Def  : constant Node_Id := Task_Definition (Task_Decl);\n-               Vis_Decl  : Node_Id;\n                Ent       : Entity_Id;\n+               Vis_Decl  : Node_Id;\n \n             begin\n                if Present (Task_Def) then\n@@ -2927,10 +2943,11 @@ package body Exp_Ch3 is\n                            Ent := Entity (Name (Vis_Decl));\n \n                            if Ekind (Ent) = E_Entry then\n-                              Append_To (Statement_List,\n+                              Append_To (Stmts,\n                                 Make_Procedure_Call_Statement (Loc,\n-                                  Name => New_Reference_To (\n-                                    RTE (RE_Bind_Interrupt_To_Entry), Loc),\n+                                  Name =>\n+                                    New_Reference_To (RTE (\n+                                      RE_Bind_Interrupt_To_Entry), Loc),\n                                   Parameter_Associations => New_List (\n                                     Make_Selected_Component (Loc,\n                                       Prefix        =>\n@@ -2954,7 +2971,7 @@ package body Exp_Ch3 is\n          --  Make_Initialize_Protection.\n \n          if Is_Protected_Record_Type (Rec_Type) then\n-            Append_List_To (Statement_List,\n+            Append_List_To (Stmts,\n               Make_Initialize_Protection (Rec_Type));\n \n             --  Generate the statements which map a string entry name to a\n@@ -2965,15 +2982,14 @@ package body Exp_Ch3 is\n                Names := Build_Entry_Names (Rec_Type);\n \n                if Present (Names) then\n-                  Append_To (Statement_List, Names);\n+                  Append_To (Stmts, Names);\n                end if;\n             end if;\n          end if;\n \n-         if Per_Object_Constraint_Components then\n-\n-            --  Second pass: components with per-object constraints\n+         --  Second pass: components with per-object constraints\n \n+         if Has_POC then\n             Decl := First_Non_Pragma (Component_Items (Comp_List));\n             while Present (Decl) loop\n                Loc := Sloc (Decl);\n@@ -2984,7 +3000,7 @@ package body Exp_Ch3 is\n                  and then No (Expression (Decl))\n                then\n                   if Has_Non_Null_Base_Init_Proc (Typ) then\n-                     Append_List_To (Statement_List,\n+                     Append_List_To (Stmts,\n                        Build_Initialization_Call (Loc,\n                          Make_Selected_Component (Loc,\n                            Prefix        => Make_Identifier (Loc, Name_uInit),\n@@ -2996,8 +3012,19 @@ package body Exp_Ch3 is\n \n                      Clean_Task_Names (Typ, Proc_Id);\n \n+                     --  Preserve the initialization state in the current\n+                     --  counter.\n+\n+                     if Needs_Finalization (Typ) then\n+                        if No (Counter_Id) then\n+                           Make_Counter;\n+                        end if;\n+\n+                        Increment_Counter;\n+                     end if;\n+\n                   elsif Component_Needs_Simple_Initialization (Typ) then\n-                     Append_List_To (Statement_List,\n+                     Append_List_To (Stmts,\n                        Build_Assignment\n                          (Id, Get_Simple_Init_Val (Typ, N, Esize (Id))));\n                   end if;\n@@ -3010,40 +3037,46 @@ package body Exp_Ch3 is\n          --  Process the variant part\n \n          if Present (Variant_Part (Comp_List)) then\n-            Alt_List := New_List;\n-            Variant := First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n-            while Present (Variant) loop\n-               Loc := Sloc (Variant);\n-               Append_To (Alt_List,\n-                 Make_Case_Statement_Alternative (Loc,\n-                   Discrete_Choices =>\n-                     New_Copy_List (Discrete_Choices (Variant)),\n-                   Statements =>\n-                     Build_Init_Statements (Component_List (Variant))));\n-               Next_Non_Pragma (Variant);\n-            end loop;\n+            declare\n+               Variant_Alts : constant List_Id := New_List;\n+               Variant      : Node_Id;\n \n-            --  The expression of the case statement which is a reference\n-            --  to one of the discriminants is replaced by the appropriate\n-            --  formal parameter of the initialization procedure.\n+            begin\n+               Variant :=\n+                 First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n+               while Present (Variant) loop\n+                  Loc := Sloc (Variant);\n+                  Append_To (Variant_Alts,\n+                    Make_Case_Statement_Alternative (Loc,\n+                      Discrete_Choices =>\n+                        New_Copy_List (Discrete_Choices (Variant)),\n+                      Statements =>\n+                        Build_Init_Statements (Component_List (Variant))));\n+                  Next_Non_Pragma (Variant);\n+               end loop;\n \n-            Append_To (Statement_List,\n-              Make_Case_Statement (Loc,\n-                Expression =>\n-                  New_Reference_To (Discriminal (\n-                    Entity (Name (Variant_Part (Comp_List)))), Loc),\n-                Alternatives => Alt_List));\n+               --  The expression of the case statement which is a reference\n+               --  to one of the discriminants is replaced by the appropriate\n+               --  formal parameter of the initialization procedure.\n+\n+               Append_To (Stmts,\n+                 Make_Case_Statement (Loc,\n+                   Expression =>\n+                     New_Reference_To (Discriminal (\n+                       Entity (Name (Variant_Part (Comp_List)))), Loc),\n+                   Alternatives => Variant_Alts));\n+            end;\n          end if;\n \n          --  If no initializations when generated for component declarations\n-         --  corresponding to this Statement_List, append a null statement\n-         --  to the Statement_List to make it a valid Ada tree.\n+         --  corresponding to this Stmts, append a null statement to Stmts to\n+         --  to make it a valid Ada tree.\n \n-         if Is_Empty_List (Statement_List) then\n-            Append (New_Node (N_Null_Statement, Loc), Statement_List);\n+         if Is_Empty_List (Stmts) then\n+            Append (New_Node (N_Null_Statement, Loc), Stmts);\n          end if;\n \n-         return Statement_List;\n+         return Stmts;\n \n       exception\n          when RE_Not_Available =>\n@@ -3057,6 +3090,89 @@ package body Exp_Ch3 is\n       procedure Build_Record_Checks (S : Node_Id; Check_List : List_Id) is\n          Subtype_Mark_Id : Entity_Id;\n \n+         procedure Constrain_Array\n+           (SI         : Node_Id;\n+            Check_List : List_Id);\n+         --  Apply a list of index constraints to an unconstrained array type.\n+         --  The first parameter is the entity for the resulting subtype.\n+         --  Check_List is a list to which the check actions are appended.\n+\n+         ---------------------\n+         -- Constrain_Array --\n+         ---------------------\n+\n+         procedure Constrain_Array\n+           (SI         : Node_Id;\n+            Check_List : List_Id)\n+         is\n+            C                     : constant Node_Id := Constraint (SI);\n+            Number_Of_Constraints : Nat := 0;\n+            Index                 : Node_Id;\n+            S, T                  : Entity_Id;\n+\n+            procedure Constrain_Index\n+              (Index      : Node_Id;\n+               S          : Node_Id;\n+               Check_List : List_Id);\n+            --  Process an index constraint in a constrained array declaration.\n+            --  The constraint can be either a subtype name or a range with or\n+            --  without an explicit subtype mark. Index is the corresponding\n+            --  index of the unconstrained array. S is the range expression.\n+            --  Check_List is a list to which the check actions are appended.\n+\n+            ---------------------\n+            -- Constrain_Index --\n+            ---------------------\n+\n+            procedure Constrain_Index\n+              (Index        : Node_Id;\n+               S            : Node_Id;\n+               Check_List   : List_Id)\n+            is\n+               T : constant Entity_Id := Etype (Index);\n+\n+            begin\n+               if Nkind (S) = N_Range then\n+                  Process_Range_Expr_In_Decl (S, T, Check_List);\n+               end if;\n+            end Constrain_Index;\n+\n+         --  Start of processing for Constrain_Array\n+\n+         begin\n+            T := Entity (Subtype_Mark (SI));\n+\n+            if Ekind (T) in Access_Kind then\n+               T := Designated_Type (T);\n+            end if;\n+\n+            S := First (Constraints (C));\n+\n+            while Present (S) loop\n+               Number_Of_Constraints := Number_Of_Constraints + 1;\n+               Next (S);\n+            end loop;\n+\n+            --  In either case, the index constraint must provide a discrete\n+            --  range for each index of the array type and the type of each\n+            --  discrete range must be the same as that of the corresponding\n+            --  index. (RM 3.6.1)\n+\n+            S := First (Constraints (C));\n+            Index := First_Index (T);\n+            Analyze (Index);\n+\n+            --  Apply constraints to each index type\n+\n+            for J in 1 .. Number_Of_Constraints loop\n+               Constrain_Index (Index, S, Check_List);\n+               Next (Index);\n+               Next (S);\n+            end loop;\n+         end Constrain_Array;\n+\n+      --  Start of processing for Build_Record_Checks\n+\n       begin\n          if Nkind (S) = N_Subtype_Indication then\n             Find_Type (Subtype_Mark (S));\n@@ -3092,69 +3208,6 @@ package body Exp_Ch3 is\n              and then not Is_RTE (T, RE_Interface_Tag);\n       end Component_Needs_Simple_Initialization;\n \n-      ---------------------\n-      -- Constrain_Array --\n-      ---------------------\n-\n-      procedure Constrain_Array\n-        (SI          : Node_Id;\n-         Check_List  : List_Id)\n-      is\n-         C                     : constant Node_Id := Constraint (SI);\n-         Number_Of_Constraints : Nat := 0;\n-         Index                 : Node_Id;\n-         S, T                  : Entity_Id;\n-\n-      begin\n-         T := Entity (Subtype_Mark (SI));\n-\n-         if Ekind (T) in Access_Kind then\n-            T := Designated_Type (T);\n-         end if;\n-\n-         S := First (Constraints (C));\n-\n-         while Present (S) loop\n-            Number_Of_Constraints := Number_Of_Constraints + 1;\n-            Next (S);\n-         end loop;\n-\n-         --  In either case, the index constraint must provide a discrete\n-         --  range for each index of the array type and the type of each\n-         --  discrete range must be the same as that of the corresponding\n-         --  index. (RM 3.6.1)\n-\n-         S := First (Constraints (C));\n-         Index := First_Index (T);\n-         Analyze (Index);\n-\n-         --  Apply constraints to each index type\n-\n-         for J in 1 .. Number_Of_Constraints loop\n-            Constrain_Index (Index, S, Check_List);\n-            Next (Index);\n-            Next (S);\n-         end loop;\n-\n-      end Constrain_Array;\n-\n-      ---------------------\n-      -- Constrain_Index --\n-      ---------------------\n-\n-      procedure Constrain_Index\n-        (Index        : Node_Id;\n-         S            : Node_Id;\n-         Check_List   : List_Id)\n-      is\n-         T : constant Entity_Id := Etype (Index);\n-\n-      begin\n-         if Nkind (S) = N_Range then\n-            Process_Range_Expr_In_Decl (S, T, Check_List);\n-         end if;\n-      end Constrain_Index;\n-\n       --------------------------------------\n       -- Parent_Subtype_Renaming_Discrims --\n       --------------------------------------\n@@ -3164,32 +3217,34 @@ package body Exp_Ch3 is\n          Dp : Entity_Id;\n \n       begin\n-         if Base_Type (Pe) /= Pe then\n+         if Base_Type (Rec_Ent) /= Rec_Ent then\n             return False;\n          end if;\n \n-         if Etype (Pe) = Pe\n-           or else not Has_Discriminants (Pe)\n-           or else Is_Constrained (Pe)\n-           or else Is_Tagged_Type (Pe)\n+         if Etype (Rec_Ent) = Rec_Ent\n+           or else not Has_Discriminants (Rec_Ent)\n+           or else Is_Constrained (Rec_Ent)\n+           or else Is_Tagged_Type (Rec_Ent)\n          then\n             return False;\n          end if;\n \n          --  If there are no explicit stored discriminants we have inherited\n          --  the root type discriminants so far, so no renamings occurred.\n \n-         if First_Discriminant (Pe) = First_Stored_Discriminant (Pe) then\n+         if First_Discriminant (Rec_Ent) =\n+              First_Stored_Discriminant (Rec_Ent)\n+         then\n             return False;\n          end if;\n \n          --  Check if we have done some trivial renaming of the parent\n          --  discriminants, i.e. something like\n          --\n-         --    type DT (X1,X2: int) is new PT (X1,X2);\n+         --    type DT (X1, X2: int) is new PT (X1, X2);\n \n-         De := First_Discriminant (Pe);\n-         Dp := First_Discriminant (Etype (Pe));\n+         De := First_Discriminant (Rec_Ent);\n+         Dp := First_Discriminant (Etype (Rec_Ent));\n \n          while Present (De) loop\n             pragma Assert (Present (Dp));\n@@ -3399,7 +3454,7 @@ package body Exp_Ch3 is\n          Build_Offset_To_Top_Functions;\n          Build_CPP_Init_Procedure;\n          Build_Init_Procedure;\n-         Set_Is_Public (Proc_Id, Is_Public (Pe));\n+         Set_Is_Public (Proc_Id, Is_Public (Rec_Ent));\n \n          --  The initialization of protected records is not worth inlining.\n          --  In addition, when compiled for another unit for inlining purposes,\n@@ -4067,7 +4122,6 @@ package body Exp_Ch3 is\n \n             Append_List_To (Stmts,\n               Make_Eq_Case (Typ, Comps, A));\n-\n          end;\n \n       --  Normal case (not unchecked union)\n@@ -4569,21 +4623,6 @@ package body Exp_Ch3 is\n          Build_Master_Entity (Def_Id);\n       end if;\n \n-      --  Build a list controller for declarations where the type is anonymous\n-      --  access and the designated type is controlled. Only declarations from\n-      --  source files receive such controllers in order to provide the same\n-      --  lifespan for any potential coextensions that may be associated with\n-      --  the object. Finalization lists of internal controlled anonymous\n-      --  access objects are already handled in Expand_N_Allocator.\n-\n-      if Comes_From_Source (N)\n-        and then Ekind (Typ) = E_Anonymous_Access_Type\n-        and then Is_Controlled (Directly_Designated_Type (Typ))\n-        and then No (Associated_Final_Chain (Typ))\n-      then\n-         Build_Final_List (N, Typ);\n-      end if;\n-\n       --  Default initialization required, and no expression present\n \n       if No (Expr) then\n@@ -4617,12 +4656,10 @@ package body Exp_Ch3 is\n          elsif not Abort_Allowed\n            or else not Comes_From_Source (N)\n          then\n-            Insert_Actions_After (Init_After,\n+            Insert_Action_After (Init_After,\n               Make_Init_Call (\n-                Ref         => New_Occurrence_Of (Def_Id, Loc),\n-                Typ         => Base_Type (Typ),\n-                Flist_Ref   => Find_Final_List (Def_Id),\n-                With_Attach => Make_Integer_Literal (Loc, 1)));\n+                Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n+                Typ     => Base_Type (Typ)));\n \n          --  Abort allowed\n \n@@ -4642,12 +4679,10 @@ package body Exp_Ch3 is\n             --  requires some code reorganization...\n \n             declare\n-               L   : constant List_Id :=\n-                       Make_Init_Call\n-                         (Ref         => New_Occurrence_Of (Def_Id, Loc),\n-                          Typ         => Base_Type (Typ),\n-                          Flist_Ref   => Find_Final_List (Def_Id),\n-                          With_Attach => Make_Integer_Literal (Loc, 1));\n+               L   : constant List_Id := New_List (\n+                       Make_Init_Call (\n+                         Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n+                         Typ     => Base_Type (Typ)));\n \n                Blk : constant Node_Id :=\n                        Make_Block_Statement (Loc,\n@@ -5072,12 +5107,10 @@ package body Exp_Ch3 is\n               and then not Is_Immutably_Limited_Type (Typ)\n               and then not Rewrite_As_Renaming\n             then\n-               Insert_Actions_After (Init_After,\n+               Insert_Action_After (Init_After,\n                  Make_Adjust_Call (\n-                   Ref          => New_Reference_To (Def_Id, Loc),\n-                   Typ          => Base_Type (Typ),\n-                   Flist_Ref    => Find_Final_List (Def_Id),\n-                   With_Attach  => Make_Integer_Literal (Loc, 1)));\n+                   Obj_Ref => New_Reference_To (Def_Id, Loc),\n+                   Typ     => Base_Type (Typ)));\n             end if;\n \n             --  For tagged types, when an init value is given, the tag has to\n@@ -5336,146 +5369,6 @@ package body Exp_Ch3 is\n       end loop;\n    end Expand_Previous_Access_Type;\n \n-   ------------------------------\n-   -- Expand_Record_Controller --\n-   ------------------------------\n-\n-   --  Need some more comments in this body ???\n-\n-   procedure Expand_Record_Controller (T : Entity_Id) is\n-      Def             : Node_Id := Type_Definition (Parent (T));\n-      Comp_List       : Node_Id;\n-      Comp_Decl       : Node_Id;\n-      Loc             : Source_Ptr;\n-      First_Comp      : Node_Id;\n-      Controller_Type : Entity_Id;\n-      Ent             : Entity_Id;\n-\n-   begin\n-      if Nkind (Def) = N_Derived_Type_Definition then\n-         Def := Record_Extension_Part (Def);\n-      end if;\n-\n-      if Null_Present (Def) then\n-         Set_Component_List (Def,\n-           Make_Component_List (Sloc (Def),\n-             Component_Items => Empty_List,\n-             Variant_Part => Empty,\n-             Null_Present => True));\n-      end if;\n-\n-      Comp_List := Component_List (Def);\n-\n-      if Null_Present (Comp_List)\n-        or else Is_Empty_List (Component_Items (Comp_List))\n-      then\n-         Loc := Sloc (Comp_List);\n-      else\n-         Loc := Sloc (First (Component_Items (Comp_List)));\n-      end if;\n-\n-      if Is_Immutably_Limited_Type (T) then\n-         Controller_Type := RTE (RE_Limited_Record_Controller);\n-      else\n-         Controller_Type := RTE (RE_Record_Controller);\n-      end if;\n-\n-      Ent := Make_Defining_Identifier (Loc, Name_uController);\n-\n-      Comp_Decl :=\n-        Make_Component_Declaration (Loc,\n-          Defining_Identifier =>  Ent,\n-          Component_Definition =>\n-            Make_Component_Definition (Loc,\n-              Aliased_Present => False,\n-              Subtype_Indication => New_Reference_To (Controller_Type, Loc)));\n-\n-      if Null_Present (Comp_List)\n-        or else Is_Empty_List (Component_Items (Comp_List))\n-      then\n-         Set_Component_Items (Comp_List, New_List (Comp_Decl));\n-         Set_Null_Present (Comp_List, False);\n-\n-      else\n-         --  The controller cannot be placed before the _Parent field since\n-         --  gigi lays out field in order and _parent must be first to preserve\n-         --  the polymorphism of tagged types.\n-\n-         First_Comp := First (Component_Items (Comp_List));\n-\n-         if not Is_Tagged_Type (T) then\n-            Insert_Before (First_Comp, Comp_Decl);\n-\n-         --  if T is a tagged type, place controller declaration after parent\n-         --  field and after eventual tags of interface types.\n-\n-         else\n-            while Present (First_Comp)\n-              and then\n-                (Chars (Defining_Identifier (First_Comp)) = Name_uParent\n-                   or else Is_Tag (Defining_Identifier (First_Comp))\n-\n-               --  Ada 2005 (AI-251): The following condition covers secondary\n-               --  tags but also the adjacent component containing the offset\n-               --  to the base of the object (component generated if the parent\n-               --  has discriminants --- see Add_Interface_Tag_Components).\n-               --  This is required to avoid the addition of the controller\n-               --  between the secondary tag and its adjacent component.\n-\n-                   or else Present\n-                             (Related_Type\n-                               (Defining_Identifier (First_Comp))))\n-            loop\n-               Next (First_Comp);\n-            end loop;\n-\n-            --  An empty tagged extension might consist only of the parent\n-            --  component. Otherwise insert the controller before the first\n-            --  component that is neither parent nor tag.\n-\n-            if Present (First_Comp) then\n-               Insert_Before (First_Comp, Comp_Decl);\n-            else\n-               Append (Comp_Decl, Component_Items (Comp_List));\n-            end if;\n-         end if;\n-      end if;\n-\n-      Push_Scope (T);\n-      Analyze (Comp_Decl);\n-      Set_Ekind (Ent, E_Component);\n-      Init_Component_Location (Ent);\n-\n-      --  Move the _controller entity ahead in the list of internal entities\n-      --  of the enclosing record so that it is selected instead of a\n-      --  potentially inherited one.\n-\n-      declare\n-         E    : constant Entity_Id := Last_Entity (T);\n-         Comp : Entity_Id;\n-\n-      begin\n-         pragma Assert (Chars (E) = Name_uController);\n-\n-         Set_Next_Entity (E, First_Entity (T));\n-         Set_First_Entity (T, E);\n-\n-         Comp := Next_Entity (E);\n-         while Next_Entity (Comp) /= E loop\n-            Next_Entity (Comp);\n-         end loop;\n-\n-         Set_Next_Entity (Comp, Empty);\n-         Set_Last_Entity (T, Comp);\n-      end;\n-\n-      End_Scope;\n-\n-   exception\n-      when RE_Not_Available =>\n-         return;\n-   end Expand_Record_Controller;\n-\n    ------------------------\n    -- Expand_Tagged_Root --\n    ------------------------\n@@ -5557,9 +5450,9 @@ package body Exp_Ch3 is\n    ------------------------------\n \n    procedure Expand_Freeze_Array_Type (N : Node_Id) is\n-      Typ      : constant Entity_Id  := Entity (N);\n+      Typ      : constant Entity_Id := Entity (N);\n       Comp_Typ : constant Entity_Id := Component_Type (Typ);\n-      Base     : constant Entity_Id  := Base_Type (Typ);\n+      Base     : constant Entity_Id := Base_Type (Typ);\n \n    begin\n       if not Is_Bit_Packed_Array (Typ) then\n@@ -5619,10 +5512,12 @@ package body Exp_Ch3 is\n                   Build_Slice_Assignment (Typ);\n                end if;\n \n+            --  ??? This may not be necessary after all\n+\n             elsif Ekind (Comp_Typ) = E_Anonymous_Access_Type\n               and then Needs_Finalization (Directly_Designated_Type (Comp_Typ))\n             then\n-               Set_Associated_Final_Chain (Comp_Typ, Add_Final_Chain (Typ));\n+               Build_Finalization_Collection (Comp_Typ);\n             end if;\n          end if;\n \n@@ -5641,6 +5536,75 @@ package body Exp_Ch3 is\n       end if;\n    end Expand_Freeze_Array_Type;\n \n+   -----------------------------------\n+   -- Expand_Freeze_Class_Wide_Type --\n+   -----------------------------------\n+\n+   procedure Expand_Freeze_Class_Wide_Type (N : Node_Id) is\n+      Typ  : constant Entity_Id := Entity (N);\n+      Root : constant Entity_Id := Root_Type (Typ);\n+\n+      function Is_C_Derivation (Typ : Entity_Id) return Boolean;\n+      --  Given a type, determine whether it is derived from a C or C++ root\n+\n+      ---------------------\n+      -- Is_C_Derivation --\n+      ---------------------\n+\n+      function Is_C_Derivation (Typ : Entity_Id) return Boolean is\n+         T : Entity_Id := Typ;\n+\n+      begin\n+         loop\n+            if Is_CPP_Class (T)\n+              or else Convention (T) = Convention_C\n+              or else Convention (T) = Convention_CPP\n+            then\n+               return True;\n+            end if;\n+\n+            exit when T = Etype (T);\n+\n+            T := Etype (T);\n+         end loop;\n+\n+         return False;\n+      end Is_C_Derivation;\n+\n+   --  Start of processing for Expand_Freeze_Class_Wide_Type\n+\n+   begin\n+      --  Do not create TSS routine Finalize_Address for concurrent class-wide\n+      --  types. Ignore C, C++, CIL and Java types since it is assumed that the\n+      --  non-Ada side will handle their destruction.\n+\n+      if Is_Concurrent_Type (Root)\n+        or else Is_C_Derivation (Root)\n+        or else Convention (Typ) = Convention_CIL\n+        or else Convention (Typ) = Convention_CPP\n+        or else Convention (Typ) = Convention_Java\n+      then\n+         return;\n+\n+      --  Do not create TSS routine Finalize_Address when dispatching calls are\n+      --  disabled since the core of the routine is a dispatching call.\n+\n+      elsif Restriction_Active (No_Dispatching_Calls) then\n+         return;\n+\n+      --  Do not create TSS routine Finalize_Address for .NET/JVM because these\n+      --  targets do not support address arithmetic and unchecked conversions.\n+\n+      elsif VM_Target /= No_VM then\n+         return;\n+      end if;\n+\n+      --  Generate the body of Finalize_Address. This routine is accessible\n+      --  through the TSS mechanism.\n+\n+      Make_Finalize_Address_Body (Typ);\n+   end Expand_Freeze_Class_Wide_Type;\n+\n    ------------------------------------\n    -- Expand_Freeze_Enumeration_Type --\n    ------------------------------------\n@@ -5957,10 +5921,6 @@ package body Exp_Ch3 is\n       Comp_Typ    : Entity_Id;\n       Predef_List : List_Id;\n \n-      Flist : Entity_Id := Empty;\n-      --  Finalization list allocated for the case of a type with anonymous\n-      --  access components whose designated type is potentially controlled.\n-\n       Renamed_Eq : Node_Id := Empty;\n       --  Defining unit name for the predefined equality function in the case\n       --  where the type has a primitive operation that is a renaming of\n@@ -6045,15 +6005,6 @@ package body Exp_Ch3 is\n                                 and then Is_Controlled (Comp_Typ)))\n          then\n             Set_Has_Controlled_Component (Def_Id);\n-\n-         elsif Ekind (Comp_Typ) = E_Anonymous_Access_Type\n-           and then Needs_Finalization (Directly_Designated_Type (Comp_Typ))\n-         then\n-            if No (Flist) then\n-               Flist := Add_Final_Chain (Def_Id);\n-            end if;\n-\n-            Set_Associated_Final_Chain (Comp_Typ, Flist);\n          end if;\n \n          Next_Component (Comp);\n@@ -6153,7 +6104,7 @@ package body Exp_Ch3 is\n                null;\n \n             --  Do not add the spec of the predefined primitives if we are\n-            --  compiling under restriction No_Dispatching_Calls\n+            --  compiling under restriction No_Dispatching_Calls.\n \n             elsif not Restriction_Active (No_Dispatching_Calls) then\n                Make_Predefined_Primitive_Specs\n@@ -6197,13 +6148,6 @@ package body Exp_Ch3 is\n                Set_All_DT_Position (Def_Id);\n             end if;\n \n-            --  Add the controlled component before the freezing actions\n-            --  referenced in those actions.\n-\n-            if Has_New_Controlled_Component (Def_Id) then\n-               Expand_Record_Controller (Def_Id);\n-            end if;\n-\n             --  Create and decorate the tags. Suppress their creation when\n             --  VM_Target because the dispatching mechanism is handled\n             --  internally by the VMs.\n@@ -6229,8 +6173,7 @@ package body Exp_Ch3 is\n               and then Present (Underlying_Record_View (Def_Id))\n             then\n                declare\n-                  Rep : constant Entity_Id :=\n-                           Underlying_Record_View (Def_Id);\n+                  Rep : constant Entity_Id := Underlying_Record_View (Def_Id);\n                begin\n                   Set_Access_Disp_Table\n                     (Rep, Access_Disp_Table       (Def_Id));\n@@ -6263,7 +6206,7 @@ package body Exp_Ch3 is\n \n             --  Freeze rest of primitive operations. There is no need to handle\n             --  the predefined primitives if we are compiling under restriction\n-            --  No_Dispatching_Calls\n+            --  No_Dispatching_Calls.\n \n             if not Restriction_Active (No_Dispatching_Calls) then\n                Append_Freeze_Actions\n@@ -6339,10 +6282,6 @@ package body Exp_Ch3 is\n       end if;\n \n       if Has_Controlled_Component (Def_Id) then\n-         if No (Controller_Component (Def_Id)) then\n-            Expand_Record_Controller (Def_Id);\n-         end if;\n-\n          Build_Controlling_Procs (Def_Id);\n       end if;\n \n@@ -6388,6 +6327,11 @@ package body Exp_Ch3 is\n          elsif not Restriction_Active (No_Dispatching_Calls) then\n             Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n             Append_Freeze_Actions (Def_Id, Predef_List);\n+\n+            --  Create the body of Finalize_Address, a helper routine used in\n+            --  conjunction with controlled objects on the heap.\n+\n+            Make_Finalize_Address_Body (Def_Id);\n          end if;\n \n          --  Ada 2005 (AI-391): If any wrappers were created for nonoverridden\n@@ -6420,6 +6364,29 @@ package body Exp_Ch3 is\n             end loop;\n          end;\n       end if;\n+\n+      --  Processing for components of anonymous access type that designate\n+      --  a controlled type.\n+\n+      Comp := First_Component (Def_Id);\n+      while Present (Comp) loop\n+         Comp_Typ := Etype (Comp);\n+\n+         if Ekind (Comp_Typ) = E_Anonymous_Access_Type\n+           and then Needs_Finalization (Directly_Designated_Type (Comp_Typ))\n+\n+            --  Avoid self-references\n+\n+           and then Directly_Designated_Type (Comp_Typ) /= Def_Id\n+         then\n+            Build_Finalization_Collection\n+             (Typ        => Comp_Typ,\n+              Ins_Node   => Parent (Def_Id),\n+              Encl_Scope => Scope (Def_Id));\n+         end if;\n+\n+         Next_Component (Comp);\n+      end loop;\n    end Expand_Freeze_Record_Type;\n \n    ------------------------------\n@@ -6505,74 +6472,8 @@ package body Exp_Ch3 is\n          if Ekind (Def_Id) = E_Record_Type then\n             Expand_Freeze_Record_Type (N);\n \n-         --  The subtype may have been declared before the type was frozen. If\n-         --  the type has controlled components it is necessary to create the\n-         --  entity for the controller explicitly because it did not exist at\n-         --  the point of the subtype declaration. Only the entity is needed,\n-         --  the back-end will obtain the layout from the type. This is only\n-         --  necessary if this is constrained subtype whose component list is\n-         --  not shared with the base type.\n-\n-         elsif Ekind (Def_Id) = E_Record_Subtype\n-           and then Has_Discriminants (Def_Id)\n-           and then Last_Entity (Def_Id) /= Last_Entity (Base_Type (Def_Id))\n-           and then Present (Controller_Component (Def_Id))\n-         then\n-            declare\n-               Old_C : constant Entity_Id := Controller_Component (Def_Id);\n-               New_C : Entity_Id;\n-\n-            begin\n-               if Scope (Old_C) = Base_Type (Def_Id) then\n-\n-                  --  The entity is the one in the parent. Create new one\n-\n-                  New_C := New_Copy (Old_C);\n-                  Set_Parent (New_C, Parent (Old_C));\n-                  Push_Scope (Def_Id);\n-                  Enter_Name (New_C);\n-                  End_Scope;\n-               end if;\n-            end;\n-\n-            if Is_Itype (Def_Id)\n-              and then Is_Record_Type (Underlying_Type (Scope (Def_Id)))\n-            then\n-               --  The freeze node is only used to introduce the controller,\n-               --  the back-end has no use for it for a discriminated\n-               --  component.\n-\n-               Set_Freeze_Node (Def_Id, Empty);\n-               Set_Has_Delayed_Freeze (Def_Id, False);\n-               Result := True;\n-            end if;\n-\n-         --  Similar process if the controller of the subtype is not present\n-         --  but the parent has it. This can happen with constrained\n-         --  record components where the subtype is an itype.\n-\n-         elsif Ekind (Def_Id) = E_Record_Subtype\n-           and then Is_Itype (Def_Id)\n-           and then No (Controller_Component (Def_Id))\n-           and then Present (Controller_Component (Etype (Def_Id)))\n-         then\n-            declare\n-               Old_C : constant Entity_Id :=\n-                         Controller_Component (Etype (Def_Id));\n-               New_C : constant Entity_Id := New_Copy (Old_C);\n-\n-            begin\n-               Set_Next_Entity  (New_C, First_Entity (Def_Id));\n-               Set_First_Entity (Def_Id, New_C);\n-\n-               --  The freeze node is only used to introduce the controller,\n-               --  the back-end has no use for it for a discriminated\n-               --   component.\n-\n-               Set_Freeze_Node (Def_Id, Empty);\n-               Set_Has_Delayed_Freeze (Def_Id, False);\n-               Result := True;\n-            end;\n+         elsif Is_Class_Wide_Type (Def_Id) then\n+            Expand_Freeze_Class_Wide_Type (N);\n          end if;\n \n       --  Freeze processing for array types\n@@ -6717,7 +6618,7 @@ package body Exp_Ch3 is\n             elsif Present (Associated_Storage_Pool (Def_Id)) then\n \n                --  Nothing to do the associated storage pool has been attached\n-               --  when analyzing the rep. clause\n+               --  when analyzing the representation clause.\n \n                null;\n             end if;\n@@ -6740,8 +6641,8 @@ package body Exp_Ch3 is\n                null;\n \n             elsif (Needs_Finalization (Desig_Type)\n-                    and then Convention (Desig_Type) /= Convention_Java\n-                    and then Convention (Desig_Type) /= Convention_CIL)\n+                     and then Convention (Desig_Type) /= Convention_Java\n+                     and then Convention (Desig_Type) /= Convention_CIL)\n               or else\n                 (Is_Incomplete_Or_Private_Type (Desig_Type)\n                    and then No (Full_View (Desig_Type))\n@@ -6751,26 +6652,22 @@ package body Exp_Ch3 is\n                   --  afford this unnecessary overhead that would generates a\n                   --  loop in the expansion scheme...\n \n-                  and then not In_Runtime (Def_Id)\n+                   and then not In_Runtime (Def_Id)\n \n                   --  Another exception is if Restrictions (No_Finalization)\n                   --  is active, since then we know nothing is controlled.\n \n-                  and then not Restriction_Active (No_Finalization))\n+                   and then not Restriction_Active (No_Finalization))\n \n                --  If the designated type is not frozen yet, its controlled\n                --  status must be retrieved explicitly.\n \n-              or else (Is_Array_Type (Desig_Type)\n-                and then not Is_Frozen (Desig_Type)\n-                and then Needs_Finalization (Component_Type (Desig_Type)))\n-\n-               --  The designated type has controlled anonymous access\n-               --  discriminants.\n-\n-              or else Has_Controlled_Coextensions (Desig_Type)\n+              or else\n+                (Is_Array_Type (Desig_Type)\n+                   and then not Is_Frozen (Desig_Type)\n+                   and then Needs_Finalization (Component_Type (Desig_Type)))\n             then\n-               Set_Associated_Final_Chain (Def_Id, Add_Final_Chain (Def_Id));\n+               Build_Finalization_Collection (Def_Id);\n             end if;\n          end;\n \n@@ -8069,10 +7966,7 @@ package body Exp_Ch3 is\n             --  components would be incorrect because the wrong entities for\n             --  discriminants could be picked up in the private type case.\n \n-            if Field_Name /= Name_uTag\n-                 and then\n-               Field_Name /= Name_uController\n-            then\n+            if Field_Name /= Name_uTag then\n                Evolve_Or_Else (Cond,\n                  Make_Op_Ne (Loc,\n                    Left_Opnd =>\n@@ -8203,10 +8097,10 @@ package body Exp_Ch3 is\n    is\n       Loc       : constant Source_Ptr := Sloc (Tag_Typ);\n       Res       : constant List_Id    := New_List;\n-      Prim      : Elmt_Id;\n+      Eq_Name   : Name_Id := Name_Op_Eq;\n       Eq_Needed : Boolean;\n       Eq_Spec   : Node_Id;\n-      Eq_Name   : Name_Id := Name_Op_Eq;\n+      Prim      : Elmt_Id;\n \n       function Is_Predefined_Eq_Renaming (Prim : Node_Id) return Boolean;\n       --  Returns true if Prim is a renaming of an unresolved predefined\n@@ -8520,49 +8414,28 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n-      --  Specs for finalization actions that may be required in case a future\n-      --  extension contain a controlled element. We generate those only for\n-      --  root tagged types where they will get dummy bodies or when the type\n-      --  has controlled components and their body must be generated. It is\n-      --  also impossible to provide those for tagged types defined within\n-      --  s-finimp since it would involve circularity problems\n+      --  All tagged types receive their own Deep_Adjust and Deep_Finalize\n+      --  regardless of whether they are controlled or contain controlled\n+      --  components.\n \n-      if In_Finalization_Root (Tag_Typ) then\n-         null;\n+      --  Do not generate the routines if finalization is disabled\n \n-      --  We also skip these if finalization is not available\n-\n-      elsif Restriction_Active (No_Finalization) then\n+      if Restriction_Active (No_Finalization) then\n          null;\n \n-      --  Skip these for CIL Value types, where finalization is not available\n+      --  Finalization is not available for CIL value types\n \n       elsif Is_Value_Type (Tag_Typ) then\n          null;\n \n-      elsif Etype (Tag_Typ) = Tag_Typ\n-        or else Needs_Finalization (Tag_Typ)\n-\n-         --  Ada 2005 (AI-251): We must also generate these subprograms if\n-         --  the immediate ancestor is an interface to ensure the correct\n-         --  initialization of its dispatch table.\n-\n-        or else (not Is_Interface (Tag_Typ)\n-                   and then Is_Interface (Etype (Tag_Typ)))\n-\n-         --  Ada 205 (AI-251): We must also generate these subprograms if\n-         --  the parent of an nonlimited interface is a limited interface\n-\n-        or else (Is_Interface (Tag_Typ)\n-                  and then not Is_Limited_Interface (Tag_Typ)\n-                  and then Is_Limited_Interface (Etype (Tag_Typ)))\n-      then\n+      else\n          if not Is_Limited_Type (Tag_Typ) then\n             Append_To (Res,\n               Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Adjust));\n          end if;\n \n-         Append_To (Res, Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Finalize));\n+         Append_To (Res,\n+           Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Finalize));\n       end if;\n \n       Predef_List := Res;\n@@ -8647,42 +8520,41 @@ package body Exp_Ch3 is\n       Name     : TSS_Name_Type;\n       For_Body : Boolean := False) return Node_Id\n    is\n-      Prof   : List_Id;\n-      Type_B : Entity_Id;\n+      Formals : List_Id;\n \n    begin\n-      if Name = TSS_Deep_Finalize then\n-         Prof := New_List;\n-         Type_B := Standard_Boolean;\n+      --  V : in out Tag_Typ\n \n-      else\n-         Prof := New_List (\n-           Make_Parameter_Specification (Loc,\n-             Defining_Identifier => Make_Defining_Identifier (Loc, Name_L),\n-             In_Present          => True,\n-             Out_Present         => True,\n-             Parameter_Type      =>\n-               New_Reference_To (RTE (RE_Finalizable_Ptr), Loc)));\n-         Type_B := Standard_Short_Short_Integer;\n-      end if;\n+      Formals := New_List (\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc, Name_V),\n+          In_Present  => True,\n+          Out_Present => True,\n+          Parameter_Type =>\n+            New_Reference_To (Tag_Typ, Loc)));\n \n-      Append_To (Prof,\n-           Make_Parameter_Specification (Loc,\n-             Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n-             In_Present          => True,\n-             Out_Present         => True,\n-             Parameter_Type      => New_Reference_To (Tag_Typ, Loc)));\n+      --  F : Boolean := True\n \n-      Append_To (Prof,\n+      if Name = TSS_Deep_Adjust\n+        or else Name = TSS_Deep_Finalize\n+      then\n+         Append_To (Formals,\n            Make_Parameter_Specification (Loc,\n-             Defining_Identifier => Make_Defining_Identifier (Loc, Name_B),\n-             Parameter_Type      => New_Reference_To (Type_B, Loc)));\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_F),\n+             Parameter_Type =>\n+               New_Reference_To (Standard_Boolean, Loc),\n+             Expression =>\n+               New_Reference_To (Standard_True, Loc)));\n+      end if;\n \n-      return Predef_Spec_Or_Body (Loc,\n-        Name     => Make_TSS_Name (Tag_Typ, Name),\n-        Tag_Typ  => Tag_Typ,\n-        Profile  => Prof,\n-        For_Body => For_Body);\n+      return\n+        Predef_Spec_Or_Body (Loc,\n+          Name     => Make_TSS_Name (Tag_Typ, Name),\n+          Tag_Typ  => Tag_Typ,\n+          Profile  => Formals,\n+          For_Body => For_Body);\n \n    exception\n       when RE_Not_Available =>\n@@ -9018,48 +8890,30 @@ package body Exp_Ch3 is\n          Append_To (Res, Decl);\n       end if;\n \n-      --  Generate dummy bodies for finalization actions of types that have\n-      --  no controlled components.\n+      --  Generate empty bodies of routines Deep_Adjust and Deep_Finalize for\n+      --  tagged types which do not contain controlled components.\n \n-      --  Skip this processing if we are in the finalization routine in the\n-      --  runtime itself, otherwise we get hopelessly circularly confused!\n+      --  Do not generate the routines if finalization is disabled\n \n-      if In_Finalization_Root (Tag_Typ) then\n+      if Restriction_Active (No_Finalization) then\n          null;\n \n-      --  Skip this if finalization is not available\n-\n-      elsif Restriction_Active (No_Finalization) then\n-         null;\n-\n-      elsif (Etype (Tag_Typ) = Tag_Typ\n-             or else Is_Controlled (Tag_Typ)\n-\n-               --  Ada 2005 (AI-251): We must also generate these subprograms\n-               --  if the immediate ancestor of Tag_Typ is an interface to\n-               --  ensure the correct initialization of its dispatch table.\n-\n-             or else (not Is_Interface (Tag_Typ)\n-                        and then\n-                      Is_Interface (Etype (Tag_Typ))))\n-        and then not Has_Controlled_Component (Tag_Typ)\n-      then\n+      elsif not Has_Controlled_Component (Tag_Typ) then\n          if not Is_Limited_Type (Tag_Typ) then\n             Decl := Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Adjust, True);\n \n             if Is_Controlled (Tag_Typ) then\n                Set_Handled_Statement_Sequence (Decl,\n                  Make_Handled_Sequence_Of_Statements (Loc,\n-                   Make_Adjust_Call (\n-                     Ref          => Make_Identifier (Loc, Name_V),\n-                     Typ          => Tag_Typ,\n-                     Flist_Ref    => Make_Identifier (Loc, Name_L),\n-                     With_Attach  => Make_Identifier (Loc, Name_B))));\n-\n+                   Statements => New_List (\n+                     Make_Adjust_Call (\n+                       Obj_Ref => Make_Identifier (Loc, Name_V),\n+                       Typ     => Tag_Typ))));\n             else\n                Set_Handled_Statement_Sequence (Decl,\n-                 Make_Handled_Sequence_Of_Statements (Loc, New_List (\n-                   Make_Null_Statement (Loc))));\n+                 Make_Handled_Sequence_Of_Statements (Loc,\n+                   Statements => New_List (\n+                     Make_Null_Statement (Loc))));\n             end if;\n \n             Append_To (Res, Decl);\n@@ -9070,15 +8924,15 @@ package body Exp_Ch3 is\n          if Is_Controlled (Tag_Typ) then\n             Set_Handled_Statement_Sequence (Decl,\n               Make_Handled_Sequence_Of_Statements (Loc,\n-                Make_Final_Call (\n-                  Ref         => Make_Identifier (Loc, Name_V),\n-                  Typ         => Tag_Typ,\n-                  With_Detach => Make_Identifier (Loc, Name_B))));\n-\n+                Statements => New_List (\n+                  Make_Final_Call (\n+                    Obj_Ref => Make_Identifier (Loc, Name_V),\n+                    Typ     => Tag_Typ))));\n          else\n             Set_Handled_Statement_Sequence (Decl,\n-              Make_Handled_Sequence_Of_Statements (Loc, New_List (\n-                Make_Null_Statement (Loc))));\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (\n+                  Make_Null_Statement (Loc))));\n          end if;\n \n          Append_To (Res, Decl);\n@@ -9195,22 +9049,31 @@ package body Exp_Ch3 is\n       --  to be (implicitly) inherited in that case because it can lead to a VM\n       --  exception.\n \n-      return (not Is_Limited_Type (Typ)\n-               or else Is_Interface (Typ)\n-               or else Has_Predefined_Or_Specified_Stream_Attribute)\n-        and then (Operation /= TSS_Stream_Input\n-                   or else not Is_Abstract_Type (Typ)\n-                   or else not Is_Derived_Type (Typ))\n+      --  Do not generate stream routines for type Finalization_Collection\n+      --  because collection may never appear in types and therefore cannot be\n+      --  read or written.\n+\n+      return\n+          (not Is_Limited_Type (Typ)\n+            or else Is_Interface (Typ)\n+            or else Has_Predefined_Or_Specified_Stream_Attribute)\n+        and then\n+          (Operation /= TSS_Stream_Input\n+            or else not Is_Abstract_Type (Typ)\n+            or else not Is_Derived_Type (Typ))\n         and then not Has_Unknown_Discriminants (Typ)\n-        and then not (Is_Interface (Typ)\n-                       and then (Is_Task_Interface (Typ)\n-                                  or else Is_Protected_Interface (Typ)\n-                                  or else Is_Synchronized_Interface (Typ)))\n+        and then not\n+          (Is_Interface (Typ)\n+            and then\n+              (Is_Task_Interface (Typ)\n+                or else Is_Protected_Interface (Typ)\n+                or else Is_Synchronized_Interface (Typ)))\n         and then not Restriction_Active (No_Streams)\n         and then not Restriction_Active (No_Dispatch)\n         and then not No_Run_Time_Mode\n         and then RTE_Available (RE_Tag)\n-        and then RTE_Available (RE_Root_Stream_Type);\n+        and then RTE_Available (RE_Root_Stream_Type)\n+        and then not Is_RTE (Typ, RE_Finalization_Collection);\n    end Stream_Operation_OK;\n \n end Exp_Ch3;"}, {"sha": "54aba222f9ce8c17b1e3894949fa2cf2c24288a8", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -113,6 +113,22 @@ package Exp_Ch3 is\n    --  want Gigi to see the node. This function can't delete the node itself\n    --  since it would confuse any remaining processing of the freeze node.\n \n+   function Get_Simple_Init_Val\n+     (T    : Entity_Id;\n+      N    : Node_Id;\n+      Size : Uint := No_Uint) return Node_Id;\n+   --  For a type which Needs_Simple_Initialization (see above), prepares the\n+   --  tree for an expression representing the required initial value. N is a\n+   --  node whose source location used in constructing this tree which is\n+   --  returned as the result of the call. The Size parameter indicates the\n+   --  target size of the object if it is known (indicated by a value that is\n+   --  not No_Uint and is greater than zero). If Size is not given (Size set to\n+   --  No_Uint, or non-positive), then the Esize of T is used as an estimate of\n+   --  the Size. The object size is needed to prepare a known invalid value for\n+   --  use by Normalize_Scalars. A call to this routine where T is a scalar\n+   --  type is only valid if we are in Normalize_Scalars or Initialize_Scalars\n+   --  mode, or if N is the node for a 'Invalid_Value attribute node.\n+\n    procedure Init_Secondary_Tags\n      (Typ            : Entity_Id;\n       Target         : Node_Id;\n@@ -139,20 +155,4 @@ package Exp_Ch3 is\n    --  set to False, but if Consider_IS is set to True, then the cases above\n    --  mentioning Normalize_Scalars also apply for Initialize_Scalars mode.\n \n-   function Get_Simple_Init_Val\n-     (T    : Entity_Id;\n-      N    : Node_Id;\n-      Size : Uint := No_Uint) return Node_Id;\n-   --  For a type which Needs_Simple_Initialization (see above), prepares the\n-   --  tree for an expression representing the required initial value. N is a\n-   --  node whose source location used in constructing this tree which is\n-   --  returned as the result of the call. The Size parameter indicates the\n-   --  target size of the object if it is known (indicated by a value that is\n-   --  not No_Uint and is greater than zero). If Size is not given (Size set to\n-   --  No_Uint, or non-positive), then the Esize of T is used as an estimate of\n-   --  the Size. The object size is needed to prepare a known invalid value for\n-   --  use by Normalize_Scalars. A call to this routine where T is a scalar\n-   --  type is only valid if we are in Normalize_Scalars or Initialize_Scalars\n-   --  mode, or if N is the node for a 'Invalid_Value attribute node.\n-\n end Exp_Ch3;"}, {"sha": "95b23d8379a2e7936427e3f04055b2204c84a104", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 311, "deletions": 507, "changes": 818, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -44,6 +44,7 @@ with Exp_Util; use Exp_Util;\n with Exp_VFpt; use Exp_VFpt;\n with Freeze;   use Freeze;\n with Inline;   use Inline;\n+with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -56,7 +57,6 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -91,6 +91,13 @@ package body Exp_Ch4 is\n    --  If a boolean array assignment can be done in place, build call to\n    --  corresponding library procedure.\n \n+   procedure Complete_Controlled_Allocation (Temp_Decl : Node_Id);\n+   --  Subsidiary to Expand_N_Allocator and Expand_Allocator_Expression. Formal\n+   --  Temp_Decl is the declaration of a temporary which hold the value of the\n+   --  original allocator. Create a custom Allocate routine for the expression\n+   --  of Temp_Decl. The routine does special processing for anonymous access\n+   --  types.\n+\n    procedure Displace_Allocator_Pointer (N : Node_Id);\n    --  Ada 2005 (AI-251): Subsidiary procedure to Expand_N_Allocator and\n    --  Expand_Allocator_Expression. Allocating class-wide interface objects\n@@ -158,14 +165,6 @@ package body Exp_Ch4 is\n    --  routine is to find the real type by looking up the tree. We also\n    --  determine if the operation must be rounded.\n \n-   function Get_Allocator_Final_List\n-     (N    : Node_Id;\n-      T    : Entity_Id;\n-      PtrT : Entity_Id) return Entity_Id;\n-   --  If the designated type is controlled, build final_list expression for\n-   --  created object. If context is an access parameter, create a local access\n-   --  type to have a usable finalization list.\n-\n    function Has_Inferable_Discriminants (N : Node_Id) return Boolean;\n    --  Ada 2005 (AI-216): A view of an Unchecked_Union object has inferable\n    --  discriminants if it has a constrained nominal type, unless the object\n@@ -375,6 +374,113 @@ package body Exp_Ch4 is\n          return;\n    end Build_Boolean_Array_Proc_Call;\n \n+   ------------------------------------\n+   -- Complete_Controlled_Allocation --\n+   ------------------------------------\n+\n+   procedure Complete_Controlled_Allocation (Temp_Decl : Node_Id) is\n+      pragma Assert (Nkind (Temp_Decl) = N_Object_Declaration);\n+\n+      Ptr_Typ : constant Entity_Id := Etype (Defining_Identifier (Temp_Decl));\n+\n+      function First_Declaration_Of_Current_Unit return Node_Id;\n+      --  Return the current unit's first declaration. If the declaration list\n+      --  is empty, the routine generates a null statement and returns it.\n+\n+      ---------------------------------------\n+      -- First_Declaration_Of_Current_Unit --\n+      ---------------------------------------\n+\n+      function First_Declaration_Of_Current_Unit return Node_Id is\n+         Sem_U : Node_Id := Unit (Cunit (Current_Sem_Unit));\n+         Decl  : Node_Id;\n+         Decls : List_Id;\n+\n+      begin\n+         if Nkind (Sem_U) = N_Package_Declaration then\n+            Sem_U := Specification (Sem_U);\n+            Decls := Visible_Declarations (Sem_U);\n+\n+            if No (Decls) then\n+               Decl  := Make_Null_Statement (Sloc (Sem_U));\n+               Decls := New_List (Decl);\n+               Set_Visible_Declarations (Sem_U, Decls);\n+            else\n+               Decl := First (Decls);\n+            end if;\n+\n+         else\n+            Decls := Declarations (Sem_U);\n+\n+            if No (Decls) then\n+               Decl  := Make_Null_Statement (Sloc (Sem_U));\n+               Decls := New_List (Decl);\n+               Set_Declarations (Sem_U, Decls);\n+            else\n+               Decl := First (Decls);\n+            end if;\n+         end if;\n+\n+         return Decl;\n+      end First_Declaration_Of_Current_Unit;\n+\n+   --  Start of processing for Complete_Controlled_Allocation\n+\n+   begin\n+      --  Do nothing if the access type may never allocate an object\n+\n+      if No_Pool_Assigned (Ptr_Typ) then\n+         return;\n+\n+      --  Access-to-controlled types are not supported on .NET/JVM\n+\n+      elsif VM_Target /= No_VM then\n+         return;\n+      end if;\n+\n+      --  Processing for anonymous access-to-controlled types. These access\n+      --  types receive a special collection which appears on the declarations\n+      --  of the enclosing semantic unit.\n+\n+      if Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n+        and then No (Associated_Collection (Ptr_Typ))\n+        and then\n+          (not Restriction_Active (No_Nested_Finalization)\n+             or else Is_Library_Level_Entity (Ptr_Typ))\n+      then\n+         declare\n+            Pool_Id : constant Entity_Id := RTE (RE_Global_Pool_Object);\n+            Scop    : Node_Id := Cunit_Entity (Current_Sem_Unit);\n+\n+         begin\n+            --  Use the scope of the current semantic unit when analyzing\n+\n+            if Ekind (Scop) = E_Subprogram_Body then\n+               Scop := Corresponding_Spec (Parent (Parent (Parent (Scop))));\n+            end if;\n+\n+            Build_Finalization_Collection\n+              (Typ        => Ptr_Typ,\n+               Ins_Node   => First_Declaration_Of_Current_Unit,\n+               Encl_Scope => Scop);\n+\n+            --  Decorate the anonymous access type and the allocator node\n+\n+            Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n+            Set_Storage_Pool (Expression (Temp_Decl), Pool_Id);\n+         end;\n+      end if;\n+\n+      --  Since the temporary object reuses the original allocator, generate a\n+      --  custom Allocate routine for the temporary.\n+\n+      if Present (Associated_Collection (Ptr_Typ)) then\n+         Build_Allocate_Deallocate_Proc\n+           (N           => Temp_Decl,\n+            Is_Allocate => True);\n+      end if;\n+   end Complete_Controlled_Allocation;\n+\n    --------------------------------\n    -- Displace_Allocator_Pointer --\n    --------------------------------\n@@ -545,68 +651,68 @@ package body Exp_Ch4 is\n             end if;\n \n             Insert_Action (N,\n-               Make_Raise_Program_Error (Loc,\n-                 Condition =>\n-                   Make_Op_Gt (Loc,\n-                     Left_Opnd  =>\n-                       Build_Get_Access_Level (Loc,\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix => Ref_Node,\n-                           Attribute_Name => Name_Tag)),\n-                     Right_Opnd =>\n-                       Make_Integer_Literal (Loc,\n-                         Type_Access_Level (PtrT))),\n-                 Reason => PE_Accessibility_Check_Failed));\n+              Make_Raise_Program_Error (Loc,\n+                Condition =>\n+                  Make_Op_Gt (Loc,\n+                    Left_Opnd =>\n+                      Build_Get_Access_Level (Loc,\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix => Ref_Node,\n+                          Attribute_Name => Name_Tag)),\n+                    Right_Opnd =>\n+                      Make_Integer_Literal (Loc,\n+                        Type_Access_Level (PtrT))),\n+                Reason => PE_Accessibility_Check_Failed));\n          end if;\n       end Apply_Accessibility_Check;\n \n       --  Local variables\n \n-      Indic : constant Node_Id   := Subtype_Mark (Expression (N));\n-      T     : constant Entity_Id := Entity (Indic);\n-      Flist : Node_Id;\n-      Node  : Node_Id;\n-      Temp  : Entity_Id;\n+      Aggr_In_Place : constant Boolean   := Is_Delayed_Aggregate (Exp);\n+      Indic         : constant Node_Id   := Subtype_Mark (Expression (N));\n+      T             : constant Entity_Id := Entity (Indic);\n+      Node          : Node_Id;\n+      Tag_Assign    : Node_Id;\n+      Temp          : Entity_Id;\n+      Temp_Decl     : Node_Id;\n \n       TagT : Entity_Id := Empty;\n       --  Type used as source for tag assignment\n \n       TagR : Node_Id := Empty;\n       --  Target reference for tag assignment\n \n-      Aggr_In_Place : constant Boolean := Is_Delayed_Aggregate (Exp);\n-\n-      Tag_Assign : Node_Id;\n-      Tmp_Node   : Node_Id;\n-\n    --  Start of processing for Expand_Allocator_Expression\n \n    begin\n-      if Is_Tagged_Type (T) or else Needs_Finalization (T) then\n-\n+      if Is_Tagged_Type (T)\n+        or else Needs_Finalization (T)\n+      then\n          if Is_CPP_Constructor_Call (Exp) then\n \n             --  Generate:\n-            --  Pnnn : constant ptr_T := new (T); Init (Pnnn.all,...); Pnnn\n+            --    Pnnn : constant ptr_T := new (T);\n+            --    Init (Pnnn.all,...);\n \n-            --  Allocate the object with no expression\n+            --  Allocate the object without an expression\n \n             Node := Relocate_Node (N);\n             Set_Expression (Node, New_Reference_To (Etype (Exp), Loc));\n \n             --  Avoid its expansion to avoid generating a call to the default\n-            --  C++ constructor\n+            --  C++ constructor.\n \n             Set_Analyzed (Node);\n \n             Temp := Make_Temporary (Loc, 'P', N);\n \n-            Insert_Action (N,\n+            Temp_Decl :=\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Temp,\n                 Constant_Present    => True,\n                 Object_Definition   => New_Reference_To (PtrT, Loc),\n-                Expression          => Node));\n+                Expression          => Node);\n+            Insert_Action (N, Temp_Decl);\n \n             Apply_Accessibility_Check (Temp);\n \n@@ -698,7 +804,6 @@ package body Exp_Ch4 is\n                         Make_Attribute_Reference (Loc,\n                           Prefix         => Exp,\n                           Attribute_Name => Name_Address)))));\n-\n             else\n                Set_Expression\n                  (Expression (N),\n@@ -708,48 +813,46 @@ package body Exp_Ch4 is\n             Analyze_And_Resolve (Expression (N), Entity (Indic));\n          end if;\n \n-         --  Keep separate the management of allocators returning interfaces\n+         --  Processing for allocators returning non-interface types\n \n          if not Is_Interface (Directly_Designated_Type (PtrT)) then\n             if Aggr_In_Place then\n-               Tmp_Node :=\n+               Temp_Decl :=\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Temp,\n                    Object_Definition   => New_Reference_To (PtrT, Loc),\n                    Expression          =>\n                      Make_Allocator (Loc,\n-                       New_Reference_To (Etype (Exp), Loc)));\n+                       Expression =>\n+                         New_Reference_To (Etype (Exp), Loc)));\n \n                --  Copy the Comes_From_Source flag for the allocator we just\n                --  built, since logically this allocator is a replacement of\n                --  the original allocator node. This is for proper handling of\n                --  restriction No_Implicit_Heap_Allocations.\n \n                Set_Comes_From_Source\n-                 (Expression (Tmp_Node), Comes_From_Source (N));\n+                 (Expression (Temp_Decl), Comes_From_Source (N));\n \n-               Set_No_Initialization (Expression (Tmp_Node));\n-               Insert_Action (N, Tmp_Node);\n+               Set_No_Initialization (Expression (Temp_Decl));\n+               Insert_Action (N, Temp_Decl);\n \n-               if Needs_Finalization (T)\n-                 and then Ekind (PtrT) = E_Anonymous_Access_Type\n-               then\n-                  --  Create local finalization list for access parameter\n-\n-                  Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n-               end if;\n-\n-               Convert_Aggr_In_Allocator (N, Tmp_Node, Exp);\n+               Complete_Controlled_Allocation (Temp_Decl);\n+               Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n             else\n                Node := Relocate_Node (N);\n                Set_Analyzed (Node);\n-               Insert_Action (N,\n+\n+               Temp_Decl :=\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Temp,\n                    Constant_Present    => True,\n                    Object_Definition   => New_Reference_To (PtrT, Loc),\n-                   Expression          => Node));\n+                   Expression          => Node);\n+\n+               Insert_Action (N, Temp_Decl);\n+               Complete_Controlled_Allocation (Temp_Decl);\n             end if;\n \n          --  Ada 2005 (AI-251): Handle allocators whose designated type is an\n@@ -775,18 +878,19 @@ package body Exp_Ch4 is\n \n                Insert_Action (N, New_Decl);\n \n-               --  Inherit the final chain to ensure that the expansion of the\n-               --  aggregate is correct in case of controlled types\n+               --  Inherit the allocation-related attributes from the original\n+               --  access type.\n \n-               if Needs_Finalization (Directly_Designated_Type (PtrT)) then\n-                  Set_Associated_Final_Chain (Def_Id,\n-                    Associated_Final_Chain (PtrT));\n-               end if;\n+               Set_Associated_Collection (Def_Id,\n+                 Associated_Collection (PtrT));\n+\n+               Set_Associated_Storage_Pool (Def_Id,\n+                 Associated_Storage_Pool (PtrT));\n \n                --  Declare the object using the previous type declaration\n \n                if Aggr_In_Place then\n-                  Tmp_Node :=\n+                  Temp_Decl :=\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Temp,\n                       Object_Definition   => New_Reference_To (Def_Id, Loc),\n@@ -800,30 +904,27 @@ package body Exp_Ch4 is\n                   --  of restriction No_Implicit_Heap_Allocations.\n \n                   Set_Comes_From_Source\n-                    (Expression (Tmp_Node), Comes_From_Source (N));\n-\n-                  Set_No_Initialization (Expression (Tmp_Node));\n-                  Insert_Action (N, Tmp_Node);\n+                    (Expression (Temp_Decl), Comes_From_Source (N));\n \n-                  if Needs_Finalization (T)\n-                    and then Ekind (PtrT) = E_Anonymous_Access_Type\n-                  then\n-                     --  Create local finalization list for access parameter\n+                  Set_No_Initialization (Expression (Temp_Decl));\n+                  Insert_Action (N, Temp_Decl);\n \n-                     Flist :=\n-                       Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n-                  end if;\n+                  Complete_Controlled_Allocation (Temp_Decl);\n+                  Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n-                  Convert_Aggr_In_Allocator (N, Tmp_Node, Exp);\n                else\n                   Node := Relocate_Node (N);\n                   Set_Analyzed (Node);\n-                  Insert_Action (N,\n+\n+                  Temp_Decl :=\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Temp,\n                       Constant_Present    => True,\n                       Object_Definition   => New_Reference_To (Def_Id, Loc),\n-                      Expression          => Node));\n+                      Expression          => Node);\n+\n+                  Insert_Action (N, Temp_Decl);\n+                  Complete_Controlled_Allocation (Temp_Decl);\n                end if;\n \n                --  Generate an additional object containing the address of the\n@@ -835,15 +936,18 @@ package body Exp_Ch4 is\n \n                New_Decl :=\n                  Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Make_Temporary (Loc, 'P'),\n-                   Object_Definition   => New_Reference_To (PtrT, Loc),\n-                   Expression          => Unchecked_Convert_To (PtrT,\n-                                            New_Reference_To (Temp, Loc)));\n+                   Defining_Identifier =>\n+                     Make_Temporary (Loc, 'P'),\n+                   Object_Definition =>\n+                     New_Reference_To (PtrT, Loc),\n+                   Expression =>\n+                     Unchecked_Convert_To (PtrT,\n+                       New_Reference_To (Temp, Loc)));\n \n                Insert_Action (N, New_Decl);\n \n-               Tmp_Node := New_Decl;\n-               Temp     := Defining_Identifier (New_Decl);\n+               Temp_Decl := New_Decl;\n+               Temp      := Defining_Identifier (New_Decl);\n             end;\n          end if;\n \n@@ -906,77 +1010,43 @@ package body Exp_Ch4 is\n          if Needs_Finalization (DesigT)\n             and then Needs_Finalization (T)\n          then\n-            declare\n-               Attach : Node_Id;\n-               Apool  : constant Entity_Id :=\n-                          Associated_Storage_Pool (PtrT);\n-\n-            begin\n-               --  If it is an allocation on the secondary stack (i.e. a value\n-               --  returned from a function), the object is attached on the\n-               --  caller side as soon as the call is completed (see\n-               --  Expand_Ctrl_Function_Call)\n-\n-               if Is_RTE (Apool, RE_SS_Pool) then\n-                  declare\n-                     F : constant Entity_Id := Make_Temporary (Loc, 'F');\n-                  begin\n-                     Insert_Action (N,\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => F,\n-                         Object_Definition   =>\n-                           New_Reference_To (RTE (RE_Finalizable_Ptr), Loc)));\n-                     Flist := New_Reference_To (F, Loc);\n-                     Attach :=  Make_Integer_Literal (Loc, 1);\n-                  end;\n-\n-               --  Normal case, not a secondary stack allocation\n-\n-               else\n-                  if Needs_Finalization (T)\n-                    and then Ekind (PtrT) = E_Anonymous_Access_Type\n-                  then\n-                     --  Create local finalization list for access parameter\n-\n-                     Flist :=\n-                       Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n-                  else\n-                     Flist := Find_Final_List (PtrT);\n-                  end if;\n-\n-                  Attach :=  Make_Integer_Literal (Loc, 2);\n-               end if;\n-\n-               --  Generate an Adjust call if the object will be moved. In Ada\n-               --  2005, the object may be inherently limited, in which case\n-               --  there is no Adjust procedure, and the object is built in\n-               --  place. In Ada 95, the object can be limited but not\n-               --  inherently limited if this allocator came from a return\n-               --  statement (we're allocating the result on the secondary\n-               --  stack). In that case, the object will be moved, so we _do_\n-               --  want to Adjust.\n-\n-               if not Aggr_In_Place\n-                 and then not Is_Immutably_Limited_Type (T)\n-               then\n-                  Insert_Actions (N,\n-                    Make_Adjust_Call (\n-                      Ref          =>\n+            --  Generate an Adjust call if the object will be moved. In Ada\n+            --  2005, the object may be inherently limited, in which case\n+            --  there is no Adjust procedure, and the object is built in\n+            --  place. In Ada 95, the object can be limited but not\n+            --  inherently limited if this allocator came from a return\n+            --  statement (we're allocating the result on the secondary\n+            --  stack). In that case, the object will be moved, so we _do_\n+            --  want to Adjust.\n+\n+            if not Aggr_In_Place\n+              and then not Is_Immutably_Limited_Type (T)\n+            then\n+               Insert_Action (N,\n+                 Make_Adjust_Call (\n+                   Obj_Ref    =>\n \n                      --  An unchecked conversion is needed in the classwide\n-                     --  case because the designated type can be an ancestor of\n-                     --  the subtype mark of the allocator.\n+                     --  case because the designated type can be an ancestor\n+                     --  of the subtype mark of the allocator.\n \n-                      Unchecked_Convert_To (T,\n-                        Make_Explicit_Dereference (Loc,\n-                          Prefix => New_Reference_To (Temp, Loc))),\n+                     Unchecked_Convert_To (T,\n+                       Make_Explicit_Dereference (Loc,\n+                         Prefix => New_Reference_To (Temp, Loc))),\n+                   Typ => T));\n+            end if;\n \n-                      Typ          => T,\n-                      Flist_Ref    => Flist,\n-                      With_Attach  => Attach,\n-                      Allocator    => True));\n-               end if;\n-            end;\n+            --  Generate:\n+            --    Set_Finalize_Address_Ptr\n+            --      (Collection, <Finalize_Address>'Unrestricted_Access)\n+\n+            if Present (Associated_Collection (PtrT)) then\n+               Insert_Action (N,\n+                 Make_Set_Finalize_Address_Ptr_Call (\n+                   Loc     => Loc,\n+                   Typ     => T,\n+                   Ptr_Typ => PtrT));\n+            end if;\n          end if;\n \n          Rewrite (N, New_Reference_To (Temp, Loc));\n@@ -992,24 +1062,29 @@ package body Exp_Ch4 is\n \n       elsif Aggr_In_Place then\n          Temp := Make_Temporary (Loc, 'P', N);\n-         Tmp_Node :=\n+         Temp_Decl :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Temp,\n              Object_Definition   => New_Reference_To (PtrT, Loc),\n-             Expression          => Make_Allocator (Loc,\n-                 New_Reference_To (Etype (Exp), Loc)));\n+             Expression          =>\n+               Make_Allocator (Loc,\n+                 Expression =>\n+                   New_Reference_To (Etype (Exp), Loc)));\n \n          --  Copy the Comes_From_Source flag for the allocator we just built,\n          --  since logically this allocator is a replacement of the original\n          --  allocator node. This is for proper handling of restriction\n          --  No_Implicit_Heap_Allocations.\n \n          Set_Comes_From_Source\n-           (Expression (Tmp_Node), Comes_From_Source (N));\n+           (Expression (Temp_Decl), Comes_From_Source (N));\n+\n+         Set_No_Initialization (Expression (Temp_Decl));\n+         Insert_Action (N, Temp_Decl);\n+\n+         Complete_Controlled_Allocation (Temp_Decl);\n+         Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n-         Set_No_Initialization (Expression (Tmp_Node));\n-         Insert_Action (N, Tmp_Node);\n-         Convert_Aggr_In_Allocator (N, Tmp_Node, Exp);\n          Rewrite (N, New_Reference_To (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);\n \n@@ -3108,10 +3183,6 @@ package body Exp_Ch4 is\n       Temp  : Entity_Id;\n       Nod   : Node_Id;\n \n-      procedure Complete_Coextension_Finalization;\n-      --  Generate finalization calls for all nested coextensions of N. This\n-      --  routine may allocate list controllers if necessary.\n-\n       procedure Rewrite_Coextension (N : Node_Id);\n       --  Static coextensions have the same lifetime as the entity they\n       --  constrain. Such occurrences can be rewritten as aliased objects\n@@ -3123,227 +3194,49 @@ package body Exp_Ch4 is\n       --  This is done without using the attribute (which malfunctions for\n       --  large sizes ???)\n \n-      ---------------------------------------\n-      -- Complete_Coextension_Finalization --\n-      ---------------------------------------\n-\n-      procedure Complete_Coextension_Finalization is\n-         Coext      : Node_Id;\n-         Coext_Elmt : Elmt_Id;\n-         Flist      : Node_Id;\n-         Ref        : Node_Id;\n-\n-         function Inside_A_Return_Statement (N : Node_Id) return Boolean;\n-         --  Determine whether node N is part of a return statement\n-\n-         function Needs_Initialization_Call (N : Node_Id) return Boolean;\n-         --  Determine whether node N is a subtype indicator allocator which\n-         --  acts a coextension. Such coextensions need initialization.\n-\n-         -------------------------------\n-         -- Inside_A_Return_Statement --\n-         -------------------------------\n-\n-         function Inside_A_Return_Statement (N : Node_Id) return Boolean is\n-            P : Node_Id;\n-\n-         begin\n-            P := Parent (N);\n-            while Present (P) loop\n-               if Nkind_In\n-                   (P, N_Extended_Return_Statement, N_Simple_Return_Statement)\n-               then\n-                  return True;\n-\n-               --  Stop the traversal when we reach a subprogram body\n-\n-               elsif Nkind (P) = N_Subprogram_Body then\n-                  return False;\n-               end if;\n-\n-               P := Parent (P);\n-            end loop;\n-\n-            return False;\n-         end Inside_A_Return_Statement;\n-\n-         -------------------------------\n-         -- Needs_Initialization_Call --\n-         -------------------------------\n-\n-         function Needs_Initialization_Call (N : Node_Id) return Boolean is\n-            Obj_Decl : Node_Id;\n-\n-         begin\n-            if Nkind (N) = N_Explicit_Dereference\n-              and then Nkind (Prefix (N)) = N_Identifier\n-              and then Nkind (Parent (Entity (Prefix (N)))) =\n-                         N_Object_Declaration\n-            then\n-               Obj_Decl := Parent (Entity (Prefix (N)));\n-\n-               return\n-                 Present (Expression (Obj_Decl))\n-                   and then Nkind (Expression (Obj_Decl)) = N_Allocator\n-                   and then Nkind (Expression (Expression (Obj_Decl))) /=\n-                              N_Qualified_Expression;\n-            end if;\n-\n-            return False;\n-         end Needs_Initialization_Call;\n-\n-      --  Start of processing for Complete_Coextension_Finalization\n-\n-      begin\n-         --  When a coextension root is inside a return statement, we need to\n-         --  use the finalization chain of the function's scope. This does not\n-         --  apply for controlled named access types because in those cases we\n-         --  can use the finalization chain of the type itself.\n-\n-         if Inside_A_Return_Statement (N)\n-           and then\n-             (Ekind (PtrT) = E_Anonymous_Access_Type\n-               or else\n-                 (Ekind (PtrT) = E_Access_Type\n-                   and then No (Associated_Final_Chain (PtrT))))\n-         then\n-            declare\n-               Decl    : Node_Id;\n-               Outer_S : Entity_Id;\n-               S       : Entity_Id;\n-\n-            begin\n-               S := Current_Scope;\n-               while Present (S) and then S /= Standard_Standard loop\n-                  if Ekind (S) = E_Function then\n-                     Outer_S := Scope (S);\n-\n-                     --  Retrieve the declaration of the body\n-\n-                     Decl :=\n-                       Parent\n-                         (Parent\n-                            (Corresponding_Body (Parent (Parent (S)))));\n-                     exit;\n-                  end if;\n-\n-                  S := Scope (S);\n-               end loop;\n-\n-               --  Push the scope of the function body since we are inserting\n-               --  the list before the body, but we are currently in the body\n-               --  itself. Override the finalization list of PtrT since the\n-               --  finalization context is now different.\n-\n-               Push_Scope (Outer_S);\n-               Build_Final_List (Decl, PtrT);\n-               Pop_Scope;\n-            end;\n-\n-         --  The root allocator may not be controlled, but it still needs a\n-         --  finalization list for all nested coextensions.\n-\n-         elsif No (Associated_Final_Chain (PtrT)) then\n-            Build_Final_List (N, PtrT);\n-         end if;\n-\n-         Flist :=\n-           Make_Selected_Component (Loc,\n-             Prefix        =>\n-               New_Reference_To (Associated_Final_Chain (PtrT), Loc),\n-             Selector_Name => Make_Identifier (Loc, Name_F));\n-\n-         Coext_Elmt := First_Elmt (Coextensions (N));\n-         while Present (Coext_Elmt) loop\n-            Coext := Node (Coext_Elmt);\n-\n-            --  Generate:\n-            --    typ! (coext.all)\n-\n-            if Nkind (Coext) = N_Identifier then\n-               Ref :=\n-                 Make_Unchecked_Type_Conversion (Loc,\n-                   Subtype_Mark => New_Reference_To (Etype (Coext), Loc),\n-                   Expression   =>\n-                     Make_Explicit_Dereference (Loc,\n-                       Prefix => New_Copy_Tree (Coext)));\n-            else\n-               Ref := New_Copy_Tree (Coext);\n-            end if;\n-\n-            --  No initialization call if not allowed\n-\n-            Check_Restriction (No_Default_Initialization, N);\n-\n-            if not Restriction_Active (No_Default_Initialization) then\n-\n-               --  Generate:\n-               --    initialize (Ref)\n-               --    attach_to_final_list (Ref, Flist, 2)\n-\n-               if Needs_Initialization_Call (Coext) then\n-                  Insert_Actions (N,\n-                    Make_Init_Call (\n-                      Ref         => Ref,\n-                      Typ         => Etype (Coext),\n-                      Flist_Ref   => Flist,\n-                      With_Attach => Make_Integer_Literal (Loc, Uint_2)));\n-\n-               --  Generate:\n-               --    attach_to_final_list (Ref, Flist, 2)\n-\n-               else\n-                  Insert_Action (N,\n-                    Make_Attach_Call (\n-                      Obj_Ref     => Ref,\n-                      Flist_Ref   => New_Copy_Tree (Flist),\n-                      With_Attach => Make_Integer_Literal (Loc, Uint_2)));\n-               end if;\n-            end if;\n-\n-            Next_Elmt (Coext_Elmt);\n-         end loop;\n-      end Complete_Coextension_Finalization;\n-\n       -------------------------\n       -- Rewrite_Coextension --\n       -------------------------\n \n       procedure Rewrite_Coextension (N : Node_Id) is\n-         Temp : constant Node_Id := Make_Temporary (Loc, 'C');\n+         Temp_Id    : constant Node_Id := Make_Temporary (Loc, 'C');\n+         Temp_Decl  : Node_Id;\n+         Insert_Nod : Node_Id;\n \n+      begin\n          --  Generate:\n          --    Cnn : aliased Etyp;\n \n-         Decl : constant Node_Id :=\n-                  Make_Object_Declaration (Loc,\n-                    Defining_Identifier => Temp,\n-                    Aliased_Present     => True,\n-                    Object_Definition   =>\n-                      New_Occurrence_Of (Etyp, Loc));\n-         Nod  : Node_Id;\n+         Temp_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp_Id,\n+             Aliased_Present => True,\n+             Object_Definition =>\n+               New_Occurrence_Of (Etyp, Loc));\n \n-      begin\n          if Nkind (Expression (N)) = N_Qualified_Expression then\n-            Set_Expression (Decl, Expression (Expression (N)));\n+            Set_Expression (Temp_Decl, Expression (Expression (N)));\n          end if;\n \n          --  Find the proper insertion node for the declaration\n \n-         Nod := Parent (N);\n-         while Present (Nod) loop\n-            exit when Nkind (Nod) in N_Statement_Other_Than_Procedure_Call\n-              or else Nkind (Nod) = N_Procedure_Call_Statement\n-              or else Nkind (Nod) in N_Declaration;\n-            Nod := Parent (Nod);\n+         Insert_Nod := Parent (N);\n+         while Present (Insert_Nod) loop\n+            exit when\n+              Nkind (Insert_Nod) in N_Statement_Other_Than_Procedure_Call\n+                or else Nkind (Insert_Nod) = N_Procedure_Call_Statement\n+                or else Nkind (Insert_Nod) in N_Declaration;\n+\n+            Insert_Nod := Parent (Insert_Nod);\n          end loop;\n \n-         Insert_Before (Nod, Decl);\n-         Analyze (Decl);\n+         Insert_Before (Insert_Nod, Temp_Decl);\n+         Analyze (Temp_Decl);\n \n          Rewrite (N,\n            Make_Attribute_Reference (Loc,\n-             Prefix         => New_Occurrence_Of (Temp, Loc),\n+             Prefix =>\n+               New_Occurrence_Of (Temp_Id, Loc),\n              Attribute_Name => Name_Unrestricted_Access));\n \n          Analyze_And_Resolve (N, PtrT);\n@@ -3463,7 +3356,7 @@ package body Exp_Ch4 is\n          --  and replace the allocator by Tnn'Unrestricted_Access. Tnn is\n          --  marked as requiring static allocation.\n \n-         Temp := Make_Temporary (Loc, 'T', Expression (Expression (N)));\n+         Temp  := Make_Temporary (Loc, 'T', Expression (Expression (N)));\n          Desig := Subtype_Mark (Expression (N));\n \n          --  If context is constrained, use constrained subtype directly,\n@@ -3505,14 +3398,6 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  The current allocator creates an object which may contain nested\n-      --  coextensions. Use the current allocator's finalization list to\n-      --  generate finalization call for all nested coextensions.\n-\n-      if Is_Coextension_Root (N) then\n-         Complete_Coextension_Finalization;\n-      end if;\n-\n       --  Check for size too large, we do this because the back end misses\n       --  proper checks here and can generate rubbish allocation calls when\n       --  we are near the limit. We only do this for the 32-bit address case\n@@ -3578,21 +3463,27 @@ package body Exp_Ch4 is\n       --  first argument to Init must be converted to the task record type.\n \n       declare\n-         T            : constant Entity_Id := Entity (Expression (N));\n-         Init         : Entity_Id;\n-         Arg1         : Node_Id;\n-         Args         : List_Id;\n-         Decls        : List_Id;\n-         Decl         : Node_Id;\n-         Discr        : Elmt_Id;\n-         Flist        : Node_Id;\n-         Temp_Decl    : Node_Id;\n-         Temp_Type    : Entity_Id;\n-         Attach_Level : Uint;\n+         T         : constant Entity_Id := Entity (Expression (N));\n+         Args      : List_Id;\n+         Decls     : List_Id;\n+         Decl      : Node_Id;\n+         Discr     : Elmt_Id;\n+         Init      : Entity_Id;\n+         Init_Arg1 : Node_Id;\n+         Temp_Decl : Node_Id;\n+         Temp_Type : Entity_Id;\n \n       begin\n          if No_Initialization (N) then\n-            null;\n+\n+            --  Even though this might be a simple allocation, create a custom\n+            --  Allocate if the context requires it.\n+\n+            if Present (Associated_Collection (PtrT)) then\n+               Build_Allocate_Deallocate_Proc\n+                 (N           => Parent (N),\n+                  Is_Allocate => True);\n+            end if;\n \n          --  Case of no initialization procedure present\n \n@@ -3630,18 +3521,20 @@ package body Exp_Ch4 is\n \n                --  Construct argument list for the initialization routine call\n \n-               Arg1 :=\n+               Init_Arg1 :=\n                  Make_Explicit_Dereference (Loc,\n-                   Prefix => New_Reference_To (Temp, Loc));\n-               Set_Assignment_OK (Arg1);\n+                   Prefix =>\n+                     New_Reference_To (Temp, Loc));\n+\n+               Set_Assignment_OK (Init_Arg1);\n                Temp_Type := PtrT;\n \n                --  The initialization procedure expects a specific type. if the\n                --  context is access to class wide, indicate that the object\n                --  being allocated has the right specific type.\n \n                if Is_Class_Wide_Type (Dtyp) then\n-                  Arg1 := Unchecked_Convert_To (T, Arg1);\n+                  Init_Arg1 := Unchecked_Convert_To (T, Init_Arg1);\n                end if;\n \n                --  If designated type is a concurrent type or if it is private\n@@ -3652,27 +3545,29 @@ package body Exp_Ch4 is\n                --  type.\n \n                if Is_Concurrent_Type (T) then\n-                  Arg1 :=\n-                    Unchecked_Convert_To (Corresponding_Record_Type (T), Arg1);\n+                  Init_Arg1 :=\n+                    Unchecked_Convert_To (\n+                      Corresponding_Record_Type (T), Init_Arg1);\n \n                elsif Is_Private_Type (T)\n                  and then Present (Full_View (T))\n                  and then Is_Concurrent_Type (Full_View (T))\n                then\n-                  Arg1 :=\n+                  Init_Arg1 :=\n                     Unchecked_Convert_To\n-                      (Corresponding_Record_Type (Full_View (T)), Arg1);\n+                      (Corresponding_Record_Type (Full_View (T)), Init_Arg1);\n \n                elsif Etype (First_Formal (Init)) /= Base_Type (T) then\n                   declare\n                      Ftyp : constant Entity_Id := Etype (First_Formal (Init));\n+\n                   begin\n-                     Arg1 := OK_Convert_To (Etype (Ftyp), Arg1);\n-                     Set_Etype (Arg1, Ftyp);\n+                     Init_Arg1 := OK_Convert_To (Etype (Ftyp), Init_Arg1);\n+                     Set_Etype (Init_Arg1, Ftyp);\n                   end;\n                end if;\n \n-               Args := New_List (Arg1);\n+               Args := New_List (Init_Arg1);\n \n                --  For the task case, pass the Master_Id of the access type as\n                --  the value of the _Master parameter, and _Chain as the value\n@@ -3786,7 +3681,7 @@ package body Exp_Ch4 is\n \n                      if not Is_Constrained (Typ)\n                        and then Present (Discriminant_Default_Value\n-                                         (First_Discriminant (Typ)))\n+                                          (First_Discriminant (Typ)))\n                        and then (Ada_Version < Ada_2005\n                                   or else\n                                     not Has_Constrained_Partial_View (Typ))\n@@ -3844,6 +3739,8 @@ package body Exp_Ch4 is\n                Set_Assignment_OK (Temp_Decl);\n                Insert_Action (N, Temp_Decl, Suppress => All_Checks);\n \n+               Complete_Controlled_Allocation (Temp_Decl);\n+\n                --  If the designated type is a task type or contains tasks,\n                --  create block to activate created tasks, and insert\n                --  declaration for Task_Image variable ahead of call.\n@@ -3868,42 +3765,24 @@ package body Exp_Ch4 is\n \n                if Needs_Finalization (T) then\n \n-                  --  Postpone the generation of a finalization call for the\n-                  --  current allocator if it acts as a coextension.\n-\n-                  if Is_Dynamic_Coextension (N) then\n-                     if No (Coextensions (N)) then\n-                        Set_Coextensions (N, New_Elmt_List);\n-                     end if;\n+                  --  Generate:\n+                  --    [Deep_]Initialize (Init_Arg1);\n \n-                     Append_Elmt (New_Copy_Tree (Arg1), Coextensions (N));\n+                  Insert_Action (N,\n+                    Make_Init_Call (\n+                      Obj_Ref => New_Copy_Tree (Init_Arg1),\n+                      Typ     => T));\n \n-                  else\n-                     Flist :=\n-                       Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n-\n-                     --  Anonymous access types created for access parameters\n-                     --  are attached to an explicitly constructed controller,\n-                     --  which ensures that they can be finalized properly,\n-                     --  even if their deallocation might not happen. The list\n-                     --  associated with the controller is doubly-linked. For\n-                     --  other anonymous access types, the object may end up\n-                     --  on the global final list which is singly-linked.\n-                     --  Work needed for access discriminants in Ada 2005 ???\n-\n-                     if Ekind (PtrT) = E_Anonymous_Access_Type then\n-                        Attach_Level := Uint_1;\n-                     else\n-                        Attach_Level := Uint_2;\n-                     end if;\n+                  --  Generate:\n+                  --    Set_Finalize_Address_Ptr\n+                  --      (Pool, <Finalize_Address>'Unrestricted_Access)\n \n-                     Insert_Actions (N,\n-                       Make_Init_Call (\n-                         Ref          => New_Copy_Tree (Arg1),\n-                         Typ          => T,\n-                         Flist_Ref    => Flist,\n-                         With_Attach  => Make_Integer_Literal (Loc,\n-                                           Intval => Attach_Level)));\n+                  if Present (Associated_Collection (PtrT)) then\n+                     Insert_Action (N,\n+                       Make_Set_Finalize_Address_Ptr_Call (\n+                         Loc     => Loc,\n+                         Typ     => T,\n+                         Ptr_Typ => PtrT));\n                   end if;\n                end if;\n \n@@ -4169,7 +4048,8 @@ package body Exp_Ch4 is\n \n          P_Decl :=\n            Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Make_Temporary (Loc, 'A'),\n+             Defining_Identifier =>\n+               Make_Temporary (Loc, 'A'),\n              Type_Definition =>\n                Make_Access_To_Object_Definition (Loc,\n                  All_Present => True,\n@@ -9220,9 +9100,7 @@ package body Exp_Ch4 is\n          then\n             return Suitable_Element (Next_Entity (C));\n \n-         elsif Chars (C) = Name_uController\n-           or else Chars (C) = Name_uTag\n-         then\n+         elsif Chars (C) = Name_uTag then\n             return Suitable_Element (Next_Entity (C));\n \n          elsif Is_Interface (Etype (C)) then\n@@ -9248,6 +9126,7 @@ package body Exp_Ch4 is\n \n       Result := New_Reference_To (Standard_True, Loc);\n       C := Suitable_Element (First_Entity (Typ));\n+\n       while Present (C) loop\n          declare\n             New_Lhs : Node_Id;\n@@ -9527,81 +9406,6 @@ package body Exp_Ch4 is\n       end if;\n    end Fixup_Universal_Fixed_Operation;\n \n-   ------------------------------\n-   -- Get_Allocator_Final_List --\n-   ------------------------------\n-\n-   function Get_Allocator_Final_List\n-     (N    : Node_Id;\n-      T    : Entity_Id;\n-      PtrT : Entity_Id) return Entity_Id\n-   is\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n-      Owner : Entity_Id := PtrT;\n-      --  The entity whose finalization list must be used to attach the\n-      --  allocated object.\n-\n-   begin\n-      if Ekind (PtrT) = E_Anonymous_Access_Type then\n-\n-         --  If the context is an access parameter, we need to create a\n-         --  non-anonymous access type in order to have a usable final list,\n-         --  because there is otherwise no pool to which the allocated object\n-         --  can belong. We create both the type and the finalization chain\n-         --  here, because freezing an internal type does not create such a\n-         --  chain. The Final_Chain that is thus created is shared by the\n-         --  access parameter. The access type is tested against the result\n-         --  type of the function to exclude allocators whose type is an\n-         --  anonymous access result type. We freeze the type at once to\n-         --  ensure that it is properly decorated for the back-end, even\n-         --  if the context and current scope is a loop.\n-\n-         if Nkind (Associated_Node_For_Itype (PtrT))\n-              in N_Subprogram_Specification\n-           and then\n-             PtrT /=\n-               Etype (Defining_Unit_Name (Associated_Node_For_Itype (PtrT)))\n-         then\n-            Owner := Make_Temporary (Loc, 'J');\n-            Insert_Action (N,\n-              Make_Full_Type_Declaration (Loc,\n-                Defining_Identifier => Owner,\n-                Type_Definition =>\n-                   Make_Access_To_Object_Definition (Loc,\n-                     Subtype_Indication =>\n-                       New_Occurrence_Of (T, Loc))));\n-\n-            Freeze_Before (N, Owner);\n-            Build_Final_List (N, Owner);\n-            Set_Associated_Final_Chain (PtrT, Associated_Final_Chain (Owner));\n-\n-         --  Ada 2005 (AI-318-02): If the context is a return object\n-         --  declaration, then the anonymous return subtype is defined to have\n-         --  the same accessibility level as that of the function's result\n-         --  subtype, which means that we want the scope where the function is\n-         --  declared.\n-\n-         elsif Nkind (Associated_Node_For_Itype (PtrT)) = N_Object_Declaration\n-           and then Ekind (Scope (PtrT)) = E_Return_Statement\n-         then\n-            Owner := Scope (Return_Applies_To (Scope (PtrT)));\n-\n-         --  Case of an access discriminant, or (Ada 2005) of an anonymous\n-         --  access component or anonymous access function result: find the\n-         --  final list associated with the scope of the type. (In the\n-         --  anonymous access component kind, a list controller will have\n-         --  been allocated when freezing the record type, and PtrT has an\n-         --  Associated_Final_Chain attribute designating it.)\n-\n-         elsif No (Associated_Final_Chain (PtrT)) then\n-            Owner := Scope (PtrT);\n-         end if;\n-      end if;\n-\n-      return Find_Final_List (Owner);\n-   end Get_Allocator_Final_List;\n-\n    ---------------------------------\n    -- Has_Inferable_Discriminants --\n    ---------------------------------"}, {"sha": "4f175f177f76ea387ac5699259272f3ccea8938e", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 42, "deletions": 450, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -56,8 +56,6 @@ with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n-with Ttypes;   use Ttypes;\n-with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n \n package body Exp_Ch5 is\n@@ -1980,17 +1978,17 @@ package body Exp_Ch5 is\n                      Append_To (L,\n                        Make_Raise_Constraint_Error (Loc,\n                          Condition =>\n-                             Make_Op_Ne (Loc,\n-                               Left_Opnd =>\n-                                 Make_Selected_Component (Loc,\n-                                   Prefix        => Duplicate_Subexpr (Lhs),\n-                                   Selector_Name =>\n-                                     Make_Identifier (Loc, Name_uTag)),\n-                               Right_Opnd =>\n-                                 Make_Selected_Component (Loc,\n-                                   Prefix        => Duplicate_Subexpr (Rhs),\n-                                   Selector_Name =>\n-                                     Make_Identifier (Loc, Name_uTag))),\n+                           Make_Op_Ne (Loc,\n+                             Left_Opnd =>\n+                               Make_Selected_Component (Loc,\n+                                 Prefix        => Duplicate_Subexpr (Lhs),\n+                                 Selector_Name =>\n+                                   Make_Identifier (Loc, Name_uTag)),\n+                             Right_Opnd =>\n+                               Make_Selected_Component (Loc,\n+                                 Prefix        => Duplicate_Subexpr (Rhs),\n+                                 Selector_Name =>\n+                                   Make_Identifier (Loc, Name_uTag))),\n                          Reason => CE_Tag_Check_Failed));\n                   end if;\n \n@@ -3482,33 +3480,25 @@ package body Exp_Ch5 is\n    ------------------------------\n \n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id is\n-      Loc : constant Source_Ptr := Sloc (N);\n+      Asn : constant Node_Id    := Relocate_Node (N);\n       L   : constant Node_Id    := Name (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Res : constant List_Id    := New_List;\n       T   : constant Entity_Id  := Underlying_Type (Etype (L));\n \n+      Comp_Asn : constant Boolean := Is_Fully_Repped_Tagged_Type (T);\n       Ctrl_Act : constant Boolean := Needs_Finalization (T)\n                                        and then not No_Ctrl_Actions (N);\n-\n-      Component_Assign : constant Boolean :=\n-                           Is_Fully_Repped_Tagged_Type (T);\n-\n       Save_Tag : constant Boolean := Is_Tagged_Type (T)\n-                                       and then not Component_Assign\n+                                       and then not Comp_Asn\n                                        and then not No_Ctrl_Actions (N)\n                                        and then Tagged_Type_Expansion;\n       --  Tags are not saved and restored when VM_Target because VM tags are\n       --  represented implicitly in objects.\n \n-      Res      : List_Id;\n-      Tag_Tmp  : Entity_Id;\n-\n-      Prev_Tmp : Entity_Id;\n-      Next_Tmp : Entity_Id;\n-      Ctrl_Ref : Node_Id;\n+      Tag_Tmp : Entity_Id;\n \n    begin\n-      Res := New_List;\n-\n       --  Finalize the target of the assignment when controlled\n \n       --  We have two exceptions here:\n@@ -3539,11 +3529,10 @@ package body Exp_Ch5 is\n          null;\n \n       else\n-         Append_List_To (Res,\n-           Make_Final_Call\n-             (Ref         => Duplicate_Subexpr_No_Checks (L),\n-              Typ         => Etype (L),\n-              With_Detach => New_Reference_To (Standard_False, Loc)));\n+         Append_To (Res,\n+           Make_Final_Call (\n+             Obj_Ref => Duplicate_Subexpr_No_Checks (L),\n+             Typ     => Etype (L)));\n       end if;\n \n       --  Save the Tag in a local variable Tag_Tmp\n@@ -3554,404 +3543,33 @@ package body Exp_Ch5 is\n          Append_To (Res,\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Tag_Tmp,\n-             Object_Definition => New_Reference_To (RTE (RE_Tag), Loc),\n+             Object_Definition =>\n+               New_Reference_To (RTE (RE_Tag), Loc),\n              Expression =>\n                Make_Selected_Component (Loc,\n-                 Prefix        => Duplicate_Subexpr_No_Checks (L),\n-                 Selector_Name => New_Reference_To (First_Tag_Component (T),\n-                                                    Loc))));\n+                 Prefix =>\n+                   Duplicate_Subexpr_No_Checks (L),\n+                 Selector_Name =>\n+                   New_Reference_To (First_Tag_Component (T), Loc))));\n \n       --  Otherwise Tag_Tmp not used\n \n       else\n          Tag_Tmp := Empty;\n       end if;\n \n-      if Ctrl_Act then\n-         if VM_Target /= No_VM then\n-\n-            --  Cannot assign part of the object in a VM context, so instead\n-            --  fallback to the previous mechanism, even though it is not\n-            --  completely correct ???\n+      --  If the tagged type has a full rep clause, expand the assignment into\n+      --  component-wise assignments. Mark the node as unanalyzed in order to\n+      --  generate the proper code and propagate this scenario by setting a\n+      --  flag to avoid infinite recursion.\n \n-            --  Save the Finalization Pointers in local variables Prev_Tmp and\n-            --  Next_Tmp. For objects with Has_Controlled_Component set, these\n-            --  pointers are in the Record_Controller\n-\n-            Ctrl_Ref := Duplicate_Subexpr (L);\n-\n-            if Has_Controlled_Component (T) then\n-               Ctrl_Ref :=\n-                 Make_Selected_Component (Loc,\n-                   Prefix => Ctrl_Ref,\n-                   Selector_Name =>\n-                     New_Reference_To (Controller_Component (T), Loc));\n-            end if;\n-\n-            Prev_Tmp := Make_Temporary (Loc, 'B');\n-\n-            Append_To (Res,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Prev_Tmp,\n-\n-                Object_Definition =>\n-                  New_Reference_To (RTE (RE_Finalizable_Ptr), Loc),\n-\n-                Expression =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      Unchecked_Convert_To (RTE (RE_Finalizable), Ctrl_Ref),\n-                    Selector_Name => Make_Identifier (Loc, Name_Prev))));\n-\n-            Next_Tmp := Make_Temporary (Loc, 'C');\n-\n-            Append_To (Res,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Next_Tmp,\n-\n-                Object_Definition   =>\n-                  New_Reference_To (RTE (RE_Finalizable_Ptr), Loc),\n-\n-                Expression          =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      Unchecked_Convert_To (RTE (RE_Finalizable),\n-                        New_Copy_Tree (Ctrl_Ref)),\n-                    Selector_Name => Make_Identifier (Loc, Name_Next))));\n-\n-            --  Do the Assignment\n-\n-            Append_To (Res, Relocate_Node (N));\n-\n-         else\n-            --  Regular (non VM) processing for controlled types and types with\n-            --  controlled components\n-\n-            --  Variables of such types contain pointers used to chain them in\n-            --  finalization lists, in addition to user data. These pointers\n-            --  are specific to each object of the type, not to the value being\n-            --  assigned.\n-\n-            --  Thus they need to be left intact during the assignment. We\n-            --  achieve this by constructing a Storage_Array subtype, and by\n-            --  overlaying objects of this type on the source and target of the\n-            --  assignment. The assignment is then rewritten to assignments of\n-            --  slices of these arrays, copying the user data, and leaving the\n-            --  pointers untouched.\n-\n-            Controlled_Actions : declare\n-               Prev_Ref : Node_Id;\n-               --  A reference to the Prev component of the record controller\n-\n-               First_After_Root : Node_Id := Empty;\n-               --  Index of first byte to be copied (used to skip\n-               --  Root_Controlled in controlled objects).\n-\n-               Last_Before_Hole : Node_Id := Empty;\n-               --  Index of last byte to be copied before outermost record\n-               --  controller data.\n-\n-               Hole_Length : Node_Id := Empty;\n-               --  Length of record controller data (Prev and Next pointers)\n-\n-               First_After_Hole : Node_Id := Empty;\n-               --  Index of first byte to be copied after outermost record\n-               --  controller data.\n-\n-               Expr, Source_Size     : Node_Id;\n-               Source_Actual_Subtype : Entity_Id;\n-               --  Used for computation of the size of the data to be copied\n-\n-               Range_Type  : Entity_Id;\n-               Opaque_Type : Entity_Id;\n-\n-               function Build_Slice\n-                 (Rec : Entity_Id;\n-                  Lo  : Node_Id;\n-                  Hi  : Node_Id) return Node_Id;\n-               --  Build and return a slice of an array of type S overlaid on\n-               --  object Rec, with bounds specified by Lo and Hi. If either\n-               --  bound is empty, a default of S'First (respectively S'Last)\n-               --  is used.\n-\n-               -----------------\n-               -- Build_Slice --\n-               -----------------\n-\n-               function Build_Slice\n-                 (Rec : Node_Id;\n-                  Lo  : Node_Id;\n-                  Hi  : Node_Id) return Node_Id\n-               is\n-                  Lo_Bound : Node_Id;\n-                  Hi_Bound : Node_Id;\n-\n-                  Opaque : constant Node_Id :=\n-                             Unchecked_Convert_To (Opaque_Type,\n-                               Make_Attribute_Reference (Loc,\n-                                 Prefix         => Rec,\n-                                 Attribute_Name => Name_Address));\n-                  --  Access value designating an opaque storage array of type\n-                  --  S overlaid on record Rec.\n-\n-               begin\n-                  --  Compute slice bounds using S'First (1) and S'Last as\n-                  --  default values when not specified by the caller.\n-\n-                  if No (Lo) then\n-                     Lo_Bound := Make_Integer_Literal (Loc, 1);\n-                  else\n-                     Lo_Bound := Lo;\n-                  end if;\n-\n-                  if No (Hi) then\n-                     Hi_Bound := Make_Attribute_Reference (Loc,\n-                       Prefix => New_Occurrence_Of (Range_Type, Loc),\n-                       Attribute_Name => Name_Last);\n-                  else\n-                     Hi_Bound := Hi;\n-                  end if;\n-\n-                  return Make_Slice (Loc,\n-                    Prefix =>\n-                      Opaque,\n-                    Discrete_Range => Make_Range (Loc,\n-                      Lo_Bound, Hi_Bound));\n-               end Build_Slice;\n-\n-            --  Start of processing for Controlled_Actions\n-\n-            begin\n-               --  Create a constrained subtype of Storage_Array whose size\n-               --  corresponds to the value being assigned.\n-\n-               --  subtype G is Storage_Offset range\n-               --    1 .. (Expr'Size + Storage_Unit - 1) / Storage_Unit\n-\n-               Expr := Duplicate_Subexpr_No_Checks (Expression (N));\n-\n-               if Nkind (Expr) = N_Qualified_Expression then\n-                  Expr := Expression (Expr);\n-               end if;\n-\n-               Source_Actual_Subtype := Etype (Expr);\n-\n-               if Has_Discriminants (Source_Actual_Subtype)\n-                 and then not Is_Constrained (Source_Actual_Subtype)\n-               then\n-                  Append_To (Res,\n-                    Build_Actual_Subtype (Source_Actual_Subtype, Expr));\n-                  Source_Actual_Subtype := Defining_Identifier (Last (Res));\n-               end if;\n-\n-               Source_Size :=\n-                 Make_Op_Add (Loc,\n-                   Left_Opnd =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix =>\n-                         New_Occurrence_Of (Source_Actual_Subtype, Loc),\n-                     Attribute_Name => Name_Size),\n-                   Right_Opnd =>\n-                     Make_Integer_Literal (Loc,\n-                       Intval => System_Storage_Unit - 1));\n-\n-               Source_Size :=\n-                 Make_Op_Divide (Loc,\n-                   Left_Opnd => Source_Size,\n-                   Right_Opnd =>\n-                     Make_Integer_Literal (Loc,\n-                       Intval => System_Storage_Unit));\n-\n-               Range_Type := Make_Temporary (Loc, 'G');\n-\n-               Append_To (Res,\n-                 Make_Subtype_Declaration (Loc,\n-                   Defining_Identifier => Range_Type,\n-                   Subtype_Indication =>\n-                     Make_Subtype_Indication (Loc,\n-                       Subtype_Mark =>\n-                         New_Reference_To (RTE (RE_Storage_Offset), Loc),\n-                       Constraint   => Make_Range_Constraint (Loc,\n-                         Range_Expression =>\n-                           Make_Range (Loc,\n-                             Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                             High_Bound => Source_Size)))));\n-\n-               --  subtype S is Storage_Array (G)\n-\n-               Append_To (Res,\n-                 Make_Subtype_Declaration (Loc,\n-                   Defining_Identifier => Make_Temporary (Loc, 'S'),\n-                   Subtype_Indication  =>\n-                     Make_Subtype_Indication (Loc,\n-                       Subtype_Mark =>\n-                         New_Reference_To (RTE (RE_Storage_Array), Loc),\n-                       Constraint =>\n-                         Make_Index_Or_Discriminant_Constraint (Loc,\n-                           Constraints =>\n-                             New_List (New_Reference_To (Range_Type, Loc))))));\n-\n-               --  type A is access S\n-\n-               Opaque_Type := Make_Temporary (Loc, 'A');\n-\n-               Append_To (Res,\n-                 Make_Full_Type_Declaration (Loc,\n-                   Defining_Identifier => Opaque_Type,\n-                   Type_Definition     =>\n-                     Make_Access_To_Object_Definition (Loc,\n-                       Subtype_Indication =>\n-                         New_Occurrence_Of (\n-                           Defining_Identifier (Last (Res)), Loc))));\n-\n-               --  Generate appropriate slice assignments\n-\n-               First_After_Root := Make_Integer_Literal (Loc, 1);\n-\n-               --  For controlled object, skip Root_Controlled part\n-\n-               if Is_Controlled (T) then\n-                  First_After_Root :=\n-                    Make_Op_Add (Loc,\n-                      First_After_Root,\n-                      Make_Op_Divide (Loc,\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix =>\n-                            New_Occurrence_Of (RTE (RE_Root_Controlled), Loc),\n-                          Attribute_Name => Name_Size),\n-                        Make_Integer_Literal (Loc, System_Storage_Unit)));\n-               end if;\n-\n-               --  For the case of a record with controlled components, skip\n-               --  record controller Prev/Next components. These components\n-               --  constitute a 'hole' in the middle of the data to be copied.\n-\n-               if Has_Controlled_Component (T) then\n-                  Prev_Ref :=\n-                    Make_Selected_Component (Loc,\n-                      Prefix        =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix => Duplicate_Subexpr_No_Checks (L),\n-                          Selector_Name =>\n-                            New_Reference_To (Controller_Component (T), Loc)),\n-                      Selector_Name =>  Make_Identifier (Loc, Name_Prev));\n-\n-                  --  Last index before hole: determined by position of the\n-                  --  _Controller.Prev component.\n-\n-                  Last_Before_Hole := Make_Temporary (Loc, 'L');\n-\n-                  Append_To (Res,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Last_Before_Hole,\n-                      Object_Definition   => New_Occurrence_Of (\n-                        RTE (RE_Storage_Offset), Loc),\n-                      Constant_Present    => True,\n-                      Expression          =>\n-                        Make_Op_Add (Loc,\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix => Prev_Ref,\n-                            Attribute_Name => Name_Position),\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix => New_Copy_Tree (Prefix (Prev_Ref)),\n-                            Attribute_Name => Name_Position))));\n-\n-                  --  Hole length: size of the Prev and Next components\n-\n-                  Hole_Length :=\n-                    Make_Op_Multiply (Loc,\n-                      Left_Opnd  => Make_Integer_Literal (Loc, Uint_2),\n-                      Right_Opnd =>\n-                        Make_Op_Divide (Loc,\n-                          Left_Opnd =>\n-                            Make_Attribute_Reference (Loc,\n-                              Prefix         => New_Copy_Tree (Prev_Ref),\n-                              Attribute_Name => Name_Size),\n-                          Right_Opnd =>\n-                            Make_Integer_Literal (Loc,\n-                              Intval => System_Storage_Unit)));\n-\n-                  --  First index after hole\n-\n-                  First_After_Hole := Make_Temporary (Loc, 'F');\n-\n-                  Append_To (Res,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => First_After_Hole,\n-                      Object_Definition   => New_Occurrence_Of (\n-                        RTE (RE_Storage_Offset), Loc),\n-                      Constant_Present    => True,\n-                      Expression          =>\n-                        Make_Op_Add (Loc,\n-                          Left_Opnd  =>\n-                            Make_Op_Add (Loc,\n-                              Left_Opnd  =>\n-                                New_Occurrence_Of (Last_Before_Hole, Loc),\n-                              Right_Opnd => Hole_Length),\n-                          Right_Opnd => Make_Integer_Literal (Loc, 1))));\n-\n-                  Last_Before_Hole :=\n-                    New_Occurrence_Of (Last_Before_Hole, Loc);\n-                  First_After_Hole :=\n-                    New_Occurrence_Of (First_After_Hole, Loc);\n-               end if;\n-\n-               --  Assign the first slice (possibly skipping Root_Controlled,\n-               --  up to the beginning of the record controller if present,\n-               --  up to the end of the object if not).\n-\n-               Append_To (Res, Make_Assignment_Statement (Loc,\n-                 Name       => Build_Slice (\n-                   Rec => Duplicate_Subexpr_No_Checks (L),\n-                   Lo  => First_After_Root,\n-                   Hi  => Last_Before_Hole),\n-\n-                 Expression => Build_Slice (\n-                   Rec => Expression (N),\n-                   Lo  => First_After_Root,\n-                   Hi  => New_Copy_Tree (Last_Before_Hole))));\n-\n-               if Present (First_After_Hole) then\n-\n-                  --  If a record controller is present, copy the second slice,\n-                  --  from right after the _Controller.Next component up to the\n-                  --  end of the object.\n-\n-                  Append_To (Res, Make_Assignment_Statement (Loc,\n-                    Name       => Build_Slice (\n-                      Rec => Duplicate_Subexpr_No_Checks (L),\n-                      Lo  => First_After_Hole,\n-                      Hi  => Empty),\n-                    Expression => Build_Slice (\n-                      Rec => Duplicate_Subexpr_No_Checks (Expression (N)),\n-                      Lo  => New_Copy_Tree (First_After_Hole),\n-                      Hi  => Empty)));\n-               end if;\n-            end Controlled_Actions;\n-         end if;\n-\n-      --  Not controlled case\n-\n-      else\n-         declare\n-            Asn : constant Node_Id := Relocate_Node (N);\n-\n-         begin\n-            --  If this is the case of a tagged type with a full rep clause,\n-            --  we must expand it into component assignments, so we mark the\n-            --  node as unanalyzed, to get it reanalyzed, but flag it has\n-            --  requiring component-wise assignment so we don't get infinite\n-            --  recursion.\n-\n-            if Component_Assign then\n-               Set_Analyzed (Asn, False);\n-               Set_Componentwise_Assignment (Asn, True);\n-            end if;\n-\n-            Append_To (Res, Asn);\n-         end;\n+      if Comp_Asn then\n+         Set_Analyzed (Asn, False);\n+         Set_Componentwise_Assignment (Asn, True);\n       end if;\n \n+      Append_To (Res, Asn);\n+\n       --  Restore the tag\n \n       if Save_Tag then\n@@ -3965,40 +3583,14 @@ package body Exp_Ch5 is\n              Expression => New_Reference_To (Tag_Tmp, Loc)));\n       end if;\n \n-      if Ctrl_Act then\n-         if VM_Target /= No_VM then\n-            --  Restore the finalization pointers\n+      --  Adjust the target after the assignment when controlled (not in the\n+      --  init proc since it is an initialization more than an assignment).\n \n-            Append_To (Res,\n-              Make_Assignment_Statement (Loc,\n-                Name =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix        =>\n-                      Unchecked_Convert_To (RTE (RE_Finalizable),\n-                        New_Copy_Tree (Ctrl_Ref)),\n-                    Selector_Name => Make_Identifier (Loc, Name_Prev)),\n-                Expression => New_Reference_To (Prev_Tmp, Loc)));\n-\n-            Append_To (Res,\n-              Make_Assignment_Statement (Loc,\n-                Name =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix        =>\n-                      Unchecked_Convert_To (RTE (RE_Finalizable),\n-                        New_Copy_Tree (Ctrl_Ref)),\n-                    Selector_Name => Make_Identifier (Loc, Name_Next)),\n-                Expression => New_Reference_To (Next_Tmp, Loc)));\n-         end if;\n-\n-         --  Adjust the target after the assignment when controlled (not in the\n-         --  init proc since it is an initialization more than an assignment).\n-\n-         Append_List_To (Res,\n+      if Ctrl_Act then\n+         Append_To (Res,\n            Make_Adjust_Call (\n-             Ref         => Duplicate_Subexpr_Move_Checks (L),\n-             Typ         => Etype (L),\n-             Flist_Ref   => New_Reference_To (RTE (RE_Global_Final_List), Loc),\n-             With_Attach => Make_Integer_Literal (Loc, 0)));\n+             Obj_Ref => Duplicate_Subexpr_Move_Checks (L),\n+             Typ     => Etype (L)));\n       end if;\n \n       return Res;"}, {"sha": "87403a5feeb35f24101c153e09f188b2ab0a3a26", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 662, "deletions": 434, "changes": 1096, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -110,19 +110,14 @@ package body Exp_Ch6 is\n    --  Adds Extra_Actual as a named parameter association for the formal\n    --  Extra_Formal in Subprogram_Call.\n \n-   procedure Add_Final_List_Actual_To_Build_In_Place_Call\n-     (Function_Call : Node_Id;\n-      Function_Id   : Entity_Id;\n-      Acc_Type      : Entity_Id;\n-      Sel_Comp      : Node_Id := Empty);\n-   --  Ada 2005 (AI-318-02): For a build-in-place call, if the result type has\n-   --  controlled parts, add an actual parameter that is a pointer to\n-   --  appropriate finalization list. The finalization list is that of the\n-   --  current scope, except for \"new Acc'(F(...))\" in which case it's the\n-   --  finalization list of the access type returned by the allocator. Acc_Type\n-   --  is that type in the allocator case; Empty otherwise. If Sel_Comp is\n-   --  not Empty, then it denotes a selected component and the finalization\n-   --  list is obtained from the _controller list of the prefix object.\n+   procedure Add_Collection_Actual_To_Build_In_Place_Call\n+     (Func_Call : Node_Id;\n+      Func_Id   : Entity_Id;\n+      Ptr_Typ   : Entity_Id := Empty);\n+   --  Ada 2005 (AI-318-02): If the result type of a build-in-place call needs\n+   --  finalization actions, add an actual parameter which is a pointer to the\n+   --  finalization collection of the caller. If Ptr_Typ is left Empty, this\n+   --  will result in an automatic \"null\" value for the actual.\n \n    procedure Add_Task_Actuals_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n@@ -191,6 +186,11 @@ package body Exp_Ch6 is\n    --  For non-scalar objects that are possibly unaligned, add call by copy\n    --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n \n+   procedure Expand_Ctrl_Function_Call (N : Node_Id);\n+   --  N is a function call which returns a controlled object. Transform the\n+   --  call into a temporary which retrieves the returned object from the\n+   --  secondary stack using 'reference.\n+\n    procedure Expand_Inlined_Call\n     (N         : Node_Id;\n      Subp      : Entity_Id;\n@@ -340,6 +340,91 @@ package body Exp_Ch6 is\n         (Function_Call, Alloc_Form_Formal, Alloc_Form_Actual);\n    end Add_Alloc_Form_Actual_To_Build_In_Place_Call;\n \n+   --------------------------------------------------\n+   -- Add_Collection_Actual_To_Build_In_Place_Call --\n+   --------------------------------------------------\n+\n+   procedure Add_Collection_Actual_To_Build_In_Place_Call\n+     (Func_Call : Node_Id;\n+      Func_Id   : Entity_Id;\n+      Ptr_Typ   : Entity_Id := Empty)\n+   is\n+   begin\n+      if not Needs_BIP_Collection (Func_Id) then\n+         return;\n+      end if;\n+\n+      declare\n+         Formal : constant Entity_Id :=\n+                    Build_In_Place_Formal (Func_Id, BIP_Collection);\n+         Loc    : constant Source_Ptr := Sloc (Func_Call);\n+\n+         Actual    : Node_Id;\n+         Desig_Typ : Entity_Id;\n+\n+      begin\n+         --  Case where the context does not require an actual collection\n+\n+         if No (Ptr_Typ) then\n+            Actual := Make_Null (Loc);\n+\n+         else\n+            Desig_Typ := Directly_Designated_Type (Ptr_Typ);\n+\n+            --  Check for a library-level access type whose designated type has\n+            --  supressed finalization. Such an access types lack a collection.\n+            --  Pass a null actual to the callee in order to signal a missing\n+            --  collection.\n+\n+            if Is_Library_Level_Entity (Ptr_Typ)\n+              and then Finalize_Storage_Only (Desig_Typ)\n+            then\n+               Actual := Make_Null (Loc);\n+\n+            --  Types in need of finalization actions\n+\n+            elsif Needs_Finalization (Desig_Typ) then\n+\n+               --  The general mechanism of creating finalization collections\n+               --  for anonymous access types is disabled by default, otherwise\n+               --  collections will pop all over the place. Such types use\n+               --  context-specific collections.\n+\n+               if Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n+                 and then No (Associated_Collection (Ptr_Typ))\n+               then\n+                  Build_Finalization_Collection\n+                    (Typ        => Ptr_Typ,\n+                     Ins_Node   => Associated_Node_For_Itype (Ptr_Typ),\n+                     Encl_Scope => Scope (Ptr_Typ));\n+               end if;\n+\n+               --  Access-to-controlled types should always have a collection\n+\n+               pragma Assert (Present (Associated_Collection (Ptr_Typ)));\n+\n+               Actual :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix =>\n+                     New_Reference_To (Associated_Collection (Ptr_Typ), Loc),\n+                   Attribute_Name => Name_Unrestricted_Access);\n+\n+            --  Tagged types\n+\n+            else\n+               Actual := Make_Null (Loc);\n+            end if;\n+         end if;\n+\n+         Analyze_And_Resolve (Actual, Etype (Formal));\n+\n+         --  Build the parameter association for the new actual and add it to\n+         --  the end of the function's actuals.\n+\n+         Add_Extra_Actual_To_Call (Func_Call, Formal, Actual);\n+      end;\n+   end Add_Collection_Actual_To_Build_In_Place_Call;\n+\n    ------------------------------\n    -- Add_Extra_Actual_To_Call --\n    ------------------------------\n@@ -393,79 +478,6 @@ package body Exp_Ch6 is\n       end if;\n    end Add_Extra_Actual_To_Call;\n \n-   --------------------------------------------------\n-   -- Add_Final_List_Actual_To_Build_In_Place_Call --\n-   --------------------------------------------------\n-\n-   procedure Add_Final_List_Actual_To_Build_In_Place_Call\n-     (Function_Call : Node_Id;\n-      Function_Id   : Entity_Id;\n-      Acc_Type      : Entity_Id;\n-      Sel_Comp      : Node_Id := Empty)\n-   is\n-      Loc               : constant Source_Ptr := Sloc (Function_Call);\n-      Final_List        : Node_Id;\n-      Final_List_Actual : Node_Id;\n-      Final_List_Formal : Node_Id;\n-      Is_Ctrl_Result    : constant Boolean :=\n-                            Needs_Finalization\n-                              (Underlying_Type (Etype (Function_Id)));\n-\n-   begin\n-      --  No such extra parameter is needed if there are no controlled parts.\n-      --  The test for Needs_Finalization accounts for class-wide results\n-      --  (which potentially have controlled parts, even if the root type\n-      --  doesn't), and the test for a tagged result type is needed because\n-      --  calls to such a function can in general occur in dispatching\n-      --  contexts, which must be treated the same as a call to class-wide\n-      --  functions. Both of these situations require that a finalization list\n-      --  be passed.\n-\n-      if not Needs_BIP_Final_List (Function_Id) then\n-         return;\n-      end if;\n-\n-      --  Locate implicit finalization list parameter in the called function\n-\n-      Final_List_Formal := Build_In_Place_Formal (Function_Id, BIP_Final_List);\n-\n-      --  Create the actual which is a pointer to the appropriate finalization\n-      --  list. Acc_Type is present if and only if this call is the\n-      --  initialization of an allocator. Use the Current_Scope or the\n-      --  Acc_Type as appropriate.\n-\n-      if Present (Acc_Type)\n-        and then (Ekind (Acc_Type) = E_Anonymous_Access_Type\n-                   or else\n-                     Present (Associated_Final_Chain (Base_Type (Acc_Type))))\n-      then\n-         Final_List := Find_Final_List (Acc_Type);\n-\n-      --  If Sel_Comp is present and the function result is controlled, then\n-      --  the finalization list will be obtained from the _controller list of\n-      --  the selected component's prefix object.\n-\n-      elsif Present (Sel_Comp) and then Is_Ctrl_Result then\n-         Final_List := Find_Final_List (Current_Scope, Sel_Comp);\n-\n-      else\n-         Final_List := Find_Final_List (Current_Scope);\n-      end if;\n-\n-      Final_List_Actual :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix         => Final_List,\n-          Attribute_Name => Name_Unrestricted_Access);\n-\n-      Analyze_And_Resolve (Final_List_Actual, Etype (Final_List_Formal));\n-\n-      --  Build the parameter association for the new actual and add it to the\n-      --  end of the function's actuals.\n-\n-      Add_Extra_Actual_To_Call\n-        (Function_Call, Final_List_Formal, Final_List_Actual);\n-   end Add_Final_List_Actual_To_Build_In_Place_Call;\n-\n    ---------------------------------------------\n    -- Add_Task_Actuals_To_Build_In_Place_Call --\n    ---------------------------------------------\n@@ -549,8 +561,8 @@ package body Exp_Ch6 is\n       case Kind is\n          when BIP_Alloc_Form       =>\n             return \"BIPalloc\";\n-         when BIP_Final_List       =>\n-            return \"BIPfinallist\";\n+         when BIP_Collection       =>\n+            return \"BIPcollection\";\n          when BIP_Master           =>\n             return \"BIPmaster\";\n          when BIP_Activation_Chain =>\n@@ -1777,6 +1789,10 @@ package body Exp_Ch6 is\n       --  convoluted tree traversal before setting the proper subprogram to be\n       --  called.\n \n+      function Is_Direct_Deep_Call (Subp : Entity_Id) return Boolean;\n+      --  Determine whether Subp denotes a non-dispatching call to a Deep\n+      --  routine.\n+\n       function New_Value (From : Node_Id) return Node_Id;\n       --  From is the original Expression. New_Value is equivalent to a call\n       --  to Duplicate_Subexpr with an explicit dereference when From is an\n@@ -1945,6 +1961,42 @@ package body Exp_Ch6 is\n          raise Program_Error;\n       end Inherited_From_Formal;\n \n+      -------------------------\n+      -- Is_Direct_Deep_Call --\n+      -------------------------\n+\n+      function Is_Direct_Deep_Call (Subp : Entity_Id) return Boolean is\n+      begin\n+         if Is_TSS (Subp, TSS_Deep_Adjust)\n+           or else Is_TSS (Subp, TSS_Deep_Finalize)\n+           or else Is_TSS (Subp, TSS_Deep_Initialize)\n+         then\n+            declare\n+               Actual : Node_Id;\n+               Formal : Node_Id;\n+\n+            begin\n+               Actual := First (Parameter_Associations (N));\n+               Formal := First_Formal (Subp);\n+               while Present (Actual)\n+                 and then Present (Formal)\n+               loop\n+                  if Nkind (Actual) = N_Identifier\n+                    and then Is_Controlling_Actual (Actual)\n+                    and then Etype (Actual) = Etype (Formal)\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next (Actual);\n+                  Next_Formal (Formal);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Is_Direct_Deep_Call;\n+\n       ---------------\n       -- New_Value --\n       ---------------\n@@ -2795,6 +2847,7 @@ package body Exp_Ch6 is\n       if Nkind (Call_Node) /= N_Entry_Call_Statement\n         and then No (Controlling_Argument (Call_Node))\n         and then Present (Parent_Subp)\n+        and then not Is_Direct_Deep_Call (Subp)\n       then\n          if Present (Inherited_From_Formal (Subp)) then\n             Parent_Subp := Inherited_From_Formal (Subp);\n@@ -3229,12 +3282,12 @@ package body Exp_Ch6 is\n          Expand_Protected_Subprogram_Call (Call_Node, Subp, Scop);\n       end if;\n \n-      --  Functions returning controlled objects need special attention:\n-      --  if the return type is limited, the context is an initialization\n-      --  and different processing applies. If the call is to a protected\n-      --  function, the expansion above will call Expand_Call recursively.\n-      --  To prevent a double attachment, check that the current call is\n-      --  not a rewriting of a protected function call.\n+      --  Functions returning controlled objects need special attention. If\n+      --  the return type is limited, then the context is initialization and\n+      --  different processing applies. If the call is to a protected function,\n+      --  the expansion above will call Expand_Call recursively. Otherwise the\n+      --  function call is transformed into a temporary which obtains the\n+      --  result from the secondary stack.\n \n       if Needs_Finalization (Etype (Subp)) then\n          if not Is_Immutably_Limited_Type (Etype (Subp))\n@@ -3407,6 +3460,33 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Call;\n \n+   -------------------------------\n+   -- Expand_Ctrl_Function_Call --\n+   -------------------------------\n+\n+   procedure Expand_Ctrl_Function_Call (N : Node_Id) is\n+   begin\n+      --  Optimization, if the returned value (which is on the sec-stack) is\n+      --  returned again, no need to copy/readjust/finalize, we can just pass\n+      --  the value thru (see Expand_N_Simple_Return_Statement), and thus no\n+      --  attachment is needed\n+\n+      if Nkind (Parent (N)) = N_Simple_Return_Statement then\n+         return;\n+      end if;\n+\n+      --  Resolution is now finished, make sure we don't start analysis again\n+      --  because of the duplication.\n+\n+      Set_Analyzed (N);\n+\n+      --  A function which returns a controlled object uses the secondary\n+      --  stack. Rewrite the call into a temporary which obtains the result of\n+      --  the function using 'reference.\n+\n+      Remove_Side_Effects (N);\n+   end Expand_Ctrl_Function_Call;\n+\n    --------------------------\n    -- Expand_Inlined_Call --\n    --------------------------\n@@ -4245,20 +4325,53 @@ package body Exp_Ch6 is\n    procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n \n-      Return_Object_Entity : constant Entity_Id :=\n-                               First_Entity (Return_Statement_Entity (N));\n-      Return_Object_Decl   : constant Node_Id :=\n-                               Parent (Return_Object_Entity);\n-      Parent_Function      : constant Entity_Id :=\n-                               Return_Applies_To (Return_Statement_Entity (N));\n-      Is_Build_In_Place    : constant Boolean :=\n-                               Is_Build_In_Place_Function (Parent_Function);\n-\n-      Return_Stm      : Node_Id;\n-      Statements      : List_Id;\n-      Handled_Stm_Seq : Node_Id;\n-      Result          : Node_Id;\n-      Exp             : Node_Id;\n+      Par_Func     : constant Entity_Id :=\n+                       Return_Applies_To (Return_Statement_Entity (N));\n+      Ret_Obj_Id   : constant Entity_Id :=\n+                       First_Entity (Return_Statement_Entity (N));\n+      Ret_Obj_Decl : constant Node_Id := Parent (Ret_Obj_Id);\n+\n+      Is_Build_In_Place : constant Boolean :=\n+                            Is_Build_In_Place_Function (Par_Func);\n+\n+      Exp         : Node_Id;\n+      HSS         : Node_Id;\n+      Result      : Node_Id;\n+      Return_Stmt : Node_Id;\n+      Stmts       : List_Id;\n+\n+      function Build_Heap_Allocator\n+        (Temp_Id    : Entity_Id;\n+         Temp_Typ   : Entity_Id;\n+         Func_Id    : Entity_Id;\n+         Ret_Typ    : Entity_Id;\n+         Alloc_Expr : Node_Id) return Node_Id;\n+      --  Create the statements necessary to allocate a return object on the\n+      --  caller's collection. The collection is available through implicit\n+      --  parameter BIPcollection.\n+      --\n+      --    if BIPcollection /= null then\n+      --       declare\n+      --          type Ptr_Typ is access Ret_Typ;\n+      --          for Ptr_Typ'Storage_Pool use\n+      --                Base_Pool (BIPcollection.all).all;\n+      --          Local : Ptr_Typ;\n+      --\n+      --       begin\n+      --          procedure Allocate (...) is\n+      --          begin\n+      --             Ada.Finalization.Heap_Management.Allocate (...);\n+      --          end Allocate;\n+      --\n+      --          Local := <Alloc_Expr>;\n+      --          Temp_Id := Temp_Typ (Local);\n+      --       end;\n+      --    end if;\n+      --\n+      --  Temp_Id is the temporary which is used to reference the internally\n+      --  created object in all allocation forms. Temp_Typ is the type of the\n+      --  temporary. Func_Id is the enclosing function. Ret_Typ is the return\n+      --  type of Func_Id. Alloc_Expr is the actual allocator.\n \n       function Move_Activation_Chain return Node_Id;\n       --  Construct a call to System.Tasking.Stages.Move_Activation_Chain\n@@ -4267,189 +4380,334 @@ package body Exp_Ch6 is\n       --    To           activation chain passed in by the caller\n       --    New_Master   master passed in by the caller\n \n-      function Move_Final_List return Node_Id;\n-      --  Construct call to System.Finalization_Implementation.Move_Final_List\n-      --  with parameters:\n-      --\n-      --    From         finalization list of the return statement\n-      --    To           finalization list passed in by the caller\n+      --------------------------\n+      -- Build_Heap_Allocator --\n+      --------------------------\n+\n+      function Build_Heap_Allocator\n+        (Temp_Id    : Entity_Id;\n+         Temp_Typ   : Entity_Id;\n+         Func_Id    : Entity_Id;\n+         Ret_Typ    : Entity_Id;\n+         Alloc_Expr : Node_Id) return Node_Id\n+      is\n+      begin\n+         --  Processing for build-in-place object allocation. This is disabled\n+         --  on .NET/JVM because pools are not supported.\n+\n+         if VM_Target = No_VM\n+           and then Is_Build_In_Place_Function (Func_Id)\n+           and then Needs_Finalization (Ret_Typ)\n+         then\n+            declare\n+               Collect : constant Entity_Id :=\n+                           Build_In_Place_Formal (Func_Id, BIP_Collection);\n+               Decls   : constant List_Id := New_List;\n+               Stmts   : constant List_Id := New_List;\n+\n+               Local_Id : Entity_Id;\n+               Pool_Id  : Entity_Id;\n+               Ptr_Typ  : Entity_Id;\n+\n+            begin\n+               --  Generate:\n+               --    Pool_Id renames Base_Pool (BIPcollection.all).all;\n+\n+               Pool_Id := Make_Temporary (Loc, 'P');\n+\n+               Append_To (Decls,\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Pool_Id,\n+                   Subtype_Mark =>\n+                     New_Reference_To (RTE (RE_Root_Storage_Pool), Loc),\n+                   Name =>\n+                     Make_Explicit_Dereference (Loc,\n+                       Prefix =>\n+                         Make_Function_Call (Loc,\n+                           Name =>\n+                             New_Reference_To (RTE (RE_Base_Pool), Loc),\n+\n+                           Parameter_Associations => New_List (\n+                             Make_Explicit_Dereference (Loc,\n+                               Prefix =>\n+                                 New_Reference_To (Collect, Loc)))))));\n+\n+               --  Create an access type which uses the storage pool of the\n+               --  caller's collection. This additional type is necessary\n+               --  because the collection cannot be associated with the type\n+               --  of the temporary. Otherwise the secondary stack allocation\n+               --  will fail.\n+\n+               --  Generate:\n+               --    type Ptr_Typ is access Ret_Typ;\n+\n+               Ptr_Typ := Make_Temporary (Loc, 'P');\n+\n+               Append_To (Decls,\n+                 Make_Full_Type_Declaration (Loc,\n+                   Defining_Identifier => Ptr_Typ,\n+                   Type_Definition =>\n+                     Make_Access_To_Object_Definition (Loc,\n+                       Subtype_Indication =>\n+                         New_Reference_To (Ret_Typ, Loc))));\n+\n+               --  Perform minor decoration in order to set the collection and\n+               --  the storage pool attributes.\n+\n+               Set_Ekind (Ptr_Typ, E_Access_Type);\n+               Set_Associated_Collection   (Ptr_Typ, Collect);\n+               Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n+\n+               --  Create the temporary, generate:\n+               --\n+               --    Local_Id : Ptr_Typ;\n+\n+               Local_Id := Make_Temporary (Loc, 'T');\n+\n+               Append_To (Decls,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Local_Id,\n+                   Object_Definition =>\n+                     New_Reference_To (Ptr_Typ, Loc)));\n+\n+               --  Allocate the object, generate:\n+               --\n+               --    Local_Id := <Alloc_Expr>;\n+\n+               Append_To (Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (Local_Id, Loc),\n+                   Expression => Alloc_Expr));\n+\n+               --  Generate:\n+               --    Temp_Id := Temp_Typ (Local_Id);\n+\n+               Append_To (Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (Temp_Id, Loc),\n+                   Expression =>\n+                     Unchecked_Convert_To (Temp_Typ,\n+                       New_Reference_To (Local_Id, Loc))));\n+\n+               --  Wrap the allocation in a block. This is further conditioned\n+               --  by checking the caller collection at runtime. A null value\n+               --  indicates a non-existent collection, most likely due to a\n+               --  Finalize_Storage_Only allocation.\n+\n+               --  Generate:\n+               --    if BIPcollection /= null then\n+               --       declare\n+               --          <Decls>\n+               --       begin\n+               --          <Stmts>\n+               --       end;\n+               --    end if;\n+\n+               return\n+                 Make_If_Statement (Loc,\n+                   Condition =>\n+                     Make_Op_Ne (Loc,\n+                       Left_Opnd =>\n+                         New_Reference_To (Collect, Loc),\n+                       Right_Opnd =>\n+                         Make_Null (Loc)),\n+\n+                   Then_Statements => New_List (\n+                     Make_Block_Statement (Loc,\n+                       Declarations => Decls,\n+                       Handled_Statement_Sequence =>\n+                         Make_Handled_Sequence_Of_Statements (Loc,\n+                           Statements => Stmts))));\n+            end;\n+\n+         --  For all other cases, generate:\n+         --\n+         --    Temp_Id := <Alloc_Expr>;\n+\n+         else\n+            return\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (Temp_Id, Loc),\n+                Expression => Alloc_Expr);\n+         end if;\n+      end Build_Heap_Allocator;\n \n       ---------------------------\n       -- Move_Activation_Chain --\n       ---------------------------\n \n       function Move_Activation_Chain return Node_Id is\n-         Activation_Chain_Formal : constant Entity_Id :=\n-                                     Build_In_Place_Formal\n-                                       (Parent_Function, BIP_Activation_Chain);\n-         To                      : constant Node_Id :=\n-                                     New_Reference_To\n-                                       (Activation_Chain_Formal, Loc);\n-         Master_Formal           : constant Entity_Id :=\n-                                     Build_In_Place_Formal\n-                                       (Parent_Function, BIP_Master);\n-         New_Master              : constant Node_Id :=\n-                                     New_Reference_To (Master_Formal, Loc);\n-\n-         Chain_Entity : Entity_Id;\n-         From         : Node_Id;\n+         Chain_Formal  : constant Entity_Id :=\n+                           Build_In_Place_Formal\n+                            (Par_Func, BIP_Activation_Chain);\n+         To            : constant Node_Id :=\n+                           New_Reference_To (Chain_Formal, Loc);\n+         Master_Formal : constant Entity_Id :=\n+                           Build_In_Place_Formal (Par_Func, BIP_Master);\n+         New_Master    : constant Node_Id :=\n+                           New_Reference_To (Master_Formal, Loc);\n+\n+         Chain_Id : Entity_Id;\n+         From     : Node_Id;\n \n       begin\n-         Chain_Entity := First_Entity (Return_Statement_Entity (N));\n-         while Chars (Chain_Entity) /= Name_uChain loop\n-            Chain_Entity := Next_Entity (Chain_Entity);\n+         Chain_Id := First_Entity (Return_Statement_Entity (N));\n+         while Chars (Chain_Id) /= Name_uChain loop\n+            Chain_Id := Next_Entity (Chain_Id);\n          end loop;\n \n          From :=\n            Make_Attribute_Reference (Loc,\n-             Prefix         => New_Reference_To (Chain_Entity, Loc),\n+             Prefix =>\n+               New_Reference_To (Chain_Id, Loc),\n              Attribute_Name => Name_Unrestricted_Access);\n          --  ??? Not clear why \"Make_Identifier (Loc, Name_uChain)\" doesn't\n-         --  work, instead of \"New_Reference_To (Chain_Entity, Loc)\" above.\n+         --  work, instead of \"New_Reference_To (Chain_Id, Loc)\" above.\n \n          return\n            Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To (RTE (RE_Move_Activation_Chain), Loc),\n+             Name =>\n+               New_Reference_To (RTE (RE_Move_Activation_Chain), Loc),\n              Parameter_Associations => New_List (From, To, New_Master));\n       end Move_Activation_Chain;\n \n-      ---------------------\n-      -- Move_Final_List --\n-      ---------------------\n+   --  Start of processing for Expand_N_Extended_Return_Statement\n \n-      function Move_Final_List return Node_Id is\n-         Flist : constant Entity_Id  :=\n-                   Finalization_Chain_Entity (Return_Statement_Entity (N));\n+   begin\n+      if Nkind (Ret_Obj_Decl) = N_Object_Declaration then\n+         Exp := Expression (Ret_Obj_Decl);\n+      else\n+         Exp := Empty;\n+      end if;\n \n-         From : constant Node_Id := New_Reference_To (Flist, Loc);\n+      HSS := Handled_Statement_Sequence (N);\n \n-         Caller_Final_List : constant Entity_Id :=\n-                               Build_In_Place_Formal\n-                                 (Parent_Function, BIP_Final_List);\n+      --  If the returned object needs finalization actions, the function must\n+      --  perform the appropriate cleanup should it fail to return. The state\n+      --  of the function itself is tracked through a flag which is coupled\n+      --  with the scope finalizer. There is one flag per each return object\n+      --  in case of multiple returns.\n \n-         To : constant Node_Id := New_Reference_To (Caller_Final_List, Loc);\n+      if Is_Build_In_Place\n+        and then Needs_Finalization (Etype (Ret_Obj_Id))\n+      then\n+         declare\n+            Flag_Decl : Node_Id;\n+            Flag_Id   : Entity_Id;\n+            Func_Bod  : Node_Id;\n \n-      begin\n-         --  Catch cases where a finalization chain entity has not been\n-         --  associated with the return statement entity.\n+         begin\n+            --  Recover the function body\n \n-         pragma Assert (Present (Flist));\n+            Func_Bod := Unit_Declaration_Node (Par_Func);\n+            if Nkind (Func_Bod) = N_Subprogram_Declaration then\n+               Func_Bod := Parent (Parent (Corresponding_Body (Func_Bod)));\n+            end if;\n \n-         --  Build required call\n+            --  Create a flag to track the function state\n \n-         return\n-           Make_If_Statement (Loc,\n-             Condition =>\n-               Make_Op_Ne (Loc,\n-                 Left_Opnd  => New_Copy (From),\n-                 Right_Opnd => New_Node (N_Null, Loc)),\n-             Then_Statements =>\n-               New_List (\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To (RTE (RE_Move_Final_List), Loc),\n-                   Parameter_Associations => New_List (From, To))));\n-      end Move_Final_List;\n+            Flag_Id := Make_Temporary (Loc, 'F');\n+            Set_Return_Flag (Ret_Obj_Id, Flag_Id);\n \n-   --  Start of processing for Expand_N_Extended_Return_Statement\n+            --  Insert the flag at the beginning of the function declarations,\n+            --  generate:\n+            --    Fnn : Boolean := False;\n \n-   begin\n-      if Nkind (Return_Object_Decl) = N_Object_Declaration then\n-         Exp := Expression (Return_Object_Decl);\n-      else\n-         Exp := Empty;\n-      end if;\n+            Flag_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Flag_Id,\n+                Object_Definition =>\n+                  New_Reference_To (Standard_Boolean, Loc),\n+                Expression =>\n+                  New_Reference_To (Standard_False, Loc));\n \n-      Handled_Stm_Seq := Handled_Statement_Sequence (N);\n+            Prepend_To (Declarations (Func_Bod), Flag_Decl);\n+            Analyze (Flag_Decl);\n+         end;\n+      end if;\n \n       --  Build a simple_return_statement that returns the return object when\n       --  there is a statement sequence, or no expression, or the result will\n       --  be built in place. Note however that we currently do this for all\n       --  composite cases, even though nonlimited composite results are not yet\n       --  built in place (though we plan to do so eventually).\n \n-      if Present (Handled_Stm_Seq)\n-        or else Is_Composite_Type (Etype (Parent_Function))\n+      if Present (HSS)\n+        or else Is_Composite_Type (Etype (Par_Func))\n         or else No (Exp)\n       then\n-         if No (Handled_Stm_Seq) then\n-            Statements := New_List;\n+         if No (HSS) then\n+            Stmts := New_List;\n \n          --  If the extended return has a handled statement sequence, then wrap\n          --  it in a block and use the block as the first statement.\n \n          else\n-            Statements :=\n-              New_List (Make_Block_Statement (Loc,\n-                          Declarations => New_List,\n-                          Handled_Statement_Sequence => Handled_Stm_Seq));\n+            Stmts := New_List (\n+              Make_Block_Statement (Loc,\n+                Declarations => New_List,\n+                Handled_Statement_Sequence => HSS));\n          end if;\n \n-         --  If control gets past the above Statements, we have successfully\n-         --  completed the return statement. If the result type has controlled\n-         --  parts and the return is for a build-in-place function, then we\n-         --  call Move_Final_List to transfer responsibility for finalization\n-         --  of the return object to the caller. An alternative would be to\n-         --  declare a Success flag in the function, initialize it to False,\n-         --  and set it to True here. Then move the Move_Final_List call into\n-         --  the cleanup code, and check Success. If Success then make a call\n-         --  to Move_Final_List else do finalization. Then we can remove the\n-         --  abort-deferral and the nulling-out of the From parameter from\n-         --  Move_Final_List. Note that the current method is not quite correct\n-         --  in the rather obscure case of a select-then-abort statement whose\n-         --  abortable part contains the return statement.\n-\n-         --  Check the type of the function to determine whether to move the\n-         --  finalization list. A special case arises when processing a simple\n-         --  return statement which has been rewritten as an extended return.\n-         --  In that case check the type of the returned object or the original\n-         --  expression. Note that Needs_Finalization accounts for the case\n-         --  of class-wide types, which which must be assumed to require\n-         --  finalization.\n+         --  If the result type contains tasks, we call Move_Activation_Chain.\n+         --  Later, the cleanup code will call Complete_Master, which will\n+         --  terminate any unactivated tasks belonging to the return statement\n+         --  master. But Move_Activation_Chain updates their master to be that\n+         --  of the caller, so they will not be terminated unless the return\n+         --  statement completes unsuccessfully due to exception, abort, goto,\n+         --  or exit. As a formality, we test whether the function requires the\n+         --  result to be built in place, though that's necessarily true for\n+         --  the case of result types with task parts.\n \n          if Is_Build_In_Place\n-           and then Needs_BIP_Final_List (Parent_Function)\n-           and then\n-             ((Present (Exp) and then Needs_Finalization (Etype (Exp)))\n-                or else\n-              (not Present (Exp)\n-                and then Needs_Finalization (Etype (Return_Object_Entity))))\n+           and Has_Task (Etype (Par_Func))\n          then\n-            Append_To (Statements, Move_Final_List);\n+            Append_To (Stmts, Move_Activation_Chain);\n          end if;\n \n-         --  Similarly to the above Move_Final_List, if the result type\n-         --  contains tasks, we call Move_Activation_Chain. Later, the cleanup\n-         --  code will call Complete_Master, which will terminate any\n-         --  unactivated tasks belonging to the return statement master. But\n-         --  Move_Activation_Chain updates their master to be that of the\n-         --  caller, so they will not be terminated unless the return statement\n-         --  completes unsuccessfully due to exception, abort, goto, or exit.\n-         --  As a formality, we test whether the function requires the result\n-         --  to be built in place, though that's necessarily true for the case\n-         --  of result types with task parts.\n-\n-         if Is_Build_In_Place and Has_Task (Etype (Parent_Function)) then\n-            Append_To (Statements, Move_Activation_Chain);\n+         --  Update the state of the function right before the object is\n+         --  returned.\n+\n+         if Is_Build_In_Place\n+           and then Needs_Finalization (Etype (Ret_Obj_Id))\n+         then\n+            declare\n+               Flag_Id : constant Entity_Id := Return_Flag (Ret_Obj_Id);\n+\n+            begin\n+               --  Generate:\n+               --    Fnn := True;\n+\n+               Append_To (Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (Flag_Id, Loc),\n+                   Expression =>\n+                     New_Reference_To (Standard_True, Loc)));\n+            end;\n          end if;\n \n          --  Build a simple_return_statement that returns the return object\n \n-         Return_Stm :=\n+         Return_Stmt :=\n            Make_Simple_Return_Statement (Loc,\n-             Expression => New_Occurrence_Of (Return_Object_Entity, Loc));\n-         Append_To (Statements, Return_Stm);\n+             Expression =>\n+               New_Occurrence_Of (Ret_Obj_Id, Loc));\n+         Append_To (Stmts, Return_Stmt);\n \n-         Handled_Stm_Seq :=\n-           Make_Handled_Sequence_Of_Statements (Loc, Statements);\n+         HSS := Make_Handled_Sequence_Of_Statements (Loc, Stmts);\n       end if;\n \n-      --  Case where we build a block\n+      --  Case where we build a return statement block\n \n-      if Present (Handled_Stm_Seq) then\n+      if Present (HSS) then\n          Result :=\n            Make_Block_Statement (Loc,\n              Declarations => Return_Object_Declarations (N),\n-             Handled_Statement_Sequence => Handled_Stm_Seq);\n+             Handled_Statement_Sequence => HSS);\n \n          --  We set the entity of the new block statement to be that of the\n          --  return statement. This is necessary so that various fields, such\n@@ -4468,15 +4726,16 @@ package body Exp_Ch6 is\n          --  allocation of the return object.\n \n          if Is_Build_In_Place\n-           and then\n-             Nkind (Return_Object_Decl) = N_Object_Renaming_Declaration\n+           and then Nkind (Ret_Obj_Decl) = N_Object_Renaming_Declaration\n          then\n-            pragma Assert (Nkind (Original_Node (Return_Object_Decl)) =\n-                            N_Object_Declaration\n-              and then Is_Build_In_Place_Function_Call\n-                         (Expression (Original_Node (Return_Object_Decl))));\n+            pragma Assert\n+              (Nkind (Original_Node (Ret_Obj_Decl)) = N_Object_Declaration\n+                 and then Is_Build_In_Place_Function_Call\n+                            (Expression (Original_Node (Ret_Obj_Decl))));\n+\n+            --  Return the build-in-place result by reference\n \n-            Set_By_Ref (Return_Stm);  -- Return build-in-place results by ref\n+            Set_By_Ref (Return_Stmt);\n \n          elsif Is_Build_In_Place then\n \n@@ -4488,27 +4747,26 @@ package body Exp_Ch6 is\n             --  expanded as separate assignments, then add an assignment\n             --  statement to ensure the return object gets initialized.\n \n-            --  declare\n-            --     Result : T [:= <expression>];\n-            --  begin\n-            --     ...\n+            --    declare\n+            --       Result : T [:= <expression>];\n+            --    begin\n+            --       ...\n \n             --  is converted to\n \n-            --  declare\n-            --     Result : T renames FuncRA.all;\n-            --     [Result := <expression;]\n-            --  begin\n-            --     ...\n+            --    declare\n+            --       Result : T renames FuncRA.all;\n+            --       [Result := <expression;]\n+            --    begin\n+            --       ...\n \n             declare\n                Return_Obj_Id    : constant Entity_Id :=\n-                                    Defining_Identifier (Return_Object_Decl);\n+                                    Defining_Identifier (Ret_Obj_Decl);\n                Return_Obj_Typ   : constant Entity_Id := Etype (Return_Obj_Id);\n                Return_Obj_Expr  : constant Node_Id :=\n-                                    Expression (Return_Object_Decl);\n-               Result_Subt      : constant Entity_Id :=\n-                                    Etype (Parent_Function);\n+                                    Expression (Ret_Obj_Decl);\n+               Result_Subt      : constant Entity_Id := Etype (Par_Func);\n                Constr_Result    : constant Boolean :=\n                                     Is_Constrained (Result_Subt);\n                Obj_Alloc_Formal : Entity_Id;\n@@ -4519,12 +4777,12 @@ package body Exp_Ch6 is\n             begin\n                --  Build-in-place results must be returned by reference\n \n-               Set_By_Ref (Return_Stm);\n+               Set_By_Ref (Return_Stmt);\n \n                --  Retrieve the implicit access parameter passed by the caller\n \n                Object_Access :=\n-                 Build_In_Place_Formal (Parent_Function, BIP_Object_Access);\n+                 Build_In_Place_Formal (Par_Func, BIP_Object_Access);\n \n                --  If the return object's declaration includes an expression\n                --  and the declaration isn't marked as No_Initialization, then\n@@ -4543,21 +4801,24 @@ package body Exp_Ch6 is\n                --  interface has no assignment operation).\n \n                if Present (Return_Obj_Expr)\n-                 and then not No_Initialization (Return_Object_Decl)\n+                 and then not No_Initialization (Ret_Obj_Decl)\n                  and then not Is_Interface (Return_Obj_Typ)\n                then\n                   Init_Assignment :=\n                     Make_Assignment_Statement (Loc,\n-                      Name       => New_Reference_To (Return_Obj_Id, Loc),\n-                      Expression => Relocate_Node (Return_Obj_Expr));\n+                      Name =>\n+                        New_Reference_To (Return_Obj_Id, Loc),\n+                      Expression =>\n+                        Relocate_Node (Return_Obj_Expr));\n+\n                   Set_Etype (Name (Init_Assignment), Etype (Return_Obj_Id));\n                   Set_Assignment_OK (Name (Init_Assignment));\n                   Set_No_Ctrl_Actions (Init_Assignment);\n \n                   Set_Parent (Name (Init_Assignment), Init_Assignment);\n                   Set_Parent (Expression (Init_Assignment), Init_Assignment);\n \n-                  Set_Expression (Return_Object_Decl, Empty);\n+                  Set_Expression (Ret_Obj_Decl, Empty);\n \n                   if Is_Class_Wide_Type (Etype (Return_Obj_Id))\n                     and then not Is_Class_Wide_Type\n@@ -4566,8 +4827,7 @@ package body Exp_Ch6 is\n                      Rewrite (Expression (Init_Assignment),\n                        Make_Type_Conversion (Loc,\n                          Subtype_Mark =>\n-                           New_Occurrence_Of\n-                             (Etype (Return_Obj_Id), Loc),\n+                           New_Occurrence_Of (Etype (Return_Obj_Id), Loc),\n                          Expression =>\n                            Relocate_Node (Expression (Init_Assignment))));\n                   end if;\n@@ -4581,7 +4841,7 @@ package body Exp_Ch6 is\n                   if Constr_Result\n                     and then not Is_Tagged_Type (Underlying_Type (Result_Subt))\n                   then\n-                     Insert_After (Return_Object_Decl, Init_Assignment);\n+                     Insert_After (Ret_Obj_Decl, Init_Assignment);\n                   end if;\n                end if;\n \n@@ -4608,24 +4868,24 @@ package body Exp_Ch6 is\n                  or else Is_Tagged_Type (Underlying_Type (Result_Subt))\n                then\n                   Obj_Alloc_Formal :=\n-                    Build_In_Place_Formal (Parent_Function, BIP_Alloc_Form);\n+                    Build_In_Place_Formal (Par_Func, BIP_Alloc_Form);\n \n                   declare\n                      Ref_Type       : Entity_Id;\n                      Ptr_Type_Decl  : Node_Id;\n                      Alloc_Obj_Id   : Entity_Id;\n                      Alloc_Obj_Decl : Node_Id;\n                      Alloc_If_Stmt  : Node_Id;\n-                     SS_Allocator   : Node_Id;\n                      Heap_Allocator : Node_Id;\n+                     SS_Allocator   : Node_Id;\n \n                   begin\n                      --  Reuse the itype created for the function's implicit\n                      --  access formal. This avoids the need to create a new\n                      --  access type here, plus it allows assigning the access\n                      --  formal directly without applying a conversion.\n \n-                     --  Ref_Type := Etype (Object_Access);\n+                     --    Ref_Type := Etype (Object_Access);\n \n                      --  Create an access type designating the function's\n                      --  result subtype.\n@@ -4641,7 +4901,7 @@ package body Exp_Ch6 is\n                              Subtype_Indication =>\n                                New_Reference_To (Return_Obj_Typ, Loc)));\n \n-                     Insert_Before (Return_Object_Decl, Ptr_Type_Decl);\n+                     Insert_Before (Ret_Obj_Decl, Ptr_Type_Decl);\n \n                      --  Create an access object that will be initialized to an\n                      --  access value denoting the return object, either coming\n@@ -4654,17 +4914,17 @@ package body Exp_Ch6 is\n                      Alloc_Obj_Decl :=\n                        Make_Object_Declaration (Loc,\n                          Defining_Identifier => Alloc_Obj_Id,\n-                         Object_Definition   => New_Reference_To\n-                                                  (Ref_Type, Loc));\n+                         Object_Definition =>\n+                           New_Reference_To (Ref_Type, Loc));\n \n-                     Insert_Before (Return_Object_Decl, Alloc_Obj_Decl);\n+                     Insert_Before (Ret_Obj_Decl, Alloc_Obj_Decl);\n \n                      --  Create allocators for both the secondary stack and\n                      --  global heap. If there's an initialization expression,\n                      --  then create these as initialized allocators.\n \n                      if Present (Return_Obj_Expr)\n-                       and then not No_Initialization (Return_Object_Decl)\n+                       and then not No_Initialization (Ret_Obj_Decl)\n                      then\n                         --  Always use the type of the expression for the\n                         --  qualified expression, rather than the result type.\n@@ -4755,10 +5015,10 @@ package body Exp_Ch6 is\n                         --  statement, past the point where these flags are\n                         --  normally set.\n \n-                        Set_Sec_Stack_Needed_For_Return (Parent_Function);\n+                        Set_Sec_Stack_Needed_For_Return (Par_Func);\n                         Set_Sec_Stack_Needed_For_Return\n                           (Return_Statement_Entity (N));\n-                        Set_Uses_Sec_Stack (Parent_Function);\n+                        Set_Uses_Sec_Stack (Par_Func);\n                         Set_Uses_Sec_Stack (Return_Statement_Entity (N));\n                      end if;\n \n@@ -4780,53 +5040,50 @@ package body Exp_Ch6 is\n \n                      Alloc_If_Stmt :=\n                        Make_If_Statement (Loc,\n-                         Condition       =>\n+                         Condition =>\n                            Make_Op_Eq (Loc,\n                              Left_Opnd =>\n                                New_Reference_To (Obj_Alloc_Formal, Loc),\n                              Right_Opnd =>\n                                Make_Integer_Literal (Loc,\n                                  UI_From_Int (BIP_Allocation_Form'Pos\n                                                 (Caller_Allocation)))),\n-                         Then_Statements =>\n-                           New_List (Make_Assignment_Statement (Loc,\n-                                       Name       =>\n-                                         New_Reference_To\n-                                           (Alloc_Obj_Id, Loc),\n-                                       Expression =>\n-                                         Make_Unchecked_Type_Conversion (Loc,\n-                                           Subtype_Mark =>\n-                                             New_Reference_To (Ref_Type, Loc),\n-                                           Expression =>\n-                                             New_Reference_To\n-                                               (Object_Access, Loc)))),\n-                         Elsif_Parts     =>\n-                           New_List (Make_Elsif_Part (Loc,\n-                                       Condition       =>\n-                                         Make_Op_Eq (Loc,\n-                                           Left_Opnd =>\n-                                             New_Reference_To\n-                                               (Obj_Alloc_Formal, Loc),\n-                                           Right_Opnd =>\n-                                             Make_Integer_Literal (Loc,\n-                                               UI_From_Int (\n-                                                 BIP_Allocation_Form'Pos\n+\n+                         Then_Statements => New_List (\n+                           Make_Assignment_Statement (Loc,\n+                             Name =>\n+                               New_Reference_To (Alloc_Obj_Id, Loc),\n+                             Expression =>\n+                               Make_Unchecked_Type_Conversion (Loc,\n+                                 Subtype_Mark =>\n+                                   New_Reference_To (Ref_Type, Loc),\n+                                 Expression =>\n+                                   New_Reference_To (Object_Access, Loc)))),\n+\n+                         Elsif_Parts => New_List (\n+                           Make_Elsif_Part (Loc,\n+                             Condition =>\n+                               Make_Op_Eq (Loc,\n+                                 Left_Opnd =>\n+                                   New_Reference_To (Obj_Alloc_Formal, Loc),\n+                                 Right_Opnd =>\n+                                   Make_Integer_Literal (Loc,\n+                                     UI_From_Int (BIP_Allocation_Form'Pos\n                                                     (Secondary_Stack)))),\n-                                       Then_Statements =>\n-                                          New_List\n-                                            (Make_Assignment_Statement (Loc,\n-                                               Name       =>\n-                                                 New_Reference_To\n-                                                   (Alloc_Obj_Id, Loc),\n-                                               Expression =>\n-                                                 SS_Allocator)))),\n-                         Else_Statements =>\n-                           New_List (Make_Assignment_Statement (Loc,\n-                                        Name       =>\n-                                          New_Reference_To\n-                                            (Alloc_Obj_Id, Loc),\n-                                        Expression =>\n-                                          Heap_Allocator)));\n+\n+                             Then_Statements => New_List (\n+                               Make_Assignment_Statement (Loc,\n+                                 Name =>\n+                                   New_Reference_To (Alloc_Obj_Id, Loc),\n+                                 Expression => SS_Allocator)))),\n+\n+                         Else_Statements => New_List (\n+                           Build_Heap_Allocator\n+                             (Temp_Id    => Alloc_Obj_Id,\n+                              Temp_Typ   => Ref_Type,\n+                              Func_Id    => Par_Func,\n+                              Ret_Typ    => Return_Obj_Typ,\n+                              Alloc_Expr => Heap_Allocator)));\n \n                      --  If a separate initialization assignment was created\n                      --  earlier, append that following the assignment of the\n@@ -4839,7 +5096,9 @@ package body Exp_Ch6 is\n                      if Present (Init_Assignment) then\n                         Rewrite (Name (Init_Assignment),\n                           Make_Explicit_Dereference (Loc,\n-                            Prefix => New_Reference_To (Alloc_Obj_Id, Loc)));\n+                            Prefix =>\n+                              New_Reference_To (Alloc_Obj_Id, Loc)));\n+\n                         Set_Etype\n                           (Name (Init_Assignment), Etype (Return_Obj_Id));\n \n@@ -4848,7 +5107,7 @@ package body Exp_Ch6 is\n                            Init_Assignment);\n                      end if;\n \n-                     Insert_Before (Return_Object_Decl, Alloc_If_Stmt);\n+                     Insert_Before (Ret_Obj_Decl, Alloc_If_Stmt);\n \n                      --  Remember the local access object for use in the\n                      --  dereference of the renaming created below.\n@@ -4863,15 +5122,16 @@ package body Exp_Ch6 is\n \n                Obj_Acc_Deref :=\n                  Make_Explicit_Dereference (Loc,\n-                   Prefix => New_Reference_To (Object_Access, Loc));\n+                   Prefix =>\n+                     New_Reference_To (Object_Access, Loc));\n \n-               Rewrite (Return_Object_Decl,\n+               Rewrite (Ret_Obj_Decl,\n                  Make_Object_Renaming_Declaration (Loc,\n                    Defining_Identifier => Return_Obj_Id,\n-                   Access_Definition   => Empty,\n-                   Subtype_Mark        => New_Occurrence_Of\n-                                            (Return_Obj_Typ, Loc),\n-                   Name                => Obj_Acc_Deref));\n+                   Access_Definition => Empty,\n+                   Subtype_Mark =>\n+                     New_Occurrence_Of (Return_Obj_Typ, Loc),\n+                   Name => Obj_Acc_Deref));\n \n                Set_Renamed_Object (Return_Obj_Id, Obj_Acc_Deref);\n             end;\n@@ -4880,49 +5140,23 @@ package body Exp_Ch6 is\n       --  Case where we do not build a block\n \n       else\n+         --  We're about to drop Return_Object_Declarations on the floor, so\n+         --  we need to insert it, in case it got expanded into useful code.\n          --  Remove side effects from expression, which may be duplicated in\n          --  subsequent checks (see Expand_Simple_Function_Return).\n \n+         Insert_List_Before (N, Return_Object_Declarations (N));\n          Remove_Side_Effects (Exp);\n \n          --  Build simple_return_statement that returns the expression directly\n \n-         Return_Stm := Make_Simple_Return_Statement (Loc, Expression => Exp);\n-\n-         --  The expansion of the return expression may create a finalization\n-         --  chain to service transient temporaries. The entity of the chain\n-         --  appears as a semantic attribute of the return statement scope.\n-         --  For the chain to be handled properly by Expand_Cleanup_Actions,\n-         --  the return statement is wrapped in a block and reanalyzed.\n-\n-         if Present\n-              (Finalization_Chain_Entity (Return_Statement_Entity (N)))\n-         then\n-            Result :=\n-              Make_Block_Statement (Loc,\n-                Declarations => Return_Object_Declarations (N),\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => New_List (Return_Stm)));\n-\n-            --  Propagate the return statement scope to the block in order to\n-            --  preserve the various semantic fields.\n-\n-            Set_Identifier\n-              (Result, New_Occurrence_Of (Return_Statement_Entity (N), Loc));\n-         else\n-            --  We're about to drop Return_Object_Declarations on the floor, so\n-            --  we need to insert it, in case it got expanded into useful code.\n-\n-            Insert_List_Before (N, Return_Object_Declarations (N));\n-\n-            Result := Return_Stm;\n-         end if;\n+         Return_Stmt := Make_Simple_Return_Statement (Loc, Expression => Exp);\n+         Result := Return_Stmt;\n       end if;\n \n       --  Set the flag to prevent infinite recursion\n \n-      Set_Comes_From_Extended_Return_Statement (Return_Stm);\n+      Set_Comes_From_Extended_Return_Statement (Return_Stmt);\n \n       Rewrite (N, Result);\n       Analyze (N);\n@@ -6557,7 +6791,7 @@ package body Exp_Ch6 is\n            Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (Tagged_Typ))));\n \n          while Present (Iface_DT_Ptr)\n-            and then Ekind (Node (Iface_DT_Ptr)) = E_Constant\n+           and then Ekind (Node (Iface_DT_Ptr)) = E_Constant\n          loop\n             pragma Assert (Has_Thunks (Node (Iface_DT_Ptr)));\n             Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n@@ -6600,7 +6834,7 @@ package body Exp_Ch6 is\n             pragma Assert (not Has_Thunks (Node (Iface_DT_Ptr)));\n \n             --  Skip the tag of the predefined primitives no-thunks dispatch\n-            --  table\n+            --  table.\n \n             Next_Elmt (Iface_DT_Ptr);\n             pragma Assert (not Has_Thunks (Node (Iface_DT_Ptr)));\n@@ -6611,7 +6845,7 @@ package body Exp_Ch6 is\n \n       --  Local variables\n \n-      Subp : constant Entity_Id := Entity (N);\n+      Subp : constant Entity_Id  := Entity (N);\n \n    --  Start of processing for Freeze_Subprogram\n \n@@ -6862,7 +7096,7 @@ package body Exp_Ch6 is\n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n-         Add_Final_List_Actual_To_Build_In_Place_Call\n+         Add_Collection_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Acc_Type);\n \n          Add_Task_Actuals_To_Build_In_Place_Call\n@@ -6890,14 +7124,13 @@ package body Exp_Ch6 is\n       --  operations. ???\n \n       else\n-\n          --  Pass an allocation parameter indicating that the function should\n          --  allocate its result on the heap.\n \n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n \n-         Add_Final_List_Actual_To_Build_In_Place_Call\n+         Add_Collection_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Acc_Type);\n \n          Add_Task_Actuals_To_Build_In_Place_Call\n@@ -6910,6 +7143,30 @@ package body Exp_Ch6 is\n            (Func_Call, Function_Id, Return_Object => Empty);\n       end if;\n \n+      --  If the build-in-place function call returns a controlled object, the\n+      --  finalization collection will require a reference to routine Finalize_\n+      --  Address of the designated type. Setting this attribute is done in the\n+      --  same manner to expansion of allocators.\n+\n+      if Needs_Finalization (Result_Subt) then\n+\n+         --  Controlled types with supressed finalization do not need to\n+         --  associate the address of their Finalize_Address primitives with a\n+         --  collection since they do not need a collection to begin with.\n+\n+         if Is_Library_Level_Entity (Acc_Type)\n+           and then Finalize_Storage_Only (Result_Subt)\n+         then\n+            null;\n+\n+         else\n+            Insert_Action (Allocator,\n+              Make_Set_Finalize_Address_Ptr_Call (Loc,\n+                Typ     => Etype (Function_Id),\n+                Ptr_Typ => Acc_Type));\n+         end if;\n+      end if;\n+\n       --  Finally, replace the allocator node with a reference to the result\n       --  of the function call itself (which will effectively be an access\n       --  to the object created by the allocator).\n@@ -6970,10 +7227,47 @@ package body Exp_Ch6 is\n \n       Result_Subt := Etype (Function_Id);\n \n+      --  If the build-in-place function returns a controlled object, then the\n+      --  object needs to be finalized immediately after the context. Since\n+      --  this case produces a transient scope, the servicing finalizer needs\n+      --  to name the returned object. Create a temporary which is initialized\n+      --  with the function call:\n+      --\n+      --    Temp_Id : Func_Type := BIP_Func_Call;\n+      --\n+      --  The initialization expression of the temporary will be rewritten by\n+      --  the expander using the appropriate mechanism in Make_Build_In_Place_\n+      --  Call_In_Object_Declaration.\n+\n+      if Needs_Finalization (Result_Subt) then\n+         declare\n+            Temp_Id   : constant Entity_Id := Make_Temporary (Loc, 'R');\n+            Temp_Decl : Node_Id;\n+\n+         begin\n+            --  Reset the guard on the function call since the following does\n+            --  not perform actual call expansion.\n+\n+            Set_Is_Expanded_Build_In_Place_Call (Func_Call, False);\n+\n+            Temp_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp_Id,\n+                Object_Definition =>\n+                  New_Reference_To (Result_Subt, Loc),\n+                Expression =>\n+                  New_Copy_Tree (Function_Call));\n+\n+            Insert_Action (Function_Call, Temp_Decl);\n+\n+            Rewrite (Function_Call, New_Reference_To (Temp_Id, Loc));\n+            Analyze (Function_Call);\n+         end;\n+\n       --  When the result subtype is constrained, an object of the subtype is\n       --  declared and an access value designating it is passed as an actual.\n \n-      if Is_Constrained (Underlying_Type (Result_Subt)) then\n+      elsif Is_Constrained (Underlying_Type (Result_Subt)) then\n \n          --  Create a temporary object to hold the function result\n \n@@ -6999,8 +7293,8 @@ package body Exp_Ch6 is\n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n-         Add_Final_List_Actual_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Acc_Type => Empty);\n+         Add_Collection_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id);\n \n          Add_Task_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n@@ -7023,8 +7317,8 @@ package body Exp_Ch6 is\n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n \n-         Add_Final_List_Actual_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Acc_Type => Empty);\n+         Add_Collection_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id);\n \n          Add_Task_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n@@ -7101,16 +7395,8 @@ package body Exp_Ch6 is\n       Add_Alloc_Form_Actual_To_Build_In_Place_Call\n         (Func_Call, Func_Id, Alloc_Form => Caller_Allocation);\n \n-      --  If Lhs is a selected component, then pass it along so that its prefix\n-      --  object will be used as the source of the finalization list.\n-\n-      if Nkind (Lhs) = N_Selected_Component then\n-         Add_Final_List_Actual_To_Build_In_Place_Call\n-           (Func_Call, Func_Id, Acc_Type => Empty, Sel_Comp => Lhs);\n-      else\n-         Add_Final_List_Actual_To_Build_In_Place_Call\n-           (Func_Call, Func_Id, Acc_Type => Empty);\n-      end if;\n+      Add_Collection_Actual_To_Build_In_Place_Call\n+        (Func_Call, Func_Id);\n \n       Add_Task_Actuals_To_Build_In_Place_Call\n         (Func_Call, Func_Id, Make_Identifier (Loc, Name_uMaster));\n@@ -7176,58 +7462,6 @@ package body Exp_Ch6 is\n       else\n          return;\n       end if;\n-\n-      --  When the target of the assignment is a return object of an enclosing\n-      --  build-in-place function and also requires finalization, the list\n-      --  generated for the assignment must be moved to that of the enclosing\n-      --  function.\n-\n-      --    function Enclosing_BIP_Function return Ctrl_Typ is\n-      --    begin\n-      --       return (Ctrl_Parent_Part => BIP_Function with ...);\n-      --    end Enclosing_BIP_Function;\n-\n-      if Is_Return_Object (Target)\n-        and then Needs_Finalization (Etype (Target))\n-        and then Needs_Finalization (Result_Subt)\n-      then\n-         declare\n-            Obj_List  : constant Node_Id := Find_Final_List (Obj_Id);\n-            Encl_List : Node_Id;\n-            Encl_Scop : Entity_Id;\n-\n-         begin\n-            Encl_Scop := Scope (Target);\n-\n-            --  Locate the scope of the extended return statement\n-\n-            while Present (Encl_Scop)\n-              and then Ekind (Encl_Scop) /= E_Return_Statement\n-            loop\n-               Encl_Scop := Scope (Encl_Scop);\n-            end loop;\n-\n-            --  A return object should always be enclosed by a return statement\n-            --  scope at some level.\n-\n-            pragma Assert (Present (Encl_Scop));\n-\n-            Encl_List :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix =>\n-                  New_Reference_To (\n-                    Finalization_Chain_Entity (Encl_Scop), Loc),\n-                Attribute_Name => Name_Unrestricted_Access);\n-\n-            --  Generate a call to move final list\n-\n-            Insert_After_And_Analyze (Obj_Decl,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Reference_To (RTE (RE_Move_Final_List), Loc),\n-                Parameter_Associations => New_List (Obj_List, Encl_List)));\n-         end;\n-      end if;\n    end Make_Build_In_Place_Call_In_Assignment;\n \n    ----------------------------------------------------\n@@ -7377,8 +7611,8 @@ package body Exp_Ch6 is\n          Establish_Transient_Scope (Object_Decl, Sec_Stack => True);\n       end if;\n \n-      Add_Final_List_Actual_To_Build_In_Place_Call\n-        (Func_Call, Function_Id, Acc_Type => Empty);\n+      Add_Collection_Actual_To_Build_In_Place_Call\n+        (Func_Call, Function_Id);\n \n       if Nkind (Parent (Object_Decl)) = N_Extended_Return_Statement\n         and then Has_Task (Result_Subt)\n@@ -7525,23 +7759,17 @@ package body Exp_Ch6 is\n    end Make_Build_In_Place_Call_In_Object_Declaration;\n \n    --------------------------\n-   -- Needs_BIP_Final_List --\n+   -- Needs_BIP_Collection --\n    --------------------------\n \n-   function Needs_BIP_Final_List (E : Entity_Id) return Boolean is\n-      pragma Assert (Is_Build_In_Place_Function (E));\n-      Result_Subt : constant Entity_Id := Underlying_Type (Etype (E));\n+   function Needs_BIP_Collection (Func_Id : Entity_Id) return Boolean is\n+      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n+      Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n \n    begin\n-      --  We need the BIP_Final_List if the result type needs finalization. We\n-      --  also need it for tagged types, even if not class-wide, because some\n-      --  type extension might need finalization, and all overriding functions\n-      --  must have the same calling conventions. However, if there is a\n-      --  pragma Restrictions (No_Finalization), we never need this parameter.\n-\n-      return (Needs_Finalization (Result_Subt)\n-               or else Is_Tagged_Type (Underlying_Type (Result_Subt)))\n-        and then not Restriction_Active (No_Finalization);\n-   end Needs_BIP_Final_List;\n+      return\n+        not Restriction_Active (No_Finalization)\n+          and then Needs_Finalization (Func_Typ);\n+   end Needs_BIP_Collection;\n \n end Exp_Ch6;"}, {"sha": "433b96a62b7a5f8334d7c90ae2f869ff7a56ae17", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -61,23 +61,28 @@ package Exp_Ch6 is\n    --  formals created for build-in-place functions. The order of the above\n    --  enumeration literals matches the order in which the formals are\n    --  declared. See Sem_Ch6.Create_Extra_Formals.\n+\n      (BIP_Alloc_Form,\n       --  Present if result subtype is unconstrained, or if the result type\n       --  is tagged. Indicates whether the return object is allocated by the\n       --  caller or callee, and if the callee, whether to use the secondary\n       --  stack or the heap. See Create_Extra_Formals.\n-      BIP_Final_List,\n+\n+      BIP_Collection,\n       --  Present if result type needs finalization. Pointer to caller's\n-      --  finalization list.\n+      --  finalization collection.\n+\n       BIP_Master,\n       --  Present if result type contains tasks. Master associated with\n       --  calling context.\n+\n       BIP_Activation_Chain,\n       --  Present if result type contains tasks. Caller's activation chain\n+\n       BIP_Object_Access);\n       --  Present for all build-in-place functions. Address at which to place\n-      --  the return object, or null if BIP_Alloc_Form indicates\n-      --  allocated by callee.\n+      --  the return object, or null if BIP_Alloc_Form indicates allocated by\n+      --  callee.\n       --  ??? We also need to be able to pass in some way to access a\n       --  user-defined storage pool at some point. And perhaps a constrained\n       --  flag.\n@@ -158,9 +163,8 @@ package Exp_Ch6 is\n    --  for which Is_Build_In_Place_Call is True, or an N_Qualified_Expression\n    --  node applied to such a function call.\n \n-   function Needs_BIP_Final_List (E : Entity_Id) return Boolean;\n-   --  ???pragma Precondition (Is_Build_In_Place_Function (E));\n-   --  Ada 2005 (AI-318-02): Returns True if the function needs the\n-   --  BIP_Final_List implicit parameter.\n+   function Needs_BIP_Collection (Func_Id : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-318-02): Return True if the function needs a finalization\n+   --  collection implicit parameter.\n \n end Exp_Ch6;"}, {"sha": "4fd7d2a7ac1781749392e4d0604c7e877a6e0c09", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 6411, "deletions": 2494, "changes": 8905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008"}, {"sha": "9aa7b0a1192ef07bd8f072f6936f977f92d93172", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 79, "deletions": 112, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,27 +35,41 @@ package Exp_Ch7 is\n    -- Finalization Management --\n    -----------------------------\n \n-   function In_Finalization_Root (E : Entity_Id) return Boolean;\n-   --  True if current scope is in package System.Finalization_Root. Used\n-   --  to avoid certain expansions that would involve circularity in the\n-   --  Rtsfind mechanism.\n-\n-   procedure Build_Final_List (N : Node_Id; Typ : Entity_Id);\n-   --  Build finalization list for anonymous access types, and for access\n-   --  types that are frozen before their designated types are known to\n-   --  be controlled.\n-\n    procedure Build_Controlling_Procs (Typ : Entity_Id);\n    --  Typ is a record, and array type having controlled components.\n    --  Create the procedures Deep_Initialize, Deep_Adjust and Deep_Finalize\n    --  that take care of finalization management at run-time.\n \n+   procedure Build_Finalization_Collection\n+     (Typ        : Entity_Id;\n+      Ins_Node   : Node_Id := Empty;\n+      Encl_Scope : Entity_Id := Empty);\n+   --  Build a finalization collection for an access type. The designated type\n+   --  may not necessarely be controlled or need finalization actions. The\n+   --  routine creates a wrapper around a user-defined storage pool or the\n+   --  general storage pool for access types. Ins_Nod and Encl_Scope are used\n+   --  in conjunction with anonymous access types. Ins_Node designates the\n+   --  insertion point before which the collection should be added. Encl_Scope\n+   --  is the scope of the context, either the enclosing record or the scope\n+   --  of the related function.\n+\n    procedure Build_Late_Proc (Typ : Entity_Id; Nam : Name_Id);\n    --  Build one controlling procedure when a late body overrides one of\n    --  the controlling operations.\n \n-   function Controller_Component (Typ : Entity_Id) return Entity_Id;\n-   --  Returns the entity of the component whose name is 'Name_uController'\n+   function Build_Raise_Statement\n+     (Loc  : Source_Ptr;\n+      E_Id : Entity_Id;\n+      R_Id : Entity_Id) return Node_Id;\n+   --  Subsidiary to routines Build_Finalizer, Make_Deep_Array_Body and Make_\n+   --  Deep_Record_Body. Generate the following conditional raise statement:\n+   --\n+   --    if R_Id then\n+   --       Raise_From_Controlled_Operation (E_Id);\n+   --    end if;\n+   --\n+   --  E_Id denotes the defining identifier of a local exception occurrence,\n+   --  R_Id is the entity of a local boolean flag.\n \n    function CW_Or_Has_Controlled_Part (T : Entity_Id) return Boolean;\n    --  True if T is a class-wide type, or if it has controlled parts (\"part\"\n@@ -64,113 +78,68 @@ package Exp_Ch7 is\n    --  applies, in which case we know that class-wide objects do not contain\n    --  controlled parts.\n \n-   procedure Expand_Ctrl_Function_Call (N : Node_Id);\n-   --  Expand a call to a function returning a controlled value. That is to\n-   --  say attach the result of the call to the current finalization list,\n-   --  which is the one of the transient scope created for such constructs.\n-\n-   function Find_Final_List\n-     (E   : Entity_Id;\n-      Ref : Node_Id := Empty) return Node_Id;\n-   --  E is an entity representing a controlled object, a controlled type or a\n-   --  scope. If Ref is not empty, it is a reference to a controlled record,\n-   --  the closest Final list is in the controller component of the record\n-   --  containing Ref, otherwise this function returns a reference to the final\n-   --  list attached to the closest dynamic scope (which can be E itself),\n-   --  creating this final list if necessary.\n-\n    function Has_New_Controlled_Component (E : Entity_Id) return Boolean;\n    --  E is a type entity. Give the same result as Has_Controlled_Component\n    --  except for tagged extensions where the result is True only if the\n    --  latest extension contains a controlled component.\n \n-   function Make_Attach_Call\n-     (Obj_Ref     : Node_Id;\n-      Flist_Ref   : Node_Id;\n-      With_Attach : Node_Id) return Node_Id;\n-   --  Attach the referenced object to the referenced Final Chain 'Flist_Ref'\n-   --  With_Attach is an expression of type Short_Short_Integer which can be\n-   --  either '0' to signify no attachment, '1' for attachment to a simply\n-   --  linked list or '2' for attachment to a doubly linked list.\n-\n-   function Make_Init_Call\n-     (Ref         : Node_Id;\n-      Typ         : Entity_Id;\n-      Flist_Ref   : Node_Id;\n-      With_Attach : Node_Id) return List_Id;\n-   --  Ref is an expression (with no-side effect and is not required to have\n-   --  been previously analyzed) that references the object to be initialized.\n-   --  Typ is the expected type of Ref, which is either a controlled type\n-   --  (Is_Controlled) or a type with controlled components (Has_Controlled).\n-   --  With_Attach is an integer expression which is the attachment level,\n-   --  see System.Finalization_Implementation.Attach_To_Final_List for the\n-   --  documentation of Nb_Link.\n-   --\n-   --  This function will generate the appropriate calls to make sure that the\n-   --  objects referenced by Ref are initialized. The generated code is quite\n-   --  different for an IS_Controlled type or a HAS_Controlled type, but this\n-   --  is not the problem for the caller, the details are in the body.\n-\n    function Make_Adjust_Call\n-     (Ref         : Node_Id;\n-      Typ         : Entity_Id;\n-      Flist_Ref   : Node_Id;\n-      With_Attach : Node_Id;\n-      Allocator   : Boolean := False) return List_Id;\n-   --  Ref is an expression (with no-side effect and is not required to have\n-   --  been previously analyzed) that references the object to be adjusted. Typ\n-   --  is the expected type of Ref, which is a controlled type (Is_Controlled)\n-   --  or a type with controlled components (Has_Controlled). With_Attach is an\n-   --  integer expression giving the attachment level (see documentation of\n-   --  Attach_To_Final_List.Nb_Link param documentation in s-finimp.ads.\n-   --  Note: if Typ is Finalize_Storage_Only and the object is at library\n-   --  level, then With_Attach will be ignored, and a zero link level will be\n-   --  passed to Attach_To_Final_List.\n-   --\n-   --  This function will generate the appropriate calls to make sure that the\n-   --  objects referenced by Ref are adjusted. The generated code is quite\n-   --  different depending on the fact the type IS_Controlled or HAS_Controlled\n-   --  but this is not the problem of the caller, the details are in the body.\n-   --  The objects must be attached when the adjust takes place after an\n-   --  initialization expression but not when it takes place after a regular\n-   --  assignment.\n-   --\n-   --  If Allocator is True, we are adjusting a newly-created object. The\n-   --  existing chaining pointers should not be left unchanged, because they\n-   --  may come from a bit-for-bit copy of those from an initializing object.\n-   --  So, when this flag is True, if the chaining pointers should otherwise\n-   --  be left unset, instead they are reset to null.\n+     (Obj_Ref    : Node_Id;\n+      Typ        : Entity_Id;\n+      For_Parent : Boolean := False) return Node_Id;\n+   --  Create a call to either Adjust or Deep_Adjust depending on the structure\n+   --  of type Typ. Obj_Ref is an expression with no-side effect (not required\n+   --  to have been previously analyzed) that references the object to be\n+   --  adjusted. Typ is the expected type of Obj_Ref. Flag For_Parent must be\n+   --  set when an adjustment call is being created for field _parent.\n \n    function Make_Final_Call\n-     (Ref         : Node_Id;\n-      Typ         : Entity_Id;\n-      With_Detach : Node_Id) return List_Id;\n-   --  Ref is an expression (with no-side effect and is not required to have\n-   --  been previously analyzed) that references the object to be Finalized.\n-   --  Typ is the expected type of Ref, which is a controlled type\n-   --  (Is_Controlled) or a type with controlled components (Has_Controlled).\n-   --  With_Detach is a boolean expression indicating whether to detach the\n-   --  controlled object from whatever finalization list it is currently\n-   --  attached to.\n-   --\n-   --  This function will generate the appropriate calls to make sure that the\n-   --  objects referenced by Ref are finalized. The generated code is quite\n-   --  different depending on the fact the type IS_Controlled or HAS_Controlled\n-   --  but this is not the problem of the caller, the details are in the body.\n-   --  The objects must be detached when finalizing an unchecked deallocated\n-   --  object but not when finalizing the target of an assignment, it is not\n-   --  necessary either on scope exit.\n+     (Obj_Ref    : Node_Id;\n+      Typ        : Entity_Id;\n+      For_Parent : Boolean := False) return Node_Id;\n+   --  Create a call to either Finalize or Deep_Finalize depending on the\n+   --  structure of type Typ. Obj_Ref is an expression (with no-side effect and\n+   --  is not required to have been previously analyzed) that references the\n+   --  object to be finalized. Typ is the expected type of Obj_Ref. Flag For_\n+   --  Parent must be set when a finalization call is being created for field\n+   --  _parent.\n+\n+   procedure Make_Finalize_Address_Body (Typ : Entity_Id);\n+   --  Create the body of TSS routine Finalize_Address if Typ is controlled and\n+   --  does not have a TSS entry for Finalize_Address. The procedure converts\n+   --  an address into a pointer and subsequently calls Deep_Finalize on the\n+   --  dereference.\n+\n+   function Make_Init_Call\n+     (Obj_Ref : Node_Id;\n+      Typ     : Entity_Id) return Node_Id;\n+   --  Obj_Ref is an expression with no-side effect (not required to have been\n+   --  previously analyzed) that references the object to be initialized. Typ\n+   --  is the expected type of Obj_Ref, which is either a controlled type\n+   --  (Is_Controlled) or a type with controlled components (Has_Controlled_\n+   --  Components).\n \n    function Make_Handler_For_Ctrl_Operation (Loc : Source_Ptr) return Node_Id;\n    --  Generate an implicit exception handler with an 'others' choice,\n    --  converting any occurrence to a raise of Program_Error.\n \n-   function Needs_Finalization (T : Entity_Id) return Boolean;\n-   --  True if T potentially needs finalization actions. True if T is\n-   --  controlled, or has subcomponents. Also True if T is a class-wide type,\n-   --  because some type extension might add controlled subcomponents, except\n-   --  that if pragma Restrictions (No_Finalization) applies, this is False for\n-   --  class-wide types.\n+   function Make_Local_Deep_Finalize\n+     (Typ : Entity_Id;\n+      Nam : Entity_Id) return Node_Id;\n+   --  Create a special version of Deep_Finalize with identifier Nam. The\n+   --  routine has state information and can parform partial finalization.\n+\n+   function Make_Set_Finalize_Address_Ptr_Call\n+     (Loc     : Source_Ptr;\n+      Typ     : Entity_Id;\n+      Ptr_Typ : Entity_Id) return Node_Id;\n+   --  Generate the following call:\n+   --\n+   --    Set_Finalize_Address_Ptr (<Ptr_Typ>FC, <Typ>FD'Unrestricted_Access);\n+   --\n+   --  where Finalize_Address is the corresponding TSS primitive of type Typ\n+   --  and Ptr_Typ is the access type of the related allocation. Loc is the\n+   --  source location of the related allocator.\n \n    --------------------------------------------\n    -- Task and Protected Object finalization --\n@@ -204,10 +173,8 @@ package Exp_Ch7 is\n    --  Check whether composite type contains a simple protected component\n \n    function Is_Simple_Protected_Type (T : Entity_Id) return Boolean;\n-   --  Check whether argument is a protected type without entries. Protected\n-   --  types with entries are controlled, and their cleanup is handled by the\n-   --  standard finalization machinery. For simple protected types we generate\n-   --  inline code to release their locks.\n+   --  Determine whether T denotes a protected type without entires whose\n+   --  _object field is of type System.Tasking.Protected_Objects.Protection.\n \n    --------------------------------\n    -- Transient Scope Management --\n@@ -225,7 +192,7 @@ package Exp_Ch7 is\n    --  secondary stack is brought in, otherwise it isn't.\n \n    function Node_To_Be_Wrapped return Node_Id;\n-   --  return the node to be wrapped if the current scope is transient\n+   --  Return the node to be wrapped if the current scope is transient\n \n    procedure Store_Before_Actions_In_Scope (L : List_Id);\n    --  Append the list L of actions to the end of the before-actions store in"}, {"sha": "d12c92c80d58dbe844ff204605792e270a38cd34", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 4, "deletions": 58, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -745,8 +745,8 @@ package body Exp_Ch9 is\n             Obj_Ptr,\n           Type_Definition =>\n             Make_Access_To_Object_Definition (Loc,\n-          Subtype_Indication =>\n-            New_Reference_To (Rec_Typ, Loc)));\n+              Subtype_Indication =>\n+                New_Reference_To (Rec_Typ, Loc)));\n       Set_Debug_Info_Needed (Defining_Identifier (Decl));\n       Prepend_To (Decls, Decl);\n    end Add_Object_Pointer;\n@@ -1039,7 +1039,7 @@ package body Exp_Ch9 is\n       --     for the task body.\n \n       --  In fact the discriminals b) are used in the renaming declarations\n-      --  for e). See details in  einfo (Handling of Discriminants).\n+      --  for e). See details in einfo (Handling of Discriminants).\n \n       if Present (Discriminant_Specifications (N)) then\n          Dlist := New_List;\n@@ -1185,10 +1185,6 @@ package body Exp_Ch9 is\n       --  Generate the call to the runtime routine Set_Entry_Name with actuals\n       --  _init._task_id or _init._object, Inn and Arg3.\n \n-      function Find_Protection_Type (Conc_Typ : Entity_Id) return Entity_Id;\n-      --  Given a protected type or its corresponding record, find the type of\n-      --  field _object.\n-\n       procedure Increment_Index (Stmts : List_Id);\n       --  Generate the following and add it to Stmts\n       --    Inn := Inn + 1;\n@@ -1367,34 +1363,6 @@ package body Exp_Ch9 is\n                Arg3));                                    --  Val\n       end Build_Set_Entry_Name_Call;\n \n-      --------------------------\n-      -- Find_Protection_Type --\n-      --------------------------\n-\n-      function Find_Protection_Type (Conc_Typ : Entity_Id) return Entity_Id is\n-         Comp : Entity_Id;\n-         Typ  : Entity_Id := Conc_Typ;\n-\n-      begin\n-         if Is_Concurrent_Type (Typ) then\n-            Typ := Corresponding_Record_Type (Typ);\n-         end if;\n-\n-         Comp := First_Component (Typ);\n-         while Present (Comp) loop\n-            if Chars (Comp) = Name_uObject then\n-               return Base_Type (Etype (Comp));\n-            end if;\n-\n-            Next_Component (Comp);\n-         end loop;\n-\n-         --  The corresponding record of a protected type should always have an\n-         --  _object field.\n-\n-         raise Program_Error;\n-      end Find_Protection_Type;\n-\n       ---------------------\n       -- Increment_Index --\n       ---------------------\n@@ -7446,9 +7414,6 @@ package body Exp_Ch9 is\n       Op_Body      : Node_Id;\n       Op_Id        : Entity_Id;\n \n-      Chain        : Entity_Id := Empty;\n-      --  Finalization chain that may be attached to new body\n-\n       function Build_Dispatching_Subprogram_Body\n         (N        : Node_Id;\n          Pid      : Node_Id;\n@@ -7573,25 +7538,6 @@ package body Exp_Ch9 is\n                   New_Op_Body :=\n                     Build_Unprotected_Subprogram_Body (Op_Body, Pid);\n \n-                  --  Propagate the finalization chain to the new body. In the\n-                  --  unlikely event that the subprogram contains a declaration\n-                  --  or allocator for an object that requires finalization,\n-                  --  the corresponding chain is created when analyzing the\n-                  --  body, and attached to its entity. This entity is not\n-                  --  further elaborated, and so the chain properly belongs to\n-                  --  the newly created subprogram body.\n-\n-                  Chain :=\n-                    Finalization_Chain_Entity (Defining_Entity (Op_Body));\n-\n-                  if Present (Chain) then\n-                     Set_Finalization_Chain_Entity\n-                       (Protected_Body_Subprogram\n-                         (Corresponding_Spec (Op_Body)), Chain);\n-                     Set_Analyzed\n-                         (Handled_Statement_Sequence (New_Op_Body), False);\n-                  end if;\n-\n                   Insert_After (Current_Node, New_Op_Body);\n                   Current_Node := New_Op_Body;\n                   Analyze (New_Op_Body);\n@@ -8223,7 +8169,7 @@ package body Exp_Ch9 is\n             Set_Protected_Body_Subprogram\n               (Defining_Unit_Name (Specification (Comp)),\n                Defining_Unit_Name (Specification (Sub)));\n-               Check_Inlining (Defining_Unit_Name (Specification (Comp)));\n+            Check_Inlining (Defining_Unit_Name (Specification (Comp)));\n \n             --  Make the protected version of the subprogram available for\n             --  expansion of external calls."}, {"sha": "60711df9c48b36b4f262604ddab4add47da25f36", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 6, "deletions": 54, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -31,7 +31,6 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Atag; use Exp_Atag;\n with Exp_Ch6;  use Exp_Ch6;\n-with Exp_Ch7;  use Exp_Ch7;\n with Exp_CG;   use Exp_CG;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Tss;  use Exp_Tss;\n@@ -4901,7 +4900,7 @@ package body Exp_Disp is\n       --            HT_Link            => HT_Link'Address,\n       --            Transportable      => <<boolean-value>>,\n       --            Type_Is_Abstract   => <<boolean-value>>,\n-      --            RC_Offset          => <<integer-value>>,\n+      --            Needs_Finalization => <<boolean-value>>,\n       --            [ Size_Func         => Size_Prim'Access ]\n       --            [ Interfaces_Table  => <<access-value>> ]\n       --            [ SSD               => SSD_Table'Address ]\n@@ -5183,62 +5182,15 @@ package body Exp_Disp is\n          end;\n       end if;\n \n-      --  RC_Offset: These are the valid values and their meaning:\n-\n-      --   >0: For simple types with controlled components is\n-      --         type._record_controller'position\n-\n-      --    0: For types with no controlled components\n-\n-      --   -1: For complex types with controlled components where the position\n-      --       of the record controller is not statically computable but there\n-      --       are controlled components at this level. The _Controller field\n-      --       is available right after the _parent.\n-\n-      --   -2: There are no controlled components at this level. We need to\n-      --       get the position from the parent.\n+      --  Needs_Finalization: Set if the type is controlled or has controlled\n+      --  components.\n \n       declare\n-         RC_Offset_Node : Node_Id;\n+         Needs_Fin : Entity_Id;\n \n       begin\n-         if not Has_Controlled_Component (Typ) then\n-            RC_Offset_Node := Make_Integer_Literal (Loc, 0);\n-\n-         elsif Etype (Typ) /= Typ\n-           and then Has_Discriminants (Parent_Typ)\n-         then\n-            if Has_New_Controlled_Component (Typ) then\n-               RC_Offset_Node := Make_Integer_Literal (Loc, -1);\n-            else\n-               RC_Offset_Node := Make_Integer_Literal (Loc, -2);\n-            end if;\n-         else\n-            RC_Offset_Node :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix => New_Reference_To (Typ, Loc),\n-                    Selector_Name =>\n-                      New_Reference_To (Controller_Component (Typ), Loc)),\n-                Attribute_Name => Name_Position);\n-\n-            --  This is not proper Ada code to use the attribute 'Position\n-            --  on something else than an object but this is supported by\n-            --  the back end (see comment on the Bit_Component attribute in\n-            --  sem_attr). So we avoid semantic checking here.\n-\n-            --  Is this documented in sinfo.ads??? it should be!\n-\n-            Set_Analyzed (RC_Offset_Node);\n-            Set_Etype (Prefix (RC_Offset_Node), RTE (RE_Record_Controller));\n-            Set_Etype (Prefix (Prefix (RC_Offset_Node)), Typ);\n-            Set_Etype (Selector_Name (Prefix (RC_Offset_Node)),\n-              RTE (RE_Record_Controller));\n-            Set_Etype (RC_Offset_Node, RTE (RE_Storage_Offset));\n-         end if;\n-\n-         Append_To (TSD_Aggr_List, RC_Offset_Node);\n+         Needs_Fin := Boolean_Literals (Needs_Finalization (Typ));\n+         Append_To (TSD_Aggr_List, New_Occurrence_Of (Needs_Fin, Loc));\n       end;\n \n       --  Size_Func"}, {"sha": "b858c97fc6e8513f0f9e9f3df9231f4b4fef0b7a", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 114, "deletions": 22, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -875,20 +875,24 @@ package body Exp_Intr is\n    --  structures to find and terminate those components.\n \n    procedure Expand_Unc_Deallocation (N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Arg   : constant Node_Id    := First_Actual (N);\n-      Typ   : constant Entity_Id  := Etype (Arg);\n-      Stmts : constant List_Id    := New_List;\n-      Rtyp  : constant Entity_Id  := Underlying_Type (Root_Type (Typ));\n-      Pool  : constant Entity_Id  := Associated_Storage_Pool (Rtyp);\n-\n-      Desig_T   : constant Entity_Id := Designated_Type (Typ);\n-      Gen_Code  : Node_Id;\n-      Free_Node : Node_Id;\n-      Deref     : Node_Id;\n-      Free_Arg  : Node_Id;\n-      Free_Cod  : List_Id;\n-      Blk       : Node_Id;\n+      Arg     : constant Node_Id    := First_Actual (N);\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Typ     : constant Entity_Id  := Etype (Arg);\n+      Desig_T : constant Entity_Id  := Designated_Type (Typ);\n+      Rtyp    : constant Entity_Id  := Underlying_Type (Root_Type (Typ));\n+      Pool    : constant Entity_Id  := Associated_Storage_Pool (Rtyp);\n+      Stmts   : constant List_Id    := New_List;\n+\n+      Blk          : Node_Id;\n+      Deref        : Node_Id;\n+      Exc_Occ_Decl : Node_Id;\n+      Exc_Occ_Id   : Entity_Id := Empty;\n+      Final_Code   : List_Id;\n+      Free_Arg     : Node_Id;\n+      Free_Node    : Node_Id;\n+      Gen_Code     : Node_Id;\n+      Raised_Decl  : Node_Id;\n+      Raised_Id    : Entity_Id := Empty;\n \n       Arg_Known_Non_Null : constant Boolean := Known_Non_Null (N);\n       --  This captures whether we know the argument to be non-null so that\n@@ -929,20 +933,93 @@ package body Exp_Intr is\n             Set_Etype (Deref, Desig_T);\n          end if;\n \n-         Free_Cod :=\n-           Make_Final_Call\n-            (Ref         => Deref,\n-             Typ         => Desig_T,\n-             With_Detach => New_Reference_To (Standard_True, Loc));\n+         --  The finalization call is expanded wrapped in a block to catch any\n+         --  possible exception. If an exception does occur, then Program_Error\n+         --  must be raised following the freeing of the object and its removal\n+         --  from the finalization collection's list. We set a flag to record\n+         --  that an exception was raised, and save its occurrence for use in\n+         --  the later raise.\n+         --\n+         --  Generate:\n+         --    Raised  : Boolean := False;\n+         --    Exc_Occ : Exception_Occurrence;\n+         --\n+         --    begin\n+         --       [Deep_]Finalize (Obj);\n+         --    exception\n+         --       when others =>\n+         --          Raised := True;\n+         --          Save_Occurrence (Exc_Occ, Get_Current_Excep.all.all);\n+         --    end;\n+\n+         Exc_Occ_Id := Make_Temporary (Loc, 'E');\n+         Raised_Id  := Make_Temporary (Loc, 'R');\n+\n+         Raised_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Raised_Id,\n+             Object_Definition =>\n+               New_Reference_To (Standard_Boolean, Loc),\n+             Expression =>\n+               New_Reference_To (Standard_False, Loc));\n+\n+         Append_To (Stmts, Raised_Decl);\n+         Analyze (Raised_Decl);\n+\n+         Exc_Occ_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Exc_Occ_Id,\n+           Object_Definition =>\n+             New_Reference_To (RTE (RE_Exception_Occurrence), Loc));\n+         Set_No_Initialization (Exc_Occ_Decl);\n+\n+         Append_To (Stmts, Exc_Occ_Decl);\n+         Analyze (Exc_Occ_Decl);\n+\n+         Final_Code := New_List (\n+           Make_Block_Statement (Loc,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Make_Final_Call (\n+                     Obj_Ref => Deref,\n+                     Typ     => Desig_T)),\n+                 Exception_Handlers => New_List (\n+                   Make_Exception_Handler (Loc,\n+                     Exception_Choices => New_List (\n+                       Make_Others_Choice (Loc)),\n+                     Statements => New_List (\n+                       Make_Assignment_Statement (Loc,\n+                         Name =>\n+                           New_Reference_To (Raised_Id, Loc),\n+                         Expression =>\n+                           New_Reference_To (Standard_True, Loc)),\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name =>\n+                           New_Reference_To (RTE (RE_Save_Occurrence), Loc),\n+                         Parameter_Associations => New_List (\n+                           New_Reference_To (Exc_Occ_Id, Loc),\n+                           Make_Explicit_Dereference (Loc,\n+                             Prefix =>\n+                               Make_Function_Call (Loc,\n+                                 Name =>\n+                                   Make_Explicit_Dereference (Loc,\n+                                     Prefix =>\n+                                       New_Reference_To\n+                                         (RTE (RE_Get_Current_Excep),\n+                                          Loc))))))))))));\n+\n+         --  If aborts are allowed, then the finalization code must be\n+         --  protected by an abort defer/undefer pair.\n \n          if Abort_Allowed then\n-            Prepend_To (Free_Cod,\n+            Prepend_To (Final_Code,\n               Build_Runtime_Call (Loc, RE_Abort_Defer));\n \n             Blk :=\n               Make_Block_Statement (Loc, Handled_Statement_Sequence =>\n                 Make_Handled_Sequence_Of_Statements (Loc,\n-                  Statements  => Free_Cod,\n+                  Statements  => Final_Code,\n                   At_End_Proc =>\n                     New_Occurrence_Of (RTE (RE_Abort_Undefer_Direct), Loc)));\n \n@@ -962,7 +1039,7 @@ package body Exp_Intr is\n             Kill_Current_Values;\n \n          else\n-            Append_List_To (Stmts, Free_Cod);\n+            Append_List_To (Stmts, Final_Code);\n          end if;\n       end if;\n \n@@ -1167,6 +1244,21 @@ package body Exp_Intr is\n          end;\n       end if;\n \n+      --  Generate a test of whether any earlier finalization raised an\n+      --  exception, and in that case raise Program_Error with the previous\n+      --  exception occurrence.\n+      --\n+      --  Generate:\n+      --    if Raised then\n+      --       Reraise_Occurrence (Exc_Occ);               --  for .NET\n+      --         <or>\n+      --       Raise_From_Controlled_Operation (Exc_Occ);  --  all other cases\n+      --    end if;\n+\n+      if Present (Raised_Id) then\n+         Append_To (Stmts, Build_Raise_Statement (Loc, Exc_Occ_Id, Raised_Id));\n+      end if;\n+\n       --  If we know the argument is non-null, then make a block statement\n       --  that contains the required statements, no need for a test.\n "}, {"sha": "0f365e29fe984ab2c9fce93ad544182742696cbb", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -1198,13 +1198,14 @@ package body Exp_Strm is\n              Return_Object_Declarations => New_List (Obj_Decl),\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n-                 New_List (Make_Attribute_Reference (Loc,\n-                             Prefix => New_Occurrence_Of (Typ, Loc),\n-                             Attribute_Name => Name_Read,\n-                             Expressions => New_List (\n-                               Make_Identifier (Loc, Name_S),\n-                               Make_Identifier (Loc, Name_V)))))));\n-\n+                 Statements => New_List (\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix =>\n+                       New_Occurrence_Of (Typ, Loc),\n+                     Attribute_Name => Name_Read,\n+                     Expressions => New_List (\n+                       Make_Identifier (Loc, Name_S),\n+                       Make_Identifier (Loc, Name_V)))))));\n       else\n          Append_To (Decls, Obj_Decl);\n "}, {"sha": "0fd967edd14fb8bd2d32bffb43fc39dc437bd053", "filename": "gcc/ada/exp_tss.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_tss.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_tss.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -82,6 +82,7 @@ package Exp_Tss is\n    TSS_Deep_Finalize      : constant TNT := \"DF\";  -- Deep Finalize\n    TSS_Deep_Initialize    : constant TNT := \"DI\";  -- Deep Initialize\n    TSS_Composite_Equality : constant TNT := \"EQ\";  -- Composite Equality\n+   TSS_Finalize_Address   : constant TNT := \"FD\";  -- Finalize Address\n    TSS_From_Any           : constant TNT := \"FA\";  -- PolyORB/DSA From_Any\n    TSS_Init_Proc          : constant TNT := \"IP\";  -- Initialization Procedure\n    TSS_CPP_Init_Proc      : constant TNT := \"IC\";  -- Init C++ dispatch tables\n@@ -103,6 +104,7 @@ package Exp_Tss is\n       TSS_Deep_Finalize,\n       TSS_Deep_Initialize,\n       TSS_Composite_Equality,\n+      TSS_Finalize_Address,\n       TSS_From_Any,\n       TSS_Init_Proc,\n       TSS_CPP_Init_Proc,"}, {"sha": "9388e664a0cbf37188cbf12b5d011b27e567fbd8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1079, "deletions": 38, "changes": 1117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -312,6 +312,320 @@ package body Exp_Util is\n       end if;\n    end Append_Freeze_Actions;\n \n+   ------------------------------------\n+   -- Build_Allocate_Deallocate_Proc --\n+   ------------------------------------\n+\n+   procedure Build_Allocate_Deallocate_Proc\n+     (N           : Node_Id;\n+      Is_Allocate : Boolean)\n+   is\n+      Expr      : constant Node_Id   := Expression (N);\n+      Ptr_Typ   : constant Entity_Id := Etype (Expr);\n+      Desig_Typ : constant Entity_Id :=\n+                    Available_View (Designated_Type (Ptr_Typ));\n+\n+      function Find_Object (E : Node_Id) return Node_Id;\n+      --  Given an arbitrary expression of an allocator, try to find an object\n+      --  reference in it, otherwise return the original expression.\n+\n+      function Is_Allocate_Deallocate_Proc (Subp : Entity_Id) return Boolean;\n+      --  Determine whether subprogram Subp denotes a custom allocate or\n+      --  deallocate.\n+\n+      -----------------\n+      -- Find_Object --\n+      -----------------\n+\n+      function Find_Object (E : Node_Id) return Node_Id is\n+         Expr   : Node_Id := E;\n+         Change : Boolean := True;\n+\n+      begin\n+         pragma Assert (Is_Allocate);\n+\n+         while Change loop\n+            Change := False;\n+\n+            if Nkind_In (Expr, N_Qualified_Expression,\n+                               N_Unchecked_Type_Conversion)\n+            then\n+               Expr   := Expression (Expr);\n+               Change := True;\n+\n+            elsif Nkind (Expr) = N_Explicit_Dereference then\n+               Expr   := Prefix (Expr);\n+               Change := True;\n+            end if;\n+         end loop;\n+\n+         return Expr;\n+      end Find_Object;\n+\n+      ---------------------------------\n+      -- Is_Allocate_Deallocate_Proc --\n+      ---------------------------------\n+\n+      function Is_Allocate_Deallocate_Proc (Subp : Entity_Id) return Boolean is\n+      begin\n+         --  Look for a subprogram body with only one statement which is a\n+         --  call to one of the Allocate / Deallocate routines in package\n+         --  Ada.Finalization.Heap_Management.\n+\n+         if Ekind (Subp) = E_Procedure\n+           and then Nkind (Parent (Parent (Subp))) = N_Subprogram_Body\n+         then\n+            declare\n+               HSS  : constant Node_Id :=\n+                        Handled_Statement_Sequence (Parent (Parent (Subp)));\n+               Proc : Entity_Id;\n+\n+            begin\n+               if Present (Statements (HSS))\n+                 and then Nkind (First (Statements (HSS))) =\n+                            N_Procedure_Call_Statement\n+               then\n+                  Proc := Entity (Name (First (Statements (HSS))));\n+\n+                  return\n+                    Is_RTE (Proc, RE_Allocate)\n+                      or else Is_RTE (Proc, RE_Deallocate);\n+               end if;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Is_Allocate_Deallocate_Proc;\n+\n+   --  Start of processing for Build_Allocate_Deallocate_Proc\n+\n+   begin\n+      --  The allocation / deallocation of a non-controlled object does not\n+      --  need the machinery created by this routine.\n+\n+      if not Needs_Finalization (Desig_Typ) then\n+         return;\n+\n+      --  The allocator or free statmenet has already been expanded and already\n+      --  has a custom Allocate / Deallocate routine.\n+\n+      elsif Nkind (Expr) = N_Allocator\n+        and then Present (Procedure_To_Call (Expr))\n+        and then Is_Allocate_Deallocate_Proc (Procedure_To_Call (Expr))\n+      then\n+         return;\n+      end if;\n+\n+      declare\n+         Loc     : constant Source_Ptr := Sloc (N);\n+         Addr_Id : constant Entity_Id := Make_Temporary (Loc, 'A');\n+         Alig_Id : constant Entity_Id := Make_Temporary (Loc, 'L');\n+         Proc_Id : constant Entity_Id := Make_Temporary (Loc, 'P');\n+         Size_Id : constant Entity_Id := Make_Temporary (Loc, 'S');\n+\n+         Actuals      : List_Id;\n+         Collect_Act  : Node_Id;\n+         Collect_Id   : Entity_Id;\n+         Collect_Typ  : Entity_Id;\n+         Proc_To_Call : Entity_Id;\n+\n+      begin\n+         --  When dealing with an access subtype, use the collection of the\n+         --  base type.\n+\n+         if Ekind (Ptr_Typ) = E_Access_Subtype then\n+            Collect_Typ := Base_Type (Ptr_Typ);\n+         else\n+            Collect_Typ := Ptr_Typ;\n+         end if;\n+\n+         Collect_Id  := Associated_Collection (Collect_Typ);\n+         Collect_Act := New_Reference_To (Collect_Id, Loc);\n+\n+         --  Handle the case where the collection is actually a pointer to a\n+         --  collection. This case arises in build-in-place functions.\n+\n+         if Is_Access_Type (Etype (Collect_Id)) then\n+            Collect_Act :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => Collect_Act);\n+         end if;\n+\n+         --  Create the actuals for the call to Allocate / Deallocate\n+\n+         Actuals := New_List (\n+           Collect_Act,\n+           New_Reference_To (Addr_Id, Loc),\n+           New_Reference_To (Size_Id, Loc),\n+           New_Reference_To (Alig_Id, Loc));\n+\n+         --  Generate a run-time check to determine whether a class-wide object\n+         --  is truly controlled.\n+\n+         if Is_Class_Wide_Type (Desig_Typ)\n+           or else Is_Generic_Actual_Type (Desig_Typ)\n+         then\n+            declare\n+               Flag_Id   : constant Entity_Id := Make_Temporary (Loc, 'F');\n+               Flag_Expr : Node_Id;\n+               Param     : Node_Id;\n+               Temp      : Node_Id;\n+\n+            begin\n+               if Is_Allocate then\n+                  Temp := Find_Object (Expression (Expr));\n+               else\n+                  Temp := Expr;\n+               end if;\n+\n+               --  Processing for generic actuals\n+\n+               if Is_Generic_Actual_Type (Desig_Typ) then\n+                  Flag_Expr :=\n+                    New_Reference_To (Boolean_Literals\n+                      (Needs_Finalization (Base_Type (Desig_Typ))), Loc);\n+\n+               --  Processing for subtype indications\n+\n+               elsif Nkind (Temp) in N_Has_Entity\n+                 and then Is_Type (Entity (Temp))\n+               then\n+                  Flag_Expr :=\n+                    New_Reference_To (Boolean_Literals\n+                      (Needs_Finalization (Entity (Temp))), Loc);\n+\n+               --  Generate a runtime check to test the controlled state of an\n+               --  object for the purposes of allocation / deallocation.\n+\n+               else\n+                  --  The following case arises when allocating through an\n+                  --  interface class-wide type, generate:\n+                  --\n+                  --    Temp.all\n+\n+                  if Is_RTE (Etype (Temp), RE_Tag_Ptr) then\n+                     Param :=\n+                       Make_Explicit_Dereference (Loc,\n+                         Prefix =>\n+                           Relocate_Node (Temp));\n+\n+                  --  Generate:\n+                  --    Temp'Tag\n+\n+                  else\n+                     Param :=\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix =>\n+                           Relocate_Node (Temp),\n+                         Attribute_Name => Name_Tag);\n+                  end if;\n+\n+                  --  Generate:\n+                  --    Needs_Finalization (Param)\n+\n+                  Flag_Expr :=\n+                    Make_Function_Call (Loc,\n+                      Name =>\n+                        New_Reference_To (RTE (RE_Needs_Finalization), Loc),\n+                      Parameter_Associations => New_List (Param));\n+               end if;\n+\n+               --  Create the temporary which represents the finalization state\n+               --  of the expression. Generate:\n+               --\n+               --    F : constant Boolean := <Flag_Expr>;\n+\n+               Insert_Action (N,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Flag_Id,\n+                   Constant_Present => True,\n+                   Object_Definition =>\n+                     New_Reference_To (Standard_Boolean, Loc),\n+                   Expression => Flag_Expr));\n+\n+               --  The flag acts as the fifth actual\n+\n+               Append_To (Actuals, New_Reference_To (Flag_Id, Loc));\n+            end;\n+         end if;\n+\n+         --  Select the proper routine to call\n+\n+         if Is_Allocate then\n+            Proc_To_Call := RTE (RE_Allocate);\n+         else\n+            Proc_To_Call := RTE (RE_Deallocate);\n+         end if;\n+\n+         --  Create a custom Allocate / Deallocate routine which has identical\n+         --  profile to that of System.Storage_Pools.\n+\n+         Insert_Action (N,\n+           Make_Subprogram_Body (Loc,\n+             Specification =>\n+\n+               --  procedure Pnn\n+\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name => Proc_Id,\n+                 Parameter_Specifications => New_List (\n+\n+                  --  P : Root_Storage_Pool\n+\n+                   Make_Parameter_Specification (Loc,\n+                     Defining_Identifier =>\n+                       Make_Temporary (Loc, 'P'),\n+                     Parameter_Type =>\n+                       New_Reference_To (RTE (RE_Root_Storage_Pool), Loc)),\n+\n+                  --  A : [out] Address\n+\n+                   Make_Parameter_Specification (Loc,\n+                     Defining_Identifier => Addr_Id,\n+                     Out_Present => Is_Allocate,\n+                     Parameter_Type =>\n+                       New_Reference_To (RTE (RE_Address), Loc)),\n+\n+                  --  S : Storage_Count\n+\n+                   Make_Parameter_Specification (Loc,\n+                     Defining_Identifier => Size_Id,\n+                     Parameter_Type =>\n+                       New_Reference_To (RTE (RE_Storage_Count), Loc)),\n+\n+                  --  L : Storage_Count\n+\n+                   Make_Parameter_Specification (Loc,\n+                     Defining_Identifier => Alig_Id,\n+                     Parameter_Type =>\n+                       New_Reference_To (RTE (RE_Storage_Count), Loc)))),\n+\n+             Declarations => No_List,\n+\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+\n+                  --  Allocate / Deallocate\n+                  --    (<Ptr_Typ collection>, A, S, L[, F]);\n+\n+                   Make_Procedure_Call_Statement (Loc,\n+                     Name =>\n+                       New_Reference_To (Proc_To_Call, Loc),\n+                     Parameter_Associations => Actuals)))));\n+\n+         --  The newly generated Allocate / Deallocate becomes the default\n+         --  procedure to call when the back end processes the allocation /\n+         --  deallocation.\n+\n+         if Is_Allocate then\n+            Set_Procedure_To_Call (Expr, Proc_Id);\n+         else\n+            Set_Procedure_To_Call (N, Proc_Id);\n+         end if;\n+      end;\n+   end Build_Allocate_Deallocate_Proc;\n+\n    ------------------------\n    -- Build_Runtime_Call --\n    ------------------------\n@@ -1351,13 +1665,17 @@ package body Exp_Util is\n \n       --  Renamings of class-wide interface types require no equivalent\n       --  constrained type declarations because we only need to reference\n-      --  the tag component associated with the interface.\n+      --  the tag component associated with the interface. The same is\n+      --  presumably true for class-wide types in general, so this test\n+      --  is broadened to include all class-wide renamings, which also\n+      --  avoids cases of unbounded recursion in Remove_Side_Effects.\n+      --  (Is this really correct, or are there some cases of class-wide\n+      --  renamings that require action in this procedure???)\n \n       elsif Present (N)\n         and then Nkind (N) = N_Object_Renaming_Declaration\n-        and then Is_Interface (Unc_Type)\n+        and then Is_Class_Wide_Type (Unc_Type)\n       then\n-         pragma Assert (Is_Class_Wide_Type (Unc_Type));\n          null;\n \n       --  In Ada95 nothing to be done if the type of the expression is limited,\n@@ -1428,11 +1746,12 @@ package body Exp_Util is\n \n          while Present (Init_Call) and then Init_Call /= Rep_Clause loop\n             if Nkind (Init_Call) = N_Procedure_Call_Statement\n-                 and then Is_Entity_Name (Name (Init_Call))\n-                 and then Entity (Name (Init_Call)) = Init_Proc\n+              and then Is_Entity_Name (Name (Init_Call))\n+              and then Entity (Name (Init_Call)) = Init_Proc\n             then\n                return Init_Call;\n             end if;\n+\n             Next (Init_Call);\n          end loop;\n \n@@ -1461,8 +1780,8 @@ package body Exp_Util is\n       --  applying to Var).\n \n       if No (Init_Call) and then Present (Freeze_Node (Var)) then\n-         Init_Call := Find_Init_Call_In_List\n-                        (First (Actions (Freeze_Node (Var))));\n+         Init_Call :=\n+           Find_Init_Call_In_List (First (Actions (Freeze_Node (Var))));\n       end if;\n \n       return Init_Call;\n@@ -1701,8 +2020,11 @@ package body Exp_Util is\n      (T    : Entity_Id;\n       Name : TSS_Name_Type) return Entity_Id\n    is\n-      Prim : Elmt_Id;\n-      Typ  : Entity_Id := T;\n+      Inher_Op  : Entity_Id := Empty;\n+      Own_Op    : Entity_Id := Empty;\n+      Prim_Elmt : Elmt_Id;\n+      Prim_Id   : Entity_Id;\n+      Typ       : Entity_Id := T;\n \n    begin\n       if Is_Class_Wide_Type (Typ) then\n@@ -1711,18 +2033,31 @@ package body Exp_Util is\n \n       Typ := Underlying_Type (Typ);\n \n-      Prim := First_Elmt (Primitive_Operations (Typ));\n-      while not Is_TSS (Node (Prim), Name) loop\n-         Next_Elmt (Prim);\n+      --  This search is based on the assertion that the dispatching version\n+      --  of the TSS routine always precedes the real primitive.\n \n-         --  Raise program error if no primitive found\n+      Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+      while Present (Prim_Elmt) loop\n+         Prim_Id := Node (Prim_Elmt);\n \n-         if No (Prim) then\n-            raise Program_Error;\n+         if Is_TSS (Prim_Id, Name) then\n+            if Present (Alias (Prim_Id)) then\n+               Inher_Op := Prim_Id;\n+            else\n+               Own_Op := Prim_Id;\n+            end if;\n          end if;\n+\n+         Next_Elmt (Prim_Elmt);\n       end loop;\n \n-      return Node (Prim);\n+      if Present (Own_Op) then\n+         return Own_Op;\n+      elsif Present (Inher_Op) then\n+         return Inher_Op;\n+      else\n+         raise Program_Error;\n+      end if;\n    end Find_Prim_Op;\n \n    ----------------------------\n@@ -1753,6 +2088,34 @@ package body Exp_Util is\n       raise Program_Error;\n    end Find_Protection_Object;\n \n+   --------------------------\n+   -- Find_Protection_Type --\n+   --------------------------\n+\n+   function Find_Protection_Type (Conc_Typ : Entity_Id) return Entity_Id is\n+      Comp : Entity_Id;\n+      Typ  : Entity_Id := Conc_Typ;\n+\n+   begin\n+      if Is_Concurrent_Type (Typ) then\n+         Typ := Corresponding_Record_Type (Typ);\n+      end if;\n+\n+      Comp := First_Component (Typ);\n+      while Present (Comp) loop\n+         if Chars (Comp) = Name_uObject then\n+            return Base_Type (Etype (Comp));\n+         end if;\n+\n+         Next_Component (Comp);\n+      end loop;\n+\n+      --  The corresponding record of a protected type should always have an\n+      --  _object field.\n+\n+      raise Program_Error;\n+   end Find_Protection_Type;\n+\n    ----------------------\n    -- Force_Evaluation --\n    ----------------------\n@@ -2190,45 +2553,254 @@ package body Exp_Util is\n       end if;\n    end Get_Stream_Size;\n \n-   ---------------------------------\n-   -- Has_Controlled_Coextensions --\n-   ---------------------------------\n+   ---------------------------\n+   -- Has_Access_Constraint --\n+   ---------------------------\n \n-   function Has_Controlled_Coextensions (Typ : Entity_Id) return Boolean is\n-      D_Typ : Entity_Id;\n-      Discr : Entity_Id;\n+   function Has_Access_Constraint (E : Entity_Id) return Boolean is\n+      Disc : Entity_Id;\n+      T    : constant Entity_Id := Etype (E);\n \n    begin\n-      --  Only consider record types\n+      if Has_Per_Object_Constraint (E)\n+        and then Has_Discriminants (T)\n+      then\n+         Disc := First_Discriminant (T);\n+         while Present (Disc) loop\n+            if Is_Access_Type (Etype (Disc)) then\n+               return True;\n+            end if;\n+\n+            Next_Discriminant (Disc);\n+         end loop;\n \n-      if not Ekind_In (Typ, E_Record_Type, E_Record_Subtype) then\n+         return False;\n+      else\n          return False;\n       end if;\n+   end Has_Access_Constraint;\n+\n+   ----------------------------\n+   -- Has_Controlled_Objects --\n+   ----------------------------\n \n-      if Has_Discriminants (Typ) then\n-         Discr := First_Discriminant (Typ);\n-         while Present (Discr) loop\n-            D_Typ := Etype (Discr);\n+   function Has_Controlled_Objects (N : Node_Id) return Boolean is\n+      For_Pkg : constant Boolean :=\n+                  Nkind_In (N, N_Package_Body, N_Package_Specification);\n \n-            if Ekind (D_Typ) = E_Anonymous_Access_Type\n+   begin\n+      case Nkind (N) is\n+         when N_Accept_Statement      |\n+              N_Block_Statement       |\n+              N_Entry_Body            |\n+              N_Package_Body          |\n+              N_Protected_Body        |\n+              N_Subprogram_Body       |\n+              N_Task_Body             =>\n+            return Has_Controlled_Objects (Declarations (N), For_Pkg)\n+                     or else\n+\n+                  --  An expanded sequence of statements may introduce\n+                  --  controlled objects.\n+\n+                  (Present (Handled_Statement_Sequence (N))\n+                     and then\n+                   Has_Controlled_Objects\n+                     (Statements (Handled_Statement_Sequence (N)), For_Pkg));\n+\n+         when N_Package_Specification =>\n+            return Has_Controlled_Objects (Visible_Declarations (N), For_Pkg)\n+                     or else\n+                   Has_Controlled_Objects (Private_Declarations (N), For_Pkg);\n+\n+         when others                  =>\n+            return False;\n+      end case;\n+   end Has_Controlled_Objects;\n+\n+   ----------------------------\n+   -- Has_Controlled_Objects --\n+   ----------------------------\n+\n+   function Has_Controlled_Objects\n+     (L           : List_Id;\n+      For_Package : Boolean) return Boolean\n+   is\n+      Decl    : Node_Id;\n+      Expr    : Node_Id;\n+      Obj_Id  : Entity_Id;\n+      Obj_Typ : Entity_Id;\n+      Pack_Id : Entity_Id;\n+      Typ     : Entity_Id;\n+\n+   begin\n+      if No (L)\n+        or else Is_Empty_List (L)\n+      then\n+         return False;\n+      end if;\n+\n+      Decl := First (L);\n+      while Present (Decl) loop\n+\n+         --  Regular object declarations\n+\n+         if Nkind (Decl) = N_Object_Declaration then\n+            Obj_Id  := Defining_Identifier (Decl);\n+            Obj_Typ := Base_Type (Etype (Obj_Id));\n+            Expr    := Expression (Decl);\n+\n+            --  Bypass any form of processing for objects which have their\n+            --  finalization disabled. This applies only to objects at the\n+            --  library level.\n+\n+            if For_Package\n+              and then Finalize_Storage_Only (Obj_Typ)\n+            then\n+               null;\n+\n+            --  Transient variables are treated separately in order to minimize\n+            --  the size of the generated code. See Exp_Ch7.Process_Transient_\n+            --  Objects.\n+\n+            elsif Is_Processed_Transient (Obj_Id) then\n+               null;\n+\n+            --  The object is of the form:\n+            --    Obj : Typ [:= Expr];\n+            --\n+            --  Do not process the incomplete view of a deferred constant\n+\n+            elsif not Is_Imported (Obj_Id)\n+              and then Needs_Finalization (Obj_Typ)\n+              and then not (Ekind (Obj_Id) = E_Constant\n+                              and then not Has_Completion (Obj_Id))\n+            then\n+               return True;\n+\n+            --  The object is of the form:\n+            --    Obj : Access_Typ := Non_BIP_Function_Call'reference;\n+            --\n+            --    Obj : Access_Typ :=\n+            --            BIP_Function_Call\n+            --              (..., BIPaccess => null, ...)'reference;\n+\n+            elsif Is_Access_Type (Obj_Typ)\n+              and then Needs_Finalization\n+                         (Available_View (Designated_Type (Obj_Typ)))\n+              and then Present (Expr)\n               and then\n-                (Is_Controlled (Designated_Type (D_Typ))\n+                (Is_Null_Access_BIP_Func_Call (Expr)\n                    or else\n-                 Is_Concurrent_Type (Designated_Type (D_Typ)))\n+                (Is_Non_BIP_Func_Call (Expr)\n+                   and then not Is_Related_To_Func_Return (Obj_Id)))\n+            then\n+               return True;\n+\n+            --  Simple protected objects which use type System.Tasking.\n+            --  Protected_Objects.Protection to manage their locks should be\n+            --  treated as controlled since they require manual cleanup.\n+\n+            elsif Ekind (Obj_Id) = E_Variable\n+              and then\n+                (Is_Simple_Protected_Type (Obj_Typ)\n+                   or else Has_Simple_Protected_Object (Obj_Typ))\n             then\n                return True;\n             end if;\n \n-            Next_Discriminant (Discr);\n-         end loop;\n-      end if;\n+         --  Specific cases of object renamings\n+\n+         elsif Nkind (Decl) = N_Object_Renaming_Declaration\n+           and then Nkind (Name (Decl)) = N_Explicit_Dereference\n+           and then Nkind (Prefix (Name (Decl))) = N_Identifier\n+         then\n+            Obj_Id  := Defining_Identifier (Decl);\n+            Obj_Typ := Base_Type (Etype (Obj_Id));\n+\n+            --  Bypass any form of processing for objects which have their\n+            --  finalization disabled. This applies only to objects at the\n+            --  library level.\n+\n+            if For_Package\n+              and then Finalize_Storage_Only (Obj_Typ)\n+            then\n+               null;\n+\n+            --  Return object of a build-in-place function. This case is\n+            --  recognized and marked by the expansion of an extended return\n+            --  statement (see Expand_N_Extended_Return_Statement).\n+\n+            elsif Needs_Finalization (Obj_Typ)\n+              and then Is_Return_Object (Obj_Id)\n+              and then Present (Return_Flag (Obj_Id))\n+            then\n+               return True;\n+            end if;\n+\n+         --  Inspect the freeze node of an access-to-controlled type and\n+         --  look for a delayed finalization collection. This case arises\n+         --  when the freeze actions are inserted at a later time than the\n+         --  expansion of the context. Since Build_Finalizer is never called\n+         --  on a single construct twice, the collection will be ultimately\n+         --  left out and never finalized. This is also needed for freeze\n+         --  actions of designated types themselves, since in some cases the\n+         --  finalization collection is associated with a designated type's\n+         --  freeze node rather than that of the access type (see handling\n+         --  for freeze actions in Build_Finalization_Collection).\n+\n+         elsif Nkind (Decl) = N_Freeze_Entity\n+           and then Present (Actions (Decl))\n+         then\n+            Typ := Entity (Decl);\n+\n+            if (Is_Access_Type (Typ)\n+                  and then not Is_Access_Subprogram_Type (Typ)\n+                  and then Needs_Finalization\n+                             (Available_View (Designated_Type (Typ))))\n+              or else\n+               (Is_Type (Typ)\n+                  and then Needs_Finalization (Typ))\n+            then\n+               return True;\n+            end if;\n+\n+         --  Nested package declarations\n+\n+         elsif Nkind (Decl) = N_Package_Declaration then\n+            Pack_Id := Defining_Unit_Name (Specification (Decl));\n+\n+            if Nkind (Pack_Id) = N_Defining_Program_Unit_Name then\n+               Pack_Id := Defining_Identifier (Pack_Id);\n+            end if;\n+\n+            if Ekind (Pack_Id) /= E_Generic_Package\n+              and then Has_Controlled_Objects (Specification (Decl))\n+            then\n+               return True;\n+            end if;\n+\n+         --  Nested package bodies\n+\n+         elsif Nkind (Decl) = N_Package_Body then\n+            Pack_Id := Corresponding_Spec (Decl);\n+\n+            if Ekind (Pack_Id) /= E_Generic_Package\n+              and then Has_Controlled_Objects (Decl)\n+            then\n+               return True;\n+            end if;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n \n       return False;\n-   end Has_Controlled_Coextensions;\n+   end Has_Controlled_Objects;\n \n-   ------------------------\n-   -- Has_Address_Clause --\n-   ------------------------\n+   ----------------------------------\n+   -- Has_Following_Address_Clause --\n+   ----------------------------------\n \n    --  Should this function check the private part in a package ???\n \n@@ -2279,6 +2851,27 @@ package body Exp_Util is\n       return Count;\n    end Homonym_Number;\n \n+   -----------------------------------\n+   -- In_Library_Level_Package_Body --\n+   -----------------------------------\n+\n+   function In_Library_Level_Package_Body (Id : Entity_Id) return Boolean is\n+   begin\n+      --  First determine whether the entity appears at the library level, then\n+      --  look at the containing unit.\n+\n+      if Is_Library_Level_Entity (Id) then\n+         declare\n+            Container : constant Node_Id := Cunit (Get_Source_Unit (Id));\n+\n+         begin\n+            return Nkind (Unit (Container)) = N_Package_Body;\n+         end;\n+      end if;\n+\n+      return False;\n+   end In_Library_Level_Package_Body;\n+\n    ------------------------------\n    -- In_Unconditional_Context --\n    ------------------------------\n@@ -2330,6 +2923,18 @@ package body Exp_Util is\n       Insert_Actions (Assoc_Node, New_List (Ins_Action), Suppress);\n    end Insert_Action;\n \n+   -------------------------\n+   -- Insert_Action_After --\n+   -------------------------\n+\n+   procedure Insert_Action_After\n+     (Assoc_Node : Node_Id;\n+      Ins_Action : Node_Id)\n+   is\n+   begin\n+      Insert_Actions_After (Assoc_Node, New_List (Ins_Action));\n+   end Insert_Action_After;\n+\n    --------------------\n    -- Insert_Actions --\n    --------------------\n@@ -3098,6 +3703,277 @@ package body Exp_Util is\n       return True;\n    end Is_All_Null_Statements;\n \n+   ------------------------------\n+   -- Is_Finalizable_Transient --\n+   ------------------------------\n+\n+   function Is_Finalizable_Transient\n+     (Decl     : Node_Id;\n+      Rel_Node : Node_Id) return Boolean\n+   is\n+      Obj_Id   : constant Entity_Id := Defining_Identifier (Decl);\n+      Obj_Typ  : constant Entity_Id := Base_Type (Etype (Obj_Id));\n+      Desig    : Entity_Id := Obj_Typ;\n+      Has_Rens : Boolean   := True;\n+      Ren_Obj  : Entity_Id;\n+\n+      function Initialized_By_Access (Trans_Id : Entity_Id) return Boolean;\n+      --  Determine whether transient object Trans_Id is initialized either\n+      --  by a function call which returns an access type or simply renames\n+      --  another pointer.\n+\n+      function Initialized_By_Aliased_BIP_Func_Call\n+        (Trans_Id : Entity_Id) return Boolean;\n+      --  Determine whether transient object Trans_Id is initialized by a\n+      --  build-in-place function call where the BIPalloc parameter is of\n+      --  value 1 and BIPaccess is not null. This case creates an aliasing\n+      --  between the returned value and the value denoted by BIPaccess.\n+\n+      function Is_Allocated (Trans_Id : Entity_Id) return Boolean;\n+      --  Determine whether transient object Trans_Id is allocated on the heap\n+\n+      function Is_Renamed\n+        (Trans_Id   : Entity_Id;\n+         First_Stmt : Node_Id) return Boolean;\n+      --  Determine whether transient object Trans_Id has been renamed in the\n+      --  statement list starting from First_Stmt.\n+\n+      ---------------------------\n+      -- Initialized_By_Access --\n+      ---------------------------\n+\n+      function Initialized_By_Access (Trans_Id : Entity_Id) return Boolean is\n+         Expr : constant Node_Id := Expression (Parent (Trans_Id));\n+\n+      begin\n+         return\n+           Present (Expr)\n+             and then Nkind (Expr) /= N_Reference\n+             and then Is_Access_Type (Etype (Expr));\n+      end Initialized_By_Access;\n+\n+      ------------------------------------------\n+      -- Initialized_By_Aliased_BIP_Func_Call --\n+      ------------------------------------------\n+\n+      function Initialized_By_Aliased_BIP_Func_Call\n+        (Trans_Id : Entity_Id) return Boolean\n+      is\n+         Call : Node_Id := Expression (Parent (Trans_Id));\n+\n+      begin\n+         --  Build-in-place calls usually appear in 'reference format\n+\n+         if Nkind (Call) = N_Reference then\n+            Call := Prefix (Call);\n+         end if;\n+\n+         if Is_Build_In_Place_Function_Call (Call) then\n+            declare\n+               Access_Nam : Name_Id := No_Name;\n+               Access_OK  : Boolean := False;\n+               Actual     : Node_Id;\n+               Alloc_Nam  : Name_Id := No_Name;\n+               Alloc_OK   : Boolean := False;\n+               Formal     : Node_Id;\n+               Func_Id    : Entity_Id;\n+               Param      : Node_Id;\n+\n+            begin\n+               --  Examine all parameter associations of the function call\n+\n+               Param := First (Parameter_Associations (Call));\n+               while Present (Param) loop\n+                  if Nkind (Param) = N_Parameter_Association\n+                    and then Nkind (Selector_Name (Param)) = N_Identifier\n+                  then\n+                     Actual := Explicit_Actual_Parameter (Param);\n+                     Formal := Selector_Name (Param);\n+\n+                     --  Construct the names of formals BIPaccess and BIPalloc\n+                     --  using the function name retrieved from an arbitrary\n+                     --  formal.\n+\n+                     if Access_Nam = No_Name\n+                       and then Alloc_Nam = No_Name\n+                       and then Present (Entity (Formal))\n+                     then\n+                        Func_Id := Scope (Entity (Formal));\n+\n+                        Access_Nam :=\n+                          New_External_Name (Chars (Func_Id),\n+                            BIP_Formal_Suffix (BIP_Object_Access));\n+\n+                        Alloc_Nam :=\n+                          New_External_Name (Chars (Func_Id),\n+                            BIP_Formal_Suffix (BIP_Alloc_Form));\n+                     end if;\n+\n+                     --  A match for BIPaccess => Temp has been found\n+\n+                     if Chars (Formal) = Access_Nam\n+                       and then Nkind (Actual) /= N_Null\n+                     then\n+                        Access_OK := True;\n+                     end if;\n+\n+                     --  A match for BIPalloc => 1 has been found\n+\n+                     if Chars (Formal) = Alloc_Nam\n+                       and then Nkind (Actual) = N_Integer_Literal\n+                       and then Intval (Actual) = Uint_1\n+                     then\n+                        Alloc_OK := True;\n+                     end if;\n+                  end if;\n+\n+                  Next (Param);\n+               end loop;\n+\n+               return Access_OK and then Alloc_OK;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Initialized_By_Aliased_BIP_Func_Call;\n+\n+      ------------------\n+      -- Is_Allocated --\n+      ------------------\n+\n+      function Is_Allocated (Trans_Id : Entity_Id) return Boolean is\n+         Expr : constant Node_Id := Expression (Parent (Trans_Id));\n+\n+      begin\n+         return\n+           Is_Access_Type (Etype (Trans_Id))\n+             and then Present (Expr)\n+             and then Nkind (Expr) = N_Allocator;\n+      end Is_Allocated;\n+\n+      ----------------\n+      -- Is_Renamed --\n+      ----------------\n+\n+      function Is_Renamed\n+        (Trans_Id   : Entity_Id;\n+         First_Stmt : Node_Id) return Boolean\n+      is\n+         Stmt : Node_Id;\n+\n+         function Extract_Renamed_Object\n+           (Ren_Decl : Node_Id) return Entity_Id;\n+         --  Given an object renaming declaration, retrieve the entity of the\n+         --  renamed name. Return Empty if the renamed name is anything other\n+         --  than a variable or a constant.\n+\n+         ----------------------------\n+         -- Extract_Renamed_Object --\n+         ----------------------------\n+\n+         function Extract_Renamed_Object\n+           (Ren_Decl : Node_Id) return Entity_Id\n+         is\n+            Change  : Boolean;\n+            Ren_Obj : Node_Id;\n+\n+         begin\n+            Change  := True;\n+            Ren_Obj := Renamed_Object (Defining_Identifier (Ren_Decl));\n+\n+            while Change loop\n+               Change := False;\n+\n+               if Nkind_In (Ren_Obj, N_Explicit_Dereference,\n+                                     N_Indexed_Component,\n+                                     N_Selected_Component)\n+               then\n+                  Ren_Obj := Prefix (Ren_Obj);\n+                  Change := True;\n+               end if;\n+            end loop;\n+\n+            if Nkind (Ren_Obj) in N_Has_Entity then\n+               return Entity (Ren_Obj);\n+            end if;\n+\n+            return Empty;\n+         end Extract_Renamed_Object;\n+\n+      --  Start of processing for Is_Renamed\n+\n+      begin\n+         --  If a previous invocation of this routine has determined that a\n+         --  list has no renamings, there is no point in repeating the same\n+         --  scan.\n+\n+         if not Has_Rens then\n+            return False;\n+         end if;\n+\n+         --  Assume that the statement list does not have a renaming. This is a\n+         --  minor optimization.\n+\n+         Has_Rens := False;\n+\n+         Stmt := First_Stmt;\n+         while Present (Stmt) loop\n+            if Nkind (Stmt) = N_Object_Renaming_Declaration then\n+               Has_Rens := True;\n+               Ren_Obj  := Extract_Renamed_Object (Stmt);\n+\n+               if Present (Ren_Obj)\n+                 and then Ren_Obj = Trans_Id\n+               then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            Next (Stmt);\n+         end loop;\n+\n+         return False;\n+      end Is_Renamed;\n+\n+   --  Start of processing for Is_Finalizable_Transient\n+\n+   begin\n+      --  Handle access types\n+\n+      if Is_Access_Type (Desig) then\n+         Desig := Available_View (Designated_Type (Desig));\n+      end if;\n+\n+      return\n+        Ekind_In (Obj_Id, E_Constant, E_Variable)\n+          and then Needs_Finalization (Desig)\n+          and then Requires_Transient_Scope (Desig)\n+          and then Nkind (Rel_Node) /= N_Simple_Return_Statement\n+\n+         --  Do not consider transient objects allocated on the heap since they\n+         --  are attached to a finalization collection.\n+\n+          and then not Is_Allocated (Obj_Id)\n+\n+         --  Do not consider renamed transient objects because the act of\n+         --  renaming extends the object's lifetime.\n+\n+          and then not Is_Renamed (Obj_Id, Decl)\n+\n+         --  If the transient object is a pointer, check that it is not\n+         --  initialized by a function which returns a pointer or acts as a\n+         --  renaming of another pointer.\n+\n+          and then\n+            (not Is_Access_Type (Obj_Typ)\n+               or else not Initialized_By_Access (Obj_Id))\n+\n+         --  Do not consider transient objects which act as indirect aliases of\n+         --  build-in-place function results.\n+\n+          and then not Initialized_By_Aliased_BIP_Func_Call (Obj_Id);\n+   end Is_Finalizable_Transient;\n+\n    ---------------------------------\n    -- Is_Fully_Repped_Tagged_Type --\n    ---------------------------------\n@@ -3145,6 +4021,90 @@ package body Exp_Util is\n         and then Is_Library_Level_Entity (Typ);\n    end Is_Library_Level_Tagged_Type;\n \n+   ----------------------------------\n+   -- Is_Null_Access_BIP_Func_Call --\n+   ----------------------------------\n+\n+   function Is_Null_Access_BIP_Func_Call (Expr : Node_Id) return Boolean is\n+      Call : Node_Id := Expr;\n+\n+   begin\n+      --  Build-in-place calls usually appear in 'reference format\n+\n+      if Nkind (Call) = N_Reference then\n+         Call := Prefix (Call);\n+      end if;\n+\n+      if Nkind_In (Call, N_Qualified_Expression,\n+                         N_Unchecked_Type_Conversion)\n+      then\n+         Call := Expression (Call);\n+      end if;\n+\n+      if Is_Build_In_Place_Function_Call (Call) then\n+         declare\n+            Access_Nam : Name_Id := No_Name;\n+            Actual     : Node_Id;\n+            Param      : Node_Id;\n+            Formal     : Node_Id;\n+\n+         begin\n+            --  Examine all parameter associations of the function call\n+\n+            Param := First (Parameter_Associations (Call));\n+            while Present (Param) loop\n+               if Nkind (Param) = N_Parameter_Association\n+                 and then Nkind (Selector_Name (Param)) = N_Identifier\n+               then\n+                  Formal := Selector_Name (Param);\n+                  Actual := Explicit_Actual_Parameter (Param);\n+\n+                  --  Construct the name of formal BIPaccess. It is much easier\n+                  --  to extract the name of the function using an arbitrary\n+                  --  formal's scope rather than the Name field of Call.\n+\n+                  if Access_Nam = No_Name\n+                    and then Present (Entity (Formal))\n+                  then\n+                     Access_Nam :=\n+                       New_External_Name\n+                         (Chars (Scope (Entity (Formal))),\n+                          BIP_Formal_Suffix (BIP_Object_Access));\n+                  end if;\n+\n+                  --  A match for BIPaccess => null has been found\n+\n+                  if Chars (Formal) = Access_Nam\n+                    and then Nkind (Actual) = N_Null\n+                  then\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               Next (Param);\n+            end loop;\n+         end;\n+      end if;\n+\n+      return False;\n+   end Is_Null_Access_BIP_Func_Call;\n+\n+   --------------------------\n+   -- Is_Non_BIP_Func_Call --\n+   --------------------------\n+\n+   function Is_Non_BIP_Func_Call (Expr : Node_Id) return Boolean is\n+   begin\n+      --  The expected call is of the format\n+      --\n+      --    Func_Call'reference\n+\n+      return\n+        Nkind (Expr) = N_Reference\n+          and then Nkind (Prefix (Expr)) = N_Function_Call\n+          and then not Is_Build_In_Place_Function_Call (Prefix (Expr));\n+   end Is_Non_BIP_Func_Call;\n+\n    ----------------------------------\n    -- Is_Possibly_Unaligned_Object --\n    ----------------------------------\n@@ -3427,6 +4387,20 @@ package body Exp_Util is\n       end;\n    end Is_Possibly_Unaligned_Slice;\n \n+   -------------------------------\n+   -- Is_Related_To_Func_Return --\n+   -------------------------------\n+\n+   function Is_Related_To_Func_Return (Id : Entity_Id) return Boolean is\n+      Expr : constant Node_Id := Related_Expression (Id);\n+\n+   begin\n+      return\n+        Present (Expr)\n+          and then Nkind (Expr) = N_Explicit_Dereference\n+          and then Nkind (Parent (Expr)) = N_Simple_Return_Statement;\n+   end Is_Related_To_Func_Return;\n+\n    --------------------------------\n    -- Is_Ref_To_Bit_Packed_Array --\n    --------------------------------\n@@ -4341,6 +5315,73 @@ package body Exp_Util is\n       end if;\n    end May_Generate_Large_Temp;\n \n+   ------------------------\n+   -- Needs_Finalization --\n+   ------------------------\n+\n+   function Needs_Finalization (T : Entity_Id) return Boolean is\n+      function Has_Some_Controlled_Component (Rec : Entity_Id) return Boolean;\n+      --  If type is not frozen yet, check explicitly among its components,\n+      --  because the Has_Controlled_Component flag is not necessarily set.\n+\n+      -----------------------------------\n+      -- Has_Some_Controlled_Component --\n+      -----------------------------------\n+\n+      function Has_Some_Controlled_Component\n+        (Rec : Entity_Id) return Boolean\n+      is\n+         Comp : Entity_Id;\n+\n+      begin\n+         if Has_Controlled_Component (Rec) then\n+            return True;\n+\n+         elsif not Is_Frozen (Rec) then\n+            if Is_Record_Type (Rec) then\n+               Comp := First_Entity (Rec);\n+\n+               while Present (Comp) loop\n+                  if not Is_Type (Comp)\n+                    and then Needs_Finalization (Etype (Comp))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next_Entity (Comp);\n+               end loop;\n+\n+               return False;\n+\n+            elsif Is_Array_Type (Rec) then\n+               return Needs_Finalization (Component_Type (Rec));\n+\n+            else\n+               return Has_Controlled_Component (Rec);\n+            end if;\n+         else\n+            return False;\n+         end if;\n+      end Has_Some_Controlled_Component;\n+\n+   --  Start of processing for Needs_Finalization\n+\n+   begin\n+      --  Class-wide types must be treated as controlled because they may\n+      --  contain an extension that has controlled components\n+\n+      --  We can skip this if finalization is not available\n+\n+      return (Is_Class_Wide_Type (T)\n+                and then not Restriction_Active (No_Finalization))\n+        or else Is_Controlled (T)\n+        or else Has_Controlled_Component (T)\n+        or else Has_Some_Controlled_Component (T)\n+        or else (Is_Concurrent_Type (T)\n+                  and then Present (Corresponding_Record_Type (T))\n+                  and then Needs_Finalization (Corresponding_Record_Type (T)));\n+   end Needs_Finalization;\n+\n    ----------------------------\n    -- Needs_Constant_Address --\n    ----------------------------"}, {"sha": "e9b373d0e3fefd18174686ea59aeb5a25c2baf28", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -118,6 +118,13 @@ package Exp_Util is\n    --  Assoc_Node is the node with which the actions are associated.\n    --  Ins_Actions may be No_List, in which case the call has no effect.\n \n+   procedure Insert_Action_After\n+     (Assoc_Node : Node_Id;\n+      Ins_Action : Node_Id);\n+   --  Assoc_Node must be a node in a list. Same as Insert_Action but the\n+   --  action will be inserted after N in a manner that is compatible with\n+   --  the transient scope mechanism.\n+\n    procedure Insert_Actions_After\n      (Assoc_Node  : Node_Id;\n       Ins_Actions : List_Id);\n@@ -187,6 +194,30 @@ package Exp_Util is\n    --  Note that the added nodes are not analyzed. The analyze call is found in\n    --  Exp_Ch13.Expand_N_Freeze_Entity.\n \n+   procedure Build_Allocate_Deallocate_Proc\n+     (N           : Node_Id;\n+      Is_Allocate : Boolean);\n+   --  Create a custom Allocate/Deallocate to be associated with an allocation\n+   --  or deallocation of a controlled or class-wide object. In the case of\n+   --  allocation, N is the declaration of the temporary variable which\n+   --  represents the expression of the original allocator node, otherwise N\n+   --  must be a free statement. If flag Is_Allocate is set, the generated\n+   --  routine is allocate, deallocate otherwise. The generated routine is:\n+   --\n+   --     F : constant Boolean :=                          --  CW case\n+   --           Ada.Tags.Needs_Finalization (<Expr>'Tag);  --  CW case\n+   --\n+   --     procedure Allocate / Deallocate\n+   --       (P : Storage_Pool;\n+   --        A : [out] Address;  --  out is present for Allocate\n+   --        S : Storage_Count;\n+   --        L : Storage_Count)\n+   --     is\n+   --     begin\n+   --        Allocate / Deallocate\n+   --          (<Ptr_Typ collection>, A, S, L, [Needs_Header => F]);\n+   --     end Allocate;\n+\n    function Build_Runtime_Call (Loc : Source_Ptr; RE : RE_Id) return Node_Id;\n    --  Build an N_Procedure_Call_Statement calling the given runtime entity.\n    --  The call has no parameters. The first argument provides the location\n@@ -393,6 +424,10 @@ package Exp_Util is\n    --  in which this routine is invoked should always have a protection\n    --  object.\n \n+   function Find_Protection_Type (Conc_Typ : Entity_Id) return Entity_Id;\n+   --  Given a protected type or its corresponding record, find the type of\n+   --  field _object.\n+\n    procedure Force_Evaluation\n      (Exp      : Node_Id;\n       Name_Req : Boolean := False);\n@@ -448,9 +483,21 @@ package Exp_Util is\n    function Get_Stream_Size (E : Entity_Id) return Uint;\n    --  Return the stream size value of the subtype E\n \n-   function Has_Controlled_Coextensions (Typ : Entity_Id) return Boolean;\n-   --  Determine whether a record type has anonymous access discriminants with\n-   --  a controlled designated type.\n+   function Has_Access_Constraint (E : Entity_Id) return Boolean;\n+   --  Given object or type E, determine whether a discriminant is of an access\n+   --  type.\n+\n+   function Has_Controlled_Objects (N : Node_Id) return Boolean;\n+   --  Given an arbitrary node N, determine whether it has a declarative or a\n+   --  statement part and whether those lists contain at least one controlled\n+   --  object.\n+\n+   function Has_Controlled_Objects\n+     (L           : List_Id;\n+      For_Package : Boolean) return Boolean;\n+   --  Given a list, determine whether L contains at least one controlled\n+   --  object. Flag For_Package should be set when the list comes from a\n+   --  package spec or body.\n \n    function Has_Following_Address_Clause (D : Node_Id) return Boolean;\n    --  D is the node for an object declaration. This function searches the\n@@ -468,6 +515,10 @@ package Exp_Util is\n    function Inside_Init_Proc return Boolean;\n    --  Returns True if current scope is within an init proc\n \n+   function In_Library_Level_Package_Body (Id : Entity_Id) return Boolean;\n+   --  Given an arbitrary entity, determine whether it appears at the library\n+   --  level of a package body.\n+\n    function In_Unconditional_Context (Node : Node_Id) return Boolean;\n    --  Node is the node for a statement or a component of a statement. This\n    --  function determines if the statement appears in a context that is\n@@ -479,6 +530,14 @@ package Exp_Util is\n    --  False otherwise. True for an empty list. It is an error to call this\n    --  routine with No_List as the argument.\n \n+   function Is_Finalizable_Transient\n+     (Decl     : Node_Id;\n+      Rel_Node : Node_Id) return Boolean;\n+   --  Determine whether declaration Decl denotes a controlled transient which\n+   --  should be finalized. Rel_Node is the related context. Even though some\n+   --  transient are controlled, they may act as renamings of other objects or\n+   --  function calls.\n+\n    function Is_Fully_Repped_Tagged_Type (T : Entity_Id) return Boolean;\n    --  Tests given type T, and returns True if T is a non-discriminated tagged\n    --  type which has a record representation clause that specifies the layout\n@@ -492,6 +551,13 @@ package Exp_Util is\n    --  Return True if Typ is a library level tagged type. Currently we use\n    --  this information to build statically allocated dispatch tables.\n \n+   function Is_Null_Access_BIP_Func_Call (Expr : Node_Id) return Boolean;\n+   --  Determine whether node Expr denotes a build-in-place function call with\n+   --  a value of \"null\" for extra formal BIPaccess.\n+\n+   function Is_Non_BIP_Func_Call (Expr : Node_Id) return Boolean;\n+   --  Determine whether node Expr denotes a non build-in-place function call\n+\n    function Is_Ref_To_Bit_Packed_Array (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a reference to a bit packed array, i.e.\n    --  whether the designated object is a component of a bit packed array, or a\n@@ -504,6 +570,10 @@ package Exp_Util is\n    --  whether the designated object is bit packed slice or a component of a\n    --  bit packed slice. Return True if so.\n \n+   function Is_Related_To_Func_Return (Id : Entity_Id) return Boolean;\n+   --  Determine whether object Id is related to an expanded return statement.\n+   --  The case concerned is \"return Id.all;\".\n+\n    function Is_Possibly_Unaligned_Slice (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a slice of an array where the slice\n    --  result may cause alignment problems because it has an alignment that\n@@ -614,6 +684,12 @@ package Exp_Util is\n    --  consist of constants, when the object has a non-trivial initialization\n    --  or is controlled.\n \n+   function Needs_Finalization (T : Entity_Id) return Boolean;\n+   --  True if type T is controlled, or has controlled subcomponents. Also\n+   --  True if T is a class-wide type, because some type extension might add\n+   --  controlled subcomponents, except that if pragma Restrictions\n+   --  (No_Finalization) applies, this is False for class-wide types.\n+\n    function Non_Limited_Designated_Type (T : Entity_Id) return Entity_Id;\n    --  An anonymous access type may designate a limited view. Check whether\n    --  non-limited view is available during expansion, to examine components"}, {"sha": "ffb8dad11625b94f7432b54e55e73ffd76429521", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -211,6 +211,9 @@ package body Expander is\n                when N_Extension_Aggregate =>\n                   Expand_N_Extension_Aggregate (N);\n \n+               when N_Free_Statement =>\n+                  Expand_N_Free_Statement (N);\n+\n                when N_Freeze_Entity =>\n                   Expand_N_Freeze_Entity (N);\n "}, {"sha": "cec09edc30fe98385159e6ff7677941a3a008eb7", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 36, "deletions": 57, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1190,7 +1190,6 @@ package body Freeze is\n \n          Set_Expression (Par, New_Occurrence_Of (Temp, Loc));\n          return True;\n-\n       else\n          return False;\n       end if;\n@@ -1303,7 +1302,7 @@ package body Freeze is\n                   Subp : Entity_Id;\n \n                begin\n-                  Prim  := First_Elmt (Prim_List);\n+                  Prim := First_Elmt (Prim_List);\n                   while Present (Prim) loop\n                      Subp := Node (Prim);\n \n@@ -1448,13 +1447,27 @@ package body Freeze is\n                end loop;\n             end;\n \n+         --  We add finalization collections to access types whose designated\n+         --  types require finalization. This is normally done when freezing\n+         --  the type, but this misses recursive type definitions where the\n+         --  later members of the recursion introduce controlled components\n+         --  (such as can happen when incomplete types are involved), as well\n+         --  cases where a component type is private and the controlled full\n+         --  type occurs after the access type is frozen. Cases that don't\n+         --  need a finalization collection are generic formal types (the\n+         --  actual type will have it) and types with Java and CIL conventions,\n+         --  since those are used for API bindings. (Are there any other cases\n+         --  that should be excluded here???)\n+\n          elsif Is_Access_Type (E)\n            and then Comes_From_Source (E)\n-           and then Ekind (Directly_Designated_Type (E)) = E_Incomplete_Type\n+           and then not Is_Generic_Type (E)\n            and then Needs_Finalization (Designated_Type (E))\n-           and then No (Associated_Final_Chain (E))\n+           and then No (Associated_Collection (E))\n+           and then Convention (Designated_Type (E)) /= Convention_Java\n+           and then Convention (Designated_Type (E)) /= Convention_CIL\n          then\n-            Build_Final_List (Parent (E), E);\n+            Build_Finalization_Collection (E);\n          end if;\n \n          Next_Entity (E);\n@@ -1800,40 +1813,6 @@ package body Freeze is\n       --  Start of processing for Freeze_Record_Type\n \n       begin\n-         --  If this is a subtype of a controlled type, declared without a\n-         --  constraint, the _controller may not appear in the component list\n-         --  if the parent was not frozen at the point of subtype declaration.\n-         --  Inherit the _controller component now.\n-\n-         if Rec /= Base_Type (Rec)\n-           and then Has_Controlled_Component (Rec)\n-         then\n-            if Nkind (Parent (Rec)) = N_Subtype_Declaration\n-              and then Is_Entity_Name (Subtype_Indication (Parent (Rec)))\n-            then\n-               Set_First_Entity (Rec, First_Entity (Base_Type (Rec)));\n-\n-            --  If this is an internal type without a declaration, as for\n-            --  record component, the base type may not yet be frozen, and its\n-            --  controller has not been created. Add an explicit freeze node\n-            --  for the itype, so it will be frozen after the base type. This\n-            --  freeze node is used to communicate with the expander, in order\n-            --  to create the controller for the enclosing record, and it is\n-            --  deleted afterwards (see exp_ch3). It must not be created when\n-            --  expansion is off, because it might appear in the wrong context\n-            --  for the back end.\n-\n-            elsif Is_Itype (Rec)\n-              and then Has_Delayed_Freeze (Base_Type (Rec))\n-              and then\n-                Nkind (Associated_Node_For_Itype (Rec)) =\n-                                                     N_Component_Declaration\n-              and then Expander_Active\n-            then\n-               Ensure_Freeze_Node (Rec);\n-            end if;\n-         end if;\n-\n          --  Freeze components and embedded subtypes\n \n          Comp := First_Entity (Rec);\n@@ -2747,23 +2726,24 @@ package body Freeze is\n \n                      if Has_Foreign_Convention (E)\n \n-                       --  We are looking for a return of unconstrained array\n+                        --  We are looking for a return of unconstrained array\n \n                        and then Is_Array_Type (R_Type)\n                        and then not Is_Constrained (R_Type)\n \n-                       --  Exclude imported routines, the warning does not\n-                       --  belong on the import, but on the routine definition.\n+                        --  Exclude imported routines, the warning does not\n+                        --  belong on the import, but rather on the routine\n+                        --  definition.\n \n                        and then not Is_Imported (E)\n \n-                       --  Exclude VM case, since both .NET and JVM can handle\n-                       --  return of unconstrained arrays without a problem.\n+                        --  Exclude VM case, since both .NET and JVM can handle\n+                        --  return of unconstrained arrays without a problem.\n \n                        and then VM_Target = No_VM\n \n-                       --  Check that general warning is enabled, and that it\n-                       --  is not suppressed for this particular case.\n+                        --  Check that general warning is enabled, and that it\n+                        --  is not suppressed for this particular case.\n \n                        and then Warn_On_Export_Import\n                        and then not Has_Warnings_Off (E)\n@@ -3940,7 +3920,7 @@ package body Freeze is\n \n             if Is_Pure_Unit_Access_Type (E)\n               and then (Ada_Version < Ada_2005\n-                         or else not No_Pool_Assigned (E))\n+                          or else not No_Pool_Assigned (E))\n             then\n                Error_Msg_N (\"named access type not allowed in pure unit\", E);\n \n@@ -5469,13 +5449,13 @@ package body Freeze is\n             elsif Is_Array_Type (Retype)\n               and then not Is_Constrained (Retype)\n \n-              --  Exclude cases where descriptor mechanism is set, since the\n-              --  VMS descriptor mechanisms allow such unconstrained returns.\n+               --  Exclude cases where descriptor mechanism is set, since the\n+               --  VMS descriptor mechanisms allow such unconstrained returns.\n \n               and then Mechanism (E) not in Descriptor_Codes\n \n-              --  Check appropriate warning is enabled (should we check for\n-              --  Warnings (Off) on specific entities here, probably so???)\n+               --  Check appropriate warning is enabled (should we check for\n+               --  Warnings (Off) on specific entities here, probably so???)\n \n               and then Warn_On_Export_Import\n \n@@ -5745,11 +5725,10 @@ package body Freeze is\n                    Declarations => New_List (\n                      Make_Object_Declaration (Loc,\n                        Defining_Identifier =>\n-                         Make_Defining_Identifier (Loc,\n-                           New_Internal_Name ('T')),\n-                         Object_Definition =>\n-                           New_Occurrence_Of (Etype (Formal), Loc),\n-                         Expression => New_Copy_Tree (Dcopy))),\n+                         Make_Temporary (Loc, 'T'),\n+                       Object_Definition =>\n+                         New_Occurrence_Of (Etype (Formal), Loc),\n+                       Expression => New_Copy_Tree (Dcopy))),\n \n                    Handled_Statement_Sequence =>\n                      Make_Handled_Sequence_Of_Statements (Loc,"}, {"sha": "ec534e1f3f2d76bc83661564b836aeb0283e8588", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -960,9 +960,7 @@ package body Inline is\n             Set_Uses_Sec_Stack\n               (Protected_Body_Subprogram (Scop),\n                 Uses_Sec_Stack (Scop));\n-            Set_Finalization_Chain_Entity\n-              (Protected_Body_Subprogram (Scop),\n-                Finalization_Chain_Entity (Scop));\n+\n             Scop := Protected_Body_Subprogram (Scop);\n          end if;\n "}, {"sha": "eab4a10db28e70654337e6eeb227786c8891e327", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -461,6 +461,13 @@ package body Lib.Writ is\n          Write_Info_Str (\" O\");\n          Write_Info_Char (OA_Setting (Unit_Num));\n \n+         if (Ekind (Uent) = E_Package\n+               or else Ekind (Uent) = E_Package_Body)\n+           and then Present (Finalizer (Uent))\n+         then\n+            Write_Info_Str (\" PF\");\n+         end if;\n+\n          if Is_Preelaborated (Uent) then\n             Write_Info_Str (\" PR\");\n          end if;"}, {"sha": "98786f48dc51bad13e69302618edde52e95bf049", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -497,6 +497,8 @@ package Lib.Writ is\n    --              units in this file. All files in the partition that specify\n    --              a default must specify the same default.\n    --\n+   --         PF  The unit has a library-level (package) finalizer\n+   --\n    --         PK  Unit is package, rather than a subprogram\n    --\n    --         PU  Unit has pragma Pure"}, {"sha": "f2fc7654108c0022d5f92aeb3ab31db7d15a96cf", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -35,13 +35,13 @@ package body Ch4 is\n    --  Attributes that cannot have arguments\n \n    Is_Parameterless_Attribute : constant Attribute_Class_Array :=\n-     (Attribute_Body_Version => True,\n+     (Attribute_Base         => True,\n+      Attribute_Body_Version => True,\n+      Attribute_Class        => True,\n       Attribute_External_Tag => True,\n       Attribute_Img          => True,\n-      Attribute_Version      => True,\n-      Attribute_Base         => True,\n-      Attribute_Class        => True,\n       Attribute_Stub_Type    => True,\n+      Attribute_Version      => True,\n       Attribute_Type_Key     => True,\n       others                 => False);\n    --  This map contains True for parameterless attributes that return a"}, {"sha": "652ec29c61f124f72ac71f273b5b7603f1f16cbb", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -112,7 +112,7 @@ package Rtsfind is\n       --  package see declarations in the runtime entity table below.\n \n       RTU_Null,\n-      --  Used as a null entry. Will cause an error if referenced\n+      --  Used as a null entry. Will cause an error if referenced.\n \n       --  Children of Ada\n \n@@ -138,7 +138,7 @@ package Rtsfind is\n \n       --  Children of Ada.Finalization\n \n-      Ada_Finalization_List_Controller,\n+      Ada_Finalization_Heap_Management,\n \n       --  Children of Ada.Interrupts\n \n@@ -245,7 +245,6 @@ package Rtsfind is\n       System_Fat_VAX_D_Float,\n       System_Fat_VAX_F_Float,\n       System_Fat_VAX_G_Float,\n-      System_Finalization_Implementation,\n       System_Finalization_Root,\n       System_Fore,\n       System_Img_Bool,\n@@ -400,7 +399,7 @@ package Rtsfind is\n    --  Range of values for children of Ada.Dispatching\n \n    subtype Ada_Finalization_Child is Ada_Child range\n-     Ada_Finalization_List_Controller .. Ada_Finalization_List_Controller;\n+     Ada_Finalization_Heap_Management .. Ada_Finalization_Heap_Management;\n    --  Range of values for children of Ada.Finalization\n \n    subtype Ada_Interrupts_Child is Ada_Child range\n@@ -500,6 +499,7 @@ package Rtsfind is\n      RE_Code_Loc,                        -- Ada.Exceptions\n      RE_Current_Target_Exception,        -- Ada.Exceptions (JGNAT use only)\n      RE_Exception_Id,                    -- Ada.Exceptions\n+     RE_Exception_Identity,              -- Ada.Exceptions\n      RE_Exception_Information,           -- Ada.Exceptions\n      RE_Exception_Message,               -- Ada.Exceptions\n      RE_Exception_Name_Simple,           -- Ada.Exceptions\n@@ -515,8 +515,14 @@ package Rtsfind is\n      RE_Reraise_Occurrence_No_Defer,     -- Ada.Exceptions\n      RE_Save_Occurrence,                 -- Ada.Exceptions\n \n-     RE_Simple_List_Controller,          -- Ada.Finalization.List_Controller\n-     RE_List_Controller,                 -- Ada.Finalization.List_Controller\n+     RE_Add_Offset_To_Address,           -- Ada.Finalization.Heap_Management\n+     RE_Allocate,                        -- Ada.Finalization.Heap_Management\n+     RE_Base_Pool,                       -- Ada.Finalization.Heap_Management\n+     RE_Deallocate,                      -- Ada.Finalization.Heap_Management\n+     RE_Finalization_Collection,         -- Ada.Finalization.Heap_Management\n+     RE_Finalization_Collection_Ptr,     -- Ada.Finalization.Heap_Management\n+     RE_Set_Finalize_Address_Ptr,        -- Ada.Finalization.Heap_Management\n+     RE_Set_Storage_Pool_Ptr,            -- Ada.Finalization.Heap_Management\n \n      RE_Interrupt_ID,                    -- Ada.Interrupts\n      RE_Is_Reserved,                     -- Ada.Interrupts\n@@ -576,6 +582,7 @@ package Rtsfind is\n      RE_Interface_Tag,                   -- Ada.Tags\n      RE_IW_Membership,                   -- Ada.Tags\n      RE_Max_Predef_Prims,                -- Ada.Tags\n+     RE_Needs_Finalization,              -- Ada.Tags\n      RE_No_Dispatch_Table_Wrapper,       -- Ada.Tags\n      RE_NDT_Prims_Ptr,                   -- Ada.Tags\n      RE_NDT_TSD,                         -- Ada.Tags\n@@ -788,16 +795,6 @@ package Rtsfind is\n      RE_Attr_VAX_G_Float,                -- System.Fat_VAX_G_Float\n      RE_Fat_VAX_G,                       -- System.Fat_VAX_G_Float\n \n-     RE_Attach_To_Final_List,            -- System.Finalization_Implementation\n-     RE_Finalizable_Ptr_Ptr,             -- System.Finalization_Implementation\n-     RE_Move_Final_List,                 -- System.Finalization_Implementation\n-     RE_Finalize_List,                   -- System.Finalization_Implementation\n-     RE_Finalize_One,                    -- System.Finalization_Implementation\n-     RE_Global_Final_List,               -- System.Finalization_Implementation\n-     RE_Record_Controller,               -- System.Finalization_Implementation\n-     RE_Limited_Record_Controller,       -- System.Finalization_Implementation\n-     RE_Deep_Tag_Attach,                 -- System.Finalization_Implementation\n-\n      RE_Root_Controlled,                 -- System.Finalization_Root\n      RE_Finalizable,                     -- System.Finalization_Root\n      RE_Finalizable_Ptr,                 -- System.Finalization_Root\n@@ -1314,8 +1311,9 @@ package Rtsfind is\n      RE_Exception_Data_Ptr,              -- System.Standard_Library\n \n      RE_Integer_Address,                 -- System.Storage_Elements\n-     RE_Storage_Offset,                  -- System.Storage_Elements\n      RE_Storage_Array,                   -- System.Storage_Elements\n+     RE_Storage_Count,                   -- System.Storage_Elements\n+     RE_Storage_Offset,                  -- System.Storage_Elements\n      RE_To_Address,                      -- System.Storage_Elements\n \n      RE_Root_Storage_Pool,               -- System.Storage_Pools\n@@ -1439,6 +1437,7 @@ package Rtsfind is\n      RE_Enter_Master,                    -- System.Soft_Links\n      RE_Get_Current_Excep,               -- System.Soft_Links\n      RE_Get_GNAT_Exception,              -- System.Soft_Links\n+     RE_Save_Library_Occurrence,         -- System.Soft_Links\n      RE_Update_Exception,                -- System.Soft_Links\n \n      RE_Bits_1,                          -- System.Unsigned_Types\n@@ -1677,6 +1676,7 @@ package Rtsfind is\n      RE_Code_Loc                         => Ada_Exceptions,\n      RE_Current_Target_Exception         => Ada_Exceptions, -- of JGNAT\n      RE_Exception_Id                     => Ada_Exceptions,\n+     RE_Exception_Identity               => Ada_Exceptions,\n      RE_Exception_Information            => Ada_Exceptions,\n      RE_Exception_Message                => Ada_Exceptions,\n      RE_Exception_Name_Simple            => Ada_Exceptions,\n@@ -1692,8 +1692,14 @@ package Rtsfind is\n      RE_Reraise_Occurrence_No_Defer      => Ada_Exceptions,\n      RE_Save_Occurrence                  => Ada_Exceptions,\n \n-     RE_Simple_List_Controller           => Ada_Finalization_List_Controller,\n-     RE_List_Controller                  => Ada_Finalization_List_Controller,\n+     RE_Add_Offset_To_Address            => Ada_Finalization_Heap_Management,\n+     RE_Allocate                         => Ada_Finalization_Heap_Management,\n+     RE_Base_Pool                        => Ada_Finalization_Heap_Management,\n+     RE_Deallocate                       => Ada_Finalization_Heap_Management,\n+     RE_Finalization_Collection          => Ada_Finalization_Heap_Management,\n+     RE_Finalization_Collection_Ptr      => Ada_Finalization_Heap_Management,\n+     RE_Set_Finalize_Address_Ptr         => Ada_Finalization_Heap_Management,\n+     RE_Set_Storage_Pool_Ptr             => Ada_Finalization_Heap_Management,\n \n      RE_Interrupt_ID                     => Ada_Interrupts,\n      RE_Is_Reserved                      => Ada_Interrupts,\n@@ -1753,6 +1759,7 @@ package Rtsfind is\n      RE_Interface_Tag                    => Ada_Tags,\n      RE_IW_Membership                    => Ada_Tags,\n      RE_Max_Predef_Prims                 => Ada_Tags,\n+     RE_Needs_Finalization               => Ada_Tags,\n      RE_No_Dispatch_Table_Wrapper        => Ada_Tags,\n      RE_NDT_Prims_Ptr                    => Ada_Tags,\n      RE_NDT_TSD                          => Ada_Tags,\n@@ -1965,16 +1972,6 @@ package Rtsfind is\n      RE_Attr_VAX_G_Float                 => System_Fat_VAX_G_Float,\n      RE_Fat_VAX_G                        => System_Fat_VAX_G_Float,\n \n-     RE_Attach_To_Final_List             => System_Finalization_Implementation,\n-     RE_Finalizable_Ptr_Ptr              => System_Finalization_Implementation,\n-     RE_Move_Final_List                  => System_Finalization_Implementation,\n-     RE_Finalize_List                    => System_Finalization_Implementation,\n-     RE_Finalize_One                     => System_Finalization_Implementation,\n-     RE_Global_Final_List                => System_Finalization_Implementation,\n-     RE_Record_Controller                => System_Finalization_Implementation,\n-     RE_Limited_Record_Controller        => System_Finalization_Implementation,\n-     RE_Deep_Tag_Attach                  => System_Finalization_Implementation,\n-\n      RE_Root_Controlled                  => System_Finalization_Root,\n      RE_Finalizable                      => System_Finalization_Root,\n      RE_Finalizable_Ptr                  => System_Finalization_Root,\n@@ -2491,8 +2488,9 @@ package Rtsfind is\n      RE_Exception_Data_Ptr               => System_Standard_Library,\n \n      RE_Integer_Address                  => System_Storage_Elements,\n-     RE_Storage_Offset                   => System_Storage_Elements,\n      RE_Storage_Array                    => System_Storage_Elements,\n+     RE_Storage_Count                    => System_Storage_Elements,\n+     RE_Storage_Offset                   => System_Storage_Elements,\n      RE_To_Address                       => System_Storage_Elements,\n \n      RE_Root_Storage_Pool                => System_Storage_Pools,\n@@ -2616,6 +2614,7 @@ package Rtsfind is\n      RE_Enter_Master                     => System_Soft_Links,\n      RE_Get_Current_Excep                => System_Soft_Links,\n      RE_Get_GNAT_Exception               => System_Soft_Links,\n+     RE_Save_Library_Occurrence          => System_Soft_Links,\n      RE_Update_Exception                 => System_Soft_Links,\n \n      RE_Bits_1                           => System_Unsigned_Types,"}, {"sha": "050f79995eca61463a21f2bc7654f22c7c8de5d9", "filename": "gcc/ada/s-finimp.adb", "status": "removed", "additions": 0, "deletions": 540, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de29d8500c2f9f5f164032ae5c3a5477dcc45c51/gcc%2Fada%2Fs-finimp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de29d8500c2f9f5f164032ae5c3a5477dcc45c51/gcc%2Fada%2Fs-finimp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finimp.adb?ref=de29d8500c2f9f5f164032ae5c3a5477dcc45c51", "patch": "@@ -1,540 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---    S Y S T E M . F I N A L I Z A T I O N _ I M P L E M E N T A T I O N   --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Exceptions;\n-with Ada.Tags;\n-\n-with System.Soft_Links;\n-\n-with System.Restrictions;\n-\n-package body System.Finalization_Implementation is\n-\n-   use Ada.Exceptions;\n-   use System.Finalization_Root;\n-\n-   package SSL renames System.Soft_Links;\n-\n-   use type SSE.Storage_Offset;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   type RC_Ptr is access all Record_Controller;\n-\n-   function To_RC_Ptr is\n-     new Ada.Unchecked_Conversion (Address, RC_Ptr);\n-\n-   procedure Raise_From_Controlled_Operation (X : Exception_Occurrence);\n-   pragma Import\n-     (Ada, Raise_From_Controlled_Operation,\n-      \"ada__exceptions__raise_from_controlled_operation\");\n-   pragma No_Return (Raise_From_Controlled_Operation);\n-   --  Raise Program_Error from an exception that occurred during an Adjust or\n-   --  Finalize operation. We use this rather kludgy Ada Import interface\n-   --  because this procedure is not available in the visible part of the\n-   --  Ada.Exceptions spec.\n-\n-   procedure Raise_From_Finalize\n-     (L          : Finalizable_Ptr;\n-      From_Abort : Boolean;\n-      E_Occ      : Exception_Occurrence);\n-   --  Deal with an exception raised during finalization of a list. L is a\n-   --  pointer to the list of element not yet finalized. From_Abort is true\n-   --  if the finalization actions come from an abort rather than a normal\n-   --  exit. E_Occ represents the exception being raised.\n-\n-   function RC_Offset (T : Ada.Tags.Tag) return SSE.Storage_Offset;\n-   pragma Import (Ada, RC_Offset, \"ada__tags__get_rc_offset\");\n-\n-   function Parent_Size (Obj : Address; T : Ada.Tags.Tag)\n-     return SSE.Storage_Count;\n-   pragma Import (Ada, Parent_Size, \"ada__tags__parent_size\");\n-\n-   function Get_Deep_Controller (Obj : System.Address) return RC_Ptr;\n-   --  Given the address (obj) of a tagged object, return a\n-   --  pointer to the record controller of this object.\n-\n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   overriding procedure Adjust (Object : in out Record_Controller) is\n-\n-      First_Comp : Finalizable_Ptr;\n-      My_Offset  : constant SSE.Storage_Offset :=\n-                     Object.My_Address - Object'Address;\n-\n-      procedure Ptr_Adjust (Ptr : in out Finalizable_Ptr);\n-      --  Subtract the offset to the pointer\n-\n-      procedure Reverse_Adjust (P : Finalizable_Ptr);\n-      --  Adjust the components in the reverse order in which they are stored\n-      --  on the finalization list. (Adjust and Finalization are not done in\n-      --  the same order)\n-\n-      ----------------\n-      -- Ptr_Adjust --\n-      ----------------\n-\n-      procedure Ptr_Adjust (Ptr : in out Finalizable_Ptr) is\n-      begin\n-         if Ptr /= null then\n-            Ptr := To_Finalizable_Ptr (To_Addr (Ptr) - My_Offset);\n-         end if;\n-      end Ptr_Adjust;\n-\n-      --------------------\n-      -- Reverse_Adjust --\n-      --------------------\n-\n-      procedure Reverse_Adjust (P : Finalizable_Ptr) is\n-      begin\n-         if P /= null then\n-            Ptr_Adjust (P.Next);\n-            Reverse_Adjust (P.Next);\n-            Adjust (P.all);\n-            Object.F := P;   --  Successfully adjusted, so place in list\n-         end if;\n-      end Reverse_Adjust;\n-\n-   --  Start of processing for Adjust\n-\n-   begin\n-      --  Adjust the components and their finalization pointers next. We must\n-      --  protect against an exception in some call to Adjust, so we keep\n-      --  pointing to the list of successfully adjusted components, which can\n-      --  be finalized if an exception is raised.\n-\n-      First_Comp := Object.F;\n-      Object.F := null;               --  nothing adjusted yet.\n-      Ptr_Adjust (First_Comp);        --  set address of first component.\n-      Reverse_Adjust (First_Comp);\n-\n-      --  Then Adjust the controller itself\n-\n-      Object.My_Address := Object'Address;\n-\n-   exception\n-      when others =>\n-         --  Finalize those components that were successfully adjusted, and\n-         --  propagate exception. The object itself is not yet attached to\n-         --  global finalization list, so we cannot rely on the outer call to\n-         --  Clean to take care of these components.\n-\n-         Finalize (Object);\n-         raise;\n-   end Adjust;\n-\n-   --------------------------\n-   -- Attach_To_Final_List --\n-   --------------------------\n-\n-   procedure Attach_To_Final_List\n-     (L       : in out Finalizable_Ptr;\n-      Obj     : in out Finalizable;\n-      Nb_Link : Short_Short_Integer)\n-   is\n-   begin\n-      --  Simple case: attachment to a one way list\n-\n-      if Nb_Link = 1 then\n-         Obj.Next := L;\n-         L        := Obj'Unchecked_Access;\n-\n-      --  Dynamically allocated objects: they are attached to a doubly linked\n-      --  list, so that an element can be finalized at any moment by means of\n-      --  an unchecked deallocation. Attachment is protected against\n-      --  multi-threaded access.\n-\n-      elsif Nb_Link = 2 then\n-\n-         --  Raise Program_Error if we're trying to allocate an object in a\n-         --  collection whose finalization has already started.\n-\n-         if L = Collection_Finalization_Started then\n-            raise Program_Error with\n-              \"allocation after collection finalization started\";\n-         end if;\n-\n-         Locked_Processing : begin\n-            SSL.Lock_Task.all;\n-            Obj.Next    := L.Next;\n-            Obj.Prev    := L.Next.Prev;\n-            L.Next.Prev := Obj'Unchecked_Access;\n-            L.Next      := Obj'Unchecked_Access;\n-            SSL.Unlock_Task.all;\n-\n-         exception\n-            when others =>\n-               SSL.Unlock_Task.all;\n-               raise;\n-         end Locked_Processing;\n-\n-      --  Attachment of arrays to the final list (used only for objects\n-      --  returned by function). Obj, in this case is the last element,\n-      --  but all other elements are already threaded after it. We just\n-      --  attach the rest of the final list at the end of the array list.\n-\n-      elsif Nb_Link = 3 then\n-         declare\n-            P : Finalizable_Ptr := Obj'Unchecked_Access;\n-\n-         begin\n-            while P.Next /= null loop\n-               P := P.Next;\n-            end loop;\n-\n-            P.Next := L;\n-            L := Obj'Unchecked_Access;\n-         end;\n-\n-      --  Make the object completely unattached (case of a library-level,\n-      --  Finalize_Storage_Only object).\n-\n-      elsif Nb_Link = 4 then\n-         Obj.Prev := null;\n-         Obj.Next := null;\n-      end if;\n-   end Attach_To_Final_List;\n-\n-   ---------------------\n-   -- Deep_Tag_Attach --\n-   ----------------------\n-\n-   procedure Deep_Tag_Attach\n-     (L : in out SFR.Finalizable_Ptr;\n-      A : System.Address;\n-      B : Short_Short_Integer)\n-   is\n-      V          : constant SFR.Finalizable_Ptr := To_Finalizable_Ptr (A);\n-      Controller : constant RC_Ptr := Get_Deep_Controller (A);\n-\n-   begin\n-      if Controller /= null then\n-         Attach_To_Final_List (L, Controller.all, B);\n-      end if;\n-\n-      --  Is controlled\n-\n-      if V.all in Finalizable then\n-         Attach_To_Final_List (L, V.all, B);\n-      end if;\n-   end Deep_Tag_Attach;\n-\n-   -----------------------------\n-   -- Detach_From_Final_List --\n-   -----------------------------\n-\n-   --  We know that the detach object is neither at the beginning nor at the\n-   --  end of the list, thanks to the dummy First and Last Elements, but the\n-   --  object may not be attached at all if it is Finalize_Storage_Only\n-\n-   procedure Detach_From_Final_List (Obj : in out Finalizable) is\n-   begin\n-      --  When objects are not properly attached to a doubly linked list do\n-      --  not try to detach them. The only case where it can happen is when\n-      --  dealing with Finalize_Storage_Only objects which are not always\n-      --  attached to the finalization list.\n-\n-      if Obj.Next /= null and then Obj.Prev /= null then\n-         SSL.Lock_Task.all;\n-         Obj.Next.Prev := Obj.Prev;\n-         Obj.Prev.Next := Obj.Next;\n-\n-         --  Reset the pointers so that a new finalization of the same object\n-         --  has no effect on the finalization list.\n-\n-         Obj.Next := null;\n-         Obj.Prev := null;\n-\n-         SSL.Unlock_Task.all;\n-      end if;\n-\n-   exception\n-      when others =>\n-         SSL.Unlock_Task.all;\n-         raise;\n-   end Detach_From_Final_List;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   overriding procedure Finalize (Object : in out Limited_Record_Controller) is\n-   begin\n-      Finalize_List (Object.F);\n-   end Finalize;\n-\n-   --------------------------\n-   -- Finalize_Global_List --\n-   --------------------------\n-\n-   procedure Finalize_Global_List is\n-   begin\n-      --  There are three case here:\n-\n-      --  a. the application uses tasks, in which case Finalize_Global_Tasks\n-      --     will defer abort.\n-\n-      --  b. the application doesn't use tasks but uses other tasking\n-      --     constructs, such as ATCs and protected objects. In this case,\n-      --     the binder will call Finalize_Global_List instead of\n-      --     Finalize_Global_Tasks, letting abort undeferred, and leading\n-      --     to assertion failures in the GNULL\n-\n-      --  c. the application doesn't use any tasking construct in which case\n-      --     deferring abort isn't necessary.\n-\n-      --  Until another solution is found to deal with case b, we need to\n-      --  call abort_defer here to pass the checks, but we do not need to\n-      --  undefer abort, since Finalize_Global_List is the last procedure\n-      --  called before exiting the partition.\n-\n-      SSL.Abort_Defer.all;\n-      Finalize_List (Global_Final_List);\n-   end Finalize_Global_List;\n-\n-   -------------------\n-   -- Finalize_List --\n-   -------------------\n-\n-   procedure Finalize_List (L : Finalizable_Ptr) is\n-      P : Finalizable_Ptr := L;\n-      Q : Finalizable_Ptr;\n-\n-      type Fake_Exception_Occurrence is record\n-         Id : Exception_Id;\n-      end record;\n-      type Ptr is access all Fake_Exception_Occurrence;\n-\n-      function To_Ptr is new\n-        Ada.Unchecked_Conversion (Exception_Occurrence_Access, Ptr);\n-\n-      X :  Exception_Id := Null_Id;\n-\n-   begin\n-      --  If abort is allowed, we get the current exception before starting\n-      --  to finalize in order to check if we are in the abort case if an\n-      --  exception is raised. When abort is not allowed, avoid accessing the\n-      --  current exception since this can be a pretty costly operation in\n-      --  programs using controlled types heavily.\n-\n-      if System.Restrictions.Abort_Allowed then\n-         X := To_Ptr (SSL.Get_Current_Excep.all).Id;\n-      end if;\n-\n-      while P /= null loop\n-         Q := P.Next;\n-         Finalize (P.all);\n-         P := Q;\n-      end loop;\n-\n-   exception\n-      when E_Occ : others =>\n-         Raise_From_Finalize (\n-           Q,\n-           X = Standard'Abort_Signal'Identity,\n-           E_Occ);\n-   end Finalize_List;\n-\n-   ------------------\n-   -- Finalize_One --\n-   ------------------\n-\n-   procedure Finalize_One (Obj : in out  Finalizable) is\n-   begin\n-      Detach_From_Final_List (Obj);\n-      Finalize (Obj);\n-   exception\n-      when E_Occ : others => Raise_From_Finalize (null, False, E_Occ);\n-   end Finalize_One;\n-\n-   -------------------------\n-   -- Get_Deep_Controller --\n-   -------------------------\n-\n-   function Get_Deep_Controller (Obj : System.Address) return RC_Ptr is\n-      The_Tag : Ada.Tags.Tag := To_Finalizable_Ptr (Obj)'Tag;\n-      Offset  : SSE.Storage_Offset := RC_Offset (The_Tag);\n-\n-   begin\n-      --  Fetch the controller from the Parent or above if necessary\n-      --  when there are no controller at this level.\n-\n-      while Offset = -2 loop\n-         The_Tag := Ada.Tags.Parent_Tag (The_Tag);\n-         Offset  := RC_Offset (The_Tag);\n-      end loop;\n-\n-      --  No Controlled component case\n-\n-      if Offset = 0 then\n-         return null;\n-\n-      --  The _controller Offset is known statically\n-\n-      elsif Offset > 0 then\n-         return To_RC_Ptr (Obj + Offset);\n-\n-      --  At this stage, we know that the controller is part of the\n-      --  ancestor corresponding to the tag \"The_Tag\" and that its parent\n-      --  is variable sized. We assume that the _controller is the first\n-      --  component right after the parent.\n-\n-      --  ??? note that it may not be true if there are new discriminants\n-\n-      else --  Offset = -1\n-\n-         declare\n-            --  define a faked record controller to avoid generating\n-            --  unnecessary expanded code for controlled types\n-\n-            type Faked_Record_Controller is record\n-               Tag, Prec, Next : Address;\n-            end record;\n-\n-            --  Reconstruction of a type with characteristics\n-            --  comparable to the original type\n-\n-            D : constant := SSE.Storage_Offset (Storage_Unit - 1);\n-\n-            type Parent_Type is new SSE.Storage_Array\n-                   (1 .. (Parent_Size (Obj, The_Tag) + D) /\n-                            SSE.Storage_Offset (Storage_Unit));\n-            for Parent_Type'Alignment use Address'Alignment;\n-\n-            type Faked_Type_Of_Obj is record\n-               Parent : Parent_Type;\n-               Controller : Faked_Record_Controller;\n-            end record;\n-\n-            type Obj_Ptr is access all Faked_Type_Of_Obj;\n-            function To_Obj_Ptr is\n-              new Ada.Unchecked_Conversion (Address, Obj_Ptr);\n-\n-         begin\n-            return To_RC_Ptr (To_Obj_Ptr (Obj).Controller'Address);\n-         end;\n-      end if;\n-   end Get_Deep_Controller;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   overriding procedure Initialize\n-     (Object : in out Limited_Record_Controller)\n-   is\n-      pragma Warnings (Off, Object);\n-   begin\n-      null;\n-   end Initialize;\n-\n-   overriding procedure Initialize (Object : in out Record_Controller) is\n-   begin\n-      Object.My_Address := Object'Address;\n-   end Initialize;\n-\n-   ---------------------\n-   -- Move_Final_List --\n-   ---------------------\n-\n-   procedure Move_Final_List\n-     (From : in out SFR.Finalizable_Ptr;\n-      To   : Finalizable_Ptr_Ptr)\n-   is\n-   begin\n-      --  This is currently called at the end of the return statement, and the\n-      --  caller does NOT defer aborts. We need to defer aborts to prevent\n-      --  mangling the finalization lists.\n-\n-      SSL.Abort_Defer.all;\n-\n-      --  Put the return statement's finalization list onto the caller's one,\n-      --  thus transferring responsibility for finalization of the return\n-      --  object to the caller.\n-\n-      Attach_To_Final_List (To.all, From.all, Nb_Link => 3);\n-\n-      --  Empty the return statement's finalization list, so that when the\n-      --  cleanup code executes, there will be nothing to finalize.\n-      From := null;\n-\n-      SSL.Abort_Undefer.all;\n-   end Move_Final_List;\n-\n-   -------------------------\n-   -- Raise_From_Finalize --\n-   -------------------------\n-\n-   procedure Raise_From_Finalize\n-     (L          : Finalizable_Ptr;\n-      From_Abort : Boolean;\n-      E_Occ      : Exception_Occurrence)\n-   is\n-      P : Finalizable_Ptr := L;\n-      Q : Finalizable_Ptr;\n-\n-   begin\n-      --  We already got an exception. We now finalize the remainder of\n-      --  the list, ignoring all further exceptions.\n-\n-      while P /= null loop\n-         Q := P.Next;\n-\n-         begin\n-            Finalize (P.all);\n-         exception\n-            when others => null;\n-         end;\n-\n-         P := Q;\n-      end loop;\n-\n-      if From_Abort then\n-         --  If finalization from an Abort, then nothing to do\n-\n-         null;\n-\n-      else\n-         --  Else raise Program_Error with an appropriate message\n-\n-         Raise_From_Controlled_Operation (E_Occ);\n-      end if;\n-   end Raise_From_Finalize;\n-\n---  Initialization of package, set Adafinal soft link\n-\n-begin\n-   SSL.Finalize_Global_List := Finalize_Global_List'Access;\n-end System.Finalization_Implementation;"}, {"sha": "944fe6f114cbdbb4aa829c332753a83aec80a9a6", "filename": "gcc/ada/s-finimp.ads", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de29d8500c2f9f5f164032ae5c3a5477dcc45c51/gcc%2Fada%2Fs-finimp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de29d8500c2f9f5f164032ae5c3a5477dcc45c51/gcc%2Fada%2Fs-finimp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finimp.ads?ref=de29d8500c2f9f5f164032ae5c3a5477dcc45c51", "patch": "@@ -1,158 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---    S Y S T E M . F I N A L I Z A T I O N _ I M P L E M E N T A T I O N   --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Unchecked_Conversion;\n-\n-with System.Storage_Elements;\n-with System.Finalization_Root;\n-\n-package System.Finalization_Implementation is\n-   pragma Elaborate_Body;\n-\n-   package SSE renames System.Storage_Elements;\n-   package SFR renames System.Finalization_Root;\n-\n-   ------------------------------------------------\n-   -- Finalization Management Abstract Interface --\n-   ------------------------------------------------\n-\n-   function To_Finalizable_Ptr is new Ada.Unchecked_Conversion\n-     (Source => System.Address, Target => SFR.Finalizable_Ptr);\n-\n-   Collection_Finalization_Started : constant SFR.Finalizable_Ptr :=\n-                                       To_Finalizable_Ptr (SSE.To_Address (1));\n-   --  This is used to implement the rule in RM 4.8(10.2/2) that requires an\n-   --  allocator to raise Program_Error if the collection finalization has\n-   --  already started. See also Ada.Finalization.List_Controller. Finalize on\n-   --  List_Controller first sets the list to Collection_Finalization_Started,\n-   --  to indicate that finalization has started. An allocator will call\n-   --  Attach_To_Final_List, which checks for the special value and raises\n-   --  Program_Error if appropriate. The Collection_Finalization_Started value\n-   --  must be different from 'Access of any finalizable object, and different\n-   --  from null. See AI-280.\n-\n-   Global_Final_List : SFR.Finalizable_Ptr;\n-   --  This list stores the controlled objects defined in library-level\n-   --  packages. They will be finalized after the main program completion.\n-\n-   procedure Finalize_Global_List;\n-   --  The procedure to be called in order to finalize the global list\n-\n-   procedure Attach_To_Final_List\n-     (L       : in out SFR.Finalizable_Ptr;\n-      Obj     : in out SFR.Finalizable;\n-      Nb_Link : Short_Short_Integer);\n-   --  Attach finalizable object Obj to the linked list L. Nb_Link controls the\n-   --  number of link of the linked_list, and is one of: 0 for no attachment, 1\n-   --  for simple linked lists or 2 for doubly linked lists or even 3 for a\n-   --  simple attachment of a whole array of elements. Attachment to a simply\n-   --  linked list is not protected against concurrent access and should only\n-   --  be used in contexts where it doesn't matter, such as for objects\n-   --  allocated on the stack. In the case of an attachment on a doubly linked\n-   --  list, L must not be null and Obj will be inserted AFTER the first\n-   --  element and the attachment is protected against concurrent call.\n-   --  Typically used to attach to a dynamically allocated object to a\n-   --  List_Controller (whose first element is always a dummy element)\n-\n-   type Finalizable_Ptr_Ptr is access all SFR.Finalizable_Ptr;\n-   --  A pointer to a finalization list. This is used as the type of the extra\n-   --  implicit formal which are passed to build-in-place functions that return\n-   --  controlled types (see Sem_Ch6). That extra formal is then passed on to\n-   --  Move_Final_List (below).\n-\n-   procedure Move_Final_List\n-     (From : in out SFR.Finalizable_Ptr;\n-      To   : Finalizable_Ptr_Ptr);\n-   --  Move all objects on From list to To list. This is used to implement\n-   --  build-in-place function returns. The return object is initially placed\n-   --  on a finalization list local to the return statement, in case the\n-   --  return statement is left prematurely (due to raising an exception,\n-   --  being aborted, or a goto or exit statement). Once the return statement\n-   --  has completed successfully, Move_Final_List is called to move the\n-   --  return object to the caller's finalization list.\n-\n-   procedure Finalize_List (L : SFR.Finalizable_Ptr);\n-   --  Call Finalize on each element of the list L\n-\n-   procedure Finalize_One (Obj  : in out SFR.Finalizable);\n-   --  Call Finalize on Obj and remove its final list\n-\n-   ---------------------\n-   -- Deep Procedures --\n-   ---------------------\n-\n-   procedure Deep_Tag_Attach\n-     (L : in out SFR.Finalizable_Ptr;\n-      A : System.Address;\n-      B : Short_Short_Integer);\n-   --  Generic attachment for tagged objects with controlled components.\n-   --  A is the address of the object, L the finalization list when it needs\n-   --  to be attached and B the attachment level (see Attach_To_Final_List).\n-\n-   -----------------------------\n-   -- Record Controller Types --\n-   -----------------------------\n-\n-   --  Definition of the types of the controller component that is included\n-   --  in records containing controlled components. This controller is\n-   --  attached to the finalization chain of the upper-level and carries\n-   --  the pointer of the finalization chain for the lower level.\n-\n-   type Limited_Record_Controller is new SFR.Root_Controlled with record\n-      F : SFR.Finalizable_Ptr;\n-   end record;\n-\n-   overriding procedure Initialize (Object : in out Limited_Record_Controller);\n-   --  Does nothing currently\n-\n-   overriding procedure Finalize (Object : in out Limited_Record_Controller);\n-   --  Finalize the controlled components of the enclosing record by following\n-   --  the list starting at Object.F.\n-\n-   type Record_Controller is\n-      new Limited_Record_Controller with record\n-         My_Address : System.Address;\n-      end record;\n-\n-   overriding procedure Initialize (Object : in out Record_Controller);\n-   --  Initialize the field My_Address to the Object'Address\n-\n-   overriding procedure Adjust (Object : in out Record_Controller);\n-   --  Adjust the components and their finalization pointers by subtracting by\n-   --  the offset of the target and the source addresses of the assignment.\n-\n-   --  Inherit Finalize from Limited_Record_Controller\n-\n-   procedure Detach_From_Final_List (Obj : in out SFR.Finalizable);\n-   --  Remove the specified object from its Final list, which must be a doubly\n-   --  linked list.\n-\n-end System.Finalization_Implementation;"}, {"sha": "4de2b7c0375032dd43e3a7242d92cc179417454c", "filename": "gcc/ada/s-finroo.ads", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-finroo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-finroo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finroo.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,54 +32,29 @@\n --  This unit provides the basic support for controlled (finalizable) types\n \n with Ada.Streams;\n-with Ada.Unchecked_Conversion;\n \n package System.Finalization_Root is\n    pragma Preelaborate;\n \n-   type Root_Controlled is tagged;\n+   --  The base for types Controlled and Limited_Controlled declared in Ada.\n+   --  Finalization.\n \n-   type Finalizable_Ptr is access all Root_Controlled'Class;\n+   type Root_Controlled is tagged null record;\n \n-   function To_Finalizable_Ptr is\n-     new Ada.Unchecked_Conversion (Address, Finalizable_Ptr);\n-\n-   function To_Addr is\n-     new Ada.Unchecked_Conversion (Finalizable_Ptr, Address);\n-\n-   type Empty_Root_Controlled is abstract tagged null record;\n-   --  Just for the sake of Controlled equality (see Ada.Finalization)\n-\n-   type Root_Controlled is new Empty_Root_Controlled with record\n-      Prev, Next : Finalizable_Ptr;\n-   end record;\n-   subtype Finalizable is Root_Controlled'Class;\n-\n-   procedure Initialize (Object : in out Root_Controlled);\n-   procedure Finalize   (Object : in out Root_Controlled);\n    procedure Adjust     (Object : in out Root_Controlled);\n-\n-   --  Stream-oriented attributes for Root_Controlled. These must be empty so\n-   --  as to not copy the finalization chain pointers. They are declared in\n-   --  a nested package so that they do not create primitive operations of\n-   --  Root_Controlled. Otherwise this would add unwanted primitives to (the\n-   --  full view of) Ada.Finalization.Limited_Controlled, which would cause\n-   --  trouble in cases where a limited controlled type is used as the\n-   --  designated type of a remote access-to-classwide type.\n+   procedure Finalize   (Object : in out Root_Controlled);\n+   procedure Initialize (Object : in out Root_Controlled);\n \n    package Stream_Attributes is\n-\n-      procedure Write\n-        (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n-         Item   : Root_Controlled) is null;\n-\n       procedure Read\n         (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n          Item   : out Root_Controlled) is null;\n \n+      procedure Write\n+        (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+         Item   : Root_Controlled) is null;\n    end Stream_Attributes;\n \n-   for Root_Controlled'Read use Stream_Attributes.Read;\n+   for Root_Controlled'Read  use Stream_Attributes.Read;\n    for Root_Controlled'Write use Stream_Attributes.Write;\n-\n end System.Finalization_Root;"}, {"sha": "dc5596272c6b2c698f2901dc1afc9e0e459339bf", "filename": "gcc/ada/s-pooglo.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-pooglo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-pooglo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pooglo.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,7 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Storage_Pools;    use System.Storage_Pools;\n+with System.Storage_Pools; use System.Storage_Pools;\n with System.Memory;\n \n package body System.Pool_Global is\n@@ -40,7 +40,7 @@ package body System.Pool_Global is\n    -- Allocate --\n    --------------\n \n-   procedure Allocate\n+   overriding procedure Allocate\n      (Pool         : in out Unbounded_No_Reclaim_Pool;\n       Address      : out System.Address;\n       Storage_Size : SSE.Storage_Count;\n@@ -69,7 +69,7 @@ package body System.Pool_Global is\n    -- Deallocate --\n    ----------------\n \n-   procedure Deallocate\n+   overriding procedure Deallocate\n      (Pool         : in out Unbounded_No_Reclaim_Pool;\n       Address      : System.Address;\n       Storage_Size : SSE.Storage_Count;\n@@ -87,7 +87,7 @@ package body System.Pool_Global is\n    -- Storage_Size --\n    ------------------\n \n-   function Storage_Size\n+   overriding function Storage_Size\n      (Pool  : Unbounded_No_Reclaim_Pool)\n       return  SSE.Storage_Count\n    is"}, {"sha": "1c0584451d6dcb117a63bf0c68ee30a75bd7b941", "filename": "gcc/ada/s-soflin.adb", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-soflin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-soflin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -95,9 +95,11 @@ package body System.Soft_Links is\n \n       Task_Termination_Handler.all (Ada.Exceptions.Null_Occurrence);\n \n-      --  Finalize the global list for controlled objects if needed\n+      --  Finalize all library-level controlled objects if needed\n \n-      Finalize_Global_List.all;\n+      if Finalize_Library_Objects /=  null then\n+         Finalize_Library_Objects.all;\n+      end if;\n    end Adafinal_NT;\n \n    ---------------------------\n@@ -243,14 +245,19 @@ package body System.Soft_Links is\n       return NT_TSD.Pri_Stack_Info'Access;\n    end Get_Stack_Info_NT;\n \n-   -------------------------------\n-   -- Null_Finalize_Global_List --\n-   -------------------------------\n+   -----------------------------\n+   -- Save_Library_Occurrence --\n+   -----------------------------\n \n-   procedure Null_Finalize_Global_List is\n+   procedure Save_Library_Occurrence\n+     (E : Ada.Exceptions.Exception_Occurrence)\n+   is\n    begin\n-      null;\n-   end Null_Finalize_Global_List;\n+      if not Library_Exception_Set then\n+         Library_Exception_Set := True;\n+         Ada.Exceptions.Save_Occurrence (Library_Exception, E);\n+      end if;\n+   end Save_Library_Occurrence;\n \n    ---------------------------\n    -- Set_Jmpbuf_Address_NT --"}, {"sha": "7f8de10dce03f9332bf2122c22d75a31b9a83f7f", "filename": "gcc/ada/s-soflin.ads", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-soflin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-soflin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,6 +59,11 @@ package System.Soft_Links is\n \n    type No_Param_Proc     is access procedure;\n    pragma Favor_Top_Level (No_Param_Proc);\n+   pragma Suppress_Initialization (No_Param_Proc);\n+   --  Some uninitialized objects of that type are initialized by the Binder\n+   --  so it is important that such objects are not reset to null during\n+   --  elaboration\n+\n    type Addr_Param_Proc   is access procedure (Addr : Address);\n    pragma Favor_Top_Level (Addr_Param_Proc);\n    type EO_Param_Proc     is access procedure (Excep : EO);\n@@ -158,9 +163,6 @@ package System.Soft_Links is\n    --  Handle task termination routines for the environment task (non-tasking\n    --  case, does nothing).\n \n-   procedure Null_Finalize_Global_List;\n-   --  Finalize global list for controlled objects (does nothing)\n-\n    procedure Adafinal_NT;\n    --  Shuts down the runtime system (non-tasking case)\n \n@@ -221,8 +223,10 @@ package System.Soft_Links is\n    Task_Termination_Handler : EO_Param_Proc := Task_Termination_NT'Access;\n    --  Handle task termination routines (task/non-task case as appropriate)\n \n-   Finalize_Global_List : No_Param_Proc := Null_Finalize_Global_List'Access;\n-   --  Performs finalization of global list for controlled objects\n+   Finalize_Library_Objects : No_Param_Proc;\n+   pragma Export (C, Finalize_Library_Objects,\n+                  \"__gnat_finalize_library_objects\");\n+   --  will be initialized by the binder\n \n    Adafinal : No_Param_Proc := Adafinal_NT'Access;\n    --  Performs the finalization of the Ada Runtime\n@@ -287,6 +291,16 @@ package System.Soft_Links is\n    -- Exception Tracebacks Soft-Links --\n    -------------------------------------\n \n+   Library_Exception : EO;\n+   pragma Export (Ada, Library_Exception, \"__gnat_library_exception\");\n+   --  Library-level finalization routines use this common reference to store\n+   --  the first library-level exception which occurs during finalization.\n+\n+   Library_Exception_Set : Boolean := False;\n+   pragma Export (Ada, Library_Exception_Set, \"__gnat_library_exception_set\");\n+   --  Used in conjunction with Library_Exception, set when an exception has\n+   --  been stored.\n+\n    Traceback_Decorator_Wrapper : Traceback_Decorator_Wrapper_Call;\n    --  Wrapper to the possible user specified traceback decorator to be\n    --  called during automatic output of exception data.\n@@ -301,6 +315,10 @@ package System.Soft_Links is\n    --  See the body of Tailored_Exception_Traceback in Ada.Exceptions for\n    --  a more detailed description of the potential problems.\n \n+   procedure Save_Library_Occurrence (E : Ada.Exceptions.Exception_Occurrence);\n+   --  When invoked, this routine saves an exception occurrence into a hidden\n+   --  reference. Subsequent calls will have no effect.\n+\n    ------------------------\n    -- Task Specific Data --\n    ------------------------"}, {"sha": "34e32915bd4dc288d6f40d8063f11ec4e5bff814", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2010, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,8 +56,8 @@ with System.Soft_Links;\n --  These are procedure pointers to non-tasking routines that use task\n --  specific data. In the absence of tasking, these routines refer to global\n --  data. In the presence of tasking, they must be replaced with pointers to\n---  task-specific versions. Also used for Create_TSD, Destroy_TSD,\n---  Get_Current_Excep, Finalize_Global_List, Task_Termination, Handler.\n+--  task-specific versions. Also used for Create_TSD, Destroy_TSD, Get_Current\n+--  _Excep, Finalize_Library_Objects, Task_Termination, Handler.\n \n with System.Tasking.Initialization;\n pragma Elaborate_All (System.Tasking.Initialization);\n@@ -854,9 +854,11 @@ package body System.Tasking.Stages is\n \n       SSL.Task_Termination_Handler.all (Ada.Exceptions.Null_Occurrence);\n \n-      --  Finalize the global list for controlled objects if needed\n+      --  Finalize all library-level controlled objects\n \n-      SSL.Finalize_Global_List.all;\n+      if not SSL.\"=\" (SSL.Finalize_Library_Objects, null) then\n+         SSL.Finalize_Library_Objects.all;\n+      end if;\n \n       --  Reset the soft links to non-tasking\n "}, {"sha": "050930bfa03c40a7f99f73abf850c537b977034d", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -4197,7 +4197,6 @@ package body Sem_Aggr is\n \n                   elsif Chars (Selectr) /= Name_uTag\n                     and then Chars (Selectr) /= Name_uParent\n-                    and then Chars (Selectr) /= Name_uController\n                   then\n                      if not Has_Discriminants (Typ) then\n                         Error_Msg_Node_2 := Typ;"}, {"sha": "8c54517c236f6e41b558a2d180ebd60a24a34936", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -216,16 +216,12 @@ package body Sem_Aux is\n \n       --  The discriminants are not necessarily contiguous, because access\n       --  discriminants will generate itypes. They are not the first entities\n-      --  either, because tag and controller record must be ahead of them.\n+      --  either because the tag must be ahead of them.\n \n       if Chars (Ent) = Name_uTag then\n          Ent := Next_Entity (Ent);\n       end if;\n \n-      if Chars (Ent) = Name_uController then\n-         Ent := Next_Entity (Ent);\n-      end if;\n-\n       --  Skip all hidden stored discriminants if any\n \n       while Present (Ent) loop\n@@ -289,17 +285,11 @@ package body Sem_Aux is\n          Ent := Next_Entity (Ent);\n       end if;\n \n-      if Chars (Ent) = Name_uController then\n-         Ent := Next_Entity (Ent);\n-      end if;\n-\n       if Has_Completely_Hidden_Discriminant (Ent) then\n-\n          while Present (Ent) loop\n             exit when Is_Completely_Hidden (Ent);\n             Ent := Next_Entity (Ent);\n          end loop;\n-\n       end if;\n \n       pragma Assert (Ekind (Ent) = E_Discriminant);"}, {"sha": "03ff2fef5348dc67ae7e78fd97fc47097fed7efd", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -106,7 +106,7 @@ package Sem_Aux is\n \n    function Enclosing_Dynamic_Scope (Ent : Entity_Id) return Entity_Id;\n    --  For any entity, Ent, returns the closest dynamic scope in which the\n-   --  entity is declared or Standard_Standard for library-level entities\n+   --  entity is declared or Standard_Standard for library-level entities.\n \n    function First_Discriminant (Typ : Entity_Id) return Entity_Id;\n    --  Typ is a type with discriminants. The discriminants are the first"}, {"sha": "e2e566dda68a2e2578dd7d93118e75578b635e5a", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -5267,9 +5267,11 @@ package body Sem_Ch10 is\n       procedure Decorate_Tagged_Type\n         (Loc  : Source_Ptr;\n          T    : Entity_Id;\n-         Scop : Entity_Id);\n-      --  Set basic attributes of tagged type T, including its class_wide type.\n-      --  The parameters Loc, Scope are used to decorate the class_wide type.\n+         Scop : Entity_Id;\n+         Mark : Boolean := False);\n+      --  Set basic attributes of tagged type T, including its class-wide type.\n+      --  The parameters Loc, Scope are used to decorate the class-wide type.\n+      --  Use flag Mark to label the class-wide type as Materialize_Entity.\n \n       procedure Build_Chain (Scope : Entity_Id; First_Decl : Node_Id);\n       --  Construct list of shadow entities and attach it to entity of\n@@ -5327,7 +5329,7 @@ package body Sem_Ch10 is\n \n                if not Analyzed_Unit then\n                   if Is_Tagged then\n-                     Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope);\n+                     Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope, True);\n                   else\n                      Decorate_Incomplete_Type (Comp_Typ, Scope);\n                   end if;\n@@ -5367,7 +5369,7 @@ package body Sem_Ch10 is\n \n                if not Analyzed_Unit then\n                   if Is_Tagged then\n-                     Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope);\n+                     Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope, True);\n                   else\n                      Decorate_Incomplete_Type (Comp_Typ, Scope);\n                   end if;\n@@ -5395,7 +5397,7 @@ package body Sem_Ch10 is\n                Comp_Typ := Defining_Identifier (Decl);\n \n                if not Analyzed_Unit then\n-                  Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope);\n+                  Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope, True);\n                end if;\n \n                --  Create shadow entity for type\n@@ -5476,7 +5478,8 @@ package body Sem_Ch10 is\n       procedure Decorate_Tagged_Type\n         (Loc  : Source_Ptr;\n          T    : Entity_Id;\n-         Scop : Entity_Id)\n+         Scop : Entity_Id;\n+         Mark : Boolean := False)\n       is\n          CW : Entity_Id;\n \n@@ -5490,7 +5493,7 @@ package body Sem_Ch10 is\n          --  and the full-view.\n \n          if No (Class_Wide_Type (T)) then\n-            CW := Make_Temporary (Loc, 'S');\n+            CW := New_External_Entity (E_Void, Scope (T), Loc, T, 'C', 0, 'T');\n \n             --  Set parent to be the same as the parent of the tagged type.\n             --  We need a parent field set, and it is supposed to point to\n@@ -5514,6 +5517,7 @@ package body Sem_Ch10 is\n             Set_Class_Wide_Type           (CW, CW);\n             Set_Equivalent_Type           (CW, Empty);\n             Set_From_With_Type            (CW, From_With_Type (T));\n+            Set_Materialize_Entity        (CW, Mark);\n \n             --  Link type to its class-wide type\n "}, {"sha": "53f79cb3ac126ca96750bccabdd542c01c391834", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -210,15 +210,6 @@ package body Sem_Ch11 is\n                Push_Scope (H_Scope);\n                Set_Etype (H_Scope, Standard_Void_Type);\n \n-               --  Set the Finalization Chain entity to Error means that it\n-               --  should not be used at that level but the parent one should\n-               --  be used instead.\n-\n-               --  ??? this usage needs documenting in Einfo/Exp_Ch7 ???\n-               --  ??? using Error for this non-error condition is nasty ???\n-\n-               Set_Finalization_Chain_Entity (H_Scope, Error);\n-\n                Enter_Name (Choice);\n                Set_Ekind (Choice, E_Variable);\n "}, {"sha": "42303e7d02a729ccf5095628e9055e1d835616dd", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 66, "deletions": 43, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -781,7 +781,7 @@ package body Sem_Ch3 is\n \n       Anon_Type :=\n         Create_Itype\n-         (E_Anonymous_Access_Type, Related_Nod, Scope_Id => Anon_Scope);\n+          (E_Anonymous_Access_Type, Related_Nod, Scope_Id => Anon_Scope);\n \n       if All_Present (N)\n         and then Ada_Version >= Ada_2005\n@@ -1279,8 +1279,11 @@ package body Sem_Ch3 is\n    ----------------------------\n \n    procedure Access_Type_Declaration (T : Entity_Id; Def : Node_Id) is\n-      S : constant Node_Id := Subtype_Indication (Def);\n       P : constant Node_Id := Parent (Def);\n+      S : constant Node_Id := Subtype_Indication (Def);\n+\n+      Full_Desig : Entity_Id;\n+\n    begin\n       Check_SPARK_Restriction (\"access type is not allowed\", Def);\n \n@@ -1307,15 +1310,17 @@ package body Sem_Ch3 is\n          Set_Ekind (T, E_Access_Type);\n       end if;\n \n-      if Base_Type (Designated_Type (T)) = T then\n+      Full_Desig := Designated_Type (T);\n+\n+      if Base_Type (Full_Desig) = T then\n          Error_Msg_N (\"access type cannot designate itself\", S);\n \n       --  In Ada 2005, the type may have a limited view through some unit\n       --  in its own context, allowing the following circularity that cannot\n       --  be detected earlier\n \n-      elsif Is_Class_Wide_Type (Designated_Type (T))\n-        and then Etype (Designated_Type (T)) = T\n+      elsif Is_Class_Wide_Type (Full_Desig)\n+        and then Etype (Full_Desig) = T\n       then\n          Error_Msg_N\n            (\"access type cannot designate its own classwide type\", S);\n@@ -1341,12 +1346,19 @@ package body Sem_Ch3 is\n       Set_Has_Task (T, False);\n       Set_Has_Controlled_Component (T, False);\n \n-      --  Initialize Associated_Final_Chain explicitly to Empty, to avoid\n+      --  Initialize Associated_Collection explicitly to Empty, to avoid\n       --  problems where an incomplete view of this entity has been previously\n       --  established by a limited with and an overlaid version of this field\n       --  (Stored_Constraint) was initialized for the incomplete view.\n \n-      Set_Associated_Final_Chain (T, Empty);\n+      --  This reset is performed in most cases except where the access type\n+      --  has been created for the purposes of allocating or deallocating a\n+      --  build-in-place object. Such access types have explicitly set pools\n+      --  and collections.\n+\n+      if No (Associated_Storage_Pool (T)) then\n+         Set_Associated_Collection (T, Empty);\n+      end if;\n \n       --  Ada 2005 (AI-231): Propagate the null-excluding and access-constant\n       --  attributes\n@@ -2537,7 +2549,7 @@ package body Sem_Ch3 is\n       --  subtypes will be built after the full view of the type.\n \n       Set_Private_Dependents (T, New_Elmt_List);\n-      Set_Is_Pure (T, F);\n+      Set_Is_Pure            (T, F);\n    end Analyze_Incomplete_Type_Decl;\n \n    -----------------------------------\n@@ -6980,35 +6992,32 @@ package body Sem_Ch3 is\n       Derived_Type : Entity_Id;\n       Derive_Subps : Boolean := True)\n    is\n-      Loc          : constant Source_Ptr := Sloc (N);\n-      Parent_Base  : Entity_Id;\n-      Type_Def     : Node_Id;\n-      Indic        : Node_Id;\n-      Discrim      : Entity_Id;\n-      Last_Discrim : Entity_Id;\n-      Constrs      : Elist_Id;\n-\n-      Discs : Elist_Id := New_Elmt_List;\n-      --  An empty Discs list means that there were no constraints in the\n-      --  subtype indication or that there was an error processing it.\n-\n-      Assoc_List : Elist_Id;\n-      New_Discrs : Elist_Id;\n-      New_Base   : Entity_Id;\n-      New_Decl   : Node_Id;\n-      New_Indic  : Node_Id;\n-\n-      Is_Tagged          : constant Boolean := Is_Tagged_Type (Parent_Type);\n       Discriminant_Specs : constant Boolean :=\n                              Present (Discriminant_Specifications (N));\n+      Is_Tagged          : constant Boolean := Is_Tagged_Type (Parent_Type);\n+      Loc                : constant Source_Ptr := Sloc (N);\n       Private_Extension  : constant Boolean :=\n                              Nkind (N) = N_Private_Extension_Declaration;\n-\n+      Assoc_List         : Elist_Id;\n       Constraint_Present : Boolean;\n+      Constrs            : Elist_Id;\n+      Discrim            : Entity_Id;\n+      Indic              : Node_Id;\n       Inherit_Discrims   : Boolean := False;\n+      Last_Discrim       : Entity_Id;\n+      New_Base           : Entity_Id;\n+      New_Decl           : Node_Id;\n+      New_Discrs         : Elist_Id;\n+      New_Indic          : Node_Id;\n+      Parent_Base        : Entity_Id;\n       Save_Etype         : Entity_Id;\n       Save_Discr_Constr  : Elist_Id;\n       Save_Next_Entity   : Entity_Id;\n+      Type_Def           : Node_Id;\n+\n+      Discs : Elist_Id := New_Elmt_List;\n+      --  An empty Discs list means that there were no constraints in the\n+      --  subtype indication or that there was an error processing it.\n \n    begin\n       if Ekind (Parent_Type) = E_Record_Type_With_Private\n@@ -8586,7 +8595,7 @@ package body Sem_Ch3 is\n       end if;\n \n       if Is_Tagged_Type (T) then\n-         Set_Is_Tagged_Type  (Def_Id);\n+         Set_Is_Tagged_Type (Def_Id);\n          Make_Class_Wide_Type (Def_Id);\n       end if;\n \n@@ -12194,8 +12203,8 @@ package body Sem_Ch3 is\n             Next_Discriminant (Old_C);\n          end loop;\n \n-         --  The tag, and the possible parent and controller components\n-         --  are unconditionally in the subtype.\n+         --  The tag and the possible parent component are unconditionally in\n+         --  the subtype.\n \n          if Is_Tagged_Type (Typ)\n            or else Has_Controlled_Component (Typ)\n@@ -12204,7 +12213,6 @@ package body Sem_Ch3 is\n             while Present (Old_C) loop\n                if Chars ((Old_C)) = Name_uTag\n                  or else Chars ((Old_C)) = Name_uParent\n-                 or else Chars ((Old_C)) = Name_uController\n                then\n                   Append_Elmt (Old_C, Comp_List);\n                end if;\n@@ -12470,7 +12478,6 @@ package body Sem_Ch3 is\n                if Original_Record_Component (Old_C) = Old_C\n                 and then Chars (Old_C) /= Name_uTag\n                 and then Chars (Old_C) /= Name_uParent\n-                and then Chars (Old_C) /= Name_uController\n                then\n                   Append_Elmt (Old_C, Comp_List);\n                end if;\n@@ -16187,15 +16194,31 @@ package body Sem_Ch3 is\n       Next_E  : Entity_Id;\n \n    begin\n-      --  The class wide type can have been defined by the partial view, in\n-      --  which case everything is already done.\n-\n       if Present (Class_Wide_Type (T)) then\n-         return;\n-      end if;\n \n-      CW_Type :=\n-        New_External_Entity (E_Void, Scope (T), Sloc (T), T, 'C', 0, 'T');\n+         --  The class-wide type is a partially decorated entity created for a\n+         --  unanalyzed tagged type referenced through a limited with clause.\n+         --  When the tagged type is analyzed, its class-wide type needs to be\n+         --  redecorated. Note that we reuse the entity created by Decorate_\n+         --  Tagged_Type in order to preserve all links.\n+\n+         if Materialize_Entity (Class_Wide_Type (T)) then\n+            CW_Type := Class_Wide_Type (T);\n+            Set_Materialize_Entity (CW_Type, False);\n+\n+         --  The class wide type can have been defined by the partial view, in\n+         --  which case everything is already done.\n+\n+         else\n+            return;\n+         end if;\n+\n+      --  Default case, we need to create a new class-wide type\n+\n+      else\n+         CW_Type :=\n+           New_External_Entity (E_Void, Scope (T), Sloc (T), T, 'C', 0, 'T');\n+      end if;\n \n       --  Inherit root type characteristics\n \n@@ -17367,10 +17390,10 @@ package body Sem_Ch3 is\n             Set_Is_Limited_Record (Full_T);\n \n          --  GNAT allow its own definition of Limited_Controlled to disobey\n-         --  this rule in order in ease the implementation. The next test is\n-         --  safe because Root_Controlled is defined in a private system child\n+         --  this rule in order in ease the implementation. This test is safe\n+         --  because Root_Controlled is defined in a private system child.\n \n-         elsif Etype (Full_T) = Full_View (RTE (RE_Root_Controlled)) then\n+         elsif Is_RTE (Etype (Full_T), RE_Root_Controlled) then\n             Set_Is_Limited_Composite (Full_T);\n          else\n             Error_Msg_N"}, {"sha": "dd527b24070d7ac77e0fbe77ea9572d055499d59", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -2897,9 +2897,9 @@ package body Sem_Ch4 is\n          Actual := First_Actual (N);\n          Formal := First_Formal (Nam);\n \n-         --  If we are analyzing a call rewritten from object notation,\n-         --  skip first actual, which may be rewritten later as an\n-         --  explicit dereference.\n+         --  If we are analyzing a call rewritten from object notation, skip\n+         --  first actual, which may be rewritten later as an explicit\n+         --  dereference.\n \n          if Must_Skip then\n             Next_Actual (Actual);\n@@ -3914,7 +3914,7 @@ package body Sem_Ch4 is\n             --  which can appear in expanded code in a tag check.\n \n             if Ekind (Type_To_Use) = E_Record_Type_With_Private\n-              and then  Chars (Selector_Name (N)) /= Name_uTag\n+              and then Chars (Selector_Name (N)) /= Name_uTag\n             then\n                exit when Comp = Last_Entity (Type_To_Use);\n             end if;"}, {"sha": "3169111304356a3071eea483d84d5e937350a5ec", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -1970,6 +1970,10 @@ package body Sem_Ch6 is\n             while Present (Formal) loop\n                Formal_Typ := Etype (Formal);\n \n+               if Is_Class_Wide_Type (Formal_Typ) then\n+                  Formal_Typ := Root_Type (Formal_Typ);\n+               end if;\n+\n                --  From concurrent type to corresponding record\n \n                if To_Corresponding then\n@@ -2061,6 +2065,10 @@ package body Sem_Ch6 is\n             Formal_Typ := Etype (First_Formal (Subp_Id));\n \n             if Is_Concurrent_Record_Type (Formal_Typ) then\n+               if Is_Class_Wide_Type (Formal_Typ) then\n+                  Formal_Typ := Root_Type (Formal_Typ);\n+               end if;\n+\n                Formal_Typ := Corresponding_Concurrent_Type (Formal_Typ);\n             end if;\n \n@@ -6057,24 +6065,15 @@ package body Sem_Ch6 is\n                     E, BIP_Formal_Suffix (BIP_Alloc_Form));\n             end if;\n \n-            --  For functions whose result type has controlled parts, we have\n-            --  an extra formal of type System.Finalization_Implementation.\n-            --  Finalizable_Ptr_Ptr. That is, we are passing a pointer to a\n-            --  finalization list (which is itself a pointer). This extra\n-            --  formal is then passed along to Move_Final_List in case of\n-            --  successful completion of a return statement. We cannot pass an\n-            --  'in out' parameter, because we need to update the finalization\n-            --  list during an abort-deferred region, rather than using\n-            --  copy-back after the function returns. This is true even if we\n-            --  are able to get away with having 'in out' parameters, which are\n-            --  normally illegal for functions. This formal is also needed when\n-            --  the function has a tagged result.\n-\n-            if Needs_BIP_Final_List (E) then\n+            --  In the case of functions whose result type needs finalization,\n+            --  add an extra formal of type Ada.Finalization.Heap_Management.\n+            --  Finalization_Collection_Ptr.\n+\n+            if Needs_BIP_Collection (E) then\n                Discard :=\n                  Add_Extra_Formal\n-                   (E, RTE (RE_Finalizable_Ptr_Ptr),\n-                    E, BIP_Formal_Suffix (BIP_Final_List));\n+                   (E, RTE (RE_Finalization_Collection_Ptr),\n+                    E, BIP_Formal_Suffix (BIP_Collection));\n             end if;\n \n             --  If the result type contains tasks, we have two extra formals:"}, {"sha": "3256ae89b3c66ad4e2723438c00c6f2dc29e9012", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -914,7 +914,8 @@ package body Sem_Ch8 is\n               (Designated_Type (T), Designated_Type (Etype (Nam)));\n \n          elsif not Subtypes_Statically_Match\n-                     (Designated_Type (T), Designated_Type (Etype (Nam)))\n+                     (Designated_Type (T),\n+                      Available_View (Designated_Type (Etype (Nam))))\n          then\n             Error_Msg_N\n               (\"subtype of renamed object does not statically match\", N);\n@@ -5629,18 +5630,21 @@ package body Sem_Ch8 is\n                then\n                   --  Do not build the subtype when referencing components of\n                   --  dispatch table wrappers. Required to avoid generating\n-                  --  elaboration code with HI runtimes.\n+                  --  elaboration code with HI runtimes. JVM and .NET use a\n+                  --  modified version of Ada.Tags which does not contain RE_\n+                  --  Dispatch_Table_Wrapper and RE_No_Dispatch_Table_Wrapper.\n+                  --  Avoid raising RE_Not_Available exception in those cases.\n \n-                  if RTU_Loaded (Ada_Tags)\n-                    and then RTE_Available (RE_Dispatch_Table_Wrapper)\n-                    and then Scope (Selector) = RTE (RE_Dispatch_Table_Wrapper)\n-                  then\n-                     C_Etype := Empty;\n-\n-                  elsif RTU_Loaded (Ada_Tags)\n-                    and then RTE_Available (RE_No_Dispatch_Table_Wrapper)\n-                    and then Scope (Selector)\n-                               = RTE (RE_No_Dispatch_Table_Wrapper)\n+                  if VM_Target = No_VM\n+                    and then RTU_Loaded (Ada_Tags)\n+                    and then\n+                      ((RTE_Available (RE_Dispatch_Table_Wrapper)\n+                          and then Scope (Selector) =\n+                                     RTE (RE_Dispatch_Table_Wrapper))\n+                      or else\n+                       (RTE_Available (RE_No_Dispatch_Table_Wrapper)\n+                          and then Scope (Selector) =\n+                                     RTE (RE_No_Dispatch_Table_Wrapper)))\n                   then\n                      C_Etype := Empty;\n "}, {"sha": "96f2ff830c2aae6ff803d06ac8b41a1cd2c6385c", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -893,17 +893,17 @@ package body Sem_Disp is\n            and then Is_Dispatching_Operation (Old_Subp)\n          then\n             pragma Assert\n-             ((Ekind (Subp) = E_Function\n-                and then Is_Dispatching_Operation (Old_Subp)\n-                and then Is_Null_Extension (Base_Type (Etype (Subp))))\n-               or else\n-                (Ekind (Subp) = E_Procedure\n+              ((Ekind (Subp) = E_Function\n+                  and then Is_Dispatching_Operation (Old_Subp)\n+                  and then Is_Null_Extension (Base_Type (Etype (Subp))))\n+              or else\n+               (Ekind (Subp) = E_Procedure\n                   and then Is_Dispatching_Operation (Old_Subp)\n                   and then Present (Alias (Old_Subp))\n                   and then Is_Null_Interface_Primitive\n                              (Ultimate_Alias (Old_Subp)))\n-               or else Get_TSS_Name (Subp) = TSS_Stream_Read\n-               or else Get_TSS_Name (Subp) = TSS_Stream_Write);\n+              or else Get_TSS_Name (Subp) = TSS_Stream_Read\n+              or else Get_TSS_Name (Subp) = TSS_Stream_Write);\n \n             Check_Controlling_Formals (Tagged_Type, Subp);\n             Override_Dispatching_Operation (Tagged_Type, Old_Subp, Subp);\n@@ -1283,7 +1283,9 @@ package body Sem_Disp is\n             or else\n           Chars (Subp) = Name_Adjust\n             or else\n-          Chars (Subp) = Name_Finalize)\n+          Chars (Subp) = Name_Finalize\n+            or else\n+          Chars (Subp) = Name_Finalize_Address)\n       then\n          declare\n             F_Node   : constant Node_Id := Freeze_Node (Tagged_Type);\n@@ -1292,15 +1294,17 @@ package body Sem_Disp is\n             Old_Bod  : Node_Id;\n             Old_Spec : Entity_Id;\n \n-            C_Names : constant array (1 .. 3) of Name_Id :=\n+            C_Names : constant array (1 .. 4) of Name_Id :=\n                         (Name_Initialize,\n                          Name_Adjust,\n-                         Name_Finalize);\n+                         Name_Finalize,\n+                         Name_Finalize_Address);\n \n-            D_Names : constant array (1 .. 3) of TSS_Name_Type :=\n+            D_Names : constant array (1 .. 4) of TSS_Name_Type :=\n                         (TSS_Deep_Initialize,\n                          TSS_Deep_Adjust,\n-                         TSS_Deep_Finalize);\n+                         TSS_Deep_Finalize,\n+                         TSS_Finalize_Address);\n \n          begin\n             --  Remove previous controlled function which was constructed and"}, {"sha": "0a676effcfc7f0a61eaf25827b9780435615601f", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -658,11 +658,9 @@ package body Sem_Elab is\n          if Body_Acts_As_Spec then\n             if Is_TSS (Ent, TSS_Deep_Initialize) then\n                declare\n-                  Typ  : Entity_Id;\n+                  Typ  : constant Entity_Id := Etype (First_Formal (Ent));\n                   Init : Entity_Id;\n                begin\n-                  Typ  := Etype (Next_Formal (First_Formal (Ent)));\n-\n                   if not Is_Controlled (Typ) then\n                      return;\n                   else"}, {"sha": "d2b8d3efb3bcd66adbd03c67abe0ca6d5781500c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -37,8 +37,8 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n-with Exp_Ch7;  use Exp_Ch7;\n with Exp_Dist; use Exp_Dist;\n+with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n with Lib.Writ; use Lib.Writ;\n with Lib.Xref; use Lib.Xref;"}, {"sha": "95080c3f94734fcb9206d30e71761604c9b64931", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 6, "deletions": 174, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -28,7 +28,6 @@ with Checks;   use Checks;\n with Debug;    use Debug;\n with Debug_A;  use Debug_A;\n with Einfo;    use Einfo;\n-with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Disp; use Exp_Disp;\n@@ -4020,40 +4019,6 @@ package body Sem_Res is\n       --  If the allocator is an actual in a call, it is allowed to be class-\n       --  wide when the context is not because it is a controlling actual.\n \n-      procedure Propagate_Coextensions (Root : Node_Id);\n-      --  Propagate all nested coextensions which are located one nesting\n-      --  level down the tree to the node Root. Example:\n-      --\n-      --    Top_Record\n-      --       Level_1_Coextension\n-      --          Level_2_Coextension\n-      --\n-      --  The algorithm is paired with delay actions done by the Expander. In\n-      --  the above example, assume all coextensions are controlled types.\n-      --  The cycle of analysis, resolution and expansion will yield:\n-      --\n-      --  1) Analyze Top_Record\n-      --  2) Analyze Level_1_Coextension\n-      --  3) Analyze Level_2_Coextension\n-      --  4) Resolve Level_2_Coextension. The allocator is marked as a\n-      --       coextension.\n-      --  5) Expand Level_2_Coextension. A temporary variable Temp_1 is\n-      --       generated to capture the allocated object. Temp_1 is attached\n-      --       to the coextension chain of Level_2_Coextension.\n-      --  6) Resolve Level_1_Coextension. The allocator is marked as a\n-      --       coextension. A forward tree traversal is performed which finds\n-      --       Level_2_Coextension's list and copies its contents into its\n-      --       own list.\n-      --  7) Expand Level_1_Coextension. A temporary variable Temp_2 is\n-      --       generated to capture the allocated object. Temp_2 is attached\n-      --       to the coextension chain of Level_1_Coextension. Currently, the\n-      --       contents of the list are [Temp_2, Temp_1].\n-      --  8) Resolve Top_Record. A forward tree traversal is performed which\n-      --       finds Level_1_Coextension's list and copies its contents into\n-      --       its own list.\n-      --  9) Expand Top_Record. Generate finalization calls for Temp_1 and\n-      --       Temp_2 and attach them to Top_Record's finalization list.\n-\n       -------------------------------------------\n       -- Check_Allocator_Discrim_Accessibility --\n       -------------------------------------------\n@@ -4107,140 +4072,14 @@ package body Sem_Res is\n \n       function In_Dispatching_Context return Boolean is\n          Par : constant Node_Id := Parent (N);\n-      begin\n-         return Nkind_In (Par, N_Function_Call, N_Procedure_Call_Statement)\n-           and then Is_Entity_Name (Name (Par))\n-           and then Is_Dispatching_Operation (Entity (Name (Par)));\n-      end In_Dispatching_Context;\n-\n-      ----------------------------\n-      -- Propagate_Coextensions --\n-      ----------------------------\n-\n-      procedure Propagate_Coextensions (Root : Node_Id) is\n-\n-         procedure Copy_List (From : Elist_Id; To : Elist_Id);\n-         --  Copy the contents of list From into list To, preserving the\n-         --  order of elements.\n-\n-         function Process_Allocator (Nod : Node_Id) return Traverse_Result;\n-         --  Recognize an allocator or a rewritten allocator node and add it\n-         --  along with its nested coextensions to the list of Root.\n-\n-         ---------------\n-         -- Copy_List --\n-         ---------------\n-\n-         procedure Copy_List (From : Elist_Id; To : Elist_Id) is\n-            From_Elmt : Elmt_Id;\n-         begin\n-            From_Elmt := First_Elmt (From);\n-            while Present (From_Elmt) loop\n-               Append_Elmt (Node (From_Elmt), To);\n-               Next_Elmt (From_Elmt);\n-            end loop;\n-         end Copy_List;\n-\n-         -----------------------\n-         -- Process_Allocator --\n-         -----------------------\n-\n-         function Process_Allocator (Nod : Node_Id) return Traverse_Result is\n-            Orig_Nod : Node_Id := Nod;\n-\n-         begin\n-            --  This is a possible rewritten subtype indication allocator. Any\n-            --  nested coextensions will appear as discriminant constraints.\n-\n-            if Nkind (Nod) = N_Identifier\n-              and then Present (Original_Node (Nod))\n-              and then Nkind (Original_Node (Nod)) = N_Subtype_Indication\n-            then\n-               declare\n-                  Discr      : Node_Id;\n-                  Discr_Elmt : Elmt_Id;\n-\n-               begin\n-                  if Is_Record_Type (Entity (Nod)) then\n-                     Discr_Elmt :=\n-                       First_Elmt (Discriminant_Constraint (Entity (Nod)));\n-                     while Present (Discr_Elmt) loop\n-                        Discr := Node (Discr_Elmt);\n-\n-                        if Nkind (Discr) = N_Identifier\n-                          and then Present (Original_Node (Discr))\n-                          and then Nkind (Original_Node (Discr)) = N_Allocator\n-                          and then Present (Coextensions (\n-                                     Original_Node (Discr)))\n-                        then\n-                           if No (Coextensions (Root)) then\n-                              Set_Coextensions (Root, New_Elmt_List);\n-                           end if;\n-\n-                           Copy_List\n-                             (From => Coextensions (Original_Node (Discr)),\n-                              To   => Coextensions (Root));\n-                        end if;\n-\n-                        Next_Elmt (Discr_Elmt);\n-                     end loop;\n-\n-                     --  There is no need to continue the traversal of this\n-                     --  subtree since all the information has already been\n-                     --  propagated.\n-\n-                     return Skip;\n-                  end if;\n-               end;\n-\n-            --  Case of either a stand alone allocator or a rewritten allocator\n-            --  with an aggregate.\n-\n-            else\n-               if Present (Original_Node (Nod)) then\n-                  Orig_Nod := Original_Node (Nod);\n-               end if;\n-\n-               if Nkind (Orig_Nod) = N_Allocator then\n-\n-                  --  Propagate the list of nested coextensions to the Root\n-                  --  allocator. This is done through list copy since a single\n-                  --  allocator may have multiple coextensions. Do not touch\n-                  --  coextensions roots.\n-\n-                  if not Is_Coextension_Root (Orig_Nod)\n-                    and then Present (Coextensions (Orig_Nod))\n-                  then\n-                     if No (Coextensions (Root)) then\n-                        Set_Coextensions (Root, New_Elmt_List);\n-                     end if;\n-\n-                     Copy_List\n-                       (From => Coextensions (Orig_Nod),\n-                        To   => Coextensions (Root));\n-                  end if;\n-\n-                  --  There is no need to continue the traversal of this\n-                  --  subtree since all the information has already been\n-                  --  propagated.\n-\n-                  return Skip;\n-               end if;\n-            end if;\n-\n-            --  Keep on traversing, looking for the next allocator\n-\n-            return OK;\n-         end Process_Allocator;\n-\n-         procedure Process_Allocators is\n-           new Traverse_Proc (Process_Allocator);\n-\n-      --  Start of processing for Propagate_Coextensions\n \n       begin\n-         Process_Allocators (Expression (Root));\n-      end Propagate_Coextensions;\n+         return\n+           Nkind_In (Par, N_Function_Call,\n+                          N_Procedure_Call_Statement)\n+             and then Is_Entity_Name (Name (Par))\n+             and then Is_Dispatching_Operation (Entity (Name (Par)));\n+      end In_Dispatching_Context;\n \n    --  Start of processing for Resolve_Allocator\n \n@@ -4487,13 +4326,6 @@ package body Sem_Res is\n             Set_Is_Dynamic_Coextension (N, False);\n             Set_Is_Static_Coextension  (N, False);\n          end if;\n-\n-         --  There is no need to propagate any nested coextensions if they\n-         --  are marked as static since they will be rewritten on the spot.\n-\n-         if not Is_Static_Coextension (N) then\n-            Propagate_Coextensions (N);\n-         end if;\n       end if;\n    end Resolve_Allocator;\n "}, {"sha": "f60aea0bcd15c45665cb0611fc7a710fe6e21fb3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 134, "deletions": 43, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -505,9 +505,9 @@ package body Sem_Util is\n       P         : constant Node_Id    := Prefix (N);\n       D         : Elmt_Id;\n       Id        : Node_Id;\n-      Indx_Type : Entity_Id;\n+      Index_Typ : Entity_Id;\n \n-      Deaccessed_T : Entity_Id;\n+      Desig_Typ : Entity_Id;\n       --  This is either a copy of T, or if T is an access type, then it is\n       --  the directly designated type of this access type.\n \n@@ -533,7 +533,7 @@ package body Sem_Util is\n          Old_Lo      : Node_Id;\n \n       begin\n-         Indx := First_Index (Deaccessed_T);\n+         Indx := First_Index (Desig_Typ);\n          while Present (Indx) loop\n             Old_Lo := Type_Low_Bound  (Etype (Indx));\n             Old_Hi := Type_High_Bound (Etype (Indx));\n@@ -584,7 +584,7 @@ package body Sem_Util is\n          D_Val       : Node_Id;\n \n       begin\n-         D := First_Elmt (Discriminant_Constraint (Deaccessed_T));\n+         D := First_Elmt (Discriminant_Constraint (Desig_Typ));\n          while Present (D) loop\n             if Denotes_Discriminant (Node (D)) then\n                D_Val :=  Make_Selected_Component (Loc,\n@@ -636,19 +636,19 @@ package body Sem_Util is\n       end if;\n \n       if Ekind (T) = E_Access_Subtype then\n-         Deaccessed_T := Designated_Type (T);\n+         Desig_Typ := Designated_Type (T);\n       else\n-         Deaccessed_T := T;\n+         Desig_Typ := T;\n       end if;\n \n-      if Ekind (Deaccessed_T) = E_Array_Subtype then\n-         Id := First_Index (Deaccessed_T);\n+      if Ekind (Desig_Typ) = E_Array_Subtype then\n+         Id := First_Index (Desig_Typ);\n          while Present (Id) loop\n-            Indx_Type := Underlying_Type (Etype (Id));\n+            Index_Typ := Underlying_Type (Etype (Id));\n \n-            if Denotes_Discriminant (Type_Low_Bound  (Indx_Type))\n+            if Denotes_Discriminant (Type_Low_Bound  (Index_Typ))\n                  or else\n-               Denotes_Discriminant (Type_High_Bound (Indx_Type))\n+               Denotes_Discriminant (Type_High_Bound (Index_Typ))\n             then\n                Remove_Side_Effects (P);\n                return\n@@ -659,11 +659,17 @@ package body Sem_Util is\n             Next_Index (Id);\n          end loop;\n \n-      elsif Is_Composite_Type (Deaccessed_T)\n-        and then Has_Discriminants (Deaccessed_T)\n-        and then not Has_Unknown_Discriminants (Deaccessed_T)\n+      elsif Is_Composite_Type (Desig_Typ)\n+        and then Has_Discriminants (Desig_Typ)\n+        and then not Has_Unknown_Discriminants (Desig_Typ)\n       then\n-         D := First_Elmt (Discriminant_Constraint (Deaccessed_T));\n+         if Is_Private_Type (Desig_Typ)\n+           and then No (Discriminant_Constraint (Desig_Typ))\n+         then\n+            Desig_Typ := Full_View (Desig_Typ);\n+         end if;\n+\n+         D := First_Elmt (Discriminant_Constraint (Desig_Typ));\n          while Present (D) loop\n             if Denotes_Discriminant (Node (D)) then\n                Remove_Side_Effects (P);\n@@ -3114,12 +3120,6 @@ package body Sem_Util is\n          then\n             null;\n \n-         --  A controller component for a type extension overrides the\n-         --  inherited component.\n-\n-         elsif Chars (E) = Name_uController then\n-            null;\n-\n          --  Case of an implicit operation or derived literal. The new entity\n          --  hides the implicit one,  which is removed from all visibility,\n          --  i.e. the entity list of its scope, and homonym chain of its name.\n@@ -3898,7 +3898,6 @@ package body Sem_Util is\n             begin\n                if not Is_Tag (Comp)\n                  and then Chars (Comp) /= Name_uParent\n-                 and then Chars (Comp) /= Name_uController\n                then\n                   Append_Elmt (Comp, Into);\n                end if;\n@@ -5970,6 +5969,118 @@ package body Sem_Util is\n           and then not In_Private_Part (Scope_Id);\n    end In_Visible_Part;\n \n+   --------------------------------\n+   -- Incomplete_Or_Private_View --\n+   --------------------------------\n+\n+   function Incomplete_Or_Private_View (Typ : Entity_Id) return Entity_Id is\n+      function Inspect_Decls\n+        (Decls : List_Id;\n+         Taft  : Boolean := False) return Entity_Id;\n+      --  Check whether a declarative region contains the incomplete or private\n+      --  view of Typ.\n+\n+      -------------------\n+      -- Inspect_Decls --\n+      -------------------\n+\n+      function Inspect_Decls\n+        (Decls : List_Id;\n+         Taft  : Boolean := False) return Entity_Id\n+      is\n+         Decl  : Node_Id;\n+         Match : Node_Id;\n+\n+      begin\n+         Decl := First (Decls);\n+         while Present (Decl) loop\n+            Match := Empty;\n+\n+            if Taft then\n+               if Nkind (Decl) = N_Incomplete_Type_Declaration then\n+                  Match := Defining_Identifier (Decl);\n+               end if;\n+            else\n+               if Nkind_In (Decl, N_Private_Extension_Declaration,\n+                                  N_Private_Type_Declaration)\n+               then\n+                  Match := Defining_Identifier (Decl);\n+               end if;\n+            end if;\n+\n+            if Present (Match)\n+              and then Present (Full_View (Match))\n+              and then Full_View (Match) = Typ\n+            then\n+               return Match;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+\n+         return Empty;\n+      end Inspect_Decls;\n+\n+      Prev : Entity_Id;\n+\n+   --  Start of processing for Incomplete_Or_Partial_View\n+\n+   begin\n+      --  Incomplete type case\n+\n+      Prev := Current_Entity_In_Scope (Typ);\n+\n+      if Present (Prev)\n+        and then Is_Incomplete_Type (Prev)\n+        and then Present (Full_View (Prev))\n+        and then Full_View (Prev) = Typ\n+      then\n+         return Prev;\n+      end if;\n+\n+      --  Private or Taft amendment type case\n+\n+      declare\n+         Pkg      : constant Entity_Id := Scope (Typ);\n+         Pkg_Decl : Node_Id := Pkg;\n+\n+      begin\n+         if Ekind (Pkg) = E_Package then\n+            while Nkind (Pkg_Decl) /= N_Package_Specification loop\n+               Pkg_Decl := Parent (Pkg_Decl);\n+            end loop;\n+\n+            --  It is knows that Typ has a private view, look for it in the\n+            --  visible declarations of the enclosing scope. A special case\n+            --  of this is when the two views have been exchanged - the full\n+            --  appears earlier than the private.\n+\n+            if Has_Private_Declaration (Typ) then\n+               Prev := Inspect_Decls (Visible_Declarations (Pkg_Decl));\n+\n+               --  Exchanged view case, look in the private declarations\n+\n+               if No (Prev) then\n+                  Prev := Inspect_Decls (Private_Declarations (Pkg_Decl));\n+               end if;\n+\n+               return Prev;\n+\n+            --  Otherwise if this is the package body, then Typ is a potential\n+            --  Taft amendment type. The incomplete view should be located in\n+            --  the private declarations of the enclosing scope.\n+\n+            elsif In_Package_Body (Pkg) then\n+               return Inspect_Decls (Private_Declarations (Pkg_Decl), True);\n+            end if;\n+         end if;\n+      end;\n+\n+      --  The type has no incomplete or private view\n+\n+      return Empty;\n+   end Incomplete_Or_Private_View;\n+\n    ---------------------------------\n    -- Insert_Explicit_Dereference --\n    ---------------------------------\n@@ -6294,23 +6405,6 @@ package body Sem_Util is\n       end if;\n    end Is_Atomic_Object;\n \n-   -------------------------\n-   -- Is_Coextension_Root --\n-   -------------------------\n-\n-   function Is_Coextension_Root (N : Node_Id) return Boolean is\n-   begin\n-      return\n-        Nkind (N) = N_Allocator\n-          and then Present (Coextensions (N))\n-\n-         --  Anonymous access discriminants carry a list of all nested\n-         --  controlled coextensions.\n-\n-          and then not Is_Dynamic_Coextension (N)\n-          and then not Is_Static_Coextension (N);\n-   end Is_Coextension_Root;\n-\n    -----------------------------\n    -- Is_Concurrent_Interface --\n    -----------------------------\n@@ -6819,10 +6913,7 @@ package body Sem_Util is\n          begin\n             Ent := First_Entity (Typ);\n             while Present (Ent) loop\n-               if Chars (Ent) = Name_uController then\n-                  null;\n-\n-               elsif Ekind (Ent) = E_Component\n+               if Ekind (Ent) = E_Component\n                  and then (No (Parent (Ent))\n                              or else No (Expression (Parent (Ent))))\n                  and then not Is_Fully_Initialized_Type (Etype (Ent))"}, {"sha": "954a11e70e6d21f23111712324352adda9561630", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -395,15 +395,15 @@ package Sem_Util is\n    --  discriminant at the same position in this new type.\n \n    procedure Find_Overlaid_Entity\n-     (N   : Node_Id;\n+     (N : Node_Id;\n       Ent : out Entity_Id;\n       Off : out Boolean);\n-   --  The node N should be an address representation clause. Determines if the\n-   --  target expression is the address of an entity with an optional offset.\n-   --  If so, Ent is set to the entity and, if there is an offset, Off is set\n-   --  to True, otherwise to False. If N is not an address representation\n+   --  The node N should be an address representation clause. Determines if\n+   --  the target expression is the address of an entity with an optional\n+   --  offset. If so, set Ent to the entity and, if there is an offset, set\n+   --  Off to True, otherwise to False. If N is not an address representation\n    --  clause, or if it is not possible to determine that the address is of\n-   --  this form, then Ent is set to Empty, and Off is set to False.\n+   --  this form, then set Ent to Empty.\n \n    function Find_Parameter_Type (Param : Node_Id) return Entity_Id;\n    --  Return the type of formal parameter Param as determined by its\n@@ -689,6 +689,11 @@ package Sem_Util is\n    --  package specification. The package must be on the scope stack, and the\n    --  corresponding private part must not.\n \n+   function Incomplete_Or_Private_View (Typ : Entity_Id) return Entity_Id;\n+   --  Given the entity of a type, retrieve the incomplete or private view of\n+   --  the same type. Note that Typ may not have a partial view to begin with,\n+   --  in that case the function returns Empty.\n+\n    procedure Insert_Explicit_Dereference (N : Node_Id);\n    --  In a context that requires a composite or subprogram type and where a\n    --  prefix is an access type, rewrite the access type node N (which is the\n@@ -722,10 +727,6 @@ package Sem_Util is\n    --  Determines if the given node denotes an atomic object in the sense of\n    --  the legality checks described in RM C.6(12).\n \n-   function Is_Coextension_Root (N : Node_Id) return Boolean;\n-   --  Determine whether node N is an allocator which acts as a coextension\n-   --  root.\n-\n    function Is_Controlling_Limited_Procedure\n      (Proc_Nam : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-345): Determine whether Proc_Nam is a primitive procedure\n@@ -1209,11 +1210,11 @@ package Sem_Util is\n    --  previous errors (particularly in -gnatq mode).\n \n    function Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n-   --  E is a type entity. The result is True when temporaries of this\n-   --  type need to be wrapped in a transient scope to be reclaimed\n-   --  properly when a secondary stack is in use. Examples of types\n-   --  requiring such wrapping are controlled types and variable-sized\n-   --  types including unconstrained arrays\n+   --  E is a type entity. The result is True when temporaries of this type\n+   --  need to be wrapped in a transient scope to be reclaimed properly when a\n+   --  secondary stack is in use. Examples of types requiring such wrapping are\n+   --  controlled types and variable-sized types including unconstrained\n+   --  arrays.\n \n    procedure Reset_Analyzed_Flags (N : Node_Id);\n    --  Reset the Analyzed flags in all nodes of the tree whose root is N"}, {"sha": "40d8dd6aecde15f09ea0d5498d1101edc17a3e0b", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -410,14 +410,6 @@ package body Sinfo is\n       return Flag6 (N);\n    end Class_Present;\n \n-   function Coextensions\n-      (N : Node_Id) return Elist_Id is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Allocator);\n-      return Elist4 (N);\n-   end Coextensions;\n-\n    function Comes_From_Extended_Return_Statement\n      (N : Node_Id) return Boolean is\n    begin\n@@ -3469,14 +3461,6 @@ package body Sinfo is\n       Set_Flag6 (N, Val);\n    end Set_Class_Present;\n \n-   procedure Set_Coextensions\n-      (N : Node_Id; Val : Elist_Id) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Allocator);\n-      Set_Elist4 (N, Val);\n-   end Set_Coextensions;\n-\n    procedure Set_Comes_From_Extended_Return_Statement\n      (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "7ee9a80a550c5b4fa13d3ac76c88ed59798cda96", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -657,10 +657,6 @@ package Sinfo is\n    --    attribute definition clause is given, rather than testing this at the\n    --    freeze point.\n \n-   --  Coextensions (Elist4-Sem)\n-   --    Present in allocators nodes. Points to list of allocators for the\n-   --    access discriminants of the allocated object.\n-\n    --  Comes_From_Extended_Return_Statement (Flag18-Sem)\n    --    Present in N_Simple_Return_Statement nodes. True if this node was\n    --    constructed as part of the N_Extended_Return_Statement expansion.\n@@ -1663,10 +1659,9 @@ package Sinfo is\n    --    Points to an E_Return_Statement representing the return statement.\n \n    --  Return_Object_Declarations (List3)\n-   --    Present in N_Extended_Return_Statement.\n-   --    Points to a list initially containing a single\n-   --    N_Object_Declaration representing the return object.\n-   --    We use a list (instead of just a pointer to the object decl)\n+   --    Present in N_Extended_Return_Statement. Points to a list initially\n+   --    containing a single N_Object_Declaration representing the return\n+   --    object. We use a list (instead of just a pointer to the object decl)\n    --    because Analyze wants to insert extra actions on this list.\n \n    --  Rounded_Result (Flag18-Sem)\n@@ -3959,7 +3954,6 @@ package Sinfo is\n       --  Expression (Node3) subtype indication or qualified expression\n       --  Storage_Pool (Node1-Sem)\n       --  Procedure_To_Call (Node2-Sem)\n-      --  Coextensions (Elist4-Sem)\n       --  Null_Exclusion_Present (Flag11)\n       --  No_Initialization (Flag13-Sem)\n       --  Is_Static_Coextension (Flag14-Sem)\n@@ -8126,9 +8120,6 @@ package Sinfo is\n    function Class_Present\n      (N : Node_Id) return Boolean;    -- Flag6\n \n-   function Coextensions\n-      (N : Node_Id) return Elist_Id;  -- Elist4\n-\n    function Comes_From_Extended_Return_Statement\n      (N : Node_Id) return Boolean;    -- Flag18\n \n@@ -9101,9 +9092,6 @@ package Sinfo is\n    procedure Set_Class_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag6\n \n-   procedure Set_Coextensions\n-     (N : Node_Id; Val : Elist_Id);           -- Elist4\n-\n    procedure Set_Comes_From_Extended_Return_Statement\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n@@ -10636,7 +10624,7 @@ package Sinfo is\n        (1 => False,   --  Storage_Pool (Node1-Sem)\n         2 => False,   --  Procedure_To_Call (Node2-Sem)\n         3 => True,    --  Expression (Node3)\n-        4 => False,   --  Coextensions (Elist4-Sem)\n+        4 => False,   --  unused\n         5 => False),  --  Etype (Node5-Sem)\n \n      N_Null_Statement =>\n@@ -11717,7 +11705,6 @@ package Sinfo is\n    pragma Inline (Choice_Parameter);\n    pragma Inline (Choices);\n    pragma Inline (Class_Present);\n-   pragma Inline (Coextensions);\n    pragma Inline (Comes_From_Extended_Return_Statement);\n    pragma Inline (Compile_Time_Known_Aggregate);\n    pragma Inline (Component_Associations);\n@@ -12039,7 +12026,6 @@ package Sinfo is\n    pragma Inline (Set_Choice_Parameter);\n    pragma Inline (Set_Choices);\n    pragma Inline (Set_Class_Present);\n-   pragma Inline (Set_Coextensions);\n    pragma Inline (Set_Comes_From_Extended_Return_Statement);\n    pragma Inline (Set_Compile_Time_Known_Aggregate);\n    pragma Inline (Set_Component_Associations);"}, {"sha": "73fbdfc462731b02071ac09efaad7eb6f83ffbbb", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                             T e m p l a t e                              --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -154,15 +154,13 @@ package Snames is\n    Name_uAssign                        : constant Name_Id := N + $;\n    Name_uATCB                          : constant Name_Id := N + $;\n    Name_uChain                         : constant Name_Id := N + $;\n-   Name_uClean                         : constant Name_Id := N + $;\n    Name_uController                    : constant Name_Id := N + $;\n    Name_uCPU                           : constant Name_Id := N + $;\n    Name_uEntry_Bodies                  : constant Name_Id := N + $;\n    Name_uExpunge                       : constant Name_Id := N + $;\n-   Name_uFinal_List                    : constant Name_Id := N + $;\n+   Name_uFinalizer                     : constant Name_Id := N + $;\n    Name_uIdepth                        : constant Name_Id := N + $;\n    Name_uInit                          : constant Name_Id := N + $;\n-   Name_uLocal_Final_List              : constant Name_Id := N + $;\n    Name_uMaster                        : constant Name_Id := N + $;\n    Name_uObject                        : constant Name_Id := N + $;\n    Name_uPostconditions                : constant Name_Id := N + $;\n@@ -191,17 +189,12 @@ package Snames is\n    Name_uDisp_Requeue                  : constant Name_Id := N + $;\n    Name_uDisp_Timed_Select             : constant Name_Id := N + $;\n \n-   --  Names of routines in Ada.Finalization, needed by expander\n+   --  Names of routines and fields in Ada.Finalization, needed by expander\n \n    Name_Initialize                     : constant Name_Id := N + $;\n    Name_Adjust                         : constant Name_Id := N + $;\n    Name_Finalize                       : constant Name_Id := N + $;\n-\n-   --  Names of fields declared in System.Finalization_Implementation,\n-   --  needed by the expander when generating code for finalization.\n-\n-   Name_Next                           : constant Name_Id := N + $;\n-   Name_Prev                           : constant Name_Id := N + $;\n+   Name_Finalize_Address               : constant Name_Id := N + $;\n \n    --  Names of allocation routines, also needed by expander\n \n@@ -240,7 +233,6 @@ package Snames is\n \n    Name_Exception_Traces               : constant Name_Id := N + $;\n    Name_Finalization                   : constant Name_Id := N + $;\n-   Name_Finalization_Root              : constant Name_Id := N + $;\n    Name_Interfaces                     : constant Name_Id := N + $;\n    Name_Most_Recent_Exception          : constant Name_Id := N + $;\n    Name_Standard                       : constant Name_Id := N + $;\n@@ -1205,11 +1197,12 @@ package Snames is\n \n    Name_Unaligned_Valid                  : constant Name_Id := N + $;\n \n-   --  Names used to implement iterators over predefined  containers\n+   --  Names used to implement iterators over predefined containers\n \n    Name_Cursor                           : constant Name_Id := N + $;\n    Name_Element                          : constant Name_Id := N + $;\n    Name_Element_Type                     : constant Name_Id := N + $;\n+   Name_Next                             : constant Name_Id := N + $;\n    Name_No_Element                       : constant Name_Id := N + $;\n    Name_Previous                         : constant Name_Id := N + $;\n "}, {"sha": "91fbf85121a150bdb0a01538a193c4ae8e9173b4", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3e68b121249fad724c7c3f2b71e430dfb91008/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=df3e68b121249fad724c7c3f2b71e430dfb91008", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -766,8 +766,9 @@ package body Tbuild is\n      (Typ  : Entity_Id;\n       Expr : Node_Id) return Node_Id\n    is\n-      Loc    : constant Source_Ptr := Sloc (Expr);\n-      Result : Node_Id;\n+      Loc         : constant Source_Ptr := Sloc (Expr);\n+      Result      : Node_Id;\n+      Expr_Parent : Node_Id;\n \n    begin\n       --  If the expression is already of the correct type, then nothing\n@@ -797,10 +798,18 @@ package body Tbuild is\n       --  All other cases\n \n       else\n+         --  Capture the parent of the expression before relocating it and\n+         --  creating the conversion, so the conversion's parent can be set\n+         --  to the original parent below.\n+\n+         Expr_Parent := Parent (Expr);\n+\n          Result :=\n            Make_Unchecked_Type_Conversion (Loc,\n              Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n              Expression   => Relocate_Node (Expr));\n+\n+         Set_Parent (Result, Expr_Parent);\n       end if;\n \n       Set_Etype (Result, Typ);"}]}