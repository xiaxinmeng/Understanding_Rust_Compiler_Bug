{"sha": "4a369d199bf2f34e037030b18d0da923e8a24997", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEzNjlkMTk5YmYyZjM0ZTAzNzAzMGIxOGQwZGE5MjNlOGEyNDk5Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-16T07:43:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-27T12:17:09Z"}, "message": "SLP vectorize across PHI nodes\n\nThis makes SLP discovery detect backedges by seeding the bst_map with\nthe node to be analyzed so it can be picked up from recursive calls.\nThis removes the need to discover backedges in a separate walk.\n\nThis enables SLP build to handle PHI nodes in full, continuing\nthe SLP build to non-backedges.  For loop vectorization this\nenables outer loop vectorization of nested SLP cycles and for\nBB vectorization this enables vectorization of PHIs at CFG merges.\n\nIt also turns code generation into a SCC discovery walk to handle\nirreducible regions and nodes only reachable via backedges where\nwe now also fill in vectorized backedge defs.\n\nThis requires sanitizing the SLP tree for SLP reduction chains even\nmore, manually filling the backedge SLP def.\n\nThis also exposes the fact that CFG copying (and edge splitting\nuntil I fixed that) ends up with different edge order in the\ncopy which doesn't play well with the desired 1:1 mapping of\nSLP PHI node children and edges for epilogue vectorization.\nI've tried to fixup CFG copying here but this really looks\nlike a dead (or expensive) end there so I've done fixup in\nslpeel_tree_duplicate_loop_to_edge_cfg instead for the cases\nwe can run into.\n\nThere's still NULLs in the SLP_TREE_CHILDREN vectors and I'm\nnot sure it's possible to eliminate them all this stage1 so the\npatch has quite some checks for this case all over the place.\n\nBootstrapped and tested on x86_64-unknown-linux-gnu.  SPEC CPU 2017\nand SPEC CPU 2006 successfully built and tested.\n\n2020-10-27  Richard Biener  <rguenther@suse.de>\n\n\t* gimple.h (gimple_expr_type): For PHIs return the type\n\tof the result.\n\t* tree-vect-loop-manip.c (slpeel_tree_duplicate_loop_to_edge_cfg):\n\tMake sure edge order into copied loop headers line up with the\n\toriginals.\n\t* tree-vect-loop.c (vect_transform_cycle_phi): Handle nested\n\tloops with SLP.\n\t(vectorizable_phi): New function.\n\t(vectorizable_live_operation): For BB vectorization compute insert\n\tlocation here.\n\t* tree-vect-slp.c (vect_free_slp_tree): Deal with NULL\n\tSLP_TREE_CHILDREN entries.\n\t(vect_create_new_slp_node): Add overloads with pre-existing node\n\targument.\n\t(vect_print_slp_graph): Likewise.\n\t(vect_mark_slp_stmts): Likewise.\n\t(vect_mark_slp_stmts_relevant): Likewise.\n\t(vect_gather_slp_loads): Likewise.\n\t(vect_optimize_slp): Likewise.\n\t(vect_slp_analyze_node_operations): Likewise.\n\t(vect_bb_slp_scalar_cost): Likewise.\n\t(vect_remove_slp_scalar_calls): Likewise.\n\t(vect_get_and_check_slp_defs): Handle PHIs.\n\t(vect_build_slp_tree_1): Handle PHIs.\n\t(vect_build_slp_tree_2): Continue SLP build, following PHI\n\targuments.  Fix memory leak.\n\t(vect_build_slp_tree): Put stub node into the hash-map so\n\twe can discover cycles directly.\n\t(vect_build_slp_instance): Set the backedge SLP def for\n\treduction chains.\n\t(vect_analyze_slp_backedges): Remove.\n\t(vect_analyze_slp): Do not call it.\n\t(vect_slp_convert_to_external): Release SLP_TREE_LOAD_PERMUTATION.\n\t(vect_slp_analyze_node_operations): Handle stray failed\n\tbackedge defs by failing.\n\t(vect_slp_build_vertices): Adjust leaf condition.\n\t(vect_bb_slp_mark_live_stmts): Handle PHIs, use visited\n\thash-set to handle cycles.\n\t(vect_slp_analyze_operations): Adjust.\n\t(vect_bb_partition_graph_r): Likewise.\n\t(vect_slp_function): Adjust split condition to allow CFG\n\tmerges.\n\t(vect_schedule_slp_instance): Rename to ...\n\t(vect_schedule_slp_node): ... this.  Move DFS walk to ...\n\t(vect_schedule_scc): ... this new function.\n\t(vect_schedule_slp): Call it.  Remove ad-hoc vectorized\n\tbackedge fill code.\n\t* tree-vect-stmts.c (vect_analyze_stmt): Call\n\tvectorizable_phi.\n\t(vect_transform_stmt): Likewise.\n\t(vect_is_simple_use): Handle vect_backedge_def.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Only\n\tset loop header PHIs to vect_unknown_def_type for loop\n\tvectorization.\n\t* tree-vectorizer.h (enum vect_def_type): Add vect_backedge_def.\n\t(enum stmt_vec_info_type): Add phi_info_type.\n\t(vectorizable_phi): Declare.\n\n\t* gcc.dg/vect/bb-slp-54.c: New test.\n\t* gcc.dg/vect/bb-slp-55.c: Likewise.\n\t* gcc.dg/vect/bb-slp-56.c: Likewise.\n\t* gcc.dg/vect/bb-slp-57.c: Likewise.\n\t* gcc.dg/vect/bb-slp-58.c: Likewise.\n\t* gcc.dg/vect/bb-slp-59.c: Likewise.\n\t* gcc.dg/vect/bb-slp-60.c: Likewise.\n\t* gcc.dg/vect/bb-slp-61.c: Likewise.\n\t* gcc.dg/vect/bb-slp-62.c: Likewise.\n\t* gcc.dg/vect/bb-slp-63.c: Likewise.\n\t* gcc.dg/vect/bb-slp-64.c: Likewise.\n\t* gcc.dg/vect/bb-slp-65.c: Likewise.\n\t* gcc.dg/vect/bb-slp-66.c: Likewise.\n\t* gcc.dg/vect/vect-outer-slp-1.c: Likewise.\n\t* gfortran.dg/vect/O3-bb-slp-1.f: Likewise.\n\t* gfortran.dg/vect/O3-bb-slp-2.f: Likewise.\n\t* g++.dg/vect/simd-11.cc: Likewise.", "tree": {"sha": "5eac5d0e6f1a4a9d6ca63d54f5daf8fc1e2c35ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eac5d0e6f1a4a9d6ca63d54f5daf8fc1e2c35ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a369d199bf2f34e037030b18d0da923e8a24997", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a369d199bf2f34e037030b18d0da923e8a24997", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a369d199bf2f34e037030b18d0da923e8a24997", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a369d199bf2f34e037030b18d0da923e8a24997/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5af1e827bbb624eb28f80d2c5e0da46185af3708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af1e827bbb624eb28f80d2c5e0da46185af3708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af1e827bbb624eb28f80d2c5e0da46185af3708"}], "stats": {"total": 1266, "additions": 1031, "deletions": 235}, "files": [{"sha": "87c90be9a6a835bd99026806c7afcd7d985c7350", "filename": "gcc/gimple.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -6598,6 +6598,8 @@ gimple_expr_type (const gimple *stmt)\n     }\n   else if (code == GIMPLE_COND)\n     return boolean_type_node;\n+  else if (code == GIMPLE_PHI)\n+    return TREE_TYPE (gimple_phi_result (stmt));\n   else\n     return void_type_node;\n }"}, {"sha": "912d184005599c1a7476f010e4cac323ff96c414", "filename": "gcc/testsuite/g++.dg/vect/simd-11.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-11.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-11.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-11.cc?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do compile }\n+// { dg-require-effective-target c++11 }\n+// { dg-additional-options \"-Ofast\" }\n+\n+template <typename> class h {\n+public:\n+  ~h();\n+};\n+template <typename> struct l;\n+template <typename c> struct l<h<c> > {\n+  using d = c;\n+  template <typename e> using f = h<e>;\n+};\n+template <typename g> struct o {\n+  typedef l<g> j;\n+  typedef typename j::d k;\n+  template <typename c> struct p { typedef typename j::f<c> m; };\n+};\n+template <typename c, typename g> struct F {\n+  typedef typename o<g>::p<c>::m q;\n+  struct : q {\n+  } r;\n+};\n+template <typename c, typename g = h<c> > class s : F<c, g> {\n+public:\n+  s(long);\n+  typename o<typename F<c, g>::q>::k operator[](long);\n+};\n+template <int> class t {\n+public:\n+  int dimension;\n+  t(const t &);\n+  void operator+=(t);\n+  double values[];\n+};\n+template <int dim> t<dim>::t(const t &p1) {\n+  for (int i = 0; i < dim; ++i)\n+    values[i] = p1.values[i];\n+}\n+template <int dim> class u : public t<dim> {\n+public:\n+  double m_fn1(const u &) const;\n+};\n+template <int dim> double u<dim>::m_fn1(const u &) const {\n+  double a;\n+  for (int i = 0; i < dim; ++i) {\n+    double b = this->values[i];\n+    a += b;\n+  }\n+  return a;\n+}\n+int m_fn2(const u<2> &p1, const u<2> &w) {\n+  int n;\n+  s<u<2> > c(n);\n+  s<double> d(n);\n+  double e = p1.m_fn1(w);\n+  for (;;) {\n+    c[0] += p1;\n+    d = e;\n+  }\n+}"}, {"sha": "d05ce33310da6dcf84d2bcf51dc37aa25854e7e8", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-54.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-54.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+\n+double a[2], b[2], c[2];\n+\n+void foo(int flag)\n+{\n+  double tem1, tem2;\n+  if (flag)\n+    {\n+      tem1 = a[0];\n+      tem2 = a[1];\n+    }\n+  else\n+    {\n+      tem1 = b[0];\n+      tem2 = b[1];\n+    }\n+  c[0] = tem1;\n+  c[1] = tem2;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"transform load\" 2 \"slp2\" } } */"}, {"sha": "57a042b0ba57404428c55305127a2ef60f8ab1e0", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-55.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-55.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-55.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-55.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+typedef struct {\n+  int a;\n+  int b;\n+  int c;\n+  int d;\n+} e;\n+e *f;\n+int g;\n+void h() {\n+  e *i;\n+  if (g) {\n+    i->c = f[g].b;\n+    i->d = f[g].a;\n+  } else\n+    i->c = i->d = 0;\n+}"}, {"sha": "90d175124920d9e11ba8cd3f1d4c285ac305b870", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-56.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-56.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-56.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-56.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+typedef struct {\n+  double a, b;\n+} c;\n+int d, e;\n+int i(void);\n+void h(c, c);\n+void f() {\n+  c a, g;\n+  do {\n+    a.a = e ?: g.a;\n+    a.b = g.b + d;\n+    h(g, a);\n+    g = a;\n+  } while (i());\n+}"}, {"sha": "6f13507fd67e13babd21163c34b89582928d7234", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-57.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-57.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-57.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-57.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-ffast-math\" } */\n+/* { dg-require-effective-target vect_float } */\n+\n+float *a;\n+typedef struct {\n+  int c;\n+  float bbmax[3];\n+} d;\n+d e;\n+int f[3];\n+int g, h, i, j;\n+float k, k;\n+void l()\n+{\n+  for (unsigned z = 0; z < 2048; ++z) {\n+    {\n+      j = e.bbmax[1] > k ? e.bbmax[1] : k;\n+    }\n+    e.bbmax[1] = j;\n+    { i = e.bbmax[2] > k ? e.bbmax[2] : k; }\n+    e.bbmax[2] = i;\n+    f[2] = a[2];\n+    {\n+      float b;\n+      h = e.bbmax[1] > b ? e.bbmax[1] : b;\n+    }\n+    e.bbmax[1] = h;\n+    {\n+      float b;\n+      g = e.bbmax[2] > b ? e.bbmax[2] : b;\n+    }\n+    e.bbmax[2] = g;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"transform load\" 1 \"slp1\" { target { { x86_64-*-* i?86-*-* } && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"optimized: basic block\" \"slp1\" { target { { x86_64-*-* i?86-*-* } && lp64 } } } } */"}, {"sha": "11bf5c333ab06efc5404d62bafd7fed3b5a6c180", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-58.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-58.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+double x[1024];\n+void bar (void);\n+\n+void foo (void)\n+{\n+  double tem1 = x[0];\n+  double tem2 = x[1];\n+  for (int i = 0; i < 511; ++i)\n+    {\n+      x[2*i] = tem1;\n+      x[2*i+1] = tem2;\n+      bar ();\n+      tem1 = x[2*(i+1)];\n+      tem2 = x[2*(i+1)+1];\n+    }\n+}\n+\n+/* We should be able to vectorize the cycle in one SLP attempt including\n+   both load groups.  */\n+/* { dg-final { scan-tree-dump-times \"transform load\" 2 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimized: basic block\" 1 \"slp1\" } } */"}, {"sha": "2e35725ff2a6c797778f7555b410edb90b2b4301", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-59.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-59.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-59.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-59.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-loopdone\" } */\n+\n+double x[1024];\n+void bar (void);\n+\n+void foo (void)\n+{\n+  double tem1 = x[0];\n+  double tem2 = x[1];\n+  for (int i = 0; i < 511; ++i)\n+    {\n+      x[2*i] = tem2;\n+      x[2*i+1] = tem1;\n+      bar ();\n+      tem1 = x[2*(i+1)];\n+      tem2 = x[2*(i+1)+1];\n+    }\n+}\n+\n+/* We should be able to vectorize the cycle in one SLP attempt including\n+   both load groups and do only one permutation.  */\n+/* { dg-final { scan-tree-dump-times \"transform load\" 2 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 1 \"loopdone\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimized: basic block\" 1 \"slp1\" } } */"}, {"sha": "52643bfd75ad62942674045a8098a051ea0901cd", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-60.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-60.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-60.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-60.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+enum { a = 1, b };\n+float *c, *e;\n+float d, h;\n+int f, g;\n+void i()\n+{\n+  float j = h;\n+  for (; g;)\n+    for (; f; f++)\n+      {\n+\tc[a] = j * d;\n+\tc[b] = h * d;\n+\tj = 0;\n+\th = e[2];\n+      }\n+}"}, {"sha": "3323a2bb2d9797f5e6af09ce8bdcb141e5de739c", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-61.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-61.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+struct a {\n+  enum { b, c } d;\n+  unsigned e;\n+  unsigned f;\n+};\n+void j(struct a *a, int i, int h)\n+{\n+  unsigned f = a->f;\n+  switch (a->d)\n+    while (1)\n+      {\n+        if (i)\n+          {\n+    case b:\n+            if (h)\n+              goto k;\n+          }\n+        else\n+          f = 0;\n+    case c:;\n+      }\n+k:\n+  a->e = a->f = f;\n+}"}, {"sha": "84ee04c1013a5451655eea9f4c57321d7c287bdd", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-62.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-62.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-62.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-62.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+typedef struct {\n+  char a;\n+  int b[];\n+} c;\n+int d, f;\n+c e;\n+void g() {\n+  int h, i, j;\n+  for (; i;)\n+    switch (i)\n+    case 4: {\n+      h = (__UINTPTR_TYPE__)g >= 3;\n+      for (; h; h -= 1)\n+        if (d)\n+          j = f;\n+    }\n+      for (; i < 3; i++)\n+        e.b[i] = j;\n+}"}, {"sha": "6519c9752fe9b4757a4e9a72c73145575610240b", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-63.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-63.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-63.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-63.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+struct {\n+  unsigned a;\n+  unsigned c;\n+} d;\n+int e, g;\n+void h(unsigned b) {\n+  unsigned a, c;\n+  while (e) {\n+    if (b) {\n+      ++e;\n+      continue;\n+    }\n+    c = g;\n+    if (g)\n+      a |= 10;\n+  }\n+  d.a = a;\n+  d.c = c;\n+}"}, {"sha": "dcb6a1455c3fd8d2957525e1c010aefc80309123", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-64.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-64.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+\n+enum { a, b };\n+double *c, *e;\n+int d, f;\n+void g() {\n+  for (;;) {\n+    c[a] = c[b] = d * e[b];\n+    f = d -= f;\n+  }\n+}"}, {"sha": "ec1707be9f5baaaf72c6144549c0c16d96d1c291", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-65.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-65.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-65.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-65.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O3\" } */\n+/* { dg-additional-options \"-mavx2\" { target x86_64-*-* i?86-*-* } } */\n+\n+int *a;\n+int b, c, d, e;\n+void f() {\n+  int g;\n+  for (;;)\n+    for (; b;)\n+      if (d)\n+        for (; c;)\n+          if (g)\n+            e += a[1] = a[2] = e;\n+}"}, {"sha": "b59a2cc72402d01528fcadefa59d7117b6100ebc", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-66.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-66.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-66.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-66.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+typedef struct {\n+  double a, b;\n+} c;\n+typedef struct {\n+  c d;\n+  long coordinates;\n+} e;\n+int f;\n+c g;\n+e h;\n+void k(int);\n+int n();\n+void j() { int i; k(i); }\n+void k(int l) {\n+  double a;\n+  int b;\n+  c m[4];\n+  long i;\n+  for (; l;)\n+    do {\n+      g.a = b ?: a;\n+      m[3] = g;\n+      if (f)\n+        m[0] = m[1] = m[3];\n+      i = 0;\n+      for (; i < 4; i++)\n+        (&h + i)->d = m[i];\n+    } while (n());\n+}"}, {"sha": "62b18bd5764e83e569f7f874524749b8f12f02db", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-slp-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-1.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+int a[1024];\n+\n+void foo (void)\n+{\n+  for (int i = 0; i < 1020; i += 4)\n+    {\n+      int suma = a[i];\n+      int sumb = a[i+1];\n+      int sumc = a[i+2];\n+      int sumd = a[i+3];\n+      for (unsigned j = 0; j < 77; ++j)\n+        {\n+          suma = (suma ^ i) + 1;\n+          sumb = (sumb ^ i) + 2;\n+          sumc = (sumc ^ i) + 3;\n+          sumd = (sumd ^ i) + 4;\n+        }\n+      a[i] = suma;\n+      a[i+1] = sumb;\n+      a[i+2] = sumc;\n+      a[i+3] = sumd;\n+    }\n+}\n+\n+/* We should vectorize this outer loop with SLP.  */\n+/* { dg-final { scan-tree-dump \"OUTER LOOP VECTORIZED\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not \"VEC_PERM_EXPR\" \"vect\" } } */"}, {"sha": "74b3b17b5a9bc038e905de04a63b9e55a551d416", "filename": "gcc/testsuite/gfortran.dg/vect/O3-bb-slp-1.f", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2FO3-bb-slp-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2FO3-bb-slp-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2FO3-bb-slp-1.f?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+       subroutine tranx3 (jbeg,jend,kbeg,kend,dlo,den,mflx,zro)\n+      parameter(in =           128+5\n+     &        , jn =           128+5\n+     &        , kn =           128+5)\n+      parameter(ijkn =   128+5)\n+      real*8    zro, dqm, dqp, dx3bi  (kn)\n+      real*8    mflux (ijkn,4), dtwid (ijkn,4),  dd    (ijkn,4)\n+       real*8  mflx (in,jn,kn)\n+       real*8  dlo  (in,jn,kn), den  (in,jn,kn)\n+       do 2100 j=jbeg-1,jend\n+               dtwid (k,1) = ( 0.5 + q1 ) * ( dlo(i  ,j,k-1)\n+     3                     - ( dx3a(k  ) + xi ) * dd   (k  ,1) )\n+               mflux (k,1) = dtwid (k,1) * ( v3(i  ,j,k) - vg3(k) ) * dt\n+             if (j.ge.jbeg) then\n+               den(i  ,j,k) = ( dlo(i  ,j,k) * dvl3a(k)\n+     1                      - etwid (k+1,1) + etwid (k,1) ) * dvl3a i(k)\n+               if (kend .eq. ke) mflx(i  ,j,ke+1) = mflux (ke+1,1)\n+             endif\n+             do 2030 k=max(kbeg-2,ks-1),kend+1\n+               dqm      = (dlo(i  ,j,k  ) - dlo(i  ,j,k-1)) * dx3bi(k  )\n+               dqp      = (dlo(i  ,j,k+1) - dlo(i  ,j,k  )) * dx3bi(k+1)\n+               dd(k,1)  = max ( dqm * dqp, zro )\n+2030       continue\n+               dtwid (k,3) = ( 0.5 + q1 ) * ( dlo(i+2,j,k-1)\n+     3                     - ( dx3a(k  ) + xi ) * deod (k  ,3) )\n+2100   continue\n+       end"}, {"sha": "34c44def09379fee39abb187689072ca3ed06218", "filename": "gcc/testsuite/gfortran.dg/vect/O3-bb-slp-2.f", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2FO3-bb-slp-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2FO3-bb-slp-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2FO3-bb-slp-2.f?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-mavx2\" { target x86_64-*-* i?86-*-* } }\n+       subroutine tranx3 (ibeg,jbeg,jend,kbeg,kend\n+     &                   ,dlo,den\n+     &                   ,edn)\n+      parameter(in =           128+5\n+     &        , jn =           128+5\n+     &        , kn =           128+5)\n+      parameter(ijkn =   128+5)\n+      real*8   e (in,jn,kn), dqm, dvl3a  (kn), dvl3ai (kn)\n+     &           , dtwid (ijkn,4),  dd    (ijkn,4)\n+     &           , etwid (ijkn,4),  deod  (ijkn,4)\n+       real*8  dlo  (in,jn,kn), den  (in,jn,kn)\n+     &      , edn  (in,jn,kn)\n+       do 2100 j=jbeg-1,jend\n+           i = ibeg - 1\n+               do 1080 k=kbeg,kend\n+               den(i  ,j,k) = ( dlo(i  ,j,k) * dvl3a(k)\n+     1                      - etwid (k+1,1) + etwid (k,1) ) * dvl3a i(k)\n+1080           continue\n+             do 2030 k=max(kbeg-2,ks-1),kend+1\n+               dqm      = (dlo(i+2,j,k  ) - dlo(i+2,j,k-1)) * dx3bi(k  )\n+               dd(k,4)  = max ( dqm * dqp, zro )\n+2030       continue\n+               dtwid (k,3) = ( 0.5 + q1 ) * ( dlo(i+2,j,k-1)\n+     1                     + ( dx3a(k-1) - xi ) * dd   (k-1,3) )\n+     2                     + ( 0.5 - q1 ) * ( dlo(i+2,j,k  )\n+     3                     - ( dx3a(k  ) + xi ) * deod (k  ,3) )\n+               do 2080 k=kbeg,kend\n+               den(i  ,j,k) = ( dlo(i  ,j,k) * dvl3a(k)\n+     1                      - dtwid (k+1,3) + dtwid (k,3) ) * dvl3a i(k)\n+               e  (i+2,j,k) = ( e  (i+2,j,k) * dvl3a(k)\n+     1                      - etwid (k+1,3) + etwid (k,3) ) * dvl3a i(k)\n+               edn(i+2,j,k) =         e(i+2,j,k) / den(i+2,j,k)\n+               e  (i+3,j,k) = ( e  (i+3,j,k) * dvl3a(k)\n+     1                      - etwid (k+1,4) + etwid (k,4) ) * dvl3a i(k)\n+               edn(i+3,j,k) =         e(i+3,j,k) / den(i+3,j,k)\n+2080           continue\n+2100   continue\n+       end"}, {"sha": "36179188f6d43c47635a220764aaabbb05897b9f", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -1084,6 +1084,33 @@ slpeel_tree_duplicate_loop_to_edge_cfg (class loop *loop,\n   exit = single_exit (loop);\n   basic_block new_preheader = new_bbs[0];\n \n+  /* Before installing PHI arguments make sure that the edges\n+     into them match that of the scalar loop we analyzed.  This\n+     makes sure the SLP tree matches up between the main vectorized\n+     loop and the epilogue vectorized copies.  */\n+  if (single_succ_edge (preheader)->dest_idx\n+      != single_succ_edge (new_bbs[0])->dest_idx)\n+    {\n+      basic_block swap_bb = new_bbs[1];\n+      gcc_assert (EDGE_COUNT (swap_bb->preds) == 2);\n+      std::swap (EDGE_PRED (swap_bb, 0), EDGE_PRED (swap_bb, 1));\n+      EDGE_PRED (swap_bb, 0)->dest_idx = 0;\n+      EDGE_PRED (swap_bb, 1)->dest_idx = 1;\n+    }\n+  if (duplicate_outer_loop)\n+    {\n+      class loop *new_inner_loop = get_loop_copy (scalar_loop->inner);\n+      if (loop_preheader_edge (scalar_loop)->dest_idx\n+\t  != loop_preheader_edge (new_inner_loop)->dest_idx)\n+\t{\n+\t  basic_block swap_bb = new_inner_loop->header;\n+\t  gcc_assert (EDGE_COUNT (swap_bb->preds) == 2);\n+\t  std::swap (EDGE_PRED (swap_bb, 0), EDGE_PRED (swap_bb, 1));\n+\t  EDGE_PRED (swap_bb, 0)->dest_idx = 0;\n+\t  EDGE_PRED (swap_bb, 1)->dest_idx = 1;\n+\t}\n+    }\n+\n   add_phi_args_after_copy (new_bbs, scalar_loop->num_nodes + 1, NULL);\n \n   /* Skip new preheader since it's deleted if copy loop is added at entry.  */"}, {"sha": "75b731407ba45f3dce8994c5655b18a1990c7883", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 101, "deletions": 11, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -7377,15 +7377,24 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n   if (slp_node)\n     {\n       vec_initial_defs.reserve (vec_num);\n-      gcc_assert (slp_node == slp_node_instance->reduc_phis);\n-      stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (reduc_stmt_info);\n-      tree neutral_op\n-\t= neutral_op_for_slp_reduction (slp_node, vectype_out,\n-\t\t\t\t\tSTMT_VINFO_REDUC_CODE (reduc_info),\n-\t\t\t\t\tfirst != NULL);\n-      get_initial_defs_for_reduction (loop_vinfo, slp_node_instance->reduc_phis,\n-\t\t\t\t      &vec_initial_defs, vec_num,\n-\t\t\t\t      first != NULL, neutral_op);\n+      if (nested_cycle)\n+\t{\n+\t  unsigned phi_idx = loop_preheader_edge (loop)->dest_idx;\n+\t  vect_get_slp_defs (SLP_TREE_CHILDREN (slp_node)[phi_idx],\n+\t\t\t     &vec_initial_defs);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (slp_node == slp_node_instance->reduc_phis);\n+\t  stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (reduc_stmt_info);\n+\t  tree neutral_op\n+\t      = neutral_op_for_slp_reduction (slp_node, vectype_out,\n+\t\t\t\t\t      STMT_VINFO_REDUC_CODE (reduc_info),\n+\t\t\t\t\t      first != NULL);\n+\t  get_initial_defs_for_reduction (loop_vinfo, slp_node_instance->reduc_phis,\n+\t\t\t\t\t  &vec_initial_defs, vec_num,\n+\t\t\t\t\t  first != NULL, neutral_op);\n+\t}\n     }\n   else\n     {\n@@ -7520,6 +7529,79 @@ vectorizable_lc_phi (loop_vec_info loop_vinfo,\n   return true;\n }\n \n+/* Vectorizes PHIs.  */\n+\n+bool\n+vectorizable_phi (vec_info *,\n+\t\t  stmt_vec_info stmt_info, gimple **vec_stmt,\n+\t\t  slp_tree slp_node)\n+{\n+  if (!is_a <gphi *> (stmt_info->stmt) || !slp_node)\n+    return false;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n+    return false;\n+\n+  tree vectype = SLP_TREE_VECTYPE (slp_node);\n+\n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      slp_tree child;\n+      unsigned i;\n+      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (slp_node), i, child)\n+\tif (!child)\n+\t  {\n+\t    if (dump_enabled_p ())\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"PHI node with unvectorized backedge def\\n\");\n+\t    return false;\n+\t  }\n+\telse if (!vect_maybe_update_slp_op_vectype (child, vectype))\n+\t  {\n+\t    if (dump_enabled_p ())\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"incompatible vector types for invariants\\n\");\n+\t    return false;\n+\t  }\n+      STMT_VINFO_TYPE (stmt_info) = phi_info_type;\n+      return true;\n+    }\n+\n+  tree scalar_dest = gimple_phi_result (stmt_info->stmt);\n+  basic_block bb = gimple_bb (stmt_info->stmt);\n+  tree vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  auto_vec<tree> vec_oprnds;\n+  auto_vec<gphi *> new_phis;\n+  for (unsigned i = 0; i < gimple_phi_num_args (stmt_info->stmt); ++i)\n+    {\n+      slp_tree child = SLP_TREE_CHILDREN (slp_node)[i];\n+\n+      /* Skip not yet vectorized defs.  */\n+      if (SLP_TREE_DEF_TYPE (child) == vect_internal_def\n+\t  && SLP_TREE_VEC_STMTS (child).is_empty ())\n+\tcontinue;\n+\n+      vect_get_slp_defs (SLP_TREE_CHILDREN (slp_node)[i], &vec_oprnds);\n+      if (!new_phis.exists ())\n+\t{\n+\t  new_phis.create (vec_oprnds.length ());\n+\t  for (unsigned j = 0; j < vec_oprnds.length (); j++)\n+\t    {\n+\t      /* Create the vectorized LC PHI node.  */\n+\t      new_phis.quick_push (create_phi_node (vec_dest, bb));\n+\t      SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phis[j]);\n+\t    }\n+\t}\n+      edge e = gimple_phi_arg_edge (as_a <gphi *> (stmt_info->stmt), i);\n+      for (unsigned j = 0; j < vec_oprnds.length (); j++)\n+\tadd_phi_arg (new_phis[j], vec_oprnds[j], e, UNKNOWN_LOCATION);\n+    }\n+  /* We should have at least one already vectorized child.  */\n+  gcc_assert (new_phis.exists ());\n+\n+  return true;\n+}\n+\n \n /* Function vect_min_worthwhile_factor.\n \n@@ -8376,8 +8458,16 @@ vectorizable_live_operation (vec_info *vinfo,\n       gimple_seq stmts = NULL;\n       new_tree = force_gimple_operand (fold_convert (lhs_type, new_tree),\n \t\t\t\t       &stmts, true, NULL_TREE);\n-\n-      gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+      if (is_a <gphi *> (vec_stmt))\n+\t{\n+\t  gimple_stmt_iterator si = gsi_after_labels (gimple_bb (vec_stmt));\n+\t  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n+\t}\n+      else\n+\t{\n+\t  gimple_stmt_iterator si = gsi_for_stmt (vec_stmt);\n+\t  gsi_insert_seq_after (&si, stmts, GSI_SAME_STMT);\n+\t}\n \n       /* Replace use of lhs with newly computed result.  If the use stmt is a\n \t single arg PHI, just replace all uses of PHI result.  It's necessary"}, {"sha": "f544b552a46fe5dbc52ecf8db32cabdd89bd1823", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 442, "deletions": 222, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -115,7 +115,8 @@ vect_free_slp_tree (slp_tree node)\n     return;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_free_slp_tree (child);\n+    if (child)\n+      vect_free_slp_tree (child);\n \n   delete node;\n }\n@@ -148,9 +149,9 @@ vect_free_slp_instance (slp_instance instance)\n /* Create an SLP node for SCALAR_STMTS.  */\n \n static slp_tree\n-vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts, unsigned nops)\n+vect_create_new_slp_node (slp_tree node,\n+\t\t\t  vec<stmt_vec_info> scalar_stmts, unsigned nops)\n {\n-  slp_tree node = new _slp_tree;\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n   SLP_TREE_CHILDREN (node).create (nops);\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n@@ -159,18 +160,33 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts, unsigned nops)\n   return node;\n }\n \n+/* Create an SLP node for SCALAR_STMTS.  */\n+\n+static slp_tree\n+vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts, unsigned nops)\n+{\n+  return vect_create_new_slp_node (new _slp_tree, scalar_stmts, nops);\n+}\n+\n /* Create an SLP node for OPS.  */\n \n static slp_tree\n-vect_create_new_slp_node (vec<tree> ops)\n+vect_create_new_slp_node (slp_tree node, vec<tree> ops)\n {\n-  slp_tree node = new _slp_tree;\n   SLP_TREE_SCALAR_OPS (node) = ops;\n   SLP_TREE_DEF_TYPE (node) = vect_external_def;\n   SLP_TREE_LANES (node) = ops.length ();\n   return node;\n }\n \n+/* Create an SLP node for OPS.  */\n+\n+static slp_tree\n+vect_create_new_slp_node (vec<tree> ops)\n+{\n+  return vect_create_new_slp_node (new _slp_tree, ops);\n+}\n+\n \n /* This structure is used in creation of an SLP tree.  Each instance\n    corresponds to the same operand in a group of scalar stmts in an SLP\n@@ -443,10 +459,13 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n       else\n \tcommutative_op = commutative_tree_code (code) ? 0U : -1U;\n     }\n+  else if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n+    number_of_oprnds = gimple_phi_num_args (stmt);\n   else\n     return -1;\n \n   bool swapped = (swap != 0);\n+  bool backedge = false;\n   gcc_assert (!swapped || first_op_cond);\n   enum vect_def_type *dts = XALLOCAVEC (enum vect_def_type, number_of_oprnds);\n   for (i = 0; i < number_of_oprnds; i++)\n@@ -463,6 +482,13 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \t  else\n \t    oprnd = gimple_op (stmt_info->stmt, map[i]);\n \t}\n+      else if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n+\t{\n+\t  oprnd = gimple_phi_arg_def (stmt, i);\n+\t  backedge = dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t     gimple_phi_arg_edge (stmt, i)->src,\n+\t\t\t\t     gimple_bb (stmt_info->stmt));\n+\t}\n       else\n \toprnd = gimple_op (stmt_info->stmt, first_op_idx + (swapped ? !i : i));\n       if (TREE_CODE (oprnd) == VIEW_CONVERT_EXPR)\n@@ -487,6 +513,26 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n       oprnd_info->def_stmts.quick_push (def_stmt_info);\n       oprnd_info->ops.quick_push (oprnd);\n \n+      /* If there's a extern def on a backedge make sure we can\n+\t code-generate at the region start.\n+\t ???  This is another case that could be fixed by adjusting\n+\t how we split the function but at the moment we'd have conflicting\n+\t goals there.  */\n+      if (backedge\n+\t  && dts[i] == vect_external_def\n+\t  && is_a <bb_vec_info> (vinfo)\n+\t  && !SSA_NAME_IS_DEFAULT_DEF (oprnd)\n+\t  && !dominated_by_p (CDI_DOMINATORS,\n+\t\t\t      as_a <bb_vec_info> (vinfo)->bbs[0],\n+\t\t\t      gimple_bb (SSA_NAME_DEF_STMT (oprnd))))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Build SLP failed: extern def %T only defined \"\n+\t\t\t     \"on backedge\\n\", oprnd);\n+\t  return -1;\n+\t}\n+\n       if (first)\n \t{\n \t  tree type = TREE_TYPE (oprnd);\n@@ -521,6 +567,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \t    case vect_internal_def:\n \t    case vect_reduction_def:\n \t    case vect_induction_def:\n+\t    case vect_nested_cycle:\n \t      break;\n \n \t    default:\n@@ -815,6 +862,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   machine_mode vec_mode;\n   stmt_vec_info first_load = NULL, prev_first_load = NULL;\n   bool first_stmt_load_p = false, load_p = false;\n+  bool first_stmt_phi_p = false, phi_p = false;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   stmt_vec_info stmt_info;\n@@ -904,6 +952,11 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      return false;\n \t    }\n \t}\n+      else if (gimple_code (stmt) == GIMPLE_PHI)\n+\t{\n+\t  rhs_code = ERROR_MARK;\n+\t  phi_p = true;\n+\t}\n       else\n \t{\n \t  rhs_code = gimple_assign_rhs_code (stmt);\n@@ -916,6 +969,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t  *node_vectype = vectype;\n \t  first_stmt_code = rhs_code;\n \t  first_stmt_load_p = load_p;\n+\t  first_stmt_phi_p = phi_p;\n \n \t  /* Shift arguments should be equal in all the packed stmts for a\n \t     vector shift with scalar shift operand.  */\n@@ -1021,7 +1075,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t\t|| first_stmt_code == INDIRECT_REF\n \t\t\t|| first_stmt_code == COMPONENT_REF\n \t\t\t|| first_stmt_code == MEM_REF)))\n-\t      || first_stmt_load_p != load_p)\n+\t      || first_stmt_load_p != load_p\n+\t      || first_stmt_phi_p != phi_p)\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -1077,6 +1132,18 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t}\n \t    }\n \n+\t  if (phi_p\n+\t      && (gimple_bb (first_stmt_info->stmt)\n+\t\t  != gimple_bb (stmt_info->stmt)))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: different BB for PHI \"\n+\t\t\t\t \"in %G\", stmt);\n+\t      /* Mismatch.  */\n+\t      continue;\n+\t    }\n+\n \t  if (!types_compatible_p (vectype, *node_vectype))\n \t    {\n \t      if (dump_enabled_p ())\n@@ -1138,7 +1205,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t    }\n \n \t  /* Not memory operation.  */\n-\t  if (TREE_CODE_CLASS (rhs_code) != tcc_binary\n+\t  if (!phi_p\n+\t      && TREE_CODE_CLASS (rhs_code) != tcc_binary\n \t      && TREE_CODE_CLASS (rhs_code) != tcc_unary\n \t      && TREE_CODE_CLASS (rhs_code) != tcc_expression\n \t      && TREE_CODE_CLASS (rhs_code) != tcc_comparison\n@@ -1251,7 +1319,7 @@ typedef hash_map <vec <gimple *>, slp_tree,\n   scalar_stmts_to_slp_tree_map_t;\n \n static slp_tree\n-vect_build_slp_tree_2 (vec_info *vinfo,\n+vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t\t       vec<stmt_vec_info> stmts, unsigned int group_size,\n \t\t       poly_uint64 *max_nunits,\n \t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n@@ -1276,19 +1344,37 @@ vect_build_slp_tree (vec_info *vinfo,\n \t}\n       return *leader;\n     }\n+\n+  /* Seed the bst_map with a stub node to be filled by vect_build_slp_tree_2\n+     so we can pick up backedge destinations during discovery.  */\n+  slp_tree res = new _slp_tree;\n+  SLP_TREE_DEF_TYPE (res) = vect_internal_def;\n+  SLP_TREE_SCALAR_STMTS (res) = stmts;\n+  bst_map->put (stmts.copy (), res);\n+\n   poly_uint64 this_max_nunits = 1;\n-  slp_tree res = vect_build_slp_tree_2 (vinfo, stmts, group_size,\n+  slp_tree res_ = vect_build_slp_tree_2 (vinfo, res, stmts, group_size,\n \t\t\t\t\t&this_max_nunits,\n \t\t\t\t\tmatches, npermutes, tree_size, bst_map);\n-  if (res)\n+  if (!res_)\n+    {\n+      bool existed_p = bst_map->put (stmts, NULL);\n+      gcc_assert (existed_p);\n+      /* Mark the node invalid so we can detect those when still in use\n+\t as backedge destinations.  */\n+      SLP_TREE_SCALAR_STMTS (res) = vNULL;\n+      SLP_TREE_DEF_TYPE (res) = vect_uninitialized_def;\n+      vect_free_slp_tree (res);\n+    }\n+  else\n     {\n+      gcc_assert (res_ == res);\n       res->max_nunits = this_max_nunits;\n       vect_update_max_nunits (max_nunits, this_max_nunits);\n       /* Keep a reference for the bst_map use.  */\n       SLP_TREE_REF_COUNT (res)++;\n     }\n-  bst_map->put (stmts.copy (), res);\n-  return res;\n+  return res_;\n }\n \n /* Recursively build an SLP tree starting from NODE.\n@@ -1299,15 +1385,14 @@ vect_build_slp_tree (vec_info *vinfo,\n    was found.  */\n \n static slp_tree\n-vect_build_slp_tree_2 (vec_info *vinfo,\n+vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t\t       vec<stmt_vec_info> stmts, unsigned int group_size,\n \t\t       poly_uint64 *max_nunits,\n \t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t       scalar_stmts_to_slp_tree_map_t *bst_map)\n {\n   unsigned nops, i, this_tree_size = 0;\n   poly_uint64 this_max_nunits = *max_nunits;\n-  slp_tree node;\n \n   matches[0] = false;\n \n@@ -1327,41 +1412,60 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \n   /* If the SLP node is a PHI (induction or reduction), terminate\n      the recursion.  */\n-  if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n-    {\n-      tree scalar_type = TREE_TYPE (PHI_RESULT (stmt));\n-      tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type,\n-\t\t\t\t\t\t  group_size);\n-      if (!vect_record_max_nunits (vinfo, stmt_info, group_size, vectype,\n-\t\t\t\t   max_nunits))\n-\treturn NULL;\n+  bool skip_args[2] = { false, false };\n+  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n+    if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n+      {\n+\ttree scalar_type = TREE_TYPE (PHI_RESULT (stmt));\n+\ttree vectype = get_vectype_for_scalar_type (vinfo, scalar_type,\n+\t\t\t\t\t\t    group_size);\n+\tif (!vect_record_max_nunits (vinfo, stmt_info, group_size, vectype,\n+\t\t\t\t     max_nunits))\n+\t  return NULL;\n \n-      vect_def_type def_type = STMT_VINFO_DEF_TYPE (stmt_info);\n-      /* Induction from different IVs is not supported.  */\n-      if (def_type == vect_induction_def)\n-\t{\n-\t  stmt_vec_info other_info;\n-\t  FOR_EACH_VEC_ELT (stmts, i, other_info)\n-\t    if (stmt_info != other_info)\n-\t      return NULL;\n-\t}\n-      else if (def_type == vect_reduction_def\n-\t       || def_type == vect_double_reduction_def\n-\t       || def_type == vect_nested_cycle)\n-\t{\n-\t  /* Else def types have to match.  */\n-\t  stmt_vec_info other_info;\n-\t  FOR_EACH_VEC_ELT (stmts, i, other_info)\n-\t    if (STMT_VINFO_DEF_TYPE (other_info) != def_type)\n-\t      return NULL;\n-\t}\n-      else\n-\treturn NULL;\n-      (*tree_size)++;\n-      node = vect_create_new_slp_node (stmts, nops);\n-      SLP_TREE_VECTYPE (node) = vectype;\n-      return node;\n-    }\n+\tvect_def_type def_type = STMT_VINFO_DEF_TYPE (stmt_info);\n+\t/* Induction from different IVs is not supported.  */\n+\tif (def_type == vect_induction_def)\n+\t  {\n+\t    stmt_vec_info other_info;\n+\t    FOR_EACH_VEC_ELT (stmts, i, other_info)\n+\t      if (stmt_info != other_info)\n+\t\treturn NULL;\n+\n+\t    /* Induction PHIs are leafs.  */\n+\t    (*tree_size)++;\n+\t    node = vect_create_new_slp_node (node, stmts, nops);\n+\t    SLP_TREE_VECTYPE (node) = vectype;\n+\t    SLP_TREE_CHILDREN (node).quick_grow_cleared (nops);\n+\t    return node;\n+\t  }\n+\telse if (def_type == vect_reduction_def\n+\t\t || def_type == vect_double_reduction_def\n+\t\t || def_type == vect_nested_cycle)\n+\t  {\n+\t    /* Else def types have to match.  */\n+\t    stmt_vec_info other_info;\n+\t    bool all_same = true;\n+\t    FOR_EACH_VEC_ELT (stmts, i, other_info)\n+\t      {\n+\t\tif (STMT_VINFO_DEF_TYPE (other_info) != def_type)\n+\t\t  return NULL;\n+\t\tif (other_info != stmt_info)\n+\t\t  all_same = false;\n+\t      }\n+\t    class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\t    /* Reduction initial values are not explicitely represented.  */\n+\t    if (!nested_in_vect_loop_p (loop, stmt_info))\n+\t      skip_args[loop_preheader_edge (loop)->dest_idx] = true;\n+\t    /* Reduction chain backedge defs are filled manually.\n+\t       ???  Need a better way to identify a SLP reduction chain PHI.\n+\t       Or a better overall way to SLP match those.  */\n+\t    if (all_same && def_type == vect_reduction_def)\n+\t      skip_args[loop_latch_edge (loop)->dest_idx] = true;\n+\t  }\n+\telse if (def_type != vect_internal_def)\n+\t  return NULL;\n+      }\n \n \n   bool two_operators = false;\n@@ -1386,7 +1490,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t{\n \t  *max_nunits = this_max_nunits;\n \t  (*tree_size)++;\n-\t  node = vect_create_new_slp_node (stmts, 0);\n+\t  node = vect_create_new_slp_node (node, stmts, 0);\n \t  SLP_TREE_VECTYPE (node) = vectype;\n \t  /* And compute the load permutation.  Whether it is actually\n \t     a permutation depends on the unrolling factor which is\n@@ -1440,7 +1544,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t representing an actual vector without any scalar ops.\n \t ???  We could hide it completely with making the permute node\n \t external?  */\n-      node = vect_create_new_slp_node (stmts, 1);\n+      node = vect_create_new_slp_node (node, stmts, 1);\n       SLP_TREE_CODE (node) = VEC_PERM_EXPR;\n       SLP_TREE_LANE_PERMUTATION (node) = lperm;\n       SLP_TREE_VECTYPE (node) = vectype;\n@@ -1486,6 +1590,14 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  continue;\n \t}\n \n+      /* We're skipping certain operands from processing, for example\n+\t outer loop reduction initial defs.  */\n+      if (i <= 1 && skip_args[i])\n+\t{\n+\t  children.safe_push (NULL);\n+\t  continue;\n+\t}\n+\n       if (is_a <bb_vec_info> (vinfo)\n \t  && oprnd_info->first_dt == vect_internal_def)\n \t{\n@@ -1508,9 +1620,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t    }\n \t}\n \n-      if (oprnd_info->first_dt != vect_internal_def\n-\t  && oprnd_info->first_dt != vect_reduction_def\n-\t  && oprnd_info->first_dt != vect_induction_def)\n+      if (oprnd_info->first_dt == vect_external_def\n+\t  || oprnd_info->first_dt == vect_constant_def)\n \t{\n \t  slp_tree invnode = vect_create_new_slp_node (oprnd_info->ops);\n \t  SLP_TREE_DEF_TYPE (invnode) = oprnd_info->first_dt;\n@@ -1639,14 +1750,14 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t      child = vect_create_new_slp_node (oprnd_info->ops);\n \t      children.safe_push (child);\n \t      oprnd_info->ops = vNULL;\n-\t      oprnd_info->def_stmts = vNULL;\n \t      continue;\n \t    }\n \t}\n \n       gcc_assert (child == NULL);\n       FOR_EACH_VEC_ELT (children, j, child)\n-\tvect_free_slp_tree (child);\n+\tif (child)\n+\t  vect_free_slp_tree (child);\n       vect_free_oprnd_info (oprnds_info);\n       return NULL;\n     }\n@@ -1670,7 +1781,9 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n       unsigned n_vector_builds = 0;\n       FOR_EACH_VEC_ELT (children, j, child)\n \t{\n-\t  if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+\t  if (!child)\n+\t    ;\n+\t  else if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n \t    all_uniform_p = false;\n \t  else if (!vect_slp_tree_uniform_p (child))\n \t    {\n@@ -1684,7 +1797,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  /* Roll back.  */\n \t  matches[0] = false;\n \t  FOR_EACH_VEC_ELT (children, j, child)\n-\t    vect_free_slp_tree (child);\n+\t    if (child)\n+\t      vect_free_slp_tree (child);\n \n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1718,7 +1832,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \n       /* Here we record the original defs since this\n \t node represents the final lane configuration.  */\n-      node = vect_create_new_slp_node (stmts, 2);\n+      node = vect_create_new_slp_node (node, stmts, 2);\n       SLP_TREE_VECTYPE (node) = vectype;\n       SLP_TREE_CODE (node) = VEC_PERM_EXPR;\n       SLP_TREE_CHILDREN (node).quick_push (one);\n@@ -1749,7 +1863,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n       return node;\n     }\n \n-  node = vect_create_new_slp_node (stmts, nops);\n+  node = vect_create_new_slp_node (node, stmts, nops);\n   SLP_TREE_VECTYPE (node) = vectype;\n   SLP_TREE_CHILDREN (node).splice (children);\n   return node;\n@@ -1835,7 +1949,8 @@ vect_print_slp_graph (dump_flags_t dump_kind, dump_location_t loc,\n   vect_print_slp_tree (dump_kind, loc, node);\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_print_slp_graph (dump_kind, loc, child, visited);\n+    if (child)\n+      vect_print_slp_graph (dump_kind, loc, child, visited);\n }\n \n static void\n@@ -1865,7 +1980,8 @@ vect_mark_slp_stmts (slp_tree node, hash_set<slp_tree> &visited)\n     STMT_SLP_TYPE (stmt_info) = pure_slp;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_mark_slp_stmts (child, visited);\n+    if (child)\n+      vect_mark_slp_stmts (child, visited);\n }\n \n static void\n@@ -1898,7 +2014,8 @@ vect_mark_slp_stmts_relevant (slp_tree node, hash_set<slp_tree> &visited)\n     }\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_mark_slp_stmts_relevant (child, visited);\n+    if (child)\n+      vect_mark_slp_stmts_relevant (child, visited);\n }\n \n static void\n@@ -1915,7 +2032,7 @@ static void\n vect_gather_slp_loads (vec<slp_tree> &loads, slp_tree node,\n \t\t       hash_set<slp_tree> &visited)\n {\n-  if (visited.add (node))\n+  if (!node || visited.add (node))\n     return;\n \n   if (SLP_TREE_CHILDREN (node).length () == 0)\n@@ -2176,34 +2293,62 @@ vect_build_slp_instance (vec_info *vinfo,\n \t\t}\n \t    }\n \n-\t  /* If this is a reduction chain with a conversion in front\n-\t     amend the SLP tree with a node for that.  */\n-\t  if (kind == slp_inst_kind_reduc_chain\n-\t      && STMT_VINFO_DEF_TYPE (scalar_stmts[0]) != vect_reduction_def)\n+\t  /* Fixup SLP reduction chains.  */\n+\t  if (kind == slp_inst_kind_reduc_chain)\n \t    {\n-\t      /* Get at the conversion stmt - we know it's the single use\n-\t\t of the last stmt of the reduction chain.  */\n-\t      gimple *tem = vect_orig_stmt (scalar_stmts[group_size - 1])->stmt;\n+\t      /* If this is a reduction chain with a conversion in front\n+\t\t amend the SLP tree with a node for that.  */\n+\t      gimple *scalar_def\n+\t\t= vect_orig_stmt (scalar_stmts[group_size - 1])->stmt;\n+\t      if (STMT_VINFO_DEF_TYPE (scalar_stmts[0]) != vect_reduction_def)\n+\t\t{\n+\t\t  /* Get at the conversion stmt - we know it's the single use\n+\t\t     of the last stmt of the reduction chain.  */\n+\t\t  use_operand_p use_p;\n+\t\t  bool r = single_imm_use (gimple_assign_lhs (scalar_def),\n+\t\t\t\t\t   &use_p, &scalar_def);\n+\t\t  gcc_assert (r);\n+\t\t  stmt_vec_info next_info = vinfo->lookup_stmt (scalar_def);\n+\t\t  next_info = vect_stmt_to_vectorize (next_info);\n+\t\t  scalar_stmts = vNULL;\n+\t\t  scalar_stmts.create (group_size);\n+\t\t  for (unsigned i = 0; i < group_size; ++i)\n+\t\t    scalar_stmts.quick_push (next_info);\n+\t\t  slp_tree conv = vect_create_new_slp_node (scalar_stmts, 1);\n+\t\t  SLP_TREE_VECTYPE (conv) = STMT_VINFO_VECTYPE (next_info);\n+\t\t  SLP_TREE_CHILDREN (conv).quick_push (node);\n+\t\t  SLP_INSTANCE_TREE (new_instance) = conv;\n+\t\t  /* We also have to fake this conversion stmt as SLP reduction\n+\t\t     group so we don't have to mess with too much code\n+\t\t     elsewhere.  */\n+\t\t  REDUC_GROUP_FIRST_ELEMENT (next_info) = next_info;\n+\t\t  REDUC_GROUP_NEXT_ELEMENT (next_info) = NULL;\n+\t\t}\n+\t      /* Fill the backedge child of the PHI SLP node.  The\n+\t\t general matching code cannot find it because the\n+\t\t scalar code does not reflect how we vectorize the\n+\t\t reduction.  */\n \t      use_operand_p use_p;\n-\t      gimple *use_stmt;\n-\t      bool r = single_imm_use (gimple_assign_lhs (tem),\n-\t\t\t\t       &use_p, &use_stmt);\n-\t      gcc_assert (r);\n-\t      stmt_vec_info next_info = vinfo->lookup_stmt (use_stmt);\n-\t      next_info = vect_stmt_to_vectorize (next_info);\n-\t      scalar_stmts = vNULL;\n-\t      scalar_stmts.create (group_size);\n-\t      for (unsigned i = 0; i < group_size; ++i)\n-\t\tscalar_stmts.quick_push (next_info);\n-\t      slp_tree conv = vect_create_new_slp_node (scalar_stmts, 1);\n-\t      SLP_TREE_VECTYPE (conv) = STMT_VINFO_VECTYPE (next_info);\n-\t      SLP_TREE_CHILDREN (conv).quick_push (node);\n-\t      SLP_INSTANCE_TREE (new_instance) = conv;\n-\t      /* We also have to fake this conversion stmt as SLP reduction\n-\t\t group so we don't have to mess with too much code\n-\t\t elsewhere.  */\n-\t      REDUC_GROUP_FIRST_ELEMENT (next_info) = next_info;\n-\t      REDUC_GROUP_NEXT_ELEMENT (next_info) = NULL;\n+\t      imm_use_iterator imm_iter;\n+\t      class loop *loop = LOOP_VINFO_LOOP (as_a <loop_vec_info> (vinfo));\n+\t      FOR_EACH_IMM_USE_FAST (use_p, imm_iter,\n+\t\t\t\t     gimple_get_lhs (scalar_def))\n+\t\t/* There are exactly two non-debug uses, the reduction\n+\t\t   PHI and the loop-closed PHI node.  */\n+\t\tif (!is_gimple_debug (USE_STMT (use_p))\n+\t\t    && gimple_bb (USE_STMT (use_p)) == loop->header)\n+\t\t  {\n+\t\t    auto_vec<stmt_vec_info, 64> phis (group_size);\n+\t\t    stmt_vec_info phi_info\n+\t\t      = vinfo->lookup_stmt (USE_STMT (use_p));\n+\t\t    for (unsigned i = 0; i < group_size; ++i)\n+\t\t      phis.quick_push (phi_info);\n+\t\t    slp_tree *phi_node = bst_map->get (phis);\n+\t\t    unsigned dest_idx = loop_latch_edge (loop)->dest_idx;\n+\t\t    SLP_TREE_CHILDREN (*phi_node)[dest_idx]\n+\t\t      = SLP_INSTANCE_TREE (new_instance);\n+\t\t    SLP_INSTANCE_TREE (new_instance)->refcnt++;\n+\t\t  }\n \t    }\n \n \t  vinfo->slp_instances.safe_push (new_instance);\n@@ -2437,60 +2582,6 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   return res;\n }\n \n-/* Fill in backedge SLP children in the SLP graph.  */\n-\n-static void\n-vect_analyze_slp_backedges (vec_info *vinfo, slp_tree node,\n-\t\t\t    scalar_stmts_to_slp_tree_map_t *bst_map,\n-\t\t\t    hash_set<slp_tree> &visited)\n-{\n-  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def\n-      || visited.add (node))\n-    return;\n-\n-  slp_tree child;\n-  unsigned i;\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (child)\n-      vect_analyze_slp_backedges (vinfo, child, bst_map, visited);\n-\n-  /* Inductions are not vectorized by vectorizing their defining cycle\n-     but by materializing the values from SCEV data.  */\n-  if (STMT_VINFO_DEF_TYPE (SLP_TREE_REPRESENTATIVE (node))\n-      == vect_induction_def)\n-    return;\n-\n-  if (gphi *phi = dyn_cast <gphi *> (SLP_TREE_REPRESENTATIVE (node)->stmt))\n-    for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n-      {\n-\tauto_vec<stmt_vec_info, 64> stmts;\n-\tunsigned j;\n-\tstmt_vec_info phi_info;\n-\tFOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, phi_info)\n-\t  {\n-\t    tree def = gimple_phi_arg_def (as_a <gphi *>(phi_info->stmt), i);\n-\t    stmt_vec_info def_info = vinfo->lookup_def (def);\n-\t    if (!def_info)\n-\t      break;\n-\t    stmts.safe_push (vect_stmt_to_vectorize (def_info));\n-\t  }\n-\tif (j != SLP_TREE_LANES (node))\n-\t  continue;\n-\tslp_tree *edge_def = bst_map->get (stmts);\n-\tif (edge_def)\n-\t  {\n-\t    /* ???  We're currently not recording non-backedge children\n-\t       of PHIs like external reduction initial values.  Avoid\n-\t       NULL entries in SLP_TREE_CHILDREN for those and thus\n-\t       for now simply only record backedge defs at a\n-\t       SLP_TREE_CHILDREN index possibly not matching that of\n-\t       the corresponding PHI argument index.  */\n-\t    SLP_TREE_CHILDREN (node).quick_push (*edge_def);\n-\t    (*edge_def)->refcnt++;\n-\t  }\n-      }\n-}\n-\n /* Check if there are stmts in the loop can be vectorized using SLP.  Build SLP\n    trees of packed scalar stmts if SLP is possible.  */\n \n@@ -2541,13 +2632,6 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \t\t\t\t   max_tree_size);\n     }\n \n-  /* Fill in backedges.  */\n-  slp_instance instance;\n-  hash_set<slp_tree> visited;\n-  FOR_EACH_VEC_ELT (vinfo->slp_instances, i, instance)\n-    vect_analyze_slp_backedges (vinfo, SLP_INSTANCE_TREE (instance),\n-\t\t\t\tbst_map, visited);\n-\n   /* The map keeps a reference on SLP nodes built, release that.  */\n   for (scalar_stmts_to_slp_tree_map_t::iterator it = bst_map->begin ();\n        it != bst_map->end (); ++it)\n@@ -2572,11 +2656,16 @@ vect_slp_build_vertices (hash_set<slp_tree> &visited, slp_tree node,\n \n   node->vertex = vertices.length ();\n   vertices.safe_push (node);\n-  if (SLP_TREE_CHILDREN (node).is_empty ())\n+\n+  bool leaf = true;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (child)\n+      {\n+\tleaf = false;\n+\tvect_slp_build_vertices (visited, child, vertices, leafs);\n+      }\n+  if (leaf)\n     leafs.safe_push (node->vertex);\n-  else\n-    FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-      vect_slp_build_vertices (visited, child, vertices, leafs);\n }\n \n /* Fill the vertices and leafs vector with all nodes in the SLP graph.  */\n@@ -2654,7 +2743,8 @@ vect_optimize_slp (vec_info *vinfo)\n       unsigned j;\n       slp_tree child;\n       FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-\tadd_edge (slpg, i, child->vertex);\n+\tif (child)\n+\t  add_edge (slpg, i, child->vertex);\n     }\n \n   /* Compute (reverse) postorder on the inverted graph.  */\n@@ -2853,7 +2943,7 @@ vect_optimize_slp (vec_info *vinfo)\n       slp_tree child;\n       FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n \t{\n-\t  if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+\t  if (!child || SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n \t    continue;\n \n \t  /* If the vector is uniform there's nothing to do.  */\n@@ -3291,6 +3381,7 @@ vect_slp_convert_to_external (vec_info *vinfo, slp_tree node,\n   unsigned int group_size = SLP_TREE_LANES (node);\n   SLP_TREE_DEF_TYPE (node) = vect_external_def;\n   SLP_TREE_SCALAR_OPS (node).safe_grow (group_size, true);\n+  SLP_TREE_LOAD_PERMUTATION (node).release ();\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     {\n       tree lhs = gimple_get_lhs (vect_orig_stmt (stmt_info)->stmt);\n@@ -3373,9 +3464,20 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n   slp_tree child;\n \n   /* Assume we can code-generate all invariants.  */\n-  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n+  if (!node\n+      || SLP_TREE_DEF_TYPE (node) == vect_constant_def\n+      || SLP_TREE_DEF_TYPE (node) == vect_external_def)\n     return true;\n \n+  if (SLP_TREE_DEF_TYPE (node) == vect_uninitialized_def)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Failed cyclic SLP reference in %p\", node);\n+      return false;\n+    }\n+  gcc_assert (SLP_TREE_DEF_TYPE (node) == vect_internal_def);\n+\n   /* If we already analyzed the exact same set of scalar stmts we're done.\n      We share the generated vector stmts for those.  */\n   if (visited.contains (node)\n@@ -3404,8 +3506,9 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n      other referrers.  */\n   if (res)\n     FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-      if ((SLP_TREE_DEF_TYPE (child) == vect_constant_def\n-\t   || SLP_TREE_DEF_TYPE (child) == vect_external_def)\n+      if (child\n+\t  && (SLP_TREE_DEF_TYPE (child) == vect_constant_def\n+\t      || SLP_TREE_DEF_TYPE (child) == vect_external_def)\n \t  /* Perform usual caching, note code-generation still\n \t     code-gens these nodes multiple times but we expect\n \t     to CSE them later.  */\n@@ -3459,8 +3562,12 @@ static void\n vect_bb_slp_mark_live_stmts (bb_vec_info bb_vinfo, slp_tree node,\n \t\t\t     slp_instance instance,\n \t\t\t     stmt_vector_for_cost *cost_vec,\n-\t\t\t     hash_set<stmt_vec_info> &svisited)\n+\t\t\t     hash_set<stmt_vec_info> &svisited,\n+\t\t\t     hash_set<slp_tree> &visited)\n {\n+  if (visited.add (node))\n+    return;\n+\n   unsigned i;\n   stmt_vec_info stmt_info;\n   stmt_vec_info last_stmt = vect_find_last_scalar_stmt_in_slp (node);\n@@ -3479,7 +3586,7 @@ vect_bb_slp_mark_live_stmts (bb_vec_info bb_vinfo, slp_tree node,\n       gimple *orig_stmt = orig_stmt_info->stmt;\n       ssa_op_iter op_iter;\n       def_operand_p def_p;\n-      FOR_EACH_SSA_DEF_OPERAND (def_p, orig_stmt, op_iter, SSA_OP_DEF)\n+      FOR_EACH_PHI_OR_STMT_DEF (def_p, orig_stmt, op_iter, SSA_OP_DEF)\n \t{\n \t  imm_use_iterator use_iter;\n \t  gimple *use_stmt;\n@@ -3548,9 +3655,9 @@ vect_bb_slp_mark_live_stmts (bb_vec_info bb_vinfo, slp_tree node,\n \n   slp_tree child;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+    if (child && SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n       vect_bb_slp_mark_live_stmts (bb_vinfo, child, instance,\n-\t\t\t\t   cost_vec, svisited);\n+\t\t\t\t   cost_vec, svisited, visited);\n }\n \n /* Analyze statements in SLP instances of VINFO.  Return true if the\n@@ -3615,11 +3722,13 @@ vect_slp_analyze_operations (vec_info *vinfo)\n   if (bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (vinfo))\n     {\n       hash_set<stmt_vec_info> svisited;\n+      hash_set<slp_tree> visited;\n       for (i = 0; vinfo->slp_instances.iterate (i, &instance); ++i)\n \t{\n \t  vect_location = instance->location ();\n \t  vect_bb_slp_mark_live_stmts (bb_vinfo, SLP_INSTANCE_TREE (instance),\n-\t\t\t\t       instance, &instance->cost_vec, svisited);\n+\t\t\t\t       instance, &instance->cost_vec, svisited,\n+\t\t\t\t       visited);\n \t}\n     }\n \n@@ -3683,7 +3792,7 @@ vect_bb_partition_graph_r (bb_vec_info bb_vinfo,\n \n   slp_tree child;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+    if (child && SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n       vect_bb_partition_graph_r (bb_vinfo, instance, child, stmt_to_instance,\n \t\t\t\t instance_leader, visited);\n }\n@@ -3759,7 +3868,7 @@ vect_bb_slp_scalar_cost (vec_info *vinfo,\n \t the scalar cost.  */\n       if (!STMT_VINFO_LIVE_P (stmt_info))\n \t{\n-\t  FOR_EACH_SSA_DEF_OPERAND (def_p, orig_stmt, op_iter, SSA_OP_DEF)\n+\t  FOR_EACH_PHI_OR_STMT_DEF (def_p, orig_stmt, op_iter, SSA_OP_DEF)\n \t    {\n \t      imm_use_iterator use_iter;\n \t      gimple *use_stmt;\n@@ -3803,7 +3912,7 @@ vect_bb_slp_scalar_cost (vec_info *vinfo,\n   auto_vec<bool, 20> subtree_life;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     {\n-      if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+      if (child && SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n \t{\n \t  /* Do not directly pass LIFE to the recursive call, copy it to\n \t     confine changes in the callee to the current child/subtree.  */\n@@ -4272,19 +4381,18 @@ vect_slp_function (function *fun)\n   for (unsigned i = 0; i < n; i++)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n-\n-      /* Split when a basic block has multiple predecessors or when the\n-\t edge into it exits a loop (because of implementation issues with\n-\t respect to placement of CTORs for externals).  */\n       bool split = false;\n-      edge e;\n-      if (!single_pred_p (bb)\n-\t  || ((e = single_pred_edge (bb)),\n-\t      loop_exit_edge_p (e->src->loop_father, e)))\n-\tsplit = true;\n+\n       /* Split when a BB is not dominated by the first block.  */\n+      if (!bbs.is_empty ()\n+\t  && !dominated_by_p (CDI_DOMINATORS, bb, bbs[0]))\n+\tsplit = true;\n+      /* Split when the loop determined by the first block\n+\t is exited.  This is because we eventually insert\n+\t invariants at region begin.  */\n       else if (!bbs.is_empty ()\n-\t       && !dominated_by_p (CDI_DOMINATORS, bb, bbs[0]))\n+\t       && bbs[0]->loop_father != bb->loop_father\n+\t       && !flow_loop_nested_p (bbs[0]->loop_father, bb->loop_father))\n \tsplit = true;\n \n       if (split && !bbs.is_empty ())\n@@ -5087,24 +5195,22 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n   return true;\n }\n \n-/* Vectorize SLP instance tree in postorder.  */\n+/* Vectorize SLP NODE.  */\n \n static void\n-vect_schedule_slp_instance (vec_info *vinfo,\n-\t\t\t    slp_tree node, slp_instance instance,\n-\t\t\t    hash_set<slp_tree> &visited)\n+vect_schedule_slp_node (vec_info *vinfo,\n+\t\t\tslp_tree node, slp_instance instance)\n {\n   gimple_stmt_iterator si;\n   int i;\n   slp_tree child;\n \n-  /* See if we have already vectorized the node in the graph of the\n-     SLP instance.  */\n-  if ((SLP_TREE_DEF_TYPE (node) == vect_internal_def\n-       && SLP_TREE_VEC_STMTS (node).exists ())\n-      || SLP_TREE_VEC_DEFS (node).exists ())\n+  /* For existing vectors there's nothing to do.  */\n+  if (SLP_TREE_VEC_DEFS (node).exists ())\n     return;\n \n+  gcc_assert (SLP_TREE_VEC_STMTS (node).is_empty ());\n+\n   /* Vectorize externals and constants.  */\n   if (SLP_TREE_DEF_TYPE (node) == vect_constant_def\n       || SLP_TREE_DEF_TYPE (node) == vect_external_def)\n@@ -5119,17 +5225,11 @@ vect_schedule_slp_instance (vec_info *vinfo,\n       return;\n     }\n \n-  /* ???  If we'd have a way to mark backedges that would be cheaper.  */\n-  if (visited.add (node))\n-    return;\n-\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_schedule_slp_instance (vinfo, child, instance, visited);\n+  stmt_vec_info stmt_info = SLP_TREE_REPRESENTATIVE (node);\n \n   gcc_assert (SLP_TREE_NUMBER_OF_VEC_STMTS (node) != 0);\n   SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));\n \n-  stmt_vec_info stmt_info = SLP_TREE_REPRESENTATIVE (node);\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"------>vectorizing SLP node starting from: %G\",\n@@ -5148,13 +5248,12 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \tlast_stmt_info = vect_find_last_scalar_stmt_in_slp (node);\n       si = gsi_for_stmt (last_stmt_info->stmt);\n     }\n-  else if ((STMT_VINFO_TYPE (SLP_TREE_REPRESENTATIVE (node))\n-\t    == cycle_phi_info_type)\n-\t   || (STMT_VINFO_TYPE (SLP_TREE_REPRESENTATIVE (node))\n-\t       == induc_vec_info_type))\n+  else if ((STMT_VINFO_TYPE (stmt_info) == cycle_phi_info_type\n+\t    || STMT_VINFO_TYPE (stmt_info) == induc_vec_info_type\n+\t    || STMT_VINFO_TYPE (stmt_info) == phi_info_type)\n+\t   && SLP_TREE_CODE (node) != VEC_PERM_EXPR)\n     {\n-      /* For reduction and induction PHIs we do not use the\n-\t insertion iterator.  */\n+      /* For PHI node vectorization we do not use the insertion iterator.  */\n       si = gsi_none ();\n     }\n   else\n@@ -5277,7 +5376,7 @@ vect_remove_slp_scalar_calls (vec_info *vinfo,\n   tree lhs;\n   stmt_vec_info stmt_info;\n \n-  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n+  if (!node || SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return;\n \n   if (visited.add (node))\n@@ -5359,6 +5458,142 @@ vectorize_slp_instance_root_stmt (slp_tree node, slp_instance instance)\n     gsi_replace (&rgsi, rstmt, true);\n }\n \n+struct slp_scc_info\n+{\n+  bool on_stack;\n+  int dfs;\n+  int lowlink;\n+};\n+\n+/* Schedule the SLP INSTANCE doing a DFS walk and collecting SCCs.  */\n+\n+static void\n+vect_schedule_scc (vec_info *vinfo, slp_tree node, slp_instance instance,\n+\t\t   hash_map<slp_tree, slp_scc_info> &scc_info,\n+\t\t   int &maxdfs, vec<slp_tree> &stack)\n+{\n+  bool existed_p;\n+  slp_scc_info *info = &scc_info.get_or_insert (node, &existed_p);\n+  gcc_assert (!existed_p);\n+  info->dfs = maxdfs;\n+  info->lowlink = maxdfs;\n+  info->on_stack = true;\n+  maxdfs++;\n+  stack.safe_push (node);\n+  unsigned i;\n+  slp_tree child;\n+\n+  /* ???  We're keeping SLP_TREE_CHILDREN of externalized nodes.  */\n+  if (SLP_TREE_DEF_TYPE (node) == vect_internal_def)\n+    FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+      {\n+\tif (!child)\n+\t  continue;\n+\tslp_scc_info *child_info = scc_info.get (child);\n+\tif (!child_info)\n+\t  {\n+\t    vect_schedule_scc (vinfo, child, instance, scc_info, maxdfs, stack);\n+\t    /* Recursion might have re-allocated the node.  */\n+\t    info = scc_info.get (node);\n+\t    child_info = scc_info.get (child);\n+\t    info->lowlink = MIN (info->lowlink, child_info->lowlink);\n+\t  }\n+\telse if (child_info->on_stack)\n+\t  info->lowlink = MIN (info->lowlink, child_info->dfs);\n+      }\n+  if (info->lowlink != info->dfs)\n+    return;\n+\n+  /* Singleton.  */\n+  if (stack.last () == node)\n+    {\n+      stack.pop ();\n+      info->on_stack = false;\n+      vect_schedule_slp_node (vinfo, node, instance);\n+      return;\n+    }\n+  /* SCC.  */\n+  int last_idx = stack.length () - 1;\n+  while (stack[last_idx] != node)\n+    last_idx--;\n+  /* We can break the cycle at PHIs who have at least one child\n+     code generated.  Then we could re-start the DFS walk until\n+     all nodes in the SCC are covered (we might have new entries\n+     for only back-reachable nodes).  But it's simpler to just\n+     iterate and schedule those that are ready.  */\n+  auto_vec<slp_tree, 4> phis_to_fixup;\n+  unsigned todo = stack.length () - last_idx;\n+  do\n+    {\n+      for (int idx = stack.length () - 1; idx >= last_idx; --idx)\n+\t{\n+\t  slp_tree entry = stack[idx];\n+\t  if (!entry)\n+\t    continue;\n+\t  bool phi = (SLP_TREE_CODE (entry) != VEC_PERM_EXPR\n+\t\t      && is_a <gphi *> (SLP_TREE_REPRESENTATIVE (entry)->stmt));\n+\t  bool ready = !phi;\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (entry), i, child)\n+\t    if (!child)\n+\t      {\n+\t\tgcc_assert (phi);\n+\t\tready = true;\n+\t\tbreak;\n+\t      }\n+\t    else if (scc_info.get (child)->on_stack)\n+\t      {\n+\t\tif (!phi)\n+\t\t  {\n+\t\t    ready = false;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (phi)\n+\t\t  {\n+\t\t    ready = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  if (ready)\n+\t    {\n+\t      vect_schedule_slp_node (vinfo, entry, instance);\n+\t      scc_info.get (entry)->on_stack = false;\n+\t      stack[idx] = NULL;\n+\t      todo--;\n+\t      if (phi)\n+\t\tphis_to_fixup.safe_push (entry);\n+\t    }\n+\t}\n+    }\n+  while (todo != 0);\n+\n+  /* Now fixup the backedge def of the vectorized PHIs in this SCC.  */\n+  slp_tree phi_node;\n+  FOR_EACH_VEC_ELT (phis_to_fixup, i, phi_node)\n+    {\n+      gphi *phi = as_a <gphi *> (SLP_TREE_REPRESENTATIVE (phi_node)->stmt);\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, gimple_bb (phi)->preds)\n+\t{\n+\t  unsigned dest_idx = e->dest_idx;\n+\t  child = SLP_TREE_CHILDREN (phi_node)[dest_idx];\n+\t  if (!child || SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+\t    continue;\n+\t  /* Simply fill all args.  */\n+\t  for (unsigned i = 0; i < SLP_TREE_VEC_STMTS (phi_node).length (); ++i)\n+\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]),\n+\t\t\t vect_get_slp_vect_def (child, i),\n+\t\t\t e, gimple_phi_arg_location (phi, dest_idx));\n+\t}\n+    }\n+\n+  /* Pop the SCC.  */\n+  stack.truncate (last_idx);\n+}\n+\n /* Generate vector code for SLP_INSTANCES in the loop/basic block.  */\n \n void\n@@ -5367,7 +5602,8 @@ vect_schedule_slp (vec_info *vinfo, vec<slp_instance> slp_instances)\n   slp_instance instance;\n   unsigned int i;\n \n-  hash_set<slp_tree> visited;\n+  hash_map<slp_tree, slp_scc_info> scc_info;\n+  int maxdfs = 0;\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       slp_tree node = SLP_INSTANCE_TREE (instance);\n@@ -5381,8 +5617,11 @@ vect_schedule_slp (vec_info *vinfo, vec<slp_instance> slp_instances)\n \t  vect_print_slp_graph (MSG_NOTE, vect_location,\n \t\t\t\tSLP_INSTANCE_TREE (instance));\n \t}\n-      /* Schedule the tree of INSTANCE.  */\n-      vect_schedule_slp_instance (vinfo, node, instance, visited);\n+      /* Schedule the tree of INSTANCE, scheduling SCCs in a way to\n+\t have a PHI be the node breaking the cycle.  */\n+      auto_vec<slp_tree> stack;\n+      if (!scc_info.get (node))\n+\tvect_schedule_scc (vinfo, node, instance, scc_info, maxdfs, stack);\n \n       if (SLP_INSTANCE_ROOT_STMT (instance))\n \tvectorize_slp_instance_root_stmt (node, instance);\n@@ -5398,25 +5637,6 @@ vect_schedule_slp (vec_info *vinfo, vec<slp_instance> slp_instances)\n       stmt_vec_info store_info;\n       unsigned int j;\n \n-      /* For reductions set the latch values of the vectorized PHIs.  */\n-      if (instance->reduc_phis\n-\t  && STMT_VINFO_REDUC_TYPE (SLP_TREE_REPRESENTATIVE\n-\t\t\t(instance->reduc_phis)) != FOLD_LEFT_REDUCTION\n-\t  && STMT_VINFO_REDUC_TYPE (SLP_TREE_REPRESENTATIVE\n-\t\t\t(instance->reduc_phis)) != EXTRACT_LAST_REDUCTION)\n-\t{\n-\t  slp_tree slp_node = root;\n-\t  slp_tree phi_node = instance->reduc_phis;\n-\t  gphi *phi = as_a <gphi *> (SLP_TREE_SCALAR_STMTS (phi_node)[0]->stmt);\n-\t  edge e = loop_latch_edge (gimple_bb (phi)->loop_father);\n-\t  gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n-\t\t      == SLP_TREE_VEC_STMTS (slp_node).length ());\n-\t  for (unsigned j = 0; j < SLP_TREE_VEC_STMTS (phi_node).length (); ++j)\n-\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[j]),\n-\t\t\t vect_get_slp_vect_def (slp_node, j),\n-\t\t\t e, gimple_phi_arg_location (phi, e->dest_idx));\n-\t}\n-\n       /* Remove scalar call stmts.  Do not do this for basic-block\n \t vectorization as not all uses may be vectorized.\n \t ???  Why should this be necessary?  DCE should be able to"}, {"sha": "7f0763f15c4a7cb63bb496d432368ab31122f1fb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -10745,7 +10745,8 @@ vect_analyze_stmt (vec_info *vinfo,\n \t      || vectorizable_condition (vinfo, stmt_info,\n \t\t\t\t\t NULL, NULL, node, cost_vec)\n \t      || vectorizable_comparison (vinfo, stmt_info, NULL, NULL, node,\n-\t\t\t\t\t  cost_vec));\n+\t\t\t\t\t  cost_vec)\n+\t      || vectorizable_phi (vinfo, stmt_info, NULL, node));\n     }\n \n   if (!ok)\n@@ -10885,6 +10886,11 @@ vect_transform_stmt (vec_info *vinfo,\n       gcc_assert (done);\n       break;\n \n+    case phi_info_type:\n+      done = vectorizable_phi (vinfo, stmt_info, &vec_stmt, slp_node);\n+      gcc_assert (done);\n+      break;\n+\n     default:\n       if (!STMT_VINFO_LIVE_P (stmt_info))\n \t{"}, {"sha": "b63dda31a0839b094985d306a993503cc00dd7eb", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -684,7 +684,8 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_SLP_VECT_ONLY (res) = false;\n   STMT_VINFO_VEC_STMTS (res) = vNULL;\n \n-  if (gimple_code (stmt) == GIMPLE_PHI\n+  if (is_a <loop_vec_info> (this)\n+      && gimple_code (stmt) == GIMPLE_PHI\n       && is_loop_header_bb_p (gimple_bb (stmt)))\n     STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;\n   else"}, {"sha": "13a02cd0d0cab06dd531c9e50b7c920ecf79b07d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a369d199bf2f34e037030b18d0da923e8a24997/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4a369d199bf2f34e037030b18d0da923e8a24997", "patch": "@@ -881,6 +881,7 @@ enum stmt_vec_info_type {\n   type_conversion_vec_info_type,\n   cycle_phi_info_type,\n   lc_phi_info_type,\n+  phi_info_type,\n   loop_exit_ctrl_vec_info_type\n };\n \n@@ -1939,6 +1940,7 @@ extern bool vect_transform_cycle_phi (loop_vec_info, stmt_vec_info,\n \t\t\t\t      slp_tree, slp_instance);\n extern bool vectorizable_lc_phi (loop_vec_info, stmt_vec_info,\n \t\t\t\t gimple **, slp_tree);\n+extern bool vectorizable_phi (vec_info *, stmt_vec_info, gimple **, slp_tree);\n extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *,"}]}