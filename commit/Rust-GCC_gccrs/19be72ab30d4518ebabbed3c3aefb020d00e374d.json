{"sha": "19be72ab30d4518ebabbed3c3aefb020d00e374d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTliZTcyYWIzMGQ0NTE4ZWJhYmJlZDNjM2FlZmIwMjBkMDBlMzc0ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-06-10T21:42:14Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-06-10T21:42:14Z"}, "message": "vector.md (GPR move splitter): Do not split moves of vectors in GPRS if they are direct moves or quad word...\n\n[gcc]\n2013-06-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Pat Haugen <pthaugen@us.ibm.com>\n\t    Peter Bergner <bergner@vnet.ibm.com>\n\n\t* config/rs6000/vector.md (GPR move splitter): Do not split moves\n\tof vectors in GPRS if they are direct moves or quad word load or\n\tstore moves.\n\n\t* config/rs6000/rs6000-protos.h (rs6000_output_move_128bit): Add\n\tdeclaration.\n\t(direct_move_p): Likewise.\n\t(quad_load_store_p): Likewise.\n\n\t* config/rs6000/rs6000.c (enum rs6000_reg_type): Simplify register\n\tclasses into bins based on the physical register type.\n\t(reg_class_to_reg_type): Likewise.\n\t(IS_STD_REG_TYPE): Likewise.\n\t(IS_FP_VECT_REG_TYPE): Likewise.\n\t(reload_fpr_gpr): Arrays to determine what insn to use if we can\n\tuse direct move instructions.\n\t(reload_gpr_vsx): Likewise.\n\t(reload_vsx_gpr): Likewise.\n\t(rs6000_init_hard_regno_mode_ok): Precalculate the register type\n\tinformation that is a simplification of register classes.  Also\n\tprecalculate direct move reload helpers.\n\t(direct_move_p): New function to return true if the operation can\n\tbe done as a direct move instruciton.\n\t(quad_load_store_p): New function to return true if the operation\n\tis a quad memory operation.\n\t(rs6000_legitimize_address): If quad memory, only allow register\n\tindirect for TImode addresses.\n\t(rs6000_legitimate_address_p): Likewise.\n\t(enum reload_reg_type): Delete, replace with rs6000_reg_type.\n\t(rs6000_reload_register_type): Likewise.\n\t(register_to_reg_type): Return register type.\n\t(rs6000_secondary_reload_simple_move): New helper function for\n\tsecondary reload and secondary memory needed to identify anything\n\tthat is a simple move, and does not need reloading.\n\t(rs6000_secondary_reload_direct_move): New helper function for\n\tsecondary reload to identify cases that can be done with several\n\tinstructions via the direct move instructions.\n\t(rs6000_secondary_reload_move): New helper function for secondary\n\treload to identify moves between register types that can be done.\n\t(rs6000_secondary_reload): Add support for quad memory operations\n\tand for direct move.\n\t(rs6000_secondary_memory_needed): Likewise.\n\t(rs6000_debug_secondary_memory_needed): Change argument names.\n\t(rs6000_output_move_128bit): New function to return the move to\n\tuse for 128-bit moves, including knowing about the various\n\tlimitations of quad memory operations.\n\n\t* config/rs6000/vsx.md (vsx_mov<mode>): Add support for quad\n\tmemory operations.  call rs6000_output_move_128bit for the actual\n\tinstruciton(s) to generate.\n\t(vsx_movti_64bit): Likewise.\n\n\t* config/rs6000/rs6000.md (UNSPEC_P8V_FMRGOW): New unspec values.\n\t(UNSPEC_P8V_MTVSRWZ): Likewise.\n\t(UNSPEC_P8V_RELOAD_FROM_GPR): Likewise.\n\t(UNSPEC_P8V_MTVSRD): Likewise.\n\t(UNSPEC_P8V_XXPERMDI): Likewise.\n\t(UNSPEC_P8V_RELOAD_FROM_VSX): Likewise.\n\t(UNSPEC_FUSION_GPR): Likewise.\n\t(FMOVE128_GPR): New iterator for direct move.\n\t(f32_lv): New mode attribute for load/store of SFmode/SDmode\n\tvalues.\n\t(f32_sv): Likewise.\n\t(f32_dm): Likewise.\n\t(zero_extend<mode>di2_internal1): Add support for power8 32-bit\n\tloads and direct move instructions.\n\t(zero_extendsidi2_lfiwzx): Likewise.\n\t(extendsidi2_lfiwax): Likewise.\n\t(extendsidi2_nocell): Likewise.\n\t(floatsi<mode>2_lfiwax): Likewise.\n\t(lfiwax): Likewise.\n\t(floatunssi<mode>2_lfiwzx): Likewise.\n\t(lfiwzx): Likewise.\n\t(fix_trunc<mode>_stfiwx): Likewise.\n\t(fixuns_trunc<mode>_stfiwx): Likewise.\n\t(mov<mode>_hardfloat, 32-bit floating point): Likewise.\n\t(mov<move>_hardfloat64, 64-bit floating point): Likewise.\n\t(parity<mode>2_cmpb): Set length/type attr.\n\t(unnamed shift right patterns, mov<mode>_internal2): Change type attr\n\tfor 'mr.' to fast_compare.\n\t(bpermd_<mode>): Change type attr to popcnt.\n\t(p8_fmrgow_<mode>): New insns for power8 direct move support.\n\t(p8_mtvsrwz_1): Likewise.\n\t(p8_mtvsrwz_2): Likewise.\n\t(reload_fpr_from_gpr<mode>): Likewise.\n\t(p8_mtvsrd_1): Likewise.\n\t(p8_mtvsrd_2): Likewise.\n\t(p8_xxpermdi_<mode>): Likewise.\n\t(reload_vsx_from_gpr<mode>): Likewise.\n\t(reload_vsx_from_gprsf): Likewise.\n\t(p8_mfvsrd_3_<mode>): LIkewise.\n\t(reload_gpr_from_vsx<mode>): Likewise.\n\t(reload_gpr_from_vsxsf): Likewise.\n\t(p8_mfvsrd_4_disf): Likewise.\n\t(multi-word GPR splits): Do not split direct moves or quad memory\n\toperations.\n\n[gcc/testsuite]\n2013-06-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Pat Haugen <pthaugen@us.ibm.com>\n\t    Peter Bergner <bergner@vnet.ibm.com>\n\n\t* gcc.target/powerpc/direct-move-vint1.c: New tests for power8\n\tdirect move instructions.\n\t* gcc.target/powerpc/direct-move-vint2.c: Likewise.\n\t* gcc.target/powerpc/direct-move.h: Likewise.\n\t* gcc.target/powerpc/direct-move-float1.c: Likewise.\n\t* gcc.target/powerpc/direct-move-float2.c: Likewise.\n\t* gcc.target/powerpc/direct-move-double1.c: Likewise.\n\t* gcc.target/powerpc/direct-move-double2.c: Likewise.\n\t* gcc.target/powerpc/direct-move-long1.c: Likewise.\n\t* gcc.target/powerpc/direct-move-long2.c: Likewise.\n\n\nCo-Authored-By: Pat Haugen <pthaugen@us.ibm.com>\nCo-Authored-By: Peter Bergner <bergner@vnet.ibm.com>\n\nFrom-SVN: r199918", "tree": {"sha": "13b6a456a0b24c6c9fe5357339f211def5e18338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13b6a456a0b24c6c9fe5357339f211def5e18338"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19be72ab30d4518ebabbed3c3aefb020d00e374d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19be72ab30d4518ebabbed3c3aefb020d00e374d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19be72ab30d4518ebabbed3c3aefb020d00e374d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19be72ab30d4518ebabbed3c3aefb020d00e374d/comments", "author": null, "committer": null, "parents": [{"sha": "16876bdcac75d7260d51b9226802cb1766c8bde0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16876bdcac75d7260d51b9226802cb1766c8bde0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16876bdcac75d7260d51b9226802cb1766c8bde0"}], "stats": {"total": 1631, "additions": 1424, "deletions": 207}, "files": [{"sha": "77bd5e6c2001ccb0b670d6b19ace083cb1f9e1bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -1,3 +1,104 @@\n+2013-06-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen <pthaugen@us.ibm.com>\n+\t    Peter Bergner <bergner@vnet.ibm.com>\n+\n+\t* config/rs6000/vector.md (GPR move splitter): Do not split moves\n+\tof vectors in GPRS if they are direct moves or quad word load or\n+\tstore moves.\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_output_move_128bit): Add\n+\tdeclaration.\n+\t(direct_move_p): Likewise.\n+\t(quad_load_store_p): Likewise.\n+\n+\t* config/rs6000/rs6000.c (enum rs6000_reg_type): Simplify register\n+\tclasses into bins based on the physical register type.\n+\t(reg_class_to_reg_type): Likewise.\n+\t(IS_STD_REG_TYPE): Likewise.\n+\t(IS_FP_VECT_REG_TYPE): Likewise.\n+\t(reload_fpr_gpr): Arrays to determine what insn to use if we can\n+\tuse direct move instructions.\n+\t(reload_gpr_vsx): Likewise.\n+\t(reload_vsx_gpr): Likewise.\n+\t(rs6000_init_hard_regno_mode_ok): Precalculate the register type\n+\tinformation that is a simplification of register classes.  Also\n+\tprecalculate direct move reload helpers.\n+\t(direct_move_p): New function to return true if the operation can\n+\tbe done as a direct move instruciton.\n+\t(quad_load_store_p): New function to return true if the operation\n+\tis a quad memory operation.\n+\t(rs6000_legitimize_address): If quad memory, only allow register\n+\tindirect for TImode addresses.\n+\t(rs6000_legitimate_address_p): Likewise.\n+\t(enum reload_reg_type): Delete, replace with rs6000_reg_type.\n+\t(rs6000_reload_register_type): Likewise.\n+\t(register_to_reg_type): Return register type.\n+\t(rs6000_secondary_reload_simple_move): New helper function for\n+\tsecondary reload and secondary memory needed to identify anything\n+\tthat is a simple move, and does not need reloading.\n+\t(rs6000_secondary_reload_direct_move): New helper function for\n+\tsecondary reload to identify cases that can be done with several\n+\tinstructions via the direct move instructions.\n+\t(rs6000_secondary_reload_move): New helper function for secondary\n+\treload to identify moves between register types that can be done.\n+\t(rs6000_secondary_reload): Add support for quad memory operations\n+\tand for direct move.\n+\t(rs6000_secondary_memory_needed): Likewise.\n+\t(rs6000_debug_secondary_memory_needed): Change argument names.\n+\t(rs6000_output_move_128bit): New function to return the move to\n+\tuse for 128-bit moves, including knowing about the various\n+\tlimitations of quad memory operations.\n+\n+\t* config/rs6000/vsx.md (vsx_mov<mode>): Add support for quad\n+\tmemory operations.  call rs6000_output_move_128bit for the actual\n+\tinstruciton(s) to generate.\n+\t(vsx_movti_64bit): Likewise.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_P8V_FMRGOW): New unspec values.\n+\t(UNSPEC_P8V_MTVSRWZ): Likewise.\n+\t(UNSPEC_P8V_RELOAD_FROM_GPR): Likewise.\n+\t(UNSPEC_P8V_MTVSRD): Likewise.\n+\t(UNSPEC_P8V_XXPERMDI): Likewise.\n+\t(UNSPEC_P8V_RELOAD_FROM_VSX): Likewise.\n+\t(UNSPEC_FUSION_GPR): Likewise.\n+\t(FMOVE128_GPR): New iterator for direct move.\n+\t(f32_lv): New mode attribute for load/store of SFmode/SDmode\n+\tvalues.\n+\t(f32_sv): Likewise.\n+\t(f32_dm): Likewise.\n+\t(zero_extend<mode>di2_internal1): Add support for power8 32-bit\n+\tloads and direct move instructions.\n+\t(zero_extendsidi2_lfiwzx): Likewise.\n+\t(extendsidi2_lfiwax): Likewise.\n+\t(extendsidi2_nocell): Likewise.\n+\t(floatsi<mode>2_lfiwax): Likewise.\n+\t(lfiwax): Likewise.\n+\t(floatunssi<mode>2_lfiwzx): Likewise.\n+\t(lfiwzx): Likewise.\n+\t(fix_trunc<mode>_stfiwx): Likewise.\n+\t(fixuns_trunc<mode>_stfiwx): Likewise.\n+\t(mov<mode>_hardfloat, 32-bit floating point): Likewise.\n+\t(mov<move>_hardfloat64, 64-bit floating point): Likewise.\n+\t(parity<mode>2_cmpb): Set length/type attr.\n+\t(unnamed shift right patterns, mov<mode>_internal2): Change type attr\n+\tfor 'mr.' to fast_compare.\n+\t(bpermd_<mode>): Change type attr to popcnt.\n+\t(p8_fmrgow_<mode>): New insns for power8 direct move support.\n+\t(p8_mtvsrwz_1): Likewise.\n+\t(p8_mtvsrwz_2): Likewise.\n+\t(reload_fpr_from_gpr<mode>): Likewise.\n+\t(p8_mtvsrd_1): Likewise.\n+\t(p8_mtvsrd_2): Likewise.\n+\t(p8_xxpermdi_<mode>): Likewise.\n+\t(reload_vsx_from_gpr<mode>): Likewise.\n+\t(reload_vsx_from_gprsf): Likewise.\n+\t(p8_mfvsrd_3_<mode>): LIkewise.\n+\t(reload_gpr_from_vsx<mode>): Likewise.\n+\t(reload_gpr_from_vsxsf): Likewise.\n+\t(p8_mfvsrd_4_disf): Likewise.\n+\t(multi-word GPR splits): Do not split direct moves or quad memory\n+\toperations.\n+\n 2013-06-10  David Malcolm  <dmalcolm@redhat.com>\n \n \t* tree-into-ssa.c (interesting_blocks): Make static."}, {"sha": "02836ecea6d9b81740150ee21ebbfa138738a5b9", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -50,6 +50,7 @@ extern rtx rs6000_got_register (rtx);\n extern rtx find_addr_reg (rtx);\n extern rtx gen_easy_altivec_constant (rtx);\n extern const char *output_vec_const_move (rtx *);\n+extern const char *rs6000_output_move_128bit (rtx *);\n extern void rs6000_expand_vector_init (rtx, rtx);\n extern void paired_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);\n@@ -70,6 +71,8 @@ extern int insvdi_rshift_rlwimi_p (rtx, rtx, rtx);\n extern int registers_ok_for_quad_peep (rtx, rtx);\n extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n+extern bool direct_move_p (rtx, rtx);\n+extern bool quad_load_store_p (rtx, rtx);\n extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n \t\t\t\t\t\t\t    enum reg_class);\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,"}, {"sha": "3646c6d9579bfbd7e86dc06b58dab666c3b371c2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 645, "deletions": 73, "changes": 718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -292,6 +292,39 @@ typedef rtx (*gen_2arg_fn_t) (rtx, rtx, rtx);\n    don't link in rs6000-c.c, so we can't call it directly.  */\n void (*rs6000_target_modify_macros_ptr) (bool, HOST_WIDE_INT, HOST_WIDE_INT);\n \n+/* Simplfy register classes into simpler classifications.  We assume\n+   GPR_REG_TYPE - FPR_REG_TYPE are ordered so that we can use a simple range\n+   check for standard register classes (gpr/floating/altivec/vsx) and\n+   floating/vector classes (float/altivec/vsx).  */\n+\n+enum rs6000_reg_type {\n+  NO_REG_TYPE,\n+  PSEUDO_REG_TYPE,\n+  GPR_REG_TYPE,\n+  VSX_REG_TYPE,\n+  ALTIVEC_REG_TYPE,\n+  FPR_REG_TYPE,\n+  SPR_REG_TYPE,\n+  CR_REG_TYPE,\n+  SPE_ACC_TYPE,\n+  SPEFSCR_REG_TYPE\n+};\n+\n+/* Map register class to register type.  */\n+static enum rs6000_reg_type reg_class_to_reg_type[N_REG_CLASSES];\n+\n+/* First/last register type for the 'normal' register types (i.e. general\n+   purpose, floating point, altivec, and VSX registers).  */\n+#define IS_STD_REG_TYPE(RTYPE) IN_RANGE(RTYPE, GPR_REG_TYPE, FPR_REG_TYPE)\n+\n+#define IS_FP_VECT_REG_TYPE(RTYPE) IN_RANGE(RTYPE, VSX_REG_TYPE, FPR_REG_TYPE)\n+\n+/* Direct moves to/from vsx/gpr registers that need an additional register to\n+   do the move.  */\n+static enum insn_code reload_fpr_gpr[NUM_MACHINE_MODES];\n+static enum insn_code reload_gpr_vsx[NUM_MACHINE_MODES];\n+static enum insn_code reload_vsx_gpr[NUM_MACHINE_MODES];\n+\n \f\n /* Target cpu costs.  */\n \n@@ -1042,6 +1075,13 @@ static void rs6000_print_isa_options (FILE *, int, const char *,\n static void rs6000_print_builtin_options (FILE *, int, const char *,\n \t\t\t\t\t  HOST_WIDE_INT);\n \n+static enum rs6000_reg_type register_to_reg_type (rtx, bool *);\n+static bool rs6000_secondary_reload_move (enum rs6000_reg_type,\n+\t\t\t\t\t  enum rs6000_reg_type,\n+\t\t\t\t\t  enum machine_mode,\n+\t\t\t\t\t  secondary_reload_info *,\n+\t\t\t\t\t  bool);\n+\n /* Hash table stuff for keeping track of TOC entries.  */\n \n struct GTY(()) toc_hash_struct\n@@ -1587,8 +1627,7 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \treturn ALTIVEC_REGNO_P (last_regno);\n     }\n \n-  /* Allow TImode in all VSX registers if the user asked for it.  Note, PTImode\n-     can only go in GPRs.  */\n+  /* Allow TImode in all VSX registers if the user asked for it.  */\n   if (mode == TImode && TARGET_VSX_TIMODE && VSX_REGNO_P (regno))\n     return 1;\n \n@@ -2154,6 +2193,36 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   rs6000_regno_regclass[ARG_POINTER_REGNUM] = BASE_REGS;\n   rs6000_regno_regclass[FRAME_POINTER_REGNUM] = BASE_REGS;\n \n+  /* Precalculate register class to simpler reload register class.  We don't\n+     need all of the register classes that are combinations of different\n+     classes, just the simple ones that have constraint letters.  */\n+  for (c = 0; c < N_REG_CLASSES; c++)\n+    reg_class_to_reg_type[c] = NO_REG_TYPE;\n+\n+  reg_class_to_reg_type[(int)GENERAL_REGS] = GPR_REG_TYPE;\n+  reg_class_to_reg_type[(int)BASE_REGS] = GPR_REG_TYPE;\n+  reg_class_to_reg_type[(int)VSX_REGS] = VSX_REG_TYPE;\n+  reg_class_to_reg_type[(int)VRSAVE_REGS] = SPR_REG_TYPE;\n+  reg_class_to_reg_type[(int)VSCR_REGS] = SPR_REG_TYPE;\n+  reg_class_to_reg_type[(int)LINK_REGS] = SPR_REG_TYPE;\n+  reg_class_to_reg_type[(int)CTR_REGS] = SPR_REG_TYPE;\n+  reg_class_to_reg_type[(int)LINK_OR_CTR_REGS] = SPR_REG_TYPE;\n+  reg_class_to_reg_type[(int)CR_REGS] = CR_REG_TYPE;\n+  reg_class_to_reg_type[(int)CR0_REGS] = CR_REG_TYPE;\n+  reg_class_to_reg_type[(int)SPE_ACC_REGS] = SPE_ACC_TYPE;\n+  reg_class_to_reg_type[(int)SPEFSCR_REGS] = SPEFSCR_REG_TYPE;\n+\n+  if (TARGET_VSX)\n+    {\n+      reg_class_to_reg_type[(int)FLOAT_REGS] = VSX_REG_TYPE;\n+      reg_class_to_reg_type[(int)ALTIVEC_REGS] = VSX_REG_TYPE;\n+    }\n+  else\n+    {\n+      reg_class_to_reg_type[(int)FLOAT_REGS] = FPR_REG_TYPE;\n+      reg_class_to_reg_type[(int)ALTIVEC_REGS] = ALTIVEC_REG_TYPE;\n+    }\n+\n   /* Precalculate vector information, this must be set up before the\n      rs6000_hard_regno_nregs_internal below.  */\n   for (m = 0; m < NUM_MACHINE_MODES; ++m)\n@@ -2305,7 +2374,15 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_LFIWZX)\n     rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;\n \n-  /* Set up the reload helper functions.  */\n+  /* Setup the direct move combinations.  */\n+  for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+    {\n+      reload_fpr_gpr[m] = CODE_FOR_nothing;\n+      reload_gpr_vsx[m] = CODE_FOR_nothing;\n+      reload_vsx_gpr[m] = CODE_FOR_nothing;\n+    }\n+\n+  /* Set up the reload helper and direct move functions.  */\n   if (TARGET_VSX || TARGET_ALTIVEC)\n     {\n       if (TARGET_64BIT)\n@@ -2329,11 +2406,47 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t      rs6000_vector_reload[DDmode][0]  = CODE_FOR_reload_dd_di_store;\n \t      rs6000_vector_reload[DDmode][1]  = CODE_FOR_reload_dd_di_load;\n \t    }\n+\t  if (TARGET_P8_VECTOR)\n+\t    {\n+\t      rs6000_vector_reload[SFmode][0]  = CODE_FOR_reload_sf_di_store;\n+\t      rs6000_vector_reload[SFmode][1]  = CODE_FOR_reload_sf_di_load;\n+\t      rs6000_vector_reload[SDmode][0]  = CODE_FOR_reload_sd_di_store;\n+\t      rs6000_vector_reload[SDmode][1]  = CODE_FOR_reload_sd_di_load;\n+\t    }\n \t  if (TARGET_VSX_TIMODE)\n \t    {\n \t      rs6000_vector_reload[TImode][0]  = CODE_FOR_reload_ti_di_store;\n \t      rs6000_vector_reload[TImode][1]  = CODE_FOR_reload_ti_di_load;\n \t    }\n+\t  if (TARGET_DIRECT_MOVE)\n+\t    {\n+\t      if (TARGET_POWERPC64)\n+\t\t{\n+\t\t  reload_gpr_vsx[TImode]    = CODE_FOR_reload_gpr_from_vsxti;\n+\t\t  reload_gpr_vsx[V2DFmode]  = CODE_FOR_reload_gpr_from_vsxv2df;\n+\t\t  reload_gpr_vsx[V2DImode]  = CODE_FOR_reload_gpr_from_vsxv2di;\n+\t\t  reload_gpr_vsx[V4SFmode]  = CODE_FOR_reload_gpr_from_vsxv4sf;\n+\t\t  reload_gpr_vsx[V4SImode]  = CODE_FOR_reload_gpr_from_vsxv4si;\n+\t\t  reload_gpr_vsx[V8HImode]  = CODE_FOR_reload_gpr_from_vsxv8hi;\n+\t\t  reload_gpr_vsx[V16QImode] = CODE_FOR_reload_gpr_from_vsxv16qi;\n+\t\t  reload_gpr_vsx[SFmode]    = CODE_FOR_reload_gpr_from_vsxsf;\n+\n+\t\t  reload_vsx_gpr[TImode]    = CODE_FOR_reload_vsx_from_gprti;\n+\t\t  reload_vsx_gpr[V2DFmode]  = CODE_FOR_reload_vsx_from_gprv2df;\n+\t\t  reload_vsx_gpr[V2DImode]  = CODE_FOR_reload_vsx_from_gprv2di;\n+\t\t  reload_vsx_gpr[V4SFmode]  = CODE_FOR_reload_vsx_from_gprv4sf;\n+\t\t  reload_vsx_gpr[V4SImode]  = CODE_FOR_reload_vsx_from_gprv4si;\n+\t\t  reload_vsx_gpr[V8HImode]  = CODE_FOR_reload_vsx_from_gprv8hi;\n+\t\t  reload_vsx_gpr[V16QImode] = CODE_FOR_reload_vsx_from_gprv16qi;\n+\t\t  reload_vsx_gpr[SFmode]    = CODE_FOR_reload_vsx_from_gprsf;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  reload_fpr_gpr[DImode] = CODE_FOR_reload_fpr_from_gprdi;\n+\t\t  reload_fpr_gpr[DDmode] = CODE_FOR_reload_fpr_from_gprdd;\n+\t\t  reload_fpr_gpr[DFmode] = CODE_FOR_reload_fpr_from_gprdf;\n+\t\t}\n+\t    }\n \t}\n       else\n \t{\n@@ -2356,6 +2469,13 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t      rs6000_vector_reload[DDmode][0]  = CODE_FOR_reload_dd_si_store;\n \t      rs6000_vector_reload[DDmode][1]  = CODE_FOR_reload_dd_si_load;\n \t    }\n+\t  if (TARGET_P8_VECTOR)\n+\t    {\n+\t      rs6000_vector_reload[SFmode][0]  = CODE_FOR_reload_sf_si_store;\n+\t      rs6000_vector_reload[SFmode][1]  = CODE_FOR_reload_sf_si_load;\n+\t      rs6000_vector_reload[SDmode][0]  = CODE_FOR_reload_sd_si_store;\n+\t      rs6000_vector_reload[SDmode][1]  = CODE_FOR_reload_sd_si_load;\n+\t    }\n \t  if (TARGET_VSX_TIMODE)\n \t    {\n \t      rs6000_vector_reload[TImode][0]  = CODE_FOR_reload_ti_si_store;\n@@ -5385,6 +5505,72 @@ gpr_or_gpr_p (rtx op0, rtx op1)\n \t  || (REG_P (op1) && INT_REGNO_P (REGNO (op1))));\n }\n \n+/* Return true if this is a move direct operation between GPR registers and\n+   floating point/VSX registers.  */\n+\n+bool\n+direct_move_p (rtx op0, rtx op1)\n+{\n+  int regno0, regno1;\n+\n+  if (!REG_P (op0) || !REG_P (op1))\n+    return false;\n+\n+  if (!TARGET_DIRECT_MOVE && !TARGET_MFPGPR)\n+    return false;\n+\n+  regno0 = REGNO (op0);\n+  regno1 = REGNO (op1);\n+  if (regno0 >= FIRST_PSEUDO_REGISTER || regno1 >= FIRST_PSEUDO_REGISTER)\n+    return false;\n+\n+  if (INT_REGNO_P (regno0))\n+    return (TARGET_DIRECT_MOVE) ? VSX_REGNO_P (regno1) : FP_REGNO_P (regno1);\n+\n+  else if (INT_REGNO_P (regno1))\n+    {\n+      if (TARGET_MFPGPR && FP_REGNO_P (regno0))\n+\treturn true;\n+\n+      else if (TARGET_DIRECT_MOVE && VSX_REGNO_P (regno0))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if this is a load or store quad operation.  */\n+\n+bool\n+quad_load_store_p (rtx op0, rtx op1)\n+{\n+  bool ret;\n+\n+  if (!TARGET_QUAD_MEMORY)\n+    ret = false;\n+\n+  else if (REG_P (op0) && MEM_P (op1))\n+    ret = (quad_int_reg_operand (op0, GET_MODE (op0))\n+\t   && quad_memory_operand (op1, GET_MODE (op1))\n+\t   && !reg_overlap_mentioned_p (op0, op1));\n+\n+  else if (MEM_P (op0) && REG_P (op1))\n+    ret = (quad_memory_operand (op0, GET_MODE (op0))\n+\t   && quad_int_reg_operand (op1, GET_MODE (op1)));\n+\n+  else\n+    ret = false;\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr, \"\\n========== quad_load_store, return %s\\n\",\n+\t       ret ? \"true\" : \"false\");\n+      debug_rtx (gen_rtx_SET (VOIDmode, op0, op1));\n+    }\n+\n+  return ret;\n+}\n+\n /* Given an address, return a constant offset term if one exists.  */\n \n static rtx\n@@ -5903,8 +6089,11 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       if (GET_CODE (x) == PLUS && XEXP (x, 1) == const0_rtx)\n \treturn force_reg (Pmode, XEXP (x, 0));\n \n+      /* For TImode with load/store quad, restrict addresses to just a single\n+\t pointer, so it works with both GPRs and VSX registers.  */\n       /* Make sure both operands are registers.  */\n-      else if (GET_CODE (x) == PLUS)\n+      else if (GET_CODE (x) == PLUS\n+\t       && (mode != TImode || !TARGET_QUAD_MEMORY))\n \treturn gen_rtx_PLUS (Pmode,\n \t\t\t     force_reg (Pmode, XEXP (x, 0)),\n \t\t\t     force_reg (Pmode, XEXP (x, 1)));\n@@ -6858,6 +7047,13 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n   if (reg_offset_p\n       && legitimate_constant_pool_address_p (x, mode, reg_ok_strict))\n     return 1;\n+  /* For TImode, if we have load/store quad, only allow register indirect\n+     addresses.  This will allow the values to go in either GPRs or VSX\n+     registers without reloading.  The vector types would tend to go into VSX\n+     registers, so we allow REG+REG, while TImode seems somewhat split, in that\n+     some uses are GPR based, and some VSX based.  */\n+  if (mode == TImode && TARGET_QUAD_MEMORY)\n+    return 0;\n   /* If not REG_OK_STRICT (before reload) let pass any stack offset.  */\n   if (! reg_ok_strict\n       && reg_offset_p\n@@ -14001,29 +14197,226 @@ rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n-enum reload_reg_type {\n-  GPR_REGISTER_TYPE,\n-  VECTOR_REGISTER_TYPE,\n-  OTHER_REGISTER_TYPE\n-};\n+/* Classify a register type.  Because the FMRGOW/FMRGEW instructions only work\n+   on traditional floating point registers, and the VMRGOW/VMRGEW instructions\n+   only work on the traditional altivec registers, note if an altivec register\n+   was choosen.  */\n \n-static enum reload_reg_type\n-rs6000_reload_register_type (enum reg_class rclass)\n+static enum rs6000_reg_type\n+register_to_reg_type (rtx reg, bool *is_altivec)\n {\n-  switch (rclass)\n+  HOST_WIDE_INT regno;\n+  enum reg_class rclass;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (!REG_P (reg))\n+    return NO_REG_TYPE;\n+\n+  regno = REGNO (reg);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n-    case GENERAL_REGS:\n-    case BASE_REGS:\n-      return GPR_REGISTER_TYPE;\n+      if (!lra_in_progress && !reload_in_progress && !reload_completed)\n+\treturn PSEUDO_REG_TYPE;\n \n-    case FLOAT_REGS:\n-    case ALTIVEC_REGS:\n-    case VSX_REGS:\n-      return VECTOR_REGISTER_TYPE;\n+      regno = true_regnum (reg);\n+      if (regno < 0 || regno >= FIRST_PSEUDO_REGISTER)\n+\treturn PSEUDO_REG_TYPE;\n+    }\t\n \n-    default:\n-      return OTHER_REGISTER_TYPE;\n+  gcc_assert (regno >= 0);\n+\n+  if (is_altivec && ALTIVEC_REGNO_P (regno))\n+    *is_altivec = true;\n+\n+  rclass = rs6000_regno_regclass[regno];\n+  return reg_class_to_reg_type[(int)rclass];\n+}\n+\n+/* Helper function for rs6000_secondary_reload to return true if a move to a\n+   different register classe is really a simple move.  */\n+\n+static bool\n+rs6000_secondary_reload_simple_move (enum rs6000_reg_type to_type,\n+\t\t\t\t     enum rs6000_reg_type from_type,\n+\t\t\t\t     enum machine_mode mode)\n+{\n+  int size;\n+\n+  /* Add support for various direct moves available.  In this function, we only\n+     look at cases where we don't need any extra registers, and one or more\n+     simple move insns are issued.  At present, 32-bit integers are not allowed\n+     in FPR/VSX registers.  Single precision binary floating is not a simple\n+     move because we need to convert to the single precision memory layout.\n+     The 4-byte SDmode can be moved.  */\n+  size = GET_MODE_SIZE (mode);\n+  if (TARGET_DIRECT_MOVE\n+      && ((mode == SDmode) || (TARGET_POWERPC64 && size == 8))\n+      && ((to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n+\t  || (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)))\n+    return true;\n+\n+  else if (TARGET_MFPGPR && TARGET_POWERPC64 && size == 8\n+\t   && ((to_type == GPR_REG_TYPE && from_type == FPR_REG_TYPE)\n+\t       || (to_type == FPR_REG_TYPE && from_type == GPR_REG_TYPE)))\n+    return true;\n+\n+  else if ((size == 4 || (TARGET_POWERPC64 && size == 8))\n+\t   && ((to_type == GPR_REG_TYPE && from_type == SPR_REG_TYPE)\n+\t       || (to_type == SPR_REG_TYPE && from_type == GPR_REG_TYPE)))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Power8 helper function for rs6000_secondary_reload, handle all of the\n+   special direct moves that involve allocating an extra register, return the\n+   insn code of the helper function if there is such a function or\n+   CODE_FOR_nothing if not.  */\n+\n+static bool\n+rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n+\t\t\t\t     enum rs6000_reg_type from_type,\n+\t\t\t\t     enum machine_mode mode,\n+\t\t\t\t     secondary_reload_info *sri,\n+\t\t\t\t     bool altivec_p)\n+{\n+  bool ret = false;\n+  enum insn_code icode = CODE_FOR_nothing;\n+  int cost = 0;\n+  int size = GET_MODE_SIZE (mode);\n+\n+  if (TARGET_POWERPC64)\n+    {\n+      if (size == 16)\n+\t{\n+\t  /* Handle moving 128-bit values from GPRs to VSX point registers on\n+\t     power8 when running in 64-bit mode using XXPERMDI to glue the two\n+\t     64-bit values back together.  */\n+\t  if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n+\t    {\n+\t      cost = 3;\t\t\t/* 2 mtvsrd's, 1 xxpermdi.  */\n+\t      icode = reload_vsx_gpr[(int)mode];\n+\t    }\n+\n+\t  /* Handle moving 128-bit values from VSX point registers to GPRs on\n+\t     power8 when running in 64-bit mode using XXPERMDI to get access to the\n+\t     bottom 64-bit value.  */\n+\t  else if (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n+\t    {\n+\t      cost = 3;\t\t\t/* 2 mfvsrd's, 1 xxpermdi.  */\n+\t      icode = reload_gpr_vsx[(int)mode];\n+\t    }\n+\t}\n+\n+      else if (mode == SFmode)\n+\t{\n+\t  if (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n+\t    {\n+\t      cost = 3;\t\t\t/* xscvdpspn, mfvsrd, and.  */\n+\t      icode = reload_gpr_vsx[(int)mode];\n+\t    }\n+\n+\t  else if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n+\t    {\n+\t      cost = 2;\t\t\t/* mtvsrz, xscvspdpn.  */\n+\t      icode = reload_vsx_gpr[(int)mode];\n+\t    }\n+\t}\n+    }\n+\n+  if (TARGET_POWERPC64 && size == 16)\n+    {\n+      /* Handle moving 128-bit values from GPRs to VSX point registers on\n+\t power8 when running in 64-bit mode using XXPERMDI to glue the two\n+\t 64-bit values back together.  */\n+      if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n+\t{\n+\t  cost = 3;\t\t\t/* 2 mtvsrd's, 1 xxpermdi.  */\n+\t  icode = reload_vsx_gpr[(int)mode];\n+\t}\n+\n+      /* Handle moving 128-bit values from VSX point registers to GPRs on\n+\t power8 when running in 64-bit mode using XXPERMDI to get access to the\n+\t bottom 64-bit value.  */\n+      else if (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n+\t{\n+\t  cost = 3;\t\t\t/* 2 mfvsrd's, 1 xxpermdi.  */\n+\t  icode = reload_gpr_vsx[(int)mode];\n+\t}\n+    }\n+\n+  else if (!TARGET_POWERPC64 && size == 8)\n+    {\n+      /* Handle moving 64-bit values from GPRs to floating point registers on\n+\t power8 when running in 32-bit mode using FMRGOW to glue the two 32-bit\n+\t values back together.  Altivec register classes must be handled\n+\t specially since a different instruction is used, and the secondary\n+\t reload support requires a single instruction class in the scratch\n+\t register constraint.  However, right now TFmode is not allowed in\n+\t Altivec registers, so the pattern will never match.  */\n+      if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE && !altivec_p)\n+\t{\n+\t  cost = 3;\t\t\t/* 2 mtvsrwz's, 1 fmrgow.  */\n+\t  icode = reload_fpr_gpr[(int)mode];\n+\t}\n     }\n+\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      ret = true;\n+      if (sri)\n+\t{\n+\t  sri->icode = icode;\n+\t  sri->extra_cost = cost;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+/* Return whether a move between two register classes can be done either\n+   directly (simple move) or via a pattern that uses a single extra temporary\n+   (using power8's direct move in this case.  */\n+\n+static bool\n+rs6000_secondary_reload_move (enum rs6000_reg_type to_type,\n+\t\t\t      enum rs6000_reg_type from_type,\n+\t\t\t      enum machine_mode mode,\n+\t\t\t      secondary_reload_info *sri,\n+\t\t\t      bool altivec_p)\n+{\n+  /* Fall back to load/store reloads if either type is not a register.  */\n+  if (to_type == NO_REG_TYPE || from_type == NO_REG_TYPE)\n+    return false;\n+\n+  /* If we haven't allocated registers yet, assume the move can be done for the\n+     standard register types.  */\n+  if ((to_type == PSEUDO_REG_TYPE && from_type == PSEUDO_REG_TYPE)\n+      || (to_type == PSEUDO_REG_TYPE && IS_STD_REG_TYPE (from_type))\n+      || (from_type == PSEUDO_REG_TYPE && IS_STD_REG_TYPE (to_type)))\n+    return true;\n+\n+  /* Moves to the same set of registers is a simple move for non-specialized\n+     registers.  */\n+  if (to_type == from_type && IS_STD_REG_TYPE (to_type))\n+    return true;\n+\n+  /* Check whether a simple move can be done directly.  */\n+  if (rs6000_secondary_reload_simple_move (to_type, from_type, mode))\n+    {\n+      if (sri)\n+\t{\n+\t  sri->icode = CODE_FOR_nothing;\n+\t  sri->extra_cost = 0;\n+\t}\n+      return true;\n+    }\n+\n+  /* Now check if we can do it in a few steps.  */\n+  return rs6000_secondary_reload_direct_move (to_type, from_type, mode, sri,\n+\t\t\t\t\t      altivec_p);\n }\n \n /* Inform reload about cases where moving X with a mode MODE to a register in\n@@ -14049,11 +14442,32 @@ rs6000_secondary_reload (bool in_p,\n   bool default_p = false;\n \n   sri->icode = CODE_FOR_nothing;\n-\n-  /* Convert vector loads and stores into gprs to use an additional base\n-     register.  */\n   icode = rs6000_vector_reload[mode][in_p != false];\n-  if (icode != CODE_FOR_nothing)\n+\n+  if (REG_P (x) || register_operand (x, mode))\n+    {\n+      enum rs6000_reg_type to_type = reg_class_to_reg_type[(int)rclass];\n+      bool altivec_p = (rclass == ALTIVEC_REGS);\n+      enum rs6000_reg_type from_type = register_to_reg_type (x, &altivec_p);\n+\n+      if (!in_p)\n+\t{\n+\t  enum rs6000_reg_type exchange = to_type;\n+\t  to_type = from_type;\n+\t  from_type = exchange;\n+\t}\n+\n+      if (rs6000_secondary_reload_move (to_type, from_type, mode, sri,\n+\t\t\t\t\taltivec_p))\n+\t{\n+\t  icode = (enum insn_code)sri->icode;\n+\t  default_p = false;\n+\t  ret = NO_REGS;\n+\t}\n+    }\n+\n+  /* Handle vector moves with reload helper functions.  */\n+  if (ret == ALL_REGS && icode != CODE_FOR_nothing)\n     {\n       ret = NO_REGS;\n       sri->icode = CODE_FOR_nothing;\n@@ -14065,12 +14479,21 @@ rs6000_secondary_reload (bool in_p,\n \n \t  /* Loads to and stores from gprs can do reg+offset, and wouldn't need\n \t     an extra register in that case, but it would need an extra\n-\t     register if the addressing is reg+reg or (reg+reg)&(-16).  */\n+\t     register if the addressing is reg+reg or (reg+reg)&(-16).  Special\n+\t     case load/store quad.  */\n \t  if (rclass == GENERAL_REGS || rclass == BASE_REGS)\n \t    {\n-\t      if (!legitimate_indirect_address_p (addr, false)\n-\t\t  && !rs6000_legitimate_offset_address_p (PTImode, addr,\n-\t\t\t\t\t\t\t  false, true))\n+\t      if (TARGET_POWERPC64 && TARGET_QUAD_MEMORY\n+\t\t  && GET_MODE_SIZE (mode) == 16\n+\t\t  && quad_memory_operand (x, mode))\n+\t\t{\n+\t\t  sri->icode = icode;\n+\t\t  sri->extra_cost = 2;\n+\t\t}\n+\n+\t      else if (!legitimate_indirect_address_p (addr, false)\n+\t\t       && !rs6000_legitimate_offset_address_p (PTImode, addr,\n+\t\t\t\t\t\t\t       false, true))\n \t\t{\n \t\t  sri->icode = icode;\n \t\t  /* account for splitting the loads, and converting the\n@@ -14084,7 +14507,7 @@ rs6000_secondary_reload (bool in_p,\n          else if ((rclass == FLOAT_REGS || rclass == NO_REGS)\n                   && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n                   && (legitimate_indirect_address_p (addr, false)\n-                      || legitimate_indirect_address_p (XEXP (addr, 0), false)\n+                      || legitimate_indirect_address_p (addr, false)\n                       || rs6000_legitimate_offset_address_p (mode, addr,\n                                                              false, true)))\n \n@@ -14136,12 +14559,12 @@ rs6000_secondary_reload (bool in_p,\n \t  else\n \t    {\n \t      enum reg_class xclass = REGNO_REG_CLASS (regno);\n-\t      enum reload_reg_type rtype1 = rs6000_reload_register_type (rclass);\n-\t      enum reload_reg_type rtype2 = rs6000_reload_register_type (xclass);\n+\t      enum rs6000_reg_type rtype1 = reg_class_to_reg_type[(int)rclass];\n+\t      enum rs6000_reg_type rtype2 = reg_class_to_reg_type[(int)xclass];\n \n \t      /* If memory is needed, use default_secondary_reload to create the\n \t\t stack slot.  */\n-\t      if (rtype1 != rtype2 || rtype1 == OTHER_REGISTER_TYPE)\n+\t      if (rtype1 != rtype2 || !IS_STD_REG_TYPE (rtype1))\n \t\tdefault_p = true;\n \t      else\n \t\tret = NO_REGS;\n@@ -14151,7 +14574,7 @@ rs6000_secondary_reload (bool in_p,\n \tdefault_p = true;\n     }\n   else if (TARGET_POWERPC64\n-\t   && rs6000_reload_register_type (rclass) == GPR_REGISTER_TYPE\n+\t   && reg_class_to_reg_type[(int)rclass] == GPR_REG_TYPE\n \t   && MEM_P (x)\n \t   && GET_MODE_SIZE (GET_MODE (x)) >= UNITS_PER_WORD)\n     {\n@@ -14190,7 +14613,7 @@ rs6000_secondary_reload (bool in_p,\n \tdefault_p = true;\n     }\n   else if (!TARGET_POWERPC64\n-\t   && rs6000_reload_register_type (rclass) == GPR_REGISTER_TYPE\n+\t   && reg_class_to_reg_type[(int)rclass] == GPR_REG_TYPE\n \t   && MEM_P (x)\n \t   && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n     {\n@@ -14753,60 +15176,45 @@ rs6000_debug_preferred_reload_class (rtx x, enum reg_class rclass)\n    set and vice versa.  */\n \n static bool\n-rs6000_secondary_memory_needed (enum reg_class class1,\n-\t\t\t\tenum reg_class class2,\n+rs6000_secondary_memory_needed (enum reg_class from_class,\n+\t\t\t\tenum reg_class to_class,\n \t\t\t\tenum machine_mode mode)\n {\n-  if (class1 == class2)\n-    return false;\n-\n-  /* Under VSX, there are 3 register classes that values could be in (VSX_REGS,\n-     ALTIVEC_REGS, and FLOAT_REGS).  We don't need to use memory to copy\n-     between these classes.  But we need memory for other things that can go in\n-     FLOAT_REGS like SFmode.  */\n-  if (TARGET_VSX\n-      && (VECTOR_MEM_VSX_P (mode) || VECTOR_UNIT_VSX_P (mode))\n-      && (class1 == VSX_REGS || class1 == ALTIVEC_REGS\n-\t  || class1 == FLOAT_REGS))\n-    return (class2 != VSX_REGS && class2 != ALTIVEC_REGS\n-\t    && class2 != FLOAT_REGS);\n-\n-  if (class1 == VSX_REGS || class2 == VSX_REGS)\n-    return true;\n+  enum rs6000_reg_type from_type, to_type;\n+  bool altivec_p = ((from_class == ALTIVEC_REGS)\n+\t\t    || (to_class == ALTIVEC_REGS));\n \n-  if (class1 == FLOAT_REGS\n-      && (!TARGET_MFPGPR || !TARGET_POWERPC64\n-\t  || ((mode != DFmode)\n-\t      && (mode != DDmode)\n-\t      && (mode != DImode))))\n-    return true;\n+  /* If a simple/direct move is available, we don't need secondary memory  */\n+  from_type = reg_class_to_reg_type[(int)from_class];\n+  to_type = reg_class_to_reg_type[(int)to_class];\n \n-  if (class2 == FLOAT_REGS\n-      && (!TARGET_MFPGPR || !TARGET_POWERPC64\n-\t  || ((mode != DFmode)\n-\t      && (mode != DDmode)\n-\t      && (mode != DImode))))\n-    return true;\n+  if (rs6000_secondary_reload_move (to_type, from_type, mode,\n+\t\t\t\t    (secondary_reload_info *)0, altivec_p))\n+    return false;\n \n-  if (class1 == ALTIVEC_REGS || class2 == ALTIVEC_REGS)\n+  /* If we have a floating point or vector register class, we need to use\n+     memory to transfer the data.  */\n+  if (IS_FP_VECT_REG_TYPE (from_type) || IS_FP_VECT_REG_TYPE (to_type))\n     return true;\n \n   return false;\n }\n \n /* Debug version of rs6000_secondary_memory_needed.  */\n static bool\n-rs6000_debug_secondary_memory_needed (enum reg_class class1,\n-\t\t\t\t      enum reg_class class2,\n+rs6000_debug_secondary_memory_needed (enum reg_class from_class,\n+\t\t\t\t      enum reg_class to_class,\n \t\t\t\t      enum machine_mode mode)\n {\n-  bool ret = rs6000_secondary_memory_needed (class1, class2, mode);\n+  bool ret = rs6000_secondary_memory_needed (from_class, to_class, mode);\n \n   fprintf (stderr,\n-\t   \"rs6000_secondary_memory_needed, return: %s, class1 = %s, \"\n-\t   \"class2 = %s, mode = %s\\n\",\n-\t   ret ? \"true\" : \"false\", reg_class_names[class1],\n-\t   reg_class_names[class2], GET_MODE_NAME (mode));\n+\t   \"rs6000_secondary_memory_needed, return: %s, from_class = %s, \"\n+\t   \"to_class = %s, mode = %s\\n\",\n+\t   ret ? \"true\" : \"false\",\n+\t   reg_class_names[from_class],\n+\t   reg_class_names[to_class],\n+\t   GET_MODE_NAME (mode));\n \n   return ret;\n }\n@@ -15011,6 +15419,170 @@ rs6000_debug_cannot_change_mode_class (enum machine_mode from,\n \n   return ret;\n }\n+\f\n+/* Return a string to do a move operation of 128 bits of data.  */\n+\n+const char *\n+rs6000_output_move_128bit (rtx operands[])\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  enum machine_mode mode = GET_MODE (dest);\n+  int dest_regno;\n+  int src_regno;\n+  bool dest_gpr_p, dest_fp_p, dest_av_p, dest_vsx_p;\n+  bool src_gpr_p, src_fp_p, src_av_p, src_vsx_p;\n+\n+  if (REG_P (dest))\n+    {\n+      dest_regno = REGNO (dest);\n+      dest_gpr_p = INT_REGNO_P (dest_regno);\n+      dest_fp_p = FP_REGNO_P (dest_regno);\n+      dest_av_p = ALTIVEC_REGNO_P (dest_regno);\n+      dest_vsx_p = dest_fp_p | dest_av_p;\n+    }\n+  else\n+    {\n+      dest_regno = -1;\n+      dest_gpr_p = dest_fp_p = dest_av_p = dest_vsx_p = false;\n+    }\n+\n+  if (REG_P (src))\n+    {\n+      src_regno = REGNO (src);\n+      src_gpr_p = INT_REGNO_P (src_regno);\n+      src_fp_p = FP_REGNO_P (src_regno);\n+      src_av_p = ALTIVEC_REGNO_P (src_regno);\n+      src_vsx_p = src_fp_p | src_av_p;\n+    }\n+  else\n+    {\n+      src_regno = -1;\n+      src_gpr_p = src_fp_p = src_av_p = src_vsx_p = false;\n+    }\n+\n+  /* Register moves.  */\n+  if (dest_regno >= 0 && src_regno >= 0)\n+    {\n+      if (dest_gpr_p)\n+\t{\n+\t  if (src_gpr_p)\n+\t    return \"#\";\n+\n+\t  else if (TARGET_VSX && TARGET_DIRECT_MOVE && src_vsx_p)\n+\t    return \"#\";\n+\t}\n+\n+      else if (TARGET_VSX && dest_vsx_p)\n+\t{\n+\t  if (src_vsx_p)\n+\t    return \"xxlor %x0,%x1,%x1\";\n+\n+\t  else if (TARGET_DIRECT_MOVE && src_gpr_p)\n+\t    return \"#\";\n+\t}\n+\n+      else if (TARGET_ALTIVEC && dest_av_p && src_av_p)\n+\treturn \"vor %0,%1,%1\";\n+\n+      else if (dest_fp_p && src_fp_p)\n+\treturn \"#\";\n+    }\n+\n+  /* Loads.  */\n+  else if (dest_regno >= 0 && MEM_P (src))\n+    {\n+      if (dest_gpr_p)\n+\t{\n+\t  if (TARGET_QUAD_MEMORY && (dest_regno & 1) == 0\n+\t      && quad_memory_operand (src, mode)\n+\t      && !reg_overlap_mentioned_p (dest, src))\n+\t    {\n+\t      /* lq/stq only has DQ-form, so avoid X-form that %y produces.  */\n+\t      return REG_P (XEXP (src, 0)) ? \"lq %0,%1\" : \"lq %0,%y1\";\n+\t    }\n+\t  else\n+\t    return \"#\";\n+\t}\n+\n+      else if (TARGET_ALTIVEC && dest_av_p\n+\t       && altivec_indexed_or_indirect_operand (src, mode))\n+\treturn \"lvx %0,%y1\";\n+\n+      else if (TARGET_VSX && dest_vsx_p)\n+\t{\n+\t  if (mode == V16QImode || mode == V8HImode || mode == V4SImode)\n+\t    return \"lxvw4x %x0,%y1\";\n+\t  else\n+\t    return \"lxvd2x %x0,%y1\";\n+\t}\n+\n+      else if (TARGET_ALTIVEC && dest_av_p)\n+\treturn \"lvx %0,%y1\";\n+\n+      else if (dest_fp_p)\n+\treturn \"#\";\n+    }\n+\n+  /* Stores.  */\n+  else if (src_regno >= 0 && MEM_P (dest))\n+    {\n+      if (src_gpr_p)\n+\t{\n+\t  if (TARGET_QUAD_MEMORY && (src_regno & 1) == 0\n+\t      && quad_memory_operand (dest, mode))\n+\t    {\n+\t      /* lq/stq only has DQ-form, so avoid X-form that %y produces.  */\n+\t      return REG_P (XEXP (dest, 0)) ? \"stq %1,%0\" : \"stq %1,%y0\";\n+\t    }\n+\t  else\n+\t    return \"#\";\n+\t}\n+\n+      else if (TARGET_ALTIVEC && src_av_p\n+\t       && altivec_indexed_or_indirect_operand (src, mode))\n+\treturn \"stvx %1,%y0\";\n+\n+      else if (TARGET_VSX && src_vsx_p)\n+\t{\n+\t  if (mode == V16QImode || mode == V8HImode || mode == V4SImode)\n+\t    return \"stxvw4x %x1,%y0\";\n+\t  else\n+\t    return \"stxvd2x %x1,%y0\";\n+\t}\n+\n+      else if (TARGET_ALTIVEC && src_av_p)\n+\treturn \"stvx %1,%y0\";\n+\n+      else if (src_fp_p)\n+\treturn \"#\";\n+    }\n+\n+  /* Constants.  */\n+  else if (dest_regno >= 0\n+\t   && (GET_CODE (src) == CONST_INT\n+\t       || GET_CODE (src) == CONST_DOUBLE\n+\t       || GET_CODE (src) == CONST_VECTOR))\n+    {\n+      if (dest_gpr_p)\n+\treturn \"#\";\n+\n+      else if (TARGET_VSX && dest_vsx_p && zero_constant (src, mode))\n+\treturn \"xxlxor %x0,%x0,%x0\";\n+\n+      else if (TARGET_ALTIVEC && dest_av_p)\n+\treturn output_vec_const_move (operands);\n+    }\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr, \"\\n===== Bad 128 bit move:\\n\");\n+      debug_rtx (gen_rtx_SET (VOIDmode, dest, src));\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n \f\n /* Given a comparison operation, return the bit number in CCR to test.  We\n    know this is a valid comparison."}, {"sha": "93aa0390311df60ce8b0f689b3ab6cfdaa040652", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 350, "deletions": 42, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -127,6 +127,13 @@\n    UNSPEC_LFIWZX\n    UNSPEC_FCTIWUZ\n    UNSPEC_GRP_END_NOP\n+   UNSPEC_P8V_FMRGOW\n+   UNSPEC_P8V_MTVSRWZ\n+   UNSPEC_P8V_RELOAD_FROM_GPR\n+   UNSPEC_P8V_MTVSRD\n+   UNSPEC_P8V_XXPERMDI\n+   UNSPEC_P8V_RELOAD_FROM_VSX\n+   UNSPEC_FUSION_GPR\n   ])\n \n ;;\n@@ -273,6 +280,15 @@\n (define_mode_iterator FMOVE128 [(TF \"!TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\")\n \t\t\t\t(TD \"TARGET_HARD_FLOAT && TARGET_FPRS\")])\n \n+; Iterators for 128 bit types for direct move\n+(define_mode_iterator FMOVE128_GPR [(TI    \"TARGET_VSX_TIMODE\")\n+\t\t\t\t    (V16QI \"\")\n+\t\t\t\t    (V8HI  \"\")\n+\t\t\t\t    (V4SI  \"\")\n+\t\t\t\t    (V4SF  \"\")\n+\t\t\t\t    (V2DI  \"\")\n+\t\t\t\t    (V2DF  \"\")])\n+\n ; Whether a floating point move is ok, don't allow SD without hardware FP\n (define_mode_attr fmove_ok [(SF \"\")\n \t\t\t    (DF \"\")\n@@ -289,11 +305,16 @@\n (define_mode_attr f32_lr [(SF \"f\")\t\t (SD \"wz\")])\n (define_mode_attr f32_lm [(SF \"m\")\t\t (SD \"Z\")])\n (define_mode_attr f32_li [(SF \"lfs%U1%X1 %0,%1\") (SD \"lfiwzx %0,%y1\")])\n+(define_mode_attr f32_lv [(SF \"lxsspx %0,%y1\")\t (SD \"lxsiwzx %0,%y1\")])\n \n ; Definitions for store from 32-bit fpr register\n (define_mode_attr f32_sr [(SF \"f\")\t\t  (SD \"wx\")])\n (define_mode_attr f32_sm [(SF \"m\")\t\t  (SD \"Z\")])\n (define_mode_attr f32_si [(SF \"stfs%U0%X0 %1,%0\") (SD \"stfiwx %1,%y0\")])\n+(define_mode_attr f32_sv [(SF \"stxsspx %1,%y0\")\t  (SD \"stxsiwzx %1,%y0\")])\n+\n+; Definitions for 32-bit fpr direct move\n+(define_mode_attr f32_dm [(SF \"wn\") (SD \"wm\")])\n \n ; These modes do not fit in integer registers in 32-bit mode.\n ; but on e500v2, the gpr are 64 bit registers\n@@ -373,7 +394,7 @@\n (define_insn \"*zero_extend<mode>di2_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(zero_extend:DI (match_operand:QHSI 1 \"reg_or_mem_operand\" \"m,r\")))]\n-  \"TARGET_POWERPC64\"\n+  \"TARGET_POWERPC64 && (<MODE>mode != SImode || !TARGET_LFIWZX)\"\n   \"@\n    l<wd>z%U1%X1 %0,%1\n    rldicl %0,%1,0,<dbits>\"\n@@ -439,6 +460,29 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n+(define_insn \"*zero_extendsidi2_lfiwzx\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wm,!wz,!wm\")\n+\t(zero_extend:DI (match_operand:SI 1 \"reg_or_mem_operand\" \"m,r,r,Z,Z\")))]\n+  \"TARGET_POWERPC64 && TARGET_LFIWZX\"\n+  \"@\n+   lwz%U1%X1 %0,%1\n+   rldicl %0,%1,0,32\n+   mtvsrwz %x0,%1\n+   lfiwzx %0,%y1\n+   lxsiwzx %x0,%y1\"\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (const_string \"*\")\n+       (const_string \"mffgpr\")\n+       (const_string \"fpload\")\n+       (const_string \"fpload\")])])\n+\n (define_insn \"extendqidi2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(sign_extend:DI (match_operand:QI 1 \"gpc_reg_operand\" \"r\")))]\n@@ -586,10 +630,33 @@\n   \"TARGET_POWERPC64\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*extendsidi2_lfiwax\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wm,!wl,!wm\")\n+\t(sign_extend:DI (match_operand:SI 1 \"lwa_operand\" \"m,r,r,Z,Z\")))]\n+  \"TARGET_POWERPC64 && TARGET_LFIWAX\"\n+  \"@\n+   lwa%U1%X1 %0,%1\n+   extsw %0,%1\n+   mtvsrwa %x0,%1\n+   lfiwax %0,%y1\n+   lxsiwax %x0,%y1\"\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ext_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_ext_u\")\n+\t   (const_string \"load_ext\")))\n+       (const_string \"exts\")\n+       (const_string \"mffgpr\")\n+       (const_string \"fpload\")\n+       (const_string \"fpload\")])])\n+\n+(define_insn \"*extendsidi2_nocell\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(sign_extend:DI (match_operand:SI 1 \"lwa_operand\" \"m,r\")))]\n-  \"TARGET_POWERPC64 && rs6000_gen_cell_microcode\"\n+  \"TARGET_POWERPC64 && rs6000_gen_cell_microcode && !TARGET_LFIWAX\"\n   \"@\n    lwa%U1%X1 %0,%1\n    extsw %0,%1\"\n@@ -603,7 +670,7 @@\n \t   (const_string \"load_ext\")))\n        (const_string \"exts\")])])\n \n-(define_insn \"\"\n+(define_insn \"*extendsidi2_nocell\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POWERPC64 && !rs6000_gen_cell_microcode\"\n@@ -2040,7 +2107,9 @@\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec:GPR [(match_operand:GPR 1 \"gpc_reg_operand\" \"r\")] UNSPEC_PARITY))]\n   \"TARGET_CMPB && TARGET_POPCNTB\"\n-  \"prty<wd> %0,%1\")\n+  \"prty<wd> %0,%1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"popcnt\")])\n \n (define_expand \"parity<mode>2\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n@@ -4321,7 +4390,7 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"delayed_compare,var_delayed_compare,delayed_compare,delayed_compare,var_delayed_compare,delayed_compare\")\n+  [(set_attr \"type\" \"fast_compare,var_delayed_compare,delayed_compare,delayed_compare,var_delayed_compare,delayed_compare\")\n    (set_attr \"length\" \"4,4,4,8,8,8\")])\n \n (define_split\n@@ -4353,7 +4422,7 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"delayed_compare,var_delayed_compare,delayed_compare,delayed_compare,var_delayed_compare,delayed_compare\")\n+  [(set_attr \"type\" \"fast_compare,var_delayed_compare,delayed_compare,delayed_compare,var_delayed_compare,delayed_compare\")\n    (set_attr \"length\" \"4,4,4,8,8,8\")])\n \n (define_split\n@@ -5558,12 +5627,15 @@\n ; We don't define lfiwax/lfiwzx with the normal definition, because we\n ; don't want to support putting SImode in FPR registers.\n (define_insn \"lfiwax\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DI [(match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\")]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wm,!wm\")\n+\t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r\")]\n \t\t   UNSPEC_LFIWAX))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\"\n-  \"lfiwax %0,%y1\"\n-  [(set_attr \"type\" \"fpload\")])\n+  \"@\n+   lfiwax %0,%y1\n+   lxsiwax %x0,%y1\n+   mtvsrwa %x0,%1\"\n+  [(set_attr \"type\" \"fpload,fpload,mffgpr\")])\n \n ; This split must be run before register allocation because it allocates the\n ; memory slot that is needed to move values to/from the FPR.  We don't allocate\n@@ -5585,7 +5657,8 @@\n   rtx src = operands[1];\n   rtx tmp;\n \n-  if (!MEM_P (src) && TARGET_MFPGPR && TARGET_POWERPC64)\n+  if (!MEM_P (src) && TARGET_POWERPC64\n+      && (TARGET_MFPGPR || TARGET_DIRECT_MOVE))\n     tmp = convert_to_mode (DImode, src, false);\n   else\n     {\n@@ -5634,12 +5707,15 @@\n    (set_attr \"type\" \"fpload\")])\n \n (define_insn \"lfiwzx\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DI [(match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\")]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wm,!wm\")\n+\t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r\")]\n \t\t   UNSPEC_LFIWZX))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\"\n-  \"lfiwzx %0,%y1\"\n-  [(set_attr \"type\" \"fpload\")])\n+  \"@\n+   lfiwzx %0,%y1\n+   lxsiwzx %x0,%y1\n+   mtvsrwz %x0,%1\"\n+  [(set_attr \"type\" \"fpload,fpload,mftgpr\")])\n \n (define_insn_and_split \"floatunssi<mode>2_lfiwzx\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d\")\n@@ -5656,7 +5732,8 @@\n   rtx src = operands[1];\n   rtx tmp;\n \n-  if (!MEM_P (src) && TARGET_MFPGPR && TARGET_POWERPC64)\n+  if (!MEM_P (src) && TARGET_POWERPC64\n+      && (TARGET_MFPGPR || TARGET_DIRECT_MOVE))\n     tmp = convert_to_mode (DImode, src, true);\n   else\n     {\n@@ -5947,7 +6024,7 @@\n       emit_insn (gen_stfiwx (dest, tmp));\n       DONE;\n     }\n-  else if (TARGET_MFPGPR && TARGET_POWERPC64)\n+  else if (TARGET_POWERPC64 && (TARGET_MFPGPR || TARGET_DIRECT_MOVE))\n     {\n       dest = gen_lowpart (DImode, dest);\n       emit_move_insn (dest, tmp);\n@@ -6041,7 +6118,7 @@\n       emit_insn (gen_stfiwx (dest, tmp));\n       DONE;\n     }\n-  else if (TARGET_MFPGPR && TARGET_POWERPC64)\n+  else if (TARGET_POWERPC64 && (TARGET_MFPGPR || TARGET_DIRECT_MOVE))\n     {\n       dest = gen_lowpart (DImode, dest);\n       emit_move_insn (dest, tmp);\n@@ -8507,7 +8584,7 @@\n    cmp<wd>i %2,%0,0\n    mr. %0,%1\n    #\"\n-  [(set_attr \"type\" \"cmp,compare,cmp\")\n+  [(set_attr \"type\" \"cmp,fast_compare,cmp\")\n    (set_attr \"length\" \"4,4,8\")])\n \n (define_split\n@@ -8697,8 +8774,8 @@\n }\")\n \n (define_insn \"mov<mode>_hardfloat\"\n-  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,wa,wa,<f32_lr>,<f32_sm>,*c*l,!r,*h,!r,!r\")\n-\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,wa,j,<f32_lm>,<f32_sr>,r,h,0,G,Fn\"))]\n+  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,wa,wa,<f32_lr>,<f32_sm>,wm,Z,?<f32_dm>,?r,*c*l,!r,*h,!r,!r\")\n+\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,wa,j,<f32_lm>,<f32_sr>,Z,wm,r,<f32_dm>,r,h,0,G,Fn\"))]\n   \"(gpc_reg_operand (operands[0], <MODE>mode)\n    || gpc_reg_operand (operands[1], <MODE>mode))\n    && (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT)\"\n@@ -8711,6 +8788,10 @@\n    xxlxor %x0,%x0,%x0\n    <f32_li>\n    <f32_si>\n+   <f32_lv>\n+   <f32_sv>\n+   mtvsrwz %x0,%1\n+   mfvsrwz %0,%x1\n    mt%0 %1\n    mf%1 %0\n    nop\n@@ -8749,16 +8830,20 @@\n \t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n \t   (const_string \"fpstore_u\")\n \t   (const_string \"fpstore\")))\n+       (const_string \"fpload\")\n+       (const_string \"fpstore\")\n+       (const_string \"mftgpr\")\n+       (const_string \"mffgpr\")\n        (const_string \"mtjmpr\")\n        (const_string \"mfjmpr\")\n        (const_string \"*\")\n        (const_string \"*\")\n        (const_string \"*\")])\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,8\")])\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8\")])\n \n (define_insn \"*mov<mode>_softfloat\"\n   [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=r,cl,r,r,m,r,r,r,r,*h\")\n-\t(match_operand:FMOVE32 1 \"input_operand\" \"r, r,h,m,r,I,L,G,Fn,0\"))]\n+\t(match_operand:FMOVE32 1 \"input_operand\" \"r,r,h,m,r,I,L,G,Fn,0\"))]\n   \"(gpc_reg_operand (operands[0], <MODE>mode)\n    || gpc_reg_operand (operands[1], <MODE>mode))\n    && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\"\n@@ -8971,8 +9056,8 @@\n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*mov<mode>_hardfloat64\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,ws,?wa,Z,?Z,ws,?wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,Z,ws,wa,ws,wa,j,r,Y,r,r,h,0,G,H,F,wg,r\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,ws,?wa,Z,?Z,ws,?wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wm\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,Z,ws,wa,ws,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wm,r\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -8997,7 +9082,9 @@\n    #\n    #\n    mftgpr %0,%1\n-   mffgpr %0,%1\"\n+   mffgpr %0,%1\n+   mfvsrd %0,%x1\n+   mtvsrd %x0,%1\"\n   [(set_attr_alternative \"type\"\n       [(if_then_else\n \t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n@@ -9055,8 +9142,10 @@\n        (const_string \"*\")\n        (const_string \"*\")\n        (const_string \"mftgpr\")\n+       (const_string \"mffgpr\")\n+       (const_string \"mftgpr\")\n        (const_string \"mffgpr\")])\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16,4,4\")])\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16,4,4,4,4\")])\n \n (define_insn \"*mov<mode>_softfloat64\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,cl,r,r,r,r,*h\")\n@@ -9435,6 +9524,216 @@\n   DONE;\n })\n \n+\f\n+;; Power8 merge instructions to allow direct move to/from floating point\n+;; registers in 32-bit mode.  We use TF mode to get two registers to move the\n+;; individual 32-bit parts across.  Subreg doesn't work too well on the TF\n+;; value, since it is allocated in reload and not all of the flow information\n+;; is setup for it.  We have two patterns to do the two moves between gprs and\n+;; fprs.  There isn't a dependancy between the two, but we could potentially\n+;; schedule other instructions between the two instructions.  TFmode is\n+;; currently limited to traditional FPR registers.  If/when this is changed, we\n+;; will need to revist %L to make sure it works with VSX registers, or add an\n+;; %x version of %L.\n+\n+(define_insn \"p8_fmrgow_<mode>\"\n+  [(set (match_operand:FMOVE64X 0 \"register_operand\" \"=d\")\n+\t(unspec:FMOVE64X [(match_operand:TF 1 \"register_operand\" \"d\")]\n+\t\t\t UNSPEC_P8V_FMRGOW))]\n+  \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"fmrgow %0,%1,%L1\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"p8_mtvsrwz_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=d\")\n+\t(unspec:TF [(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_P8V_MTVSRWZ))]\n+  \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"mtvsrwz %x0,%1\"\n+  [(set_attr \"type\" \"mftgpr\")])\n+\n+(define_insn \"p8_mtvsrwz_2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"+d\")\n+\t(unspec:TF [(match_dup 0)\n+\t\t    (match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_P8V_MTVSRWZ))]\n+  \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"mtvsrwz %L0,%1\"\n+  [(set_attr \"type\" \"mftgpr\")])\n+\n+(define_insn_and_split \"reload_fpr_from_gpr<mode>\"\n+  [(set (match_operand:FMOVE64X 0 \"register_operand\" \"=ws\")\n+\t(unspec:FMOVE64X [(match_operand:FMOVE64X 1 \"register_operand\" \"r\")]\n+\t\t\t UNSPEC_P8V_RELOAD_FROM_GPR))\n+   (clobber (match_operand:TF 2 \"register_operand\" \"=d\"))]\n+  \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp = operands[2];\n+  rtx gpr_hi_reg = gen_highpart (SImode, src);\n+  rtx gpr_lo_reg = gen_lowpart (SImode, src);\n+\n+  emit_insn (gen_p8_mtvsrwz_1 (tmp, gpr_hi_reg));\n+  emit_insn (gen_p8_mtvsrwz_2 (tmp, gpr_lo_reg));\n+  emit_insn (gen_p8_fmrgow_<mode> (dest, tmp));\n+  DONE;\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"three\")])\n+\n+;; Move 128 bit values from GPRs to VSX registers in 64-bit mode\n+(define_insn \"p8_mtvsrd_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=ws\")\n+\t(unspec:TF [(match_operand:DI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_P8V_MTVSRD))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"mtvsrd %0,%1\"\n+  [(set_attr \"type\" \"mftgpr\")])\n+\n+(define_insn \"p8_mtvsrd_2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"+ws\")\n+\t(unspec:TF [(match_dup 0)\n+\t\t    (match_operand:DI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_P8V_MTVSRD))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"mtvsrd %L0,%1\"\n+  [(set_attr \"type\" \"mftgpr\")])\n+\n+(define_insn \"p8_xxpermdi_<mode>\"\n+  [(set (match_operand:FMOVE128_GPR 0 \"register_operand\" \"=wa\")\n+\t(unspec:FMOVE128_GPR [(match_operand:TF 1 \"register_operand\" \"ws\")]\n+\t\t\t     UNSPEC_P8V_XXPERMDI))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"xxpermdi %x0,%1,%L1,0\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn_and_split \"reload_vsx_from_gpr<mode>\"\n+  [(set (match_operand:FMOVE128_GPR 0 \"register_operand\" \"=wa\")\n+\t(unspec:FMOVE128_GPR\n+\t [(match_operand:FMOVE128_GPR 1 \"register_operand\" \"r\")]\n+\t UNSPEC_P8V_RELOAD_FROM_GPR))\n+   (clobber (match_operand:TF 2 \"register_operand\" \"=ws\"))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp = operands[2];\n+  rtx gpr_hi_reg = gen_highpart (DImode, src);\n+  rtx gpr_lo_reg = gen_lowpart (DImode, src);\n+\n+  emit_insn (gen_p8_mtvsrd_1 (tmp, gpr_hi_reg));\n+  emit_insn (gen_p8_mtvsrd_2 (tmp, gpr_lo_reg));\n+  emit_insn (gen_p8_xxpermdi_<mode> (dest, tmp));\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"three\")])\n+\n+;; Move SFmode to a VSX from a GPR register.  Because scalar floating point\n+;; type is stored internally as double precision in the VSX registers, we have\n+;; to convert it from the vector format.\n+\n+(define_insn_and_split \"reload_vsx_from_gprsf\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=wa\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_P8V_RELOAD_FROM_GPR))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=r\"))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE && WORDS_BIG_ENDIAN\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op0_di = simplify_gen_subreg (DImode, op0, SFmode, 0);\n+  rtx op1_di = simplify_gen_subreg (DImode, op1, SFmode, 0);\n+\n+  /* Move SF value to upper 32-bits for xscvspdpn.  */\n+  emit_insn (gen_ashldi3 (op2, op1_di, GEN_INT (32)));\n+  emit_move_insn (op0_di, op2);\n+  emit_insn (gen_vsx_xscvspdpn_directmove (op0, op0));\n+  DONE;\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"two\")])\n+\n+;; Move 128 bit values from VSX registers to GPRs in 64-bit mode by doing a\n+;; normal 64-bit move, followed by an xxpermdi to get the bottom 64-bit value,\n+;; and then doing a move of that.\n+(define_insn \"p8_mfvsrd_3_<mode>\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(unspec:DF [(match_operand:FMOVE128_GPR 1 \"register_operand\" \"wa\")]\n+\t\t   UNSPEC_P8V_RELOAD_FROM_VSX))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE && WORDS_BIG_ENDIAN\"\n+  \"mfvsrd %0,%x1\"\n+  [(set_attr \"type\" \"mftgpr\")])\n+\n+(define_insn_and_split \"reload_gpr_from_vsx<mode>\"\n+  [(set (match_operand:FMOVE128_GPR 0 \"register_operand\" \"=r\")\n+\t(unspec:FMOVE128_GPR\n+\t [(match_operand:FMOVE128_GPR 1 \"register_operand\" \"wa\")]\n+\t UNSPEC_P8V_RELOAD_FROM_VSX))\n+   (clobber (match_operand:FMOVE128_GPR 2 \"register_operand\" \"=wa\"))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE && WORDS_BIG_ENDIAN\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp = operands[2];\n+  rtx gpr_hi_reg = gen_highpart (DFmode, dest);\n+  rtx gpr_lo_reg = gen_lowpart (DFmode, dest);\n+\n+  emit_insn (gen_p8_mfvsrd_3_<mode> (gpr_hi_reg, src));\n+  emit_insn (gen_vsx_xxpermdi_<mode> (tmp, src, src, GEN_INT (3)));\n+  emit_insn (gen_p8_mfvsrd_3_<mode> (gpr_lo_reg, tmp));\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"three\")])\n+\n+;; Move SFmode to a GPR from a VSX register.  Because scalar floating point\n+;; type is stored internally as double precision, we have to convert it to the\n+;; vector format.\n+\n+(define_insn_and_split \"reload_gpr_from_vsxsf\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"wa\")]\n+\t\t   UNSPEC_P8V_RELOAD_FROM_VSX))\n+   (clobber (match_operand:V4SF 2 \"register_operand\" \"=wa\"))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE && WORDS_BIG_ENDIAN\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx diop0 = simplify_gen_subreg (DImode, op0, SFmode, 0);\n+\n+  emit_insn (gen_vsx_xscvdpspn_scalar (op2, op1));\n+  emit_insn (gen_p8_mfvsrd_4_disf (diop0, op2));\n+  emit_insn (gen_lshrdi3 (diop0, diop0, GEN_INT (32)));\n+  DONE;\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"three\")])\n+\n+(define_insn \"p8_mfvsrd_4_disf\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:V4SF 1 \"register_operand\" \"wa\")]\n+\t\t   UNSPEC_P8V_RELOAD_FROM_VSX))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE && WORDS_BIG_ENDIAN\"\n+  \"mfvsrd %0,%x1\"\n+  [(set_attr \"type\" \"mftgpr\")])\n+\n \f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns.\n@@ -9484,7 +9783,8 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n   \"! TARGET_POWERPC64 && reload_completed\n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\n+   && !direct_move_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 1))]\n   \"\n@@ -9502,13 +9802,14 @@\n   [(set (match_operand:DIFD 0 \"rs6000_nonimmediate_operand\" \"\")\n         (match_operand:DIFD 1 \"input_operand\" \"\"))]\n   \"reload_completed && !TARGET_POWERPC64\n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\n+   && !direct_move_p (operands[0], operands[1])\"\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_insn \"*movdi_internal64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,?Z,?wa,?wa,r,*h,*h,?wa,r,?*wg\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,wa,Z,wa,*h,r,0,O,*wg,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,?Z,?wa,?wa,r,*h,*h,?wa,r,?*wg,r,?*wm\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,wa,Z,wa,*h,r,0,O,*wg,r,*wm,r\"))]\n   \"TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n@@ -9530,7 +9831,9 @@\n    nop\n    xxlxor %x0,%x0,%x0\n    mftgpr %0,%1\n-   mffgpr %0,%1\"\n+   mffgpr %0,%1\n+   mfvsrd %0,%x1\n+   mtvsrd %x0,%1\"\n   [(set_attr_alternative \"type\"\n       [(if_then_else\n \t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n@@ -9579,8 +9882,10 @@\n        (const_string \"*\")\n        (const_string \"vecsimple\")\n        (const_string \"mftgpr\")\n+       (const_string \"mffgpr\")\n+       (const_string \"mftgpr\")\n        (const_string \"mffgpr\")])\n-   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4,4\")])\n+   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4,4,4,4\")])\n \n ;; Generate all one-bits and clear left or right.\n ;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.\n@@ -9669,19 +9974,20 @@\n \t\t\t\t\t  (const_string \"conditional\")))])\n \n (define_insn \"*mov<mode>_ppc64\"\n-  [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"=Y,r,r\")\n-\t(match_operand:TI2 1 \"input_operand\" \"r,Y,r\"))]\n-  \"(TARGET_POWERPC64\n-   && (<MODE>mode != TImode || VECTOR_MEM_NONE_P (TImode))\n+  [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"=Y,r,r,r\")\n+\t(match_operand:TI2 1 \"input_operand\" \"r,Y,r,F\"))]\n+  \"(TARGET_POWERPC64 && VECTOR_MEM_NONE_P (<MODE>mode)\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode)))\"\n   \"#\"\n-  [(set_attr \"type\" \"store,load,*\")])\n+  [(set_attr \"type\" \"store,load,*,*\")])\n \n (define_split\n-  [(set (match_operand:TI2 0 \"gpc_reg_operand\" \"\")\n+  [(set (match_operand:TI2 0 \"int_reg_operand\" \"\")\n \t(match_operand:TI2 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_POWERPC64\"\n+  \"TARGET_POWERPC64\n+   && (VECTOR_MEM_NONE_P (<MODE>mode)\n+       || (reload_completed && INT_REGNO_P (REGNO (operands[0]))))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n   \"\n@@ -9708,7 +10014,9 @@\n   [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TI2 1 \"input_operand\" \"\"))]\n   \"reload_completed\n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\n+   && !direct_move_p (operands[0], operands[1])\n+   && !quad_load_store_p (operands[0], operands[1])\"\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \f"}, {"sha": "6cfebdeebdc29b13b94b48b533fbec997be1d154", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -126,7 +126,9 @@\n         (match_operand:VEC_L 1 \"input_operand\" \"\"))]\n   \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n    && reload_completed\n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\n+   && !direct_move_p (operands[0], operands[1])\n+   && !quad_load_store_p (operands[0], operands[1])\"\n   [(pc)]\n {\n   rs6000_split_multireg_move (operands[0], operands[1]);"}, {"sha": "b87da826a95d8415481ae620c1bea6e6878a75b1", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 10, "deletions": 91, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -213,112 +213,31 @@\n \n ;; VSX moves\n (define_insn \"*vsx_mov<mode>\"\n-  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?wa,?wa,*Y,*r,*r,<VSr>,?wa,*r,v,wZ,v\")\n-\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,Z,<VSr>,wa,Z,wa,r,Y,r,j,j,j,W,v,wZ\"))]\n+  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?wa,?wa,wQ,?&r,??Y,??r,??r,<VSr>,?wa,*r,v,wZ, v\")\n+\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,Z,<VSr>,wa,Z,wa,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\n    && (register_operand (operands[0], <MODE>mode) \n        || register_operand (operands[1], <MODE>mode))\"\n {\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 3:\n-      gcc_assert (MEM_P (operands[0])\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_INC\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_DEC\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_MODIFY);\n-      return \"stx<VSm>x %x1,%y0\";\n-\n-    case 1:\n-    case 4:\n-      gcc_assert (MEM_P (operands[1])\n-\t\t  && GET_CODE (XEXP (operands[1], 0)) != PRE_INC\n-\t\t  && GET_CODE (XEXP (operands[1], 0)) != PRE_DEC\n-\t\t  && GET_CODE (XEXP (operands[1], 0)) != PRE_MODIFY);\n-      return \"lx<VSm>x %x0,%y1\";\n-\n-    case 2:\n-    case 5:\n-      return \"xxlor %x0,%x1,%x1\";\n-\n-    case 6:\n-    case 7:\n-    case 8:\n-    case 11:\n-      return \"#\";\n-\n-    case 9:\n-    case 10:\n-      return \"xxlxor %x0,%x0,%x0\";\n-\n-    case 12:\n-      return output_vec_const_move (operands);\n-\n-    case 13:\n-      gcc_assert (MEM_P (operands[0])\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_INC\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_DEC\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_MODIFY);\n-      return \"stvx %1,%y0\";\n-\n-    case 14:\n-      gcc_assert (MEM_P (operands[0])\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_INC\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_DEC\n-\t\t  && GET_CODE (XEXP (operands[0], 0)) != PRE_MODIFY);\n-      return \"lvx %0,%y1\";\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return rs6000_output_move_128bit (operands);\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecstore,vecload,vecsimple,*,*,*,vecsimple,vecsimple,*,*,vecstore,vecload\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecstore,vecload,vecsimple,load,store,store,load, *,vecsimple,vecsimple,*, *,vecstore,vecload\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,12,12,12,12,16,4,4,*,16,4,4\")])\n \n ;; Unlike other VSX moves, allow the GPRs even for reloading, since a normal\n ;; use of TImode is for unions.  However for plain data movement, slightly\n ;; favor the vector loads\n (define_insn \"*vsx_movti_64bit\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,v, v,wZ,?Y,?r,?r,?r\")\n-\t(match_operand:TI 1 \"input_operand\"        \"wa, Z,wa, O,W,wZ, v, r, Y, r, n\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,v,v,wZ,wQ,&r,Y,r,r,?r\")\n+\t(match_operand:TI 1 \"input_operand\" \"wa,Z,wa,O,W,wZ,v,r,wQ,r,Y,r,n\"))]\n   \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)\n    && (register_operand (operands[0], TImode) \n        || register_operand (operands[1], TImode))\"\n {\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"stxvd2x %x1,%y0\";\n-\n-    case 1:\n-      return \"lxvd2x %x0,%y1\";\n-\n-    case 2:\n-      return \"xxlor %x0,%x1,%x1\";\n-\n-    case 3:\n-      return \"xxlxor %x0,%x0,%x0\";\n-\n-    case 4:\n-      return output_vec_const_move (operands);\n-\n-    case 5:\n-      return \"stvx %1,%y0\";\n-\n-    case 6:\n-      return \"lvx %0,%y1\";\n-\n-    case 7:\n-    case 8:\n-    case 9:\n-    case 10:\n-      return \"#\";\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return rs6000_output_move_128bit (operands);\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecsimple,vecsimple,vecstore,vecload,*,*,*,*\")\n-   (set_attr \"length\" \"     4,      4,        4,       4,         8,       4,      4,8,8,8,8\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecsimple,vecsimple,vecstore,vecload,store,load,store,load,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,16,4,4,8,8,8,8,8,8\")])\n \n (define_insn \"*vsx_movti_32bit\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,v, v,wZ,Q,Y,????r,????r,????r,r\")"}, {"sha": "8817b27dd2329cf60c46d77e27784834b9a36a78", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -1,3 +1,18 @@\n+2013-06-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen <pthaugen@us.ibm.com>\n+\t    Peter Bergner <bergner@vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/direct-move-vint1.c: New tests for power8\n+\tdirect move instructions.\n+\t* gcc.target/powerpc/direct-move-vint2.c: Likewise.\n+\t* gcc.target/powerpc/direct-move.h: Likewise.\n+\t* gcc.target/powerpc/direct-move-float1.c: Likewise.\n+\t* gcc.target/powerpc/direct-move-float2.c: Likewise.\n+\t* gcc.target/powerpc/direct-move-double1.c: Likewise.\n+\t* gcc.target/powerpc/direct-move-double2.c: Likewise.\n+\t* gcc.target/powerpc/direct-move-long1.c: Likewise.\n+\t* gcc.target/powerpc/direct-move-long2.c: Likewise.\n+\n 2013-06-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/52440"}, {"sha": "534a04a937b5b0c7eb710e7a58b88d2d76a3a9d1", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-double1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-double1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-double1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-double1.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-final { scan-assembler-times \"mtvsrd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"mfvsrd\" 1 } } */\n+\n+/* Check code generation for direct move for long types.  */\n+\n+#define TYPE double\n+#define IS_FLOAT 1\n+#define NO_ALTIVEC 1\n+\n+#include \"direct-move.h\""}, {"sha": "750debfc0dfa72e6d6314158325bb93802ca7aac", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-double2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-double2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-double2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-double2.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* Check whether we get the right bits for direct move at runtime.  */\n+\n+#define TYPE double\n+#define IS_FLOAT 1\n+#define NO_ALTIVEC 1\n+#define DO_MAIN\n+\n+#include \"direct-move.h\""}, {"sha": "ff1e97c0d43c5fea3ee4190cede27afca5332e36", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-float1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-float1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-float1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-float1.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-final { scan-assembler-times \"mtvsrd\" 2 } } */\n+/* { dg-final { scan-assembler-times \"mfvsrd\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xscvdpspn\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xscvspdpn\" 2 } } */\n+\n+/* Check code generation for direct move for long types.  */\n+\n+#define TYPE float\n+#define IS_FLOAT 1\n+#define NO_ALTIVEC 1\n+\n+#include \"direct-move.h\""}, {"sha": "ace728ff6d4428e5f764c3869a688f3adbdd6f7e", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-float2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-float2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-float2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-float2.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* Check whether we get the right bits for direct move at runtime.  */\n+\n+#define TYPE float\n+#define IS_FLOAT 1\n+#define NO_ALTIVEC 1\n+#define DO_MAIN\n+\n+#include \"direct-move.h\""}, {"sha": "907e802c72b216a75fccd13921c59574f133641a", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-long1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-long1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-long1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-long1.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-final { scan-assembler-times \"mtvsrd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"mfvsrd\" 2 } } */\n+\n+/* Check code generation for direct move for long types.  */\n+\n+#define TYPE long\n+#define IS_INT 1\n+#define NO_ALTIVEC 1\n+\n+#include \"direct-move.h\""}, {"sha": "fba613e454824687d3bffe0ee77c6bf80e9ba532", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-long2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-long2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-long2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-long2.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* Check whether we get the right bits for direct move at runtime.  */\n+\n+#define TYPE long\n+#define IS_INT 1\n+#define NO_ALTIVEC 1\n+#define DO_MAIN\n+\n+#include \"direct-move.h\""}, {"sha": "cdfa18857f14730aacb13bcf3e56d5f8453d1018", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-vint1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vint1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vint1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vint1.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-final { scan-assembler-times \"mtvsrd\" 4 } } */\n+/* { dg-final { scan-assembler-times \"mfvsrd\" 4 } } */\n+\n+/* Check code generation for direct move for long types.  */\n+\n+#define TYPE vector int\n+\n+#include \"direct-move.h\""}, {"sha": "5c0c9abdac5581bcd29ff010555991b6dfbda97e", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-vint2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vint2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vint2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vint2.c?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do run { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* Check whether we get the right bits for direct move at runtime.  */\n+\n+#define TYPE vector int\n+#define DO_MAIN\n+\n+#include \"direct-move.h\""}, {"sha": "4e84fd678bbcbf3a38cce0822e6ac3b39f6764b6", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move.h", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19be72ab30d4518ebabbed3c3aefb020d00e374d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move.h?ref=19be72ab30d4518ebabbed3c3aefb020d00e374d", "patch": "@@ -0,0 +1,183 @@\n+/* Test functions for direct move support.  */\n+\n+\n+void __attribute__((__noinline__))\n+copy (TYPE *a, TYPE *b)\n+{\n+  *b = *a;\n+}\n+\n+#ifndef NO_GPR\n+void __attribute__((__noinline__))\n+load_gpr (TYPE *a, TYPE *b)\n+{\n+  TYPE c = *a;\n+  __asm__ (\"# gpr, reg = %0\" : \"+b\" (c));\n+  *b = c;\n+}\n+#endif\n+\n+#ifndef NO_FPR\n+void __attribute__((__noinline__))\n+load_fpr (TYPE *a, TYPE *b)\n+{\n+  TYPE c = *a;\n+  __asm__ (\"# fpr, reg = %0\" : \"+d\" (c));\n+  *b = c;\n+}\n+#endif\n+\n+#ifndef NO_ALTIVEC\n+void __attribute__((__noinline__))\n+load_altivec (TYPE *a, TYPE *b)\n+{\n+  TYPE c = *a;\n+  __asm__ (\"# altivec, reg = %0\" : \"+v\" (c));\n+  *b = c;\n+}\n+#endif\n+\n+#ifndef NO_VSX\n+void __attribute__((__noinline__))\n+load_vsx (TYPE *a, TYPE *b)\n+{\n+  TYPE c = *a;\n+  __asm__ (\"# vsx, reg = %x0\" : \"+wa\" (c));\n+  *b = c;\n+}\n+#endif\n+\n+#ifndef NO_GPR_TO_VSX\n+void __attribute__((__noinline__))\n+load_gpr_to_vsx (TYPE *a, TYPE *b)\n+{\n+  TYPE c = *a;\n+  TYPE d;\n+  __asm__ (\"# gpr, reg = %0\" : \"+b\" (c));\n+  d = c;\n+  __asm__ (\"# vsx, reg = %x0\" : \"+wa\" (d));\n+  *b = d;\n+}\n+#endif\n+\n+#ifndef NO_VSX_TO_GPR\n+void __attribute__((__noinline__))\n+load_vsx_to_gpr (TYPE *a, TYPE *b)\n+{\n+  TYPE c = *a;\n+  TYPE d;\n+  __asm__ (\"# vsx, reg = %x0\" : \"+wa\" (c));\n+  d = c;\n+  __asm__ (\"# gpr, reg = %0\" : \"+b\" (d));\n+  *b = d;\n+}\n+#endif\n+\n+#ifdef DO_MAIN\n+typedef void (fn_type (TYPE *, TYPE *));\n+\n+struct test_struct {\n+  fn_type *func;\n+  const char *name;\n+};\n+\n+const struct test_struct test_functions[] = {\n+  { copy,\t\t\"copy\"\t\t  },\n+#ifndef NO_GPR\n+  { load_gpr,\t\t\"load_gpr\"\t  },\n+#endif\n+#ifndef NO_FPR\n+  { load_fpr,\t\t\"load_fpr\"\t  },\n+#endif\n+#ifndef NO_ALTIVEC\n+  { load_altivec,\t\"load_altivec\"\t  },\n+#endif\n+#ifndef NO_VSX\n+  { load_vsx,\t\t\"load_vsx\"\t  },\n+#endif\n+#ifndef NO_GPR_TO_VSX\n+  { load_gpr_to_vsx,\t\"load_gpr_to_vsx\" },\n+#endif\n+#ifndef NO_VSX_TO_GPR\n+  { load_vsx_to_gpr,\t\"load_vsx_to_gpr\" },\n+#endif\n+};\n+\n+/* Test a given value for each of the functions.  */\n+void __attribute__((__noinline__))\n+test_value (TYPE a)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof (test_functions) / sizeof (test_functions[0]); i++)\n+    {\n+      TYPE b;\n+\n+      test_functions[i].func (&a, &b);\n+      if (memcmp ((void *)&a, (void *)&b, sizeof (TYPE)) != 0)\n+\tabort ();\n+    }\n+}\n+\n+/* Main program.  */\n+int\n+main (void)\n+{\n+  size_t i;\n+  long j;\n+  union {\n+    TYPE value;\n+    unsigned char bytes[sizeof (TYPE)];\n+  } u;\n+\n+#if IS_INT\n+  TYPE value = (TYPE)-5;\n+  for (i = 0; i < 12; i++)\n+    {\n+      test_value (value);\n+      value++;\n+    }\n+\n+  for (i = 0; i < 8*sizeof (TYPE); i++)\n+    test_value (((TYPE)1) << i);\n+\n+#elif IS_UNS\n+  TYPE value = (TYPE)0;\n+  for (i = 0; i < 10; i++)\n+    {\n+      test_value (value);\n+      test_value (~ value);\n+      value++;\n+    }\n+\n+  for (i = 0; i < 8*sizeof (TYPE); i++)\n+    test_value (((TYPE)1) << i);\n+\n+#elif IS_FLOAT\n+  TYPE value = (TYPE)-5;\n+  for (i = 0; i < 12; i++)\n+    {\n+      test_value (value);\n+      value++;\n+    }\n+\n+  test_value ((TYPE)3.1415926535);\n+  test_value ((TYPE)1.23456);\n+  test_value ((TYPE)(-0.0));\n+  test_value ((TYPE)NAN);\n+  test_value ((TYPE)+INFINITY);\n+  test_value ((TYPE)-INFINITY);\n+#else\n+\n+  for (j = 0; j < 10; j++)\n+    {\n+      for (i = 0; i < sizeof (TYPE); i++)\n+\tu.bytes[i] = (unsigned char) (random () >> 4);\n+\n+      test_value (u.value);\n+    }\n+#endif\n+\n+  return 0;\n+}\n+#endif"}]}