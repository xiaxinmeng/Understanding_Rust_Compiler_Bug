{"sha": "f73d56667d8c9b6344e930bac2928a7cca46ab4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjczZDU2NjY3ZDhjOWI2MzQ0ZTkzMGJhYzI5MjhhN2NjYTQ2YWI0Yw==", "commit": {"author": {"name": "Mostafa Hagog", "email": "mustafa@il.ibm.com", "date": "2005-04-03T09:27:07Z"}, "committer": {"name": "Mostafa Hagog", "email": "hagog@gcc.gnu.org", "date": "2005-04-03T09:27:07Z"}, "message": "cfg.c (clear_bb_flags): Don't clear BB_DISABLE_SCHEDULE.\n\n2005-03-31 Mostafa Hagog <mustafa@il.ibm.com>\n\n        * cfg.c (clear_bb_flags): Don't clear BB_DISABLE_SCHEDULE.\n        * modulo-sched.c (undo_replace_buff_elem): New structure.\n        (kernel_number_of_cycles, ps_unschedule_node,\n        undo_generate_reg_moves,free_undo_replace_buff,\n        undo_permute_partial_schedule,  loop_single_full_bb_p,\n        SIMPLE_SMS_LOOP_P, loop_canon_p, canon_loop,\n        build_loops_structure, get_sched_window): New.\n        (generate_reg_moves): Return undo_replace_buff_elem and other\n        fixes.\n        (generate_prolog_epilog): Remove old loop versioning.\n        (sms_schedule): Use loop information and loop_version.\n        (sms_schedule_by_order): Split part of it to get_sched_window.\n        * passes.c (rest_of_handle_sms): call cfg_layout_initialize\n        cfg_layout_finalize and free_dominance_info before/after SMS.\n\nFrom-SVN: r97484", "tree": {"sha": "8a2f7cc89d6073c3b6b3841a55aaa027e337866b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a2f7cc89d6073c3b6b3841a55aaa027e337866b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f73d56667d8c9b6344e930bac2928a7cca46ab4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f73d56667d8c9b6344e930bac2928a7cca46ab4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f73d56667d8c9b6344e930bac2928a7cca46ab4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f73d56667d8c9b6344e930bac2928a7cca46ab4c/comments", "author": null, "committer": null, "parents": [{"sha": "1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c"}], "stats": {"total": 1016, "additions": 693, "deletions": 323}, "files": [{"sha": "1a87962919a88d31794a92654e91db4276118eeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73d56667d8c9b6344e930bac2928a7cca46ab4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73d56667d8c9b6344e930bac2928a7cca46ab4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f73d56667d8c9b6344e930bac2928a7cca46ab4c", "patch": "@@ -1,3 +1,20 @@\n+2005-04-03 Mostafa Hagog <mustafa@il.ibm.com>\n+\n+\t* cfg.c (clear_bb_flags): Don't clear BB_DISABLE_SCHEDULE.\n+\t* modulo-sched.c (undo_replace_buff_elem): New structure.\n+\t(kernel_number_of_cycles, ps_unschedule_node,\n+\tundo_generate_reg_moves,free_undo_replace_buff,\n+\tundo_permute_partial_schedule, \tloop_single_full_bb_p,\n+\tSIMPLE_SMS_LOOP_P, loop_canon_p, canon_loop,\n+\tbuild_loops_structure, get_sched_window): New.\n+\t(generate_reg_moves): Return undo_replace_buff_elem and other\n+\tfixes.\n+\t(generate_prolog_epilog): Remove old loop versioning.\n+\t(sms_schedule): Use loop information and loop_version.\n+\t(sms_schedule_by_order): Split part of it to get_sched_window.\n+\t* passes.c (rest_of_handle_sms): call cfg_layout_initialize\n+\tcfg_layout_finalize and free_dominance_info before/after SMS.\n+\n 2005-04-03 Mostafa Hagog <mustafa@il.ibm.com>\n \n \t* cfghooks.c (lv_flush_pending_stmts,"}, {"sha": "b8dccb080f58cb6b8767125f9722f39b2a7ccd25", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73d56667d8c9b6344e930bac2928a7cca46ab4c/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73d56667d8c9b6344e930bac2928a7cca46ab4c/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=f73d56667d8c9b6344e930bac2928a7cca46ab4c", "patch": "@@ -461,7 +461,7 @@ clear_bb_flags (void)\n   basic_block bb;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    bb->flags = BB_PARTITION (bb);\n+    bb->flags = BB_PARTITION (bb)  | (bb->flags & BB_DISABLE_SCHEDULE);\n }\n \f\n /* Check the consistency of profile information.  We can't do that"}, {"sha": "a2443c1748030c0378d49f313180ebd876573880", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 666, "deletions": 321, "changes": 987, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73d56667d8c9b6344e930bac2928a7cca46ab4c/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73d56667d8c9b6344e930bac2928a7cca46ab4c/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=f73d56667d8c9b6344e930bac2928a7cca46ab4c", "patch": "@@ -145,16 +145,31 @@ struct partial_schedule\n   ddg_ptr g;\t/* The DDG of the insns in the partial schedule.  */\n };\n \n+/* We use this to record all the register replacements we do in\n+   the kernel so we can undo SMS if it is not profitable.  */\n+struct undo_replace_buff_elem\n+{\n+  rtx insn;\n+  rtx orig_reg;\n+  rtx new_reg;\n+  struct undo_replace_buff_elem *next;\n+};\n \n-static partial_schedule_ptr create_partial_schedule (int ii, ddg_ptr, int history);\n-static void free_partial_schedule (partial_schedule_ptr);\n-static void reset_partial_schedule (partial_schedule_ptr, int new_ii);\n+\n+  \n+partial_schedule_ptr create_partial_schedule (int ii, ddg_ptr, int history);\n+void free_partial_schedule (partial_schedule_ptr);\n+void reset_partial_schedule (partial_schedule_ptr, int new_ii);\n void print_partial_schedule (partial_schedule_ptr, FILE *);\n+static int kernel_number_of_cycles (rtx first_insn, rtx last_insn);\n static ps_insn_ptr ps_add_node_check_conflicts (partial_schedule_ptr,\n \t\t\t\t\t\tddg_node_ptr node, int cycle,\n \t\t\t\t\t\tsbitmap must_precede,\n \t\t\t\t\t\tsbitmap must_follow);\n static void rotate_partial_schedule (partial_schedule_ptr, int);\n+void set_row_column_for_ps (partial_schedule_ptr);\n+static bool ps_unschedule_node (partial_schedule_ptr, ddg_node_ptr );\n+\n \f\n /* This page defines constants and structures for the modulo scheduling\n    driver.  */\n@@ -174,12 +189,11 @@ static void set_node_sched_params (ddg_ptr);\n static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int,\n \t\t\t\t\t\t   int *, FILE*);\n static void permute_partial_schedule (partial_schedule_ptr ps, rtx last);\n-static void generate_prolog_epilog (partial_schedule_ptr, rtx, rtx, int);\n+static void generate_prolog_epilog (partial_schedule_ptr ,struct loop * loop, rtx);\n static void duplicate_insns_of_cycles (partial_schedule_ptr ps,\n \t\t\t\t       int from_stage, int to_stage,\n \t\t\t\t       int is_prolog);\n \n-\n #define SCHED_ASAP(x) (((node_sched_params_ptr)(x)->aux.info)->asap)\n #define SCHED_TIME(x) (((node_sched_params_ptr)(x)->aux.info)->time)\n #define SCHED_FIRST_REG_MOVE(x) \\\n@@ -458,12 +472,13 @@ calculate_maxii (ddg_ptr g)\n    nreg_moves = ----------------------------------- + 1 - {   dependence.\n                             ii                          { 1 if not.\n */\n-static void\n+static struct undo_replace_buff_elem *\n generate_reg_moves (partial_schedule_ptr ps)\n {\n   ddg_ptr g = ps->g;\n   int ii = ps->ii;\n   int i;\n+  struct undo_replace_buff_elem *reg_move_replaces = NULL;\n \n   for (i = 0; i < g->num_nodes; i++)\n     {\n@@ -536,11 +551,77 @@ generate_reg_moves (partial_schedule_ptr ps)\n \t    SCHED_FIRST_REG_MOVE (u) = reg_move;\n \n \t  EXECUTE_IF_SET_IN_SBITMAP (uses_of_defs[i_reg_move], 0, i_use,\n-\t    replace_rtx (g->nodes[i_use].insn, old_reg, new_reg));\n+\t    {\n+\t      struct undo_replace_buff_elem *rep;\n+\n+\t      rep = (struct undo_replace_buff_elem *)\n+\t\t    xcalloc (1, sizeof (struct undo_replace_buff_elem));\n+\t      rep->insn = g->nodes[i_use].insn;\n+\t      rep->orig_reg = old_reg;\n+\t      rep->new_reg = new_reg;\n+\n+\t      if (! reg_move_replaces)\n+\t\treg_move_replaces = rep;\n+\t      else\n+\t\t{\n+\t\t  rep->next = reg_move_replaces;\n+\t\t  reg_move_replaces = rep;\n+\t\t}\n+\n+\t      replace_rtx (g->nodes[i_use].insn, old_reg, new_reg);\n+\t    });\n \n \t  prev_reg = new_reg;\n \t}\n     }\n+  return reg_move_replaces;\n+}\n+\n+/* We call this when we want to undo the SMS schedule for a given loop.\n+   One of the things that we do is to delete the register moves generated\n+   for the sake of SMS; this function deletes the register move instructions\n+   recorded in the undo buffer.  */\n+static void\n+undo_generate_reg_moves (partial_schedule_ptr ps,\n+\t\t\t struct undo_replace_buff_elem *reg_move_replaces)\n+{\n+  int i,j;\n+\n+  for (i = 0; i < ps->g->num_nodes; i++)\n+    {\n+      ddg_node_ptr u = &ps->g->nodes[i];\n+      rtx prev;\n+      rtx crr = SCHED_FIRST_REG_MOVE (u);\n+\n+      for (j = 0; j < SCHED_NREG_MOVES (u); j++)\n+\t{\n+\t  prev = PREV_INSN (crr);\n+\t  delete_insn (crr);\n+\t  crr = prev;\n+\t}\n+    }\n+\n+  while (reg_move_replaces)\n+    {\n+      struct undo_replace_buff_elem *rep = reg_move_replaces;\n+\n+      reg_move_replaces = reg_move_replaces->next;\n+      replace_rtx (rep->insn, rep->new_reg, rep->orig_reg);\n+    }\n+}\n+\n+/* Free memory allocated for the undo buffer.  */\n+static void\n+free_undo_replace_buff (struct undo_replace_buff_elem *reg_move_replaces)\n+{\n+\n+  while (reg_move_replaces)\n+    {\n+      struct undo_replace_buff_elem *rep = reg_move_replaces;\n+\n+      reg_move_replaces = reg_move_replaces->next;\n+      free (rep);\n+    }\n }\n \n /* Bump the SCHED_TIMEs of all nodes to start from zero.  Set the values\n@@ -601,6 +682,25 @@ permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n \t\t\t    PREV_INSN (last));\n }\n \n+/* As part of undoing SMS we return to the original ordering of the\n+   instructions inside the loop kernel.  Given the partial schedule PS, this\n+   function returns the ordering of the instruction according to their CUID\n+   in the DDG (PS->G), which is the original order of the instruction before\n+   performing SMS.  */\n+static void\n+undo_permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n+{\n+  int i;\n+\n+  for (i = 0 ; i < ps->g->num_nodes; i++)\n+    if (last == ps->g->nodes[i].insn\n+\t|| last == ps->g->nodes[i].first_note)\n+      break;\n+    else if (PREV_INSN (last) != ps->g->nodes[i].insn)\n+      reorder_insns_nobb (ps->g->nodes[i].first_note, ps->g->nodes[i].insn,\n+\t\t\t  PREV_INSN (last));\n+}\n+\n /* Used to generate the prologue & epilogue.  Duplicate the subset of\n    nodes whose stages are between FROM_STAGE and TO_STAGE (inclusive\n    of both), together with a prefix/suffix of their reg_moves.  */\n@@ -657,7 +757,6 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \n \tfor (j = 0; j < i_reg_moves; j++, reg_move = NEXT_INSN (reg_move))\n \t  emit_insn (copy_rtx (PATTERN (reg_move)));\n-\n \tif (SCHED_STAGE (u_node) >= from_stage\n \t    && SCHED_STAGE (u_node) <= to_stage)\n \t  duplicate_insn_chain (u_node->first_note, u_node->insn);\n@@ -667,39 +766,27 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \n /* Generate the instructions (including reg_moves) for prolog & epilog.  */\n static void\n-generate_prolog_epilog (partial_schedule_ptr ps, rtx orig_loop_beg,\n-\t\t\trtx orig_loop_end, int unknown_count)\n+generate_prolog_epilog (partial_schedule_ptr ps, struct loop * loop, rtx count_reg)\n {\n   int i;\n   int last_stage = PS_STAGE_COUNT (ps) - 1;\n   edge e;\n-  rtx c_reg = NULL_RTX;\n-  rtx cmp = NULL_RTX;\n-  rtx precond_jump = NULL_RTX;\n-  rtx precond_exit_label = NULL_RTX;\n-  rtx precond_exit_label_insn = NULL_RTX;\n-  rtx last_epilog_insn = NULL_RTX;\n-  rtx loop_exit_label = NULL_RTX;\n-  rtx loop_exit_label_insn = NULL_RTX;\n-  rtx orig_loop_bct = NULL_RTX;\n-\n-  /* Loop header edge.  */\n-  e = EDGE_PRED (ps->g->bb, 0);\n-  if (e->src == ps->g->bb)\n-    e = EDGE_PRED (ps->g->bb, 1);\n \n   /* Generate the prolog, inserting its insns on the loop-entry edge.  */\n   start_sequence ();\n \n-  /* This is the place where we want to insert the precondition.  */\n-  if (unknown_count)\n-    precond_jump = emit_note (NOTE_INSN_DELETED);\n+  if (count_reg)\n+   /* Generate a subtract instruction at the beginning of the prolog to\n+      adjust the loop count by STAGE_COUNT.  */\n+   emit_insn (gen_sub2_insn (count_reg, GEN_INT (last_stage)));\n \n   for (i = 0; i < last_stage; i++)\n     duplicate_insns_of_cycles (ps, 0, i, 1);\n \n-  /* No need to call insert_insn_on_edge; we prepared the sequence.  */\n-  e->insns.r = get_insns ();\n+  /* Put the prolog ,  on the one and only entry edge.  */\n+  e = loop_preheader_edge (loop);\n+  loop_split_edge_with(e , get_insns());\n+\n   end_sequence ();\n \n   /* Generate the epilog, inserting its insns on the loop-exit edge.  */\n@@ -708,107 +795,179 @@ generate_prolog_epilog (partial_schedule_ptr ps, rtx orig_loop_beg,\n   for (i = 0; i < last_stage; i++)\n     duplicate_insns_of_cycles (ps, i + 1, last_stage, 0);\n \n-  last_epilog_insn = emit_note (NOTE_INSN_DELETED);\n+  /* Put the epilogue on the one and only one exit edge.  */\n+  gcc_assert (loop->single_exit);\n+  e = loop->single_exit;\n+  loop_split_edge_with(e , get_insns());\n+  end_sequence ();\n+}\n+\n+/* Return the line note insn preceding INSN, for debugging.  Taken from\n+   emit-rtl.c.  */\n+static rtx\n+find_line_note (rtx insn)\n+{\n+  for (; insn; insn = PREV_INSN (insn))\n+    if (NOTE_P (insn)\n+\t&& NOTE_LINE_NUMBER (insn) >= 0)\n+      break;\n+\n+  return insn;\n+}\n \n-  /* Emit the label where to put the original loop code.  */\n-  if (unknown_count)\n+/* Return true if all the BBs of the loop are empty except the\n+   loop header.  */\n+static bool\n+loop_single_full_bb_p (struct loop *loop)\n+{\n+  unsigned i;\n+  basic_block *bbs = get_loop_body (loop);\n+\n+  for (i = 0; i < loop->num_nodes ; i++)\n     {\n-      rtx label, cond;\n+      rtx head, tail;\n+      bool empty_bb = true;\n+\n+      if (bbs[i] == loop->header)\n+        continue;\n+\n+      /* Make sure that basic blocks other than the header\n+         have only notes labels or jumps.  */\n+      get_block_head_tail (bbs[i]->index, &head, &tail);\n+      for (; head != NEXT_INSN (tail); head = NEXT_INSN (head))\n+        {\n+          if (NOTE_P (head) || LABEL_P (head)\n+ \t      || (INSN_P (head) && JUMP_P (head)))\n+ \t    continue;\n+ \t  empty_bb = false;\n+ \t  break;\n+        }\n+\n+      if (! empty_bb)\n+        {\n+          free (bbs);\n+          return false;\n+        }\n+    }\n+  free (bbs);\n+  return true;\n+}\n \n-      precond_exit_label = gen_label_rtx ();\n-      precond_exit_label_insn = emit_label (precond_exit_label);\n+/* A simple loop from SMS point of view; it is a loop that is composed of\n+   either a single basic block or two BBs - a header and a latch.  */\n+#define SIMPLE_SMS_LOOP_P(loop) ((loop->num_nodes < 3 ) \t\t    \\\n+\t\t\t\t  && (EDGE_COUNT (loop->latch->preds) == 1) \\\n+                                  && (EDGE_COUNT (loop->latch->succs) == 1))\n \n-      /* Put the original loop code.  */\n-      reorder_insns_nobb (orig_loop_beg, orig_loop_end, precond_exit_label_insn);\n+/* Return true if the loop is in its canonical form and false if not.\n+   i.e. SIMPLE_SMS_LOOP_P and have one preheader block, and single exit.  */\n+static bool\n+loop_canon_p (struct loop *loop, FILE *dump_file)\n+{\n \n-      /* Change the label of the BCT to be the PRECOND_EXIT_LABEL.  */\n-      orig_loop_bct = get_last_insn ();\n-      c_reg = doloop_register_get (orig_loop_bct, &cmp);\n-      label = XEXP (SET_SRC (cmp), 1);\n-      cond = XEXP (SET_SRC (cmp), 0);\n+  if (loop->inner || ! loop->outer)\n+    return false;\n \n-      if (! c_reg || GET_CODE (cond) != NE)\n-        abort ();\n+  if (!loop->single_exit)\n+    {\n+      if (dump_file)\n+\t{\n+\t  rtx line_note = find_line_note (BB_END (loop->header));\n \n-      XEXP (label, 0) = precond_exit_label;\n-      JUMP_LABEL (orig_loop_bct) = precond_exit_label_insn;\n-      LABEL_NUSES (precond_exit_label_insn)++;\n+\t  fprintf (dump_file, \"SMS loop many exits \");\n+\t  if (line_note)\n+\t    {\n+\t      expanded_location xloc;\n+\t      NOTE_EXPANDED_LOCATION (xloc, line_note);\n+\t      fprintf (stats_file, \" %s %d (file, line)\\n\",\n+\t\t       xloc.file, xloc.line);\n+\t    }\n+\t}\n+      return false;\n+    }\n \n-      /* Generate the loop exit label.  */\n-      loop_exit_label = gen_label_rtx ();\n-      loop_exit_label_insn = emit_label (loop_exit_label);\n+  if (! SIMPLE_SMS_LOOP_P (loop) && ! loop_single_full_bb_p (loop))\n+    {\n+      if (dump_file)\n+\t{\n+\t  rtx line_note = find_line_note (BB_END (loop->header));\n+\n+\t  fprintf (dump_file, \"SMS loop many BBs. \");\n+\t  if (line_note)\n+\t    {\n+\t      expanded_location xloc;\n+  \t      NOTE_EXPANDED_LOCATION (xloc, line_note);\n+\t      fprintf (stats_file, \" %s %d (file, line)\\n\",\n+\t\t       xloc.file, xloc.line);\n+\t    }\n+\t}\n+      return false;\n     }\n \n-  e = EDGE_SUCC (ps->g->bb, 0);\n-  if (e->dest == ps->g->bb)\n-    e = EDGE_SUCC (ps->g->bb, 1);\n+    return true;\n+}\n \n-  e->insns.r = get_insns ();\n-  end_sequence ();\n+/* If there are more than one entry for the loop,\n+   make it one by splitting the first entry edge and\n+   redirecting the others to the new BB.  */\n+static void\n+canon_loop (struct loop *loop)\n+{\n+  edge e;\n+  edge_iterator i;\n \n-  commit_edge_insertions ();\n+  /* Avoid annoying special cases of edges going to exit\n+     block.  */\n+  FOR_EACH_EDGE (e, i, EXIT_BLOCK_PTR->preds)\n+    if ((e->flags & EDGE_FALLTHRU) && (EDGE_COUNT (e->src->succs) > 1))\n+      loop_split_edge_with (e, NULL_RTX);\n \n-  if (unknown_count)\n+  if (loop->latch == loop->header\n+      || EDGE_COUNT (loop->latch->succs) > 1)\n     {\n-      rtx precond_insns, epilog_jump, insert_after_insn;\n-      basic_block loop_exit_bb = BLOCK_FOR_INSN (loop_exit_label_insn);\n-      basic_block epilog_bb = BLOCK_FOR_INSN (last_epilog_insn);\n-      basic_block precond_bb = BLOCK_FOR_INSN (precond_jump);\n-      basic_block orig_loop_bb = BLOCK_FOR_INSN (precond_exit_label_insn);\n-      edge epilog_exit_edge = single_succ_edge (epilog_bb);\n-\n-      /* Do loop preconditioning to take care of cases were the loop count is\n-\t less than the stage count.  Update the CFG properly.  */\n-      insert_after_insn = precond_jump;\n-      start_sequence ();\n-      c_reg = doloop_register_get (ps->g->closing_branch->insn, &cmp);\n-      emit_cmp_and_jump_insns (c_reg, GEN_INT (PS_STAGE_COUNT (ps)), LT, NULL,\n-      \t\t\t       GET_MODE (c_reg), 1, precond_exit_label);\n-      precond_insns = get_insns ();\n-      precond_jump = get_last_insn ();\n-      end_sequence ();\n-      reorder_insns (precond_insns, precond_jump, insert_after_insn);\n-\n-      /* Generate a subtract instruction at the beginning of the prolog to\n-\t adjust the loop count by STAGE_COUNT.  */\n-      emit_insn_after (gen_sub2_insn (c_reg, GEN_INT (PS_STAGE_COUNT (ps) - 1)),\n-                       precond_jump);\n-      update_bb_for_insn (precond_bb);\n-      delete_insn (insert_after_insn);\n-\n-      /* Update label info for the precondition jump.  */\n-      JUMP_LABEL (precond_jump) = precond_exit_label_insn;\n-      LABEL_NUSES (precond_exit_label_insn)++;\n-\n-      /* Update the CFG.  */\n-      split_block (precond_bb, precond_jump);\n-      make_edge (precond_bb, orig_loop_bb, 0);\n-\n-      /* Add a jump at end of the epilog to the LOOP_EXIT_LABEL to jump over the\n-\t original loop copy and update the CFG.  */\n-      epilog_jump = emit_jump_insn_after (gen_jump (loop_exit_label),\n-      \t\t\t\t\t  last_epilog_insn);\n-      delete_insn (last_epilog_insn);\n-      JUMP_LABEL (epilog_jump) = loop_exit_label_insn;\n-      LABEL_NUSES (loop_exit_label_insn)++;\n-\n-      redirect_edge_succ (epilog_exit_edge, loop_exit_bb);\n-      epilog_exit_edge->flags &= ~EDGE_FALLTHRU;\n-      emit_barrier_after (BB_END (epilog_bb));\n+      FOR_EACH_EDGE (e, i, loop->header->preds)\n+        if (e->src == loop->latch)\n+          break;\n+      loop_split_edge_with (e, NULL_RTX);\n     }\n }\n \n-/* Return the line note insn preceding INSN, for debugging.  Taken from\n-   emit-rtl.c.  */\n-static rtx\n-find_line_note (rtx insn)\n+/* Build the loop information without loop\n+   canonization, the loop canonization will\n+   be perfromed if the loop is SMSable.  */\n+static struct loops *\n+build_loops_structure (FILE *dumpfile)\n {\n-  for (; insn; insn = PREV_INSN (insn))\n-    if (NOTE_P (insn)\n-\t&& NOTE_LINE_NUMBER (insn) >= 0)\n-      break;\n+  struct loops *loops = xcalloc (1, sizeof (struct loops));\n \n-  return insn;\n+  /* Find the loops.  */\n+\n+  if (flow_loops_find (loops) <= 1)\n+    {\n+      /* No loops.  */\n+      flow_loops_free (loops);\n+      free (loops);\n+\n+      return NULL;\n+    }\n+\n+  /* Not going to update these.  */\n+  free (loops->cfg.rc_order);\n+  loops->cfg.rc_order = NULL;\n+  free (loops->cfg.dfs_order);\n+  loops->cfg.dfs_order = NULL;\n+\n+  create_preheaders (loops, CP_SIMPLE_PREHEADERS);\n+  mark_single_exit_loops (loops);\n+  /* Dump loops.  */\n+  flow_loops_dump (loops, dumpfile, NULL, 1);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_dominators (CDI_DOMINATORS);\n+  verify_loop_structure (loops);\n+#endif\n+\n+  return loops;\n }\n \n /* Main entry point, perform SMS scheduling on the loops of the function\n@@ -819,13 +978,22 @@ sms_schedule (FILE *dump_file)\n   static int passes = 0;\n   rtx insn;\n   ddg_ptr *g_arr, g;\n-  basic_block bb, pre_header = NULL;\n   int * node_order;\n   int maxii;\n-  int i;\n+  unsigned i,num_loops;\n   partial_schedule_ptr ps;\n-  int max_bb_index = last_basic_block;\n   struct df *df;\n+  struct loops *loops;\n+  basic_block bb = NULL;\n+  /* vars to the versioning only if needed*/\n+  struct loop * nloop;\n+  basic_block condition_bb = NULL;\n+  edge latch_edge;\n+  gcov_type trip_count = 0;\n+\n+  if (! (loops = build_loops_structure (dump_file)))\n+    return;  /* There is no loops to schedule.  */\n+\n \n   stats_file = dump_file;\n \n@@ -849,58 +1017,47 @@ sms_schedule (FILE *dump_file)\n   df = df_init ();\n   df_analyze (df, 0, DF_ALL);\n \n-  /* Allocate memory to hold the DDG array.  */\n-  g_arr = xcalloc (max_bb_index, sizeof (ddg_ptr));\n+  /* Allocate memory to hold the DDG array one entry for each loop.\n+     We use loop->num as index into this array.  */\n+  g_arr = xcalloc (loops->num, sizeof (ddg_ptr));\n+\n \n   /* Build DDGs for all the relevant loops and hold them in G_ARR\n-     indexed by the loop BB index.  */\n-  FOR_EACH_BB (bb)\n+     indexed by the loop index.  */\n+  for (i = 0; i < loops->num; i++)\n     {\n       rtx head, tail;\n       rtx count_reg, comp;\n-      edge e, pre_header_edge;\n-\n-      if (bb->index < 0)\n-\tcontinue;\n+      struct loop *loop = loops->parray[i];\n \n-      /* Check if bb has two successors, one being itself.  */\n-      if (EDGE_COUNT (bb->succs) != 2)\n-\tcontinue;\n-\n-      if (EDGE_SUCC (bb, 0)->dest != bb && EDGE_SUCC (bb, 1)->dest != bb)\n-\tcontinue;\n-\n-      if ((EDGE_SUCC (bb, 0)->flags & EDGE_COMPLEX)\n-\t  || (EDGE_SUCC (bb, 1)->flags & EDGE_COMPLEX))\n-\tcontinue;\n+      /* For debugging.  */\n+      if ((passes++ > MAX_SMS_LOOP_NUMBER) && (MAX_SMS_LOOP_NUMBER != -1))\n+        {\n+          if (dump_file)\n+            fprintf (dump_file, \"SMS reached MAX_PASSES... \\n\");\n \n-      /* Check if bb has two predecessors, one being itself.  */\n-      if (EDGE_COUNT (bb->preds) != 2)\n-\tcontinue;\n+          break;\n+        }\n \n-      if (EDGE_PRED (bb, 0)->src != bb && EDGE_PRED (bb, 1)->src != bb)\n-\tcontinue;\n+      if (! loop_canon_p (loop, dump_file))\n+        continue;\n \n-      if ((EDGE_PRED (bb, 0)->flags & EDGE_COMPLEX)\n-\t  || (EDGE_PRED (bb, 1)->flags & EDGE_COMPLEX))\n+      if (! loop_single_full_bb_p (loop))\n \tcontinue;\n \n-      /* For debugging.  */\n-      if ((passes++ > MAX_SMS_LOOP_NUMBER) && (MAX_SMS_LOOP_NUMBER != -1))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"SMS reached MAX_PASSES... \\n\");\n-\t  break;\n-\t}\n+      bb = loop->header;\n \n       get_block_head_tail (bb->index, &head, &tail);\n-      pre_header_edge = EDGE_PRED (bb, 0);\n-      if (EDGE_PRED (bb, 0)->src != bb)\n-\tpre_header_edge = EDGE_PRED (bb, 1);\n+      latch_edge = loop_latch_edge (loop);\n+      gcc_assert (loop->single_exit);\n+      if (loop->single_exit->count)\n+\ttrip_count = latch_edge->count / loop->single_exit->count;\n \n       /* Perfrom SMS only on loops that their average count is above threshold.  */\n-      if (bb->count < pre_header_edge->count * SMS_LOOP_AVERAGE_COUNT_THRESHOLD)\n-        {\n+\n+      if ( latch_edge->count\n+          && (latch_edge->count < loop->single_exit->count * SMS_LOOP_AVERAGE_COUNT_THRESHOLD))\n+\t{\n \t  if (stats_file)\n \t    {\n \t      rtx line_note = find_line_note (tail);\n@@ -919,10 +1076,10 @@ sms_schedule (FILE *dump_file)\n \t      \t  fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n \t             \t   (HOST_WIDEST_INT) bb->count);\n \t      \t  fprintf (stats_file, \"\\n\");\n-\t      \t  fprintf (stats_file, \"SMS preheader-count \");\n-\t      \t  fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n-\t           \t   (HOST_WIDEST_INT) pre_header_edge->count);\n-\t      \t  fprintf (stats_file, \"\\n\");\n+                  fprintf (stats_file, \"SMS trip-count \");\n+                  fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n+                           (HOST_WIDEST_INT) trip_count);\n+                  fprintf (stats_file, \"\\n\");\n \t      \t  fprintf (stats_file, \"SMS profile-sum-max \");\n \t      \t  fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n \t          \t   (HOST_WIDEST_INT) profile_info->sum_max);\n@@ -936,12 +1093,6 @@ sms_schedule (FILE *dump_file)\n       if ( !(count_reg = doloop_register_get (tail, &comp)))\n \tcontinue;\n \n-      e = EDGE_PRED (bb, 0);\n-      if (e->src == bb)\n-\tpre_header = EDGE_PRED (bb, 1)->src;\n-      else\n-\tpre_header = e->src;\n-\n       /* Don't handle BBs with calls or barriers, or !single_set insns.  */\n       for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n \tif (CALL_P (insn)\n@@ -973,33 +1124,36 @@ sms_schedule (FILE *dump_file)\n \t  continue;\n         }\n \n-      g_arr[bb->index] = g;\n+      g_arr[i] = g;\n     }\n \n   /* Release Data Flow analysis data structures.  */\n   df_finish (df);\n \n+  /* We don't want to perform SMS on new loops - created by versioning.  */\n+  num_loops = loops->num;\n   /* Go over the built DDGs and perfrom SMS for each one of them.  */\n-  for (i = 0; i < max_bb_index; i++)\n+  for (i = 0; i < num_loops; i++)\n     {\n       rtx head, tail;\n       rtx count_reg, count_init, comp;\n-      edge pre_header_edge;\n       int mii, rec_mii;\n-      int stage_count = 0;\n+      unsigned stage_count = 0;\n       HOST_WIDEST_INT loop_count = 0;\n+      struct loop *loop = loops->parray[i];\n \n       if (! (g = g_arr[i]))\n         continue;\n \n       if (dump_file)\n \tprint_ddg (dump_file, g);\n \n-      get_block_head_tail (g->bb->index, &head, &tail);\n+      get_block_head_tail (loop->header->index, &head, &tail);\n \n-      pre_header_edge = EDGE_PRED (g->bb, 0);\n-      if (EDGE_PRED (g->bb, 0)->src != g->bb)\n-\tpre_header_edge = EDGE_PRED (g->bb, 1);\n+      latch_edge = loop_latch_edge (loop);\n+      gcc_assert (loop->single_exit);\n+      if (loop->single_exit->count)\n+\ttrip_count = latch_edge->count / loop->single_exit->count;\n \n       if (stats_file)\n \t{\n@@ -1019,10 +1173,6 @@ sms_schedule (FILE *dump_file)\n \t      fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n \t               (HOST_WIDEST_INT) bb->count);\n \t      fprintf (stats_file, \"\\n\");\n-\t      fprintf (stats_file, \"SMS preheader-count \");\n-\t      fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n-\t               (HOST_WIDEST_INT) pre_header_edge->count);\n-\t      fprintf (stats_file, \"\\n\");\n \t      fprintf (stats_file, \"SMS profile-sum-max \");\n \t      fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n \t               (HOST_WIDEST_INT) profile_info->sum_max);\n@@ -1034,17 +1184,25 @@ sms_schedule (FILE *dump_file)\n           fprintf (stats_file, \"SMS num-stores %d\\n\", g->num_stores);\n \t}\n \n-      /* Make sure this is a doloop.  */\n-      if ( !(count_reg = doloop_register_get (tail, &comp)))\n-\tabort ();\n \n-      /* This should be NULL_RTX if the count is unknown at compile time.  */\n-      count_init = const_iteration_count (count_reg, pre_header, &loop_count);\n+      /* In case of th loop have doloop register it gets special\n+\t handling.  */\n+      count_init = NULL_RTX;\n+      if ((count_reg = doloop_register_get (tail, &comp)))\n+\t{\n+\t  basic_block pre_header;\n+\n+\t  pre_header = loop_preheader_edge (loop)->src;\n+\t  count_init = const_iteration_count (count_reg, pre_header,\n+\t\t\t\t\t      &loop_count);\n+\t}\n+      gcc_assert (count_reg);\n \n       if (stats_file && count_init)\n         {\n           fprintf (stats_file, \"SMS const-doloop \");\n-          fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC, loop_count);\n+          fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n+\t\t     loop_count);\n           fprintf (stats_file, \"\\n\");\n         }\n \n@@ -1068,46 +1226,40 @@ sms_schedule (FILE *dump_file)\n       if (ps)\n \tstage_count = PS_STAGE_COUNT (ps);\n \n-      if (stage_count == 0 || (count_init && (stage_count > loop_count)))\n+      /* Stage count of 1 means that there is no interleaving between\n+         iterations, let the scheduling passes do the job.  */\n+      if (stage_count < 1\n+\t  || (count_init && (loop_count <= stage_count))\n+\t  || (flag_branch_probabilities && (trip_count <= stage_count)))\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"SMS failed... \\n\");\n-\t  if (stats_file)\n-\t    fprintf (stats_file, \"SMS sched-failed %d\\n\", stage_count);\n+\t    {\n+\t      fprintf (dump_file, \"SMS failed... \\n\");\n+\t      fprintf (dump_file, \"SMS sched-failed (stage-count=%d, loop-count=\", stage_count);\n+\t      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, loop_count);\n+\t      fprintf (dump_file, \", trip-count=\");\n+\t      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, trip_count);\n+\t      fprintf (dump_file, \")\\n\");\n+\t    }\n+\t  continue;\n \t}\n       else\n \t{\n-          rtx orig_loop_beg = NULL_RTX;\n-\t  rtx orig_loop_end = NULL_RTX;\n+\t  int orig_cycles = kernel_number_of_cycles (BB_HEAD (g->bb), BB_END (g->bb));\n+\t  int new_cycles;\n+\t  struct undo_replace_buff_elem *reg_move_replaces;\n \n \t  if (stats_file)\n \t    {\n \t      fprintf (stats_file,\n \t\t       \"SMS succeeded %d %d (with ii, sc)\\n\", ps->ii,\n \t\t       stage_count);\n-\t      print_partial_schedule (ps, dump_file);\n-\t      fprintf (dump_file,\n+\t      print_partial_schedule (ps, stats_file);\n+\t      fprintf (stats_file,\n \t\t       \"SMS Branch (%d) will later be scheduled at cycle %d.\\n\",\n \t\t       g->closing_branch->cuid, PS_MIN_CYCLE (ps) - 1);\n \t    }\n \n-          /* Save the original loop if we want to do loop preconditioning in\n-\t     case the BCT count is not known.  */\n-          if (! count_init)\n-            {\n-\t      int i;\n-\n-              start_sequence ();\n-\t      /* Copy the original loop code before modifying it -\n-\t \t so we can use it later.  */\n-\t      for (i = 0; i < ps->g->num_nodes; i++)\n-\t\tduplicate_insn_chain (ps->g->nodes[i].first_note,\n-\t\t\t\t      ps->g->nodes[i].insn);\n-\n-\t      orig_loop_beg = get_insns ();\n-              orig_loop_end = get_last_insn ();\n-\t      end_sequence ();\n-            }\n \t  /* Set the stage boundaries.  If the DDG is built with closing_branch_deps,\n \t     the closing_branch was scheduled and should appear in the last (ii-1)\n \t     row.  Otherwise, we are free to schedule the branch, and we let nodes\n@@ -1117,28 +1269,66 @@ sms_schedule (FILE *dump_file)\n \t  rotate_partial_schedule (ps, PS_MIN_CYCLE (ps));\n \t  set_columns_for_ps (ps);\n \n+\t  /* Generate the kernel just to be able to measure its cycles.  */\n \t  permute_partial_schedule (ps, g->closing_branch->first_note);\n+\t  reg_move_replaces = generate_reg_moves (ps);\n \n-          /* Mark this loop as software pipelined so the later\n-\t     scheduling passes doesn't touch it.  */\n-\t  if (! flag_resched_modulo_sched)\n-\t    g->bb->flags |= BB_DISABLE_SCHEDULE;\n-\t  /* The life-info is not valid any more.  */\n-\t  g->bb->flags |= BB_DIRTY;\n+\t  /* Get the number of cycles the new kernel expect to execute in.  */\n+\t  new_cycles = kernel_number_of_cycles (BB_HEAD (g->bb), BB_END (g->bb));\n \n-\t  generate_reg_moves (ps);\n-\t  if (dump_file)\n-\t    print_node_sched_params (dump_file, g->num_nodes);\n+\t  /* Get back to the original loop so we can do loop versioning.  */\n+\t  undo_permute_partial_schedule (ps, g->closing_branch->first_note);\n+\t  if (reg_move_replaces)\n+\t    undo_generate_reg_moves (ps, reg_move_replaces);\n+\n+\t  if ( new_cycles >= orig_cycles)\n+\t    {\n+\t      /* SMS is not profitable so undo the permutation and reg move generation\n+\t         and return the kernel to its original state.  */\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Undoing SMS becuase it is not profitable.\\n\");\n+\n+\t    }\n+\t  else\n+\t    {\n+\t      canon_loop (loop);\n+\n+              /* case the BCT count is not known , Do loop-versioning */\n+\t      if (count_reg && ! count_init)\n+\t\t{\n+\t\t  rtx comp_rtx = gen_rtx_fmt_ee (GT, VOIDmode, count_reg,\n+\t\t\t\t\t\t GEN_INT(stage_count));\n \n-\t  /* Set new iteration count of loop kernel.  */\n-          if (count_init)\n-\t    SET_SRC (single_set (count_init)) = GEN_INT (loop_count\n-                                                         - stage_count + 1);\n+\t\t  nloop = loop_version (loops, loop, comp_rtx, &condition_bb);\n+\t\t}\n \n-\t  /* Generate prolog and epilog.  */\n-\t  generate_prolog_epilog (ps, orig_loop_beg, orig_loop_end,\n-\t\t\t\t  count_init ? 0 : 1);\n+\t      /* Set new iteration count of loop kernel.  */\n+              if (count_reg && count_init)\n+\t\tSET_SRC (single_set (count_init)) = GEN_INT (loop_count\n+\t\t\t\t\t\t\t     - stage_count + 1);\n+\n+\t      /* Now apply the scheduled kernel to the RTL of the loop.  */\n+\t      permute_partial_schedule (ps, g->closing_branch->first_note);\n+\n+              /* Mark this loop as software pipelined so the later\n+\t      scheduling passes doesn't touch it.  */\n+\t      if (! flag_resched_modulo_sched)\n+\t\tg->bb->flags |= BB_DISABLE_SCHEDULE;\n+\t      /* The life-info is not valid any more.  */\n+\t      g->bb->flags |= BB_DIRTY;\n+\n+\t      reg_move_replaces = generate_reg_moves (ps);\n+\t      if (dump_file)\n+\t\tprint_node_sched_params (dump_file, g->num_nodes);\n+\t      /* Generate prolog and epilog.  */\n+\t      if (count_reg && !count_init)\n+\t\tgenerate_prolog_epilog (ps, loop, count_reg);\n+\t      else\n+\t \tgenerate_prolog_epilog (ps, loop, NULL_RTX);\n+\t    }\n+\t  free_undo_replace_buff (reg_move_replaces);\n \t}\n+\n       free_partial_schedule (ps);\n       free (node_sched_params);\n       free (node_order);\n@@ -1147,6 +1337,7 @@ sms_schedule (FILE *dump_file)\n \n   /* Release scheduler data, needed until now because of DFA.  */\n   sched_finish ();\n+  loop_optimizer_finalize (loops, dump_file);\n }\n \n /* The SMS scheduling algorithm itself\n@@ -1225,6 +1416,140 @@ sms_schedule (FILE *dump_file)\n    set to 0 to save compile time.  */\n #define DFA_HISTORY SMS_DFA_HISTORY\n \n+/* Given the partial schedule PS, this function calculates and returns the\n+   cycles in wich we can schedule the node with the given index I.\n+   NOTE: Here we do the backtracking in SMS, in some special cases. We have\n+   noticed that there are several cases in which we fail    to SMS the loop\n+   because the sched window of a node is empty    due to tight data-deps. In\n+   such cases we want to unschedule    some of the predecssors/successors\n+   until we get non-empty    scheduling window.  It returns -1 if the\n+   scheduling window is empty and zero otherwise.  */\n+\n+static int\n+get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n+\t\t  sbitmap sched_nodes, int ii, int *start_p, int *step_p, int *end_p)\n+{\n+  int start, step, end;\n+  ddg_edge_ptr e;\n+  int u = nodes_order [i];\n+  ddg_node_ptr u_node = &ps->g->nodes[u];\n+  sbitmap psp = sbitmap_alloc (ps->g->num_nodes);\n+  sbitmap pss = sbitmap_alloc (ps->g->num_nodes);\n+  sbitmap u_node_preds = NODE_PREDECESSORS (u_node);\n+  sbitmap u_node_succs = NODE_SUCCESSORS (u_node);\n+  int psp_not_empty;\n+  int pss_not_empty;\n+\n+  /* 1. compute sched window for u (start, end, step).  */\n+  sbitmap_zero (psp);\n+  sbitmap_zero (pss);\n+  psp_not_empty = sbitmap_a_and_b_cg (psp, u_node_preds, sched_nodes);\n+  pss_not_empty = sbitmap_a_and_b_cg (pss, u_node_succs, sched_nodes);\n+\n+  if (psp_not_empty && !pss_not_empty)\n+    {\n+      int early_start = INT_MIN;\n+\n+      end = INT_MAX;\n+      for (e = u_node->in; e != 0; e = e->next_in)\n+\t{\n+\t  ddg_node_ptr v_node = e->src;\n+\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n+\t    {\n+\t      int node_st = SCHED_TIME (v_node)\n+\t      \t\t    + e->latency - (e->distance * ii);\n+\n+\t      early_start = MAX (early_start, node_st);\n+\n+\t      if (e->data_type == MEM_DEP)\n+\t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n+\t    }\n+\t}\n+      start = early_start;\n+      end = MIN (end, early_start + ii);\n+      step = 1;\n+    }\n+\n+  else if (!psp_not_empty && pss_not_empty)\n+    {\n+      int late_start = INT_MAX;\n+\n+      end = INT_MIN;\n+      for (e = u_node->out; e != 0; e = e->next_out)\n+\t{\n+\t  ddg_node_ptr v_node = e->dest;\n+\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n+\t    {\n+\t      late_start = MIN (late_start,\n+\t\t\t\tSCHED_TIME (v_node) - e->latency\n+\t\t\t\t+ (e->distance * ii));\n+\t      if (e->data_type == MEM_DEP)\n+\t\tend = MAX (end, SCHED_TIME (v_node) - ii + 1);\n+\t    }\n+\t}\n+      start = late_start;\n+      end = MAX (end, late_start - ii);\n+      step = -1;\n+    }\n+\n+  else if (psp_not_empty && pss_not_empty)\n+    {\n+      int early_start = INT_MIN;\n+      int late_start = INT_MAX;\n+\n+      start = INT_MIN;\n+      end = INT_MAX;\n+      for (e = u_node->in; e != 0; e = e->next_in)\n+\t{\n+\t  ddg_node_ptr v_node = e->src;\n+\n+\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n+\t    {\n+\t      early_start = MAX (early_start,\n+\t\t\t\t SCHED_TIME (v_node) + e->latency\n+\t\t\t\t - (e->distance * ii));\n+\t      if (e->data_type == MEM_DEP)\n+\t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n+\t    }\n+\t}\n+      for (e = u_node->out; e != 0; e = e->next_out)\n+\t{\n+\t  ddg_node_ptr v_node = e->dest;\n+\n+\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n+\t    {\n+\t      late_start = MIN (late_start,\n+\t\t\t\tSCHED_TIME (v_node) - e->latency\n+\t\t\t\t+ (e->distance * ii));\n+\t      if (e->data_type == MEM_DEP)\n+\t\tstart = MAX (start, SCHED_TIME (v_node) - ii + 1);\n+\t    }\n+\t}\n+      start = MAX (start, early_start);\n+      end = MIN (end, MIN (early_start + ii, late_start + 1));\n+      step = 1;\n+    }\n+  else /* psp is empty && pss is empty.  */\n+    {\n+      start = SCHED_ASAP (u_node);\n+      end = start + ii;\n+      step = 1;\n+    }\n+\n+  *start_p = start;\n+  *step_p = step;\n+  *end_p = end;\n+  sbitmap_free (psp);\n+  sbitmap_free (pss);\n+\n+  if ((start >= end && step == 1) || (start <= end && step == -1))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* This function implements the scheduling algorithm for SMS according to the\n+   above algorithm.  */\n static partial_schedule_ptr\n sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order, FILE *dump_file)\n {\n@@ -1237,126 +1562,70 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order, FILE *du\n   sbitmap sched_nodes = sbitmap_alloc (num_nodes);\n   sbitmap must_precede = sbitmap_alloc (num_nodes);\n   sbitmap must_follow = sbitmap_alloc (num_nodes);\n+  sbitmap tobe_scheduled = sbitmap_alloc (num_nodes);\n \n   partial_schedule_ptr ps = create_partial_schedule (ii, g, DFA_HISTORY);\n \n-  while (try_again_with_larger_ii && ii < maxii)\n+  sbitmap_ones (tobe_scheduled);\n+  sbitmap_zero (sched_nodes);\n+\n+  while ((! sbitmap_equal (tobe_scheduled, sched_nodes)\n+\t || try_again_with_larger_ii ) && ii < maxii)\n     {\n+      int j;\n+      bool unscheduled_nodes = false;\n+\n       if (dump_file)\n \tfprintf(dump_file, \"Starting with ii=%d\\n\", ii);\n-      try_again_with_larger_ii = false;\n-      sbitmap_zero (sched_nodes);\n+      if (try_again_with_larger_ii)\n+\t{\n+\t  try_again_with_larger_ii = false;\n+\t  sbitmap_zero (sched_nodes);\n+\t}\n \n       for (i = 0; i < num_nodes; i++)\n \t{\n \t  int u = nodes_order[i];\n-\t  ddg_node_ptr u_node = &g->nodes[u];\n-\t  sbitmap u_node_preds = NODE_PREDECESSORS (u_node);\n-\t  sbitmap u_node_succs = NODE_SUCCESSORS (u_node);\n-\t  int psp_not_empty;\n-\t  int pss_not_empty;\n+  \t  ddg_node_ptr u_node = &ps->g->nodes[u];\n \t  rtx insn = u_node->insn;\n \n \t  if (!INSN_P (insn))\n-\t    continue;\n-\n-\t  if (JUMP_P (insn)) /* Closing branch handled later.  */\n-\t    continue;\n-\n-\t  /* 1. compute sched window for u (start, end, step).  */\n-\t  psp_not_empty = sbitmap_any_common_bits (u_node_preds, sched_nodes);\n-\t  pss_not_empty = sbitmap_any_common_bits (u_node_succs, sched_nodes);\n-\n-\t  if (psp_not_empty && !pss_not_empty)\n \t    {\n-\t      int early_start = 0;\n-\n-\t      end = INT_MAX;\n-\t      for (e = u_node->in; e != 0; e = e->next_in)\n-\t\t{\n-\t\t  ddg_node_ptr v_node = e->src;\n-\t\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n-\t\t    {\n-                      int node_st = SCHED_TIME (v_node)\n-\t\t      \t\t    + e->latency - (e->distance * ii);\n-\n-\t\t      early_start = MAX (early_start, node_st);\n-\n-\t\t      if (e->data_type == MEM_DEP)\n-\t\t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n-\t\t    }\n-\t\t}\n-\t      start = early_start;\n-\t      end = MIN (end, early_start + ii);\n-\t      step = 1;\n+\t      RESET_BIT (tobe_scheduled, u);\n+\t      continue;\n \t    }\n \n-\t  else if (!psp_not_empty && pss_not_empty)\n+\t  if (JUMP_P (insn)) /* Closing branch handled later.  */\n \t    {\n-\t      int late_start = INT_MAX;\n-\n-\t      end = INT_MIN;\n-\t      for (e = u_node->out; e != 0; e = e->next_out)\n-\t\t{\n-\t\t  ddg_node_ptr v_node = e->dest;\n-\t\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n-\t\t    {\n-\t\t      late_start = MIN (late_start,\n-\t\t\t\t\tSCHED_TIME (v_node) - e->latency\n-\t\t\t\t\t+ (e->distance * ii));\n-\t\t      if (e->data_type == MEM_DEP)\n-\t\t\tend = MAX (end, SCHED_TIME (v_node) - ii + 1);\n-\t\t    }\n-\t\t}\n-\t      start = late_start;\n-\t      end = MAX (end, late_start - ii);\n-\t      step = -1;\n+\t      RESET_BIT (tobe_scheduled, u);\n+\t      continue;\n \t    }\n \n-\t  else if (psp_not_empty && pss_not_empty)\n-\t    {\n-\t      int early_start = 0;\n-\t      int late_start = INT_MAX;\n+\t  if (TEST_BIT (sched_nodes, u))\n+\t    continue;\n \n-\t      start = INT_MIN;\n-\t      end = INT_MAX;\n-\t      for (e = u_node->in; e != 0; e = e->next_in)\n-\t\t{\n-\t\t  ddg_node_ptr v_node = e->src;\n-\n-\t\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n-\t\t    {\n-\t\t      early_start = MAX (early_start,\n-\t\t\t\t\t SCHED_TIME (v_node) + e->latency\n-\t\t\t\t\t - (e->distance * ii));\n-\t\t      if (e->data_type == MEM_DEP)\n-\t\t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n-\t\t    }\n-\t\t}\n-\t      for (e = u_node->out; e != 0; e = e->next_out)\n+\t  /* Try to get non-empty scheduling window.  */\n+\t  j = i;\n+\t  while (get_sched_window (ps, nodes_order, i, sched_nodes, ii, &start, &step, &end) < 0\n+\t\t && j > 0)\n+\t    {\n+\t      unscheduled_nodes = true;\n+\t      if (TEST_BIT (NODE_PREDECESSORS (u_node), nodes_order[j - 1])\n+\t\t  || TEST_BIT (NODE_SUCCESSORS (u_node), nodes_order[j - 1]))\n \t\t{\n-\t\t  ddg_node_ptr v_node = e->dest;\n-\n-\t\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n-\t\t    {\n-\t\t      late_start = MIN (late_start,\n-\t\t\t\t\tSCHED_TIME (v_node) - e->latency\n-\t\t\t\t\t+ (e->distance * ii));\n-\t\t      if (e->data_type == MEM_DEP)\n-\t\t\tstart = MAX (start, SCHED_TIME (v_node) - ii + 1);\n-\t\t    }\n+\t\t  ps_unschedule_node (ps, &ps->g->nodes[nodes_order[j - 1]]);\n+\t\t  RESET_BIT (sched_nodes, nodes_order [j - 1]);\n \t\t}\n-\t      start = MAX (start, early_start);\n-\t      end = MIN (end, MIN (early_start + ii, late_start + 1));\n-\t      step = 1;\n+\t      j--;\n \t    }\n-\t  else /* psp is empty && pss is empty.  */\n+\t  if (j < 0)\n \t    {\n-\t      start = SCHED_ASAP (u_node);\n-\t      end = start + ii;\n-\t      step = 1;\n+\t      /* ??? Try backtracking instead of immediately ii++?  */\n+\t      ii++;\n+\t      try_again_with_larger_ii = true;\n+\t      reset_partial_schedule (ps, ii);\n+\t      break;\n \t    }\n-\n \t  /* 2. Try scheduling u in window.  */\n \t  if (dump_file)\n \t    fprintf(dump_file, \"Trying to schedule node %d in (%d .. %d) step %d\\n\",\n@@ -1406,6 +1675,9 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order, FILE *du\n \t      reset_partial_schedule (ps, ii);\n \t      break;\n \t    }\n+\t  if (unscheduled_nodes)\n+\t    break;\n+\n \t  /* ??? If (success), check register pressure estimates.  */\n \t} /* Continue with next node.  */\n     } /* While try_again_with_larger_ii.  */\n@@ -1792,7 +2064,7 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n    modulo scheduling.  */\n \n /* Create a partial schedule and allocate a memory to hold II rows.  */\n-static partial_schedule_ptr\n+partial_schedule_ptr\n create_partial_schedule (int ii, ddg_ptr g, int history)\n {\n   partial_schedule_ptr ps = (partial_schedule_ptr)\n@@ -1828,7 +2100,7 @@ free_ps_insns (partial_schedule_ptr ps)\n }\n \n /* Free all the memory allocated to the partial schedule.  */\n-static void\n+void\n free_partial_schedule (partial_schedule_ptr ps)\n {\n   if (!ps)\n@@ -1840,7 +2112,7 @@ free_partial_schedule (partial_schedule_ptr ps)\n \n /* Clear the rows array with its PS_INSNs, and create a new one with\n    NEW_II rows.  */\n-static void\n+void\n reset_partial_schedule (partial_schedule_ptr ps, int new_ii)\n {\n   if (!ps)\n@@ -1895,7 +2167,7 @@ create_ps_insn (ddg_node_ptr node, int rest_count, int cycle)\n \n /* Removes the given PS_INSN from the partial schedule.  Returns false if the\n    node is not found in the partial schedule, else returns true.  */\n-static int\n+static bool\n remove_node_from_ps (partial_schedule_ptr ps, ps_insn_ptr ps_i)\n {\n   int row;\n@@ -2083,6 +2355,58 @@ advance_one_cycle (void)\n \t\t      (*targetm.sched.dfa_post_cycle_insn) ());\n }\n \n+/* Given the kernel of a loop (from FIRST_INSN to LAST_INSN), finds\n+   the number of cycles according to DFA that the kernel fits in,\n+   we use this to check if we done well with SMS after we add\n+   register moves.  In some cases register moves overhead makes\n+   it even worse than the original loop.  We want SMS to be performed\n+   when it gives less cycles after register moves are added.  */\n+static int\n+kernel_number_of_cycles (rtx first_insn, rtx last_insn)\n+{\n+  int cycles = 0;\n+  rtx insn;\n+  int can_issue_more = issue_rate;\n+\n+  state_reset (curr_state);\n+\n+  for (insn = first_insn;\n+       insn != NULL_RTX && insn != last_insn;\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (! INSN_P (insn) || GET_CODE (PATTERN (insn)) == USE)\n+\tcontinue;\n+\n+      /* Check if there is room for the current insn.  */\n+      if (!can_issue_more || state_dead_lock_p (curr_state))\n+\t{\n+\t  cycles ++;\n+\t  advance_one_cycle ();\n+\t  can_issue_more = issue_rate;\n+\t}\n+\n+\t/* Update the DFA state and return with failure if the DFA found\n+\t   recource conflicts.  */\n+      if (state_transition (curr_state, insn) >= 0)\n+\t{\n+\t  cycles ++;\n+\t  advance_one_cycle ();\n+\t  can_issue_more = issue_rate;\n+\t}\n+\n+      if (targetm.sched.variable_issue)\n+\tcan_issue_more =\n+\t  (*targetm.sched.variable_issue) (sched_dump, sched_verbose,\n+\t\t\t\t\t   insn, can_issue_more);\n+      /* A naked CLOBBER or USE generates no instruction, so don't\n+\t let them consume issue slots.  */\n+      else if (GET_CODE (PATTERN (insn)) != USE\n+\t       && GET_CODE (PATTERN (insn)) != CLOBBER)\n+\tcan_issue_more--;\n+    }\n+  return cycles;\n+}\n+\n /* Checks if PS has resource conflicts according to DFA, starting from\n    FROM cycle to TO cycle; returns true if there are conflicts and false\n    if there are no conflicts.  Assumes DFA is being used.  */\n@@ -2140,7 +2464,7 @@ ps_has_conflicts (partial_schedule_ptr ps, int from, int to)\n    is returned.  Bit N is set in MUST_PRECEDE/MUST_FOLLOW if the node with \n    cuid N must be come before/after (respectively) the node pointed to by \n    PS_I when scheduled in the same cycle.  */\n-static ps_insn_ptr\n+ps_insn_ptr\n ps_add_node_check_conflicts (partial_schedule_ptr ps, ddg_node_ptr n,\n    \t\t\t     int c, sbitmap must_precede,\n \t\t\t     sbitmap must_follow)\n@@ -2185,7 +2509,7 @@ ps_add_node_check_conflicts (partial_schedule_ptr ps, ddg_node_ptr n,\n \n /* Rotate the rows of PS such that insns scheduled at time\n    START_CYCLE will appear in row 0.  Updates max/min_cycles.  */\n-static void\n+void\n rotate_partial_schedule (partial_schedule_ptr ps, int start_cycle)\n {\n   int i, row, backward_rotates;\n@@ -2211,4 +2535,25 @@ rotate_partial_schedule (partial_schedule_ptr ps, int start_cycle)\n   ps->min_cycle -= start_cycle;\n }\n \n+/* Remove the node N from the partial schedule PS; becuase we restart the DFA\n+   each time we want to check for resuorce conflicts; this is equivalent to\n+   unscheduling the node N.  */\n+static bool\n+ps_unschedule_node (partial_schedule_ptr ps, ddg_node_ptr n)\n+{\n+  ps_insn_ptr ps_i;\n+  int row = SMODULO (SCHED_TIME (n), ps->ii);\n+\n+  if (row < 0 || row > ps->ii)\n+    return false;\n+\n+  for (ps_i = ps->rows[row];\n+       ps_i &&  ps_i->node != n;\n+       ps_i = ps_i->next_in_row);\n+  if (!ps_i)\n+    return false;\n+\n+  return remove_node_from_ps (ps, ps_i);\n+}\n #endif /* INSN_SCHEDULING*/\n+"}, {"sha": "40e87a474f001df2088aef835e25c9c5aa69e5c5", "filename": "gcc/passes.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73d56667d8c9b6344e930bac2928a7cca46ab4c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73d56667d8c9b6344e930bac2928a7cca46ab4c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f73d56667d8c9b6344e930bac2928a7cca46ab4c", "patch": "@@ -577,17 +577,19 @@ rest_of_handle_partition_blocks (void)\n static void\n rest_of_handle_sms (void)\n {\n+  basic_block bb;\n   sbitmap blocks;\n \n   timevar_push (TV_SMS);\n   open_dump_file (DFI_sms, current_function_decl);\n \n   /* We want to be able to create new pseudos.  */\n   no_new_pseudos = 0;\n+  /* Collect loop information to be used in SMS.  */\n+  cfg_layout_initialize (CLEANUP_UPDATE_LIFE);\n   sms_schedule (dump_file);\n   close_dump_file (DFI_sms, print_rtl, get_insns ());\n \n-\n   /* Update the life information, because we add pseudos.  */\n   max_regno = max_reg_num ();\n   allocate_reg_info (max_regno, FALSE, FALSE);\n@@ -601,6 +603,12 @@ rest_of_handle_sms (void)\n \n   no_new_pseudos = 1;\n \n+  /* Finalize layout changes.  */\n+  FOR_EACH_BB (bb)\n+    if (bb->next_bb != EXIT_BLOCK_PTR)\n+      bb->rbi->next = bb->next_bb;\n+  cfg_layout_finalize ();\n+  free_dominance_info (CDI_DOMINATORS);\n   ggc_collect ();\n   timevar_pop (TV_SMS);\n }"}]}