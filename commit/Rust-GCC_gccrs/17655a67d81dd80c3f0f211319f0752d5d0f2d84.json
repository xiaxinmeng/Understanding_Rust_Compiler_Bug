{"sha": "17655a67d81dd80c3f0f211319f0752d5d0f2d84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2NTVhNjdkODFkZDgwYzNmMGYyMTEzMTlmMDc1MmQ1ZDBmMmQ4NA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-07-31T17:28:08Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-07-31T17:28:08Z"}, "message": "char_traits.h: Remove generic definitions.\n\n\n2002-07-30  Benjamin Kosnik  <bkoz@redhat.com>\n            Gabriel Dos Reis  <gdr@nerim.net>\n\n\t* include/bits/char_traits.h: Remove generic definitions.\n\t* include/bits/streambuf_iterator.h (istreambuf_iterator): Use\n\teof, not -2.\n\t* include/bits/istream.tcc (istream::readsome): Don't check\n\tagainst eof, instead use constants.\n\t(istream::sync): Same.\n\t(istream::sentry::sentry): Use eq_int_type.\n\t(istream::get): Same.\n\t* include/bits/ostream.tcc: Change __pad to\n\t__pad<_CharT, _Traits>::_S_pad.\n\t* include/bits/locale_facets.h: Add __pad_traits generic and\n\tostreambuf_iterator specialization.\n\t* include/bits/locale_facets.tcc: Change __pad into struct __pad\n\twith a _CharT and _Traits template parameter and _S_pad static\n\tmember function.\n\t* src/locale-inst.cc: Update __pad instantiations.\n\n\t* include/std/std_fstream.h: Declare _M_underflow_common\n\tspecializations.\n\t* src/fstream.cc: New. Add _M_underflow_common specializations.\n\t* include/bits/fstream.tcc (filebuf::close): Use traits_type.\n\t(filebuf::_M_underflow_common(bool)): Remove generic version, as\n\tsys_ungetc and custom int_types don't get along.\n\t* include/std/std_streambuf.h: Add _M_pos.\n\t* src/Makefile.am (sources): Add fstream.cc.\n\t* src/Makefile.in: Regenerate.\n\n\t* testsuite/21_strings/capacity.cc: Add char_traits specializations.\n\t* testsuite/22_locale/codecvt_members_unicode_char.cc: Same.\n\t* testsuite/22_locale/codecvt_members_unicode_wchar_t.cc: Same.\n\t* testsuite/22_locale/ctor_copy_dtor.cc: Same.\n\t* testsuite/27_io/filebuf_virtuals.cc (test07): Move to...\n\t* testsuite/27_io/filebuf.cc: ...here.\n\t* testsuite/testsuite_hooks.h: Add gnu_char, gnu_int, char_traits\n\tspecialization for both.\n\t* testsuite/27_io/streambuf.cc: Add instantiation test,\n\ttestsuite_hooks include.\n\t* testsuite/27_io/istream.cc: Same.\n\t* testsuite/27_io/ostream.cc: Same.\n\t* testsuite/27_io/fstream.cc: Same.\n\t* testsuite/27_io/stringstream.cc: Same.\n\t* testsuite/27_io/filebuf.cc: Same.\n\t* testsuite/27_io/stringbuf.cc: Same.\n\nFrom-SVN: r55905", "tree": {"sha": "30378b039a9d33a145661b9a02218fa208931d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30378b039a9d33a145661b9a02218fa208931d33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17655a67d81dd80c3f0f211319f0752d5d0f2d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17655a67d81dd80c3f0f211319f0752d5d0f2d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17655a67d81dd80c3f0f211319f0752d5d0f2d84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17655a67d81dd80c3f0f211319f0752d5d0f2d84/comments", "author": null, "committer": null, "parents": [{"sha": "ad72b5331e04616e343f3b7f92c4cd4c784c3d86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad72b5331e04616e343f3b7f92c4cd4c784c3d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad72b5331e04616e343f3b7f92c4cd4c784c3d86"}], "stats": {"total": 191, "additions": 191, "deletions": 0}, "files": [{"sha": "941e6db4d953cb96c0e527cd0e8e2923a2c3e3ed", "filename": "libstdc++-v3/src/fstream.cc", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17655a67d81dd80c3f0f211319f0752d5d0f2d84/libstdc%2B%2B-v3%2Fsrc%2Ffstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17655a67d81dd80c3f0f211319f0752d5d0f2d84/libstdc%2B%2B-v3%2Fsrc%2Ffstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffstream.cc?ref=17655a67d81dd80c3f0f211319f0752d5d0f2d84", "patch": "@@ -0,0 +1,191 @@\n+// File based streams -*- C++ -*-\n+\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8  File-based streams\n+//\n+\n+#include <fstream>\n+\n+namespace std \n+{\n+  template<> \n+    basic_filebuf<char>::int_type \n+    basic_filebuf<char>::_M_underflow_common(bool __bump)\n+    {\n+      int_type __ret = traits_type::eof();\n+      bool __testin = _M_mode & ios_base::in;\n+      bool __testout = _M_mode & ios_base::out;\n+\n+      if (__testin)\n+\t{\n+\t  // Check for pback madness, and if so swich back to the\n+\t  // normal buffers and jet outta here before expensive\n+\t  // fileops happen...\n+\t  if (_M_pback_init)\n+\t    {\n+\t      _M_pback_destroy();\n+\t      if (_M_in_cur < _M_in_end)\n+\t\treturn traits_type::to_int_type(*_M_in_cur);\n+\t    }\n+\n+\t  // Sync internal and external buffers.\n+\t  // NB: __testget -> __testput as _M_buf_unified here.\n+\t  bool __testget = _M_in_cur && _M_in_beg < _M_in_cur;\n+\t  bool __testinit = _M_is_indeterminate();\n+\t  if (__testget)\n+\t    {\n+\t      if (__testout)\n+\t\t_M_really_overflow();\n+\t      else if (_M_in_cur != _M_filepos)\n+\t\t_M_file.seekoff(_M_in_cur - _M_filepos,\n+\t\t\t\tios_base::cur, ios_base::in);\n+\t    }\n+\n+\t  if (__testinit || __testget)\n+\t    {\n+\t      streamsize __elen = 0;\n+\t      streamsize __ilen = 0;\n+\t      __elen = _M_file.xsgetn(reinterpret_cast<char*>(_M_in_beg), \n+\t\t\t\t      _M_buf_size);\n+\t      __ilen = __elen;\n+\n+\t      if (0 < __ilen)\n+\t\t{\n+\t\t  _M_set_determinate(__ilen);\n+\t\t  if (__testout)\n+\t\t    _M_out_cur = _M_in_cur;\n+\t\t  __ret = traits_type::to_int_type(*_M_in_cur);\n+\t\t  if (__bump)\n+\t\t    _M_in_cur_move(1);\n+\t\t  else if (_M_buf_size == 1)\n+\t\t    {\n+\t\t      // If we are synced with stdio, we have to unget the\n+\t\t      // character we just read so that the file pointer\n+\t\t      // doesn't move.\n+\t\t      _M_file.sys_ungetc(traits_type::to_int_type(*_M_in_cur));\n+\t\t      _M_set_indeterminate();\n+\t\t    }\n+\t\t}\t   \n+\t    }\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __ret;\n+    }\n+\n+  template<> \n+    basic_filebuf<wchar_t>::int_type \n+    basic_filebuf<wchar_t>::_M_underflow_common(bool __bump)\n+    {\n+      int_type __ret = traits_type::eof();\n+      bool __testin = _M_mode & ios_base::in;\n+      bool __testout = _M_mode & ios_base::out;\n+\n+      if (__testin)\n+\t{\n+\t  // Check for pback madness, and if so swich back to the\n+\t  // normal buffers and jet outta here before expensive\n+\t  // fileops happen...\n+\t  if (_M_pback_init)\n+\t    {\n+\t      _M_pback_destroy();\n+\t      if (_M_in_cur < _M_in_end)\n+\t\treturn traits_type::to_int_type(*_M_in_cur);\n+\t    }\n+\n+\t  // Sync internal and external buffers.\n+\t  // NB: __testget -> __testput as _M_buf_unified here.\n+\t  bool __testget = _M_in_cur && _M_in_beg < _M_in_cur;\n+\t  bool __testinit = _M_is_indeterminate();\n+\t  if (__testget)\n+\t    {\n+\t      if (__testout)\n+\t\t_M_really_overflow();\n+\t      else if (_M_in_cur != _M_filepos)\n+\t\t_M_file.seekoff(_M_in_cur - _M_filepos,\n+\t\t\t\tios_base::cur, ios_base::in);\n+\t    }\n+\n+\t  if (__testinit || __testget)\n+\t    {\n+\t      const locale __loc = this->getloc();\n+\t      const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc); \n+\n+\t      streamsize __elen = 0;\n+\t      streamsize __ilen = 0;\n+\t      if (__cvt.always_noconv())\n+\t\t{\n+\t\t  __elen = _M_file.xsgetn(reinterpret_cast<char*>(_M_in_beg), \n+\t\t\t\t\t  _M_buf_size);\n+\t\t  __ilen = __elen;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  char* __buf = static_cast<char*>(__builtin_alloca(_M_buf_size));\n+\t\t  __elen = _M_file.xsgetn(__buf, _M_buf_size);\n+\n+\t\t  const char* __eend;\n+\t\t  char_type* __iend;\n+\t\t  __res_type __r = __cvt.in(_M_state_cur, __buf, \n+\t\t\t\t\t    __buf + __elen, __eend, _M_in_beg, \n+\t\t\t\t\t    _M_in_beg + _M_buf_size, __iend);\n+\t\t  if (__r == codecvt_base::ok)\n+\t\t    __ilen = __iend - _M_in_beg;\n+\t\t  else \n+\t\t    {\n+\t\t      // Unwind.\n+\t\t      __ilen = 0;\n+\t\t      _M_file.seekoff(-__elen, ios_base::cur, ios_base::in);\n+\t\t    }\n+\t\t}\n+\n+\t      if (0 < __ilen)\n+\t\t{\n+\t\t  _M_set_determinate(__ilen);\n+\t\t  if (__testout)\n+\t\t    _M_out_cur = _M_in_cur;\n+\t\t  __ret = traits_type::to_int_type(*_M_in_cur);\n+\t\t  if (__bump)\n+\t\t    _M_in_cur_move(1);\n+\t\t  else if (_M_buf_size == 1)\n+\t\t    {\n+\t\t      // If we are synced with stdio, we have to unget the\n+\t\t      // character we just read so that the file pointer\n+\t\t      // doesn't move.\n+\t\t      _M_file.sys_ungetc(traits_type::to_int_type(*_M_in_cur));\n+\t\t      _M_set_indeterminate();\n+\t\t    }\n+\t\t}\t   \n+\t    }\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __ret;\n+    }\n+} // namespace std"}]}