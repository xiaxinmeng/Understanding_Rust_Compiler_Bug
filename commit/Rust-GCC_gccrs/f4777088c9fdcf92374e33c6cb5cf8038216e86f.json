{"sha": "f4777088c9fdcf92374e33c6cb5cf8038216e86f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ3NzcwODhjOWZkY2Y5MjM3NGUzM2M2Y2I1Y2Y4MDM4MjE2ZTg2Zg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2020-02-09T16:56:38Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2020-02-09T16:56:38Z"}, "message": "Improve splitX passes management\n\nThe names of split_before_sched2 (\"split4\") and split_before_regstack\n(\"split3\") do not reflect their insertion point in the sequence of passes,\nwhere split_before_regstack follows split_before_sched2. Reorder the code\nand rename the passes to reflect the reality.\n\nsplit_before_regstack pass does not need to run if split_before_sched2 pass\nwas already performed. Introduce enable_split_before_sched2 function to\nsimplify gating functions of these two passes.\n\nThere is no need for a separate rest_of_handle_split_before_sched2.\nsplit_all_insns can be called unconditionally from\npass_split_before_sched2::execute, since the corresponding gating function\ndetermines if the pass is executed or not.\n\n\t* recog.c: Move pass_split_before_sched2 code in front of\n\tpass_split_before_regstack.\n\t(pass_data_split_before_sched2): Rename pass to split3 from split4.\n\t(pass_data_split_before_regstack): Rename pass to split4 from split3.\n\t(rest_of_handle_split_before_sched2): Remove.\n\t(pass_split_before_sched2::execute): Unconditionally call\n\tsplit_all_insns.\n\t(enable_split_before_sched2): New function.\n\t(pass_split_before_sched2::gate): Use enable_split_before_sched2.\n\t(pass_split_before_regstack::gate): Ditto.\n\t* config/nds32/nds32.c (nds32_split_double_word_load_store_p):\n\tUpdate name check for renamed split4 pass.\n\t* config/sh/sh.c (register_sh_passes): Update pass insertion\n\tpoint for renamed split4 pass.", "tree": {"sha": "85523c7252064a953b0e87b5bdf8a22885332af2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85523c7252064a953b0e87b5bdf8a22885332af2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4777088c9fdcf92374e33c6cb5cf8038216e86f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4777088c9fdcf92374e33c6cb5cf8038216e86f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4777088c9fdcf92374e33c6cb5cf8038216e86f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4777088c9fdcf92374e33c6cb5cf8038216e86f/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38660e87f01dbe15082e83cc4842d66f8d292ba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38660e87f01dbe15082e83cc4842d66f8d292ba0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38660e87f01dbe15082e83cc4842d66f8d292ba0"}], "stats": {"total": 119, "additions": 65, "deletions": 54}, "files": [{"sha": "feb2d066d0b114ef4ec4ad75acb3423d5ab0e7cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4777088c9fdcf92374e33c6cb5cf8038216e86f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4777088c9fdcf92374e33c6cb5cf8038216e86f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4777088c9fdcf92374e33c6cb5cf8038216e86f", "patch": "@@ -1,3 +1,20 @@\n+2020-02-09  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* recog.c: Move pass_split_before_sched2 code in front of\n+\tpass_split_before_regstack.\n+\t(pass_data_split_before_sched2): Rename pass to split3 from split4.\n+\t(pass_data_split_before_regstack): Rename pass to split4 from split3.\n+\t(rest_of_handle_split_before_sched2): Remove.\n+\t(pass_split_before_sched2::execute): Unconditionally call\n+\tsplit_all_insns.\n+\t(enable_split_before_sched2): New function.\n+\t(pass_split_before_sched2::gate): Use enable_split_before_sched2.\n+\t(pass_split_before_regstack::gate): Ditto.\n+\t* config/nds32/nds32.c (nds32_split_double_word_load_store_p):\n+\tUpdate name check for renamed split4 pass.\n+\t* config/sh/sh.c (register_sh_passes): Update pass insertion\n+\tpoint for renamed split4 pass.\n+\n 2020-02-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gimplify.c (gimplify_adjust_omp_clauses_1): Promote"}, {"sha": "acf13715d8304856e86da2a6e149a06489086b9d", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4777088c9fdcf92374e33c6cb5cf8038216e86f/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4777088c9fdcf92374e33c6cb5cf8038216e86f/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=f4777088c9fdcf92374e33c6cb5cf8038216e86f", "patch": "@@ -5496,7 +5496,7 @@ nds32_split_double_word_load_store_p(rtx *operands, bool load_p)\n     return false;\n \n   const char *pass_name = current_pass->name;\n-  if (pass_name && ((strcmp (pass_name, \"split4\") == 0)\n+  if (pass_name && ((strcmp (pass_name, \"split3\") == 0)\n \t\t     || (strcmp (pass_name, \"split5\") == 0)))\n     return !satisfies_constraint_Da (mem) || MEM_VOLATILE_P (mem);\n "}, {"sha": "a178cfd3b9c9b998c573847c9fb1d9d3768e86c0", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4777088c9fdcf92374e33c6cb5cf8038216e86f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4777088c9fdcf92374e33c6cb5cf8038216e86f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f4777088c9fdcf92374e33c6cb5cf8038216e86f", "patch": "@@ -800,7 +800,7 @@ register_sh_passes (void)\n   /* Run sh_treg_combine pass after register allocation and basic block\n      reordering as this sometimes creates new opportunities.  */\n   register_pass (make_pass_sh_treg_combine (g, true, \"sh_treg_combine3\"),\n-\t\t PASS_POS_INSERT_AFTER, \"split4\", 1);\n+\t\t PASS_POS_INSERT_AFTER, \"split3\", 1);\n \n   /* Optimize sett and clrt insns, by e.g. removing them if the T bit value\n      is known after a conditional branch."}, {"sha": "8c098cf5b0fe8b4378a58ff6517b4b27998c0613", "filename": "gcc/recog.c", "status": "modified", "additions": 46, "deletions": 52, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4777088c9fdcf92374e33c6cb5cf8038216e86f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4777088c9fdcf92374e33c6cb5cf8038216e86f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f4777088c9fdcf92374e33c6cb5cf8038216e86f", "patch": "@@ -3943,9 +3943,19 @@ make_pass_split_after_reload (gcc::context *ctxt)\n   return new pass_split_after_reload (ctxt);\n }\n \n+static bool\n+enable_split_before_sched2 (void)\n+{\n+#ifdef INSN_SCHEDULING\n+  return optimize > 0 && flag_schedule_insns_after_reload;\n+#else\n+  return false;\n+#endif\n+}\n+\n namespace {\n \n-const pass_data pass_data_split_before_regstack =\n+const pass_data pass_data_split_before_sched2 =\n {\n   RTL_PASS, /* type */\n   \"split3\", /* name */\n@@ -3958,61 +3968,38 @@ const pass_data pass_data_split_before_regstack =\n   0, /* todo_flags_finish */\n };\n \n-class pass_split_before_regstack : public rtl_opt_pass\n+class pass_split_before_sched2 : public rtl_opt_pass\n {\n public:\n-  pass_split_before_regstack (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_split_before_regstack, ctxt)\n+  pass_split_before_sched2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_split_before_sched2, ctxt)\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *);\n+  virtual bool gate (function *)\n+    {\n+      return enable_split_before_sched2 ();\n+    }\n+\n   virtual unsigned int execute (function *)\n     {\n       split_all_insns ();\n       return 0;\n     }\n \n-}; // class pass_split_before_regstack\n-\n-bool\n-pass_split_before_regstack::gate (function *)\n-{\n-#if HAVE_ATTR_length && defined (STACK_REGS)\n-  /* If flow2 creates new instructions which need splitting\n-     and scheduling after reload is not done, they might not be\n-     split until final which doesn't allow splitting\n-     if HAVE_ATTR_length.  */\n-# ifdef INSN_SCHEDULING\n-  return !optimize || !flag_schedule_insns_after_reload;\n-# else\n-  return true;\n-# endif\n-#else\n-  return false;\n-#endif\n-}\n+}; // class pass_split_before_sched2\n \n } // anon namespace\n \n rtl_opt_pass *\n-make_pass_split_before_regstack (gcc::context *ctxt)\n-{\n-  return new pass_split_before_regstack (ctxt);\n-}\n-\n-static unsigned int\n-rest_of_handle_split_before_sched2 (void)\n+make_pass_split_before_sched2 (gcc::context *ctxt)\n {\n-#ifdef INSN_SCHEDULING\n-  split_all_insns ();\n-#endif\n-  return 0;\n+  return new pass_split_before_sched2 (ctxt);\n }\n \n namespace {\n \n-const pass_data pass_data_split_before_sched2 =\n+const pass_data pass_data_split_before_regstack =\n {\n   RTL_PASS, /* type */\n   \"split4\", /* name */\n@@ -4025,36 +4012,43 @@ const pass_data pass_data_split_before_sched2 =\n   0, /* todo_flags_finish */\n };\n \n-class pass_split_before_sched2 : public rtl_opt_pass\n+class pass_split_before_regstack : public rtl_opt_pass\n {\n public:\n-  pass_split_before_sched2 (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_split_before_sched2, ctxt)\n+  pass_split_before_regstack (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_split_before_regstack, ctxt)\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-#ifdef INSN_SCHEDULING\n-      return optimize > 0 && flag_schedule_insns_after_reload;\n-#else\n-      return false;\n-#endif\n-    }\n-\n+  virtual bool gate (function *);\n   virtual unsigned int execute (function *)\n     {\n-      return rest_of_handle_split_before_sched2 ();\n+      split_all_insns ();\n+      return 0;\n     }\n \n-}; // class pass_split_before_sched2\n+}; // class pass_split_before_regstack\n+\n+bool\n+pass_split_before_regstack::gate (function *)\n+{\n+#if HAVE_ATTR_length && defined (STACK_REGS)\n+  /* If flow2 creates new instructions which need splitting\n+     and scheduling after reload is not done, they might not be\n+     split until final which doesn't allow splitting\n+     if HAVE_ATTR_length.  */\n+  return !enable_split_before_sched2 ();\n+#else\n+  return false;\n+#endif\n+}\n \n } // anon namespace\n \n rtl_opt_pass *\n-make_pass_split_before_sched2 (gcc::context *ctxt)\n+make_pass_split_before_regstack (gcc::context *ctxt)\n {\n-  return new pass_split_before_sched2 (ctxt);\n+  return new pass_split_before_regstack (ctxt);\n }\n \n namespace {"}]}