{"sha": "7ded4467c9ee286111320967832db758d71acf4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RlZDQ0NjdjOWVlMjg2MTExMzIwOTY3ODMyZGI3NThkNzFhY2Y0Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-09-11T09:39:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-09-11T09:39:11Z"}, "message": "basic-block.h (cached_make_edge, [...]): New.\n\n\t* basic-block.h (cached_make_edge, make_single_succ): New.\n\t(make_edge): Remove first parameter.\n\t* bb-reroder.c (fixup_reorder_chain): Use make_single_succ_edge.\n\t* cfg.c (cached_make_edge): Rename from make_edge; return newly\n\tcreated edge; use obstack allocation.\n\t(make_edge, make_single_succ_edge): New.\n\t(first_removed_edge): New static variable.\n\t(init_flow): Initialize first_removed_edge and n_edges.\n\t(clear_edges): Use remove_edge.\n\t(flow_delete_block): Likewise.\n\t(remove_edge): Add removed edges to the removed edges list.\n\t(split_block, redirect_edge_and_branch_force, split_edge):\n\tUse make_edge.\n\t* cfganal.c (flow_call_edges_add): Updaet make_edge call.\n\t(add_noreturn_fake_exit_edges): Likewise.\n\t(connect_infinite_loops_to_exit): Liekwise.\n\t* cfgbuild.c (make_label_edge, make_edges, find_sub_basic_blocks):\n\tUse cached_make_edge.\n\t* cfgcleanup.c (try_crossjump_to_edge): Use make_single_succ_edge.\n\t* profile.c (branch_prob): Update make_edge call.\n\t* ssa-dce.c (ssa_eliminate_dead_code): Likewise.\n\nFrom-SVN: r45540", "tree": {"sha": "0b80eab87a8ff974cac08543ff1bb4f76eff3798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b80eab87a8ff974cac08543ff1bb4f76eff3798"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ded4467c9ee286111320967832db758d71acf4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ded4467c9ee286111320967832db758d71acf4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ded4467c9ee286111320967832db758d71acf4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ded4467c9ee286111320967832db758d71acf4c/comments", "author": null, "committer": null, "parents": [{"sha": "30102605e710a95f8cb00ddd14303d7fcc284fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30102605e710a95f8cb00ddd14303d7fcc284fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30102605e710a95f8cb00ddd14303d7fcc284fae"}], "stats": {"total": 224, "additions": 122, "deletions": 102}, "files": [{"sha": "266154bcdc7e2b021fe6c58a5a07d416dfebbbbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -1,3 +1,27 @@\n+Tue Sep 11 11:37:52 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (cached_make_edge, make_single_succ): New.\n+\t(make_edge): Remove first parameter.\n+\t* bb-reroder.c (fixup_reorder_chain): Use make_single_succ_edge.\n+\t* cfg.c (cached_make_edge): Rename from make_edge; return newly\n+\tcreated edge; use obstack allocation.\n+\t(make_edge, make_single_succ_edge): New.\n+\t(first_removed_edge): New static variable.\n+\t(init_flow): Initialize first_removed_edge and n_edges.\n+\t(clear_edges): Use remove_edge.\n+\t(flow_delete_block): Likewise.\n+\t(remove_edge): Add removed edges to the removed edges list.\n+\t(split_block, redirect_edge_and_branch_force, split_edge):\n+\tUse make_edge.\n+\t* cfganal.c (flow_call_edges_add): Updaet make_edge call.\n+\t(add_noreturn_fake_exit_edges): Likewise.\n+\t(connect_infinite_loops_to_exit): Liekwise.\n+\t* cfgbuild.c (make_label_edge, make_edges, find_sub_basic_blocks):\n+\tUse cached_make_edge.\n+\t* cfgcleanup.c (try_crossjump_to_edge): Use make_single_succ_edge.\n+\t* profile.c (branch_prob): Update make_edge call.\n+\t* ssa-dce.c (ssa_eliminate_dead_code): Likewise.\n+\n 2001-09-11  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c: Tidy formatting."}, {"sha": "1a49c5f1a7d706b2dd824fe40650d5c5b773eb96", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -305,7 +305,11 @@ extern void connect_infinite_loops_to_exit\tPARAMS ((void));\n extern int flow_call_edges_add\t\tPARAMS ((sbitmap));\n extern rtx flow_delete_insn\t\tPARAMS ((rtx));\n extern void flow_delete_insn_chain\tPARAMS ((rtx, rtx));\n-extern void make_edge\t\t\tPARAMS ((sbitmap *, basic_block,\n+extern edge cached_make_edge\t\tPARAMS ((sbitmap *, basic_block,\n+\t\t\t\t\t\t basic_block, int));\n+extern edge make_edge\t\t\tPARAMS ((basic_block,\n+\t\t\t\t\t\t basic_block, int));\n+extern edge make_single_succ_edge\tPARAMS ((basic_block,\n \t\t\t\t\t\t basic_block, int));\n extern void remove_edge\t\t\tPARAMS ((edge));\n extern void redirect_edge_succ\t\tPARAMS ((edge, basic_block));"}, {"sha": "c048ac872ab01e803f0d1cc396ebb981d416d497", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -737,10 +737,8 @@ fixup_reorder_chain ()\n       RBI (bb)->next = nb;\n \n       /* Link to new block.  */\n-      make_edge (NULL, nb, e_fall->dest, 0);\n+      make_single_succ_edge (nb, e_fall->dest, 0);\n       redirect_edge_succ (e_fall, nb);\n-      nb->succ->count = e_fall->count;\n-      nb->succ->probability = REG_BR_PROB_BASE;\n \n       /* Don't process this new block.  */\n       bb = nb;"}, {"sha": "ff7e1bf7a14b8e4d64b36b2615117991195ede57", "filename": "gcc/cfg.c", "status": "modified", "additions": 75, "deletions": 79, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -34,7 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,\n \t set_block_for_new_insns\n      - Edge manipulation\n-\t make_edge, remove_edge\n+\t make_edge, make_single_succ_edge, cached_make_edge, remove_edge\n \t - Low level edge redirection (without updating instruction chain)\n \t     redirect_edge_succ, redirect_edge_succ_nodup, redirect_edge_pred\n \t - High level edge redirection (with updating and optimizing instruction\n@@ -80,6 +80,10 @@ int n_basic_blocks;\n \n int n_edges;\n \n+/* First edge in the deleted edges chain.  */\n+\n+edge first_deleted_edge;\n+\n /* The basic block array.  */\n \n varray_type basic_block_info;\n@@ -151,6 +155,9 @@ init_flow ()\n {\n   static int initialized;\n \n+  first_deleted_edge = 0;\n+  n_edges = 0;\n+\n   if (!initialized)\n     {\n       gcc_obstack_init (&flow_obstack);\n@@ -170,32 +177,20 @@ void\n clear_edges ()\n {\n   int i;\n-  edge n, e;\n \n   for (i = 0; i < n_basic_blocks; ++i)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n \n-      for (e = bb->succ; e; e = n)\n-\t{\n-\t  n = e->succ_next;\n-\t  free (e);\n-\t}\n-\n-      bb->succ = 0;\n-      bb->pred = 0;\n+      while (bb->succ)\n+\tremove_edge (bb->succ);\n     }\n \n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = n)\n-    {\n-      n = e->succ_next;\n-      free (e);\n-    }\n+  while (ENTRY_BLOCK_PTR->succ)\n+    remove_edge (ENTRY_BLOCK_PTR->succ);\n \n-  ENTRY_BLOCK_PTR->succ = 0;\n-  EXIT_BLOCK_PTR->pred = 0;\n-\n-  n_edges = 0;\n+  if (n_edges)\n+    abort ();\n }\n \f\n /* Return true if NOTE is not one of the ones that must be kept paired,\n@@ -458,26 +453,10 @@ flow_delete_block (b)\n   /* Remove the edges into and out of this block.  Note that there may\n      indeed be edges in, if we are removing an unreachable loop.  */\n   {\n-    edge e, next, *q;\n-\n-    for (e = b->pred; e; e = next)\n-      {\n-\tfor (q = &e->src->succ; *q != e; q = &(*q)->succ_next)\n-\t  continue;\n-\t*q = e->succ_next;\n-\tnext = e->pred_next;\n-\tn_edges--;\n-\tfree (e);\n-      }\n-    for (e = b->succ; e; e = next)\n-      {\n-\tfor (q = &e->dest->pred; *q != e; q = &(*q)->pred_next)\n-\t  continue;\n-\t*q = e->pred_next;\n-\tnext = e->succ_next;\n-\tn_edges--;\n-\tfree (e);\n-      }\n+    while (b->pred != NULL)\n+      remove_edge (b->pred);\n+    while (b->succ != NULL)\n+      remove_edge (b->succ);\n \n     b->pred = NULL;\n     b->succ = NULL;\n@@ -589,8 +568,10 @@ set_block_for_new_insns (insn, bb)\n     }\n }\n \f\n-void\n-make_edge (edge_cache, src, dst, flags)\n+/* Create an edge connecting SRC and DST with FLAGS optionally using\n+   edge cache CACHE.  Return the new edge, NULL if already exist. */\n+edge\n+cached_make_edge (edge_cache, src, dst, flags)\n      sbitmap *edge_cache;\n      basic_block src, dst;\n      int flags;\n@@ -614,20 +595,29 @@ make_edge (edge_cache, src, dst, flags)\n \n       /* The edge exists; early exit if no work to do.  */\n       if (flags == 0)\n-\treturn;\n+\treturn NULL;\n \n       /* FALLTHRU */\n     case 0:\n       for (e = src->succ; e; e = e->succ_next)\n \tif (e->dest == dst)\n \t  {\n \t    e->flags |= flags;\n-\t    return;\n+\t    return NULL;\n \t  }\n       break;\n     }\n \n-  e = (edge) xcalloc (1, sizeof (*e));\n+  if (first_deleted_edge)\n+    {\n+      e = first_deleted_edge;\n+      first_deleted_edge = e->succ_next;\n+    }\n+  else\n+    {\n+      e = (edge) obstack_alloc (&flow_obstack, sizeof (*e));\n+      memset (e, 0, sizeof (*e));\n+    }\n   n_edges++;\n \n   e->succ_next = src->succ;\n@@ -641,6 +631,34 @@ make_edge (edge_cache, src, dst, flags)\n \n   if (use_edge_cache)\n     SET_BIT (edge_cache[src->index], dst->index);\n+\n+  return e;\n+}\n+\n+/* Create an edge connecting SRC and DEST with flags FLAGS.  Return newly\n+   created edge or NULL if already exist.  */\n+\n+edge\n+make_edge (src, dest, flags)\n+     basic_block src, dest;\n+     int flags;\n+{\n+  return cached_make_edge (NULL, src, dest, flags);\n+}\n+\n+/* Create an edge connecting SRC to DEST and set probability by knowling\n+   that it is the single edge leaving SRC.  */\n+\n+edge\n+make_single_succ_edge (src, dest, flags)\n+     basic_block src, dest;\n+     int flags;\n+{\n+  edge e = make_edge (src, dest, flags);\n+\n+  e->probability = REG_BR_PROB_BASE;\n+  e->count = src->count;\n+  return e;\n }\n \n /* This function will remove an edge from the flow graph.  */\n@@ -676,7 +694,9 @@ remove_edge (e)\n     dest->pred = e->pred_next;\n \n   n_edges--;\n-  free (e);\n+  memset (e, 0, sizeof (*e));\n+  e->succ_next = first_deleted_edge;\n+  first_deleted_edge = e;\n }\n \n /* Redirect an edge's successor from one block to another.  */\n@@ -766,8 +786,6 @@ split_block (bb, insn)\n \n   /* Create the new structures.  */\n   new_bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*new_bb));\n-  new_edge = (edge) xcalloc (1, sizeof (*new_edge));\n-  n_edges++;\n \n   memset (new_bb, 0, sizeof (*new_bb));\n \n@@ -776,22 +794,18 @@ split_block (bb, insn)\n   bb->end = insn;\n \n   new_bb->succ = bb->succ;\n-  bb->succ = new_edge;\n-  new_bb->pred = new_edge;\n+  bb->succ = NULL;\n+  new_bb->pred = NULL;\n   new_bb->count = bb->count;\n   new_bb->frequency = bb->frequency;\n   new_bb->loop_depth = bb->loop_depth;\n \n-  new_edge->src = bb;\n-  new_edge->dest = new_bb;\n-  new_edge->flags = EDGE_FALLTHRU;\n-  new_edge->probability = REG_BR_PROB_BASE;\n-  new_edge->count = bb->count;\n-\n   /* Redirect the src of the successor edges of bb to point to new_bb.  */\n   for (e = new_bb->succ; e; e = e->succ_next)\n     e->src = new_bb;\n \n+  new_edge = make_single_succ_edge (bb, new_bb, EDGE_FALLTHRU);\n+\n   /* Place the new block just after the block being split.  */\n   VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n \n@@ -1262,22 +1276,16 @@ redirect_edge_and_branch_force (e, target)\n \n   /* Create the new structures.  */\n   new_bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*new_bb));\n-  new_edge = (edge) xcalloc (1, sizeof (*new_edge));\n-  n_edges++;\n \n   memset (new_bb, 0, sizeof (*new_bb));\n \n   new_bb->end = new_bb->head = last_loop_beg_note (e->src->end);\n   new_bb->succ = NULL;\n-  new_bb->pred = new_edge;\n+  new_bb->pred = NULL;\n   new_bb->count = e->count;\n   new_bb->frequency = EDGE_FREQUENCY (e);\n   new_bb->loop_depth = e->dest->loop_depth;\n \n-  new_edge->flags = EDGE_FALLTHRU;\n-  new_edge->probability = e->probability;\n-  new_edge->count = e->count;\n-\n   if (target->global_live_at_start)\n     {\n       new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n@@ -1288,11 +1296,9 @@ redirect_edge_and_branch_force (e, target)\n     }\n \n   /* Wire edge in.  */\n-  new_edge->src = e->src;\n-  new_edge->dest = new_bb;\n-  new_edge->succ_next = e->src->succ;\n-  e->src->succ = new_edge;\n-  new_edge->pred_next = NULL;\n+  new_edge = make_edge (e->src, new_bb, EDGE_FALLTHRU);\n+  new_edge->probability = e->probability;\n+  new_edge->count = e->count;\n \n   /* Redirect old edge.  */\n   redirect_edge_succ (e, target);\n@@ -1487,8 +1493,6 @@ split_edge (edge_in)\n \n   /* Create the new structures.  */\n   bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*bb));\n-  edge_out = (edge) xcalloc (1, sizeof (*edge_out));\n-  n_edges++;\n \n   memset (bb, 0, sizeof (*bb));\n \n@@ -1502,21 +1506,13 @@ split_edge (edge_in)\n     }\n \n   /* Wire them up.  */\n-  bb->succ = edge_out;\n+  bb->succ = NULL;\n   bb->count = edge_in->count;\n   bb->frequency = EDGE_FREQUENCY (edge_in);\n \n   edge_in->flags &= ~EDGE_CRITICAL;\n \n-  edge_out->pred_next = old_succ->pred;\n-  edge_out->succ_next = NULL;\n-  edge_out->src = bb;\n-  edge_out->dest = old_succ;\n-  edge_out->flags = EDGE_FALLTHRU;\n-  edge_out->probability = REG_BR_PROB_BASE;\n-  edge_out->count = edge_in->count;\n-\n-  old_succ->pred = edge_out;\n+  edge_out = make_single_succ_edge (bb, old_succ, EDGE_FALLTHRU);\n \n   /* Tricky case -- if there existed a fallthru into the successor\n      (and we're not it) we must add a new unconditional jump around"}, {"sha": "5711794801fd6fb51234f239e41266c40b494b03", "filename": "gcc/cfganal.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -348,7 +348,7 @@ flow_call_edges_add (blocks)\n \t      if (e)\n \t\tblocks_split++;\n \n-\t      make_edge (NULL, bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n+\t      make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n \t    }\n \t  if (insn == bb->head)\n \t    break;\n@@ -762,7 +762,7 @@ add_noreturn_fake_exit_edges ()\n \n   for (x = 0; x < n_basic_blocks; x++)\n     if (BASIC_BLOCK (x)->succ == NULL)\n-      make_edge (NULL, BASIC_BLOCK (x), EXIT_BLOCK_PTR, EDGE_FAKE);\n+      make_single_succ_edge (BASIC_BLOCK (x), EXIT_BLOCK_PTR, EDGE_FAKE);\n }\n \n /* This function adds a fake edge between any infinite loops to the\n@@ -794,7 +794,7 @@ connect_infinite_loops_to_exit ()\n       unvisited_block = flow_dfs_compute_reverse_execute (&dfs_ds);\n       if (!unvisited_block)\n \tbreak;\n-      make_edge (NULL, unvisited_block, EXIT_BLOCK_PTR, EDGE_FAKE);\n+      make_edge (unvisited_block, EXIT_BLOCK_PTR, EDGE_FAKE);\n       flow_dfs_compute_reverse_add_bb (&dfs_ds, unvisited_block);\n     }\n "}, {"sha": "ea1c7327b343d50b2a77a317d72c74e18d931eef", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -186,7 +186,7 @@ make_label_edge (edge_cache, src, label, flags)\n   if (INSN_UID (label) == 0)\n     return;\n \n-  make_edge (edge_cache, src, BLOCK_FOR_INSN (label), flags);\n+  cached_make_edge (edge_cache, src, BLOCK_FOR_INSN (label), flags);\n }\n \n /* Create the edges generated by INSN in REGION.  */\n@@ -246,7 +246,7 @@ make_edges (label_value_list, min, max, update_p)\n     }\n \n   /* By nature of the way these get numbered, block 0 is always the entry.  */\n-  make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n+  cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n \n   for (i = min; i <= max; ++i)\n     {\n@@ -257,7 +257,7 @@ make_edges (label_value_list, min, max, update_p)\n \n       if (GET_CODE (bb->head) == CODE_LABEL\n \t  && LABEL_ALTERNATE_NAME (bb->head))\n-\tmake_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n+\tcached_make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n \n       /* Examine the last instruction of the block, and discover the\n \t ways we can leave the block.  */\n@@ -330,7 +330,7 @@ make_edges (label_value_list, min, max, update_p)\n \n \t  /* Returns create an exit out.  */\n \t  else if (returnjump_p (insn))\n-\t    make_edge (edge_cache, bb, EXIT_BLOCK_PTR, 0);\n+\t    cached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR, 0);\n \n \t  /* Otherwise, we have a plain conditional or unconditional jump.  */\n \t  else\n@@ -347,7 +347,7 @@ make_edges (label_value_list, min, max, update_p)\n \t wouldn't have created the sibling call in the first place.  */\n \n       if (code == CALL_INSN && SIBLING_CALL_P (insn))\n-\tmake_edge (edge_cache, bb, EXIT_BLOCK_PTR,\n+\tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR,\n \t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n \n       /* If this is a CALL_INSN, then mark it as reaching the active EH\n@@ -383,14 +383,14 @@ make_edges (label_value_list, min, max, update_p)\n       /* Find out if we can drop through to the next block.  */\n       insn = next_nonnote_insn (insn);\n       if (!insn || (i + 1 == n_basic_blocks && force_fallthru))\n-\tmake_edge (edge_cache, bb, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n+\tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n       else if (i + 1 < n_basic_blocks)\n \t{\n \t  rtx tmp = BLOCK_HEAD (i + 1);\n \t  if (GET_CODE (tmp) == NOTE)\n \t    tmp = next_nonnote_insn (tmp);\n \t  if (force_fallthru || insn == tmp)\n-\t    make_edge (edge_cache, bb, BASIC_BLOCK (i + 1), EDGE_FALLTHRU);\n+\t    cached_make_edge (edge_cache, bb, BASIC_BLOCK (i + 1), EDGE_FALLTHRU);\n \t}\n     }\n \n@@ -701,7 +701,7 @@ find_sub_basic_blocks (bb)\n \t  remove_edge (falltru);\n \t  jump_insn = 0;\n \t  if (LABEL_ALTERNATE_NAME (insn))\n-\t    make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n+\t    make_edge (ENTRY_BLOCK_PTR, bb, 0);\n \t  break;\n \tcase INSN:\n \tcase JUMP_INSN:"}, {"sha": "4413c027f17f5b2af94f7682006511420cd7ac1c", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -941,9 +941,7 @@ try_crossjump_to_edge (mode, e1, e2)\n   /* Update CFG.  */\n   while (src1->succ)\n     remove_edge (src1->succ);\n-  make_edge (NULL, src1, redirect_to, 0);\n-  src1->succ->probability = REG_BR_PROB_BASE;\n-  src1->succ->count = src1->count;\n+  make_single_succ_edge (src1, redirect_to, 0);\n \n   return true;\n }"}, {"sha": "81737f98fe0cdc6a78c33c71048b0adc28e7b34c", "filename": "gcc/profile.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -563,7 +563,7 @@ branch_prob ()\n \t\t  || insn != NEXT_INSN (bb->head))\n \t\t{\n \t\t  e = split_block (bb, PREV_INSN (insn));\n-\t\t  make_edge (NULL, ENTRY_BLOCK_PTR, e->dest, EDGE_FAKE);\n+\t\t  make_edge (ENTRY_BLOCK_PTR, e->dest, EDGE_FAKE);\n \t\t  break;\n \t\t}\n \t      else\n@@ -572,7 +572,7 @@ branch_prob ()\n \t\t     be the very first instruction of function.  */\n \t\t  if (!i)\n \t\t    abort ();\n-\t\t  make_edge (NULL, ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n+\t\t  make_edge (ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n \t\t}\n \t    }\n \t}\n@@ -599,14 +599,14 @@ branch_prob ()\n \t  if (rtl_dump_file)\n \t    fprintf (rtl_dump_file, \"Adding fake exit edge to bb %i\\n\",\n \t\t     bb->index);\n-          make_edge (NULL, bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n+          make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n \t}\n       if (need_entry_edge && !have_entry_edge)\n \t{\n \t  if (rtl_dump_file)\n \t    fprintf (rtl_dump_file, \"Adding fake entry edge to bb %i\\n\",\n \t\t     bb->index);\n-          make_edge (NULL, ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n+          make_edge (ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n \t}\n     }\n "}, {"sha": "797a01ca68a88032e29e377e9068a85bf037853b", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ded4467c9ee286111320967832db758d71acf4c/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=7ded4467c9ee286111320967832db758d71acf4c", "patch": "@@ -707,7 +707,7 @@ ssa_eliminate_dead_code ()\n \n \t/* Create an edge from this block to the post dominator.  \n \t   What about the PHI nodes at the target?  */\n-\tmake_edge (NULL, bb, pdom_bb, 0);\n+\tmake_edge (bb, pdom_bb, 0);\n \n \t/* Third, transform this insn into an unconditional\n \t   jump to the label for the immediate postdominator.  */"}]}