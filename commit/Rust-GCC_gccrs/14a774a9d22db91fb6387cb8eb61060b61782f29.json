{"sha": "14a774a9d22db91fb6387cb8eb61060b61782f29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRhNzc0YTlkMjJkYjkxZmI2Mzg3Y2I4ZWI2MTA2MGI2MTc4MmYyOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1999-11-01T01:11:22Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1999-11-01T01:11:22Z"}, "message": "[multiple changes]\n\nFri Oct 29 15:25:07 1999  Arnaud Charlet  <charlet@ACT-Europe.FR>\n\n\t* gcov.c (DIR_SEPARATOR): Provide default.\n\t(output_data): Add test for MS-DOS format absolute filename.\n\t(fancy_abort): Correct program name.\n\t(open_files): Open all files in binary mode.\n\t* libgcc2.c (__bb_exit_func): Likewise.\n\n\t* profile.c (init_branch_prob): Specify binary when opening files.\n\n\t* flags.h (flag_unwind_tables): New decl.\n\t* toplev.c (flag_unwind_table): New definition.\n\t(f_options): Add -funwind-tables.\n\t(decode_g_option): Clarify warning when unknown -g option is given.\n\t(rest_of_compilation): If inside an inlined external function,\n\tpretend we are just being declared.\n\n\t* dwarf2out.c (dwarf2out_do_frame): Check -funwind_tables.\n\t(dwarf2out_frame_finish): Likewise.\n\nFri Oct 29 06:32:44 1999  Geoffrey Keating  <geoffk@cygnus.com>\n\n\t* flow.c (propagate_block): When the last reference to a label\n \tbefore an ADDR_VEC is deleted because the reference is a dead\n \tstore, delete the ADDR_VEC.\n\nFri Oct 29 07:44:26 1999  Vasco Pedro  <vp@di.fct.unl.pt>\n\n\t* fold-const.c (merge_ranges): In not in0, but in1, handle\n\tupper bounds equal like subset case.\n\nThu Oct 28 19:22:24 1999  Douglas Rupp <rupp@gnat.com>\n\n\t* dbxout.c (dbxout_parms): Generate a second stabs line for parameters\n\tpassed in a register but moved to the stack.\n\nThu Oct 28 19:12:57 1999  Sam Tardieu  <tardieu@act-europe.fr>\n\n\t* gcc.c (pass_exit_codes, greatest_status): New variables.\n\t(struct option_map): Add entry for \"--pass-exit-codes\".\n\t(execute): Update greatest_status if error.\n\t(display_help): Add documentation for -pass-exit-codes.\n\t(process_command): Handle -pass-exit-codes.\n\t(main): Look at pass_exit_codes and greatest_status on call to exit.\n\nThu Oct 28 18:06:50 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* reload.c (find_reloads): Refine test for no input reload\n\tcase to not includes reloads emitted after insn.\n\n\t* function.c (find_temp_slots_from_address): Handle sum involving\n\ta register that points to a temp slot.\n\t(update_temp_slot_address): Make recursive call if both old and\n\tnew are PLUS with a common operand.\n\t* calls.c (expand_call): Mark temp slot for result as having\n\taddress taken.\n\n\t* rtlanal.c (reg_referenced_p, case IF_THEN_ELSE): New case.\n\n\t* gcc.c (process_command): Add standard_exec_prefix with \"GCC\"\n\tcomponent as well as \"BINUTILS\".\n\n\t* integrate.h (copy_rtx_and_substitute): New arg, FOR_LHS.\n\t* integrate.c (copy_rtx_and_substitute): Likewise.\n\t(expand_inline_function, integrate_parm_decls, integrate_decl_tree):\n\tAll callers changed.\n\t* unroll.c (inital_reg_note_copy, copy_loop_body): Likewise.\n\n\t* dbxout.c (dbxout_type, case INTEGER_TYPE_NODE): If can use\n\tgdb extensions, write size of type; also be more consistent\n\tin using references when this is a subtype.\n\n\t* pa.md (extv, extzv, insv): Use define_expand to reject constant\n\tthat is out of range.\n\n\t* loop.c (unknown_constant_address_altered): New variable.\n\t(prescan_loop): Initialize it.\n\t(note_addr_stored): Set it for RTX_UNCHANGING_P MEM.\n\t(invariant_p, case MEM): Remove handling for volatile and readony;\n\tcheck new variable if readonly.\n\t(check_dbra_loop): Chdeck unknown_constant_address_altered.\n\n\t* cse.c (canon_hash, case MEM): Do not record if BLKmode.\n\t(addr_affects_sp_p): Removed from note_mem_written and only\n\tdefine #ifdef AUTO_INC_DEC.\n\n\t* alpha.c (input_operand, case ADDRESSOF): Treat as REG.\n\n\t* regclass.c (record_reg_classes): Properly handle register move\n\tdirections.\n\n\t* varasm.c (initializer_constant_valid_p, case MINUS_EXPR):\n\tDon't think valid if both operands are invalid.\n\t(struct constant_descriptor): New field RTL.\n\t(mark_const_hash_entry): Mark it.\n\t(record_constant{,_rtx}): Initialize it.\n\t(output_constant_def): Allocate RTL in permanent obstack and\n\tsave in table.\n\t({record,compare}_constant_1): Modes must match for\n\tCONSTRUCTOR of ARRAY_TYPE.\n\n\t* c-common.h (initializer_constant_valid_p): Delete decl from here.\n\t* output.h (initializer_constant_valid_p): Move decl to here.\n\t* c-common.c (initializer_constant_valid_p): Delete function from here.\n\t* varasm.c (initializer_constant_valid_p): Move function to here.\n\n\t* tree.h (STRIP_SIGN_NOPS): New macro.\n\t* fold-const.c (optimize_minmax_comparison): New function.\n\t(invert_truthvalue, case WITH_RECORD_EXPR): New case.\n\t(fold): Use STRIP_SIGN_NOPS instead of STRIP_TYPE_NOPS.\n\t(fold, case EQ_EXPR): Call optimize_minmax_comparison and add\n\tcases with ABS_EXPR, NEGATE_EXPR, PLUS_EXPR, MINUS_EXPR, and\n\twidening conversions.\n\t(fold, case LE_EXPR): Rework changing unsigned to signed comparisons\n\tto look at size of mode, not precision of type; also add missing cases.\n\t(optimize_bit_field_compare, decode_field_reference): Don't try to\n\toptimize COMPONENT_REF of a PLACEHOLDER_EXPR.\n\n\t* dwarf2out.c (ctype.h): Include.\n\t(dwarf2out_set_demangle_name_func): New function.\n\t(size_of_line_info): Deleted.\n\t(output_line_info): Compute size of line info table from difference\n\tof labels.\n\t(base_type_die, add_name_attribute): Call demangle function, if any.\n\t(field_byte_offset): Use bits per word for variable length fields.\n\t(gen_array_type_die): Add array name.\n\t(gen_subprogram_die): Ignore DECL_INLINE if -fno-inline.\n\t(dwarf2out_add_library_unit_info): New function.\n\n\t* explow.c (set_stack_check_libfunc): New function.\n\t(stack_check_libfunc): New static variable.\n\t(probe_stack_range): Allow front-end to set up a libfunc to call.\n\n\t* combine.c (simplify_comparison): When making comparison in wider\n\tmode, check for having commuted an AND and a SUBREG.\n\t(contains_muldiv): New function.\n\t(try_combine): Call it when dividing a PARALLEL.\n\t(simplify_rtx, case TRUNCATE): Don't remove for umulsi3_highpart.\n\t(simplify_comparison, case ASHIFTRT): Recognize sign-extension of\n\ta PLUS.\n\t(record_value_for_reg): If TEM is a binary operation with two CLOBBERs,\n\tuse one of the CLOBBERs instead.\n\t(if_then_else_cond): If comparing against zero, just return thing\n\tbeing compared.\n\n\t* optabs.c (expand_abs): If machine has MAX, ABS (x) is MAX (x, -x).\n\tDon't generate shifts and subtract if have conditional arithmetic.\n\n\t* rtl.h (delete_barrier): New declaration.\n\t* jump.c (jump_optimize): Set up to handle conditional call.\n\tIn conditional arithmetic case, handle CALL_INSN followed by a BARRIER.\n\t(delete_barrier): New function.\n\n\t* rtl.c (read_rtx): Call fatal if bad RTL code; check for bad mode.\n\n\t* recog.c (nonmemory_operand): Accept ADDRESSOF.\n\n\t* tree.c (build_type_attribute_variant): Push to obstack of\n\tttype around type_hash_canon call.\n\n\t* expr.c (placeholder_list): Move decl to file scope.\n\t(expand_expr): Don't force access to volatile just because its\n\taddress is taken.\n\tIf ignoring reference operations, just expand the operands.\n\t(expand_expr, case COMPONENT_REF): Propagate\n\tEXPAND_CONST_ADDRESS to recursive call when expanding inner.\n\tRefine test for using bitfield operations vs pointer punning.\n\t(expand_expr, case CONVERT_EXPR): If converting to\n\tBLKmode UNION_TYPE from BLKmode, just return inner object.\n\tUse proper mode in store_field call.\n\tProperly set sizes of object to store and total size in store_field\n\tcall for convert to union.\n\t(expand_expr, case ARRAY_REF): If OP0 is in a register, put it in\n\tmemory (like for ADDR_EXPR).  Also, don't put constant in register if\n\twe'll want it in memory.\n\t(readonly_fields_p): New function.\n\t(expand_expr, case INDIRECT_REF): Call it if LHS.\n\t(expand_assignment): Handle a RESULT_DECL where\n\tDECL_RTL is a PARALLEL.\n\t(do_jump, case WITH_RECORD_EXPR): New case.\n\t(get_inner_reference): Always go inside a CONVERT_EXPR\n\tand NOP_EXPR if both modes are the same.\n\t(store_field): Use bitfield operations if size of bitsize is not same\n\tas size of RHS's type.\n\tCheck for bitpos not a multiple of alignment in BLKmode case.\n\tDo block move in largest possible alignment.\n\t(store_constructor): Set BITSIZE to -1 for variable size and properly\n \tin case of array of BLKmode.\n\t(expand_expr_unaligned): New function.\n\t(do_compare_and_jump): Call it.\n\n\t* mips/iris5.h (SWITCHES_NEED_SPACES): New macro.\n\t* collect2.c (main): Only allow -ofoo if SWITCHES_NEED_SPACES\n\tdoes not include 'o'.\n\n\t* function.c (instantiate_virtual_regs_1, case SET): Handle case where\n\tboth SET_DEST and SET_SRC reference a virtual register.\n\t(gen_mem_addressof): Copy RTX_UNCHANGING_P from new REG to old REG.\n\n\t* integrate.c (expand_inline_function): Handle case of setting\n\tvirtual stack vars register (from built in setjmp); when parameter\n\tlives in memory, expand virtual_{stack_vars,incoming_args}_rtx early.\n\t(subst_constant): Add new parm, MEMONLY.\n\t(expand_inline_function, integrate_parm_decls): Pass new parm.\n\t(integrate_decl_tree): Likewise.\n\t(copy_rtx_and_substitute, case MEM): Do copy RTX_UNCHANGING_P.\n\t(try_constants): Call subst_constants twice, with MEMONLY 0 and 1.\n\t(copy_rtx_and_substitute, case SET): Add explicit calls to\n\tcopy_rtx_and_substitute for both sides.\n\n\t* stmt.c (expand_asm_operands): Don't use TREE_STRING_LENGTH for\n\tconstraints.\n\t(pushcase{,_range}): Convert to NOMINAL_TYPE after checking for\n\twithin INDEX_TYPE, instead of before.\n\t(fixup_gotos): Use f->target_rtl, not the next insn,\n\tsince latter may be from a later fixup.\n\t(expand_value_return): Correctly convert VAL when promoting function\n\treturn; support RETURN_REG being a PARALLEL.\n\t(expand_return): When checking for result in regs and having\n\tcleanup, consider PARALLEL in DECL_RTL as being in regs.\n\nFrom-SVN: r30299", "tree": {"sha": "58ab23a2ebe35102f1a66447caaf4626bb2b4641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58ab23a2ebe35102f1a66447caaf4626bb2b4641"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14a774a9d22db91fb6387cb8eb61060b61782f29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14a774a9d22db91fb6387cb8eb61060b61782f29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14a774a9d22db91fb6387cb8eb61060b61782f29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14a774a9d22db91fb6387cb8eb61060b61782f29/comments", "author": null, "committer": null, "parents": [{"sha": "8f65050e4185eaed8aa074387c3db51955ac806b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f65050e4185eaed8aa074387c3db51955ac806b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f65050e4185eaed8aa074387c3db51955ac806b"}], "stats": {"total": 3030, "additions": 2135, "deletions": 895}, "files": [{"sha": "7b779a2b4c2218cb635f397eeffc40bbf60117c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -184,6 +184,227 @@ Fri Oct 29 02:51:35 1999  Mark Mitchell  <mark@codesourcery.com>\n \t(pre_edge_insert): Free inserted.\n \t* stmt.c (free_stmt_status): Don't free NULL.\n \n+Fri Oct 29 15:25:07 1999  Arnaud Charlet  <charlet@ACT-Europe.FR>\n+\n+\t* gcov.c (DIR_SEPARATOR): Provide default.\n+\t(output_data): Add test for MS-DOS format absolute filename.\n+\t(fancy_abort): Correct program name.\n+\t(open_files): Open all files in binary mode.\n+\t* libgcc2.c (__bb_exit_func): Likewise.\n+\n+\t* profile.c (init_branch_prob): Specify binary when opening files.\n+\n+\t* flags.h (flag_unwind_tables): New decl.\n+\t* toplev.c (flag_unwind_table): New definition.\n+\t(f_options): Add -funwind-tables.\n+\t(decode_g_option): Clarify warning when unknown -g option is given.\n+\t(rest_of_compilation): If inside an inlined external function,\n+\tpretend we are just being declared.\n+\n+\t* dwarf2out.c (dwarf2out_do_frame): Check -funwind_tables.\n+\t(dwarf2out_frame_finish): Likewise.\n+\n+Fri Oct 29 06:32:44 1999  Geoffrey Keating  <geoffk@cygnus.com>\n+\n+\t* flow.c (propagate_block): When the last reference to a label\n+ \tbefore an ADDR_VEC is deleted because the reference is a dead\n+ \tstore, delete the ADDR_VEC.\n+\n+Fri Oct 29 07:44:26 1999  Vasco Pedro  <vp@di.fct.unl.pt>\n+\n+\t* fold-const.c (merge_ranges): In not in0, but in1, handle\n+\tupper bounds equal like subset case.\n+\n+Thu Oct 28 19:22:24 1999  Douglas Rupp <rupp@gnat.com>\n+\n+\t* dbxout.c (dbxout_parms): Generate a second stabs line for parameters\n+\tpassed in a register but moved to the stack.\n+\n+Thu Oct 28 19:12:57 1999  Sam Tardieu  <tardieu@act-europe.fr>\n+\n+\t* gcc.c (pass_exit_codes, greatest_status): New variables.\n+\t(struct option_map): Add entry for \"--pass-exit-codes\".\n+\t(execute): Update greatest_status if error.\n+\t(display_help): Add documentation for -pass-exit-codes.\n+\t(process_command): Handle -pass-exit-codes.\n+\t(main): Look at pass_exit_codes and greatest_status on call to exit.\n+\n+Thu Oct 28 18:06:50 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reload.c (find_reloads): Refine test for no input reload\n+\tcase to not includes reloads emitted after insn.\n+\n+\t* function.c (find_temp_slots_from_address): Handle sum involving\n+\ta register that points to a temp slot.\n+\t(update_temp_slot_address): Make recursive call if both old and\n+\tnew are PLUS with a common operand.\n+\t* calls.c (expand_call): Mark temp slot for result as having\n+\taddress taken.\n+\t\n+\t* rtlanal.c (reg_referenced_p, case IF_THEN_ELSE): New case.\n+\n+\t* gcc.c (process_command): Add standard_exec_prefix with \"GCC\"\n+\tcomponent as well as \"BINUTILS\".\n+\n+\t* integrate.h (copy_rtx_and_substitute): New arg, FOR_LHS.\n+\t* integrate.c (copy_rtx_and_substitute): Likewise.\n+\t(expand_inline_function, integrate_parm_decls, integrate_decl_tree):\n+\tAll callers changed.\n+\t* unroll.c (inital_reg_note_copy, copy_loop_body): Likewise.\n+\t\n+\t* dbxout.c (dbxout_type, case INTEGER_TYPE_NODE): If can use\n+\tgdb extensions, write size of type; also be more consistent\n+\tin using references when this is a subtype.\n+\n+\t* pa.md (extv, extzv, insv): Use define_expand to reject constant\n+\tthat is out of range.\n+\n+\t* loop.c (unknown_constant_address_altered): New variable.\n+\t(prescan_loop): Initialize it.\n+\t(note_addr_stored): Set it for RTX_UNCHANGING_P MEM.\n+\t(invariant_p, case MEM): Remove handling for volatile and readony;\n+\tcheck new variable if readonly.\n+\t(check_dbra_loop): Chdeck unknown_constant_address_altered.\n+\n+\t* cse.c (canon_hash, case MEM): Do not record if BLKmode.\n+\t(addr_affects_sp_p): Removed from note_mem_written and only\n+\tdefine #ifdef AUTO_INC_DEC.\n+\n+\t* alpha.c (input_operand, case ADDRESSOF): Treat as REG.\n+\n+\t* regclass.c (record_reg_classes): Properly handle register move\n+\tdirections.\n+\n+\t* varasm.c (initializer_constant_valid_p, case MINUS_EXPR):\n+\tDon't think valid if both operands are invalid.\n+\t(struct constant_descriptor): New field RTL.\n+\t(mark_const_hash_entry): Mark it.\n+\t(record_constant{,_rtx}): Initialize it.\n+\t(output_constant_def): Allocate RTL in permanent obstack and\n+\tsave in table.\n+\t({record,compare}_constant_1): Modes must match for\n+\tCONSTRUCTOR of ARRAY_TYPE.\n+\n+\t* c-common.h (initializer_constant_valid_p): Delete decl from here.\n+\t* output.h (initializer_constant_valid_p): Move decl to here.\n+\t* c-common.c (initializer_constant_valid_p): Delete function from here.\n+\t* varasm.c (initializer_constant_valid_p): Move function to here.\n+\n+\t* tree.h (STRIP_SIGN_NOPS): New macro.\n+\t* fold-const.c (optimize_minmax_comparison): New function.\n+\t(invert_truthvalue, case WITH_RECORD_EXPR): New case.\n+\t(fold): Use STRIP_SIGN_NOPS instead of STRIP_TYPE_NOPS.\n+\t(fold, case EQ_EXPR): Call optimize_minmax_comparison and add\n+\tcases with ABS_EXPR, NEGATE_EXPR, PLUS_EXPR, MINUS_EXPR, and\n+\twidening conversions.\n+\t(fold, case LE_EXPR): Rework changing unsigned to signed comparisons\n+\tto look at size of mode, not precision of type; also add missing cases.\n+\t(optimize_bit_field_compare, decode_field_reference): Don't try to\n+\toptimize COMPONENT_REF of a PLACEHOLDER_EXPR.\n+\n+\t* dwarf2out.c (ctype.h): Include.\n+\t(dwarf2out_set_demangle_name_func): New function.\n+\t(size_of_line_info): Deleted.\n+\t(output_line_info): Compute size of line info table from difference\n+\tof labels.\n+\t(base_type_die, add_name_attribute): Call demangle function, if any.\n+\t(field_byte_offset): Use bits per word for variable length fields.\n+\t(gen_array_type_die): Add array name.\n+\t(gen_subprogram_die): Ignore DECL_INLINE if -fno-inline.\n+\t(dwarf2out_add_library_unit_info): New function.\n+\n+\t* explow.c (set_stack_check_libfunc): New function.\n+\t(stack_check_libfunc): New static variable.\n+\t(probe_stack_range): Allow front-end to set up a libfunc to call.\n+\n+\t* combine.c (simplify_comparison): When making comparison in wider\n+\tmode, check for having commuted an AND and a SUBREG.\n+\t(contains_muldiv): New function.\n+\t(try_combine): Call it when dividing a PARALLEL.\n+\t(simplify_rtx, case TRUNCATE): Don't remove for umulsi3_highpart.\n+\t(simplify_comparison, case ASHIFTRT): Recognize sign-extension of\n+\ta PLUS.\n+\t(record_value_for_reg): If TEM is a binary operation with two CLOBBERs,\n+\tuse one of the CLOBBERs instead.\n+\t(if_then_else_cond): If comparing against zero, just return thing\n+\tbeing compared.\n+\n+\t* optabs.c (expand_abs): If machine has MAX, ABS (x) is MAX (x, -x).\n+\tDon't generate shifts and subtract if have conditional arithmetic.\n+\n+\t* rtl.h (delete_barrier): New declaration.\n+\t* jump.c (jump_optimize): Set up to handle conditional call.\n+\tIn conditional arithmetic case, handle CALL_INSN followed by a BARRIER.\n+\t(delete_barrier): New function.\n+\n+\t* rtl.c (read_rtx): Call fatal if bad RTL code; check for bad mode.\n+\n+\t* recog.c (nonmemory_operand): Accept ADDRESSOF.\n+\n+\t* tree.c (build_type_attribute_variant): Push to obstack of\n+\tttype around type_hash_canon call.\n+\n+\t* expr.c (placeholder_list): Move decl to file scope.\n+\t(expand_expr): Don't force access to volatile just because its\n+\taddress is taken.\n+\tIf ignoring reference operations, just expand the operands.\n+\t(expand_expr, case COMPONENT_REF): Propagate\n+\tEXPAND_CONST_ADDRESS to recursive call when expanding inner.\n+\tRefine test for using bitfield operations vs pointer punning.\n+\t(expand_expr, case CONVERT_EXPR): If converting to\n+\tBLKmode UNION_TYPE from BLKmode, just return inner object.\n+\tUse proper mode in store_field call.\n+\tProperly set sizes of object to store and total size in store_field\n+\tcall for convert to union.\n+\t(expand_expr, case ARRAY_REF): If OP0 is in a register, put it in\n+\tmemory (like for ADDR_EXPR).  Also, don't put constant in register if\n+\twe'll want it in memory.\n+\t(readonly_fields_p): New function.\n+\t(expand_expr, case INDIRECT_REF): Call it if LHS.\n+\t(expand_assignment): Handle a RESULT_DECL where\n+\tDECL_RTL is a PARALLEL.\n+\t(do_jump, case WITH_RECORD_EXPR): New case.\n+\t(get_inner_reference): Always go inside a CONVERT_EXPR\n+\tand NOP_EXPR if both modes are the same.\n+\t(store_field): Use bitfield operations if size of bitsize is not same\n+\tas size of RHS's type.\n+\tCheck for bitpos not a multiple of alignment in BLKmode case.\n+\tDo block move in largest possible alignment.\n+\t(store_constructor): Set BITSIZE to -1 for variable size and properly\n+ \tin case of array of BLKmode.\n+\t(expand_expr_unaligned): New function.\n+\t(do_compare_and_jump): Call it.\n+\n+\t* mips/iris5.h (SWITCHES_NEED_SPACES): New macro.\n+\t* collect2.c (main): Only allow -ofoo if SWITCHES_NEED_SPACES\n+\tdoes not include 'o'.\n+\n+\t* function.c (instantiate_virtual_regs_1, case SET): Handle case where\n+\tboth SET_DEST and SET_SRC reference a virtual register.\n+\t(gen_mem_addressof): Copy RTX_UNCHANGING_P from new REG to old REG.\n+\n+\t* integrate.c (expand_inline_function): Handle case of setting\n+\tvirtual stack vars register (from built in setjmp); when parameter\n+\tlives in memory, expand virtual_{stack_vars,incoming_args}_rtx early.\n+\t(subst_constant): Add new parm, MEMONLY.\n+\t(expand_inline_function, integrate_parm_decls): Pass new parm.\n+\t(integrate_decl_tree): Likewise.\n+\t(copy_rtx_and_substitute, case MEM): Do copy RTX_UNCHANGING_P.\n+\t(try_constants): Call subst_constants twice, with MEMONLY 0 and 1.\n+\t(copy_rtx_and_substitute, case SET): Add explicit calls to\n+\tcopy_rtx_and_substitute for both sides.\n+\n+\t* stmt.c (expand_asm_operands): Don't use TREE_STRING_LENGTH for\n+\tconstraints.\n+\t(pushcase{,_range}): Convert to NOMINAL_TYPE after checking for\n+\twithin INDEX_TYPE, instead of before.\n+\t(fixup_gotos): Use f->target_rtl, not the next insn,\n+\tsince latter may be from a later fixup.\n+\t(expand_value_return): Correctly convert VAL when promoting function\n+\treturn; support RETURN_REG being a PARALLEL.\n+\t(expand_return): When checking for result in regs and having\n+\tcleanup, consider PARALLEL in DECL_RTL as being in regs.\n+\n 1999-10-28 21:27 -0700  Zack Weinberg  <zack@bitmover.com>\n \n \t* cpplib.h (struct cpp_buffer: fname, nominal_fname,"}, {"sha": "71334a2176e6288629df86f7c094c455450bce0a", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -3845,161 +3845,6 @@ build_va_arg (expr, type)\n {\n   return build1 (VA_ARG_EXPR, type, expr);\n }\n-\n-/* Return nonzero if VALUE is a valid constant-valued expression\n-   for use in initializing a static variable; one that can be an\n-   element of a \"constant\" initializer.\n-\n-   Return null_pointer_node if the value is absolute;\n-   if it is relocatable, return the variable that determines the relocation.\n-   We assume that VALUE has been folded as much as possible;\n-   therefore, we do not need to check for such things as\n-   arithmetic-combinations of integers.  */\n-\n-tree\n-initializer_constant_valid_p (value, endtype)\n-     tree value;\n-     tree endtype;\n-{\n-  switch (TREE_CODE (value))\n-    {\n-    case CONSTRUCTOR:\n-      if ((TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n-\t   || TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE)\n-\t  && TREE_CONSTANT (value)\n-\t  && CONSTRUCTOR_ELTS (value))\n-\treturn\n-\t  initializer_constant_valid_p (TREE_VALUE (CONSTRUCTOR_ELTS (value)),\n-\t\t\t\t\tendtype);\n-\t\n-      return TREE_STATIC (value) ? null_pointer_node : 0;\n-\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case STRING_CST:\n-    case COMPLEX_CST:\n-      return null_pointer_node;\n-\n-    case ADDR_EXPR:\n-      return TREE_OPERAND (value, 0);\n-\n-    case NON_LVALUE_EXPR:\n-      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-    case CONVERT_EXPR:\n-    case NOP_EXPR:\n-      /* Allow conversions between pointer types.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (value))\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow conversions between real types.  */\n-      if (FLOAT_TYPE_P (TREE_TYPE (value))\n-\t  && FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow length-preserving conversions between integer types.  */\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0)))\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow conversions between other integer types only if\n-\t explicit value.  */\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\t{\n-\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t     endtype);\n-\t  if (inner == null_pointer_node)\n-\t    return null_pointer_node;\n-\t  break;\n-\t}\n-\n-      /* Allow (int) &foo provided int is as wide as a pointer.  */\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0)))\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-\n-      /* Likewise conversions from int to pointers, but also allow\n-\t conversions from 0.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (value))\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\t{\n-\t  if (integer_zerop (TREE_OPERAND (value, 0)))\n-\t    return null_pointer_node;\n-\t  else if (TYPE_PRECISION (TREE_TYPE (value))\n-\t\t   <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\t    return initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t endtype);\n-\t}\n-\n-      /* Allow conversions to union types if the value inside is okay.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-      break;\n-\n-    case PLUS_EXPR:\n-      if (! INTEGRAL_TYPE_P (endtype)\n-\t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n-        {\n-\t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t      endtype);\n-\t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t      endtype);\n-\t  /* If either term is absolute, use the other terms relocation.  */\n-\t  if (valid0 == null_pointer_node)\n-\t    return valid1;\n-\t  if (valid1 == null_pointer_node)\n-\t    return valid0;\n-        }\n-      break;\n-\n-    case MINUS_EXPR:\n-      if (! INTEGRAL_TYPE_P (endtype)\n-\t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n-\t{\n-\t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t      endtype);\n-\t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t      endtype);\n-\t  /* Win if second argument is absolute.  */\n-\t  if (valid1 == null_pointer_node)\n-\t    return valid0;\n-\t  /* Win if both arguments have the same relocation.\n-\t     Then the value is absolute.  */\n-\t  if (valid0 == valid1)\n-\t    return null_pointer_node;\n-\t}\n-\n-      /* Support differences between labels.  */\n-      if (INTEGRAL_TYPE_P (endtype))\n-\t{\n-\t  tree op0, op1;\n-\t  op0 = TREE_OPERAND (value, 0);\n-\t  op1 = TREE_OPERAND (value, 1);\n-\t  STRIP_NOPS (op0);\n-\t  STRIP_NOPS (op1);\n-\n-\t  if (TREE_CODE (op0) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (op0, 0)) == LABEL_DECL\n-\t      && TREE_CODE (op1) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (op1, 0)) == LABEL_DECL)\n-\t    return null_pointer_node;\n-\t}\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n \f\n /* Given a type, apply default promotions wrt unnamed function arguments\n    and return the new type.  Return NULL_TREE if no change.  */"}, {"sha": "03c533ddfc6cd4ca46d0c04643a8f636c04cae73", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -119,8 +119,6 @@ extern void c_common_nodes_and_builtins\t\tPROTO((int, int, int));\n \n extern tree build_va_arg\t\t\tPROTO((tree, tree));\n \n-extern tree initializer_constant_valid_p\tPROTO((tree, tree));\n-\n /* Nonzero if the type T promotes to itself.\n    ANSI C states explicitly the list of types that promote;\n    in particular, short promotes to int even if they have the same width.  */"}, {"sha": "15b64e0efd8cde32a222c915b2c7ee780af78475", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1763,6 +1763,7 @@ expand_call (exp, target, ignore)\n \t    d = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (exp));\n \t    DECL_RTL (d) = assign_temp (TREE_TYPE (exp), 1, 0, 1);\n \t    mark_addressable (d);\n+\t    mark_temp_addr_taken (DECL_RTL (d));\n \t    structure_value_addr = XEXP (DECL_RTL (d), 0);\n \t    TREE_USED (d) = 1;\n \t    target = 0;"}, {"sha": "e7be7acd3e93062237d5756d9bf37b396f2819a9", "filename": "gcc/collect2.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1200,7 +1200,12 @@ main (argc, argv)\n \t    case 'o':\n \t      if (arg[2] == '\\0')\n \t\toutput_file = *ld1++ = *ld2++ = *++argv;\n-\t      else\n+\t      else if (1\n+#ifdef SWITCHES_NEED_SPACES\n+\t\t       && ! index (SWITCHES_NEED_SPACES, arg[1])\n+#endif\n+\t\t       )\n+\n \t\toutput_file = &arg[2];\n \t      break;\n "}, {"sha": "dbae9dc4f8fcb1ff964ef4fbbd21640c8494567d", "filename": "gcc/combine.c", "status": "modified", "additions": 103, "deletions": 7, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -358,6 +358,7 @@ static void set_nonzero_bits_and_sign_copies  PROTO((rtx, rtx, void *));\n static int can_combine_p\tPROTO((rtx, rtx, rtx, rtx, rtx *, rtx *));\n static int sets_function_arg_p\tPROTO((rtx));\n static int combinable_i3pat\tPROTO((rtx, rtx *, rtx, rtx, int, rtx *));\n+static int contains_muldiv\tPROTO((rtx));\n static rtx try_combine\t\tPROTO((rtx, rtx, rtx));\n static void undo_all\t\tPROTO((void));\n static rtx *find_split_point\tPROTO((rtx *, rtx));\n@@ -1350,6 +1351,37 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n   return 1;\n }\n \f\n+/* Return 1 if X is an arithmetic expression that contains a multiplication\n+   and division.  We don't count multiplications by powers of two here.  */\n+\n+static int\n+contains_muldiv (x)\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case MOD:  case DIV:  case UMOD:  case UDIV:\n+      return 1;\n+\n+    case MULT:\n+      return ! (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t&& exact_log2 (INTVAL (XEXP (x, 1))) >= 0);\n+    default:\n+      switch (GET_RTX_CLASS (GET_CODE (x)))\n+\t{\n+\tcase 'c':  case '<':  case '2':\n+\t  return contains_muldiv (XEXP (x, 0))\n+\t    || contains_muldiv (XEXP (x, 1));\n+\n+\tcase '1':\n+\t  return contains_muldiv (XEXP (x, 0));\n+\n+\tdefault:\n+\t  return 0;\n+\t}\n+    }\n+}\n+\f\n /* Try to combine the insns I1 and I2 into I3.\n    Here I1 and I2 appear earlier than I3.\n    I1 can be zero; then we combine just I2 into I3.\n@@ -2201,7 +2233,9 @@ try_combine (i3, i2, i1)\n \t   && ! reg_referenced_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t  XVECEXP (newpat, 0, 0))\n \t   && ! reg_referenced_p (SET_DEST (XVECEXP (newpat, 0, 0)),\n-\t\t\t\t  XVECEXP (newpat, 0, 1)))\n+\t\t\t\t  XVECEXP (newpat, 0, 1))\n+\t   && ! (contains_muldiv (SET_SRC (XVECEXP (newpat, 0, 0)))\n+\t\t && contains_muldiv (SET_SRC (XVECEXP (newpat, 0, 1)))))\n     {\n       /* Normally, it doesn't matter which of the two is done first,\n \t but it does if one references cc0.  In that case, it has to\n@@ -3848,12 +3882,16 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \treturn SUBREG_REG (XEXP (x, 0));\n \n       /* If we know that the value is already truncated, we can\n-         replace the TRUNCATE with a SUBREG if TRULY_NOOP_TRUNCATION is\n-\t nonzero for the corresponding modes.  */\n+         replace the TRUNCATE with a SUBREG if TRULY_NOOP_TRUNCATION\n+         is nonzero for the corresponding modes.  But don't do this\n+         for an (LSHIFTRT (MULT ...)) since this will cause problems\n+         with the umulXi3_highpart patterns.  */\n       if (TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n \t\t\t\t GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))))\n \t  && num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n-\t     >= GET_MODE_BITSIZE (mode) + 1)\n+\t     >= GET_MODE_BITSIZE (mode) + 1\n+\t  && ! (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n+ \t\t&& GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT))\n \treturn gen_lowpart_for_combine (mode, XEXP (x, 0));\n \n       /* A truncate of a comparison can be replaced with a subreg if\n@@ -6898,10 +6936,19 @@ if_then_else_cond (x, ptrue, pfalse)\n   rtx cond0, cond1, true0, true1, false0, false1;\n   unsigned HOST_WIDE_INT nz;\n \n+  /* If we are comparing a value against zero, we are done.  */\n+  if ((code == NE || code == EQ)\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) == 0)\n+    {\n+      *ptrue = (code == NE) ? const1_rtx : const0_rtx;\n+      *pfalse = (code == NE) ? const0_rtx : const1_rtx;\n+      return XEXP (x, 0);\n+    }\n+\n   /* If this is a unary operation whose operand has one of two values, apply\n      our opcode to compute those values.  */\n-  if (GET_RTX_CLASS (code) == '1'\n-      && (cond0 = if_then_else_cond (XEXP (x, 0), &true0, &false0)) != 0)\n+  else if (GET_RTX_CLASS (code) == '1'\n+\t   && (cond0 = if_then_else_cond (XEXP (x, 0), &true0, &false0)) != 0)\n     {\n       *ptrue = gen_unary (code, mode, GET_MODE (XEXP (x, 0)), true0);\n       *pfalse = gen_unary (code, mode, GET_MODE (XEXP (x, 0)), false0);\n@@ -10459,6 +10506,32 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \n+\t  /* Likewise if OP0 is a PLUS of a sign extension with a\n+\t     constant, which is usually represented with the PLUS\n+\t     between the shifts.  */\n+\t  if (! unsigned_comparison_p\n+\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && GET_CODE (XEXP (op0, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (op0, 0), 1)) == CONST_INT\n+\t      && GET_CODE (XEXP (XEXP (op0, 0), 0)) == ASHIFT\n+\t      && XEXP (op0, 1) == XEXP (XEXP (XEXP (op0, 0), 0), 1)\n+\t      && (tmode = mode_for_size (mode_width - INTVAL (XEXP (op0, 1)),\n+\t\t\t\t\t MODE_INT, 1)) != BLKmode\n+\t      && ((unsigned HOST_WIDE_INT) const_op <= GET_MODE_MASK (tmode)\n+\t\t  || ((unsigned HOST_WIDE_INT) - const_op\n+\t\t      <= GET_MODE_MASK (tmode))))\n+\t    {\n+\t      rtx inner = XEXP (XEXP (XEXP (op0, 0), 0), 0);\n+\t      rtx add_const = XEXP (XEXP (op0, 0), 1);\n+\t      rtx new_const = gen_binary (ASHIFTRT, GET_MODE (op0), add_const,\n+\t\t\t\t\t  XEXP (op0, 1));\n+\n+\t      op0 = gen_binary (PLUS, tmode,\n+\t\t\t\tgen_lowpart_for_combine (tmode, inner),\n+\t\t\t\tnew_const);\n+\t      continue;\n+\t    }\n+\n \t  /* ... fall through ...  */\n \tcase LSHIFTRT:\n \t  /* If we have (compare (xshiftrt FOO N) (const_int C)) and\n@@ -10563,6 +10636,17 @@ simplify_comparison (code, pop0, pop1)\n \t\t  && (num_sign_bit_copies (op1, tmode)\n \t\t      > GET_MODE_BITSIZE (tmode) - GET_MODE_BITSIZE (mode))))\n \t    {\n+\t      /* If OP0 is an AND and we don't have an AND in MODE either,\n+\t\t make a new AND in the proper mode.  */\n+\t      if (GET_CODE (op0) == AND\n+\t\t  && (add_optab->handlers[(int) mode].insn_code\n+\t\t      == CODE_FOR_nothing))\n+\t\top0 = gen_binary (AND, tmode,\n+\t\t\t\t  gen_lowpart_for_combine (tmode,\n+\t\t\t\t\t\t\t   XEXP (op0, 0)),\n+\t\t\t\t  gen_lowpart_for_combine (tmode,\n+\t\t\t\t\t\t\t   XEXP (op0, 1)));\n+\n \t      op0 = gen_lowpart_for_combine (tmode, op0);\n \t      op1 = gen_lowpart_for_combine (tmode, op1);\n \t      break;\n@@ -10690,8 +10774,20 @@ record_value_for_reg (reg, insn, value)\n       subst_low_cuid = INSN_CUID (insn);\n       tem = get_last_value (reg);      \n \n+      /* If TEM is simply a binary operation with two CLOBBERs as operands,\n+\t it isn't going to be useful and will take a lot of time to process,\n+\t so just use the CLOBBER.  */\n+\n       if (tem)\n-\tvalue = replace_rtx (copy_rtx (value), reg, tem);\n+\t{\n+\t  if ((GET_RTX_CLASS (GET_CODE (tem)) == '2'\n+\t       || GET_RTX_CLASS (GET_CODE (tem)) == 'c')\n+\t      && GET_CODE (XEXP (tem, 0)) == CLOBBER\n+\t      && GET_CODE (XEXP (tem, 1)) == CLOBBER)\n+\t    tem = XEXP (tem, 0);\n+\n+\t  value = replace_rtx (copy_rtx (value), reg, tem);\n+\t}\n     }\n \n   /* For each register modified, show we don't know its value, that"}, {"sha": "48173db86f5c53636965c84b02df6f0946a48bc7", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -625,6 +625,7 @@ input_operand (op, mode)\n       return mode == ptr_mode || mode == DImode;\n \n     case REG:\n+    case ADDRESSOF:\n       return 1;\n \n     case SUBREG:"}, {"sha": "ad8f62825fd98468ab535ff6d6a54a29db9e9743", "filename": "gcc/config/mips/iris5.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fconfig%2Fmips%2Firis5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fconfig%2Fmips%2Firis5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis5.h?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -43,6 +43,9 @@ Boston, MA 02111-1307, USA.  */\n #define LD_INIT_SWITCH \"-init\"\n #define LD_FINI_SWITCH \"-fini\"\n \n+/* The linker needs a space after \"-o\".  */\n+#define SWITCHES_NEED_SPACES \"o\"\n+\n /* Specify wchar_t types.  */\n #undef\tWCHAR_TYPE\n #undef\tWCHAR_TYPE_SIZE"}, {"sha": "e26347b0d86fa5a23a8ea77fc7e8b8dcadb159e5", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -5106,7 +5106,20 @@\n   DONE;\n }\")\n \n-(define_insn \"extzv\"\n+(define_expand \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! uint5_operand (operands[2], SImode)\n+      ||  ! uint5_operand (operands[3], SImode))\n+  FAIL;\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n@@ -5126,7 +5139,20 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"extv\"\n+(define_expand \"extv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! uint5_operand (operands[2], SImode)\n+      ||  ! uint5_operand (operands[3], SImode))\n+  FAIL;\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n@@ -5146,7 +5172,20 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"insv\"\n+(define_expand \"insv\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 1 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\"))\n+\t(match_operand:SI 3 \"arith5_operand\" \"r,L\"))]\n+  \"\"\n+  \"\n+{\n+  if (! uint5_operand (operands[1], SImode)\n+      ||  ! uint5_operand (operands[2], SImode))\n+  FAIL;\n+}\")\n+\n+(define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r,r\")\n \t\t\t (match_operand:SI 1 \"uint5_operand\" \"\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\"))"}, {"sha": "e94851342dd083854bae2e21033b467a5ab78b66", "filename": "gcc/cse.c", "status": "modified", "additions": 132, "deletions": 129, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -291,13 +291,14 @@ static rtx this_insn;\n static int *reg_next_eqv;\n static int *reg_prev_eqv;\n \n-struct cse_reg_info {\n+struct cse_reg_info\n+{\n   /* The number of times the register has been altered in the current\n      basic block.  */\n   int reg_tick;\n \n   /* The next cse_reg_info structure in the free or used list.  */\n-  struct cse_reg_info* next;\n+  struct cse_reg_info *next;\n \n   /* The REG_TICK value at which rtx's containing this register are\n      valid in the hash table.  If this does not equal the current\n@@ -576,7 +577,8 @@ static int constant_pool_entries_cost;\n \n /* This data describes a block that will be processed by cse_basic_block.  */\n \n-struct cse_basic_block_data {\n+struct cse_basic_block_data\n+{\n   /* Lowest CUID value of insns in block.  */\n   int low_cuid;\n   /* Highest CUID value of insns in block.  */\n@@ -588,14 +590,15 @@ struct cse_basic_block_data {\n   /* Size of current branch path, if any.  */\n   int path_size;\n   /* Current branch path, indicating which branches will be taken.  */\n-  struct branch_path {\n-    /* The branch insn.  */\n-    rtx branch;\n-    /* Whether it should be taken or not.  AROUND is the same as taken\n-       except that it is used when the destination label is not preceded\n+  struct branch_path\n+    {\n+      /* The branch insn.  */\n+      rtx branch;\n+      /* Whether it should be taken or not.  AROUND is the same as taken\n+\t except that it is used when the destination label is not preceded\n        by a BARRIER.  */\n-    enum taken {TAKEN, NOT_TAKEN, AROUND} status;\n-  } path[PATHLENGTH];\n+      enum taken {TAKEN, NOT_TAKEN, AROUND} status;\n+    } path[PATHLENGTH];\n };\n \n /* Nonzero if X has the form (PLUS frame-pointer integer).  We check for\n@@ -692,7 +695,9 @@ static void record_jump_equiv\tPROTO((rtx, int));\n static void record_jump_cond\tPROTO((enum rtx_code, enum machine_mode,\n \t\t\t\t       rtx, rtx, int));\n static void cse_insn\t\tPROTO((rtx, rtx));\n-static int note_mem_written\tPROTO((rtx));\n+#ifdef AUTO_INC_DEC\n+static int addr_affects_sp_p\tPROTO((rtx));\n+#endif\n static void invalidate_from_clobbers PROTO((rtx));\n static rtx cse_process_notes\tPROTO((rtx, rtx));\n static void cse_around_loop\tPROTO((rtx));\n@@ -1721,21 +1726,18 @@ flush_hash_table ()\n \t  remove_from_table (p, i);\n       }\n }\n-\n-\n-/* Remove from the hash table, or mark as invalid,\n-   all expressions whose values could be altered by storing in X.\n-   X is a register, a subreg, or a memory reference with nonvarying address\n-   (because, when a memory reference with a varying address is stored in,\n-   all memory references are removed by invalidate_memory\n-   so specific invalidation is superfluous).\n-   FULL_MODE, if not VOIDmode, indicates that this much should be invalidated\n-   instead of just the amount indicated by the mode of X.  This is only used\n-   for bitfield stores into memory.\n-\n-   A nonvarying address may be just a register or just\n-   a symbol reference, or it may be either of those plus\n-   a numeric offset.  */\n+\f\n+/* Remove from the hash table, or mark as invalid, all expressions whose\n+   values could be altered by storing in X.  X is a register, a subreg, or\n+   a memory reference with nonvarying address (because, when a memory\n+   reference with a varying address is stored in, all memory references are\n+   removed by invalidate_memory so specific invalidation is superfluous).\n+   FULL_MODE, if not VOIDmode, indicates that this much should be\n+   invalidated instead of just the amount indicated by the mode of X.  This\n+   is only used for bitfield stores into memory.\n+\n+   A nonvarying address may be just a register or just a symbol reference,\n+   or it may be either of those plus a numeric offset.  */\n \n static void\n invalidate (x, full_mode)\n@@ -1745,130 +1747,118 @@ invalidate (x, full_mode)\n   register int i;\n   register struct table_elt *p;\n \n-  /* If X is a register, dependencies on its contents\n-     are recorded through the qty number mechanism.\n-     Just change the qty number of the register,\n-     mark it as invalid for expressions that refer to it,\n-     and remove it itself.  */\n-\n-  if (GET_CODE (x) == REG)\n+  switch (GET_CODE (x))\n     {\n-      register int regno = REGNO (x);\n-      register unsigned hash = HASH (x, GET_MODE (x));\n-\n-      /* Remove REGNO from any quantity list it might be on and indicate\n-\t that its value might have changed.  If it is a pseudo, remove its\n-\t entry from the hash table.\n+    case REG:\n+      {\n+\t/* If X is a register, dependencies on its contents are recorded\n+\t   through the qty number mechanism.  Just change the qty number of\n+\t   the register, mark it as invalid for expressions that refer to it,\n+\t   and remove it itself.  */\n+\tregister int regno = REGNO (x);\n+\tregister unsigned hash = HASH (x, GET_MODE (x));\n \n-\t For a hard register, we do the first two actions above for any\n-\t additional hard registers corresponding to X.  Then, if any of these\n-\t registers are in the table, we must remove any REG entries that\n-\t overlap these registers.  */\n+\t/* Remove REGNO from any quantity list it might be on and indicate\n+\t   that its value might have changed.  If it is a pseudo, remove its\n+\t   entry from the hash table.\n \n-      delete_reg_equiv (regno);\n-      REG_TICK (regno)++;\n+\t   For a hard register, we do the first two actions above for any\n+\t   additional hard registers corresponding to X.  Then, if any of these\n+\t   registers are in the table, we must remove any REG entries that\n+\t   overlap these registers.  */\n \n-      if (regno >= FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  /* Because a register can be referenced in more than one mode,\n-\t     we might have to remove more than one table entry.  */\n+\tdelete_reg_equiv (regno);\n+\tREG_TICK (regno)++;\n \n-\t  struct table_elt *elt;\n+\tif (regno >= FIRST_PSEUDO_REGISTER)\n+\t  {\n+\t    /* Because a register can be referenced in more than one mode,\n+\t       we might have to remove more than one table entry.  */\n+\t    struct table_elt *elt;\n \n-\t  while ((elt = lookup_for_remove (x, hash, GET_MODE (x))))\n-\t    remove_from_table (elt, hash);\n-\t}\n-      else\n-\t{\n-\t  HOST_WIDE_INT in_table\n-\t    = TEST_HARD_REG_BIT (hard_regs_in_table, regno);\n-\t  int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t  int tregno, tendregno;\n-\t  register struct table_elt *p, *next;\n+\t    while ((elt = lookup_for_remove (x, hash, GET_MODE (x))))\n+\t      remove_from_table (elt, hash);\n+\t  }\n+\telse\n+\t  {\n+\t    HOST_WIDE_INT in_table\n+\t      = TEST_HARD_REG_BIT (hard_regs_in_table, regno);\n+\t    int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t    int tregno, tendregno;\n+\t    register struct table_elt *p, *next;\n \n-\t  CLEAR_HARD_REG_BIT (hard_regs_in_table, regno);\n+\t    CLEAR_HARD_REG_BIT (hard_regs_in_table, regno);\n \n-\t  for (i = regno + 1; i < endregno; i++)\n-\t    {\n-\t      in_table |= TEST_HARD_REG_BIT (hard_regs_in_table, i);\n-\t      CLEAR_HARD_REG_BIT (hard_regs_in_table, i);\n-\t      delete_reg_equiv (i);\n-\t      REG_TICK (i)++;\n-\t    }\n+\t    for (i = regno + 1; i < endregno; i++)\n+\t      {\n+\t\tin_table |= TEST_HARD_REG_BIT (hard_regs_in_table, i);\n+\t\tCLEAR_HARD_REG_BIT (hard_regs_in_table, i);\n+\t\tdelete_reg_equiv (i);\n+\t\tREG_TICK (i)++;\n+\t      }\n \n-\t  if (in_table)\n-\t    for (hash = 0; hash < NBUCKETS; hash++)\n-\t      for (p = table[hash]; p; p = next)\n-\t\t{\n-\t\t  next = p->next_same_hash;\n+\t    if (in_table)\n+\t      for (hash = 0; hash < NBUCKETS; hash++)\n+\t\tfor (p = table[hash]; p; p = next)\n+\t\t  {\n+\t\t    next = p->next_same_hash;\n \n \t\t  if (GET_CODE (p->exp) != REG\n \t\t      || REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n \t\t    continue;\n-\n-\t\t  tregno = REGNO (p->exp);\n-\t\t  tendregno\n-\t\t    = tregno + HARD_REGNO_NREGS (tregno, GET_MODE (p->exp));\n-\t\t  if (tendregno > regno && tregno < endregno)\n-\t\t    remove_from_table (p, hash);\n-\t\t}\n-\t}\n-\n+\t\t  \n+\t\t    tregno = REGNO (p->exp);\n+\t\t    tendregno\n+\t\t      = tregno + HARD_REGNO_NREGS (tregno, GET_MODE (p->exp));\n+\t\t    if (tendregno > regno && tregno < endregno)\n+\t\t      remove_from_table (p, hash);\n+\t\t  }\n+\t  }\n+      }\n       return;\n-    }\n \n-  if (GET_CODE (x) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (x)) != REG)\n-\tabort ();\n+    case SUBREG:\n       invalidate (SUBREG_REG (x), VOIDmode);\n       return;\n-    }\n-\n-  /* If X is a parallel, invalidate all of its elements.  */\n \n-  if (GET_CODE (x) == PARALLEL)\n-    {\n+    case PARALLEL:\n       for (i = XVECLEN (x, 0) - 1; i >= 0 ; --i)\n \tinvalidate (XVECEXP (x, 0, i), VOIDmode);\n       return;\n-    }\n \n-  /* If X is an expr_list, this is part of a disjoint return value;\n-     extract the location in question ignoring the offset.  */\n-\n-  if (GET_CODE (x) == EXPR_LIST)\n-    {\n+    case EXPR_LIST:\n+      /* This is part of a disjoint return value; extract the location in\n+\t question ignoring the offset.  */\n       invalidate (XEXP (x, 0), VOIDmode);\n       return;\n-    }\n-\n-  /* X is not a register; it must be a memory reference with\n-     a nonvarying address.  Remove all hash table elements\n-     that refer to overlapping pieces of memory.  */\n \n-  if (GET_CODE (x) != MEM)\n-    abort ();\n-\n-  if (full_mode == VOIDmode)\n-    full_mode = GET_MODE (x);\n+    case MEM:\n+      /* Remove all hash table elements that refer to overlapping pieces of\n+\t memory.  */\n+      if (full_mode == VOIDmode)\n+\tfull_mode = GET_MODE (x);\n \n-  for (i = 0; i < NBUCKETS; i++)\n-    {\n-      register struct table_elt *next;\n-      for (p = table[i]; p; p = next)\n+      for (i = 0; i < NBUCKETS; i++)\n \t{\n-\t  next = p->next_same_hash;\n-\t  /* Invalidate ASM_OPERANDS which reference memory (this is easier\n-\t     than checking all the aliases).  */\n-\t  if (p->in_memory\n-\t      && (GET_CODE (p->exp) != MEM\n-\t\t  || true_dependence (x, full_mode, p->exp, cse_rtx_varies_p)))\n-\t    remove_from_table (p, i);\n+\t  register struct table_elt *next;\n+\n+\t  for (p = table[i]; p; p = next)\n+\t    {\n+\t      next = p->next_same_hash;\n+\t      if (p->in_memory\n+\t\t  && (GET_CODE (p->exp) != MEM\n+\t\t      || true_dependence (x, full_mode, p->exp,\n+\t\t\t\t\t  cse_rtx_varies_p)))\n+\t\tremove_from_table (p, i);\n+\t    }\n \t}\n+      return;\n+\n+    default:\n+      abort ();\n     }\n }\n-\n+\f\n /* Remove all expressions that refer to register REGNO,\n    since they are already invalid, and we are about to\n    mark that register valid again and don't want the old\n@@ -2215,7 +2205,9 @@ canon_hash (x, mode)\n       return hash;\n \n     case MEM:\n-      if (MEM_VOLATILE_P (x))\n+      /* We don't record if marked volatile or if BLKmode since we don't\n+\t know the size of the move.  */\n+      if (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode)\n \t{\n \t  do_not_record = 1;\n \t  return 0;\n@@ -6171,6 +6163,7 @@ cse_insn (insn, libcall_insn)\n }\n \f\n /* Remove from the hash table all expressions that reference memory.  */\n+\n static void\n invalidate_memory ()\n {\n@@ -6186,13 +6179,15 @@ invalidate_memory ()\n       }\n }\n \n-/* XXX ??? The name of this function bears little resemblance to\n-   what this function actually does.  FIXME.  */\n+#ifdef AUTO_INC_DEC\n+\n+/* If ADDR is an address that implicitly affects the stack pointer, return\n+   1 and update the register tables to show the effect.  Else, return 0.  */\n+\n static int\n-note_mem_written (addr)\n+addr_affects_sp_p (addr)\n      register rtx addr;\n {\n-  /* Pushing or popping the stack invalidates just the stack pointer.  */\n   if ((GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n        || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n       && GET_CODE (XEXP (addr, 0)) == REG\n@@ -6204,10 +6199,13 @@ note_mem_written (addr)\n       /* This should be *very* rare.  */\n       if (TEST_HARD_REG_BIT (hard_regs_in_table, STACK_POINTER_REGNUM))\n \tinvalidate (stack_pointer_rtx, VOIDmode);\n+\n       return 1;\n     }\n+\n   return 0;\n }\n+#endif\n \n /* Perform invalidation on the basis of everything about an insn\n    except for invalidating the actual places that are SET in it.\n@@ -6432,7 +6430,9 @@ invalidate_skipped_set (dest, set, data)\n   enum rtx_code code = GET_CODE (dest);\n \n   if (code == MEM\n-      && ! note_mem_written (dest)\t/* If this is not a stack push ... */\n+#ifdef AUTO_INC_DEC\n+      && ! addr_affects_sp_p (dest)\t/* If this is not a stack push ... */\n+#endif\n       /* There are times when an address can appear varying and be a PLUS\n \t during this scan when it would be a fixed address were we to know\n \t the proper equivalences.  So invalidate all memory if there is\n@@ -6605,10 +6605,13 @@ cse_set_around_loop (x, insn, loop_start)\n \t    }\n     }\n \n-  /* Now invalidate anything modified by X.  */\n-  note_mem_written (SET_DEST (x));\n+#ifdef AUTO_INC_DEC\n+  /* Deal with the destination of X affecting the stack pointer.  */\n+  addr_affects_sp_p (SET_DEST (x));\n+#endif\n \n-  /* See comment on similar code in cse_insn for explanation of these tests.  */\n+  /* See comment on similar code in cse_insn for explanation of these\n+     tests.  */\n   if (GET_CODE (SET_DEST (x)) == REG || GET_CODE (SET_DEST (x)) == SUBREG\n       || GET_CODE (SET_DEST (x)) == MEM)\n     invalidate (SET_DEST (x), VOIDmode);"}, {"sha": "5357b02338c5144218712a899ad2c68800962cd1", "filename": "gcc/dbxout.c", "status": "modified", "additions": 66, "deletions": 22, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1153,25 +1153,48 @@ dbxout_type (type, full, show_arg_types)\n \t  dbxout_type_index (type);\n \t  fprintf (asmfile, \";0;127;\");\n \t}\n-      /* This used to check if the type's precision was more than\n-\t HOST_BITS_PER_WIDE_INT.  That is wrong since gdb uses a\n-\t long (it has no concept of HOST_BITS_PER_WIDE_INT).  */\n-      else if (use_gnu_debug_info_extensions\n-\t       && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)\n-\t\t   || TYPE_PRECISION (type) >= HOST_BITS_PER_LONG))\n-\t{\n-\t  /* This used to say `r1' and we used to take care\n-\t     to make sure that `int' was type number 1.  */\n-\t  fprintf (asmfile, \"r\");\n-\t  dbxout_type_index (integer_type_node);\n-\t  fprintf (asmfile, \";\");\n-\t  print_int_cst_octal (TYPE_MIN_VALUE (type));\n-\t  fprintf (asmfile, \";\");\n-\t  print_int_cst_octal (TYPE_MAX_VALUE (type));\n-\t  fprintf (asmfile, \";\");\n-\t}\n-      else /* Output other integer types as subranges of `int'.  */\n+\n+      /* If this is a subtype of another integer type, always prefer to\n+\t write it as a subtype.  */\n+      else if (TREE_TYPE (type) != 0\n+\t       && TREE_CODE (TREE_TYPE (type)) == INTEGER_CST)\n \tdbxout_range_type (type);\n+\n+      else\n+  \t{\n+\t  /* If the size is non-standard, say what it is if we can use\n+\t     GDB extensions.  */\n+\n+\t  if (use_gnu_debug_info_extensions\n+\t      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n+\t    fprintf (asmfile, \"@s%d;\", TYPE_PRECISION (type));\n+\n+\t  /* If we can use GDB extensions and the size is wider than a\n+\t     long (the size used by GDB to read them) or we may have\n+\t     trouble writing the bounds the usual way, write them in\n+\t     octal.  Note the test is for the *target's* size of \"long\",\n+\t     not that of the host.  The host test is just to make sure we\n+\t     can write it out in case the host wide int is narrower than the\n+\t     target \"long\".  */\n+\n+ \t  if (use_gnu_debug_info_extensions\n+\t      && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)\n+\t\t  || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT))\n+\t    {\n+\t      fprintf (asmfile, \"r\");\n+\t      dbxout_type_index (type);\n+\t      fprintf (asmfile, \";\");\n+\t      print_int_cst_octal (TYPE_MIN_VALUE (type));\n+\t      fprintf (asmfile, \";\");\n+\t      print_int_cst_octal (TYPE_MAX_VALUE (type));\n+\t      fprintf (asmfile, \";\");\n+\t    }\n+\n+\t  else\n+\t    /* Output other integer types as subranges of `int'.  */\n+\t    dbxout_range_type (type);\n+  \t}\n+\n       CHARS (22);\n       break;\n \n@@ -2427,17 +2450,26 @@ dbxout_parms (parms)\n \t\t && ! CONSTANT_P (XEXP (DECL_RTL (parms), 0)))\n \t  {\n \t    /* Parm was passed in registers but lives on the stack.  */\n+\t    int aux_sym_value = 0;\n \n \t    current_sym_code = N_PSYM;\n \t    /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))),\n \t       in which case we want the value of that CONST_INT,\n \t       or (MEM (REG ...)) or (MEM (MEM ...)),\n \t       in which case we use a value of zero.  */\n-\t    if (GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG\n-\t\t|| GET_CODE (XEXP (DECL_RTL (parms), 0)) == MEM)\n+\t    if (GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG)\n \t      current_sym_value = 0;\n+\t    else if (GET_CODE (XEXP (DECL_RTL (parms), 0)) == MEM)\n+\t      {\n+\t\t/* Remember the location on the stack the parm is moved to */\n+\t        aux_sym_value\n+\t\t  = INTVAL (XEXP (XEXP (XEXP (DECL_RTL (parms), 0), 0), 1));\n+\t        current_sym_value = 0;\n+\t      }\n \t    else\n-\t      current_sym_value = INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1));\n+\t\tcurrent_sym_value\n+\t\t  = INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1));\n+\n \t    current_sym_addr = 0;\n \n \t    /* Make a big endian correction if the mode of the type of the\n@@ -2452,7 +2484,8 @@ dbxout_parms (parms)\n \t    FORCE_TEXT;\n \t    if (DECL_NAME (parms))\n \t      {\n-\t\tcurrent_sym_nchars = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t\tcurrent_sym_nchars\n+\t\t  = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n \n \t\tfprintf (asmfile, \"%s \\\"%s:%c\", ASM_STABS_OP,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n@@ -2470,6 +2503,17 @@ dbxout_parms (parms)\n \t\t\t\t     XEXP (DECL_RTL (parms), 0));\n \t    dbxout_type (TREE_TYPE (parms), 0, 0);\n \t    dbxout_finish_symbol (parms);\n+\t    if (aux_sym_value != 0)\n+\t      {\n+\t\t/* Generate an entry for the stack location */\n+\n+\t\tfprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t\tcurrent_sym_value = aux_sym_value;\n+\t        current_sym_code = N_LSYM;\n+\t        dbxout_type (build_reference_type (TREE_TYPE (parms)), 0, 0);\n+\t        dbxout_finish_symbol (parms);\n+\t      }\n \t  }\n       }\n }"}, {"sha": "08b957d24bbe5f489ae424289251865ab8a9ee30", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 63, "deletions": 174, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -44,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"dwarf2out.h\"\n #include \"toplev.h\"\n #include \"dyn-string.h\"\n+#include <ctype.h>\n \n /* We cannot use <assert.h> in GCC source, since that would include\n    GCC's assert.h, which may not be compatible with the host compiler.  */\n@@ -65,6 +66,7 @@ dwarf2out_do_frame ()\n           || DWARF2_FRAME_INFO\n #endif\n #ifdef DWARF2_UNWIND_INFO\n+\t  || flag_unwind_tables\n \t  || (flag_exceptions && ! exceptions_via_longjmp)\n #endif\n \t  );\n@@ -1904,11 +1906,11 @@ dwarf2out_frame_finish ()\n #ifdef MIPS_DEBUGGING_INFO\n   if (write_symbols == DWARF2_DEBUG)\n     output_call_frame_info (0);\n-  if (flag_exceptions && ! exceptions_via_longjmp)\n+  if (flag_unwind_tables || (flag_exceptions && ! exceptions_via_longjmp))\n     output_call_frame_info (1);\n #else\n   if (write_symbols == DWARF2_DEBUG\n-      || (flag_exceptions && ! exceptions_via_longjmp))\n+      || flag_unwind_tables || (flag_exceptions && ! exceptions_via_longjmp))\n     output_call_frame_info (1);  \n #endif\n }  \n@@ -2441,7 +2443,6 @@ static int constant_size\t\tPROTO((long unsigned));\n static unsigned long size_of_die\tPROTO((dw_die_ref));\n static void calc_die_sizes\t\tPROTO((dw_die_ref));\n static unsigned long size_of_line_prolog\tPROTO((void));\n-static unsigned long size_of_line_info\tPROTO((void));\n static unsigned long size_of_pubnames\tPROTO((void));\n static unsigned long size_of_aranges\tPROTO((void));\n static enum dwarf_form value_format\tPROTO((dw_val_ref));\n@@ -2655,6 +2656,18 @@ static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   while (0)\n #endif\n \f\n+/* We allow a language front-end to designate a function that is to be\n+   called to \"demangle\" any name before it it put into a DIE.  */\n+\n+static char *(*demangle_name_func) PROTO((char *));\n+\n+void\n+dwarf2out_set_demangle_name_func (func)\n+     char *(*func) PROTO((char *));\n+{\n+  demangle_name_func = func;\n+}\n+\f\n /* Convert an integer constant expression into assembler syntax.  Addition\n    and subtraction are the only arithmetic that may appear in these\n    expressions.   This is an adaptation of output_addr_const in final.c.\n@@ -4720,165 +4733,6 @@ size_of_line_prolog ()\n   return size;\n }\n \n-/* Return the size of the line information generated for this\n-   compilation unit.  */\n-\n-static unsigned long\n-size_of_line_info ()\n-{\n-  register unsigned long size;\n-  register unsigned long lt_index;\n-  register unsigned long current_line;\n-  register long line_offset;\n-  register long line_delta;\n-  register unsigned long current_file;\n-  register unsigned long function;\n-  unsigned long size_of_set_address;\n-\n-  /* Size of a DW_LNE_set_address instruction.  */\n-  size_of_set_address = 1 + size_of_uleb128 (1 + PTR_SIZE) + 1 + PTR_SIZE;\n-\n-  /* Version number.  */\n-  size = 2;\n-\n-  /* Prolog length specifier.  */\n-  size += DWARF_OFFSET_SIZE;\n-\n-  /* Prolog.  */\n-  size += size_of_line_prolog ();\n-\n-  current_file = 1;\n-  current_line = 1;\n-  for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n-    {\n-      register dw_line_info_ref line_info = &line_info_table[lt_index];\n-\n-      if (line_info->dw_line_num == current_line\n-\t  && line_info->dw_file_num == current_file)\n-\tcontinue;\n-\n-      /* Advance pc instruction.  */\n-      /* ??? See the DW_LNS_advance_pc comment in output_line_info.  */\n-      if (0)\n-\tsize += 1 + 2;\n-      else\n-\tsize += size_of_set_address;\n-\n-      if (line_info->dw_file_num != current_file)\n-\t{\n-\t  /* Set file number instruction.  */\n-\t  size += 1;\n-\t  current_file = line_info->dw_file_num;\n-\t  size += size_of_uleb128 (current_file);\n-\t}\n-\n-      if (line_info->dw_line_num != current_line)\n-\t{\n-\t  line_offset = line_info->dw_line_num - current_line;\n-\t  line_delta = line_offset - DWARF_LINE_BASE;\n-\t  current_line = line_info->dw_line_num;\n-\t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n-\t    /* 1-byte special line number instruction.  */\n-\t    size += 1;\n-\t  else\n-\t    {\n-\t      /* Advance line instruction.  */\n-\t      size += 1;\n-\t      size += size_of_sleb128 (line_offset);\n-\t      /* Generate line entry instruction.  */\n-\t      size += 1;\n-\t    }\n-\t}\n-    }\n-\n-  /* Advance pc instruction.  */\n-  if (0)\n-    size += 1 + 2;\n-  else\n-    size += size_of_set_address;\n-\n-  /* End of line number info. marker.  */\n-  size += 1 + size_of_uleb128 (1) + 1;\n-\n-  function = 0;\n-  current_file = 1;\n-  current_line = 1;\n-  for (lt_index = 0; lt_index < separate_line_info_table_in_use; )\n-    {\n-      register dw_separate_line_info_ref line_info\n-\t= &separate_line_info_table[lt_index];\n-\n-      if (line_info->dw_line_num == current_line\n-\t  && line_info->dw_file_num == current_file\n-\t  && line_info->function == function)\n-\tgoto cont;\n-\n-      if (function != line_info->function)\n-\t{\n-\t  function = line_info->function;\n-\t  /* Set address register instruction.  */\n-\t  size += size_of_set_address;\n-\t}\n-      else\n-\t{\n-\t  /* Advance pc instruction.  */\n-\t  if (0)\n-\t    size += 1 + 2;\n-\t  else\n-\t    size += size_of_set_address;\n-\t}\n-\n-      if (line_info->dw_file_num != current_file)\n-\t{\n-\t  /* Set file number instruction.  */\n-\t  size += 1;\n-\t  current_file = line_info->dw_file_num;\n-\t  size += size_of_uleb128 (current_file);\n-\t}\n-\n-      if (line_info->dw_line_num != current_line)\n-\t{\n-\t  line_offset = line_info->dw_line_num - current_line;\n-\t  line_delta = line_offset - DWARF_LINE_BASE;\n-\t  current_line = line_info->dw_line_num;\n-\t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n-\t    /* 1-byte special line number instruction.  */\n-\t    size += 1;\n-\t  else\n-\t    {\n-\t      /* Advance line instruction.  */\n-\t      size += 1;\n-\t      size += size_of_sleb128 (line_offset);\n-\n-\t      /* Generate line entry instruction.  */\n-\t      size += 1;\n-\t    }\n-\t}\n-\n-    cont:\n-      ++lt_index;\n-\n-      /* If we're done with a function, end its sequence.  */\n-      if (lt_index == separate_line_info_table_in_use\n-\t  || separate_line_info_table[lt_index].function != function)\n-\t{\n-\t  current_file = 1;\n-\t  current_line = 1;\n-\n-\t  /* Advance pc instruction.  */\n-\t  if (0)\n-\t    size += 1 + 2;\n-\t  else\n-\t    size += size_of_set_address;\n-\n-\t  /* End of line number info. marker.  */\n-\t  size += 1 + size_of_uleb128 (1) + 1;\n-\t}\n-    }\n-\n-  return size;\n-}\n-\n /* Return the size of the .debug_pubnames table  generated for the\n    compilation unit.  */\n \n@@ -5650,10 +5504,7 @@ output_aranges ()\n }\n \n /* Output the source line number correspondence information.  This\n-   information goes into the .debug_line section.\n-\n-   If the format of this data changes, then the function size_of_line_info\n-   must also be adjusted the same way.  */\n+   information goes into the .debug_line section.  */\n \n static void\n output_line_info ()\n@@ -5670,12 +5521,13 @@ output_line_info ()\n   register unsigned long current_file;\n   register unsigned long function;\n \n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, size_of_line_info ());\n+  ASM_OUTPUT_DWARF_DELTA (asm_out_file, \".LTEND\", \".LTSTART\");\n   if (flag_debug_asm)\n     fprintf (asm_out_file, \"\\t%s Length of Source Line Info.\",\n \t     ASM_COMMENT_START);\n \n   fputc ('\\n', asm_out_file);\n+  ASM_OUTPUT_LABEL (asm_out_file, \".LTSTART\");\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, DWARF_VERSION);\n   if (flag_debug_asm)\n     fprintf (asm_out_file, \"\\t%s DWARF Version\", ASM_COMMENT_START);\n@@ -5932,6 +5784,7 @@ output_line_info ()\n     }\n \n   /* Output the marker for the end of the line number info.  */\n+  ASM_OUTPUT_LABEL (asm_out_file, \".LTEND\");\n   ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n   if (flag_debug_asm)\n     fprintf (asm_out_file, \"\\t%s DW_LNE_end_sequence\", ASM_COMMENT_START);\n@@ -6234,6 +6087,9 @@ base_type_die (type)\n     }\n \n   base_type_result = new_die (DW_TAG_base_type, comp_unit_die);\n+  if (demangle_name_func)\n+    type_name = (*demangle_name_func) (type_name);\n+\n   add_AT_string (base_type_result, DW_AT_name, type_name);\n   add_AT_unsigned (base_type_result, DW_AT_byte_size,\n \t\t   int_size_in_bytes (type));\n@@ -6774,17 +6630,20 @@ field_byte_offset (decl)\n   bitpos_tree = DECL_FIELD_BITPOS (decl);\n   field_size_tree = DECL_SIZE (decl);\n \n-  /* We cannot yet cope with fields whose positions or sizes are variable, so \n+  /* We cannot yet cope with fields whose positions are variable, so \n      for now, when we see such things, we simply return 0.  Someday, we may\n      be able to handle such cases, but it will be damn difficult.  */\n   if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n     return 0;\n+\n   bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n \n-  if (TREE_CODE (field_size_tree) != INTEGER_CST)\n-    return 0;\n+    /* If we don't know the size of the field, pretend it's a full word.  */\n+  if (TREE_CODE (field_size_tree) == INTEGER_CST)\n+    field_size_in_bits = (unsigned) TREE_INT_CST_LOW (field_size_tree);\n+  else\n+    field_size_in_bits = BITS_PER_WORD;\n \n-  field_size_in_bits = (unsigned) TREE_INT_CST_LOW (field_size_tree);\n   type_size_in_bits = simple_type_size_in_bits (type);\n   type_align_in_bits = simple_type_align_in_bits (type);\n   type_align_in_bytes = type_align_in_bits / BITS_PER_UNIT;\n@@ -7229,7 +7088,12 @@ add_name_attribute (die, name_string)\n      register const char *name_string;\n {\n   if (name_string != NULL && *name_string != 0)\n-    add_AT_string (die, DW_AT_name, name_string);\n+    {\n+      if (demangle_name_func)\n+\tname_string = (*demangle_name_func) (name_string);\n+\n+      add_AT_string (die, DW_AT_name, name_string);\n+    }\n }\n \n /* Given a tree node describing an array bound (either lower or upper) output\n@@ -7923,6 +7787,7 @@ gen_array_type_die (type, context_die)\n #endif\n     add_subscript_info (array_die, type);\n \n+  add_name_attribute (array_die, type_tag (type));\n   equate_type_number_to_die (type, array_die);\n \n   /* Add representation of the type of the elements of this array type.  */\n@@ -8422,13 +8287,13 @@ gen_subprogram_die (decl, context_die)\n \t inline is not saved anywhere.  */\n       if (DECL_DEFER_OUTPUT (decl))\n \t{\n-\t  if (DECL_INLINE (decl))\n+\t  if (DECL_INLINE (decl) && !flag_no_inline)\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_inlined);\n \t  else\n \t    add_AT_unsigned (subr_die, DW_AT_inline,\n \t\t\t     DW_INL_declared_not_inlined);\n \t}\n-      else if (DECL_INLINE (decl))\n+      else if (DECL_INLINE (decl) && !flag_no_inline)\n \tadd_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n       else\n \tabort ();\n@@ -9577,6 +9442,30 @@ gen_decl_die (decl, context_die)\n     }\n }\n \f\n+/* Add Ada \"use\" clause information for SGI Workshop debugger.  */\n+\n+void\n+dwarf2out_add_library_unit_info (filename, context_list)\n+     char *filename;\n+     char *context_list;\n+{\n+  unsigned int file_index;\n+\n+  if (filename != NULL)\n+    {\n+      dw_die_ref unit_die = new_die (DW_TAG_module, comp_unit_die);\n+      tree context_list_decl \n+\t= build_decl (LABEL_DECL, get_identifier (context_list),\n+\t\t      void_type_node);\n+\n+      TREE_PUBLIC (context_list_decl) = TRUE;\n+      add_name_attribute (unit_die, context_list);\n+      file_index = lookup_filename (filename);\n+      add_AT_unsigned (unit_die, DW_AT_decl_file, file_index);\n+      add_pubname (context_list_decl, unit_die);\n+    }\n+}\n+\n /* Write the debugging output for DECL.  */\n \n void"}, {"sha": "857bcc656bf4480a930c5554f722255dc9174169", "filename": "gcc/explow.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1379,6 +1379,19 @@ allocate_dynamic_stack_space (size, target, known_align)\n   return target;\n }\n \f\n+/* A front end may want to override GCC's stack checking by providing a \n+   run-time routine to call to check the stack, so provide a mechanism for\n+   calling that routine.  */\n+\n+static rtx stack_check_libfunc;\n+\n+void\n+set_stack_check_libfunc (libfunc)\n+     rtx libfunc;\n+{\n+  stack_check_libfunc = libfunc;\n+}\n+\f\n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n \n static void\n@@ -1412,9 +1425,19 @@ probe_stack_range (first, size)\n      HOST_WIDE_INT first;\n      rtx size;\n {\n-  /* First see if we have an insn to check the stack.  Use it if so.  */\n+  /* First see if the front end has set up a function for us to call to\n+     check the stack.  */\n+  if (stack_check_libfunc != 0)\n+    emit_library_call (stack_check_libfunc, 0, VOIDmode, 1,\n+\t\t       memory_address (QImode,\n+\t\t\t\t       gen_rtx (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\tplus_constant (size, first))),\n+\t\t       ptr_mode);\n+\n+  /* Next see if we have an insn to check the stack.  Use it if so.  */\n #ifdef HAVE_check_stack\n-  if (HAVE_check_stack)\n+  else if (HAVE_check_stack)\n     {\n       insn_operand_predicate_fn pred;\n       rtx last_addr\n@@ -1428,14 +1451,13 @@ probe_stack_range (first, size)\n \tlast_addr = copy_to_mode_reg (Pmode, last_addr);\n \n       emit_insn (gen_check_stack (last_addr));\n-      return;\n     }\n #endif\n \n   /* If we have to generate explicit probes, see if we have a constant\n      small number of them to generate.  If so, that's the easy case.  */\n-  if (GET_CODE (size) == CONST_INT\n-      && INTVAL (size) < 10 * STACK_CHECK_PROBE_INTERVAL)\n+  else if (GET_CODE (size) == CONST_INT\n+\t   && INTVAL (size) < 10 * STACK_CHECK_PROBE_INTERVAL)\n     {\n       HOST_WIDE_INT offset;\n "}, {"sha": "59ae687c5d872599eee73e23cfe399e6984f7011", "filename": "gcc/expr.c", "status": "modified", "additions": 414, "deletions": 39, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -90,6 +90,9 @@ int do_preexpand_calls = 1;\n    infinite recursion.  */\n static int in_check_memory_usage;\n \n+/* Chain of pending expressions for PLACEHOLDER_EXPR to replace.  */\n+static tree placeholder_list = 0;\n+\n /* This structure is used by move_by_pieces to describe the move to\n    be performed.  */\n struct move_by_pieces\n@@ -153,6 +156,8 @@ static tree init_noncopied_parts PROTO((tree, tree));\n static int safe_from_p\t\tPROTO((rtx, tree, int));\n static int fixed_type_p\t\tPROTO((tree));\n static rtx var_rtx\t\tPROTO((tree));\n+static int readonly_fields_p\tPROTO((tree));\n+static rtx expand_expr_unaligned PROTO((tree, int *));\n static rtx expand_increment\tPROTO((tree, int, int));\n static void preexpand_calls\tPROTO((tree));\n static void do_jump_by_parts_greater PROTO((tree, int, rtx, rtx));\n@@ -3492,13 +3497,20 @@ expand_assignment (to, from, want_value, suggest_reg)\n     }\n \n   /* Don't move directly into a return register.  */\n-  if (TREE_CODE (to) == RESULT_DECL && GET_CODE (to_rtx) == REG)\n+  if (TREE_CODE (to) == RESULT_DECL\n+      && (GET_CODE (to_rtx) == REG || GET_CODE (to_rtx) == PARALLEL))\n     {\n       rtx temp;\n \n       push_temp_slots ();\n       temp = expand_expr (from, 0, GET_MODE (to_rtx), 0);\n-      emit_move_insn (to_rtx, temp);\n+\n+      if (GET_CODE (to_rtx) == PARALLEL)\n+\temit_group_load (to_rtx, temp, int_size_in_bytes (TREE_TYPE (from)),\n+\t\t\t TYPE_ALIGN (TREE_TYPE (from)) / BITS_PER_UNIT);\n+      else\n+\temit_move_insn (to_rtx, temp);\n+\n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n       pop_temp_slots ();\n@@ -4142,7 +4154,11 @@ store_constructor (exp, target, align, cleared)\n \t  if (cleared && is_zeros_p (TREE_VALUE (elt)))\n \t    continue;\n \n-\t  bitsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t  if (TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)\n+\t    bitsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t  else\n+\t    bitsize = -1;\n+\n \t  unsignedp = TREE_UNSIGNED (field);\n \t  mode = DECL_MODE (field);\n \t  if (DECL_BIT_FIELD (field))\n@@ -4317,9 +4333,18 @@ store_constructor (exp, target, align, cleared)\n \t  if (cleared && is_zeros_p (value))\n \t    continue;\n \n-\t  mode = TYPE_MODE (elttype);\n-\t  bitsize = GET_MODE_BITSIZE (mode);\n \t  unsignedp = TREE_UNSIGNED (elttype);\n+\t  mode = TYPE_MODE (elttype);\n+\t  if (mode == BLKmode)\n+\t    {\n+\t      if (TREE_CODE (TYPE_SIZE (elttype)) == INTEGER_CST\n+\t\t  && TREE_INT_CST_HIGH (TYPE_SIZE (elttype)) == 0)\n+\t\tbitsize = TREE_INT_CST_LOW (TYPE_SIZE (elttype));\n+\t      else\n+\t\tbitsize = -1;\n+\t    }\n+\t  else\n+\t    bitsize = GET_MODE_BITSIZE (mode);\n \n \t  if (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)\n \t    {\n@@ -4709,9 +4734,19 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n       || GET_CODE (target) == SUBREG\n       /* If the field isn't aligned enough to store as an ordinary memref,\n \t store it as a bit field.  */\n-      || (SLOW_UNALIGNED_ACCESS\n-\t  && align * BITS_PER_UNIT < GET_MODE_ALIGNMENT (mode))\n-      || (SLOW_UNALIGNED_ACCESS && bitpos % GET_MODE_ALIGNMENT (mode) != 0))\n+      || (mode != BLKmode && SLOW_UNALIGNED_ACCESS\n+\t  && (align * BITS_PER_UNIT < GET_MODE_ALIGNMENT (mode)\n+\t      || bitpos % GET_MODE_ALIGNMENT (mode)))\n+      || (mode == BLKmode && SLOW_UNALIGNED_ACCESS\n+\t  && (TYPE_ALIGN (TREE_TYPE (exp)) > align * BITS_PER_UNIT\n+\t      || bitpos % TYPE_ALIGN (TREE_TYPE (exp)) != 0))\n+      /* If the RHS and field are a constant size and the size of the\n+\t RHS isn't the same size as the bitfield, we must use bitfield\n+\t operations.  */\n+      || ((bitsize >= 0\n+\t   && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST)\n+\t  && (TREE_INT_CST_HIGH (TYPE_SIZE (TREE_TYPE (exp))) != 0\n+\t      || TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))) != bitsize)))\n     {\n       rtx temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n@@ -4746,10 +4781,14 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t\t\t\t   plus_constant (XEXP (target, 0),\n \t\t\t\t\t\tbitpos / BITS_PER_UNIT));\n \n+\t  /* Find an alignment that is consistent with the bit position.  */\n+\t  while ((bitpos % (align * BITS_PER_UNIT)) != 0)\n+\t    align >>= 1;\n+\n \t  emit_block_move (target, temp,\n \t\t\t   GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n \t\t\t\t    / BITS_PER_UNIT),\n-\t\t\t   1);\n+\t\t\t   align);\n \n \t  return value_mode == VOIDmode ? const0_rtx : target;\n \t}\n@@ -4985,9 +5024,6 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n \t       && ! ((TREE_CODE (exp) == NOP_EXPR\n \t\t      || TREE_CODE (exp) == CONVERT_EXPR)\n-\t\t     && ! (TREE_CODE (TREE_TYPE (exp)) == UNION_TYPE\n-\t\t\t   && (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0)))\n-\t\t\t       != UNION_TYPE))\n \t\t     && (TYPE_MODE (TREE_TYPE (exp))\n \t\t\t == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))))\n \tbreak;\n@@ -5525,6 +5561,25 @@ check_max_integer_computation_mode (exp)\n }\n #endif\n \n+\f\n+/* Utility function used by expand_expr to see if TYPE, a RECORD_TYPE,\n+   has any readonly fields.  If any of the fields have types that\n+   contain readonly fields, return true as well.  */\n+\n+static int\n+readonly_fields_p (type)\n+     tree type;\n+{\n+  tree field;\n+\n+  for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n+    if (TREE_READONLY (field)\n+\t|| (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n+\t    && readonly_fields_p (TREE_TYPE (field))))\n+      return 1;\n+\n+  return 0;\n+}\n \f\n /* expand_expr: generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n@@ -5568,9 +5623,6 @@ expand_expr (exp, target, tmode, modifier)\n      enum machine_mode tmode;\n      enum expand_modifier modifier;\n {\n-  /* Chain of pending expressions for PLACEHOLDER_EXPR to replace.\n-     This is static so it will be accessible to our recursive callees.  */\n-  static tree placeholder_list = 0;\n   register rtx op0, op1, temp;\n   tree type = TREE_TYPE (exp);\n   int unsignedp = TREE_UNSIGNED (type);\n@@ -5629,22 +5681,25 @@ expand_expr (exp, target, tmode, modifier)\n       if (! TREE_SIDE_EFFECTS (exp))\n \treturn const0_rtx;\n \n-      /* Ensure we reference a volatile object even if value is ignored.  */\n+      /* Ensure we reference a volatile object even if value is ignored, but\n+\t don't do this if all we are doing is taking its address.  */\n       if (TREE_THIS_VOLATILE (exp)\n \t  && TREE_CODE (exp) != FUNCTION_DECL\n-\t  && mode != VOIDmode && mode != BLKmode)\n+\t  && mode != VOIDmode && mode != BLKmode\n+\t  && modifier != EXPAND_CONST_ADDRESS)\n \t{\n \t  temp = expand_expr (exp, NULL_RTX, VOIDmode, ro_modifier);\n \t  if (GET_CODE (temp) == MEM)\n \t    temp = copy_to_reg (temp);\n \t  return const0_rtx;\n \t}\n \n-      if (TREE_CODE_CLASS (code) == '1')\n+      if (TREE_CODE_CLASS (code) == '1' || code == COMPONENT_REF\n+\t  || code == INDIRECT_REF || code == BUFFER_REF)\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n \t\t\t    VOIDmode, ro_modifier);\n-      else if (TREE_CODE_CLASS (code) == '2'\n-\t       || TREE_CODE_CLASS (code) == '<')\n+      else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<'\n+\t     || code == ARRAY_REF)\n \t{\n \t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, ro_modifier);\n \t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, ro_modifier);\n@@ -5656,7 +5711,14 @@ expand_expr (exp, target, tmode, modifier)\n \t   the first.  */\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n \t\t\t    VOIDmode, ro_modifier);\n-\n+      else if (code == BIT_FIELD_REF)\n+\t{\n+\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 2), const0_rtx, VOIDmode, ro_modifier);\n+\t  return const0_rtx;\n+\t}\n+;\n       target = 0;\n     }\n \n@@ -6334,6 +6396,14 @@ expand_expr (exp, target, tmode, modifier)\n \t   never change.  Languages where it can never change should\n \t   also set TREE_STATIC.  */\n \tRTX_UNCHANGING_P (temp) = TREE_READONLY (exp) & TREE_STATIC (exp);\n+\n+\t/* If we are writing to this object and its type is a record with\n+\t   readonly fields, we must mark it as readonly so it will\n+\t   conflict with readonly references to those fields.  */\n+\tif (modifier == EXPAND_MEMORY_USE_WO\n+\t    && TREE_CODE (type) == RECORD_TYPE && readonly_fields_p (type))\n+\t  RTX_UNCHANGING_P (temp) = 1;\n+\n \treturn temp;\n       }\n \n@@ -6516,15 +6586,17 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t!= INTEGER_CST)\n \t\t\t    ? target : NULL_RTX),\n \t\t\t   VOIDmode,\n-\t\t\t   modifier == EXPAND_INITIALIZER\n+\t\t\t   (modifier == EXPAND_INITIALIZER\n+\t\t\t    || modifier == EXPAND_CONST_ADDRESS)\n \t\t\t   ? modifier : EXPAND_NORMAL);\n \n \t/* If this is a constant, put it into a register if it is a\n-\t   legitimate constant and memory if it isn't.  */\n+\t   legitimate constant and OFFSET is 0 and memory if it isn't.  */\n \tif (CONSTANT_P (op0))\n \t  {\n \t    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));\n-\t    if (mode != BLKmode && LEGITIMATE_CONSTANT_P (op0))\n+\t    if (mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)\n+\t\t&& offset == 0)\n \t      op0 = force_reg (mode, op0);\n \t    else\n \t      op0 = validize_mem (force_const_mem (mode, op0));\n@@ -6534,6 +6606,20 @@ expand_expr (exp, target, tmode, modifier)\n \t  {\n \t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n \n+\t    /* If this object is in memory, put it into a register.\n+\t       This case can't occur in C, but can in Ada if we have\n+\t       unchecked conversion of an expression from a scalar type to\n+\t       an array or record type.  */\n+\t    if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n+\t\t|| GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF)\n+\t      {\n+\t\trtx memloc = assign_temp (TREE_TYPE (tem), 1, 1, 1);\n+\n+\t\tmark_temp_addr_taken (memloc);\n+\t\temit_move_insn (memloc, op0);\n+\t\top0 = memloc;\n+\t      }\n+\n \t    if (GET_CODE (op0) != MEM)\n \t      abort ();\n \n@@ -6546,12 +6632,12 @@ expand_expr (exp, target, tmode, modifier)\n #endif\n \t      }\n \n-\t    /* A constant address in TO_RTX can have VOIDmode, we must not try\n+\t    /* A constant address in OP0 can have VOIDmode, we must not try\n \t       to call force_reg for that case.  Avoid that case.  */\n \t    if (GET_CODE (op0) == MEM\n \t\t&& GET_MODE (op0) == BLKmode\n \t\t&& GET_MODE (XEXP (op0, 0)) != VOIDmode\n-\t\t&& bitsize\n+\t\t&& bitsize != 0\n \t\t&& (bitpos % bitsize) == 0 \n \t\t&& (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n \t\t&& (alignment * BITS_PER_UNIT) == GET_MODE_ALIGNMENT (mode1))\n@@ -6625,13 +6711,23 @@ expand_expr (exp, target, tmode, modifier)\n \t\t     && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n \t\t    /* If the field isn't aligned enough to fetch as a memref,\n \t\t       fetch it as a bit field.  */\n-\t\t    || (SLOW_UNALIGNED_ACCESS\n-\t\t\t&& ((TYPE_ALIGN (TREE_TYPE (tem)) < (unsigned int) GET_MODE_ALIGNMENT (mode))\n-\t\t\t    || (bitpos % GET_MODE_ALIGNMENT (mode) != 0))))))\n+\t\t    || (mode1 != BLKmode && SLOW_UNALIGNED_ACCESS\n+\t\t\t&& ((TYPE_ALIGN (TREE_TYPE (tem))\n+\t\t\t     < (unsigned int) GET_MODE_ALIGNMENT (mode))\n+\t\t\t    || (bitpos % GET_MODE_ALIGNMENT (mode) != 0)))))\n+\t    || (modifier != EXPAND_CONST_ADDRESS\n+\t\t&& modifier != EXPAND_INITIALIZER\n+\t\t&& mode == BLKmode\n+\t\t\t&& SLOW_UNALIGNED_ACCESS\n+\t\t&& (TYPE_ALIGN (type) > alignment * BITS_PER_UNIT\n+\t\t    || bitpos % TYPE_ALIGN (type) != 0)))\n \t  {\n \t    enum machine_mode ext_mode = mode;\n \n-\t    if (ext_mode == BLKmode)\n+\t    if (ext_mode == BLKmode\n+\t\t&& ! (target != 0 && GET_CODE (op0) == MEM\n+\t\t      && GET_CODE (target) == MEM\n+\t\t      && bitpos % BITS_PER_UNIT == 0))\n \t      ext_mode = mode_for_size (bitsize, MODE_INT, 1);\n \n \t    if (ext_mode == BLKmode)\n@@ -6709,7 +6805,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (GET_CODE (op0) == MEM)\n \t  MEM_ALIAS_SET (op0) = get_alias_set (exp);\n-\n+ \n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n \t  mark_reg_pointer (XEXP (op0, 0), alignment);\n \n@@ -6890,6 +6986,16 @@ expand_expr (exp, target, tmode, modifier)\n       if (TREE_CODE (type) == UNION_TYPE)\n \t{\n \t  tree valtype = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\n+\t  /* If both input and output are BLKmode, this conversion\n+\t     isn't actually doing anything unless we need to make the\n+\t     alignment stricter.  */\n+\t  if (mode == BLKmode && TYPE_MODE (valtype) == BLKmode\n+\t      && (TYPE_ALIGN (type) <= TYPE_ALIGN (valtype)\n+\t\t  || TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT))\n+\t    return expand_expr (TREE_OPERAND (exp, 0), target, tmode,\n+\t\t\t\tmodifier);\n+\n \t  if (target == 0)\n \t    {\n \t      if (mode != BLKmode)\n@@ -6905,11 +7011,13 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  else if (GET_CODE (target) == REG)\n \t    /* Store this field into a union of the proper type.  */\n-\t    store_field (target, GET_MODE_BITSIZE (TYPE_MODE (valtype)), 0,\n-\t\t\t TYPE_MODE (valtype), TREE_OPERAND (exp, 0),\n-\t\t\t VOIDmode, 0, 1,\n-\t\t\t int_size_in_bytes (TREE_TYPE (TREE_OPERAND (exp, 0))),\n-\t\t\t 0);\n+\t    store_field (target,\n+\t\t\t MIN ((int_size_in_bytes (TREE_TYPE\n+\t\t\t\t\t\t  (TREE_OPERAND (exp, 0)))\n+\t\t\t       * BITS_PER_UNIT),\n+\t\t\t      GET_MODE_BITSIZE (mode)),\n+\t\t\t 0, TYPE_MODE (valtype), TREE_OPERAND (exp, 0),\n+\t\t\t VOIDmode, 0, 1, int_size_in_bytes (type), 0);\n \t  else\n \t    abort ();\n \n@@ -8306,6 +8414,263 @@ expand_expr (exp, target, tmode, modifier)\n   return temp;\n }\n \f\n+/* Similar to expand_expr, except that we don't specify a target, target\n+   mode, or modifier and we return the alignment of the inner type.  This is\n+   used in cases where it is not necessary to align the result to the\n+   alignment of its type as long as we know the alignment of the result, for\n+   example for comparisons of BLKmode values.  */\n+\n+static rtx\n+expand_expr_unaligned (exp, palign)\n+     register tree exp;\n+     int *palign;\n+{\n+  register rtx op0;\n+  tree type = TREE_TYPE (exp);\n+  register enum machine_mode mode = TYPE_MODE (type);\n+\n+  /* Default the alignment we return to that of the type.  */\n+  *palign = TYPE_ALIGN (type);\n+\n+  /* The only cases in which we do anything special is if the resulting mode\n+     is BLKmode.  */\n+  if (mode != BLKmode)\n+    return expand_expr (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+    case NON_LVALUE_EXPR:\n+      /* Conversions between BLKmode values don't change the underlying\n+         alignment or value.  */\n+      if (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == BLKmode)\n+\treturn expand_expr_unaligned (TREE_OPERAND (exp, 0), palign);\n+      break;\n+\n+    case ARRAY_REF:\n+      /* Much of the code for this case is copied directly from expand_expr.\n+\t We need to duplicate it here because we will do something different\n+\t in the fall-through case, so we need to handle the same exceptions\n+\t it does.  */\n+      {\n+\ttree array = TREE_OPERAND (exp, 0);\n+\ttree domain = TYPE_DOMAIN (TREE_TYPE (array));\n+\ttree low_bound = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n+\ttree index = TREE_OPERAND (exp, 1);\n+\ttree index_type = TREE_TYPE (index);\n+\tHOST_WIDE_INT i;\n+\n+\tif (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) != ARRAY_TYPE)\n+\t  abort ();\n+\n+\t/* Optimize the special-case of a zero lower bound.\n+\n+\t   We convert the low_bound to sizetype to avoid some problems\n+\t   with constant folding.  (E.g. suppose the lower bound is 1,\n+\t   and its mode is QI.  Without the conversion,  (ARRAY\n+\t   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n+\t   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)\n+\n+\t   But sizetype isn't quite right either (especially if\n+\t   the lowbound is negative).  FIXME */\n+\n+\tif (! integer_zerop (low_bound))\n+\t  index = fold (build (MINUS_EXPR, index_type, index,\n+\t\t\t       convert (sizetype, low_bound)));\n+\n+\t/* If this is a constant index into a constant array,\n+\t   just get the value from the array.  Handle both the cases when\n+\t   we have an explicit constructor and when our operand is a variable\n+\t   that was declared const.  */\n+\n+\tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array))\n+\t  {\n+\t    if (TREE_CODE (index) == INTEGER_CST\n+\t\t&& TREE_INT_CST_HIGH (index) == 0)\n+\t      {\n+\t\ttree elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n+\n+\t\ti = TREE_INT_CST_LOW (index);\n+\t\twhile (elem && i--)\n+\t\t  elem = TREE_CHAIN (elem);\n+\t\tif (elem)\n+\t\t  return expand_expr_unaligned (fold (TREE_VALUE (elem)),\n+\t\t\t\t\t\tpalign);\n+\t      }\n+\t  }\n+\t  \n+\telse if (optimize >= 1\n+\t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n+\t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n+\t\t && TREE_CODE (DECL_INITIAL (array)) != ERROR_MARK)\n+\t  {\n+\t    if (TREE_CODE (index) == INTEGER_CST)\n+\t      {\n+\t\ttree init = DECL_INITIAL (array);\n+\n+\t\ti = TREE_INT_CST_LOW (index);\n+\t\tif (TREE_CODE (init) == CONSTRUCTOR)\n+\t\t  {\n+\t\t    tree elem = CONSTRUCTOR_ELTS (init);\n+\n+\t\t    while (elem\n+\t\t\t   && !tree_int_cst_equal (TREE_PURPOSE (elem), index))\n+\t\t      elem = TREE_CHAIN (elem);\n+\t\t    if (elem)\n+\t\t      return expand_expr_unaligned (fold (TREE_VALUE (elem)),\n+\t\t\t\t\t\t    palign);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+      /* ... fall through ... */\n+\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+      /* If the operand is a CONSTRUCTOR, we can just extract the\n+\t appropriate field if it is present.  Don't do this if we have\n+\t already written the data since we want to refer to that copy\n+\t and varasm.c assumes that's what we'll do.  */\n+      if (TREE_CODE (exp) != ARRAY_REF\n+\t  && TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR\n+\t  && TREE_CST_RTL (TREE_OPERAND (exp, 0)) == 0)\n+\t{\n+\t  tree elt;\n+\n+\t  for (elt = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)); elt;\n+\t       elt = TREE_CHAIN (elt))\n+\t    if (TREE_PURPOSE (elt) == TREE_OPERAND (exp, 1))\n+\t      /* Note that unlike the case in expand_expr, we know this is\n+\t\t BLKmode and hence not an integer.  */\n+\t      return expand_expr_unaligned (TREE_VALUE (elt), palign);\n+\t}\n+\n+      {\n+\tenum machine_mode mode1;\n+\tint bitsize;\n+\tint bitpos;\n+\ttree offset;\n+\tint volatilep = 0;\n+\tint alignment;\n+\tint unsignedp;\n+\ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n+\t\t\t\t\t&mode1, &unsignedp, &volatilep,\n+\t\t\t\t\t&alignment);\n+\n+\t/* If we got back the original object, something is wrong.  Perhaps\n+\t   we are evaluating an expression too early.  In any event, don't\n+\t   infinitely recurse.  */\n+\tif (tem == exp)\n+\t  abort ();\n+\n+\top0 = expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+\n+\t/* If this is a constant, put it into a register if it is a\n+\t   legitimate constant and OFFSET is 0 and memory if it isn't.  */\n+\tif (CONSTANT_P (op0))\n+\t  {\n+\t    enum machine_mode inner_mode = TYPE_MODE (TREE_TYPE (tem));\n+\n+\t    if (inner_mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)\n+\t\t&& offset == 0)\n+\t      op0 = force_reg (inner_mode, op0);\n+\t    else\n+\t      op0 = validize_mem (force_const_mem (inner_mode, op0));\n+\t  }\n+\n+\tif (offset != 0)\n+\t  {\n+\t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n+\n+\t    /* If this object is in a register, put it into memory.\n+\t       This case can't occur in C, but can in Ada if we have\n+\t       unchecked conversion of an expression from a scalar type to\n+\t       an array or record type.  */\n+\t    if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n+\t\t|| GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF)\n+\t      {\n+\t\trtx memloc = assign_temp (TREE_TYPE (tem), 1, 1, 1);\n+\n+\t\tmark_temp_addr_taken (memloc);\n+\t\temit_move_insn (memloc, op0);\n+\t\top0 = memloc;\n+\t      }\n+\n+\t    if (GET_CODE (op0) != MEM)\n+\t      abort ();\n+\n+\t    if (GET_MODE (offset_rtx) != ptr_mode)\n+\t      {\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t\toffset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n+#else\n+\t\toffset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+#endif\n+\t      }\n+\n+\t    op0 = change_address (op0, VOIDmode,\n+\t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (op0, 0),\n+\t\t\t\t\t\tforce_reg (ptr_mode,\n+\t\t\t\t\t\t\t   offset_rtx)));\n+\t  }\n+\n+\t/* Don't forget about volatility even if this is a bitfield.  */\n+\tif (GET_CODE (op0) == MEM && volatilep && ! MEM_VOLATILE_P (op0))\n+\t  {\n+\t    op0 = copy_rtx (op0);\n+\t    MEM_VOLATILE_P (op0) = 1;\n+\t  }\n+\n+\t/* Check the access.  */\n+\tif (current_function_check_memory_usage && GET_CODE (op0) == MEM)\n+          {\n+\t    rtx to;\n+\t    int size;\n+\n+\t    to = plus_constant (XEXP (op0, 0), (bitpos / BITS_PER_UNIT));\n+\t    size = (bitpos % BITS_PER_UNIT) + bitsize + BITS_PER_UNIT - 1;\n+\n+\t    /* Check the access right of the pointer.  */\n+\t    if (size > BITS_PER_UNIT)\n+\t      emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t\t\t to, ptr_mode, GEN_INT (size / BITS_PER_UNIT),\n+\t\t\t\t TYPE_MODE (sizetype),\n+\t\t\t\t GEN_INT (MEMORY_USE_RO), \n+\t\t\t\t TYPE_MODE (integer_type_node));\n+\t  }\n+\n+\t/* Get a reference to just this component.  */\n+\top0 = change_address (op0, mode1,\n+\t\t\t      plus_constant (XEXP (op0, 0),\n+\t\t\t\t\t     (bitpos / BITS_PER_UNIT)));\n+\n+\tMEM_ALIAS_SET (op0) = get_alias_set (exp);\n+\n+\t/* Adjust the alignment in case the bit position is not\n+\t   a multiple of the alignment of the inner object.  */\n+\twhile (bitpos % alignment != 0)\n+\t  alignment >>= 1;\n+\n+\tif (GET_CODE (XEXP (op0, 0)) == REG)\n+\t  mark_reg_pointer (XEXP (op0, 0), alignment);\n+\n+\tMEM_IN_STRUCT_P (op0) = 1;\n+\tMEM_VOLATILE_P (op0) |= volatilep;\n+\n+\t*palign = alignment;\n+\treturn op0;\n+      }\n+\n+    default:\n+      break;\n+\n+    }\n+\n+  return expand_expr (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+}\n+\f\n /* Return the tree node and offset if a given argument corresponds to\n    a string constant.  */\n \n@@ -8771,6 +9136,15 @@ do_jump (exp, if_false_label, if_true_label)\n       do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n       break;\n \n+    case WITH_RECORD_EXPR:\n+      /* Put the object on the placeholder list, recurse through our first\n+\t operand, and pop the list.  */\n+      placeholder_list = tree_cons (TREE_OPERAND (exp, 1), NULL_TREE,\n+\t\t\t\t    placeholder_list);\n+      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n+      placeholder_list = TREE_CHAIN (placeholder_list);\n+      break;\n+\n #if 0\n       /* This is never less insns than evaluating the PLUS_EXPR followed by\n \t a test and can be longer if the test is eliminated.  */\n@@ -9424,18 +9798,19 @@ do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n      enum rtx_code signed_code, unsigned_code;\n      rtx if_false_label, if_true_label;\n {\n+  int align0, align1;\n   register rtx op0, op1;\n   register tree type;\n   register enum machine_mode mode;\n   int unsignedp;\n   enum rtx_code code;\n \n   /* Don't crash if the comparison was erroneous.  */\n-  op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+  op0 = expand_expr_unaligned (TREE_OPERAND (exp, 0), &align0);\n   if (TREE_CODE (TREE_OPERAND (exp, 0)) == ERROR_MARK)\n     return;\n \n-  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n+  op1 = expand_expr_unaligned (TREE_OPERAND (exp, 1), &align1);\n   type = TREE_TYPE (TREE_OPERAND (exp, 0));\n   mode = TYPE_MODE (type);\n   unsignedp = TREE_UNSIGNED (type);\n@@ -9473,7 +9848,7 @@ do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,\n \t\t\t   ((mode == BLKmode)\n \t\t\t    ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),\n-\t\t\t   TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT,\n+\t\t\t   MIN (align0, align1) / BITS_PER_UNIT,\n \t\t\t   if_false_label, if_true_label);\n }\n \f"}, {"sha": "9b88302d7638cf840e346db79a6f0515555c2f6e", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -404,6 +404,10 @@ extern int flag_exceptions;\n \n extern int flag_new_exceptions;\n \n+/* Nonzero means generate frame unwind info table when supported */\n+\n+extern int flag_unwind_tables;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n "}, {"sha": "b93f49e400e42bb55669ee8d49363264e8154a1f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 270, "deletions": 38, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -92,6 +92,7 @@ static int merge_ranges\t\tPROTO((int *, tree *, tree *, int, tree, tree,\n static tree fold_range_test\tPROTO((tree));\n static tree unextend\t\tPROTO((tree, int, int, tree));\n static tree fold_truthop\tPROTO((enum tree_code, tree, tree, tree));\n+static tree optimize_minmax_comparison PROTO((tree));\n static tree strip_compound_expr PROTO((tree, tree));\n static int multiple_of_p\tPROTO((tree, tree, tree));\n static tree constant_boolean_node PROTO((int, tree));\n@@ -2585,6 +2586,11 @@ invert_truthvalue (arg)\n       return build (COMPOUND_EXPR, type, TREE_OPERAND (arg, 0),\n \t\t    invert_truthvalue (TREE_OPERAND (arg, 1)));\n \n+    case WITH_RECORD_EXPR:\n+      return build (WITH_RECORD_EXPR, type,\n+\t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t    TREE_OPERAND (arg, 1));\n+\n     case NON_LVALUE_EXPR:\n       return invert_truthvalue (TREE_OPERAND (arg, 0));\n \n@@ -2728,11 +2734,13 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \n   /* Get all the information about the extractions being done.  If the bit size\n      if the same as the size of the underlying object, we aren't doing an\n-     extraction at all and so can do nothing.  */\n+     extraction at all and so can do nothing.  We also don't want to\n+     do anything if the inner expression is a PLACEHOLDER_EXPR since we\n+     then will no longer be able to replace it.  */\n   linner = get_inner_reference (lhs, &lbitsize, &lbitpos, &offset, &lmode,\n \t\t\t\t&lunsignedp, &lvolatilep, &alignment);\n   if (linner == lhs || lbitsize == GET_MODE_BITSIZE (lmode) || lbitsize < 0\n-      || offset != 0)\n+      || offset != 0 || TREE_CODE (linner) == PLACEHOLDER_EXPR)\n     return 0;\n \n  if (!const_p)\n@@ -2743,7 +2751,8 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \t\t\t\t   &runsignedp, &rvolatilep, &alignment);\n \n      if (rinner == rhs || lbitpos != rbitpos || lbitsize != rbitsize\n-\t || lunsignedp != runsignedp || offset != 0)\n+\t || lunsignedp != runsignedp || offset != 0\n+\t || TREE_CODE (rinner) == PLACEHOLDER_EXPR)\n        return 0;\n    }\n \n@@ -2936,7 +2945,8 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n   inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,\n \t\t\t       punsignedp, pvolatilep, &alignment);\n   if ((inner == exp && and_mask == 0)\n-      || *pbitsize < 0 || offset != 0)\n+      || *pbitsize < 0 || offset != 0\n+      || TREE_CODE (inner) == PLACEHOLDER_EXPR)\n     return 0;\n   \n   /* Compute the mask to access the bitfield.  */\n@@ -3305,15 +3315,11 @@ make_range (exp, pin_p, plow, phigh)\n \n \t      /* A range without an upper bound is, naturally, unbounded.\n \t\t Since convert would have cropped a very large value, use\n-\t\t  the max value for the destination type.  */\n+\t\t the max value for the destination type.  */\n+\t      high_positive\n+\t\t= TYPE_MAX_VALUE (equiv_type) ? TYPE_MAX_VALUE (equiv_type)\n+\t\t  : TYPE_MAX_VALUE (type);\n \n-\t      high_positive = TYPE_MAX_VALUE (equiv_type);\n-\t      if (!high_positive)\n-\t\t{\n-\t\t  high_positive = TYPE_MAX_VALUE (type);\n-\t\t  if (!high_positive)\n-\t\t    abort();\n-\t\t}\n \t      high_positive = fold (build (RSHIFT_EXPR, type,\n \t\t\t\t\t   convert (type, high_positive),\n \t\t\t\t\t   convert (type, integer_one_node)));\n@@ -3517,7 +3523,7 @@ merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n \t end of the second.  */\n       if (no_overlap)\n \tin_p = 1, low = low1, high = high1;\n-      else if (subset)\n+      else if (subset || highequal)\n \tin_p = 0, low = high = 0;\n       else\n \t{\n@@ -4051,6 +4057,103 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t\tconst_binop (BIT_IOR_EXPR, l_const, r_const, 0));\n }\n \f\n+/* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a \n+   constant.  */\n+\n+static tree\n+optimize_minmax_comparison (t)\n+     tree t;\n+{\n+  tree type = TREE_TYPE (t);\n+  tree arg0 = TREE_OPERAND (t, 0);\n+  enum tree_code op_code;\n+  tree comp_const = TREE_OPERAND (t, 1);\n+  tree minmax_const;\n+  int consts_equal, consts_lt;\n+  tree inner;\n+\n+  STRIP_SIGN_NOPS (arg0);\n+\n+  op_code = TREE_CODE (arg0);\n+  minmax_const = TREE_OPERAND (arg0, 1);\n+  consts_equal = tree_int_cst_equal (minmax_const, comp_const);\n+  consts_lt = tree_int_cst_lt (minmax_const, comp_const);\n+  inner = TREE_OPERAND (arg0, 0);\n+\n+  /* If something does not permit us to optimize, return the original tree.  */\n+  if ((op_code != MIN_EXPR && op_code != MAX_EXPR)\n+      || TREE_CODE (comp_const) != INTEGER_CST\n+      || TREE_CONSTANT_OVERFLOW (comp_const)\n+      || TREE_CODE (minmax_const) != INTEGER_CST\n+      || TREE_CONSTANT_OVERFLOW (minmax_const))\n+    return t;\n+\n+  /* Now handle all the various comparison codes.  We only handle EQ_EXPR\n+     and GT_EXPR, doing the rest with recursive calls using logical\n+     simplifications.  */\n+  switch (TREE_CODE (t))\n+    {\n+    case NE_EXPR:  case LT_EXPR:  case LE_EXPR:\n+      return\n+\tinvert_truthvalue (optimize_minmax_comparison (invert_truthvalue (t)));\n+\n+    case GE_EXPR:\n+      return\n+\tfold (build (TRUTH_ORIF_EXPR, type,\n+\t\t     optimize_minmax_comparison\n+\t\t     (build (EQ_EXPR, type, arg0, comp_const)),\n+\t\t     optimize_minmax_comparison\n+\t\t     (build (GT_EXPR, type, arg0, comp_const))));\n+\n+    case EQ_EXPR:\n+      if (op_code == MAX_EXPR && consts_equal)\n+\t/* MAX (X, 0) == 0  ->  X <= 0  */\n+\treturn fold (build (LE_EXPR, type, inner, comp_const));\n+\n+      else if (op_code == MAX_EXPR && consts_lt)\n+\t/* MAX (X, 0) == 5  ->  X == 5   */\n+\treturn fold (build (EQ_EXPR, type, inner, comp_const));\n+\n+      else if (op_code == MAX_EXPR)\n+\t/* MAX (X, 0) == -1  ->  false  */\n+\treturn omit_one_operand (type, integer_zero_node, inner);\n+\n+      else if (consts_equal)\n+\t/* MIN (X, 0) == 0  ->  X >= 0  */\n+\treturn fold (build (GE_EXPR, type, inner, comp_const));\n+\n+      else if (consts_lt)\n+\t/* MIN (X, 0) == 5  ->  false  */\n+\treturn omit_one_operand (type, integer_zero_node, inner);\n+\n+      else\n+\t/* MIN (X, 0) == -1  ->  X == -1  */\n+\treturn fold (build (EQ_EXPR, type, inner, comp_const));\n+\n+    case GT_EXPR:\n+      if (op_code == MAX_EXPR && (consts_equal || consts_lt))\n+\t/* MAX (X, 0) > 0  ->  X > 0\n+\t   MAX (X, 0) > 5  ->  X > 5  */\n+\treturn fold (build (GT_EXPR, type, inner, comp_const));\n+\n+      else if (op_code == MAX_EXPR)\n+\t/* MAX (X, 0) > -1  ->  true  */\n+\treturn omit_one_operand (type, integer_one_node, inner);\n+\n+      else if (op_code == MIN_EXPR && (consts_equal || consts_lt))\n+\t/* MIN (X, 0) > 0  ->  false\n+\t   MIN (X, 0) > 5  ->  false  */\n+\treturn omit_one_operand (type, integer_zero_node, inner);\n+\n+      else\n+\t/* MIN (X, 0) > -1  ->  X > -1  */\n+\treturn fold (build (GT_EXPR, type, inner, comp_const));\n+\n+    default:\n+      return t;\n+    }\n+}\n+\f\n /* If T contains a COMPOUND_EXPR which was inserted merely to evaluate\n    S, a SAVE_EXPR, return the expression actually being evaluated.   Note\n    that we may sometimes modify the tree.  */\n@@ -4182,7 +4285,7 @@ fold (expr)\n \n       /* Don't use STRIP_NOPS, because signedness of argument type matters.  */\n       if (arg0 != 0)\n-\tSTRIP_TYPE_NOPS (arg0);\n+\tSTRIP_SIGN_NOPS (arg0);\n \n       if (arg0 != 0 && TREE_CODE (arg0) == COMPLEX_CST)\n \tsubop = TREE_REALPART (arg0);\n@@ -4216,7 +4319,7 @@ fold (expr)\n \t    {\n \t      /* Signedness matters here.  Perhaps we can refine this\n \t\t later.  */\n-\t      STRIP_TYPE_NOPS (op);\n+\t      STRIP_SIGN_NOPS (op);\n \t    }\n \t  else\n \t    {\n@@ -5925,6 +6028,76 @@ fold (expr)\n \t    }\n \t}\n \n+      /* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or\n+\t a MINUS_EXPR of a constant, we can convert it into a comparison with\n+\t a revised constant as long as no overflow occurs.  */\n+      if ((code == EQ_EXPR || code == NE_EXPR)\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && (TREE_CODE (arg0) == PLUS_EXPR\n+\t      || TREE_CODE (arg0) == MINUS_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+\t  && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n+\t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t\t      arg1, TREE_OPERAND (arg0, 1), 0))\n+\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n+\n+      /* Similarly for a NEGATE_EXPR.  */\n+      else if ((code == EQ_EXPR || code == NE_EXPR)\n+\t       && TREE_CODE (arg0) == NEGATE_EXPR\n+\t       && TREE_CODE (arg1) == INTEGER_CST\n+\t       && 0 != (tem = fold (build1 (NEGATE_EXPR, TREE_TYPE (arg1),\n+\t\t\t\t\t    arg1)))\n+\t       && TREE_CODE (tem) == INTEGER_CST\n+\t       && ! TREE_CONSTANT_OVERFLOW (tem))\n+\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n+\n+      /* If we have X - Y == 0, we can convert that to X == Y and similarly\n+\t for !=.  Don't do this for ordered comparisons due to overflow.  */\n+      else if ((code == NE_EXPR || code == EQ_EXPR)\n+\t       && integer_zerop (arg1) && TREE_CODE (arg0) == MINUS_EXPR)\n+\treturn fold (build (code, type,\n+\t\t\t    TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1)));\n+\n+      /* If we are widening one operand of an integer comparison,\n+\t see if the other operand is similarly being widened.  Perhaps we\n+\t can do the comparison in the narrower type.  */\n+      else if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE\n+\t       && TREE_CODE (arg0) == NOP_EXPR\n+\t       && (tem = get_unwidened (arg0, NULL_TREE)) != arg0\n+\t       && (t1 = get_unwidened (arg1, TREE_TYPE (tem))) != 0\n+\t       && (TREE_TYPE (t1) == TREE_TYPE (tem)\n+\t\t   || (TREE_CODE (t1) == INTEGER_CST\n+\t\t       && int_fits_type_p (t1, TREE_TYPE (tem)))))\n+\treturn fold (build (code, type, tem, convert (TREE_TYPE (tem), t1)));\n+      \n+      /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n+\t constant, we can simplify it.  */\n+      else if (TREE_CODE (arg1) == INTEGER_CST\n+\t       && (TREE_CODE (arg0) == MIN_EXPR\n+\t\t   || TREE_CODE (arg0) == MAX_EXPR)\n+\t       && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+\treturn optimize_minmax_comparison (t);\n+\n+      /* If we are comparing an ABS_EXPR with a constant, we can\n+\t convert all the cases into explicit comparisons, but they may\n+\t well not be faster than doing the ABS and one comparison.\n+\t But ABS (X) <= C is a range comparison, which becomes a subtraction\n+\t and a comparison, and is probably faster.  */\n+      else if (code == LE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n+\t       && TREE_CODE (arg0) == ABS_EXPR\n+\t       && ! TREE_SIDE_EFFECTS (arg0))\n+\t{\n+\t  tree inner = TREE_OPERAND (arg0, 0);\n+\n+\t  tem = fold (build1 (NEGATE_EXPR, TREE_TYPE (arg1), arg1));\n+\t  if (TREE_CODE (tem) == INTEGER_CST\n+\t      && ! TREE_CONSTANT_OVERFLOW (tem))\n+\t    return fold (build (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\tbuild (GE_EXPR, type, inner, tem),\n+\t\t\t\tbuild (LE_EXPR, type, inner, arg1)));\n+\t}\n+\t  \n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n \t two operations, but the latter can be done in one less insn\n@@ -6076,35 +6249,93 @@ fold (expr)\n \t    }\n \t}\n \n-      /* An unsigned <= 0x7fffffff can be simplified.  */\n+      /* Comparisons with the highest or lowest possible integer of\n+\t the specified size will have known values and an unsigned\n+\t <= 0x7fffffff can be simplified.  */\n       {\n-\tint width = TYPE_PRECISION (TREE_TYPE (arg1));\n+\tint width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg1)));\n+\n \tif (TREE_CODE (arg1) == INTEGER_CST\n \t    && ! TREE_CONSTANT_OVERFLOW (arg1)\n \t    && width <= HOST_BITS_PER_WIDE_INT\n-\t    && TREE_INT_CST_LOW (arg1) == ((HOST_WIDE_INT) 1 << (width - 1)) - 1\n-\t    && TREE_INT_CST_HIGH (arg1) == 0\n \t    && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t\t|| POINTER_TYPE_P (TREE_TYPE (arg1)))\n-\t    && TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t\t|| POINTER_TYPE_P (TREE_TYPE (arg1))))\n \t  {\n-\t    switch (TREE_CODE (t))\n-\t      {\n-\t      case LE_EXPR:\n-\t\treturn fold (build (GE_EXPR, type,\n-\t\t\t\t    convert (signed_type (TREE_TYPE (arg0)),\n-\t\t\t\t\t     arg0),\n-\t\t\t\t    convert (signed_type (TREE_TYPE (arg1)),\n-\t\t\t\t\t     integer_zero_node)));\n-\t      case GT_EXPR:\n-\t\treturn fold (build (LT_EXPR, type,\n-\t\t\t\t    convert (signed_type (TREE_TYPE (arg0)),\n-\t\t\t\t\t     arg0),\n-\t\t\t\t    convert (signed_type (TREE_TYPE (arg1)),\n-\t\t\t\t\t     integer_zero_node)));\n-\t      default:\n-\t\tbreak;\n-\t      }\n+\t    if (TREE_INT_CST_HIGH (arg1) == 0\n+\t\t&& (TREE_INT_CST_LOW (arg1)\n+\t\t    == ((HOST_WIDE_INT) 1 << (width - 1)) - 1)\n+\t\t&& ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t      switch (TREE_CODE (t))\n+\t\t{\n+\t\tcase GT_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_zero_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase GE_EXPR:\n+\t\t  TREE_SET_CODE (t, EQ_EXPR);\n+\t\t  break;\n+\n+\t\tcase LE_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_one_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase LT_EXPR:\n+\t\t  TREE_SET_CODE (t, NE_EXPR);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\n+\t    else if (TREE_INT_CST_HIGH (arg1) == -1\n+\t\t     && (- TREE_INT_CST_LOW (arg1)\n+\t\t\t == ((HOST_WIDE_INT) 1 << (width - 1)))\n+\t\t     && ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t      switch (TREE_CODE (t))\n+\t\t{\n+\t\tcase LT_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_zero_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase LE_EXPR:\n+\t\t  TREE_SET_CODE (t, EQ_EXPR);\n+\t\t  break;\n+\n+\t\tcase GE_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_one_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase GT_EXPR:\n+\t\t  TREE_SET_CODE (t, NE_EXPR);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\n+\t    else if (TREE_INT_CST_HIGH (arg1) == 0\n+\t\t      && (TREE_INT_CST_LOW (arg1)\n+\t\t\t  == ((HOST_WIDE_INT) 1 << (width - 1)) - 1)\n+\t\t      && TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t      \n+\t      switch (TREE_CODE (t))\n+\t\t{\n+\t\tcase LE_EXPR:\n+\t\t  return fold (build (GE_EXPR, type,\n+\t\t\t\t      convert (signed_type (TREE_TYPE (arg0)),\n+\t\t\t\t\t       arg0),\n+\t\t\t\t      convert (signed_type (TREE_TYPE (arg1)),\n+\t\t\t\t\t       integer_zero_node)));\n+\t\tcase GT_EXPR:\n+\t\t  return fold (build (LT_EXPR, type,\n+\t\t\t\t      convert (signed_type (TREE_TYPE (arg0)),\n+\t\t\t\t\t       arg0),\n+\t\t\t\t      convert (signed_type (TREE_TYPE (arg1)),\n+\t\t\t\t\t       integer_zero_node)));\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n \t  }\n       }\n \n@@ -6268,6 +6499,7 @@ fold (expr)\n       /* Note that it is safe to invert for real values here because we\n \t will check below in the one case that it matters.  */\n \n+      t1 = NULL_TREE;\n       invert = 0;\n       if (code == NE_EXPR || code == GE_EXPR)\n \t{"}, {"sha": "a93f48b03220f263e6407db0f7ef0ff4d0d11e1c", "filename": "gcc/function.c", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -940,6 +940,15 @@ find_temp_slot_from_address (x)\n \t    return p;\n     }\n \n+  /* If we have a sum involving a register, see if it points to a temp\n+     slot.  */\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == REG\n+      && (p = find_temp_slot_from_address (XEXP (x, 0))) != 0)\n+    return p;\n+  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG\n+\t   && (p = find_temp_slot_from_address (XEXP (x, 1))) != 0)\n+    return p;\n+\n   return 0;\n }\n       \n@@ -950,11 +959,34 @@ void\n update_temp_slot_address (old, new)\n      rtx old, new;\n {\n-  struct temp_slot *p = find_temp_slot_from_address (old);\n+  struct temp_slot *p;\n \n-  /* If none, return.  Else add NEW as an alias.  */\n-  if (p == 0)\n+  if (rtx_equal_p (old, new))\n     return;\n+\n+  p = find_temp_slot_from_address (old);\n+\n+  /* If we didn't find one, see if both OLD and NEW are a PLUS and if\n+     there is a register in common between them.  If so, try a recursive\n+     call on those values.  */\n+  if (p == 0)\n+    {\n+      if (GET_CODE (old) != PLUS || GET_CODE (new) != PLUS)\n+\treturn;\n+\n+      if (rtx_equal_p (XEXP (old, 0), XEXP (new, 0)))\n+\tupdate_temp_slot_address (XEXP (old, 1), XEXP (new, 1));\n+      else if (rtx_equal_p (XEXP (old, 1), XEXP (new, 0)))\n+\tupdate_temp_slot_address (XEXP (old, 0), XEXP (new, 1));\n+      else if (rtx_equal_p (XEXP (old, 0), XEXP (new, 1)))\n+\tupdate_temp_slot_address (XEXP (old, 1), XEXP (new, 0));\n+      else if (rtx_equal_p (XEXP (old, 1), XEXP (new, 1)))\n+\tupdate_temp_slot_address (XEXP (old, 0), XEXP (new, 0));\n+\n+      return;\n+    }\n+\n+  /* Otherwise add an alias for the temp's address. */\n   else if (p->address == 0)\n     p->address = new;\n   else\n@@ -2665,9 +2697,11 @@ gen_mem_addressof (reg, decl)\n   tree type = TREE_TYPE (decl);\n   rtx r = gen_rtx_ADDRESSOF (Pmode, gen_reg_rtx (GET_MODE (reg)),\n \t\t\t     REGNO (reg), decl);\n+\n   /* If the original REG was a user-variable, then so is the REG whose\n-     address is being taken.  */\n+     address is being taken.  Likewise for unchanging.  */\n   REG_USERVAR_P (XEXP (r, 0)) = REG_USERVAR_P (reg);\n+  RTX_UNCHANGING_P (XEXP (r, 0)) = RTX_UNCHANGING_P (reg);\n \n   PUT_CODE (reg, MEM);\n   PUT_MODE (reg, DECL_MODE (decl));\n@@ -3422,17 +3456,20 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \n       if (new)\n \t{\n+\t  rtx src = SET_SRC (x);\n+\n+\t  instantiate_virtual_regs_1 (&src, NULL_RTX, 0);\n+\n \t  /* The only valid sources here are PLUS or REG.  Just do\n \t     the simplest possible thing to handle them.  */\n-\t  if (GET_CODE (SET_SRC (x)) != REG\n-\t      && GET_CODE (SET_SRC (x)) != PLUS)\n+\t  if (GET_CODE (src) != REG && GET_CODE (src) != PLUS)\n \t    abort ();\n \n \t  start_sequence ();\n-\t  if (GET_CODE (SET_SRC (x)) != REG)\n-\t    temp = force_operand (SET_SRC (x), NULL_RTX);\n+\t  if (GET_CODE (src) != REG)\n+\t    temp = force_operand (src, NULL_RTX);\n \t  else\n-\t    temp = SET_SRC (x);\n+\t    temp = src;\n \t  temp = force_operand (plus_constant (temp, offset), NULL_RTX);\n \t  seq = get_insns ();\n \t  end_sequence ();"}, {"sha": "44844c05510ba929b3acf1d7c6d8f18c3893803b", "filename": "gcc/gcc.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -100,6 +100,10 @@ static char dir_separator_str[] = {DIR_SEPARATOR, 0};\n \n #define MIN_FATAL_STATUS 1\n \n+/* Flag saying to pass the greatest exit code returned by a sub-process\n+   to the calling program.  */\n+static int pass_exit_codes;\n+\n /* Flag saying to print the directories gcc will search through looking for\n    programs, libraries, etc.  */\n \n@@ -168,6 +172,10 @@ static char *cross_compile = \"0\";\n    run if this is non-zero.  */\n static int error_count = 0;\n \n+/* Greatest exit code of sub-processes that has been encountered up to\n+   now.  */\n+static int greatest_status = 1;\n+\n /* This is the obstack which we use to allocate many strings.  */\n \n static struct obstack obstack;\n@@ -769,6 +777,7 @@ static const char *link_command_spec = \"\\\n \t\t\t%{!A:%{!nostdlib:%{!nostartfiles:%S}}}\\\n \t\t\t%{static:} %{L*} %o\\\n \t\t\t%{!nostdlib:%{!nodefaultlibs:%G %L %G}}\\\n+   {\"--pass-exit-codes\", \"-pass-exit-codes\", 0},\n \t\t\t%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\\\n \t\t\t%{T*}\\\n \t\t\t\\n }}}}}}\";\n@@ -2363,7 +2372,11 @@ execute ()\n \t\t    }\n \t\t  else if (WIFEXITED (status)\n \t\t\t   && WEXITSTATUS (status) >= MIN_FATAL_STATUS)\n-\t\t    ret_code = -1;\n+\t\t    {\n+\t\t      if (WEXITSTATUS (status) > greatest_status)\n+\t\t\tgreatest_status = WEXITSTATUS (status);\n+\t\t      ret_code = -1;\n+\t\t    }\n \t\t}\n #ifdef HAVE_GETRUSAGE\n \t      if (report_times && ut + st != 0)\n@@ -2490,6 +2503,7 @@ display_help ()\n   printf (\"Usage: %s [options] file...\\n\", programname);\n   printf (\"Options:\\n\");\n \n+  printf (\"  -pass-exit-codes         Exit with highest error code from a phase\\n\");\n   printf (\"  --help                   Display this information\\n\");\n   if (! verbose_flag)\n     printf (\"  (Use '-v --help' to display command line options of sub-processes)\\n\");\n@@ -2793,6 +2807,11 @@ process_command (argc, argv)\n \t  add_assembler_option (\"--help\", 6);\n \t  add_linker_option (\"--help\", 6);\n \t}\n+      else if (! strcmp (argv[i], \"-pass-exit-codes\"))\n+\t{\n+\t  pass_exit_codes = 1;\n+\t  n_switches++;\n+\t}\n       else if (! strcmp (argv[i], \"-print-search-dirs\"))\n \tprint_search_dirs = 1;\n       else if (! strcmp (argv[i], \"-print-libgcc-file-name\"))\n@@ -3086,6 +3105,8 @@ process_command (argc, argv)\n   /* Use 2 as fourth arg meaning try just the machine as a suffix,\n      as well as trying the machine and the version.  */\n #ifndef OS2\n+  add_prefix (&exec_prefixes, standard_exec_prefix, \"GCC\",\n+\t      0, 1, warn_std_ptr);\n   add_prefix (&exec_prefixes, standard_exec_prefix, \"BINUTILS\",\n \t      0, 2, warn_std_ptr);\n   add_prefix (&exec_prefixes, standard_exec_prefix_1, \"BINUTILS\",\n@@ -3161,6 +3182,8 @@ process_command (argc, argv)\n \t;\n       else if (! strncmp (argv[i], \"-Wp,\", 4))\n \t;\n+      else if (! strcmp (argv[i], \"-pass-exit-codes\"))\n+\t;\n       else if (! strcmp (argv[i], \"-print-search-dirs\"))\n \t;\n       else if (! strcmp (argv[i], \"-print-libgcc-file-name\"))\n@@ -5198,7 +5221,9 @@ main (argc, argv)\n       printf (\"<URL:http://www.gnu.org/software/gcc/faq.html#bugreport>\\n\");\n     }\n   \n-  return (error_count > 0 ? (signal_count ? 2 : 1) : 0);\n+  return (signal_count != 0 ? 2\n+\t  : error_count > 0 ? (pass_exit_codes ? greatest_status : 1)\n+\t  : 0);\n }\n \n /* Find the proper compilation spec for the file name NAME,"}, {"sha": "822531cce09bca349eeb3a306b338e2622f4a7e3", "filename": "gcc/gcov.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -275,6 +275,9 @@ fnotice VPROTO ((FILE *file, const char *msgid, ...))\n   va_end (ap);\n }\n \n+#ifndef DIR_SEPARATOR\n+#define DIR_SEPARATOR '/'\n+#endif\n \n /* More 'friendly' abort that prints the line and file.\n    config.h can #define abort fancy_abort if you like that sort of thing.  */\n@@ -283,7 +286,7 @@ extern void fancy_abort PROTO ((void)) ATTRIBUTE_NORETURN;\n void\n fancy_abort ()\n {\n-  fnotice (stderr, \"Internal gcc abort.\\n\");\n+  fnotice (stderr, \"Internal gcov abort.\\n\");\n   exit (FATAL_EXIT_CODE);\n }\n \f\n@@ -407,7 +410,7 @@ open_files ()\n   else\n     strcat (bbg_file_name, \".bbg\");\n \n-  bb_file = fopen (bb_file_name, \"r\");\n+  bb_file = fopen (bb_file_name, \"rb\");\n   if (bb_file == NULL)\n     {\n       fnotice (stderr, \"Could not open basic block file %s.\\n\", bb_file_name);\n@@ -416,14 +419,14 @@ open_files ()\n \n   /* If none of the functions in the file were executed, then there won't\n      be a .da file.  Just assume that all counts are zero in this case.  */\n-  da_file = fopen (da_file_name, \"r\");\n+  da_file = fopen (da_file_name, \"rb\");\n   if (da_file == NULL)\n     {\n       fnotice (stderr, \"Could not open data file %s.\\n\", da_file_name);\n       fnotice (stderr, \"Assuming that all execution counts are zero.\\n\");\n     }\n     \n-  bbg_file = fopen (bbg_file_name, \"r\");\n+  bbg_file = fopen (bbg_file_name, \"rb\");\n   if (bbg_file == NULL)\n     {\n       fnotice (stderr, \"Could not open program flow graph file %s.\\n\",\n@@ -1000,7 +1003,13 @@ output_data ()\n     {\n       /* If this is a relative file name, and an object directory has been\n \t specified, then make it relative to the object directory name.  */\n-      if (*s_ptr->name != '/' && object_directory != 0\n+      if (! (*s_ptr->name == '/' || *s_ptr->name == DIR_SEPARATOR\n+\t     /* Check for disk name on MS-DOS-based systems.  */\n+\t     || (DIR_SEPARATOR == '\\\\'\n+\t\t && s_ptr->name[1] == ':'\n+\t\t && (s_ptr->name[2] == DIR_SEPARATOR\n+\t\t     || s_ptr->name[2] == '/')))\n+\t  && object_directory != 0\n \t  && *object_directory != '\\0')\n \t{\n \t  int objdir_count = strlen (object_directory);"}, {"sha": "8ea80663c3a3ac4ff9b2ab77053c6da168c60b08", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1,22 +1,22 @@\n /* Simple garbage collection for the GNU compiler.\n    Copyright (C) 1999 Free Software Foundation, Inc.\n \n-   This file is part of GNU CC.\n+This file is part of GNU CC.\n \n-   GNU CC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n \n-   GNU CC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GNU CC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n \n /* Generic garbage collection (GC) functions and data, not specific to\n    any particular GC implementation.  */\n@@ -63,7 +63,7 @@ static void\n ggc_mark_rtx_ptr (elt)\n      void *elt;\n {\n-  ggc_mark_rtx (*(rtx *)elt);\n+  ggc_mark_rtx (*(rtx *) elt);\n }\n \n /* Type-correct function to pass to ggc_add_root.  It just forwards\n@@ -73,7 +73,7 @@ static void\n ggc_mark_tree_ptr (elt)\n      void *elt;\n {\n-  ggc_mark_tree (*(tree *)elt);\n+  ggc_mark_tree (*(tree *) elt);\n }\n \n /* Type-correct function to pass to ggc_add_root.  It just forwards\n@@ -83,7 +83,7 @@ static void\n ggc_mark_tree_varray_ptr (elt)\n      void *elt;\n {\n-  ggc_mark_tree_varray (*(varray_type *)elt);\n+  ggc_mark_tree_varray (*(varray_type *) elt);\n }\n \n /* Type-correct function to pass to ggc_add_root.  It just forwards\n@@ -104,7 +104,7 @@ static void\n ggc_mark_string_ptr (elt)\n      void *elt;\n {\n-  ggc_mark_string (*(char **)elt);\n+  ggc_mark_string (*(char **) elt);\n }\n \n /* Add BASE as a new garbage collection root.  It is an array of"}, {"sha": "c7420ab2e95bdcae7f165e71874f97a69ab1edc2", "filename": "gcc/integrate.c", "status": "modified", "additions": 190, "deletions": 120, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -69,7 +69,7 @@ static void integrate_parm_decls\tPROTO((tree, struct inline_remap *,\n static tree integrate_decl_tree\t\tPROTO((tree,\n \t\t\t\t\t       struct inline_remap *));\n static void subst_constants\t\tPROTO((rtx *, rtx,\n-\t\t\t\t\t       struct inline_remap *));\n+\t\t\t\t\t       struct inline_remap *, int));\n static void set_block_origin_self\tPROTO((tree));\n static void set_decl_origin_self\tPROTO((tree));\n static void set_block_abstract_flags\tPROTO((tree, int));\n@@ -153,7 +153,8 @@ function_cannot_inline_p (fndecl)\n     return N_(\"function with nested functions cannot be inline\");\n \n   if (forced_labels)\n-    return N_(\"function with label addresses used in initializers cannot inline\");\n+    return\n+      N_(\"function with label addresses used in initializers cannot inline\");\n \n   if (current_function_cannot_inline)\n     return current_function_cannot_inline;\n@@ -769,11 +770,19 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t}\n       else if (GET_CODE (loc) == MEM)\n \t{\n-\t  /* This is the case of a parameter that lives in memory.\n-\t     It will live in the block we allocate in the called routine's\n+\t  /* This is the case of a parameter that lives in memory.  It\n+\t     will live in the block we allocate in the called routine's\n \t     frame that simulates the incoming argument area.  Do nothing\n-\t     now; we will call store_expr later.  */\n-\t  ;\n+\t     with the parameter now; we will call store_expr later.  In\n+\t     this case, however, we must ensure that the virtual stack and\n+\t     incoming arg rtx values are expanded now so that we can be\n+\t     sure we have enough slots in the const equiv map since the\n+\t     store_expr call can easily blow the size estimate.  */\n+\t  if (DECL_FRAME_SIZE (fndecl) != 0)\n+\t    copy_rtx_and_substitute (virtual_stack_vars_rtx, map, 0);\n+\n+\t  if (DECL_SAVED_INSNS (fndecl)->args_size != 0)\n+\t    copy_rtx_and_substitute (virtual_incoming_args_rtx, map, 0);\n \t}\n       else if (GET_CODE (loc) == REG)\n \tprocess_reg_param (map, loc, copy);\n@@ -816,8 +825,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n \t  /* Compute the address in the area we reserved and store the\n \t     value there.  */\n-\t  temp = copy_rtx_and_substitute (loc, map);\n-\t  subst_constants (&temp, NULL_RTX, map);\n+\t  temp = copy_rtx_and_substitute (loc, map, 1);\n+\t  subst_constants (&temp, NULL_RTX, map, 1);\n \t  apply_change_group ();\n \t  if (! memory_address_p (GET_MODE (temp), XEXP (temp, 0)))\n \t    temp = change_address (temp, VOIDmode, XEXP (temp, 0));\n@@ -841,8 +850,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n     {\n       if (GET_CODE (XEXP (loc, 0)) == ADDRESSOF)\n \t{\n-\t  temp = copy_rtx_and_substitute (loc, map);\n-\t  subst_constants (&temp, NULL_RTX, map);\n+\t  temp = copy_rtx_and_substitute (loc, map, 1);\n+\t  subst_constants (&temp, NULL_RTX, map, 1);\n \t  apply_change_group ();\n \t  target = temp;\n \t}\n@@ -882,8 +891,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t    }\n \t  else\n \t    {\n-\t      temp = copy_rtx_and_substitute (loc, map);\n-\t      subst_constants (&temp, NULL_RTX, map);\n+\t      temp = copy_rtx_and_substitute (loc, map, 1);\n+\t      subst_constants (&temp, NULL_RTX, map, 0);\n \t      apply_change_group ();\n \t      emit_move_insn (temp, structure_value_addr);\n \t    }\n@@ -1033,7 +1042,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n \t\t  /* If we must not delete the source,\n \t\t     load it into a new temporary.  */\n-\t\t  copy = emit_insn (copy_rtx_and_substitute (pattern, map));\n+\t\t  copy = emit_insn (copy_rtx_and_substitute (pattern, map, 0));\n \n \t\t  new_set = single_set (copy);\n \t\t  if (new_set == 0)\n@@ -1046,7 +1055,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t\t has a note on it, keep the insn.  */\n \t      else if (rtx_equal_p (SET_DEST (set), SET_SRC (set))\n \t\t       && REG_NOTES (insn) != 0)\n-\t\tcopy = emit_insn (copy_rtx_and_substitute (pattern, map));\n+\t\tcopy = emit_insn (copy_rtx_and_substitute (pattern, map, 0));\n \t      else\n \t\tbreak;\n \t    }\n@@ -1066,13 +1075,44 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t\t   && rtx_equal_p (SET_SRC (set),\n \t\t\t\t   static_chain_incoming_rtx))\n \t    {\n-\t      rtx newdest = copy_rtx_and_substitute (SET_DEST (set), map);\n+\t      rtx newdest = copy_rtx_and_substitute (SET_DEST (set), map, 1);\n \n \t      copy = emit_move_insn (newdest, static_chain_value);\n \t      static_chain_value = 0;\n \t    }\n+\n+\t  /* If this is setting the virtual stack vars register, this must\n+\t     be the code at the handler for a builtin longjmp.  The value\n+\t     saved in the setjmp buffer will be the address of the frame\n+\t     we've made for this inlined instance within our frame.  But we\n+\t     know the offset of that value so we can use it to reconstruct\n+\t     our virtual stack vars register from that value.  If we are\n+\t     copying it from the stack pointer, leave it unchanged.  */\n+\t  else if (set != 0\n+\t\t   && rtx_equal_p (SET_DEST (set), virtual_stack_vars_rtx))\n+\t    {\n+\t      temp = map->reg_map[REGNO (SET_DEST (set))];\n+\t      temp = VARRAY_CONST_EQUIV (map->const_equiv_varray,\n+\t\t\t\t\t REGNO (temp)).rtx;\n+\n+\t      if (GET_CODE (temp) != PLUS\n+\t\t  || ! rtx_equal_p (XEXP (temp, 0), virtual_stack_vars_rtx)\n+\t\t  || GET_CODE (XEXP (temp, 1)) != CONST_INT)\n+\t\tabort ();\n+\n+\t      if (rtx_equal_p (SET_SRC (set), stack_pointer_rtx))\n+\t\ttemp = SET_SRC (set);\n+\t      else\n+\t\ttemp\n+\t\t  = force_operand (plus_constant (SET_SRC (set),\n+\t\t\t\t\t\t  - INTVAL (XEXP (temp, 1))),\n+\t\t\t\t   NULL_RTX);\n+\n+\t      copy = emit_move_insn (SET_DEST (set), temp);\n+\t    }\n+\n \t  else\n-\t    copy = emit_insn (copy_rtx_and_substitute (pattern, map));\n+\t    copy = emit_insn (copy_rtx_and_substitute (pattern, map, 0));\n \t  /* REG_NOTES will be copied later.  */\n \n #ifdef HAVE_cc0\n@@ -1113,7 +1153,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t      pattern = gen_jump (local_return_label);\n \t    }\n \t  else\n-\t    pattern = copy_rtx_and_substitute (PATTERN (insn), map);\n+\t    pattern = copy_rtx_and_substitute (PATTERN (insn), map, 0);\n \n \t  copy = emit_jump_insn (pattern);\n \n@@ -1149,13 +1189,14 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  break;\n \n \tcase CALL_INSN:\n-\t  pattern = copy_rtx_and_substitute (PATTERN (insn), map);\n+\t  pattern = copy_rtx_and_substitute (PATTERN (insn), map, 0);\n \t  copy = emit_call_insn (pattern);\n \n \t  /* Because the USAGE information potentially contains objects other\n \t     than hard registers, we need to copy it.  */\n \t  CALL_INSN_FUNCTION_USAGE (copy)\n-\t    = copy_rtx_and_substitute (CALL_INSN_FUNCTION_USAGE (insn), map);\n+\t    = copy_rtx_and_substitute (CALL_INSN_FUNCTION_USAGE (insn),\n+\t\t\t\t       map, 0);\n \n #ifdef HAVE_cc0\n \t  if (cc0_insn)\n@@ -1238,10 +1279,11 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t&& map->insn_map[INSN_UID (insn)]\n \t&& REG_NOTES (insn))\n       {\n-\trtx tem = copy_rtx_and_substitute (REG_NOTES (insn), map);\n+\trtx tem = copy_rtx_and_substitute (REG_NOTES (insn), map, 0);\n+\n \t/* We must also do subst_constants, in case one of our parameters\n \t   has const type and constant value.  */\n-\tsubst_constants (&tem, NULL_RTX, map);\n+\tsubst_constants (&tem, NULL_RTX, map, 0);\n \tapply_change_group ();\n \tREG_NOTES (map->insn_map[INSN_UID (insn)]) = tem;\n       }\n@@ -1334,7 +1376,7 @@ integrate_parm_decls (args, map, arg_vector)\n       register tree decl = build_decl (VAR_DECL, DECL_NAME (tail),\n \t\t\t\t       TREE_TYPE (tail));\n       rtx new_decl_rtl\n-\t= copy_rtx_and_substitute (RTVEC_ELT (arg_vector, i), map);\n+\t= copy_rtx_and_substitute (RTVEC_ELT (arg_vector, i), map, 1);\n \n       DECL_ARG_TYPE (decl) = DECL_ARG_TYPE (tail);\n       /* We really should be setting DECL_INCOMING_RTL to something reasonable\n@@ -1349,7 +1391,7 @@ integrate_parm_decls (args, map, arg_vector)\n \t debugging information contains the actual register, instead of the\n \t virtual register.   Do this by not passing an insn to\n \t subst_constants.  */\n-      subst_constants (&new_decl_rtl, NULL_RTX, map);\n+      subst_constants (&new_decl_rtl, NULL_RTX, map, 1);\n       apply_change_group ();\n       DECL_RTL (decl) = new_decl_rtl;\n     }\n@@ -1385,12 +1427,13 @@ integrate_decl_tree (let, map)\n \n       if (DECL_RTL (t) != 0)\n \t{\n-\t  DECL_RTL (d) = copy_rtx_and_substitute (DECL_RTL (t), map);\n+\t  DECL_RTL (d) = copy_rtx_and_substitute (DECL_RTL (t), map, 1);\n+\n \t  /* Fully instantiate the address with the equivalent form so that the\n \t     debugging information contains the actual register, instead of the\n \t     virtual register.   Do this by not passing an insn to\n \t     subst_constants.  */\n-\t  subst_constants (&DECL_RTL (d), NULL_RTX, map);\n+\t  subst_constants (&DECL_RTL (d), NULL_RTX, map, 1);\n \t  apply_change_group ();\n \t}\n       /* These args would always appear unused, if not for this.  */\n@@ -1437,21 +1480,26 @@ integrate_decl_tree (let, map)\n   return new_block;\n }\n \f\n-/* Create a new copy of an rtx.\n-   Recursively copies the operands of the rtx,\n+/* Create a new copy of an rtx. Recursively copies the operands of the rtx,\n    except for those few rtx codes that are sharable.\n \n    We always return an rtx that is similar to that incoming rtx, with the\n    exception of possibly changing a REG to a SUBREG or vice versa.  No\n    rtl is ever emitted.\n \n+   If FOR_LHS is nonzero, if means we are processing something that will\n+   be the LHS of a SET.  In that case, we copy RTX_UNCHANGING_P even if\n+   inlining since we need to be conservative in how it is set for\n+   such cases.\n+\n    Handle constants that need to be placed in the constant pool by\n    calling `force_const_mem'.  */\n \n rtx\n-copy_rtx_and_substitute (orig, map)\n+copy_rtx_and_substitute (orig, map, for_lhs)\n      register rtx orig;\n      struct inline_remap *map;\n+     int for_lhs;\n {\n   register rtx copy, temp;\n   register int i, j;\n@@ -1593,7 +1641,7 @@ copy_rtx_and_substitute (orig, map)\n       return map->reg_map[regno];\n \n     case SUBREG:\n-      copy = copy_rtx_and_substitute (SUBREG_REG (orig), map);\n+      copy = copy_rtx_and_substitute (SUBREG_REG (orig), map, for_lhs);\n       /* SUBREG is ordinary, but don't make nested SUBREGs.  */\n       if (GET_CODE (copy) == SUBREG)\n \treturn gen_rtx_SUBREG (GET_MODE (orig), SUBREG_REG (copy),\n@@ -1616,7 +1664,8 @@ copy_rtx_and_substitute (orig, map)\n \n     case ADDRESSOF:\n       copy = gen_rtx_ADDRESSOF (mode,\n-\t\t\t\tcopy_rtx_and_substitute (XEXP (orig, 0), map),\n+\t\t\t\tcopy_rtx_and_substitute (XEXP (orig, 0),\n+\t\t\t\t\t\t\t map, for_lhs),\n \t\t\t\t0, ADDRESSOF_DECL(orig));\n       regno = ADDRESSOF_REGNO (orig);\n       if (map->reg_map[regno])\n@@ -1644,7 +1693,7 @@ copy_rtx_and_substitute (orig, map)\n \t to (use foo) if the original insn didn't have a subreg.\n \t Removing the subreg distorts the VAX movstrhi pattern\n \t by changing the mode of an operand.  */\n-      copy = copy_rtx_and_substitute (XEXP (orig, 0), map);\n+      copy = copy_rtx_and_substitute (XEXP (orig, 0), map, code == CLOBBER);\n       if (GET_CODE (copy) == SUBREG && GET_CODE (XEXP (orig, 0)) != SUBREG)\n \tcopy = SUBREG_REG (copy);\n       return gen_rtx_fmt_e (code, VOIDmode, copy);\n@@ -1697,7 +1746,9 @@ copy_rtx_and_substitute (orig, map)\n \t  if (inlining)\n \t    {\n \t      rtx temp = force_const_mem (const_mode,\n-\t\t\t\t\t  copy_rtx_and_substitute (constant, map));\n+\t\t\t\t\t  copy_rtx_and_substitute (constant,\n+\t\t\t\t\t\t\t\t   map, 0));\n+\n #if 0\n \t      /* Legitimizing the address here is incorrect.\n \n@@ -1723,9 +1774,9 @@ copy_rtx_and_substitute (orig, map)\n \t      return temp;\n \t    }\n \t  else if (GET_CODE (constant) == LABEL_REF)\n-\t    return XEXP (force_const_mem (GET_MODE (orig),\n-\t\t\t\t\t  copy_rtx_and_substitute (constant,\n-\t\t\t\t\t\t\t\t   map)),\n+\t    return XEXP (force_const_mem\n+\t\t\t (GET_MODE (orig),\n+\t\t\t  copy_rtx_and_substitute (constant, map, for_lhs)),\n \t\t\t 0);\n \t}\n       else\n@@ -1792,8 +1843,8 @@ copy_rtx_and_substitute (orig, map)\n \t    (GET_MODE (orig),\n \t     gen_rtx_MEM (GET_MODE (XEXP (orig, 0)),\n \t\t\t  copy_rtx_and_substitute (XEXP (XEXP (orig, 0), 0),\n-\t\t\t\t\t\t   map)),\n-\t     copy_rtx_and_substitute (XEXP (orig, 1), map));\n+\t\t\t\t\t\t   map, 0)),\n+\t     copy_rtx_and_substitute (XEXP (orig, 1), map, 0));\n       break;\n \n #if 0\n@@ -1815,29 +1866,39 @@ copy_rtx_and_substitute (orig, map)\n \t  rtx equiv_loc;\n \t  HOST_WIDE_INT loc_offset;\n \n-\t  copy_rtx_and_substitute (SET_DEST (orig), map);\n+\t  copy_rtx_and_substitute (SET_DEST (orig), map, for_lhs);\n \t  equiv_reg = map->reg_map[REGNO (SET_DEST (orig))];\n-\t  equiv_loc = VARRAY_CONST_EQUIV (map->const_equiv_varray, REGNO (equiv_reg)).rtx;\n+\t  equiv_loc = VARRAY_CONST_EQUIV (map->const_equiv_varray,\n+\t\t\t\t\t  REGNO (equiv_reg)).rtx;\n \t  loc_offset\n \t    = GET_CODE (equiv_loc) == REG ? 0 : INTVAL (XEXP (equiv_loc, 1));\n \t      \n \t  return gen_rtx_SET (VOIDmode, SET_DEST (orig),\n \t\t\t      force_operand\n \t\t\t      (plus_constant\n-\t\t\t       (copy_rtx_and_substitute (SET_SRC (orig), map),\n+\t\t\t       (copy_rtx_and_substitute (SET_SRC (orig),\n+\t\t\t\t\t\t\t map, 0),\n \t\t\t\t- loc_offset),\n \t\t\t       NULL_RTX));\n \t}\n+      else\n+\treturn gen_rtx_SET (VOIDmode,\n+\t\t\t    copy_rtx_and_substitute (SET_DEST (orig), map, 1),\n+\t\t\t    copy_rtx_and_substitute (SET_SRC (orig), map, 0));\n       break;\n \n     case MEM:\n       if (inlining\n \t  && GET_CODE (XEXP (orig, 0)) == SYMBOL_REF\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (orig, 0)))\n \t{\n-\t  enum machine_mode const_mode = get_pool_mode_for_function (inlining, XEXP (orig, 0));\n-\t  rtx constant = get_pool_constant_for_function (inlining, XEXP (orig, 0));\n-\t  constant = copy_rtx_and_substitute (constant, map);\n+\t  enum machine_mode const_mode\n+\t    = get_pool_mode_for_function (inlining, XEXP (orig, 0));\n+\t  rtx constant\n+\t    = get_pool_constant_for_function (inlining, XEXP (orig, 0));\n+\n+\t  constant = copy_rtx_and_substitute (constant, map, 0);\n+\n \t  /* If this was an address of a constant pool entry that itself\n \t     had to be placed in the constant pool, it might not be a\n \t     valid address.  So the recursive call might have turned it\n@@ -1846,22 +1907,16 @@ copy_rtx_and_substitute (orig, map)\n \t     MEM into a REG, but we'll assume that it safe.  */\n \t  if (! CONSTANT_P (constant))\n \t    return constant;\n+\n \t  return validize_mem (force_const_mem (const_mode, constant));\n \t}\n+\n       copy = rtx_alloc (MEM);\n       PUT_MODE (copy, mode);\n-      XEXP (copy, 0) = copy_rtx_and_substitute (XEXP (orig, 0), map);\n+      XEXP (copy, 0) = copy_rtx_and_substitute (XEXP (orig, 0), map, 0);\n       MEM_COPY_ATTRIBUTES (copy, orig);\n       MEM_ALIAS_SET (copy) = MEM_ALIAS_SET (orig);\n-\n-      /* If doing function inlining, this MEM might not be const in the\n-\t function that it is being inlined into, and thus may not be\n-\t unchanging after function inlining.  Constant pool references are\n-\t handled elsewhere, so this doesn't lose RTX_UNCHANGING_P bits\n-\t for them.  */\n-      if (! map->integrating)\n-\tRTX_UNCHANGING_P (copy) = RTX_UNCHANGING_P (orig);\n-\n+      RTX_UNCHANGING_P (copy) = RTX_UNCHANGING_P (orig);\n       return copy;\n       \n     default:\n@@ -1886,7 +1941,8 @@ copy_rtx_and_substitute (orig, map)\n \t  break;\n \n \tcase 'e':\n-\t  XEXP (copy, i) = copy_rtx_and_substitute (XEXP (orig, i), map);\n+\t  XEXP (copy, i)\n+\t    = copy_rtx_and_substitute (XEXP (orig, i), map, for_lhs);\n \t  break;\n \n \tcase 'u':\n@@ -1902,7 +1958,8 @@ copy_rtx_and_substitute (orig, map)\n \t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n \t      for (j = 0; j < XVECLEN (copy, i); j++)\n \t\tXVECEXP (copy, i, j)\n-\t\t  = copy_rtx_and_substitute (XVECEXP (orig, i, j), map);\n+\t\t  = copy_rtx_and_substitute (XVECEXP (orig, i, j),\n+\t\t\t\t\t     map, for_lhs);\n \t    }\n \t  break;\n \n@@ -1947,9 +2004,14 @@ try_constants (insn, map)\n   int i;\n \n   map->num_sets = 0;\n-  subst_constants (&PATTERN (insn), insn, map);\n \n-  /* Apply the changes if they are valid; otherwise discard them.  */\n+  /* First try just updating addresses, then other things.  This is\n+     important when we have something like the store of a constant\n+     into memory and we can update the memory address but the machine\n+     does not support a constant source.  */\n+  subst_constants (&PATTERN (insn), insn, map, 1);\n+  apply_change_group ();\n+  subst_constants (&PATTERN (insn), insn, map, 0);\n   apply_change_group ();\n \n   /* Show we don't know the value of anything stored or clobbered.  */\n@@ -1996,16 +2058,19 @@ try_constants (insn, map)\n    into insns; cse will do the latter task better.\n \n    This function is also used to adjust address of items previously addressed\n-   via the virtual stack variable or virtual incoming arguments registers.  */\n+   via the virtual stack variable or virtual incoming arguments registers. \n+\n+   If MEMONLY is nonzero, only make changes inside a MEM.  */\n \n static void\n-subst_constants (loc, insn, map)\n+subst_constants (loc, insn, map, memonly)\n      rtx *loc;\n      rtx insn;\n      struct inline_remap *map;\n+     int memonly;\n {\n   rtx x = *loc;\n-  register int i;\n+  register int i, j;\n   register enum rtx_code code;\n   register const char *format_ptr;\n   int num_changes = num_validated_changes ();\n@@ -2027,7 +2092,8 @@ subst_constants (loc, insn, map)\n \n #ifdef HAVE_cc0\n     case CC0:\n-      validate_change (insn, loc, map->last_cc0_value, 1);\n+      if (! memonly)\n+\tvalidate_change (insn, loc, map->last_cc0_value, 1);\n       return;\n #endif\n \n@@ -2036,32 +2102,33 @@ subst_constants (loc, insn, map)\n       /* The only thing we can do with a USE or CLOBBER is possibly do\n \t some substitutions in a MEM within it.  */\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n-\tsubst_constants (&XEXP (XEXP (x, 0), 0), insn, map);\n+\tsubst_constants (&XEXP (XEXP (x, 0), 0), insn, map, 0);\n       return;\n \n     case REG:\n       /* Substitute for parms and known constants.  Don't replace\n \t hard regs used as user variables with constants.  */\n-      {\n-\tint regno = REGNO (x);\n-\tstruct const_equiv_data *p;\n-\n-\tif (! (regno < FIRST_PSEUDO_REGISTER && REG_USERVAR_P (x))\n-\t    && (size_t) regno < VARRAY_SIZE (map->const_equiv_varray)\n-\t    && (p = &VARRAY_CONST_EQUIV (map->const_equiv_varray, regno),\n-\t\tp->rtx != 0)\n-\t    && p->age >= map->const_age)\n-\t  validate_change (insn, loc, p->rtx, 1);\n-\treturn;\n-      }\n+      if (! memonly)\n+\t{\n+\t  int regno = REGNO (x);\n+\t  struct const_equiv_data *p;\n+\n+\t  if (! (regno < FIRST_PSEUDO_REGISTER && REG_USERVAR_P (x))\n+\t      && (size_t) regno < VARRAY_SIZE (map->const_equiv_varray)\n+\t      && (p = &VARRAY_CONST_EQUIV (map->const_equiv_varray, regno),\n+\t\t  p->rtx != 0)\n+\t      && p->age >= map->const_age)\n+\t    validate_change (insn, loc, p->rtx, 1);\n+\t}\n+      return;\n \n     case SUBREG:\n       /* SUBREG applied to something other than a reg\n \t should be treated as ordinary, since that must\n \t be a special hack and we don't know how to treat it specially.\n \t Consider for example mulsidi3 in m68k.md.\n \t Ordinary SUBREG of a REG needs this special treatment.  */\n-      if (GET_CODE (SUBREG_REG (x)) == REG)\n+      if (! memonly && GET_CODE (SUBREG_REG (x)) == REG)\n \t{\n \t  rtx inner = SUBREG_REG (x);\n \t  rtx new = 0;\n@@ -2071,7 +2138,7 @@ subst_constants (loc, insn, map)\n \t     see what is inside, try to form the new SUBREG and see if that is\n \t     valid.  We handle two cases: extracting a full word in an \n \t     integral mode and extracting the low part.  */\n-\t  subst_constants (&inner, NULL_RTX, map);\n+\t  subst_constants (&inner, NULL_RTX, map, 0);\n \n \t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n \t      && GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD\n@@ -2091,11 +2158,11 @@ subst_constants (loc, insn, map)\n       break;\n \n     case MEM:\n-      subst_constants (&XEXP (x, 0), insn, map);\n+      subst_constants (&XEXP (x, 0), insn, map, 0);\n \n       /* If a memory address got spoiled, change it back.  */\n-      if (insn != 0 && num_validated_changes () != num_changes\n-\t  && !memory_address_p (GET_MODE (x), XEXP (x, 0)))\n+      if (! memonly && insn != 0 && num_validated_changes () != num_changes\n+\t  && ! memory_address_p (GET_MODE (x), XEXP (x, 0)))\n \tcancel_changes (num_changes);\n       return;\n \n@@ -2108,7 +2175,7 @@ subst_constants (loc, insn, map)\n \trtx dest = *dest_loc;\n \trtx src, tem;\n \n-\tsubst_constants (&SET_SRC (x), insn, map);\n+\tsubst_constants (&SET_SRC (x), insn, map, memonly);\n \tsrc = SET_SRC (x);\n \n \twhile (GET_CODE (*dest_loc) == ZERO_EXTRACT\n@@ -2117,15 +2184,15 @@ subst_constants (loc, insn, map)\n \t  {\n \t    if (GET_CODE (*dest_loc) == ZERO_EXTRACT)\n \t      {\n-\t\tsubst_constants (&XEXP (*dest_loc, 1), insn, map);\n-\t\tsubst_constants (&XEXP (*dest_loc, 2), insn, map);\n+\t\tsubst_constants (&XEXP (*dest_loc, 1), insn, map, memonly);\n+\t\tsubst_constants (&XEXP (*dest_loc, 2), insn, map, memonly);\n \t      }\n \t    dest_loc = &XEXP (*dest_loc, 0);\n \t  }\n \n \t/* Do substitute in the address of a destination in memory.  */\n \tif (GET_CODE (*dest_loc) == MEM)\n-\t  subst_constants (&XEXP (*dest_loc, 0), insn, map);\n+\t  subst_constants (&XEXP (*dest_loc, 0), insn, map, 0);\n \n \t/* Check for the case of DEST a SUBREG, both it and the underlying\n \t   register are less than one word, and the SUBREG has the wider mode.\n@@ -2187,7 +2254,7 @@ subst_constants (loc, insn, map)\n \n \tcase 'e':\n \t  if (XEXP (x, i))\n-\t    subst_constants (&XEXP (x, i), insn, map);\n+\t    subst_constants (&XEXP (x, i), insn, map, memonly);\n \t  break;\n \n \tcase 'u':\n@@ -2199,11 +2266,9 @@ subst_constants (loc, insn, map)\n \n \tcase 'E':\n \t  if (XVEC (x, i) != NULL && XVECLEN (x, i) != 0)\n-\t    {\n-\t      int j;\n-\t      for (j = 0; j < XVECLEN (x, i); j++)\n-\t\tsubst_constants (&XVECEXP (x, i, j), insn, map);\n-\t    }\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      subst_constants (&XVECEXP (x, i, j), insn, map, memonly);\n+\n \t  break;\n \n \tdefault:\n@@ -2213,7 +2278,8 @@ subst_constants (loc, insn, map)\n \n   /* If this is a commutative operation, move a constant to the second\n      operand unless the second operand is already a CONST_INT.  */\n-  if ((GET_RTX_CLASS (code) == 'c' || code == NE || code == EQ)\n+  if (! memonly\n+      && (GET_RTX_CLASS (code) == 'c' || code == NE || code == EQ)\n       && CONSTANT_P (XEXP (x, 0)) && GET_CODE (XEXP (x, 1)) != CONST_INT)\n     {\n       rtx tem = XEXP (x, 0);\n@@ -2222,45 +2288,49 @@ subst_constants (loc, insn, map)\n     }\n \n   /* Simplify the expression in case we put in some constants.  */\n-  switch (GET_RTX_CLASS (code))\n-    {\n-    case '1':\n-      if (op0_mode == MAX_MACHINE_MODE)\n-\tabort ();\n-      new = simplify_unary_operation (code, GET_MODE (x),\n-\t\t\t\t      XEXP (x, 0), op0_mode);\n-      break;\n-\n-    case '<':\n+  if (! memonly)\n+    switch (GET_RTX_CLASS (code))\n       {\n-\tenum machine_mode op_mode = GET_MODE (XEXP (x, 0));\n-\tif (op_mode == VOIDmode)\n-\t  op_mode = GET_MODE (XEXP (x, 1));\n-\tnew = simplify_relational_operation (code, op_mode,\n-\t\t\t\t\t     XEXP (x, 0), XEXP (x, 1));\n+      case '1':\n+\tif (op0_mode == MAX_MACHINE_MODE)\n+\t  abort ();\n+\tnew = simplify_unary_operation (code, GET_MODE (x),\n+\t\t\t\t\tXEXP (x, 0), op0_mode);\n+\tbreak;\n+\n+      case '<':\n+\t{\n+\t  enum machine_mode op_mode = GET_MODE (XEXP (x, 0));\n+\n+\t  if (op_mode == VOIDmode)\n+\t    op_mode = GET_MODE (XEXP (x, 1));\n+\t  new = simplify_relational_operation (code, op_mode,\n+\t\t\t\t\t       XEXP (x, 0), XEXP (x, 1));\n #ifdef FLOAT_STORE_FLAG_VALUE\n-\tif (new != 0 && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+\t  if (new != 0 && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n \t  new = ((new == const0_rtx) ? CONST0_RTX (GET_MODE (x))\n \t\t : CONST_DOUBLE_FROM_REAL_VALUE (FLOAT_STORE_FLAG_VALUE,\n \t\t\t\t\t\t GET_MODE (x)));\n #endif\n-\tbreak;\n+\t  break;\n       }\n \n-    case '2':\n-    case 'c':\n-      new = simplify_binary_operation (code, GET_MODE (x),\n-\t\t\t\t       XEXP (x, 0), XEXP (x, 1));\n-      break;\n+      case '2':\n+      case 'c':\n+\tnew = simplify_binary_operation (code, GET_MODE (x),\n+\t\t\t\t\t XEXP (x, 0), XEXP (x, 1));\n+\tbreak;\n \n-    case 'b':\n-    case '3':\n-      if (op0_mode == MAX_MACHINE_MODE)\n-\tabort ();\n-      new = simplify_ternary_operation (code, GET_MODE (x), op0_mode,\n-\t\t\t\t\tXEXP (x, 0), XEXP (x, 1), XEXP (x, 2));\n-      break;\n-    }\n+      case 'b':\n+      case '3':\n+\tif (op0_mode == MAX_MACHINE_MODE)\n+\t  abort ();\n+\n+\tnew = simplify_ternary_operation (code, GET_MODE (x), op0_mode,\n+\t\t\t\t\t  XEXP (x, 0), XEXP (x, 1),\n+\t\t\t\t\t  XEXP (x, 2));\n+\tbreak;\n+      }\n \n   if (new)\n     validate_change (insn, loc, new, 1);"}, {"sha": "f107d11b6d22ce42de77e654b805a23e9ae4a881", "filename": "gcc/integrate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -114,7 +114,7 @@ struct inline_remap\n \n /* Return a copy of an rtx (as needed), substituting pseudo-register,\n    labels, and frame-pointer offsets as necessary.  */\n-extern rtx copy_rtx_and_substitute PROTO((rtx, struct inline_remap *));\n+extern rtx copy_rtx_and_substitute PROTO((rtx, struct inline_remap *, int));\n \n extern void try_constants PROTO((rtx, struct inline_remap *));\n "}, {"sha": "e2573c66224a88e9eb75fb16849e484614bd8b50", "filename": "gcc/invoke.texi", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -88,7 +88,7 @@ in the following sections.\n @item Overall Options\n @xref{Overall Options,,Options Controlling the Kind of Output}.\n @smallexample\n--c  -S  -E  -o @var{file}  -pipe  -v  --help  -x @var{language}\n+-c  -S  -E  -o @var{file}  -pipe  -pass-exit-codes  -v  --help  -x @var{language}\n @end smallexample\n \n @item C Language Options\n@@ -428,7 +428,7 @@ in the following sections.\n @xref{Code Gen Options,,Options for Code Generation Conventions}.\n @smallexample\n -fcall-saved-@var{reg}  -fcall-used-@var{reg}\n--fexceptions -ffixed-@var{reg}  -finhibit-size-directive\n+-fexceptions  -funwind-tables  -ffixed-@var{reg}  -finhibit-size-directive\n -fcheck-memory-usage  -fprefix-function-name\n -fno-common  -fno-ident  -fno-gnu-linker\n -fpcc-struct-return  -fpic  -fPIC\n@@ -527,6 +527,13 @@ assembler  assembler-with-cpp\n Turn off any specification of a language, so that subsequent files are\n handled according to their file name suffixes (as they are if @samp{-x}\n has not been used at all).\n+\n+@item -pass-exit-codes\n+Normally the @code{gcc} program will exit with the code of 1 if any\n+phase of the compiler returns a non-success return code.  If you specify\n+@samp{-pass-exit-codes}, the @code{gcc} program will instead return with\n+numerically highest error produced by any phase that returned an error\n+indication.\n @end table\n \n If you only want some of the stages of compilation, you can use\n@@ -6693,6 +6700,12 @@ properly with exception handlers written in C++.  You may also wish to\n disable this option if you are compiling older C++ programs that don't\n use exception handling.\n \n+@item -funwind-tables\n+Similar to @code{-fexceptions}, except that it will just generate any needed\n+static data, but will not affect the generated code in any other way.\n+You will normally not enable this option; instead, a language processor\n+that needs this handling would enable it on your behalf.\n+\n @item -fpcc-struct-return\n Return ``short'' @code{struct} and @code{union} values in memory like\n longer ones, rather than in registers.  This convention is less"}, {"sha": "ddc102816cd5abfc69ce16e13b7a289a7dc5e4a0", "filename": "gcc/jump.c", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1028,26 +1028,52 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t     need to remove the BARRIER if we succeed.  We can only\n \t\t     have one such jump since there must be a label after\n \t\t     the BARRIER and it's either ours, in which case it's the\n-\t\t     only one or some other, in which case we'd fail.  */\n+\t\t     only one or some other, in which case we'd fail.\n+\t\t     Likewise if it's a CALL_INSN followed by a BARRIER.  */\n \n-\t\t  if (simplejump_p (temp1))\n-\t\t    changed_jump = temp1;\n+\t\t  if (simplejump_p (temp1)\n+\t\t      || (GET_CODE (temp1) == CALL_INSN\n+\t\t\t  && NEXT_INSN (temp1) != 0\n+\t\t\t  && GET_CODE (NEXT_INSN (temp1)) == BARRIER))\n+\t\t    {\n+\t\t      if (changed_jump == 0)\n+\t\t\tchanged_jump = temp1;\n+\t\t      else\n+\t\t\tchanged_jump\n+\t\t\t  = gen_rtx_INSN_LIST (VOIDmode, temp1, changed_jump);\n+\t\t    }\n \n \t\t  /* See if we are allowed another insn and if this insn\n \t\t     if one we think we may be able to handle.  */\n \t\t  if (++num_insns > BRANCH_COST\n \t\t      || last_insn\n-\t\t      || (temp2 = single_set (temp1)) == 0\n-\t\t      || side_effects_p (SET_SRC (temp2))\n-\t\t      || may_trap_p (SET_SRC (temp2)))\n-\t\t    failed = 1;\n-\t\t  else\n+\t\t      || (((temp2 = single_set (temp1)) == 0\n+\t\t\t   || side_effects_p (SET_SRC (temp2))\n+\t\t\t   || may_trap_p (SET_SRC (temp2)))\n+\t\t\t  && GET_CODE (temp1) != CALL_INSN))\n+\t\t      failed = 1;\n+\t\t  else if (temp2 != 0)\n \t\t    validate_change (temp1, &SET_SRC (temp2),\n \t\t\t\t     gen_rtx_IF_THEN_ELSE\n \t\t\t\t     (GET_MODE (SET_DEST (temp2)),\n \t\t\t\t      copy_rtx (ourcond),\n \t\t\t\t      SET_SRC (temp2), SET_DEST (temp2)),\n \t\t\t\t     1);\n+\t\t  else\n+\t\t    {\n+\t\t      /* This is a CALL_INSN that doesn't have a SET.  */\n+\t\t      rtx *call_loc = &PATTERN (temp1);\n+\n+\t\t      if (GET_CODE (*call_loc) == PARALLEL)\n+\t\t\tcall_loc = &XVECEXP (*call_loc, 0, 0);\n+\n+\t\t      validate_change (temp1, call_loc,\n+\t\t\t\t       gen_rtx_IF_THEN_ELSE\n+\t\t\t\t       (VOIDmode, copy_rtx (ourcond),\n+\t\t\t\t\t*call_loc, const0_rtx),\n+\t\t\t\t       1);\n+\t\t    }\n+\n \n \t\t  if (modified_in_p (ourcond, temp1))\n \t\t    last_insn = 1;\n@@ -1073,10 +1099,13 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n \t\t  if (changed_jump != 0)\n \t\t    {\n-\t\t      if (GET_CODE (NEXT_INSN (changed_jump)) != BARRIER)\n-\t\t\tabort ();\n+\t\t      while (GET_CODE (changed_jump) == INSN_LIST)\n+\t\t\t{\n+\t\t\t  delete_barrier (NEXT_INSN (XEXP (changed_jump, 0)));\n+\t\t\t  changed_jump = XEXP (changed_jump, 1);\n+\t\t\t}\n \n-\t\t      delete_insn (NEXT_INSN (changed_jump));\n+\t\t      delete_barrier (NEXT_INSN (changed_jump));\n \t\t    }\n \n \t\t  delete_insn (insn);\n@@ -4037,6 +4066,18 @@ delete_jump (insn)\n     delete_computation (insn);\n }\n \n+/* Verify INSN is a BARRIER and delete it.  */\n+\n+void\n+delete_barrier (insn)\n+     rtx insn;\n+{\n+  if (GET_CODE (insn) != BARRIER)\n+    abort ();\n+\n+  delete_insn (insn);\n+}\n+\n /* Recursively delete prior insns that compute the value (used only by INSN\n    which the caller is deleting) stored in the register mentioned by NOTE\n    which is a REG_DEAD note associated with INSN.  */"}, {"sha": "68a4b4b67df545d81970380f5e10309b35a39707", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1514,7 +1514,7 @@ __bb_exit_func (void)\n \t  /* If the file exists, and the number of counts in it is the same,\n \t     then merge them in.  */\n \t     \n-\t  if ((da_file = fopen (ptr->filename, \"r\")) != 0)\n+\t  if ((da_file = fopen (ptr->filename, \"rb\")) != 0)\n \t    {\n \t      long n_counts = 0;\n \t      \n@@ -1547,7 +1547,7 @@ __bb_exit_func (void)\n \t\tfprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n \t\t\t ptr->filename);\n \t    }\n-\t  if ((da_file = fopen (ptr->filename, \"w\")) == 0)\n+\t  if ((da_file = fopen (ptr->filename, \"wb\")) == 0)\n \t    {\n \t      fprintf (stderr, \"arc profiling: Can't open output file %s.\\n\",\n \t\t       ptr->filename);"}, {"sha": "933f5fe68b41b9a1806904db1d107a4ec752d471", "filename": "gcc/loop.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -197,6 +197,11 @@ static int loop_mems_allocated;\n \n static int unknown_address_altered;\n \n+/* The above doesn't count any readonly memory locations that are stored.\n+   This does.  */\n+\n+static int unknown_constant_address_altered;\n+\n /* Count of movable (i.e. invariant) instructions discovered in the loop.  */\n static int num_movables;\n \n@@ -2386,9 +2391,9 @@ constant_high_bytes (p, loop_start)\n \f\n /* Scan a loop setting the elements `cont', `vtop', `loops_enclosed',\n    `has_call', `has_volatile', and `has_tablejump' within LOOP_INFO.\n-   Set the global variables `unknown_address_altered' and\n-   `num_mem_sets'.  Also, fill in the array `loop_mems' and the list\n-   `loop_store_mems'.  */\n+   Set the global variables `unknown_address_altered',\n+   `unknown_constant_address_altered', and `num_mem_sets'.  Also, fill\n+   in the array `loop_mems' and the list `loop_store_mems'.  */\n \n static void\n prescan_loop (start, end, loop_info)\n@@ -2414,6 +2419,7 @@ prescan_loop (start, end, loop_info)\n   loop_info->vtop = 0;\n \n   unknown_address_altered = 0;\n+  unknown_constant_address_altered = 0;\n   loop_store_mems = NULL_RTX;\n   first_loop_store_insn = NULL_RTX;\n   loop_mems_idx = 0;\n@@ -3166,11 +3172,15 @@ note_addr_stored (x, y, data)\n   num_mem_sets++;\n \n   /* BLKmode MEM means all memory is clobbered.  */\n-  if (GET_MODE (x) == BLKmode)\n-    unknown_address_altered = 1;\n+    if (GET_MODE (x) == BLKmode)\n+    {\n+      if (RTX_UNCHANGING_P (x))\n+\tunknown_constant_address_altered = 1;\n+      else\n+\tunknown_address_altered = 1;\n \n-  if (unknown_address_altered)\n-    return;\n+      return;\n+    }\n \n   loop_store_mems = gen_rtx_EXPR_LIST (VOIDmode, x, loop_store_mems);\n }\n@@ -3275,20 +3285,12 @@ invariant_p (x)\n       return VARRAY_INT (set_in_loop, REGNO (x)) == 0;\n \n     case MEM:\n-      /* Volatile memory references must be rejected.  Do this before\n-\t checking for read-only items, so that volatile read-only items\n-\t will be rejected also.  */\n-      if (MEM_VOLATILE_P (x))\n-\treturn 0;\n-\n-      /* Read-only items (such as constants in a constant pool) are\n-\t invariant if their address is.  */\n-      if (RTX_UNCHANGING_P (x))\n-\tbreak;\n-\n-      /* If we had a subroutine call, any location in memory could have been\n-\t clobbered.  */\n-      if (unknown_address_altered)\n+      /* If we had a subroutine call, any location in memory could\n+\t have been clobbered.  We used to test here for volatile and\n+\t readonly, but true_dependence knows how to do that better\n+\t than we do. */\n+      if (RTX_UNCHANGING_P (x)\n+\t  ? unknown_constant_address_altered : unknown_address_altered)\n \treturn 0;\n \n       /* See if there is any dependence between a store and this load.  */\n@@ -3298,6 +3300,7 @@ invariant_p (x)\n \t  if (true_dependence (XEXP (mem_list_entry, 0), VOIDmode,\n \t\t\t       x, rtx_varies_p))\n \t    return 0;\n+\n \t  mem_list_entry = XEXP (mem_list_entry, 1);\n \t}\n \n@@ -8013,6 +8016,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \n \t      reversible_mem_store\n \t\t= (! unknown_address_altered\n+\t\t   && ! unknown_constant_address_altered\n \t\t   && ! invariant_p (XEXP (XEXP (loop_store_mems, 0), 0)));\n \n \t      /* If the store depends on a register that is set after the"}, {"sha": "db0a078c4303fef058182ac5e7d04d0a84ae4efc", "filename": "gcc/optabs.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -2263,10 +2263,29 @@ expand_abs (mode, op0, target, safe)\n   if (temp != 0)\n     return temp;\n \n+  /* If we have a MAX insn, we can do this as MAX (x, -x).  */\n+  if (smax_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+    {\n+      rtx last = get_last_insn ();\n+\n+      temp = expand_unop (mode, neg_optab, op0, NULL_RTX, 0);\n+      if (temp != 0)\n+\ttemp = expand_binop (mode, smax_optab, op0, temp, target, 0,\n+\t\t\t     OPTAB_WIDEN);\n+\n+      if (temp != 0)\n+\treturn temp;\n+\n+      delete_insns_since (last);\n+    }\n+\n   /* If this machine has expensive jumps, we can do integer absolute\n      value of X as (((signed) x >> (W-1)) ^ x) - ((signed) x >> (W-1)),\n-     where W is the width of MODE.  */\n+     where W is the width of MODE.  But don't do this if the machine has\n+     conditional arithmetic since the branches will be converted into\n+     a conditional negation insn.  */\n \n+#ifndef HAVE_conditional_arithmetic\n   if (GET_MODE_CLASS (mode) == MODE_INT && BRANCH_COST >= 2)\n     {\n       rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n@@ -2282,6 +2301,7 @@ expand_abs (mode, op0, target, safe)\n       if (temp != 0)\n \treturn temp;\n     }\n+#endif\n \n   /* If that does not win, use conditional jump and negate.  */\n "}, {"sha": "d6c9076790b5b0260b4791b9c9f7b87056ce4f12", "filename": "gcc/output.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -336,6 +336,17 @@ extern rtx peephole\t\t\tPROTO((rtx));\n /* Write all the constants in the constant pool.  */\n extern void output_constant_pool\tPROTO((char *, tree));\n \n+/* Return nonzero if VALUE is a valid constant-valued expression\n+   for use in initializing a static variable; one that can be an\n+   element of a \"constant\" initializer.\n+\n+   Return null_pointer_node if the value is absolute;\n+   if it is relocatable, return the variable that determines the relocation.\n+   We assume that VALUE has been folded as much as possible;\n+   therefore, we do not need to check for such things as\n+   arithmetic-combinations of integers.  */\n+extern tree initializer_constant_valid_p\tPROTO((tree, tree));\n+\n /* Output assembler code for constant EXP to FILE, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n    Assumes output_addressed_constants has been done on EXP already."}, {"sha": "f691245a3a0bba686982d665a1c5e3f63e5c7563", "filename": "gcc/profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1423,7 +1423,7 @@ init_branch_prob (filename)\n       strcpy (data_file, filename);\n       strip_off_ending (data_file, len);\n       strcat (data_file, \".bb\");\n-      if ((bb_file = fopen (data_file, \"w\")) == 0)\n+      if ((bb_file = fopen (data_file, \"wb\")) == 0)\n \tpfatal_with_name (data_file);\n \n       /* Open an output file for the program flow graph.  */\n@@ -1432,7 +1432,7 @@ init_branch_prob (filename)\n       strcpy (bbg_file_name, filename);\n       strip_off_ending (bbg_file_name, len);\n       strcat (bbg_file_name, \".bbg\");\n-      if ((bbg_file = fopen (bbg_file_name, \"w\")) == 0)\n+      if ((bbg_file = fopen (bbg_file_name, \"wb\")) == 0)\n \tpfatal_with_name (bbg_file_name);\n \n       /* Initialize to zero, to ensure that the first file name will be\n@@ -1447,7 +1447,7 @@ init_branch_prob (filename)\n       strcpy (da_file_name, filename);\n       strip_off_ending (da_file_name, len);\n       strcat (da_file_name, \".da\");\n-      if ((da_file = fopen (da_file_name, \"r\")) == 0)\n+      if ((da_file = fopen (da_file_name, \"rb\")) == 0)\n \twarning (\"file %s not found, execution counts assumed to be zero.\",\n \t\t da_file_name);\n "}, {"sha": "1b7a044156505fef8ea13fad0f1396f17a6c388e", "filename": "gcc/recog.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1020,6 +1020,11 @@ register_operand (op, mode)\n       op = SUBREG_REG (op);\n     }\n \n+  /* If we have an ADDRESSOF, consider it valid since it will be\n+     converted into something that will not be a MEM. */\n+  if (GET_CODE (op) == ADDRESSOF)\n+    return 1;\n+\n   /* We don't consider registers whose class is NO_REGS\n      to be a register operand.  */\n   return (GET_CODE (op) == REG"}, {"sha": "824f1662019e78dc97019332aaa02f0c7d8a88ca", "filename": "gcc/regclass.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1436,14 +1436,19 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t\t  struct costs *pp = &this_op_costs[i];\n \n \t\t  for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t    pp->cost[class] = may_move_cost[class][(int) classes[i]];\n+\t\t    pp->cost[class]\n+\t\t      = (recog_data.operand_type[i] == OP_IN\n+\t\t\t ? may_move_cost[class][(int) classes[i]]\n+\t\t\t : move_cost[(int) classes[i]][class]);\n \n \t\t  /* If the alternative actually allows memory, make things\n \t\t     a bit cheaper since we won't need an extra insn to\n \t\t     load it.  */\n \n-\t\t  pp->mem_cost = (MEMORY_MOVE_COST (mode, classes[i], 1)\n-\t\t\t\t  - allows_mem);\n+\t\t  pp->mem_cost\n+\t\t    = (MEMORY_MOVE_COST (mode, classes[i], \n+\t\t\t\t\t recog_data.operand_type[i] == OP_IN)\n+\t\t       - allows_mem);\n \n \t\t  /* If we have assigned a class to this register in our\n \t\t     first pass, add a cost to this alternative corresponding\n@@ -1452,7 +1457,8 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \n \t\t  if (prefclass)\n \t\t    alt_cost\n-\t\t      += may_move_cost[(unsigned char)prefclass[REGNO (op)]][(int) classes[i]];\n+\t\t      += (may_move_cost[(unsigned char) prefclass[REGNO (op)]]\n+\t\t\t  [(int) classes[i]]);\n \t\t}\n \t    }\n "}, {"sha": "2fad69a1fa694ad7f3ea2c4e58c39786c80aa8ae", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -2662,15 +2662,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t   && reg_alternate_class (REGNO (recog_data.operand[i])) == NO_REGS);\n     }\n \n-#ifdef HAVE_cc0\n-  /* If we made any reloads for addresses, see if they violate a\n-     \"no input reloads\" requirement for this insn.  */\n-  if (no_input_reloads)\n-    for (i = 0; i < n_reloads; i++)\n-      if (rld[i].in != 0)\n-\tabort ();\n-#endif\n-\n   /* If this is simply a copy from operand 1 to operand 0, merge the\n      preferred classes for the operands.  */\n   if (set != 0 && noperands >= 2 && recog_data.operand[0] == SET_DEST (set)\n@@ -4112,6 +4103,18 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    rld[j].in = 0;\n \t  }\n \n+#ifdef HAVE_cc0\n+  /* If we made any reloads for addresses, see if they violate a\n+     \"no input reloads\" requirement for this insn.  But loads that we\n+     do after the insn (such as for output addresses) are fine.  */\n+  if (no_input_reloads)\n+    for (i = 0; i < n_reloads; i++)\n+      if (reload_in[i] != 0\n+\t  && reload_when_needed[i] != RELOAD_FOR_OUTADDR_ADDRESS\n+\t  && reload_when_needed[i] != RELOAD_FOR_OUTPUT_ADDRESS)\n+\tabort ();\n+#endif\n+\n   /* Set which reloads must use registers not used in any group.  Start\n      with those that conflict with a group and then include ones that\n      conflict with ones that are already known to conflict with a group.  */"}, {"sha": "67997296db4441c64e5578c1cf71213278f3cbdd", "filename": "gcc/rtl.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -806,30 +806,28 @@ read_rtx (infile)\n \n   tmp_code = UNKNOWN;\n \n-  for (i=0; i < NUM_RTX_CODE; i++) /* @@ might speed this search up */\n-    {\n-      if (!(strcmp (tmp_char, GET_RTX_NAME (i))))\n-\t{\n-\t  tmp_code = (RTX_CODE) i;\t/* get value for name */\n-\t  break;\n-\t}\n-    }\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    if (! strcmp (tmp_char, GET_RTX_NAME (i)))\n+      {\n+\ttmp_code = (RTX_CODE) i;\t/* get value for name */\n+\tbreak;\n+      }\n+\n   if (tmp_code == UNKNOWN)\n-    {\n-      fprintf (stderr,\n-\t       \"Unknown rtx read in rtl.read_rtx(). Code name was %s .\",\n-\t       tmp_char);\n-    }\n+    fatal (\"Unknown rtx read in rtl.read_rtx(). Code name was %s .\", tmp_char);\n+\n   /* (NIL) stands for an expression that isn't there.  */\n   if (tmp_code == NIL)\n     {\n       /* Discard the closeparen.  */\n-      while ((c = getc (infile)) && c != ')');\n+      while ((c = getc (infile)) && c != ')')\n+\t;\n+\n       return 0;\n     }\n \n-  return_rtx = rtx_alloc (tmp_code); /* if we end up with an insn expression\n-\t\t\t\t       then we free this space below.  */\n+  /* If we end up with an insn expression then we free this space below.  */\n+  return_rtx = rtx_alloc (tmp_code);\n   format_ptr = GET_RTX_FORMAT (GET_CODE (return_rtx));\n \n   /* If what follows is `: mode ', read it and\n@@ -838,13 +836,16 @@ read_rtx (infile)\n   i = read_skip_spaces (infile);\n   if (i == ':')\n     {\n-      register int k;\n       read_name (tmp_char, infile);\n-      for (k = 0; k < NUM_MACHINE_MODES; k++)\n-\tif (!strcmp (GET_MODE_NAME (k), tmp_char))\n+      for (j = 0; j < NUM_MACHINE_MODES; j++)\n+\tif (! strcmp (GET_MODE_NAME (j), tmp_char))\n \t  break;\n \n-      PUT_MODE (return_rtx, (enum machine_mode) k );\n+      if (j == MAX_MACHINE_MODE)\n+\tfatal (\"Unknown mode read in rtl.read_rtx(). Mode name was %s.\",\n+\t       tmp_char);\n+\n+      PUT_MODE (return_rtx, (enum machine_mode) j);\n     }\n   else\n     ungetc (i, infile);"}, {"sha": "8a92a19a7e27783eafcf027c8b536664197e6b01", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1059,6 +1059,7 @@ extern rtx find_equiv_reg\t\tPROTO((rtx, rtx, enum reg_class, int, short *, int, e\n extern rtx squeeze_notes\t\tPROTO((rtx, rtx));\n extern rtx delete_insn\t\t\tPROTO((rtx));\n extern void delete_jump\t\t\tPROTO((rtx));\n+extern void delete_barrier\t\tPROTO((rtx));\n extern rtx get_label_before\t\tPROTO((rtx));\n extern rtx get_label_after\t\tPROTO((rtx));\n extern rtx follow_jumps\t\t\tPROTO((rtx));"}, {"sha": "43dd48e75d0edb75e326ed43d5d09aca93dec2de", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -403,6 +403,7 @@ reg_referenced_p (x, body)\n \n     case CALL:\n     case USE:\n+    case IF_THEN_ELSE:\n       return reg_overlap_mentioned_p (x, body);\n \n     case TRAP_IF:"}, {"sha": "6e7862794b6a3adcbc219c287e80392eb25875e6", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1543,17 +1543,15 @@ simplify_plus_minus (code, mode, op0, op1)\n \n struct cfc_args\n {\n-  /* Input */\n-  rtx op0, op1;\n-  /* Output */\n-  int equal, op0lt, op1lt;\n+  rtx op0, op1;\t\t\t/* Input */\n+  int equal, op0lt, op1lt;\t/* Output */\n };\n \n static void\n check_fold_consts (data)\n   PTR data;\n {\n-  struct cfc_args * args = (struct cfc_args *) data;\n+  struct cfc_args *args = (struct cfc_args *) data;\n   REAL_VALUE_TYPE d0, d1;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (d0, args->op0);"}, {"sha": "76e5e8be9cc23f50db4c04e909cac814c1cfe412", "filename": "gcc/stmt.c", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1115,25 +1115,18 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t{\n \t  register rtx cleanup_insns;\n \n-\t  /* Get the first non-label after the label\n-\t     this goto jumps to.  If that's before this scope begins,\n-\t     we don't have a jump into the scope.  */\n-\t  rtx after_label = f->target_rtl;\n-\t  while (after_label != 0 && GET_CODE (after_label) == CODE_LABEL)\n-\t    after_label = NEXT_INSN (after_label);\n-\n \t  /* If this fixup jumped into this contour from before the beginning\n-\t     of this contour, report an error.  */\n+\t     of this contour, report an error.   This code used to use\n+\t     the first non-label insn after f->target_rtl, but that's\n+\t     wrong since such can be added, by things like put_var_into_stack\n+\t     and have INSN_UIDs that are out of the range of the block.  */\n \t  /* ??? Bug: this does not detect jumping in through intermediate\n \t     blocks that have stack levels or cleanups.\n \t     It detects only a problem with the innermost block\n \t     around the label.  */\n \t  if (f->target != 0\n \t      && (dont_jump_in || stack_level || cleanup_list)\n-\t      /* If AFTER_LABEL is 0, it means the jump goes to the end\n-\t\t of the rtl, which means it jumps into this scope.  */\n-\t      && (after_label == 0\n-\t\t  || INSN_UID (first_insn) < INSN_UID (after_label))\n+\t      && INSN_UID (first_insn) < INSN_UID (f->target_rtl)\n \t      && INSN_UID (first_insn) > INSN_UID (f->before_jump)\n \t      && ! DECL_ERROR_ISSUED (f->target))\n \t    {\n@@ -1345,6 +1338,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n     {\n       char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n+\n       i = decode_reg_name (regname);\n       if (i >= 0 || i == -4)\n \t++nclobbers;\n@@ -1372,11 +1366,13 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       while (tmp)\n \t{\n \t  char *constraint = TREE_STRING_POINTER (TREE_PURPOSE (tmp));\n+\n \t  if (n_occurrences (',', constraint) != nalternatives)\n \t    {\n \t      error (\"operand constraints for `asm' differ in number of alternatives\");\n \t      return;\n \t    }\n+\n \t  if (TREE_CHAIN (tmp))\n \t    tmp = TREE_CHAIN (tmp);\n \t  else\n@@ -1405,7 +1401,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t the worst that happens if we get it wrong is we issue an error\n \t message.  */\n \n-      c_len = TREE_STRING_LENGTH (TREE_PURPOSE (tail)) - 1;\n+      c_len = strlen (TREE_STRING_POINTER (TREE_PURPOSE (tail)));\n       constraint = TREE_STRING_POINTER (TREE_PURPOSE (tail));\n \n       /* Allow the `=' or `+' to not be at the beginning of the string,\n@@ -1585,7 +1581,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  return;\n \t}\n \n-      c_len = TREE_STRING_LENGTH (TREE_PURPOSE (tail)) - 1;\n+      c_len = strlen (TREE_STRING_POINTER (TREE_PURPOSE (tail)));\n       constraint = TREE_STRING_POINTER (TREE_PURPOSE (tail));\n       orig_constraint = constraint;\n \n@@ -1597,7 +1593,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  case '+':  case '=':  case '&':\n \t    if (constraint == orig_constraint)\n \t      {\n-\t        error (\"input operand constraint contains `%c'\", constraint[j]);\n+\t        error (\"input operand constraint contains `%c'\",\n+\t\t       constraint[j]);\n \t        return;\n \t      }\n \t    break;\n@@ -1645,10 +1642,11 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t\t|| (j == 1 && c_len == 2 && constraint[0] == '%'))\n \t      {\n \t\ttree o = outputs;\n+\n \t\tfor (j = constraint[j] - '0'; j > 0; --j)\n \t\t  o = TREE_CHAIN (o);\n \t\n-\t\tc_len = TREE_STRING_LENGTH (TREE_PURPOSE (o)) - 1;\n+\t\tc_len = strlen (TREE_STRING_POINTER (TREE_PURPOSE (o)));\n \t\tconstraint = TREE_STRING_POINTER (TREE_PURPOSE (o));\n \t\tj = 0;\n \t\tbreak;\n@@ -1691,6 +1689,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t      emit_move_insn (memloc, op);\n \t      op = memloc;\n \t    }\n+\n \t  else if (GET_CODE (op) == MEM && MEM_VOLATILE_P (op))\n \t    /* We won't recognize volatile memory as available a\n \t       memory_operand at this point.  Ignore it.  */\n@@ -1711,8 +1710,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       i++;\n     }\n \n-  /* Protect all the operands from the queue,\n-     now that they have all been evaluated.  */\n+  /* Protect all the operands from the queue now that they have all been\n+     evaluated.  */\n \n   for (i = 0; i < ninputs - ninout; i++)\n     XVECEXP (body, 3, i) = protect_from_queue (XVECEXP (body, 3, i), 0);\n@@ -1741,20 +1740,24 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       XSTR (body, 1) = TREE_STRING_POINTER (TREE_PURPOSE (outputs));\n       insn = emit_insn (gen_rtx_SET (VOIDmode, output_rtx[0], body));\n     }\n+\n   else if (noutputs == 0 && nclobbers == 0)\n     {\n       /* No output operands: put in a raw ASM_OPERANDS rtx.  */\n       insn = emit_insn (body);\n     }\n+\n   else\n     {\n       rtx obody = body;\n       int num = noutputs;\n-      if (num == 0) num = 1;\n+\n+      if (num == 0)\n+\tnum = 1;\n+\n       body = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num + nclobbers));\n \n       /* For each output operand, store a SET.  */\n-\n       for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n \t{\n \t  XVECEXP (body, 0, i)\n@@ -2692,19 +2695,25 @@ expand_value_return (val)\n #ifdef PROMOTE_FUNCTION_RETURN\n       tree type = TREE_TYPE (DECL_RESULT (current_function_decl));\n       int unsignedp = TREE_UNSIGNED (type);\n+      enum machine_mode old_mode\n+\t= DECL_MODE (DECL_RESULT (current_function_decl));\n       enum machine_mode mode\n-\t= promote_mode (type, DECL_MODE (DECL_RESULT (current_function_decl)),\n-\t\t\t&unsignedp, 1);\n+\t= promote_mode (type, old_mode, &unsignedp, 1);\n \n-      if (GET_MODE (val) != VOIDmode && GET_MODE (val) != mode)\n-\tconvert_move (return_reg, val, unsignedp);\n-      else\n+      if (mode != old_mode)\n+\tval = convert_modes (mode, old_mode, val, unsignedp);\n #endif\n+      if (GET_CODE (return_reg) == PARALLEL)\n+\temit_group_load (return_reg, val, int_size_in_bytes (type),\n+\t\t\t TYPE_ALIGN (type) / BITS_PER_UNIT);\n+      else\n \temit_move_insn (return_reg, val);\n     }\n+\n   if (GET_CODE (return_reg) == REG\n       && REGNO (return_reg) < FIRST_PSEUDO_REGISTER)\n     emit_insn (gen_rtx_USE (VOIDmode, return_reg));\n+\n   /* Handle calls that return values in multiple non-contiguous locations.\n      The Irix 6 ABI has examples of this.  */\n   else if (GET_CODE (return_reg) == PARALLEL)\n@@ -2789,6 +2798,7 @@ expand_return (retval)\n      run destructors on variables that might be used in the subsequent\n      computation of the return value.  */\n   rtx last_insn = 0;\n+  rtx result_rtl = DECL_RTL (DECL_RESULT (current_function_decl));\n   register rtx val = 0;\n   register rtx op0;\n   tree retval_rhs;\n@@ -2941,7 +2951,7 @@ expand_return (retval)\n \n   if (retval_rhs != 0\n       && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n-      && GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) == REG)\n+      && GET_CODE (result_rtl) == REG)\n     {\n       int i, bitpos, xbitpos;\n       int big_endian_correction = 0;\n@@ -3017,7 +3027,7 @@ expand_return (retval)\n       if (tmpmode == VOIDmode)\n \tabort ();\n \n-      PUT_MODE (DECL_RTL (DECL_RESULT (current_function_decl)), tmpmode);\n+      PUT_MODE (result_rtl, tmpmode);\n \n       if (GET_MODE_SIZE (tmpmode) < GET_MODE_SIZE (word_mode))\n \tresult_reg_mode = word_mode;\n@@ -3038,10 +3048,13 @@ expand_return (retval)\n   else if (cleanups\n       && retval_rhs != 0\n       && TREE_TYPE (retval_rhs) != void_type_node\n-      && GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) == REG)\n+      && (GET_CODE (result_rtl) == REG\n+\t  || (GET_CODE (result_rtl) == PARALLEL)))\n     {\n-      /* Calculate the return value into a pseudo reg.  */\n-      val = gen_reg_rtx (DECL_MODE (DECL_RESULT (current_function_decl)));\n+      /* Calculate the return value into a temporary (usually a pseudo\n+         reg).  */\n+      val = assign_temp (TREE_TYPE (DECL_RESULT (current_function_decl)),\n+\t\t\t 0, 0, 1);\n       val = expand_expr (retval_rhs, val, GET_MODE (val), 0);\n       val = force_not_mem (val);\n       emit_queue ();\n@@ -3054,7 +3067,7 @@ expand_return (retval)\n \t calculate value into hard return reg.  */\n       expand_expr (retval, const0_rtx, VOIDmode, 0);\n       emit_queue ();\n-      expand_value_return (DECL_RTL (DECL_RESULT (current_function_decl)));\n+      expand_value_return (result_rtl);\n     }\n }\n \n@@ -4533,17 +4546,19 @@ pushcase (value, converter, label, duplicate)\n   if (index_type == error_mark_node)\n     return 0;\n \n-  /* Convert VALUE to the type in which the comparisons are nominally done.  */\n-  if (value != 0)\n-    value = (*converter) (nominal_type, value);\n-\n   check_seenlabel ();\n \n   /* Fail if this value is out of range for the actual type of the index\n      (which may be narrower than NOMINAL_TYPE).  */\n-  if (value != 0 && ! int_fits_type_p (value, index_type))\n+  if (value != 0\n+      && (TREE_CONSTANT_OVERFLOW (value)\n+\t  || ! int_fits_type_p (value, index_type)))\n     return 3;\n \n+  /* Convert VALUE to the type in which the comparisons are nominally done.  */\n+  if (value != 0)\n+    value = (*converter) (nominal_type, value);\n+\n   /* Fail if this is a duplicate or overlaps another entry.  */\n   if (value == 0)\n     {\n@@ -4606,17 +4621,14 @@ pushcase_range (value1, value2, converter, label, duplicate)\n \n   /* Fail if the range is empty.  Do this before any conversion since\n      we want to allow out-of-range empty ranges.  */\n-  if (value2 && tree_int_cst_lt (value2, value1))\n+  if (value2 != 0 && tree_int_cst_lt (value2, value1))\n     return 4;\n \n-  value1 = (*converter) (nominal_type, value1);\n-\n   /* If the max was unbounded, use the max of the nominal_type we are \n      converting to.  Do this after the < check above to suppress false\n      positives.  */\n-  if (!value2)\n+  if (value2 == 0)\n     value2 = TYPE_MAX_VALUE (nominal_type);\n-  value2 = (*converter) (nominal_type, value2);\n \n   /* Fail if these values are out of range.  */\n   if (TREE_CONSTANT_OVERFLOW (value1)\n@@ -4627,6 +4639,9 @@ pushcase_range (value1, value2, converter, label, duplicate)\n       || ! int_fits_type_p (value2, index_type))\n     return 3;\n \n+  value1 = (*converter) (nominal_type, value1);\n+  value2 = (*converter) (nominal_type, value2);\n+\n   return add_case_node (value1, value2, label, duplicate);\n }\n "}, {"sha": "ea4631a5cd1d5046f47351ecb458ba74f5f238ec", "filename": "gcc/toplev.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -633,6 +633,10 @@ int flag_exceptions;\n \n int flag_new_exceptions = 1;\n \n+/* Nonzero means generate frame unwind info table when supported */\n+\n+int flag_unwind_tables = 0;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n \n@@ -937,6 +941,8 @@ lang_independent_options f_options[] =\n    \"Enable exception handling\" },\n   {\"new-exceptions\", &flag_new_exceptions, 1,\n    \"Use the new model for exception handling\" },\n+  {\"unwind-tables\", &flag_unwind_tables, 1,\n+    \"Just generate unwind tables for exception handling\" },\n   {\"sjlj-exceptions\", &exceptions_via_longjmp, 1,\n    \"Use setjmp/longjmp to handle exceptions\" },\n   {\"asynchronous-exceptions\", &asynchronous_exceptions, 1,\n@@ -3571,8 +3577,21 @@ rest_of_compilation (decl)\n   if (DECL_SAVED_INSNS (decl) == 0)\n     {\n       int inlinable = 0;\n+      tree parent;\n       const char *lose;\n \n+      /* If this is nested inside an inlined external function, pretend\n+\t it was only declared.  Since we cannot inline such functions,\n+\t generating code for this one is not only not necessary but will\n+\t confuse some debugging output writers.  */\n+      for (parent = DECL_CONTEXT (current_function_decl);\n+\t   parent != 0; parent = DECL_CONTEXT (parent))\n+\tif (DECL_INLINE (parent) && DECL_EXTERNAL (parent))\n+\t  {\n+\t    DECL_INITIAL (decl) = 0;\n+\t    goto exit_rest_of_compilation;\n+\t  }\n+\n       /* If requested, consider whether to make this function inline.  */\n       if (DECL_INLINE (decl) || flag_inline_functions)\n \tTIMEVAR (integration_time,\n@@ -4929,6 +4948,7 @@ decode_W_option (arg)\n /* Parse a -g... comand line switch.  ARG is the value after the -g.\n    It is safe to access 'ARG - 2' to generate the full switch name.\n    Return the number of strings consumed.  */\n+\n static int\n decode_g_option (arg)\n      const char * arg;\n@@ -5012,8 +5032,7 @@ ignoring option `%s' due to invalid debug level specification\",\n \t    }\n \t  \n \t  if (type == NO_DEBUG)\n-\t    warning (\"`%s' not supported by this configuration of GCC\",\n-\t\t     arg - 2);\n+\t    warning (\"`%s': unknown or unsupported -g option\", arg - 2);\n \n \t  /* Does it conflict with an already selected type?  */\n \t  if (type_explicitly_set_p\n@@ -5046,7 +5065,7 @@ ignoring option `%s' due to invalid debug level specification\",\n     }\n   \n   if (! da->arg)\n-    warning (\"`%s' not supported by this configuration of GCC\", arg - 2);\n+    warning (\"`%s': unknown or unsupported -g option\", arg - 2);\n \n   return 1;\n }"}, {"sha": "1184c6b6f8c99c0c66984bccd2fb25e31609f312", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -3359,12 +3359,9 @@ build_type_attribute_variant (ttype, attribute)\n   if ( ! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n     {\n       register int hashcode;\n-      register struct obstack *ambient_obstack = current_obstack;\n       tree ntype;\n \n-      if (ambient_obstack != &permanent_obstack)\n-        current_obstack = TYPE_OBSTACK (ttype);\n-\n+      push_obstacks (TYPE_OBSTACK (ttype), TYPE_OBSTACK (ttype));\n       ntype = copy_node (ttype);\n \n       TYPE_POINTER_TO (ntype) = 0;\n@@ -3400,12 +3397,7 @@ build_type_attribute_variant (ttype, attribute)\n \n       ntype = type_hash_canon (hashcode, ntype);\n       ttype = build_qualified_type (ntype, TYPE_QUALS (ttype));\n-\n-      /* We must restore the current obstack after the type_hash_canon call,\n-\t because type_hash_canon calls type_hash_add for permanent types, and\n-\t then type_hash_add calls oballoc expecting to get something permanent\n-\t back.  */\n-      current_obstack = ambient_obstack;\n+      pop_obstacks ();\n     }\n \n   return ttype;"}, {"sha": "477708e4f65a7af0641e233df004ea6fe70fae3a", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -402,6 +402,18 @@ extern void tree_class_check_failed PROTO((const tree, char,\n \t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0)))))\t\\\n     (EXP) = TREE_OPERAND (EXP, 0);\n \n+/* Like STRIP_NOPS, but don't let the signedness change either.  */\n+\n+#define STRIP_SIGN_NOPS(EXP) \\\n+  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\\\n+\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\\\n+\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n+\t && (TYPE_MODE (TREE_TYPE (EXP))\t\t\t\\\n+\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0))))\t\\\n+\t && (TREE_UNSIGNED (TREE_TYPE (EXP))\t\t\t\\\n+\t     == TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (EXP, 0))))) \\\n+    (EXP) = TREE_OPERAND (EXP, 0);\n+\n /* Like STRIP_NOPS, but don't alter the TREE_TYPE either.  */\n \n #define STRIP_TYPE_NOPS(EXP) \\\n@@ -861,9 +873,9 @@ struct tree_block\n \n /* The set of type qualifiers for this type.  */\n #define TYPE_QUALS(NODE)\t\t\t\\\n-  ((TYPE_READONLY(NODE) * TYPE_QUAL_CONST) |\t\\\n-   (TYPE_VOLATILE(NODE) * TYPE_QUAL_VOLATILE) |\t\\\n-   (TYPE_RESTRICT(NODE) * TYPE_QUAL_RESTRICT))\n+  ((TYPE_READONLY(NODE) * TYPE_QUAL_CONST)\t\\\n+   | (TYPE_VOLATILE(NODE) * TYPE_QUAL_VOLATILE)\t\\\n+   | (TYPE_RESTRICT(NODE) * TYPE_QUAL_RESTRICT))\n \n /* These flags are available for each language front end to use internally.  */\n #define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)->type.lang_flag_0)"}, {"sha": "0d9cf4acbc30c995b9ef31cb80e8745c37763b53", "filename": "gcc/unroll.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -1616,7 +1616,7 @@ initial_reg_note_copy (notes, map)\n   PUT_MODE (copy, GET_MODE (notes));\n \n   if (GET_CODE (notes) == EXPR_LIST)\n-    XEXP (copy, 0) = copy_rtx_and_substitute (XEXP (notes, 0), map);\n+    XEXP (copy, 0) = copy_rtx_and_substitute (XEXP (notes, 0), map, 0);\n   else if (GET_CODE (notes) == INSN_LIST)\n     /* Don't substitute for these yet.  */\n     XEXP (copy, 0) = XEXP (notes, 0);\n@@ -1927,7 +1927,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t    }\n \t  else\n \t    {\n-\t      pattern = copy_rtx_and_substitute (pattern, map);\n+\t      pattern = copy_rtx_and_substitute (pattern, map, 0);\n \t      copy = emit_insn (pattern);\n \t    }\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n@@ -1974,7 +1974,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t  break;\n \n \tcase JUMP_INSN:\n-\t  pattern = copy_rtx_and_substitute (PATTERN (insn), map);\n+\t  pattern = copy_rtx_and_substitute (PATTERN (insn), map, 0);\n \t  copy = emit_jump_insn (pattern);\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n \n@@ -2107,14 +2107,15 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t  break;\n \n \tcase CALL_INSN:\n-\t  pattern = copy_rtx_and_substitute (PATTERN (insn), map);\n+\t  pattern = copy_rtx_and_substitute (PATTERN (insn), map, 0);\n \t  copy = emit_call_insn (pattern);\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n \n \t  /* Because the USAGE information potentially contains objects other\n \t     than hard registers, we need to copy it.  */\n \t  CALL_INSN_FUNCTION_USAGE (copy)\n-\t    = copy_rtx_and_substitute (CALL_INSN_FUNCTION_USAGE (insn), map);\n+\t    = copy_rtx_and_substitute (CALL_INSN_FUNCTION_USAGE (insn),\n+\t\t\t\t       map, 0);\n \n #ifdef HAVE_cc0\n \t  if (cc0_insn)"}, {"sha": "e88f0cbd79cd346c27914f18099415f23ce68d9a", "filename": "gcc/varasm.c", "status": "modified", "additions": 204, "deletions": 26, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a774a9d22db91fb6387cb8eb61060b61782f29/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=14a774a9d22db91fb6387cb8eb61060b61782f29", "patch": "@@ -2343,6 +2343,7 @@ struct constant_descriptor\n {\n   struct constant_descriptor *next;\n   char *label;\n+  rtx rtl;\n   char contents[1];\n };\n \n@@ -2361,6 +2362,7 @@ mark_const_hash_entry (ptr)\n   while (desc)\n     {\n       ggc_mark_string (desc->label);\n+      ggc_mark_rtx (desc->rtl);\n       desc = desc->next;\n     }\n }\n@@ -2576,6 +2578,7 @@ compare_constant_1 (exp, p)\n \t  register tree link;\n \t  int length = list_length (CONSTRUCTOR_ELTS (exp));\n \t  tree type;\n+\t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n \t  int have_purpose = 0;\n \n \t  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n@@ -2599,6 +2602,14 @@ compare_constant_1 (exp, p)\n \t  if (bcmp ((char *) &type, p, sizeof type))\n \t    return 0;\n \n+\t  if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n+\t    {\n+\t      if (bcmp ((char *) &mode, p, sizeof mode))\n+\t\treturn 0;\n+\n+\t      p += sizeof mode;\n+\t    }\n+\n \t  p += sizeof type;\n \n \t  if (bcmp ((char *) &have_purpose, p, sizeof have_purpose))\n@@ -2715,12 +2726,14 @@ record_constant (exp)\n {\n   struct constant_descriptor *next = 0;\n   char *label = 0;\n+  rtx rtl = 0;\n \n-  /* Make a struct constant_descriptor.  The first two pointers will\n+  /* Make a struct constant_descriptor.  The first three pointers will\n      be filled in later.  Here we just leave space for them.  */\n \n   obstack_grow (&permanent_obstack, (char *) &next, sizeof next);\n   obstack_grow (&permanent_obstack, (char *) &label, sizeof label);\n+  obstack_grow (&permanent_obstack, (char *) &rtl, sizeof rtl);\n   record_constant_1 (exp);\n   return (struct constant_descriptor *) obstack_finish (&permanent_obstack);\n }\n@@ -2785,6 +2798,7 @@ record_constant_1 (exp)\n \t{\n \t  register tree link;\n \t  int length = list_length (CONSTRUCTOR_ELTS (exp));\n+\t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n \t  tree type;\n \t  int have_purpose = 0;\n \n@@ -2795,14 +2809,18 @@ record_constant_1 (exp)\n \t  obstack_grow (&permanent_obstack, (char *) &length, sizeof length);\n \n \t  /* For record constructors, insist that the types match.\n-\t     For arrays, just verify both constructors are for arrays. \n-\t     Then insist that either both or none have any TREE_PURPOSE\n-\t     values.  */\n+\t     For arrays, just verify both constructors are for arrays\n+\t     of the same mode.  Then insist that either both or none\n+\t     have any TREE_PURPOSE values.  */\n \t  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n \t    type = TREE_TYPE (exp);\n \t  else\n \t    type = 0;\n+\n \t  obstack_grow (&permanent_obstack, (char *) &type, sizeof type);\n+\t  if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n+\t    obstack_grow (&permanent_obstack, &mode, sizeof mode);\n+\t\t\t  \n \t  obstack_grow (&permanent_obstack, (char *) &have_purpose,\n \t\t\tsizeof have_purpose);\n \n@@ -3027,9 +3045,8 @@ output_constant_def (exp)\n   register int hash;\n   register struct constant_descriptor *desc;\n   char label[256];\n-  char *found = 0;\n   int reloc;\n-  register rtx def;\n+  int found = 1;\n \n   if (TREE_CST_RTL (exp))\n     return TREE_CST_RTL (exp);\n@@ -3047,12 +3064,9 @@ output_constant_def (exp)\n       \n   for (desc = const_hash_table[hash]; desc; desc = desc->next)\n     if (compare_constant (exp, desc))\n-      {\n-\tfound = desc->label;\n-\tbreak;\n-      }\n+      break;\n       \n-  if (found == 0)\n+  if (desc == 0)\n     {\n       /* No constant equal to EXP is known to have been output.\n \t Make a constant descriptor to enter EXP in the hash table.\n@@ -3066,23 +3080,30 @@ output_constant_def (exp)\n       desc->next = const_hash_table[hash];\n       desc->label = ggc_alloc_string (label, -1);\n       const_hash_table[hash] = desc;\n-    }\n   \n-  /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n+      /* We have a symbol name; construct the SYMBOL_REF and the MEM\n+\t in the permanent obstack.  We could also construct this in the\n+\t obstack of EXP and put it into TREE_CST_RTL, but we have no way\n+\t of knowing what obstack it is (e.g., it might be in a function\n+\t obstack of a function we are nested inside).  */\n \n-  push_obstacks_nochange ();\n-  if (TREE_PERMANENT (exp))\n-    end_temporary_allocation ();\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n \n-  def = gen_rtx_SYMBOL_REF (Pmode, desc->label);\n-      \n-  TREE_CST_RTL (exp)\n-    = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)), def);\n-  RTX_UNCHANGING_P (TREE_CST_RTL (exp)) = 1;\n-  if (AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n-    MEM_SET_IN_STRUCT_P (TREE_CST_RTL (exp), 1);\n+      desc->rtl\n+\t= gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t       gen_rtx_SYMBOL_REF (Pmode, desc->label));\n \n-  pop_obstacks ();\n+      RTX_UNCHANGING_P (desc->rtl) = 1;\n+      if (AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n+\tMEM_SET_IN_STRUCT_P (desc->rtl, 1);\n+\n+      pop_obstacks ();\n+\n+      found = 0;\n+    }\n+\n+  TREE_CST_RTL (exp) = desc->rtl;\n \n   /* Optionally set flags or add text to the name to record information\n      such as that it is a function name.  If the name is changed, the macro\n@@ -3093,7 +3114,7 @@ output_constant_def (exp)\n \n   /* If this is the first time we've seen this particular constant,\n      output it (or defer its output for later).  */\n-  if (found == 0)\n+  if (! found)\n     {\n       int after_function = 0;\n \n@@ -3482,6 +3503,7 @@ record_constant_rtx (mode, x)\n {\n   struct constant_descriptor *ptr;\n   char *label;\n+  rtx rtl;\n   struct rtx_const value;\n \n   decode_rtx_const (mode, x, &value);\n@@ -3491,6 +3513,7 @@ record_constant_rtx (mode, x)\n      memory allocated from function_obstack (current_obstack).  */\n   obstack_grow (saveable_obstack, &ptr, sizeof ptr);\n   obstack_grow (saveable_obstack, &label, sizeof label);\n+  obstack_grow (saveable_obstack, &rtl, sizeof rtl);\n \n   /* Record constant contents.  */\n   obstack_grow (saveable_obstack, &value, sizeof value);\n@@ -3988,6 +4011,161 @@ output_addressed_constants (exp)\n   return reloc;\n }\n \f\n+/* Return nonzero if VALUE is a valid constant-valued expression\n+   for use in initializing a static variable; one that can be an\n+   element of a \"constant\" initializer.\n+\n+   Return null_pointer_node if the value is absolute;\n+   if it is relocatable, return the variable that determines the relocation.\n+   We assume that VALUE has been folded as much as possible;\n+   therefore, we do not need to check for such things as\n+   arithmetic-combinations of integers.  */\n+\n+tree\n+initializer_constant_valid_p (value, endtype)\n+     tree value;\n+     tree endtype;\n+{\n+  switch (TREE_CODE (value))\n+    {\n+    case CONSTRUCTOR:\n+      if ((TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n+\t   || TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE)\n+\t  && TREE_CONSTANT (value)\n+\t  && CONSTRUCTOR_ELTS (value))\n+\treturn\n+\t  initializer_constant_valid_p (TREE_VALUE (CONSTRUCTOR_ELTS (value)),\n+\t\t\t\t\tendtype);\n+\t\n+      return TREE_STATIC (value) ? null_pointer_node : 0;\n+\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+    case COMPLEX_CST:\n+      return null_pointer_node;\n+\n+    case ADDR_EXPR:\n+      return TREE_OPERAND (value, 0);\n+\n+    case NON_LVALUE_EXPR:\n+      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+      /* Allow conversions between pointer types.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (value))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow conversions between real types.  */\n+      if (FLOAT_TYPE_P (TREE_TYPE (value))\n+\t  && FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow length-preserving conversions between integer types.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0)))\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow conversions between other integer types only if\n+\t explicit value.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\t{\n+\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t     endtype);\n+\t  if (inner == null_pointer_node)\n+\t    return null_pointer_node;\n+\t  break;\n+\t}\n+\n+      /* Allow (int) &foo provided int is as wide as a pointer.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0)))\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n+\n+      /* Likewise conversions from int to pointers, but also allow\n+\t conversions from 0.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (value))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\t{\n+\t  if (integer_zerop (TREE_OPERAND (value, 0)))\n+\t    return null_pointer_node;\n+\t  else if (TYPE_PRECISION (TREE_TYPE (value))\n+\t\t   <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0))))\n+\t    return initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t endtype);\n+\t}\n+\n+      /* Allow conversions to union types if the value inside is okay.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n+      break;\n+\n+    case PLUS_EXPR:\n+      if (! INTEGRAL_TYPE_P (endtype)\n+\t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n+        {\n+\t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t      endtype);\n+\t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n+\t\t\t\t\t\t      endtype);\n+\t  /* If either term is absolute, use the other terms relocation.  */\n+\t  if (valid0 == null_pointer_node)\n+\t    return valid1;\n+\t  if (valid1 == null_pointer_node)\n+\t    return valid0;\n+        }\n+      break;\n+\n+    case MINUS_EXPR:\n+      if (! INTEGRAL_TYPE_P (endtype)\n+\t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n+\t{\n+\t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t      endtype);\n+\t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n+\t\t\t\t\t\t      endtype);\n+\t  /* Win if second argument is absolute.  */\n+\t  if (valid1 == null_pointer_node)\n+\t    return valid0;\n+\t  /* Win if both arguments have the same relocation.\n+\t     Then the value is absolute.  */\n+\t  if (valid0 == valid1 && valid0 != 0)\n+\t    return null_pointer_node;\n+\t}\n+\n+      /* Support differences between labels.  */\n+      if (INTEGRAL_TYPE_P (endtype))\n+\t{\n+\t  tree op0, op1;\n+\t  op0 = TREE_OPERAND (value, 0);\n+\t  op1 = TREE_OPERAND (value, 1);\n+\t  STRIP_NOPS (op0);\n+\t  STRIP_NOPS (op1);\n+\n+\t  if (TREE_CODE (op0) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (op0, 0)) == LABEL_DECL\n+\t      && TREE_CODE (op1) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (op1, 0)) == LABEL_DECL)\n+\t    return null_pointer_node;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\f\n /* Output assembler code for constant EXP to FILE, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n    Assumes output_addressed_constants has been done on EXP already.\n@@ -4608,7 +4786,7 @@ make_decl_one_only (decl)\n void\n init_varasm_once ()\n {\n-  ggc_add_root (const_hash_table, MAX_HASH_TABLE, sizeof(const_hash_table[0]),\n+  ggc_add_root (const_hash_table, MAX_HASH_TABLE, sizeof const_hash_table[0],\n \t\tmark_const_hash_entry);\n   ggc_add_string_root (&in_named_name, 1);\n }"}]}