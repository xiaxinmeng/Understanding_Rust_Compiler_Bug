{"sha": "45ce0f05e0d77adccc0d91fcc8404c6f37138526", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVjZTBmMDVlMGQ3N2FkY2NjMGQ5MWZjYzg0MDRjNmYzNzEzODUyNg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2015-05-12T13:42:21Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2015-05-12T13:42:21Z"}, "message": "combine.c (recog_for_combine_1): New function, factored out from recog_for_combine.\n\n\t* combine.c (recog_for_combine_1): New function, factored out\n\tfrom recog_for_combine.\n\t(change_zero_ext): New function.\n\t(recog_for_combine): If recog fails, try again with the pattern\n\tmodified by change_zero_ext; if that still fails, restore the\n\tpattern.\n\nFrom-SVN: r223067", "tree": {"sha": "327e0dd7f1eaf2c68d0e9eb375b96c40c4b16f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/327e0dd7f1eaf2c68d0e9eb375b96c40c4b16f25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45ce0f05e0d77adccc0d91fcc8404c6f37138526", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ce0f05e0d77adccc0d91fcc8404c6f37138526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ce0f05e0d77adccc0d91fcc8404c6f37138526", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ce0f05e0d77adccc0d91fcc8404c6f37138526/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1bcc1e4102b64d93441c0318c537a182923c331b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bcc1e4102b64d93441c0318c537a182923c331b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bcc1e4102b64d93441c0318c537a182923c331b"}], "stats": {"total": 129, "additions": 116, "deletions": 13}, "files": [{"sha": "f084795cda951516b411d1cab488a6b29d6c8f0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ce0f05e0d77adccc0d91fcc8404c6f37138526/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ce0f05e0d77adccc0d91fcc8404c6f37138526/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45ce0f05e0d77adccc0d91fcc8404c6f37138526", "patch": "@@ -1,3 +1,12 @@\n+2015-05-12  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* combine.c (recog_for_combine_1): New function, factored out\n+\tfrom recog_for_combine.\n+\t(change_zero_ext): New function.\n+\t(recog_for_combine): If recog fails, try again with the pattern\n+\tmodified by change_zero_ext; if that still fails, restore the\n+\tpattern.\n+\n 2015-05-12  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* combine.c (get_undo_marker): New function."}, {"sha": "1c1a74fdaa6809c04d80eaf5e3b44503e337eaef", "filename": "gcc/combine.c", "status": "modified", "additions": 107, "deletions": 13, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ce0f05e0d77adccc0d91fcc8404c6f37138526/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ce0f05e0d77adccc0d91fcc8404c6f37138526/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=45ce0f05e0d77adccc0d91fcc8404c6f37138526", "patch": "@@ -10879,21 +10879,11 @@ simplify_shift_const (rtx x, enum rtx_code code, machine_mode result_mode,\n }\n \n \f\n-/* Like recog, but we receive the address of a pointer to a new pattern.\n-   We try to match the rtx that the pointer points to.\n-   If that fails, we may try to modify or replace the pattern,\n-   storing the replacement into the same pointer object.\n-\n-   Modifications include deletion or addition of CLOBBERs.\n-\n-   PNOTES is a pointer to a location where any REG_UNUSED notes added for\n-   the CLOBBERs are placed.\n-\n-   The value is the final insn code from the pattern ultimately matched,\n-   or -1.  */\n+/* A subroutine of recog_for_combine.  See there for arguments and\n+   return value.  */\n \n static int\n-recog_for_combine (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n+recog_for_combine_1 (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n {\n   rtx pat = *pnewpat;\n   rtx pat_without_clobbers;\n@@ -11040,6 +11030,110 @@ recog_for_combine (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n \n   return insn_code_number;\n }\n+\n+/* Change every ZERO_EXTRACT and ZERO_EXTEND of a SUBREG that can be\n+   expressed as an AND and maybe an LSHIFTRT, to that formulation.\n+   Return whether anything was so changed.  */\n+\n+static bool\n+change_zero_ext (rtx *src)\n+{\n+  bool changed = false;\n+\n+  subrtx_ptr_iterator::array_type array;\n+  FOR_EACH_SUBRTX_PTR (iter, array, src, NONCONST)\n+    {\n+      rtx x = **iter;\n+      machine_mode mode = GET_MODE (x);\n+      int size;\n+\n+      if (GET_CODE (x) == ZERO_EXTRACT\n+\t  && CONST_INT_P (XEXP (x, 1))\n+\t  && CONST_INT_P (XEXP (x, 2))\n+\t  && GET_MODE (XEXP (x, 0)) == mode)\n+\t{\n+\t  size = INTVAL (XEXP (x, 1));\n+\n+\t  int start = INTVAL (XEXP (x, 2));\n+\t  if (BITS_BIG_ENDIAN)\n+\t    start = GET_MODE_PRECISION (mode) - size - start;\n+\n+\t  x = gen_rtx_LSHIFTRT (mode, XEXP (x, 0), GEN_INT (start));\n+\t}\n+      else if (GET_CODE (x) == ZERO_EXTEND\n+\t       && GET_CODE (XEXP (x, 0)) == SUBREG\n+\t       && GET_MODE (SUBREG_REG (XEXP (x, 0))) == mode\n+\t       && subreg_lowpart_p (XEXP (x, 0)))\n+\t{\n+\t  size = GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)));\n+\t  x = SUBREG_REG (XEXP (x, 0));\n+\t}\n+      else\n+\tcontinue;\n+\n+      unsigned HOST_WIDE_INT mask = 1;\n+      mask <<= size;\n+      mask--;\n+\n+      x = gen_rtx_AND (mode, x, GEN_INT (mask));\n+\n+      SUBST (**iter, x);\n+      changed = true;\n+    }\n+\n+  return changed;\n+}\n+\n+/* Like recog, but we receive the address of a pointer to a new pattern.\n+   We try to match the rtx that the pointer points to.\n+   If that fails, we may try to modify or replace the pattern,\n+   storing the replacement into the same pointer object.\n+\n+   Modifications include deletion or addition of CLOBBERs.  If the\n+   instruction will still not match, we change ZERO_EXTEND and ZERO_EXTRACT\n+   to the equivalent AND and perhaps LSHIFTRT patterns, and try with that\n+   (and undo if that fails).\n+\n+   PNOTES is a pointer to a location where any REG_UNUSED notes added for\n+   the CLOBBERs are placed.\n+\n+   The value is the final insn code from the pattern ultimately matched,\n+   or -1.  */\n+\n+static int\n+recog_for_combine (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n+{\n+  rtx pat = PATTERN (insn);\n+  int insn_code_number = recog_for_combine_1 (pnewpat, insn, pnotes);\n+  if (insn_code_number >= 0 || check_asm_operands (pat))\n+    return insn_code_number;\n+\n+  void *marker = get_undo_marker ();\n+  bool changed = false;\n+\n+  if (GET_CODE (pat) == SET)\n+    changed = change_zero_ext (&SET_SRC (pat));\n+  else if (GET_CODE (pat) == PARALLEL)\n+    {\n+      int i;\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx set = XVECEXP (pat, 0, i);\n+\t  if (GET_CODE (set) == SET)\n+\t    changed |= change_zero_ext (&SET_SRC (set));\n+\t}\n+    }\n+\n+  if (changed)\n+    {\n+      insn_code_number = recog_for_combine_1 (pnewpat, insn, pnotes);\n+\n+      if (insn_code_number < 0)\n+\tundo_to_marker (marker);\n+    }\n+\n+  return insn_code_number;\n+}\n \f\n /* Like gen_lowpart_general but for use by combine.  In combine it\n    is not possible to create any new pseudoregs.  However, it is"}]}