{"sha": "15d8a51dee9e80190ac43afc9b553976776e17a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVkOGE1MWRlZTllODAxOTBhYzQzYWZjOWI1NTM5NzY3NzZlMTdhOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:50:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:50:50Z"}, "message": "[multiple changes]\n\n2011-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch5.adb, exp_ch7.adb, exp_util.adb, bindgen.adb, sem_prag.adb,\n\ts-tassta.adb, exp_ch4.adb, exp_disp.adb, s-stausa.adb: Minor\n\treformatting.\n\n2011-08-04  Arnaud Charlet  <charlet@adacore.com>\n\n\t* make.adb (Linking_Phase): Set source search path before calling\n\tgnatlink in CodePeer mode.\n\nFrom-SVN: r177388", "tree": {"sha": "bd9bf8ec7cc3d3b591ef5f5bd4457dbf781acc82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd9bf8ec7cc3d3b591ef5f5bd4457dbf781acc82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15d8a51dee9e80190ac43afc9b553976776e17a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d8a51dee9e80190ac43afc9b553976776e17a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15d8a51dee9e80190ac43afc9b553976776e17a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d8a51dee9e80190ac43afc9b553976776e17a9/comments", "author": null, "committer": null, "parents": [{"sha": "f46faa08530f834488a7ab292af8946005d3b153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46faa08530f834488a7ab292af8946005d3b153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f46faa08530f834488a7ab292af8946005d3b153"}], "stats": {"total": 184, "additions": 110, "deletions": 74}, "files": [{"sha": "5089441c14e44df9ddafd73c375ece8888142fb8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -1,3 +1,14 @@\n+2011-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch5.adb, exp_ch7.adb, exp_util.adb, bindgen.adb, sem_prag.adb,\n+\ts-tassta.adb, exp_ch4.adb, exp_disp.adb, s-stausa.adb: Minor\n+\treformatting.\n+\n+2011-08-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* make.adb (Linking_Phase): Set source search path before calling\n+\tgnatlink in CodePeer mode.\n+\n 2011-08-04  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch7.adb (Expand_N_Package_Body, Expand_N_Package_Declaration):"}, {"sha": "8c89a5095a89c155b0d75b97b9fc62b855c9e3e6", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -1,4 +1,4 @@\n------------------------------------------------------------------------------\n+------------------------------------------------------------------------------\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n@@ -467,8 +467,8 @@ package body Bindgen is\n          end if;\n \n       --  Pragma Import C cannot be used on virtual machine targets, therefore\n-      --  call the runtime finalization routine directly.\n-      --  Similarly in CodePeer mode, where imported functions are ignored.\n+      --  call the runtime finalization routine directly. Similarly in CodePeer\n+      --  mode, where imported functions are ignored.\n \n       else\n          WBI (\"      System.Standard_Library.Adafinal;\");\n@@ -1406,6 +1406,7 @@ package body Bindgen is\n \n    procedure Gen_Elab_Calls_Ada is\n       Check_Elab_Flag : Boolean;\n+\n    begin\n       for E in Elab_Order.First .. Elab_Order.Last loop\n          declare\n@@ -1478,9 +1479,9 @@ package body Bindgen is\n             elsif U.Unit_Kind /= 's' or else not CodePeer_Mode then\n                Check_Elab_Flag :=\n                  not CodePeer_Mode\n-                 and then (Force_Checking_Of_Elaboration_Flags\n-                            or Interface_Library_Unit\n-                            or not Bind_Main_Program);\n+                   and then (Force_Checking_Of_Elaboration_Flags\n+                              or Interface_Library_Unit\n+                              or not Bind_Main_Program);\n \n                if Check_Elab_Flag then\n                   Set_String (\"      if E\");\n@@ -2179,6 +2180,7 @@ package body Bindgen is\n \n          Callee_Name : String renames Name_Buffer (1 .. Name_Len - 2);\n          --  Strip trailing \"%b\"\n+\n       begin\n          if ALIs.Table (ALIs.First).Main_Program = Proc then\n             WBI (\"   procedure \" & CodePeer_Wrapper_Name & \" is \");\n@@ -2277,6 +2279,7 @@ package body Bindgen is\n             if ALIs.Table (ALIs.First).Main_Program = Func then\n                WBI (\"      Result : Integer;\");\n             end if;\n+\n          else\n             --  To call the main program, we declare it using a pragma Import\n             --  Ada with the right link name.\n@@ -2330,7 +2333,7 @@ package body Bindgen is\n       --  with a pragma Volatile in order to tell the compiler to preserve\n       --  this variable at any level of optimization.\n \n-      if Bind_Main_Program and then not CodePeer_Mode then\n+      if Bind_Main_Program and not CodePeer_Mode then\n          WBI\n            (\"      Ensure_Reference : aliased System.Address := \" &\n             \"Ada_Main_Program_Name'Address;\");\n@@ -3312,8 +3315,8 @@ package body Bindgen is\n       Gen_Adainit_Ada;\n \n       if Bind_Main_Program and then VM_Target = No_VM then\n-         --  For CodePeer, declare a wrapper for the\n-         --  user-defined main program.\n+\n+         --  For CodePeer, declare a wrapper for the user-defined main program\n \n          if CodePeer_Mode then\n             Gen_CodePeer_Wrapper;"}, {"sha": "0a9ddb1c3367deca9c5eef82c3a9defe6c32e9f0", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -659,8 +659,7 @@ package body Exp_Ch4 is\n                 Attribute_Name => Name_Tag);\n \n             if Tagged_Type_Expansion then\n-               New_Node :=\n-                 Build_Get_Access_Level (Loc, New_Node);\n+               New_Node := Build_Get_Access_Level (Loc, New_Node);\n \n             elsif VM_Target /= No_VM then\n                New_Node :="}, {"sha": "6bf5246324484d7fe294ebec82be569ddc70998e", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -2462,7 +2462,6 @@ package body Exp_Ch5 is\n            and then Nkind (Alt) = N_Case_Statement_Alternative\n          loop\n             Process_Statements_For_Controlled_Objects (Alt);\n-\n             Next (Alt);\n          end loop;\n       end;"}, {"sha": "aef06214b2f305ee19b932a8bb4b9466adf86b3d", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -3936,8 +3936,8 @@ package body Exp_Ch7 is\n \n       if Tagged_Type_Expansion\n         and then (Is_Compilation_Unit (Id)\n-                    or else (Is_Generic_Instance (Id)\n-                               and then Is_Library_Level_Entity (Id)))\n+                   or else (Is_Generic_Instance (Id)\n+                             and then Is_Library_Level_Entity (Id)))\n       then\n          Build_Static_Dispatch_Tables (N);\n       end if;"}, {"sha": "a577a2512ac633c9db37e718a8175347e3f251cf", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -6649,7 +6649,7 @@ package body Exp_Disp is\n              Name => New_Reference_To (RTE (RE_Check_TSD), Loc),\n              Parameter_Associations => New_List (\n                Make_Attribute_Reference (Loc,\n-                 Prefix => New_Reference_To (TSD, Loc),\n+                 Prefix         => New_Reference_To (TSD, Loc),\n                  Attribute_Name => Name_Unrestricted_Access))));\n       end if;\n \n@@ -6661,7 +6661,7 @@ package body Exp_Disp is\n           Name => New_Reference_To (RTE (RE_Register_TSD), Loc),\n           Parameter_Associations => New_List (\n             Make_Attribute_Reference (Loc,\n-              Prefix => New_Reference_To (TSD, Loc),\n+              Prefix         => New_Reference_To (TSD, Loc),\n               Attribute_Name => Name_Unrestricted_Access))));\n \n       --  Populate the two auxiliary tables used for dispatching asynchronous,"}, {"sha": "fbf7fe92038c6d4119c0976dad4600b2bede54fb", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -5468,7 +5468,6 @@ package body Exp_Util is\n \n       function Are_Wrapped (L : List_Id) return Boolean is\n          Stmt : constant Node_Id := First (L);\n-\n       begin\n          return\n            Present (Stmt)\n@@ -5494,15 +5493,14 @@ package body Exp_Util is\n \n    begin\n       case Nkind (N) is\n-         when N_Elsif_Part                 |\n-              N_If_Statement               |\n-              N_Conditional_Entry_Call     |\n-              N_Selective_Accept           =>\n+         when N_Elsif_Part             |\n+              N_If_Statement           |\n+              N_Conditional_Entry_Call |\n+              N_Selective_Accept       =>\n \n             --  Check the \"then statements\" for elsif parts and if statements\n \n-            if Nkind_In (N, N_Elsif_Part,\n-                            N_If_Statement)\n+            if Nkind_In (N, N_Elsif_Part, N_If_Statement)\n               and then not Is_Empty_List (Then_Statements (N))\n               and then not Are_Wrapped (Then_Statements (N))\n               and then Requires_Cleanup_Actions"}, {"sha": "ec5cfb0f610f988105602615167459a4645bed1f", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -4357,16 +4357,16 @@ package body Make is\n                   end if;\n                end;\n             end if;\n-\n          end if;\n \n          --  Put the object directories in ADA_OBJECTS_PATH\n+         --  Ditto for source directories in ADA_INCLUDE_PATH in CodePeer mode\n \n          Prj.Env.Set_Ada_Paths\n            (Main_Project,\n             Project_Tree,\n             Including_Libraries => False,\n-            Include_Path        => False);\n+            Include_Path        => CodePeer_Mode);\n \n          --  Check for attributes Linker'Linker_Options in projects other than\n          --  the main project\n@@ -4581,7 +4581,6 @@ package body Make is\n                  new String'(\"-F=\" & Get_Name_String (Mapping_Path));\n             end if;\n          end if;\n-\n       end if;\n \n       begin"}, {"sha": "6ccc386c7f4323c36d37a42e4179301be32080f0", "filename": "gcc/ada/s-stausa.adb", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -129,8 +129,8 @@ package body System.Stack_Usage is\n       Result_Array := new Result_Array_Type (1 .. Buffer_Size);\n       Result_Array.all :=\n         (others =>\n-           (Task_Name => (others => ASCII.NUL),\n-            Value     => 0,\n+           (Task_Name   => (others => ASCII.NUL),\n+            Value       => 0,\n             Stack_Size  => 0));\n \n       --  Set the Is_Enabled flag to true, so that the task wrapper knows that\n@@ -176,6 +176,7 @@ package body System.Stack_Usage is\n    ----------------\n \n    procedure Fill_Stack (Analyzer : in out Stack_Analyzer) is\n+\n       --  Change the local variables and parameters of this function with\n       --  super-extra care. The more the stack frame size of this function is\n       --  big, the more an \"instrumentation threshold at writing\" error is\n@@ -188,21 +189,23 @@ package body System.Stack_Usage is\n       --  allocated byte on the stack.\n    begin\n       if Parameters.Stack_Grows_Down then\n-         if Analyzer.Stack_Base - Stack_Address (Analyzer.Pattern_Size)\n-           > To_Stack_Address (Current_Stack_Level'Address) - Guard\n+         if Analyzer.Stack_Base - Stack_Address (Analyzer.Pattern_Size) >\n+              To_Stack_Address (Current_Stack_Level'Address) - Guard\n          then\n             --  No room for a pattern\n+\n             Analyzer.Pattern_Size := 0;\n             return;\n          end if;\n \n-         Analyzer.Pattern_Limit := Analyzer.Stack_Base\n-           - Stack_Address (Analyzer.Pattern_Size);\n+         Analyzer.Pattern_Limit :=\n+           Analyzer.Stack_Base - Stack_Address (Analyzer.Pattern_Size);\n \n          if Analyzer.Stack_Base >\n-           To_Stack_Address (Current_Stack_Level'Address) - Guard\n+              To_Stack_Address (Current_Stack_Level'Address) - Guard\n          then\n             --  Reduce pattern size to prevent local frame overwrite\n+\n             Analyzer.Pattern_Size :=\n               Integer (To_Stack_Address (Current_Stack_Level'Address) - Guard\n                          - Analyzer.Pattern_Limit);\n@@ -211,42 +214,47 @@ package body System.Stack_Usage is\n          Analyzer.Pattern_Overlay_Address :=\n            To_Address (Analyzer.Pattern_Limit);\n       else\n-         if Analyzer.Stack_Base + Stack_Address (Analyzer.Pattern_Size)\n-           < To_Stack_Address (Current_Stack_Level'Address) + Guard\n+         if Analyzer.Stack_Base + Stack_Address (Analyzer.Pattern_Size) <\n+              To_Stack_Address (Current_Stack_Level'Address) + Guard\n          then\n             --  No room for a pattern\n+\n             Analyzer.Pattern_Size := 0;\n             return;\n          end if;\n \n-         Analyzer.Pattern_Limit := Analyzer.Stack_Base\n-           + Stack_Address (Analyzer.Pattern_Size);\n+         Analyzer.Pattern_Limit :=\n+           Analyzer.Stack_Base + Stack_Address (Analyzer.Pattern_Size);\n \n          if Analyzer.Stack_Base <\n            To_Stack_Address (Current_Stack_Level'Address) + Guard\n          then\n             --  Reduce pattern size to prevent local frame overwrite\n-            Analyzer.Pattern_Size := Integer\n-              (Analyzer.Pattern_Limit\n-                 - (To_Stack_Address (Current_Stack_Level'Address) + Guard));\n+\n+            Analyzer.Pattern_Size :=\n+              Integer\n+                (Analyzer.Pattern_Limit -\n+                  (To_Stack_Address (Current_Stack_Level'Address) + Guard));\n          end if;\n \n          Analyzer.Pattern_Overlay_Address :=\n-           To_Address (Analyzer.Pattern_Limit\n-                         - Stack_Address (Analyzer.Pattern_Size));\n+           To_Address (Analyzer.Pattern_Limit -\n+                         Stack_Address (Analyzer.Pattern_Size));\n       end if;\n \n       --  Declare and fill the pattern buffer\n+\n       declare\n          Pattern : aliased Stack_Slots\n-           (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n+                     (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n          for Pattern'Address use Analyzer.Pattern_Overlay_Address;\n \n       begin\n          if System.Parameters.Stack_Grows_Down then\n             for J in reverse Pattern'Range loop\n                Pattern (J) := Analyzer.Pattern;\n             end loop;\n+\n          else\n             for J in Pattern'Range loop\n                Pattern (J) := Analyzer.Pattern;\n@@ -284,7 +292,7 @@ package body System.Stack_Usage is\n       else\n          Analyzer.Task_Name :=\n            Task_Name (Task_Name'First ..\n-                        Task_Name'First + Task_Name_Length - 1);\n+                      Task_Name'First + Task_Name_Length - 1);\n       end if;\n \n       Next_Id := Next_Id + 1;\n@@ -322,6 +330,7 @@ package body System.Stack_Usage is\n \n    begin\n       --  Value if the pattern was not modified\n+\n       if Parameters.Stack_Grows_Down then\n          Analyzer.Topmost_Touched_Mark :=\n            Analyzer.Pattern_Limit + Stack_Address (Analyzer.Pattern_Size);\n@@ -341,17 +350,17 @@ package body System.Stack_Usage is\n       if System.Parameters.Stack_Grows_Down then\n          for J in Stack'Range loop\n             if Stack (J) /= Analyzer.Pattern then\n-               Analyzer.Topmost_Touched_Mark\n-                 := To_Stack_Address (Stack (J)'Address);\n+               Analyzer.Topmost_Touched_Mark :=\n+                 To_Stack_Address (Stack (J)'Address);\n                exit;\n             end if;\n          end loop;\n \n       else\n          for J in reverse Stack'Range loop\n             if Stack (J) /= Analyzer.Pattern then\n-               Analyzer.Topmost_Touched_Mark\n-                 := To_Stack_Address (Stack (J)'Address);\n+               Analyzer.Topmost_Touched_Mark :=\n+                 To_Stack_Address (Stack (J)'Address);\n                exit;\n             end if;\n          end loop;\n@@ -407,8 +416,9 @@ package body System.Stack_Usage is\n       Max_Stack_Size_Len, Max_Actual_Use_Len : Natural := 0;\n \n       Task_Name_Blanks : constant\n-        String (1 .. Task_Name_Length - Task_Name_Str'Length) :=\n-          (others => ' ');\n+                           String\n+                             (1 .. Task_Name_Length - Task_Name_Str'Length) :=\n+                               (others => ' ');\n \n    begin\n       Set_Output (Standard_Error);\n@@ -444,12 +454,14 @@ package body System.Stack_Usage is\n \n          declare\n             Stack_Size_Blanks  : constant\n-              String (1 .. Max_Stack_Size_Len - Stack_Size_Str'Length) :=\n-                (others => ' ');\n+                                   String (1 .. Max_Stack_Size_Len -\n+                                                  Stack_Size_Str'Length) :=\n+                                      (others => ' ');\n \n             Stack_Usage_Blanks : constant\n-              String (1 .. Max_Actual_Use_Len - Actual_Size_Str'Length) :=\n-                (others => ' ');\n+                                   String (1 .. Max_Actual_Use_Len -\n+                                                  Actual_Size_Str'Length) :=\n+                                      (others => ' ');\n \n          begin\n             if Stack_Size_Str'Length > Max_Stack_Size_Len then\n@@ -491,14 +503,14 @@ package body System.Stack_Usage is\n    -------------------\n \n    procedure Report_Result (Analyzer : Stack_Analyzer) is\n-      Result  : Task_Result := (Task_Name  => Analyzer.Task_Name,\n-                                Stack_Size => Analyzer.Stack_Size,\n-                                Value      => 0);\n+      Result : Task_Result := (Task_Name  => Analyzer.Task_Name,\n+                               Stack_Size => Analyzer.Stack_Size,\n+                               Value      => 0);\n    begin\n       if Analyzer.Pattern_Size = 0 then\n+\n          --  If we have that result, it means that we didn't do any computation\n-         --  at all. In other words, we used at least everything (and possibly\n-         --  more).\n+         --  at all (i.e. we used at least everything (and possibly more).\n \n          Result.Value := Analyzer.Stack_Size;\n "}, {"sha": "8795ce7727d1880a6ab3999db77b9f0b12e1f435", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -1115,7 +1115,7 @@ package body System.Tasking.Stages is\n \n       if System.Stack_Usage.Is_Enabled then\n          declare\n-            Guard_Page_Size      : constant := 12 * 1024;\n+            Guard_Page_Size : constant := 12 * 1024;\n             --  Part of the stack used as a guard page. This is an OS dependent\n             --  value, so we need to use the maximum. This value is only used\n             --  when the stack address is known, that is currently Windows.\n@@ -1125,9 +1125,9 @@ package body System.Tasking.Stages is\n             --  smaller values resulted in segmentation faults from dynamic\n             --  stack analysis.\n \n-            Big_Overflow_Guard   : constant := 16 * 1024;\n-            Small_Stack_Limit    : constant := 64 * 1024;\n-            --  ??? These three values are experimental, and seems to work on\n+            Big_Overflow_Guard : constant := 16 * 1024;\n+            Small_Stack_Limit  : constant := 64 * 1024;\n+            --  ??? These three values are experimental, and seem to work on\n             --  most platforms. They still need to be analyzed further. They\n             --  also need documentation, what are they???\n \n@@ -1137,22 +1137,27 @@ package body System.Tasking.Stages is\n \n             Stack_Base : Address;\n             --  Address of the base of the stack\n+\n          begin\n             Stack_Base := Self_ID.Common.Compiler_Data.Pri_Stack_Info.Base;\n             if Stack_Base = Null_Address then\n+\n                --  On many platforms, we don't know the real stack base\n                --  address. Estimate it using an address in the frame.\n+\n                Stack_Base := Bottom_Of_Stack'Address;\n \n                --  Also reduce the size of the stack to take into account the\n                --  secondary stack array declared in this frame. This is for\n                --  sure very conservative.\n+\n                if not Parameters.Sec_Stack_Dynamic then\n                   Pattern_Size :=\n                     Pattern_Size - Natural (Secondary_Stack_Size);\n                end if;\n \n                --  Adjustments for inner frames\n+\n                Pattern_Size := Pattern_Size -\n                  (if Pattern_Size < Small_Stack_Limit\n                     then Small_Overflow_Guard"}, {"sha": "a0b56a98c9830a24c84cb854d45e93b09e32169b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d8a51dee9e80190ac43afc9b553976776e17a9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=15d8a51dee9e80190ac43afc9b553976776e17a9", "patch": "@@ -426,7 +426,9 @@ package body Sem_Prag is\n       --  Checks that the given argument has an identifier, and if so, requires\n       --  it to match one of the given identifier names. If there is no\n       --  identifier, or a non-matching identifier, then an error message is\n-      --  given and Pragma_Exit is raised.\n+      --  given and Pragma_Exit is raised. ??? why is this needed, why isnt\n+      --  Check_Arg_Is_One_Of good enough. At the very least explain this\n+      --  odd apparent redundancy\n \n       procedure Check_In_Main_Program;\n       --  Common checks for pragmas that appear within a main program\n@@ -6843,9 +6845,9 @@ package body Sem_Prag is\n          -- Check --\n          -----------\n \n-         --  pragma Check ([Name    =>] Identifier,\n-         --                [Check   =>] Boolean_Expression\n-         --              [,[Message =>] String_Expression]);\n+         --  pragma Check ([Name    =>] IDENTIFIER,\n+         --                [Check   =>] Boolean_EXPRESSION\n+         --              [,[Message =>] String_EXPRESSION]);\n \n          when Pragma_Check => Check : declare\n             Expr : Node_Id;\n@@ -11527,8 +11529,8 @@ package body Sem_Prag is\n          -- Postcondition --\n          -------------------\n \n-         --  pragma Postcondition ([Check   =>] Boolean_Expression\n-         --                      [,[Message =>] String_Expression]);\n+         --  pragma Postcondition ([Check   =>] Boolean_EXPRESSION\n+         --                      [,[Message =>] String_EXPRESSION]);\n \n          when Pragma_Postcondition => Postcondition : declare\n             In_Body : Boolean;\n@@ -11550,8 +11552,8 @@ package body Sem_Prag is\n          -- Precondition --\n          ------------------\n \n-         --  pragma Precondition ([Check   =>] Boolean_Expression\n-         --                     [,[Message =>] String_Expression]);\n+         --  pragma Precondition ([Check   =>] Boolean_EXPRESSION\n+         --                     [,[Message =>] String_EXPRESSION]);\n \n          when Pragma_Precondition => Precondition : declare\n             In_Body : Boolean;\n@@ -13262,10 +13264,14 @@ package body Sem_Prag is\n          -- Test_Case --\n          ---------------\n \n-         --  pragma Test_Case ([Name     =>] String_Expression\n+         --  pragma Test_Case ([Name     =>] String_EXPRESSION\n          --                   ,[Mode     =>] (Normal | Robustness)\n-         --                  [, Requires =>  Boolean_Expression]\n-         --                  [, Ensures  =>  Boolean_Expression]);\n+         --                  [, Requires =>  Boolean_EXPRESSION]\n+         --                  [, Ensures  =>  Boolean_EXPRESSION]);\n+\n+         --  ??? Why is Name not static_string_EXPRESSION??? Seems very\n+         --  weird to require it to be a string literal, and if we DO want\n+         --  that restriction the grammar should make this clear.\n \n          when Pragma_Test_Case => Test_Case : declare\n \n@@ -13280,10 +13286,14 @@ package body Sem_Prag is\n             Check_Arg_Is_String_Literal (Arg1);\n             Check_Optional_Identifier (Arg2, Name_Mode);\n             Check_Arg_Is_One_Of (Arg2, Name_Normal, Name_Robustness);\n+\n             if Arg_Count = 4 then\n                Check_Identifier (Arg3, Name_Requires);\n                Check_Identifier (Arg4, Name_Ensures);\n             else\n+               --  ??? why not Check_Arg_Is_One_Of, very odd!!! At the very\n+               --  least needs an explanation!\n+\n                Check_Identifier_Is_One_Of (Arg3, Name_Requires, Name_Ensures);\n             end if;\n "}]}