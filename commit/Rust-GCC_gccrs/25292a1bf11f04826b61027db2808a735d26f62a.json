{"sha": "25292a1bf11f04826b61027db2808a735d26f62a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUyOTJhMWJmMTFmMDQ4MjZiNjEwMjdkYjI4MDhhNzM1ZDI2ZjYyYQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-05-20T07:14:50Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-05-20T07:14:50Z"}, "message": "re PR libfortran/24459 ([4.1 Only] gfortran namelist problem)\n\n2006-05-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/24459\n\t* io/list_read.c (nml_parse_qualifier): Leave loop spec end value\n\tat default value unless -std=f95 or if an array section\n\tis specified in namelist input.  Warn if -pedantic.\n\t* io/io.h (st_parameter_dt): Add expanded_read flag.\n\nFrom-SVN: r113924", "tree": {"sha": "72d7a6767678cfbc49746dd70c1193e00863af45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72d7a6767678cfbc49746dd70c1193e00863af45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25292a1bf11f04826b61027db2808a735d26f62a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25292a1bf11f04826b61027db2808a735d26f62a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25292a1bf11f04826b61027db2808a735d26f62a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25292a1bf11f04826b61027db2808a735d26f62a/comments", "author": null, "committer": null, "parents": [{"sha": "8bf6519618696ba28021cedb319a1f784991f962", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf6519618696ba28021cedb319a1f784991f962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf6519618696ba28021cedb319a1f784991f962"}], "stats": {"total": 59, "additions": 52, "deletions": 7}, "files": [{"sha": "7f6010631014788c358fb553b7e98e4cc739d097", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25292a1bf11f04826b61027db2808a735d26f62a/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25292a1bf11f04826b61027db2808a735d26f62a/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=25292a1bf11f04826b61027db2808a735d26f62a", "patch": "@@ -1,3 +1,11 @@\n+2006-05-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/24459\n+\t* io/list_read.c (nml_parse_qualifier): Leave loop spec end value\n+\tat default value unless -std=f95 or if an array section\n+\tis specified in namelist input.  Warn if -pedantic.\n+\t* io/io.h (st_parameter_dt): Add expanded_read flag.\n+\n 2006-05-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/22423"}, {"sha": "2d3c185a08769bb4e883ccccfef0721992da0f82", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25292a1bf11f04826b61027db2808a735d26f62a/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25292a1bf11f04826b61027db2808a735d26f62a/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=25292a1bf11f04826b61027db2808a735d26f62a", "patch": "@@ -432,7 +432,9 @@ typedef struct st_parameter_dt\n \t  struct format_data *fmt;\n \t  jmp_buf *eof_jump;\n \t  namelist_info *ionml;\n-\n+\t  /* A flag used to identify when a non-standard expanded namelist read\n+\t     has occurred.  */\n+\t  int expanded_read;\n \t  /* Storage area for values except for strings.  Must be large\n \t     enough to hold a complex value (two reals) of the largest\n \t     kind.  */"}, {"sha": "0670efab86f34f24567f2ff8dc4a36bbdc447201", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25292a1bf11f04826b61027db2808a735d26f62a/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25292a1bf11f04826b61027db2808a735d26f62a/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=25292a1bf11f04826b61027db2808a735d26f62a", "patch": "@@ -1660,8 +1660,12 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n   int indx;\n   int neg;\n   int null_flag;\n+  int is_array_section;\n   char c;\n \n+  is_array_section = 0;\n+  dtp->u.p.expanded_read = 0;\n+\n   /* The next character in the stream should be the '('.  */\n \n   c = next_char (dtp);\n@@ -1700,6 +1704,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t      switch (c)\n \t\t{\n \t\tcase ':':\n+                  is_array_section = 1;\n \t\t  break;\n \n \t\tcase ',': case ')':\n@@ -1775,7 +1780,14 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t      if (indx == 0)\n \t\t{\n \t\t  memcpy (&ls[dim].start, dtp->u.p.value, sizeof(ssize_t));\n-\t\t  ls[dim].end = ls[dim].start;\n+\n+\t\t  /*  If -std=f95/2003 or an array section is specified,\n+\t\t      do not allow excess data to be processed.  */\n+                  if (is_array_section == 1\n+\t\t      || compile_options.allow_std < GFC_STD_GNU)\n+\t\t    ls[dim].end = ls[dim].start;\n+\t\t  else\n+\t\t    dtp->u.p.expanded_read = 1;\n \t\t}\n \t      break;\n \t    }\n@@ -2112,6 +2124,10 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t    strcpy (obj_name, nl->var_name);\n \t    strcat (obj_name, \"%\");\n \n+\t    /* If reading a derived type, disable the expanded read warning\n+\t       since a single object can have multiple reads.  */\n+\t    dtp->u.p.expanded_read = 0;\n+\n \t    /* Now loop over the components. Update the component pointer\n \t       with the return value from nml_write_obj.  This loop jumps\n \t       past nested derived types by testing if the potential\n@@ -2157,11 +2173,16 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \n       *pprev_nl = nl;\n       if (dtp->u.p.nml_read_error)\n-\treturn SUCCESS;\n+\t{\n+\t  dtp->u.p.expanded_read = 0;\n+\t  return SUCCESS;\n+\t}\n \n       if (dtp->u.p.saved_type == GFC_DTYPE_UNKNOWN)\n-\tgoto incr_idx;\n-\n+\t{\n+\t  dtp->u.p.expanded_read = 0;\n+\t  goto incr_idx;\n+\t}\n \n       /* Note the switch from GFC_DTYPE_type to BT_type at this point.\n \t This comes about because the read functions return BT_types.  */\n@@ -2182,14 +2203,27 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t  memcpy (pdata, dtp->u.p.saved_string, m);\n \t  if (m < dlen)\n \t    memset ((void*)( pdata + m ), ' ', dlen - m);\n-\tbreak;\n+\t  break;\n \n \tdefault:\n \t  break;\n       }\n \n-      /* Break out of loop if scalar.  */\n+      /* Warn if a non-standard expanded read occurs. A single read of a\n+\t single object is acceptable.  If a second read occurs, issue a warning\n+\t and set the flag to zero to prevent further warnings.  */\n+      if (dtp->u.p.expanded_read == 2)\n+\t{\n+\t  notify_std (GFC_STD_GNU, \"Non-standard expanded namelist read.\");\n+\t  dtp->u.p.expanded_read = 0;\n+\t}\n+\n+      /* If the expanded read warning flag is set, increment it,\n+\t indicating that a single read has occured.  */\n+      if (dtp->u.p.expanded_read >= 1)\n+\tdtp->u.p.expanded_read++;\n \n+      /* Break out of loop if scalar.  */\n       if (!nl->var_rank)\n \tbreak;\n \n@@ -2500,6 +2534,7 @@ namelist_read (st_parameter_dt *dtp)\n \n   dtp->u.p.namelist_mode = 1;\n   dtp->u.p.input_complete = 0;\n+  dtp->u.p.expanded_read = 0;\n \n   dtp->u.p.eof_jump = &eof_jump;\n   if (setjmp (eof_jump))"}]}