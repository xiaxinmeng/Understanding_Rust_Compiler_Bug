{"sha": "fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJkMzViYTFiMzUyYmFhNzg1ZjdkMTFiYWZlMWFlNjQ3MDZhMmJmNQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-04T21:04:23Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-04T21:04:23Z"}, "message": "re PR fortran/83683 (eoshift accepts wrong-length boundary)\n\n2018-01-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/83683\n\tPR fortran/45689\n\t* check.c (gfc_check_eoshift): Check for string length and\n\tfor conformance of boundary.\n\t* intrinsic.c (add_functions): Add gfc_simplify_eoshift.\n\t* intrinsic.h: Add prototype for gfc_simplify_eoshift.\n\t* simplify.c (gfc_simplify_eoshift): New function.\n\n2018-01-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/83683\n\tPR fortran/45689\n\t* gfortran.dg/eoshift_8.f90: New test.\n\t* gfortran.dg/simplify_eoshift_1.f90: New test.\n\nFrom-SVN: r256265", "tree": {"sha": "399b51f5eaaf929b22f26bb2d070530254d46950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/399b51f5eaaf929b22f26bb2d070530254d46950"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/comments", "author": null, "committer": null, "parents": [{"sha": "1e678f69f7dc995a55d2cf0b4a10ffce88c0f776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e678f69f7dc995a55d2cf0b4a10ffce88c0f776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e678f69f7dc995a55d2cf0b4a10ffce88c0f776"}], "stats": {"total": 449, "additions": 433, "deletions": 16}, "files": [{"sha": "7eb453dd2cc1c61e55d7f09432b440d13a851a26", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "patch": "@@ -1,3 +1,13 @@\n+2018-01-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/83683\n+\tPR fortran/45689\n+\t* check.c (gfc_check_eoshift): Check for string length and\n+\tfor conformance of boundary.\n+\t* intrinsic.c (add_functions): Add gfc_simplify_eoshift.\n+\t* intrinsic.h: Add prototype for gfc_simplify_eoshift.\n+\t* simplify.c (gfc_simplify_eoshift): New function.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "fccb9275bec772fa974c5585875adc0e21c661b4", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "patch": "@@ -2185,6 +2185,8 @@ bool\n gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t\t   gfc_expr *dim)\n {\n+  int d;\n+\n   if (!array_check (array, 0))\n     return false;\n \n@@ -2197,21 +2199,20 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n   if (!dim_rank_check (dim, array, false))\n     return false;\n \n+  if (!dim)\n+    d = 1;\n+  else if (dim->expr_type == EXPR_CONSTANT)\n+    gfc_extract_int (dim, &d);\n+  else\n+    d = -1;\n+\n   if (array->rank == 1 || shift->rank == 0)\n     {\n       if (!scalar_check (shift, 1))\n \treturn false;\n     }\n   else if (shift->rank == array->rank - 1)\n     {\n-      int d;\n-      if (!dim)\n-\td = 1;\n-      else if (dim->expr_type == EXPR_CONSTANT)\n-\tgfc_extract_int (dim, &d);\n-      else\n-\td = -1;\n-\n       if (d > 0)\n \t{\n \t  int i, j;\n@@ -2246,20 +2247,52 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n       if (!same_type_check (array, 0, boundary, 2))\n \treturn false;\n \n+      /* Reject unequal string lengths and emit a better error message than\n+       gfc_check_same_strlen would.  */\n+      if (array->ts.type == BT_CHARACTER)\n+\t{\n+\t  ssize_t len_a, len_b;\n+\n+\t  len_a = gfc_var_strlen (array);\n+\t  len_b = gfc_var_strlen (boundary);\n+\t  if (len_a != -1 && len_b != -1 && len_a != len_b)\n+\t    {\n+\t      gfc_error (\"%qs must be of same type and kind as %qs at %L in %qs\",\n+\t\t\t gfc_current_intrinsic_arg[2]->name,\n+\t\t\t gfc_current_intrinsic_arg[0]->name,\n+\t\t\t &boundary->where, gfc_current_intrinsic);\n+\t      return false;\n+\t    }\n+\t}\n+      \n       if (array->rank == 1 || boundary->rank == 0)\n \t{\n \t  if (!scalar_check (boundary, 2))\n \t    return false;\n \t}\n       else if (boundary->rank == array->rank - 1)\n \t{\n-\t  if (!gfc_check_conformance (shift, boundary,\n-\t\t\t\t      \"arguments '%s' and '%s' for \"\n-\t\t\t\t      \"intrinsic %s\",\n-\t\t\t\t      gfc_current_intrinsic_arg[1]->name,\n-\t\t\t\t      gfc_current_intrinsic_arg[2]->name,\n-\t\t\t\t      gfc_current_intrinsic))\n-\t    return false;\n+\t  if (d > 0)\n+\t    {\n+\t      int i,j;\n+\t      for (i = 0, j = 0; i < array->rank; i++)\n+\t\t{\n+\t\t  if (i != d - 1)\n+\t\t    {\n+\t\t      if (!identical_dimen_shape (array, i, boundary, j))\n+\t\t\t{\n+\t\t\t  gfc_error (\"%qs argument of %qs intrinsic at %L has \"\n+\t\t\t\t     \"invalid shape in dimension %d (%ld/%ld)\",\n+\t\t\t\t     gfc_current_intrinsic_arg[2]->name,\n+\t\t\t\t     gfc_current_intrinsic, &shift->where, i+1,\n+\t\t\t\t     mpz_get_si (array->shape[i]),\n+\t\t\t\t     mpz_get_si (boundary->shape[j]));\n+\t\t\t  return false;\n+\t\t\t}\n+\t\t      j += 1;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n       else\n \t{"}, {"sha": "ed732aa525258d9657f483dd67fc6317c3e93b95", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "patch": "@@ -1756,7 +1756,7 @@ add_functions (void)\n   make_generic (\"dshiftr\", GFC_ISYM_DSHIFTR, GFC_STD_F2008);\n \n   add_sym_4 (\"eoshift\", GFC_ISYM_EOSHIFT, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-\t     gfc_check_eoshift, NULL, gfc_resolve_eoshift,\n+\t     gfc_check_eoshift, gfc_simplify_eoshift, gfc_resolve_eoshift,\n \t     ar, BT_REAL, dr, REQUIRED, sh, BT_INTEGER, ii, REQUIRED,\n \t     bd, BT_REAL, dr, OPTIONAL, dm, BT_INTEGER, ii, OPTIONAL);\n "}, {"sha": "a7db830d381c5a3b0cf5a284c0f7719626d869e2", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "patch": "@@ -287,6 +287,7 @@ gfc_expr *gfc_simplify_dot_product (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dreal (gfc_expr *);\n gfc_expr *gfc_simplify_dshiftl (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dshiftr (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_epsilon (gfc_expr *);\n gfc_expr *gfc_simplify_erf (gfc_expr *);\n gfc_expr *gfc_simplify_erfc (gfc_expr *);"}, {"sha": "bf8a5397c45606b05aa24759a165a2f95a505bd9", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "patch": "@@ -2347,6 +2347,271 @@ gfc_simplify_dshiftl (gfc_expr *arg1, gfc_expr *arg2, gfc_expr *shiftarg)\n }\n \n \n+gfc_expr *\n+gfc_simplify_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n+\t\t   gfc_expr *dim)\n+{\n+  bool temp_boundary;\n+  gfc_expr *bnd;\n+  gfc_expr *result;\n+  int which;\n+  gfc_expr **arrayvec, **resultvec;\n+  gfc_expr **rptr, **sptr;\n+  mpz_t size;\n+  size_t arraysize, i;\n+  gfc_constructor *array_ctor, *shift_ctor, *bnd_ctor;\n+  ssize_t shift_val, len;\n+  ssize_t count[GFC_MAX_DIMENSIONS], extent[GFC_MAX_DIMENSIONS],\n+    sstride[GFC_MAX_DIMENSIONS], a_extent[GFC_MAX_DIMENSIONS],\n+    a_stride[GFC_MAX_DIMENSIONS], ss_ex[GFC_MAX_DIMENSIONS];\n+  ssize_t rsoffset;\n+  int d, n;\n+  bool continue_loop;\n+  gfc_expr **src, **dest;\n+  size_t s_len;\n+\n+  if (!is_constant_array_expr (array))\n+    return NULL;\n+\n+  if (shift->rank > 0)\n+    gfc_simplify_expr (shift, 1);\n+\n+  if (!gfc_is_constant_expr (shift))\n+    return NULL;\n+\n+  if (boundary)\n+    {\n+      if (boundary->rank > 0)\n+\tgfc_simplify_expr (boundary, 1);\n+      \n+      if (!gfc_is_constant_expr (boundary))\n+\t  return NULL;\n+    }\n+\n+  if (dim)\n+    {\n+      if (!gfc_is_constant_expr (dim))\n+\treturn NULL;\n+      which = mpz_get_si (dim->value.integer) - 1;\n+    }\n+  else\n+    which = 0;\n+\n+  s_len = 0;\n+  if (boundary == NULL)\n+    {\n+      temp_boundary = true;\n+      switch (array->ts.type)\n+\t{\n+\t  \n+\tcase BT_INTEGER:\n+\t  bnd = gfc_get_int_expr (array->ts.kind, NULL, 0);\n+\t  break;\n+\n+\tcase BT_LOGICAL:\n+\t  bnd = gfc_get_logical_expr (array->ts.kind, NULL, 0);\n+\t  break;\n+\n+\tcase BT_REAL:\n+\t  bnd = gfc_get_constant_expr (array->ts.type, array->ts.kind, &gfc_current_locus);\n+\t  mpfr_set_ui (bnd->value.real, 0, GFC_RND_MODE);\n+\t  break;\n+\n+\tcase BT_COMPLEX:\n+\t  bnd = gfc_get_constant_expr (array->ts.type, array->ts.kind, &gfc_current_locus);\n+\t  mpc_set_ui (bnd->value.complex, 0, GFC_RND_MODE);\n+\t  break;\n+\n+\tcase BT_CHARACTER:\n+\t  s_len = mpz_get_ui (array->ts.u.cl->length->value.integer);\n+\t  bnd = gfc_get_character_expr (array->ts.kind, &gfc_current_locus, NULL, s_len);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable();\n+\n+\t}\n+    }\n+  else\n+    {\n+      temp_boundary = false;\n+      bnd = boundary;\n+    }\n+  \n+  gfc_array_size (array, &size);\n+  arraysize = mpz_get_ui (size);\n+  mpz_clear (size);\n+\n+  result = gfc_get_array_expr (array->ts.type, array->ts.kind, &array->where);\n+  result->shape = gfc_copy_shape (array->shape, array->rank);\n+  result->rank = array->rank;\n+  result->ts = array->ts;\n+\n+  if (arraysize == 0)\n+    goto final;\n+\n+  arrayvec = XCNEWVEC (gfc_expr *, arraysize);\n+  array_ctor = gfc_constructor_first (array->value.constructor);\n+  for (i = 0; i < arraysize; i++)\n+    {\n+      arrayvec[i] = array_ctor->expr;\n+      array_ctor = gfc_constructor_next (array_ctor);\n+    }\n+\n+  resultvec = XCNEWVEC (gfc_expr *, arraysize);\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+\n+  for (d=0; d < array->rank; d++)\n+    {\n+      a_extent[d] = mpz_get_si (array->shape[d]);\n+      a_stride[d] = d == 0 ? 1 : a_stride[d-1] * a_extent[d-1];\n+    }\n+\n+  if (shift->rank > 0)\n+    {\n+      shift_ctor = gfc_constructor_first (shift->value.constructor);\n+      shift_val = 0;\n+    }\n+  else\n+    {\n+      shift_ctor = NULL;\n+      shift_val = mpz_get_si (shift->value.integer);\n+    }\n+\n+  if (bnd->rank > 0)\n+    bnd_ctor = gfc_constructor_first (bnd->value.constructor);\n+  else\n+    bnd_ctor = NULL;\n+\n+  /* Shut up compiler */\n+  len = 1;\n+  rsoffset = 1;\n+\n+  n = 0;\n+  for (d=0; d < array->rank; d++)\n+    {\n+      if (d == which)\n+\t{\n+\t  rsoffset = a_stride[d];\n+\t  len = a_extent[d];\n+\t}\n+      else\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = a_extent[d];\n+\t  sstride[n] = a_stride[d];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  n++;\n+\t}\n+    }\n+\n+  continue_loop = true;\n+  d = array->rank;\n+  rptr = resultvec;\n+  sptr = arrayvec;\n+\n+  while (continue_loop)\n+    {\n+      ssize_t sh, delta;\n+\n+      if (shift_ctor)\n+\tsh = mpz_get_si (shift_ctor->expr->value.integer);\n+      else\n+\tsh = shift_val;\n+\n+      if (( sh >= 0 ? sh : -sh ) > len)\n+\t{\n+\t  delta = len;\n+\t  sh = len;\n+\t}\n+      else\n+\tdelta = (sh >= 0) ? sh: -sh;\n+\n+      if (sh > 0)\n+        {\n+          src = &sptr[delta * rsoffset];\n+          dest = rptr;\n+        }\n+      else\n+        {\n+          src = sptr;\n+          dest = &rptr[delta * rsoffset];\n+        }\n+\n+      for (n = 0; n < len - delta; n++)\n+\t{\n+\t  *dest = *src;\n+\t  dest += rsoffset;\n+\t  src += rsoffset;\n+\t}\n+\n+      if (sh < 0)\n+        dest = rptr;\n+\n+      n = delta;\n+\n+      if (bnd_ctor)\n+\t{\n+\t  while (n--)\n+\t    {\n+\t      *dest = gfc_copy_expr (bnd_ctor->expr);\n+\t      dest += rsoffset;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  while (n--)\n+\t    {\n+\t      *dest = gfc_copy_expr (bnd);\n+\t      dest += rsoffset;\n+\t    }\n+\t}\n+      rptr += sstride[0];\n+      sptr += sstride[0];\n+      if (shift_ctor)\n+\tshift_ctor =  gfc_constructor_next (shift_ctor);\n+\n+      if (bnd_ctor)\n+\tbnd_ctor = gfc_constructor_next (bnd_ctor);\n+      \n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  rptr -= ss_ex[n];\n+\t  sptr -= ss_ex[n];\n+\t  n++;\n+\t  if (n >= d - 1)\n+\t    {\n+\t      continue_loop = false;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      rptr += sstride[n];\n+\t      sptr += sstride[n];\n+\t    }\n+\t}\n+    }\n+\n+  for (i = 0; i < arraysize; i++)\n+    {\n+      gfc_constructor_append_expr (&result->value.constructor,\n+\t\t\t\t   gfc_copy_expr (resultvec[i]),\n+\t\t\t\t   NULL);\n+    }\n+\n+ final:\n+  if (temp_boundary)\n+    gfc_free_expr (bnd);\n+\n+  return result;\n+}\n+\n gfc_expr *\n gfc_simplify_erf (gfc_expr *x)\n {"}, {"sha": "7f60c14e7e430b1f11205b50b5ab6c6d60a160d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "patch": "@@ -1,3 +1,10 @@\n+2018-01-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/83683\n+\tPR fortran/45689\n+\t* gfortran.dg/eoshift_8.f90: New test.\n+\t* gfortran.dg/simplify_eoshift_1.f90: New test.\n+\n 2018-01-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/83585"}, {"sha": "0930638bc15f92d69f7b82590c5f36dbc2564b94", "filename": "gcc/testsuite/gfortran.dg/eoshift_8.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_8.f90?ref=fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! PR 83664 - invalid code that used to be accepted.\n+program main\n+  implicit none\n+  integer :: n\n+  integer :: i,n1, n2, n3\n+  character(len=3), parameter :: e(2,3,4) = reshape([(repeat(achar(i),3),i=iachar('a'),iachar('a')+2*3*4-1)], &\n+       shape(e))\n+  character(len=3), parameter :: bnd2(3,5) = reshape([(repeat(achar(i),3),i=iachar('A'),iachar('A')+3*5-1)], &\n+       shape(bnd2))\n+  character(len=3) :: f2(2,3,4) \n+\n+  n = -1\n+  f2 = eoshift(e,shift=n,boundary=bnd2) ! { dg-error \"has invalid shape\" }\n+  f2 = eoshift(e,shift=1,boundary=\"x\") ! { dg-error \"must be of same type and kind\" }\n+\n+  print '(*(1H\",A,1H\",:\",\"))',f2\n+end program main"}, {"sha": "29521b22eed24e56614b3c86c80c84c8ad2aed15", "filename": "gcc/testsuite/gfortran.dg/simplify_eoshift_1.f90", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_eoshift_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd35ba1b352baa785f7d11bafe1ae64706a2bf5/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_eoshift_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_eoshift_1.f90?ref=fbd35ba1b352baa785f7d11bafe1ae64706a2bf5", "patch": "@@ -0,0 +1,83 @@\n+! { dg-do  run }\n+program main\n+  implicit none\n+  integer :: i,n1, n2, n3\n+  integer, parameter :: a(3) = [1,2,3]\n+  integer, parameter :: b1(3) = eoshift(a,0)\n+  integer, parameter :: b2(3) = eoshift(a,1)\n+  integer, parameter :: b3(3) = eoshift(a,-2)\n+  integer, parameter :: b4(3) = eoshift(a,4,boundary=42)\n+  integer, parameter :: c(3,3) = reshape([(i,i=1,3*3)],shape(c))\n+  integer, parameter :: b5(3,3) = eoshift(c,shift=1,dim=1,boundary=33)\n+  integer, parameter :: b6(3,3) = eoshift(c,shift=2,dim=1)\n+  integer, parameter :: b7(3,3) = eoshift(c,shift=-1,dim=2)\n+  integer, parameter :: b8(3,3) = eoshift(c,shift=-1,dim=2,boundary=[-1,-2,-3])\n+  integer, parameter :: b9(3,3) = eoshift(c,shift=[-1,-1,-1])\n+  integer, parameter :: b10(3,3) = eoshift(c,shift=[-1,0,1]);\n+  integer, parameter :: b11(3,3) = eoshift(c,dim=2,shift=[-2,-1,1],boundary=42);\n+  integer, parameter :: b12(3,3) = eoshift(c,dim=1,shift=[-1,-2,0],boundary=[-3,-7,-9])\n+  real, parameter :: r(3,4,5) = reshape([(1.0*i**2,i=1,3*4*5)],shape(r))\n+  real, parameter :: q1(3,4,5) = eoshift(r,shift=1,dim=3)\n+  integer, parameter :: sh1(3,4) = reshape([-1,-2,0,3,2,5,6,-6,3,1,-1,-5],shape(sh1))\n+  real, parameter :: bnd1(3,4) = reshape([-1.,-2.,-3.,-4.,-5.,-6.,-7.,-8.,-9.,-10.,-11.,-12.],shape(bnd1))\n+  real, parameter :: q2(3,4,5) = eoshift(r,dim=3,shift=sh1)\n+  real, parameter :: q3(3,4,5) = eoshift(r,dim=3,shift=sh1,boundary=bnd1)\n+  complex(kind=8), parameter :: s(3,3) = reshape([(cmplx(i*i-5*i,-i+4,kind=8),i=1,9)],shape(s))\n+  complex(kind=8), parameter :: t(3,3) = eoshift(s,shift=4)\n+  character(len=3), parameter :: e(2,3,4) = reshape([(repeat(achar(i),3),i=iachar('a'),iachar('a')+2*3*4-1)], &\n+       shape(e))\n+  character(len=3) :: e2(2,3,4)\n+  character(len=3), parameter :: f1(2,3,4) = eoshift(e,1)\n+  character(len=3), parameter :: bnd2(2,4) = reshape([(repeat(achar(i),3),i=iachar('A'),iachar('A')+2*4-1)], &\n+       shape(bnd2))\n+  character(len=3), parameter :: f2(2,3,4) = eoshift(e,dim=2,shift=-1,boundary=bnd2);\n+  integer, parameter :: sh2(2,3) = reshape([1, -2, 0, 1, 2, -1, 2, 0],shape(sh2))\n+  character(len=3), parameter :: f3(2,3,4) = eoshift(e,dim=3,shift=sh2)\n+  integer, parameter :: empty(1:0) =[integer ::]\n+  integer, parameter :: empty2(1:0) = eoshift(empty,1)\n+  \n+  n1 = 1\n+  n2 = 2\n+  n3 = 3\n+\n+  if (any(b1 /= a)) call abort\n+  if (any(b2 /= [2, 3, 0])) call abort\n+  if (any(b3 /= [0, 0, 1])) call abort\n+  if (any(b4 /= 42)) call abort\n+  if (any(eoshift(c,shift=1,dim=n1,boundary=33) /= b5)) call abort\n+  if (any(eoshift(c,shift=2,dim=1) /= b6)) call abort\n+  if (any(eoshift(c,shift=-1,dim=2) /= b7)) call abort\n+  if (any(eoshift(c,shift=-1,dim=n2,boundary=[-1,-2,-3]) /= b8)) call abort\n+  if (any(eoshift(c,shift=-1) /= b9)) call abort\n+  if (any(eoshift(r,shift=1,dim=n3) /= q1)) call abort\n+  if (any(b10 /= reshape([ 0, 1, 2, 4, 5, 6, 8, 9, 0],shape(b10)))) call abort\n+  if (any(b11 /= reshape([42, 42,  6, 42,  2,  9,  1,  5, 42],shape(b11)))) call abort\n+  if (any(b12 /= reshape([ -3,  1,  2, -7, -7,  4,  7,  8,  9],shape(b11)))) call abort\n+  if (any(q1 /= reshape([169.,196.,225.,256.,289.,324.,361.,400.,441.,484.,529.,576.,625.,&\n+          676.,729.,784.,841.,900.,961.,1024.,1089.,1156.,1225.,1296.,1369.,1444.,1521.,&\n+          1600.,1681.,1764.,1849.,1936.,2025.,2116.,2209.,2304.,2401.,2500.,2601.,2704.,&\n+          2809.,2916.,3025.,3136.,3249.,3364.,3481.,3600.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.],&\n+          shape(q1)))) call abort\n+  if (any(q2 /= reshape([0.,0.,9.,1600.,841.,0.,0.,0.,2025.,484.,0.,0.,1.,0.,225.,2704.,&\n+          1681.,0.,0.,0.,3249.,1156.,121.,0.,169.,4.,729.,0.,2809.,0.,0.,0.,0.,2116.,&\n+          529.,0.,625.,196.,1521.,0.,0.,0.,0.,0.,0.,3364.,1225.,0.,1369.,676.,2601.,&\n+          0.,0.,0.,0.,0.,0.,0.,2209.,0.],shape(q2)))) call abort\n+  if (any(q3 /= reshape([-1.,-2.,9.,1600.,841.,-6.,-7.,-8.,2025.,484.,-11.,-12.,1.,&\n+          -2.,225.,2704.,1681.,-6.,-7.,-8.,3249.,1156.,121.,-12.,169.,4.,729.,-4.,&\n+          2809.,-6.,-7.,-8.,-9.,2116.,529.,-12.,625.,196.,1521.,-4.,-5.,-6.,-7.,-8.,&\n+          -9.,3364.,1225.,-12.,1369.,676.,2601.,-4.,-5.,-6.,-7.,-8.,-9.,-10.,2209.,-12.],&\n+          shape(q3)))) call abort\n+  if (any(f1 /= reshape([\"bbb\",\"   \",\"ddd\",\"   \",\"fff\",\"   \",\"hhh\",\"   \",\"jjj\",\"   \",\"lll\",\"   \",&\n+       \"nnn\",\"   \",\"ppp\",\"   \",\"rrr\",\"   \",\"ttt\",\"   \",\"vvv\",\"   \",\"xxx\",\"   \"], &\n+       shape(f1)))) call abort\n+  if (any(f2 /= reshape([\"AAA\",\"BBB\",\"aaa\",\"bbb\",\"ccc\",\"ddd\",\"CCC\",\"DDD\",\"ggg\",\"hhh\",\"iii\",\"jjj\",&\n+       \"EEE\",\"FFF\",\"mmm\",\"nnn\",\"ooo\",\"ppp\",\"GGG\",\"HHH\",\"sss\",\"ttt\",\"uuu\",\"vvv\"],shape(f2)))) call abort\n+\n+  e2 = e\n+  if (any (f2 /= eoshift(e2,dim=2,shift=-1,boundary=bnd2))) call abort\n+  if (any (f3 /= reshape ([\"ggg\",\"   \",\"ccc\",\"jjj\",\"qqq\",\"   \",\"mmm\",\"   \",\"iii\",\"ppp\",&\n+       \"www\",\"fff\",\"sss\",\"bbb\",\"ooo\",\"vvv\",\"   \",\"lll\",\"   \",\"hhh\",\"uuu\",&\n+       \"   \",\"   \",\"rrr\"], shape(f3)))) call abort\n+  if (size(empty) /=0) call abort\n+  if (any(t /= (0.0_8, 0.0_8))) call abort\n+end program main"}]}