{"sha": "c60f23e13ecbc5a5b07adb7557f1da094246cb2a", "node_id": "C_kwDOANBUbNoAKGM2MGYyM2UxM2VjYmM1YTViMDdhZGI3NTU3ZjFkYTA5NDI0NmNiMmE", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-12-03T01:04:15Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-06T17:11:36Z"}, "message": "[Ada] Avoid building malformed component constraints\n\ngcc/ada/\n\n\t* sem_util.adb (Build_Actual_Subtype_Of_Component): Define a new\n\tlocal function, Build_Discriminant_Reference, and call it in\n\teach of the three cases where Make_Selected_Component was\n\tpreviously being called to construct a discriminant reference (2\n\tin Build_Actual_Array_Constraint and 1 in\n\tBuild_Actual_Record_Constraint). Instead of unconditionally\n\tusing the passed-in object name as the prefix for the new\n\tselected component node, this new function checks to see if\n\tperhaps a prefix of that name should be used instead.", "tree": {"sha": "10d6e8ce5a0d148f989fb583ec246a3a7d7956ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10d6e8ce5a0d148f989fb583ec246a3a7d7956ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c60f23e13ecbc5a5b07adb7557f1da094246cb2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c60f23e13ecbc5a5b07adb7557f1da094246cb2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c60f23e13ecbc5a5b07adb7557f1da094246cb2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c60f23e13ecbc5a5b07adb7557f1da094246cb2a/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41a7b9484a39657deab7cac7092c2bf634a39365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41a7b9484a39657deab7cac7092c2bf634a39365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41a7b9484a39657deab7cac7092c2bf634a39365"}], "stats": {"total": 106, "additions": 92, "deletions": 14}, "files": [{"sha": "2bc3c95dbeb6584e8e4af4a974a9b29da2090977", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 92, "deletions": 14, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60f23e13ecbc5a5b07adb7557f1da094246cb2a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60f23e13ecbc5a5b07adb7557f1da094246cb2a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c60f23e13ecbc5a5b07adb7557f1da094246cb2a", "patch": "@@ -1970,6 +1970,12 @@ package body Sem_Util is\n       --  Similar to previous one, for discriminated components constrained\n       --  by the discriminant of the enclosing object.\n \n+      function Build_Discriminant_Reference\n+        (Discrim_Name : Node_Id; Obj : Node_Id := P) return Node_Id;\n+      --  Build a reference to the discriminant denoted by Discrim_Name.\n+      --  The prefix of the result is usually Obj, but it could be\n+      --  a prefix of Obj in some corner cases.\n+\n       function Copy_And_Maybe_Dereference (N : Node_Id) return Node_Id;\n       --  Copy the subtree rooted at N and insert an explicit dereference if it\n       --  is of an access type.\n@@ -1993,11 +1999,7 @@ package body Sem_Util is\n             Old_Hi := Type_High_Bound (Etype (Indx));\n \n             if Denotes_Discriminant (Old_Lo) then\n-               Lo :=\n-                 Make_Selected_Component (Loc,\n-                   Prefix => Copy_And_Maybe_Dereference (P),\n-                   Selector_Name => New_Occurrence_Of (Entity (Old_Lo), Loc));\n-\n+               Lo := Build_Discriminant_Reference (Old_Lo);\n             else\n                Lo := New_Copy_Tree (Old_Lo);\n \n@@ -2011,11 +2013,7 @@ package body Sem_Util is\n             end if;\n \n             if Denotes_Discriminant (Old_Hi) then\n-               Hi :=\n-                 Make_Selected_Component (Loc,\n-                   Prefix => Copy_And_Maybe_Dereference (P),\n-                   Selector_Name => New_Occurrence_Of (Entity (Old_Hi), Loc));\n-\n+               Hi := Build_Discriminant_Reference (Old_Hi);\n             else\n                Hi := New_Copy_Tree (Old_Hi);\n                Set_Analyzed (Hi, False);\n@@ -2041,10 +2039,7 @@ package body Sem_Util is\n          D := First_Elmt (Discriminant_Constraint (Desig_Typ));\n          while Present (D) loop\n             if Denotes_Discriminant (Node (D)) then\n-               D_Val := Make_Selected_Component (Loc,\n-                 Prefix => Copy_And_Maybe_Dereference (P),\n-                Selector_Name => New_Occurrence_Of (Entity (Node (D)), Loc));\n-\n+               D_Val := Build_Discriminant_Reference (Node (D));\n             else\n                D_Val := New_Copy_Tree (Node (D));\n             end if;\n@@ -2056,6 +2051,89 @@ package body Sem_Util is\n          return Constraints;\n       end Build_Actual_Record_Constraint;\n \n+      ----------------------------------\n+      -- Build_Discriminant_Reference --\n+      ----------------------------------\n+\n+      function Build_Discriminant_Reference\n+        (Discrim_Name : Node_Id; Obj : Node_Id := P) return Node_Id\n+      is\n+         Discrim : constant Entity_Id := Entity (Discrim_Name);\n+\n+         function Obj_Is_Good_Prefix return Boolean;\n+         --  Returns True if Obj.Discrim makes sense; that is, if\n+         --  Obj has Discrim as one of its discriminants (or is an\n+         --  access value that designates such an object).\n+\n+         ------------------------\n+         -- Obj_Is_Good_Prefix --\n+         ------------------------\n+\n+         function Obj_Is_Good_Prefix return Boolean is\n+            Obj_Type           : Entity_Id :=\n+              Implementation_Base_Type (Etype (Obj));\n+\n+            Discriminated_Type : constant Entity_Id :=\n+              Implementation_Base_Type\n+                (Scope (Original_Record_Component (Discrim)));\n+         begin\n+            --  The order of the following two tests matters in the\n+            --  access-to-class-wide case.\n+\n+            if Is_Access_Type (Obj_Type) then\n+               Obj_Type := Implementation_Base_Type\n+                             (Designated_Type (Obj_Type));\n+            end if;\n+\n+            if Is_Class_Wide_Type (Obj_Type) then\n+               Obj_Type := Implementation_Base_Type\n+                             (Find_Specific_Type (Obj_Type));\n+            end if;\n+\n+            --  If a type T1 defines a discriminant D1, then Obj.D1 is ok (for\n+            --  our purposes here) if T1 is an ancestor of the type of Obj.\n+            --  So that's what we would like to test for here.\n+            --  The bad news: Is_Ancestor is only defined in the tagged case.\n+            --  The good news: in the untagged case, Implementation_Base_Type\n+            --  looks through derived types so we can use a simpler test.\n+\n+            if Is_Tagged_Type (Discriminated_Type) then\n+               return Is_Ancestor (Discriminated_Type, Obj_Type);\n+            else\n+               return Discriminated_Type = Obj_Type;\n+            end if;\n+         end Obj_Is_Good_Prefix;\n+\n+      --  Start of processing for Build_Discriminant_Reference\n+\n+      begin\n+         if Obj_Is_Good_Prefix then\n+            return Make_Selected_Component (Loc,\n+                     Prefix => Copy_And_Maybe_Dereference (Obj),\n+                     Selector_Name => New_Occurrence_Of (Discrim, Loc));\n+         else\n+            --  If the given discriminant is not a component of the given\n+            --  object, then try the enclosing object.\n+\n+            if Nkind (Obj) = N_Selected_Component then\n+               return Build_Discriminant_Reference\n+                        (Discrim_Name => Discrim_Name,\n+                         Obj          => Prefix (Obj));\n+            elsif Nkind (Obj) in N_Has_Entity\n+              and then Nkind (Parent (Entity (Obj))) =\n+                       N_Object_Renaming_Declaration\n+            then\n+               --  Look through a renaming (a corner case of a corner case).\n+               return Build_Discriminant_Reference\n+                        (Discrim_Name => Discrim_Name,\n+                         Obj          => Name (Parent (Entity (Obj))));\n+            else\n+               pragma Assert (False);\n+               raise Program_Error;\n+            end if;\n+         end if;\n+      end Build_Discriminant_Reference;\n+\n       ------------------------------------\n       -- Build_Access_Record_Constraint --\n       ------------------------------------"}]}