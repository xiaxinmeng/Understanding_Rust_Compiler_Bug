{"sha": "faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "node_id": "C_kwDOANBUbNoAKGZhYWNhZmQyMzA2YWQ3ZWNlNzIxYTc5ZGVkYmI2ZTQ0ZTBkNjViZGI", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-12-08T00:22:47Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-18T23:20:57Z"}, "message": "analyzer: extend state-purging to locals [PR104943]\n\nThe existing analyzer code attempts to purge the state of SSA names\nwhere it can in order to minimize the size of program_state instances,\nand to increase the chances of being able to reuse exploded_node\ninstances whilst exploring the user's code.\n\nPR analyzer/104943 identifies that we fail to purge state of local\nvariables, based on behavior seen in PR analyzer/104954 when attempting\nto profile slow performance of -fanalyzer on a particular file in the\nLinux kernel, where that testcase has many temporary \"boxed\" values of\nstructs containing ints, which are never cleaned up, leading to bloat\nof the program_state instances (specifically, of the store objects).\n\nThis patch generalizes the state purging from just being on SSA names\nto also work on local variables.  Doing so requires that we detect where\naddresses to a local variable (or within them) are taken; we assume that\nonce a pointer has been taken, it's not longer safe to purge the value\nof that decl at any successor point within the function.\n\nDoing so speeds up the PR analyzer/104954 Linux kernel analyzer testcase\nfrom taking 254 seconds to \"just\" 186 seconds (and I have a followup\npatch in development that seems to further reduce this to 37 seconds).\n\nThe patch may also help with scaling up taint-detection so that it can\neventually be turned on by default, but we're not quite there (this\nis PR analyzer/103533).\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/104943\n\tPR analyzer/104954\n\tPR analyzer/103533\n\t* analyzer.h (class state_purge_per_decl): New forward decl.\n\t* engine.cc (impl_run_checkers): Pass region_model_manager to\n\tstate_purge_map ctor.\n\t* program-point.cc (function_point::final_stmt_p): New.\n\t(function_point::get_next): New.\n\t* program-point.h (function_point::final_stmt_p): New decl.\n\t(function_point::get_next): New decl.\n\t* program-state.cc (program_state::prune_for_point): Generalize to\n\tpurge local decls as well as SSA names.\n\t(program_state::can_purge_base_region_p): New.\n\t* program-state.h (program_state::can_purge_base_region_p): New\n\tdecl.\n\t* region-model.cc (struct append_ssa_names_cb_data): Rename to...\n\t(struct append_regions_cb_data): ...this.\n\t(region_model::get_ssa_name_regions_for_current_frame): Rename\n\tto...\n\t(region_model::get_regions_for_current_frame): ...this, updating\n\tfor other renamings.\n\t(region_model::append_ssa_names_cb): Rename to...\n\t(region_model::append_regions_cb): ...this, and drop the requirement\n\tthat the subregion be a SSA name.\n\t* region-model.h (struct append_ssa_names_cb_data): Rename decl\n\tto...\n\t(struct append_regions_cb_data): ...this.\n\t(region_model::get_ssa_name_regions_for_current_frame): Rename\n\tdecl to...\n\t(region_model::get_regions_for_current_frame): ...this.\n\t(region_model::append_ssa_names_cb): Rename decl to...\n\t(region_model::append_regions_cb): ...this.\n\t* state-purge.cc: Include \"tristate.h\", \"selftest.h\",\n\t\"analyzer/store.h\", \"analyzer/region-model.h\", and\n\t\"gimple-walk.h\".\n\t(get_candidate_for_purging): New.\n\t(class gimple_op_visitor): New.\n\t(my_load_cb): New.\n\t(my_store_cb): New.\n\t(my_addr_cb): New.\n\t(state_purge_map::state_purge_map): Add \"mgr\" param.  Update for\n\trenamings.  Find uses of local variables.\n\t(state_purge_map::~state_purge_map): Update for renaming of m_map\n\tto m_ssa_map.  Clean up m_decl_map.\n\t(state_purge_map::get_or_create_data_for_decl): New.\n\t(state_purge_per_ssa_name::state_purge_per_ssa_name): Update for\n\tinheriting from state_purge_per_tree.\n\t(state_purge_per_ssa_name::add_to_worklist): Likewise.\n\t(state_purge_per_decl::state_purge_per_decl): New.\n\t(state_purge_per_decl::add_needed_at): New.\n\t(state_purge_per_decl::add_pointed_to_at): New.\n\t(state_purge_per_decl::process_worklists): New.\n\t(state_purge_per_decl::add_to_worklist): New.\n\t(same_binding_p): New.\n\t(fully_overwrites_p): New.\n\t(state_purge_per_decl::process_point_backwards): New.\n\t(state_purge_per_decl::process_point_forwards): New.\n\t(state_purge_per_decl::needed_at_point_p): New.\n\t(state_purge_annotator::print_needed): Generalize to print local\n\tdecls as well as SSA names.\n\t* state-purge.h (class state_purge_map): Update leading comment.\n\t(state_purge_map::map_t): Rename to...\n\t(state_purge_map::ssa_map_t): ...this.\n\t(state_purge_map::iterator): Rename to...\n\t(state_purge_map::ssa_iterator): ...this.\n\t(state_purge_map::decl_map_t): New typedef.\n\t(state_purge_map::decl_iterator): New typedef.\n\t(state_purge_map::state_purge_map): Add \"mgr\" param.\n\t(state_purge_map::get_data_for_ssa_name): Update for renaming.\n\t(state_purge_map::get_any_data_for_decl): New.\n\t(state_purge_map::get_or_create_data_for_decl): New decl.\n\t(state_purge_map::begin): Rename to...\n\t(state_purge_map::begin_ssas): ...this.\n\t(state_purge_map::end): Rename to...\n\t(state_purge_map::end_ssa): ...this.\n\t(state_purge_map::begin_decls): New.\n\t(state_purge_map::end_decls): New.\n\t(state_purge_map::m_map): Rename to...\n\t(state_purge_map::m_ssa_map): ...this.\n\t(state_purge_map::m_decl_map): New field.\n\t(class state_purge_per_tree): New class.\n\t(class state_purge_per_ssa_name): Inherit from state_purge_per_tree.\n\t(state_purge_per_ssa_name::get_function): Move to base class.\n\t(state_purge_per_ssa_name::point_set_t): Likewise.\n\t(state_purge_per_ssa_name::m_fun): Likewise.\n\t(class state_purge_per_decl): New.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/104943\n\tPR analyzer/104954\n\tPR analyzer/103533\n\t* gcc.dg/analyzer/torture/boxed-ptr-1.c: Update expected number\n\tof exploded nodes to reflect improvements in state purging.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "1b8e681559ca7b6582988e89980aedb20c090ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b8e681559ca7b6582988e89980aedb20c090ad6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000"}], "stats": {"total": 935, "additions": 853, "deletions": 82}, "files": [{"sha": "a8289d0a0e0bad2eaf5679339ebbdb34cdcf2663", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -103,6 +103,7 @@ class exploded_path;\n class analysis_plan;\n class state_purge_map;\n class state_purge_per_ssa_name;\n+class state_purge_per_decl;\n class state_change;\n class rewind_info_t;\n "}, {"sha": "f911ed4ac392e7fc6e3fadb326b0731040792120", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -5728,7 +5728,7 @@ impl_run_checkers (logger *logger)\n   state_purge_map *purge_map = NULL;\n \n   if (flag_analyzer_state_purge)\n-    purge_map = new state_purge_map (sg, logger);\n+    purge_map = new state_purge_map (sg, eng.get_model_manager (), logger);\n \n   if (flag_dump_analyzer_supergraph)\n     {"}, {"sha": "61cea8a10768221d3c450765291b1d3820af1bf2", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -214,6 +214,17 @@ function_point::get_location () const\n     return UNKNOWN_LOCATION;\n }\n \n+/* Return true if this function_point is a before_stmt for\n+   the final stmt in its supernode.  */\n+\n+bool\n+function_point::final_stmt_p () const\n+{\n+  if (m_kind != PK_BEFORE_STMT)\n+    return false;\n+  return m_stmt_idx == get_supernode ()->m_stmts.length () - 1;\n+}\n+\n /* Create a function_point representing the entrypoint of function FUN.  */\n \n function_point\n@@ -625,6 +636,35 @@ function_point::next_stmt ()\n     }\n }\n \n+/* For those function points for which there is a uniquely-defined\n+   successor, return it.  */\n+\n+function_point\n+function_point::get_next () const\n+{\n+  switch (get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case PK_ORIGIN:\n+    case PK_AFTER_SUPERNODE:\n+      gcc_unreachable (); /* Not uniquely defined.  */\n+    case PK_BEFORE_SUPERNODE:\n+      if (get_supernode ()->m_stmts.length () > 0)\n+\treturn before_stmt (get_supernode (), 0);\n+      else\n+\treturn after_supernode (get_supernode ());\n+    case PK_BEFORE_STMT:\n+      {\n+\tunsigned next_idx = get_stmt_idx () + 1;\n+\tif (next_idx < get_supernode ()->m_stmts.length ())\n+\t  return before_stmt (get_supernode (), next_idx);\n+\telse\n+\t  return after_supernode (get_supernode ());\n+      }\n+    }\n+}\n+\n /* For those program points for which there is a uniquely-defined\n    successor, return it.  */\n "}, {"sha": "4b1c733d7106f62552e0387fbf62c02e06fa42d0", "filename": "gcc/analyzer/program-point.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -104,6 +104,8 @@ class function_point\n     return m_stmt_idx;\n   }\n \n+  bool final_stmt_p () const;\n+\n   /* Factory functions for making various kinds of program_point.  */\n \n   static function_point from_function_entry (const supergraph &sg,\n@@ -145,6 +147,8 @@ class function_point\n   /* For before_stmt, go to next stmt.  */\n   void next_stmt ();\n \n+  function_point get_next () const;\n+\n  private:\n   const supernode *m_supernode;\n "}, {"sha": "7ad581c7fbd83c30d8a2a31a340a51d81123f1a4", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 94, "deletions": 35, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -1122,52 +1122,90 @@ program_state::prune_for_point (exploded_graph &eg,\n   if (pm)\n     {\n       unsigned num_ssas_purged = 0;\n-      auto_vec<const decl_region *> ssa_name_regs;\n-      new_state.m_region_model->get_ssa_name_regions_for_current_frame\n-\t(&ssa_name_regs);\n-      ssa_name_regs.qsort (region::cmp_ptr_ptr);\n+      unsigned num_decls_purged = 0;\n+      auto_vec<const decl_region *> regs;\n+      new_state.m_region_model->get_regions_for_current_frame (&regs);\n+      regs.qsort (region::cmp_ptr_ptr);\n       unsigned i;\n       const decl_region *reg;\n-      FOR_EACH_VEC_ELT (ssa_name_regs, i, reg)\n+      FOR_EACH_VEC_ELT (regs, i, reg)\n \t{\n-\t  tree ssa_name = reg->get_decl ();\n-\t  const state_purge_per_ssa_name &per_ssa\n-\t    = pm->get_data_for_ssa_name (ssa_name);\n-\t  if (!per_ssa.needed_at_point_p (point.get_function_point ()))\n+\t  const tree node = reg->get_decl ();\n+\t  if (TREE_CODE (node) == SSA_NAME)\n \t    {\n-\t      /* Don't purge bindings of SSA names to svalues\n-\t\t that have unpurgable sm-state, so that leaks are\n-\t\t reported at the end of the function, rather than\n-\t\t at the last place that such an SSA name is referred to.\n-\n-\t\t But do purge them for temporaries (when SSA_NAME_VAR is\n-\t\t NULL), so that we report for cases where a leak happens when\n-\t\t a variable is overwritten with another value, so that the leak\n-\t\t is reported at the point of overwrite, rather than having\n-\t\t temporaries keep the value reachable until the frame is\n-\t\t popped.  */\n-\t      const svalue *sval\n-\t\t= new_state.m_region_model->get_store_value (reg, NULL);\n-\t      if (!new_state.can_purge_p (eg.get_ext_state (), sval)\n-\t\t  && SSA_NAME_VAR (ssa_name))\n+\t      const tree ssa_name = node;\n+\t      const state_purge_per_ssa_name &per_ssa\n+\t\t= pm->get_data_for_ssa_name (node);\n+\t      if (!per_ssa.needed_at_point_p (point.get_function_point ()))\n \t\t{\n-\t\t  /* (currently only state maps can keep things\n-\t\t     alive).  */\n-\t\t  if (logger)\n-\t\t    logger->log (\"not purging binding for %qE\"\n-\t\t\t\t \" (used by state map)\", ssa_name);\n-\t\t  continue;\n+\t\t  /* Don't purge bindings of SSA names to svalues\n+\t\t     that have unpurgable sm-state, so that leaks are\n+\t\t     reported at the end of the function, rather than\n+\t\t     at the last place that such an SSA name is referred to.\n+\n+\t\t     But do purge them for temporaries (when SSA_NAME_VAR is\n+\t\t     NULL), so that we report for cases where a leak happens when\n+\t\t     a variable is overwritten with another value, so that the leak\n+\t\t     is reported at the point of overwrite, rather than having\n+\t\t     temporaries keep the value reachable until the frame is\n+\t\t     popped.  */\n+\t\t  const svalue *sval\n+\t\t    = new_state.m_region_model->get_store_value (reg, NULL);\n+\t\t  if (!new_state.can_purge_p (eg.get_ext_state (), sval)\n+\t\t      && SSA_NAME_VAR (ssa_name))\n+\t\t    {\n+\t\t      /* (currently only state maps can keep things\n+\t\t\t alive).  */\n+\t\t      if (logger)\n+\t\t\tlogger->log (\"not purging binding for %qE\"\n+\t\t\t\t     \" (used by state map)\", ssa_name);\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  new_state.m_region_model->purge_region (reg);\n+\t\t  num_ssas_purged++;\n \t\t}\n-\n-\t      new_state.m_region_model->purge_region (reg);\n-\t      num_ssas_purged++;\n+\t    }\n+\t  else\n+\t    {\n+\t      const tree decl = node;\n+\t      gcc_assert (TREE_CODE (node) == VAR_DECL\n+\t\t\t  || TREE_CODE (node) == PARM_DECL\n+\t\t\t  || TREE_CODE (node) == RESULT_DECL);\n+\t      if (const state_purge_per_decl *per_decl\n+\t\t  = pm->get_any_data_for_decl (decl))\n+\t\tif (!per_decl->needed_at_point_p (point.get_function_point ()))\n+\t\t  {\n+\t\t    /* Don't purge bindings of decls if there are svalues\n+\t\t       that have unpurgable sm-state within the decl's cluster,\n+\t\t       so that leaks are reported at the end of the function,\n+\t\t       rather than at the last place that such a decl is\n+\t\t       referred to.  */\n+\t\t    if (!new_state.can_purge_base_region_p (eg.get_ext_state (),\n+\t\t\t\t\t\t\t    reg))\n+\t\t      {\n+\t\t\t/* (currently only state maps can keep things\n+\t\t\t   alive).  */\n+\t\t\tif (logger)\n+\t\t\t  logger->log (\"not purging binding for %qE\"\n+\t\t\t\t       \" (value in binding used by state map)\",\n+\t\t\t\t       decl);\n+\t\t\tcontinue;\n+\t\t      }\n+\n+\t\t    new_state.m_region_model->purge_region (reg);\n+\t\t    num_decls_purged++;\n+\t\t  }\n \t    }\n \t}\n \n-      if (num_ssas_purged > 0)\n+      if (num_ssas_purged > 0 || num_decls_purged > 0)\n \t{\n \t  if (logger)\n-\t    logger->log (\"num_ssas_purged: %i\", num_ssas_purged);\n+\t    {\n+\t      logger->log (\"num_ssas_purged: %i\", num_ssas_purged);\n+\t      logger->log (\"num_decl_purged: %i\", num_decls_purged);\n+\t    }\n \t  impl_region_model_context ctxt (eg, enode_for_diag,\n \t\t\t\t\t  this,\n \t\t\t\t\t  &new_state,\n@@ -1182,6 +1220,27 @@ program_state::prune_for_point (exploded_graph &eg,\n   return new_state;\n }\n \n+/* Return true if there are no unpurgeable bindings within BASE_REG. */\n+\n+bool\n+program_state::can_purge_base_region_p (const extrinsic_state &ext_state,\n+\t\t\t\t\tconst region *base_reg) const\n+{\n+  binding_cluster *cluster\n+    = m_region_model->get_store ()->get_cluster (base_reg);\n+  if (!cluster)\n+    return true;\n+\n+  for (auto iter : *cluster)\n+    {\n+      const svalue *sval = iter.second;\n+      if (!can_purge_p (ext_state, sval))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Get a representative tree to use for describing SVAL.  */\n \n tree"}, {"sha": "baab7874c261b88bbc361158438e699acd0bb14e", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -257,6 +257,9 @@ class program_state\n     return true;\n   }\n \n+  bool can_purge_base_region_p (const extrinsic_state &ext_state,\n+\t\t\t\tconst region *base_reg) const;\n+\n   bool can_merge_with_p (const program_state &other,\n \t\t\t const extrinsic_state &ext_state,\n \t\t\t const program_point &point,"}, {"sha": "29d3122edb3bc007f84f708990aac6986da00686", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -4148,39 +4148,35 @@ region_model::get_fndecl_for_call (const gcall *call,\n \n /* Would be much simpler to use a lambda here, if it were supported.  */\n \n-struct append_ssa_names_cb_data\n+struct append_regions_cb_data\n {\n   const region_model *model;\n   auto_vec<const decl_region *> *out;\n };\n \n-/* Populate *OUT with all decl_regions for SSA names in the current\n+/* Populate *OUT with all decl_regions in the current\n    frame that have clusters within the store.  */\n \n void\n region_model::\n-get_ssa_name_regions_for_current_frame (auto_vec<const decl_region *> *out)\n-  const\n+get_regions_for_current_frame (auto_vec<const decl_region *> *out) const\n {\n-  append_ssa_names_cb_data data;\n+  append_regions_cb_data data;\n   data.model = this;\n   data.out = out;\n-  m_store.for_each_cluster (append_ssa_names_cb, &data);\n+  m_store.for_each_cluster (append_regions_cb, &data);\n }\n \n-/* Implementation detail of get_ssa_name_regions_for_current_frame.  */\n+/* Implementation detail of get_regions_for_current_frame.  */\n \n void\n-region_model::append_ssa_names_cb (const region *base_reg,\n-\t\t\t\t   append_ssa_names_cb_data *cb_data)\n+region_model::append_regions_cb (const region *base_reg,\n+\t\t\t\t append_regions_cb_data *cb_data)\n {\n   if (base_reg->get_parent_region () != cb_data->model->m_current_frame)\n     return;\n   if (const decl_region *decl_reg = base_reg->dyn_cast_decl_region ())\n-    {\n-      if (TREE_CODE (decl_reg->get_decl ()) == SSA_NAME)\n-\tcb_data->out->safe_push (decl_reg);\n-    }\n+    cb_data->out->safe_push (decl_reg);\n }\n \n /* Return a new region describing a heap-allocated block of memory."}, {"sha": "8d92d7c97a323d1f58a7198501a3fa63ab08c117", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -494,7 +494,7 @@ class region_model_manager\n   auto_delete_vec<region> m_managed_dynamic_regions;\n };\n \n-struct append_ssa_names_cb_data;\n+struct append_regions_cb_data;\n \n /* Helper class for handling calls to functions with known behavior.\n    Implemented in region-model-impl-calls.c.  */\n@@ -756,10 +756,9 @@ class region_model\n   tree get_fndecl_for_call (const gcall *call,\n \t\t\t    region_model_context *ctxt);\n \n-  void get_ssa_name_regions_for_current_frame\n-    (auto_vec<const decl_region *> *out) const;\n-  static void append_ssa_names_cb (const region *base_reg,\n-\t\t\t\t   struct append_ssa_names_cb_data *data);\n+  void get_regions_for_current_frame (auto_vec<const decl_region *> *out) const;\n+  static void append_regions_cb (const region *base_reg,\n+\t\t\t\t struct append_regions_cb_data *data);\n \n   const svalue *get_store_value (const region *reg,\n \t\t\t\t region_model_context *ctxt) const;"}, {"sha": "7a061a194808d4b3d18ef64e48b15f632c3c355a", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 598, "deletions": 9, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -49,13 +49,165 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/state-purge.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"gimple-walk.h\"\n \n #if ENABLE_ANALYZER\n \n+/* Given NODE at an access, determine if this access is within\n+   a decl that could be consider for purging, and if so, return the decl.  */\n+\n+static tree\n+get_candidate_for_purging (tree node)\n+{\n+  tree iter = node;\n+  while (1)\n+    switch (TREE_CODE (iter))\n+      {\n+      default:\n+\treturn NULL_TREE;\n+\n+      case COMPONENT_REF:\n+\titer = TREE_OPERAND (iter, 0);\n+\tcontinue;\n+\n+      case VAR_DECL:\n+\tif (is_global_var (iter))\n+\t  return NULL_TREE;\n+\telse\n+\t  return iter;\n+\n+      case PARM_DECL:\n+      case RESULT_DECL:\n+\treturn iter;\n+      }\n+}\n+\n+/* Class-based handler for walk_stmt_load_store_addr_ops at a particular\n+   function_point, for populating the worklists within a state_purge_map.  */\n+\n+class gimple_op_visitor : public log_user\n+{\n+public:\n+  gimple_op_visitor (state_purge_map *map,\n+\t\t     const function_point &point,\n+\t\t     function *fun)\n+  : log_user (map->get_logger ()),\n+    m_map (map),\n+    m_point (point),\n+    m_fun (fun)\n+  {}\n+\n+  bool on_load (gimple *stmt, tree base, tree op)\n+  {\n+    LOG_FUNC (get_logger ());\n+    if (get_logger ())\n+      {\n+\tpretty_printer pp;\n+\tpp_gimple_stmt_1 (&pp, stmt, 0, (dump_flags_t)0);\n+\tlog (\"on_load: %s; base: %qE, op: %qE\",\n+\t     pp_formatted_text (&pp), base, op);\n+      }\n+    if (tree node = get_candidate_for_purging (base))\n+      add_needed (node);\n+    return true;\n+  }\n+\n+  bool on_store (gimple *stmt, tree base, tree op)\n+  {\n+    LOG_FUNC (get_logger ());\n+    if (get_logger ())\n+      {\n+\tpretty_printer pp;\n+\tpp_gimple_stmt_1 (&pp, stmt, 0, (dump_flags_t)0);\n+\tlog (\"on_store: %s; base: %qE, op: %qE\",\n+\t     pp_formatted_text (&pp), base, op);\n+      }\n+    return true;\n+  }\n+\n+  bool on_addr (gimple *stmt, tree base, tree op)\n+  {\n+    LOG_FUNC (get_logger ());\n+    if (get_logger ())\n+      {\n+\tpretty_printer pp;\n+\tpp_gimple_stmt_1 (&pp, stmt, 0, (dump_flags_t)0);\n+\tlog (\"on_addr: %s; base: %qE, op: %qE\",\n+\t     pp_formatted_text (&pp), base, op);\n+      }\n+    if (TREE_CODE (op) != ADDR_EXPR)\n+      return true;\n+    if (tree node = get_candidate_for_purging (base))\n+      {\n+\tadd_needed (node);\n+\tadd_pointed_to (node);\n+      }\n+    return true;\n+  }\n+\n+private:\n+  void add_needed (tree decl)\n+  {\n+    gcc_assert (get_candidate_for_purging (decl) == decl);\n+    state_purge_per_decl &data\n+      = get_or_create_data_for_decl (decl);\n+    data.add_needed_at (m_point);\n+\n+    /* Handle calls: if we're seeing a use at a call, then add a use at the\n+       \"after-supernode\" point (in case of interprocedural call superedges).  */\n+    if (m_point.final_stmt_p ())\n+      data.add_needed_at (m_point.get_next ());\n+  }\n+\n+  void add_pointed_to (tree decl)\n+  {\n+    gcc_assert (get_candidate_for_purging (decl) == decl);\n+    get_or_create_data_for_decl (decl).add_pointed_to_at (m_point);\n+  }\n+\n+  state_purge_per_decl &\n+  get_or_create_data_for_decl (tree decl)\n+  {\n+    return m_map->get_or_create_data_for_decl (m_fun, decl);\n+  }\n+\n+  state_purge_map *m_map;\n+  const function_point &m_point;\n+  function *m_fun;\n+};\n+\n+static bool\n+my_load_cb  (gimple *stmt, tree base, tree op, void *user_data)\n+{\n+  gimple_op_visitor *x = (gimple_op_visitor *)user_data;\n+  return x->on_load (stmt, base, op);\n+}\n+\n+static bool\n+my_store_cb  (gimple *stmt, tree base, tree op, void *user_data)\n+{\n+  gimple_op_visitor *x = (gimple_op_visitor *)user_data;\n+  return x->on_store (stmt, base, op);\n+}\n+\n+static bool\n+my_addr_cb  (gimple *stmt, tree base, tree op, void *user_data)\n+{\n+  gimple_op_visitor *x = (gimple_op_visitor *)user_data;\n+  return x->on_addr (stmt, base, op);\n+}\n+\n /* state_purge_map's ctor.  Walk all SSA names in all functions, building\n-   a state_purge_per_ssa_name instance for each.  */\n+   a state_purge_per_ssa_name instance for each.\n+   Also, walk all loads and address-taken ops of local variables, building\n+   a state_purge_per_decl as appropriate.  */\n \n state_purge_map::state_purge_map (const supergraph &sg,\n+\t\t\t\t  region_model_manager *mgr,\n \t\t\t\t  logger *logger)\n : log_user (logger), m_sg (sg)\n {\n@@ -78,19 +230,65 @@ state_purge_map::state_purge_map (const supergraph &sg,\n \t  if (TREE_CODE (var) == VAR_DECL)\n \t    if (VAR_DECL_IS_VIRTUAL_OPERAND (var))\n \t      continue;\n-\tm_map.put (name, new state_purge_per_ssa_name (*this, name, fun));\n+\tm_ssa_map.put (name, new state_purge_per_ssa_name (*this, name, fun));\n       }\n   }\n+\n+  /* Find all uses of local vars.\n+     We iterate through all function points, finding loads, stores, and\n+     address-taken operations on locals, building a pair of worklists.  */\n+  for (auto snode : sg.m_nodes)\n+    {\n+      if (logger)\n+\tlog (\"SN: %i\", snode->m_index);\n+      /* We ignore m_returning_call and phi nodes.  */\n+      gimple *stmt;\n+      unsigned i;\n+      FOR_EACH_VEC_ELT (snode->m_stmts, i, stmt)\n+\t{\n+\t  function_point point (function_point::before_stmt (snode, i));\n+\t  gimple_op_visitor v (this, point, snode->get_function ());\n+\t  walk_stmt_load_store_addr_ops (stmt, &v,\n+\t\t\t\t\t my_load_cb, my_store_cb, my_addr_cb);\n+\t}\n+    }\n+\n+  /* Now iterate through the m_decl_map, processing each pair of worklists.  */\n+  for (state_purge_map::decl_iterator iter = begin_decls ();\n+       iter != end_decls ();\n+       ++iter)\n+    {\n+      state_purge_per_decl *per_decl_data = (*iter).second;\n+      per_decl_data->process_worklists (*this, mgr);\n+    }\n }\n \n /* state_purge_map's dtor.  */\n \n state_purge_map::~state_purge_map ()\n {\n-  for (iterator iter = m_map.begin (); iter != m_map.end (); ++iter)\n-    delete (*iter).second;\n+  for (auto iter : m_ssa_map)\n+    delete iter.second;\n+  for (auto iter : m_decl_map)\n+    delete iter.second;\n }\n \n+/* Get the state_purge_per_decl for local DECL within FUN, creating it\n+   if necessary.  */\n+\n+state_purge_per_decl &\n+state_purge_map::get_or_create_data_for_decl (function *fun, tree decl)\n+{\n+  if (state_purge_per_decl **slot\n+      = const_cast <decl_map_t&> (m_decl_map).get (decl))\n+    return **slot;\n+  state_purge_per_decl *result = new state_purge_per_decl (*this, decl, fun);\n+  m_decl_map.put (decl, result);\n+  return *result;\n+}\n+\n+/* class state_purge_per_ssa_name : public state_purge_per_tree.  */\n+\n /* state_purge_per_ssa_name's ctor.\n \n    Locate all uses of VAR within FUN.\n@@ -103,7 +301,7 @@ state_purge_map::~state_purge_map ()\n state_purge_per_ssa_name::state_purge_per_ssa_name (const state_purge_map &map,\n \t\t\t\t\t\t    tree name,\n \t\t\t\t\t\t    function *fun)\n-: m_points_needing_name (), m_name (name), m_fun (fun)\n+: state_purge_per_tree (fun), m_points_needing_name (), m_name (name)\n {\n   LOG_FUNC (map.get_logger ());\n \n@@ -270,7 +468,7 @@ state_purge_per_ssa_name::add_to_worklist (const function_point &point,\n       logger->end_log_line ();\n     }\n \n-  gcc_assert (point.get_function () == m_fun);\n+  gcc_assert (point.get_function () == get_function ());\n   if (point.get_from_edge ())\n     gcc_assert (point.get_from_edge ()->get_kind () == SUPEREDGE_CFG_EDGE);\n \n@@ -470,6 +668,382 @@ state_purge_per_ssa_name::process_point (const function_point &point,\n     }\n }\n \n+/* class state_purge_per_decl : public state_purge_per_tree.  */\n+\n+/* state_purge_per_decl's ctor.  */\n+\n+state_purge_per_decl::state_purge_per_decl (const state_purge_map &map,\n+\t\t\t\t\t    tree decl,\n+\t\t\t\t\t    function *fun)\n+: state_purge_per_tree (fun),\n+  m_decl (decl)\n+{\n+  /* The RESULT_DECL is always needed at the end of its function. */\n+  if (TREE_CODE (decl) == RESULT_DECL)\n+    {\n+      supernode *exit_snode = map.get_sg ().get_node_for_function_exit (fun);\n+      add_needed_at (function_point::after_supernode (exit_snode));\n+    }\n+}\n+\n+/* Mark the value of the decl (or a subvalue within it) as being needed\n+   at POINT.  */\n+\n+void\n+state_purge_per_decl::add_needed_at (const function_point &point)\n+{\n+  m_points_needing_decl.add (point);\n+}\n+\n+/* Mark that a pointer to the decl (or a region within it) is taken\n+   at POINT.  */\n+\n+void\n+state_purge_per_decl::add_pointed_to_at (const function_point &point)\n+{\n+  m_points_taking_address.add (point);\n+}\n+\n+/* Process the worklists for this decl:\n+   (a) walk backwards from points where we know the value of the decl\n+   is needed, marking points until we get to a stmt that fully overwrites\n+   the decl.\n+   (b) walk forwards from points where the address of the decl is taken,\n+   marking points as potentially needing the value of the decl.  */\n+\n+void\n+state_purge_per_decl::process_worklists (const state_purge_map &map,\n+\t\t\t\t\t region_model_manager *mgr)\n+{\n+  logger *logger = map.get_logger ();\n+  LOG_SCOPE (logger);\n+  if (logger)\n+    logger->log (\"decl: %qE within %qD\", m_decl, get_fndecl ());\n+\n+  /* Worklist for walking backwards from uses.  */\n+  {\n+    auto_vec<function_point> worklist;\n+    point_set_t seen;\n+\n+    /* Add all uses of the decl to the worklist.  */\n+    for (auto iter : m_points_needing_decl)\n+      worklist.safe_push (iter);\n+\n+    region_model model (mgr);\n+    model.push_frame (get_function (), NULL, NULL);\n+\n+    /* Process worklist by walking backwards until we reach a stmt\n+       that fully overwrites the decl.  */\n+    {\n+      log_scope s (logger, \"processing worklist\");\n+      while (worklist.length () > 0)\n+\t{\n+\t  function_point point = worklist.pop ();\n+\t  process_point_backwards (point, &worklist, &seen, map, model);\n+\t}\n+    }\n+  }\n+\n+  /* Worklist for walking forwards from address-taken points.  */\n+  {\n+    auto_vec<function_point> worklist;\n+    point_set_t seen;\n+\n+    /* Add all uses of the decl to the worklist.  */\n+    for (auto iter : m_points_taking_address)\n+      {\n+\tworklist.safe_push (iter);\n+\n+\t/* Add to m_points_needing_decl (now that we traversed\n+\t   it above for the backward worklist).  */\n+\tm_points_needing_decl.add (iter);\n+      }\n+\n+    /* Process worklist by walking forwards. */\n+    {\n+      log_scope s (logger, \"processing worklist\");\n+      while (worklist.length () > 0)\n+\t{\n+\t  function_point point = worklist.pop ();\n+\t  process_point_forwards (point, &worklist, &seen, map);\n+\t}\n+    }\n+  }\n+}\n+\n+/* Add POINT to *WORKLIST if the point is not already in *seen.\n+   Add newly seen points to *SEEN and to m_points_needing_name.  */\n+\n+void\n+state_purge_per_decl::add_to_worklist (const function_point &point,\n+\t\t\t\t       auto_vec<function_point> *worklist,\n+\t\t\t\t       point_set_t *seen,\n+\t\t\t\t       logger *logger)\n+{\n+  LOG_FUNC (logger);\n+  if (logger)\n+    {\n+      logger->start_log_line ();\n+      logger->log_partial (\"point: '\");\n+      point.print (logger->get_printer (), format (false));\n+      logger->log_partial (\"' for worklist for %qE\", m_decl);\n+      logger->end_log_line ();\n+    }\n+\n+  gcc_assert (point.get_function () == get_function ());\n+  if (point.get_from_edge ())\n+    gcc_assert (point.get_from_edge ()->get_kind () == SUPEREDGE_CFG_EDGE);\n+\n+  if (seen->contains (point))\n+    {\n+      if (logger)\n+\tlogger->log (\"already seen for %qE\", m_decl);\n+    }\n+  else\n+    {\n+      if (logger)\n+\tlogger->log (\"not seen; adding to worklist for %qE\", m_decl);\n+      m_points_needing_decl.add (point);\n+      seen->add (point);\n+      worklist->safe_push (point);\n+    }\n+}\n+\n+/* Determine if REG_A and REG_B express writing to exactly the same\n+   set of bits.\n+   For example, when \"s.field\" is the only field of \"s\", and there's no\n+   padding, this should return true.  */\n+\n+static bool\n+same_binding_p (const region *reg_a, const region *reg_b,\n+\t\tstore_manager *store_mgr)\n+{\n+  if (reg_a->get_base_region () != reg_b->get_base_region ())\n+    return false;\n+  const binding_key *bind_key_a = binding_key::make (store_mgr, reg_a);\n+  const binding_key *bind_key_b = binding_key::make (store_mgr, reg_b);\n+  return bind_key_a == bind_key_b;\n+}\n+\n+/* Return true if STMT fully overwrites DECL.  */\n+\n+static bool\n+fully_overwrites_p (const gimple *stmt, tree decl,\n+\t\t    const region_model &model)\n+{\n+  if (tree lhs = gimple_get_lhs (stmt))\n+    {\n+      /* Determine if LHS fully overwrites DECL.\n+\t We can't just check for equality; consider the case of\n+\t \"s.field = EXPR;\" where the stmt writes to the only field\n+\t of \"s\", and there's no padding.  */\n+      const region *lhs_reg = model.get_lvalue (lhs, NULL);\n+      const region *decl_reg = model.get_lvalue (decl, NULL);\n+      if (same_binding_p (lhs_reg, decl_reg,\n+\t\t\t  model.get_manager ()->get_store_manager ()))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Process POINT, popped from *WORKLIST.\n+   Iterate over predecessors of POINT, adding to *WORKLIST and *SEEN,\n+   until we get to a stmt that fully overwrites the decl.  */\n+\n+void\n+state_purge_per_decl::\n+process_point_backwards (const function_point &point,\n+\t\t\t auto_vec<function_point> *worklist,\n+\t\t\t point_set_t *seen,\n+\t\t\t const state_purge_map &map,\n+\t\t\t const region_model &model)\n+{\n+  logger *logger = map.get_logger ();\n+  LOG_FUNC (logger);\n+  if (logger)\n+    {\n+      logger->start_log_line ();\n+      logger->log_partial (\"considering point: '\");\n+      point.print (logger->get_printer (), format (false));\n+      logger->log_partial (\"' for %qE\", m_decl);\n+      logger->end_log_line ();\n+    }\n+  const supernode *snode = point.get_supernode ();\n+\n+  switch (point.get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+\n+    case PK_ORIGIN:\n+      break;\n+\n+    case PK_BEFORE_SUPERNODE:\n+      {\n+\t/* Add given pred to worklist.  */\n+\tif (point.get_from_edge ())\n+\t  {\n+\t    gcc_assert (point.get_from_edge ()->m_src);\n+\t    add_to_worklist\n+\t      (function_point::after_supernode (point.get_from_edge ()->m_src),\n+\t       worklist, seen, logger);\n+\t  }\n+\telse\n+\t  {\n+\t    /* Add any intraprocedually edge for a call.  */\n+\t    if (snode->m_returning_call)\n+\t    {\n+\t      gcall *returning_call = snode->m_returning_call;\n+\t      cgraph_edge *cedge\n+\t\t  = supergraph_call_edge (snode->m_fun,\n+\t\t\t\t\t  returning_call);\n+\t      if(cedge)\n+\t\t{\n+\t\t  superedge *sedge\n+\t\t    = map.get_sg ().get_intraprocedural_edge_for_call (cedge);\n+\t\t  gcc_assert (sedge);\n+\t\t  add_to_worklist\n+\t\t    (function_point::after_supernode (sedge->m_src),\n+\t\t     worklist, seen, logger);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  supernode *callernode\n+\t\t    = map.get_sg ().get_supernode_for_stmt (returning_call);\n+\n+\t\t  gcc_assert (callernode);\n+\t\t  add_to_worklist\n+\t\t    (function_point::after_supernode (callernode),\n+\t\t     worklist, seen, logger);\n+\t\t}\n+\t    }\n+\t  }\n+      }\n+      break;\n+\n+    case PK_BEFORE_STMT:\n+      {\n+\t/* This is somewhat equivalent to how the SSA case handles\n+\t   def-stmts.  */\n+\tif (fully_overwrites_p (point.get_stmt (), m_decl, model))\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"stmt fully overwrites %qE; terminating\", m_decl);\n+\t    return;\n+\t  }\n+\tif (point.get_stmt_idx () > 0)\n+\t  add_to_worklist (function_point::before_stmt\n+\t\t\t     (snode, point.get_stmt_idx () - 1),\n+\t\t\t   worklist, seen, logger);\n+\telse\n+\t{\n+\t  /* Add before_supernode to worklist.  This captures the in-edge,\n+\t     so we have to do it once per in-edge.  */\n+\t  unsigned i;\n+\t  superedge *pred;\n+\t  FOR_EACH_VEC_ELT (snode->m_preds, i, pred)\n+\t    add_to_worklist (function_point::before_supernode (snode,\n+\t\t\t\t\t\t\t       pred),\n+\t\t\t     worklist, seen, logger);\n+\t}\n+      }\n+      break;\n+\n+    case PK_AFTER_SUPERNODE:\n+      {\n+\tif (snode->m_stmts.length ())\n+\t  add_to_worklist\n+\t    (function_point::before_stmt (snode,\n+\t\t\t\t\t  snode->m_stmts.length () - 1),\n+\t     worklist, seen, logger);\n+\telse\n+\t  {\n+\t    /* Add before_supernode to worklist.  This captures the in-edge,\n+\t       so we have to do it once per in-edge.  */\n+\t    unsigned i;\n+\t    superedge *pred;\n+\t    FOR_EACH_VEC_ELT (snode->m_preds, i, pred)\n+\t      add_to_worklist (function_point::before_supernode (snode,\n+\t\t\t\t\t\t\t\t pred),\n+\t\t\t       worklist, seen, logger);\n+\t  }\n+      }\n+      break;\n+    }\n+\n+}\n+\n+/* Process POINT, popped from *WORKLIST.\n+   Iterate over successors of POINT, adding to *WORKLIST and *SEEN.  */\n+\n+void\n+state_purge_per_decl::\n+process_point_forwards (const function_point &point,\n+\t\t\tauto_vec<function_point> *worklist,\n+\t\t\tpoint_set_t *seen,\n+\t\t\tconst state_purge_map &map)\n+{\n+  logger *logger = map.get_logger ();\n+  LOG_FUNC (logger);\n+  if (logger)\n+    {\n+      logger->start_log_line ();\n+      logger->log_partial (\"considering point: '\");\n+      point.print (logger->get_printer (), format (false));\n+      logger->log_partial (\"' for %qE\", m_decl);\n+      logger->end_log_line ();\n+    }\n+  const supernode *snode = point.get_supernode ();\n+\n+  switch (point.get_kind ())\n+    {\n+    default:\n+    case PK_ORIGIN:\n+      gcc_unreachable ();\n+\n+    case PK_BEFORE_SUPERNODE:\n+      {\n+\tfunction_point next = point.get_next ();\n+\tadd_to_worklist (next, worklist, seen, logger);\n+      }\n+      break;\n+\n+    case PK_BEFORE_STMT:\n+      {\n+\t/* Perhaps we should stop at a clobber of the decl,\n+\t   but that ought to purge state for us explicitly.  */\n+\tfunction_point next = point.get_next ();\n+\tadd_to_worklist (next, worklist, seen, logger);\n+      }\n+      break;\n+\n+    case PK_AFTER_SUPERNODE:\n+      {\n+\t/* Look at interprocedural out-edges.  */\n+\tunsigned i;\n+\tsuperedge *succ;\n+\tFOR_EACH_VEC_ELT (snode->m_succs, i, succ)\n+\t  {\n+\t    enum edge_kind kind = succ->get_kind ();\n+\t    if (kind == SUPEREDGE_CFG_EDGE\n+\t\t|| kind == SUPEREDGE_INTRAPROCEDURAL_CALL)\n+\t      add_to_worklist (function_point::before_supernode (succ->m_dest,\n+\t\t\t\t\t\t\t\t succ),\n+\t\t\t       worklist, seen, logger);\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+/* Return true if the decl is needed at POINT.  */\n+\n+bool\n+state_purge_per_decl::needed_at_point_p (const function_point &point) const\n+{\n+  return const_cast <point_set_t &> (m_points_needing_decl).contains (point);\n+}\n+\n /* class state_purge_annotator : public dot_annotator.  */\n \n /* Implementation of dot_annotator::add_node_annotations vfunc for\n@@ -580,7 +1154,8 @@ state_purge_annotator::add_stmt_annotations (graphviz_out *gv,\n   print_needed (gv, before_stmt, true);\n }\n \n-/* Get the ssa names needed and not-needed at POINT, and print them to GV.\n+/* Get the decls and SSA names needed and not-needed at POINT, and\n+   print them to GV.\n    If WITHIN_TABLE is true, print them within <TR> elements.  */\n \n void\n@@ -590,8 +1165,8 @@ state_purge_annotator::print_needed (graphviz_out *gv,\n {\n   auto_vec<tree> needed;\n   auto_vec<tree> not_needed;\n-  for (state_purge_map::iterator iter = m_map->begin ();\n-       iter != m_map->end ();\n+  for (state_purge_map::ssa_iterator iter = m_map->begin_ssas ();\n+       iter != m_map->end_ssas ();\n        ++iter)\n     {\n       tree name = (*iter).first;\n@@ -604,6 +1179,20 @@ state_purge_annotator::print_needed (graphviz_out *gv,\n \t    not_needed.safe_push (name);\n \t}\n     }\n+  for (state_purge_map::decl_iterator iter = m_map->begin_decls ();\n+       iter != m_map->end_decls ();\n+       ++iter)\n+    {\n+      tree decl = (*iter).first;\n+      state_purge_per_decl *per_decl_data = (*iter).second;\n+      if (per_decl_data->get_function () == point.get_function ())\n+\t{\n+\t  if (per_decl_data->needed_at_point_p (point))\n+\t    needed.safe_push (decl);\n+\t  else\n+\t    not_needed.safe_push (decl);\n+\t}\n+    }\n \n   print_vec_of_names (gv, \"needed here\", needed, within_table);\n   print_vec_of_names (gv, \"not needed here\", not_needed, within_table);"}, {"sha": "3c51b481239935f77bd54362fb3d5ced8a354d5d", "filename": "gcc/analyzer/state-purge.h", "status": "modified", "additions": 97, "deletions": 13, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fstate-purge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Fanalyzer%2Fstate-purge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.h?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -70,17 +70,22 @@ pod_hash_traits<function_point>::is_empty (value_type v)\n \n namespace ana {\n \n-/* The result of analyzing which SSA names can be purged from state at\n+/* The result of analyzing which decls and SSA names can be purged from state at\n    different points in the program, so that we can simplify program_state\n    objects, in the hope of reducing state-blowup.  */\n \n class state_purge_map : public log_user\n {\n public:\n-  typedef ordered_hash_map<tree, state_purge_per_ssa_name *> map_t;\n-  typedef map_t::iterator iterator;\n+  typedef ordered_hash_map<tree, state_purge_per_ssa_name *> ssa_map_t;\n+  typedef ssa_map_t::iterator ssa_iterator;\n \n-  state_purge_map (const supergraph &sg, logger *logger);\n+  typedef ordered_hash_map<tree, state_purge_per_decl *> decl_map_t;\n+  typedef decl_map_t::iterator decl_iterator;\n+\n+  state_purge_map (const supergraph &sg,\n+\t\t   region_model_manager *mgr,\n+\t\t   logger *logger);\n   ~state_purge_map ();\n \n   const state_purge_per_ssa_name &get_data_for_ssa_name (tree name) const\n@@ -91,20 +96,58 @@ class state_purge_map : public log_user\n \tgcc_assert (!VAR_DECL_IS_VIRTUAL_OPERAND (var));\n \n     state_purge_per_ssa_name **slot\n-      = const_cast <map_t&> (m_map).get (name);\n+      = const_cast <ssa_map_t&> (m_ssa_map).get (name);\n     return **slot;\n   }\n \n+  const state_purge_per_decl *get_any_data_for_decl (tree decl) const\n+  {\n+    gcc_assert (TREE_CODE (decl) == VAR_DECL\n+\t\t|| TREE_CODE (decl) == PARM_DECL\n+\t\t|| TREE_CODE (decl) == RESULT_DECL);\n+    if (state_purge_per_decl **slot\n+\t= const_cast <decl_map_t&> (m_decl_map).get (decl))\n+      return *slot;\n+    else\n+      return NULL;\n+  }\n+\n+  state_purge_per_decl &get_or_create_data_for_decl (function *fun, tree decl);\n+\n   const supergraph &get_sg () const { return m_sg; }\n \n-  iterator begin () const { return m_map.begin (); }\n-  iterator end () const { return m_map.end (); }\n+  ssa_iterator begin_ssas () const { return m_ssa_map.begin (); }\n+  ssa_iterator end_ssas () const { return m_ssa_map.end (); }\n+\n+  decl_iterator begin_decls () const { return m_decl_map.begin (); }\n+  decl_iterator end_decls () const { return m_decl_map.end (); }\n \n private:\n   DISABLE_COPY_AND_ASSIGN (state_purge_map);\n \n   const supergraph &m_sg;\n-  map_t m_map;\n+  ssa_map_t m_ssa_map;\n+  decl_map_t m_decl_map;\n+};\n+\n+  /* Base class for state_purge_per_ssa_name and state_purge_per_decl.  */\n+\n+class state_purge_per_tree\n+{\n+public:\n+  function *get_function () const { return m_fun; }\n+  tree get_fndecl () const { return m_fun->decl; }\n+\n+protected:\n+  typedef hash_set<function_point> point_set_t;\n+\n+  state_purge_per_tree (function *fun)\n+  : m_fun (fun)\n+  {\n+  }\n+\n+private:\n+  function *m_fun;\n };\n \n /* The part of a state_purge_map relating to a specific SSA name.\n@@ -114,7 +157,7 @@ class state_purge_map : public log_user\n    their successor states, so that we can simplify program_state objects,\n    in the hope of reducing state-blowup.  */\n \n-class state_purge_per_ssa_name\n+class state_purge_per_ssa_name : public state_purge_per_tree\n {\n public:\n   state_purge_per_ssa_name (const state_purge_map &map,\n@@ -123,8 +166,6 @@ class state_purge_per_ssa_name\n \n   bool needed_at_point_p (const function_point &point) const;\n \n-  function *get_function () const { return m_fun; }\n-\n private:\n   static function_point before_use_stmt (const state_purge_map &map,\n \t\t\t\t\t const gimple *use_stmt);\n@@ -137,10 +178,53 @@ class state_purge_per_ssa_name\n \t\t      auto_vec<function_point> *worklist,\n \t\t      const state_purge_map &map);\n \n-  typedef hash_set<function_point> point_set_t;\n   point_set_t m_points_needing_name;\n   tree m_name;\n-  function *m_fun;\n+};\n+\n+/* The part of a state_purge_map relating to a specific decl.\n+\n+   Analogous to state_purge_per_ssa_name, but for local decls.\n+\n+   This is more involved than the SSA name case, because we also need\n+   to handle pointers and components.  */\n+\n+class state_purge_per_decl : public state_purge_per_tree\n+{\n+public:\n+  state_purge_per_decl (const state_purge_map &map,\n+\t\t\ttree decl,\n+\t\t\tfunction *fun);\n+\n+  bool needed_at_point_p (const function_point &point) const;\n+\n+  void add_needed_at (const function_point &point);\n+  void add_pointed_to_at (const function_point &point);\n+  void process_worklists (const state_purge_map &map,\n+\t\t\t  region_model_manager *mgr);\n+\n+private:\n+  static function_point before_use_stmt (const state_purge_map &map,\n+\t\t\t\t\t const gimple *use_stmt);\n+\n+  void add_to_worklist (const function_point &point,\n+\t\t\tauto_vec<function_point> *worklist,\n+\t\t\tpoint_set_t *seen,\n+\t\t\tlogger *logger);\n+\n+  void process_point_backwards (const function_point &point,\n+\t\t\t\tauto_vec<function_point> *worklist,\n+\t\t\t\tpoint_set_t *seen,\n+\t\t\t\tconst state_purge_map &map,\n+\t\t\t\tconst region_model &model);\n+  void process_point_forwards (const function_point &point,\n+\t\t\t       auto_vec<function_point> *worklist,\n+\t\t\t       point_set_t *seen,\n+\t\t\t       const state_purge_map &map);\n+\n+  point_set_t m_points_needing_decl;\n+  point_set_t m_points_taking_address;\n+  tree m_decl;\n };\n \n /* Subclass of dot_annotator for use by -fdump-analyzer-state-purge."}, {"sha": "5bc7151a79870849f926fde35ef95a9ba4dfd0ed", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/boxed-ptr-1.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-ptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faacafd2306ad7ece721a79dedbb6e44e0d65bdb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-ptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-ptr-1.c?ref=faacafd2306ad7ece721a79dedbb6e44e0d65bdb", "patch": "@@ -47,9 +47,7 @@ void test_2 (int flag)\n \n   boxed_free (ptr);  \n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n-  /* TODO: ideally we would have purged the state of \"ptr\", and there would be\n-     just 1 enode here (PR analyzer/104943).  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n }\n \n void test_3 (int kind)\n@@ -76,7 +74,5 @@ void test_3 (int kind)\n \n   boxed_free (ptr);  \n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"4 processed enodes\" } */\n-  /* TODO: ideally we would have purged the state of \"ptr\", and there would be\n-     just 1 enode here (PR analyzer/104943).  */  \n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n }"}]}