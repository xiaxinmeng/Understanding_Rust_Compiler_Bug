{"sha": "ca55abaee78c7f75c7036d8616781bba42f1af6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E1NWFiYWVlNzhjN2Y3NWM3MDM2ZDg2MTY3ODFiYmE0MmYxYWY2Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-16T02:07:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-16T02:07:50Z"}, "message": "dwarf2 EH support\n\nFrom-SVN: r15464", "tree": {"sha": "d3f3fa9225d4040922a030638ba72ca3349ef34e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3f3fa9225d4040922a030638ba72ca3349ef34e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca55abaee78c7f75c7036d8616781bba42f1af6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca55abaee78c7f75c7036d8616781bba42f1af6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca55abaee78c7f75c7036d8616781bba42f1af6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca55abaee78c7f75c7036d8616781bba42f1af6c/comments", "author": null, "committer": null, "parents": [{"sha": "5168dcfc4419b301b0b083738a158b52cf32593e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5168dcfc4419b301b0b083738a158b52cf32593e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5168dcfc4419b301b0b083738a158b52cf32593e"}], "stats": {"total": 1111, "additions": 882, "deletions": 229}, "files": [{"sha": "ca793d536e9d7977c8867755fe52bd882c2904bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -12,6 +12,47 @@ Mon Sep 15 15:39:26 1997  Jeffrey A Law  (law@cygnus.com)\n \tmode wider than HOST_WIDE_INT, then the high word of a CONST_INT\n \tis derived from the sign bit of the low word.\n \n+Mon Sep 15 11:43:38 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tSupport dwarf2 unwinding on PUSH_ROUNDING targets like the x86.\n+\n+\t* dwarf2.h: Add DW_CFA_GNU_args_size.\n+\t* frame.c (execute_cfa_insn): Likewise.\n+\t* dwarf2out.c (dwarf_cfi_name, output_cfi): Likewise.\n+\t(dwarf2out_args_size, dwarf2out_stack_adjust): New fns.\n+\t(dwarf2out_frame_debug): If this isn't a prologue or epilogue\n+\tinsn, hand it off to dwarf2out_stack_adjust.\n+\t(dwarf2out_begin_prologue): Initialize args_size.\n+\t* frame.h (struct frame_state): Add args_size.\n+\t* libgcc2.c (__throw): Use args_size.\n+\t* final.c (final_scan_insn): If we push args, hand off all insns\n+\tto dwarf2out_frame_debug.\n+\t* defaults.h (DWARF2_UNWIND_INFO): OK for !ACCUMULATE_OUTGOING_ARGS.\n+\n+\t* dwarf2out.c dwarf2out_frame_debug): Fix typo.\n+\tHandle epilogue restore of SP from FP.\n+\t* emit-rtl.c (gen_sequence): Still generate a sequence if the \n+\tlone insn has RTX_FRAME_RELATED_P set.\n+\n+\t* frame.c (extract_cie_info): Handle \"e\" augmentation.\n+\t* dwarf2out.c (ASM_OUTPUT_DWARF_*): Provide definitions in the\n+ \tabsence of UNALIGNED_*_ASM_OP.\n+\t(UNALIGNED_*_ASM_OP): Only provide defaults if OBJECT_FORMAT_ELF.\n+\t(output_call_frame_info): Use \"e\" instead of \"z\" for augmentation.\n+\tDon't emit augmentation fields length.\n+\t(dwarf2out_do_frame): Move outside of #ifdefs.\n+\t* defaults.h (DWARF2_UNWIND_INFO): Don't require unaligned data\n+\topcodes.\n+\n+\t* sparc.h (UNALIGNED_INT_ASM_OP et al): Don't define here after all.\n+\t* sparc/sysv4.h (UNALIGNED_INT_ASM_OP): Define here.\n+\t* sparc/sunos4.h (DWARF2_UNWIND_INFO): Define to 0.\n+\t* sparc/sun4gas.h: New file.\n+\t* configure.in: Use sun4gas.h if SunOS 4 --with-gnu-as.\n+\n+\t* collect2.c (write_c_file_stat, write_c_file_glob): Declare \n+\t__register_frame_table and __deregister_frame.\n+\n 1997-09-15  Brendan Kehoe  <brendan@cygnus.com>\n \n \t* except.c (find_exception_handler_labels): Use xmalloc instead of\n@@ -45,6 +86,11 @@ Sat Sep 13 12:57:26 1997  Jeffrey A Law  (law@cygnus.com)\n \t* haifa-sched.c (add_branch_dependences): Make each insn in\n \ta SCHED_GROUP_P block explicitly depend on the previous insn.\n \n+Fri Sep 12 13:49:58 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.h: Prototype dwarf2 hooks.\n+\t* expr.c: Adjust.\n+\n Thu Sep 11 17:43:55 1997  Jim Wilson  <wilson@cygnus.com>\n \n \t* configure.in (native_prefix): Delete.\n@@ -112,6 +158,95 @@ Wed Sep 10 14:05:08 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)\n \t(check-gcc, check-g++): Depend on testsuite/site.exp.\n \tDon't stop for failure.\n \n+Wed Sep 10 12:59:57 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* expr.c (expand_builtin): Only support __builtin_dwarf_fp_regnum()\n+\tif DWARF2_UNWIND_INFO.\n+\n+Wed Sep 10 11:49:20 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tAdd support for exception handling using DWARF 2 frame unwind info.\n+\tCurrently works on SPARC and MIPS, and almost on x86.\n+\t\n+\t* libgcc2.c (get_reg, put_reg, get_return_addr, put_return_addr,\n+\tnext_stack_level, in_reg_window): Helper fns.\n+\t(__throw): Implement for DWARF2_UNWIND_INFO.\n+\n+\t* expr.c (expand_builtin): Handle builtins used by __throw.\n+\t* tree.h (enum built_in_function): Add builtins used by __throw.\n+\t* c-decl.c (init_decl_processing): Declare builtins used by __throw.\n+\t* dwarf2out.c (expand_builtin_dwarf_fp_regnum): Used by __throw.\n+\t* except.c (expand_builtin_unwind_init): Hook for dwarf2 __throw.\n+\t(expand_builtin_extract_return_addr): Likewise.\n+\t(expand_builtin_frob_return_addr): Likewise.\n+\t(expand_builtin_set_return_addr_reg): Likewise.\n+\t(expand_builtin_eh_stub): Likewise.\n+\t(expand_builtin_set_eh_regs): Likewise.\n+\t(eh_regs): Choose two call-clobbered registers for passing back values.\n+\n+\t* frame.c, frame.h: New files for parsing dwarf 2 frame info.\n+\t* Makefile.in (LIB2ADD): New variable.  Add $(srcdir)/frame.c.\n+\t(libgcc2.a): Use it instead of $(LIB2FUNCS_EXTRA) $(LANG_LIB2FUNCS)\n+\t(stmp-multilib): Likewise.\n+\t($(T)crtbegin.o, $(T)crtend.o): Add -fno-exceptions.\n+\n+\t* except.c: #include \"defaults.h\".\n+\t(exceptions_via_longjmp): Default depends on DWARF2_UNWIND_INFO.\n+\t(emit_throw): Don't defeat assemble_external if DWARF2_UNWIND_INFO.\n+\t(register_exception_table_p): New fn.\n+\t(start_eh_unwinder): Don't do anything if DWARF2_UNWIND_INFO.\n+\t(end_eh_unwinder): Likewise.\n+\n+\t* crtstuff.c: Wrap .eh_frame section, use EH_FRAME_SECTION_ASM_OP, \n+\tcall __register_frame and __deregister_frame as needed.\n+\t* varasm.c (eh_frame_section): New fn if EH_FRAME_SECTION_ASM_OP.\n+\t* dwarf2out.c (EH_FRAME_SECTION): Now a function-like macro.  Check\n+\tEH_FRAME_SECTION_ASM_OP.\n+\t* sparc/sysv4.h (EH_FRAME_SECTION_ASM_OP): Define.\n+\t* mips/iris6.h: (EH_FRAME_SECTION_ASM_OP): Define.\n+\t(LINK_SPEC): Add __EH_FRAME_BEGIN__ to hidden symbols.\n+\n+\t* dwarf2out.c (output_call_frame_info): If no support for\n+ \tEXCEPTION_SECTION, mark the start of the frame info with a\n+ \tcollectable tag.\n+\t* collect2.c (frame_tables): New list.\n+\t(is_ctor_dtor): Recognise frame entries.\n+\t(scan_prog_file): Likewise.\n+\t(main): Pass -fno-exceptions to sub-compile.  Also do collection\n+\tif there are any frame entries.\n+\t(write_c_file_stat): Call __register_frame_table and\n+ \t__deregister_frame as needed.\n+\t(write_c_file_glob): Likewise.\n+\n+\t* defaults.h (DWARF2_UNWIND_INFO): Default to 1 if supported.  \n+\tAlso require unaligned reloc support.\n+\t* sparc.h (UNALIGNED_SHORT_ASM_OP, UNALIGNED_INT_ASM_OP,\n+ \tUNALIGNED_DOUBLE_INT_ASM_OP): Define here.\n+\t* sparc/sysv4.h: Not here.\n+\n+\t* toplev.c (compile_file): Call dwarf2out_frame_{init,finish}.\n+\t* dwarf2out.c (dwarf2out_init): Don't call dwarf2out_frame_init.\n+\t(dwarf2out_finish): Don't call dwarf2out_frame_finish.\n+\n+\t* libgcc2.c (L_eh): Reorganize, moving code shared by different\n+\tEH implementations to the top.\n+\t(find_exception_handler): Split out.  Start from 0.  Compare against\n+\tend with >=.\n+\t(__find_first_exception_table_match): Use it.\n+\t* except.c (output_exception_table): Don't do anything if there's\n+\tno table.  Don't output a first entry of zeroes.\n+\t(eh_outer_context): Adjust properly.\n+\t(add_eh_table_entry): Use xrealloc.\n+\t* toplev.c (compile_file): Just call output_exception_table.\n+\n+Wed Sep 10  11:30:36 1997  Jason Merrill  <jason@cygnus.com>\n+\n+\t* i386.c (ix86_prologue): Add dwarf2 support for !do_rtl case.\n+\n+Wed Sep 10 08:17:10 1997  Torbjorn Granlund  <tege@pdc.kth..se>\n+\n+\t* except.c (eh_outer_context): Do masking using expand_and.\n+\n Wed Sep 10 01:38:30 1997  Doug Evans  <dje@cygnus.com>\n \n \tAdd port done awhile ago for the ARC cpu.\n@@ -152,10 +287,38 @@ Tue Sep  9 17:07:36 1997  Stan Cox  <coxs@dg-rtp.dg.com>\n \t* m88k.c (m88k_expand_prologue): Set MEM_IN_STRUCT_P of va_list\n \ttemplate.\n \n+Tue Sep  9 09:50:02 1997  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* dwarf2out.c (output_call_frame_info): Call named_section.\n+\n Tue Sep  9 09:12:17 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* haifa-sched.c (print_value): Fix last change.\n \n+Tue Sep  9 01:30:37 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* mips.h (DWARF_FRAME_REGNUM): Use the same numbering regardless of\n+\twrite_symbols.\n+\n+Mon Sep  8 16:32:43 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* mips.c (function_prologue): Set up the CFA when ABI_32.\n+\n+\t* sparc.c (save_regs): Check dwarf2out_do_frame instead of DWARF2_DEBUG\n+\tfor dwarf2 unwind info.\n+\t(output_function_prologue, sparc_flat_output_function_prologue): Same.\n+\n+\t* final.c (final_end_function): Check dwarf2out_do_frame instead\n+ \tof DWARF2_DEBUG for dwarf2 unwind info.\n+\t(final_scan_insn): Likewise.\n+\t(final_start_function): Likewise.  Initialize dwarf2 frame debug here.\n+\t(final): Not here.\n+\n+\t* expr.c (expand_builtin_return_addr): Only SETUP_FRAME_ADDRESSES if\n+\tcount > 0.\n+\n+\t* varasm.c (exception_section): Check EXCEPTION_SECTION first.\n+\n Mon Sep  8 15:15:11 1997  Nick Clifton  <nickc@cygnus.com>\n \n \t* v850.h (ASM_SPEC): Pass on target processor."}, {"sha": "985cbd549222a924af4fa907bfcf65e4c950fabc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -268,7 +268,7 @@ LIBGCC2 = libgcc2.a\n # -g1 causes output of debug info only for file-scope entities.\n # we use this here because that should be enough, and also\n # so that -g1 will be tested.\n-LIBGCC2_DEBUG_CFLAGS = -g1\n+LIBGCC2_DEBUG_CFLAGS = -g\n LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED\n \n # Additional options to use when compiling libgcc2.a.\n@@ -949,8 +949,9 @@ libgcc2.ready: $(GCC_PASSES) $(LIBGCC2_DEPS) stmp-int-hdrs\n \t\ttouch libgcc2.ready; \\\n \tfi\n \n-libgcc2.a: libgcc2.c libgcc2.ready $(CONFIG_H) $(LIB2FUNCS_EXTRA) \\\n-   $(LANG_LIB2FUNCS) machmode.h longlong.h gbl-ctors.h config.status\n+LIB2ADD = $(srcdir)/frame.c $(LIB2FUNCS_EXTRA) $(LANG_LIB2FUNCS)\n+libgcc2.a: libgcc2.c libgcc2.ready $(CONFIG_H) $(LIB2ADD) \\\n+   machmode.h longlong.h gbl-ctors.h config.status\n # Actually build it in tmplibgcc2.a, then rename at end,\n # so that libgcc2.a itself remains nonexistent if compilation is aborted.\n \t-rm -f tmplibgcc2.a\n@@ -975,35 +976,31 @@ libgcc2.a: libgcc2.c libgcc2.ready $(CONFIG_H) $(LIB2FUNCS_EXTRA) \\\n # We don't use -e here because there are if statements\n # that should not make the command give up when the if condition is false.\n # Instead, we test for failure after each command where it matters.\n-\tfor file in .. $(LIB2FUNCS_EXTRA) $(LANG_LIB2FUNCS); \\\n-\tdo \\\n-\t  if [ x$${file} != x.. ]; then \\\n-\t    name=`echo $${file} | sed -e 's/[.][cSo]$$//' -e 's/[.]asm$$//' -e 's/[.]txt$$//'`; \\\n-\t    oname=` echo $${name} | sed -e 's,.*/,,'`; \\\n-\t    if [ $${name}.txt = $${file} ]; then \\\n-\t      for f in .. `cat $${file}`; do if [ x$${f} != x.. ]; then \\\n-\t\t$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n-\t  \t  AR=\"$(AR)\" AR_FLAGS=\"$(AR_FLAGS)\" CC=\"$(CC)\" \\\n-\t\t  CFLAGS=\"$(CFLAGS)\" HOST_PREFIX=\"$(HOST_PREFIX)\" \\\n-\t\t  HOST_PREFIX_1=\"$(HOST_PREFIX_1)\" \\\n-\t\t  LANGUAGES=\"$(LANGUAGES)\" \\\n-\t\t  LIBGCC2_CFLAGS=\"$(LIBGCC2_CFLAGS)\" $${f}; \\\n-\t        if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n-\t        $(AR) $(AR_FLAGS) tmplibgcc2.a $${f}; \\\n-\t        rm -f $${f}; \\\n-\t      else true; \\\n-\t      fi; done; \\\n-\t    else \\\n-\t      echo $${name}; \\\n-\t      if [ $${name}.asm = $${file} ]; then \\\n-\t\tcp $${file} $${name}.s || exit 1; file=$${name}.s; \\\n-\t      else true; fi; \\\n-\t      $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) -c $${file}; \\\n+\tfor file in $(LIB2ADD); do \\\n+\t  name=`echo $${file} | sed -e 's/[.][cSo]$$//' -e 's/[.]asm$$//' -e 's/[.]txt$$//'`; \\\n+\t  oname=` echo $${name} | sed -e 's,.*/,,'`; \\\n+\t  if [ $${name}.txt = $${file} ]; then \\\n+\t    for f in .. `cat $${file}`; do if [ x$${f} != x.. ]; then \\\n+\t      $(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n+\t\tAR=\"$(AR)\" AR_FLAGS=\"$(AR_FLAGS)\" CC=\"$(CC)\" \\\n+\t\tCFLAGS=\"$(CFLAGS)\" HOST_PREFIX=\"$(HOST_PREFIX)\" \\\n+\t\tHOST_PREFIX_1=\"$(HOST_PREFIX_1)\" \\\n+\t\tLANGUAGES=\"$(LANGUAGES)\" \\\n+\t\tLIBGCC2_CFLAGS=\"$(LIBGCC2_CFLAGS)\" $${f}; \\\n \t      if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n-\t      $(AR) $(AR_FLAGS) tmplibgcc2.a $${oname}$(objext); \\\n-\t      rm -f $${name}.s $${oname}$(objext); \\\n-\t    fi; \\\n-\t  else true; \\\n+\t      $(AR) $(AR_FLAGS) tmplibgcc2.a $${f}; \\\n+\t      rm -f $${f}; \\\n+\t    else true; \\\n+\t    fi; done; \\\n+\t  else \\\n+\t    echo $${name}; \\\n+\t    if [ $${name}.asm = $${file} ]; then \\\n+\t      cp $${file} $${name}.s || exit 1; file=$${name}.s; \\\n+\t    else true; fi; \\\n+\t    $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) -c $${file}; \\\n+\t    if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\t    $(AR) $(AR_FLAGS) tmplibgcc2.a $${oname}$(objext); \\\n+\t    rm -f $${name}.s $${oname}$(objext); \\\n \t  fi; \\\n \tdone\n \tmv tmplibgcc2.a libgcc2.a\n@@ -1050,8 +1047,7 @@ stamp-mlib: $(srcdir)/genmultilib Makefile\n \n # Build multiple copies of libgcc.a, one for each target switch.\n stmp-multilib: $(LIBGCC1) libgcc2.c libgcc2.ready $(CONFIG_H) \\\n-   $(LIB2FUNCS_EXTRA) $(LANG_LIB2FUNCS) machmode.h longlong.h gbl-ctors.h \\\n-   config.status\n+   $(LIB2ADD) machmode.h longlong.h gbl-ctors.h config.status\n \tfor i in `$(GCC_FOR_TARGET) --print-multi-lib`; do \\\n \t  dir=`echo $$i | sed -e 's/;.*$$//'`; \\\n \t  flags=`echo $$i | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`; \\\n@@ -1121,12 +1117,12 @@ stmp-multilib-sub:\n # constructors.\n $(T)crtbegin.o: crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n-\t  -finhibit-size-directive -fno-inline-functions $(CRTSTUFF_T_CFLAGS) \\\n+\t  -finhibit-size-directive -fno-inline-functions -fno-exceptions $(CRTSTUFF_T_CFLAGS) \\\n \t  -c $(srcdir)/crtstuff.c -DCRT_BEGIN -o $(T)crtbegin$(objext)\n \n $(T)crtend.o: crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n-\t  -finhibit-size-directive -fno-inline-functions $(CRTSTUFF_T_CFLAGS) \\\n+\t  -finhibit-size-directive -fno-inline-functions -fno-exceptions $(CRTSTUFF_T_CFLAGS) \\\n \t  -c $(srcdir)/crtstuff.c -DCRT_END -o $(T)crtend$(objext)\n \n # On some systems we also want to install versions of these files"}, {"sha": "132788144401338040d2d5f669e24875351971a3", "filename": "gcc/configure", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -2313,7 +2313,7 @@ for machine in $build $host $target; do\n \ti[3456]86-*-freebsd*)\n \t\ttm_file=i386/freebsd.h\n \t\txm_file=i386/xm-freebsd.h\n-\t\t# On FreeBSD, the headers are already ok, except for math.h\n+\t\t# On FreeBSD, the headers are already ok, except for math.h.\n \t\tfixincludes=fixinc.math\n \t\ttmake_file=i386/t-freebsd\n \t\t;;\n@@ -3897,6 +3897,9 @@ for machine in $build $host $target; do\n \t\ttm_file=sparc/sunos4.h\n \t\ttmake_file=sparc/t-sunos41\n \t\tuse_collect2=yes\n+\t\tif [ x$gas = xyes ]; then\n+\t\t\ttm_file=\"${tm_file} sparc/sun4gas.h\"\n+\t\tfi\n \t\t;;\n \tsparc-*-sunos3*)\n \t\ttm_file=sparc/sun4o3.h"}, {"sha": "79649494b0767d964221412b529b6534965b8de5", "filename": "gcc/configure.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -2383,6 +2383,9 @@ for machine in $build $host $target; do\n \t\ttm_file=sparc/sunos4.h\n \t\ttmake_file=sparc/t-sunos41\n \t\tuse_collect2=yes\n+\t\tif [[ x$gas = xyes ]]; then\n+\t\t\ttm_file=\"${tm_file} sparc/sun4gas.h\"\n+\t\tfi\n \t\t;;\n \tsparc-*-sunos3*)\n \t\ttm_file=sparc/sun4o3.h"}, {"sha": "4873ed6f2f291b5d3c93800da2ffc20e594d0b57", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -36,6 +36,14 @@ Thu Sep 11 10:08:45 1997  Mark Mitchell  <mmitchell@usa.net>\n \t(tsubst): Do constant folding as necessary to make sure that\n \targuments passed to lookup_template_class really are constants. \n \n+Wed Sep 10 11:21:55 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.c (expand_builtin_throw): #ifndef DWARF2_UNWIND_INFO.\n+\t* decl2.c (finish_file): Only register exception tables if we\n+\tneed to.\n+\n+\t* decl.c (init_decl_processing): Add __builtin_[fs]p.\n+\n Tue Sep  9 19:49:38 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (unify): Just return 0 for a TYPENAME_TYPE."}, {"sha": "446befb4cc98242f7b2d2b117f7626bc2e334120", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -4725,7 +4725,7 @@ init_decl_processing ()\n   tree string_ftype_ptr_ptr, int_ftype_string_string;\n   tree sizetype_endlink;\n   tree ptr_ftype, ptr_ftype_unsigned, ptr_ftype_sizetype;\n-  tree void_ftype, void_ftype_int, void_ftype_ptr;\n+  tree void_ftype, void_ftype_int, void_ftype_ptr, ptr_ftype_void;\n \n   /* Have to make these distinct before we try using them.  */\n   lang_name_cplusplus = get_identifier (\"C++\");\n@@ -5103,6 +5103,10 @@ init_decl_processing ()\n   builtin_function (\"__builtin_frame_address\", ptr_ftype_unsigned,\n \t\t    BUILT_IN_FRAME_ADDRESS, NULL_PTR);\n \n+  ptr_ftype_void = build_function_type (ptr_type_node, endlink);\n+  builtin_function (\"__builtin_fp\", ptr_ftype_void, BUILT_IN_FP, NULL_PTR);\n+  builtin_function (\"__builtin_sp\", ptr_ftype_void, BUILT_IN_SP, NULL_PTR);\n+\n   builtin_function (\"__builtin_alloca\", ptr_ftype_sizetype,\n \t\t    BUILT_IN_ALLOCA, \"alloca\");\n   builtin_function (\"__builtin_ffs\", int_ftype_int, BUILT_IN_FFS, NULL_PTR);"}, {"sha": "234b6f5a13c439b1e6f5be2d7ded0d76bcf1e291", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -3196,6 +3196,7 @@ gen_sequence ()\n      (Now that we cache SEQUENCE expressions, it isn't worth special-casing\n      the case of an empty list.)  */\n   if (len == 1\n+      && ! RTX_FRAME_RELATED_P (first_insn)\n       && (GET_CODE (first_insn) == INSN\n \t  || GET_CODE (first_insn) == JUMP_INSN\n \t  /* Don't discard the call usage field.  */"}, {"sha": "47cae20cf9180aa399538228665962e58c1ff6f5", "filename": "gcc/except.c", "status": "modified", "additions": 289, "deletions": 80, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -87,34 +87,47 @@ Boston, MA 02111-1307, USA.  */\n    exception region, and the address of the handler designated for\n    that region.\n \n-   At program startup each object file invokes a function named\n+   If the target does not use the DWARF 2 frame unwind information, at\n+   program startup each object file invokes a function named\n    __register_exceptions with the address of its local\n-   __EXCEPTION_TABLE__. __register_exceptions is defined in libgcc2.c,\n-   and is responsible for recording all of the exception regions into\n-   one list (which is kept in a static variable named exception_table_list).\n+   __EXCEPTION_TABLE__. __register_exceptions is defined in libgcc2.c, and\n+   is responsible for recording all of the exception regions into one list\n+   (which is kept in a static variable named exception_table_list).\n+\n+   On targets that support crtstuff.c, the unwind information\n+   is stored in a section named .eh_frame and the information for the\n+   entire shared object or program is registered with a call to\n+   __register_frame.  On other targets, the information for each\n+   translation unit is registered separately with a static constructor.\n+   __register_frame is defined in frame.c, and is responsible for\n+   recording all of the unwind regions into one list (which is kept in a\n+   static variable named unwind_table_list).\n \n    The function __throw is actually responsible for doing the\n-   throw. In the C++ frontend, __throw is generated on a\n+   throw. On machines that have unwind info support, __throw is generated\n+   by code in libgcc2.c, otherwise __throw is generated on a\n    per-object-file basis for each source file compiled with\n-   -fexceptions. Before __throw is invoked, the current context\n-   of the throw needs to be placed in the global variable __eh_pc.\n+   -fexceptions by the the C++ frontend.  Before __throw is invoked,\n+   the current context of the throw needs to be placed in the global\n+   variable __eh_pc.\n \n    __throw attempts to find the appropriate exception handler for the \n    PC value stored in __eh_pc by calling __find_first_exception_table_match\n    (which is defined in libgcc2.c). If __find_first_exception_table_match\n-   finds a relevant handler, __throw jumps directly to it.\n-\n-   If a handler for the context being thrown from can't be found,\n-   __throw is responsible for unwinding the stack, determining the\n-   address of the caller of the current function (which will be used\n-   as the new context to throw from), and then restarting the process\n-   of searching for a handler for the new context. __throw may also\n-   call abort if it is unable to unwind the stack, and can also\n-   call an external library function named __terminate if it reaches\n-   the top of the stack without finding an appropriate handler. (By\n-   default __terminate invokes abort, but this behavior can be\n-   changed by the user to perform some sort of cleanup behavior before\n-   exiting).\n+   finds a relevant handler, __throw transfers control directly to it.\n+\n+   If a handler for the context being thrown from can't be found, __throw\n+   walks (see Walking the stack below) the stack up the dynamic call chain to\n+   continue searching for an appropriate exception handler based upon the\n+   caller of the function it last sought a exception handler for.  It stops\n+   then either an exception handler is found, or when the top of the\n+   call chain is reached.\n+\n+   If no handler is found, an external library function named\n+   __terminate is called.  If a handler is found, then we restart\n+   our search for a handler at the end of the call chain, and repeat\n+   the search process, but instead of just walking up the call chain,\n+   we unwind the call chain as we walk up it.\n \n    Internal implementation details:\n \n@@ -231,40 +244,79 @@ Boston, MA 02111-1307, USA.  */\n    incorrect results is better than halting the program.\n \n \n-   Unwinding the stack:\n+   Walking the stack:\n \n-   The details of unwinding the stack to the next frame can be rather\n-   complex. While in many cases a generic __unwind_function routine\n-   can be used by the generated exception handling code to do this, it\n-   is often necessary to generate inline code to do the unwinding.\n+   The stack is walked by starting with a pointer to the current\n+   frame, and finding the pointer to the callers frame.  The unwind info\n+   tells __throw how to find it.\n \n-   Whether or not these inlined unwinders are necessary is\n-   target-specific.\n+   Unwinding the stack:\n \n-   By default, if the target-specific backend doesn't supply a\n-   definition for __unwind_function, inlined unwinders will be used\n-   instead. The main tradeoff here is in text space utilization.\n-   Obviously, if inline unwinders have to be generated repeatedly,\n-   this uses much more space than if a single routine is used.\n+   When we use the term unwinding the stack, we mean undoing the\n+   effects of the function prologue in a controlled fashion so that we\n+   still have the flow of control.  Otherwise, we could just return\n+   (jump to the normal end of function epilogue).\n+\n+   This is done in __throw in libgcc2.c when we know that a handler exists\n+   in a frame higher up the call stack than its immediate caller.\n+\n+   To unwind, we find the unwind data associated with the frame, if any.\n+   If we don't find any, we call the library routine __terminate.  If we do\n+   find it, we use the information to copy the saved register values from\n+   that frame into the register save area in the frame for __throw, return\n+   into a stub which updates the stack pointer, and jump to the handler.\n+   The normal function epilogue for __throw handles restoring the saved\n+   values into registers.\n+\n+   When unwinding, we use this method if we know it will\n+   work (if DWARF2_UNWIND_INFO is defined).  Otherwise, we know that\n+   an inline unwinder will have been emitted for any function that\n+   __unwind_function cannot unwind.  The inline unwinder appears as a\n+   normal exception handler for the entire function, for any function\n+   that we know cannot be unwound by __unwind_function.  We inform the\n+   compiler of whether a function can be unwound with\n+   __unwind_function by having DOESNT_NEED_UNWINDER evaluate to true\n+   when the unwinder isn't needed.  __unwind_function is used as an\n+   action of last resort.  If no other method can be used for\n+   unwinding, __unwind_function is used.  If it cannot unwind, it\n+   should call __teminate.\n+\n+   By default, if the target-specific backend doesn't supply a definition\n+   for __unwind_function and doesn't support DWARF2_UNWIND_INFO, inlined\n+   unwinders will be used instead. The main tradeoff here is in text space\n+   utilization.  Obviously, if inline unwinders have to be generated\n+   repeatedly, this uses much more space than if a single routine is used.\n \n    However, it is simply not possible on some platforms to write a\n    generalized routine for doing stack unwinding without having some\n-   form of additional data associated with each function. The current\n-   implementation encodes this data in the form of additional machine\n-   instructions. This is clearly not desirable, as it is extremely\n-   inefficient. The next implementation will provide a set of metadata\n-   for each function that will provide the needed information.\n+   form of additional data associated with each function.  The current\n+   implementation can encode this data in the form of additional\n+   machine instructions or as static data in tabular form.  The later\n+   is called the unwind data.\n \n-   The backend macro DOESNT_NEED_UNWINDER is used to conditionalize\n-   whether or not per-function unwinders are needed. If DOESNT_NEED_UNWINDER\n-   is defined and has a non-zero value, a per-function unwinder is\n-   not emitted for the current function.\n+   The backend macro DOESNT_NEED_UNWINDER is used to conditionalize whether\n+   or not per-function unwinders are needed. If DOESNT_NEED_UNWINDER is\n+   defined and has a non-zero value, a per-function unwinder is not emitted\n+   for the current function.  If the static unwind data is supported, then\n+   a per-function unwinder is not emitted.\n \n    On some platforms it is possible that neither __unwind_function\n    nor inlined unwinders are available. For these platforms it is not\n    possible to throw through a function call, and abort will be\n    invoked instead of performing the throw. \n \n+   The reason the unwind data may be needed is that on some platforms\n+   the order and types of data stored on the stack can vary depending\n+   on the type of function, its arguments and returned values, and the\n+   compilation options used (optimization versus non-optimization,\n+   -fomit-frame-pointer, processor variations, etc).\n+\n+   Unfortunately, this also means that throwing through functions that\n+   aren't compiled with exception handling support will still not be\n+   possible on some platforms. This problem is currently being\n+   investigated, but no solutions have been found that do not imply\n+   some unacceptable performance penalties.\n+\n    Future directions:\n \n    Currently __throw makes no differentiation between cleanups and\n@@ -309,28 +361,11 @@ Boston, MA 02111-1307, USA.  */\n    query various state variables to determine what actions are to be\n    performed next.\n \n-   Another major problem that is being worked on is the issue with\n-   stack unwinding on various platforms. Currently the only platform\n-   that has support for __unwind_function is the Sparc; all other\n-   ports require per-function unwinders, which causes large amounts of\n-   code bloat.\n-\n-   Ideally it would be possible to store a small set of metadata with\n-   each function that would then make it possible to write a\n-   __unwind_function for every platform. This would eliminate the\n-   need for per-function unwinders.\n-\n-   The main reason the data is needed is that on some platforms the\n-   order and types of data stored on the stack can vary depending on\n-   the type of function, its arguments and returned values, and the\n-   compilation options used (optimization versus non-optimization,\n-   -fomit-frame-pointer, processor variations, etc).\n-\n-   Unfortunately, this also means that throwing through functions that\n-   aren't compiled with exception handling support will still not be\n-   possible on some platforms. This problem is currently being\n-   investigated, but no solutions have been found that do not imply\n-   some unacceptable performance penalties.\n+   Another major problem that is being worked on is the issue with stack\n+   unwinding on various platforms. Currently the only platforms that have\n+   support for the generation of a generic unwinder are the SPARC and MIPS.\n+   All other ports require per-function unwinders, which produce large\n+   amounts of code bloat.\n \n    For setjmp/longjmp based exception handling, some of the details\n    are as above, but there are some additional details.  This section\n@@ -354,6 +389,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n #include \"config.h\"\n+#include \"defaults.h\"\n #include <stdio.h>\n #include \"rtl.h\"\n #include \"tree.h\"\n@@ -373,7 +409,11 @@ Boston, MA 02111-1307, USA.  */\n /* One to use setjmp/longjmp method of generating code for exception\n    handling.  */\n \n+#if DWARF2_UNWIND_INFO\n+int exceptions_via_longjmp = 0;\n+#else\n int exceptions_via_longjmp = 1;\n+#endif\n \n /* One to enable asynchronous exception support.  */\n \n@@ -645,15 +685,12 @@ eh_outer_context (addr)\n {\n   /* First mask out any unwanted bits.  */\n #ifdef MASK_RETURN_ADDR\n-  expand_binop (Pmode, and_optab, addr, MASK_RETURN_ADDR, addr,\n-\t\t1, OPTAB_LIB_WIDEN);\n+  expand_and (addr, MASK_RETURN_ADDR, addr);\n #endif\n \n-  /* Then subtract out enough to get into the appropriate region.  If\n-     this is defined, assume we don't need to subtract anything as it\n-     is already within the correct region.  */\n-#if ! defined (RETURN_ADDR_OFFSET)\n-  addr = plus_constant (addr, -1);\n+  /* Then adjust to find the real return address.  */\n+#if defined (RETURN_ADDR_OFFSET)\n+  addr = plus_constant (addr, RETURN_ADDR_OFFSET);\n #endif\n \n   return addr;\n@@ -1107,7 +1144,10 @@ emit_throw ()\n #ifdef JUMP_TO_THROW\n       emit_indirect_jump (throw_libfunc);\n #else\n+#ifndef DWARF2_UNWIND_INFO\n+      /* Prevent assemble_external from doing anything with this symbol.  */\n       SYMBOL_REF_USED (throw_libfunc) = 1;\n+#endif\n       emit_library_call (throw_libfunc, 0, VOIDmode, 0);\n #endif\n       throw_used = 1;\n@@ -1446,10 +1486,8 @@ add_eh_table_entry (n)\n \t  if (eh_table_max_size < 0)\n \t    abort ();\n \n-\t  if ((eh_table = (int *) realloc (eh_table,\n-\t\t\t\t\t   eh_table_max_size * sizeof (int)))\n-\t      == 0)\n-\t    fatal (\"virtual memory exhausted\");\n+\t  eh_table = (int *) xrealloc (eh_table,\n+\t\t\t\t       eh_table_max_size * sizeof (int));\n \t}\n       else\n \t{\n@@ -1475,6 +1513,18 @@ exception_table_p ()\n   return 0;\n }\n \n+/* 1 if we need a static constructor to register EH table info.  */\n+\n+int\n+register_exception_table_p ()\n+{\n+#if defined (DWARF2_UNWIND_INFO)\n+  return 0;\n+#endif\n+\n+  return exception_table_p ();\n+}\n+\n /* Output the entry of the exception table corresponding to to the\n    exception region numbered N to file FILE. \n \n@@ -1512,7 +1562,7 @@ output_exception_table ()\n   int i;\n   extern FILE *asm_out_file;\n \n-  if (! doing_eh (0))\n+  if (! doing_eh (0) || ! eh_table)\n     return;\n \n   exception_section ();\n@@ -1521,11 +1571,6 @@ output_exception_table ()\n   assemble_align (GET_MODE_ALIGNMENT (ptr_mode));\n   assemble_label (\"__EXCEPTION_TABLE__\");\n \n-  assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n-  assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n-  assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n-  putc ('\\n', asm_out_file);\t\t/* blank line */\n-\n   for (i = 0; i < eh_table_size; ++i)\n     output_exception_table_entry (asm_out_file, eh_table[i]);\n \n@@ -1572,6 +1617,10 @@ start_eh_unwinder ()\n   if (exceptions_via_longjmp)\n     return;\n \n+#ifdef DWARF2_UNWIND_INFO\n+  return;\n+#endif\n+\n   expand_eh_region_start ();\n }\n \n@@ -1598,6 +1647,10 @@ end_eh_unwinder ()\n   if (exceptions_via_longjmp)\n     return;\n \n+#ifdef DWARF2_UNWIND_INFO\n+  return;\n+#else /* DWARF2_UNWIND_INFO */\n+\n   assemble_external (eh_saved_pc);\n \n   expr = make_node (RTL_EXPR);\n@@ -1658,6 +1711,7 @@ end_eh_unwinder ()\n       emit_barrier ();\n     }\n #endif\n+#endif /* DWARF2_UNWIND_INFO */\n }\n \n /* If necessary, emit insns for the per function unwinder for the\n@@ -2101,3 +2155,158 @@ exception_optimize ()\n \t}\n     }\n }\n+\f\n+/* Various hooks for the DWARF 2 __throw routine.  */\n+\n+/* Do any necessary initialization to access arbitrary stack frames.\n+   On the SPARC, this means flushing the register windows.  */\n+\n+void\n+expand_builtin_unwind_init ()\n+{\n+  /* Set this so all the registers get saved in our frame; we need to be\n+     able to copy the saved values for any registers from frames we unwind. */\n+  current_function_has_nonlocal_label = 1;\n+\n+#ifdef SETUP_FRAME_ADDRESSES\n+  SETUP_FRAME_ADDRESSES ();\n+#endif\n+}\n+\n+/* Given a value extracted from the return address register or stack slot,\n+   return the actual address encoded in that value.  */\n+\n+rtx\n+expand_builtin_extract_return_addr (addr_tree)\n+     tree addr_tree;\n+{\n+  rtx addr = expand_expr (addr_tree, NULL_RTX, Pmode, 0);\n+  return eh_outer_context (addr);\n+}\n+\n+/* Given an actual address in addr_tree, do any necessary encoding\n+   and return the value to be stored in the return address register or\n+   stack slot so the epilogue will return to that address.  */\n+\n+rtx\n+expand_builtin_frob_return_addr (addr_tree)\n+     tree addr_tree;\n+{\n+  rtx addr = expand_expr (addr_tree, NULL_RTX, Pmode, 0);\n+#ifdef RETURN_ADDR_OFFSET\n+  addr = plus_constant (addr, -RETURN_ADDR_OFFSET);\n+#endif\n+  return addr;\n+}\n+\n+/* Given an actual address in addr_tree, set the return address register up\n+   so the epilogue will return to that address.  If the return address is\n+   not in a register, do nothing.  */\n+\n+void\n+expand_builtin_set_return_addr_reg (addr_tree)\n+     tree addr_tree;\n+{\n+  rtx ra = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t       0, hard_frame_pointer_rtx);\n+\n+  if (GET_CODE (ra) != REG || REGNO (ra) >= FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  emit_move_insn (ra, expand_builtin_frob_return_addr (addr_tree));\n+}\n+\n+/* Choose two registers for communication between the main body of\n+   __throw and the stub for adjusting the stack pointer.  The first register\n+   is used to pass the address of the exception handler; the second register\n+   is used to pass the stack pointer offset.\n+\n+   For register 1 we use the return value register for a void *.\n+   For register 2 we use the static chain register if it exists and is\n+     different from register 1, otherwise some arbitrary call-clobbered\n+     register.  */\n+\n+static void\n+eh_regs (r1, r2, outgoing)\n+     rtx *r1, *r2;\n+     int outgoing;\n+{\n+  rtx reg1, reg2;\n+\n+#ifdef FUNCTION_OUTGOING_VALUE\n+  if (outgoing)\n+    reg1 = FUNCTION_OUTGOING_VALUE (build_pointer_type (void_type_node),\n+\t\t\t\t    current_function_decl);\n+  else\n+#endif\n+    reg1 = FUNCTION_VALUE (build_pointer_type (void_type_node),\n+\t\t\t   current_function_decl);\n+\n+#ifdef STATIC_CHAIN_REGNUM\n+  if (outgoing)\n+    reg2 = static_chain_incoming_rtx;\n+  else\n+    reg2 = static_chain_rtx;\n+  if (REGNO (reg2) == REGNO (reg1))\n+#endif /* STATIC_CHAIN_REGNUM */\n+    reg2 = NULL_RTX;\n+\n+  if (reg2 == NULL_RTX)\n+    {\n+      int i;\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+\tif (call_used_regs[i] && ! fixed_regs[i] && i != REGNO (reg1))\n+\t  {\n+\t    reg2 = gen_rtx (REG, Pmode, i);\n+\t    break;\n+\t  }\n+\n+      if (reg2 == NULL_RTX)\n+\tabort ();\n+    }\n+\n+  *r1 = reg1;\n+  *r2 = reg2;\n+}\n+\n+/* Emit inside of __throw a stub which adjusts the stack pointer and jumps\n+   to the exception handler.  __throw will set up the necessary values\n+   and then return to the stub.  */\n+\n+rtx\n+expand_builtin_eh_stub ()\n+{\n+  rtx stub_start = gen_label_rtx ();\n+  rtx after_stub = gen_label_rtx ();\n+  rtx handler, offset, temp;\n+\n+  emit_jump (after_stub);\n+  emit_label (stub_start);\n+\n+  eh_regs (&handler, &offset, 0);\n+\n+  adjust_stack (offset);\n+  emit_indirect_jump (handler);\n+\n+  emit_label (after_stub);\n+  return gen_rtx (LABEL_REF, Pmode, stub_start);\n+}\n+\n+/* Set up the registers for passing the handler address and stack offset\n+   to the stub above.  */\n+\n+void\n+expand_builtin_set_eh_regs (handler, offset)\n+     tree handler, offset;\n+{\n+  rtx reg1, reg2;\n+\n+  eh_regs (&reg1, &reg2, 1);\n+\n+  store_expr (offset,  reg2, 0);\n+  store_expr (handler, reg1, 0);\n+\n+  /* These will be used by the stub.  */\n+  emit_insn (gen_rtx (USE, VOIDmode, reg1));\n+  emit_insn (gen_rtx (USE, VOIDmode, reg2));\n+}"}, {"sha": "640bc8fd30e64a985a7119ce5cd81a607cd144b9", "filename": "gcc/expr.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"output.h\"\n #include \"typeclass.h\"\n+#include \"defaults.h\"\n \n #include \"bytecode.h\"\n #include \"bc-opcode.h\"\n@@ -7997,7 +7998,8 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n      arbitrary frames.  For example, on the sparc, we must first flush\n      all register windows to the stack.  */\n #ifdef SETUP_FRAME_ADDRESSES\n-  SETUP_FRAME_ADDRESSES ();\n+  if (count > 0)\n+    SETUP_FRAME_ADDRESSES ();\n #endif\n \n   /* On the sparc, the return address is not in the frame, it is in a\n@@ -9137,6 +9139,32 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn const0_rtx;\n       }\n \n+      /* Various hooks for the DWARF 2 __throw routine.  */\n+    case BUILT_IN_UNWIND_INIT:\n+      expand_builtin_unwind_init ();\n+      return const0_rtx;\n+    case BUILT_IN_FP:\n+      return frame_pointer_rtx;\n+    case BUILT_IN_SP:\n+      return stack_pointer_rtx;\n+#ifdef DWARF2_UNWIND_INFO\n+    case BUILT_IN_DWARF_FP_REGNUM:\n+      return expand_builtin_dwarf_fp_regnum ();\n+#endif\n+    case BUILT_IN_FROB_RETURN_ADDR:\n+      return expand_builtin_frob_return_addr (TREE_VALUE (arglist));\n+    case BUILT_IN_EXTRACT_RETURN_ADDR:\n+      return expand_builtin_extract_return_addr (TREE_VALUE (arglist));\n+    case BUILT_IN_SET_RETURN_ADDR_REG:\n+      expand_builtin_set_return_addr_reg (TREE_VALUE (arglist));\n+      return const0_rtx;\n+    case BUILT_IN_EH_STUB:\n+      return expand_builtin_eh_stub ();\n+    case BUILT_IN_SET_EH_REGS:\n+      expand_builtin_set_eh_regs (TREE_VALUE (arglist),\n+\t\t\t\t  TREE_VALUE (TREE_CHAIN (arglist)));\n+      return const0_rtx;\n+\n     default:\t\t\t/* just do library call, if unknown builtin */\n       error (\"built-in function `%s' not currently supported\",\n \t     IDENTIFIER_POINTER (DECL_NAME (fndecl)));"}, {"sha": "26a0e05d1ad296076d914c42f8405c3272676f14", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 349, "deletions": 111, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca55abaee78c7f75c7036d8616781bba42f1af6c/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=ca55abaee78c7f75c7036d8616781bba42f1af6c", "patch": "@@ -3107,11 +3107,9 @@ int _exit_dummy_decl = 0;\t/* prevent compiler & linker warnings */\n \f\n #ifdef L_eh\n \n-#ifdef EH_TABLE_LOOKUP\n-\n-EH_TABLE_LOOKUP\n+/* Shared exception handling support routines.  */\n \n-#else\n+extern void *__eh_type;\n \n void\n __default_terminate ()\n@@ -3127,14 +3125,31 @@ __terminate ()\n   (*__terminate_func)();\n }\n \n+void *\n+__throw_type_match (void *catch_type, void *throw_type, void *obj)\n+{\n+#if 0\n+ printf (\"__throw_type_match (): catch_type = %s, throw_type = %s\\n\",\n+\t catch_type, throw_type);\n+#endif\n+ if (strcmp ((const char *)catch_type, (const char *)throw_type) == 0)\n+   return obj;\n+ return 0;\n+}\n+\n+void\n+__empty ()\n+{\n+}\n+\f\n+/* Support routines for setjmp/longjmp exception handling.  */\n+\n /* Calls to __sjthrow are generated by the compiler when an exception\n    is raised when using the setjmp/longjmp exception handling codegen\n    method.  */\n \n extern void longjmp (void *, int);\n \n-void *__eh_type;\n-\n static void *top_elt[2];\n void **__dynamic_handler_chain = top_elt;\n \n@@ -3286,120 +3301,104 @@ __sjpopnthrow ()\n \n   __sjthrow ();\n }\n+\f\n+/* Support code for all exception region-based exception handling.  */\n+\n+/* This value identifies the place from which an exception is being\n+   thrown.  */\n+\n+extern void *__eh_pc;\n+\n+#ifdef EH_TABLE_LOOKUP\n+\n+EH_TABLE_LOOKUP\n \n-typedef struct {\n+#else\n+\n+typedef struct exception_table {\n   void *start;\n   void *end;\n   void *exception_handler;\n } exception_table;\n \n-struct exception_table_node {\n+/* This routine takes a PC and a pointer to the exception region TABLE for\n+   its translation unit, and returns the address of the exception handler\n+   associated with the closest exception table handler entry associated\n+   with that PC, or 0 if there are no table entries the PC fits in.\n+\n+   In the advent of a tie, we have to give the last entry, as it represents\n+   an inner block.  */\n+\n+static void *\n+find_exception_handler (void *pc, exception_table *table)\n+{\n+  if (table)\n+    {\n+      int pos;\n+      int best = 0;\n+\n+      /* We can't do a binary search because the table isn't guaranteed\n+\t to be sorted from function to function.  */\n+      for (pos = 0; table[pos].exception_handler != (void *) -1; ++pos)\n+\t{\n+\t  if (table[pos].start <= pc && table[pos].end >= pc)\n+\t    {\n+\t      /* This can apply.  Make sure it is at least as small as\n+\t\t the previous best.  */\n+\t      if (best == 0 || (table[pos].end <= table[best].end\n+\t\t\t\t&& table[pos].start >= table[best].start))\n+\t\tbest = pos;\n+\t    }\n+\t  /* But it is sorted by starting PC within a function.  */\n+\t  else if (best && table[pos].start > pc)\n+\t    break;\n+\t}\n+      if (best != 0)\n+\treturn table[best].exception_handler;\n+    }\n+\n+  return (void *) 0;\n+}\n+#endif /* EH_TABLE_LOOKUP */\n+\f\n+#ifndef DWARF2_UNWIND_INFO\n+/* Support code for exception handling using inline unwinders or\n+   __unwind_function.  */\n+\n+#ifndef EH_TABLE_LOOKUP\n+typedef struct exception_table_node {\n   exception_table *table;\n   void *start;\n   void *end;\n   struct exception_table_node *next;\n-};\n+} exception_table_node;\n \n static struct exception_table_node *exception_table_list;\n \n-/* this routine takes a pc, and the address of the exception handler associated\n-   with the closest exception table handler entry associated with that PC,\n-   or 0 if there are no table entries the PC fits in.  The algorithm works\n-   something like this:\n-\n-    while(current_entry exists) {\n-        if(current_entry.start < pc )\n-            current_entry = next_entry;\n-        else {\n-            if(prev_entry.start <= pc && prev_entry.end > pc) {\n-                save pointer to prev_entry;\n-                return prev_entry.exception_handler;\n-             }\n-            else return 0;\n-         }\n-     }\n-    return 0;\n-\n-   Assuming a correctly sorted table (ascending order) this routine should\n-   return the tightest match...\n-\n-   In the advent of a tie, we have to give the last entry, as it represents\n-   an inner block.  */\n-\n void *\n __find_first_exception_table_match (void *pc)\n {\n-  register struct exception_table_node *tnp;\n-  register exception_table *table;\n-  int pos;\n-  int best;\n-\n-#if 0\n-  printf (\"find_first_exception_table_match (): pc = %x!\\n\", pc);\n-#endif\n+  register exception_table_node *tnp;\n \n   for (tnp = exception_table_list; tnp != 0; tnp = tnp->next)\n     {\n-      if (tnp->start > pc || tnp->end <= pc)\n-\tcontinue;\n-\n-      table = tnp->table;\n-\n-      pos = 0;\n-      best = 0;\n-#if 0\n-      /* We can't do this yet, as we don't know that the table is sorted.  */\n-      do {\n-\t++pos;\n-\tif (table[pos].start > pc)\n-\t  /* found the first table[pos].start > pc, so the previous\n-\t     entry better be the one we want! */\n-\t  break;\n-      } while (table[pos].exception_handler != (void *) -1);\n-\n-      --pos;\n-      if (table[pos].start <= pc && table[pos].end > pc)\n-\t{\n-#if 0\n-\t  printf (\"find_first_eh_table_match (): found match: %x\\n\", table[pos].exception_handler);\n-#endif\n-\t  return table[pos].exception_handler;\n-\t}\n-#else\n-      while (table[++pos].exception_handler != (void *) -1) {\n-\tif (table[pos].start <= pc && table[pos].end > pc)\n-\t  {\n-\t    /* This can apply.  Make sure it is better or as good as\n-\t       the previous best.  */\n-\t    /* The best one ends first.  */\n-\t    if (best == 0 || (table[pos].end <= table[best].end\n-\t\t\t      /* The best one starts last.  */\n-\t\t\t      && table[pos].start >= table[best].start))\n-\t      best = pos;\n-\t  }\n-      }\n-      if (best != 0)\n-\treturn table[best].exception_handler;\n-#endif\n+      if (tnp->start <= pc && tnp->end >= pc)\n+\treturn find_exception_handler (pc, tnp->table);\n     }\n \n-#if 0\n-  printf (\"find_first_eh_table_match (): else: returning NULL!\\n\");\n-#endif\n   return (void *) 0;\n }\n \n void\n __register_exceptions (exception_table *table)\n {\n-  struct exception_table_node *node;\n+  exception_table_node *node;\n   exception_table *range = table + 1;\n \n   if (range->start == (void *) -1)\n     return;\n \n-  node = (struct exception_table_node *)\n-    malloc (sizeof (struct exception_table_node));\n+  node = (exception_table_node *) malloc (sizeof (exception_table_node));\n   node->table = table;\n \n   /* This look can be optimized away either if the table\n@@ -3417,19 +3416,7 @@ __register_exceptions (exception_table *table)\n   node->next = exception_table_list;\n   exception_table_list = node;\n }\n-#endif\n-\n-void *\n-__throw_type_match (void *catch_type, void *throw_type, void *obj)\n-{\n-#if 0\n- printf (\"__throw_type_match (): catch_type = %s, throw_type = %s\\n\",\n-\t catch_type, throw_type);\n-#endif\n- if (strcmp ((const char *)catch_type, (const char *)throw_type) == 0)\n-   return obj;\n- return 0;\n-}\n+#endif /* !EH_TABLE_LOOKUP */\n \n /* Throw stub routine.\n \n@@ -3441,11 +3428,6 @@ __throw ()\n   abort ();\n }\n \n-/* This value identifies the place from which an exception is being\n-   thrown.  */\n-\n-void *__eh_pc;\n-\n /* See expand_builtin_throw for details.  */\n \n void **__eh_pcnthrow () {\n@@ -3456,11 +3438,6 @@ void **__eh_pcnthrow () {\n   return buf;\n }\n \n-void\n-__empty ()\n-{\n-}\n-\n #if #machine(i386)\n void\n __unwind_function(void *ptr)\n@@ -3539,6 +3516,267 @@ __unwind_function(void *ptr)\n   abort ();\n }\n #endif /* powerpc */\n+\f\n+#else /* DWARF2_UNWIND_INFO */\n+/* Support code for exception handling using static unwind information.  */\n+\n+#include \"frame.h\"\n+\n+/* This type is used in get_reg and put_reg to deal with ABIs where a void*\n+   is smaller than a word, such as the Irix 6 n32 ABI.  We cast twice to\n+   avoid a warning about casting between int and pointer of different\n+   sizes.  */\n+\n+typedef int ptr_type __attribute__ ((mode (pointer)));\n+\n+/* Get the value of register REG as saved in UDATA, where SUB_UDATA is a\n+   frame called by UDATA or 0.  */\n+\n+static void*\n+get_reg (unsigned reg, frame_state *udata, frame_state *sub_udata)\n+{\n+  if (udata->saved[reg] == REG_SAVED_OFFSET)\n+    return (void *)(ptr_type)\n+      *(word_type *)(udata->cfa + udata->reg_or_offset[reg]);\n+  else if (udata->saved[reg] == REG_SAVED_REG && sub_udata)\n+    return get_reg (udata->reg_or_offset[reg], sub_udata, 0);\n+  else\n+    abort ();\n+}\n+\n+/* Overwrite the saved value for register REG in frame UDATA with VAL.  */\n+\n+static void\n+put_reg (unsigned reg, void *val, frame_state *udata)\n+{\n+  if (udata->saved[reg] == REG_SAVED_OFFSET)\n+    *(word_type *)(udata->cfa + udata->reg_or_offset[reg])\n+      = (word_type)(ptr_type) val;\n+  else\n+    abort ();\n+}\n+\n+/* Retrieve the return address for frame UDATA, where SUB_UDATA is a\n+   frame called by UDATA or 0.  */\n+\n+static inline void *\n+get_return_addr (frame_state *udata, frame_state *sub_udata)\n+{\n+  return __builtin_extract_return_addr\n+    (get_reg (udata->retaddr_column, udata, sub_udata));\n+}\n+\n+/* Overwrite the return address for frame UDATA with VAL.  */\n+\n+static inline void\n+put_return_addr (void *val, frame_state *udata)\n+{\n+  val = __builtin_frob_return_addr (val);\n+  put_reg (udata->retaddr_column, val, udata);\n+}\n+\n+/* Given the current frame UDATA and its return address PC, return the\n+   information about the calling frame in CALLER_UDATA.  */\n+\n+static void *\n+next_stack_level (void *pc, frame_state *udata, frame_state *caller_udata)\n+{\n+  caller_udata = __frame_state_for (pc, caller_udata);\n+  if (! caller_udata)\n+    return 0;\n+\n+  /* Now go back to our caller's stack frame.  If our caller's CFA register\n+     was saved in our stack frame, restore it; otherwise, assume the CFA\n+     register is SP and restore it to our CFA value.  */\n+  if (udata->saved[caller_udata->cfa_reg])\n+    caller_udata->cfa = get_reg (caller_udata->cfa_reg, udata, 0);\n+  else\n+    caller_udata->cfa = udata->cfa;\n+  caller_udata->cfa += caller_udata->cfa_offset;\n+\n+  return caller_udata;\n+}\n+\n+#ifdef INCOMING_REGNO\n+/* Is the saved value for register REG in frame UDATA stored in a register\n+   window in the previous frame?  */\n+\n+static int\n+in_reg_window (int reg, frame_state *udata)\n+{\n+  if (udata->saved[reg] != REG_SAVED_OFFSET)\n+    return 0;\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+  return udata->reg_or_offset[reg] > 0;\n+#else\n+  return udata->reg_or_offset[reg] < 0;\n+#endif\n+}\n+#endif /* INCOMING_REGNO */\n+\n+/* We first search for an exception handler, and if we don't find\n+   it, we call __terminate on the current stack frame so that we may\n+   use the debugger to walk the stack and understand why no handler\n+   was found.\n+\n+   If we find one, then we unwind the frames down to the one that\n+   has the handler and transfer control into the handler.  */\n+\n+void\n+__throw ()\n+{\n+  void *pc, *handler, *retaddr;\n+  frame_state ustruct, ustruct2;\n+  frame_state *udata = &ustruct;\n+  frame_state *sub_udata = &ustruct2;\n+  frame_state my_ustruct, *my_udata = &my_ustruct;\n+  long args_size;\n+\n+  /* This is required for C++ semantics.  We must call terminate if we\n+     try and rethrow an exception, when there is no exception currently\n+     active.  */\n+  if (! __eh_type)\n+    __terminate ();\n+    \n+  /* Start at our stack frame.  */\n+label:\n+  udata = __frame_state_for (&&label, udata);\n+  if (! udata)\n+    __terminate ();\n+\n+  /* We need to get the value from the CFA register.  At this point in\n+     compiling __throw we don't know whether or not we will use the frame\n+     pointer register for the CFA, so we check our unwind info.  */\n+  if (udata->cfa_reg == __builtin_dwarf_fp_regnum ())\n+    udata->cfa = __builtin_fp ();\n+  else\n+    udata->cfa = __builtin_sp ();\n+  udata->cfa += udata->cfa_offset;\n+\n+  memcpy (my_udata, udata, sizeof (*udata));\n+\n+  /* Do any necessary initialization to access arbitrary stack frames.\n+     On the SPARC, this means flushing the register windows.  */\n+  __builtin_unwind_init ();\n+\n+  /* Now reset pc to the right throw point.  */\n+  pc = __eh_pc;\n+\n+  for (;;)\n+    { \n+      frame_state *p = udata;\n+      udata = next_stack_level (pc, udata, sub_udata);\n+      sub_udata = p;\n+\n+      /* If we couldn't find the next frame, we lose.  */\n+      if (! udata)\n+\tbreak;\n+\n+      handler = find_exception_handler (pc, udata->eh_ptr);\n+\n+      /* If we found one, we can stop searching.  */\n+      if (handler)\n+\t{\n+\t  args_size = udata->args_size;\n+\t  break;\n+\t}\n+\n+      /* Otherwise, we continue searching.  */\n+      pc = get_return_addr (udata, sub_udata);\n+    }\n+\n+  /* If we haven't found a handler by now, this is an unhandled\n+     exception.  */\n+  if (! handler)\n+    __terminate ();\n+\n+  if (pc == __eh_pc)\n+    /* We found a handler in the throw context, no need to unwind.  */\n+    udata = my_udata;\n+  else\n+    {\n+      int i;\n+      void *val;\n+\n+      /* Unwind all the frames between this one and the handler by copying\n+\t their saved register values into our register save slots.  */\n+\n+      /* Remember the PC where we found the handler.  */\n+      void *handler_pc = pc;\n+\n+      /* Start from the throw context again.  */\n+      pc = __eh_pc;\n+      memcpy (udata, my_udata, sizeof (*udata));\n+\n+      while (pc != handler_pc)\n+\t{\n+\t  frame_state *p = udata;\n+\t  udata = next_stack_level (pc, udata, sub_udata);\n+\t  sub_udata = p;\n+\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+\t    if (udata->saved[i])\n+\t      {\n+#ifdef INCOMING_REGNO\n+\t\t/* If you modify the saved value of the return address\n+\t\t   register on the SPARC, you modify the return address for\n+\t\t   your caller's frame.  Don't do that here, as it will\n+\t\t   confuse get_return_addr.  */\n+\t\tif (in_reg_window (i, udata)\n+\t\t    && udata->saved[udata->retaddr_column] == REG_SAVED_REG\n+\t\t    && udata->reg_or_offset[udata->retaddr_column] == i)\n+\t\t  continue;\n+#endif\n+\t\tval = get_reg (i, udata, sub_udata);\n+\t\tput_reg (i, val, my_udata);\n+\t      }\n+\n+\t  pc = get_return_addr (udata, sub_udata);\n+\t}\n+\n+#ifdef INCOMING_REGNO\n+      /* But we do need to update the saved return address register from\n+\t the last frame we unwind, or the handler frame will have the wrong\n+\t return address.  */\n+      if (udata->saved[udata->retaddr_column] == REG_SAVED_REG)\n+\t{\n+\t  i = udata->reg_or_offset[udata->retaddr_column];\n+\t  if (in_reg_window (i, udata))\n+\t    {\n+\t      val = get_reg (i, udata, sub_udata);\n+\t      put_reg (i, val, my_udata);\n+\t    }\n+\t}\n+#endif\n+    }\n+  /* udata now refers to the frame called by the handler frame.  */\n+\n+  /* Emit the stub to adjust sp and jump to the handler.  */\n+  retaddr = __builtin_eh_stub ();\n+\n+  /* And then set our return address to point to the stub.  */\n+  if (my_udata->saved[my_udata->retaddr_column] == REG_SAVED_OFFSET)\n+    put_return_addr (retaddr, my_udata);\n+  else\n+    __builtin_set_return_addr_reg (retaddr);\n+\n+  /* Set up the registers we use to communicate with the stub.\n+     We check STACK_GROWS_DOWNWARD so the stub can use adjust_stack.  */\n+  __builtin_set_eh_regs (handler,\n+#ifdef STACK_GROWS_DOWNWARD\n+\t\t\t udata->cfa - my_udata->cfa\n+#else\n+\t\t\t my_udata->cfa - udata->cfa\n+#endif\n+\t\t\t + args_size\n+\t\t\t );\n+\n+  /* Epilogue:  restore the handler frame's register values and return\n+     to the stub.  */\n+}\n+#endif /* !DWARF2_UNWIND_INFO */\n+\n #endif /* L_eh */\n \f\n #ifdef L_pure"}]}