{"sha": "016adb0549c554d7ac73547a7c75b9a5594b14a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE2YWRiMDU0OWM1NTRkN2FjNzM1NDdhN2M3NWI5YTU1OTRiMTRhMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-10-27T11:30:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-10-27T11:30:23Z"}, "message": "tree-ssa-forwprop.c: Include tree-cfgcleanup.h and tree-into-ssa.h.\n\n2014-10-27  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-forwprop.c: Include tree-cfgcleanup.h and tree-into-ssa.h.\n\t(lattice): New global.\n\t(fwprop_ssa_val): New function.\n\t(fold_all_stmts): Likewise.\n\t(pass_forwprop::execute): Finally fold all stmts.\n\n\t* gcc.dg/tree-ssa/forwprop-6.c: Scan ccp1 dump instead.\n\t* gcc.dg/strlenopt-8.c: Adjust and XFAIL for non_strict_align\n\ttarget due to memcpy inline-expansion.\n\nFrom-SVN: r216728", "tree": {"sha": "d1caa846739a37536850c447d2598db7a5251ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1caa846739a37536850c447d2598db7a5251ce5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/016adb0549c554d7ac73547a7c75b9a5594b14a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/016adb0549c554d7ac73547a7c75b9a5594b14a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/016adb0549c554d7ac73547a7c75b9a5594b14a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/016adb0549c554d7ac73547a7c75b9a5594b14a3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c44fc0f2305f051c9631b4ab3f46417bfe0d644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c44fc0f2305f051c9631b4ab3f46417bfe0d644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c44fc0f2305f051c9631b4ab3f46417bfe0d644"}], "stats": {"total": 121, "additions": 116, "deletions": 5}, "files": [{"sha": "d11aae9537cc05cb0f2945c319a74d5e66a2d057", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=016adb0549c554d7ac73547a7c75b9a5594b14a3", "patch": "@@ -1,3 +1,11 @@\n+2014-10-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-forwprop.c: Include tree-cfgcleanup.h and tree-into-ssa.h.\n+\t(lattice): New global.\n+\t(fwprop_ssa_val): New function.\n+\t(fold_all_stmts): Likewise.\n+\t(pass_forwprop::execute): Finally fold all stmts.\n+\n 2014-10-26  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c++/53061"}, {"sha": "2f8efef32c208c67f1ca149265d425a7dc0aa6dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=016adb0549c554d7ac73547a7c75b9a5594b14a3", "patch": "@@ -1,3 +1,9 @@\n+2014-10-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/forwprop-6.c: Scan ccp1 dump instead.\n+\t* gcc.dg/strlenopt-8.c: Adjust and XFAIL for non_strict_align\n+\ttarget due to memcpy inline-expansion.\n+\n 2014-10-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/pack10.ads: New test."}, {"sha": "d82b31c5e0d83391bf0930da002b55a9aac03e25", "filename": "gcc/testsuite/gcc.dg/strlenopt-8.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c?ref=016adb0549c554d7ac73547a7c75b9a5594b14a3", "patch": "@@ -43,8 +43,13 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* On non-strict-align targets we inline the memcpy that strcat is turned\n+   into and end up with a short typed load / store which strlenopt is not\n+   able to analyze.  */\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" { xfail non_strict_align } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" { target { non_strict_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" { target { ! non_strict_align } } } }  */\n /* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */"}, {"sha": "79f0a8d2683436359772cb5d5d22a06eb51e6c5e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-6.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-6.c?ref=016adb0549c554d7ac73547a7c75b9a5594b14a3", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-forwprop1 -W -Wall\" } */\n+/* { dg-options \"-O2 -fdump-tree-ccp1 -W -Wall\" } */\n #if (__SIZEOF_INT__ == __SIZEOF_FLOAT__)\n typedef int intflt;\n #elif (__SIZEOF_LONG__ == __SIZEOF_FLOAT__)\n@@ -24,5 +24,5 @@ void f(void)\n    it to be valid.  Then we might as well handle the situation by\n    value-numbering, removing the load altogether.\n    ???  We now do this after CPP re-writes a into SSA form.  */\n-/* { dg-final { scan-tree-dump-times \"VIEW_CONVERT_EXPR\" 1 \"forwprop1\" } } */\n-/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump-times \"VIEW_CONVERT_EXPR\" 1 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "6b584e5c486ae70138249fbb40971249b17a5199", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016adb0549c554d7ac73547a7c75b9a5594b14a3/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=016adb0549c554d7ac73547a7c75b9a5594b14a3", "patch": "@@ -54,6 +54,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"tree-ssa-dom.h\"\n #include \"builtins.h\"\n+#include \"tree-cfgcleanup.h\"\n+#include \"tree-into-ssa.h\"\n \n /* This pass propagates the RHS of assignment statements into use\n    sites of the LHS of the assignment.  It's basically a specialized\n@@ -3586,6 +3588,93 @@ simplify_mult (gimple_stmt_iterator *gsi)\n \n   return false;\n }\n+\n+\n+/* Const-and-copy lattice for fold_all_stmts.  */\n+static vec<tree> lattice;\n+\n+/* Primitive \"lattice\" function for gimple_simplify.  */\n+\n+static tree\n+fwprop_ssa_val (tree name)\n+{\n+  /* First valueize NAME.  */\n+  if (TREE_CODE (name) == SSA_NAME\n+      && SSA_NAME_VERSION (name) < lattice.length ())\n+    {\n+      tree val = lattice[SSA_NAME_VERSION (name)];\n+      if (val)\n+\tname = val;\n+    }\n+  /* If NAME is not the only use signal we don't want to continue\n+     matching into its definition.  */\n+  if (TREE_CODE (name) == SSA_NAME\n+      && !has_single_use (name))\n+    return NULL_TREE;\n+  return name;\n+}\n+\n+/* Fold all stmts using fold_stmt following only single-use chains\n+   and using a simple const-and-copy lattice.  */\n+\n+static bool\n+fold_all_stmts (struct function *fun)\n+{\n+  bool cfg_changed = false;\n+\n+  /* Combine stmts with the stmts defining their operands.  Do that\n+     in an order that guarantees visiting SSA defs before SSA uses.  */\n+  lattice.create (num_ssa_names);\n+  lattice.quick_grow_cleared (num_ssa_names);\n+  int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n+  int postorder_num = inverted_post_order_compute (postorder);\n+  for (int i = 0; i < postorder_num; ++i)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fun, postorder[i]);\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple orig_stmt = stmt;\n+\n+\t  if (fold_stmt (&gsi, fwprop_ssa_val))\n+\t    {\n+\t      stmt = gsi_stmt (gsi);\n+\t      if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt)\n+\t\t  && gimple_purge_dead_eh_edges (bb))\n+\t\tcfg_changed = true;\n+\t      /* Cleanup the CFG if we simplified a condition to\n+\t         true or false.  */\n+\t      if (gimple_code (stmt) == GIMPLE_COND\n+\t\t  && (gimple_cond_true_p (stmt)\n+\t\t      || gimple_cond_false_p (stmt)))\n+\t\tcfg_changed = true;\n+\t      update_stmt (stmt);\n+\t    }\n+\n+\t  /* Fill up the lattice.  */\n+\t  if (gimple_assign_single_p (stmt))\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (stmt);\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t{\n+\t\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t\t    lattice[SSA_NAME_VERSION (lhs)] = fwprop_ssa_val (rhs);\n+\t\t  else if (is_gimple_min_invariant (rhs))\n+\t\t    lattice[SSA_NAME_VERSION (lhs)] = rhs;\n+\t\t  else\n+\t\t    lattice[SSA_NAME_VERSION (lhs)] = lhs;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  free (postorder);\n+  lattice.release ();\n+\n+  return cfg_changed;\n+}\n+\n /* Main entry point for the forward propagation and statement combine\n    optimizer.  */\n \n@@ -3876,6 +3965,9 @@ pass_forwprop::execute (function *fun)\n \t}\n     }\n \n+  /* At the end fold all statements.  */\n+  cfg_changed |= fold_all_stmts (fun);\n+\n   if (cfg_changed)\n     todoflags |= TODO_cleanup_cfg;\n "}]}