{"sha": "0e67400ab4f95d41decb49c32975f49ceb1e9f8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2NzQwMGFiNGY5NWQ0MWRlY2I0OWMzMjk3NWY0OWNlYjFlOWY4Yg==", "commit": {"author": {"name": "Fariborz Jahanian", "email": "fjahanian@apple.com", "date": "2003-10-23T14:36:23Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2003-10-23T14:36:23Z"}, "message": "rs6000.h (UNITS_PER_WORD): Use TARGET_32BIT, not TARGET_POWREPC64.\n\n\t* config/rs6000/rs6000.h (UNITS_PER_WORD): Use TARGET_32BIT, not\n\tTARGET_POWREPC64.\n\t(UNITS_PER_GPR_WORD): Define.\n\t(HARD_REGNO_NREGS): Use UNITS_PER_GPR_WORD.\n\t(HARD_REGNO_CALL_PART_CLOBBERED): Define.\n\t(HARD_REGNO_MODE_OK): Use UNITS_PER_GPR_WORD.\n\t(CLASS_MAX_NREGS): Use UNITS_PER_GPR_WORD.\n\t* config/rs6000/rs6000.c (function_arg): Generate PARALLEL for\n\tDFmode and DImode in 32-bit ABI / 64-bit computation mode.\n\t(rs6000_emit_prologue): Select reg_mode and reg_size using\n\tTARGET_32BIT, not TARGET_POWERPC64.\n\t(rs6000_function_value): Generate PARALLEL for DImode in 32-bit\n\tABI / 64-bit computation mode\n\nCo-Authored-By: David Edelsohn <edelsohn@gnu.org>\n\nFrom-SVN: r72851", "tree": {"sha": "b061ab2a9bc4d3558edd1a6da9e70b7a05c3a4cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b061ab2a9bc4d3558edd1a6da9e70b7a05c3a4cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e67400ab4f95d41decb49c32975f49ceb1e9f8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e67400ab4f95d41decb49c32975f49ceb1e9f8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e67400ab4f95d41decb49c32975f49ceb1e9f8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e67400ab4f95d41decb49c32975f49ceb1e9f8b/comments", "author": null, "committer": null, "parents": [{"sha": "00503146990fe82f1a2fcb4ee5daee776b27e882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00503146990fe82f1a2fcb4ee5daee776b27e882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00503146990fe82f1a2fcb4ee5daee776b27e882"}], "stats": {"total": 132, "additions": 124, "deletions": 8}, "files": [{"sha": "b1132f9256df313d98c92082aa3fe6d868222d15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e67400ab4f95d41decb49c32975f49ceb1e9f8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e67400ab4f95d41decb49c32975f49ceb1e9f8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e67400ab4f95d41decb49c32975f49ceb1e9f8b", "patch": "@@ -1,3 +1,20 @@\n+2003-10-23  Fariborz Jahanian  <fjahanian@apple.com>\n+\t    David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.h (UNITS_PER_WORD): Use TARGET_32BIT, not\n+\tTARGET_POWREPC64.\n+\t(UNITS_PER_GPR_WORD): Define.\n+\t(HARD_REGNO_NREGS): Use UNITS_PER_GPR_WORD.\n+\t(HARD_REGNO_CALL_PART_CLOBBERED): Define.\n+\t(HARD_REGNO_MODE_OK): Use UNITS_PER_GPR_WORD.\n+\t(CLASS_MAX_NREGS): Use UNITS_PER_GPR_WORD.\n+\t* config/rs6000/rs6000.c (function_arg): Generate PARALLEL for\n+\tDFmode and DImode in 32-bit ABI / 64-bit computation mode.\n+\t(rs6000_emit_prologue): Select reg_mode and reg_size using\n+\tTARGET_32BIT, not TARGET_POWERPC64.\n+\t(rs6000_function_value): Generate PARALLEL for DImode in 32-bit\n+\tABI / 64-bit computation mode\n+\n 2003-10-22  Andrew Haley  <aph@redhat.com>\n \n \t* toplev.c (output_file_directive): Allow for null input_name."}, {"sha": "2387ea7d367f3b29f6d521abd271372571641746", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 96, "deletions": 4, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e67400ab4f95d41decb49c32975f49ceb1e9f8b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e67400ab4f95d41decb49c32975f49ceb1e9f8b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0e67400ab4f95d41decb49c32975f49ceb1e9f8b", "patch": "@@ -4071,6 +4071,53 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t      || (align_words < GP_ARG_NUM_REG))))\n \t    return gen_rtx_REG (mode, cum->fregno);\n \n+\t  if (TARGET_32BIT && TARGET_POWERPC64 && mode == DFmode)\n+\t    {\n+              /* -mpowerpc64 with 32bit ABI splits up a DFmode argument\n+\t\t in vararg list into zero, one or two GPRs */\n+\t      if (align_words >= GP_ARG_NUM_REG)\n+\t\treturn gen_rtx_PARALLEL (DFmode,\n+\t\t  gen_rtvec (2,\n+\t\t\t     gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\tNULL_RTX, const0_rtx), \n+\t\t\t     gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\tgen_rtx_REG (mode,\n+\t\t\t\t\t\t\t     cum->fregno),\n+\t\t\t\t\t\tconst0_rtx)));\n+\t      else if (align_words + RS6000_ARG_SIZE (mode, type)\n+\t\t       > GP_ARG_NUM_REG)\n+\t\t/* If this is partially on the stack, then we only\n+\t\t   include the portion actually in registers here. */\n+\t\treturn gen_rtx_PARALLEL (DFmode,\n+\t\t  gen_rtvec (2,   \n+\t\t\t     gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\tgen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t     GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t     + align_words),\n+\t\t\t\t\t\tconst0_rtx),\n+\t\t\t     gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\tgen_rtx_REG (mode,\n+\t\t\t\t\t\t\t     cum->fregno),\n+\t\t\t\t\t\tconst0_rtx)));\n+\n+\t      /* split a DFmode arg into two GPRs */\n+\t      return gen_rtx_PARALLEL (DFmode,\n+\t\tgen_rtvec (3,\n+\t\t\t   gen_rtx_EXPR_LIST (VOIDmode,       \n+\t\t\t\t\t      gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t   GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t   + align_words),\n+\t\t\t\t\t      const0_rtx),\n+\t\t\t   gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t   GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t   + align_words + 1),\n+\t\t\t\t\t      GEN_INT (4)),\n+\t\t\t   gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (mode, cum->fregno),\n+\t\t\t\t\t      const0_rtx)));\n+            }\n+\n           return gen_rtx_PARALLEL (mode,\n \t    gen_rtvec (2,\n \t\t       gen_rtx_EXPR_LIST (VOIDmode,\n@@ -4091,6 +4138,37 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\tgen_rtx_REG (mode, cum->fregno),\n \t\t\t\tconst0_rtx)));\n \t}\n+      /* -mpowerpc64 with 32bit ABI splits up a DImode argument into one\n+\t or two GPRs */\n+      else if (TARGET_32BIT && TARGET_POWERPC64 && mode == DImode\n+\t       && align_words < GP_ARG_NUM_REG - 1)\n+\t{\n+\t  return gen_rtx_PARALLEL (DImode,\n+\t    gen_rtvec (2,\n+\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (SImode,\n+\t\t\t\t\t\t       GP_ARG_MIN_REG\n+\t\t\t\t\t\t       + align_words),\n+\t\t\t\t\t  const0_rtx),\n+\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (SImode,\n+\t\t\t\t\t\t       GP_ARG_MIN_REG\n+\t\t\t\t\t\t       + align_words + 1),\n+\t\t\t\t\t  GEN_INT (4))));\n+\t}\n+      else if (TARGET_32BIT && TARGET_POWERPC64 && mode == DImode\n+\t       && align_words == GP_ARG_NUM_REG - 1)\n+\t{\n+\t  return gen_rtx_PARALLEL (DImode,\n+\t    gen_rtvec (2,\n+\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  NULL_RTX, const0_rtx),\n+\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (SImode,\n+\t\t\t\t\t\t       GP_ARG_MIN_REG\n+\t\t\t\t\t\t       + align_words),\n+\t\t\t\t\t  const0_rtx)));\n+\t}\n       else if (align_words < GP_ARG_NUM_REG)\n \treturn gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n       else\n@@ -11278,8 +11356,8 @@ void\n rs6000_emit_prologue (void)\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n-  enum machine_mode reg_mode = TARGET_POWERPC64 ? DImode : SImode;\n-  int reg_size = TARGET_POWERPC64 ? 8 : 4;\n+  enum machine_mode reg_mode = Pmode;\n+  int reg_size = UNITS_PER_WORD;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n   rtx frame_ptr_rtx = gen_rtx_REG (Pmode, 12);\n   rtx frame_reg_rtx = sp_reg_rtx;\n@@ -11744,8 +11822,8 @@ rs6000_emit_epilogue (int sibcall)\n   int sp_offset = 0;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, 1);\n   rtx frame_reg_rtx = sp_reg_rtx;\n-  enum machine_mode reg_mode = TARGET_POWERPC64 ? DImode : SImode;\n-  int reg_size = TARGET_POWERPC64 ? 8 : 4;\n+  enum machine_mode reg_mode = Pmode;\n+  int reg_size = UNITS_PER_WORD;\n   int i;\n \n   info = rs6000_stack_info ();\n@@ -15357,6 +15435,20 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n   enum machine_mode mode;\n   unsigned int regno;\n \n+  if (TARGET_32BIT && TARGET_POWERPC64 && TYPE_MODE (valtype) == DImode)\n+    {\n+      /* Long long return value need be split in -mpowerpc64, 32bit ABI.  */\n+      return gen_rtx_PARALLEL (DImode,\n+\tgen_rtvec (2,\n+\t\t   gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (SImode, GP_ARG_RETURN),\n+\t\t\t\t      const0_rtx),\n+\t\t   gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (SImode,\n+\t\t\t\t\t\t   GP_ARG_RETURN + 1),\n+\t\t\t\t      GEN_INT (4))));\n+    }\n+\n   if ((INTEGRAL_TYPE_P (valtype)\n        && TYPE_PRECISION (valtype) < BITS_PER_WORD)\n       || POINTER_TYPE_P (valtype))"}, {"sha": "3665b0a3fb50086a37c2211eba254cc7d39a31fd", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e67400ab4f95d41decb49c32975f49ceb1e9f8b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e67400ab4f95d41decb49c32975f49ceb1e9f8b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0e67400ab4f95d41decb49c32975f49ceb1e9f8b", "patch": "@@ -625,7 +625,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n #define MAX_BITS_PER_WORD 64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD (! TARGET_POWERPC64 ? 4 : 8)\n+#define UNITS_PER_WORD (TARGET_32BIT ? 4 : 8)\n #ifdef IN_LIBGCC2\n #define MIN_UNITS_PER_WORD UNITS_PER_WORD\n #else\n@@ -988,14 +988,21 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    POWER and PowerPC GPRs hold 32 bits worth;\n    PowerPC64 GPRs and FPRs point register holds 64 bits worth.  */\n \n+#define UNITS_PER_GPR_WORD (! TARGET_POWERPC64 ? 4 : 8)\n+\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n    ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n    : (SPE_SIMD_REGNO_P (REGNO) && TARGET_SPE && SPE_VECTOR_MODE (MODE))   \\\n    ? ((GET_MODE_SIZE (MODE) + UNITS_PER_SPE_WORD - 1) / UNITS_PER_SPE_WORD) \\\n    : ALTIVEC_REGNO_P (REGNO)\t\t\t\t\t\t\\\n    ? ((GET_MODE_SIZE (MODE) + UNITS_PER_ALTIVEC_WORD - 1) / UNITS_PER_ALTIVEC_WORD) \\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_GPR_WORD - 1) / UNITS_PER_GPR_WORD))\n+\n+#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\\\n+  ((TARGET_32BIT && TARGET_POWERPC64\t\t\t\\\n+    && (MODE == DImode || MODE == DFmode)\t\t\\\n+    && INT_REGNO_P (REGNO)) ? 1 : 0)\n \n #define ALTIVEC_VECTOR_MODE(MODE)\t\\\n \t ((MODE) == V16QImode\t\t\\\n@@ -1035,7 +1042,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    : SPE_SIMD_REGNO_P (REGNO) && TARGET_SPE && SPE_VECTOR_MODE (MODE) ? 1 \\\n    : CR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_CC\t\t\\\n    : XER_REGNO_P (REGNO) ? (MODE) == PSImode\t\t\t\t\\\n-   : GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\n+   : GET_MODE_SIZE (MODE) <= UNITS_PER_GPR_WORD)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -1458,7 +1465,7 @@ enum reg_class\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n  (((CLASS) == FLOAT_REGS) \t\t\t\t\t\t\\\n   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_GPR_WORD - 1) / UNITS_PER_GPR_WORD))\n \n \n /* Return a class of registers that cannot change FROM mode to TO mode.  */"}]}