{"sha": "088d3b0fc3d97093c3e9c8a9313be2010f55af54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg4ZDNiMGZjM2Q5NzA5M2MzZTljOGE5MzEzYmUyMDEwZjU1YWY1NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-09-18T10:51:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-09-18T10:51:43Z"}, "message": "re PR ada/58264 (incorrect bounds of string when assigned from dereference of function result)\n\n\tPR ada/58264\n\t* gcc-interface/trans.c (Attribute_to_gnu): Define GNAT_PREFIX local\n\tvariable and use it throughout.\n\t<Attr_Length>: Note whether the prefix is the dereference of a pointer\n\tto unconstrained array and, in this case, capture the result for both\n\tAttr_First and Attr_Last.\n\nFrom-SVN: r202694", "tree": {"sha": "32460a96cd626f9b413c15aa5d0ecb979bdd3781", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32460a96cd626f9b413c15aa5d0ecb979bdd3781"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/088d3b0fc3d97093c3e9c8a9313be2010f55af54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/088d3b0fc3d97093c3e9c8a9313be2010f55af54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/088d3b0fc3d97093c3e9c8a9313be2010f55af54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/088d3b0fc3d97093c3e9c8a9313be2010f55af54/comments", "author": null, "committer": null, "parents": [{"sha": "5ef054c39266d4a7767f070bf9b540e113a72f97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ef054c39266d4a7767f070bf9b540e113a72f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ef054c39266d4a7767f070bf9b540e113a72f97"}], "stats": {"total": 178, "additions": 129, "deletions": 49}, "files": [{"sha": "6b0ba092134fc62c1221beb9b8009218d042579e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088d3b0fc3d97093c3e9c8a9313be2010f55af54/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088d3b0fc3d97093c3e9c8a9313be2010f55af54/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=088d3b0fc3d97093c3e9c8a9313be2010f55af54", "patch": "@@ -1,3 +1,12 @@\n+2013-09-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/58264\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Define GNAT_PREFIX local\n+\tvariable and use it throughout.\n+\t<Attr_Length>: Note whether the prefix is the dereference of a pointer\n+\tto unconstrained array and, in this case, capture the result for both\n+\tAttr_First and Attr_Last.\n+\n 2013-09-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Abstract_State>: New."}, {"sha": "7e56f22c3f042ccae4632b5520ea512006a0ded4", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 91, "deletions": 49, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088d3b0fc3d97093c3e9c8a9313be2010f55af54/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088d3b0fc3d97093c3e9c8a9313be2010f55af54/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=088d3b0fc3d97093c3e9c8a9313be2010f55af54", "patch": "@@ -1391,6 +1391,7 @@ Pragma_to_gnu (Node_Id gnat_node)\n static tree\n Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n {\n+  const Node_Id gnat_prefix = Prefix (gnat_node);\n   tree gnu_prefix, gnu_type, gnu_expr;\n   tree gnu_result_type, gnu_result = error_mark_node;\n   bool prefix_unused = false;\n@@ -1400,13 +1401,13 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n      parameter types might be incomplete types coming from a limited with.  */\n   if (Ekind (Etype (gnat_node)) == E_Access_Subprogram_Type\n       && Is_Dispatch_Table_Entity (Etype (gnat_node))\n-      && Nkind (Prefix (gnat_node)) == N_Identifier\n-      && Is_Subprogram (Entity (Prefix (gnat_node)))\n-      && Is_Public (Entity (Prefix (gnat_node)))\n-      && !present_gnu_tree (Entity (Prefix (gnat_node))))\n-    gnu_prefix = get_minimal_subprog_decl (Entity (Prefix (gnat_node)));\n+      && Nkind (gnat_prefix) == N_Identifier\n+      && Is_Subprogram (Entity (gnat_prefix))\n+      && Is_Public (Entity (gnat_prefix))\n+      && !present_gnu_tree (Entity (gnat_prefix)))\n+    gnu_prefix = get_minimal_subprog_decl (Entity (gnat_prefix));\n   else\n-    gnu_prefix = gnat_to_gnu (Prefix (gnat_node));\n+    gnu_prefix = gnat_to_gnu (gnat_prefix);\n   gnu_type = TREE_TYPE (gnu_prefix);\n \n   /* If the input is a NULL_EXPR, make a new one.  */\n@@ -1549,8 +1550,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t since it can use a special calling convention on some platforms,\n \t which cannot be propagated to the access type.  */\n       else if (attribute == Attr_Access\n-\t       && Nkind (Prefix (gnat_node)) == N_Identifier\n-\t       && is_cplusplus_method (Entity (Prefix (gnat_node))))\n+\t       && Nkind (gnat_prefix) == N_Identifier\n+\t       && is_cplusplus_method (Entity (gnat_prefix)))\n \tpost_error (\"access to C++ constructor or member function not allowed\",\n \t\t    gnat_node);\n \n@@ -1661,13 +1662,12 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  /* If this is a dereference and we have a special dynamic constrained\n \t     subtype on the prefix, use it to compute the size; otherwise, use\n \t     the designated subtype.  */\n-\t  if (Nkind (Prefix (gnat_node)) == N_Explicit_Dereference)\n+\t  if (Nkind (gnat_prefix) == N_Explicit_Dereference)\n \t    {\n-\t      Node_Id gnat_deref = Prefix (gnat_node);\n \t      Node_Id gnat_actual_subtype\n-\t\t= Actual_Designated_Subtype (gnat_deref);\n+\t\t= Actual_Designated_Subtype (gnat_prefix);\n \t      tree gnu_ptr_type\n-\t\t= TREE_TYPE (gnat_to_gnu (Prefix (gnat_deref)));\n+\t\t= TREE_TYPE (gnat_to_gnu (Prefix (gnat_prefix)));\n \n \t      if (TYPE_IS_FAT_OR_THIN_POINTER_P (gnu_ptr_type)\n \t\t  && Present (gnat_actual_subtype))\n@@ -1728,7 +1728,6 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  align = DECL_ALIGN (TREE_OPERAND (gnu_prefix, 1)) / BITS_PER_UNIT;\n \telse\n \t  {\n-\t    Node_Id gnat_prefix = Prefix (gnat_node);\n \t    Entity_Id gnat_type = Etype (gnat_prefix);\n \t    unsigned int double_align;\n \t    bool is_capped_double, align_clause;\n@@ -1800,28 +1799,38 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t\t : 1), i;\n \tstruct parm_attr_d *pa = NULL;\n \tEntity_Id gnat_param = Empty;\n+\tbool unconstrained_ptr_deref = false;\n \n \t/* Make sure any implicit dereference gets done.  */\n \tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n \tgnu_prefix = maybe_unconstrained_array (gnu_prefix);\n \n-\t/* We treat unconstrained array In parameters specially.  */\n-\tif (!Is_Constrained (Etype (Prefix (gnat_node))))\n-\t  {\n-\t    Node_Id gnat_prefix = Prefix (gnat_node);\n-\n-\t    /* This is the direct case.  */\n-\t    if (Nkind (gnat_prefix) == N_Identifier\n-\t\t&& Ekind (Entity (gnat_prefix)) == E_In_Parameter)\n-\t      gnat_param = Entity (gnat_prefix);\n-\n-\t    /* This is the indirect case.  Note that we need to be sure that\n-\t       the access value cannot be null as we'll hoist the load.  */\n-\t    if (Nkind (gnat_prefix) == N_Explicit_Dereference\n-\t\t&& Nkind (Prefix (gnat_prefix)) == N_Identifier\n-\t\t&& Ekind (Entity (Prefix (gnat_prefix))) == E_In_Parameter\n-\t\t&& Can_Never_Be_Null (Entity (Prefix (gnat_prefix))))\n-\t      gnat_param = Entity (Prefix (gnat_prefix));\n+\t/* We treat unconstrained array In parameters specially.  We also note\n+\t   whether we are dereferencing a pointer to unconstrained array.  */\n+\tif (!Is_Constrained (Etype (gnat_prefix)))\n+\t  switch (Nkind (gnat_prefix))\n+\t    {\n+\t    case N_Identifier:\n+\t      /* This is the direct case.  */\n+\t      if (Ekind (Entity (gnat_prefix)) == E_In_Parameter)\n+\t\tgnat_param = Entity (gnat_prefix);\n+\t      break;\n+\n+\t    case N_Explicit_Dereference:\n+\t      /* This is the indirect case.  Note that we need to be sure that\n+\t\t the access value cannot be null as we'll hoist the load.  */\n+\t      if (Nkind (Prefix (gnat_prefix)) == N_Identifier\n+\t\t  && Ekind (Entity (Prefix (gnat_prefix))) == E_In_Parameter)\n+\t\t{\n+\t\t  if (Can_Never_Be_Null (Entity (Prefix (gnat_prefix))))\n+\t\t    gnat_param = Entity (Prefix (gnat_prefix));\n+\t\t}\n+\t      else\n+\t\tunconstrained_ptr_deref = true;\n+\t      break;\n+\n+\t    default:\n+\t      break;\n \t  }\n \n \t/* If the prefix is the view conversion of a constrained array to an\n@@ -1956,22 +1965,54 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  {\n \t    gnu_result\n \t      = build1 (SAVE_EXPR, TREE_TYPE (gnu_result), gnu_result);\n-\t    if (attribute == Attr_First)\n-\t      pa->first = gnu_result;\n-\t    else if (attribute == Attr_Last)\n-\t      pa->last = gnu_result;\n-\t    else\n-\t      pa->length = gnu_result;\n+\t    switch (attribute)\n+\t      {\n+\t      case Attr_First:\n+\t\tpa->first = gnu_result;\n+\t\tbreak;\n+\n+\t      case Attr_Last:\n+\t\tpa->last = gnu_result;\n+\t\tbreak;\n+\n+\t      case Attr_Length:\n+\t      case Attr_Range_Length:\n+\t\tpa->length = gnu_result;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n \t  }\n \n-\t/* Set the source location onto the predicate of the condition in the\n-\t   'Length case but do not do it if the expression is cached to avoid\n-\t   messing up the debug info.  */\n-\telse if ((attribute == Attr_Range_Length || attribute == Attr_Length)\n-\t\t && TREE_CODE (gnu_result) == COND_EXPR\n-\t\t && EXPR_P (TREE_OPERAND (gnu_result, 0)))\n-\t  set_expr_location_from_node (TREE_OPERAND (gnu_result, 0),\n-\t\t\t\t       gnat_node);\n+\t/* Otherwise, evaluate it each time it is referenced.  */\n+\telse\n+\t  switch (attribute)\n+\t    {\n+\t    case Attr_First:\n+\t    case Attr_Last:\n+\t      /* If we are dereferencing a pointer to unconstrained array, we\n+\t\t need to capture the value because the pointed-to bounds may\n+\t\t subsequently be released.  */\n+\t      if (unconstrained_ptr_deref)\n+\t\tgnu_result\n+\t\t  = build1 (SAVE_EXPR, TREE_TYPE (gnu_result), gnu_result);\n+\t      break;\n+\n+\t    case Attr_Length:\n+\t    case Attr_Range_Length:\n+\t      /* Set the source location onto the predicate of the condition\n+\t\t but not if the expression is cached to avoid messing up the\n+\t\t debug info.  */\n+\t      if (TREE_CODE (gnu_result) == COND_EXPR\n+\t\t  && EXPR_P (TREE_OPERAND (gnu_result, 0)))\n+\t\tset_expr_location_from_node (TREE_OPERAND (gnu_result, 0),\n+\t\t\t\t\t     gnat_node);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \n \tbreak;\n       }\n@@ -2144,8 +2185,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n     case Attr_Mechanism_Code:\n       {\n+\tEntity_Id gnat_obj = Entity (gnat_prefix);\n \tint code;\n-\tEntity_Id gnat_obj = Entity (Prefix (gnat_node));\n \n \tprefix_unused = true;\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -2180,10 +2221,11 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n      it has a side-effect.  But don't do it if the prefix is just an entity\n      name.  However, if an access check is needed, we must do it.  See second\n      example in AARM 11.6(5.e).  */\n-  if (prefix_unused && TREE_SIDE_EFFECTS (gnu_prefix)\n-      && !Is_Entity_Name (Prefix (gnat_node)))\n-    gnu_result = build_compound_expr  (TREE_TYPE (gnu_result), gnu_prefix,\n-\t\t\t\t       gnu_result);\n+  if (prefix_unused\n+      && TREE_SIDE_EFFECTS (gnu_prefix)\n+      && !Is_Entity_Name (gnat_prefix))\n+    gnu_result\n+      = build_compound_expr  (TREE_TYPE (gnu_result), gnu_prefix, gnu_result);\n \n   *gnu_result_type_p = gnu_result_type;\n   return gnu_result;"}, {"sha": "1e9450548cbd196d7280691790877d9c9374a564", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088d3b0fc3d97093c3e9c8a9313be2010f55af54/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088d3b0fc3d97093c3e9c8a9313be2010f55af54/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=088d3b0fc3d97093c3e9c8a9313be2010f55af54", "patch": "@@ -1,3 +1,7 @@\n+2013-09-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t*  gnat.dg/array_bounds_test2.adb: New test.\n+\n 2013-09-18  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* g++.dg/debug/dwarf2/omp-fesdr.C: Check for fopenmp effective target."}, {"sha": "43e1ed3ced0c334b8946097bc94f94654faf4f6e", "filename": "gcc/testsuite/gnat.dg/array_bounds_test2.adb", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088d3b0fc3d97093c3e9c8a9313be2010f55af54/gcc%2Ftestsuite%2Fgnat.dg%2Farray_bounds_test2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088d3b0fc3d97093c3e9c8a9313be2010f55af54/gcc%2Ftestsuite%2Fgnat.dg%2Farray_bounds_test2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray_bounds_test2.adb?ref=088d3b0fc3d97093c3e9c8a9313be2010f55af54", "patch": "@@ -0,0 +1,25 @@\n+--  { dg-do run }\n+\n+with Ada.Unchecked_Deallocation;\n+\n+procedure Array_Bounds_Test2 is\n+\n+  type String_Ptr_T is access String;\n+  procedure Free is new Ada.Unchecked_Deallocation (String, String_Ptr_T);\n+  String_Data : String_Ptr_T := new String'(\"Hello World\");\n+\n+  function Peek return String_Ptr_T is\n+  begin\n+    return String_Data;\n+  end Peek;\n+\n+begin\n+  declare\n+    Corrupted_String : String := Peek.all;\n+  begin\n+    Free(String_Data);\n+    if Corrupted_String'First /= 1 then\n+      raise Program_Error;\n+    end if;\n+  end;\n+end;"}]}