{"sha": "3b2249aa1bb3f0240d45130a185c477c4530dc5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IyMjQ5YWExYmIzZjAyNDBkNDUxMzBhMTg1YzQ3N2M0NTMwZGM1YQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-04-27T12:18:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T12:18:31Z"}, "message": "exp_ch9.adb (Expand_Entry_Barrier): Code cleanup.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch9.adb (Expand_Entry_Barrier): Code\n\tcleanup. Do not perform the optimization which removes the\n\tdeclarations of the discriminant and component renamings when\n\tvalidity checks on operands and attributes are in effect.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_spark.adb, exp_util.adb, sem_ch7.adb, g-dyntab.adb, g-dyntab.ads,\n\tfreeze.adb, a-cfinve.ads, a-cofuma.adb, a-cofuma.ads, a-cfhama.adb,\n\ta-cfhama.ads, a-cofove.ads: Minor reformatting.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* g-debpoo.adb (Dump_Gnatmem): Protect against a possible null\n\tpointer dereference.\n\t* g-spipat.adb (Dump): Code clean up. Protect against a possible\n\tnull pointer dereference.\n\nFrom-SVN: r247326", "tree": {"sha": "6c325a5af15dc82cc88d5b982f068db66259d963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c325a5af15dc82cc88d5b982f068db66259d963"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b2249aa1bb3f0240d45130a185c477c4530dc5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2249aa1bb3f0240d45130a185c477c4530dc5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b2249aa1bb3f0240d45130a185c477c4530dc5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2249aa1bb3f0240d45130a185c477c4530dc5a/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3ef4e650e37bb768468d18d7c0f0b45298c3452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ef4e650e37bb768468d18d7c0f0b45298c3452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3ef4e650e37bb768468d18d7c0f0b45298c3452"}], "stats": {"total": 715, "additions": 391, "deletions": 324}, "files": [{"sha": "44c6ed5c62781d6a15a7c77b1e1fb4e3ba17edf3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -1,3 +1,23 @@\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch9.adb (Expand_Entry_Barrier): Code\n+\tcleanup. Do not perform the optimization which removes the\n+\tdeclarations of the discriminant and component renamings when\n+\tvalidity checks on operands and attributes are in effect.\n+\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_spark.adb, exp_util.adb, sem_ch7.adb, g-dyntab.adb, g-dyntab.ads,\n+\tfreeze.adb, a-cfinve.ads, a-cofuma.adb, a-cofuma.ads, a-cfhama.adb,\n+\ta-cfhama.ads, a-cofove.ads: Minor reformatting.\n+\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* g-debpoo.adb (Dump_Gnatmem): Protect against a possible null\n+\tpointer dereference.\n+\t* g-spipat.adb (Dump): Code clean up. Protect against a possible\n+\tnull pointer dereference.\n+\n 2017-04-27  Bob Duff  <duff@adacore.com>\n \n \t* g-dyntab.ads, g-dyntab.adb: Default for Table_Low_Bound."}, {"sha": "526a556ad1201853c43e2186de09973228a89ede", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -38,7 +38,6 @@ with System; use type System.Address;\n package body Ada.Containers.Formal_Hashed_Maps with\n   SPARK_Mode => Off\n is\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -112,8 +111,10 @@ is\n       begin\n          Node := Left.First.Node;\n          while Node /= 0 loop\n-            ENode := Find (Container => Right,\n-                           Key       => Left.Nodes (Node).Key).Node;\n+            ENode :=\n+              Find\n+                (Container => Right,\n+                 Key       => Left.Nodes (Node).Key).Node;\n \n             if ENode = 0 or else\n               Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n@@ -202,11 +203,11 @@ is\n       Capacity : Count_Type := 0) return Map\n    is\n       C      : constant Count_Type :=\n-        Count_Type'Max (Capacity, Source.Capacity);\n+                 Count_Type'Max (Capacity, Source.Capacity);\n+      Cu     : Cursor;\n       H      : Hash_Type;\n       N      : Count_Type;\n       Target : Map (C, Source.Modulus);\n-      Cu     : Cursor;\n \n    begin\n       if 0 < Capacity and then Capacity < Source.Capacity then\n@@ -300,8 +301,8 @@ is\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position),\n-                     \"bad cursor in function Element\");\n+      pragma Assert\n+        (Vet (Container, Position), \"bad cursor in function Element\");\n \n       return Container.Nodes (Position.Node).Element;\n    end Element;\n@@ -429,9 +430,12 @@ is\n          --  for their postconditions.\n \n          while Position /= 0 loop\n-            R := M.Add (Container => R,\n-                        New_Key   => Container.Nodes (Position).Key,\n-                        New_Item  => Container.Nodes (Position).Element);\n+            R :=\n+              M.Add\n+                (Container => R,\n+                 New_Key   => Container.Nodes (Position).Key,\n+                 New_Item  => Container.Nodes (Position).Element);\n+\n             Position := HT_Ops.Next (Container, Position);\n          end loop;\n \n@@ -478,7 +482,6 @@ is\n    ----------------------\n \n    procedure Generic_Allocate (HT : in out Map; Node : out Count_Type) is\n-\n       procedure Allocate is\n         new HT_Ops.Generic_Allocate (Set_Element);\n \n@@ -600,8 +603,7 @@ is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error with\n-           \"attempt to insert key already in map\";\n+         raise Constraint_Error with \"attempt to insert key already in map\";\n       end if;\n    end Insert;\n \n@@ -647,8 +649,9 @@ is\n      (Target : in out Map;\n       Source : in out Map)\n    is\n-      NN   : HT_Types.Nodes_Type renames Source.Nodes;\n-      X, Y : Count_Type;\n+      NN : HT_Types.Nodes_Type renames Source.Nodes;\n+      X  : Count_Type;\n+      Y  : Count_Type;\n \n    begin\n       if Target'Address = Source'Address then\n@@ -695,8 +698,7 @@ is\n       end if;\n \n       if not Has_Element (Container, Position) then\n-         raise Constraint_Error\n-           with \"Position has no element\";\n+         raise Constraint_Error with \"Position has no element\";\n       end if;\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in function Next\");\n@@ -731,8 +733,7 @@ is\n \n    begin\n       if Node = 0 then\n-         raise Constraint_Error with\n-           \"attempt to replace key not in map\";\n+         raise Constraint_Error with \"attempt to replace key not in map\";\n       end if;\n \n       declare\n@@ -758,8 +759,8 @@ is\n            \"Position cursor of Replace_Element has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position),\n-                     \"bad cursor in Replace_Element\");\n+      pragma Assert\n+        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n \n       Container.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n@@ -821,8 +822,9 @@ is\n             return False;\n          end if;\n \n-         X := Container.Buckets\n-           (Key_Ops.Index (Container, Container.Nodes (Position.Node).Key));\n+         X :=\n+           Container.Buckets\n+             (Key_Ops.Index (Container, Container.Nodes (Position.Node).Key));\n \n          for J in 1 .. Container.Length loop\n             if X = Position.Node then"}, {"sha": "452e5eeb322b2b0e8a1de0569fa0468e0710e50d", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -177,18 +177,16 @@ is\n \n             --  It contains all the keys contained in Model\n \n-            and\n-              (for all Key of Model (Container) =>\n-                (for some L of Keys'Result => Equivalent_Keys (L, Key)))\n+            and (for all Key of Model (Container) =>\n+                  (for some L of Keys'Result => Equivalent_Keys (L, Key)))\n \n             --  It has no duplicate\n \n-            and\n-              (for all I in 1 .. Length (Container) =>\n-                (for all J in 1 .. Length (Container) =>\n-                  (if Equivalent_Keys\n-                        (K.Get (Keys'Result, I), K.Get (Keys'Result, J))\n-                   then I = J)));\n+            and (for all I in 1 .. Length (Container) =>\n+                  (for all J in 1 .. Length (Container) =>\n+                    (if Equivalent_Keys\n+                          (K.Get (Keys'Result, I), K.Get (Keys'Result, J))\n+                     then I = J)));\n       pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n \n       function Positions (Container : Map) return P.Map with\n@@ -242,6 +240,7 @@ is\n          K : Key_Type) return Element_Type renames M.Get;\n       --  To improve readability of contracts, we rename the function used to\n       --  access an element in the model to Element.\n+\n    end Formal_Model;\n    use Formal_Model;\n \n@@ -278,9 +277,8 @@ is\n \n          --  Actual keys are preserved\n \n-         and\n-           (for all Key of Keys (Source) =>\n-              Formal_Hashed_Maps.Key (Target, Find (Target, Key)) = Key);\n+         and (for all Key of Keys (Source) =>\n+               Formal_Hashed_Maps.Key (Target, Find (Target, Key)) = Key);\n \n    function Copy\n      (Source   : Map;\n@@ -296,8 +294,8 @@ is\n                  Copy'Result.Capacity = Source.Capacity\n               else\n                  Copy'Result.Capacity = Capacity);\n-   --  Copy returns a container stricty equal to Source. It must have\n-   --  the same cursors associated with each element. Therefore:\n+   --  Copy returns a container stricty equal to Source. It must have the same\n+   --  cursors associated with each element. Therefore:\n    --  - capacity=0 means use Source.Capacity as capacity of target\n    --  - the modulus cannot be changed.\n \n@@ -356,9 +354,8 @@ is\n \n          --  Actual keys are preserved\n \n-         and\n-           (for all Key of Keys (Source)'Old =>\n-              Formal_Hashed_Maps.Key (Target, Find (Target, Key)) = Key);\n+         and (for all Key of Keys (Source)'Old =>\n+               Formal_Hashed_Maps.Key (Target, Find (Target, Key)) = Key);\n \n    procedure Insert\n      (Container : in out Map;\n@@ -477,9 +474,9 @@ is\n \n             --  The key equivalent to Key in Container is replaced by Key\n \n-            and K.Get (Keys (Container),\n-                       P.Get (Positions (Container), Find (Container, Key))) =\n-                Key\n+            and K.Get\n+                  (Keys (Container),\n+                   P.Get (Positions (Container), Find (Container, Key))) = Key\n             and K.Equal_Except\n                   (Keys (Container)'Old,\n                    Keys (Container),\n@@ -533,12 +530,13 @@ is\n \n          --  The key equivalent to Key in Container is replaced by Key\n \n-         and K.Get (Keys (Container),\n-                    P.Get (Positions (Container), Find (Container, Key))) = Key\n+         and K.Get\n+               (Keys (Container),\n+                P.Get (Positions (Container), Find (Container, Key))) = Key\n          and K.Equal_Except\n-              (Keys (Container)'Old,\n-               Keys (Container),\n-               P.Get (Positions (Container), Find (Container, Key)))\n+               (Keys (Container)'Old,\n+                Keys (Container),\n+                P.Get (Positions (Container), Find (Container, Key)))\n \n          --  New_Item is now associated with the Key in Container\n "}, {"sha": "98dcea1b37a44f5a40e8f01f34ed2055601965d1", "filename": "gcc/ada/a-cfinve.ads", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.ads?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -58,19 +58,22 @@ is\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    subtype Extended_Index is Index_Type'Base\n-   range Index_Type'First - 1 ..\n-     Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n+     range Index_Type'First - 1 ..\n+           Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n \n    Last_Count : constant Count_Type :=\n-     (if Index_Type'Last < Index_Type'First then 0\n+     (if Index_Type'Last < Index_Type'First then\n+         0\n       elsif Index_Type'Last < -1\n         or else Index_Type'Pos (Index_Type'First) >\n-          Index_Type'Pos (Index_Type'Last) - Count_Type'Last\n-      then Index_Type'Pos (Index_Type'Last) -\n-          Index_Type'Pos (Index_Type'First) + 1\n-      else Count_Type'Last);\n+                Index_Type'Pos (Index_Type'Last) - Count_Type'Last\n+      then\n+         Index_Type'Pos (Index_Type'Last) -\n+           Index_Type'Pos (Index_Type'First) + 1\n+      else\n+         Count_Type'Last);\n    --  Maximal capacity of any vector. It is the minimum of the size of the\n    --  index range and the last possible Count_Type.\n "}, {"sha": "d9b68d0a304c7a4c38bad113e524d30dcc474d08", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -52,19 +52,22 @@ is\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    subtype Extended_Index is Index_Type'Base\n-   range Index_Type'First - 1 ..\n-     Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n+     range Index_Type'First - 1 ..\n+           Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n \n    Last_Count : constant Count_Type :=\n-     (if Index_Type'Last < Index_Type'First then 0\n+     (if Index_Type'Last < Index_Type'First then\n+         0\n       elsif Index_Type'Last < -1\n         or else Index_Type'Pos (Index_Type'First) >\n-          Index_Type'Pos (Index_Type'Last) - Count_Type'Last\n-      then Index_Type'Pos (Index_Type'Last) -\n-          Index_Type'Pos (Index_Type'First) + 1\n-      else Count_Type'Last);\n+                Index_Type'Pos (Index_Type'Last) - Count_Type'Last\n+      then\n+         Index_Type'Pos (Index_Type'Last) -\n+           Index_Type'Pos (Index_Type'First) + 1\n+      else\n+         Count_Type'Last);\n    --  Maximal capacity of any vector. It is the minimum of the size of the\n    --  index range and the last possible Count_Type.\n "}, {"sha": "2e30089d77eee0e5ef09b3857db9886fc96c79ae", "filename": "gcc/ada/a-cofuma.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -95,8 +95,8 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n             if not Equivalent_Keys (K, New_Key)\n               and then\n                 (Find (Right.Keys, K) = 0\n-                   or else Get (Right.Elements, Find (Right.Keys, K)) /=\n-                           Get (Left.Elements, I))\n+                  or else Get (Right.Elements, Find (Right.Keys, K)) /=\n+                          Get (Left.Elements, I))\n             then\n                return False;\n             end if;\n@@ -120,8 +120,8 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n               and then not Equivalent_Keys (K, Y)\n               and then\n                 (Find (Right.Keys, K) = 0\n-                   or else Get (Right.Elements, Find (Right.Keys, K)) /=\n-                           Get (Left.Elements, I))\n+                  or else Get (Right.Elements, Find (Right.Keys, K)) /=\n+                          Get (Left.Elements, I))\n             then\n                return False;\n             end if;"}, {"sha": "2d8a2045cf704fa676d71e4a61f0b1678e2ec61c", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -88,7 +88,7 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Post   =>\n        Has_Key (Container, Left) = Has_Key (Container, Right)\n          and (if Has_Key (Container, Left) then\n-                Get (Container, Left) = Get (Container, Right));\n+                 Get (Container, Left) = Get (Container, Right));\n \n    ------------------------\n    -- Property Functions --\n@@ -101,7 +101,7 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Post   =>\n        \"<=\"'Result =\n          (for all Key of Left =>\n-            Has_Key (Right, Key) and then Get (Right, Key) = Get (Left, Key));\n+           Has_Key (Right, Key) and then Get (Right, Key) = Get (Left, Key));\n \n    function \"=\" (Left : Map; Right : Map) return Boolean with\n    --  Extensional equality over maps\n@@ -110,9 +110,9 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Post   =>\n        \"=\"'Result =\n          ((for all Key of Left =>\n-             Has_Key (Right, Key)\n-               and then Get (Right, Key) = Get (Left, Key))\n-               and (for all Key of Right => Has_Key (Left, Key)));\n+            Has_Key (Right, Key)\n+              and then Get (Right, Key) = Get (Left, Key))\n+              and (for all Key of Right => Has_Key (Left, Key)));\n \n    pragma Warnings (Off, \"unused variable \"\"Key\"\"\");\n    function Is_Empty (Container : Map) return Boolean with"}, {"sha": "b79a41b1099b98a62242fd30d98892b73fdc1c24", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -63,6 +63,7 @@ with Stand;    use Stand;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n+with Validsw;  use Validsw;\n \n package body Exp_Ch9 is\n \n@@ -5927,13 +5928,12 @@ package body Exp_Ch9 is\n    --------------------------\n \n    procedure Expand_Entry_Barrier (N : Node_Id; Ent : Entity_Id) is\n-      Cond      : constant Node_Id   :=\n-                    Condition (Entry_Body_Formal_Part (N));\n+      Cond      : constant Node_Id   := Condition (Entry_Body_Formal_Part (N));\n       Prot      : constant Entity_Id := Scope (Ent);\n       Spec_Decl : constant Node_Id   := Parent (Prot);\n-      Func      : Entity_Id          := Empty;\n-      B_F       : Node_Id;\n-      Body_Decl : Node_Id;\n+\n+      Func_Id : Entity_Id := Empty;\n+      --  The entity of the barrier function\n \n       function Is_Global_Entity (N : Node_Id) return Traverse_Result;\n       --  Check whether entity in Barrier is external to protected type.\n@@ -5966,7 +5966,7 @@ package body Exp_Ch9 is\n                --  during expansion, it is ok. If expansion is not performed,\n                --  then Func is Empty so this test cannot succeed.\n \n-               if Scope (E) = Func then\n+               if Scope (E) = Func_Id then\n                   null;\n \n                --  A protected call from a barrier to another object is ok\n@@ -6112,6 +6112,12 @@ package body Exp_Ch9 is\n \n       function Check_Pure_Barriers is new Traverse_Func (Is_Pure_Barrier);\n \n+      --  Local variables\n+\n+      Cond_Id    : Entity_Id;\n+      Entry_Body : Node_Id;\n+      Func_Body  : Node_Id;\n+\n    --  Start of processing for Expand_Entry_Barrier\n \n    begin\n@@ -6130,20 +6136,20 @@ package body Exp_Ch9 is\n       --  version of it because it is never called.\n \n       if Expander_Active then\n-         B_F  := Build_Barrier_Function (N, Ent, Prot);\n-         Func := Barrier_Function (Ent);\n-         Set_Corresponding_Spec (B_F, Func);\n+         Func_Body := Build_Barrier_Function (N, Ent, Prot);\n+         Func_Id   := Barrier_Function (Ent);\n+         Set_Corresponding_Spec (Func_Body, Func_Id);\n \n-         Body_Decl := Parent (Corresponding_Body (Spec_Decl));\n+         Entry_Body := Parent (Corresponding_Body (Spec_Decl));\n \n-         if Nkind (Parent (Body_Decl)) = N_Subunit then\n-            Body_Decl := Corresponding_Stub (Parent (Body_Decl));\n+         if Nkind (Parent (Entry_Body)) = N_Subunit then\n+            Entry_Body := Corresponding_Stub (Parent (Entry_Body));\n          end if;\n \n-         Insert_Before_And_Analyze (Body_Decl, B_F);\n+         Insert_Before_And_Analyze (Entry_Body, Func_Body);\n \n          Set_Discriminals (Spec_Decl);\n-         Set_Scope (Func, Scope (Prot));\n+         Set_Scope (Func_Id, Scope (Prot));\n \n       else\n          Analyze_And_Resolve (Cond, Any_Boolean);\n@@ -6167,20 +6173,25 @@ package body Exp_Ch9 is\n       --  scope.\n \n       if Is_Entity_Name (Cond) then\n-\n-         --  A small optimization of useless renamings. If the scope of the\n-         --  entity of the condition is not the barrier function, then the\n-         --  condition does not reference any of the generated renamings\n-         --  within the function.\n-\n-         if Expander_Active and then Scope (Entity (Cond)) /= Func then\n-            Set_Declarations (B_F, Empty_List);\n+         Cond_Id := Entity (Cond);\n+\n+         --  Perform a small optimization of simple barrier functions. If the\n+         --  scope of the condition's entity is not the barrier function, then\n+         --  the condition does not depend on any of the generated renamings.\n+         --  If this is the case, eliminate the renamings as they are useless.\n+         --  This optimization is not performed when the condition was folded\n+         --  and validity checks are in effect because the original condition\n+         --  may have produced at least one check that depends on the generated\n+         --  renamings.\n+\n+         if Expander_Active\n+           and then Scope (Cond_Id) /= Func_Id\n+           and then not Validity_Check_Operands\n+         then\n+            Set_Declarations (Func_Body, Empty_List);\n          end if;\n \n-         if Entity (Cond) = Standard_False\n-              or else\n-            Entity (Cond) = Standard_True\n-         then\n+         if Cond_Id = Standard_False or else Cond_Id = Standard_True then\n             return;\n \n          elsif Is_Simple_Barrier_Name (Cond) then"}, {"sha": "7062e1373a007b4fefee1e59bfcb0118fac8f927", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -251,9 +251,7 @@ package body Exp_SPARK is\n       --  specialized to the descendant type, hence build a separate DIC\n       --  procedure for it as done during regular expansion for compilation.\n \n-      if Has_DIC (E)\n-        and then Is_Tagged_Type (E)\n-      then\n+      if Has_DIC (E) and then Is_Tagged_Type (E) then\n          Build_DIC_Procedure_Body (E, For_Freeze => True);\n       end if;\n    end Expand_SPARK_Freeze_Type;"}, {"sha": "2c23841f465c5968af08bad4e495ffd3b748b7b5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -1132,17 +1132,16 @@ package body Exp_Util is\n                if not Is_Abstract_Subprogram (Subp)\n                  and then Is_Abstract_Subprogram (Entity (N))\n                then\n-                  Error_Msg_Sloc := Sloc (Current_Scope);\n-                  --  Error_Msg_Node_1 := Entity (N);\n+                  Error_Msg_Sloc   := Sloc (Current_Scope);\n                   Error_Msg_Node_2 := Subp;\n                   if Comes_From_Source (Subp) then\n                      Error_Msg_NE\n-                       (\"cannot call abstract subprogram& in inherited \"\n-                         & \"condition for&#\", Subp, Entity (N));\n+                       (\"cannot call abstract subprogram & in inherited \"\n+                        & \"condition for&#\", Subp, Entity (N));\n                   else\n                      Error_Msg_NE\n-                       (\"cannot call abstract subprogram& in inherited \"\n-                         & \"condition for inherited&#\", Subp, Entity (N));\n+                       (\"cannot call abstract subprogram & in inherited \"\n+                        & \"condition for inherited&#\", Subp, Entity (N));\n                   end if;\n \n                --  In SPARK mode, reject an inherited condition for an"}, {"sha": "d18d3d40bd5ebe603d28f7ca3cb3f84c5c0dd417", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -1406,10 +1406,6 @@ package body Freeze is\n       Par_Prim      : Entity_Id;\n       Prim          : Entity_Id;\n \n-      ---------------------------------------\n-      -- Build_Inherited_Condition_Pragmas --\n-      ---------------------------------------\n-\n       procedure Build_Inherited_Condition_Pragmas (Subp : Entity_Id);\n       --  Build corresponding pragmas for an operation whose ancestor has\n       --  class-wide pre/postconditions. If the operation is inherited, the\n@@ -1418,6 +1414,10 @@ package body Freeze is\n       --  to verify their legality, in case they contain calls to other\n       --  primitives that may haven been overridden.\n \n+      ---------------------------------------\n+      -- Build_Inherited_Condition_Pragmas --\n+      ---------------------------------------\n+\n       procedure Build_Inherited_Condition_Pragmas (Subp : Entity_Id) is\n          A_Post   : Node_Id;\n          A_Pre    : Node_Id;\n@@ -1462,6 +1462,8 @@ package body Freeze is\n          end if;\n       end Build_Inherited_Condition_Pragmas;\n \n+   --  Start of processing for Check_Inherited_Conditions\n+\n    begin\n       Op_Node := First_Elmt (Prim_Ops);\n       while Present (Op_Node) loop\n@@ -1480,13 +1482,14 @@ package body Freeze is\n          Next_Elmt (Op_Node);\n       end loop;\n \n-      --  Now perform validity checks on the inherited conditions of\n-      --  overriding operations, for conformance with LSP, and apply\n-      --  SPARK-specific restrictions on inherited conditions.\n+      --  Perform validity checks on the inherited conditions of overriding\n+      --  operations, for conformance with LSP, and apply SPARK-specific\n+      --  restrictions on inherited conditions.\n \n       Op_Node := First_Elmt (Prim_Ops);\n       while Present (Op_Node) loop\n          Prim := Node (Op_Node);\n+\n          if Present (Overridden_Operation (Prim))\n            and then Comes_From_Source (Prim)\n          then\n@@ -1505,11 +1508,10 @@ package body Freeze is\n             if SPARK_Mode = On then\n                Collect_Inherited_Class_Wide_Conditions (Prim);\n \n-            else\n-\n-               --  Build the corresponding pragmas to check for legality\n-               --  of the inherited condition.\n+            --  Otherwise build the corresponding pragmas to check for legality\n+            --  of the inherited condition.\n \n+            else\n                Build_Inherited_Condition_Pragmas (Prim);\n             end if;\n          end if;\n@@ -1541,10 +1543,10 @@ package body Freeze is\n             Build_Inherited_Condition_Pragmas (Prim);\n          end if;\n \n-         if Needs_Wrapper and then not Is_Abstract_Subprogram (Par_Prim)\n+         if Needs_Wrapper\n+           and then not Is_Abstract_Subprogram (Par_Prim)\n            and then Expander_Active\n          then\n-\n             --  We need to build a new primitive that overrides the inherited\n             --  one, and whose inherited expression has been updated above.\n             --  These expressions are the arguments of pragmas that are part"}, {"sha": "fe2debd09d35fc9e65f3813e743cb329eb63e7db", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -401,7 +401,7 @@ package body GNAT.Debug_Pools is\n    ---------------\n \n    function Header_Of (Address : System.Address)\n-      return Allocation_Header_Access\n+     return Allocation_Header_Access\n    is\n       function Convert is new Ada.Unchecked_Conversion\n         (System.Address, Allocation_Header_Access);\n@@ -2293,8 +2293,12 @@ package body GNAT.Debug_Pools is\n    begin\n       File := fopen (File_Name & ASCII.NUL, \"wb\" & ASCII.NUL);\n       fwrite (\"GMEM DUMP\" & ASCII.LF, 10, 1, File);\n-      fwrite (Dummy_Time'Address, Duration'Max_Size_In_Storage_Elements, 1,\n-              File);\n+\n+      fwrite\n+        (Ptr    => Dummy_Time'Address,\n+         Size   => Duration'Max_Size_In_Storage_Elements,\n+         Nmemb  => 1,\n+         Stream => File);\n \n       --  List of not deallocated blocks (see Print_Info)\n \n@@ -2303,9 +2307,9 @@ package body GNAT.Debug_Pools is\n          Header := Header_Of (Current);\n \n          Actual_Size := size_t (Header.Block_Size);\n-         Tracebk := Header.Alloc_Traceback.Traceback;\n \n          if Header.Alloc_Traceback /= null then\n+            Tracebk   := Header.Alloc_Traceback.Traceback;\n             Num_Calls := Tracebk'Length;\n \n             --  (Code taken from memtrack.adb in GNAT's sources)\n@@ -2316,12 +2320,24 @@ package body GNAT.Debug_Pools is\n \n             fputc (Character'Pos ('A'), File);\n             fwrite (Current'Address, Address_Size, 1, File);\n-            fwrite (Actual_Size'Address, size_t'Max_Size_In_Storage_Elements,\n-                    1, File);\n-            fwrite (Dummy_Time'Address, Duration'Max_Size_In_Storage_Elements,\n-                    1, File);\n-            fwrite (Num_Calls'Address, Integer'Max_Size_In_Storage_Elements, 1,\n-                    File);\n+\n+            fwrite\n+              (Ptr    => Actual_Size'Address,\n+               Size   => size_t'Max_Size_In_Storage_Elements,\n+               Nmemb  => 1,\n+               Stream => File);\n+\n+            fwrite\n+              (Ptr    => Dummy_Time'Address,\n+               Size   => Duration'Max_Size_In_Storage_Elements,\n+               Nmemb  => 1,\n+               Stream => File);\n+\n+            fwrite\n+              (Ptr    => Num_Calls'Address,\n+               Size   => Integer'Max_Size_In_Storage_Elements,\n+               Nmemb  => 1,\n+               Stream => File);\n \n             for J in Tracebk'First .. Tracebk'First + Num_Calls - 1 loop\n                declare\n@@ -2330,7 +2346,6 @@ package body GNAT.Debug_Pools is\n                   fwrite (Ptr'Address, Address_Size, 1, File);\n                end;\n             end loop;\n-\n          end if;\n \n          Current := Header.Next;"}, {"sha": "eff48cbdd8f0012d3a0e54bc76f2cbb7f6a1bcd9", "filename": "gcc/ada/g-dyntab.adb", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -284,18 +284,24 @@ package body GNAT.Dynamic_Tables is\n       --  Last, but if Release_Threshold /= 0, then we need to take that into\n       --  account.\n \n+      ------------------------\n+      -- New_Last_Allocated --\n+      ------------------------\n+\n       function New_Last_Allocated return Table_Last_Type is\n          subtype Table_Length_Type is Table_Index_Type'Base\n            range 0 .. Table_Index_Type'Base'Last;\n+\n          Length : constant Table_Length_Type := T.P.Last - First + 1;\n+\n          Comp_Size_In_Bytes : constant Table_Length_Type :=\n            Table_Type'Component_Size / System.Storage_Unit;\n+\n          Length_Threshold : constant Table_Length_Type :=\n            Table_Length_Type (Release_Threshold) / Comp_Size_In_Bytes;\n+\n       begin\n-         if Release_Threshold = 0\n-           or else Length < Length_Threshold\n-         then\n+         if Release_Threshold = 0 or else Length < Length_Threshold then\n             return T.P.Last;\n          else\n             declare\n@@ -306,6 +312,8 @@ package body GNAT.Dynamic_Tables is\n          end if;\n       end New_Last_Allocated;\n \n+      --  Local variables\n+\n       New_Last_Alloc : constant Table_Last_Type := New_Last_Allocated;\n \n    --  Start of processing for Release\n@@ -324,15 +332,15 @@ package body GNAT.Dynamic_Tables is\n             function To_Old_Alloc_Ptr is\n               new Ada.Unchecked_Conversion (Table_Ptr, Old_Alloc_Ptr);\n \n-            subtype Alloc_Type is\n-              Table_Type (First .. New_Last_Alloc);\n+            subtype Alloc_Type is Table_Type (First .. New_Last_Alloc);\n             type Alloc_Ptr is access all Alloc_Type;\n \n             function To_Table_Ptr is\n-               new Ada.Unchecked_Conversion (Alloc_Ptr, Table_Ptr);\n+              new Ada.Unchecked_Conversion (Alloc_Ptr, Table_Ptr);\n \n             Old_Table : Old_Alloc_Ptr := To_Old_Alloc_Ptr (T.Table);\n             New_Table : constant Alloc_Ptr := new Alloc_Type;\n+\n          begin\n             New_Table (Alloc_Type'Range) := Old_Table (Alloc_Type'Range);\n             T.P.Last_Allocated := New_Last_Alloc;\n@@ -353,6 +361,7 @@ package body GNAT.Dynamic_Tables is\n    is\n       pragma Assert (not T.Locked);\n       Item_Copy : constant Table_Component_Type := Item;\n+\n    begin\n       --  If Set_Last is going to reallocate the table, we make a copy of Item,\n       --  in case the call was \"Set_Item (T, X, T.Table (Y));\", and Item is"}, {"sha": "a1e9507a6d44256a2f53af5346d6a828fc4ac0fd", "filename": "gcc/ada/g-dyntab.ads", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fg-dyntab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fg-dyntab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.ads?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -69,12 +69,12 @@ package GNAT.Dynamic_Tables is\n \n    --  Table_Component_Type must not be a type with controlled parts.\n \n-   --  The Table_Initial value controls the allocation of the table when\n-   --  it is first allocated.\n+   --  The Table_Initial value controls the allocation of the table when it is\n+   --  first allocated.\n \n-   --  The Table_Increment value controls the amount of increase, if the\n-   --  table has to be increased in size. The value given is a percentage\n-   --  value (e.g. 100 = increase table size by 100%, i.e. double it).\n+   --  The Table_Increment value controls the amount of increase, if the table\n+   --  has to be increased in size. The value given is a percentage value (e.g.\n+   --  100 = increase table size by 100%, i.e. double it).\n \n    --  The Last and Set_Last subprograms provide control over the current\n    --  logical allocation. They are quite efficient, so they can be used\n@@ -85,18 +85,18 @@ package GNAT.Dynamic_Tables is\n    --  restrict the use of table for discriminated types. If it is necessary\n    --  to take the access of a table element, use Unrestricted_Access.\n \n-   --  WARNING: On HPPA, the virtual addressing approach used in this unit\n-   --  is incompatible with the indexing instructions on the HPPA. So when\n-   --  using this unit, compile your application with -mdisable-indexing.\n+   --  WARNING: On HPPA, the virtual addressing approach used in this unit is\n+   --  incompatible with the indexing instructions on the HPPA. So when using\n+   --  this unit, compile your application with -mdisable-indexing.\n \n    --  WARNING: If the table is reallocated, then the address of all its\n    --  components will change. So do not capture the address of an element\n-   --  and then use the address later after the table may be reallocated.\n-   --  One tricky case of this is passing an element of the table to a\n-   --  subprogram by reference where the table gets reallocated during\n-   --  the execution of the subprogram. The best rule to follow is never\n-   --  to pass a table element as a parameter except for the case of IN\n-   --  mode parameters with scalar values.\n+   --  and then use the address later after the table may be reallocated. One\n+   --  tricky case of this is passing an element of the table to a subprogram\n+   --  by reference where the table gets reallocated during the execution of\n+   --  the subprogram. The best rule to follow is never to pass a table element\n+   --  as a parameter except for the case of IN mode parameters with scalar\n+   --  values.\n \n    pragma Assert (Table_Low_Bound /= Table_Index_Type'Base'First);\n \n@@ -107,12 +107,12 @@ package GNAT.Dynamic_Tables is\n \n    --  Table_Component_Type must not be a type with controlled parts.\n \n-   --  The Table_Initial value controls the allocation of the table when\n-   --  it is first allocated.\n+   --  The Table_Initial value controls the allocation of the table when it is\n+   --  first allocated.\n \n-   --  The Table_Increment value controls the amount of increase, if the\n-   --  table has to be increased in size. The value given is a percentage\n-   --  value (e.g. 100 = increase table size by 100%, i.e. double it).\n+   --  The Table_Increment value controls the amount of increase, if the table\n+   --  has to be increased in size. The value given is a percentage value (e.g.\n+   --  100 = increase table size by 100%, i.e. double it).\n \n    --  The Last and Set_Last subprograms provide control over the current\n    --  logical allocation. They are quite efficient, so they can be used\n@@ -201,9 +201,9 @@ package GNAT.Dynamic_Tables is\n \n    procedure Release (T : in out Instance);\n    --  Storage is allocated in chunks according to the values given in the\n-   --  Table_Initial and Table_Increment parameters. If Release_Threshold is 0\n-   --  or the length of the table does not exceed this threshold then a call to\n-   --  Release releases all storage that is allocated, but is not logically\n+   --  Table_Initial and Table_Increment parameters. If Release_Threshold is\n+   --  0 or the length of the table does not exceed this threshold then a call\n+   --  to Release releases all storage that is allocated, but is not logically\n    --  part of the current array value; otherwise the call to Release leaves\n    --  the current array value plus 0.1% of the current table length free\n    --  elements located at the end of the table. This parameter facilitates\n@@ -267,14 +267,14 @@ package GNAT.Dynamic_Tables is\n    generic\n      with function Lt (Comp1, Comp2 : Table_Component_Type) return Boolean;\n    procedure Sort_Table (Table : in out Instance);\n-   --  This procedure sorts the components of the table into ascending\n-   --  order making calls to Lt to do required comparisons, and using\n-   --  assignments to move components around. The Lt function returns True\n-   --  if Comp1 is less than Comp2 (in the sense of the desired sort), and\n-   --  False if Comp1 is greater than Comp2. For equal objects it does not\n-   --  matter if True or False is returned (it is slightly more efficient\n-   --  to return False). The sort is not stable (the order of equal items\n-   --  in the table is not preserved).\n+   --  This procedure sorts the components of the table into ascending order\n+   --  making calls to Lt to do required comparisons, and using assignments\n+   --  to move components around. The Lt function returns True if Comp1 is\n+   --  less than Comp2 (in the sense of the desired sort), and False if Comp1\n+   --  is greater than Comp2. For equal objects it does not matter if True or\n+   --  False is returned (it is slightly more efficient to return False). The\n+   --  sort is not stable (the order of equal items in the table is not\n+   --  preserved).\n \n private\n "}, {"sha": "194a3355c025f059b36350dafd63b338e351e573", "filename": "gcc/ada/g-spipat.adb", "status": "modified", "additions": 161, "deletions": 154, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fg-spipat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fg-spipat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2016, AdaCore                     --\n+--                     Copyright (C) 1998-2017, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2086,28 +2086,15 @@ package body GNAT.Spitbol.Patterns is\n    ----------\n \n    procedure Dump (P : Pattern) is\n-\n-      subtype Count is Ada.Text_IO.Count;\n-      Scol : Count;\n-      --  Used to keep track of column in dump output\n-\n-      Refs : Ref_Array (1 .. P.P.Index);\n-      --  We build a reference array whose N'th element points to the\n-      --  pattern element whose Index value is N.\n-\n-      Cols : Natural := 2;\n-      --  Number of columns used for pattern numbers, minimum is 2\n-\n-      E : PE_Ptr;\n-\n-      procedure Write_Node_Id (E : PE_Ptr);\n-      --  Writes out a string identifying the given pattern element\n+      procedure Write_Node_Id (E : PE_Ptr; Cols : Natural);\n+      --  Writes out a string identifying the given pattern element. Cols is\n+      --  the column indentation level.\n \n       -------------------\n       -- Write_Node_Id --\n       -------------------\n \n-      procedure Write_Node_Id (E : PE_Ptr) is\n+      procedure Write_Node_Id (E : PE_Ptr; Cols : Natural) is\n       begin\n          if E = EOP then\n             Put (\"EOP\");\n@@ -2134,16 +2121,29 @@ package body GNAT.Spitbol.Patterns is\n          end if;\n       end Write_Node_Id;\n \n+      --  Local variables\n+\n+      Cols : Natural := 2;\n+      --  Number of columns used for pattern numbers, minimum is 2\n+\n+      E : PE_Ptr;\n+\n+      subtype Count is Ada.Text_IO.Count;\n+      Scol : Count;\n+      --  Used to keep track of column in dump output\n+\n    --  Start of processing for Dump\n \n    begin\n       New_Line;\n-      Put (\"Pattern Dump Output (pattern at \" &\n-           Image (P'Address) &\n-           \", S = \" & Natural'Image (P.Stk) & ')');\n+      Put\n+        (\"Pattern Dump Output (pattern at \"\n+         & Image (P'Address)\n+         & \", S = \"\n+         & Natural'Image (P.Stk) & ')');\n+      New_Line;\n \n       Scol := Col;\n-      New_Line;\n \n       while Col < Scol loop\n          Put ('-');\n@@ -2165,144 +2165,151 @@ package body GNAT.Spitbol.Patterns is\n          return;\n       end if;\n \n-      Build_Ref_Array (P.P, Refs);\n-\n-      --  Set number of columns required for node numbers\n-\n-      while 10 ** Cols - 1 < Integer (P.P.Index) loop\n-         Cols := Cols + 1;\n-      end loop;\n-\n-      --  Now dump the nodes in reverse sequence. We output them in reverse\n-      --  sequence since this corresponds to the natural order used to\n-      --  construct the patterns.\n-\n-      for J in reverse Refs'Range loop\n-         E := Refs (J);\n-         Write_Node_Id (E);\n-         Set_Col (Count (Cols) + 4);\n-         Put (Image (E));\n-         Put (\"  \");\n-         Put (Pattern_Code'Image (E.Pcode));\n-         Put (\"  \");\n-         Set_Col (21 + Count (Cols) + Address_Image_Length);\n-         Write_Node_Id (E.Pthen);\n-         Set_Col (24 + 2 * Count (Cols) + Address_Image_Length);\n-\n-         case E.Pcode is\n-            when PC_Alt\n-               | PC_Arb_X\n-               | PC_Arbno_S\n-               | PC_Arbno_X\n-            =>\n-               Write_Node_Id (E.Alt);\n-\n-            when PC_Rpat =>\n-               Put (Str_PP (E.PP));\n-\n-            when PC_Pred_Func =>\n-               Put (Str_BF (E.BF));\n-\n-            when PC_Assign_Imm\n-               | PC_Assign_OnM\n-               | PC_Any_VP\n-               | PC_Break_VP\n-               | PC_BreakX_VP\n-               | PC_NotAny_VP\n-               | PC_NSpan_VP\n-               | PC_Span_VP\n-               | PC_String_VP\n-            =>\n-               Put (Str_VP (E.VP));\n-\n-            when PC_Write_Imm\n-               | PC_Write_OnM\n-            =>\n-               Put (Str_FP (E.FP));\n-\n-            when PC_String =>\n-               Put (Image (E.Str.all));\n-\n-            when PC_String_2 =>\n-               Put (Image (E.Str2));\n-\n-            when PC_String_3 =>\n-               Put (Image (E.Str3));\n-\n-            when PC_String_4 =>\n-               Put (Image (E.Str4));\n-\n-            when PC_String_5 =>\n-               Put (Image (E.Str5));\n-\n-            when PC_String_6 =>\n-               Put (Image (E.Str6));\n+      declare\n+         Refs : Ref_Array (1 .. P.P.Index);\n+         --  We build a reference array whose N'th element points to the\n+         --  pattern element whose Index value is N.\n \n-            when PC_Setcur =>\n-               Put (Str_NP (E.Var));\n-\n-            when PC_Any_CH\n-               | PC_Break_CH\n-               | PC_BreakX_CH\n-               | PC_Char\n-               | PC_NotAny_CH\n-               | PC_NSpan_CH\n-               | PC_Span_CH\n-            =>\n-               Put (''' & E.Char & ''');\n-\n-            when PC_Any_CS\n-               | PC_Break_CS\n-               | PC_BreakX_CS\n-               | PC_NotAny_CS\n-               | PC_NSpan_CS\n-               | PC_Span_CS\n-            =>\n-               Put ('\"' & To_Sequence (E.CS) & '\"');\n-\n-            when PC_Arbno_Y\n-               | PC_Len_Nat\n-               | PC_Pos_Nat\n-               | PC_RPos_Nat\n-               | PC_RTab_Nat\n-               | PC_Tab_Nat\n-            =>\n-               Put (S (E.Nat));\n+      begin\n+         Build_Ref_Array (P.P, Refs);\n \n-            when PC_Pos_NF\n-               | PC_Len_NF\n-               | PC_RPos_NF\n-               | PC_RTab_NF\n-               | PC_Tab_NF\n-            =>\n-               Put (Str_NF (E.NF));\n+         --  Set number of columns required for node numbers\n \n-            when PC_Pos_NP\n-               | PC_Len_NP\n-               | PC_RPos_NP\n-               | PC_RTab_NP\n-               | PC_Tab_NP\n-            =>\n-               Put (Str_NP (E.NP));\n-\n-            when PC_Any_VF\n-               | PC_Break_VF\n-               | PC_BreakX_VF\n-               | PC_NotAny_VF\n-               | PC_NSpan_VF\n-               | PC_Span_VF\n-               | PC_String_VF\n-            =>\n-               Put (Str_VF (E.VF));\n+         while 10 ** Cols - 1 < Integer (P.P.Index) loop\n+            Cols := Cols + 1;\n+         end loop;\n \n-            when others =>\n-               null;\n-         end case;\n+         --  Now dump the nodes in reverse sequence. We output them in reverse\n+         --  sequence since this corresponds to the natural order used to\n+         --  construct the patterns.\n+\n+         for J in reverse Refs'Range loop\n+            E := Refs (J);\n+            Write_Node_Id (E, Cols);\n+            Set_Col (Count (Cols) + 4);\n+            Put (Image (E));\n+            Put (\"  \");\n+            Put (Pattern_Code'Image (E.Pcode));\n+            Put (\"  \");\n+            Set_Col (21 + Count (Cols) + Address_Image_Length);\n+            Write_Node_Id (E.Pthen, Cols);\n+            Set_Col (24 + 2 * Count (Cols) + Address_Image_Length);\n+\n+            case E.Pcode is\n+               when PC_Alt\n+                  | PC_Arb_X\n+                  | PC_Arbno_S\n+                  | PC_Arbno_X\n+               =>\n+                  Write_Node_Id (E.Alt, Cols);\n+\n+               when PC_Rpat =>\n+                  Put (Str_PP (E.PP));\n+\n+               when PC_Pred_Func =>\n+                  Put (Str_BF (E.BF));\n+\n+               when PC_Assign_Imm\n+                  | PC_Assign_OnM\n+                  | PC_Any_VP\n+                  | PC_Break_VP\n+                  | PC_BreakX_VP\n+                  | PC_NotAny_VP\n+                  | PC_NSpan_VP\n+                  | PC_Span_VP\n+                  | PC_String_VP\n+               =>\n+                  Put (Str_VP (E.VP));\n+\n+               when PC_Write_Imm\n+                  | PC_Write_OnM\n+               =>\n+                  Put (Str_FP (E.FP));\n+\n+               when PC_String =>\n+                  Put (Image (E.Str.all));\n+\n+               when PC_String_2 =>\n+                  Put (Image (E.Str2));\n+\n+               when PC_String_3 =>\n+                  Put (Image (E.Str3));\n+\n+               when PC_String_4 =>\n+                  Put (Image (E.Str4));\n+\n+               when PC_String_5 =>\n+                  Put (Image (E.Str5));\n+\n+               when PC_String_6 =>\n+                  Put (Image (E.Str6));\n+\n+               when PC_Setcur =>\n+                  Put (Str_NP (E.Var));\n+\n+               when PC_Any_CH\n+                  | PC_Break_CH\n+                  | PC_BreakX_CH\n+                  | PC_Char\n+                  | PC_NotAny_CH\n+                  | PC_NSpan_CH\n+                  | PC_Span_CH\n+               =>\n+                  Put (''' & E.Char & ''');\n+\n+               when PC_Any_CS\n+                  | PC_Break_CS\n+                  | PC_BreakX_CS\n+                  | PC_NotAny_CS\n+                  | PC_NSpan_CS\n+                  | PC_Span_CS\n+               =>\n+                  Put ('\"' & To_Sequence (E.CS) & '\"');\n+\n+               when PC_Arbno_Y\n+                  | PC_Len_Nat\n+                  | PC_Pos_Nat\n+                  | PC_RPos_Nat\n+                  | PC_RTab_Nat\n+                  | PC_Tab_Nat\n+               =>\n+                  Put (S (E.Nat));\n+\n+               when PC_Pos_NF\n+                  | PC_Len_NF\n+                  | PC_RPos_NF\n+                  | PC_RTab_NF\n+                  | PC_Tab_NF\n+               =>\n+                  Put (Str_NF (E.NF));\n+\n+               when PC_Pos_NP\n+                  | PC_Len_NP\n+                  | PC_RPos_NP\n+                  | PC_RTab_NP\n+                  | PC_Tab_NP\n+               =>\n+                  Put (Str_NP (E.NP));\n+\n+               when PC_Any_VF\n+                  | PC_Break_VF\n+                  | PC_BreakX_VF\n+                  | PC_NotAny_VF\n+                  | PC_NSpan_VF\n+                  | PC_Span_VF\n+                  | PC_String_VF\n+               =>\n+                  Put (Str_VF (E.VF));\n+\n+               when others =>\n+                  null;\n+            end case;\n+\n+            New_Line;\n+         end loop;\n \n          New_Line;\n-      end loop;\n-\n-      New_Line;\n+      end;\n    end Dump;\n \n    ----------"}, {"sha": "266395af6589b44a736adeaf0fe6690f0dcedd61", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2249aa1bb3f0240d45130a185c477c4530dc5a/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=3b2249aa1bb3f0240d45130a185c477c4530dc5a", "patch": "@@ -983,9 +983,9 @@ package body Sem_Ch7 is\n       Set_SPARK_Aux_Pragma_Inherited (Id);\n \n       --  Save the state of flag Ignore_SPARK_Mode_Pragmas_In_Instance in case\n-      --  the body of this package is instantiated or inlined later and out\n-      --  of context. The body uses this attribute to restore the value of\n-      --  the global flag.\n+      --  the body of this package is instantiated or inlined later and out of\n+      --  context. The body uses this attribute to restore the value of the\n+      --  global flag.\n \n       if Ignore_SPARK_Mode_Pragmas_In_Instance then\n          Set_Ignore_SPARK_Mode_Pragmas (Id);"}]}