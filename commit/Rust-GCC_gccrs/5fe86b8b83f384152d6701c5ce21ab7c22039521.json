{"sha": "5fe86b8b83f384152d6701c5ce21ab7c22039521", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZlODZiOGI4M2YzODQxNTJkNjcwMWM1Y2UyMWFiN2MyMjAzOTUyMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-24T23:52:30Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-24T23:52:30Z"}, "message": "(duplicate_decls): Use TYPE_MAIN_VARIANT even for compares with void_type_node.\n\n(grokdeclarator, get_parm_info, store_parm_decls): Likewise.\n\nFrom-SVN: r1683", "tree": {"sha": "7ff519eb2ac4afdd913d35a4bffb182caa44f73a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ff519eb2ac4afdd913d35a4bffb182caa44f73a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fe86b8b83f384152d6701c5ce21ab7c22039521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe86b8b83f384152d6701c5ce21ab7c22039521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fe86b8b83f384152d6701c5ce21ab7c22039521", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe86b8b83f384152d6701c5ce21ab7c22039521/comments", "author": null, "committer": null, "parents": [{"sha": "1fa041c5af61f6143da6fb64482e0dfed400b792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa041c5af61f6143da6fb64482e0dfed400b792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fa041c5af61f6143da6fb64482e0dfed400b792"}], "stats": {"total": 41, "additions": 22, "deletions": 19}, "files": [{"sha": "d6b64e3891e9efedbf13f0da5e30c79cbc38d347", "filename": "gcc/c-decl.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe86b8b83f384152d6701c5ce21ab7c22039521/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe86b8b83f384152d6701c5ce21ab7c22039521/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=5fe86b8b83f384152d6701c5ce21ab7c22039521", "patch": "@@ -1258,20 +1258,20 @@ duplicate_decls (newdecl, olddecl)\n \t   && TREE_CODE (TREE_TYPE (newtype)) == POINTER_TYPE\n \t   && (DECL_IN_SYSTEM_HEADER (olddecl)\n \t       || DECL_IN_SYSTEM_HEADER (newdecl))\n-\t   && ((TREE_TYPE (TREE_TYPE (newtype)) == void_type_node\n+\t   && ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (newtype))) == void_type_node\n \t\t&& TYPE_ARG_TYPES (oldtype) == 0\n \t\t&& self_promoting_args_p (TYPE_ARG_TYPES (newtype))\n \t\t&& TREE_TYPE (TREE_TYPE (oldtype)) == char_type_node)\n \t       ||\n \t       (TREE_TYPE (TREE_TYPE (newtype)) == char_type_node\n \t\t&& TYPE_ARG_TYPES (newtype) == 0\n \t\t&& self_promoting_args_p (TYPE_ARG_TYPES (oldtype))\n-\t\t&& TREE_TYPE (TREE_TYPE (oldtype)) == void_type_node)))\n+\t\t&& TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)))\n     {\n       if (pedantic)\n \tpedwarn_with_decl (newdecl, \"conflicting types for `%s'\");\n       /* Make sure we keep void * as ret type, not char *.  */\n-      if (TREE_TYPE (TREE_TYPE (oldtype)) == void_type_node)\n+      if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)\n \tTREE_TYPE (newdecl) = newtype = oldtype;\n     }\n   else if (!types_match\n@@ -1304,7 +1304,8 @@ duplicate_decls (newdecl, olddecl)\n \t    {\n \t      register tree type = TREE_VALUE (t);\n \n-\t      if (TREE_CHAIN (t) == 0 && type != void_type_node)\n+\t      if (TREE_CHAIN (t) == 0\n+\t\t  && TYPE_MAIN_VARIANT (type) != void_type_node)\n \t\t{\n \t\t  error (\"A parameter list with an ellipsis can't match\");\n \t\t  error (\"an empty parameter name list declaration.\");\n@@ -1343,12 +1344,12 @@ duplicate_decls (newdecl, olddecl)\n \t  for (parm = TYPE_ACTUAL_ARG_TYPES (oldtype),\n \t       type = TYPE_ARG_TYPES (newtype),\n \t       nargs = 1;\n-\t       (TREE_VALUE (parm) != void_type_node\n-\t\t|| TREE_VALUE (type) != void_type_node);\n+\t       (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) != void_type_node\n+\t\t|| TYPE_MAIN_VARIANT (TREE_VALUE (type)) != void_type_node);\n \t       parm = TREE_CHAIN (parm), type = TREE_CHAIN (type), nargs++)\n \t    {\n-\t      if (TREE_VALUE (parm) == void_type_node\n-\t\t  || TREE_VALUE (type) == void_type_node)\n+\t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n+\t\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t\t{\n \t\t  errmsg = \"prototype for `%s' follows and number of arguments\";\n \t\t  break;\n@@ -3724,7 +3725,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n \t  /* Check for some types that there cannot be arrays of.  */\n \n-\t  if (type == void_type_node)\n+\t  if (TYPE_MAIN_VARIANT (type) == void_type_node)\n \t    {\n \t      error (\"declaration of `%s' as array of voids\", name);\n \t      type = error_mark_node;\n@@ -3991,7 +3992,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n      We don't complain about parms either, but that is because\n      a better error message can be made later.  */\n \n-  if (type == void_type_node && decl_context != PARM)\n+  if (TYPE_MAIN_VARIANT (type) == void_type_node && decl_context != PARM)\n     {\n       error (\"variable or field `%s' declared void\",\n \t     IDENTIFIER_POINTER (declarator));\n@@ -4128,7 +4129,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n \t    if (! strcmp (IDENTIFIER_POINTER (declarator), \"main\"))\n \t      warning (\"cannot inline function `main'\");\n-\t    else if (last && TREE_VALUE (last) != void_type_node)\n+\t    else if (last && (TYPE_MAIN_VARIANT (TREE_VALUE (last))\n+\t\t\t      != void_type_node))\n \t      warning (\"inline declaration ignored for function with `...'\");\n \t    else\n \t      /* Assume that otherwise the function can be inlined.  */\n@@ -4350,7 +4352,7 @@ get_parm_info (void_at_end)\n   /* Just `void' (and no ellipsis) is special.  There are really no parms.  */\n   if (void_at_end && parms != 0\n       && TREE_CHAIN (parms) == 0\n-      && TREE_TYPE (parms) == void_type_node\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (parms)) == void_type_node\n       && DECL_NAME (parms) == 0)\n     {\n       parms = NULL_TREE;\n@@ -4411,7 +4413,7 @@ get_parm_info (void_at_end)\n #endif\n \n \ttypes = saveable_tree_cons (NULL_TREE, TREE_TYPE (decl), types);\n-\tif (TREE_VALUE (types) == void_type_node && ! erred\n+\tif (TYPE_MAIN_VARIANT (TREE_VALUE (types)) == void_type_node && ! erred\n \t    && DECL_NAME (decl) == 0)\n \t  {\n \t    error (\"`void' in parameter list must be the entire list\");\n@@ -5289,7 +5291,7 @@ store_parm_decls ()\n \t    {\n \t      if (DECL_NAME (parm) == 0)\n \t\terror_with_decl (parm, \"parameter name omitted\");\n-\t      else if (TREE_TYPE (parm) == void_type_node)\n+\t      else if (TYPE_MAIN_VARIANT (TREE_TYPE (parm)) == void_type_node)\n \t\t{\n \t\t  error_with_decl (parm, \"parameter `%s' declared void\");\n \t\t  /* Change the type to error_mark_node so this parameter\n@@ -5334,7 +5336,7 @@ store_parm_decls ()\n \t  next = TREE_CHAIN (parm);\n \t  if (DECL_NAME (parm) == 0)\n \t    ;\n-\t  else if (TREE_TYPE (parm) == void_type_node)\n+\t  else if (TYPE_MAIN_VARIANT (TREE_TYPE (parm)) == void_type_node)\n \t    ;\n \t  else if (TREE_CODE (parm) != PARM_DECL)\n \t    pushdecl (parm);\n@@ -5389,7 +5391,7 @@ store_parm_decls ()\n \t    }\n \n \t  /* If the declaration says \"void\", complain and ignore it.  */\n-\t  if (found && TREE_TYPE (found) == void_type_node)\n+\t  if (found && TYPE_MAIN_VARIANT (TREE_TYPE (found)) == void_type_node)\n \t    {\n \t      error_with_decl (found, \"parameter `%s' declared void\");\n \t      TREE_TYPE (found) = integer_type_node;\n@@ -5489,11 +5491,12 @@ store_parm_decls ()\n \t  register tree type;\n \t  for (parm = DECL_ARGUMENTS (fndecl),\n \t       type = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-\t       parm || (type && TREE_VALUE (type) != void_type_node);\n+\t       parm || (type && (TYPE_MAIN_VARIANT (TREE_VALUE (type))\n+\t\t\t\t != void_type_node));\n \t       parm = TREE_CHAIN (parm), type = TREE_CHAIN (type))\n \t    {\n \t      if (parm == 0 || type == 0\n-\t\t  || TREE_VALUE (type) == void_type_node)\n+\t\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t\t{\n \t\t  error (\"number of arguments doesn't match prototype\");\n \t\t  break;\n@@ -5669,7 +5672,7 @@ combine_parm_decls (specparms, parmlist, void_at_end)\n \t}\n \n       /* If the declaration says \"void\", complain and ignore it.  */\n-      if (found && TREE_TYPE (found) == void_type_node)\n+      if (found && TYPE_MAIN_VARIANT (TREE_TYPE (found)) == void_type_node)\n \t{\n \t  error_with_decl (found, \"parameter `%s' declared void\");\n \t  TREE_TYPE (found) = integer_type_node;"}]}