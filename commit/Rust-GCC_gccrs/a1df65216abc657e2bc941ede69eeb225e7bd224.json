{"sha": "a1df65216abc657e2bc941ede69eeb225e7bd224", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFkZjY1MjE2YWJjNjU3ZTJiYzk0MWVkZTY5ZWViMjI1ZTdiZDIyNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-10-09T18:20:01Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-10-09T18:20:01Z"}, "message": "amo.h: New include file to provide ISA 3.0 atomic memory operation instruction support.\n\n[gcc]\n2017-10-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/amo.h: New include file to provide ISA 3.0 atomic\n\tmemory operation instruction support.\n\t* config.gcc (powerpc*-*-*): Include amo.h as an extra header.\n\t(rs6000-ibm-aix[789]*): Likewise.\n\t* doc/extend.texi (PowerPC Atomic Memory Operation Functions):\n\tDocument new functions.\n\n[gcc/testsuite]\n2017-10-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/amo1.c: New test.\n\t* gcc.target/powerpc/amo2.c: Likewise.\n\nFrom-SVN: r253552", "tree": {"sha": "2edd7a75ef5025bd7f5a46c9f441e1471658b28b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2edd7a75ef5025bd7f5a46c9f441e1471658b28b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1df65216abc657e2bc941ede69eeb225e7bd224", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1df65216abc657e2bc941ede69eeb225e7bd224", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1df65216abc657e2bc941ede69eeb225e7bd224", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1df65216abc657e2bc941ede69eeb225e7bd224/comments", "author": null, "committer": null, "parents": [{"sha": "15529d0aa0264ae211db7acfebd1e23c8a944123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15529d0aa0264ae211db7acfebd1e23c8a944123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15529d0aa0264ae211db7acfebd1e23c8a944123"}], "stats": {"total": 453, "additions": 452, "deletions": 1}, "files": [{"sha": "4f56637b6d85fa3212a149c45ef94c6836c7fe3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1df65216abc657e2bc941ede69eeb225e7bd224", "patch": "@@ -1,3 +1,12 @@\n+2017-10-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/amo.h: New include file to provide ISA 3.0 atomic\n+\tmemory operation instruction support.\n+\t* config.gcc (powerpc*-*-*): Include amo.h as an extra header.\n+\t(rs6000-ibm-aix[789]*): Likewise.\n+\t* doc/extend.texi (PowerPC Atomic Memory Operation Functions):\n+\tDocument new functions.\n+\n 2017-10-09  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82397"}, {"sha": "ee92f70904a72c6051e3f5b8cd146a69dced6bcd", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=a1df65216abc657e2bc941ede69eeb225e7bd224", "patch": "@@ -461,6 +461,7 @@ powerpc*-*-*)\n \textra_headers=\"${extra_headers} mmintrin.h x86intrin.h\"\n \textra_headers=\"${extra_headers} ppu_intrinsics.h spu2vmx.h vec_types.h si2vmx.h\"\n \textra_headers=\"${extra_headers} paired.h\"\n+\textra_headers=\"${extra_headers} amo.h\"\n \tcase x$with_cpu in\n \t    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[3456789]|xpower6x|xrs64a|xcell|xa2|xe500mc64|xe5500|xe6500)\n \t\tcpu_is_64bit=yes\n@@ -2627,7 +2628,7 @@ rs6000-ibm-aix[789].* | powerpc-ibm-aix[789].*)\n \tuse_collect2=yes\n \tthread_file='aix'\n \tuse_gcc_stdint=wrap\n-\textra_headers=altivec.h\n+\textra_headers=\"altivec.h amo.h\"\n \tdefault_use_cxa_atexit=yes\n \t;;\n rl78-*-elf*)"}, {"sha": "0014490e8692d3ac63f278567f6a939fdcbdbbed", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a1df65216abc657e2bc941ede69eeb225e7bd224", "patch": "@@ -12041,6 +12041,7 @@ instructions, but allow the compiler to schedule those calls.\n * PowerPC Built-in Functions::\n * PowerPC AltiVec/VSX Built-in Functions::\n * PowerPC Hardware Transactional Memory Built-in Functions::\n+* PowerPC Atomic Memory Operation Functions::\n * RX Built-in Functions::\n * S/390 System z Built-in Functions::\n * SH Built-in Functions::\n@@ -19126,6 +19127,67 @@ while (1)\n   @}\n @end smallexample\n \n+@node PowerPC Atomic Memory Operation Functions\n+@subsection PowerPC Atomic Memory Operation Functions\n+ISA 3.0 of the PowerPC added new atomic memory operation (amo)\n+instructions.  GCC provides support for these instructions in 64-bit\n+environments.  All of the functions are declared in the include file\n+@code{amo.h}.\n+\n+The functions supported are:\n+\n+@smallexample\n+#include <amo.h>\n+\n+uint32_t amo_lwat_add (uint32_t *, uint32_t);\n+uint32_t amo_lwat_xor (uint32_t *, uint32_t);\n+uint32_t amo_lwat_ior (uint32_t *, uint32_t);\n+uint32_t amo_lwat_and (uint32_t *, uint32_t);\n+uint32_t amo_lwat_umax (uint32_t *, uint32_t);\n+uint32_t amo_lwat_umin (uint32_t *, uint32_t);\n+uint32_t amo_lwat_swap (uint32_t *, uint32_t);\n+\n+int32_t amo_lwat_sadd (int32_t *, int32_t);\n+int32_t amo_lwat_smax (int32_t *, int32_t);\n+int32_t amo_lwat_smin (int32_t *, int32_t);\n+int32_t amo_lwat_sswap (int32_t *, int32_t);\n+\n+uint64_t amo_ldat_add (uint64_t *, uint64_t);\n+uint64_t amo_ldat_xor (uint64_t *, uint64_t);\n+uint64_t amo_ldat_ior (uint64_t *, uint64_t);\n+uint64_t amo_ldat_and (uint64_t *, uint64_t);\n+uint64_t amo_ldat_umax (uint64_t *, uint64_t);\n+uint64_t amo_ldat_umin (uint64_t *, uint64_t);\n+uint64_t amo_ldat_swap (uint64_t *, uint64_t);\n+\n+int64_t amo_ldat_sadd (int64_t *, int64_t);\n+int64_t amo_ldat_smax (int64_t *, int64_t);\n+int64_t amo_ldat_smin (int64_t *, int64_t);\n+int64_t amo_ldat_sswap (int64_t *, int64_t);\n+\n+void amo_stwat_add (uint32_t *, uint32_t);\n+void amo_stwat_xor (uint32_t *, uint32_t);\n+void amo_stwat_ior (uint32_t *, uint32_t);\n+void amo_stwat_and (uint32_t *, uint32_t);\n+void amo_stwat_umax (uint32_t *, uint32_t);\n+void amo_stwat_umin (uint32_t *, uint32_t);\n+\n+void amo_stwat_sadd (int32_t *, int32_t);\n+void amo_stwat_smax (int32_t *, int32_t);\n+void amo_stwat_smin (int32_t *, int32_t);\n+\n+void amo_stdat_add (uint64_t *, uint64_t);\n+void amo_stdat_xor (uint64_t *, uint64_t);\n+void amo_stdat_ior (uint64_t *, uint64_t);\n+void amo_stdat_and (uint64_t *, uint64_t);\n+void amo_stdat_umax (uint64_t *, uint64_t);\n+void amo_stdat_umin (uint64_t *, uint64_t);\n+\n+void amo_stdat_sadd (int64_t *, int64_t);\n+void amo_stdat_smax (int64_t *, int64_t);\n+void amo_stdat_smin (int64_t *, int64_t);\n+@end smallexample\n+\n @node RX Built-in Functions\n @subsection RX Built-in Functions\n GCC supports some of the RX instructions which cannot be expressed in"}, {"sha": "eb88b21c4311f13a4c5d152cda7a441f55f1f357", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a1df65216abc657e2bc941ede69eeb225e7bd224", "patch": "@@ -1,3 +1,8 @@\n+2017-10-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/amo1.c: New test.\n+\t* gcc.target/powerpc/amo2.c: Likewise.\n+\n 2017-10-09  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82449"}, {"sha": "152f0e5874b03f79e60fd393486972dfaf5e015f", "filename": "gcc/testsuite/gcc.target/powerpc/amo1.c", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Famo1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Famo1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Famo1.c?ref=a1df65216abc657e2bc941ede69eeb225e7bd224", "patch": "@@ -0,0 +1,253 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mpower9-vector -mpower9-misc -O2\" } */\n+\n+/* Verify P9 atomic memory operations.  */\n+\n+#include <amo.h>\n+#include <stdint.h>\n+\n+uint32_t\n+do_lw_add (uint32_t *mem, uint32_t value)\n+{\n+  return amo_lwat_add (mem, value);\n+}\n+\n+int32_t\n+do_lw_sadd (int32_t *mem, int32_t value)\n+{\n+  return amo_lwat_sadd (mem, value);\n+}\n+\n+uint32_t\n+do_lw_xor (uint32_t *mem, uint32_t value)\n+{\n+  return amo_lwat_xor (mem, value);\n+}\n+\n+uint32_t\n+do_lw_ior (uint32_t *mem, uint32_t value)\n+{\n+  return amo_lwat_ior (mem, value);\n+}\n+\n+uint32_t\n+do_lw_and (uint32_t *mem, uint32_t value)\n+{\n+  return amo_lwat_and (mem, value);\n+}\n+\n+uint32_t\n+do_lw_umax (uint32_t *mem, uint32_t value)\n+{\n+  return amo_lwat_umax (mem, value);\n+}\n+\n+int32_t\n+do_lw_smax (int32_t *mem, int32_t value)\n+{\n+  return amo_lwat_smax (mem, value);\n+}\n+\n+uint32_t\n+do_lw_umin (uint32_t *mem, uint32_t value)\n+{\n+  return amo_lwat_umin (mem, value);\n+}\n+\n+int32_t\n+do_lw_smin (int32_t *mem, int32_t value)\n+{\n+  return amo_lwat_smin (mem, value);\n+}\n+\n+uint32_t\n+do_lw_swap (uint32_t *mem, uint32_t value)\n+{\n+  return amo_lwat_swap (mem, value);\n+}\n+\n+int32_t\n+do_lw_sswap (int32_t *mem, int32_t value)\n+{\n+  return amo_lwat_sswap (mem, value);\n+}\n+\n+uint64_t\n+do_ld_add (uint64_t *mem, uint64_t value)\n+{\n+  return amo_ldat_add (mem, value);\n+}\n+\n+int64_t\n+do_ld_sadd (int64_t *mem, int64_t value)\n+{\n+  return amo_ldat_sadd (mem, value);\n+}\n+\n+uint64_t\n+do_ld_xor (uint64_t *mem, uint64_t value)\n+{\n+  return amo_ldat_xor (mem, value);\n+}\n+\n+uint64_t\n+do_ld_ior (uint64_t *mem, uint64_t value)\n+{\n+  return amo_ldat_ior (mem, value);\n+}\n+\n+uint64_t\n+do_ld_and (uint64_t *mem, uint64_t value)\n+{\n+  return amo_ldat_and (mem, value);\n+}\n+\n+uint64_t\n+do_ld_umax (uint64_t *mem, uint64_t value)\n+{\n+  return amo_ldat_umax (mem, value);\n+}\n+\n+int64_t\n+do_ld_smax (int64_t *mem, int64_t value)\n+{\n+  return amo_ldat_smax (mem, value);\n+}\n+\n+uint64_t\n+do_ld_umin (uint64_t *mem, uint64_t value)\n+{\n+  return amo_ldat_umin (mem, value);\n+}\n+\n+int64_t\n+do_ld_smin (int64_t *mem, int64_t value)\n+{\n+  return amo_ldat_smin (mem, value);\n+}\n+\n+uint64_t\n+do_ld_swap (uint64_t *mem, uint64_t value)\n+{\n+  return amo_ldat_swap (mem, value);\n+}\n+\n+int64_t\n+do_ld_sswap (int64_t *mem, int64_t value)\n+{\n+  return amo_ldat_sswap (mem, value);\n+}\n+\n+void\n+do_sw_add (uint32_t *mem, uint32_t value)\n+{\n+  amo_stwat_add (mem, value);\n+}\n+\n+void\n+do_sw_sadd (int32_t *mem, int32_t value)\n+{\n+  amo_stwat_sadd (mem, value);\n+}\n+\n+void\n+do_sw_xor (uint32_t *mem, uint32_t value)\n+{\n+  amo_stwat_xor (mem, value);\n+}\n+\n+void\n+do_sw_ior (uint32_t *mem, uint32_t value)\n+{\n+  amo_stwat_ior (mem, value);\n+}\n+\n+void\n+do_sw_and (uint32_t *mem, uint32_t value)\n+{\n+  amo_stwat_and (mem, value);\n+}\n+\n+void\n+do_sw_umax (int32_t *mem, int32_t value)\n+{\n+  amo_stwat_umax (mem, value);\n+}\n+\n+void\n+do_sw_smax (int32_t *mem, int32_t value)\n+{\n+  amo_stwat_smax (mem, value);\n+}\n+\n+void\n+do_sw_umin (int32_t *mem, int32_t value)\n+{\n+  amo_stwat_umin (mem, value);\n+}\n+\n+void\n+do_sw_smin (int32_t *mem, int32_t value)\n+{\n+  amo_stwat_smin (mem, value);\n+}\n+\n+void\n+do_sd_add (uint64_t *mem, uint64_t value)\n+{\n+  amo_stdat_add (mem, value);\n+}\n+\n+void\n+do_sd_sadd (int64_t *mem, int64_t value)\n+{\n+  amo_stdat_sadd (mem, value);\n+}\n+\n+void\n+do_sd_xor (uint64_t *mem, uint64_t value)\n+{\n+  amo_stdat_xor (mem, value);\n+}\n+\n+void\n+do_sd_ior (uint64_t *mem, uint64_t value)\n+{\n+  amo_stdat_ior (mem, value);\n+}\n+\n+void\n+do_sd_and (uint64_t *mem, uint64_t value)\n+{\n+  amo_stdat_and (mem, value);\n+}\n+\n+void\n+do_sd_umax (int64_t *mem, int64_t value)\n+{\n+  amo_stdat_umax (mem, value);\n+}\n+\n+void\n+do_sd_smax (int64_t *mem, int64_t value)\n+{\n+  amo_stdat_smax (mem, value);\n+}\n+\n+void\n+do_sd_umin (int64_t *mem, int64_t value)\n+{\n+  amo_stdat_umin (mem, value);\n+}\n+\n+void\n+do_sd_smin (int64_t *mem, int64_t value)\n+{\n+  amo_stdat_smin (mem, value);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mldat\\M}  11 } } */\n+/* { dg-final { scan-assembler-times {\\mlwat\\M}  11 } } */\n+/* { dg-final { scan-assembler-times {\\mstdat\\M}  9 } } */\n+/* { dg-final { scan-assembler-times {\\mstwat\\M}  9 } } */"}, {"sha": "cc7cfe4b450e573e43a17550c2db925d28764f4f", "filename": "gcc/testsuite/gcc.target/powerpc/amo2.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Famo2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1df65216abc657e2bc941ede69eeb225e7bd224/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Famo2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Famo2.c?ref=a1df65216abc657e2bc941ede69eeb225e7bd224", "patch": "@@ -0,0 +1,121 @@\n+/* { dg-do run { target { powerpc*-*-linux* && { lp64 && p9vector_hw } } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-O2 -mpower9-vector -mpower9-misc\" } */\n+\n+#include <amo.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/* Test whether the ISA 3.0 amo (atomic memory operations) functions perform as\n+   expected.  */\n+\n+/* 32-bit tests.  */\n+static uint32_t u32_ld[4] = {\n+  9,\t\t\t\t/* add */\n+  7,\t\t\t\t/* xor */\n+  6,\t\t\t\t/* ior */\n+  7,\t\t\t\t/* and */\n+};\n+\n+static uint32_t u32_st[4] = {\n+  9,\t\t\t\t/* add */\n+  7,\t\t\t\t/* xor */\n+  6,\t\t\t\t/* ior */\n+  7,\t\t\t\t/* and */\n+};\n+\n+static uint32_t u32_result[4];\n+\n+static uint32_t u32_update[4] = {\n+  9 + 1,\t\t\t/* add */\n+  7 ^ 1,\t\t\t/* xor */\n+  6 | 1,\t\t\t/* ior */\n+  7 & 1,\t\t\t/* and */\n+};\n+\n+static uint32_t u32_prev[4] = {\n+  9,\t\t\t\t/* add */\n+  7,\t\t\t\t/* xor */\n+  6,\t\t\t\t/* ior */\n+  7,\t\t\t\t/* and */\n+};\n+\n+/* 64-bit tests.  */\n+static uint64_t u64_ld[4] = {\n+  9,\t\t\t\t/* add */\n+  7,\t\t\t\t/* xor */\n+  6,\t\t\t\t/* ior */\n+  7,\t\t\t\t/* and */\n+};\n+\n+static uint64_t u64_st[4] = {\n+  9,\t\t\t\t/* add */\n+  7,\t\t\t\t/* xor */\n+  6,\t\t\t\t/* ior */\n+  7,\t\t\t\t/* and */\n+};\n+\n+static uint64_t u64_result[4];\n+\n+static uint64_t u64_update[4] = {\n+  9 + 1,\t\t\t/* add */\n+  7 ^ 1,\t\t\t/* xor */\n+  6 | 1,\t\t\t/* ior */\n+  7 & 1,\t\t\t/* and */\n+};\n+\n+static uint64_t u64_prev[4] = {\n+  9,\t\t\t\t/* add */\n+  7,\t\t\t\t/* xor */\n+  6,\t\t\t\t/* ior */\n+  7,\t\t\t\t/* and */\n+};\n+\n+int\n+main (void)\n+{\n+  size_t i;\n+\n+  u32_result[0] = amo_lwat_add (&u32_ld[0], 1);\n+  u32_result[1] = amo_lwat_xor (&u32_ld[1], 1);\n+  u32_result[2] = amo_lwat_ior (&u32_ld[2], 1);\n+  u32_result[3] = amo_lwat_and (&u32_ld[3], 1);\n+\n+  u64_result[0] = amo_ldat_add (&u64_ld[0], 1);\n+  u64_result[1] = amo_ldat_xor (&u64_ld[1], 1);\n+  u64_result[2] = amo_ldat_ior (&u64_ld[2], 1);\n+  u64_result[3] = amo_ldat_and (&u64_ld[3], 1);\n+\n+  amo_stwat_add (&u32_st[0], 1);\n+  amo_stwat_xor (&u32_st[1], 1);\n+  amo_stwat_ior (&u32_st[2], 1);\n+  amo_stwat_and (&u32_st[3], 1);\n+\n+  amo_stdat_add (&u64_st[0], 1);\n+  amo_stdat_xor (&u64_st[1], 1);\n+  amo_stdat_ior (&u64_st[2], 1);\n+  amo_stdat_and (&u64_st[3], 1);\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (u32_result[i] != u32_prev[i])\n+\tabort ();\n+\n+      if (u32_ld[i] != u32_update[i])\n+\tabort ();\n+\n+      if (u32_st[i] != u32_update[i])\n+\tabort ();\n+\n+      if (u64_result[i] != u64_prev[i])\n+\tabort ();\n+\n+      if (u64_ld[i] != u64_update[i])\n+\tabort ();\n+\n+      if (u64_st[i] != u64_update[i])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}]}