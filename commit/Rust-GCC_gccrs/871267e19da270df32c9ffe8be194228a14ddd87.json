{"sha": "871267e19da270df32c9ffe8be194228a14ddd87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcxMjY3ZTE5ZGEyNzBkZjMyYzlmZmU4YmUxOTQyMjhhMTRkZGQ4Nw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-17T17:52:05Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-17T17:52:05Z"}, "message": "re PR fortran/61420 ([OOP] type-bound procedure returning a procedure pointer fails to compile)\n\n2016-10-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/61420\n\tPR fortran/78013\n\t* resolve.c (resolve_variable): Obtain the typespec for a\n\tvariable expression, when the variable is a function result\n\tthat is a procedure pointer.\n\n2016-10-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/61420\n\tPR fortran/78013\n\t* gfortran.dg/proc_ptr_49.f90: New test.\n\nFrom-SVN: r241274", "tree": {"sha": "200ebb8c89c3290e59010b3d9765e835125267cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/200ebb8c89c3290e59010b3d9765e835125267cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/871267e19da270df32c9ffe8be194228a14ddd87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/871267e19da270df32c9ffe8be194228a14ddd87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/871267e19da270df32c9ffe8be194228a14ddd87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/871267e19da270df32c9ffe8be194228a14ddd87/comments", "author": null, "committer": null, "parents": [{"sha": "fd9593e9d2addd7b96ab4da00c4a240edc111fc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd9593e9d2addd7b96ab4da00c4a240edc111fc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd9593e9d2addd7b96ab4da00c4a240edc111fc7"}], "stats": {"total": 71, "additions": 70, "deletions": 1}, "files": [{"sha": "9b2c5c583f25371707d67f46a2b174cce8aa07a5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871267e19da270df32c9ffe8be194228a14ddd87/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871267e19da270df32c9ffe8be194228a14ddd87/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=871267e19da270df32c9ffe8be194228a14ddd87", "patch": "@@ -1,3 +1,11 @@\n+2016-10-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/61420\n+\tPR fortran/78013\n+\t* resolve.c (resolve_variable): Obtain the typespec for a\n+\tvariable expression, when the variable is a function result\n+\tthat is a procedure pointer.\n+\n 2016-10-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/48298"}, {"sha": "87178a413335c7db9c928dd7d8ab754ce4508b16", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871267e19da270df32c9ffe8be194228a14ddd87/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871267e19da270df32c9ffe8be194228a14ddd87/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=871267e19da270df32c9ffe8be194228a14ddd87", "patch": "@@ -5112,6 +5112,11 @@ resolve_variable (gfc_expr *e)\n \n   if (sym->ts.type != BT_UNKNOWN)\n     gfc_variable_attr (e, &e->ts);\n+  else if (sym->attr.flavor == FL_PROCEDURE\n+\t   && sym->attr.function && sym->result\n+\t   && sym->result->ts.type != BT_UNKNOWN\n+\t   && sym->result->attr.proc_pointer)\n+    e->ts = sym->result->ts;\n   else\n     {\n       /* Must be a simple variable reference.  */"}, {"sha": "4ba97ca0c2e2f296a02ec1c9fe8b550e55e1e1d9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871267e19da270df32c9ffe8be194228a14ddd87/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871267e19da270df32c9ffe8be194228a14ddd87/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=871267e19da270df32c9ffe8be194228a14ddd87", "patch": "@@ -1,3 +1,9 @@\n+2016-10-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/61420\n+\tPR fortran/78013\n+\t* gfortran.dg/proc_ptr_49.f90: New test.\n+\n 2016-09-29  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR target/77308\n@@ -895,7 +901,7 @@\n \n 2016-09-29  Sandra Loosemore  <sandra@codesourcery.com>\n \n-\t* c-c++-common/pr27336.c: Make dependency on \n+\t* c-c++-common/pr27336.c: Make dependency on\n \t-fdelete-null-pointer-checks explicit.\n \t* g++.dg/cpp0x/constexpr-array-ptr10.C: Likewise.\n \t* g++.dg/cpp0x/constexpr-nullptr-1.C: Likewise."}, {"sha": "cb540a4f548f0387ce7eb739e30ab1cb7aeb85fe", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_49.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871267e19da270df32c9ffe8be194228a14ddd87/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_49.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871267e19da270df32c9ffe8be194228a14ddd87/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_49.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_49.f90?ref=871267e19da270df32c9ffe8be194228a14ddd87", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do compile }\n+!\n+! Tests the fix for PRs 78013 and 61420, both of which gave a\n+! no IMPLICIT type message for the procedure pointer at assignment.\n+!\n+module m\n+\n+  implicit none\n+\n+  abstract interface\n+    function I_f() result( r )\n+      real :: r\n+    end function I_f\n+  end interface\n+\n+  type, abstract :: a_t\n+    private\n+    procedure(I_f), nopass, pointer :: m_f => null()\n+  contains\n+    private\n+    procedure, pass(this), public :: f => get_f\n+  end type a_t\n+\n+contains\n+\n+  function get_f( this ) result( f_ptr )  ! Error message here.\n+    class(a_t), intent(in)  :: this\n+    procedure(I_f), pointer :: f_ptr\n+    f_ptr => this%m_f                     ! Error here :-)\n+  end function get_f\n+\n+end module m\n+\n+module test\n+  implicit none\n+\n+  type functions\n+  contains\n+    procedure, nopass :: get_pf => get_it ! Error here\n+  end type\n+\n+  class(functions), allocatable :: f\n+\n+contains\n+\n+  function get_it()                      ! Error message here.\n+    procedure (real), pointer :: get_it\n+  end function\n+\n+end module"}]}