{"sha": "2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "node_id": "C_kwDOANBUbNoAKDI2NjllODBjMTdmNGM5ZDhiNTM0YzczYWUwYzYwYTUxZGUwYjQ2NTk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-11T09:10:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-11T09:10:22Z"}, "message": "Merge #1090 #1097 #1098 #1099 #1101\n\n1090: macros: add concat! macro r=philberty a=liushuyu\n\n- extracts parenthesis-matching logic into a function\r\n- adds `concat!` macro\n\n1097: Support mangling *const ptr and slices like *const [T] r=philberty a=philberty\n\nThe legacy mangling scheme needs to convert the canonical path containing\r\n* for pointers and the [] brackets representing slices into:\r\n\r\n  * = $BP$\r\n  [ = $u5b$\r\n  ] = $u5d$\r\n\r\nThese symbols are not allowed in asm symbols.\r\n\r\nAddresses #849\r\n\n\n1098: Ensure unsize method resolutions actually unsize r=philberty a=philberty\n\nThis was a typo when unsized method resolution was added, where the\r\nadjustment was wrongly marked as an indirection. The enum is required so\r\nthat the code generation adjustment takes place.\r\n\r\nAddresses #849\n\n1099: Fix bad inherent overlap error r=philberty a=philberty\n\nWhen we examine HIR::ImplBlock's we determine if an impl might overlap\r\nanother impl based on the Self type. So for example you might have a\r\ngeneric structure Foo<T>(T), and an associated impl block for Foo<i32>, but\r\nthen go on to define an associated impl of Foo<T> the generic one will\r\noverlap any associated impl hiding the generic implementation.\r\n\r\nIn this case we have two generic impl blocks\r\n\r\n  *const [T]\r\n  *const T\r\n\r\nThis means the *const T might overlap with the slice one since it is\r\ngeneric. As bjorn3 pointed out in #1075 , the correct implementation is to\r\nobserve that [T] is constrained by size but untill we have the auto trait\r\nof Sized we must example the two generic impls and just determine that\r\nthey are not-equal so for now this is the best implementation we can do.\r\n\r\nFixes #1075 \r\n\n\n1101: Add helper as_string for DefIds r=philberty a=philberty\n\nThis just adds a useful helper to as_string DefId's directly\n\nCo-authored-by: liushuyu <liushuyu011@gmail.com>\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "40c7b9b28b3aa2ce51f45363ce2638e0e7388fe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40c7b9b28b3aa2ce51f45363ce2638e0e7388fe0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiU/B+CRBK7hj4Ov3rIwAAQ7EIAHsu8bHPNnCGSBlmqucIQPd9\no0z8FQtkoPlZffy9paIKQkwgKA/2e2E5E8KTm7kUEipzQuYRXae67DBMY+x8ux24\nvOrGWgV4ZU4iI9Dv2n/jquRJg3tYdzX1EL/xRXBXWuC4iQGSWi2KYpHomwqFwfSc\nmyhanCEIIKkbtACsns7pU4BcQjfgPGUIf8wlkRdJutPAMNPYwieDQTT/wNtn7Eus\nILKsQIvc0dN9bMi4BNBPMLHo8qhnArHZd+jZTLrOSVdcE+Eh9YRU2/2JXUech75E\nHsFUdErvDKcgEx7AiP1vX0ivpv+aJYc29nF5RateEGzXfF8CqYyGKeXTVZ7nxME=\n=As25\n-----END PGP SIGNATURE-----\n", "payload": "tree 40c7b9b28b3aa2ce51f45363ce2638e0e7388fe0\nparent e5281ee490ad9edafbde2c7d301c77130c0b4147\nparent fed5a41fb1c2c91b77297fdd6d3731078f480441\nparent 6fb118f3e2ed4a189198936a82e0f68ccf954044\nparent 8d3184e822af007829b3820a9b3df03b7548ff59\nparent 4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7\nparent 3513fa38f2dbc2b564a32832ad9277ef909c6379\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1649668222 +0000\ncommitter GitHub <noreply@github.com> 1649668222 +0000\n\nMerge #1090 #1097 #1098 #1099 #1101\n\n1090: macros: add concat! macro r=philberty a=liushuyu\n\n- extracts parenthesis-matching logic into a function\r\n- adds `concat!` macro\n\n1097: Support mangling *const ptr and slices like *const [T] r=philberty a=philberty\n\nThe legacy mangling scheme needs to convert the canonical path containing\r\n* for pointers and the [] brackets representing slices into:\r\n\r\n  * = $BP$\r\n  [ = $u5b$\r\n  ] = $u5d$\r\n\r\nThese symbols are not allowed in asm symbols.\r\n\r\nAddresses #849\r\n\n\n1098: Ensure unsize method resolutions actually unsize r=philberty a=philberty\n\nThis was a typo when unsized method resolution was added, where the\r\nadjustment was wrongly marked as an indirection. The enum is required so\r\nthat the code generation adjustment takes place.\r\n\r\nAddresses #849\n\n1099: Fix bad inherent overlap error r=philberty a=philberty\n\nWhen we examine HIR::ImplBlock's we determine if an impl might overlap\r\nanother impl based on the Self type. So for example you might have a\r\ngeneric structure Foo<T>(T), and an associated impl block for Foo<i32>, but\r\nthen go on to define an associated impl of Foo<T> the generic one will\r\noverlap any associated impl hiding the generic implementation.\r\n\r\nIn this case we have two generic impl blocks\r\n\r\n  *const [T]\r\n  *const T\r\n\r\nThis means the *const T might overlap with the slice one since it is\r\ngeneric. As bjorn3 pointed out in #1075 , the correct implementation is to\r\nobserve that [T] is constrained by size but untill we have the auto trait\r\nof Sized we must example the two generic impls and just determine that\r\nthey are not-equal so for now this is the best implementation we can do.\r\n\r\nFixes #1075 \r\n\n\n1101: Add helper as_string for DefIds r=philberty a=philberty\n\nThis just adds a useful helper to as_string DefId's directly\n\nCo-authored-by: liushuyu <liushuyu011@gmail.com>\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5281ee490ad9edafbde2c7d301c77130c0b4147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5281ee490ad9edafbde2c7d301c77130c0b4147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5281ee490ad9edafbde2c7d301c77130c0b4147"}, {"sha": "fed5a41fb1c2c91b77297fdd6d3731078f480441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed5a41fb1c2c91b77297fdd6d3731078f480441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fed5a41fb1c2c91b77297fdd6d3731078f480441"}, {"sha": "6fb118f3e2ed4a189198936a82e0f68ccf954044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb118f3e2ed4a189198936a82e0f68ccf954044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fb118f3e2ed4a189198936a82e0f68ccf954044"}, {"sha": "8d3184e822af007829b3820a9b3df03b7548ff59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d3184e822af007829b3820a9b3df03b7548ff59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d3184e822af007829b3820a9b3df03b7548ff59"}, {"sha": "4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7"}, {"sha": "3513fa38f2dbc2b564a32832ad9277ef909c6379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3513fa38f2dbc2b564a32832ad9277ef909c6379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3513fa38f2dbc2b564a32832ad9277ef909c6379"}], "stats": {"total": 245, "additions": 202, "deletions": 43}, "files": [{"sha": "82f643a1b90e16e99e6cb52accc0b007bb692992", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -11,6 +11,9 @@ static const std::string kMangledSubstBegin = \"$LT$\";\n static const std::string kMangledSubstEnd = \"$GT$\";\n static const std::string kMangledSpace = \"$u20$\";\n static const std::string kMangledRef = \"$RF$\";\n+static const std::string kMangledPtr = \"$BP$\";\n+static const std::string kMangledLeftSqParen = \"$u5b$\";\t // [\n+static const std::string kMangledRightSqParen = \"$u5d$\"; // ]\n static const std::string kQualPathBegin = \"_\" + kMangledSubstBegin;\n \n namespace Rust {\n@@ -29,8 +32,15 @@ legacy_mangle_name (const std::string &name)\n   // <example::Bar as example::A>::fooA:\n   // _ZN43_$LT$example..Bar$u20$as$u20$example..A$GT$4fooA17hfc615fa76c7db7a0E:\n   //\n+  // core::ptr::const_ptr::<impl *const T>::cast:\n+  // _ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hb79f4617226f1d55E:\n+  //\n+  // core::ptr::const_ptr::<impl *const [T]>::as_ptr:\n+  // _ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$6as_ptr17he16e0dcd9473b04fE:\n+  //\n   // example::Foo<T>::new:\n   // _ZN7example12Foo$LT$T$GT$3new17h9a2aacb7fd783515E:\n+\n   std::string buffer;\n   for (size_t i = 0; i < name.size (); i++)\n     {\n@@ -47,6 +57,12 @@ legacy_mangle_name (const std::string &name)\n \tm = kMangledSubstBegin;\n       else if (c == '>')\n \tm = kMangledSubstEnd;\n+      else if (c == '*')\n+\tm = kMangledPtr;\n+      else if (c == '[')\n+\tm = kMangledLeftSqParen;\n+      else if (c == ']')\n+\tm = kMangledRightSqParen;\n       else if (c == ':')\n \t{\n \t  rust_assert (i + 1 < name.size ());"}, {"sha": "85520ec60a497244236ffe4c390d560cb00a9ec4", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -34,17 +34,12 @@ make_string (Location locus, std::string value)\n \t\t\t  PrimitiveCoreType::CORETYPE_STR, {}, locus));\n }\n \n-/* Parse a single string literal from the given delimited token tree,\n-   and return the LiteralExpr for it. Allow for an optional trailing comma,\n-   but otherwise enforce that these are the only tokens.  */\n+/* Match the end token of a macro given the start delimiter of the macro */\n \n-std::unique_ptr<AST::LiteralExpr>\n-parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n-\t\t\t     Location invoc_locus)\n+static inline TokenId\n+macro_end_token (AST::DelimTokenTree &invoc_token_tree,\n+\t\t Parser<MacroInvocLexer> &parser)\n {\n-  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n-  Parser<MacroInvocLexer> parser (std::move (lex));\n-\n   auto last_token_id = TokenId::RIGHT_CURLY;\n   switch (invoc_token_tree.get_delim_type ())\n     {\n@@ -63,6 +58,22 @@ parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n       break;\n     }\n \n+  return last_token_id;\n+}\n+\n+/* Parse a single string literal from the given delimited token tree,\n+   and return the LiteralExpr for it. Allow for an optional trailing comma,\n+   but otherwise enforce that these are the only tokens.  */\n+\n+std::unique_ptr<AST::LiteralExpr>\n+parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n+\t\t\t     Location invoc_locus)\n+{\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+\n+  auto last_token_id = macro_end_token (invoc_token_tree, parser);\n+\n   std::unique_ptr<AST::LiteralExpr> lit_expr = nullptr;\n \n   if (parser.peek_current_token ()->get_id () == STRING_LITERAL)\n@@ -252,4 +263,44 @@ MacroBuiltin::compile_error (Location invoc_locus, AST::MacroInvocData &invoc)\n   return AST::ASTFragment::create_error ();\n }\n \n+/* Expand builtin macro concat!(), which joins all the literal parameters\n+   into a string with no delimiter. */\n+\n+AST::ASTFragment\n+MacroBuiltin::concat (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  auto invoc_token_tree = invoc.get_delim_tok_tree ();\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+  auto str = std::string ();\n+  bool has_error = false;\n+\n+  auto last_token_id = macro_end_token (invoc_token_tree, parser);\n+\n+  /* NOTE: concat! could accept no argument, so we don't have any checks here */\n+  while (parser.peek_current_token ()->get_id () != last_token_id)\n+    {\n+      auto lit_expr = parser.parse_literal_expr ();\n+      if (lit_expr)\n+\t{\n+\t  str += lit_expr->as_string ();\n+\t}\n+      else\n+\t{\n+\t  rust_error_at (parser.peek_current_token ()->get_locus (),\n+\t\t\t \"argument must be a constant literal\");\n+\t  has_error = true;\n+\t}\n+      parser.maybe_skip_token (COMMA);\n+    }\n+\n+  parser.skip_token (last_token_id);\n+\n+  if (has_error)\n+    return AST::ASTFragment::create_error ();\n+\n+  auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n+  return AST::ASTFragment ({node});\n+}\n+\n } // namespace Rust"}, {"sha": "a581af4c9ab732feefe7cfff73090985730c77af", "filename": "gcc/rust/expand/rust-macro-builtins.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -80,6 +80,9 @@ class MacroBuiltin\n \n   static AST::ASTFragment compile_error (Location invoc_locus,\n \t\t\t\t\t AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment concat (Location invoc_locus,\n+\t\t\t\t  AST::MacroInvocData &invoc);\n };\n } // namespace Rust\n "}, {"sha": "986ff460490fe508bf25af256dd867ec6c91ae07", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -116,7 +116,7 @@ Adjuster::try_unsize_type (const TyTy::BaseType *ty)\n \t\t\t   TyTy::TyVar (slice_elem->get_ref ()));\n   context->insert_implicit_type (slice);\n \n-  return Adjustment (Adjustment::AdjustmentType::INDIRECTION, slice);\n+  return Adjustment (Adjustment::AdjustmentType::UNSIZE, slice);\n }\n \n static bool"}, {"sha": "9abf87280ad25878cfff24bd60935e0a1482f04e", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -123,7 +123,26 @@ class OverlappingImplItemPass : public TypeCheckBase\n \t      continue;\n \n \t    if (query->can_eq (candidate, false))\n-\t      possible_collision (it->second, iy->second);\n+\t      {\n+\t\t// we might be in the case that we have:\n+\t\t//\n+\t\t// *const T vs *const [T]\n+\t\t//\n+\t\t// so lets use an equality check when the\n+\t\t// candidates are both generic to be sure we dont emit a false\n+\t\t// positive\n+\n+\t\tbool a = query->is_concrete ();\n+\t\tbool b = candidate->is_concrete ();\n+\t\tbool both_generic = !a && !b;\n+\t\tif (both_generic)\n+\t\t  {\n+\t\t    if (!query->is_equal (*candidate))\n+\t\t      continue;\n+\t\t  }\n+\n+\t\tpossible_collision (it->second, iy->second);\n+\t      }\n \t  }\n       }\n   }\n@@ -152,8 +171,8 @@ class OverlappingImplItemPass : public TypeCheckBase\n   void collision_detected (HIR::ImplItem *query, HIR::ImplItem *dup,\n \t\t\t   const std::string &name)\n   {\n-    RichLocation r (query->get_locus ());\n-    r.add_range (dup->get_locus ());\n+    RichLocation r (dup->get_locus ());\n+    r.add_range (query->get_locus ());\n     rust_error_at (r, \"duplicate definitions with name %s\", name.c_str ());\n   }\n "}, {"sha": "fda505aa84e5d43dd86fec8ce70563c27c5107e0", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -284,7 +284,10 @@ class PathProbeType : public TypeCheckBase\n       return;\n \n     if (!receiver->can_eq (impl_block_ty, false))\n-      return;\n+      {\n+\tif (!impl_block_ty->can_eq (receiver, false))\n+\t  return;\n+      }\n \n     // lets visit the impl_item\n     item->accept_vis (*this);"}, {"sha": "b34db3bd44e3e5615a7c0e3010fc9b89da84c844", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -41,7 +41,10 @@ TypeBoundsProbe::scan ()\n \treturn true;\n \n       if (!receiver->can_eq (impl_type, false))\n-\treturn true;\n+\t{\n+\t  if (!impl_type->can_eq (receiver, false))\n+\t    return true;\n+\t}\n \n       possible_trait_paths.push_back ({impl->get_trait_ref ().get (), impl});\n       return true;"}, {"sha": "34c89639f6f1c7afa40de104f2b9293733ed83e1", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -886,8 +886,6 @@ class ArrayCmp : public BaseCmp\n     ok = true;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const ArrayType *base;\n@@ -916,8 +914,6 @@ class SliceCmp : public BaseCmp\n     ok = true;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const SliceType *base;\n@@ -939,8 +935,6 @@ class BoolCmp : public BaseCmp\n     ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const BoolType *base;\n@@ -965,8 +959,6 @@ class IntCmp : public BaseCmp\n     ok = type.get_int_kind () == base->get_int_kind ();\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const IntType *base;\n@@ -991,8 +983,6 @@ class UintCmp : public BaseCmp\n     ok = type.get_uint_kind () == base->get_uint_kind ();\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const UintType *base;\n@@ -1017,8 +1007,6 @@ class FloatCmp : public BaseCmp\n     ok = type.get_float_kind () == base->get_float_kind ();\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const FloatType *base;\n@@ -1120,8 +1108,6 @@ class TupleCmp : public BaseCmp\n     ok = true;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const TupleType *base;\n@@ -1143,8 +1129,6 @@ class USizeCmp : public BaseCmp\n \n   void visit (const USizeType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const USizeType *base;\n@@ -1166,8 +1150,6 @@ class ISizeCmp : public BaseCmp\n \n   void visit (const ISizeType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const ISizeType *base;\n@@ -1189,8 +1171,6 @@ class CharCmp : public BaseCmp\n \n   void visit (const CharType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const CharType *base;\n@@ -1365,8 +1345,6 @@ class StrCmp : public BaseCmp\n \n   void visit (const StrType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const StrType *base;\n@@ -1383,8 +1361,6 @@ class NeverCmp : public BaseCmp\n \n   void visit (const NeverType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const NeverType *base;\n@@ -1478,8 +1454,6 @@ class DynamicCmp : public BaseCmp\n     ok = base->bounds_compatible (type, ref_locus, false);\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n "}, {"sha": "7bacc4c0f01b807b7ae2e00733fe07caf525cccf", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -754,6 +754,7 @@ Mappings::insert_macro_def (AST::MacroRulesDefinition *macro)\n       {\"include_bytes\", MacroBuiltin::include_bytes},\n       {\"include_str\", MacroBuiltin::include_str},\n       {\"compile_error\", MacroBuiltin::compile_error},\n+      {\"concat\", MacroBuiltin::concat},\n     };\n \n   auto builtin = builtin_macros.find (macro->get_rule_name ());"}, {"sha": "27faa7f4254dd7f74f4d2bfe922fb88d74fcf72c", "filename": "gcc/rust/util/rust-mapping-common.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Futil%2Frust-mapping-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Frust%2Futil%2Frust-mapping-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-mapping-common.h?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -50,6 +50,15 @@ struct DefId\n     return ((uint64_t) this->crateNum << 32 | this->localDefId)\n \t   < ((uint64_t) other.crateNum << 32 | other.localDefId);\n   }\n+\n+  std::string as_string () const\n+  {\n+    std::string buf;\n+    buf += std::to_string (crateNum);\n+    buf += \" \"; // or anything else\n+    buf += std::to_string (localDefId);\n+    return buf;\n+  }\n };\n \n #define UNKNOWN_CREATENUM ((uint32_t) (0))"}, {"sha": "1fcd65fd648fc8535d562ea68fa4c6cacd28f4f6", "filename": "gcc/testsuite/rust/compile/builtin_macro_concat.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_concat.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_concat.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_concat.rs?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -0,0 +1,15 @@\n+macro_rules! concat {\n+  () => {{}};\n+}\n+\n+fn main () {\n+  let not_literal = \"identifier\";\n+  concat! ();\n+  concat! (,); // { dg-error \"argument must be a constant literal\" }\n+  concat! (not_literal); // { dg-error \"argument must be a constant literal\" }\n+  concat! (\"message\");\n+  concat! (\"message\",);\n+  concat! (\"message\",1, true, false, 1.0, 10usize, 2000u64);\n+  concat! (\"message\",1, true, false, 1.0, 10usize, 2000u64,);\n+  concat! (\"m\", not_literal); // { dg-error \"argument must be a constant literal\" }\n+}"}, {"sha": "2a41632e693a6df235170416087065c88c93765e", "filename": "gcc/testsuite/rust/compile/generics7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -15,7 +15,7 @@ impl Foo<char> {\n }\n \n impl<T> Foo<T> {\n-    fn bar(self) -> T { // { dg-error \"duplicate definitions with name bar\" }\n+    fn bar(self) -> T {\n         self.a\n     }\n }"}, {"sha": "ceefc5d2c6a3e51fdb8126746027cb201b8a6341", "filename": "gcc/testsuite/rust/compile/generics8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics8.rs?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -1,7 +1,7 @@\n struct Foo<A, B>(A, B);\n \n impl<T> Foo<i32, T> {\n-    fn test(a: T) -> T { // { dg-error \"duplicate definitions with name test\" }\n+    fn test(a: T) -> T {\n         a\n     }\n }"}, {"sha": "3bd6321a9408df29130fb8b7777d7ded8eea92e1", "filename": "gcc/testsuite/rust/compile/torture/issue-1075.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1075.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1075.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1075.rs?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -0,0 +1,42 @@\n+// { dg-additional-options \"-w\" }\n+extern \"rust-intrinsic\" {\n+    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+\n+struct FatPtr<T> {\n+    data: *const T,\n+    len: usize,\n+}\n+\n+union Repr<T> {\n+    rust: *const [T],\n+    rust_mut: *mut [T],\n+    raw: FatPtr<T>,\n+}\n+\n+impl<T> *const [T] {\n+    pub const fn len(self) -> usize {\n+        // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n+        // Only `std` can make this guarantee.\n+        let a = unsafe { Repr { rust: self }.raw };\n+        a.len\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+impl<T> *const T {\n+    pub const unsafe fn offset(self, count: isize) -> *const T {\n+        unsafe { offset(self, count) }\n+    }\n+\n+    pub const unsafe fn add(self, count: usize) -> Self {\n+        unsafe { self.offset(count as isize) }\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}"}, {"sha": "ca405857320b8c7ecf589f95b9c17da7f311d709", "filename": "gcc/testsuite/rust/execute/torture/builtin_macro_concat.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_concat.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2669e80c17f4c9d8b534c73ae0c60a51de0b4659/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_concat.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_concat.rs?ref=2669e80c17f4c9d8b534c73ae0c60a51de0b4659", "patch": "@@ -0,0 +1,23 @@\n+// { dg-output \"\\ntest10btrue2.15\\ntest10bfalse2.151\\n\" }\n+macro_rules! concat {\n+    () => {{}};\n+}\n+\n+extern \"C\" {\n+    fn printf(fmt: *const i8, ...);\n+}\n+\n+fn print(s: &str) {\n+    printf(\"%s\\n\" as *const str as *const i8, s as *const str as *const i8);\n+}\n+\n+fn main() -> i32 {\n+    let a = concat!();\n+    let b = concat!(\"test\", 10, 'b', true, 2.15);\n+    let c = concat!(\"test\", 10, 'b', false, 2.15, 1u64);\n+    print(a);\n+    print(b);\n+    print(c);\n+\n+    0\n+}"}]}