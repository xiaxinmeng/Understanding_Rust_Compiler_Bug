{"sha": "4d54539c8fa94d78298746efe4a18e909a440457", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ1NDUzOWM4ZmE5NGQ3ODI5ODc0NmVmZTRhMThlOTA5YTQ0MDQ1Nw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-12-18T20:23:04Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-12-18T20:23:04Z"}, "message": "stl_list.h: Formatting tweaks.\n\n\n2003-12-18  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/stl_list.h: Formatting tweaks.\n\t* include/bits/list.tcc: Same.\n\nFrom-SVN: r74795", "tree": {"sha": "b3423f1d8307fa0e8f3431a9783fde30878792c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3423f1d8307fa0e8f3431a9783fde30878792c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d54539c8fa94d78298746efe4a18e909a440457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d54539c8fa94d78298746efe4a18e909a440457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d54539c8fa94d78298746efe4a18e909a440457", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d54539c8fa94d78298746efe4a18e909a440457/comments", "author": null, "committer": null, "parents": [{"sha": "91d39d71c8fa67c9aca4f30f65a06683b866d371", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d39d71c8fa67c9aca4f30f65a06683b866d371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d39d71c8fa67c9aca4f30f65a06683b866d371"}], "stats": {"total": 1694, "additions": 856, "deletions": 838}, "files": [{"sha": "faba7f1f964dab6f920507e24642360cfb517ec4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d54539c8fa94d78298746efe4a18e909a440457/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d54539c8fa94d78298746efe4a18e909a440457/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4d54539c8fa94d78298746efe4a18e909a440457", "patch": "@@ -1,3 +1,8 @@\n+2003-12-18  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/stl_list.h: Formatting tweaks.\n+\t* include/bits/list.tcc: Same.\n+\n 2003-12-18  Matt Austern  <austern@apple.com>\n \n \t* include/bits/demangle.h: Fix allocator type correctness,"}, {"sha": "a4f7c18dffa5638881af3baf6b0dbf6564e8eaba", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d54539c8fa94d78298746efe4a18e909a440457/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d54539c8fa94d78298746efe4a18e909a440457/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=4d54539c8fa94d78298746efe4a18e909a440457", "patch": "@@ -66,7 +66,7 @@ namespace __gnu_norm\n   template<typename _Tp, typename _Alloc>\n     void\n     _List_base<_Tp,_Alloc>::\n-    __clear()\n+    _M_clear()\n     {\n       typedef _List_node<_Tp>  _Node;\n       _Node* __cur = static_cast<_Node*>(this->_M_node._M_next);\n@@ -92,7 +92,8 @@ namespace __gnu_norm\n           this->_M_node._M_next = __x._M_node._M_next;\n           this->_M_node._M_prev = __x._M_node._M_prev;\n           \n-          this->_M_node._M_next->_M_prev = this->_M_node._M_prev->_M_next = &this->_M_node;\n+\t  this->_M_node._M_prev->_M_next = &this->_M_node;\n+          this->_M_node._M_next->_M_prev = this->_M_node._M_prev->_M_next;\n           __x._M_node._M_next = __x._M_node._M_prev = &__x._M_node;\n         }\n       }\n@@ -101,16 +102,19 @@ namespace __gnu_norm\n         __x._M_node._M_next = this->_M_node._M_next;\n         __x._M_node._M_prev = this->_M_node._M_prev;\n         \n-        __x._M_node._M_next->_M_prev = __x._M_node._M_prev->_M_next = &__x._M_node;\n+\t__x._M_node._M_prev->_M_next = &__x._M_node;\n+        __x._M_node._M_next->_M_prev = __x._M_node._M_prev->_M_next;\n         this->_M_node._M_next = this->_M_node._M_prev = &this->_M_node;\n       }\n       else\n       {\n         std::swap(this->_M_node._M_next,__x._M_node._M_next);\n         std::swap(this->_M_node._M_prev,__x._M_node._M_prev);\n       \n-        this->_M_node._M_next->_M_prev = this->_M_node._M_prev->_M_next = &this->_M_node;\n-        __x._M_node._M_next->_M_prev = __x._M_node._M_prev->_M_next = &__x._M_node;\n+\tthis->_M_node._M_prev->_M_next = &this->_M_node;\n+        this->_M_node._M_next->_M_prev = this->_M_node._M_prev->_M_next;\n+\t__x._M_node._M_prev->_M_next = &__x._M_node;\n+        __x._M_node._M_next->_M_prev = __x._M_node._M_prev->_M_next;\n       } \n     }\n  \n@@ -196,11 +200,13 @@ namespace __gnu_norm\n     template <typename _InputIterator>\n       void\n       list<_Tp,_Alloc>::\n-      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, __false_type)\n+      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, \n+\t\t\t __false_type)\n       {\n         iterator __first1 = begin();\n         iterator __last1 = end();\n-        for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n+        for (; __first1 != __last1 && __first2 != __last2; \n+\t     ++__first1, ++__first2)\n           *__first1 = *__first2;\n         if (__first2 == __last2)\n           erase(__first1, __last1);\n@@ -276,10 +282,12 @@ namespace __gnu_norm\n   __List_base_reverse(_List_node_base* __p)\n   {\n     _List_node_base* __tmp = __p;\n-    do {\n-      std::swap(__tmp->_M_next, __tmp->_M_prev);\n-      __tmp = __tmp->_M_prev;     // Old next node is now prev.\n-    } while (__tmp != __p);\n+    do \n+      {\n+\tstd::swap(__tmp->_M_next, __tmp->_M_prev);\n+\t__tmp = __tmp->_M_prev;     // Old next node is now prev.\n+      } \n+    while (__tmp != __p);\n   }\n   \n   template<typename _Tp, typename _Alloc>"}, {"sha": "a9513f1656a01e07feec86fe20d1b280fa27dfb8", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 832, "deletions": 827, "changes": 1659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d54539c8fa94d78298746efe4a18e909a440457/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d54539c8fa94d78298746efe4a18e909a440457/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=4d54539c8fa94d78298746efe4a18e909a440457", "patch": "@@ -80,9 +80,9 @@ namespace __gnu_norm\n   /// @if maint An actual node in the %list.  @endif\n   template<typename _Tp>\n     struct _List_node : public _List_node_base\n-  {\n-    _Tp _M_data;                ///< User's data.\n-  };\n+    {\n+      _Tp _M_data;                ///< User's data.\n+    };\n   \n   \n   /**\n@@ -104,11 +104,9 @@ namespace __gnu_norm\n     _List_node_base* _M_node;\n   \n     _List_iterator_base(_List_node_base* __x)\n-    : _M_node(__x)\n-    { }\n+    : _M_node(__x) { }\n   \n-    _List_iterator_base()\n-    { }\n+    _List_iterator_base() { }\n   \n     /// Walk the %list forward.\n     void\n@@ -141,127 +139,126 @@ namespace __gnu_norm\n   */\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     struct _List_iterator : public _List_iterator_base\n-  {\n-    typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-    typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-    typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n-  \n-    typedef _Tp                                       value_type;\n-    typedef _Ptr                                      pointer;\n-    typedef _Ref                                      reference;\n-    typedef _List_node<_Tp>                           _Node;\n-  \n-    _List_iterator(_Node* __x)\n-    : _List_iterator_base(__x)\n-    { }\n-  \n-    _List_iterator()\n-    { }\n-  \n-    _List_iterator(const iterator& __x)\n-    : _List_iterator_base(__x._M_node)\n-    { }\n-  \n-    reference\n-    operator*() const\n-    { return static_cast<_Node*>(_M_node)->_M_data; }\n-    // Must downcast from List_node_base to _List_node to get to _M_data.\n-  \n-    pointer\n-    operator->() const\n-    { return &(operator*()); }\n-  \n-    _Self&\n-    operator++()\n     {\n-      this->_M_incr();\n-      return *this;\n-    }\n-  \n-    _Self\n-    operator++(int)\n-    {\n-      _Self __tmp = *this;\n-      this->_M_incr();\n-      return __tmp;\n-    }\n-  \n-    _Self&\n-    operator--()\n-    {\n-      this->_M_decr();\n-      return *this;\n-    }\n-  \n-    _Self\n-    operator--(int)\n-    {\n-      _Self __tmp = *this;\n-      this->_M_decr();\n+      typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+      typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+      typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n+      \n+      typedef _Tp                                       value_type;\n+      typedef _Ptr                                      pointer;\n+      typedef _Ref                                      reference;\n+      typedef _List_node<_Tp>                           _Node;\n+      \n+      _List_iterator(_Node* __x)\n+      : _List_iterator_base(__x) { }\n+  \n+      _List_iterator() { }\n+      \n+      _List_iterator(const iterator& __x)\n+      : _List_iterator_base(__x._M_node) { }\n+  \n+      // Must downcast from List_node_base to _List_node to get to _M_data.\n+      reference\n+      operator*() const\n+      { return static_cast<_Node*>(_M_node)->_M_data; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+      \n+      _Self&\n+      operator++()\n+      {\n+\tthis->_M_incr();\n+\treturn *this;\n+      }\n+      \n+      _Self\n+      operator++(int)\n+      {\n+\t_Self __tmp = *this;\n+\tthis->_M_incr();\n+\treturn __tmp;\n+      }\n+      \n+      _Self&\n+      operator--()\n+      {\n+\tthis->_M_decr();\n+\treturn *this;\n+      }\n+      \n+      _Self\n+      operator--(int)\n+      {\n+\t_Self __tmp = *this;\n+\tthis->_M_decr();\n       return __tmp;\n-    }\n-  };\n+      }\n+    };\n   \n   /**\n    *  @if maint\n    *  See bits/stl_deque.h's _Deque_base for an explanation.\n    *  @endif\n   */\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     class _List_base\n     : public _Alloc::template rebind<_List_node<_Tp> >::other\n-  {\n-  protected:\n-    // NOTA BENE\n-    // The stored instance is not actually of \"allocator_type\"'s type.\n-    // Instead we rebind the type to Allocator<List_node<Tp>>, which\n-    // according to [20.1.5]/4 should probably be the same.\n-    // List_node<Tp> is not the same size as Tp (it's two pointers\n-    // larger), and specializations on Tp may go unused because\n-    // List_node<Tp> is being bound instead.\n-    //\n-    // We put this to the test in the constructors and in get_allocator,\n-    // where we use conversions between allocator_type and \n-    // _Node_Alloc_type. The conversion is required by table 32 in [20.1.5].\n-    typedef typename _Alloc::template rebind<_List_node<_Tp> >::other\n+    {\n+    protected:\n+      // NOTA BENE\n+      // The stored instance is not actually of \"allocator_type\"'s\n+      // type.  Instead we rebind the type to\n+      // Allocator<List_node<Tp>>, which according to [20.1.5]/4\n+      // should probably be the same.  List_node<Tp> is not the same\n+      // size as Tp (it's two pointers larger), and specializations on\n+      // Tp may go unused because List_node<Tp> is being bound\n+      // instead.\n+      //\n+      // We put this to the test in the constructors and in\n+      // get_allocator, where we use conversions between\n+      // allocator_type and _Node_Alloc_type. The conversion is\n+      // required by table 32 in [20.1.5].\n+      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other\n       _Node_Alloc_type;\n \n-    _List_node<_Tp>*\n-    _M_get_node()\n-    { return _Node_Alloc_type::allocate(1); }\n+      _List_node_base _M_node;\n \n-    void\n-    _M_put_node(_List_node<_Tp>* __p)\n-    { _Node_Alloc_type::deallocate(__p, 1); }\n+      _List_node<_Tp>*\n+      _M_get_node()\n+      { return _Node_Alloc_type::allocate(1); }\n+      \n+      void\n+      _M_put_node(_List_node<_Tp>* __p)\n+      { _Node_Alloc_type::deallocate(__p, 1); }\n \n-    _List_node_base _M_node;\n   public:\n-    typedef _Alloc allocator_type;\n-    allocator_type get_allocator() const\n+      typedef _Alloc allocator_type;\n \n-    { return allocator_type(*static_cast<const _Node_Alloc_type*>(this)); }\n+      allocator_type \n+      get_allocator() const\n+      { return allocator_type(*static_cast<const _Node_Alloc_type*>(this)); }\n \n-    _List_base(const allocator_type& __a)\n-    : _Node_Alloc_type(__a)\n-    {\n-      this->_M_node._M_next = &this->_M_node;\n-      this->_M_node._M_prev = &this->_M_node;\n-    }\n-  \n-    // This is what actually destroys the list.\n-    ~_List_base()\n-    {\n-      __clear();\n-    }\n+      _List_base(const allocator_type& __a)\n+      : _Node_Alloc_type(__a)\n+      {\n+\tthis->_M_node._M_next = &this->_M_node;\n+\tthis->_M_node._M_prev = &this->_M_node;\n+      }\n   \n-    void\n-    __clear();\n-  };\n+      // This is what actually destroys the list.\n+      ~_List_base()\n+      { _M_clear(); }\n+      \n+      void\n+      _M_clear();\n+    };\n   \n   \n   /**\n-   *  @brief  A standard container with linear time access to elements, and\n-   *  fixed time insertion/deletion at any point in the sequence.\n+   *  @brief A standard container with linear time access to elements,\n+   *  and fixed time insertion/deletion at any point in the sequence.\n    *\n    *  @ingroup Containers\n    *  @ingroup Sequences\n@@ -306,761 +303,768 @@ namespace __gnu_norm\n   */\n   template<typename _Tp, typename _Alloc = allocator<_Tp> >\n     class list : protected _List_base<_Tp, _Alloc>\n-  {\n-    // concept requirements\n-    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-  \n-    typedef _List_base<_Tp, _Alloc>                       _Base;\n-  \n-  public:\n-    typedef _Tp                                           value_type;\n-    typedef value_type*                                   pointer;\n-    typedef const value_type*                             const_pointer;\n-    typedef _List_iterator<_Tp,_Tp&,_Tp*>                 iterator;\n-    typedef _List_iterator<_Tp,const _Tp&,const _Tp*>     const_iterator;\n-    typedef std::reverse_iterator<const_iterator>         const_reverse_iterator;\n-    typedef std::reverse_iterator<iterator>               reverse_iterator;\n-    typedef value_type&                                   reference;\n-    typedef const value_type&                             const_reference;\n-    typedef size_t                                        size_type;\n-    typedef ptrdiff_t                                     difference_type;\n-    typedef typename _Base::allocator_type                allocator_type;\n-  \n-  protected:\n-    // Note that pointers-to-_Node's can be ctor-converted to iterator types.\n-    typedef _List_node<_Tp>                               _Node;\n-  \n-    /** @if maint\n-     *  One data member plus two memory-handling functions.  If the _Alloc\n-     *  type requires separate instances, then one of those will also be\n-     *  included, accumulated from the topmost parent.\n-     *  @endif\n-    */\n-    using _Base::_M_node;\n-    using _Base::_M_put_node;\n-    using _Base::_M_get_node;\n-  \n-    /**\n-     *  @if maint\n-     *  @param  x  An instance of user data.\n-     *\n-     *  Allocates space for a new node and constructs a copy of @a x in it.\n-     *  @endif\n-    */\n-    _Node*\n-    _M_create_node(const value_type& __x)\n     {\n-      _Node* __p = this->_M_get_node();\n-      try {\n-        std::_Construct(&__p->_M_data, __x);\n-      }\n-      catch(...)\n+      // concept requirements\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+  \n+      typedef _List_base<_Tp, _Alloc>                   _Base;\n+  \n+    public:\n+      typedef _Tp                                       value_type;\n+      typedef value_type*                               pointer;\n+      typedef const value_type*                         const_pointer;\n+      typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+      typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+      typedef std::reverse_iterator<const_iterator>     const_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>           reverse_iterator;\n+      typedef value_type&                               reference;\n+      typedef const value_type&                         const_reference;\n+      typedef size_t                                    size_type;\n+      typedef ptrdiff_t                                 difference_type;\n+      typedef typename _Base::allocator_type            allocator_type;\n+  \n+    protected:\n+      // Note that pointers-to-_Node's can be ctor-converted to\n+      // iterator types.\n+      typedef _List_node<_Tp>               \t\t_Node;\n+  \n+      /** @if maint\n+       *  One data member plus two memory-handling functions.  If the\n+       *  _Alloc type requires separate instances, then one of those\n+       *  will also be included, accumulated from the topmost parent.\n+       *  @endif\n+       */\n+      using _Base::_M_node;\n+      using _Base::_M_put_node;\n+      using _Base::_M_get_node;\n+      \n+      /**\n+       *  @if maint\n+       *  @param  x  An instance of user data.\n+       *\n+       *  Allocates space for a new node and constructs a copy of @a x in it.\n+       *  @endif\n+       */\n+      _Node*\n+      _M_create_node(const value_type& __x)\n       {\n-        _M_put_node(__p);\n-        __throw_exception_again;\n+\t_Node* __p = this->_M_get_node();\n+\ttry \n+\t  {\n+\t    std::_Construct(&__p->_M_data, __x);\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    _M_put_node(__p);\n+\t    __throw_exception_again;\n+\t  }\n+\treturn __p;\n       }\n-      return __p;\n-    }\n   \n-    /**\n-     *  @if maint\n-     *  Allocates space for a new node and default-constructs a new instance\n-     *  of @c value_type in it.\n-     *  @endif\n-    */\n-    _Node*\n-    _M_create_node()\n-    {\n-      _Node* __p = this->_M_get_node();\n-      try {\n-        std::_Construct(&__p->_M_data);\n-      }\n-      catch(...)\n+      /**\n+       *  @if maint\n+       *  Allocates space for a new node and default-constructs a new\n+       *  instance of @c value_type in it.\n+       *  @endif\n+       */\n+      _Node*\n+      _M_create_node()\n       {\n-        _M_put_node(__p);\n-        __throw_exception_again;\n+\t_Node* __p = this->_M_get_node();\n+\ttry \n+\t  {\n+\t    std::_Construct(&__p->_M_data);\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    _M_put_node(__p);\n+\t    __throw_exception_again;\n+\t  }\n+\treturn __p;\n       }\n-      return __p;\n-    }\n-  \n-  public:\n-    // [23.2.2.1] construct/copy/destroy\n-    // (assign() and get_allocator() are also listed in this section)\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    explicit\n-    list(const allocator_type& __a = allocator_type())\n-    : _Base(__a) { }\n-  \n-    /**\n-     *  @brief  Create a %list with copies of an exemplar element.\n-     *  @param  n  The number of elements to initially create.\n-     *  @param  value  An element to copy.\n-     * \n-     *  This constructor fills the %list with @a n copies of @a value.\n-    */\n-    list(size_type __n, const value_type& __value,\n-         const allocator_type& __a = allocator_type())\n+      \n+    public:\n+      // [23.2.2.1] construct/copy/destroy\n+      // (assign() and get_allocator() are also listed in this section)\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      explicit\n+      list(const allocator_type& __a = allocator_type())\n+      : _Base(__a) { }\n+  \n+      /**\n+       *  @brief  Create a %list with copies of an exemplar element.\n+       *  @param  n  The number of elements to initially create.\n+       *  @param  value  An element to copy.\n+       * \n+       *  This constructor fills the %list with @a n copies of @a value.\n+       */\n+      list(size_type __n, const value_type& __value,\n+\t   const allocator_type& __a = allocator_type())\n       : _Base(__a)\n       { this->insert(begin(), __n, __value); }\n   \n-    /**\n-     *  @brief  Create a %list with default elements.\n-     *  @param  n  The number of elements to initially create.\n-     * \n-     *  This constructor fills the %list with @a n copies of a\n-     *  default-constructed element.\n-    */\n-    explicit\n-    list(size_type __n)\n+      /**\n+       *  @brief  Create a %list with default elements.\n+       *  @param  n  The number of elements to initially create.\n+       * \n+       *  This constructor fills the %list with @a n copies of a\n+       *  default-constructed element.\n+       */\n+      explicit\n+      list(size_type __n)\n       : _Base(allocator_type())\n       { this->insert(begin(), __n, value_type()); }\n   \n-    /**\n-     *  @brief  %List copy constructor.\n-     *  @param  x  A %list of identical element and allocator types.\n-     * \n-     *  The newly-created %list uses a copy of the allocation object used\n-     *  by @a x.\n-    */\n-    list(const list& __x)\n+      /**\n+       *  @brief  %List copy constructor.\n+       *  @param  x  A %list of identical element and allocator types.\n+       * \n+       *  The newly-created %list uses a copy of the allocation object used\n+       *  by @a x.\n+       */\n+      list(const list& __x)\n       : _Base(__x.get_allocator())\n       { this->insert(begin(), __x.begin(), __x.end()); }\n-  \n-    /**\n-     *  @brief  Builds a %list from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     * \n-     *  Create a %list consisting of copies of the elements from\n-     *  [@a first,@a last).  This is linear in N (where N is\n-     *  distance(@a first,@a last)).\n-     *\n-     *  @if maint\n-     *  We don't need any dispatching tricks here, because insert does all of\n-     *  that anyway.\n-     *  @endif\n-    */\n-    template<typename _InputIterator>\n-      list(_InputIterator __first, _InputIterator __last,\n-           const allocator_type& __a = allocator_type())\n-      : _Base(__a)\n-      { this->insert(begin(), __first, __last); }\n-  \n-    /**\n-     *  No explicit dtor needed as the _Base dtor takes care of\n-     *  things.  The _Base dtor only erases the elements, and note\n-     *  that if the elements themselves are pointers, the pointed-to\n-     *  memory is not touched in any way.  Managing the pointer is the\n-     *  user's responsibilty.\n-    */\n-  \n-    /**\n-     *  @brief  %List assignment operator.\n-     *  @param  x  A %list of identical element and allocator types.\n-     * \n-     *  All the elements of @a x are copied, but unlike the copy\n-     *  constructor, the allocator object is not copied.\n-    */\n-    list&\n-    operator=(const list& __x);\n-  \n-    /**\n-     *  @brief  Assigns a given value to a %list.\n-     *  @param  n  Number of elements to be assigned.\n-     *  @param  val  Value to be assigned.\n-     *\n-     *  This function fills a %list with @a n copies of the given\n-     *  value.  Note that the assignment completely changes the %list\n-     *  and that the resulting %list's size is the same as the number\n-     *  of elements assigned.  Old data may be lost.\n-    */\n-    void\n-    assign(size_type __n, const value_type& __val) \n-    { _M_fill_assign(__n, __val); }\n-  \n-    /**\n-     *  @brief  Assigns a range to a %list.\n-     *  @param  first  An input iterator.\n-     *  @param  last   An input iterator.\n-     *\n-     *  This function fills a %list with copies of the elements in the\n-     *  range [@a first,@a last).\n-     *\n-     *  Note that the assignment completely changes the %list and that the\n-     *  resulting %list's size is the same as the number of elements assigned.\n-     *  Old data may be lost.\n-    */\n-    template<typename _InputIterator>\n+      \n+      /**\n+       *  @brief  Builds a %list from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       * \n+       *  Create a %list consisting of copies of the elements from\n+       *  [@a first,@a last).  This is linear in N (where N is\n+       *  distance(@a first,@a last)).\n+       *\n+       *  @if maint\n+       *  We don't need any dispatching tricks here, because insert does all of\n+       *  that anyway.\n+       *  @endif\n+       */\n+      template<typename _InputIterator>\n+        list(_InputIterator __first, _InputIterator __last,\n+\t     const allocator_type& __a = allocator_type())\n+        : _Base(__a)\n+        { this->insert(begin(), __first, __last); }\n+  \n+      /**\n+       *  No explicit dtor needed as the _Base dtor takes care of\n+       *  things.  The _Base dtor only erases the elements, and note\n+       *  that if the elements themselves are pointers, the pointed-to\n+       *  memory is not touched in any way.  Managing the pointer is\n+       *  the user's responsibilty.\n+       */\n+  \n+      /**\n+       *  @brief  %List assignment operator.\n+       *  @param  x  A %list of identical element and allocator types.\n+       * \n+       *  All the elements of @a x are copied, but unlike the copy\n+       *  constructor, the allocator object is not copied.\n+       */\n+      list&\n+      operator=(const list& __x);\n+      \n+      /**\n+       *  @brief  Assigns a given value to a %list.\n+       *  @param  n  Number of elements to be assigned.\n+       *  @param  val  Value to be assigned.\n+       *\n+       *  This function fills a %list with @a n copies of the given\n+       *  value.  Note that the assignment completely changes the %list\n+       *  and that the resulting %list's size is the same as the number\n+       *  of elements assigned.  Old data may be lost.\n+       */\n+      void\n+      assign(size_type __n, const value_type& __val) \n+      { _M_fill_assign(__n, __val); }\n+      \n+      /**\n+       *  @brief  Assigns a range to a %list.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *\n+       *  This function fills a %list with copies of the elements in the\n+       *  range [@a first,@a last).\n+       *\n+       *  Note that the assignment completely changes the %list and\n+       *  that the resulting %list's size is the same as the number of\n+       *  elements assigned.  Old data may be lost.\n+       */\n+      template<typename _InputIterator>\n+        void\n+        assign(_InputIterator __first, _InputIterator __last)\n+        { \n+\t  // Check whether it's an integral type.  If so, it's not an iterator.\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_assign_dispatch(__first, __last, _Integral());\n+\t}\n+  \n+      /// Get a copy of the memory allocation object.\n+      allocator_type\n+      get_allocator() const { return _Base::get_allocator(); }\n+      \n+      // iterators\n+      /**\n+       *  Returns a read/write iterator that points to the first element in the\n+       *  %list.  Iteration is done in ordinary element order.\n+       */\n+      iterator\n+      begin() { return static_cast<_Node*>(this->_M_node._M_next); }\n+      \n+      /**\n+       *  Returns a read-only (constant) iterator that points to the\n+       *  first element in the %list.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      const_iterator\n+      begin() const { return static_cast<_Node*>(this->_M_node._M_next); }\n+      \n+      /**\n+       *  Returns a read/write iterator that points one past the last\n+       *  element in the %list.  Iteration is done in ordinary element\n+       *  order.\n+       */\n+      iterator\n+      end() { return static_cast<_Node*>(&this->_M_node); }\n+      \n+      /**\n+       *  Returns a read-only (constant) iterator that points one past\n+       *  the last element in the %list.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      const_iterator\n+      end() const \n+      { return const_cast<_Node*>(static_cast<const _Node*>(&this->_M_node)); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to the last\n+       *  element in the %list.  Iteration is done in reverse element\n+       *  order.\n+       */\n+      reverse_iterator\n+      rbegin() { return reverse_iterator(end()); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to\n+       *  the last element in the %list.  Iteration is done in reverse\n+       *  element order.\n+       */\n+      const_reverse_iterator\n+      rbegin() const { return const_reverse_iterator(end()); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to one\n+       *  before the first element in the %list.  Iteration is done in\n+       *  reverse element order.\n+       */\n+      reverse_iterator\n+      rend() { return reverse_iterator(begin()); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to one\n+       *  before the first element in the %list.  Iteration is done in reverse\n+       *  element order.\n+       */\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+      \n+      // [23.2.2.2] capacity\n+      /**\n+       *  Returns true if the %list is empty.  (Thus begin() would equal\n+       *  end().)\n+       */\n+      bool\n+      empty() const { return this->_M_node._M_next == &this->_M_node; }\n+      \n+      /**  Returns the number of elements in the %list.  */\n+      size_type\n+      size() const { return std::distance(begin(), end()); }\n+      \n+      /**  Returns the size() of the largest possible %list.  */\n+      size_type\n+      max_size() const { return size_type(-1); }\n+      \n+      /**\n+       *  @brief Resizes the %list to the specified number of elements.\n+       *  @param new_size Number of elements the %list should contain.\n+       *  @param x Data with which new elements should be populated.\n+       *\n+       *  This function will %resize the %list to the specified number\n+       *  of elements.  If the number is smaller than the %list's\n+       *  current size the %list is truncated, otherwise the %list is\n+       *  extended and new elements are populated with given data.\n+       */\n+      void\n+      resize(size_type __new_size, const value_type& __x);\n+      \n+      /**\n+       *  @brief  Resizes the %list to the specified number of elements.\n+       *  @param  new_size  Number of elements the %list should contain.\n+       *\n+       *  This function will resize the %list to the specified number of\n+       *  elements.  If the number is smaller than the %list's current\n+       *  size the %list is truncated, otherwise the %list is extended\n+       *  and new elements are default-constructed.\n+       */\n+      void\n+      resize(size_type __new_size) { this->resize(__new_size, value_type()); }\n+      \n+      // element access\n+      /**\n+       *  Returns a read/write reference to the data at the first\n+       *  element of the %list.\n+       */\n+      reference\n+      front() { return *begin(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the first\n+       *  element of the %list.\n+       */\n+      const_reference\n+      front() const { return *begin(); }\n+      \n+      /**\n+       *  Returns a read/write reference to the data at the last element\n+       *  of the %list.\n+       */\n+      reference\n+      back() { return *(--end()); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the last\n+       *  element of the %list.\n+       */\n+      const_reference\n+      back() const { return *(--end()); }\n+      \n+      // [23.2.2.3] modifiers\n+      /**\n+       *  @brief  Add data to the front of the %list.\n+       *  @param  x  Data to be added.\n+       *\n+       *  This is a typical stack operation.  The function creates an\n+       *  element at the front of the %list and assigns the given data\n+       *  to it.  Due to the nature of a %list this operation can be\n+       *  done in constant time, and does not invalidate iterators and\n+       *  references.\n+       */\n       void\n-      assign(_InputIterator __first, _InputIterator __last)\n+      push_front(const value_type& __x) { this->insert(begin(), __x); }\n+  \n+      /**\n+       *  @brief  Removes first element.\n+       *\n+       *  This is a typical stack operation.  It shrinks the %list by\n+       *  one.  Due to the nature of a %list this operation can be done\n+       *  in constant time, and only invalidates iterators/references to\n+       *  the element being removed.\n+       *\n+       *  Note that no data is returned, and if the first element's data\n+       *  is needed, it should be retrieved before pop_front() is\n+       *  called.\n+       */\n+      void\n+      pop_front() { this->erase(begin()); }\n+      \n+      /**\n+       *  @brief  Add data to the end of the %list.\n+       *  @param  x  Data to be added.\n+       *\n+       *  This is a typical stack operation.  The function creates an\n+       *  element at the end of the %list and assigns the given data to\n+       *  it.  Due to the nature of a %list this operation can be done\n+       *  in constant time, and does not invalidate iterators and\n+       *  references.\n+       */\n+      void\n+      push_back(const value_type& __x) { this->insert(end(), __x); }\n+      \n+      /**\n+       *  @brief  Removes last element.\n+       *\n+       *  This is a typical stack operation.  It shrinks the %list by\n+       *  one.  Due to the nature of a %list this operation can be done\n+       *  in constant time, and only invalidates iterators/references to\n+       *  the element being removed.\n+       *\n+       *  Note that no data is returned, and if the last element's data\n+       *  is needed, it should be retrieved before pop_back() is called.\n+       */\n+      void\n+      pop_back()\n       {\n-        // Check whether it's an integral type.  If so, it's not an iterator.\n-        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-        _M_assign_dispatch(__first, __last, _Integral());\n+\titerator __tmp = end();\n+\tthis->erase(--__tmp);\n       }\n-  \n-    /// Get a copy of the memory allocation object.\n-    allocator_type\n-    get_allocator() const { return _Base::get_allocator(); }\n-  \n-    // iterators\n-    /**\n-     *  Returns a read/write iterator that points to the first element in the\n-     *  %list.  Iteration is done in ordinary element order.\n-    */\n-    iterator\n-    begin() { return static_cast<_Node*>(this->_M_node._M_next); }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points to the\n-     *  first element in the %list.  Iteration is done in ordinary\n-     *  element order.\n-    */\n-    const_iterator\n-    begin() const { return static_cast<_Node*>(this->_M_node._M_next); }\n-  \n-    /**\n-     *  Returns a read/write iterator that points one past the last\n-     *  element in the %list.  Iteration is done in ordinary element\n-     *  order.\n-    */\n-    iterator\n-    end() { return static_cast<_Node*>(&this->_M_node); }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points one past\n-     *  the last element in the %list.  Iteration is done in ordinary\n-     *  element order.\n-    */\n-    const_iterator\n-    end() const \n-    { return const_cast<_Node *>(static_cast<const _Node*>(&this->_M_node)); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to the last\n-     *  element in the %list.  Iteration is done in reverse element\n-     *  order.\n-    */\n-    reverse_iterator\n-    rbegin() { return reverse_iterator(end()); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to\n-     *  the last element in the %list.  Iteration is done in reverse\n-     *  element order.\n-    */\n-    const_reverse_iterator\n-    rbegin() const { return const_reverse_iterator(end()); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to one\n-     *  before the first element in the %list.  Iteration is done in\n-     *  reverse element order.\n-    */\n-    reverse_iterator\n-    rend() { return reverse_iterator(begin()); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to one\n-     *  before the first element in the %list.  Iteration is done in reverse\n-     *  element order.\n-    */\n-    const_reverse_iterator\n-    rend() const\n-    { return const_reverse_iterator(begin()); }\n-  \n-    // [23.2.2.2] capacity\n-    /**\n-     *  Returns true if the %list is empty.  (Thus begin() would equal\n-     *  end().)\n-    */\n-    bool\n-    empty() const { return this->_M_node._M_next == &this->_M_node; }\n-  \n-    /**  Returns the number of elements in the %list.  */\n-    size_type\n-    size() const { return std::distance(begin(), end()); }\n-  \n-    /**  Returns the size() of the largest possible %list.  */\n-    size_type\n-    max_size() const { return size_type(-1); }\n-  \n-    /**\n-     *  @brief Resizes the %list to the specified number of elements.\n-     *  @param new_size Number of elements the %list should contain.\n-     *  @param x Data with which new elements should be populated.\n-     *\n-     *  This function will %resize the %list to the specified number\n-     *  of elements.  If the number is smaller than the %list's\n-     *  current size the %list is truncated, otherwise the %list is\n-     *  extended and new elements are populated with given data.\n-    */\n-    void\n-    resize(size_type __new_size, const value_type& __x);\n-  \n-    /**\n-     *  @brief  Resizes the %list to the specified number of elements.\n-     *  @param  new_size  Number of elements the %list should contain.\n-     *\n-     *  This function will resize the %list to the specified number of\n-     *  elements.  If the number is smaller than the %list's current\n-     *  size the %list is truncated, otherwise the %list is extended\n-     *  and new elements are default-constructed.\n-    */\n-    void\n-    resize(size_type __new_size) { this->resize(__new_size, value_type()); }\n-  \n-    // element access\n-    /**\n-     *  Returns a read/write reference to the data at the first element of the\n-     *  %list.\n-    */\n-    reference\n-    front() { return *begin(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the first\n-     *  element of the %list.\n-    */\n-    const_reference\n-    front() const { return *begin(); }\n-  \n-    /**\n-     *  Returns a read/write reference to the data at the last element\n-     *  of the %list.\n-    */\n-    reference\n-    back() { return *(--end()); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the last\n-     *  element of the %list.\n-    */\n-    const_reference\n-    back() const { return *(--end()); }\n-  \n-    // [23.2.2.3] modifiers\n-    /**\n-     *  @brief  Add data to the front of the %list.\n-     *  @param  x  Data to be added.\n-     *\n-     *  This is a typical stack operation.  The function creates an\n-     *  element at the front of the %list and assigns the given data\n-     *  to it.  Due to the nature of a %list this operation can be\n-     *  done in constant time, and does not invalidate iterators and\n-     *  references.\n-    */\n-    void\n-    push_front(const value_type& __x) { this->insert(begin(), __x); }\n-  \n-    /**\n-     *  @brief  Removes first element.\n-     *\n-     *  This is a typical stack operation.  It shrinks the %list by\n-     *  one.  Due to the nature of a %list this operation can be done\n-     *  in constant time, and only invalidates iterators/references to\n-     *  the element being removed.\n-     *\n-     *  Note that no data is returned, and if the first element's data\n-     *  is needed, it should be retrieved before pop_front() is\n-     *  called.\n-    */\n-    void\n-    pop_front() { this->erase(begin()); }\n-  \n-    /**\n-     *  @brief  Add data to the end of the %list.\n-     *  @param  x  Data to be added.\n-     *\n-     *  This is a typical stack operation.  The function creates an\n-     *  element at the end of the %list and assigns the given data to\n-     *  it.  Due to the nature of a %list this operation can be done\n-     *  in constant time, and does not invalidate iterators and\n-     *  references.\n-    */\n-    void\n-    push_back(const value_type& __x) { this->insert(end(), __x); }\n-  \n-    /**\n-     *  @brief  Removes last element.\n-     *\n-     *  This is a typical stack operation.  It shrinks the %list by\n-     *  one.  Due to the nature of a %list this operation can be done\n-     *  in constant time, and only invalidates iterators/references to\n-     *  the element being removed.\n-     *\n-     *  Note that no data is returned, and if the last element's data\n-     *  is needed, it should be retrieved before pop_back() is called.\n-    */\n-    void\n-    pop_back()\n-    {\n-      iterator __tmp = end();\n-      this->erase(--__tmp);\n-    }\n-  \n-    /**\n-     *  @brief  Inserts given value into %list before specified iterator.\n-     *  @param  position  An iterator into the %list.\n-     *  @param  x  Data to be inserted.\n-     *  @return  An iterator that points to the inserted data.\n-     *\n-     *  This function will insert a copy of the given value before the\n-     *  specified location.  Due to the nature of a %list this\n-     *  operation can be done in constant time, and does not\n-     *  invalidate iterators and references.\n-    */\n-    iterator\n-    insert(iterator __position, const value_type& __x);\n-  \n-    /**\n-     *  @brief  Inserts a number of copies of given data into the %list.\n-     *  @param  position  An iterator into the %list.\n-     *  @param  n  Number of elements to be inserted.\n-     *  @param  x  Data to be inserted.\n-     *\n-     *  This function will insert a specified number of copies of the\n-     *  given data before the location specified by @a position.\n-     *\n-     *  Due to the nature of a %list this operation can be done in\n-     *  constant time, and does not invalidate iterators and\n-     *  references.\n-    */\n-    void\n-    insert(iterator __position, size_type __n, const value_type& __x)\n-    { _M_fill_insert(__position, __n, __x); }\n-  \n-    /**\n-     *  @brief  Inserts a range into the %list.\n-     *  @param  position  An iterator into the %list.\n-     *  @param  first  An input iterator.\n-     *  @param  last   An input iterator.\n-     *\n-     *  This function will insert copies of the data in the range [@a\n-     *  first,@a last) into the %list before the location specified by\n-     *  @a position.\n-     *\n-     *  Due to the nature of a %list this operation can be done in constant\n-     *  time, and does not invalidate iterators and references.\n-    */\n-    template<typename _InputIterator>\n+      \n+      /**\n+       *  @brief  Inserts given value into %list before specified iterator.\n+       *  @param  position  An iterator into the %list.\n+       *  @param  x  Data to be inserted.\n+       *  @return  An iterator that points to the inserted data.\n+       *\n+       *  This function will insert a copy of the given value before\n+       *  the specified location.  Due to the nature of a %list this\n+       *  operation can be done in constant time, and does not\n+       *  invalidate iterators and references.\n+       */\n+      iterator\n+      insert(iterator __position, const value_type& __x);\n+      \n+      /**\n+       *  @brief  Inserts a number of copies of given data into the %list.\n+       *  @param  position  An iterator into the %list.\n+       *  @param  n  Number of elements to be inserted.\n+       *  @param  x  Data to be inserted.\n+       *\n+       *  This function will insert a specified number of copies of the\n+       *  given data before the location specified by @a position.\n+       *\n+       *  Due to the nature of a %list this operation can be done in\n+       *  constant time, and does not invalidate iterators and\n+       *  references.\n+       */\n       void\n-      insert(iterator __position, _InputIterator __first, \n-\t     _InputIterator __last)\n+      insert(iterator __position, size_type __n, const value_type& __x)\n+      { _M_fill_insert(__position, __n, __x); }\n+      \n+      /**\n+       *  @brief  Inserts a range into the %list.\n+       *  @param  position  An iterator into the %list.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *\n+       *  This function will insert copies of the data in the range [@a\n+       *  first,@a last) into the %list before the location specified by\n+       *  @a position.\n+       *\n+       *  Due to the nature of a %list this operation can be done in\n+       *  constant time, and does not invalidate iterators and\n+       *  references.\n+       */\n+      template<typename _InputIterator>\n+        void\n+        insert(iterator __position, _InputIterator __first, \n+\t       _InputIterator __last)\n+        {\n+\t  // Check whether it's an integral type.  If so, it's not an iterator.\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_insert_dispatch(__position, __first, __last, _Integral());\n+\t}\n+      \n+      /**\n+       *  @brief  Remove element at given position.\n+       *  @param  position  Iterator pointing to element to be erased.\n+       *  @return  An iterator pointing to the next element (or end()).\n+       *\n+       *  This function will erase the element at the given position and thus\n+       *  shorten the %list by one.\n+       *\n+       *  Due to the nature of a %list this operation can be done in\n+       *  constant time, and only invalidates iterators/references to\n+       *  the element being removed.  The user is also cautioned that\n+       *  this function only erases the element, and that if the element\n+       *  is itself a pointer, the pointed-to memory is not touched in\n+       *  any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      iterator\n+      erase(iterator __position);\n+  \n+      /**\n+       *  @brief  Remove a range of elements.\n+       *  @param  first  Iterator pointing to the first element to be erased.\n+       *  @param  last  Iterator pointing to one past the last element to be\n+       *                erased.\n+       *  @return  An iterator pointing to the element pointed to by @a last\n+       *           prior to erasing (or end()).\n+       *\n+       *  This function will erase the elements in the range @a\n+       *  [first,last) and shorten the %list accordingly.\n+       *\n+       *  Due to the nature of a %list this operation can be done in\n+       *  constant time, and only invalidates iterators/references to\n+       *  the element being removed.  The user is also cautioned that\n+       *  this function only erases the elements, and that if the\n+       *  elements themselves are pointers, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's\n+       *  responsibilty.\n+       */\n+      iterator\n+      erase(iterator __first, iterator __last)\n       {\n-        // Check whether it's an integral type.  If so, it's not an iterator.\n-        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-        _M_insert_dispatch(__position, __first, __last, _Integral());\n+\twhile (__first != __last)\n+\t  erase(__first++);\n+\treturn __last;\n       }\n   \n-    /**\n-     *  @brief  Remove element at given position.\n-     *  @param  position  Iterator pointing to element to be erased.\n-     *  @return  An iterator pointing to the next element (or end()).\n-     *\n-     *  This function will erase the element at the given position and thus\n-     *  shorten the %list by one.\n-     *\n-     *  Due to the nature of a %list this operation can be done in\n-     *  constant time, and only invalidates iterators/references to\n-     *  the element being removed.  The user is also cautioned that\n-     *  this function only erases the element, and that if the element\n-     *  is itself a pointer, the pointed-to memory is not touched in\n-     *  any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    iterator\n-    erase(iterator __position);\n-  \n-    /**\n-     *  @brief  Remove a range of elements.\n-     *  @param  first  Iterator pointing to the first element to be erased.\n-     *  @param  last  Iterator pointing to one past the last element to be\n-     *                erased.\n-     *  @return  An iterator pointing to the element pointed to by @a last\n-     *           prior to erasing (or end()).\n-     *\n-     *  This function will erase the elements in the range @a\n-     *  [first,last) and shorten the %list accordingly.\n-     *\n-     *  Due to the nature of a %list this operation can be done in\n-     *  constant time, and only invalidates iterators/references to\n-     *  the element being removed.  The user is also cautioned that\n-     *  this function only erases the elements, and that if the\n-     *  elements themselves are pointers, the pointed-to memory is not\n-     *  touched in any way.  Managing the pointer is the user's\n-     *  responsibilty.\n-    */\n-    iterator\n-    erase(iterator __first, iterator __last)\n-    {\n-      while (__first != __last)\n-        erase(__first++);\n-      return __last;\n-    }\n-  \n-    /**\n-     *  @brief  Swaps data with another %list.\n-     *  @param  x  A %list of the same element and allocator types.\n-     *\n-     *  This exchanges the elements between two lists in constant\n-     *  time.  Note that the global std::swap() function is\n-     *  specialized such that std::swap(l1,l2) will feed to this\n-     *  function.\n-    */\n-    void\n-    swap(list& __x);\n-  \n-    /**\n-     *  Erases all the elements.  Note that this function only erases\n-     *  the elements, and that if the elements themselves are\n-     *  pointers, the pointed-to memory is not touched in any way.\n-     *  Managing the pointer is the user's responsibilty.\n-    */\n-    void\n-    clear() { _Base::__clear(); }\n-  \n-    // [23.2.2.4] list operations\n-    /**\n-     *  @brief  Insert contents of another %list.\n-     *  @param  position  Iterator referencing the element to insert before.\n-     *  @param  x  Source list.\n-     *\n-     *  The elements of @a x are inserted in constant time in front of\n-     *  the element referenced by @a position.  @a x becomes an empty\n-     *  list.\n-    */\n-    void\n-    splice(iterator __position, list& __x)\n-    {\n-      if (!__x.empty())\n-        this->_M_transfer(__position, __x.begin(), __x.end());\n-    }\n-  \n-    /**\n-     *  @brief  Insert element from another %list.\n-     *  @param  position  Iterator referencing the element to insert before.\n-     *  @param  x  Source list.\n-     *  @param  i  Iterator referencing the element to move.\n-     *\n-     *  Removes the element in list @a x referenced by @a i and\n-     *  inserts it into the current list before @a position.\n-    */\n-    void\n-    splice(iterator __position, list&, iterator __i)\n-    {\n-      iterator __j = __i;\n-      ++__j;\n-      if (__position == __i || __position == __j) return;\n-      this->_M_transfer(__position, __i, __j);\n-    }\n-  \n-    /**\n-     *  @brief  Insert range from another %list.\n-     *  @param  position  Iterator referencing the element to insert before.\n-     *  @param  x  Source list.\n-     *  @param  first  Iterator referencing the start of range in x.\n-     *  @param  last  Iterator referencing the end of range in x.\n-     *\n-     *  Removes elements in the range [first,last) and inserts them\n-     *  before @a position in constant time.\n-     *\n-     *  Undefined if @a position is in [first,last).\n-   */\n-    void\n-    splice(iterator __position, list&, iterator __first, iterator __last)\n-    {\n-      if (__first != __last)\n-        this->_M_transfer(__position, __first, __last);\n-    }\n-  \n-    /**\n-     *  @brief  Remove all elements equal to value.\n-     *  @param  value  The value to remove.\n-     *\n-     *  Removes every element in the list equal to @a value.\n-     *  Remaining elements stay in list order.  Note that this\n-     *  function only erases the elements, and that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched\n-     *  in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    void\n-    remove(const _Tp& __value);\n-  \n-    /**\n-     *  @brief  Remove all elements satisfying a predicate.\n-     *  @param  Predicate  Unary predicate function or object.\n-     *\n-     *  Removes every element in the list for which the predicate\n-     *  returns true.  Remaining elements stay in list order.  Note\n-     *  that this function only erases the elements, and that if the\n-     *  elements themselves are pointers, the pointed-to memory is not\n-     *  touched in any way.  Managing the pointer is the user's\n-     *  responsibilty.\n-    */\n-    template<typename _Predicate>\n+      /**\n+       *  @brief  Swaps data with another %list.\n+       *  @param  x  A %list of the same element and allocator types.\n+       *\n+       *  This exchanges the elements between two lists in constant\n+       *  time.  Note that the global std::swap() function is\n+       *  specialized such that std::swap(l1,l2) will feed to this\n+       *  function.\n+       */\n       void\n-      remove_if(_Predicate);\n-  \n-    /**\n-     *  @brief  Remove consecutive duplicate elements.\n-     *\n-     *  For each consecutive set of elements with the same value,\n-     *  remove all but the first one.  Remaining elements stay in list\n-     *  order.  Note that this function only erases the elements, and\n-     *  that if the elements themselves are pointers, the pointed-to\n-     *  memory is not touched in any way.  Managing the pointer is the\n-     *  user's responsibilty.\n-    */\n-    void\n-    unique();\n-  \n-    /**\n-     *  @brief  Remove consecutive elements satisfying a predicate.\n-     *  @param  BinaryPredicate  Binary predicate function or object.\n-     *\n-     *  For each consecutive set of elements [first,last) that satisfy\n-     *  predicate(first,i) where i is an iterator in [first,last),\n-     *  remove all but the first one.  Remaining elements stay in list\n-     *  order.  Note that this function only erases the elements, and\n-     *  that if the elements themselves are pointers, the pointed-to\n-     *  memory is not touched in any way.  Managing the pointer is the\n-     *  user's responsibilty.\n-    */\n-    template<typename _BinaryPredicate>\n+      swap(list& __x);\n+  \n+      /**\n+       *  Erases all the elements.  Note that this function only erases\n+       *  the elements, and that if the elements themselves are\n+       *  pointers, the pointed-to memory is not touched in any way.\n+       *  Managing the pointer is the user's responsibilty.\n+       */\n       void\n-      unique(_BinaryPredicate);\n-  \n-    /**\n-     *  @brief  Merge sorted lists.\n-     *  @param  x  Sorted list to merge.\n-     *\n-     *  Assumes that both @a x and this list are sorted according to\n-     *  operator<().  Merges elements of @a x into this list in sorted\n-     *  order, leaving @a x empty when complete.  Elements in this\n-     *  list precede elements in @a x that are equal.\n-    */\n-    void\n-    merge(list& __x);\n-  \n-    /**\n-     *  @brief  Merge sorted lists according to comparison function.\n-     *  @param  x  Sorted list to merge.\n-     *  @param  StrictWeakOrdering  Comparison function definining sort order.\n-     *\n-     *  Assumes that both @a x and this list are sorted according to\n-     *  StrictWeakOrdering.  Merges elements of @a x into this list in\n-     *  sorted order, leaving @a x empty when complete.  Elements in\n-     *  this list precede elements in @a x that are equivalent\n-     *  according to StrictWeakOrdering().\n-    */\n-    template<typename _StrictWeakOrdering>\n+      clear() { _Base::_M_clear(); }\n+  \n+      // [23.2.2.4] list operations\n+      /**\n+       *  @brief  Insert contents of another %list.\n+       *  @param  position  Iterator referencing the element to insert before.\n+       *  @param  x  Source list.\n+       *\n+       *  The elements of @a x are inserted in constant time in front of\n+       *  the element referenced by @a position.  @a x becomes an empty\n+       *  list.\n+       */\n       void\n-      merge(list&, _StrictWeakOrdering);\n-  \n-    /**\n-     *  @brief  Reverse the elements in list.\n-     *\n-     *  Reverse the order of elements in the list in linear time.\n-    */\n-    void\n-    reverse() { __List_base_reverse(&this->_M_node); }\n-  \n-    /**\n-     *  @brief  Sort the elements.\n-     *\n-     *  Sorts the elements of this list in NlogN time.  Equivalent\n-     *  elements remain in list order.\n-    */\n-    void\n-    sort();\n+      splice(iterator __position, list& __x)\n+      {\n+\tif (!__x.empty())\n+\t  this->_M_transfer(__position, __x.begin(), __x.end());\n+      }\n   \n-    /**\n-     *  @brief  Sort the elements according to comparison function.\n-     *\n-     *  Sorts the elements of this list in NlogN time.  Equivalent\n-     *  elements remain in list order.\n-    */\n-    template<typename _StrictWeakOrdering>\n+      /**\n+       *  @brief  Insert element from another %list.\n+       *  @param  position  Iterator referencing the element to insert before.\n+       *  @param  x  Source list.\n+       *  @param  i  Iterator referencing the element to move.\n+       *\n+       *  Removes the element in list @a x referenced by @a i and\n+       *  inserts it into the current list before @a position.\n+       */\n       void\n-      sort(_StrictWeakOrdering);\n-  \n-  protected:\n-    // Internal assign functions follow.\n+      splice(iterator __position, list&, iterator __i)\n+      {\n+\titerator __j = __i;\n+\t++__j;\n+\tif (__position == __i || __position == __j) return;\n+\tthis->_M_transfer(__position, __i, __j);\n+      }\n   \n-    // Called by the range assign to implement [23.1.1]/9\n-    template<typename _Integer>\n+      /**\n+       *  @brief  Insert range from another %list.\n+       *  @param  position  Iterator referencing the element to insert before.\n+       *  @param  x  Source list.\n+       *  @param  first  Iterator referencing the start of range in x.\n+       *  @param  last  Iterator referencing the end of range in x.\n+       *\n+       *  Removes elements in the range [first,last) and inserts them\n+       *  before @a position in constant time.\n+       *\n+       *  Undefined if @a position is in [first,last).\n+       */\n       void\n-      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+      splice(iterator __position, list&, iterator __first, iterator __last)\n       {\n-        _M_fill_assign(static_cast<size_type>(__n),\n-                       static_cast<value_type>(__val));\n+\tif (__first != __last)\n+\t  this->_M_transfer(__position, __first, __last);\n       }\n   \n-    // Called by the range assign to implement [23.1.1]/9\n-    template<typename _InputIterator>\n+      /**\n+       *  @brief  Remove all elements equal to value.\n+       *  @param  value  The value to remove.\n+       *\n+       *  Removes every element in the list equal to @a value.\n+       *  Remaining elements stay in list order.  Note that this\n+       *  function only erases the elements, and that if the elements\n+       *  themselves are pointers, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's\n+       *  responsibilty.\n+       */\n       void\n-      _M_assign_dispatch(_InputIterator __first, _InputIterator __last, \n-\t\t\t __false_type);\n-  \n-    // Called by assign(n,t), and the range assign when it turns out\n-    // to be the same thing.\n-    void\n-    _M_fill_assign(size_type __n, const value_type& __val);\n-  \n-  \n-    // Internal insert functions follow.\n+      remove(const _Tp& __value);\n+  \n+      /**\n+       *  @brief  Remove all elements satisfying a predicate.\n+       *  @param  Predicate  Unary predicate function or object.\n+       *\n+       *  Removes every element in the list for which the predicate\n+       *  returns true.  Remaining elements stay in list order.  Note\n+       *  that this function only erases the elements, and that if the\n+       *  elements themselves are pointers, the pointed-to memory is\n+       *  not touched in any way.  Managing the pointer is the user's\n+       *  responsibilty.\n+       */\n+      template<typename _Predicate>\n+      void\n+      remove_if(_Predicate);\n   \n-    // Called by the range insert to implement [23.1.1]/9\n-    template<typename _Integer>\n+      /**\n+       *  @brief  Remove consecutive duplicate elements.\n+       *\n+       *  For each consecutive set of elements with the same value,\n+       *  remove all but the first one.  Remaining elements stay in\n+       *  list order.  Note that this function only erases the\n+       *  elements, and that if the elements themselves are pointers,\n+       *  the pointed-to memory is not touched in any way.  Managing\n+       *  the pointer is the user's responsibilty.\n+       */\n+      void\n+      unique();\n+  \n+      /**\n+       *  @brief  Remove consecutive elements satisfying a predicate.\n+       *  @param  BinaryPredicate  Binary predicate function or object.\n+       *\n+       *  For each consecutive set of elements [first,last) that\n+       *  satisfy predicate(first,i) where i is an iterator in\n+       *  [first,last), remove all but the first one.  Remaining\n+       *  elements stay in list order.  Note that this function only\n+       *  erases the elements, and that if the elements themselves are\n+       *  pointers, the pointed-to memory is not touched in any way.\n+       *  Managing the pointer is the user's responsibilty.\n+       */\n+      template<typename _BinaryPredicate>\n+        void\n+        unique(_BinaryPredicate);\n+  \n+      /**\n+       *  @brief  Merge sorted lists.\n+       *  @param  x  Sorted list to merge.\n+       *\n+       *  Assumes that both @a x and this list are sorted according to\n+       *  operator<().  Merges elements of @a x into this list in\n+       *  sorted order, leaving @a x empty when complete.  Elements in\n+       *  this list precede elements in @a x that are equal.\n+       */\n+      void\n+      merge(list& __x);\n+  \n+      /**\n+       *  @brief  Merge sorted lists according to comparison function.\n+       *  @param  x  Sorted list to merge.\n+       *  @param StrictWeakOrdering Comparison function definining\n+       *  sort order.\n+       *\n+       *  Assumes that both @a x and this list are sorted according to\n+       *  StrictWeakOrdering.  Merges elements of @a x into this list\n+       *  in sorted order, leaving @a x empty when complete.  Elements\n+       *  in this list precede elements in @a x that are equivalent\n+       *  according to StrictWeakOrdering().\n+       */\n+      template<typename _StrictWeakOrdering>\n+        void\n+        merge(list&, _StrictWeakOrdering);\n+  \n+      /**\n+       *  @brief  Reverse the elements in list.\n+       *\n+       *  Reverse the order of elements in the list in linear time.\n+       */\n+      void\n+      reverse() { __List_base_reverse(&this->_M_node); }\n+  \n+      /**\n+       *  @brief  Sort the elements.\n+       *\n+       *  Sorts the elements of this list in NlogN time.  Equivalent\n+       *  elements remain in list order.\n+       */\n+      void\n+      sort();\n+  \n+      /**\n+       *  @brief  Sort the elements according to comparison function.\n+       *\n+       *  Sorts the elements of this list in NlogN time.  Equivalent\n+       *  elements remain in list order.\n+       */\n+      template<typename _StrictWeakOrdering>\n+        void\n+        sort(_StrictWeakOrdering);\n+  \n+    protected:\n+      // Internal assign functions follow.\n+      \n+      // Called by the range assign to implement [23.1.1]/9\n+      template<typename _Integer>\n+        void\n+        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+        {\n+\t  _M_fill_assign(static_cast<size_type>(__n),\n+\t\t\t static_cast<value_type>(__val));\n+\t}\n+  \n+      // Called by the range assign to implement [23.1.1]/9\n+      template<typename _InputIterator>\n+        void\n+        _M_assign_dispatch(_InputIterator __first, _InputIterator __last, \n+\t\t\t   __false_type);\n+  \n+      // Called by assign(n,t), and the range assign when it turns out\n+      // to be the same thing.\n       void\n-      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n-                         __true_type)\n+      _M_fill_assign(size_type __n, const value_type& __val);\n+      \n+      \n+      // Internal insert functions follow.\n+      \n+      // Called by the range insert to implement [23.1.1]/9\n+      template<typename _Integer>\n+        void\n+        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n+\t\t\t   __true_type)\n+        {\n+\t  _M_fill_insert(__pos, static_cast<size_type>(__n),\n+\t\t\t static_cast<value_type>(__x));\n+\t}\n+      \n+      // Called by the range insert to implement [23.1.1]/9\n+      template<typename _InputIterator>\n+        void\n+        _M_insert_dispatch(iterator __pos,\n+\t\t\t   _InputIterator __first, _InputIterator __last,\n+\t\t\t   __false_type)\n+        {\n+\t  for ( ; __first != __last; ++__first)\n+\t    insert(__pos, *__first);\n+\t}\n+      \n+      // Called by insert(p,n,x), and the range insert when it turns out\n+      // to be the same thing.\n+      void\n+      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n       {\n-        _M_fill_insert(__pos, static_cast<size_type>(__n),\n-                       static_cast<value_type>(__x));\n+\tfor ( ; __n > 0; --__n)\n+\t  insert(__pos, __x);\n       }\n-  \n-    // Called by the range insert to implement [23.1.1]/9\n-    template<typename _InputIterator>\n+      \n+      \n+      // Moves the elements from [first,last) before position.\n       void\n-      _M_insert_dispatch(iterator __pos,\n-                         _InputIterator __first, _InputIterator __last,\n-                         __false_type)\n+      _M_transfer(iterator __position, iterator __first, iterator __last)\n       {\n-        for ( ; __first != __last; ++__first)\n-          insert(__pos, *__first);\n+\tif (__position != __last) \n+\t  {\n+\t    // Remove [first, last) from its old position.\n+\t    __last._M_node->_M_prev->_M_next     = __position._M_node;\n+\t    __first._M_node->_M_prev->_M_next    = __last._M_node;\n+\t    __position._M_node->_M_prev->_M_next = __first._M_node;\n+\t    \n+\t    // Splice [first, last) into its new position.\n+\t    _List_node_base* __tmp      = __position._M_node->_M_prev;\n+\t    __position._M_node->_M_prev = __last._M_node->_M_prev;\n+\t    __last._M_node->_M_prev     = __first._M_node->_M_prev;\n+\t    __first._M_node->_M_prev    = __tmp;\n+\t  }\n       }\n-  \n-    // Called by insert(p,n,x), and the range insert when it turns out\n-    // to be the same thing.\n-    void\n-    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n-    {\n-      for ( ; __n > 0; --__n)\n-        insert(__pos, __x);\n-    }\n-  \n-  \n-    // Moves the elements from [first,last) before position.\n-    void\n-    _M_transfer(iterator __position, iterator __first, iterator __last)\n-    {\n-      if (__position != __last) {\n-        // Remove [first, last) from its old position.\n-        __last._M_node->_M_prev->_M_next     = __position._M_node;\n-        __first._M_node->_M_prev->_M_next    = __last._M_node;\n-        __position._M_node->_M_prev->_M_next = __first._M_node;\n-  \n-        // Splice [first, last) into its new position.\n-        _List_node_base* __tmp      = __position._M_node->_M_prev;\n-        __position._M_node->_M_prev = __last._M_node->_M_prev;\n-        __last._M_node->_M_prev     = __first._M_node->_M_prev;\n-        __first._M_node->_M_prev    = __tmp;\n-      }\n-    }\n-  };\n+    };\n   \n   \n   /**\n@@ -1074,7 +1078,7 @@ namespace __gnu_norm\n    *  equal, and if corresponding elements compare equal.\n   */\n   template<typename _Tp, typename _Alloc>\n-  inline bool\n+    inline bool\n     operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n     {\n       typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n@@ -1083,9 +1087,10 @@ namespace __gnu_norm\n   \n       const_iterator __i1 = __x.begin();\n       const_iterator __i2 = __y.begin();\n-      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n-        ++__i1;\n-        ++__i2;\n+      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) \n+\t{\n+\t  ++__i1;\n+\t  ++__i2;\n       }\n       return __i1 == __end1 && __i2 == __end2;\n     }"}]}