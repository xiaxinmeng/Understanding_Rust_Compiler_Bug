{"sha": "b1a275e1e03d6fd70bac89c750b5158bb369e71d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFhMjc1ZTFlMDNkNmZkNzBiYWM4OWM3NTBiNTE1OGJiMzY5ZTcxZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-09T20:22:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-09T20:22:50Z"}, "message": "pa.c (pa_adjust_insn_length): dbra and movb insns which have their output in a FP register do not need adjustment.\n\n        * pa.c (pa_adjust_insn_length): dbra and movb insns which have\n        their output in a FP register do not need adjustment.\n        (output_cbranch, output_bb): Handle conditional jump to the\n        following instruction.\n        (output_dbra): New function extracted from dbra pattern.\n        (output_movb): New function.\n        (eq_neq_comparison_operator): New function.\n        (movb_comparison_operator): New function.\n\nFrom-SVN: r4888", "tree": {"sha": "9fd78a1db32c44c54d28e820a414469bad082511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fd78a1db32c44c54d28e820a414469bad082511"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1a275e1e03d6fd70bac89c750b5158bb369e71d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a275e1e03d6fd70bac89c750b5158bb369e71d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1a275e1e03d6fd70bac89c750b5158bb369e71d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a275e1e03d6fd70bac89c750b5158bb369e71d/comments", "author": null, "committer": null, "parents": [{"sha": "98b2d887833f25794d0febba4ea1fcf65a9490c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98b2d887833f25794d0febba4ea1fcf65a9490c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98b2d887833f25794d0febba4ea1fcf65a9490c2"}], "stats": {"total": 234, "additions": 231, "deletions": 3}, "files": [{"sha": "fc61ca5d953fe1ec41a037b3393088f9bbab03e6", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 231, "deletions": 3, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a275e1e03d6fd70bac89c750b5158bb369e71d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a275e1e03d6fd70bac89c750b5158bb369e71d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b1a275e1e03d6fd70bac89c750b5158bb369e71d", "patch": "@@ -2543,10 +2543,12 @@ pa_adjust_insn_length (insn, length)\n \t  && ! forward_branch_p (insn))\n \treturn 1;\n       /* Adjust dbra insn with short backwards conditional branch with\n-\t unfilled delay slot -- only for case where counter is in a register. */\n+\t unfilled delay slot -- only for case where counter is in a \n+\t general register register. */\n       else if (GET_CODE (pat) == PARALLEL\n \t       && GET_CODE (XVECEXP (pat, 0, 1)) == SET\n \t       && GET_CODE (XEXP (XVECEXP (pat, 0, 1), 0)) == REG\n+ \t       && ! FP_REG_P (XEXP (XVECEXP (pat, 0, 1), 0)) \n \t       && length == 1\n \t       && ! forward_branch_p (insn))\n \treturn 1;\n@@ -3250,10 +3252,18 @@ output_cbranch (operands, nullify, length, negated, insn)\n   rtx *operands;\n   int nullify, length, negated;\n   rtx insn;\n-{ \n+{\n   static char buf[100];\n   int useskip = 0;\n \n+  /* A conditional branch to the following instruction (eg the delay slot) is\n+     asking for a disaster.  This can happen when not optimizing.\n+\n+     In such cases it is safe to emit nothing.  */\n+\n+  if (JUMP_LABEL (insn) == next_nonnote_insn (insn))\n+    return \"\";\n+  \n   /* If this is a long branch with its delay slot unfilled, set `nullify'\n      as it can nullify the delay slot and save a nop.  */\n   if (length == 2 && dbr_sequence_length () == 0)\n@@ -3343,10 +3353,18 @@ output_bb (operands, nullify, length, negated, insn, which)\n   int nullify, length, negated;\n   rtx insn;\n   int which;\n-{ \n+{\n   static char buf[100];\n   int useskip = 0;\n \n+  /* A conditional branch to the following instruction (eg the delay slot) is\n+     asking for a disaster.  I do not think this can happen as this pattern\n+     is only used when optimizing; jump optimization should eliminate the \n+     jump.  But be prepared just in case.  */\n+     \n+  if (JUMP_LABEL (insn) == next_nonnote_insn (insn))\n+    return \"\";\n+  \n   /* If this is a long branch with its delay slot unfilled, set `nullify'\n      as it can nullify the delay slot and save a nop.  */\n   if (length == 2 && dbr_sequence_length () == 0)\n@@ -3441,6 +3459,197 @@ output_bb (operands, nullify, length, negated, insn, which)\n   return buf;\n }\n \n+/* Return the output template for emitting a dbra type insn.\n+\n+   Note it may perform some output operations on its own before\n+   returning the final output string.  */\n+char *\n+output_dbra (operands, insn, which_alternative)\n+     rtx *operands;\n+     rtx insn;\n+     int which_alternative;\n+{\n+\n+  /* A conditional branch to the following instruction (eg the delay slot) is\n+     asking for a disaster.  Be prepared!  */\n+\n+  if (JUMP_LABEL (insn) == next_nonnote_insn (insn))\n+    {\n+      if (which_alternative == 0)\n+\treturn \"ldo %1(%0),%0\";\n+      else if (which_alternative == 1)\n+\t{\n+\t  output_asm_insn (\"fstws %0,-16(0,%%r30)\",operands);\n+\t  output_asm_insn (\"ldw -16(0,%%r30),%4\",operands);\n+\t  output_asm_insn (\"ldo %1(%4),%4\\n\\tstw %4,-16(0,%%r30)\", operands);\n+\t  return \"fldws -16(0,%%r30),%0\";\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\"ldw %0,%4\", operands);\n+\t  return \"ldo %1(%4),%4\\n\\tstw %4,%0\";\n+\t}\n+    }\n+\n+  if (which_alternative == 0)\n+    {\n+      int nullify = INSN_ANNULLED_BRANCH_P (insn);\n+      int length = get_attr_length (insn);\n+\n+      /* If this is a long branch with its delay slot unfilled, set `nullify'\n+\t as it can nullify the delay slot and save a nop.  */\n+      if (length == 2 && dbr_sequence_length () == 0)\n+\tnullify = 1;\n+\n+      /* If this is a short forward conditional branch which did not get\n+\t its delay slot filled, the delay slot can still be nullified.  */\n+      if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+\tnullify = forward_branch_p (insn);\n+\n+      /* Handle short versions first.  */\n+      if (length == 1 && nullify)\n+\treturn \"addib,%C2,n %1,%0,%3\";\n+      else if (length == 1 && ! nullify)\n+\treturn \"addib,%C2 %1,%0,%3\";\n+      else if (length == 2)\n+\t{\n+\t  /* Handle weird backwards branch with a fulled delay slot \n+\t     which is nullified.  */\n+\t  if (dbr_sequence_length () != 0\n+\t      && ! forward_branch_p (insn)\n+\t      && nullify)\n+\t    return \"addib,%N2,n %1,%0,.+12\\n\\tbl %3,0\";\n+\t  \n+\t  /* Handle normal cases.  */  \n+\t  if (nullify)\n+\t    return \"addi,%N2 %1,%0,%0\\n\\tbl,n %3,0\";\n+\t  else\n+\t    return \"addi,%N2 %1,%0,%0\\n\\tbl %3,0\";\n+\t}\n+      else\n+\tabort();\n+    }\n+  /* Deal with gross reload from FP register case.  */\n+  else if (which_alternative == 1)\n+    {\n+      /* Move loop counter from FP register to MEM then into a GR,\n+\t increment the GR, store the GR into MEM, and finally reload\n+\t the FP register from MEM from within the branch's delay slot.  */ \n+      output_asm_insn (\"fstws %0,-16(0,%%r30)\\n\\tldw -16(0,%%r30),%4\",operands);\n+      output_asm_insn (\"ldo %1(%4),%4\\n\\tstw %4,-16(0,%%r30)\", operands);\n+      if (get_attr_length (insn) == 6)\n+\treturn \"comb,%S2 0,%4,%3\\n\\tfldws -16(0,%%r30),%0\";\n+      else\n+\treturn \"comclr,%B2 0,%4,0\\n\\tbl %3,0\\n\\tfldws -16(0,%%r30),%0\";\n+    }\n+  /* Deal with gross reload from memory case.  */\n+  else\n+    {\n+      /* Reload loop counter from memory, the store back to memory\n+\t happens in the branch's delay slot.   */\n+      output_asm_insn (\"ldw %0,%4\", operands);\n+      if (get_attr_length (insn) == 3)\n+\treturn \"addib,%C2 %1,%4,%3\\n\\tstw %4,%0\";\n+      else\n+\treturn \"addi,%N2 %1,%4,%0\\n\\tbl %3,0\\n\\tstw %4,%0\";\n+    }\n+}\n+\n+/* Return the output template for emitting a dbra type insn.\n+\n+   Note it may perform some output operations on its own before\n+   returning the final output string.  */\n+char *\n+output_movb (operands, insn, which_alternative, reverse_comparison)\n+     rtx *operands;\n+     rtx insn;\n+     int which_alternative;\n+     int reverse_comparison;\n+{\n+\n+  /* A conditional branch to the following instruction (eg the delay slot) is\n+     asking for a disaster.  Be prepared!  */\n+\n+  if (JUMP_LABEL (insn) == next_nonnote_insn (insn))\n+    {\n+      if (which_alternative == 0)\n+\treturn \"copy %1,%0\";\n+      else if (which_alternative == 1)\n+\t{\n+\t  output_asm_insn (\"fstws %1,-16(0,%%r30)\",operands);\n+\t  return \"fldws -16(0,%%r30),%0\";\n+\t}\n+      else\n+\treturn \"stw %1,%0\";\n+    }\n+\n+  /* Support the second variant.  */\n+  if (reverse_comparison)\n+    PUT_CODE (operands[2], reverse_condition (GET_CODE (operands[2])));\n+\n+  if (which_alternative == 0)\n+    {\n+      int nullify = INSN_ANNULLED_BRANCH_P (insn);\n+      int length = get_attr_length (insn);\n+\n+      /* If this is a long branch with its delay slot unfilled, set `nullify'\n+\t as it can nullify the delay slot and save a nop.  */\n+      if (length == 2 && dbr_sequence_length () == 0)\n+\tnullify = 1;\n+\n+      /* If this is a short forward conditional branch which did not get\n+\t its delay slot filled, the delay slot can still be nullified.  */\n+      if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+\tnullify = forward_branch_p (insn);\n+\n+      /* Handle short versions first.  */\n+      if (length == 1 && nullify)\n+\treturn \"movb,%C2,n %1,%0,%3\";\n+      else if (length == 1 && ! nullify)\n+\treturn \"movb,%C2 %1,%0,%3\";\n+      else if (length == 2)\n+\t{\n+\t  /* Handle weird backwards branch with a fulled delay slot \n+\t     which is nullified.  */\n+\t  if (dbr_sequence_length () != 0\n+\t      && ! forward_branch_p (insn)\n+\t      && nullify)\n+\t    return \"movb,%N2,n %1,%0,.+12\\n\\ttbl %3,0\";\n+\t  \n+\t  /* Handle normal cases.  */  \n+\t  if (nullify)\n+\t    return \"or,%N2 %1,%%r0,%0\\n\\tbl,n %3,0\";\n+\t  else\n+\t    return \"or,%N2 %1,%%r0,%0\\n\\tbl %3,0\";\n+\t}\n+      else\n+\tabort();\n+    }\n+  /* Deal with gross reload from FP register case.  */\n+  else if (which_alternative == 1)\n+    {\n+      /* Move loop counter from FP register to MEM then into a GR,\n+\t increment the GR, store the GR into MEM, and finally reload\n+\t the FP register from MEM from within the branch's delay slot.  */ \n+      output_asm_insn (\"fstws %1,-16(0,%%r30)\",operands);\n+      if (get_attr_length (insn) == 3)\n+\treturn \"comb,%S2 0,%1,%3\\n\\tfldws -16(0,%%r30),%0\";\n+      else\n+\treturn \"comclr,%B2 0,%1,0\\n\\tbl %3,0\\n\\tfldws -16(0,%%r30),%0\";\n+    }\n+  /* Deal with gross reload from memory case.  */\n+  else\n+    {\n+      /* Reload loop counter from memory, the store back to memory\n+\t happens in the branch's delay slot.   */\n+      if (get_attr_length (insn) == 2)\n+\treturn \"comb,%S2 0,%1,%3\\n\\tstw %1,%0\";\n+      else\n+\treturn \"comclr,%B2 0,%1,0\\n\\tbl %3,0\\n\\tstw %1,%0\";\n+    }\n+}\n+\n+\n extern struct obstack *saveable_obstack;\n \n /* In HPUX 8.0's shared library scheme, special relocations are needed\n@@ -3603,3 +3812,22 @@ forward_branch_p (insn)\n   return (insn == label);\n }\n \n+/* Return 1 if OP is an equality comparison, else return 0.  */\n+int\n+eq_neq_comparison_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n+}\n+\n+/* Return 1 if OP is an operator suitable for use in a movb instruction.  */\n+int\n+movb_comparison_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == EQ || GET_CODE (op) == NE\n+\t  || GET_CODE (op) == LT || GET_CODE (op) == GE);\n+}\n+"}]}