{"sha": "4f75543dc417cee2db2fc46f516f7e3137e4b250", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY3NTU0M2RjNDE3Y2VlMmRiMmZjNDZmNTE2ZjdlMzEzN2U0YjI1MA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-05-01T00:08:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-05-01T00:08:36Z"}, "message": "PR libstdc++/61761 fix std::proj for targets without C99 cproj\n\nThe current generic implementation of __complex_proj used when cproj is\nnot available calculates the wrong projection, giving a different result\nthan given by C99's cproj.\n\nWhen C99 cproj is not available but isinf and copysign are, use those to\ngive correct results for float, double and long double. Otherwise, and\nfor other specializations of std::complex, just use a generic version\nthat returns its argument, and so doesn't support infinities.\n\nWe might want to consider adding additional overloads of __complex_proj\nto support extended types such as _Float64x, _Float128 etc.\n\n\tPR libstdc++/61761\n\t* include/std/complex (__complex_proj): Return parameter unchanged.\n\t[_GLIBCXX_USE_C99_COMPLEX] (__complex_proj): Change overloads for\n\tfloating-point types to take std::complex arguments.\n\t[_GLIBCXX_USE_C99_MATH_TR1] (__complex_proj): Add overloads for\n\tfloating-point types.\n\t* testsuite/26_numerics/complex/proj.cc: New test.\n\nFrom-SVN: r270759", "tree": {"sha": "76345135bc4cf391e0112a78063393252d647b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76345135bc4cf391e0112a78063393252d647b69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f75543dc417cee2db2fc46f516f7e3137e4b250", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f75543dc417cee2db2fc46f516f7e3137e4b250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f75543dc417cee2db2fc46f516f7e3137e4b250", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f75543dc417cee2db2fc46f516f7e3137e4b250/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f4753914455ad186f7c1f994743abfcb05a7dc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4753914455ad186f7c1f994743abfcb05a7dc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4753914455ad186f7c1f994743abfcb05a7dc9"}], "stats": {"total": 465, "additions": 440, "deletions": 25}, "files": [{"sha": "5a070ff79c9ab0fce5e7fa56fa56f68665a9ceb4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f75543dc417cee2db2fc46f516f7e3137e4b250/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f75543dc417cee2db2fc46f516f7e3137e4b250/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4f75543dc417cee2db2fc46f516f7e3137e4b250", "patch": "@@ -1,3 +1,13 @@\n+2019-05-01  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/61761\n+\t* include/std/complex (__complex_proj): Return parameter unchanged.\n+\t[_GLIBCXX_USE_C99_COMPLEX] (__complex_proj): Change overloads for\n+\tfloating-point types to take std::complex arguments.\n+\t[_GLIBCXX_USE_C99_MATH_TR1] (__complex_proj): Add overloads for\n+\tfloating-point types.\n+\t* testsuite/26_numerics/complex/proj.cc: New test.\n+\n 2019-04-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/abi/pre/gnu.ver (GLIBCXX_3.4.26): Change _Lock_policyE2 exports"}, {"sha": "45450e8ca013930cdda5c08371566addf23be0db", "filename": "libstdc++-v3/include/std/complex", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f75543dc417cee2db2fc46f516f7e3137e4b250/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f75543dc417cee2db2fc46f516f7e3137e4b250/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=4f75543dc417cee2db2fc46f516f7e3137e4b250", "patch": "@@ -1898,41 +1898,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     std::complex<_Tp> proj(const std::complex<_Tp>&);\n \n+  // Generic implementation of std::proj, does not work for infinities.\n   template<typename _Tp>\n-    std::complex<_Tp>\n+    inline std::complex<_Tp>\n     __complex_proj(const std::complex<_Tp>& __z)\n-    {\n-      const _Tp __den = (__z.real() * __z.real()\n-\t\t\t + __z.imag() * __z.imag() + _Tp(1.0));\n-\n-      return std::complex<_Tp>((_Tp(2.0) * __z.real()) / __den,\n-\t\t\t       (_Tp(2.0) * __z.imag()) / __den);\n-    }\n+    { return __z; }\n \n #if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_proj(__complex__ float __z)\n-  { return __builtin_cprojf(__z); }\n-\n-  inline __complex__ double\n-  __complex_proj(__complex__ double __z)\n-  { return __builtin_cproj(__z); }\n-\n-  inline __complex__ long double\n-  __complex_proj(const __complex__ long double& __z)\n-  { return __builtin_cprojl(__z); }\n+  inline complex<float>\n+  __complex_proj(const complex<float>& __z)\n+  { return __builtin_cprojf(__z.__rep()); }\n+\n+  inline complex<double>\n+  __complex_proj(const complex<double>& __z)\n+  { return __builtin_cproj(__z.__rep()); }\n+\n+  inline complex<long double>\n+  __complex_proj(const complex<long double>& __z)\n+  { return __builtin_cprojl(__z.__rep()); }\n+#elif defined _GLIBCXX_USE_C99_MATH_TR1\n+  inline complex<float>\n+  __complex_proj(const complex<float>& __z)\n+  {\n+    if (__builtin_isinf(__z.real()) || __builtin_isinf(__z.imag()))\n+      return complex<float>(__builtin_inff(),\n+\t\t\t    __builtin_copysignf(0.0f, __z.imag()));\n+    return __z;\n+  }\n+\n+  inline complex<double>\n+  __complex_proj(const complex<double>& __z)\n+  {\n+    if (__builtin_isinf(__z.real()) || __builtin_isinf(__z.imag()))\n+      return complex<double>(__builtin_inf(),\n+\t\t\t     __builtin_copysign(0.0, __z.imag()));\n+    return __z;\n+  }\n+\n+  inline complex<long double>\n+  __complex_proj(const complex<long double>& __z)\n+  {\n+    if (__builtin_isinf(__z.real()) || __builtin_isinf(__z.imag()))\n+      return complex<long double>(__builtin_infl(),\n+\t\t\t\t  __builtin_copysignl(0.0l, __z.imag()));\n+    return __z;\n+  }\n+#endif\n \n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    proj(const std::complex<_Tp>& __z)\n-    { return __complex_proj(__z.__rep()); }\n-#else\n   template<typename _Tp>\n     inline std::complex<_Tp>\n     proj(const std::complex<_Tp>& __z)\n     { return __complex_proj(__z); }\n-#endif\n \n+  // Overload for scalars\n   template<typename _Tp>\n     inline std::complex<typename __gnu_cxx::__promote<_Tp>::__type>\n     proj(_Tp __x)"}, {"sha": "b70ca4c58e950c16a7bab8317d67f623f428b0b4", "filename": "libstdc++-v3/testsuite/26_numerics/complex/proj.cc", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f75543dc417cee2db2fc46f516f7e3137e4b250/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fproj.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f75543dc417cee2db2fc46f516f7e3137e4b250/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fproj.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fproj.cc?ref=4f75543dc417cee2db2fc46f516f7e3137e4b250", "patch": "@@ -0,0 +1,387 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+\n+#include <complex>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+template<typename T>\n+bool eq(const std::complex<T>& x, const std::complex<T>& y)\n+{\n+  bool nan_reals = std::isnan(x.real()) && std::isnan(y.real());\n+  bool nan_imags = std::isnan(x.imag()) && std::isnan(y.imag());\n+\n+  bool sign_reals\n+    = std::copysign(T(1), x.real()) == std::copysign(T(1), y.real());\n+  bool sign_imags\n+    = std::copysign(T(1), x.imag()) == std::copysign(T(1), y.imag());\n+\n+  return ((x.real() == y.real() && sign_reals) || nan_reals)\n+    && ((x.imag() == y.imag() && sign_imags) || nan_imags);\n+}\n+\n+void\n+test01()\n+{\n+  const double qnan = std::numeric_limits<double>::quiet_NaN();\n+  const double pinf = std::numeric_limits<double>::infinity();\n+  const double ninf = -pinf;\n+\n+  std::complex<double> c00(0, 0);\n+  VERIFY( eq( std::proj(c00)  , c00 ) );\n+  VERIFY( eq( std::proj(-c00) , -c00 ) );\n+  c00.real(-0.0);\n+  VERIFY( eq( std::proj(c00)  , c00 ) );\n+  VERIFY( eq( std::proj(-c00) , -c00 ) );\n+\n+  const std::complex<double> c01(0, 1);\n+  VERIFY( eq( std::proj(c01)  , c01 ) );\n+  VERIFY( eq( std::proj(-c01) , -c01 ) );\n+  c00.real(-0.0);\n+  VERIFY( eq( std::proj(c01)  , c01 ) );\n+  VERIFY( eq( std::proj(-c01) , -c01 ) );\n+\n+  const std::complex<double> c10(1, 0);\n+  VERIFY( eq( std::proj(c10)  , c10 ) );\n+  VERIFY( eq( std::proj(-c10) , -c10 ) );\n+\n+  const std::complex<double> c12(1, 2);\n+  VERIFY( eq( std::proj(c12)  , c12 ) );\n+  VERIFY( eq( std::proj(-c12) , -c12 ) );\n+\n+  const std::complex<double> c0q(0, qnan);\n+  VERIFY( eq( std::proj(c0q)  , c0q ) );\n+  VERIFY( eq( std::proj(-c0q) , -c0q ) );\n+\n+  const std::complex<double> c1q(1, qnan);\n+  VERIFY( eq( std::proj(c1q)  , c1q ) );\n+  VERIFY( eq( std::proj(-c1q) , -c1q ) );\n+\n+  const std::complex<double> cq0(qnan, 0);\n+  VERIFY( eq( std::proj(cq0)  , cq0 ) );\n+  VERIFY( eq( std::proj(-cq0) , -cq0 ) );\n+\n+  const std::complex<double> cq1(qnan, 1);\n+  VERIFY( eq( std::proj(cq1)  , cq1 ) );\n+  VERIFY( eq( std::proj(-cq1) , -cq1 ) );\n+\n+  const std::complex<double> cqq(qnan, qnan);\n+  VERIFY( eq( std::proj(cqq)  , cqq ) );\n+  VERIFY( eq( std::proj(-cqq) , -cqq ) );\n+\n+  const std::complex<double> c0p(0, pinf);\n+  VERIFY( eq( std::proj(c0p)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-c0p) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> c1p(1, pinf);\n+  VERIFY( eq( std::proj(c1p)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-c1p) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> cqp(qnan, pinf);\n+  VERIFY( eq( std::proj(cqp)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cqp) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> cpp(pinf, pinf);\n+  VERIFY( eq( std::proj(cpp)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cpp) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double>  c0n(0, ninf);\n+  VERIFY( eq( std::proj(c0n) , std::complex<double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-c0n) , std::complex<double>(pinf, +0.0) ) );\n+\n+  const std::complex<double> c1n(1, ninf);\n+  VERIFY( eq( std::proj(c1n)  , std::complex<double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-c1n) , std::complex<double>(pinf, +0.0) ) );\n+\n+  const std::complex<double> cqn(qnan, ninf);\n+  VERIFY( eq( std::proj(cqn)  , std::complex<double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cqn) , std::complex<double>(pinf, +0.0) ) );\n+\n+  const std::complex<double> cpn(pinf, ninf);\n+  VERIFY( eq( std::proj(cpn)  , std::complex<double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cpn) , std::complex<double>(pinf, +0.0) ) );\n+\n+  const std::complex<double> cnn(ninf, ninf);\n+  VERIFY( eq( std::proj(cnn)  , std::complex<double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cnn) , std::complex<double>(pinf, +0.0) ) );\n+\n+  const std::complex<double> cp0(pinf, 0);\n+  VERIFY( eq( std::proj(cp0)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cp0) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> cp1(pinf, 1);\n+  VERIFY( eq( std::proj(cp1)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cp1) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> cpq(pinf, qnan);\n+  VERIFY( eq( std::proj(cpq)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cpq) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> cn0(ninf, 0);\n+  VERIFY( eq( std::proj(cn0)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cn0) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> cn1(ninf, 1);\n+  VERIFY( eq( std::proj(cn1)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cn1) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> cnq(ninf, qnan);\n+  VERIFY( eq( std::proj(cnq)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cnq) , std::complex<double>(pinf, -0.0) ) );\n+\n+  const std::complex<double> cnp(ninf, pinf);\n+  VERIFY( eq( std::proj(cnp)  , std::complex<double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cnp) , std::complex<double>(pinf, -0.0) ) );\n+}\n+\n+void\n+test02()\n+{\n+  const float qnan = std::numeric_limits<float>::quiet_NaN();\n+  const float pinf = std::numeric_limits<float>::infinity();\n+  const float ninf = -pinf;\n+\n+  std::complex<float> c00(0, 0);\n+  VERIFY( eq( std::proj(c00)  , c00 ) );\n+  VERIFY( eq( std::proj(-c00) , -c00 ) );\n+  c00.real(-0.0);\n+  VERIFY( eq( std::proj(c00)  , c00 ) );\n+  VERIFY( eq( std::proj(-c00) , -c00 ) );\n+\n+  const std::complex<float> c01(0, 1);\n+  VERIFY( eq( std::proj(c01)  , c01 ) );\n+  VERIFY( eq( std::proj(-c01) , -c01 ) );\n+  c00.real(-0.0);\n+  VERIFY( eq( std::proj(c01)  , c01 ) );\n+  VERIFY( eq( std::proj(-c01) , -c01 ) );\n+\n+  const std::complex<float> c10(1, 0);\n+  VERIFY( eq( std::proj(c10)  , c10 ) );\n+  VERIFY( eq( std::proj(-c10) , -c10 ) );\n+\n+  const std::complex<float> c12(1, 2);\n+  VERIFY( eq( std::proj(c12)  , c12 ) );\n+  VERIFY( eq( std::proj(-c12) , -c12 ) );\n+\n+  const std::complex<float> c0q(0, qnan);\n+  VERIFY( eq( std::proj(c0q)  , c0q ) );\n+  VERIFY( eq( std::proj(-c0q) , -c0q ) );\n+\n+  const std::complex<float> c1q(1, qnan);\n+  VERIFY( eq( std::proj(c1q)  , c1q ) );\n+  VERIFY( eq( std::proj(-c1q) , -c1q ) );\n+\n+  const std::complex<float> cq0(qnan, 0);\n+  VERIFY( eq( std::proj(cq0)  , cq0 ) );\n+  VERIFY( eq( std::proj(-cq0) , -cq0 ) );\n+\n+  const std::complex<float> cq1(qnan, 1);\n+  VERIFY( eq( std::proj(cq1)  , cq1 ) );\n+  VERIFY( eq( std::proj(-cq1) , -cq1 ) );\n+\n+  const std::complex<float> cqq(qnan, qnan);\n+  VERIFY( eq( std::proj(cqq)  , cqq ) );\n+  VERIFY( eq( std::proj(-cqq) , -cqq ) );\n+\n+  const std::complex<float> c0p(0, pinf);\n+  VERIFY( eq( std::proj(c0p)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-c0p) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> c1p(1, pinf);\n+  VERIFY( eq( std::proj(c1p)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-c1p) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> cqp(qnan, pinf);\n+  VERIFY( eq( std::proj(cqp)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cqp) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> cpp(pinf, pinf);\n+  VERIFY( eq( std::proj(cpp)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cpp) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float>  c0n(0, ninf);\n+  VERIFY( eq( std::proj(c0n)  , std::complex<float>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-c0n) , std::complex<float>(pinf, +0.0) ) );\n+\n+  const std::complex<float> c1n(1, ninf);\n+  VERIFY( eq( std::proj(c1n)  , std::complex<float>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-c1n) , std::complex<float>(pinf, +0.0) ) );\n+\n+  const std::complex<float> cqn(qnan, ninf);\n+  VERIFY( eq( std::proj(cqn)  , std::complex<float>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cqn) , std::complex<float>(pinf, +0.0) ) );\n+\n+  const std::complex<float> cpn(pinf, ninf);\n+  VERIFY( eq( std::proj(cpn)  , std::complex<float>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cpn) , std::complex<float>(pinf, +0.0) ) );\n+\n+  const std::complex<float> cnn(ninf, ninf);\n+  VERIFY( eq( std::proj(cnn)  , std::complex<float>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cnn) , std::complex<float>(pinf, +0.0) ) );\n+\n+  const std::complex<float> cp0(pinf, 0);\n+  VERIFY( eq( std::proj(cp0)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cp0) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> cp1(pinf, 1);\n+  VERIFY( eq( std::proj(cp1)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cp1) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> cpq(pinf, qnan);\n+  VERIFY( eq( std::proj(cpq)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cpq) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> cn0(ninf, 0);\n+  VERIFY( eq( std::proj(cn0)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cn0) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> cn1(ninf, 1);\n+  VERIFY( eq( std::proj(cn1)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cn1) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> cnq(ninf, qnan);\n+  VERIFY( eq( std::proj(cnq)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cnq) , std::complex<float>(pinf, -0.0) ) );\n+\n+  const std::complex<float> cnp(ninf, pinf);\n+  VERIFY( eq( std::proj(cnp)  , std::complex<float>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cnp) , std::complex<float>(pinf, -0.0) ) );\n+}\n+\n+void\n+test03()\n+{\n+  const long double qnan = std::numeric_limits<long double>::quiet_NaN();\n+  const long double pinf = std::numeric_limits<long double>::infinity();\n+  const long double ninf = -pinf;\n+\n+  std::complex<long double> c00(0, 0);\n+  VERIFY( eq( std::proj(c00)  , c00 ) );\n+  VERIFY( eq( std::proj(-c00) , -c00 ) );\n+  c00.real(-0.0);\n+  VERIFY( eq( std::proj(c00)  , c00 ) );\n+  VERIFY( eq( std::proj(-c00) , -c00 ) );\n+\n+  const std::complex<long double> c01(0, 1);\n+  VERIFY( eq( std::proj(c01)  , c01 ) );\n+  VERIFY( eq( std::proj(-c01) , -c01 ) );\n+  c00.real(-0.0);\n+  VERIFY( eq( std::proj(c01)  , c01 ) );\n+  VERIFY( eq( std::proj(-c01) , -c01 ) );\n+\n+  const std::complex<long double> c10(1, 0);\n+  VERIFY( eq( std::proj(c10)  , c10 ) );\n+  VERIFY( eq( std::proj(-c10) , -c10 ) );\n+\n+  const std::complex<long double> c12(1, 2);\n+  VERIFY( eq( std::proj(c12)  , c12 ) );\n+  VERIFY( eq( std::proj(-c12) , -c12 ) );\n+\n+  const std::complex<long double> c0q(0, qnan);\n+  VERIFY( eq( std::proj(c0q)  , c0q ) );\n+  VERIFY( eq( std::proj(-c0q) , -c0q ) );\n+\n+  const std::complex<long double> c1q(1, qnan);\n+  VERIFY( eq( std::proj(c1q)  , c1q ) );\n+  VERIFY( eq( std::proj(-c1q) , -c1q ) );\n+\n+  const std::complex<long double> cq0(qnan, 0);\n+  VERIFY( eq( std::proj(cq0)  , cq0 ) );\n+  VERIFY( eq( std::proj(-cq0) , -cq0 ) );\n+\n+  const std::complex<long double> cq1(qnan, 1);\n+  VERIFY( eq( std::proj(cq1)  , cq1 ) );\n+  VERIFY( eq( std::proj(-cq1) , -cq1 ) );\n+\n+  const std::complex<long double> cqq(qnan, qnan);\n+  VERIFY( eq( std::proj(cqq)  , cqq ) );\n+  VERIFY( eq( std::proj(-cqq) , -cqq ) );\n+\n+  const std::complex<long double> c0p(0, pinf);\n+  VERIFY( eq( std::proj(c0p)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-c0p) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> c1p(1, pinf);\n+  VERIFY( eq( std::proj(c1p)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-c1p) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> cqp(qnan, pinf);\n+  VERIFY( eq( std::proj(cqp)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cqp) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> cpp(pinf, pinf);\n+  VERIFY( eq( std::proj(cpp)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cpp) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double>  c0n(0, ninf);\n+  VERIFY( eq( std::proj(c0n) , std::complex<long double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-c0n) , std::complex<long double>(pinf, +0.0) ) );\n+\n+  const std::complex<long double> c1n(1, ninf);\n+  VERIFY( eq( std::proj(c1n)  , std::complex<long double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-c1n) , std::complex<long double>(pinf, +0.0) ) );\n+\n+  const std::complex<long double> cqn(qnan, ninf);\n+  VERIFY( eq( std::proj(cqn)  , std::complex<long double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cqn) , std::complex<long double>(pinf, +0.0) ) );\n+\n+  const std::complex<long double> cpn(pinf, ninf);\n+  VERIFY( eq( std::proj(cpn)  , std::complex<long double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cpn) , std::complex<long double>(pinf, +0.0) ) );\n+\n+  const std::complex<long double> cnn(ninf, ninf);\n+  VERIFY( eq( std::proj(cnn)  , std::complex<long double>(pinf, -0.0) ) );\n+  VERIFY( eq( std::proj(-cnn) , std::complex<long double>(pinf, +0.0) ) );\n+\n+  const std::complex<long double> cp0(pinf, 0);\n+  VERIFY( eq( std::proj(cp0)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cp0) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> cp1(pinf, 1);\n+  VERIFY( eq( std::proj(cp1)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cp1) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> cpq(pinf, qnan);\n+  VERIFY( eq( std::proj(cpq)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cpq) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> cn0(ninf, 0);\n+  VERIFY( eq( std::proj(cn0)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cn0) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> cn1(ninf, 1);\n+  VERIFY( eq( std::proj(cn1)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cn1) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> cnq(ninf, qnan);\n+  VERIFY( eq( std::proj(cnq)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cnq) , std::complex<long double>(pinf, -0.0) ) );\n+\n+  const std::complex<long double> cnp(ninf, pinf);\n+  VERIFY( eq( std::proj(cnp)  , std::complex<long double>(pinf, +0.0) ) );\n+  VERIFY( eq( std::proj(-cnp) , std::complex<long double>(pinf, -0.0) ) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}]}