{"sha": "a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk4ZTRlNjJjMWMwYzg1NzBjN2RiMzIxZTNjOGEyYTdjMjMzNmM2MA==", "commit": {"author": {"name": "John Marino", "email": "gnugcc@marino.st", "date": "2015-08-27T12:12:41Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-08-27T12:12:41Z"}, "message": "Provide nearly complete std::locale support for DragonFly\n\n2015-08-27  John Marino  <gnugcc@marino.st>\n\n\t* acinclude.m4 (*-*-dragonfly*): Change 7 locale support files\n\tfrom generic to new DragonFly versions.\n\t* configure: Regenerate.\n\t* config/locale/dragonfly/c_locale.cc: Improve locale support.\n\t* config/locale/dragonfly/ctype_members.cc: Likewise.\n\t* config/os/bsd/dragonfly/ctype_configure_char.cc: Likewise.\n\t* config/os/bsd/dragonfly/os_defines.h: Define _GLIBCXX_USE_C99.\n\t* config/locale/dragonfly/c_locale.h: New.\n\t* config/locale/dragonfly/codecvt_members.cc: New.\n\t* config/locale/dragonfly/collate_members.cc: New.\n\t* config/locale/dragonfly/monetary_members.cc: New.\n\t* config/locale/dragonfly/numeric_members.cc: New.\n\t* config/locale/dragonfly/time_members.cc: New.\n\t* config/locale/dragonfly/time_members.h: New.\n\nFrom-SVN: r227257", "tree": {"sha": "329a40068557be978e05678346e2bd98819dc11b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/329a40068557be978e05678346e2bd98819dc11b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a185c87663f4cf8315d085b52ef388687253733a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a185c87663f4cf8315d085b52ef388687253733a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a185c87663f4cf8315d085b52ef388687253733a"}], "stats": {"total": 2517, "additions": 2301, "deletions": 216}, "files": [{"sha": "e74daf479a5bde0ad6cb9c12fb54a3a5caf2e34d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -1,3 +1,20 @@\n+2015-08-27  John Marino  <gnugcc@marino.st>\n+\n+\t* acinclude.m4 (*-*-dragonfly*): Change 7 locale support files\n+\tfrom generic to new DragonFly versions.\n+\t* configure: Regenerate.\n+\t* config/locale/dragonfly/c_locale.cc: Improve locale support.\n+\t* config/locale/dragonfly/ctype_members.cc: Likewise.\n+\t* config/os/bsd/dragonfly/ctype_configure_char.cc: Likewise.\n+\t* config/os/bsd/dragonfly/os_defines.h: Define _GLIBCXX_USE_C99.\n+\t* config/locale/dragonfly/c_locale.h: New.\n+\t* config/locale/dragonfly/codecvt_members.cc: New.\n+\t* config/locale/dragonfly/collate_members.cc: New.\n+\t* config/locale/dragonfly/monetary_members.cc: New.\n+\t* config/locale/dragonfly/numeric_members.cc: New.\n+\t* config/locale/dragonfly/time_members.cc: New.\n+\t* config/locale/dragonfly/time_members.h: New.\n+\n 2015-08-27  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* configure: Regenerate."}, {"sha": "789bc5894a0fea96cc8ef8a07350836713e9ba95", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -2087,17 +2087,17 @@ AC_DEFUN([GLIBCXX_ENABLE_CLOCALE], [\n     dragonfly)\n       AC_MSG_RESULT(dragonfly)\n \n-      CLOCALE_H=config/locale/generic/c_locale.h\n+      CLOCALE_H=config/locale/dragonfly/c_locale.h\n       CLOCALE_CC=config/locale/dragonfly/c_locale.cc\n-      CCODECVT_CC=config/locale/generic/codecvt_members.cc\n-      CCOLLATE_CC=config/locale/generic/collate_members.cc\n+      CCODECVT_CC=config/locale/dragonfly/codecvt_members.cc\n+      CCOLLATE_CC=config/locale/dragonfly/collate_members.cc\n       CCTYPE_CC=config/locale/dragonfly/ctype_members.cc\n       CMESSAGES_H=config/locale/generic/messages_members.h\n       CMESSAGES_CC=config/locale/generic/messages_members.cc\n-      CMONEY_CC=config/locale/generic/monetary_members.cc\n-      CNUMERIC_CC=config/locale/generic/numeric_members.cc\n-      CTIME_H=config/locale/generic/time_members.h\n-      CTIME_CC=config/locale/generic/time_members.cc\n+      CMONEY_CC=config/locale/dragonfly/monetary_members.cc\n+      CNUMERIC_CC=config/locale/dragonfly/numeric_members.cc\n+      CTIME_H=config/locale/dragonfly/time_members.h\n+      CTIME_CC=config/locale/dragonfly/time_members.cc\n       CLOCALE_INTERNAL_H=config/locale/generic/c++locale_internal.h\n       ;;\n "}, {"sha": "500cf7e47bae9d12b1770053d74a3b03a5a9a813", "filename": "libstdc++-v3/config/locale/dragonfly/c_locale.cc", "status": "modified", "additions": 65, "deletions": 164, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fc_locale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fc_locale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fc_locale.cc?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -1,4 +1,4 @@\n-// Wrapper for underlying C-language localization -*- C++ -*-\n+// localization implementation details, DragonFly version -*- C++ -*-\n \n // Copyright (C) 2014-2015 Free Software Foundation, Inc.\n //\n@@ -27,18 +27,14 @@\n //\n \n // Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n \n-#include <cerrno>  // For errno\n-#include <cmath>  // For isinf, finite, finitef, fabs\n-#include <cstdlib>  // For strof, strtold\n-#include <cstring>\n-#include <cstdio>\n+#include <cstdlib>\n #include <locale>\n+#include <stdexcept>\n #include <limits>\n-\n-#ifdef _GLIBCXX_HAVE_IEEEFP_H\n-#include <ieeefp.h>\n-#endif\n+#include <langinfo.h>\n+#include <xlocale.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -47,40 +43,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<>\n     void\n     __convert_to_v(const char* __s, float& __v, ios_base::iostate& __err,\n-\t\t   const __c_locale&) throw()\n+\t\t   const __c_locale& __cloc) throw()\n     {\n-      // Assumes __s formatted for \"C\" locale.\n-      char* __old = setlocale(LC_ALL, 0);\n-      const size_t __len = strlen(__old) + 1;\n-      char* __sav = new char[__len];\n-      memcpy(__sav, __old, __len);\n-      setlocale(LC_ALL, \"C\");\n       char* __sanity;\n-      bool __overflow = false;\n-\n-#if !__FLT_HAS_INFINITY__\n-      errno = 0;\n-#endif\n-\n-#ifdef _GLIBCXX_HAVE_STRTOF\n-      __v = strtof(__s, &__sanity);\n-#else\n-      double __d = strtod(__s, &__sanity);\n-      __v = static_cast<float>(__d);\n-#ifdef _GLIBCXX_HAVE_FINITEF\n-      if (!finitef (__v))\n-\t__overflow = true;\n-#elif defined (_GLIBCXX_HAVE_FINITE)\n-      if (!finite (static_cast<double> (__v)))\n-\t__overflow = true;\n-#elif defined (_GLIBCXX_HAVE_ISINF)\n-      if (isinf (static_cast<double> (__v)))\n-\t__overflow = true;\n-#else\n-      if (fabs(__d) > numeric_limits<float>::max())\n-\t__overflow = true;\n-#endif\n-#endif // _GLIBCXX_HAVE_STRTOF\n+      __v = strtof_l(__s, &__sanity, (locale_t)__cloc);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 23. Num_get overflow result.\n@@ -89,44 +55,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __v = 0.0f;\n \t  __err = ios_base::failbit;\n \t}\n-      else if (__overflow\n-#if __FLT_HAS_INFINITY__\n-\t       || __v == numeric_limits<float>::infinity()\n-\t       || __v == -numeric_limits<float>::infinity()\n-#else\n-\t       || ((__v > 1.0f || __v < -1.0f) && errno == ERANGE)\n-#endif\n-\t      )\n+      else if (__v == numeric_limits<float>::infinity())\n \t{\n-\t  if (__v > 0.0f)\n-\t    __v = numeric_limits<float>::max();\n-\t  else\n-\t    __v = -numeric_limits<float>::max();\n+\t  __v = numeric_limits<float>::max();\n+\t  __err = ios_base::failbit;\n+\t}\n+      else if (__v == -numeric_limits<float>::infinity())\n+\t{\n+\t  __v = -numeric_limits<float>::max();\n \t  __err = ios_base::failbit;\n \t}\n-\n-      setlocale(LC_ALL, __sav);\n-      delete [] __sav;\n     }\n \n   template<>\n     void\n     __convert_to_v(const char* __s, double& __v, ios_base::iostate& __err,\n-\t\t   const __c_locale&) throw()\n+\t\t   const __c_locale& __cloc) throw()\n     {\n-      // Assumes __s formatted for \"C\" locale.\n-      char* __old = setlocale(LC_ALL, 0);\n-      const size_t __len = strlen(__old) + 1;\n-      char* __sav = new char[__len];\n-      memcpy(__sav, __old, __len);\n-      setlocale(LC_ALL, \"C\");\n       char* __sanity;\n-\n-#if !__DBL_HAS_INFINITY__\n-      errno = 0;\n-#endif\n-\n-      __v = strtod(__s, &__sanity);\n+      __v = strtod_l(__s, &__sanity, (locale_t)__cloc);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 23. Num_get overflow result.\n@@ -135,132 +82,86 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __v = 0.0;\n \t  __err = ios_base::failbit;\n \t}\n-      else if (\n-#if __DBL_HAS_INFINITY__\n-\t       __v == numeric_limits<double>::infinity()\n-\t       || __v == -numeric_limits<double>::infinity())\n-#else\n-\t       (__v > 1.0 || __v < -1.0) && errno == ERANGE)\n-#endif\n+      else if (__v == numeric_limits<double>::infinity())\n \t{\n-\t  if (__v > 0.0)\n-\t    __v = numeric_limits<double>::max();\n-\t  else\n-\t    __v = -numeric_limits<double>::max();\n+\t  __v = numeric_limits<double>::max();\n+\t  __err = ios_base::failbit;\n+\t}\n+      else if (__v == -numeric_limits<double>::infinity())\n+\t{\n+\t  __v = -numeric_limits<double>::max();\n \t  __err = ios_base::failbit;\n \t}\n-\n-      setlocale(LC_ALL, __sav);\n-      delete [] __sav;\n     }\n \n   template<>\n     void\n-    __convert_to_v(const char* __s, long double& __v,\n-\t\t   ios_base::iostate& __err, const __c_locale&) throw()\n+    __convert_to_v(const char* __s, long double& __v, ios_base::iostate& __err,\n+\t\t   const __c_locale& __cloc) throw()\n     {\n-      // Assumes __s formatted for \"C\" locale.\n-      char* __old = setlocale(LC_ALL, 0);\n-      const size_t __len = strlen(__old) + 1;\n-      char* __sav = new char[__len];\n-      memcpy(__sav, __old, __len);\n-      setlocale(LC_ALL, \"C\");\n-\n-#if !__LDBL_HAS_INFINITY__\n-      errno = 0;\n-#endif\n-\n-#if defined(_GLIBCXX_HAVE_STRTOLD) && !defined(_GLIBCXX_HAVE_BROKEN_STRTOLD)\n       char* __sanity;\n-      __v = strtold(__s, &__sanity);\n+      __v = strtold_l(__s, &__sanity, (locale_t)__cloc);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 23. Num_get overflow result.\n       if (__sanity == __s || *__sanity != '\\0')\n-#else\n-      typedef char_traits<char>::int_type int_type;\n-      int __p = sscanf(__s, \"%Lf\", &__v);\n-\n-      if (!__p || static_cast<int_type>(__p) == char_traits<char>::eof())\n-#endif\n \t{\n \t  __v = 0.0l;\n \t  __err = ios_base::failbit;\n \t}\n-       else if (\n-#if __LDBL_HAS_INFINITY__\n-\t\t__v == numeric_limits<long double>::infinity()\n-\t\t|| __v == -numeric_limits<long double>::infinity())\n-#else\n-\t\t(__v > 1.0l || __v < -1.0l) && errno == ERANGE)\n-#endif\n+      else if (__v == numeric_limits<long double>::infinity())\n \t{\n-\t  if (__v > 0.0l)\n-\t    __v = numeric_limits<long double>::max();\n-\t  else\n-\t    __v = -numeric_limits<long double>::max();\n+\t  __v = numeric_limits<long double>::max();\n+\t  __err = ios_base::failbit;\n+\t}\n+      else if (__v == -numeric_limits<long double>::infinity())\n+\t{\n+\t  __v = -numeric_limits<long double>::max();\n \t  __err = ios_base::failbit;\n \t}\n-\n-      setlocale(LC_ALL, __sav);\n-      delete [] __sav;\n     }\n \n-\n-  /*  DragonFly's implementation of setlocale won't accept something like\n-      \"de_DE\".  According to nls manpage, the expected format is:\n-      language[_territory][.codeset][@modifier], but it seems that both\n-      the _territory and .codeset components are required.\n-      \n-      As an attempt to correct for this, we'll tack on \".UTF-8\" if \n-      a period is not detected in the locale string.  \n-\n-      There are no locales with modifiers on DragonFly so if found, they\n-      will just be stripped off silently.  e.g \"de_DE@euro\" will be reduced\n-      to \"de_DE\".  The UTF-8 default would be added after that.\n-  */\n-\n   void\n   locale::facet::_S_create_c_locale(__c_locale& __cloc, const char* __s,\n-\t\t\t\t    __c_locale)\n+\t\t\t\t    __c_locale __old)\n   {\n-    const size_t size__s = (__s == NULL) ? 1 : strlen (__s);\n-    const char UTF8[] = \".UTF-8\";\n-    char localspec[size__s + 6 + 1];\n-    \n-    if (__s == NULL) {\n-       localspec[0] = '\\0';\n-    } else {\n-       strcpy (localspec, __s);\n-       char * pch = strchr (localspec, '@');\n-       if (pch != NULL)\n-          *pch = 0;\n-\n-       if (  (strchr (__s, '.') == NULL)\n-          && (strcmp (__s, \"C\") != 0)\n-          && (strcmp (__s, \"POSIX\") != 0))\n-          strncat (localspec, UTF8, 6);\n-    }\n-\n-    const char * result = std::setlocale(LC_ALL, localspec);\n-    \n-    if ((strcmp(result, \"C\") != 0) && (strcmp (result, localspec) != 0))\n-      __throw_runtime_error(__N(\"locale::facet::_S_create_c_locale \"\n-\t\t\t    \"name not valid\"));\n-    __cloc = 0;\n+    __cloc = (__c_locale)newlocale(LC_ALL_MASK, __s, (locale_t)__old);\n+    if (!__cloc)\n+      {\n+\t// This named locale is not supported by the underlying OS.\n+\t__throw_runtime_error(__N(\"locale::facet::_S_create_c_locale \"\n+\t\t\t\t  \"name not valid\"));\n+      }\n   }\n \n   void\n   locale::facet::_S_destroy_c_locale(__c_locale& __cloc)\n-  { __cloc = 0; }\n+  {\n+    if (__cloc && _S_get_c_locale() != __cloc)\n+      freelocale((locale_t)__cloc);\n+  }\n \n   __c_locale\n-  locale::facet::_S_clone_c_locale(__c_locale&) throw()\n-  { return __c_locale(); }\n+  locale::facet::_S_clone_c_locale(__c_locale& __cloc) throw()\n+  { return (__c_locale)duplocale((locale_t)__cloc); }\n \n   __c_locale\n-  locale::facet::_S_lc_ctype_c_locale(__c_locale, const char*)\n-  { return __c_locale(); }\n+  locale::facet::_S_lc_ctype_c_locale(__c_locale __cloc, const char* __s)\n+  {\n+    __c_locale __dup = (__c_locale)duplocale((locale_t)__cloc);\n+    if (__dup == __c_locale(0))\n+      __throw_runtime_error(__N(\"locale::facet::_S_lc_ctype_c_locale \"\n+\t\t\t\t\"duplocale error\"));\n+    __c_locale __changed = (__c_locale)newlocale(LC_CTYPE_MASK, __s,\n+\t\t\t\t\t\t (locale_t)__dup);\n+    if (__changed == __c_locale(0))\n+      {\n+\tfreelocale((locale_t)__dup);\n+\t__throw_runtime_error(__N(\"locale::facet::_S_lc_ctype_c_locale \"\n+\t\t\t\t  \"newlocale error\"));\n+      }\n+    return __changed;\n+  }\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n@@ -295,5 +196,5 @@ _GLIBCXX_END_NAMESPACE_VERSION\n #ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n #define _GLIBCXX_LDBL_COMPAT(dbl, ldbl) \\\n   extern \"C\" void ldbl (void) __attribute__ ((alias (#dbl)))\n-_GLIBCXX_LDBL_COMPAT(_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKPi, _ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKPi);\n+_GLIBCXX_LDBL_COMPAT(_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct, _ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct);\n #endif // _GLIBCXX_LONG_DOUBLE_COMPAT"}, {"sha": "5c17cfe10c3af04d4fb260aed16fa52d4b2b1d67", "filename": "libstdc++-v3/config/locale/dragonfly/c_locale.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fc_locale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fc_locale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fc_locale.h?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -0,0 +1,82 @@\n+// localization implementation details, DragonFly version -*- C++ -*-\n+\n+// Copyright (C) 2001-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/c++locale.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{locale}\n+ */\n+\n+//\n+// ISO C++ 14882: 22.8  Standard locale categories.\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n+\n+#ifndef _GLIBCXX_CXX_LOCALE_H\n+#define _GLIBCXX_CXX_LOCALE_H 1\n+\n+#pragma GCC system_header\n+\n+#include <clocale>\n+#include <xlocale.h>\n+\n+#define _GLIBCXX_NUM_CATEGORIES 0\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  typedef int*\t\t\t__c_locale;\n+\n+  // Convert numeric value of type double and long double to string and\n+  // return length of string.  If vsnprintf is available use it, otherwise\n+  // fall back to the unsafe vsprintf which, in general, can be dangerous\n+  // and should be avoided.\n+  inline int\n+  __convert_from_v(const __c_locale& __cloc, char* __out,\n+\t\t   const int __size __attribute__ ((__unused__)),\n+\t\t   const char* __fmt, ...)\n+  {\n+    __c_locale __old = (__c_locale)uselocale((locale_t)__cloc);\n+\n+    __builtin_va_list __args;\n+    __builtin_va_start(__args, __fmt);\n+\n+#ifdef _GLIBCXX_USE_C99\n+    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);\n+#else\n+    const int __ret = __builtin_vsprintf(__out, __fmt, __args);\n+#endif\n+\n+    __builtin_va_end(__args);\n+\n+    uselocale((locale_t)__old);\n+    return __ret;\n+  }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif"}, {"sha": "9aef875563819ecd33563fee712540e7cff9dfcd", "filename": "libstdc++-v3/config/locale/dragonfly/codecvt_members.cc", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fcodecvt_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fcodecvt_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fcodecvt_members.cc?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -0,0 +1,288 @@\n+// std::codecvt implementation details, DragonFly version -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+//\n+// ISO C++ 14882: 22.2.1.5 - Template class codecvt\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n+\n+#include <locale>\n+#include <cstring>\n+#include <cstdlib>  // For MB_CUR_MAX\n+#include <climits>  // For MB_LEN_MAX\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // Specializations.\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  codecvt_base::result\n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_out(state_type& __state, const intern_type* __from, \n+\t const intern_type* __from_end, const intern_type*& __from_next,\n+\t extern_type* __to, extern_type* __to_end,\n+\t extern_type*& __to_next) const\n+  {\n+    result __ret = ok;\n+    state_type __tmp_state(__state);\n+\n+    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_codecvt);\n+\n+    // wcsnrtombs is *very* fast but stops if encounters NUL characters:\n+    // in case we fall back to wcrtomb and then continue, in a loop.\n+    // NB: wcsnrtombs is a GNU extension\n+    for (__from_next = __from, __to_next = __to;\n+\t __from_next < __from_end && __to_next < __to_end\n+\t && __ret == ok;)\n+      {\n+\tconst intern_type* __from_chunk_end = wmemchr(__from_next, L'\\0',\n+\t\t\t\t\t\t      __from_end - __from_next);\n+\tif (!__from_chunk_end)\n+\t  __from_chunk_end = __from_end;\n+\n+\t__from = __from_next;\n+\tconst size_t __conv = wcsnrtombs(__to_next, &__from_next,\n+\t\t\t\t\t __from_chunk_end - __from_next,\n+\t\t\t\t\t __to_end - __to_next, &__state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    // In case of error, in order to stop at the exact place we\n+\t    // have to start again from the beginning with a series of\n+\t    // wcrtomb.\n+\t    for (; __from < __from_next; ++__from)\n+\t      __to_next += wcrtomb(__to_next, *__from, &__tmp_state);\n+\t    __state = __tmp_state;\n+\t    __ret = error;\n+\t  }\n+\telse if (__from_next && __from_next < __from_chunk_end)\n+\t  {\n+\t    __to_next += __conv;\n+\t    __ret = partial;\n+\t  }\n+\telse\n+\t  {\n+\t    __from_next = __from_chunk_end;\n+\t    __to_next += __conv;\n+\t  }\n+\n+\tif (__from_next < __from_end && __ret == ok)\n+\t  {\n+\t    extern_type __buf[MB_LEN_MAX];\n+\t    __tmp_state = __state;\n+\t    const size_t __conv2 = wcrtomb(__buf, *__from_next, &__tmp_state);\n+\t    if (__conv2 > static_cast<size_t>(__to_end - __to_next))\n+\t      __ret = partial;\n+\t    else\n+\t      {\n+\t\tmemcpy(__to_next, __buf, __conv2);\n+\t\t__state = __tmp_state;\n+\t\t__to_next += __conv2;\n+\t\t++__from_next;\n+\t      }\n+\t  }\n+      }\n+\n+    uselocale((locale_t)__old);\n+\n+    return __ret; \n+  }\n+  \n+  codecvt_base::result\n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_in(state_type& __state, const extern_type* __from, \n+\tconst extern_type* __from_end, const extern_type*& __from_next,\n+\tintern_type* __to, intern_type* __to_end,\n+\tintern_type*& __to_next) const\n+  {\n+    result __ret = ok;\n+    state_type __tmp_state(__state);\n+\n+    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_codecvt);\n+\n+    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n+    // in case we store a L'\\0' and then continue, in a loop.\n+    // NB: mbsnrtowcs is a GNU extension\n+    for (__from_next = __from, __to_next = __to;\n+\t __from_next < __from_end && __to_next < __to_end\n+\t && __ret == ok;)\n+      {\n+\tconst extern_type* __from_chunk_end;\n+\t__from_chunk_end = static_cast<const extern_type*>(memchr(__from_next, '\\0',\n+\t\t\t\t\t\t\t\t  __from_end\n+\t\t\t\t\t\t\t\t  - __from_next));\n+\tif (!__from_chunk_end)\n+\t  __from_chunk_end = __from_end;\n+\n+\t__from = __from_next;\n+\tsize_t __conv = mbsnrtowcs(__to_next, &__from_next,\n+\t\t\t\t   __from_chunk_end - __from_next,\n+\t\t\t\t   __to_end - __to_next, &__state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    // In case of error, in order to stop at the exact place we\n+\t    // have to start again from the beginning with a series of\n+\t    // mbrtowc.\n+\t    for (;; ++__to_next, __from += __conv)\n+\t      {\n+\t\t__conv = mbrtowc(__to_next, __from, __from_end - __from,\n+\t\t\t\t &__tmp_state);\n+\t\tif (__conv == static_cast<size_t>(-1)\n+\t\t    || __conv == static_cast<size_t>(-2))\n+\t\t  break;\n+\t      }\n+\t    __from_next = __from;\n+\t    __state = __tmp_state;\t    \n+\t    __ret = error;\n+\t  }\n+\telse if (__from_next && __from_next < __from_chunk_end)\n+\t  {\n+\t    // It is unclear what to return in this case (see DR 382). \n+\t    __to_next += __conv;\n+\t    __ret = partial;\n+\t  }\n+\telse\n+\t  {\n+\t    __from_next = __from_chunk_end;\n+\t    __to_next += __conv;\n+\t  }\n+\n+\tif (__from_next < __from_end && __ret == ok)\n+\t  {\n+\t    if (__to_next < __to_end)\n+\t      {\n+\t\t// XXX Probably wrong for stateful encodings\n+\t\t__tmp_state = __state;\t\t\n+\t\t++__from_next;\n+\t\t*__to_next++ = L'\\0';\n+\t      }\n+\t    else\n+\t      __ret = partial;\n+\t  }\n+      }\n+\n+    uselocale((locale_t)__old);\n+\n+    return __ret; \n+  }\n+\n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_encoding() const throw()\n+  {\n+    // XXX This implementation assumes that the encoding is\n+    // stateless and is either single-byte or variable-width.\n+    int __ret = 0;\n+    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_codecvt);\n+    if (MB_CUR_MAX == 1)\n+      __ret = 1;\n+    uselocale((locale_t)__old);\n+    return __ret;\n+  }  \n+\n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_max_length() const throw()\n+  {\n+    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_codecvt);\n+    // XXX Probably wrong for stateful encodings.\n+    int __ret = MB_CUR_MAX;\n+    uselocale((locale_t)__old);\n+    return __ret;\n+  }\n+  \n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_length(state_type& __state, const extern_type* __from,\n+\t    const extern_type* __end, size_t __max) const\n+  {\n+    int __ret = 0;\n+    state_type __tmp_state(__state);\n+\n+    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_codecvt);\n+\n+    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n+    // in case we advance past it and then continue, in a loop.\n+    // NB: mbsnrtowcs is a GNU extension\n+  \n+    // A dummy internal buffer is needed in order for mbsnrtocws to consider\n+    // its fourth parameter (it wouldn't with NULL as first parameter).\n+    wchar_t* __to = static_cast<wchar_t*>(__builtin_alloca(sizeof(wchar_t) \n+\t\t\t\t\t\t\t   * __max));\n+    while (__from < __end && __max)\n+      {\n+\tconst extern_type* __from_chunk_end;\n+\t__from_chunk_end = static_cast<const extern_type*>(memchr(__from, '\\0',\n+\t\t\t\t\t\t\t\t  __end\n+\t\t\t\t\t\t\t\t  - __from));\n+\tif (!__from_chunk_end)\n+\t  __from_chunk_end = __end;\n+\n+\tconst extern_type* __tmp_from = __from;\n+\tsize_t __conv = mbsnrtowcs(__to, &__from,\n+\t\t\t\t   __from_chunk_end - __from,\n+\t\t\t\t   __max, &__state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    // In case of error, in order to stop at the exact place we\n+\t    // have to start again from the beginning with a series of\n+\t    // mbrtowc.\n+\t    for (__from = __tmp_from;; __from += __conv)\n+\t      {\n+\t\t__conv = mbrtowc(0, __from, __end - __from,\n+\t\t\t\t &__tmp_state);\n+\t\tif (__conv == static_cast<size_t>(-1)\n+\t\t    || __conv == static_cast<size_t>(-2))\n+\t\t  break;\n+\t      }\n+\t    __state = __tmp_state;\n+\t    __ret += __from - __tmp_from;\n+\t    break;\n+\t  }\n+\tif (!__from)\n+\t  __from = __from_chunk_end;\n+\t\n+\t__ret += __from - __tmp_from;\n+\t__max -= __conv;\n+\n+\tif (__from < __end && __max)\n+\t  {\n+\t    // XXX Probably wrong for stateful encodings\n+\t    __tmp_state = __state;\n+\t    ++__from;\n+\t    ++__ret;\n+\t    --__max;\n+\t  }\n+      }\n+\n+    uselocale((locale_t)__old);\n+\n+    return __ret; \n+  }\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "7cd6c5baf19129f7a15b691b80d9e2d63f8fafdd", "filename": "libstdc++-v3/config/locale/dragonfly/collate_members.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fcollate_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fcollate_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fcollate_members.cc?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -0,0 +1,74 @@\n+// std::collate implementation details, DragonFly version -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+//\n+// ISO C++ 14882: 22.2.4.1.2  collate virtual functions\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n+\n+#include <locale>\n+#include <cstring>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // These are basically extensions to char_traits, and perhaps should\n+  // be put there instead of here.\n+  template<>\n+    int \n+    collate<char>::_M_compare(const char* __one, \n+\t\t\t      const char* __two) const throw()\n+    { \n+      int __cmp = strcoll_l(__one, __two, (locale_t)_M_c_locale_collate);\n+      return (__cmp >> (8 * sizeof (int) - 2)) | (__cmp != 0);\n+    }\n+  \n+  template<>\n+    size_t\n+    collate<char>::_M_transform(char* __to, const char* __from, \n+\t\t\t\tsize_t __n) const throw()\n+    { return strxfrm_l(__to, __from, __n, (locale_t)_M_c_locale_collate); }\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    int \n+    collate<wchar_t>::_M_compare(const wchar_t* __one, \n+\t\t\t\t const wchar_t* __two) const throw()\n+    {\n+      int __cmp = wcscoll_l(__one, __two, (locale_t)_M_c_locale_collate);\n+      return (__cmp >> (8 * sizeof (int) - 2)) | (__cmp != 0);\n+    }\n+  \n+  template<>\n+    size_t\n+    collate<wchar_t>::_M_transform(wchar_t* __to, const wchar_t* __from,\n+\t\t\t\t   size_t __n) const throw()\n+    { return wcsxfrm_l(__to, __from, __n, (locale_t)_M_c_locale_collate); }\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "7b6b34f23a6193c70941882f5ad162f5625adde7", "filename": "libstdc++-v3/config/locale/dragonfly/ctype_members.cc", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fctype_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fctype_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fctype_members.cc?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -1,4 +1,4 @@\n-// std::ctype implementation details, GNU version -*- C++ -*-\n+// std::ctype implementation details, DragonFly version -*- C++ -*-\n \n // Copyright (C) 2014-2015 Free Software Foundation, Inc.\n //\n@@ -27,18 +27,22 @@\n //\n \n // Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n \n #include <locale>\n-#include <bits/c++locale_internal.h>\n-#include <cstdlib>\n #include <cstring>\n #include <cstdio>\n \n+#ifndef _ISbit\n+#define _ISbit(bit) ((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n   // NB: The other ctype<char> specializations are in src/locale.cc and\n   // various /config/os/* files.\n-\n   ctype_byname<char>::ctype_byname(const char* __s, size_t __refs)\n   : ctype<char>(0, false, __refs) \n   { \t\t\n@@ -54,39 +58,78 @@ namespace std _GLIBCXX_VISIBILITY(default)\n \n #ifdef _GLIBCXX_USE_WCHAR_T  \n   ctype<wchar_t>::__wmask_type\n-  ctype<wchar_t>::_M_convert_to_wmask(\n-    const mask __attribute__((__unused__)) __m) const throw()\n+  ctype<wchar_t>::_M_convert_to_wmask(const mask __m) const throw()\n   {\n-    // DragonFly uses the same codes for 'char' as 'wchar_t', so this routine\n-    // never gets called.\n-    return __wmask_type();\n-  };\n+    __wmask_type __ret;\n+    switch (__m)\n+      {\n+      case space:\n+\t__ret = wctype_l(\"space\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case print:\n+\t__ret = wctype_l(\"print\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case cntrl:\n+\t__ret = wctype_l(\"cntrl\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case upper:\n+\t__ret = wctype_l(\"upper\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case lower:\n+\t__ret = wctype_l(\"lower\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case alpha:\n+\t__ret = wctype_l(\"alpha\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case digit:\n+\t__ret = wctype_l(\"digit\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case punct:\n+\t__ret = wctype_l(\"punct\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case xdigit:\n+\t__ret = wctype_l(\"xdigit\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case alnum:\n+\t__ret = wctype_l(\"alnum\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case graph:\n+\t__ret = wctype_l(\"graph\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      case blank:\n+\t__ret = wctype_l(\"blank\", (locale_t)_M_c_locale_ctype);\n+\tbreak;\n+      default:\n+\t__ret = __wmask_type();\n+      }\n+    return __ret;\n+  }\n   \n   wchar_t\n   ctype<wchar_t>::do_toupper(wchar_t __c) const\n-  { return towupper(__c); }\n+  { return towupper_l(__c, (locale_t)_M_c_locale_ctype); }\n \n   const wchar_t*\n   ctype<wchar_t>::do_toupper(wchar_t* __lo, const wchar_t* __hi) const\n   {\n     while (__lo < __hi)\n       {\n-        *__lo = towupper(*__lo);\n+        *__lo = towupper_l(*__lo, (locale_t)_M_c_locale_ctype);\n         ++__lo;\n       }\n     return __hi;\n   }\n   \n   wchar_t\n   ctype<wchar_t>::do_tolower(wchar_t __c) const\n-  { return towlower(__c); }\n+  { return towlower_l(__c, (locale_t)_M_c_locale_ctype); }\n   \n   const wchar_t*\n   ctype<wchar_t>::do_tolower(wchar_t* __lo, const wchar_t* __hi) const\n   {\n     while (__lo < __hi)\n       {\n-        *__lo = towlower(*__lo);\n+        *__lo = towlower_l(*__lo, (locale_t)_M_c_locale_ctype);\n         ++__lo;\n       }\n     return __hi;\n@@ -113,10 +156,12 @@ namespace std _GLIBCXX_VISIBILITY(default)\n   char\n   ctype<wchar_t>::\n   do_narrow(wchar_t __wc, char __dfault) const\n-  { \n+  {\n     if (__wc >= 0 && __wc < 128 && _M_narrow_ok)\n       return _M_narrow[__wc];\n+    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_ctype);\n     const int __c = wctob(__wc);\n+    uselocale((locale_t)__old);\n     return (__c == EOF ? __dfault : static_cast<char>(__c)); \n   }\n \n@@ -125,6 +170,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n   do_narrow(const wchar_t* __lo, const wchar_t* __hi, char __dfault, \n \t    char* __dest) const\n   {\n+    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_ctype);\n     if (_M_narrow_ok)\n       while (__lo < __hi)\n \t{\n@@ -146,12 +192,14 @@ namespace std _GLIBCXX_VISIBILITY(default)\n \t  ++__lo;\n \t  ++__dest;\n \t}\n+    uselocale((locale_t)__old);\n     return __hi;\n   }\n \n   void\n   ctype<wchar_t>::_M_initialize_ctype() throw()\n   {\n+    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_ctype);\n     wint_t __i;\n     for (__i = 0; __i < 128; ++__i)\n       {\n@@ -165,9 +213,18 @@ namespace std _GLIBCXX_VISIBILITY(default)\n       _M_narrow_ok = true;\n     else\n       _M_narrow_ok = false;\n-    for (size_t __i = 0;\n-\t __i < sizeof(_M_widen) / sizeof(wint_t); ++__i)\n-      _M_widen[__i] = btowc(__i);\n+    for (size_t __j = 0;\n+\t __j < sizeof(_M_widen) / sizeof(wint_t); ++__j)\n+      _M_widen[__j] = btowc(__j);\n+\n+    for (size_t __k = 0; __k <= 11; ++__k)\n+      {\n+\t_M_bit[__k] = static_cast<mask>(_ISbit(__k));\n+\t_M_wmask[__k] = _M_convert_to_wmask(_M_bit[__k]);\n+      }\n+    uselocale((locale_t)__old);\n   }\n #endif //  _GLIBCXX_USE_WCHAR_T\n-}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "5c07c7335b7925519efa8551f7e86eeefa5afc6b", "filename": "libstdc++-v3/config/locale/dragonfly/monetary_members.cc", "status": "added", "additions": 903, "deletions": 0, "changes": 903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fmonetary_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fmonetary_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fmonetary_members.cc?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -0,0 +1,903 @@\n+// std::moneypunct implementation details, DragonFly version -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+//\n+// ISO C++ 14882: 22.2.6.3.2  moneypunct virtual functions\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n+\n+#include <locale>\n+#include <cstring>\n+#include <xlocale.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+// This file might be compiled twice, but we only want to define the members\n+// of money_base once.\n+#if ! _GLIBCXX_USE_CXX11_ABI\n+\n+  // Construct and return valid pattern consisting of some combination of:\n+  // space none symbol sign value\n+  money_base::pattern\n+  money_base::_S_construct_pattern(char __precedes, char __space, \n+\t\t\t\t   char __posn) throw()\n+  { \n+    pattern __ret;\n+\n+    // This insanely complicated routine attempts to construct a valid\n+    // pattern for use with moneypunct. A couple of invariants:\n+\n+    // if (__precedes) symbol -> value\n+    // else value -> symbol\n+    \n+    // if (__space) space\n+    // else none\n+\n+    // none == never first\n+    // space never first or last\n+\n+    // Any elegant implementations of this are welcome.\n+    switch (__posn)\n+      {\n+      case 0:\n+      case 1:\n+\t// 1 The sign precedes the value and symbol.\n+\t__ret.field[0] = sign;\n+\tif (__space)\n+\t  {\n+\t    // Pattern starts with sign.\n+\t    if (__precedes)\n+\t      {\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[1] = value;\n+\t\t__ret.field[3] = symbol;\n+\t      }\n+\t    __ret.field[2] = space;\n+\t  }\n+\telse\n+\t  {\n+\t    // Pattern starts with sign and ends with none.\n+\t    if (__precedes)\n+\t      {\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[1] = value;\n+\t\t__ret.field[2] = symbol;\n+\t      }\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      case 2:\n+\t// 2 The sign follows the value and symbol.\n+\tif (__space)\n+\t  {\n+\t    // Pattern either ends with sign.\n+\t    if (__precedes)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[2] = symbol;\n+\t      }\n+\t    __ret.field[1] = space;\n+\t    __ret.field[3] = sign;\n+\t  }\n+\telse\n+\t  {\n+\t    // Pattern ends with sign then none.\n+\t    if (__precedes)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = symbol;\n+\t      }\n+\t    __ret.field[2] = sign;\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      case 3:\n+\t// 3 The sign immediately precedes the symbol.\n+\tif (__precedes)\n+\t  {\n+\t    __ret.field[0] = sign;\n+\t    __ret.field[1] = symbol;\t    \n+\t    if (__space)\n+\t      {\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[2] = value;\t\t\n+\t\t__ret.field[3] = none;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    __ret.field[0] = value;\n+\t    if (__space)\n+\t      {\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = sign;\n+\t\t__ret.field[3] = symbol;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[1] = sign;\n+\t\t__ret.field[2] = symbol;\n+\t\t__ret.field[3] = none;\n+\t      }\n+\t  }\n+\tbreak;\n+      case 4:\n+\t// 4 The sign immediately follows the symbol.\n+\tif (__precedes)\n+\t  {\n+\t    __ret.field[0] = symbol;\n+\t    __ret.field[1] = sign;\n+\t    if (__space)\n+\t      {\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[2] = value;\n+\t\t__ret.field[3] = none;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    __ret.field[0] = value;\n+\t    if (__space)\n+\t      {\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = symbol;\n+\t\t__ret.field[3] = sign;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = sign;\n+\t\t__ret.field[3] = none;\n+\t      }\n+\t  }\n+\tbreak;\n+      default:\n+\t__ret = pattern();\n+      }\n+    return __ret;\n+  }\n+#endif\n+\n+  template<>\n+    void\n+    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale __cloc, \n+\t\t\t\t\t\t     const char*)\n+    {\n+      if (!_M_data)\n+\t_M_data = new __moneypunct_cache<char, true>;\n+\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_data->_M_decimal_point = '.';\n+\t  _M_data->_M_thousands_sep = ',';\n+\t  _M_data->_M_grouping = \"\";\n+\t  _M_data->_M_grouping_size = 0;\n+\t  _M_data->_M_use_grouping = false;\n+\t  _M_data->_M_curr_symbol = \"\";\n+\t  _M_data->_M_curr_symbol_size = 0;\n+\t  _M_data->_M_positive_sign = \"\";\n+\t  _M_data->_M_positive_sign_size = 0;\n+\t  _M_data->_M_negative_sign = \"\";\n+\t  _M_data->_M_negative_sign_size = 0;\n+\t  _M_data->_M_frac_digits = 0;\n+\t  _M_data->_M_pos_format = money_base::_S_default_pattern;\n+\t  _M_data->_M_neg_format = money_base::_S_default_pattern;\n+\n+\t  for (size_t __i = 0; __i < money_base::_S_end; ++__i)\n+\t    _M_data->_M_atoms[__i] = money_base::_S_atoms[__i];\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  lconv* lc = localeconv_l((locale_t) __cloc);\n+\n+\t  // Check for NULL, which implies no fractional digits.\n+\t  if (lc->mon_decimal_point == NULL ||\n+\t      lc->mon_decimal_point[0] == '\\0')\n+\t    {\n+\t      // Like in \"C\" locale.\n+\t      _M_data->_M_frac_digits = 0;\n+\t      _M_data->_M_decimal_point = '.';\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_data->_M_decimal_point = lc->mon_decimal_point[0];\n+\t      _M_data->_M_frac_digits = lc->int_frac_digits;\n+\t    }\n+\n+\t  const char* __cgroup = lc->mon_grouping;\n+\t  const char* __cpossign = lc->positive_sign;\n+\t  const char* __cnegsign = lc->negative_sign;\n+\t  // _Intl == true\n+\t  const char* __ccurr = lc->int_curr_symbol;\n+\n+\t  char* __group = 0;\n+\t  char* __ps = 0;\n+\t  char* __ns = 0;\n+\t  const char __nposn = lc->int_n_sign_posn;\n+\t  __try\n+\t    {\n+\t      size_t __len;\n+\t      \n+\t      // Check for NULL, which implies no grouping.\n+\t      if (lc->mon_thousands_sep == NULL ||\n+\t          lc->mon_thousands_sep[0] == '\\0')\n+\t\t{\n+\t\t  // Like in \"C\" locale.\n+\t\t  _M_data->_M_grouping = \"\";\n+\t\t  _M_data->_M_grouping_size = 0;\n+\t\t  _M_data->_M_use_grouping = false;\n+\t\t  _M_data->_M_thousands_sep = ',';\n+\t\t}\n+\t      else\n+\t\t{\n+\t          _M_data->_M_thousands_sep = lc->mon_thousands_sep[0];\n+\n+\t\t  __len = strlen(__cgroup);\n+\t\t  if (__len)\n+\t\t    {\n+\t\t      __group = new char[__len + 1];\n+\t\t      memcpy(__group, __cgroup, __len + 1);\n+\t\t      _M_data->_M_grouping = __group;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      _M_data->_M_grouping = \"\";\n+\t\t      _M_data->_M_use_grouping = false;\n+\t\t    }\n+\t\t  _M_data->_M_grouping_size = __len;\n+\t\t}\n+\n+\t      __len = strlen(__cpossign);\n+\t      if (__len)\n+\t\t{\n+\t\t  __ps = new char[__len + 1];\n+\t\t  memcpy(__ps, __cpossign, __len + 1);\n+\t\t  _M_data->_M_positive_sign = __ps;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_positive_sign = \"\";\n+\t      _M_data->_M_positive_sign_size = __len;\n+\n+\t      if (!__nposn)\n+\t\t{\n+\t\t  _M_data->_M_negative_sign = \"()\";\n+\t\t  _M_data->_M_negative_sign_size = 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __len = strlen(__cnegsign);\n+\t\t  if (__len)\n+\t\t    {\n+\t\t      __ns = new char[__len + 1];\n+\t\t      memcpy(__ns, __cnegsign, __len + 1);\n+\t\t      _M_data->_M_negative_sign = __ns;\n+\t\t    }\n+\t\t  else\n+\t\t    _M_data->_M_negative_sign = \"\";\n+\t\t  _M_data->_M_negative_sign_size = __len;\n+\t\t}\n+\n+\t      __len = strlen(__ccurr);\n+\t      if (__len)\n+\t\t{\n+\t\t  char* __curr = new char[__len + 1];\n+\t\t  memcpy(__curr, __ccurr, __len + 1);\n+\t\t  _M_data->_M_curr_symbol = __curr;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_curr_symbol = \"\";\n+\t      _M_data->_M_curr_symbol_size = __len;\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      delete _M_data;\n+\t      _M_data = 0;\n+\t      delete [] __group;\n+\t      delete [] __ps;\n+\t      delete [] __ns;\n+\t      __throw_exception_again;\n+\t    }\n+\n+\t  char __pprecedes = lc->int_p_cs_precedes;\n+\t  char __pspace = lc->int_p_sep_by_space;\n+\t  char __pposn = lc->int_p_sign_posn;\n+\t  _M_data->_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,\n+\t\t\t\t\t\t\t__pposn);\n+\t  char __nprecedes = lc->int_n_cs_precedes;\n+\t  char __nspace = lc->int_n_sep_by_space;\n+\t  _M_data->_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,\n+\t\t\t\t\t\t\t__nposn);\n+\t}\n+    }\n+\n+  template<>\n+    void\n+    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale __cloc, \n+\t\t\t\t\t\t      const char*)\n+    {\n+      if (!_M_data)\n+\t_M_data = new __moneypunct_cache<char, false>;\n+\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_data->_M_decimal_point = '.';\n+\t  _M_data->_M_thousands_sep = ',';\n+\t  _M_data->_M_grouping = \"\";\n+\t  _M_data->_M_grouping_size = 0;\n+\t  _M_data->_M_use_grouping = false;\n+\t  _M_data->_M_curr_symbol = \"\";\n+\t  _M_data->_M_curr_symbol_size = 0;\n+\t  _M_data->_M_positive_sign = \"\";\n+\t  _M_data->_M_positive_sign_size = 0;\n+\t  _M_data->_M_negative_sign = \"\";\n+\t  _M_data->_M_negative_sign_size = 0;\n+\t  _M_data->_M_frac_digits = 0;\n+\t  _M_data->_M_pos_format = money_base::_S_default_pattern;\n+\t  _M_data->_M_neg_format = money_base::_S_default_pattern;\n+\n+\t  for (size_t __i = 0; __i < money_base::_S_end; ++__i)\n+\t    _M_data->_M_atoms[__i] = money_base::_S_atoms[__i];\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  lconv* lc = localeconv_l((locale_t) __cloc);\n+\n+\t  // Check for NULL, which implies no fractional digits.\n+\t  if (lc->mon_decimal_point == NULL ||\n+\t      lc->mon_decimal_point[0] == '\\0')\n+\t    {\n+\t      // Like in \"C\" locale.\n+\t      _M_data->_M_frac_digits = 0;\n+\t      _M_data->_M_decimal_point = '.';\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_data->_M_decimal_point = lc->mon_decimal_point[0];\n+\t      _M_data->_M_frac_digits = lc->frac_digits;\n+            }\n+\n+\t  const char* __cgroup = lc->mon_grouping;\n+\t  const char* __cpossign = lc->positive_sign;\n+\t  const char* __cnegsign = lc->negative_sign;\n+\t  // _Intl == false\n+\t  const char* __ccurr = lc->currency_symbol;\n+\n+\t  char* __group = 0;\n+\t  char* __ps = 0;\n+\t  char* __ns = 0;\n+\t  const char __nposn = lc->n_sign_posn;\n+\t  __try\n+\t    {\n+\t      size_t __len;\n+\n+\t      // Check for NULL, which implies no grouping.\n+\t      if (lc->mon_thousands_sep == NULL ||\n+\t          lc->mon_thousands_sep[0] == '\\0')\n+\t\t{\n+\t\t  // Like in \"C\" locale.\n+\t\t  _M_data->_M_grouping = \"\";\n+\t\t  _M_data->_M_grouping_size = 0;\n+\t\t  _M_data->_M_use_grouping = false;\n+\t\t  _M_data->_M_thousands_sep = ',';\n+\t\t}\n+\t      else\n+\t\t{\n+\t          _M_data->_M_thousands_sep = lc->mon_thousands_sep[0];\n+\n+\t\t  __len = strlen(__cgroup);\n+\t\t  if (__len)\n+\t\t    {\n+\t\t      __group = new char[__len + 1];\n+\t\t      memcpy(__group, __cgroup, __len + 1);\n+\t\t      _M_data->_M_grouping = __group;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      _M_data->_M_grouping = \"\";\n+\t\t      _M_data->_M_use_grouping = false;\n+\t\t    }\n+\t\t  _M_data->_M_grouping_size = __len;\n+\t\t}\n+\n+\t      __len = strlen(__cpossign);\n+\t      if (__len)\n+\t\t{\n+\t\t  __ps = new char[__len + 1];\n+\t\t  memcpy(__ps, __cpossign, __len + 1);\n+\t\t  _M_data->_M_positive_sign = __ps;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_positive_sign = \"\";\n+\t      _M_data->_M_positive_sign_size = __len;\n+\n+\t      if (!__nposn)\n+\t\t{\n+\t\t  _M_data->_M_negative_sign = \"()\";\n+\t\t  _M_data->_M_negative_sign_size = 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __len = strlen(__cnegsign);\n+\t\t  if (__len)\n+\t\t    {\n+\t\t      __ns = new char[__len + 1];\n+\t\t      memcpy(__ns, __cnegsign, __len + 1);\n+\t\t      _M_data->_M_negative_sign = __ns;\n+\t\t    }\n+\t\t  else\n+\t\t    _M_data->_M_negative_sign = \"\";\n+\t\t  _M_data->_M_negative_sign_size = __len;\n+\t\t}\n+\n+\t      __len = strlen(__ccurr);\n+\t      if (__len)\n+\t\t{\n+\t\t  char* __curr = new char[__len + 1];\n+\t\t  memcpy(__curr, __ccurr, __len + 1);\n+\t\t  _M_data->_M_curr_symbol = __curr;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_curr_symbol = \"\";\n+\t      _M_data->_M_curr_symbol_size = __len;\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      delete _M_data;\n+\t      _M_data = 0;\n+\t      delete [] __group;\n+\t      delete [] __ps;\n+\t      delete [] __ns;\n+\t      __throw_exception_again;\n+\t    }\n+\n+\t  char __pprecedes = lc->p_cs_precedes;\n+\t  char __pspace = lc->p_sep_by_space;\n+\t  char __pposn = lc->p_sign_posn;\n+\t  _M_data->_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,\n+\t\t\t\t\t\t\t__pposn);\n+\t  char __nprecedes = lc->n_cs_precedes;\n+\t  char __nspace = lc->n_sep_by_space;\n+\t  _M_data->_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,\n+\t\t\t\t\t\t\t__nposn);\n+\t}\n+    }\n+\n+  template<>\n+    moneypunct<char, true>::~moneypunct()\n+    {\n+      if (_M_data->_M_grouping_size)\n+\tdelete [] _M_data->_M_grouping;\n+      if (_M_data->_M_positive_sign_size)\n+\tdelete [] _M_data->_M_positive_sign;\n+      if (_M_data->_M_negative_sign_size\n+          && strcmp(_M_data->_M_negative_sign, \"()\") != 0)\n+\tdelete [] _M_data->_M_negative_sign;\n+      if (_M_data->_M_curr_symbol_size)\n+\tdelete [] _M_data->_M_curr_symbol;\n+      delete _M_data;\n+    }\n+\n+  template<>\n+    moneypunct<char, false>::~moneypunct()\n+    {\n+      if (_M_data->_M_grouping_size)\n+\tdelete [] _M_data->_M_grouping;\n+      if (_M_data->_M_positive_sign_size)\n+\tdelete [] _M_data->_M_positive_sign;\n+      if (_M_data->_M_negative_sign_size\n+          && strcmp(_M_data->_M_negative_sign, \"()\") != 0)\n+\tdelete [] _M_data->_M_negative_sign;\n+      if (_M_data->_M_curr_symbol_size)\n+\tdelete [] _M_data->_M_curr_symbol;\n+      delete _M_data;\n+    }\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    void\n+    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale __cloc, \n+\t\t\t\t\t\t\tconst char*)\n+    {\n+      if (!_M_data)\n+\t_M_data = new __moneypunct_cache<wchar_t, true>;\n+\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_data->_M_decimal_point = L'.';\n+\t  _M_data->_M_thousands_sep = L',';\n+\t  _M_data->_M_grouping = \"\";\n+\t  _M_data->_M_grouping_size = 0;\n+\t  _M_data->_M_use_grouping = false;\n+\t  _M_data->_M_curr_symbol = L\"\";\n+\t  _M_data->_M_curr_symbol_size = 0;\n+\t  _M_data->_M_positive_sign = L\"\";\n+\t  _M_data->_M_positive_sign_size = 0;\n+\t  _M_data->_M_negative_sign = L\"\";\n+\t  _M_data->_M_negative_sign_size = 0;\n+\t  _M_data->_M_frac_digits = 0;\n+\t  _M_data->_M_pos_format = money_base::_S_default_pattern;\n+\t  _M_data->_M_neg_format = money_base::_S_default_pattern;\n+\n+\t  // Use ctype::widen code without the facet...\n+\t  for (size_t __i = 0; __i < money_base::_S_end; ++__i)\n+\t    _M_data->_M_atoms[__i] =\n+\t      static_cast<wchar_t>(money_base::_S_atoms[__i]);\n+\t}\n+      else\n+\t{\n+\t  __c_locale __old = (__c_locale)uselocale((locale_t)__cloc);\n+\t  // Named locale.\n+\t  lconv* lc = localeconv_l((locale_t) __cloc);\n+\n+\t  // Check for NULL, which implies no fractional digits.\n+\t  if (lc->mon_decimal_point == NULL ||\n+\t      lc->mon_decimal_point[0] == '\\0')\n+\t    {\n+\t      // Like in \"C\" locale.\n+\t      _M_data->_M_frac_digits = 0;\n+\t      _M_data->_M_decimal_point = L'.';\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_data->_M_frac_digits = lc->int_frac_digits;\n+\t      _M_data->_M_decimal_point = (wchar_t)lc->mon_decimal_point[0];\n+            }\n+\n+\t  const char* __cgroup = lc->mon_grouping;\n+\t  const char* __cpossign = lc->positive_sign;\n+\t  const char* __cnegsign = lc->negative_sign;\n+\t  const char* __ccurr = lc->int_curr_symbol;\n+\n+\t  char* __group = 0;\n+\t  wchar_t* __wcs_ps = 0;\n+\t  wchar_t* __wcs_ns = 0;\n+\t  const char __nposn = lc->int_n_sign_posn;\n+\t  __try\n+\t    {\n+\t      size_t __len;\n+\n+\t      // Check for NULL, which implies no grouping.\n+\t      if (lc->mon_thousands_sep == NULL ||\n+\t          lc->mon_thousands_sep[0] == '\\0')\n+\t\t{\n+\t\t  // Like in \"C\" locale.\n+\t\t  _M_data->_M_grouping = \"\";\n+\t\t  _M_data->_M_grouping_size = 0;\n+\t\t  _M_data->_M_use_grouping = false;\n+\t\t  _M_data->_M_thousands_sep = L',';\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  _M_data->_M_thousands_sep =\n+\t\t\t(wchar_t)lc->mon_thousands_sep[0];\n+\t\t  __len = strlen(__cgroup);\n+\t\t  if (__len)\n+\t\t    {\n+\t\t      __group = new char[__len + 1];\n+\t\t      memcpy(__group, __cgroup, __len + 1);\n+\t\t      _M_data->_M_grouping = __group;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      _M_data->_M_grouping = \"\";\n+\t\t      _M_data->_M_use_grouping = false;\n+\t\t    }\n+\t\t  _M_data->_M_grouping_size = __len;\n+\t\t}\n+\n+\t      mbstate_t __state;\n+\t      __len = strlen(__cpossign);\n+\t      if (__len)\n+\t\t{\n+\t\t  memset(&__state, 0, sizeof(mbstate_t));\n+\t\t  __wcs_ps = new wchar_t[__len + 1];\n+\t\t  mbsrtowcs(__wcs_ps, &__cpossign, __len + 1, &__state);\n+\t\t  _M_data->_M_positive_sign = __wcs_ps;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_positive_sign = L\"\";\n+\t      _M_data->_M_positive_sign_size = \n+\t\twcslen(_M_data->_M_positive_sign);\n+\t      \n+\t      __len = strlen(__cnegsign);\n+\t      if (!__nposn)\n+\t\t_M_data->_M_negative_sign = L\"()\";\n+\t      else if (__len)\n+\t\t{\n+\t\t  memset(&__state, 0, sizeof(mbstate_t));\n+\t\t  __wcs_ns = new wchar_t[__len + 1];\n+\t\t  mbsrtowcs(__wcs_ns, &__cnegsign, __len + 1, &__state);\n+\t\t  _M_data->_M_negative_sign = __wcs_ns;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_negative_sign = L\"\";\n+\t      _M_data->_M_negative_sign_size = \n+\t\twcslen(_M_data->_M_negative_sign);\n+\t      \n+\t      // _Intl == true.\n+\t      __len = strlen(__ccurr);\n+\t      if (__len)\n+\t\t{\n+\t\t  memset(&__state, 0, sizeof(mbstate_t));\n+\t\t  wchar_t* __wcs = new wchar_t[__len + 1];\n+\t\t  mbsrtowcs(__wcs, &__ccurr, __len + 1, &__state);\n+\t\t  _M_data->_M_curr_symbol = __wcs;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_curr_symbol = L\"\";\n+\t      _M_data->_M_curr_symbol_size = wcslen(_M_data->_M_curr_symbol);\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      delete _M_data;\n+\t      _M_data = 0;\n+\t      delete [] __group;\n+\t      delete [] __wcs_ps;\n+\t      delete [] __wcs_ns;\t      \n+\t      uselocale((locale_t)__old);\n+\t      __throw_exception_again;\n+\t    } \n+\t  \n+\t  char __pprecedes = lc->int_p_cs_precedes;\n+\t  char __pspace = lc->int_p_sep_by_space;\n+\t  char __pposn = lc->int_p_sign_posn;\n+\t  _M_data->_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,\n+\t\t\t\t\t\t\t__pposn);\n+\t  char __nprecedes = lc->int_n_cs_precedes;\n+\t  char __nspace = lc->int_n_sep_by_space;\n+\t  _M_data->_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,\n+\t\t\t\t\t\t\t__nposn);\n+\n+\t  uselocale((locale_t)__old);\n+\t}\n+    }\n+\n+  template<>\n+  void\n+  moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale __cloc,\n+\t\t\t\t\t\t       const char*)\n+  {\n+    if (!_M_data)\n+      _M_data = new __moneypunct_cache<wchar_t, false>;\n+\n+    if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_data->_M_decimal_point = L'.';\n+\t  _M_data->_M_thousands_sep = L',';\n+\t  _M_data->_M_grouping = \"\";\n+          _M_data->_M_grouping_size = 0;\n+\t  _M_data->_M_use_grouping = false;\n+\t  _M_data->_M_curr_symbol = L\"\";\n+\t  _M_data->_M_curr_symbol_size = 0;\n+\t  _M_data->_M_positive_sign = L\"\";\n+\t  _M_data->_M_positive_sign_size = 0;\n+\t  _M_data->_M_negative_sign = L\"\";\n+\t  _M_data->_M_negative_sign_size = 0;\n+\t  _M_data->_M_frac_digits = 0;\n+\t  _M_data->_M_pos_format = money_base::_S_default_pattern;\n+\t  _M_data->_M_neg_format = money_base::_S_default_pattern;\n+\n+\t  // Use ctype::widen code without the facet...\n+\t  for (size_t __i = 0; __i < money_base::_S_end; ++__i)\n+\t    _M_data->_M_atoms[__i] =\n+\t      static_cast<wchar_t>(money_base::_S_atoms[__i]);\n+\t}\n+      else\n+\t{\n+\t  __c_locale __old = (__c_locale)uselocale((locale_t)__cloc);\n+\t  // Named locale.\n+\t  lconv* lc = localeconv_l((locale_t) __cloc);\n+\n+\t  // Check for NULL, which implies no fractional digits.\n+\t  if (lc->mon_decimal_point == NULL ||\n+\t      lc->mon_decimal_point[0] == '\\0')\n+\t    {\n+\t      // Like in \"C\" locale.\n+\t      _M_data->_M_frac_digits = 0;\n+\t      _M_data->_M_decimal_point = L'.';\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_data->_M_frac_digits = lc->frac_digits;\n+\t      _M_data->_M_decimal_point = (wchar_t)lc->mon_decimal_point[0];\n+            }\n+\n+\t  const char* __cgroup = lc->mon_grouping;\n+\t  const char* __cpossign = lc->positive_sign;\n+\t  const char* __cnegsign = lc->negative_sign;\n+\t  const char* __ccurr = lc->currency_symbol;\n+\n+\t  char* __group = 0;\n+\t  wchar_t* __wcs_ps = 0;\n+\t  wchar_t* __wcs_ns = 0;\n+\t  const char __nposn = lc->n_sign_posn;\n+\t  __try\n+            {\n+\t      size_t __len;\n+\n+\t      // Check for NULL, which implies no grouping.\n+\t      if (lc->mon_thousands_sep == NULL ||\n+\t          lc->mon_thousands_sep[0] == '\\0')\n+\t\t{\n+\t\t  // Like in \"C\" locale.\n+\t\t  _M_data->_M_grouping = \"\";\n+\t\t  _M_data->_M_grouping_size = 0;\n+\t\t  _M_data->_M_use_grouping = false;\n+\t\t  _M_data->_M_thousands_sep = L',';\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  _M_data->_M_thousands_sep =\n+\t\t\t(wchar_t)lc->mon_thousands_sep[0];\n+\t\t  __len = strlen(__cgroup);\n+\t\t  if (__len)\n+\t\t    {\n+\t\t      __group = new char[__len + 1];\n+\t\t      memcpy(__group, __cgroup, __len + 1);\n+\t\t      _M_data->_M_grouping = __group;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      _M_data->_M_grouping = \"\";\n+\t\t      _M_data->_M_use_grouping = false;\n+\t\t    }\n+\t\t  _M_data->_M_grouping_size = __len;\n+\t\t}\n+\n+              mbstate_t __state;\n+              __len = strlen(__cpossign);\n+              if (__len)\n+                {\n+\t\t  memset(&__state, 0, sizeof(mbstate_t));\n+\t\t  __wcs_ps = new wchar_t[__len + 1];\n+\t\t  mbsrtowcs(__wcs_ps, &__cpossign, __len + 1, &__state);\n+\t\t  _M_data->_M_positive_sign = __wcs_ps;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_positive_sign = L\"\";\n+              _M_data->_M_positive_sign_size = \n+\t\twcslen(_M_data->_M_positive_sign);\n+\n+\t      __len = strlen(__cnegsign);\n+\t      if (!__nposn)\n+\t\t_M_data->_M_negative_sign = L\"()\";\n+\t      else if (__len)\n+\t\t{\n+\t\t  memset(&__state, 0, sizeof(mbstate_t));\n+\t\t  __wcs_ns = new wchar_t[__len + 1];\n+\t\t  mbsrtowcs(__wcs_ns, &__cnegsign, __len + 1, &__state);\n+\t\t  _M_data->_M_negative_sign = __wcs_ns;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_negative_sign = L\"\";\n+              _M_data->_M_negative_sign_size = \n+\t\twcslen(_M_data->_M_negative_sign);\n+\n+\t      // _Intl == true.\n+\t      __len = strlen(__ccurr);\n+\t      if (__len)\n+\t\t{\n+\t\t  memset(&__state, 0, sizeof(mbstate_t));\n+\t\t  wchar_t* __wcs = new wchar_t[__len + 1];\n+\t\t  mbsrtowcs(__wcs, &__ccurr, __len + 1, &__state);\n+\t\t  _M_data->_M_curr_symbol = __wcs;\n+\t\t}\n+\t      else\n+\t\t_M_data->_M_curr_symbol = L\"\";\n+              _M_data->_M_curr_symbol_size = wcslen(_M_data->_M_curr_symbol);\n+\t    }\n+          __catch(...)\n+\t    {\n+\t      delete _M_data;\n+              _M_data = 0;\n+\t      delete [] __group;\n+\t      delete [] __wcs_ps;\n+\t      delete [] __wcs_ns;\t      \n+\t      uselocale((locale_t)__old);\n+              __throw_exception_again;\n+\t    }\n+\n+\t  char __pprecedes = lc->p_cs_precedes;\n+\t  char __pspace = lc->p_sep_by_space;\n+\t  char __pposn = lc->p_sign_posn;\n+\t  _M_data->_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,\n+\t                                                __pposn);\n+\t  char __nprecedes = lc->n_cs_precedes;\n+\t  char __nspace = lc->n_sep_by_space;\n+\t  _M_data->_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,\n+\t                                                __nposn);\n+\n+\t  uselocale((locale_t)__old);\n+\t}\n+    }\n+\n+  template<>\n+    moneypunct<wchar_t, true>::~moneypunct()\n+    {\n+      if (_M_data->_M_grouping_size)\n+\tdelete [] _M_data->_M_grouping;\n+      if (_M_data->_M_positive_sign_size)\n+\tdelete [] _M_data->_M_positive_sign;\n+      if (_M_data->_M_negative_sign_size\n+          && wcscmp(_M_data->_M_negative_sign, L\"()\") != 0)\n+\tdelete [] _M_data->_M_negative_sign;\n+      if (_M_data->_M_curr_symbol_size)\n+\tdelete [] _M_data->_M_curr_symbol;\n+      delete _M_data;\n+    }\n+\n+  template<>\n+    moneypunct<wchar_t, false>::~moneypunct()\n+    {\n+      if (_M_data->_M_grouping_size)\n+\tdelete [] _M_data->_M_grouping;\n+      if (_M_data->_M_positive_sign_size)\n+\tdelete [] _M_data->_M_positive_sign;\n+      if (_M_data->_M_negative_sign_size\n+          && wcscmp(_M_data->_M_negative_sign, L\"()\") != 0)\n+\tdelete [] _M_data->_M_negative_sign;\n+      if (_M_data->_M_curr_symbol_size)\n+\tdelete [] _M_data->_M_curr_symbol;\n+      delete _M_data;\n+    }\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "ba44045cd707656d6bfddff675083eb603fae47f", "filename": "libstdc++-v3/config/locale/dragonfly/numeric_members.cc", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fnumeric_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fnumeric_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Fnumeric_members.cc?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -0,0 +1,235 @@\n+// std::numpunct implementation details, DragonFly version -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+//\n+// ISO C++ 14882: 22.2.3.1.2  numpunct virtual functions\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n+\n+#include <locale>\n+#include <cstring>\n+#include <xlocale.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<> \n+    void\n+    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc)\n+    {\n+      if (!_M_data)\n+\t_M_data = new __numpunct_cache<char>;\n+\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_data->_M_grouping = \"\";\n+\t  _M_data->_M_grouping_size = 0;\n+\t  _M_data->_M_use_grouping = false;\n+\n+\t  _M_data->_M_decimal_point = '.';\n+\t  _M_data->_M_thousands_sep = ',';\n+\n+\t  for (size_t __i = 0; __i < __num_base::_S_oend; ++__i)\n+\t    _M_data->_M_atoms_out[__i] = __num_base::_S_atoms_out[__i];\n+\n+\t  for (size_t __j = 0; __j < __num_base::_S_iend; ++__j)\n+\t    _M_data->_M_atoms_in[__j] = __num_base::_S_atoms_in[__j];\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  lconv* lc = localeconv_l((locale_t) __cloc);\n+\n+\t  // Decimal point should always be defined, but check null anyway\n+\t  if (lc->decimal_point == NULL)\n+\t    {\n+\t      // Not defined, so use \"C\" locale default\n+\t      _M_data->_M_decimal_point = '.';\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_data->_M_decimal_point = lc->decimal_point[0];\n+\t    }\n+\t  // Check for NULL, which implies no grouping.\n+\t  if (lc->thousands_sep == NULL || lc->thousands_sep[0] == '\\0')\n+\t    {\n+\t      // Like in \"C\" locale.\n+\t      _M_data->_M_grouping = \"\";\n+\t      _M_data->_M_grouping_size = 0;\n+\t      _M_data->_M_use_grouping = false;\n+\t      _M_data->_M_thousands_sep = ',';\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_data->_M_thousands_sep = lc->thousands_sep[0];\n+\n+\t      const char* __src = lc->grouping;\n+\t      const size_t __len = strlen(__src);\n+\t      if (__len)\n+\t\t{\n+\t\t  __try\n+\t\t    {\n+\t\t      char* __dst = new char[__len + 1];\n+\t\t      memcpy(__dst, __src, __len + 1);\n+\t\t      _M_data->_M_grouping = __dst;\n+\t\t      _M_data->_M_use_grouping = true;\n+\t\t    }\n+\t\t  __catch(...)\n+\t\t    {\n+\t\t      delete _M_data;\n+\t\t      _M_data = 0;\n+\t\t      __throw_exception_again;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  _M_data->_M_grouping = \"\";\n+\t\t  _M_data->_M_use_grouping = false;\n+\t\t}\n+\t      _M_data->_M_grouping_size = __len;\n+\t    }\n+\t}\n+\n+      // NB: There is no way to extact this info from posix locales.\n+      // _M_truename = __nl_langinfo_l(YESSTR, __cloc);\n+      _M_data->_M_truename = \"true\";\n+      _M_data->_M_truename_size = 4;\n+      // _M_falsename = __nl_langinfo_l(NOSTR, __cloc);\n+      _M_data->_M_falsename = \"false\";\n+      _M_data->_M_falsename_size = 5;\n+    }\n+ \n+  template<> \n+    numpunct<char>::~numpunct()\n+    {\n+      if (_M_data->_M_grouping_size)\n+\tdelete [] _M_data->_M_grouping;\n+      delete _M_data;\n+    }\n+   \n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<> \n+    void\n+    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc)\n+    {\n+      if (!_M_data)\n+\t_M_data = new __numpunct_cache<wchar_t>;\n+\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_data->_M_grouping = \"\";\n+\t  _M_data->_M_grouping_size = 0;\n+\t  _M_data->_M_use_grouping = false;\n+\n+\t  _M_data->_M_decimal_point = L'.';\n+\t  _M_data->_M_thousands_sep = L',';\n+\n+\t  // Use ctype::widen code without the facet...\n+\t  for (size_t __i = 0; __i < __num_base::_S_oend; ++__i)\n+\t    _M_data->_M_atoms_out[__i] =\n+\t      static_cast<wchar_t>(__num_base::_S_atoms_out[__i]);\n+\n+\t  for (size_t __j = 0; __j < __num_base::_S_iend; ++__j)\n+\t    _M_data->_M_atoms_in[__j] =\n+\t      static_cast<wchar_t>(__num_base::_S_atoms_in[__j]);\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  lconv* lc = localeconv_l((locale_t) __cloc);\n+\n+\t  // Decimal point should always be defined, but check null anyway\n+\t  if (lc->decimal_point == NULL)\n+\t    {\n+\t      // Not defined, so use \"C\" locale default\n+\t      _M_data->_M_decimal_point = L'.';\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_data->_M_decimal_point = (wchar_t)lc->decimal_point[0];\n+\t    }\n+\t  // Check for NULL, which implies no grouping.\n+\t  if (lc->thousands_sep == NULL || lc->thousands_sep[0] == '\\0')\n+\t    {\n+\t      // Like in \"C\" locale.\n+\t      _M_data->_M_grouping = \"\";\n+\t      _M_data->_M_grouping_size = 0;\n+\t      _M_data->_M_use_grouping = false;\n+\t      _M_data->_M_thousands_sep = L',';\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_data->_M_thousands_sep = (wchar_t)lc->thousands_sep[0];\n+\n+  \t      const char* __src = lc->grouping;\n+\t      const size_t __len = strlen(__src);\n+\t      if (__len)\n+\t\t{\n+\t\t  __try\n+\t\t    {\n+\t\t      char* __dst = new char[__len + 1];\n+\t\t      memcpy(__dst, __src, __len + 1);\n+\t\t      _M_data->_M_grouping = __dst;\n+\t\t    }\n+\t\t  __catch(...)\n+\t\t    {\n+\t\t      delete _M_data;\n+\t\t      _M_data = 0;\n+\t\t      __throw_exception_again;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  _M_data->_M_grouping = \"\";\n+\t\t  _M_data->_M_use_grouping = false;\n+\t\t}\n+\t      _M_data->_M_grouping_size = __len;\n+\t    }\n+\t}\n+\n+      // NB: There is no way to extact this info from posix locales.\n+      // _M_truename = __nl_langinfo_l(YESSTR, __cloc);\n+      _M_data->_M_truename = L\"true\";\n+      _M_data->_M_truename_size = 4;\n+      // _M_falsename = __nl_langinfo_l(NOSTR, __cloc);\n+      _M_data->_M_falsename = L\"false\";\n+      _M_data->_M_falsename_size = 5;\n+    }\n+\n+  template<> \n+    numpunct<wchar_t>::~numpunct()\n+    {\n+      if (_M_data->_M_grouping_size)\n+\tdelete [] _M_data->_M_grouping;\n+      delete _M_data;\n+    }\n+ #endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "1812e50b5be53689949d9992be968c0c76b61070", "filename": "libstdc++-v3/config/locale/dragonfly/time_members.cc", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Ftime_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Ftime_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Ftime_members.cc?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -0,0 +1,404 @@\n+// std::time_get, std::time_put implementation, DragonFly version -*- C++ -*-\n+\n+// Copyright (C) 2001-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+//\n+// ISO C++ 14882: 22.2.5.1.2 - time_get virtual functions\n+// ISO C++ 14882: 22.2.5.3.2 - time_put virtual functions\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n+\n+#include <locale>\n+#include <ctime>\n+#include <cwchar>\n+#include <stdlib.h>\n+#include <langinfo.h>\n+#include <xlocale.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<>\n+    void\n+    __timepunct<char>::\n+    _M_put(char* __s, size_t __maxlen, const char* __format, \n+\t   const tm* __tm) const throw()\n+    {\n+      const size_t __len = strftime_l(__s, __maxlen, __format, __tm,\n+\t\t\t\t      (locale_t)_M_c_locale_timepunct);\n+      // Make sure __s is null terminated.\n+      if (__len == 0)\n+\t__s[0] = '\\0';\n+    }\n+\n+  template<> \n+    void\n+    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc)\n+    {\n+      if (!_M_data)\n+\t_M_data = new __timepunct_cache<char>;\n+\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_c_locale_timepunct = _S_get_c_locale();\n+\n+\t  _M_data->_M_date_format = \"%m/%d/%y\";\n+\t  _M_data->_M_date_era_format = \"%m/%d/%y\";\n+\t  _M_data->_M_time_format = \"%H:%M:%S\";\n+\t  _M_data->_M_time_era_format = \"%H:%M:%S\";\n+\t  _M_data->_M_date_time_format = \"\";\n+\t  _M_data->_M_date_time_era_format = \"\";\n+\t  _M_data->_M_am = \"AM\";\n+\t  _M_data->_M_pm = \"PM\";\n+\t  _M_data->_M_am_pm_format = \"\";\n+\n+\t  // Day names, starting with \"C\"'s Sunday.\n+\t  _M_data->_M_day1 = \"Sunday\";\n+\t  _M_data->_M_day2 = \"Monday\";\n+\t  _M_data->_M_day3 = \"Tuesday\";\n+\t  _M_data->_M_day4 = \"Wednesday\";\n+\t  _M_data->_M_day5 = \"Thursday\";\n+\t  _M_data->_M_day6 = \"Friday\";\n+\t  _M_data->_M_day7 = \"Saturday\";\n+\n+\t  // Abbreviated day names, starting with \"C\"'s Sun.\n+\t  _M_data->_M_aday1 = \"Sun\";\n+\t  _M_data->_M_aday2 = \"Mon\";\n+\t  _M_data->_M_aday3 = \"Tue\";\n+\t  _M_data->_M_aday4 = \"Wed\";\n+\t  _M_data->_M_aday5 = \"Thu\";\n+\t  _M_data->_M_aday6 = \"Fri\";\n+\t  _M_data->_M_aday7 = \"Sat\";\n+\n+\t  // Month names, starting with \"C\"'s January.\n+\t  _M_data->_M_month01 = \"January\";\n+\t  _M_data->_M_month02 = \"February\";\n+\t  _M_data->_M_month03 = \"March\";\n+\t  _M_data->_M_month04 = \"April\";\n+\t  _M_data->_M_month05 = \"May\";\n+\t  _M_data->_M_month06 = \"June\";\n+\t  _M_data->_M_month07 = \"July\";\n+\t  _M_data->_M_month08 = \"August\";\n+\t  _M_data->_M_month09 = \"September\";\n+\t  _M_data->_M_month10 = \"October\";\n+\t  _M_data->_M_month11 = \"November\";\n+\t  _M_data->_M_month12 = \"December\";\n+\n+\t  // Abbreviated month names, starting with \"C\"'s Jan.\n+\t  _M_data->_M_amonth01 = \"Jan\";\n+\t  _M_data->_M_amonth02 = \"Feb\";\n+\t  _M_data->_M_amonth03 = \"Mar\";\n+\t  _M_data->_M_amonth04 = \"Apr\";\n+\t  _M_data->_M_amonth05 = \"May\";\n+\t  _M_data->_M_amonth06 = \"Jun\";\n+\t  _M_data->_M_amonth07 = \"Jul\";\n+\t  _M_data->_M_amonth08 = \"Aug\";\n+\t  _M_data->_M_amonth09 = \"Sep\";\n+\t  _M_data->_M_amonth10 = \"Oct\";\n+\t  _M_data->_M_amonth11 = \"Nov\";\n+\t  _M_data->_M_amonth12 = \"Dec\";\n+\t}\n+      else\n+\t{\n+\t  _M_c_locale_timepunct = _S_clone_c_locale(__cloc); \n+\n+\t  _M_data->_M_date_format = nl_langinfo_l(D_FMT, (locale_t)__cloc);\n+\t  _M_data->_M_date_era_format = nl_langinfo_l(ERA_D_FMT,\n+\t  \t\t\t\t\t      (locale_t)__cloc);\n+\t  _M_data->_M_time_format = nl_langinfo_l(T_FMT, (locale_t)__cloc);\n+\t  _M_data->_M_time_era_format = nl_langinfo_l(ERA_T_FMT,\n+\t\t\t\t\t\t      (locale_t)__cloc);\n+\t  _M_data->_M_date_time_format = nl_langinfo_l(D_T_FMT,\n+\t\t\t\t\t\t       (locale_t)__cloc);\n+\t  _M_data->_M_date_time_era_format = nl_langinfo_l(ERA_D_T_FMT,\n+\t  \t\t\t\t\t\t   (locale_t)__cloc);\n+\t  _M_data->_M_am = nl_langinfo_l(AM_STR, (locale_t)__cloc);\n+\t  _M_data->_M_pm = nl_langinfo_l(PM_STR, (locale_t)__cloc);\n+\t  _M_data->_M_am_pm_format = nl_langinfo_l(T_FMT_AMPM,\n+\t  \t\t\t\t\t   (locale_t)__cloc);\n+\n+\t  // Day names, starting with \"C\"'s Sunday.\n+\t  _M_data->_M_day1 = nl_langinfo_l(DAY_1, (locale_t)__cloc);\n+\t  _M_data->_M_day2 = nl_langinfo_l(DAY_2, (locale_t)__cloc);\n+\t  _M_data->_M_day3 = nl_langinfo_l(DAY_3, (locale_t)__cloc);\n+\t  _M_data->_M_day4 = nl_langinfo_l(DAY_4, (locale_t)__cloc);\n+\t  _M_data->_M_day5 = nl_langinfo_l(DAY_5, (locale_t)__cloc);\n+\t  _M_data->_M_day6 = nl_langinfo_l(DAY_6, (locale_t)__cloc);\n+\t  _M_data->_M_day7 = nl_langinfo_l(DAY_7, (locale_t)__cloc);\n+\n+\t  // Abbreviated day names, starting with \"C\"'s Sun.\n+\t  _M_data->_M_aday1 = nl_langinfo_l(ABDAY_1, (locale_t)__cloc);\n+\t  _M_data->_M_aday2 = nl_langinfo_l(ABDAY_2, (locale_t)__cloc);\n+\t  _M_data->_M_aday3 = nl_langinfo_l(ABDAY_3, (locale_t)__cloc);\n+\t  _M_data->_M_aday4 = nl_langinfo_l(ABDAY_4, (locale_t)__cloc);\n+\t  _M_data->_M_aday5 = nl_langinfo_l(ABDAY_5, (locale_t)__cloc);\n+\t  _M_data->_M_aday6 = nl_langinfo_l(ABDAY_6, (locale_t)__cloc);\n+\t  _M_data->_M_aday7 = nl_langinfo_l(ABDAY_7, (locale_t)__cloc);\n+\n+\t  // Month names, starting with \"C\"'s January.\n+\t  _M_data->_M_month01 = nl_langinfo_l(MON_1, (locale_t)__cloc);\n+\t  _M_data->_M_month02 = nl_langinfo_l(MON_2, (locale_t)__cloc);\n+\t  _M_data->_M_month03 = nl_langinfo_l(MON_3, (locale_t)__cloc);\n+\t  _M_data->_M_month04 = nl_langinfo_l(MON_4, (locale_t)__cloc);\n+\t  _M_data->_M_month05 = nl_langinfo_l(MON_5, (locale_t)__cloc);\n+\t  _M_data->_M_month06 = nl_langinfo_l(MON_6, (locale_t)__cloc);\n+\t  _M_data->_M_month07 = nl_langinfo_l(MON_7, (locale_t)__cloc);\n+\t  _M_data->_M_month08 = nl_langinfo_l(MON_8, (locale_t)__cloc);\n+\t  _M_data->_M_month09 = nl_langinfo_l(MON_9, (locale_t)__cloc);\n+\t  _M_data->_M_month10 = nl_langinfo_l(MON_10, (locale_t)__cloc);\n+\t  _M_data->_M_month11 = nl_langinfo_l(MON_11, (locale_t)__cloc);\n+\t  _M_data->_M_month12 = nl_langinfo_l(MON_12, (locale_t)__cloc);\n+\n+\t  // Abbreviated month names, starting with \"C\"'s Jan.\n+\t  _M_data->_M_amonth01 = nl_langinfo_l(ABMON_1, (locale_t)__cloc);\n+\t  _M_data->_M_amonth02 = nl_langinfo_l(ABMON_2, (locale_t)__cloc);\n+\t  _M_data->_M_amonth03 = nl_langinfo_l(ABMON_3, (locale_t)__cloc);\n+\t  _M_data->_M_amonth04 = nl_langinfo_l(ABMON_4, (locale_t)__cloc);\n+\t  _M_data->_M_amonth05 = nl_langinfo_l(ABMON_5, (locale_t)__cloc);\n+\t  _M_data->_M_amonth06 = nl_langinfo_l(ABMON_6, (locale_t)__cloc);\n+\t  _M_data->_M_amonth07 = nl_langinfo_l(ABMON_7, (locale_t)__cloc);\n+\t  _M_data->_M_amonth08 = nl_langinfo_l(ABMON_8, (locale_t)__cloc);\n+\t  _M_data->_M_amonth09 = nl_langinfo_l(ABMON_9, (locale_t)__cloc);\n+\t  _M_data->_M_amonth10 = nl_langinfo_l(ABMON_10, (locale_t)__cloc);\n+\t  _M_data->_M_amonth11 = nl_langinfo_l(ABMON_11, (locale_t)__cloc);\n+\t  _M_data->_M_amonth12 = nl_langinfo_l(ABMON_12, (locale_t)__cloc);\n+\t}\n+    }\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    void\n+    __timepunct<wchar_t>::\n+    _M_put(wchar_t* __s, size_t __maxlen, const wchar_t* __format, \n+\t   const tm* __tm) const throw()\n+    {\n+      const size_t __len = wcsftime_l(__s, __maxlen, __format, __tm,\n+\t\t\t\t      (locale_t)_M_c_locale_timepunct);\n+      // Make sure __s is null terminated.\n+      if (__len == 0)\n+\t__s[0] = L'\\0';\n+    }\n+\n+#define WIDE_LANGINFO(M,FMT) \\\n+\tfmtlen = mbstowcs_l (holder, nl_langinfo_l(FMT, (locale_t)__cloc), \\\n+\t\t128, (locale_t)__cloc); \\\n+\tlangstring = new wchar_t[fmtlen + 1]; \\\n+\twcsncpy (langstring, holder, fmtlen); \\\n+\tlangstring[fmtlen] = L'\\0'; \\\n+\t_M_data->M = langstring;\n+\n+  template<> \n+    void\n+    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc)\n+    {\n+      if (!_M_data)\n+\t_M_data = new __timepunct_cache<wchar_t>;\n+\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_c_locale_timepunct = _S_get_c_locale();\n+\n+\t  _M_data->_M_date_format = L\"%m/%d/%y\";\n+\t  _M_data->_M_date_era_format = L\"%m/%d/%y\";\n+\t  _M_data->_M_time_format = L\"%H:%M:%S\";\n+\t  _M_data->_M_time_era_format = L\"%H:%M:%S\";\n+\t  _M_data->_M_date_time_format = L\"\";\n+\t  _M_data->_M_date_time_era_format = L\"\";\n+\t  _M_data->_M_am = L\"AM\";\n+\t  _M_data->_M_pm = L\"PM\";\n+\t  _M_data->_M_am_pm_format = L\"\";\n+\n+\t  // Day names, starting with \"C\"'s Sunday.\n+\t  _M_data->_M_day1 = L\"Sunday\";\n+\t  _M_data->_M_day2 = L\"Monday\";\n+\t  _M_data->_M_day3 = L\"Tuesday\";\n+\t  _M_data->_M_day4 = L\"Wednesday\";\n+\t  _M_data->_M_day5 = L\"Thursday\";\n+\t  _M_data->_M_day6 = L\"Friday\";\n+\t  _M_data->_M_day7 = L\"Saturday\";\n+\n+\t  // Abbreviated day names, starting with \"C\"'s Sun.\n+\t  _M_data->_M_aday1 = L\"Sun\";\n+\t  _M_data->_M_aday2 = L\"Mon\";\n+\t  _M_data->_M_aday3 = L\"Tue\";\n+\t  _M_data->_M_aday4 = L\"Wed\";\n+\t  _M_data->_M_aday5 = L\"Thu\";\n+\t  _M_data->_M_aday6 = L\"Fri\";\n+\t  _M_data->_M_aday7 = L\"Sat\";\n+\n+\t  // Month names, starting with \"C\"'s January.\n+\t  _M_data->_M_month01 = L\"January\";\n+\t  _M_data->_M_month02 = L\"February\";\n+\t  _M_data->_M_month03 = L\"March\";\n+\t  _M_data->_M_month04 = L\"April\";\n+\t  _M_data->_M_month05 = L\"May\";\n+\t  _M_data->_M_month06 = L\"June\";\n+\t  _M_data->_M_month07 = L\"July\";\n+\t  _M_data->_M_month08 = L\"August\";\n+\t  _M_data->_M_month09 = L\"September\";\n+\t  _M_data->_M_month10 = L\"October\";\n+\t  _M_data->_M_month11 = L\"November\";\n+\t  _M_data->_M_month12 = L\"December\";\n+\n+\t  // Abbreviated month names, starting with \"C\"'s Jan.\n+\t  _M_data->_M_amonth01 = L\"Jan\";\n+\t  _M_data->_M_amonth02 = L\"Feb\";\n+\t  _M_data->_M_amonth03 = L\"Mar\";\n+\t  _M_data->_M_amonth04 = L\"Apr\";\n+\t  _M_data->_M_amonth05 = L\"May\";\n+\t  _M_data->_M_amonth06 = L\"Jun\";\n+\t  _M_data->_M_amonth07 = L\"Jul\";\n+\t  _M_data->_M_amonth08 = L\"Aug\";\n+\t  _M_data->_M_amonth09 = L\"Sep\";\n+\t  _M_data->_M_amonth10 = L\"Oct\";\n+\t  _M_data->_M_amonth11 = L\"Nov\";\n+\t  _M_data->_M_amonth12 = L\"Dec\";\n+\t}\n+      else\n+\t{\n+\t  wchar_t *langstring = 0;\n+\t  wchar_t holder[128];\n+\t  size_t fmtlen;\n+\n+\t  _M_c_locale_timepunct = _S_clone_c_locale(__cloc); \n+\n+\t  WIDE_LANGINFO(_M_date_format, D_FMT)\n+\t  WIDE_LANGINFO(_M_date_era_format, ERA_D_FMT)\n+\t  WIDE_LANGINFO(_M_time_format, T_FMT)\n+\t  WIDE_LANGINFO(_M_time_era_format, ERA_T_FMT)\n+\t  WIDE_LANGINFO(_M_date_time_format, D_T_FMT)\n+\t  WIDE_LANGINFO(_M_date_time_era_format, ERA_D_T_FMT)\n+\t  WIDE_LANGINFO(_M_am, AM_STR)\n+\t  WIDE_LANGINFO(_M_pm, PM_STR)\n+\t  WIDE_LANGINFO(_M_am_pm_format, T_FMT_AMPM)\n+\n+\t  // Day names, starting with \"C\"'s Sunday.\n+\t  WIDE_LANGINFO(_M_day1, DAY_1)\n+\t  WIDE_LANGINFO(_M_day2, DAY_2)\n+\t  WIDE_LANGINFO(_M_day3, DAY_3)\n+\t  WIDE_LANGINFO(_M_day4, DAY_4)\n+\t  WIDE_LANGINFO(_M_day5, DAY_5)\n+\t  WIDE_LANGINFO(_M_day6, DAY_6)\n+\t  WIDE_LANGINFO(_M_day7, DAY_7)\n+\n+\t  // Abbreviated day names, starting with \"C\"'s Sun.\n+\t  WIDE_LANGINFO(_M_aday1, ABDAY_1)\n+\t  WIDE_LANGINFO(_M_aday2, ABDAY_2)\n+\t  WIDE_LANGINFO(_M_aday3, ABDAY_3)\n+\t  WIDE_LANGINFO(_M_aday4, ABDAY_4)\n+\t  WIDE_LANGINFO(_M_aday5, ABDAY_5)\n+\t  WIDE_LANGINFO(_M_aday6, ABDAY_6)\n+\t  WIDE_LANGINFO(_M_aday7, ABDAY_7)\n+\n+\t  // Month names, starting with \"C\"'s January.\n+\t  WIDE_LANGINFO(_M_month01, MON_1)\n+\t  WIDE_LANGINFO(_M_month02, MON_2)\n+\t  WIDE_LANGINFO(_M_month03, MON_3)\n+\t  WIDE_LANGINFO(_M_month04, MON_4)\n+\t  WIDE_LANGINFO(_M_month05, MON_5)\n+\t  WIDE_LANGINFO(_M_month06, MON_6)\n+\t  WIDE_LANGINFO(_M_month07, MON_7)\n+\t  WIDE_LANGINFO(_M_month08, MON_8)\n+\t  WIDE_LANGINFO(_M_month09, MON_9)\n+\t  WIDE_LANGINFO(_M_month10, MON_10)\n+\t  WIDE_LANGINFO(_M_month11, MON_11)\n+\t  WIDE_LANGINFO(_M_month12, MON_12)\n+\n+\t  // Abbreviated month names, starting with \"C\"'s Jan.\n+\t  WIDE_LANGINFO(_M_amonth01, ABMON_1)\n+\t  WIDE_LANGINFO(_M_amonth02, ABMON_2)\n+\t  WIDE_LANGINFO(_M_amonth03, ABMON_3)\n+\t  WIDE_LANGINFO(_M_amonth04, ABMON_4)\n+\t  WIDE_LANGINFO(_M_amonth05, ABMON_5)\n+\t  WIDE_LANGINFO(_M_amonth06, ABMON_6)\n+\t  WIDE_LANGINFO(_M_amonth07, ABMON_7)\n+\t  WIDE_LANGINFO(_M_amonth08, ABMON_8)\n+\t  WIDE_LANGINFO(_M_amonth09, ABMON_9)\n+\t  WIDE_LANGINFO(_M_amonth10, ABMON_10)\n+\t  WIDE_LANGINFO(_M_amonth11, ABMON_11)\n+\t  WIDE_LANGINFO(_M_amonth12, ABMON_12)\n+\t}\n+    }\n+\n+  template<> \n+    __timepunct<wchar_t>::~__timepunct()\n+    {\n+      delete [] _M_data->_M_date_format;\n+      delete [] _M_data->_M_date_era_format;\n+      delete [] _M_data->_M_time_format;\n+      delete [] _M_data->_M_time_era_format;\n+      delete [] _M_data->_M_date_time_format;\n+      delete [] _M_data->_M_date_time_era_format;\n+      delete [] _M_data->_M_am;\n+      delete [] _M_data->_M_pm;\n+      delete [] _M_data->_M_am_pm_format;\n+      delete [] _M_data->_M_day1;\n+      delete [] _M_data->_M_day2;\n+      delete [] _M_data->_M_day3;\n+      delete [] _M_data->_M_day4;\n+      delete [] _M_data->_M_day5;\n+      delete [] _M_data->_M_day6;\n+      delete [] _M_data->_M_day7;\n+      delete [] _M_data->_M_aday1;\n+      delete [] _M_data->_M_aday2;\n+      delete [] _M_data->_M_aday3;\n+      delete [] _M_data->_M_aday4;\n+      delete [] _M_data->_M_aday5;\n+      delete [] _M_data->_M_aday6;\n+      delete [] _M_data->_M_aday7;\n+      delete [] _M_data->_M_month01;\n+      delete [] _M_data->_M_month02;\n+      delete [] _M_data->_M_month03;\n+      delete [] _M_data->_M_month04;\n+      delete [] _M_data->_M_month05;\n+      delete [] _M_data->_M_month06;\n+      delete [] _M_data->_M_month07;\n+      delete [] _M_data->_M_month08;\n+      delete [] _M_data->_M_month09;\n+      delete [] _M_data->_M_month10;\n+      delete [] _M_data->_M_month11;\n+      delete [] _M_data->_M_month12;\n+      delete [] _M_data->_M_amonth01;\n+      delete [] _M_data->_M_amonth02;\n+      delete [] _M_data->_M_amonth03;\n+      delete [] _M_data->_M_amonth04;\n+      delete [] _M_data->_M_amonth05;\n+      delete [] _M_data->_M_amonth06;\n+      delete [] _M_data->_M_amonth07;\n+      delete [] _M_data->_M_amonth08;\n+      delete [] _M_data->_M_amonth09;\n+      delete [] _M_data->_M_amonth10;\n+      delete [] _M_data->_M_amonth11;\n+      delete [] _M_data->_M_amonth12;\n+      delete _M_data;\n+    }\n+\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "fb78bc6e45f3e4d9b754b945f4a522b55879ef95", "filename": "libstdc++-v3/config/locale/dragonfly/time_members.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Ftime_members.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Ftime_members.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fdragonfly%2Ftime_members.h?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -0,0 +1,95 @@\n+// std::time_get, std::time_put implementation, DragonFly version -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/time_members.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{locale}\n+ */\n+\n+//\n+// ISO C++ 14882: 22.2.5.1.2 - time_get functions\n+// ISO C++ 14882: 22.2.5.3.2 - time_put functions\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+// Modified for DragonFly by John Marino <gnugcc@marino.st>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _CharT>\n+    __timepunct<_CharT>::__timepunct(size_t __refs) \n+    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0), \n+      _M_name_timepunct(_S_get_c_name())\n+    { _M_initialize_timepunct(); }\n+\n+  template<typename _CharT>\n+    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs) \n+    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(0), \n+      _M_name_timepunct(_S_get_c_name())\n+    { _M_initialize_timepunct(); }\n+\n+  template<typename _CharT>\n+    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,\n+\t\t\t\t     size_t __refs) \n+    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0), \n+      _M_name_timepunct(0)\n+    {\n+      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)\n+\t{\n+\t  const size_t __len = __builtin_strlen(__s) + 1;\n+\t  char* __tmp = new char[__len];\n+\t  __builtin_memcpy(__tmp, __s, __len);\n+\t  _M_name_timepunct = __tmp;\n+\t}\n+      else\n+\t_M_name_timepunct = _S_get_c_name();\n+\n+      __try\n+\t{ _M_initialize_timepunct(__cloc); }\n+      __catch(...)\n+\t{\n+\t  if (_M_name_timepunct != _S_get_c_name())\n+\t    delete [] _M_name_timepunct;\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _CharT>\n+    __timepunct<_CharT>::~__timepunct()\n+    { \n+      if (_M_name_timepunct != _S_get_c_name())\n+\tdelete [] _M_name_timepunct;\n+      delete _M_data; \n+      _S_destroy_c_locale(_M_c_locale_timepunct); \n+    }\n+\n+  // specialization\n+  template<>\n+    __timepunct<wchar_t>::~__timepunct();\n+\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "b1c24a2e1a53bedf44c4912336745790e6838f8d", "filename": "libstdc++-v3/config/os/bsd/dragonfly/ctype_configure_char.cc", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fbsd%2Fdragonfly%2Fctype_configure_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fbsd%2Fdragonfly%2Fctype_configure_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fbsd%2Fdragonfly%2Fctype_configure_char.cc?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -37,32 +37,60 @@ namespace std _GLIBCXX_VISIBILITY(default)\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n // Information as gleaned from /usr/include/ctype.h\n-  \n+\n   const ctype_base::mask*\n   ctype<char>::classic_table() throw()\n-  { return 0; }\n-\n-  ctype<char>::ctype(__c_locale, const mask* __table, bool __del, \n-\t\t     size_t __refs) \n-  : facet(__refs), _M_del(__table != 0 && __del), \n-  _M_toupper(NULL), _M_tolower(NULL), \n-  _M_table(__table ? __table : classic_table()) \n-  { \n+  { return NULL; }\n+\n+  ctype<char>::ctype(__c_locale, const mask* __table, bool __del,\n+\t\t     size_t __refs)\n+  : facet(__refs), _M_c_locale_ctype(_S_get_c_locale()),\n+  _M_del(__table != 0 && __del), _M_widen_ok(0), _M_narrow_ok(0)\n+  {\n+    char* __old = setlocale(LC_CTYPE, NULL);\n+    char* __sav = NULL;\n+    if (strcmp(__old, \"C\"))\n+      {\n+\tconst size_t __len = strlen(__old) + 1;\n+\t__sav = new char[__len];\n+\tmemcpy(__sav, __old, __len);\n+\tsetlocale(LC_CTYPE, \"C\");\n+      }\n+    _M_toupper = NULL;\n+    _M_tolower = NULL;\n+    _M_table = __table ? __table : classic_table();\n+    if (__sav)\n+      {\n+\tsetlocale(LC_CTYPE, __sav);\n+\tdelete [] __sav;\n+      }\n     memset(_M_widen, 0, sizeof(_M_widen));\n-    _M_widen_ok = 0;\n     memset(_M_narrow, 0, sizeof(_M_narrow));\n-    _M_narrow_ok = 0;\n   }\n \n-  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs) \n-  : facet(__refs), _M_del(__table != 0 && __del), \n-  _M_toupper(NULL), _M_tolower(NULL), \n-  _M_table(__table ? __table : classic_table()) \n-  { \n+  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs)\n+  : facet(__refs), _M_c_locale_ctype(_S_get_c_locale()),\n+  _M_del(__table != 0 && __del), _M_widen_ok(0), _M_narrow_ok(0)\n+  {\n+    char* __old = setlocale(LC_CTYPE, NULL);\n+    char* __sav = NULL;\n+    if (strcmp(__old, \"C\"))\n+      {\n+\tconst size_t __len = strlen(__old) + 1;\n+\t__sav = new char[__len];\n+\tmemcpy(__sav, __old, __len);\n+\tsetlocale(LC_CTYPE, \"C\");\n+      }\n+    _M_toupper = NULL;\n+    _M_tolower = NULL;\n+    _M_table = __table ? __table : classic_table();\n+    if (__sav)\n+      {\n+\tsetlocale(LC_CTYPE, __sav);\n+\tdelete [] __sav;\n+      }\n     memset(_M_widen, 0, sizeof(_M_widen));\n-    _M_widen_ok = 0;\n     memset(_M_narrow, 0, sizeof(_M_narrow));\n-    _M_narrow_ok = 0;\n   }\n \n   char\n@@ -84,7 +112,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   ctype<char>::do_tolower(char __c) const\n   { return ::tolower((int) __c); }\n \n-  const char* \n+  const char*\n   ctype<char>::do_tolower(char* __low, const char* __high) const\n   {\n     while (__low < __high)"}, {"sha": "2209129145a033895e30420df65b0de35946df55", "filename": "libstdc++-v3/config/os/bsd/dragonfly/os_defines.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fbsd%2Fdragonfly%2Fos_defines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fbsd%2Fdragonfly%2Fos_defines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fbsd%2Fdragonfly%2Fos_defines.h?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -29,6 +29,7 @@\n // System-specific #define, typedefs, corrections, etc, go here.  This\n // file will come before all others.\n \n+#define _GLIBCXX_USE_C99 1\n #define _GLIBCXX_USE_C99_CHECK 1\n #define _GLIBCXX_USE_C99_DYNAMIC (!(__ISO_C_VISIBLE >= 1999))\n #define _GLIBCXX_USE_C99_LONG_LONG_CHECK 1"}, {"sha": "8646465fbbee75f0b870c631e1da64f3d834bfd9", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=a98e4e62c1c0c8570c7db321e3c8a2a7c2336c60", "patch": "@@ -15986,17 +15986,17 @@ $as_echo \"darwin or freebsd\" >&6; }\n       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: dragonfly\" >&5\n $as_echo \"dragonfly\" >&6; }\n \n-      CLOCALE_H=config/locale/generic/c_locale.h\n+      CLOCALE_H=config/locale/dragonfly/c_locale.h\n       CLOCALE_CC=config/locale/dragonfly/c_locale.cc\n-      CCODECVT_CC=config/locale/generic/codecvt_members.cc\n-      CCOLLATE_CC=config/locale/generic/collate_members.cc\n+      CCODECVT_CC=config/locale/dragonfly/codecvt_members.cc\n+      CCOLLATE_CC=config/locale/dragonfly/collate_members.cc\n       CCTYPE_CC=config/locale/dragonfly/ctype_members.cc\n       CMESSAGES_H=config/locale/generic/messages_members.h\n       CMESSAGES_CC=config/locale/generic/messages_members.cc\n-      CMONEY_CC=config/locale/generic/monetary_members.cc\n-      CNUMERIC_CC=config/locale/generic/numeric_members.cc\n-      CTIME_H=config/locale/generic/time_members.h\n-      CTIME_CC=config/locale/generic/time_members.cc\n+      CMONEY_CC=config/locale/dragonfly/monetary_members.cc\n+      CNUMERIC_CC=config/locale/dragonfly/numeric_members.cc\n+      CTIME_H=config/locale/dragonfly/time_members.h\n+      CTIME_CC=config/locale/dragonfly/time_members.cc\n       CLOCALE_INTERNAL_H=config/locale/generic/c++locale_internal.h\n       ;;\n "}]}