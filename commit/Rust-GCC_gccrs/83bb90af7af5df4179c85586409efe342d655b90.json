{"sha": "83bb90af7af5df4179c85586409efe342d655b90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNiYjkwYWY3YWY1ZGY0MTc5Yzg1NTg2NDA5ZWZlMzQyZDY1NWI5MA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2012-06-12T10:07:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-12T10:07:29Z"}, "message": "sem_prag.adb (Analyze_Pragma, [...]): Do not crash on illegal unchecked union that is a null record.\n\n2012-06-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma, case Unchecked_Union): Do\n\tnot crash on illegal unchecked union that is a null record.\n\n2012-06-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb (Has_Inferable_Discriminants): Reorganize code to\n\ttreat implicit dereferences with a constrained unchecked union\n\tnominal subtype as having inferable discriminants.\n\nFrom-SVN: r188437", "tree": {"sha": "11ff71a3be65dc04fda99dc9197d9e47e6db5c94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11ff71a3be65dc04fda99dc9197d9e47e6db5c94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83bb90af7af5df4179c85586409efe342d655b90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bb90af7af5df4179c85586409efe342d655b90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83bb90af7af5df4179c85586409efe342d655b90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bb90af7af5df4179c85586409efe342d655b90/comments", "author": null, "committer": null, "parents": [{"sha": "586ecbf363a2a4209c5bacc0d292f3bf08f784e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586ecbf363a2a4209c5bacc0d292f3bf08f784e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/586ecbf363a2a4209c5bacc0d292f3bf08f784e1"}], "stats": {"total": 63, "additions": 39, "deletions": 24}, "files": [{"sha": "7eab91e039b780ca34b8912954b0f5ff55e75bbd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bb90af7af5df4179c85586409efe342d655b90/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bb90af7af5df4179c85586409efe342d655b90/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=83bb90af7af5df4179c85586409efe342d655b90", "patch": "@@ -1,3 +1,14 @@\n+2012-06-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Unchecked_Union): Do\n+\tnot crash on illegal unchecked union that is a null record.\n+\n+2012-06-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb (Has_Inferable_Discriminants): Reorganize code to\n+\ttreat implicit dereferences with a constrained unchecked union\n+\tnominal subtype as having inferable discriminants. \n+\n 2012-06-12  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch6.adb: Minor reformatting."}, {"sha": "e115edabfbd90cacb2100e24659da2e7d7301322", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bb90af7af5df4179c85586409efe342d655b90/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bb90af7af5df4179c85586409efe342d655b90/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=83bb90af7af5df4179c85586409efe342d655b90", "patch": "@@ -10048,11 +10048,12 @@ package body Exp_Ch4 is\n       --------------------------------\n \n       function Prefix_Is_Formal_Parameter (N : Node_Id) return Boolean is\n-         Sel_Comp : Node_Id := N;\n+         Sel_Comp : Node_Id;\n \n       begin\n          --  Move to the left-most prefix by climbing up the tree\n \n+         Sel_Comp := N;\n          while Present (Parent (Sel_Comp))\n            and then Nkind (Parent (Sel_Comp)) = N_Selected_Component\n          loop\n@@ -10065,20 +10066,12 @@ package body Exp_Ch4 is\n    --  Start of processing for Has_Inferable_Discriminants\n \n    begin\n-      --  For identifiers and indexed components, it is sufficient to have a\n-      --  constrained Unchecked_Union nominal subtype.\n-\n-      if Nkind_In (N, N_Identifier, N_Indexed_Component) then\n-         return Is_Unchecked_Union (Base_Type (Etype (N)))\n-                  and then\n-                Is_Constrained (Etype (N));\n-\n       --  For selected components, the subtype of the selector must be a\n       --  constrained Unchecked_Union. If the component is subject to a\n       --  per-object constraint, then the enclosing object must have inferable\n       --  discriminants.\n \n-      elsif Nkind (N) = N_Selected_Component then\n+      if Nkind (N) = N_Selected_Component then\n          if Has_Per_Object_Constraint (Entity (Selector_Name (N))) then\n \n             --  A small hack. If we have a per-object constrained selected\n@@ -10087,29 +10080,35 @@ package body Exp_Ch4 is\n \n             if Prefix_Is_Formal_Parameter (N) then\n                return True;\n-            end if;\n \n             --  Otherwise, check the enclosing object and the selector\n \n-            return Has_Inferable_Discriminants (Prefix (N))\n-                     and then\n-                   Has_Inferable_Discriminants (Selector_Name (N));\n-         end if;\n+            else\n+               return Has_Inferable_Discriminants (Prefix (N))\n+                 and then Has_Inferable_Discriminants (Selector_Name (N));\n+            end if;\n \n          --  The call to Has_Inferable_Discriminants will determine whether\n          --  the selector has a constrained Unchecked_Union nominal type.\n \n-         return Has_Inferable_Discriminants (Selector_Name (N));\n+         else\n+            return Has_Inferable_Discriminants (Selector_Name (N));\n+         end if;\n \n       --  A qualified expression has inferable discriminants if its subtype\n       --  mark is a constrained Unchecked_Union subtype.\n \n       elsif Nkind (N) = N_Qualified_Expression then\n          return Is_Unchecked_Union (Etype (Subtype_Mark (N)))\n            and then Is_Constrained (Etype (Subtype_Mark (N)));\n-      end if;\n \n-      return False;\n+      --  For all other names, it is sufficient to have a constrained\n+      --  Unchecked_Union nominal subtype.\n+\n+      else\n+         return Is_Unchecked_Union (Base_Type (Etype (N)))\n+           and then Is_Constrained (Etype (N));\n+      end if;\n    end Has_Inferable_Discriminants;\n \n    -------------------------------"}, {"sha": "757ea700bb06ceb29b5cd7ae470a73be55901ec5", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bb90af7af5df4179c85586409efe342d655b90/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bb90af7af5df4179c85586409efe342d655b90/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=83bb90af7af5df4179c85586409efe342d655b90", "patch": "@@ -14186,18 +14186,23 @@ package body Sem_Prag is\n                Tdef  := Type_Definition (Declaration_Node (Typ));\n                Clist := Component_List (Tdef);\n \n+               --  Check presence of component list and variant part\n+\n+               if No (Clist) or else No (Variant_Part (Clist)) then\n+                  Error_Msg_N\n+                    (\"Unchecked_Union must have variant part\", Tdef);\n+                  return;\n+               end if;\n+\n+               --  Check components\n+\n                Comp := First (Component_Items (Clist));\n                while Present (Comp) loop\n                   Check_Component (Comp, Typ);\n                   Next (Comp);\n                end loop;\n \n-               if No (Clist) or else No (Variant_Part (Clist)) then\n-                  Error_Msg_N\n-                    (\"Unchecked_Union must have variant part\",\n-                     Tdef);\n-                  return;\n-               end if;\n+               --  Check variant part\n \n                Vpart := Variant_Part (Clist);\n "}]}