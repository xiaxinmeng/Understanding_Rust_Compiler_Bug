{"sha": "d2cc7f9266280e7bd2cf880cec034b290d94adcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJjYzdmOTI2NjI4MGU3YmQyY2Y4ODBjZWMwMzRiMjkwZDk0YWRjZA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-12-17T23:42:58Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-12-17T23:42:58Z"}, "message": "stl_vector.h (vector(const vector&)): Use _M_get_Tp_allocator.\n\n2005-12-17  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_vector.h (vector(const vector&)): Use\n\t_M_get_Tp_allocator.\n\t* include/bits/stl_deque.h (deque(const deque&)): Likewise.\n\t(_M_destroy_data): Adjust.\n\n2005-12-17  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_deque.h (deque<>::_M_erase_at_end,\n\t_M_erase_at_begin, _M_destroy_data, _M_destroy_data_dispatch,\n\t_M_destroy_data_aux): New, optimize erase at begin() / end() and\n\tconsistently use the \"segmented iterator\" optimization.\n\t(deque<>::~deque(), resize, clear, _M_assign_aux, _M_fill_assign):\n\tUse the above.\n\t* include/bits/deque.tcc (deque<>::operator=, _M_assign_aux): Same.\n\t(erase(iterator, iterator)): Likewise, clean-up.\n\t(erase(iterator)): Tweak, don't call copy unnecessarily. \n\t(_M_destroy_data_aux): Define.\n\t* testsuite/23_containers/deque/modifiers/erase/1.cc: New.\n\t* testsuite/23_containers/deque/modifiers/erase/2.cc: Likewise.\n\nFrom-SVN: r108727", "tree": {"sha": "5c68797a2ab28649717b6f0e949cf2516613985e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c68797a2ab28649717b6f0e949cf2516613985e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2cc7f9266280e7bd2cf880cec034b290d94adcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2cc7f9266280e7bd2cf880cec034b290d94adcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2cc7f9266280e7bd2cf880cec034b290d94adcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2cc7f9266280e7bd2cf880cec034b290d94adcd/comments", "author": null, "committer": null, "parents": [{"sha": "d9e88af0e216994a14d7dbca7f7d227ac03b1365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e88af0e216994a14d7dbca7f7d227ac03b1365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e88af0e216994a14d7dbca7f7d227ac03b1365"}], "stats": {"total": 445, "additions": 377, "deletions": 68}, "files": [{"sha": "2599c135ec54046cd33c4fd45cb328dd5e19f2b8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d2cc7f9266280e7bd2cf880cec034b290d94adcd", "patch": "@@ -1,3 +1,25 @@\n+2005-12-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_vector.h (vector(const vector&)): Use\n+\t_M_get_Tp_allocator.\n+\t* include/bits/stl_deque.h (deque(const deque&)): Likewise.\n+\t(_M_destroy_data): Adjust.\n+\n+2005-12-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_deque.h (deque<>::_M_erase_at_end,\n+\t_M_erase_at_begin, _M_destroy_data, _M_destroy_data_dispatch,\n+\t_M_destroy_data_aux): New, optimize erase at begin() / end() and\n+\tconsistently use the \"segmented iterator\" optimization.\n+\t(deque<>::~deque(), resize, clear, _M_assign_aux, _M_fill_assign):\n+\tUse the above.\n+\t* include/bits/deque.tcc (deque<>::operator=, _M_assign_aux): Same.\n+\t(erase(iterator, iterator)): Likewise, clean-up.\n+\t(erase(iterator)): Tweak, don't call copy unnecessarily. \n+\t(_M_destroy_data_aux): Define.\n+\t* testsuite/23_containers/deque/modifiers/erase/1.cc: New.\n+\t* testsuite/23_containers/deque/modifiers/erase/2.cc: Likewise.\n+\n 2005-12-17  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* include/bits/valarray_after.h (_Expr<>::operator[](slice)): "}, {"sha": "d8f5ef6f0d29eb42992adf0ab0612f15a355b672", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 41, "deletions": 59, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=d2cc7f9266280e7bd2cf880cec034b290d94adcd", "patch": "@@ -72,8 +72,8 @@ namespace _GLIBCXX_STD\n       if (&__x != this)\n \t{\n \t  if (__len >= __x.size())\n-\t    erase(std::copy(__x.begin(), __x.end(), this->_M_impl._M_start),\n-\t\t  this->_M_impl._M_finish);\n+\t    _M_erase_at_end(std::copy(__x.begin(), __x.end(),\n+\t\t\t\t      this->_M_impl._M_start));\n \t  else\n \t    {\n \t      const_iterator __mid = __x.begin() + difference_type(__len);\n@@ -112,92 +112,52 @@ namespace _GLIBCXX_STD\n     {\n       iterator __next = __position;\n       ++__next;\n-      const size_type __index = __position - this->_M_impl._M_start;\n+      const size_type __index = __position - begin();\n       if (__index < (size() >> 1))\n \t{\n-\t  std::copy_backward(this->_M_impl._M_start, __position, __next);\n+\t  if (__position != begin())\n+\t    std::copy_backward(begin(), __position, __next);\n \t  pop_front();\n \t}\n       else\n \t{\n-\t  std::copy(__next, this->_M_impl._M_finish, __position);\n+\t  if (__next != end())\n+\t    std::copy(__next, end(), __position);\n \t  pop_back();\n \t}\n-      return this->_M_impl._M_start + __index;\n+      return begin() + __index;\n     }\n \n   template <typename _Tp, typename _Alloc>\n     typename deque<_Tp, _Alloc>::iterator\n     deque<_Tp, _Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n-      if (__first == this->_M_impl._M_start\n-\t  && __last == this->_M_impl._M_finish)\n+      if (__first == begin() && __last == end())\n \t{\n \t  clear();\n-\t  return this->_M_impl._M_finish;\n+\t  return end();\n \t}\n       else\n \t{\n \t  const difference_type __n = __last - __first;\n-\t  const difference_type __elems_before = (__first\n-\t\t\t\t\t\t  - this->_M_impl._M_start);\n+\t  const difference_type __elems_before = __first - begin();\n \t  if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)\n \t    {\n-\t      std::copy_backward(this->_M_impl._M_start, __first, __last);\n-\t      iterator __new_start = this->_M_impl._M_start + __n;\n-\t      std::_Destroy(this->_M_impl._M_start, __new_start,\n-\t\t\t    _M_get_Tp_allocator());\n-\t      _M_destroy_nodes(this->_M_impl._M_start._M_node,\n-\t\t\t       __new_start._M_node);\n-\t      this->_M_impl._M_start = __new_start;\n+\t      if (__first != begin())\n+\t\tstd::copy_backward(begin(), __first, __last);\n+\t      _M_erase_at_begin(begin() + __n);\n \t    }\n \t  else\n \t    {\n-\t      std::copy(__last, this->_M_impl._M_finish, __first);\n-\t      iterator __new_finish = this->_M_impl._M_finish - __n;\n-\t      std::_Destroy(__new_finish, this->_M_impl._M_finish,\n-\t\t\t    _M_get_Tp_allocator());\n-\t      _M_destroy_nodes(__new_finish._M_node + 1,\n-\t\t\t       this->_M_impl._M_finish._M_node + 1);\n-\t      this->_M_impl._M_finish = __new_finish;\n+\t      if (__last != end())\n+\t\tstd::copy(__last, end(), __first);\n+\t      _M_erase_at_end(end() - __n);\n \t    }\n-\t  return this->_M_impl._M_start + __elems_before;\n+\t  return begin() + __elems_before;\n \t}\n     }\n \n-  template <typename _Tp, typename _Alloc>\n-    void\n-    deque<_Tp, _Alloc>::\n-    clear()\n-    {\n-      for (_Map_pointer __node = this->_M_impl._M_start._M_node + 1;\n-           __node < this->_M_impl._M_finish._M_node;\n-           ++__node)\n-\t{\n-\t  std::_Destroy(*__node, *__node + _S_buffer_size(),\n-\t\t\t_M_get_Tp_allocator());\n-\t  _M_deallocate_node(*__node);\n-\t}\n-\n-      if (this->_M_impl._M_start._M_node != this->_M_impl._M_finish._M_node)\n-\t{\n-\t  std::_Destroy(this->_M_impl._M_start._M_cur,\n-\t\t\tthis->_M_impl._M_start._M_last,\n-\t\t\t_M_get_Tp_allocator());\n-\t  std::_Destroy(this->_M_impl._M_finish._M_first,\n-\t\t\tthis->_M_impl._M_finish._M_cur,\n-\t\t\t_M_get_Tp_allocator());\n-\t  _M_deallocate_node(this->_M_impl._M_finish._M_first);\n-\t}\n-      else\n-        std::_Destroy(this->_M_impl._M_start._M_cur,\n-\t\t      this->_M_impl._M_finish._M_cur,\n-\t\t      _M_get_Tp_allocator());\n-\n-      this->_M_impl._M_finish = this->_M_impl._M_start;\n-    }\n-\n   template <typename _Tp, class _Alloc>\n     template <typename _InputIterator>\n       void\n@@ -209,7 +169,7 @@ namespace _GLIBCXX_STD\n         for (; __first != __last && __cur != end(); ++__cur, ++__first)\n           *__cur = *__first;\n         if (__first == __last)\n-          erase(__cur, end());\n+          _M_erase_at_end(__cur);\n         else\n           insert(end(), __first, __last);\n       }\n@@ -673,6 +633,28 @@ namespace _GLIBCXX_STD\n         }\n       }\n \n+   template<typename _Tp, typename _Alloc>\n+     void\n+     deque<_Tp, _Alloc>::\n+     _M_destroy_data_aux(iterator __first, iterator __last)\n+     {\n+       for (_Map_pointer __node = __first._M_node + 1;\n+\t    __node < __last._M_node; ++__node)\n+\t std::_Destroy(*__node, *__node + _S_buffer_size(),\n+\t\t       _M_get_Tp_allocator());\n+\n+       if (__first._M_node != __last._M_node)\n+\t {\n+\t   std::_Destroy(__first._M_cur, __first._M_last,\n+\t\t\t _M_get_Tp_allocator());\n+\t   std::_Destroy(__last._M_first, __last._M_cur,\n+\t\t\t _M_get_Tp_allocator());\n+\t }\n+       else\n+\t std::_Destroy(__first._M_cur, __last._M_cur,\n+\t\t       _M_get_Tp_allocator());\n+     }\n+\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp, _Alloc>::"}, {"sha": "15401ba6865478fda4f7106414756a0c8f9a35b9", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=d2cc7f9266280e7bd2cf880cec034b290d94adcd", "patch": "@@ -687,7 +687,7 @@ namespace _GLIBCXX_STD\n        *  by @a x.\n        */\n       deque(const deque& __x)\n-      : _Base(__x.get_allocator(), __x.size())\n+      : _Base(__x._M_get_Tp_allocator(), __x.size())\n       { std::__uninitialized_copy_a(__x.begin(), __x.end(), \n \t\t\t\t    this->_M_impl._M_start,\n \t\t\t\t    _M_get_Tp_allocator()); }\n@@ -722,8 +722,7 @@ namespace _GLIBCXX_STD\n        *  way.  Managing the pointer is the user's responsibilty.\n        */\n       ~deque()\n-      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t      _M_get_Tp_allocator()); }\n+      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }\n \n       /**\n        *  @brief  %Deque assignment operator.\n@@ -833,7 +832,8 @@ namespace _GLIBCXX_STD\n        *  in reverse element order.\n        */\n       reverse_iterator\n-      rend() { return reverse_iterator(this->_M_impl._M_start); }\n+      rend()\n+      { return reverse_iterator(this->_M_impl._M_start); }\n \n       /**\n        *  Returns a read-only (constant) reverse iterator that points\n@@ -871,7 +871,7 @@ namespace _GLIBCXX_STD\n       {\n \tconst size_type __len = size();\n \tif (__new_size < __len)\n-\t  erase(this->_M_impl._M_start + __new_size, this->_M_impl._M_finish);\n+\t  _M_erase_at_end(this->_M_impl._M_start + __new_size);\n \telse\n \t  insert(this->_M_impl._M_finish, __new_size - __len, __x);\n       }\n@@ -1191,7 +1191,9 @@ namespace _GLIBCXX_STD\n        *  pointed-to memory is not touched in any way.  Managing the pointer is\n        *  the user's responsibilty.\n        */\n-      void clear();\n+      void\n+      clear()\n+      { _M_erase_at_end(begin()); }\n \n     protected:\n       // Internal constructor functions follow.\n@@ -1301,7 +1303,7 @@ namespace _GLIBCXX_STD\n \t      insert(end(), __mid, __last);\n \t    }\n \t  else\n-\t    erase(std::copy(__first, __last, begin()), end());\n+\t    _M_erase_at_end(std::copy(__first, __last, begin()));\n \t}\n \n       // Called by assign(n,t), and the range assign when it turns out\n@@ -1316,7 +1318,7 @@ namespace _GLIBCXX_STD\n \t  }\n \telse\n \t  {\n-\t    erase(begin() + __n, end());\n+\t    _M_erase_at_end(begin() + __n);\n \t    std::fill(begin(), end(), __val);\n \t  }\n       }\n@@ -1328,8 +1330,11 @@ namespace _GLIBCXX_STD\n        *  @endif\n        */\n       void _M_push_back_aux(const value_type&);\n+\n       void _M_push_front_aux(const value_type&);\n+\n       void _M_pop_back_aux();\n+\n       void _M_pop_front_aux();\n       //@}\n \n@@ -1391,6 +1396,55 @@ namespace _GLIBCXX_STD\n \t\t      _ForwardIterator __first, _ForwardIterator __last,\n \t\t      size_type __n);\n \n+\n+      // Internal erase functions follow.\n+\n+      void\n+      _M_destroy_data_aux(iterator __first, iterator __last);\n+\n+      void\n+      _M_destroy_data_dispatch(iterator, iterator, __true_type) { }\n+      \n+      void\n+      _M_destroy_data_dispatch(iterator __first, iterator __last, __false_type)\n+      { _M_destroy_data_aux(__first, __last); }\n+\n+      // Called by ~deque().\n+      // NB: Doesn't deallocate the nodes.\n+      template<typename _Alloc1>\n+        void\n+        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)\n+        { _M_destroy_data_aux(__first, __last); }\n+\n+      void\n+      _M_destroy_data(iterator __first, iterator __last,\n+\t\t      const std::allocator<_Tp>&)\n+      {\n+\ttypedef typename std::__is_scalar<value_type>::__type\n+\t  _Has_trivial_destructor;\n+\t_M_destroy_data_dispatch(__first, __last, _Has_trivial_destructor());\n+      }\n+\n+      // Called by erase(q1, q2).\n+      void\n+      _M_erase_at_begin(iterator __pos)\n+      {\n+\t_M_destroy_data(begin(), __pos, _M_get_Tp_allocator());\n+\t_M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);\n+\tthis->_M_impl._M_start = __pos;\n+      }\n+\n+      // Called by erase(q1, q2), resize(), clear(), _M_assign_aux,\n+      // _M_fill_assign, operator=.\n+      void\n+      _M_erase_at_end(iterator __pos)\n+      {\n+\t_M_destroy_data(__pos, end(), _M_get_Tp_allocator());\n+\t_M_destroy_nodes(__pos._M_node + 1,\n+\t\t\t this->_M_impl._M_finish._M_node + 1);\n+\tthis->_M_impl._M_finish = __pos;\n+      }\n+\n       //@{\n       /**\n        *  @if maint"}, {"sha": "731806b0a9482f119d5a678b9c11b6881766995f", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=d2cc7f9266280e7bd2cf880cec034b290d94adcd", "patch": "@@ -230,7 +230,7 @@ namespace _GLIBCXX_STD\n        *  @a x (for fast expansion) will not be copied.\n        */\n       vector(const vector& __x)\n-      : _Base(__x.size(), __x.get_allocator())\n+      : _Base(__x.size(), __x._M_get_Tp_allocator())\n       { this->_M_impl._M_finish =\n \t  std::__uninitialized_copy_a(__x.begin(), __x.end(),\n \t\t\t\t      this->_M_impl._M_start,"}, {"sha": "167f1f2a12bff01b7c57a9be00ece200ae1a5ec6", "filename": "libstdc++-v3/testsuite/23_containers/deque/modifiers/erase/1.cc", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Ferase%2F1.cc?ref=d2cc7f9266280e7bd2cf880cec034b290d94adcd", "patch": "@@ -0,0 +1,136 @@\n+// 2005-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.1.3 deque modifiers\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+\n+const int  A[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+const int A1[] = {0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+const int A2[] = {0, 2, 3, 4, 10, 11, 12, 13, 14, 15};\n+const int A3[] = {0, 2, 3, 4, 10, 11};\n+const int A4[] = {4, 10, 11};\n+const int A5[] = {4, 10};\n+const int  N = sizeof(A)  / sizeof(int);\n+const int N1 = sizeof(A1) / sizeof(int);\n+const int N2 = sizeof(A2) / sizeof(int);\n+const int N3 = sizeof(A3) / sizeof(int);\n+const int N4 = sizeof(A4) / sizeof(int);\n+const int N5 = sizeof(A5) / sizeof(int);\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::deque<int>                deque_type;\n+  typedef deque_type::iterator        iterator_type;\n+\n+  deque_type v(A, A + N);\n+\n+  iterator_type it1 = v.erase(v.begin() + 1);\n+  VERIFY( it1 == v.begin() + 1 );\n+  VERIFY( v.size() == N1 );\n+  VERIFY( std::equal(v.begin(), v.end(), A1) );\n+  \n+  iterator_type it2 = v.erase(v.begin() + 4, v.begin() + 9);\n+  VERIFY( it2 == v.begin() + 4 );\n+  VERIFY( v.size() == N2 );\n+  VERIFY( std::equal(v.begin(), v.end(), A2) );\n+  \n+  iterator_type it3 = v.erase(v.begin() + 6, v.end());\n+  VERIFY( it3 == v.begin() + 6 );\n+  VERIFY( v.size() == N3 );\n+  VERIFY( std::equal(v.begin(), v.end(), A3) );\n+\n+  iterator_type it4 = v.erase(v.begin(), v.begin() + 3);\n+  VERIFY( it4 == v.begin() );\n+  VERIFY( v.size() == N4 );\n+  VERIFY( std::equal(v.begin(), v.end(), A4) );\n+\n+  iterator_type it5 = v.erase(v.begin() + 2);\n+  VERIFY( it5 == v.begin() + 2 );\n+  VERIFY( v.size() == N5 );\n+  VERIFY( std::equal(v.begin(), v.end(), A5) );\n+\n+  iterator_type it6 = v.erase(v.begin(), v.end());\n+  VERIFY( it6 == v.begin() );\n+  VERIFY( v.empty() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::deque<std::deque<int> >   deque_type;\n+  typedef deque_type::iterator        iterator_type;\n+\n+  deque_type v, v1, v2, v3, v4, v5;\n+  for (int i = 0; i < N; ++i)\n+    v.push_back(std::deque<int>(1, A[i]));\n+  for (int i = 0; i < N1; ++i)\n+    v1.push_back(std::deque<int>(1, A1[i]));\n+  for (int i = 0; i < N2; ++i)\n+    v2.push_back(std::deque<int>(1, A2[i]));\n+  for (int i = 0; i < N3; ++i)\n+    v3.push_back(std::deque<int>(1, A3[i]));\n+  for (int i = 0; i < N4; ++i)\n+    v4.push_back(std::deque<int>(1, A4[i]));\n+  for (int i = 0; i < N5; ++i)\n+    v5.push_back(std::deque<int>(1, A5[i]));\n+  \n+  iterator_type it1 = v.erase(v.begin() + 1);\n+  VERIFY( it1 == v.begin() + 1 );\n+  VERIFY( v.size() == N1 );\n+  VERIFY( std::equal(v.begin(), v.end(), v1.begin()) );\n+  \n+  iterator_type it2 = v.erase(v.begin() + 4, v.begin() + 9);\n+  VERIFY( it2 == v.begin() + 4 );\n+  VERIFY( v.size() == N2 );\n+  VERIFY( std::equal(v.begin(), v.end(), v2.begin()) );\n+  \n+  iterator_type it3 = v.erase(v.begin() + 6, v.end());\n+  VERIFY( it3 == v.begin() + 6 );\n+  VERIFY( v.size() == N3 );\n+  VERIFY( std::equal(v.begin(), v.end(), v3.begin()) );\n+\n+  iterator_type it4 = v.erase(v.begin(), v.begin() + 3);\n+  VERIFY( it4 == v.begin() );\n+  VERIFY( v.size() == N4 );\n+  VERIFY( std::equal(v.begin(), v.end(), v4.begin()) );\n+\n+  iterator_type it5 = v.erase(v.begin() + 2);\n+  VERIFY( it5 == v.begin() + 2 );\n+  VERIFY( v.size() == N5 );\n+  VERIFY( std::equal(v.begin(), v.end(), v5.begin()) );\n+\n+  iterator_type it6 = v.erase(v.begin(), v.end());\n+  VERIFY( it6 == v.begin() );\n+  VERIFY( v.empty() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "19542d3999e9e4488688b479d12ed2b935771c87", "filename": "libstdc++-v3/testsuite/23_containers/deque/modifiers/erase/2.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Ferase%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2cc7f9266280e7bd2cf880cec034b290d94adcd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Ferase%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Ferase%2F2.cc?ref=d2cc7f9266280e7bd2cf880cec034b290d94adcd", "patch": "@@ -0,0 +1,115 @@\n+// 2005-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.1.3 deque modifiers\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+\n+const int  A[] = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n+\t\t  13, 14, 15};\n+const int A0[] = {-5, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+const int A1[] = {-5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+const int A2[] = {-5, 0, 1, 2, 8, 9, 10, 11, 12, 13, 14, 15};\n+const int A3[] = {-5, 0, 1, 2, 8, 9, 10, 11};\n+const int A4[] = {2, 8, 9, 10, 11};\n+const int A5[] = {2, 8, 10, 11};\n+const int A6[] = {2, 8, 10};\n+const int  N = sizeof(A)  / sizeof(int);\n+const int N0 = sizeof(A0) / sizeof(int);\n+const int N1 = sizeof(A1) / sizeof(int);\n+const int N2 = sizeof(A2) / sizeof(int);\n+const int N3 = sizeof(A3) / sizeof(int);\n+const int N4 = sizeof(A4) / sizeof(int);\n+const int N5 = sizeof(A5) / sizeof(int);\n+const int N6 = sizeof(A6) / sizeof(int);\n+\n+template<int Size>\n+  class My_class\n+  {\n+    double dummy[Size];\n+    int data;\n+    \n+  public:\n+    My_class(int num)\n+    : data(num) { }\n+    \n+    operator int() const\n+    { return data; }\n+  };\n+\n+template<typename T>\n+  void\n+  test01()\n+  {\n+    bool test __attribute__((unused)) = true;\n+    \n+    typedef std::deque<T>                         deque_type;\n+    typedef typename deque_type::iterator      iterator_type;\n+\n+    deque_type v(A, A + N);\n+\n+    iterator_type it0 = v.erase(v.begin() + 1, v.begin() + 4);\n+    VERIFY( it0 == v.begin() + 1 );\n+    VERIFY( v.size() == N0 );\n+    VERIFY( std::equal(v.begin(), v.end(), A0) );\n+    \n+    iterator_type it1 = v.erase(v.begin() + 1);\n+    VERIFY( it1 == v.begin() + 1 );\n+    VERIFY( v.size() == N1 );\n+    VERIFY( std::equal(v.begin(), v.end(), A1) );\n+    \n+    iterator_type it2 = v.erase(v.begin() + 4, v.begin() + 9);\n+    VERIFY( it2 == v.begin() + 4 );\n+    VERIFY( v.size() == N2 );\n+    VERIFY( std::equal(v.begin(), v.end(), A2) );\n+  \n+    iterator_type it3 = v.erase(v.begin() + 8, v.end());\n+    VERIFY( it3 == v.begin() + 8 );\n+    VERIFY( v.size() == N3 );\n+    VERIFY( std::equal(v.begin(), v.end(), A3) );\n+\n+    iterator_type it4 = v.erase(v.begin(), v.begin() + 3);\n+    VERIFY( it4 == v.begin() );\n+    VERIFY( v.size() == N4 );\n+    VERIFY( std::equal(v.begin(), v.end(), A4) );\n+    \n+    iterator_type it5 = v.erase(v.begin() + 2);\n+    VERIFY( it5 == v.begin() + 2 );\n+    VERIFY( v.size() == N5 );\n+    VERIFY( std::equal(v.begin(), v.end(), A5) );\n+\n+    iterator_type it6 = v.erase(v.begin() + 3, v.end());\n+    VERIFY( it6 == v.begin() + 3 );\n+    VERIFY( v.size() == N6 );\n+    VERIFY( std::equal(v.begin(), v.end(), A6) );\n+\n+    iterator_type it7 = v.erase(v.begin(), v.end());\n+    VERIFY( it7 == v.begin() );\n+    VERIFY( v.empty() );\n+  }\n+\n+int main()\n+{\n+  test01<My_class<1> >();\n+  test01<My_class<8> >();\n+  test01<My_class<32> >();\n+  return 0;\n+}"}]}