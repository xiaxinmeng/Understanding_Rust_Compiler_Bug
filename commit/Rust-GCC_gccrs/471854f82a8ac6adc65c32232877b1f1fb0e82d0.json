{"sha": "471854f82a8ac6adc65c32232877b1f1fb0e82d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcxODU0ZjgyYThhYzZhZGM2NWMzMjIzMjg3N2IxZjFmYjBlODJkMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-22T17:05:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-22T17:05:11Z"}, "message": "alias.c, [...]: Fix comment formatting.\n\n\t* alias.c, basic-block.h, cgraphunit.c, combine.c, domwalk.h,\n\tfinal.c, gengtype.c, genpreds.c, ggc-page.c, insn-notes.def,\n\tlambda-code.c, loop-unroll.c, modulo-sched.c, pointer-set.c,\n\tpretty-print.c, ra-colorize.c, sbitmap.c, tree-complex.c,\n\ttree-data-ref.c, tree-dfa.c, tree-inline.c, tree-into-ssa.c,\n\ttree-scalar-evolution.c, tree-ssa-dom.c,\n\ttree-ssa-loop-manip.c, tree-ssa-loop-niter.c,\n\ttree-ssa-phiopt.c, tree-ssa-pre.c, tree-ssa-threadupdate.c,\n\ttree-vectorizer.c, vec.h: Fix comment formatting.\n\nFrom-SVN: r89453", "tree": {"sha": "78237ea08ce69e2e4f29b80e8bf73c2c708305a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78237ea08ce69e2e4f29b80e8bf73c2c708305a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/471854f82a8ac6adc65c32232877b1f1fb0e82d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/471854f82a8ac6adc65c32232877b1f1fb0e82d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/471854f82a8ac6adc65c32232877b1f1fb0e82d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/471854f82a8ac6adc65c32232877b1f1fb0e82d0/comments", "author": null, "committer": null, "parents": [{"sha": "969def55395b4bb4f544419b64294257a68a154b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969def55395b4bb4f544419b64294257a68a154b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/969def55395b4bb4f544419b64294257a68a154b"}], "stats": {"total": 198, "additions": 105, "deletions": 93}, "files": [{"sha": "0c5445f42bc3294f0198738b679439c12a7955e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -1,3 +1,15 @@\n+2004-10-22  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* alias.c, basic-block.h, cgraphunit.c, combine.c, domwalk.h,\n+\tfinal.c, gengtype.c, genpreds.c, ggc-page.c, insn-notes.def,\n+\tlambda-code.c, loop-unroll.c, modulo-sched.c, pointer-set.c,\n+\tpretty-print.c, ra-colorize.c, sbitmap.c, tree-complex.c,\n+\ttree-data-ref.c, tree-dfa.c, tree-inline.c, tree-into-ssa.c,\n+\ttree-scalar-evolution.c, tree-ssa-dom.c,\n+\ttree-ssa-loop-manip.c, tree-ssa-loop-niter.c,\n+\ttree-ssa-phiopt.c, tree-ssa-pre.c, tree-ssa-threadupdate.c,\n+\ttree-vectorizer.c, vec.h: Fix comment formatting.\n+\n 2004-10-22  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* dwarf.h, gthr-dce.h, gthr-single.h, gthr-solaris.h, gthr.h,"}, {"sha": "49f2c6b11471241af00e91474e0f62ed7e8dc62d", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -482,7 +482,7 @@ get_alias_set (tree t)\n \t\t       type, then we would believe that other subsets\n \t\t       of the pointed-to type (such as fields of that\n \t\t       type) do not conflict with the type pointed to\n-\t\t       by the restricted pointer.   */\n+\t\t       by the restricted pointer.  */\n \t\t    DECL_POINTER_ALIAS_SET (decl)\n \t\t      = pointed_to_alias_set;\n \t\t  else"}, {"sha": "cb82fe15e3372143ca198f293e880d7fa8e578e8", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -567,7 +567,7 @@ ei_start_1 (VEC(edge) **ev)\n }\n \n /* Return an iterator pointing to the last element of an edge\n-   vector. */\n+   vector.  */\n static inline edge_iterator\n ei_last_1 (VEC(edge) **ev)\n {"}, {"sha": "3b0c5b66d0570d27337fedd654b88a318fe7bfcf", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -236,8 +236,8 @@ static FILE *cgraph_dump_file;\n static GTY((param1_is(tree), param2_is(tree)))\n      splay_tree static_vars_to_consider_by_tree;\n \n-/* FIXME -- PROFILE-RESTRUCTURE: change comment from DECL_UID to var-ann. */    \n-/* same as above but indexed by DECL_UID */\n+/* FIXME -- PROFILE-RESTRUCTURE: change comment from DECL_UID to var-ann.  */    \n+/* Same as above but indexed by DECL_UID.  */\n static GTY((param1_is(int), param2_is(tree)))\n      splay_tree static_vars_to_consider_by_uid;\n \n@@ -246,10 +246,10 @@ static GTY((param1_is(int), param2_is(tree)))\n    uid.  */\n static bitmap module_statics_escape;\n \n-/* FIXME -- PROFILE-RESTRUCTURE: change comment from DECL_UID to var-ann. */    \n+/* FIXME -- PROFILE-RESTRUCTURE: change comment from DECL_UID to var-ann.  */    \n /* A bit is set for every module static we are considering and is\n    indexed by DECL_UID.  This is ored into the local info when asm\n-   code is found that clobbers all memory. */\n+   code is found that clobbers all memory.  */\n static GTY(()) bitmap all_module_statics;\n \n /* Holds the value of \"memory\".  */\n@@ -344,7 +344,7 @@ print_order (const char * note, struct cgraph_node** order, int count)\n   fprintf (cgraph_dump_file, \"\\n\");\n }\n \n-/* FIXME -- PROFILE-RESTRUCTURE: Remove this function, it becomes a nop. */    \n+/* FIXME -- PROFILE-RESTRUCTURE: Remove this function, it becomes a nop.  */    \n /* Convert IN_DECL bitmap which is indexed by DECL_UID to IN_ANN, a\n    bitmap indexed by var_ann (VAR_DECL)->uid.  */\n \n@@ -411,7 +411,7 @@ new_static_vars_info(struct cgraph_node* node,\n \n \n /* FIXME -- PROFILE-RESTRUCTURE: Remove this function, it becomes a\n-   nop. */    \n+   nop.  */    \n /* The bitmaps used to represent the static global variables are\n    indexed by DECL_UID however, this is not used inside of functions\n    to index the ssa variables.  The denser var_ann (VAR_DECL)->uid is\n@@ -1218,7 +1218,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v)\n /* Topsort the call graph by caller relation.  Put the result in ORDER.\n \n    The REDUCE flag is true if you want the cycles reduced to single\n-   nodes.  Only consider nodes that have the output bit set. */\n+   nodes.  Only consider nodes that have the output bit set.  */\n \n static int\n cgraph_reduced_inorder (struct cgraph_node **order, bool reduce)\n@@ -2018,7 +2018,7 @@ cgraph_inline_p (struct cgraph_edge *e, const char **reason)\n /* FIXME this needs to be enhanced.  If we are compiling a single\n    module this returns true if the variable is a module level static,\n    but if we are doing whole program compilation, this could return\n-   true if TREE_PUBLIC is true. */\n+   true if TREE_PUBLIC is true.  */\n /* Return true if the variable T is the right kind of static variable to\n    perform compilation unit scope escape analysis.  */\n \n@@ -2045,7 +2045,7 @@ check_rhs_var (struct cgraph_node *fn, tree t)\n \t\t     lang_hooks.decl_printable_name (x, 2));\n \t  \n \t  /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n-\t     DECL_UID to get the uid from the var_ann field. */    \n+\t     DECL_UID to get the uid from the var_ann field.  */    \n \t  bitmap_set_bit (module_statics_escape, DECL_UID (x));\n \t}\n     }\n@@ -2057,7 +2057,7 @@ check_rhs_var (struct cgraph_node *fn, tree t)\n \tfprintf (cgraph_dump_file, \"\\nadding rhs:%s\",\n \t\t lang_hooks.decl_printable_name (t, 2));\n       /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n-\t DECL_UID to get the uid from the var_ann field. */    \n+\t DECL_UID to get the uid from the var_ann field.  */    \n       bitmap_set_bit (fn->static_vars_info->local->statics_read_by_decl_uid, \n \t\t      DECL_UID (t));\n     }\n@@ -2080,7 +2080,7 @@ check_lhs_var (struct cgraph_node *fn, tree t)\n \t\t lang_hooks.decl_printable_name (t, 2));\n       \n       /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n-\t DECL_UID to get the uid from the var_ann field. */    \n+\t DECL_UID to get the uid from the var_ann field.  */    \n       bitmap_set_bit (fn->static_vars_info->local->statics_written_by_decl_uid,\n \t\t      DECL_UID (t));\n     }\n@@ -2137,7 +2137,7 @@ get_asm_expr_operands (struct cgraph_node * fn, tree stmt)\n   for (link = ASM_CLOBBERS (stmt); link; link = TREE_CHAIN (link))\n     if (TREE_VALUE (link) == memory_identifier) \n       {\n-\t/* Abandon all hope, ye who enter here. */\n+\t/* Abandon all hope, ye who enter here.  */\n \tlocal_static_vars_info_t l = fn->static_vars_info->local;\n \tbitmap_a_or_b (l->statics_read_by_decl_uid,\n \t\t       l->statics_read_by_decl_uid,\n@@ -2184,7 +2184,7 @@ process_call_for_static_vars(struct cgraph_node * caller, tree call_expr)\n       tree callee_t = get_callee_fndecl (call_expr);\n       if (callee_t == NULL) \n \t{\n-\t  /* Indirect call. */\n+\t  /* Indirect call.  */\n \t  caller->local.calls_read_all = true;\n \t  caller->local.calls_write_all = true;\n \t}\n@@ -2225,10 +2225,10 @@ scan_for_static_refs (tree *tp,\n     {\n     case MODIFY_EXPR:\n       {\n-\t/* First look on the lhs and see what variable is stored to */\n+\t/* First look on the lhs and see what variable is stored to.  */\n \ttree rhs = TREE_OPERAND (t, 1);\n \tcheck_lhs_var (fn, TREE_OPERAND (t, 0));\n-\t/* Next check the operands on the rhs to see if they are ok. */\n+\t/* Next check the operands on the rhs to see if they are ok.  */\n \tswitch (TREE_CODE_CLASS (TREE_CODE (rhs))) {\n \tcase tcc_binary:\n \t  check_rhs_var (fn, TREE_OPERAND (rhs, 0));\n@@ -2302,7 +2302,7 @@ cgraph_characterize_statics_local (struct cgraph_node *fn)\n }\n \n /* Lookup the tree node for the static variable that has UID and\n-   conver the name to a string for debugging. */\n+   conver the name to a string for debugging.  */\n static const char *\n cgraph_get_static_name_by_uid (int index)\n {\n@@ -2397,7 +2397,7 @@ cgraph_characterize_statics (void)\n   struct cgraph_varpool_node *vnode;\n   tree global;\n \n-  /* get rid of the splay trees from the previous compilation unit. */\n+  /* Get rid of the splay trees from the previous compilation unit.  */\n   \n   static_vars_to_consider_by_tree =\n     splay_tree_new_ggc (splay_tree_compare_pointers);\n@@ -2415,7 +2415,7 @@ cgraph_characterize_statics (void)\n       all_module_statics = BITMAP_GGC_ALLOC ();\n     }\n \n-  /* Find all of the global variables that we wish to analyze. */\n+  /* Find all of the global variables that we wish to analyze.  */\n   for (vnode = cgraph_varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n     {\n       global = vnode->decl;\n@@ -2426,15 +2426,15 @@ cgraph_characterize_statics (void)\n \t\t\t     (splay_tree_key) global, \n \t\t\t     (splay_tree_value) global);\n \t  /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n-\t     DECL_UID to get the uid from the var_ann field. */    \n+\t     DECL_UID to get the uid from the var_ann field.  */    \n \t  splay_tree_insert (static_vars_to_consider_by_uid,\n \t\t\t     DECL_UID (global), (splay_tree_value)global);\n \t  \n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \"\\nConsidering global:%s\",\n \t\t     lang_hooks.decl_printable_name (global, 2));\n \t  /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n-\t     DECL_UID to get the uid from the var_ann field. */    \n+\t     DECL_UID to get the uid from the var_ann field.  */    \n \t  bitmap_set_bit (all_module_statics, DECL_UID (global));\n \t}\n     }\n@@ -2537,7 +2537,7 @@ cgraph_characterize_statics (void)\n       write_all = node->local.calls_write_all;\n \n       /* If any node in a cycle is calls_read_all or calls_write_all\n-\t they all are. */\n+\t they all are.  */\n       w = node->next_cycle;\n       while (w)\n \t{\n@@ -2639,7 +2639,7 @@ cgraph_characterize_statics (void)\n \t}\n     }\n \n-  /* Cleanup. */\n+  /* Cleanup.  */\n   for (i = order_pos - 1; i >= 0; i--)\n     {\n       static_vars_info_t node_info;"}, {"sha": "93c09905dfbad7fbd7c5429a486326ff779f1b7c", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -9027,7 +9027,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t     signbit', and attempt to change the PLUS to an XOR and move it to\n \t     the outer operation as is done above in the AND/IOR/XOR case\n \t     leg for shift(logical). See details in logical handling above\n-\t     for reasoning in doing so. */\n+\t     for reasoning in doing so.  */\n \t  if (code == LSHIFTRT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && mode_signbit_p (result_mode, XEXP (varop, 1))"}, {"sha": "b8f31f57eac69c5094914fbbad49d526fdaafac2", "filename": "gcc/domwalk.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -103,7 +103,7 @@ struct dom_walk_data\n   /* From here below are private data.  Please do not use this\n      information/data outside domwalk.c.  */\n \n-  /* Stack of available block local structures.   */\n+  /* Stack of available block local structures.  */\n   varray_type free_block_data;\n };\n "}, {"sha": "eb87bc7f6d89ba9de53d345ff798a6d57145e225", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -768,7 +768,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n   /* Compute maximum UID and allocate label_align / uid_shuid.  */\n   max_uid = get_max_uid ();\n \n-  /* Free uid_shuid before reallocating it.   */\n+  /* Free uid_shuid before reallocating it.  */\n   free (uid_shuid);\n   \n   uid_shuid = xmalloc (max_uid * sizeof *uid_shuid);"}, {"sha": "dd9ab097920857c3db50585d599f522125cf8201", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -3006,7 +3006,7 @@ main(int ARG_UNUSED (argc), char ** ARG_UNUSED (argv))\n         parse_file (all_files[i]);\n #ifndef USE_MAPPED_LOCATION\n       /* temporary kludge - gengtype doesn't handle conditionals.\n-\t Manually add source_locus *after* we've processed input.h. */\n+\t Manually add source_locus *after* we've processed input.h.  */\n       if (i == 0)\n \tdo_typedef (\"source_locus\", create_pointer (resolve_typedef (\"location_t\", &pos)), &pos);\n #endif"}, {"sha": "1eebc331c303252a32886441bfc5b1d09294605b", "filename": "gcc/genpreds.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -106,7 +106,7 @@ write_tm_preds_h (void)\n \t      (match_test \"basereg_operand_1 (op, mode)\")))\n \n    The only wart is that there's no way to insist on a { } string in\n-   an RTL template, so we have to handle \"\" strings. */\n+   an RTL template, so we have to handle \"\" strings.  */\n \n    \n static void\n@@ -288,7 +288,7 @@ add_mode_tests (struct pred_data *p)\n \t    if (test0 && test1)\n \t      /* Must put it on the dependent clause, not the\n \t      \t controlling expression, or we change the meaning of\n-\t      \t the test. */\n+\t      \t the test.  */\n \t      pos = &XEXP (subexp, 1);\n \t    else\n \t      pos = &XEXP (subexp, 2);"}, {"sha": "e0dfb1610d404fc26d734486d7623b16daaab0b9", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -459,7 +459,7 @@ static struct globals\n    allocation routines.  The first page is used, the rest go onto the\n    free list.  This cannot be larger than HOST_BITS_PER_INT for the\n    in_use bitmask for page_group.  Hosts that need a different value\n-   can override this by defining GGC_QUIRE_SIZE explicitly. */\n+   can override this by defining GGC_QUIRE_SIZE explicitly.  */\n #ifndef GGC_QUIRE_SIZE\n # ifdef USING_MMAP\n #  define GGC_QUIRE_SIZE 256"}, {"sha": "3894dda31289df8788aec7b7ae56402395f59321", "filename": "gcc/insn-notes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Finsn-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Finsn-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-notes.def?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -90,7 +90,7 @@ INSN_NOTE (BASIC_BLOCK)\n \n /* Record that the current basic block is unlikely to be executed and\n    should be moved to the UNLIKELY_EXECUTED_TEXT_SECTION.  FIXME: Make\n-   this a bit on the basic block structure. */\n+   this a bit on the basic block structure.  */\n INSN_NOTE (UNLIKELY_EXECUTED_CODE)\n \n #undef INSN_NOTE"}, {"sha": "4ff4859881f2ba571fd0dfc62309a5e9ab7ffcce", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -357,7 +357,7 @@ print_lambda_loopnest (FILE * outfile, lambda_loopnest nest, char start)\n }\n \n /* Allocate a new lattice structure of DEPTH x DEPTH, with INVARIANTS number\n-   of invariants.    */\n+   of invariants.  */\n \n static lambda_lattice\n lambda_lattice_new (int depth, int invariants)\n@@ -575,7 +575,7 @@ compute_nest_using_fourier_motzkin (int size,\n \t  else if (A[j][i] > 0)\n \t    {\n \t      /* Any linear expression with a coefficient greater than 0\n-\t\t becomes part of the new upper bound. */ \n+\t\t becomes part of the new upper bound.  */ \n \t      expression = lambda_linear_expression_new (depth, invariants);\n \t      for (k = 0; k < i; k++)\n \t\tLLE_COEFFICIENTS (expression)[k] = -1 * A[j][k];\n@@ -2008,7 +2008,7 @@ stmt_uses_phi_result (tree stmt, tree phi_result)\n   use_optype uses = STMT_USE_OPS (stmt);\n   \n   /* This is conservatively true, because we only want SIMPLE bumpers\n-     of the form x +- constant for our pass. */\n+     of the form x +- constant for our pass.  */\n   if (NUM_USES (uses) != 1)\n     return false;\n   if (USE_OP (uses, 0) == phi_result)\n@@ -2148,7 +2148,7 @@ replace_uses_of_x_with_y (tree stmt, tree x, tree y)\n     }\n }\n \n-/* Return TRUE if STMT uses tree OP in it's uses. */\n+/* Return TRUE if STMT uses tree OP in it's uses.  */\n \n static bool\n stmt_uses_op (tree stmt, tree op)\n@@ -2206,7 +2206,7 @@ can_convert_to_perfect_nest (struct loop *loop,\n \t\t  }\n \t      \n \t      /* If the bb of a statement we care about isn't dominated by \n-\t\t the header of the inner loop, then we are also screwed. */\n+\t\t the header of the inner loop, then we are also screwed.  */\n \t      if (!dominated_by_p (CDI_DOMINATORS,\n \t\t\t\t   bb_for_stmt (stmt), \n \t\t\t\t   loop->inner->header))"}, {"sha": "6b6181496162c31a0dd2f912dc9fa5b0d72b896e", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -89,7 +89,7 @@ struct iv_to_split\n struct var_to_expand\n {\n   rtx insn;\t\t           /* The insn in that the variable expansion occurs.  */\n-  rtx reg;                         /* The accumulator which is expanded. */\n+  rtx reg;                         /* The accumulator which is expanded.  */\n   varray_type var_expansions;      /* The copies of the accumulator which is expanded.  */ \n   enum rtx_code op;                /* The type of the accumulation - addition, subtraction \n                                       or multiplication.  */\n@@ -1453,7 +1453,7 @@ ve_info_hash (const void *ves)\n }\n \n /* Return true if IVTS1 and IVTS2 (which are really both of type \n-   \"var_to_expand *\") refer to the same instruction. */\n+   \"var_to_expand *\") refer to the same instruction.  */\n \n static int\n ve_info_eq (const void *ivts1, const void *ivts2)\n@@ -1464,7 +1464,7 @@ ve_info_eq (const void *ivts1, const void *ivts2)\n   return i1->insn == i2->insn;\n }\n \n-/* Returns true if REG is referenced in one insn in LOOP. */\n+/* Returns true if REG is referenced in one insn in LOOP.  */\n \n bool\n referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg)"}, {"sha": "b88ef12ea355f22723029d5f04730c2acd8b2900", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -1936,7 +1936,7 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n \n   /* Find the first must follow and the last must precede\n      and insert the node immediately after the must precede\n-     but make sure that it there is no must follow after it.   */\n+     but make sure that it there is no must follow after it.  */\n   for (next_ps_i = ps->rows[row];\n        next_ps_i;\n        next_ps_i = next_ps_i->next_in_row)"}, {"sha": "b0f04ff3aa3d6927151641a8afaf7dd57433a81f", "filename": "gcc/pointer-set.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fpointer-set.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fpointer-set.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-set.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -51,7 +51,7 @@ struct pointer_set_t\n \n    We don't need to do anything special for full-width multiplication\n    because we're only interested in the least significant word of the\n-   product, and unsigned arithmetic in C is modulo the word size. */\n+   product, and unsigned arithmetic in C is modulo the word size.  */\n \n static inline size_t\n hash1 (const void *p, unsigned long max, unsigned long logmax)\n@@ -69,7 +69,7 @@ hash1 (const void *p, unsigned long max, unsigned long logmax)\n   return ((A * (unsigned long) p) >> shift) & (max - 1);\n }\n \n-/* Allocate an empty pointer set. */\n+/* Allocate an empty pointer set.  */\n struct pointer_set_t *\n pointer_set_create (void)\n {\n@@ -83,7 +83,7 @@ pointer_set_create (void)\n   return result;\n }\n \n-/* Reclaims all memory associated with PSET. */\n+/* Reclaims all memory associated with PSET.  */\n void pointer_set_destroy (struct pointer_set_t *pset)\n {\n   XDELETEVEC (pset->slots);\n@@ -94,7 +94,7 @@ void pointer_set_destroy (struct pointer_set_t *pset)\n \n    Collisions are resolved by linear probing.  More complicated\n    collision management schemes are only useful when the load factor\n-   significantly exceeds 0.5, and we never let that happen. */\n+   significantly exceeds 0.5, and we never let that happen.  */\n int\n pointer_set_contains (struct pointer_set_t *pset, void *p)\n {\n@@ -117,7 +117,7 @@ pointer_set_contains (struct pointer_set_t *pset, void *p)\n \n /* Subroutine of pointer_set_insert.  Inserts P into an empty\n    element of SLOTS, an array of length N_SLOTS.  Returns nonzero\n-   if P was already present in N_SLOTS. */\n+   if P was already present in N_SLOTS.  */\n static int\n insert_aux (void *p, void **slots, size_t n_slots, size_t log_slots)\n {\n@@ -141,15 +141,15 @@ insert_aux (void *p, void **slots, size_t n_slots, size_t log_slots)\n }\n \n /* Inserts P into PSET if it wasn't already there.  Returns nonzero\n-   if it was already there. P must be nonnull. */\n+   if it was already there. P must be nonnull.  */\n int\n pointer_set_insert (struct pointer_set_t *pset, void *p)\n {\n   if (insert_aux (p, pset->slots, pset->n_slots, pset->log_slots))\n     return 1;\n       \n   /* We've inserted a new element.  Expand the table if necessary to keep\n-     the load factor small. */\n+     the load factor small.  */\n   ++pset->n_elements;\n   if (pset->n_elements > pset->n_slots / 4)\n     {"}, {"sha": "3a10e7600c6788c4f4064248a1b201901580a20c", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -607,7 +607,7 @@ pp_base_string (pretty_printer *pp, const char *str)\n   pp_maybe_wrap_text (pp, str, str + (str ? strlen (str) : 0));\n }\n \n-/* Maybe print out a whitespace if needed.   */\n+/* Maybe print out a whitespace if needed.  */\n \n void\n pp_base_maybe_space (pretty_printer *pp)"}, {"sha": "6d7980cc2b353b2b7ede0d2eacd2280e120d39af", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -247,7 +247,7 @@ reset_lists (void)\n     }\n \n #ifdef ENABLE_CHECKING\n-  /* Sanity check, that we only have free, initial or precolored webs. */\n+  /* Sanity check, that we only have free, initial or precolored webs.  */\n   {\n     unsigned int i;\n \n@@ -2493,7 +2493,7 @@ ok_class (struct web *target, struct web *source)\n      branch on count transformation (i.e. DoLoop) since the target, which\n      prefers the CTR, was being coalesced with a source which preferred\n      GENERAL_REGS. If only one web has a preferred class with 1 free reg\n-     then set it as the preferred color of the other web.   */\n+     then set it as the preferred color of the other web.  */\n   enum reg_class t_class, s_class;\n   t_class = reg_preferred_class (target->regno);\n   s_class = reg_preferred_class (source->regno);"}, {"sha": "b1e3c99efd8becad88e6cec589581ec6c3b4ee3d", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -103,7 +103,7 @@ sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n   return bmap;\n }\n \n-/* Re-allocate a simple bitmap of N_ELMS bits. New storage is uninitialized.   */\n+/* Re-allocate a simple bitmap of N_ELMS bits. New storage is uninitialized.  */\n \n sbitmap\n sbitmap_realloc (sbitmap src, unsigned int n_elms)"}, {"sha": "bfd74bdc8002f0d22b807463c1c24a08378d79e2", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -254,7 +254,7 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n   t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, min, ratio);\n   div = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, max);\n \n-  /* Result is now ((ar + ai*ratio)/div) + i((ai - ar*ratio)/div). */\n+  /* Result is now ((ar + ai*ratio)/div) + i((ai - ar*ratio)/div).  */\n   t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, ratio);\n   t2 = gimplify_build2 (bsi, PLUS_EXPR, inner_type, ar, t1);\n   rr = gimplify_build2 (bsi, code, inner_type, t2, div);"}, {"sha": "1ef964f240f84e009dbd6c9e4d2556f632248ad7", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -1457,7 +1457,7 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t  else\n \t\t    {\n \t\t      /* FIXME: For the moment, the upper bound of the\n-\t\t\t iteration domain for j is not checked. */\n+\t\t\t iteration domain for j is not checked.  */\n \t\t      *overlaps_a = chrec_dont_know;\n \t\t      *overlaps_b = chrec_dont_know;\n \t\t      *last_conflicts = chrec_dont_know;\n@@ -1467,7 +1467,7 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t      else\n \t\t{\n \t\t  /* FIXME: For the moment, the upper bound of the\n-\t\t     iteration domain for i is not checked. */\n+\t\t     iteration domain for i is not checked.  */\n \t\t  *overlaps_a = chrec_dont_know;\n \t\t  *overlaps_b = chrec_dont_know;\n \t\t  *last_conflicts = chrec_dont_know;"}, {"sha": "e86d21c8dfafb6171730124efe91c97a1c3381f0", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -189,7 +189,7 @@ compute_immediate_uses (int flags, bool (*calc_for)(tree))\n }\n \n \n-/* Invalidates dataflow information for a statement STMT.   */\n+/* Invalidates dataflow information for a statement STMT.  */\n \n void\n free_df_for_stmt (tree stmt)"}, {"sha": "f1d9c5a19ebdcb3bafde7082022fdebbbb56eab9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -889,7 +889,7 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n \t\t DECL_STRUCT_FUNCTION (caller)->unexpanded_var_list);\n \n   /* Do not have the rest of GCC warn about this variable as it should\n-     not be visible to the user.   */\n+     not be visible to the user.  */\n   TREE_NO_WARNING (var) = 1;\n \n   /* Build the use expr.  If the return type of the function was"}, {"sha": "972bec9e351f458c909b0ed1213da97aa7486e6d", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -770,7 +770,7 @@ ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n /* SSA Rewriting Step 3.  Visit all the successor blocks of BB looking for\n    PHI nodes.  For every PHI node found, add a new argument containing the\n    current reaching definition for the variable and the edge through which\n-   that definition is reaching the PHI node.   */\n+   that definition is reaching the PHI node.  */\n \n static void\n rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,"}, {"sha": "92f4436c46535d275d74a1e333eeeb3357b988d3", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -1049,7 +1049,7 @@ get_exit_conditions_rec (struct loop *loop,\n }\n \n /* Select the candidate loop nests for the analysis.  This function\n-   initializes the EXIT_CONDITIONS array.   */\n+   initializes the EXIT_CONDITIONS array.  */\n \n static void\n select_loops_exit_conditions (struct loops *loops, "}, {"sha": "c74537ca79bba5afcc288e7284559f6a252e2f11", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -201,7 +201,7 @@ struct vrp_element\n static htab_t vrp_data;\n \n /* An entry in the VRP_DATA hash table.  We record the variable and a\n-   varray of VRP_ELEMENT records associated with that variable.   */\n+   varray of VRP_ELEMENT records associated with that variable.  */\n \n struct vrp_hash_elt\n {\n@@ -404,7 +404,7 @@ tree_ssa_dominator_optimize (void)\n   /* And finalize the dominator walker.  */\n   fini_walk_dominator_tree (&walk_data);\n \n-  /* Free nonzero_vars.   */\n+  /* Free nonzero_vars.  */\n   BITMAP_XFREE (nonzero_vars);\n   BITMAP_XFREE (need_eh_cleanup);\n \n@@ -694,7 +694,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t  /* If we have a known destination for the conditional, then\n \t     we can perform this optimization, which saves at least one\n \t     conditional jump each time it applies since we get to\n-\t     bypass the conditional at our original destination.   */\n+\t     bypass the conditional at our original destination.  */\n \t  if (dest)\n \t    {\n \t      update_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n@@ -2312,7 +2312,7 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n     def = TREE_OPERAND (stmt, 0);\n \n   /* Certain expressions on the RHS can be optimized away, but can not\n-     themselves be entered into the hash tables.   */\n+     themselves be entered into the hash tables.  */\n   if (ann->makes_aliased_stores\n       || ! def\n       || TREE_CODE (def) != SSA_NAME\n@@ -3075,7 +3075,7 @@ get_eq_expr_value (tree if_stmt,\n   retval.dst = NULL;\n \n   /* If the conditional is a single variable 'X', return 'X = 1' for\n-     the true arm and 'X = 0' on the false arm.   */\n+     the true arm and 'X = 0' on the false arm.  */\n   if (TREE_CODE (cond) == SSA_NAME)\n     {\n       retval.dst = cond;"}, {"sha": "2dff13d8d58143f47a7d7df3ae53035deaca60c7", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -846,7 +846,7 @@ tree_ssa_loop_version (struct loops *loops, struct loop * loop,\n \n   /* At this point condition_bb is loop predheader with two successors, \n      first_head and second_head.   Make sure that loop predheader has only \n-     one successor. */\n+     one successor.  */\n   loop_split_edge_with (loop_preheader_edge (loop), NULL);\n   loop_split_edge_with (loop_preheader_edge (nloop), NULL);\n "}, {"sha": "b879b9e7a4c734783bb2faf859f38165d34d7e6f", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -54,7 +54,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n */\n \n /* Returns true if ARG is either NULL_TREE or constant zero.  Unlike\n-   integer_zerop, it does not care about overflow flags. */\n+   integer_zerop, it does not care about overflow flags.  */\n \n bool\n zero_p (tree arg)\n@@ -69,7 +69,7 @@ zero_p (tree arg)\n }\n \n /* Returns true if ARG a nonzero constant.  Unlike integer_nonzerop, it does\n-   not care about overflow flags. */\n+   not care about overflow flags.  */\n \n static bool\n nonzero_p (tree arg)"}, {"sha": "1d871d008733e986f30ad8ad4386b97a5b190be1", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -280,7 +280,7 @@ replace_phi_with_stmt (block_stmt_iterator bsi, basic_block bb,\n     conditional replacement.  Return true if the replacement is done.\n     Otherwise return false.\n     BB is the basic block where the replacement is going to be done on.  ARG0\n-    is argument 0 from PHI.  Likewise for ARG1.   */\n+    is argument 0 from PHI.  Likewise for ARG1.  */\n \n static bool\n conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n@@ -384,7 +384,7 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n \treturn false; \n \n       /* If what we get back is not gimple try to create it as gimple by\n-\t using a temporary variable.   */\n+\t using a temporary variable.  */\n       if (is_gimple_cast (cond)\n \t  && !is_gimple_val (TREE_OPERAND (cond, 0)))\n \t{\n@@ -413,7 +413,7 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     replacement.  Return true if the replacement is done.  Otherwise return\n     false.\n     BB is the basic block where the replacement is going to be done on.  ARG0\n-    is argument 0 from the PHI.  Likewise for ARG1.   */\n+    is argument 0 from the PHI.  Likewise for ARG1.  */\n \n static bool\n value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n@@ -425,7 +425,7 @@ value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   edge true_edge, false_edge;\n \n   /* If the type says honor signed zeros we cannot do this\n-     optimization.   */\n+     optimization.  */\n   if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n     return false;\n \n@@ -497,7 +497,7 @@ value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     replacement.  Return true if the replacement is done.  Otherwise return\n     false.\n     bb is the basic block where the replacement is going to be done on.  arg0\n-    is argument 0 from the phi.  Likewise for arg1.   */\n+    is argument 0 from the phi.  Likewise for arg1.  */\n static bool\n abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n {\n@@ -514,7 +514,7 @@ abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   enum tree_code cond_code;\n \n   /* If the type says honor signed zeros we cannot do this\n-     optimization.   */\n+     optimization.  */\n   if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n     return false;\n \n@@ -584,7 +584,7 @@ abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n       && cond_code != LT_EXPR && cond_code != LE_EXPR)\n     return false;\n \n-  /* Make sure the conditional is arg[01] OP y.   */\n+  /* Make sure the conditional is arg[01] OP y.  */\n   if (TREE_OPERAND (cond, 0) != rhs)\n     return false;\n \n@@ -617,7 +617,7 @@ abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   else\n     lhs = result;\n \n-  /*  Build the modify expression with abs expression.   */\n+  /* Build the modify expression with abs expression.  */\n   new = build (MODIFY_EXPR, TREE_TYPE (lhs),\n                lhs, build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n "}, {"sha": "6a7b620fcb27501392b4aeff40511b5822ca7a48", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -363,7 +363,7 @@ expr_pred_trans_eq (const void *p1, const void *p2)\n     return false;\n \n   /* If they are for the same basic block, determine if the\n-     expressions are equal.   */  \n+     expressions are equal.  */  \n   if (expressions_equal_p (ve1->e, ve2->e))\n     return true;\n   \n@@ -866,7 +866,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n     case tcc_reference:\n-      /* XXX: Until we have PRE of loads working, none will be ANTIC. */\n+      /* XXX: Until we have PRE of loads working, none will be ANTIC.  */\n       return NULL;\n \n     case tcc_binary:"}, {"sha": "3f4f5d57774f00dd3390f1cd0bbfc6694f8a8e0e", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -422,7 +422,7 @@ thread_block (basic_block bb)\n    It is the caller's responsibility to fix the dominance information\n    and rewrite duplicated SSA_NAMEs back into SSA form.\n \n-   Returns true if one or more edges were threaded, false otherwise.   */\n+   Returns true if one or more edges were threaded, false otherwise.  */\n \n bool\n thread_through_all_blocks (void)"}, {"sha": "656c612e29286b34395e9dcee905248981592d87", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -616,7 +616,7 @@ make_loop_iterate_ntimes (struct loop *loop, tree niters,\n \n   if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n     cond = build2 (GE_EXPR, boolean_type_node, indx_after_incr, niters);\n-  else /* 'then' edge loops back.   */\n+  else /* 'then' edge loops back.  */\n     cond = build2 (LT_EXPR, boolean_type_node, indx_after_incr, niters);\n \n   begin_label = build1 (GOTO_EXPR, void_type_node, begin_label);\n@@ -800,7 +800,7 @@ verify_loop_for_duplication (struct loop *loop,\n       return false;\n     }\n \n-  /* Only loops with 1 exit. */\n+  /* Only loops with 1 exit.  */\n   if (loop->num_exits != 1)\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n@@ -809,7 +809,7 @@ verify_loop_for_duplication (struct loop *loop,\n       return false;\n     }\n \n-  /* Only loops with 1 entry. */\n+  /* Only loops with 1 entry.  */\n   if (loop->num_entries != 1)\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n@@ -1578,7 +1578,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   tree dest, new_stmt;\n \n   /* Only the access function of the last index is relevant (i_n in\n-     a[i_1][i_2]...[i_n]), the others correspond to loop invariants. */\n+     a[i_1][i_2]...[i_n]), the others correspond to loop invariants.  */\n   access_fn = DR_ACCESS_FN (dr, 0);\n   ok = vect_is_simple_iv_evolution (loop->num, access_fn, &init_oval, &step, \n \t\t\t\t    true);\n@@ -2705,7 +2705,7 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo, tree *ni_name_p,\n   ni_name = vect_build_loop_niters (loop_vinfo);\n \n   /* ratio = ni / vf.\n-     vf is power of 2; then if ratio =  = n >> log2 (vf).   */\n+     vf is power of 2; then if ratio =  = n >> log2 (vf).  */\n   vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   ratio = vect_build_symbol_bound (ni_name, vf, loop);\n        \n@@ -2760,7 +2760,7 @@ vect_build_symbol_bound (tree n, int vf, struct loop * loop)\n \n   var_name = make_ssa_name (var, NULL_TREE);\n \n-  /* vf is power of 2; then n/vf = n >> log2 (vf).   */\n+  /* vf is power of 2; then n/vf = n >> log2 (vf).  */\n \n   i = exact_log2 (vf);\n   stmt = build2 (MODIFY_EXPR, void_type_node, var_name,\n@@ -2834,7 +2834,7 @@ vect_transform_loop_bound (loop_vec_info loop_vinfo, tree niters)\n   if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n     cond = build2 (GE_EXPR, boolean_type_node, \n \t\t   indx_after_incr, new_loop_bound);\n-  else /* 'then' edge loops back.   */\n+  else /* 'then' edge loops back.  */\n     cond = build2 (LT_EXPR, boolean_type_node, \n \t\t   indx_after_incr, new_loop_bound);\n \n@@ -3818,7 +3818,7 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n    exist any data dependences between them.\n \n    TODO: dependences which distance is greater than the vectorization factor\n-         can be ignored.   */\n+         can be ignored.  */\n \n static bool\n vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n@@ -4067,7 +4067,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr,\n           fprintf (dump_file, \" scalar_type: \");\n           print_generic_expr (dump_file, scalar_type, TDF_DETAILS);\n         }\n-      /* It is not possible to vectorize this data reference. */\n+      /* It is not possible to vectorize this data reference.  */\n       return false;\n     }\n   gcc_assert (TREE_CODE (ref) == ARRAY_REF || TREE_CODE (ref) == INDIRECT_REF);\n@@ -4184,7 +4184,7 @@ vect_compute_array_ref_alignment (struct data_reference *dr,\n   tree nbits;\n \n   if (TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n-    /* The reference is an array without its last index. */\n+    /* The reference is an array without its last index.  */\n     next_ref = vect_compute_array_base_alignment (ref, vectype, &dims, \n \t\t\t\t\t\t  &misalign);\n   else\n@@ -4495,7 +4495,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t\t\t\t      loop_containing_stmt (DR_STMT (dr))->num))\n \t{\n \t  /* Evolution part is not NULL in this loop (it is neither constant \n-\t     nor invariant). */\n+\t     nor invariant).  */\n \t  if (vect_debug_details (NULL))\n \t    {\n \t      fprintf (dump_file, \n@@ -4579,7 +4579,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n    MEMREF - a data-ref in STMT, which is an INDIRECT_REF.\n \n    If the data-ref access is vectorizable, return a data_reference structure\n-   that represents it (DR). Otherwise - return NULL.   */\n+   that represents it (DR). Otherwise - return NULL.  */\n \n static struct data_reference *\n vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n@@ -4751,7 +4751,7 @@ vect_get_symbl_and_dr (tree memref, tree stmt, bool is_read,\n       /* Store the array base in the stmt info. \n \t For one dimensional array ref a[i], the base is a,\n \t for multidimensional a[i1][i2]..[iN], the base is \n-\t a[i1][i2]..[iN-1]. */\n+\t a[i1][i2]..[iN-1].  */\n       array_base = TREE_OPERAND (memref, 0);\n       STMT_VINFO_VECT_DR_BASE (stmt_info) = array_base;\t     \n \n@@ -4809,7 +4809,7 @@ vect_get_symbl_and_dr (tree memref, tree stmt, bool is_read,\n \n    FORNOW: Handle aligned INDIRECT_REFs and ARRAY_REFs \n \t   which base is really an array (not a pointer) and which alignment \n-\t   can be forced. This restriction will be relaxed.   */\n+\t   can be forced. This restriction will be relaxed.  */\n \n static bool\n vect_analyze_data_refs (loop_vec_info loop_vinfo)"}, {"sha": "945a4137f6b172e4e872709e1b3735fb2b9364cc", "filename": "gcc/vec.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471854f82a8ac6adc65c32232877b1f1fb0e82d0/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=471854f82a8ac6adc65c32232877b1f1fb0e82d0", "patch": "@@ -323,7 +323,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    \n    Find the first position in which VAL could be inserted without\n    changing the ordering of V.  LESSTHAN is a function that returns\n-   true if the first argument is strictly less than the second.   */\n+   true if the first argument is strictly less than the second.  */\n    \n #define VEC_lower_bound(TDEF,V,O,LT)    \\\n        (VEC_OP(TDEF,lower_bound)(V,O,LT VEC_CHECK_INFO))"}]}