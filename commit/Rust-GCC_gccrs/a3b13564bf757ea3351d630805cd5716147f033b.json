{"sha": "a3b13564bf757ea3351d630805cd5716147f033b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNiMTM1NjRiZjc1N2VhMzM1MWQ2MzA4MDVjZDU3MTYxNDdmMDMzYg==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@gmail.com", "date": "2018-04-05T02:51:45Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-04-05T02:51:45Z"}, "message": "[NDS32] Refine bit-wise operation and shift patterns.\n\ngcc/\n\t* config/nds32/iterators.md (shift_rotate): New code iterator.\n\t(shift): New code attribute.\n\t* config/nds32/nds32-md-auxiliary.c (nds32_expand_constant): New.\n\t* config/nds32/nds32-protos.h (nds32_expand_constant): Declare.\n\t* config/nds32/nds32.c (nds32_print_operand): Deal with more cases.\n\t* config/nds32/nds32.md (addsi3, *add_srli): Refine implementation for\n\tbit-wise operations.\n\t(andsi3, *andsi3): Ditto.\n\t(iorsi3, *iorsi3, *or_slli, *or_srli): Ditto.\n\t(xorsi3, *xorsi3, *xor_slli, *xor_srli): Ditto.\n\t(<shift>si3, *ashlsi3, *ashrsi3, *lshrsi3, *rotrsi3): Ditto.\n\t* config/nds32/predicates.md (nds32_rimm5u_operand, nds32_and_operand,\n\tnds32_ior_operand, nds32_xor_operand): New predicates.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r259117", "tree": {"sha": "0bef54daf5c4fb2485e0d330051132490bcbc1a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bef54daf5c4fb2485e0d330051132490bcbc1a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3b13564bf757ea3351d630805cd5716147f033b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b13564bf757ea3351d630805cd5716147f033b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b13564bf757ea3351d630805cd5716147f033b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b13564bf757ea3351d630805cd5716147f033b/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c36be57336c5d4c3b989e9be5bbe060a0deba12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c36be57336c5d4c3b989e9be5bbe060a0deba12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c36be57336c5d4c3b989e9be5bbe060a0deba12"}], "stats": {"total": 353, "additions": 242, "deletions": 111}, "files": [{"sha": "19ea1ab7f628e077e8085efe32c04418edcce331", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3b13564bf757ea3351d630805cd5716147f033b", "patch": "@@ -1,3 +1,20 @@\n+2018-04-05  Kito Cheng  <kito.cheng@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/iterators.md (shift_rotate): New code iterator.\n+\t(shift): New code attribute.\n+\t* config/nds32/nds32-md-auxiliary.c (nds32_expand_constant): New.\n+\t* config/nds32/nds32-protos.h (nds32_expand_constant): Declare.\n+\t* config/nds32/nds32.c (nds32_print_operand): Deal with more cases.\n+\t* config/nds32/nds32.md (addsi3, *add_srli): Refine implementation for\n+\tbit-wise operations.\n+\t(andsi3, *andsi3): Ditto.\n+\t(iorsi3, *iorsi3, *or_slli, *or_srli): Ditto.\n+\t(xorsi3, *xorsi3, *xor_slli, *xor_srli): Ditto.\n+\t(<shift>si3, *ashlsi3, *ashrsi3, *lshrsi3, *rotrsi3): Ditto.\n+\t* config/nds32/predicates.md (nds32_rimm5u_operand, nds32_and_operand,\n+\tnds32_ior_operand, nds32_xor_operand): New predicates.\n+\n 2018-04-05  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32.md (add<mode>3, sub<mode>3): Rename to ..."}, {"sha": "e0798ff812f7a384ebd37fceea6a46ce9129d81e", "filename": "gcc/config/nds32/iterators.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fiterators.md?ref=a3b13564bf757ea3351d630805cd5716147f033b", "patch": "@@ -61,10 +61,16 @@\n ;; Code iterators.\n ;;----------------------------------------------------------------------------\n \n+;; shifts\n+(define_code_iterator shift_rotate [ashift ashiftrt lshiftrt rotatert])\n \n ;;----------------------------------------------------------------------------\n ;; Code attributes.\n ;;----------------------------------------------------------------------------\n \n+;; shifts\n+(define_code_attr shift\n+  [(ashift \"ashl\") (ashiftrt \"ashr\") (lshiftrt \"lshr\") (rotatert \"rotr\")])\n+\n \n ;;----------------------------------------------------------------------------"}, {"sha": "607bcc212113b1dc2a0d6532c15816b542d156ca", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=a3b13564bf757ea3351d630805cd5716147f033b", "patch": "@@ -2111,3 +2111,49 @@ nds32_long_call_p (rtx symbol)\n {\n   return TARGET_CMODEL_LARGE;\n }\n+\n+void\n+nds32_expand_constant (machine_mode mode, HOST_WIDE_INT val,\n+\t\t       rtx target, rtx source)\n+{\n+  rtx temp = gen_reg_rtx (mode);\n+  int clear_sign_bit_copies = 0;\n+  int clear_zero_bit_copies = 0;\n+  unsigned HOST_WIDE_INT remainder = val & 0xffffffffUL;\n+\n+  /* Count number of leading zeros.  */\n+  clear_sign_bit_copies =  __builtin_clz (remainder);\n+  /* Count number of trailing zeros.  */\n+  clear_zero_bit_copies = __builtin_ctz (remainder);\n+\n+  HOST_WIDE_INT sign_shift_mask = ((0xffffffffUL\n+\t\t\t\t    << (32 - clear_sign_bit_copies))\n+\t\t\t\t   & 0xffffffffUL);\n+  HOST_WIDE_INT zero_shift_mask = (1 << clear_zero_bit_copies) - 1;\n+\n+  if (clear_sign_bit_copies > 0 && clear_sign_bit_copies < 17\n+      && (remainder | sign_shift_mask) == 0xffffffffUL)\n+    {\n+      /* Transfer AND to two shifts, example:\n+\t a = b & 0x7fffffff => (b << 1) >> 1 */\n+      rtx shift = GEN_INT (clear_sign_bit_copies);\n+\n+      emit_insn (gen_ashlsi3 (temp, source, shift));\n+      emit_insn (gen_lshrsi3 (target, temp, shift));\n+    }\n+  else if (clear_zero_bit_copies > 0 && clear_sign_bit_copies < 17\n+\t   && (remainder | zero_shift_mask) == 0xffffffffUL)\n+    {\n+      /* Transfer AND to two shifts, example:\n+\t a = b & 0xfff00000 => (b >> 20) << 20 */\n+      rtx shift = GEN_INT (clear_zero_bit_copies);\n+\n+      emit_insn (gen_lshrsi3 (temp, source, shift));\n+      emit_insn (gen_ashlsi3 (target, temp, shift));\n+    }\n+  else\n+    {\n+      emit_move_insn (temp, GEN_INT (val));\n+      emit_move_insn (target, gen_rtx_fmt_ee (AND, mode, source, temp));\n+    }\n+}"}, {"sha": "42f8dd9d762ca8b27714a7f183724bb9f6a80db9", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=a3b13564bf757ea3351d630805cd5716147f033b", "patch": "@@ -154,6 +154,11 @@ extern const char *nds32_output_cbranchsi4_greater_less_zero (rtx_insn *, rtx *)\n extern const char *nds32_output_stack_push (rtx);\n extern const char *nds32_output_stack_pop (rtx);\n \n+/* Auxiliary functions to split large constant RTX pattern.  */\n+\n+extern void nds32_expand_constant (machine_mode,\n+\t\t\t\t   HOST_WIDE_INT, rtx, rtx);\n+\n /* Auxiliary functions to check using return with null epilogue.  */\n \n extern int nds32_can_use_return_insn (void);"}, {"sha": "74ff621664f0440efb43556bac06127bcea59bed", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=a3b13564bf757ea3351d630805cd5716147f033b", "patch": "@@ -2402,6 +2402,8 @@ nds32_asm_globalize_label (FILE *stream, const char *name)\n static void\n nds32_print_operand (FILE *stream, rtx x, int code)\n {\n+  HOST_WIDE_INT one_position;\n+  HOST_WIDE_INT zero_position;\n   int op_value;\n \n   switch (code)\n@@ -2410,6 +2412,26 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n       /* Do nothing special.  */\n       break;\n \n+    case 'b':\n+      /* Use exact_log2() to search the 0-bit position.  */\n+      gcc_assert (CONST_INT_P (x));\n+      zero_position = exact_log2 (~UINTVAL (x) & GET_MODE_MASK (SImode));\n+      gcc_assert (zero_position != -1);\n+      fprintf (stream, HOST_WIDE_INT_PRINT_DEC, zero_position);\n+\n+      /* No need to handle following process, so return immediately.  */\n+      return;\n+\n+    case 'B':\n+      /* Use exact_log2() to search the 1-bit position.  */\n+      gcc_assert (CONST_INT_P (x));\n+      one_position = exact_log2 (UINTVAL (x) & GET_MODE_MASK (SImode));\n+      gcc_assert (one_position != -1);\n+      fprintf (stream, HOST_WIDE_INT_PRINT_DEC, one_position);\n+\n+      /* No need to handle following process, so return immediately.  */\n+      return;\n+\n     case 'V':\n       /* 'x' is supposed to be CONST_INT, get the value.  */\n       gcc_assert (CONST_INT_P (x));"}, {"sha": "b7c82b6979870177820c10e5f7fe0b38e7cb270d", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 108, "deletions": 111, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=a3b13564bf757ea3351d630805cd5716147f033b", "patch": "@@ -323,7 +323,7 @@\n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"               \"=   d,   l,   d,   l, d, l,   k,   l,    r, r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\"      \"%   0,   l,   0,   l, 0, l,   0,   k,    r, r\")\n-\t\t (match_operand:SI 2 \"nds32_rimm15s_operand\" \" In05,In03,Iu05,Iu03, r, l,Is10,IU06, Is15, r\")))]\n+\t\t (match_operand:SI 2 \"nds32_rimm15s_operand\" \" In05,In03,Iu05,Iu03, r, l,Is10,Iu06, Is15, r\")))]\n   \"\"\n {\n   switch (which_alternative)\n@@ -400,10 +400,10 @@\n    (set_attr \"length\"       \"4\")])\n \n (define_insn \"*add_srli\"\n-  [(set (match_operand:SI 0 \"register_operand\"                        \"=   r\")\n-\t(plus:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"    r\")\n-\t\t\t      (match_operand:SI 2 \"immediate_operand\" \" Iu05\"))\n-\t\t (match_operand:SI 3 \"register_operand\"               \"    r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                          \"=   r\")\n+\t(plus:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\"    \"    r\")\n+\t\t\t      (match_operand:SI 2 \"nds32_imm5u_operand\" \" Iu05\"))\n+\t\t (match_operand:SI 3 \"register_operand\"                 \"    r\")))]\n   \"TARGET_ISA_V3\"\n   \"add_srli\\t%0, %3, %1, %2\"\n   [(set_attr \"type\" \"alu_shift\")\n@@ -555,14 +555,28 @@\n    (set_attr \"length\" \"4\")]\n )\n \n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"         \"=w, r,    l,    l,    l,    l,    l,    l,    r,   r,     r,    r,    r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0, r,    l,    l,    l,    l,    0,    0,    r,   r,     r,    r,    r\")\n-\t\t(match_operand:SI 2 \"general_operand\"  \" w, r, Izeb, Izeh, Ixls, Ix11, Ibms, Ifex, Izeb, Izeh, Iu15, Ii15, Ic15\")))]\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"nds32_reg_constant_operand\" \"\")))]\n+  \"\"\n+{\n+  if (CONST_INT_P (operands[2])\n+      && !nds32_and_operand (operands[2], SImode))\n+    {\n+      nds32_expand_constant (SImode, INTVAL (operands[2]),\n+\t\t\t     operands[0], operands[1]);\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=l, r,   l,   l,   l,   l,   l,   l,    r,   r,     r,    r,    r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\"  \"%0, r,   l,   l,   l,   l,   0,   0,    r,   r,     r,    r,    r\")\n+\t\t(match_operand:SI 2 \"nds32_and_operand\" \" l, r,Izeb,Izeh,Ixls,Ix11,Ibms,Ifex, Izeb, Izeh, Iu15, Ii15, Ic15\")))]\n   \"\"\n {\n   HOST_WIDE_INT mask = INTVAL (operands[2]);\n-  int zero_position;\n \n   /* 16-bit andi instructions:\n      andi Rt3,Ra3,0xff   -> zeb33  Rt3,Ra3\n@@ -587,8 +601,7 @@\n     case 5:\n       return \"x11b33\\t%0, %1\";\n     case 6:\n-      operands[2] = GEN_INT (floor_log2 (mask));\n-      return \"bmski33\\t%0, %2\";\n+      return \"bmski33\\t%0, %B2\";\n     case 7:\n       operands[2] = GEN_INT (floor_log2 (mask + 1) - 1);\n       return \"fexti33\\t%0, %2\";\n@@ -602,20 +615,7 @@\n       operands[2] = GEN_INT (~mask);\n       return \"bitci\\t%0, %1, %2\";\n     case 12:\n-      /* If we reach this alternative,\n-         it must pass the nds32_can_use_bclr_p() test,\n-         so that we can guarantee there is only one 0-bit\n-         within the immediate value.  */\n-      for (zero_position = 31; zero_position >= 0; zero_position--)\n-\t{\n-\t  if ((INTVAL (operands[2]) & (1 << zero_position)) == 0)\n-\t    {\n-\t      /* Found the 0-bit position.  */\n-\t      operands[2] = GEN_INT (zero_position);\n-\t      break;\n-\t    }\n-\t}\n-      return \"bclr\\t%0, %1, %2\";\n+      return \"bclr\\t%0, %1, %b2\";\n \n     default:\n       gcc_unreachable ();\n@@ -652,54 +652,46 @@\n \n ;; For V3/V3M ISA, we have 'or33' instruction.\n ;; So we can identify 'or Rt3,Rt3,Ra3' case and set its length to be 2.\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"         \"=w, r,    r,    r\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0, r,    r,    r\")\n-\t\t(match_operand:SI 2 \"general_operand\"  \" w, r, Iu15, Ie15\")))]\n+\n+(define_expand \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_operand\"  \"\")))]\n   \"\"\n {\n-  int one_position;\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"or33\\t%0, %2\";\n-    case 1:\n-      return \"or\\t%0, %1, %2\";\n-    case 2:\n-      return \"ori\\t%0, %1, %2\";\n-    case 3:\n-      /* If we reach this alternative,\n-         it must pass the nds32_can_use_bset_p() test,\n-         so that we can guarantee there is only one 1-bit\n-         within the immediate value.  */\n-      /* Use exact_log2() to search the 1-bit position.  */\n-      one_position = exact_log2 (INTVAL (operands[2]));\n-      operands[2] = GEN_INT (one_position);\n-      return \"bset\\t%0, %1, %2\";\n+  if (!nds32_ior_operand (operands[2], SImode))\n+    operands[2] = force_reg (SImode, operands[2]);\n+})\n \n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\"   \"alu,alu,alu,alu\")\n-   (set_attr \"length\" \"  2,  4,  4,  4\")])\n+(define_insn \"*iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=l, r,    r,    r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\"  \"%0, r,    r,    r\")\n+\t\t(match_operand:SI 2 \"nds32_ior_operand\" \" l, r, Iu15, Ie15\")))]\n+  \"\"\n+  \"@\n+   or33\\t%0, %2\n+   or\\t%0, %1, %2\n+   ori\\t%0, %1, %2\n+   bset\\t%0, %1, %B2\"\n+  [(set_attr \"type\"    \"alu,alu,alu,alu\")\n+   (set_attr \"length\"  \"  2,  4,  4,  4\")\n+   (set_attr \"feature\" \"v3m, v1, v1,pe1\")])\n \n (define_insn \"*or_slli\"\n-  [(set (match_operand:SI 0 \"register_operand\"                     \"=   r\")\n-\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\"  \"    r\")\n-\t\t\t   (match_operand:SI 2 \"immediate_operand\" \" Iu05\"))\n-\t\t(match_operand:SI 3 \"register_operand\"             \"    r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                       \"=   r\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\"    \"    r\")\n+\t\t\t   (match_operand:SI 2 \"nds32_imm5u_operand\" \" Iu05\"))\n+\t\t(match_operand:SI 3 \"register_operand\"               \"    r\")))]\n   \"TARGET_ISA_V3\"\n   \"or_slli\\t%0, %3, %1, %2\"\n   [(set_attr \"type\" \"alu_shift\")\n    (set_attr \"length\"       \"4\")])\n \n (define_insn \"*or_srli\"\n-  [(set (match_operand:SI 0 \"register_operand\"                       \"=   r\")\n-\t(ior:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"    r\")\n-\t\t\t     (match_operand:SI 2 \"immediate_operand\" \" Iu05\"))\n-\t\t(match_operand:SI 3 \"register_operand\"               \"    r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                         \"=   r\")\n+\t(ior:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\"    \"    r\")\n+\t\t\t     (match_operand:SI 2 \"nds32_imm5u_operand\" \" Iu05\"))\n+\t\t(match_operand:SI 3 \"register_operand\"                 \"    r\")))]\n   \"TARGET_ISA_V3\"\n   \"or_srli\\t%0, %3, %1, %2\"\n   [(set_attr \"type\" \"alu_shift\")\n@@ -712,66 +704,57 @@\n \n ;; For V3/V3M ISA, we have 'xor33' instruction.\n ;; So we can identify 'xor Rt3,Rt3,Ra3' case and set its length to be 2.\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"         \"=w, r,    r,    r\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0, r,    r,    r\")\n-\t\t(match_operand:SI 2 \"general_operand\"  \" w, r, Iu15, It15\")))]\n+\n+(define_expand \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_operand\"  \"\")))]\n   \"\"\n {\n-  int one_position;\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"xor33\\t%0, %2\";\n-    case 1:\n-      return \"xor\\t%0, %1, %2\";\n-    case 2:\n-      return \"xori\\t%0, %1, %2\";\n-    case 3:\n-      /* If we reach this alternative,\n-         it must pass the nds32_can_use_btgl_p() test,\n-         so that we can guarantee there is only one 1-bit\n-         within the immediate value.  */\n-      /* Use exact_log2() to search the 1-bit position.  */\n-      one_position = exact_log2 (INTVAL (operands[2]));\n-      operands[2] = GEN_INT (one_position);\n-      return \"btgl\\t%0, %1, %2\";\n+  if (!nds32_xor_operand (operands[2], SImode))\n+    operands[2] = force_reg (SImode, operands[2]);\n+})\n \n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n+(define_insn \"*xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=l, r,    r,    r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\"  \"%0, r,    r,    r\")\n+\t\t(match_operand:SI 2 \"nds32_xor_operand\" \" l, r, Iu15, It15\")))]\n+  \"\"\n+  \"@\n+   xor33\\t%0, %2\n+   xor\\t%0, %1, %2\n+   xori\\t%0, %1, %2\n+   btgl\\t%0, %1, %B2\"\n   [(set_attr \"type\"    \"alu,alu,alu,alu\")\n    (set_attr \"length\"  \"  2,  4,  4,  4\")\n    (set_attr \"feature\" \"v3m, v1, v1,pe1\")])\n \n (define_insn \"*xor_slli\"\n   [(set (match_operand:SI 0 \"register_operand\"                     \"=   r\")\n \t(xor:SI (ashift:SI (match_operand:SI 1 \"register_operand\"  \"    r\")\n-\t\t\t   (match_operand:SI 2 \"immediate_operand\" \" Iu05\"))\n+\t\t\t   (match_operand:SI 2 \"nds32_imm5u_operand\" \" Iu05\"))\n \t\t(match_operand:SI 3 \"register_operand\"             \"    r\")))]\n   \"TARGET_ISA_V3\"\n   \"xor_slli\\t%0, %3, %1, %2\"\n   [(set_attr \"type\" \"alu_shift\")\n    (set_attr \"length\"       \"4\")])\n \n (define_insn \"*xor_srli\"\n-  [(set (match_operand:SI 0 \"register_operand\"                       \"=   r\")\n-\t(xor:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"    r\")\n-\t\t\t     (match_operand:SI 2 \"immediate_operand\" \" Iu05\"))\n-\t\t(match_operand:SI 3 \"register_operand\"               \"    r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                         \"=   r\")\n+\t(xor:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\"    \"    r\")\n+\t\t\t     (match_operand:SI 2 \"nds32_imm5u_operand\" \" Iu05\"))\n+\t\t(match_operand:SI 3 \"register_operand\"                 \"    r\")))]\n   \"TARGET_ISA_V3\"\n   \"xor_srli\\t%0, %3, %1, %2\"\n   [(set_attr \"type\" \"alu_shift\")\n    (set_attr \"length\"       \"4\")])\n \n ;; Rotate Right Instructions.\n \n-(define_insn \"rotrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"                 \"=   r, r\")\n-\t  (rotatert:SI (match_operand:SI 1 \"register_operand\"  \"    r, r\")\n-\t\t       (match_operand:SI 2 \"nonmemory_operand\" \" Iu05, r\")))]\n+(define_insn \"*rotrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                    \"=   r, r\")\n+\t  (rotatert:SI (match_operand:SI 1 \"register_operand\"     \"    r, r\")\n+\t\t       (match_operand:SI 2 \"nds32_rimm5u_operand\" \" Iu05, r\")))]\n   \"\"\n   \"@\n    rotri\\t%0, %1, %2\n@@ -822,10 +805,23 @@\n \n ;; Shift instructions.\n \n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"             \"=   l,    r, r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\"  \"    l,    r, r\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \" Iu03, Iu05, r\")))]\n+(define_expand \"<shift>si3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                      \"\")\n+\t(shift_rotate:SI (match_operand:SI 1 \"register_operand\"     \"\")\n+\t\t\t (match_operand:SI 2 \"nds32_rimm5u_operand\" \"\")))]\n+  \"\"\n+{\n+  if (operands[2] == const0_rtx)\n+    {\n+      emit_move_insn (operands[0], operands[1]);\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=   l,    r, r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\"     \"    l,    r, r\")\n+\t\t   (match_operand:SI 2 \"nds32_rimm5u_operand\" \" Iu03, Iu05, r\")))]\n   \"\"\n   \"@\n    slli333\\t%0, %1, %2\n@@ -834,10 +830,11 @@\n   [(set_attr \"type\"    \"  alu,  alu,  alu\")\n    (set_attr \"subtype\" \"shift,shift,shift\")\n    (set_attr \"length\"  \"    2,    4,    4\")])\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"               \"=   d,    r, r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"    0,    r, r\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \" Iu05, Iu05, r\")))]\n+\n+(define_insn \"*ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                  \"=   d,    r, r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\"     \"    0,    r, r\")\n+\t\t     (match_operand:SI 2 \"nds32_rimm5u_operand\" \" Iu05, Iu05, r\")))]\n   \"\"\n   \"@\n    srai45\\t%0, %2\n@@ -847,10 +844,10 @@\n    (set_attr \"subtype\" \"shift,shift,shift\")\n    (set_attr \"length\"  \"    2,    4,    4\")])\n \n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"               \"=   d,    r, r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"    0,    r, r\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \" Iu05, Iu05, r\")))]\n+(define_insn \"*lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                  \"=   d,    r, r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\"     \"    0,    r, r\")\n+\t\t     (match_operand:SI 2 \"nds32_rimm5u_operand\" \" Iu05, Iu05, r\")))]\n   \"\"\n   \"@\n    srli45\\t%0, %2"}, {"sha": "066ec3471eab0a427d508ce6fe006abc9dda4171", "filename": "gcc/config/nds32/predicates.md", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b13564bf757ea3351d630805cd5716147f033b/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpredicates.md?ref=a3b13564bf757ea3351d630805cd5716147f033b", "patch": "@@ -51,6 +51,10 @@\n   (and (match_operand 0 \"const_int_operand\")\n        (match_test \"satisfies_constraint_Iu05 (op)\")))\n \n+(define_predicate \"nds32_rimm5u_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"nds32_imm5u_operand\")))\n+\n (define_predicate \"nds32_move_operand\"\n   (and (match_operand 0 \"general_operand\")\n        (not (match_code \"high,const,symbol_ref,label_ref\")))\n@@ -65,6 +69,40 @@\n   return true;\n })\n \n+(define_predicate \"nds32_and_operand\"\n+  (match_operand 0 \"nds32_reg_constant_operand\")\n+{\n+  return REG_P (op)\n+\t || GET_CODE (op) == SUBREG\n+\t || satisfies_constraint_Izeb (op)\n+\t || satisfies_constraint_Izeh (op)\n+\t || satisfies_constraint_Ixls (op)\n+\t || satisfies_constraint_Ix11 (op)\n+\t || satisfies_constraint_Ibms (op)\n+\t || satisfies_constraint_Ifex (op)\n+\t || satisfies_constraint_Iu15 (op)\n+\t || satisfies_constraint_Ii15 (op)\n+\t || satisfies_constraint_Ic15 (op);\n+})\n+\n+(define_predicate \"nds32_ior_operand\"\n+  (match_operand 0 \"nds32_reg_constant_operand\")\n+{\n+  return REG_P (op)\n+\t || GET_CODE (op) == SUBREG\n+\t || satisfies_constraint_Iu15 (op)\n+\t || satisfies_constraint_Ie15 (op);\n+})\n+\n+(define_predicate \"nds32_xor_operand\"\n+  (match_operand 0 \"nds32_reg_constant_operand\")\n+{\n+  return REG_P (op)\n+\t || GET_CODE (op) == SUBREG\n+\t || satisfies_constraint_Iu15 (op)\n+\t || satisfies_constraint_It15 (op);\n+})\n+\n (define_predicate \"nds32_general_register_operand\"\n   (match_code \"reg,subreg\")\n {"}]}