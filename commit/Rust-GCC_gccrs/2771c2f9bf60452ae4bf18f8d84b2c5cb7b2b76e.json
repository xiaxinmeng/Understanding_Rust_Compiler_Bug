{"sha": "2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3MWMyZjliZjYwNDUyYWU0YmYxOGY4ZDg0YjJjNWNiN2IyYjc2ZQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2012-12-11T08:37:00Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2012-12-11T08:37:00Z"}, "message": "predicates.md (\"execute_operation\"): New predicate.\n\n2012-12-11  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* config/s390/predicates.md (\"execute_operation\"): New predicate.\n\t* config/s390/s390.md (\"*execute_rl\", \"*execute\"): Use the new\n\tpredicate.\n\nFrom-SVN: r194385", "tree": {"sha": "cadb0620f280d6c9b908d2db8bd6869fa475d830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cadb0620f280d6c9b908d2db8bd6869fa475d830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e/comments", "author": null, "committer": null, "parents": [{"sha": "33e4edab852f968dd90705152d775cf5f7a1827a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e4edab852f968dd90705152d775cf5f7a1827a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33e4edab852f968dd90705152d775cf5f7a1827a"}], "stats": {"total": 56, "additions": 54, "deletions": 2}, "files": [{"sha": "a8bd7c8f49c70e12012c1ddf77d13e4b42ac2c9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e", "patch": "@@ -1,3 +1,9 @@\n+2012-12-11  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* config/s390/predicates.md (\"execute_operation\"): New predicate.\n+\t* config/s390/s390.md (\"*execute_rl\", \"*execute\"): Use the new\n+\tpredicate.\n+\n 2012-12-10  Xinliang David Li  <davidxl@google.com>\n \n \t* config/i386/i386.c: Enable push/pop in pro/epilogue for mordern CPUs."}, {"sha": "9ba85bf387c32a7f20fce2e2af51c8661960201c", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e", "patch": "@@ -348,6 +348,52 @@\n   return true;\n })\n \n+;; For an execute pattern the target instruction is embedded into the\n+;; RTX but will not get checked for validity by recog automatically.\n+;; The execute_operation predicate extracts the target RTX and invokes\n+;; recog.\n+(define_special_predicate \"execute_operation\"\n+  (match_code \"parallel\")\n+{\n+  rtx pattern = op;\n+  rtx insn;\n+  int icode;\n+\n+  /* This is redundant but since this predicate is evaluated\n+     first when recognizing the insn we can prevent the more\n+     expensive code below from being executed for many cases.  */\n+  if (GET_CODE (XVECEXP (pattern, 0, 0)) != UNSPEC\n+      || XINT (XVECEXP (pattern, 0, 0), 1) != UNSPEC_EXECUTE)\n+    return false;\n+\n+  /* Keep in sync with s390_execute_target.  */\n+  if (XVECLEN (pattern, 0) == 2)\n+    {\n+      pattern = copy_rtx (XVECEXP (pattern, 0, 1));\n+    }\n+  else\n+    {\n+      rtvec vec = rtvec_alloc (XVECLEN (pattern, 0) - 1);\n+      int i;\n+\n+      for (i = 0; i < XVECLEN (pattern, 0) - 1; i++)\n+\tRTVEC_ELT (vec, i) = copy_rtx (XVECEXP (pattern, 0, i + 1));\n+\n+      pattern = gen_rtx_PARALLEL (VOIDmode, vec);\n+    }\n+\n+  /* Since we do not have the wrapping insn here we have to build one.  */\n+  insn = make_insn_raw (pattern);\n+  icode = recog_memoized (insn);\n+  if (icode < 0)\n+    return false;\n+\n+  extract_insn (insn);\n+  constrain_operands (1);\n+\n+  return which_alternative >= 0;\n+})\n+\n ;; Return true if OP is a store multiple operation.  It is known to be a\n ;; PARALLEL and the first section will be tested.\n "}, {"sha": "bea58cd7a8340a5f7df64c8cd2176d0e69d72371", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=2771c2f9bf60452ae4bf18f8d84b2c5cb7b2b76e", "patch": "@@ -2493,7 +2493,7 @@\n ;;\n \n (define_insn \"*execute_rl\"\n-  [(match_parallel 0 \"\"\n+  [(match_parallel 0 \"execute_operation\"\n     [(unspec [(match_operand 1    \"register_operand\" \"a\")\n \t      (match_operand 2    \"\" \"\")\n               (match_operand:SI 3 \"larl_operand\" \"X\")] UNSPEC_EXECUTE)])]\n@@ -2504,7 +2504,7 @@\n    (set_attr \"type\"    \"cs\")])\n \n (define_insn \"*execute\"\n-  [(match_parallel 0 \"\"\n+  [(match_parallel 0 \"execute_operation\"\n     [(unspec [(match_operand 1 \"register_operand\" \"a\")\n               (match_operand:BLK 2 \"memory_operand\" \"R\")\n               (match_operand 3 \"\" \"\")] UNSPEC_EXECUTE)])]"}]}