{"sha": "1470e75f92c375cb27c473fd5f26af4a7b3bf1cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ3MGU3NWY5MmMzNzVjYjI3YzQ3M2ZkNWYyNmFmNGE3YjNiZjFjZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-07-16T19:35:10Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-07-16T19:35:10Z"}, "message": "jit: Add guide for submitting patches to jit docs\n\ngcc/jit/ChangeLog:\n\t* docs/internals/index.rst (Overview of code structure): Add note\n\tthat the implementation is in C++, despite the .c extension.\n\t(Submitting patches): New subsection.\n\nFrom-SVN: r225905", "tree": {"sha": "f9b968ba66bd22ba3cea4eef4818aee88f324568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9b968ba66bd22ba3cea4eef4818aee88f324568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bc1c07c4a3724d55f82e32f13be6307de9adcff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bc1c07c4a3724d55f82e32f13be6307de9adcff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bc1c07c4a3724d55f82e32f13be6307de9adcff"}], "stats": {"total": 250, "additions": 247, "deletions": 3}, "files": [{"sha": "e0abaac8eb7fae0fd0cfb48678db8e6e9dcc974e", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=1470e75f92c375cb27c473fd5f26af4a7b3bf1cd", "patch": "@@ -1,3 +1,10 @@\n+2015-07-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/internals/index.rst (Overview of code structure): Add note\n+\tthat the implementation is in C++, despite the .c extension.\n+\t(Submitting patches): New subsection.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\n 2015-07-09  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* dummy-frontend.c: Adjust includes for flags.h changes."}, {"sha": "c304c26be3e7c02093810ae964c3fa20ed98dcf0", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 142, "deletions": 3, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=1470e75f92c375cb27c473fd5f26af4a7b3bf1cd", "patch": "@@ -19,7 +19,7 @@\n \n @copying\n @quotation\n-libgccjit 6.0.0 (experimental 20150701), July 01, 2015\n+libgccjit 6.0.0 (experimental 20150716), July 16, 2015\n \n David Malcolm\n \n@@ -353,6 +353,7 @@ Internals\n * Packaging notes:: \n * Overview of code structure:: \n * Design notes:: \n+* Submitting patches:: \n \n Running the test suite\n \n@@ -14043,6 +14044,7 @@ This is a thin wrapper around the\n * Packaging notes:: \n * Overview of code structure:: \n * Design notes:: \n+* Submitting patches:: \n \n @end menu\n \n@@ -14395,6 +14397,9 @@ popd\n @section Overview of code structure\n \n \n+The library is implemented in C++.  The source files have the @code{.c}\n+extension for legacy reasons.\n+\n \n @itemize *\n \n@@ -14856,7 +14861,7 @@ JIT: gcc::jit::logger::~logger()\n \n @noindent\n \n-@node Design notes,,Overview of code structure,Internals\n+@node Design notes,Submitting patches,Overview of code structure,Internals\n @anchor{internals/index design-notes}@anchor{1b9}\n @section Design notes\n \n@@ -14869,8 +14874,142 @@ be within the libgccjit API entrypoints in libgccjit.c, since this is as\n close as possible to the error; failing that, a good place is within\n @code{recording::context::validate ()} in jit-recording.c.\n \n+@node Submitting patches,,Design notes,Internals\n+@anchor{internals/index submitting-patches}@anchor{1ba}\n+@section Submitting patches\n+\n+\n+Please read the contribution guidelines for gcc at\n+@indicateurl{https://gcc.gnu.org/contribute.html}.\n+\n+Patches for the jit should be sent to both the\n+@email{gcc-patches@@gcc.gnu.org} and @email{jit@@gcc.gnu.org} mailing lists,\n+with \"jit\" and \"PATCH\" in the Subject line.\n+\n+You don't need to do a full bootstrap for code that just touches the\n+@code{jit} and @code{testsuite/jit.dg} subdirectories.  However, please run\n+@code{make check-jit} before submitting the patch, and mention the results\n+in your email (along with the host triple that the tests were run on).\n+\n+A good patch should contain the information listed in the\n+gcc contribution guide linked to above; for a @code{jit} patch, the patch\n+shold contain:\n+\n+@quotation\n+\n+\n+@itemize *\n+\n+@item \n+the code itself (for example, a new API entrypoint will typically\n+touch @code{libgccjit.h} and @code{.c}, along with support code in\n+@code{jit-recording.[ch]} and @code{jit-playback.[ch]} as appropriate)\n+\n+@item \n+test coverage\n+\n+@item \n+documentation for the C API\n+\n+@item \n+documentation for the C++ API\n+@end itemize\n+@end quotation\n+\n+A patch that adds new API entrypoints should also contain:\n+\n+@quotation\n+\n+\n+@itemize *\n+\n+@item \n+a feature macro in @code{libgccjit.h} so that client code that doesn't\n+use a \"configure\" mechanism can still easily detect the presence of\n+the entrypoint.  See e.g. @code{LIBGCCJIT_HAVE_SWITCH_STATEMENTS} (for\n+a category of entrypoints) and\n+@code{LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks}\n+(for an individual entrypoint).\n+\n+@item \n+a new ABI tag containing the new symbols (in @code{libgccjit.map}), so\n+that we can detect client code that uses them\n+\n+@item \n+Support for @pxref{5d,,gcc_jit_context_dump_reproducer_to_file()}.  Most\n+jit testcases attempt to dump their contexts to a .c file; @code{jit.exp}\n+then sanity-checks the generated c by compiling them (though\n+not running them).   A new API entrypoint\n+needs to \"know\" how to write itself back out to C (by implementing\n+@code{gcc::jit::recording::memento::write_reproducer} for the appropriate\n+@code{memento} subclass).\n+\n+@item \n+C++ bindings for the new entrypoints (see @code{libgccjit++.h}); ideally\n+with test coverage, though the C++ API test coverage is admittedly\n+spotty at the moment\n+\n+@item \n+documentation for the new C entrypoints\n+\n+@item \n+documentation for the new C++ entrypoints\n+\n+@item \n+documentation for the new ABI tag (see @code{topics/compatibility.rst}).\n+@end itemize\n+@end quotation\n+\n+Depending on the patch you can either extend an existing test case, or\n+add a new test case.  If you add an entirely new testcase: @code{jit.exp}\n+expects jit testcases to begin with @code{test-}, or @code{test-error-} (for a\n+testcase that generates an error on a @pxref{8,,gcc_jit_context}).\n+\n+Every new testcase that doesn't generate errors should also touch\n+@code{gcc/testsuite/jit.dg/all-non-failing-tests.h}:\n+\n+@quotation\n+\n+\n+@itemize *\n+\n+@item \n+Testcases that don't generate errors should ideally be added to the\n+@code{testcases} array in that file; this means that, in addition\n+to being run standalone, they also get run within\n+@code{test-combination.c} (which runs all successful tests inside one\n+big @pxref{8,,gcc_jit_context}), and @code{test-threads.c} (which runs all\n+successful tests in one process, each one running in a different\n+thread on a different @pxref{8,,gcc_jit_context}).\n+\n+@cartouche\n+@quotation Note \n+Given that exported functions within a @pxref{8,,gcc_jit_context}\n+must have unique names, and most testcases are run within\n+@code{test-combination.c}, this means that every jit-compiled test\n+function typically needs a name that's unique across the entire\n+test suite.\n+@end quotation\n+@end cartouche\n+\n+@item \n+Testcases that aren't to be added to the @code{testcases} array should\n+instead add a comment to the file clarifying why they're not in that\n+array. See the file for examples.\n+@end itemize\n+@end quotation\n+\n+Typically a patch that touches the .rst documentation will also need the\n+texinfo to be regenerated.  You can do this with\n+Sphinx 1.0@footnote{http://sphinx-doc.org/} or later by\n+running @code{make texinfo} within @code{SRCDIR/gcc/jit/docs}.   Don't do this\n+within the patch sent to the mailing list; it can often be relatively\n+large and inconsequential (e.g. anchor renumbering), rather like generated\n+\"configure\" changes from configure.ac.  You can regenerate it when\n+committing to svn.\n+\n @node Indices and tables,Index,Internals,Top\n-@anchor{index indices-and-tables}@anchor{1ba}\n+@anchor{index indices-and-tables}@anchor{1bb}\n @unnumbered Indices and tables\n \n "}, {"sha": "6f287626d58405efe4ae5e5fe36c345bd1f696b2", "filename": "gcc/jit/docs/internals/index.rst", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1470e75f92c375cb27c473fd5f26af4a7b3bf1cd/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst?ref=1470e75f92c375cb27c473fd5f26af4a7b3bf1cd", "patch": "@@ -287,6 +287,9 @@ For example:\n Overview of code structure\n --------------------------\n \n+The library is implemented in C++.  The source files have the ``.c``\n+extension for legacy reasons.\n+\n * ``libgccjit.c`` implements the API entrypoints.  It performs error\n   checking, then calls into classes of the gcc::jit::recording namespace\n   within ``jit-recording.c`` and ``jit-recording.h``.\n@@ -335,3 +338,98 @@ should be rejected via additional checking.  The checking ideally should\n be within the libgccjit API entrypoints in libgccjit.c, since this is as\n close as possible to the error; failing that, a good place is within\n ``recording::context::validate ()`` in jit-recording.c.\n+\n+Submitting patches\n+------------------\n+Please read the contribution guidelines for gcc at\n+https://gcc.gnu.org/contribute.html.\n+\n+Patches for the jit should be sent to both the\n+gcc-patches@gcc.gnu.org and jit@gcc.gnu.org mailing lists,\n+with \"jit\" and \"PATCH\" in the Subject line.\n+\n+You don't need to do a full bootstrap for code that just touches the\n+``jit`` and ``testsuite/jit.dg`` subdirectories.  However, please run\n+``make check-jit`` before submitting the patch, and mention the results\n+in your email (along with the host triple that the tests were run on).\n+\n+A good patch should contain the information listed in the\n+gcc contribution guide linked to above; for a ``jit`` patch, the patch\n+shold contain:\n+\n+  * the code itself (for example, a new API entrypoint will typically\n+    touch ``libgccjit.h`` and ``.c``, along with support code in\n+    ``jit-recording.[ch]`` and ``jit-playback.[ch]`` as appropriate)\n+\n+  * test coverage\n+\n+  * documentation for the C API\n+\n+  * documentation for the C++ API\n+\n+A patch that adds new API entrypoints should also contain:\n+\n+  * a feature macro in ``libgccjit.h`` so that client code that doesn't\n+    use a \"configure\" mechanism can still easily detect the presence of\n+    the entrypoint.  See e.g. ``LIBGCCJIT_HAVE_SWITCH_STATEMENTS`` (for\n+    a category of entrypoints) and\n+    ``LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks``\n+    (for an individual entrypoint).\n+\n+  * a new ABI tag containing the new symbols (in ``libgccjit.map``), so\n+    that we can detect client code that uses them\n+\n+  * Support for :c:func:`gcc_jit_context_dump_reproducer_to_file`.  Most\n+    jit testcases attempt to dump their contexts to a .c file; ``jit.exp``\n+    then sanity-checks the generated c by compiling them (though\n+    not running them).   A new API entrypoint\n+    needs to \"know\" how to write itself back out to C (by implementing\n+    ``gcc::jit::recording::memento::write_reproducer`` for the appropriate\n+    ``memento`` subclass).\n+\n+  * C++ bindings for the new entrypoints (see ``libgccjit++.h``); ideally\n+    with test coverage, though the C++ API test coverage is admittedly\n+    spotty at the moment\n+\n+  * documentation for the new C entrypoints\n+\n+  * documentation for the new C++ entrypoints\n+\n+  * documentation for the new ABI tag (see ``topics/compatibility.rst``).\n+\n+Depending on the patch you can either extend an existing test case, or\n+add a new test case.  If you add an entirely new testcase: ``jit.exp``\n+expects jit testcases to begin with ``test-``, or ``test-error-`` (for a\n+testcase that generates an error on a :c:type:`gcc_jit_context`).\n+\n+Every new testcase that doesn't generate errors should also touch\n+``gcc/testsuite/jit.dg/all-non-failing-tests.h``:\n+\n+  * Testcases that don't generate errors should ideally be added to the\n+    ``testcases`` array in that file; this means that, in addition\n+    to being run standalone, they also get run within\n+    ``test-combination.c`` (which runs all successful tests inside one\n+    big :c:type:`gcc_jit_context`), and ``test-threads.c`` (which runs all\n+    successful tests in one process, each one running in a different\n+    thread on a different :c:type:`gcc_jit_context`).\n+\n+    .. note::\n+\n+       Given that exported functions within a :c:type:`gcc_jit_context`\n+       must have unique names, and most testcases are run within\n+       ``test-combination.c``, this means that every jit-compiled test\n+       function typically needs a name that's unique across the entire\n+       test suite.\n+\n+  * Testcases that aren't to be added to the ``testcases`` array should\n+    instead add a comment to the file clarifying why they're not in that\n+    array. See the file for examples.\n+\n+Typically a patch that touches the .rst documentation will also need the\n+texinfo to be regenerated.  You can do this with\n+`Sphinx 1.0 <http://sphinx-doc.org/>`_ or later by\n+running ``make texinfo`` within ``SRCDIR/gcc/jit/docs``.   Don't do this\n+within the patch sent to the mailing list; it can often be relatively\n+large and inconsequential (e.g. anchor renumbering), rather like generated\n+\"configure\" changes from configure.ac.  You can regenerate it when\n+committing to svn."}]}