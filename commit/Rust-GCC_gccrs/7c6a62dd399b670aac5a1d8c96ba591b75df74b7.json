{"sha": "7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M2YTYyZGQzOTliNjcwYWFjNWExZDhjOTZiYTU5MWI3NWRmNzRiNw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2006-12-01T19:53:29Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2006-12-01T19:53:29Z"}, "message": "common.opt (ftree-combine-temps): Remove.\n\n\n\t* common.opt (ftree-combine-temps): Remove.\n\t* tree-outof-ssa.c (SSANORM_COMBINE_TEMPS): Remove.\n\t(coalesce_ssa_name): Don't check for combine-temps.\n\t(coalesce_vars): Remove.\n\t(check_replaceable): Use num_imm_uses.\n\t(remove_ssa_form, insert_backedge_copies, rewrite_out_of_ssa): Don't \n\tcheck for combine-temps.\n\t(rewrite_out_of_ssa): Never create a ref_count in the var_map.\n\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Change parms\n\tto register_ssa_partition calls.\n\t* tree-ssa-live.c (register_ssa_partition): Remove prototype.\n\t(init_var_map, delete_var_map): remove refernces to ref_count.\n\t(create_ssa_var_map): Never calculate a ref count.\n\t(type_var_init): Remove.\n\t* tree-ssa-live.h (typedef struct _var_map): Remove ref_count.\n\t(SSA_VAR_MAP_REF_COUNT): Delete.\n\t(create_ssa_var_map): Change Prototype to have no parameters.\n\t(version_ref_count): Delete.\n\t(register_ssa_partition): Remove 'is_use' paramater and don't set the\n\tref_count vector.\n\t(type_var_num, type_var, type_var_first_partition,\n\ttype_var_next_partition, type_var_dump, type_var_delete,\n\ttype_var_remove_partition, type_var_find, type_var_compact,\n\ttype_var_decompact): Remove.\n\n\t* gcc.dg/max-1.c: Remove reference to -fno-tree-lrs option.\n\nFrom-SVN: r119409", "tree": {"sha": "6542d2518434af68a90407dc272e1642c14f88d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6542d2518434af68a90407dc272e1642c14f88d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/comments", "author": null, "committer": null, "parents": [{"sha": "35e3ced91afa26d2fb8ad118de9c5e208dcc3944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e3ced91afa26d2fb8ad118de9c5e208dcc3944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e3ced91afa26d2fb8ad118de9c5e208dcc3944"}], "stats": {"total": 443, "additions": 55, "deletions": 388}, "files": [{"sha": "34ac82f96a6974b3f62fe0b1724ecaffbb2d2059", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "patch": "@@ -1,3 +1,30 @@\n+2006-12-01  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* common.opt (ftree-combine-temps): Remove.\n+\t* tree-outof-ssa.c (SSANORM_COMBINE_TEMPS): Remove.\n+\t(coalesce_ssa_name): Don't check for combine-temps.\n+\t(coalesce_vars): Remove.\n+\t(check_replaceable): Use num_imm_uses.\n+\t(remove_ssa_form, insert_backedge_copies, rewrite_out_of_ssa): Don't \n+\tcheck for combine-temps.\n+\t(rewrite_out_of_ssa): Never create a ref_count in the var_map.\n+\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Change parms\n+\tto register_ssa_partition calls.\n+\t* tree-ssa-live.c (register_ssa_partition): Remove prototype.\n+\t(init_var_map, delete_var_map): remove refernces to ref_count.\n+\t(create_ssa_var_map): Never calculate a ref count.\n+\t(type_var_init): Remove.\n+\t* tree-ssa-live.h (typedef struct _var_map): Remove ref_count.\n+\t(SSA_VAR_MAP_REF_COUNT): Delete.\n+\t(create_ssa_var_map): Change Prototype to have no parameters.\n+\t(version_ref_count): Delete.\n+\t(register_ssa_partition): Remove 'is_use' paramater and don't set the\n+\tref_count vector.\n+\t(type_var_num, type_var, type_var_first_partition,\n+\ttype_var_next_partition, type_var_dump, type_var_delete,\n+\ttype_var_remove_partition, type_var_find, type_var_compact,\n+\ttype_var_decompact): Remove.\n+\n 2006-12-01  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.md (pushsi_insn, popsi_insn): Set correct addrtype"}, {"sha": "e73fbac9e9188f1c077439badb6f63edd24cc815", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "patch": "@@ -929,10 +929,6 @@ ftree-ch\n Common Report Var(flag_tree_ch)\n Enable loop header copying on trees\n \n-ftree-combine-temps\n-Common Report Var(flag_tree_combine_temps)\n-Coalesce memory temporaries in the SSA->normal pass\n-\n ftree-copyrename\n Common Report Var(flag_tree_copyrename)\n Replace SSA temporaries with better names in copies"}, {"sha": "08b4e0446e5626f9281e463b2fccaaf62eaf7d8b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "patch": "@@ -1,3 +1,7 @@\n+2006-12-01  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* gcc.dg/max-1.c: Remove reference to -fno-tree-lrs option.\n+\n 2006-12-01  Ryan Mansfield  <rmansfield@qnx.com>\n \n \tPR c++/29066"}, {"sha": "3eb7800a7f4c300e9546f69ad5e86dcb5cf19f65", "filename": "gcc/testsuite/gcc.dg/max-1.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftestsuite%2Fgcc.dg%2Fmax-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftestsuite%2Fgcc.dg%2Fmax-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmax-1.c?ref=7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "patch": "@@ -1,7 +1,9 @@\n /* PR middle-end/18548 */\n /* Test case reduced by Andrew Pinski <pinskia@physics.uc.edu> */\n /* { dg-do run } */\n-/* { dg-options \"-O1 -fno-tree-lrs\" } */\n+/* { dg-options \"-O1 \" } */\n+/* Option -fno-tree-lrs removed By Andrew MacLeod since it is no longer \n+   supported in the compiler beginning with GCC 4.3.  */\n /* m32c has varying sized pointers */\n /* { dg-skip-if \"\" { \"m32c-*-*\" } { \"*\" } { \"-mcpu=m32c\" \"-mcpu=m32cm\" } } */\n "}, {"sha": "1bd531a1b658c154d196e980d99172dd67c47567", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 7, "deletions": 149, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "patch": "@@ -51,7 +51,6 @@ Boston, MA 02110-1301, USA.  */\n /* Flags to pass to remove_ssa_form.  */\n \n #define SSANORM_PERFORM_TER\t\t0x1\n-#define SSANORM_COMBINE_TEMPS\t\t0x2\n #define SSANORM_COALESCE_PARTITIONS\t0x4\n \n /* Used to hold all the components required to do SSA PHI elimination.\n@@ -874,11 +873,8 @@ coalesce_ssa_name (var_map map, int flags)\n \tSET_BIT (live, x);\n     }\n \n-  if ((flags & SSANORM_COMBINE_TEMPS) == 0)\n-    {\n-      delete_tree_live_info (liveinfo);\n-      liveinfo = NULL;\n-    }\n+  delete_tree_live_info (liveinfo);\n+  liveinfo = NULL;\n \n   /* Assign root variable as partition representative for each live on entry\n      partition.  */\n@@ -1126,121 +1122,6 @@ eliminate_virtual_phis (void)\n }\n \n \n-/* This routine will coalesce variables in MAP of the same type which do not \n-   interfere with each other. LIVEINFO is the live range info for variables\n-   of interest.  This will both reduce the memory footprint of the stack, and \n-   allow us to coalesce together local copies of globals and scalarized \n-   component refs.  */\n-\n-static void\n-coalesce_vars (var_map map, tree_live_info_p liveinfo)\n-{\n-  basic_block bb;\n-  type_var_p tv;\n-  tree var;\n-  unsigned x, p, p2;\n-  coalesce_list_p cl;\n-  conflict_graph graph;\n-\n-  cl = create_coalesce_list (map);\n-\n-  /* Merge all the live on entry vectors for coalesced partitions.  */\n-  for (x = 0; x < num_var_partitions (map); x++)\n-    {\n-      var = partition_to_var (map, x);\n-      p = var_to_partition (map, var);\n-      if (p != x)\n-        live_merge_and_clear (liveinfo, p, x);\n-    }\n-\n-  /* When PHI nodes are turned into copies, the result of each PHI node\n-     becomes live on entry to the block. Mark these now.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      tree phi, arg;\n-      unsigned p;\n-      \n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  p = var_to_partition (map, PHI_RESULT (phi));\n-\n-\t  /* Skip virtual PHI nodes.  */\n-\t  if (p == (unsigned)NO_PARTITION)\n-\t    continue;\n-\n-\t  make_live_on_entry (liveinfo, bb, p);\n-\n-\t  /* Each argument is a potential copy operation. Add any arguments \n-\t     which are not coalesced to the result to the coalesce list.  */\n-\t  for (x = 0; x < (unsigned)PHI_NUM_ARGS (phi); x++)\n-\t    {\n-\t      arg = PHI_ARG_DEF (phi, x);\n-\t      if (!phi_ssa_name_p (arg))\n-\t        continue;\n-\t      p2 = var_to_partition (map, arg);\n-\t      if (p2 == (unsigned)NO_PARTITION)\n-\t\tcontinue;\n-\t      if (p != p2)\n-\t\t{\n-\t\t  edge e = PHI_ARG_EDGE (phi, x);\n-\n-\t\t  add_coalesce (cl, p, p2, \n-\t\t\t\tcoalesce_cost (EDGE_FREQUENCY (e),\n-\t\t\t\t\t       maybe_hot_bb_p (bb),\n-\t\t\t\t\t       EDGE_CRITICAL_P (e)));\n-\t\t}\n-\t    }\n-\t}\n-   }\n-\n-  \n-  /* Re-calculate live on exit info.  */\n-  calculate_live_on_exit (liveinfo);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Live range info for variable memory coalescing.\\n\");\n-      dump_live_info (dump_file, liveinfo, LIVEDUMP_ALL);\n-\n-      fprintf (dump_file, \"Coalesce list from phi nodes:\\n\");\n-      dump_coalesce_list (dump_file, cl);\n-    }\n-\n-\n-  tv = type_var_init (map);\n-  if (dump_file)\n-    type_var_dump (dump_file, tv);\n-  type_var_compact (tv);\n-  if (dump_file)\n-    type_var_dump (dump_file, tv);\n-\n-  graph = build_tree_conflict_graph (liveinfo, tv, cl);\n-\n-  type_var_decompact (tv);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"type var list now looks like:n\");\n-      type_var_dump (dump_file, tv);\n-\n-      fprintf (dump_file, \"Coalesce list after conflict graph build:\\n\");\n-      dump_coalesce_list (dump_file, cl);\n-    }\n-\n-  sort_coalesce_list (cl);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Coalesce list after sorting:\\n\");\n-      dump_coalesce_list (dump_file, cl);\n-    }\n-\n-  coalesce_tpa_members (tv, graph, map, cl, \n-\t\t\t((dump_flags & TDF_DETAILS) ? dump_file : NULL));\n-\n-  type_var_delete (tv);\n-  delete_coalesce_list (cl);\n-}\n-\n-\n /* Temporary Expression Replacement (TER)\n \n    Replace SSA version variables during out-of-ssa with their defining\n@@ -1553,7 +1434,6 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n {\n   tree var, def, basevar;\n   int version;\n-  var_map map = tab->map;\n   ssa_op_iter iter;\n   tree call_expr;\n   bitmap def_vars, use_vars;\n@@ -1566,7 +1446,7 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n   if (!def)\n     return false;\n \n-  if (version_ref_count (map, def) != 1)\n+  if (num_imm_uses (def) != 1)\n     return false;\n \n   /* There must be no V_MAY_DEFS or V_MUST_DEFS.  */\n@@ -2338,19 +2218,15 @@ remove_ssa_form (var_map map, int flags)\n \n   /* If we are not combining temps, don't calculate live ranges for variables\n      with only one SSA version.  */\n-  if ((flags & SSANORM_COMBINE_TEMPS) == 0)\n-    compact_var_map (map, VARMAP_NO_SINGLE_DEFS);\n-  else\n-    compact_var_map (map, VARMAP_NORMAL);\n+  compact_var_map (map, VARMAP_NO_SINGLE_DEFS);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);\n \n   liveinfo = coalesce_ssa_name (map, flags);\n \n   /* Make sure even single occurrence variables are in the list now.  */\n-  if ((flags & SSANORM_COMBINE_TEMPS) == 0)\n-    compact_var_map (map, VARMAP_NORMAL);\n+  compact_var_map (map, VARMAP_NORMAL);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2374,16 +2250,6 @@ remove_ssa_form (var_map map, int flags)\n       dump_var_map (dump_file, map);\n     }\n \n-  if ((flags & SSANORM_COMBINE_TEMPS) && liveinfo)\n-    {\n-      coalesce_vars (map, liveinfo);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"After variable memory coalescing:\\n\");\n-\t  dump_var_map (dump_file, map);\n-\t}\n-    }\n-  \n   if (liveinfo)\n     delete_tree_live_info (liveinfo);\n \n@@ -2449,8 +2315,7 @@ insert_backedge_copies (void)\n \t\t need a copy statement.  */\n \t      if ((e->flags & EDGE_DFS_BACK)\n \t\t  && (TREE_CODE (arg) != SSA_NAME\n-\t\t      || (!flag_tree_combine_temps\n-\t\t\t  && SSA_NAME_VAR (arg) != result_var)))\n+\t\t      || SSA_NAME_VAR (arg) != result_var))\n \t\t{\n \t\t  tree stmt, name, last = NULL;\n \t\t  block_stmt_iterator bsi;\n@@ -2505,7 +2370,6 @@ static unsigned int\n rewrite_out_of_ssa (void)\n {\n   var_map map;\n-  int var_flags = 0;\n   int ssa_flags = 0;\n \n   /* If elimination of a PHI requires inserting a copy on a backedge,\n@@ -2524,14 +2388,8 @@ rewrite_out_of_ssa (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_tree_cfg (dump_file, dump_flags & ~TDF_DETAILS);\n \n-  /* We cannot allow unssa to un-gimplify trees before we instrument them.  */\n-  if (flag_tree_ter && !flag_mudflap)\n-    var_flags = SSA_VAR_MAP_REF_COUNT;\n-\n-  map = create_ssa_var_map (var_flags);\n+  map = create_ssa_var_map ();\n \n-  if (flag_tree_combine_temps)\n-    ssa_flags |= SSANORM_COMBINE_TEMPS;\n   if (flag_tree_ter && !flag_mudflap)\n     ssa_flags |= SSANORM_PERFORM_TER;\n "}, {"sha": "b2921a2b9eb2ec3d073f612a9687ff2619c8530d", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "patch": "@@ -121,8 +121,8 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n   gcc_assert (TREE_CODE (var1) == SSA_NAME);\n   gcc_assert (TREE_CODE (var2) == SSA_NAME);\n \n-  register_ssa_partition (map, var1, false);\n-  register_ssa_partition (map, var2, true);\n+  register_ssa_partition (map, var1);\n+  register_ssa_partition (map, var2);\n \n   p1 = partition_find (map->var_partition, SSA_NAME_VERSION (var1));\n   p2 = partition_find (map->var_partition, SSA_NAME_VERSION (var2));"}, {"sha": "3d578ac3ce4aeeb40be55d33cf74309c2f479829", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 9, "deletions": 96, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "patch": "@@ -45,7 +45,6 @@ static tree_live_info_p new_tree_live_info (var_map);\n static inline void set_if_valid (var_map, bitmap, tree);\n static inline void add_livein_if_notdef (tree_live_info_p, bitmap,\n \t\t\t\t\t tree, basic_block);\n-static inline void register_ssa_partition (var_map, tree, bool);\n static inline void add_conflicts_if_valid (tpa_p, conflict_graph,\n \t\t\t\t\t   var_map, bitmap, tree);\n static partition_pair_p find_partition_pair (coalesce_list_p, int, int, bool);\n@@ -79,7 +78,6 @@ init_var_map (int size)\n   map->compact_to_partition = NULL;\n   map->num_partitions = size;\n   map->partition_size = size;\n-  map->ref_count = NULL;\n   return map;\n }\n \n@@ -95,8 +93,6 @@ delete_var_map (var_map map)\n     free (map->partition_to_compact);\n   if (map->compact_to_partition)\n     free (map->compact_to_partition);\n-  if (map->ref_count)\n-    free (map->ref_count);\n   free (map);\n }\n \n@@ -402,11 +398,11 @@ remove_unused_locals (void)\n    new partition map is returned.  */\n \n var_map\n-create_ssa_var_map (int flags)\n+create_ssa_var_map (void)\n {\n   block_stmt_iterator bsi;\n   basic_block bb;\n-  tree dest, use;\n+  tree var;\n   tree stmt;\n   var_map map;\n   ssa_op_iter iter;\n@@ -422,26 +418,19 @@ create_ssa_var_map (int flags)\n   used_in_virtual_ops = BITMAP_ALLOC (NULL);\n #endif\n \n-  if (flags & SSA_VAR_MAP_REF_COUNT)\n-    {\n-      map->ref_count\n-\t= (int *)xmalloc (((num_ssa_names + 1) * sizeof (int)));\n-      memset (map->ref_count, 0, (num_ssa_names + 1) * sizeof (int));\n-    }\n-\n   FOR_EACH_BB (bb)\n     {\n       tree phi, arg;\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  int i;\n-\t  register_ssa_partition (map, PHI_RESULT (phi), false);\n+\t  register_ssa_partition (map, PHI_RESULT (phi));\n \t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n \t    {\n \t      arg = PHI_ARG_DEF (phi, i);\n \t      if (TREE_CODE (arg) == SSA_NAME)\n-\t\tregister_ssa_partition (map, arg, true);\n+\t\tregister_ssa_partition (map, arg);\n \n \t      mark_all_vars_used (&PHI_ARG_DEF_TREE (phi, i));\n \t    }\n@@ -452,31 +441,22 @@ create_ssa_var_map (int flags)\n \t  stmt = bsi_stmt (bsi);\n \n \t  /* Register USE and DEF operands in each statement.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (use , stmt, iter, SSA_OP_USE)\n-\t    {\n-\t      register_ssa_partition (map, use, true);\n-\n-#ifdef ENABLE_CHECKING\n-\t      bitmap_set_bit (used_in_real_ops, DECL_UID (SSA_NAME_VAR (use)));\n-#endif\n-\t    }\n-\n-\t  FOR_EACH_SSA_TREE_OPERAND (dest, stmt, iter, SSA_OP_DEF)\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, (SSA_OP_DEF|SSA_OP_USE))\n \t    {\n-\t      register_ssa_partition (map, dest, false);\n+\t      register_ssa_partition (map, var);\n \n #ifdef ENABLE_CHECKING\n-\t      bitmap_set_bit (used_in_real_ops, DECL_UID (SSA_NAME_VAR (dest)));\n+\t      bitmap_set_bit (used_in_real_ops, DECL_UID (SSA_NAME_VAR (var)));\n #endif\n \t    }\n \n #ifdef ENABLE_CHECKING\n \t  /* Validate that virtual ops don't get used in funny ways.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, \n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, \n \t\t\t\t     SSA_OP_VIRTUAL_USES | SSA_OP_VMUSTDEF)\n \t    {\n \t      bitmap_set_bit (used_in_virtual_ops, \n-\t\t\t      DECL_UID (SSA_NAME_VAR (use)));\n+\t\t\t      DECL_UID (SSA_NAME_VAR (var)));\n \t    }\n \n #endif /* ENABLE_CHECKING */\n@@ -1069,73 +1049,6 @@ root_var_init (var_map map)\n }\n \n \n-/* Initialize a type_var structure which associates all the partitions in MAP \n-   of the same type to the type node's index.  Volatiles are ignored.  */\n-\n-type_var_p\n-type_var_init (var_map map)\n-{\n-  type_var_p tv;\n-  int x, y, p;\n-  int num_partitions = num_var_partitions (map);\n-  tree t;\n-  sbitmap seen;\n-\n-  tv = tpa_init (map);\n-  if (!tv)\n-    return NULL;\n-\n-  seen = sbitmap_alloc (num_partitions);\n-  sbitmap_zero (seen);\n-\n-  for (x = num_partitions - 1; x >= 0; x--)\n-    {\n-      t = partition_to_var (map, x);\n-\n-      /* Disallow coalescing of these types of variables.  */\n-      if (!t\n-\t  || TREE_THIS_VOLATILE (t)\n-\t  || TREE_CODE (t) == RESULT_DECL\n-      \t  || TREE_CODE (t) == PARM_DECL \n-\t  || (DECL_P (t)\n-\t      && (DECL_REGISTER (t)\n-\t\t  || !DECL_IGNORED_P (t)\n-\t\t  || DECL_RTL_SET_P (t))))\n-        continue;\n-\n-      p = var_to_partition (map, t);\n-\n-      gcc_assert (p != NO_PARTITION);\n-\n-      /* If partitions have been coalesced, only add the representative \n-\t for the partition to the list once.  */\n-      if (TEST_BIT (seen, p))\n-        continue;\n-      SET_BIT (seen, p);\n-      t = TREE_TYPE (t);\n-\n-      /* Find the list for this type.  */\n-      for (y = 0; y < tv->num_trees; y++)\n-        if (t == VEC_index (tree, tv->trees, y))\n-\t  break;\n-      if (y == tv->num_trees)\n-        {\n-\t  tv->num_trees++;\n-\t  VEC_safe_push (tree, heap, tv->trees, t);\n-\t  VEC_safe_push (int, heap, tv->first_partition, p);\n-\t}\n-      else\n-        {\n-\t  tv->next_partition[p] = VEC_index (int, tv->first_partition, y);\n-\t  VEC_replace (int, tv->first_partition, y, p);\n-\t}\n-      tv->partition_to_tree_map[p] = y;\n-    }\n-  sbitmap_free (seen);\n-  return tv;\n-}\n-\n-\n /* Hash function for 2 integer coalesce pairs.  */\n #define COALESCE_HASH_FN(R1, R2) ((R2) * ((R2) - 1) / 2 + (R1))\n "}, {"sha": "625e833770cd0205c6064663696f13b7112d0c78", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 3, "deletions": 136, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6a62dd399b670aac5a1d8c96ba591b75df74b7/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "patch": "@@ -44,9 +44,6 @@ typedef struct _var_map\n \n   /* Original partition size.  */\n   unsigned int partition_size;\n-\n-  /* Reference count, if required.  */\n-  int *ref_count;\n } *var_map;\n \n #define VAR_ANN_PARTITION(ann) (ann->partition)\n@@ -74,11 +71,9 @@ static inline tree var_to_partition_to_var (var_map, tree);\n static inline tree partition_to_var (var_map, int);\n static inline int var_to_partition (var_map, tree);\n static inline tree version_to_var (var_map, int);\n-static inline int version_ref_count (var_map, tree);\n-static inline void register_ssa_partition (var_map, tree, bool);\n+static inline void register_ssa_partition (var_map, tree);\n \n-#define SSA_VAR_MAP_REF_COUNT\t 0x01\n-extern var_map create_ssa_var_map (int);\n+extern var_map create_ssa_var_map (void);\n \n /* Number of partitions in MAP.  */\n \n@@ -89,17 +84,6 @@ num_var_partitions (var_map map)\n }\n \n \n-/* Return the reference count for SSA_VAR's partition in MAP.  */\n-\n-static inline int\n-version_ref_count (var_map map, tree ssa_var)\n-{\n-  int version = SSA_NAME_VERSION (ssa_var);\n-  gcc_assert (map->ref_count);\n-  return map->ref_count[version];\n-}\n- \n-\n /* Given partition index I from MAP, return the variable which represents that \n    partition.  */\n  \n@@ -176,7 +160,7 @@ var_to_partition_to_var (var_map map, tree var)\n    later.  */ \n \n static inline void\n-register_ssa_partition (var_map map, tree ssa_var, bool is_use)\n+register_ssa_partition (var_map map, tree ssa_var)\n {\n   int version;\n \n@@ -185,9 +169,6 @@ register_ssa_partition (var_map map, tree ssa_var, bool is_use)\n #endif\n \n   version = SSA_NAME_VERSION (ssa_var);\n-  if (is_use && map->ref_count)\n-    map->ref_count[version]++;\n-\n   if (map->partition_to_var[version] == NULL_TREE)\n     map->partition_to_var[SSA_NAME_VERSION (ssa_var)] = ssa_var;\n }\n@@ -551,120 +532,6 @@ root_var_decompact (root_var_p rv)\n }\n \n \n-/* A TYPE_VAR object is similar to a root_var object, except this associates \n-   partitions with their type rather than their root variable.  This is used to \n-   coalesce memory locations based on type.  */\n-\n-typedef tpa_p type_var_p;\n-\n-static inline tree type_var (type_var_p, int);\n-static inline int type_var_first_partition (type_var_p, int);\n-static inline int type_var_next_partition (type_var_p, int);\n-static inline int type_var_num (type_var_p);\n-static inline void type_var_dump (FILE *, type_var_p);\n-static inline void type_var_remove_partition (type_var_p, int, int);\n-static inline void type_var_delete (type_var_p);\n-static inline int type_var_find (type_var_p, int);\n-static inline int type_var_compact (type_var_p);\n-static inline void type_var_decompact (type_var_p);\n-\n-extern type_var_p type_var_init (var_map);\n-\n-/* Value returned when there is no partitions associated with a list.  */\n-#define TYPE_VAR_NONE\t\tTPA_NONE\n-\n-\n-/* Return the number of distinct type lists in TV.  */\n-\n-static inline int \n-type_var_num (type_var_p tv)\n-{\n-  return tpa_num_trees (tv);\n-}\n-\n-\n-/* Return the type of list I in TV.  */\n-\n-static inline tree\n-type_var (type_var_p tv, int i)\n-{\n-  return tpa_tree (tv, i);\n-}\n-\n-\n-/* Return the first partition belonging to type list I in TV.  */\n-\n-static inline int\n-type_var_first_partition (type_var_p tv, int i)\n-{\n-  return tpa_first_partition (tv, i);\n-}\n-\n-\n-/* Return the next partition after partition I in a type list within TV.  */\n-\n-static inline int\n-type_var_next_partition (type_var_p tv, int i)\n-{\n-  return tpa_next_partition (tv, i);\n-}\n-\n-\n-/* Send debug info for type_var object TV to file F.  */\n-\n-static inline void\n-type_var_dump (FILE *f, type_var_p tv)\n-{\n-  fprintf (f, \"\\nType Var dump\\n\");\n-  tpa_dump (f, tv);\n-  fprintf (f, \"\\n\");\n-}\n-\n-\n-/* Delete type_var object TV.  */\n-\n-static inline void\n-type_var_delete (type_var_p tv)\n-{\n-  tpa_delete (tv);\n-}\n-\n-\n-/* Remove partition PARTITION_INDEX from type list TYPE_INDEX in TV.  */\n-\n-static inline void\n-type_var_remove_partition (type_var_p tv, int type_index, int partition_index)\n-{\n-  tpa_remove_partition (tv, type_index, partition_index);\n-}\n-\n-\n-/* Return the type index in TV for the list partition I is in.  */\n-\n-static inline int\n-type_var_find (type_var_p tv, int i)\n-{\n-  return tpa_find_tree (tv, i);\n-}\n-\n-\n-/* Hide single element lists in TV.  */\n-\n-static inline int \n-type_var_compact (type_var_p tv)\n-{\n-  return tpa_compact (tv);\n-}\n-\n-\n-/* Expose single element lists in TV.  */\n-\n-static inline void\n-type_var_decompact (type_var_p tv)\n-{\n-  tpa_decompact (tv);\n-}\n-\n /* This set of routines implements a coalesce_list. This is an object which\n    is used to track pairs of partitions which are desirable to coalesce\n    together at some point.  Costs are associated with each pair, and when "}]}