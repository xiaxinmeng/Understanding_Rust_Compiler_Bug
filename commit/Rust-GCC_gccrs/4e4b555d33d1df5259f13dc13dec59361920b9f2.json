{"sha": "4e4b555d33d1df5259f13dc13dec59361920b9f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU0YjU1NWQzM2QxZGY1MjU5ZjEzZGMxM2RlYzU5MzYxOTIwYjlmMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-12T04:27:36Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-12T04:27:36Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r451", "tree": {"sha": "3034869a319d2245ce39802bb85588f3ae12352b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3034869a319d2245ce39802bb85588f3ae12352b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e4b555d33d1df5259f13dc13dec59361920b9f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e4b555d33d1df5259f13dc13dec59361920b9f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e4b555d33d1df5259f13dc13dec59361920b9f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e4b555d33d1df5259f13dc13dec59361920b9f2/comments", "author": null, "committer": null, "parents": [{"sha": "1d0d98f38ca9701e45ddc93b8138b06feb3fa513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0d98f38ca9701e45ddc93b8138b06feb3fa513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d0d98f38ca9701e45ddc93b8138b06feb3fa513"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "c2aba9c5a20fb9b33026600faedbb3a436cdc130", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e4b555d33d1df5259f13dc13dec59361920b9f2/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e4b555d33d1df5259f13dc13dec59361920b9f2/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=4e4b555d33d1df5259f13dc13dec59361920b9f2", "patch": "@@ -57,14 +57,19 @@ tree\n get_pending_sizes ()\n {\n   tree chain = pending_sizes;\n+  tree t;\n+\n+  /* Put each SAVE_EXPR into the current function.  */\n+  for (t = chain; t; t = TREE_CHAIN (t))\n+    SAVE_EXPR_CONTEXT (TREE_VALUE (t)) = current_function_decl;\n   pending_sizes = 0;\n   return chain;\n }\n \n /* Given a size SIZE that isn't constant, return a SAVE_EXPR\n    to serve as the actual size-expression for a type or decl.  */\n \n-static tree\n+tree\n variable_size (size)\n      tree size;\n {\n@@ -686,15 +691,13 @@ layout_type (type)\n \t      = mode_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n \t\t\t       MODE_INT, 1);\n \n-#ifdef STRICT_ALIGNMENT\n-\t    if (TYPE_ALIGN (type) < BIGGEST_ALIGNMENT\n+\t    if (STRICT_ALIGNMENT && TYPE_ALIGN (type) < BIGGEST_ALIGNMENT\n \t\t&& TYPE_ALIGN (type) < TREE_INT_CST_LOW (TYPE_SIZE (type))\n \t\t&& TYPE_MODE (type) != BLKmode)\n \t      {\n \t\tTYPE_NO_FORCE_BLK (type) = 1;\n \t\tTYPE_MODE (type) = BLKmode;\n \t      }\n-#endif\n \t  }\n \tbreak;\n       }\n@@ -741,17 +744,18 @@ layout_type (type)\n \t  /* If structure's known alignment is less than\n \t     what the scalar mode would need, and it matters,\n \t     then stick with BLKmode.  */\n-#ifdef STRICT_ALIGNMENT\n-\t  if (! (TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n-\t\t || TYPE_ALIGN (type) >= TREE_INT_CST_LOW (TYPE_SIZE (type))))\n+\t  if (STRICT_ALIGNMENT\n+\t      && ! (TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n+\t\t    || (TYPE_ALIGN (type)\n+\t\t\t>= TREE_INT_CST_LOW (TYPE_SIZE (type)))))\n \t    {\n \t      if (TYPE_MODE (type) != BLKmode)\n \t\t/* If this is the only reason this type is BLKmode,\n \t\t   then don't force containing types to be BLKmode.  */\n \t\tTYPE_NO_FORCE_BLK (type) = 1;\n \t      TYPE_MODE (type) = BLKmode;\n \t    }\n-#endif\n+\n \trecord_lose: ;\n \t}\n \n@@ -771,11 +775,9 @@ layout_type (type)\n \t  /* If structure's known alignment is less than\n \t     what the scalar mode would need, and it matters,\n \t     then stick with BLKmode.  */\n-#ifdef STRICT_ALIGNMENT\n-\t  && (TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n-\t      || TYPE_ALIGN (type) >= TREE_INT_CST_LOW (TYPE_SIZE (type)))\n-#endif\n-\t  )\n+\t  && (! STRICT_ALIGNMENT\n+\t      || TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n+\t      || TYPE_ALIGN (type) >= TREE_INT_CST_LOW (TYPE_SIZE (type))))\n \t{\n \t  tree field;\n \t  /* A union which has any BLKmode members must itself be BLKmode;\n@@ -809,11 +811,9 @@ layout_type (type)\n      alignment.  */\n \n   if (TYPE_MODE (type) != BLKmode && TYPE_MODE (type) != VOIDmode\n-#ifndef STRICT_ALIGNMENT\n-      && (TREE_CODE (type) != RECORD_TYPE && TREE_CODE (type) != UNION_TYPE\n-\t  && TREE_CODE (type) != ARRAY_TYPE)\n-#endif\n-      )\n+      && (STRICT_ALIGNMENT\n+\t  || (TREE_CODE (type) != RECORD_TYPE && TREE_CODE (type) != UNION_TYPE\n+\t      && TREE_CODE (type) != ARRAY_TYPE)))\n     TYPE_ALIGN (type) = GET_MODE_ALIGNMENT (TYPE_MODE (type));\n \n   /* Evaluate nonconstant size only once, either now or as soon as safe.  */\n@@ -971,7 +971,7 @@ get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n \n   if (mode == MAX_MACHINE_MODE\n       /* It is tempting to omit the following line\n-\t if STRICT_ALIGNMENT is not defined.\n+\t if STRICT_ALIGNMENT is true.\n \t But that is incorrect, since if the bitfield uses part of 3 bytes\n \t and we use a 4-byte mode, we could get a spurious segv\n \t if the extra 4th byte is past the end of memory."}]}