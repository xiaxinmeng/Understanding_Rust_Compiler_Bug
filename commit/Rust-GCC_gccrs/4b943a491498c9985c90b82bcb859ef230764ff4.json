{"sha": "4b943a491498c9985c90b82bcb859ef230764ff4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI5NDNhNDkxNDk4Yzk5ODVjOTBiODJiY2I4NTllZjIzMDc2NGZmNA==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2013-03-30T23:34:22Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2013-03-30T23:34:22Z"}, "message": "In dse.c, remove alias hash tables that are never set.\n\nRemove conditions that are then never true.\nRemove functions that are then never called.\nRemove variables that are then never read.\n\n\nIndex: gcc/ChangeLog\n\n2013-03-29  Lawrence Crowl  <crowl@google.com>\n\n\t* dse.c (clear_alias_sets): Remove never set.\n\t(disqualified_clear_alias_sets): Remove never set.\n\t(clear_alias_mode_pool): Remove never set.\n\t(dse_step0): Remove condition that is never true.\n\t(canon_address): Remove condition that is never true.\n\t(dse_step7): Remove condition that is never true.\n\t(rest_of_handle_dse): Remove condition that is never true.\n\t(rest_of_handle_dse::did_global): Remove never read from above.\n\t(dse_step2_spill): Remove never called from above.\n\t(dse_step5_spill): Remove never called from above.\n\nFrom-SVN: r197272", "tree": {"sha": "1a59563f50df5bd0154ebcaf0ea7e66e332cd2eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a59563f50df5bd0154ebcaf0ea7e66e332cd2eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b943a491498c9985c90b82bcb859ef230764ff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b943a491498c9985c90b82bcb859ef230764ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b943a491498c9985c90b82bcb859ef230764ff4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b943a491498c9985c90b82bcb859ef230764ff4/comments", "author": null, "committer": null, "parents": [{"sha": "624e9b1f2359fda45434c8abeb119b193ba7411a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624e9b1f2359fda45434c8abeb119b193ba7411a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/624e9b1f2359fda45434c8abeb119b193ba7411a"}], "stats": {"total": 205, "additions": 14, "deletions": 191}, "files": [{"sha": "13f302c8bf435cb01d2ae9597c0fc9991f0d1a47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b943a491498c9985c90b82bcb859ef230764ff4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b943a491498c9985c90b82bcb859ef230764ff4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b943a491498c9985c90b82bcb859ef230764ff4", "patch": "@@ -1,3 +1,16 @@\n+2013-03-30  Lawrence Crowl  <crowl@google.com>\n+\n+\t* dse.c (clear_alias_sets): Remove never set.\n+\t(disqualified_clear_alias_sets): Remove never set.\n+\t(clear_alias_mode_pool): Remove never set.\n+\t(dse_step0): Remove condition that is never true.\n+\t(canon_address): Remove condition that is never true.\n+\t(dse_step7): Remove condition that is never true.\n+\t(rest_of_handle_dse): Remove condition that is never true.\n+\t(rest_of_handle_dse::did_global): Remove never read from above.\n+\t(dse_step2_spill): Remove never called from above.\n+\t(dse_step5_spill): Remove never called from above.\n+\n 2013-03-30  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* doc/md.texi (Standard Names) <casesi>: Update documentation for"}, {"sha": "629d2387923b765d2423d56d8f0a56ba2fbc7873", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 191, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b943a491498c9985c90b82bcb859ef230764ff4/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b943a491498c9985c90b82bcb859ef230764ff4/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=4b943a491498c9985c90b82bcb859ef230764ff4", "patch": "@@ -572,20 +572,6 @@ static alloc_pool deferred_change_pool;\n \n static deferred_change_t deferred_change_list = NULL;\n \n-/* This are used to hold the alias sets of spill variables.  Since\n-   these are never aliased and there may be a lot of them, it makes\n-   sense to treat them specially.  This bitvector is only allocated in\n-   calls from dse_record_singleton_alias_set which currently is only\n-   made during reload1.  So when dse is called before reload this\n-   mechanism does nothing.  */\n-\n-static bitmap clear_alias_sets = NULL;\n-\n-/* The set of clear_alias_sets that have been disqualified because\n-   there are loads or stores using a different mode than the alias set\n-   was registered with.  */\n-static bitmap disqualified_clear_alias_sets = NULL;\n-\n /* The group that holds all of the clear_alias_sets.  */\n static group_info_t clear_alias_group;\n \n@@ -599,8 +585,6 @@ struct clear_alias_mode_holder\n   enum machine_mode mode;\n };\n \n-static alloc_pool clear_alias_mode_pool;\n-\n /* This is true except if cfun->stdarg -- i.e. we cannot do\n    this for vararg functions because they play games with the frame.  */\n static bool stores_off_frame_dead_at_return;\n@@ -788,10 +772,7 @@ dse_step0 (void)\n \n   init_alias_analysis ();\n \n-  if (clear_alias_sets)\n-    clear_alias_group = get_group_info (NULL);\n-  else\n-    clear_alias_group = NULL;\n+  clear_alias_group = NULL;\n }\n \n \n@@ -1189,39 +1170,6 @@ canon_address (rtx mem,\n   rtx expanded_address, address;\n   int expanded;\n \n-  /* Make sure that cselib is has initialized all of the operands of\n-     the address before asking it to do the subst.  */\n-\n-  if (clear_alias_sets)\n-    {\n-      /* If this is a spill, do not do any further processing.  */\n-      alias_set_type alias_set = MEM_ALIAS_SET (mem);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"found alias set %d\\n\", (int) alias_set);\n-      if (bitmap_bit_p (clear_alias_sets, alias_set))\n-\t{\n-\t  struct clear_alias_mode_holder *entry\n-\t    = clear_alias_set_lookup (alias_set);\n-\n-\t  /* If the modes do not match, we cannot process this set.  */\n-\t  if (entry->mode != GET_MODE (mem))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file,\n-\t\t\t \"disqualifying alias set %d, (%s) != (%s)\\n\",\n-\t\t\t (int) alias_set, GET_MODE_NAME (entry->mode),\n-\t\t\t GET_MODE_NAME (GET_MODE (mem)));\n-\n-\t      bitmap_set_bit (disqualified_clear_alias_sets, alias_set);\n-\t      return false;\n-\t    }\n-\n-\t  *alias_set_out = alias_set;\n-\t  *group_id = clear_alias_group->id;\n-\t  return true;\n-\t}\n-    }\n-\n   *alias_set_out = 0;\n \n   cselib_lookup (mem_address, address_mode, 1, GET_MODE (mem));\n@@ -2993,47 +2941,6 @@ dse_step2_nospill (void)\n }\n \n \n-/* Init the offset tables for the spill case.  */\n-\n-static bool\n-dse_step2_spill (void)\n-{\n-  unsigned int j;\n-  group_info_t group = clear_alias_group;\n-  bitmap_iterator bi;\n-\n-  /* Position 0 is unused because 0 is used in the maps to mean\n-     unused.  */\n-  current_position = 1;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      bitmap_print (dump_file, clear_alias_sets,\n-\t\t    \"clear alias sets              \", \"\\n\");\n-      bitmap_print (dump_file, disqualified_clear_alias_sets,\n-\t\t    \"disqualified clear alias sets \", \"\\n\");\n-    }\n-\n-  memset (group->offset_map_n, 0, sizeof(int) * group->offset_map_size_n);\n-  memset (group->offset_map_p, 0, sizeof(int) * group->offset_map_size_p);\n-  bitmap_clear (group->group_kill);\n-\n-  /* Remove the disqualified positions from the store2_p set.  */\n-  bitmap_and_compl_into (group->store2_p, disqualified_clear_alias_sets);\n-\n-  /* We do not need to process the store2_n set because\n-     alias_sets are always positive.  */\n-  EXECUTE_IF_SET_IN_BITMAP (group->store2_p, 0, j, bi)\n-    {\n-      bitmap_set_bit (group->group_kill, current_position);\n-      group->offset_map_p[j] = current_position++;\n-      group->process_globally = true;\n-    }\n-\n-  return current_position != 1;\n-}\n-\n-\n \f\n /*----------------------------------------------------------------------------\n   Third step.\n@@ -3690,72 +3597,6 @@ dse_step5_nospill (void)\n }\n \n \n-static void\n-dse_step5_spill (void)\n-{\n-  basic_block bb;\n-  FOR_EACH_BB (bb)\n-    {\n-      bb_info_t bb_info = bb_table[bb->index];\n-      insn_info_t insn_info = bb_info->last_insn;\n-      bitmap v = bb_info->out;\n-\n-      while (insn_info)\n-\t{\n-\t  bool deleted = false;\n-\t  /* There may have been code deleted by the dce pass run before\n-\t     this phase.  */\n-\t  if (insn_info->insn\n-\t      && INSN_P (insn_info->insn)\n-\t      && (!insn_info->cannot_delete)\n-\t      && (!bitmap_empty_p (v)))\n-\t    {\n-\t      /* Try to delete the current insn.  */\n-\t      store_info_t store_info = insn_info->store_rec;\n-\t      deleted = true;\n-\n-\t      while (store_info)\n-\t\t{\n-\t\t  if (store_info->alias_set)\n-\t\t    {\n-\t\t      int index = get_bitmap_index (clear_alias_group,\n-\t\t\t\t\t\t    store_info->alias_set);\n-\t\t      if (index == 0 || !bitmap_bit_p (v, index))\n-\t\t\t{\n-\t\t\t  deleted = false;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    deleted = false;\n-\t\t  store_info = store_info->next;\n-\t\t}\n-\t      if (deleted && dbg_cnt (dse)\n-\t\t  && check_for_inc_dec_1 (insn_info))\n-\t\t{\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file, \"Spill deleting insn %d\\n\",\n-\t\t\t     INSN_UID (insn_info->insn));\n-\t\t  delete_insn (insn_info->insn);\n-\t\t  spill_deleted++;\n-\t\t  insn_info->insn = NULL;\n-\t\t}\n-\t    }\n-\n-\t  if (insn_info->insn\n-\t      && INSN_P (insn_info->insn)\n-\t      && (!deleted))\n-\t    {\n-\t      scan_stores_spill (insn_info->store_rec, v, NULL);\n-\t      scan_reads_spill (insn_info->read_rec, v, NULL);\n-\t    }\n-\n-\t  insn_info = insn_info->prev_insn;\n-\t}\n-    }\n-}\n-\n-\n \f\n /*----------------------------------------------------------------------------\n    Sixth step.\n@@ -3819,14 +3660,6 @@ dse_step7 (void)\n   bitmap_obstack_release (&dse_bitmap_obstack);\n   obstack_free (&dse_obstack, NULL);\n \n-  if (clear_alias_sets)\n-    {\n-      BITMAP_FREE (clear_alias_sets);\n-      BITMAP_FREE (disqualified_clear_alias_sets);\n-      free_alloc_pool (clear_alias_mode_pool);\n-      htab_delete (clear_alias_mode_table);\n-    }\n-\n   end_alias_analysis ();\n   free (bb_table);\n   rtx_group_table.dispose ();\n@@ -3852,8 +3685,6 @@ dse_step7 (void)\n static unsigned int\n rest_of_handle_dse (void)\n {\n-  bool did_global = false;\n-\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n \n   /* Need the notes since we must track live hardregs in the forwards\n@@ -3868,34 +3699,13 @@ rest_of_handle_dse (void)\n     {\n       df_set_flags (DF_LR_RUN_DCE);\n       df_analyze ();\n-      did_global = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"doing global processing\\n\");\n       dse_step3 (false);\n       dse_step4 ();\n       dse_step5_nospill ();\n     }\n \n-  /* For the instance of dse that runs after reload, we make a special\n-     pass to process the spills.  These are special in that they are\n-     totally transparent, i.e, there is no aliasing issues that need\n-     to be considered.  This means that the wild reads that kill\n-     everything else do not apply here.  */\n-  if (clear_alias_sets && dse_step2_spill ())\n-    {\n-      if (!did_global)\n-\t{\n-\t  df_set_flags (DF_LR_RUN_DCE);\n-\t  df_analyze ();\n-\t}\n-      did_global = true;\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"doing global spill processing\\n\");\n-      dse_step3 (true);\n-      dse_step4 ();\n-      dse_step5_spill ();\n-    }\n-\n   dse_step6 ();\n   dse_step7 ();\n "}]}