{"sha": "00f24f56732861d09a9716fa5b6b8a96c2289143", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBmMjRmNTY3MzI4NjFkMDlhOTcxNmZhNWI2YjhhOTZjMjI4OTE0Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-07-02T09:38:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-07-02T09:38:20Z"}, "message": "tree-cfg: Fix ICE with switch stmt to unreachable opt and forced labels [PR95857]\n\nThe following testcase ICEs, because during the cfg cleanup, we see:\n  switch (i$e_11) <default: <L12> [33.33%], case -3: <lab2> [33.33%], case 0: <L10> [33.33%], case 2: <lab2> [33.33%]>\n...\nlab2:\n  __builtin_unreachable ();\nwhere lab2 is FORCED_LABEL.  The way it works, we go through the case labels\nand when we reach the first one that points to gimple_seq_unreachable*\nbasic block, we remove the edge (if any) from the switch bb to the bb\ncontaining the label and bbs reachable only through that edge we've just\nremoved.  Once we do that, we must throw away all other cases that use\nthe same label (or some other labels from the same bb we've removed the edge\nto and the bb).  To avoid quadratic behavior, this is not done by walking\nall remaining cases immediately before removing, but only when processing\nthem later.\nFor normal labels this works, fine, if the label is in a deleted bb, it will\nhave NULL label_to_block and we handle that case, or, if the unreachable bb\nhas some other edge to it, only the edge will be removed and not the bb,\nand again, find_edge will not find the edge and we only remove the case.\nAnd if a label would be to some other block, that other block wouldn't have\nbeen removed earlier because there would be still an edge from the switch\nblock.\nNow, FORCED_LABEL (and I think DECL_NONLOCAL too) break this, because\nthose labels aren't removed, but instead moved to some surrounding basic\nblock.  So, when we later process those, when their gimple_seq_unreachable*\nbasic block is removed, label_to_block will return some unrelated block\n(in the testcase the switch bb), so we decide to keep the case which doesn't\nseem to be unreachable, but we don't really have an edge from the switch\nblock to the block the label got moved to.\n\nI thought first about punting in gimple_seq_unreachable* on\nFORCED_LABEL/DECL_NONLOCAL labels, but that might penalize even code that\ndoesn't care, so this instead just makes sure that for\nFORCED_LABEL/DECL_NONLOCAL labels that are being removed (and thus moved\nrandomly) we remember in a hash_set the fact that those labels should be\ntreated as removed for the purpose of the optimization, and later on\nhandle those labels that way.\n\n2020-07-02  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/95857\n\t* tree-cfg.c (group_case_labels_stmt): When removing an unreachable\n\tbase_bb, remember all forced and non-local labels on it and later\n\ttreat those as if they have NULL label_to_block.  Formatting fix.\n\tFix a comment typo.\n\n\t* gcc.dg/pr95857.c: New test.", "tree": {"sha": "9e309b637586205e1f954b3f79cabf2d90cd7234", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e309b637586205e1f954b3f79cabf2d90cd7234"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00f24f56732861d09a9716fa5b6b8a96c2289143", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f24f56732861d09a9716fa5b6b8a96c2289143", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f24f56732861d09a9716fa5b6b8a96c2289143", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f24f56732861d09a9716fa5b6b8a96c2289143/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5d9f7834ab809841c4ccc90bca74808b4bcaf8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d9f7834ab809841c4ccc90bca74808b4bcaf8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5d9f7834ab809841c4ccc90bca74808b4bcaf8d"}], "stats": {"total": 77, "additions": 72, "deletions": 5}, "files": [{"sha": "41506ea68933713eeb33290081aab0f3c634ef26", "filename": "gcc/testsuite/gcc.dg/pr95857.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f24f56732861d09a9716fa5b6b8a96c2289143/gcc%2Ftestsuite%2Fgcc.dg%2Fpr95857.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f24f56732861d09a9716fa5b6b8a96c2289143/gcc%2Ftestsuite%2Fgcc.dg%2Fpr95857.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr95857.c?ref=00f24f56732861d09a9716fa5b6b8a96c2289143", "patch": "@@ -0,0 +1,37 @@\n+/* PR tree-optimization/95857 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+struct E { int e; };\n+int bar (void), baz (void);\n+void qux (void *);\n+\n+void\n+foo (int x)\n+{\n+  struct E a = { 0 };\n+  struct E i = { 0 };\n+  qux (&&lab2);\n+  if (baz ())\n+    i.e = 1;\n+  else\n+    a.e = -2;\n+  switch (a.e)\n+    {\n+    case -2:\n+    lab1:\n+      switch (i.e)\n+\t{\n+\tcase -3:\n+\tcase 2:\n+\t  if (i.e-- != 2)\n+\t    __builtin_unreachable ();\n+\tlab2:\n+\t  baz ();\n+\t  goto lab1;\n+\tcase 0:\n+\t  bar ();\n+\t}\n+      break;\n+    }\n+}"}, {"sha": "b4d0c6db238146bc9a1ebd3e39ccfdaa7097a38a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f24f56732861d09a9716fa5b6b8a96c2289143/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f24f56732861d09a9716fa5b6b8a96c2289143/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=00f24f56732861d09a9716fa5b6b8a96c2289143", "patch": "@@ -1728,6 +1728,7 @@ group_case_labels_stmt (gswitch *stmt)\n   int old_size = gimple_switch_num_labels (stmt);\n   int i, next_index, new_size;\n   basic_block default_bb = NULL;\n+  hash_set<tree> *removed_labels = NULL;\n \n   default_bb = gimple_switch_default_bb (cfun, stmt);\n \n@@ -1744,8 +1745,11 @@ group_case_labels_stmt (gswitch *stmt)\n       base_bb = label_to_block (cfun, CASE_LABEL (base_case));\n \n       /* Discard cases that have the same destination as the default case or\n-\t whose destiniation blocks have already been removed as unreachable.  */\n-      if (base_bb == NULL || base_bb == default_bb)\n+\t whose destination blocks have already been removed as unreachable.  */\n+      if (base_bb == NULL\n+\t  || base_bb == default_bb\n+\t  || (removed_labels\n+\t      && removed_labels->contains (CASE_LABEL (base_case))))\n \t{\n \t  i++;\n \t  continue;\n@@ -1768,10 +1772,13 @@ group_case_labels_stmt (gswitch *stmt)\n \t  /* Merge the cases if they jump to the same place,\n \t     and their ranges are consecutive.  */\n \t  if (merge_bb == base_bb\n+\t      && (removed_labels == NULL\n+\t\t  || !removed_labels->contains (CASE_LABEL (merge_case)))\n \t      && wi::to_wide (CASE_LOW (merge_case)) == bhp1)\n \t    {\n-\t      base_high = CASE_HIGH (merge_case) ?\n-\t\t  CASE_HIGH (merge_case) : CASE_LOW (merge_case);\n+\t      base_high\n+\t\t= (CASE_HIGH (merge_case)\n+\t\t   ? CASE_HIGH (merge_case) : CASE_LOW (merge_case));\n \t      CASE_HIGH (base_case) = base_high;\n \t      next_index++;\n \t    }\n@@ -1792,7 +1799,29 @@ group_case_labels_stmt (gswitch *stmt)\n \t{\n \t  edge base_edge = find_edge (gimple_bb (stmt), base_bb);\n \t  if (base_edge != NULL)\n-\t    remove_edge_and_dominated_blocks (base_edge);\n+\t    {\n+\t      for (gimple_stmt_iterator gsi = gsi_start_bb (base_bb);\n+\t\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t\tif (glabel *stmt = dyn_cast <glabel *> (gsi_stmt (gsi)))\n+\t\t  {\n+\t\t    if (FORCED_LABEL (gimple_label_label (stmt))\n+\t\t\t|| DECL_NONLOCAL (gimple_label_label (stmt)))\n+\t\t      {\n+\t\t\t/* Forced/non-local labels aren't going to be removed,\n+\t\t\t   but they will be moved to some neighbouring basic\n+\t\t\t   block. If some later case label refers to one of\n+\t\t\t   those labels, we should throw that case away rather\n+\t\t\t   than keeping it around and refering to some random\n+\t\t\t   other basic block without an edge to it.  */\n+\t\t\tif (removed_labels == NULL)\n+\t\t\t  removed_labels = new hash_set<tree>;\n+\t\t\tremoved_labels->add (gimple_label_label (stmt));\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  break;\n+\t      remove_edge_and_dominated_blocks (base_edge);\n+\t    }\n \t  i = next_index;\n \t  continue;\n \t}\n@@ -1809,6 +1838,7 @@ group_case_labels_stmt (gswitch *stmt)\n   if (new_size < old_size)\n     gimple_switch_set_num_labels (stmt, new_size);\n \n+  delete removed_labels;\n   return new_size < old_size;\n }\n "}]}