{"sha": "2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY1NzEzMzRmZjQ1Nzg1MGI5YTc3NDhiNmFmOGM4ZDFkMDdjOGYxYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-05-29T10:31:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-05-29T10:31:58Z"}, "message": "re PR tree-optimization/36343 (Wrong code due to bad TBAA pruning of points-to-sets and use in call clobbering)\n\n2008-05-29  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/36343\n\tPR tree-optimization/36346\n\tPR tree-optimization/36347\n\t* tree-flow.h (clobber_what_p_points_to): Declare.\n\t* tree-ssa-structalias.c (set_uids_in_ptset): Whether the\n\tpointed-to variable is dereferenced is irrelevant to whether\n\tthe pointer can access the pointed-to variable.\n\t(clobber_what_p_points_to): New function.\n\t* tree-ssa-alias.c (set_initial_properties): Use it.\n\t* tree-ssa.c (verify_flow_sensitive_alias_info): Adjust\n\tcall clobber check for NMTs.\n\n\t* gcc.c-torture/execute/pr36343.c: New testcase.\n\nFrom-SVN: r136152", "tree": {"sha": "9ac5b52b2f6b2f8b4637381bf6843792fdf1b16e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ac5b52b2f6b2f8b4637381bf6843792fdf1b16e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3d5f74124228eafaf92a3b63a18cd9265f2cf25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d5f74124228eafaf92a3b63a18cd9265f2cf25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d5f74124228eafaf92a3b63a18cd9265f2cf25"}], "stats": {"total": 167, "additions": 141, "deletions": 26}, "files": [{"sha": "72477652d6d08bd305fad7f7332d128f09780069", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "patch": "@@ -1,3 +1,17 @@\n+2008-05-29  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36343\n+\tPR tree-optimization/36346\n+\tPR tree-optimization/36347\n+\t* tree-flow.h (clobber_what_p_points_to): Declare.\n+\t* tree-ssa-structalias.c (set_uids_in_ptset): Whether the\n+\tpointed-to variable is dereferenced is irrelevant to whether\n+\tthe pointer can access the pointed-to variable.\n+\t(clobber_what_p_points_to): New function.\n+\t* tree-ssa-alias.c (set_initial_properties): Use it.\n+\t* tree-ssa.c (verify_flow_sensitive_alias_info): Adjust\n+\tcall clobber check for NMTs.\n+\n 2008-05-28  Seongbae Park  <seongbae.park@gmail.com>\n \t\n \t* value-prof.c (tree_ic_transform): Use HOST_WIDEST_INT_PRINT_DEC"}, {"sha": "9f77f70634b9ed9102f56d5e040e347519574efc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "patch": "@@ -1,3 +1,8 @@\n+2008-05-29  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36343\n+\t* gcc.c-torture/execute/pr36343.c: New testcase.\n+\n 2008-05-29  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat.dg/abstract1.ad[sb]: New test."}, {"sha": "44b9fb340756f034bb87eed9ffe4c24465f3501c", "filename": "gcc/testsuite/gcc.c-torture/execute/pr36343.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr36343.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr36343.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr36343.c?ref=2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "patch": "@@ -0,0 +1,32 @@\n+extern void abort (void);\n+\n+void __attribute__((noinline))\n+bar (int **p)\n+{\n+  float *q = (float *)p;\n+  *q = 0.0;\n+}\n+\n+float __attribute__((noinline))\n+foo (int b)\n+{\n+  int *i = 0;\n+  float f = 1.0;\n+  int **p;\n+  if (b)\n+    p = &i;\n+  else\n+    p = (int **)&f;\n+  bar (p);\n+  if (b)\n+    return **p;\n+  return f;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0.0)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "94d5a69f69ccebb8f3a8c77ec1fba439179dfe52", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "patch": "@@ -1167,6 +1167,7 @@ tree gimple_fold_indirect_ref (tree);\n \n /* In tree-ssa-structalias.c */\n bool find_what_p_points_to (tree);\n+bool clobber_what_p_points_to (tree);\n \n /* In tree-ssa-live.c */\n extern void remove_unused_locals (void);"}, {"sha": "1523aebac17aa0670ab94c8e7b88fd6b6e6a2591", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "patch": "@@ -545,8 +545,14 @@ set_initial_properties (struct alias_info *ai)\n     {\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n       tree tag = symbol_mem_tag (SSA_NAME_VAR (ptr));\n-      \n-      if (pi->value_escapes_p)\n+\n+      /* A pointer that only escapes via a function return does not\n+         add to the call clobber or call used solution.\n+\t To exclude ESCAPE_TO_PURE_CONST we would need to track\n+\t call used variables separately or compute those properly\n+\t in the operand scanner.  */\n+      if (pi->value_escapes_p\n+\t  && pi->escape_mask & ~ESCAPE_TO_RETURN)\n \t{\n \t  /* If PTR escapes then its associated memory tags and\n \t     pointed-to variables are call-clobbered.  */\n@@ -556,24 +562,13 @@ set_initial_properties (struct alias_info *ai)\n \t  if (tag)\n \t    mark_call_clobbered (tag, pi->escape_mask);\n \n-\t  if (pi->pt_vars)\n-\t    {\n-\t      bitmap_iterator bi;\n-\t      unsigned int j;\t      \n-\t      EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n-\t\t{\n-\t\t  tree alias = referenced_var (j);\n-\n-\t\t  /* If you clobber one part of a structure, you\n-\t\t     clobber the entire thing.  While this does not make\n-\t\t     the world a particularly nice place, it is necessary\n-\t\t     in order to allow C/C++ tricks that involve\n-\t\t     pointer arithmetic to work.  */\n-\t\t  if (!unmodifiable_var_p (alias))\n-\t\t    mark_call_clobbered (alias, pi->escape_mask);\n-\t\t}\n-\t    }\n-\t  else if (pi->pt_anything)\n+\t  /* Defer to points-to analysis if possible, otherwise\n+\t     clobber all addressable variables.  Parameters cannot\n+\t     point to local memory though.\n+\t     ???  Properly tracking which pointers point to non-local\n+\t     memory only would make a big difference here.  */\n+\t  if (!clobber_what_p_points_to (ptr)\n+\t      && !(pi->escape_mask & ESCAPE_IS_PARM))\n \t    {\n \t      any_pt_anything = true;\n \t      pt_anything_mask |= pi->escape_mask;"}, {"sha": "b6d73ce66f4f138db0b2cbd640f2d6d6f473314a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 71, "deletions": 5, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "patch": "@@ -4664,17 +4664,19 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n \t  || TREE_CODE (vi->decl) == RESULT_DECL)\n \t{\n \t  /* Just add VI->DECL to the alias set.\n-\t     Don't type prune artificial vars.  */\n-\t  if (vi->is_artificial_var)\n+\t     Don't type prune artificial vars or points-to sets\n+\t     for pointers that have not been dereferenced or with\n+\t     type-based pruning disabled.  */\n+\t  if (vi->is_artificial_var\n+\t      || !is_derefed\n+\t      || no_tbaa_pruning)\n \t    bitmap_set_bit (into, DECL_UID (vi->decl));\n \t  else\n \t    {\n \t      alias_set_type var_alias_set, ptr_alias_set;\n \t      var_alias_set = get_alias_set (vi->decl);\n \t      ptr_alias_set = get_alias_set (TREE_TYPE (TREE_TYPE (ptr)));\n-\t      if (no_tbaa_pruning\n-\t\t  || (!is_derefed && !vi->directly_dereferenced)\n-\t\t  || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n+\t      if (alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n \t        bitmap_set_bit (into, DECL_UID (vi->decl));\n \t    }\n \t}\n@@ -4885,7 +4887,71 @@ find_what_p_points_to (tree p)\n   return false;\n }\n \n+/* Mark everything that p points to as call clobbered.  Returns true\n+   if everything is done and false if all addressable variables need to\n+   be clobbered because p points to anything.  */\n \n+bool\n+clobber_what_p_points_to (tree p)\n+{\n+  tree lookup_p = p;\n+  varinfo_t vi;\n+  struct ptr_info_def *pi;\n+  unsigned int i;\n+  bitmap_iterator bi;\n+\n+  if (!have_alias_info)\n+    return false;\n+\n+  /* For parameters, get at the points-to set for the actual parm\n+     decl.  */\n+  if (TREE_CODE (p) == SSA_NAME\n+      && TREE_CODE (SSA_NAME_VAR (p)) == PARM_DECL\n+      && SSA_NAME_IS_DEFAULT_DEF (p))\n+    lookup_p = SSA_NAME_VAR (p);\n+\n+  vi = lookup_vi_for_tree (lookup_p);\n+  if (!vi)\n+    return false;\n+\n+  /* We are asking for the points-to solution of pointers.  */\n+  gcc_assert (!vi->is_artificial_var\n+\t      && vi->size == vi->fullsize);\n+\n+  pi = get_ptr_info (p);\n+\n+  /* This variable may have been collapsed, let's get the real\n+     variable.  */\n+  vi = get_varinfo (find (vi->id));\n+\n+  /* Mark variables in the solution call-clobbered.  */\n+  EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n+    {\n+      varinfo_t vi = get_varinfo (i);\n+\n+      if (vi->is_artificial_var)\n+\t{\n+\t  /* nothing_id and readonly_id do not cause any\n+\t     call clobber ops.  For anything_id and integer_id\n+\t     we need to clobber all addressable vars.  */\n+\t  if (vi->id == anything_id\n+\t      || vi->id == integer_id)\n+\t    return false;\n+\t}\n+\n+      /* Only artificial heap-vars are further interesting.  */\n+      if (vi->is_artificial_var && !vi->is_heap_var)\n+\tcontinue;\n+\n+      if ((TREE_CODE (vi->decl) == VAR_DECL\n+\t   || TREE_CODE (vi->decl) == PARM_DECL\n+\t   || TREE_CODE (vi->decl) == RESULT_DECL)\n+\t  && !unmodifiable_var_p (vi->decl))\n+\tmark_call_clobbered (vi->decl, pi->escape_mask);\n+    }\n+\n+  return true;\n+}\n \n /* Dump points-to information to OUTFILE.  */\n "}, {"sha": "f71e3af7ff98b362491745a36faeb1ce3887e443", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f571334ff457850b9a7748b6af8c8d1d07c8f1c/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=2f571334ff457850b9a7748b6af8c8d1d07c8f1c", "patch": "@@ -571,7 +571,9 @@ verify_flow_sensitive_alias_info (void)\n \t  goto err;\n \t}\n \n-      if (pi->value_escapes_p && pi->name_mem_tag)\n+      if (pi->value_escapes_p\n+\t  && pi->escape_mask & ~ESCAPE_TO_RETURN\n+\t  && pi->name_mem_tag)\n \t{\n \t  tree t = memory_partition (pi->name_mem_tag);\n \t  if (t == NULL_TREE)"}]}