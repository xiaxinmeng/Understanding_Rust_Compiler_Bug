{"sha": "1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU0NGU4NTdlMDVjMTY1ZjZmMDFhZWI1NmE3YTQzZWU3NjViZmM5OQ==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2015-10-27T13:36:47Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-10-27T13:36:47Z"}, "message": "config.gcc: Handle --enable-fdpic.\n\ngcc/ChangeLog\n\t* config.gcc: Handle --enable-fdpic.\n\t* config/sh/constraints.md (Ccl): New constraint.\n\t* config/sh/linux.h (SUBTARGET_LINK_EMUL_SUFFIX): Handle -mfdpic.\n\t* config/sh/sh-c.c (sh_cpu_cpp_builtins): Add __FDPIC__ and\n\t__SH_FDPIC__.\n\t* config/sh/sh-mem.cc (expand_block_move): Support FDPIC for calls to\n\tlibrary functions.\n\t* config/sh/sh-protos.h (function_symbol_result): New struct.\n\t(function_symbol): Return function_symbol_result.\n\t(sh_get_fdpic_reg_initial_val, sh_load_function_descriptor): New\n\tdeclarations.\n\t* config/sh/sh.c (TARGET_ASM_INTEGER, sh_assemble_integer): Implement\n\ttarget hook.\n\t(TARGET_CANNOT_FORCE_CONST_MEM, sh_cannot_force_const_mem_p): Likewise.\n\t(sh_option_override): Force -fPIC if FDPIC is in effect.\n\t(sh_asm_output_addr_const_extra): Add UNSPEC_GOTFUNCDESC and\n\tUNSPEC_GOTOFFFUNCDESC cases.\n\t(prepare_move_operands): Use FDPIC initial GOT register for\n\tTLS-related GOT access; inhibit cross-section address offset constants\n\tfor FDPIC.\n\t(sh_assemble_integer): New function.\n\t(sh_cannot_copy_insn_p): Inhibit copying insns that are FDPIC\n\tPC-relative call sites.\n\t(expand_ashiftrt): Adapt invocation of function_symbol.\n\t(sh_expand_prologue): Inhibit PC-relative GOT address load for FDPIC.\n\t(nonpic_symbol_mentioned_p): Add cases for UNSPEC_GOTFUNCDESC and\n\tUNSPEC_GOTOFFFUNCDESC.\n\t(legitimize_pic_address): Resolve function symbols to function\n\tdescriptors for FDPIC.  Do not use GOT-relative addressing for local\n\tdata that may be read-only on FDPIC.\n\t(sh_emit_storesi, sh_emit_storehi): New functions.\n\t(sh_trampoline_init): Generate FDPIC trampolines.\n\t(sh_function_ok_for_sibcall): Add TARGET_FDPIC check.\n\t(sh_expand_sym_label2reg): Don't assume sibcalls are local.\n\t(sh_output_mi_thunk): Generate FDPIC call.\n\t(function_symbol): Return function_symbol_result.  For SFUNC_STATIC on\n\tFDPIC, generate call site labels to use PC-relative addressing rather\n\tthan GOT-relative addressing.\n\t(sh_conditional_register_usage): Make PIC register fixed and call used\n\twhen FDPIC is in effect.\n\t(sh_legitimate_constant_p): Impose FDPIC constant constraints.\n\t(sh_cannot_force_const_mem_p, sh_load_function_descriptor,\n\tsh_get_fdpic_reg_initial_val): New functions.\n\t* config/sh/sh.h (SUBTARGET_ASM_SPEC, SUBTARGET_LINK_EMUL_SUFFIX):\n\tHandle -mfdpic.\n\t(FDPIC_SELF_SPECS, SUBTARGET_DRIVER_SELF_SPECS,\n\tPIC_OFFSET_TABLE_REG_CALL_CLOBBERED,\n\tSH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P): New macros.\n\t(DRIVER_SELF_SPECS): Add SUBTARGET_DRIVER_SELF_SPECS and\n\tFDPIC_SELF_SPECS.\n\t(TRAMPOLINE_SIZE): Select trampoline size for FDPIC.\n\t(ASM_PREFERRED_EH_DATA_FORMAT): Add EH format constraints for FDPIC.\n\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Handle FDPIC case.\n\t* config/sh/sh.md (UNSPEC_GOTFUNCDESC, UNSPEC_GOTOFFFUNCDESC): New\n\tconstants.\n\t(calli_fdpic, call_valuei_fdpic, sibcalli_fdpic, sibcalli_pcrel_fdpic,\n\tsibcall_pcrel_fdpic, sibcall_valuei_fdpic, sibcall_valuei_pcrel_fdpic,\n\tsibcall_value_pcrel_fdpic, sym2GOTFUNCDESC, symGOTFUNCDESC2reg,\n\tsym2GOTOFFFUNCDESC, symGOTOFFFUNCDESC2reg): New patterns.\n\t(udivsi3_i1, udivsi3_i4, udivsi3_i4_single, udivsi3,\n\t*divsi_inv_call_combine, divsi3_i4, divsi3_i4_single, divsi3, ashlsi3,\n\tashlsi3_d_call, ashrsi3_n, lshrsi3, lshrsi3_d_call, calli, call_valuei,\n\tcall, call_value, sibcalli, sibcalli_pcrel, sibcall_pcrel, sibcall,\n\tsibcall_valuei, sibcall_valuei_pcrel, sibcall_value_pcrel,\n\tsibcall_value, GOTaddr2picreg, symGOT_load, symGOTOFF2reg,\n\tblock_move_real, block_lump_real, block_move_real_i4,\n\tblock_lump_real_i4): Add support for FDPIC calls.\n\t(mulsi3, ic_invalidate_line, initialize_trampoline, call_pop,\n\tcall_value_pop): Adjust for new function_symbol signature.\n\t* config/sh/sh.opt (-mfdpic): New option.\n\t* doc/install.texi (Options specification): Document --enable-fdpic.\n\t* doc/invoke.texi (SH Options): Document -mfdpic.\n\ninclude/ChangeLog:\n\t* longlong.h (udiv_qrnnd): Add FDPIC compatible version for SH.\n\nlibitm/ChangeLog:\n\t* config/sh/sjlj.S (_ITM_beginTransaction): Bypass PLT calling\n\tGTM_begin_transaction for compatibility with FDPIC.\n\nCo-Authored-By: Andrew Stubbs <ams@codesourcery.com>\nCo-Authored-By: Joseph Myers <joseph@codesourcery.com>\nCo-Authored-By: Mark Shinwell <shinwell@codesourcery.com>\nCo-Authored-By: Rich Felker <dalias@libc.org>\n\nFrom-SVN: r229438", "tree": {"sha": "857afca3716f7d66aef179f93b7d7adf702d67fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/857afca3716f7d66aef179f93b7d7adf702d67fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/comments", "author": null, "committer": null, "parents": [{"sha": "6f9071656286512360ca22b6668c9c8d823ec907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9071656286512360ca22b6668c9c8d823ec907", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f9071656286512360ca22b6668c9c8d823ec907"}], "stats": {"total": 1043, "additions": 889, "deletions": 154}, "files": [{"sha": "80045dd920497d5e03010f4c9dd9373781651ae1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -1,3 +1,83 @@\n+2015-10-27  Daniel Jacobowitz  <dan@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\t    Mark Shinwell  <shinwell@codesourcery.com>\n+\t    Andrew Stubbs  <ams@codesourcery.com>\n+\t    Rich Felker <dalias@libc.org>\n+\n+\t* config.gcc: Handle --enable-fdpic.\n+\t* config/sh/constraints.md (Ccl): New constraint.\n+\t* config/sh/linux.h (SUBTARGET_LINK_EMUL_SUFFIX): Handle -mfdpic.\n+\t* config/sh/sh-c.c (sh_cpu_cpp_builtins): Add __FDPIC__ and\n+\t__SH_FDPIC__.\n+\t* config/sh/sh-mem.cc (expand_block_move): Support FDPIC for calls to\n+\tlibrary functions.\n+\t* config/sh/sh-protos.h (function_symbol_result): New struct.\n+\t(function_symbol): Return function_symbol_result.\n+\t(sh_get_fdpic_reg_initial_val, sh_load_function_descriptor): New\n+\tdeclarations.\n+\t* config/sh/sh.c (TARGET_ASM_INTEGER, sh_assemble_integer): Implement\n+\ttarget hook.\n+\t(TARGET_CANNOT_FORCE_CONST_MEM, sh_cannot_force_const_mem_p): Likewise.\n+\t(sh_option_override): Force -fPIC if FDPIC is in effect.\n+\t(sh_asm_output_addr_const_extra): Add UNSPEC_GOTFUNCDESC and\n+\tUNSPEC_GOTOFFFUNCDESC cases.\n+\t(prepare_move_operands): Use FDPIC initial GOT register for\n+\tTLS-related GOT access; inhibit cross-section address offset constants\n+\tfor FDPIC.\n+\t(sh_assemble_integer): New function.\n+\t(sh_cannot_copy_insn_p): Inhibit copying insns that are FDPIC\n+\tPC-relative call sites.\n+\t(expand_ashiftrt): Adapt invocation of function_symbol.\n+\t(sh_expand_prologue): Inhibit PC-relative GOT address load for FDPIC.\n+\t(nonpic_symbol_mentioned_p): Add cases for UNSPEC_GOTFUNCDESC and\n+\tUNSPEC_GOTOFFFUNCDESC.\n+\t(legitimize_pic_address): Resolve function symbols to function\n+\tdescriptors for FDPIC.  Do not use GOT-relative addressing for local\n+\tdata that may be read-only on FDPIC.\n+\t(sh_emit_storesi, sh_emit_storehi): New functions.\n+\t(sh_trampoline_init): Generate FDPIC trampolines.\n+\t(sh_function_ok_for_sibcall): Add TARGET_FDPIC check.\n+\t(sh_expand_sym_label2reg): Don't assume sibcalls are local.\n+\t(sh_output_mi_thunk): Generate FDPIC call.\n+\t(function_symbol): Return function_symbol_result.  For SFUNC_STATIC on\n+\tFDPIC, generate call site labels to use PC-relative addressing rather\n+\tthan GOT-relative addressing.\n+\t(sh_conditional_register_usage): Make PIC register fixed and call used\n+\twhen FDPIC is in effect.\n+\t(sh_legitimate_constant_p): Impose FDPIC constant constraints.\n+\t(sh_cannot_force_const_mem_p, sh_load_function_descriptor,\n+\tsh_get_fdpic_reg_initial_val): New functions.\n+\t* config/sh/sh.h (SUBTARGET_ASM_SPEC, SUBTARGET_LINK_EMUL_SUFFIX):\n+\tHandle -mfdpic.\n+\t(FDPIC_SELF_SPECS, SUBTARGET_DRIVER_SELF_SPECS,\n+\tPIC_OFFSET_TABLE_REG_CALL_CLOBBERED,\n+\tSH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P): New macros.\n+\t(DRIVER_SELF_SPECS): Add SUBTARGET_DRIVER_SELF_SPECS and\n+\tFDPIC_SELF_SPECS.\n+\t(TRAMPOLINE_SIZE): Select trampoline size for FDPIC.\n+\t(ASM_PREFERRED_EH_DATA_FORMAT): Add EH format constraints for FDPIC.\n+\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Handle FDPIC case.\n+\t* config/sh/sh.md (UNSPEC_GOTFUNCDESC, UNSPEC_GOTOFFFUNCDESC): New\n+\tconstants.\n+\t(calli_fdpic, call_valuei_fdpic, sibcalli_fdpic, sibcalli_pcrel_fdpic,\n+\tsibcall_pcrel_fdpic, sibcall_valuei_fdpic, sibcall_valuei_pcrel_fdpic,\n+\tsibcall_value_pcrel_fdpic, sym2GOTFUNCDESC, symGOTFUNCDESC2reg,\n+\tsym2GOTOFFFUNCDESC, symGOTOFFFUNCDESC2reg): New patterns.\n+\t(udivsi3_i1, udivsi3_i4, udivsi3_i4_single, udivsi3,\n+\t*divsi_inv_call_combine, divsi3_i4, divsi3_i4_single, divsi3, ashlsi3,\n+\tashlsi3_d_call, ashrsi3_n, lshrsi3, lshrsi3_d_call, calli, call_valuei,\n+\tcall, call_value, sibcalli, sibcalli_pcrel, sibcall_pcrel, sibcall,\n+\tsibcall_valuei, sibcall_valuei_pcrel, sibcall_value_pcrel,\n+\tsibcall_value, GOTaddr2picreg, symGOT_load, symGOTOFF2reg,\n+\tblock_move_real, block_lump_real, block_move_real_i4,\n+\tblock_lump_real_i4): Add support for FDPIC calls.\n+\t(mulsi3, ic_invalidate_line, initialize_trampoline, call_pop,\n+\tcall_value_pop): Adjust for new function_symbol signature.\n+\t* config/sh/sh.opt (-mfdpic): New option.\n+\t* doc/install.texi (Options specification): Document --enable-fdpic.\n+\t* doc/invoke.texi (SH Options): Document -mfdpic.\n+\n+\n 2015-10-27  Alan Lawrence  <alan.lawrence@arm.com>\n \n \tPR tree-optimization/65963"}, {"sha": "4a7cbd20503903a1f0ce250e1592c14a3ae2e316", "filename": "gcc/config.gcc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -2628,6 +2628,9 @@ sh-*-elf* | sh[12346l]*-*-elf* | \\\n \ttm_file=\"${tm_file} dbxelf.h elfos.h sh/elf.h\"\n \tcase ${target} in\n \tsh*-*-linux*)\ttmake_file=\"${tmake_file} sh/t-linux\"\n+\t\t\tif test x$enable_fdpic = xyes; then\n+\t\t\t\ttm_defines=\"$tm_defines FDPIC_DEFAULT=1\"\n+\t\t\tfi\n \t\t\ttm_file=\"${tm_file} gnu-user.h linux.h glibc-stdint.h sh/linux.h\" ;;\n \tsh*-*-netbsd*)\n \t\t\ttm_file=\"${tm_file} netbsd.h netbsd-elf.h sh/netbsd-elf.h\""}, {"sha": "41c88a2b568886c9af6143aafc0eab813efb9d48", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -25,6 +25,7 @@\n ;;  Bsc: SCRATCH - for the scratch register in movsi_ie in the\n ;;       fldi0 / fldi0 cases\n ;; Cxx: Constants other than only CONST_INT\n+;;  Ccl: call site label\n ;;  Css: signed 16-bit constant, literal or symbolic\n ;;  Csu: unsigned 16-bit constant, literal or symbolic\n ;;  Csy: label or symbol\n@@ -233,6 +234,11 @@\n    hence mova is being used, hence do not select this pattern.\"\n   (match_code \"scratch\"))\n \n+(define_constraint \"Ccl\"\n+  \"A call site label, for bsrf.\"\n+  (and (match_code \"unspec\")\n+       (match_test \"XINT (op, 1) == UNSPEC_CALLER\")))\n+\n (define_constraint \"Css\"\n   \"A signed 16-bit constant, literal or symbolic.\"\n   (and (match_code \"const\")"}, {"sha": "b032b04ee4fbb6dca6327e2bac9bef8d37c33369", "filename": "gcc/config/sh/linux.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flinux.h?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -67,7 +67,8 @@ along with GCC; see the file COPYING3.  If not see\n #define GLIBC_DYNAMIC_LINKER \"/lib/ld-linux.so.2\"\n \n #undef SUBTARGET_LINK_EMUL_SUFFIX\n-#define SUBTARGET_LINK_EMUL_SUFFIX \"_linux\"\n+#define SUBTARGET_LINK_EMUL_SUFFIX \"%{mfdpic:_fd;:_linux}\"\n+\n #undef SUBTARGET_LINK_SPEC\n #define SUBTARGET_LINK_SPEC \\\n   \"%{shared:-shared} \\"}, {"sha": "2dabf66bd47b5034451d47a4da5103e79810bbdf", "filename": "gcc/config/sh/sh-c.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-c.c?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -137,6 +137,11 @@ sh_cpu_cpp_builtins (cpp_reader* pfile)\n     builtin_define (\"__HITACHI__\");\n   if (TARGET_FMOVD)\n     builtin_define (\"__FMOVD_ENABLED__\");\n+  if (TARGET_FDPIC)\n+    {\n+      builtin_define (\"__SH_FDPIC__\");\n+      builtin_define (\"__FDPIC__\");\n+    }\n   builtin_define (TARGET_LITTLE_ENDIAN\n \t\t  ? \"__LITTLE_ENDIAN__\" : \"__BIG_ENDIAN__\");\n "}, {"sha": "5111fb111f6de7216e56c3019ba389681b8a2aee", "filename": "gcc/config/sh/sh-mem.cc", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-mem.cc?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -108,29 +108,30 @@ expand_block_move (rtx *operands)\n \t  rtx r4 = gen_rtx_REG (SImode, 4);\n \t  rtx r5 = gen_rtx_REG (SImode, 5);\n \n-\t  function_symbol (func_addr_rtx, \"__movmemSI12_i4\", SFUNC_STATIC);\n+\t  rtx lab = function_symbol (func_addr_rtx, \"__movmemSI12_i4\",\n+\t\t\t\t     SFUNC_STATIC).lab;\n \t  force_into (XEXP (operands[0], 0), r4);\n \t  force_into (XEXP (operands[1], 0), r5);\n-\t  emit_insn (gen_block_move_real_i4 (func_addr_rtx));\n+\t  emit_insn (gen_block_move_real_i4 (func_addr_rtx, lab));\n \t  return true;\n \t}\n       else if (! optimize_size)\n \t{\n-\t  const char *entry_name;\n \t  rtx func_addr_rtx = gen_reg_rtx (Pmode);\n-\t  int dwords;\n \t  rtx r4 = gen_rtx_REG (SImode, 4);\n \t  rtx r5 = gen_rtx_REG (SImode, 5);\n \t  rtx r6 = gen_rtx_REG (SImode, 6);\n \n-\t  entry_name = (bytes & 4 ? \"__movmem_i4_odd\" : \"__movmem_i4_even\");\n-\t  function_symbol (func_addr_rtx, entry_name, SFUNC_STATIC);\n+\t  rtx lab = function_symbol (func_addr_rtx, bytes & 4\n+\t\t\t\t\t\t    ? \"__movmem_i4_odd\"\n+\t\t\t\t\t\t    : \"__movmem_i4_even\",\n+\t\t\t\t     SFUNC_STATIC).lab;\n \t  force_into (XEXP (operands[0], 0), r4);\n \t  force_into (XEXP (operands[1], 0), r5);\n \n-\t  dwords = bytes >> 3;\n+\t  int dwords = bytes >> 3;\n \t  emit_insn (gen_move_insn (r6, GEN_INT (dwords - 1)));\n-\t  emit_insn (gen_block_lump_real_i4 (func_addr_rtx));\n+\t  emit_insn (gen_block_lump_real_i4 (func_addr_rtx, lab));\n \t  return true;\n \t}\n       else\n@@ -144,10 +145,10 @@ expand_block_move (rtx *operands)\n       rtx r5 = gen_rtx_REG (SImode, 5);\n \n       sprintf (entry, \"__movmemSI%d\", bytes);\n-      function_symbol (func_addr_rtx, entry, SFUNC_STATIC);\n+      rtx lab = function_symbol (func_addr_rtx, entry, SFUNC_STATIC).lab;\n       force_into (XEXP (operands[0], 0), r4);\n       force_into (XEXP (operands[1], 0), r5);\n-      emit_insn (gen_block_move_real (func_addr_rtx));\n+      emit_insn (gen_block_move_real (func_addr_rtx, lab));\n       return true;\n     }\n \n@@ -161,7 +162,7 @@ expand_block_move (rtx *operands)\n       rtx r5 = gen_rtx_REG (SImode, 5);\n       rtx r6 = gen_rtx_REG (SImode, 6);\n \n-      function_symbol (func_addr_rtx, \"__movmem\", SFUNC_STATIC);\n+      rtx lab = function_symbol (func_addr_rtx, \"__movmem\", SFUNC_STATIC).lab;\n       force_into (XEXP (operands[0], 0), r4);\n       force_into (XEXP (operands[1], 0), r5);\n \n@@ -174,7 +175,7 @@ expand_block_move (rtx *operands)\n       final_switch = 16 - ((bytes / 4) % 16);\n       while_loop = ((bytes / 4) / 16 - 1) * 16;\n       emit_insn (gen_move_insn (r6, GEN_INT (while_loop + final_switch)));\n-      emit_insn (gen_block_lump_real (func_addr_rtx));\n+      emit_insn (gen_block_lump_real (func_addr_rtx, lab));\n       return true;\n     }\n "}, {"sha": "c64a9488df9a354ddf5632b4b27545df06fe6036", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -377,7 +377,19 @@ extern void fpscr_set_from_mem (int, HARD_REG_SET);\n extern void sh_pr_interrupt (struct cpp_reader *);\n extern void sh_pr_trapa (struct cpp_reader *);\n extern void sh_pr_nosave_low_regs (struct cpp_reader *);\n-extern rtx function_symbol (rtx, const char *, enum sh_function_kind);\n+\n+struct function_symbol_result\n+{\n+  function_symbol_result (void) : sym (NULL), lab (NULL) { }\n+  function_symbol_result (rtx s, rtx l) : sym (s), lab (l) { }\n+\n+  rtx sym;\n+  rtx lab;\n+};\n+\n+extern function_symbol_result function_symbol (rtx, const char *,\n+\t\t\t\t\t       sh_function_kind);\n+extern rtx sh_get_fdpic_reg_initial_val (void);\n extern rtx sh_get_pr_initial_val (void);\n \n extern void sh_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree,\n@@ -396,4 +408,5 @@ extern bool sh_hard_regno_mode_ok (unsigned int, machine_mode);\n extern machine_mode sh_hard_regno_caller_save_mode (unsigned int, unsigned int,\n \t\t\t\t\t\t    machine_mode);\n extern bool sh_can_use_simple_return_p (void);\n+extern rtx sh_load_function_descriptor (rtx);\n #endif /* ! GCC_SH_PROTOS_H */"}, {"sha": "530fe53078534666bc527379da2fa652021b33e8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 275, "deletions": 40, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -251,6 +251,7 @@ static rtx sh_expand_builtin (tree, rtx, rtx, machine_mode, int);\n static void sh_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\tHOST_WIDE_INT, tree);\n static void sh_file_start (void);\n+static bool sh_assemble_integer (rtx, unsigned int, int);\n static bool flow_dependent_p (rtx, rtx);\n static void flow_dependent_p_1 (rtx, const_rtx, void *);\n static int shiftcosts (rtx);\n@@ -259,6 +260,7 @@ static int addsubcosts (rtx);\n static int multcosts (rtx);\n static bool unspec_caller_rtx_p (rtx);\n static bool sh_cannot_copy_insn_p (rtx_insn *);\n+static bool sh_cannot_force_const_mem_p (machine_mode, rtx);\n static bool sh_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int sh_address_cost (rtx, machine_mode, addr_space_t, bool);\n static int sh_pr_n_sets (void);\n@@ -404,6 +406,9 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n \n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER sh_assemble_integer\n+\n #undef TARGET_REGISTER_MOVE_COST\n #define TARGET_REGISTER_MOVE_COST sh_register_move_cost\n \n@@ -662,6 +667,9 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_ATOMIC_TEST_AND_SET_TRUEVAL\n #define TARGET_ATOMIC_TEST_AND_SET_TRUEVAL 0x80\n \n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM sh_cannot_force_const_mem_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -979,6 +987,13 @@ sh_option_override (void)\n   if (! global_options_set.x_TARGET_ZDCBRANCH && TARGET_HARD_SH4)\n     TARGET_ZDCBRANCH = 1;\n \n+  /* FDPIC code is a special form of PIC, and the vast majority of code\n+     generation constraints that apply to PIC also apply to FDPIC, so we\n+     set flag_pic to avoid the need to check TARGET_FDPIC everywhere\n+     flag_pic is checked. */\n+  if (TARGET_FDPIC && !flag_pic)\n+    flag_pic = 2;\n+\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (! VALID_REGISTER_P (regno))\n       sh_register_names[regno][0] = '\\0';\n@@ -1670,6 +1685,14 @@ sh_asm_output_addr_const_extra (FILE *file, rtx x)\n \t  output_addr_const (file, XVECEXP (x, 0, 1));\n \t  fputs (\"-.)\", file);\n \t  break;\n+\tcase UNSPEC_GOTFUNCDESC:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@GOTFUNCDESC\", file);\n+\t  break;\n+\tcase UNSPEC_GOTOFFFUNCDESC:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@GOTOFFFUNCDESC\", file);\n+\t  break;\n \tdefault:\n \t  return false;\n \t}\n@@ -1854,6 +1877,9 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t    {\n \t    case TLS_MODEL_GLOBAL_DYNAMIC:\n \t      tga_ret = gen_rtx_REG (Pmode, R0_REG);\n+\t      if (TARGET_FDPIC)\n+\t\temit_move_insn (gen_rtx_REG (Pmode, PIC_REG),\n+\t\t\t\tsh_get_fdpic_reg_initial_val ());\n \t      emit_call_insn (gen_tls_global_dynamic (tga_ret, op1));\n \t      tmp = gen_reg_rtx (Pmode);\n \t      emit_move_insn (tmp, tga_ret);\n@@ -1862,6 +1888,9 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \n \t    case TLS_MODEL_LOCAL_DYNAMIC:\n \t      tga_ret = gen_rtx_REG (Pmode, R0_REG);\n+\t      if (TARGET_FDPIC)\n+\t\temit_move_insn (gen_rtx_REG (Pmode, PIC_REG),\n+\t\t\t\tsh_get_fdpic_reg_initial_val ());\n \t      emit_call_insn (gen_tls_local_dynamic (tga_ret, op1));\n \n \t      tmp = gen_reg_rtx (Pmode);\n@@ -1879,6 +1908,9 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t    case TLS_MODEL_INITIAL_EXEC:\n \t      tga_op1 = !can_create_pseudo_p () ? op0 : gen_reg_rtx (Pmode);\n \t      tmp = gen_sym2GOTTPOFF (op1);\n+\t      if (TARGET_FDPIC)\n+\t\temit_move_insn (gen_rtx_REG (Pmode, PIC_REG),\n+\t\t\t\tsh_get_fdpic_reg_initial_val ());\n \t      emit_insn (gen_tls_initial_exec (tga_op1, tmp));\n \t      op1 = tga_op1;\n \t      break;\n@@ -1905,6 +1937,22 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t  operands[1] = op1;\n \t}\n     }\n+\n+  if (SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)\n+    {\n+      rtx base, offset;\n+      split_const (operands[1], &base, &offset);\n+\n+      if (GET_CODE (base) == SYMBOL_REF\n+\t  && !offset_within_block_p (base, INTVAL (offset)))\n+\t{\n+\t  rtx tmp = can_create_pseudo_p () ? gen_reg_rtx (mode) : operands[0];\n+\t  emit_move_insn (tmp, base);\n+\t  if (!arith_operand (offset, mode))\n+\t    offset = force_reg (mode, offset);\n+\t  emit_insn (gen_add3_insn (operands[0], tmp, offset));\n+\t}\n+    }\n }\n \n /* Implement the canonicalize_comparison target hook for the combine\n@@ -3009,6 +3057,24 @@ sh_file_start (void)\n     }\n }\n \f\n+/* Implementation of TARGET_ASM_INTEGER for SH.  Pointers to functions\n+   need to be output as pointers to function descriptors for\n+   FDPIC.  */\n+\n+static bool\n+sh_assemble_integer (rtx value, unsigned int size, int aligned_p)\n+{\n+  if (TARGET_FDPIC && size == UNITS_PER_WORD\n+      && GET_CODE (value) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (value))\n+    {\n+      fputs (\"\\t.long\\t\", asm_out_file);\n+      output_addr_const (asm_out_file, value);\n+      fputs (\"@FUNCDESC\\n\", asm_out_file);\n+      return true;\n+    }\n+  return default_assemble_integer (value, size, aligned_p);\n+}\n+\f\n /* Check if PAT includes UNSPEC_CALLER unspec pattern.  */\n static bool\n unspec_caller_rtx_p (rtx pat)\n@@ -3044,6 +3110,17 @@ sh_cannot_copy_insn_p (rtx_insn *insn)\n     return false;\n \n   pat = PATTERN (insn);\n+\n+  if (GET_CODE (pat) == CLOBBER || GET_CODE (pat) == USE)\n+    return false;\n+\n+  if (TARGET_FDPIC && GET_CODE (pat) == PARALLEL)\n+    {\n+      rtx t = XVECEXP (pat, 0, XVECLEN (pat, 0) - 1);\n+      if (GET_CODE (t) == USE && unspec_caller_rtx_p (XEXP (t, 0)))\n+\treturn true;\n+    }\n+\n   if (GET_CODE (pat) != SET)\n     return false;\n   pat = SET_SRC (pat);\n@@ -4085,8 +4162,8 @@ expand_ashiftrt (rtx *operands)\n   /* Load the value into an arg reg and call a helper.  */\n   emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n   sprintf (func, \"__ashiftrt_r4_%d\", value);\n-  function_symbol (wrk, func, SFUNC_STATIC);\n-  emit_insn (gen_ashrsi3_n (GEN_INT (value), wrk));\n+  rtx lab = function_symbol (wrk, func, SFUNC_STATIC).lab;\n+  emit_insn (gen_ashrsi3_n (GEN_INT (value), wrk, lab));\n   emit_move_insn (operands[0], gen_rtx_REG (SImode, 4));\n   return true;\n }\n@@ -7937,7 +8014,8 @@ sh_expand_prologue (void)\n       stack_usage += d;\n     }\n \n-  if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n+  if (flag_pic && !TARGET_FDPIC\n+      && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n     emit_insn (gen_GOTaddr2picreg (const0_rtx));\n \n   if (SHMEDIA_REGS_STACK_ADJUST ())\n@@ -10438,7 +10516,9 @@ nonpic_symbol_mentioned_p (rtx x)\n \t  || XINT (x, 1) == UNSPEC_PLT\n \t  || XINT (x, 1) == UNSPEC_PCREL\n \t  || XINT (x, 1) == UNSPEC_SYMOFF\n-\t  || XINT (x, 1) == UNSPEC_PCREL_SYMOFF))\n+\t  || XINT (x, 1) == UNSPEC_PCREL_SYMOFF\n+\t  || XINT (x, 1) == UNSPEC_GOTFUNCDESC\n+\t  || XINT (x, 1) == UNSPEC_GOTOFFFUNCDESC))\n     return false;\n \n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n@@ -10473,15 +10553,37 @@ legitimize_pic_address (rtx orig, machine_mode mode ATTRIBUTE_UNUSED,\n       if (reg == NULL_RTX)\n \treg = gen_reg_rtx (Pmode);\n \n-      emit_insn (gen_symGOTOFF2reg (reg, orig));\n+      if (TARGET_FDPIC\n+\t  && GET_CODE (orig) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (orig))\n+\t{\n+\t  /* Weak functions may be NULL which doesn't work with\n+\t     GOTOFFFUNCDESC because the runtime offset is not known.  */\n+\t  if (SYMBOL_REF_WEAK (orig))\n+\t    emit_insn (gen_symGOTFUNCDESC2reg (reg, orig));\n+\t  else\n+\t    emit_insn (gen_symGOTOFFFUNCDESC2reg (reg, orig));\n+\t}\n+      else if (TARGET_FDPIC\n+\t       && (GET_CODE (orig) == LABEL_REF\n+\t\t   || (GET_CODE (orig) == SYMBOL_REF && SYMBOL_REF_DECL (orig)\n+\t\t       && (TREE_READONLY (SYMBOL_REF_DECL (orig))\n+\t\t\t   || SYMBOL_REF_EXTERNAL_P (orig)\n+\t\t\t   || DECL_SECTION_NAME(SYMBOL_REF_DECL (orig))))))\n+\t/* In FDPIC, GOTOFF can only be used for writable data.  */\n+\temit_insn (gen_symGOT2reg (reg, orig));\n+      else\n+\temit_insn (gen_symGOTOFF2reg (reg, orig));\n       return reg;\n     }\n   else if (GET_CODE (orig) == SYMBOL_REF)\n     {\n       if (reg == NULL_RTX)\n \treg = gen_reg_rtx (Pmode);\n \n-      emit_insn (gen_symGOT2reg (reg, orig));\n+      if (TARGET_FDPIC && SYMBOL_REF_FUNCTION_P (orig))\n+\temit_insn (gen_symGOTFUNCDESC2reg (reg, orig));\n+      else\n+\temit_insn (gen_symGOT2reg (reg, orig));\n       return reg;\n     }\n   return orig;\n@@ -11519,8 +11621,39 @@ sh_ms_bitfield_layout_p (const_tree record_type ATTRIBUTE_UNUSED)\n    5 0008 00000000 \tl1:  \t.long   area\n    6 000c 00000000 \tl2:\t.long   function\n \n+   FDPIC needs a form that includes a function descriptor and\n+   code to load the GOT register:\n+   0 0000 00000000\t\t.long\tl0\n+   1 0004 00000000\t\t.long\tgotval\n+   2 0008 D302    \tl0:\tmov.l\tl1,r3\n+   3 000a D203    \t\tmov.l\tl2,r2\n+   4 000c 6122    \t\tmov.l\t@r2,r1\n+   5 000e 5C21    \t\tmov.l\t@(4,r2),r12\n+   6 0010 412B    \t\tjmp\t@r1\n+   7 0012 0009    \t\tnop\n+   8 0014 00000000\tl1:\t.long\tarea\n+   9 0018 00000000\tl2:\t.long\tfunction\n+\n    SH5 (compact) uses r1 instead of r3 for the static chain.  */\n \n+/* Emit insns to store a value at memory address + offset.  */\n+static void\n+sh_emit_storesi (rtx addr, HOST_WIDE_INT offset, rtx value)\n+{\n+  gcc_assert ((offset & 3) == 0);\n+  emit_move_insn (offset == 0\n+\t\t  ? change_address (addr, SImode, NULL_RTX)\n+\t\t  : adjust_address (addr, SImode, offset), value);\n+}\n+\n+/* Emit insns to store w0 at addr + offset and w1 at addr + offset + 2.  */\n+static void\n+sh_emit_storehi (rtx addr, HOST_WIDE_INT offset, uint16_t w0, uint16_t w1)\n+{\n+  sh_emit_storesi (addr, offset, gen_int_mode (TARGET_LITTLE_ENDIAN\n+\t\t\t\t\t       ? (w0 | (w1 << 16))\n+\t\t\t\t\t       : (w1 | (w0 << 16)), SImode));\n+}\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n@@ -11655,20 +11788,34 @@ sh_trampoline_init (rtx tramp_mem, tree fndecl, rtx cxt)\n       emit_insn (gen_initialize_trampoline (tramp, cxt, fnaddr));\n       return;\n     }\n-  emit_move_insn (change_address (tramp_mem, SImode, NULL_RTX),\n-\t\t  gen_int_mode (TARGET_LITTLE_ENDIAN ? 0xd301d202 : 0xd202d301,\n-\t\t\t\tSImode));\n-  emit_move_insn (adjust_address (tramp_mem, SImode, 4),\n-\t\t  gen_int_mode (TARGET_LITTLE_ENDIAN ? 0x0009422b : 0x422b0009,\n-\t\t\t\tSImode));\n-  emit_move_insn (adjust_address (tramp_mem, SImode, 8), cxt);\n-  emit_move_insn (adjust_address (tramp_mem, SImode, 12), fnaddr);\n+  if (TARGET_FDPIC)\n+    {\n+      rtx a = force_reg (Pmode, plus_constant (Pmode, XEXP (tramp_mem, 0), 8));\n+\n+      sh_emit_storesi (tramp_mem, 0, a);\n+      sh_emit_storesi (tramp_mem, 4, sh_get_fdpic_reg_initial_val ());\n+\n+      sh_emit_storehi (tramp_mem,  8, 0xd302, 0xd203);\n+      sh_emit_storehi (tramp_mem, 12, 0x6122, 0x5c21);\n+      sh_emit_storehi (tramp_mem, 16, 0x412b, 0x0009);\n+\n+      sh_emit_storesi (tramp_mem, 20, cxt);\n+      sh_emit_storesi (tramp_mem, 24, fnaddr);\n+    }\n+  else\n+    {\n+      sh_emit_storehi (tramp_mem, 0, 0xd202, 0xd301);\n+      sh_emit_storehi (tramp_mem, 4, 0x422b, 0x0009);\n+\n+      sh_emit_storesi (tramp_mem,  8, cxt);\n+      sh_emit_storesi (tramp_mem, 12, fnaddr);\n+    }\n   if (TARGET_HARD_SH4 || TARGET_SH5)\n     {\n       if (!TARGET_INLINE_IC_INVALIDATE\n \t  || (!(TARGET_SH4A || TARGET_SH4_300) && TARGET_USERMODE))\n \temit_library_call (function_symbol (NULL, \"__ic_invalidate\",\n-\t\t\t\t\t    FUNCTION_ORDINARY),\n+\t\t\t\t\t    FUNCTION_ORDINARY).sym,\n \t\t\t   LCT_NORMAL, VOIDmode, 1, tramp, SImode);\n       else\n \temit_insn (gen_ic_invalidate_line (tramp));\n@@ -11698,7 +11845,7 @@ sh_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n \t  && (! TARGET_SHCOMPACT\n \t      || crtl->args.info.stack_regs == 0)\n \t  && ! sh_cfun_interrupt_handler_p ()\n-\t  && (! flag_pic\n+\t  && (! flag_pic || TARGET_FDPIC\n \t      || (decl && ! (TREE_PUBLIC (decl) || DECL_WEAK (decl)))\n \t      || (decl && DECL_VISIBILITY (decl) != VISIBILITY_DEFAULT)));\n }\n@@ -11712,7 +11859,7 @@ sh_expand_sym_label2reg (rtx reg, rtx sym, rtx lab, bool sibcall_p)\n \n   if (!is_weak && SYMBOL_REF_LOCAL_P (sym))\n     emit_insn (gen_sym_label2reg (reg, sym, lab));\n-  else if (sibcall_p)\n+  else if (sibcall_p && SYMBOL_REF_LOCAL_P (sym))\n     emit_insn (gen_symPCREL_label2reg (reg, sym, lab));\n   else\n     emit_insn (gen_symPLT_label2reg (reg, sym, lab));\n@@ -12715,8 +12862,16 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n #endif\n   if (TARGET_SH2 && flag_pic)\n     {\n-      sibcall = gen_sibcall_pcrel (funexp, const0_rtx);\n-      XEXP (XVECEXP (sibcall, 0, 2), 0) = scratch2;\n+      if (TARGET_FDPIC)\n+\t{\n+\t  sibcall = gen_sibcall_pcrel_fdpic (funexp, const0_rtx);\n+\t  XEXP (XVECEXP (sibcall, 0, 3), 0) = scratch2;\n+\t}\n+      else\n+\t{\n+\t  sibcall = gen_sibcall_pcrel (funexp, const0_rtx);\n+\t  XEXP (XVECEXP (sibcall, 0, 2), 0) = scratch2;\n+\t}\n     }\n   else\n     {\n@@ -12757,17 +12912,25 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   epilogue_completed = 0;\n }\n \n-rtx\n-function_symbol (rtx target, const char *name, enum sh_function_kind kind)\n-{\n-  rtx sym;\n+/* Return an RTX pair for the address and call site label of a function\n+   NAME of kind KIND, placing the result in TARGET if not NULL.  For\n+   SFUNC_STATIC, if FDPIC, the LAB member of result will be set to\n+   (const_int 0) if jsr should be used, or a label_ref if bsrf should\n+   be used.  For FDPIC, both SFUNC_GOT and SFUNC_STATIC will return the\n+   address of the function itself, not a function descriptor, so they\n+   can only be used with functions not using the FDPIC register that\n+   are known to be called directory without a PLT entry.  */\n \n+function_symbol_result\n+function_symbol (rtx target, const char *name, sh_function_kind kind)\n+{\n   /* If this is not an ordinary function, the name usually comes from a\n      string literal or an sprintf buffer.  Make sure we use the same\n      string consistently, so that cse will be able to unify address loads.  */\n   if (kind != FUNCTION_ORDINARY)\n     name = IDENTIFIER_POINTER (get_identifier (name));\n-  sym = gen_rtx_SYMBOL_REF (Pmode, name);\n+  rtx sym = gen_rtx_SYMBOL_REF (Pmode, name);\n+  rtx lab = const0_rtx;\n   SYMBOL_REF_FLAGS (sym) = SYMBOL_FLAG_FUNCTION;\n   if (flag_pic)\n     switch (kind)\n@@ -12784,24 +12947,35 @@ function_symbol (rtx target, const char *name, enum sh_function_kind kind)\n \t}\n       case SFUNC_STATIC:\n \t{\n-\t  /* ??? To allow cse to work, we use GOTOFF relocations.\n-\t     We could add combiner patterns to transform this into\n-\t     straight pc-relative calls with sym2PIC / bsrf when\n-\t     label load and function call are still 1:1 and in the\n-\t     same basic block during combine.  */\n \t  rtx reg = target ? target : gen_reg_rtx (Pmode);\n \n-\t  emit_insn (gen_symGOTOFF2reg (reg, sym));\n+\t  if (TARGET_FDPIC)\n+\t    {\n+\t      /* We use PC-relative calls, since GOTOFF can only refer\n+\t\t to writable data.  This works along with sh_sfunc_call.  */\n+ \t      lab = PATTERN (gen_call_site ());\n+\t      emit_insn (gen_sym_label2reg (reg, sym, lab));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* ??? To allow cse to work, we use GOTOFF relocations.\n+\t\t we could add combiner patterns to transform this into\n+\t\t straight pc-relative calls with sym2PIC / bsrf when\n+\t\t label load and function call are still 1:1 and in the\n+\t\t same basic block during combine.  */\n+\t      emit_insn (gen_symGOTOFF2reg (reg, sym));\n+\t    }\n+\n \t  sym = reg;\n \t  break;\n \t}\n       }\n   if (target && sym != target)\n     {\n       emit_move_insn (target, sym);\n-      return target;\n+      return function_symbol_result (target, lab);\n     }\n-  return sym;\n+  return function_symbol_result (sym, lab);\n }\n \n /* Find the number of a general purpose register in S.  */\n@@ -13414,6 +13588,12 @@ sh_conditional_register_usage (void)\n       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n       call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n     }\n+  if (TARGET_FDPIC)\n+    {\n+      fixed_regs[PIC_REG] = 1;\n+      call_used_regs[PIC_REG] = 1;\n+      call_really_used_regs[PIC_REG] = 1;\n+    }\n   /* Renesas saves and restores mac registers on call.  */\n   if (TARGET_HITACHI && ! TARGET_NOMACSAVE)\n     {\n@@ -13442,14 +13622,32 @@ sh_conditional_register_usage (void)\n static bool\n sh_legitimate_constant_p (machine_mode mode, rtx x)\n {\n-  return (TARGET_SHMEDIA\n-\t  ? ((mode != DFmode && GET_MODE_CLASS (mode) != MODE_VECTOR_FLOAT)\n-\t     || x == CONST0_RTX (mode)\n-\t     || !TARGET_SHMEDIA_FPU\n-\t     || TARGET_SHMEDIA64)\n-\t  : (GET_CODE (x) != CONST_DOUBLE\n-\t     || mode == DFmode || mode == SFmode\n-\t     || mode == DImode || GET_MODE (x) == VOIDmode));\n+  if (SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)\n+    {\n+      rtx base, offset;\n+      split_const (x, &base, &offset);\n+\n+      if (GET_CODE (base) == SYMBOL_REF\n+\t  && !offset_within_block_p (base, INTVAL (offset)))\n+       return false;\n+    }\n+\n+  if (TARGET_FDPIC\n+      && (SYMBOLIC_CONST_P (x)\n+\t  || (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n+\t      && SYMBOLIC_CONST_P (XEXP (XEXP (x, 0), 0)))))\n+    return false;\n+\n+  if (TARGET_SHMEDIA\n+      && ((mode != DFmode && GET_MODE_CLASS (mode) != MODE_VECTOR_FLOAT)\n+\t  || x == CONST0_RTX (mode)\n+\t  || !TARGET_SHMEDIA_FPU\n+\t  || TARGET_SHMEDIA64))\n+    return false;\n+\n+  return GET_CODE (x) != CONST_DOUBLE\n+\t || mode == DFmode || mode == SFmode\n+\t || mode == DImode || GET_MODE (x) == VOIDmode;\n }\n \n enum sh_divide_strategy_e sh_div_strategy = SH_DIV_STRATEGY_DEFAULT;\n@@ -14540,4 +14738,41 @@ sh_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,\n     }\n }\n \n+bool\n+sh_cannot_force_const_mem_p (machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     rtx x ATTRIBUTE_UNUSED)\n+{\n+  return TARGET_FDPIC;\n+}\n+\n+/* Emit insns to load the function address from FUNCDESC (an FDPIC\n+   function descriptor) into r1 and the GOT address into r12,\n+   returning an rtx for r1.  */\n+\n+rtx\n+sh_load_function_descriptor (rtx funcdesc)\n+{\n+  rtx r1 = gen_rtx_REG (Pmode, R1_REG);\n+  rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);\n+  rtx fnaddr = gen_rtx_MEM (Pmode, funcdesc);\n+  rtx gotaddr = gen_rtx_MEM (Pmode, plus_constant (Pmode, funcdesc, 4));\n+\n+  emit_move_insn (r1, fnaddr);\n+  /* The ABI requires the entry point address to be loaded first, so\n+     prevent the load from being moved after that of the GOT\n+     address.  */\n+  emit_insn (gen_blockage ());\n+  emit_move_insn (pic_reg, gotaddr);\n+  return r1;\n+}\n+\n+/* Return an rtx holding the initial value of the FDPIC register (the\n+   FDPIC pointer passed in from the caller).  */\n+\n+rtx\n+sh_get_fdpic_reg_initial_val (void)\n+{\n+  return get_hard_reg_initial_val (Pmode, PIC_REG);\n+}\n+\n #include \"gt-sh.h\""}, {"sha": "e6d63363fc60b50774e759ad8d9b07c9c1898b7b", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -316,7 +316,7 @@ extern int code_for_indirect_jump_scratch;\n #endif\n \n #ifndef SUBTARGET_ASM_SPEC\n-#define SUBTARGET_ASM_SPEC \"\"\n+#define SUBTARGET_ASM_SPEC \"%{mfdpic:--fdpic}\"\n #endif\n \n #if TARGET_ENDIAN_DEFAULT == MASK_LITTLE_ENDIAN\n@@ -344,7 +344,7 @@ extern int code_for_indirect_jump_scratch;\n #define ASM_ISA_DEFAULT_SPEC \"\"\n #endif /* MASK_SH5 */\n \n-#define SUBTARGET_LINK_EMUL_SUFFIX \"\"\n+#define SUBTARGET_LINK_EMUL_SUFFIX \"%{mfdpic:_fd}\"\n #define SUBTARGET_LINK_SPEC \"\"\n \n /* Go via SH_LINK_SPEC to avoid code replication.  */\n@@ -378,8 +378,18 @@ extern int code_for_indirect_jump_scratch;\n \"%{m2a*:%eSH2a does not support little-endian}}\"\n #endif\n \n+#ifdef FDPIC_DEFAULT\n+#define FDPIC_SELF_SPECS \"%{!mno-fdpic:-mfdpic}\"\n+#else\n+#define FDPIC_SELF_SPECS\n+#endif\n+\n #undef DRIVER_SELF_SPECS\n-#define DRIVER_SELF_SPECS UNSUPPORTED_SH2A\n+#define DRIVER_SELF_SPECS UNSUPPORTED_SH2A SUBTARGET_DRIVER_SELF_SPECS \\\n+  FDPIC_SELF_SPECS\n+\n+#undef SUBTARGET_DRIVER_SELF_SPECS\n+#define SUBTARGET_DRIVER_SELF_SPECS\n \n #define ASSEMBLER_DIALECT assembler_dialect\n \n@@ -937,6 +947,10 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    code access to data items.  */\n #define PIC_OFFSET_TABLE_REGNUM\t(flag_pic ? PIC_REG : INVALID_REGNUM)\n \n+/* For FDPIC, the FDPIC register is call-clobbered (otherwise PLT\n+   entries would need to handle saving and restoring it).  */\n+#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED TARGET_FDPIC\n+\n #define GOT_SYMBOL_NAME \"*_GLOBAL_OFFSET_TABLE_\"\n \n /* Definitions for register eliminations.\n@@ -1561,7 +1575,8 @@ struct sh_args {\n    6 000c 00000000 \tl2:\t.long   function  */\n \n /* Length in units of the trampoline for entering a nested function.  */\n-#define TRAMPOLINE_SIZE  (TARGET_SHMEDIA64 ? 40 : TARGET_SH5 ? 24 : 16)\n+#define TRAMPOLINE_SIZE \\\n+  (TARGET_SHMEDIA64 ? 40 : TARGET_SH5 ? 24 : TARGET_FDPIC ? 32 : 16)\n \n /* Alignment required for a trampoline in bits.  */\n #define TRAMPOLINE_ALIGNMENT \\\n@@ -1617,6 +1632,10 @@ struct sh_args {\n       || GENERAL_REGISTER_P ((unsigned) reg_renumber[(REGNO)])) \\\n    : (REGNO) == R0_REG || (unsigned) reg_renumber[(REGNO)] == R0_REG)\n \n+/* True if SYMBOL + OFFSET constants must refer to something within\n+   SYMBOL's section.  */\n+#define SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P TARGET_FDPIC\n+\n /* Maximum number of registers that can appear in a valid memory\n    address.  */\n #define MAX_REGS_PER_ADDRESS 2\n@@ -2257,9 +2276,11 @@ extern int current_function_interrupt;\n /* We have to distinguish between code and data, so that we apply\n    datalabel where and only where appropriate.  Use sdataN for data.  */\n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \\\n- ((flag_pic && (GLOBAL) ? DW_EH_PE_indirect : 0) \\\n-  | (flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr) \\\n-  | ((CODE) ? 0 : (TARGET_SHMEDIA64 ? DW_EH_PE_sdata8 : DW_EH_PE_sdata4)))\n+  ((TARGET_FDPIC \\\n+    ? ((GLOBAL) ? DW_EH_PE_indirect | DW_EH_PE_datarel : DW_EH_PE_pcrel) \\\n+    : ((flag_pic && (GLOBAL) ? DW_EH_PE_indirect : 0) \\\n+       | (flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr))) \\\n+   | ((CODE) ? 0 : (TARGET_SHMEDIA64 ? DW_EH_PE_sdata8 : DW_EH_PE_sdata4)))\n \n /* Handle special EH pointer encodings.  Absolute, pc-relative, and\n    indirect are handled automatically.  */\n@@ -2272,6 +2293,17 @@ extern int current_function_interrupt;\n \tSYMBOL_REF_FLAGS (ADDR) |= SYMBOL_FLAG_FUNCTION; \\\n \tif (0) goto DONE; \\\n       } \\\n+    if (TARGET_FDPIC \\\n+\t&& ((ENCODING) & 0xf0) == (DW_EH_PE_indirect | DW_EH_PE_datarel)) \\\n+      { \\\n+\tfputs (\"\\t.ualong \", FILE); \\\n+\toutput_addr_const (FILE, ADDR); \\\n+\tif (GET_CODE (ADDR) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (ADDR)) \\\n+\t  fputs (\"@GOTFUNCDESC\", FILE); \\\n+\telse \\\n+\t  fputs (\"@GOT\", FILE); \\\n+\tgoto DONE; \\\n+      } \\\n   } while (0)\n \n #if (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__"}, {"sha": "557a0f0ff5f6ef9cc1ede0ef0e8833d244dcc884", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 394, "deletions": 86, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -170,6 +170,9 @@\n   UNSPEC_SYMOFF\n   ;; (unspec [OFFSET ANCHOR] UNSPEC_PCREL_SYMOFF) == OFFSET - (ANCHOR - .).\n   UNSPEC_PCREL_SYMOFF\n+  ;; For FDPIC\n+  UNSPEC_GOTFUNCDESC\n+  UNSPEC_GOTOFFFUNCDESC\n   ;; Misc builtins\n   UNSPEC_BUILTIN_STRLEN\n ])\n@@ -2591,15 +2594,18 @@\n ;; This reload would clobber the value in r0 we are trying to store.\n ;; If we let reload allocate r0, then this problem can never happen.\n (define_insn \"udivsi3_i1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=z,z\")\n \t(udiv:SI (reg:SI R4_REG) (reg:SI R5_REG)))\n    (clobber (reg:SI T_REG))\n    (clobber (reg:SI PR_REG))\n    (clobber (reg:SI R1_REG))\n    (clobber (reg:SI R4_REG))\n-   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r,r\"))\n+   (use (match_operand 2 \"\" \"Z,Ccl\"))]\n   \"TARGET_SH1 && TARGET_DIVIDE_CALL_DIV1\"\n-  \"jsr\t@%1%#\"\n+  \"@\n+\tjsr\t@%1%#\n+\tbsrf\t%1\\n%O2:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n@@ -2648,7 +2654,7 @@\n })\n \n (define_insn \"udivsi3_i4\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y,y\")\n \t(udiv:SI (reg:SI R4_REG) (reg:SI R5_REG)))\n    (clobber (reg:SI T_REG))\n    (clobber (reg:SI PR_REG))\n@@ -2660,16 +2666,19 @@\n    (clobber (reg:SI R4_REG))\n    (clobber (reg:SI R5_REG))\n    (clobber (reg:SI FPSCR_STAT_REG))\n-   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r,r\"))\n+   (use (match_operand 2 \"\" \"Z,Ccl\"))\n    (use (reg:SI FPSCR_MODES_REG))]\n   \"TARGET_FPU_DOUBLE && ! TARGET_FPU_SINGLE\"\n-  \"jsr\t@%1%#\"\n+  \"@\n+\tjsr\t@%1%#\n+\tbsrf\t%1\\n%O2:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"fp_mode\" \"double\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_insn \"udivsi3_i4_single\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y,y\")\n \t(udiv:SI (reg:SI R4_REG) (reg:SI R5_REG)))\n    (clobber (reg:SI T_REG))\n    (clobber (reg:SI PR_REG))\n@@ -2680,10 +2689,13 @@\n    (clobber (reg:SI R1_REG))\n    (clobber (reg:SI R4_REG))\n    (clobber (reg:SI R5_REG))\n-   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r,r\"))\n+   (use (match_operand 2 \"\" \"Z,Ccl\"))]\n   \"(TARGET_FPU_SINGLE_ONLY || TARGET_FPU_DOUBLE || TARGET_SHCOMPACT)\n    && TARGET_FPU_SINGLE\"\n-  \"jsr\t@%1%#\"\n+  \"@\n+\tjsr\t@%1%#\n+\tbsrf\t%1\\n%O2:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n@@ -2742,11 +2754,11 @@\n     }\n   else if (TARGET_DIVIDE_CALL_FP)\n     {\n-      function_symbol (operands[3], \"__udivsi3_i4\", SFUNC_STATIC);\n+      rtx lab = function_symbol (operands[3], \"__udivsi3_i4\", SFUNC_STATIC).lab;\n       if (TARGET_FPU_SINGLE)\n-\tlast = gen_udivsi3_i4_single (operands[0], operands[3]);\n+\tlast = gen_udivsi3_i4_single (operands[0], operands[3], lab);\n       else\n-\tlast = gen_udivsi3_i4 (operands[0], operands[3]);\n+\tlast = gen_udivsi3_i4 (operands[0], operands[3], lab);\n     }\n   else if (TARGET_SHMEDIA_FPU)\n     {\n@@ -2771,14 +2783,14 @@\n       if (TARGET_SHMEDIA)\n \tlast = gen_udivsi3_i1_media (operands[0], operands[3]);\n       else if (TARGET_FPU_ANY)\n-\tlast = gen_udivsi3_i4_single (operands[0], operands[3]);\n+\tlast = gen_udivsi3_i4_single (operands[0], operands[3], const0_rtx);\n       else\n-\tlast = gen_udivsi3_i1 (operands[0], operands[3]);\n+\tlast = gen_udivsi3_i1 (operands[0], operands[3], const0_rtx);\n     }\n   else\n     {\n-      function_symbol (operands[3], \"__udivsi3\", SFUNC_STATIC);\n-      last = gen_udivsi3_i1 (operands[0], operands[3]);\n+      rtx lab = function_symbol (operands[3], \"__udivsi3\", SFUNC_STATIC).lab;\n+      last = gen_udivsi3_i1 (operands[0], operands[3], lab);\n     }\n   emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n   emit_move_insn (gen_rtx_REG (SImode, 5), operands[2]);\n@@ -2906,7 +2918,7 @@\n       emit_move_insn (gen_rtx_REG (DImode, R20_REG), x);\n       break;\n     }\n-  sym = function_symbol (NULL, name, kind);\n+  sym = function_symbol (NULL, name, kind).sym;\n   emit_insn (gen_divsi3_media_2 (operands[0], sym));\n   DONE;\n }\n@@ -2926,31 +2938,37 @@\n })\n \n (define_insn \"divsi3_i4\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y,y\")\n \t(div:SI (reg:SI R4_REG) (reg:SI R5_REG)))\n    (clobber (reg:SI PR_REG))\n    (clobber (reg:DF DR0_REG))\n    (clobber (reg:DF DR2_REG))\n    (clobber (reg:SI FPSCR_STAT_REG))\n-   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r,r\"))\n+   (use (match_operand 2 \"\" \"Z,Ccl\"))\n    (use (reg:SI FPSCR_MODES_REG))]\n   \"TARGET_FPU_DOUBLE && ! TARGET_FPU_SINGLE\"\n-  \"jsr\t@%1%#\"\n+  \"@\n+\tjsr\t@%1%#\n+\tbsrf\t%1\\n%O2:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"fp_mode\" \"double\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_insn \"divsi3_i4_single\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y,y\")\n \t(div:SI (reg:SI R4_REG) (reg:SI R5_REG)))\n    (clobber (reg:SI PR_REG))\n    (clobber (reg:DF DR0_REG))\n    (clobber (reg:DF DR2_REG))\n    (clobber (reg:SI R2_REG))\n-   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r,r\"))\n+   (use (match_operand 2 \"\" \"Z,Ccl\"))]\n   \"(TARGET_FPU_SINGLE_ONLY || TARGET_FPU_DOUBLE || TARGET_SHCOMPACT)\n    && TARGET_FPU_SINGLE\"\n-  \"jsr\t@%1%#\"\n+  \"@\n+\tjsr\t@%1%#\n+\tbsrf\t%1\\n%O2:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n@@ -2994,11 +3012,12 @@\n     }\n   else if (TARGET_DIVIDE_CALL_FP)\n     {\n-      function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_STATIC);\n+      rtx lab = function_symbol (operands[3], sh_divsi3_libfunc,\n+\t\t\t\t SFUNC_STATIC).lab;\n       if (TARGET_FPU_SINGLE)\n-\tlast = gen_divsi3_i4_single (operands[0], operands[3]);\n+\tlast = gen_divsi3_i4_single (operands[0], operands[3], lab);\n       else\n-\tlast = gen_divsi3_i4 (operands[0], operands[3]);\n+\tlast = gen_divsi3_i4 (operands[0], operands[3], lab);\n     }\n   else if (TARGET_SH2A)\n     {\n@@ -3113,7 +3132,7 @@\n \tlast = ((TARGET_DIVIDE_CALL2 ? gen_divsi3_media_2 : gen_divsi3_i1_media)\n \t\t(operands[0], operands[3]));\n       else if (TARGET_FPU_ANY)\n-\tlast = gen_divsi3_i4_single (operands[0], operands[3]);\n+\tlast = gen_divsi3_i4_single (operands[0], operands[3], const0_rtx);\n       else\n \tlast = gen_divsi3_i1 (operands[0], operands[3]);\n     }\n@@ -3713,7 +3732,7 @@ label:\n     {\n       /* The address must be set outside the libcall,\n \t since it goes into a pseudo.  */\n-      rtx sym = function_symbol (NULL, \"__mulsi3\", SFUNC_STATIC);\n+      rtx sym = function_symbol (NULL, \"__mulsi3\", SFUNC_STATIC).sym;\n       rtx addr = force_reg (SImode, sym);\n       rtx insns = gen_mulsi3_call (operands[0], operands[1],\n \t\t\t\t   operands[2], addr);\n@@ -4970,8 +4989,8 @@ label:\n     {\n       emit_move_insn (gen_rtx_REG (SImode, R4_REG), operands[1]);\n       rtx funcaddr = gen_reg_rtx (Pmode);\n-      function_symbol (funcaddr, \"__ashlsi3_r0\", SFUNC_STATIC);\n-      emit_insn (gen_ashlsi3_d_call (operands[0], operands[2], funcaddr));\n+      rtx lab = function_symbol (funcaddr, \"__ashlsi3_r0\", SFUNC_STATIC).lab;\n+      emit_insn (gen_ashlsi3_d_call (operands[0], operands[2], funcaddr, lab));\n \n       DONE;\n     }\n@@ -5024,15 +5043,18 @@ label:\n ;; In order to make combine understand the truncation of the shift amount\n ;; operand we have to allow it to use pseudo regs for the shift operands.\n (define_insn \"ashlsi3_d_call\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,z\")\n \t(ashift:SI (reg:SI R4_REG)\n-\t\t   (and:SI (match_operand:SI 1 \"arith_reg_operand\" \"z\")\n+\t\t   (and:SI (match_operand:SI 1 \"arith_reg_operand\" \"z,z\")\n \t\t\t   (const_int 31))))\n-   (use (match_operand:SI 2 \"arith_reg_operand\" \"r\"))\n+   (use (match_operand:SI 2 \"arith_reg_operand\" \"r,r\"))\n+   (use (match_operand 3 \"\" \"Z,Ccl\"))\n    (clobber (reg:SI T_REG))\n    (clobber (reg:SI PR_REG))]\n   \"TARGET_SH1 && !TARGET_DYNSHIFT\"\n-  \"jsr\t@%2%#\"\n+  \"@\n+\tjsr\t@%2%#\n+\tbsrf\t%2\\n%O3:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n@@ -5374,12 +5396,15 @@ label:\n (define_insn \"ashrsi3_n\"\n   [(set (reg:SI R4_REG)\n \t(ashiftrt:SI (reg:SI R4_REG)\n-\t\t     (match_operand:SI 0 \"const_int_operand\" \"i\")))\n+\t\t     (match_operand:SI 0 \"const_int_operand\" \"i,i\")))\n    (clobber (reg:SI T_REG))\n    (clobber (reg:SI PR_REG))\n-   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r,r\"))\n+   (use (match_operand 2 \"\" \"Z,Ccl\"))]\n   \"TARGET_SH1\"\n-  \"jsr\t@%1%#\"\n+  \"@\n+\tjsr\t@%1%#\n+\tbsrf\t%1\\n%O2:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n@@ -5532,8 +5557,8 @@ label:\n     {\n       emit_move_insn (gen_rtx_REG (SImode, R4_REG), operands[1]);\n       rtx funcaddr = gen_reg_rtx (Pmode);\n-      function_symbol (funcaddr, \"__lshrsi3_r0\", SFUNC_STATIC);\n-      emit_insn (gen_lshrsi3_d_call (operands[0], operands[2], funcaddr));\n+      rtx lab = function_symbol (funcaddr, \"__lshrsi3_r0\", SFUNC_STATIC).lab;\n+      emit_insn (gen_lshrsi3_d_call (operands[0], operands[2], funcaddr, lab));\n       DONE;\n     }\n })\n@@ -5585,15 +5610,18 @@ label:\n ;; In order to make combine understand the truncation of the shift amount\n ;; operand we have to allow it to use pseudo regs for the shift operands.\n (define_insn \"lshrsi3_d_call\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,z\")\n \t(lshiftrt:SI (reg:SI R4_REG)\n-\t\t     (and:SI (match_operand:SI 1 \"arith_reg_operand\" \"z\")\n+\t\t     (and:SI (match_operand:SI 1 \"arith_reg_operand\" \"z,z\")\n \t\t\t     (const_int 31))))\n-   (use (match_operand:SI 2 \"arith_reg_operand\" \"r\"))\n+   (use (match_operand:SI 2 \"arith_reg_operand\" \"r,r\"))\n+   (use (match_operand 3 \"\" \"Z,Ccl\"))\n    (clobber (reg:SI T_REG))\n    (clobber (reg:SI PR_REG))]\n   \"TARGET_SH1 && !TARGET_DYNSHIFT\"\n-  \"jsr\t@%2%#\"\n+  \"@\n+\tjsr\t@%2%#\n+\tbsrf\t%2\\n%O3:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n@@ -7315,7 +7343,7 @@ label:\n     }\n   else if (TARGET_SHCOMPACT)\n     {\n-      operands[1] = function_symbol (NULL, \"__ic_invalidate\", SFUNC_STATIC);\n+      operands[1] = function_symbol (NULL, \"__ic_invalidate\", SFUNC_STATIC).sym;\n       operands[1] = force_reg (Pmode, operands[1]);\n       emit_insn (gen_ic_invalidate_line_compact (operands[0], operands[1]));\n       DONE;\n@@ -7397,7 +7425,7 @@ label:\n \n   tramp = force_reg (Pmode, operands[0]);\n   sfun = force_reg (Pmode, function_symbol (NULL, \"__init_trampoline\",\n-\t\t\t\t\t    SFUNC_STATIC));\n+\t\t\t\t\t    SFUNC_STATIC).sym);\n   emit_move_insn (gen_rtx_REG (SImode, R2_REG), operands[1]);\n   emit_move_insn (gen_rtx_REG (SImode, R3_REG), operands[2]);\n \n@@ -9455,9 +9483,29 @@ label:\n \t (match_operand 1 \"\" \"\"))\n    (use (reg:SI FPSCR_MODES_REG))\n    (clobber (reg:SI PR_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && !TARGET_FDPIC\"\n {\n-  if (TARGET_SH2A && (dbr_sequence_length () == 0))\n+  if (TARGET_SH2A && dbr_sequence_length () == 0)\n+    return \"jsr/n\t@%0\";\n+  else\n+    return \"jsr\t@%0%#\";\n+}\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"fp_set\" \"unknown\")])\n+\n+(define_insn \"calli_fdpic\"\n+  [(call (mem:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t (match_operand 1))\n+   (use (reg:SI FPSCR_MODES_REG))\n+   (use (reg:SI PIC_REG))\n+   (clobber (reg:SI PR_REG))]\n+  \"TARGET_FDPIC\"\n+{\n+  if (TARGET_SH2A && dbr_sequence_length () == 0)\n     return \"jsr/n\t@%0\";\n   else\n     return \"jsr\t@%0%#\";\n@@ -9584,9 +9632,30 @@ label:\n \t      (match_operand 2 \"\" \"\")))\n    (use (reg:SI FPSCR_MODES_REG))\n    (clobber (reg:SI PR_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && !TARGET_FDPIC\"\n+{\n+  if (TARGET_SH2A && dbr_sequence_length () == 0)\n+    return \"jsr/n\t@%1\";\n+  else\n+    return \"jsr\t@%1%#\";\n+}\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"fp_set\" \"unknown\")])\n+\n+(define_insn \"call_valuei_fdpic\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t      (match_operand 2)))\n+   (use (reg:SI FPSCR_REG))\n+   (use (reg:SI PIC_REG))\n+   (clobber (reg:SI PR_REG))]\n+  \"TARGET_FDPIC\"\n {\n-  if (TARGET_SH2A && (dbr_sequence_length () == 0))\n+  if (TARGET_SH2A && dbr_sequence_length () == 0)\n     return \"jsr/n\t@%1\";\n   else\n     return \"jsr\t@%1%#\";\n@@ -9721,6 +9790,12 @@ label:\n \t      (clobber (reg:SI PR_REG))])]\n   \"\"\n {\n+  if (TARGET_FDPIC)\n+    {\n+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);\n+      emit_move_insn (pic_reg, sh_get_fdpic_reg_initial_val ());\n+    }\n+\n   if (TARGET_SHMEDIA)\n     {\n       operands[0] = shmedia_prepare_call_address (operands[0], 0);\n@@ -9755,8 +9830,8 @@ label:\n \t run out of registers when adjusting fpscr for the call.  */\n       emit_insn (gen_force_mode_for_call ());\n \n-      operands[0]\n-\t= function_symbol (NULL, \"__GCC_shcompact_call_trampoline\", SFUNC_GOT);\n+      operands[0] = function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",\n+\t\t\t\t     SFUNC_GOT).sym;\n       operands[0] = force_reg (SImode, operands[0]);\n \n       emit_move_insn (r0, func);\n@@ -9804,7 +9879,13 @@ label:\n     operands[1] = operands[2];\n   }\n \n-  emit_call_insn (gen_calli (operands[0], operands[1]));\n+  if (TARGET_FDPIC)\n+    {\n+      operands[0] = sh_load_function_descriptor (operands[0]);\n+      emit_call_insn (gen_calli_fdpic (operands[0], operands[1]));\n+    }\n+  else\n+    emit_call_insn (gen_calli (operands[0], operands[1]));\n   DONE;\n })\n \n@@ -9884,7 +9965,7 @@ label:\n   emit_insn (gen_force_mode_for_call ());\n \n   operands[0] = function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",\n-\t\t\t\t SFUNC_GOT);\n+\t\t\t\t SFUNC_GOT).sym;\n   operands[0] = force_reg (SImode, operands[0]);\n \n   emit_move_insn (r0, func);\n@@ -9909,6 +9990,12 @@ label:\n \t      (clobber (reg:SI PR_REG))])]\n   \"\"\n {\n+  if (TARGET_FDPIC)\n+    {\n+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);\n+      emit_move_insn (pic_reg, sh_get_fdpic_reg_initial_val ());\n+    }\n+\n   if (TARGET_SHMEDIA)\n     {\n       operands[1] = shmedia_prepare_call_address (operands[1], 0);\n@@ -9944,8 +10031,8 @@ label:\n \t run out of registers when adjusting fpscr for the call.  */\n       emit_insn (gen_force_mode_for_call ());\n \n-      operands[1]\n-\t= function_symbol (NULL, \"__GCC_shcompact_call_trampoline\", SFUNC_GOT);\n+      operands[1] = function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",\n+\t\t\t\t     SFUNC_GOT).sym;\n       operands[1] = force_reg (SImode, operands[1]);\n \n       emit_move_insn (r0, func);\n@@ -9993,7 +10080,14 @@ label:\n   else\n     operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n \n-  emit_call_insn (gen_call_valuei (operands[0], operands[1], operands[2]));\n+  if (TARGET_FDPIC)\n+    {\n+      operands[1] = sh_load_function_descriptor (operands[1]);\n+      emit_call_insn (gen_call_valuei_fdpic (operands[0], operands[1],\n+\t\t\t\t\t     operands[2]));\n+    }\n+  else\n+    emit_call_insn (gen_call_valuei (operands[0], operands[1], operands[2]));\n   DONE;\n })\n \n@@ -10002,7 +10096,21 @@ label:\n \t (match_operand 1 \"\" \"\"))\n    (use (reg:SI FPSCR_MODES_REG))\n    (return)]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && !TARGET_FDPIC\"\n+  \"jmp\t@%0%#\"\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n+(define_insn \"sibcalli_fdpic\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"k\"))\n+\t (match_operand 1))\n+   (use (reg:SI FPSCR_MODES_REG))\n+   (use (reg:SI PIC_REG))\n+   (return)]\n+  \"TARGET_FDPIC\"\n   \"jmp\t@%0%#\"\n   [(set_attr \"needs_delay_slot\" \"yes\")\n    (set (attr \"fp_mode\")\n@@ -10016,7 +10124,25 @@ label:\n    (use (match_operand 2 \"\" \"\"))\n    (use (reg:SI FPSCR_MODES_REG))\n    (return)]\n-  \"TARGET_SH2\"\n+  \"TARGET_SH2 && !TARGET_FDPIC\"\n+{\n+  return       \"braf\t%0\"\t\"\\n\"\n+\t \"%O2:%#\";\n+}\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n+(define_insn \"sibcalli_pcrel_fdpic\"\n+  [(call (mem:SI (match_operand:SI 0 \"arith_reg_operand\" \"k\"))\n+\t (match_operand 1))\n+   (use (match_operand 2))\n+   (use (reg:SI FPSCR_MODES_REG))\n+   (use (reg:SI PIC_REG))\n+   (return)]\n+  \"TARGET_SH2 && TARGET_FDPIC\"\n {\n   return       \"braf\t%0\"\t\"\\n\"\n \t \"%O2:%#\";\n@@ -10049,7 +10175,7 @@ label:\n    (use (reg:SI FPSCR_MODES_REG))\n    (clobber (match_scratch:SI 2 \"=&k\"))\n    (return)]\n-  \"TARGET_SH2\"\n+  \"TARGET_SH2 && !TARGET_FDPIC\"\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n@@ -10069,6 +10195,32 @@ label:\n \t\t      (const_string \"single\") (const_string \"double\")))\n    (set_attr \"type\" \"jump_ind\")])\n \n+(define_insn_and_split \"sibcall_pcrel_fdpic\"\n+  [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\"))\n+\t (match_operand 1))\n+   (use (reg:SI FPSCR_MODES_REG))\n+   (use (reg:SI PIC_REG))\n+   (clobber (match_scratch:SI 2 \"=k\"))\n+   (return)]\n+  \"TARGET_SH2 && TARGET_FDPIC\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx lab = PATTERN (gen_call_site ());\n+\n+  sh_expand_sym_label2reg (operands[2], operands[0], lab, true);\n+  rtx i = emit_call_insn (gen_sibcalli_pcrel_fdpic (operands[2], operands[1],\n+\t\t\t\t\t\t    copy_rtx (lab)));\n+  SIBLING_CALL_P (i) = 1;\n+  DONE;\n+}\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n (define_insn \"sibcall_compact\"\n   [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"k,k\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -10113,6 +10265,12 @@ label:\n      (return)])]\n   \"\"\n {\n+  if (TARGET_FDPIC)\n+    {\n+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);\n+      emit_move_insn (pic_reg, sh_get_fdpic_reg_initial_val ());\n+    }\n+\n   if (TARGET_SHMEDIA)\n     {\n       operands[0] = shmedia_prepare_call_address (operands[0], 1);\n@@ -10157,8 +10315,8 @@ label:\n \t run out of registers when adjusting fpscr for the call.  */\n       emit_insn (gen_force_mode_for_call ());\n \n-      operands[0]\n-\t= function_symbol (NULL, \"__GCC_shcompact_call_trampoline\", SFUNC_GOT);\n+      operands[0] = function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",\n+\t\t\t\t     SFUNC_GOT).sym;\n       operands[0] = force_reg (SImode, operands[0]);\n \n       /* We don't need a return trampoline, since the callee will\n@@ -10192,13 +10350,23 @@ label:\n \t static functions.  */\n       && SYMBOL_REF_LOCAL_P (XEXP (operands[0], 0)))\n     {\n-      emit_call_insn (gen_sibcall_pcrel (XEXP (operands[0], 0), operands[1]));\n+      if (TARGET_FDPIC)\n+\temit_call_insn (gen_sibcall_pcrel_fdpic (XEXP (operands[0], 0),\n+\t\t\t\t\t\t operands[1]));\n+      else\n+\temit_call_insn (gen_sibcall_pcrel (XEXP (operands[0], 0), operands[1]));\n       DONE;\n     }\n   else\n     operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n \n-  emit_call_insn (gen_sibcalli (operands[0], operands[1]));\n+  if (TARGET_FDPIC)\n+    {\n+      operands[0] = sh_load_function_descriptor (operands[0]);\n+      emit_call_insn (gen_sibcalli_fdpic (operands[0], operands[1]));\n+    }\n+  else\n+    emit_call_insn (gen_sibcalli (operands[0], operands[1]));\n   DONE;\n })\n \n@@ -10208,7 +10376,22 @@ label:\n \t      (match_operand 2 \"\" \"\")))\n    (use (reg:SI FPSCR_MODES_REG))\n    (return)]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && !TARGET_FDPIC\"\n+  \"jmp\t@%1%#\"\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+       (if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t     (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n+(define_insn \"sibcall_valuei_fdpic\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"k\"))\n+\t      (match_operand 2)))\n+   (use (reg:SI FPSCR_MODES_REG))\n+   (use (reg:SI PIC_REG))\n+   (return)]\n+  \"TARGET_FDPIC\"\n   \"jmp\t@%1%#\"\n   [(set_attr \"needs_delay_slot\" \"yes\")\n    (set (attr \"fp_mode\")\n@@ -10223,7 +10406,26 @@ label:\n    (use (match_operand 3 \"\" \"\"))\n    (use (reg:SI FPSCR_MODES_REG))\n    (return)]\n-  \"TARGET_SH2\"\n+  \"TARGET_SH2 && !TARGET_FDPIC\"\n+{\n+  return       \"braf\t%1\"\t\"\\n\"\n+\t \"%O3:%#\";\n+}\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n+(define_insn \"sibcall_valuei_pcrel_fdpic\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"k\"))\n+\t      (match_operand 2)))\n+   (use (match_operand 3))\n+   (use (reg:SI FPSCR_MODES_REG))\n+   (use (reg:SI PIC_REG))\n+   (return)]\n+  \"TARGET_SH2 && TARGET_FDPIC\"\n {\n   return       \"braf\t%1\"\t\"\\n\"\n \t \"%O3:%#\";\n@@ -10241,7 +10443,7 @@ label:\n    (use (reg:SI FPSCR_MODES_REG))\n    (clobber (match_scratch:SI 3 \"=&k\"))\n    (return)]\n-  \"TARGET_SH2\"\n+  \"TARGET_SH2 && !TARGET_FDPIC\"\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n@@ -10263,6 +10465,35 @@ label:\n \t\t      (const_string \"single\") (const_string \"double\")))\n    (set_attr \"type\" \"jump_ind\")])\n \n+(define_insn_and_split \"sibcall_value_pcrel_fdpic\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\"))\n+\t      (match_operand 2)))\n+   (use (reg:SI FPSCR_MODES_REG))\n+   (use (reg:SI PIC_REG))\n+   (clobber (match_scratch:SI 3 \"=k\"))\n+   (return)]\n+  \"TARGET_SH2 && TARGET_FDPIC\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx lab = PATTERN (gen_call_site ());\n+\n+  sh_expand_sym_label2reg (operands[3], operands[1], lab, true);\n+  rtx i = emit_call_insn (gen_sibcall_valuei_pcrel_fdpic (operands[0],\n+\t\t\t\t\t\t\t  operands[3],\n+\t\t\t\t\t\t\t  operands[2],\n+\t\t\t\t\t\t\t  copy_rtx (lab)));\n+  SIBLING_CALL_P (i) = 1;\n+  DONE;\n+}\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n (define_insn \"sibcall_value_compact\"\n   [(set (match_operand 0 \"\" \"=rf,rf\")\n \t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"k,k\"))\n@@ -10310,6 +10541,12 @@ label:\n      (return)])]\n   \"\"\n {\n+  if (TARGET_FDPIC)\n+    {\n+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);\n+      emit_move_insn (pic_reg, sh_get_fdpic_reg_initial_val ());\n+    }\n+\n   if (TARGET_SHMEDIA)\n     {\n       operands[1] = shmedia_prepare_call_address (operands[1], 1);\n@@ -10355,8 +10592,8 @@ label:\n \t run out of registers when adjusting fpscr for the call.  */\n       emit_insn (gen_force_mode_for_call ());\n \n-      operands[1]\n-\t= function_symbol (NULL, \"__GCC_shcompact_call_trampoline\", SFUNC_GOT);\n+      operands[1] = function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",\n+\t\t\t\t     SFUNC_GOT).sym;\n       operands[1] = force_reg (SImode, operands[1]);\n \n       /* We don't need a return trampoline, since the callee will\n@@ -10391,15 +10628,27 @@ label:\n \t static functions.  */\n       && SYMBOL_REF_LOCAL_P (XEXP (operands[1], 0)))\n     {\n-      emit_call_insn (gen_sibcall_value_pcrel (operands[0],\n-\t\t\t\t\t       XEXP (operands[1], 0),\n-\t\t\t\t\t       operands[2]));\n+      if (TARGET_FDPIC)\n+       emit_call_insn (gen_sibcall_value_pcrel_fdpic (operands[0],\n+\t\t\t\t\t\t      XEXP (operands[1], 0),\n+\t\t\t\t\t\t      operands[2]));\n+      else\n+       emit_call_insn (gen_sibcall_value_pcrel (operands[0],\n+\t\t\t\t\t\tXEXP (operands[1], 0),\n+\t\t\t\t\t\toperands[2]));\n       DONE;\n     }\n   else\n     operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n \n-  emit_call_insn (gen_sibcall_valuei (operands[0], operands[1], operands[2]));\n+  if (TARGET_FDPIC)\n+    {\n+      operands[1] = sh_load_function_descriptor (operands[1]);\n+      emit_call_insn (gen_sibcall_valuei_fdpic (operands[0], operands[1],\n+\t\t\t\t\t\toperands[2]));\n+    }\n+  else\n+    emit_call_insn (gen_sibcall_valuei (operands[0], operands[1], operands[2]));\n   DONE;\n })\n \n@@ -10483,7 +10732,7 @@ label:\n   emit_insn (gen_force_mode_for_call ());\n \n   operands[1] = function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",\n-\t\t\t\t SFUNC_GOT);\n+\t\t\t\t SFUNC_GOT).sym;\n   operands[1] = force_reg (SImode, operands[1]);\n \n   emit_move_insn (r0, func);\n@@ -10681,6 +10930,13 @@ label:\n       DONE;\n     }\n \n+  if (TARGET_FDPIC)\n+    {\n+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);\n+      emit_move_insn (pic_reg, sh_get_fdpic_reg_initial_val ());\n+      DONE;\n+    }\n+\n   operands[1] = gen_rtx_REG (Pmode, PIC_REG);\n   operands[2] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\n \n@@ -10816,6 +11072,9 @@ label:\n   rtx mem;\n   bool stack_chk_guard_p = false;\n \n+  rtx picreg = TARGET_FDPIC ? sh_get_fdpic_reg_initial_val ()\n+\t\t\t    : gen_rtx_REG (Pmode, PIC_REG);\n+\n   operands[2] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n   operands[3] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n \n@@ -10858,8 +11117,7 @@ label:\n   if (stack_chk_guard_p)\n     emit_insn (gen_chk_guard_add (operands[3], operands[2]));\n   else\n-    emit_move_insn (operands[3], gen_rtx_PLUS (Pmode, operands[2],\n-\t\t\t\t\t       gen_rtx_REG (Pmode, PIC_REG)));\n+    emit_move_insn (operands[3], gen_rtx_PLUS (Pmode, operands[2], picreg));\n \n   /* N.B. This is not constant for a GOTPLT relocation.  */\n   mem = gen_rtx_MEM (Pmode, operands[3]);\n@@ -10890,6 +11148,23 @@ label:\n   DONE;\n })\n \n+(define_expand \"sym2GOTFUNCDESC\"\n+  [(const (unspec [(match_operand 0)] UNSPEC_GOTFUNCDESC))]\n+  \"TARGET_FDPIC\")\n+\n+(define_expand \"symGOTFUNCDESC2reg\"\n+  [(match_operand 0) (match_operand 1)]\n+  \"TARGET_FDPIC\"\n+{\n+  rtx gotsym = gen_sym2GOTFUNCDESC (operands[1]);\n+  PUT_MODE (gotsym, Pmode);\n+  rtx insn = emit_insn (gen_symGOT_load (operands[0], gotsym));\n+\n+  MEM_READONLY_P (SET_SRC (PATTERN (insn))) = 1;\n+\n+  DONE;\n+})\n+\n (define_expand \"symGOTPLT2reg\"\n   [(match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\")]\n   \"\"\n@@ -10916,18 +11191,39 @@ label:\n \t   ? operands[0]\n \t   : gen_reg_rtx (GET_MODE (operands[0])));\n \n+  rtx picreg = TARGET_FDPIC ? sh_get_fdpic_reg_initial_val ()\n+\t\t\t    : gen_rtx_REG (Pmode, PIC_REG);\n+\n   gotoffsym = gen_sym2GOTOFF (operands[1]);\n   PUT_MODE (gotoffsym, Pmode);\n   emit_move_insn (t, gotoffsym);\n-  insn = emit_move_insn (operands[0],\n-\t\t\t gen_rtx_PLUS (Pmode, t,\n-\t\t\t\t       gen_rtx_REG (Pmode, PIC_REG)));\n+  insn = emit_move_insn (operands[0], gen_rtx_PLUS (Pmode, t, picreg));\n \n   set_unique_reg_note (insn, REG_EQUAL, operands[1]);\n \n   DONE;\n })\n \n+(define_expand \"sym2GOTOFFFUNCDESC\"\n+  [(const (unspec [(match_operand 0)] UNSPEC_GOTOFFFUNCDESC))]\n+  \"TARGET_FDPIC\")\n+\n+(define_expand \"symGOTOFFFUNCDESC2reg\"\n+  [(match_operand 0) (match_operand 1)]\n+  \"TARGET_FDPIC\"\n+{\n+  rtx picreg = sh_get_fdpic_reg_initial_val ();\n+  rtx t = !can_create_pseudo_p ()\n+\t  ? operands[0]\n+\t  : gen_reg_rtx (GET_MODE (operands[0]));\n+\n+  rtx gotoffsym = gen_sym2GOTOFFFUNCDESC (operands[1]);\n+  PUT_MODE (gotoffsym, Pmode);\n+  emit_move_insn (t, gotoffsym);\n+  emit_move_insn (operands[0], gen_rtx_PLUS (Pmode, t, picreg));\n+  DONE;\n+})\n+\n (define_expand \"symPLT_label2reg\"\n   [(set (match_operand:SI 0 \"\" \"\")\n \t(const:SI\n@@ -12678,18 +12974,22 @@ label:\n (define_insn \"block_move_real\"\n   [(parallel [(set (mem:BLK (reg:SI R4_REG))\n \t\t   (mem:BLK (reg:SI R5_REG)))\n-\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r,r\"))\n+\t      (use (match_operand 1 \"\" \"Z,Ccl\"))\n \t      (clobber (reg:SI PR_REG))\n \t      (clobber (reg:SI R0_REG))])]\n   \"TARGET_SH1 && ! TARGET_HARD_SH4\"\n-  \"jsr\t@%0%#\"\n+  \"@\n+\tjsr\t@%0%#\n+\tbsrf\t%0\\n%O1:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_insn \"block_lump_real\"\n   [(parallel [(set (mem:BLK (reg:SI R4_REG))\n \t\t   (mem:BLK (reg:SI R5_REG)))\n-\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r,r\"))\n+\t      (use (match_operand 1 \"\" \"Z,Ccl\"))\n \t      (use (reg:SI R6_REG))\n \t      (clobber (reg:SI PR_REG))\n \t      (clobber (reg:SI T_REG))\n@@ -12698,27 +12998,33 @@ label:\n \t      (clobber (reg:SI R6_REG))\n \t      (clobber (reg:SI R0_REG))])]\n   \"TARGET_SH1 && ! TARGET_HARD_SH4\"\n-  \"jsr\t@%0%#\"\n+  \"@\n+\tjsr\t@%0%#\n+\tbsrf\t%0\\n%O1:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_insn \"block_move_real_i4\"\n   [(parallel [(set (mem:BLK (reg:SI R4_REG))\n \t\t   (mem:BLK (reg:SI R5_REG)))\n-\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r,r\"))\n+\t      (use (match_operand 1 \"\" \"Z,Ccl\"))\n \t      (clobber (reg:SI PR_REG))\n \t      (clobber (reg:SI R0_REG))\n \t      (clobber (reg:SI R1_REG))\n \t      (clobber (reg:SI R2_REG))])]\n   \"TARGET_HARD_SH4\"\n-  \"jsr\t@%0%#\"\n+  \"@\n+\tjsr\t@%0%#\n+\tbsrf\t%0\\n%O1:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_insn \"block_lump_real_i4\"\n   [(parallel [(set (mem:BLK (reg:SI R4_REG))\n \t\t   (mem:BLK (reg:SI R5_REG)))\n-\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r,r\"))\n+\t      (use (match_operand 1 \"\" \"Z,Ccl\"))\n \t      (use (reg:SI R6_REG))\n \t      (clobber (reg:SI PR_REG))\n \t      (clobber (reg:SI T_REG))\n@@ -12730,7 +13036,9 @@ label:\n \t      (clobber (reg:SI R2_REG))\n \t      (clobber (reg:SI R3_REG))])]\n   \"TARGET_HARD_SH4\"\n-  \"jsr\t@%0%#\"\n+  \"@\n+\tjsr\t@%0%#\n+\tbsrf\t%0\\n%O1:%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n "}, {"sha": "28e80dc7376a354732ce4c85c066c9f446cbe1aa", "filename": "gcc/config/sh/sh.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -260,6 +260,10 @@ mdivsi3_libfunc=\n Target RejectNegative Joined Var(sh_divsi3_libfunc) Init(\"\")\n Specify name for 32 bit signed division function.\n \n+mfdpic\n+Target Report Var(TARGET_FDPIC) Init(0)\n+Generate ELF FDPIC code\n+\n mfmovd\n Target RejectNegative Mask(FMOVD)\n Enable the use of 64-bit floating point registers in fmov instructions.  See -mdalign if 64-bit alignment is required."}, {"sha": "57399edbefb4604a9810b5c63009ef6131d80789", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -1810,6 +1810,9 @@ When neither of these configure options are used, the default will be\n 128-bit @code{long double} when built against GNU C Library 2.4 and later,\n 64-bit @code{long double} otherwise.\n \n+@item --enable-fdpic\n+On SH Linux systems, generate ELF FDPIC code.\n+\n @item --with-gmp=@var{pathname}\n @itemx --with-gmp-include=@var{pathname}\n @itemx --with-gmp-lib=@var{pathname}"}, {"sha": "462eef0bedfe00761f56605cdc5ced5b5050383d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -21244,6 +21244,10 @@ in effect.\n Prefer zero-displacement conditional branches for conditional move instruction\n patterns.  This can result in faster code on the SH4 processor.\n \n+@item -mfdpic\n+@opindex fdpic\n+Generate code using the FDPIC ABI.\n+\n @end table\n \n @node Solaris 2 Options"}, {"sha": "544309aa71cfbccdf1d5e47b8ac0b19774dda2a1", "filename": "include/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -1,3 +1,11 @@\n+2015-10-27  Daniel Jacobowitz  <dan@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\t    Mark Shinwell  <shinwell@codesourcery.com>\n+\t    Andrew Stubbs  <ams@codesourcery.com>\n+\t    Rich Felker <dalias@libc.org>\n+\n+\t* longlong.h (udiv_qrnnd): Add FDPIC compatible version for SH.\n+\n 2015-10-18  Roland McGrath  <roland@gnu.org>\n \n \tPR other/63758"}, {"sha": "d7ef671226cd6f545c2fd3ede22b693cd213c934", "filename": "include/longlong.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/include%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/include%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flonglong.h?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -1102,6 +1102,33 @@ extern UDItype __umulsidi3 (USItype, USItype);\n /* This is the same algorithm as __udiv_qrnnd_c.  */\n #define UDIV_NEEDS_NORMALIZATION 1\n \n+#ifdef __FDPIC__\n+/* FDPIC needs a special version of the asm fragment to extract the\n+   code address from the function descriptor. __udiv_qrnnd_16 is\n+   assumed to be local and not to use the GOT, so loading r12 is\n+   not needed. */\n+#define udiv_qrnnd(q, r, n1, n0, d) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    extern UWtype __udiv_qrnnd_16 (UWtype, UWtype)\t\t\t\\\n+\t\t\t__attribute__ ((visibility (\"hidden\")));\t\\\n+    /* r0: rn r1: qn */ /* r0: n1 r4: n0 r5: d r6: d1 */ /* r2: __m */\t\\\n+    __asm__ (\t\t\t\t\t\t\t\t\\\n+\t\"mov%M4\t%4,r5\\n\"\t\t\t\t\t\t\\\n+\"\tswap.w\t%3,r4\\n\"\t\t\t\t\t\t\\\n+\"\tswap.w\tr5,r6\\n\"\t\t\t\t\t\t\\\n+\"\tmov.l\t@%5,r2\\n\"\t\t\t\t\t\t\\\n+\"\tjsr\t@r2\\n\"\t\t\t\t\t\t\t\\\n+\"\tshll16\tr6\\n\"\t\t\t\t\t\t\t\\\n+\"\tswap.w\tr4,r4\\n\"\t\t\t\t\t\t\\\n+\"\tmov.l\t@%5,r2\\n\"\t\t\t\t\t\t\\\n+\"\tjsr\t@r2\\n\"\t\t\t\t\t\t\t\\\n+\"\tswap.w\tr1,%0\\n\"\t\t\t\t\t\t\\\n+\"\tor\tr1,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" (q), \"=&z\" (r)\t\t\t\t\t\t\\\n+\t: \"1\" (n1), \"r\" (n0), \"rm\" (d), \"r\" (&__udiv_qrnnd_16)\t\t\\\n+\t: \"r1\", \"r2\", \"r4\", \"r5\", \"r6\", \"pr\", \"t\");\t\t\t\\\n+  } while (0)\n+#else\n #define udiv_qrnnd(q, r, n1, n0, d) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     extern UWtype __udiv_qrnnd_16 (UWtype, UWtype)\t\t\t\\\n@@ -1121,6 +1148,7 @@ extern UDItype __umulsidi3 (USItype, USItype);\n \t: \"1\" (n1), \"r\" (n0), \"rm\" (d), \"r\" (&__udiv_qrnnd_16)\t\t\\\n \t: \"r1\", \"r2\", \"r4\", \"r5\", \"r6\", \"pr\", \"t\");\t\t\t\\\n   } while (0)\n+#endif /* __FDPIC__  */\n \n #define UDIV_TIME 80\n "}, {"sha": "69492d813a433396d3ddc91cdac8c861a84d2622", "filename": "libitm/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -1,3 +1,12 @@\n+2015-10-27  Daniel Jacobowitz  <dan@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\t    Mark Shinwell  <shinwell@codesourcery.com>\n+\t    Andrew Stubbs  <ams@codesourcery.com>\n+\t    Rich Felker <dalias@libc.org>\n+\n+\t* config/sh/sjlj.S (_ITM_beginTransaction): Bypass PLT calling\n+\tGTM_begin_transaction for compatibility with FDPIC.\n+\n 2015-10-09  David Malcolm  <dmalcolm@redhat.com>\n \n \t* testsuite/lib/libitm.exp: Load multiline.exp before prune.exp,"}, {"sha": "8c83fce9fb22d4a3a9d9d141525972b15a3ceddc", "filename": "libitm/config/sh/sjlj.S", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/libitm%2Fconfig%2Fsh%2Fsjlj.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e44e857e05c165f6f01aeb56a7a43ee765bfc99/libitm%2Fconfig%2Fsh%2Fsjlj.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fsh%2Fsjlj.S?ref=1e44e857e05c165f6f01aeb56a7a43ee765bfc99", "patch": "@@ -58,9 +58,6 @@ _ITM_beginTransaction:\n \tjsr\t@r1\n \t mov\tr15, r5\n #else\n-\tmova\t.Lgot, r0\n-\tmov.l\t.Lgot, r12\n-\tadd\tr0, r12\n \tmov.l\t.Lbegin, r1\n \tbsrf\tr1\n \t mov\tr15, r5\n@@ -79,14 +76,12 @@ _ITM_beginTransaction:\n \t nop\n \tcfi_endproc\n \n-        .align  2\n-.Lgot:\n-\t.long\t_GLOBAL_OFFSET_TABLE_\n+\t.align  2\n .Lbegin:\n #if defined HAVE_ATTRIBUTE_VISIBILITY || !defined __PIC__\n \t.long\tGTM_begin_transaction\n #else\n-\t.long\tGTM_begin_transaction@PLT-(.Lbegin0-.)\n+\t.long\tGTM_begin_transaction@PCREL-(.Lbegin0-.)\n #endif\n \t.size\t_ITM_beginTransaction, . - _ITM_beginTransaction\n "}]}