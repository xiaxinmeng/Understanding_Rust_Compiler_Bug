{"sha": "93a732514865f3607cc01f5c5b078f63580ef4b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNhNzMyNTE0ODY1ZjM2MDdjYzAxZjVjNWIwNzhmNjM1ODBlZjRiMQ==", "commit": {"author": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-11-25T16:31:47Z"}, "committer": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-11-25T16:39:07Z"}, "message": "libsanitizer:  Add hwasan pass and associated gimple changes\n\nThere are four main features to this change:\n\n1) Check pointer tags match address tags.\n\nWhen sanitizing for hwasan we now put HWASAN_CHECK internal functions before\nmemory accesses in the `asan` pass.  This checks that a tag in the pointer\nbeing used match the tag stored in shadow memory for the memory region being\nused.\n\nThese internal functions are expanded into actual checks in the sanopt\npass that happens just before expansion into RTL.\n\nWe use the same mechanism that currently inserts ASAN_CHECK internal\nfunctions to insert the new HWASAN_CHECK functions.\n\n2) Instrument known builtin function calls.\n\nHandle all builtin functions that we know use memory accesses.\nThis commit uses the machinery added for ASAN to identify builtin\nfunctions that access memory.\n\nThe main differences between the approaches for HWASAN and ASAN are:\n - libhwasan intercepts much less builtin functions.\n - Alloca needs to be transformed differently (instead of adding\n   redzones it needs to tag shadow memory and return a tagged pointer).\n - stack_restore needs to untag the shadow stack between the current\n   position and where it's going.\n - `noreturn` functions can not be handled by simply unpoisoning the\n   entire shadow stack -- there is no \"always valid\" tag.\n   (exceptions and things such as longjmp need to be handled in a\n   different way, usually in the runtime).\n\nFor hardware implemented checking (such as AArch64's memory tagging\nextension) alloca and stack_restore will need to be handled by hooks in\nthe backend rather than transformation at the gimple level.  This will\nallow architecture specific handling of such stack modifications.\n\n3) Introduce HWASAN block-scope poisoning\n\nHere we use exactly the same mechanism as ASAN_MARK to poison/unpoison\nvariables on entry/exit of a block.\n\nIn order to simply use the exact same machinery we're using the same\ninternal functions until the SANOPT pass.  This means that all handling\nof ASAN_MARK is the same.\nThis has the negative that the naming may be a little confusing, but a\npositive that handling of the internal function doesn't have to be\nduplicated for a function that behaves exactly the same but has a\ndifferent name.\n\ngcc/ChangeLog:\n\n\t* asan.c (asan_instrument_reads): New.\n\t(asan_instrument_writes): New.\n\t(asan_memintrin): New.\n\t(handle_builtin_stack_restore): Account for HWASAN.\n\t(handle_builtin_alloca): Account for HWASAN.\n\t(get_mem_refs_of_builtin_call): Special case strlen for HWASAN.\n\t(hwasan_instrument_reads): New.\n\t(hwasan_instrument_writes): New.\n\t(hwasan_memintrin): New.\n\t(report_error_func): Assert not HWASAN.\n\t(build_check_stmt): Make HWASAN_CHECK instead of ASAN_CHECK.\n\t(instrument_derefs): HWASAN does not tag globals.\n\t(instrument_builtin_call): Use new helper functions.\n\t(maybe_instrument_call): Don't instrument `noreturn` functions.\n\t(initialize_sanitizer_builtins): Add new type.\n\t(asan_expand_mark_ifn): Account for HWASAN.\n\t(asan_expand_check_ifn): Assert never called by HWASAN.\n\t(asan_expand_poison_ifn): Account for HWASAN.\n\t(asan_instrument): Branch based on whether using HWASAN or ASAN.\n\t(pass_asan::gate): Return true if sanitizing HWASAN.\n\t(pass_asan_O0::gate): Return true if sanitizing HWASAN.\n\t(hwasan_check_func): New.\n\t(hwasan_expand_check_ifn): New.\n\t(hwasan_expand_mark_ifn): New.\n\t(gate_hwasan): New.\n\t* asan.h (hwasan_expand_check_ifn): New decl.\n\t(hwasan_expand_mark_ifn): New decl.\n\t(gate_hwasan): New decl.\n\t(asan_intercepted_p): Always false for hwasan.\n\t(asan_sanitize_use_after_scope): Account for HWASAN.\n\t* builtin-types.def (BT_FN_PTR_CONST_PTR_UINT8): New.\n\t* gimple-fold.c (gimple_build): New overload for building function\n\tcalls without arguments.\n\t(gimple_build_round_up): New.\n\t* gimple-fold.h (gimple_build): New decl.\n\t(gimple_build): New inline function.\n\t(gimple_build_round_up): New decl.\n\t(gimple_build_round_up): New inline function.\n\t* gimple-pretty-print.c (dump_gimple_call_args): Account for\n\tHWASAN.\n\t* gimplify.c (asan_poison_variable): Account for HWASAN.\n\t(gimplify_function_tree): Remove requirement of\n\tSANITIZE_ADDRESS, requiring asan or hwasan is accounted for in\n\t`asan_sanitize_use_after_scope`.\n\t* internal-fn.c (expand_HWASAN_CHECK): New.\n\t(expand_HWASAN_ALLOCA_UNPOISON): New.\n\t(expand_HWASAN_CHOOSE_TAG): New.\n\t(expand_HWASAN_MARK): New.\n\t(expand_HWASAN_SET_TAG): New.\n\t* internal-fn.def (HWASAN_ALLOCA_UNPOISON): New.\n\t(HWASAN_CHOOSE_TAG): New.\n\t(HWASAN_CHECK): New.\n\t(HWASAN_MARK): New.\n\t(HWASAN_SET_TAG): New.\n\t* sanitizer.def (BUILT_IN_HWASAN_LOAD1): New.\n\t(BUILT_IN_HWASAN_LOAD2): New.\n\t(BUILT_IN_HWASAN_LOAD4): New.\n\t(BUILT_IN_HWASAN_LOAD8): New.\n\t(BUILT_IN_HWASAN_LOAD16): New.\n\t(BUILT_IN_HWASAN_LOADN): New.\n\t(BUILT_IN_HWASAN_STORE1): New.\n\t(BUILT_IN_HWASAN_STORE2): New.\n\t(BUILT_IN_HWASAN_STORE4): New.\n\t(BUILT_IN_HWASAN_STORE8): New.\n\t(BUILT_IN_HWASAN_STORE16): New.\n\t(BUILT_IN_HWASAN_STOREN): New.\n\t(BUILT_IN_HWASAN_LOAD1_NOABORT): New.\n\t(BUILT_IN_HWASAN_LOAD2_NOABORT): New.\n\t(BUILT_IN_HWASAN_LOAD4_NOABORT): New.\n\t(BUILT_IN_HWASAN_LOAD8_NOABORT): New.\n\t(BUILT_IN_HWASAN_LOAD16_NOABORT): New.\n\t(BUILT_IN_HWASAN_LOADN_NOABORT): New.\n\t(BUILT_IN_HWASAN_STORE1_NOABORT): New.\n\t(BUILT_IN_HWASAN_STORE2_NOABORT): New.\n\t(BUILT_IN_HWASAN_STORE4_NOABORT): New.\n\t(BUILT_IN_HWASAN_STORE8_NOABORT): New.\n\t(BUILT_IN_HWASAN_STORE16_NOABORT): New.\n\t(BUILT_IN_HWASAN_STOREN_NOABORT): New.\n\t(BUILT_IN_HWASAN_TAG_MISMATCH4): New.\n\t(BUILT_IN_HWASAN_HANDLE_LONGJMP): New.\n\t(BUILT_IN_HWASAN_TAG_PTR): New.\n\t* sanopt.c (sanopt_optimize_walker): Act for hwasan.\n\t(pass_sanopt::execute): Act for hwasan.\n\t* toplev.c (compile_file): Use `gate_hwasan` function.", "tree": {"sha": "9aab46197c88d39fd2e60cf328d9a85b3057e64c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aab46197c88d39fd2e60cf328d9a85b3057e64c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93a732514865f3607cc01f5c5b078f63580ef4b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a732514865f3607cc01f5c5b078f63580ef4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93a732514865f3607cc01f5c5b078f63580ef4b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a732514865f3607cc01f5c5b078f63580ef4b1/comments", "author": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0854b584bdc2862b49f029095e58beca797cf449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0854b584bdc2862b49f029095e58beca797cf449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0854b584bdc2862b49f029095e58beca797cf449"}], "stats": {"total": 881, "additions": 845, "deletions": 36}, "files": [{"sha": "5968e12e5dc7bc535840ace9d44286d320b89fb4", "filename": "gcc/asan.c", "status": "modified", "additions": 583, "deletions": 27, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -370,6 +370,25 @@ asan_sanitize_allocas_p (void)\n   return (asan_sanitize_stack_p () && param_asan_protect_allocas);\n }\n \n+bool\n+asan_instrument_reads (void)\n+{\n+  return (sanitize_flags_p (SANITIZE_ADDRESS) && param_asan_instrument_reads);\n+}\n+\n+bool\n+asan_instrument_writes (void)\n+{\n+  return (sanitize_flags_p (SANITIZE_ADDRESS) && param_asan_instrument_writes);\n+}\n+\n+bool\n+asan_memintrin (void)\n+{\n+  return (sanitize_flags_p (SANITIZE_ADDRESS) && param_asan_memintrin);\n+}\n+\n+\n /* Checks whether section SEC should be sanitized.  */\n \n static bool\n@@ -630,20 +649,47 @@ get_last_alloca_addr ()\n    To overcome the issue we use following trick: pass new_sp as a second\n    parameter to __asan_allocas_unpoison and rewrite it during expansion with\n    new_sp + (virtual_dynamic_stack_rtx - sp) later in\n-   expand_asan_emit_allocas_unpoison function.  */\n+   expand_asan_emit_allocas_unpoison function.\n+\n+   HWASAN needs to do very similar, the eventual pseudocode should be:\n+      __hwasan_tag_memory (virtual_stack_dynamic_rtx,\n+\t\t\t   0,\n+\t\t\t   new_sp - sp);\n+      __builtin_stack_restore (new_sp)\n+\n+   Need to use the same trick to handle STACK_DYNAMIC_OFFSET as described\n+   above.  */\n \n static void\n handle_builtin_stack_restore (gcall *call, gimple_stmt_iterator *iter)\n {\n-  if (!iter || !asan_sanitize_allocas_p ())\n+  if (!iter\n+      || !(asan_sanitize_allocas_p () || hwasan_sanitize_allocas_p ()))\n     return;\n \n-  tree last_alloca = get_last_alloca_addr ();\n   tree restored_stack = gimple_call_arg (call, 0);\n-  tree fn = builtin_decl_implicit (BUILT_IN_ASAN_ALLOCAS_UNPOISON);\n-  gimple *g = gimple_build_call (fn, 2, last_alloca, restored_stack);\n-  gsi_insert_before (iter, g, GSI_SAME_STMT);\n-  g = gimple_build_assign (last_alloca, restored_stack);\n+\n+  gimple *g;\n+\n+  if (hwasan_sanitize_allocas_p ())\n+    {\n+      enum internal_fn fn = IFN_HWASAN_ALLOCA_UNPOISON;\n+      /* There is only one piece of information `expand_HWASAN_ALLOCA_UNPOISON`\n+\t needs to work.  This is the length of the area that we're\n+\t deallocating.  Since the stack pointer is known at expand time, the\n+\t position of the new stack pointer after deallocation is enough\n+\t information to calculate this length.  */\n+      g = gimple_build_call_internal (fn, 1, restored_stack);\n+    }\n+  else\n+    {\n+      tree last_alloca = get_last_alloca_addr ();\n+      tree fn = builtin_decl_implicit (BUILT_IN_ASAN_ALLOCAS_UNPOISON);\n+      g = gimple_build_call (fn, 2, last_alloca, restored_stack);\n+      gsi_insert_before (iter, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (last_alloca, restored_stack);\n+    }\n+\n   gsi_insert_before (iter, g, GSI_SAME_STMT);\n }\n \n@@ -673,14 +719,12 @@ handle_builtin_stack_restore (gcall *call, gimple_stmt_iterator *iter)\n static void\n handle_builtin_alloca (gcall *call, gimple_stmt_iterator *iter)\n {\n-  if (!iter || !asan_sanitize_allocas_p ())\n+  if (!iter\n+      || !(asan_sanitize_allocas_p () || hwasan_sanitize_allocas_p ()))\n     return;\n \n   gassign *g;\n   gcall *gg;\n-  const HOST_WIDE_INT redzone_mask = ASAN_RED_ZONE_SIZE - 1;\n-\n-  tree last_alloca = get_last_alloca_addr ();\n   tree callee = gimple_call_fndecl (call);\n   tree old_size = gimple_call_arg (call, 0);\n   tree ptr_type = gimple_call_lhs (call) ? TREE_TYPE (gimple_call_lhs (call))\n@@ -690,6 +734,68 @@ handle_builtin_alloca (gcall *call, gimple_stmt_iterator *iter)\n     = DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA\n       ? 0 : tree_to_uhwi (gimple_call_arg (call, 1));\n \n+  if (hwasan_sanitize_allocas_p ())\n+    {\n+      gimple_seq stmts = NULL;\n+      location_t loc = gimple_location (gsi_stmt (*iter));\n+      /*\n+\t HWASAN needs a different expansion.\n+\n+\t addr = __builtin_alloca (size, align);\n+\n+\t should be replaced by\n+\n+\t new_size = size rounded up to HWASAN_TAG_GRANULE_SIZE byte alignment;\n+\t untagged_addr = __builtin_alloca (new_size, align);\n+\t tag = __hwasan_choose_alloca_tag ();\n+\t addr = ifn_HWASAN_SET_TAG (untagged_addr, tag);\n+\t __hwasan_tag_memory (untagged_addr, tag, new_size);\n+\t*/\n+      /* Ensure alignment at least HWASAN_TAG_GRANULE_SIZE bytes so we start on\n+\t a tag granule.  */\n+      align = align > HWASAN_TAG_GRANULE_SIZE ? align : HWASAN_TAG_GRANULE_SIZE;\n+\n+      tree old_size = gimple_call_arg (call, 0);\n+      tree new_size = gimple_build_round_up (&stmts, loc, size_type_node,\n+\t\t\t\t\t     old_size,\n+\t\t\t\t\t     HWASAN_TAG_GRANULE_SIZE);\n+\n+      /* Make the alloca call */\n+      tree untagged_addr\n+\t= gimple_build (&stmts, loc,\n+\t\t\tas_combined_fn (BUILT_IN_ALLOCA_WITH_ALIGN), ptr_type,\n+\t\t\tnew_size, build_int_cst (size_type_node, align));\n+\n+      /* Choose the tag.\n+\t Here we use an internal function so we can choose the tag at expand\n+\t time.  We need the decision to be made after stack variables have been\n+\t assigned their tag (i.e. once the hwasan_frame_tag_offset variable has\n+\t been set to one after the last stack variables tag).  */\n+      tree tag = gimple_build (&stmts, loc, CFN_HWASAN_CHOOSE_TAG,\n+\t\t\t       unsigned_char_type_node);\n+\n+      /* Add tag to pointer.  */\n+      tree addr\n+\t= gimple_build (&stmts, loc, CFN_HWASAN_SET_TAG, ptr_type,\n+\t\t\tuntagged_addr, tag);\n+\n+      /* Tag shadow memory.\n+\t NOTE: require using `untagged_addr` here for libhwasan API.  */\n+      gimple_build (&stmts, loc, as_combined_fn (BUILT_IN_HWASAN_TAG_MEM),\n+\t\t    void_type_node, untagged_addr, tag, new_size);\n+\n+      /* Insert the built up code sequence into the original instruction stream\n+\t the iterator points to.  */\n+      gsi_insert_seq_before (iter, stmts, GSI_SAME_STMT);\n+\n+      /* Finally, replace old alloca ptr with NEW_ALLOCA.  */\n+      replace_call_with_value (iter, addr);\n+      return;\n+    }\n+\n+  tree last_alloca = get_last_alloca_addr ();\n+  const HOST_WIDE_INT redzone_mask = ASAN_RED_ZONE_SIZE - 1;\n+\n   /* If ALIGN > ASAN_RED_ZONE_SIZE, we embed left redzone into first ALIGN\n      bytes of allocated space.  Otherwise, align alloca to ASAN_RED_ZONE_SIZE\n      manually.  */\n@@ -842,6 +948,31 @@ get_mem_refs_of_builtin_call (gcall *call,\n       break;\n \n     case BUILT_IN_STRLEN:\n+      /* Special case strlen here since its length is taken from its return\n+\t value.\n+\n+\t The approach taken by the sanitizers is to check a memory access\n+\t before it's taken.  For ASAN strlen is intercepted by libasan, so no\n+\t check is inserted by the compiler.\n+\n+\t This function still returns `true` and provides a length to the rest\n+\t of the ASAN pass in order to record what areas have been checked,\n+\t avoiding superfluous checks later on.\n+\n+\t HWASAN does not intercept any of these internal functions.\n+\t This means that checks for memory accesses must be inserted by the\n+\t compiler.\n+\t strlen is a special case, because we can tell the length from the\n+\t return of the function, but that is not known until after the function\n+\t has returned.\n+\n+\t Hence we can't check the memory access before it happens.\n+\t We could check the memory access after it has already happened, but\n+\t for now we choose to just ignore `strlen` calls.\n+\t This decision was simply made because that means the special case is\n+\t limited to this one case of this one function.  */\n+      if (hwasan_sanitize_p ())\n+\treturn false;\n       source0 = gimple_call_arg (call, 0);\n       len = gimple_call_lhs (call);\n       break;\n@@ -1411,6 +1542,156 @@ asan_redzone_buffer::flush_if_full (void)\n     flush_redzone_payload ();\n }\n \n+\n+/* HWAddressSanitizer (hwasan) is a probabilistic method for detecting\n+   out-of-bounds and use-after-free bugs.\n+   Read more:\n+   http://code.google.com/p/address-sanitizer/\n+\n+   Similar to AddressSanitizer (asan) it consists of two parts: the\n+   instrumentation module in this file, and a run-time library.\n+\n+   The instrumentation module adds a run-time check before every memory insn in\n+   the same manner as asan (see the block comment for AddressSanitizer above).\n+   Currently, hwasan only adds out-of-line instrumentation, where each check is\n+   implemented as a function call to the run-time library.  Hence a check for a\n+   load of N bytes from address X would be implemented with a function call to\n+   __hwasan_loadN(X), and checking a store of N bytes from address X would be\n+   implemented with a function call to __hwasan_storeN(X).\n+\n+   The main difference between hwasan and asan is in the information stored to\n+   help this checking.  Both sanitizers use a shadow memory area which stores\n+   data recording the state of main memory at a corresponding address.\n+\n+   For hwasan, each 16 byte granule in main memory has a corresponding 1 byte\n+   in shadow memory.  This shadow address can be calculated with equation:\n+     (addr >> log_2(HWASAN_TAG_GRANULE_SIZE))\n+\t  + __hwasan_shadow_memory_dynamic_address;\n+   The conversion between real and shadow memory for asan is given in the block\n+   comment at the top of this file.\n+   The description of how this shadow memory is laid out for asan is in the\n+   block comment at the top of this file, here we describe how this shadow\n+   memory is used for hwasan.\n+\n+   For hwasan, each variable is assigned a byte-sized 'tag'.  The extent of\n+   the shadow memory for that variable is filled with the assigned tag, and\n+   every pointer referencing that variable has its top byte set to the same\n+   tag.  The run-time library redefines malloc so that every allocation returns\n+   a tagged pointer and tags the corresponding shadow memory with the same tag.\n+\n+   On each pointer dereference the tag found in the pointer is compared to the\n+   tag found in the shadow memory corresponding to the accessed memory address.\n+   If these tags are found to differ then this memory access is judged to be\n+   invalid and a report is generated.\n+\n+   This method of bug detection is not perfect -- it can not catch every bad\n+   access -- but catches them probabilistically instead.  There is always the\n+   possibility that an invalid memory access will happen to access memory\n+   tagged with the same tag as the pointer that this access used.\n+   The chances of this are approx. 0.4% for any two uncorrelated objects.\n+\n+   Random tag generation can mitigate this problem by decreasing the\n+   probability that an invalid access will be missed in the same manner over\n+   multiple runs.  i.e. if two objects are tagged the same in one run of the\n+   binary they are unlikely to be tagged the same in the next run.\n+   Both heap and stack allocated objects have random tags by default.\n+\n+   [16 byte granule implications]\n+    Since the shadow memory only has a resolution on real memory of 16 bytes,\n+    invalid accesses that are within the same 16 byte granule as a valid\n+    address will not be caught.\n+\n+    There is a \"short-granule\" feature in the runtime library which does catch\n+    such accesses, but this feature is not implemented for stack objects (since\n+    stack objects are allocated and tagged by compiler instrumentation, and\n+    this feature has not yet been implemented in GCC instrumentation).\n+\n+    Another outcome of this 16 byte resolution is that each tagged object must\n+    be 16 byte aligned.  If two objects were to share any 16 byte granule in\n+    memory, then they both would have to be given the same tag, and invalid\n+    accesses to one using a pointer to the other would be undetectable.\n+\n+   [Compiler instrumentation]\n+    Compiler instrumentation ensures that two adjacent buffers on the stack are\n+    given different tags, this means an access to one buffer using a pointer\n+    generated from the other (e.g. through buffer overrun) will have mismatched\n+    tags and be caught by hwasan.\n+\n+    We don't randomly tag every object on the stack, since that would require\n+    keeping many registers to record each tag.  Instead we randomly generate a\n+    tag for each function frame, and each new stack object uses a tag offset\n+    from that frame tag.\n+    i.e. each object is tagged as RFT + offset, where RFT is the \"random frame\n+    tag\" generated for this frame.\n+    This means that randomisation does not peturb the difference between tags\n+    on tagged stack objects within a frame, but this is mitigated by the fact\n+    that objects with the same tag within a frame are very far apart\n+    (approx. 2^HWASAN_TAG_SIZE objects apart).\n+\n+    As a demonstration, using the same example program as in the asan block\n+    comment above:\n+\n+     int\n+     foo ()\n+     {\n+       char a[23] = {0};\n+       int b[2] = {0};\n+\n+       a[5] = 1;\n+       b[1] = 2;\n+\n+       return a[5] + b[1];\n+     }\n+\n+    On AArch64 the stack will be ordered as follows for the above function:\n+\n+    Slot 1/ [24 bytes for variable 'a']\n+    Slot 2/ [8 bytes padding for alignment]\n+    Slot 3/ [8 bytes for variable 'b']\n+    Slot 4/ [8 bytes padding for alignment]\n+\n+    (The padding is there to ensure 16 byte alignment as described in the 16\n+     byte granule implications).\n+\n+    While the shadow memory will be ordered as follows:\n+\n+    - 2 bytes (representing 32 bytes in real memory) tagged with RFT + 1.\n+    - 1 byte (representing 16 bytes in real memory) tagged with RFT + 2.\n+\n+    And any pointer to \"a\" will have the tag RFT + 1, and any pointer to \"b\"\n+    will have the tag RFT + 2.\n+\n+   [Top Byte Ignore requirements]\n+    Hwasan requires the ability to store an 8 bit tag in every pointer.  There\n+    is no instrumentation done to remove this tag from pointers before\n+    dereferencing, which means the hardware must ignore this tag during memory\n+    accesses.\n+\n+    Architectures where this feature is available should indicate this using\n+    the TARGET_MEMTAG_CAN_TAG_ADDRESSES hook.\n+\n+   [Stack requires cleanup on unwinding]\n+    During normal operation of a hwasan sanitized program more space in the\n+    shadow memory becomes tagged as the stack grows.  As the stack shrinks this\n+    shadow memory space must become untagged.  If it is not untagged then when\n+    the stack grows again (during other function calls later on in the program)\n+    objects on the stack that are usually not tagged (e.g. parameters passed on\n+    the stack) can be placed in memory whose shadow space is tagged with\n+    something else, and accesses can cause false positive reports.\n+\n+    Hence we place untagging code on every epilogue of functions which tag some\n+    stack objects.\n+\n+    Moreover, the run-time library intercepts longjmp & setjmp to untag when\n+    the stack is unwound this way.\n+\n+    C++ exceptions are not yet handled, which means this sanitizer can not\n+    handle C++ code that throws exceptions -- it will give false positives\n+    after an exception has been thrown.  The implementation that the hwasan\n+    library has for handling these relies on the frame pointer being after any\n+    local variables.  This is not generally the case for GCC.  */\n+\n+\n /* Returns whether we are tagging pointers and checking those tags on memory\n    access.  */\n bool\n@@ -1433,6 +1714,27 @@ hwasan_sanitize_allocas_p (void)\n   return (hwasan_sanitize_stack_p () && param_hwasan_instrument_allocas);\n }\n \n+/* Should we instrument reads?  */\n+bool\n+hwasan_instrument_reads (void)\n+{\n+  return (hwasan_sanitize_p () && param_hwasan_instrument_reads);\n+}\n+\n+/* Should we instrument writes?  */\n+bool\n+hwasan_instrument_writes (void)\n+{\n+  return (hwasan_sanitize_p () && param_hwasan_instrument_writes);\n+}\n+\n+/* Should we instrument builtin calls?  */\n+bool\n+hwasan_memintrin (void)\n+{\n+  return (hwasan_sanitize_p () && param_hwasan_instrument_mem_intrinsics);\n+}\n+\n /* Insert code to protect stack vars.  The prologue sequence should be emitted\n    directly, epilogue sequence returned.  BASE is the register holding the\n    stack base, against which OFFSETS array offsets are relative to, OFFSETS\n@@ -1928,6 +2230,8 @@ static tree\n report_error_func (bool is_store, bool recover_p, HOST_WIDE_INT size_in_bytes,\n \t\t   int *nargs)\n {\n+  gcc_assert (!hwasan_sanitize_p ());\n+\n   static enum built_in_function report[2][2][6]\n     = { { { BUILT_IN_ASAN_REPORT_LOAD1, BUILT_IN_ASAN_REPORT_LOAD2,\n \t    BUILT_IN_ASAN_REPORT_LOAD4, BUILT_IN_ASAN_REPORT_LOAD8,\n@@ -2220,6 +2524,7 @@ build_check_stmt (location_t loc, tree base, tree len,\n   gimple *g;\n \n   gcc_assert (!(size_in_bytes > 0 && !is_non_zero_len));\n+  gcc_assert (size_in_bytes == -1 || size_in_bytes >= 1);\n \n   gsi = *iter;\n \n@@ -2264,7 +2569,11 @@ build_check_stmt (location_t loc, tree base, tree len,\n   if (is_scalar_access)\n     flags |= ASAN_CHECK_SCALAR_ACCESS;\n \n-  g = gimple_build_call_internal (IFN_ASAN_CHECK, 4,\n+  enum internal_fn fn = hwasan_sanitize_p ()\n+    ? IFN_HWASAN_CHECK\n+    : IFN_ASAN_CHECK;\n+\n+  g = gimple_build_call_internal (fn, 4,\n \t\t\t\t  build_int_cst (integer_type_node, flags),\n \t\t\t\t  base, len,\n \t\t\t\t  build_int_cst (integer_type_node,\n@@ -2288,9 +2597,9 @@ static void\n instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \t\t   location_t location, bool is_store)\n {\n-  if (is_store && !param_asan_instrument_writes)\n+  if (is_store && !(asan_instrument_writes () || hwasan_instrument_writes ()))\n     return;\n-  if (!is_store && !param_asan_instrument_reads)\n+  if (!is_store && !(asan_instrument_reads () || hwasan_instrument_reads ()))\n     return;\n \n   tree type, base;\n@@ -2351,7 +2660,12 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n     {\n       if (DECL_THREAD_LOCAL_P (inner))\n \treturn;\n-      if (!param_asan_globals && is_global_var (inner))\n+      /* If we're not sanitizing globals and we can tell statically that this\n+\t access is inside a global variable, then there's no point adding\n+\t instrumentation to check the access.  N.b. hwasan currently never\n+\t sanitizes globals.  */\n+      if ((hwasan_sanitize_p () || !param_asan_globals)\n+\t  && is_global_var (inner))\n         return;\n       if (!TREE_STATIC (inner))\n \t{\n@@ -2444,7 +2758,7 @@ instrument_mem_region_access (tree base, tree len,\n static bool\n instrument_builtin_call (gimple_stmt_iterator *iter)\n {\n-  if (!param_asan_memintrin)\n+  if (!(asan_memintrin () || hwasan_memintrin ()))\n     return false;\n \n   bool iter_advanced_p = false;\n@@ -2580,10 +2894,27 @@ maybe_instrument_call (gimple_stmt_iterator *iter)\n \t      break;\n \t    }\n \t}\n-      tree decl = builtin_decl_implicit (BUILT_IN_ASAN_HANDLE_NO_RETURN);\n-      gimple *g = gimple_build_call (decl, 0);\n-      gimple_set_location (g, gimple_location (stmt));\n-      gsi_insert_before (iter, g, GSI_SAME_STMT);\n+      /* If a function does not return, then we must handle clearing up the\n+\t shadow stack accordingly.  For ASAN we can simply set the entire stack\n+\t to \"valid\" for accesses by setting the shadow space to 0 and all\n+\t accesses will pass checks.  That means that some bad accesses may be\n+\t missed, but we will not report any false positives.\n+\n+\t This is not possible for HWASAN.  Since there is no \"always valid\" tag\n+\t we can not set any space to \"always valid\".  If we were to clear the\n+\t entire shadow stack then code resuming from `longjmp` or a caught\n+\t exception would trigger false positives when correctly accessing\n+\t variables on the stack.  Hence we need to handle things like\n+\t `longjmp`, thread exit, and exceptions in a different way.  These\n+\t problems must be handled externally to the compiler, e.g. in the\n+\t language runtime.  */\n+      if (! hwasan_sanitize_p ())\n+\t{\n+\t  tree decl = builtin_decl_implicit (BUILT_IN_ASAN_HANDLE_NO_RETURN);\n+\t  gimple *g = gimple_build_call (decl, 0);\n+\t  gimple_set_location (g, gimple_location (stmt));\n+\t  gsi_insert_before (iter, g, GSI_SAME_STMT);\n+\t}\n     }\n \n   bool instrumented = false;\n@@ -2982,6 +3313,9 @@ initialize_sanitizer_builtins (void)\n     = build_function_type_list (void_type_node, uint64_type_node,\n \t\t\t\tptr_type_node, NULL_TREE);\n \n+  tree BT_FN_PTR_CONST_PTR_UINT8\n+    = build_function_type_list (ptr_type_node, const_ptr_type_node,\n+\t\t\t\tunsigned_char_type_node, NULL_TREE);\n   tree BT_FN_VOID_PTR_UINT8_PTRMODE\n     = build_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\tunsigned_char_type_node,\n@@ -3305,6 +3639,31 @@ asan_expand_mark_ifn (gimple_stmt_iterator *iter)\n \n   gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n \n+  if (hwasan_sanitize_p ())\n+    {\n+      gcc_assert (param_hwasan_instrument_stack);\n+      gimple_seq stmts = NULL;\n+      /* Here we swap ASAN_MARK calls for HWASAN_MARK.\n+\t This is because we are using the approach of using ASAN_MARK as a\n+\t synonym until here.\n+\t That approach means we don't yet have to duplicate all the special\n+\t cases for ASAN_MARK and ASAN_POISON with the exact same handling but\n+\t called HWASAN_MARK etc.\n+\n+\t N.b. __asan_poison_stack_memory (which implements ASAN_MARK for ASAN)\n+\t rounds the size up to its shadow memory granularity, while\n+\t __hwasan_tag_memory (which implements the same for HWASAN) does not.\n+\t Hence we emit HWASAN_MARK with an aligned size unlike ASAN_MARK.  */\n+      tree len = gimple_call_arg (g, 2);\n+      tree new_len = gimple_build_round_up (&stmts, loc, size_type_node, len,\n+\t\t\t\t\t    HWASAN_TAG_GRANULE_SIZE);\n+      gimple_build (&stmts, loc, CFN_HWASAN_MARK,\n+\t\t    void_type_node, gimple_call_arg (g, 0),\n+\t\t    base, new_len);\n+      gsi_replace_with_seq (iter, stmts, true);\n+      return false;\n+    }\n+\n   if (is_poison)\n     {\n       if (asan_handled_variables == NULL)\n@@ -3379,6 +3738,7 @@ asan_expand_mark_ifn (gimple_stmt_iterator *iter)\n bool\n asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n {\n+  gcc_assert (!hwasan_sanitize_p ());\n   gimple *g = gsi_stmt (*iter);\n   location_t loc = gimple_location (g);\n   bool recover_p;\n@@ -3652,11 +4012,61 @@ asan_expand_poison_ifn (gimple_stmt_iterator *iter,\n \n       int nargs;\n       bool store_p = gimple_call_internal_p (use, IFN_ASAN_POISON_USE);\n-      tree fun = report_error_func (store_p, recover_p, tree_to_uhwi (size),\n-\t\t\t\t    &nargs);\n-\n-      gcall *call = gimple_build_call (fun, 1,\n-\t\t\t\t       build_fold_addr_expr (shadow_var));\n+      gcall *call;\n+      if (hwasan_sanitize_p ())\n+\t{\n+\t  tree fun = builtin_decl_implicit (BUILT_IN_HWASAN_TAG_MISMATCH4);\n+\t  /* NOTE: hwasan has no __hwasan_report_* functions like asan does.\n+\t\tWe use __hwasan_tag_mismatch4 with arguments that tell it the\n+\t\tsize of access and load to report all tag mismatches.\n+\n+\t\tThe arguments to this function are:\n+\t\t  Address of invalid access.\n+\t\t  Bitfield containing information about the access\n+\t\t    (access_info)\n+\t\t  Pointer to a frame of registers\n+\t\t    (for use in printing the contents of registers in a dump)\n+\t\t    Not used yet -- to be used by inline instrumentation.\n+\t\t  Size of access.\n+\n+\t\tThe access_info bitfield encodes the following pieces of\n+\t\tinformation:\n+\t\t  - Is this a store or load?\n+\t\t    access_info & 0x10  =>  store\n+\t\t  - Should the program continue after reporting the error?\n+\t\t    access_info & 0x20  =>  recover\n+\t\t  - What size access is this (not used here since we can always\n+\t\t    pass the size in the last argument)\n+\n+\t\t    if (access_info & 0xf == 0xf)\n+\t\t      size is taken from last argument.\n+\t\t    else\n+\t\t      size == 1 << (access_info & 0xf)\n+\n+\t\tThe last argument contains the size of the access iff the\n+\t\taccess_info size indicator is 0xf (we always use this argument\n+\t\trather than storing the size in the access_info bitfield).\n+\n+\t\tSee the function definition `__hwasan_tag_mismatch4` in\n+\t\tlibsanitizer/hwasan for the full definition.\n+\t\t*/\n+\t  unsigned access_info = (0x20 * recover_p)\n+\t    + (0x10 * store_p)\n+\t    + (0xf);\n+\t  call = gimple_build_call (fun, 4,\n+\t\t\t\t    build_fold_addr_expr (shadow_var),\n+\t\t\t\t    build_int_cst (pointer_sized_int_node,\n+\t\t\t\t\t\t   access_info),\n+\t\t\t\t    build_int_cst (pointer_sized_int_node, 0),\n+\t\t\t\t    size);\n+\t}\n+      else\n+\t{\n+\t  tree fun = report_error_func (store_p, recover_p, tree_to_uhwi (size),\n+\t\t\t\t\t&nargs);\n+\t  call = gimple_build_call (fun, 1,\n+\t\t\t\t    build_fold_addr_expr (shadow_var));\n+\t}\n       gimple_set_location (call, gimple_location (use));\n       gimple *call_to_insert = call;\n \n@@ -3704,6 +4114,12 @@ asan_expand_poison_ifn (gimple_stmt_iterator *iter,\n static unsigned int\n asan_instrument (void)\n {\n+  if (hwasan_sanitize_p ())\n+    {\n+      transform_statements ();\n+      return 0;\n+    }\n+\n   if (shadow_ptr_types[0] == NULL_TREE)\n     asan_init_shadow_ptr_types ();\n   transform_statements ();\n@@ -3741,7 +4157,7 @@ class pass_asan : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_asan (m_ctxt); }\n-  virtual bool gate (function *) { return gate_asan (); }\n+  virtual bool gate (function *) { return gate_asan () || gate_hwasan (); }\n   virtual unsigned int execute (function *) { return asan_instrument (); }\n \n }; // class pass_asan\n@@ -3777,7 +4193,10 @@ class pass_asan_O0 : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *) { return !optimize && gate_asan (); }\n+  virtual bool gate (function *)\n+    {\n+      return !optimize && (gate_asan () || gate_hwasan ());\n+    }\n   virtual unsigned int execute (function *) { return asan_instrument (); }\n \n }; // class pass_asan_O0\n@@ -3790,6 +4209,8 @@ make_pass_asan_O0 (gcc::context *ctxt)\n   return new pass_asan_O0 (ctxt);\n }\n \n+/*  HWASAN  */\n+\n /* For stack tagging:\n \n    Return the offset from the frame base tag that the \"next\" expanded object\n@@ -4133,4 +4554,139 @@ hwasan_truncate_to_tag_size (rtx tag, rtx target)\n   return tag;\n }\n \n+/* Construct a function tree for __hwasan_{load,store}{1,2,4,8,16,_n}.\n+   IS_STORE is either 1 (for a store) or 0 (for a load).  */\n+static combined_fn\n+hwasan_check_func (bool is_store, bool recover_p, HOST_WIDE_INT size_in_bytes,\n+\t\t   int *nargs)\n+{\n+  static enum built_in_function check[2][2][6]\n+    = { { { BUILT_IN_HWASAN_LOAD1, BUILT_IN_HWASAN_LOAD2,\n+\t    BUILT_IN_HWASAN_LOAD4, BUILT_IN_HWASAN_LOAD8,\n+\t    BUILT_IN_HWASAN_LOAD16, BUILT_IN_HWASAN_LOADN },\n+\t  { BUILT_IN_HWASAN_STORE1, BUILT_IN_HWASAN_STORE2,\n+\t    BUILT_IN_HWASAN_STORE4, BUILT_IN_HWASAN_STORE8,\n+\t    BUILT_IN_HWASAN_STORE16, BUILT_IN_HWASAN_STOREN } },\n+\t{ { BUILT_IN_HWASAN_LOAD1_NOABORT,\n+\t    BUILT_IN_HWASAN_LOAD2_NOABORT,\n+\t    BUILT_IN_HWASAN_LOAD4_NOABORT,\n+\t    BUILT_IN_HWASAN_LOAD8_NOABORT,\n+\t    BUILT_IN_HWASAN_LOAD16_NOABORT,\n+\t    BUILT_IN_HWASAN_LOADN_NOABORT },\n+\t  { BUILT_IN_HWASAN_STORE1_NOABORT,\n+\t    BUILT_IN_HWASAN_STORE2_NOABORT,\n+\t    BUILT_IN_HWASAN_STORE4_NOABORT,\n+\t    BUILT_IN_HWASAN_STORE8_NOABORT,\n+\t    BUILT_IN_HWASAN_STORE16_NOABORT,\n+\t    BUILT_IN_HWASAN_STOREN_NOABORT } } };\n+  if (size_in_bytes == -1)\n+    {\n+      *nargs = 2;\n+      return as_combined_fn (check[recover_p][is_store][5]);\n+    }\n+  *nargs = 1;\n+  int size_log2 = exact_log2 (size_in_bytes);\n+  gcc_assert (size_log2 >= 0 && size_log2 <= 5);\n+  return as_combined_fn (check[recover_p][is_store][size_log2]);\n+}\n+\n+/* Expand the HWASAN_{LOAD,STORE} builtins.  */\n+bool\n+hwasan_expand_check_ifn (gimple_stmt_iterator *iter, bool)\n+{\n+  gimple *g = gsi_stmt (*iter);\n+  location_t loc = gimple_location (g);\n+  bool recover_p;\n+  if (flag_sanitize & SANITIZE_USER_HWADDRESS)\n+    recover_p = (flag_sanitize_recover & SANITIZE_USER_HWADDRESS) != 0;\n+  else\n+    recover_p = (flag_sanitize_recover & SANITIZE_KERNEL_HWADDRESS) != 0;\n+\n+  HOST_WIDE_INT flags = tree_to_shwi (gimple_call_arg (g, 0));\n+  gcc_assert (flags < ASAN_CHECK_LAST);\n+  bool is_scalar_access = (flags & ASAN_CHECK_SCALAR_ACCESS) != 0;\n+  bool is_store = (flags & ASAN_CHECK_STORE) != 0;\n+  bool is_non_zero_len = (flags & ASAN_CHECK_NON_ZERO_LEN) != 0;\n+\n+  tree base = gimple_call_arg (g, 1);\n+  tree len = gimple_call_arg (g, 2);\n+\n+  /* `align` is unused for HWASAN_CHECK, but we pass the argument anyway\n+     since that way the arguments match ASAN_CHECK.  */\n+  /* HOST_WIDE_INT align = tree_to_shwi (gimple_call_arg (g, 3));  */\n+\n+  unsigned HOST_WIDE_INT size_in_bytes\n+    = is_scalar_access ? tree_to_shwi (len) : -1;\n+\n+  gimple_stmt_iterator gsi = *iter;\n+\n+  if (!is_non_zero_len)\n+    {\n+      /* So, the length of the memory area to hwasan-protect is\n+\t non-constant.  Let's guard the generated instrumentation code\n+\t like:\n+\n+\t if (len != 0)\n+\t   {\n+\t     // hwasan instrumentation code goes here.\n+\t   }\n+\t // falltrough instructions, starting with *ITER.  */\n+\n+      g = gimple_build_cond (NE_EXPR,\n+\t\t\t    len,\n+\t\t\t    build_int_cst (TREE_TYPE (len), 0),\n+\t\t\t    NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, loc);\n+\n+      basic_block then_bb, fallthrough_bb;\n+      insert_if_then_before_iter (as_a <gcond *> (g), iter,\n+\t\t\t\t  /*then_more_likely_p=*/true,\n+\t\t\t\t  &then_bb, &fallthrough_bb);\n+      /* Note that fallthrough_bb starts with the statement that was\n+\tpointed to by ITER.  */\n+\n+      /* The 'then block' of the 'if (len != 0) condition is where\n+\twe'll generate the hwasan instrumentation code now.  */\n+      gsi = gsi_last_bb (then_bb);\n+    }\n+\n+  gimple_seq stmts = NULL;\n+  tree base_addr = gimple_build (&stmts, loc, NOP_EXPR,\n+\t\t\t\t pointer_sized_int_node, base);\n+\n+  int nargs = 0;\n+  combined_fn fn\n+    = hwasan_check_func (is_store, recover_p, size_in_bytes, &nargs);\n+  if (nargs == 1)\n+    gimple_build (&stmts, loc, fn, void_type_node, base_addr);\n+  else\n+    {\n+      gcc_assert (nargs == 2);\n+      tree sz_arg = gimple_build (&stmts, loc, NOP_EXPR,\n+\t\t\t\t  pointer_sized_int_node, len);\n+      gimple_build (&stmts, loc, fn, void_type_node, base_addr, sz_arg);\n+    }\n+\n+  gsi_insert_seq_after (&gsi, stmts, GSI_NEW_STMT);\n+  gsi_remove (iter, true);\n+  *iter = gsi;\n+  return false;\n+}\n+\n+/* For stack tagging:\n+\n+   Dummy: the HWASAN_MARK internal function should only ever be in the code\n+   after the sanopt pass.  */\n+bool\n+hwasan_expand_mark_ifn (gimple_stmt_iterator *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+bool\n+gate_hwasan ()\n+{\n+  return hwasan_sanitize_p ();\n+}\n+\n #include \"gt-asan.h\""}, {"sha": "4b873d6696026839025926581ccc9aceca225196", "filename": "gcc/asan.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -49,6 +49,9 @@ extern void hwasan_finish_file (void);\n extern bool hwasan_sanitize_p (void);\n extern bool hwasan_sanitize_stack_p (void);\n extern bool hwasan_sanitize_allocas_p (void);\n+extern bool hwasan_expand_check_ifn (gimple_stmt_iterator *, bool);\n+extern bool hwasan_expand_mark_ifn (gimple_stmt_iterator *);\n+extern bool gate_hwasan (void);\n \n extern gimple_stmt_iterator create_cond_insert_point\n      (gimple_stmt_iterator *, bool, bool, bool, basic_block *, basic_block *);\n@@ -181,6 +184,9 @@ extern hash_set<tree> *asan_handled_variables;\n static inline bool\n asan_intercepted_p (enum built_in_function fcode)\n {\n+  if (hwasan_sanitize_p ())\n+    return false;\n+\n   return fcode == BUILT_IN_INDEX\n \t || fcode == BUILT_IN_MEMCHR\n \t || fcode == BUILT_IN_MEMCMP\n@@ -209,7 +215,8 @@ asan_intercepted_p (enum built_in_function fcode)\n static inline bool\n asan_sanitize_use_after_scope (void)\n {\n-  return (flag_sanitize_address_use_after_scope && asan_sanitize_stack_p ());\n+  return (flag_sanitize_address_use_after_scope\n+\t  && (asan_sanitize_stack_p () || hwasan_sanitize_stack_p ()));\n }\n \n /* Return true if DECL should be guarded on the stack.  */"}, {"sha": "770f3575cee2c6a4a5cfb16354bd8ba2d65f574e", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -503,6 +503,7 @@ DEF_FUNCTION_TYPE_2 (BT_FN_INT_FEXCEPT_T_PTR_INT, BT_INT, BT_FEXCEPT_T_PTR,\n \t\t     BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_FEXCEPT_T_PTR_INT, BT_INT,\n \t\t     BT_CONST_FEXCEPT_T_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_UINT8, BT_PTR, BT_CONST_PTR, BT_UINT8)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n "}, {"sha": "40fc7e4a3af0194eb0233b7066c76d9f79b15912", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -8479,6 +8479,32 @@ gimple_build (gimple_seq *seq, location_t loc,\n   return res;\n }\n \n+/* Build the call FN () with a result of type TYPE (or no result if TYPE is\n+   void) with a location LOC.  Returns the built expression value (or NULL_TREE\n+   if TYPE is void) and appends statements possibly defining it to SEQ.  */\n+\n+tree\n+gimple_build (gimple_seq *seq, location_t loc, combined_fn fn, tree type)\n+{\n+  tree res = NULL_TREE;\n+  gcall *stmt;\n+  if (internal_fn_p (fn))\n+    stmt = gimple_build_call_internal (as_internal_fn (fn), 0);\n+  else\n+    {\n+      tree decl = builtin_decl_implicit (as_builtin_fn (fn));\n+      stmt = gimple_build_call (decl, 0);\n+    }\n+  if (!VOID_TYPE_P (type))\n+    {\n+      res = create_tmp_reg_or_ssa_name (type);\n+      gimple_call_set_lhs (stmt, res);\n+    }\n+  gimple_set_location (stmt, loc);\n+  gimple_seq_add_stmt_without_update (seq, stmt);\n+  return res;\n+}\n+\n /* Build the call FN (ARG0) with a result of type TYPE\n    (or no result if TYPE is void) with location LOC,\n    simplifying it first if possible.  Returns the built\n@@ -8668,6 +8694,26 @@ gimple_build_vector (gimple_seq *seq, location_t loc,\n   return builder->build ();\n }\n \n+/* Emit gimple statements into &stmts that take a value given in OLD_SIZE\n+   and generate a value guaranteed to be rounded upwards to ALIGN.\n+\n+   Return the tree node representing this size, it is of TREE_TYPE TYPE.  */\n+\n+tree\n+gimple_build_round_up (gimple_seq *seq, location_t loc, tree type,\n+\t\t       tree old_size, unsigned HOST_WIDE_INT align)\n+{\n+  unsigned HOST_WIDE_INT tg_mask = align - 1;\n+  /* tree new_size = (old_size + tg_mask) & ~tg_mask;  */\n+  gcc_assert (INTEGRAL_TYPE_P (type));\n+  tree tree_mask = build_int_cst (type, tg_mask);\n+  tree oversize = gimple_build (seq, loc, PLUS_EXPR, type, old_size,\n+\t\t\t\ttree_mask);\n+\n+  tree mask = build_int_cst (type, -align);\n+  return gimple_build (seq, loc, BIT_AND_EXPR, type, oversize, mask);\n+}\n+\n /* Return true if the result of assignment STMT is known to be non-negative.\n    If the return value is based on the assumption that signed overflow is\n    undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change"}, {"sha": "a131e364f9a44a216c5752c6b58ef589d5bb5c35", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -90,6 +90,12 @@ gimple_build (gimple_seq *seq,\n {\n   return gimple_build (seq, UNKNOWN_LOCATION, code, type, op0, op1, op2);\n }\n+extern tree gimple_build (gimple_seq *, location_t, combined_fn, tree);\n+inline tree\n+gimple_build (gimple_seq *seq, combined_fn fn, tree type)\n+{\n+  return gimple_build (seq, UNKNOWN_LOCATION, fn, type);\n+}\n extern tree gimple_build (gimple_seq *, location_t, combined_fn, tree, tree);\n inline tree\n gimple_build (gimple_seq *seq, combined_fn fn, tree type, tree arg0)\n@@ -144,6 +150,15 @@ gimple_build_vector (gimple_seq *seq, tree_vector_builder *builder)\n   return gimple_build_vector (seq, UNKNOWN_LOCATION, builder);\n }\n \n+extern tree gimple_build_round_up (gimple_seq *, location_t, tree, tree,\n+\t\t\t\t   unsigned HOST_WIDE_INT);\n+inline tree\n+gimple_build_round_up (gimple_seq *seq, tree type, tree old_size,\n+\t\t       unsigned HOST_WIDE_INT align)\n+{\n+  return gimple_build_round_up (seq, UNKNOWN_LOCATION, type, old_size, align);\n+}\n+\n extern bool gimple_stmt_nonnegative_warnv_p (gimple *, bool *, int = 0);\n extern bool gimple_stmt_integer_valued_real_p (gimple *, int = 0);\n "}, {"sha": "075d6e5208a392956436bf92cb88a9e3378e5216", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -753,6 +753,7 @@ dump_gimple_call_args (pretty_printer *buffer, const gcall *gs,\n \t  limit = ARRAY_SIZE (reduction_args);\n \t  break;\n \n+\tcase IFN_HWASAN_MARK:\n \tcase IFN_ASAN_MARK:\n #define DEF(X) #X\n \t  static const char *const asan_mark_args[] = {IFN_ASAN_MARK_FLAGS};"}, {"sha": "54cb66bd1dd5498c8af62ddecf90401ed4cbe05e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -1237,8 +1237,11 @@ asan_poison_variable (tree decl, bool poison, gimple_stmt_iterator *it,\n \n   /* It's necessary to have all stack variables aligned to ASAN granularity\n      bytes.  */\n-  if (DECL_ALIGN_UNIT (decl) <= ASAN_SHADOW_GRANULARITY)\n-    SET_DECL_ALIGN (decl, BITS_PER_UNIT * ASAN_SHADOW_GRANULARITY);\n+  gcc_assert (!hwasan_sanitize_p () || hwasan_sanitize_stack_p ());\n+  unsigned shadow_granularity\n+    = hwasan_sanitize_p () ? HWASAN_TAG_GRANULE_SIZE : ASAN_SHADOW_GRANULARITY;\n+  if (DECL_ALIGN_UNIT (decl) <= shadow_granularity)\n+    SET_DECL_ALIGN (decl, BITS_PER_UNIT * shadow_granularity);\n \n   HOST_WIDE_INT flags = poison ? ASAN_MARK_POISON : ASAN_MARK_UNPOISON;\n \n@@ -15392,7 +15395,7 @@ gimplify_function_tree (tree fndecl)\n      if necessary.  */\n   cfun->curr_properties |= PROP_gimple_lva;\n \n-  if (asan_sanitize_use_after_scope () && sanitize_flags_p (SANITIZE_ADDRESS))\n+  if (asan_sanitize_use_after_scope ())\n     asan_poisoned_variables = new hash_set<tree> ();\n   bind = gimplify_body (fndecl, true);\n   if (asan_poisoned_variables)"}, {"sha": "3a979f144dec8983b5c73770b4035233249c38f7", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -468,6 +468,111 @@ expand_UBSAN_OBJECT_SIZE (internal_fn, gcall *)\n \n /* This should get expanded in the sanopt pass.  */\n \n+static void\n+expand_HWASAN_CHECK (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* For hwasan stack tagging:\n+   Clear tags on the dynamically allocated space.\n+   For use after an object dynamically allocated on the stack goes out of\n+   scope.  */\n+static void\n+expand_HWASAN_ALLOCA_UNPOISON (internal_fn, gcall *gc)\n+{\n+  gcc_assert (Pmode == ptr_mode);\n+  tree restored_position = gimple_call_arg (gc, 0);\n+  rtx restored_rtx = expand_expr (restored_position, NULL_RTX, VOIDmode,\n+\t\t\t\t  EXPAND_NORMAL);\n+  rtx func = init_one_libfunc (\"__hwasan_tag_memory\");\n+  rtx off = expand_simple_binop (Pmode, MINUS, restored_rtx,\n+\t\t\t\t stack_pointer_rtx, NULL_RTX, 0,\n+\t\t\t\t OPTAB_WIDEN);\n+  emit_library_call_value (func, NULL_RTX, LCT_NORMAL, VOIDmode,\n+\t\t\t   virtual_stack_dynamic_rtx, Pmode,\n+\t\t\t   HWASAN_STACK_BACKGROUND, QImode,\n+\t\t\t   off, Pmode);\n+}\n+\n+/* For hwasan stack tagging:\n+   Return a tag to be used for a dynamic allocation.  */\n+static void\n+expand_HWASAN_CHOOSE_TAG (internal_fn, gcall *gc)\n+{\n+  tree tag = gimple_call_lhs (gc);\n+  rtx target = expand_expr (tag, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+  machine_mode mode = GET_MODE (target);\n+  gcc_assert (mode == QImode);\n+\n+  rtx base_tag = targetm.memtag.extract_tag (hwasan_frame_base (), NULL_RTX);\n+  gcc_assert (base_tag);\n+  rtx tag_offset = gen_int_mode (hwasan_current_frame_tag (), QImode);\n+  rtx chosen_tag = expand_simple_binop (QImode, PLUS, base_tag, tag_offset,\n+\t\t\t\t\ttarget, /* unsignedp = */1,\n+\t\t\t\t\tOPTAB_WIDEN);\n+  chosen_tag = hwasan_truncate_to_tag_size (chosen_tag, target);\n+\n+  /* Really need to put the tag into the `target` RTX.  */\n+  if (chosen_tag != target)\n+    {\n+      rtx temp = chosen_tag;\n+      gcc_assert (GET_MODE (chosen_tag) == mode);\n+      emit_move_insn (target, temp);\n+    }\n+\n+  hwasan_increment_frame_tag ();\n+}\n+\n+/* For hwasan stack tagging:\n+   Tag a region of space in the shadow stack according to the base pointer of\n+   an object on the stack.  N.b. the length provided in the internal call is\n+   required to be aligned to HWASAN_TAG_GRANULE_SIZE.  */\n+static void\n+expand_HWASAN_MARK (internal_fn, gcall *gc)\n+{\n+  gcc_assert (ptr_mode == Pmode);\n+  HOST_WIDE_INT flag = tree_to_shwi (gimple_call_arg (gc, 0));\n+  bool is_poison = ((asan_mark_flags)flag) == ASAN_MARK_POISON;\n+\n+  tree base = gimple_call_arg (gc, 1);\n+  gcc_checking_assert (TREE_CODE (base) == ADDR_EXPR);\n+  rtx base_rtx = expand_normal (base);\n+\n+  rtx tag = is_poison ? HWASAN_STACK_BACKGROUND\n+    : targetm.memtag.extract_tag (base_rtx, NULL_RTX);\n+  rtx address = targetm.memtag.untagged_pointer (base_rtx, NULL_RTX);\n+\n+  tree len = gimple_call_arg (gc, 2);\n+  rtx r_len = expand_normal (len);\n+\n+  rtx func = init_one_libfunc (\"__hwasan_tag_memory\");\n+  emit_library_call (func, LCT_NORMAL, VOIDmode, address, Pmode,\n+\t\t     tag, QImode, r_len, Pmode);\n+}\n+\n+/* For hwasan stack tagging:\n+   Store a tag into a pointer.  */\n+static void\n+expand_HWASAN_SET_TAG (internal_fn, gcall *gc)\n+{\n+  gcc_assert (ptr_mode == Pmode);\n+  tree g_target = gimple_call_lhs (gc);\n+  tree g_ptr = gimple_call_arg (gc, 0);\n+  tree g_tag = gimple_call_arg (gc, 1);\n+\n+  rtx ptr = expand_normal (g_ptr);\n+  rtx tag = expand_expr (g_tag, NULL_RTX, QImode, EXPAND_NORMAL);\n+  rtx target = expand_normal (g_target);\n+\n+  rtx untagged = targetm.memtag.untagged_pointer (ptr, target);\n+  rtx tagged_value = targetm.memtag.set_tag (untagged, tag, target);\n+  if (tagged_value != target)\n+    emit_move_insn (target, tagged_value);\n+}\n+\n+/* This should get expanded in the sanopt pass.  */\n+\n static void\n expand_ASAN_CHECK (internal_fn, gcall *)\n {"}, {"sha": "91a7bfea3eecad747320afcd11e05eedb9f7fcbf", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -321,6 +321,13 @@ DEF_INTERNAL_FN (UBSAN_PTR, ECF_LEAF | ECF_NOTHROW, \". R . \")\n DEF_INTERNAL_FN (UBSAN_OBJECT_SIZE, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN, NULL)\n DEF_INTERNAL_FN (BUILTIN_EXPECT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (HWASAN_ALLOCA_UNPOISON, ECF_LEAF | ECF_NOTHROW, \". R \")\n+DEF_INTERNAL_FN (HWASAN_CHOOSE_TAG, ECF_LEAF | ECF_NOTHROW, \". \")\n+DEF_INTERNAL_FN (HWASAN_CHECK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW,\n+\t\t \". . R . . \")\n+DEF_INTERNAL_FN (HWASAN_MARK, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (HWASAN_SET_TAG,\n+\t\t ECF_TM_PURE | ECF_PURE | ECF_LEAF | ECF_NOTHROW, \". R R \")\n DEF_INTERNAL_FN (ASAN_CHECK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW,\n \t\t \". . R . . \")\n DEF_INTERNAL_FN (ASAN_MARK, ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "f02731e8f2b5c7e78000d768e7c472658883ccb4", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -183,6 +183,61 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_POINTER_SUBTRACT, \"__sanitizer_ptr_sub\",\n /* Hardware Address Sanitizer.  */\n DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_INIT, \"__hwasan_init\",\n \t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD1, \"__hwasan_load1\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD2, \"__hwasan_load2\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD4, \"__hwasan_load4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD8, \"__hwasan_load8\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD16, \"__hwasan_load16\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOADN, \"__hwasan_loadN\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE1, \"__hwasan_store1\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE2, \"__hwasan_store2\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE4, \"__hwasan_store4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE8, \"__hwasan_store8\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE16, \"__hwasan_store16\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STOREN, \"__hwasan_storeN\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD1_NOABORT, \"__hwasan_load1_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD2_NOABORT, \"__hwasan_load2_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD4_NOABORT, \"__hwasan_load4_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD8_NOABORT, \"__hwasan_load8_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOAD16_NOABORT, \"__hwasan_load16_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_LOADN_NOABORT, \"__hwasan_loadN_noabort\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE1_NOABORT, \"__hwasan_store1_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE2_NOABORT, \"__hwasan_store2_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE4_NOABORT, \"__hwasan_store4_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE8_NOABORT, \"__hwasan_store8_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STORE16_NOABORT,\n+\t\t      \"__hwasan_store16_noabort\",\n+\t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_STOREN_NOABORT, \"__hwasan_storeN_noabort\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_TAG_MISMATCH4, \"__hwasan_tag_mismatch4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_HANDLE_LONGJMP, \"__hwasan_handle_longjmp\",\n+\t\t      BT_FN_VOID_CONST_PTR, ATTR_NOTHROW_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_TAG_PTR, \"__hwasan_tag_pointer\",\n+\t\t      BT_FN_PTR_CONST_PTR_UINT8, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_TAG_MEM, \"__hwasan_tag_memory\",\n \t\t      BT_FN_VOID_PTR_UINT8_PTRMODE, ATTR_NOTHROW_LIST)\n "}, {"sha": "965ab367c299f9315cddeb968d1c75086c8762b4", "filename": "gcc/sanopt.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -776,7 +776,8 @@ sanopt_optimize_walker (basic_block bb, class sanopt_ctx *ctx)\n   basic_block son;\n   gimple_stmt_iterator gsi;\n   sanopt_info *info = (sanopt_info *) bb->aux;\n-  bool asan_check_optimize = (flag_sanitize & SANITIZE_ADDRESS) != 0;\n+  bool asan_check_optimize\n+    = ((flag_sanitize & (SANITIZE_ADDRESS | SANITIZE_HWADDRESS)) != 0);\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n     {\n@@ -806,6 +807,7 @@ sanopt_optimize_walker (basic_block bb, class sanopt_ctx *ctx)\n       if (asan_check_optimize\n \t  && gimple_call_builtin_p (stmt, BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT))\n \t{\n+\t  gcc_assert (!hwasan_sanitize_p ());\n \t  use_operand_p use;\n \t  gimple *use_stmt;\n \t  if (single_imm_use (gimple_vdef (stmt), &use, &use_stmt))\n@@ -834,6 +836,7 @@ sanopt_optimize_walker (basic_block bb, class sanopt_ctx *ctx)\n \t  case IFN_UBSAN_PTR:\n \t    remove = maybe_optimize_ubsan_ptr_ifn (ctx, stmt);\n \t    break;\n+\t  case IFN_HWASAN_CHECK:\n \t  case IFN_ASAN_CHECK:\n \t    if (asan_check_optimize)\n \t      remove = maybe_optimize_asan_check_ifn (ctx, stmt);\n@@ -1262,17 +1265,21 @@ sanitize_rewrite_addressable_params (function *fun)\n unsigned int\n pass_sanopt::execute (function *fun)\n {\n+  /* n.b. ASAN_MARK is used for both HWASAN and ASAN.\n+     asan_num_accesses is hence used to count either HWASAN_CHECK or ASAN_CHECK\n+     stuff.  This is fine because you can only have one of these active at a\n+     time.  */\n   basic_block bb;\n   int asan_num_accesses = 0;\n   bool contains_asan_mark = false;\n \n   /* Try to remove redundant checks.  */\n   if (optimize\n       && (flag_sanitize\n-\t  & (SANITIZE_NULL | SANITIZE_ALIGNMENT\n+\t  & (SANITIZE_NULL | SANITIZE_ALIGNMENT | SANITIZE_HWADDRESS\n \t     | SANITIZE_ADDRESS | SANITIZE_VPTR | SANITIZE_POINTER_OVERFLOW)))\n     asan_num_accesses = sanopt_optimize (fun, &contains_asan_mark);\n-  else if (flag_sanitize & SANITIZE_ADDRESS)\n+  else if (flag_sanitize & (SANITIZE_ADDRESS | SANITIZE_HWADDRESS))\n     {\n       gimple_stmt_iterator gsi;\n       FOR_EACH_BB_FN (bb, fun)\n@@ -1292,7 +1299,7 @@ pass_sanopt::execute (function *fun)\n       sanitize_asan_mark_poison ();\n     }\n \n-  if (asan_sanitize_stack_p ())\n+  if (asan_sanitize_stack_p () || hwasan_sanitize_stack_p ())\n     sanitize_rewrite_addressable_params (fun);\n \n   bool use_calls = param_asan_instrumentation_with_call_threshold < INT_MAX\n@@ -1334,6 +1341,9 @@ pass_sanopt::execute (function *fun)\n \t\tcase IFN_UBSAN_VPTR:\n \t\t  no_next = ubsan_expand_vptr_ifn (&gsi);\n \t\t  break;\n+\t\tcase IFN_HWASAN_CHECK:\n+\t\t  no_next = hwasan_expand_check_ifn (&gsi, use_calls);\n+\t\t  break;\n \t\tcase IFN_ASAN_CHECK:\n \t\t  no_next = asan_expand_check_ifn (&gsi, use_calls);\n \t\t  break;\n@@ -1345,6 +1355,9 @@ pass_sanopt::execute (function *fun)\n \t\t\t\t\t\t    &need_commit_edge_insert,\n \t\t\t\t\t\t    shadow_vars_mapping);\n \t\t  break;\n+\t\tcase IFN_HWASAN_MARK:\n+\t\t  no_next = hwasan_expand_mark_ifn (&gsi);\n+\t\t  break;\n \t\tdefault:\n \t\t  break;\n \t\t}"}, {"sha": "cb4ae77fccb44769732f9677a65c96be6321c9fa", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a732514865f3607cc01f5c5b078f63580ef4b1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=93a732514865f3607cc01f5c5b078f63580ef4b1", "patch": "@@ -512,7 +512,7 @@ compile_file (void)\n       if (flag_sanitize & SANITIZE_THREAD)\n \ttsan_finish_file ();\n \n-      if (flag_sanitize & SANITIZE_HWADDRESS)\n+      if (gate_hwasan ())\n \thwasan_finish_file ();\n \n       omp_finish_file ();"}]}