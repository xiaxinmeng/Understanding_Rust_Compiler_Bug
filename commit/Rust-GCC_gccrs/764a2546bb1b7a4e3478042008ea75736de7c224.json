{"sha": "764a2546bb1b7a4e3478042008ea75736de7c224", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY0YTI1NDZiYjFiN2E0ZTM0NzgwNDIwMDhlYTc1NzM2ZGU3YzIyNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-10-07T12:20:17Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-10-07T12:20:17Z"}, "message": "function.c (frame_required_for_rtx): Remove function.\n\n\t* function.c (frame_required_for_rtx): Remove function.\n\t(requires_stack_frame_p): New arg set_up_by_prologue.  All callers\n\tchanged.  Compute a set of mentioned registers and compare against\n\tthe new arg rather than calling frame_required_for_rtx.\n\t(thread_prologue_and_epilogue_insns): Compute the set_up_by_prologue\n\treg set.  Convert the unconverted_simple_returns mechanism to store\n\tjump insns rather than their basic blocks.  Also check the\n\torig_entry_edge destination for new blocks.\n\nFrom-SVN: r179654", "tree": {"sha": "75f1b4d01d5b4be1eae0851d70a65cea44fab5f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75f1b4d01d5b4be1eae0851d70a65cea44fab5f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/764a2546bb1b7a4e3478042008ea75736de7c224", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764a2546bb1b7a4e3478042008ea75736de7c224", "html_url": "https://github.com/Rust-GCC/gccrs/commit/764a2546bb1b7a4e3478042008ea75736de7c224", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764a2546bb1b7a4e3478042008ea75736de7c224/comments", "author": null, "committer": null, "parents": [{"sha": "87aab9b24b6ef536f090e3c5acb7e68d14f141fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87aab9b24b6ef536f090e3c5acb7e68d14f141fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87aab9b24b6ef536f090e3c5acb7e68d14f141fe"}], "stats": {"total": 85, "additions": 56, "deletions": 29}, "files": [{"sha": "c5722341e198e9198842aface96901e5d29f5fb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764a2546bb1b7a4e3478042008ea75736de7c224/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764a2546bb1b7a4e3478042008ea75736de7c224/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=764a2546bb1b7a4e3478042008ea75736de7c224", "patch": "@@ -1,3 +1,14 @@\n+2011-10-07  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* function.c (frame_required_for_rtx): Remove function.\n+\t(requires_stack_frame_p): New arg set_up_by_prologue.  All callers\n+\tchanged.  Compute a set of mentioned registers and compare against\n+\tthe new arg rather than calling frame_required_for_rtx.\n+\t(thread_prologue_and_epilogue_insns): Compute the set_up_by_prologue\n+\treg set.  Convert the unconverted_simple_returns mechanism to store\n+\tjump insns rather than their basic blocks.  Also check the\n+\torig_entry_edge destination for new blocks.\n+\n 2011-10-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/50650"}, {"sha": "85a0bb7d2526a2a903c55b08433ad6b944beb001", "filename": "gcc/function.c", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764a2546bb1b7a4e3478042008ea75736de7c224/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764a2546bb1b7a4e3478042008ea75736de7c224/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=764a2546bb1b7a4e3478042008ea75736de7c224", "patch": "@@ -5303,39 +5303,27 @@ record_hard_reg_uses (rtx *px, void *data)\n   for_each_rtx (px, record_hard_reg_uses_1, data);\n }\n \n-/* A subroutine of requires_stack_frame_p, called via for_each_rtx.\n-   Return 1 if we found an rtx that forces a prologue, zero otherwise.  */\n-static int\n-frame_required_for_rtx (rtx *loc, void *data ATTRIBUTE_UNUSED)\n-{\n-  rtx x = *loc;\n-  if (x == stack_pointer_rtx || x == hard_frame_pointer_rtx\n-      || x == arg_pointer_rtx || x == pic_offset_table_rtx)\n-    return 1;\n-  return 0;\n-}\n-\n /* Return true if INSN requires the stack frame to be set up.\n    PROLOGUE_USED contains the hard registers used in the function\n-   prologue.  */\n+   prologue.  SET_UP_BY_PROLOGUE is the set of registers we expect the\n+   prologue to set up for the function.  */\n static bool\n-requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used)\n+requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used,\n+\t\t\tHARD_REG_SET set_up_by_prologue)\n {\n-  df_ref *def_rec;\n+  df_ref *df_rec;\n   HARD_REG_SET hardregs;\n   unsigned regno;\n \n   if (!INSN_P (insn) || DEBUG_INSN_P (insn))\n     return false;\n   if (CALL_P (insn))\n     return !SIBLING_CALL_P (insn);\n-  if (for_each_rtx (&PATTERN (insn), frame_required_for_rtx, NULL))\n-    return true;\n \n   CLEAR_HARD_REG_SET (hardregs);\n-  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+  for (df_rec = DF_INSN_DEFS (insn); *df_rec; df_rec++)\n     {\n-      rtx dreg = DF_REF_REG (*def_rec);\n+      rtx dreg = DF_REF_REG (*df_rec);\n \n       if (!REG_P (dreg))\n \tcontinue;\n@@ -5350,6 +5338,20 @@ requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used)\n     if (TEST_HARD_REG_BIT (hardregs, regno)\n \t&& df_regs_ever_live_p (regno))\n       return true;\n+\n+  for (df_rec = DF_INSN_USES (insn); *df_rec; df_rec++)\n+    {\n+      rtx reg = DF_REF_REG (*df_rec);\n+\n+      if (!REG_P (reg))\n+\tcontinue;\n+\n+      add_to_hard_reg_set (&hardregs, GET_MODE (reg),\n+\t\t\t   REGNO (reg));\n+    }\n+  if (hard_reg_set_intersect_p (hardregs, set_up_by_prologue))\n+    return true;\n+\n   return false;\n }\n #endif\n@@ -5455,7 +5457,7 @@ thread_prologue_and_epilogue_insns (void)\n   basic_block last_bb;\n   bool last_bb_active ATTRIBUTE_UNUSED;\n #ifdef HAVE_simple_return\n-  VEC (basic_block, heap) *unconverted_simple_returns = NULL;\n+  VEC (rtx, heap) *unconverted_simple_returns = NULL;\n   basic_block simple_return_block_hot = NULL;\n   basic_block simple_return_block_cold = NULL;\n   bool nonempty_prologue;\n@@ -5575,6 +5577,7 @@ thread_prologue_and_epilogue_insns (void)\n       && nonempty_prologue && !crtl->calls_eh_return)\n     {\n       HARD_REG_SET prologue_clobbered, prologue_used, live_on_edge;\n+      HARD_REG_SET set_up_by_prologue;\n       rtx p_insn;\n \n       VEC(basic_block, heap) *vec;\n@@ -5610,6 +5613,16 @@ thread_prologue_and_epilogue_insns (void)\n \n       vec = VEC_alloc (basic_block, heap, n_basic_blocks);\n \n+      CLEAR_HARD_REG_SET (set_up_by_prologue);\n+      add_to_hard_reg_set (&set_up_by_prologue, Pmode, STACK_POINTER_REGNUM);\n+      add_to_hard_reg_set (&set_up_by_prologue, Pmode, ARG_POINTER_REGNUM);\n+      if (frame_pointer_needed)\n+\tadd_to_hard_reg_set (&set_up_by_prologue, Pmode,\n+\t\t\t     HARD_FRAME_POINTER_REGNUM);\n+      if (pic_offset_table_rtx)\n+\tadd_to_hard_reg_set (&set_up_by_prologue, Pmode,\n+\t\t\t     PIC_OFFSET_TABLE_REGNUM);\n+\n       FOR_EACH_BB (bb)\n \t{\n \t  rtx insn;\n@@ -5628,7 +5641,8 @@ thread_prologue_and_epilogue_insns (void)\n \t    }\n \t  else\n \t    FOR_BB_INSNS (bb, insn)\n-\t      if (requires_stack_frame_p (insn, prologue_used))\n+\t      if (requires_stack_frame_p (insn, prologue_used,\n+\t\t\t\t\t  set_up_by_prologue))\n \t\t{\n \t\t  bitmap_set_bit (&bb_flags, bb->index);\n \t\t  VEC_quick_push (basic_block, vec, bb);\n@@ -5872,8 +5886,8 @@ thread_prologue_and_epilogue_insns (void)\n \t\t{\n #ifdef HAVE_simple_return\n \t\t  if (simple_p)\n-\t\t    VEC_safe_push (basic_block, heap,\n-\t\t\t\t   unconverted_simple_returns, bb);\n+\t\t    VEC_safe_push (rtx, heap,\n+\t\t\t\t   unconverted_simple_returns, jump);\n #endif\n \t\t  continue;\n \t\t}\n@@ -5891,8 +5905,8 @@ thread_prologue_and_epilogue_insns (void)\n \t    {\n #ifdef HAVE_simple_return\n \t      if (simple_p)\n-\t\tVEC_safe_push (basic_block, heap,\n-\t\t\t       unconverted_simple_returns, bb);\n+\t\tVEC_safe_push (rtx, heap,\n+\t\t\t       unconverted_simple_returns, jump);\n #endif\n \t      continue;\n \t    }\n@@ -6022,6 +6036,7 @@ thread_prologue_and_epilogue_insns (void)\n       blocks = sbitmap_alloc (last_basic_block);\n       sbitmap_zero (blocks);\n       SET_BIT (blocks, entry_edge->dest->index);\n+      SET_BIT (blocks, orig_entry_edge->dest->index);\n       find_many_sub_basic_blocks (blocks);\n       sbitmap_free (blocks);\n \n@@ -6040,10 +6055,10 @@ thread_prologue_and_epilogue_insns (void)\n      convert to conditional simple_returns, but couldn't for some\n      reason, create a block to hold a simple_return insn and redirect\n      those remaining edges.  */\n-  if (!VEC_empty (basic_block, unconverted_simple_returns))\n+  if (!VEC_empty (rtx, unconverted_simple_returns))\n     {\n       basic_block exit_pred = EXIT_BLOCK_PTR->prev_bb;\n-      basic_block src_bb;\n+      rtx jump;\n       int i;\n \n       gcc_assert (entry_edge != orig_entry_edge);\n@@ -6061,8 +6076,9 @@ thread_prologue_and_epilogue_insns (void)\n \t    simple_return_block_cold = e->dest;\n \t}\n \n-      FOR_EACH_VEC_ELT (basic_block, unconverted_simple_returns, i, src_bb)\n+      FOR_EACH_VEC_ELT (rtx, unconverted_simple_returns, i, jump)\n \t{\n+\t  basic_block src_bb = BLOCK_FOR_INSN (jump);\n \t  edge e = find_edge (src_bb, last_bb);\n \t  basic_block *pdest_bb;\n \n@@ -6087,7 +6103,7 @@ thread_prologue_and_epilogue_insns (void)\n \t    }\n \t  redirect_edge_and_branch_force (e, *pdest_bb);\n \t}\n-      VEC_free (basic_block, heap, unconverted_simple_returns);\n+      VEC_free (rtx, heap, unconverted_simple_returns);\n     }\n #endif\n "}]}