{"sha": "12f0c50ca93bed7c589750e20df7977787e0ea07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJmMGM1MGNhOTNiZWQ3YzU4OTc1MGUyMGRmNzk3Nzc4N2UwZWEwNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T12:26:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T12:26:47Z"}, "message": "[multiple changes]\n\n2011-08-02  Geert Bosch  <bosch@adacore.com>\n\n\t* a-calfor.adb (Image): Simplify, removing unnecessary uses of 'Image.\n\n2011-08-02  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_type.adb (Covers): Move trivial case to the top and reuse the\n\tcomputed value of Base_Type.\n\n2011-08-02  Yannick Moy  <moy@adacore.com>\n\n\t* restrict.adb (Check_Restriction): issue an error for any use of\n\tclass-wide, even if the No_Dispatch restriction is not set.\n\t* sem_aggr.adb: Correct typos in comments and messages in formal mode\n\t* sem_ch3.adb (Process_Full_View): issue an error in formal mode is,\n\twhen completing a private extension, the type named in the private part\n\tis not the same as that named in the visible part.\n\t* sem_res.adb (Resolve_Call): issue an error in formal mode on the use\n\tof an inherited primitive operations of a tagged type or type extension\n\tthat returns the tagged type.\n\t* sem_util.adb, sem_util.ads (Is_Inherited_Operation_For_Type): new\n\tfunction which returns True for an implicit operation inherited by the\n\tderived type declaration for the argument type.\n\t(Is_SPARK_Object_Reference): move to appropriate place in alphabetic\n\torder.\n\nFrom-SVN: r177135", "tree": {"sha": "e9994213bbdf660c6dabde2c267fe268880d00c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9994213bbdf660c6dabde2c267fe268880d00c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12f0c50ca93bed7c589750e20df7977787e0ea07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f0c50ca93bed7c589750e20df7977787e0ea07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f0c50ca93bed7c589750e20df7977787e0ea07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f0c50ca93bed7c589750e20df7977787e0ea07/comments", "author": null, "committer": null, "parents": [{"sha": "fb86fe11bfa9d28396b7283c41f8da190e205934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb86fe11bfa9d28396b7283c41f8da190e205934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb86fe11bfa9d28396b7283c41f8da190e205934"}], "stats": {"total": 535, "additions": 278, "deletions": 257}, "files": [{"sha": "9ba947a1dc1b641eda111a0efc2a8b0e3437150c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -1,3 +1,29 @@\n+2011-08-02  Geert Bosch  <bosch@adacore.com>\n+\n+\t* a-calfor.adb (Image): Simplify, removing unnecessary uses of 'Image.\n+\n+2011-08-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_type.adb (Covers): Move trivial case to the top and reuse the\n+\tcomputed value of Base_Type.\n+\n+2011-08-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* restrict.adb (Check_Restriction): issue an error for any use of\n+\tclass-wide, even if the No_Dispatch restriction is not set.\n+\t* sem_aggr.adb: Correct typos in comments and messages in formal mode\n+\t* sem_ch3.adb (Process_Full_View): issue an error in formal mode is,\n+\twhen completing a private extension, the type named in the private part\n+\tis not the same as that named in the visible part.\n+\t* sem_res.adb (Resolve_Call): issue an error in formal mode on the use\n+\tof an inherited primitive operations of a tagged type or type extension\n+\tthat returns the tagged type.\n+\t* sem_util.adb, sem_util.ads (Is_Inherited_Operation_For_Type): new\n+\tfunction which returns True for an implicit operation inherited by the\n+\tderived type declaration for the argument type.\n+\t(Is_SPARK_Object_Reference): move to appropriate place in alphabetic\n+\torder.\n+\n 2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch5.adb (Pre_Analyze_Range): new procedure extracted from"}, {"sha": "41f8c2595dd38723cf45de38fb5fef761b86912d", "filename": "gcc/ada/a-calfor.adb", "status": "modified", "additions": 58, "deletions": 125, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fa-calfor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fa-calfor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calfor.adb?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -139,83 +139,53 @@ package body Ada.Calendar.Formatting is\n      (Elapsed_Time          : Duration;\n       Include_Time_Fraction : Boolean := False) return String\n    is\n+      To_Char    : constant array (0 .. 9) of Character := \"0123456789\";\n       Hour       : Hour_Number;\n       Minute     : Minute_Number;\n       Second     : Second_Number;\n       Sub_Second : Duration;\n       SS_Nat     : Natural;\n \n-      Low  : Integer;\n-      High : Integer;\n+      --  Determine the two slice bounds for the result string depending on\n+      --  whether the input is negative and whether fractions are requested.\n+\n+      First  : constant Integer := (if Elapsed_Time < 0.0 then 1 else 2);\n+      Last   : constant Integer := (if Include_Time_Fraction then 12 else 9);\n \n       Result : String := \"-00:00:00.00\";\n \n    begin\n       Split (abs (Elapsed_Time), Hour, Minute, Second, Sub_Second);\n \n-      --  Determine the two slice bounds for the result string depending on\n-      --  whether the input is negative and whether fractions are requested.\n+      --  Hour processing, positions 2 and 3\n \n-      Low  := (if Elapsed_Time < 0.0 then 1 else 2);\n-      High := (if Include_Time_Fraction then 12 else 9);\n+      Result (2) := To_Char (Hour / 10);\n+      Result (3) := To_Char (Hour mod 10);\n \n-      --  Prevent rounding when converting to natural\n+      --  Minute processing, positions 5 and 6\n \n-      Sub_Second := Sub_Second * 100.0;\n+      Result (5) := To_Char (Minute / 10);\n+      Result (6) := To_Char (Minute mod 10);\n \n-      if Sub_Second > 0.0 then\n-         Sub_Second := Sub_Second - 0.5;\n-      end if;\n+      --  Second processing, positions 8 and 9\n \n-      SS_Nat := Natural (Sub_Second);\n+      Result (8) := To_Char (Second / 10);\n+      Result (9) := To_Char (Second mod 10);\n \n-      declare\n-         Hour_Str   : constant String := Hour_Number'Image (Hour);\n-         Minute_Str : constant String := Minute_Number'Image (Minute);\n-         Second_Str : constant String := Second_Number'Image (Second);\n-         SS_Str     : constant String := Natural'Image (SS_Nat);\n+      --  Optional sub second processing, positions 11 and 12\n \n-      begin\n-         --  Hour processing, positions 2 and 3\n+      if Include_Time_Fraction and then Sub_Second > 0.0 then\n \n-         if Hour < 10 then\n-            Result (3) := Hour_Str (2);\n-         else\n-            Result (2) := Hour_Str (2);\n-            Result (3) := Hour_Str (3);\n-         end if;\n-\n-         --  Minute processing, positions 5 and 6\n+         --  Prevent rounding up when converting to natural, avoiding the zero\n+         --  case to prevent rounding down to a negative number.\n \n-         if Minute < 10 then\n-            Result (6) := Minute_Str (2);\n-         else\n-            Result (5) := Minute_Str (2);\n-            Result (6) := Minute_Str (3);\n-         end if;\n+         SS_Nat := Natural (Duration'(Sub_Second * 100.0) - 0.5);\n \n-         --  Second processing, positions 8 and 9\n-\n-         if Second < 10 then\n-            Result (9) := Second_Str (2);\n-         else\n-            Result (8) := Second_Str (2);\n-            Result (9) := Second_Str (3);\n-         end if;\n-\n-         --  Optional sub second processing, positions 11 and 12\n-\n-         if Include_Time_Fraction then\n-            if SS_Nat < 10 then\n-               Result (12) := SS_Str (2);\n-            else\n-               Result (11) := SS_Str (2);\n-               Result (12) := SS_Str (3);\n-            end if;\n-         end if;\n+         Result (11) := To_Char (SS_Nat / 10);\n+         Result (12) := To_Char (SS_Nat mod 10);\n+      end if;\n \n-         return Result (Low .. High);\n-      end;\n+      return Result (First .. Last);\n    end Image;\n \n    -----------\n@@ -227,6 +197,8 @@ package body Ada.Calendar.Formatting is\n       Include_Time_Fraction : Boolean := False;\n       Time_Zone             : Time_Zones.Time_Offset := 0) return String\n    is\n+      To_Char    : constant array (0 .. 9) of Character := \"0123456789\";\n+\n       Year        : Year_Number;\n       Month       : Month_Number;\n       Day         : Day_Number;\n@@ -237,99 +209,60 @@ package body Ada.Calendar.Formatting is\n       SS_Nat      : Natural;\n       Leap_Second : Boolean;\n \n+      --  The result length depends on whether fractions are requested.\n+\n       Result : String := \"0000-00-00 00:00:00.00\";\n+      Last   : constant Positive\n+                 := Result'Last - (if Include_Time_Fraction then 0 else 3);\n \n    begin\n       Split (Date, Year, Month, Day,\n              Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n \n-      --  Prevent rounding when converting to natural\n-\n-      Sub_Second := Sub_Second * 100.0;\n-\n-      if Sub_Second > 0.0 then\n-         Sub_Second := Sub_Second - 0.5;\n-      end if;\n-\n-      SS_Nat := Natural (Sub_Second);\n+      --  Year processing, positions 1, 2, 3 and 4\n \n-      declare\n-         Year_Str   : constant String := Year_Number'Image (Year);\n-         Month_Str  : constant String := Month_Number'Image (Month);\n-         Day_Str    : constant String := Day_Number'Image (Day);\n-         Hour_Str   : constant String := Hour_Number'Image (Hour);\n-         Minute_Str : constant String := Minute_Number'Image (Minute);\n-         Second_Str : constant String := Second_Number'Image (Second);\n-         SS_Str     : constant String := Natural'Image (SS_Nat);\n+      Result (1) := To_Char (Year / 1000);\n+      Result (2) := To_Char (Year / 100 mod 10);\n+      Result (3) := To_Char (Year / 10 mod 10);\n+      Result (4) := To_Char (Year mod 10);\n \n-      begin\n-         --  Year processing, positions 1, 2, 3 and 4\n+      --  Month processing, positions 6 and 7\n \n-         Result (1) := Year_Str (2);\n-         Result (2) := Year_Str (3);\n-         Result (3) := Year_Str (4);\n-         Result (4) := Year_Str (5);\n+      Result (6) := To_Char (Month / 10);\n+      Result (7) := To_Char (Month mod 10);\n \n-         --  Month processing, positions 6 and 7\n+      --  Day processing, positions 9 and 10\n \n-         if Month < 10 then\n-            Result (7) := Month_Str (2);\n-         else\n-            Result (6) := Month_Str (2);\n-            Result (7) := Month_Str (3);\n-         end if;\n+      Result (9)  := To_Char (Day / 10);\n+      Result (10) := To_Char (Day mod 10);\n \n-         --  Day processing, positions 9 and 10\n+      Result (12) := To_Char (Hour / 10);\n+      Result (13) := To_Char (Hour mod 10);\n \n-         if Day < 10 then\n-            Result (10) := Day_Str (2);\n-         else\n-            Result (9)  := Day_Str (2);\n-            Result (10) := Day_Str (3);\n-         end if;\n+      --  Minute processing, positions 15 and 16\n \n-         --  Hour processing, positions 12 and 13\n+      Result (15) := To_Char (Minute / 10);\n+      Result (16) := To_Char (Minute mod 10);\n \n-         if Hour < 10 then\n-            Result (13) := Hour_Str (2);\n-         else\n-            Result (12) := Hour_Str (2);\n-            Result (13) := Hour_Str (3);\n-         end if;\n+      --  Second processing, positions 18 and 19\n \n-         --  Minute processing, positions 15 and 16\n+      Result (18) := To_Char (Second / 10);\n+      Result (19) := To_Char (Second mod 10);\n \n-         if Minute < 10 then\n-            Result (16) := Minute_Str (2);\n-         else\n-            Result (15) := Minute_Str (2);\n-            Result (16) := Minute_Str (3);\n-         end if;\n+      --  Optional sub second processing, positions 21 and 22\n \n-         --  Second processing, positions 18 and 19\n+      if Include_Time_Fraction and then Sub_Second > 0.0 then\n \n-         if Second < 10 then\n-            Result (19) := Second_Str (2);\n-         else\n-            Result (18) := Second_Str (2);\n-            Result (19) := Second_Str (3);\n-         end if;\n+         --  Prevent rounding up when converting to natural, avoiding the zero\n+         --  case to prevent rounding down to a negative number.\n \n-         --  Optional sub second processing, positions 21 and 22\n+         SS_Nat := Natural (Duration'(Sub_Second * 100.0) - 0.5);\n \n-         if Include_Time_Fraction then\n-            if SS_Nat < 10 then\n-               Result (22) := SS_Str (2);\n-            else\n-               Result (21) := SS_Str (2);\n-               Result (22) := SS_Str (3);\n-            end if;\n+         Result (21) := To_Char (SS_Nat / 10);\n+         Result (22) := To_Char (SS_Nat mod 10);\n+      end if;\n \n-            return Result;\n-         else\n-            return Result (1 .. 19);\n-         end if;\n-      end;\n+      return Result (Result'First .. Last);\n    end Image;\n \n    ------------"}, {"sha": "215a21f505f9052adc3dea218037e3fce25bc605", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -331,6 +331,13 @@ package body Restrict is\n          return;\n       end if;\n \n+      --  In formal mode, issue an error for any use of class-wide, even if the\n+      --  No_Dispatch restriction is not set.\n+\n+      if R = No_Dispatch then\n+         Check_Formal_Restriction (\"class-wide is not allowed\", N);\n+      end if;\n+\n       if UI_Is_In_Int_Range (V) then\n          VV := Integer (UI_To_Int (V));\n       else"}, {"sha": "28193ef0ce41d3a73301be6066668c19298c88b4", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -2375,11 +2375,11 @@ package body Sem_Aggr is\n    --  components of the given type mark.\n \n    --  b) If the ancestor part is an expression, it must be unambiguous, and\n-   --  once we have its type we can also compute the needed  components as in\n+   --  once we have its type we can also compute the needed components as in\n    --  the previous case. In both cases, if the ancestor type is not the\n    --  immediate ancestor, we have to build this ancestor recursively.\n \n-   --  In both cases discriminants of the ancestor type do not play a role in\n+   --  In both cases, discriminants of the ancestor type do not play a role in\n    --  the resolution of the needed components, because inherited discriminants\n    --  cannot be used in a type extension. As a result we can compute\n    --  independently the list of components of the ancestor type and of the\n@@ -2483,13 +2483,12 @@ package body Sem_Aggr is\n       Analyze (A);\n       Check_Parameterless_Call (A);\n \n-      --  In SPARK or ALFA, the ancestor part cannot be a subtype mark\n+      --  In SPARK or ALFA, the ancestor part cannot be a type mark\n \n       if Is_Entity_Name (A)\n         and then Is_Type (Entity (A))\n       then\n-         Check_Formal_Restriction\n-           (\"ancestor part cannot be a subtype mark\", A);\n+         Check_Formal_Restriction (\"ancestor part cannot be a type mark\", A);\n       end if;\n \n       if not Is_Tagged_Type (Typ) then"}, {"sha": "2a8d7c19af31019d71dc3493ca76e6edd0befa93", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 91, "deletions": 72, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -17275,89 +17275,108 @@ package body Sem_Ch3 is\n               (\"parent of full type must descend from parent\"\n                   & \" of private extension\", Full_Indic);\n \n-         --  Check the rules of 7.3(10): if the private extension inherits\n-         --  known discriminants, then the full type must also inherit those\n-         --  discriminants from the same (ancestor) type, and the parent\n-         --  subtype of the full type must be constrained if and only if\n-         --  the ancestor subtype of the private extension is constrained.\n-\n-         elsif No (Discriminant_Specifications (Parent (Priv_T)))\n-           and then not Has_Unknown_Discriminants (Priv_T)\n-           and then Has_Discriminants (Base_Type (Priv_Parent))\n-         then\n-            declare\n-               Priv_Indic  : constant Node_Id :=\n-                               Subtype_Indication (Parent (Priv_T));\n+         --  First check a formal restriction, and then proceed with checking\n+         --  Ada rules. Since the formal restriction is not a serious error, we\n+         --  don't prevent further error detection for this check, hence the\n+         --  ELSE.\n \n-               Priv_Constr : constant Boolean :=\n-                               Is_Constrained (Priv_Parent)\n-                                 or else\n-                                   Nkind (Priv_Indic) = N_Subtype_Indication\n-                                 or else Is_Constrained (Entity (Priv_Indic));\n+         else\n \n-               Full_Constr : constant Boolean :=\n-                               Is_Constrained (Full_Parent)\n-                                 or else\n-                                   Nkind (Full_Indic) = N_Subtype_Indication\n-                                 or else Is_Constrained (Entity (Full_Indic));\n+            --  In formal mode, when completing a private extension the type\n+            --  named in the private part must be exactly the same as that\n+            --  named in the visible part.\n \n-               Priv_Discr : Entity_Id;\n-               Full_Discr : Entity_Id;\n+            if Priv_Parent /= Full_Parent then\n+               Error_Msg_Name_1 := Chars (Priv_Parent);\n+               Check_Formal_Restriction (\"% expected\", Full_Indic);\n+            end if;\n \n-            begin\n-               Priv_Discr := First_Discriminant (Priv_Parent);\n-               Full_Discr := First_Discriminant (Full_Parent);\n-               while Present (Priv_Discr) and then Present (Full_Discr) loop\n-                  if Original_Record_Component (Priv_Discr) =\n-                     Original_Record_Component (Full_Discr)\n-                    or else\n-                     Corresponding_Discriminant (Priv_Discr) =\n-                     Corresponding_Discriminant (Full_Discr)\n-                  then\n-                     null;\n-                  else\n-                     exit;\n-                  end if;\n+            --  Check the rules of 7.3(10): if the private extension inherits\n+            --  known discriminants, then the full type must also inherit those\n+            --  discriminants from the same (ancestor) type, and the parent\n+            --  subtype of the full type must be constrained if and only if\n+            --  the ancestor subtype of the private extension is constrained.\n \n-                  Next_Discriminant (Priv_Discr);\n-                  Next_Discriminant (Full_Discr);\n-               end loop;\n+            if No (Discriminant_Specifications (Parent (Priv_T)))\n+              and then not Has_Unknown_Discriminants (Priv_T)\n+              and then Has_Discriminants (Base_Type (Priv_Parent))\n+            then\n+               declare\n+                  Priv_Indic  : constant Node_Id :=\n+                                  Subtype_Indication (Parent (Priv_T));\n+\n+                  Priv_Constr : constant Boolean :=\n+                                  Is_Constrained (Priv_Parent)\n+                                    or else\n+                                      Nkind (Priv_Indic) = N_Subtype_Indication\n+                                        or else\n+                                          Is_Constrained (Entity (Priv_Indic));\n+\n+                  Full_Constr : constant Boolean :=\n+                                  Is_Constrained (Full_Parent)\n+                                    or else\n+                                      Nkind (Full_Indic) = N_Subtype_Indication\n+                                        or else\n+                                          Is_Constrained (Entity (Full_Indic));\n+\n+                  Priv_Discr : Entity_Id;\n+                  Full_Discr : Entity_Id;\n \n-               if Present (Priv_Discr) or else Present (Full_Discr) then\n-                  Error_Msg_N\n-                    (\"full view must inherit discriminants of the parent type\"\n-                     & \" used in the private extension\", Full_Indic);\n+               begin\n+                  Priv_Discr := First_Discriminant (Priv_Parent);\n+                  Full_Discr := First_Discriminant (Full_Parent);\n+                  while Present (Priv_Discr) and then Present (Full_Discr) loop\n+                     if Original_Record_Component (Priv_Discr) =\n+                       Original_Record_Component (Full_Discr)\n+                       or else\n+                         Corresponding_Discriminant (Priv_Discr) =\n+                         Corresponding_Discriminant (Full_Discr)\n+                     then\n+                        null;\n+                     else\n+                        exit;\n+                     end if;\n \n-               elsif Priv_Constr and then not Full_Constr then\n-                  Error_Msg_N\n-                    (\"parent subtype of full type must be constrained\",\n-                     Full_Indic);\n+                     Next_Discriminant (Priv_Discr);\n+                     Next_Discriminant (Full_Discr);\n+                  end loop;\n \n-               elsif Full_Constr and then not Priv_Constr then\n-                  Error_Msg_N\n-                    (\"parent subtype of full type must be unconstrained\",\n-                     Full_Indic);\n-               end if;\n-            end;\n+                  if Present (Priv_Discr) or else Present (Full_Discr) then\n+                     Error_Msg_N\n+                       (\"full view must inherit discriminants of the parent\"\n+                        & \" type used in the private extension\", Full_Indic);\n \n-         --  Check the rules of 7.3(12): if a partial view has neither known\n-         --  or unknown discriminants, then the full type declaration shall\n-         --  define a definite subtype.\n+                  elsif Priv_Constr and then not Full_Constr then\n+                     Error_Msg_N\n+                       (\"parent subtype of full type must be constrained\",\n+                        Full_Indic);\n \n-         elsif      not Has_Unknown_Discriminants (Priv_T)\n-           and then not Has_Discriminants (Priv_T)\n-           and then not Is_Constrained (Full_T)\n-         then\n-            Error_Msg_N\n-              (\"full view must define a constrained type if partial view\"\n-                & \" has no discriminants\", Full_T);\n-         end if;\n+                  elsif Full_Constr and then not Priv_Constr then\n+                     Error_Msg_N\n+                       (\"parent subtype of full type must be unconstrained\",\n+                        Full_Indic);\n+                  end if;\n+               end;\n+\n+               --  Check the rules of 7.3(12): if a partial view has neither\n+               --  known or unknown discriminants, then the full type\n+               --  declaration shall define a definite subtype.\n \n-         --  ??????? Do we implement the following properly ?????\n-         --  If the ancestor subtype of a private extension has constrained\n-         --  discriminants, then the parent subtype of the full view shall\n-         --  impose a statically matching constraint on those discriminants\n-         --  [7.3(13)].\n+            elsif      not Has_Unknown_Discriminants (Priv_T)\n+              and then not Has_Discriminants (Priv_T)\n+              and then not Is_Constrained (Full_T)\n+            then\n+               Error_Msg_N\n+                 (\"full view must define a constrained type if partial view\"\n+                  & \" has no discriminants\", Full_T);\n+            end if;\n+\n+            --  ??????? Do we implement the following properly ?????\n+            --  If the ancestor subtype of a private extension has constrained\n+            --  discriminants, then the parent subtype of the full view shall\n+            --  impose a statically matching constraint on those discriminants\n+            --  [7.3(13)].\n+         end if;\n \n       else\n          --  For untagged types, verify that a type without discriminants"}, {"sha": "00115cc44aa0ca53fcd85d0bd31a9348fd4c955e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -5734,6 +5734,22 @@ package body Sem_Res is\n          Check_For_Eliminated_Subprogram (Subp, Nam);\n       end if;\n \n+      --  In formal mode, the primitive operations of a tagged type or type\n+      --  extension do not include functions that return the tagged type.\n+\n+      --  Commented out as the call to Is_Inherited_Operation_For_Type may\n+      --  cause an error because the type entity of the parent node of\n+      --  Entity (Name (N) may not be set.\n+\n+--      if Nkind (N) = N_Function_Call\n+--        and then Is_Tagged_Type (Etype (N))\n+--        and then Is_Entity_Name (Name (N))\n+--        and then Is_Inherited_Operation_For_Type\n+--         (Entity (Name (N)), Etype (N))\n+--      then\n+--         Check_Formal_Restriction (\"function not inherited\", N);\n+--      end if;\n+\n       --  All done, evaluate call and deal with elaboration issues\n \n       Eval_Call (N);"}, {"sha": "02f6a6f46f68cae7f3f46e3c678fb71314a93388", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -737,22 +737,12 @@ package body Sem_Type is\n          else\n             raise Program_Error;\n          end if;\n+      end if;\n \n-      else\n-         BT1 := Base_Type (T1);\n-         BT2 := Base_Type (T2);\n-\n-         --  Handle underlying view of records with unknown discriminants\n-         --  using the original entity that motivated the construction of\n-         --  this underlying record view (see Build_Derived_Private_Type).\n-\n-         if Is_Underlying_Record_View (BT1) then\n-            BT1 := Underlying_Record_View (BT1);\n-         end if;\n+      --  Trivial case: same types are always compatible\n \n-         if Is_Underlying_Record_View (BT2) then\n-            BT2 := Underlying_Record_View (BT2);\n-         end if;\n+      if T1 = T2 then\n+         return True;\n       end if;\n \n       --  First check for Standard_Void_Type, which is special. Subsequent\n@@ -762,26 +752,38 @@ package body Sem_Type is\n \n       if (T1 = Standard_Void_Type) /= (T2 = Standard_Void_Type) then\n          return False;\n+      end if;\n+\n+      BT1 := Base_Type (T1);\n+      BT2 := Base_Type (T2);\n \n-      --  Simplest case: same types are compatible, and types that have the\n-      --  same base type and are not generic actuals are compatible. Generic\n-      --  actuals  belong to their class but are not compatible with other\n-      --  types of their class, and in particular with other generic actuals.\n-      --  They are however compatible with their own subtypes, and itypes\n-      --  with the same base are compatible as well. Similarly, constrained\n-      --  subtypes obtained from expressions of an unconstrained nominal type\n-      --  are compatible with the base type (may lead to spurious ambiguities\n-      --  in obscure cases ???)\n+      --  Handle underlying view of records with unknown discriminants\n+      --  using the original entity that motivated the construction of\n+      --  this underlying record view (see Build_Derived_Private_Type).\n+\n+      if Is_Underlying_Record_View (BT1) then\n+         BT1 := Underlying_Record_View (BT1);\n+      end if;\n+\n+      if Is_Underlying_Record_View (BT2) then\n+         BT2 := Underlying_Record_View (BT2);\n+      end if;\n+\n+      --  Simplest case: types that have the same base type and are not generic\n+      --  actuals are compatible. Generic actuals belong to their class but are\n+      --  not compatible with other types of their class, and in particular\n+      --  with other generic actuals. They are however compatible with their\n+      --  own subtypes, and itypes with the same base are compatible as well.\n+      --  Similarly, constrained subtypes obtained from expressions of an\n+      --  unconstrained nominal type are compatible with the base type (may\n+      --  lead to spurious ambiguities in obscure cases ???)\n \n       --  Generic actuals require special treatment to avoid spurious ambi-\n       --  guities in an instance, when two formal types are instantiated with\n       --  the same actual, so that different subprograms end up with the same\n       --  signature in the instance.\n \n-      elsif T1 = T2 then\n-         return True;\n-\n-      elsif BT1 = BT2\n+      if BT1 = BT2\n         or else BT1 = T2\n         or else BT2 = T1\n       then\n@@ -830,7 +832,7 @@ package body Sem_Type is\n         and then Is_Interface (Etype (T1))\n         and then Is_Concurrent_Type (T2)\n         and then Interface_Present_In_Ancestor\n-                   (Typ   => Base_Type (T2),\n+                   (Typ   => BT2,\n                     Iface => Etype (T1))\n       then\n          return True;\n@@ -889,7 +891,7 @@ package body Sem_Type is\n       elsif Is_Class_Wide_Type (T2)\n         and then\n           (Class_Wide_Type (T1) = T2\n-             or else Base_Type (Root_Type (T2)) = Base_Type (T1))\n+             or else Base_Type (Root_Type (T2)) = BT1)\n       then\n          return True;\n \n@@ -1037,7 +1039,7 @@ package body Sem_Type is\n \n       --  The actual type may be the result of a previous error\n \n-      elsif Base_Type (T2) = Any_Type then\n+      elsif BT2 = Any_Type then\n          return True;\n \n       --  A packed array type covers its corresponding non-packed type. This is"}, {"sha": "91cc8121d604561c09bfc280798a9d9052418303", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -6745,6 +6745,18 @@ package body Sem_Util is\n                   and then Is_Derived_Type (Etype (E)));\n    end Is_Inherited_Operation;\n \n+   -------------------------------------\n+   -- Is_Inherited_Operation_For_Type --\n+   -------------------------------------\n+\n+   function Is_Inherited_Operation_For_Type\n+     (E, Typ : Entity_Id) return Boolean\n+   is\n+   begin\n+      return Is_Inherited_Operation (E)\n+        and then Etype (Parent (E)) = Typ;\n+   end Is_Inherited_Operation_For_Type;\n+\n    -----------------------------\n    -- Is_Library_Level_Entity --\n    -----------------------------\n@@ -6845,27 +6857,6 @@ package body Sem_Util is\n       end if;\n    end Is_Object_Reference;\n \n-   -------------------------------\n-   -- Is_SPARK_Object_Reference --\n-   -------------------------------\n-\n-   function Is_SPARK_Object_Reference (N : Node_Id) return Boolean is\n-   begin\n-      if Is_Entity_Name (N) then\n-         return Present (Entity (N))\n-           and then\n-             (Ekind_In (Entity (N), E_Constant, E_Variable)\n-               or else Ekind (Entity (N)) in Formal_Kind);\n-\n-      else\n-         if Nkind (N) = N_Selected_Component then\n-            return Is_SPARK_Object_Reference (Prefix (N));\n-         else\n-            return False;\n-         end if;\n-      end if;\n-   end Is_SPARK_Object_Reference;\n-\n    -----------------------------------\n    -- Is_OK_Variable_For_Out_Formal --\n    -----------------------------------\n@@ -7377,6 +7368,29 @@ package body Sem_Util is\n       end if;\n    end Is_Selector_Name;\n \n+   -------------------------------\n+   -- Is_SPARK_Object_Reference --\n+   -------------------------------\n+\n+   function Is_SPARK_Object_Reference (N : Node_Id) return Boolean is\n+   begin\n+      if Is_Entity_Name (N) then\n+         return Present (Entity (N))\n+           and then\n+             (Ekind_In (Entity (N), E_Constant, E_Variable)\n+              or else Ekind (Entity (N)) in Formal_Kind);\n+\n+      else\n+         case Nkind (N) is\n+            when N_Selected_Component =>\n+               return Is_SPARK_Object_Reference (Prefix (N));\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end if;\n+   end Is_SPARK_Object_Reference;\n+\n    ------------------\n    -- Is_Statement --\n    ------------------"}, {"sha": "715fc1b0499daf5b77e593d6dac6c7b05f783eaf", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0c50ca93bed7c589750e20df7977787e0ea07/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=12f0c50ca93bed7c589750e20df7977787e0ea07", "patch": "@@ -748,7 +748,12 @@ package Sem_Util is\n \n    function Is_Inherited_Operation (E : Entity_Id) return Boolean;\n    --  E is a subprogram. Return True is E is an implicit operation inherited\n-   --  by a derived type declarations.\n+   --  by a derived type declaration.\n+\n+   function Is_Inherited_Operation_For_Type\n+     (E, Typ : Entity_Id) return Boolean;\n+   --  E is a subprogram. Return True is E is an implicit operation inherited\n+   --  by the derived type declaration for type Typ.\n \n    function Is_LHS (N : Node_Id) return Boolean;\n    --  Returns True iff N is used as Name in an assignment statement\n@@ -766,9 +771,6 @@ package Sem_Util is\n    --  Determines if the tree referenced by N represents an object. Both\n    --  variable and constant objects return True (compare Is_Variable).\n \n-   function Is_SPARK_Object_Reference (N : Node_Id) return Boolean;\n-   --  Determines if the tree referenced by N represents an object in SPARK\n-\n    function Is_OK_Variable_For_Out_Formal (AV : Node_Id) return Boolean;\n    --  Used to test if AV is an acceptable formal for an OUT or IN OUT formal.\n    --  Note that the Is_Variable function is not quite the right test because\n@@ -826,6 +828,9 @@ package Sem_Util is\n    --  represent use of the N_Identifier node for a true identifier, when\n    --  normally such nodes represent a direct name.\n \n+   function Is_SPARK_Object_Reference (N : Node_Id) return Boolean;\n+   --  Determines if the tree referenced by N represents an object in SPARK\n+\n    function Is_Statement (N : Node_Id) return Boolean;\n    pragma Inline (Is_Statement);\n    --  Check if the node N is a statement node. Note that this includes"}]}