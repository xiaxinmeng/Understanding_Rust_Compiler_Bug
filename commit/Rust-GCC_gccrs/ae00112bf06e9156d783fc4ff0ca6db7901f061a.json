{"sha": "ae00112bf06e9156d783fc4ff0ca6db7901f061a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUwMDExMmJmMDZlOTE1NmQ3ODNmYzRmZjBjYTZkYjc5MDFmMDYxYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-09-29T18:15:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-09-29T18:15:28Z"}, "message": "expr.c (expand_expr_real_1): Force op0 to non-constant memory if it cannot be forced to constant memory.\n\n\t* expr.c (expand_expr_real_1) <normal_inner_ref>: Force op0 to\n\tnon-constant memory if it cannot be forced to constant memory.\n\tOverhaul surrounding code and factor out common condition.\n\nFrom-SVN: r140760", "tree": {"sha": "34f87eb5fb8a95b70ad305222bd287b998c72b59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34f87eb5fb8a95b70ad305222bd287b998c72b59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae00112bf06e9156d783fc4ff0ca6db7901f061a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae00112bf06e9156d783fc4ff0ca6db7901f061a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae00112bf06e9156d783fc4ff0ca6db7901f061a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae00112bf06e9156d783fc4ff0ca6db7901f061a/comments", "author": null, "committer": null, "parents": [{"sha": "6b5676ce6e62245d2ecf954fefad122b5c47476d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5676ce6e62245d2ecf954fefad122b5c47476d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b5676ce6e62245d2ecf954fefad122b5c47476d"}], "stats": {"total": 79, "additions": 43, "deletions": 36}, "files": [{"sha": "a8d787bd86b2076a28367ac903cc3e383cf6bf2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae00112bf06e9156d783fc4ff0ca6db7901f061a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae00112bf06e9156d783fc4ff0ca6db7901f061a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae00112bf06e9156d783fc4ff0ca6db7901f061a", "patch": "@@ -1,4 +1,10 @@\n-2008-09-11  Jeff Law <law@redhat.com>\n+2008-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.c (expand_expr_real_1) <normal_inner_ref>: Force op0 to\n+\tnon-constant memory if it cannot be forced to constant memory.\n+\tOverhaul surrounding code and factor out common condition.\n+\n+2008-09-29  Jeff Law <law@redhat.com>\n \n \t* reload1.c (alter_reg): Add missing curly braces.\n "}, {"sha": "32c8d01fe7f40d5bf82179a1f66d29964e03c017", "filename": "gcc/expr.c", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae00112bf06e9156d783fc4ff0ca6db7901f061a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae00112bf06e9156d783fc4ff0ca6db7901f061a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ae00112bf06e9156d783fc4ff0ca6db7901f061a", "patch": "@@ -7744,13 +7744,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case ARRAY_RANGE_REF:\n     normal_inner_ref:\n       {\n-\tenum machine_mode mode1;\n+\tenum machine_mode mode1, mode2;\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n-\tint volatilep = 0;\n+\tint volatilep = 0, must_force_mem;\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n \t\t\t\t\t&mode1, &unsignedp, &volatilep, true);\n-\trtx orig_op0;\n+\trtx orig_op0, memloc;\n \n \t/* If we got back the original object, something is wrong.  Perhaps\n \t   we are evaluating an expression too early.  In any event, don't\n@@ -7760,7 +7760,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t/* If TEM's type is a union of variable size, pass TARGET to the inner\n \t   computation, since it will need a temporary and TARGET is known\n \t   to have to do.  This occurs in unchecked conversion in Ada.  */\n-\n \torig_op0 = op0\n \t  = expand_expr (tem,\n \t\t\t (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n@@ -7774,45 +7773,47 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t  || modifier == EXPAND_STACK_PARM)\n \t\t\t ? modifier : EXPAND_NORMAL);\n \n-\t/* If this is a constant, put it into a register if it is a legitimate\n-\t   constant, OFFSET is 0, and we won't try to extract outside the\n-\t   register (in case we were passed a partially uninitialized object\n-\t   or a view_conversion to a larger size) or a BLKmode piece of it\n-\t   (e.g. if it is unchecked-converted to a record type in Ada).  Force\n-\t   the constant to memory otherwise.  */\n-\tif (CONSTANT_P (op0))\n-\t  {\n-\t    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));\n-\t    if (mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)\n-\t\t&& offset == 0\n-\t\t&& mode1 != BLKmode\n-\t\t&& bitpos + bitsize <= GET_MODE_BITSIZE (mode))\n-\t      op0 = force_reg (mode, op0);\n-\t    else\n-\t      op0 = validize_mem (force_const_mem (mode, op0));\n-\t  }\n-\n-\t/* Otherwise, if this object not in memory and we either have an\n-\t   offset, a BLKmode result, or a reference outside the object, put it\n-\t   there.  Such cases can occur in Ada if we have unchecked conversion\n-\t   of an expression from a scalar type to an array or record type or\n-\t   for an ARRAY_RANGE_REF whose type is BLKmode.  */\n-\telse if (!MEM_P (op0)\n-\t\t && (offset != 0\n-\t\t     || mode1 == BLKmode\n-\t\t     || (bitpos + bitsize\n-\t\t\t > GET_MODE_BITSIZE (GET_MODE (op0)))))\n+\tmode2\n+\t  = CONSTANT_P (op0) ? TYPE_MODE (TREE_TYPE (tem)) : GET_MODE (op0);\n+\n+\t/* If we have either an offset, a BLKmode result, or a reference\n+\t   outside the underlying object, we must force it to memory.\n+\t   Such a case can occur in Ada if we have unchecked conversion\n+\t   of an expression from a scalar type to an aggregate type or\n+\t   for an ARRAY_RANGE_REF whose type is BLKmode, or if we were\n+\t   passed a partially uninitialized object or a view-conversion\n+\t   to a larger size.  */\n+\tmust_force_mem = (offset\n+\t\t\t  || mode1 == BLKmode\n+\t\t\t  || bitpos + bitsize > GET_MODE_BITSIZE (mode2));\n+\n+\t/* If this is a constant, put it in a register if it is a legitimate\n+\t   constant and we don't need a memory reference.  */\n+\tif (CONSTANT_P (op0)\n+\t    && mode2 != BLKmode\n+\t    && LEGITIMATE_CONSTANT_P (op0)\n+\t    && !must_force_mem)\n+\t  op0 = force_reg (mode2, op0);\n+\n+\t/* Otherwise, if this is a constant, try to force it to the constant\n+\t   pool.  Note that back-ends, e.g. MIPS, may refuse to do so if it\n+\t   is a legitimate constant.  */\n+\telse if (CONSTANT_P (op0) && (memloc = force_const_mem (mode2, op0)))\n+\t  op0 = validize_mem (memloc);\n+\n+\t/* Otherwise, if this is a constant or the object is not in memory\n+\t   and need be, put it there.  */\n+\telse if (CONSTANT_P (op0) || (!MEM_P (op0) && must_force_mem))\n \t  {\n \t    tree nt = build_qualified_type (TREE_TYPE (tem),\n \t\t\t\t\t    (TYPE_QUALS (TREE_TYPE (tem))\n \t\t\t\t\t     | TYPE_QUAL_CONST));\n-\t    rtx memloc = assign_temp (nt, 1, 1, 1);\n-\n+\t    memloc = assign_temp (nt, 1, 1, 1);\n \t    emit_move_insn (memloc, op0);\n \t    op0 = memloc;\n \t  }\n \n-\tif (offset != 0)\n+\tif (offset)\n \t  {\n \t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode,\n \t\t\t\t\t  EXPAND_SUM);"}]}