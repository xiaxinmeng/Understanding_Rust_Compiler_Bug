{"sha": "277294d73bf540ec0f5bc320cebab7cfb43bacf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3Mjk0ZDczYmY1NDBlYzBmNWJjMzIwY2ViYWI3Y2ZiNDNiYWNmMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-03-03T03:24:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-03T03:24:44Z"}, "message": "call.c, [...]: Remove support for -fno-ansi-overloading and overloading METHOD_CALL_EXPR.\n\n\t* call.c, class.c, cp-tree.h, cvt.c, decl.c, init.c, lex.c,\n\tmethod.c, pt.c, ptree.c, typeck.c: Remove support for\n\t-fno-ansi-overloading and overloading METHOD_CALL_EXPR.\n\t* class.h: Remove.\n\t* Makefile.in: Adjust.\n\nFrom-SVN: r18384", "tree": {"sha": "feddd74d6019aeb873b50f2e6071211850960347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feddd74d6019aeb873b50f2e6071211850960347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/277294d73bf540ec0f5bc320cebab7cfb43bacf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277294d73bf540ec0f5bc320cebab7cfb43bacf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/277294d73bf540ec0f5bc320cebab7cfb43bacf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277294d73bf540ec0f5bc320cebab7cfb43bacf3/comments", "author": null, "committer": null, "parents": [{"sha": "494321710472a23a9a75d046f9a0fb413e33d2d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494321710472a23a9a75d046f9a0fb413e33d2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494321710472a23a9a75d046f9a0fb413e33d2d2"}], "stats": {"total": 4520, "additions": 453, "deletions": 4067}, "files": [{"sha": "54b45e1b30b4730f75589441c1bab743156dec66", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -1,5 +1,11 @@\n Tue Mar  3 01:38:17 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* call.c, class.c, cp-tree.h, cvt.c, decl.c, init.c, lex.c,\n+\tmethod.c, pt.c, ptree.c, typeck.c: Remove support for \n+\t-fno-ansi-overloading and overloading METHOD_CALL_EXPR.\n+\t* class.h: Remove.\n+\t* Makefile.in: Adjust.\n+\n \t* pt.c (unify): Don't allow reduced cv-quals when strict.\n \n \t* call.c, class.c, pt.c, cp-tree.h: Remove nsubsts parm from"}, {"sha": "a6f0f3cd1f6e8fc4a731b2e5c66a84ce7ad37e3f", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -240,12 +240,12 @@ typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(srcdir)/../expr.h ../insn-codes.h\n class.o : class.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n-call.o : call.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h class.h\n+call.o : call.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n friend.o : friend.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H)\n init.o : init.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(srcdir)/../expr.h ../insn-codes.h\n-method.o : method.c $(CONFIG_H) $(CXX_TREE_H) class.h\n-cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) class.h\n+method.o : method.c $(CONFIG_H) $(CXX_TREE_H)\n+cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H)\n search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h $(srcdir)/../flags.h\n tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H)"}, {"sha": "8fe87aa8c76b1969afc332001fa44d23098752d4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 401, "deletions": 2745, "changes": 3146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3"}, {"sha": "f13180fb973af5c2b70e02ee828e26d1be4a157c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -3229,7 +3229,7 @@ finish_struct_1 (t, warn_anon)\n \n   if (IS_SIGNATURE (t))\n     all_virtual = 0;\n-  else if (flag_all_virtual == 1 && TYPE_OVERLOADS_METHOD_CALL_EXPR (t))\n+  else if (flag_all_virtual == 1)\n     all_virtual = 1;\n   else\n     all_virtual = 0;"}, {"sha": "12e45f78415c0f7610067fb0474afd2cffa2934e", "filename": "gcc/cp/class.h", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494321710472a23a9a75d046f9a0fb413e33d2d2/gcc%2Fcp%2Fclass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494321710472a23a9a75d046f9a0fb413e33d2d2/gcc%2Fcp%2Fclass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.h?ref=494321710472a23a9a75d046f9a0fb413e33d2d2", "patch": "@@ -1,117 +0,0 @@\n-/* Variables and structures for overloading rules.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* The following structure is used when comparing various alternatives\n-   for overloading.  The unsigned quantity `strikes.i' is used\n-   for fast comparison of two possibilities.  This number is an\n-   aggregate of four constituents:\n-\n-     EVIL: if this is non-zero, then the candidate should not be considered\n-     ELLIPSIS: if this is non-zero, then some actual argument has been matched\n-               against an ellipsis\n-     USER: if this is non-zero, then a user-defined type conversion is needed\n-     B_OR_D: if this is non-zero, then use a base pointer instead of the\n-             type of the pointer we started with.\n-     EASY: if this is non-zero, then we have a builtin conversion\n-           (such as int to long, int to float, etc) to do.\n-\n-   If two candidates require user-defined type conversions, and the\n-   type conversions are not identical, then an ambiguity error\n-   is reported.\n-\n-   If two candidates agree on user-defined type conversions,\n-   and one uses pointers of strictly higher type (derived where\n-   another uses base), then that alternative is silently chosen.\n-\n-   Note that this technique really only works for 255 arguments.  Perhaps\n-   this is not enough.  */\n-\n-/* These macros and harshness_code are used by the NEW METHOD.  */\n-#define EVIL_CODE (1<<7)\n-#define CONST_CODE (1<<6)\n-#define ELLIPSIS_CODE (1<<5)\n-#define USER_CODE (1<<4)\n-#define STD_CODE (1<<3)\n-#define PROMO_CODE (1<<2)\n-#define QUAL_CODE (1<<1)\n-#define TRIVIAL_CODE (1<<0)\n-\n-struct harshness_code\n-{\n-  /* What kind of conversion is involved.  */\n-  unsigned short code;\n-\n-  /* The inheritance distance.  */\n-  short distance;\n-\n-  /* For a PROMO_CODE, Any special penalties involved in integral conversions.\n-     This exists because $4.1 of the ARM states that something like\n-     `short unsigned int' should promote to `int', not `unsigned int'.\n-     If, for example, it tries to match two fns, f(int) and f(unsigned),\n-     f(int) should be a better match than f(unsigned) by this rule.  Without\n-     this extra metric, they both only appear as \"integral promotions\", which\n-     will lead to an ambiguity.\n-     For a TRIVIAL_CODE, This is also used by build_overload_call_real and\n-     convert_harshness to keep track of other information we need.  */\n-  unsigned short int_penalty;\n-};\n-\n-struct candidate\n-{\n-  struct harshness_code h;\t/* Used for single-argument conversions.  */\n-\n-  int h_len;\t\t\t/* The length of the harshness vector.  */\n-\n-  tree function;\t\t/* A FUNCTION_DECL */\n-  tree basetypes;\t\t/* The path to function.  */\n-  tree arg;\t\t\t/* first parm to function.  */\n-\n-  /* Indexed by argument number, encodes evil, user, d_to_b, and easy\n-     strikes for that argument.  At end of array, we store the index+1\n-     of where we started using default parameters, or 0 if there are\n-     none.  */\n-  struct harshness_code *harshness;\n-\n-  union\n-    {\n-      tree field;\t\t/* If no evil strikes, the FUNCTION_DECL of\n-\t\t\t\t   the function (if a member function).  */\n-      int bad_arg;\t\t/* the index of the first bad argument:\n-\t\t\t\t   0 if no bad arguments\n-\t\t\t\t   > 0 is first bad argument\n-\t\t\t\t   -1 if extra actual arguments\n-\t\t\t\t   -2 if too few actual arguments.\n-\t\t\t\t   -3 if const/non const method mismatch.\n-\t\t\t\t   -4 if type unification failed.\n-\t\t\t\t   -5 if contravariance violation.  */\n-    } u;\n-};\n-int rank_for_overload PROTO ((struct candidate *, struct candidate *));\n-\n-/* Variables shared between class.c and call.c.  */\n-\n-extern int n_vtables;\n-extern int n_vtable_entries;\n-extern int n_vtable_searches;\n-extern int n_vtable_elems;\n-extern int n_convert_harshness;\n-extern int n_compute_conversion_costs;\n-extern int n_build_method_call;\n-extern int n_inner_fields_searched;"}, {"sha": "95bc071aee0424ea372290f033e8bd6969852713", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -327,11 +327,6 @@ extern int flag_elide_constructors;\n \n extern int flag_ansi;\n \n-/* Nonzero means do argument matching for overloading according to the\n-   ANSI rules, rather than what g++ used to believe to be correct.  */\n-\n-extern int flag_ansi_overloading;\n-\n /* Nonzero means recognize and handle signature language constructs.  */\n \n extern int flag_handle_signatures;\n@@ -620,10 +615,6 @@ struct lang_type\n    convenient, don't reprocess any methods that appear in its redefinition.  */\n #define TYPE_REDEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.redefined)\n \n-/* Nonzero means that this _CLASSTYPE node overloads the method call\n-   operator.  In this case, all method calls go through `operator->()(...).  */\n-#define TYPE_OVERLOADS_METHOD_CALL_EXPR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_method_call_overloaded)\n-\n /* Nonzero means that this type is a signature.  */\n # define IS_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)?TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature:0)\n # define SET_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature=1)\n@@ -2039,19 +2030,14 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n extern char **opname_tab, **assignop_tab;\n \f\n /* in call.c */\n-extern struct candidate *ansi_c_filler;\n extern int get_arglist_len_in_bytes\t\tPROTO((tree));\n \n-extern int rank_for_overload\t\t\tPROTO((struct candidate *, struct candidate *));\n-extern void compute_conversion_costs\t\tPROTO((tree, tree, struct candidate *, int));\n extern tree build_vfield_ref\t\t\tPROTO((tree, tree));\n extern tree resolve_scope_to_name\t\tPROTO((tree, tree));\n extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n extern tree build_addr_func\t\t\tPROTO((tree));\n extern tree build_call\t\t\t\tPROTO((tree, tree, tree));\n extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n-extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *, int));\n-extern tree build_overload_call\t\t\tPROTO((tree, tree, int));\n extern int null_ptr_cst_p\t\t\tPROTO((tree));\n extern tree type_decays_to\t\t\tPROTO((tree));\n extern tree build_user_type_conversion\t\tPROTO((tree, tree, int));\n@@ -2090,7 +2076,6 @@ extern void warn_hidden\t\t\t\tPROTO((tree));\n /* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n extern tree convert_from_reference\t\tPROTO((tree));\n-extern tree convert_to_aggr\t\t\tPROTO((tree, tree, char **, int));\n extern tree convert_pointer_to_real\t\tPROTO((tree, tree));\n extern tree convert_pointer_to\t\t\tPROTO((tree, tree));\n extern tree ocp_convert\t\t\t\tPROTO((tree, tree, int, int));\n@@ -2399,7 +2384,6 @@ extern void yyhook\t\t\t\tPROTO((int));\n /* in method.c */\n extern void init_method\t\t\t\tPROTO((void));\n extern void do_inline_function_hair\t\tPROTO((tree, tree));\n-extern void  report_type_mismatch\t\tPROTO((struct candidate *, tree, char *));\n extern char *build_overload_name\t\tPROTO((tree, int, int));\n extern tree build_static_name\t\t\tPROTO((tree, tree));\n extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));"}, {"sha": "05cd667777055b2445413fb013edb75b5f419e54", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 17, "deletions": 395, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -30,7 +30,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"cp-tree.h\"\n-#include \"class.h\"\n #include \"convert.h\"\n \n #ifdef HAVE_STDLIB_H\n@@ -482,11 +481,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n     {\n       /* Look for a user-defined conversion to lvalue that we can use.  */\n \n-      if (flag_ansi_overloading)\n-\trval_as_conversion\n-\t  = build_type_conversion (CONVERT_EXPR, reftype, expr, 1);\n-      else\n-\trval_as_conversion = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n+      rval_as_conversion\n+\t= build_type_conversion (CONVERT_EXPR, reftype, expr, 1);\n \n       if (rval_as_conversion && rval_as_conversion != error_mark_node\n \t  && real_lvalue_p (rval_as_conversion))\n@@ -556,7 +552,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       if (rval != error_mark_node)\n \trval = build1 (NOP_EXPR, reftype, rval);\n     }\n-  else if (flag_ansi_overloading)\n+  else\n     {\n       rval = convert_for_initialization (NULL_TREE, type, expr, flags,\n \t\t\t\t\t \"converting\", 0, 0);\n@@ -568,89 +564,6 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \tcp_pedwarn (\"initializing non-const `%T' with `%T' will use a temporary\",\n \t\t    reftype, intype);\n     }\n-  else\n-    {\n-      tree rval_as_ctor = NULL_TREE;\n-      \n-      if (rval_as_conversion)\n-\t{\n-\t  if (rval_as_conversion == error_mark_node)\n-\t    {\n-\t      cp_error (\"conversion from `%T' to `%T' is ambiguous\",\n-\t\t\tintype, reftype);\n-\t      return error_mark_node;\n-\t    }\n-\t  rval_as_conversion = build_up_reference (reftype, rval_as_conversion,\n-\t\t\t\t\t\t   flags, 1);\n-\t}\n-      \n-      /* Definitely need to go through a constructor here.  */\n-      if (TYPE_HAS_CONSTRUCTOR (type)\n-\t  && ! CLASSTYPE_ABSTRACT_VIRTUALS (type)\n-\t  && (rval = build_method_call\n-\t      (NULL_TREE, ctor_identifier,\n-\t       build_expr_list (NULL_TREE, expr), TYPE_BINFO (type),\n-\t       LOOKUP_NO_CONVERSION|LOOKUP_SPECULATIVELY\n-\t       | LOOKUP_ONLYCONVERTING)))\n-\t{\n-\t  tree init;\n-\n-\t  if (toplevel_bindings_p ())\n-\t    {\n-\t      tree t = get_temp_name (type, toplevel_bindings_p ());\n-\t      init = build_method_call (t, ctor_identifier,\n-\t\t\t\t\tbuild_expr_list (NULL_TREE, expr),\n-\t\t\t\t\tTYPE_BINFO (type),\n-\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION\n-\t\t\t\t\t| LOOKUP_ONLYCONVERTING);\n-\n-\t      if (init == error_mark_node)\n-\t\treturn error_mark_node;\n-\n-\t      make_decl_rtl (t, NULL_PTR, 1);\n-\t      static_aggregates = perm_tree_cons (expr, t, static_aggregates);\n-\t      rval = build_unary_op (ADDR_EXPR, t, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      init = build_method_call (NULL_TREE, ctor_identifier,\n-\t\t\t\t\tbuild_expr_list (NULL_TREE, expr),\n-\t\t\t\t\tTYPE_BINFO (type),\n-\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION\n-\t\t\t\t\t|LOOKUP_ONLYCONVERTING);\n-\n-\t      if (init == error_mark_node)\n-\t\treturn error_mark_node;\n-\n-\t      rval = build_cplus_new (type, init);\n-\t      rval = build_up_reference (reftype, rval, flags, 1);\n-\t    }\n-\t  rval_as_ctor = rval;\n-\t}\n-\n-      if (rval_as_ctor && rval_as_conversion)\n-\t{\n-\t  cp_error (\"ambiguous conversion from `%T' to `%T'; both user-defined conversion and constructor apply\",\n-\t\t    intype, reftype);\n-\t  return error_mark_node;\n-\t}\n-      else if (rval_as_ctor)\n-\trval = rval_as_ctor;\n-      else if (rval_as_conversion)\n-\trval = rval_as_conversion;\n-      else if (! IS_AGGR_TYPE (type) && ! IS_AGGR_TYPE (intype))\n-\t{\n-\t  rval = cp_convert (type, expr);\n-\t  if (rval == error_mark_node)\n-\t    return error_mark_node;\n-\t  \n-\t  rval = build_up_reference (reftype, rval, flags, 1);\n-\t}\n-\n-      if (rval && ! TYPE_READONLY (TREE_TYPE (reftype)))\n-\tcp_pedwarn (\"initializing non-const `%T' with `%T' will use a temporary\",\n-\t\t    reftype, intype);\n-    }\n \n   if (rval)\n     {\n@@ -685,190 +598,6 @@ convert_from_reference (val)\n   return val;\n }\n \f\n-/* See if there is a constructor of type TYPE which will convert\n-   EXPR.  The reference manual seems to suggest (8.5.6) that we need\n-   not worry about finding constructors for base classes, then converting\n-   to the derived class.\n-\n-   MSGP is a pointer to a message that would be an appropriate error\n-   string.  If MSGP is NULL, then we are not interested in reporting\n-   errors.  */\n-\n-tree\n-convert_to_aggr (type, expr, msgp, protect)\n-     tree type, expr;\n-     char **msgp;\n-     int protect;\n-{\n-  tree basetype = type;\n-  tree name = TYPE_IDENTIFIER (basetype);\n-  tree function, fndecl, fntype, parmtypes, parmlist, result;\n-#if 0\n-  /* See code below that used this.  */\n-  tree method_name;\n-#endif\n-  tree access;\n-  int can_be_private, can_be_protected;\n-\n-  if (! TYPE_HAS_CONSTRUCTOR (basetype))\n-    {\n-      if (msgp)\n-\t*msgp = \"type `%s' does not have a constructor\";\n-      return error_mark_node;\n-    }\n-\n-  access = access_public_node;\n-  can_be_private = 0;\n-  can_be_protected = IDENTIFIER_CLASS_VALUE (name) || name == current_class_name;\n-\n-  parmlist = build_expr_list (NULL_TREE, expr);\n-  parmtypes = scratch_tree_cons (NULL_TREE, TREE_TYPE (expr), void_list_node);\n-\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-    {\n-      parmtypes = expr_tree_cons (NULL_TREE, integer_type_node, parmtypes);\n-      parmlist = scratch_tree_cons (NULL_TREE, integer_one_node, parmlist);\n-    }\n-\n-  /* The type of the first argument will be filled in inside the loop.  */\n-  parmlist = expr_tree_cons (NULL_TREE, integer_zero_node, parmlist);\n-  parmtypes = scratch_tree_cons (NULL_TREE, build_pointer_type (basetype), parmtypes);\n-\n-  /* No exact conversion was found.  See if an approximate\n-     one will do.  */\n-  fndecl = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0);\n-\n-  {\n-    int saw_private = 0;\n-    int saw_protected = 0;\n-    struct candidate *candidates\n-      = (struct candidate *) alloca ((decl_list_length (fndecl)+1) * sizeof (struct candidate));\n-    struct candidate *cp = candidates;\n-\n-    while (fndecl)\n-      {\n-\tfunction = fndecl;\n-\tcp->h_len = 2;\n-\tcp->harshness = (struct harshness_code *)\n-\t  alloca (3 * sizeof (struct harshness_code));\n-\n-\tcompute_conversion_costs (fndecl, parmlist, cp, 2);\n-\tif ((cp->h.code & EVIL_CODE) == 0)\n-\t  {\n-\t    cp->u.field = fndecl;\n-\t    if (protect)\n-\t      {\n-\t\tif (TREE_PRIVATE (fndecl))\n-\t\t  access = access_private_node;\n-\t\telse if (TREE_PROTECTED (fndecl))\n-\t\t  access = access_protected_node;\n-\t\telse\n-\t\t  access = access_public_node;\n-\t      }\n-\t    else\n-\t      access = access_public_node;\n-\n-\t    if (access == access_private_node\n-\t\t? (basetype == current_class_type\n-\t\t   || is_friend (basetype, cp->function)\n-\t\t   || purpose_member (basetype, DECL_ACCESS (fndecl)))\n-\t\t: access == access_protected_node\n-\t\t? (can_be_protected\n-\t\t   || purpose_member (basetype, DECL_ACCESS (fndecl)))\n-\t\t: 1)\n-\t      {\n-\t\tif (cp->h.code <= TRIVIAL_CODE)\n-\t\t  goto found_and_ok;\n-\t\tcp++;\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (access == access_private_node)\n-\t\t  saw_private = 1;\n-\t\telse\n-\t\t  saw_protected = 1;\n-\t      }\n-\t  }\n-\tfndecl = DECL_CHAIN (fndecl);\n-      }\n-    if (cp - candidates)\n-      {\n-\t/* Rank from worst to best.  Then cp will point to best one.\n-\t   Private fields have their bits flipped.  For unsigned\n-\t   numbers, this should make them look very large.\n-\t   If the best alternate has a (signed) negative value,\n-\t   then all we ever saw were private members.  */\n-\tif (cp - candidates > 1)\n-\t  qsort (candidates,\t/* char *base */\n-\t\t cp - candidates, /* int nel */\n-\t\t sizeof (struct candidate), /* int width */\n-\t\t (int (*) PROTO((const void *, const void *))) rank_for_overload); /* int (*compar)() */\n-\n-\t--cp;\n-\tif (cp->h.code & EVIL_CODE)\n-\t  {\n-\t    if (msgp)\n-\t      *msgp = \"ambiguous type conversion possible for `%s'\";\n-\t    return error_mark_node;\n-\t  }\n-\n-\tfunction = cp->function;\n-\tfndecl = cp->u.field;\n-\tgoto found_and_ok;\n-      }\n-    else if (msgp)\n-      {\n-\tif (saw_private)\n-\t  {\n-\t    if (saw_protected)\n-\t      *msgp = \"only private and protected conversions apply\";\n-\t    else\n-\t      *msgp = \"only private conversions apply\";\n-\t  }\n-\telse if (saw_protected)\n-\t  *msgp = \"only protected conversions apply\";\n-\telse\n-\t  *msgp = \"no appropriate conversion to type `%s'\";\n-      }\n-    return error_mark_node;\n-  }\n-  /* NOTREACHED */\n-\n- found:\n-  if (access == access_private_node)\n-    if (! can_be_private)\n-      {\n-\tif (msgp)\n-\t  *msgp = TREE_PRIVATE (fndecl)\n-\t    ? \"conversion to type `%s' is private\"\n-\t    : \"conversion to type `%s' is from private base class\";\n-\treturn error_mark_node;\n-      }\n-  if (access == access_protected_node)\n-    if (! can_be_protected)\n-      {\n-\tif (msgp)\n-\t  *msgp = TREE_PRIVATE (fndecl)\n-\t    ? \"conversion to type `%s' is protected\"\n-\t    : \"conversion to type `%s' is from protected base class\";\n-\treturn error_mark_node;\n-      }\n-  function = fndecl;\n- found_and_ok:\n-\n-  /* It will convert, but we don't do anything about it yet.  */\n-  if (msgp == 0)\n-    return NULL_TREE;\n-\n-  fntype = TREE_TYPE (function);\n-\n-  parmlist = convert_arguments (NULL_TREE, TYPE_ARG_TYPES (fntype),\n-\t\t\t\tparmlist, NULL_TREE, LOOKUP_NORMAL);\n-\n-  result = build_call (function, TREE_TYPE (fntype), parmlist);\n-  return result;\n-}\n-\n /* Call this when we know (for any reason) that expr is not, in fact,\n    zero.  This routine is like convert_pointer_to, but it pays\n    attention to which specific instance of what type we want to\n@@ -1119,71 +848,20 @@ ocp_convert (type, expr, convtype, flags)\n \t There may be some ambiguity between using a constructor\n \t vs. using a type conversion operator when both apply.  */\n \n-      if (flag_ansi_overloading)\n-\t{\n-\t  ctor = e;\n-\t  \n-\t  if ((flags & LOOKUP_ONLYCONVERTING)\n-\t      && ! (IS_AGGR_TYPE (dtype) && DERIVED_FROM_P (type, dtype)))\n-\t    {\n-\t      ctor = build_user_type_conversion (type, ctor, flags);\n-\t      flags |= LOOKUP_NO_CONVERSION;\n-\t    }\n-\t  if (ctor)\n-\t    ctor = build_method_call (NULL_TREE, ctor_identifier,\n-\t\t\t\t      build_expr_list (NULL_TREE, ctor),\n-\t\t\t\t      TYPE_BINFO (type), flags);\n-\t  if (ctor)\n-\t    return build_cplus_new (type, ctor);\n-\t}\n-      else\n-\t{\n-\t  if (IS_AGGR_TYPE (dtype) && ! DERIVED_FROM_P (type, dtype)\n-\t      && TYPE_HAS_CONVERSION (dtype))\n-\t    conversion = build_type_conversion (CONVERT_EXPR, type, e, 1);\n-\n-\t  if (conversion == error_mark_node)\n-\t    {\n-\t      if (flags & LOOKUP_COMPLAIN)\n-\t\terror (\"ambiguous pointer conversion\");\n-\t      return conversion;\n-\t    }\n+      ctor = e;\n \n-\t  if (TYPE_HAS_CONSTRUCTOR (complete_type (type)))\n-\t    ctor = build_method_call (NULL_TREE, ctor_identifier,\n-\t\t\t\t      build_expr_list (NULL_TREE, e),\n-\t\t\t\t      TYPE_BINFO (type),\n-\t\t\t\t      (flags & LOOKUP_NORMAL)\n-\t\t\t\t      | LOOKUP_SPECULATIVELY\n-\t\t\t\t      | (flags & LOOKUP_ONLYCONVERTING)\n-\t\t\t\t      | (flags & LOOKUP_NO_CONVERSION)\n-\t\t\t\t      | (conversion ? LOOKUP_NO_CONVERSION : 0));\n-\n-\t  if (ctor == error_mark_node)\n-\t    {\n-\t      if (flags & LOOKUP_COMPLAIN)\n-\t\tcp_error (\"in conversion to type `%T'\", type);\n-\t      if (flags & LOOKUP_SPECULATIVELY)\n-\t\treturn NULL_TREE;\n-\t      return error_mark_node;\n-\t    }\n-      \n-\t  if (conversion && ctor)\n-\t    {\n-\t      if (flags & LOOKUP_COMPLAIN)\n-\t\terror (\"both constructor and type conversion operator apply\");\n-\t      if (flags & LOOKUP_SPECULATIVELY)\n-\t\treturn NULL_TREE;\n-\t      return error_mark_node;\n-\t    }\n-\t  else if (conversion)\n-\t    return conversion;\n-\t  else if (ctor)\n-\t    {\n-\t      ctor = build_cplus_new (type, ctor);\n-\t      return ctor;\n-\t    }\n+      if ((flags & LOOKUP_ONLYCONVERTING)\n+\t  && ! (IS_AGGR_TYPE (dtype) && DERIVED_FROM_P (type, dtype)))\n+\t{\n+\t  ctor = build_user_type_conversion (type, ctor, flags);\n+\t  flags |= LOOKUP_NO_CONVERSION;\n \t}\n+      if (ctor)\n+\tctor = build_method_call (NULL_TREE, ctor_identifier,\n+\t\t\t\t  build_expr_list (NULL_TREE, ctor),\n+\t\t\t\t  TYPE_BINFO (type), flags);\n+      if (ctor)\n+\treturn build_cplus_new (type, ctor);\n     }\n \n   /* If TYPE or TREE_TYPE (E) is not on the permanent_obstack,\n@@ -1339,64 +1017,8 @@ build_type_conversion (code, xtype, expr, for_sure)\n {\n   /* C++: check to see if we can convert this aggregate type\n      into the required type.  */\n-  tree basetype;\n-  tree conv;\n-  tree winner = NULL_TREE;\n-\n-  if (flag_ansi_overloading)\n-    return build_user_type_conversion\n-      (xtype, expr, for_sure ? LOOKUP_NORMAL : 0);\n-\n-  if (expr == error_mark_node)\n-    return error_mark_node;\n-\n-  basetype = TREE_TYPE (expr);\n-  if (TREE_CODE (basetype) == REFERENCE_TYPE)\n-    basetype = TREE_TYPE (basetype);\n-\n-  basetype = TYPE_MAIN_VARIANT (basetype);\n-  if (! TYPE_LANG_SPECIFIC (basetype) || ! TYPE_HAS_CONVERSION (basetype))\n-    return NULL_TREE;\n-\n-  /* Do we have an exact match?  */\n-  {\n-    tree typename = build_typename_overload (xtype);\n-    if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n-      return build_type_conversion_1 (xtype, basetype, expr, typename,\n-\t\t\t\t      for_sure);\n-  }\n-\n-  /* Nope; try looking for others.  */\n-  for (conv = lookup_conversions (basetype); conv; conv = TREE_CHAIN (conv))\n-    {\n-      tree cand = TREE_VALUE (conv);\n-\n-      if (winner && winner == cand)\n-\tcontinue;\n-\n-      if (can_convert (xtype, TREE_TYPE (TREE_TYPE (cand))))\n-\t{\n-\t  if (winner)\n-\t    {\n-\t      if (for_sure)\n-\t\t{\n-\t\t  cp_error (\"ambiguous conversion from `%T' to `%T'\", basetype,\n-\t\t\t    xtype);\n-\t\t  cp_error (\"  candidate conversions include `%D' and `%D'\",\n-\t\t\t    winner, cand);\n-\t\t}\n-\t      return NULL_TREE;\n-\t    }\n-\t  else\n-\t    winner = cand;\n-\t}\n-    }\n-\n-  if (winner)\n-    return build_type_conversion_1 (xtype, basetype, expr,\n-\t\t\t\t    DECL_NAME (winner), for_sure);\n-\n-  return NULL_TREE;\n+  return build_user_type_conversion\n+    (xtype, expr, for_sure ? LOOKUP_NORMAL : 0);\n }\n \n /* Convert the given EXPR to one of a group of types suitable for use in an"}, {"sha": "334db914a144624e35713cfa022cd5651c465701", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -10760,8 +10760,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    }\n \t}\n       \n-      if (name == ansi_opname[(int) CALL_EXPR]\n-\t  || name == ansi_opname[(int) METHOD_CALL_EXPR])\n+      if (name == ansi_opname[(int) CALL_EXPR])\n \treturn;\t\t\t/* no restrictions on args */\n \n       if (IDENTIFIER_TYPENAME_P (name) && ! DECL_TEMPLATE_INFO (decl))\n@@ -11245,7 +11244,6 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t      TYPE_USES_COMPLEX_INHERITANCE (ref) = 1;\n \t    }\n \n-\t  TYPE_OVERLOADS_METHOD_CALL_EXPR (ref) |= TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype);\n \t  TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n \t  TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n \t  CLASSTYPE_LOCAL_TYPEDECLS (ref) |= CLASSTYPE_LOCAL_TYPEDECLS (basetype);"}, {"sha": "246834219088170710656f71327bb6661026fc1e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -143,11 +143,6 @@ int flag_no_ident;\n \n int flag_ansi;\n \n-/* Nonzero means do argument matching for overloading according to the\n-   ANSI rules, rather than what g++ used to believe to be correct.  */\n-\n-int flag_ansi_overloading = 1;\n-\n /* Nonzero means do emit exported implementations of functions even if\n    they can be inlined.  */\n \n@@ -470,7 +465,6 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"implement-inlines\", &flag_implement_inlines, 1},\n   {\"external-templates\", &flag_external_templates, 1},\n   {\"implicit-templates\", &flag_implicit_templates, 1},\n-  {\"ansi-overloading\", &flag_ansi_overloading, 1},\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"conserve-space\", &flag_conserve_space, 1},\n   {\"vtable-thunks\", &flag_vtable_thunks, 1},\n@@ -565,6 +559,13 @@ lang_decode_option (p)\n \t  flag_guiding_decls = 0;\n \t  found = 1;\n \t}\n+      else if (!strcmp (p, \"ansi-overloading\"))\n+\tfound = 1;\n+      else if (!strcmp (p, \"no-ansi-overloading\"))\n+\t{\n+\t  error (\"-fno-ansi-overloading is no longer supported\");\n+\t  found = 1;\n+\t}\n       else if (!strncmp (p, \"template-depth-\", 15))\n \t{\n \t  char *endp = p + 15;"}, {"sha": "a420092984f4c679d51f2a240314e1ffad8d7bcd", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 221, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -1249,7 +1249,7 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n   tree rval;\n   tree parms;\n \n-  if (flag_ansi_overloading && init && TREE_CODE (init) != TREE_LIST\n+  if (init && TREE_CODE (init) != TREE_LIST\n       && (flags & LOOKUP_ONLYCONVERTING))\n     {\n       /* Base subobjects should only get direct-initialization.  */\n@@ -1287,15 +1287,6 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n       if (parms)\n \tinit = TREE_VALUE (parms);\n     }\n-  else if (! flag_ansi_overloading\n-\t   && TREE_CODE (init) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (init)\n-\t   && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (init)))\n-    {\n-      rval = convert_for_initialization (exp, type, init, 0, 0, 0, 0);\n-      TREE_USED (rval) = 1;\n-      expand_expr_stmt (rval);\n-      return;\n-    }\n   else\n     parms = build_expr_list (NULL_TREE, init);\n \n@@ -1308,52 +1299,9 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n       flags |= LOOKUP_HAS_IN_CHARGE;\n     }\n \n-  if (flag_ansi_overloading)\n-    {\n-      rval = build_method_call (exp, ctor_identifier,\n-\t\t\t\tparms, binfo, flags);\n-      expand_expr_stmt (rval);\n-      return;\n-    }\n-\n-  if (init && TREE_CHAIN (parms) == NULL_TREE\n-      && TYPE_HAS_TRIVIAL_INIT_REF (type)\n-      && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (init)))\n-    {\n-      rval = build (INIT_EXPR, type, exp, init);\n-      TREE_SIDE_EFFECTS (rval) = 1;\n-      expand_expr_stmt (rval);\n-    }\n-  else\n-    {\n-      if (flags & LOOKUP_ONLYCONVERTING)\n-\tflags |= LOOKUP_NO_CONVERSION;\n-      rval = build_method_call (exp, ctor_identifier,\n-\t\t\t\tparms, binfo, flags);\n-\n-      /* Private, protected, or otherwise unavailable.  */\n-      if (rval == error_mark_node)\n-\t{\n-\t  if (flags & LOOKUP_COMPLAIN)\n-\t    cp_error (\"in base initialization for %sclass `%T'\",\n-\t\t      TREE_VIA_VIRTUAL (binfo) ? \"virtual base \" : \"\",\n-\t\t      binfo);\n-\t}\n-      else if (rval == NULL_TREE)\n-\tmy_friendly_abort (361);\n-      else\n-\t{\n-\t  /* p. 222: if the base class assigns to `this', then that\n-\t     value is used in the derived class.  */\n-\t  if ((flag_this_is_variable & 1) && alias_this)\n-\t    {\n-\t      TREE_TYPE (rval) = TREE_TYPE (current_class_ptr);\n-\t      expand_assignment (current_class_ptr, rval, 0, 0);\n-\t    }\n-\t  else\n-\t    expand_expr_stmt (rval);\n-\t}\n-    }\n+  rval = build_method_call (exp, ctor_identifier,\n+\t\t\t    parms, binfo, flags);\n+  expand_expr_stmt (rval);\n }\n \n /* This function is responsible for initializing EXP with INIT\n@@ -1413,171 +1361,6 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n       return;\n     }\n \n-  if (init && ! flag_ansi_overloading)\n-    {\n-      tree init_list = NULL_TREE;\n-\n-      if (TREE_CODE (init) == TREE_LIST)\n-\t{\n-\t  init_list = init;\n-\t  if (TREE_CHAIN (init) == NULL_TREE)\n-\t    init = TREE_VALUE (init);\n-\t}\n-\n-      init_type = TREE_TYPE (init);\n-\n-      if (TREE_CODE (init) != TREE_LIST)\n-\t{\n-\t  if (init_type == error_mark_node)\n-\t    return;\n-\n-\t  /* This happens when we use C++'s functional cast notation.\n-\t     If the types match, then just use the TARGET_EXPR\n-\t     directly.  Otherwise, we need to create the initializer\n-\t     separately from the object being initialized.  */\n-\t  if (TREE_CODE (init) == TARGET_EXPR)\n-\t    {\n-\t      if (TYPE_MAIN_VARIANT (init_type) == TYPE_MAIN_VARIANT (type))\n-\t\t{\n-\t\t  if (TREE_CODE (exp) == VAR_DECL\n-\t\t      || TREE_CODE (exp) == RESULT_DECL)\n-\t\t    /* Unify the initialization targets.  */\n-\t\t    DECL_RTL (TREE_OPERAND (init, 0)) = DECL_RTL (exp);\n-\t\t  else\n-\t\t    DECL_RTL (TREE_OPERAND (init, 0)) = expand_expr (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\n-\t\t  expand_expr_stmt (init);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\n-\t  if (init_type == type && TREE_CODE (init) == CALL_EXPR)\n-\t    {\n-\t      /* A CALL_EXPR is a legitimate form of initialization, so\n-\t\t we should not print this warning message.  */\n-\n-\t      expand_assignment (exp, init, 0, 0);\n-\t      if (exp == DECL_RESULT (current_function_decl))\n-\t\t{\n-\t\t  /* Failing this assertion means that the return value\n-\t\t     from receives multiple initializations.  */\n-\t\t  my_friendly_assert (DECL_INITIAL (exp) == NULL_TREE\n-\t\t\t\t      || DECL_INITIAL (exp) == error_mark_node,\n-\t\t\t\t      212);\n-\t\t  DECL_INITIAL (exp) = init;\n-\t\t}\n-\t      return;\n-\t    }\n-\t  else if (init_type == type\n-\t\t   && TREE_CODE (init) == COND_EXPR)\n-\t    {\n-\t      /* Push value to be initialized into the cond, where possible.\n-\t         Avoid spurious warning messages when initializing the\n-\t\t result of this function.  */\n-\t      TREE_OPERAND (init, 1)\n-\t\t= build_modify_expr (exp, INIT_EXPR, TREE_OPERAND (init, 1));\n-\t      if (exp == DECL_RESULT (current_function_decl))\n-\t\tDECL_INITIAL (exp) = NULL_TREE;\n-\t      TREE_OPERAND (init, 2)\n-\t\t= build_modify_expr (exp, INIT_EXPR, TREE_OPERAND (init, 2));\n-\t      if (exp == DECL_RESULT (current_function_decl))\n-\t\tDECL_INITIAL (exp) = init;\n-\t      TREE_SIDE_EFFECTS (init) = 1;\n-\t      expand_expr (init, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t      free_temp_slots ();\n-\t      return;\n-\t    }\n-\t}\n-\n-      /* We did not know what we were initializing before.  Now we do.  */\n-      if (TREE_CODE (init) == TARGET_EXPR)\n-\t{\n-\t  tree tmp = TREE_OPERAND (TREE_OPERAND (init, 1), 1);\n-\n-\t  if (tmp && TREE_CODE (TREE_VALUE (tmp)) == NOP_EXPR\n-\t      && TREE_OPERAND (TREE_VALUE (tmp), 0) == integer_zero_node)\n-\t    {\n-\t      /* In order for this to work for RESULT_DECLs, if their\n-\t\t type has a constructor, then they must be BLKmode\n-\t\t so that they will be meaningfully addressable.  */\n-\t      tree arg = build_unary_op (ADDR_EXPR, exp, 0);\n-\t      init = TREE_OPERAND (init, 1);\n-\t      init = build (CALL_EXPR, build_pointer_type (TREE_TYPE (init)),\n-\t\t\t    TREE_OPERAND (init, 0), TREE_OPERAND (init, 1), NULL_TREE);\n-\t      TREE_SIDE_EFFECTS (init) = 1;\n-\t      TREE_VALUE (TREE_OPERAND (init, 1))\n-\t\t= convert_pointer_to (TREE_TYPE (TREE_TYPE (TREE_VALUE (tmp))), arg);\n-\n-\t      if (alias_this)\n-\t\t{\n-\t\t  expand_assignment (current_function_decl, init, 0, 0);\n-\t\t  return;\n-\t\t}\n-\t      if (exp == DECL_RESULT (current_function_decl))\n-\t\t{\n-\t\t  if (DECL_INITIAL (DECL_RESULT (current_function_decl)))\n-\t\t    fatal (\"return value from function receives multiple initializations\");\n-\t\t  DECL_INITIAL (exp) = init;\n-\t\t}\n-\t      expand_expr_stmt (init);\n-\t      return;\n-\t    }\n-\t}\n-\n-      /* Handle this case: when calling a constructor: xyzzy foo(bar);\n-\t which really means:  xyzzy foo = bar; Ugh!\n-\n-\t More useful for this case: xyzzy *foo = new xyzzy (bar);  */\n-\n-      if (! TYPE_NEEDS_CONSTRUCTING (type) && ! IS_AGGR_TYPE (type))\n-\t{\n-\t  if (init_list && TREE_CHAIN (init_list))\n-\t    {\n-\t      warning (\"initializer list being treated as compound expression\");\n-\t      init = cp_convert (type, build_compound_expr (init_list));\n-\t      if (init == error_mark_node)\n-\t\treturn;\n-\t    }\n-\n-\t  expand_assignment (exp, init, 0, 0);\n-\n-\t  return;\n-\t}\n-\n-      /* If this is copy-initialization, see whether we can go through a\n-\t type conversion operator.  */\n-      if (TREE_CODE (init) != TREE_LIST && (flags & LOOKUP_ONLYCONVERTING))\n-\t{\n-\t  tree ttype = TREE_CODE (init_type) == REFERENCE_TYPE\n-\t    ? TREE_TYPE (init_type) : init_type;\n-\n-\t  if (ttype != type && IS_AGGR_TYPE (ttype))\n-\t    {\n-\t      tree rval = build_type_conversion (CONVERT_EXPR, type, init, 1);\n-\n-\t      if (rval)\n-\t\t{\n-\t\t  /* See if there is a constructor for``type'' that takes a\n-\t\t     ``ttype''-typed object.  */\n-\t\t  tree parms = build_expr_list (NULL_TREE, init);\n-\t\t  tree as_cons = NULL_TREE;\n-\t\t  if (TYPE_HAS_CONSTRUCTOR (type))\n-\t\t    as_cons = build_method_call (exp, ctor_identifier,\n-\t\t\t\t\t\t parms, binfo,\n-\t\t\t\t\t\t LOOKUP_SPECULATIVELY|LOOKUP_NO_CONVERSION);\n-\t\t  if (as_cons != NULL_TREE && as_cons != error_mark_node)\n-\t\t    /* ANSI C++ June 5 1992 WP 12.3.2.6.1 */\n-\t\t    cp_error (\"ambiguity between conversion to `%T' and constructor\",\n-\t\t\t      type);\n-\t\t  else\n-\t\t    if (rval != error_mark_node)\n-\t\t      expand_aggr_init_1 (binfo, true_exp, exp, rval, alias_this, flags);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n   /* We know that expand_default_init can handle everything we want\n      at this point.  */\n   expand_default_init (binfo, true_exp, exp, init, alias_this, flags);"}, {"sha": "7dfcc1f4c21c62c638be1dd64f5e19864ae97c40", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -615,8 +615,6 @@ init_lex ()\n   IDENTIFIER_OPNAME_P (ansi_opname[(int) MAX_EXPR]) = 1;\n   ansi_opname[(int) COND_EXPR] = get_identifier (\"__cn\");\n   IDENTIFIER_OPNAME_P (ansi_opname[(int) COND_EXPR]) = 1;\n-  ansi_opname[(int) METHOD_CALL_EXPR] = get_identifier (\"__wr\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) METHOD_CALL_EXPR]) = 1;\n \n   init_method ();\n   init_error ();\n@@ -747,7 +745,6 @@ init_lex ()\n \n   opname_tab[(int) COMPONENT_REF] = \"->\";\n   opname_tab[(int) MEMBER_REF] = \"->*\";\n-  opname_tab[(int) METHOD_CALL_EXPR] = \"->()\";\n   opname_tab[(int) INDIRECT_REF] = \"*\";\n   opname_tab[(int) ARRAY_REF] = \"[]\";\n   opname_tab[(int) MODIFY_EXPR] = \"=\";"}, {"sha": "e1ae25072acfb1282d3add22762bd7c701c4b16d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 392, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -34,7 +34,6 @@ Boston, MA 02111-1307, USA.  */\n #include <stdio.h>\n #include \"tree.h\"\n #include \"cp-tree.h\"\n-#include \"class.h\"\n #include \"obstack.h\"\n #include <ctype.h>\n #include \"rtl.h\"\n@@ -175,92 +174,6 @@ do_inline_function_hair (type, friend_list)\n     }\n }\n \f\n-/* Report an argument type mismatch between the best declared function\n-   we could find and the current argument list that we have.  */\n-\n-void\n-report_type_mismatch (cp, parmtypes, name_kind)\n-     struct candidate *cp;\n-     tree parmtypes;\n-     char *name_kind;\n-{\n-  int i = cp->u.bad_arg;\n-  tree ttf, tta;\n-  char *tmp_firstobj;\n-\n-  switch (i)\n-    {\n-    case -4:\n-      my_friendly_assert (TREE_CODE (cp->function) == TEMPLATE_DECL, 240);\n-      cp_error (\"type unification failed for function template `%#D'\",\n-\t\tcp->function);\n-      return;\n-\n-    case -2:\n-      cp_error (\"too few arguments for %s `%#D'\", name_kind, cp->function);\n-      return;\n-    case -1:\n-      cp_error (\"too many arguments for %s `%#D'\", name_kind, cp->function);\n-      return;\n-    case 0:\n-      if (TREE_CODE (TREE_TYPE (cp->function)) != METHOD_TYPE)\n-\tbreak;\n-    case -3:\n-      /* Happens when the implicit object parameter is rejected.  */\n-      my_friendly_assert (! TYPE_READONLY (TREE_TYPE (TREE_VALUE (parmtypes))),\n-\t\t\t  241);\n-      if (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (TREE_VALUE (parmtypes))))\n-\t  && ! TYPE_VOLATILE (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (cp->function))))))\n-\tcp_error (\"call to non-volatile %s `%#D' with volatile object\",\n-\t\t  name_kind, cp->function);\n-      else\n-\tcp_error (\"call to non-const %s `%#D' with const object\",\n-\t\t  name_kind, cp->function);\n-      return;\n-    }\n-\n-  ttf = TYPE_ARG_TYPES (TREE_TYPE (cp->function));\n-  tta = parmtypes;\n-\n-  while (i-- > 0)\n-    {\n-      ttf = TREE_CHAIN (ttf);\n-      tta = TREE_CHAIN (tta);\n-    }\n-\n-  OB_INIT ();\n-  OB_PUTS (\"bad argument \");\n-  sprintf (digit_buffer, \"%d\", cp->u.bad_arg\n-\t   - (TREE_CODE (TREE_TYPE (cp->function)) == METHOD_TYPE)\n-\t   + 1);\n-  OB_PUTCP (digit_buffer);\n-\n-  OB_PUTS (\" for function `\");\n-  OB_PUTCP (decl_as_string (cp->function, 1));\n-  OB_PUTS (\"' (type was \");\n-\n-  /* Reset `i' so that type printing routines do the right thing.  */\n-  if (tta)\n-    {\n-      enum tree_code code = TREE_CODE (TREE_TYPE (TREE_VALUE (tta)));\n-      if (code == ERROR_MARK)\n-\tOB_PUTS (\"(failed type instantiation)\");\n-      else\n-\t{\n-\t  i = (code == FUNCTION_TYPE || code == METHOD_TYPE);\n-\t  OB_PUTCP (type_as_string (TREE_TYPE (TREE_VALUE (tta)), 1));\n-\t}\n-    }\n-  else OB_PUTS (\"void\");\n-  OB_PUTC (')');\n-  OB_FINISH ();\n-\n-  tmp_firstobj = (char *)alloca (obstack_object_size (&scratch_obstack));\n-  bcopy (obstack_base (&scratch_obstack), tmp_firstobj,\n-\t obstack_object_size (&scratch_obstack));\n-  error (tmp_firstobj);\n-}\n-\f\n /* Here is where overload code starts.  */\n \n /* type tables for K and B type compression */\n@@ -1733,311 +1646,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n      int flags;\n      tree xarg1, xarg2, arg3;\n {\n-  tree rval = 0;\n-  tree arg1, arg2;\n-  tree type1, type2, fnname;\n-  tree fields1 = 0, parms = 0;\n-  tree global_fn;\n-  int try_second;\n-  int binary_is_unary;\n-\n-  if (flag_ansi_overloading)\n-    return build_new_op (code, flags, xarg1, xarg2, arg3);\n-\n-  if (xarg1 == error_mark_node)\n-    return error_mark_node;\n-\n-  if (code == COND_EXPR)\n-    {\n-      if (xarg2 == error_mark_node\n-\t  || arg3 == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-  if (code == COMPONENT_REF)\n-    if (TREE_CODE (TREE_TYPE (xarg1)) == POINTER_TYPE)\n-      return rval;\n-\n-  /* First, see if we can work with the first argument */\n-  type1 = TREE_TYPE (xarg1);\n-\n-  /* Some tree codes have length > 1, but we really only want to\n-     overload them if their first argument has a user defined type.  */\n-  switch (code)\n-    {\n-    case PREINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case COMPONENT_REF:\n-      binary_is_unary = 1;\n-      try_second = 0;\n-      break;\n-\n-      /* ARRAY_REFs and CALL_EXPRs must overload successfully.\n-\t If they do not, return error_mark_node instead of NULL_TREE.  */\n-    case ARRAY_REF:\n-      if (xarg2 == error_mark_node)\n-\treturn error_mark_node;\n-    case CALL_EXPR:\n-      rval = error_mark_node;\n-      binary_is_unary = 0;\n-      try_second = 0;\n-      break;\n-\n-    case VEC_NEW_EXPR:\n-    case NEW_EXPR:\n-      {\n-\ttree args = expr_tree_cons (NULL_TREE, xarg2, arg3);\n-\tfnname = ansi_opname[(int) code];\n-\tif (flags & LOOKUP_GLOBAL)\n-\t  return build_overload_call (fnname, args, flags & LOOKUP_COMPLAIN);\n-\n-\trval = build_method_call\n-\t  (build_indirect_ref (build1 (NOP_EXPR, xarg1, error_mark_node),\n-\t\t\t       \"new\"),\n-\t   fnname, args, NULL_TREE, flags);\n-\tif (rval == error_mark_node)\n-\t  /* User might declare fancy operator new, but invoke it\n-\t     like standard one.  */\n-\t  return rval;\n-\n-\tTREE_TYPE (rval) = xarg1;\n-\treturn rval;\n-      }\n-      break;\n-\n-    case VEC_DELETE_EXPR:\n-    case DELETE_EXPR:\n-      {\n-\tfnname = ansi_opname[(int) code];\n-\tif (flags & LOOKUP_GLOBAL)\n-\t  return build_overload_call (fnname,\n-\t\t\t\t      build_expr_list (NULL_TREE, xarg1),\n-\t\t\t\t      flags & LOOKUP_COMPLAIN);\n-\targ1 = TREE_TYPE (xarg1);\n-\n-\t/* This handles the case where we're trying to delete\n-\t   X (*a)[10];\n-\t   a=new X[5][10];\n-\t   delete[] a; */\n-\t   \n-\tif (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)\n-\t  {\n-\t    /* Strip off the pointer and the array.  */\n-\t    arg1 = TREE_TYPE (TREE_TYPE (arg1));\n-\n-\t    while (TREE_CODE (arg1) == ARRAY_TYPE)\n-\t\targ1 = (TREE_TYPE (arg1));\n-\n-\t    arg1 = build_pointer_type (arg1);\n-\t  }\n-\n-\trval = build_method_call\n-\t  (build_indirect_ref (build1 (NOP_EXPR, arg1,\n-\t\t\t\t       error_mark_node),\n-\t\t\t       NULL_PTR),\n-\t   fnname, expr_tree_cons (NULL_TREE, xarg1,\n-\t\t\t       build_expr_list (NULL_TREE, xarg2)),\n-\t   NULL_TREE, flags);\n-#if 0\n-\t/* This can happen when operator delete is protected.  */\n-\tmy_friendly_assert (rval != error_mark_node, 250);\n-\tTREE_TYPE (rval) = void_type_node;\n-#endif\n-\treturn rval;\n-      }\n-      break;\n-\n-    default:\n-      binary_is_unary = 0;\n-      try_second = tree_code_length [(int) code] == 2;\n-      if (try_second && xarg2 == error_mark_node)\n-\treturn error_mark_node;\n-      break;\n-    }\n-\n-  if (try_second && xarg2 == error_mark_node)\n-    return error_mark_node;\n-\n-  /* What ever it was, we do not know how to deal with it.  */\n-  if (type1 == NULL_TREE)\n-    return rval;\n-\n-  if (TREE_CODE (type1) == OFFSET_TYPE)\n-    type1 = TREE_TYPE (type1);\n-\n-  if (TREE_CODE (type1) == REFERENCE_TYPE)\n-    {\n-      arg1 = convert_from_reference (xarg1);\n-      type1 = TREE_TYPE (arg1);\n-    }\n-  else\n-    {\n-      arg1 = xarg1;\n-    }\n-\n-  if (!IS_AGGR_TYPE (type1) || TYPE_PTRMEMFUNC_P (type1))\n-    {\n-      /* Try to fail. First, fail if unary */\n-      if (! try_second)\n-\treturn rval;\n-      /* Second, see if second argument is non-aggregate.  */\n-      type2 = TREE_TYPE (xarg2);\n-      if (TREE_CODE (type2) == OFFSET_TYPE)\n-\ttype2 = TREE_TYPE (type2);\n-      if (TREE_CODE (type2) == REFERENCE_TYPE)\n-\t{\n-\t  arg2 = convert_from_reference (xarg2);\n-\t  type2 = TREE_TYPE (arg2);\n-\t}\n-      else\n-\t{\n-\t  arg2 = xarg2;\n-\t}\n-\n-      if (!IS_AGGR_TYPE (type2))\n-\treturn rval;\n-      try_second = 0;\n-    }\n-\n-  if (try_second)\n-    {\n-      /* First arg may succeed; see whether second should.  */\n-      type2 = TREE_TYPE (xarg2);\n-      if (TREE_CODE (type2) == OFFSET_TYPE)\n-\ttype2 = TREE_TYPE (type2);\n-      if (TREE_CODE (type2) == REFERENCE_TYPE)\n-\t{\n-\t  arg2 = convert_from_reference (xarg2);\n-\t  type2 = TREE_TYPE (arg2);\n-\t}\n-      else\n-\t{\n-\t  arg2 = xarg2;\n-\t}\n-\n-      if (! IS_AGGR_TYPE (type2))\n-\ttry_second = 0;\n-    }\n-\n-  if (type1 == unknown_type_node\n-      || (try_second && TREE_TYPE (xarg2) == unknown_type_node))\n-    {\n-      /* This will not be implemented in the foreseeable future.  */\n-      return rval;\n-    }\n-\n-  if (code == MODIFY_EXPR)\n-    fnname = ansi_assopname[(int) TREE_CODE (arg3)];\n-  else\n-    fnname = ansi_opname[(int) code];\n-\n-  global_fn = lookup_name_nonclass (fnname);\n-\n-  /* This is the last point where we will accept failure.  This\n-     may be too eager if we wish an overloaded operator not to match,\n-     but would rather a normal operator be called on a type-converted\n-     argument.  */\n-\n-  if (IS_AGGR_TYPE (type1))\n-    {\n-      fields1 = lookup_fnfields (TYPE_BINFO (type1), fnname, 0);\n-      /* ARM $13.4.7, prefix/postfix ++/--.  */\n-      if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n-\t{\n-\t  xarg2 = integer_zero_node;\n-\t  binary_is_unary = 0;\n-\n-\t  if (fields1)\n-\t    {\n-\t      tree t, t2;\n-\t      int have_postfix = 0;\n-\n-\t      /* Look for an `operator++ (int)'.  If they didn't have\n-\t\t one, then we fall back to the old way of doing things.  */\n-\t      for (t = TREE_VALUE (fields1); t ; t = DECL_CHAIN (t))\n-\t\t{\n-\t\t  t2 = TYPE_ARG_TYPES (TREE_TYPE (t));\n-\t\t  if (TREE_CHAIN (t2) != NULL_TREE\n-\t\t      && TREE_VALUE (TREE_CHAIN (t2)) == integer_type_node)\n-\t\t    {\n-\t\t      have_postfix = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t      if (! have_postfix)\n-\t\t{\n-\t\t  char *op = POSTINCREMENT_EXPR ? \"++\" : \"--\";\n-\n-\t\t  /* There's probably a LOT of code in the world that\n-\t\t     relies upon this old behavior.  */\n-\t\t  pedwarn (\"no `operator%s (int)' declared for postfix `%s', using prefix operator instead\",\n-\t\t\t   op, op);\n-\t\t  xarg2 = NULL_TREE;\n-\t\t  binary_is_unary = 1;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (fields1 == NULL_TREE && global_fn == NULL_TREE)\n-    return rval;\n-\n-  /* If RVAL winds up being `error_mark_node', we will return\n-     that... There is no way that normal semantics of these\n-     operators will succeed.  */\n-\n-  /* This argument may be an uncommitted OFFSET_REF.  This is\n-     the case for example when dealing with static class members\n-     which are referenced from their class name rather than\n-     from a class instance.  */\n-  if (TREE_CODE (xarg1) == OFFSET_REF\n-      && TREE_CODE (TREE_OPERAND (xarg1, 1)) == VAR_DECL)\n-    xarg1 = TREE_OPERAND (xarg1, 1);\n-  if (try_second && xarg2 && TREE_CODE (xarg2) == OFFSET_REF\n-      && TREE_CODE (TREE_OPERAND (xarg2, 1)) == VAR_DECL)\n-    xarg2 = TREE_OPERAND (xarg2, 1);\n-\n-  if (global_fn)\n-    flags |= LOOKUP_GLOBAL;\n-\n-  if (code == CALL_EXPR)\n-    {\n-      /* This can only be a member function.  */\n-      return build_method_call (xarg1, fnname, xarg2,\n-\t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n-    }\n-  else if (tree_code_length[(int) code] == 1 || binary_is_unary)\n-    {\n-      parms = NULL_TREE;\n-      rval = build_method_call (xarg1, fnname, NULL_TREE, NULL_TREE, flags);\n-    }\n-  else if (code == COND_EXPR)\n-    {\n-      parms = expr_tree_cons (NULL_TREE, xarg2, build_expr_list (NULL_TREE, arg3));\n-      rval = build_method_call (xarg1, fnname, parms, NULL_TREE, flags);\n-    }\n-  else if (code == METHOD_CALL_EXPR)\n-    {\n-      /* must be a member function.  */\n-      parms = expr_tree_cons (NULL_TREE, xarg2, arg3);\n-      return build_method_call (xarg1, fnname, parms, NULL_TREE,\n-\t\t\t\tLOOKUP_NORMAL);\n-    }\n-  else if (fields1)\n-    {\n-      parms = build_expr_list (NULL_TREE, xarg2);\n-      rval = build_method_call (xarg1, fnname, parms, NULL_TREE, flags);\n-    }\n-  else\n-    {\n-      parms = expr_tree_cons (NULL_TREE, xarg1,\n-\t\t\t build_expr_list (NULL_TREE, xarg2));\n-      rval = build_overload_call (fnname, parms, flags);\n-    }\n-\n-  return rval;\n+  return build_new_op (code, flags, xarg1, xarg2, arg3);\n }\n \f\n /* This function takes an identifier, ID, and attempts to figure out what"}, {"sha": "dcc137396dceac16fc82b39ef2c9f4e40406d874", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -3890,38 +3890,6 @@ tsubst (t, args, in_decl)\n \tif (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n \t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n \n-\t/* Look for matching decls for the moment.  */\n-\tif (! member && ! flag_ansi_overloading)\n-\t  {\n-\t    tree decls = lookup_name_nonclass (DECL_NAME (t));\n-\t    tree d = NULL_TREE;\n-    \n-\t    if (decls == NULL_TREE)\n-\t      /* no match */;\n-\t    else if (is_overloaded_fn (decls))\n-\t      for (decls = get_first_fn (decls); decls;\n-\t\t   decls = DECL_CHAIN (decls))\n-\t\t{\n-\t\t  if (TREE_CODE (decls) == FUNCTION_DECL\n-\t\t      && TREE_TYPE (decls) == type)\n-\t\t    {\n-\t\t      d = decls;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t    if (d)\n-\t      {\n-\t\tint dcl_only = ! DECL_INITIAL (d);\n-\t\tif (dcl_only)\n-\t\t  DECL_INITIAL (r) = error_mark_node;\n-\t\tduplicate_decls (r, d);\n-\t\tr = d;\n-\t\tif (dcl_only)\n-\t\t  DECL_INITIAL (r) = 0;\n-\t      }\n-\t  }\n-\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n \t    DECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n@@ -5539,7 +5507,7 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n       if (CLASSTYPE_TEMPLATE_INFO (parm) && uses_template_parms (parm))\n \t{\n \t  tree t = NULL_TREE;\n-\t  if (flag_ansi_overloading && ! strict)\n+\t  if (! strict)\n \t    t = get_template_base (CLASSTYPE_TI_TEMPLATE (parm), arg);\n \t  else if\n \t    (CLASSTYPE_TEMPLATE_INFO (arg)"}, {"sha": "6ad4d39de9331ca36b2ff2dde97f424563426e07", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -118,8 +118,6 @@ print_lang_type (file, node, indent)\n     fputs (\" has=\", file);\n   if (TYPE_HAS_ASSIGN_REF (node))\n     fputs (\" this=(X&)\", file);\n-  if (TYPE_OVERLOADS_METHOD_CALL_EXPR (node))\n-    fputs (\" op->()\", file);\n   if (TYPE_GETS_INIT_AGGR (node))\n     fputs (\" gets X(X, ...)\", file);\n   if (TYPE_OVERLOADS_CALL_EXPR (node))"}, {"sha": "7820f6ea3cf2ba93314902f9ebcb3ff0b1d558b0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 11, "deletions": 130, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277294d73bf540ec0f5bc320cebab7cfb43bacf3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=277294d73bf540ec0f5bc320cebab7cfb43bacf3", "patch": "@@ -2470,24 +2470,10 @@ build_x_function_call (function, params, decl)\n \t}\n       else\n \t{\n-\t  tree val = TREE_VALUE (function);\n-\n-\t  if (flag_ansi_overloading)\n-\t    {\n-\t      /* Put back explicit template arguments, if any.  */\n-\t      if (template_id)\n-\t\tfunction = template_id;\n-\t      return build_new_function_call (function, params);\n-\t    }\n-\n-\t  if (TREE_CODE (val) == TEMPLATE_DECL)\n-\t    return build_overload_call_real\n-\t      (function, params, LOOKUP_COMPLAIN, (struct candidate *)0, 0);\n-\t  else if (DECL_CHAIN (val) != NULL_TREE)\n-\t    return build_overload_call\n-\t      (function, params, LOOKUP_COMPLAIN);\n-\t  else\n-\t    my_friendly_abort (360);\n+\t  /* Put back explicit template arguments, if any.  */\n+\t  if (template_id)\n+\t    function = template_id;\n+\t  return build_new_function_call (function, params);\n \t}\n     }\n \n@@ -3062,17 +3048,7 @@ build_x_binary_op (code, arg1, arg2)\n   if (processing_template_decl)\n     return build_min_nt (code, arg1, arg2);\n \n-  if (flag_ansi_overloading)\n-    return build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n-\n-  rval = build_opfncall (code, LOOKUP_SPECULATIVELY,\n-\t\t\t arg1, arg2, NULL_TREE);\n-  if (rval)\n-    return build_opfncall (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n-  if (code == MEMBER_REF)\n-    return build_m_component_ref (build_indirect_ref (arg1, NULL_PTR),\n-\t\t\t\t  arg2);\n-  return build_binary_op (code, arg1, arg2, 1);\n+  return build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n }\n \n tree\n@@ -4131,21 +4107,10 @@ build_x_unary_op (code, xarg)\n     {\n       tree rval;\n \n-      if (flag_ansi_overloading)\n-\t{\n-\t  rval = build_new_op (code, LOOKUP_NORMAL, xarg,\n-\t\t\t       NULL_TREE, NULL_TREE);\n-\t  if (rval || code != ADDR_EXPR)\n-\t    return rval;\n-\t}\n-      else\n-\t{\n-\t  rval = build_opfncall (code, LOOKUP_SPECULATIVELY, xarg,\n-\t\t\t\t NULL_TREE, NULL_TREE);\n-\t  if (rval)\n-\t    return build_opfncall (code, LOOKUP_NORMAL, xarg,\n-\t\t\t\t   NULL_TREE, NULL_TREE);\n-\t}\n+      rval = build_new_op (code, LOOKUP_NORMAL, xarg,\n+\t\t\t   NULL_TREE, NULL_TREE);\n+      if (rval || code != ADDR_EXPR)\n+\treturn rval;\n     }\n \n   if (code == ADDR_EXPR)\n@@ -4907,16 +4872,7 @@ build_x_conditional_expr (ifexp, op1, op2)\n   if (processing_template_decl)\n     return build_min_nt (COND_EXPR, ifexp, op1, op2);\n \n-  if (flag_ansi_overloading)\n-    return build_new_op (COND_EXPR, LOOKUP_NORMAL, ifexp, op1, op2);\n-\n-  /* See comments in `build_x_binary_op'.  */\n-  if (op1 != 0)\n-    rval = build_opfncall (COND_EXPR, LOOKUP_SPECULATIVELY, ifexp, op1, op2);\n-  if (rval)\n-    return build_opfncall (COND_EXPR, LOOKUP_NORMAL, ifexp, op1, op2);\n-  \n-  return build_conditional_expr (ifexp, op1, op2);\n+  return build_new_op (COND_EXPR, LOOKUP_NORMAL, ifexp, op1, op2);\n }\n \n tree\n@@ -7092,82 +7048,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \n   if (IS_AGGR_TYPE (type)\n       && (TYPE_NEEDS_CONSTRUCTING (type) || TREE_HAS_CONSTRUCTOR (rhs)))\n-    {\n-      if (flag_ansi_overloading)\n-\treturn ocp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n-\n-      if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype))\n-\t{\n-\t  /* This is sufficient to perform initialization.  No need,\n-\t     apparently, to go through X(X&) to do first-cut\n-\t     initialization.  Return through a TARGET_EXPR so that we get\n-\t     cleanups if it is used.  */\n-\t  if (TREE_CODE (rhs) == CALL_EXPR)\n-\t    {\n-\t      rhs = build_cplus_new (type, rhs);\n-\t      return rhs;\n-\t    }\n-\t  /* Handle the case of default parameter initialization and\n-\t     initialization of static variables.  */\n-\t  else if (TREE_CODE (rhs) == TARGET_EXPR)\n-\t    return rhs;\n-\t  else if (TREE_CODE (rhs) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (rhs))\n-\t    {\n-\t      my_friendly_assert (TREE_CODE (TREE_OPERAND (rhs, 0)) == CALL_EXPR, 318);\n-\t      if (exp)\n-\t\t{\n-\t\t  my_friendly_assert (TREE_VALUE (TREE_OPERAND (TREE_OPERAND (rhs, 0), 1)) == NULL_TREE, 316);\n-\t\t  TREE_VALUE (TREE_OPERAND (TREE_OPERAND (rhs, 0), 1))\n-\t\t    = build_unary_op (ADDR_EXPR, exp, 0);\n-\t\t}\n-\t      else\n-\t\trhs = build_cplus_new (type, TREE_OPERAND (rhs, 0));\n-\t      return rhs;\n-\t    }\n-\t  else if (TYPE_HAS_TRIVIAL_INIT_REF (type))\n-\t    return rhs;\n-\t}\n-      if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype)\n-\t  || (IS_AGGR_TYPE (rhstype) && UNIQUELY_DERIVED_FROM_P (type, rhstype)))\n-\t{\n-\t  if (TYPE_HAS_INIT_REF (type))\n-\t    {\n-\t      tree init = build_method_call (exp, ctor_identifier,\n-\t\t\t\t\t     build_expr_list (NULL_TREE, rhs),\n-\t\t\t\t\t     TYPE_BINFO (type), LOOKUP_NORMAL);\n-\n-\t      if (init == error_mark_node)\n-\t\treturn error_mark_node;\n-\n-\t      if (exp == 0)\n-\t\t{\n-\t\t  exp = build_cplus_new (type, init);\n-\t\t  return exp;\n-\t\t}\n-\n-\t      return build (COMPOUND_EXPR, type, init, exp);\n-\t    }\n-\n-\t  /* ??? The following warnings are turned off because\n-\t     this is another place where the default X(X&) constructor\n-\t     is implemented.  */\n-\t  if (TYPE_HAS_ASSIGNMENT (type))\n-\t    cp_warning (\"bitwise copy: `%T' defines operator=\", type);\n-\n-\t  if (TREE_CODE (TREE_TYPE (rhs)) == REFERENCE_TYPE)\n-\t    rhs = convert_from_reference (rhs);\n-\t  if (type != rhstype)\n-\t    {\n-\t      tree nrhs = build1 (NOP_EXPR, type, rhs);\n-\t      TREE_CONSTANT (nrhs) = TREE_CONSTANT (rhs);\n-\t      rhs = nrhs;\n-\t    }\n-\t  return rhs;\n-\t}\n-\n-      return ocp_convert (type, rhs, CONV_OLD_CONVERT,\n-\t\t\t  flags | LOOKUP_NO_CONVERSION);\n-    }\n+    return ocp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n   if (type == TREE_TYPE (rhs))\n     {"}]}