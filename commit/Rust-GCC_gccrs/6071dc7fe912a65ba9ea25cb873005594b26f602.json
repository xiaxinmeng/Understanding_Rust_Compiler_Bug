{"sha": "6071dc7fe912a65ba9ea25cb873005594b26f602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA3MWRjN2ZlOTEyYTY1YmE5ZWEyNWNiODczMDA1NTk0YjI2ZjYwMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-05T04:24:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-05T04:24:40Z"}, "message": "function.c (struct assign_parm_data_all): New.\n\n        * function.c (struct assign_parm_data_all): New.\n        (struct assign_parm_data_one): New.\n        (assign_parms_initialize_all, assign_parms_augmented_arg_list,\n        assign_parm_find_data_types, assign_parms_setup_varargs,\n        assign_parm_find_entry_rtl, assign_parm_is_stack_parm,\n        assign_parm_find_stack_rtl, assign_parm_adjust_entry_rtl,\n        assign_parm_adjust_stack_rtl, assign_parm_setup_block_p,\n        assign_parm_setup_block, assign_parm_setup_reg,\n        assign_parm_setup_stack, assign_parms_unsplit_complex): Split from ...\n        (assign_parms): ... here.\n\nFrom-SVN: r84105", "tree": {"sha": "a9f9f3c1cd2c8f67040e14ac93605cb139263448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9f9f3c1cd2c8f67040e14ac93605cb139263448"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6071dc7fe912a65ba9ea25cb873005594b26f602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6071dc7fe912a65ba9ea25cb873005594b26f602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6071dc7fe912a65ba9ea25cb873005594b26f602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6071dc7fe912a65ba9ea25cb873005594b26f602/comments", "author": null, "committer": null, "parents": [{"sha": "bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831"}], "stats": {"total": 1853, "additions": 1011, "deletions": 842}, "files": [{"sha": "6f297581a530748eb05fa7c45c44d4a6e7f82516", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6071dc7fe912a65ba9ea25cb873005594b26f602/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6071dc7fe912a65ba9ea25cb873005594b26f602/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6071dc7fe912a65ba9ea25cb873005594b26f602", "patch": "@@ -1,3 +1,16 @@\n+2004-07-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* function.c (struct assign_parm_data_all): New.\n+\t(struct assign_parm_data_one): New.\n+\t(assign_parms_initialize_all, assign_parms_augmented_arg_list,\n+\tassign_parm_find_data_types, assign_parms_setup_varargs,\n+\tassign_parm_find_entry_rtl, assign_parm_is_stack_parm, \n+\tassign_parm_find_stack_rtl, assign_parm_adjust_entry_rtl,\n+\tassign_parm_adjust_stack_rtl, assign_parm_setup_block_p,\n+\tassign_parm_setup_block, assign_parm_setup_reg,\n+\tassign_parm_setup_stack, assign_parms_unsplit_complex): Split from ...\n+\t(assign_parms): ... here.\n+\n 2004-07-04  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-pre.c (bb_value_sets): phi_gen, tmp_gen, new_sets"}, {"sha": "5afb046677ced388142ee757f759e426179b431c", "filename": "gcc/function.c", "status": "modified", "additions": 998, "deletions": 842, "changes": 1840, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6071dc7fe912a65ba9ea25cb873005594b26f602/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6071dc7fe912a65ba9ea25cb873005594b26f602/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6071dc7fe912a65ba9ea25cb873005594b26f602", "patch": "@@ -229,7 +229,6 @@ static void prepare_function_start (tree);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n static void instantiate_virtual_regs_lossage (rtx);\n-static tree split_complex_args (tree);\n static void set_insn_locators (rtx, int) ATTRIBUTE_UNUSED;\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n@@ -2032,926 +2031,1136 @@ use_register_for_decl (tree decl)\n   return (optimize || DECL_REGISTER (decl));\n }\n \n-/* Assign RTL expressions to the function's parameters.\n-   This may involve copying them into registers and using\n-   those registers as the RTL for them.  */\n+/* Structures to communicate between the subroutines of assign_parms.\n+   The first holds data persistent across all parameters, the second\n+   is cleared out for each parameter.  */\n \n-void\n-assign_parms (tree fndecl)\n+struct assign_parm_data_all\n {\n-  tree parm;\n   CUMULATIVE_ARGS args_so_far;\n-  /* Total space needed so far for args on the stack,\n-     given as a constant and a tree-expression.  */\n   struct args_size stack_args_size;\n-  HOST_WIDE_INT extra_pretend_bytes = 0;\n-  tree fntype = TREE_TYPE (fndecl);\n-  tree fnargs = DECL_ARGUMENTS (fndecl), orig_fnargs;\n-  /* This is used for the arg pointer when referring to stack args.  */\n-  rtx internal_arg_pointer;\n-  /* This is a dummy PARM_DECL that we used for the function result if\n-     the function returns a structure.  */\n-  tree function_result_decl = 0;\n-  int varargs_setup = 0;\n-  int reg_parm_stack_space ATTRIBUTE_UNUSED = 0;\n-  rtx conversion_insns = 0;\n+  tree function_result_decl;\n+  tree orig_fnargs;\n+  rtx conversion_insns;\n+  HOST_WIDE_INT pretend_args_size;\n+  HOST_WIDE_INT extra_pretend_bytes;\n+  int reg_parm_stack_space;\n+};\n \n-  /* Nonzero if function takes extra anonymous args.\n-     This means the last named arg must be on the stack\n-     right before the anonymous ones.  */\n-  int stdarg = current_function_stdarg;\n+struct assign_parm_data_one\n+{\n+  tree nominal_type;\n+  tree passed_type;\n+  rtx entry_parm;\n+  rtx stack_parm;\n+  enum machine_mode nominal_mode;\n+  enum machine_mode passed_mode;\n+  enum machine_mode promoted_mode;\n+  struct locate_and_pad_arg_data locate;\n+  int partial;\n+  BOOL_BITFIELD named_arg : 1;\n+  BOOL_BITFIELD last_named : 1;\n+  BOOL_BITFIELD passed_pointer : 1;\n+  BOOL_BITFIELD on_stack : 1;\n+  BOOL_BITFIELD loaded_in_reg : 1;\n+};\n \n-  /* If the reg that the virtual arg pointer will be translated into is\n-     not a fixed reg or is the stack pointer, make a copy of the virtual\n-     arg pointer, and address parms via the copy.  The frame pointer is\n-     considered fixed even though it is not marked as such.\n+/* A subroutine of assign_parms.  Initialize ALL.  */\n \n-     The second time through, simply use ap to avoid generating rtx.  */\n+static void\n+assign_parms_initialize_all (struct assign_parm_data_all *all)\n+{\n+  tree fntype;\n \n-  if ((ARG_POINTER_REGNUM == STACK_POINTER_REGNUM\n-       || ! (fixed_regs[ARG_POINTER_REGNUM]\n-\t     || ARG_POINTER_REGNUM == FRAME_POINTER_REGNUM)))\n-    internal_arg_pointer = copy_to_reg (virtual_incoming_args_rtx);\n-  else\n-    internal_arg_pointer = virtual_incoming_args_rtx;\n-  current_function_internal_arg_pointer = internal_arg_pointer;\n+  memset (all, 0, sizeof (*all));\n \n-  stack_args_size.constant = 0;\n-  stack_args_size.var = 0;\n+  fntype = TREE_TYPE (current_function_decl);\n+\n+#ifdef INIT_CUMULATIVE_INCOMING_ARGS\n+  INIT_CUMULATIVE_INCOMING_ARGS (all->args_so_far, fntype, NULL_RTX);\n+#else\n+  INIT_CUMULATIVE_ARGS (all->args_so_far, fntype, NULL_RTX,\n+\t\t\tcurrent_function_decl, -1);\n+#endif\n+\n+#ifdef REG_PARM_STACK_SPACE\n+  all->reg_parm_stack_space = REG_PARM_STACK_SPACE (current_function_decl);\n+#endif\n+}\n+\n+/* If ARGS contains entries with complex types, split the entry into two\n+   entries of the component type.  Return a new list of substitutions are\n+   needed, else the old list.  */\n+\n+static tree\n+split_complex_args (tree args)\n+{\n+  tree p;\n+\n+  /* Before allocating memory, check for the common case of no complex.  */\n+  for (p = args; p; p = TREE_CHAIN (p))\n+    {\n+      tree type = TREE_TYPE (p);\n+      if (TREE_CODE (type) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (type))\n+        goto found;\n+    }\n+  return args;\n+\n+ found:\n+  args = copy_list (args);\n+\n+  for (p = args; p; p = TREE_CHAIN (p))\n+    {\n+      tree type = TREE_TYPE (p);\n+      if (TREE_CODE (type) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (type))\n+\t{\n+\t  tree decl;\n+\t  tree subtype = TREE_TYPE (type);\n+\n+\t  /* Rewrite the PARM_DECL's type with its component.  */\n+\t  TREE_TYPE (p) = subtype;\n+\t  DECL_ARG_TYPE (p) = TREE_TYPE (DECL_ARG_TYPE (p));\n+\t  DECL_MODE (p) = VOIDmode;\n+\t  DECL_SIZE (p) = NULL;\n+\t  DECL_SIZE_UNIT (p) = NULL;\n+\t  layout_decl (p, 0);\n+\n+\t  /* Build a second synthetic decl.  */\n+\t  decl = build_decl (PARM_DECL, NULL_TREE, subtype);\n+\t  DECL_ARG_TYPE (decl) = DECL_ARG_TYPE (p);\n+\t  layout_decl (decl, 0);\n+\n+\t  /* Splice it in; skip the new decl.  */\n+\t  TREE_CHAIN (decl) = TREE_CHAIN (p);\n+\t  TREE_CHAIN (p) = decl;\n+\t  p = decl;\n+\t}\n+    }\n+\n+  return args;\n+}\n+\n+/* A subroutine of assign_parms.  Adjust the parameter list to incorporate\n+   the hidden struct return argument, and (abi willing) complex args.\n+   Return the new parameter list.  */\n+\n+static tree\n+assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n+{\n+  tree fndecl = current_function_decl;\n+  tree fntype = TREE_TYPE (fndecl);\n+  tree fnargs = DECL_ARGUMENTS (fndecl);\n \n   /* If struct value address is treated as the first argument, make it so.  */\n   if (aggregate_value_p (DECL_RESULT (fndecl), fndecl)\n       && ! current_function_returns_pcc_struct\n       && targetm.calls.struct_value_rtx (TREE_TYPE (fndecl), 1) == 0)\n     {\n       tree type = build_pointer_type (TREE_TYPE (fntype));\n+      tree decl;\n \n-      function_result_decl = build_decl (PARM_DECL, NULL_TREE, type);\n+      decl = build_decl (PARM_DECL, NULL_TREE, type);\n+      DECL_ARG_TYPE (decl) = type;\n+      DECL_ARTIFICIAL (decl) = 1;\n \n-      DECL_ARG_TYPE (function_result_decl) = type;\n-      TREE_CHAIN (function_result_decl) = fnargs;\n-      fnargs = function_result_decl;\n+      TREE_CHAIN (decl) = fnargs;\n+      fnargs = decl;\n+      all->function_result_decl = decl;\n     }\n \n-  orig_fnargs = fnargs;\n+  all->orig_fnargs = fnargs;\n \n   /* If the target wants to split complex arguments into scalars, do so.  */\n   if (targetm.calls.split_complex_arg)\n     fnargs = split_complex_args (fnargs);\n \n-#ifdef REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n-#endif\n+  return fnargs;\n+}\n \n-#ifdef INIT_CUMULATIVE_INCOMING_ARGS\n-  INIT_CUMULATIVE_INCOMING_ARGS (args_so_far, fntype, NULL_RTX);\n-#else\n-  INIT_CUMULATIVE_ARGS (args_so_far, fntype, NULL_RTX, fndecl, -1);\n-#endif\n+/* A subroutine of assign_parms.  Examine PARM and pull out type and mode\n+   data for the parameter.  Incorporate ABI specifics such as pass-by-\n+   reference and type promotion.  */\n \n-  /* We haven't yet found an argument that we must push and pretend the\n-     caller did.  */\n-  current_function_pretend_args_size = 0;\n+static void\n+assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n+\t\t\t     struct assign_parm_data_one *data)\n+{\n+  tree nominal_type, passed_type;\n+  enum machine_mode nominal_mode, passed_mode, promoted_mode;\n \n-  for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n+  memset (data, 0, sizeof (*data));\n+\n+  /* Set LAST_NAMED if this is last named arg before last anonymous args.  */\n+  if (current_function_stdarg)\n     {\n-      rtx entry_parm;\n-      rtx stack_parm;\n-      enum machine_mode promoted_mode, passed_mode;\n-      enum machine_mode nominal_mode, promoted_nominal_mode;\n-      int unsignedp;\n-      struct locate_and_pad_arg_data locate;\n-      int passed_pointer = 0;\n-      int did_conversion = 0;\n-      tree passed_type = DECL_ARG_TYPE (parm);\n-      tree nominal_type = TREE_TYPE (parm);\n-      int last_named = 0, named_arg;\n-      int in_regs;\n-      int partial = 0;\n-      int pretend_bytes = 0;\n-      int loaded_in_reg = 0;\n-\n-      /* Set LAST_NAMED if this is last named arg before last\n-\t anonymous args.  */\n-      if (stdarg)\n-\t{\n-\t  tree tem;\n+      tree tem;\n+      for (tem = TREE_CHAIN (parm); tem; tem = TREE_CHAIN (tem))\n+\tif (DECL_NAME (tem))\n+\t  break;\n+      if (tem == 0)\n+\tdata->last_named = true;\n+    }\n \n-\t  for (tem = TREE_CHAIN (parm); tem; tem = TREE_CHAIN (tem))\n-\t    if (DECL_NAME (tem))\n-\t      break;\n+  /* Set NAMED_ARG if this arg should be treated as a named arg.  For\n+     most machines, if this is a varargs/stdarg function, then we treat\n+     the last named arg as if it were anonymous too.  */\n+  if (targetm.calls.strict_argument_naming (&all->args_so_far))\n+    data->named_arg = 1;\n+  else\n+    data->named_arg = !data->last_named;\n+\n+  nominal_type = TREE_TYPE (parm);\n+  passed_type = DECL_ARG_TYPE (parm);\n+\n+  /* Look out for errors propagating this far.  Also, if the parameter's\n+     type is void then its value doesn't matter.  */\n+  if (TREE_TYPE (parm) == error_mark_node\n+      /* This can happen after weird syntax errors\n+\t or if an enum type is defined among the parms.  */\n+      || TREE_CODE (parm) != PARM_DECL\n+      || passed_type == NULL\n+      || VOID_TYPE_P (nominal_type))\n+    {\n+      nominal_type = passed_type = void_type_node;\n+      nominal_mode = passed_mode = promoted_mode = VOIDmode;\n+      goto egress;\n+    }\n \n-\t  if (tem == 0)\n-\t    last_named = 1;\n-\t}\n-      /* Set NAMED_ARG if this arg should be treated as a named arg.  For\n-\t most machines, if this is a varargs/stdarg function, then we treat\n-\t the last named arg as if it were anonymous too.  */\n-      named_arg = (targetm.calls.strict_argument_naming (&args_so_far)\n-\t\t   ? 1 : !last_named);\n-\n-      if (TREE_TYPE (parm) == error_mark_node\n-\t  /* This can happen after weird syntax errors\n-\t     or if an enum type is defined among the parms.  */\n-\t  || TREE_CODE (parm) != PARM_DECL\n-\t  || passed_type == NULL)\n-\t{\n-\t  SET_DECL_RTL (parm, gen_rtx_MEM (BLKmode, const0_rtx));\n-\t  DECL_INCOMING_RTL (parm) = DECL_RTL (parm);\n-\t  TREE_USED (parm) = 1;\n-\t  continue;\n-\t}\n+  /* Find mode of arg as it is passed, and mode of arg as it should be\n+     during execution of this function.  */\n+  passed_mode = TYPE_MODE (passed_type);\n+  nominal_mode = TYPE_MODE (nominal_type);\n+\n+  /* If the parm is to be passed as a transparent union, use the type of\n+     the first field for the tests below.  We have already verified that\n+     the modes are the same.  */\n+  if (DECL_TRANSPARENT_UNION (parm)\n+      || (TREE_CODE (passed_type) == UNION_TYPE\n+\t  && TYPE_TRANSPARENT_UNION (passed_type)))\n+    passed_type = TREE_TYPE (TYPE_FIELDS (passed_type));\n+\n+  /* See if this arg was passed by invisible reference.  It is if it is an\n+     object whose size depends on the contents of the object itself or if\n+     the machine requires these objects be passed that way.  */\n+  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (passed_type))\n+      || TREE_ADDRESSABLE (passed_type)\n+      || FUNCTION_ARG_PASS_BY_REFERENCE (all->args_so_far, passed_mode,\n+\t\t\t\t\t passed_type, data->named_arg))\n+    {\n+      passed_type = nominal_type = build_pointer_type (passed_type);\n+      data->passed_pointer = true;\n+      passed_mode = nominal_mode = Pmode;\n+    }\n+  /* See if the frontend wants to pass this by invisible reference.  */\n+  else if (passed_type != nominal_type\n+\t   && POINTER_TYPE_P (passed_type)\n+\t   && TREE_TYPE (passed_type) == nominal_type)\n+    {\n+      nominal_type = passed_type;\n+      data->passed_pointer = 1;\n+      passed_mode = nominal_mode = Pmode;\n+    }\n \n-      /* Find mode of arg as it is passed, and mode of arg\n-\t as it should be during execution of this function.  */\n-      passed_mode = TYPE_MODE (passed_type);\n-      nominal_mode = TYPE_MODE (nominal_type);\n+  /* Find mode as it is passed by the ABI.  */\n+  promoted_mode = passed_mode;\n+  if (targetm.calls.promote_function_args (TREE_TYPE (current_function_decl)))\n+    {\n+      int unsignedp = TYPE_UNSIGNED (passed_type);\n+      promoted_mode = promote_mode (passed_type, promoted_mode,\n+\t\t\t\t    &unsignedp, 1);\n+    }\n \n-      /* If the parm's mode is VOID, its value doesn't matter,\n-\t and avoid the usual things like emit_move_insn that could crash.  */\n-      if (nominal_mode == VOIDmode)\n-\t{\n-\t  SET_DECL_RTL (parm, const0_rtx);\n-\t  DECL_INCOMING_RTL (parm) = DECL_RTL (parm);\n-\t  continue;\n-\t}\n+ egress:\n+  data->nominal_type = nominal_type;\n+  data->passed_type = passed_type;\n+  data->nominal_mode = nominal_mode;\n+  data->passed_mode = passed_mode;\n+  data->promoted_mode = promoted_mode;\n+}\n \n-      /* If the parm is to be passed as a transparent union, use the\n-\t type of the first field for the tests below.  We have already\n-\t verified that the modes are the same.  */\n-      if (DECL_TRANSPARENT_UNION (parm)\n-\t  || (TREE_CODE (passed_type) == UNION_TYPE\n-\t      && TYPE_TRANSPARENT_UNION (passed_type)))\n-\tpassed_type = TREE_TYPE (TYPE_FIELDS (passed_type));\n-\n-      /* See if this arg was passed by invisible reference.  It is if\n-\t it is an object whose size depends on the contents of the\n-\t object itself or if the machine requires these objects be passed\n-\t that way.  */\n-\n-      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (passed_type))\n-\t  || TREE_ADDRESSABLE (passed_type)\n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n-\t  || FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, passed_mode,\n-\t\t\t\t\t     passed_type, named_arg)\n-#endif\n-\t  )\n-\t{\n-\t  passed_type = nominal_type = build_pointer_type (passed_type);\n-\t  passed_pointer = 1;\n-\t  passed_mode = nominal_mode = Pmode;\n-\t}\n-      /* See if the frontend wants to pass this by invisible reference.  */\n-      else if (passed_type != nominal_type\n-\t       && POINTER_TYPE_P (passed_type)\n-\t       && TREE_TYPE (passed_type) == nominal_type)\n-\t{\n-\t  nominal_type = passed_type;\n-\t  passed_pointer = 1;\n-\t  passed_mode = nominal_mode = Pmode;\n-\t}\n+/* A subroutine of assign_parms.  Invoke setup_incoming_varargs.  */\n+\n+static void\n+assign_parms_setup_varargs (struct assign_parm_data_all *all,\n+\t\t\t    struct assign_parm_data_one *data, bool no_rtl)\n+{\n+  int varargs_pretend_bytes = 0;\n+\n+  targetm.calls.setup_incoming_varargs (&all->args_so_far,\n+\t\t\t\t\tdata->promoted_mode,\n+\t\t\t\t\tdata->passed_type,\n+\t\t\t\t\t&varargs_pretend_bytes, no_rtl);\n+\n+  /* If the back-end has requested extra stack space, record how much is\n+     needed.  Do not change pretend_args_size otherwise since it may be\n+     nonzero from an earlier partial argument.  */\n+  if (varargs_pretend_bytes > 0)\n+    all->pretend_args_size = varargs_pretend_bytes;\n+}\n \n-      promoted_mode = passed_mode;\n+/* A subroutine of assign_parms.  Set DATA->ENTRY_PARM corresponding to\n+   the incoming location of the current parameter.  */\n \n-      if (targetm.calls.promote_function_args (TREE_TYPE (fndecl)))\n-\t{\n-\t  /* Compute the mode in which the arg is actually extended to.  */\n-\t  unsignedp = TYPE_UNSIGNED (passed_type);\n-\t  promoted_mode = promote_mode (passed_type, promoted_mode,\n-\t\t\t\t\t&unsignedp, 1);\n-\t}\n+static void\n+assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n+\t\t\t    struct assign_parm_data_one *data)\n+{\n+  HOST_WIDE_INT pretend_bytes = 0;\n+  rtx entry_parm;\n+  bool in_regs;\n+\n+  if (data->promoted_mode == VOIDmode)\n+    {\n+      data->entry_parm = data->stack_parm = const0_rtx;\n+      return;\n+    }\n \n-      /* Let machine desc say which reg (if any) the parm arrives in.\n-\t 0 means it arrives on the stack.  */\n #ifdef FUNCTION_INCOMING_ARG\n-      entry_parm = FUNCTION_INCOMING_ARG (args_so_far, promoted_mode,\n-\t\t\t\t\t  passed_type, named_arg);\n+  entry_parm = FUNCTION_INCOMING_ARG (all->args_so_far, data->promoted_mode,\n+\t\t\t\t      data->passed_type, data->named_arg);\n #else\n-      entry_parm = FUNCTION_ARG (args_so_far, promoted_mode,\n-\t\t\t\t passed_type, named_arg);\n+  entry_parm = FUNCTION_ARG (all->args_so_far, data->promoted_mode,\n+\t\t\t     data->passed_type, data->named_arg);\n #endif\n \n-      if (entry_parm == 0)\n-\tpromoted_mode = passed_mode;\n-\n-      /* If this is the last named parameter, do any required setup for\n-\t varargs or stdargs.  We need to know about the case of this being an\n-\t addressable type, in which case we skip the registers it\n-\t would have arrived in.\n-\n-\t For stdargs, LAST_NAMED will be set for two parameters, the one that\n-\t is actually the last named, and the dummy parameter.  We only\n-\t want to do this action once.\n-\n-\t Also, indicate when RTL generation is to be suppressed.  */\n-      if (last_named && !varargs_setup)\n-\t{\n-\t  int varargs_pretend_bytes = 0;\n-\t  targetm.calls.setup_incoming_varargs (&args_so_far, promoted_mode,\n-\t\t\t\t\t\tpassed_type,\n-\t\t\t\t\t\t&varargs_pretend_bytes, 0);\n-\t  varargs_setup = 1;\n-\n-\t  /* If the back-end has requested extra stack space, record how\n-\t     much is needed.  Do not change pretend_args_size otherwise\n-\t     since it may be nonzero from an earlier partial argument.  */\n-\t  if (varargs_pretend_bytes > 0)\n-\t    current_function_pretend_args_size = varargs_pretend_bytes;\n-\t}\n+  if (entry_parm == 0)\n+    data->promoted_mode = data->passed_mode;\n \n-      /* Determine parm's home in the stack,\n-\t in case it arrives in the stack or we should pretend it did.\n+  /* Determine parm's home in the stack, in case it arrives in the stack\n+     or we should pretend it did.  Compute the stack position and rtx where\n+     the argument arrives and its size.\n \n-\t Compute the stack position and rtx where the argument arrives\n-\t and its size.\n-\n-\t There is one complexity here:  If this was a parameter that would\n-\t have been passed in registers, but wasn't only because it is\n-\t __builtin_va_alist, we want locate_and_pad_parm to treat it as if\n-\t it came in a register so that REG_PARM_STACK_SPACE isn't skipped.\n-\t In this case, we call FUNCTION_ARG with NAMED set to 1 instead of\n-\t 0 as it was the previous time.  */\n-      in_regs = entry_parm != 0;\n+     There is one complexity here:  If this was a parameter that would\n+     have been passed in registers, but wasn't only because it is\n+     __builtin_va_alist, we want locate_and_pad_parm to treat it as if\n+     it came in a register so that REG_PARM_STACK_SPACE isn't skipped.\n+     In this case, we call FUNCTION_ARG with NAMED set to 1 instead of 0\n+     as it was the previous time.  */\n+  in_regs = entry_parm != 0;\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n-      in_regs = 1;\n+  in_regs = true;\n #endif\n-      if (!in_regs && !named_arg)\n+  if (!in_regs && !data->named_arg)\n+    {\n+      if (targetm.calls.pretend_outgoing_varargs_named (&all->args_so_far))\n \t{\n-\t  int pretend_named =\n-\t    targetm.calls.pretend_outgoing_varargs_named (&args_so_far);\n-\t  if (pretend_named)\n-\t    {\n+\t  rtx tem;\n #ifdef FUNCTION_INCOMING_ARG\n-\t      in_regs = FUNCTION_INCOMING_ARG (args_so_far, promoted_mode,\n-\t\t\t\t\t       passed_type,\n-\t\t\t\t\t       pretend_named) != 0;\n+\t  tem = FUNCTION_INCOMING_ARG (all->args_so_far, data->promoted_mode,\n+\t\t\t\t       data->passed_type, true);\n #else\n-\t      in_regs = FUNCTION_ARG (args_so_far, promoted_mode,\n-\t\t\t\t      passed_type,\n-\t\t\t\t      pretend_named) != 0;\n+\t  tem = FUNCTION_ARG (all->args_so_far, data->promoted_mode,\n+\t\t\t      data->passed_type, true);\n #endif\n-\t    }\n+\t  in_regs = tem != NULL;\n \t}\n+    }\n \n-      /* If this parameter was passed both in registers and in the stack,\n-\t use the copy on the stack.  */\n-      if (MUST_PASS_IN_STACK (promoted_mode, passed_type))\n-\tentry_parm = 0;\n+  /* If this parameter was passed both in registers and in the stack, use\n+     the copy on the stack.  */\n+  if (MUST_PASS_IN_STACK (data->promoted_mode, data->passed_type))\n+    entry_parm = 0;\n \n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n-      if (entry_parm)\n+  if (entry_parm)\n+    {\n+      int partial;\n+\n+      partial = FUNCTION_ARG_PARTIAL_NREGS (all->args_so_far,\n+\t\t\t\t\t    data->promoted_mode,\n+\t\t\t\t\t    data->passed_type,\n+\t\t\t\t\t    data->named_arg);\n+      data->partial = partial;\n+\n+      /* The caller might already have allocated stack space for the\n+\t register parameters.  */\n+      if (partial != 0 && all->reg_parm_stack_space == 0)\n \t{\n-\t  partial = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, promoted_mode,\n-\t\t\t\t\t\tpassed_type, named_arg);\n-\t  if (partial\n-\t      /* The caller might already have allocated stack space\n-\t\t for the register parameters.  */\n-\t      && reg_parm_stack_space == 0)\n-\t    {\n-\t      /* Part of this argument is passed in registers and part\n-\t\t is passed on the stack.  Ask the prologue code to extend\n-\t\t the stack part so that we can recreate the full value.\n-\n-\t\t PRETEND_BYTES is the size of the registers we need to store.\n-\t\t CURRENT_FUNCTION_PRETEND_ARGS_SIZE is the amount of extra\n-\t\t stack space that the prologue should allocate.\n-\n-\t\t Internally, gcc assumes that the argument pointer is\n-\t\t aligned to STACK_BOUNDARY bits.  This is used both for\n-\t\t alignment optimizations (see init_emit) and to locate\n-\t\t arguments that are aligned to more than PARM_BOUNDARY\n-\t\t bits.  We must preserve this invariant by rounding\n-\t\t CURRENT_FUNCTION_PRETEND_ARGS_SIZE up to a stack\n-\t\t boundary.  */\n-\n-\t      /* We assume at most one partial arg, and it must be the first\n-\t         argument on the stack.  */\n-\t      if (extra_pretend_bytes || current_function_pretend_args_size)\n-\t\tabort ();\n+\t  /* Part of this argument is passed in registers and part\n+\t     is passed on the stack.  Ask the prologue code to extend\n+\t     the stack part so that we can recreate the full value.\n+\n+\t     PRETEND_BYTES is the size of the registers we need to store.\n+\t     CURRENT_FUNCTION_PRETEND_ARGS_SIZE is the amount of extra\n+\t     stack space that the prologue should allocate.\n+\n+\t     Internally, gcc assumes that the argument pointer is aligned\n+\t     to STACK_BOUNDARY bits.  This is used both for alignment\n+\t     optimizations (see init_emit) and to locate arguments that are\n+\t     aligned to more than PARM_BOUNDARY bits.  We must preserve this\n+\t     invariant by rounding CURRENT_FUNCTION_PRETEND_ARGS_SIZE up to\n+\t     a stack boundary.  */\n+\n+\t  /* We assume at most one partial arg, and it must be the first\n+\t     argument on the stack.  */\n+\t  if (all->extra_pretend_bytes || all->pretend_args_size)\n+\t    abort ();\n \n-\t      pretend_bytes = partial * UNITS_PER_WORD;\n-\t      current_function_pretend_args_size\n-\t\t= CEIL_ROUND (pretend_bytes, STACK_BYTES);\n+\t  pretend_bytes = partial * UNITS_PER_WORD;\n+\t  all->pretend_args_size = CEIL_ROUND (pretend_bytes, STACK_BYTES);\n \n-\t      /* We want to align relative to the actual stack pointer, so\n-\t         don't include this in the stack size until later.  */\n-\t      extra_pretend_bytes = current_function_pretend_args_size;\n-\t    }\n+\t  /* We want to align relative to the actual stack pointer, so\n+\t     don't include this in the stack size until later.  */\n+\t  all->extra_pretend_bytes = all->pretend_args_size;\n \t}\n+    }\n #endif\n \n-      memset (&locate, 0, sizeof (locate));\n-      locate_and_pad_parm (promoted_mode, passed_type, in_regs,\n-\t\t\t   entry_parm ? partial : 0, fndecl,\n-\t\t\t   &stack_args_size, &locate);\n-      /* Adjust offsets to include the pretend args.  */\n-      locate.slot_offset.constant += extra_pretend_bytes - pretend_bytes;\n-      locate.offset.constant += extra_pretend_bytes - pretend_bytes;\n+  locate_and_pad_parm (data->promoted_mode, data->passed_type, in_regs,\n+\t\t       entry_parm ? data->partial : 0, current_function_decl,\n+\t\t       &all->stack_args_size, &data->locate);\n \n-      {\n-\trtx offset_rtx;\n-\tunsigned int align, boundary;\n-\n-\t/* If we're passing this arg using a reg, make its stack home\n-\t   the aligned stack slot.  */\n-\tif (entry_parm)\n-\t  offset_rtx = ARGS_SIZE_RTX (locate.slot_offset);\n-\telse\n-\t  offset_rtx = ARGS_SIZE_RTX (locate.offset);\n-\n-\tif (offset_rtx == const0_rtx)\n-\t  stack_parm = gen_rtx_MEM (promoted_mode, internal_arg_pointer);\n-\telse\n-\t  stack_parm = gen_rtx_MEM (promoted_mode,\n-\t\t\t\t    gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t  internal_arg_pointer,\n-\t\t\t\t\t\t  offset_rtx));\n-\n-\tset_mem_attributes (stack_parm, parm, 1);\n-\n-\tboundary = FUNCTION_ARG_BOUNDARY (promoted_mode, passed_type);\n-\talign = 0;\n-\n-\t/* If we're padding upward, we know that the alignment of the slot\n-\t   is FUNCTION_ARG_BOUNDARY.  If we're using slot_offset, we're\n-\t   intentionally forcing upward padding.  Otherwise we have to come\n-\t   up with a guess at the alignment based on OFFSET_RTX.  */\n-\tif (locate.where_pad == upward || entry_parm)\n-\t  align = boundary;\n-\telse if (GET_CODE (offset_rtx) == CONST_INT)\n-\t  {\n-\t    align = INTVAL (offset_rtx) * BITS_PER_UNIT | boundary;\n-\t    align = align & -align;\n-\t  }\n-\tif (align > 0)\n-\t  set_mem_align (stack_parm, align);\n+  /* Adjust offsets to include the pretend args.  */\n+  pretend_bytes = all->extra_pretend_bytes - pretend_bytes;\n+  data->locate.slot_offset.constant += pretend_bytes;\n+  data->locate.offset.constant += pretend_bytes;\n \n-\tif (entry_parm)\n-\t  set_reg_attrs_for_parm (entry_parm, stack_parm);\n-      }\n+  data->entry_parm = entry_parm;\n+}\n \n-      /* If this parm was passed part in regs and part in memory,\n-\t pretend it arrived entirely in memory\n-\t by pushing the register-part onto the stack.\n+/* A subroutine of assign_parms.  If there is actually space on the stack\n+   for this parm, count it in stack_args_size and return true.  */\n \n-\t In the special case of a DImode or DFmode that is split,\n-\t we could put it together in a pseudoreg directly,\n-\t but for now that's not worth bothering with.  */\n+static bool\n+assign_parm_is_stack_parm (struct assign_parm_data_all *all,\n+\t\t\t   struct assign_parm_data_one *data)\n+{\n+  /* Trivially true if we've no incomming register.  */\n+  if (data->entry_parm == NULL)\n+    ;\n+  /* Also true if we're partially in registers and partially not,\n+     since we've arranged to drop the entire argument on the stack.  */\n+  else if (data->partial != 0)\n+    ;\n+  /* Also true if the target says that it's passed in both registers\n+     and on the stack.  */\n+  else if (GET_CODE (data->entry_parm) == PARALLEL\n+\t   && XEXP (XVECEXP (data->entry_parm, 0, 0), 0) == NULL_RTX)\n+    ;\n+  /* Also true if the target says that there's stack allocated for\n+     all register parameters.  */\n+  else if (all->reg_parm_stack_space > 0)\n+    ;\n+  /* Otherwise, no, this parameter has no ABI defined stack slot.  */\n+  else\n+    return false;\n \n-      if (partial)\n-\t{\n-\t  /* Handle calls that pass values in multiple non-contiguous\n-\t     locations.  The Irix 6 ABI has examples of this.  */\n-\t  if (GET_CODE (entry_parm) == PARALLEL)\n-\t    emit_group_store (validize_mem (stack_parm), entry_parm,\n-\t\t\t      TREE_TYPE (parm),\n-\t\t\t      int_size_in_bytes (TREE_TYPE (parm)));\n+  all->stack_args_size.constant += data->locate.size.constant;\n+  if (data->locate.size.var)\n+    ADD_PARM_SIZE (all->stack_args_size, data->locate.size.var);\n \n-\t  else\n-\t    move_block_from_reg (REGNO (entry_parm), validize_mem (stack_parm),\n-\t\t\t\t partial);\n+  return true;\n+}\n \n-\t  entry_parm = stack_parm;\n-\t}\n+/* A subroutine of assign_parms.  Given that this parameter is allocated\n+   stack space by the ABI, find it.  */\n \n-      /* If we didn't decide this parm came in a register,\n-\t by default it came on the stack.  */\n-      if (entry_parm == 0)\n-\tentry_parm = stack_parm;\n+static void\n+assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n+{\n+  rtx offset_rtx, stack_parm;\n+  unsigned int align, boundary;\n \n-      /* Record permanently how this parm was passed.  */\n-      set_decl_incoming_rtl (parm, entry_parm);\n-\n-      /* If there is actually space on the stack for this parm,\n-\t count it in stack_args_size; otherwise set stack_parm to 0\n-\t to indicate there is no preallocated stack slot for the parm.  */\n-\n-      if (entry_parm == stack_parm\n-\t  || (GET_CODE (entry_parm) == PARALLEL\n-\t      && XEXP (XVECEXP (entry_parm, 0, 0), 0) == NULL_RTX)\n-#if defined (REG_PARM_STACK_SPACE)\n-\t  /* On some machines, even if a parm value arrives in a register\n-\t     there is still an (uninitialized) stack slot allocated\n-\t     for it.  */\n-\t  || REG_PARM_STACK_SPACE (fndecl) > 0\n-#endif\n-\t  )\n-\t{\n-\t  stack_args_size.constant += locate.size.constant;\n-\t  if (locate.size.var)\n-\t    ADD_PARM_SIZE (stack_args_size, locate.size.var);\n-\t}\n+  /* If we're passing this arg using a reg, make its stack home the\n+     aligned stack slot.  */\n+  if (data->entry_parm)\n+    offset_rtx = ARGS_SIZE_RTX (data->locate.slot_offset);\n+  else\n+    offset_rtx = ARGS_SIZE_RTX (data->locate.offset);\n+\n+  stack_parm = current_function_internal_arg_pointer;\n+  if (offset_rtx != const0_rtx)\n+    stack_parm = gen_rtx_PLUS (Pmode, stack_parm, offset_rtx);\n+  stack_parm = gen_rtx_MEM (data->promoted_mode, stack_parm);\n+\n+  set_mem_attributes (stack_parm, parm, 1);\n+\n+  boundary = FUNCTION_ARG_BOUNDARY (data->promoted_mode, data->passed_type);\n+  align = 0;\n+\n+  /* If we're padding upward, we know that the alignment of the slot\n+     is FUNCTION_ARG_BOUNDARY.  If we're using slot_offset, we're\n+     intentionally forcing upward padding.  Otherwise we have to come\n+     up with a guess at the alignment based on OFFSET_RTX.  */\n+  if (data->locate.where_pad == upward || data->entry_parm)\n+    align = boundary;\n+  else if (GET_CODE (offset_rtx) == CONST_INT)\n+    {\n+      align = INTVAL (offset_rtx) * BITS_PER_UNIT | boundary;\n+      align = align & -align;\n+    }\n+  if (align > 0)\n+    set_mem_align (stack_parm, align);\n+\n+  if (data->entry_parm)\n+    set_reg_attrs_for_parm (data->entry_parm, stack_parm);\n+\n+  data->stack_parm = stack_parm;\n+}\n+\n+/* A subroutine of assign_parms.  Adjust DATA->ENTRY_RTL such that it's\n+   always valid and contiguous.  */\n+\n+static void\n+assign_parm_adjust_entry_rtl (struct assign_parm_data_one *data)\n+{\n+  rtx entry_parm = data->entry_parm;\n+  rtx stack_parm = data->stack_parm;\n+\n+  /* If this parm was passed part in regs and part in memory, pretend it\n+     arrived entirely in memory by pushing the register-part onto the stack.\n+     In the special case of a DImode or DFmode that is split, we could put\n+     it together in a pseudoreg directly, but for now that's not worth\n+     bothering with.  */\n+  if (data->partial != 0)\n+    {\n+      /* Handle calls that pass values in multiple non-contiguous\n+\t locations.  The Irix 6 ABI has examples of this.  */\n+      if (GET_CODE (entry_parm) == PARALLEL)\n+\temit_group_store (validize_mem (stack_parm), entry_parm,\n+\t\t\t  data->passed_type, \n+\t\t\t  int_size_in_bytes (data->passed_type));\n       else\n-\t/* No stack slot was pushed for this parm.  */\n-\tstack_parm = 0;\n+\tmove_block_from_reg (REGNO (entry_parm), validize_mem (stack_parm),\n+\t\t\t     data->partial);\n \n-      /* Update info on where next arg arrives in registers.  */\n+      entry_parm = stack_parm;\n+    }\n \n-      FUNCTION_ARG_ADVANCE (args_so_far, promoted_mode,\n-\t\t\t    passed_type, named_arg);\n-\n-      /* If we can't trust the parm stack slot to be aligned enough\n-\t for its ultimate type, don't use that slot after entry.\n-\t We'll make another stack slot, if we need one.  */\n-      if (STRICT_ALIGNMENT && stack_parm\n-\t  && GET_MODE_ALIGNMENT (nominal_mode) > MEM_ALIGN (stack_parm))\n-\tstack_parm = 0;\n-\n-      /* If parm was passed in memory, and we need to convert it on entry,\n-\t don't store it back in that same slot.  */\n-      if (entry_parm == stack_parm\n-\t  && nominal_mode != BLKmode && nominal_mode != passed_mode)\n-\tstack_parm = 0;\n-\n-      /* When an argument is passed in multiple locations, we can't\n-\t make use of this information, but we can save some copying if\n-\t the whole argument is passed in a single register.  */\n-      if (GET_CODE (entry_parm) == PARALLEL\n-\t  && nominal_mode != BLKmode && passed_mode != BLKmode)\n-\t{\n-\t  int i, len = XVECLEN (entry_parm, 0);\n-\n-\t  for (i = 0; i < len; i++)\n-\t    if (XEXP (XVECEXP (entry_parm, 0, i), 0) != NULL_RTX\n-\t\t&& REG_P (XEXP (XVECEXP (entry_parm, 0, i), 0))\n-\t\t&& (GET_MODE (XEXP (XVECEXP (entry_parm, 0, i), 0))\n-\t\t    == passed_mode)\n-\t\t&& INTVAL (XEXP (XVECEXP (entry_parm, 0, i), 1)) == 0)\n-\t      {\n-\t\tentry_parm = XEXP (XVECEXP (entry_parm, 0, i), 0);\n-\t\tset_decl_incoming_rtl (parm, entry_parm);\n-\t\tbreak;\n-\t      }\n-\t}\n+  /* If we didn't decide this parm came in a register, by default it came\n+     on the stack.  */\n+  else if (entry_parm == NULL)\n+    entry_parm = stack_parm;\n+\n+  /* When an argument is passed in multiple locations, we can't make use\n+     of this information, but we can save some copying if the whole argument\n+     is passed in a single register.  */\n+  else if (GET_CODE (entry_parm) == PARALLEL\n+\t   && data->nominal_mode != BLKmode\n+\t   && data->passed_mode != BLKmode)\n+    {\n+      size_t i, len = XVECLEN (entry_parm, 0);\n+\n+      for (i = 0; i < len; i++)\n+\tif (XEXP (XVECEXP (entry_parm, 0, i), 0) != NULL_RTX\n+\t    && REG_P (XEXP (XVECEXP (entry_parm, 0, i), 0))\n+\t    && (GET_MODE (XEXP (XVECEXP (entry_parm, 0, i), 0))\n+\t\t== data->passed_mode)\n+\t    && INTVAL (XEXP (XVECEXP (entry_parm, 0, i), 1)) == 0)\n+\t  {\n+\t    entry_parm = XEXP (XVECEXP (entry_parm, 0, i), 0);\n+\t    break;\n+\t  }\n+    }\n \n-      /* ENTRY_PARM is an RTX for the parameter as it arrives,\n-\t in the mode in which it arrives.\n-\t STACK_PARM is an RTX for a stack slot where the parameter can live\n-\t during the function (in case we want to put it there).\n-\t STACK_PARM is 0 if no stack slot was pushed for it.\n+  data->entry_parm = entry_parm;\n+}\n \n-\t Now output code if necessary to convert ENTRY_PARM to\n-\t the type in which this function declares it,\n-\t and store that result in an appropriate place,\n-\t which may be a pseudo reg, may be STACK_PARM,\n-\t or may be a local stack slot if STACK_PARM is 0.\n+/* A subroutine of assign_parms.  Adjust DATA->STACK_RTL such that it's\n+   always valid and properly aligned.  */\n \n-\t Set DECL_RTL to that place.  */\n \n-      if (GET_CODE (entry_parm) == PARALLEL\n-\t  && nominal_mode != BLKmode\n-\t  && XVECLEN (entry_parm, 0) > 1)\n-\t{\n-\t  /* Reconstitute objects the size of a register or larger using\n-\t     register operations instead of the stack.  */\n-\t  rtx parmreg = gen_reg_rtx (nominal_mode);\n+static void\n+assign_parm_adjust_stack_rtl (struct assign_parm_data_one *data)\n+{\n+  rtx stack_parm = data->stack_parm;\n+\n+  /* If we can't trust the parm stack slot to be aligned enough for its\n+     ultimate type, don't use that slot after entry.  We'll make another\n+     stack slot, if we need one.  */\n+  if (STRICT_ALIGNMENT && stack_parm\n+      && GET_MODE_ALIGNMENT (data->nominal_mode) > MEM_ALIGN (stack_parm))\n+    stack_parm = NULL;\n+\n+  /* If parm was passed in memory, and we need to convert it on entry,\n+     don't store it back in that same slot.  */\n+  else if (data->entry_parm == stack_parm\n+\t   && data->nominal_mode != BLKmode\n+\t   && data->nominal_mode != data->passed_mode)\n+    stack_parm = NULL;\n+\n+  data->stack_parm = stack_parm;\n+}\n \n-\t  if (REG_P (parmreg))\n-\t    {\n-\t      emit_group_store (parmreg, entry_parm, TREE_TYPE (parm),\n-\t\t\t\tint_size_in_bytes (TREE_TYPE (parm)));\n-\t      SET_DECL_RTL (parm, parmreg);\n-\t      loaded_in_reg = 1;\n-\t    }\n-\t}\n+/* A subroutine of assign_parms.  Return true if the current parameter\n+   should be stored as a BLKmode in the current frame.  */\n+\n+static bool\n+assign_parm_setup_block_p (struct assign_parm_data_one *data)\n+{\n+  if (data->nominal_mode == BLKmode)\n+    return true;\n+  if (GET_CODE (data->entry_parm) == PARALLEL)\n+    return true;\n \n-      if (nominal_mode == BLKmode\n #ifdef BLOCK_REG_PADDING\n-\t  || (locate.where_pad == (BYTES_BIG_ENDIAN ? upward : downward)\n-\t      && GET_MODE_SIZE (promoted_mode) < UNITS_PER_WORD)\n+  if (data->locate.where_pad == (BYTES_BIG_ENDIAN ? upward : downward)\n+      && GET_MODE_SIZE (data->promoted_mode) < UNITS_PER_WORD)\n+    return true;\n #endif\n-\t  || GET_CODE (entry_parm) == PARALLEL)\n+\n+  return false;\n+}\n+\n+/* A subroutine of assign_parms.  Arrange for the parameter to be \n+   present and valid in DATA->STACK_RTL.  */\n+\n+static void\n+assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n+{\n+  rtx entry_parm = data->entry_parm;\n+  rtx stack_parm = data->stack_parm;\n+\n+  /* If we've a non-block object that's nevertheless passed in parts,\n+     reconstitute it in register operations rather than on the stack.  */\n+  if (GET_CODE (entry_parm) == PARALLEL\n+      && data->nominal_mode != BLKmode\n+      && XVECLEN (entry_parm, 0) > 1\n+      && optimize)\n+    {\n+      rtx parmreg = gen_reg_rtx (data->nominal_mode);\n+\n+      emit_group_store (parmreg, entry_parm, data->nominal_type,\n+\t\t\tint_size_in_bytes (data->nominal_type));\n+      SET_DECL_RTL (parm, parmreg);\n+      return;\n+    }\n+\n+  /* If a BLKmode arrives in registers, copy it to a stack slot.  Handle\n+     calls that pass values in multiple non-contiguous locations.  */\n+  if (REG_P (entry_parm) || GET_CODE (entry_parm) == PARALLEL)\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (data->passed_type);\n+      HOST_WIDE_INT size_stored = CEIL_ROUND (size, UNITS_PER_WORD);\n+      rtx mem;\n+\n+      /* Note that we will be storing an integral number of words.\n+\t So we have to be careful to ensure that we allocate an\n+\t integral number of words.  We do this below in the\n+\t assign_stack_local if space was not allocated in the argument\n+\t list.  If it was, this will not work if PARM_BOUNDARY is not\n+\t a multiple of BITS_PER_WORD.  It isn't clear how to fix this\n+\t if it becomes a problem.  Exception is when BLKmode arrives\n+\t with arguments not conforming to word_mode.  */\n+\n+      if (stack_parm == 0)\n \t{\n-\t  /* If a BLKmode arrives in registers, copy it to a stack slot.\n-\t     Handle calls that pass values in multiple non-contiguous\n-\t     locations.  The Irix 6 ABI has examples of this.  */\n-\t  if (REG_P (entry_parm)\n-\t      || (GET_CODE (entry_parm) == PARALLEL\n-\t\t && (!loaded_in_reg || !optimize)))\n-\t    {\n-\t      int size = int_size_in_bytes (TREE_TYPE (parm));\n-\t      int size_stored = CEIL_ROUND (size, UNITS_PER_WORD);\n-\t      rtx mem;\n-\n-\t      /* Note that we will be storing an integral number of words.\n-\t\t So we have to be careful to ensure that we allocate an\n-\t\t integral number of words.  We do this below in the\n-\t\t assign_stack_local if space was not allocated in the argument\n-\t\t list.  If it was, this will not work if PARM_BOUNDARY is not\n-\t\t a multiple of BITS_PER_WORD.  It isn't clear how to fix this\n-\t\t if it becomes a problem.  Exception is when BLKmode arrives\n-\t\t with arguments not conforming to word_mode.  */\n-\n-\t      if (stack_parm == 0)\n-\t\t{\n-\t\t  stack_parm = assign_stack_local (BLKmode, size_stored, 0);\n-\t\t  PUT_MODE (stack_parm, GET_MODE (entry_parm));\n-\t\t  set_mem_attributes (stack_parm, parm, 1);\n-\t\t}\n-\t      else if (GET_CODE (entry_parm) == PARALLEL)\n-\t\t;\n-\t      else if (size != 0 && PARM_BOUNDARY % BITS_PER_WORD != 0)\n-\t\tabort ();\n+\t  stack_parm = assign_stack_local (BLKmode, size_stored, 0);\n+\t  data->stack_parm = stack_parm;\n+\t  PUT_MODE (stack_parm, GET_MODE (entry_parm));\n+\t  set_mem_attributes (stack_parm, parm, 1);\n+\t}\n+      else if (GET_CODE (entry_parm) == PARALLEL)\n+\t;\n+      else if (size != 0 && PARM_BOUNDARY % BITS_PER_WORD != 0)\n+\tabort ();\n \n-\t      mem = validize_mem (stack_parm);\n+      mem = validize_mem (stack_parm);\n \n-\t      /* Handle calls that pass values in multiple non-contiguous\n-\t\t locations.  The Irix 6 ABI has examples of this.  */\n-\t      if (GET_CODE (entry_parm) == PARALLEL)\n-\t\temit_group_store (mem, entry_parm, TREE_TYPE (parm), size);\n+      /* Handle values in multiple non-contiguous locations.  */\n+      if (GET_CODE (entry_parm) == PARALLEL)\n+\temit_group_store (mem, entry_parm, data->passed_type, size);\n \n-\t      else if (size == 0)\n-\t\t;\n+      else if (size == 0)\n+\t;\n \n-\t      /* If SIZE is that of a mode no bigger than a word, just use\n-\t\t that mode's store operation.  */\n-\t      else if (size <= UNITS_PER_WORD)\n-\t\t{\n-\t\t  enum machine_mode mode\n-\t\t    = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+      /* If SIZE is that of a mode no bigger than a word, just use\n+\t that mode's store operation.  */\n+      else if (size <= UNITS_PER_WORD)\n+\t{\n+\t  enum machine_mode mode\n+\t    = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n \n-\t\t  if (mode != BLKmode\n+\t  if (mode != BLKmode\n #ifdef BLOCK_REG_PADDING\n-\t\t      && (size == UNITS_PER_WORD\n-\t\t\t  || (BLOCK_REG_PADDING (mode, TREE_TYPE (parm), 1)\n-\t\t\t      != (BYTES_BIG_ENDIAN ? upward : downward)))\n+\t      && (size == UNITS_PER_WORD\n+\t\t  || (BLOCK_REG_PADDING (mode, data->passed_type, 1)\n+\t\t      != (BYTES_BIG_ENDIAN ? upward : downward)))\n #endif\n-\t\t      )\n-\t\t    {\n-\t\t      rtx reg = gen_rtx_REG (mode, REGNO (entry_parm));\n-\t\t      emit_move_insn (change_address (mem, mode, 0), reg);\n-\t\t    }\n+\t      )\n+\t    {\n+\t      rtx reg = gen_rtx_REG (mode, REGNO (entry_parm));\n+\t      emit_move_insn (change_address (mem, mode, 0), reg);\n+\t    }\n \n-\t\t  /* Blocks smaller than a word on a BYTES_BIG_ENDIAN\n-\t\t     machine must be aligned to the left before storing\n-\t\t     to memory.  Note that the previous test doesn't\n-\t\t     handle all cases (e.g. SIZE == 3).  */\n-\t\t  else if (size != UNITS_PER_WORD\n+\t  /* Blocks smaller than a word on a BYTES_BIG_ENDIAN\n+\t     machine must be aligned to the left before storing\n+\t     to memory.  Note that the previous test doesn't\n+\t     handle all cases (e.g. SIZE == 3).  */\n+\t  else if (size != UNITS_PER_WORD\n #ifdef BLOCK_REG_PADDING\n-\t\t\t   && (BLOCK_REG_PADDING (mode, TREE_TYPE (parm), 1)\n-\t\t\t       == downward)\n+\t\t   && (BLOCK_REG_PADDING (mode, data->passed_type, 1)\n+\t\t       == downward)\n #else\n-\t\t\t   && BYTES_BIG_ENDIAN\n+\t\t   && BYTES_BIG_ENDIAN\n #endif\n-\t\t\t   )\n-\t\t    {\n-\t\t      rtx tem, x;\n-\t\t      int by = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n-\t\t      rtx reg = gen_rtx_REG (word_mode, REGNO (entry_parm));\n-\n-\t\t      x = expand_binop (word_mode, ashl_optab, reg,\n-\t\t\t\t\tGEN_INT (by), 0, 1, OPTAB_WIDEN);\n-\t\t      tem = change_address (mem, word_mode, 0);\n-\t\t      emit_move_insn (tem, x);\n-\t\t    }\n-\t\t  else\n-\t\t    move_block_from_reg (REGNO (entry_parm), mem,\n-\t\t\t\t\t size_stored / UNITS_PER_WORD);\n-\t\t}\n-\t      else\n-\t\tmove_block_from_reg (REGNO (entry_parm), mem,\n-\t\t\t\t     size_stored / UNITS_PER_WORD);\n+\t\t   )\n+\t    {\n+\t      rtx tem, x;\n+\t      int by = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\t      rtx reg = gen_rtx_REG (word_mode, REGNO (data->entry_parm));\n+\n+\t      x = expand_binop (word_mode, ashl_optab, reg,\n+\t\t\t\tGEN_INT (by), 0, 1, OPTAB_WIDEN);\n+\t      tem = change_address (mem, word_mode, 0);\n+\t      emit_move_insn (tem, x);\n \t    }\n-\t  /* If parm is already bound to register pair, don't change \n-\t     this binding.  */\n-\t  if (! DECL_RTL_SET_P (parm))\n-\t    SET_DECL_RTL (parm, stack_parm);\n+\t  else\n+\t    move_block_from_reg (REGNO (data->entry_parm), mem,\n+\t\t\t\t size_stored / UNITS_PER_WORD);\n \t}\n-      else if (use_register_for_decl (parm)\n-\t       /* Always assign pseudo to structure return or item passed\n-\t\t  by invisible reference.  */\n-\t       || passed_pointer || parm == function_result_decl)\n+      else\n+\tmove_block_from_reg (REGNO (data->entry_parm), mem,\n+\t\t\t     size_stored / UNITS_PER_WORD);\n+    }\n+\n+  SET_DECL_RTL (parm, stack_parm);\n+}\n+\n+/* A subroutine of assign_parms.  Allocate a pseudo to hold the current\n+   parameter.  Get it there.  Perform all ABI specified conversions.  */\n+\n+static void\n+assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n+\t\t       struct assign_parm_data_one *data)\n+{\n+  rtx parmreg;\n+  enum machine_mode promoted_nominal_mode;\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (parm));\n+  bool did_conversion = false;\n+\n+  /* Store the parm in a pseudoregister during the function, but we may\n+     need to do it in a wider mode.  */\n+\n+  promoted_nominal_mode\n+    = promote_mode (data->nominal_type, data->nominal_mode, &unsignedp, 0);\n+\n+  parmreg = gen_reg_rtx (promoted_nominal_mode);\n+\n+  if (!DECL_ARTIFICIAL (parm))\n+    mark_user_reg (parmreg);\n+\n+  /* If this was an item that we received a pointer to,\n+     set DECL_RTL appropriately.  */\n+  if (data->passed_pointer)\n+    {\n+      rtx x = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (data->passed_type)), parmreg);\n+      set_mem_attributes (x, parm, 1);\n+      SET_DECL_RTL (parm, x);\n+    }\n+  else\n+    {\n+      SET_DECL_RTL (parm, parmreg);\n+      maybe_set_unchanging (DECL_RTL (parm), parm);\n+    }\n+\n+  /* Copy the value into the register.  */\n+  if (data->nominal_mode != data->passed_mode\n+      || promoted_nominal_mode != data->promoted_mode)\n+    {\n+      int save_tree_used;\n+\n+      /* ENTRY_PARM has been converted to PROMOTED_MODE, its\n+\t mode, by the caller.  We now have to convert it to\n+\t NOMINAL_MODE, if different.  However, PARMREG may be in\n+\t a different mode than NOMINAL_MODE if it is being stored\n+\t promoted.\n+\n+\t If ENTRY_PARM is a hard register, it might be in a register\n+\t not valid for operating in its mode (e.g., an odd-numbered\n+\t register for a DFmode).  In that case, moves are the only\n+\t thing valid, so we can't do a convert from there.  This\n+\t occurs when the calling sequence allow such misaligned\n+\t usages.\n+\n+\t In addition, the conversion may involve a call, which could\n+\t clobber parameters which haven't been copied to pseudo\n+\t registers yet.  Therefore, we must first copy the parm to\n+\t a pseudo reg here, and save the conversion until after all\n+\t parameters have been moved.  */\n+\n+      rtx tempreg = gen_reg_rtx (GET_MODE (data->entry_parm));\n+\n+      emit_move_insn (tempreg, validize_mem (data->entry_parm));\n+\n+      push_to_sequence (all->conversion_insns);\n+      tempreg = convert_to_mode (data->nominal_mode, tempreg, unsignedp);\n+\n+      if (GET_CODE (tempreg) == SUBREG\n+\t  && GET_MODE (tempreg) == data->nominal_mode\n+\t  && REG_P (SUBREG_REG (tempreg))\n+\t  && data->nominal_mode == data->passed_mode\n+\t  && GET_MODE (SUBREG_REG (tempreg)) == GET_MODE (data->entry_parm)\n+\t  && GET_MODE_SIZE (GET_MODE (tempreg))\n+\t     < GET_MODE_SIZE (GET_MODE (data->entry_parm)))\n \t{\n-\t  /* Store the parm in a pseudoregister during the function, but we\n-\t     may need to do it in a wider mode.  */\n+\t  /* The argument is already sign/zero extended, so note it\n+\t     into the subreg.  */\n+\t  SUBREG_PROMOTED_VAR_P (tempreg) = 1;\n+\t  SUBREG_PROMOTED_UNSIGNED_SET (tempreg, unsignedp);\n+\t}\n \n-\t  rtx parmreg;\n+      /* TREE_USED gets set erroneously during expand_assignment.  */\n+      save_tree_used = TREE_USED (parm);\n+      expand_assignment (parm, make_tree (data->nominal_type, tempreg), 0);\n+      TREE_USED (parm) = save_tree_used;\n+      all->conversion_insns = get_insns ();\n+      end_sequence ();\n \n-\t  unsignedp = TYPE_UNSIGNED (TREE_TYPE (parm));\n+      did_conversion = true;\n+    }\n+  else\n+    emit_move_insn (parmreg, validize_mem (data->entry_parm));\n+\n+  /* If we were passed a pointer but the actual value can safely live\n+     in a register, put it in one.  */\n+  if (data->passed_pointer\n+      && TYPE_MODE (TREE_TYPE (parm)) != BLKmode\n+      /* If by-reference argument was promoted, demote it.  */\n+      && (TYPE_MODE (TREE_TYPE (parm)) != GET_MODE (DECL_RTL (parm))\n+\t  || use_register_for_decl (parm)))\n+    {\n+      /* We can't use nominal_mode, because it will have been set to\n+\t Pmode above.  We must use the actual mode of the parm.  */\n+      parmreg = gen_reg_rtx (TYPE_MODE (TREE_TYPE (parm)));\n+      mark_user_reg (parmreg);\n \n-\t  promoted_nominal_mode\n-\t    = promote_mode (TREE_TYPE (parm), nominal_mode, &unsignedp, 0);\n+      if (GET_MODE (parmreg) != GET_MODE (DECL_RTL (parm)))\n+\t{\n+\t  rtx tempreg = gen_reg_rtx (GET_MODE (DECL_RTL (parm)));\n+\t  int unsigned_p = TYPE_UNSIGNED (TREE_TYPE (parm));\n+\n+\t  push_to_sequence (all->conversion_insns);\n+\t  emit_move_insn (tempreg, DECL_RTL (parm));\n+\t  tempreg = convert_to_mode (GET_MODE (parmreg), tempreg, unsigned_p);\n+\t  emit_move_insn (parmreg, tempreg);\n+\t  all->conversion_insns = get_insns();\n+\t  end_sequence ();\n \n-\t  parmreg = gen_reg_rtx (promoted_nominal_mode);\n-\t  mark_user_reg (parmreg);\n+\t  did_conversion = true;\n+\t}\n+      else\n+\temit_move_insn (parmreg, DECL_RTL (parm));\n \n-\t  /* If this was an item that we received a pointer to, set DECL_RTL\n-\t     appropriately.  */\n-\t  if (passed_pointer)\n-\t    {\n-\t      rtx x = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (passed_type)),\n-\t\t\t\t   parmreg);\n-\t      set_mem_attributes (x, parm, 1);\n-\t      SET_DECL_RTL (parm, x);\n-\t    }\n-\t  else\n-\t    {\n-\t      SET_DECL_RTL (parm, parmreg);\n-\t      maybe_set_unchanging (DECL_RTL (parm), parm);\n-\t    }\n+      SET_DECL_RTL (parm, parmreg);\n \n-\t  /* Copy the value into the register.  */\n-\t  if (nominal_mode != passed_mode\n-\t      || promoted_nominal_mode != promoted_mode)\n-\t    {\n-\t      int save_tree_used;\n-\t      /* ENTRY_PARM has been converted to PROMOTED_MODE, its\n-\t\t mode, by the caller.  We now have to convert it to\n-\t\t NOMINAL_MODE, if different.  However, PARMREG may be in\n-\t\t a different mode than NOMINAL_MODE if it is being stored\n-\t\t promoted.\n-\n-\t\t If ENTRY_PARM is a hard register, it might be in a register\n-\t\t not valid for operating in its mode (e.g., an odd-numbered\n-\t\t register for a DFmode).  In that case, moves are the only\n-\t\t thing valid, so we can't do a convert from there.  This\n-\t\t occurs when the calling sequence allow such misaligned\n-\t\t usages.\n-\n-\t\t In addition, the conversion may involve a call, which could\n-\t\t clobber parameters which haven't been copied to pseudo\n-\t\t registers yet.  Therefore, we must first copy the parm to\n-\t\t a pseudo reg here, and save the conversion until after all\n-\t\t parameters have been moved.  */\n-\n-\t      rtx tempreg = gen_reg_rtx (GET_MODE (entry_parm));\n-\n-\t      emit_move_insn (tempreg, validize_mem (entry_parm));\n-\n-\t      push_to_sequence (conversion_insns);\n-\t      tempreg = convert_to_mode (nominal_mode, tempreg, unsignedp);\n-\n-\t      if (GET_CODE (tempreg) == SUBREG\n-\t\t  && GET_MODE (tempreg) == nominal_mode\n-\t\t  && REG_P (SUBREG_REG (tempreg))\n-\t\t  && nominal_mode == passed_mode\n-\t\t  && GET_MODE (SUBREG_REG (tempreg)) == GET_MODE (entry_parm)\n-\t\t  && GET_MODE_SIZE (GET_MODE (tempreg))\n-\t\t     < GET_MODE_SIZE (GET_MODE (entry_parm)))\n-\t\t{\n-\t\t  /* The argument is already sign/zero extended, so note it\n-\t\t     into the subreg.  */\n-\t\t  SUBREG_PROMOTED_VAR_P (tempreg) = 1;\n-\t\t  SUBREG_PROMOTED_UNSIGNED_SET (tempreg, unsignedp);\n-\t\t}\n+      /* STACK_PARM is the pointer, not the parm, and PARMREG is\n+\t now the parm.  */\n+      data->stack_parm = NULL;\n+    }\n \n-\t      /* TREE_USED gets set erroneously during expand_assignment.  */\n-\t      save_tree_used = TREE_USED (parm);\n-\t      expand_assignment (parm,\n-\t\t\t\t make_tree (nominal_type, tempreg), 0);\n-\t      TREE_USED (parm) = save_tree_used;\n-\t      conversion_insns = get_insns ();\n-\t      did_conversion = 1;\n-\t      end_sequence ();\n-\t    }\n-\t  else\n-\t    emit_move_insn (parmreg, validize_mem (entry_parm));\n-\n-\t  /* If we were passed a pointer but the actual value\n-\t     can safely live in a register, put it in one.  */\n-\t  if (passed_pointer\n-\t      && use_register_for_decl (parm)\n-\t      /* If by-reference argument was promoted, demote it.  */\n-\t      && TYPE_MODE (TREE_TYPE (parm)) != GET_MODE (DECL_RTL (parm)))\n-\t    {\n-\t      /* We can't use nominal_mode, because it will have been set to\n-\t\t Pmode above.  We must use the actual mode of the parm.  */\n-\t      parmreg = gen_reg_rtx (TYPE_MODE (TREE_TYPE (parm)));\n-\t      mark_user_reg (parmreg);\n-\t      if (GET_MODE (parmreg) != GET_MODE (DECL_RTL (parm)))\n-\t\t{\n-\t\t  rtx tempreg = gen_reg_rtx (GET_MODE (DECL_RTL (parm)));\n-\t\t  int unsigned_p = TYPE_UNSIGNED (TREE_TYPE (parm));\n-\t\t  push_to_sequence (conversion_insns);\n-\t\t  emit_move_insn (tempreg, DECL_RTL (parm));\n-\t\t  SET_DECL_RTL (parm,\n-\t\t\t\tconvert_to_mode (GET_MODE (parmreg),\n-\t\t\t\t\t\t tempreg,\n-\t\t\t\t\t\t unsigned_p));\n-\t\t  emit_move_insn (parmreg, DECL_RTL (parm));\n-\t\t  conversion_insns = get_insns();\n-\t\t  did_conversion = 1;\n-\t\t  end_sequence ();\n-\t\t}\n-\t      else\n-\t\temit_move_insn (parmreg, DECL_RTL (parm));\n-\t      SET_DECL_RTL (parm, parmreg);\n-\t      /* STACK_PARM is the pointer, not the parm, and PARMREG is\n-\t\t now the parm.  */\n-\t      stack_parm = 0;\n-\t    }\n #ifdef FUNCTION_ARG_CALLEE_COPIES\n-\t  /* If we are passed an arg by reference and it is our responsibility\n-\t     to make a copy, do it now.\n-\t     PASSED_TYPE and PASSED mode now refer to the pointer, not the\n-\t     original argument, so we must recreate them in the call to\n-\t     FUNCTION_ARG_CALLEE_COPIES.  */\n-\t  /* ??? Later add code to handle the case that if the argument isn't\n-\t     modified, don't do the copy.  */\n-\n-\t  else if (passed_pointer\n-\t\t   && FUNCTION_ARG_CALLEE_COPIES (args_so_far,\n-\t\t\t\t\t\t  TYPE_MODE (TREE_TYPE (passed_type)),\n-\t\t\t\t\t\t  TREE_TYPE (passed_type),\n-\t\t\t\t\t\t  named_arg)\n-\t\t   && ! TREE_ADDRESSABLE (TREE_TYPE (passed_type)))\n-\t    {\n-\t      rtx copy;\n-\t      tree type = TREE_TYPE (passed_type);\n+  /* If we are passed an arg by reference and it is our responsibility\n+     to make a copy, do it now.\n+     PASSED_TYPE and PASSED mode now refer to the pointer, not the\n+     original argument, so we must recreate them in the call to\n+     FUNCTION_ARG_CALLEE_COPIES.  */\n+  /* ??? Later add code to handle the case that if the argument isn't\n+     modified, don't do the copy.  */\n+\n+  else if (data->passed_pointer\n+\t   && FUNCTION_ARG_CALLEE_COPIES (all->args_so_far,\n+\t\t\t\t\t  TYPE_MODE (TREE_TYPE (passed_type)),\n+\t\t\t\t\t  TREE_TYPE (passed_type),\n+\t\t\t\t\t  data->named_arg)\n+\t   && ! TREE_ADDRESSABLE (TREE_TYPE (passed_type)))\n+    {\n+      rtx copy;\n+      tree type = TREE_TYPE (passed_type);\n \n-\t      /* This sequence may involve a library call perhaps clobbering\n-\t\t registers that haven't been copied to pseudos yet.  */\n+      /* This sequence may involve a library call perhaps clobbering\n+\t registers that haven't been copied to pseudos yet.  */\n \n-\t      push_to_sequence (conversion_insns);\n+      push_to_sequence (all->conversion_insns);\n \n-\t      if (!COMPLETE_TYPE_P (type)\n-\t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-\t\t/* This is a variable sized object.  */\n-\t\tcopy = gen_rtx_MEM (BLKmode,\n-\t\t\t\t    allocate_dynamic_stack_space\n-\t\t\t\t    (expr_size (parm), NULL_RTX,\n-\t\t\t\t     TYPE_ALIGN (type)));\n-\t      else\n-\t\tcopy = assign_stack_temp (TYPE_MODE (type),\n-\t\t\t\t\t  int_size_in_bytes (type), 1);\n-\t      set_mem_attributes (copy, parm, 1);\n-\n-\t      store_expr (parm, copy, 0);\n-\t      emit_move_insn (parmreg, XEXP (copy, 0));\n-\t      conversion_insns = get_insns ();\n-\t      did_conversion = 1;\n-\t      end_sequence ();\n-\t    }\n+      if (!COMPLETE_TYPE_P (type)\n+\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t{\n+\t  /* This is a variable sized object.  */\n+\t  copy = allocate_dynamic_stack_space (expr_size (parm), NULL_RTX,\n+\t\t\t\t\t       TYPE_ALIGN (type));\n+\t  copy = gen_rtx_MEM (BLKmode, copy);\n+\t}\n+      else\n+\tcopy = assign_stack_temp (TYPE_MODE (type),\n+\t\t\t\t  int_size_in_bytes (type), 1);\n+      set_mem_attributes (copy, parm, 1);\n+\n+      store_expr (parm, copy, 0);\n+      emit_move_insn (parmreg, XEXP (copy, 0));\n+      all->conversion_insns = get_insns ();\n+      end_sequence ();\n+\n+      did_conversion = true;\n+    }\n #endif /* FUNCTION_ARG_CALLEE_COPIES */\n \n-\t  /* Mark the register as eliminable if we did no conversion\n-\t     and it was copied from memory at a fixed offset,\n-\t     and the arg pointer was not copied to a pseudo-reg.\n-\t     If the arg pointer is a pseudo reg or the offset formed\n-\t     an invalid address, such memory-equivalences\n-\t     as we make here would screw up life analysis for it.  */\n-\t  if (nominal_mode == passed_mode\n-\t      && ! did_conversion\n-\t      && stack_parm != 0\n-\t      && MEM_P (stack_parm)\n-\t      && locate.offset.var == 0\n-\t      && reg_mentioned_p (virtual_incoming_args_rtx,\n-\t\t\t\t  XEXP (stack_parm, 0)))\n+  /* Mark the register as eliminable if we did no conversion and it was\n+     copied from memory at a fixed offset, and the arg pointer was not\n+     copied to a pseudo-reg.  If the arg pointer is a pseudo reg or the\n+     offset formed an invalid address, such memory-equivalences as we\n+     make here would screw up life analysis for it.  */\n+  if (data->nominal_mode == data->passed_mode\n+      && !did_conversion\n+      && data->stack_parm != 0\n+      && MEM_P (data->stack_parm)\n+      && data->locate.offset.var == 0\n+      && reg_mentioned_p (virtual_incoming_args_rtx,\n+\t\t\t  XEXP (data->stack_parm, 0)))\n+    {\n+      rtx linsn = get_last_insn ();\n+      rtx sinsn, set;\n+\n+      /* Mark complex types separately.  */\n+      if (GET_CODE (parmreg) == CONCAT)\n+\t{\n+\t  enum machine_mode submode\n+\t    = GET_MODE_INNER (GET_MODE (parmreg));\n+\t  int regnor = REGNO (gen_realpart (submode, parmreg));\n+\t  int regnoi = REGNO (gen_imagpart (submode, parmreg));\n+\t  rtx stackr = gen_realpart (submode, data->stack_parm);\n+\t  rtx stacki = gen_imagpart (submode, data->stack_parm);\n+\n+\t  /* Scan backwards for the set of the real and\n+\t     imaginary parts.  */\n+\t  for (sinsn = linsn; sinsn != 0;\n+\t       sinsn = prev_nonnote_insn (sinsn))\n \t    {\n-\t      rtx linsn = get_last_insn ();\n-\t      rtx sinsn, set;\n+\t      set = single_set (sinsn);\n+\t      if (set == 0)\n+\t\tcontinue;\n \n-\t      /* Mark complex types separately.  */\n-\t      if (GET_CODE (parmreg) == CONCAT)\n-\t\t{\n-\t\t  enum machine_mode submode\n-\t\t    = GET_MODE_INNER (GET_MODE (parmreg));\n-\t          int regnor = REGNO (gen_realpart (submode, parmreg));\n-\t          int regnoi = REGNO (gen_imagpart (submode, parmreg));\n-\t\t  rtx stackr = gen_realpart (submode, stack_parm);\n-\t\t  rtx stacki = gen_imagpart (submode, stack_parm);\n-\n-\t\t  /* Scan backwards for the set of the real and\n-\t\t     imaginary parts.  */\n-\t\t  for (sinsn = linsn; sinsn != 0;\n-\t\t       sinsn = prev_nonnote_insn (sinsn))\n-\t\t    {\n-\t\t      set = single_set (sinsn);\n-\t\t      if (set == 0)\n-\t\t\tcontinue;\n-\n-\t\t      if (SET_DEST (set) == regno_reg_rtx [regnoi])\n-\t\t        REG_NOTES (sinsn)\n-\t\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV, stacki,\n-\t\t\t\t\t       REG_NOTES (sinsn));\n-\t\t      else if (SET_DEST (set) == regno_reg_rtx [regnor])\n-\t\t        REG_NOTES (sinsn)\n-\t\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV, stackr,\n-\t\t\t\t\t       REG_NOTES (sinsn));\n-\t\t    }\n-\t\t}\n-\t      else if ((set = single_set (linsn)) != 0\n-\t\t       && SET_DEST (set) == parmreg)\n-\t\tREG_NOTES (linsn)\n-\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV,\n-\t\t\t\t       stack_parm, REG_NOTES (linsn));\n+\t      if (SET_DEST (set) == regno_reg_rtx [regnoi])\n+\t\tREG_NOTES (sinsn)\n+\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV, stacki,\n+\t\t\t\t       REG_NOTES (sinsn));\n+\t      else if (SET_DEST (set) == regno_reg_rtx [regnor])\n+\t\tREG_NOTES (sinsn)\n+\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV, stackr,\n+\t\t\t\t       REG_NOTES (sinsn));\n \t    }\n+\t}\n+      else if ((set = single_set (linsn)) != 0\n+\t       && SET_DEST (set) == parmreg)\n+\tREG_NOTES (linsn)\n+\t  = gen_rtx_EXPR_LIST (REG_EQUIV,\n+\t\t\t       data->stack_parm, REG_NOTES (linsn));\n+    }\n+\n+  /* For pointer data type, suggest pointer register.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (parm)))\n+    mark_reg_pointer (parmreg,\n+\t\t      TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));\n+}\n+\n+/* A subroutine of assign_parms.  Allocate stack space to hold the current\n+   parameter.  Get it there.  Perform all ABI specified conversions.  */\n+\n+static void\n+assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n+\t\t         struct assign_parm_data_one *data)\n+{\n+  /* Value must be stored in the stack slot STACK_PARM during function\n+     execution.  */\n+\n+  if (data->promoted_mode != data->nominal_mode)\n+    {\n+      /* Conversion is required.  */\n+      rtx tempreg = gen_reg_rtx (GET_MODE (data->entry_parm));\n+\n+      emit_move_insn (tempreg, validize_mem (data->entry_parm));\n \n-\t  /* For pointer data type, suggest pointer register.  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (parm)))\n-\t    mark_reg_pointer (parmreg,\n-\t\t\t      TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));\n+      push_to_sequence (all->conversion_insns);\n+      data->entry_parm = convert_to_mode (data->nominal_mode, tempreg,\n+\t\t\t\t\t  TYPE_UNSIGNED (TREE_TYPE (parm)));\n+\n+      if (data->stack_parm)\n+\t/* ??? This may need a big-endian conversion on sparc64.  */\n+\tdata->stack_parm\n+\t  = adjust_address (data->stack_parm, data->nominal_mode, 0);\n+\n+      all->conversion_insns = get_insns ();\n+      end_sequence ();\n+    }\n+\n+  if (data->entry_parm != data->stack_parm)\n+    {\n+      if (data->stack_parm == 0)\n+\t{\n+\t  data->stack_parm\n+\t    = assign_stack_local (GET_MODE (data->entry_parm),\n+\t\t\t\t  GET_MODE_SIZE (GET_MODE (data->entry_parm)),\n+\t\t\t\t  0);\n+\t  set_mem_attributes (data->stack_parm, parm, 1);\n \t}\n-      else\n+\n+      if (data->promoted_mode != data->nominal_mode)\n \t{\n-\t  /* Value must be stored in the stack slot STACK_PARM\n-\t     during function execution.  */\n+\t  push_to_sequence (all->conversion_insns);\n+\t  emit_move_insn (validize_mem (data->stack_parm),\n+\t\t\t  validize_mem (data->entry_parm));\n+\t  all->conversion_insns = get_insns ();\n+\t  end_sequence ();\n+\t}\n+      else\n+\temit_move_insn (validize_mem (data->stack_parm),\n+\t\t\tvalidize_mem (data->entry_parm));\n+    }\n \n-\t  if (promoted_mode != nominal_mode)\n-\t    {\n-\t      /* Conversion is required.  */\n-\t      rtx tempreg = gen_reg_rtx (GET_MODE (entry_parm));\n+  SET_DECL_RTL (parm, data->stack_parm);\n+}\n \n-\t      emit_move_insn (tempreg, validize_mem (entry_parm));\n+/* A subroutine of assign_parms.  If the ABI splits complex arguments, then\n+   undo the frobbing that we did in assign_parms_augmented_arg_list.  */\n \n-\t      push_to_sequence (conversion_insns);\n-\t      entry_parm = convert_to_mode (nominal_mode, tempreg,\n-\t\t\t\t\t    TYPE_UNSIGNED (TREE_TYPE (parm)));\n-\t      if (stack_parm)\n-\t\t/* ??? This may need a big-endian conversion on sparc64.  */\n-\t\tstack_parm = adjust_address (stack_parm, nominal_mode, 0);\n+static void\n+assign_parms_unsplit_complex (tree orig_fnargs, tree fnargs)\n+{\n+  tree parm;\n \n-\t      conversion_insns = get_insns ();\n-\t      did_conversion = 1;\n-\t      end_sequence ();\n-\t    }\n+  for (parm = orig_fnargs; parm; parm = TREE_CHAIN (parm))\n+    {\n+      if (TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (TREE_TYPE (parm)))\n+\t{\n+\t  rtx tmp, real, imag;\n+\t  enum machine_mode inner = GET_MODE_INNER (DECL_MODE (parm));\n \n-\t  if (entry_parm != stack_parm)\n+\t  real = DECL_RTL (fnargs);\n+\t  imag = DECL_RTL (TREE_CHAIN (fnargs));\n+\t  if (inner != GET_MODE (real))\n \t    {\n-\t      if (stack_parm == 0)\n-\t\t{\n-\t\t  stack_parm\n-\t\t    = assign_stack_local (GET_MODE (entry_parm),\n-\t\t\t\t\t  GET_MODE_SIZE (GET_MODE (entry_parm)),\n-\t\t\t\t\t  0);\n-\t\t  set_mem_attributes (stack_parm, parm, 1);\n-\t\t}\n+\t      real = gen_lowpart_SUBREG (inner, real);\n+\t      imag = gen_lowpart_SUBREG (inner, imag);\n+\t    }\n+\t  tmp = gen_rtx_CONCAT (DECL_MODE (parm), real, imag);\n+\t  SET_DECL_RTL (parm, tmp);\n \n-\t      if (promoted_mode != nominal_mode)\n-\t\t{\n-\t\t  push_to_sequence (conversion_insns);\n-\t\t  emit_move_insn (validize_mem (stack_parm),\n-\t\t\t\t  validize_mem (entry_parm));\n-\t\t  conversion_insns = get_insns ();\n-\t\t  end_sequence ();\n-\t\t}\n-\t      else\n-\t\temit_move_insn (validize_mem (stack_parm),\n-\t\t\t\tvalidize_mem (entry_parm));\n+\t  real = DECL_INCOMING_RTL (fnargs);\n+\t  imag = DECL_INCOMING_RTL (TREE_CHAIN (fnargs));\n+\t  if (inner != GET_MODE (real))\n+\t    {\n+\t      real = gen_lowpart_SUBREG (inner, real);\n+\t      imag = gen_lowpart_SUBREG (inner, imag);\n \t    }\n+\t  tmp = gen_rtx_CONCAT (DECL_MODE (parm), real, imag);\n+\t  set_decl_incoming_rtl (parm, tmp);\n+\t  fnargs = TREE_CHAIN (fnargs);\n+\t}\n+      else\n+\t{\n+\t  SET_DECL_RTL (parm, DECL_RTL (fnargs));\n+\t  set_decl_incoming_rtl (parm, DECL_INCOMING_RTL (fnargs));\n \n-\t  SET_DECL_RTL (parm, stack_parm);\n+\t  /* Set MEM_EXPR to the original decl, i.e. to PARM,\n+\t     instead of the copy of decl, i.e. FNARGS.  */\n+\t  if (DECL_INCOMING_RTL (parm) && MEM_P (DECL_INCOMING_RTL (parm)))\n+\t    set_mem_expr (DECL_INCOMING_RTL (parm), parm);\n \t}\n+\n+      fnargs = TREE_CHAIN (fnargs);\n     }\n+}\n+\n+/* Assign RTL expressions to the function's parameters.  This may involve\n+   copying them into registers and using those registers as the DECL_RTL.  */\n+\n+void\n+assign_parms (tree fndecl)\n+{\n+  struct assign_parm_data_all all;\n+  tree fnargs, parm;\n+  rtx internal_arg_pointer;\n+  int varargs_setup = 0;\n+\n+  /* If the reg that the virtual arg pointer will be translated into is\n+     not a fixed reg or is the stack pointer, make a copy of the virtual\n+     arg pointer, and address parms via the copy.  The frame pointer is\n+     considered fixed even though it is not marked as such.\n \n-  if (targetm.calls.split_complex_arg && fnargs != orig_fnargs)\n+     The second time through, simply use ap to avoid generating rtx.  */\n+\n+  if ((ARG_POINTER_REGNUM == STACK_POINTER_REGNUM\n+       || ! (fixed_regs[ARG_POINTER_REGNUM]\n+\t     || ARG_POINTER_REGNUM == FRAME_POINTER_REGNUM)))\n+    internal_arg_pointer = copy_to_reg (virtual_incoming_args_rtx);\n+  else\n+    internal_arg_pointer = virtual_incoming_args_rtx;\n+  current_function_internal_arg_pointer = internal_arg_pointer;\n+\n+  assign_parms_initialize_all (&all);\n+  fnargs = assign_parms_augmented_arg_list (&all);\n+\n+  for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n     {\n-      for (parm = orig_fnargs; parm; parm = TREE_CHAIN (parm))\n+      struct assign_parm_data_one data;\n+\n+      /* Extract the type of PARM; adjust it according to ABI.  */\n+      assign_parm_find_data_types (&all, parm, &data);\n+\n+      /* Early out for errors and void parameters.  */\n+      if (data.passed_mode == VOIDmode)\n \t{\n-\t  if (TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE\n-\t      && targetm.calls.split_complex_arg (TREE_TYPE (parm)))\n-\t    {\n-\t      rtx tmp, real, imag;\n-\t      enum machine_mode inner = GET_MODE_INNER (DECL_MODE (parm));\n+\t  SET_DECL_RTL (parm, const0_rtx);\n+\t  DECL_INCOMING_RTL (parm) = DECL_RTL (parm);\n+\t  continue;\n+\t}\n \n-\t      real = DECL_RTL (fnargs);\n-\t      imag = DECL_RTL (TREE_CHAIN (fnargs));\n-\t      if (inner != GET_MODE (real))\n-\t\t{\n-\t\t  real = gen_lowpart_SUBREG (inner, real);\n-\t\t  imag = gen_lowpart_SUBREG (inner, imag);\n-\t\t}\n-\t      tmp = gen_rtx_CONCAT (DECL_MODE (parm), real, imag);\n-\t      SET_DECL_RTL (parm, tmp);\n+      /* Handle stdargs.  LAST_NAMED is a slight mis-nomer; it's also true\n+\t for the unnamed dummy argument following the last named argument.\n+\t See ABI silliness wrt strict_argument_naming and NAMED_ARG.  So\n+\t we only want to do this when we get to the actual last named\n+\t argument, which will be the first time LAST_NAMED gets set.  */\n+      if (data.last_named && !varargs_setup)\n+\t{\n+\t  varargs_setup = true;\n+\t  assign_parms_setup_varargs (&all, &data, false);\n+\t}\n \n-\t      real = DECL_INCOMING_RTL (fnargs);\n-\t      imag = DECL_INCOMING_RTL (TREE_CHAIN (fnargs));\n-\t      if (inner != GET_MODE (real))\n-\t\t{\n-\t\t  real = gen_lowpart_SUBREG (inner, real);\n-\t\t  imag = gen_lowpart_SUBREG (inner, imag);\n-\t\t}\n-\t      tmp = gen_rtx_CONCAT (DECL_MODE (parm), real, imag);\n-\t      set_decl_incoming_rtl (parm, tmp);\n-\t      fnargs = TREE_CHAIN (fnargs);\n-\t    }\n-\t  else\n-\t    {\n-\t      SET_DECL_RTL (parm, DECL_RTL (fnargs));\n-\t      set_decl_incoming_rtl (parm, DECL_INCOMING_RTL (fnargs));\n-\n-\t      /* Set MEM_EXPR to the original decl, i.e. to PARM,\n-\t\t instead of the copy of decl, i.e. FNARGS.  */\n-\t      if (DECL_INCOMING_RTL (parm)\n-\t\t  && MEM_P (DECL_INCOMING_RTL (parm)))\n-\t\tset_mem_expr (DECL_INCOMING_RTL (parm), parm);\n-\t    }\n-\t  fnargs = TREE_CHAIN (fnargs);\n+      /* Find out where the parameter arrives in this function.  */\n+      assign_parm_find_entry_rtl (&all, &data);\n+\n+      /* Find out where stack space for this parameter might be.  */\n+      if (assign_parm_is_stack_parm (&all, &data))\n+\t{\n+\t  assign_parm_find_stack_rtl (parm, &data);\n+\t  assign_parm_adjust_entry_rtl (&data);\n \t}\n+\n+      /* Record permanently how this parm was passed.  */\n+      set_decl_incoming_rtl (parm, data.entry_parm);\n+\n+      /* Update info on where next arg arrives in registers.  */\n+      FUNCTION_ARG_ADVANCE (all.args_so_far, data.promoted_mode,\n+\t\t\t    data.passed_type, data.named_arg);\n+\n+      assign_parm_adjust_stack_rtl (&data);\n+\n+      if (assign_parm_setup_block_p (&data))\n+\tassign_parm_setup_block (parm, &data);\n+      else if (data.passed_pointer || use_register_for_decl (parm))\n+\tassign_parm_setup_reg (&all, parm, &data);\n+      else\n+\tassign_parm_setup_stack (&all, parm, &data);\n     }\n \n+  if (targetm.calls.split_complex_arg && fnargs != all.orig_fnargs)\n+    assign_parms_unsplit_complex (all.orig_fnargs, fnargs);\n+\n   /* Output all parameter conversion instructions (possibly including calls)\n      now that all parameters have been copied out of hard registers.  */\n-  emit_insn (conversion_insns);\n+  emit_insn (all.conversion_insns);\n \n   /* If we are receiving a struct value address as the first argument, set up\n      the RTL for the function result. As this might require code to convert\n      the transmitted address to Pmode, we do this here to ensure that possible\n      preliminary conversions of the address have been emitted already.  */\n-  if (function_result_decl)\n+  if (all.function_result_decl)\n     {\n-      tree result = DECL_RESULT (fndecl);\n-      rtx addr = DECL_RTL (function_result_decl);\n+      tree result = DECL_RESULT (current_function_decl);\n+      rtx addr = DECL_RTL (all.function_result_decl);\n       rtx x;\n \n       addr = convert_memory_address (Pmode, addr);\n@@ -2961,8 +3170,9 @@ assign_parms (tree fndecl)\n     }\n \n   /* We have aligned all the args, so add space for the pretend args.  */\n-  stack_args_size.constant += extra_pretend_bytes;\n-  current_function_args_size = stack_args_size.constant;\n+  current_function_pretend_args_size = all.pretend_args_size;\n+  all.stack_args_size.constant += all.extra_pretend_bytes;\n+  current_function_args_size = all.stack_args_size.constant;\n \n   /* Adjust function incoming argument size for alignment and\n      minimum length.  */\n@@ -2978,12 +3188,12 @@ assign_parms (tree fndecl)\n \n #ifdef ARGS_GROW_DOWNWARD\n   current_function_arg_offset_rtx\n-    = (stack_args_size.var == 0 ? GEN_INT (-stack_args_size.constant)\n-       : expand_expr (size_diffop (stack_args_size.var,\n-\t\t\t\t   size_int (-stack_args_size.constant)),\n+    = (stack_args_size.var == 0 ? GEN_INT (-all.stack_args_size.constant)\n+       : expand_expr (size_diffop (all.stack_args_size.var,\n+\t\t\t\t   size_int (-all.stack_args_size.constant)),\n \t\t      NULL_RTX, VOIDmode, 0));\n #else\n-  current_function_arg_offset_rtx = ARGS_SIZE_RTX (stack_args_size);\n+  current_function_arg_offset_rtx = ARGS_SIZE_RTX (all.stack_args_size);\n #endif\n \n   /* See how many bytes, if any, of its args a function should try to pop\n@@ -2995,7 +3205,7 @@ assign_parms (tree fndecl)\n   /* For stdarg.h function, save info about\n      regs and stack space used by the named args.  */\n \n-  current_function_args_info = args_so_far;\n+  current_function_args_info = all.args_so_far;\n \n   /* Set the rtx used for the function return value.  Put this in its\n      own variable so any optimizers that need this information don't have\n@@ -3035,60 +3245,6 @@ assign_parms (tree fndecl)\n \t}\n     }\n }\n-\n-/* If ARGS contains entries with complex types, split the entry into two\n-   entries of the component type.  Return a new list of substitutions are\n-   needed, else the old list.  */\n-\n-static tree\n-split_complex_args (tree args)\n-{\n-  tree p;\n-\n-  /* Before allocating memory, check for the common case of no complex.  */\n-  for (p = args; p; p = TREE_CHAIN (p))\n-    {\n-      tree type = TREE_TYPE (p);\n-      if (TREE_CODE (type) == COMPLEX_TYPE\n-\t  && targetm.calls.split_complex_arg (type))\n-        goto found;\n-    }\n-  return args;\n-\n- found:\n-  args = copy_list (args);\n-\n-  for (p = args; p; p = TREE_CHAIN (p))\n-    {\n-      tree type = TREE_TYPE (p);\n-      if (TREE_CODE (type) == COMPLEX_TYPE\n-\t  && targetm.calls.split_complex_arg (type))\n-\t{\n-\t  tree decl;\n-\t  tree subtype = TREE_TYPE (type);\n-\n-\t  /* Rewrite the PARM_DECL's type with its component.  */\n-\t  TREE_TYPE (p) = subtype;\n-\t  DECL_ARG_TYPE (p) = TREE_TYPE (DECL_ARG_TYPE (p));\n-\t  DECL_MODE (p) = VOIDmode;\n-\t  DECL_SIZE (p) = NULL;\n-\t  DECL_SIZE_UNIT (p) = NULL;\n-\t  layout_decl (p, 0);\n-\n-\t  /* Build a second synthetic decl.  */\n-\t  decl = build_decl (PARM_DECL, NULL_TREE, subtype);\n-\t  DECL_ARG_TYPE (decl) = DECL_ARG_TYPE (p);\n-\t  layout_decl (decl, 0);\n-\n-\t  /* Splice it in; skip the new decl.  */\n-\t  TREE_CHAIN (decl) = TREE_CHAIN (p);\n-\t  TREE_CHAIN (p) = decl;\n-\t  p = decl;\n-\t}\n-    }\n-\n-  return args;\n-}\n \f\n /* Indicate whether REGNO is an incoming argument to the current function\n    that was promoted to a wider mode.  If so, return the RTX for the"}]}