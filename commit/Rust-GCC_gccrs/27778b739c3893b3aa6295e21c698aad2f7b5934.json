{"sha": "27778b739c3893b3aa6295e21c698aad2f7b5934", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3NzhiNzM5YzM4OTNiM2FhNjI5NWUyMWM2OThhYWQyZjdiNTkzNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-29T01:39:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-29T01:39:04Z"}, "message": "cp-tree.h (strip_array_types): New function.\n\n\t* cp-tree.h (strip_array_types): New function.\n\t* decl.c (maybe_deduce_size_from_array_init): New function, split\n\tout from cp_finish_decl.\n\t(layout_var_decl): Likewise.\n\t(maybe_commonize_var): Likewise.\n\t(maybe_inject_for_scope_var): Likewise.\n\t(initialize_local_var): Likewise.\n\t(build_cleanup_on_safe_obstack): Likewise.\n\t(check_initializer): Likewise.\n\t(make_rtl_for_nonlocal_decl): Likewise.\n\t(cp_finish_decl): Use them.\n\t* typeck.c (strip_array_types): New function.\n\nFrom-SVN: r28956", "tree": {"sha": "55c1952e777b54793ab4c537a88880bd600bb3e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55c1952e777b54793ab4c537a88880bd600bb3e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27778b739c3893b3aa6295e21c698aad2f7b5934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27778b739c3893b3aa6295e21c698aad2f7b5934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27778b739c3893b3aa6295e21c698aad2f7b5934", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27778b739c3893b3aa6295e21c698aad2f7b5934/comments", "author": null, "committer": null, "parents": [{"sha": "31aa49b77060d8d81466908a506854a08b7efb18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31aa49b77060d8d81466908a506854a08b7efb18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31aa49b77060d8d81466908a506854a08b7efb18"}], "stats": {"total": 1029, "additions": 588, "deletions": 441}, "files": [{"sha": "be4bbdbabc059aa7403232534e570db777741198", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27778b739c3893b3aa6295e21c698aad2f7b5934/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27778b739c3893b3aa6295e21c698aad2f7b5934/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=27778b739c3893b3aa6295e21c698aad2f7b5934", "patch": "@@ -4,6 +4,19 @@\n \n 1999-08-28  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (strip_array_types): New function.\n+\t* decl.c (maybe_deduce_size_from_array_init): New function, split\n+\tout from cp_finish_decl.\n+\t(layout_var_decl): Likewise.\n+\t(maybe_commonize_var): Likewise.\n+\t(maybe_inject_for_scope_var): Likewise.\n+\t(initialize_local_var): Likewise.\n+\t(build_cleanup_on_safe_obstack): Likewise.\n+\t(check_initializer): Likewise.\n+\t(make_rtl_for_nonlocal_decl): Likewise.\n+\t(cp_finish_decl): Use them.\n+\t* typeck.c (strip_array_types): New function.\n+\t\n \t* cp-tree.def (LABEL_STMT): New tree node.\n \t* cp-tree.h (LABEL_STMT_LABEL): New macro.\n \t(shadow_label): Remove."}, {"sha": "901d25298ff36c0cbab58d5137b316862e519c11", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27778b739c3893b3aa6295e21c698aad2f7b5934/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27778b739c3893b3aa6295e21c698aad2f7b5934/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=27778b739c3893b3aa6295e21c698aad2f7b5934", "patch": "@@ -3574,6 +3574,7 @@ extern tree c_expand_start_case\t\t\tPROTO((tree));\n extern int comp_ptr_ttypes\t\t\tPROTO((tree, tree));\n extern int ptr_reasonably_similar\t\tPROTO((tree, tree));\n extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n+extern tree strip_array_types                   PROTO((tree));\n extern int cp_type_quals                        PROTO((tree));\n extern int cp_has_mutable_p                     PROTO((tree));\n extern int at_least_as_qualified_p              PROTO((tree, tree));"}, {"sha": "8ca2f57a7ecc77592fe4e14bc7b377ed1847affd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 560, "deletions": 437, "changes": 997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27778b739c3893b3aa6295e21c698aad2f7b5934/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27778b739c3893b3aa6295e21c698aad2f7b5934/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=27778b739c3893b3aa6295e21c698aad2f7b5934", "patch": "@@ -193,6 +193,14 @@ static void add_decl_to_level PROTO((tree, struct binding_level *));\n static tree make_label_decl PROTO((tree, int));\n static void pop_label PROTO((tree));\n static void pop_labels PROTO((tree));\n+static void maybe_deduce_size_from_array_init PROTO((tree, tree));\n+static void layout_var_decl PROTO((tree, tree *));\n+static void maybe_commonize_var PROTO((tree));\n+static void maybe_inject_for_scope_var PROTO((tree));\n+static void initialize_local_var PROTO((tree, tree, tree, int));\n+static tree build_cleanup_on_safe_obstack PROTO((tree));\n+static void check_initializer PROTO((tree, tree *));\n+static void make_rtl_for_nonlocal_decl PROTO((tree, tree, const char *));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -7315,6 +7323,207 @@ obscure_complex_init (decl, init)\n   return init;\n }\n \n+/* When parsing `int a[] = {1, 2};' we don't know the size of the\n+   array until we finish parsing the initializer.  If that's the\n+   situation we're in, update DECL accordingly.  */\n+\n+static void\n+maybe_deduce_size_from_array_init (decl, init)\n+     tree decl;\n+     tree init;\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_DOMAIN (type) == NULL_TREE\n+      && TREE_CODE (decl) != TYPE_DECL)\n+    {\n+      int do_default\n+\t= (TREE_STATIC (decl)\n+\t   /* Even if pedantic, an external linkage array\n+\t      may have incomplete type at first.  */\n+\t   ? pedantic && ! DECL_EXTERNAL (decl)\n+\t   : !DECL_EXTERNAL (decl));\n+      tree initializer = init ? init : DECL_INITIAL (decl);\n+      int failure = complete_array_type (type, initializer, do_default);\n+\n+      if (failure == 1)\n+\tcp_error (\"initializer fails to determine size of `%D'\", decl);\n+\n+      if (failure == 2)\n+\t{\n+\t  if (do_default)\n+\t    cp_error (\"array size missing in `%D'\", decl);\n+\t  /* If a `static' var's size isn't known, make it extern as\n+\t     well as static, so it does not get allocated.  If it's not\n+\t     `static', then don't mark it extern; finish_incomplete_decl\n+\t     will give it a default size and it will get allocated.  */\n+\t  else if (!pedantic && TREE_STATIC (decl) && !TREE_PUBLIC (decl))\n+\t    DECL_EXTERNAL (decl) = 1;\n+\t}\n+\n+      if (pedantic && TYPE_DOMAIN (type) != NULL_TREE\n+\t  && tree_int_cst_lt (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n+\t\t\t      integer_zero_node))\n+\tcp_error (\"zero-size array `%D'\", decl);\n+\n+      layout_decl (decl, 0);\n+    }\n+}\n+\n+/* Set DECL_SIZE, DECL_ALIGN, etc. for DECL (a VAR_DECL), and issue\n+   any appropriate error messages regarding the layout.  INITP is a\n+   pointer to the initializer for DECL; the initializer may be\n+   modified by this function.  */\n+\n+static void\n+layout_var_decl (decl, initp)\n+     tree decl;\n+     tree *initp;\n+{\n+  tree ttype = target_type (TREE_TYPE (decl));\n+\n+  if (DECL_SIZE (decl) == NULL_TREE\n+      && TYPE_SIZE (complete_type (TREE_TYPE (decl))) != NULL_TREE)\n+    layout_decl (decl, 0);\n+\n+  if (TREE_STATIC (decl) && DECL_SIZE (decl) == NULL_TREE)\n+    {\n+      /* A static variable with an incomplete type:\n+\t that is an error if it is initialized.\n+\t Otherwise, let it through, but if it is not `extern'\n+\t then it may cause an error message later.  */\n+      if (DECL_INITIAL (decl) != NULL_TREE)\n+\tcp_error (\"storage size of `%D' isn't known\", decl);\n+      *initp = NULL_TREE;\n+    }\n+  else if (!DECL_EXTERNAL (decl) && DECL_SIZE (decl) == NULL_TREE)\n+    {\n+      /* An automatic variable with an incomplete type: that is an error.\n+\t Don't talk about array types here, since we took care of that\n+\t message in grokdeclarator.  */\n+      cp_error (\"storage size of `%D' isn't known\", decl);\n+      TREE_TYPE (decl) = error_mark_node;\n+    }\n+  else if (!DECL_EXTERNAL (decl) && IS_AGGR_TYPE (ttype))\n+    /* Let debugger know it should output info for this type.  */\n+    note_debug_info_needed (ttype);\n+\n+  if (TREE_STATIC (decl) && DECL_CLASS_SCOPE_P (decl))\n+    note_debug_info_needed (DECL_CONTEXT (decl));\n+\n+  if ((DECL_EXTERNAL (decl) || TREE_STATIC (decl))\n+      && DECL_SIZE (decl) != NULL_TREE\n+      && ! TREE_CONSTANT (DECL_SIZE (decl)))\n+    {\n+      if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n+\tconstant_expression_warning (DECL_SIZE (decl));\n+      else\n+\tcp_error (\"storage size of `%D' isn't constant\", decl);\n+    }\n+}\n+\n+/* Return a cleanup for DECL, created on whatever obstack is\n+   appropriate.  */\n+\n+static tree\n+build_cleanup_on_safe_obstack (decl)\n+     tree decl;\n+{\n+  tree cleanup;\n+  tree type;\n+  int need_pop;\n+\n+  type = TREE_TYPE (decl);\n+\n+  /* Only variables get cleaned up.  */\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return NULL_TREE;\n+  \n+  /* And only things with destructors need cleaning up.  */\n+  if (!TYPE_NEEDS_DESTRUCTOR (type))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (decl) == VAR_DECL &&\n+      (DECL_EXTERNAL (decl) || TREE_STATIC (decl)))\n+    /* We don't clean up things that aren't defined in this\n+       translation unit, or that need a static cleanup.  The latter\n+       are handled by finish_file.  */\n+    return NULL_TREE;\n+  \n+  /* Switch to an obstack that will live until the point where the\n+     cleanup code is actually expanded.  */\n+  need_pop = suspend_momentary ();\n+\n+  /* Compute the cleanup.  */\n+  cleanup = maybe_build_cleanup (decl);\n+\n+  /* Pop back to the obstack we were on before.  */\n+  resume_momentary (need_pop);\n+  \n+  return cleanup;\n+}\n+\n+/* If a local static variable is declared in an inline function, or if\n+   we have a weak definition, we must endeavor to create only one\n+   instance of the variable at link-time.  */\n+\n+static void\n+maybe_commonize_var (decl)\n+     tree decl;\n+{\n+  /* Static data in a function with comdat linkage also has comdat\n+     linkage.  */\n+  if (TREE_STATIC (decl)\n+      /* Don't mess with __FUNCTION__.  */\n+      && ! TREE_ASM_WRITTEN (decl)\n+      && current_function_decl\n+      && DECL_CONTEXT (decl) == current_function_decl\n+      && (DECL_THIS_INLINE (current_function_decl)\n+\t  || DECL_TEMPLATE_INSTANTIATION (current_function_decl))\n+      && TREE_PUBLIC (current_function_decl))\n+    {\n+      /* Rather than try to get this right with inlining, we suppress\n+\t inlining of such functions.  */\n+      current_function_cannot_inline\n+\t= \"function with static variable cannot be inline\";\n+\n+      /* If flag_weak, we don't need to mess with this, as we can just\n+\t make the function weak, and let it refer to its unique local\n+\t copy.  This works because we don't allow the function to be\n+\t inlined.  */\n+      if (! flag_weak)\n+\t{\n+\t  if (DECL_INTERFACE_KNOWN (current_function_decl))\n+\t    {\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_EXTERNAL (decl) = DECL_EXTERNAL (current_function_decl);\n+\t    }\n+\t  else if (DECL_INITIAL (decl) == NULL_TREE\n+\t\t   || DECL_INITIAL (decl) == error_mark_node)\n+\t    {\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_COMMON (decl) = 1;\n+\t    }\n+\t  /* else we lose. We can only do this if we can use common,\n+\t     which we can't if it has been initialized.  */\n+\n+\t  if (TREE_PUBLIC (decl))\n+\t    DECL_ASSEMBLER_NAME (decl)\n+\t      = build_static_name (current_function_decl, DECL_NAME (decl));\n+\t  else if (! DECL_ARTIFICIAL (decl))\n+\t    {\n+\t      cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);\n+\t      cp_warning_at (\"  you can work around this by removing the initializer\", decl);\n+\t    }\n+\t}\n+    }\n+  else if (DECL_LANG_SPECIFIC (decl) && DECL_COMDAT (decl))\n+    /* Set it up again; we might have set DECL_INITIAL since the last\n+       time.  */\n+    comdat_linkage (decl);\n+}\n+\n /* Issue an error message if DECL is an uninitialized const variable.  */\n \n static void\n@@ -7334,6 +7543,327 @@ check_for_uninitialized_const_var (decl)\n     cp_error (\"uninitialized const `%D'\", decl);\n }\n \n+/* Verify INITP (the initializer for DECL), and record the\n+   initialization in DECL_INITIAL, if appropriate.  The initializer\n+   may be modified by this function.  */\n+\n+static void\n+check_initializer (decl, initp)\n+     tree decl;\n+     tree *initp;\n+{\n+  tree init;\n+  tree type;\n+\n+  if (TREE_CODE (decl) == FIELD_DECL)\n+    return;\n+\n+  type = TREE_TYPE (decl);\n+  init = *initp;\n+\n+  /* If `start_decl' didn't like having an initialization, ignore it now.  */\n+  if (init != NULL_TREE && DECL_INITIAL (decl) == NULL_TREE)\n+    init = NULL_TREE;\n+  else if (DECL_EXTERNAL (decl))\n+    ;\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      if (TREE_STATIC (decl))\n+\tmake_decl_rtl (decl, NULL_PTR, toplevel_bindings_p ());\n+      grok_reference_init (decl, type, init);\n+      init = NULL_TREE;\n+    }\n+\n+  /* Check for certain invalid initializations.  */\n+  if (init)\n+    {\n+      if (TYPE_SIZE (type) && !TREE_CONSTANT (TYPE_SIZE (type)))\n+\t{\n+\t  cp_error (\"variable-sized object `%D' may not be initialized\", decl);\n+\t  init = NULL_TREE;\n+\t}\n+      if (TREE_CODE (type) == ARRAY_TYPE\n+\t  && !TYPE_SIZE (complete_type (TREE_TYPE (type))))\n+\t{\n+\t  cp_error (\"elements of array `%#D' have incomplete type\", decl);\n+\t  init = NULL_TREE;\n+\t}\n+    }\n+\n+  if (TREE_CODE (decl) == CONST_DECL)\n+    {\n+      my_friendly_assert (TREE_CODE (decl) != REFERENCE_TYPE, 148);\n+\n+      DECL_INITIAL (decl) = init;\n+\n+      /* This will keep us from needing to worry about our obstacks.  */\n+      my_friendly_assert (init != NULL_TREE, 149);\n+      init = NULL_TREE;\n+    }\n+  else if (init)\n+    {\n+      if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))\n+\t{\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    init = digest_init (type, init, (tree *) 0);\n+\t  else if (TREE_CODE (init) == CONSTRUCTOR\n+\t\t   && TREE_HAS_CONSTRUCTOR (init))\n+\t    {\n+\t      if (TYPE_NON_AGGREGATE_CLASS (type))\n+\t\t{\n+\t\t  cp_error (\"`%D' must be initialized by constructor, not by `{...}'\",\n+\t\t\t    decl);\n+\t\t  init = error_mark_node;\n+\t\t}\n+\t      else\n+\t\tgoto dont_use_constructor;\n+\t    }\n+\t}\n+      else\n+\t{\n+\tdont_use_constructor:\n+\t  if (TREE_CODE (init) != TREE_VEC)\n+\t    init = store_init_value (decl, init);\n+\t}\n+\n+      if (init)\n+\t/* We must hide the initializer so that expand_decl\n+\t   won't try to do something it does not understand.  */\n+\tinit = obscure_complex_init (decl, init);\n+    }\n+  else if (DECL_EXTERNAL (decl))\n+    ;\n+  else if (TREE_CODE_CLASS (TREE_CODE (type)) == 't'\n+\t   && (IS_AGGR_TYPE (type) || TYPE_NEEDS_CONSTRUCTING (type)))\n+    {\n+      tree core_type = strip_array_types (type);\n+\n+      if (! TYPE_NEEDS_CONSTRUCTING (core_type))\n+\t{\n+\t  if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type))\n+\t    cp_error (\"structure `%D' with uninitialized const members\", decl);\n+\t  if (CLASSTYPE_REF_FIELDS_NEED_INIT (core_type))\n+\t    cp_error (\"structure `%D' with uninitialized reference members\",\n+\t\t      decl);\n+\t}\n+\n+      check_for_uninitialized_const_var (decl);\n+\n+      if (TYPE_SIZE (type) != NULL_TREE\n+\t  && TYPE_NEEDS_CONSTRUCTING (type))\n+\tinit = obscure_complex_init (decl, NULL_TREE);\n+\n+    }\n+  else\n+    check_for_uninitialized_const_var (decl);\n+  \n+  /* Store the modified initializer for our caller.  */\n+  *initp = init;\n+}\n+\n+/* If DECL is not a local variable, give it RTL.  */\n+\n+static void\n+make_rtl_for_nonlocal_decl (decl, init, asmspec)\n+     tree decl;\n+     tree init;\n+     const char *asmspec;\n+{\n+  int was_temp;\n+  int toplev;\n+  tree type;\n+\n+  type = TREE_TYPE (decl);\n+  toplev = toplevel_bindings_p ();\n+  was_temp = (TREE_STATIC (decl) && TYPE_NEEDS_DESTRUCTOR (type)\n+\t      && allocation_temporary_p ());\n+  if (was_temp)\n+    end_temporary_allocation ();\n+\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n+    make_decl_rtl (decl, NULL_PTR, toplev);\n+  else if (TREE_CODE (decl) == VAR_DECL\n+\t   && TREE_READONLY (decl)\n+\t   && DECL_INITIAL (decl) != NULL_TREE\n+\t   && DECL_INITIAL (decl) != error_mark_node\n+\t   && ! EMPTY_CONSTRUCTOR_P (DECL_INITIAL (decl)))\n+    {\n+      DECL_INITIAL (decl) = save_expr (DECL_INITIAL (decl));\n+\n+      if (asmspec)\n+\tDECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n+\n+      if (! toplev\n+\t  && TREE_STATIC (decl)\n+\t  && ! TREE_SIDE_EFFECTS (decl)\n+\t  && ! TREE_PUBLIC (decl)\n+\t  && ! DECL_EXTERNAL (decl)\n+\t  && ! TYPE_NEEDS_DESTRUCTOR (type)\n+\t  && DECL_MODE (decl) != BLKmode)\n+\t{\n+\t  /* If this variable is really a constant, then fill its DECL_RTL\n+\t     slot with something which won't take up storage.\n+\t     If something later should take its address, we can always give\n+\t     it legitimate RTL at that time.  */\n+\t  DECL_RTL (decl) = gen_reg_rtx (DECL_MODE (decl));\n+\t  store_expr (DECL_INITIAL (decl), DECL_RTL (decl), 0);\n+\t  TREE_ASM_WRITTEN (decl) = 1;\n+\t}\n+      else if (toplev && ! TREE_PUBLIC (decl))\n+\t{\n+\t  /* If this is a static const, change its apparent linkage\n+\t     if it belongs to a #pragma interface.  */\n+\t  if (!interface_unknown)\n+\t    {\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_EXTERNAL (decl) = interface_only;\n+\t    }\n+\t  make_decl_rtl (decl, asmspec, toplev);\n+\t}\n+      else\n+\trest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL\n+\t   && DECL_LANG_SPECIFIC (decl)\n+\t   && DECL_IN_AGGR_P (decl))\n+    {\n+      my_friendly_assert (TREE_STATIC (decl), 19990828);\n+\n+      if (init == NULL_TREE\n+#ifdef DEFAULT_STATIC_DEFS\n+\t  /* If this code is dead, then users must\n+\t     explicitly declare static member variables\n+\t     outside the class def'n as well.  */\n+\t  && TYPE_NEEDS_CONSTRUCTING (type)\n+#endif\n+\t  )\n+\t{\n+\t  DECL_EXTERNAL (decl) = 1;\n+\t  make_decl_rtl (decl, asmspec, 1);\n+\t}\n+      else\n+\trest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n+    }\n+  else\n+    rest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n+\n+  if (was_temp)\n+    resume_temporary_allocation ();\n+}\n+\n+/* The old ARM scoping rules injected variables declared in the\n+   initialization statement of a for-statement into the surrounding\n+   scope.  We support this usage, in order to be backward-compatible.\n+   DECL is a just-declared VAR_DECL; if necessary inject its\n+   declaration into the surrounding scope.  */\n+\n+static void\n+maybe_inject_for_scope_var (decl)\n+     tree decl;\n+{\n+  if (current_binding_level->is_for_scope)\n+    {\n+      struct binding_level *outer \n+\t= current_binding_level->level_chain;\n+\n+      /* Check to see if the same name is already bound at the outer\n+\t level, either because it was directly declared, or because a\n+\t dead for-decl got preserved.  In either case, the code would\n+\t not have been valid under the ARM scope rules, so clear\n+\t is_for_scope for the current_binding_level.\n+\n+\t Otherwise, we need to preserve the temp slot for decl to last\n+\t into the outer binding level.  */\n+\n+      tree outer_binding \n+\t= TREE_CHAIN (IDENTIFIER_BINDING (DECL_NAME (decl)));\n+\t      \n+      if (outer_binding && BINDING_LEVEL (outer_binding) == outer\n+\t  && (TREE_CODE (BINDING_VALUE (outer_binding)) \n+\t      == VAR_DECL)\n+\t  && DECL_DEAD_FOR_LOCAL (BINDING_VALUE (outer_binding)))\n+\t{\n+\t  BINDING_VALUE (outer_binding)\n+\t    = DECL_SHADOWED_FOR_VAR (BINDING_VALUE (outer_binding));\n+\t  current_binding_level->is_for_scope = 0;\n+\t}\n+      else if (DECL_IN_MEMORY_P (decl))\n+\tpreserve_temp_slots (DECL_RTL (decl));\n+    }\n+}\n+\n+/* Generate code to initialized DECL (a local variable).  */\n+\n+static void\n+initialize_local_var (decl, init, cleanup, flags)\n+     tree decl;\n+     tree init;\n+     tree cleanup;\n+     int flags;\n+{\n+  tree type;\n+\n+  type = TREE_TYPE (decl);\n+  expand_start_target_temps ();\n+\n+  if (DECL_SIZE (decl) && type != error_mark_node)\n+    {\n+      int already_used;\n+  \n+      /* Compute and store the initial value.  */\n+      expand_decl_init (decl);\n+      already_used = TREE_USED (decl) || TREE_USED (type);\n+\n+      if (init || TYPE_NEEDS_CONSTRUCTING (type))\n+\t{\n+\t  emit_line_note (DECL_SOURCE_FILE (decl),\n+\t\t\t  DECL_SOURCE_LINE (decl));\n+\t  /* We call push_momentary here so that when\n+\t     finish_expr_stmt clears the momentary obstack it\n+\t     doesn't destory any momentary expressions we may\n+\t     have lying around.  Although cp_finish_decl is\n+\t     usually called at the end of a declaration\n+\t     statement, it may also be called for a temporary\n+\t     object in the middle of an expression.  */\n+\t  push_momentary ();\n+\t  finish_expr_stmt (build_aggr_init (decl, init, flags));\n+\t  pop_momentary ();\n+\t}\n+\n+      /* Set this to 0 so we can tell whether an aggregate which was\n+\t initialized was ever used.  Don't do this if it has a\n+\t destructor, so we don't complain about the 'resource\n+\t allocation is initialization' idiom.  */\n+      /* Now set attribute((unused)) on types so decls of that type\n+\t will be marked used. (see TREE_USED, above.)  This avoids the\n+\t warning problems this particular code tried to work\n+\t around. */\n+\n+      if (TYPE_NEEDS_CONSTRUCTING (type)\n+\t  && ! already_used\n+\t  && cleanup == NULL_TREE\n+\t  && DECL_NAME (decl))\n+\tTREE_USED (decl) = 0;\n+\n+      if (already_used)\n+\tTREE_USED (decl) = 1;\n+    }\n+\n+  /* Cleanup any temporaries needed for the initial value.  */\n+  expand_end_target_temps ();\n+\n+  if (DECL_SIZE (decl) && type != error_mark_node)\n+    {\n+      /* Store the cleanup, if there was one.  */\n+      if (cleanup)\n+\t{\n+\t  if (! expand_decl_cleanup (decl, cleanup))\n+\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t      decl);\n+\t}\n+    }\n+}\n+\n /* Finish processing of a declaration;\n    install its line number and initial value.\n    If the length of an array type is not known before,\n@@ -7364,13 +7894,11 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n      int flags;\n {\n   register tree type;\n-  tree cleanup = NULL_TREE, ttype = NULL_TREE;\n+  tree ttype = NULL_TREE;\n   int was_incomplete;\n   int temporary = allocation_temporary_p ();\n   const char *asmspec = NULL;\n   int was_readonly = 0;\n-  int already_used = 0;\n-  tree core_type;\n \n   /* If this is 0, then we did not change obstacks.  */\n   if (! decl)\n@@ -7433,6 +7961,9 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       goto finish_end0;\n     }\n \n+  /* Parameters are handled by store_parm_decls, not cp_finish_decl.  */\n+  my_friendly_assert (TREE_CODE (decl) != PARM_DECL, 19990828);\n+\n   /* Take care of TYPE_DECLs up front.  */\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n@@ -7478,122 +8009,19 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       TREE_READONLY (decl) = 0;\n     }\n \n-  if (TREE_CODE (decl) == FIELD_DECL)\n+  if (TREE_CODE (decl) == FIELD_DECL && asmspec)\n     {\n-      if (init && init != error_mark_node)\n-\tmy_friendly_assert (TREE_PERMANENT (init), 147);\n-\n-      if (asmspec)\n-\t{\n-\t  /* This must override the asm specifier which was placed\n-\t     by grokclassfn.  Lay this out fresh.  */\n-\t  DECL_RTL (TREE_TYPE (decl)) = NULL_RTX;\n-\t  DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n-\t  make_decl_rtl (decl, asmspec, 0);\n-\t}\n-    }\n-  /* If `start_decl' didn't like having an initialization, ignore it now.  */\n-  else if (init != NULL_TREE && DECL_INITIAL (decl) == NULL_TREE)\n-    init = NULL_TREE;\n-  else if (DECL_EXTERNAL (decl))\n-    ;\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      if (TREE_STATIC (decl))\n-\tmake_decl_rtl (decl, NULL_PTR, toplevel_bindings_p ());\n-      grok_reference_init (decl, type, init);\n-      init = NULL_TREE;\n+      /* This must override the asm specifier which was placed by\n+\t grokclassfn.  Lay this out fresh.  */\n+      DECL_RTL (TREE_TYPE (decl)) = NULL_RTX;\n+      DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n+      make_decl_rtl (decl, asmspec, 0);\n     }\n \n-  /* Check for certain invalid initializations.  */\n-  if (init)\n-    {\n-      if (TYPE_SIZE (type) && !TREE_CONSTANT (TYPE_SIZE (type)))\n-\t{\n-\t  cp_error (\"variable-sized object `%D' may not be initialized\", decl);\n-\t  init = NULL_TREE;\n-\t}\n-      if (TREE_CODE (type) == ARRAY_TYPE\n-\t  && !TYPE_SIZE (complete_type (TREE_TYPE (type))))\n-\t{\n-\t  cp_error (\"elements of array `%#D' have incomplete type\", decl);\n-\t  init = NULL_TREE;\n-\t}\n-    }\n+  check_initializer (decl, &init);\n \n   GNU_xref_decl (current_function_decl, decl);\n \n-  core_type = type;\n-  while (TREE_CODE (core_type) == ARRAY_TYPE)\n-    core_type = TREE_TYPE (core_type);\n-  \n-  if (TREE_CODE (decl) == FIELD_DECL)\n-    ;\n-  else if (TREE_CODE (decl) == CONST_DECL)\n-    {\n-      my_friendly_assert (TREE_CODE (decl) != REFERENCE_TYPE, 148);\n-\n-      DECL_INITIAL (decl) = init;\n-\n-      /* This will keep us from needing to worry about our obstacks.  */\n-      my_friendly_assert (init != NULL_TREE, 149);\n-      init = NULL_TREE;\n-    }\n-  else if (init)\n-    {\n-      if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))\n-\t{\n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    init = digest_init (type, init, (tree *) 0);\n-\t  else if (TREE_CODE (init) == CONSTRUCTOR\n-\t\t   && TREE_HAS_CONSTRUCTOR (init))\n-\t    {\n-\t      if (TYPE_NON_AGGREGATE_CLASS (type))\n-\t\t{\n-\t\t  cp_error (\"`%D' must be initialized by constructor, not by `{...}'\",\n-\t\t\t    decl);\n-\t\t  init = error_mark_node;\n-\t\t}\n-\t      else\n-\t\tgoto dont_use_constructor;\n-\t    }\n-\t}\n-      else\n-\t{\n-\tdont_use_constructor:\n-\t  if (TREE_CODE (init) != TREE_VEC)\n-\t    init = store_init_value (decl, init);\n-\t}\n-\n-      if (init)\n-\t/* We must hide the initializer so that expand_decl\n-\t   won't try to do something it does not understand.  */\n-\tinit = obscure_complex_init (decl, init);\n-    }\n-  else if (DECL_EXTERNAL (decl))\n-    ;\n-  else if (TREE_CODE_CLASS (TREE_CODE (type)) == 't'\n-\t   && (IS_AGGR_TYPE (type) || TYPE_NEEDS_CONSTRUCTING (type)))\n-    {\n-      if (! TYPE_NEEDS_CONSTRUCTING (core_type))\n-\t{\n-\t  if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type))\n-\t    cp_error (\"structure `%D' with uninitialized const members\", decl);\n-\t  if (CLASSTYPE_REF_FIELDS_NEED_INIT (core_type))\n-\t    cp_error (\"structure `%D' with uninitialized reference members\",\n-\t\t      decl);\n-\t}\n-\n-      check_for_uninitialized_const_var (decl);\n-\n-      if (TYPE_SIZE (type) != NULL_TREE\n-\t  && TYPE_NEEDS_CONSTRUCTING (type))\n-\tinit = obscure_complex_init (decl, NULL_TREE);\n-\n-    }\n-  else\n-    check_for_uninitialized_const_var (decl);\n-  \n   /* For top-level declaration, the initial value was read in\n      the temporary obstack.  MAXINDEX, rtl, etc. to be made below\n      must go in the permanent obstack; but don't discard the\n@@ -7603,102 +8031,10 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     end_temporary_allocation ();\n \n   /* Deduce size of array from initialization, if not already known.  */\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_DOMAIN (type) == NULL_TREE\n-      && TREE_CODE (decl) != TYPE_DECL)\n-    {\n-      int do_default\n-\t= (TREE_STATIC (decl)\n-\t   /* Even if pedantic, an external linkage array\n-\t      may have incomplete type at first.  */\n-\t   ? pedantic && ! DECL_EXTERNAL (decl)\n-\t   : !DECL_EXTERNAL (decl));\n-      tree initializer = init ? init : DECL_INITIAL (decl);\n-      int failure = complete_array_type (type, initializer, do_default);\n-\n-      if (failure == 1)\n-\tcp_error (\"initializer fails to determine size of `%D'\", decl);\n-\n-      if (failure == 2)\n-\t{\n-\t  if (do_default)\n-\t    cp_error (\"array size missing in `%D'\", decl);\n-\t  /* If a `static' var's size isn't known, make it extern as\n-\t     well as static, so it does not get allocated.  If it's not\n-\t     `static', then don't mark it extern; finish_incomplete_decl\n-\t     will give it a default size and it will get allocated.  */\n-\t  else if (!pedantic && TREE_STATIC (decl) && !TREE_PUBLIC (decl))\n-\t    DECL_EXTERNAL (decl) = 1;\n-\t}\n-\n-      if (pedantic && TYPE_DOMAIN (type) != NULL_TREE\n-\t  && tree_int_cst_lt (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n-\t\t\t      integer_zero_node))\n-\tcp_error (\"zero-size array `%D'\", decl);\n-\n-      layout_decl (decl, 0);\n-    }\n+  maybe_deduce_size_from_array_init (decl, init);\n \n   if (TREE_CODE (decl) == VAR_DECL)\n-    {\n-      if (DECL_SIZE (decl) == NULL_TREE\n-\t  && TYPE_SIZE (complete_type (TREE_TYPE (decl))) != NULL_TREE)\n-\tlayout_decl (decl, 0);\n-\n-      if (TREE_STATIC (decl) && DECL_SIZE (decl) == NULL_TREE)\n-\t{\n-\t  /* A static variable with an incomplete type:\n-\t     that is an error if it is initialized.\n-\t     Otherwise, let it through, but if it is not `extern'\n-\t     then it may cause an error message later.  */\n-\t  if (DECL_INITIAL (decl) != NULL_TREE)\n-\t    cp_error (\"storage size of `%D' isn't known\", decl);\n-\t  init = NULL_TREE;\n-\t}\n-      else if (!DECL_EXTERNAL (decl) && DECL_SIZE (decl) == NULL_TREE)\n-\t{\n-\t  /* An automatic variable with an incomplete type: that is an error.\n-\t     Don't talk about array types here, since we took care of that\n-\t     message in grokdeclarator.  */\n-\t  cp_error (\"storage size of `%D' isn't known\", decl);\n-\t  TREE_TYPE (decl) = error_mark_node;\n-\t}\n-      else if (!DECL_EXTERNAL (decl) && IS_AGGR_TYPE (ttype))\n-\t/* Let debugger know it should output info for this type.  */\n-\tnote_debug_info_needed (ttype);\n-\n-      if (TREE_STATIC (decl) && DECL_CLASS_SCOPE_P (decl))\n-\tnote_debug_info_needed (DECL_CONTEXT (decl));\n-\n-      if ((DECL_EXTERNAL (decl) || TREE_STATIC (decl))\n-\t  && DECL_SIZE (decl) != NULL_TREE\n-\t  && ! TREE_CONSTANT (DECL_SIZE (decl)))\n-\t{\n-\t  if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n-\t    constant_expression_warning (DECL_SIZE (decl));\n-\t  else\n-\t    cp_error (\"storage size of `%D' isn't constant\", decl);\n-\t}\n-\n-      if (! DECL_EXTERNAL (decl) && TYPE_NEEDS_DESTRUCTOR (type)\n-\t  /* Cleanups for static variables are handled by `finish_file'.  */\n-\t  && ! TREE_STATIC (decl))\n-\t{\n-\t  int yes = suspend_momentary ();\n-\t  cleanup = maybe_build_cleanup (decl);\n-\t  resume_momentary (yes);\n-\t}\n-    }\n-  /* PARM_DECLs get cleanups, too.  */\n-  else if (TREE_CODE (decl) == PARM_DECL && TYPE_NEEDS_DESTRUCTOR (type))\n-    {\n-      if (temporary)\n-\tend_temporary_allocation ();\n-      cleanup = maybe_build_cleanup (decl);\n-      if (temporary)\n-\tresume_temporary_allocation ();\n-    }\n+    layout_var_decl (decl, &init);\n \n   /* Output the assembler code and/or RTL code for variables and functions,\n      unless the type is an undefined structure or union.\n@@ -7711,146 +8047,18 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     {\n       /* ??? FIXME: What about nested classes?  */\n       int toplev = toplevel_bindings_p ();\n-      int was_temp\n-\t= (TREE_STATIC (decl) && TYPE_NEEDS_DESTRUCTOR (type)\n-\t   && allocation_temporary_p ());\n \n-      if (was_temp)\n-\tend_temporary_allocation ();\n-\n-      /* Static data in a function with comdat linkage also has comdat\n-         linkage.  */\n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && TREE_STATIC (decl)\n-\t  /* Don't mess with __FUNCTION__.  */\n-\t  && ! TREE_ASM_WRITTEN (decl)\n-\t  && current_function_decl\n-\t  && DECL_CONTEXT (decl) == current_function_decl\n-\t  && (DECL_THIS_INLINE (current_function_decl)\n-\t      || DECL_TEMPLATE_INSTANTIATION (current_function_decl))\n-\t  && TREE_PUBLIC (current_function_decl))\n-\t{\n-\t  /* Rather than try to get this right with inlining, we suppress\n-\t     inlining of such functions.  */\n-\t  current_function_cannot_inline\n-\t    = \"function with static variable cannot be inline\";\n-\n-\t  /* If flag_weak, we don't need to mess with this, as we can just\n-\t     make the function weak, and let it refer to its unique local\n-\t     copy.  This works because we don't allow the function to be\n-\t     inlined.  */\n-\t  if (! flag_weak)\n-\t    {\n-\t      if (DECL_INTERFACE_KNOWN (current_function_decl))\n-\t\t{\n-\t\t  TREE_PUBLIC (decl) = 1;\n-\t\t  DECL_EXTERNAL (decl) = DECL_EXTERNAL (current_function_decl);\n-\t\t}\n-\t      else if (DECL_INITIAL (decl) == NULL_TREE\n-\t\t       || DECL_INITIAL (decl) == error_mark_node)\n-\t\t{\n-\t\t  TREE_PUBLIC (decl) = 1;\n-\t\t  DECL_COMMON (decl) = 1;\n-\t\t}\n-\t      /* else we lose. We can only do this if we can use common,\n-                 which we can't if it has been initialized.  */\n-\n-\t      if (TREE_PUBLIC (decl))\n-\t\tDECL_ASSEMBLER_NAME (decl)\n-\t\t  = build_static_name (current_function_decl, DECL_NAME (decl));\n-\t      else if (! DECL_ARTIFICIAL (decl))\n-\t\t{\n-\t\t  cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);\n-\t\t  cp_warning_at (\"  you can work around this by removing the initializer\", decl);\n-\t\t}\n-\t    }\n-\t}\n-\n-      else if (TREE_CODE (decl) == VAR_DECL\n-\t       && DECL_LANG_SPECIFIC (decl)\n-\t       && DECL_COMDAT (decl))\n-\t/* Set it up again; we might have set DECL_INITIAL since the\n-\t   last time.  */\n-\tcomdat_linkage (decl);\n-\n-      if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n-\tmake_decl_rtl (decl, NULL_PTR, toplev);\n-      else if (TREE_CODE (decl) == VAR_DECL\n-\t       && TREE_READONLY (decl)\n-\t       && DECL_INITIAL (decl) != NULL_TREE\n-\t       && DECL_INITIAL (decl) != error_mark_node\n-\t       && ! EMPTY_CONSTRUCTOR_P (DECL_INITIAL (decl)))\n-\t{\n-\t  DECL_INITIAL (decl) = save_expr (DECL_INITIAL (decl));\n-\n-\t  if (asmspec)\n-\t    DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n-\n-\t  if (! toplev\n-\t      && TREE_STATIC (decl)\n-\t      && ! TREE_SIDE_EFFECTS (decl)\n-\t      && ! TREE_PUBLIC (decl)\n-\t      && ! DECL_EXTERNAL (decl)\n-\t      && ! TYPE_NEEDS_DESTRUCTOR (type)\n-\t      && DECL_MODE (decl) != BLKmode)\n-\t    {\n-\t      /* If this variable is really a constant, then fill its DECL_RTL\n-\t\t slot with something which won't take up storage.\n-\t\t If something later should take its address, we can always give\n-\t\t it legitimate RTL at that time.  */\n-\t      DECL_RTL (decl) = gen_reg_rtx (DECL_MODE (decl));\n-\t      store_expr (DECL_INITIAL (decl), DECL_RTL (decl), 0);\n-\t      TREE_ASM_WRITTEN (decl) = 1;\n-\t    }\n-\t  else if (toplev && ! TREE_PUBLIC (decl))\n-\t    {\n-\t      /* If this is a static const, change its apparent linkage\n-\t         if it belongs to a #pragma interface.  */\n-\t      if (!interface_unknown)\n-\t\t{\n-\t\t  TREE_PUBLIC (decl) = 1;\n-\t\t  DECL_EXTERNAL (decl) = interface_only;\n-\t\t}\n-\t      make_decl_rtl (decl, asmspec, toplev);\n-\t    }\n-\t  else\n-\t    rest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n-\t}\n-      else if (TREE_CODE (decl) == VAR_DECL\n-\t       && DECL_LANG_SPECIFIC (decl)\n-\t       && DECL_IN_AGGR_P (decl))\n-\t{\n-\t  if (TREE_STATIC (decl))\n-\t    {\n-\t      if (init == NULL_TREE\n-#ifdef DEFAULT_STATIC_DEFS\n-\t\t  /* If this code is dead, then users must\n-\t\t     explicitly declare static member variables\n-\t\t     outside the class def'n as well.  */\n-\t\t  && TYPE_NEEDS_CONSTRUCTING (type)\n-#endif\n-\t\t  )\n-\t\t{\n-\t\t  DECL_EXTERNAL (decl) = 1;\n-\t\t  make_decl_rtl (decl, asmspec, 1);\n-\t\t}\n-\t      else\n-\t\trest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n-\t    }\n-\t  else\n-\t    /* Just a constant field.  Should not need any rtl.  */\n-\t    goto finish_end0;\n-\t}\n-      else\n-\trest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n+      if (TREE_CODE (decl) == VAR_DECL)\n+\tmaybe_commonize_var (decl);\n \n-      if (was_temp)\n-\tresume_temporary_allocation ();\n+      make_rtl_for_nonlocal_decl (decl, init, asmspec);\n \n-      if (!abstract_virtuals_error (decl, core_type)\n-\t  && (TREE_CODE (type) == FUNCTION_TYPE\n-\t      || TREE_CODE (type) == METHOD_TYPE))\n-\tabstract_virtuals_error (decl, TREE_TYPE (type));\n+      if (TREE_CODE (type) == FUNCTION_TYPE \n+\t  || TREE_CODE (type) == METHOD_TYPE)\n+\tabstract_virtuals_error (decl, \n+\t\t\t\t strip_array_types (TREE_TYPE (type)));\n+      else \n+\tabstract_virtuals_error (decl, strip_array_types (type));\n \n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t;\n@@ -7870,6 +8078,8 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t}\n       else if (! toplev)\n \t{\n+\t  tree cleanup = build_cleanup_on_safe_obstack (decl);\n+\n \t  /* This is a declared decl which must live until the\n \t     end of the binding contour.  It may need a cleanup.  */\n \n@@ -7904,93 +8114,8 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t}\n \t    }\n \n-\t  if (current_binding_level->is_for_scope)\n-\t    {\n-\t      struct binding_level *outer \n-\t\t= current_binding_level->level_chain;\n-\n-\t      /* Check to see if the same name is already bound at\n-\t\t the outer level, either because it was directly declared,\n-\t\t or because a dead for-decl got preserved.  In either case,\n-\t\t the code would not have been valid under the ARM\n-\t\t scope rules, so clear is_for_scope for the\n-\t\t current_binding_level.\n-\n-\t\t Otherwise, we need to preserve the temp slot for decl\n-\t\t to last into the outer binding level.  */\n-\n-\t      tree outer_binding \n-\t\t= TREE_CHAIN (IDENTIFIER_BINDING (DECL_NAME (decl)));\n-\t      \n-\t      if (outer_binding && BINDING_LEVEL (outer_binding) == outer\n-\t\t  && (TREE_CODE (BINDING_VALUE (outer_binding)) \n-\t\t      == VAR_DECL)\n-\t\t  && DECL_DEAD_FOR_LOCAL (BINDING_VALUE (outer_binding)))\n-\t\t{\n-\t\t  BINDING_VALUE (outer_binding)\n-\t\t    = DECL_SHADOWED_FOR_VAR (BINDING_VALUE (outer_binding));\n-\t\t  current_binding_level->is_for_scope = 0;\n-\t\t}\n-\t      else if (DECL_IN_MEMORY_P (decl))\n-\t\tpreserve_temp_slots (DECL_RTL (decl));\n-\t    }\n-\n-\t  expand_start_target_temps ();\n-\n-\t  if (DECL_SIZE (decl) && type != error_mark_node)\n-\t    {\n-\t      /* Compute and store the initial value.  */\n-\t      expand_decl_init (decl);\n-       \t      already_used = TREE_USED (decl) || TREE_USED (type);\n-\n-\t      if (init || TYPE_NEEDS_CONSTRUCTING (type))\n-\t\t{\n-\t\t  emit_line_note (DECL_SOURCE_FILE (decl),\n-\t\t\t\t  DECL_SOURCE_LINE (decl));\n-\t\t  /* We call push_momentary here so that when\n-\t\t     finish_expr_stmt clears the momentary obstack it\n-\t\t     doesn't destory any momentary expressions we may\n-\t\t     have lying around.  Although cp_finish_decl is\n-\t\t     usually called at the end of a declaration\n-\t\t     statement, it may also be called for a temporary\n-\t\t     object in the middle of an expression.  */\n-\t\t  push_momentary ();\n-\t\t  finish_expr_stmt (build_aggr_init (decl, init, flags));\n-\t\t  pop_momentary ();\n-\t\t}\n-\n-\t      /* Set this to 0 so we can tell whether an aggregate which\n-\t\t was initialized was ever used.  Don't do this if it has a\n-\t\t destructor, so we don't complain about the 'resource\n-\t\t allocation is initialization' idiom.  */\n-\t      /* Now set attribute((unused)) on types so decls of\n-\t\t that type will be marked used. (see TREE_USED, above.) \n-\t\t This avoids the warning problems this particular code\n-\t\t tried to work around. */\n-\n-\t      if (TYPE_NEEDS_CONSTRUCTING (type)\n-\t\t  && ! already_used\n-\t\t  && cleanup == NULL_TREE\n-\t\t  && DECL_NAME (decl))\n-\t\tTREE_USED (decl) = 0;\n-\n-\t      if (already_used)\n-\t\tTREE_USED (decl) = 1;\n-\t    }\n-\n-\t  /* Cleanup any temporaries needed for the initial value.  */\n-\t  expand_end_target_temps ();\n-\n-\t  if (DECL_SIZE (decl) && type != error_mark_node)\n-\t    {\n-\t      /* Store the cleanup, if there was one.  */\n-\t      if (cleanup)\n-\t\t{\n-\t\t  if (! expand_decl_cleanup (decl, cleanup))\n-\t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n-\t\t\t      decl);\n-\t\t}\n-\t    }\n+\t  maybe_inject_for_scope_var (decl);\n+\t  initialize_local_var (decl, init, cleanup, flags);\n \t}\n     finish_end0:\n \n@@ -8035,12 +8160,10 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     }\n \n   if (need_pop)\n-    {\n-      /* Resume permanent allocation, if not within a function.  */\n-      /* The corresponding push_obstacks_nochange is in start_decl,\n-\t start_method, groktypename, and in grokfield.  */\n-      pop_obstacks ();\n-    }\n+    /* Resume permanent allocation, if not within a function.  The\n+       corresponding push_obstacks_nochange is in start_decl,\n+       start_method, groktypename, and in grokfield.  */\n+    pop_obstacks ();\n \n   if (was_readonly)\n     TREE_READONLY (decl) = 1;"}, {"sha": "e41d450046aabe717b9f6b8230644a9a9eabb268", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27778b739c3893b3aa6295e21c698aad2f7b5934/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27778b739c3893b3aa6295e21c698aad2f7b5934/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=27778b739c3893b3aa6295e21c698aad2f7b5934", "patch": "@@ -7167,16 +7167,26 @@ comp_ptr_ttypes_reinterpret (to, from)\n     }\n }\n \n-/* Returns the type-qualifier set corresponding to TYPE.  */\n+/* Recursively examines the array elements of TYPE, until a non-array\n+   element type is found.  */\n \n-int\n-cp_type_quals (type)\n+tree\n+strip_array_types (type)\n      tree type;\n {\n   while (TREE_CODE (type) == ARRAY_TYPE)\n     type = TREE_TYPE (type);\n \n-  return TYPE_QUALS (type);\n+  return type;\n+}\n+\n+/* Returns the type-qualifier set corresponding to TYPE.  */\n+\n+int\n+cp_type_quals (type)\n+     tree type;\n+{\n+  return TYPE_QUALS (strip_array_types (type));\n }\n \n /* Returns non-zero if the TYPE contains a mutable member */"}]}