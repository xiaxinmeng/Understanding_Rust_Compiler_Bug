{"sha": "ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJjNDY0OTQwZGU3N2I4ZTIyZjk5ZDFlMmIxYTFhM2JmMjNlYjI0ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-11-18T12:46:08Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-18T12:46:08Z"}, "message": "libstdc++: Fix std::jthread bugs\n\nThe std::jthread::get_id() function was missing a return statement.\n\nThe is_invocable check needs to be done using decayed types, as they'll\nbe forwarded to std::invoke as rvalues.\n\nAlso reduce header dependencies for the <thread> header. We don't need\nto include <functional> for std::jthread because <bits/invoke.h> is\nalready included, which defines std::__invoke. We can also remove\n<bits/functexcept.h> which isn't used at all. Finally, when\n_GLIBCXX_HAS_GTHREADS is not defined there's no point including any\nother headers, since we're not going to define anything in <thread>\nanyway.\n\n\t* include/std/thread: Reduce header dependencies.\n\t(jthread::get_id()): Add missing return.\n\t(jthread::get_stop_token()): Avoid unnecessary stop_source temporary.\n\t(jthread::_S_create): Check is_invocable using decayed types. Add\n\tstatic assertion.\n\t* testsuite/30_threads/jthread/1.cc: Add dg-require-gthreads.\n\t* testsuite/30_threads/jthread/2.cc: Likewise.\n\t* testsuite/30_threads/jthread/3.cc: New test.\n\t* testsuite/30_threads/jthread/jthread.cc: Add missing directives for\n\tpthread and gthread support. Use VERIFY instead of assert.\n\nFrom-SVN: r278402", "tree": {"sha": "4d53deb7d80e5c8c96d81c3879c751e5cfdaacde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d53deb7d80e5c8c96d81c3879c751e5cfdaacde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b39526e0a34a41f916f80bcb45f2e1c64dcf763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b39526e0a34a41f916f80bcb45f2e1c64dcf763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b39526e0a34a41f916f80bcb45f2e1c64dcf763"}], "stats": {"total": 194, "additions": 130, "deletions": 64}, "files": [{"sha": "6f493120ef4f4622d72467fd18c03df5ecfd4424", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "patch": "@@ -1,5 +1,16 @@\n 2019-11-18  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/std/thread: Reduce header dependencies.\n+\t(jthread::get_id()): Add missing return.\n+\t(jthread::get_stop_token()): Avoid unnecessary stop_source temporary.\n+\t(jthread::_S_create): Check is_invocable using decayed types. Add\n+\tstatic assertion.\n+\t* testsuite/30_threads/jthread/1.cc: Add dg-require-gthreads.\n+\t* testsuite/30_threads/jthread/2.cc: Likewise.\n+\t* testsuite/30_threads/jthread/3.cc: New test.\n+\t* testsuite/30_threads/jthread/jthread.cc: Add missing directives for\n+\tpthread and gthread support. Use VERIFY instead of assert.\n+\n \t* include/bits/alloc_traits.h (allocator_traits::construct)\n \t(allocator_traits::destroy, allocator_traits::max_size): Add unused\n \tattributes to parameters that are not used in C++20."}, {"sha": "825ce4096fcfd0de4b3ba3a94b2cba417f4ad15d", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "patch": "@@ -35,23 +35,26 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#include <chrono>\n-#include <memory>\n-#include <tuple>\n-#include <cerrno>\n+#include <bits/c++config.h>\n+\n+#if defined(_GLIBCXX_HAS_GTHREADS)\n+#include <bits/gthr.h>\n+\n+#include <chrono> // std::chrono::*\n+#include <memory> // std::unique_ptr\n+#include <tuple>  // std::tuple\n \n #if __cplusplus > 201703L\n-#define __cpp_lib_jthread 201907L\n-#include <functional>\n-#include <stop_token>\n+# include <stop_token> // std::stop_source, std::stop_token, std::nostopstate\n #endif\n \n-#include <bits/functexcept.h>\n-#include <bits/functional_hash.h>\n-#include <bits/invoke.h>\n-#include <bits/gthr.h>\n+#ifdef _GLIBCXX_USE_NANOSLEEP\n+# include <cerrno>  // errno, EINTR\n+# include <time.h>  // nanosleep\n+#endif\n \n-#if defined(_GLIBCXX_HAS_GTHREADS)\n+#include <bits/functional_hash.h> // std::hash\n+#include <bits/invoke.h>\t  // std::__invoke\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -483,7 +486,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     [[nodiscard]] id\n     get_id() const noexcept\n     {\n-      _M_thread.get_id();\n+      return _M_thread.get_id();\n     }\n \n     [[nodiscard]] native_handle_type\n@@ -512,7 +515,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     bool request_stop() noexcept\n     {\n-      return get_stop_source().request_stop();\n+      return _M_stop_source.request_stop();\n     }\n \n     friend void swap(jthread& __lhs, jthread& __rhs) noexcept\n@@ -525,12 +528,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       static thread\n       _S_create(stop_source& __ssrc, _Callable&& __f, _Args&&... __args)\n       {\n-\tif constexpr(is_invocable_v<_Callable, stop_token, _Args...>)\n+\tif constexpr(is_invocable_v<decay_t<_Callable>, stop_token,\n+\t\t\t\t    decay_t<_Args>...>)\n \t  return thread{std::forward<_Callable>(__f), __ssrc.get_token(),\n \t\t\tstd::forward<_Args>(__args)...};\n \telse\n-\t  return thread{std::forward<_Callable>(__f),\n-\t\t\tstd::forward<_Args>(__args)...};\n+\t  {\n+\t    static_assert(is_invocable_v<decay_t<_Callable>,\n+\t\t\t\t\t decay_t<_Args>...>,\n+\t\t\t  \"std::thread arguments must be invocable after\"\n+\t\t\t  \" conversion to rvalues\");\n+\t    return thread{std::forward<_Callable>(__f),\n+\t\t\t  std::forward<_Args>(__args)...};\n+\t  }\n       }\n \n     stop_source _M_stop_source;\n@@ -539,9 +549,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif // __cpp_lib_jthread\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n-\n #endif // _GLIBCXX_HAS_GTHREADS\n-\n #endif // C++11\n-\n #endif // _GLIBCXX_THREAD"}, {"sha": "574c1f25dc3c694fca838cd82ee72b192c9b5a9f", "filename": "libstdc++-v3/testsuite/30_threads/jthread/1.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F1.cc?ref=ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "patch": "@@ -17,6 +17,7 @@\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do compile { target c++2a } }\n+// { dg-require-gthreads \"\" }\n \n #include <thread>\n "}, {"sha": "52413c8d2a3e6c1625575a52dfa0d04772d34bd3", "filename": "libstdc++-v3/testsuite/30_threads/jthread/2.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F2.cc?ref=ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "patch": "@@ -17,6 +17,7 @@\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do compile { target c++2a } }\n+// { dg-require-gthreads \"\" }\n \n #include <version>\n "}, {"sha": "e4a2fbb3620b2728bf8373f9c81482dd36dcc819", "filename": "libstdc++-v3/testsuite/30_threads/jthread/3.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F3.cc?ref=ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do compile { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <thread>\n+\n+struct RvalCallable\n+{\n+  void operator()() && { }\n+};\n+\n+void test01()\n+{\n+  RvalCallable r;\n+  std::jthread t(r);\n+}\n+\n+struct RvalCallableWithToken\n+{\n+  void operator()(std::stop_token) && { }\n+};\n+\n+void test02()\n+{\n+  RvalCallableWithToken r;\n+  std::jthread t(r);\n+}"}, {"sha": "aeb9f1f1b7f8c7da7886efbf1feb5421a6fd01bd", "filename": "libstdc++-v3/testsuite/30_threads/jthread/jthread.cc", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2Fjthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2Fjthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2Fjthread.cc?ref=ebc464940de77b8e22f99d1e2b1a1a3bf23eb24d", "patch": "@@ -15,25 +15,27 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-options \"-std=gnu++2a\" }\n-// { dg-do compile { target c++2a } }\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n \n #include <thread>\n #include <chrono>\n-#include <cassert>\n #include <atomic>\n+#include <testsuite_hooks.h>\n \n-using namespace::std::literals;\n+using namespace std::literals;\n \n //------------------------------------------------------\n \n void test_no_stop_token()\n {\n   // test the basic jthread API (not taking stop_token arg)\n \n-  assert(std::jthread::hardware_concurrency() == std::thread::hardware_concurrency()); \n+  VERIFY(std::jthread::hardware_concurrency() == std::thread::hardware_concurrency());\n   std::stop_token stoken;\n-  assert(!stoken.stop_possible());\n+  VERIFY(!stoken.stop_possible());\n   {\n     std::jthread::id t1ID{std::this_thread::get_id()};\n     std::atomic<bool> t1AllSet{false};\n@@ -47,12 +49,12 @@ void test_no_stop_token()\n     for (int i=0; !t1AllSet.load(); ++i) {\n       std::this_thread::sleep_for(10ms);\n     }\n-    assert(t1.joinable());\n-    assert(t1ID == t1.get_id());\n+    VERIFY(t1.joinable());\n+    VERIFY(t1ID == t1.get_id());\n     stoken = t1.get_stop_token();\n-    assert(!stoken.stop_requested());\n-  } \n-  assert(stoken.stop_requested());\n+    VERIFY(!stoken.stop_requested());\n+  }\n+  VERIFY(stoken.stop_requested());\n }\n \n //------------------------------------------------------\n@@ -63,8 +65,8 @@ void test_stop_token()\n \n   std::stop_source ssource;\n   std::stop_source origsource;\n-  assert(ssource.stop_possible());\n-  assert(!ssource.stop_requested());\n+  VERIFY(ssource.stop_possible());\n+  VERIFY(!ssource.stop_requested());\n   {\n     std::jthread::id t1ID{std::this_thread::get_id()};\n     std::atomic<bool> t1AllSet{false};\n@@ -83,34 +85,34 @@ void test_stop_token()\n       std::this_thread::sleep_for(10ms);\n     }\n     // and check all values:\n-    assert(t1.joinable());\n-    assert(t1ID == t1.get_id());\n+    VERIFY(t1.joinable());\n+    VERIFY(t1ID == t1.get_id());\n \n     std::this_thread::sleep_for(470ms);\n     origsource = std::move(ssource);\n     ssource = t1.get_stop_source();\n-    assert(!ssource.stop_requested());\n+    VERIFY(!ssource.stop_requested());\n     auto ret = ssource.request_stop();\n-    assert(ret);\n+    VERIFY(ret);\n     ret = ssource.request_stop();\n-    assert(!ret);\n-    assert(ssource.stop_requested());\n-    assert(!t1done.load());\n-    assert(!origsource.stop_requested());\n+    VERIFY(!ret);\n+    VERIFY(ssource.stop_requested());\n+    VERIFY(!t1done.load());\n+    VERIFY(!origsource.stop_requested());\n \n     std::this_thread::sleep_for(470ms);\n     origsource.request_stop();\n-  } \n-  assert(origsource.stop_requested());\n-  assert(ssource.stop_requested());\n+  }\n+  VERIFY(origsource.stop_requested());\n+  VERIFY(ssource.stop_requested());\n }\n \n //------------------------------------------------------\n \n void test_join()\n {\n   std::stop_source ssource;\n-  assert(ssource.stop_possible());\n+  VERIFY(ssource.stop_possible());\n   {\n     std::jthread t1([](std::stop_token stoken) {\n                       for (int i=0; !stoken.stop_requested(); ++i) {\n@@ -126,10 +128,10 @@ void test_join()\n                    });\n     // wait for all thread to finish:\n     t2.join();\n-    assert(!t2.joinable());\n-    assert(t1.joinable());\n+    VERIFY(!t2.joinable());\n+    VERIFY(t1.joinable());\n     t1.join();\n-    assert(!t1.joinable());\n+    VERIFY(!t1.joinable());\n   }\n }\n \n@@ -138,7 +140,7 @@ void test_join()\n void test_detach()\n {\n   std::stop_source ssource;\n-  assert(ssource.stop_possible());\n+  VERIFY(ssource.stop_possible());\n   std::atomic<bool> t1FinallyInterrupted{false};\n   {\n     std::jthread t0;\n@@ -152,8 +154,8 @@ void test_detach()\n                    t1ID = std::this_thread::get_id();\n                    t1InterruptToken = stoken;\n                    t1IsInterrupted = stoken.stop_requested();\n-                   assert(stoken.stop_possible());\n-                   assert(!stoken.stop_requested());\n+                   VERIFY(stoken.stop_possible());\n+                   VERIFY(!stoken.stop_requested());\n                    t1AllSet.store(true);\n                    for (int i=0; !stoken.stop_requested(); ++i) {\n                       std::this_thread::sleep_for(100ms);\n@@ -163,36 +165,35 @@ void test_detach()\n     for (int i=0; !t1AllSet.load(); ++i) {\n       std::this_thread::sleep_for(10ms);\n     }\n-    assert(!t0.joinable());\n-    assert(t1.joinable());\n-    assert(t1ID == t1.get_id());\n-    assert(t1IsInterrupted == false);\n-    assert(t1InterruptToken == t1.get_stop_source().get_token());\n+    VERIFY(!t0.joinable());\n+    VERIFY(t1.joinable());\n+    VERIFY(t1ID == t1.get_id());\n+    VERIFY(t1IsInterrupted == false);\n+    VERIFY(t1InterruptToken == t1.get_stop_source().get_token());\n     ssource = t1.get_stop_source();\n-    assert(t1InterruptToken.stop_possible());\n-    assert(!t1InterruptToken.stop_requested());\n+    VERIFY(t1InterruptToken.stop_possible());\n+    VERIFY(!t1InterruptToken.stop_requested());\n     t1.detach();\n-    assert(!t1.joinable());\n+    VERIFY(!t1.joinable());\n   }\n \n-  assert(!t1FinallyInterrupted.load());\n+  VERIFY(!t1FinallyInterrupted.load());\n   ssource.request_stop();\n-  assert(ssource.stop_requested());\n+  VERIFY(ssource.stop_requested());\n   for (int i=0; !t1FinallyInterrupted.load() && i < 100; ++i) {\n     std::this_thread::sleep_for(100ms);\n   }\n-  assert(t1FinallyInterrupted.load());\n+  VERIFY(t1FinallyInterrupted.load());\n }\n \n int main()\n {\n   std::set_terminate([](){\n-                       assert(false);\n+                       VERIFY(false);\n                      });\n \n   test_no_stop_token();\n   test_stop_token();\n   test_join();\n   test_detach();\n }\n-"}]}