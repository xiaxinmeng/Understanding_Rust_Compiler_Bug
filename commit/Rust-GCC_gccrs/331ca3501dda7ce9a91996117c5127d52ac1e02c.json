{"sha": "331ca3501dda7ce9a91996117c5127d52ac1e02c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMxY2EzNTAxZGRhN2NlOWE5MTk5NjExN2M1MTI3ZDUyYWMxZTAyYw==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@amelek.gda.pl", "date": "2002-05-26T20:19:32Z"}, "committer": {"name": "Marek Michalkiewicz", "email": "marekm@gcc.gnu.org", "date": "2002-05-26T20:19:32Z"}, "message": "avr-protos.h (avr_out_sbxx_branch): Declare.\n\n\n\t* config/avr/avr-protos.h (avr_out_sbxx_branch): Declare.\n\t* config/avr/avr.c (jump_over_one_insn_p): Take length of the\n\tbranch insn into account, do not assume 1.\n\t(avr_out_sbxx_branch): New function.  Optimize cases of skipping\n\tover single word insn.  Handle upper half of I/O space too.\n\t* config/avr/avr.md (*sbrx_branch): Use it.\n\t(*sbrx_and_branchhi, *sbrx_and_branchsi): Likewise.\n\t(*sbix_branch, *sbix_branch_bit7): Likewise.\n\t(*sbix_branch_tmp, *sbix_branch_tmp_bit7): New.\n\tUse RTL peepholes to optimize register operand sign tests.\n\nFrom-SVN: r53906", "tree": {"sha": "ea23f56fa9169a28bf2f05e88970c86fa1a79396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea23f56fa9169a28bf2f05e88970c86fa1a79396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/331ca3501dda7ce9a91996117c5127d52ac1e02c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/331ca3501dda7ce9a91996117c5127d52ac1e02c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/331ca3501dda7ce9a91996117c5127d52ac1e02c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/331ca3501dda7ce9a91996117c5127d52ac1e02c/comments", "author": null, "committer": null, "parents": [{"sha": "9059e33cbbb601ed3a7f36d62a4dc7600b72bc60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9059e33cbbb601ed3a7f36d62a4dc7600b72bc60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9059e33cbbb601ed3a7f36d62a4dc7600b72bc60"}], "stats": {"total": 374, "additions": 234, "deletions": 140}, "files": [{"sha": "7b8ba2d8a75824ffa77a0b8f2fc76d0dd16f0c58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331ca3501dda7ce9a91996117c5127d52ac1e02c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331ca3501dda7ce9a91996117c5127d52ac1e02c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=331ca3501dda7ce9a91996117c5127d52ac1e02c", "patch": "@@ -25,6 +25,19 @@\n \t(_cpp_parse_expr, reduce): Update to handle two-integers.\n \t* cpplib.c (_cpp_test_assertion): Back up on CPP_EOF.\n \n+2002-05-26  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n+\n+\t* config/avr/avr-protos.h (avr_out_sbxx_branch): Declare.\n+\t* config/avr/avr.c (jump_over_one_insn_p): Take length of the\n+\tbranch insn into account, do not assume 1.\n+\t(avr_out_sbxx_branch): New function.  Optimize cases of skipping\n+\tover single word insn.  Handle upper half of I/O space too.\n+\t* config/avr/avr.md (*sbrx_branch): Use it.\n+\t(*sbrx_and_branchhi, *sbrx_and_branchsi): Likewise.\n+\t(*sbix_branch, *sbix_branch_bit7): Likewise.\n+\t(*sbix_branch_tmp, *sbix_branch_tmp_bit7): New.\n+\tUse RTL peepholes to optimize register operand sign tests.\n+\n 2002-05-26  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n \n \t* config/avr/avr.c (avr_asm_only_p): New variable."}, {"sha": "3d0be48c80728dcf5775df98aac968b805d81ed5", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331ca3501dda7ce9a91996117c5127d52ac1e02c/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331ca3501dda7ce9a91996117c5127d52ac1e02c/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=331ca3501dda7ce9a91996117c5127d52ac1e02c", "patch": "@@ -98,6 +98,7 @@ extern const char * lshrsi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n \n extern void avr_output_bld PARAMS ((rtx operands[], int bit_nr));\n extern void avr_output_addr_vec_elt PARAMS ((FILE *stream, int value));\n+extern const char *avr_out_sbxx_branch PARAMS ((rtx insn, rtx operands[]));\n \n extern enum reg_class preferred_reload_class PARAMS ((rtx x,\n \t\t\t\t\t\t     enum reg_class class));"}, {"sha": "67e6d52114e47a9d49829760ae42f28f2f289586", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331ca3501dda7ce9a91996117c5127d52ac1e02c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331ca3501dda7ce9a91996117c5127d52ac1e02c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=331ca3501dda7ce9a91996117c5127d52ac1e02c", "patch": "@@ -5233,7 +5233,7 @@ jump_over_one_insn_p (insn, dest)\n \t\t      : dest);\n   int jump_addr = INSN_ADDRESSES (INSN_UID (insn));\n   int dest_addr = INSN_ADDRESSES (uid);\n-  return dest_addr - jump_addr == 2;\n+  return dest_addr - jump_addr == get_attr_length (insn) + 1;\n }\n \n /* Returns 1 if a value of mode MODE can be stored starting with hard\n@@ -5451,3 +5451,76 @@ avr_peep2_scratch_safe (scratch)\n     }\n   return 1;\n }\n+\n+/* Output a branch that tests a single bit of a register (QI, HI or SImode)\n+   or memory location in the I/O space (QImode only).\n+\n+   Operand 0: comparison operator (must be EQ or NE, compare bit to zero).\n+   Operand 1: register operand to test, or CONST_INT memory address.\n+   Operand 2: bit number (for QImode operand) or mask (HImode, SImode).\n+   Operand 3: label to jump to if the test is true.  */\n+\n+const char *\n+avr_out_sbxx_branch (insn, operands)\n+     rtx insn;\n+     rtx operands[];\n+{\n+  enum rtx_code comp = GET_CODE (operands[0]);\n+  int long_jump = (get_attr_length (insn) >= 4);\n+  int reverse = long_jump || jump_over_one_insn_p (insn, operands[3]);\n+\n+  if (comp == GE)\n+    comp = EQ;\n+  else if (comp == LT)\n+    comp = NE;\n+\n+  if (reverse)\n+    comp = reverse_condition (comp);\n+\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[1]) < 0x40)\n+\t{\n+\t  if (comp == EQ)\n+\t    output_asm_insn (AS2 (sbis,%1-0x20,%2), operands);\n+\t  else\n+\t    output_asm_insn (AS2 (sbic,%1-0x20,%2), operands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (AS2 (in,__tmp_reg__,%1-0x20), operands);\n+\t  if (comp == EQ)\n+\t    output_asm_insn (AS2 (sbrs,__tmp_reg__,%2), operands);\n+\t  else\n+\t    output_asm_insn (AS2 (sbrc,__tmp_reg__,%2), operands);\n+\t}\n+    }\n+  else  /* GET_CODE (operands[1]) == REG */\n+    {\n+      if (GET_MODE (operands[1]) == QImode)\n+\t{\n+\t  if (comp == EQ)\n+\t    output_asm_insn (AS2 (sbrs,%1,%2), operands);\n+\t  else\n+\t    output_asm_insn (AS2 (sbrc,%1,%2), operands);\n+\t}\n+      else  /* HImode or SImode */\n+\t{\n+\t  static char buf[] = \"sbrc %A1,0\";\n+\t  int bit_nr = exact_log2 (INTVAL (operands[2])\n+\t\t\t\t   & GET_MODE_MASK (GET_MODE (operands[1])));\n+\n+\t  buf[3] = (comp == EQ) ? 's' : 'c';\n+\t  buf[6] = 'A' + (bit_nr >> 3);\n+\t  buf[9] = '0' + (bit_nr & 7);\n+\t  output_asm_insn (buf, operands);\n+\t}\n+    }\n+\n+  if (long_jump)\n+    return (AS1 (rjmp,_PC_+4) CR_TAB\n+\t    AS1 (jmp,%3));\n+  if (!reverse)\n+    return AS1 (rjmp,%3);\n+  return \"\";\n+}"}, {"sha": "08a468aa40bce020210e5e30e5ea30f07fa5e6e3", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 146, "deletions": 139, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/331ca3501dda7ce9a91996117c5127d52ac1e02c/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/331ca3501dda7ce9a91996117c5127d52ac1e02c/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=331ca3501dda7ce9a91996117c5127d52ac1e02c", "patch": "@@ -1850,31 +1850,20 @@\n   \"\"\n   \"\")\n \n+;; Test a single bit in a QI/HI/SImode register.\n (define_insn \"*sbrx_branch\"\n   [(set (pc)\n         (if_then_else\n \t (match_operator 0 \"comparison_operator\"\n \t\t\t [(zero_extract\n \t\t\t   (match_operand:QI 1 \"register_operand\" \"r\")\n \t\t\t   (const_int 1)\n-\t\t\t   (match_operand 2 \"immediate_operand\" \"n\"))\n+\t\t\t   (match_operand 2 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n-  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\"\n-  \"* {\n-       int comp = ((get_attr_length (insn) == 4)\n-                   ? reverse_condition (GET_CODE (operands[0]))\n-                   : GET_CODE (operands[0]));\n-       if (comp == EQ)\n-         output_asm_insn (AS2 (sbrs,%1,%2), operands);\n-       else\n-         output_asm_insn (AS2 (sbrc,%1,%2), operands);\n-       if (get_attr_length (insn) != 4)\n-         return AS1 (rjmp,%3);\n-       return (AS1 (rjmp,_PC_+4) CR_TAB\n-               AS1 (jmp,%3));\n-     }\"\n+  \"GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE\"\n+  \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n \t\t\t   (le (minus (pc) (match_dup 3)) (const_int 2046)))\n@@ -1884,34 +1873,19 @@\n \t\t\t\t    (const_int 4))))\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"*sbrx_and_branchsi\"\n+(define_insn \"*sbrx_and_branchhi\"\n   [(set (pc)\n         (if_then_else\n \t (match_operator 0 \"comparison_operator\"\n-\t\t\t [(and:SI\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:SI 2 \"immediate_operand\" \"n\"))\n+\t\t\t [(and:HI\n+\t\t\t   (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:HI 2 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n   \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n-   && mask_one_bit_p(INTVAL (operands[2]))\"\n-  \"* {\n-       int comp = ((get_attr_length (insn) == 4)\n-                   ? reverse_condition (GET_CODE (operands[0]))\n-                   : GET_CODE (operands[0]));\n-       int bit = mask_one_bit_p(INTVAL (operands[2])) - 1;\n-       static char buf[] = \\\"sbrc %A1,0\\\";\n-       buf[3] = (comp == EQ ? 's' : 'c');\n-       buf[6] = bit / 8 + 'A';\n-       buf[9] = bit % 8 + '0';\n-       output_asm_insn (buf, operands);\n-\n-       if (get_attr_length (insn) != 4)\n-         return AS1 (rjmp,%3);\n-       return (AS1 (rjmp,_PC_+4) CR_TAB\n-               AS1 (jmp,%3));\n-     }\"\n+   && exact_log2 (INTVAL (operands[2]) & 0xffff) >= 0\"\n+  \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n \t\t\t   (le (minus (pc) (match_dup 3)) (const_int 2046)))\n@@ -1921,34 +1895,19 @@\n \t\t\t\t    (const_int 4))))\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"*sbrx_and_branchhi\"\n+(define_insn \"*sbrx_and_branchsi\"\n   [(set (pc)\n         (if_then_else\n \t (match_operator 0 \"comparison_operator\"\n-\t\t\t [(and:HI\n-\t\t\t   (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:HI 2 \"immediate_operand\" \"n\"))\n+\t\t\t [(and:SI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n   \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n-   && mask_one_bit_p(INTVAL (operands[2]))\"\n-  \"* {\n-       int comp = ((get_attr_length (insn) == 4)\n-                   ? reverse_condition (GET_CODE (operands[0]))\n-                   : GET_CODE (operands[0]));\n-       int bit = mask_one_bit_p(INTVAL (operands[2])) - 1;\n-       static char buf[] = \\\"sbrc %A1,0\\\";\n-       buf[3] = (comp == EQ ? 's' : 'c');\n-       buf[6] = bit / 8 + 'A';\n-       buf[9] = bit % 8 + '0';\n-       output_asm_insn (buf, operands);\n-\n-       if (get_attr_length (insn) != 4)\n-         return AS1 (rjmp,%3);\n-       return (AS1 (rjmp,_PC_+4) CR_TAB\n-               AS1 (jmp,%3));\n-     }\"\n+   && exact_log2 (INTVAL (operands[2]) & 0xffffffff) >= 0\"\n+  \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n \t\t\t   (le (minus (pc) (match_dup 3)) (const_int 2046)))\n@@ -1958,6 +1917,83 @@\n \t\t\t\t    (const_int 4))))\n    (set_attr \"cc\" \"clobber\")])\n \n+;; Convert sign tests to bit 7/15/31 tests that match the above insns.\n+(define_peephole2\n+  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set (pc) (if_then_else (eq (zero_extract (match_dup 0)\n+\t\t\t\t\t     (const_int 1)\n+\t\t\t\t\t     (const_int 7))\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_dup 1))\n+\t\t\t   (pc)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set (pc) (if_then_else (ne (zero_extract (match_dup 0)\n+\t\t\t\t\t     (const_int 1)\n+\t\t\t\t\t     (const_int 7))\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_dup 1))\n+\t\t\t   (pc)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set (pc) (if_then_else (eq (and:HI (match_dup 0) (const_int -32768))\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_dup 1))\n+\t\t\t   (pc)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set (pc) (if_then_else (ne (and:HI (match_dup 0) (const_int -32768))\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_dup 1))\n+\t\t\t   (pc)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set (pc) (if_then_else (eq (and:SI (match_dup 0) (match_dup 2))\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_dup 1))\n+\t\t\t   (pc)))]\n+  \"operands[2] = GEN_INT (0x80000000);\")\n+\n+(define_peephole2\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set (pc) (if_then_else (ne (and:SI (match_dup 0) (match_dup 2))\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_dup 1))\n+\t\t\t   (pc)))]\n+  \"operands[2] = GEN_INT (0x80000000);\")\n+\n ;; ************************************************************************\n ;; Implementation of conditional jumps here.\n ;;  Compare with 0 (test) jumps\n@@ -2258,6 +2294,7 @@\n   [(set_attr \"length\" \"1\")\n    (set_attr \"cc\" \"none\")])\n \n+;; Lower half of the I/O space - use sbic/sbis directly.\n (define_insn \"*sbix_branch\"\n   [(set (pc)\n \t(if_then_else\n@@ -2271,21 +2308,7 @@\n \t (pc)))]\n   \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n    && avr_io_address_p (operands[1], 1 + 0x20)\"\n-{\n-  enum rtx_code comp = GET_CODE (operands[0]);\n-  int reverse = (get_attr_length (insn) == 4);\n-\n-  if (reverse)\n-    comp = reverse_condition (comp);\n-  if (comp == EQ)\n-    output_asm_insn (AS2 (sbis,%1-0x20,%2), operands);\n-  else\n-    output_asm_insn (AS2 (sbic,%1-0x20,%2), operands);\n-  if (!reverse)\n-    return AS1 (rjmp,%3);\n-  return (AS1 (rjmp,_PC_+4) CR_TAB\n-\t  AS1 (jmp,%3));\n-}\n+  \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n \t\t\t   (le (minus (pc) (match_dup 3)) (const_int 2046)))\n@@ -2307,19 +2330,9 @@\n   \"(GET_CODE (operands[0]) == GE || GET_CODE (operands[0]) == LT)\n    && avr_io_address_p (operands[1], 1 + 0x20)\"\n {\n-  enum rtx_code comp = GET_CODE (operands[0]);\n-  int reverse = (get_attr_length (insn) == 4);\n-\n-  if (reverse)\n-    comp = reverse_condition (comp);\n-  if (comp == GE)\n-    output_asm_insn (AS2 (sbis,%1-0x20,7), operands);\n-  else\n-    output_asm_insn (AS2 (sbic,%1-0x20,7), operands);\n-  if (!reverse)\n-    return AS1 (rjmp,%2);\n-  return (AS1 (rjmp,_PC_+4) CR_TAB\n-\t  AS1 (jmp,%2));\n+  operands[3] = operands[2];\n+  operands[2] = GEN_INT (7);\n+  return avr_out_sbxx_branch (insn, operands);\n }\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 2)) (const_int -2046))\n@@ -2330,6 +2343,54 @@\n \t\t\t\t    (const_int 4))))\n    (set_attr \"cc\" \"clobber\")])\n \n+;; Upper half of the I/O space - read port to __tmp_reg__ and use sbrc/sbrs.\n+(define_insn \"*sbix_branch_tmp\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"comparison_operator\"\n+\t\t\t [(zero_extract\n+\t\t\t   (mem:QI (match_operand 1 \"const_int_operand\" \"n\"))\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand 2 \"const_int_operand\" \"n\"))\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n+   && avr_io_address_p (operands[1], 1) && INTVAL (operands[1]) >= 0x40\"\n+  \"* return avr_out_sbxx_branch (insn, operands);\"\n+  [(set (attr \"length\")\n+\t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n+\t\t\t   (le (minus (pc) (match_dup 3)) (const_int 2045)))\n+\t\t      (const_int 3)\n+\t\t      (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t    (const_int 3)\n+\t\t\t\t    (const_int 5))))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*sbix_branch_tmp_bit7\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"comparison_operator\"\n+\t\t\t [(mem:QI (match_operand 1 \"const_int_operand\" \"n\"))\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"(GET_CODE (operands[0]) == GE || GET_CODE (operands[0]) == LT)\n+   && avr_io_address_p (operands[1], 1) && INTVAL (operands[1]) >= 0x40\"\n+{\n+  operands[3] = operands[2];\n+  operands[2] = GEN_INT (7);\n+  return avr_out_sbxx_branch (insn, operands);\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (and (ge (minus (pc) (match_dup 2)) (const_int -2046))\n+\t\t\t   (le (minus (pc) (match_dup 2)) (const_int 2045)))\n+\t\t      (const_int 3)\n+\t\t      (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t    (const_int 3)\n+\t\t\t\t    (const_int 5))))\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; ************************* Peepholes ********************************\n \n (define_peephole\n@@ -2430,60 +2491,6 @@\n   return (AS1 (brcs,_PC_+4) CR_TAB\n           AS1 (jmp,%1));\n }\")\n-\t\t\t\t\t\n-(define_peephole\n-  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))\n-   (set (pc)\n-\t(if_then_else (lt (cc0) (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"jump_over_one_insn_p (insn, operands[1])\"\n-  \"sbrs %0,7\")\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))\n-   (set (pc)\n-\t(if_then_else (ge (cc0) (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"jump_over_one_insn_p (insn, operands[1])\"\n-  \"sbrc %0,7\")\n-\t\t\t\t\t\n-(define_peephole\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"\"))\n-   (set (pc)\n-\t(if_then_else (lt (cc0) (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"jump_over_one_insn_p (insn, operands[1])\"\n-  \"sbrs %B0,7\")\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"\"))\n-   (set (pc)\n-\t(if_then_else (ge (cc0) (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"jump_over_one_insn_p (insn, operands[1])\"\n-  \"sbrc %B0,7\")\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (pc)\n-\t(if_then_else (lt (cc0) (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"jump_over_one_insn_p (insn, operands[1])\"\n-  \"sbrs %D0,7\")\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (pc)\n-\t(if_then_else (ge (cc0) (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"jump_over_one_insn_p (insn, operands[1])\"\n-  \"sbrc %D0,7\")\n \n (define_peephole\n   [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))"}]}