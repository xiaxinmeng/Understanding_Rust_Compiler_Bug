{"sha": "c6150df67f5d7cb05a5784509d9158e0ecc471d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYxNTBkZjY3ZjVkN2NiMDVhNTc4NDUwOWQ5MTU4ZTBlY2M0NzFkOA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-02-14T17:26:59Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-02-14T17:26:59Z"}, "message": "make v850 use constraints.md\n\n\tmake v850 use constraints.md\n        * config/v850/constraints.md: New file.\n        * config/v850/v850.md: Include it.\n        * config/v850/predicates.md (reg_or_0_operand): Use\n        satisfies_constraint_G.\n        (special_symbolref_operand): Use satisfies_constraint_K.\n        * config/v850/v850.h (CONSTANT_ADDRESS_P): Use constraint_satisfied_p.\n        (GO_IF_LEGITIMATE_ADDRESS): Likewise.\n        (REG_CLASS_FROM_LETTER, INT_7_BITS, INT_8_BITS): Delete.\n        (CONST_OK_FOR_P, CONST_OK_FOR_LETTER_P): Delete.\n        (EXTRA_CONSTRAINT): Delete.\n        (CONST_OK_FOR_I, CONST_OK_FOR_J): Use insn_const_int_ok_for_constraint.\n        (CONST_OK_FOR_K, CONST_OK_FOR_L, CONST_OK_FOR_M): Likewise.\n        (CONST_OK_FOR_N, CONST_OK_FOR_O): Likewise.\n\nFrom-SVN: r170140", "tree": {"sha": "d074ad62bdf1f6a129a4e61a9d6dd25608148ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d074ad62bdf1f6a129a4e61a9d6dd25608148ec8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6150df67f5d7cb05a5784509d9158e0ecc471d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6150df67f5d7cb05a5784509d9158e0ecc471d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6150df67f5d7cb05a5784509d9158e0ecc471d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6150df67f5d7cb05a5784509d9158e0ecc471d8/comments", "author": null, "committer": null, "parents": [{"sha": "49f0e1ba4aa0eafe931e34a0876be7b8df58afde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49f0e1ba4aa0eafe931e34a0876be7b8df58afde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49f0e1ba4aa0eafe931e34a0876be7b8df58afde"}], "stats": {"total": 244, "additions": 144, "deletions": 100}, "files": [{"sha": "76d333971d69798151afdcd7260c8984b2c080de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6150df67f5d7cb05a5784509d9158e0ecc471d8", "patch": "@@ -1,3 +1,19 @@\n+2011-02-14  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+        * config/v850/constraints.md: New file.\n+        * config/v850/v850.md: Include it.\n+        * config/v850/predicates.md (reg_or_0_operand): Use\n+        satisfies_constraint_G.\n+        (special_symbolref_operand): Use satisfies_constraint_K.\n+        * config/v850/v850.h (CONSTANT_ADDRESS_P): Use constraint_satisfied_p.\n+        (GO_IF_LEGITIMATE_ADDRESS): Likewise.\n+        (REG_CLASS_FROM_LETTER, INT_7_BITS, INT_8_BITS): Delete.\n+        (CONST_OK_FOR_P, CONST_OK_FOR_LETTER_P): Delete.\n+        (EXTRA_CONSTRAINT): Delete.\n+        (CONST_OK_FOR_I, CONST_OK_FOR_J): Use insn_const_int_ok_for_constraint.\n+        (CONST_OK_FOR_K, CONST_OK_FOR_L, CONST_OK_FOR_M): Likewise.\n+        (CONST_OK_FOR_N, CONST_OK_FOR_O): Likewise.\n+\n 2011-02-14  Anatoly Sokolov  <aesok@post.ru>\n \n \tPR target/47696"}, {"sha": "eecdab3d4efca25244023aa8b367e2d7e8aad578", "filename": "gcc/config/v850/constraints.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2Fconfig%2Fv850%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2Fconfig%2Fv850%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fconstraints.md?ref=c6150df67f5d7cb05a5784509d9158e0ecc471d8", "patch": "@@ -0,0 +1,108 @@\n+;; Constraint definitions for V850.\n+;; Copyright (C) 2011 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_register_constraint \"e\" \"EVEN_REGS\"\n+  \"@internal\")\n+\n+;; Integer constraints.\n+(define_constraint \"I\"\n+  \"Integer constant 0.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"J\"\n+  \"A signed 5-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -16 && ival <= 15\")))\n+\n+(define_constraint \"K\"\n+  \"A signed 16-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32768 && ival <= 32767\")))\n+\n+(define_constraint \"L\"\n+  \"A valid constant for a movhi instruction.\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"(ival | 0x7fff0000) == 0x7fff0000\")\n+\t    (match_test \"(ival | 0x7fff0000) + 0x10000 == 0\"))))\n+\n+(define_constraint \"M\"\n+  \"An unsigned 16-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 65535\")))\n+\n+(define_constraint \"N\"\n+  \"An unsigned 5-bit immediate in shift instructions.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 31\")))\n+\n+(define_constraint \"O\"\n+  \"A signed 9-bit immediate for word multiply instructions.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -255 && ival <= 255\")))\n+\n+(define_constraint \"P\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"0\")))\n+\n+;; Floating-point constraints.\n+(define_constraint \"G\"\n+  \"A zero of some form.\"\n+  (and (match_code \"const_double\")\n+       (ior (match_test \"GET_MODE_CLASS (mode) == MODE_FLOAT\")\n+\t    (match_test \"GET_MODE_CLASS (mode) == MODE_INT\"))\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+(define_constraint \"H\"\n+  \"@internal\"\n+  (and (match_code \"const_double\")\n+       (match_test \"0\")))\n+\n+;;; Extra constraints.\n+(define_constraint \"Q\"\n+  \"A memory address that does not contain a symbol address.\"\n+  (and (match_code \"mem\")\n+       (match_test \"ep_memory_operand (op, mode, FALSE)\")))\n+\n+(define_constraint \"R\"\n+  \"@internal\"\n+  (match_test \"special_symbolref_operand (op, VOIDmode)\"))\n+\n+(define_constraint \"S\"\n+  \"@internal\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"!SYMBOL_REF_ZDA_P (op)\")))\n+\n+(define_constraint \"T\"\n+  \"@internal\"\n+  (match_test \"ep_memory_operand (op, mode, TRUE)\"))\n+\n+(define_constraint \"U\"\n+  \"@internal\"\n+  (ior (and (match_code \"symbol_ref\")\n+\t    (match_test \"SYMBOL_REF_ZDA_P (op)\"))\n+       (and (match_code \"const\")\n+\t    (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")\n+\t    (match_test \"GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\")\n+\t    (match_test \"SYMBOL_REF_ZDA_P (XEXP (XEXP (op, 0), 0))\"))))\n+\n+(define_constraint \"W\"\n+  \"@internal\"\n+  (match_test \"disp23_operand (op, VOIDmode)\"))"}, {"sha": "129f00d595f33f98327944c0d303047cb4607e84", "filename": "gcc/config/v850/predicates.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2Fconfig%2Fv850%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2Fconfig%2Fv850%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fpredicates.md?ref=c6150df67f5d7cb05a5784509d9158e0ecc471d8", "patch": "@@ -26,7 +26,7 @@\n     return INTVAL (op) == 0;\n \n   else if (GET_CODE (op) == CONST_DOUBLE)\n-    return CONST_DOUBLE_OK_FOR_G (op);\n+    return satisfies_constraint_G (op);\n \n   else\n     return register_operand (op, mode);\n@@ -129,8 +129,7 @@\n {\n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-      && CONST_OK_FOR_K (INTVAL (XEXP (XEXP (op, 0), 1))))\n+      && satisfies_constraint_K (XEXP (XEXP (op, 0), 1)))\n     op = XEXP (XEXP (op, 0), 0);\n \n   if (GET_CODE (op) == SYMBOL_REF)"}, {"sha": "892a34c6305bb41b87af2a78be42be4f782f4d99", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 17, "deletions": 97, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=c6150df67f5d7cb05a5784509d9158e0ecc471d8", "patch": "@@ -357,11 +357,6 @@ enum reg_class\n #define INDEX_REG_CLASS NO_REGS\n #define BASE_REG_CLASS  GENERAL_REGS\n \n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-       (C == 'e' ? EVEN_REGS : (NO_REGS))\n-\n /* Macros to check register numbers against specific register classes.  */\n \n /* These assume that REGNO is a hard or pseudo reg number.\n@@ -384,62 +379,22 @@ enum reg_class\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* The letters I, J, K, L, M, N, O, P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-\n-#define INT_7_BITS(VALUE) ((unsigned) (VALUE) + 0x40 < 0x80)\n-#define INT_8_BITS(VALUE) ((unsigned) (VALUE) + 0x80 < 0x100)\n-/* zero */\n-#define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n-/* 5-bit signed immediate */\n-#define CONST_OK_FOR_J(VALUE) ((unsigned) (VALUE) + 0x10 < 0x20)\n-/* 16-bit signed immediate */\n-#define CONST_OK_FOR_K(VALUE) ((unsigned) (VALUE) + 0x8000 < 0x10000)\n-/* valid constant for movhi instruction.  */\n-#define CONST_OK_FOR_L(VALUE) \\\n-  (((unsigned) ((int) (VALUE) >> 16) + 0x8000 < 0x10000) \\\n-   && CONST_OK_FOR_I ((VALUE & 0xffff)))\n-/* 16-bit unsigned immediate */\n-#define CONST_OK_FOR_M(VALUE) ((unsigned)(VALUE) < 0x10000)\n-/* 5-bit unsigned immediate in shift instructions */\n-#define CONST_OK_FOR_N(VALUE) ((unsigned) (VALUE) <= 31)\n-/* 9-bit signed immediate for word multiply instruction.  */\n-#define CONST_OK_FOR_O(VALUE) ((unsigned) (VALUE) + 0x100 < 0x200)\n-\n-#define CONST_OK_FOR_P(VALUE) 0\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n-   (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n-   (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n-   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : \\\n-   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : \\\n-   (C) == 'N' ? CONST_OK_FOR_N (VALUE) : \\\n-   (C) == 'O' ? CONST_OK_FOR_O (VALUE) : \\\n-   (C) == 'P' ? CONST_OK_FOR_P (VALUE) : \\\n-   0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself. \n-     \n-  `G' is a zero of some form.  */\n+/* Convenience wrappers around insn_const_int_ok_for_constraint.  */\n \n-#define CONST_DOUBLE_OK_FOR_G(VALUE)\t\t\t\t\t\\\n-  ((GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\t\t\\\n-    && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\t\\\n-   || (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_INT\t\t\t\\\n-       && CONST_DOUBLE_LOW (VALUE) == 0\t\t\t\t\t\\\n-       && CONST_DOUBLE_HIGH (VALUE) == 0))\n-\n-#define CONST_DOUBLE_OK_FOR_H(VALUE) 0\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((C) == 'G'   ? CONST_DOUBLE_OK_FOR_G (VALUE)\t\t\t\t\\\n-   : (C) == 'H' ? CONST_DOUBLE_OK_FOR_H (VALUE)\t\t\t\t\\\n-   : 0)\n+#define CONST_OK_FOR_I(VALUE) \\\n+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_I)\n+#define CONST_OK_FOR_J(VALUE) \\\n+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_J)\n+#define CONST_OK_FOR_K(VALUE) \\\n+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_K)\n+#define CONST_OK_FOR_L(VALUE) \\\n+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_L)\n+#define CONST_OK_FOR_M(VALUE) \\\n+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_M)\n+#define CONST_OK_FOR_N(VALUE) \\\n+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_N)\n+#define CONST_OK_FOR_O(VALUE) \\\n+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_O)\n \n \f\n /* Stack layout; function entry, exit and calling.  */\n@@ -623,9 +578,7 @@ struct cum_arg { int nbytes; int anonymous_args; };\n /* ??? This seems too exclusive.  May get better code by accepting more\n    possibilities here, in particular, should accept ZDA_NAME SYMBOL_REFs.  */\n \n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == CONST_INT\t\t\t\t\\\n-   && CONST_OK_FOR_K (INTVAL (X)))\n+#define CONSTANT_ADDRESS_P(X) constraint_satisfied_p (X, CONSTRAINT_K)\n \n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -666,39 +619,6 @@ struct cum_arg { int nbytes; int anonymous_args; };\n \n #endif\n \n-/* A C expression that defines the optional machine-dependent\n-   constraint letters that can be used to segregate specific types of\n-   operands, usually memory references, for the target machine.\n-   Normally this macro will not be defined.  If it is required for a\n-   particular target machine, it should return 1 if VALUE corresponds\n-   to the operand type represented by the constraint letter C.  If C\n-   is not defined as an extra constraint, the value returned should\n-   be 0 regardless of VALUE.\n-\n-   For example, on the ROMP, load instructions cannot have their\n-   output in r0 if the memory reference contains a symbolic address.\n-   Constraint letter `Q' is defined as representing a memory address\n-   that does *not* contain a symbolic address.  An alternative is\n-   specified with a `Q' constraint on the input and `r' on the\n-   output.  The next alternative specifies `m' on the input and a\n-   register class that does not include r0 on the output.  */\n-\n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n- ((C) == 'Q'   ? ep_memory_operand (OP, GET_MODE (OP), FALSE)\t\t\\\n-  : (C) == 'R' ? special_symbolref_operand (OP, VOIDmode)\t\t\\\n-  : (C) == 'S' ? (GET_CODE (OP) == SYMBOL_REF\t\t\t\t\\\n-\t\t  && !SYMBOL_REF_ZDA_P (OP))\t\t\t\t\\\n-  : (C) == 'T' ? ep_memory_operand (OP, GET_MODE (OP), TRUE)\t\t\\\n-  : (C) == 'U' ? ((GET_CODE (OP) == SYMBOL_REF\t\t\t\t\\\n-\t\t   && SYMBOL_REF_ZDA_P (OP))\t\t\t\t\\\n-\t\t  || (GET_CODE (OP) == CONST\t\t\t\t\\\n-\t\t      && GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n-\t\t      && GET_CODE (XEXP (XEXP (OP, 0), 0)) == SYMBOL_REF\\\n-\t\t      && SYMBOL_REF_ZDA_P (XEXP (XEXP (OP, 0), 0))))\t\\\n-  : (C) == 'W' ? (GET_CODE (OP) == CONST_INT                            \\\n-\t\t  && ((unsigned)(INTVAL (OP)) >= 0x8000)               \\\n-\t\t  && ((unsigned)(INTVAL (OP)) < 0x400000))              \\\n-  : 0)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n@@ -738,7 +658,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n      goto ADDR;\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n       && RTX_OK_FOR_BASE_P (XEXP (X, 0)) \t\t\t\t\\\n-      && (GET_CODE (XEXP (X,1)) == CONST_INT && CONST_OK_FOR_K (INTVAL(XEXP (X,1)) + GET_MODE_NUNITS(MODE) * UNITS_PER_WORD)) \\\n+      && constraint_satisfied_p (XEXP (X,1), CONSTRAINT_K)\t\t\\\n       && ((MODE == QImode || INTVAL (XEXP (X, 1)) % 2 == 0)\t\t\\\n \t   && CONST_OK_FOR_K (INTVAL (XEXP (X, 1)) \t\t\t\\\n                               + (GET_MODE_NUNITS (MODE) * UNITS_PER_WORD)))) \\"}, {"sha": "88e42c65e904849f482af18c203b00497b1c5ab9", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6150df67f5d7cb05a5784509d9158e0ecc471d8/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=c6150df67f5d7cb05a5784509d9158e0ecc471d8", "patch": "@@ -100,6 +100,7 @@\n \t\t\t \"nothing\")\n \n (include \"predicates.md\")\n+(include \"constraints.md\")\n \f\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS"}]}