{"sha": "ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNjNDJjMTRhN2IzYTlkZDRiMDRjNDJiNDlmNmRhMTVlOWM4Y2JmMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-05-20T10:31:38Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-05-20T10:31:38Z"}, "message": "call.c (any_strictly_viable): New.\n\n* call.c (any_strictly_viable): New.\n(build_new_op): Use it for COMPOUND_EXPR and ADDR_EXPRs.\n\nFrom-SVN: r53656", "tree": {"sha": "2506b41b0616abacfbb4980eaa13d6b8646898ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2506b41b0616abacfbb4980eaa13d6b8646898ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1/comments", "author": null, "committer": null, "parents": [{"sha": "c0fe508e8b201c7789a66f252609a0f9006acfe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0fe508e8b201c7789a66f252609a0f9006acfe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0fe508e8b201c7789a66f252609a0f9006acfe9"}], "stats": {"total": 37, "additions": 36, "deletions": 1}, "files": [{"sha": "0a48612777b2486fba5e908eb8f15953f2b4cf24", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1", "patch": "@@ -1,3 +1,8 @@\n+2002-05-20  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* call.c (any_strictly_viable): New.\n+\t(build_new_op): Use it for COMPOUND_EXPR and ADDR_EXPRs.\n+\n 2002-05-19  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* error.c (dump_type) [TYPEOF_TYPE]: Fix parenthesis printing."}, {"sha": "75fac88df7d7a09d08f2176334a43f4fcb15aa20", "filename": "gcc/cp/call.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ecc42c14a7b3a9dd4b04c42b49f6da15e9c8cbf1", "patch": "@@ -62,6 +62,7 @@ static void print_z_candidates PARAMS ((struct z_candidate *));\n static tree build_this PARAMS ((tree));\n static struct z_candidate * splice_viable PARAMS ((struct z_candidate *));\n static int any_viable PARAMS ((struct z_candidate *));\n+static int any_strictly_viable PARAMS ((struct z_candidate *));\n static struct z_candidate * add_template_candidate\n \tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, int,\n \t       unification_kind_t));\n@@ -2319,6 +2320,16 @@ any_viable (cands)\n   return 0;\n }\n \n+static int\n+any_strictly_viable (cands)\n+     struct z_candidate *cands;\n+{\n+  for (; cands; cands = cands->next)\n+    if (cands->viable == 1)\n+      return 1;\n+  return 0;\n+}\n+\n static struct z_candidate *\n splice_viable (cands)\n      struct z_candidate *cands;\n@@ -3228,6 +3239,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   enum tree_code code2 = NOP_EXPR;\n   tree templates = NULL_TREE;\n   tree conv;\n+  bool viable_candidates;\n \n   if (arg1 == error_mark_node\n       || arg2 == error_mark_node\n@@ -3392,7 +3404,25 @@ build_new_op (code, flags, arg1, arg2, arg3)\n       (candidates, code, code2, fnname, args, flags);\n   }\n \n-  if (! any_viable (candidates))\n+  switch (code)\n+    {\n+    case COMPOUND_EXPR:\n+    case ADDR_EXPR:\n+      /* For these, the built-in candidates set is empty\n+\t [over.match.oper]/3.  We don't want non-strict matches\n+\t because exact matches are always possible with built-in\n+\t operators.  The built-in candidate set for COMPONENT_REF\n+\t would be empty too, but since there are no such built-in\n+\t operators, we accept non-strict matches for them.  */\n+      viable_candidates = any_strictly_viable (candidates);\n+      break;\n+\n+    default:\n+      viable_candidates = any_viable (candidates);\n+      break;\n+    }      \n+\n+  if (! viable_candidates)\n     {\n       switch (code)\n \t{"}]}