{"sha": "4c12dc0556605578f4f35c4be27cff9fef28877b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMxMmRjMDU1NjYwNTU3OGY0ZjM1YzRiZTI3Y2ZmOWZlZjI4ODc3Yg==", "commit": {"author": {"name": "Sylvia Taylor", "email": "sylvia.taylor@arm.com", "date": "2019-07-09T09:28:09Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2019-07-09T09:28:09Z"}, "message": "[arm]: redefine aes patterns\n\nThis patch removes the arch-common aese/aesmc and aesd/aesimc fusions\n(i.e. aes fusion) implemented in the scheduling phase through the\naarch_crypto_can_dual function. The reason is due to observing\nundesired behaviour in cases such as:\n- when register allocation goes bad (e.g. extra movs)\n- aes operations with xor and zeroed keys among interleaved operations\n\nA more stable version should be provided by instead doing the aes fusion\nduring the combine pass. As such, new combine patterns have been added to\nenable this.\n\nThe second change is the aese and aesd patterns have been rewritten as\nencapsulating a xor operation. The purpose is to simplify the need of\nhaving additional combine patterns for cases like the ones below:\n\nFor AESE (though it also applies to AESD as both have a xor operation):\n\n    data = data ^ key;\n    data = vaeseq_u8(data, zero);\n    ---\n    veor        q1, q0, q1\n    aese.8      q1, q9\n\nShould mean and generate the same as:\n\n    data = vaeseq_u8(data, key);\n    ---\n    aese.8       q1, q0\n\n2019-07-09  Sylvia Taylor  <sylvia.taylor@arm.com>\n\n\t* config/arm/crypto.md:\n\t(crypto_<crypto_pattern>): Redefine aese/aesd pattern with xor.\n\t(crypto_<crypto_pattern>): Remove attribute enabled for aesmc.\n\t(crypto_<crypto_pattern>): Split CRYPTO_BINARY into 2 patterns.\n\t(*aarch32_crypto_aese_fused, *aarch32_crypto_aesd_fused): New.\n\t* config/arm/arm.c\n\t(aarch_macro_fusion_pair_p): Remove aes/aesmc fusion check.\n\t* config/arm/aarch-common-protos.h\n\t(aarch_crypto_can_dual_issue): Remove.\n\t* config/arm/aarch-common.c\n\t(aarch_crypto_can_dual_issue): Likewise.\n\t* config/arm/exynos-m1.md: Remove aese/aesmc fusion.\n\t* config/arm/cortex-a53.md: Likewise.\n\t* config/arm/cortex-a57.md: Likewise.\n\t* config/arm/iterators.md:\n\t(CRYPTO_BINARY): Redefine.\n\t(CRYPTO_UNARY): Removed.\n\t(CRYPTO_AES, CRYPTO_AESMC): New.\n\n\t* gcc.target/arm/aes-fuse-1.c: New.\n\t* gcc.target/arm/aes-fuse-2.c: New.\n\t* gcc.target/arm/aes_xor_combine.c: New.\n\nFrom-SVN: r273296", "tree": {"sha": "8f24bd0317594277b073819448676ca2c2d63b3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f24bd0317594277b073819448676ca2c2d63b3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c12dc0556605578f4f35c4be27cff9fef28877b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c12dc0556605578f4f35c4be27cff9fef28877b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c12dc0556605578f4f35c4be27cff9fef28877b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c12dc0556605578f4f35c4be27cff9fef28877b/comments", "author": null, "committer": null, "parents": [{"sha": "b52db15861e60f5ca82b63caabed6a00da98c7d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52db15861e60f5ca82b63caabed6a00da98c7d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52db15861e60f5ca82b63caabed6a00da98c7d7"}], "stats": {"total": 348, "additions": 269, "deletions": 79}, "files": [{"sha": "21d7c1c8498fd9d82265ced71f9ea38ee3c2ec59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -1,3 +1,24 @@\n+2019-07-09  Sylvia Taylor  <sylvia.taylor@arm.com>\n+\n+\t* config/arm/crypto.md:\n+\t(crypto_<crypto_pattern>): Redefine aese/aesd pattern with xor.\n+\t(crypto_<crypto_pattern>): Remove attribute enabled for aesmc.\n+\t(crypto_<crypto_pattern>): Split CRYPTO_BINARY into 2 patterns.\n+\t(*aarch32_crypto_aese_fused, *aarch32_crypto_aesd_fused): New.\n+\t* config/arm/arm.c\n+\t(aarch_macro_fusion_pair_p): Remove aes/aesmc fusion check.\n+\t* config/arm/aarch-common-protos.h\n+\t(aarch_crypto_can_dual_issue): Remove.\n+\t* config/arm/aarch-common.c\n+\t(aarch_crypto_can_dual_issue): Likewise.\n+\t* config/arm/exynos-m1.md: Remove aese/aesmc fusion.\n+\t* config/arm/cortex-a53.md: Likewise.\n+\t* config/arm/cortex-a57.md: Likewise.\n+\t* config/arm/iterators.md:\n+\t(CRYPTO_BINARY): Redefine.\n+\t(CRYPTO_UNARY): Removed.\n+\t(CRYPTO_AES, CRYPTO_AESMC): New.\n+\n 2019-07-09  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (struct vn_walk_cb_data): Add orig_ref member."}, {"sha": "3bf38a104f6941eec1ce88db7d6b6ceb7da0af92", "filename": "gcc/config/arm/aarch-common-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common-protos.h?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -24,7 +24,6 @@\n #define GCC_AARCH_COMMON_PROTOS_H\n \n extern int aarch_accumulator_forwarding (rtx_insn *, rtx_insn *);\n-extern int aarch_crypto_can_dual_issue (rtx_insn *, rtx_insn *);\n extern bool aarch_rev16_p (rtx);\n extern bool aarch_rev16_shleft_mask_imm_p (rtx, machine_mode);\n extern bool aarch_rev16_shright_mask_imm_p (rtx, machine_mode);"}, {"sha": "965a07a43e3129dd1743d4a79813a597feca0b71", "filename": "gcc/config/arm/aarch-common.c", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Faarch-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Faarch-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.c?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -31,46 +31,6 @@\n #include \"rtl-iter.h\"\n #include \"memmodel.h\"\n \n-/* In ARMv8-A there's a general expectation that AESE/AESMC\n-   and AESD/AESIMC sequences of the form:\n-\n-   AESE Vn, _\n-   AESMC Vn, Vn\n-\n-   will issue both instructions in a single cycle on super-scalar\n-   implementations.  This function identifies such pairs.  */\n-\n-int\n-aarch_crypto_can_dual_issue (rtx_insn *producer_insn, rtx_insn *consumer_insn)\n-{\n-  rtx producer_set, consumer_set;\n-  rtx producer_src, consumer_src;\n-\n-  producer_set = single_set (producer_insn);\n-  consumer_set = single_set (consumer_insn);\n-\n-  producer_src = producer_set ? SET_SRC (producer_set) : NULL;\n-  consumer_src = consumer_set ? SET_SRC (consumer_set) : NULL;\n-\n-  if (producer_src && consumer_src\n-      && GET_CODE (producer_src) == UNSPEC && GET_CODE (consumer_src) == UNSPEC\n-      && ((XINT (producer_src, 1) == UNSPEC_AESE\n-           && XINT (consumer_src, 1) == UNSPEC_AESMC)\n-          || (XINT (producer_src, 1) == UNSPEC_AESD\n-              && XINT (consumer_src, 1) == UNSPEC_AESIMC)))\n-  {\n-    unsigned int regno = REGNO (SET_DEST (producer_set));\n-\n-    /* Before reload the registers are virtual, so the destination of\n-       consumer_set doesn't need to match.  */\n-\n-    return (REGNO (SET_DEST (consumer_set)) == regno || !reload_completed)\n-\t    && REGNO (XVECEXP (consumer_src, 0, 0)) == regno;\n-  }\n-\n-  return 0;\n-}\n-\n /* Return TRUE if X is either an arithmetic shift left, or\n    is a multiplication by a power of two.  */\n bool"}, {"sha": "f42a7b1d4edb04f4a26617f9cda1730dcd7c393a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -30606,10 +30606,6 @@ aarch_macro_fusion_pair_p (rtx_insn* prev, rtx_insn* curr)\n   if (!arm_macro_fusion_p ())\n     return false;\n \n-  if (current_tune->fusible_ops & tune_params::FUSE_AES_AESMC\n-      && aarch_crypto_can_dual_issue (prev, curr))\n-    return true;\n-\n   if (current_tune->fusible_ops & tune_params::FUSE_MOVW_MOVT\n       && arm_sets_movw_movt_fusible_p (prev_set, curr_set))\n     return true;"}, {"sha": "2d96a9cdd5a0d8a4533d0265e557e71fb2eb9427", "filename": "gcc/config/arm/cortex-a57.md", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Fcortex-a57.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Fcortex-a57.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-a57.md?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -801,9 +801,3 @@\n ;; help.\n (define_bypass 1 \"cortex_a57_*\"\n \t\t \"cortex_a57_call,cortex_a57_branch\")\n-\n-;; AESE+AESMC and AESD+AESIMC pairs forward with zero latency\n-(define_bypass 0 \"cortex_a57_crypto_simple\"\n-\t\t \"cortex_a57_crypto_simple\"\n-\t\t \"aarch_crypto_can_dual_issue\")\n-"}, {"sha": "bf34f69fc75c4b16dd947a7fe48728a97a319abf", "filename": "gcc/config/arm/crypto.md", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Fcrypto.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Fcrypto.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcrypto.md?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -19,33 +19,76 @@\n ;; <http://www.gnu.org/licenses/>.\n \n \n-;; When AES/AESMC fusion is enabled we want the register allocation to\n-;; look like:\n-;;    AESE Vn, _\n-;;    AESMC Vn, Vn\n-;; So prefer to tie operand 1 to operand 0 when fusing.\n-\n (define_insn \"crypto_<crypto_pattern>\"\n-  [(set (match_operand:<crypto_mode> 0 \"register_operand\" \"=w,w\")\n-        (unspec:<crypto_mode> [(match_operand:<crypto_mode> 1\n-                       \"register_operand\" \"0,w\")]\n-         CRYPTO_UNARY))]\n+  [(set (match_operand:<crypto_mode> 0 \"register_operand\" \"=w\")\n+\t(unspec:<crypto_mode>\n+\t\t[(match_operand:<crypto_mode> 1 \"register_operand\" \"w\")]\n+\t CRYPTO_AESMC))]\n   \"TARGET_CRYPTO\"\n   \"<crypto_pattern>.<crypto_size_sfx>\\\\t%q0, %q1\"\n-  [(set_attr \"type\" \"<crypto_type>\")\n-   (set_attr_alternative \"enabled\"\n-     [(if_then_else (match_test\n-\t\t       \"arm_fusion_enabled_p (tune_params::FUSE_AES_AESMC)\")\n-\t\t     (const_string \"yes\" )\n-\t\t     (const_string \"no\"))\n-      (const_string \"yes\")])]\n+  [(set_attr \"type\" \"<crypto_type>\")]\n+)\n+\n+(define_insn \"crypto_<crypto_pattern>\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=w\")\n+\t(unspec:V16QI\n+\t\t[(xor:V16QI\n+\t\t     (match_operand:V16QI 1 \"register_operand\" \"%0\")\n+\t\t     (match_operand:V16QI 2 \"register_operand\" \"w\"))]\n+\tCRYPTO_AES))]\n+  \"TARGET_CRYPTO\"\n+  \"<crypto_pattern>.<crypto_size_sfx>\\\\t%q0, %q2\"\n+  [(set_attr \"type\" \"<crypto_type>\")]\n+)\n+\n+;; When AESE/AESMC fusion is enabled we really want to keep the two together\n+;; and enforce the register dependency without scheduling or register\n+;; allocation messing up the order or introducing moves inbetween.\n+;;  Mash the two together during combine.\n+\n+(define_insn \"*aarch32_crypto_aese_fused\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=w\")\n+\t(unspec:V16QI\n+\t\t[(unspec:V16QI\n+\t\t    [(xor:V16QI\n+\t\t\t(match_operand:V16QI 1 \"register_operand\" \"%0\")\n+\t\t\t(match_operand:V16QI 2 \"register_operand\" \"w\"))]\n+\t\tUNSPEC_AESE)]\n+\tUNSPEC_AESMC))]\n+  \"TARGET_CRYPTO\n+   && arm_fusion_enabled_p (tune_params::FUSE_AES_AESMC)\"\n+  \"aese.8\\\\t%q0, %q2\\;aesmc.8\\\\t%q0, %q0\"\n+  [(set_attr \"type\" \"crypto_aese\")\n+   (set_attr \"length\" \"8\")]\n+)\n+\n+;; When AESD/AESIMC fusion is enabled we really want to keep the two together\n+;; and enforce the register dependency without scheduling or register\n+;; allocation messing up the order or introducing moves inbetween.\n+;;  Mash the two together during combine.\n+\n+(define_insn \"*aarch32_crypto_aesd_fused\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=w\")\n+\t(unspec:V16QI\n+\t\t[(unspec:V16QI\n+\t\t    [(xor:V16QI\n+\t\t\t(match_operand:V16QI 1 \"register_operand\" \"%0\")\n+\t\t\t(match_operand:V16QI 2 \"register_operand\" \"w\"))]\n+\t\tUNSPEC_AESD)]\n+\tUNSPEC_AESIMC))]\n+  \"TARGET_CRYPTO\n+   && arm_fusion_enabled_p (tune_params::FUSE_AES_AESMC)\"\n+  \"aesd.8\\\\t%q0, %q2\\;aesimc.8\\\\t%q0, %q0\"\n+  [(set_attr \"type\" \"crypto_aese\")\n+   (set_attr \"length\" \"8\")]\n )\n \n (define_insn \"crypto_<crypto_pattern>\"\n   [(set (match_operand:<crypto_mode> 0 \"register_operand\" \"=w\")\n-        (unspec:<crypto_mode> [(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")\n-                      (match_operand:<crypto_mode> 2 \"register_operand\" \"w\")]\n-         CRYPTO_BINARY))]\n+\t(unspec:<crypto_mode>\n+\t\t[(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")\n+\t\t(match_operand:<crypto_mode> 2 \"register_operand\" \"w\")]\n+\tCRYPTO_BINARY))]\n   \"TARGET_CRYPTO\"\n   \"<crypto_pattern>.<crypto_size_sfx>\\\\t%q0, %q2\"\n   [(set_attr \"type\" \"<crypto_type>\")]"}, {"sha": "150ac85ebc7dad0c0028a35a8851bef66a997642", "filename": "gcc/config/arm/exynos-m1.md", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Fexynos-m1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Fexynos-m1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fexynos-m1.md?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -950,11 +950,6 @@\n \t\t \"exynos_m1_crypto_simple, exynos_m1_crypto_complex,\\\n \t\t  exynos_m1_crypto_poly*\")\n \n-;; AES{D,E}/AESMC pairs can feed each other instantly.\n-(define_bypass 0 \"exynos_m1_crypto_simple\"\n-\t\t \"exynos_m1_crypto_simple\"\n-\t\t \"aarch_crypto_can_dual_issue\")\n-\n ;; Predicted branches take no time, but mispredicted ones take forever anyway.\n (define_bypass 1 \"exynos_m1_*\"\n \t\t \"exynos_m1_call, exynos_m1_branch\")"}, {"sha": "e03a7202417586808f6033864432bc77e63d746f", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -413,10 +413,11 @@\n (define_int_iterator CRC [UNSPEC_CRC32B UNSPEC_CRC32H UNSPEC_CRC32W\n                           UNSPEC_CRC32CB UNSPEC_CRC32CH UNSPEC_CRC32CW])\n \n-(define_int_iterator CRYPTO_UNARY [UNSPEC_AESMC UNSPEC_AESIMC])\n+(define_int_iterator CRYPTO_AESMC [UNSPEC_AESMC UNSPEC_AESIMC])\n \n-(define_int_iterator CRYPTO_BINARY [UNSPEC_AESD UNSPEC_AESE\n-                                    UNSPEC_SHA1SU1 UNSPEC_SHA256SU0])\n+(define_int_iterator CRYPTO_AES [UNSPEC_AESD UNSPEC_AESE])\n+\n+(define_int_iterator CRYPTO_BINARY [UNSPEC_SHA1SU1 UNSPEC_SHA256SU0])\n \n (define_int_iterator CRYPTO_TERNARY [UNSPEC_SHA1SU0 UNSPEC_SHA256H\n                                      UNSPEC_SHA256H2 UNSPEC_SHA256SU1])"}, {"sha": "995076b34d1abf77329d6a82cfbbcab0e89e9423", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -1,3 +1,9 @@\n+2019-07-09  Sylvia Taylor  <sylvia.taylor@arm.com>\n+\n+\t* gcc.target/arm/aes-fuse-1.c: New.\n+\t* gcc.target/arm/aes-fuse-2.c: New.\n+\t* gcc.target/arm/aes_xor_combine.c: New.\n+\n 2019-07-09  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/predict-17.c: Test loop optimizer assumption"}, {"sha": "27b08aeef7ba7c9fc8b5cbebcbcbf576ca88f064", "filename": "gcc/testsuite/gcc.target/arm/aes-fuse-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes-fuse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes-fuse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes-fuse-1.c?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_crypto_ok } */\n+/* { dg-add-options arm_crypto } */\n+/* { dg-additional-options \"-mcpu=cortex-a72 -O3 -dp\" } */\n+\n+#include <arm_neon.h>\n+\n+#define AESE(r, v, key) (r = vaeseq_u8 ((v), (key)));\n+#define AESMC(r, i) (r = vaesmcq_u8 (i))\n+\n+const uint8x16_t zero = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+\n+uint8x16_t dummy;\n+uint8x16_t a;\n+uint8x16_t b;\n+uint8x16_t c;\n+uint8x16_t d;\n+uint8x16_t x;\n+uint8x16_t y;\n+uint8x16_t k;\n+\n+void foo (void)\n+{\n+  AESE (a, a, k);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESE (b, b, k);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESE (c, c, k);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESE (d, d, k);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+\n+  x = x ^ k;\n+  AESE (x, x, zero);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  y = y ^ k;\n+  AESE (y, y, zero);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+\n+  AESMC (d, d);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESMC (c, c);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESMC (b, b);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESMC (a, a);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+\n+  AESMC (y, y);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESMC (x, x);\n+}\n+\n+/* { dg-final { scan-assembler-times \"crypto_aese_fused\" 6 } } */\n+/* { dg-final { scan-assembler-not \"veor\" } } */"}, {"sha": "1266a287531691f84d80c62d3e1e70915aff9668", "filename": "gcc/testsuite/gcc.target/arm/aes-fuse-2.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes-fuse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes-fuse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes-fuse-2.c?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_crypto_ok } */\n+/* { dg-add-options arm_crypto } */\n+/* { dg-additional-options \"-mcpu=cortex-a72 -O3 -dp\" } */\n+\n+#include <arm_neon.h>\n+\n+#define AESD(r, v, key) (r = vaesdq_u8 ((v), (key)));\n+#define AESIMC(r, i) (r = vaesimcq_u8 (i))\n+\n+const uint8x16_t zero = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+\n+uint8x16_t dummy;\n+uint8x16_t a;\n+uint8x16_t b;\n+uint8x16_t c;\n+uint8x16_t d;\n+uint8x16_t x;\n+uint8x16_t y;\n+uint8x16_t k;\n+\n+void foo (void)\n+{\n+  AESD (a, a, k);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESD (b, b, k);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESD (c, c, k);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESD (d, d, k);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+\n+  x = x ^ k;\n+  AESD (x, x, zero);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  y = y ^ k;\n+  AESD (y, y, zero);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+\n+  AESIMC (d, d);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESIMC (c, c);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESIMC (b, b);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESIMC (a, a);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+\n+  AESIMC (y, y);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  dummy = vaddq_u8 (dummy, dummy);\n+  AESIMC (x, x);\n+}\n+\n+/* { dg-final { scan-assembler-times \"crypto_aesd_fused\" 6 } } */\n+/* { dg-final { scan-assembler-not \"veor\" } } */"}, {"sha": "17ae1c53e4a9bcb0bd439fd504ceafda4496d809", "filename": "gcc/testsuite/gcc.target/arm/aes_xor_combine.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes_xor_combine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c12dc0556605578f4f35c4be27cff9fef28877b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes_xor_combine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faes_xor_combine.c?ref=4c12dc0556605578f4f35c4be27cff9fef28877b", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_crypto_ok } */\n+/* { dg-add-options arm_crypto } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <arm_neon.h>\n+\n+#define AESE(r, v, key) (r = vaeseq_u8 ((v), (key)));\n+#define AESD(r, v, key) (r = vaesdq_u8 ((v), (key)));\n+\n+const uint8x16_t zero = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+\n+uint8x16_t foo_key_0 (uint8x16_t dummy, uint8x16_t foo, uint8x16_t bar)\n+{\n+    dummy = dummy ^ foo;\n+    AESE(dummy, dummy, zero);\n+    dummy = dummy ^ bar;\n+    AESE(dummy, dummy, zero);\n+\n+    dummy = dummy ^ foo;\n+    AESD(dummy, dummy, zero);\n+    dummy = dummy ^ bar;\n+    AESD(dummy, dummy, zero);\n+\n+    return dummy;\n+}\n+\n+uint8x16_t foo_data_0 (uint8x16_t dummy, uint8x16_t foo, uint8x16_t bar)\n+{\n+    dummy = dummy ^ foo;\n+    AESE(dummy, zero, dummy);\n+    dummy = dummy ^ bar;\n+    AESE(dummy, zero, dummy);\n+\n+    dummy = dummy ^ foo;\n+    AESD(dummy, zero, dummy);\n+    dummy = dummy ^ bar;\n+    AESD(dummy, zero, dummy);\n+\n+    return dummy;\n+}\n+\n+/* { dg-final { scan-assembler-not \"veor\" } } */"}]}