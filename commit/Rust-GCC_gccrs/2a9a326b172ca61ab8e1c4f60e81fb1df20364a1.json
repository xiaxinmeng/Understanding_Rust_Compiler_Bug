{"sha": "2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE5YTMyNmIxNzJjYTYxYWI4ZTFjNGY2MGU4MWZiMWRmMjAzNjRhMQ==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-04-28T00:59:40Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-04-28T00:59:40Z"}, "message": "Makefile.in (OBJS): Add timevar.o.\n\nhangeLog:\n\n\t* Makefile.in (OBJS): Add timevar.o.\n\t(toplev.o): Depend on timevar.h.\n\t(ggc-simple.o): Likewise.\n\t(ggc-page.o): Likewise.\n\t(timevar.o): New rule.\n\t(timevar.h): New rule.\n\n\t* timevar.h: New file.\n\t* timevar.c: Likewise.\n\t* timevar.def: Likewise.\n\n\t* toplev.h (gc_time, parse_time, varconst_time): Remove.\n\t* toplev.c: Use timevar_push and timevar_pop instead of TIMEVAR\n\tthroughout.\n\t(TIMEVAR): Remove macro.\n\t(gc_time, parse_time, varconst_time, integration_time, jump_time,\n\tcse_time, gcse_time, loop_time, cse2_time, branch_prob_time,\n\tflow_time, combine_time, regmove_time, sched_time,\n\tlocal_alloc_time, global_alloc_time, flow2_time, peephole2_time,\n\tsched2_time, dbr_sched_time, reorder_blocks_time,\n\trename_registers_time, shorten_branch_time, stack_reg_time,\n\tto_ssa_time, from_ssa_time, final_time, symout_time, dump_time,\n\tall_time): Remove.\n\t(compile_file): Don't initialize time variables.  Call\n\tinit_timevar and start TV_TOTAL timer.  Call timevar_print instead\n\tof many calls to print_time.\n\t(rest_of_compilation): Add timing for reload_cse_regs.\n\t(get_run_time): Removed to timevar.c.\n\t(print_time): Likewise.\n\t(get_run_time): Implement using TV_TOTAL time variable.\n\t(print_time): Get total run time from get_run_time.\n\t* ggc-page.c (ggc_collect): Push and pop TV_GC instead of\n\tcomputing elapsed time explicitly.\n\t* ggc-simple.c (ggc_collect): Likewise.\n\t(gc_time): Remove declaration.\n\n\ncp/ChangeLog:\n\n\t* lex.c (my_get_run_time): Remove.\n\t(init_filename_times): Use get_run_time instead of my_get_run_time.\n\t(check_newline): Likewise.\n\t(dump_time_statistics): Likewise.\n\t* decl2.c (finish_file): Push and pop timevar TV_VARCONST instead\n\tof computing elapsed time explicitly.\n\nFrom-SVN: r33496", "tree": {"sha": "721fcd61f706b846a8cfad4302cec9e16abe799a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/721fcd61f706b846a8cfad4302cec9e16abe799a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/comments", "author": null, "committer": null, "parents": [{"sha": "e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e815887f4d7e3aaa8e68584729c18c9b3c5fef05"}], "stats": {"total": 1721, "additions": 1101, "deletions": 620}, "files": [{"sha": "35d7605fbbd593b9e7f32a46e86aba475ad2ea41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -1,3 +1,41 @@\n+2000-04-27  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* Makefile.in (OBJS): Add timevar.o.\n+\t(toplev.o): Depend on timevar.h.\n+\t(ggc-simple.o): Likewise.\n+\t(ggc-page.o): Likewise.\n+\t(timevar.o): New rule.\n+\t(timevar.h): New rule.\n+\n+\t* timevar.h: New file.\n+\t* timevar.c: Likewise.\n+\t* timevar.def: Likewise.\n+\n+\t* toplev.h (gc_time, parse_time, varconst_time): Remove.\n+\t* toplev.c: Use timevar_push and timevar_pop instead of TIMEVAR\n+\tthroughout.\n+\t(TIMEVAR): Remove macro.\n+\t(gc_time, parse_time, varconst_time, integration_time, jump_time,\n+\tcse_time, gcse_time, loop_time, cse2_time, branch_prob_time,\n+\tflow_time, combine_time, regmove_time, sched_time,\n+\tlocal_alloc_time, global_alloc_time, flow2_time, peephole2_time,\n+\tsched2_time, dbr_sched_time, reorder_blocks_time,\n+\trename_registers_time, shorten_branch_time, stack_reg_time,\n+\tto_ssa_time, from_ssa_time, final_time, symout_time, dump_time,\n+\tall_time): Remove.\n+\t(compile_file): Don't initialize time variables.  Call\n+\tinit_timevar and start TV_TOTAL timer.  Call timevar_print instead\n+\tof many calls to print_time.\n+\t(rest_of_compilation): Add timing for reload_cse_regs.\n+\t(get_run_time): Removed to timevar.c.\n+\t(print_time): Likewise.\n+\t(get_run_time): Implement using TV_TOTAL time variable.\n+\t(print_time): Get total run time from get_run_time. \n+\t* ggc-page.c (ggc_collect): Push and pop TV_GC instead of\n+\tcomputing elapsed time explicitly.\n+\t* ggc-simple.c (ggc_collect): Likewise.\n+\t(gc_time): Remove declaration.\n+\t\n 2000-04-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* calls.c (combine_pending_stack_adjustment_and_call): New function."}, {"sha": "e3c13f0b050214bed09f2b8dc080a175be01a8ec", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -684,7 +684,7 @@ OBJS = diagnostic.o \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o \\\n  predict.o lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o bb-reorder.o \\\n- sibcall.o conflict.o\n+ sibcall.o conflict.o timevar.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1470,10 +1470,10 @@ ggc-common.o: ggc-common.c $(CONFIG_H) $(RTL_H) $(TREE_H) \\\n \tflags.h $(GGC_H) varray.h hash.h\n \n ggc-simple.o: ggc-simple.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h \\\n-\t$(GGC_H) varray.h\n+\t$(GGC_H) varray.h timevar.h\n \n ggc-page.o: ggc-page.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h toplev.h \\\n-\t$(GGC_H) varray.h\n+\t$(GGC_H) varray.h timevar.h\n \n ggc-none.o: ggc-none.c $(CONFIG_H) $(RTL_H) $(GGC_H)\n \n@@ -1505,7 +1505,7 @@ toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) function.h \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n    insn-codes.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h dwarfout.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) $(BASIC_BLOCK_H) graph.h loop.h \\\n-   except.h regs.h $(lang_options_files)\n+   except.h regs.h timevar.h $(lang_options_files)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(MAYBE_USE_COLLECT2) \\\n \t  -DTARGET_NAME=\\\"$(target_alias)\\\" \\\n \t  -c `echo $(srcdir)/toplev.c | sed 's,^\\./,,'`\n@@ -1658,6 +1658,8 @@ lists.o: lists.c $(CONFIG_H) system.h toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) insn-flags.h function.h except.h $(EXPR_H)\n+timevar.o : timevar.c $(CONFIG_H) system.h timevar.h timevar.def\n+timevar.h : timevar.def\n \n regrename.o : regrename.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h \\"}, {"sha": "fdad42247fbe68806253f7163c6eaf329efe8ffb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -1,3 +1,12 @@\n+2000-04-27  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* lex.c (my_get_run_time): Remove.\n+\t(init_filename_times): Use get_run_time instead of my_get_run_time.\n+\t(check_newline): Likewise.\n+\t(dump_time_statistics): Likewise.\n+\t* decl2.c (finish_file): Push and pop timevar TV_VARCONST instead\n+\tof computing elapsed time explicitly.\n+\n 2000-04-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (TREE_READONLY_DECL_P): Use DECL_P."}, {"sha": "99473a88a09a9779007a9c537ab14f87a64c263e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -44,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"dwarf2out.h\"\n #include \"dwarfout.h\"\n #include \"ggc.h\"\n+#include \"timevar.h\"\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n@@ -3429,7 +3430,6 @@ generate_ctor_and_dtor_functions_for_priority (n, data)\n void\n finish_file ()\n {\n-  long start_time, this_time;\n   tree vars;\n   int reconsider;\n   size_t i;\n@@ -3463,7 +3463,7 @@ finish_file ()\n      generating the intiailzer for an object may cause templates to be\n      instantiated, etc., etc.  */\n \n-  start_time = get_run_time ();\n+  timevar_push (TV_VARCONST);\n \n   if (new_abi_rtti_p ())\n     emit_support_tinfos ();\n@@ -3686,9 +3686,7 @@ finish_file ()\n   if (back_end_hook)\n     (*back_end_hook) (global_namespace);\n \n-  this_time = get_run_time ();\n-  parse_time -= this_time - start_time;\n-  varconst_time += this_time - start_time;\n+  timevar_pop (TV_VARCONST);\n \n   if (flag_detailed_statistics)\n     {"}, {"sha": "ba32971d259052c00d292c476a085775877e7744", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n+#include \"timevar.h\"\n \n #ifdef MULTIBYTE_CHARS\n #include \"mbchar.h\"\n@@ -56,7 +57,6 @@ static int check_newline PARAMS ((void));\n static int whitespace_cr\t\tPARAMS ((int));\n static int skip_white_space PARAMS ((int));\n static void finish_defarg PARAMS ((void));\n-static int my_get_run_time PARAMS ((void));\n static int interface_strcmp PARAMS ((const char *));\n static int readescape PARAMS ((int *));\n static char *extend_token_buffer PARAMS ((const char *));\n@@ -388,17 +388,6 @@ get_time_identifier (name)\n     }\n   return time_identifier;\n }\n-\n-static inline int\n-my_get_run_time ()\n-{\n-  int old_quiet_flag = quiet_flag;\n-  int this_time;\n-  quiet_flag = 0;\n-  this_time = get_run_time ();\n-  quiet_flag = old_quiet_flag;\n-  return this_time;\n-}\n \f\n /* Table indexed by tree code giving a string containing a character\n    classifying the tree code.  Possibilities are\n@@ -488,7 +477,7 @@ init_filename_times ()\n   if (flag_detailed_statistics)\n     {\n       header_time = 0;\n-      body_time = my_get_run_time ();\n+      body_time = get_run_time ();\n       TREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (this_filename_time)) \n \t= body_time;\n     }\n@@ -2390,7 +2379,7 @@ check_newline ()\n      is charged against header time, and body time starts back at 0.  */\n   if (flag_detailed_statistics)\n     {\n-      int this_time = my_get_run_time ();\n+      int this_time = get_run_time ();\n       tree time_identifier = get_time_identifier (TREE_STRING_POINTER (yylval.ttype));\n       header_time += this_time - body_time;\n       TREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (this_filename_time))\n@@ -5086,7 +5075,7 @@ void\n dump_time_statistics ()\n {\n   register tree prev = 0, decl, next;\n-  int this_time = my_get_run_time ();\n+  int this_time = get_run_time ();\n   TREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (this_filename_time))\n     += this_time - body_time;\n "}, {"sha": "924e952b336781b431191714328bfffe5a38c47f", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"varray.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n+#include \"timevar.h\"\n \n #ifdef HAVE_MMAP_ANYWHERE\n #include <sys/mman.h>\n@@ -1101,8 +1102,6 @@ poison_pages ()\n void\n ggc_collect ()\n {\n-  long time;\n-\n   /* Avoid frequent unnecessary work by skipping collection if the\n      total allocations haven't expanded much since the last\n      collection.  */\n@@ -1111,7 +1110,7 @@ ggc_collect ()\n     return;\n #endif\n \n-  time = get_run_time ();\n+  timevar_push (TV_GC);\n   if (!quiet_flag)\n     fprintf (stderr, \" {GC %luk -> \", (unsigned long) G.allocated / 1024);\n \n@@ -1136,14 +1135,10 @@ ggc_collect ()\n   if (G.allocated_last_gc < GGC_MIN_LAST_ALLOCATED)\n     G.allocated_last_gc = GGC_MIN_LAST_ALLOCATED;\n \n-  time = get_run_time () - time;\n-  gc_time += time;\n+  timevar_pop (TV_GC);\n \n   if (!quiet_flag)\n-    {\n-      fprintf (stderr, \"%luk in %.3f}\", \n-\t       (unsigned long) G.allocated / 1024, time * 1e-6);\n-    }\n+    fprintf (stderr, \"%luk}\", (unsigned long) G.allocated / 1024);\n }\n \n /* Print allocation statistics.  */"}, {"sha": "b7b6a660bea976f68c6b2248b0e3c6e0fbe6b7cc", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -26,6 +26,7 @@\n #include \"flags.h\"\n #include \"varray.h\"\n #include \"ggc.h\"\n+#include \"timevar.h\"\n \n #ifndef offsetof\n #define offsetof(TYPE, MEMBER)\t((size_t) &((TYPE *)0)->MEMBER)\n@@ -58,7 +59,6 @@\n /* Constants for general use.  */\n \n char *empty_string;\n-extern int gc_time;\n \n #ifndef HOST_BITS_PER_PTR\n #define HOST_BITS_PER_PTR  HOST_BITS_PER_LONG\n@@ -339,8 +339,6 @@ sweep_objs (root)\n void\n ggc_collect ()\n {\n-  int time;\n-\n #ifndef GGC_ALWAYS_COLLECT\n   if (G.allocated < GGC_MIN_EXPAND_FOR_GC * G.allocated_last_gc)\n     return;\n@@ -350,7 +348,7 @@ ggc_collect ()\n   debug_ggc_balance ();\n #endif\n \n-  time = get_run_time ();\n+  timevar_push (TV_GC);\n   if (!quiet_flag)\n     fprintf (stderr, \" {GC %luk -> \", (unsigned long)G.allocated / 1024);\n \n@@ -365,14 +363,10 @@ ggc_collect ()\n   if (G.allocated_last_gc < GGC_MIN_LAST_ALLOCATED)\n     G.allocated_last_gc = GGC_MIN_LAST_ALLOCATED;\n \n-  time = get_run_time () - time;\n-  gc_time += time;\n+  timevar_pop (TV_GC);\n \n   if (!quiet_flag)\n-    {\n-      fprintf (stderr, \"%luk in %.3f}\", \n-\t       (unsigned long) G.allocated / 1024, time * 1e-6);\n-    }\n+    fprintf (stderr, \"%luk}\", (unsigned long) G.allocated / 1024);\n \n #ifdef GGC_BALANCE\n   debug_ggc_balance ();"}, {"sha": "61fc92d21ce84b8a1d5d146fa4b55ce62a781b5d", "filename": "gcc/timevar.c", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -0,0 +1,448 @@\n+/* Timing variables for measuring compiler performance.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Alex Samuel <samuel@codesourcery.com>\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#ifdef HAVE_SYS_TIMES_H\n+# include <sys/times.h>\n+#endif\n+\n+#include \"timevar.h\"\n+\n+/* See timevar.h for an explanation of timing variables.  */\n+\n+/* A timing variable.  */\n+\n+struct timevar_def\n+{\n+  /* Elapsed time for this variable.  */\n+  struct timevar_time_def elapsed;\n+\n+  /* If this variable is timed independently of the timing stack,\n+     using timevar_start, this contains the start time.  */\n+  struct timevar_time_def start_time;\n+\n+  /* Non-zero if this timing variable is running as a standalone\n+     timer.  */\n+  int standalone;\n+\n+  /* The name of this timing variable.  */\n+  const char *name;\n+};\n+\n+/* An element on the timing stack.  Elapsed time is attributed to the\n+   topmost timing variable on the stack.  */\n+\n+struct timevar_stack_def\n+{\n+  /* The timing variable at this stack level.  */\n+  struct timevar_def *timevar;\n+\n+  /* The next lower timing variable context in the stack.  */\n+  struct timevar_stack_def *next;\n+};\n+\n+/* Declared timing variables.  Constructed from the contents of\n+   timevar.def.  */\n+static struct timevar_def timevars[TIMEVAR_LAST];\n+\n+/* The top of the timing stack.  */\n+static struct timevar_stack_def *stack;\n+\n+/* The time at which the topmost element on the timing stack was\n+   pushed.  Time elapsed since then is attributed to the topmost\n+   element.  */\n+static struct timevar_time_def start_time;\n+\n+static void get_time\n+  PARAMS ((struct timevar_time_def *));\n+static void timevar_add\n+  PARAMS ((struct timevar_time_def *, struct timevar_time_def *));\n+static void timevar_accumulate\n+  PARAMS ((struct timevar_time_def *, struct timevar_time_def *, \n+\t   struct timevar_time_def *));\n+\n+/* Fill the current times into TIME.  The definition of this function\n+   also defines any or all of the HAVE_USER_TIME, HAVE_SYS_TIME, and\n+   HAVA_WALL_TIME macros.  */\n+\n+static void\n+get_time (time)\n+     struct timevar_time_def *time;\n+{\n+  time->user = 0;\n+  time->sys  = 0;\n+  time->wall = 0;\n+\n+#ifdef __BEOS__\n+  /* Nothing.  */\n+#else /* not BeOS */\n+#if defined (_WIN32) && !defined (__CYGWIN__)\n+  if (clock () >= 0)\n+    time->user = clock () * 1000;\n+#define HAVE_USER_TIME\n+\n+#else /* not _WIN32 */\n+#ifdef _SC_CLK_TCK\n+  {\n+    static int tick;\n+    struct tms tms;\n+    if (tick == 0)\n+      tick = 1000000 / sysconf (_SC_CLK_TCK);\n+    time->wall = times (&tms) * tick;\n+    time->user = tms.tms_utime * tick;\n+    time->sys = tms.tms_stime * tick;\n+  }\n+#define HAVE_USER_TIME\n+#define HAVE_SYS_TIME\n+#define HAVE_WALL_TIME\n+\n+#else\n+#ifdef USG\n+  {\n+    struct tms tms;\n+#   if HAVE_SYSCONF && defined _SC_CLK_TCK\n+#    define TICKS_PER_SECOND sysconf (_SC_CLK_TCK) /* POSIX 1003.1-1996 */\n+#   else\n+#    ifdef CLK_TCK\n+#     define TICKS_PER_SECOND CLK_TCK /* POSIX 1003.1-1988; obsolescent */\n+#    else\n+#     define TICKS_PER_SECOND HZ /* traditional UNIX */\n+#    endif\n+#   endif\n+    time->wall = times (&tms) * (1000000 / TICKS_PER_SECOND);\n+    time->user = tms.tms_utime * (1000000 / TICKS_PER_SECOND);\n+    time->sys = tms.tms_stime * (1000000 / TICKS_PER_SECOND);\n+  }\n+#define HAVE_USER_TIME\n+#define HAVE_SYS_TIME\n+#define HAVE_WALL_TIME\n+\n+#else\n+#ifndef VMS\n+  {\n+    struct rusage rusage;\n+    getrusage (0, &rusage);\n+    time->user \n+      = rusage.ru_utime.tv_sec * 1000000 + rusage.ru_utime.tv_usec;\n+    time->sys \n+      = rusage.ru_stime.tv_sec * 1000000 + rusage.ru_stime.tv_usec;\n+  }\n+#define HAVE_USER_TIME\n+#define HAVE_SYS_TIME\n+\n+#else /* VMS */\n+  {\n+    struct\n+      {\n+        int proc_user_time;\n+        int proc_system_time;\n+        int child_user_time;\n+        int child_system_time;\n+      } vms_times;\n+    time->wall = times ((void *) &vms_times) * 10000;\n+    time->user = vms_times.proc_user_time * 10000;\n+    time->sys = vms_times.proc_system_time * 10000;\n+  }\n+#define HAVE_USER_TIME\n+#define HAVE_SYS_TIME\n+#define HAVE_WALL_TIME\n+\n+#endif\t/* VMS */\n+#endif\t/* USG */\n+#endif  /* _SC_CLK_TCK */\n+#endif\t/* _WIN32 */\n+#endif\t/* __BEOS__ */\n+}  \n+\n+/* Add ELAPSED to TIMER.  */\n+\n+static void\n+timevar_add (timer, elapsed)\n+     struct timevar_time_def *timer;\n+     struct timevar_time_def *elapsed;\n+{\n+  timer->user += elapsed->user;\n+  timer->sys += elapsed->sys;\n+  timer->wall += elapsed->wall;\n+}\n+\n+/* Add the difference between STOP_TIME and START_TIME to TIMER.  */\n+\n+static void \n+timevar_accumulate (timer, start_time, stop_time)\n+  struct timevar_time_def *timer;\n+  struct timevar_time_def *start_time;\n+  struct timevar_time_def *stop_time;\n+{\n+  timer->user += stop_time->user - start_time->user;\n+  timer->sys += stop_time->sys - start_time->sys;\n+  timer->wall += stop_time->wall - start_time->wall;\n+}\n+\n+/* Initialize timing variables.  */\n+\n+void\n+init_timevar (void)\n+{\n+  /* Zero all elapsed times.  */\n+  memset ((void *) timevars, 0, sizeof (timevars));\n+\n+  /* Initialize the names of timing variables.  */\n+#define DEFTIMEVAR(identifer__, name__) \\\n+  timevars[identifer__].name = name__;\n+#include \"timevar.def\"\n+#undef DEFTIMEVAR\n+}\n+\n+/* Push TIMEVAR onto the timing stack.  No further elapsed time is\n+   attributed to the previous topmost timing variable on the stack;\n+   subsequent elapsed time is attributed to TIMEVAR, until it is\n+   popped or another element is pushed on top. \n+\n+   TIMEVAR cannot be running as a standalone timer.  */\n+\n+void\n+timevar_push (timevar)\n+     timevar_id_t timevar;\n+{\n+  struct timevar_def *tv = &timevars[timevar];\n+  struct timevar_stack_def *context;\n+  struct timevar_time_def now;\n+\n+  /* Can't push a standalone timer.  */\n+  if (tv->standalone)\n+    abort ();\n+\n+  /* What time is it?  */\n+  get_time (&now);\n+\n+  /* If the stack isn't empty, attribute the current elapsed time to\n+     the old topmost element.  */\n+  if (stack)\n+    timevar_accumulate (&stack->timevar->elapsed, &start_time, &now);\n+\n+  /* Reset the start time; from now on, time is attributed to\n+     TIMEVAR. */\n+  start_time = now;\n+\n+  /* Create a new stack element, and push it.  */\n+  context = (struct timevar_stack_def *) \n+    xmalloc (sizeof (struct timevar_stack_def));\n+  context->timevar = tv;\n+  context->next = stack;\n+  stack = context;\n+}\n+\n+/* Pop the topmost timing variable element off the timing stack.  The\n+   popped variable must be TIMEVAR.  Elapsed time since the that\n+   element was pushed on, or since it was last exposed on top of the\n+   stack when the element above it was popped off, is credited to that\n+   timing variable.  */\n+\n+void\n+timevar_pop (timevar)\n+     timevar_id_t timevar;\n+{\n+  struct timevar_time_def now;\n+  struct timevar_stack_def *next = stack->next;\n+\n+  if (&timevars[timevar] != stack->timevar)\n+    abort ();\n+\n+  /* What time is it?  */\n+  get_time (&now);\n+\n+  /* Attribute the elapsed time to the element we're popping.  */\n+  timevar_accumulate (&stack->timevar->elapsed, &start_time, &now);\n+\n+  /* Reset the start time; from now on, time is attributed to the\n+     element just exposed on the stack.  */\n+  start_time = now;\n+\n+  /* Remove the stack element.  */\n+  free (stack);\n+  stack = next;\n+}\n+\n+/* Start timing TIMEVAR independently of the timing stack.  Elapsed\n+   time until timevar_stop is called for the same timing variable is\n+   attributed to TIMEVAR.  */\n+\n+void\n+timevar_start (timevar)\n+     timevar_id_t timevar;\n+{\n+  struct timevar_def *tv = &timevars[timevar];\n+\n+  /* Don't allow the same timing variable to be started more than\n+     once.  */\n+  if (tv->standalone)\n+    abort ();\n+  tv->standalone = 1;\n+\n+  get_time (&tv->start_time);\n+}\n+\n+/* Stop timing TIMEVAR.  Time elapsed since timevar_start was called\n+   is attributed to it.  */\n+\n+void\n+timevar_stop (timevar)\n+     timevar_id_t timevar;\n+{\n+  struct timevar_def *tv = &timevars[timevar];\n+  struct timevar_time_def now;\n+\n+  /* TIMEVAR must have been started via timevar_start.  */\n+  if (!tv->standalone)\n+    abort ();\n+\n+  get_time (&now);\n+  timevar_accumulate (&tv->elapsed, &tv->start_time, &now);\n+}\n+\n+/* Fill the elapsed time for TIMEVAR into ELAPSED.  Returns\n+   update-to-date information even if TIMEVAR is currently running.  */\n+\n+void\n+timevar_get (timevar, elapsed)\n+     timevar_id_t timevar;\n+     struct timevar_time_def *elapsed;\n+{\n+  struct timevar_def *tv = &timevars[timevar];\n+\n+  *elapsed = tv->elapsed;\n+\n+  /* Is TIMEVAR currently running as a standalone timer?  */\n+  if (tv->standalone)\n+    /* Add the time elapsed since the it was started.  */\n+    timevar_add (elapsed, &tv->start_time);\n+\n+  /* Is TIMEVAR at the top of the timer stack?  */\n+  if (stack->timevar == tv)\n+    /* Add the elapsed time since it was pushed.  */\n+    timevar_add (elapsed, &start_time);\n+}\n+\n+/* Summarize timing variables to FP.  The timing variable TV_TOTAL has\n+   a special meaning -- it's considered to be the total elapsed time,\n+   for normalizing the others, and is displayed last.  */\n+\n+void\n+timevar_print (fp)\n+     FILE *fp;\n+{\n+  /* Only print stuff if we have some sort of time information.  */\n+#if defined (HAVE_USER_TIME) || defined (HAVE_SYS_TIME) || defined (HAVE_WALL_TIME)\n+  timevar_id_t id;\n+  struct timevar_time_def *total = &timevars[TV_TOTAL].elapsed;\n+\n+  fprintf (fp, \"\\nExecution times (seconds)\\n\");\n+  for (id = 0; id < TIMEVAR_LAST; ++id)\n+    {\n+      struct timevar_def *tv = &timevars[id];\n+\n+      /* Don't print the total execution time here; that goes at the\n+\t end.  */\n+      if (id == TV_TOTAL)\n+\tcontinue;\n+\n+      /* The timing variable name.  */\n+      fprintf (fp, \" %-22s:\", tv->name);\n+\n+#ifdef HAVE_USER_TIME\n+      /* Print user-mode time for this process.  */\n+      fprintf (fp, \"%4ld.%02ld (%2.0f%%) usr\", \n+\t       tv->elapsed.user / 1000000, \n+\t       (tv->elapsed.user % 1000000) / 10000,\n+\t       (total->user == 0) ? 0.0 \n+\t       : (100.0 * tv->elapsed.user / (double) total->user));\n+#endif /* HAVE_USER_TIME */\n+\n+#ifdef HAVE_SYS_TIME\n+      /* Print system-mode time for this process.  */\n+      fprintf (fp, \"%4ld.%02ld (%2.0f%%) sys\", \n+\t       tv->elapsed.sys / 1000000, \n+\t       (tv->elapsed.sys % 1000000) / 10000,\n+\t       (total->sys == 0) ? 0.0 \n+\t       : (100.0 * tv->elapsed.sys / (double) total->sys));\n+#endif /* HAVE_SYS_TIME */\n+\n+#ifdef HAVE_WALL_TIME\n+      /* Print wall clock time elapsed.  */\n+      fprintf (fp, \"%4ld.%02ld (%2.0f%%) wall\", \n+\t       tv->elapsed.wall / 1000000, \n+\t       (tv->elapsed.wall % 1000000) / 10000,\n+\t       (total->wall == 0) ? 0.0 \n+\t       : (100.0 * tv->elapsed.wall / (double) total->wall));\n+#endif /* HAVE_WALL_TIME */\n+\n+      fprintf (fp, \"\\n\");\n+    }\n+\n+  /* Print total time.  */\n+  fprintf (fp, \" TOTAL                 :\");\n+#ifdef HAVE_USER_TIME\n+  fprintf (fp, \"%4ld.%02ld          \", \n+\t   total->user / 1000000, (total->user % 1000000) / 10000);\n+#endif \n+#ifdef HAVE_SYS_TIME\n+  fprintf (fp, \"%4ld.%02ld          \", \n+\t   total->sys  / 1000000, (total->sys  % 1000000) / 10000);\n+#endif\n+#ifdef HAVE_WALL_TIME\n+  fprintf (fp, \"%4ld.%02ld\\n\",\n+\t   total->wall / 1000000, (total->wall % 1000000) / 10000);\n+#endif\n+  \n+#endif /* defined (HAVE_USER_TIME) || defined (HAVE_SYS_TIME) \n+\t  || defined (HAVE_WALL_TIME) */\n+}\n+\n+/* Returns time (user + system) used so far by the compiler process,\n+   in microseconds.  */\n+\n+long\n+get_run_time ()\n+{\n+  struct timevar_time_def total_elapsed;\n+  timevar_get (TV_TOTAL, &total_elapsed);\n+  return total_elapsed.user + total_elapsed.sys;\n+}\n+\n+/* Prints a message to stderr stating that time elapsed in STR is\n+   TOTAL (given in microseconds).  */\n+\n+void\n+print_time (str, total)\n+     const char *str;\n+     long total;\n+{\n+  long all_time = get_run_time ();\n+  fprintf (stderr,\n+\t   \"time in %s: %ld.%06ld (%ld%%)\\n\",\n+\t   str, total / 1000000, total % 1000000,\n+ \t   all_time == 0 ? 0\n+ \t   : (long) (((100.0 * (double) total) / (double) all_time) + .5));\n+}\n+"}, {"sha": "865d074df6ae00e73679534f88e4a3ccd55d5efe", "filename": "gcc/timevar.def", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -0,0 +1,73 @@\n+/* This file contains the definitions for timing variables used to\n+   measure run-time performance of the compiler.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Alex Samuel <samuel@codesourcery.com>\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* This file contains timing variable definitions, used by timevar.h\n+   and timevar.c.\n+\n+   Syntax:\n+\n+     DEFTIMEVAR (id, name)\n+\n+   where ID is the enumeral value used to identify the timing\n+   variable, and NAME is a character string describing its purpose.  */\n+\n+/* The total execution time.  */\n+DEFTIMEVAR (TV_TOTAL                 , \"total time\")\n+\n+/* Time spent garbage-collecting.  */\n+DEFTIMEVAR (TV_GC                    , \"garbage collection\")\n+\n+/* Time spent generating dump files.  */\n+DEFTIMEVAR (TV_DUMP                  , \"dump files\")\n+\n+/* Timing in various stages of the compiler.  */\n+DEFTIMEVAR (TV_PARSE                 , \"parser\")\n+DEFTIMEVAR (TV_VARCONST              , \"varconst\")\n+DEFTIMEVAR (TV_INTEGRATION           , \"integration\")\n+DEFTIMEVAR (TV_JUMP                  , \"jump\")\n+DEFTIMEVAR (TV_CSE                   , \"CSE\")\n+DEFTIMEVAR (TV_GCSE                  , \"global CSE\")\n+DEFTIMEVAR (TV_LOOP                  , \"loop analysis\")\n+DEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\n+DEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")\n+DEFTIMEVAR (TV_FLOW                  , \"flow analysis\")\n+DEFTIMEVAR (TV_COMBINE               , \"combiner\")\n+DEFTIMEVAR (TV_REGMOVE               , \"regmove\")\n+DEFTIMEVAR (TV_SCHED                 , \"scheduling\")\n+DEFTIMEVAR (TV_LOCAL_ALLOC           , \"local alloc\")\n+DEFTIMEVAR (TV_GLOBAL_ALLOC          , \"global alloc\")\n+DEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\n+DEFTIMEVAR (TV_FLOW2                 , \"flow 2\")\n+DEFTIMEVAR (TV_PEEPHOLE2             , \"peephole 2\")\n+DEFTIMEVAR (TV_SCHED2                , \"schedulding 2\")\n+DEFTIMEVAR (TV_DBR_SCHED             , \"delay branch sched\")\n+DEFTIMEVAR (TV_REORDER_BLOCKS        , \"reorder blocks\")\n+DEFTIMEVAR (TV_RENAME_REGISTERS      , \"rename registers\")\n+DEFTIMEVAR (TV_SHORTEN_BRANCH        , \"shorten branches\")\n+DEFTIMEVAR (TV_REG_STACK             , \"reg stack\")\n+DEFTIMEVAR (TV_TO_SSA                , \"convert to SSA\")\n+DEFTIMEVAR (TV_FROM_SSA              , \"convert from SSA\")\n+DEFTIMEVAR (TV_FINAL                 , \"final\")\n+DEFTIMEVAR (TV_SYMOUT                , \"symout\")\n+\n+/* Everything else in rest_of_compilation not included above.  */\n+DEFTIMEVAR (TV_REST_OF_COMPILATION   , \"rest of compilation\")"}, {"sha": "c7fcfa70456f50e2271eafb68b040d58e09952a6", "filename": "gcc/timevar.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -0,0 +1,86 @@\n+/* Timing variables for measuring compiler performance.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Alex Samuel <samuel@codesourcery.com>\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* Timing variables are used to measure elapsed time in various\n+   portions of the compiler.  Each measures elapsed user, system, and\n+   wall-clock time, as appropriate to and supported by the host\n+   system.\n+\n+   Timing variables are defined using the DEFTIMEVAR macro in\n+   timevar.def.  Each has an enumeral identifier, used when referring\n+   to the timing variable in code, and a character string name.\n+\n+   Timing variables can be used in two ways:\n+\n+     - On the timing stack, using timevar_push and timevar_pop.\n+       Timing variables may be pushed onto the stack; elapsed time is\n+       attributed to the topmost timing variable on the stack.  When\n+       another variable is pushed on, the previous topmost variable is\n+       `paused' until the pushed variable is popped back off.\n+\n+     - As a standalone timer, using timevar_start and timevar_stop.\n+       All time elapsed between the two calls is attributed to the\n+       variable.  \n+*/\n+   \n+/* This structure stores the various varieties of time that can be\n+   measured.  Times are stored in microseconds.  The time may be an\n+   absolute time or a time difference; in the former case, the time\n+   base is undefined, except that the difference between two times\n+   produces a valid time difference.  */\n+\n+struct timevar_time_def\n+{\n+  /* User time in this process.  */\n+  long user;\n+\n+  /* System time (if applicable for this host platform) in this\n+     process.  */\n+  long sys;\n+\n+  /* Wall clock time.  */\n+  long wall;\n+};\n+\n+/* An enumeration of timing variable indentifiers.  Constructed from\n+   the contents of timevar.def.  */\n+\n+#define DEFTIMEVAR(identifier__, name__) \\\n+    identifier__, \n+typedef enum\n+{\n+#include \"timevar.def\"\n+  TIMEVAR_LAST\n+}\n+timevar_id_t;\n+#undef DEFTIMEVAR\n+\n+extern void init_timevar PARAMS ((void));\n+extern void timevar_push PARAMS ((timevar_id_t));\n+extern void timevar_pop PARAMS ((timevar_id_t));\n+extern void timevar_start PARAMS ((timevar_id_t));\n+extern void timevar_stop PARAMS ((timevar_id_t));\n+extern void timevar_get PARAMS ((timevar_id_t, struct timevar_time_def *));\n+extern void timevar_print PARAMS ((FILE *));\n+\n+/* Provided for backward compatibility.  */\n+extern long get_run_time PARAMS ((void));\n+extern void print_time PARAMS ((const char *, long));"}, {"sha": "e175a40c6da81e6f49865df982e5ab1fcbc37aa4", "filename": "gcc/toplev.c", "status": "modified", "additions": 426, "deletions": 573, "changes": 999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -60,6 +60,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"graph.h\"\n #include \"loop.h\"\n #include \"regs.h\"\n+#include \"timevar.h\"\n \n #ifndef ACCUMULATE_OUTGOING_ARGS\n #define ACCUMULATE_OUTGOING_ARGS 0\n@@ -1402,130 +1403,7 @@ read_integral_parameter (p, pname, defval)\n   return atoi (p);\n }\n \n-\n-/* Time accumulators, to count the total time spent in various passes.\n-   The first three are used in other files; the latter two only here.  */\n-\n-long gc_time;\n-long parse_time;\n-long varconst_time;\n-\n-static long integration_time;\n-static long jump_time;\n-static long cse_time;\n-static long gcse_time;\n-static long loop_time;\n-static long cse2_time;\n-static long branch_prob_time;\n-static long flow_time;\n-static long combine_time;\n-static long regmove_time;\n-static long sched_time;\n-static long local_alloc_time;\n-static long global_alloc_time;\n-static long flow2_time;\n-static long peephole2_time;\n-static long sched2_time;\n-static long dbr_sched_time;\n-static long reorder_blocks_time;\n-static long rename_registers_time;\n-static long shorten_branch_time;\n-static long stack_reg_time;\n-static long to_ssa_time;\n-static long from_ssa_time;\n-static long final_time;\n-static long symout_time;\n-static long dump_time;\n-static long all_time;\n \f\n-/* Return time used so far, in microseconds.  */\n-\n-long\n-get_run_time ()\n-{\n-  if (quiet_flag)\n-    return 0;\n-\n-#ifdef __BEOS__\n-  return 0;\n-#else /* not BeOS */\n-#if defined (_WIN32) && !defined (__CYGWIN__)\n-  if (clock() < 0)\n-    return 0;\n-  else\n-    return (clock() * 1000);\n-#else /* not _WIN32 */\n-#ifdef _SC_CLK_TCK\n-  {\n-    static int tick;\n-    struct tms tms;\n-    if (tick == 0)\n-      tick = 1000000 / sysconf(_SC_CLK_TCK);\n-    times (&tms);\n-    return (tms.tms_utime + tms.tms_stime) * tick;\n-  }\n-#else\n-#ifdef USG\n-  {\n-    struct tms tms;\n-#   if HAVE_SYSCONF && defined _SC_CLK_TCK\n-#    define TICKS_PER_SECOND sysconf (_SC_CLK_TCK) /* POSIX 1003.1-1996 */\n-#   else\n-#    ifdef CLK_TCK\n-#     define TICKS_PER_SECOND CLK_TCK /* POSIX 1003.1-1988; obsolescent */\n-#    else\n-#     define TICKS_PER_SECOND HZ /* traditional UNIX */\n-#    endif\n-#   endif\n-    times (&tms);\n-    return (tms.tms_utime + tms.tms_stime) * (1000000 / TICKS_PER_SECOND);\n-  }\n-#else\n-#ifndef VMS\n-  {\n-    struct rusage rusage;\n-    getrusage (0, &rusage);\n-    return (rusage.ru_utime.tv_sec * 1000000 + rusage.ru_utime.tv_usec\n-\t    + rusage.ru_stime.tv_sec * 1000000 + rusage.ru_stime.tv_usec);\n-  }\n-#else /* VMS */\n-  {\n-    struct\n-      {\n-        int proc_user_time;\n-        int proc_system_time;\n-        int child_user_time;\n-        int child_system_time;\n-      } vms_times;\n-    times ((void *) &vms_times);\n-    return (vms_times.proc_user_time + vms_times.proc_system_time) * 10000;\n-  }\n-#endif\t/* VMS */\n-#endif\t/* USG */\n-#endif  /* _SC_CLK_TCK */\n-#endif\t/* _WIN32 */\n-#endif\t/* __BEOS__ */\n-}\n-\n-#define TIMEVAR(VAR, BODY)\t\t\\\n-do {\t\t\t\t\t\\\n-  long otime = get_run_time ();\t\t\\\n-  BODY;\t\t\t\t\t\\\n-  VAR += get_run_time () - otime;\t\\\n-} while (0)\n-\n-void\n-print_time (str, total)\n-     const char *str;\n-     long total;\n-{\n-  fprintf (stderr,\n-\t   \"time in %s: %ld.%06ld (%ld%%)\\n\",\n-\t   str, total / 1000000, total % 1000000,\n-\t   all_time == 0 ? 0\n-\t   : (long) (((100.0 * (double) total) / (double) all_time) + .5));\n-}\n-\n /* This is the default decl_printable_name function.  */\n \n static const char *\n@@ -1824,44 +1702,42 @@ open_dump_file (index, decl)\n   if (! dump_file[index].enabled)\n     return 0;\n \n-  TIMEVAR\n-    (dump_time,\n-      {\n-\tif (rtl_dump_file != NULL)\n-\t  fclose (rtl_dump_file);\n+  timevar_push (TV_DUMP);\n+  if (rtl_dump_file != NULL)\n+    fclose (rtl_dump_file);\n   \n-\tsprintf (seq, \".%02d.\", index);\n+  sprintf (seq, \".%02d.\", index);\n \n-\tif (! dump_file[index].initialized)\n-\t  {\n-\t    /* If we've not initialized the files, do so now.  */\n-\t    if (graph_dump_format != no_graph\n-\t\t&& dump_file[index].graph_dump_p)\n-\t      {\n-\t\tdump_name = concat (seq, dump_file[index].extension, NULL);\n-\t\tclean_graph_dump_file (dump_base_name, dump_name);\n-\t\tfree (dump_name);\n-\t      }\n-\t    dump_file[index].initialized = 1;\n-\t    open_arg = \"w\";\n-\t  }\n-\telse\n-\t  open_arg = \"a\";\n+  if (! dump_file[index].initialized)\n+    {\n+      /* If we've not initialized the files, do so now.  */\n+      if (graph_dump_format != no_graph\n+\t  && dump_file[index].graph_dump_p)\n+\t{\n+\t  dump_name = concat (seq, dump_file[index].extension, NULL);\n+\t  clean_graph_dump_file (dump_base_name, dump_name);\n+\t  free (dump_name);\n+\t}\n+      dump_file[index].initialized = 1;\n+      open_arg = \"w\";\n+    }\n+  else\n+    open_arg = \"a\";\n \n-\tdump_name = concat (dump_base_name, seq,\n-\t\t\t    dump_file[index].extension, NULL);\n+  dump_name = concat (dump_base_name, seq,\n+\t\t      dump_file[index].extension, NULL);\n \n-\trtl_dump_file = fopen (dump_name, open_arg);\n-\tif (rtl_dump_file == NULL)\n-\t  pfatal_with_name (dump_name);\n+  rtl_dump_file = fopen (dump_name, open_arg);\n+  if (rtl_dump_file == NULL)\n+    pfatal_with_name (dump_name);\n        \n-\tfree (dump_name);\n+  free (dump_name);\n \n-\tif (decl)\n-\t  fprintf (rtl_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t   decl_printable_name (decl, 2));\n-      });\n-  \n+  if (decl)\n+    fprintf (rtl_dump_file, \"\\n;; Function %s\\n\\n\",\n+\t     decl_printable_name (decl, 2));\n+\n+  timevar_pop (TV_DUMP);\n   return 1;\n }\n \n@@ -1876,30 +1752,28 @@ close_dump_file (index, func, insns)\n   if (! rtl_dump_file)\n     return;\n \n-  TIMEVAR\n-    (dump_time,\n-      {\n-\tif (insns\n-\t    && graph_dump_format != no_graph\n-\t    && dump_file[index].graph_dump_p)\n-\t  {\n-\t    char seq[16];\n-\t    char *suffix;\n+  timevar_push (TV_DUMP);\n+  if (insns\n+      && graph_dump_format != no_graph\n+      && dump_file[index].graph_dump_p)\n+    {\n+      char seq[16];\n+      char *suffix;\n \n-\t    sprintf (seq, \".%02d.\", index);\n-\t    suffix = concat (seq, dump_file[index].extension, NULL);\n-\t    print_rtl_graph_with_bb (dump_base_name, suffix, insns);\n-\t    free (suffix);\n-\t  }\n+      sprintf (seq, \".%02d.\", index);\n+      suffix = concat (seq, dump_file[index].extension, NULL);\n+      print_rtl_graph_with_bb (dump_base_name, suffix, insns);\n+      free (suffix);\n+    }\n \n-       if (func && insns)\n-\t func (rtl_dump_file, insns);\n+  if (func && insns)\n+    func (rtl_dump_file, insns);\n        \n-       fflush (rtl_dump_file);\n-       fclose (rtl_dump_file);\n+  fflush (rtl_dump_file);\n+  fclose (rtl_dump_file);\n        \n-       rtl_dump_file = NULL;\n-     });\n+  rtl_dump_file = NULL;\n+  timevar_pop (TV_DUMP);\n }\n \n /* Do any final processing required for the declarations in VEC, of\n@@ -2060,6 +1934,7 @@ check_global_declarations (vec, len)\n \t  && ! TREE_USED (DECL_NAME (decl)))\n \twarning_with_decl (decl, \"`%s' defined but not used\");\n \n+      timevar_push (TV_SYMOUT);\n #ifdef SDB_DEBUGGING_INFO\n       /* The COFF linker can move initialized global vars to the end.\n \t And that can screw up the symbol ordering.\n@@ -2069,7 +1944,7 @@ check_global_declarations (vec, len)\n \t  && TREE_PUBLIC (decl) && DECL_INITIAL (decl)\n \t  && ! DECL_EXTERNAL (decl)\n \t  && DECL_RTL (decl) != 0)\n-\tTIMEVAR (symout_time, sdbout_symbol (decl, 0));\n+\tsdbout_symbol (decl, 0);\n \n       /* Output COFF information for non-global\n \t file-scope initialized variables.  */\n@@ -2079,7 +1954,7 @@ check_global_declarations (vec, len)\n \t  && ! DECL_EXTERNAL (decl)\n \t  && DECL_RTL (decl) != 0\n \t  && GET_CODE (DECL_RTL (decl)) == MEM)\n-\tTIMEVAR (symout_time, sdbout_toplevel_data (decl));\n+\tsdbout_toplevel_data (decl);\n #endif /* SDB_DEBUGGING_INFO */\n #ifdef DWARF_DEBUGGING_INFO\n       /* Output DWARF information for file-scope tentative data object\n@@ -2089,7 +1964,7 @@ check_global_declarations (vec, len)\n \n       if (write_symbols == DWARF_DEBUG\n \t  && (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl)))\n-\tTIMEVAR (symout_time, dwarfout_file_scope_decl (decl, 1));\n+\tdwarfout_file_scope_decl (decl, 1);\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n       /* Output DWARF2 information for file-scope tentative data object\n@@ -2099,8 +1974,9 @@ check_global_declarations (vec, len)\n \n       if (write_symbols == DWARF2_DEBUG\n \t  && (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl)))\n-\tTIMEVAR (symout_time, dwarf2out_decl (decl));\n+\tdwarf2out_decl (decl);\n #endif\n+      timevar_pop (TV_SYMOUT);\n     }\n }\n \n@@ -2158,42 +2034,17 @@ compile_file (name)\n      char *name;\n {\n   tree globals;\n-  int start_time;\n \n   int name_specified = name != 0;\n \n   if (dump_base_name == 0)\n     dump_base_name = name ? name : \"gccdump\";\n \n-  parse_time = 0;\n-  varconst_time = 0;\n-  integration_time = 0;\n-  jump_time = 0;\n-  cse_time = 0;\n-  gcse_time = 0;\n-  loop_time = 0;\n-  cse2_time = 0;\n-  branch_prob_time = 0;\n-  flow_time = 0;\n-  combine_time = 0;\n-  regmove_time = 0;\n-  sched_time = 0;\n-  local_alloc_time = 0;\n-  global_alloc_time = 0;\n-  flow2_time = 0;\n-  peephole2_time = 0;\n-  sched2_time = 0;\n-  dbr_sched_time = 0;\n-  reorder_blocks_time = 0;\n-  rename_registers_time = 0;\n-  shorten_branch_time = 0;\n-  stack_reg_time = 0;\n-  to_ssa_time = 0;\n-  from_ssa_time = 0;\n-  final_time = 0;\n-  symout_time = 0;\n-  dump_time = 0;\n+  /* Start timing total execution time.  */\n \n+  init_timevar ();\n+  timevar_start (TV_TOTAL);\n+  \n   /* Initialize data in various passes.  */\n \n   init_obstacks ();\n@@ -2365,35 +2216,35 @@ compile_file (name)\n \n   /* If dbx symbol table desired, initialize writing it\n      and output the predefined types.  */\n+  timevar_push (TV_SYMOUT);\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n   if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n-    TIMEVAR (symout_time, dbxout_init (asm_out_file, main_input_filename,\n-\t\t\t\t       getdecls ()));\n+    dbxout_init (asm_out_file, main_input_filename, getdecls ());\n #endif\n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)\n-    TIMEVAR (symout_time, sdbout_init (asm_out_file, main_input_filename,\n-\t\t\t\t       getdecls ()));\n+    sdbout_init (asm_out_file, main_input_filename, getdecls ());\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n   if (write_symbols == DWARF_DEBUG)\n-    TIMEVAR (symout_time, dwarfout_init (asm_out_file, main_input_filename));\n+    dwarfout_init (asm_out_file, main_input_filename);\n #endif\n #ifdef DWARF2_UNWIND_INFO\n   if (dwarf2out_do_frame ())\n     dwarf2out_frame_init ();\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n   if (write_symbols == DWARF2_DEBUG)\n-    TIMEVAR (symout_time, dwarf2out_init (asm_out_file, main_input_filename));\n+    dwarf2out_init (asm_out_file, main_input_filename);\n #endif\n+  timevar_pop (TV_SYMOUT);\n \n   /* Initialize yet another pass.  */\n \n   init_final (main_input_filename);\n   init_branch_prob (dump_base_name);\n \n-  start_time = get_run_time ();\n+  timevar_push (TV_PARSE);\n \n   /* Call the parser, which parses the entire file\n      (calling rest_of_compilation for each function).  */\n@@ -2412,10 +2263,7 @@ compile_file (name)\n   /* Compilation is now finished except for writing\n      what's left of the symbol table output.  */\n \n-  parse_time += get_run_time () - start_time;\n-\n-  parse_time -= integration_time;\n-  parse_time -= varconst_time;\n+  timevar_pop (TV_PARSE);\n \n   if (flag_syntax_only)\n     goto finish_syntax;\n@@ -2465,20 +2313,15 @@ compile_file (name)\n   weak_finish ();\n \n   /* Do dbx symbols */\n+  timevar_push (TV_SYMOUT);\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n   if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n-    TIMEVAR (symout_time,\n-\t     {\n-\t       dbxout_finish (asm_out_file, main_input_filename);\n-\t     });\n+    dbxout_finish (asm_out_file, main_input_filename);\n #endif\n \n #ifdef DWARF_DEBUGGING_INFO\n   if (write_symbols == DWARF_DEBUG)\n-    TIMEVAR (symout_time,\n-\t     {\n-\t       dwarfout_finish ();\n-\t     });\n+    dwarfout_finish ();\n #endif\n \n #ifdef DWARF2_UNWIND_INFO\n@@ -2488,23 +2331,21 @@ compile_file (name)\n \n #ifdef DWARF2_DEBUGGING_INFO\n   if (write_symbols == DWARF2_DEBUG)\n-    TIMEVAR (symout_time,\n-\t     {\n-\t       dwarf2out_finish ();\n-\t     });\n+    dwarf2out_finish ();\n #endif\n+  timevar_pop (TV_SYMOUT);\n \n   /* Output some stuff at end of file if nec.  */\n \n   end_final (dump_base_name);\n    \n   if (flag_test_coverage || flag_branch_probabilities)\n     {\n+      timevar_push (TV_DUMP);\n       open_dump_file (DFI_bp, NULL);\n-   \n-      TIMEVAR (dump_time, end_branch_prob (rtl_dump_file));\n-   \n+      end_branch_prob (rtl_dump_file);\n       close_dump_file (DFI_bp, NULL, NULL_RTX);\n+      timevar_pop (TV_DUMP);\n     }\n    \n #ifdef ASM_FILE_END\n@@ -2526,8 +2367,10 @@ compile_file (name)\n \n   if (optimize > 0 && open_dump_file (DFI_combine, NULL))\n     {\n-      TIMEVAR (dump_time, dump_combine_total_stats (rtl_dump_file));\n+      timevar_push (TV_DUMP);\n+      dump_combine_total_stats (rtl_dump_file);\n       close_dump_file (DFI_combine, NULL, NULL_RTX);\n+      timevar_pop (TV_DUMP);\n     }\n \n   /* Close non-debugging input and output files.  Take special care to note\n@@ -2561,55 +2404,13 @@ compile_file (name)\n   /* Free up memory for the benefit of leak detectors.  */\n   free_reg_info ();\n \n+  /* Stop timing total execution time.  */\n+  timevar_stop (TV_TOTAL);\n+\n   /* Print the times.  */\n \n   if (! quiet_flag)\n-    {\n-      all_time = get_run_time ();\n-\n-      fprintf (stderr,\"\\n\");\n-\n-      print_time (\"parse\", parse_time);\n-      print_time (\"integration\", integration_time);\n-      print_time (\"jump\", jump_time);\n-      print_time (\"cse\", cse_time);\n-      print_time (\"to ssa\", to_ssa_time);\n-      print_time (\"from ssa\", from_ssa_time);\n-      print_time (\"gcse\", gcse_time);\n-      print_time (\"loop\", loop_time);\n-      print_time (\"cse2\", cse2_time);\n-      print_time (\"branch-prob\", branch_prob_time);\n-      print_time (\"flow\", flow_time);\n-      print_time (\"combine\", combine_time);\n-      print_time (\"regmove\", regmove_time);\n-#ifdef INSN_SCHEDULING\n-      print_time (\"sched\", sched_time);\n-#endif\n-      print_time (\"local-alloc\", local_alloc_time);\n-      print_time (\"global-alloc\", global_alloc_time);\n-      print_time (\"flow2\", flow2_time);\n-#ifdef HAVE_peephole2\n-      print_time (\"peephole2\", peephole2_time);\n-#endif\n-#ifdef INSN_SCHEDULING\n-      print_time (\"sched2\", sched2_time);\n-#endif\n-#ifdef DELAY_SLOTS\n-      print_time (\"dbranch\", dbr_sched_time);\n-#endif\n-      print_time (\"bbro\", reorder_blocks_time);\n-      print_time (\"rnreg\", rename_registers_time);\n-      print_time (\"shorten-branch\", shorten_branch_time);\n-#ifdef STACK_REGS\n-      print_time (\"stack-reg\", stack_reg_time);\n-#endif\n-      print_time (\"final\", final_time);\n-      print_time (\"varconst\", varconst_time);\n-      print_time (\"symout\", symout_time);\n-      print_time (\"dump\", dump_time);\n-      if (ggc_p)\n-\tprint_time (\"gc\", gc_time);\n-    }\n+    timevar_print (stderr);\n }\n \f\n /* This is called from various places for FUNCTION_DECL, VAR_DECL,\n@@ -2644,29 +2445,30 @@ rest_of_decl_compilation (decl, asmspec, top_level, at_end)\n      but we need to treat them as if they were.  */\n   if (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n       || TREE_CODE (decl) == FUNCTION_DECL)\n-    TIMEVAR (varconst_time,\n-\t     {\n-\t       make_decl_rtl (decl, asmspec, top_level);\n-\t       /* Initialized extern variable exists to be replaced\n-\t\t  with its value, or represents something that will be\n-\t\t  output in another file.  */\n-\t       if (! (TREE_CODE (decl) == VAR_DECL\n-\t\t      && DECL_EXTERNAL (decl) && TREE_READONLY (decl)\n-\t\t      && DECL_INITIAL (decl) != 0\n-\t\t      && DECL_INITIAL (decl) != error_mark_node))\n-\t\t /* Don't output anything\n-\t\t    when a tentative file-scope definition is seen.\n-\t\t    But at end of compilation, do output code for them.  */\n-\t\t if (! (! at_end && top_level\n-\t\t\t&& (DECL_INITIAL (decl) == 0\n-\t\t\t    || DECL_INITIAL (decl) == error_mark_node)))\n-\t\t   assemble_variable (decl, top_level, at_end, 0);\n-\t       if (decl == last_assemble_variable_decl)\n-\t\t {\n-\t\t   ASM_FINISH_DECLARE_OBJECT (asm_out_file, decl,\n-\t\t\t\t\t      top_level, at_end);\n-\t\t }\n-\t     });\n+    {\n+      timevar_push (TV_VARCONST);\n+      make_decl_rtl (decl, asmspec, top_level);\n+      /* Initialized extern variable exists to be replaced\n+\t with its value, or represents something that will be\n+\t output in another file.  */\n+      if (! (TREE_CODE (decl) == VAR_DECL\n+\t     && DECL_EXTERNAL (decl) && TREE_READONLY (decl)\n+\t     && DECL_INITIAL (decl) != 0\n+\t     && DECL_INITIAL (decl) != error_mark_node))\n+\t/* Don't output anything\n+\t     when a tentative file-scope definition is seen.\n+\t     But at end of compilation, do output code for them.  */\n+\tif (! (! at_end && top_level\n+\t       && (DECL_INITIAL (decl) == 0\n+\t\t   || DECL_INITIAL (decl) == error_mark_node)))\n+\t  assemble_variable (decl, top_level, at_end, 0);\n+      if (decl == last_assemble_variable_decl)\n+\t{\n+\t  ASM_FINISH_DECLARE_OBJECT (asm_out_file, decl,\n+\t\t\t\t     top_level, at_end);\n+\t}\n+      timevar_pop (TV_VARCONST);\n+    }\n   else if (DECL_REGISTER (decl) && asmspec != 0)\n     {\n       if (decode_reg_name (asmspec) >= 0)\n@@ -2680,12 +2482,20 @@ rest_of_decl_compilation (decl, asmspec, top_level, at_end)\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n   else if ((write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n \t   && TREE_CODE (decl) == TYPE_DECL)\n-    TIMEVAR (symout_time, dbxout_symbol (decl, 0));\n+    {\n+      timevar_push (TV_SYMOUT);\n+      dbxout_symbol (decl, 0);\n+      timevar_pop (TV_SYMOUT);\n+    }\n #endif\n #ifdef SDB_DEBUGGING_INFO\n   else if (write_symbols == SDB_DEBUG && top_level\n \t   && TREE_CODE (decl) == TYPE_DECL)\n-    TIMEVAR (symout_time, sdbout_symbol (decl, 0));\n+    {\n+      timevar_push (TV_SYMOUT);\n+      sdbout_symbol (decl, 0);\n+      timevar_pop (TV_SYMOUT);\n+    }\n #endif\n }\n \n@@ -2701,14 +2511,16 @@ rest_of_type_compilation (type, toplev)\n      int toplev ATTRIBUTE_UNUSED;\n #endif\n {\n+  timevar_push (TV_SYMOUT);\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n   if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n-    TIMEVAR (symout_time, dbxout_symbol (TYPE_STUB_DECL (type), !toplev));\n+    dbxout_symbol (TYPE_STUB_DECL (type), !toplev);\n #endif\n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)\n-    TIMEVAR (symout_time, sdbout_symbol (TYPE_STUB_DECL (type), !toplev));\n+    symout_time, sdbout_symbol (TYPE_STUB_DECL (type), !toplev);\n #endif\n+  timevar_pop (TV_SYMOUT);\n }\n \n /* DECL is an inline function, whose body is present, but which is not\n@@ -2758,11 +2570,12 @@ rest_of_compilation (decl)\n      tree decl;\n {\n   register rtx insns;\n-  int start_time = get_run_time ();\n   int tem;\n   int failure = 0;\n   int rebuild_label_notes_after_reload;\n \n+  timevar_push (TV_REST_OF_COMPILATION);\n+\n   /* When processing delayed functions, prepare_function_start() won't\n      have been run to re-initialize it.  */\n   cse_not_expected = ! optimize;\n@@ -2807,30 +2620,31 @@ rest_of_compilation (decl)\n \n       /* If requested, consider whether to make this function inline.  */\n       if (DECL_INLINE (decl) || flag_inline_functions)\n-\tTIMEVAR (integration_time,\n-\t\t {\n-\t\t   lose = function_cannot_inline_p (decl);\n-\t\t   if (lose || ! optimize)\n-\t\t     {\n-\t\t       if (warn_inline && DECL_INLINE (decl))\n-\t\t\t warning_with_decl (decl, lose);\n-\t\t       DECL_ABSTRACT_ORIGIN (decl) = 0;\n-\t\t       /* Don't really compile an extern inline function.\n-\t\t\t  If we can't make it inline, pretend\n-\t\t\t  it was only declared.  */\n-\t\t       if (DECL_EXTERNAL (decl))\n-\t\t\t {\n-\t\t\t   DECL_INITIAL (decl) = 0;\n-\t\t\t   goto exit_rest_of_compilation;\n-\t\t\t }\n-\t\t     }\n-\t\t   else\n-\t\t     /* ??? Note that this has the effect of making it look\n-\t\t\tlike \"inline\" was specified for a function if we choose\n-\t\t\tto inline it.  This isn't quite right, but it's\n-\t\t\tprobably not worth the trouble to fix.  */\n-\t\t     inlinable = DECL_INLINE (decl) = 1;\n-\t\t });\n+\t{\n+\t  timevar_push (TV_INTEGRATION);\n+\t  lose = function_cannot_inline_p (decl);\n+\t  timevar_pop (TV_INTEGRATION);\n+\t  if (lose || ! optimize)\n+\t    {\n+\t      if (warn_inline && DECL_INLINE (decl))\n+\t\twarning_with_decl (decl, lose);\n+\t      DECL_ABSTRACT_ORIGIN (decl) = 0;\n+\t      /* Don't really compile an extern inline function.\n+\t\t If we can't make it inline, pretend\n+\t\t it was only declared.  */\n+\t      if (DECL_EXTERNAL (decl))\n+\t\t{\n+\t\t  DECL_INITIAL (decl) = 0;\n+\t\t  goto exit_rest_of_compilation;\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* ??? Note that this has the effect of making it look\n+\t\t like \"inline\" was specified for a function if we choose\n+\t\t to inline it.  This isn't quite right, but it's\n+\t\t probably not worth the trouble to fix.  */\n+\t    inlinable = DECL_INLINE (decl) = 1;\n+\t}\n \n       insns = get_insns ();\n \n@@ -2883,7 +2697,9 @@ rest_of_compilation (decl)\n \t    TREE_NOTHROW (current_function_decl) = 1;\n \n \t  note_deferral_of_defined_inline_function (decl);\n-\t  TIMEVAR (integration_time, save_for_inline_nocopy (decl));\n+\t  timevar_push (TV_INTEGRATION);\n+\t  save_for_inline_nocopy (decl);\n+\t  timevar_pop (TV_INTEGRATION);\n \t  DECL_SAVED_INSNS (decl)->inlinable = inlinable;\n \t  goto exit_rest_of_compilation;\n \t}\n@@ -2922,13 +2738,15 @@ rest_of_compilation (decl)\n      (of possibly multiple) methods of performing the call.  */\n   if (flag_optimize_sibling_calls)\n     {\n+      timevar_push (TV_JUMP);\n       open_dump_file (DFI_sibling, decl);\n \n-      TIMEVAR (jump_time, optimize_sibling_and_tail_recursive_calls ());\n+      optimize_sibling_and_tail_recursive_calls ();\n \n       close_dump_file (DFI_sibling, print_rtl, get_insns ());\n+      timevar_pop (TV_JUMP);\n     }\n-  \n+\n #ifdef FINALIZE_PIC\n   /* If we are doing position-independent code generation, now\n      is the time to output special prologues and epilogues.\n@@ -2969,16 +2787,17 @@ rest_of_compilation (decl)\n   /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n      are initialized and to compute whether control can drop off the end\n      of the function.  */\n-  TIMEVAR (jump_time,\n-\t   {\n-\t     /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n-\t\tbefore jump optimization switches branch directions.  */\n-\t     expected_value_to_br_prob ();\n \n-\t     reg_scan (insns, max_reg_num (), 0);\n-\t     jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n-\t\t\t    JUMP_AFTER_REGSCAN);\n-\t   });\n+  timevar_push (TV_JUMP);\n+  /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n+     before jump optimization switches branch directions.  */\n+  expected_value_to_br_prob ();\n+\n+  reg_scan (insns, max_reg_num (), 0);\n+  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t\t JUMP_AFTER_REGSCAN);\n+\n+  timevar_pop (TV_JUMP);\n \n   /* Now is when we stop if -fsyntax-only and -Wreturn-type.  */\n   if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n@@ -2987,23 +2806,22 @@ rest_of_compilation (decl)\n       goto exit_rest_of_compilation;\n     }\n \n-  TIMEVAR (jump_time,\n-\t   {\n-\t     /* Try to identify useless null pointer tests and delete them.  */\n-\t     if (flag_delete_null_pointer_checks)\n-\t       {\n-\t\t find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-\t\t cleanup_cfg (insns);\n-\t\t delete_null_pointer_checks (insns);\n-\t       }\n-\n-\t     /* Jump optimization, and the removal of NULL pointer checks,\n-\t\tmay have reduced the number of instructions substantially. \n-\t\tCSE, and future passes, allocate arrays whose dimensions\n-\t\tinvolve the maximum instruction UID, so if we can reduce\n-\t\tthe maximum UID we'll save big on memory.  */\n-\t     renumber_insns (rtl_dump_file);\n-\t   });\n+  timevar_push (TV_JUMP);\n+  /* Try to identify useless null pointer tests and delete them.  */\n+  if (flag_delete_null_pointer_checks)\n+    {\n+      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+      cleanup_cfg (insns);\n+      delete_null_pointer_checks (insns);\n+    }\n+\n+  /* Jump optimization, and the removal of NULL pointer checks, may\n+     have reduced the number of instructions substantially.  CSE, and\n+     future passes, allocate arrays whose dimensions involve the\n+     maximum instruction UID, so if we can reduce the maximum UID\n+     we'll save big on memory.  */\n+  renumber_insns (rtl_dump_file);\n+  timevar_pop (TV_JUMP);\n \n   close_dump_file (DFI_jump, print_rtl, insns);\n \n@@ -3018,41 +2836,52 @@ rest_of_compilation (decl)\n   if (optimize > 0)\n     {\n       open_dump_file (DFI_cse, decl);\n+      timevar_push (TV_CSE);\n \n-      TIMEVAR (cse_time, reg_scan (insns, max_reg_num (), 1));\n+      reg_scan (insns, max_reg_num (), 1);\n \n       if (flag_thread_jumps)\n-\tTIMEVAR (jump_time, thread_jumps (insns, max_reg_num (), 1));\n+\t{\n+\t  timevar_push (TV_JUMP);\n+\t  thread_jumps (insns, max_reg_num (), 1);\n+\t  timevar_pop (TV_JUMP);\n+\t}\n \n-      TIMEVAR (cse_time, tem = cse_main (insns, max_reg_num (),\n-\t\t\t\t\t 0, rtl_dump_file));\n+      tem = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n \n       /* If we are not running the second CSE pass, then we are no longer\n \t expecting CSE to be run.  */\n       cse_not_expected = !flag_rerun_cse_after_loop;\n \n       if (tem || optimize > 1)\n-\tTIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t\t\t\t   !JUMP_NOOP_MOVES,\n-\t\t\t\t\t   !JUMP_AFTER_REGSCAN));\n+\t{\n+\t  timevar_push (TV_JUMP);\n+\t  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t\t\t !JUMP_AFTER_REGSCAN);\n+\t  timevar_pop (TV_JUMP);\n+\t}\n  \n       /* Run this after jump optmizations remove all the unreachable code\n \t so that unreachable code will not keep values live.  */\n-      TIMEVAR (cse_time, delete_trivially_dead_insns (insns, max_reg_num ()));\n+      delete_trivially_dead_insns (insns, max_reg_num ());\n \n       /* Try to identify useless null pointer tests and delete them.  */\n       if (flag_delete_null_pointer_checks)\n-\tTIMEVAR (jump_time,\n-\t\t {\n-\t\t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-\t\t   cleanup_cfg (insns);\n-\t\t   delete_null_pointer_checks (insns);\n-\t\t });\n+\t{\n+\t  timevar_push (TV_JUMP);\n+\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\n+\t  cleanup_cfg (insns);\n+\n+\t  delete_null_pointer_checks (insns);\n+\t  timevar_pop (TV_JUMP);\n+\t}\n \n       /* The second pass of jump optimization is likely to have\n          removed a bunch more instructions.  */\n       renumber_insns (rtl_dump_file);\n \n+      timevar_pop (TV_CSE);\n       close_dump_file (DFI_cse, print_rtl, insns);\n     }\n \n@@ -3068,33 +2897,35 @@ rest_of_compilation (decl)\n \n   if (optimize > 0 && flag_ssa)\n     {\n+      /* Convert to SSA form.  */\n+\n+      timevar_push (TV_TO_SSA);\n       open_dump_file (DFI_ssa, decl);\n \n-      TIMEVAR (to_ssa_time,\n-\t       {\n-\t\t find_basic_blocks (insns, max_reg_num(), rtl_dump_file);\n-\t\t cleanup_cfg (insns);\n-\t\t convert_to_ssa ();\n-\t       });\n+      find_basic_blocks (insns, max_reg_num(), rtl_dump_file);\n+      cleanup_cfg (insns);\n+      convert_to_ssa ();\n \n       close_dump_file (DFI_ssa, print_rtl_with_bb, insns);\n+      timevar_pop (TV_TO_SSA);\n \n-      open_dump_file (DFI_ussa, decl);\n+      /* Currently, there's nothing to do in SSA form.  */\n \n-      TIMEVAR (from_ssa_time,\n-\t       {\n-\t\t convert_from_ssa ();\n+      /* Convert from SSA form.  */\n \n-\t\t /* New registers have been created.  Rescan their usage.  */\n-\t\t reg_scan (insns, max_reg_num (), 1);\n+      timevar_push (TV_FROM_SSA);\n+      open_dump_file (DFI_ussa, decl);\n \n-\t\t /* Life analysis used in SSA adds log_links but these\n-\t\t    shouldn't be there until the flow stage, so clear\n-\t\t    them away.  */\n-\t\t clear_log_links (insns);\n-\t       });\n+      convert_from_ssa ();\n+      /* New registers have been created.  Rescan their usage.  */\n+      reg_scan (insns, max_reg_num (), 1);\n+      /* Life analysis used in SSA adds log_links but these\n+\t shouldn't be there until the flow stage, so clear\n+\t them away.  */\n+      clear_log_links (insns);\n \n       close_dump_file (DFI_ussa, print_rtl_with_bb, insns);\n+      timevar_pop (TV_FROM_SSA);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3104,25 +2935,25 @@ rest_of_compilation (decl)\n \n   if (optimize > 0 && flag_gcse)\n     {\n+      timevar_push (TV_GCSE);\n       open_dump_file (DFI_gcse, decl);\n \n-      TIMEVAR (gcse_time,\n-\t       {\n-\t\t find_basic_blocks (insns, max_reg_num(), rtl_dump_file);\n-\t\t cleanup_cfg (insns);\n-\t\t tem = gcse_main (insns, rtl_dump_file);\n-\t       });\n+      find_basic_blocks (insns, max_reg_num(), rtl_dump_file);\n+      cleanup_cfg (insns);\n+      tem = gcse_main (insns, rtl_dump_file);\n \n       /* If gcse altered any jumps, rerun jump optimizations to clean\n \t things up.  */\n       if (tem)\n \t{\n-\t  TIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t\t\t\t     !JUMP_NOOP_MOVES,\n-\t\t\t\t\t     !JUMP_AFTER_REGSCAN));\n+\t  timevar_push (TV_JUMP);\n+\t  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t\t\t !JUMP_AFTER_REGSCAN);\n+\t  timevar_pop (TV_JUMP);\n         }\n \n       close_dump_file (DFI_gcse, print_rtl, insns);\n+      timevar_pop (TV_GCSE);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3132,31 +2963,29 @@ rest_of_compilation (decl)\n \n   if (optimize > 0)\n     {\n+      timevar_push (TV_LOOP);\n       open_dump_file (DFI_loop, decl);\n-\n-      TIMEVAR\n-\t(loop_time,\n-\t {\n-\t   if (flag_rerun_loop_opt)\n-\t     {\n-\t       /* We only want to perform unrolling once.  */\n+      \n+      if (flag_rerun_loop_opt)\n+\t{\n+\t  /* We only want to perform unrolling once.  */\n \t       \n-\t       loop_optimize (insns, rtl_dump_file, 0, 0);\n+\t  loop_optimize (insns, rtl_dump_file, 0, 0);\n \n-\t       /* The first call to loop_optimize makes some instructions\n-\t\t  trivially dead.  We delete those instructions now in the\n-\t\t  hope that doing so will make the heuristics in loop work\n-\t\t  better and possibly speed up compilation.  */\n-\t       delete_trivially_dead_insns (insns, max_reg_num ());\n+\t  /* The first call to loop_optimize makes some instructions\n+\t     trivially dead.  We delete those instructions now in the\n+\t     hope that doing so will make the heuristics in loop work\n+\t     better and possibly speed up compilation.  */\n+\t  delete_trivially_dead_insns (insns, max_reg_num ());\n \n-\t       /* The regscan pass is currently necessary as the alias\n+\t  /* The regscan pass is currently necessary as the alias\n \t\t  analysis code depends on this information.  */\n-\t       reg_scan (insns, max_reg_num (), 1);\n-\t     }\n-\t   loop_optimize (insns, rtl_dump_file, flag_unroll_loops, 1);\n-\t });\n+\t  reg_scan (insns, max_reg_num (), 1);\n+\t}\n+      loop_optimize (insns, rtl_dump_file, flag_unroll_loops, 1);\n \n       close_dump_file (DFI_loop, print_rtl, insns);\n+      timevar_pop (TV_LOOP);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3169,6 +2998,7 @@ rest_of_compilation (decl)\n \n   if (optimize > 0)\n     {\n+      timevar_push (TV_CSE2);\n       open_dump_file (DFI_cse2, decl);\n \n       if (flag_rerun_cse_after_loop)\n@@ -3178,53 +3008,50 @@ rest_of_compilation (decl)\n \t     the second CSE pass to do a better job.  Jump_optimize can change\n \t     max_reg_num so we must rerun reg_scan afterwards.\n \t     ??? Rework to not call reg_scan so often.  */\n-\t  TIMEVAR (jump_time,\n-\t\t   {\n-\t\t     reg_scan (insns, max_reg_num (), 0);\n-\t\t     jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t\t\t    !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n-\t\t   });\n+\t  timevar_push (TV_JUMP);\n+\t  reg_scan (insns, max_reg_num (), 0);\n+\t  jump_optimize (insns, !JUMP_CROSS_JUMP,\n+\t\t\t !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n+\t  timevar_pop (TV_JUMP);\n \t  \n-\t  TIMEVAR (cse2_time,\n-\t\t   {\n-\t\t     reg_scan (insns, max_reg_num (), 0);\n-\t\t     tem = cse_main (insns, max_reg_num (),\n-\t\t\t\t     1, rtl_dump_file);\n-\t\t   });\n+\t  reg_scan (insns, max_reg_num (), 0);\n+\t  tem = cse_main (insns, max_reg_num (), 1, rtl_dump_file);\n \n \t  if (tem)\n-\t    TIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t\t\t\t       !JUMP_NOOP_MOVES,\n-\t\t\t\t\t       !JUMP_AFTER_REGSCAN));\n+\t    {\n+\t      timevar_push (TV_JUMP);\n+\t      jump_optimize (insns, !JUMP_CROSS_JUMP,\n+\t\t\t     !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t      timevar_pop (TV_JUMP);\n+\t    }\n \t}\n \n       if (flag_thread_jumps)\n \t{\n \t  /* This pass of jump threading straightens out code\n \t     that was kinked by loop optimization.  */\n-\t  TIMEVAR (jump_time,\n-\t\t   {\n-\t\t     reg_scan (insns, max_reg_num (), 0);\n-\t\t     thread_jumps (insns, max_reg_num (), 0);\n-\t\t   });\n+\t  timevar_push (TV_JUMP);\n+\t  reg_scan (insns, max_reg_num (), 0);\n+\t  thread_jumps (insns, max_reg_num (), 0);\n+\t  timevar_pop (TV_JUMP);\n \t}\n \n       close_dump_file (DFI_cse2, print_rtl, insns);\n+      timevar_pop (TV_CSE2);\n \n       if (ggc_p)\n \tggc_collect ();\n     }\n \n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n+      timevar_push (TV_BRANCH_PROB);\n       open_dump_file (DFI_bp, decl);\n \n-      TIMEVAR (branch_prob_time,\n-\t       {\n-\t\t branch_prob (insns, rtl_dump_file);\n-\t       });\n+      branch_prob (insns, rtl_dump_file);\n \n       close_dump_file (DFI_bp, print_rtl, insns);\n+      timevar_pop (TV_BRANCH_PROB);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3240,31 +3067,29 @@ rest_of_compilation (decl)\n   /* Do control and data flow analysis; wrote some of the results to\n      the dump file.  */\n \n-  TIMEVAR\n-    (flow_time,\n-     {\n-       find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-       cleanup_cfg (insns);\n-       if (optimize)\n-\t {\n-\t   struct loops loops;\n+  timevar_push (TV_FLOW);\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  cleanup_cfg (insns);\n+  if (optimize)\n+    {\n+      struct loops loops;\n \n-\t   /* Discover and record the loop depth at the head of each basic\n-\t      block.  The loop infrastructure does the real job for us.  */\n-\t   flow_loops_find (&loops);\n+      /* Discover and record the loop depth at the head of each basic\n+\t block.  The loop infrastructure does the real job for us.  */\n+      flow_loops_find (&loops);\n \n-\t   /* Estimate using heuristics if no profiling info is available.  */\n-\t   if (! flag_branch_probabilities)\n-\t     estimate_probability (&loops);\n+      /* Estimate using heuristics if no profiling info is available.  */\n+      if (! flag_branch_probabilities)\n+\testimate_probability (&loops);\n \n-\t   if (rtl_dump_file)\n-\t     flow_loops_dump (&loops, rtl_dump_file, 0);\n+      if (rtl_dump_file)\n+\tflow_loops_dump (&loops, rtl_dump_file, 0);\n \n-\t   flow_loops_free (&loops);\n-\t }\n-       life_analysis (insns, rtl_dump_file, PROP_FINAL);\n-       mark_constant_function ();\n-     });\n+      flow_loops_free (&loops);\n+    }\n+  life_analysis (insns, rtl_dump_file, PROP_FINAL);\n+  mark_constant_function ();\n+  timevar_pop (TV_FLOW);\n \n   if (warn_uninitialized || extra_warnings)\n     {\n@@ -3288,23 +3113,24 @@ rest_of_compilation (decl)\n     {\n       int rebuild_jump_labels_after_combine = 0;\n \n+      timevar_push (TV_COMBINE);\n       open_dump_file (DFI_combine, decl);\n \n-      TIMEVAR (combine_time, \n-\t       {\n-\t\t rebuild_jump_labels_after_combine\n-\t\t   = combine_instructions (insns, max_reg_num ());\n-\t       });\n+      rebuild_jump_labels_after_combine\n+\t= combine_instructions (insns, max_reg_num ());\n       \n       /* Combining insns may have turned an indirect jump into a\n \t direct jump.  Rebuid the JUMP_LABEL fields of jumping\n \t instructions.  */\n       if (rebuild_jump_labels_after_combine)\n \t{\n-\t  TIMEVAR (jump_time, rebuild_jump_labels (insns));\n+\t  timevar_push (TV_JUMP);\n+\t  rebuild_jump_labels (insns);\n+\t  timevar_pop (TV_JUMP);\n \t}\n \n       close_dump_file (DFI_combine, print_rtl_with_bb, insns);\n+      timevar_pop (TV_COMBINE);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3314,20 +3140,23 @@ rest_of_compilation (decl)\n      necessary for two-address machines.  */\n   if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n     {\n+      timevar_push (TV_REGMOVE);\n       open_dump_file (DFI_regmove, decl);\n \n-      TIMEVAR (regmove_time, regmove_optimize (insns, max_reg_num (),\n-\t\t\t\t\t       rtl_dump_file));\n+      regmove_optimize (insns, max_reg_num (), rtl_dump_file);\n \n       close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n+      timevar_pop (TV_REGMOVE);\n \n       if (ggc_p)\n \tggc_collect ();\n     }\n \n   if (optimize && n_basic_blocks)\n     {\n-      TIMEVAR (gcse_time, optimize_mode_switching (NULL_PTR));\n+      timevar_push (TV_GCSE);\n+      optimize_mode_switching (NULL_PTR);\n+      timevar_pop (TV_GCSE);\n     }\n \n #ifdef INSN_SCHEDULING\n@@ -3336,14 +3165,16 @@ rest_of_compilation (decl)\n      because doing the sched analysis makes some of the dump.  */\n   if (optimize > 0 && flag_schedule_insns)\n     {\n+      timevar_push (TV_SCHED);\n       open_dump_file (DFI_sched, decl);\n \n       /* Do control and data sched analysis,\n \t and write some of the results to dump file.  */\n \n-      TIMEVAR (sched_time, schedule_insns (rtl_dump_file));\n+      schedule_insns (rtl_dump_file);\n \n       close_dump_file (DFI_sched, print_rtl_with_bb, insns);\n+      timevar_pop (TV_SCHED);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3355,52 +3186,52 @@ rest_of_compilation (decl)\n      epilogue thus changing register elimination offsets.  */\n   current_function_is_leaf = leaf_function_p ();\n \n+  timevar_push (TV_LOCAL_ALLOC);\n   open_dump_file (DFI_lreg, decl);\n \n   /* Allocate pseudo-regs that are used only within 1 basic block. \n \n      RUN_JUMP_AFTER_RELOAD records whether or not we need to rerun the\n      jump optimizer after register allocation and reloading are finished.  */\n \n-  TIMEVAR (local_alloc_time,\n-\t   {\n-\t     /* We recomputed reg usage as part of updating the rest\n-\t\tof life info during sched.  */\n-\t     if (! flag_schedule_insns)\n-\t       recompute_reg_usage (insns, ! optimize_size);\n-\t     regclass (insns, max_reg_num (), rtl_dump_file);\n-\t     rebuild_label_notes_after_reload = local_alloc ();\n-\t   });\n+  /* We recomputed reg usage as part of updating the rest\n+     of life info during sched.  */\n+  if (! flag_schedule_insns)\n+    recompute_reg_usage (insns, ! optimize_size);\n+  regclass (insns, max_reg_num (), rtl_dump_file);\n+  rebuild_label_notes_after_reload = local_alloc ();\n+\n+  timevar_pop (TV_LOCAL_ALLOC);\n \n   if (dump_file[DFI_lreg].enabled)\n     {\n-      TIMEVAR (dump_time,\n-\t       {\n-\t\t dump_flow_info (rtl_dump_file);\n-\t\t dump_local_alloc (rtl_dump_file);\n-\t       });\n+      timevar_push (TV_DUMP);\n+\n+      dump_flow_info (rtl_dump_file);\n+      dump_local_alloc (rtl_dump_file);\n \n       close_dump_file (DFI_lreg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DUMP);\n     }\n \n   if (ggc_p)\n     ggc_collect ();\n \n+  timevar_push (TV_GLOBAL_ALLOC);\n   open_dump_file (DFI_greg, decl);\n \n   /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n      pass fixing up any insns that are invalid.  */\n \n-  TIMEVAR (global_alloc_time,\n-\t   {\n-\t     if (optimize)\n-\t       failure = global_alloc (rtl_dump_file);\n-\t     else\n-\t       {\n-\t\t build_insn_chain (insns);\n-\t\t failure = reload (insns, 0, rtl_dump_file);\n-\t       }\n-\t   });\n+  if (optimize)\n+    failure = global_alloc (rtl_dump_file);\n+  else\n+    {\n+      build_insn_chain (insns);\n+      failure = reload (insns, 0, rtl_dump_file);\n+    }\n+\n+  timevar_pop (TV_GLOBAL_ALLOC);\n \n   if (failure)\n     goto exit_rest_of_compilation;\n@@ -3410,7 +3241,11 @@ rest_of_compilation (decl)\n \n   /* Do a very simple CSE pass over just the hard registers.  */\n   if (optimize > 0)\n-    reload_cse_regs (insns);\n+    {\n+      timevar_push (TV_RELOAD_CSE_REGS);\n+      reload_cse_regs (insns);\n+      timevar_pop (TV_RELOAD_CSE_REGS); \n+    }\n \n   /* If optimizing, then go ahead and split insns now since we are about\n      to recompute flow information anyway.  */\n@@ -3421,22 +3256,30 @@ rest_of_compilation (decl)\n      a direct jump.  If so, we must rebuild the JUMP_LABEL fields of\n      jumping instructions.  */\n   if (rebuild_label_notes_after_reload)\n-    TIMEVAR (jump_time, rebuild_jump_labels (insns));\n+    {\n+      timevar_push (TV_JUMP);\n+\n+      rebuild_jump_labels (insns);\n+\n+      timevar_pop (TV_JUMP);\n+    }\n \n   if (dump_file[DFI_greg].enabled)\n     {\n-      TIMEVAR (dump_time, dump_global_regs (rtl_dump_file));\n+      timevar_push (TV_DUMP);\n+\n+      dump_global_regs (rtl_dump_file);\n+\n       close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DUMP);\n     }\n \n   /* Re-create the death notes which were deleted during reload.  */\n+  timevar_push (TV_FLOW2);\n   open_dump_file (DFI_flow2, decl);\n-  \n-  TIMEVAR (flow2_time,\n-\t   {\n-\t     jump_optimize_minimal (insns);\n-\t     find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-\t   });\n+\n+  jump_optimize_minimal (insns);\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \n   /* On some machines, the prologue and epilogue code, or parts thereof,\n      can be represented as RTL.  Doing so lets us schedule insns between\n@@ -3446,11 +3289,8 @@ rest_of_compilation (decl)\n \n   if (optimize)\n     {\n-      TIMEVAR (flow2_time,\n-\t       {\n-\t\t cleanup_cfg (insns);\n-\t\t life_analysis (insns, rtl_dump_file, PROP_FINAL);\n-\t       });\n+      cleanup_cfg (insns);\n+      life_analysis (insns, rtl_dump_file, PROP_FINAL);\n \n       /* This is kind of heruistics.  We need to run combine_stack_adjustments\n          even for machines with possibly nonzero RETURN_POPS_ARGS\n@@ -3459,7 +3299,7 @@ rest_of_compilation (decl)\n #ifndef PUSH_ROUNDING\n       if (!ACCUMULATE_OUTGOING_ARGS)\n #endif\n-\tTIMEVAR (flow2_time, { combine_stack_adjustments (); });\n+\tcombine_stack_adjustments ();\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3468,29 +3308,34 @@ rest_of_compilation (decl)\n   flow2_completed = 1;\n \n   close_dump_file (DFI_flow2, print_rtl_with_bb, insns);\n+  timevar_pop (TV_FLOW2);\n \n #ifdef HAVE_peephole2\n   if (optimize > 0 && flag_peephole2)\n     {\n-      open_dump_file (DFI_peephole2, decl);\n+      timevar_push (TV_PEEPHOLE2);\n \n-      TIMEVAR (peephole2_time, peephole2_optimize (rtl_dump_file));\n+      open_dump_file (DFI_peephole2, decl);\n+      peephole2_optimize (rtl_dump_file);\n \n       close_dump_file (DFI_peephole2, print_rtl_with_bb, insns);\n+      timevar_pop (TV_PEEPHOLE2);\n     }\n #endif\n \n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n+      timevar_push (TV_SCHED2);\n       open_dump_file (DFI_sched2, decl);\n \n       /* Do control and data sched analysis again,\n \t and write some more of the results to dump file.  */\n \n-      TIMEVAR (sched2_time, schedule_insns (rtl_dump_file));\n+      schedule_insns (rtl_dump_file);\n \n       close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n+      timevar_pop (TV_SCHED2);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3504,34 +3349,39 @@ rest_of_compilation (decl)\n \n   if (optimize > 0 && flag_reorder_blocks)\n     {\n+      timevar_push (TV_REORDER_BLOCKS);\n       open_dump_file (DFI_bbro, decl);\n \n-      TIMEVAR (reorder_blocks_time, reorder_basic_blocks ());\n+      reorder_basic_blocks ();\n \n       close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n+      timevar_pop (TV_REORDER_BLOCKS);\n     }    \n \n   if (optimize > 0 && flag_rename_registers)\n     {\n+      timevar_push (TV_RENAME_REGISTERS);\n       open_dump_file (DFI_rnreg, decl);\n \n-      TIMEVAR (rename_registers_time, regrename_optimize ());\n+      regrename_optimize ();\n \n       close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_RENAME_REGISTERS);\n     }    \n \n   /* One more attempt to remove jumps to .+1 left by dead-store elimination. \n      Also do cross-jumping this time and delete no-op move insns.  */\n \n   if (optimize > 0)\n     {\n+      timevar_push (TV_JUMP);\n       open_dump_file (DFI_jump2, decl);\n \n-      TIMEVAR (jump_time, jump_optimize (insns, JUMP_CROSS_JUMP,\n-\t\t\t\t\t JUMP_NOOP_MOVES,\n-\t\t\t\t\t !JUMP_AFTER_REGSCAN));\n+      jump_optimize (insns, JUMP_CROSS_JUMP, JUMP_NOOP_MOVES, \n+\t\t     !JUMP_AFTER_REGSCAN);\n \n       close_dump_file (DFI_jump2, print_rtl_with_bb, insns);\n+      timevar_pop (TV_JUMP);\n     }\n \n   /* If a machine dependent reorganization is needed, call it.  */\n@@ -3552,15 +3402,13 @@ rest_of_compilation (decl)\n #ifdef DELAY_SLOTS\n   if (optimize > 0 && flag_delayed_branch)\n     {\n+      timevar_push (TV_DBR_SCHED);\n       open_dump_file (DFI_dbr, decl);\n \n-      TIMEVAR\n-\t(dbr_sched_time,\n-\t {\n-           dbr_schedule (insns, rtl_dump_file);\n-\t });\n+      dbr_schedule (insns, rtl_dump_file);\n \n       close_dump_file (DFI_dbr, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DBR_SCHED);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3571,14 +3419,18 @@ rest_of_compilation (decl)\n \n      Note this must run before reg-stack because of death note (ab)use\n      in the ia32 backend.  */\n-  TIMEVAR (shorten_branch_time, shorten_branches (get_insns ()));\n+  timevar_push (TV_SHORTEN_BRANCH);\n+  shorten_branches (get_insns ());\n+  timevar_pop (TV_SHORTEN_BRANCH);\n \n #ifdef STACK_REGS\n+  timevar_push (TV_REG_STACK);\n   open_dump_file (DFI_stack, decl);\n \n-  TIMEVAR (stack_reg_time, reg_to_stack (insns, rtl_dump_file));\n+  reg_to_stack (insns, rtl_dump_file);\n \n   close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n+  timevar_pop (TV_REG_STACK);\n \n   if (ggc_p)\n     ggc_collect ();\n@@ -3592,37 +3444,38 @@ rest_of_compilation (decl)\n \n   /* Now turn the rtl into assembler code.  */\n \n-  TIMEVAR (final_time,\n-\t   {\n-\t     rtx x;\n-\t     const char *fnname;\n+  timevar_push (TV_FINAL);\n+  {\n+    rtx x;\n+    const char *fnname;\n \n-\t     /* Get the function's name, as described by its RTL.\n+    /* Get the function's name, as described by its RTL.\n \t\tThis may be different from the DECL_NAME name used\n \t\tin the source file.  */\n \n-\t     x = DECL_RTL (decl);\n-\t     if (GET_CODE (x) != MEM)\n-\t       abort ();\n-\t     x = XEXP (x, 0);\n-\t     if (GET_CODE (x) != SYMBOL_REF)\n-\t       abort ();\n-\t     fnname = XSTR (x, 0);\n-\n-\t     assemble_start_function (decl, fnname);\n-\t     final_start_function (insns, asm_out_file, optimize);\n-\t     final (insns, asm_out_file, optimize, 0);\n-\t     final_end_function (insns, asm_out_file, optimize);\n-\t     assemble_end_function (decl, fnname);\n-\t     if (! quiet_flag)\n-\t       fflush (asm_out_file);\n+    x = DECL_RTL (decl);\n+    if (GET_CODE (x) != MEM)\n+      abort ();\n+    x = XEXP (x, 0);\n+    if (GET_CODE (x) != SYMBOL_REF)\n+      abort ();\n+    fnname = XSTR (x, 0);\n+\n+    assemble_start_function (decl, fnname);\n+    final_start_function (insns, asm_out_file, optimize);\n+    final (insns, asm_out_file, optimize, 0);\n+    final_end_function (insns, asm_out_file, optimize);\n+    assemble_end_function (decl, fnname);\n+    if (! quiet_flag)\n+      fflush (asm_out_file);\n \n \t     /* Release all memory allocated by flow.  */\n-\t     free_basic_block_vars (0);\n+    free_basic_block_vars (0);\n \n-\t     /* Release all memory held by regsets now */\n-\t     regset_release_memory ();\n-\t   });\n+    /* Release all memory held by regsets now */\n+    regset_release_memory ();\n+  }\n+  timevar_pop (TV_FINAL);\n \n   if (ggc_p)\n     ggc_collect ();\n@@ -3637,20 +3490,22 @@ rest_of_compilation (decl)\n      for those inline functions that need to have out-of-line copies\n      generated.  During that call, we *will* be routed past here.  */\n \n+  timevar_push (TV_SYMOUT);\n #ifdef DBX_DEBUGGING_INFO\n   if (write_symbols == DBX_DEBUG)\n-    TIMEVAR (symout_time, dbxout_function (decl));\n+    dbxout_function (decl);\n #endif\n \n #ifdef DWARF_DEBUGGING_INFO\n   if (write_symbols == DWARF_DEBUG)\n-    TIMEVAR (symout_time, dwarfout_file_scope_decl (decl, 0));\n+    dwarfout_file_scope_decl (decl, 0);\n #endif\n \n #ifdef DWARF2_DEBUGGING_INFO\n   if (write_symbols == DWARF2_DEBUG)\n-    TIMEVAR (symout_time, dwarf2out_decl (decl));\n+    dwarf2out_decl (decl);\n #endif\n+  timevar_pop (TV_SYMOUT);\n \n  exit_rest_of_compilation:\n \n@@ -3666,24 +3521,25 @@ rest_of_compilation (decl)\n   flow2_completed = 0;\n   no_new_pseudos = 0;\n \n-  TIMEVAR (final_time,\n-\t   {\n-\t      /* Clear out the insn_length contents now that they are no\n-\t\t longer valid.  */\n-\t      init_insn_lengths ();\n+  timevar_push (TV_FINAL);\n+\n+  /* Clear out the insn_length contents now that they are no\n+     longer valid.  */\n+  init_insn_lengths ();\n \n-\t      /* Clear out the real_constant_chain before some of the rtx's\n+  /* Clear out the real_constant_chain before some of the rtx's\n \t\t it runs through become garbage.  */\n-\t      clear_const_double_mem ();\n+  clear_const_double_mem ();\n \n-\t      /* Cancel the effect of rtl_in_current_obstack.  */\n-\t      resume_temporary_allocation ();\n+  /* Cancel the effect of rtl_in_current_obstack.  */\n+  resume_temporary_allocation ();\n \n-\t      /* Show no temporary slots allocated.  */\n-\t      init_temp_slots ();\n+  /* Show no temporary slots allocated.  */\n+  init_temp_slots ();\n \n-\t      free_basic_block_vars (0);\n-\t   });\n+  free_basic_block_vars (0);\n+\n+  timevar_pop (TV_FINAL);\n \n   /* Make sure volatile mem refs aren't considered valid operands for\n      arithmetic insns.  We must call this here if this is a nested inline\n@@ -3705,10 +3561,7 @@ rest_of_compilation (decl)\n   if (ggc_p)\n     ggc_collect ();\n \n-  /* The parsing time is all the time spent in yyparse\n-     *except* what is spent in this function.  */\n-\n-  parse_time -= get_run_time () - start_time;\n+  timevar_pop (TV_REST_OF_COMPILATION);\n }\n \f\n static void"}, {"sha": "e5a06fff093ba12cbaa75c03dc5d4c26039fd4c5", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9a326b172ca61ab8e1c4f60e81fb1df20364a1/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=2a9a326b172ca61ab8e1c4f60e81fb1df20364a1", "patch": "@@ -26,10 +26,6 @@ union tree_node;\n struct rtx_def;\n #endif\n \n-extern long gc_time;\n-extern long parse_time;\n-extern long varconst_time;\n-\n extern int read_integral_parameter\tPARAMS ((const char *, const char *,\n \t\t\t\t\t\tconst int));\n extern int count_error\t\t\tPARAMS ((int));"}]}