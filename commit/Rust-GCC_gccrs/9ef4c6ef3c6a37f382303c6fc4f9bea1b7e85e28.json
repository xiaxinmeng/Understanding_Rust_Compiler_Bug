{"sha": "9ef4c6ef3c6a37f382303c6fc4f9bea1b7e85e28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVmNGM2ZWYzYzZhMzdmMzgyMzAzYzZmYzRmOWJlYTFiN2U4NWUyOA==", "commit": {"author": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-09-06T05:52:01Z"}, "committer": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-09-06T05:52:01Z"}, "message": "final.c (final): If a label is reached only from a single jump...\n\nd\n\t* final.c (final): If a label is reached only from a single jump,\n\tcall NOTICE_UPDATE_CC on the jump and its predecessor before\n\temitting the insn after the label.\n\t* i386.h: Add AMD K6 support.\n\tChange TARGET_* macros to use table lookup.\n\t(INITIALIZE_TRAMPOLINE): Improve trampoline code.\n\t(ADJUST_COST): Change definition to call function in i386.c.\n\t(ISSUE_RATE): Define as 2 for anything newer than an 80486.\n\t* i386.c: Add AMD K6 support.\n\tAdd constants for feature tests used by TARGET_* macros.\n\t(split_di): If before reload, call gen_lowpart and gen_highpart.\n\t(x86_adjust_cost): New function.\n\t(put_jump_code): New function.\n\t(print_operand): New codes 'D' and 'd'.\n\t* i386.md: New insn types.  New insn attribute \"memory\".\n\tRedefine scheduling parameters to use new types and add AMD K6\n\tsupport.  Explicitly set type of most insns.\n\t(move insns): K6 prefers movl $0,reg to xorl reg,reg.  Pentium\n\tPro and K6 prefer movl $1,reg to incl reg.\n\t(adddi3, subdi3): Set cc_status.\n\t(DImode shift patterns): Change label counters from HOST_WIDE_INT\n\tto int; x86 can't have more than 2^31 DImode shifts per\tfile.\n\t(setcc): Combine all setcc patterns.  Allow writing memory.\n\tCombine all jump patterns using match_operator.\n\t(*bzero): Name pattern.  Emit mutliple stos instructions when that\n\tis faster than rep stos.\n\t(xordi3, anddi3, iordi3): Simplify DImode logical patterns and\n\tadd define_split.\n\t* ch/Make-lang.in: Comment ^L characters.  Sun make doesn't like them.\n\nFrom-SVN: r22290", "tree": {"sha": "ac886893cda3c276920c570b5da1725d53046427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac886893cda3c276920c570b5da1725d53046427"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ef4c6ef3c6a37f382303c6fc4f9bea1b7e85e28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef4c6ef3c6a37f382303c6fc4f9bea1b7e85e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ef4c6ef3c6a37f382303c6fc4f9bea1b7e85e28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef4c6ef3c6a37f382303c6fc4f9bea1b7e85e28/comments", "author": null, "committer": null, "parents": [{"sha": "0d83c20351c5e7557ce5b8eaf48d9bdcd373181b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d83c20351c5e7557ce5b8eaf48d9bdcd373181b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d83c20351c5e7557ce5b8eaf48d9bdcd373181b"}], "stats": {"total": 35, "additions": 35, "deletions": 0}, "files": [{"sha": "454ab6c71f5bfe0ca6d8b417414e6c370216ec67", "filename": "gcc/final.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef4c6ef3c6a37f382303c6fc4f9bea1b7e85e28/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef4c6ef3c6a37f382303c6fc4f9bea1b7e85e28/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=9ef4c6ef3c6a37f382303c6fc4f9bea1b7e85e28", "patch": "@@ -1980,6 +1980,18 @@ final (first, file, optimize, prescan)\n         max_uid = INSN_UID (insn);\n       if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n         line_note_exists[NOTE_LINE_NUMBER (insn)] = 1;\n+#ifdef HAVE_cc0\n+      /* If CC tracking across branches is enabled, record the insn which\n+\t jumps to each branch only reached from one place.  */\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\t{\n+\t  rtx lab = JUMP_LABEL (insn);\n+\t  if (lab && LABEL_NUSES (lab) == 1)\n+\t    {\n+\t      LABEL_REFS (lab) = insn;\n+\t    }\n+\t}\n+#endif\n     }\n \n   /* Initialize insn_eh_region table if eh is being used. */\n@@ -2283,7 +2295,30 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    ASM_OUTPUT_ALIGN (file, align);\n #endif\n \t}\n+#ifdef HAVE_cc0\n       CC_STATUS_INIT;\n+      /* If this label is reached from only one place, set the condition\n+\t codes from the instruction just before the branch.  */\n+      if (LABEL_NUSES (insn) == 1)\n+\t{\n+\t  rtx jump = LABEL_REFS (insn);\n+\t  rtx barrier = prev_nonnote_insn (insn);\n+\t  rtx prev;\n+\t  /* If the LABEL_REFS field of this label has been set to point\n+\t     at a branch, the predecessor of the branch is a regular\n+\t     insn, and that branch is the only way to reach this label,\n+\t     set the condition codes based on the branch and its\n+\t     predecessor.  */\n+\t  if (barrier && GET_CODE (barrier) == BARRIER\n+\t      && jump && GET_CODE (jump) == JUMP_INSN\n+\t      && (prev = prev_nonnote_insn (jump))\n+\t      && GET_CODE (prev) == INSN)\n+\t    {\n+\t      NOTICE_UPDATE_CC (PATTERN (prev), prev);\n+\t      NOTICE_UPDATE_CC (PATTERN (jump), jump);\n+\t    }\n+\t}\n+#endif\n       if (prescan > 0)\n \tbreak;\n       new_block = 1;"}]}