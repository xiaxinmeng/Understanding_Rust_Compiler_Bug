{"sha": "f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcwZjNmN2U5ZmJmMWMwYTc3MDAxN2NmNmJhM2YwNTg4NmU2MmJkMA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-07-29T18:04:42Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-07-29T18:04:42Z"}, "message": "lwg-active.html, [...]: Import Revision 31.\n\n2004-07-29  Paolo Carlini  <pcarlini@suse.de>\n\n\t* docs/html/ext/lwg-active.html, lwg-defects.html: Import Revision 31.\n\nFrom-SVN: r85310", "tree": {"sha": "3bf702f2db9b3612e3ede71cb4614a112fb9fb91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bf702f2db9b3612e3ede71cb4614a112fb9fb91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0/comments", "author": null, "committer": null, "parents": [{"sha": "4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e"}], "stats": {"total": 1081, "additions": 1025, "deletions": 56}, "files": [{"sha": "e58e61d91de74c15d87933ae97a4873d3f912806", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0", "patch": "@@ -1,3 +1,7 @@\n+2004-07-29  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* docs/html/ext/lwg-active.html, lwg-defects.html: Import Revision 31.\n+\n 2004-07-29  Paolo Carlini  <pcarlini@suse.de>\n             Petur Runolfsson  <peturr02@ru.is>\n "}, {"sha": "148e32f9baf9753fecde05778c0b7271850cdcc1", "filename": "libstdc++-v3/docs/html/ext/lwg-active.html", "status": "modified", "additions": 1008, "deletions": 53, "changes": 1061, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html?ref=f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0", "patch": "@@ -5,11 +5,11 @@\n <table>\n <tr>\n <td align=\"left\">Doc. no.</td>\n-<td align=\"left\">N1635=04-0075</td>\n+<td align=\"left\">N1657=04-0097</td>\n </tr>\n <tr>\n <td align=\"left\">Date:</td>\n-<td align=\"left\">12 Apr 2004</td>\n+<td align=\"left\">16 Jul 2004</td>\n </tr>\n <tr>\n <td align=\"left\">Project:</td>\n@@ -20,7 +20,7 @@\n <td align=\"left\">Matt Austern &lt;austern@apple.com&gt;</td>\n </tr>\n </table>\n-<h1>C++ Standard Library Active Issues List (Revision 30)</h1>\n+<h1>C++ Standard Library Active Issues List (Revision 31)</h1>\n   <p>Reference ISO/IEC IS 14882:1998(E)</p>\n   <p>Also see:</p>\n   <ul>\n@@ -88,6 +88,11 @@ <h1>C++ Standard Library Active Issues List (Revision 30)</h1>\n   directory as the issues list files.  </p>\n <h2>Revision History</h2>\n <ul>\n+<li>R31: \n+2004-07 mid-term mailing: reflects new proposed resolutions and\n+new issues received after the post-Sydney mailing.  Added\n+new issues <a href=\"lwg-active.html#463\">463</a>-<a href=\"lwg-active.html#478\">478</a>.\n+</li>\n <li>R30: \n Post-Sydney mailing: reflects decisions made at the Sydney meeting.\n Voted all \"Ready\" issues from R29 into the working paper.\n@@ -2080,7 +2085,7 @@ <h2>Active Issues</h2>\n   Someone who understands string replace well needs to work on\n   this.]</i></p>\n <hr>\n-<a name=\"369\"><h3>369.&nbsp;io stream objects and static ctors</h3></a><p><b>Section:</b>&nbsp;27.3 <a href=\"lib-iostreams.html#lib.iostream.objects\"> [lib.iostream.objects]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Ruslan Abdikeev&nbsp; <b>Date:</b>&nbsp;8 Jul 2002</p>\n+<a name=\"369\"><h3>369.&nbsp;io stream objects and static ctors</h3></a><p><b>Section:</b>&nbsp;27.3 <a href=\"lib-iostreams.html#lib.iostream.objects\"> [lib.iostream.objects]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Review\">Review</a>&nbsp; <b>Submitter:</b>&nbsp;Ruslan Abdikeev&nbsp; <b>Date:</b>&nbsp;8 Jul 2002</p>\n <p>\n Is it safe to use standard iostream objects from constructors of\n static objects?  Are standard iostream objects constructed and are\n@@ -2145,36 +2150,63 @@ <h2>Active Issues</h2>\n mention of an _instance_ of ios_base::Init in Standard.\n </p>\n <p><b>Proposed resolution:</b></p>\n-<p>\n-At the end of header &lt;iostream&gt; synopsis in 27.3 <a href=\"lib-iostreams.html#lib.iostream.objects\"> [lib.iostream.objects]</a>\n-</p>\n-\n-<pre>\n-       namespace std\n-       {\n-          ... extern istream cin; ...\n-</pre>\n-\n-<p>add the following lines</p>\n-\n-<pre>\n-          namespace\n-          {\n-             ios_base::Init &lt;some_implementation_defined_name&gt;;\n-          }\n-        }\n-</pre>\n+<p>Add to [lib.iostream.objects], p2, immediately before the last sentence\n+of the paragraph, the following two sentences:</p>\n+<blockquote>\n+It is implementation-defined whether the header &lt;iostream&gt; defines\n+an ios_base::Init object or not. If it does not, an implementation\n+must specify the means of achieving safe access to the standard\n+objects for input and output during program startup.\n+</blockquote>\n \n <p><i>[Santa Cruz: The LWG is leaning toward NAD.  There isn't any\n normative wording saying that the Init scheme will be used, but that\n is probably intentional.  Implementers use dirty tricks for iostream\n initialization, and doing it portably is somewhere between difficult\n and impossible.  Too much constraint in this area is dangerous, and if\n we are to make any changes it would probably be more appropriate\n-forthem to be nonnormative.  Martin will try to come up with clearer\n-wording that expreses this intent.]</i></p>\n-\n-\n+for them to be nonnormative.  Summer '04 mid-meeting mailing: Martin\n+provided wording for resolution and rationale.]</i></p>\n+<p><b>Rationale:</b></p>\n+<p>\n+The original proposed resolution unconditionally required\n+implementations to define an ios_base::Init object of some\n+implementation-defined name in the header &lt;iostream&gt;. That's an\n+overspecification. First, defining the object may be unnecessary\n+and even detrimental to performance if an implementation can\n+guarantee that the 8 standard iostream objects will be initialized\n+before any other user-defined object in a program. Second, there\n+is no need to require implementations to document the name of the\n+object.</p>\n+\n+<p>\n+The new proposed resolution specifies that implementations may\n+(but need not) define an ios_base::Init object, while requiring\n+them to document whether they do or not, and if not, to document\n+how portable programs achieve safe access to the 8 standard iostream\n+objects during program startup (3.6)(*). The intent is that if an\n+implementation documents that &lt;iostream&gt; defines an ios_base::Init\n+object, it implies that the header must be #included before any\n+references to the standard iostream objects. Otherwise, if an\n+implementation does not define an ios_base::Init object in\n+&lt;iostream&gt; it must either assure and document that the standard\n+iostream objects are safely accessible at startup, or specify what\n+a portable program must do to safely access them (e.g., it may\n+require that a program define an ios_base::Init object before\n+doing so, or that it call ios::sync_with_stdio(), etc.).\n+</p>\n+\n+<p>\n+(*) Note that the term startup is broader than the term \"Constructors\n+and destructors for static objects\" used in Footnote 265 since the\n+former includes other functions besides constructors and destructors,\n+including the following example:\n+</p>\n+<pre>\n+    int foo () { return (std::cout &lt;&lt; \"foo()\\n\").rdstate (); }\n+    int i = foo ();\n+    int main () { return i; }\n+</pre>\n <hr>\n <a name=\"371\"><h3>371.&nbsp;Stability of multiset and multimap member functions</h3></a><p><b>Section:</b>&nbsp;23.1 <a href=\"lib-containers.html#lib.container.requirements\"> [lib.container.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Frank Compagner&nbsp; <b>Date:</b>&nbsp;20 Jul 2002</p>\n <p>\n@@ -2277,7 +2309,7 @@ <h2>Active Issues</h2>\n \n <p><b>Proposed resolution:</b></p>\n <hr>\n-<a name=\"378\"><h3>378.&nbsp;locale immutability and locale::operator=()</h3></a><p><b>Section:</b>&nbsp;22.1.1 <a href=\"lib-locales.html#lib.locale\"> [lib.locale]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;6 Sep 2002</p>\n+<a name=\"378\"><h3>378.&nbsp;locale immutability and locale::operator=()</h3></a><p><b>Section:</b>&nbsp;22.1.1 <a href=\"lib-locales.html#lib.locale\"> [lib.locale]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Review\">Review</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;6 Sep 2002</p>\n <p>\n I think there is a problem with 22.1.1, p6 which says that\n </p>\n@@ -2310,20 +2342,10 @@ <h2>Active Issues</h2>\n out of scope?\n </p>\n <p><b>Proposed resolution:</b></p>\n-<p>\n-Suggest to replace 22.1.1 <a href=\"lib-locales.html#lib.locale\"> [lib.locale]</a>, p6 with\n-</p>\n-<pre>\n-    -6- Unless assigned a new value, locale objects are immutable;\n-        once a facet reference is obtained from it, that reference\n-        remains usable as long as the locale object itself exists\n-        or until the locale object is assigned the value of another,\n-        distinct locale object.\n-</pre>\n-\n-<p><i>[Santa Cruz: Dietmar agrees with this general direction, but is\n-uncomfortable about the proposed wording.  He and Martin will try to\n-come up with better wording.]</i></p>\n+<p><i>[Summer '04 mid-meeting mailing: Martin and Dietmar believe this\n+  is a duplicate of issue <a href=\"lwg-defects.html#31\">31</a> and recommend that it be\n+  closed.\n+]</i></p>\n \n <hr>\n <a name=\"382\"><h3>382.&nbsp;codecvt do_in/out result</h3></a><p><b>Section:</b>&nbsp;22.2.1.5 <a href=\"lib-locales.html#lib.locale.codecvt\"> [lib.locale.codecvt]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;30 Aug  2002</p>\n@@ -2581,7 +2603,7 @@ <h2>Active Issues</h2>\n not be allowed.\n ]</i></p>\n <hr>\n-<a name=\"386\"><h3>386.&nbsp;Reverse iterator's operator[] has impossible return type</h3></a><p><b>Section:</b>&nbsp;24.4.1.3.11 <a href=\"lib-iterators.html#lib.reverse.iter.opindex\"> [lib.reverse.iter.opindex]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;23 Oct 2002</p>\n+<a name=\"386\"><h3>386.&nbsp;Reverse iterator's operator[] has impossible return type</h3></a><p><b>Section:</b>&nbsp;24.4.1.3.11 <a href=\"lib-iterators.html#lib.reverse.iter.opindex\"> [lib.reverse.iter.opindex]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Review\">Review</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;23 Oct 2002</p>\n <p>In 24.4.1.3.11 <a href=\"lib-iterators.html#lib.reverse.iter.opindex\"> [lib.reverse.iter.opindex]</a>, <tt>reverse_iterator&lt;&gt;::operator[]</tt> \n is specified as having a return type of <tt>reverse_iterator::reference</tt>,\n which is the same as <tt>iterator_traits&lt;Iterator&gt;::reference</tt>.\n@@ -2594,8 +2616,37 @@ <h2>Active Issues</h2>\n   to <tt>Iterator</tt>'s value type.  The return type specified for\n   reverse_iterator's operator[] would thus appear to be impossible.</p>\n \n-<p>Related issue: <a href=\"lwg-active.html#299\">299</a>.  Jeremy will work on this.</p>\n+<p>With the resolution of issue <a href=\"lwg-active.html#299\">299</a>, the type of\n+  <tt>a[n]</tt> will continue to be required (for random access\n+  iterators) to be convertible to the value type, and also <tt>a[n] =\n+  t</tt> will be a valid expression.  Implementations of\n+  <tt>reverse_iterator</tt> will likely need to return a proxy from\n+  <tt>operator[]</tt> to meet these requirements. As mentioned in the\n+  comment from Dave Abrahams, the simplest way to specify that\n+  <tt>reverse_iterator</tt> meet this requirement to just mandate\n+  it and leave the return type of <tt>operator[]</tt> unspecified.</p>\n+\n <p><b>Proposed resolution:</b></p>\n+\n+<p>In 24.4.1.2 <a href=\"lib-iterators.html#lib.reverse.iter.requirements\"> [lib.reverse.iter.requirements]</a> change:</p>\n+\n+<blockquote>\n+<pre>\n+reference operator[](difference_type n) const;\n+</pre>\n+</blockquote>\n+\n+<p>to:</p>\n+\n+<blockquote>\n+<pre>\n+<b><i>implementation defined</i></b> operator[](difference_type n) const; // see <font color=\"red\">lib.random.access.iterators</font>\n+</pre>\n+</blockquote>\n+\n+\n+\n+\n <p><i>[\n Comments from Dave Abrahams: IMO we should resolve 386 by just saying\n     that the return type of reverse_iterator's operator[] is\n@@ -4451,7 +4502,7 @@ <h2>Active Issues</h2>\n uninitialized characters.  Positioning is only allowable over the\n initialized range.</p>\n <hr>\n-<a name=\"434\"><h3>434.&nbsp;bitset::to_string() hard to use</h3></a><p><b>Section:</b>&nbsp;23.3.5.2 <a href=\"lib-containers.html#lib.bitset.members\"> [lib.bitset.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;15 Oct 2003</p>\n+<a name=\"434\"><h3>434.&nbsp;bitset::to_string() hard to use</h3></a><p><b>Section:</b>&nbsp;23.3.5.2 <a href=\"lib-containers.html#lib.bitset.members\"> [lib.bitset.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Review\">Review</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;15 Oct 2003</p>\n <p>\n It has been pointed out a number of times that the bitset to_string() member\n function template is tedious to use since callers must explicitly specify the\n@@ -4486,10 +4537,10 @@ <h2>Active Issues</h2>\n </pre>\n \n <p><i>[Kona: the LWG agrees that this is an improvement over the\n-  status quo.  Dietmar will propose an alternative using a proxy\n-  object, so that \"s = b.to_string()\" would work not just when s is\n-  of type std::string, but when s is of type std::basic_string&lt;C,T&gt;\n-  for arbitrary types C and T.]</i></p>\n+  status quo.  Dietmar thought about an alternative using a proxy\n+  object but now believes that the proposed resolution above is the\n+  right choice.\n+]</i></p>\n \n <hr>\n <a name=\"435\"><h3>435.&nbsp;bug in DR 25</h3></a><p><b>Section:</b>&nbsp;21.3.7.9 <a href=\"lib-strings.html#lib.string.io\"> [lib.string.io]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Ready\">Ready</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;15 Oct 2003</p>\n@@ -4914,7 +4965,7 @@ <h2>Active Issues</h2>\n Change overflow(EOF) to overflow(traits::eof()).\n </p>\n <hr>\n-<a name=\"444\"><h3>444.&nbsp;Bad use of casts in fstream</h3></a><p><b>Section:</b>&nbsp;27.8.1 <a href=\"lib-iostreams.html#lib.fstreams\"> [lib.fstreams]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Vincent Leloup&nbsp; <b>Date:</b>&nbsp;20 Nov 2003</p>\n+<a name=\"444\"><h3>444.&nbsp;Bad use of casts in fstream</h3></a><p><b>Section:</b>&nbsp;27.8.1 <a href=\"lib-iostreams.html#lib.fstreams\"> [lib.fstreams]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Review\">Review</a>&nbsp; <b>Submitter:</b>&nbsp;Vincent Leloup&nbsp; <b>Date:</b>&nbsp;20 Nov 2003</p>\n <p>\n 27.8.1.7 <a href=\"lib-iostreams.html#lib.ifstream.members\"> [lib.ifstream.members]</a> p1, 27.8.1.10 <a href=\"lib-iostreams.html#lib.ofstream.members\"> [lib.ofstream.members]</a> p1, 27.8.1.13 <a href=\"lib-iostreams.html#lib.fstream.members\"> [lib.fstream.members]</a> p1 seems have same problem as exposed in LWG issue\n <a href=\"lwg-defects.html#252\">252</a>.\n@@ -4959,7 +5010,7 @@ <h2>Active Issues</h2>\n \n \n <hr>\n-<a name=\"445\"><h3>445.&nbsp;iterator_traits::reference unspecified for some iterator categories</h3></a><p><b>Section:</b>&nbsp;24.3.1 <a href=\"lib-iterators.html#lib.iterator.traits\"> [lib.iterator.traits]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;9 Dec 2003</p>\n+<a name=\"445\"><h3>445.&nbsp;iterator_traits::reference unspecified for some iterator categories</h3></a><p><b>Section:</b>&nbsp;24.3.1 <a href=\"lib-iterators.html#lib.iterator.traits\"> [lib.iterator.traits]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#Review\">Review</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;9 Dec 2003</p>\n <p>\n The standard places no restrictions at all on the reference type\n of input, output, or forward iterators (for forward iterators it\n@@ -5004,11 +5055,113 @@ <h2>Active Issues</h2>\n reference.\n </p>\n \n+\n+<p>\n+(Jeremy Siek) During the discussion in Sydney, it was felt that a\n+simpler long term solution for this was needed. The solution proposed\n+was to require <tt>reference</tt> to be the same type as <tt>*a</tt>\n+and <tt>pointer</tt> to be the same type as <tt>a-&gt;</tt>.  Most\n+iterators in the Standard Library already meet this requirement. Some\n+iterators are output iterators, and do not need to meet the\n+requirement, and others are only specified through the general\n+iterator requirements (which will change with this resolution). The\n+sole case where there is an explicit definition of the reference type\n+that will need to change is <tt>istreambuf_iterator</tt> which returns\n+<tt>charT</tt> from <tt>operator*</tt> but has a reference type of\n+<tt>charT&amp;</tt>. We propose changing the reference type of\n+<tt>istreambuf_iterator</tt> to <tt>charT</tt>.\n+</p>\n+\n+<p>The other option for resolving the issue with <tt>pointer</tt>,\n+  mentioned in the note below, is to remove <tt>pointer</tt>\n+  altogether. I prefer placing requirements on <tt>pointer</tt> to\n+  removing it for two reasons. First, <tt>pointer</tt> will become\n+  useful for implementing iterator adaptors and in particular,\n+  <tt>reverse_iterator</tt> will become more well defined. Second,\n+  removing <tt>pointer</tt> is a rather drastic and publicly-visible\n+  action to take.</p>\n+\n+<p>The proposed resolution technically enlarges the requirements for\n+iterators, which means there are existing iterators (such as\n+<tt>istreambuf_iterator</tt>, and potentially some programmer-defined\n+iterators) that will no longer meet the requirements. Will this break\n+existing code? The scenario in which it would is if an algorithm\n+implementation (say in the Standard Library) is changed to rely on\n+<tt>iterator_traits::reference</tt>, and then is used with one of the\n+iterators that do not have an appropriately defined\n+<tt>iterator_traits::reference</tt>.\n+</p>\n+\n+\n+<p>The proposed resolution makes one other subtle change. Previously,\n+it was required that output iterators have a <tt>difference_type</tt>\n+and <tt>value_type</tt> of <tt>void</tt>, which means that a forward\n+iterator could not be an output iterator. This is clearly a mistake,\n+so I've changed the wording to say that those types may be\n+<tt>void</tt>.\n+</p>\n+\n <p><b>Proposed resolution:</b></p>\n \n+<p>In <font color=\"red\">24.3.1.1</font>, after:</p>\n+\n+<blockquote>\n+be defined as the iterator's difference type, value type and iterator\n+category, respectively.\n+</blockquote>\n+\n+<p>In <font color=\"red\">24.3.1.1</font>, add:</p>\n+\n+<blockquote>\n+In addition, the types\n+<pre>\n+iterator_traits&lt;Iterator&gt;::reference\n+iterator_traits&lt;Iterator&gt;::pointer\n+</pre>\n+must be defined as the iterator's reference and pointer types, that\n+is, the same type as the type of <tt>*a</tt> and <tt>a-&gt;</tt>,\n+respectively.\n+</blockquote>\n+\n+<p>In <font color=\"red\">24.3.1.1</font>, change:</p>\n+\n+<blockquote>\n+In the case of an output iterator, the types\n+<pre>\n+iterator_traits&lt;Iterator&gt;::difference_type\n+iterator_traits&lt;Iterator&gt;::value_type\n+</pre>\n+are both defined as <tt>void</tt>.\n+</blockquote>\n+\n+<p>to:</p>\n+<blockquote>\n+In the case of an output iterator, the types\n+<pre>\n+iterator_traits&lt;Iterator&gt;::difference_type\n+iterator_traits&lt;Iterator&gt;::value_type\n+iterator_traits&lt;Iterator&gt;::reference\n+iterator_traits&lt;Iterator&gt;::pointer\n+</pre>\n+may be defined as <tt>void</tt>.\n+</blockquote>\n+\n+<p>In <font color=\"red\">24.5.6</font>, change:</p>\n+<blockquote>\n+<pre>\n+typename traits::off_type, charT*, charT&amp;&gt;\n+</pre>\n+</blockquote>\n+<p>to:</p>\n+<blockquote>\n+<pre>\n+typename traits::off_type, charT*, charT&gt;\n+</pre>\n+</blockquote>\n+\n <p><i>[\n-Sydney: Agreed that this is underspecified, but it's not the only\n-place where iterators are underspecified. We may need a more complete\n+Sydney: Agreed that this is under-specified, but it's not the only\n+place where iterators are under-specified. We may need a more complete\n review.  One nice simple rule that would solve this problem: *a is\n always <tt>reference</tt> by definition, and a-&gt; is\n always <tt>pointer</tt> by definition. If we do that, then we'll also\n@@ -5455,6 +5608,808 @@ <h2>Active Issues</h2>\n <p><b>Proposed resolution:</b></p>\n <p>\n </p>\n+<hr>\n+<a name=\"463\"><h3>463.&nbsp;auto_ptr usability issues</h3></a><p><b>Section:</b>&nbsp;20.4.5 <a href=\"lib-utilities.html#lib.auto.ptr\"> [lib.auto.ptr]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Rani Sharoni&nbsp; <b>Date:</b>&nbsp;7 Dec 2003</p>\n+\n+<p>\n+TC1 CWG DR #84 effectively made the template%lt;class Y&gt; operator auto_ptr%lt;Y&gt;()\n+member of auto_ptr (20.4.5.3/4) obsolete.\n+</p>\n+\n+<p>\n+The sole purpose of this obsolete conversion member is to enable copy\n+initialization base from r-value derived (or any convertible types like\n+cv-types) case:\n+</p>\n+<pre>\n+#include %lt;memory&gt;\n+using std::auto_ptr;\n+\n+struct B {};\n+struct D : B {};\n+\n+auto_ptr%lt;D&gt; source();\n+int sink(auto_ptr%lt;B&gt;);\n+int x1 = sink( source() ); // #1 EDG - no suitable copy constructor\n+</pre>\n+\n+<p>\n+The excellent analysis of conversion operations that was given in the final\n+auto_ptr proposal\n+(http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/1997/N1128.pdf)\n+explicitly specifies this case analysis (case 4). DR #84 makes the analysis\n+wrong and actually comes to forbid the loophole that was exploited by the\n+auto_ptr designers.\n+</p>\n+\n+<p>\n+I didn't encounter any compliant compiler (e.g. EDG, GCC, BCC and VC) that\n+ever allowed this case. This is probably because it requires 3 user defined\n+conversions and in fact current compilers conform to DR #84.\n+</p>\n+\n+<p>\n+I was surprised to discover that the obsolete conversion member actually has\n+negative impact of the copy initialization base from l-value derived\n+case:</p>\n+<pre>\n+auto_ptr%lt;D&gt; dp;\n+int x2 = sink(dp); // #2 EDG - more than one user-defined conversion applies\n+</pre>\n+\n+<p>\n+I'm sure that the original intention was allowing this initialization using\n+the template%lt;class Y&gt; auto_ptr(auto_ptr%lt;Y&gt;&amp; a) constructor (20.4.5.1/4) but\n+since in this copy initialization it's merely user defined conversion (UDC)\n+and the obsolete conversion member is UDC with the same rank (for the early\n+overloading stage) there is an ambiguity between them.\n+</p>\n+\n+<p>\n+Removing the obsolete member will have impact on code that explicitly\n+invokes it:\n+</p>\n+<pre>\n+int y = sink(source().operator auto_ptr%lt;B&gt;());\n+</pre>\n+\n+<p>\n+IMHO no one ever wrote such awkward code and the reasonable workaround for\n+#1 is:\n+</p>\n+<pre>\n+int y = sink( auto_ptr%lt;B&gt;(source()) );\n+</pre>\n+\n+<p>\n+I was even more surprised to find out that after removing the obsolete\n+conversion member the initialization was still ill-formed:\n+int x3 = sink(dp); // #3 EDG - no suitable copy constructor\n+</p>\n+\n+<p>\n+This copy initialization semantically requires copy constructor which means\n+that both template conversion constructor and the auto_ptr_ref conversion\n+member (20.4.5.3/3) are required which is what was explicitly forbidden in\n+DR #84. This is a bit amusing case in which removing ambiguity results with\n+no candidates.\n+</p>\n+\n+<p>\n+I also found exception safety issue with auto_ptr related to auto_ptr_ref:\n+</p>\n+<pre>\n+int f(auto_ptr%lt;B&gt;, std::string);\n+auto_ptr%lt;B&gt; source2();\n+\n+// string constructor throws while auto_ptr_ref\n+// \"holds\" the pointer\n+int x4 = f(source2(), \"xyz\"); // #4\n+</pre>\n+\n+<p>\n+The theoretic execution sequence that will cause a leak:\n+</p>\n+<ol>\n+<li>call auto_ptr%lt;B&gt;::operator auto_ptr_ref%lt;B&gt;()</li>\n+<li>call string::string(char const*) and throw</li>\n+</ol>\n+\n+<p>\n+According to 20.4.5.3/3 and 20.4.5/2 the auto_ptr_ref conversion member\n+returns auto_ptr_ref%lt;Y&gt; that holds *this and this is another defect since\n+the type of *this is auto_ptr%lt;X&gt; where X might be different from Y. Several\n+library vendors (e.g. SGI) implement auto_ptr_ref%lt;Y&gt; with Y* as member which\n+is much more reasonable. Other vendor implemented auto_ptr_ref as\n+defectively required and it results with awkward and catastrophic code:\n+int oops = sink(auto_ptr%lt;B&gt;(source())); // warning recursive on all control\n+paths\n+</p>\n+\n+<p>\n+Dave Abrahams noticed that there is no specification saying that\n+auto_ptr_ref copy constructor can't throw.\n+</p>\n+\n+<p>\n+My proposal comes to solve all the above issues and significantly simplify\n+auto_ptr implementation. One of the fundamental requirements from auto_ptr\n+is that it can be constructed in an intuitive manner (i.e. like ordinary\n+pointers) but with strict ownership semantics which yield that source\n+auto_ptr in initialization must be non-const. My idea is to add additional\n+constructor template with sole propose to generate ill-formed, diagnostic\n+required, instance for const auto_ptr arguments during instantiation of\n+declaration. This special constructor will not be instantiated for other\n+types which is achievable using 14.8.2/2 (SFINAE). Having this constructor\n+in hand makes the constructor template%lt;class Y&gt; auto_ptr(auto_ptr%lt;Y&gt; const&amp;)\n+legitimate since the actual argument can't be const yet non const r-value\n+are acceptable.\n+</p>\n+\n+<p>\n+This implementation technique makes the \"private auxiliary class\"\n+auto_ptr_ref obsolete and I found out that modern C++ compilers (e.g. EDG,\n+GCC and VC) consume the new implementation as expected and allow all\n+intuitive initialization and assignment cases while rejecting illegal cases\n+that involve const auto_ptr arguments.\n+</p>\n+\n+<p>The proposed auto_ptr interface:</p>\n+\n+<pre>\n+namespace std {\n+    template%lt;class X&gt; class auto_ptr {\n+    public:\n+        typedef X element_type;\n+\n+        // 20.4.5.1 construct/copy/destroy:\n+        explicit auto_ptr(X* p=0) throw();\n+        auto_ptr(auto_ptr&amp;) throw();\n+        template%lt;class Y&gt; auto_ptr(auto_ptr%lt;Y&gt; const&amp;) throw();\n+        auto_ptr&amp; operator=(auto_ptr&amp;) throw();\n+        template%lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr%lt;Y&gt;) throw();\n+        ~auto_ptr() throw();\n+\n+        // 20.4.5.2 members:\n+        X&amp; operator*() const throw();\n+        X* operator-&gt;() const throw();\n+        X* get() const throw();\n+        X* release() throw();\n+        void reset(X* p=0) throw();\n+\n+    private:\n+        template%lt;class U&gt;\n+        auto_ptr(U&amp; rhs, typename\n+unspecified_error_on_const_auto_ptr%lt;U&gt;::type = 0);\n+    };\n+}\n+</pre>\n+\n+<p>\n+One compliant technique to implement the unspecified_error_on_const_auto_ptr\n+helper class is using additional private auto_ptr member class template like\n+the following:\n+</p>\n+<pre>\n+template%lt;typename T&gt; struct unspecified_error_on_const_auto_ptr;\n+\n+template%lt;typename T&gt;\n+struct unspecified_error_on_const_auto_ptr%lt;auto_ptr%lt;T&gt; const&gt;\n+{ typedef typename auto_ptr%lt;T&gt;::const_auto_ptr_is_not_allowed type; };\n+</pre>\n+\n+<p>\n+There are other techniques to implement this helper class that might work\n+better for different compliers (i.e. better diagnostics) and therefore I\n+suggest defining its semantic behavior without mandating any specific\n+implementation. IMO, and I didn't found any compiler that thinks otherwise,\n+14.7.1/5 doesn't theoretically defeat the suggested technique but I suggest\n+verifying this with core language experts.\n+</p>\n+\n+<p><b>Further changes in standard text:</b></p>\n+<p>Remove section 20.4.5.3</p>\n+\n+<p>Change 20.4.5/2 to read something like:\n+Initializing auto_ptr%lt;X&gt; from const auto_ptr%lt;Y&gt; will result with unspecified\n+ill-formed declaration that will require unspecified diagnostic.</p>\n+\n+<p>Change 20.4.5.1/4,5,6 to read:</p>\n+\n+<pre>template%lt;class Y&gt; auto_ptr(auto_ptr%lt;Y&gt; const&amp; a) throw();</pre>\n+<p> 4 Requires: Y* can be implicitly converted to X*.</p>\n+<p> 5 Effects: Calls const_cast%lt;auto_ptr%lt;Y&gt;&amp;&gt;(a).release().</p>\n+<p> 6 Postconditions: *this holds the pointer returned from a.release().</p>\n+\n+<p>Change 20.4.5.1/10</p>\n+<pre>\n+template%lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr%lt;Y&gt; a) throw();\n+</pre>\n+<p>\n+10 Requires: Y* can be implicitly converted to X*. The expression delete\n+get() is well formed.\n+</p>\n+\n+<p>LWG TC DR #127 is obsolete.</p>\n+\n+<p>\n+Notice that the copy constructor and copy assignment operator should remain\n+as before and accept non-const auto_ptr&amp; since they have effect on the form\n+of the implicitly declared copy constructor and copy assignment operator of\n+class that contains auto_ptr as member per 12.8/5,10:\n+</p>\n+<pre>\n+struct X {\n+    // implicit X(X&amp;)\n+    // implicit X&amp; operator=(X&amp;)\n+    auto_ptr%lt;D&gt; aptr_;\n+};\n+</pre>\n+\n+<p>\n+In most cases this indicates about sloppy programming but preserves the\n+current auto_ptr behavior.\n+</p>\n+\n+<p>\n+Dave Abrahams encouraged me to suggest fallback implementation in case that\n+my suggestion that involves removing of auto_ptr_ref will not be accepted.\n+In this case removing the obsolete conversion member to auto_ptr%lt;Y&gt; and\n+20.4.5.3/4,5 is still required in order to eliminate ambiguity in legal\n+cases. The two constructors that I suggested will co exist with the current\n+members but will make auto_ptr_ref obsolete in initialization contexts.\n+auto_ptr_ref will be effective in assignment contexts as suggested in DR\n+#127 and I can't see any serious exception safety issues in those cases\n+(although it's possible to synthesize such). auto_ptr_ref%lt;X&gt; semantics will\n+have to be revised to say that it strictly holds pointer of type X and not\n+reference to an auto_ptr for the favor of cases in which auto_ptr_ref%lt;Y&gt; is\n+constructed from auto_ptr%lt;X&gt; in which X is different from Y (i.e. assignment\n+from r-value derived to base).\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"464\"><h3>464.&nbsp;Suggestion for new member functions in standard containers</h3></a><p><b>Section:</b>&nbsp;23.2.4 <a href=\"lib-containers.html#lib.vector\"> [lib.vector]</a>, 23.3.1 <a href=\"lib-containers.html#lib.map\"> [lib.map]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Thorsten Ottosen&nbsp; <b>Date:</b>&nbsp;12 May 2004</p>\n+\n+<p>To add slightly more convenience to vector&lt;T&gt; and map&lt;Key,T&gt; we should consider to add</p>\n+<ol>\n+<li> add vector&lt;T&gt;::data() member (const and non-const version)\n+semantics: if( empty() ) return 0; else return buffer_;</li>\n+<li> add map&lt;Key,T&gt;::at( const Key&amp; k ) member (const and non-const version)\n+<i>semantics</i>: iterator i = find( k ); if( i != end() ) return *i; else throw range_error();</li>\n+</ol>\n+\n+<p>Rationale:</p>\n+\n+<ul>\n+<li>To obtain a pointer to the vector's buffer, one must use either operator[]() (which can give undefined  behavior for empty vectors) or at() (which will then throw if the vector is empty).  </li>\n+<li>tr1::array&lt;T,sz&gt; already has a data() member</li>\n+<li>e cannot use operator[]() when T is not DefaultDonstructible</li>\n+<li>Neither when the map is const.</li>\n+<li>when we want to make sure we don't add an element accidently</li>\n+<li>when it should be considered an error if a key is not in the map</li>\n+</ul>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"465\"><h3>465.&nbsp;Contents of &lt;ciso646&gt;</h3></a><p><b>Section:</b>&nbsp;17.4.1.2 <a href=\"lib-intro.html#lib.headers\"> [lib.headers]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Steve Clamage&nbsp; <b>Date:</b>&nbsp;3 Jun 2004</p>\n+<p>C header &lt;iso646.h&gt; defines macros for some operators, such as\n+not_eq for !=.</p>\n+\n+<p>Section 17.4.1.2 <a href=\"lib-intro.html#lib.headers\"> [lib.headers]</a> \"Headers\" says that except as noted in\n+clauses 18 through 27, the &lt;cname&gt; C++ header contents are the same\n+as the C header &lt;name.h&gt;. In particular, table 12 lists\n+&lt;ciso646&gt; as a C++ header.</p>\n+\n+<p>I don't find any other mention of &lt;ciso646&gt;, or any mention of\n+&lt;iso646.h&gt;, in clauses 17 thorough 27. That implies that the\n+contents of &lt;ciso646&gt; are the same as C header &lt;iso646.h&gt;.</p>\n+\n+<p>Annex C (informative, not normative) in [diff.header.iso646.h] C.2.2.2\n+\"Header &lt;iso646.h&gt;\" says that the alternative tokens are not\n+defined as macros in &lt;ciso646&gt;, but does not mention the contents\n+of &lt;iso646.h&gt;.</p>\n+\n+<p>I don't find any normative text to support C.2.2.2.</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Add a section somewhere (clause 18? clause 22?) that says &lt;iso646.h&gt; and &lt;ciso646&gt; are empty for C++.\n+</p>\n+<hr>\n+<a name=\"466\"><h3>466.&nbsp;basic_string ctor should prevent null pointer error</h3></a><p><b>Section:</b>&nbsp;21.3.1 <a href=\"lib-strings.html#lib.string.cons\"> [lib.string.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Daniel Frey&nbsp; <b>Date:</b>&nbsp;10 Jun 2004</p>\n+<p>\n+Today, my colleagues and me wasted a lot of time. After some time, I\n+found the problem. It could be reduced to the following short example:\n+</p>\n+\n+<pre>\n+  #include &lt;string&gt;\n+  int main() { std::string( 0 ); }\n+</pre>\n+\n+<p>The problem is that the tested compilers (GCC 2.95.2, GCC 3.3.1 and\n+Comeau online) compile the above without errors or warnings! The\n+programs (at least for the GCC) resulted in a SEGV.</p>\n+\n+<p>I know that the standard explicitly states that the ctor of string\n+requires a char* which is not zero. STLs could easily detect the above\n+case with a private ctor for basic_string which takes a single 'int'\n+argument. This would catch the above code at compile time and would not\n+ambiguate any other legal ctors.</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"467\"><h3>467.&nbsp;char_traits::lt(), compare(), and memcmp()</h3></a><p><b>Section:</b>&nbsp;21.1.3.1 <a href=\"lib-strings.html#lib.char.traits.specializations.char\"> [lib.char.traits.specializations.char]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n+\n+<p>\n+Table 37 describes the requirements on Traits::compare() in terms of\n+those on Traits::lt(). 21.1.3.1, p6 requires char_traits&lt;char&gt;::lt()\n+to yield the same result as operator&lt;(char, char).\n+</p>\n+\n+<p>\n+Most, if not all, implementations of char_traits&lt;char&gt;::compare()\n+call memcmp() for efficiency. However, the C standard requires both\n+memcmp() and strcmp() to interpret characters under comparison as\n+unsigned, regardless of the signedness of char. As a result, all\n+these char_traits implementations fail to meet the requirement\n+imposed by Table 37 on compare() when char is signed.\n+</p>\n+\n+\n+<p>Read email thread starting with c++std-lib-13499 for more. </p>\n+<p><b>Proposed resolution:</b></p>\n+\n+\n+<p>Change 21.1.3.1, p6 from</p>\n+<pre>\n+    The two-argument members assign, eq, and lt are defined identically\n+    to the built-in operators =, ==, and &lt; respectively.\n+</pre>\n+<p>to</p>\n+<pre>\n+    The two-argument members assign and eq are defined identically\n+    to the built-in operators = and == respectively. The two-argument\n+    member lt is defined identically to the built-in operator &lt; for\n+    type unsigned char.\n+</pre>\n+\n+<hr>\n+<a name=\"468\"><h3>468.&nbsp;unexpected consequences of ios_base::operator void*()</h3></a><p><b>Section:</b>&nbsp;27.4.4.3 <a href=\"lib-iostreams.html#lib.iostate.flags\"> [lib.iostate.flags]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n+\n+<p>The program below is required to compile but when run it typically\n+produces unexpected results due to the user-defined conversion from\n+std::cout or any object derived from basic_ios to void*.\n+</p>\n+\n+<pre>\n+    #include &lt;cassert&gt;\n+    #include &lt;iostream&gt;\n+\n+    int main ()\n+    {\n+        assert (std::cin.tie () == std::cout);\n+        // calls std::cout.ios::operator void*()\n+    }\n+</pre>\n+\n+<p><b>Proposed resolution:</b></p>\n+\n+<p>\n+Replace std::basic_ios&lt;charT, traits&gt;::operator void*() with another\n+conversion operator to some unspecified type that is guaranteed not\n+to be convertible to any other type except for bool (a pointer-to-member\n+might be one such suitable type). In addition, make it clear that the\n+pointer type need not be a pointer to a complete type and when non-null,\n+the value need not be valid.\n+</p>\n+\n+<p>Specifically, change in [lib.ios] the signature of</p>\n+<pre>\n+    operator void*() const;\n+</pre>\n+<p>to</p>\n+<pre>\n+    operator unspecified_pointer_type () const;\n+</pre>\n+<p>and change [lib.iostate.flags], p1 from</p>\n+<pre>\n+    operator void*() const;\n+</pre>\n+<p>to</p>\n+<pre>\n+    operator unspecified_pointer_type() const;\n+    -1- Returns: If fail() then a null pointer; otherwise some\n+        non-null but not necessarily valid pointer to indicate\n+        success.\n+    -2- Note: The type named unspecified_pointer_type above is a pointer\n+        to some unspecified, possibly incomplete type, that is guaranteed\n+        not to be convertible to any other type except bool.(Footnote 1)\n+        --\n+        Footnote 1: A pointer-to-member might be one such suitable type.\n+</pre>\n+\n+<hr>\n+<a name=\"469\"><h3>469.&nbsp;vector&lt;bool&gt; ill-formed relational operators</h3></a><p><b>Section:</b>&nbsp;23.2.5 <a href=\"lib-containers.html#lib.vector.bool\"> [lib.vector.bool]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n+\n+<p>\n+The overloads of relational operators for vector&lt;bool&gt; specified\n+in [lib.vector.bool] are redundant (they are semantically identical\n+to those provided for the vector primary template) and may even be\n+diagnosed as ill-formed (refer to Daveed Vandevoorde's explanation\n+in c++std-lib-13647).\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Remove all overloads of overloads of relational operators for\n+vector&lt;bool&gt; from [lib.vector.bool].\n+</p>\n+<hr>\n+<a name=\"470\"><h3>470.&nbsp;accessing containers from their elements' special functions</h3></a><p><b>Section:</b>&nbsp;23 <a href=\"lib-containers.html#lib.containers\"> [lib.containers]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n+\n+<p>\n+The standard doesn't prohibit the destructors (or any other special\n+functions) of containers' elements invoked from a member function\n+of the container from \"recursively\" calling the same (or any other)\n+member function on the same container object, potentially while the\n+container is in an intermediate state, or even changing the state\n+of the container object while it is being modified. This may result\n+in some surprising (i.e., undefined) behavior.\n+</p>\n+\n+<p>Read email thread starting with c++std-lib-13637 for more.</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+\n+<p>Add to Container Requirements the following new paragraph:</p>\n+\n+<pre>\n+    Unless otherwise specified, the behavior of a program that\n+    invokes a container member function f from a member function\n+    g of the container's value_type on a container object c that\n+    called g from its mutating member function h, is undefined.\n+    I.e., if v is an element of c, directly or indirectly calling\n+    c.h() from v.g() called from c.f(), is undefined.\n+</pre>\n+\n+<hr>\n+<a name=\"471\"><h3>471.&nbsp;result of what() implementation-defined</h3></a><p><b>Section:</b>&nbsp;18.6.1 <a href=\"lib-support.html#lib.exception\"> [lib.exception]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n+\n+<p>[lib.exception] specifies the following:</p>\n+<pre>\n+    exception (const exception&amp;) throw();\n+    exception&amp; operator= (const exception&amp;) throw();\n+\n+    -4- Effects: Copies an exception object.\n+    -5- Notes: The effects of calling what() after assignment\n+        are implementation-defined.\n+</pre>\n+\n+<p>\n+First, does the Note only apply to the assignment operator? If so,\n+what are the effects of calling what() on a copy of an object? Is\n+the returned pointer supposed to point to an identical copy of\n+the NTBS returned by what() called on the original object or not?\n+</p>\n+\n+<p>\n+Second, is this Note intended to extend to all the derived classes\n+in section 19? I.e., does the standard provide any guarantee for\n+the effects of what() called on a copy of any of the derived class\n+described in section 19?\n+</p>\n+\n+<p>\n+Finally, if the answer to the first question is no, I believe it\n+constitutes a defect since throwing an exception object typically\n+implies invoking the copy ctor on the object. If the answer is yes,\n+then I believe the standard ought to be clarified to spell out\n+exactly what the effects are on the copy (i.e., after the copy\n+ctor was called).\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<hr>\n+<a name=\"472\"><h3>472.&nbsp;Missing \"Returns\" clause in std::equal_range</h3></a><p><b>Section:</b>&nbsp;25.3.3.3 <a href=\"lib-algorithms.html#lib.equal.range\"> [lib.equal.range]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Prateek R Karandikar&nbsp; <b>Date:</b>&nbsp;29 Feb 1900</p>\n+<p>\n+There is no \"Returns:\" clause for std::equal_range, which returns non-void.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<hr>\n+<a name=\"473\"><h3>473.&nbsp;underspecified ctype calls</h3></a><p><b>Section:</b>&nbsp;22.2.1.1 <a href=\"lib-locales.html#lib.locale.ctype\"> [lib.locale.ctype]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;1 Jul 2004</p>\n+<p>\n+Most ctype member functions come in two forms: one that operates\n+on a single character at a time and another form that operates\n+on a range of characters. Both forms are typically described by\n+a single Effects and/or Returns clause.\n+</p>\n+<p>\n+The Returns clause of each of the single-character non-virtual forms\n+suggests that the function calls the corresponding single character\n+virtual function, and that the array form calls the corresponding\n+virtual array form. Neither of the two forms of each virtual member\n+function is required to be implemented in terms of the other.\n+</p>\n+<p>\n+There are three problems:\n+</p>\n+<p>\n+1. One is that while the standard does suggest that each non-virtual\n+member function calls the corresponding form of the virtual function,\n+it doesn't actually explicitly require it.\n+</p>\n+<p>\n+Implementations that cache results from some of the virtual member\n+functions for some or all values of their arguments might want to\n+call the array form from the non-array form the first time to fill\n+the cache and avoid any or most subsequent virtual calls. Programs\n+that rely on each form of the virtual function being called from\n+the corresponding non-virtual function will see unexpected behavior\n+when using such implementations.\n+</p>\n+<p>\n+2. The second problem is that either form of each of the virtual\n+functions can be overridden by a user-defined function in a derived\n+class to return a value that is different from the one produced by\n+the virtual function of the alternate form that has not been\n+overriden.\n+</p>\n+<p>\n+Thus, it might be possible for, say, ctype::widen(c) to return one\n+value, while for ctype::widen(&amp;c, &amp;c + 1, &amp;wc) to set\n+wc to another value. This is almost certainly not intended. Both\n+forms of every function should be required to return the same result\n+for the same character, otherwise the same program using an\n+implementation that calls one form of the functions will behave\n+differently than when using another implementation that calls the\n+other form of the function \"under the hood.\"\n+</p>\n+<p>\n+3. The last problem is that the standard text fails to specify whether\n+one form of any of the virtual functions is permitted to be implemented\n+in terms of the other form or not, and if so, whether it is required\n+or permitted to call the overridden virtual function or not.\n+</p>\n+<p>\n+Thus, a program that overrides one of the virtual functions so that\n+it calls the other form which then calls the base member might end\n+up in an infinite loop if the called form of the base implementation\n+of the function in turn calls the other form.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+To fix these problems I propose the following:\n+</p>\n+<p>\n+Add two paragraphs immediately after 22.2.1.1 [lib.locale.ctype],\n+p2, with the following text:\n+</p>\n+\n+<pre>\n+  -3- Each ctype non-virtual member function that comes in two forms,\n+      one that takes a range of elements of char_type, and another\n+      that takes just a single element of char_type, is required to\n+      call the corresponding form of the virtual member function\n+      with the same value of char_type to obtain the result. The\n+      result for the same argument may be cached and returned from\n+      subsequent calls to either form of the non-virtual member\n+      function with that argument.\n+\n+  -4- For each ctype virtual member function that comes in two forms\n+      (as explained above), the single element form is required to\n+      produce the same result for a character c that the corresponding\n+      array form produces for the array element with the same value as\n+      c, and vice versa.\n+\n+  -5- It is unspecified whether the array form of each virtual member\n+      function calls the single-element virtual overload of the same\n+      function in a loop, or whether the single element form calls\n+      the array form with an array of a single element with the value\n+      of its argument, or whether neither form calls the other. In\n+      any case, an implementation is not permitted to make calls from\n+      one form of any virtual member function to the corresponding\n+      other form that is overridden in a derived class.\n+</pre>\n+\n+<hr>\n+<a name=\"474\"><h3>474.&nbsp;confusing Footnote 297</h3></a><p><b>Section:</b>&nbsp;27.6.2.5.4 <a href=\"lib-iostreams.html#lib.ostream.inserters.character\"> [lib.ostream.inserters.character]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;1 Jul 2004</p>\n+\n+<p>\n+I think Footnote 297 is confused. The paragraph it applies to seems\n+quite clear in that widen() is only called if the object is not a char\n+stream (i.e., not basic_ostream&lt;char&gt;), so it's irrelevant what the\n+value of widen(c) is otherwise.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+I propose to strike the Footnote.\n+</p>\n+<hr>\n+<a name=\"475\"><h3>475.&nbsp;May the function object passed to for_each modify the elements of the iterated sequence?</h3></a><p><b>Section:</b>&nbsp;25.1.1 <a href=\"lib-algorithms.html#lib.alg.foreach\"> [lib.alg.foreach]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Stephan T. Lavavej, Jaakko Jarvi&nbsp; <b>Date:</b>&nbsp;9 Jul 2004</p>\n+<p>\n+It is not clear whether the function object passed to for_each is allowed to\n+modify the elements of the sequence being iterated over.\n+</p>\n+\n+<p>\n+for_each is classified without explanation in [lib.alg.nonmodifying], \"25.1\n+Non-modifying sequence operations\". 'Non-modifying sequence operation' is\n+never defined.\n+</p>\n+\n+<p>\n+25(5) says: \"If an algorithm's Effects section says that a value pointed to\n+by any iterator passed as an argument is modified, then that algorithm has\n+an additional type requirement: The type of that argument shall satisfy the\n+requirements of a mutable iterator (24.1).\"\n+</p>\n+\n+<p>for_each's Effects section does not mention whether arguments can be\n+modified:</p>\n+\n+<blockquote>\n+  \"Effects: Applies f to the result of dereferencing every iterator in the\n+   range [first, last), starting from first and proceeding to last - 1.\"\n+</blockquote>\n+\n+<p>\n+Every other algorithm in [lib.alg.nonmodifying] is \"really\" non-modifying in\n+the sense that neither the algorithms themselves nor the function objects\n+passed to the algorithms may modify the sequences or elements in any way.\n+This DR affects only for_each.\n+</p>\n+\n+<p>\n+We suspect that for_each's classification in \"non-modifying sequence\n+operations\" means that the algorithm itself does not inherently modify the\n+sequence or the elements in the sequence, but that the function object\n+passed to it may modify the elements it operates on. \n+</p>\n+\n+<p>\n+The original STL document by Stepanov and Lee explicitly prohibited the\n+function object from modifying its argument.\n+The \"obvious\" implementation of for_each found in several standard library \n+implementations, however, does not impose this restriction.\n+As a result, we suspect that the use of for_each with function objects that modify\n+their arguments is wide-spread. \n+If the restriction was reinstated, all such code would become non-conforming.\n+Further, none of the other algorithms in the Standard\n+could serve the purpose of for_each (transform does not guarantee the order in\n+which its function object is called). \n+</p>\n+\n+<p>\n+We suggest that the standard be clarified to explicitly allow the function object \n+passed to for_each modify its argument.</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>Add the following sentence to the Effects in 25.1.1 <a href=\"lib-algorithms.html#lib.alg.foreach\"> [lib.alg.foreach]</a>:</p>\n+\n+<blockquote>\n+\"f may apply non-constant functions through the dereferenced iterators\n+passed to it; if it does, the type of first shall satisfy the requirements\n+of a mutable iterator (24.1).\"\n+</blockquote>\n+\n+<hr>\n+<a name=\"476\"><h3>476.&nbsp;Forward Iterator implied mutability</h3></a><p><b>Section:</b>&nbsp;24.1.3 <a href=\"lib-iterators.html#lib.forward.iterators\"> [lib.forward.iterators]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;9 Jul 2004</p>\n+\n+<p>24.1/3 says:</p>\n+<blockquote>\n+  Forward iterators satisfy all the requirements of the input and\n+  output iterators and can be used whenever either kind is specified\n+</blockquote>\n+\n+<p>\n+The problem is that satisfying the requirements of output iterator\n+means that you can always assign *something* into the result of\n+dereferencing it.  That makes almost all non-mutable forward\n+iterators non-conforming.  I think we need to sever the refinement\n+relationship between forward iterator and output iterator.\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>in 24.1/3, replace:</p>\n+<blockquote>\n+    Forward iterators satisfy all the requirements of the input and\n+    output iterators and can be used whenever either kind is specified.\n+</blockquote>\n+<p>with</p>\n+<blockquote>\n+   A forward iterator satisfies all the input iterator requirements.\n+   A mutable forward iterator satisfies all the output iterator\n+   requirements.\n+</blockquote>\n+<hr>\n+<a name=\"477\"><h3>477.&nbsp;Operator-&gt; for const forward iterators</h3></a><p><b>Section:</b>&nbsp;24.1.3 <a href=\"lib-iterators.html#lib.forward.iterators\"> [lib.forward.iterators]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;11 Jul 2004</p>\n+<p>\n+The Forward Iterator requirements table contains the following:\n+</p>\n+<pre>\n+ expression  return type         operational  precondition\n+                                  semantics\n+  ==========  ==================  ===========  ==========================\n+  a-&gt;m        U&amp; if X is mutable, (*a).m       pre: (*a).m is well-defined.\n+              otherwise const U&amp;\n+\n+  r-&gt;m        U&amp;                  (*r).m       pre: (*r).m is well-defined.\n+</pre>\n+\n+<p>\n+The first line is exactly right.  The second line is wrong.  Basically\n+it implies that the const-ness of the iterator affects the const-ness\n+of referenced members.  But Paragraph 11 of [lib.iterator.requirements] says:\n+</p>\n+\n+<blockquote>\n+   In the following sections, a and b denote values of type const X, n\n+   denotes a value of the difference type Distance, u, tmp, and m\n+   denote identifiers, r denotes a value of X&amp;, t denotes a value of\n+   value type T, o denotes a value of some type that is writable to\n+   the output iterator.\n+</blockquote>\n+\n+<p>AFAICT if we need the second line at all, it should read the same\n+as the first line.</p>\n+\n+<p>Related issue: <a href=\"lwg-active.html#478\">478</a></p>\n+<p><b>Proposed resolution:</b></p>\n+<hr>\n+<a name=\"478\"><h3>478.&nbsp;Should forward iterator requirements table have a line for r-&gt;m?</h3></a><p><b>Section:</b>&nbsp;24.1.3 <a href=\"lib-iterators.html#lib.forward.iterators\"> [lib.forward.iterators]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;11 Jul 2004</p>\n+<p>\n+The Forward Iterator requirements table contains the following:\n+</p>\n+<pre>\n+ expression  return type         operational  precondition\n+                                  semantics\n+  ==========  ==================  ===========  ==========================\n+  a-&gt;m        U&amp; if X is mutable, (*a).m       pre: (*a).m is well-defined.\n+              otherwise const U&amp;\n+\n+  r-&gt;m        U&amp;                  (*r).m       pre: (*r).m is well-defined.\n+</pre>\n+\n+<p>The second line may be unnecessary.  Paragraph 11 of\n+  [lib.iterator.requirements] says:\n+</p>\n+\n+<blockquote>\n+   In the following sections, a and b denote values of type const X, n\n+   denotes a value of the difference type Distance, u, tmp, and m\n+   denote identifiers, r denotes a value of X&amp;, t denotes a value of\n+   value type T, o denotes a value of some type that is writable to\n+   the output iterator.\n+</blockquote>\n+\n+<p>\n+Because operators can be overloaded on an iterator's const-ness, the\n+current requirements allow iterators to make many of the operations\n+specified using the identifiers a and b invalid for non-const\n+iterators.  Rather than expanding the tables, I think the right\n+answer is to change \n+</p>\n+<blockquote>\n+    \"const X\"\n+</blockquote>\n+\n+<p> to </p>\n+\n+<blockquote>\n+    \"X or const X\" \n+</blockquote>\n+\n+<p>in paragraph 11 of [lib.iterator.requirements].</p>\n+\n+<p>Related issue: <a href=\"lwg-active.html#477\">477</a></p>\n+<p><b>Proposed resolution:</b></p>\n <p>----- End of document -----</p>\n </body>\n </html>"}, {"sha": "6f6cf2343ddcb2c9b0eee3d90d4f7e4176033801", "filename": "libstdc++-v3/docs/html/ext/lwg-defects.html", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html?ref=f70f3f7e9fbf1c0a770017cf6ba3f05886e62bd0", "patch": "@@ -5,11 +5,11 @@\n <table>\n <tr>\n <td align=\"left\">Doc. no.</td>\n-<td align=\"left\">N1636=04-0076</td>\n+<td align=\"left\">N1658=04-0098</td>\n </tr>\n <tr>\n <td align=\"left\">Date:</td>\n-<td align=\"left\">12 Apr 2004</td>\n+<td align=\"left\">16 Jul 2004</td>\n </tr>\n <tr>\n <td align=\"left\">Project:</td>\n@@ -20,7 +20,7 @@\n <td align=\"left\">Matt Austern &lt;austern@apple.com&gt;</td>\n </tr>\n </table>\n-<h1>C++ Standard Library Defect Report List (Revision 30)</h1>\n+<h1>C++ Standard Library Defect Report List (Revision 31)</h1>\n   <p>Reference ISO/IEC IS 14882:1998(E)</p>\n   <p>Also see:</p>\n     <ul>\n@@ -42,6 +42,11 @@ <h1>C++ Standard Library Defect Report List (Revision 30)</h1>\n   document.</p>\n <h2>Revision History</h2>\n <ul>\n+<li>R31: \n+2004-07 mid-term mailing: reflects new proposed resolutions and\n+new issues received after the post-Sydney mailing.  Added\n+new issues <a href=\"lwg-active.html#463\">463</a>-<a href=\"lwg-active.html#478\">478</a>.\n+</li>\n <li>R30: \n Post-Sydney mailing: reflects decisions made at the Sydney meeting.\n Voted all \"Ready\" issues from R29 into the working paper.\n@@ -2845,6 +2850,11 @@ <h2>Defect Reports</h2>\n   constructor is invoked is a real issue.  This can vary in any case,\n   because of language rules on copy constructor elision.  That's too\n   much to read into these semantics clauses.</p>\n+\n+<p>Additionally, as Dave Abrahams pointed out (c++std-lib-13703): since \n+   we're told (24.1/3) that forward iterators satisfy all the requirements\n+   of input iterators, we can't impose any requirements in the Input\n+   Iterator requirements table that forward iterators don't satisfy.</p>\n <hr>\n <a name=\"103\"><h3>103.&nbsp;set::iterator is required to be modifiable, but this allows modification of keys</h3></a><p><b>Section:</b>&nbsp;23.1.2 <a href=\"lib-containers.html#lib.associative.reqmts\"> [lib.associative.reqmts]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;AFNOR&nbsp; <b>Date:</b>&nbsp;7 Oct 1998</p>\n <p>Set::iterator is described as implementation-defined with a"}]}