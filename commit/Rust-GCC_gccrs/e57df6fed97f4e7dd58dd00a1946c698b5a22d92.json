{"sha": "e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU3ZGY2ZmVkOTdmNGU3ZGQ1OGRkMDBhMTk0NmM2OThiNWEyMmQ5Mg==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2004-11-26T17:15:39Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2004-11-26T17:15:39Z"}, "message": "Friend class name lookup 4/n\n\n\tFriend class name lookup 4/n\n\t* class.c (pushclass): Don't call cxx_remember_type_decls.\n\t* cp-tree.h (clear_anon_tags): Remove declaration.\n\t* decl.c (grokdeclarator): Don't call lookup_tag_reverse.\n\t* name-lookup.c (binding_entry_free, binding_table_free): Comment\n\tout functions.\n\t(binding_table_find_anon_type, binding_table_reverse_maybe_remap,\n\tbinding_table_remove_anonymous_types, cxx_remember_type_decls,\n\tbt_print_entry, clear_anon_tags, follow_tag_typedef, lookup_tag,\n\tlookup_tag_reverse): Remove\n\t(begin_scope, leave_scope, kept_level_p, print_binding_level):\n\tDon't use type_decls field in cp_binding_level.\n\t(maybe_process_template_type_declaration, pushtag): Set\n\tCLASSTYPE_NESTED_UTDS directly.\n\t* name-lookup.h (binding_table_remove_anonymous_types,\n\tcxx_remember_type_decls, lookup_tag, lookup_tag_reverse): Remove\n\tdeclaration.\n\t(cp_binding_level): Remove type_decls field.\n\nFrom-SVN: r91342", "tree": {"sha": "6917632b4872bacbee70ead116da681a6b68ac04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6917632b4872bacbee70ead116da681a6b68ac04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/comments", "author": null, "committer": null, "parents": [{"sha": "7510740de1b8ce91ee2cd969de1e585e406e3b8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7510740de1b8ce91ee2cd969de1e585e406e3b8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7510740de1b8ce91ee2cd969de1e585e406e3b8f"}], "stats": {"total": 410, "additions": 41, "deletions": 369}, "files": [{"sha": "bf2ddb85da8028e5184a24d481894f5830fbd4b9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "patch": "@@ -1,3 +1,24 @@\n+2004-11-27  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tFriend class name lookup 4/n\n+\t* class.c (pushclass): Don't call cxx_remember_type_decls.\n+\t* cp-tree.h (clear_anon_tags): Remove declaration.\n+\t* decl.c (grokdeclarator): Don't call lookup_tag_reverse.\n+\t* name-lookup.c (binding_entry_free, binding_table_free): Comment\n+\tout functions.\n+\t(binding_table_find_anon_type, binding_table_reverse_maybe_remap,\n+\tbinding_table_remove_anonymous_types, cxx_remember_type_decls,\n+\tbt_print_entry, clear_anon_tags, follow_tag_typedef, lookup_tag,\n+\tlookup_tag_reverse): Remove\n+\t(begin_scope, leave_scope, kept_level_p, print_binding_level):\n+\tDon't use type_decls field in cp_binding_level.\n+\t(maybe_process_template_type_declaration, pushtag): Set\n+\tCLASSTYPE_NESTED_UTDS directly.\n+\t* name-lookup.h (binding_table_remove_anonymous_types,\n+\tcxx_remember_type_decls, lookup_tag, lookup_tag_reverse): Remove\n+\tdeclaration.\n+\t(cp_binding_level): Remove type_decls field.\n+\n 2004-11-26  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* typeck.c: Fix a comment typo."}, {"sha": "8a0da05899eb7d36350de78aa5e8d40131cd0b3e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "patch": "@@ -5376,8 +5376,6 @@ pushclass (tree type)\n     pushlevel_class ();\n   else\n     restore_class_cache ();\n-  \n-  cxx_remember_type_decls (CLASSTYPE_NESTED_UTDS (type));\n }\n \n /* When we exit a toplevel class scope, we save its binding level so"}, {"sha": "eb152580195da290134634e6a6ada8e09353aa6c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "patch": "@@ -3709,7 +3709,6 @@ extern void push_switch\t\t\t\t(tree);\n extern void pop_switch\t\t\t\t(void);\n extern void pushtag\t\t\t\t(tree, tree, int);\n extern tree make_anon_name\t\t\t(void);\n-extern void clear_anon_tags\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree);\n extern tree duplicate_decls\t\t\t(tree, tree);\n extern tree pushdecl_top_level\t\t\t(tree);"}, {"sha": "93c04175b435d3b38c74fb072419bc0a080b2d40", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "patch": "@@ -7663,7 +7663,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t  tree t;\n \n \t  /* Replace the anonymous name with the real name everywhere.  */\n-\t  lookup_tag_reverse (type, unqualified_id);\n \t  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n \t    if (TYPE_NAME (t) == oldname)\n \t      TYPE_NAME (t) = decl;"}, {"sha": "ddbd78f2ca0144569598e8bcd4d9c2a9d074badd", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 20, "deletions": 358, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "patch": "@@ -95,7 +95,7 @@ binding_entry_make (tree name, tree type)\n }\n \n /* Put ENTRY back on the free list.  */\n-\n+#if 0\n static inline void\n binding_entry_free (binding_entry entry)\n {\n@@ -104,6 +104,7 @@ binding_entry_free (binding_entry entry)\n   entry->chain = free_binding_entry;\n   free_binding_entry = entry;\n }\n+#endif\n \n /* The datatype used to implement the mapping from names to types at\n    a given scope.  */\n@@ -131,7 +132,7 @@ binding_table_construct (binding_table table, size_t chain_count)\n }\n \n /* Make TABLE's entries ready for reuse.  */\n-\n+#if 0\n static void\n binding_table_free (binding_table table)\n {\n@@ -154,6 +155,7 @@ binding_table_free (binding_table table)\n     }\n   table->entry_count = 0;\n }\n+#endif\n \n /* Allocate a table with CHAIN_COUNT, assumed to be a power of two.  */\n \n@@ -225,82 +227,6 @@ binding_table_find (binding_table table, tree name)\n   return entry;\n }\n \n-/* Return the binding_entry, if any, that maps NAME to an anonymous type.  */\n-\n-static tree\n-binding_table_find_anon_type (binding_table table, tree name)\n-{\n-  const unsigned int hash = IDENTIFIER_HASH_VALUE (name);\n-  binding_entry entry = table->chain[ENTRY_INDEX (hash, table->chain_count)];\n-\n-  while (entry != NULL && TYPE_IDENTIFIER (entry->type) != name)\n-    entry = entry->chain;\n-\n-  return entry ? entry->type : NULL;\n-}\n-\n-/* Return the binding_entry, if any, that has TYPE as target.  If NAME\n-   is non-null, then set the domain and rehash that entry.  */\n-\n-static binding_entry\n-binding_table_reverse_maybe_remap (binding_table table, tree type, tree name)\n-{\n-  const size_t chain_count = table->chain_count;\n-  binding_entry entry = NULL;\n-  binding_entry *p = NULL;\n-  size_t i;\n-\n-  for (i = 0; i < chain_count && entry == NULL; ++i)\n-    {\n-      p = &table->chain[i];\n-      while (*p != NULL && entry == NULL)\n-        if ((*p)->type == type)\n-          entry = *p;\n-        else\n-          p = &(*p)->chain;\n-    }\n-\n-  if (entry != NULL && name != NULL && entry->name != name)\n-    {\n-      /* Remove the bucket from the previous chain.  */\n-      *p = (*p)->chain;\n-\n-      /* Remap the name type to type.  */\n-      i = ENTRY_INDEX (IDENTIFIER_HASH_VALUE (name), chain_count);\n-      entry->chain = table->chain[i];\n-      entry->name = name;\n-      table->chain[i] = entry;\n-    }\n-\n-  return entry;\n-}\n-\n-/* Remove from TABLE all entries that map to anonymous enums or\n-   class-types.  */\n-\n-void\n-binding_table_remove_anonymous_types (binding_table table)\n-{\n-  const size_t chain_count = table->chain_count;\n-  size_t i;\n-\n-  for (i = 0; i < chain_count; ++i)\n-    {\n-      binding_entry *p = &table->chain[i];\n-\n-      while (*p != NULL)\n-        if (ANON_AGGRNAME_P ((*p)->name))\n-          {\n-            binding_entry e = *p;\n-            *p = (*p)->chain;\n-            --table->entry_count;\n-            binding_entry_free (e);\n-          }\n-        else\n-          p = &(*p)->chain;\n-    }\n-}\n-\n /* Apply PROC -- with DATA -- to all entries in TABLE.  */\n \n void\n@@ -1337,7 +1263,6 @@ begin_scope (scope_kind kind, tree entity)\n       break;\n \n     case sk_namespace:\n-      scope->type_decls = binding_table_new (namespace_scope_ht_size (entity));\n       NAMESPACE_LEVEL (entity) = scope;\n       VARRAY_TREE_INIT (scope->static_decls,\n                         DECL_NAME (entity) == std_identifier\n@@ -1397,10 +1322,6 @@ leave_scope (void)\n       && scope->kind != sk_class)\n     {\n       scope->level_chain = free_binding_level;\n-      if (scope->kind == sk_class)\n-        scope->type_decls = NULL;\n-      else\n-        binding_table_free (scope->type_decls);\n       gcc_assert (!ENABLE_SCOPE_CHECKING\n \t\t  || scope->binding_depth == binding_depth);\n       free_binding_level = scope;\n@@ -1508,8 +1429,7 @@ kept_level_p (void)\n   return (current_binding_level->blocks != NULL_TREE\n \t  || current_binding_level->keep\n           || current_binding_level->kind == sk_cleanup\n-\t  || current_binding_level->names != NULL_TREE\n-\t  || current_binding_level->type_decls != NULL);\n+\t  || current_binding_level->names != NULL_TREE);\n }\n \n /* Returns the kind of the innermost scope.  */\n@@ -1549,58 +1469,10 @@ getdecls (void)\n   return current_binding_level->names;\n }\n \n-/* Set the current binding TABLE for type declarations..  This is a\n-   temporary workaround of the fact that the data structure classtypes\n-   does not currently carry its allocated cxx_scope structure.  */\n-void\n-cxx_remember_type_decls (binding_table table)\n-{\n-  current_binding_level->type_decls = table;\n-}\n-\n /* For debugging.  */\n static int no_print_functions = 0;\n static int no_print_builtins = 0;\n \n-/* Called from print_binding_level through binding_table_foreach to\n-   print the content of binding ENTRY.  DATA is a pointer to line offset\n-   marker.  */\n-static void\n-bt_print_entry (binding_entry entry, void *data)\n-{\n-  int *p = (int *) data;\n-  int len;\n-\n-  if (entry->name == NULL)\n-    len = 3;\n-  else if (entry->name == TYPE_IDENTIFIER (entry->type))\n-    len = 2;\n-  else\n-    len = 4;\n-    len = 4;\n-\n-  *p += len;\n-\n-  if (*p > 5)\n-    {\n-      fprintf (stderr, \"\\n\\t\");\n-      *p = len;\n-    }\n-  if (entry->name == NULL)\n-    {\n-      print_node_brief (stderr, \"<unnamed-typedef\", entry->type, 0);\n-      fprintf (stderr, \">\");\n-    }\n-  else if (entry->name == TYPE_IDENTIFIER (entry->type))\n-    print_node_brief (stderr, \"\", entry->type, 0);\n-  else\n-    {\n-      print_node_brief (stderr, \"<typedef\", entry->name, 0);\n-      print_node_brief (stderr, \"\", entry->type, 0);\n-      fprintf (stderr, \">\");\n-    }\n-}\n-\n void\n print_binding_level (struct cp_binding_level* lvl)\n {\n@@ -1643,14 +1515,6 @@ print_binding_level (struct cp_binding_level* lvl)\n       if (i)\n         fprintf (stderr, \"\\n\");\n     }\n-  if (lvl->type_decls)\n-    {\n-      fprintf (stderr, \" tags:\\t\");\n-      i = 0;\n-      binding_table_foreach (lvl->type_decls, bt_print_entry, &i);\n-      if (i)\n-\tfprintf (stderr, \"\\n\");\n-    }\n   if (VEC_length (cp_class_binding, lvl->class_shadowed))\n     {\n       size_t i;\n@@ -1845,27 +1709,6 @@ make_anon_name (void)\n   return get_identifier (buf);\n }\n \n-/* Clear the TREE_PURPOSE slot of UTDs which have anonymous typenames.\n-   This keeps dbxout from getting confused.  */\n-\n-void\n-clear_anon_tags (void)\n-{\n-  struct cp_binding_level *b;\n-  static int last_cnt = 0;\n-\n-  /* Fast out if no new anon names were declared.  */\n-  if (last_cnt == anon_cnt)\n-    return;\n-\n-  b = current_binding_level;\n-  while (b->kind == sk_cleanup)\n-    b = b->level_chain;\n-  if (b->type_decls != NULL)\n-    binding_table_remove_anonymous_types (b->type_decls);\n-  last_cnt = anon_cnt;\n-}\n-\f\n /* Return (from the stack of) the BINDING, if any, established at SCOPE.  */ \n \n static inline cxx_binding *\n@@ -2329,188 +2172,6 @@ do_local_using_decl (tree decl, tree scope, tree name)\n     cp_emit_debug_info_for_using (orig_decl, current_scope());\n }\n \n-/* Return the type that should be used when TYPE's name is preceded\n-   by a tag such as 'struct' or 'union', or null if the name cannot\n-   be used in this way.\n-\n-   For example, when processing the third line of:\n-\n-\tstruct A;\n-\ttypedef struct A A;\n-\tstruct A;\n-\n-   lookup of A will find the typedef.  Given A's typedef, this function\n-   will return the type associated with \"struct A\".  For the tag to be\n-   anything other than TYPE, TYPE must be a typedef whose original type\n-   has the same name and context as TYPE itself.\n-\n-   It is not valid for a typedef of an anonymous type to be used with\n-   an explicit tag:\n-\n-       typedef struct { ... } B;\n-       struct B;\n-\n-   Return null for this case.  */\n-\n-static tree\n-follow_tag_typedef (tree type)\n-{\n-  tree original;\n-\n-  original = original_type (type);\n-  if (! TYPE_NAME (original))\n-    return NULL_TREE;\n-  if (TYPE_IDENTIFIER (original) == TYPE_IDENTIFIER (type)\n-      && (CP_DECL_CONTEXT (TYPE_NAME (original))\n-\t  == CP_DECL_CONTEXT (TYPE_NAME (type)))\n-      && !(CLASS_TYPE_P (original) && TYPE_WAS_ANONYMOUS (original)))\n-    return original;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Given NAME, an IDENTIFIER_NODE,\n-   return the structure (or union or enum) definition for that name.\n-   Searches binding levels from its SCOPE up to the global level.\n-   If THISLEVEL_ONLY is nonzero, searches only the specified context\n-   (but skips any sk_cleanup contexts to find one that is\n-   meaningful for tags).\n-   FORM says which kind of type the caller wants;\n-   it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.\n-   If the wrong kind of type is found, and it's not a template, an error is\n-   reported.  */\n-\n-tree\n-lookup_tag (enum tree_code form, tree name,\n-            cxx_scope *binding_level, int thislevel_only)\n-{\n-  struct cp_binding_level *level;\n-  /* Nonzero if, we should look past a template parameter level, even\n-     if THISLEVEL_ONLY.  */\n-  int allow_template_parms_p = 1;\n-  bool type_is_anonymous = ANON_AGGRNAME_P (name);\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  for (level = binding_level; level; level = level->level_chain)\n-    {\n-      tree tail;\n-      if (type_is_anonymous && level->type_decls != NULL)\n-        {\n-          tree type = binding_table_find_anon_type (level->type_decls, name);\n-          /* There is no need for error checking here, because\n-           anon names are unique throughout the compilation.  */\n-          if (type != NULL)\n-            POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, type);\n-        }\n-      else if (level->kind == sk_namespace)\n-\t/* Do namespace lookup.  */\n-\tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n-\t  {\n-            cxx_binding *binding =\n-              cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (tail), name);\n-\n-\t    if (binding && (binding->type\n-\t\t\t    || (binding->value \n-\t\t\t\t&& DECL_DECLARES_TYPE_P (binding->value))))\n-\t      {\n-\t\ttree old;\n-\t\t\n-\t\t/* If we just skipped past a template parameter level,\n-\t\t   even though THISLEVEL_ONLY, and we find a template\n-\t\t   class declaration, then we use the _TYPE node for the\n-\t\t   template.  See the example below.  */\n-\t\tif (thislevel_only && !allow_template_parms_p\n-\t\t    && binding->value\n-\t\t    && DECL_CLASS_TEMPLATE_P (binding->value))\n-\t\t  old = binding->value;\n-\t\telse\n-\t\t  old = binding->type ? binding->type : binding->value;\n-\n-\t\t/* We've found something at this binding level.  If it is\n-\t\t   a typedef, extract the tag it refers to.  Lookup fails\n-\t\t   if the typedef doesn't refer to a taggable type.  */\n-\t\told = TREE_TYPE (old);\n-\t\told = follow_tag_typedef (old);\n-\t\tif (!old)\n-\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t\tif (TREE_CODE (old) != form\n-\t\t    && (form == ENUMERAL_TYPE\n-\t\t\t|| TREE_CODE (old) == ENUMERAL_TYPE))\n-\t\t  {\n-\t\t    error (\"%q#D redeclared as %C\", old, form);\n-\t\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t\t  }\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old);\n-\t      }\n-\t    if (thislevel_only || tail == global_namespace)\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t  }\n-      else if (level->type_decls != NULL)\n-        {\n-          binding_entry entry = binding_table_find (level->type_decls, name);\n-          if (entry != NULL)\n-            {\n-              enum tree_code code = TREE_CODE (entry->type);\n-\t\t\n-              if (code != form\n-                  && (form == ENUMERAL_TYPE || code == ENUMERAL_TYPE))\n-                {\n-                  /* Definition isn't the kind we were looking for.  */\n-                  error (\"%q#D redeclared as %C\", entry->type, form);\n-                  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-                }\n-              POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->type);\n-            }\n-\t  }\n-      if (thislevel_only && level->kind != sk_cleanup)\n-\t{\n-\t  if (level->kind == sk_template_parms && allow_template_parms_p)\n-\t    {\n-\t      /* We must deal with cases like this:\n-\n-\t           template <class T> struct S;\n-\t\t   template <class T> struct S {};\n-\n-\t\t When looking up `S', for the second declaration, we\n-\t\t would like to find the first declaration.  But, we\n-\t\t are in the pseudo-global level created for the\n-\t\t template parameters, rather than the (surrounding)\n-\t\t namespace level.  Thus, we keep going one more level,\n-\t\t even though THISLEVEL_ONLY is nonzero.  */\n-\t      allow_template_parms_p = 0;\n-\t      continue;\n-\t    }\n-\t  else\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t}\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-}\n-\n-/* Given a type, find the tag that was defined for it and return the tag name.\n-   Otherwise return 0.  However, the value can never be 0\n-   in the cases in which this is used.\n-\n-   C++: If NAME is nonzero, this is the new name to install.  This is\n-   done when replacing anonymous tags with real tag names.  */\n-\n-tree\n-lookup_tag_reverse (tree type, tree name)\n-{\n-  struct cp_binding_level *level;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  for (level = current_binding_level; level; level = level->level_chain)\n-    {\n-      binding_entry entry = level->type_decls == NULL\n-        ? NULL\n-        : binding_table_reverse_maybe_remap (level->type_decls, type, name);\n-      if (entry)\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->name);\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-}\n-\n /* Returns true if ROOT (a namespace, class, or function) encloses\n    CHILD.  CHILD may be either a class type or a namespace.  */\n \n@@ -4882,19 +4543,18 @@ maybe_process_template_type_declaration (tree type, int globalize,\n \t      && b->level_chain->kind == sk_class)\n \t    {\n \t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n-\t      /* Put this UDT in the table of UDTs for the class, since\n-\t\t that won't happen below because B is not the class\n-\t\t binding level, but is instead the pseudo-global level.  */\n-              if (b->level_chain->type_decls == NULL)\n-                b->level_chain->type_decls =\n-                  binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n-              binding_table_insert (b->level_chain->type_decls, name, type);\n+\n \t      if (!COMPLETE_TYPE_P (current_class_type))\n \t\t{\n \t\t  maybe_add_class_template_decl_list (current_class_type,\n \t\t\t\t\t\t      type, /*friend_p=*/0);\n-\t\t  CLASSTYPE_NESTED_UTDS (current_class_type) =\n-                    b->level_chain->type_decls;\n+\t\t  /* Put this UDT in the table of UDTs for the class.  */\n+\t\t  if (CLASSTYPE_NESTED_UTDS (current_class_type) == NULL)\n+\t\t    CLASSTYPE_NESTED_UTDS (current_class_type) =\n+\t\t      binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n+\n+\t\t  binding_table_insert\n+\t\t    (CLASSTYPE_NESTED_UTDS (current_class_type), name, type);\n \t\t}\n \t    }\n \t}\n@@ -4934,10 +4594,6 @@ pushtag (tree name, tree type, int globalize)\n \t\t || COMPLETE_TYPE_P (b->this_entity))))\n     b = b->level_chain;\n \n-  if (b->type_decls == NULL)\n-    b->type_decls = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n-  binding_table_insert (b->type_decls, name, type);\n-\n   if (name)\n     {\n       /* Do C++ gratuitous typedefing.  */\n@@ -5013,7 +4669,13 @@ pushtag (tree name, tree type, int globalize)\n \t{\n \t  maybe_add_class_template_decl_list (current_class_type,\n \t\t\t\t\t      type, /*friend_p=*/0);\n-\t  CLASSTYPE_NESTED_UTDS (current_class_type) = b->type_decls;\n+\n+\t  if (CLASSTYPE_NESTED_UTDS (current_class_type) == NULL)\n+\t    CLASSTYPE_NESTED_UTDS (current_class_type)\n+\t      = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n+\n+\t  binding_table_insert\n+\t    (CLASSTYPE_NESTED_UTDS (current_class_type), name, type);\n \t}\n     }\n "}, {"sha": "5c6452191db466d633623a817aadb5c5fe6df648", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57df6fed97f4e7dd58dd00a1946c698b5a22d92/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=e57df6fed97f4e7dd58dd00a1946c698b5a22d92", "patch": "@@ -46,10 +46,8 @@ struct binding_entry_s GTY(())\n #define NAMESPACE_STD_HT_SIZE                        (1 << 8)\n #define GLOBAL_SCOPE_HT_SIZE                         (1 << 8)\n \n-extern void binding_table_remove_anonymous_types (binding_table);\n extern void binding_table_foreach (binding_table, bt_foreach_proc, void *);\n extern binding_entry binding_table_find (binding_table, tree);\n-extern void cxx_remember_type_decls (binding_table);\n \f\n /* Datatype that represents binding established by a declaration between\n    a name and a C++ entity.  */\n@@ -194,9 +192,6 @@ struct cp_binding_level GTY(())\n     /* A chain of VTABLE_DECL nodes.  */\n     tree vtables; \n \n-    /* A dictionary for looking up user-defined-types.  */\n-    binding_table type_decls;\n-\n     /* A list of USING_DECL nodes.  */\n     tree usings;\n \n@@ -317,8 +312,6 @@ extern void pop_nested_namespace (tree);\n extern void pushlevel_class (void);\n extern void poplevel_class (void);\n extern tree pushdecl_with_scope (tree, cxx_scope *);\n-extern tree lookup_tag (enum tree_code, tree, cxx_scope *, int);\n-extern tree lookup_tag_reverse (tree, tree);\n extern tree lookup_name\t(tree, int);\n extern tree lookup_name_real (tree, int, int, bool, int, int);\n extern tree lookup_type_scope (tree, tag_scope);"}]}