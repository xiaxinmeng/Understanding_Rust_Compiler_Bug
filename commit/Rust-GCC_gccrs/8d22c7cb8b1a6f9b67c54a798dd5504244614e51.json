{"sha": "8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "node_id": "C_kwDOANBUbNoAKDhkMjJjN2NiOGIxYTZmOWI2N2M1NGE3OThkZDU1MDQyNDQ2MTRlNTE", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-08-01T21:02:23Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-08-17T16:35:45Z"}, "message": "c++: Extend -Wpessimizing-move to other contexts\n\nIn my recent patch which enhanced -Wpessimizing-move so that it warns\nabout class prvalues too I said that I'd like to extend it so that it\nwarns in more contexts where a std::move can prevent copy elision, such\nas:\n\n  T t = std::move(T());\n  T t(std::move(T()));\n  T t{std::move(T())};\n  T t = {std::move(T())};\n  void foo (T);\n  foo (std::move(T()));\n\nThis patch does that by adding two maybe_warn_pessimizing_move calls.\nThese must happen before we've converted the initializers otherwise the\nstd::move will be buried in a TARGET_EXPR.\n\n\tPR c++/106276\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (build_over_call): Call maybe_warn_pessimizing_move.\n\t* cp-tree.h (maybe_warn_pessimizing_move): Declare.\n\t* decl.cc (build_aggr_init_full_exprs): Call\n\tmaybe_warn_pessimizing_move.\n\t* typeck.cc (maybe_warn_pessimizing_move): Handle TREE_LIST and\n\tCONSTRUCTOR.  Add a bool parameter and use it.  Adjust a diagnostic\n\tmessage.\n\t(check_return_expr): Adjust the call to maybe_warn_pessimizing_move.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/Wpessimizing-move7.C: Add dg-warning.\n\t* g++.dg/cpp0x/Wpessimizing-move8.C: New test.", "tree": {"sha": "1c20cb245dd1cdb66727bde28f86ce9850e5e056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c20cb245dd1cdb66727bde28f86ce9850e5e056"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "745be54bd6634fe63d6be83615e264c83d2ae9f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/745be54bd6634fe63d6be83615e264c83d2ae9f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/745be54bd6634fe63d6be83615e264c83d2ae9f9"}], "stats": {"total": 148, "additions": 120, "deletions": 28}, "files": [{"sha": "370137ebd6d39f069f98f987e1362f6b521dfe57", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "patch": "@@ -9627,10 +9627,13 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       if (!conversion_warning)\n \targ_complain &= ~tf_warning;\n \n+      if (arg_complain & tf_warning)\n+\tmaybe_warn_pessimizing_move (arg, type, /*return_p*/false);\n+\n       val = convert_like_with_context (conv, arg, fn, i - is_method,\n \t\t\t\t       arg_complain);\n       val = convert_for_arg_passing (type, val, arg_complain);\n-\t\n+\n       if (val == error_mark_node)\n         return error_mark_node;\n       else"}, {"sha": "9f2ff3728b417116812b1a987f535ff6747fa7ae", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "patch": "@@ -8099,6 +8099,7 @@ extern tree finish_right_unary_fold_expr     (tree, int);\n extern tree finish_binary_fold_expr          (tree, tree, int);\n extern tree treat_lvalue_as_rvalue_p\t     (tree, bool);\n extern bool decl_in_std_namespace_p\t     (tree);\n+extern void maybe_warn_pessimizing_move\t     (tree, tree, bool);\n \n /* in typeck2.cc */\n extern void require_complete_eh_spec_types\t(tree, tree);"}, {"sha": "84a1a01134116474245d73deeb0d9938ca3bdd3e", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "patch": "@@ -7220,9 +7220,10 @@ check_array_initializer (tree decl, tree type, tree init)\n \n static tree\n build_aggr_init_full_exprs (tree decl, tree init, int flags)\n-     \n {\n   gcc_assert (stmts_are_full_exprs_p ());\n+  if (init)\n+    maybe_warn_pessimizing_move (init, TREE_TYPE (decl), /*return_p*/false);\n   return build_aggr_init (decl, init, flags, tf_warning_or_error);\n }\n "}, {"sha": "19bb7f74321db4eaf755cdec1b93544973eda8a8", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "patch": "@@ -10372,17 +10372,17 @@ treat_lvalue_as_rvalue_p (tree expr, bool return_p)\n     }\n }\n \n-/* Warn about wrong usage of std::move in a return statement.  RETVAL\n-   is the expression we are returning; FUNCTYPE is the type the function\n-   is declared to return.  */\n+/* Warn about dubious usage of std::move (in a return statement, if RETURN_P\n+   is true).  EXPR is the std::move expression; TYPE is the type of the object\n+   being initialized.  */\n \n-static void\n-maybe_warn_pessimizing_move (tree retval, tree functype)\n+void\n+maybe_warn_pessimizing_move (tree expr, tree type, bool return_p)\n {\n   if (!(warn_pessimizing_move || warn_redundant_move))\n     return;\n \n-  location_t loc = cp_expr_loc_or_input_loc (retval);\n+  const location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   /* C++98 doesn't know move.  */\n   if (cxx_dialect < cxx11)\n@@ -10394,14 +10394,32 @@ maybe_warn_pessimizing_move (tree retval, tree functype)\n     return;\n \n   /* This is only interesting for class types.  */\n-  if (!CLASS_TYPE_P (functype))\n+  if (!CLASS_TYPE_P (type))\n     return;\n \n+  /* A a = std::move (A());  */\n+  if (TREE_CODE (expr) == TREE_LIST)\n+    {\n+      if (list_length (expr) == 1)\n+\texpr = TREE_VALUE (expr);\n+      else\n+\treturn;\n+    }\n+  /* A a = {std::move (A())};\n+     A a{std::move (A())};  */\n+  else if (TREE_CODE (expr) == CONSTRUCTOR)\n+    {\n+      if (CONSTRUCTOR_NELTS (expr) == 1)\n+\texpr = CONSTRUCTOR_ELT (expr, 0)->value;\n+      else\n+\treturn;\n+    }\n+\n   /* We're looking for *std::move<T&> ((T &) &arg).  */\n-  if (REFERENCE_REF_P (retval)\n-      && TREE_CODE (TREE_OPERAND (retval, 0)) == CALL_EXPR)\n+  if (REFERENCE_REF_P (expr)\n+      && TREE_CODE (TREE_OPERAND (expr, 0)) == CALL_EXPR)\n     {\n-      tree fn = TREE_OPERAND (retval, 0);\n+      tree fn = TREE_OPERAND (expr, 0);\n       if (is_std_move_p (fn))\n \t{\n \t  tree arg = CALL_EXPR_ARG (fn, 0);\n@@ -10413,20 +10431,24 @@ maybe_warn_pessimizing_move (tree retval, tree functype)\n \t    return;\n \t  arg = TREE_OPERAND (arg, 0);\n \t  arg = convert_from_reference (arg);\n-\t  /* Warn if we could do copy elision were it not for the move.  */\n-\t  if (can_do_nrvo_p (arg, functype))\n+\t  if (can_do_rvo_p (arg, type))\n \t    {\n \t      auto_diagnostic_group d;\n \t      if (warning_at (loc, OPT_Wpessimizing_move,\n-\t\t\t      \"moving a local object in a return statement \"\n-\t\t\t      \"prevents copy elision\"))\n+\t\t\t      \"moving a temporary object prevents copy \"\n+\t\t\t      \"elision\"))\n \t\tinform (loc, \"remove %<std::move%> call\");\n \t    }\n-\t  else if (can_do_rvo_p (arg, functype))\n+\t  /* The rest of the warnings is only relevant for when we are\n+\t     returning from a function.  */\n+\t  else if (!return_p)\n+\t    return;\n+\t  /* Warn if we could do copy elision were it not for the move.  */\n+\t  else if (can_do_nrvo_p (arg, type))\n \t    {\n \t      auto_diagnostic_group d;\n \t      if (warning_at (loc, OPT_Wpessimizing_move,\n-\t\t\t      \"moving a temporary object in a return statement \"\n+\t\t\t      \"moving a local object in a return statement \"\n \t\t\t      \"prevents copy elision\"))\n \t\tinform (loc, \"remove %<std::move%> call\");\n \t    }\n@@ -10437,7 +10459,7 @@ maybe_warn_pessimizing_move (tree retval, tree functype)\n \t    {\n \t      /* Make sure that overload resolution would actually succeed\n \t\t if we removed the std::move call.  */\n-\t      tree t = convert_for_initialization (NULL_TREE, functype,\n+\t      tree t = convert_for_initialization (NULL_TREE, type,\n \t\t\t\t\t\t   moved,\n \t\t\t\t\t\t   (LOOKUP_NORMAL\n \t\t\t\t\t\t    | LOOKUP_ONLYCONVERTING\n@@ -10722,7 +10744,7 @@ check_return_expr (tree retval, bool *no_warning)\n     return NULL_TREE;\n \n   if (!named_return_value_okay_p)\n-    maybe_warn_pessimizing_move (retval, functype);\n+    maybe_warn_pessimizing_move (retval, functype, /*return_p*/true);\n \n   /* Do any required conversions.  */\n   if (bare_retval == result || DECL_CONSTRUCTOR_P (current_function_decl))"}, {"sha": "a17c7a87b7dd236ea6a8745283d971bed037e4de", "filename": "gcc/testsuite/g++.dg/cpp0x/Wpessimizing-move7.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move7.C?ref=8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "patch": "@@ -30,23 +30,23 @@ static A foo ();\n A\n fn1 ()\n {\n-  return std::move (A{}); // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n-  return std::move (A()); // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n-  return std::move (foo ()); // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n+  return std::move (A{}); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  return std::move (A()); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  return std::move (foo ()); // { dg-warning \"moving a temporary object prevents copy elision\" }\n }\n \n B fn2 ()\n {\n-  return std::move (A());\n-  return std::move (A{});\n-  return std::move (foo ());\n+  return std::move (A()); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  return std::move (A{}); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  return std::move (foo ()); // { dg-warning \"moving a temporary object prevents copy elision\" }\n }\n \n template <typename T1, typename T2>\n T1\n fn3 ()\n {\n-  return std::move (T2{}); // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n+  return std::move (T2{}); // { dg-warning \"moving a temporary object prevents copy elision\" }\n }\n \n void\n@@ -58,6 +58,6 @@ do_fn3 ()\n \n char take_buffer;\n struct label_text {\n-  label_text take() { return std::move(label_text(&take_buffer)); } // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n+  label_text take() { return std::move(label_text(&take_buffer)); } // { dg-warning \"moving a temporary object prevents copy elision\" }\n   label_text(char *);\n };"}, {"sha": "51406c8f97f4afaa130d04ff7ee1d525825918f5", "filename": "gcc/testsuite/g++.dg/cpp0x/Wpessimizing-move8.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d22c7cb8b1a6f9b67c54a798dd5504244614e51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move8.C?ref=8d22c7cb8b1a6f9b67c54a798dd5504244614e51", "patch": "@@ -0,0 +1,65 @@\n+// PR c++/106276\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wpessimizing-move\" }\n+\n+// Define std::move.\n+namespace std {\n+  template<typename _Tp>\n+    struct remove_reference\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    constexpr typename std::remove_reference<_Tp>::type&&\n+    move(_Tp&& __t) noexcept\n+    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }\n+}\n+\n+struct A { A(); A(const A&) = delete; A(A&&); };\n+struct B { B(A); };\n+struct X { };\n+\n+void foo (A);\n+void bar (X);\n+\n+void\n+fn1 ()\n+{\n+  A a1 = std::move (A()); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  A a2 = std::move (A{}); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  A a3(std::move (A())); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  A a4(std::move (A{})); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  A a5{std::move (A())}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  A a6{std::move (A{})}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  A a7 = {std::move (A())}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  A a8 = {std::move (A{})}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+\n+  B b1 = std::move (A()); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  B b2(std::move (A())); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  B b3{std::move (A())}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  B b4 = {std::move (A())}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+\n+  X x1 = std::move (X()); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  X x2 = std::move (X{}); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  X x3(std::move (X())); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  X x4(std::move (X{})); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  X x5{std::move (X())}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  X x6{std::move (X{})}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  X x7 = {std::move (X())}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  X x8 = {std::move (X{})}; // { dg-warning \"moving a temporary object prevents copy elision\" }\n+\n+  foo (std::move (A())); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  foo (std::move (A{})); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  bar (std::move (X())); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+  bar (std::move (X{})); // { dg-warning \"moving a temporary object prevents copy elision\" }\n+\n+  foo (std::move (a1));\n+  bar (std::move (x1));\n+}"}]}