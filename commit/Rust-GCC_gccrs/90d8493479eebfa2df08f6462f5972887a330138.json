{"sha": "90d8493479eebfa2df08f6462f5972887a330138", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBkODQ5MzQ3OWVlYmZhMmRmMDhmNjQ2MmY1OTcyODg3YTMzMDEzOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-06-12T20:47:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-06-12T20:47:08Z"}, "message": "toplev.c (process_options): Reject -fabi-version=1.\n\ngcc/\n\t* toplev.c (process_options): Reject -fabi-version=1.\ngcc/cp/\n\t* call.c (build_operator_new_call): Remove -fabi-version=1 support.\n\t* class.c (walk_subobject_offsets, include_empty_classes): Likewise.\n\t(layout_nonempty_base_or_field, end_of_class): Likewise.\n\t(layout_empty_base, build_base_field, layout_class_type): Likewise.\n\t(is_empty_class, add_vcall_offset_vtbl_entries_1): Likewise.\n\t(layout_virtual_bases): Likewise.\n\t* decl.c (compute_array_index_type): Likewise.\n\t* mangle.c (write_mangled_name, write_prefix): Likewise.\n\t(write_template_prefix, write_integer_cst, write_expression): Likewise.\n\t(write_template_arg, write_array_type): Likewise.\n\t* method.c (lazily_declare_fn): Likewise.\n\t* rtti.c (get_pseudo_ti_index): Likewise.\n\t* typeck.c (comp_array_types): Likewise.\n\nFrom-SVN: r211592", "tree": {"sha": "fb6c67f9fd779411a8cc1494ddd0c7961d42676d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb6c67f9fd779411a8cc1494ddd0c7961d42676d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90d8493479eebfa2df08f6462f5972887a330138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d8493479eebfa2df08f6462f5972887a330138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d8493479eebfa2df08f6462f5972887a330138", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d8493479eebfa2df08f6462f5972887a330138/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8fdcb6a997e7125d155b79947a1793f01611527b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdcb6a997e7125d155b79947a1793f01611527b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fdcb6a997e7125d155b79947a1793f01611527b"}], "stats": {"total": 950, "additions": 135, "deletions": 815}, "files": [{"sha": "6344a539492099bc1876ade232b60cbde0898b31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -1,3 +1,7 @@\n+2014-06-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* toplev.c (process_options): Reject -fabi-version=1.\n+\n 2014-06-12  Jeff Law  <law@redhat.com>\n \n         PR tree-optimization/61009"}, {"sha": "f61fab52b73476cc1552fad88a165a1958d77e6e", "filename": "gcc/common.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -776,7 +776,7 @@ Driver Undocumented\n ;    Therefore, 0 will not necessarily indicate the same ABI in different\n ;    versions of G++.\n ;\n-; 1: The version of the ABI first used in G++ 3.2.\n+; 1: The version of the ABI first used in G++ 3.2.  No longer selectable.\n ;\n ; 2: The version of the ABI first used in G++ 3.4 (and current default).\n ;"}, {"sha": "7bfa9dcb15a5990f544f6829238e63928b154784", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -1,3 +1,19 @@\n+2014-06-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* call.c (build_operator_new_call): Remove -fabi-version=1 support.\n+\t* class.c (walk_subobject_offsets, include_empty_classes): Likewise.\n+\t(layout_nonempty_base_or_field, end_of_class): Likewise.\n+\t(layout_empty_base, build_base_field, layout_class_type): Likewise.\n+\t(is_empty_class, add_vcall_offset_vtbl_entries_1): Likewise.\n+\t(layout_virtual_bases): Likewise.\n+\t* decl.c (compute_array_index_type): Likewise.\n+\t* mangle.c (write_mangled_name, write_prefix): Likewise.\n+\t(write_template_prefix, write_integer_cst, write_expression): Likewise.\n+\t(write_template_arg, write_array_type): Likewise.\n+\t* method.c (lazily_declare_fn): Likewise.\n+\t* rtti.c (get_pseudo_ti_index): Likewise.\n+\t* typeck.c (comp_array_types): Likewise.\n+\n 2014-06-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* vtable-class-hierarchy.c: Update handling for section names"}, {"sha": "ac14ce24dddcb2814e34a06f6ca52d56c3af936f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -4130,29 +4130,17 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n    if (*cookie_size)\n      {\n        bool use_cookie = true;\n-       if (!abi_version_at_least (2))\n-\t {\n-\t   /* In G++ 3.2, the check was implemented incorrectly; it\n-\t      looked at the placement expression, rather than the\n-\t      type of the function.  */\n-\t   if ((*args)->length () == 2\n-\t       && same_type_p (TREE_TYPE ((**args)[1]), ptr_type_node))\n-\t     use_cookie = false;\n-\t }\n-       else\n-\t {\n-\t   tree arg_types;\n-\n-\t   arg_types = TYPE_ARG_TYPES (TREE_TYPE (cand->fn));\n-\t   /* Skip the size_t parameter.  */\n-\t   arg_types = TREE_CHAIN (arg_types);\n-\t   /* Check the remaining parameters (if any).  */\n-\t   if (arg_types\n-\t       && TREE_CHAIN (arg_types) == void_list_node\n-\t       && same_type_p (TREE_VALUE (arg_types),\n-\t\t\t       ptr_type_node))\n-\t     use_cookie = false;\n-\t }\n+       tree arg_types;\n+\n+       arg_types = TYPE_ARG_TYPES (TREE_TYPE (cand->fn));\n+       /* Skip the size_t parameter.  */\n+       arg_types = TREE_CHAIN (arg_types);\n+       /* Check the remaining parameters (if any).  */\n+       if (arg_types\n+\t   && TREE_CHAIN (arg_types) == void_list_node\n+\t   && same_type_p (TREE_VALUE (arg_types),\n+\t\t\t   ptr_type_node))\n+\t use_cookie = false;\n        /* If we need a cookie, adjust the number of bytes allocated.  */\n        if (use_cookie)\n \t {"}, {"sha": "a96b3602786422d8e445a73d2502d370f22c8d0f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 66, "deletions": 280, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -3820,8 +3820,7 @@ walk_subobject_offsets (tree type,\n \n   if (!TYPE_P (type))\n     {\n-      if (abi_version_at_least (2))\n-\ttype_binfo = type;\n+      type_binfo = type;\n       type = BINFO_TYPE (type);\n     }\n \n@@ -3847,43 +3846,29 @@ walk_subobject_offsets (tree type,\n \t{\n \t  tree binfo_offset;\n \n-\t  if (abi_version_at_least (2)\n-\t      && BINFO_VIRTUAL_P (binfo))\n+\t  if (BINFO_VIRTUAL_P (binfo))\n \t    continue;\n \n-\t  if (!vbases_p\n-\t      && BINFO_VIRTUAL_P (binfo)\n-\t      && !BINFO_PRIMARY_P (binfo))\n-\t    continue;\n-\n-\t  if (!abi_version_at_least (2))\n-\t    binfo_offset = size_binop (PLUS_EXPR,\n-\t\t\t\t       offset,\n-\t\t\t\t       BINFO_OFFSET (binfo));\n-\t  else\n-\t    {\n-\t      tree orig_binfo;\n-\t      /* We cannot rely on BINFO_OFFSET being set for the base\n-\t\t class yet, but the offsets for direct non-virtual\n-\t\t bases can be calculated by going back to the TYPE.  */\n-\t      orig_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n-\t      binfo_offset = size_binop (PLUS_EXPR,\n-\t\t\t\t\t offset,\n-\t\t\t\t\t BINFO_OFFSET (orig_binfo));\n-\t    }\n+\t  tree orig_binfo;\n+\t  /* We cannot rely on BINFO_OFFSET being set for the base\n+\t     class yet, but the offsets for direct non-virtual\n+\t     bases can be calculated by going back to the TYPE.  */\n+\t  orig_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n+\t  binfo_offset = size_binop (PLUS_EXPR,\n+\t\t\t\t     offset,\n+\t\t\t\t     BINFO_OFFSET (orig_binfo));\n \n \t  r = walk_subobject_offsets (binfo,\n \t\t\t\t      f,\n \t\t\t\t      binfo_offset,\n \t\t\t\t      offsets,\n \t\t\t\t      max_offset,\n-\t\t\t\t      (abi_version_at_least (2)\n-\t\t\t\t       ? /*vbases_p=*/0 : vbases_p));\n+\t\t\t\t      /*vbases_p=*/0);\n \t  if (r)\n \t    return r;\n \t}\n \n-      if (abi_version_at_least (2) && CLASSTYPE_VBASECLASSES (type))\n+      if (CLASSTYPE_VBASECLASSES (type))\n \t{\n \t  unsigned ix;\n \t  vec<tree, va_gc> *vbases;\n@@ -3936,11 +3921,7 @@ walk_subobject_offsets (tree type,\n \t  {\n \t    tree field_offset;\n \n-\t    if (abi_version_at_least (2))\n-\t      field_offset = byte_position (field);\n-\t    else\n-\t      /* In G++ 3.2, DECL_FIELD_OFFSET was used.  */\n-\t      field_offset = DECL_FIELD_OFFSET (field);\n+\t    field_offset = byte_position (field);\n \n \t    r = walk_subobject_offsets (TREE_TYPE (field),\n \t\t\t\t\tf,\n@@ -3967,10 +3948,7 @@ walk_subobject_offsets (tree type,\n \n       /* Step through each of the elements in the array.  */\n       for (index = size_zero_node;\n-\t   /* G++ 3.2 had an off-by-one error here.  */\n-\t   (abi_version_at_least (2)\n-\t    ? !tree_int_cst_lt (TYPE_MAX_VALUE (domain), index)\n-\t    : tree_int_cst_lt (index, TYPE_MAX_VALUE (domain)));\n+\t   !tree_int_cst_lt (TYPE_MAX_VALUE (domain), index);\n \t   index = size_binop (PLUS_EXPR, index, size_one_node))\n \t{\n \t  r = walk_subobject_offsets (TREE_TYPE (type),\n@@ -4114,10 +4092,6 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \t offset zero.  */\n       if (TREE_CODE (rli->t) == UNION_TYPE)\n \tbreak;\n-      /* G++ 3.2 did not check for overlaps when placing a non-empty\n-\t virtual base.  */\n-      if (!abi_version_at_least (2) && binfo && BINFO_VIRTUAL_P (binfo))\n-\tbreak;\n       if (layout_conflict_p (field_p ? type : binfo, offset,\n \t\t\t     offsets, field_p))\n \t{\n@@ -4182,17 +4156,9 @@ layout_empty_base (record_layout_info rli, tree binfo,\n   alignment = ssize_int (CLASSTYPE_ALIGN_UNIT (basetype));\n \n   if (!integer_zerop (BINFO_OFFSET (binfo)))\n-    {\n-      if (abi_version_at_least (2))\n-\tpropagate_binfo_offsets\n-\t  (binfo, size_diffop_loc (input_location,\n+    propagate_binfo_offsets\n+      (binfo, size_diffop_loc (input_location,\n \t\t\t       size_zero_node, BINFO_OFFSET (binfo)));\n-      else\n-\twarning (OPT_Wabi,\n-\t\t \"offset of empty base %qT may not be ABI-compliant and may\"\n-\t\t \"change in a future version of GCC\",\n-\t\t BINFO_TYPE (binfo));\n-    }\n \n   /* This is an empty base class.  We first try to put it at offset\n      zero.  */\n@@ -4311,14 +4277,7 @@ build_base_field (record_layout_info rli, tree binfo,\n \t\t\t\t\t   /*offsets=*/NULL,\n \t\t\t\t\t   /*max_offset=*/NULL_TREE,\n \t\t\t\t\t   /*vbases_p=*/true))\n-\t    {\n-\t      if (abi_version_at_least (2))\n-\t\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n-\t      else\n-\t\twarning (OPT_Wabi,\n-\t\t\t \"class %qT will be considered nearly empty in a \"\n-\t\t\t \"future version of GCC\", t);\n-\t    }\n+\t    CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n \t}\n \n       /* We do not create a FIELD_DECL for empty base classes because\n@@ -5808,27 +5767,11 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n {\n   tree vbase;\n   tree t = rli->t;\n-  bool first_vbase = true;\n   tree *next_field;\n \n   if (BINFO_N_BASE_BINFOS (TYPE_BINFO (t)) == 0)\n     return;\n \n-  if (!abi_version_at_least(2))\n-    {\n-      /* In G++ 3.2, we incorrectly rounded the size before laying out\n-\t the virtual bases.  */\n-      finish_record_layout (rli, /*free_p=*/false);\n-#ifdef STRUCTURE_SIZE_BOUNDARY\n-      /* Packed structures don't need to have minimum size.  */\n-      if (! TYPE_PACKED (t))\n-\tTYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), (unsigned) STRUCTURE_SIZE_BOUNDARY);\n-#endif\n-      rli->offset = TYPE_SIZE_UNIT (t);\n-      rli->bitpos = bitsize_zero_node;\n-      rli->record_align = TYPE_ALIGN (t);\n-    }\n-\n   /* Find the last field.  The artificial fields created for virtual\n      bases will go after the last extant field to date.  */\n   next_field = &TYPE_FIELDS (t);\n@@ -5845,35 +5788,10 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \n       if (!BINFO_PRIMARY_P (vbase))\n \t{\n-\t  tree basetype = TREE_TYPE (vbase);\n-\n \t  /* This virtual base is not a primary base of any class in the\n \t     hierarchy, so we have to add space for it.  */\n \t  next_field = build_base_field (rli, vbase,\n \t\t\t\t\t offsets, next_field);\n-\n-\t  /* If the first virtual base might have been placed at a\n-\t     lower address, had we started from CLASSTYPE_SIZE, rather\n-\t     than TYPE_SIZE, issue a warning.  There can be both false\n-\t     positives and false negatives from this warning in rare\n-\t     cases; to deal with all the possibilities would probably\n-\t     require performing both layout algorithms and comparing\n-\t     the results which is not particularly tractable.  */\n-\t  if (warn_abi\n-\t      && first_vbase\n-\t      && (tree_int_cst_lt\n-\t\t  (size_binop (CEIL_DIV_EXPR,\n-\t\t\t       round_up_loc (input_location,\n-\t\t\t\t\t CLASSTYPE_SIZE (t),\n-\t\t\t\t\t CLASSTYPE_ALIGN (basetype)),\n-\t\t\t       bitsize_unit_node),\n-\t\t   BINFO_OFFSET (vbase))))\n-\t    warning (OPT_Wabi,\n-\t\t     \"offset of virtual base %qT is not ABI-compliant and \"\n-\t\t     \"may change in a future version of GCC\",\n-\t\t     basetype);\n-\n-\t  first_vbase = false;\n \t}\n     }\n }\n@@ -5927,8 +5845,7 @@ end_of_class (tree t, int include_virtuals_p)\n \tresult = offset;\n     }\n \n-  /* G++ 3.2 did not check indirect virtual bases.  */\n-  if (abi_version_at_least (2) && include_virtuals_p)\n+  if (include_virtuals_p)\n     for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n \t vec_safe_iterate (vbases, i, &base_binfo); i++)\n       {\n@@ -6015,17 +5932,9 @@ include_empty_classes (record_layout_info rli)\n   if (TREE_CODE (rli_size) == INTEGER_CST\n       && tree_int_cst_lt (rli_size, eoc))\n     {\n-      if (!abi_version_at_least (2))\n-\t/* In version 1 of the ABI, the size of a class that ends with\n-\t   a bitfield was not rounded up to a whole multiple of a\n-\t   byte.  Because rli_size_unit_so_far returns only the number\n-\t   of fully allocated bytes, any extra bits were not included\n-\t   in the size.  */\n-\trli->bitpos = round_down (rli->bitpos, BITS_PER_UNIT);\n-      else\n-\t/* The size should have been rounded to a whole byte.  */\n-\tgcc_assert (tree_int_cst_equal\n-\t\t    (rli->bitpos, round_down (rli->bitpos, BITS_PER_UNIT)));\n+      /* The size should have been rounded to a whole byte.  */\n+      gcc_assert (tree_int_cst_equal\n+\t\t  (rli->bitpos, round_down (rli->bitpos, BITS_PER_UNIT)));\n       rli->bitpos\n \t= size_binop (PLUS_EXPR,\n \t\t      rli->bitpos,\n@@ -6155,26 +6064,16 @@ layout_class_type (tree t, tree *virtuals_p)\n \t    integer_type = integer_types[itk];\n \t  } while (itk > 0 && integer_type == NULL_TREE);\n \n-\t  /* Figure out how much additional padding is required.  GCC\n-\t     3.2 always created a padding field, even if it had zero\n-\t     width.  */\n-\t  if (!abi_version_at_least (2)\n-\t      || tree_int_cst_lt (TYPE_SIZE (integer_type), DECL_SIZE (field)))\n+\t  /* Figure out how much additional padding is required.  */\n+\t  if (tree_int_cst_lt (TYPE_SIZE (integer_type), DECL_SIZE (field)))\n \t    {\n-\t      if (abi_version_at_least (2) && TREE_CODE (t) == UNION_TYPE)\n+\t      if (TREE_CODE (t) == UNION_TYPE)\n \t\t/* In a union, the padding field must have the full width\n \t\t   of the bit-field; all fields start at offset zero.  */\n \t\tpadding = DECL_SIZE (field);\n \t      else\n-\t\t{\n-\t\t  if (TREE_CODE (t) == UNION_TYPE)\n-\t\t    warning (OPT_Wabi, \"size assigned to %qT may not be \"\n-\t\t\t     \"ABI-compliant and may change in a future \"\n-\t\t\t     \"version of GCC\",\n-\t\t\t     t);\n-\t\t  padding = size_binop (MINUS_EXPR, DECL_SIZE (field),\n-\t\t\t\t\tTYPE_SIZE (integer_type));\n-\t\t}\n+\t\tpadding = size_binop (MINUS_EXPR, DECL_SIZE (field),\n+\t\t\t\t      TYPE_SIZE (integer_type));\n \t    }\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n \t  /* An unnamed bitfield does not normally affect the\n@@ -6201,26 +6100,17 @@ layout_class_type (tree t, tree *virtuals_p)\n \t     field is effectively invisible.  */\n \t  DECL_SIZE (field) = TYPE_SIZE (type);\n \t  /* We must also reset the DECL_MODE of the field.  */\n-\t  if (abi_version_at_least (2))\n-\t    DECL_MODE (field) = TYPE_MODE (type);\n-\t  else if (warn_abi\n-\t\t   && DECL_MODE (field) != TYPE_MODE (type))\n-\t    /* Versions of G++ before G++ 3.4 did not reset the\n-\t       DECL_MODE.  */\n-\t    warning (OPT_Wabi,\n-\t\t     \"the offset of %qD may not be ABI-compliant and may \"\n-\t\t     \"change in a future version of GCC\", field);\n+\t  DECL_MODE (field) = TYPE_MODE (type);\n \t}\n       else\n \tlayout_nonempty_base_or_field (rli, field, NULL_TREE,\n \t\t\t\t       empty_base_offsets);\n \n       /* Remember the location of any empty classes in FIELD.  */\n-      if (abi_version_at_least (2))\n-\trecord_subobject_offsets (TREE_TYPE (field),\n-\t\t\t\t  byte_position(field),\n-\t\t\t\t  empty_base_offsets,\n-\t\t\t\t  /*is_data_member=*/true);\n+      record_subobject_offsets (TREE_TYPE (field),\n+\t\t\t\tbyte_position(field),\n+\t\t\t\tempty_base_offsets,\n+\t\t\t\t/*is_data_member=*/true);\n \n       /* If a bit-field does not immediately follow another bit-field,\n \t and yet it starts in the middle of a byte, we have failed to\n@@ -6239,17 +6129,6 @@ layout_class_type (tree t, tree *virtuals_p)\n \twarning (OPT_Wabi, \"offset of %q+D is not ABI-compliant and may \"\n \t\t \"change in a future version of GCC\", field);\n \n-      /* G++ used to use DECL_FIELD_OFFSET as if it were the byte\n-\t offset of the field.  */\n-      if (warn_abi\n-\t  && !abi_version_at_least (2)\n-\t  && !tree_int_cst_equal (DECL_FIELD_OFFSET (field),\n-\t\t\t\t  byte_position (field))\n-\t  && contains_empty_class_p (TREE_TYPE (field)))\n-\twarning (OPT_Wabi, \"%q+D contains empty classes which may cause base \"\n-\t\t \"classes to be placed at different locations in a \"\n-\t\t \"future version of GCC\", field);\n-\n       /* The middle end uses the type of expressions to determine the\n \t possible range of expression values.  In order to optimize\n \t \"x.i > 7\" to \"false\" for a 2-bit bitfield \"i\", the middle end\n@@ -6300,7 +6179,7 @@ layout_class_type (tree t, tree *virtuals_p)\n       last_field_was_bitfield = DECL_C_BIT_FIELD (field);\n     }\n \n-  if (abi_version_at_least (2) && !integer_zerop (rli->bitpos))\n+  if (!integer_zerop (rli->bitpos))\n     {\n       /* Make sure that we are on a byte boundary so that the size of\n \t the class without virtual bases will always be a round number\n@@ -6309,11 +6188,6 @@ layout_class_type (tree t, tree *virtuals_p)\n       normalize_rli (rli);\n     }\n \n-  /* G++ 3.2 does not allow virtual bases to be overlaid with tail\n-     padding.  */\n-  if (!abi_version_at_least (2))\n-    include_empty_classes(rli);\n-\n   /* Delete all zero-width bit-fields from the list of fields.  Now\n      that the type is laid out they are no longer important.  */\n   remove_zero_width_bit_fields (t);\n@@ -6325,45 +6199,30 @@ layout_class_type (tree t, tree *virtuals_p)\n     {\n       base_t = make_node (TREE_CODE (t));\n \n-      /* Set the size and alignment for the new type.  In G++ 3.2, all\n-\t empty classes were considered to have size zero when used as\n-\t base classes.  */\n-      if (!abi_version_at_least (2) && CLASSTYPE_EMPTY_P (t))\n-\t{\n-\t  TYPE_SIZE (base_t) = bitsize_zero_node;\n-\t  TYPE_SIZE_UNIT (base_t) = size_zero_node;\n-\t  if (warn_abi && !integer_zerop (rli_size_unit_so_far (rli)))\n-\t    warning (OPT_Wabi,\n-\t\t     \"layout of classes derived from empty class %qT \"\n-\t\t     \"may change in a future version of GCC\",\n-\t\t     t);\n-\t}\n-      else\n-\t{\n-\t  tree eoc;\n-\n-\t  /* If the ABI version is not at least two, and the last\n-\t     field was a bit-field, RLI may not be on a byte\n-\t     boundary.  In particular, rli_size_unit_so_far might\n-\t     indicate the last complete byte, while rli_size_so_far\n-\t     indicates the total number of bits used.  Therefore,\n-\t     rli_size_so_far, rather than rli_size_unit_so_far, is\n-\t     used to compute TYPE_SIZE_UNIT.  */\n-\t  eoc = end_of_class (t, /*include_virtuals_p=*/0);\n-\t  TYPE_SIZE_UNIT (base_t)\n-\t    = size_binop (MAX_EXPR,\n-\t\t\t  convert (sizetype,\n-\t\t\t\t   size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t\t       rli_size_so_far (rli),\n-\t\t\t\t\t       bitsize_int (BITS_PER_UNIT))),\n-\t\t\t  eoc);\n-\t  TYPE_SIZE (base_t)\n-\t    = size_binop (MAX_EXPR,\n-\t\t\t  rli_size_so_far (rli),\n-\t\t\t  size_binop (MULT_EXPR,\n-\t\t\t\t      convert (bitsizetype, eoc),\n-\t\t\t\t      bitsize_int (BITS_PER_UNIT)));\n-\t}\n+      /* Set the size and alignment for the new type.  */\n+      tree eoc;\n+\n+      /* If the ABI version is not at least two, and the last\n+\t field was a bit-field, RLI may not be on a byte\n+\t boundary.  In particular, rli_size_unit_so_far might\n+\t indicate the last complete byte, while rli_size_so_far\n+\t indicates the total number of bits used.  Therefore,\n+\t rli_size_so_far, rather than rli_size_unit_so_far, is\n+\t used to compute TYPE_SIZE_UNIT.  */\n+      eoc = end_of_class (t, /*include_virtuals_p=*/0);\n+      TYPE_SIZE_UNIT (base_t)\n+\t= size_binop (MAX_EXPR,\n+\t\t      convert (sizetype,\n+\t\t\t       size_binop (CEIL_DIV_EXPR,\n+\t\t\t\t\t   rli_size_so_far (rli),\n+\t\t\t\t\t   bitsize_int (BITS_PER_UNIT))),\n+\t\t      eoc);\n+      TYPE_SIZE (base_t)\n+\t= size_binop (MAX_EXPR,\n+\t\t      rli_size_so_far (rli),\n+\t\t      size_binop (MULT_EXPR,\n+\t\t\t\t  convert (bitsizetype, eoc),\n+\t\t\t\t  bitsize_int (BITS_PER_UNIT)));\n       TYPE_ALIGN (base_t) = rli->record_align;\n       TYPE_USER_ALIGN (base_t) = TYPE_USER_ALIGN (t);\n \n@@ -7908,12 +7767,7 @@ is_empty_class (tree type)\n   if (! CLASS_TYPE_P (type))\n     return 0;\n \n-  /* In G++ 3.2, whether or not a class was empty was determined by\n-     looking at its size.  */\n-  if (abi_version_at_least (2))\n-    return CLASSTYPE_EMPTY_P (type);\n-  else\n-    return integer_zerop (CLASSTYPE_SIZE (type));\n+  return CLASSTYPE_EMPTY_P (type);\n }\n \n /* Returns true if TYPE contains an empty class.  */\n@@ -9278,83 +9132,15 @@ static void\n add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n {\n   /* Make entries for the rest of the virtuals.  */\n-  if (abi_version_at_least (2))\n-    {\n-      tree orig_fn;\n-\n-      /* The ABI requires that the methods be processed in declaration\n-\t order.  G++ 3.2 used the order in the vtable.  */\n-      for (orig_fn = TYPE_METHODS (BINFO_TYPE (binfo));\n-\t   orig_fn;\n-\t   orig_fn = DECL_CHAIN (orig_fn))\n-\tif (DECL_VINDEX (orig_fn))\n-\t  add_vcall_offset (orig_fn, binfo, vid);\n-    }\n-  else\n-    {\n-      tree derived_virtuals;\n-      tree base_virtuals;\n-      tree orig_virtuals;\n-      /* If BINFO is a primary base, the most derived class which has\n-\t BINFO as a primary base; otherwise, just BINFO.  */\n-      tree non_primary_binfo;\n-\n-      /* We might be a primary base class.  Go up the inheritance hierarchy\n-\t until we find the most derived class of which we are a primary base:\n-\t it is the BINFO_VIRTUALS there that we need to consider.  */\n-      non_primary_binfo = binfo;\n-      while (BINFO_INHERITANCE_CHAIN (non_primary_binfo))\n-\t{\n-\t  tree b;\n-\n-\t  /* If we have reached a virtual base, then it must be vid->vbase,\n-\t     because we ignore other virtual bases in\n-\t     add_vcall_offset_vtbl_entries_r.  In turn, it must be a primary\n-\t     base (possibly multi-level) of vid->binfo, or we wouldn't\n-\t     have called build_vcall_and_vbase_vtbl_entries for it.  But it\n-\t     might be a lost primary, so just skip down to vid->binfo.  */\n-\t  if (BINFO_VIRTUAL_P (non_primary_binfo))\n-\t    {\n-\t      gcc_assert (non_primary_binfo == vid->vbase);\n-\t      non_primary_binfo = vid->binfo;\n-\t      break;\n-\t    }\n-\n-\t  b = BINFO_INHERITANCE_CHAIN (non_primary_binfo);\n-\t  if (get_primary_binfo (b) != non_primary_binfo)\n-\t    break;\n-\t  non_primary_binfo = b;\n-\t}\n-\n-      if (vid->ctor_vtbl_p)\n-\t/* For a ctor vtable we need the equivalent binfo within the hierarchy\n-\t   where rtti_binfo is the most derived type.  */\n-\tnon_primary_binfo\n-\t  = original_binfo (non_primary_binfo, vid->rtti_binfo);\n-\n-      for (base_virtuals = BINFO_VIRTUALS (binfo),\n-\t     derived_virtuals = BINFO_VIRTUALS (non_primary_binfo),\n-\t     orig_virtuals = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (binfo)));\n-\t   base_virtuals;\n-\t   base_virtuals = TREE_CHAIN (base_virtuals),\n-\t     derived_virtuals = TREE_CHAIN (derived_virtuals),\n-\t     orig_virtuals = TREE_CHAIN (orig_virtuals))\n-\t{\n-\t  tree orig_fn;\n-\n-\t  /* Find the declaration that originally caused this function to\n-\t     be present in BINFO_TYPE (binfo).  */\n-\t  orig_fn = BV_FN (orig_virtuals);\n-\n-\t  /* When processing BINFO, we only want to generate vcall slots for\n-\t     function slots introduced in BINFO.  So don't try to generate\n-\t     one if the function isn't even defined in BINFO.  */\n-\t  if (!SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), DECL_CONTEXT (orig_fn)))\n-\t    continue;\n-\n-\t  add_vcall_offset (orig_fn, binfo, vid);\n-\t}\n-    }\n+  tree orig_fn;\n+\n+  /* The ABI requires that the methods be processed in declaration\n+     order.  */\n+  for (orig_fn = TYPE_METHODS (BINFO_TYPE (binfo));\n+       orig_fn;\n+       orig_fn = DECL_CHAIN (orig_fn))\n+    if (DECL_VINDEX (orig_fn))\n+      add_vcall_offset (orig_fn, binfo, vid);\n }\n \n /* Add a vcall offset entry for ORIG_FN to the vtable.  */"}, {"sha": "c472ee5522a475a8a3f2ee1ced7f63e7012263a8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -8268,7 +8268,6 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n {\n   tree itype;\n   tree osize = size;\n-  tree abi_1_itype = NULL_TREE;\n \n   if (error_operand_p (size))\n     return error_mark_node;\n@@ -8305,9 +8304,6 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n \t      if (size == error_mark_node)\n \t\treturn error_mark_node;\n \t      type = TREE_TYPE (size);\n-\t      /* We didn't support this case in GCC 3.2, so don't bother\n-\t\t trying to model it now in ABI v1.  */\n-\t      abi_1_itype = error_mark_node;\n \t    }\n \n \t  if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))\n@@ -8354,17 +8350,6 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n       return itype;\n     }\n   \n-  if (!abi_version_at_least (2) && processing_template_decl\n-      && abi_1_itype == NULL_TREE)\n-    /* For abi-1, we handled all instances in templates the same way,\n-       even when they were non-dependent. This affects the manglings\n-       produced.  So, we do the normal checking for non-dependent\n-       sizes, but at the end we'll return the same type that abi-1\n-       would have, but with TYPE_CANONICAL set to the \"right\"\n-       value that the current ABI would provide. */\n-    abi_1_itype = build_index_type (build_min (MINUS_EXPR, sizetype,\n-\t\t\t\t\t       osize, integer_one_node));\n-\n   /* Normally, the array-bound will be a constant.  */\n   if (TREE_CODE (size) == INTEGER_CST)\n     {\n@@ -8510,14 +8495,7 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n     }\n \n   /* Create and return the appropriate index type.  */\n-  if (abi_1_itype && abi_1_itype != error_mark_node)\n-    {\n-      tree t = build_index_type (itype);\n-      TYPE_CANONICAL (abi_1_itype) = TYPE_CANONICAL (t);\n-      itype = abi_1_itype;\n-    }\n-  else\n-    itype = build_index_type (itype);\n+  itype = build_index_type (itype);\n \n   /* If the index type were dependent, we would have returned early, so\n      remember that it isn't.  */"}, {"sha": "86319c6e97273a7bfc133779c97f07ae5edacd54", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 26, "deletions": 95, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -663,10 +663,7 @@ write_mangled_name (const tree decl, bool top_level)\n \t     <source-name> without a type.\"  We cannot write\n \t     overloaded operators that way though, because it contains\n \t     characters invalid in assembler.  */\n-\t  if (abi_version_at_least (2))\n-\t    write_string (\"_Z\");\n-\t  else\n-\t    G.need_abi_warning = true;\n+\t  write_string (\"_Z\");\n \t  write_source_name (DECL_NAME (decl));\n \t}\n     }\n@@ -677,17 +674,10 @@ write_mangled_name (const tree decl, bool top_level)\n \t       /* And neither are `extern \"C\"' variables.  */\n \t       || DECL_EXTERN_C_P (decl)))\n     {\n-      if (top_level || abi_version_at_least (2))\n-\tgoto unmangled_name;\n-      else\n-\t{\n-\t  G.need_abi_warning = true;\n-\t  goto mangled_name;\n-\t}\n+      goto unmangled_name;\n     }\n   else\n     {\n-    mangled_name:;\n       write_string (\"_Z\");\n       write_encoding (decl);\n     }\n@@ -1020,13 +1010,7 @@ write_prefix (const tree node)\n \ttemplate_info = TYPE_TEMPLATE_INFO (node);\n     }\n \n-  /* In G++ 3.2, the name of the template parameter was used.  */\n-  if (TREE_CODE (node) == TEMPLATE_TYPE_PARM\n-      && !abi_version_at_least (2))\n-    G.need_abi_warning = true;\n-\n-  if (TREE_CODE (node) == TEMPLATE_TYPE_PARM\n-      && abi_version_at_least (2))\n+  if (TREE_CODE (node) == TEMPLATE_TYPE_PARM)\n     write_template_param (node);\n   else if (template_info != NULL)\n     /* Templated.  */\n@@ -1124,15 +1108,8 @@ write_template_prefix (const tree node)\n   if (find_substitution (substitution))\n     return;\n \n-  /* In G++ 3.2, the name of the template template parameter was used.  */\n-  if (TREE_TYPE (templ)\n-      && TREE_CODE (TREE_TYPE (templ)) == TEMPLATE_TEMPLATE_PARM\n-      && !abi_version_at_least (2))\n-    G.need_abi_warning = true;\n-\n   if (TREE_TYPE (templ)\n-      && TREE_CODE (TREE_TYPE (templ)) == TEMPLATE_TEMPLATE_PARM\n-      && abi_version_at_least (2))\n+      && TREE_CODE (TREE_TYPE (templ)) == TEMPLATE_TEMPLATE_PARM)\n     write_template_param (TREE_TYPE (templ));\n   else\n     {\n@@ -1597,45 +1574,29 @@ write_integer_cst (const tree cst)\n static void\n write_real_cst (const tree value)\n {\n-  if (abi_version_at_least (2))\n-    {\n-      long target_real[4];  /* largest supported float */\n-      char buffer[9];       /* eight hex digits in a 32-bit number */\n-      int i, limit, dir;\n+  long target_real[4];  /* largest supported float */\n+  char buffer[9];       /* eight hex digits in a 32-bit number */\n+  int i, limit, dir;\n \n-      tree type = TREE_TYPE (value);\n-      int words = GET_MODE_BITSIZE (TYPE_MODE (type)) / 32;\n+  tree type = TREE_TYPE (value);\n+  int words = GET_MODE_BITSIZE (TYPE_MODE (type)) / 32;\n \n-      real_to_target (target_real, &TREE_REAL_CST (value),\n-\t\t      TYPE_MODE (type));\n-\n-      /* The value in target_real is in the target word order,\n-\t so we must write it out backward if that happens to be\n-\t little-endian.  write_number cannot be used, it will\n-\t produce uppercase.  */\n-      if (FLOAT_WORDS_BIG_ENDIAN)\n-\ti = 0, limit = words, dir = 1;\n-      else\n-\ti = words - 1, limit = -1, dir = -1;\n+  real_to_target (target_real, &TREE_REAL_CST (value),\n+\t\t  TYPE_MODE (type));\n \n-      for (; i != limit; i += dir)\n-\t{\n-\t  sprintf (buffer, \"%08lx\", (unsigned long) target_real[i]);\n-\t  write_chars (buffer, 8);\n-\t}\n-    }\n+  /* The value in target_real is in the target word order,\n+     so we must write it out backward if that happens to be\n+     little-endian.  write_number cannot be used, it will\n+     produce uppercase.  */\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    i = 0, limit = words, dir = 1;\n   else\n+    i = words - 1, limit = -1, dir = -1;\n+\n+  for (; i != limit; i += dir)\n     {\n-      /* In G++ 3.3 and before the REAL_VALUE_TYPE was written out\n-\t literally.  Note that compatibility with 3.2 is impossible,\n-\t because the old floating-point emulator used a different\n-\t format for REAL_VALUE_TYPE.  */\n-      size_t i;\n-      for (i = 0; i < sizeof (TREE_REAL_CST (value)); ++i)\n-\twrite_number (((unsigned char *) &TREE_REAL_CST (value))[i],\n-\t\t      /*unsigned_p*/ 1,\n-\t\t      /*base*/ 16);\n-      G.need_abi_warning = 1;\n+      sprintf (buffer, \"%08lx\", (unsigned long) target_real[i]);\n+      write_chars (buffer, 8);\n     }\n }\n \n@@ -2631,7 +2592,7 @@ write_expression (tree expr)\n     write_template_param (expr);\n   /* Handle literals.  */\n   else if (TREE_CODE_CLASS (code) == tcc_constant\n-\t   || (abi_version_at_least (2) && code == CONST_DECL))\n+\t   || code == CONST_DECL)\n     write_template_arg_literal (expr);\n   else if (code == PARM_DECL && DECL_ARTIFICIAL (expr))\n     {\n@@ -2668,10 +2629,6 @@ write_expression (tree expr)\n     }\n   else if (DECL_P (expr))\n     {\n-      /* G++ 3.2 incorrectly mangled non-type template arguments of\n-\t enumeration type using their names.  */\n-      if (code == CONST_DECL)\n-\tG.need_abi_warning = 1;\n       write_char ('L');\n       write_mangled_name (expr, false);\n       write_char ('E');\n@@ -2709,22 +2666,12 @@ write_expression (tree expr)\n \t  member = BASELINK_FUNCTIONS (expr);\n \t}\n \n-      if (!abi_version_at_least (2) && DECL_P (member))\n-\t{\n-\t  write_string (\"sr\");\n-\t  write_type (scope);\n-\t  /* G++ 3.2 incorrectly put out both the \"sr\" code and\n-\t     the nested name of the qualified name.  */\n-\t  G.need_abi_warning = 1;\n-\t  write_encoding (member);\n-\t}\n-\n       /* If the MEMBER is a real declaration, then the qualifying\n \t scope was not dependent.  Ideally, we would not have a\n \t SCOPE_REF in those cases, but sometimes we do.  If the second\n \t argument is a DECL, then the name must not have been\n \t dependent.  */\n-      else if (DECL_P (member))\n+      if (DECL_P (member))\n \twrite_expression (member);\n       else\n \t{\n@@ -3109,10 +3056,7 @@ write_template_arg (tree node)\n \t internal consistency, such arguments use a conversion from\n \t address of object to reference type.  */\n       gcc_assert (TREE_CODE (TREE_OPERAND (node, 0)) == ADDR_EXPR);\n-      if (abi_version_at_least (2))\n-\tnode = TREE_OPERAND (TREE_OPERAND (node, 0), 0);\n-      else\n-\tG.need_abi_warning = 1;\n+      node = TREE_OPERAND (TREE_OPERAND (node, 0), 0);\n     }\n \n   if (TREE_CODE (node) == BASELINK\n@@ -3147,15 +3091,11 @@ write_template_arg (tree node)\n     /* A template appearing as a template arg is a template template arg.  */\n     write_template_template_arg (node);\n   else if ((TREE_CODE_CLASS (code) == tcc_constant && code != PTRMEM_CST)\n-\t   || (abi_version_at_least (2) && code == CONST_DECL)\n+\t   || code == CONST_DECL\n \t   || null_member_pointer_value_p (node))\n     write_template_arg_literal (node);\n   else if (DECL_P (node))\n     {\n-      /* Until ABI version 2, non-type template arguments of\n-\t enumeration type were mangled using their names.  */\n-      if (code == CONST_DECL && !abi_version_at_least (2))\n-\tG.need_abi_warning = 1;\n       write_char ('L');\n       /* Until ABI version 3, the underscore before the mangled name\n \t was incorrectly omitted.  */\n@@ -3230,15 +3170,6 @@ write_array_type (const tree type)\n       else\n \t{\n \t  max = TREE_OPERAND (max, 0);\n-\t  if (!abi_version_at_least (2))\n-\t    {\n-\t      /* value_dependent_expression_p presumes nothing is\n-\t\t dependent when PROCESSING_TEMPLATE_DECL is zero.  */\n-\t      ++processing_template_decl;\n-\t      if (!value_dependent_expression_p (max))\n-\t\tG.need_abi_warning = 1;\n-\t      --processing_template_decl;\n-\t    }\n \t  write_expression (max);\n \t}\n "}, {"sha": "4d8aac1dfbb944d3d01ef527fdb7d51242d0e449", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -2067,21 +2067,12 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n   add_method (type, fn, NULL_TREE);\n   /* Add it to TYPE_METHODS.  */\n   if (sfk == sfk_destructor\n-      && DECL_VIRTUAL_P (fn)\n-      && abi_version_at_least (2))\n+      && DECL_VIRTUAL_P (fn))\n     /* The ABI requires that a virtual destructor go at the end of the\n        vtable.  */\n     TYPE_METHODS (type) = chainon (TYPE_METHODS (type), fn);\n   else\n     {\n-      /* G++ 3.2 put the implicit destructor at the *beginning* of the\n-\t TYPE_METHODS list, which cause the destructor to be emitted\n-\t in an incorrect location in the vtable.  */\n-      if (warn_abi && sfk == sfk_destructor && DECL_VIRTUAL_P (fn))\n-\twarning (OPT_Wabi, \"vtable layout for class %qT may not be ABI-compliant\"\n-\t\t \"and may change in a future version of GCC due to \"\n-\t\t \"implicit virtual destructor\",\n-\t\t type);\n       DECL_CHAIN (fn) = TYPE_METHODS (type);\n       TYPE_METHODS (type) = fn;\n     }"}, {"sha": "10cc168faf6ab405ed053b6d14036cd60e08c98a", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -1331,14 +1331,8 @@ get_pseudo_ti_index (tree type)\n \t\t/* already created.  */\n \t\tbreak;\n \n-\t      /* Create the array of __base_class_type_info entries.\n-\t\t G++ 3.2 allocated an array that had one too many\n-\t\t entries, and then filled that extra entries with\n-\t\t zeros.  */\n-\t      if (abi_version_at_least (2))\n-\t\tarray_domain = build_index_type (size_int (num_bases - 1));\n-\t      else\n-\t\tarray_domain = build_index_type (size_int (num_bases));\n+\t      /* Create the array of __base_class_type_info entries.  */\n+\t      array_domain = build_index_type (size_int (num_bases - 1));\n \t      base_array = build_array_type ((*tinfo_descs)[TK_BASE_TYPE].type,\n \t\t\t\t\t     array_domain);\n "}, {"sha": "65dccf7a1b3514d105043be93a7561d5bc42162f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -1114,17 +1114,6 @@ comp_array_types (const_tree t1, const_tree t2, bool allow_redeclaration)\n     return false;\n   max1 = TYPE_MAX_VALUE (d1);\n   max2 = TYPE_MAX_VALUE (d2);\n-  if (processing_template_decl && !abi_version_at_least (2)\n-      && !value_dependent_expression_p (max1)\n-      && !value_dependent_expression_p (max2))\n-    {\n-      /* With abi-1 we do not fold non-dependent array bounds, (and\n-\t consequently mangle them incorrectly).  We must therefore\n-\t fold them here, to verify the domains have the same\n-\t value.  */\n-      max1 = fold (max1);\n-      max2 = fold (max2);\n-    }\n \n   if (!cp_tree_equal (max1, max2))\n     return false;"}, {"sha": "4efd3e22af2f225660a315744bb117aac374ef43", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -2479,92 +2479,6 @@ functions taking vectors of different sizes.\n The mangling is changed in @option{-fabi-version=4}.\n @end itemize\n \n-The known incompatibilities in @option{-fabi-version=1} include:\n-\n-@itemize @bullet\n-\n-@item\n-Incorrect handling of tail-padding for bit-fields.  G++ may attempt to\n-pack data into the same byte as a base class.  For example:\n-\n-@smallexample\n-struct A @{ virtual void f(); int f1 : 1; @};\n-struct B : public A @{ int f2 : 1; @};\n-@end smallexample\n-\n-@noindent\n-In this case, G++ places @code{B::f2} into the same byte\n-as @code{A::f1}; other compilers do not.  You can avoid this problem\n-by explicitly padding @code{A} so that its size is a multiple of the\n-byte size on your platform; that causes G++ and other compilers to\n-lay out @code{B} identically.\n-\n-@item\n-Incorrect handling of tail-padding for virtual bases.  G++ does not use\n-tail padding when laying out virtual bases.  For example:\n-\n-@smallexample\n-struct A @{ virtual void f(); char c1; @};\n-struct B @{ B(); char c2; @};\n-struct C : public A, public virtual B @{@};\n-@end smallexample\n-\n-@noindent\n-In this case, G++ does not place @code{B} into the tail-padding for\n-@code{A}; other compilers do.  You can avoid this problem by\n-explicitly padding @code{A} so that its size is a multiple of its\n-alignment (ignoring virtual base classes); that causes G++ and other\n-compilers to lay out @code{C} identically.\n-\n-@item\n-Incorrect handling of bit-fields with declared widths greater than that\n-of their underlying types, when the bit-fields appear in a union.  For\n-example:\n-\n-@smallexample\n-union U @{ int i : 4096; @};\n-@end smallexample\n-\n-@noindent\n-Assuming that an @code{int} does not have 4096 bits, G++ makes the\n-union too small by the number of bits in an @code{int}.\n-\n-@item\n-Empty classes can be placed at incorrect offsets.  For example:\n-\n-@smallexample\n-struct A @{@};\n-\n-struct B @{\n-  A a;\n-  virtual void f ();\n-@};\n-\n-struct C : public B, public A @{@};\n-@end smallexample\n-\n-@noindent\n-G++ places the @code{A} base class of @code{C} at a nonzero offset;\n-it should be placed at offset zero.  G++ mistakenly believes that the\n-@code{A} data member of @code{B} is already at offset zero.\n-\n-@item\n-Names of template functions whose types involve @code{typename} or\n-template template parameters can be mangled incorrectly.\n-\n-@smallexample\n-template <typename Q>\n-void f(typename Q::X) @{@}\n-\n-template <template <typename> class Q>\n-void f(typename Q<int>::X) @{@}\n-@end smallexample\n-\n-@noindent\n-Instantiations of these templates may be mangled incorrectly.\n-\n-@end itemize\n-\n It also warns about psABI-related changes.  The known psABI changes at this\n point include:\n "}, {"sha": "05b898609c2dba8970e0f2523e269b766048aa9e", "filename": "gcc/testsuite/c-c++-common/abi-bf.c", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fabi-bf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fabi-bf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fabi-bf.c?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,3 +0,0 @@\n-/* { dg-warning \"incompatible\" } */\n-/* { dg-do compile } */\n-/* { dg-options \"-fstrict-volatile-bitfields -fabi-version=1\" } */"}, {"sha": "6cfda5d47df53523f1c84de1b642642c3f30ca8a", "filename": "gcc/testsuite/g++.dg/abi/bitfield12.C", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield12.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,5 +0,0 @@\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-\n-struct S { // { dg-warning \"ABI\" }\n-  char c : 1024; // { dg-warning \"width\" }\n-};"}, {"sha": "53131401434c68c574133c9c3f1d7fea19fbd349", "filename": "gcc/testsuite/g++.dg/abi/bitfield5.C", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield5.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,15 +0,0 @@\n-// { dg-do compile } \n-// { dg-options \"-Wabi -fabi-version=1\" }\n-// { dg-options \"-Wabi -fabi-version=1 -mno-ms-bitfields\" { target i?86-*-* x86_64-*-* } }\n-\n-struct A { \n-  virtual void f(); \n-  int f1 : 1; \n-};\n-\n-struct B : public A {\n-  int f2 : 1;  // { dg-warning \"ABI\" }\n-  int : 0;\n-  int f3 : 4; \n-  int f4 : 3;\n-};"}, {"sha": "b5b656ffa477b200798865c7f22cbe0f2b58edf0", "filename": "gcc/testsuite/g++.dg/abi/bitfield7.C", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fbitfield7.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,7 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-\n-union U { // { dg-warning \"ABI\" }\n-  int i: 4096; // { dg-warning \"exceeds\" }\n-};\n-"}, {"sha": "dc180453b706a766d9c3170c9ce800a05d95cd1b", "filename": "gcc/testsuite/g++.dg/abi/cookie2.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie2.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,16 +0,0 @@\n-// { dg-options \"-fabi-version=1\" }\n-\n-void *operator new[](__SIZE_TYPE__, void *);\n-\n-struct A {\n-    ~A(){}\n-};\n-\n-int main()\n-{\n-  A * a = (A*) new char[20];\n-  A  * b = new(a) A[3];\n-  // In the 3.2 ABI, a cookie was allocated in this case.\n-  if (a == b)\n-    return 1;\n-}"}, {"sha": "6b89cc8eae0582f9c87bc79cbdfdb05b6de7f61a", "filename": "gcc/testsuite/g++.dg/abi/dtor2.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fdtor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fdtor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fdtor2.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,14 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-\n-struct A {\n-  virtual void a ();\n-};\n-\n-struct B {\n-  virtual ~B ();\n-};\n-\n-struct C : public A, public B { // { dg-warning \"virtual\" }\n-  virtual void c ();\n-};"}, {"sha": "1b14a6d03bec1fc2a9d2beffc3a9783e9e81ba12", "filename": "gcc/testsuite/g++.dg/abi/empty6.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty6.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,14 +0,0 @@\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-\n-struct A {};\n-\n-struct B {\n-  A a; // { dg-warning \"empty\" \"\" { xfail mmix-*-* } }\n-  virtual void f () {}\n-} __attribute__((aligned(2 * sizeof (void *))));\n-/* The preceding attribute is necessary on targets with\n-   BIGGEST_ALIGNMENT <= POINTER_SIZE to trigger the warning, as\n-   otherwise the offset of 'a' (i.e. POINTER_SIZE) is split into a\n-   non-zero DECL_FIELD_OFFSET and a zero DECL_FIELD_BIT_OFFSET,\n-   and then there is no discrepancy between DECL_FIELD_OFFSET and\n-   byte_position to warn about.  */"}, {"sha": "871208da3ad5ec0c2e03aef925e08ac2ec6e3469", "filename": "gcc/testsuite/g++.dg/abi/macro1.C", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmacro1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmacro1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmacro1.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,5 +0,0 @@\n-// { dg-options \"-fabi-version=1\" }\n-\n-#if __GXX_ABI_VERSION != 102\n-#error \"Incorrect value of __GXX_ABI_VERSION\"\n-#endif"}, {"sha": "722d43c85a83e4e451c456bee38400aeadbafd74", "filename": "gcc/testsuite/g++.dg/abi/mangle11.C", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle11.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,10 +0,0 @@\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-\n-template <typename Q>\n-void f (typename Q::X) {} // { dg-warning \"mangle\" }\n-\n-struct S {\n-  typedef int X;\n-};\n-\n-template void f<S> (int); // { dg-message \"required\" }"}, {"sha": "92f49c22fdf308ac28450fbc2a70ebc7b506bd87", "filename": "gcc/testsuite/g++.dg/abi/mangle12.C", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle12.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,11 +0,0 @@\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-\n-template <template <typename> class Q>\n-void f (typename Q<int>::X) {} // { dg-warning \"mangle\" }\n-\n-template <typename Q>\n-struct S {\n-  typedef int X;\n-};\n-\n-template void f<S> (int);  // { dg-message \"required\" }"}, {"sha": "2b38255ac0ad4101bb4634f4c99516ba7aa9c5cb", "filename": "gcc/testsuite/g++.dg/abi/mangle14.C", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle14.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,13 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-// { dg-final { scan-assembler \"_Z1g1SIXadsr1ANS0_1fIiEEivEE\" } }\n-\n-struct A {\n-  template <typename T> int f ();\n-};\n-\n-typedef int (A::*P)();\n-\n-template <P> struct S {};\n-\n-void g (S<&A::f<int> >) {} // { dg-warning \"mangle\" }"}, {"sha": "f98e2717d847d325be201bc424aa24acf2cd00f1", "filename": "gcc/testsuite/g++.dg/abi/mangle17.C", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,11 +0,0 @@\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-\n-enum E { e = 3 };\n-\n-template <int I> struct S {};\n-\n-template <int I> void f (S<I + e + int (3.7)>) {} // { dg-warning \"mangle\" }\n-template void f<7>(S<7 + e + int (3.7)>); // { dg-message \"required\" }\n-\n-template <int I> void g (S<I + e + int (3.7)>) {} // { dg-warning \"mangle\" }\n-template void g<7>(S<7 + e + int (3.7)>); // { dg-message \"required\" }"}, {"sha": "a231d495fef7bb5475b39b198b015ced2576a66b", "filename": "gcc/testsuite/g++.dg/abi/mangle18-2.C", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle18-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle18-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle18-2.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,23 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-fabi-version=1 -Wabi\" }\n-\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n-// Contributed by Nathan Sidwell 30 Nov 2003 <nathan@codesourcery.com>\n-\n-// PR 13241\n-// mangled template arguments that are external objects incorrectly\n-\n-extern \"C\" void Foo ();\n-namespace NMS \n-{\n-  extern \"C\" int V;\n-}\n-\n-template <void (*)()> struct S {};\n-template <int *> struct T {};\n-\n-void f (S<Foo>){} // { dg-warning \"mangled name\" }\n-// { dg-final { scan-assembler \"\\n_?_Z1f1SIXadL3FooEEE\\[: \\t\\n\\]\" } }\n-\n-void g (T<&NMS::V>){}  // { dg-warning \"mangled name\" }\n-// { dg-final { scan-assembler \"\\n_?_Z1g1TIXadL_ZN3NMS1VEEEE\\[: \\t\\n\\]\" } }"}, {"sha": "f0855e69d342a8502efe9cf1142ad228d18e29f0", "filename": "gcc/testsuite/g++.dg/abi/mangle19-2.C", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle19-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle19-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle19-2.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,13 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-fabi-version=1 -Wabi\" }\n-\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n-// Contributed by Nathan Sidwell 15 Dec 2003 <nathan@codesourcery.com>\n-\n-// PR 13242\n-// mangled template arguments that are external objects incorrectly\n-\n-extern int N;\n-template <int &> struct S {};\n-void n (S<N>) {}  // { dg-warning \"mangled name\" }\n-// { dg-final { scan-assembler \"\\n_?_Z1n1SIXadL_Z1NEEE\\[: \\t\\n\\]\" } }"}, {"sha": "5ba6bac03a677854781ff6ad10deeebee05277ce", "filename": "gcc/testsuite/g++.dg/abi/mangle20-2.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,16 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-fabi-version=1 -Wabi\" }\n-\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n-// Contributed by Nathan Sidwell 15 Dec 2003 <nathan@codesourcery.com>\n-\n-// PR 9043\n-// mangled array types in templates\n-\n-template <int I> void f(int (*)[2]) {} // { dg-warning \"mangled name\" }\n-template <int I> void g(int (*)[I+2]) {}\n-\n-template void f<1>(int (*)[2]);  // { dg-message \"required\" }\n-//  { dg-final { scan-assembler \"\\n_?_Z1fILi1EEvPALi2E_i\\[: \\t\\n\\]\" } }\n-template void g<1>(int (*)[3]);\n-//  { dg-final { scan-assembler \"\\n_?_Z1gILi1EEvPAplT_Li2E_i\\[: \\t\\n\\]\" } }"}, {"sha": "b6e7f88fcaa2990a36d62310da1c72617f421dd4", "filename": "gcc/testsuite/g++.dg/abi/vbase10.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase10.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,14 +0,0 @@\n-// { dg-do compile }\n-// -fpack-struct is necessary because the code below assumes the initial\n-// packing is larger than 1, which cannot ge guaranteed for all targets.\n-// { dg-options \"-Wabi -fabi-version=1 -fpack-struct=8\" }\n-// On ARM processors, the alignment of B will be 4 even though it\n-// contains only a single \"char\".  That would avoids the situation\n-// that the warning below is designed to catch.  We therefore\n-// explicitly set the default structure alignment to 1.\n-// { dg-options \"-Wabi -fabi-version=1 -mstructure-size-boundary=8\" { target arm*-*-* } }\n-\n-struct A { virtual void f(); char c1; };\n-struct B { B(); char c2; };\n-struct C : public A, public virtual B {}; // { dg-warning \"ABI\" }\n-"}, {"sha": "320d5ba77dcb3843726e3d37069520c1d9f2d5ab", "filename": "gcc/testsuite/g++.dg/abi/vbase14.C", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase14.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,6 +0,0 @@\n-// { dg-options \"-Wabi -fabi-version=1\" }\n-\n-struct E1 {};\n-struct E2 : public E1 {}; // { dg-warning \"layout\" }\n-struct E : public E1, public E2 {}; // { dg-warning \"layout|ambiguity\" }\n-struct N : public E { virtual void f () {} };  // { dg-warning \"nearly\" }"}, {"sha": "418a2029951d78fa79b608b1dd8aecb9e781993d", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-abi1.C", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-abi1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-abi1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-abi1.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,17 +0,0 @@\n-// PR c++/47301\n-// { dg-do compile { target c++11 } }\n-// { dg-options \"-fabi-version=1\" }\n-\n-struct A\n-{\n-  constexpr operator int ()\n-  {\n-    return 1;\n-  }\n-};\n-\n-template < int > struct B\n-{\n-  static constexpr A a = A();\n-  int ar[a];\n-};"}, {"sha": "ea17e5d5f908e58f880dbd6f21b70d38c300e451", "filename": "gcc/testsuite/g++.dg/template/anonunion1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fanonunion1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fanonunion1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fanonunion1.C?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -1,6 +1,6 @@\n // PR c++/47303\n // { dg-do compile }\n-// { dg-options \"-fabi-version=1\" }\n+\n \n struct Z\n {"}, {"sha": "97fe7cde25d5eeabbb4697570c8083ddbe0abb9c", "filename": "gcc/testsuite/g++.dg/template/array1-1.C", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray1-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray1-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray1-1.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,32 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-fabi-version=1\" }\n-\n-// Contributed by Nathan Sidwell 22 Dec 2003 <nathan@codesourcery.com>\n-// Origin: Roger Sayle  <roger@eyesopen.com>\n-\n-// PR c++/12774 Array domains compared unequal\n-\n-void Foo(double r[3][3])\n-{\n-}\n-\n-void Baz()\n-{\n-   double m[3][3];\n-   Foo(m);\n-}\n-\n-template <class T>\n-void Bar()\n-{\n-   double m[3][3];\n-   Foo(m);\n-}\n-\n-int main()\n-{\n-   Baz();\n-   Bar<int>();\n-   return 0;\n-}\n-"}, {"sha": "2980a1fd186e90f636e63f4d78b4c6739c53bb8f", "filename": "gcc/testsuite/g++.dg/template/array2-1.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray2-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray2-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray2-1.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,14 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-fabi-version=1\" }\n-\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n-// Contributed by Nathan Sidwell 29 Dec 2003 <nathan@codesourcery.com>\n-\n-// PR c++/13494. ICE\n-\n-template<typename T>\n-int foo(int d[][4])\n-{\n-  return d[0][0];\n-}\n-"}, {"sha": "01d415b3edd4cdf0c7db5704285ebead44be297a", "filename": "gcc/testsuite/g++.dg/template/conv8.C", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdcb6a997e7125d155b79947a1793f01611527b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv8.C?ref=8fdcb6a997e7125d155b79947a1793f01611527b", "patch": "@@ -1,12 +0,0 @@\n-// { dg-options \"-fabi-version=1 -Wno-abi\" }\n-\n-template <typename T> struct S {\n-    struct I{};\n-    operator I* ();\n-};\n-\n-template <typename T> struct S2 : S<T> {\n-    operator typename S<T>::I* ();\n-};\n-\n-template struct S2<int>;"}, {"sha": "fea8b3df955ba70f7e746cf3e761c0ac517b7a51", "filename": "gcc/testsuite/g++.dg/template/qualttp17.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp17.C?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -1,7 +1,7 @@\n // Copyright (C) 2001 Free Software Foundation\n // Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n // { dg-do compile }\n-// { dg-options \"-fno-inline -fabi-version=1 -Wno-abi\" }\n+// { dg-options \"-fno-inline\" }\n \n struct A\n {\n@@ -22,4 +22,4 @@ int main()\n \tf<A>(x);\n }\n \n-// { dg-final { scan-assembler \"\\n_?_Z1fI1AEv1XIN1T1BEE\\[: \\t\\n\\]\" } }\n+// { dg-final { scan-assembler \"\\n_?_Z1fI1AEv1XINT_1BEE\\[: \\t\\n\\]\" } }"}, {"sha": "fcd0e43fcd9215300bc8cc5b8ee9395c9135bc24", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d8493479eebfa2df08f6462f5972887a330138/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=90d8493479eebfa2df08f6462f5972887a330138", "patch": "@@ -1290,11 +1290,11 @@ process_options (void)\n     flag_ira_region\n       = optimize_size || !optimize ? IRA_REGION_ONE : IRA_REGION_MIXED;\n \n-  if (flag_strict_volatile_bitfields > 0 && !abi_version_at_least (2))\n+  if (!abi_version_at_least (2))\n     {\n-      warning (0, \"-fstrict-volatile-bitfields disabled; \"\n-\t       \"it is incompatible with ABI versions < 2\");\n-      flag_strict_volatile_bitfields = 0;\n+      /* -fabi-version=1 support was removed after GCC 4.9.  */\n+      error (\"%<-fabi-version=1%> is no longer supported\");\n+      flag_abi_version = 2;\n     }\n \n   /* Unrolling all loops implies that standard loop unrolling must also"}]}