{"sha": "dff6b454a21d43e2cb4c29d0418053239bf85620", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZmNmI0NTRhMjFkNDNlMmNiNGMyOWQwNDE4MDUzMjM5YmY4NTYyMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:25:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:25:04Z"}, "message": "(finish_function): Clear current_class_decl.\n\n(start_function): If current_class_decl is a signature pointer, don't\ndereference it but set C_C_D to current_class_decl.\n(duplicate_decls): Complain about virtual functions redeclared to be inline.\n(get_unique_name): New routine to name unnamed namespaces.\n(push_namespace): Use get_unique_name for naming unnamed namespaces.\n(complete_array_type): Fill in the TYPE_DOMAIN of our TYPE_MAIN_VARIANT if it\nis not filled in.\n(start_function): Complain about redefinition of a function even when\nthe pending_inline version is compiled after the other version.\n(init_decl_processing): Fix number of fields for building sigtable_entry_type.\n(tag_identifier, offset_identifier): New variables to hold the identifiers for\nthe sigtable fields tag and offset.\n(init_decl_processing): Initialize these variables.\n(init_decl_processing): Use these variables to build the sigtable_entry_type\nstructure.  Rename the code and offset fields to tag and delta, respectively;\nadd offset and index fields. Changed types of fields from\nshort_integer_type_node to delta_type_node.\n(lookup_name_real): Don't try to look anything up in an\terroneous object.\n(grokdeclarator): Always give errors on constant overflow for array indices.\n\nFrom-SVN: r10036", "tree": {"sha": "33c8cc36e7c54834fe8327162177b675ec6e8f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33c8cc36e7c54834fe8327162177b675ec6e8f81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dff6b454a21d43e2cb4c29d0418053239bf85620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff6b454a21d43e2cb4c29d0418053239bf85620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff6b454a21d43e2cb4c29d0418053239bf85620", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff6b454a21d43e2cb4c29d0418053239bf85620/comments", "author": null, "committer": null, "parents": [{"sha": "0f869a71dab6afee86e7dfd8cdb273ab0a969aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f869a71dab6afee86e7dfd8cdb273ab0a969aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f869a71dab6afee86e7dfd8cdb273ab0a969aad"}], "stats": {"total": 163, "additions": 138, "deletions": 25}, "files": [{"sha": "957eebec5fabb829d119d5dd4a3c79da06b4e1e0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 138, "deletions": 25, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff6b454a21d43e2cb4c29d0418053239bf85620/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff6b454a21d43e2cb4c29d0418053239bf85620/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=dff6b454a21d43e2cb4c29d0418053239bf85620", "patch": "@@ -293,9 +293,9 @@ tree base_init_expr;\n    Identifiers for `this' in member functions and the auto-delete\n    parameter for destructors.  */\n tree this_identifier, in_charge_identifier;\n-/* Used in pointer to member functions, and in vtables. */\n+/* Used in pointer to member functions, in vtables, and in sigtables. */\n tree pfn_identifier, index_identifier, delta_identifier, delta2_identifier;\n-tree pfn_or_delta2_identifier;\n+tree pfn_or_delta2_identifier, tag_identifier, offset_identifier;\n \n /* A list (chain of TREE_LIST nodes) of named label uses.\n    The TREE_PURPOSE field is the list of variables defined\n@@ -1575,7 +1575,56 @@ print_binding_stack ()\n   print_binding_level (global_binding_level);\n }\n \n-/* Push into the scope of the NAME namespace.  */\n+extern char * first_global_object_name;\n+\n+/* Get a unique name for each call to this routine for unnamed namespaces.\n+   Mostly copied from get_file_function_name.  */\n+static tree\n+get_unique_name ()\n+{\n+  static int temp_name_counter = 0;\n+  char *buf;\n+  register char *p;\n+\n+  if (first_global_object_name)\n+    p = first_global_object_name;\n+  else if (main_input_filename)\n+    p = main_input_filename;\n+  else\n+    p = input_filename;\n+\n+#define UNNAMED_NAMESPACE_FORMAT \"__%s_%d\"\n+\n+  buf = (char *) alloca (sizeof (UNNAMED_NAMESPACE_FORMAT) + strlen (p));\n+\n+  sprintf (buf, UNNAMED_NAMESPACE_FORMAT, p, temp_name_counter++);\n+\n+  /* Don't need to pull weird characters out of global names.  */\n+  if (p != first_global_object_name)\n+    {\n+      for (p = buf+11; *p; p++)\n+\tif (! ((*p >= '0' && *p <= '9')\n+#if 0 /* we always want labels, which are valid C++ identifiers (+ `$') */\n+#ifndef ASM_IDENTIFY_GCC\t/* this is required if `.' is invalid -- k. raeburn */\n+\t       || *p == '.'\n+#endif\n+#endif\n+#ifndef NO_DOLLAR_IN_LABEL\t/* this for `$'; unlikely, but... -- kr */\n+\t       || *p == '$'\n+#endif\n+#ifndef NO_DOT_IN_LABEL\t\t/* this for `.'; unlikely, but... */\n+\t       || *p == '.'\n+#endif\n+\t       || (*p >= 'A' && *p <= 'Z')\n+\t       || (*p >= 'a' && *p <= 'z')))\n+\t  *p = '_';\n+    }\n+\n+  return get_identifier (buf);\n+}\n+\n+/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n+   select a name that is unique to this compilation unit.  */\n void\n push_namespace (name)\n      tree name;\n@@ -1585,6 +1634,12 @@ push_namespace (name)\n   char *buf;\n   tree d = make_node (NAMESPACE_DECL);\n \n+  if (! name)\n+    {\n+      /* Create a truely ugly name! */\n+      name = get_unique_name ();\n+    }\n+\n   DECL_NAME (d) = name;\n   DECL_ASSEMBLER_NAME (d) = name;\n   /* pushdecl wants to check the size of it to see if it is incomplete... */\n@@ -2547,10 +2602,23 @@ duplicate_decls (newdecl, olddecl)\n \t\t  }\n \t      }\n \n-\t  if (DECL_THIS_INLINE (newdecl) && ! DECL_THIS_INLINE (olddecl)\n-\t      && TREE_ADDRESSABLE (olddecl))\n-\t    cp_pedwarn (\"`%#D' was used before it was declared inline\",\n-\t\t\tnewdecl);\n+\t  if (DECL_THIS_INLINE (newdecl) && ! DECL_THIS_INLINE (olddecl))\n+\t    {\n+\t      if (DECL_VINDEX (olddecl) && ! DECL_ABSTRACT_VIRTUAL_P (olddecl))\n+\t\t{\n+\t\t  cp_pedwarn (\"virtual function `%#D' redeclared inline\",\n+\t\t\t      newdecl);\n+\t\t  cp_pedwarn_at (\"previous non-inline declaration here\",\n+\t\t\t\t olddecl);\n+\t\t}\n+\t      else if (TREE_ADDRESSABLE (olddecl))\n+\t\t{\n+\t\t  cp_pedwarn (\"`%#D' was used before it was declared inline\",\n+\t\t\t      newdecl);\n+\t\t  cp_pedwarn_at (\"previous non-inline declaration here\",\n+\t\t\t\t olddecl);\n+\t\t}\n+\t    }\n \t}\n       /* These bits are logically part of the type for non-functions.  */\n       else if (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n@@ -4261,7 +4329,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \n       if (got_scope)\n \ttype = got_scope;\n-      else\n+      else if (got_object != error_mark_node)\n \ttype = got_object;\n       \n       if (type)\n@@ -4671,6 +4739,11 @@ init_decl_processing ()\n   delta_identifier = get_identifier (VTABLE_DELTA_NAME);\n   delta2_identifier = get_identifier (VTABLE_DELTA2_NAME);\n   pfn_or_delta2_identifier = get_identifier (\"__pfn_or_delta2\");\n+  if (flag_handle_signatures)\n+    {\n+      tag_identifier = get_identifier (SIGTABLE_TAG_NAME);\n+      offset_identifier = get_identifier (SIGTABLE_OFFSET_NAME);\n+    }\n \n   /* Define `int' and `char' first so that dbx will output them first.  */\n \n@@ -5217,17 +5290,27 @@ init_decl_processing ()\n   if (flag_handle_signatures)\n     {\n       sigtable_entry_type = make_lang_type (RECORD_TYPE);\n-      fields[0] = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t\t get_identifier (SIGTABLE_CODE_NAME),\n-\t\t\t\t\t short_integer_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t\t get_identifier (SIGTABLE_OFFSET_NAME),\n-\t\t\t\t\t short_integer_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t\t get_identifier (SIGTABLE_PFN_NAME),\n-\t\t\t\t\t ptr_type_node);\n-      finish_builtin_type (sigtable_entry_type, SIGTABLE_PTR_TYPE, fields, 2,\n+      fields[0] = build_lang_field_decl (FIELD_DECL, tag_identifier,\n+\t\t\t\t\t delta_type_node);\n+      fields[1] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n+\t\t\t\t\t delta_type_node);\n+      fields[2] = build_lang_field_decl (FIELD_DECL, offset_identifier,\n+\t\t\t\t\t delta_type_node);\n+      fields[3] = build_lang_field_decl (FIELD_DECL, index_identifier,\n+\t\t\t\t\t delta_type_node);\n+      finish_builtin_type (sigtable_entry_type, SIGTABLE_PTR_TYPE, fields, 3,\n \t\t\t   double_type_node);\n+\n+      /* Make this part of an invisible union.  */\n+      fields[4] = copy_node (fields[2]);\n+      TREE_TYPE (fields[4]) = ptr_type_node;\n+      DECL_NAME (fields[4]) = pfn_identifier;\n+      DECL_MODE (fields[4]) = TYPE_MODE (ptr_type_node);\n+      DECL_SIZE (fields[4]) = TYPE_SIZE (ptr_type_node);\n+      TREE_UNSIGNED (fields[4]) = 0;\n+      TREE_CHAIN (fields[1]) = fields[4];\n+      TREE_CHAIN (fields[4]) = fields[2];\n+\n       sigtable_entry_type = build_type_variant (sigtable_entry_type, 1, 0);\n       record_builtin_type (RID_MAX, SIGTABLE_PTR_TYPE, sigtable_entry_type);\n     }\n@@ -6955,14 +7038,19 @@ complete_array_type (type, initial_value, do_default)\n       tree itype;\n \n       TYPE_DOMAIN (type) = build_index_type (maxindex);\n-      if (!TREE_TYPE (maxindex))\n+      if (! TREE_TYPE (maxindex))\n \tTREE_TYPE (maxindex) = TYPE_DOMAIN (type);\n       if (initial_value)\n         itype = TREE_TYPE (initial_value);\n       else\n \titype = NULL;\n       if (itype && !TYPE_DOMAIN (itype))\n \tTYPE_DOMAIN (itype) = TYPE_DOMAIN (type);\n+      /* The type of the main variant should never be used for arrays\n+\t of different sizes.  It should only ever be completed with the\n+\t size of the array.  */\n+      if (! TYPE_DOMAIN (TYPE_MAIN_VARIANT (type)))\n+\tTYPE_DOMAIN (TYPE_MAIN_VARIANT (type)) = TYPE_DOMAIN (type);\n     }\n \n   /* Lay out the type now that we can get the real answer.  */\n@@ -8477,7 +8565,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  cp_pedwarn (\"ANSI C++ forbids zero-size array `%D'\", dname);\n \t\tif (TREE_CONSTANT (size))\n \t\t  {\n+\t\t    int old_flag_pedantic_errors = flag_pedantic_errors;\n+\t\t    int old_pedantic = pedantic;\n+\t\t    pedantic = flag_pedantic_errors = 1;\n+\t\t    /* Always give overflow errors on array subscripts.  */\n \t\t    constant_expression_warning (size);\n+\t\t    pedantic = old_pedantic;\n+\t\t    flag_pedantic_errors = old_flag_pedantic_errors;\n \t\t    if (INT_CST_LT (size, integer_zero_node))\n \t\t      {\n \t\t\tcp_error (\"size of array `%D' is negative\", dname);\n@@ -11007,6 +11101,16 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t    cp_error_at (\"previous declaration here\", IDENTIFIER_GLOBAL_VALUE (DECL_NAME (decl1)));\n \t}\n \n+      /* This can happen if a template class is instantiated as part of the\n+\t specialization of a member function which is defined in the class\n+\t template.  We should just use the specialization, but for now give an\n+\t error.  */\n+      if (DECL_INITIAL (decl1) != NULL_TREE)\n+\t{\n+\t  cp_error_at (\"specialization of `%#D' not supported\", decl1);\n+\t  cp_error (\"when defined in the class template body\", decl1);\n+\t}\n+\n       last_function_parms = DECL_ARGUMENTS (decl1);\n       last_function_parm_tags = NULL_TREE;\n       fntype = TREE_TYPE (decl1);\n@@ -11206,16 +11310,24 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t     we keep the consistency between `current_class_type'\n \t     and `current_class_decl'.  */\n \t  tree t = last_function_parms;\n-\t  int i = suspend_momentary ();\n \n \t  my_friendly_assert (t != NULL_TREE\n \t\t\t      && TREE_CODE (t) == PARM_DECL, 162);\n \n-\t  /* Fool build_indirect_ref.  */\n-\t  current_class_decl = NULL_TREE;\n-\t  C_C_D = build_indirect_ref (t, NULL_PTR);\n-\t  current_class_decl = t;\n-\t  resume_momentary (i);\n+\t  if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n+\t    {\n+\t      int i = suspend_momentary ();\n+\n+\t      /* Fool build_indirect_ref.  */\n+\t      current_class_decl = NULL_TREE;\n+\t      C_C_D = build_indirect_ref (t, NULL_PTR);\n+\t      current_class_decl = t;\n+\t      resume_momentary (i);\n+\t    }\n+\t  else\n+\t    /* We're having a signature pointer here.  */\n+\t    C_C_D = current_class_decl = t;\n+\n \t}\n     }\n   else\n@@ -12022,6 +12134,7 @@ finish_function (lineno, call_poplevel, nested)\n     }\n \n   named_label_uses = NULL_TREE;\n+  current_class_decl = NULL_TREE;\n }\n \f\n /* Create the FUNCTION_DECL for a function definition."}]}