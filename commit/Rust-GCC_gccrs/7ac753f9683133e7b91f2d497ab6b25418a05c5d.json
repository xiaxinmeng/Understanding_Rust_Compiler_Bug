{"sha": "7ac753f9683133e7b91f2d497ab6b25418a05c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FjNzUzZjk2ODMxMzNlN2I5MWYyZDQ5N2FiNmIyNTQxOGEwNWM1ZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2014-11-20T22:25:35Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2014-11-20T22:25:35Z"}, "message": "Disable an unsafe VRP transformation when -fno-strict-overflow is set\n\ngcc/\n\t* tree-vrp.c (test_for_singularity): New parameter\n\tstrict_overflow_p.  Set *strict_overflow_p to true if signed\n\toverflow must be undefined for the return value to satisfy the\n\tconditional.\n\t(simplify_cond_using_ranges): Don't perform the simplification\n\tif it violates overflow rules.\n\ngcc/testsuite/\n\t* gcc.dg/no-strict-overflow-8.c: New test.\n\nFrom-SVN: r217895", "tree": {"sha": "50fdade7d7ba6205c00a1d0613c261fa0f192e1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50fdade7d7ba6205c00a1d0613c261fa0f192e1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ac753f9683133e7b91f2d497ab6b25418a05c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac753f9683133e7b91f2d497ab6b25418a05c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac753f9683133e7b91f2d497ab6b25418a05c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac753f9683133e7b91f2d497ab6b25418a05c5d/comments", "author": null, "committer": null, "parents": [{"sha": "75bda2e8134c013bc3d02b78e5b8b34022961985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75bda2e8134c013bc3d02b78e5b8b34022961985", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75bda2e8134c013bc3d02b78e5b8b34022961985"}], "stats": {"total": 95, "additions": 87, "deletions": 8}, "files": [{"sha": "4501014d340b788cfc18ed5c5b3aeadcd3fde83a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac753f9683133e7b91f2d497ab6b25418a05c5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac753f9683133e7b91f2d497ab6b25418a05c5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ac753f9683133e7b91f2d497ab6b25418a05c5d", "patch": "@@ -1,3 +1,12 @@\n+2014-11-20  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* tree-vrp.c (test_for_singularity): New parameter\n+\tstrict_overflow_p.  Set *strict_overflow_p to true if signed\n+\toverflow must be undefined for the return value to satisfy the\n+\tconditional.\n+\t(simplify_cond_using_ranges): Don't perform the simplification\n+\tif it violates overflow rules.\n+\n 2014-11-20  Marek Polacek  <polacek@redhat.com>\n \n \t* tree-ssa-loop-niter.c (maybe_lower_iteration_bound): Fix typo."}, {"sha": "882e2ac4e82a967e15ff2c3d772355ba8ed71bdb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac753f9683133e7b91f2d497ab6b25418a05c5d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac753f9683133e7b91f2d497ab6b25418a05c5d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ac753f9683133e7b91f2d497ab6b25418a05c5d", "patch": "@@ -1,3 +1,7 @@\n+2014-11-20  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* gcc.dg/no-strict-overflow-8.c: New test.\n+\n 2014-11-20  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* gcc.dg/undefined-loop-1.c: New file."}, {"sha": "11ef9358d5a80bff9c00f05242c7eb9c23af03ae", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-8.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac753f9683133e7b91f2d497ab6b25418a05c5d/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac753f9683133e7b91f2d497ab6b25418a05c5d/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-8.c?ref=7ac753f9683133e7b91f2d497ab6b25418a05c5d", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-optimized\" } */\n+\n+/* We cannot fold i > 0 because p->a - p->b can be larger than INT_MAX\n+   and thus i can wrap.  Dual of Wstrict-overflow-18.c  */\n+\n+struct c { unsigned int a; unsigned int b; };\n+extern void bar (struct c *);\n+int\n+foo (struct c *p)\n+{\n+  int i;\n+  int sum = 0;\n+\n+  for (i = 0; i < p->a - p->b; ++i)\n+    {\n+      if (i > 0)\n+\tsum += 2;\n+      bar (p);\n+    }\n+  return sum;\n+}\n+\n+/* { dg-final { scan-tree-dump \"i_.* > 0\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a75138ffc5b1774d2ca3d9899003492d48bc19f5", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac753f9683133e7b91f2d497ab6b25418a05c5d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac753f9683133e7b91f2d497ab6b25418a05c5d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=7ac753f9683133e7b91f2d497ab6b25418a05c5d", "patch": "@@ -9117,11 +9117,15 @@ simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n    a known value range VR.\n \n    If there is one and only one value which will satisfy the\n-   conditional, then return that value.  Else return NULL.  */\n+   conditional, then return that value.  Else return NULL.\n+\n+   If signed overflow must be undefined for the value to satisfy\n+   the conditional, then set *STRICT_OVERFLOW_P to true.  */\n \n static tree\n test_for_singularity (enum tree_code cond_code, tree op0,\n-\t\t      tree op1, value_range_t *vr)\n+\t\t      tree op1, value_range_t *vr,\n+\t\t      bool *strict_overflow_p)\n {\n   tree min = NULL;\n   tree max = NULL;\n@@ -9172,7 +9176,16 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n \t then there is only one value which can satisfy the condition,\n \t return that value.  */\n       if (operand_equal_p (min, max, 0) && is_gimple_min_invariant (min))\n-\treturn min;\n+\t{\n+\t  if ((cond_code == LE_EXPR || cond_code == LT_EXPR)\n+\t      && is_overflow_infinity (vr->max))\n+\t    *strict_overflow_p = true;\n+\t  if ((cond_code == GE_EXPR || cond_code == GT_EXPR)\n+\t      && is_overflow_infinity (vr->min))\n+\t    *strict_overflow_p = true;\n+\n+\t  return min;\n+\t}\n     }\n   return NULL;\n }\n@@ -9252,9 +9265,12 @@ simplify_cond_using_ranges (gcond *stmt)\n \t able to simplify this conditional. */\n       if (vr->type == VR_RANGE)\n \t{\n-\t  tree new_tree = test_for_singularity (cond_code, op0, op1, vr);\n+\t  enum warn_strict_overflow_code wc = WARN_STRICT_OVERFLOW_COMPARISON;\n+\t  bool sop = false;\n+\t  tree new_tree = test_for_singularity (cond_code, op0, op1, vr, &sop);\n \n-\t  if (new_tree)\n+\t  if (new_tree\n+\t      && (!sop || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0))))\n \t    {\n \t      if (dump_file)\n \t\t{\n@@ -9275,16 +9291,30 @@ simplify_cond_using_ranges (gcond *stmt)\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \n+\t      if (sop && issue_strict_overflow_warning (wc))\n+\t        {\n+\t          location_t location = input_location;\n+\t          if (gimple_has_location (stmt))\n+\t\t    location = gimple_location (stmt);\n+\n+\t          warning_at (location, OPT_Wstrict_overflow,\n+\t\t\t      \"assuming signed overflow does not occur when \"\n+\t\t\t      \"simplifying conditional\");\n+\t        }\n+\n \t      return true;\n \t    }\n \n \t  /* Try again after inverting the condition.  We only deal\n \t     with integral types here, so no need to worry about\n \t     issues with inverting FP comparisons.  */\n-\t  cond_code = invert_tree_comparison (cond_code, false);\n-\t  new_tree = test_for_singularity (cond_code, op0, op1, vr);\n+\t  sop = false;\n+\t  new_tree = test_for_singularity\n+\t\t       (invert_tree_comparison (cond_code, false),\n+\t\t\top0, op1, vr, &sop);\n \n-\t  if (new_tree)\n+\t  if (new_tree\n+\t      && (!sop || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0))))\n \t    {\n \t      if (dump_file)\n \t\t{\n@@ -9305,6 +9335,17 @@ simplify_cond_using_ranges (gcond *stmt)\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \n+\t      if (sop && issue_strict_overflow_warning (wc))\n+\t        {\n+\t          location_t location = input_location;\n+\t          if (gimple_has_location (stmt))\n+\t\t    location = gimple_location (stmt);\n+\n+\t          warning_at (location, OPT_Wstrict_overflow,\n+\t\t\t      \"assuming signed overflow does not occur when \"\n+\t\t\t      \"simplifying conditional\");\n+\t        }\n+\n \t      return true;\n \t    }\n \t}"}]}