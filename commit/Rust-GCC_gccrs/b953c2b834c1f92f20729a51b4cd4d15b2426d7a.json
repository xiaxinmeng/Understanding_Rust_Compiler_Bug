{"sha": "b953c2b834c1f92f20729a51b4cd4d15b2426d7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk1M2MyYjgzNGMxZjkyZjIwNzI5YTUxYjRjZDRkMTViMjQyNmQ3YQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-14T11:55:59Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-07-14T11:55:59Z"}, "message": "haifa-sched.c (schedule_insns): Remove outdated comment.\n\n\t* haifa-sched.c (schedule_insns): Remove outdated comment.\n\t(schedule_block): When computing a known value for TODO_SPEC,\n\tjust set it rather than using logical operations.\n\t(try_ready): Likewise.  Use a local variable rather than a\n\tpointer to TODO_SPEC.  Reorder an if statement to move the\n\teasy case to the then block.\n\t* sched-deps.c (dep_spec_p): New static function.\n\t(update_dep): Use it to decide whether to call\n\tchange_spec_dep_to_hard.\n\t(get_back_and_forw_lists): Use it.\n\t(sd_resolve_dep): Likewise.\n\t(init_dep): If !USE_DEPS_LIST, use zero to initialize status.\n\t(haifa_note_mem_dep): Likewise.\n\t(check_dep): Likewise.\n\t(sd_add_dep): Also clear SPECULATIVE bits if not DO_SPECULATION.\n\t(sched_free_deps): Free in two passes.\n\nFrom-SVN: r176271", "tree": {"sha": "ecad391f99e5f9afa268f24a4b9d7124c34b54ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecad391f99e5f9afa268f24a4b9d7124c34b54ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b953c2b834c1f92f20729a51b4cd4d15b2426d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b953c2b834c1f92f20729a51b4cd4d15b2426d7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b953c2b834c1f92f20729a51b4cd4d15b2426d7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b953c2b834c1f92f20729a51b4cd4d15b2426d7a/comments", "author": null, "committer": null, "parents": [{"sha": "1f098f077cf9ed048238e0a8d609034bb48f5e4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f098f077cf9ed048238e0a8d609034bb48f5e4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f098f077cf9ed048238e0a8d609034bb48f5e4c"}], "stats": {"total": 167, "additions": 89, "deletions": 78}, "files": [{"sha": "2341964fe701bfe2c321c9266ae3d7d3ee0e8226", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b953c2b834c1f92f20729a51b4cd4d15b2426d7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b953c2b834c1f92f20729a51b4cd4d15b2426d7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b953c2b834c1f92f20729a51b4cd4d15b2426d7a", "patch": "@@ -1,3 +1,22 @@\n+2011-07-14  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* haifa-sched.c (schedule_insns): Remove outdated comment.\n+\t(schedule_block): When computing a known value for TODO_SPEC,\n+\tjust set it rather than using logical operations.\n+\t(try_ready): Likewise.  Use a local variable rather than a\n+\tpointer to TODO_SPEC.  Reorder an if statement to move the\n+\teasy case to the then block.\n+\t* sched-deps.c (dep_spec_p): New static function.\n+\t(update_dep): Use it to decide whether to call\n+\tchange_spec_dep_to_hard.\n+\t(get_back_and_forw_lists): Use it.\n+\t(sd_resolve_dep): Likewise.\n+\t(init_dep): If !USE_DEPS_LIST, use zero to initialize status.\n+\t(haifa_note_mem_dep): Likewise.\n+\t(check_dep): Likewise.\n+\t(sd_add_dep): Also clear SPECULATIVE bits if not DO_SPECULATION.\n+\t(sched_free_deps): Free in two passes.\n+\n 2011-07-14  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR middle-end/49736"}, {"sha": "2bef53071cf11f12cd6207be47ede1f57615b608", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b953c2b834c1f92f20729a51b4cd4d15b2426d7a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b953c2b834c1f92f20729a51b4cd4d15b2426d7a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b953c2b834c1f92f20729a51b4cd4d15b2426d7a", "patch": "@@ -2004,18 +2004,6 @@ schedule_insn (rtx insn)\n \t}\n     }\n \n-  /* This is the place where scheduler doesn't *basically* need backward and\n-     forward dependencies for INSN anymore.  Nevertheless they are used in\n-     heuristics in rank_for_schedule (), early_queue_to_ready () and in\n-     some targets (e.g. rs6000).  Thus the earliest place where we *can*\n-     remove dependencies is after targetm.sched.finish () call in\n-     schedule_block ().  But, on the other side, the safest place to remove\n-     dependencies is when we are finishing scheduling entire region.  As we\n-     don't generate [many] dependencies during scheduling itself, we won't\n-     need memory until beginning of next region.\n-     Bottom line: Dependencies are removed for all insns in the end of\n-     scheduling the region.  */\n-\n   /* Annotate the instruction with issue information -- TImode\n      indicates that the instruction is expected not to be able\n      to issue on the same cycle as the previous insn.  A machine\n@@ -3906,7 +3894,7 @@ schedule_block (basic_block *target_bb)\n \t    /* We normally get here only if we don't want to move\n \t       insn from the split block.  */\n \t    {\n-\t      TODO_SPEC (insn) = (TODO_SPEC (insn) & ~SPECULATIVE) | HARD_DEP;\n+\t      TODO_SPEC (insn) = HARD_DEP;\n \t      goto restart_choose_ready;\n \t    }\n \n@@ -4049,7 +4037,7 @@ schedule_block (basic_block *target_bb)\n \n \t  x = ready_element (&ready, i);\n \t  QUEUE_INDEX (x) = QUEUE_NOWHERE;\n-\t  TODO_SPEC (x) = (TODO_SPEC (x) & ~SPECULATIVE) | HARD_DEP;\n+\t  TODO_SPEC (x) = HARD_DEP;\n \t}\n \n       if (q_size)\n@@ -4062,7 +4050,7 @@ schedule_block (basic_block *target_bb)\n \n \t\tx = XEXP (link, 0);\n \t\tQUEUE_INDEX (x) = QUEUE_NOWHERE;\n-\t\tTODO_SPEC (x) = (TODO_SPEC (x) & ~SPECULATIVE) | HARD_DEP;\n+\t\tTODO_SPEC (x) = HARD_DEP;\n \t      }\n \t    free_INSN_LIST_list (&insn_queue[i]);\n \t  }\n@@ -4492,33 +4480,25 @@ static int haifa_speculate_insn (rtx, ds_t, rtx *);\n int\n try_ready (rtx next)\n {\n-  ds_t old_ts, *ts;\n+  ds_t old_ts, new_ts;\n \n-  ts = &TODO_SPEC (next);\n-  old_ts = *ts;\n+  old_ts = TODO_SPEC (next);\n \n   gcc_assert (!(old_ts & ~(SPECULATIVE | HARD_DEP))\n \t      && ((old_ts & HARD_DEP)\n \t\t  || (old_ts & SPECULATIVE)));\n \n   if (sd_lists_empty_p (next, SD_LIST_BACK))\n     /* NEXT has all its dependencies resolved.  */\n-    {\n-      /* Remove HARD_DEP bit from NEXT's status.  */\n-      *ts &= ~HARD_DEP;\n-\n-      if (current_sched_info->flags & DO_SPECULATION)\n-\t/* Remove all speculative bits from NEXT's status.  */\n-\t*ts &= ~SPECULATIVE;\n-    }\n+    new_ts = 0;\n   else\n     {\n       /* One of the NEXT's dependencies has been resolved.\n \t Recalculate NEXT's status.  */\n \n-      *ts &= ~SPECULATIVE & ~HARD_DEP;\n-\n-      if (sd_lists_empty_p (next, SD_LIST_HARD_BACK))\n+      if (!sd_lists_empty_p (next, SD_LIST_HARD_BACK))\n+\tnew_ts = HARD_DEP;\n+      else\n \t/* Now we've got NEXT with speculative deps only.\n \t   1. Look at the deps to see what we have to do.\n \t   2. Check if we can do 'todo'.  */\n@@ -4527,6 +4507,8 @@ try_ready (rtx next)\n \t  dep_t dep;\n \t  bool first_p = true;\n \n+\t  new_ts = 0;\n+\n \t  FOR_EACH_DEP (next, SD_LIST_BACK, sd_it, dep)\n \t    {\n \t      ds_t ds = DEP_STATUS (dep) & SPECULATIVE;\n@@ -4539,55 +4521,53 @@ try_ready (rtx next)\n \t\t{\n \t\t  first_p = false;\n \n-\t\t  *ts = ds;\n+\t\t  new_ts = ds;\n \t\t}\n \t      else\n-\t\t*ts = ds_merge (*ts, ds);\n+\t\tnew_ts = ds_merge (new_ts, ds);\n \t    }\n \n-\t  if (ds_weak (*ts) < spec_info->data_weakness_cutoff)\n+\t  if (ds_weak (new_ts) < spec_info->data_weakness_cutoff)\n \t    /* Too few points.  */\n-\t    *ts = (*ts & ~SPECULATIVE) | HARD_DEP;\n+\t    new_ts = HARD_DEP;\n \t}\n-      else\n-\t*ts |= HARD_DEP;\n     }\n \n-  if (*ts & HARD_DEP)\n-    gcc_assert (*ts == old_ts\n+  if (new_ts & HARD_DEP)\n+    gcc_assert (new_ts == HARD_DEP && new_ts == old_ts\n \t\t&& QUEUE_INDEX (next) == QUEUE_NOWHERE);\n   else if (current_sched_info->new_ready)\n-    *ts = current_sched_info->new_ready (next, *ts);\n+    new_ts = current_sched_info->new_ready (next, new_ts);\n \n   /* * if !(old_ts & SPECULATIVE) (e.g. HARD_DEP or 0), then insn might\n      have its original pattern or changed (speculative) one.  This is due\n      to changing ebb in region scheduling.\n      * But if (old_ts & SPECULATIVE), then we are pretty sure that insn\n      has speculative pattern.\n \n-     We can't assert (!(*ts & HARD_DEP) || *ts == old_ts) here because\n+     We can't assert (!(new_ts & HARD_DEP) || new_ts == old_ts) here because\n      control-speculative NEXT could have been discarded by sched-rgn.c\n      (the same case as when discarded by can_schedule_ready_p ()).  */\n \n-  if ((*ts & SPECULATIVE)\n-      /* If (old_ts == *ts), then (old_ts & SPECULATIVE) and we don't\n+  if ((new_ts & SPECULATIVE)\n+      /* If (old_ts == new_ts), then (old_ts & SPECULATIVE) and we don't\n \t need to change anything.  */\n-      && *ts != old_ts)\n+      && new_ts != old_ts)\n     {\n       int res;\n       rtx new_pat;\n \n-      gcc_assert ((*ts & SPECULATIVE) && !(*ts & ~SPECULATIVE));\n+      gcc_assert (!(new_ts & ~SPECULATIVE));\n \n-      res = haifa_speculate_insn (next, *ts, &new_pat);\n+      res = haifa_speculate_insn (next, new_ts, &new_pat);\n \n       switch (res)\n \t{\n \tcase -1:\n \t  /* It would be nice to change DEP_STATUS of all dependences,\n-\t     which have ((DEP_STATUS & SPECULATIVE) == *ts) to HARD_DEP,\n+\t     which have ((DEP_STATUS & SPECULATIVE) == new_ts) to HARD_DEP,\n \t     so we won't reanalyze anything.  */\n-\t  *ts = (*ts & ~SPECULATIVE) | HARD_DEP;\n+\t  new_ts = HARD_DEP;\n \t  break;\n \n \tcase 0:\n@@ -4611,14 +4591,16 @@ try_ready (rtx next)\n \t}\n     }\n \n-  /* We need to restore pattern only if (*ts == 0), because otherwise it is\n-     either correct (*ts & SPECULATIVE),\n-     or we simply don't care (*ts & HARD_DEP).  */\n+  /* We need to restore pattern only if (new_ts == 0), because otherwise it is\n+     either correct (new_ts & SPECULATIVE),\n+     or we simply don't care (new_ts & HARD_DEP).  */\n \n   gcc_assert (!ORIG_PAT (next)\n \t      || !IS_SPECULATION_BRANCHY_CHECK_P (next));\n \n-  if (*ts & HARD_DEP)\n+  TODO_SPEC (next) = new_ts;\n+\n+  if (new_ts & HARD_DEP)\n     {\n       /* We can't assert (QUEUE_INDEX (next) == QUEUE_NOWHERE) here because\n \t control-speculative NEXT could have been discarded by sched-rgn.c\n@@ -4628,7 +4610,8 @@ try_ready (rtx next)\n       change_queue_index (next, QUEUE_NOWHERE);\n       return -1;\n     }\n-  else if (!(*ts & BEGIN_SPEC) && ORIG_PAT (next) && !IS_SPECULATION_CHECK_P (next))\n+  else if (!(new_ts & BEGIN_SPEC)\n+\t   && ORIG_PAT (next) && !IS_SPECULATION_CHECK_P (next))\n     /* We should change pattern of every previously speculative\n        instruction - and we determine if NEXT was speculative by using\n        ORIG_PAT field.  Except one case - speculation checks have ORIG_PAT\n@@ -4640,18 +4623,16 @@ try_ready (rtx next)\n \n   if (sched_verbose >= 2)\n     {\n-      int s = TODO_SPEC (next);\n-\n       fprintf (sched_dump, \";;\\t\\tdependencies resolved: insn %s\",\n                (*current_sched_info->print_insn) (next, 0));\n \n       if (spec_info && spec_info->dump)\n         {\n-          if (s & BEGIN_DATA)\n+          if (new_ts & BEGIN_DATA)\n             fprintf (spec_info->dump, \"; data-spec;\");\n-          if (s & BEGIN_CONTROL)\n+          if (new_ts & BEGIN_CONTROL)\n             fprintf (spec_info->dump, \"; control-spec;\");\n-          if (s & BE_IN_CONTROL)\n+          if (new_ts & BE_IN_CONTROL)\n             fprintf (spec_info->dump, \"; in-control-spec;\");\n         }\n "}, {"sha": "09523e78749e9aa31d104b6ac9a685a7fe8485b0", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b953c2b834c1f92f20729a51b4cd4d15b2426d7a/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b953c2b834c1f92f20729a51b4cd4d15b2426d7a/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b953c2b834c1f92f20729a51b4cd4d15b2426d7a", "patch": "@@ -121,7 +121,7 @@ init_dep (dep_t dep, rtx pro, rtx con, enum reg_note kind)\n   if ((current_sched_info->flags & USE_DEPS_LIST))\n     ds = dk_to_ds (kind);\n   else\n-    ds = -1;\n+    ds = 0;\n \n   init_dep_1 (dep, pro, con, kind, ds);\n }\n@@ -414,6 +414,16 @@ clear_deps_list (deps_list_t l)\n   while (1);\n }\n \n+/* Decide whether a dependency should be treated as a hard or a speculative\n+   dependency.  */\n+static bool\n+dep_spec_p (dep_t dep)\n+{\n+  if (current_sched_info->flags & DO_SPECULATION)\n+    return (DEP_STATUS (dep) & SPECULATIVE) != 0;\n+  return false;\n+}\n+\n static regset reg_pending_sets;\n static regset reg_pending_clobbers;\n static regset reg_pending_uses;\n@@ -1064,6 +1074,7 @@ update_dep (dep_t dep, dep_t new_dep,\n {\n   enum DEPS_ADJUST_RESULT res = DEP_PRESENT;\n   enum reg_note old_type = DEP_TYPE (dep);\n+  bool was_spec = dep_spec_p (dep);\n \n   /* If this is a more restrictive type of dependence than the\n      existing one, then change the existing dependence to this\n@@ -1082,20 +1093,13 @@ update_dep (dep_t dep, dep_t new_dep,\n       ds_t new_status = ds | dep_status;\n \n       if (new_status & SPECULATIVE)\n-\t/* Either existing dep or a dep we're adding or both are\n-\t   speculative.  */\n \t{\n+\t  /* Either existing dep or a dep we're adding or both are\n+\t     speculative.  */\n \t  if (!(ds & SPECULATIVE)\n \t      || !(dep_status & SPECULATIVE))\n \t    /* The new dep can't be speculative.  */\n-\t    {\n-\t      new_status &= ~SPECULATIVE;\n-\n-\t      if (dep_status & SPECULATIVE)\n-\t\t/* The old dep was speculative, but now it\n-\t\t   isn't.  */\n-\t\tchange_spec_dep_to_hard (sd_it);\n-\t    }\n+\t    new_status &= ~SPECULATIVE;\n \t  else\n \t    {\n \t      /* Both are speculative.  Merge probabilities.  */\n@@ -1120,6 +1124,10 @@ update_dep (dep_t dep, dep_t new_dep,\n \t}\n     }\n \n+  if (was_spec && !dep_spec_p (dep))\n+    /* The old dep was speculative, but now it isn't.  */\n+    change_spec_dep_to_hard (sd_it);\n+\n   if (true_dependency_cache != NULL\n       && res == DEP_CHANGED)\n     update_dependency_caches (dep, old_type);\n@@ -1220,8 +1228,7 @@ get_back_and_forw_lists (dep_t dep, bool resolved_p,\n \n   if (!resolved_p)\n     {\n-      if ((current_sched_info->flags & DO_SPECULATION)\n-\t  && (DEP_STATUS (dep) & SPECULATIVE))\n+      if (dep_spec_p (dep))\n \t*back_list_ptr = INSN_SPEC_BACK_DEPS (con);\n       else\n \t*back_list_ptr = INSN_HARD_BACK_DEPS (con);\n@@ -1248,8 +1255,8 @@ sd_add_dep (dep_t dep, bool resolved_p)\n \n   gcc_assert (INSN_P (insn) && INSN_P (elem) && insn != elem);\n \n-  if ((current_sched_info->flags & DO_SPECULATION)\n-      && !sched_insn_is_legitimate_for_speculation_p (insn, DEP_STATUS (dep)))\n+  if ((current_sched_info->flags & DO_SPECULATION) == 0\n+      || !sched_insn_is_legitimate_for_speculation_p (insn, DEP_STATUS (dep)))\n     DEP_STATUS (dep) &= ~SPECULATIVE;\n \n   copy_dep (DEP_NODE_DEP (n), dep);\n@@ -1289,8 +1296,7 @@ sd_resolve_dep (sd_iterator_def sd_it)\n   rtx pro = DEP_PRO (dep);\n   rtx con = DEP_CON (dep);\n \n-  if ((current_sched_info->flags & DO_SPECULATION)\n-      && (DEP_STATUS (dep) & SPECULATIVE))\n+  if (dep_spec_p (dep))\n     move_dep_link (DEP_NODE_BACK (node), INSN_SPEC_BACK_DEPS (con),\n \t\t   INSN_RESOLVED_BACK_DEPS (con));\n   else\n@@ -1705,7 +1711,7 @@ haifa_note_mem_dep (rtx mem, rtx pending_mem, rtx pending_insn, ds_t ds)\n     dep_def _dep, *dep = &_dep;\n \n     init_dep_1 (dep, pending_insn, cur_insn, ds_to_dt (ds),\n-                current_sched_info->flags & USE_DEPS_LIST ? ds : -1);\n+                current_sched_info->flags & USE_DEPS_LIST ? ds : 0);\n     maybe_add_or_update_dep_1 (dep, false, pending_mem, mem);\n   }\n \n@@ -3512,18 +3518,23 @@ sched_free_deps (rtx head, rtx tail, bool resolved_p)\n   rtx insn;\n   rtx next_tail = NEXT_INSN (tail);\n \n+  /* We make two passes since some insns may be scheduled before their\n+     dependencies are resolved.  */\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     if (INSN_P (insn) && INSN_LUID (insn) > 0)\n       {\n-\t/* Clear resolved back deps together with its dep_nodes.  */\n-\tdelete_dep_nodes_in_back_deps (insn, resolved_p);\n-\n \t/* Clear forward deps and leave the dep_nodes to the\n \t   corresponding back_deps list.  */\n \tif (resolved_p)\n \t  clear_deps_list (INSN_RESOLVED_FORW_DEPS (insn));\n \telse\n \t  clear_deps_list (INSN_FORW_DEPS (insn));\n+      }\n+  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) && INSN_LUID (insn) > 0)\n+      {\n+\t/* Clear resolved back deps together with its dep_nodes.  */\n+\tdelete_dep_nodes_in_back_deps (insn, resolved_p);\n \n \tsd_finish_insn (insn);\n       }\n@@ -4164,7 +4175,7 @@ check_dep (dep_t dep, bool relaxed_p)\n \n   if (!(current_sched_info->flags & USE_DEPS_LIST))\n     {\n-      gcc_assert (ds == -1);\n+      gcc_assert (ds == 0);\n       return;\n     }\n "}]}