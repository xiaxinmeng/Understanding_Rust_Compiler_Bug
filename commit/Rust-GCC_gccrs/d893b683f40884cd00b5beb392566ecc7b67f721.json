{"sha": "d893b683f40884cd00b5beb392566ecc7b67f721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg5M2I2ODNmNDA4ODRjZDAwYjViZWIzOTI1NjZlY2M3YjY3ZjcyMQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-07-19T23:36:34Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-07-19T23:36:34Z"}, "message": "PR tree-optimization/84047 - missing -Warray-bounds on an out-of-bounds index into an array\n\nPR tree-optimization/84047 - missing -Warray-bounds on an out-of-bounds index into an array\nPR tree-optimization/83776 - missing -Warray-bounds indexing past the end of a string literal\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/84047\n\tPR tree-optimization/83776\n\t* tree-vrp.c (vrp_prop::check_mem_ref): New function.\n\t(check_array_bounds): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/83776\n\tPR tree-optimization/84047\n\t* gcc.dg/Warray-bounds-29.c: New test.\n\t* gcc.dg/Warray-bounds-30.c: New test.\n\t* gcc.dg/Warray-bounds-31.c: New test.\n\t* gcc.dg/Warray-bounds-32.c: New test.\n\nFrom-SVN: r262893", "tree": {"sha": "c7d999063b4f24555814611b02dd940e42314cd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7d999063b4f24555814611b02dd940e42314cd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d893b683f40884cd00b5beb392566ecc7b67f721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d893b683f40884cd00b5beb392566ecc7b67f721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d893b683f40884cd00b5beb392566ecc7b67f721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d893b683f40884cd00b5beb392566ecc7b67f721/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a34ab135873dda54ae9d7553c35019354a516832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a34ab135873dda54ae9d7553c35019354a516832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a34ab135873dda54ae9d7553c35019354a516832"}], "stats": {"total": 1068, "additions": 1065, "deletions": 3}, "files": [{"sha": "09329f43957b2aede1914fc25d9f856c803ef7f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d893b683f40884cd00b5beb392566ecc7b67f721", "patch": "@@ -1,3 +1,10 @@\n+2018-07-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/84047\n+\tPR tree-optimization/83776\n+\t* tree-vrp.c (vrp_prop::check_mem_ref): New function.\n+\t(check_array_bounds): Call it.\n+\n 2018-07-19  Martin Sebor  <msebor@redhat.com>\n \n \t* align.h (align_flags): Use member initialization."}, {"sha": "8eccef11066b62c67d3787700f198dd8df48fa25", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d893b683f40884cd00b5beb392566ecc7b67f721", "patch": "@@ -1,3 +1,12 @@\n+2018-07-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/83776\n+\tPR tree-optimization/84047\n+\t* gcc.dg/Warray-bounds-29.c: New test.\n+\t* gcc.dg/Warray-bounds-30.c: New test.\n+\t* gcc.dg/Warray-bounds-31.c: New test.\n+\t* gcc.dg/Warray-bounds-32.c: New test.\n+\n 2018-07-19  Michael Collison  <michael.collison@arm.com>\n \t    Richard Henderson <rth@redhat.com>\n "}, {"sha": "72c5d1cecf8b94ea0e31b61102a5d77158b8f2c3", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-29.c", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-29.c?ref=d893b683f40884cd00b5beb392566ecc7b67f721", "patch": "@@ -0,0 +1,150 @@\n+/* PR tree-optimization/83776: missing -Warray-bounds indexing past the end\n+   of a string literal\n+   Test to exercise warnings for computations of otherwise in-bounds indices\n+   into strings that temporarily exceed the bounds of the string.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds=2 -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define MAX DIFF_MAX\n+#define MIN DIFF_MIN\n+\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+void sink (int, ...);\n+\n+#define T(expr)   sink (0, expr)\n+\n+void test_narrow (void)\n+{\n+  int i = SR (1, 2);\n+\n+  const char *p0 = \"12\";\n+  const char *p1 = p0 + i;    /* points at '2' or beyond */\n+  const char *p2 = p1 + i;    /* points at '\\0' or beyond */\n+  const char *p3 = p2 + i;    /* points just past the end */\n+  const char *p4 = p3 + i;    /* invalid */\n+\n+  T (p0[-1]);                 /* { dg-warning \"array subscript \\(-1|\\[0-9\\]+) is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p0[0]);\n+  T (p0[1]);\n+  T (p0[2]);\n+  T (p0[3]);                  /* { dg-warning \"array subscript 3 is outside array bounds of .char\\\\\\[3].\" } */\n+\n+  T (&p0[-1]);                /* { dg-warning \"array subscript \\(-1|\\[0-9\\]+) is \\(above|below|outside\\) array bounds of .char\\\\\\[3].\" } */\n+  T (&p0[0]);\n+  T (&p0[1]);\n+  T (&p0[2]);\n+  T (&p0[3]);\n+  T (&p0[4]);                 /* { dg-warning \"array subscript 4 is \\(above|outside\\) array bounds of .char\\\\\\[3].\" } */\n+\n+  T (p1[-3]);                 /* { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p1[-2]);\n+  T (p1[-1]);\n+  T (p1[ 0]);\n+  T (p1[ 1]);\n+  T (p1[ 2]);                 /* { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p1[ 3]);                 /* { dg-warning \"array subscript \\\\\\[4, 5] is outside array bounds of .char\\\\\\[3].\" } */\n+\n+  T (&p1[-3]);                /* { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of .char\\\\\\[3].\" \"bug\" { xfail *-*-* } } */\n+  T (&p1[-2]);\n+  T (&p1[-1]);\n+  T (&p1[ 0]);\n+  T (&p1[ 1]);\n+  T (&p1[ 2]);\n+  T (&p1[ 3]);                /* { dg-warning \"array subscript \\\\\\[4, 6] is outside array bounds of .char\\\\\\[3].\" \"bug\" { xfail *-*-* } } */\n+\n+  T (p2[-4]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p2[-3]);\n+  T (p2[-2]);\n+  T (p2[-1]);\n+  T (p2[ 0]);\n+\n+  /* Even though the lower bound of p3's offsets is in bounds, in order\n+     to subtract 4 from p3 and get a dereferenceable pointer its value\n+     would have to be out-of-bounds.  */\n+  T (p3[-4]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p3[-3]);\n+  T (p3[-2]);\n+  T (p3[-1]);\n+  T (p3[ 0]);                 /* { dg-warning \"array subscript \\\\\\[3, 6] is outside array bounds of .char\\\\\\[3].\" } */\n+\n+  T (p4[-4]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p4[-3]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p4[-2]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n+\n+  /* The final subscripts below are invalid.  */\n+  T (p4[-1]);                 /* { dg-warning \"array subscript \\\\\\[3, 7] is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p4[ 0]);                 /* { dg-warning \"array subscript \\\\\\[4, 8] is outside array bounds of .char\\\\\\[3].\" } */\n+}\n+\n+\n+void test_narrow_vflow (void)\n+{\n+  int i = SR (DIFF_MAX - 2, DIFF_MAX);\n+  int j = SR (1, DIFF_MAX);\n+\n+  const char *p0 = \"123\";\n+  const char *p1 = p0 + i;    /* points at '2' or beyond */\n+  const char *p2 = p1 + i;    /* points at '\\0' or beyond */\n+  const char *p3 = p2 + i;    /* points just past the end */\n+  const char *p4 = p3 + i;    /* invalid */\n+}\n+\n+\n+void test_wide (void)\n+{\n+  int i = SR (1, 2);\n+\n+  const wchar_t *p0 = L\"123\";\n+  const wchar_t *p1 = p0 + i;    /* points at L'2' or beyond */\n+  const wchar_t *p2 = p1 + i;    /* points at L'3' or beyond */\n+  const wchar_t *p3 = p2 + i;    /* points at L'\\0' or beyond */\n+  const wchar_t *p4 = p3 + i;    /* points just past the end */\n+  const wchar_t *p5 = p4 + i;    /* invalid */\n+\n+  T (p0[0]);\n+  T (p0[1]);\n+  T (p0[2]);\n+  T (p0[3]);\n+  T (p0[4]);                  /* { dg-warning \"array subscript 4 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+\n+  T (p1[-1]);\n+  T (p1[ 0]);\n+  T (p1[ 1]);\n+  T (p1[ 2]);\n+  T (p1[ 3]);                  /* { dg-warning \"array subscript \\\\\\[4, 5] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+\n+  T (&p1[-1]);\n+  T (&p1[ 0]);\n+  T (&p1[ 1]);\n+  T (&p1[ 2]);\n+  T (&p1[ 3]);\n+  T (&p1[ 4]);                 /* { dg-warning \"array subscript \\\\\\[5, 6] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" \"bug\" { xfail *-*-* } } */\n+\n+  T (p2[-5]);                 /* { dg-warning \"array subscript \\\\\\[-3, -1] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  T (p2[-4]);\n+  T (p2[-3]);\n+  T (p2[-2]);\n+  T (p2[-1]);\n+  T (p2[ 0]);\n+\n+  /* Even though the lower bound of p3's offsets is in bounds, in order\n+     to subtract 5 from p3 and get a dereferenceable pointer its value\n+     would have to be out-of-bounds.  */\n+  T (p3[-5]);                 /* { dg-warning \"intermediate array offset 5 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  T (p3[-4]);\n+  T (p3[-3]);\n+  T (p3[-2]);\n+  T (p3[-1]);\n+  T (p3[ 0]);\n+  T (p3[ 1]);                 /* { dg-warning \"array subscript \\\\\\[4, 7] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+\n+  T (p4[-5]);                 /* { dg-warning \"intermediate array offset 5 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  T (p4[-4]);\n+  T (p4[-3]);\n+  T (p4[-2]);\n+  T (p4[-1]);\n+  T (p4[ 0]);                 /* { dg-warning \"array subscript \\\\\\[4, 8] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+}"}, {"sha": "ac7e9a6e8fbe6aff977c38f84f1a173e5cd41b36", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-30.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c?ref=d893b683f40884cd00b5beb392566ecc7b67f721", "patch": "@@ -0,0 +1,200 @@\n+/* PR tree-optimization/84047 - missing -Warray-bounds on an out-of-bounds\n+   index into an array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds=2 -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define MAX DIFF_MAX\n+#define MIN DIFF_MIN\n+\n+void sink (int, ...);\n+\n+#define T(...)   sink (0, __VA_ARGS__)\n+\n+void test_global_char_array (void)\n+{\n+  extern char gcar1[1];\n+  char *p = gcar1;\n+\n+  T (p[MIN]);       /* { dg-warning \"subscript -\\[0-9\\]+ is outside array bounds of .char\\\\\\[1].\" } */\n+  T (p[-1]);        /* { dg-warning \"subscript -1 is outside array bounds of .char\\\\\\[1].\" } */\n+  T (p[0]);\n+  T (p[1]);         /* { dg-warning \"subscript 1 is outside array bounds of .char\\\\\\[1].\" } */\n+  T (p[MAX]);       /* { dg-warning \"subscript \\[0-9\\]+ is outside array bounds of .char\\\\\\[1].\" } */\n+\n+  T (&p[MIN]);      /* { dg-warning \"subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .char\\\\\\[1].\" } */\n+  T (&p[-1]);       /* { dg-warning \"subscript -1 is \\(below|outside\\) array bounds of .char\\\\\\[1].\" } */\n+  T (&p[0]);\n+  T (&p[1]);\n+  T (&p[2]);        /* { dg-warning \"subscript 2 is \\(above|outside\\) array bounds of .char\\\\\\[1].\" } */\n+  T (&p[MAX]);      /* { dg-warning \"subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .char\\\\\\[1].\" } */\n+\n+  extern char gcar3[3];\n+  char *q = gcar3;\n+\n+  T (q[MIN]);       /* { dg-warning \"subscript -\\[0-9\\]+ is outside array bounds of .char\\\\\\[3].\" } */\n+  T (q[-1]);        /* { dg-warning \"subscript -1 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (q[0]);\n+  T (q[1]);\n+  T (q[2]);\n+  T (q[3]);         /* { dg-warning \"subscript 3 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (q[MAX]);       /* { dg-warning \"subscript \\[0-9\\]+ is outside array bounds of .char\\\\\\[3].\" } */\n+\n+  T (&q[MIN]);      /* { dg-warning \"subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .char\\\\\\[3].\" } */\n+  T (&q[-1]);       /* { dg-warning \"subscript -1 is \\(below|outside\\) array bounds of .char\\\\\\[3].\" } */\n+  T (&q[0]);\n+  T (&q[1]);\n+  T (&q[2]);\n+  T (&q[3]);\n+  T (&q[4]);        /* { dg-warning \"subscript 4 is \\(above|outside\\) array bounds of .char\\\\\\[3].\" } */\n+  T (&q[MAX]);      /* { dg-warning \"subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .char\\\\\\[3].\" } */\n+}\n+\n+\n+void test_global_int_array (void)\n+{\n+  /* Use smaller values to prevent false negatives due to undetected\n+     integer overflow/wrapping.  */\n+  ptrdiff_t min = MIN / sizeof (int);\n+  ptrdiff_t max = MAX / sizeof (int);\n+\n+  extern int giar1[1];\n+  extern int giar3[3];\n+\n+  int *p = giar1;\n+\n+  T (p[min]);       /* { dg-warning \"subscript -\\[0-9\\]+ is outside array bounds of .int\\\\\\[1].\" } */\n+  T (p[-1]);        /* { dg-warning \"subscript -1 is outside array bounds of .int\\\\\\[1].\" } */\n+  T (p[0]);\n+  T (p[1]);         /* { dg-warning \"subscript 1 is outside array bounds of .int\\\\\\[1].\" } */\n+  T (p[max]);       /* { dg-warning \"subscript \\[0-9\\]+ is outside array bounds of .int\\\\\\[1].\" } */\n+\n+  T (&p[min]);      /* { dg-warning \"subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .int\\\\\\[1].\" } */\n+  T (&p[-1]);       /* { dg-warning \"subscript -1 is \\(below|outside\\) array bounds of .int\\\\\\[1].\" } */\n+  T (&p[0]);\n+  T (&p[1]);\n+  T (&p[2]);        /* { dg-warning \"subscript 2 is \\(above|outside\\) array bounds of .int\\\\\\[1].\" } */\n+  T (&p[max]);      /* { dg-warning \"subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .int\\\\\\[1].\" } */\n+\n+  int *q = giar3;\n+\n+  T (q[min]);       /* { dg-warning \"subscript -\\[0-9\\]+ is outside array bounds of .int\\\\\\[3].\" } */\n+  T (q[-1]);        /* { dg-warning \"subscript -1 is outside array bounds of .int\\\\\\[3].\" } */\n+  T (q[0]);\n+  T (q[1]);\n+  T (q[2]);\n+  T (q[3]);         /* { dg-warning \"subscript 3 is outside array bounds of .int\\\\\\[3].\" } */\n+  T (q[max]);       /* { dg-warning \"subscript \\[0-9\\]+ is outside array bounds of .int\\\\\\[3].\" } */\n+\n+  T (&q[min]);      /* { dg-warning \"subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .int\\\\\\[3].\" } */\n+  T (&q[-1]);       /* { dg-warning \"subscript -1 is \\(below|outside\\) array bounds of .int\\\\\\[3].\" } */\n+  T (&q[0]);\n+  T (&q[1]);\n+  T (&q[2]);\n+  T (&q[3]);\n+  T (&q[4]);        /* { dg-warning \"subscript 4 is \\(above|outside\\) array bounds of .int\\\\\\[3].\" } */\n+  T (&q[max]);      /* { dg-warning \"subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .int\\\\\\[3].\" } */\n+}\n+\n+\n+void test_global_short_2dim_array (void)\n+{\n+  extern short giar3_5[3][5];\n+\n+  short *p = giar3_5[0];\n+\n+  /* The access below isn't diagnosed because the reference is transformed\n+     into MEM_REF (short*, &giar3_5, 0), i.e., *giar3_5[0][0].  */\n+  T (p[MIN]);       /* { dg-warning \"subscript -\\[0-9\\]+ is outside array bounds of .short int\\\\\\[3]\" \"bug\" { xfail *-*-*} } */\n+  T (p[-1]);        /* { dg-warning \"subscript -1 is outside array bounds of .short int\\\\\\[3]\" } */\n+  T (p[0]);\n+  T (p[1]);\n+  T (p[2]);\n+  T (p[15]);        /* { dg-warning \"subscript 15 is outside array bounds of .short int\\\\\\[3]\" } */\n+  T (p[MAX]);       /* { dg-warning \"subscript -?\\[0-9\\]+ is outside array bounds of .short int\\\\\\[3]\" } */\n+\n+  T (&p[MIN]);      /* { dg-warning \"subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .short int\\\\\\[3]\" \"bug\" { xfail *-*-* } } */\n+  T (&p[-1]);       /* { dg-warning \"subscript -1 is \\(below|outside\\) array bounds of .short int\\\\\\[3]\" } */\n+  T (&p[0]);\n+  T (&p[1]);\n+  T (&p[2]);\n+  T (&p[3]);\n+  T (&p[16]);       /* { dg-warning \"subscript 16 is \\(above|outside\\) array bounds of .short int\\\\\\[3]\" } */\n+  T (&p[MAX]);      /* { dg-warning \"subscript -?\\[0-9\\]+ is \\(above|outside\\) array bounds of .short int\\\\\\[3]\" } */\n+}\n+\n+\n+void test_local_char_array (void)\n+{\n+  char ar1[1] = { 1 };\n+  char *p = ar1;\n+\n+  T (p[MIN]);      /* { dg-warning \"subscript -\\[0-9\\]+ is outside array bounds of .char\\\\\\[1].\" } */\n+  T (p[-1]);       /* { dg-warning \"subscript -1 is outside array bounds of .char\\\\\\[1].\" } */\n+  T (p[0]);\n+  T (p[1]);         /* { dg-warning \"subscript 1 is outside array bounds of .char\\\\\\[1].\" } */\n+  T (p[MAX]);       /* { dg-warning \"subscript \\[0-9\\]+ is outside array bounds of .char\\\\\\[1].\" } */\n+\n+  T (&p[MIN]);     /* { dg-warning \"subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .char\\\\\\[1].\" } */\n+  T (&p[-1]);      /* { dg-warning \"subscript -1 is \\(below|outside\\) array bounds of .char\\\\\\[1].\" } */\n+  T (&p[0]);\n+  T (&p[1]);\n+  T (&p[2]);        /* { dg-warning \"subscript 2 is \\(above|outside\\) array bounds of .char\\\\\\[1].\" } */\n+  T (&p[MAX]);      /* { dg-warning \"subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .char\\\\\\[1].\" } */\n+\n+  char ar3[3] = { 1, 2, 3 };\n+  p = ar3;\n+\n+  T (p[MIN]);       /* { dg-warning \"subscript -\\[0-9\\]+ is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p[-1]);        /* { dg-warning \"subscript -1 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p[0]);\n+  T (p[1]);\n+  T (p[2]);\n+  T (p[3]);         /* { dg-warning \"subscript 3 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p[MAX]);       /* { dg-warning \"subscript \\[0-9\\]+ is outside array bounds of .char\\\\\\[3].\" } */\n+\n+  T (&p[MIN]);      /* { dg-warning \"subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .char\\\\\\[3].\" } */\n+  T (&p[-1]);       /* { dg-warning \"subscript -1 is \\(below|outside\\) array bounds of .char\\\\\\[3].\" } */\n+  T (&p[0]);\n+  T (&p[1]);\n+  T (&p[2]);\n+  T (&p[3]);\n+  T (&p[4]);        /* { dg-warning \"subscript 4 is \\(above|outside\\) array bounds of .char\\\\\\[3].\" } */\n+  T (&p[MAX]);      /* { dg-warning \"subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .char\\\\\\[3].\" } */\n+}\n+\n+struct S\n+{\n+  int a[2], b[3];\n+} s [4];\n+\n+void test_struct_array_cst (void)\n+{\n+  T (s[0].a[0] + s[0].a[1] + s[0].b[0] + s[0].b[1] + s[0].b[2] + s[0].b[2]\n+     + s[1].a[0] + s[1].a[1] + s[1].b[0] + s[1].b[1] + s[1].b[2] + s[1].b[2]\n+     + s[2].a[0] + s[2].a[1] + s[2].b[0] + s[2].b[1] + s[2].b[2] + s[2].b[2]\n+     + s[3].a[0] + s[3].a[1] + s[3].b[0] + s[3].b[1] + s[3].b[2] + s[3].b[2]);\n+\n+  T (&s[0].a[2],\n+     &s[0].b[3],\n+     &s[1].a[2],\n+     &s[1].b[3],\n+     &s[2].a[2],\n+     &s[2].b[3],\n+     &s[3].a[2],\n+     &s[3].b[3]);\n+\n+  T (s[0].a[2]);    /* { dg-warning \"subscript 2 is above array bounds of .int\\\\\\[2\\\\\\].\" } */\n+  T (s[0].b[3]);    /* { dg-warning \"subscript 3 is above array bounds of .int\\\\\\[3\\\\\\].\" } */\n+  T (s[1].a[2]);    /* { dg-warning \"subscript 2 is above array bounds of .int\\\\\\[2\\\\\\].\" } */\n+  T (s[1].b[3]);    /* { dg-warning \"subscript 3 is above array bounds of .int\\\\\\[3\\\\\\].\" } */\n+  T (s[2].a[2]);    /* { dg-warning \"subscript 2 is above array bounds of .int\\\\\\[2\\\\\\].\" } */\n+  T (s[2].b[3]);    /* { dg-warning \"subscript 3 is above array bounds of .int\\\\\\[3\\\\\\].\" } */\n+  T (s[3].a[2]);    /* { dg-warning \"subscript 2 is above array bounds of .int\\\\\\[2\\\\\\].\" } */\n+  T (s[3].b[3]);    /* { dg-warning \"subscript 3 is above array bounds of .int\\\\\\[3\\\\\\].\" } */\n+\n+  T (s[4].a[0]);    /* { dg-warning \"subscript 4 is above array bounds of .struct S\\\\\\[4\\\\\\].\" } */\n+  T (s[4].a[2]);    /* { dg-warning \"subscript 4 is above array bounds of .struct S\\\\\\[4\\\\\\].\" } */\n+                    /* { dg-warning \"subscript 2 is above array bounds of .int\\\\\\[2\\\\\\].\" \"\" { target *-*-* } .-1 } */\n+}"}, {"sha": "e0be1e598edc4b80dc89d5d210aa50ee32d77c49", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-31.c", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-31.c?ref=d893b683f40884cd00b5beb392566ecc7b67f721", "patch": "@@ -0,0 +1,248 @@\n+/* PR tree-optimization/83776: missing -Warray-bounds indexing past the end\n+   of a string literal\n+   Test to exercise detection of out-of-bounds indices into narrow string\n+   literals.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define MAX DIFF_MAX\n+#define MIN DIFF_MIN\n+\n+#define S1 \"1\"\n+#define S3 \"123\"\n+#define S7 \"1234567\"\n+#define S8 \"12345678\"\n+#define S9 \"123456789\"\n+\n+void sink (int, ...);\n+\n+#define T(expr)   sink (0, expr)\n+\n+\n+void narrow_direct_cst (void)\n+{\n+  T (S1[MIN]);                /* { dg-warning \"array subscript -\\[0-9\\]+ is below array bounds of .char\\\\\\[2]\" \"\" { xfail *-*-* } } */\n+  T (S1[-1]);                 /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[2]\" } */\n+  T (S1[0]);\n+  T (S1[1]);\n+  T (S1[2]);                  /* { dg-warning \"array subscript 2 is above array bounds of .char\\\\\\[2]\" } */\n+  T (S1[MAX]);                /* { dg-warning \"array subscript \\[0-9\\]+ is above array bounds of .char\\\\\\[2]\" } */\n+\n+  T (&S1[MIN]);               /* { dg-warning \"array subscript -\\[0-9\\]+ is below array bounds of .char\\\\\\[2]\" } */\n+  T (&S1[-1]);                /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[2]\" } */\n+  T (&S1[0]);\n+  T (&S1[2]);\n+  T (&S1[3]);                 /* { dg-warning \"array subscript 3 is above array bounds of .char\\\\\\[2]\" } */\n+  T (&S1[MAX]);               /* { dg-warning \"array subscript \\[0-9\\]+ is above array bounds of .char\\\\\\[2]\" } */\n+\n+  T (S9[MIN]);                /* { dg-warning \"array subscript -\\[0-9\\]+ is below array bounds of .char\\\\\\[10]\" \"\" { xfail *-*-* } } */\n+  T (S9[-1]);                 /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[10]\" } */\n+  T (S9[9]);\n+  T (S9[10]);                 /* { dg-warning \"array subscript 10 is above array bounds of .char\\\\\\[10]\" } */\n+  T (S9[11]);                 /* { dg-warning \"array subscript 11 is above array bounds of .char\\\\\\[10]\" } */\n+  T (S9[MAX]);                /* { dg-warning \"array subscript \\[0-9\\]+ is above array bounds of .char\\\\\\[10]\" } */\n+\n+  T (&S9[MIN]);               /* { dg-warning \"array subscript -\\[0-9\\]+ is below array bounds of .char\\\\\\[10]\" } */\n+  T (&S9[-1]);                /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[10]\" } */\n+  T (&S9[9]);\n+  T (&S9[10]);\n+  T (&S9[11]);                 /* { dg-warning \"array subscript 11 is above array bounds of .char\\\\\\[10]\" } */\n+  T (&S9[MAX]);               /* { dg-warning \"array subscript \\[0-9\\]+ is above array bounds of .char\\\\\\[10]\" } */\n+}\n+\n+void narrow_ptr_deref_cst (void)\n+{\n+  const char *p = S8 + 9;\n+\n+  T (*(p + MIN));             /* { dg-warning \"array subscript -\\[0-9\\]+ is outside array bounds of .char\\\\\\[9].\" } */\n+  T (*(p - 10));              /* { dg-warning \"array subscript -1 is outside array bounds of .char\\\\\\[9].\" } */\n+  T (*(p - 9));\n+  T (*(p - 1));\n+  T (*p);                     /* { dg-warning \"array subscript 9 is outside array bounds of .char\\\\\\[9].\" } */\n+  T (*(p + 1));               /* { dg-warning \"array subscript 10 is outside array bounds of .char\\\\\\[9].\" } */\n+  T (*(p + 2));               /* { dg-warning \"array subscript 11 is outside array bounds of .char\\\\\\[9].\" } */\n+}\n+\n+void narrow_ptr_index_cst (void)\n+{\n+  const char *p = S7;\n+\n+  T (p[MIN + 1]);             /* { dg-warning \"array subscript -\\[0-9\\]+ is outside array bounds of .char\\\\\\[8].\" \"bug 84047\" { xfail *-*-* } } */\n+  T (p[-1]);                  /* { dg-warning \"array subscript -1 is outside array bounds of .char\\\\\\[8].\" } */\n+  T (p[0]);\n+  T (p[1]);\n+  T (p[8]);                   /* { dg-warning \"array subscript 8 is outside array bounds of .char\\\\\\[8].\" } */\n+  T (p[99]);                  /* { dg-warning \"array subscript 99 is outside array bounds of .char\\\\\\[8].\" } */\n+  T (p[MAX]);                 /* { dg-warning \"array subscript \\[0-9\\]+ is outside array bounds of .char\\\\\\[8].\" } */\n+\n+  T (&p[MIN + 1]);            /* { dg-warning \"array subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .char\\\\\\[8].\" } */\n+  T (&p[-1]);                 /* { dg-warning \"array subscript -1 is \\(below|outside\\) array bounds of .char\\\\\\[8].\" } */\n+  T (&p[0]);\n+  T (&p[1]);\n+  T (&p[8]);\n+  T (&p[9]);                  /* { dg-warning \"array subscript 9 is \\(above|outside\\) array bounds of .char\\\\\\[8].\" } */\n+  T (&p[99]);                 /* { dg-warning \"array subscript 99 is \\(above|outside\\) array bounds of .char\\\\\\[8].\" } */\n+  T (&p[MAX]);                /* { dg-warning \"array subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .char\\\\\\[8].\" } */\n+\n+  const char *q = S8 + 4;\n+  T (q[MIN + 1]);             /* { dg-warning \"array subscript -?\\[0-9\\]+ is outside array bounds of .char\\\\\\[9].\" \"bug 84047\" { xfail *-*-* } } */\n+  T (q[-5]);                  /* { dg-warning \"array subscript -1 is outside array bounds of .char\\\\\\[9].\" } */\n+  T (q[-4]);\n+  T (q[0]);\n+  T (q[1]);\n+  T (q[3]);\n+  T (q[4]);\n+  T (q[5]);                   /* { dg-warning \"array subscript 9 is outside array bounds of .char\\\\\\[9].\" } */\n+  T (q[99]);                  /* { dg-warning \"array subscript 103 is outside array bounds of .char\\\\\\[9].\" } */\n+  T (q[MAX - 4]);             /* { dg-warning \"array subscript \\[0-9\\]+ is outside array bounds of .char\\\\\\[9].\" } */\n+  T (q[MAX - 3]);             /* { dg-warning \"array subscript \\[0-9\\]+ is outside array bounds of .char\\\\\\[9].\" \"bug 84047\" { xfail *-*-* } } */\n+\n+  T (&q[MIN + 1]);            /* { dg-warning \"array subscript -?\\[0-9\\]+ is \\(below|outside\\) array bounds of .char\\\\\\[9].\" } */\n+  T (&q[-5]);                 /* { dg-warning \"array subscript -1 is \\(below|outside\\) array bounds of .char\\\\\\[9].\" } */\n+  T (&q[-4]);\n+  T (&q[0]);\n+  T (&q[1]);\n+  T (&q[5]);\n+  T (&q[6]);                  /* { dg-warning \"array subscript 10 is \\(above|outside\\) array bounds of .char\\\\\\[9].\" } */\n+  T (&q[99]);                 /* { dg-warning \"array subscript 103 is \\(above|outside\\) array bounds of .char\\\\\\[9].\" } */\n+  T (&q[MAX - 4]);            /* { dg-warning \"array subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .char\\\\\\[9].\" } */\n+  T (&q[MAX - 3]);            /* { dg-warning \"array subscript -?\\[0-9\\]+ is \\(below|outside\\) array bounds of .char\\\\\\[9].\" } */\n+}\n+\n+\n+void narrow_direct_range (ptrdiff_t i, size_t j)\n+{\n+  T (S3[i]);\n+  T (S9[j]);\n+\n+  T (S3[SR (MIN, -1)]);       /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[4]\" } */\n+  T (S3[SR (MIN, 0)]);\n+  T (S3[SR (-2, -1)]);        /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[4]\" } */\n+  T (S3[SR (1, 2)]);\n+  T (S3[SR (1, 999)]);\n+  T (S3[SR (2, 999)]);\n+  T (S3[SR (3, 999)]);\n+  T (S3[SR (4, 999)]);       /* { dg-warning \"array subscript 4 is above array bounds of .char\\\\\\[4]\" } */\n+\n+  T (&S3[SR (MIN, -1)]);      /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[4]\" } */\n+  T (&S3[SR (MIN, 0)]);\n+  T (&S3[SR (-2, -1)]);       /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[4]\" } */\n+  T (&S3[SR (1, 2)]);\n+  T (&S3[SR (1, 999)]);\n+  T (&S3[SR (2, 999)]);\n+  T (&S3[SR (4, 999)]);\n+  T (&S3[SR (5, 999)]);      /* { dg-warning \"array subscript 5 is above array bounds of .char\\\\\\[4]\" } */\n+\n+  T (S9[SR (MIN, -9)]);       /* { dg-warning \"array subscript -9 is below array bounds of .char\\\\\\[10]\" } */\n+  T (S9[SR (MIN, -1)]);       /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[10]\" } */\n+  T (S9[SR (MIN, 0)]);\n+  T (S9[SR (-2, -1)]);        /* { dg-warning \"array subscript -1 is below array bounds of .char\\\\\\[10]\" } */\n+  T (S9[SR (1, 2)]);\n+  T (S9[SR (1, 9)]);\n+  T (S9[SR (1, 999)]);\n+  T (S9[SR (9, 999)]);\n+  T (S9[SR (10, 999)]);       /* { dg-warning \"array subscript 10 is above array bounds of .char\\\\\\[10]\" } */\n+  T (S9[SR (99, MAX)]);       /* { dg-warning \"array subscript 99 is above array bounds of .char\\\\\\[10]\" } */\n+}\n+\n+\n+void narrow_ptr_deref_range (ptrdiff_t i, size_t j)\n+{\n+  const char *p;\n+\n+  p = S1 + i;\n+  T (*p);\n+\n+  p = S1 + j;\n+  T (*p);\n+\n+  p = S1 + SR (-999, 999);\n+  T (*p);\n+\n+  p = S1 + SR (-1, 1);\n+  T (*p);\n+\n+  p = S1 + SR (-1, 0);\n+  T (*p);\n+\n+  p = S1 + SR (0, 1);\n+  T (*p);\n+\n+  p = S1 + SR (1, 2);\n+  T (*p);\n+\n+  p = S1 + SR (2, 3);\n+  T (*p);                     /* { dg-warning \"array subscript \\\\\\[2, 3] is outside array bounds of .char\\\\\\[2].\" } */\n+\n+  p = S1 + SR (9, 99);\n+  T (*p);                     /* { dg-warning \"array subscript \\\\\\[9, 99] is outside array bounds of .char\\\\\\[2].\" } */\n+\n+  p = S8 + SR (-999, 999);\n+  T (*p);\n+\n+  p = S8 + SR (-9, -1);\n+  T (*p);                     /* { dg-warning \"array subscript \\\\\\[-9, -1] is outside array bounds of .char\\\\\\[9].\" } */\n+\n+  p = S8 + SR (-9, 0);\n+  T (*p);\n+\n+  p = S8 + SR (-9, 9);\n+  T (*p);\n+\n+  p = S8 + SR (-9, 123);\n+  T (*p);\n+\n+  p = S8 + SR (8, 123);\n+  T (*p);\n+\n+  p = S8 + SR (9, 123);\n+  T (*p);                     /* { dg-warning \"array subscript \\\\\\[9, 123] is outside array bounds of .char\\\\\\[9].\" } */\n+\n+  {\n+    const char *p1 = S3 + i;\n+    const char *p2 = p1 + i;\n+    const char *p3 = p2 + i;\n+    const char *p4 = p3 + i;\n+    const char *p5 = p4 + i;\n+\n+    T (*p1);\n+    T (*p2);\n+    T (*p3);\n+    T (*p4);\n+    T (*p5);\n+  }\n+\n+  {\n+    i = SR (1, 2);\n+\n+    const char *p1 = S3 +  SR (1, DIFF_MAX - 1);\n+    const char *p2 = p1 + i;\n+    const char *p3 = p2 + i;\n+    const char *p4 = p3 + i;\n+    const char *p5 = p4 + i;\n+\n+    T (*p1);\n+    T (*p2);\n+    T (*p3);\n+    T (*p4);                  /* { dg-warning \"array subscript \\\\\\[4, \\[0-9\\]+] is outside array bounds of .char\\\\\\[4].\" } */\n+    T (*p5);                  /* { dg-warning \"array subscript \\\\\\[5, \\[0-9\\]+] is outside array bounds of .char\\\\\\[4].\" } */\n+  }\n+}\n+\n+\n+void narrow_ptr_index_range (void)\n+{\n+  const char *p;\n+\n+  p = S7;\n+  T (p[SR (-9, -1)]);         /* { dg-warning \"array subscript \\\\\\[-9, -1] is outside array bounds of .char\\\\\\[8].\" } */\n+  T (p[SR (-8, 0)]);\n+  T (p[SR (0, MAX)]);\n+  T (p[SR (1, 9)]);\n+  T (p[SR (8, 9)]);           /* { dg-warning \"array subscript \\\\\\[8, 9] is outside array bounds of .char\\\\\\[8].\" } */\n+\n+  p = S7 + SR (4, 6);\n+  T (p[5]);                   /* { dg-warning \"array subscript \\\\\\[9, 11] is outside array bounds of .char\\\\\\[8].\" } */\n+}"}, {"sha": "951276426a9612452e5950da187524352bcec856", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-32.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-32.c?ref=d893b683f40884cd00b5beb392566ecc7b67f721", "patch": "@@ -0,0 +1,185 @@\n+/* PR tree-optimization/83776: missing -Warray-bounds indexing past the end\n+   of a string literal\n+   Test to exercise indices into wide string literals.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define MAX DIFF_MAX\n+#define MIN DIFF_MIN\n+\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+#define W2 L\"12\"\n+#define W3 L\"123\"\n+#define W4 L\"1234\"\n+#define W7 L\"1234567\"\n+#define W8 L\"12345678\"\n+#define W9 L\"123456789\"\n+\n+void sink (int);\n+\n+#define T(expr)   sink (expr)\n+\n+\n+void wide_direct_cst (void)\n+{\n+  T (W9[MIN]);                /* { dg-warning \"array subscript -\\[0-9\\]+ is below array bounds of .\\[a-z \\]+\\\\\\[10]\" \"\" } */\n+  T (W9[-1]);                 /* { dg-warning \"array subscript -1 is below array bounds of .\\[a-z \\]+\\\\\\[10]\" } */\n+  T (W9[11]);                 /* { dg-warning \"array subscript 11 is above array bounds of .\\[a-z \\]+\\\\\\[10]\" } */\n+  T (W9[MAX]);                /* { dg-warning \"array subscript \\[0-9\\]+ is above array bounds of .\\[a-z \\]+\\\\\\[10]\" } */\n+\n+}\n+\n+void wide_ptr_deref_cst (void)\n+{\n+  const wchar_t *p = W8 + 9;\n+  T (*p);                     /* { dg-warning \"array subscript 9 is outside array bounds of .\\[a-z \\]+\\\\\\[9].\" } */\n+  T (p[1]);                   /* { dg-warning \"array subscript 10 is outside array bounds of .\\[a-z \\]+\\\\\\[9].\" } */\n+  T (p[99]);                  /* { dg-warning \"array subscript 108 is outside array bounds of .\\[a-z \\]+\\\\\\[9].\" } */\n+}\n+\n+void wide_ptr_index_cst (void)\n+{\n+  const wchar_t *p = W7;\n+\n+  T (p[1]);\n+  T (p[8]);                   /* { dg-warning \"array subscript 8 is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n+  T (p[99]);                  /* { dg-warning \"array subscript 99 is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n+  T (p[MAX]);                 /* { dg-warning \"array subscript -?\\[0-9\\]+ is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n+}\n+\n+\n+void wide_direct_range (ptrdiff_t i, size_t j)\n+{\n+  T (W9[i]);\n+  T (W9[j]);\n+\n+  T (W9[SR (MIN, -9)]);       /* { dg-warning \"array subscript -9 is below array bounds of .\\[a-z \\]+\\\\\\[10]\" } */\n+  T (W9[SR (MIN, -1)]);       /* { dg-warning \"array subscript -1 is below array bounds of .\\[a-z \\]+\\\\\\[10]\" } */\n+  T (W9[SR (MIN, 0)]);\n+  T (W9[SR (-2, -1)]);        /* { dg-warning \"array subscript -1 is below array bounds of .\\[a-z \\]+\\\\\\[10]\" } */\n+  T (W9[SR (1, 2)]);\n+  T (W9[SR (1, 9)]);\n+  T (W9[SR (1, 999)]);\n+  T (W9[SR (9, 999)]);\n+  T (W9[SR (10, 999)]);       /* { dg-warning \"array subscript 10 is above array bounds of .\\[a-z \\]+\\\\\\[10]\" } */\n+  T (W9[SR (99, MAX)]);       /* { dg-warning \"array subscript 99 is above array bounds of .\\[a-z \\]+\\\\\\[10]\" } */\n+}\n+\n+void wide_ptr_deref_range (ptrdiff_t i, size_t j)\n+{\n+  const wchar_t *p;\n+\n+  p = W8 + i;\n+  T (*p);\n+\n+  p = W8 + j;\n+  T (*p);\n+\n+  p = W8 + SR (-9, -1);\n+  T (*p);                     /* { dg-warning \"array subscript \\\\\\[-9, -1] is outside array bounds of .\\[a-z \\]+\\\\\\[9].\" } */\n+\n+  p = W8 + SR (-9, 0);\n+  T (*p);\n+\n+  p = W8 + SR (-9, 9);\n+  T (*p);\n+\n+  p = W8 + SR (9, 123);\n+  T (*p);                     /* { dg-warning \"array subscript \\\\\\[9, 123] is outside array bounds of .\\[a-z \\]+\\\\\\[9].\" } */\n+}\n+\n+void wide_ptr_index_range (void)\n+{\n+  const wchar_t *p;\n+\n+  p = W7;\n+  T (p[SR (-9, -1)]);         /* { dg-warning \"array subscript \\\\\\[-9, -1] is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n+  T (p[SR (-8, 0)]);\n+  T (p[SR (0, MAX)]);\n+  T (p[SR (1, 9)]);\n+  T (p[SR (8, 9)]);           /* { dg-warning \"array subscript \\\\\\[8, 9] is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n+\n+  p = W7 + SR (4, 6);\n+  T (p[5]);                   /* { dg-warning \"array subscript \\\\\\[9, 11] is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n+}\n+\n+void wide_ptr_index_range_1 (void)\n+{\n+  {\n+    int i = SR (1, 2);\n+    const wchar_t *p1 = W2 + i;\n+\n+    T (p1[0]);\n+  }\n+  {\n+    int i = SR (1, 2);\n+    const wchar_t *p1 = W2 + i;\n+\n+    T (p1[1]);\n+  }\n+  {\n+    int i = SR (1, 2);\n+    const wchar_t *p1 = W2 + i;\n+\n+    T (p1[2]);                /* { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+  }\n+}\n+\n+void wide_ptr_index_range_chain (void)\n+{\n+  int i = SR (1, 2);\n+  {\n+    const wchar_t *p1 = W2 + i;\n+    const wchar_t *p2 = p1 + i;\n+    const wchar_t *p3 = p2 + i;\n+\n+    T (p1[-3]);               /* { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p1[-2]);\n+    T (p1[-1]);\n+    T (p1[0]);\n+    T (p1[1]);\n+    T (p1[2]);                /* { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+\n+    T (p2[-5]);               /* { dg-warning \"array subscript \\\\\\[-3, -1] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p2[-4]);\n+    T (p2[-1]);\n+    T (p2[0]);\n+    T (p2[1]);                /* { dg-warning \"array subscript \\\\\\[3, 5] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+\n+    T (p3[0]);                /* { dg-warning \"array subscript \\\\\\[3, 6] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p3[1]);                /* { dg-warning \"array subscript \\\\\\[4, 7] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p3[9999]);             /* { dg-warning \"array subscript \\\\\\[10002, 10005] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+\n+    /* Large offsets are indistinguishable from negative values.  */\n+    T (p3[DIFF_MAX]);         /* { dg-warning \"array subscript\" \"bug\" { xfail *-*-* } } */\n+  }\n+\n+  {\n+    const wchar_t *p1 = W3 + i;\n+    const wchar_t *p2 = p1 + i;\n+    const wchar_t *p3 = p2 + i;\n+    const wchar_t *p4 = p3 + i;\n+\n+    T (p1[-3]);               /* { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+    T (p1[-2]);\n+    T (p1[1]);\n+    T (p1[2]);\n+    T (p1[3]);                /* { dg-warning \"array subscript \\\\\\[4, 5] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+\n+    T (p3[1]);                /* { dg-warning \"array subscript \\\\\\[4, 7] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  }\n+}\n+\n+void wide_ptr_index_range_4 (void)\n+{\n+  int i = SR (1, 2);\n+  const wchar_t *p1 = W4 + i;\n+  const wchar_t *p2 = p1 + i;\n+  const wchar_t *p3 = p2 + i;\n+  const wchar_t *p4 = p3 + i;\n+\n+  T (p4[1]);                  /* { dg-warning \"array subscript \\\\\\[5, 9] is outside array bounds of .\\[a-z \\]+\\\\\\[5].\" } */\n+}"}, {"sha": "7ab8898b4534a1ef003a8d0ff1e98c6752deadd3", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 266, "deletions": 3, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d893b683f40884cd00b5beb392566ecc7b67f721/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d893b683f40884cd00b5beb392566ecc7b67f721", "patch": "@@ -4753,6 +4753,7 @@ class vrp_prop : public ssa_propagation_engine\n   void vrp_finalize (bool);\n   void check_all_array_refs (void);\n   void check_array_ref (location_t, tree, bool);\n+  void check_mem_ref (location_t, tree, bool);\n   void search_for_addr_array (tree, location_t);\n \n   class vr_values vr_values;\n@@ -4905,21 +4906,282 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n     }\n }\n \n+/* Checks one MEM_REF in REF, located at LOCATION, for out-of-bounds\n+   references to string constants.  If VRP can determine that the array\n+   subscript is a constant, check if it is outside valid range.\n+   If the array subscript is a RANGE, warn if it is non-overlapping\n+   with valid range.\n+   IGNORE_OFF_BY_ONE is true if the MEM_REF is inside an ADDR_EXPR\n+   (used to allow one-past-the-end indices for code that takes\n+   the address of the just-past-the-end element of an array).  */\n+\n+void\n+vrp_prop::check_mem_ref (location_t location, tree ref, bool ignore_off_by_one)\n+{\n+  if (TREE_NO_WARNING (ref))\n+    return;\n+\n+  tree arg = TREE_OPERAND (ref, 0);\n+  /* The constant and variable offset of the reference.  */\n+  tree cstoff = TREE_OPERAND (ref, 1);\n+  tree varoff = NULL_TREE;\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  /* The array or string constant bounds in bytes.  Initially set\n+     to [-MAXOBJSIZE - 1, MAXOBJSIZE]  until a tighter bound is\n+     determined.  */\n+  offset_int arrbounds[2] = { -maxobjsize - 1, maxobjsize };\n+\n+  /* The minimum and maximum intermediate offset.  For a reference\n+     to be valid, not only does the final offset/subscript must be\n+     in bounds but all intermediate offsets should be as well.\n+     GCC may be able to deal gracefully with such out-of-bounds\n+     offsets so the checking is only enbaled at -Warray-bounds=2\n+     where it may help detect bugs in uses of the intermediate\n+     offsets that could otherwise not be detectable.  */\n+  offset_int ioff = wi::to_offset (fold_convert (ptrdiff_type_node, cstoff));\n+  offset_int extrema[2] = { 0, wi::abs (ioff) };\n+\n+  /* The range of the byte offset into the reference.  */\n+  offset_int offrange[2] = { 0, 0 };\n+\n+  value_range *vr = NULL;\n+\n+  /* Determine the offsets and increment OFFRANGE for the bounds of each.\n+     The loop computes the the range of the final offset for expressions\n+     such as (A + i0 + ... + iN)[CSTOFF] where i0 through iN are SSA_NAMEs\n+     in some range.  */\n+  while (TREE_CODE (arg) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (arg);\n+      if (!is_gimple_assign (def))\n+\tbreak;\n+\n+      tree_code code = gimple_assign_rhs_code (def);\n+      if (code == POINTER_PLUS_EXPR)\n+\t{\n+\t  arg = gimple_assign_rhs1 (def);\n+\t  varoff = gimple_assign_rhs2 (def);\n+\t}\n+      else if (code == ASSERT_EXPR)\n+\t{\n+\t  arg = TREE_OPERAND (gimple_assign_rhs1 (def), 0);\n+\t  continue;\n+\t}\n+      else\n+\treturn;\n+\n+      /* VAROFF should always be a SSA_NAME here (and not even\n+\t INTEGER_CST) but there's no point in taking chances.  */\n+      if (TREE_CODE (varoff) != SSA_NAME)\n+\tbreak;\n+\n+      vr = get_value_range (varoff);\n+      if (!vr || vr->type == VR_UNDEFINED || !vr->min || !vr->max)\n+\tbreak;\n+\n+      if (TREE_CODE (vr->min) != INTEGER_CST\n+          || TREE_CODE (vr->max) != INTEGER_CST)\n+        break;\n+\n+      if (vr->type == VR_RANGE)\n+\t{\n+\t  if (tree_int_cst_lt (vr->min, vr->max))\n+\t    {\n+\t      offset_int min\n+\t\t= wi::to_offset (fold_convert (ptrdiff_type_node, vr->min));\n+\t      offset_int max\n+\t\t= wi::to_offset (fold_convert (ptrdiff_type_node, vr->max));\n+\t      if (min < max)\n+\t\t{\n+\t\t  offrange[0] += min;\n+\t\t  offrange[1] += max;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  offrange[0] += max;\n+\t\t  offrange[1] += min;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Conservatively add [-MAXOBJSIZE -1, MAXOBJSIZE]\n+\t\t to OFFRANGE.  */\n+\t      offrange[0] += arrbounds[0];\n+\t      offrange[1] += arrbounds[1];\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* For an anti-range, analogously to the above, conservatively\n+\t     add [-MAXOBJSIZE -1, MAXOBJSIZE] to OFFRANGE.  */\n+\t  offrange[0] += arrbounds[0];\n+\t  offrange[1] += arrbounds[1];\n+\t}\n+\n+      /* Keep track of the minimum and maximum offset.  */\n+      if (offrange[1] < 0 && offrange[1] < extrema[0])\n+\textrema[0] = offrange[1];\n+      if (offrange[0] > 0 && offrange[0] > extrema[1])\n+\textrema[1] = offrange[0];\n+\n+      if (offrange[0] < arrbounds[0])\n+\toffrange[0] = arrbounds[0];\n+\n+      if (offrange[1] > arrbounds[1])\n+\toffrange[1] = arrbounds[1];\n+    }\n+\n+  if (TREE_CODE (arg) == ADDR_EXPR)\n+    {\n+      arg = TREE_OPERAND (arg, 0);\n+      if (TREE_CODE (arg) != STRING_CST\n+\t  && TREE_CODE (arg) != VAR_DECL)\n+\treturn;\n+    }\n+  else\n+    return;\n+\n+  /* The type of the object being referred to.  It can be an array,\n+     string literal, or a non-array type when the MEM_REF represents\n+     a reference/subscript via a pointer to an object that is not\n+     an element of an array.  References to members of structs and\n+     unions are excluded because MEM_REF doesn't make it possible\n+     to identify the member where the reference originated.  */\n+  tree reftype = TREE_TYPE (arg);\n+  if (POINTER_TYPE_P (reftype)\n+      || RECORD_OR_UNION_TYPE_P (reftype))\n+    return;\n+\n+  offset_int eltsize;\n+  if (TREE_CODE (reftype) == ARRAY_TYPE)\n+    {\n+      eltsize = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (reftype)));\n+\n+      if (tree dom = TYPE_DOMAIN (reftype))\n+\t{\n+\t  tree bnds[] = { TYPE_MIN_VALUE (dom), TYPE_MAX_VALUE (dom) };\n+\t  if (array_at_struct_end_p (arg)\n+\t      || !bnds[0] || !bnds[1])\n+\t    {\n+\t      arrbounds[0] = 0;\n+\t      arrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n+\t    }\n+\t  else\n+\t    {\n+\t      arrbounds[0] = wi::to_offset (bnds[0]) * eltsize;\n+\t      arrbounds[1] = (wi::to_offset (bnds[1]) + 1) * eltsize;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  arrbounds[0] = 0;\n+\t  arrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n+\t}\n+\n+      if (TREE_CODE (ref) == MEM_REF)\n+\t{\n+\t  /* For MEM_REF determine a tighter bound of the non-array\n+\t     element type.  */\n+\t  tree eltype = TREE_TYPE (reftype);\n+\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n+\t    eltype = TREE_TYPE (eltype);\n+\t  eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));\n+\t}\n+    }\n+  else\n+    {\n+      eltsize = 1;\n+      arrbounds[0] = 0;\n+      arrbounds[1] = wi::to_offset (TYPE_SIZE_UNIT (reftype));\n+    }\n+\n+  offrange[0] += ioff;\n+  offrange[1] += ioff;\n+\n+  /* Compute the more permissive upper bound when IGNORE_OFF_BY_ONE\n+     is set (when taking the address of the one-past-last element\n+     of an array) but always use the stricter bound in diagnostics. */\n+  offset_int ubound = arrbounds[1];\n+  if (ignore_off_by_one)\n+    ubound += 1;\n+\n+  if (offrange[0] >= ubound || offrange[1] < arrbounds[0])\n+    {\n+      /* Treat a reference to a non-array object as one to an array\n+\t of a single element.  */\n+      if (TREE_CODE (reftype) != ARRAY_TYPE)\n+\treftype = build_array_type_nelts (reftype, 1);\n+\n+      if (TREE_CODE (ref) == MEM_REF)\n+\t{\n+\t  /* Extract the element type out of MEM_REF and use its size\n+\t     to compute the index to print in the diagnostic; arrays\n+\t     in MEM_REF don't mean anything.   */\n+\t  tree type = TREE_TYPE (ref);\n+\t  while (TREE_CODE (type) == ARRAY_TYPE)\n+\t    type = TREE_TYPE (type);\n+\t  tree size = TYPE_SIZE_UNIT (type);\n+\t  offrange[0] = offrange[0] / wi::to_offset (size);\n+\t  offrange[1] = offrange[1] / wi::to_offset (size);\n+\t}\n+      else\n+\t{\n+\t  /* For anything other than MEM_REF, compute the index to\n+\t     print in the diagnostic as the offset over element size.  */\n+\t  offrange[0] = offrange[0] / eltsize;\n+\t  offrange[1] = offrange[1] / eltsize;\n+\t}\n+\n+      if (offrange[0] == offrange[1])\n+\twarning_at (location, OPT_Warray_bounds,\n+\t\t    \"array subscript %wi is outside array bounds \"\n+\t\t    \"of %qT\",\n+\t\t    offrange[0].to_shwi (), reftype);\n+      else\n+\twarning_at (location, OPT_Warray_bounds,\n+\t\t    \"array subscript [%wi, %wi] is outside array bounds \"\n+\t\t    \"of %qT\",\n+\t\t    offrange[0].to_shwi (), offrange[1].to_shwi (), reftype);\n+      TREE_NO_WARNING (ref) = 1;\n+      return;\n+    }\n+\n+  if (warn_array_bounds < 2)\n+    return;\n+\n+  /* At level 2 check also intermediate offsets.  */\n+  int i = 0;\n+  if (extrema[i] < -arrbounds[1] || extrema[i = 1] > ubound)\n+    {\n+      HOST_WIDE_INT tmpidx = extrema[i].to_shwi () / eltsize.to_shwi ();\n+\n+      warning_at (location, OPT_Warray_bounds,\n+\t\t  \"intermediate array offset %wi is outside array bounds \"\n+\t\t  \"of %qT\",\n+\t\t  tmpidx,  reftype);\n+      TREE_NO_WARNING (ref) = 1;\n+    }\n+}\n+\n /* Searches if the expr T, located at LOCATION computes\n    address of an ARRAY_REF, and call check_array_ref on it.  */\n \n void\n vrp_prop::search_for_addr_array (tree t, location_t location)\n {\n-  /* Check each ARRAY_REFs in the reference chain. */\n+  /* Check each ARRAY_REF and MEM_REF in the reference chain. */\n   do\n     {\n       if (TREE_CODE (t) == ARRAY_REF)\n \tcheck_array_ref (location, t, true /*ignore_off_by_one*/);\n+      else if (TREE_CODE (t) == MEM_REF)\n+\tcheck_mem_ref (location, t, true /*ignore_off_by_one*/);\n \n       t = TREE_OPERAND (t, 0);\n     }\n-  while (handled_component_p (t));\n+  while (handled_component_p (t) || TREE_CODE (t) == MEM_REF);\n \n   if (TREE_CODE (t) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n@@ -5001,7 +5263,8 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n   vrp_prop *vrp_prop = (class vrp_prop *)wi->info;\n   if (TREE_CODE (t) == ARRAY_REF)\n     vrp_prop->check_array_ref (location, t, false /*ignore_off_by_one*/);\n-\n+  else if (TREE_CODE (t) == MEM_REF)\n+    vrp_prop->check_mem_ref (location, t, false /*ignore_off_by_one*/);\n   else if (TREE_CODE (t) == ADDR_EXPR)\n     {\n       vrp_prop->search_for_addr_array (t, location);"}]}