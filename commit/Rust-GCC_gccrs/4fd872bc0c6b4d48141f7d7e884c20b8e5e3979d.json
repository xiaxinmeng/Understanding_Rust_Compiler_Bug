{"sha": "4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZkODcyYmMwYzZiNGQ0ODE0MWY3ZDdlODg0YzIwYjhlNWUzOTc5ZA==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-12-20T01:20:33Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-12-20T01:20:33Z"}, "message": "OpenACC 2.6 deep copy: middle-end parts\n\n\tgcc/\n\t* gimplify.c (gimplify_omp_var_data): Add GOVD_MAP_HAS_ATTACHMENTS.\n\t(insert_struct_comp_map): Support derived-type member mappings\n\tfor arrays with descriptors which use GOMP_MAP_TO_PSET.  Support\n\tGOMP_MAP_ATTACH_DETACH.\n\t(gimplify_scan_omp_clauses): Tidy up OACC_ENTER_DATA/OACC_EXIT_DATA\n\tmappings.  Handle attach/detach clauses and component references.\n\t(gimplify_adjust_omp_clauses_1): Skip adjustments for explicit\n\tattach/detach clauses.\n\t(gimplify_omp_target_update): Handle struct mappings and finalize for\n\tdetach operations.\n\t* omp-low.c (lower_omp_target): Support GOMP_MAP_ATTACH,\n\tGOMP_MAP_DETACH, GOMP_MAP_FORCE_DETACH.\n\t* tree-pretty-print.c (dump_omp_clause): Likewise, plus\n\tGOMP_MAP_ATTACH_DETACH.\n\n\tinclude/\n\t* gomp-constants.h (gomp_map_kind): Add GOMP_MAP_ATTACH_DETACH.\n\nFrom-SVN: r279626", "tree": {"sha": "d413cc1b638c4788d3a17583d44ecd7fe461c717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d413cc1b638c4788d3a17583d44ecd7fe461c717"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f"}], "stats": {"total": 267, "additions": 242, "deletions": 25}, "files": [{"sha": "28f5994ea0dcc3a78cd3a40a867c60dfacb53cf4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "patch": "@@ -1,3 +1,20 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+\t* gimplify.c (gimplify_omp_var_data): Add GOVD_MAP_HAS_ATTACHMENTS.\n+\t(insert_struct_comp_map): Support derived-type member mappings\n+\tfor arrays with descriptors which use GOMP_MAP_TO_PSET.  Support\n+\tGOMP_MAP_ATTACH_DETACH.\n+\t(gimplify_scan_omp_clauses): Tidy up OACC_ENTER_DATA/OACC_EXIT_DATA\n+\tmappings.  Handle attach/detach clauses and component references.\n+\t(gimplify_adjust_omp_clauses_1): Skip adjustments for explicit\n+\tattach/detach clauses.\n+\t(gimplify_omp_target_update): Handle struct mappings and finalize for\n+\tdetach operations.\n+\t* omp-low.c (lower_omp_target): Support GOMP_MAP_ATTACH,\n+\tGOMP_MAP_DETACH, GOMP_MAP_FORCE_DETACH.\n+\t* tree-pretty-print.c (dump_omp_clause): Likewise, plus\n+\tGOMP_MAP_ATTACH_DETACH.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \n \t* gimplify.c (insert_struct_comp_map, extract_base_bit_offset): New."}, {"sha": "bbe4c7f5a4ba2a420fa43f2a4386e1cab6238cd3", "filename": "gcc/gimplify.c", "status": "modified", "additions": 195, "deletions": 24, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "patch": "@@ -123,6 +123,10 @@ enum gimplify_omp_var_data\n   /* Flag for GOVD_REDUCTION: inscan seen in {in,ex}clusive clause.  */\n   GOVD_REDUCTION_INSCAN = 0x2000000,\n \n+  /* Flag for GOVD_MAP: (struct) vars that have pointer attachments for\n+     fields.  */\n+  GOVD_MAP_HAS_ATTACHMENTS = 8388608,\n+\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n \t\t\t   | GOVD_LOCAL)\n@@ -8209,20 +8213,33 @@ insert_struct_comp_map (enum tree_code code, tree c, tree struct_node,\n \t\t\ttree prev_node, tree *scp)\n {\n   enum gomp_map_kind mkind\n-    = code == OMP_TARGET_EXIT_DATA ? GOMP_MAP_RELEASE : GOMP_MAP_ALLOC;\n+    = (code == OMP_TARGET_EXIT_DATA || code == OACC_EXIT_DATA)\n+      ? GOMP_MAP_RELEASE : GOMP_MAP_ALLOC;\n \n   tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n   tree cl = scp ? prev_node : c2;\n   OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n   OMP_CLAUSE_DECL (c2) = unshare_expr (OMP_CLAUSE_DECL (c));\n   OMP_CLAUSE_CHAIN (c2) = scp ? *scp : prev_node;\n-  OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (ptr_type_node);\n+  if (OMP_CLAUSE_CHAIN (prev_node) != c\n+      && OMP_CLAUSE_CODE (OMP_CLAUSE_CHAIN (prev_node)) == OMP_CLAUSE_MAP\n+      && (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (prev_node))\n+\t  == GOMP_MAP_TO_PSET))\n+    OMP_CLAUSE_SIZE (c2) = OMP_CLAUSE_SIZE (OMP_CLAUSE_CHAIN (prev_node));\n+  else\n+    OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (ptr_type_node);\n   if (struct_node)\n     OMP_CLAUSE_CHAIN (struct_node) = c2;\n \n   /* We might need to create an additional mapping if we have a reference to a\n-     pointer (in C++).  */\n-  if (OMP_CLAUSE_CHAIN (prev_node) != c)\n+     pointer (in C++).  Don't do this if we have something other than a\n+     GOMP_MAP_ALWAYS_POINTER though, i.e. a GOMP_MAP_TO_PSET.  */\n+  if (OMP_CLAUSE_CHAIN (prev_node) != c\n+      && OMP_CLAUSE_CODE (OMP_CLAUSE_CHAIN (prev_node)) == OMP_CLAUSE_MAP\n+      && ((OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (prev_node))\n+\t   == GOMP_MAP_ALWAYS_POINTER)\n+\t  || (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (prev_node))\n+\t      == GOMP_MAP_ATTACH_DETACH)))\n     {\n       tree c4 = OMP_CLAUSE_CHAIN (prev_node);\n       tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n@@ -8329,6 +8346,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n   struct gimplify_omp_ctx *ctx, *outer_ctx;\n   tree c;\n   hash_map<tree, tree> *struct_map_to_clause = NULL;\n+  hash_set<tree> *struct_deref_set = NULL;\n   tree *prev_list_p = NULL, *orig_list_p = list_p;\n   int handled_depend_iterators = -1;\n   int nowait = -1;\n@@ -8731,8 +8749,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    case OMP_TARGET_DATA:\n \t    case OMP_TARGET_ENTER_DATA:\n \t    case OMP_TARGET_EXIT_DATA:\n-\t    case OACC_ENTER_DATA:\n-\t    case OACC_EXIT_DATA:\n \t    case OACC_HOST_DATA:\n \t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n \t\t  || (OMP_CLAUSE_MAP_KIND (c)\n@@ -8741,6 +8757,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t   mapped, but not the pointer to it.  */\n \t\tremove = true;\n \t      break;\n+\t    case OACC_ENTER_DATA:\n+\t    case OACC_EXIT_DATA:\n+\t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n+\t\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_TO_PSET\n+\t\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t  || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t      == GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n+\t\tremove = true;\n+\t      break;\n \t    default:\n \t      break;\n \t    }\n@@ -8814,7 +8839,35 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  pd = &TREE_OPERAND (decl, 0);\n \t\t  decl = TREE_OPERAND (decl, 0);\n \t\t}\n-\t      if (TREE_CODE (decl) == COMPONENT_REF)\n+\t      bool indir_p = false;\n+\t      tree orig_decl = decl;\n+\t      tree decl_ref = NULL_TREE;\n+\t      if ((region_type & ORT_ACC) != 0\n+\t\t  && TREE_CODE (*pd) == COMPONENT_REF\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH\n+\t\t  && code != OACC_UPDATE)\n+\t\t{\n+\t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n+\t\t    {\n+\t\t      decl = TREE_OPERAND (decl, 0);\n+\t\t      if ((TREE_CODE (decl) == MEM_REF\n+\t\t\t   && integer_zerop (TREE_OPERAND (decl, 1)))\n+\t\t\t  || INDIRECT_REF_P (decl))\n+\t\t\t{\n+\t\t\t  indir_p = true;\n+\t\t\t  decl = TREE_OPERAND (decl, 0);\n+\t\t\t}\n+\t\t      if (TREE_CODE (decl) == INDIRECT_REF\n+\t\t\t  && DECL_P (TREE_OPERAND (decl, 0))\n+\t\t\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n+\t\t\t      == REFERENCE_TYPE))\n+\t\t\t{\n+\t\t\t  decl_ref = decl;\n+\t\t\t  decl = TREE_OPERAND (decl, 0);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else if (TREE_CODE (decl) == COMPONENT_REF)\n \t\t{\n \t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n \t\t    decl = TREE_OPERAND (decl, 0);\n@@ -8824,13 +8877,76 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  == REFERENCE_TYPE))\n \t\t    decl = TREE_OPERAND (decl, 0);\n \t\t}\n+\t      if (decl != orig_decl && DECL_P (decl) && indir_p)\n+\t\t{\n+\t\t  gomp_map_kind k = (code == OACC_EXIT_DATA) ? GOMP_MAP_DETACH\n+\t\t\t\t\t\t\t     : GOMP_MAP_ATTACH;\n+\t\t  /* We have a dereference of a struct member.  Make this an\n+\t\t     attach/detach operation, and ensure the base pointer is\n+\t\t     mapped as a FIRSTPRIVATE_POINTER.  */\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (c, k);\n+\t\t  flags = GOVD_MAP | GOVD_SEEN | GOVD_EXPLICIT;\n+\t\t  tree next_clause = OMP_CLAUSE_CHAIN (c);\n+\t\t  if (k == GOMP_MAP_ATTACH\n+\t\t      && code != OACC_ENTER_DATA\n+\t\t      && (!next_clause\n+\t\t\t   || (OMP_CLAUSE_CODE (next_clause) != OMP_CLAUSE_MAP)\n+\t\t\t   || (OMP_CLAUSE_MAP_KIND (next_clause)\n+\t\t\t       != GOMP_MAP_POINTER)\n+\t\t\t   || OMP_CLAUSE_DECL (next_clause) != decl)\n+\t\t      && (!struct_deref_set\n+\t\t\t  || !struct_deref_set->contains (decl)))\n+\t\t    {\n+\t\t      if (!struct_deref_set)\n+\t\t\tstruct_deref_set = new hash_set<tree> ();\n+\t\t      /* As well as the attach, we also need a\n+\t\t\t FIRSTPRIVATE_POINTER clause to properly map the\n+\t\t\t pointer to the struct base.  */\n+\t\t      tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t  OMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALLOC);\n+\t\t      OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (c2)\n+\t\t\t= 1;\n+\t\t      tree charptr_zero\n+\t\t\t= build_int_cst (build_pointer_type (char_type_node),\n+\t\t\t\t\t 0);\n+\t\t      OMP_CLAUSE_DECL (c2)\n+\t\t\t= build2 (MEM_REF, char_type_node,\n+\t\t\t\t  decl_ref ? decl_ref : decl, charptr_zero);\n+\t\t      OMP_CLAUSE_SIZE (c2) = size_zero_node;\n+\t\t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t  OMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (c3,\n+\t\t\t\t\t       GOMP_MAP_FIRSTPRIVATE_POINTER);\n+\t\t      OMP_CLAUSE_DECL (c3) = decl;\n+\t\t      OMP_CLAUSE_SIZE (c3) = size_zero_node;\n+\t\t      tree mapgrp = *prev_list_p;\n+\t\t      *prev_list_p = c2;\n+\t\t      OMP_CLAUSE_CHAIN (c3) = mapgrp;\n+\t\t      OMP_CLAUSE_CHAIN (c2) = c3;\n+\n+\t\t      struct_deref_set->add (decl);\n+\t\t    }\n+\t\t  goto do_add_decl;\n+\t\t}\n+\t      /* An \"attach/detach\" operation on an update directive should\n+\t\t behave as a GOMP_MAP_ALWAYS_POINTER.  Beware that\n+\t\t unlike attach or detach map kinds, GOMP_MAP_ALWAYS_POINTER\n+\t\t depends on the previous mapping.  */\n+\t      if (code == OACC_UPDATE\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n+\t\tOMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ALWAYS_POINTER);\n \t      if (gimplify_expr (pd, pre_p, NULL, is_gimple_lvalue, fb_lvalue)\n \t\t  == GS_ERROR)\n \t\t{\n \t\t  remove = true;\n \t\t  break;\n \t\t}\n-\t      if (DECL_P (decl))\n+\t      if (DECL_P (decl)\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_TO_PSET\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_DETACH\n+\t\t  && code != OACC_UPDATE)\n \t\t{\n \t\t  if (error_operand_p (decl))\n \t\t    {\n@@ -8851,7 +8967,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      break;\n \t\t    }\n \n-\t\t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER)\n+\t\t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER\n+\t\t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n \t\t    {\n \t\t      /* Error recovery.  */\n \t\t      if (prev_list_p == NULL)\n@@ -8884,20 +9001,47 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t    = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n \t\t  bool ptr = (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t      == GOMP_MAP_ALWAYS_POINTER);\n+\t\t  bool attach_detach = (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t\t\t== GOMP_MAP_ATTACH_DETACH);\n+\t\t  bool attach = OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t\t\t\t|| OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH;\n+\t\t  bool has_attachments = false;\n+\t\t  /* For OpenACC, pointers in structs should trigger an\n+\t\t     attach action.  */\n+\t\t  if (attach_detach && (region_type & ORT_ACC) != 0)\n+\t\t    {\n+\t\t      /* Turn a GOMP_MAP_ATTACH_DETACH clause into a\n+\t\t\t GOMP_MAP_ATTACH or GOMP_MAP_DETACH clause after we\n+\t\t\t have detected a case that needs a GOMP_MAP_STRUCT\n+\t\t\t mapping added.  */\n+\t\t      gomp_map_kind k\n+\t\t\t= (code == OACC_EXIT_DATA) ? GOMP_MAP_DETACH\n+\t\t\t\t\t\t   : GOMP_MAP_ATTACH;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (c, k);\n+\t\t      has_attachments = true;\n+\t\t    }\n \t\t  if (n == NULL || (n->value & GOVD_MAP) == 0)\n \t\t    {\n \t\t      tree l = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t\t OMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (l, GOMP_MAP_STRUCT);\n+\t\t      gomp_map_kind k = attach ? GOMP_MAP_FORCE_PRESENT\n+\t\t\t\t\t       : GOMP_MAP_STRUCT;\n+\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (l, k);\n \t\t      if (base_ref)\n \t\t\tOMP_CLAUSE_DECL (l) = unshare_expr (base_ref);\n \t\t      else\n \t\t\tOMP_CLAUSE_DECL (l) = decl;\n-\t\t      OMP_CLAUSE_SIZE (l) = size_int (1);\n+\t\t      OMP_CLAUSE_SIZE (l)\n+\t\t\t= (!attach\n+\t\t\t   ? size_int (1)\n+\t\t\t   : DECL_P (OMP_CLAUSE_DECL (l))\n+\t\t\t   ? DECL_SIZE_UNIT (OMP_CLAUSE_DECL (l))\n+\t\t\t   : TYPE_SIZE_UNIT (TREE_TYPE (OMP_CLAUSE_DECL (l))));\n \t\t      if (struct_map_to_clause == NULL)\n \t\t\tstruct_map_to_clause = new hash_map<tree, tree>;\n \t\t      struct_map_to_clause->put (decl, l);\n-\t\t      if (ptr)\n+\t\t      if (ptr || attach_detach)\n \t\t\t{\n \t\t\t  insert_struct_comp_map (code, c, l, *prev_list_p,\n \t\t\t\t\t\t  NULL);\n@@ -8923,23 +9067,31 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  OMP_CLAUSE_CHAIN (l) = c2;\n \t\t\t}\n \t\t      flags = GOVD_MAP | GOVD_EXPLICIT;\n-\t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) || ptr)\n+\t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c))\n+\t\t\t  || ptr\n+\t\t\t  || attach_detach)\n \t\t\tflags |= GOVD_SEEN;\n+\t\t      if (has_attachments)\n+\t\t\tflags |= GOVD_MAP_HAS_ATTACHMENTS;\n \t\t      goto do_add_decl;\n \t\t    }\n-\t\t  else\n+\t\t  else if (struct_map_to_clause)\n \t\t    {\n \t\t      tree *osc = struct_map_to_clause->get (decl);\n \t\t      tree *sc = NULL, *scp = NULL;\n-\t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) || ptr)\n+\t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c))\n+\t\t\t  || ptr\n+\t\t\t  || attach_detach)\n \t\t\tn->value |= GOVD_SEEN;\n \t\t      sc = &OMP_CLAUSE_CHAIN (*osc);\n \t\t      if (*sc != c\n \t\t\t  && (OMP_CLAUSE_MAP_KIND (*sc)\n-\t\t\t      == GOMP_MAP_FIRSTPRIVATE_REFERENCE)) \n+\t\t\t      == GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n \t\t\tsc = &OMP_CLAUSE_CHAIN (*sc);\n+\t\t      /* Here \"prev_list_p\" is the end of the inserted\n+\t\t\t alloc/release nodes after the struct node, OSC.  */\n \t\t      for (; *sc != c; sc = &OMP_CLAUSE_CHAIN (*sc))\n-\t\t\tif (ptr && sc == prev_list_p)\n+\t\t\tif ((ptr || attach_detach) && sc == prev_list_p)\n \t\t\t  break;\n \t\t\telse if (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n \t\t\t\t != COMPONENT_REF\n@@ -8992,18 +9144,19 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\t|| (known_eq (offset1, offsetn)\n \t\t\t\t    && maybe_lt (bitpos1, bitposn)))\n \t\t\t      {\n-\t\t\t\tif (ptr)\n+\t\t\t\tif (ptr || attach_detach)\n \t\t\t\t  scp = sc;\n \t\t\t\telse\n \t\t\t\t  break;\n \t\t\t      }\n \t\t\t  }\n \t\t      if (remove)\n \t\t\tbreak;\n-\t\t      OMP_CLAUSE_SIZE (*osc)\n-\t\t\t= size_binop (PLUS_EXPR, OMP_CLAUSE_SIZE (*osc),\n-\t\t\t\t      size_one_node);\n-\t\t      if (ptr)\n+\t\t      if (!attach)\n+\t\t\tOMP_CLAUSE_SIZE (*osc)\n+\t\t\t  = size_binop (PLUS_EXPR, OMP_CLAUSE_SIZE (*osc),\n+\t\t\t\t\tsize_one_node);\n+\t\t      if (ptr || attach_detach)\n \t\t\t{\n \t\t\t  tree cl = insert_struct_comp_map (code, c, NULL,\n \t\t\t\t\t\t\t    *prev_list_p, scp);\n@@ -9033,11 +9186,18 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t}\n \t      if (!remove\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_POINTER\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH_DETACH\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_TO_PSET\n \t\t  && OMP_CLAUSE_CHAIN (c)\n \t\t  && OMP_CLAUSE_CODE (OMP_CLAUSE_CHAIN (c)) == OMP_CLAUSE_MAP\n-\t\t  && (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (c))\n-\t\t      == GOMP_MAP_ALWAYS_POINTER))\n+\t\t  && ((OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (c))\n+\t\t       == GOMP_MAP_ALWAYS_POINTER)\n+\t\t      || (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (c))\n+\t\t\t  == GOMP_MAP_ATTACH_DETACH)\n+\t\t      || (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (c))\n+\t\t\t  == GOMP_MAP_TO_PSET)))\n \t\tprev_list_p = list_p;\n+\n \t      break;\n \t    }\n \t  flags = GOVD_MAP | GOVD_EXPLICIT;\n@@ -9561,6 +9721,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n   gimplify_omp_ctxp = ctx;\n   if (struct_map_to_clause)\n     delete struct_map_to_clause;\n+  if (struct_deref_set)\n+    delete struct_deref_set;\n }\n \n /* Return true if DECL is a candidate for shared to firstprivate\n@@ -9708,6 +9870,8 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n     return 0;\n   if ((flags & GOVD_SEEN) == 0)\n     return 0;\n+  if ((flags & GOVD_MAP_HAS_ATTACHMENTS) != 0)\n+    return 0;\n   if (flags & GOVD_DEBUG_PRIVATE)\n     {\n       gcc_assert ((flags & GOVD_DATA_SHARE_CLASS) == GOVD_SHARED);\n@@ -12784,6 +12948,13 @@ gimplify_omp_target_update (tree *expr_p, gimple_seq *pre_p)\n \t\t one group, so no handling required here.  */\n \t      gcc_assert (have_clause);\n \t      break;\n+\t    case GOMP_MAP_DETACH:\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_FORCE_DETACH);\n+\t      have_clause = false;\n+\t      break;\n+\t    case GOMP_MAP_STRUCT:\n+\t      have_clause = false;\n+\t      break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }"}, {"sha": "e697f3c620d4ee279b0fe6890529c838880f7cc2", "filename": "gcc/omp-low.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "patch": "@@ -11440,6 +11440,9 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case GOMP_MAP_FORCE_DEVICEPTR:\n \t  case GOMP_MAP_DEVICE_RESIDENT:\n \t  case GOMP_MAP_LINK:\n+\t  case GOMP_MAP_ATTACH:\n+\t  case GOMP_MAP_DETACH:\n+\t  case GOMP_MAP_FORCE_DETACH:\n \t    gcc_assert (is_gimple_omp_oacc (stmt));\n \t    break;\n \t  default:"}, {"sha": "8d21ef81cdc93ae5643f4ce093be96eebe237295", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "patch": "@@ -852,6 +852,18 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \tcase GOMP_MAP_LINK:\n \t  pp_string (pp, \"link\");\n \t  break;\n+\tcase GOMP_MAP_ATTACH:\n+\t  pp_string (pp, \"attach\");\n+\t  break;\n+\tcase GOMP_MAP_DETACH:\n+\t  pp_string (pp, \"detach\");\n+\t  break;\n+\tcase GOMP_MAP_FORCE_DETACH:\n+\t  pp_string (pp, \"force_detach\");\n+\t  break;\n+\tcase GOMP_MAP_ATTACH_DETACH:\n+\t  pp_string (pp, \"attach_detach\");\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -873,6 +885,12 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \t    case GOMP_MAP_TO_PSET:\n \t      pp_string (pp, \" [pointer set, len: \");\n \t      break;\n+\t    case GOMP_MAP_ATTACH:\n+\t    case GOMP_MAP_DETACH:\n+\t    case GOMP_MAP_FORCE_DETACH:\n+\t    case GOMP_MAP_ATTACH_DETACH:\n+\t      pp_string (pp, \" [bias: \");\n+\t      break;\n \t    default:\n \t      pp_string (pp, \" [len: \");\n \t      break;"}, {"sha": "3d44a944680990749876159b0b02f8df0a29f17e", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "patch": "@@ -1,3 +1,7 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+\t* gomp-constants.h (gomp_map_kind): Add GOMP_MAP_ATTACH_DETACH.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \n \t* gomp-constants.h (GOMP_MAP_FLAG_SPECIAL_4, GOMP_MAP_DEEP_COPY):"}, {"sha": "fdae6ccc870126f62a72d6956589f17ee843ceb4", "filename": "include/gomp-constants.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "patch": "@@ -144,7 +144,11 @@ enum gomp_map_kind\n     /* Do not map, but pointer assign a pointer instead.  */\n     GOMP_MAP_FIRSTPRIVATE_POINTER =\t(GOMP_MAP_LAST | 1),\n     /* Do not map, but pointer assign a reference instead.  */\n-    GOMP_MAP_FIRSTPRIVATE_REFERENCE =\t(GOMP_MAP_LAST | 2)\n+    GOMP_MAP_FIRSTPRIVATE_REFERENCE =\t(GOMP_MAP_LAST | 2),\n+    /* An attach or detach operation.  Rewritten to the appropriate type during\n+       gimplification, depending on directive (i.e. \"enter data\" or\n+       parallel/kernels region vs. \"exit data\").  */\n+    GOMP_MAP_ATTACH_DETACH =\t\t(GOMP_MAP_LAST | 3)\n   };\n \n #define GOMP_MAP_COPY_TO_P(X) \\"}]}