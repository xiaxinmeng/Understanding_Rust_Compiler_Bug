{"sha": "b440f32451e63beab306ec5cffba4c7ca3e85f97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ0MGYzMjQ1MWU2M2JlYWIzMDZlYzVjZmZiYTRjN2NhM2U4NWY5Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-01-10T04:47:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-01-10T04:47:26Z"}, "message": "arm: Implement vec_perm and vec_perm_const for NEON.\n\n\t* config/arm/arm.c (arm_vectorize_vec_perm_const_ok,\n\tTARGET_VECTORIZE_VEC_PERM_CONST_OK, neon_split_vcombine, MAX_VECT_LEN,\n\tstruct expand_vec_perm_d, arm_expand_vec_perm_1, arm_expand_vec_perm,\n\tarm_evpc_neon_vuzp, arm_evpc_neon_vzip, arm_evpc_neon_vrev,\n\tarm_evpc_neon_vtrn, arm_evpc_neon_vtbl, arm_expand_vec_perm_const_1,\n\tarm_expand_vec_perm_const): New.\n\t* config/arm/arm-protos.h: Update.\n\t* config/arm/neon.md (UNSPEC_VCONCAT): New.\n\t(*neon_vswp<VDQX>): New.\n\t(neon_vcombine<VDX>): Use neon_split_vcombine.\n\t(neon_vtbl1v16qi, neon_vtbl2v16qi, neon_vcombinev16qi): New.\n\t* config/arm/vec-common.md (vec_perm_const<VALL>): New.\n\t(vec_perm<VE>): New.\n\ntestsuite/\n\t* lib/target-supports.exp (check_effective_target_vect_perm,\n\tcheck_effective_target_vect_perm_byte,\n\tcheck_effective_target_vect_perm_short): Enable for arm neon.\n\nFrom-SVN: r183051", "tree": {"sha": "e4a083eb7000163130dae87944b7a0474f29a141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4a083eb7000163130dae87944b7a0474f29a141"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b440f32451e63beab306ec5cffba4c7ca3e85f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b440f32451e63beab306ec5cffba4c7ca3e85f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b440f32451e63beab306ec5cffba4c7ca3e85f97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b440f32451e63beab306ec5cffba4c7ca3e85f97/comments", "author": null, "committer": null, "parents": [{"sha": "18f0fe6b98ec82da10e3d3c67f802f1cf6c2a77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18f0fe6b98ec82da10e3d3c67f802f1cf6c2a77f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18f0fe6b98ec82da10e3d3c67f802f1cf6c2a77f"}], "stats": {"total": 776, "additions": 729, "deletions": 47}, "files": [{"sha": "c7d02081bef747b979ada0182c80e61a819d3918", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b440f32451e63beab306ec5cffba4c7ca3e85f97", "patch": "@@ -1,3 +1,19 @@\n+2012-01-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/arm/arm.c (arm_vectorize_vec_perm_const_ok, \n+\tTARGET_VECTORIZE_VEC_PERM_CONST_OK, neon_split_vcombine, MAX_VECT_LEN,\n+\tstruct expand_vec_perm_d, arm_expand_vec_perm_1, arm_expand_vec_perm,\n+\tarm_evpc_neon_vuzp, arm_evpc_neon_vzip, arm_evpc_neon_vrev,\n+\tarm_evpc_neon_vtrn, arm_evpc_neon_vtbl, arm_expand_vec_perm_const_1,\n+\tarm_expand_vec_perm_const): New.\n+\t* config/arm/arm-protos.h: Update.\n+\t* config/arm/neon.md (UNSPEC_VCONCAT): New.\n+\t(*neon_vswp<VDQX>): New.\n+\t(neon_vcombine<VDX>): Use neon_split_vcombine.\n+\t(neon_vtbl1v16qi, neon_vtbl2v16qi, neon_vcombinev16qi): New.\n+\t* config/arm/vec-common.md (vec_perm_const<VALL>): New.\n+\t(vec_perm<VE>): New.\n+\n 2012-01-10  Richard Henderson  <rth@redhat.com>\n \n \t* config/arm/arm.c (arm_gen_compare_reg): Add scratch argument;"}, {"sha": "1767128c8d5bd8464d436da7f9ce8a79a4eeaff4", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=b440f32451e63beab306ec5cffba4c7ca3e85f97", "patch": "@@ -86,6 +86,7 @@ extern void neon_emit_pair_result_insn (enum machine_mode,\n \t\t\t\t\trtx (*) (rtx, rtx, rtx, rtx),\n \t\t\t\t\trtx, rtx, rtx);\n extern void neon_disambiguate_copy (rtx *, rtx *, rtx *, unsigned int);\n+extern void neon_split_vcombine (rtx op[3]);\n extern enum reg_class coproc_secondary_reload_class (enum machine_mode, rtx,\n \t\t\t\t\t\t     bool);\n extern bool arm_tls_referenced_p (rtx);\n@@ -243,4 +244,7 @@ extern const struct tune_params *current_tune;\n extern int vfp3_const_double_for_fract_bits (rtx);\n #endif /* RTX_CODE */\n \n+extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n+extern bool arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n+\n #endif /* ! GCC_ARM_PROTOS_H */"}, {"sha": "4c310d4242029bc482a98b1b8dd909ae47909e8a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 565, "deletions": 2, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b440f32451e63beab306ec5cffba4c7ca3e85f97", "patch": "@@ -269,6 +269,9 @@ static unsigned int arm_autovectorize_vector_sizes (void);\n static int arm_default_branch_cost (bool, bool);\n static int arm_cortex_a5_branch_cost (bool, bool);\n \n+static bool arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t\t     const unsigned char *sel);\n+\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -612,6 +615,10 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_PREFERRED_RENAME_CLASS \\\n   arm_preferred_rename_class\n \n+#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n+#define TARGET_VECTORIZE_VEC_PERM_CONST_OK \\\n+  arm_vectorize_vec_perm_const_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -20915,6 +20922,53 @@ neon_disambiguate_copy (rtx *operands, rtx *dest, rtx *src, unsigned int count)\n     }\n }\n \n+/* Split operands into moves from op[1] + op[2] into op[0].  */\n+\n+void\n+neon_split_vcombine (rtx operands[3])\n+{\n+  unsigned int dest = REGNO (operands[0]);\n+  unsigned int src1 = REGNO (operands[1]);\n+  unsigned int src2 = REGNO (operands[2]);\n+  enum machine_mode halfmode = GET_MODE (operands[1]);\n+  unsigned int halfregs = HARD_REGNO_NREGS (src1, halfmode);\n+  rtx destlo, desthi;\n+\n+  if (src1 == dest && src2 == dest + halfregs)\n+    return;\n+\n+  /* Preserve register attributes for variable tracking.  */\n+  destlo = gen_rtx_REG_offset (operands[0], halfmode, dest, 0);\n+  desthi = gen_rtx_REG_offset (operands[0], halfmode, dest + halfregs,\n+\t\t\t       GET_MODE_SIZE (halfmode));\n+\n+  /* Special case of reversed high/low parts.  Use VSWP.  */\n+  if (src2 == dest && src1 == dest + halfregs)\n+    {\n+      rtx x = gen_rtx_SET (VOIDmode, destlo, operands[1]);\n+      rtx y = gen_rtx_SET (VOIDmode, desthi, operands[2]);\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x, y)));\n+      return;\n+    }\n+\n+  if (!reg_overlap_mentioned_p (operands[2], destlo))\n+    {\n+      /* Try to avoid unnecessary moves if part of the result\n+\t is in the right place already.  */\n+      if (src1 != dest)\n+\temit_move_insn (destlo, operands[1]);\n+      if (src2 != dest + halfregs)\n+\temit_move_insn (desthi, operands[2]);\n+    }\n+  else\n+    {\n+      if (src2 != dest + halfregs)\n+\temit_move_insn (desthi, operands[2]);\n+      if (src1 != dest)\n+\temit_move_insn (destlo, operands[1]);\n+    }\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient).\n@@ -24642,7 +24696,7 @@ vfp3_const_double_for_fract_bits (rtx operand)\n     }\n   return 0;\n }\n-\n+\f\n /* Emit a memory barrier around an atomic sequence according to MODEL.  */\n \n static void\n@@ -24945,6 +24999,515 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n \n   arm_post_atomic_barrier (model);\n }\n+\f\n+#define MAX_VECT_LEN 16\n \n-#include \"gt-arm.h\"\n+struct expand_vec_perm_d\n+{\n+  rtx target, op0, op1;\n+  unsigned char perm[MAX_VECT_LEN];\n+  enum machine_mode vmode;\n+  unsigned char nelt;\n+  bool one_vector_p;\n+  bool testing_p;\n+};\n+\n+/* Generate a variable permutation.  */\n+\n+static void\n+arm_expand_vec_perm_1 (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  enum machine_mode vmode = GET_MODE (target);\n+  bool one_vector_p = rtx_equal_p (op0, op1);\n \n+  gcc_checking_assert (vmode == V8QImode || vmode == V16QImode);\n+  gcc_checking_assert (GET_MODE (op0) == vmode);\n+  gcc_checking_assert (GET_MODE (op1) == vmode);\n+  gcc_checking_assert (GET_MODE (sel) == vmode);\n+  gcc_checking_assert (TARGET_NEON);\n+\n+  if (one_vector_p)\n+    {\n+      if (vmode == V8QImode)\n+\temit_insn (gen_neon_vtbl1v8qi (target, op0, sel));\n+      else\n+\temit_insn (gen_neon_vtbl1v16qi (target, op0, sel));\n+    }\n+  else\n+    {\n+      rtx pair;\n+\n+      if (vmode == V8QImode)\n+\t{\n+\t  pair = gen_reg_rtx (V16QImode);\n+\t  emit_insn (gen_neon_vcombinev8qi (pair, op0, op1));\n+\t  pair = gen_lowpart (TImode, pair);\n+\t  emit_insn (gen_neon_vtbl2v8qi (target, pair, sel));\n+\t}\n+      else\n+\t{\n+\t  pair = gen_reg_rtx (OImode);\n+\t  emit_insn (gen_neon_vcombinev16qi (pair, op0, op1));\n+\t  emit_insn (gen_neon_vtbl2v16qi (target, pair, sel));\n+\t}\n+    }\n+}\n+\n+void\n+arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  enum machine_mode vmode = GET_MODE (target);\n+  unsigned int i, nelt = GET_MODE_NUNITS (vmode);\n+  bool one_vector_p = rtx_equal_p (op0, op1);\n+  rtx rmask[MAX_VECT_LEN], mask;\n+\n+  /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n+     numbering of elements for big-endian, we must reverse the order.  */\n+  gcc_checking_assert (!BYTES_BIG_ENDIAN);\n+\n+  /* The VTBL instruction does not use a modulo index, so we must take care\n+     of that ourselves.  */\n+  mask = GEN_INT (one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+  for (i = 0; i < nelt; ++i)\n+    rmask[i] = mask;\n+  mask = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rmask));\n+  sel = expand_simple_binop (vmode, AND, sel, mask, NULL, 0, OPTAB_LIB_WIDEN);\n+\n+  arm_expand_vec_perm_1 (target, op0, op1, sel);\n+}\n+\n+/* Generate or test for an insn that supports a constant permutation.  */\n+\n+/* Recognize patterns for the VUZP insns.  */\n+\n+static bool\n+arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, odd, mask, nelt = d->nelt;\n+  rtx out0, out1, in0, in1, x;\n+  rtx (*gen)(rtx, rtx, rtx, rtx);\n+\n+  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n+  if (d->perm[0] == 0)\n+    odd = 0;\n+  else if (d->perm[0] == 1)\n+    odd = 1;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt; i++)\n+    {\n+      unsigned elt = (i * 2 + odd) & mask;\n+      if (d->perm[i] != elt)\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  switch (d->vmode)\n+    {\n+    case V16QImode: gen = gen_neon_vuzpv16qi_internal; break;\n+    case V8QImode:  gen = gen_neon_vuzpv8qi_internal;  break;\n+    case V8HImode:  gen = gen_neon_vuzpv8hi_internal;  break;\n+    case V4HImode:  gen = gen_neon_vuzpv4hi_internal;  break;\n+    case V4SImode:  gen = gen_neon_vuzpv4si_internal;  break;\n+    case V2SImode:  gen = gen_neon_vuzpv2si_internal;  break;\n+    case V2SFmode:  gen = gen_neon_vuzpv2sf_internal;  break;\n+    case V4SFmode:  gen = gen_neon_vuzpv4sf_internal;  break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      odd = !odd;\n+    }\n+\n+  out0 = d->target;\n+  out1 = gen_reg_rtx (d->vmode);\n+  if (odd)\n+    x = out0, out0 = out1, out1 = x;\n+\n+  emit_insn (gen (out0, in0, in1, out1));\n+  return true;\n+}\n+\n+/* Recognize patterns for the VZIP insns.  */\n+\n+static bool\n+arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, high, mask, nelt = d->nelt;\n+  rtx out0, out1, in0, in1, x;\n+  rtx (*gen)(rtx, rtx, rtx, rtx);\n+\n+  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n+  high = nelt / 2;\n+  if (d->perm[0] == high)\n+    ;\n+  else if (d->perm[0] == 0)\n+    high = 0;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt / 2; i++)\n+    {\n+      unsigned elt = (i + high) & mask;\n+      if (d->perm[i * 2] != elt)\n+\treturn false;\n+      elt = (elt + nelt) & mask;\n+      if (d->perm[i * 2 + 1] != elt)\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  switch (d->vmode)\n+    {\n+    case V16QImode: gen = gen_neon_vzipv16qi_internal; break;\n+    case V8QImode:  gen = gen_neon_vzipv8qi_internal;  break;\n+    case V8HImode:  gen = gen_neon_vzipv8hi_internal;  break;\n+    case V4HImode:  gen = gen_neon_vzipv4hi_internal;  break;\n+    case V4SImode:  gen = gen_neon_vzipv4si_internal;  break;\n+    case V2SImode:  gen = gen_neon_vzipv2si_internal;  break;\n+    case V2SFmode:  gen = gen_neon_vzipv2sf_internal;  break;\n+    case V4SFmode:  gen = gen_neon_vzipv4sf_internal;  break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      high = !high;\n+    }\n+\n+  out0 = d->target;\n+  out1 = gen_reg_rtx (d->vmode);\n+  if (high)\n+    x = out0, out0 = out1, out1 = x;\n+\n+  emit_insn (gen (out0, in0, in1, out1));\n+  return true;\n+}\n+\n+/* Recognize patterns for the VREV insns.  */\n+\n+static bool\n+arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, j, diff, nelt = d->nelt;\n+  rtx (*gen)(rtx, rtx, rtx);\n+\n+  if (!d->one_vector_p)\n+    return false;\n+\n+  diff = d->perm[0];\n+  switch (diff)\n+    {\n+    case 7:\n+      switch (d->vmode)\n+\t{\n+\tcase V16QImode: gen = gen_neon_vrev64v16qi; break;\n+\tcase V8QImode:  gen = gen_neon_vrev64v8qi;  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+    case 3:\n+      switch (d->vmode)\n+\t{\n+\tcase V16QImode: gen = gen_neon_vrev32v16qi; break;\n+\tcase V8QImode:  gen = gen_neon_vrev32v8qi;  break;\n+\tcase V8HImode:  gen = gen_neon_vrev64v8hi;  break;\n+\tcase V4HImode:  gen = gen_neon_vrev64v4hi;  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+    case 1:\n+      switch (d->vmode)\n+\t{\n+\tcase V16QImode: gen = gen_neon_vrev16v16qi; break;\n+\tcase V8QImode:  gen = gen_neon_vrev16v8qi;  break;\n+\tcase V8HImode:  gen = gen_neon_vrev32v8hi;  break;\n+\tcase V4HImode:  gen = gen_neon_vrev32v4hi;  break;\n+\tcase V4SImode:  gen = gen_neon_vrev64v4si;  break;\n+\tcase V2SImode:  gen = gen_neon_vrev64v2si;  break;\n+\tcase V4SFmode:  gen = gen_neon_vrev64v4sf;  break;\n+\tcase V2SFmode:  gen = gen_neon_vrev64v2sf;  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  for (i = 0; i < nelt; i += diff)\n+    for (j = 0; j <= diff; j += 1)\n+      if (d->perm[i + j] != i + diff - j)\n+\treturn false;\n+\n+  /* Success! */\n+  if (d->testing_p)\n+    return true;\n+\n+  /* ??? The third operand is an artifact of the builtin infrastructure\n+     and is ignored by the actual instruction.  */\n+  emit_insn (gen (d->target, d->op0, const0_rtx));\n+  return true;\n+}\n+\n+/* Recognize patterns for the VTRN insns.  */\n+\n+static bool\n+arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, odd, mask, nelt = d->nelt;\n+  rtx out0, out1, in0, in1, x;\n+  rtx (*gen)(rtx, rtx, rtx, rtx);\n+\n+  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n+  if (d->perm[0] == 0)\n+    odd = 0;\n+  else if (d->perm[0] == 1)\n+    odd = 1;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt; i += 2)\n+    {\n+      if (d->perm[i] != i + odd)\n+\treturn false;\n+      if (d->perm[i + 1] != ((i + nelt + odd) & mask))\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  switch (d->vmode)\n+    {\n+    case V16QImode: gen = gen_neon_vtrnv16qi_internal; break;\n+    case V8QImode:  gen = gen_neon_vtrnv8qi_internal;  break;\n+    case V8HImode:  gen = gen_neon_vtrnv8hi_internal;  break;\n+    case V4HImode:  gen = gen_neon_vtrnv4hi_internal;  break;\n+    case V4SImode:  gen = gen_neon_vtrnv4si_internal;  break;\n+    case V2SImode:  gen = gen_neon_vtrnv2si_internal;  break;\n+    case V2SFmode:  gen = gen_neon_vtrnv2sf_internal;  break;\n+    case V4SFmode:  gen = gen_neon_vtrnv4sf_internal;  break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      odd = !odd;\n+    }\n+\n+  out0 = d->target;\n+  out1 = gen_reg_rtx (d->vmode);\n+  if (odd)\n+    x = out0, out0 = out1, out1 = x;\n+\n+  emit_insn (gen (out0, in0, in1, out1));\n+  return true;\n+}\n+\n+/* The NEON VTBL instruction is a fully variable permuation that's even\n+   stronger than what we expose via VEC_PERM_EXPR.  What it doesn't do\n+   is mask the index operand as VEC_PERM_EXPR requires.  Therefore we\n+   can do slightly better by expanding this as a constant where we don't\n+   have to apply a mask.  */\n+\n+static bool\n+arm_evpc_neon_vtbl (struct expand_vec_perm_d *d)\n+{\n+  rtx rperm[MAX_VECT_LEN], sel;\n+  enum machine_mode vmode = d->vmode;\n+  unsigned int i, nelt = d->nelt;\n+\n+  /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n+     numbering of elements for big-endian, we must reverse the order.  */\n+  if (BYTES_BIG_ENDIAN)\n+    return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  /* Generic code will try constant permutation twice.  Once with the\n+     original mode and again with the elements lowered to QImode.\n+     So wait and don't do the selector expansion ourselves.  */\n+  if (vmode != V8QImode && vmode != V16QImode)\n+    return false;\n+\n+  for (i = 0; i < nelt; ++i)\n+    rperm[i] = GEN_INT (d->perm[i]);\n+  sel = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rperm));\n+  sel = force_reg (vmode, sel);\n+\n+  arm_expand_vec_perm_1 (d->target, d->op0, d->op1, sel);\n+  return true;\n+}\n+\n+static bool\n+arm_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n+{\n+  /* The pattern matching functions above are written to look for a small\n+     number to begin the sequence (0, 1, N/2).  If we begin with an index\n+     from the second operand, we can swap the operands.  */\n+  if (d->perm[0] >= d->nelt)\n+    {\n+      unsigned i, nelt = d->nelt;\n+      rtx x;\n+\n+      for (i = 0; i < nelt; ++i)\n+\td->perm[i] = (d->perm[i] + nelt) & (2 * nelt - 1);\n+\n+      x = d->op0;\n+      d->op0 = d->op1;\n+      d->op1 = x;\n+    }\n+\n+  if (TARGET_NEON)\n+    {\n+      if (arm_evpc_neon_vuzp (d))\n+\treturn true;\n+      if (arm_evpc_neon_vzip (d))\n+\treturn true;\n+      if (arm_evpc_neon_vrev (d))\n+\treturn true;\n+      if (arm_evpc_neon_vtrn (d))\n+\treturn true;\n+      return arm_evpc_neon_vtbl (d);\n+    }\n+  return false;\n+}\n+\n+/* Expand a vec_perm_const pattern.  */\n+\n+bool\n+arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  struct expand_vec_perm_d d;\n+  int i, nelt, which;\n+\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n+\n+  d.vmode = GET_MODE (target);\n+  gcc_assert (VECTOR_MODE_P (d.vmode));\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = false;\n+\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      rtx e = XVECEXP (sel, 0, i);\n+      int ei = INTVAL (e) & (2 * nelt - 1);\n+      which |= (ei < nelt ? 1 : 2);\n+      d.perm[i] = ei;\n+    }\n+\n+  switch (which)\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case 3:\n+      d.one_vector_p = false;\n+      if (!rtx_equal_p (op0, op1))\n+\tbreak;\n+\n+      /* The elements of PERM do not suggest that only the first operand\n+\t is used, but both operands are identical.  Allow easier matching\n+\t of the permutation by folding the permutation into the single\n+\t input vector.  */\n+      /* FALLTHRU */\n+    case 2:\n+      for (i = 0; i < nelt; ++i)\n+        d.perm[i] &= nelt - 1;\n+      d.op0 = op1;\n+      d.one_vector_p = true;\n+      break;\n+\n+    case 1:\n+      d.op1 = op0;\n+      d.one_vector_p = true;\n+      break;\n+    }\n+\n+  return arm_expand_vec_perm_const_1 (&d);\n+}\n+\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n+\n+static bool\n+arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t const unsigned char *sel)\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned int i, nelt, which;\n+  bool ret;\n+\n+  d.vmode = vmode;\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = true;\n+  memcpy (d.perm, sel, nelt);\n+\n+  /* Categorize the set of elements in the selector.  */\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      unsigned char e = d.perm[i];\n+      gcc_assert (e < 2 * nelt);\n+      which |= (e < nelt ? 1 : 2);\n+    }\n+\n+  /* For all elements from second vector, fold the elements to first.  */\n+  if (which == 2)\n+    for (i = 0; i < nelt; ++i)\n+      d.perm[i] -= nelt;\n+\n+  /* Check whether the mask can be applied to the vector type.  */\n+  d.one_vector_p = (which != 3);\n+\n+  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+  if (!d.one_vector_p)\n+    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+  start_sequence ();\n+  ret = arm_expand_vec_perm_const_1 (&d);\n+  end_sequence ();\n+\n+  return ret;\n+}\n+\n+\f\n+#include \"gt-arm.h\""}, {"sha": "24a15802bc35936dcfd39c0e06444840c91cbf03", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 104, "deletions": 40, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=b440f32451e63beab306ec5cffba4c7ca3e85f97", "patch": "@@ -1,5 +1,6 @@\n ;; ARM NEON coprocessor Machine Description\n-;; Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+;; Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012\n+;;   Free Software Foundation, Inc.\n ;; Written by CodeSourcery.\n ;;\n ;; This file is part of GCC.\n@@ -35,6 +36,7 @@\n   UNSPEC_VCGE\n   UNSPEC_VCGT\n   UNSPEC_VCLS\n+  UNSPEC_VCONCAT\n   UNSPEC_VCVT\n   UNSPEC_VCVT_N\n   UNSPEC_VEXT\n@@ -2860,55 +2862,40 @@\n   DONE;\n })\n \n+; Disabled before reload because we don't want combine doing something silly,\n+; but used by the post-reload expansion of neon_vcombine.\n+(define_insn \"*neon_vswp<mode>\"\n+  [(set (match_operand:VDQX 0 \"s_register_operand\" \"+w\")\n+\t(match_operand:VDQX 1 \"s_register_operand\" \"+w\"))\n+   (set (match_dup 1) (match_dup 0))]\n+  \"TARGET_NEON && reload_completed\"\n+  \"vswp\\t%<V_reg>1, %<V_reg>2\"\n+  [(set (attr \"neon_type\")\n+\t(if_then_else (match_test \"<Is_d_reg>\")\n+\t\t      (const_string \"neon_bp_simple\")\n+\t\t      (const_string \"neon_bp_2cycle\")))]\n+)\n+\n ;; In this insn, operand 1 should be low, and operand 2 the high part of the\n ;; dest vector.\n ;; FIXME: A different implementation of this builtin could make it much\n ;; more likely that we wouldn't actually need to output anything (we could make\n ;; it so that the reg allocator puts things in the right places magically\n ;; instead). Lack of subregs for vectors makes that tricky though, I think.\n \n-(define_insn \"neon_vcombine<mode>\"\n+(define_insn_and_split \"neon_vcombine<mode>\"\n   [(set (match_operand:<V_DOUBLE> 0 \"s_register_operand\" \"=w\")\n-        (vec_concat:<V_DOUBLE> (match_operand:VDX 1 \"s_register_operand\" \"w\")\n-\t\t\t       (match_operand:VDX 2 \"s_register_operand\" \"w\")))]\n+        (vec_concat:<V_DOUBLE>\n+\t  (match_operand:VDX 1 \"s_register_operand\" \"w\")\n+\t  (match_operand:VDX 2 \"s_register_operand\" \"w\")))]\n   \"TARGET_NEON\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n {\n-  int dest = REGNO (operands[0]);\n-  int src1 = REGNO (operands[1]);\n-  int src2 = REGNO (operands[2]);\n-  rtx destlo;\n-\n-  if (src1 == dest && src2 == dest + 2)\n-    return \"\";\n-  else if (src2 == dest && src1 == dest + 2)\n-    /* Special case of reversed high/low parts.  */\n-    return \"vswp\\t%P1, %P2\";\n-\n-  destlo = gen_rtx_REG (<MODE>mode, dest);\n-\n-  if (!reg_overlap_mentioned_p (operands[2], destlo))\n-    {\n-      /* Try to avoid unnecessary moves if part of the result is in the right\n-         place already.  */\n-      if (src1 != dest)\n-        output_asm_insn (\"vmov\\t%e0, %P1\", operands);\n-      if (src2 != dest + 2)\n-        output_asm_insn (\"vmov\\t%f0, %P2\", operands);\n-    }\n-  else\n-    {\n-      if (src2 != dest + 2)\n-        output_asm_insn (\"vmov\\t%f0, %P2\", operands);\n-      if (src1 != dest)\n-        output_asm_insn (\"vmov\\t%e0, %P1\", operands);\n-    }\n-\n-  return \"\";\n-}\n-  ;; We set the neon_type attribute based on the vmov instructions above.\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"neon_type\" \"neon_bp_simple\")]\n-)\n+  neon_split_vcombine (operands);\n+  DONE;\n+})\n \n (define_expand \"neon_vget_high<mode>\"\n   [(match_operand:<V_HALF> 0 \"s_register_operand\")\n@@ -3920,6 +3907,83 @@\n   [(set_attr \"neon_type\" \"neon_bp_3cycle\")]\n )\n \n+;; These three are used by the vec_perm infrastructure for V16QImode.\n+(define_insn_and_split \"neon_vtbl1v16qi\"\n+  [(set (match_operand:V16QI 0 \"s_register_operand\" \"=&w\")\n+\t(unspec:V16QI [(match_operand:V16QI 1 \"s_register_operand\" \"w\")\n+\t\t       (match_operand:V16QI 2 \"s_register_operand\" \"w\")]\n+\t\t      UNSPEC_VTBL))]\n+  \"TARGET_NEON\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0, op1, op2, part0, part2;\n+  unsigned ofs;\n+\n+  op0 = operands[0];\n+  op1 = gen_lowpart (TImode, operands[1]);\n+  op2 = operands[2];\n+\n+  ofs = subreg_lowpart_offset (V8QImode, V16QImode);\n+  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n+  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n+  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n+\n+  ofs = subreg_highpart_offset (V8QImode, V16QImode);\n+  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n+  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n+  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"neon_vtbl2v16qi\"\n+  [(set (match_operand:V16QI 0 \"s_register_operand\" \"=&w\")\n+\t(unspec:V16QI [(match_operand:OI 1 \"s_register_operand\" \"w\")\n+\t\t       (match_operand:V16QI 2 \"s_register_operand\" \"w\")]\n+\t\t      UNSPEC_VTBL))]\n+  \"TARGET_NEON\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0, op1, op2, part0, part2;\n+  unsigned ofs;\n+\n+  op0 = operands[0];\n+  op1 = operands[1];\n+  op2 = operands[2];\n+\n+  ofs = subreg_lowpart_offset (V8QImode, V16QImode);\n+  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n+  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n+  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n+\n+  ofs = subreg_highpart_offset (V8QImode, V16QImode);\n+  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n+  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n+  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n+  DONE;\n+})\n+\n+;; ??? Logically we should extend the regular neon_vcombine pattern to\n+;; handle quad-word input modes, producing octa-word output modes.  But\n+;; that requires us to add support for octa-word vector modes in moves.\n+;; That seems overkill for this one use in vec_perm.\n+(define_insn_and_split \"neon_vcombinev16qi\"\n+  [(set (match_operand:OI 0 \"s_register_operand\" \"=w\")\n+\t(unspec:OI [(match_operand:V16QI 1 \"s_register_operand\" \"w\")\n+\t\t    (match_operand:V16QI 2 \"s_register_operand\" \"w\")]\n+\t\t   UNSPEC_VCONCAT))]\n+  \"TARGET_NEON\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  neon_split_vcombine (operands);\n+  DONE;\n+})\n+\n (define_insn \"neon_vtbx1v8qi\"\n   [(set (match_operand:V8QI 0 \"s_register_operand\" \"=w\")\n \t(unspec:V8QI [(match_operand:V8QI 1 \"s_register_operand\" \"0\")"}, {"sha": "4d903bd80fe894bcd9feca30f176dc04c5f0d9f0", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=b440f32451e63beab306ec5cffba4c7ca3e85f97", "patch": "@@ -1,5 +1,5 @@\n ;; Machine Description for shared bits common to IWMMXT and Neon.\n-;; Copyright (C) 2006, 2007, 2010 Free Software Foundation, Inc.\n+;; Copyright (C) 2006, 2007, 2010, 2012 Free Software Foundation, Inc.\n ;; Written by CodeSourcery.\n ;;\n ;; This file is part of GCC.\n@@ -108,3 +108,29 @@\n    || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n {\n })\n+\n+(define_expand \"vec_perm_const<mode>\"\n+  [(match_operand:VALL 0 \"s_register_operand\" \"\")\n+   (match_operand:VALL 1 \"s_register_operand\" \"\")\n+   (match_operand:VALL 2 \"s_register_operand\" \"\")\n+   (match_operand:<V_cmp_result> 3 \"\" \"\")]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+  if (arm_expand_vec_perm_const (operands[0], operands[1],\n+\t\t\t\t operands[2], operands[3]))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"vec_perm<mode>\"\n+  [(match_operand:VE 0 \"s_register_operand\" \"\")\n+   (match_operand:VE 1 \"s_register_operand\" \"\")\n+   (match_operand:VE 2 \"s_register_operand\" \"\")\n+   (match_operand:VE 3 \"s_register_operand\" \"\")]\n+  \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+{\n+  arm_expand_vec_perm (operands[0], operands[1], operands[2], operands[3]);\n+  DONE;\n+})"}, {"sha": "aa61ed40efa2b8d375f2e535f4aa1afaab1e6652", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b440f32451e63beab306ec5cffba4c7ca3e85f97", "patch": "@@ -1,3 +1,9 @@\n+2012-01-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_perm,\n+\tcheck_effective_target_vect_perm_byte,\n+\tcheck_effective_target_vect_perm_short): Enable for arm neon.\n+\n 2012-01-09  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/46328"}, {"sha": "9f2d7bae863de4b351f2351c4277b9b8939b9be5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b440f32451e63beab306ec5cffba4c7ca3e85f97/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b440f32451e63beab306ec5cffba4c7ca3e85f97", "patch": "@@ -1,5 +1,5 @@\n #   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-#   2011 Free Software Foundation, Inc.\n+#   2011, 2012 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -2733,7 +2733,8 @@ proc check_effective_target_vect_perm { } {\n         verbose \"check_effective_target_vect_perm: using cached result\" 2\n     } else {\n         set et_vect_perm_saved 0\n-        if { [istarget powerpc*-*-*]\n+        if { [is-effective-target arm_neon_ok]\n+\t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*] } {\n@@ -2756,7 +2757,8 @@ proc check_effective_target_vect_perm_byte { } {\n         verbose \"check_effective_target_vect_perm_byte: using cached result\" 2\n     } else {\n         set et_vect_perm_byte_saved 0\n-        if { [istarget powerpc*-*-*]\n+        if { [is-effective-target arm_neon_ok]\n+\t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n             set et_vect_perm_byte_saved 1\n         }\n@@ -2777,7 +2779,8 @@ proc check_effective_target_vect_perm_short { } {\n         verbose \"check_effective_target_vect_perm_short: using cached result\" 2\n     } else {\n         set et_vect_perm_short_saved 0\n-        if { [istarget powerpc*-*-*]\n+        if { [is-effective-target arm_neon_ok]\n+\t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n             set et_vect_perm_short_saved 1\n         }"}]}