{"sha": "c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ0OWQzYWUyOGZmNGUxMzMxMTRmYjY3ZGJmN2RjYzdhOTVjYTVkNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-19T13:33:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-19T13:33:55Z"}, "message": "Enforce correct COND_EXPR order for EXTRACT_LAST_REDUCTION\n\nFor conditional reductions, the \"then\" value needs to be the candidate\nvalue calculated by this iteration while the \"else\" value needs to be\nthe result carried over from previous iterations.  If the COND_EXPR\nis the other way around, we need to swap it.\n\n2019-09-19  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vectorizable_condition): Take an int\n\treduction index instead of a boolean flag.\n\t* tree-vect-stmts.c (vectorizable_condition): Likewise.\n\tSwap the \"then\" and \"else\" values for EXTRACT_LAST_REDUCTION\n\treductions if the reduction accumulator is the \"then\" rather\n\tthan the \"else\" value.\n\t(vect_analyze_stmt): Update call accordingly.\n\t(vect_transform_stmt): Likewise.\n\t* tree-vect-loop.c (vectorizable_reduction): Likewise,\n\tasserting that the index is > 0.\n\nFrom-SVN: r275962", "tree": {"sha": "12ab56e51ea7fe069d7e8ffa1c0b6e41ea5252ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12ab56e51ea7fe069d7e8ffa1c0b6e41ea5252ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37bc3aa0474f21b7a678b09951634de3205d014e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bc3aa0474f21b7a678b09951634de3205d014e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37bc3aa0474f21b7a678b09951634de3205d014e"}], "stats": {"total": 67, "additions": 57, "deletions": 10}, "files": [{"sha": "506e93d757ca7bf218045eef572107c0bc9d4966", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "patch": "@@ -1,3 +1,16 @@\n+2019-09-19  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vectorizable_condition): Take an int\n+\treduction index instead of a boolean flag.\n+\t* tree-vect-stmts.c (vectorizable_condition): Likewise.\n+\tSwap the \"then\" and \"else\" values for EXTRACT_LAST_REDUCTION\n+\treductions if the reduction accumulator is the \"then\" rather\n+\tthan the \"else\" value.\n+\t(vect_analyze_stmt): Update call accordingly.\n+\t(vect_transform_stmt): Likewise.\n+\t* tree-vect-loop.c (vectorizable_reduction): Likewise,\n+\tasserting that the index is > 0.\n+\n 2019-09-19  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-icf.c (sort_sem_items_by_decl_uid): Simplify comparator."}, {"sha": "aec44622e03c34701b912cefeec10b4b1abb42c8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "patch": "@@ -6659,8 +6659,9 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     {\n       /* Only call during the analysis stage, otherwise we'll lose\n \t STMT_VINFO_TYPE.  */\n+      gcc_assert (reduc_index > 0);\n       if (!vec_stmt && !vectorizable_condition (stmt_info, gsi, NULL,\n-\t\t\t\t\t\ttrue, NULL, cost_vec))\n+\t\t\t\t\t\treduc_index, NULL, cost_vec))\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -7113,9 +7114,9 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   if (reduction_type == EXTRACT_LAST_REDUCTION)\n     {\n-      gcc_assert (!slp_node);\n+      gcc_assert (!slp_node && reduc_index > 0);\n       return vectorizable_condition (stmt_info, gsi, vec_stmt,\n-\t\t\t\t     true, NULL, NULL);\n+\t\t\t\t     reduc_index, NULL, NULL);\n     }\n \n   /* Create the destination vector  */\n@@ -7145,9 +7146,9 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     {\n       if (code == COND_EXPR)\n         {\n-          gcc_assert (!slp_node);\n+          gcc_assert (!slp_node && reduc_index > 0);\n \t  vectorizable_condition (stmt_info, gsi, vec_stmt,\n-\t\t\t\t  true, NULL, NULL);\n+\t\t\t\t  reduc_index, NULL, NULL);\n           break;\n         }\n       if (code == LSHIFT_EXPR"}, {"sha": "0636e5c9ffa08b0e62cdf0f5d7d1bb775b716e37", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "patch": "@@ -9778,7 +9778,7 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n \n bool\n vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\tstmt_vec_info *vec_stmt, bool for_reduction,\n+\t\t\tstmt_vec_info *vec_stmt, int reduc_index,\n \t\t\tslp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   vec_info *vinfo = stmt_info->vinfo;\n@@ -9807,6 +9807,7 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   vec<tree> vec_oprnds3 = vNULL;\n   tree vec_cmp_type;\n   bool masked = false;\n+  bool for_reduction = (reduc_index > 0);\n \n   if (for_reduction && STMT_SLP_TYPE (stmt_info))\n     return false;\n@@ -9888,6 +9889,29 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       cond_expr1 = TREE_OPERAND (cond_expr, 1);\n     }\n \n+  /* For conditional reductions, the \"then\" value needs to be the candidate\n+     value calculated by this iteration while the \"else\" value needs to be\n+     the result carried over from previous iterations.  If the COND_EXPR\n+     is the other way around, we need to swap it.  */\n+  bool must_invert_cmp_result = false;\n+  if (reduction_type == EXTRACT_LAST_REDUCTION && reduc_index == 1)\n+    {\n+      if (masked)\n+\tmust_invert_cmp_result = true;\n+      else\n+\t{\n+\t  bool honor_nans = HONOR_NANS (TREE_TYPE (cond_expr0));\n+\t  tree_code new_code = invert_tree_comparison (cond_code, honor_nans);\n+\t  if (new_code == ERROR_MARK)\n+\t    must_invert_cmp_result = true;\n+\t  else\n+\t    cond_code = new_code;\n+\t}\n+      /* Make sure we don't accidentally use the old condition.  */\n+      cond_expr = NULL_TREE;\n+      std::swap (then_clause, else_clause);\n+    }\n+\n   if (!masked && VECTOR_BOOLEAN_TYPE_P (comp_vectype))\n     {\n       /* Boolean values may have another representation in vectors\n@@ -10102,6 +10126,15 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t  vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \t\t  vec_compare = vec_compare_name;\n \t\t}\n+\t      if (must_invert_cmp_result)\n+\t\t{\n+\t\t  tree vec_compare_name = make_ssa_name (vec_cmp_type);\n+\t\t  gassign *new_stmt = gimple_build_assign (vec_compare_name,\n+\t\t\t\t\t\t\t   BIT_NOT_EXPR,\n+\t\t\t\t\t\t\t   vec_compare);\n+\t\t  vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n+\t\t  vec_compare = vec_compare_name;\n+\t\t}\n \t      gcall *new_stmt = gimple_build_call_internal\n \t\t(IFN_FOLD_EXTRACT_LAST, 3, else_clause, vec_compare,\n \t\t vec_then_clause);\n@@ -10635,7 +10668,7 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t\t\t\t     node_instance, cost_vec)\n \t  || vectorizable_induction (stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_shift (stmt_info, NULL, NULL, node, cost_vec)\n-\t  || vectorizable_condition (stmt_info, NULL, NULL, false, node,\n+\t  || vectorizable_condition (stmt_info, NULL, NULL, 0, node,\n \t\t\t\t     cost_vec)\n \t  || vectorizable_comparison (stmt_info, NULL, NULL, node,\n \t\t\t\t      cost_vec));\n@@ -10654,7 +10687,7 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t      || vectorizable_load (stmt_info, NULL, NULL, node, node_instance,\n \t\t\t\t    cost_vec)\n \t      || vectorizable_store (stmt_info, NULL, NULL, node, cost_vec)\n-\t      || vectorizable_condition (stmt_info, NULL, NULL, false, node,\n+\t      || vectorizable_condition (stmt_info, NULL, NULL, 0, node,\n \t\t\t\t\t cost_vec)\n \t      || vectorizable_comparison (stmt_info, NULL, NULL, node,\n \t\t\t\t\t  cost_vec));\n@@ -10759,7 +10792,7 @@ vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       break;\n \n     case condition_vec_info_type:\n-      done = vectorizable_condition (stmt_info, gsi, &vec_stmt, false,\n+      done = vectorizable_condition (stmt_info, gsi, &vec_stmt, 0,\n \t\t\t\t     slp_node, NULL);\n       gcc_assert (done);\n       break;"}, {"sha": "aef0ff8663c7c19d20b0a6adfd7a5d19be2cfae9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "patch": "@@ -1534,7 +1534,7 @@ extern void vect_remove_stores (stmt_vec_info);\n extern opt_result vect_analyze_stmt (stmt_vec_info, bool *, slp_tree,\n \t\t\t\t     slp_instance, stmt_vector_for_cost *);\n extern bool vectorizable_condition (stmt_vec_info, gimple_stmt_iterator *,\n-\t\t\t\t    stmt_vec_info *, bool, slp_tree,\n+\t\t\t\t    stmt_vec_info *, int, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n extern bool vectorizable_shift (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\tstmt_vec_info *, slp_tree,"}]}