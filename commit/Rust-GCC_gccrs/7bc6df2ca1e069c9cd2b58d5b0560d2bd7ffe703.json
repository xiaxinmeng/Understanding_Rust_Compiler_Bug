{"sha": "7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JjNmRmMmNhMWUwNjljOWNkMmI1OGQ1YjA1NjBkMmJkN2ZmZTcwMw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-11-18T16:44:00Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-11-18T16:44:00Z"}, "message": "re PR target/49868 (Implement named address space to place/access data in flash memory)\n\ngcc/\n\tPR target/49868\n\t* config/avr/avr.h (base_arch_s): Add field n_segments.\n\t(ADDR_SPACE_PGM1, ADDR_SPACE_PGM2, ADDR_SPACE_PGM3,\n\tADDR_SPACE_PGM4, ADDR_SPACE_PGM5, ADDR_SPACE_PGMX): New address spaces.\n\t(AVR_HAVE_ELPM, AVR_HAVE_ELPMX): New defines.\n\t(INIT_EXPANDERS): New define.\n\t* config/avr/avr-protos.h (avr_mem_pgmx_p): New.\n\t(avr_init_expanders): New.\n\t(avr_emit_movmemhi, avr_out_movmem): New.\n\t(avr_xload_libgcc_p): New.\n\t* config/avr/avr-c.c (avr_register_target_pragmas): Register\n\taddress spaces __pgm1, __pgm2,  __pgm3,  __pgm4  __pgm5,  __pgmx.\n\t(avr_cpu_cpp_builtins): Add built-in defines __PGM1,\n\t__PGM2, __PGM3, __PGM4, __PGM5, __PGMX.\n\t* config/avr/avr-devices.c (avr_arch_types): Set field n_segments.\n\n\t* config/avr/avr.c (AVR_SECTION_PROGMEM): Change define to cover\n\t3 bits instead of just 1.\n\t(xstring_empty, xstring_e, rampz_rtx): New static GTYed variables.\n\t(progmem_section): Change from section to array of sections.\n\t(progmem_section_prefix): New static variable.\n\t(avr_file_start): Print set for __RAMPZ__\n\t(avr_option_override): Move initialization of RTXes from here...\n\t(avr_init_expanders): ...to this new function.\n\t(avr_pgm_segment): New static function.\n\t(avr_decl_pgm_p): Handle error_mark_node.\n\t(avr_mem_pgmx_p, avr_decl_pgmx_p): New static functions.\n\t(avr_out_xload,\tavr_find_unused_d_reg): New static functions.\n\t(expand_prologue, expand_epilogue): Use rampz_rtx.\n\t(print_operand): Hande CONST_STRING.\n\t(avr_xload_libgcc_p): New static function.\n\t(avr_out_lpm_no_lpmx, avr_out_lpm): Handle ELPM.\n\t(avr_progmem_p): Return 2 for 24-bit flash address space.\n\t(avr_out_sbxx_branch): Clean-up code from ASn macros.\n\t(out_movqi_r_mr, out_movqi_mr_r): Ditto. And recognize RAMPZ's\n\taddress and print symbolically.\n\t(avr_asm_named_section, avr_section_type_flags,\n\tavr_encode_section_info, avr_asm_select_section,\n\tavr_addr_space_address_mode, avr_addr_space_pointer_mode,\n\tavr_addr_space_legitimate_address_p, avr_addr_space_convert,\n\tavr_addr_space_legitimize_address): Handle new address spaces.\n\t(avr_output_progmem_section_asm_op): New static function.\n\t(avr_asm_init_sections): Initialize progmem_section[].\n\t(adjust_insn_length): Handle ADJUST_LEN_XLOAD, ADJUST_LEN_MOVMEM.\n\t(avr_const_address_lo16): New static function.\n\t(avr_assemble_integer): Use it to handle 3-byte integers.\n\t(avr_emit_movmemhi, avr_out_movmem): New functions.\n\t\n\t* config/avr/predicates.md (nox_general_operand): Handle new\n\taddress spaces.\n\t* config/avr/avr.md (unspec): Add UNSPEC_MOVMEM.\n\t(adjust_len): Add xload, movmem.\n\t(SP_ADDR): New define_constants.\n\t(isa): Add \"lpm\", \"lpmx\", \"elpm\", \"elpmx\".\n\t(enabled): Handle them.\n\t(load<mode>_libgcc): New expander.\n\t(*load.<mode>.libgcc): Rename to load_<mode>_libgcc.\n\t(xload8_A, xload<mode>_A): New insn-and-splits.\n\t(xload_8, xload_<mode>_libgcc, xload_<mode>, loadmem_elpm): New insns.\n\t(mov<mode>): Handle new address spaces.\n\t(movmemhi): Rewrite using avr_emit_movmemhi.\n\t(MOVMEM_r_d): New mode attribute.\n\t(movmem_<mode>, movmem_qi_elpm): New insns.\n\t(setmemhi, *clrmemqi, *clrmemhi, strlenhi, *strlenhi): Unquote\n\tC-code.  Use label instead of hard-coded instrunction lengths.\n\t\nlibgcc/\n\tPR target/49868\n\t* config/avr/t-avr (LIB1ASMFUNCS): Add _xload_2 _xload_3 _xload_4.\n\t* config/avr/lib1funcs.S (__xload_2, __xload_3, __xload_4):\n\tNew functions.\n\nFrom-SVN: r181482", "tree": {"sha": "ef22897c6f94d5a785ffecb11a0779bdd6138771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef22897c6f94d5a785ffecb11a0779bdd6138771"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59659b596734466dd182fa99b0a189ca7c376129", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59659b596734466dd182fa99b0a189ca7c376129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59659b596734466dd182fa99b0a189ca7c376129"}], "stats": {"total": 1840, "additions": 1445, "deletions": 395}, "files": [{"sha": "57bba242ad32f7430fe990454f7cae29d42dd16a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -1,3 +1,71 @@\n+2011-11-18  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\t* config/avr/avr.h (base_arch_s): Add field n_segments.\n+\t(ADDR_SPACE_PGM1, ADDR_SPACE_PGM2, ADDR_SPACE_PGM3,\n+\tADDR_SPACE_PGM4, ADDR_SPACE_PGM5, ADDR_SPACE_PGMX): New address spaces.\n+\t(AVR_HAVE_ELPM, AVR_HAVE_ELPMX): New defines.\n+\t(INIT_EXPANDERS): New define.\n+\t* config/avr/avr-protos.h (avr_mem_pgmx_p): New.\n+\t(avr_init_expanders): New.\n+\t(avr_emit_movmemhi, avr_out_movmem): New.\n+\t(avr_xload_libgcc_p): New.\n+\t* config/avr/avr-c.c (avr_register_target_pragmas): Register\n+\taddress spaces __pgm1, __pgm2,  __pgm3,  __pgm4  __pgm5,  __pgmx.\n+\t(avr_cpu_cpp_builtins): Add built-in defines __PGM1,\n+\t__PGM2, __PGM3, __PGM4, __PGM5, __PGMX.\n+\t* config/avr/avr-devices.c (avr_arch_types): Set field n_segments.\n+\n+\t* config/avr/avr.c (AVR_SECTION_PROGMEM): Change define to cover\n+\t3 bits instead of just 1.\n+\t(xstring_empty, xstring_e, rampz_rtx): New static GTYed variables.\n+\t(progmem_section): Change from section to array of sections.\n+\t(progmem_section_prefix): New static variable.\n+\t(avr_file_start): Print set for __RAMPZ__\n+\t(avr_option_override): Move initialization of RTXes from here...\n+\t(avr_init_expanders): ...to this new function.\n+\t(avr_pgm_segment): New static function.\n+\t(avr_decl_pgm_p): Handle error_mark_node.\n+\t(avr_mem_pgmx_p, avr_decl_pgmx_p): New static functions.\n+\t(avr_out_xload,\tavr_find_unused_d_reg): New static functions.\n+\t(expand_prologue, expand_epilogue): Use rampz_rtx.\n+\t(print_operand): Hande CONST_STRING.\n+\t(avr_xload_libgcc_p): New static function.\n+\t(avr_out_lpm_no_lpmx, avr_out_lpm): Handle ELPM.\n+\t(avr_progmem_p): Return 2 for 24-bit flash address space.\n+\t(avr_out_sbxx_branch): Clean-up code from ASn macros.\n+\t(out_movqi_r_mr, out_movqi_mr_r): Ditto. And recognize RAMPZ's\n+\taddress and print symbolically.\n+\t(avr_asm_named_section, avr_section_type_flags,\n+\tavr_encode_section_info, avr_asm_select_section,\n+\tavr_addr_space_address_mode, avr_addr_space_pointer_mode,\n+\tavr_addr_space_legitimate_address_p, avr_addr_space_convert,\n+\tavr_addr_space_legitimize_address): Handle new address spaces.\n+\t(avr_output_progmem_section_asm_op): New static function.\n+\t(avr_asm_init_sections): Initialize progmem_section[].\n+\t(adjust_insn_length): Handle ADJUST_LEN_XLOAD, ADJUST_LEN_MOVMEM.\n+\t(avr_const_address_lo16): New static function.\n+\t(avr_assemble_integer): Use it to handle 3-byte integers.\n+\t(avr_emit_movmemhi, avr_out_movmem): New functions.\n+\t\n+\t* config/avr/predicates.md (nox_general_operand): Handle new\n+\taddress spaces.\n+\t* config/avr/avr.md (unspec): Add UNSPEC_MOVMEM.\n+\t(adjust_len): Add xload, movmem.\n+\t(SP_ADDR): New define_constants.\n+\t(isa): Add \"lpm\", \"lpmx\", \"elpm\", \"elpmx\".\n+\t(enabled): Handle them.\n+\t(load<mode>_libgcc): New expander.\n+\t(*load.<mode>.libgcc): Rename to load_<mode>_libgcc.\n+\t(xload8_A, xload<mode>_A): New insn-and-splits.\n+\t(xload_8, xload_<mode>_libgcc, xload_<mode>, loadmem_elpm): New insns.\n+\t(mov<mode>): Handle new address spaces.\n+\t(movmemhi): Rewrite using avr_emit_movmemhi.\n+\t(MOVMEM_r_d): New mode attribute.\n+\t(movmem_<mode>, movmem_qi_elpm): New insns.\n+\t(setmemhi, *clrmemqi, *clrmemhi, strlenhi, *strlenhi): Unquote\n+\tC-code.  Use label instead of hard-coded instrunction lengths.\n+\n 2011-11-18  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/50605"}, {"sha": "5fbc51cc70dfdb2832a4c2c8c9576262a8e25ccb", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -37,6 +37,12 @@ void\n avr_register_target_pragmas (void)\n {\n   c_register_addr_space (\"__pgm\", ADDR_SPACE_PGM);\n+  c_register_addr_space (\"__pgm1\", ADDR_SPACE_PGM1);\n+  c_register_addr_space (\"__pgm2\", ADDR_SPACE_PGM2);\n+  c_register_addr_space (\"__pgm3\", ADDR_SPACE_PGM3);\n+  c_register_addr_space (\"__pgm4\", ADDR_SPACE_PGM4);\n+  c_register_addr_space (\"__pgm5\", ADDR_SPACE_PGM5);\n+  c_register_addr_space (\"__pgmx\", ADDR_SPACE_PGMX);\n }\n \n \n@@ -109,6 +115,12 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   if (!strcmp (lang_hooks.name, \"GNU C\"))\n     {\n       cpp_define (pfile, \"__PGM=__pgm\");\n+      cpp_define (pfile, \"__PGM1=__pgm1\");\n+      cpp_define (pfile, \"__PGM2=__pgm2\");\n+      cpp_define (pfile, \"__PGM3=__pgm3\");\n+      cpp_define (pfile, \"__PGM4=__pgm4\");\n+      cpp_define (pfile, \"__PGM5=__pgm5\");\n+      cpp_define (pfile, \"__PGMX=__pgmx\");\n     }\n \n   /* Define builtin macros so that the user can"}, {"sha": "e0e473833360df665851f99bb21af61bb4f6c85b", "filename": "gcc/config/avr/avr-devices.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr-devices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr-devices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-devices.c?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -25,18 +25,27 @@\n \n /* List of all known AVR MCU architectures.  */\n \n-const struct base_arch_s avr_arch_types[] = {\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, NULL,               \"avr2\" },  /* unknown device specified */\n-  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, \"__AVR_ARCH__=1\",   \"avr1\" },\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, \"__AVR_ARCH__=2\",   \"avr2\" },\n-  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, \"__AVR_ARCH__=25\",  \"avr25\" },\n-  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, \"__AVR_ARCH__=3\",   \"avr3\" },\n-  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, \"__AVR_ARCH__=31\",  \"avr31\" },\n-  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, \"__AVR_ARCH__=35\",  \"avr35\" },\n-  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, \"__AVR_ARCH__=4\",   \"avr4\" },\n-  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, \"__AVR_ARCH__=5\",   \"avr5\" },\n-  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, \"__AVR_ARCH__=51\",  \"avr51\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, \"__AVR_ARCH__=6\",   \"avr6\" }\n+const struct base_arch_s\n+avr_arch_types[] =\n+{\n+  /* unknown device specified */\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 1, NULL,               \"avr2\" },\n+  /*\n+    A  M  J  L  E  E  E         d  S   # F\n+    S  U  M  P  L  L  I         a  t   6 l \n+    M  L  P  M  P  P  J  -  -   t  a   4 a   \n+             X  M  M  M         a  r     s\n+                   X  P            t   k h  */\n+  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=1\",   \"avr1\" },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=2\",   \"avr2\" },\n+  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=25\",  \"avr25\" },\n+  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=3\",   \"avr3\" },\n+  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 2, \"__AVR_ARCH__=31\",  \"avr31\" },\n+  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=35\",  \"avr35\" },\n+  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=4\",   \"avr4\" },\n+  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=5\",   \"avr5\" },\n+  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 2, \"__AVR_ARCH__=51\",  \"avr51\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 4, \"__AVR_ARCH__=6\",   \"avr6\" }\n };\n \n const struct mcu_type_s avr_mcu_types[] = {"}, {"sha": "c71bc9df6812b211a58b1cefdf9994502c2f6d87", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -34,6 +34,7 @@ extern int avr_hard_regno_rename_ok (unsigned int, unsigned int);\n extern rtx avr_return_addr_rtx (int count, rtx tem);\n extern void avr_register_target_pragmas (void);\n extern bool avr_accumulate_outgoing_args (void);\n+extern void avr_init_expanders (void);\n \n #ifdef TREE_CODE\n extern void avr_asm_output_aligned_decl_common (FILE*, const_tree, const char*, unsigned HOST_WIDE_INT, unsigned int, bool);\n@@ -84,6 +85,7 @@ extern bool avr_rotate_bytes (rtx operands[]);\n \n extern void expand_prologue (void);\n extern void expand_epilogue (bool);\n+extern bool avr_emit_movmemhi (rtx*);\n extern int avr_epilogue_uses (int regno);\n extern int avr_starting_frame_offset (void);\n \n@@ -94,6 +96,8 @@ extern const char* avr_out_bitop (rtx, rtx*, int*);\n extern const char* avr_out_plus (rtx*, int*, int*);\n extern const char* avr_out_plus_noclobber (rtx*, int*, int*);\n extern const char* avr_out_addto_sp (rtx*, int*);\n+extern const char* avr_out_xload (rtx, rtx*, int*);\n+extern const char* avr_out_movmem (rtx, rtx*, int*);\n extern bool avr_popcount_each_byte (rtx, int, int);\n \n extern int extra_constraint_Q (rtx x);\n@@ -122,7 +126,9 @@ extern bool avr_regno_mode_code_ok_for_base_p (int, enum machine_mode, addr_spac\n extern rtx avr_incoming_return_addr_rtx (void);\n extern rtx avr_legitimize_reload_address (rtx*, enum machine_mode, int, int, int, int, rtx (*)(rtx,int));\n extern bool avr_mem_pgm_p (rtx);\n+extern bool avr_mem_pgmx_p (rtx);\n extern bool avr_load_libgcc_p (rtx);\n+extern bool avr_xload_libgcc_p (enum machine_mode);\n #endif /* RTX_CODE */\n \n #ifdef REAL_VALUE_TYPE"}, {"sha": "e7b902d8534ae290e14dffc619dcd221ffd3c11f", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 953, "deletions": 242, "changes": 1195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -55,7 +55,10 @@\n /* Return true if STR starts with PREFIX and false, otherwise.  */\n #define STR_PREFIX_P(STR,PREFIX) (0 == strncmp (STR, PREFIX, strlen (PREFIX)))\n \n-#define AVR_SECTION_PROGMEM (SECTION_MACH_DEP << 0)\n+/* The 4 bits starting at SECTION_MACH_DEP are reverved to store\n+   1 + flash segment where progmem data is to be located.\n+   For example, data with __pgm2 is stored as (1+2) * SECTION_MACH_DEP.  */\n+#define AVR_SECTION_PROGMEM (0xf * SECTION_MACH_DEP)\n \n \n /* Prototypes for local helper functions.  */\n@@ -97,6 +100,13 @@ static GTY(()) rtx tmp_reg_rtx;\n /* Zeroed register RTX (gen_rtx_REG (QImode, ZERO_REGNO)) */\n static GTY(()) rtx zero_reg_rtx;\n \n+/* RAMPZ special function register */\n+static GTY(()) rtx rampz_rtx;\n+\n+/* RTX containing the strings \"\" and \"e\", respectively */\n+static GTY(()) rtx xstring_empty;\n+static GTY(()) rtx xstring_e;\n+\n /* RTXs for all general purpose registers as QImode */\n static GTY(()) rtx all_regs_rtx[32];\n \n@@ -116,7 +126,17 @@ const struct mcu_type_s *avr_current_device;\n static GTY(()) section *progmem_swtable_section;\n \n /* Unnamed section associated to __attribute__((progmem)) aka. PROGMEM.  */\n-static GTY(()) section *progmem_section;\n+static GTY(()) section *progmem_section[6];\n+\n+static const char * const progmem_section_prefix[6] =\n+  {\n+    \".progmem.data\",\n+    \".progmem1.data\",\n+    \".progmem2.data\",\n+    \".progmem3.data\",\n+    \".progmem4.data\",\n+    \".progmem5.data\"\n+  };\n \n /* To track if code will use .bss and/or .data.  */\n bool avr_need_clear_bss_p = false;\n@@ -317,8 +337,6 @@ avr_popcount_each_byte (rtx xval, int n_bytes, int pop_mask)\n static void\n avr_option_override (void)\n {\n-  int regno;\n-  \n   flag_delete_null_pointer_checks = 0;\n \n   /* caller-save.c looks for call-clobbered hard registers that are assigned\n@@ -347,15 +365,6 @@ avr_option_override (void)\n   avr_current_arch = &avr_arch_types[avr_current_device->arch];\n   avr_extra_arch_macro = avr_current_device->macro;\n \n-  for (regno = 0; regno < 32; regno ++)\n-    all_regs_rtx[regno] = gen_rtx_REG (QImode, regno);\n-\n-  lpm_reg_rtx  = all_regs_rtx[LPM_REGNO];\n-  tmp_reg_rtx  = all_regs_rtx[TMP_REGNO];\n-  zero_reg_rtx = all_regs_rtx[ZERO_REGNO];\n-\n-  lpm_addr_reg_rtx = gen_rtx_REG (HImode, REG_Z);\n-\n   init_machine_status = avr_init_machine_status;\n \n   avr_log_set_avr_log();\n@@ -369,6 +378,38 @@ avr_init_machine_status (void)\n   return ggc_alloc_cleared_machine_function ();\n }\n \n+\n+/* Implement `INIT_EXPANDERS'.  */\n+/* The function works like a singleton.  */\n+\n+void\n+avr_init_expanders (void)\n+{\n+  int regno;\n+\n+  static bool done = false;\n+\n+  if (done)\n+    return;\n+  else\n+    done = true;\n+\n+  for (regno = 0; regno < 32; regno ++)\n+    all_regs_rtx[regno] = gen_rtx_REG (QImode, regno);\n+\n+  lpm_reg_rtx  = all_regs_rtx[LPM_REGNO];\n+  tmp_reg_rtx  = all_regs_rtx[TMP_REGNO];\n+  zero_reg_rtx = all_regs_rtx[ZERO_REGNO];\n+\n+  lpm_addr_reg_rtx = gen_rtx_REG (HImode, REG_Z);\n+\n+  rampz_rtx = gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR));\n+\n+  xstring_empty = gen_rtx_CONST_STRING (VOIDmode, \"\");\n+  xstring_e = gen_rtx_CONST_STRING (VOIDmode, \"e\");\n+}\n+\n+\n /* Return register class for register R.  */\n \n enum reg_class\n@@ -414,18 +455,60 @@ avr_scalar_mode_supported_p (enum machine_mode mode)\n }\n \n \n+/* Return the segment number of pgm address space AS, i.e.\n+   the 64k block it lives in.\n+   Return -1 if unknown, i.e. 24-bit AS in flash.\n+   Return -2 for anything else.  */\n+\n+static int\n+avr_pgm_segment (addr_space_t as)\n+{\n+  switch (as)\n+    {\n+    default: return -2;\n+\n+    case ADDR_SPACE_PGMX:  return -1;\n+    case ADDR_SPACE_PGM:   return 0;\n+    case ADDR_SPACE_PGM1:  return 1;\n+    case ADDR_SPACE_PGM2:  return 2;\n+    case ADDR_SPACE_PGM3:  return 3;\n+    case ADDR_SPACE_PGM4:  return 4;\n+    case ADDR_SPACE_PGM5:  return 5;\n+    }\n+}\n+\n+\n /* Return TRUE if DECL is a VAR_DECL located in Flash and FALSE, otherwise.  */\n \n static bool\n avr_decl_pgm_p (tree decl)\n {\n-  if (TREE_CODE (decl) != VAR_DECL)\n-    return false;\n+  if (TREE_CODE (decl) != VAR_DECL\n+      || TREE_TYPE (decl) == error_mark_node)\n+    {\n+      return false;\n+    }\n \n   return !ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n }\n \n \n+/* Return TRUE if DECL is a VAR_DECL located in the 24-bit Flash\n+   address space and FALSE, otherwise.  */\n+ \n+static bool\n+avr_decl_pgmx_p (tree decl)\n+{\n+  if (TREE_CODE (decl) != VAR_DECL\n+      || TREE_TYPE (decl) == error_mark_node)\n+    {\n+      return false;\n+    }\n+\n+  return (ADDR_SPACE_PGMX == TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n+}\n+\n+\n /* Return TRUE if X is a MEM rtx located in Flash and FALSE, otherwise.  */\n \n bool\n@@ -436,6 +519,17 @@ avr_mem_pgm_p (rtx x)\n }\n \n \n+/* Return TRUE if X is a MEM rtx located in the 24-bit Flash\n+   address space and FALSE, otherwise.  */\n+\n+bool\n+avr_mem_pgmx_p (rtx x)\n+{\n+  return (MEM_P (x)\n+          && ADDR_SPACE_PGMX == MEM_ADDR_SPACE (x));\n+}\n+\n+\n /* A helper for the subsequent function attribute used to dig for\n    attribute 'name' in a FUNCTION_DECL or FUNCTION_TYPE */\n \n@@ -1041,8 +1135,7 @@ expand_prologue (void)\n           && TEST_HARD_REG_BIT (set, REG_Z)\n           && TEST_HARD_REG_BIT (set, REG_Z + 1))\n         {\n-          emit_move_insn (tmp_reg_rtx,\n-                          gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)));\n+          emit_move_insn (tmp_reg_rtx, rampz_rtx);\n           emit_push_byte (TMP_REGNO, false);\n         }\n         \n@@ -1280,8 +1373,7 @@ expand_epilogue (bool sibcall_p)\n           && TEST_HARD_REG_BIT (set, REG_Z + 1))\n         {\n           emit_pop_byte (TMP_REGNO);\n-          emit_move_insn (gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)), \n-                          tmp_reg_rtx);\n+          emit_move_insn (rampz_rtx, tmp_reg_rtx);\n         }\n \n       /* Restore SREG using tmp reg as scratch.  */\n@@ -1795,6 +1887,8 @@ print_operand (FILE *file, rtx x, int code)\n       REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n       fprintf (file, \"0x%lx\", val);\n     }\n+  else if (GET_CODE (x) == CONST_STRING)\n+    fputs (XSTR (x, 0), file);\n   else if (code == 'j')\n     fputs (cond_string (GET_CODE (x)), file);\n   else if (code == 'k')\n@@ -2247,6 +2341,70 @@ avr_load_libgcc_p (rtx op)\n           && avr_mem_pgm_p (op));\n }\n \n+/* Return true if a value of mode MODE is read by __xload_* function.  */\n+\n+bool\n+avr_xload_libgcc_p (enum machine_mode mode)\n+{\n+  int n_bytes = GET_MODE_SIZE (mode);\n+  \n+  return (n_bytes > 1\n+          && avr_current_arch->n_segments > 1\n+          && !AVR_HAVE_ELPMX);\n+}\n+\n+\n+/* Find an unused d-register to be used as scratch in INSN.\n+   EXCLUDE is either NULL_RTX or some register. In the case where EXCLUDE\n+   is a register, skip all possible return values that overlap EXCLUDE.\n+   The policy for the returned register is similar to that of\n+   `reg_unused_after', i.e. the returned register may overlap the SET_DEST\n+   of INSN.\n+\n+   Return a QImode d-register or NULL_RTX if nothing found.  */\n+\n+static rtx\n+avr_find_unused_d_reg (rtx insn, rtx exclude)\n+{\n+  int regno;\n+  bool isr_p = (interrupt_function_p (current_function_decl)\n+                || signal_function_p (current_function_decl));\n+\n+  for (regno = 16; regno < 32; regno++)\n+    {\n+      rtx reg = all_regs_rtx[regno];\n+      \n+      if ((exclude\n+           && reg_overlap_mentioned_p (exclude, reg))\n+          || fixed_regs[regno])\n+        {\n+          continue;\n+        }\n+\n+      /* Try non-live register */\n+\n+      if (!df_regs_ever_live_p (regno)\n+          && (TREE_THIS_VOLATILE (current_function_decl)\n+              || cfun->machine->is_OS_task\n+              || cfun->machine->is_OS_main\n+              || (!isr_p && call_used_regs[regno])))\n+        {\n+          return reg;\n+        }\n+\n+      /* Any live register can be used if it is unused after.\n+         Prologue/epilogue will care for it as needed.  */\n+      \n+      if (df_regs_ever_live_p (regno)\n+          && reg_unused_after (insn, reg))\n+        {\n+          return reg;\n+        }\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n \n /* Helper function for the next function in the case where only restricted\n    version of LPM instruction is available.  */\n@@ -2279,28 +2437,30 @@ avr_out_lpm_no_lpmx (rtx insn, rtx *xop, int *plen)\n           gcc_unreachable();\n \n         case 1:\n-          return avr_asm_len (\"lpm\" CR_TAB\n-                              \"mov %0,%3\", xop, plen, 2);\n+          avr_asm_len (\"%4lpm\", xop, plen, 1);\n+\n+          if (regno_dest != LPM_REGNO)\n+            avr_asm_len (\"mov %0,%3\", xop, plen, 1);\n+\n+          return \"\";\n \n         case 2:\n           if (REGNO (dest) == REG_Z)\n-            return avr_asm_len (\"lpm\"        CR_TAB\n+            return avr_asm_len (\"%4lpm\"      CR_TAB\n                                 \"push %3\"    CR_TAB\n                                 \"adiw %2,1\"  CR_TAB\n-                                \"lpm\"        CR_TAB\n+                                \"%4lpm\"      CR_TAB\n                                 \"mov %B0,%3\" CR_TAB\n                                 \"pop %A0\", xop, plen, 6);\n-          else\n-            {\n-              avr_asm_len (\"lpm\"        CR_TAB\n-                           \"mov %A0,%3\" CR_TAB\n-                           \"adiw %2,1\"  CR_TAB\n-                           \"lpm\"        CR_TAB\n-                           \"mov %B0,%3\", xop, plen, 5);\n+          \n+          avr_asm_len (\"%4lpm\"      CR_TAB\n+                       \"mov %A0,%3\" CR_TAB\n+                       \"adiw %2,1\"  CR_TAB\n+                       \"%4lpm\"      CR_TAB\n+                       \"mov %B0,%3\", xop, plen, 5);\n                 \n-              if (!reg_unused_after (insn, addr))\n-                avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n-            }\n+          if (!reg_unused_after (insn, addr))\n+            avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n           \n           break; /* 2 */\n         }\n@@ -2310,17 +2470,31 @@ avr_out_lpm_no_lpmx (rtx insn, rtx *xop, int *plen)\n     case POST_INC:\n \n       gcc_assert (REG_Z == REGNO (XEXP (addr, 0))\n-                  && n_bytes <= 2);\n+                  && n_bytes <= 4);\n \n-      avr_asm_len (\"lpm\"        CR_TAB\n-                   \"mov %A0,%3\" CR_TAB\n-                   \"adiw %2,1\", xop, plen, 3);\n+      if (regno_dest == LPM_REGNO)\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"adiw %2,1\", xop, plen, 2);\n+      else\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"mov %A0,%3\" CR_TAB\n+                     \"adiw %2,1\", xop, plen, 3);\n \n       if (n_bytes >= 2)\n-        avr_asm_len (\"lpm\"        CR_TAB\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n                      \"mov %B0,%3\" CR_TAB\n                      \"adiw %2,1\", xop, plen, 3);\n \n+      if (n_bytes >= 3)\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"mov %C0,%3\" CR_TAB\n+                     \"adiw %2,1\", xop, plen, 3);\n+\n+      if (n_bytes >= 4)\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"mov %D0,%3\" CR_TAB\n+                     \"adiw %2,1\", xop, plen, 3);\n+\n       break; /* POST_INC */\n       \n     } /* switch CODE (addr) */\n@@ -2337,12 +2511,13 @@ avr_out_lpm_no_lpmx (rtx insn, rtx *xop, int *plen)\n static const char*\n avr_out_lpm (rtx insn, rtx *op, int *plen)\n {\n-  rtx xop[5];\n+  rtx xop[6];\n   rtx dest = op[0];\n   rtx src = SET_SRC (single_set (insn));\n   rtx addr;\n   int n_bytes = GET_MODE_SIZE (GET_MODE (dest));\n   int regno_dest;\n+  int segment;\n \n   if (plen)\n     *plen = 0;\n@@ -2357,17 +2532,66 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n \n   addr = XEXP (src, 0);\n \n-  gcc_assert (!avr_load_libgcc_p (src)\n-              && REG_P (dest)\n-              && (REG_P (addr) || POST_INC == GET_CODE (addr)));\n+  segment = avr_pgm_segment (MEM_ADDR_SPACE (src));\n+\n+  gcc_assert (REG_P (dest)\n+              && ((segment >= 0\n+                   && (REG_P (addr) || POST_INC == GET_CODE (addr)))\n+                  || (GET_CODE (addr) == LO_SUM && segment == -1)));\n+\n+  if (segment == -1)\n+    {\n+      /* We are called from avr_out_xload because someone wrote\n+         __pgmx on a device with just one flash segment.  */\n+\n+      addr = XEXP (addr, 1);\n+    }\n \n   xop[0] = dest;\n   xop[1] = addr;\n   xop[2] = lpm_addr_reg_rtx;\n+  xop[4] = xstring_empty;\n+  xop[5] = tmp_reg_rtx;\n \n   regno_dest = REGNO (dest);\n \n-  if (!AVR_HAVE_LPMX)\n+  /* Cut down segment number to a number the device actually\n+     supports.  We do this late to preserve the address space's\n+     name for diagnostics.  */\n+\n+  segment %= avr_current_arch->n_segments;\n+\n+  /* Set RAMPZ as needed.  */\n+\n+  if (segment)\n+    {\n+      xop[4] = GEN_INT (segment);\n+      \n+      if (xop[3] = avr_find_unused_d_reg (insn, lpm_addr_reg_rtx),\n+          xop[3])\n+        {\n+          avr_asm_len (\"ldi %3,%4\" CR_TAB\n+                       \"out __RAMPZ__,%3\", xop, plen, 2);\n+        }\n+      else if (segment == 1)\n+        {\n+          avr_asm_len (\"clr %5\" CR_TAB\n+                       \"inc %5\" CR_TAB\n+                       \"out __RAMPZ__,%5\", xop, plen, 3);\n+        }\n+      else\n+        {\n+          avr_asm_len (\"mov %5,%2\"         CR_TAB\n+                       \"ldi %2,%4\"         CR_TAB\n+                       \"out __RAMPZ__,%2\"  CR_TAB\n+                       \"mov %2,%5\", xop, plen, 4);\n+        }\n+      \n+      xop[4] = xstring_e;\n+    }\n+\n+  if ((segment == 0 && !AVR_HAVE_LPMX)\n+      || (segment != 0 && !AVR_HAVE_ELPMX))\n     {\n       return avr_out_lpm_no_lpmx (insn, xop, plen);\n     }\n@@ -2387,17 +2611,17 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n           gcc_unreachable();\n \n         case 1:\n-          return avr_asm_len (\"lpm %0,%a2\", xop, plen, -1);\n+          return avr_asm_len (\"%4lpm %0,%a2\", xop, plen, 1);\n \n         case 2:\n           if (REGNO (dest) == REG_Z)\n-            return avr_asm_len (\"lpm __tmp_reg__,%a2+\" CR_TAB\n-                                \"lpm %B0,%a2\"          CR_TAB\n-                                \"mov %A0,__tmp_reg__\", xop, plen, -3);\n+            return avr_asm_len (\"%4lpm %5,%a2+\" CR_TAB\n+                                \"%4lpm %B0,%a2\" CR_TAB\n+                                \"mov %A0,%5\", xop, plen, 3);\n           else\n             {\n-              avr_asm_len (\"lpm %A0,%a2+\" CR_TAB\n-                           \"lpm %B0,%a2\", xop, plen, -2);\n+              avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n+                           \"%4lpm %B0,%a2\", xop, plen, 2);\n                 \n               if (!reg_unused_after (insn, addr))\n                 avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n@@ -2407,9 +2631,9 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n \n         case 3:\n \n-          avr_asm_len (\"lpm %A0,%a2+\" CR_TAB\n-                       \"lpm %B0,%a2+\" CR_TAB\n-                       \"lpm %C0,%a2\", xop, plen, -3);\n+          avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n+                       \"%4lpm %B0,%a2+\" CR_TAB\n+                       \"%4lpm %C0,%a2\", xop, plen, 3);\n                 \n           if (!reg_unused_after (insn, addr))\n             avr_asm_len (\"sbiw %2,2\", xop, plen, 1);\n@@ -2418,17 +2642,17 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n       \n         case 4:\n \n-          avr_asm_len (\"lpm %A0,%a2+\" CR_TAB\n-                       \"lpm %B0,%a2+\", xop, plen, -2);\n+          avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n+                       \"%4lpm %B0,%a2+\", xop, plen, 2);\n           \n           if (REGNO (dest) == REG_Z - 2)\n-            return avr_asm_len (\"lpm __tmp_reg__,%a2+\" CR_TAB\n-                                \"lpm %C0,%a2\"          CR_TAB\n-                                \"mov %D0,__tmp_reg__\", xop, plen, 3);\n+            return avr_asm_len (\"%4lpm %5,%a2+\" CR_TAB\n+                                \"%4lpm %C0,%a2\"          CR_TAB\n+                                \"mov %D0,%5\", xop, plen, 3);\n           else\n             {\n-              avr_asm_len (\"lpm %C0,%a2+\" CR_TAB\n-                           \"lpm %D0,%a2\", xop, plen, 2);\n+              avr_asm_len (\"%4lpm %C0,%a2+\" CR_TAB\n+                           \"%4lpm %D0,%a2\", xop, plen, 2);\n                 \n               if (!reg_unused_after (insn, addr))\n                 avr_asm_len (\"sbiw %2,3\", xop, plen, 1);\n@@ -2444,10 +2668,10 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n       gcc_assert (REG_Z == REGNO (XEXP (addr, 0))\n                   && n_bytes <= 4);\n \n-      avr_asm_len                    (\"lpm %A0,%a2+\", xop, plen, -1);\n-      if (n_bytes >= 2)  avr_asm_len (\"lpm %B0,%a2+\", xop, plen, 1);\n-      if (n_bytes >= 3)  avr_asm_len (\"lpm %C0,%a2+\", xop, plen, 1);\n-      if (n_bytes >= 4)  avr_asm_len (\"lpm %D0,%a2+\", xop, plen, 1);\n+      avr_asm_len                    (\"%4lpm %A0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 2)  avr_asm_len (\"%4lpm %B0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 3)  avr_asm_len (\"%4lpm %C0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 4)  avr_asm_len (\"%4lpm %D0,%a2+\", xop, plen, 1);\n \n       break; /* POST_INC */\n \n@@ -2457,6 +2681,81 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n }\n \n \n+/* Worker function for xload_<mode> and xload_8 insns.  */\n+\n+const char*\n+avr_out_xload (rtx insn, rtx *op, int *plen)\n+{\n+  rtx xop[5];\n+  rtx reg = op[0];\n+  int n_bytes = GET_MODE_SIZE (GET_MODE (reg));\n+  unsigned int regno = REGNO (reg);\n+\n+  if (avr_current_arch->n_segments == 1)\n+    return avr_out_lpm (insn, op, plen);\n+\n+  xop[0] = reg;\n+  xop[1] = op[1];\n+  xop[2] = lpm_addr_reg_rtx;\n+  xop[3] = lpm_reg_rtx;\n+  xop[4] = tmp_reg_rtx;\n+  \n+  avr_asm_len (\"out __RAMPZ__,%1\", xop, plen, -1);\n+  \n+  if (1 == n_bytes)\n+    {\n+      if (AVR_HAVE_ELPMX)\n+        return avr_asm_len (\"elpm %0,%a2\", xop, plen, 1);\n+      else\n+        return avr_asm_len (\"elpm\" CR_TAB\n+                            \"mov %0,%3\", xop, plen, 2);\n+    }\n+\n+  gcc_assert (AVR_HAVE_ELPMX);\n+  \n+  if (!reg_overlap_mentioned_p (reg, lpm_addr_reg_rtx))\n+    {\n+      /* Insn clobbers the Z-register so we can use post-increment.  */\n+      \n+      avr_asm_len                    (\"elpm %A0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 2)  avr_asm_len (\"elpm %B0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 3)  avr_asm_len (\"elpm %C0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 4)  avr_asm_len (\"elpm %D0,%a2+\", xop, plen, 1);\n+\n+      return \"\";\n+    }\n+\n+  switch (n_bytes)\n+    {\n+    default:\n+      gcc_unreachable();\n+      \n+    case 2:\n+      gcc_assert (regno == REGNO (lpm_addr_reg_rtx));\n+\n+      return avr_asm_len (\"elpm %4,%a2+\" CR_TAB\n+                          \"elpm %B0,%a2\" CR_TAB\n+                          \"mov %A0,%4\", xop, plen, 3);\n+\n+    case 3:\n+    case 4:\n+      gcc_assert (regno + 2 == REGNO (lpm_addr_reg_rtx));\n+      \n+      avr_asm_len (\"elpm %A0,%a2+\" CR_TAB\n+                   \"elpm %B0,%a2+\", xop, plen, 2);\n+\n+      if (n_bytes == 3)\n+        return avr_asm_len (\"elpm %C0,%a2\", xop, plen, 1);\n+      else\n+        return avr_asm_len (\"elpm %4,%a2+\" CR_TAB\n+                            \"elpm %D0,%a2\" CR_TAB\n+                            \"mov %C0,%4\", xop, plen, 3);\n+    }\n+  \n+  return \"\";\n+}\n+\n+\n const char *\n output_movqi (rtx insn, rtx operands[], int *l)\n {\n@@ -2596,71 +2895,73 @@ output_movhi (rtx insn, rtx operands[], int *l)\n }\n \n const char *\n-out_movqi_r_mr (rtx insn, rtx op[], int *l)\n+out_movqi_r_mr (rtx insn, rtx op[], int *plen)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n   rtx x = XEXP (src, 0);\n-  int dummy;\n-  \n-  if (!l)\n-    l = &dummy;\n   \n   if (CONSTANT_ADDRESS_P (x))\n     {\n-      if (CONST_INT_P (x) && INTVAL (x) == SREG_ADDR)\n-\t{\n-\t  *l = 1;\n-\t  return AS2 (in,%0,__SREG__);\n-\t}\n+      if (CONST_INT_P (x))\n+        {\n+          if (SREG_ADDR == INTVAL (x))\n+            return avr_asm_len (\"in %0,__SREG__\", op, plen, -1);\n+\n+          if (RAMPZ_ADDR == INTVAL (x))\n+            return avr_asm_len (\"in %0,__RAMPZ__\", op, plen, -1);\n+        }\n+      \n       if (optimize > 0 && io_address_operand (x, QImode))\n-\t{\n-\t  *l = 1;\n-\t  return AS2 (in,%0,%m1-0x20);\n-\t}\n-      *l = 2;\n-      return AS2 (lds,%0,%m1);\n+        return avr_asm_len (\"in %0,%m1-0x20\", op, plen, -1);\n+\n+      return avr_asm_len (\"lds %0,%m1\", op, plen, -2);\n     }\n-  /* memory access by reg+disp */\n   else if (GET_CODE (x) == PLUS\n-      && REG_P (XEXP (x,0))\n-      && GET_CODE (XEXP (x,1)) == CONST_INT)\n+           && REG_P (XEXP (x, 0))\n+           && CONST_INT_P (XEXP (x, 1)))\n     {\n-      if ((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (src))) >= 63)\n-\t{\n-\t  int disp = INTVAL (XEXP (x,1));\n-\t  if (REGNO (XEXP (x,0)) != REG_Y)\n-\t    fatal_insn (\"incorrect insn:\",insn);\n+      /* memory access by reg+disp */\n \n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (src)))\n-\t    return *l = 3, (AS2 (adiw,r28,%o1-63) CR_TAB\n-\t\t\t    AS2 (ldd,%0,Y+63)     CR_TAB\n-\t\t\t    AS2 (sbiw,r28,%o1-63));\n+      int disp = INTVAL (XEXP (x, 1));\n+      \n+      if (disp - GET_MODE_SIZE (GET_MODE (src)) >= 63)\n+        {\n+          if (REGNO (XEXP (x, 0)) != REG_Y)\n+            fatal_insn (\"incorrect insn:\",insn);\n \n-\t  return *l = 5, (AS2 (subi,r28,lo8(-%o1)) CR_TAB\n-\t\t\t  AS2 (sbci,r29,hi8(-%o1)) CR_TAB\n-\t\t\t  AS2 (ld,%0,Y)            CR_TAB\n-\t\t\t  AS2 (subi,r28,lo8(%o1))  CR_TAB\n-\t\t\t  AS2 (sbci,r29,hi8(%o1)));\n-\t}\n-      else if (REGNO (XEXP (x,0)) == REG_X)\n-\t{\n-\t  /* This is a paranoid case LEGITIMIZE_RELOAD_ADDRESS must exclude\n-\t     it but I have this situation with extremal optimizing options.  */\n-\t  if (reg_overlap_mentioned_p (dest, XEXP (x,0))\n-\t      || reg_unused_after (insn, XEXP (x,0)))\n-\t    return *l = 2, (AS2 (adiw,r26,%o1) CR_TAB\n-\t\t\t    AS2 (ld,%0,X));\n-\n-\t  return *l = 3, (AS2 (adiw,r26,%o1) CR_TAB\n-\t\t\t  AS2 (ld,%0,X)      CR_TAB\n-\t\t\t  AS2 (sbiw,r26,%o1));\n-\t}\n-      *l = 1;\n-      return AS2 (ldd,%0,%1);\n+          if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (src)))\n+            return avr_asm_len (\"adiw r28,%o1-63\" CR_TAB\n+                                \"ldd %0,Y+63\"     CR_TAB\n+                                \"sbiw r28,%o1-63\", op, plen, -3);\n+\n+          return avr_asm_len (\"subi r28,lo8(-%o1)\" CR_TAB\n+                              \"sbci r29,hi8(-%o1)\" CR_TAB\n+                              \"ld %0,Y\"            CR_TAB\n+                              \"subi r28,lo8(%o1)\"  CR_TAB\n+                              \"sbci r29,hi8(%o1)\", op, plen, -5);\n+        }\n+      else if (REGNO (XEXP (x, 0)) == REG_X)\n+        {\n+          /* This is a paranoid case LEGITIMIZE_RELOAD_ADDRESS must exclude\n+             it but I have this situation with extremal optimizing options.  */\n+          \n+          avr_asm_len (\"adiw r26,%o1\" CR_TAB\n+                       \"ld %0,X\", op, plen, -2);\n+          \n+          if (!reg_overlap_mentioned_p (dest, XEXP (x,0))\n+              && !reg_unused_after (insn, XEXP (x,0)))\n+            {\n+              avr_asm_len (\"sbiw r26,%o1\", op, plen, 1);\n+            }\n+\n+          return \"\";\n+        }\n+\n+      return avr_asm_len (\"ldd %0,%1\", op, plen, -1);\n     }\n-  *l = 1;\n-  return AS2 (ld,%0,%1);\n+  \n+  return avr_asm_len (\"ld %0,%1\", op, plen, -1);\n }\n \n const char *\n@@ -3539,83 +3840,76 @@ avr_out_movpsi (rtx insn, rtx *op, int *plen)\n \n \n const char *\n-out_movqi_mr_r (rtx insn, rtx op[], int *l)\n+out_movqi_mr_r (rtx insn, rtx op[], int *plen)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n   rtx x = XEXP (dest, 0);\n-  int dummy;\n-\n-  if (!l)\n-    l = &dummy;\n   \n   if (CONSTANT_ADDRESS_P (x))\n     {\n-      if (CONST_INT_P (x) && INTVAL (x) == SREG_ADDR)\n-\t{\n-\t  *l = 1;\n-\t  return AS2 (out,__SREG__,%1);\n-\t}\n+      if (CONST_INT_P (x))\n+        {\n+          if (SREG_ADDR == INTVAL (x))\n+            return avr_asm_len (\"out __SREG__,%1\", op, plen, -1);\n+\n+          if (RAMPZ_ADDR == INTVAL (x))\n+            return avr_asm_len (\"out __RAMPZ__,%1\", op, plen, -1);\n+        }\n+      \n       if (optimize > 0 && io_address_operand (x, QImode))\n-\t{\n-\t  *l = 1;\n-\t  return AS2 (out,%m0-0x20,%1);\n-\t}\n-      *l = 2;\n-      return AS2 (sts,%m0,%1);\n+        avr_asm_len (\"out %m0-0x20,%1\", op, plen, -1);\n+\n+      return avr_asm_len (\"sts %m0,%1\", op, plen, -2);\n     }\n-  /* memory access by reg+disp */\n-  else if (GET_CODE (x) == PLUS\t\n-      && REG_P (XEXP (x,0))\n-      && GET_CODE (XEXP (x,1)) == CONST_INT)\n+  else if (GET_CODE (x) == PLUS\n+           && REG_P (XEXP (x, 0))\n+           && CONST_INT_P (XEXP (x, 1)))\n     {\n-      if ((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (dest))) >= 63)\n-\t{\n-\t  int disp = INTVAL (XEXP (x,1));\n-\t  if (REGNO (XEXP (x,0)) != REG_Y)\n-\t    fatal_insn (\"incorrect insn:\",insn);\n+      /* memory access by reg+disp */\n \n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest)))\n-\t    return *l = 3, (AS2 (adiw,r28,%o0-63) CR_TAB\n-\t\t\t    AS2 (std,Y+63,%1)     CR_TAB\n-\t\t\t    AS2 (sbiw,r28,%o0-63));\n+      int disp = INTVAL (XEXP (x, 1));\n \n-\t  return *l = 5, (AS2 (subi,r28,lo8(-%o0)) CR_TAB\n-\t\t\t  AS2 (sbci,r29,hi8(-%o0)) CR_TAB\n-\t\t\t  AS2 (st,Y,%1)            CR_TAB\n-\t\t\t  AS2 (subi,r28,lo8(%o0))  CR_TAB\n-\t\t\t  AS2 (sbci,r29,hi8(%o0)));\n-\t}\n+      if (disp - GET_MODE_SIZE (GET_MODE (dest)) >= 63)\n+        {\n+          if (REGNO (XEXP (x, 0)) != REG_Y)\n+            fatal_insn (\"incorrect insn:\",insn);\n+\n+          if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest)))\n+            return avr_asm_len (\"adiw r28,%o0-63\" CR_TAB\n+                                \"std Y+63,%1\"     CR_TAB\n+                                \"sbiw r28,%o0-63\", op, plen, -3);\n+\n+          return avr_asm_len (\"subi r28,lo8(-%o0)\" CR_TAB\n+                              \"sbci r29,hi8(-%o0)\" CR_TAB\n+                              \"st Y,%1\"            CR_TAB\n+                              \"subi r28,lo8(%o0)\"  CR_TAB\n+                              \"sbci r29,hi8(%o0)\", op, plen, -5);\n+        }\n       else if (REGNO (XEXP (x,0)) == REG_X)\n-\t{\n-\t  if (reg_overlap_mentioned_p (src, XEXP (x, 0)))\n-\t    {\n-\t      if (reg_unused_after (insn, XEXP (x,0)))\n-\t\treturn *l = 3, (AS2 (mov,__tmp_reg__,%1) CR_TAB\n-\t\t\t\tAS2 (adiw,r26,%o0)       CR_TAB\n-\t\t\t\tAS2 (st,X,__tmp_reg__));\n-\n-\t      return *l = 4, (AS2 (mov,__tmp_reg__,%1) CR_TAB\n-\t\t\t      AS2 (adiw,r26,%o0)       CR_TAB\n-\t\t\t      AS2 (st,X,__tmp_reg__)   CR_TAB\n-\t\t\t      AS2 (sbiw,r26,%o0));\n-\t    }\n-\t  else\n-\t    {\n-\t      if (reg_unused_after (insn, XEXP (x,0)))\n-\t\treturn *l = 2, (AS2 (adiw,r26,%o0) CR_TAB\n-\t\t\t\tAS2 (st,X,%1));\n+        {\n+          if (reg_overlap_mentioned_p (src, XEXP (x, 0)))\n+            {\n+              avr_asm_len (\"mov __tmp_reg__,%1\" CR_TAB\n+                           \"adiw r26,%o0\"       CR_TAB\n+                           \"st X,__tmp_reg__\", op, plen, -3);\n+            }\n+          else\n+            {\n+              avr_asm_len (\"adiw r26,%o0\" CR_TAB\n+                           \"st X,%1\", op, plen, -2);\n+            }\n+          \n+          if (!reg_unused_after (insn, XEXP (x,0)))\n+            avr_asm_len (\"sbiw r26,%o0\", op, plen, 1);\n \n-\t      return *l = 3, (AS2 (adiw,r26,%o0) CR_TAB\n-\t\t\t      AS2 (st,X,%1)      CR_TAB\n-\t\t\t      AS2 (sbiw,r26,%o0));\n-\t    }\n-\t}\n-      *l = 1;\n-      return AS2 (std,%0,%1);\n+          return \"\";\n+        }\n+      \n+      return avr_asm_len (\"std %0,%1\", op, plen, 1);\n     }\n-  *l = 1;\n-  return AS2 (st,%0,%1);\n+  \n+  return avr_asm_len (\"st %0,%1\", op, plen, 1);\n }\n \n const char *\n@@ -6201,7 +6495,9 @@ adjust_insn_length (rtx insn, int len)\n     case ADJUST_LEN_MOV16: output_movhi (insn, op, &len); break;\n     case ADJUST_LEN_MOV24: avr_out_movpsi (insn, op, &len); break;\n     case ADJUST_LEN_MOV32: output_movsisf (insn, op, &len); break;\n-      \n+    case ADJUST_LEN_MOVMEM: avr_out_movmem (insn, op, &len); break;\n+    case ADJUST_LEN_XLOAD: avr_out_xload (insn, op, &len); break;\n+\n     case ADJUST_LEN_TSTHI: avr_out_tsthi (insn, op, &len); break;\n     case ADJUST_LEN_TSTPSI: avr_out_tstpsi (insn, op, &len); break;\n     case ADJUST_LEN_TSTSI: avr_out_tstsi (insn, op, &len); break;\n@@ -6346,6 +6642,49 @@ _reg_unused_after (rtx insn, rtx reg)\n   return 1;\n }\n \n+\n+/* Return RTX that represents the lower 16 bits of a constant address.\n+   Unfortunately, simplify_gen_subreg does not handle this case.  */\n+\n+static rtx\n+avr_const_address_lo16 (rtx x)\n+{\n+  rtx lo16;\n+  \n+  switch (GET_CODE (x))\n+    {\n+    default:\n+      break;\n+      \n+    case CONST:\n+      if (PLUS == GET_CODE (XEXP (x, 0))\n+          && SYMBOL_REF == GET_CODE (XEXP (XEXP (x, 0), 0))\n+          && CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n+        {\n+          HOST_WIDE_INT offset = INTVAL (XEXP (XEXP (x, 0), 1));\n+          const char *name = XSTR (XEXP (XEXP (x, 0), 0), 0);\n+          \n+          lo16 = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+          lo16 = gen_rtx_CONST (Pmode, plus_constant (lo16, offset));\n+          \n+          return lo16;\n+        }\n+      \n+      break;\n+      \n+    case SYMBOL_REF:\n+      {\n+        const char *name = XSTR (x, 0);\n+        \n+        return gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+      }\n+    }\n+  \n+  avr_edump (\"\\n%?: %r\\n\", x);\n+  gcc_unreachable();\n+}\n+\n+\n /* Target hook for assembling integer objects.  The AVR version needs\n    special handling for references to certain labels.  */\n \n@@ -6358,11 +6697,30 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       fputs (\"\\t.word\\tgs(\", asm_out_file);\n       output_addr_const (asm_out_file, x);\n       fputs (\")\\n\", asm_out_file);\n+      \n+      return true;\n+    }\n+  else if (GET_MODE (x) == PSImode)\n+    {\n+      default_assemble_integer (avr_const_address_lo16 (x),\n+                                GET_MODE_SIZE (HImode), aligned_p);\n+      \n+      fputs (\"\\t.warning\\t\\\"assembling 24-bit address needs binutils extension for hh8(\",\n+             asm_out_file);\n+      output_addr_const (asm_out_file, x);\n+      fputs (\")\\\"\\n\", asm_out_file);\n+      \n+      fputs (\"\\t.byte\\t0\\t\" ASM_COMMENT_START \" hh8(\", asm_out_file);\n+      output_addr_const (asm_out_file, x);\n+      fputs (\")\\n\", asm_out_file);\n+      \n       return true;\n     }\n+  \n   return default_assemble_integer (x, size, aligned_p);\n }\n \n+\n /* Worker function for ASM_DECLARE_FUNCTION_NAME.  */\n \n void\n@@ -6518,6 +6876,7 @@ avr_attribute_table[] =\n    Return non-zero if DECL is data that must end up in Flash and\n    zero if the data lives in RAM (.bss, .data, .rodata, ...).\n    \n+   Return 2   if DECL is located in 24-bit flash address-space\n    Return 1   if DECL is located in 16-bit flash address-space\n    Return -1  if attribute `progmem' occurs in DECL or ATTRIBUTES\n    Return 0   otherwise  */\n@@ -6530,6 +6889,9 @@ avr_progmem_p (tree decl, tree attributes)\n   if (TREE_CODE (decl) != VAR_DECL)\n     return 0;\n \n+  if (avr_decl_pgmx_p (decl))\n+    return 2;\n+\n   if (avr_decl_pgm_p (decl))\n     return 1;\n \n@@ -6745,11 +7107,23 @@ avr_output_bss_section_asm_op (const void *data)\n }\n \n \n+/* Unnamed section callback for progmem*.data sections.  */\n+\n+static void\n+avr_output_progmem_section_asm_op (const void *data)\n+{\n+  fprintf (asm_out_file, \"\\t.section\\t%s,\\\"a\\\",@progbits\\n\",\n+           (const char*) data);\n+}\n+\n+\n /* Implement `TARGET_ASM_INIT_SECTIONS'.  */\n \n static void\n avr_asm_init_sections (void)\n {\n+  unsigned int n;\n+  \n   /* Set up a section for jump tables.  Alignment is handled by\n      ASM_OUTPUT_BEFORE_CASE_LABEL.  */\n   \n@@ -6768,9 +7142,12 @@ avr_asm_init_sections (void)\n                                \",\\\"ax\\\",@progbits\");\n     }\n \n-  progmem_section\n-    = get_unnamed_section (0, output_section_asm_op,\n-                           \"\\t.section\\t.progmem.data,\\\"a\\\",@progbits\");\n+  for (n = 0; n < sizeof (progmem_section) / sizeof (*progmem_section); n++)\n+    {\n+      progmem_section[n]\n+        = get_unnamed_section (0, avr_output_progmem_section_asm_op,\n+                               progmem_section_prefix[n]);\n+    }\n   \n   /* Override section callbacks to keep track of `avr_need_clear_bss_p'\n      resp. `avr_need_copy_data_p'.  */\n@@ -6849,8 +7226,9 @@ avr_asm_named_section (const char *name, unsigned int flags, tree decl)\n {\n   if (flags & AVR_SECTION_PROGMEM)\n     {\n+      int segment = (flags & AVR_SECTION_PROGMEM) / SECTION_MACH_DEP - 1;\n       const char *old_prefix = \".rodata\";\n-      const char *new_prefix = \".progmem.data\";\n+      const char *new_prefix = progmem_section_prefix[segment];\n       const char *sname = new_prefix;\n       \n       if (STR_PREFIX_P (name, old_prefix))\n@@ -6877,6 +7255,7 @@ avr_asm_named_section (const char *name, unsigned int flags, tree decl)\n static unsigned int\n avr_section_type_flags (tree decl, const char *name, int reloc)\n {\n+  int prog;\n   unsigned int flags = default_section_type_flags (decl, name, reloc);\n \n   if (STR_PREFIX_P (name, \".noinit\"))\n@@ -6890,11 +7269,16 @@ avr_section_type_flags (tree decl, const char *name, int reloc)\n     }\n \n   if (decl && DECL_P (decl)\n-      && avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n+      && (prog = avr_progmem_p (decl, DECL_ATTRIBUTES (decl)), prog))\n     {\n+      int segment = 0;\n+\n+      if (prog == 1)\n+        segment = avr_pgm_segment (TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n+\n       flags &= ~SECTION_WRITE;\n       flags &= ~SECTION_BSS;\n-      flags |= AVR_SECTION_PROGMEM;\n+      flags |= (1 + segment % avr_current_arch->n_segments) * SECTION_MACH_DEP;\n     }\n   \n   return flags;\n@@ -6930,16 +7314,25 @@ avr_encode_section_info (tree decl, rtx rtl,\n static section *\n avr_asm_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n {\n+  int prog;\n+  \n   section * sect = default_elf_select_section (decl, reloc, align);\n   \n   if (decl && DECL_P (decl)\n-      && avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n+      && (prog = avr_progmem_p (decl, DECL_ATTRIBUTES (decl)), prog))\n     {\n+      int segment = 0;\n+      \n+      if (prog == 1)\n+        segment = avr_pgm_segment (TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n+\n+      segment %= avr_current_arch->n_segments;\n+      \n       if (sect->common.flags & SECTION_NAMED)\n         {\n           const char * name = sect->named.name;\n           const char * old_prefix = \".rodata\";\n-          const char * new_prefix = \".progmem.data\";\n+          const char * new_prefix = progmem_section_prefix[segment];\n \n           if (STR_PREFIX_P (name, old_prefix))\n             {\n@@ -6950,31 +7343,36 @@ avr_asm_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n             }\n         }\n           \n-      return progmem_section;\n+      return progmem_section[segment];\n     }\n \n   return sect;\n }\n \n /* Implement `TARGET_ASM_FILE_START'.  */\n-/* Outputs some appropriate text to go at the start of an assembler\n-   file.  */\n+/* Outputs some text at the start of each assembler file.  */\n \n static void\n avr_file_start (void)\n {\n+  int sfr_offset = 0x20;\n+\n   if (avr_current_arch->asm_only)\n     error (\"MCU %qs supported for assembler only\", avr_current_device->name);\n \n   default_file_start ();\n \n-/*  fprintf (asm_out_file, \"\\t.arch %s\\n\", avr_current_device->name);*/\n-  fputs (\"__SREG__ = 0x3f\\n\"\n-\t \"__SP_H__ = 0x3e\\n\"\n-\t \"__SP_L__ = 0x3d\\n\", asm_out_file);\n-  \n-  fputs (\"__tmp_reg__ = 0\\n\" \n-         \"__zero_reg__ = 1\\n\", asm_out_file);\n+  fprintf (asm_out_file,\n+           \"__SREG__ = 0x%02x\\n\"\n+           \"__SP_H__ = 0x%02x\\n\"\n+           \"__SP_L__ = 0x%02x\\n\"\n+           \"__RAMPZ__ = 0x%02x\\n\"\n+           \"__tmp_reg__ = 0\\n\" \n+           \"__zero_reg__ = 1\\n\",\n+           -sfr_offset + SREG_ADDR,\n+           -sfr_offset + SP_ADDR + 1,\n+           -sfr_offset + SP_ADDR,\n+           -sfr_offset + RAMPZ_ADDR);\n }\n \n \n@@ -8954,8 +9352,8 @@ const char *\n avr_out_sbxx_branch (rtx insn, rtx operands[])\n {\n   enum rtx_code comp = GET_CODE (operands[0]);\n-  int long_jump = (get_attr_length (insn) >= 4);\n-  int reverse = long_jump || jump_over_one_insn_p (insn, operands[3]);\n+  bool long_jump = get_attr_length (insn) >= 4;\n+  bool reverse = long_jump || jump_over_one_insn_p (insn, operands[3]);\n \n   if (comp == GE)\n     comp = EQ;\n@@ -8965,49 +9363,61 @@ avr_out_sbxx_branch (rtx insn, rtx operands[])\n   if (reverse)\n     comp = reverse_condition (comp);\n \n-  if (GET_CODE (operands[1]) == CONST_INT)\n+  switch (GET_CODE (operands[1]))\n     {\n-      if (INTVAL (operands[1]) < 0x40)\n-\t{\n-\t  if (comp == EQ)\n-\t    output_asm_insn (AS2 (sbis,%m1-0x20,%2), operands);\n-\t  else\n-\t    output_asm_insn (AS2 (sbic,%m1-0x20,%2), operands);\n-\t}\n+    default:\n+      gcc_unreachable();\n+      \n+    case CONST_INT:\n+\n+      if (low_io_address_operand (operands[1], QImode))\n+        {\n+          if (comp == EQ)\n+            output_asm_insn (\"sbis %m1-0x20,%2\", operands);\n+          else\n+            output_asm_insn (\"sbic %m1-0x20,%2\", operands);\n+        }\n       else\n-\t{\n-\t  output_asm_insn (AS2 (in,__tmp_reg__,%m1-0x20), operands);\n-\t  if (comp == EQ)\n-\t    output_asm_insn (AS2 (sbrs,__tmp_reg__,%2), operands);\n-\t  else\n-\t    output_asm_insn (AS2 (sbrc,__tmp_reg__,%2), operands);\n-\t}\n-    }\n-  else  /* GET_CODE (operands[1]) == REG */\n-    {\n+        {\n+          output_asm_insn (\"in __tmp_reg__,%m1-0x20\", operands);\n+          if (comp == EQ)\n+            output_asm_insn (\"sbrs __tmp_reg__,%2\", operands);\n+          else\n+            output_asm_insn (\"sbrc __tmp_reg__,%2\", operands);\n+        }\n+\n+      break; /* CONST_INT */\n+\n+    case REG:\n+\n       if (GET_MODE (operands[1]) == QImode)\n-\t{\n-\t  if (comp == EQ)\n-\t    output_asm_insn (AS2 (sbrs,%1,%2), operands);\n-\t  else\n-\t    output_asm_insn (AS2 (sbrc,%1,%2), operands);\n-\t}\n-      else  /* HImode or SImode */\n-\t{\n-\t  static char buf[] = \"sbrc %A1,0\";\n-\t  int bit_nr = INTVAL (operands[2]);\n-\t  buf[3] = (comp == EQ) ? 's' : 'c';\n-\t  buf[6] = 'A' + (bit_nr >> 3);\n-\t  buf[9] = '0' + (bit_nr & 7);\n-\t  output_asm_insn (buf, operands);\n-\t}\n-    }\n+        {\n+          if (comp == EQ)\n+            output_asm_insn (\"sbrs %1,%2\", operands);\n+          else\n+            output_asm_insn (\"sbrc %1,%2\", operands);\n+        }\n+      else  /* HImode, PSImode or SImode */\n+        {\n+          static char buf[] = \"sbrc %A1,0\";\n+          unsigned int bit_nr = UINTVAL (operands[2]);\n+\n+          buf[3] = (comp == EQ) ? 's' : 'c';\n+          buf[6] = 'A' + (bit_nr / 8);\n+          buf[9] = '0' + (bit_nr % 8);\n+          output_asm_insn (buf, operands);\n+        }\n+\n+      break; /* REG */\n+    }        /* switch */\n \n   if (long_jump)\n-    return (AS1 (rjmp,.+4) CR_TAB\n-\t    AS1 (jmp,%x3));\n+    return (\"rjmp .+4\" CR_TAB\n+            \"jmp %x3\");\n+\n   if (!reverse)\n-    return AS1 (rjmp,%x3);\n+    return \"rjmp %x3\";\n+\n   return \"\";\n }\n \n@@ -9055,18 +9465,18 @@ avr_case_values_threshold (void)\n /* Implement `TARGET_ADDR_SPACE_ADDRESS_MODE'.  */\n \n static enum machine_mode\n-avr_addr_space_address_mode (addr_space_t as ATTRIBUTE_UNUSED)\n+avr_addr_space_address_mode (addr_space_t as)\n {\n-  return HImode;\n+  return as == ADDR_SPACE_PGMX ? PSImode : HImode;\n }\n \n \n /* Implement `TARGET_ADDR_SPACE_POINTER_MODE'.  */\n \n static enum machine_mode\n-avr_addr_space_pointer_mode (addr_space_t as ATTRIBUTE_UNUSED)\n+avr_addr_space_pointer_mode (addr_space_t as)\n {\n-  return HImode;\n+  return as == ADDR_SPACE_PGMX ? PSImode : HImode;\n }\n \n \n@@ -9111,6 +9521,11 @@ avr_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n       return avr_legitimate_address_p (mode, x, strict);\n \n     case ADDR_SPACE_PGM:\n+    case ADDR_SPACE_PGM1:\n+    case ADDR_SPACE_PGM2:\n+    case ADDR_SPACE_PGM3:\n+    case ADDR_SPACE_PGM4:\n+    case ADDR_SPACE_PGM5:\n \n       switch (GET_CODE (x))\n         {\n@@ -9119,15 +9534,32 @@ avr_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n           break;\n           \n         case POST_INC:\n-          ok = (!avr_load_libgcc_p (x)\n-                && avr_reg_ok_for_pgm_addr (XEXP (x, 0), strict));\n+          ok = avr_reg_ok_for_pgm_addr (XEXP (x, 0), strict);\n           break;\n           \n         default:\n           break;\n         }\n \n       break; /* PGM */\n+      \n+    case ADDR_SPACE_PGMX:\n+      if (REG_P (x))\n+        ok = (!strict\n+              && can_create_pseudo_p());\n+\n+      if (LO_SUM == GET_CODE (x))\n+        {\n+          rtx hi = XEXP (x, 0);\n+          rtx lo = XEXP (x, 1);\n+\n+          ok = (REG_P (hi)\n+                && (!strict || REGNO (hi) < FIRST_PSEUDO_REGISTER)\n+                && REG_P (lo)\n+                && REGNO (lo) == REG_Z);\n+        }\n+      \n+      break; /* PGMX */\n     }\n \n   if (avr_log.legitimate_address_p)\n@@ -9177,24 +9609,303 @@ avr_addr_space_legitimize_address (rtx x, rtx old_x,\n static rtx\n avr_addr_space_convert (rtx src, tree type_from, tree type_to)\n {\n+  addr_space_t as_from = TYPE_ADDR_SPACE (TREE_TYPE (type_from));\n+  addr_space_t as_to = TYPE_ADDR_SPACE (TREE_TYPE (type_to));\n+\n   if (avr_log.progmem)\n     avr_edump (\"\\n%!: op = %r\\nfrom = %t\\nto = %t\\n\",\n                src, type_from, type_to);\n \n+  if (as_from != ADDR_SPACE_PGMX\n+      && as_to == ADDR_SPACE_PGMX)\n+    {\n+      rtx new_src;\n+      int n_segments = avr_current_arch->n_segments;\n+      RTX_CODE code = GET_CODE (src);\n+\n+      if (CONST == code\n+          && PLUS == GET_CODE (XEXP (src, 0))\n+          && SYMBOL_REF == GET_CODE (XEXP (XEXP (src, 0), 0))\n+          && CONST_INT_P (XEXP (XEXP (src, 0), 1)))\n+        {\n+          HOST_WIDE_INT offset = INTVAL (XEXP (XEXP (src, 0), 1));\n+          const char *name = XSTR (XEXP (XEXP (src, 0), 0), 0);\n+          \n+          new_src = gen_rtx_SYMBOL_REF (PSImode, ggc_strdup (name));\n+          new_src = gen_rtx_CONST (PSImode,\n+                                   plus_constant (new_src, offset));\n+          return new_src;\n+        }\n+\n+      if (SYMBOL_REF == code)\n+          {\n+            const char *name = XSTR (src, 0);\n+            \n+            return gen_rtx_SYMBOL_REF (PSImode, ggc_strdup (name));\n+          }\n+      \n+      src = force_reg (Pmode, src);\n+      \n+      if (ADDR_SPACE_GENERIC_P (as_from)\n+          || as_from == ADDR_SPACE_PGM\n+          || n_segments == 1)\n+        {\n+          return gen_rtx_ZERO_EXTEND (PSImode, src);\n+        }\n+      else\n+        {\n+          int segment = avr_pgm_segment (as_from) % n_segments;\n+\n+          new_src = gen_reg_rtx (PSImode);\n+          emit_insn (gen_n_extendhipsi2 (new_src, GEN_INT (segment), src));\n+\n+          return new_src;\n+        }\n+    }\n+  \n   return src;\n }\n \n \n /* Implement `TARGET_ADDR_SPACE_SUBSET_P'.  */\n \n static bool\n-avr_addr_space_subset_p (addr_space_t subset ATTRIBUTE_UNUSED,\n-                         addr_space_t superset ATTRIBUTE_UNUSED)\n+avr_addr_space_subset_p (addr_space_t subset, addr_space_t superset)\n {\n+  if (subset == ADDR_SPACE_PGMX\n+      && superset != ADDR_SPACE_PGMX)\n+    {\n+      return false;\n+    }\n+  \n+  return true;\n+}\n+\n+\n+/* Worker function for movmemhi insn.\n+   XOP[0]  Destination as MEM:BLK\n+   XOP[1]  Source      \"     \"\n+   XOP[2]  # Bytes to copy\n+\n+   Return TRUE  if the expansion is accomplished.\n+   Return FALSE if the operand compination is not supported.  */\n+\n+bool\n+avr_emit_movmemhi (rtx *xop)\n+{\n+  HOST_WIDE_INT count;\n+  enum machine_mode loop_mode;\n+  addr_space_t as = MEM_ADDR_SPACE (xop[1]);\n+  rtx loop_reg, addr0, addr1, a_src, a_dest, insn, xas, reg_x;\n+  rtx a_hi8 = NULL_RTX;\n+\n+  if (avr_mem_pgm_p (xop[0]))\n+    return false;\n+\n+  if (!CONST_INT_P (xop[2]))\n+    return false;\n+\n+  count = INTVAL (xop[2]);\n+  if (count <= 0)\n+    return false;\n+\n+  a_src  = XEXP (xop[1], 0);\n+  a_dest = XEXP (xop[0], 0);\n+\n+  /* See if constant fits in 8 bits.  */\n+\n+  loop_mode = (count <= 0x100) ? QImode : HImode;\n+\n+  if (PSImode == GET_MODE (a_src))\n+    {\n+      addr1 = simplify_gen_subreg (HImode, a_src, PSImode, 0);\n+      a_hi8 = simplify_gen_subreg (QImode, a_src, PSImode, 2);\n+    }\n+  else\n+    {\n+      int seg = avr_pgm_segment (as);\n+      \n+      addr1 = a_src;\n+\n+      if (seg > 0\n+          && seg % avr_current_arch->n_segments > 0)\n+        {\n+          a_hi8 = GEN_INT (seg % avr_current_arch->n_segments);\n+        }\n+    }\n+\n+  if (a_hi8\n+      && avr_current_arch->n_segments > 1)\n+    {\n+      emit_move_insn (rampz_rtx, a_hi8 = copy_to_mode_reg (QImode, a_hi8));\n+    }\n+  else if (!ADDR_SPACE_GENERIC_P (as))\n+    {\n+      as = ADDR_SPACE_PGM;\n+    }\n+\n+  xas = GEN_INT (as);\n+\n+  /* Create loop counter register */\n+\n+  loop_reg = copy_to_mode_reg (loop_mode, gen_int_mode (count, loop_mode));\n+\n+  /* Copy pointers into new pseudos - they will be changed */\n+\n+  addr0 = copy_to_mode_reg (HImode, a_dest);\n+  addr1 = copy_to_mode_reg (HImode, addr1);\n+\n+  /* FIXME: Register allocator might come up with spill fails if it is left\n+        on its own.  Thus, we allocate the pointer registers by hand.  */\n+\n+  emit_move_insn (lpm_addr_reg_rtx, addr1);\n+  addr1 = lpm_addr_reg_rtx;\n+\n+  reg_x = gen_rtx_REG (HImode, REG_X);\n+  emit_move_insn (reg_x, addr0);\n+  addr0 = reg_x;\n+\n+  /* FIXME: Register allocator does a bad job and might spill address\n+        register(s) inside the loop leading to additional move instruction\n+        to/from stack which could clobber tmp_reg.  Thus, do *not* emit\n+        load and store as seperate insns.  Instead, we perform the copy\n+        by means of one monolithic insn.  */\n+\n+  if (ADDR_SPACE_GENERIC_P (as))\n+    {\n+      rtx (*fun) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n+        = QImode == loop_mode ? gen_movmem_qi : gen_movmem_hi;\n+\n+      insn = fun (addr0, addr1, xas, loop_reg,\n+                  addr0, addr1, tmp_reg_rtx, loop_reg);\n+    }\n+  else if (as == ADDR_SPACE_PGM)\n+    {\n+      rtx (*fun) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n+        = QImode == loop_mode ? gen_movmem_qi : gen_movmem_hi;\n+\n+      insn = fun (addr0, addr1, xas, loop_reg, addr0, addr1,\n+                  AVR_HAVE_LPMX ? tmp_reg_rtx : lpm_reg_rtx, loop_reg);\n+    }\n+  else\n+    {\n+      rtx (*fun) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n+        = QImode == loop_mode ? gen_movmem_qi_elpm : gen_movmem_hi_elpm;\n+      \n+      insn = fun (addr0, addr1, xas, loop_reg, addr0, addr1,\n+                  AVR_HAVE_ELPMX ? tmp_reg_rtx : lpm_reg_rtx, loop_reg,\n+                  a_hi8, a_hi8, GEN_INT (RAMPZ_ADDR));\n+    }\n+\n+  set_mem_addr_space (SET_SRC (XVECEXP (insn, 0, 0)), as);\n+  emit_insn (insn);\n+\n   return true;\n }\n \n \n+/* Print assembler for movmem_qi, movmem_hi insns...\n+       $0, $4 : & dest\n+       $1, $5 : & src\n+       $2     : Address Space\n+       $3, $7 : Loop register\n+       $6     : Scratch register\n+\n+   ...and movmem_qi_elpm, movmem_hi_elpm insns.\n+   \n+       $8, $9 : hh8 (& src)\n+       $10    : RAMPZ_ADDR\n+*/\n+\n+const char*\n+avr_out_movmem (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n+{\n+  addr_space_t as = (addr_space_t) INTVAL (xop[2]);\n+  enum machine_mode loop_mode = GET_MODE (xop[3]);\n+\n+  bool sbiw_p = test_hard_reg_class (ADDW_REGS, xop[3]);\n+\n+  gcc_assert (REG_X == REGNO (xop[0])\n+              && REG_Z == REGNO (xop[1]));\n+\n+  if (plen)\n+    *plen = 0;\n+\n+  /* Loop label */\n+\n+  avr_asm_len (\"0:\", xop, plen, 0);\n+\n+  /* Load with post-increment */\n+\n+  switch (as)\n+    {\n+    default:\n+      gcc_unreachable();\n+      \n+    case ADDR_SPACE_GENERIC:\n+\n+      avr_asm_len (\"ld %6,%a1+\", xop, plen, 1);\n+      break;\n+      \n+    case ADDR_SPACE_PGM:\n+\n+      if (AVR_HAVE_LPMX)\n+        avr_asm_len (\"lpm %6,%a1+\", xop, plen, 1);\n+      else\n+        avr_asm_len (\"lpm\" CR_TAB\n+                     \"adiw %1,1\", xop, plen, 2);\n+      break;\n+      \n+    case ADDR_SPACE_PGM1:\n+    case ADDR_SPACE_PGM2:\n+    case ADDR_SPACE_PGM3:\n+    case ADDR_SPACE_PGM4:\n+    case ADDR_SPACE_PGM5:\n+    case ADDR_SPACE_PGMX:\n+\n+      if (AVR_HAVE_ELPMX)\n+        avr_asm_len (\"elpm %6,%a1+\", xop, plen, 1);\n+      else\n+        avr_asm_len (\"elpm\" CR_TAB\n+                     \"adiw %1,1\", xop, plen, 2);\n+      \n+      if (as == ADDR_SPACE_PGMX\n+          && !AVR_HAVE_ELPMX)\n+        {\n+          avr_asm_len (\"adc %8,__zero_reg__\" CR_TAB\n+                       \"out __RAMPZ__,%8\", xop, plen, 2);\n+        }\n+      \n+      break;\n+    }\n+\n+  /* Store with post-increment */\n+\n+  avr_asm_len (\"st %a0+,%6\", xop, plen, 1);\n+\n+  /* Decrement loop-counter and set Z-flag */\n+\n+  if (QImode == loop_mode)\n+    {\n+      avr_asm_len (\"dec %3\", xop, plen, 1);\n+    }\n+  else if (sbiw_p)\n+    {\n+      avr_asm_len (\"sbiw %3,1\", xop, plen, 1);\n+    }\n+  else\n+    {\n+      avr_asm_len (\"subi %A3,1\" CR_TAB\n+                   \"sbci %B3,0\", xop, plen, 2);\n+    }\n+\n+  /* Loop until zero */\n+  \n+  return avr_asm_len (\"brne 0b\", xop, plen, 1);\n+}\n+\n+\n+\f\n /* Helper for __builtin_avr_delay_cycles */\n \n static void"}, {"sha": "30bca35349a38a77025a8c70f9a66fb26c77778d", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -54,6 +54,9 @@ struct base_arch_s {\n   /* Default start of data section address for architecture.  */\n   int default_data_section_start;\n \n+  /* Number of 64k segments in the flash.  */\n+  int n_segments;\n+\n   const char *const macro;\n   \n   /* Architecture name.  */\n@@ -131,6 +134,8 @@ extern const struct base_arch_s avr_arch_types[];\n #define AVR_HAVE_MUL (avr_current_arch->have_mul)\n #define AVR_HAVE_MOVW (avr_current_arch->have_movw_lpmx)\n #define AVR_HAVE_LPMX (avr_current_arch->have_movw_lpmx)\n+#define AVR_HAVE_ELPM (avr_current_arch->have_elpm)\n+#define AVR_HAVE_ELPMX (avr_current_arch->have_elpmx)\n #define AVR_HAVE_RAMPZ (avr_current_arch->have_elpm)\n #define AVR_HAVE_EIJMP_EICALL (avr_current_arch->have_eijmp_eicall)\n #define AVR_HAVE_8BIT_SP (avr_current_device->short_sp || TARGET_TINY_STACK)\n@@ -393,6 +398,12 @@ typedef struct avr_args {\n \n \n #define ADDR_SPACE_PGM  1\n+#define ADDR_SPACE_PGM1 2\n+#define ADDR_SPACE_PGM2 3\n+#define ADDR_SPACE_PGM3 4\n+#define ADDR_SPACE_PGM4 5\n+#define ADDR_SPACE_PGM5 6\n+#define ADDR_SPACE_PGMX 7\n \n #define REGISTER_TARGET_PRAGMAS()                                       \\\n   do {                                                                  \\\n@@ -645,3 +656,5 @@ struct GTY(()) machine_function\n #define PUSH_ROUNDING(X)\t(X)\n \n #define ACCUMULATE_OUTGOING_ARGS avr_accumulate_outgoing_args()\n+\n+#define INIT_EXPANDERS avr_init_expanders()"}, {"sha": "9e7fc9a920483f2a4ea17856396faefbb09877d6", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 294, "deletions": 139, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -47,11 +47,15 @@\n    (ZERO_REGNO\t1)\t; zero register r1\n    \n    (SREG_ADDR   0x5F)\n+   (SP_ADDR     0x5D)\n+\n+   ;; Register holding the address' high part when loading via ELPM\n    (RAMPZ_ADDR  0x5B)\n    ])\n \n (define_c_enum \"unspec\"\n   [UNSPEC_STRLEN\n+   UNSPEC_MOVMEM\n    UNSPEC_INDEX_JMP\n    UNSPEC_FMUL\n    UNSPEC_FMULS\n@@ -128,6 +132,7 @@\n   \"out_bitop, out_plus, out_plus_noclobber, addto_sp,\n    tsthi, tstpsi, tstsi, compare, call,\n    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,\n+   xload, movmem,\n    ashlqi, ashrqi, lshrqi,\n    ashlhi, ashrhi, lshrhi,\n    ashlsi, ashrsi, lshrsi,\n@@ -137,15 +142,14 @@\n \n ;; Flavours of instruction set architecture (ISA), used in enabled attribute\n \n-;; mov:   ISA has no MOVW\n-;; movw:  ISA has MOVW\n-;; rjmp:  ISA has no CALL/JMP\n-;; jmp:   ISA has CALL/JMP\n-;; ijmp:  ISA has no EICALL/EIJMP\n-;; eijmp: ISA has EICALL/EIJMP\n+;; mov  : ISA has no MOVW                movw  : ISA has MOVW\n+;; rjmp : ISA has no CALL/JMP            jmp   : ISA has CALL/JMP\n+;; ijmp : ISA has no EICALL/EIJMP        eijmp : ISA has EICALL/EIJMP\n+;; lpm  : ISA has no LPMX                lpmx  : ISA has LPMX\n+;; elpm : ISA has ELPM but no ELPMX      elpmx : ISA has ELPMX\n \n (define_attr \"isa\"\n-  \"mov,movw, rjmp,jmp, ijmp,eijmp,\n+  \"mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx,\n    standard\"\n   (const_string \"standard\"))\n \n@@ -176,6 +180,22 @@\n          (and (eq_attr \"isa\" \"eijmp\")\n               (match_test \"AVR_HAVE_EIJMP_EICALL\"))\n          (const_int 1)\n+\n+         (and (eq_attr \"isa\" \"lpm\")\n+              (match_test \"!AVR_HAVE_LPMX\"))\n+         (const_int 1)\n+\n+         (and (eq_attr \"isa\" \"lpmx\")\n+              (match_test \"AVR_HAVE_LPMX\"))\n+         (const_int 1)\n+\n+         (and (eq_attr \"isa\" \"elpm\")\n+              (match_test \"AVR_HAVE_ELPM && !AVR_HAVE_ELPMX\"))\n+         (const_int 1)\n+\n+         (and (eq_attr \"isa\" \"elpmx\")\n+              (match_test \"AVR_HAVE_ELPMX\"))\n+         (const_int 1)\n          ] (const_int 0)))\n \n \n@@ -243,12 +263,10 @@\n ;; even though its function is identical to that in builtins.c\n \n (define_expand \"nonlocal_goto\"\n-  [\n-  (use (match_operand 0 \"general_operand\"))\n-  (use (match_operand 1 \"general_operand\"))\n-  (use (match_operand 2 \"general_operand\"))\n-  (use (match_operand 3 \"general_operand\"))\n-  ]\n+  [(use (match_operand 0 \"general_operand\"))\n+   (use (match_operand 1 \"general_operand\"))\n+   (use (match_operand 2 \"general_operand\"))\n+   (use (match_operand 3 \"general_operand\"))]\n   \"\"\n {\n   rtx r_label = copy_to_reg (operands[1]);\n@@ -333,7 +351,7 @@\n     set_mem_addr_space (operands[1], ADDR_SPACE_PGM);\n   })\n     \n-(define_insn \"*load.<mode>.libgcc\"\n+(define_insn \"load_<mode>_libgcc\"\n   [(set (reg:MOVMODE 22)\n         (match_operand:MOVMODE 0 \"memory_operand\" \"m,m\"))]\n   \"avr_load_libgcc_p (operands[0])\n@@ -348,6 +366,135 @@\n    (set_attr \"cc\" \"clobber\")])\n \n \n+(define_insn_and_split \"xload8_A\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (match_operand:QI 1 \"memory_operand\"    \"m\"))\n+   (clobber (reg:HI REG_Z))]\n+  \"can_create_pseudo_p()\n+   && avr_mem_pgmx_p (operands[1])\n+   && REG_P (XEXP (operands[1], 0))\"\n+  { gcc_unreachable(); }\n+  \"&& 1\"\n+  [(clobber (const_int 0))]\n+  {\n+    rtx insn, addr = XEXP (operands[1], 0);\n+    rtx hi8 = gen_reg_rtx (QImode);\n+    rtx reg_z = gen_rtx_REG (HImode, REG_Z);\n+\n+    emit_move_insn (reg_z, simplify_gen_subreg (HImode, addr, PSImode, 0));\n+    emit_move_insn (hi8, simplify_gen_subreg (QImode, addr, PSImode, 2));\n+\n+    insn = emit_insn (gen_xload_8 (operands[0], hi8));\n+    set_mem_addr_space (SET_SRC (single_set (insn)),\n+                                 MEM_ADDR_SPACE (operands[1]));\n+    DONE;\n+  })\n+\n+(define_insn_and_split \"xload<mode>_A\"\n+  [(set (match_operand:MOVMODE 0 \"register_operand\" \"=r\")\n+        (match_operand:MOVMODE 1 \"memory_operand\"    \"m\"))\n+   (clobber (reg:QI 21))\n+   (clobber (reg:HI REG_Z))]\n+  \"QImode != <MODE>mode\n+   && can_create_pseudo_p()\n+   && avr_mem_pgmx_p (operands[1])\n+   && REG_P (XEXP (operands[1], 0))\"\n+  { gcc_unreachable(); }\n+  \"&& 1\"\n+  [(clobber (const_int 0))]\n+  {\n+    rtx addr = XEXP (operands[1], 0);\n+    rtx reg_z = gen_rtx_REG (HImode, REG_Z);\n+    rtx addr_hi8 = simplify_gen_subreg (QImode, addr, PSImode, 2);\n+    addr_space_t as = MEM_ADDR_SPACE (operands[1]);\n+    rtx hi8, insn;\n+\n+    emit_move_insn (reg_z, simplify_gen_subreg (HImode, addr, PSImode, 0));\n+\n+    if (avr_xload_libgcc_p (<MODE>mode))\n+      {\n+        emit_move_insn (gen_rtx_REG (QImode, 21), addr_hi8);\n+        insn = emit_insn (gen_xload_<mode>_libgcc ());\n+        emit_move_insn (operands[0], gen_rtx_REG (<MODE>mode, 22));\n+      }\n+    else if (avr_current_arch->n_segments == 1\n+             && GET_MODE_SIZE (<MODE>mode) > 2\n+             && !AVR_HAVE_LPMX)\n+      {\n+        rtx src = gen_rtx_MEM (<MODE>mode, reg_z);\n+\n+        as = ADDR_SPACE_PGM;\n+        insn = emit_insn (gen_load_<mode>_libgcc (src));\n+        emit_move_insn (operands[0], gen_rtx_REG (<MODE>mode, 22));\n+      }\n+    else\n+      {\n+        hi8 = gen_reg_rtx (QImode);\n+        emit_move_insn (hi8, addr_hi8);\n+        insn = emit_insn (gen_xload_<mode> (operands[0], hi8));\n+      }\n+\n+    set_mem_addr_space (SET_SRC (single_set (insn)), as);\n+\n+    DONE;\n+  })\n+\n+;; Move value from address space pgmx to a register\n+;; These insns must be prior to respective generic move insn.\n+\n+(define_insn \"xload_8\"\n+  [(set (match_operand:QI 0 \"register_operand\"                    \"=r\")\n+        (mem:QI (lo_sum:PSI (match_operand:QI 1 \"register_operand\" \"r\")\n+                            (reg:HI REG_Z))))]\n+  \"\"\n+  {\n+    return avr_out_xload (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"xload\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; \"xload_hi_libgcc\"\n+;; \"xload_psi_libgcc\"\n+;; \"xload_si_libgcc\"\n+;; \"xload_sf_libgcc\"\n+(define_insn \"xload_<mode>_libgcc\"\n+  [(set (reg:MOVMODE 22)\n+        (mem:MOVMODE (lo_sum:PSI (reg:QI 21)\n+                                 (reg:HI REG_Z))))\n+   (clobber (reg:QI 21))\n+   (clobber (reg:HI REG_Z))]\n+  \"<MODE>mode != QImode\n+   && avr_xload_libgcc_p (<MODE>mode)\"\n+  {\n+    rtx x_bytes = GEN_INT (GET_MODE_SIZE (<MODE>mode));\n+\n+    /* Devices with ELPM* also have CALL.  */\n+\n+    output_asm_insn (\"call __xload_%0\", &x_bytes);\n+    return \"\";\n+  }\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; \"xload_hi\"\n+;; \"xload_psi\"\n+;; \"xload_si\"\n+;; \"xload_sf\"\n+(define_insn \"xload_<mode>\"\n+  [(set (match_operand:MOVMODE 0 \"register_operand\"                    \"=r\")\n+        (mem:MOVMODE (lo_sum:PSI (match_operand:QI 1 \"register_operand\" \"r\")\n+                                 (reg:HI REG_Z))))\n+   (clobber (scratch:HI))\n+   (clobber (reg:HI REG_Z))]\n+  \"<MODE>mode != QImode\n+   && !avr_xload_libgcc_p (<MODE>mode)\"\n+  {\n+    return avr_out_xload (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"xload\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n ;; General move expanders\n \n ;; \"movqi\"\n@@ -375,6 +522,21 @@\n         operands[1] = src = copy_to_mode_reg (<MODE>mode, src);\n       }\n \n+  if (avr_mem_pgmx_p (src))\n+    {\n+      rtx addr = XEXP (src, 0);\n+\n+      if (!REG_P (addr))\n+        src = replace_equiv_address (src, copy_to_mode_reg (PSImode, addr));\n+\n+      if (QImode == <MODE>mode)\n+        emit_insn (gen_xload8_A (dest, src));\n+      else\n+        emit_insn (gen_xload<mode>_A (dest, src));\n+\n+      DONE;\n+    }\n+\n     if (avr_load_libgcc_p (src))\n       {\n         /* For the small devices, do loads per libgcc call.  */\n@@ -673,171 +835,164 @@\n \n ;;=========================================================================\n ;; move string (like memcpy)\n-;; implement as RTL loop\n \n (define_expand \"movmemhi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-          (match_operand:BLK 1 \"memory_operand\" \"\"))\n-          (use (match_operand:HI 2 \"const_int_operand\" \"\"))\n-          (use (match_operand:HI 3 \"const_int_operand\" \"\"))])]\n+                   (match_operand:BLK 1 \"memory_operand\" \"\"))\n+              (use (match_operand:HI 2 \"const_int_operand\" \"\"))\n+              (use (match_operand:HI 3 \"const_int_operand\" \"\"))])]\n   \"\"\n-  \"{\n-  int prob;\n-  HOST_WIDE_INT count;\n-  enum machine_mode mode;\n-  rtx label = gen_label_rtx ();\n-  rtx loop_reg;\n-  rtx jump, src;\n-\n-  /* Copy pointers into new psuedos - they will be changed.  */\n-  rtx addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n-  rtx addr1 = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n-\n-  /* Create rtx for tmp register - we use this as scratch.  */\n-  rtx tmp_reg_rtx  = gen_rtx_REG (QImode, TMP_REGNO);\n-\n-  if (avr_mem_pgm_p (operands[0]))\n-    DONE;\n-\n-  if (GET_CODE (operands[2]) != CONST_INT)\n+  {\n+    if (avr_emit_movmemhi (operands))\n+      DONE;\n+    \n     FAIL;\n+  })\n \n-  count = INTVAL (operands[2]);\n-  if (count <= 0)\n-    FAIL;\n+(define_mode_attr MOVMEM_r_d [(QI \"r\")\n+                              (HI \"d\")])\n+\n+;; $0, $4 : & dest\n+;; $1, $5 : & src\n+;; $2     : Address Space\n+;; $3, $7 : Loop register\n+;; $6     : Scratch register\n+\n+;; \"movmem_qi\"\n+;; \"movmem_hi\"\n+(define_insn \"movmem_<mode>\"\n+  [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"x\"))\n+        (mem:BLK (match_operand:HI 1 \"register_operand\" \"z\")))\n+   (unspec [(match_operand:QI 2 \"const_int_operand\"     \"LP\")]\n+           UNSPEC_MOVMEM)\n+   (use (match_operand:QIHI 3 \"register_operand\"       \"<MOVMEM_r_d>\"))\n+   (clobber (match_operand:HI 4 \"register_operand\"     \"=0\"))\n+   (clobber (match_operand:HI 5 \"register_operand\"     \"=1\"))\n+   (clobber (match_operand:QI 6 \"register_operand\"     \"=&r\"))\n+   (clobber (match_operand:QIHI 7 \"register_operand\"   \"=3\"))]\n+  \"\"\n+  {\n+    return avr_out_movmem (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"movmem\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Ditto and\n+;; $8, $9 : hh8 (& src)\n+;; $10    : RAMPZ_ADDR\n+\n+;; \"movmem_qi_elpm\"\n+;; \"movmem_hi_elpm\"\n+(define_insn \"movmem_<mode>_elpm\"\n+  [(set (mem:BLK (match_operand:HI 0 \"register_operand\"             \"x\"))\n+        (mem:BLK (lo_sum:PSI (match_operand:QI 8 \"register_operand\" \"r\")\n+                             (match_operand:HI 1 \"register_operand\" \"z\"))))\n+   (unspec [(match_operand:QI 2 \"const_int_operand\"                 \"n\")]\n+           UNSPEC_MOVMEM)\n+   (use (match_operand:QIHI 3 \"register_operand\"                   \"<MOVMEM_r_d>\"))\n+   (clobber (match_operand:HI 4 \"register_operand\"                 \"=0\"))\n+   (clobber (match_operand:HI 5 \"register_operand\"                 \"=1\"))\n+   (clobber (match_operand:QI 6 \"register_operand\"                 \"=&r\"))\n+   (clobber (match_operand:QIHI 7 \"register_operand\"               \"=3\"))\n+   (clobber (match_operand:QI 9 \"register_operand\"                 \"=8\"))\n+   (clobber (mem:QI (match_operand:QI 10 \"io_address_operand\"       \"n\")))]\n+  \"\"\n+  {\n+    return avr_out_movmem (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"movmem\")\n+   (set_attr \"cc\" \"clobber\")])\n \n-  /* Work out branch probability for latter use.  */\n-  prob = REG_BR_PROB_BASE - REG_BR_PROB_BASE / count;\n-\n-  /* See if constant fit 8 bits.  */\n-  mode = (count < 0x100) ? QImode : HImode;\n-  /* Create loop counter register.  */\n-  loop_reg = copy_to_mode_reg (mode, gen_int_mode (count, mode));\n-\n-  /* Now create RTL code for move loop.  */\n-  /* Label at top of loop.  */\n-  emit_label (label);\n-\n-  /* Move one byte into scratch and inc pointer.  */\n-  src = gen_rtx_MEM (QImode, addr1);\n-  set_mem_addr_space (src, MEM_ADDR_SPACE (operands[1]));\n-  emit_move_insn (tmp_reg_rtx, src);\n-  emit_move_insn (addr1, gen_rtx_PLUS (Pmode, addr1, const1_rtx));\n-\n-  /* Move to mem and inc pointer.  */\n-  emit_move_insn (gen_rtx_MEM (QImode, addr0), tmp_reg_rtx);\n-  emit_move_insn (addr0, gen_rtx_PLUS (Pmode, addr0, const1_rtx));\n-\n-  /* Decrement count.  */\n-  emit_move_insn (loop_reg, gen_rtx_PLUS (mode, loop_reg, constm1_rtx));\n-\n-  /* Compare with zero and jump if not equal. */\n-  emit_cmp_and_jump_insns (loop_reg, const0_rtx, NE, NULL_RTX, mode, 1,\n-                           label);\n-  /* Set jump probability based on loop count.  */\n-  jump = get_last_insn ();\n-  add_reg_note (jump, REG_BR_PROB, GEN_INT (prob));\n-  DONE;\n-}\")\n \n-;; =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2\n+;; =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2\n ;; memset (%0, %2, %1)\n \n (define_expand \"setmemhi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n- \t\t   (match_operand 2 \"const_int_operand\" \"\"))\n-\t      (use (match_operand:HI 1 \"const_int_operand\" \"\"))\n-\t      (use (match_operand:HI 3 \"const_int_operand\" \"n\"))\n-\t      (clobber (match_scratch:HI 4 \"\"))\n-\t      (clobber (match_dup 5))])]\n+                   (match_operand 2 \"const_int_operand\" \"\"))\n+              (use (match_operand:HI 1 \"const_int_operand\" \"\"))\n+              (use (match_operand:HI 3 \"const_int_operand\" \"\"))\n+              (clobber (match_scratch:HI 4 \"\"))\n+              (clobber (match_dup 5))])]\n   \"\"\n-  \"{\n-  rtx addr0;\n-  enum machine_mode mode;\n+  {\n+    rtx addr0;\n+    enum machine_mode mode;\n \n-  /* If value to set is not zero, use the library routine.  */\n-  if (operands[2] != const0_rtx)\n-    FAIL;\n+    /* If value to set is not zero, use the library routine.  */\n+    if (operands[2] != const0_rtx)\n+      FAIL;\n \n-  if (!CONST_INT_P (operands[1]))\n-    FAIL;\n+    if (!CONST_INT_P (operands[1]))\n+      FAIL;\n+\n+    mode = u8_operand (operands[1], VOIDmode) ? QImode : HImode;\n+    operands[5] = gen_rtx_SCRATCH (mode);\n+    operands[1] = copy_to_mode_reg (mode,\n+                                    gen_int_mode (INTVAL (operands[1]), mode));\n+    addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+    operands[0] = gen_rtx_MEM (BLKmode, addr0);\n+  })\n \n-  mode = u8_operand (operands[1], VOIDmode) ? QImode : HImode;\n-  operands[5] = gen_rtx_SCRATCH (mode);\n-  operands[1] = copy_to_mode_reg (mode,\n-                                  gen_int_mode (INTVAL (operands[1]), mode));\n-  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n-  operands[0] = gen_rtx_MEM (BLKmode, addr0);\n-}\")\n \n (define_insn \"*clrmemqi\"\n   [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"e\"))\n-\t(const_int 0))\n+        (const_int 0))\n    (use (match_operand:QI 1 \"register_operand\" \"r\"))\n    (use (match_operand:QI 2 \"const_int_operand\" \"n\"))\n    (clobber (match_scratch:HI 3 \"=0\"))\n    (clobber (match_scratch:QI 4 \"=&1\"))]\n   \"\"\n-  \"st %a0+,__zero_reg__\n-        dec %1\n-\tbrne .-6\"\n+  \"0:\\;st %a0+,__zero_reg__\\;dec %1\\;brne 0b\"\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"clobber\")])\n \n+\n (define_insn \"*clrmemhi\"\n   [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"e,e\"))\n-\t(const_int 0))\n+        (const_int 0))\n    (use (match_operand:HI 1 \"register_operand\" \"!w,d\"))\n    (use (match_operand:HI 2 \"const_int_operand\" \"n,n\"))\n    (clobber (match_scratch:HI 3 \"=0,0\"))\n    (clobber (match_scratch:HI 4 \"=&1,&1\"))]\n   \"\"\n-  \"*{\n-     if (which_alternative==0)\n-       return (AS2 (st,%a0+,__zero_reg__) CR_TAB\n-\t       AS2 (sbiw,%A1,1) CR_TAB\n-\t       AS1 (brne,.-6));\n-     else\n-       return (AS2 (st,%a0+,__zero_reg__) CR_TAB\n-\t       AS2 (subi,%A1,1) CR_TAB\n-\t       AS2 (sbci,%B1,0) CR_TAB\n-\t       AS1 (brne,.-8));\n-}\"\n+  \"@\n+\t0:\\;st %a0+,__zero_reg__\\;sbiw %A1,1\\;brne 0b\n+\t0:\\;st %a0+,__zero_reg__\\;subi %A1,1\\;sbci %B1,0\\;brne 0b\"\n   [(set_attr \"length\" \"3,4\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n \n (define_expand \"strlenhi\"\n-    [(set (match_dup 4)\n-\t  (unspec:HI [(match_operand:BLK 1 \"memory_operand\" \"\")\n-\t\t      (match_operand:QI 2 \"const_int_operand\" \"\")\n-\t\t      (match_operand:HI 3 \"immediate_operand\" \"\")]\n-\t\t     UNSPEC_STRLEN))\n-     (set (match_dup 4) (plus:HI (match_dup 4)\n-\t\t\t\t (const_int -1)))\n-     (set (match_operand:HI 0 \"register_operand\" \"\")\n-\t  (minus:HI (match_dup 4)\n-\t\t    (match_dup 5)))]\n-   \"\"\n-   \"{\n-  rtx addr;\n-  if (operands[2] != const0_rtx)\n-    FAIL;\n-  addr = copy_to_mode_reg (Pmode, XEXP (operands[1],0));\n-  operands[1] = gen_rtx_MEM (BLKmode, addr); \n-  operands[5] = addr;\n-  operands[4] = gen_reg_rtx (HImode);\n-}\")\n+  [(set (match_dup 4)\n+        (unspec:HI [(match_operand:BLK 1 \"memory_operand\" \"\")\n+                    (match_operand:QI 2 \"const_int_operand\" \"\")\n+                    (match_operand:HI 3 \"immediate_operand\" \"\")]\n+                   UNSPEC_STRLEN))\n+   (set (match_dup 4)\n+        (plus:HI (match_dup 4)\n+                 (const_int -1)))\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+        (minus:HI (match_dup 4)\n+                  (match_dup 5)))]\n+  \"\"\n+  {\n+    rtx addr;\n+    if (operands[2] != const0_rtx)\n+      FAIL;\n+    addr = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+    operands[1] = gen_rtx_MEM (BLKmode, addr); \n+    operands[5] = addr;\n+    operands[4] = gen_reg_rtx (HImode);\n+  })\n \n (define_insn \"*strlenhi\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=e\")\n-\t(unspec:HI [(mem:BLK (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t    (const_int 0)\n-\t\t    (match_operand:HI 2 \"immediate_operand\" \"i\")]\n-\t\t   UNSPEC_STRLEN))]\n-  \"\"\n-  \"ld __tmp_reg__,%a0+\n-\ttst __tmp_reg__\n-\tbrne .-6\"\n+  [(set (match_operand:HI 0 \"register_operand\"                      \"=e\")\n+        (unspec:HI [(mem:BLK (match_operand:HI 1 \"register_operand\"  \"0\"))\n+                    (const_int 0)\n+                    (match_operand:HI 2 \"immediate_operand\"          \"i\")]\n+                   UNSPEC_STRLEN))]\n+  \"\"\n+  \"0:\\;ld __tmp_reg__,%a0+\\;tst __tmp_reg__\\;brne 0b\"\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"clobber\")])\n "}, {"sha": "fff34b58464e2f6e7006d4192cc950d13bb8c3d4", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -63,10 +63,11 @@\n        (match_test \"!avr_mem_pgm_p (op)\")))\n \n ;; Return 1 if OP is an \"ordinary\" general operand, i.e. a general\n-;; operand whose load is not handled by a libgcc call.\n+;; operand whose load is not handled by a libgcc call or ELPM.\n (define_predicate \"nox_general_operand\"\n   (and (match_operand 0 \"general_operand\")\n-       (match_test \"!avr_load_libgcc_p (op)\")))\n+       (not (match_test \"avr_load_libgcc_p (op)\"))\n+       (not (match_test \"avr_mem_pgmx_p (op)\"))))\n \n ;; Return 1 if OP is the zero constant for MODE.\n (define_predicate \"const0_operand\""}, {"sha": "86b482f9950f20baf46cd88f30a5da48b2ae19d0", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -1,3 +1,10 @@\n+2011-11-18  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\t* config/avr/t-avr (LIB1ASMFUNCS): Add _xload_2 _xload_3 _xload_4.\n+\t* config/avr/lib1funcs.S (__xload_2, __xload_3, __xload_4):\n+\tNew functions.\n+\n 2011-11-16  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n \t* config/arm/lib1funcs.asm (udivsi3): Add support for divide"}, {"sha": "aee69e50d8e6179c7ffb799c8e9e6c674e3d862d", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -1227,6 +1227,73 @@ ENDF __load_4\n \n #endif /* L_load_3 || L_load_3 */\n \n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Loading n bytes from Flash; n = 2,3,4\n+;; R22... = Flash[R21:Z]\n+;; Clobbers: __tmp_reg__, R21, R30, R31\n+\n+#if (defined (L_xload_2)            \\\n+     || defined (L_xload_3)         \\\n+     || defined (L_xload_4))        \\\n+    && defined (__AVR_HAVE_ELPM__)  \\\n+    && !defined (__AVR_HAVE_ELPMX__)\n+\n+#if !defined (__AVR_HAVE_RAMPZ__)\n+#error Need RAMPZ\n+#endif /* have RAMPZ */\n+\n+;; Destination\n+#define D0  22\n+#define D1  D0+1\n+#define D2  D0+2\n+#define D3  D0+3\n+\n+;; Register containing bits 16+ of the address\n+\n+#define HHI8  21\n+\n+.macro  .xload dest, n\n+    elpm\n+    mov     \\dest, r0\n+.if \\dest != D0+\\n-1\n+    adiw    r30, 1\n+    adc     HHI8, __zero_reg__\n+    out     __RAMPZ__, HHI8\n+.endif\n+.endm\n+\n+#if defined (L_xload_2)\n+DEFUN __xload_2\n+    out     __RAMPZ__, HHI8\n+    .xload D0, 2\n+    .xload D1, 2\n+    ret\n+ENDF __xload_2\n+#endif /* L_xload_2 */\n+\n+#if defined (L_xload_3)\n+DEFUN __xload_3\n+    out     __RAMPZ__, HHI8\n+    .xload D0, 3\n+    .xload D1, 3\n+    .xload D2, 3\n+    ret\n+ENDF __xload_3\n+#endif /* L_xload_3 */\n+\n+#if defined (L_xload_4)\n+DEFUN __xload_4\n+    out     __RAMPZ__, HHI8\n+    .xload D0, 4\n+    .xload D1, 4\n+    .xload D2, 4\n+    .xload D3, 4\n+    ret\n+ENDF __xload_4\n+#endif /* L_xload_4 */\n+\n+#endif /* L_xload_{2|3|4} && ELPM */\n+\n \f\n .section .text.libgcc.builtins, \"ax\", @progbits\n "}, {"sha": "5ebb17e4eb5805fbaeec7e818574048cdfacd454", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=7bc6df2ca1e069c9cd2b58d5b0560d2bd7ffe703", "patch": "@@ -22,6 +22,7 @@ LIB1ASMFUNCS = \\\n \t_tablejump \\\n \t_tablejump_elpm \\\n \t_load_3 _load_4 \\\n+\t_xload_2 _xload_3 _xload_4 \\\n \t_copy_data \\\n \t_clear_bss \\\n \t_ctors \\"}]}