{"sha": "c033690d7e2108d2b7ddbb37d488a6f1519eedff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAzMzY5MGQ3ZTIxMDhkMmI3ZGRiYjM3ZDQ4OGE2ZjE1MTllZWRmZg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-09T21:40:48Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-09T21:40:48Z"}, "message": "reload.c (find_reloads): Don't clear badop if we have a winreg alternative...\n\n\t* reload.c (find_reloads): Don't clear badop if we have a\n\twinreg alternative, but not win, and the class only has fixed\n\tregs.\n\t* hard-reg-set.h (class_only_fixed_regs): Declare.\n\t* reginfo.c (class_only_fixed_regs): New array.\n\t(init_reg_sets_1): Initialize it.\n\t* config/arm/arm.md (arm_addsi3, thumb1_addsi3, arm_subsi3_insn): Don't\n\tdiscourage alternatives using the stack pointer.\n\ntestsuite/\n\t* gcc.dg/pr32370.c: Allow another kind of error message.\n\nFrom-SVN: r162019", "tree": {"sha": "0f4ba6c4f6978df7d77d7f9b7c320a76b3712099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f4ba6c4f6978df7d77d7f9b7c320a76b3712099"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c033690d7e2108d2b7ddbb37d488a6f1519eedff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c033690d7e2108d2b7ddbb37d488a6f1519eedff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c033690d7e2108d2b7ddbb37d488a6f1519eedff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c033690d7e2108d2b7ddbb37d488a6f1519eedff/comments", "author": null, "committer": null, "parents": [{"sha": "e8edaf9523c61dfbdeac886069badf12ff981973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8edaf9523c61dfbdeac886069badf12ff981973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8edaf9523c61dfbdeac886069badf12ff981973"}], "stats": {"total": 62, "additions": 45, "deletions": 17}, "files": [{"sha": "a3a28a75ea6ab6b0e2d5d790c61e1f7714f62c3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c033690d7e2108d2b7ddbb37d488a6f1519eedff", "patch": "@@ -1,3 +1,14 @@\n+2010-07-09  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* reload.c (find_reloads): Don't clear badop if we have a\n+\twinreg alternative, but not win, and the class only has fixed\n+\tregs.\n+\t* hard-reg-set.h (class_only_fixed_regs): Declare.\n+\t* reginfo.c (class_only_fixed_regs): New array.\n+\t(init_reg_sets_1): Initialize it.\n+\t* config/arm/arm.md (arm_addsi3, thumb1_addsi3, arm_subsi3_insn): Don't\n+\tdiscourage alternatives using the stack pointer.\n+\n 2010-07-09  Richard Guenther  <rguenther@suse.de>\n \n \t* gimple.c (struct type_fixup_s): New struct and VEC type."}, {"sha": "6f20aea7fc96a2b90c52a658d70e38e77a2b742b", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=c033690d7e2108d2b7ddbb37d488a6f1519eedff", "patch": "@@ -610,9 +610,9 @@\n ;;  (plus (reg rN) (reg sp)) into (reg rN).  In this case reload will\n ;; put the duplicated register first, and not try the commutative version.\n (define_insn_and_split \"*arm_addsi3\"\n-  [(set (match_operand:SI          0 \"s_register_operand\" \"=r, !k, r,r, !k,r\")\n-\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"%rk,!k, r,rk,!k,rk\")\n-\t\t (match_operand:SI 2 \"reg_or_int_operand\" \"rI, rI,!k,L, L,?n\")))]\n+  [(set (match_operand:SI          0 \"s_register_operand\" \"=r, k,r,r, k,r\")\n+\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"%rk,k,r,rk,k,rk\")\n+\t\t (match_operand:SI 2 \"reg_or_int_operand\" \"rI,rI,k,L, L,?n\")))]\n   \"TARGET_32BIT\"\n   \"@\n    add%?\\\\t%0, %1, %2\n@@ -637,14 +637,10 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-;; Register group 'k' is a single register group containing only the stack\n-;; register.  Trying to reload it will always fail catastrophically,\n-;; so never allow those alternatives to match if reloading is needed.\n-\n (define_insn_and_split \"*thumb1_addsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=l,l,l,*rk,*hk,l,!k,l,l\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,l,*0,*0,!k,!k,0,l\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"I,J,lL,*hk,*rk,!M,!O,Pa,Pb\")))]\n+  [(set (match_operand:SI          0 \"register_operand\" \"=l,l,l,*rk,*hk,l,k,l,l\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,l,*0,*0,k,k,0,l\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"I,J,lL,*hk,*rk,M,O,Pa,Pb\")))]\n   \"TARGET_THUMB1\"\n   \"*\n    static const char * const asms[] = \n@@ -1089,8 +1085,8 @@\n ; ??? Check Thumb-2 split length\n (define_insn_and_split \"*arm_subsi3_insn\"\n   [(set (match_operand:SI           0 \"s_register_operand\" \"=r,r,rk,r,r\")\n-\t(minus:SI (match_operand:SI 1 \"reg_or_int_operand\" \"rI,r,!k,?n,r\")\n-\t\t  (match_operand:SI 2 \"reg_or_int_operand\" \"r,rI, r, r,?n\")))]\n+\t(minus:SI (match_operand:SI 1 \"reg_or_int_operand\" \"rI,r,k,?n,r\")\n+\t\t  (match_operand:SI 2 \"reg_or_int_operand\" \"r,rI,r, r,?n\")))]\n   \"TARGET_32BIT\"\n   \"@\n    rsb%?\\\\t%0, %2, %1"}, {"sha": "1e7972855231960d8f4a5c093df8c9ca91e8da76", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=c033690d7e2108d2b7ddbb37d488a6f1519eedff", "patch": "@@ -643,6 +643,10 @@ extern int inv_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n \n extern HARD_REG_SET reg_class_contents[N_REG_CLASSES];\n \n+/* For each reg class, a boolean saying whether the class contains only\n+   fixed registers.  */\n+extern bool class_only_fixed_regs[N_REG_CLASSES];\n+\n /* For each reg class, number of regs it contains.  */\n \n extern unsigned int reg_class_size[N_REG_CLASSES];"}, {"sha": "40f21d131a1fe05c9a88ae85e62d0d3ced433ad0", "filename": "gcc/reginfo.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=c033690d7e2108d2b7ddbb37d488a6f1519eedff", "patch": "@@ -141,6 +141,10 @@ int inv_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n /* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n HARD_REG_SET reg_class_contents[N_REG_CLASSES];\n \n+/* For each reg class, a boolean saying whether the class contains only\n+   fixed registers.  */\n+bool class_only_fixed_regs[N_REG_CLASSES];\n+\n /* The same information, but as an array of unsigned ints.  We copy from\n    these unsigned ints to the table above.  We do this so the tm.h files\n    do not have to be aware of the wordsize for machines with <= 64 regs.\n@@ -421,9 +425,17 @@ init_reg_sets_1 (void)\n \n   memset (reg_class_size, 0, sizeof reg_class_size);\n   for (i = 0; i < N_REG_CLASSES; i++)\n-    for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-      if (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n-\treg_class_size[i]++;\n+    {\n+      bool any_nonfixed = false;\n+      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\t\n+\tif (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n+\t  {\n+\t    reg_class_size[i]++;\n+\t    if (!fixed_regs[j])\n+\t      any_nonfixed = true;\n+\t  }\n+      class_only_fixed_regs[i] = !any_nonfixed;\n+    }\n \n   /* Initialize the table of subunions.\n      reg_class_subunion[I][J] gets the largest-numbered reg-class"}, {"sha": "6301f9ada8b73329393c51552fea153fbbd9ad8a", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c033690d7e2108d2b7ddbb37d488a6f1519eedff", "patch": "@@ -3470,7 +3470,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t  /* If this operand could be handled with a reg,\n \t     and some reg is allowed, then this operand can be handled.  */\n-\t  if (winreg && this_alternative[i] != NO_REGS)\n+\t  if (winreg && this_alternative[i] != NO_REGS\n+\t      && (win || !class_only_fixed_regs[this_alternative[i]]))\n \t    badop = 0;\n \n \t  /* Record which operands fit this alternative.  */"}, {"sha": "77e4d9d19a81680cb858e9940ab092b3d04b2ee5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c033690d7e2108d2b7ddbb37d488a6f1519eedff", "patch": "@@ -1,3 +1,7 @@\n+2010-07-09  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* gcc.dg/pr32370.c: Allow another kind of error message.\n+\n 2010-07-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/atomic3.adb: New test."}, {"sha": "fc3d724e6c48134e6c0bea1548b958f17f30b8a5", "filename": "gcc/testsuite/gcc.dg/pr32370.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Ftestsuite%2Fgcc.dg%2Fpr32370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c033690d7e2108d2b7ddbb37d488a6f1519eedff/gcc%2Ftestsuite%2Fgcc.dg%2Fpr32370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr32370.c?ref=c033690d7e2108d2b7ddbb37d488a6f1519eedff", "patch": "@@ -19,7 +19,7 @@ unsigned int\n foo (TYPE port)\n {\n   unsigned int v;\n-  __asm__ __volatile__ (\"\" : C (v) : \"Nd\" (port));\t/* { dg-error \"while reloading\\|has impossible\" } */\n+  __asm__ __volatile__ (\"\" : C (v) : \"Nd\" (port));\t/* { dg-error \"while reloading\\|has impossible\\|inconsistent operand constraints\" } */\n   return v;\n }\n "}]}