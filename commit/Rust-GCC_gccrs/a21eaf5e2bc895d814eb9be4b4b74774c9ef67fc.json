{"sha": "a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxZWFmNWUyYmM4OTVkODE0ZWI5YmU0YjRiNzQ3NzRjOWVmNjdmYw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2010-09-01T10:13:07Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2010-09-01T10:13:07Z"}, "message": "stormy16.c: Use REG_P, MEM_P and CONST_INT_P where appropriate.\n\n        * config/stormy16/stormy16.c: Use REG_P, MEM_P and CONST_INT_P\n        where appropriate.\n        (xstormy16_legitimate_address_p): Use true and false instead of 1\n        and 0.\n        (xstormy16_expand_prologue): Delete unused local variable 'insn'.\n        (xstormy16_function_arg): Use FIRST_ARGUMENT_REGNUM in place of\n        magic constant 2.\n        (xstormy16_expand_call): Fix comment at start of function.\n\nFrom-SVN: r163722", "tree": {"sha": "f46e7dd7597dc9d1fde45865adc7b0e4c23c1e66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f46e7dd7597dc9d1fde45865adc7b0e4c23c1e66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "166d08bddeffca222328dfb9806418910fe83729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/166d08bddeffca222328dfb9806418910fe83729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/166d08bddeffca222328dfb9806418910fe83729"}], "stats": {"total": 172, "additions": 91, "deletions": 81}, "files": [{"sha": "355d4eaaaa25ac7ac289c77658a16f0e78333ef6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc", "patch": "@@ -1,3 +1,14 @@\n+2010-09-01  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/stormy16/stormy16.c: Use REG_P, MEM_P and CONST_INT_P\n+\twhere appropriate.\n+\t(xstormy16_legitimate_address_p): Use true and false instead of 1\n+\tand 0.\n+\t(xstormy16_expand_prologue): Delete unused local variable 'insn'.\n+\t(xstormy16_function_arg): Use FIRST_ARGUMENT_REGNUM in place of\n+\tmagic constant 2.\n+\t(xstormy16_expand_call): Fix comment at start of function.\n+\n 2010-09-01  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rx/rx.c (rx_expand_prologue): Do not adjust frame size"}, {"sha": "c4f1c1b4186e32ff402c8bbd9e261957778c023e", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=a21eaf5e2bc895d814eb9be4b4b74774c9ef67fc", "patch": "@@ -104,7 +104,7 @@ xstormy16_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n static int\n xstormy16_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n-  return (GET_CODE (x) == CONST_INT ? 2\n+  return (CONST_INT_P (x) ? 2\n \t  : GET_CODE (x) == PLUS ? 7\n \t  : 5);\n }\n@@ -292,7 +292,7 @@ xstormy16_output_cbranch_hi (rtx op, const char *label, int reversed, rtx insn)\n \n   code = GET_CODE (op);\n \n-  if (GET_CODE (XEXP (op, 0)) != REG)\n+  if (! REG_P (XEXP (op, 0)))\n     {\n       code = swap_condition (code);\n       operands = \"%3,%2\";\n@@ -377,7 +377,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n       {\n \tint regnum;\n \n-\tgcc_assert (GET_CODE (XEXP (op, 0)) == REG);\n+\tgcc_assert (REG_P (XEXP (op, 0)));\n \n \tregnum = REGNO (XEXP (op, 0));\n \tsprintf (prevop, \"or %s,%s\", reg_names[regnum], reg_names[regnum+1]);\n@@ -455,13 +455,13 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n \n enum reg_class\n xstormy16_secondary_reload_class (enum reg_class rclass,\n-\t\t\t\t  enum machine_mode mode,\n+\t\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t  rtx x)\n {\n   /* This chip has the interesting property that only the first eight\n      registers can be moved to/from memory.  */\n-  if ((GET_CODE (x) == MEM\n-       || ((GET_CODE (x) == SUBREG || GET_CODE (x) == REG)\n+  if ((MEM_P (x)\n+       || ((GET_CODE (x) == SUBREG || REG_P (x))\n \t   && (true_regnum (x) == -1\n \t       || true_regnum (x) >= FIRST_PSEUDO_REGISTER)))\n       && ! reg_class_subset_p (rclass, EIGHT_REGS))\n@@ -473,8 +473,7 @@ xstormy16_secondary_reload_class (enum reg_class rclass,\n enum reg_class\n xstormy16_preferred_reload_class (rtx x, enum reg_class rclass)\n {\n-  if (rclass == GENERAL_REGS\n-      && GET_CODE (x) == MEM)\n+  if (rclass == GENERAL_REGS && MEM_P (x))\n     return EIGHT_REGS;\n \n   return rclass;\n@@ -489,16 +488,16 @@ xstormy16_below100_symbol (rtx x,\n {\n   if (GET_CODE (x) == CONST)\n     x = XEXP (x, 0);\n-  if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+  if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))\n     x = XEXP (x, 0);\n \n   if (GET_CODE (x) == SYMBOL_REF)\n     return (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_XSTORMY16_BELOW100) != 0;\n \n-  if (GET_CODE (x) == CONST_INT)\n+  if (CONST_INT_P (x))\n     {\n       HOST_WIDE_INT i = INTVAL (x);\n+\n       if ((i >= 0x0000 && i <= 0x00ff)\n \t  || (i >= 0x7f00 && i <= 0x7fff))\n \treturn 1;\n@@ -512,7 +511,7 @@ xstormy16_below100_symbol (rtx x,\n int\n xstormy16_splittable_below100_operand (rtx x, enum machine_mode mode)\n {\n-  if (GET_CODE (x) == MEM && MEM_VOLATILE_P (x))\n+  if (MEM_P (x) && MEM_VOLATILE_P (x))\n     return 0;\n   return xstormy16_below100_operand (x, mode);\n }\n@@ -541,17 +540,19 @@ xstormy16_expand_iorqi3 (rtx *operands)\n       return;\n     }\n \n-  if (GET_CODE (in) != REG)\n+  if (! REG_P (in))\n     in = copy_to_mode_reg (QImode, in);\n-  if (GET_CODE (val) != REG\n-      && GET_CODE (val) != CONST_INT)\n+\n+  if (! REG_P (val) && ! CONST_INT_P (val))\n     val = copy_to_mode_reg (QImode, val);\n-  if (GET_CODE (out) != REG)\n+\n+  if (! REG_P (out))\n     out = gen_reg_rtx (QImode);\n \n   in = simplify_gen_subreg (HImode, in, QImode, 0);\n   outsub = simplify_gen_subreg (HImode, out, QImode, 0);\n-  if (GET_CODE (val) != CONST_INT)\n+\n+  if (! CONST_INT_P (val))\n     val = simplify_gen_subreg (HImode, val, QImode, 0);\n \n   emit_insn (gen_iorhi3 (outsub, in, val));\n@@ -584,17 +585,19 @@ xstormy16_expand_andqi3 (rtx *operands)\n       return;\n     }\n \n-  if (GET_CODE (in) != REG)\n+  if (! REG_P (in))\n     in = copy_to_mode_reg (QImode, in);\n-  if (GET_CODE (val) != REG\n-      && GET_CODE (val) != CONST_INT)\n+\n+  if (! REG_P (val) && ! CONST_INT_P (val))\n     val = copy_to_mode_reg (QImode, val);\n-  if (GET_CODE (out) != REG)\n+\n+  if (! REG_P (out))\n     out = gen_reg_rtx (QImode);\n \n   in = simplify_gen_subreg (HImode, in, QImode, 0);\n   outsub = simplify_gen_subreg (HImode, out, QImode, 0);\n-  if (GET_CODE (val) != CONST_INT)\n+\n+  if (! CONST_INT_P (val))\n     val = simplify_gen_subreg (HImode, val, QImode, 0);\n \n   emit_insn (gen_andhi3 (outsub, in, val));\n@@ -604,11 +607,11 @@ xstormy16_expand_andqi3 (rtx *operands)\n }\n \n #define LEGITIMATE_ADDRESS_INTEGER_P(X, OFFSET)\t\t\t\t\\\n- (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n+  (CONST_INT_P (X)\t\t\t\t\t\t\t\\\n   && (unsigned HOST_WIDE_INT) (INTVAL (X) + (OFFSET) + 2048) < 4096)\n \n #define LEGITIMATE_ADDRESS_CONST_INT_P(X, OFFSET)\t\t\t \\\n- (GET_CODE (X) == CONST_INT\t\t\t\t\t\t \\\n+ (CONST_INT_P (X)\t\t\t\t\t\t\t \\\n   && INTVAL (X) + (OFFSET) >= 0\t\t\t\t\t\t \\\n   && INTVAL (X) + (OFFSET) < 0x8000\t\t\t\t\t \\\n   && (INTVAL (X) + (OFFSET) < 0x100 || INTVAL (X) + (OFFSET) >= 0x7F00))\n@@ -618,31 +621,31 @@ xstormy16_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\trtx x, bool strict)\n {\n   if (LEGITIMATE_ADDRESS_CONST_INT_P (x, 0))\n-    return 1;\n+    return true;\n \n   if (GET_CODE (x) == PLUS\n       && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (x, 1), 0))\n     {\n       x = XEXP (x, 0);\n       /* PR 31232: Do not allow INT+INT as an address.  */\n-      if (GET_CODE (x) == CONST_INT)\n-\treturn 0;\n+      if (CONST_INT_P (x))\n+\treturn false;\n     }\n \n-  if ((GET_CODE (x) == PRE_MODIFY\n-       && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT)\n+  if ((GET_CODE (x) == PRE_MODIFY && CONST_INT_P (XEXP (XEXP (x, 1), 1)))\n       || GET_CODE (x) == POST_INC\n       || GET_CODE (x) == PRE_DEC)\n     x = XEXP (x, 0);\n \n-  if (GET_CODE (x) == REG && REGNO_OK_FOR_BASE_P (REGNO (x))\n+  if (REG_P (x)\n+      && REGNO_OK_FOR_BASE_P (REGNO (x))\n       && (! strict || REGNO (x) < FIRST_PSEUDO_REGISTER))\n-    return 1;\n+    return true;\n \n   if (xstormy16_below100_symbol (x, mode))\n-    return 1;\n+    return true;\n \n-  return 0;\n+  return false;\n }\n \n /* Return nonzero if memory address X (an RTX) can have different\n@@ -696,20 +699,20 @@ xstormy16_extra_constraint_p (rtx x, int c)\n     {\n       /* 'Q' is for pushes.  */\n     case 'Q':\n-      return (GET_CODE (x) == MEM\n+      return (MEM_P (x)\n \t      && GET_CODE (XEXP (x, 0)) == POST_INC\n \t      && XEXP (XEXP (x, 0), 0) == stack_pointer_rtx);\n \n       /* 'R' is for pops.  */\n     case 'R':\n-      return (GET_CODE (x) == MEM\n+      return (MEM_P (x)\n \t      && GET_CODE (XEXP (x, 0)) == PRE_DEC\n \t      && XEXP (XEXP (x, 0), 0) == stack_pointer_rtx);\n \n       /* 'S' is for immediate memory addresses.  */\n     case 'S':\n-      return (GET_CODE (x) == MEM\n-\t      && GET_CODE (XEXP (x, 0)) == CONST_INT\n+      return (MEM_P (x)\n+\t      && CONST_INT_P (XEXP (x, 0))\n \t      && xstormy16_legitimate_address_p (VOIDmode, XEXP (x, 0), 0));\n \n       /* 'T' is for Rx.  */\n@@ -720,14 +723,12 @@ xstormy16_extra_constraint_p (rtx x, int c)\n       /* 'U' is for CONST_INT values not between 2 and 15 inclusive,\n \t for allocating a scratch register for 32-bit shifts.  */\n     case 'U':\n-      return (GET_CODE (x) == CONST_INT\n-\t      && (INTVAL (x) < 2 || INTVAL (x) > 15));\n+      return (CONST_INT_P (x) && (! IN_RANGE (INTVAL (x), 2, 15)));\n \n       /* 'Z' is for CONST_INT value zero.  This is for adding zero to\n \t a register in addhi3, which would otherwise require a carry.  */\n     case 'Z':\n-      return (GET_CODE (x) == CONST_INT\n-\t      && (INTVAL (x) == 0));\n+      return (CONST_INT_P (x) && (INTVAL (x) == 0));\n \n     case 'W':\n       return xstormy16_below100_operand (x, GET_MODE (x));\n@@ -770,7 +771,7 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n \t      && general_operand (src, mode));\n \n   /* This case is not supported below, and shouldn't be generated.  */\n-  gcc_assert (GET_CODE (dest) != MEM || GET_CODE (src) != MEM);\n+  gcc_assert (! MEM_P (dest) || ! MEM_P (src));\n \n   /* This case is very very bad after reload, so trap it now.  */\n   gcc_assert (GET_CODE (dest) != SUBREG && GET_CODE (src) != SUBREG);\n@@ -785,7 +786,7 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n      must be reversed.  */\n   direction = 1;\n \n-  if (GET_CODE (dest) == MEM)\n+  if (MEM_P (dest))\n     {\n       mem_operand = XEXP (dest, 0);\n       dest_modifies = side_effects_p (mem_operand);\n@@ -798,7 +799,7 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n \t  MEM_VOLATILE_P (dest) = 0;\n \t}\n     }\n-  else if (GET_CODE (src) == MEM)\n+  else if (MEM_P (src))\n     {\n       mem_operand = XEXP (src, 0);\n       src_modifies = side_effects_p (mem_operand);\n@@ -816,8 +817,8 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n \n   if (mem_operand == NULL_RTX)\n     {\n-      if (GET_CODE (src) == REG\n-\t  && GET_CODE (dest) == REG\n+      if (REG_P (src)\n+\t  && REG_P (dest)\n \t  && reg_overlap_mentioned_p (dest, src)\n \t  && REGNO (dest) > REGNO (src))\n \tdirection = -1;\n@@ -826,12 +827,11 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n       || (GET_CODE (mem_operand) == PLUS\n \t  && GET_CODE (XEXP (mem_operand, 0)) == PRE_DEC))\n     direction = -1;\n-  else if (GET_CODE (src) == MEM\n-\t   && reg_overlap_mentioned_p (dest, src))\n+  else if (MEM_P (src) && reg_overlap_mentioned_p (dest, src))\n     {\n       int regno;\n \n-      gcc_assert (GET_CODE (dest) == REG);\n+      gcc_assert (REG_P (dest));\n       regno = REGNO (dest);\n \n       gcc_assert (refers_to_regno_p (regno, regno + num_words,\n@@ -887,7 +887,7 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n void\n xstormy16_expand_move (enum machine_mode mode, rtx dest, rtx src)\n {\n-  if ((GET_CODE (dest) == MEM) && (GET_CODE (XEXP (dest, 0)) == PRE_MODIFY))\n+  if (MEM_P (dest) && (GET_CODE (XEXP (dest, 0)) == PRE_MODIFY))\n     {\n       rtx pmv      = XEXP (dest, 0);\n       rtx dest_reg = XEXP (pmv, 0);\n@@ -898,7 +898,7 @@ xstormy16_expand_move (enum machine_mode mode, rtx dest, rtx src)\n       dest = gen_rtx_MEM (mode, dest_reg);\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n     }\n-  else if ((GET_CODE (src) == MEM) && (GET_CODE (XEXP (src, 0)) == PRE_MODIFY))\n+  else if (MEM_P (src) && (GET_CODE (XEXP (src, 0)) == PRE_MODIFY))\n     {\n       rtx pmv     = XEXP (src, 0);\n       rtx src_reg = XEXP (pmv, 0);\n@@ -913,11 +913,11 @@ xstormy16_expand_move (enum machine_mode mode, rtx dest, rtx src)\n   /* There are only limited immediate-to-memory move instructions.  */\n   if (! reload_in_progress\n       && ! reload_completed\n-      && GET_CODE (dest) == MEM\n-      && (GET_CODE (XEXP (dest, 0)) != CONST_INT\n+      && MEM_P (dest)\n+      && (! CONST_INT_P (XEXP (dest, 0))\n \t  || ! xstormy16_legitimate_address_p (mode, XEXP (dest, 0), 0))\n       && ! xstormy16_below100_operand (dest, mode)\n-      && GET_CODE (src) != REG\n+      && ! REG_P (src)\n       && GET_CODE (src) != SUBREG)\n     src = copy_to_mode_reg (mode, src);\n \n@@ -1194,7 +1194,7 @@ void\n xstormy16_expand_epilogue (void)\n {\n   struct xstormy16_stack_layout layout;\n-  rtx mem_pop_rtx, insn;\n+  rtx mem_pop_rtx;\n   int regno;\n   const int ifun = xstormy16_interrupt_function_p ();\n \n@@ -1284,7 +1284,7 @@ xstormy16_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n   if (targetm.calls.must_pass_in_stack (mode, type)\n       || cum + XSTORMY16_WORD_SIZE (type, mode) > NUM_ARGUMENT_REGISTERS)\n     return NULL_RTX;\n-  return gen_rtx_REG (mode, cum + 2);\n+  return gen_rtx_REG (mode, cum + FIRST_ARGUMENT_REGISTER);\n }\n \n /* Build the va_list type.\n@@ -1565,7 +1565,7 @@ xstormy16_asm_output_aligned_common (FILE *stream,\n   rtx symbol;\n \n   if (mem != NULL_RTX\n-      && GET_CODE (mem) == MEM\n+      && MEM_P (mem)\n       && GET_CODE (symbol = XEXP (mem, 0)) == SYMBOL_REF\n       && SYMBOL_REF_FLAGS (symbol) & SYMBOL_FLAG_XSTORMY16_BELOW100)\n     {\n@@ -1693,13 +1693,13 @@ xstormy16_print_operand_address (FILE *file, rtx address)\n   int pre_dec, post_inc;\n \n   /* There are a few easy cases.  */\n-  if (GET_CODE (address) == CONST_INT)\n+  if (CONST_INT_P (address))\n     {\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (address) & 0xFFFF);\n       return;\n     }\n \n-  if (CONSTANT_P (address) || GET_CODE (address) == CODE_LABEL)\n+  if (CONSTANT_P (address) || LABEL_P (address))\n     {\n       output_addr_const (file, address);\n       return;\n@@ -1709,7 +1709,7 @@ xstormy16_print_operand_address (FILE *file, rtx address)\n      (plus:HI (pre_dec:HI (reg:HI ...)) (const_int ...)).  */\n   if (GET_CODE (address) == PLUS)\n     {\n-      gcc_assert (GET_CODE (XEXP (address, 1)) == CONST_INT);\n+      gcc_assert (CONST_INT_P (XEXP (address, 1)));\n       offset = INTVAL (XEXP (address, 1));\n       address = XEXP (address, 0);\n     }\n@@ -1721,7 +1721,7 @@ xstormy16_print_operand_address (FILE *file, rtx address)\n   if (pre_dec || post_inc)\n     address = XEXP (address, 0);\n \n-  gcc_assert (GET_CODE (address) == REG);\n+  gcc_assert (REG_P (address));\n \n   fputc ('(', file);\n   if (pre_dec)\n@@ -1749,7 +1749,7 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \tHOST_WIDE_INT xx = 1;\n \tHOST_WIDE_INT l;\n \n-\tif (GET_CODE (x) == CONST_INT)\n+\tif (CONST_INT_P (x))\n \t  xx = INTVAL (x);\n \telse\n \t  output_operand_lossage (\"'B' operand is not constant\");\n@@ -1789,7 +1789,7 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n       /* Print the symbol without a surrounding @fptr().  */\n       if (GET_CODE (x) == SYMBOL_REF)\n \tassemble_name (file, XSTR (x, 0));\n-      else if (GET_CODE (x) == LABEL_REF)\n+      else if (LABEL_P (x))\n \toutput_asm_label (x);\n       else\n \txstormy16_print_operand_address (file, x);\n@@ -1802,7 +1802,7 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n       {\n \tHOST_WIDE_INT xx = 0;\n \n-\tif (GET_CODE (x) == CONST_INT)\n+\tif (CONST_INT_P (x))\n \t  xx = INTVAL (x);\n \telse\n \t  output_operand_lossage (\"'o' operand is not constant\");\n@@ -1820,7 +1820,7 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \tHOST_WIDE_INT xx = 1;\n \tHOST_WIDE_INT l;\n \n-\tif (GET_CODE (x) == CONST_INT)\n+\tif (CONST_INT_P (x))\n \t  xx = INTVAL (x);\n \telse\n \t  output_operand_lossage (\"'B' operand is not constant\");\n@@ -1918,25 +1918,20 @@ xstormy16_output_addr_vec (FILE *file, rtx label ATTRIBUTE_UNUSED, rtx table)\n }\n \f\n /* Expander for the `call' patterns.\n-   INDEX is the index of the switch statement.\n-   LOWER_BOUND is a CONST_INT that is the value of INDEX corresponding\n-     to the first table entry.\n-   RANGE is the number of table entries.\n-   TABLE is an ADDR_VEC that is the jump table.\n-   DEFAULT_LABEL is the address to branch to if INDEX is outside the\n-     range LOWER_BOUND to LOWER_BOUND + RANGE - 1.  */\n+   RETVAL is the RTL for the return register or NULL for void functions.\n+   DEST is the function to call, expressed as a MEM.\n+   COUNTER is ignored.  */\n \n void\n xstormy16_expand_call (rtx retval, rtx dest, rtx counter)\n {\n   rtx call, temp;\n   enum machine_mode mode;\n \n-  gcc_assert (GET_CODE (dest) == MEM);\n+  gcc_assert (MEM_P (dest));\n   dest = XEXP (dest, 0);\n \n-  if (! CONSTANT_P (dest)\n-      && GET_CODE (dest) != REG)\n+  if (! CONSTANT_P (dest) && ! REG_P (dest))\n     dest = force_reg (Pmode, dest);\n \n   if (retval == NULL)\n@@ -1996,7 +1991,8 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \t{\n \tcase PLUS:\n \t  if (firstloop\n-\t      && GET_CODE (w_src1) == CONST_INT && INTVAL (w_src1) == 0)\n+\t      && CONST_INT_P (w_src1)\n+\t      && INTVAL (w_src1) == 0)\n \t    continue;\n \n \t  if (firstloop)\n@@ -2029,7 +2025,8 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \t    }\n \t  else if (firstloop\n \t\t   && code != COMPARE\n-\t\t   && GET_CODE (w_src1) == CONST_INT && INTVAL (w_src1) == 0)\n+\t\t   && CONST_INT_P (w_src1)\n+\t\t   && INTVAL (w_src1) == 0)\n \t    continue;\n \t  else if (firstloop)\n \t    insn = gen_subchi4 (w_dest, w_src0, w_src1);\n@@ -2040,7 +2037,7 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \tcase IOR:\n \tcase XOR:\n \tcase AND:\n-\t  if (GET_CODE (w_src1) == CONST_INT\n+\t  if (CONST_INT_P (w_src1)\n \t      && INTVAL (w_src1) == -(code == AND))\n \t    continue;\n \n@@ -2080,8 +2077,10 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n   const char *r0, *r1, *rt;\n   static char r[64];\n \n-  gcc_assert (GET_CODE (size_r) == CONST_INT\n-\t      && GET_CODE (x) == REG && mode == SImode);\n+  gcc_assert (CONST_INT_P (size_r)\n+\t      && REG_P (x)\n+\t      && mode == SImode);\n+\n   size = INTVAL (size_r) & (GET_MODE_BITSIZE (mode) - 1);\n \n   if (size == 0)\n@@ -2423,7 +2422,7 @@ combine_bnp (rtx insn)\n     }\n \n   reg = XEXP (cond, 0);\n-  if (GET_CODE (reg) != REG)\n+  if (! REG_P (reg))\n     return;\n   regno = REGNO (reg);\n   if (XEXP (cond, 1) != const0_rtx)"}]}