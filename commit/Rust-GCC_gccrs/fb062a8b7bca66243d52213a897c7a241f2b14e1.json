{"sha": "fb062a8b7bca66243d52213a897c7a241f2b14e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIwNjJhOGI3YmNhNjYyNDNkNTIyMTNhODk3YzdhMjQxZjJiMTRlMQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2020-01-22T04:54:15Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2020-05-09T01:34:18Z"}, "message": "cris: Move trivially from cc0 to reg:CC model, removing most optimizations.\n\nIn the parlance of <https://gcc.gnu.org/wiki/CC0Transition>,\nthis is a basic \"type 2\" conversion, without\ncondition-code-related optimizations (just plain CCmode), but\nwith \"cstore{M}4\" defined.  CRIS is somewhat similar to the\nm68k; most instructions affect condition-codes.  To wit, it\nlacks sufficient instructions to compose an arbitrary valid\naddress in a register, specifically from a valid address where\ninvolved registers have to be spilled or adjusted, without\naffecting condition-codes in CRIS_CC0_REGNUM aka. dccr.\n\nOn the other hand, moving dccr to and from a stackpointer-plus-\nconstant-offset-address *can* be done without additional register\nuse, and moving to or from a general register does not affect\nit.  There's no instruction to add a constant to a register or\nto put a constant in a register, without affecting dccr, but\nthere *is* an instruction to add a register (optionally scaled)\nto another without affecting dccr (i.e. \"addi\").  Also, moves\n*to* memory from any register do not affect dccr, and likewise\nbetween another special registers and a general register.  Maybe\nsome of that opens up the solution-space to a better solution\nthan clobbering dccr until reload_completed; to be investigated.\nFAOD: I know what to do in the direction of defining and using\nadditional CCmodes, but prefer to do the full transition in\nsmaller steps.\n\nRegarding the similarity to m68k, I didn't follow the steps of\nthe m68k cc0 transition, making use of the final_postscan_insn\nhook as with the a NOTICE_UPDATE_CC machinery.  For one, because\nit seems to be lacking in that it keeps compare-elimination\nrestricted to output-time, but also because it seems a bad match\nconsidering that CRIS has delay-slots; better try to eliminate\ncompares earlier.  Another approach which I originally intended\nto implement, that of the visium port of defining three variants\nfor most insns (not counting the define_subst expansions;\nunaffecting-before-reload, clobbering and setting), seems\noverworked and bloating the machine description.  I may be\nproven wrong, but I prefer we fix gcc if some something bails on\nseeing a parallel with a clobber of that specific hard-register.\n\nAlso, I chose to remove most anonymous combination-matching\npatterns; matchers, splitters and peepholes instead of\nconverting them to add clobbers of CRIS_CC0_REGNUM.  There are\nexclusions: those covered in the test-suite, if trivial enough.\n\nMany of these patterns are used to handle the side-effect-\nassignment addressing-modes as put together by combine: a\n\"prefix instruction\" before the main instruction, where the main\ninstruction uses the post-incremented-register addressing-mode\nand the \"left-over\" instruction-field in the prefixed insn to\nassign a register.  An example: the hopefully descriptive\n\"move.d $r9,[$r0=$r1+1234]\" compared to \"move.d $r9,[$r1+1234]\";\nboth formed by the prefix insn \"biap.w 1234,$r1\" before\nrespectively \"move.d $r9,[$r0+]\" and \"move.d $r9,[$r0]\".  Other\nprefix variants exist.  Useful, but optional, except where\nside-effect assignment was used in a special case in the\nfunction prologue; adjusted to a less optimal combination.\nSupport like the function cris_side_effect_mode_ok is kept.\n\nI intend to put back as many as I find use for, of those\nanonymous patterns in a controlled manner, with self-contained\ntest-cases proving their usability, rather than symmetry with\nother instructions and similar addressing modes, which guided\nthe original introduction.  I've entered pr93372 to track code\nperformance regressions related to this transition, with focus\non target-side causes and fixes; besides the function prologue\nspecial-case, there were some checking presence of the bit-test\n(btstq) instruction.\n\nThe now-gone \"tst<mode>\" patterns deserve a comment too: they\nwere an artefact from pre-\"cbranch\" era, now fully folded into\nthe \"cmp<mode>\" patterns.\n\nI've left the now-unused \"cc\" insn attribute in, for the time\nbeing; to be removed, used or transformed to be useful with\nfurther work to fix pr93372.  It can't be used as is, because\n\"normal\" doesn't mean \"like a compare instruction\" but \"handled\nby NOTICE_UPDATE_CC\" and may in fact be reflecting e.g. reverse\noperands, something that bit me during the conversion.\n\ngcc:\n\tMove trivially from cc0 to reg:CC model, removing most optimizations.\n\t* config/cris/cris.md: Remove all side-effect patterns and their\n\tsplitters.  Remove most peepholes.  Add clobbers of CRIS_CC0_REGNUM\n\tto all but post-reload control-flow and movem insns.  Remove\n\tconstraints on all modified expanders.  Remove obsoleted cc0-related\n\treferences.\n\t(attr \"cc\"): Remove alternative \"rev\".\n\t(mode_iterator BWDD, DI_, SI_): New.\n\t(mode_attr sCC_destc, cmp_op1c, cmp_op2c): New.\n\t(\"tst<mode>\"): Remove; fold as \"M\" alternative into compare insn.\n\t(\"mstep_shift\", \"mstep_mul\"): Remove patterns.\n\t(\"s<rcond>\", \"s<ocond>\", \"s<ncond>\"): Anonymize.\n\t* config/cris/cris.c: Change all non-condition-code,\n\tnon-control-flow emitted insns to add a parallel with clobber of\n\tCRIS_CC0_REGNUM, mostly by changing from gen_rtx_SET with\n\temit_insn to use of emit_move_insn, gen_add2_insn or\n\tcris_emit_insn, as convenient.\n\t(cris_reg_overlap_mentioned_p)\n\t(cris_normal_notice_update_cc, cris_notice_update_cc): Remove.\n\t(cris_movem_load_rest_p): Don't assume all elements in a\n\tPARALLEL are SETs.\n\t(cris_store_multiple_op_p): Ditto.\n\t(cris_emit_insn): New function.\n\t* cris/cris-protos.h (cris_emit_insn): Declare.", "tree": {"sha": "b0244f19be34c052025f71d62aa727335759201f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0244f19be34c052025f71d62aa727335759201f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb062a8b7bca66243d52213a897c7a241f2b14e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb062a8b7bca66243d52213a897c7a241f2b14e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb062a8b7bca66243d52213a897c7a241f2b14e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb062a8b7bca66243d52213a897c7a241f2b14e1/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0780379c1b621813fbea60449bc51b65f6f8c6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0780379c1b621813fbea60449bc51b65f6f8c6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0780379c1b621813fbea60449bc51b65f6f8c6e"}], "stats": {"total": 3182, "additions": 612, "deletions": 2570}, "files": [{"sha": "4abfbbecee2accbf286c73b56e7241622b29c7fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb062a8b7bca66243d52213a897c7a241f2b14e1", "patch": "@@ -9,6 +9,31 @@\n \t* config/cris/t-elfmulti: Remove crisv32 multilib.\n \t* config/cris: Remove shared-library and CRIS v32 support.\n \n+\tMove trivially from cc0 to reg:CC model, removing most optimizations.\n+\t* config/cris/cris.md: Remove all side-effect patterns and their\n+\tsplitters.  Remove most peepholes.  Add clobbers of CRIS_CC0_REGNUM\n+\tto all but post-reload control-flow and movem insns.  Remove\n+\tconstraints on all modified expanders.  Remove obsoleted cc0-related\n+\treferences.\n+\t(attr \"cc\"): Remove alternative \"rev\".\n+\t(mode_iterator BWDD, DI_, SI_): New.\n+\t(mode_attr sCC_destc, cmp_op1c, cmp_op2c): New.\n+\t(\"tst<mode>\"): Remove; fold as \"M\" alternative into compare insn.\n+\t(\"mstep_shift\", \"mstep_mul\"): Remove patterns.\n+\t(\"s<rcond>\", \"s<ocond>\", \"s<ncond>\"): Anonymize.\n+\t* config/cris/cris.c: Change all non-condition-code,\n+\tnon-control-flow emitted insns to add a parallel with clobber of\n+\tCRIS_CC0_REGNUM, mostly by changing from gen_rtx_SET with\n+\temit_insn to use of emit_move_insn, gen_add2_insn or\n+\tcris_emit_insn, as convenient.\n+\t(cris_reg_overlap_mentioned_p)\n+\t(cris_normal_notice_update_cc, cris_notice_update_cc): Remove.\n+\t(cris_movem_load_rest_p): Don't assume all elements in a\n+\tPARALLEL are SETs.\n+\t(cris_store_multiple_op_p): Ditto.\n+\t(cris_emit_insn): New function.\n+\t* cris/cris-protos.h (cris_emit_insn): Declare.\n+\n 2020-05-08  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* ira-color.c (update_costs_from_allocno): Remove"}, {"sha": "4d8e76f6e39ce328cd9cd6b3a19ba51cbcb541fb", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=fb062a8b7bca66243d52213a897c7a241f2b14e1", "patch": "@@ -36,11 +36,12 @@ extern void cris_reduce_compare (rtx *, rtx *, rtx *);\n extern bool cris_biap_index_p (const_rtx, bool);\n extern bool cris_legitimate_address_p (machine_mode, rtx, bool);\n extern bool cris_store_multiple_op_p (rtx);\n-extern bool cris_movem_load_rest_p (rtx, int);\n+extern bool cris_movem_load_rest_p (rtx);\n extern void cris_asm_output_symbol_ref (FILE *, rtx);\n extern void cris_asm_output_case_end (FILE *, int, rtx_insn *);\n-extern rtx cris_gen_movem_load (rtx, rtx, int);\n+extern rtx cris_gen_movem_load (rtx, rtx);\n extern rtx cris_emit_movem_store (rtx, rtx, int, bool);\n+extern rtx_insn *cris_emit_insn (rtx x);\n extern void cris_order_for_addsi3 (rtx *, int);\n extern void cris_emit_trap_for_misalignment (rtx);\n #endif /* RTX_CODE */"}, {"sha": "9fdabe2ac9b4af0e69e1794f2bbf4c31832dd273", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 105, "deletions": 434, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=fb062a8b7bca66243d52213a897c7a241f2b14e1", "patch": "@@ -90,9 +90,6 @@ static char cris_output_insn_is_bound = 0;\n    goes in code or in a static initializer.  */\n static int in_code = 0;\n \n-/* Fix for reg_overlap_mentioned_p.  */\n-static int cris_reg_overlap_mentioned_p (rtx, rtx);\n-\n static machine_mode cris_promote_function_mode (const_tree, machine_mode,\n \t\t\t\t\t\t     int *, const_tree, int);\n \n@@ -290,9 +287,9 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n /* Helper for cris_load_multiple_op and cris_ret_movem_op.  */\n \n bool\n-cris_movem_load_rest_p (rtx op, int offs)\n+cris_movem_load_rest_p (rtx op)\n {\n-  unsigned int reg_count = XVECLEN (op, 0) - offs;\n+  unsigned int reg_count = XVECLEN (op, 0);\n   rtx src_addr;\n   int i;\n   rtx elt;\n@@ -303,35 +300,36 @@ cris_movem_load_rest_p (rtx op, int offs)\n   /* Perform a quick check so we don't blow up below.  FIXME: Adjust for\n      other than (MEM reg).  */\n   if (reg_count <= 1\n-      || GET_CODE (XVECEXP (op, 0, offs)) != SET\n-      || !REG_P (SET_DEST (XVECEXP (op, 0, offs)))\n-      || !MEM_P (SET_SRC (XVECEXP (op, 0, offs))))\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || !REG_P (SET_DEST (XVECEXP (op, 0, 0)))\n+      || !MEM_P (SET_SRC (XVECEXP (op, 0, 0))))\n     return false;\n \n   /* Check a possible post-inc indicator.  */\n-  if (GET_CODE (SET_SRC (XVECEXP (op, 0, offs + 1))) == PLUS)\n+  if (GET_CODE (XVECEXP (op, 0, 1)) == SET\n+      && GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) == PLUS)\n     {\n-      rtx reg = XEXP (SET_SRC (XVECEXP (op, 0, offs + 1)), 0);\n-      rtx inc = XEXP (SET_SRC (XVECEXP (op, 0, offs + 1)), 1);\n+      rtx reg = XEXP (SET_SRC (XVECEXP (op, 0, 1)), 0);\n+      rtx inc = XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1);\n \n       reg_count--;\n \n       if (reg_count == 1\n \t  || !REG_P (reg)\n-\t  || !REG_P (SET_DEST (XVECEXP (op, 0, offs + 1)))\n-\t  || REGNO (reg) != REGNO (SET_DEST (XVECEXP (op, 0, offs + 1)))\n+\t  || !REG_P (SET_DEST (XVECEXP (op, 0, 1)))\n+\t  || REGNO (reg) != REGNO (SET_DEST (XVECEXP (op, 0, 1)))\n \t  || !CONST_INT_P (inc)\n \t  || INTVAL (inc) != (HOST_WIDE_INT) reg_count * 4)\n \treturn false;\n-      i = offs + 2;\n+      i = 2;\n     }\n   else\n-    i = offs + 1;\n+    i = 1;\n \n   regno_dir = -1;\n   regno = reg_count - 1;\n \n-  elt = XVECEXP (op, 0, offs);\n+  elt = XVECEXP (op, 0, 0);\n   src_addr = XEXP (SET_SRC (elt), 0);\n \n   if (GET_CODE (elt) != SET\n@@ -399,15 +397,15 @@ cris_store_multiple_op_p (rtx op)\n   dest_addr = XEXP (dest, 0);\n \n   /* Check a possible post-inc indicator.  */\n-  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) == PLUS)\n+  if (GET_CODE (XVECEXP (op, 0, 1)) == SET\n+      && GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) == PLUS)\n     {\n       rtx reg = XEXP (SET_SRC (XVECEXP (op, 0, 1)), 0);\n       rtx inc = XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1);\n \n       reg_count--;\n \n-      if (reg_count == 1\n-\t  || !REG_P (reg)\n+      if (!REG_P (reg)\n \t  || !REG_P (SET_DEST (XVECEXP (op, 0, 1)))\n \t  || REGNO (reg) != REGNO (SET_DEST (XVECEXP (op, 0, 1)))\n \t  || !CONST_INT_P (inc)\n@@ -1501,302 +1499,6 @@ cris_memory_move_cost (machine_mode mode,\n     return 6;\n }\n \n-/* Worker for cris_notice_update_cc; handles the \"normal\" cases.\n-   FIXME: this code is historical; its functionality should be\n-   refactored to look at insn attributes and moved to\n-   cris_notice_update_cc.  Except, we better lose cc0 entirely.  */\n-\n-static void\n-cris_normal_notice_update_cc (rtx exp, rtx insn)\n-{\n-  /* \"Normal\" means, for:\n-     (set (cc0) (...)):\n-     CC is (...).\n-\n-     (set (reg) (...)):\n-     CC is (reg) and (...) - unless (...) is 0 or reg is a special\n-\tregister, then CC does not change.\n-     CC_NO_OVERFLOW unless (...) is reg or mem.\n-\n-     (set (mem) (...)):\n-     CC does not change.\n-\n-     (set (pc) (...)):\n-     CC does not change.\n-\n-     (parallel\n-      (set (reg1) (mem (bdap/biap)))\n-      (set (reg2) (bdap/biap))):\n-     CC is (reg1) and (mem (reg2))\n-\n-     (parallel\n-      (set (mem (bdap/biap)) (reg1)) [or 0]\n-      (set (reg2) (bdap/biap))):\n-     CC does not change.\n-\n-     (where reg and mem includes strict_low_parts variants thereof)\n-\n-     For all others, assume CC is clobbered.\n-     Note that we do not have to care about setting CC_NO_OVERFLOW,\n-     since the overflow flag is set to 0 (i.e. right) for\n-     instructions where it does not have any sane sense, but where\n-     other flags have meanings.  (This includes shifts; the carry is\n-     not set by them).\n-\n-     Note that there are other parallel constructs we could match,\n-     but we don't do that yet.  */\n-\n-  if (GET_CODE (exp) == SET)\n-    {\n-      /* FIXME: Check when this happens.  It looks like we should\n-\t actually do a CC_STATUS_INIT here to be safe.  */\n-      if (SET_DEST (exp) == pc_rtx)\n-\treturn;\n-\n-      /* Record CC0 changes, so we do not have to output multiple\n-\t test insns.  */\n-      if (SET_DEST (exp) == cc0_rtx)\n-\t{\n-\t  CC_STATUS_INIT;\n-\n-\t  if (GET_CODE (SET_SRC (exp)) == COMPARE\n-\t      && XEXP (SET_SRC (exp), 1) == const0_rtx)\n-\t    cc_status.value1 = XEXP (SET_SRC (exp), 0);\n-\t  else\n-\t    cc_status.value1 = SET_SRC (exp);\n-\n-          /* Handle flags for the special btstq on one bit.  */\n-\t  if (GET_CODE (cc_status.value1) == ZERO_EXTRACT\n-\t      && XEXP (cc_status.value1, 1) == const1_rtx)\n-\t    {\n-\t      if (CONST_INT_P (XEXP (cc_status.value1, 0)))\n-\t\t/* Using cmpq.  */\n-\t\tcc_status.flags = CC_INVERTED;\n-\t      else\n-\t\t/* A one-bit btstq.  */\n-\t\tcc_status.flags = CC_Z_IN_NOT_N;\n-\t    }\n-\n-\t  else if (GET_CODE (SET_SRC (exp)) == COMPARE)\n-\t    {\n-\t      if (!REG_P (XEXP (SET_SRC (exp), 0))\n-\t\t  && XEXP (SET_SRC (exp), 1) != const0_rtx)\n-\t\t/* For some reason gcc will not canonicalize compare\n-\t\t   operations, reversing the sign by itself if\n-\t\t   operands are in wrong order.  */\n-\t\t/* (But NOT inverted; eq is still eq.) */\n-\t\tcc_status.flags = CC_REVERSED;\n-\n-\t      /* This seems to be overlooked by gcc.  FIXME: Check again.\n-\t\t FIXME:  Is it really safe?  */\n-\t      cc_status.value2\n-\t\t= gen_rtx_MINUS (GET_MODE (SET_SRC (exp)),\n-\t\t\t\t XEXP (SET_SRC (exp), 0),\n-\t\t\t\t XEXP (SET_SRC (exp), 1));\n-\t    }\n-\t  return;\n-\t}\n-      else if (REG_P (SET_DEST (exp))\n-\t       || (GET_CODE (SET_DEST (exp)) == STRICT_LOW_PART\n-\t\t   && REG_P (XEXP (SET_DEST (exp), 0))))\n-\t{\n-\t  /* A register is set; normally CC is set to show that no\n-\t     test insn is needed.  Catch the exceptions.  */\n-\n-\t  /* If not to cc0, then no \"set\"s in non-natural mode give\n-\t     ok cc0...  */\n-\t  if (GET_MODE_SIZE (GET_MODE (SET_DEST (exp))) > UNITS_PER_WORD\n-\t      || GET_MODE_CLASS (GET_MODE (SET_DEST (exp))) == MODE_FLOAT)\n-\t    {\n-\t      /* ... except add:s and sub:s in DImode.  */\n-\t      if (GET_MODE (SET_DEST (exp)) == DImode\n-\t\t  && (GET_CODE (SET_SRC (exp)) == PLUS\n-\t\t      || GET_CODE (SET_SRC (exp)) == MINUS))\n-\t\t{\n-\t\t  CC_STATUS_INIT;\n-\t\t  cc_status.value1 = SET_DEST (exp);\n-\t\t  cc_status.value2 = SET_SRC (exp);\n-\n-\t\t  if (cris_reg_overlap_mentioned_p (cc_status.value1,\n-\t\t\t\t\t\t    cc_status.value2))\n-\t\t    cc_status.value2 = 0;\n-\n-\t\t  /* Add and sub may set V, which gets us\n-\t\t     unoptimizable results in \"gt\" and \"le\" condition\n-\t\t     codes.  */\n-\t\t  cc_status.flags |= CC_NO_OVERFLOW;\n-\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  else if (SET_SRC (exp) == const0_rtx\n-\t\t   || (REG_P (SET_SRC (exp))\n-\t\t       && (REGNO (SET_SRC (exp))\n-\t\t\t   > CRIS_LAST_GENERAL_REGISTER)))\n-\t    {\n-\t      /* There's no CC0 change for this case.  Just check\n-\t\t for overlap.  */\n-\t      if (cc_status.value1\n-\t\t  && modified_in_p (cc_status.value1, insn))\n-\t\tcc_status.value1 = 0;\n-\n-\t      if (cc_status.value2\n-\t\t  && modified_in_p (cc_status.value2, insn))\n-\t\tcc_status.value2 = 0;\n-\n-\t      return;\n-\t    }\n-\t  else\n-\t    {\n-\t      CC_STATUS_INIT;\n-\t      cc_status.value1 = SET_DEST (exp);\n-\t      cc_status.value2 = SET_SRC (exp);\n-\n-\t      if (cris_reg_overlap_mentioned_p (cc_status.value1,\n-\t\t\t\t\t\tcc_status.value2))\n-\t\tcc_status.value2 = 0;\n-\n-\t      /* Some operations may set V, which gets us\n-\t\t unoptimizable results in \"gt\" and \"le\" condition\n-\t\t codes.  */\n-\t      if (GET_CODE (SET_SRC (exp)) == PLUS\n-\t\t  || GET_CODE (SET_SRC (exp)) == MINUS\n-\t\t  || GET_CODE (SET_SRC (exp)) == NEG)\n-\t\tcc_status.flags |= CC_NO_OVERFLOW;\n-\n-\t      return;\n-\t    }\n-\t}\n-      else if (MEM_P (SET_DEST (exp))\n-\t       || (GET_CODE (SET_DEST (exp)) == STRICT_LOW_PART\n-\t\t   && MEM_P (XEXP (SET_DEST (exp), 0))))\n-\t{\n-\t  /* When SET to MEM, then CC is not changed (except for\n-\t     overlap).  */\n-\t  if (cc_status.value1\n-\t      && modified_in_p (cc_status.value1, insn))\n-\t    cc_status.value1 = 0;\n-\n-\t  if (cc_status.value2\n-\t      && modified_in_p (cc_status.value2, insn))\n-\t    cc_status.value2 = 0;\n-\n-\t  return;\n-\t}\n-    }\n-  else if (GET_CODE (exp) == PARALLEL)\n-    {\n-      if (GET_CODE (XVECEXP (exp, 0, 0)) == SET\n-\t  && GET_CODE (XVECEXP (exp, 0, 1)) == SET\n-\t  && REG_P (XEXP (XVECEXP (exp, 0, 1), 0)))\n-\t{\n-\t  if (REG_P (XEXP (XVECEXP (exp, 0, 0), 0))\n-\t      && MEM_P (XEXP (XVECEXP (exp, 0, 0), 1)))\n-\t    {\n-\t      CC_STATUS_INIT;\n-\n-\t      /* For \"move.S [rx=ry+o],rz\", say CC reflects\n-\t\t value1=rz and value2=[rx] */\n-\t      cc_status.value1 = XEXP (XVECEXP (exp, 0, 0), 0);\n-\t      cc_status.value2\n-\t\t= replace_equiv_address (XEXP (XVECEXP (exp, 0, 0), 1),\n-\t\t\t\t\t XEXP (XVECEXP (exp, 0, 1), 0));\n-\n-\t      /* Huh?  A side-effect cannot change the destination\n-\t\t register.  */\n-\t      if (cris_reg_overlap_mentioned_p (cc_status.value1,\n-\t\t\t\t\t\tcc_status.value2))\n-\t\tinternal_error (\"internal error: sideeffect-insn affecting main effect\");\n-\t      return;\n-\t    }\n-\t  else if ((REG_P (XEXP (XVECEXP (exp, 0, 0), 1))\n-\t\t    || XEXP (XVECEXP (exp, 0, 0), 1) == const0_rtx)\n-\t\t   && MEM_P (XEXP (XVECEXP (exp, 0, 0), 0)))\n-\t    {\n-\t      /* For \"move.S rz,[rx=ry+o]\" and \"clear.S [rx=ry+o]\",\n-\t\t say flags are not changed, except for overlap.  */\n-\t      if (cc_status.value1\n-\t\t  && modified_in_p (cc_status.value1, insn))\n-\t\tcc_status.value1 = 0;\n-\n-\t      if (cc_status.value2\n-\t\t  && modified_in_p (cc_status.value2, insn))\n-\t\tcc_status.value2 = 0;\n-\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  /* If we got here, the case wasn't covered by the code above.  */\n-  CC_STATUS_INIT;\n-}\n-\n-/*  This function looks into the pattern to see how this insn affects\n-    condition codes.\n-\n-    Used when to eliminate test insns before a condition-code user,\n-    such as a \"scc\" insn or a conditional branch.  This includes\n-    checking if the entities that cc was updated by, are changed by the\n-    operation.\n-\n-    Currently a jumble of the old peek-inside-the-insn and the newer\n-    check-cc-attribute methods.  */\n-\n-void\n-cris_notice_update_cc (rtx exp, rtx_insn *insn)\n-{\n-  enum attr_cc attrval = get_attr_cc (insn);\n-\n-  /* Check if user specified \"-mcc-init\" as a bug-workaround.  Remember\n-     to still set CC_REVERSED as below, since that's required by some\n-     compare insn alternatives.  (FIXME: GCC should do this virtual\n-     operand swap by itself.)  A test-case that may otherwise fail is\n-     gcc.c-torture/execute/20000217-1.c -O0 and -O1.  */\n-  if (TARGET_CCINIT)\n-    {\n-      CC_STATUS_INIT;\n-\n-      if (attrval == CC_REV)\n-\tcc_status.flags = CC_REVERSED;\n-      return;\n-    }\n-\n-  /* Slowly, we're converting to using attributes to control the setting\n-     of condition-code status.  */\n-  switch (attrval)\n-    {\n-    case CC_NONE:\n-      /* Even if it is \"none\", a setting may clobber a previous\n-\t cc-value, so check.  */\n-      if (GET_CODE (exp) == SET)\n-\t{\n-\t  if (cc_status.value1\n-\t      && modified_in_p (cc_status.value1, insn))\n-\t    cc_status.value1 = 0;\n-\n-\t  if (cc_status.value2\n-\t      && modified_in_p (cc_status.value2, insn))\n-\t    cc_status.value2 = 0;\n-\t}\n-      return;\n-\n-    case CC_CLOBBER:\n-      CC_STATUS_INIT;\n-      return;\n-\n-    case CC_REV:\n-    case CC_NORMAL:\n-      cris_normal_notice_update_cc (exp, insn);\n-      return;\n-\n-    default:\n-      internal_error (\"unknown cc_attr value\");\n-    }\n-\n-  CC_STATUS_INIT;\n-}\n-\n /* Return != 0 if the return sequence for the current function is short,\n    like \"ret\" or \"jump [sp+]\".  Prior to reloading, we can't tell if\n    registers must be saved, so return 0 then.  */\n@@ -2208,23 +1910,6 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n   internal_error (\"internal error: cris_side_effect_mode_ok with bad operands\");\n }\n \n-/* The function reg_overlap_mentioned_p in CVS (still as of 2001-05-16)\n-   does not handle the case where the IN operand is strict_low_part; it\n-   does handle it for X.  Test-case in Axis-20010516.  This function takes\n-   care of that for THIS port.  FIXME: strict_low_part is going away\n-   anyway.  */\n-\n-static int\n-cris_reg_overlap_mentioned_p (rtx x, rtx in)\n-{\n-  /* The function reg_overlap_mentioned now handles when X is\n-     strict_low_part, but not when IN is a STRICT_LOW_PART.  */\n-  if (GET_CODE (in) == STRICT_LOW_PART)\n-    in = XEXP (in, 0);\n-\n-  return reg_overlap_mentioned_p (x, in);\n-}\n-\n /* Queue an .ident string in the queue of top-level asm statements.\n    If the front-end is done, we must be being called from toplev.c.\n    In that case, do nothing.  */\n@@ -2480,22 +2165,20 @@ cris_split_movdx (rtx *operands)\n \t  /* We normally copy the low-numbered register first.  However, if\n \t     the first register operand 0 is the same as the second register of\n \t     operand 1, we must copy in the opposite order.  */\n-\t  emit_insn (gen_rtx_SET (operand_subword (dest, reverse, TRUE, mode),\n-\t\t\t\t  operand_subword (src, reverse, TRUE, mode)));\n+\t  emit_move_insn (operand_subword (dest, reverse, TRUE, mode),\n+\t\t\t  operand_subword (src, reverse, TRUE, mode));\n \n-\t  emit_insn (gen_rtx_SET (operand_subword (dest, !reverse, TRUE, mode),\n-\t\t\t\t  operand_subword (src, !reverse, TRUE, mode)));\n+\t  emit_move_insn (operand_subword (dest, !reverse, TRUE, mode),\n+\t\t\t  operand_subword (src, !reverse, TRUE, mode));\n \t}\n       /* Constant-to-reg copy.  */\n       else if (CONST_INT_P (src) || GET_CODE (src) == CONST_DOUBLE)\n \t{\n \t  rtx words[2];\n \t  split_double (src, &words[0], &words[1]);\n-\t  emit_insn (gen_rtx_SET (operand_subword (dest, 0, TRUE, mode),\n-\t\t\t\t  words[0]));\n+\t  emit_move_insn (operand_subword (dest, 0, TRUE, mode), words[0]);\n \n-\t  emit_insn (gen_rtx_SET (operand_subword (dest, 1, TRUE, mode),\n-\t\t\t\t  words[1]));\n+\t  emit_move_insn (operand_subword (dest, 1, TRUE, mode), words[1]);\n \t}\n       /* Mem-to-reg copy.  */\n       else if (MEM_P (src))\n@@ -2522,18 +2205,15 @@ cris_split_movdx (rtx *operands)\n \t\t addresses ourselves, we must add a post-inc note\n \t\t manually.  */\n \t      mem = change_address (src, SImode, addr);\n-\t      insn\n-\t\t= gen_rtx_SET (operand_subword (dest, 0, TRUE, mode), mem);\n-\t      insn = emit_insn (insn);\n+\t      insn = emit_move_insn (operand_subword (dest, 0, TRUE, mode),\n+\t\t\t\t     mem);\n \t      if (GET_CODE (XEXP (mem, 0)) == POST_INC)\n \t\tREG_NOTES (insn)\n \t\t  = alloc_EXPR_LIST (REG_INC, XEXP (XEXP (mem, 0), 0),\n \t\t\t\t     REG_NOTES (insn));\n \n \t      mem = copy_rtx (mem);\n-\t      insn\n-\t\t= gen_rtx_SET (operand_subword (dest, 1, TRUE, mode), mem);\n-\t      insn = emit_insn (insn);\n+\t      insn = emit_move_insn (operand_subword (dest, 1, TRUE, mode), mem);\n \t      if (GET_CODE (XEXP (mem, 0)) == POST_INC)\n \t\tREG_NOTES (insn)\n \t\t  = alloc_EXPR_LIST (REG_INC, XEXP (XEXP (mem, 0), 0),\n@@ -2548,19 +2228,17 @@ cris_split_movdx (rtx *operands)\n \t      if (side_effects_p (addr))\n \t\tfatal_insn (\"unexpected side-effects in address\", addr);\n \n-\t      emit_insn (gen_rtx_SET\n-\t\t\t (operand_subword (dest, reverse, TRUE, mode),\n-\t\t\t  change_address\n-\t\t\t  (src, SImode,\n-\t\t\t   plus_constant (Pmode, addr,\n-\t\t\t\t\t  reverse * UNITS_PER_WORD))));\n-\t      emit_insn (gen_rtx_SET\n-\t\t\t (operand_subword (dest, ! reverse, TRUE, mode),\n-\t\t\t  change_address\n-\t\t\t  (src, SImode,\n-\t\t\t   plus_constant (Pmode, addr,\n-\t\t\t\t\t  (! reverse) *\n-\t\t\t\t\t  UNITS_PER_WORD))));\n+\t      emit_move_insn (operand_subword (dest, reverse, TRUE, mode),\n+\t\t\t      change_address\n+\t\t\t      (src, SImode,\n+\t\t\t       plus_constant (Pmode, addr,\n+\t\t\t\t\t      reverse * UNITS_PER_WORD)));\n+\t      emit_move_insn (operand_subword (dest, ! reverse, TRUE, mode),\n+\t\t\t      change_address\n+\t\t\t      (src, SImode,\n+\t\t\t       plus_constant (Pmode, addr,\n+\t\t\t\t\t      (! reverse) *\n+\t\t\t\t\t      UNITS_PER_WORD)));\n \t    }\n \t}\n       else\n@@ -2582,17 +2260,14 @@ cris_split_movdx (rtx *operands)\n \t  /* Whenever we emit insns with post-incremented addresses\n \t     ourselves, we must add a post-inc note manually.  */\n \t  mem = change_address (dest, SImode, addr);\n-\t  insn\n-\t    = gen_rtx_SET (mem, operand_subword (src, 0, TRUE, mode));\n-\t  insn = emit_insn (insn);\n+\t  insn = emit_move_insn (mem, operand_subword (src, 0, TRUE, mode));\n \t  if (GET_CODE (XEXP (mem, 0)) == POST_INC)\n \t    REG_NOTES (insn)\n \t      = alloc_EXPR_LIST (REG_INC, XEXP (XEXP (mem, 0), 0),\n \t\t\t\t REG_NOTES (insn));\n \n \t  mem = copy_rtx (mem);\n-\t  insn = gen_rtx_SET (mem, operand_subword (src, 1, TRUE, mode));\n-\t  insn = emit_insn (insn);\n+\t  insn = emit_move_insn (mem, operand_subword (src, 1, TRUE, mode));\n \t  if (GET_CODE (XEXP (mem, 0)) == POST_INC)\n \t    REG_NOTES (insn)\n \t      = alloc_EXPR_LIST (REG_INC, XEXP (XEXP (mem, 0), 0),\n@@ -2606,15 +2281,13 @@ cris_split_movdx (rtx *operands)\n \t  if (side_effects_p (addr))\n \t    fatal_insn (\"unexpected side-effects in address\", addr);\n \n-\t  emit_insn (gen_rtx_SET\n-\t\t     (change_address (dest, SImode, addr),\n-\t\t      operand_subword (src, 0, TRUE, mode)));\n+\t  emit_move_insn (change_address (dest, SImode, addr),\n+\t\t\t  operand_subword (src, 0, TRUE, mode));\n \n-\t  emit_insn (gen_rtx_SET\n-\t\t     (change_address (dest, SImode,\n-\t\t\t\t      plus_constant (Pmode, addr,\n-\t\t\t\t\t\t     UNITS_PER_WORD)),\n-\t\t      operand_subword (src, 1, TRUE, mode)));\n+\t  emit_move_insn (change_address (dest, SImode,\n+\t\t\t\t\t  plus_constant (Pmode, addr,\n+\t\t\t\t\t\t\t UNITS_PER_WORD)),\n+\t\t\t  operand_subword (src, 1, TRUE, mode));\n \t}\n     }\n \n@@ -2727,10 +2400,7 @@ cris_expand_prologue (void)\n \t   stdarg_regs > 0;\n \t   regno--, pretend -= 4, stdarg_regs--)\n \t{\n-\t  insn = emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t\t plus_constant (Pmode,\n-\t\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\t\t-4)));\n+\t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (-4)));\n \t  /* FIXME: When dwarf2 frame output and unless asynchronous\n \t     exceptions, make dwarf2 bundle together all stack\n \t     adjustments like it does for registers between stack\n@@ -2755,9 +2425,8 @@ cris_expand_prologue (void)\n   /* Save SRP if not a leaf function.  */\n   if (return_address_on_stack)\n     {\n-      insn = emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t    -4 - pretend)));\n+      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t       GEN_INT (-4 - pretend)));\n       pretend = 0;\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n@@ -2771,9 +2440,8 @@ cris_expand_prologue (void)\n   /* Set up the frame pointer, if needed.  */\n   if (frame_pointer_needed)\n     {\n-      insn = emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t    -4 - pretend)));\n+      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t       GEN_INT (-4 - pretend)));\n       pretend = 0;\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n@@ -2820,7 +2488,10 @@ cris_expand_prologue (void)\n \t\t     side-effects insns are allowed.  */\n \t\t  if ((last_movem_reg + 1) * 4 + size >= 64\n \t\t      && (last_movem_reg + 1) * 4 + size <= 128\n-\t\t      && (cris_cpu_version >= CRIS_CPU_SVINTO || n_saved == 1)\n+\t\t      && cris_cpu_version >= CRIS_CPU_SVINTO\n+\t\t      /* Don't use side-effect assignment for a single\n+\t\t\t move.  */\n+\t\t      && n_saved > 1\n \t\t      && TARGET_SIDE_EFFECT_PREFIXES)\n \t\t    {\n \t\t      mem\n@@ -2836,10 +2507,9 @@ cris_expand_prologue (void)\n \t\t  else\n \t\t    {\n \t\t      insn\n-\t\t\t= gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t      -(n_saved * 4 + size)));\n-\t\t      insn = emit_insn (insn);\n+\t\t\t= emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t\t\t    GEN_INT (-(n_saved * 4\n+\t\t\t\t\t\t\t       + size))));\n \t\t      RTX_FRAME_RELATED_P (insn) = 1;\n \n \t\t      mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n@@ -2853,10 +2523,8 @@ cris_expand_prologue (void)\n \t\t  size = 0;\n \t\t}\n \n-\t      insn = emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t\t     plus_constant (Pmode,\n-\t\t\t\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t\t\t\t    -4 - size)));\n+\t      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t\t       GEN_INT (-4 - size)));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \n \t      mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n@@ -2880,7 +2548,9 @@ cris_expand_prologue (void)\n \t do it if side-effects insns are allowed.  */\n       if ((last_movem_reg + 1) * 4 + size >= 64\n \t  && (last_movem_reg + 1) * 4 + size <= 128\n-\t  && (cris_cpu_version >= CRIS_CPU_SVINTO || n_saved == 1)\n+\t  && cris_cpu_version >= CRIS_CPU_SVINTO\n+\t  /* Don't use side-effect assignment for a single move. */\n+\t  && n_saved > 1\n \t  && TARGET_SIDE_EFFECT_PREFIXES)\n \t{\n \t  mem\n@@ -2893,11 +2563,8 @@ cris_expand_prologue (void)\n \t}\n       else\n \t{\n-\t  insn\n-\t    = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t  -(n_saved * 4 + size)));\n-\t  insn = emit_insn (insn);\n+\t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t\t   GEN_INT (-(n_saved * 4 + size))));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \n \t  mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n@@ -2909,20 +2576,16 @@ cris_expand_prologue (void)\n       /* We have to put outgoing argument space after regs.  */\n       if (cfoa_size)\n \t{\n-\t  insn = emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t\t plus_constant (Pmode,\n-\t\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\t\t-cfoa_size)));\n+\t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t\t   GEN_INT (-cfoa_size)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  framesize += cfoa_size;\n \t}\n     }\n   else if ((size + cfoa_size) > 0)\n     {\n-      insn = emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t     plus_constant (Pmode,\n-\t\t\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t\t\t    -(cfoa_size + size))));\n+      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t       GEN_INT (-(cfoa_size + size))));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       framesize += size + cfoa_size;\n     }\n@@ -2988,9 +2651,8 @@ cris_expand_epilogue (void)\n \t  {\n \t    /* There is an area for outgoing parameters located before\n \t       the saved registers.  We have to adjust for that.  */\n-\t    emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t    plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t   argspace_offset)));\n+\t    emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (argspace_offset)));\n \t    /* Make sure we only do this once.  */\n \t    argspace_offset = 0;\n \t  }\n@@ -3013,18 +2675,15 @@ cris_expand_epilogue (void)\n \n       if (argspace_offset)\n \t{\n-\t  emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t argspace_offset)));\n+\t  emit_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (argspace_offset)));\n \t  argspace_offset = 0;\n \t}\n \n       mem = gen_rtx_MEM (SImode,\n \t\t\t gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n       set_mem_alias_set (mem, get_frame_alias_set ());\n       insn\n-\t= emit_insn (cris_gen_movem_load (mem,\n-\t\t\t\t\t  GEN_INT (last_movem_reg + 1), 0));\n+\t= emit_insn (cris_gen_movem_load (mem, GEN_INT (last_movem_reg + 1)));\n       /* Whenever we emit insns with post-incremented addresses\n \t ourselves, we must add a post-inc note manually.  */\n       if (side_effects_p (PATTERN (insn)))\n@@ -3071,8 +2730,7 @@ cris_expand_epilogue (void)\n \t yet.  */\n       size += argspace_offset;\n \n-      emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t      plus_constant (Pmode, stack_pointer_rtx, size)));\n+      emit_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (size)));\n     }\n \n   /* If this function has no pushed register parameters\n@@ -3097,9 +2755,8 @@ cris_expand_epilogue (void)\n \t    = alloc_EXPR_LIST (REG_INC, stack_pointer_rtx, REG_NOTES (insn));\n \n \t  if (crtl->calls_eh_return)\n-\t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   gen_raw_REG (SImode, CRIS_STACKADJ_REG)));\n+\t    emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t      gen_raw_REG (SImode, CRIS_STACKADJ_REG)));\n \t  cris_expand_return (false);\n \t}\n       else\n@@ -3131,23 +2788,20 @@ cris_expand_epilogue (void)\n \t    = alloc_EXPR_LIST (REG_INC, stack_pointer_rtx, REG_NOTES (insn));\n \t}\n \n-      emit_insn (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t     pretend)));\n+      emit_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (pretend)));\n     }\n \n   /* Perform the \"physical\" unwinding that the EH machinery calculated.  */\n   if (crtl->calls_eh_return)\n-    emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t   stack_pointer_rtx,\n-\t\t\t   gen_raw_REG (SImode, CRIS_STACKADJ_REG)));\n+    emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t      gen_raw_REG (SImode, CRIS_STACKADJ_REG)));\n   cris_expand_return (false);\n }\n \n /* Worker function for generating movem from mem for load_multiple.  */\n \n rtx\n-cris_gen_movem_load (rtx src, rtx nregs_rtx, int nprefix)\n+cris_gen_movem_load (rtx src, rtx nregs_rtx)\n {\n   int nregs = INTVAL (nregs_rtx);\n   rtvec vec;\n@@ -3166,24 +2820,23 @@ cris_gen_movem_load (rtx src, rtx nregs_rtx, int nprefix)\n   if (nregs == 1)\n     return gen_movsi (gen_rtx_REG (SImode, 0), src);\n \n-  vec = rtvec_alloc (nprefix + nregs\n-\t\t     + (GET_CODE (XEXP (src, 0)) == POST_INC));\n+  vec = rtvec_alloc (nregs + (GET_CODE (XEXP (src, 0)) == POST_INC));\n \n   if (GET_CODE (XEXP (src, 0)) == POST_INC)\n     {\n-      RTVEC_ELT (vec, nprefix + 1)\n+      RTVEC_ELT (vec, 1)\n \t= gen_rtx_SET (srcreg, plus_constant (Pmode, srcreg, nregs * 4));\n       eltno++;\n     }\n \n   src = replace_equiv_address (src, srcreg);\n-  RTVEC_ELT (vec, nprefix)\n+  RTVEC_ELT (vec, 0)\n     = gen_rtx_SET (gen_rtx_REG (SImode, regno), src);\n   regno += regno_inc;\n \n   for (i = 1; i < nregs; i++, eltno++)\n     {\n-      RTVEC_ELT (vec, nprefix + eltno)\n+      RTVEC_ELT (vec, eltno)\n \t= gen_rtx_SET (gen_rtx_REG (SImode, regno),\n \t\t       adjust_address_nv (src, SImode, i * 4));\n       regno += regno_inc;\n@@ -3192,6 +2845,22 @@ cris_gen_movem_load (rtx src, rtx nregs_rtx, int nprefix)\n   return gen_rtx_PARALLEL (VOIDmode, vec);\n }\n \n+/* Convenience function for CRIS-local use of emit_insn, wrapping the\n+   argument in a parallel with a clobber of CRIS_CC0_REGNUM before\n+   passing on to emit_insn. */\n+\n+rtx_insn *\n+cris_emit_insn (rtx x)\n+{\n+  rtvec vec = rtvec_alloc (2);\n+\n+  RTVEC_ELT (vec, 0) = x;\n+  RTVEC_ELT (vec, 1)\n+    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CRIS_CC0_REGNUM));\n+\n+  return emit_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+}\n+\n /* Worker function for generating movem to mem.  If FRAME_RELATED, notes\n    are added that the dwarf2 machinery understands.  */\n \n@@ -3219,23 +2888,25 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n   /* Don't use movem for just one insn.  The insns are equivalent.  */\n   if (nregs == 1)\n     {\n-      rtx mov = gen_rtx_SET (dest, gen_rtx_REG (SImode, 0));\n-\n       if (increment == 0)\n \t{\n-\t  insn = emit_insn (mov);\n+\t  insn = emit_move_insn (dest, gen_rtx_REG (SImode, 0));\n \t  if (frame_related)\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \t  return insn;\n \t}\n \n       /* If there was a request for a side-effect, create the ordinary\n          parallel.  */\n-      vec = rtvec_alloc (2);\n+      vec = rtvec_alloc (3);\n \n+      rtx mov = gen_rtx_SET (dest, gen_rtx_REG (SImode, 0));\n       RTVEC_ELT (vec, 0) = mov;\n       RTVEC_ELT (vec, 1) = gen_rtx_SET (destreg, plus_constant (Pmode, destreg,\n \t\t\t\t\t\t\t\tincrement));\n+      RTVEC_ELT (vec, 2)\n+\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CRIS_CC0_REGNUM));\n+\n       if (frame_related)\n \t{\n \t  RTX_FRAME_RELATED_P (mov) = 1;"}, {"sha": "e721d12d0a23f4749ee93257addc9df67660bbe0", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=fb062a8b7bca66243d52213a897c7a241f2b14e1", "patch": "@@ -698,11 +698,8 @@ struct cum_args {int regs;};\n \n /* Node: Condition Code */\n \n-#define NOTICE_UPDATE_CC(EXP, INSN) cris_notice_update_cc (EXP, INSN)\n-\n-/* FIXME: Maybe define CANONICALIZE_COMPARISON later, when playing with\n-   optimizations.  It is needed; currently we do this with instruction\n-   patterns and NOTICE_UPDATE_CC.  */\n+/* FIXME: Maybe define TARGET_CANONICALIZE_COMPARISON later, when\n+   playing with optimizations.  Definitely define SELECT_CC_MODE.  */\n \n \n /* Node: Costs */"}, {"sha": "7690d7f06587fcf35b7fd1ac98633376f6deb5a4", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 472, "deletions": 2126, "changes": 2598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=fb062a8b7bca66243d52213a897c7a241f2b14e1"}, {"sha": "2b55c05931b829ff5ec6d4b464e876bcdf7cbf3a", "filename": "gcc/config/cris/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fpredicates.md?ref=fb062a8b7bca66243d52213a897c7a241f2b14e1", "patch": "@@ -51,7 +51,7 @@\n \n (define_predicate \"cris_load_multiple_op\"\n   (and (match_code \"parallel\")\n-       (match_test \"cris_movem_load_rest_p (op, 0)\")))\n+       (match_test \"cris_movem_load_rest_p (op)\")))\n \n (define_predicate \"cris_store_multiple_op\"\n   (and (match_code \"parallel\")"}, {"sha": "30b5ea075af4de4e21fa8583508d085cd52b36b5", "filename": "gcc/config/cris/sync.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb062a8b7bca66243d52213a897c7a241f2b14e1/gcc%2Fconfig%2Fcris%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fsync.md?ref=fb062a8b7bca66243d52213a897c7a241f2b14e1", "patch": "@@ -123,7 +123,8 @@\n \t (match_operand:BWD 2 \"<atomic_op_op_pred>\" \"<atomic_op_op_cnstr>\")))\n    (set (match_operand:BWD 0 \"register_operand\" \"=&r\")\n \t(match_dup 1))\n-   (clobber (match_scratch:SI 3 \"=&r\"))]\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (reg:CC CRIS_CC0_REGNUM))]\n   \"<MODE>mode == QImode || !TARGET_ATOMICS_MAY_CALL_LIBFUNCS\"\n {\n   /* Can't be too sure; better ICE if this happens.  */\n@@ -226,7 +227,8 @@\n \t [(match_dup 2)\n \t  (match_dup 3)\n \t  (match_operand:BWD 4 \"register_operand\" \"r\")]\n-\t CRIS_UNSPEC_ATOMIC_SWAP_MEM))]\n+\t CRIS_UNSPEC_ATOMIC_SWAP_MEM))\n+   (clobber (reg:CC CRIS_CC0_REGNUM))]\n   \"<MODE>mode == QImode || !TARGET_ATOMICS_MAY_CALL_LIBFUNCS\"\n {\n   if (cris_cpu_version == 10)"}]}