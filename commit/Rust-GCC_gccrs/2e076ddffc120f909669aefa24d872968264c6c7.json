{"sha": "2e076ddffc120f909669aefa24d872968264c6c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUwNzZkZGZmYzEyMGY5MDk2NjlhZWZhMjRkODcyOTY4MjY0YzZjNw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-04-09T16:58:50Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-04-09T16:58:50Z"}, "message": "Removed unused functions.\n\nChanged call_address_operand() to only accept symbolic addresses.\n\nFrom-SVN: r19070", "tree": {"sha": "131f18f591a5a2c800c64b98fa61b30be21cee42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/131f18f591a5a2c800c64b98fa61b30be21cee42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e076ddffc120f909669aefa24d872968264c6c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e076ddffc120f909669aefa24d872968264c6c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e076ddffc120f909669aefa24d872968264c6c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e076ddffc120f909669aefa24d872968264c6c7/comments", "author": null, "committer": null, "parents": [{"sha": "5a5732cf8ce5f18975733a5425125a32ffa15dae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5732cf8ce5f18975733a5425125a32ffa15dae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5732cf8ce5f18975733a5425125a32ffa15dae"}], "stats": {"total": 189, "additions": 66, "deletions": 123}, "files": [{"sha": "4cc32aa303db165f37bc38319f9b846cf98ef26d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e076ddffc120f909669aefa24d872968264c6c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e076ddffc120f909669aefa24d872968264c6c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e076ddffc120f909669aefa24d872968264c6c7", "patch": "@@ -1,3 +1,12 @@\n+Thu Apr  9 16:53:59 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/m32r/m32r.c: call_address_operand(): Only accept symbolic\n+\taddresses.\n+\tsymbolic_memort_operand(), call32_operand(), int8_operand(),\n+\tint16_operand(), uint24_operand(), reg_or_int8_operand(): Removed.\n+\tNot used.\n+\tuint16_operand(): Made static.\n+\n Thu Apr  9 01:43:04 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* calls.c (expand_call): Fix typo."}, {"sha": "0b7b631d7b0d10e5a46870d7c46f41466f358236", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 57, "deletions": 123, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e076ddffc120f909669aefa24d872968264c6c7/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e076ddffc120f909669aefa24d872968264c6c7/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=2e076ddffc120f909669aefa24d872968264c6c7", "patch": "@@ -1,4 +1,4 @@\n-/* Subroutines used for code generation on the M32R/D cpu.\n+/* Subroutines used for code generation on the Mitsubishi M32R cpu.\n    Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -18,8 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#include <stdio.h>\n #include \"config.h\"\n+#include <stdio.h>\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -416,9 +416,10 @@ call_address_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  return (symbolic_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && LEGITIMATE_CONSTANT_P (op))\n-\t  || (GET_CODE (op) == REG));\n+  return symbolic_operand (op, mode);\n+\n+  /* Constants and values in registers are not OK, because\n+     the m32r BL instruction can only support PC relative branching.  */ \n }\n \n int\n@@ -450,23 +451,6 @@ symbolic_operand (op, mode)\n     }\n }\n \n-/* Return truth value of statement that OP is a symbolic memory\n-   operand of mode MODE.  */\n-\n-int\n-symbolic_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n-\t  || GET_CODE (op) == LABEL_REF);\n-}\n-\n /* Return 1 if OP is a reference to an object in .sdata/.sbss.  */\n \n int\n@@ -561,16 +545,6 @@ call26_operand (op, mode)\n   return TARGET_CALL26;\n }\n \n-/* Return 1 if OP is a function that must be called with 32 bit addressing.  */\n-\n-int\n-call32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return ! call26_operand (op, mode);\n-}\n-\n /* Returns 1 if OP is an acceptable operand for seth/add3.  */\n \n int\n@@ -592,30 +566,6 @@ seth_add3_operand (op, mode)\n   return 0;\n }\n \n-/* Return true if OP is a signed 8 bit immediate value.  */\n-\n-int\n-int8_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return INT8_P (INTVAL (op));\n-}\n-\n-/* Return true if OP is a signed 16 bit immediate value.  */\n-\n-int\n-int16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return INT16_P (INTVAL (op));\n-}\n-\n /* Return true if OP is a signed 16 bit immediate value\n    useful in comparisons.  */\n \n@@ -631,7 +581,7 @@ cmp_int16_operand (op, mode)\n \n /* Return true if OP is an unsigned 16 bit immediate value.  */\n \n-int\n+static int\n uint16_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n@@ -641,32 +591,6 @@ uint16_operand (op, mode)\n   return UINT16_P (INTVAL (op));\n }\n \n-/* Return true if OP is an unsigned 24 bit immediate value.  */\n-\n-int\n-uint24_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return UINT24_P (INTVAL (op));\n-}\n-\n-/* Return true if OP is a register or signed 8 bit value.  */\n-\n-int\n-reg_or_int8_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n-    return register_operand (op, mode);\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return INT8_P (INTVAL (op));\n-}\n-\n /* Return true if OP is a register or signed 8 bit value.  */\n \n int\n@@ -681,7 +605,7 @@ reg_or_int16_operand (op, mode)\n   return INT16_P (INTVAL (op));\n }\n \n-/* Return true if OP is a register or signed 8 bit value.  */\n+/* Return true if OP is a register or an unsigned 16 bit value.  */\n \n int\n reg_or_uint16_operand (op, mode)\n@@ -937,24 +861,26 @@ m32r_select_cc_mode (op, x, y)\n rtx\n gen_compare (code, x, y)\n      enum rtx_code code;\n-     rtx x, y;\n+     rtx           x;\n+     rtx           y;\n {\n-  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n-  enum rtx_code compare_code, branch_code;\n-  rtx cc_reg = gen_rtx (REG, mode, CARRY_REGNUM);\n-  int swap_p = 0;\n+  enum rtx_code     compare_code;\n+  enum rtx_code     branch_code;\n+  enum machine_mode mode      = SELECT_CC_MODE (code, x, y);\n+  rtx               cc_reg    = gen_rtx (REG, mode, CARRY_REGNUM);\n+  int               must_swap = 0;\n \n   switch (code)\n     {\n-    case EQ: compare_code = EQ; branch_code = NE; break;\n-    case NE: compare_code = EQ; branch_code = EQ; break;\n-    case LT: compare_code = LT; branch_code = NE; break;\n-    case LE: compare_code = LT; branch_code = EQ; swap_p = 1; break;\n-    case GT: compare_code = LT; branch_code = NE; swap_p = 1; break;\n-    case GE: compare_code = LT; branch_code = EQ; break;\n+    case EQ:  compare_code = EQ;  branch_code = NE; break;\n+    case NE:  compare_code = EQ;  branch_code = EQ; break;\n+    case LT:  compare_code = LT;  branch_code = NE; break;\n+    case LE:  compare_code = LT;  branch_code = EQ; must_swap = 1; break;\n+    case GT:  compare_code = LT;  branch_code = NE; must_swap = 1; break;\n+    case GE:  compare_code = LT;  branch_code = EQ; break;\n     case LTU: compare_code = LTU; branch_code = NE; break;\n-    case LEU: compare_code = LTU; branch_code = EQ; swap_p = 1; break;\n-    case GTU: compare_code = LTU; branch_code = NE; swap_p = 1; break;\n+    case LEU: compare_code = LTU; branch_code = EQ; must_swap = 1; break;\n+    case GTU: compare_code = LTU; branch_code = NE; must_swap = 1; break;\n     case GEU: compare_code = LTU; branch_code = EQ; break;\n     }\n \n@@ -964,10 +890,12 @@ gen_compare (code, x, y)\n       if (compare_code == EQ\n \t  && register_operand (y, SImode))\n \treturn gen_rtx (code, mode, x, y);\n+      \n       /* reg/zero signed comparison */\n       if ((compare_code == EQ || compare_code == LT)\n \t  && y == const0_rtx)\n \treturn gen_rtx (code, mode, x, y);\n+      \n       /* reg/smallconst equal comparison */\n       if (compare_code == EQ\n \t  && GET_CODE (y) == CONST_INT\n@@ -977,6 +905,7 @@ gen_compare (code, x, y)\n \t  emit_insn (gen_cmp_ne_small_const_insn (tmp, x, y));\n \t  return gen_rtx (code, mode, tmp, const0_rtx);\n \t}\n+      \n       /* reg/const equal comparison */\n       if (compare_code == EQ\n \t  && CONSTANT_P (y))\n@@ -986,28 +915,32 @@ gen_compare (code, x, y)\n \t}\n     }\n \n-  if (swap_p && CONSTANT_P (y))\n-    y = force_reg (GET_MODE (x), y);\n-  else if (CONSTANT_P (y))\n+  if (CONSTANT_P (y))\n     {\n-      int ok_const_p =\n-\t(code == LTU || code == LEU || code == GTU || code == GEU)\n-\t  ? uint16_operand (y, GET_MODE (y))\n-\t  : reg_or_cmp_int16_operand (y, GET_MODE (y));\n-      if (! ok_const_p)\n+      if (must_swap)\n \ty = force_reg (GET_MODE (x), y);\n+      else\n+\t{\n+\t  int ok_const =\n+\t    (code == LTU || code == LEU || code == GTU || code == GEU)\n+\t    ? uint16_operand (y, GET_MODE (y))\n+\t    : reg_or_cmp_int16_operand (y, GET_MODE (y));\n+\t  \n+\t  if (! ok_const)\n+\t    y = force_reg (GET_MODE (x), y);\n+\t}\n     }\n \n   switch (compare_code)\n     {\n     case EQ :\n-      emit_insn (gen_cmp_eqsi_insn (swap_p ? y : x, swap_p ? x : y));\n+      emit_insn (gen_cmp_eqsi_insn (must_swap ? y : x, must_swap ? x : y));\n       break;\n     case LT :\n-      emit_insn (gen_cmp_ltsi_insn (swap_p ? y : x, swap_p ? x : y));\n+      emit_insn (gen_cmp_ltsi_insn (must_swap ? y : x, must_swap ? x : y));\n       break;\n     case LTU :\n-      emit_insn (gen_cmp_ltusi_insn (swap_p ? y : x, swap_p ? x : y));\n+      emit_insn (gen_cmp_ltusi_insn (must_swap ? y : x, must_swap ? x : y));\n       break;\n     }\n \n@@ -1289,8 +1222,8 @@ m32r_compute_frame_size (size)\n \n void\n m32r_output_function_prologue (file, size)\n-     FILE *file;\n-     int size;\n+     FILE * file;\n+     int    size;\n {\n   int regno;\n   int total_size, frame_size;\n@@ -1388,8 +1321,8 @@ m32r_output_function_prologue (file, size)\n \n void\n m32r_output_function_epilogue (file, size)\n-     FILE *file;\n-     int size;\n+     FILE * file;\n+     int    size;\n {\n   int regno;\n   int noepilogue = FALSE;\n@@ -1423,8 +1356,8 @@ m32r_output_function_epilogue (file, size)\n       unsigned int args_size = current_frame_info.args_size;\n       unsigned int gmask = current_frame_info.gmask;\n       int can_trust_sp_p = !current_function_calls_alloca;\n-      char *sp_str = reg_names[STACK_POINTER_REGNUM];\n-      char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+      char * sp_str = reg_names[STACK_POINTER_REGNUM];\n+      char * fp_str = reg_names[FRAME_POINTER_REGNUM];\n \n       /* The first thing to do is point the sp at the bottom of the register\n \t save area.  */\n@@ -1525,7 +1458,7 @@ m32r_initialize_trampoline (tramp, fnaddr, cxt)\n \n void\n m32r_asm_file_start (file)\n-     FILE *file;\n+     FILE * file;\n {\n   if (flag_verbose_asm)\n     fprintf (file, \"%s M32R/D special options: -G %d\\n\",\n@@ -1538,9 +1471,9 @@ m32r_asm_file_start (file)\n \n void\n m32r_print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+     FILE * file;\n+     rtx    x;\n+     int    code;\n {\n   switch (code)\n     {\n@@ -1655,7 +1588,7 @@ m32r_print_operand (file, x, code)\n       break;\n \n     case 'U' :\n-      /* FIXME: wip */\n+      /* ??? wip */\n       /* Output a load/store with update indicator if appropriate.  */\n       if (GET_CODE (x) == MEM)\n \t{\n@@ -1750,11 +1683,12 @@ m32r_print_operand (file, x, code)\n \n void\n m32r_print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+     FILE * file;\n+     rtx    addr;\n {\n-  register rtx base, index = 0;\n-  int offset = 0;\n+  register rtx base;\n+  register rtx index = 0;\n+  int          offset = 0;\n \n   switch (GET_CODE (addr))\n     {"}]}