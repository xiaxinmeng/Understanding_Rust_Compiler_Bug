{"sha": "4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5M2M5NWFjNTA4NmI0YmIwNTYyZTg3ZGNmYzMzOGJkNGIyMjI1Yg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2005-10-24T09:11:51Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2005-10-24T09:11:51Z"}, "message": "re PR fortran/15586 (gfortran should support i18n in its compiler messages)\n\n\tPR fortran/15586\n\t* arith.c (gfc_arith_error): Change message to include locus.\n\t(check_result, eval_intrinsic, gfc_int2int, gfc_real2real,\n\tgfc_real2complex, gfc_complex2real, gfc_complex2complex): Use\n\tthe new gfc_arith_error.\n\t(arith_error): Rewrite full error messages instead of building\n\tthem from pieces.\n\t* check.c (must_be): Removed.\n\t(type_check, numeric_check, int_or_real_check, real_or_complex_check,\n\tkind_check, double_check, logical_array_check, array_check,\n\tscalar_check, same_type_check, rank_check, kind_value_check,\n\tvariable_check, gfc_check_allocated, gfc_check_associated,\n\tgfc_check_cmplx, gfc_check_dcmplx, gfc_check_dot_product,\n\tgfc_check_index, gfc_check_kind, gfc_check_matmul, gfc_check_null,\n\tgfc_check_pack, gfc_check_precision, gfc_check_present,\n\tgfc_check_spread): Rewrite full error messages instead of\n\tbuilding them from pieces.\n\t* decl.c (gfc_match_entry): Rewrite full error messages instead\n\tof building them from pieces.\n\t* parse.c (gfc_state_name): Remove.\n\t* parse.h: Remove prototype for gfc_state_name.\n\nFrom-SVN: r105844", "tree": {"sha": "0248353a9119382348e932d54cf3de18649875b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0248353a9119382348e932d54cf3de18649875b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "835681c8a218a2625d97f84c08a3789b373a2336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/835681c8a218a2625d97f84c08a3789b373a2336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/835681c8a218a2625d97f84c08a3789b373a2336"}], "stats": {"total": 353, "additions": 213, "deletions": 140}, "files": [{"sha": "5cb021b391f20ad238fbbfc8d883e7416686b086", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "patch": "@@ -1,3 +1,27 @@\n+2005-10-24  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/15586\n+\t* arith.c (gfc_arith_error): Change message to include locus.\n+\t(check_result, eval_intrinsic, gfc_int2int, gfc_real2real,\n+\tgfc_real2complex, gfc_complex2real, gfc_complex2complex): Use\n+\tthe new gfc_arith_error.\n+\t(arith_error): Rewrite full error messages instead of building\n+\tthem from pieces.\n+\t* check.c (must_be): Removed.\n+\t(type_check, numeric_check, int_or_real_check, real_or_complex_check,\n+\tkind_check, double_check, logical_array_check, array_check,\n+\tscalar_check, same_type_check, rank_check, kind_value_check,\n+\tvariable_check, gfc_check_allocated, gfc_check_associated,\n+\tgfc_check_cmplx, gfc_check_dcmplx, gfc_check_dot_product,\n+\tgfc_check_index, gfc_check_kind, gfc_check_matmul, gfc_check_null,\n+\tgfc_check_pack, gfc_check_precision, gfc_check_present,\n+\tgfc_check_spread): Rewrite full error messages instead of\n+\tbuilding them from pieces.\n+\t* decl.c (gfc_match_entry): Rewrite full error messages instead\n+\tof building them from pieces.\n+\t* parse.c (gfc_state_name): Remove.\n+\t* parse.h: Remove prototype for gfc_state_name.\n+\n 2005-10-23  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR fortran/23635"}, {"sha": "e0c1f4b7e66ae098991a8ec5a7313055501986b5", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "patch": "@@ -138,25 +138,26 @@ gfc_arith_error (arith code)\n   switch (code)\n     {\n     case ARITH_OK:\n-      p = _(\"Arithmetic OK\");\n+      p = _(\"Arithmetic OK at %L\");\n       break;\n     case ARITH_OVERFLOW:\n-      p = _(\"Arithmetic overflow\");\n+      p = _(\"Arithmetic overflow at %L\");\n       break;\n     case ARITH_UNDERFLOW:\n-      p = _(\"Arithmetic underflow\");\n+      p = _(\"Arithmetic underflow at %L\");\n       break;\n     case ARITH_NAN:\n-      p = _(\"Arithmetic NaN\");\n+      p = _(\"Arithmetic NaN at %L\");\n       break;\n     case ARITH_DIV0:\n-      p = _(\"Division by zero\");\n+      p = _(\"Division by zero at %L\");\n       break;\n     case ARITH_INCOMMENSURATE:\n-      p = _(\"Array operands are incommensurate\");\n+      p = _(\"Array operands are incommensurate at %L\");\n       break;\n     case ARITH_ASYMMETRIC:\n-      p = _(\"Integer outside symmetric range implied by Standard Fortran\");\n+      p =\n+\t_(\"Integer outside symmetric range implied by Standard Fortran at %L\");\n       break;\n     default:\n       gfc_internal_error (\"gfc_arith_error(): Bad error code\");\n@@ -598,13 +599,13 @@ check_result (arith rc, gfc_expr * x, gfc_expr * r, gfc_expr ** rp)\n   if (val == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-\tgfc_warning (\"%s at %L\", gfc_arith_error (val), &x->where);\n+\tgfc_warning (gfc_arith_error (val), &x->where);\n       val = ARITH_OK;\n     }\n \n   if (val == ARITH_ASYMMETRIC)\n     {\n-      gfc_warning (\"%s at %L\", gfc_arith_error (val), &x->where);\n+      gfc_warning (gfc_arith_error (val), &x->where);\n       val = ARITH_OK;\n     }\n \n@@ -1604,7 +1605,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n   if (rc != ARITH_OK)\n     {\t\t\t\t/* Something went wrong */\n-      gfc_error (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n+      gfc_error (gfc_arith_error (rc), &op1->where);\n       return NULL;\n     }\n \n@@ -1907,8 +1908,40 @@ gfc_convert_complex (gfc_expr * real, gfc_expr * imag, int kind)\n static void\n arith_error (arith rc, gfc_typespec * from, gfc_typespec * to, locus * where)\n {\n-  gfc_error (\"%s converting %s to %s at %L\", gfc_arith_error (rc),\n-\t     gfc_typename (from), gfc_typename (to), where);\n+  switch (rc)\n+    {\n+    case ARITH_OK:\n+      gfc_error (\"Arithmetic OK converting %s to %s at %L\",\n+\t\t gfc_typename (from), gfc_typename (to), where);\n+      break;\n+    case ARITH_OVERFLOW:\n+      gfc_error (\"Arithmetic overflow converting %s to %s at %L\",\n+\t\t gfc_typename (from), gfc_typename (to), where);\n+      break;\n+    case ARITH_UNDERFLOW:\n+      gfc_error (\"Arithmetic underflow converting %s to %s at %L\",\n+\t\t gfc_typename (from), gfc_typename (to), where);\n+      break;\n+    case ARITH_NAN:\n+      gfc_error (\"Arithmetic NaN converting %s to %s at %L\",\n+\t\t gfc_typename (from), gfc_typename (to), where);\n+      break;\n+    case ARITH_DIV0:\n+      gfc_error (\"Division by zero converting %s to %s at %L\",\n+\t\t gfc_typename (from), gfc_typename (to), where);\n+      break;\n+    case ARITH_INCOMMENSURATE:\n+      gfc_error (\"Array operands are incommensurate converting %s to %s at %L\",\n+\t\t gfc_typename (from), gfc_typename (to), where);\n+      break;\n+    case ARITH_ASYMMETRIC:\n+      gfc_error (\"Integer outside symmetric range implied by Standard Fortran\"\n+\t \t \" converting %s to %s at %L\",\n+\t\t gfc_typename (from), gfc_typename (to), where);\n+      break;\n+    default:\n+      gfc_internal_error (\"gfc_arith_error(): Bad error code\");\n+    }\n \n   /* TODO: Do something about the error, ie, throw exception, return\n      NaN, etc.  */\n@@ -1931,7 +1964,7 @@ gfc_int2int (gfc_expr * src, int kind)\n     {\n       if (rc == ARITH_ASYMMETRIC)\n         {\n-          gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n+          gfc_warning (gfc_arith_error (rc), &src->where);\n         }\n       else\n         {\n@@ -2033,7 +2066,7 @@ gfc_real2real (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n+        gfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n@@ -2065,7 +2098,7 @@ gfc_real2complex (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n+        gfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n@@ -2120,7 +2153,7 @@ gfc_complex2real (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n+        gfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n     }\n   if (rc != ARITH_OK)\n@@ -2152,7 +2185,7 @@ gfc_complex2complex (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n+        gfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n@@ -2167,7 +2200,7 @@ gfc_complex2complex (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n+        gfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)"}, {"sha": "49a7505be6fc648b501a46b6585750e19d1598e8", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 88, "deletions": 60, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "patch": "@@ -33,18 +33,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"intrinsic.h\"\n \n \n-/* The fundamental complaint function of this source file.  This\n-   function can be called in all kinds of ways.  */\n-\n-static void\n-must_be (gfc_expr * e, int n, const char *thing_msgid)\n-{\n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be %s\",\n-\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where,\n-\t     thing_msgid);\n-}\n-\n-\n /* Check the type of an expression.  */\n \n static try\n@@ -53,7 +41,9 @@ type_check (gfc_expr * e, int n, bt type)\n   if (e->ts.type == type)\n     return SUCCESS;\n \n-  must_be (e, n, gfc_basic_typename (type));\n+  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be %s\",\n+\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where,\n+\t     gfc_basic_typename (type));\n \n   return FAILURE;\n }\n@@ -67,7 +57,8 @@ numeric_check (gfc_expr * e, int n)\n   if (gfc_numeric_ts (&e->ts))\n     return SUCCESS;\n \n-  must_be (e, n, \"a numeric type\");\n+  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a numeric type\",\n+\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n \n   return FAILURE;\n }\n@@ -80,7 +71,9 @@ int_or_real_check (gfc_expr * e, int n)\n {\n   if (e->ts.type != BT_INTEGER && e->ts.type != BT_REAL)\n     {\n-      must_be (e, n, \"INTEGER or REAL\");\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or REAL\",\n+\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n       return FAILURE;\n     }\n \n@@ -95,7 +88,9 @@ real_or_complex_check (gfc_expr * e, int n)\n {\n   if (e->ts.type != BT_REAL && e->ts.type != BT_COMPLEX)\n     {\n-      must_be (e, n, \"REAL or COMPLEX\");\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be REAL or COMPLEX\",\n+\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n       return FAILURE;\n     }\n \n@@ -119,7 +114,9 @@ kind_check (gfc_expr * k, int n, bt type)\n \n   if (k->expr_type != EXPR_CONSTANT)\n     {\n-      must_be (k, n, \"a constant\");\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be a constant\",\n+\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &k->where);\n       return FAILURE;\n     }\n \n@@ -145,7 +142,9 @@ double_check (gfc_expr * d, int n)\n \n   if (d->ts.kind != gfc_default_double_kind)\n     {\n-      must_be (d, n, \"double precision\");\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be double precision\",\n+\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &d->where);\n       return FAILURE;\n     }\n \n@@ -160,7 +159,9 @@ logical_array_check (gfc_expr * array, int n)\n {\n   if (array->ts.type != BT_LOGICAL || array->rank == 0)\n     {\n-      must_be (array, n, \"a logical array\");\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be a logical array\",\n+\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &array->where);\n       return FAILURE;\n     }\n \n@@ -176,7 +177,8 @@ array_check (gfc_expr * e, int n)\n   if (e->rank != 0)\n     return SUCCESS;\n \n-  must_be (e, n, \"an array\");\n+  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be an array\",\n+\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n \n   return FAILURE;\n }\n@@ -190,7 +192,8 @@ scalar_check (gfc_expr * e, int n)\n   if (e->rank == 0)\n     return SUCCESS;\n \n-  must_be (e, n, \"a scalar\");\n+  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a scalar\",\n+\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n \n   return FAILURE;\n }\n@@ -201,16 +204,12 @@ scalar_check (gfc_expr * e, int n)\n static try\n same_type_check (gfc_expr * e, int n, gfc_expr * f, int m)\n {\n-  char message[100];\n-\n   if (gfc_compare_types (&e->ts, &f->ts))\n     return SUCCESS;\n \n-  sprintf (message, _(\"the same type and kind as '%s'\"),\n-\t   gfc_current_intrinsic_arg[n]);\n-\n-  must_be (f, m, message);\n-\n+  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be the same type \"\n+\t     \"and kind as '%s'\", gfc_current_intrinsic_arg[m],\n+\t     gfc_current_intrinsic, &f->where, gfc_current_intrinsic_arg[n]);\n   return FAILURE;\n }\n \n@@ -220,15 +219,12 @@ same_type_check (gfc_expr * e, int n, gfc_expr * f, int m)\n static try\n rank_check (gfc_expr * e, int n, int rank)\n {\n-  char message[100];\n-\n   if (e->rank == rank)\n     return SUCCESS;\n \n-  sprintf (message, _(\"of rank %d\"), rank);\n-\n-  must_be (e, n, message);\n-\n+  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of rank %d\",\n+\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t     &e->where, rank);\n   return FAILURE;\n }\n \n@@ -257,14 +253,12 @@ nonoptional_check (gfc_expr * e, int n)\n static try\n kind_value_check (gfc_expr * e, int n, int k)\n {\n-  char message[100];\n-\n   if (e->ts.kind == k)\n     return SUCCESS;\n \n-  sprintf (message, _(\"of kind %d\"), k);\n-\n-  must_be (e, n, message);\n+  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of kind %d\",\n+\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t     &e->where, k);\n   return FAILURE;\n }\n \n@@ -289,7 +283,8 @@ variable_check (gfc_expr * e, int n)\n       return FAILURE;\n     }\n \n-  must_be (e, n, \"a variable\");\n+  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a variable\",\n+\t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n \n   return FAILURE;\n }\n@@ -436,7 +431,9 @@ gfc_check_allocated (gfc_expr * array)\n \n   if (!array->symtree->n.sym->attr.allocatable)\n     {\n-      must_be (array, 0, \"ALLOCATABLE\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n+\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n+\t\t &array->where);\n       return FAILURE;\n     }\n \n@@ -473,7 +470,9 @@ gfc_check_associated (gfc_expr * pointer, gfc_expr * target)\n   attr = gfc_variable_attr (pointer, NULL);\n   if (!attr.pointer)\n     {\n-      must_be (pointer, 0, \"a POINTER\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER\",\n+\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n+\t\t &pointer->where);\n       return FAILURE;\n     }\n \n@@ -492,7 +491,9 @@ gfc_check_associated (gfc_expr * pointer, gfc_expr * target)\n   attr = gfc_variable_attr (target, NULL);\n   if (!attr.pointer && !attr.target)\n     {\n-      must_be (target, 1, \"a POINTER or a TARGET\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER \"\n+\t\t \"or a TARGET\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &target->where);\n       return FAILURE;\n     }\n \n@@ -616,7 +617,9 @@ gfc_check_cmplx (gfc_expr * x, gfc_expr * y, gfc_expr * kind)\n \n       if (x->ts.type == BT_COMPLEX)\n \t{\n-\t  must_be (y, 1, \"not be present if 'x' is COMPLEX\");\n+\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be \"\n+\t\t     \"present if 'x' is COMPLEX\", gfc_current_intrinsic_arg[1],\n+\t\t     gfc_current_intrinsic, &y->where);\n \t  return FAILURE;\n \t}\n     }\n@@ -676,7 +679,9 @@ gfc_check_dcmplx (gfc_expr * x, gfc_expr * y)\n \n       if (x->ts.type == BT_COMPLEX)\n \t{\n-\t  must_be (y, 1, \"not be present if 'x' is COMPLEX\");\n+\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be \"\n+\t\t     \"present if 'x' is COMPLEX\", gfc_current_intrinsic_arg[1],\n+\t\t     gfc_current_intrinsic, &y->where);\n \t  return FAILURE;\n \t}\n     }\n@@ -723,7 +728,9 @@ gfc_check_dot_product (gfc_expr * vector_a, gfc_expr * vector_b)\n       break;\n \n     default:\n-      must_be (vector_a, 0, \"numeric or LOGICAL\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &vector_a->where);\n       return FAILURE;\n     }\n \n@@ -1027,7 +1034,10 @@ gfc_check_index (gfc_expr * string, gfc_expr * substring, gfc_expr * back)\n \n   if (string->ts.kind != substring->ts.kind)\n     {\n-      must_be (substring, 1, \"the same kind as 'string'\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be the same \"\n+\t\t \"kind as '%s'\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &substring->where,\n+\t\t gfc_current_intrinsic_arg[0]);\n       return FAILURE;\n     }\n \n@@ -1139,7 +1149,9 @@ gfc_check_kind (gfc_expr * x)\n {\n   if (x->ts.type == BT_DERIVED)\n     {\n-      must_be (x, 0, \"a non-derived type\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a \"\n+\t\t \"non-derived type\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &x->where);\n       return FAILURE;\n     }\n \n@@ -1350,13 +1362,17 @@ gfc_check_matmul (gfc_expr * matrix_a, gfc_expr * matrix_b)\n {\n   if ((matrix_a->ts.type != BT_LOGICAL) && !gfc_numeric_ts (&matrix_b->ts))\n     {\n-      must_be (matrix_a, 0, \"numeric or LOGICAL\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &matrix_a->where);\n       return FAILURE;\n     }\n \n   if ((matrix_b->ts.type != BT_LOGICAL) && !gfc_numeric_ts (&matrix_a->ts))\n     {\n-      must_be (matrix_b, 0, \"numeric or LOGICAL\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &matrix_b->where);\n       return FAILURE;\n     }\n \n@@ -1375,7 +1391,9 @@ gfc_check_matmul (gfc_expr * matrix_a, gfc_expr * matrix_b)\n       break;\n \n     default:\n-      must_be (matrix_a, 0, \"of rank 1 or 2\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of rank \"\n+\t\t \"1 or 2\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &matrix_a->where);\n       return FAILURE;\n     }\n \n@@ -1540,7 +1558,9 @@ gfc_check_null (gfc_expr * mold)\n \n   if (!attr.pointer)\n     {\n-      must_be (mold, 0, \"a POINTER\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER\",\n+\t\t gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &mold->where);\n       return FAILURE;\n     }\n \n@@ -1559,7 +1579,10 @@ gfc_check_pack (gfc_expr * array, gfc_expr * mask, gfc_expr * vector)\n \n   if (mask->rank != 0 && mask->rank != array->rank)\n     {\n-      must_be (array, 0, \"conformable with 'mask' argument\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be conformable \"\n+\t\t \"with '%s' argument\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &array->where,\n+\t\t gfc_current_intrinsic_arg[1]);\n       return FAILURE;\n     }\n \n@@ -1583,7 +1606,9 @@ gfc_check_precision (gfc_expr * x)\n {\n   if (x->ts.type != BT_REAL && x->ts.type != BT_COMPLEX)\n     {\n-      must_be (x, 0, \"of type REAL or COMPLEX\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of type \"\n+\t\t \"REAL or COMPLEX\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &x->where);\n       return FAILURE;\n     }\n \n@@ -1602,13 +1627,17 @@ gfc_check_present (gfc_expr * a)\n   sym = a->symtree->n.sym;\n   if (!sym->attr.dummy)\n     {\n-      must_be (a, 0, \"a dummy variable\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of a \"\n+\t\t \"dummy variable\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &a->where);\n       return FAILURE;\n     }\n \n   if (!sym->attr.optional)\n     {\n-      must_be (a, 0, \"an OPTIONAL dummy variable\");\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of \"\n+\t\t \"an OPTIONAL dummy variable\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &a->where);\n       return FAILURE;\n     }\n \n@@ -1906,10 +1935,9 @@ gfc_check_spread (gfc_expr * source, gfc_expr * dim, gfc_expr * ncopies)\n {\n   if (source->rank >= GFC_MAX_DIMENSIONS)\n     {\n-      char message[100];\n-\n-      sprintf (message, _(\"less than rank %d\"), GFC_MAX_DIMENSIONS);\n-      must_be (source, 0, message);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be less \"\n+\t\t \"than rank %d\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &source->where, GFC_MAX_DIMENSIONS);\n \n       return FAILURE;\n     }"}, {"sha": "69c0fc87162d92683a3218a7f710bad4a3b78c01", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "patch": "@@ -2419,11 +2419,57 @@ gfc_match_entry (void)\n     return m;\n \n   state = gfc_current_state ();\n-  if (state != COMP_SUBROUTINE\n-      && state != COMP_FUNCTION)\n+  if (state != COMP_SUBROUTINE && state != COMP_FUNCTION)\n     {\n-      gfc_error (\"ENTRY statement at %C cannot appear within %s\",\n-\t\t gfc_state_name (gfc_current_state ()));\n+      switch (state)\n+\t{\n+\t  case COMP_PROGRAM:\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within a PROGRAM\");\n+\t    break;\n+\t  case COMP_MODULE:\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within a MODULE\");\n+\t    break;\n+\t  case COMP_BLOCK_DATA:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear within a BLOCK DATA\");\n+\t    break;\n+\t  case COMP_INTERFACE:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear within an INTERFACE\");\n+\t    break;\n+\t  case COMP_DERIVED:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear \"\n+\t       \"within a DERIVED TYPE block\");\n+\t    break;\n+\t  case COMP_IF:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear within an IF-THEN block\");\n+\t    break;\n+\t  case COMP_DO:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear within a DO block\");\n+\t    break;\n+\t  case COMP_SELECT:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear within a SELECT block\");\n+\t    break;\n+\t  case COMP_FORALL:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear within a FORALL block\");\n+\t    break;\n+\t  case COMP_WHERE:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear within a WHERE block\");\n+\t    break;\n+\t  case COMP_CONTAINS:\n+\t    gfc_error\n+\t      (\"ENTRY statement at %C cannot appear \"\n+\t       \"within a contained subprogram\");\n+\t    break;\n+\t  default:\n+\t    gfc_internal_error (\"gfc_match_entry(): Bad state\");\n+\t}\n       return MATCH_ERROR;\n     }\n "}, {"sha": "69459251f04c351a2ba2eade283f75391613e7ab", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "patch": "@@ -959,63 +959,6 @@ gfc_ascii_statement (gfc_statement st)\n }\n \n \n-/* Return the name of a compile state.  */\n-\n-const char *\n-gfc_state_name (gfc_compile_state state)\n-{\n-  const char *p;\n-\n-  switch (state)\n-    {\n-    case COMP_PROGRAM:\n-      p = _(\"a PROGRAM\");\n-      break;\n-    case COMP_MODULE:\n-      p = _(\"a MODULE\");\n-      break;\n-    case COMP_SUBROUTINE:\n-      p = _(\"a SUBROUTINE\");\n-      break;\n-    case COMP_FUNCTION:\n-      p = _(\"a FUNCTION\");\n-      break;\n-    case COMP_BLOCK_DATA:\n-      p = _(\"a BLOCK DATA\");\n-      break;\n-    case COMP_INTERFACE:\n-      p = _(\"an INTERFACE\");\n-      break;\n-    case COMP_DERIVED:\n-      p = _(\"a DERIVED TYPE block\");\n-      break;\n-    case COMP_IF:\n-      p = _(\"an IF-THEN block\");\n-      break;\n-    case COMP_DO:\n-      p = _(\"a DO block\");\n-      break;\n-    case COMP_SELECT:\n-      p = _(\"a SELECT block\");\n-      break;\n-    case COMP_FORALL:\n-      p = _(\"a FORALL block\");\n-      break;\n-    case COMP_WHERE:\n-      p = _(\"a WHERE block\");\n-      break;\n-    case COMP_CONTAINS:\n-      p = _(\"a contained subprogram\");\n-      break;\n-\n-    default:\n-      gfc_internal_error (\"gfc_state_name(): Bad state\");\n-    }\n-\n-  return p;\n-}\n-\n-\n /* Do whatever is necessary to accept the last statement.  */\n \n static void"}, {"sha": "1460ff301f6f3ad3ff6d002edde85339c8c6ed9f", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c93c95ac5086b4bb0562e87dcfc338bd4b2225b/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=4c93c95ac5086b4bb0562e87dcfc338bd4b2225b", "patch": "@@ -63,6 +63,5 @@ int gfc_check_do_variable (gfc_symtree *);\n try gfc_find_state (gfc_compile_state);\n gfc_state_data *gfc_enclosing_unit (gfc_compile_state *);\n const char *gfc_ascii_statement (gfc_statement);\n-const char *gfc_state_name (gfc_compile_state);\n \n #endif  /* GFC_PARSE_H  */"}]}