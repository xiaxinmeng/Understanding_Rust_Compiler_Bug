{"sha": "040c57570147b0a05c29339dd778378b8cf15a56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQwYzU3NTcwMTQ3YjBhMDVjMjkzMzlkZDc3ODM3OGI4Y2YxNWE1Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-19T18:46:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-19T18:46:30Z"}, "message": "mn10300: tidy pic address loading\n\nThere's little reason to greatly complicate things by splitting\nthe pic_load patterns and using complex rtl to make it work out.\nInstead, use the %= marker to generate unique numbers and emit\nthe entire load_pic sequence at once.\n\nAt the same time, collect all references to outgoing_args_size\ninto mn10300_frame_size, and all computations of register save\narea size into mn10300_initial_offset.\n\nFrom-SVN: r169012", "tree": {"sha": "b53191eb6304d67c68c266be80195b8b3e0a8733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b53191eb6304d67c68c266be80195b8b3e0a8733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/040c57570147b0a05c29339dd778378b8cf15a56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040c57570147b0a05c29339dd778378b8cf15a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040c57570147b0a05c29339dd778378b8cf15a56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040c57570147b0a05c29339dd778378b8cf15a56/comments", "author": null, "committer": null, "parents": [{"sha": "bad41521231654dafc67f31cb8abfa47ad09c691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad41521231654dafc67f31cb8abfa47ad09c691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad41521231654dafc67f31cb8abfa47ad09c691"}], "stats": {"total": 336, "additions": 118, "deletions": 218}, "files": [{"sha": "dcdd569812f3261f3f2e1e1c5e0c053ad5de2b4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=040c57570147b0a05c29339dd778378b8cf15a56", "patch": "@@ -1,5 +1,24 @@\n 2011-01-19  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300.c (mn10300_unspec_int_label_counter): Remove.\n+\t(mn10300_asm_output_addr_const_extra): Don't handle UNSPEC_INT_LABEL.\n+\t(mn10300_legitimate_constant_p): Likewise.\n+\t(mn10300_can_use_return_insn): Use mn10300_initial_offset.\n+\t(mn10300_frame_size): New.\n+\t(mn10300_expand_prologue): Use it.\n+\t(mn10300_expand_epilogue): Likewise.\n+\t(mn10300_initial_offset): Likewise.\n+\t* config/mn10300/mn10300-protos.h: Update.\n+\t* config/mn10300/mn10300.h (mn10300_unspec_int_label_counter): Remove.\n+\t* config/mn10300/mn10300.md (UNSPEC_INT_LABEL): Remove.\n+\t(prologue, epilogue, return_internal): Tidy output code.\n+\t(mn10300_store_multiple_operation, return): Likewise.\n+\t(int_label, pop_pic_reg, GOTaddr2picreg): Remove.\n+\t(am33_loadPC, mn10300_loadPC, call_next_insn): Remove.\n+\t(add_GOT_to_pic_reg, add_GOT_to_any_reg): Remove.\n+\t(load_pic, am33_load_pic): New.\n+\t(mn10300_load_pic0, mn10300_load_pic1): New.\n+\n \t* config/mn10300/mn10300-modes.def (CCZN, CCZNC): New modes.\n \t* config/mn10300/mn10300.c (CC_FLAG_Z): New.\n \t(CC_FLAG_N, CC_FLAG_C, CC_FLAG_V): New."}, {"sha": "c25ba9b7cc70a737df70302e20ca9cfde3627caf", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=040c57570147b0a05c29339dd778378b8cf15a56", "patch": "@@ -49,6 +49,7 @@ extern int   mn10300_can_use_return_insn (void);\n extern void  mn10300_expand_prologue (void);\n extern void  mn10300_expand_epilogue (void);\n extern int   mn10300_initial_offset (int, int);\n+extern int   mn10300_frame_size (void);\n \n #undef Mmode\n #undef Cstar"}, {"sha": "b2c2460abc594ce9239d5363c01c083307ca7551", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 28, "deletions": 79, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=040c57570147b0a05c29339dd778378b8cf15a56", "patch": "@@ -44,10 +44,6 @@\n #include \"target-def.h\"\n #include \"df.h\"\n \n-/* This is used by GOTaddr2picreg to uniquely identify\n-   UNSPEC_INT_LABELs.  */\n-int mn10300_unspec_int_label_counter;\n-\n /* This is used in the am33_2.0-linux-gnu port, in which global symbol\n    names are not prefixed by underscores, to tell whether to prefix a\n    label with a plus sign or not, so that the assembler can tell\n@@ -544,10 +540,6 @@ mn10300_asm_output_addr_const_extra (FILE *file, rtx x)\n     {\n       switch (XINT (x, 1))\n \t{\n-\tcase UNSPEC_INT_LABEL:\n-\t  asm_fprintf (file, \".%LLIL\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t       INTVAL (XVECEXP (x, 0, 0)));\n-\t  break;\n \tcase UNSPEC_PIC:\n \t  /* GLOBAL_OFFSET_TABLE or local symbols, no suffix.  */\n \t  output_addr_const (file, XVECEXP (x, 0, 0));\n@@ -634,24 +626,7 @@ mn10300_print_reg_list (FILE *file, int mask)\n int\n mn10300_can_use_return_insn (void)\n {\n-  /* size includes the fixed stack space needed for function calls.  */\n-  int size = get_frame_size () + crtl->outgoing_args_size;\n-\n-  /* And space for the return pointer.  */\n-  size += crtl->outgoing_args_size ? 4 : 0;\n-\n-  return (reload_completed\n-\t  && size == 0\n-\t  && !df_regs_ever_live_p (2)\n-\t  && !df_regs_ever_live_p (3)\n-\t  && !df_regs_ever_live_p (6)\n-\t  && !df_regs_ever_live_p (7)\n-\t  && !df_regs_ever_live_p (14)\n-\t  && !df_regs_ever_live_p (15)\n-\t  && !df_regs_ever_live_p (16)\n-\t  && !df_regs_ever_live_p (17)\n-\t  && fp_regs_to_save () == 0\n-\t  && !frame_pointer_needed);\n+  return !mn10300_initial_offset (ARG_POINTER_REGNUM, STACK_POINTER_REGNUM);\n }\n \n /* Returns the set of live, callee-saved registers as a bitmask.  The\n@@ -760,11 +735,7 @@ mn10300_gen_multiple_store (unsigned int mask)\n void\n mn10300_expand_prologue (void)\n {\n-  HOST_WIDE_INT size;\n-\n-  /* SIZE includes the fixed stack space needed for function calls.  */\n-  size = get_frame_size () + crtl->outgoing_args_size;\n-  size += (crtl->outgoing_args_size ? 4 : 0);\n+  HOST_WIDE_INT size = mn10300_frame_size ();\n \n   /* If we use any of the callee-saved registers, save them now.  */\n   mn10300_gen_multiple_store (mn10300_get_live_callee_saved_regs ());\n@@ -1017,17 +988,13 @@ mn10300_expand_prologue (void)\n \t\t\t      GEN_INT (-size))));\n \n   if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n-    emit_insn (gen_GOTaddr2picreg ());\n+    emit_insn (gen_load_pic ());\n }\n \n void\n mn10300_expand_epilogue (void)\n {\n-  HOST_WIDE_INT size;\n-\n-  /* SIZE includes the fixed stack space needed for function calls.  */\n-  size = get_frame_size () + crtl->outgoing_args_size;\n-  size += (crtl->outgoing_args_size ? 4 : 0);\n+  HOST_WIDE_INT size = mn10300_frame_size ();\n   \n   if (TARGET_AM33_2 && fp_regs_to_save ())\n     {\n@@ -1441,55 +1408,38 @@ mn10300_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+int\n+mn10300_frame_size (void)\n+{\n+  /* size includes the fixed stack space needed for function calls.  */\n+  int size = get_frame_size () + crtl->outgoing_args_size;\n+\n+  /* And space for the return pointer.  */\n+  size += crtl->outgoing_args_size ? 4 : 0;\n+\n+  return size;\n+}\n+\n int\n mn10300_initial_offset (int from, int to)\n {\n+  int diff = 0;\n+\n+  gcc_assert (from == ARG_POINTER_REGNUM || from == FRAME_POINTER_REGNUM);\n+  gcc_assert (to == FRAME_POINTER_REGNUM || to == STACK_POINTER_REGNUM);\n+\n+  if (to == STACK_POINTER_REGNUM)\n+    diff = mn10300_frame_size ();\n+\n   /* The difference between the argument pointer and the frame pointer\n      is the size of the callee register save area.  */\n-  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+  if (from == ARG_POINTER_REGNUM)\n     {\n-      if (df_regs_ever_live_p (2) || df_regs_ever_live_p (3)\n-\t  || df_regs_ever_live_p (6) || df_regs_ever_live_p (7)\n-\t  || df_regs_ever_live_p (14) || df_regs_ever_live_p (15)\n-\t  || df_regs_ever_live_p (16) || df_regs_ever_live_p (17)\n-\t  || fp_regs_to_save ()\n-\t  || frame_pointer_needed)\n-\treturn REG_SAVE_BYTES\n-\t  + 4 * fp_regs_to_save ();\n-      else\n-\treturn 0;\n+      diff += REG_SAVE_BYTES;\n+      diff += 4 * fp_regs_to_save ();\n     }\n \n-  /* The difference between the argument pointer and the stack pointer is\n-     the sum of the size of this function's frame, the callee register save\n-     area, and the fixed stack space needed for function calls (if any).  */\n-  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    {\n-      if (df_regs_ever_live_p (2) || df_regs_ever_live_p (3)\n-\t  || df_regs_ever_live_p (6) || df_regs_ever_live_p (7)\n-\t  || df_regs_ever_live_p (14) || df_regs_ever_live_p (15)\n-\t  || df_regs_ever_live_p (16) || df_regs_ever_live_p (17)\n-\t  || fp_regs_to_save ()\n-\t  || frame_pointer_needed)\n-\treturn (get_frame_size () + REG_SAVE_BYTES\n-\t\t+ 4 * fp_regs_to_save ()\n-\t\t+ (crtl->outgoing_args_size\n-\t\t   ? crtl->outgoing_args_size + 4 : 0));\n-      else\n-\treturn (get_frame_size ()\n-\t\t+ (crtl->outgoing_args_size\n-\t\t   ? crtl->outgoing_args_size + 4 : 0));\n-    }\n-\n-  /* The difference between the frame pointer and stack pointer is the sum\n-     of the size of this function's frame and the fixed stack space needed\n-     for function calls (if any).  */\n-  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return (get_frame_size ()\n-\t    + (crtl->outgoing_args_size\n-\t       ? crtl->outgoing_args_size + 4 : 0));\n-\n-  gcc_unreachable ();\n+  return diff;\n }\n \n /* Worker function for TARGET_RETURN_IN_MEMORY.  */\n@@ -2087,7 +2037,6 @@ mn10300_legitimate_constant_p (rtx x)\n \t{\n \t  switch (XINT (x, 1))\n \t    {\n-\t    case UNSPEC_INT_LABEL:\n \t    case UNSPEC_PIC:\n \t    case UNSPEC_GOT:\n \t    case UNSPEC_GOTOFF:"}, {"sha": "b10f45068059a89084be8e0db6866301b1d550a5", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=040c57570147b0a05c29339dd778378b8cf15a56", "patch": "@@ -53,8 +53,6 @@\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-extern GTY(()) int mn10300_unspec_int_label_counter;\n-\n enum processor_type\n {\n   PROCESSOR_MN10300,"}, {"sha": "2477cb386af778979536ffd65a4431f4c0cf9c47", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 70, "deletions": 137, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040c57570147b0a05c29339dd778378b8cf15a56/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=040c57570147b0a05c29339dd778378b8cf15a56", "patch": "@@ -31,7 +31,6 @@\n   (MDR_REG  50)\n   (CC_REG   51)\n \n-  (UNSPEC_INT_LABEL\t0)\n   (UNSPEC_PIC\t\t1)\n   (UNSPEC_GOT\t\t2)\n   (UNSPEC_GOTOFF\t3)\n@@ -294,7 +293,6 @@\n \t(match_operand:SI     1 \"impossible_plus_operand\" \"\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=&A\"))]\n   \"\"\n-  \"\n {\n   rtx dest, scratch, other;\n \n@@ -336,16 +334,7 @@\n \temit_move_insn (dest, scratch);\n     }\n   DONE;\n-}\")\n-\n-(define_insn \"pop_pic_reg\"\n-  [(set (reg:SI PIC_REG)\n-\t(mem:SI (post_inc:SI (reg:SI SP_REG))))]\n-  \"reload_completed\"\n-  \"movm (sp),[a2]\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t       (const_int 44) (const_int 33)))]\n-)\n+})\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\")\n@@ -1141,13 +1130,10 @@\n (define_expand \"builtin_setjmp_receiver\"\n   [(match_operand 0 \"\" \"\")]\n   \"flag_pic\"\n-  \"\n {\n-  if (flag_pic)\n-    emit_insn (gen_GOTaddr2picreg ());\n-\n+  emit_insn (gen_load_pic ());\n   DONE;\n-}\")\n+})\n \n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"register_operand\")\n@@ -1612,16 +1598,14 @@\n (define_expand \"prologue\"\n   [(const_int 0)]\n   \"\"\n-  \"mn10300_expand_prologue (); DONE;\")\n+  { mn10300_expand_prologue (); DONE; }\n+)\n \n (define_expand \"epilogue\"\n   [(return)]\n   \"\"\n-  \"\n-  {\n-    mn10300_expand_epilogue ();\n-    DONE;\n-  }\")\n+  { mn10300_expand_epilogue (); DONE; }\n+)\n \n (define_insn \"return_internal\"\n   [(const_int 2)\n@@ -1638,13 +1622,12 @@\n    (match_operand:SI 0  \"const_int_operand\" \"i\")\n    (return)]\n   \"\"\n-  \"*\n-  {\n-    fputs (\\\"\\\\tret \\\", asm_out_file);\n-    mn10300_print_reg_list (asm_out_file, mn10300_get_live_callee_saved_regs ());\n-    fprintf (asm_out_file, \\\",%d\\\\n\\\", (int) INTVAL (operands[0]));\n-    return \\\"\\\";\n-  }\"\n+{\n+  fputs (\"\\tret \", asm_out_file);\n+  mn10300_print_reg_list (asm_out_file, mn10300_get_live_callee_saved_regs ());\n+  fprintf (asm_out_file, \",%d\\n\", (int) INTVAL (operands[0]));\n+  return \"\";\n+}\n   ;; Assumes that there will be no more than 8 regs to pop\n   [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n \t\t\t\t       (const_int 1414) (const_int 1313)))]\n@@ -1655,15 +1638,14 @@\n   [(match_parallel 0 \"mn10300_store_multiple_operation\"\n     [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (match_operand 1 \"\" \"\")))])]\n   \"\"\n-  \"*\n-  {\n-    fputs (\\\"\\\\tmovm \\\", asm_out_file);\n-    mn10300_print_reg_list (asm_out_file,\n-                            mn10300_store_multiple_operation (operands[0],\n-\t\t\t\t\t\t              VOIDmode));\n-    fprintf (asm_out_file, \\\",(sp)\\\\n\\\");\n-    return \\\"\\\";\n-  }\"\n+{\n+  fputs (\"\\tmovm \", asm_out_file);\n+  mn10300_print_reg_list (asm_out_file,\n+                          mn10300_store_multiple_operation (operands[0],\n+\t\t\t\t\t\t            VOIDmode));\n+  fprintf (asm_out_file, \",(sp)\\n\");\n+  return \"\";\n+}\n   ;; Assume that no more than 8 registers will be pushed.\n   [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n \t\t\t\t       (const_int 99) (const_int 88)))]\n@@ -1672,116 +1654,67 @@\n (define_insn \"return\"\n   [(return)]\n   \"mn10300_can_use_return_insn ()\"\n-  \"*\n-{\n-  rtx next = next_active_insn (insn);\n-\n-  if (next\n-      && JUMP_P (next)\n-      && GET_CODE (PATTERN (next)) == RETURN)\n-    return \\\"\\\";\n-  else\n-    return \\\"rets\\\";\n-}\"\n+  \"rets\"\n   [(set_attr \"timings\" \"66\")]\n )\n \n-(define_expand \"int_label\"\n-  [(unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_INT_LABEL)]\n-  \"\" \"\")\n-\n-(define_expand \"GOTaddr2picreg\"\n-  [(match_dup 0)]\n-  \"\" \"\n+(define_expand \"load_pic\"\n+  [(const_int 0)]\n+  \"flag_pic\"\n {\n-  /* It would be nice to be able to have int_label keep track of the\n-     counter and all, but if we add C code to it, we'll get an insn\n-     back, and we just want the pattern.  */\n-  operands[0] = gen_int_label (GEN_INT (mn10300_unspec_int_label_counter++));\n   if (TARGET_AM33)\n-    emit_insn (gen_am33_loadPC (operands[0]));\n+    emit_insn (gen_am33_load_pic (pic_offset_table_rtx));\n+  else if (mn10300_frame_size () == 0)\n+    emit_insn (gen_mn10300_load_pic0 (pic_offset_table_rtx));\n   else\n-    emit_insn (gen_mn10300_loadPC (operands[0]));\n-  emit_insn (gen_add_GOT_to_pic_reg (copy_rtx (operands[0])));\n+    emit_insn (gen_mn10300_load_pic1 (pic_offset_table_rtx));\n   DONE;\n-}\n-\")\n+})\n \n-(define_insn \"am33_loadPC\"\n-  [(parallel\n-    [(set (reg:SI PIC_REG) (pc))\n-     (use (match_operand 0 \"\" \"\"))])]\n+(define_insn \"am33_load_pic\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_GOT))\n+   (clobber (reg:CC CC_REG))]\n   \"TARGET_AM33\"\n-  \"%0:\\;mov pc,a2\"\n+{\n+  operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\n+  return \".LPIC%=:\\;mov pc,%0\\;add %1-(.LPIC%=-.),%0\";\n+}\n+  [(set_attr \"timings\" \"33\")]\n )\n \n-(define_insn_and_split \"mn10300_loadPC\"\n-  [(parallel\n-    [(set (reg:SI PIC_REG) (pc))\n-     (use (match_operand 0 \"\" \"\"))])]\n-  \"! TARGET_AM33\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(match_operand 0 \"\" \"\")]\n-  {\n-    rtx sp_reg = gen_rtx_REG (SImode, SP_REG);\n-    int need_stack_space = (get_frame_size () == 0\n-\t                    && crtl->outgoing_args_size == 0);\n-\n-    if (need_stack_space)\n-      emit_insn (gen_addsi3 (sp_reg, sp_reg, GEN_INT (-4)));\n-\n-    emit_insn (gen_call_next_insn (operands[0]));\n-\n-    if (need_stack_space)\n-      emit_insn (gen_pop_pic_reg ());\n-    else\n-      emit_move_insn (pic_offset_table_rtx, gen_rtx_MEM (SImode, sp_reg));\n-    DONE;\n-  }\n+;; Load pic register with push/pop of stack.\n+(define_insn \"mn10300_load_pic0\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_GOT))\n+   (clobber (reg:SI MDR_REG))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+{\n+  operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\n+  return (\"add -4,sp\\;\"\n+\t  \"calls .LPIC%=\\n\"\n+          \".LPIC%=:\\;\"\n+\t  \"movm (sp),[%0]\\;\"\n+\t  \"add %1-(.LPIC%=-.),%0\");\n+}\n+  [(set_attr \"timings\" \"88\")]\n )\n \n-(define_insn \"call_next_insn\"\n-  [(parallel\n-    [(set (mem:SI (reg:SI SP_REG)) (pc))\n-     (use (match_operand 0 \"\" \"\"))])]\n-  \"reload_completed\"\n-  \"calls %0\\;%0:\"\n-  [(set_attr \"timings\" \"44\")]\n-)\n-\n-(define_expand \"add_GOT_to_pic_reg\"\n-  [(parallel [(set (reg:SI PIC_REG)\n-\t\t   (plus:SI\n-\t\t    (reg:SI PIC_REG)\n-\t\t    (const:SI\n-\t\t     (unspec:SI [(minus:SI\n-\t\t\t       (match_dup 1)\n-\t\t\t       (const (minus:SI\n-\t\t\t\t       (const (match_operand:SI 0 \"\" \"\"))\n-\t\t\t\t       (pc))))\n-\t\t\t      ] UNSPEC_PIC))))\n-\t      (clobber (reg:CC CC_REG))\n-\t      ])\n-  ]\n-  \"\"\n-  \"operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\"\n-)\n-\n-(define_expand \"add_GOT_to_any_reg\"\n-  [(parallel [(set (match_operand:SI 0 \"\" \"\")\n-\t\t   (plus:SI\n-\t\t    (match_operand:SI 1 \"\" \"\")\n-\t\t    (const\n-\t\t     (unspec [(minus:SI\n-\t\t\t       (match_dup 3)\n-\t\t\t       (const (minus:SI\n-\t\t\t\t       (const (match_operand:SI 2 \"\" \"\"))\n-\t\t\t\t       (pc))))\n-\t\t\t      ] UNSPEC_PIC))))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n+;; Load pic register re-using existing stack space.\n+(define_insn \"mn10300_load_pic1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_GOT))\n+   (clobber (mem:SI (reg:SI SP_REG)))\n+   (clobber (reg:SI MDR_REG))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"operands[3] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\"\n+{\n+  operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\n+  return (\"calls .LPIC%=\\n\"\n+\t  \".LPIC%=:\\;\"\n+          \"mov (sp),%0\\;\"\n+          \"add %1-(.LPIC%=-.),%0\");\n+}\n+  [(set_attr \"timings\" \"66\")]\n )"}]}