{"sha": "0a59abbfc74c3961fb01323d9fbff8427518fde6", "node_id": "C_kwDOANBUbNoAKDBhNTlhYmJmYzc0YzM5NjFmYjAxMzIzZDlmYmZmODQyNzUxOGZkZTY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-11-04T13:22:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-04T13:22:10Z"}, "message": "Merge #1627\n\n1627: Merge GCC mainline/master into gccrs/master r=CohenArthur a=ibuclaw\n\n`@doko42` was asking, so here's another merge sync.\n\nCo-authored-by: GCC Administrator <gccadmin@gcc.gnu.org>\nCo-authored-by: Andrew MacLeod <amacleod@redhat.com>\nCo-authored-by: Liwei Xu <liwei.xu@intel.com>\nCo-authored-by: Richard Biener <rguenther@suse.de>\nCo-authored-by: Jakub Jelinek <jakub@redhat.com>\nCo-authored-by: Andre Vieira <andre.simoesdiasvieira@arm.com>\nCo-authored-by: Jonathan Wakely <jwakely@redhat.com>\nCo-authored-by: Martin Jambor <mjambor@suse.cz>\nCo-authored-by: Joseph Myers <joseph@codesourcery.com>\nCo-authored-by: Patrick Palka <ppalka@redhat.com>\nCo-authored-by: Florian Weimer <fweimer@redhat.com>\nCo-authored-by: Marek Polacek <polacek@redhat.com>\nCo-authored-by: liuhongt <hongtao.liu@intel.com>\nCo-authored-by: Martin Liska <mliska@suse.cz>\nCo-authored-by: Robin Dapp <rdapp@linux.ibm.com>\nCo-authored-by: Takayuki 'January June' Suwa <jjsuwa_sys3175@yahoo.co.jp>\nCo-authored-by: Stefan Schulze Frielinghaus <stefansf@linux.ibm.com>", "tree": {"sha": "b17389116bc4da1d022345b7b78eb6fc0fbe4eb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b17389116bc4da1d022345b7b78eb6fc0fbe4eb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a59abbfc74c3961fb01323d9fbff8427518fde6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjZRICCRBK7hj4Ov3rIwAAc6cIAKirgP4en81dfRcYGKwcfkQ7\nLnNIzXOS0n1y1WzajiDTkPFaDnJIBMG92Idc7iUdKMBffVnCgnf9ECppXoOSPIve\n9/ynREpXbaOhAJ5RhLG93+QUTOot5egpAEm6LHSxcPeXWvcYqxrHqRAQBmFG+Pyx\nZUCku3eU9D50ySrqyHvXwnRLf6xusaaCUWwUYmP3LYz/ZgQ6gEORpkRwDlidjC/y\ntG/MALkic9Sv5bpcLeKhCYQRIeV3/Rq0zJtb+bEGa02CihvogBll5cOnrKLIn1hG\n0aTw8PwtTf4IvDsbhdTmKgC0UKTJmYvsLZlp+NzxhTEayeRrhSsZ4KjCZiNQoyo=\n=tTcQ\n-----END PGP SIGNATURE-----\n", "payload": "tree b17389116bc4da1d022345b7b78eb6fc0fbe4eb0\nparent f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f\nparent a7b70c704182db2defd0c0f991c16f4d9219bc2f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1667568130 +0000\ncommitter GitHub <noreply@github.com> 1667568130 +0000\n\nMerge #1627\n\n1627: Merge GCC mainline/master into gccrs/master r=CohenArthur a=ibuclaw\n\n`@doko42` was asking, so here's another merge sync.\n\nCo-authored-by: GCC Administrator <gccadmin@gcc.gnu.org>\nCo-authored-by: Andrew MacLeod <amacleod@redhat.com>\nCo-authored-by: Liwei Xu <liwei.xu@intel.com>\nCo-authored-by: Richard Biener <rguenther@suse.de>\nCo-authored-by: Jakub Jelinek <jakub@redhat.com>\nCo-authored-by: Andre Vieira <andre.simoesdiasvieira@arm.com>\nCo-authored-by: Jonathan Wakely <jwakely@redhat.com>\nCo-authored-by: Martin Jambor <mjambor@suse.cz>\nCo-authored-by: Joseph Myers <joseph@codesourcery.com>\nCo-authored-by: Patrick Palka <ppalka@redhat.com>\nCo-authored-by: Florian Weimer <fweimer@redhat.com>\nCo-authored-by: Marek Polacek <polacek@redhat.com>\nCo-authored-by: liuhongt <hongtao.liu@intel.com>\nCo-authored-by: Martin Liska <mliska@suse.cz>\nCo-authored-by: Robin Dapp <rdapp@linux.ibm.com>\nCo-authored-by: Takayuki 'January June' Suwa <jjsuwa_sys3175@yahoo.co.jp>\nCo-authored-by: Stefan Schulze Frielinghaus <stefansf@linux.ibm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a59abbfc74c3961fb01323d9fbff8427518fde6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a59abbfc74c3961fb01323d9fbff8427518fde6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a59abbfc74c3961fb01323d9fbff8427518fde6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f"}, {"sha": "a7b70c704182db2defd0c0f991c16f4d9219bc2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b70c704182db2defd0c0f991c16f4d9219bc2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7b70c704182db2defd0c0f991c16f4d9219bc2f"}], "stats": {"total": 95558, "additions": 79468, "deletions": 16090}, "files": [{"sha": "381e1ce9e4bbe4c26778552b4fa5671c334704a3", "filename": ".github/bors_log_expected_warnings", "status": "modified", "additions": 84, "deletions": 75, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/.github%2Fbors_log_expected_warnings", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/.github%2Fbors_log_expected_warnings", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fbors_log_expected_warnings?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,7 +1,7 @@\n ../../../../libffi/src/x86/ffi.c:612:1: warning: label \u2018out\u2019 defined but not used [-Wunused-label]\n-../../../libcpp/expr.cc:807:18: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../../libcpp/expr.cc:810:39: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../../libcpp/expr.cc:820:34: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../../libcpp/expr.cc:822:18: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../../libcpp/expr.cc:825:39: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../../libcpp/expr.cc:835:34: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../../libcpp/macro.cc:186:23: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../../libcpp/macro.cc:215:24: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../../libcpp/macro.cc:3704:58: warning: format not a string literal and no format arguments [-Wformat-security]\n@@ -12,84 +12,93 @@\n ../../../libffi/src/java_raw_api.c:369:3: warning: \u2018ffi_prep_java_raw_closure_loc\u2019 is deprecated [-Wdeprecated-declarations]\n ../../../libffi/src/x86/ffi64.c:783:1: warning: label \u2018out\u2019 defined but not used [-Wunused-label]\n ../../../libffi/src/x86/ffiw64.c:250:1: warning: label \u2018out\u2019 defined but not used [-Wunused-label]\n-../../gcc/analyzer/diagnostic-manager.cc:784:20: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/diagnostic-manager.cc:784:28: warning: unknown conversion type character \u2018E\u2019 in format [-Wformat=]\n-../../gcc/analyzer/engine.cc:1652:3: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/engine.cc:1652:60: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/program-state.cc:1310:20: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/analyzer/sm-fd.cc:381:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-fd.cc:381:63: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-fd.cc:384:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-fd.cc:384:59: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-fd.cc:522:34: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-fd.cc:522:70: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-fd.cc:591:54: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-fd.cc:591:6: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-fd.cc:659:49: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-fd.cc:659:4: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-file.cc:203:34: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-file.cc:203:70: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/call-summary.cc:112:20: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/call-summary.cc:112:28: warning: unknown conversion type character \u2018E\u2019 in format [-Wformat=]\n+../../gcc/analyzer/call-summary.cc:114:20: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/call-summary.cc:114:28: warning: unknown conversion type character \u2018E\u2019 in format [-Wformat=]\n+../../gcc/analyzer/call-summary.cc:114:40: warning: unknown conversion type character \u2018E\u2019 in format [-Wformat=]\n+../../gcc/analyzer/call-summary.cc:122:18: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/call-summary.cc:122:26: warning: unknown conversion type character \u2018E\u2019 in format [-Wformat=]\n+../../gcc/analyzer/call-summary.cc:98:11: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/call-summary.cc:98:19: warning: unknown conversion type character \u2018E\u2019 in format [-Wformat=]\n+../../gcc/analyzer/diagnostic-manager.cc:777:20: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/diagnostic-manager.cc:777:28: warning: unknown conversion type character \u2018E\u2019 in format [-Wformat=]\n+../../gcc/analyzer/engine.cc:1788:3: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/engine.cc:1788:60: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/program-state.cc:1330:20: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/analyzer/sm-fd.cc:388:31: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-fd.cc:388:63: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-fd.cc:391:31: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-fd.cc:391:59: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-fd.cc:529:34: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-fd.cc:529:70: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-fd.cc:598:54: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-fd.cc:598:6: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-fd.cc:666:49: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-fd.cc:666:4: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-file.cc:200:34: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-file.cc:200:70: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-file.cc:255:31: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-file.cc:255:63: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n ../../gcc/analyzer/sm-file.cc:258:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-file.cc:258:63: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-file.cc:261:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-file.cc:261:59: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:1066:36: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:1066:61: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:1249:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:1249:67: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:1252:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:1252:69: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:1255:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:1256:28: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:1331:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:1331:66: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:1339:31: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:1339:66: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:825:7: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:826:24: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:826:54: warning: format \u2018%s\u2019 expects argument of type \u2018char*\u2019, but argument 4 has type \u2018diagnostic_event_id_t*\u2019 [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:831:7: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:832:23: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:894:34: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:894:70: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-malloc.cc:969:34: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-malloc.cc:969:76: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/sm-sensitive.cc:151:34: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/sm-sensitive.cc:152:22: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/varargs.cc:434:33: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/varargs.cc:434:7: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/varargs.cc:445:26: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/varargs.cc:445:7: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/varargs.cc:509:52: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/varargs.cc:509:7: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/analyzer/varargs.cc:520:45: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n-../../gcc/analyzer/varargs.cc:520:7: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/c-family/c-common.cc:6623:30: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/c-family/c-common.cc:6627:33: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/analyzer/sm-file.cc:258:59: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:1062:36: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:1062:61: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:1245:31: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:1245:67: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:1248:31: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:1248:69: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:1251:31: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:1252:28: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:1327:31: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:1327:66: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:1335:31: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:1335:66: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:821:7: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:822:24: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:822:54: warning: format \u2018%s\u2019 expects argument of type \u2018char*\u2019, but argument 4 has type \u2018diagnostic_event_id_t*\u2019 [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:827:7: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:828:23: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:890:34: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:890:70: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-malloc.cc:965:34: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-malloc.cc:965:76: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/sm-sensitive.cc:148:34: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/sm-sensitive.cc:149:22: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/varargs.cc:429:33: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/varargs.cc:429:7: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/varargs.cc:440:26: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/varargs.cc:440:7: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/varargs.cc:504:52: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/varargs.cc:504:7: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/analyzer/varargs.cc:515:45: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n+../../gcc/analyzer/varargs.cc:515:7: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/c-family/c-common.cc:6595:30: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/c-family/c-common.cc:6599:33: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/c/c-convert.cc:84:31: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/c/c-typeck.cc:11921:42: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/c/c-typeck.cc:3713:28: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/c/c-typeck.cc:4483:42: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/c/c-typeck.cc:6662:43: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/c/c-typeck.cc:11946:42: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/c/c-typeck.cc:3730:28: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/c/c-typeck.cc:4500:42: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/c/c-typeck.cc:6687:43: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/collect-utils.cc:237:37: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/collect2.cc:2397:37: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/config/i386/i386.cc:21689:32: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/config/i386/i386.cc:21689:32: warning: unknown conversion type character \u2018{\u2019 in format [-Wformat=]\n-../../gcc/config/i386/i386.cc:21689:32: warning: unknown conversion type character \u2018}\u2019 in format [-Wformat=]\n-../../gcc/config/i386/i386.cc:2565:8: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/config/i386/i386.cc:2565:8: warning: unknown conversion type character \u2018{\u2019 in format [-Wformat=]\n-../../gcc/config/i386/i386.cc:2565:8: warning: unknown conversion type character \u2018}\u2019 in format [-Wformat=]\n+../../gcc/config/i386/i386.cc:21697:32: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/config/i386/i386.cc:21697:32: warning: unknown conversion type character \u2018{\u2019 in format [-Wformat=]\n+../../gcc/config/i386/i386.cc:21697:32: warning: unknown conversion type character \u2018}\u2019 in format [-Wformat=]\n+../../gcc/config/i386/i386.cc:2568:8: warning: too many arguments for format [-Wformat-extra-args]\n+../../gcc/config/i386/i386.cc:2568:8: warning: unknown conversion type character \u2018{\u2019 in format [-Wformat=]\n+../../gcc/config/i386/i386.cc:2568:8: warning: unknown conversion type character \u2018}\u2019 in format [-Wformat=]\n ../../gcc/diagnostic.cc:2206:52: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/fold-const.cc:314:42: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/fold-const.cc:313:42: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/gimple-range-gori.cc:318:22: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/ipa-devirt.cc:965:47: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/lto-wrapper.cc:1365:52: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/lto-wrapper.cc:1957:44: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/omp-low.cc:10632:19: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n-../../gcc/omp-low.cc:1547:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n-../../gcc/omp-low.cc:1552:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n-../../gcc/omp-oacc-kernels-decompose.cc:1500:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n-../../gcc/omp-oacc-kernels-decompose.cc:870:22: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n+../../gcc/omp-low.cc:10633:19: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n+../../gcc/omp-low.cc:1548:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n+../../gcc/omp-low.cc:1553:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n+../../gcc/omp-oacc-kernels-decompose.cc:1501:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n+../../gcc/omp-oacc-kernels-decompose.cc:871:22: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n ../../gcc/omp-offload.cc:2242:22: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n ../../gcc/omp-offload.cc:2280:22: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n ../../gcc/tree-diagnostic-path.cc:176:21: warning: too many arguments for format [-Wformat-extra-args]\n@@ -111,9 +120,9 @@\n ../../gcc/tree-diagnostic-path.cc:68:23: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n ../../gcc/tree-diagnostic-path.cc:68:26: warning: format \u2018%s\u2019 expects argument of type \u2018char*\u2019, but argument 3 has type \u2018diagnostic_event_id_t*\u2019 [-Wformat=]\n ../../gcc/tree-ssa-sccvn.cc:280:67: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../libcpp/expr.cc:807:18: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../libcpp/expr.cc:810:39: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../libcpp/expr.cc:820:34: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../libcpp/expr.cc:822:18: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../libcpp/expr.cc:825:39: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../libcpp/expr.cc:835:34: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../libcpp/macro.cc:186:23: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../libcpp/macro.cc:215:24: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../libcpp/macro.cc:3704:58: warning: format not a string literal and no format arguments [-Wformat-security]"}, {"sha": "f99789e016dac7bed638a797c7f2f27a04a84eac", "filename": "ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,3 +1,30 @@\n+2022-10-31  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\t* MAINTAINERS: Update email address.\n+\n+2022-10-21  \u0414\u0438\u043b\u044f\u043d \u041f\u0430\u043b\u0430\u0443\u0437\u043e\u0432  <dilyan.palauzov@aegee.org>\n+\n+\t* configure.ac: Don't configure readline if --with-system-readline is\n+\tused.\n+\t* configure: Re-generate.\n+\n+2022-10-12  Cui,Lili  <lili.cui@intel.com>\n+\n+\t* MAINTAINERS (Write After Approval): Add myself.\n+\n+2022-10-11  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* libtool.m4 (*vxworks*): When enable_shared, set dynamic_linker\n+\tand friends for rtp !large. Assume the linker has the required\n+\tabilities and set lt_cv_deplibs_check_method.\n+\n+2022-09-30  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* configure.ac (*vxworks*): If enable_shared is not\n+\tset, set to \"no\" and add --disable-shared to target and\n+\thost_configargs.\n+\t* configure: Regenerate.\n+\n 2022-09-26  Jeff Law  <jlaw@ventanamicro.com>\n \n \t* MAINTAINERS: Update my email address and DCO entry."}, {"sha": "55c5ef958068b01c114bbdcac25e7166ebd31126", "filename": "MAINTAINERS", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -60,7 +60,7 @@ arc port\t\tJoern Rennecke\t\t<gnu@amylaar.uk>\n arc port\t\tClaudiu Zissulescu\t<claziss@synopsys.com>\n arm port\t\tNick Clifton\t\t<nickc@redhat.com>\n arm port\t\tRichard Earnshaw\t<richard.earnshaw@arm.com>\n-arm port\t\tRamana Radhakrishnan\t<ramana.radhakrishnan@arm.com>\n+arm port\t\tRamana Radhakrishnan\t<ramana.gcc@gmail.com>\n arm port\t\tKyrylo Tkachov\t\t<kyrylo.tkachov@arm.com>\n avr port\t\tDenis Chertykov\t\t<chertykov@gmail.com>\n bfin port\t\tJie Zhang\t\t<jzhang918@gmail.com>\n@@ -377,6 +377,7 @@ Andrea Corallo\t\t\t\t\t<andrea.corallo@arm.com>\n Christian Cornelssen\t\t\t\t<ccorn@cs.tu-berlin.de>\n Ludovic Court\u00e8s\t\t\t\t\t<ludo@gnu.org>\n Lawrence Crowl\t\t\t\t\t<crowl@google.com>\n+Lili Cui\t\t\t\t\t<lili.cui@intel.com>\n Ian Dall\t\t\t\t\t<ian@beware.dropbear.id.au>\n David Daney\t\t\t\t\t<david.daney@caviumnetworks.com>\n Robin Dapp\t\t\t\t\t<rdapp@linux.ibm.com>"}, {"sha": "5e54dd42eeb8a2fc2d3555e5da1b68a27d616d4a", "filename": "config/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,3 +1,8 @@\n+2022-10-19  LIU Hao  <lh_mouse@126.com>\n+\n+\t* gthr.m4 (GCC_AC_THREAD_HEADER): Add new case for `mcf` thread\n+\tmodel\n+\n 2022-08-31  Martin Liska  <mliska@suse.cz>\n \n \t* mh-pa-hpux10: Removed."}, {"sha": "11996247f150f99a9eb6720b33f8f72bacb8bf8c", "filename": "config/gthr.m4", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/config%2Fgthr.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/config%2Fgthr.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fgthr.m4?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -22,6 +22,7 @@ case $1 in\n     tpf)\tthread_header=config/s390/gthr-tpf.h ;;\n     vxworks)\tthread_header=config/gthr-vxworks.h ;;\n     win32)\tthread_header=config/i386/gthr-win32.h ;;\n+    mcf)\tthread_header=config/i386/gthr-mcf.h ;;\n esac\n AC_SUBST(thread_header)\n ])"}, {"sha": "007a77a5f6c9988832c38a6792e196493d635a17", "filename": "configure", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2946,6 +2946,12 @@ if test x$with_system_zlib = xyes ; then\n   noconfigdirs=\"$noconfigdirs zlib\"\n fi\n \n+# Don't compile the bundled readline/libreadline.a if --with-system-readline\n+# is provided.\n+if test x$with_system_readline = xyes ; then\n+  noconfigdirs=\"$noconfigdirs readline\"\n+fi\n+\n # some tools are so dependent upon X11 that if we're not building with X,\n # it's not even worth trying to configure, much less build, that tool.\n \n@@ -10263,6 +10269,17 @@ case \"${target}\" in\n   mep*)\n     FLAGS_FOR_TARGET=\"$FLAGS_FOR_TARGET -mlibrary\"\n     ;;\n+  # The VxWorks support for shared libraries is getting in\n+  # incrementally.  Make sure it doesn't get activated implicitly:\n+  *vxworks*)\n+    if test \"${enable_shared-unset}\" = unset ; then\n+      enable_shared=no\n+      # So the build of libraries knows ...\n+      target_configargs=\"${target_configargs} --disable-shared\"\n+      # So gcc knows ...\n+      host_configargs=\"${host_configargs} --disable-shared\"\n+    fi\n+    ;;\n esac\n \n # Makefile fragments."}, {"sha": "1df410bba1f822701b87929e82c3826897874ebb", "filename": "configure.ac", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -247,6 +247,12 @@ if test x$with_system_zlib = xyes ; then\n   noconfigdirs=\"$noconfigdirs zlib\"\n fi\n \n+# Don't compile the bundled readline/libreadline.a if --with-system-readline\n+# is provided.\n+if test x$with_system_readline = xyes ; then\n+  noconfigdirs=\"$noconfigdirs readline\"\n+fi\n+\n # some tools are so dependent upon X11 that if we're not building with X, \n # it's not even worth trying to configure, much less build, that tool.\n \n@@ -3440,6 +3446,17 @@ case \"${target}\" in\n   mep*)\n     FLAGS_FOR_TARGET=\"$FLAGS_FOR_TARGET -mlibrary\"\n     ;;\n+  # The VxWorks support for shared libraries is getting in\n+  # incrementally.  Make sure it doesn't get activated implicitly:\n+  *vxworks*)\n+    if test \"${enable_shared-unset}\" = unset ; then\n+      enable_shared=no\n+      # So the build of libraries knows ...\n+      target_configargs=\"${target_configargs} --disable-shared\"\n+      # So gcc knows ...\n+      host_configargs=\"${host_configargs} --disable-shared\"\n+    fi\n+    ;;\n esac\n \n # Makefile fragments."}, {"sha": "0b65ec43dfc715577128e4b771cf104389454fd5", "filename": "contrib/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,3 +1,21 @@\n+2022-10-20  Jonathan Wakely   <jwakely@redhat.com>\n+\t    Ulrich Drepper  <drepper@redhat.com>\n+\n+\t* gcc_update: Add rule for gcc/cp/std-name-hint.gperf.\n+\n+2022-10-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/git_update_version.py: Remove extra fetch.\n+\n+2022-10-06  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/git_update_version.py: Use logging module\n+\tand provide robust debugging output.\n+\n+2022-10-05  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/git_update_version.py: Do fetch before a push.\n+\n 2022-09-20  Martin Liska  <mliska@suse.cz>\n \n \t* filter-clang-warnings.py: Skip egrep: warning: egrep is"}, {"sha": "074e717d6105fc610a6864f80626007e530c1f01", "filename": "contrib/gcc-changelog/git_update_version.py", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/contrib%2Fgcc-changelog%2Fgit_update_version.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/contrib%2Fgcc-changelog%2Fgit_update_version.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_update_version.py?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -18,6 +18,7 @@\n \n import argparse\n import datetime\n+import logging\n import os\n \n from git import Repo\n@@ -34,6 +35,13 @@\n         '3ab5c8cd03d92bf4ec41e351820349d92fbc40c4',\n         '86d8e0c0652ef5236a460b75c25e4f7093cc0651')\n \n+FORMAT = '%(asctime)s:%(levelname)s:%(name)s:%(message)s'\n+logging.basicConfig(level=logging.INFO, format=FORMAT,\n+                    handlers=[\n+                        logging.FileHandler('/tmp/git_update_version.txt'),\n+                        logging.StreamHandler()\n+                    ])\n+\n \n def read_timestamp(path):\n     with open(path) as f:\n@@ -43,11 +51,11 @@ def read_timestamp(path):\n def prepend_to_changelog_files(repo, folder, git_commit, add_to_git):\n     if not git_commit.success:\n         for error in git_commit.errors:\n-            print(error)\n+            logging.info(error)\n         raise AssertionError()\n     for entry, output in git_commit.to_changelog_entries(use_commit_ts=True):\n         full_path = os.path.join(folder, entry, 'ChangeLog')\n-        print('writing to %s' % full_path)\n+        logging.info('writing to %s' % full_path)\n         if os.path.exists(full_path):\n             with open(full_path) as f:\n                 content = f.read()\n@@ -95,7 +103,7 @@ def update_current_branch(ref_name):\n         commit = commit.parents[-1]\n         commit_count += 1\n \n-    print('%d revisions since last Daily bump' % commit_count)\n+    logging.info('%d revisions since last Daily bump' % commit_count)\n     datestamp_path = os.path.join(args.git_path, 'gcc/DATESTAMP')\n     if (read_timestamp(datestamp_path) != current_timestamp\n             or args.dry_mode or args.current):\n@@ -117,25 +125,29 @@ def update_current_branch(ref_name):\n                                  branch.name.split('/')[-1] + '.patch')\n             with open(patch, 'w+') as f:\n                 f.write(diff)\n-            print('branch diff written to %s' % patch)\n+            logging.info('branch diff written to %s' % patch)\n             repo.git.checkout(force=True)\n         else:\n             # update timestamp\n-            print('DATESTAMP will be changed:')\n+            logging.info('DATESTAMP will be changed:')\n             with open(datestamp_path, 'w+') as f:\n                 f.write(current_timestamp)\n             repo.git.add(datestamp_path)\n             if not args.current:\n                 repo.index.commit('Daily bump.')\n+                logging.info('commit is done')\n                 if args.push:\n-                    repo.git.push('origin', branch)\n-                    print('branch is pushed')\n+                    try:\n+                        repo.git.push('origin', branch)\n+                        logging.info('branch is pushed')\n+                    except Exception:\n+                        logging.exception('git push failed')\n     else:\n-        print('DATESTAMP unchanged')\n+        logging.info('DATESTAMP unchanged')\n \n \n if args.current:\n-    print('=== Working on the current branch ===', flush=True)\n+    logging.info('=== Working on the current branch ===')\n     update_current_branch()\n else:\n     for ref in origin.refs:\n@@ -146,10 +158,11 @@ def update_current_branch(ref_name):\n                 branch = repo.branches[name]\n             else:\n                 branch = repo.create_head(name, ref).set_tracking_branch(ref)\n-            print('=== Working on: %s ===' % branch, flush=True)\n+            logging.info('=== Working on: %s ===' % branch)\n             branch.checkout()\n             origin.pull(rebase=True)\n-            print('branch pulled and checked out')\n+            logging.info('branch pulled and checked out')\n             update_current_branch(name)\n             assert not repo.index.diff(None)\n-            print('branch is done\\n', flush=True)\n+            logging.info('branch is done')\n+            logging.info('')"}, {"sha": "18c7ec46264c9bf9bc28bdc6964f2b5f2e9f85d4", "filename": "contrib/gcc_update", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -95,6 +95,7 @@ gcc/config/rs6000/fusion.md: gcc/config/rs6000/genfusion.pl\n # And then, language-specific files\n gcc/cp/cfns.h: gcc/cp/cfns.gperf\n gcc/cp/std-name-hint.h: gcc/cp/std-name-hint.gperf\n+gcc/cp/std-name-hint.gperf: gcc/cp/cxxapi-data.csv\n # testsuite\n # Without this, _Pragma3.c can have a false negative.\n gcc/testsuite/gcc.dg/cpp/_Pragma3.c: gcc/testsuite/gcc.dg/cpp/mi1c.h"}, {"sha": "c3c398d5a591332334daae92507fe64d47bfc012", "filename": "fixincludes/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/fixincludes%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/fixincludes%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2FChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,3 +1,34 @@\n+2022-10-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/107059\n+\t* inclhack.def (glibc_cxx_floatn_5): New.\n+\t* fixincl.x: Regenerated.\n+\t* tests/base/bits/floatn.h: Regenerated.\n+\n+2022-10-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/107059\n+\t* inclhack.def (glibc_cxx_floatn_2): Handle #elif the same as #if.\n+\t(glibc_cxx_floatn_4): New.\n+\t* fixincl.x: Regenerated.\n+\t* tests/base/bits/floatn.h: Regenerated.\n+\n+2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* inclhack.def (glibc_cxx_floatn_1, glibc_cxx_floatn_2,\n+\tglibc_cxx_floatn_3): Add to files also \"*/bits/floatn.h\"\n+\tand \"*/bits/floatn-common.h\".\n+\t* fixincl.x: Regenerated.\n+\n+2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/106652\n+\tPR c++/85518\n+\t* inclhack.def (glibc_cxx_floatn_1, glibc_cxx_floatn_2,\n+\tglibc_cxx_floatn_3): New fixes.\n+\t* tests/base/bits/floatn.h: New file.\n+\t* fixincl.x: Regenerated.\n+\n 2022-08-31  Martin Liska  <mliska@suse.cz>\n \n \t* configure: Regenerate."}, {"sha": "20867548e246c7ed97ea895e1df59fa8c0a9bedf", "filename": "fixincludes/fixincl.x", "status": "modified", "additions": 96, "deletions": 7, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/fixincludes%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/fixincludes%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ffixincl.x?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2,11 +2,11 @@\n  *\n  * DO NOT EDIT THIS FILE   (fixincl.x)\n  *\n- * It has been AutoGen-ed  September 27, 2022 at 12:21:44 PM by AutoGen 5.18.16\n+ * It has been AutoGen-ed  September 29, 2022 at 10:22:55 PM by AutoGen 5.18.16\n  * From the definitions    inclhack.def\n  * and the template file   fixincl\n  */\n-/* DO NOT SVN-MERGE THIS FILE, EITHER Tue Sep 27 12:21:44 CEST 2022\n+/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Sep 29 22:22:55 CEST 2022\n  *\n  * You must regenerate it.  Use the ./genfixes script.\n  *\n@@ -15,7 +15,7 @@\n  * certain ANSI-incompatible system header files which are fixed to work\n  * correctly with ANSI C and placed in a directory that GNU C will search.\n  *\n- * This file contains 270 fixup descriptions.\n+ * This file contains 272 fixup descriptions.\n  *\n  * See README for more information.\n  *\n@@ -4167,7 +4167,7 @@ tSCC zGlibc_Cxx_Floatn_2List[] =\n  *  content selection pattern - do fix if pattern found\n  */\n tSCC zGlibc_Cxx_Floatn_2Select0[] =\n-       \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n+       \"^([ \\t]*#[ \\t]*(el)?if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n (([ \\t]*/\\\\*[^\\n\\\n ]*\\\\*/\\n\\\n )?[ \\t]*typedef[ \\t]+[^\\n\\\n@@ -4183,7 +4183,7 @@ static tTestDesc aGlibc_Cxx_Floatn_2Tests[] = {\n static const char* apzGlibc_Cxx_Floatn_2Patch[] = {\n     \"format\",\n     \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n\\\n-%2\",\n+%3\",\n     (char*)NULL };\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n@@ -4231,6 +4231,83 @@ static const char* apzGlibc_Cxx_Floatn_3Patch[] = {\n %2\",\n     (char*)NULL };\n \n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Cxx_Floatn_4 fix\n+ */\n+tSCC zGlibc_Cxx_Floatn_4Name[] =\n+     \"glibc_cxx_floatn_4\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_Cxx_Floatn_4List[] =\n+  \"bits/floatn.h\\0*/bits/floatn.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_Cxx_Floatn_4Machs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_Cxx_Floatn_4Select0[] =\n+       \"^([ \\t]*#[ \\t]*if __LDBL_MANT_DIG__ == 113 && )defined __cplusplus\\n\\\n+(([ \\t]*/\\\\*[^\\n\\\n+]*\\\\*/\\n\\\n+)?[ \\t]*typedef[ \\t]+[^\\n\\\n+]*[ \\t]+_Float128;)\";\n+\n+#define    GLIBC_CXX_FLOATN_4_TEST_CT  1\n+static tTestDesc aGlibc_Cxx_Floatn_4Tests[] = {\n+  { TT_EGREP,    zGlibc_Cxx_Floatn_4Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Cxx_Floatn_4\n+ */\n+static const char* apzGlibc_Cxx_Floatn_4Patch[] = {\n+    \"format\",\n+    \"%1defined __cplusplus && !__GNUC_PREREQ (13, 0)\\n\\\n+%2\",\n+    (char*)NULL };\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Cxx_Floatn_5 fix\n+ */\n+tSCC zGlibc_Cxx_Floatn_5Name[] =\n+     \"glibc_cxx_floatn_5\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_Cxx_Floatn_5List[] =\n+  \"bits/floatn.h\\0bits/floatn-common.h\\0*/bits/floatn.h\\0*/bits/floatn-common.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_Cxx_Floatn_5Machs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_Cxx_Floatn_5Select0[] =\n+       \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n+([ \\t]*#[ \\t]+error \\\"_Float128[xX] supported but no )\";\n+\n+#define    GLIBC_CXX_FLOATN_5_TEST_CT  1\n+static tTestDesc aGlibc_Cxx_Floatn_5Tests[] = {\n+  { TT_EGREP,    zGlibc_Cxx_Floatn_5Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Cxx_Floatn_5\n+ */\n+static const char* apzGlibc_Cxx_Floatn_5Patch[] = {\n+    \"format\",\n+    \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n\\\n+%2\",\n+    (char*)NULL };\n+\n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n  *  Description of Glibc_Mutex_Init fix\n@@ -10998,9 +11075,9 @@ static const char* apzX11_SprintfPatch[] = {\n  *\n  *  List of all fixes\n  */\n-#define REGEX_COUNT          308\n+#define REGEX_COUNT          310\n #define MACH_LIST_SIZE_LIMIT 187\n-#define FIX_COUNT            270\n+#define FIX_COUNT            272\n \n /*\n  *  Enumerate the fixes\n@@ -11106,6 +11183,8 @@ typedef enum {\n     GLIBC_CXX_FLOATN_1_FIXIDX,\n     GLIBC_CXX_FLOATN_2_FIXIDX,\n     GLIBC_CXX_FLOATN_3_FIXIDX,\n+    GLIBC_CXX_FLOATN_4_FIXIDX,\n+    GLIBC_CXX_FLOATN_5_FIXIDX,\n     GLIBC_MUTEX_INIT_FIXIDX,\n     GLIBC_STDINT_FIXIDX,\n     GLIBC_STRNCPY_FIXIDX,\n@@ -11779,6 +11858,16 @@ tFixDesc fixDescList[ FIX_COUNT ] = {\n      GLIBC_CXX_FLOATN_3_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n      aGlibc_Cxx_Floatn_3Tests,   apzGlibc_Cxx_Floatn_3Patch, 0 },\n \n+  {  zGlibc_Cxx_Floatn_4Name,    zGlibc_Cxx_Floatn_4List,\n+     apzGlibc_Cxx_Floatn_4Machs,\n+     GLIBC_CXX_FLOATN_4_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_Cxx_Floatn_4Tests,   apzGlibc_Cxx_Floatn_4Patch, 0 },\n+\n+  {  zGlibc_Cxx_Floatn_5Name,    zGlibc_Cxx_Floatn_5List,\n+     apzGlibc_Cxx_Floatn_5Machs,\n+     GLIBC_CXX_FLOATN_5_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_Cxx_Floatn_5Tests,   apzGlibc_Cxx_Floatn_5Patch, 0 },\n+\n   {  zGlibc_Mutex_InitName,    zGlibc_Mutex_InitList,\n      apzGlibc_Mutex_InitMachs,\n      GLIBC_MUTEX_INIT_TEST_CT, FD_MACH_ONLY,"}, {"sha": "d4637470d7a79897a820a69f11c5e47597f8fe9c", "filename": "fixincludes/inclhack.def", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/fixincludes%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/fixincludes%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Finclhack.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2060,18 +2060,22 @@ fix = {\n fix = {\n     hackname  = glibc_cxx_floatn_2;\n     files     = bits/floatn.h, bits/floatn-common.h, \"*/bits/floatn.h\", \"*/bits/floatn-common.h\";\n-    select    = \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n+    select    = \"^([ \\t]*#[ \\t]*(el)?if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n \t\t\"(([ \\t]*/\\\\*[^\\n]*\\\\*/\\n)?\"\n \t\t\"[ \\t]*typedef[ \\t]+[^\\n]*[ \\t]+_Float(16|32|64|128)x?([ \\t]+__attribute__ \\\\(\\\\(__mode__ \\\\(__HF__\\\\)\\\\)\\\\))?;)\";\n     c_fix     = format;\n-    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%2\";\n+    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%3\";\n     test_text = <<-EOT\n \t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n \ttypedef float _Float16 __attribute__ ((__mode__ (__HF__)));\n \t#  endif\n \t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n \ttypedef __float128 _Float128;\n \t#  endif\n+\t#  if 0\n+\t#  elif !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\ttypedef __float128 _Float128;\n+\t#  endif\n \tEOT;\n };\n \n@@ -2111,6 +2115,39 @@ fix = {\n \tEOT;\n };\n \n+fix = {\n+    hackname  = glibc_cxx_floatn_4;\n+    files     = bits/floatn.h, \"*/bits/floatn.h\";\n+    select    = \"^([ \\t]*#[ \\t]*if __LDBL_MANT_DIG__ == 113 && )defined __cplusplus\\n\"\n+\t\t\"(([ \\t]*/\\\\*[^\\n]*\\\\*/\\n)?\"\n+\t\t\"[ \\t]*typedef[ \\t]+[^\\n]*[ \\t]+_Float128;)\";\n+    c_fix     = format;\n+    c_fix_arg = \"%1defined __cplusplus && !__GNUC_PREREQ (13, 0)\\n%2\";\n+    test_text = <<-EOT\n+\t#  if __LDBL_MANT_DIG__ == 113 && defined __cplusplus\n+\ttypedef long double _Float128;\n+\t#   define __CFLOAT128 _Complex long double\n+\t#  endif\n+\tEOT;\n+};\n+\n+fix = {\n+    hackname  = glibc_cxx_floatn_5;\n+    files     = bits/floatn.h, bits/floatn-common.h, \"*/bits/floatn.h\", \"*/bits/floatn-common.h\";\n+    select    = \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n+\t\t\"([ \\t]*#[ \\t]+error \\\"_Float128[xX] supported but no )\";\n+    c_fix     = format;\n+    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%2\";\n+    test_text = <<-EOT\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t#   error \"_Float128X supported but no constant suffix\"\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t#   error \"_Float128x supported but no type\"\n+\t#  endif\n+\tEOT;\n+};\n+\n /*  glibc-2.3.5 defines pthread mutex initializers incorrectly,\n  *  so we replace them with versions that correspond to the\n  *  definition."}, {"sha": "9681134a5f3ce8e6008102a4d45ad1335c70f40c", "filename": "fixincludes/tests/base/bits/floatn.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -45,6 +45,10 @@ typedef float _Float16 __attribute__ ((__mode__ (__HF__)));\n #  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n typedef __float128 _Float128;\n #  endif\n+#  if 0\n+#  elif !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+typedef __float128 _Float128;\n+#  endif\n #endif  /* GLIBC_CXX_FLOATN_2_CHECK */\n \n \n@@ -72,3 +76,21 @@ typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));\n #   define __CFLOAT64 _Complex _Float64\n #  endif\n #endif  /* GLIBC_CXX_FLOATN_3_CHECK */\n+\n+\n+#if defined( GLIBC_CXX_FLOATN_4_CHECK )\n+#  if __LDBL_MANT_DIG__ == 113 && defined __cplusplus && !__GNUC_PREREQ (13, 0)\n+typedef long double _Float128;\n+#   define __CFLOAT128 _Complex long double\n+#  endif\n+#endif  /* GLIBC_CXX_FLOATN_4_CHECK */\n+\n+\n+#if defined( GLIBC_CXX_FLOATN_5_CHECK )\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+#   error \"_Float128X supported but no constant suffix\"\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+#   error \"_Float128x supported but no type\"\n+#  endif\n+#endif  /* GLIBC_CXX_FLOATN_5_CHECK */"}, {"sha": "f7ab7dacd1485e3421556f2e41661e82fa4198f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3920, "deletions": 0, "changes": 3920, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "39502537bfa90875d5d7785452019d85d4d7d8af", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1 +1 @@\n-20220927\n+20221101"}, {"sha": "fb1fd4b2922c06ea9a195d7a08004741e3e76ea1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1263,6 +1263,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/bar-chart.o \\\n \tanalyzer/call-info.o \\\n \tanalyzer/call-string.o \\\n+\tanalyzer/call-summary.o \\\n \tanalyzer/checker-path.o \\\n \tanalyzer/complexity.o \\\n \tanalyzer/constraint-manager.o \\\n@@ -2691,6 +2692,7 @@ s-match: build/genmatch$(build_exeext) $(srcdir)/match.pd cfn-operators.pd\n \n GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(host_xm_file_list) \\\n+  $(OPTIONS_H_EXTRA) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n   $(srcdir)/wide-int.h $(srcdir)/alias.h \\\n   $(srcdir)/coverage.cc  $(srcdir)/rtl.h \\"}, {"sha": "e13486ac0483cfd2dffa5d8147bca085137d7ae5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,3 +1,176 @@\n+2022-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* libgnat/system-linux-sparc.ads (Support_Atomic_Primitives): New\n+\tconstant set to True.\n+\n+2022-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.def (LOAD_EXPR): New expression code.\n+\t* gcc-interface/gigi.h (build_storage_model_load): Declare.\n+\t(build_storage_model_store): Likewise.\n+\t(instantiate_load_in_expr): Likewise.\n+\t(INSTANTIATE_LOAD_IN_EXPR): New macro.\n+\t(instantiate_load_in_array_ref): Declare.\n+\t* gcc-interface/decl.cc (gnat_to_gnu_entity) <E_Record_Type>: Set a\n+\tfake discriminant number on the fields of the template type.\n+\t(gnat_to_gnu_field): Use integer for DECL_DISCRIMINANT_NUMBER.\n+\t* gcc-interface/misc.cc (gnat_init_ts): Mark LOAD_EXPR as typed.\n+\t* gcc-interface/trans.cc (fold_constant_decl_in_expr) <ARRAY_REF>:\n+\tAlso preserve the 4th operand.\n+\t(Attribute_to_gnu): Deal with LOAD_EXPR of unconstrained array type.\n+\t<Attr_Size>: Call INSTANTIATE_LOAD_IN_EXPR for a storage model.\n+\t<Attr_Length>: Likewise.\n+\t<Attr_Bit_Position>: Likewise.\n+\t(get_storage_model): New function.\n+\t(get_storage_model_access): Likewise.\n+\t(storage_model_access_required_p): Likewise.\n+\t(Call_to_gnu): Add GNAT_STORAGE_MODEL parameter and deal with it.\n+\tAlso deal with actual parameters that have a storage model.\n+\t(gnat_to_gnu) <N_Object_Declaratio>: Adjust call to Call_to_gnu.\n+\t<N_Explicit_Dereference>: Deal with a storage model access.\n+\t<N_Indexed_Component>: Likewise.\n+\t<N_Slice>: Likewise.\n+\t<N_Selected_Component>: Likewise.\n+\t<N_Assignment_Statement>: Adjust call to Call_to_gnu.  Deal with a\n+\tstorage model access either on the LHS, on the RHS or on both.\n+\t<N_Function_Cal>: Adjust call to Call_to_gnu.\n+\t<N_Free_Statement>: Deal with a pool that is a storage model.\n+\tReplace test for UNCONSTRAINED_ARRAY_REF with test on the type.\n+\t(gnat_gimplify_expr) <CALL_EXPR>: Tidy up.\n+\t<LOAD_EXPR>: New case.\n+\t<UNCONSTRAINED_ARRAY_REF>: Move down.\n+\t* gcc-interface/utils.cc (maybe_unconstrained_array): Deal with a\n+\tLOAD_EXPR by recursing on its first operand.\n+\t* gcc-interface/utils2.cc (build_allocator): Deal with a pool that\n+\tis a storage model.\n+\t(build_storage_model_copy): New function.\n+\t(build_storage_model_load): Likewise.\n+\t(build_storage_model_store): Likewise.\n+\t(instantiate_load_in_expr): Likewise.\n+\t(instantiate_load_in_array_ref): Likewise.\n+\t(gnat_rewrite_reference) <ARRAY_REF>: Also preserve the 4th operand.\n+\t(get_inner_constant_reference) <ARRAY_REF>: Remove useless test.\n+\t(gnat_invariant_expr) <ARRAY_REF>: Rewrite test.\n+\n+2022-10-06  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_ch6.adb\n+\t(Analyze_Procedure_Call): Replace \"return;\" with \"goto Leave;\", as\n+\tper comment preceding body of Analyze_Procedure_Call.\n+\n+2022-10-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_ch9.adb (Allows_Lock_Free_Implementation): Reject\n+\tconditional goto statements.\n+\n+2022-10-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_pragmas.rst\n+\t(Lock_Free): Remove inconsistent periods that end item\n+\tdescriptions.\n+\t* sem_ch9.adb\n+\t(Allows_Lock_Free_Implementation): Remove unnecessary guard\n+\tagainst an empty list of parameters; replace low-level entity kind\n+\tmembership test with a high-level query; refill error message.\n+\t* gnat_rm.texi: Regenerate.\n+\n+2022-10-06  Alexandre Oliva  <oliva@adacore.com>\n+\n+\t* doc/gnat_rm/security_hardening_features.rst: Add examples of\n+\tcodegen changes in hardened conditionals.\n+\t* gnat_rm.texi: Regenerate.\n+\n+2022-10-06  Alexandre Oliva  <oliva@adacore.com>\n+\n+\t* doc/gnat_rm/security_hardening_features.rst: Add examples of\n+\tcodegen changes in hardened booleans. Mention that C traps where\n+\tAda raises exceptions.\n+\t* gnat_rm.texi: Regenerate.\n+\n+2022-10-06  Alexandre Oliva  <oliva@adacore.com>\n+\n+\t* doc/gnat_rm/security_hardening_features.rst: Add examples of\n+\tcodegen changes in stack scrubbing.\n+\t* gnat_rm.texi: Regenerate.\n+\n+2022-10-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* exp_ch9.adb (Build_Lock_Free_Protected_Subprogram_Body): Replace\n+\tshallow copy of protected statements with a deep copy.\n+\n+2022-10-06  Marc Poulhi\u00e8s  <poulhies@adacore.com>\n+\n+\t* fe.h (Has_Storage_Model_Type_Aspect)\n+\t(Has_Designated_Storage_Model_Aspect, Storage_Model_Object)\n+\t(Storage_Model_Copy_From, Storage_Model_Copy_To): Add\n+\tdeclarations.\n+\t* sem_util.ads: Add WARNING markers for functions for which a new\n+\tC declaration has been added in fe.h\n+\n+2022-10-06  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_util.adb\n+\t(Get_Current_Value_Condition): Treat references occurring within\n+\tthe condition of an if statement, an elsif, or a while loop in the\n+\tsame way as references that occur before the start of that\n+\tenclosing construct.\n+\n+2022-10-06  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Call): Add test of Comes_From_Source on the\n+\tenclosing subprogram's Entity_Id for determining whether to\n+\tperform the compile-time accessibility check on actuals passed to\n+\taliased formals in a function call occurring within a return\n+\tstatement. That test excludes cases where the call occurs within\n+\tthe return statement of a Pre'Class wrapper function.\n+\n+2022-10-06  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch5.adb\n+\t(Expand_Assign_Array_Loop_Or_Bitfield): Minor cleanups.\n+\n+2022-10-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Ignore one variant of pragma\n+\tWarnings in GNATprove mode.\n+\n+2022-10-06  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch5.adb\n+\t(Expand_Assign_Array_Loop_Or_Bitfield): Disable the\n+\tFast_Copy_Bitfield optimization in certain cases.\n+\n+2022-10-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_prag.adb\n+\t(Sig_Pragma): Change flag for pragma Refined_State to mean \"not\n+\tsignificant\"; this is primarily for documentation, because the\n+\texact value of the flag is not really taken into account for\n+\tRefined_State.\n+\t(Is_Non_Significant_Pragma_Reference): Add special handling for\n+\tpragma Refined_State.\n+\n+2022-09-29  Ronan Desplanques  <desplanques@adacore.com>\n+\n+\t* einfo.ads: remove documentation duplicate\n+\n+2022-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* contracts.adb (Build_Subprogram_Contract_Wrapper): Put back the\n+\textended return statement if the result type is built-in-place.\n+\t* sem_attr.adb (Analyze_Attribute_Old_Result): Also expect an\n+\textended return statement.\n+\n+2022-09-29  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch5.adb\n+\t(Expand_Assign_Array_Loop_Or_Bitfield): Make the checks for\n+\tvolatile and independent objects more precise.\n+\n+2022-09-29  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_util.adb (Collect_Visible_States): Ignore package renamings.\n+\n 2022-09-26  Ghjuvan Lacambre  <lacambre@adacore.com>\n \n \t* doc/gnat_rm/implementation_defined_attributes.rst: Rename Valid_Image."}, {"sha": "a300d739effc2b76b77671ff014f19ad3f7935b4", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -30,6 +30,7 @@ with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n with Errout;         use Errout;\n+with Exp_Ch6;        use Exp_Ch6;\n with Exp_Prag;       use Exp_Prag;\n with Exp_Tss;        use Exp_Tss;\n with Exp_Util;       use Exp_Util;\n@@ -1609,7 +1610,7 @@ package body Contracts is\n       --  preserving the result for the purpose of evaluating postconditions,\n       --  contracts, type invariants, etc.\n \n-      --  In the case of a function, generate:\n+      --  In the case of a regular function, generate:\n       --\n       --  function Original_Func (X : in out Integer) return Typ is\n       --     <prologue renamings>\n@@ -1641,7 +1642,27 @@ package body Contracts is\n       --  Note that an extended return statement does not yield the same result\n       --  because the copy of the return object is not elided by GNAT for now.\n \n-      --  Or, in the case of a procedure:\n+      --  Or else, in the case of a BIP function, generate:\n+\n+      --  function Original_Func (X : in out Integer) return Typ is\n+      --     <prologue renamings>\n+      --     <preconditions>\n+      --\n+      --     function _Wrapped_Statements return Typ is\n+      --        <original declarations>\n+      --     begin\n+      --        <original statements>\n+      --     end;\n+      --\n+      --  begin\n+      --     return\n+      --        Result_Obj : constant Typ := _Wrapped_Statements\n+      --     do\n+      --        <postconditions statments>\n+      --     end return;\n+      --  end;\n+\n+      --  Or else, in the case of a procedure, generate:\n       --\n       --  procedure Original_Proc (X : in out Integer) is\n       --     <prologue renamings>\n@@ -1657,7 +1678,6 @@ package body Contracts is\n       --     _Wrapped_Statements;\n       --     <postconditions statments>\n       --  end;\n-      --\n \n       --  Create Identifier\n \n@@ -1716,6 +1736,26 @@ package body Contracts is\n          Set_Statements\n            (Handled_Statement_Sequence (Body_Decl), Stmts);\n \n+      --  Generate the post-execution statements and the extended return\n+      --  when the subprogram being wrapped is a BIP function.\n+\n+      elsif Is_Build_In_Place_Result_Type (Ret_Type) then\n+         Set_Statements (Handled_Statement_Sequence (Body_Decl), New_List (\n+           Make_Extended_Return_Statement (Loc,\n+             Return_Object_Declarations => New_List (\n+                Make_Object_Declaration (Loc,\n+                  Defining_Identifier => Result,\n+                  Constant_Present    => True,\n+                  Object_Definition   =>\n+                    New_Occurrence_Of (Ret_Type, Loc),\n+                  Expression          =>\n+                    Make_Function_Call (Loc,\n+                      Name                   =>\n+                        New_Occurrence_Of (Wrapper_Id, Loc)))),\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Stmts))));\n+\n       --  Declare a renaming of the result of the call to the wrapper and\n       --  append a return of the result of the call when the subprogram is\n       --  a function, after manually removing the side effects. Note that"}, {"sha": "6752d48d15948ae9d95cf0c45dedfdff8f7aaaa3", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -3744,10 +3744,10 @@ In addition, each protected subprogram body must satisfy:\n \n * May reference only one protected component\n * May not reference nonconstant entities outside the protected subprogram\n-  scope.\n+  scope\n * May not contain address representation items, allocators, or quantified\n-  expressions.\n-* May not contain delay, goto, loop, or procedure-call statements.\n+  expressions\n+* May not contain delay, goto, loop, or procedure-call statements\n * May not contain exported and imported entities\n * May not dereferenced access values\n * Function calls and attribute references must be static"}, {"sha": "d7c02b94f36d2f7e06d8edfef1c23a4e842db69d", "filename": "gcc/ada/doc/gnat_rm/security_hardening_features.rst", "status": "modified", "additions": 126, "deletions": 6, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -74,6 +74,58 @@ or a variable.)\n      --  scrubbing of the stack space used by that subprogram.\n \n \n+Given these declarations, Foo has its type and body modified as\n+follows:\n+\n+.. code-block:: ada\n+\n+     function Foo (<WaterMark> : in out System.Address) returns Integer\n+     is\n+       --  ...\n+     begin\n+       <__strub_update> (<WaterMark>);  --  Updates the stack WaterMark.\n+       --  ...\n+     end;\n+\n+\n+whereas its callers are modified from:\n+\n+.. code-block:: ada\n+\n+     X := Foo;\n+\n+to:\n+\n+.. code-block:: ada\n+\n+     declare\n+       <WaterMark> : System.Address;\n+     begin\n+       <__strub_enter> (<WaterMark>);  -- Initialize <WaterMark>.\n+       X := Foo (<WaterMark>);\n+       <__strub_leave> (<WaterMark>);  -- Scrubs stack up to <WaterMark>.\n+     end;\n+\n+\n+As for Bar, because it is strubbed in internal mode, its callers are\n+not modified.  Its definition is modified roughly as follows:\n+\n+.. code-block:: ada\n+\n+     procedure Bar is\n+       <WaterMark> : System.Address;\n+       procedure Strubbed_Bar (<WaterMark> : in out System.Address) is\n+       begin\n+         <__strub_update> (<WaterMark>);  --  Updates the stack WaterMark.\n+         -- original Bar body.\n+       end Strubbed_Bar;\n+     begin\n+       <__strub_enter> (<WaterMark>);  -- Initialize <WaterMark>.\n+       Strubbed_Bar (<WaterMark>);\n+       <__strub_leave> (<WaterMark>);  -- Scrubs stack up to <WaterMark>.\n+     end Bar;\n+\n+\n There are also :switch:`-fstrub={choice}` command-line options to\n control default settings.  For usage and more details on the\n command-line options, on the ``strub`` attribute, and their use with\n@@ -151,11 +203,58 @@ activated by a separate command-line option.\n \n The option :switch:`-fharden-compares` enables hardening of compares\n that compute results stored in variables, adding verification that the\n-reversed compare yields the opposite result.\n+reversed compare yields the opposite result, turning:\n+\n+.. code-block:: ada\n+\n+    B := X = Y;\n+\n+\n+into:\n+\n+.. code-block:: ada\n+\n+    B := X = Y;\n+    declare\n+      NotB : Boolean := X /= Y; -- Computed independently of B.\n+    begin\n+      if B = NotB then\n+        <__builtin_trap>;\n+      end if;\n+    end;\n+\n \n The option :switch:`-fharden-conditional-branches` enables hardening\n of compares that guard conditional branches, adding verification of\n-the reversed compare to both execution paths.\n+the reversed compare to both execution paths, turning:\n+\n+.. code-block:: ada\n+\n+    if X = Y then\n+      X := Z + 1;\n+    else\n+      Y := Z - 1;\n+    end if;\n+\n+\n+into:\n+\n+.. code-block:: ada\n+\n+    if X = Y then\n+      if X /= Y then -- Computed independently of X = Y.\n+        <__builtin_trap>;\n+      end if;\n+      X := Z + 1;\n+    else\n+      if X /= Y then -- Computed independently of X = Y.\n+        null;\n+      else\n+        <__builtin_trap>;\n+      end if;\n+      Y := Z - 1;\n+    end if;\n+\n \n These transformations are introduced late in the compilation pipeline,\n long after boolean expressions are decomposed into separate compares,\n@@ -213,19 +312,40 @@ further remove checks found to be redundant.\n For additional hardening, the ``hardbool`` :samp:`Machine_Attribute`\n pragma can be used to annotate boolean types with representation\n clauses, so that expressions of such types used as conditions are\n-checked even when compiling with :switch:`-gnatVT`.\n+checked even when compiling with :switch:`-gnatVT`:\n \n .. code-block:: ada\n \n    pragma Machine_Attribute (HBool, \"hardbool\");\n \n+   function To_Boolean (X : HBool) returns Boolean is (Boolean (X));\n+\n+\n+is compiled roughly like:\n+\n+.. code-block:: ada\n+\n+   function To_Boolean (X : HBool) returns Boolean is\n+   begin\n+     if X not in True | False then\n+       raise Constraint_Error;\n+     elsif X in True then\n+       return True;\n+     else\n+       return False;\n+     end if;\n+   end To_Boolean;\n+\n \n Note that :switch:`-gnatVn` will disable even ``hardbool`` testing.\n \n Analogous behavior is available as a GCC extension to the C and\n-Objective C programming languages, through the ``hardbool`` attribute.\n-For usage and more details on that attribute, see :title:`Using the\n-GNU Compiler Collection (GCC)`.\n+Objective C programming languages, through the ``hardbool`` attribute,\n+with the difference that, instead of raising a Constraint_Error\n+exception, when a hardened boolean variable is found to hold a value\n+that stands for neither True nor False, the program traps.  For usage\n+and more details on that attribute, see :title:`Using the GNU Compiler\n+Collection (GCC)`.\n \n \n .. Control Flow Redundancy:"}, {"sha": "e350f137ee74db1a83946859259a5fca7f63576f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 3, "deletions": 37, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -222,10 +222,9 @@ package Einfo is\n --  on the actions triggered by a freeze node, which include the construction\n --  of initialization procedures and dispatch tables.\n \n---  b) The presence of a freeze node on an entity is used by the back end to\n---  defer elaboration of the entity until its freeze node is seen. In the\n---  absence of an explicit freeze node, an entity is frozen (and elaborated)\n---  at the point of declaration.\n+--  b) The flag is used by the back end to defer elaboration of the entity\n+--  until its freeze node is seen. In the absence of an explicit freeze node,\n+--  an entity is frozen (and elaborated) at the point of declaration.\n \n --  For object declarations, the flag is set when an address clause for the\n --  object is encountered. Legality checks on the address expression only take\n@@ -4825,39 +4824,6 @@ package Einfo is\n \n --  The front-end does not store explicitly the fact that Z renames X.\n \n---------------------------------------\n--- Delayed Freezing and Elaboration --\n---------------------------------------\n-\n---  The flag Has_Delayed_Freeze indicates that an entity carries an explicit\n---  freeze node, which appears later in the expanded tree.\n-\n---  a) The flag is used by the front-end to trigger expansion actions\n---  which include the generation of that freeze node. Typically this happens at\n---  the end of the current compilation unit, or before the first subprogram\n---  body is encountered in the current unit. See files freeze and exp_ch13 for\n---  details on the actions triggered by a freeze node, which include the\n---  construction of initialization procedures and dispatch tables.\n-\n---  b) The flag is used by the backend to defer elaboration of the entity until\n---  its freeze node is seen. In the absence of an explicit freeze node, an\n---  entity is frozen (and elaborated) at the point of declaration.\n-\n---  For object declarations, the flag is set when an address clause for the\n---  object is encountered. Legality checks on the address expression only\n---  take place at the freeze point of the object.\n-\n---  Most types have an explicit freeze node, because they cannot be elaborated\n---  until all representation and operational items that apply to them have been\n---  analyzed. Private types and incomplete types have the flag set as well, as\n---  do task and protected types.\n-\n---  Implicit base types created for type derivations, as well as classwide\n---  types created for all tagged types, have the flag set.\n-\n---  If a subprogram has an access parameter whose designated type is incomplete\n---  the subprogram has the flag set.\n-\n ------------------\n -- Access Kinds --\n ------------------"}, {"sha": "d5d66d961dedde596e23ccac088dfd9098e8c64a", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 84, "deletions": 25, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1594,48 +1594,107 @@ package body Exp_Ch5 is\n       Rev    : Boolean) return Node_Id\n    is\n \n+      function Volatile_Or_Independent\n+        (Exp : Node_Id; Typ : Entity_Id) return Boolean;\n+      --  Exp is an expression of type Typ, or if there is no expression\n+      --  involved, Exp is Empty. True if there are any volatile or independent\n+      --  objects that should disable the optimization. We check the object\n+      --  itself, all subcomponents, and if Exp is a slice of a component or\n+      --  slice, we check the prefix and its type.\n+      --\n+      --  We disable the optimization when there are relevant volatile or\n+      --  independent objects, because Copy_Bitfield can read and write bits\n+      --  that are not part of the objects being copied.\n+\n+      -----------------------------\n+      -- Volatile_Or_Independent --\n+      -----------------------------\n+\n+      function Volatile_Or_Independent\n+        (Exp : Node_Id; Typ : Entity_Id) return Boolean\n+      is\n+      begin\n+         --  Initially, Exp is the left- or right-hand side. In recursive\n+         --  calls, Exp is Empty if we're just checking a component type, and\n+         --  Exp is the prefix if we're checking the prefix of a slice.\n+\n+         if Present (Exp)\n+           and then (Is_Volatile_Object_Ref (Exp)\n+                       or else Is_Independent_Object (Exp))\n+         then\n+            return True;\n+         end if;\n+\n+         if Has_Volatile_Components (Typ)\n+           or else Has_Independent_Components (Typ)\n+         then\n+            return True;\n+         end if;\n+\n+         if Is_Array_Type (Typ) then\n+            if Volatile_Or_Independent (Empty, Component_Type (Typ)) then\n+               return True;\n+            end if;\n+\n+         elsif Is_Record_Type (Typ) then\n+            declare\n+               Comp : Entity_Id := First_Component (Typ);\n+            begin\n+               while Present (Comp) loop\n+                  if Volatile_Or_Independent (Empty, Comp) then\n+                     return True;\n+                  end if;\n+\n+                  Next_Component (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         if Nkind (Exp) = N_Slice\n+           and then Nkind (Prefix (Exp)) in\n+                      N_Selected_Component | N_Indexed_Component | N_Slice\n+         then\n+            if Volatile_Or_Independent (Prefix (Exp), Etype (Prefix (Exp)))\n+            then\n+               return True;\n+            end if;\n+         end if;\n+\n+         return False;\n+      end Volatile_Or_Independent;\n+\n+      function Slice_Of_Packed_Component (L : Node_Id) return Boolean is\n+        (Nkind (L) = N_Slice\n+         and then Nkind (Prefix (L)) = N_Indexed_Component\n+         and then Is_Bit_Packed_Array (Etype (Prefix (Prefix (L)))));\n+      --  L is the left-hand side Name. Returns True if L is a slice of a\n+      --  component of a bit-packed array. The optimization is disabled in\n+      --  that case, because Expand_Assign_Array_Bitfield_Fast cannot\n+      --  currently handle that case correctly.\n+\n       L : constant Node_Id := Name (N);\n       R : constant Node_Id := Expression (N);\n       --  Left- and right-hand sides of the assignment statement\n \n       Slices : constant Boolean :=\n         Nkind (L) = N_Slice or else Nkind (R) = N_Slice;\n-      L_Prefix_Comp : constant Boolean :=\n-        --  True if the left-hand side is a slice of a component or slice\n-        Nkind (L) = N_Slice\n-          and then Nkind (Prefix (L)) in\n-                     N_Selected_Component | N_Indexed_Component | N_Slice;\n-      R_Prefix_Comp : constant Boolean :=\n-        --  Likewise for the right-hand side\n-        Nkind (R) = N_Slice\n-          and then Nkind (Prefix (R)) in\n-                     N_Selected_Component | N_Indexed_Component | N_Slice;\n+\n+   --  Start of processing for Expand_Assign_Array_Loop_Or_Bitfield\n \n    begin\n       --  Determine whether Copy_Bitfield or Fast_Copy_Bitfield is appropriate\n       --  (will work, and will be more efficient than component-by-component\n       --  copy). Copy_Bitfield doesn't work for reversed storage orders. It is\n-      --  efficient for slices of bit-packed arrays. Copy_Bitfield can read and\n-      --  write bits that are not part of the objects being copied, so we don't\n-      --  want to use it if there are volatile or independent components. If\n-      --  the Prefix of the slice is a component or slice, then it might be a\n-      --  part of an object with some other volatile or independent components,\n-      --  so we disable the optimization in that case as well. We could\n-      --  complicate this code by actually looking for such volatile and\n-      --  independent components.\n+      --  efficient for slices of bit-packed arrays.\n \n       if Is_Bit_Packed_Array (L_Type)\n         and then Is_Bit_Packed_Array (R_Type)\n         and then not Reverse_Storage_Order (L_Type)\n         and then not Reverse_Storage_Order (R_Type)\n-        and then Ndim = 1\n         and then Slices\n-        and then not Has_Volatile_Component (L_Type)\n-        and then not Has_Volatile_Component (R_Type)\n-        and then not Has_Independent_Components (L_Type)\n-        and then not Has_Independent_Components (R_Type)\n-        and then not L_Prefix_Comp\n-        and then not R_Prefix_Comp\n+        and then not Slice_Of_Packed_Component (L)\n+        and then not Volatile_Or_Independent (L, L_Type)\n+        and then not Volatile_Or_Independent (R, R_Type)\n       then\n          --  Here if Copy_Bitfield can work (except for the Rev test below).\n          --  Determine whether to call Fast_Copy_Bitfield instead. If we"}, {"sha": "decf61782afbb89ccf046c4d361e31175a68433a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2797,7 +2797,7 @@ package body Exp_Ch9 is\n             Expected_Comp : Entity_Id;\n             Stmt          : Node_Id;\n             Stmts         : List_Id :=\n-                              New_Copy_List (Statements (Hand_Stmt_Seq));\n+                              New_Copy_List_Tree (Statements (Hand_Stmt_Seq));\n             Typ_Size      : Int;\n             Unsigned      : Entity_Id;\n "}, {"sha": "f569d2ef583c17a4b22bf4da97d355efa3458349", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -6923,6 +6923,11 @@ package body Exp_Util is\n             if Loc < Sloc (CV) then\n                return;\n \n+            --  In condition of IF statement\n+\n+            elsif In_Subtree (N => Var, Root => Condition (CV)) then\n+               return;\n+\n             --  After end of IF statement\n \n             elsif Loc >= Sloc (CV) + Text_Ptr (UI_To_Int (End_Span (CV))) then\n@@ -7009,7 +7014,12 @@ package body Exp_Util is\n             if Loc < Sloc (CV) then\n                return;\n \n-               --  After end of IF statement\n+            --  In condition of ELSIF part\n+\n+            elsif In_Subtree (N => Var, Root => Condition (CV)) then\n+               return;\n+\n+            --  After end of IF statement\n \n             elsif Loc >= Sloc (Stm) +\n               Text_Ptr (UI_To_Int (End_Span (Stm)))\n@@ -7066,6 +7076,11 @@ package body Exp_Util is\n                if Loc < Sloc (Loop_Stmt) then\n                   return;\n \n+               --  In condition of while loop\n+\n+               elsif In_Subtree (N => Var, Root => Condition (CV)) then\n+                  return;\n+\n                --  After end of LOOP statement\n \n                elsif Loc >= Sloc (End_Label (Loop_Stmt)) then"}, {"sha": "79a1b58836ec3b1e9375656dd8f07e22e824111b", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -304,17 +304,27 @@ extern Boolean Compile_Time_Known_Value\t(Node_Id);\n \n #define Defining_Entity\t\t\tsem_util__defining_entity\n #define First_Actual\t\t\tsem_util__first_actual\n+#define Has_Storage_Model_Type_Aspect\tsem_util__storage_model_support__has_storage_model_type_aspect\n+#define Has_Designated_Storage_Model_Aspect sem_util__storage_model_support__has_designated_storage_model_aspect\n #define Is_Expression_Function\t\tsem_util__is_expression_function\n #define Is_Variable_Size_Record \tsem_util__is_variable_size_record\n #define Needs_Secondary_Stack\t\tsem_util__needs_secondary_stack\n #define Next_Actual\t\t\tsem_util__next_actual\n+#define Storage_Model_Object \t\tsem_util__storage_model_support__storage_model_object\n+#define Storage_Model_Copy_From \tsem_util__storage_model_support__storage_model_copy_from\n+#define Storage_Model_Copy_To \t\tsem_util__storage_model_support__storage_model_copy_to\n \n extern Entity_Id Defining_Entity\t\t(Node_Id);\n extern Node_Id First_Actual\t\t\t(Node_Id);\n+extern Boolean Has_Storage_Model_Type_Aspect\t(Entity_Id);\n+extern Boolean Has_Designated_Storage_Model_Aspect (Entity_Id);\n extern Boolean Is_Expression_Function\t\t(Entity_Id);\n extern Boolean Is_Variable_Size_Record \t\t(Entity_Id);\n extern Boolean Needs_Secondary_Stack\t\t(Entity_Id);\n extern Node_Id Next_Actual\t\t\t(Node_Id);\n+extern Entity_Id Storage_Model_Object\t\t(Entity_Id);\n+extern Entity_Id Storage_Model_Copy_From\t(Entity_Id);\n+extern Entity_Id Storage_Model_Copy_To \t\t(Entity_Id);\n \n /* sinfo: */\n "}, {"sha": "7fc95cb74c58970a54ba88f428ff4cb8c53d4c71", "filename": "gcc/ada/gcc-interface/ada-tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -35,6 +35,10 @@ DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", tcc_type, 0)\n DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\",\n \t     tcc_reference, 1)\n \n+/* Same as SAVE_EXPR, but operand 1 contains the statement used to initialize\n+   the temporary instead of using the value of operand 0 directly.  */\n+DEFTREECODE (LOAD_EXPR, \"load_expr\", tcc_expression, 2)\n+\n /* An expression that returns an RTL suitable for its type.  Operand 0\n    is an expression to be evaluated for side effects only.  */\n DEFTREECODE (NULL_EXPR, \"null_expr\", tcc_expression, 1)"}, {"sha": "f8c76982de5a68d6b22483dbe866496e2c1e7bc6", "filename": "gcc/ada/gcc-interface/decl.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2279,6 +2279,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t\t      gnu_index_type,\n \t\t\t\t\t      gnu_template_type, NULL_TREE,\n \t\t\t\t\t      NULL_TREE, 0, 0);\n+\t    /* Mark the field specifically for INSTANTIATE_LOAD_IN_EXPR.  */\n+\t    DECL_DISCRIMINANT_NUMBER (gnu_lb_field) = integer_minus_one_node;\n \t    Sloc_to_locus (Sloc (gnat_entity),\n \t\t\t   &DECL_SOURCE_LOCATION (gnu_lb_field));\n \n@@ -2287,6 +2289,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t\t      gnu_index_type,\n \t\t\t\t\t      gnu_template_type, NULL_TREE,\n \t\t\t\t\t      NULL_TREE, 0, 0);\n+\t    /* Mark the field specifically for INSTANTIATE_LOAD_IN_EXPR.  */\n+\t    DECL_DISCRIMINANT_NUMBER (gnu_hb_field) = integer_minus_one_node;\n \t    Sloc_to_locus (Sloc (gnat_entity),\n \t\t\t   &DECL_SOURCE_LOCATION (gnu_hb_field));\n \n@@ -7694,7 +7698,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   if (Ekind (gnat_field) == E_Discriminant)\n     {\n       DECL_DISCRIMINANT_NUMBER (gnu_field)\n-\t= UI_To_gnu (Discriminant_Number (gnat_field), sizetype);\n+\t= UI_To_gnu (Discriminant_Number (gnat_field), integer_type_node);\n       DECL_INVARIANT_P (gnu_field)\n \t= No (Discriminant_Default_Value (gnat_field));\n       DECL_NONADDRESSABLE_P (gnu_field) = 0;"}, {"sha": "82e2403a7d69fc2ae958c2e15cb8227f10ee4437", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -912,6 +912,34 @@ extern tree build_allocator (tree type, tree init, tree result_type,\n                              Entity_Id gnat_proc, Entity_Id gnat_pool,\n                              Node_Id gnat_node, bool);\n \n+/* Build a load of SRC using the storage model of GNAT_SMO.  */\n+extern tree build_storage_model_load (Entity_Id gnat_smo, tree src);\n+\n+/* Build a load of SRC into DEST using the storage model of GNAT_SMO.\n+   If SIZE is specified, use it, otherwise use the size of SRC.  */\n+extern tree build_storage_model_load (Entity_Id gnat_smo, tree dest, tree src,\n+\t\t\t\t      tree size = NULL_TREE);\n+\n+/* Build a store of SRC into DEST using the storage model of GNAT_SMO.\n+   If SIZE is specified, use it, otherwise use the size of DEST.  */\n+extern tree build_storage_model_store (Entity_Id gnat_smo, tree dest, tree src,\n+\t\t\t\t       tree size = NULL_TREE);\n+\n+/* Given a tree EXP, instantiate occurrences of LOAD_EXPR in it and associate\n+   them with the storage model of GNAT_SMO.  */\n+extern tree instantiate_load_in_expr (tree exp, Entity_Id gnat_smo);\n+\n+/* This macro calls the above function but short-circuits the common\n+   case of a constant to save time and also checks for NULL.  */\n+\n+#define INSTANTIATE_LOAD_IN_EXPR(EXP, GNAT_SMO) \\\n+  ((EXP) == NULL_TREE || TREE_CONSTANT (EXP) ? (EXP)\t\\\n+   : instantiate_load_in_expr (EXP, GNAT_SMO))\n+\n+/* Given an array or slice reference, instantiate occurrences of LOAD_EXPR in\n+   it and associate them with the storage model of GNAT_SMO.  */\n+extern void instantiate_load_in_array_ref (tree ref, Entity_Id gnat_smo);\n+\n /* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Returns true if successful.  */\n extern bool gnat_mark_addressable (tree t);"}, {"sha": "e1b5a43c4f43215488ecffc3a2981eea6d30e4f9", "filename": "gcc/ada/gcc-interface/misc.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1309,6 +1309,7 @@ gnat_init_ts (void)\n   MARK_TS_COMMON (UNCONSTRAINED_ARRAY_TYPE);\n \n   MARK_TS_TYPED (UNCONSTRAINED_ARRAY_REF);\n+  MARK_TS_TYPED (LOAD_EXPR);\n   MARK_TS_TYPED (NULL_EXPR);\n   MARK_TS_TYPED (PLUS_NOMOD_EXPR);\n   MARK_TS_TYPED (MINUS_NOMOD_EXPR);"}, {"sha": "d0ff741585e289a42ea49cfadcf90dd794fce1ad", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 283, "deletions": 43, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1033,7 +1033,7 @@ fold_constant_decl_in_expr (tree exp)\n \treturn exp;\n \n       return fold (build4 (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1),\n-\t\t\t   TREE_OPERAND (exp, 2), NULL_TREE));\n+\t\t\t   TREE_OPERAND (exp, 2), TREE_OPERAND (exp, 3)));\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n@@ -1671,6 +1671,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n   tree gnu_type = TREE_TYPE (gnu_prefix);\n   tree gnu_expr, gnu_result_type, gnu_result = error_mark_node;\n   bool prefix_unused = false;\n+  Entity_Id gnat_smo;\n \n   /* If the input is a NULL_EXPR, make a new one.  */\n   if (TREE_CODE (gnu_prefix) == NULL_EXPR)\n@@ -1680,6 +1681,14 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       return build1 (NULL_EXPR, gnu_result_type, TREE_OPERAND (gnu_prefix, 0));\n     }\n \n+  /* If the input is a LOAD_EXPR of an unconstrained array type, the second\n+     operand contains the storage model object.  */\n+  if (TREE_CODE (gnu_prefix) == LOAD_EXPR\n+      && TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE)\n+    gnat_smo = tree_to_shwi (TREE_OPERAND (gnu_prefix, 1));\n+  else\n+    gnat_smo = Empty;\n+\n   switch (attribute)\n     {\n     case Attr_Pred:\n@@ -1960,7 +1969,11 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       /* Deal with a self-referential size by qualifying the size with the\n \t object or returning the maximum size for a type.  */\n       if (TREE_CODE (gnu_prefix) != TYPE_DECL)\n-\tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n+\t{\n+\t  gnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n+\t  if (Present (gnat_smo))\n+\t    gnu_result = INSTANTIATE_LOAD_IN_EXPR (gnu_result, gnat_smo);\n+\t}\n       else if (CONTAINS_PLACEHOLDER_P (gnu_result))\n \tgnu_result = max_size (gnu_result, true);\n \n@@ -2191,6 +2204,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t   handling.  Note that these attributes could not have been used on\n \t   an unconstrained array type.  */\n \tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n+\tif (Present (gnat_smo))\n+\t  gnu_result = INSTANTIATE_LOAD_IN_EXPR (gnu_result, gnat_smo);\n \n \t/* Cache the expression we have just computed.  Since we want to do it\n \t   at run time, we force the use of a SAVE_EXPR and let the gimplifier\n@@ -2351,6 +2366,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t/* If this has a PLACEHOLDER_EXPR, qualify it by the object we are\n \t   handling.  */\n \tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n+\tif (Present (gnat_smo))\n+\t  gnu_result = INSTANTIATE_LOAD_IN_EXPR (gnu_result, gnat_smo);\n \tbreak;\n       }\n \n@@ -4356,6 +4373,49 @@ simple_atomic_access_required_p (Node_Id gnat_node, bool *sync)\n   return type == SIMPLE_ATOMIC;\n }\n \n+/* Return the storage model specified by GNAT_NODE, or else Empty.  */\n+\n+static Entity_Id\n+get_storage_model (Node_Id gnat_node)\n+{\n+  if (Nkind (gnat_node) == N_Explicit_Dereference\n+      && Has_Designated_Storage_Model_Aspect (Etype (Prefix (gnat_node))))\n+    return Storage_Model_Object (Etype (Prefix (gnat_node)));\n+  else\n+    return Empty;\n+}\n+\n+/* Compute whether GNAT_NODE requires storage model access and set GNAT_SMO to\n+   the storage model object to be used for it if it does, or else Empty.  */\n+\n+static void\n+get_storage_model_access (Node_Id gnat_node, Entity_Id *gnat_smo)\n+{\n+  const Node_Id gnat_parent = Parent (gnat_node);\n+\n+  /* If we are the prefix of the parent, then the access is above us.  */\n+  if (node_is_component (gnat_parent) && Prefix (gnat_parent) == gnat_node)\n+    {\n+      *gnat_smo = Empty;\n+      return;\n+    }\n+\n+  while (node_is_component (gnat_node))\n+    gnat_node = Prefix (gnat_node);\n+\n+  *gnat_smo = get_storage_model (gnat_node);\n+}\n+\n+/* Return true if GNAT_NODE requires storage model access and, if so, set\n+   GNAT_SMO to the storage model object to be used for it.  */\n+\n+static bool\n+storage_model_access_required_p (Node_Id gnat_node, Entity_Id *gnat_smo)\n+{\n+  get_storage_model_access (gnat_node, gnat_smo);\n+  return Present (*gnat_smo);\n+}\n+\n /* Create a temporary variable with PREFIX and TYPE, and return it.  */\n \n static tree\n@@ -4471,11 +4531,14 @@ elaborate_profile (Entity_Id first_formal, Entity_Id result_type)\n    N_Assignment_Statement and the result is to be placed into that object.\n    ATOMIC_ACCESS is the type of atomic access to be used for the assignment\n    to GNU_TARGET.  If, in addition, ATOMIC_SYNC is true, then the assignment\n-   to GNU_TARGET requires atomic synchronization.  */\n+   to GNU_TARGET requires atomic synchronization.  GNAT_STORAGE_MODEL is the\n+   storage model object to be used for the assignment to GNU_TARGET or Empty\n+   if there is none.  */\n \n static tree\n Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n-\t     atomic_acces_t atomic_access, bool atomic_sync)\n+\t     atomic_acces_t atomic_access, bool atomic_sync,\n+\t     Entity_Id gnat_storage_model)\n {\n   const bool function_call = (Nkind (gnat_node) == N_Function_Call);\n   const bool returning_value = (function_call && !gnu_target);\n@@ -4507,6 +4570,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   Node_Id gnat_actual;\n   atomic_acces_t aa_type;\n   bool aa_sync;\n+  Entity_Id gnat_smo;\n \n   /* The only way we can make a call via an access type is if GNAT_NAME is an\n      explicit dereference.  In that case, get the list of formal args from the\n@@ -4624,7 +4688,9 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  unconstrained record type with default discriminant, because the\n \t  return may copy more data than the bit-field can contain.\n \n-       5. There is no target and we have misaligned In Out or Out parameters\n+       5. There is a target which needs to be accessed with a storage model.\n+\n+       6. There is no target and we have misaligned In Out or Out parameters\n \t  passed by reference, because we need to preserve the return value\n \t  before copying back the parameters.  However, in this case, we'll\n \t  defer creating the temporary, see below.\n@@ -4654,7 +4720,10 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      && DECL_BIT_FIELD (TREE_OPERAND (gnu_target, 1))\n \t      && DECL_SIZE (TREE_OPERAND (gnu_target, 1))\n \t\t != TYPE_SIZE (TREE_TYPE (gnu_target))\n-\t      && type_is_padding_self_referential (gnu_result_type))))\n+\t      && type_is_padding_self_referential (gnu_result_type))\n+\t  || (gnu_target\n+\t      && Present (gnat_storage_model)\n+\t      && Present (Storage_Model_Copy_To (gnat_storage_model)))))\n     {\n       gnu_retval = create_temporary (\"R\", gnu_result_type);\n       DECL_RETURN_VALUE_P (gnu_retval) = 1;\n@@ -4725,12 +4794,19 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      = build_compound_expr (TREE_TYPE (gnu_name), init, gnu_name);\n \t}\n \n-      /* If we are passing a non-addressable parameter by reference, pass the\n-\t address of a copy.  In the In Out or Out case, set up to copy back\n-\t out after the call.  */\n+      get_storage_model_access (gnat_actual, &gnat_smo);\n+\n+      /* If we are passing a non-addressable actual parameter by reference,\n+\t pass the address of a copy.  Likewise if it needs to be accessed with\n+\t a storage model.  In the In Out or Out case, set up to copy back out\n+\t after the call.  */\n       if (is_by_ref_formal_parm\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n-\t  && !addressable_p (gnu_name, gnu_name_type))\n+\t  && (!addressable_p (gnu_name, gnu_name_type)\n+\t      || (Present (gnat_smo)\n+\t\t  && (Present (Storage_Model_Copy_From (gnat_smo))\n+\t\t      || (!in_param\n+\t\t\t  && Present (Storage_Model_Copy_To (gnat_smo)))))))\n \t{\n \t  tree gnu_orig = gnu_name, gnu_temp, gnu_stmt;\n \n@@ -4801,20 +4877,40 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    }\n \n \t  /* Create an explicit temporary holding the copy.  */\n+\t  tree gnu_temp_type;\n+\t  if (Nkind (gnat_actual) == N_Explicit_Dereference\n+\t      && Present (Actual_Designated_Subtype (gnat_actual)))\n+\t    gnu_temp_type\n+\t      = gnat_to_gnu_type (Actual_Designated_Subtype (gnat_actual));\n+\t  else\n+\t    gnu_temp_type = TREE_TYPE (gnu_name);\n+\n \t  /* Do not initialize it for the _Init parameter of an initialization\n \t     procedure since no data is meant to be passed in.  */\n \t  if (Ekind (gnat_formal) == E_Out_Parameter\n \t      && Is_Entity_Name (gnat_subprog)\n \t      && Is_Init_Proc (Entity (gnat_subprog)))\n-\t    gnu_name = gnu_temp = create_temporary (\"A\", TREE_TYPE (gnu_name));\n+\t    gnu_name = gnu_temp = create_temporary (\"A\", gnu_temp_type);\n \n \t  /* Initialize it on the fly like for an implicit temporary in the\n \t     other cases, as we don't necessarily have a statement list.  */\n \t  else\n \t    {\n-\t      gnu_temp = create_init_temporary (\"A\", gnu_name, &gnu_stmt,\n-\t\t\t\t\t\tgnat_actual);\n-\t      gnu_name = build_compound_expr (TREE_TYPE (gnu_name), gnu_stmt,\n+\t      if (Present (gnat_smo)\n+\t\t  && Present (Storage_Model_Copy_From (gnat_smo)))\n+\t\t{\n+\t\t  gnu_temp = create_temporary (\"A\", gnu_temp_type);\n+\t\t  gnu_stmt\n+\t\t    = build_storage_model_load (gnat_smo, gnu_temp,\n+\t\t\t\t\t\tgnu_name,\n+\t\t\t\t\t\tTYPE_SIZE_UNIT (gnu_temp_type));\n+\t\t  set_expr_location_from_node (gnu_stmt, gnat_actual);\n+\t\t}\n+\t      else\n+\t\tgnu_temp = create_init_temporary (\"A\", gnu_name, &gnu_stmt,\n+\t\t\t\t\t\t  gnat_actual);\n+\n+\t      gnu_name = build_compound_expr (gnu_temp_type, gnu_stmt,\n \t\t\t\t\t      gnu_temp);\n \t    }\n \n@@ -4830,8 +4926,16 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t\t     (TREE_OPERAND (TREE_OPERAND (gnu_orig, 1), 1)))\n \t\tgnu_orig = TREE_OPERAND (gnu_orig, 2);\n \n-\t      gnu_stmt\n-\t\t= build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_orig, gnu_temp);\n+\t      if (Present (gnat_smo)\n+\t\t  && Present (Storage_Model_Copy_To (gnat_smo)))\n+\t\tgnu_stmt\n+\t\t  = build_storage_model_store (gnat_smo, gnu_orig,\n+\t\t\t\t\t       gnu_temp,\n+\t\t\t\t\t       TYPE_SIZE_UNIT (gnu_temp_type));\n+\t      else\n+\t\tgnu_stmt\n+\t\t  = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_orig,\n+\t\t\t\t     gnu_temp);\n \t      set_expr_location_from_node (gnu_stmt, gnat_node);\n \n \t      append_to_statement_list (gnu_stmt, &gnu_after_list);\n@@ -4842,12 +4946,19 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       tree gnu_actual = gnu_name;\n \n       /* If atomic access is required for an In or In Out actual parameter,\n-\t build the atomic load.  */\n+\t build the atomic load.  Or else, if storage model access is required,\n+\t build the special load.  */\n       if (is_true_formal_parm\n \t  && !is_by_ref_formal_parm\n-\t  && Ekind (gnat_formal) != E_Out_Parameter\n-\t  && simple_atomic_access_required_p (gnat_actual, &aa_sync))\n-\tgnu_actual = build_atomic_load (gnu_actual, aa_sync);\n+\t  && Ekind (gnat_formal) != E_Out_Parameter)\n+\t{\n+\t  if (simple_atomic_access_required_p (gnat_actual, &aa_sync))\n+\t    gnu_actual = build_atomic_load (gnu_actual, aa_sync);\n+\n+\t  else if (Present (gnat_smo)\n+\t\t   && Present (Storage_Model_Copy_From (gnat_smo)))\n+\t    gnu_actual = build_storage_model_load (gnat_smo, gnu_actual);\n+\t}\n \n       /* If this was a procedure call, we may not have removed any padding.\n \t So do it here for the part we will use as an input, if any.  */\n@@ -5211,6 +5322,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      }\n \n \t    get_atomic_access (gnat_actual, &aa_type, &aa_sync);\n+\t    get_storage_model_access (gnat_actual, &gnat_smo);\n \n \t    /* If an outer atomic access is required for an actual parameter,\n \t       build the load-modify-store sequence.  */\n@@ -5224,6 +5336,13 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      gnu_result\n \t\t= build_atomic_store (gnu_actual, gnu_result, aa_sync);\n \n+\t    /* Or else, if a storage model access is required, build the special\n+\t       store.  */\n+\t    else if (Present (gnat_smo)\n+\t\t     && Present (Storage_Model_Copy_To (gnat_smo)))\n+\t      gnu_result\n+\t\t= build_storage_model_store (gnat_smo, gnu_actual, gnu_result);\n+\n \t    /* Otherwise build a regular assignment.  */\n \t    else\n \t      gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n@@ -5298,6 +5417,11 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      = build_load_modify_store (gnu_target, gnu_call, gnat_node);\n \t  else if (atomic_access == SIMPLE_ATOMIC)\n \t    gnu_call = build_atomic_store (gnu_target, gnu_call, atomic_sync);\n+\t  else if (Present (gnat_storage_model)\n+\t\t   && Present (Storage_Model_Copy_To (gnat_storage_model)))\n+\t    gnu_call\n+\t      = build_storage_model_store (gnat_storage_model, gnu_target,\n+\t\t\t\t\t   gnu_call);\n \t  else\n \t    gnu_call\n \t      = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_call);\n@@ -6104,6 +6228,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   atomic_acces_t aa_type;\n   bool went_into_elab_proc;\n   bool aa_sync;\n+  Entity_Id gnat_smo;\n \n   /* Save node number for error message and set location information.  */\n   if (Sloc (gnat_node) > No_Location)\n@@ -6376,7 +6501,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_result\n \t    = Call_to_gnu (Prefix (Expression (gnat_node)),\n \t\t\t   &gnu_result_type, gnu_result,\n-\t\t\t   NOT_ATOMIC, false);\n+\t\t\t   NOT_ATOMIC, false, Empty);\n \t  break;\n \t}\n \n@@ -6522,15 +6647,25 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t  && !present_in_lhs_or_actual_p (gnat_node))\n \tgnu_result = build_atomic_load (gnu_result, aa_sync);\n+\n+      /* If storage model access is required on the RHS, build the load.  */\n+      else if (storage_model_access_required_p (gnat_node, &gnat_smo)\n+\t       && Present (Storage_Model_Copy_From (gnat_smo))\n+\t       && !present_in_lhs_or_actual_p (gnat_node))\n+\tgnu_result = build_storage_model_load (gnat_smo, gnu_result);\n       break;\n \n     case N_Indexed_Component:\n       {\n-\ttree gnu_array_object = gnat_to_gnu ((Prefix (gnat_node)));\n+\tconst Entity_Id gnat_array_object = Prefix (gnat_node);\n+\ttree gnu_array_object = gnat_to_gnu (gnat_array_object);\n \ttree gnu_type;\n \tint ndim, i;\n \tNode_Id *gnat_expr_array;\n \n+\t/* Get the storage model of the array.  */\n+\tgnat_smo = get_storage_model (gnat_array_object);\n+\n \tgnu_array_object = maybe_padded_object (gnu_array_object);\n \tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n@@ -6582,6 +6717,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t    gnu_result\n \t      = build_binary_op (ARRAY_REF, NULL_TREE, gnu_result, gnu_expr);\n+\n+\t    if (Present (gnat_smo))\n+\t      instantiate_load_in_array_ref (gnu_result, gnat_smo);\n \t  }\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -6590,18 +6728,28 @@ gnat_to_gnu (Node_Id gnat_node)\n \tif (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t    && !present_in_lhs_or_actual_p (gnat_node))\n \t  gnu_result = build_atomic_load (gnu_result, aa_sync);\n+\n+\t/* If storage model access is required on the RHS, build the load.  */\n+\telse if (storage_model_access_required_p (gnat_node, &gnat_smo)\n+\t\t && Present (Storage_Model_Copy_From (gnat_smo))\n+\t\t && !present_in_lhs_or_actual_p (gnat_node))\n+\t  gnu_result = build_storage_model_load (gnat_smo, gnu_result);\n       }\n       break;\n \n     case N_Slice:\n       {\n-\ttree gnu_array_object = gnat_to_gnu (Prefix (gnat_node));\n+\tconst Entity_Id gnat_array_object = Prefix (gnat_node);\n+\ttree gnu_array_object = gnat_to_gnu (gnat_array_object);\n \n-\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\t/* Get the storage model of the array.  */\n+\tgnat_smo = get_storage_model (gnat_array_object);\n \n \tgnu_array_object = maybe_padded_object (gnu_array_object);\n \tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n+\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\n \tgnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n \tgnu_expr = maybe_character_value (gnu_expr);\n \n@@ -6614,6 +6762,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tgnu_result = build_binary_op (ARRAY_RANGE_REF, gnu_result_type,\n \t\t\t\t      gnu_array_object, gnu_expr);\n+\n+\tif (Present (gnat_smo))\n+\t  instantiate_load_in_array_ref (gnu_result, gnat_smo);\n+\n+\t/* If storage model access is required on the RHS, build the load.  */\n+\tif (storage_model_access_required_p (gnat_node, &gnat_smo)\n+\t    && Present (Storage_Model_Copy_From (gnat_smo))\n+\t    && !present_in_lhs_or_actual_p (gnat_node))\n+\t  gnu_result = build_storage_model_load (gnat_smo, gnu_result);\n       }\n       break;\n \n@@ -6691,6 +6848,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \tif (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t    && !present_in_lhs_or_actual_p (gnat_node))\n \t  gnu_result = build_atomic_load (gnu_result, aa_sync);\n+\n+\t/* If storage model access is required on the RHS, build the load.  */\n+\telse if (storage_model_access_required_p (gnat_node, &gnat_smo)\n+\t\t && Present (Storage_Model_Copy_From (gnat_smo))\n+\t\t && !present_in_lhs_or_actual_p (gnat_node))\n+\t  gnu_result = build_storage_model_load (gnat_smo, gnu_result);\n       }\n       break;\n \n@@ -7224,9 +7387,10 @@ gnat_to_gnu (Node_Id gnat_node)\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call)\n \t{\n \t  get_atomic_access (Name (gnat_node), &aa_type, &aa_sync);\n+\t  get_storage_model_access (Name (gnat_node), &gnat_smo);\n \t  gnu_result\n \t    = Call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs,\n-\t\t\t   aa_type, aa_sync);\n+\t\t\t   aa_type, aa_sync, gnat_smo);\n \t}\n \n       /* Otherwise we need to build the assignment statement manually.  */\n@@ -7264,6 +7428,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gigi_checking_assert (!Do_Range_Check (gnat_expr));\n \n \t  get_atomic_access (Name (gnat_node), &aa_type, &aa_sync);\n+\t  get_storage_model_access (Name (gnat_node), &gnat_smo);\n \n \t  /* If an outer atomic access is required on the LHS, build the load-\n \t     modify-store sequence.  */\n@@ -7275,6 +7440,43 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  else if (aa_type == SIMPLE_ATOMIC)\n \t    gnu_result = build_atomic_store (gnu_lhs, gnu_rhs, aa_sync);\n \n+\t  /* Or else, if a storage model access is required, build the special\n+\t     store.  */\n+\t  else if (Present (gnat_smo)\n+\t\t   && Present (Storage_Model_Copy_To (gnat_smo)))\n+\t    {\n+\t      tree t = remove_conversions (gnu_rhs, false);\n+\n+\t      /* If a storage model load is present on the RHS then instantiate\n+\t\t the temporary associated with it now, lest it be of variable\n+\t\t size and thus could not be instantiated by gimplification.  */\n+\t      if (TREE_CODE (t) == LOAD_EXPR)\n+\t\t{\n+\t\t  t = TREE_OPERAND (t, 1);\n+\t\t  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n+\n+\t\t  tree elem\n+\t\t    = build_nonstandard_integer_type (BITS_PER_UNIT, 1);\n+\t\t  tree size = fold_convert (sizetype, CALL_EXPR_ARG (t, 3));\n+\t\t  tree index = build_index_type (size);\n+\t\t  tree temp\n+\t\t    = create_temporary (\"L\", build_array_type (elem, index));\n+\t\t  tree arg = CALL_EXPR_ARG (t, 1);\n+\t\t  CALL_EXPR_ARG (t, 1)\n+\t\t    = build_unary_op (ADDR_EXPR, TREE_TYPE (arg), temp);\n+\n+\t\t  start_stmt_group ();\n+\t\t  add_stmt (t);\n+\t\t  t = build_storage_model_store (gnat_smo, gnu_lhs, temp);\n+\t\t  add_stmt (t);\n+\t\t  gnu_result = end_stmt_group ();\n+\t\t}\n+\n+\t      else\n+\t\tgnu_result\n+\t\t  = build_storage_model_store (gnat_smo, gnu_lhs, gnu_rhs);\n+\t    }\n+\n \t  /* Or else, use memset when the conditions are met.  This has already\n \t     been validated by Aggr_Assignment_OK_For_Backend in the front-end\n \t     and the RHS is thus guaranteed to be of the appropriate form.  */\n@@ -7307,10 +7509,27 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t\t\t gnat_node);\n \t    }\n \n-\t  /* Otherwise build a regular assignment.  */\n \t  else\n-\t    gnu_result\n-\t      = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n+\t    {\n+\t      tree t = remove_conversions (gnu_rhs, false);\n+\n+\t      /* If a storage model load is present on the RHS, then elide the\n+\t\t temporary associated with it.  */\n+\t      if (TREE_CODE (t) == LOAD_EXPR)\n+\t\t{\n+\t\t  gnu_result = TREE_OPERAND (t, 1);\n+\t\t  gcc_assert (TREE_CODE (gnu_result) == CALL_EXPR);\n+\n+\t\t  tree arg = CALL_EXPR_ARG (gnu_result, 1);\n+\t\t  CALL_EXPR_ARG (gnu_result, 1)\n+\t\t    = build_unary_op (ADDR_EXPR, TREE_TYPE (arg), gnu_lhs);\n+\t\t}\n+\n+\t      /* Otherwise build a regular assignment.  */\n+\t      else\n+\t\tgnu_result\n+\t\t  = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n+\t    }\n \n \t  /* If the assignment type is a regular array and the two sides are\n \t     not completely disjoint, play safe and use memmove.  But don't do\n@@ -7624,7 +7843,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n       gnu_result = Call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE,\n-\t\t\t\tNOT_ATOMIC, false);\n+\t\t\t\tNOT_ATOMIC, false, Empty);\n       break;\n \n     /************************/\n@@ -8023,10 +8242,14 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       if (!type_annotate_only)\n \t{\n-\t  tree gnu_ptr, gnu_ptr_type, gnu_obj_type, gnu_actual_obj_type;\n-\n \t  const Entity_Id gnat_desig_type\n \t    = Designated_Type (Underlying_Type (Etype (gnat_temp)));\n+\t  const Entity_Id gnat_pool = Storage_Pool (gnat_node);\n+\t  const bool pool_is_storage_model\n+\t    = Present (gnat_pool)\n+\t      && Has_Storage_Model_Type_Aspect (Etype (gnat_pool))\n+\t      && Present (Storage_Model_Copy_From (gnat_pool));\n+\t  tree gnu_ptr, gnu_ptr_type, gnu_obj_type, gnu_actual_obj_type;\n \n \t  /* Make sure the designated type is complete before dereferencing,\n \t     in case it is a Taft Amendment type.  */\n@@ -8087,12 +8310,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  tree gnu_size = TYPE_SIZE_UNIT (gnu_actual_obj_type);\n \t  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_ptr);\n+\t  if (pool_is_storage_model)\n+\t    gnu_size = INSTANTIATE_LOAD_IN_EXPR (gnu_size, gnat_pool);\n \n \t  gnu_result\n \t      = build_call_alloc_dealloc (gnu_ptr, gnu_size, gnu_obj_type,\n \t\t\t\t\t  Procedure_To_Call (gnat_node),\n-\t\t\t\t\t  Storage_Pool (gnat_node),\n-\t\t\t\t\t  gnat_node);\n+\t\t\t\t\t  gnat_pool, gnat_node);\n \t}\n       break;\n \n@@ -8300,7 +8524,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   && return_type_with_variable_size_p (TREE_TYPE (gnu_result)))\n     ;\n \n-  else if (TREE_CODE (gnu_result) == UNCONSTRAINED_ARRAY_REF\n+  else if (TREE_CODE (TREE_TYPE (gnu_result)) == UNCONSTRAINED_ARRAY_TYPE\n \t   && Present (Parent (gnat_node))\n \t   && Nkind (Parent (gnat_node)) == N_Attribute_Reference\n \t   && lvalue_required_for_attribute_p (Parent (gnat_node)))\n@@ -8739,7 +8963,7 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t avoid blocking concatenation in the caller when it is inlined.  */\n       for (int i = 0; i < call_expr_nargs (expr); i++)\n \t{\n-\t  tree arg = *(CALL_EXPR_ARGP (expr) + i);\n+\t  tree arg = CALL_EXPR_ARG (expr, i);\n \n \t  if (TREE_CODE (arg) == CONSTRUCTOR\n \t      && TREE_CONSTANT (arg)\n@@ -8751,7 +8975,7 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t      if (TREE_CODE (t) == ADDR_EXPR)\n \t\tt = TREE_OPERAND (t, 0);\n \t      if (TREE_CODE (t) != STRING_CST)\n-\t\t*(CALL_EXPR_ARGP (expr) + i) = tree_output_constant_def (arg);\n+\t\tCALL_EXPR_ARG (expr, i) = tree_output_constant_def (arg);\n \t    }\n \t}\n       break;\n@@ -8816,11 +9040,21 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \tTREE_NO_WARNING (expr) = TREE_NO_WARNING (op);\n       break;\n \n-    case UNCONSTRAINED_ARRAY_REF:\n-      /* We should only do this if we are just elaborating for side effects,\n-\t but we can't know that yet.  */\n-      *expr_p = TREE_OPERAND (*expr_p, 0);\n-      return GS_OK;\n+    case LOAD_EXPR:\n+      {\n+\ttree new_var = create_tmp_var (type, \"L\");\n+\tTREE_ADDRESSABLE (new_var) = 1;\n+\n+\ttree init = TREE_OPERAND (expr, 1);\n+\tgcc_assert (TREE_CODE (init) == CALL_EXPR);\n+\ttree arg = CALL_EXPR_ARG (init, 1);\n+\tCALL_EXPR_ARG (init, 1)\n+\t  = build_unary_op (ADDR_EXPR, TREE_TYPE (arg), new_var);\n+\tgimplify_and_add (init, pre_p);\n+\n+\t*expr_p = new_var;\n+\treturn GS_OK;\n+      }\n \n     case VIEW_CONVERT_EXPR:\n       op = TREE_OPERAND (expr, 0);\n@@ -8832,17 +9066,23 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t  && AGGREGATE_TYPE_P (TREE_TYPE (op))\n \t  && !AGGREGATE_TYPE_P (type))\n \t{\n-\t  tree mod, new_var = create_tmp_var_raw (TREE_TYPE (op), \"C\");\n+\t  tree new_var = create_tmp_var_raw (TREE_TYPE (op), \"C\");\n \t  gimple_add_tmp_var (new_var);\n \n-\t  mod = build2 (INIT_EXPR, TREE_TYPE (new_var), new_var, op);\n+\t  tree mod = build2 (INIT_EXPR, TREE_TYPE (new_var), new_var, op);\n \t  gimplify_and_add (mod, pre_p);\n \n \t  TREE_OPERAND (expr, 0) = new_var;\n \t  return GS_OK;\n \t}\n       break;\n \n+    case UNCONSTRAINED_ARRAY_REF:\n+      /* We should only do this if we are just elaborating for side effects,\n+\t but we can't know that yet.  */\n+      *expr_p = TREE_OPERAND (expr, 0);\n+      return GS_OK;\n+\n     default:\n       break;\n     }"}, {"sha": "5942de150b9b3cdcbba4b44d7ca969b4d729b456", "filename": "gcc/ada/gcc-interface/utils.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Futils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Futils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -5256,6 +5256,13 @@ maybe_unconstrained_array (tree exp)\n \t    }\n \t}\n \n+      else if (code == LOAD_EXPR)\n+\t{\n+\t  const Entity_Id gnat_smo = tree_to_shwi (TREE_OPERAND (exp, 1));\n+\t  tree t = maybe_unconstrained_array (TREE_OPERAND (exp, 0));\n+\t  exp = build_storage_model_load (gnat_smo, t);\n+\t}\n+\n       else if (code == NULL_EXPR)\n \texp = build1 (NULL_EXPR,\n \t\t      TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type)))),"}, {"sha": "ef81f8dd56a036345bd598f461c0db4c169cc591", "filename": "gcc/ada/gcc-interface/utils2.cc", "status": "modified", "additions": 277, "deletions": 17, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2401,6 +2401,10 @@ tree\n build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n                  Entity_Id gnat_pool, Node_Id gnat_node, bool ignore_init_type)\n {\n+  const bool pool_is_storage_model\n+    = Present (gnat_pool)\n+      && Has_Storage_Model_Type_Aspect (Etype (gnat_pool))\n+      && Present (Storage_Model_Copy_To (gnat_pool));\n   tree size, storage, storage_deref, storage_init;\n \n   /* If the initializer, if present, is a NULL_EXPR, just return a new one.  */\n@@ -2433,6 +2437,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t\t\t\t\t  get_identifier (\"ALLOC\"), false);\n       tree template_type = TREE_TYPE (TYPE_FIELDS (storage_type));\n       tree storage_ptr_type = build_pointer_type (storage_type);\n+      tree lhs, rhs;\n \n       size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (storage_type),\n \t\t\t\t\t     init);\n@@ -2459,17 +2464,21 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t\t\t\t  build_template (template_type, type, init));\n \t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (storage_type)),\n \t\t\t\t  init);\n-\t  storage_init\n-\t    = build_binary_op (INIT_EXPR, NULL_TREE, storage_deref,\n-\t\t\t       gnat_build_constructor (storage_type, v));\n+\n+\t  lhs = storage_deref;\n+\t  rhs = gnat_build_constructor (storage_type, v);\n \t}\n       else\n-\tstorage_init\n-\t  = build_binary_op (INIT_EXPR, NULL_TREE,\n-\t\t\t     build_component_ref (storage_deref,\n-\t\t\t\t\t\t  TYPE_FIELDS (storage_type),\n-\t\t\t\t\t\t  false),\n-\t\t\t     build_template (template_type, type, NULL_TREE));\n+\t{\n+\t  lhs = build_component_ref (storage_deref, TYPE_FIELDS (storage_type),\n+\t\t\t\t     false);\n+\t  rhs = build_template (template_type, type, NULL_TREE);\n+\t}\n+\n+      if (pool_is_storage_model)\n+\tstorage_init = build_storage_model_store (gnat_pool, lhs, rhs);\n+      else\n+\tstorage_init = build_binary_op (INIT_EXPR, NULL_TREE, lhs, rhs);\n \n       return build2 (COMPOUND_EXPR, result_type,\n \t\t     storage_init, convert (result_type, storage));\n@@ -2509,14 +2518,263 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n       storage = gnat_protect_expr (storage);\n       storage_deref = build_unary_op (INDIRECT_REF, NULL_TREE, storage);\n       TREE_THIS_NOTRAP (storage_deref) = 1;\n-      storage_init\n-\t= build_binary_op (INIT_EXPR, NULL_TREE, storage_deref, init);\n+      if (pool_is_storage_model)\n+\tstorage_init\n+\t  = build_storage_model_store (gnat_pool, storage_deref, init);\n+      else\n+\tstorage_init\n+\t  = build_binary_op (INIT_EXPR, NULL_TREE, storage_deref, init);\n       return build2 (COMPOUND_EXPR, result_type, storage_init, storage);\n     }\n \n   return storage;\n }\n \n+/* Build a call to a copy procedure of a storage model given by an object.\n+   DEST, SRC and SIZE are as for a call to memcpy.  GNAT_SMO is the entity\n+   for the storage model object and COPY_TO says which procedure to use.  */\n+\n+static tree\n+build_storage_model_copy (Entity_Id gnat_smo, tree dest, tree src, tree size,\n+\t\t\t  bool copy_to)\n+{\n+  const Entity_Id gnat_copy_proc\n+    = copy_to\n+      ? Storage_Model_Copy_To (gnat_smo)\n+      : Storage_Model_Copy_From (gnat_smo);\n+  tree gnu_copy_proc = gnat_to_gnu (gnat_copy_proc);\n+  tree gnu_param_type_list = TYPE_ARG_TYPES (TREE_TYPE (gnu_copy_proc));\n+  tree t1 = TREE_VALUE (gnu_param_type_list);\n+  tree t2 = TREE_VALUE (TREE_CHAIN (gnu_param_type_list));\n+  tree t3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (gnu_param_type_list)));\n+  tree t4\n+    = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (gnu_param_type_list))));\n+\n+  return\n+    build_call_n_expr (gnu_copy_proc,\n+\t\t       4,\n+\t\t       build_unary_op (ADDR_EXPR, t1, gnat_to_gnu (gnat_smo)),\n+\t\t       build_unary_op (ADDR_EXPR, t2, dest),\n+\t\t       build_unary_op (ADDR_EXPR, t3, src),\n+\t\t       convert (t4, size));\n+}\n+\n+/* Build a load of SRC using the storage model of GNAT_SMO.  */\n+\n+tree\n+build_storage_model_load (Entity_Id gnat_smo, tree src)\n+{\n+  tree ret = build2 (LOAD_EXPR, TREE_TYPE (src), src, NULL_TREE);\n+\n+  /* Unconstrained array references have no size so we need to store the\n+     storage object model for future processing by the machinery.  */\n+  if (TREE_CODE (src) == UNCONSTRAINED_ARRAY_REF)\n+    TREE_OPERAND (ret, 1) = build_int_cst (integer_type_node, gnat_smo);\n+  else\n+    TREE_OPERAND (ret, 1) = build_storage_model_load (gnat_smo, src, src);\n+\n+  return ret;\n+}\n+\n+/* Build a load of SRC into DEST using the storage model of GNAT_SMO.\n+   If SIZE is specified, use it, otherwise use the size of SRC.  */\n+\n+tree\n+build_storage_model_load (Entity_Id gnat_smo, tree dest, tree src, tree size)\n+{\n+  gcc_assert (TREE_CODE (src) != LOAD_EXPR);\n+\n+  if (!size)\n+    {\n+      size = TYPE_SIZE_UNIT (TREE_TYPE (src));\n+      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, src);\n+      size = INSTANTIATE_LOAD_IN_EXPR (size, gnat_smo);\n+    }\n+\n+  return build_storage_model_copy (gnat_smo, dest, src, size, false);\n+}\n+\n+/* Build a store of SRC into DEST using the storage model of GNAT_SMO.\n+   If SIZE is specified, use it, otherwise use the size of DEST.  */\n+\n+tree\n+build_storage_model_store (Entity_Id gnat_smo, tree dest, tree src, tree size)\n+{\n+  gcc_assert (TREE_CODE (src) != LOAD_EXPR);\n+\n+  if (!size)\n+    {\n+      size = TYPE_SIZE_UNIT (TREE_TYPE (dest));\n+      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, dest);\n+      size = INSTANTIATE_LOAD_IN_EXPR (size, gnat_smo);\n+    }\n+\n+  return build_storage_model_copy (gnat_smo, dest, src, size, true);\n+}\n+\n+/* Given a tree EXP, instantiate occurrences of LOAD_EXPR in it and associate\n+   them with the storage model of GNAT_SMO.  */\n+\n+tree\n+instantiate_load_in_expr (tree exp, Entity_Id gnat_smo)\n+{\n+  const enum tree_code code = TREE_CODE (exp);\n+  tree type = TREE_TYPE (exp);\n+  tree op0, op1, op2, op3;\n+  tree new_tree;\n+\n+  /* We handle TREE_LIST and COMPONENT_REF separately.  */\n+  if (code == TREE_LIST)\n+    {\n+      op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_CHAIN (exp), gnat_smo);\n+      op1 = INSTANTIATE_LOAD_IN_EXPR (TREE_VALUE (exp), gnat_smo);\n+      if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n+\treturn exp;\n+\n+      return tree_cons (TREE_PURPOSE (exp), op1, op0);\n+    }\n+  else if (code == COMPONENT_REF)\n+    {\n+      /* The field.  */\n+      op1 = TREE_OPERAND (exp, 1);\n+\n+      /* If it is a discriminant or equivalent, a LOAD_EXPR is needed.  */\n+      if (DECL_DISCRIMINANT_NUMBER (op1))\n+\treturn build_storage_model_load (gnat_smo, exp);\n+\n+      op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      new_tree = fold_build3 (COMPONENT_REF, type, op0, op1, NULL_TREE);\n+   }\n+  else\n+    switch (TREE_CODE_CLASS (code))\n+      {\n+      case tcc_constant:\n+      case tcc_declaration:\n+\t  return exp;\n+\n+      case tcc_expression:\n+\tif (code == LOAD_EXPR)\n+\t  return exp;\n+\n+\t/* Fall through.  */\n+\n+      case tcc_exceptional:\n+      case tcc_unary:\n+      case tcc_binary:\n+      case tcc_comparison:\n+      case tcc_reference:\n+\tswitch (TREE_CODE_LENGTH (code))\n+\t  {\n+\t  case 0:\n+\t    return exp;\n+\n+\t  case 1:\n+\t    op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+\t    if (op0 == TREE_OPERAND (exp, 0))\n+\t      return exp;\n+\n+\t    new_tree = fold_build1 (code, type, op0);\n+\t    break;\n+\n+\t  case 2:\n+\t    op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+\t    op1 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 1), gnat_smo);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t      return exp;\n+\n+\t    new_tree = fold_build2 (code, type, op0, op1);\n+\t    break;\n+\n+\t  case 3:\n+\t    op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+\t    op1 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 1), gnat_smo);\n+\t    op2 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 2), gnat_smo);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0)\n+\t\t&& op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2))\n+\t      return exp;\n+\n+\t    new_tree = fold_build3 (code, type, op0, op1, op2);\n+\t    break;\n+\n+\t  case 4:\n+\t    op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+\t    op1 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 1), gnat_smo);\n+\t    op2 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 2), gnat_smo);\n+\t    op3 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 3), gnat_smo);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0)\n+\t\t&& op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2)\n+\t\t&& op3 == TREE_OPERAND (exp, 3))\n+\t      return exp;\n+\n+\t    new_tree = fold (build4 (code, type, op0, op1, op2, op3));\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tbreak;\n+\n+      case tcc_vl_exp:\n+\t{\n+\t  gcc_assert (code == CALL_EXPR);\n+\n+\t  const int n = call_expr_nargs (exp);\n+\t  gcc_assert (n > 0);\n+\t  tree *argarray = XALLOCAVEC (tree, n);\n+\t  for (int i = 0; i < n; i++)\n+\t    argarray[i]\n+\t      = INSTANTIATE_LOAD_IN_EXPR (CALL_EXPR_ARG (exp, i), gnat_smo);\n+\n+\t  for (int i = 0; i < n; i++)\n+\t    if (argarray[i] != CALL_EXPR_ARG (exp, i))\n+\t      return build_call_array (type, CALL_EXPR_FN (exp), n, argarray);\n+\n+\t  return exp;\n+\t}\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  TREE_READONLY (new_tree) |= TREE_READONLY (exp);\n+\n+  if (code == INDIRECT_REF || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n+    TREE_THIS_NOTRAP (new_tree) |= TREE_THIS_NOTRAP (exp);\n+\n+  return new_tree;\n+}\n+\n+/* Given an array or slice reference, instantiate occurrences of LOAD_EXPR in\n+   it and associate them with the storage model of GNAT_SMO.  */\n+\n+void\n+instantiate_load_in_array_ref (tree ref, Entity_Id gnat_smo)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n+  tree elem_type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (ref, 0)));\n+\n+  TREE_OPERAND (ref, 2)\n+    = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_MIN_VALUE (domain_type), ref);\n+  TREE_OPERAND (ref, 2)\n+    = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (ref, 2), gnat_smo);\n+\n+  TREE_OPERAND (ref, 3)\n+    = size_binop (EXACT_DIV_EXPR,\n+\t\t  SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (elem_type),\n+\t\t\t\t\t\t  ref),\n+\t\t  size_int (TYPE_ALIGN_UNIT (elem_type)));\n+  TREE_OPERAND (ref, 3)\n+    = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (ref, 3), gnat_smo);\n+}\n+\n /* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Return true if successful.  */\n \n@@ -2816,7 +3074,7 @@ gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, tree *init)\n \t\t  gnat_rewrite_reference (TREE_OPERAND (ref, 0), func, data,\n \t\t\t\t\t  init),\n \t\t  func (TREE_OPERAND (ref, 1), data),\n-\t\t  TREE_OPERAND (ref, 2), NULL_TREE);\n+\t\t  TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n       break;\n \n     case COMPOUND_EXPR:\n@@ -2901,9 +3159,6 @@ get_inner_constant_reference (tree exp)\n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n \t  {\n-\t    if (TREE_OPERAND (exp, 2))\n-\t      return NULL_TREE;\n-\n \t    tree array_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t    if (!TREE_CONSTANT (TREE_OPERAND (exp, 1))\n \t        || !TREE_CONSTANT (TYPE_MIN_VALUE (TYPE_DOMAIN (array_type)))\n@@ -3044,8 +3299,13 @@ gnat_invariant_expr (tree expr)\n \n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n-\t  if (!TREE_CONSTANT (TREE_OPERAND (t, 1)) || TREE_OPERAND (t, 2))\n-\t    return NULL_TREE;\n+\t  {\n+\t    tree array_type = TREE_TYPE (TREE_OPERAND (t, 0));\n+\t    if (!TREE_CONSTANT (TREE_OPERAND (t, 1))\n+\t        || !TREE_CONSTANT (TYPE_MIN_VALUE (TYPE_DOMAIN (array_type)))\n+\t        || !TREE_CONSTANT (TYPE_SIZE_UNIT (TREE_TYPE (array_type))))\n+\t      return NULL_TREE;\n+\t  }\n \t  break;\n \n \tcase BIT_FIELD_REF:"}, {"sha": "e79cdeeacfea6920cbe193991adc784b85957e91", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 122, "deletions": 10, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -3,7 +3,7 @@\n @setfilename gnat_rm.info\n @documentencoding UTF-8\n @ifinfo\n-@*Generated by Sphinx 5.1.1.@*\n+@*Generated by Sphinx 5.2.3.@*\n @end ifinfo\n @settitle GNAT Reference Manual\n @defindex ge\n@@ -19,7 +19,7 @@\n \n @copying\n @quotation\n-GNAT Reference Manual , Sep 23, 2022\n+GNAT Reference Manual , Oct 04, 2022\n \n AdaCore\n \n@@ -5243,14 +5243,14 @@ May reference only one protected component\n \n @item \n May not reference nonconstant entities outside the protected subprogram\n-scope.\n+scope\n \n @item \n May not contain address representation items, allocators, or quantified\n-expressions.\n+expressions\n \n @item \n-May not contain delay, goto, loop, or procedure-call statements.\n+May not contain delay, goto, loop, or procedure-call statements\n \n @item \n May not contain exported and imported entities\n@@ -28734,6 +28734,55 @@ pragma Machine_Attribute (Var, \"strub\");\n --  scrubbing of the stack space used by that subprogram.\n @end example\n \n+Given these declarations, Foo has its type and body modified as\n+follows:\n+\n+@example\n+function Foo (<WaterMark> : in out System.Address) returns Integer\n+is\n+  --  ...\n+begin\n+  <__strub_update> (<WaterMark>);  --  Updates the stack WaterMark.\n+  --  ...\n+end;\n+@end example\n+\n+whereas its callers are modified from:\n+\n+@example\n+X := Foo;\n+@end example\n+\n+to:\n+\n+@example\n+declare\n+  <WaterMark> : System.Address;\n+begin\n+  <__strub_enter> (<WaterMark>);  -- Initialize <WaterMark>.\n+  X := Foo (<WaterMark>);\n+  <__strub_leave> (<WaterMark>);  -- Scrubs stack up to <WaterMark>.\n+end;\n+@end example\n+\n+As for Bar, because it is strubbed in internal mode, its callers are\n+not modified.  Its definition is modified roughly as follows:\n+\n+@example\n+procedure Bar is\n+  <WaterMark> : System.Address;\n+  procedure Strubbed_Bar (<WaterMark> : in out System.Address) is\n+  begin\n+    <__strub_update> (<WaterMark>);  --  Updates the stack WaterMark.\n+    -- original Bar body.\n+  end Strubbed_Bar;\n+begin\n+  <__strub_enter> (<WaterMark>);  -- Initialize <WaterMark>.\n+  Strubbed_Bar (<WaterMark>);\n+  <__strub_leave> (<WaterMark>);  -- Scrubs stack up to <WaterMark>.\n+end Bar;\n+@end example\n+\n There are also @code{-fstrub=`choice'} command-line options to\n control default settings.  For usage and more details on the\n command-line options, on the @code{strub} attribute, and their use with\n@@ -28809,11 +28858,54 @@ activated by a separate command-line option.\n \n The option @code{-fharden-compares} enables hardening of compares\n that compute results stored in variables, adding verification that the\n-reversed compare yields the opposite result.\n+reversed compare yields the opposite result, turning:\n+\n+@example\n+B := X = Y;\n+@end example\n+\n+into:\n+\n+@example\n+B := X = Y;\n+declare\n+  NotB : Boolean := X /= Y; -- Computed independently of B.\n+begin\n+  if B = NotB then\n+    <__builtin_trap>;\n+  end if;\n+end;\n+@end example\n \n The option @code{-fharden-conditional-branches} enables hardening\n of compares that guard conditional branches, adding verification of\n-the reversed compare to both execution paths.\n+the reversed compare to both execution paths, turning:\n+\n+@example\n+if X = Y then\n+  X := Z + 1;\n+else\n+  Y := Z - 1;\n+end if;\n+@end example\n+\n+into:\n+\n+@example\n+if X = Y then\n+  if X /= Y then -- Computed independently of X = Y.\n+    <__builtin_trap>;\n+  end if;\n+  X := Z + 1;\n+else\n+  if X /= Y then -- Computed independently of X = Y.\n+    null;\n+  else\n+    <__builtin_trap>;\n+  end if;\n+  Y := Z - 1;\n+end if;\n+@end example\n \n These transformations are introduced late in the compilation pipeline,\n long after boolean expressions are decomposed into separate compares,\n@@ -28871,17 +28963,37 @@ further remove checks found to be redundant.\n For additional hardening, the @code{hardbool} @code{Machine_Attribute}\n pragma can be used to annotate boolean types with representation\n clauses, so that expressions of such types used as conditions are\n-checked even when compiling with @code{-gnatVT}.\n+checked even when compiling with @code{-gnatVT}:\n \n @example\n pragma Machine_Attribute (HBool, \"hardbool\");\n+\n+function To_Boolean (X : HBool) returns Boolean is (Boolean (X));\n+@end example\n+\n+is compiled roughly like:\n+\n+@example\n+function To_Boolean (X : HBool) returns Boolean is\n+begin\n+  if X not in True | False then\n+    raise Constraint_Error;\n+  elsif X in True then\n+    return True;\n+  else\n+    return False;\n+  end if;\n+end To_Boolean;\n @end example\n \n Note that @code{-gnatVn} will disable even @code{hardbool} testing.\n \n Analogous behavior is available as a GCC extension to the C and\n-Objective C programming languages, through the @code{hardbool} attribute.\n-For usage and more details on that attribute, see @cite{Using the GNU Compiler Collection (GCC)}.\n+Objective C programming languages, through the @code{hardbool} attribute,\n+with the difference that, instead of raising a Constraint_Error\n+exception, when a hardened boolean variable is found to hold a value\n+that stands for neither True nor False, the program traps.  For usage\n+and more details on that attribute, see @cite{Using the GNU Compiler Collection (GCC)}.\n \n @c Control Flow Redundancy:\n "}, {"sha": "6d4ee380b2d80f04065e0a43e8df36e0063e6fa2", "filename": "gcc/ada/libgnat/system-linux-sparc.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Flibgnat%2Fsystem-linux-sparc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Flibgnat%2Fsystem-linux-sparc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-sparc.ads?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -133,6 +133,7 @@ private\n    Stack_Check_Probes        : constant Boolean := True;\n    Stack_Check_Limits        : constant Boolean := False;\n    Support_Aggregates        : constant Boolean := True;\n+   Support_Atomic_Primitives : constant Boolean := True;\n    Support_Composite_Assign  : constant Boolean := True;\n    Support_Composite_Compare : constant Boolean := True;\n    Support_Long_Shifts       : constant Boolean := True;"}, {"sha": "d27d956a1e7dbc525a051348a44a9dc988810a4c", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1454,10 +1454,12 @@ package body Sem_Attr is\n             Subp_Decl := Find_Related_Declaration_Or_Body (Prag);\n          end if;\n \n-         --  'Old objects appear in block statements as part of the expansion\n-         --  of contract wrappers.\n+         --  'Old objects appear in block and extended return statements as\n+         --  part of the expansion of contract wrappers.\n \n-         if Nkind (Subp_Decl) = N_Block_Statement then\n+         if Nkind (Subp_Decl) in N_Block_Statement\n+                               | N_Extended_Return_Statement\n+         then\n             Subp_Decl := Parent (Parent (Subp_Decl));\n          end if;\n "}, {"sha": "6824941fa34998b37e9e822d814543a6417da5c0", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1467,12 +1467,17 @@ package body Sem_Ch4 is\n       end if;\n \n       --  Check the accessibility level for actuals for explicitly aliased\n-      --  formals.\n+      --  formals when a function call appears within a return statement.\n+      --  This is only checked if the enclosing subprogram Comes_From_Source,\n+      --  to avoid issuing errors on calls occurring in wrapper subprograms\n+      --  (for example, where the call is part of an expression of an aspect\n+      --  associated with a wrapper, such as Pre'Class).\n \n       if Nkind (N) = N_Function_Call\n         and then Comes_From_Source (N)\n         and then Present (Nam_Ent)\n         and then In_Return_Value (N)\n+        and then Comes_From_Source (Current_Subprogram)\n       then\n          declare\n             Form : Node_Id;"}, {"sha": "7ad6408af81b3b8507216a235acf2192513b036e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2398,7 +2398,7 @@ package body Sem_Ch6 is\n                            Class_Wide_Type (Etype (First_Formal (Subp))) = Typ)\n                  and then Try_Object_Operation (P)\n                then\n-                  return;\n+                  goto Leave;\n \n                else\n                   Analyze_Call_And_Resolve;"}, {"sha": "f2a5901786538a1981c780ed21735a2cd164b874", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -178,8 +178,6 @@ package body Sem_Ch9 is\n                elsif Nkind (Decl) = N_Subprogram_Declaration\n                  and then\n                    Nkind (Specification (Decl)) = N_Procedure_Specification\n-                 and then\n-                   Present (Parameter_Specifications (Specification (Decl)))\n                then\n                   declare\n                      Par_Specs : constant List_Id   :=\n@@ -455,7 +453,7 @@ package body Sem_Ch9 is\n \n                   --  Goto statements restricted\n \n-                  elsif Kind = N_Goto_Statement then\n+                  elsif Kind in N_Goto_Statement | N_Goto_When_Statement then\n                      if Lock_Free_Given then\n                         Error_Msg_N (\"goto statement not allowed\", N);\n                         return Skip;\n@@ -477,7 +475,7 @@ package body Sem_Ch9 is\n                         --  Prohibit references to non-constant entities\n                         --  outside the protected subprogram scope.\n \n-                        if Ekind (Id) in Assignable_Kind\n+                        if Is_Assignable (Id)\n                           and then not\n                             Scope_Within_Or_Same (Scope (Id), Sub_Id)\n                           and then not\n@@ -487,8 +485,8 @@ package body Sem_Ch9 is\n                         then\n                            if Lock_Free_Given then\n                               Error_Msg_NE\n-                                (\"reference to global variable& not \" &\n-                                 \"allowed\", N, Id);\n+                                (\"reference to global variable& not allowed\",\n+                                 N, Id);\n                               return Skip;\n                            end if;\n "}, {"sha": "f85d0919e7b611b50e15b5f0a00a9c7a7f1e0f64", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -25731,6 +25731,13 @@ package body Sem_Prag is\n                        (\"argument of pragma% must be On/Off or static string \"\n                         & \"expression\", Arg1);\n \n+                  --  Use of pragma Warnings to set warning switches is\n+                  --  ignored in GNATprove mode, as these switches apply to\n+                  --  the compiler only.\n+\n+                  elsif GNATprove_Mode then\n+                     null;\n+\n                   --  One argument string expression case\n \n                   else\n@@ -31608,7 +31615,7 @@ package body Sem_Prag is\n       Pragma_Refined_Depends                => -1,\n       Pragma_Refined_Global                 => -1,\n       Pragma_Refined_Post                   => -1,\n-      Pragma_Refined_State                  => -1,\n+      Pragma_Refined_State                  =>  0,\n       Pragma_Relative_Deadline              =>  0,\n       Pragma_Remote_Access_Type             => -1,\n       Pragma_Remote_Call_Interface          => -1,\n@@ -31713,6 +31720,15 @@ package body Sem_Prag is\n       P := Parent (N);\n \n       if Nkind (P) /= N_Pragma_Argument_Association then\n+\n+         --  References within pragma Refined_State are not significant. They\n+         --  can't be recognized using pragma argument number, because they\n+         --  appear inside refinement clauses that rely on aggregate syntax.\n+\n+         if In_Pragma_Expression (N, Name_Refined_State) then\n+            return True;\n+         end if;\n+\n          return False;\n \n       else"}, {"sha": "25e886e1ca14d3577c39eabf6852aecaee142c03", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -6018,8 +6018,11 @@ package body Sem_Util is\n                Append_New_Elmt (Item_Id, States);\n \n             --  Recursively gather the visible states of a nested package\n+            --  except for nested package renamings.\n \n-            elsif Ekind (Item_Id) = E_Package then\n+            elsif Ekind (Item_Id) = E_Package\n+              and then No (Renamed_Entity (Item_Id))\n+            then\n                Collect_Visible_States (Item_Id, States);\n             end if;\n "}, {"sha": "c23d358e2fbdfb86f8557762d9b36b8c007aeb7f", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -3655,17 +3655,23 @@ package Sem_Util is\n       function Has_Storage_Model_Type_Aspect (Typ : Entity_Id) return Boolean;\n       --  Returns True iff Typ specifies aspect Storage_Model_Type\n \n+      --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n       function Has_Designated_Storage_Model_Aspect\n         (Typ : Entity_Id) return Boolean;\n       --  Returns True iff Typ specifies aspect Designated_Storage_Model\n \n+      --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n       function Storage_Model_Object (Typ : Entity_Id) return Entity_Id;\n       --  Given an access type Typ with aspect Designated_Storage_Model,\n       --  returns the storage-model object associated with that type.\n       --  The object Entity_Ids returned by this function can be passed\n       --  other functions declared in this interface to retrieve operations\n       --  associated with Storage_Model_Type aspect of the object's type.\n \n+      --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n       function Storage_Model_Type (Obj : Entity_Id) return Entity_Id;\n       --  Given an object Obj of a type specifying aspect Storage_Model_Type,\n       --  returns that type.\n@@ -3715,12 +3721,16 @@ package Sem_Util is\n       --  type, returns the procedure specified for the Copy_From choice in\n       --  that aspect; returns Empty if the procedure isn't specified.\n \n+      --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n       function Storage_Model_Copy_To\n         (SM_Obj_Or_Type : Entity_Id) return Entity_Id;\n       --  Given a type with aspect Storage_Model_Type or an object of such a\n       --  type, returns the procedure specified for the Copy_To choice in that\n       --  aspect; returns Empty if the procedure isn't specified.\n \n+      --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n       function Storage_Model_Storage_Size\n         (SM_Obj_Or_Type : Entity_Id) return Entity_Id;\n       --  Given a type with aspect Storage_Model_Type or an object of such a"}, {"sha": "c62837dd854fb4e693eeafea9033b38ca9010b7a", "filename": "gcc/alias.cc", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Falias.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Falias.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -3369,6 +3369,10 @@ memory_modified_in_insn_p (const_rtx mem, const_rtx insn)\n void\n init_alias_analysis (void)\n {\n+  const bool frame_pointer_eliminated\n+    = reload_completed\n+      && !frame_pointer_needed\n+      && targetm.can_eliminate (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM);\n   unsigned int maxreg = max_reg_num ();\n   int changed, pass;\n   int i;\n@@ -3446,12 +3450,8 @@ init_alias_analysis (void)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (static_reg_base_value[i]\n \t    /* Don't treat the hard frame pointer as special if we\n-\t       eliminated the frame pointer to the stack pointer instead.  */\n-\t    && !(i == HARD_FRAME_POINTER_REGNUM\n-\t\t && reload_completed\n-\t\t && !frame_pointer_needed\n-\t\t && targetm.can_eliminate (FRAME_POINTER_REGNUM,\n-\t\t\t\t\t   STACK_POINTER_REGNUM)))\n+\t       eliminated the frame pointer to the stack pointer.  */\n+\t    && !(i == HARD_FRAME_POINTER_REGNUM && frame_pointer_eliminated))\n \t  {\n \t    new_reg_base_value[i] = static_reg_base_value[i];\n \t    bitmap_set_bit (reg_seen, i);\n@@ -3467,10 +3467,15 @@ init_alias_analysis (void)\n \t\t{\n \t\t  rtx note, set;\n \n+\t\t  /* Treat the hard frame pointer as special unless we\n+\t\t     eliminated the frame pointer to the stack pointer.  */\n+\t\t  if (!frame_pointer_eliminated\n+\t\t      && modified_in_p (hard_frame_pointer_rtx, insn))\n+\t\t    continue;\n+\n \t\t  /* If this insn has a noalias note, process it,  Otherwise,\n \t\t     scan for sets.  A simple set will have no side effects\n \t\t     which could change the base value of any other register.  */\n-\n \t\t  if (GET_CODE (PATTERN (insn)) == SET\n \t\t      && REG_NOTES (insn) != 0\n \t\t      && find_reg_note (insn, REG_NOALIAS, NULL_RTX))"}, {"sha": "6e6b056bd0f3b463d361a110376174ef08e9a10d", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,3 +1,300 @@\n+2022-10-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* sm-fd.cc (fd_state_machine::on_open): Transition to \"unchecked\"\n+\twhen the mode is symbolic, rather than just on integer constants.\n+\t(fd_state_machine::check_for_open_fd): Don't complain about\n+\tunchecked values in the start state.\n+\n+2022-10-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* sm-fd.dot: New file.\n+\n+2022-10-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/107349\n+\t* varargs.cc (get_va_copy_arg): Fix the non-pointer case.\n+\n+2022-10-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/107345\n+\t* region-model.cc (region_model::eval_condition_without_cm):\n+\tEnsure that constants are on the right-hand side before checking\n+\tfor them.\n+\n+2022-10-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* engine.cc (impl_region_model_context::get_malloc_map): Replace\n+\twith...\n+\t(impl_region_model_context::get_state_map_by_name): ...this.\n+\t(impl_region_model_context::get_fd_map): Delete.\n+\t(impl_region_model_context::get_taint_map): Delete.\n+\t* exploded-graph.h (impl_region_model_context::get_fd_map):\n+\tDelete.\n+\t(impl_region_model_context::get_malloc_map): Delete.\n+\t(impl_region_model_context::get_taint_map): Delete.\n+\t(impl_region_model_context::get_state_map_by_name): New.\n+\t* region-model.h (region_model_context::get_state_map_by_name):\n+\tNew vfunc.\n+\t(region_model_context::get_fd_map): Convert from vfunc to\n+\tfunction.\n+\t(region_model_context::get_malloc_map): Likewise.\n+\t(region_model_context::get_taint_map): Likewise.\n+\t(noop_region_model_context::get_state_map_by_name): New.\n+\t(noop_region_model_context::get_fd_map): Delete.\n+\t(noop_region_model_context::get_malloc_map): Delete.\n+\t(noop_region_model_context::get_taint_map): Delete.\n+\t(region_model_context_decorator::get_state_map_by_name): New.\n+\t(region_model_context_decorator::get_fd_map): Delete.\n+\t(region_model_context_decorator::get_malloc_map): Delete.\n+\t(region_model_context_decorator::get_taint_map): Delete.\n+\n+2022-10-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/106300\n+\t* engine.cc (impl_region_model_context::get_fd_map): New.\n+\t* exploded-graph.h (impl_region_model_context::get_fd_map): New\n+\tdecl.\n+\t* region-model-impl-calls.cc (region_model::impl_call_pipe): New.\n+\t* region-model.cc (region_model::update_for_int_cst_return): New,\n+\tbased on...\n+\t(region_model::update_for_zero_return): ...this.  Reimplement in\n+\tterms of the former.\n+\t(region_model::on_call_pre): Handle \"pipe\" and \"pipe2\".\n+\t(region_model::on_call_post): Likewise.\n+\t* region-model.h (region_model::impl_call_pipe): New decl.\n+\t(region_model::update_for_int_cst_return): New decl.\n+\t(region_model::mark_as_valid_fd): New decl.\n+\t(region_model_context::get_fd_map): New pure virtual fn.\n+\t(noop_region_model_context::get_fd_map): New.\n+\t(region_model_context_decorator::get_fd_map): New.\n+\t* sm-fd.cc: Include \"analyzer/program-state.h\".\n+\t(fd_state_machine::describe_state_change): Handle transitions from\n+\tstart state to valid states.\n+\t(fd_state_machine::mark_as_valid_fd): New.\n+\t(fd_state_machine::on_stmt): Add missing return for \"creat\".\n+\t(region_model::mark_as_valid_fd): New.\n+\n+2022-10-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/105765\n+\t* varargs.cc (get_BT_VALIST_ARG): Rename to...\n+\t(get_va_copy_arg): ...this, and update logic for determining level\n+\tof indirection of va_copy's argument to use type of argument,\n+\trather than looking at va_list_type_node, to correctly handle\n+\t__builtin_ms_va_copy.\n+\t(get_stateful_BT_VALIST_ARG): Rename to...\n+\t(get_stateful_va_copy_arg): ...this.\n+\t(va_list_state_machine::on_va_copy): Update for renaming.\n+\t(region_model::impl_call_va_copy): Likewise.\n+\n+2022-10-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/107210\n+\t* svalue.cc (constant_svalue::maybe_fold_bits_within): Only\n+\tattempt to extract individual bits when tree_fits_uhwi_p.\n+\n+2022-10-07  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/105783\n+\t* region-model.cc (selftest::get_bit): New function.\n+\t(selftest::test_bits_within_svalue_folding): New.\n+\t(selfftest::analyzer_region_model_cc_tests): Call it.\n+\t* svalue.cc (constant_svalue::maybe_fold_bits_within): Handle the\n+\tcase of extracting a single bit.\n+\n+2022-10-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/107158\n+\t* store.cc (store::replay_call_summary_cluster): Eliminate\n+\tspecial-casing of RK_HEAP_ALLOCATED in favor of sharing code with\n+\tRK_DECL, avoiding an ICE due to attempting to bind a\n+\tcompound_svalue into a binding_cluster when an svalue in the\n+\tsummary cluster converts to a compound_svalue in the caller.\n+\n+2022-10-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* call-summary.cc (call_summary_replay::dump_to_pp): Bulletproof\n+\tagainst NULL caller regions/svalues.\n+\n+2022-10-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* analysis-plan.cc: Simplify includes.\n+\t* analyzer-pass.cc: Likewise.\n+\t* analyzer-selftests.cc: Likewise.\n+\t* analyzer.cc: Likewise.\n+\t* analyzer.h: Add includes of \"json.h\" and \"tristate.h\".\n+\t* call-info.cc: Simplify includes.\n+\t* call-string.cc: Likewise.\n+\t* call-summary.cc: Likewise.\n+\t* checker-path.cc: Likewise.\n+\t* complexity.cc: Likewise.\n+\t* constraint-manager.cc: Likewise.\n+\t* diagnostic-manager.cc: Likewise.\n+\t* engine.cc: Likewise.\n+\t* feasible-graph.cc: Likewise.\n+\t* known-function-manager.cc: Likewise.\n+\t* pending-diagnostic.cc: Likewise.\n+\t* program-point.cc: Likewise.\n+\t* program-state.cc: Likewise.\n+\t* region-model-asm.cc: Likewise.\n+\t* region-model-impl-calls.cc: Likewise.\n+\t* region-model-manager.cc: Likewise.\n+\t* region-model-reachability.cc: Likewise.\n+\t* region-model.cc: Likewise.\n+\t* region-model.h: Include \"selftest.h\".\n+\t* region.cc: Simplify includes.\n+\t* sm-fd.cc: Likewise.\n+\t* sm-file.cc: Likewise.\n+\t* sm-malloc.cc: Likewise.\n+\t* sm-pattern-test.cc: Likewise.\n+\t* sm-sensitive.cc: Likewise.\n+\t* sm-signal.cc: Likewise.\n+\t* sm-taint.cc: Likewise.\n+\t* sm.cc: Likewise.\n+\t* state-purge.cc: Likewise.\n+\t* store.cc: Likewise.\n+\t* store.h: Likewise.\n+\t* supergraph.cc: Likewise.\n+\t* svalue.cc: Likewise.\n+\t* svalue.h: Likewise.\n+\t* trimmed-graph.cc: Likewise.\n+\t* varargs.cc: Likewise.\n+\n+2022-10-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/107060\n+\t* call-summary.cc\n+\t(call_summary_replay::convert_svalue_from_summary_1): Handle NULL\n+\tresults from convert_svalue_from_summary in SK_UNARY_OP and\n+\tSK_BIN_OP.\n+\t* engine.cc (impl_region_model_context::on_unknown_change): Bail\n+\tout on svalues that can't have associated state.\n+\t* region-model-impl-calls.cc\n+\t(region_model::impl_call_analyzer_get_unknown_ptr): New.\n+\t* region-model.cc (region_model::on_stmt_pre): Handle\n+\t\"__analyzer_get_unknown_ptr\".\n+\t* region-model.h\n+\t(region_model::impl_call_analyzer_get_unknown_ptr): New decl.\n+\t* store.cc (store::replay_call_summary_cluster): Avoid trying to\n+\tcreate binding clusters for base regions that shouldn't have them.\n+\n+2022-10-05  Martin Liska  <mliska@suse.cz>\n+\n+\t* call-summary.cc (call_summary_replay::call_summary_replay):\n+\t  Remove unused variable and arguments.\n+\t* call-summary.h: Likewise.\n+\t* engine.cc (exploded_node::on_stmt): Likewise.\n+\t(exploded_node::replay_call_summaries): Likewise.\n+\t(exploded_node::replay_call_summary): Likewise.\n+\t* exploded-graph.h (class exploded_node): Likewise.\n+\n+2022-10-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/107072\n+\t* analyzer-logging.h: Include \"diagnostic-core.h\".\n+\t* analyzer.h: Include \"function.h\".\n+\t(class call_summary): New forward decl.\n+\t(class call_summary_replay): New forward decl.\n+\t(struct per_function_data): New forward decl.\n+\t(struct interesting_t): New forward decl.\n+\t(custom_edge_info::update_state): New vfunc.\n+\t* call-info.cc (custom_edge_info::update_state): New.\n+\t* call-summary.cc: New file.\n+\t* call-summary.h: New file.\n+\t* constraint-manager.cc: Include \"analyzer/call-summary.h\".\n+\t(class replay_fact_visitor): New.\n+\t(constraint_manager::replay_call_summary): New.\n+\t* constraint-manager.h (constraint_manager::replay_call_summary):\n+\tNew.\n+\t* engine.cc: Include \"analyzer/call-summary.h\".\n+\t(exploded_node::on_stmt): Handle call summaries.\n+\t(class call_summary_edge_info): New.\n+\t(exploded_node::replay_call_summaries): New.\n+\t(exploded_node::replay_call_summary): New.\n+\t(per_function_data::~per_function_data): New.\n+\t(per_function_data::add_call_summary): Move here from header and\n+\treimplement.\n+\t(exploded_graph::process_node): Call update_state rather than\n+\tupdate_model when handling bifurcation\n+\t(viz_callgraph_node::dump_dot): Use a regular label rather\n+\tthan an HTML table; add summaries to dump.\n+\t* exploded-graph.h: Include \"alloc-pool.h\", \"fibonacci_heap.h\",\n+\t\"supergraph.h\", \"sbitmap.h\", \"shortest-paths.h\", \"analyzer/sm.h\",\n+\t\"analyzer/program-state.h\", and \"analyzer/diagnostic-manager.h\".\n+\t(exploded_node::replay_call_summaries): New decl.\n+\t(exploded_node::replay_call_summary): New decl.\n+\t(per_function_data::~per_function_data): New decl.\n+\t(per_function_data::add_call_summary): Move implemention from\n+\theader.\n+\t(per_function_data::m_summaries): Update type of element.\n+\t* known-function-manager.h: Include \"analyzer/analyzer-logging.h\".\n+\t* program-point.h: Include \"pretty-print.h\" and\n+\t\"analyzer/call-string.h\".\n+\t* program-state.cc: Include \"analyzer/call-summary.h\".\n+\t(sm_state_map::replay_call_summary): New.\n+\t(program_state::replay_call_summary): New.\n+\t* program-state.h (sm_state_map::replay_call_summary): New decl.\n+\t(program_state::replay_call_summary): New decl.\n+\t* region-model-manager.cc\n+\t(region_model_manager::get_or_create_asm_output_svalue): New\n+\toverload.\n+\t* region-model-manager.h\n+\t(region_model_manager::get_or_create_asm_output_svalue): New\n+\toverload decl.\n+\t* region-model.cc: Include \"analyzer/call-summary.h\".\n+\t(region_model::maybe_update_for_edge): Remove call to\n+\tregion_model::update_for_call_summary on\n+\tSUPEREDGE_INTRAPROCEDURAL_CALL.\n+\t(region_model::update_for_call_summary): Delete.\n+\t(region_model::replay_call_summary): New.\n+\t* region-model.h (region_model::replay_call_summary): New decl.\n+\t(region_model::update_for_call_summary): Delete decl.\n+\t* store.cc: Include \"analyzer/call-summary.h\".\n+\t(store::replay_call_summary): New.\n+\t(store::replay_call_summary_cluster): New.\n+\t* store.h: Include \"tristate.h\".\n+\t(is_a_helper <const ana::concrete_binding *>::test): New.\n+\t(store::replay_call_summary): New decl.\n+\t(store::replay_call_summary_cluster): New decl.\n+\t* supergraph.cc (get_ultimate_function_for_cgraph_edge): Remove\n+\t\"static\" from decl.\n+\t(supergraph_call_edge): Make stmt param const.\n+\t* supergraph.h: Include \"ordered-hash-map.h\", \"cfg.h\",\n+\t\"basic-block.h\", \"gimple.h\", \"gimple-iterator.h\", and \"digraph.h\".\n+\t(supergraph_call_edge): Make stmt param const.\n+\t(get_ultimate_function_for_cgraph_edge): New decl.\n+\t* svalue.cc (compound_svalue::compound_svalue): Assert that we're\n+\tnot nesting compound_svalues.\n+\t* svalue.h: Include \"json.h\", \"analyzer/store.h\", and\n+\t\"analyzer/program-point.h\".\n+\t(asm_output_svalue::get_num_outputs): New accessor.\n+\n+2022-10-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* region-model.h: Include \"analyzer/region-model-manager.h\"\n+\t(class region_model_manager): Move decl to...\n+\t* region-model-manager.h: ...this new file.\n+\n+2022-10-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* region-model-manager.cc\n+\t(region_model_manager::maybe_fold_unaryop): Fold -(-(VAL)) to VAL.\n+\n+2022-10-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* region-model-manager.cc\n+\t(region_model_manager::get_or_create_widening_svalue): Use a\n+\tfunction_point rather than a program_point.\n+\t* region-model.cc (selftest::test_widening_constraints): Likewise.\n+\t* region-model.h\n+\t(region_model_manager::get_or_create_widening_svalue): Likewise.\n+\t(model_merger::get_function_point): New.\n+\t* svalue.cc (svalue::can_merge_p): Use a function_point rather\n+\tthan a program_point.\n+\t(svalue::can_merge_p): Likewise.\n+\t* svalue.h (widening_svalue::key_t): Likewise.\n+\t(widening_svalue::widening_svalue): Likewise.\n+\n 2022-09-12  Martin Liska  <mliska@suse.cz>\n \n \t* region-model.cc (region_model::maybe_complain_about_infoleak):"}, {"sha": "a4a42c5cd3da1a7c962780ae120f8c503b6052de", "filename": "gcc/analyzer/analysis-plan.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalysis-plan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalysis-plan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalysis-plan.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -27,15 +27,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"ipa-utils.h\"\n #include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-core.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/analysis-plan.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n #include \"cgraph.h\"\n-#include \"function.h\"\n #include \"cfg.h\"\n #include \"basic-block.h\"\n #include \"gimple.h\""}, {"sha": "71b540c65183e0b31b35d1428c406ffcc6f08088", "filename": "gcc/analyzer/analyzer-logging.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer-logging.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer-logging.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-logging.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -23,6 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef ANALYZER_LOGGING_H\n #define ANALYZER_LOGGING_H\n \n+#include \"diagnostic-core.h\"\n+\n namespace ana {\n \n /* A logger encapsulates a logging stream: a way to send"}, {"sha": "fc7098ddccb0272b1ea1cc848fa8aa84952c5829", "filename": "gcc/analyzer/analyzer-pass.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer-pass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer-pass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-pass.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -26,7 +26,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"options.h\"\n #include \"tree.h\"\n-#include \"function.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/engine.h\"\n "}, {"sha": "278c245f415ff92c4567e17b62c419465b5622e9", "filename": "gcc/analyzer/analyzer-selftests.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer-selftests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer-selftests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-selftests.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -23,7 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"stringpool.h\"\n-#include \"function.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-selftests.h\"\n "}, {"sha": "8a2a7734f24c4253af1697276f1b72c303538e85", "filename": "gcc/analyzer/analyzer.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -27,7 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"diagnostic.h\"\n #include \"intl.h\"\n-#include \"function.h\"\n #include \"analyzer/analyzer.h\"\n \n #if ENABLE_ANALYZER"}, {"sha": "a2d79e4a59fe0768a064b8d785a441c5f213a85c", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -21,6 +21,10 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_ANALYZER_H\n #define GCC_ANALYZER_ANALYZER_H\n \n+#include \"function.h\"\n+#include \"json.h\"\n+#include \"tristate.h\"\n+\n class graphviz_out;\n \n namespace ana {\n@@ -114,6 +118,10 @@ class state_machine;\n class logger;\n class visitor;\n class known_function_manager;\n+class call_summary;\n+class call_summary_replay;\n+struct per_function_data;\n+struct interesting_t;\n \n /* Forward decls of functions.  */\n \n@@ -263,6 +271,11 @@ class custom_edge_info\n   /* Hook for making .dot label more readable.  */\n   virtual void print (pretty_printer *pp) const = 0;\n \n+  /* Hook for updating STATE when handling bifurcation.  */\n+  virtual bool update_state (program_state *state,\n+\t\t\t     const exploded_edge *eedge,\n+\t\t\t     region_model_context *ctxt) const;\n+\n   /* Hook for updating MODEL within exploded_path::feasible_p\n      and when handling bifurcation.  */\n   virtual bool update_model (region_model *model,"}, {"sha": "56059ac5cf4af2276d7f78ed7621d705c25c6796", "filename": "gcc/analyzer/call-info.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcall-info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcall-info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-info.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -30,11 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n #include \"cgraph.h\"\n #include \"tree-pretty-print.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n-#include \"selftest.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\"\n@@ -56,17 +52,24 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-path.h\"\n #include \"analyzer/checker-path.h\"\n #include \"analyzer/diagnostic-manager.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n-#include \"shortest-paths.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"analyzer/call-info.h\"\n \n #if ENABLE_ANALYZER\n \n namespace ana {\n \n-/* class call_info : public custom_eedge_info_t.  */\n+/* class custom_edge_info.  */\n+\n+bool\n+custom_edge_info::update_state (program_state *state,\n+\t\t\t\tconst exploded_edge *eedge,\n+\t\t\t\tregion_model_context *ctxt) const\n+{\n+  return update_model (state->m_region_model, eedge, ctxt);\n+}\n+\n+/* class call_info : public custom_edge_info.  */\n \n /* Implementation of custom_edge_info::print vfunc for call_info:\n    use get_desc to get a label_text, and print it to PP.  */"}, {"sha": "f0a30d9b2b66df3b67d92d8129d3e729d3d892b5", "filename": "gcc/analyzer/call-string.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcall-string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcall-string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -24,7 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pretty-print.h\"\n #include \"tree.h\"\n #include \"options.h\"\n-#include \"json.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n #include \"cgraph.h\""}, {"sha": "12ef82d18d6c997f1ad105cc8b7115ce44776928", "filename": "gcc/analyzer/call-summary.cc", "status": "added", "additions": 889, "deletions": 0, "changes": 889, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcall-summary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcall-summary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-summary.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -0,0 +1,889 @@\n+/* Classes for working with summaries of function calls.\n+   Copyright (C) 2022 David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tree-dfa.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/call-summary.h\"\n+#include \"analyzer/exploded-graph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class call_summary.  */\n+\n+const program_state &\n+call_summary::get_state () const\n+{\n+  return m_enode->get_state ();\n+}\n+\n+tree\n+call_summary::get_fndecl () const\n+{\n+  return m_enode->get_point ().get_fndecl ();\n+}\n+\n+label_text\n+call_summary::get_desc () const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+\n+  get_user_facing_desc (&pp);\n+  if (flag_analyzer_verbose_edges)\n+    pp_printf (&pp, \" (call summary; EN: %i)\", m_enode->m_index);\n+\n+  return label_text::take (xstrdup (pp_formatted_text (&pp)));\n+}\n+\n+/* Generate a user-facing description of this call summary.c\n+   This has various heuristics for distinguishing between different\n+   summaries.\n+   This will help with debugging, too.  */\n+\n+void\n+call_summary::get_user_facing_desc (pretty_printer *pp) const\n+{\n+  tree fndecl = get_fndecl ();\n+\n+  /* If there are multiple summaries, try to use the return value to\n+     distinguish between them.  */\n+  if (m_per_fn_data->m_summaries.length () > 1)\n+    {\n+      if (tree result = DECL_RESULT (fndecl))\n+\t{\n+\t  const region *result_reg\n+\t    = get_state ().m_region_model->get_lvalue (result, NULL);\n+\t  const svalue *result_sval\n+\t    = get_state ().m_region_model->get_store_value (result_reg, NULL);\n+\t  switch (result_sval->get_kind ())\n+\t    {\n+\t    default:\n+\t      break;\n+\t    case SK_REGION:\n+\t      {\n+\t\tconst region_svalue *region_sval\n+\t\t  = as_a <const region_svalue *> (result_sval);\n+\t\tconst region *pointee_reg = region_sval->get_pointee ();\n+\t\tswitch (pointee_reg->get_kind ())\n+\t\t  {\n+\t\t  default:\n+\t\t    break;\n+\t\t  case RK_HEAP_ALLOCATED:\n+\t\t    pp_printf (pp,\n+\t\t\t       \"when %qE returns pointer\"\n+\t\t\t       \" to heap-allocated buffer\",\n+\t\t\t       fndecl);\n+\t\t    return;\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    case SK_CONSTANT:\n+\t      {\n+\t\tconst constant_svalue *constant_sval\n+\t\t  = as_a <const constant_svalue *> (result_sval);\n+\t\ttree cst = constant_sval->get_constant ();\n+\t\tif (POINTER_TYPE_P (TREE_TYPE (result))\n+\t\t    && zerop (cst))\n+\t\t  pp_printf (pp, \"when %qE returns NULL\", fndecl);\n+\t\telse\n+\t\t  pp_printf (pp, \"when %qE returns %qE\", fndecl, cst);\n+\t\treturn;\n+\t      }\n+\t    }\n+\t}\n+    }\n+\n+  /* Fallback.  */\n+  pp_printf (pp, \"when %qE returns\", fndecl);\n+}\n+\n+/* Dump a multiline representation of this object to PP.  */\n+\n+void\n+call_summary::dump_to_pp (const extrinsic_state &ext_state,\n+\t\t\t  pretty_printer *pp,\n+\t\t\t  bool simple) const\n+{\n+  label_text desc = get_desc ();\n+  pp_printf (pp, \"desc: %qs\", desc.get ());\n+  pp_newline (pp);\n+\n+  get_state ().dump_to_pp (ext_state, simple, true, pp);\n+}\n+\n+/* Dump a multiline representation of this object to FILE.  */\n+\n+void\n+call_summary::dump (const extrinsic_state &ext_state,\n+\t\t    FILE *fp,\n+\t\t    bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = fp;\n+  dump_to_pp (ext_state, &pp, simple);\n+  pp_flush (&pp);\n+}\n+\n+/* Dump a multiline representation of this object to stderr.  */\n+\n+DEBUG_FUNCTION void\n+call_summary::dump (const extrinsic_state &ext_state, bool simple) const\n+{\n+  dump (ext_state, stderr, simple);\n+}\n+\n+/* class call_summary_replay.  */\n+\n+/* call_summary_replay's ctor.\n+   Populate the cache with params for the summary based on\n+   arguments at the caller. */\n+\n+call_summary_replay::call_summary_replay (const call_details &cd,\n+\t\t\t\t\t  function *called_fn,\n+\t\t\t\t\t  call_summary *summary,\n+\t\t\t\t\t  const extrinsic_state &ext_state)\n+: m_cd (cd),\n+  m_summary (summary),\n+  m_ext_state (ext_state)\n+{\n+  region_model_manager *mgr = cd.get_manager ();\n+\n+  // populate params based on args\n+  tree fndecl = called_fn->decl;\n+\n+  /* Get a frame_region for use with respect to the summary.\n+     This will be a top-level frame, since that's what's in\n+     the summary.  */\n+  const frame_region *summary_frame\n+    = mgr->get_frame_region (NULL, called_fn);\n+\n+  unsigned idx = 0;\n+  for (tree iter_parm = DECL_ARGUMENTS (fndecl); iter_parm;\n+       iter_parm = DECL_CHAIN (iter_parm), ++idx)\n+    {\n+      /* If there's a mismatching declaration, the call stmt might\n+\t not have enough args.  Handle this case by leaving the\n+\t rest of the params as uninitialized.  */\n+      if (idx >= cd.num_args ())\n+\tbreak;\n+      const svalue *caller_arg_sval = cd.get_arg_svalue (idx);\n+      tree parm_lval = iter_parm;\n+      if (tree parm_default_ssa = ssa_default_def (called_fn, iter_parm))\n+\tparm_lval = parm_default_ssa;\n+      const region *summary_parm_reg\n+\t= summary_frame->get_region_for_local (mgr, parm_lval, cd.get_ctxt ());\n+      const svalue *summary_initial_parm_reg\n+\t= mgr->get_or_create_initial_value (summary_parm_reg);\n+      add_svalue_mapping (summary_initial_parm_reg, caller_arg_sval);\n+    }\n+\n+  /* Handle any variadic args.  */\n+  unsigned va_arg_idx = 0;\n+  for (; idx < cd.num_args (); idx++, va_arg_idx++)\n+    {\n+      const svalue *caller_arg_sval = cd.get_arg_svalue (idx);\n+      const region *summary_var_arg_reg\n+\t= mgr->get_var_arg_region (summary_frame, va_arg_idx);\n+      const svalue *summary_initial_var_arg_reg\n+\t= mgr->get_or_create_initial_value (summary_var_arg_reg);\n+      add_svalue_mapping (summary_initial_var_arg_reg, caller_arg_sval);\n+    }\n+}\n+\n+/* Try to convert SUMMARY_SVAL in the summary to a corresponding svalue\n+   in the caller, caching the result.\n+\n+   Return NULL if the conversion is not possible.  */\n+\n+const svalue *\n+call_summary_replay::convert_svalue_from_summary (const svalue *summary_sval)\n+{\n+  gcc_assert (summary_sval);\n+\n+  if (const svalue **slot\n+\t= m_map_svalue_from_summary_to_caller.get (summary_sval))\n+    return *slot;\n+\n+  const svalue *caller_sval = convert_svalue_from_summary_1 (summary_sval);\n+\n+  /* Add to cache.  */\n+  add_svalue_mapping (summary_sval, caller_sval);\n+\n+  return caller_sval;\n+}\n+\n+/* Implementation of call_summary_replay::convert_svalue_from_summary.  */\n+\n+const svalue *\n+call_summary_replay::convert_svalue_from_summary_1 (const svalue *summary_sval)\n+{\n+  gcc_assert (summary_sval);\n+\n+  switch (summary_sval->get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case SK_REGION:\n+      {\n+\tconst region_svalue *region_summary_sval\n+\t  = as_a <const region_svalue *> (summary_sval);\n+\tconst region *summary_reg = region_summary_sval->get_pointee ();\n+\tconst region *caller_reg = convert_region_from_summary (summary_reg);\n+\tif (!caller_reg)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\tconst svalue *caller_ptr\n+\t  = mgr->get_ptr_svalue (summary_sval->get_type (),\n+\t\t\t\t caller_reg);\n+\treturn caller_ptr;\n+      }\n+      break;\n+\n+    case SK_CONSTANT:\n+    case SK_PLACEHOLDER:\n+    case SK_POISONED:\n+    case SK_UNKNOWN:\n+      return summary_sval;\n+\n+    case SK_SETJMP:\n+      return NULL; // TODO\n+\n+    case SK_INITIAL:\n+      {\n+\tconst initial_svalue *initial_summary_sval\n+\t  = as_a <const initial_svalue *> (summary_sval);\n+\t/* Params should already be in the cache, courtesy of the ctor.  */\n+\tgcc_assert (!initial_summary_sval->initial_value_of_param_p ());\n+\n+\t/* Initial value of region within the summary is the value of the\n+\t   region at the point of the call.  */\n+\tconst region *summary_reg = initial_summary_sval->get_region ();\n+\tconst region *caller_reg = convert_region_from_summary (summary_reg);\n+\tif (!caller_reg)\n+\t  return NULL;\n+\tconst svalue *caller_sval\n+\t  = m_cd.get_model ()->get_store_value (caller_reg, m_cd.get_ctxt ());\n+\treturn caller_sval;\n+      }\n+      break;\n+    case SK_UNARYOP:\n+      {\n+\tconst unaryop_svalue *unaryop_summary_sval\n+\t  = as_a <const unaryop_svalue *> (summary_sval);\n+\tconst svalue *summary_arg = unaryop_summary_sval->get_arg ();\n+\tconst svalue *caller_arg = convert_svalue_from_summary (summary_arg);\n+\tif (!caller_arg)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_unaryop (summary_sval->get_type (),\n+\t\t\t\t\t   unaryop_summary_sval->get_op (),\n+\t\t\t\t\t   caller_arg);\n+      }\n+      break;\n+    case SK_BINOP:\n+      {\n+\tconst binop_svalue *binop_summary_sval\n+\t  = as_a <const binop_svalue *> (summary_sval);\n+\tconst svalue *summary_arg0 = binop_summary_sval->get_arg0 ();\n+\tconst svalue *caller_arg0 = convert_svalue_from_summary (summary_arg0);\n+\tif (!caller_arg0)\n+\t  return NULL;\n+\tconst svalue *summary_arg1 = binop_summary_sval->get_arg1 ();\n+\tconst svalue *caller_arg1 = convert_svalue_from_summary (summary_arg1);\n+\tif (!caller_arg1)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_binop (summary_sval->get_type (),\n+\t\t\t\t\t binop_summary_sval->get_op (),\n+\t\t\t\t\t caller_arg0,\n+\t\t\t\t\t caller_arg1);\n+      }\n+      break;\n+    case SK_SUB:\n+      {\n+\tconst sub_svalue *sub_summary_sval\n+\t  = as_a <const sub_svalue *> (summary_sval);\n+\tregion_model_manager *mgr = get_manager ();\n+\tconst svalue *summary_parent_sval = sub_summary_sval->get_parent ();\n+\tif (!summary_parent_sval)\n+\t  return NULL;\n+\tconst region *summary_subregion = sub_summary_sval->get_subregion ();\n+\tif (!summary_subregion)\n+\t  return NULL;\n+\treturn mgr->get_or_create_sub_svalue (summary_sval->get_type (),\n+\t\t\t\t\t      summary_parent_sval,\n+\t\t\t\t\t      summary_subregion);\n+      }\n+      break;\n+    case SK_REPEATED:\n+      {\n+\tconst repeated_svalue *repeated_summary_sval\n+\t  = as_a <const repeated_svalue *> (summary_sval);\n+\tconst svalue *summary_outer_size\n+\t  = repeated_summary_sval->get_outer_size ();\n+\tconst svalue *caller_outer_size\n+\t  = convert_svalue_from_summary (summary_outer_size);\n+\tif (!caller_outer_size)\n+\t  return NULL;\n+\tconst svalue *summary_inner_sval\n+\t  = repeated_summary_sval->get_inner_svalue ();\n+\tconst svalue *caller_inner_sval\n+\t  = convert_svalue_from_summary (summary_inner_sval);\n+\tif (!caller_inner_sval)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_repeated_svalue (summary_sval->get_type (),\n+\t\t\t\t\t\t   caller_outer_size,\n+\t\t\t\t\t\t   caller_inner_sval);\n+      }\n+      break;\n+    case SK_BITS_WITHIN:\n+      {\n+\tconst bits_within_svalue *bits_within_summary_sval\n+\t  = as_a <const bits_within_svalue *> (summary_sval);\n+\tconst bit_range &bits = bits_within_summary_sval->get_bits ();\n+\tconst svalue *summary_inner_sval\n+\t  = bits_within_summary_sval->get_inner_svalue ();\n+\tconst svalue *caller_inner_sval\n+\t  = convert_svalue_from_summary (summary_inner_sval);\n+\tif (!caller_inner_sval)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_bits_within (summary_sval->get_type (),\n+\t\t\t\t\t       bits,\n+\t\t\t\t\t       caller_inner_sval);\n+      }\n+      break;\n+    case SK_UNMERGEABLE:\n+      {\n+\tconst unmergeable_svalue *unmergeable_summary_sval\n+\t  = as_a <const unmergeable_svalue *> (summary_sval);\n+\tconst svalue *summary_arg_sval = unmergeable_summary_sval->get_arg ();\n+\tconst svalue *caller_arg_sval\n+\t  = convert_svalue_from_summary (summary_arg_sval);\n+\tif (!caller_arg_sval)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_unmergeable (caller_arg_sval);\n+      }\n+      break;\n+    case SK_WIDENING:\n+      {\n+\tconst widening_svalue *widening_summary_sval\n+\t  = as_a <const widening_svalue *> (summary_sval);\n+\tconst function_point &point = widening_summary_sval->get_point ();\n+\tconst svalue *summary_base_sval\n+\t  = widening_summary_sval->get_base_svalue ();\n+\tconst svalue *caller_base_sval\n+\t  = convert_svalue_from_summary (summary_base_sval);\n+\tif (!(caller_base_sval\n+\t      && caller_base_sval->can_have_associated_state_p ()))\n+\t  return NULL;\n+\tconst svalue *summary_iter_sval\n+\t  = widening_summary_sval->get_iter_svalue ();\n+\tconst svalue *caller_iter_sval\n+\t  = convert_svalue_from_summary (summary_iter_sval);\n+\tif (!(caller_iter_sval\n+\t      && caller_iter_sval->can_have_associated_state_p ()))\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_widening_svalue\n+\t  (summary_iter_sval->get_type (),\n+\t   point,\n+\t   caller_base_sval,\n+\t   caller_iter_sval);\n+      }\n+      break;\n+    case SK_COMPOUND:\n+      {\n+\tconst compound_svalue *compound_summary_sval\n+\t  = as_a <const compound_svalue *> (summary_sval);\n+\tregion_model_manager *mgr = get_manager ();\n+\tstore_manager *store_mgr = mgr->get_store_manager ();\n+\tbinding_map caller_map;\n+\tauto_vec <const binding_key *> summary_keys;\n+\tfor (auto kv : *compound_summary_sval)\n+\t  summary_keys.safe_push (kv.first);\n+\tsummary_keys.qsort (binding_key::cmp_ptrs);\n+\tfor (auto key : summary_keys)\n+\t  {\n+\t    gcc_assert (key->concrete_p ());\n+\t    /* No remapping is needed for concrete binding keys.  */\n+\n+\t    const svalue *bound_summary_sval\n+\t      = compound_summary_sval->get_map ().get (key);\n+\t    const svalue *caller_sval\n+\t      = convert_svalue_from_summary (bound_summary_sval);\n+\t    if (!caller_sval)\n+\t      caller_sval = mgr->get_or_create_unknown_svalue (NULL_TREE);\n+\n+\t    if (const compound_svalue *inner_compound_sval\n+\t\t= caller_sval->dyn_cast_compound_svalue ())\n+\t      {\n+\t\tconst concrete_binding *outer_key\n+\t\t  = as_a <const concrete_binding *> (key);\n+\t\tfor (auto inner_kv : *inner_compound_sval)\n+\t\t  {\n+\t\t    // These should already be mapped to the caller.\n+\t\t    const binding_key *inner_key = inner_kv.first;\n+\t\t    const svalue *inner_sval = inner_kv.second;\n+\t\t    gcc_assert (inner_key->concrete_p ());\n+\t\t    const concrete_binding *concrete_key\n+\t\t      = as_a <const concrete_binding *> (inner_key);\n+\t\t    bit_offset_t effective_start\n+\t\t      = (concrete_key->get_start_bit_offset ()\n+\t\t\t + outer_key->get_start_bit_offset ());\n+\t\t    const concrete_binding *effective_concrete_key\n+\t\t      = store_mgr->get_concrete_binding\n+\t\t\t  (effective_start,\n+\t\t\t   concrete_key->get_size_in_bits ());\n+\t\t    caller_map.put (effective_concrete_key, inner_sval);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      caller_map.put (key, caller_sval);\n+\t  }\n+\treturn mgr->get_or_create_compound_svalue (summary_sval->get_type (),\n+\t\t\t\t\t\t   caller_map);\n+      }\n+      break;\n+    case SK_CONJURED:\n+      {\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_unknown_svalue (summary_sval->get_type ());\n+      }\n+      break;\n+    case SK_ASM_OUTPUT:\n+      {\n+\tconst asm_output_svalue *asm_output_summary_sval\n+\t  = as_a <const asm_output_svalue *> (summary_sval);\n+\tconst char *asm_string = asm_output_summary_sval->get_asm_string ();\n+\tunsigned output_idx = asm_output_summary_sval->get_output_idx ();\n+\tunsigned num_inputs = asm_output_summary_sval->get_num_inputs ();\n+\tunsigned num_outputs = asm_output_summary_sval->get_num_outputs ();\n+\tauto_vec<const svalue *> inputs (num_inputs);\n+\tfor (unsigned idx = 0; idx < num_inputs; idx++)\n+\t  {\n+\t    const svalue *summary_input\n+\t      = asm_output_summary_sval->get_input (idx);\n+\t    const svalue *caller_input\n+\t      = convert_svalue_from_summary (summary_input);\n+\t    if (!caller_input)\n+\t      return NULL;\n+\t    inputs.safe_push (caller_input);\n+\t  }\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_asm_output_svalue (summary_sval->get_type (),\n+\t\t\t\t\t\t     asm_string,\n+\t\t\t\t\t\t     output_idx,\n+\t\t\t\t\t\t     num_outputs,\n+\t\t\t\t\t\t     inputs);\n+      }\n+      break;\n+    case SK_CONST_FN_RESULT:\n+      {\n+\tconst const_fn_result_svalue *const_fn_result_summary_sval\n+\t  = as_a <const const_fn_result_svalue *> (summary_sval);\n+\ttree fndecl = const_fn_result_summary_sval->get_fndecl ();\n+\tunsigned num_inputs = const_fn_result_summary_sval->get_num_inputs ();\n+\tauto_vec<const svalue *> inputs (num_inputs);\n+\tfor (unsigned idx = 0; idx < num_inputs; idx++)\n+\t  {\n+\t    const svalue *summary_input\n+\t      = const_fn_result_summary_sval->get_input (idx);\n+\t    const svalue *caller_input\n+\t      = convert_svalue_from_summary (summary_input);\n+\t    if (!caller_input)\n+\t      return NULL;\n+\t    inputs.safe_push (caller_input);\n+\t  }\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_const_fn_result_svalue\n+\t  (summary_sval->get_type (),\n+\t   fndecl,\n+\t   inputs);\n+      }\n+      break;\n+    }\n+}\n+\n+/* Try to convert SUMMARY_REG in the summary to a corresponding region\n+   in the caller, caching the result.\n+\n+   Return NULL if the conversion is not possible.  */\n+\n+const region *\n+call_summary_replay::convert_region_from_summary (const region *summary_reg)\n+{\n+  gcc_assert (summary_reg);\n+\n+  if (const region **slot\n+\t= m_map_region_from_summary_to_caller.get (summary_reg))\n+    return *slot;\n+\n+  const region *caller_reg = convert_region_from_summary_1 (summary_reg);\n+\n+  /* Add to cache.  */\n+  add_region_mapping (summary_reg, caller_reg);\n+\n+  return caller_reg;\n+}\n+\n+/* Implementation of call_summary_replay::convert_region_from_summary.  */\n+\n+const region *\n+call_summary_replay::convert_region_from_summary_1 (const region *summary_reg)\n+{\n+  gcc_assert (summary_reg);\n+\n+  region_model_manager *mgr = get_manager ();\n+  switch (summary_reg->get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+      /* Top-level regions.  */\n+    case RK_FRAME:\n+    case RK_GLOBALS:\n+    case RK_CODE:\n+    case RK_STACK:\n+    case RK_HEAP:\n+    case RK_ROOT:\n+      /* These should never be pointed to by a region_svalue.  */\n+      gcc_unreachable ();\n+\n+    case RK_FUNCTION:\n+    case RK_LABEL:\n+    case RK_STRING:\n+    case RK_UNKNOWN:\n+      /* We can reuse these regions directly.  */\n+      return summary_reg;\n+\n+    case RK_SYMBOLIC:\n+      {\n+\tconst symbolic_region *summary_symbolic_reg\n+\t  = as_a <const symbolic_region *> (summary_reg);\n+\tconst svalue *summary_ptr_sval = summary_symbolic_reg->get_pointer ();\n+\tconst svalue *caller_ptr_sval\n+\t  = convert_svalue_from_summary (summary_ptr_sval);\n+\tif (!caller_ptr_sval)\n+\t  return NULL;\n+\tconst region *caller_reg\n+\t  = get_caller_model ()->deref_rvalue (caller_ptr_sval,\n+\t\t\t\t\t       NULL_TREE,\n+\t\t\t\t\t       get_ctxt ());\n+\treturn caller_reg;\n+      }\n+      break;\n+\n+    case RK_DECL:\n+      {\n+\tconst decl_region *summary_decl_reg\n+\t  = as_a <const decl_region *> (summary_reg);\n+\ttree decl = summary_decl_reg->get_decl ();\n+\tswitch (TREE_CODE (decl))\n+\t  {\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  case SSA_NAME:\n+\t    /* We don't care about writes to locals within\n+\t       the summary.  */\n+\t    return NULL;\n+\t  case VAR_DECL:\n+\t    /* We don't care about writes to locals within\n+\t       the summary.  */\n+\t    if (is_global_var (decl))\n+\t      /* If it's a global, we can reuse the region directly.  */\n+\t      return summary_reg;\n+\t    else\n+\t      /* Otherwise, we don't care about locals.  */\n+\t      return NULL;\n+\t  case RESULT_DECL:\n+\t    return m_cd.get_lhs_region ();\n+\t  case PARM_DECL:\n+\t    /* Writes (by value) to parms should be visible to the caller.  */\n+\t    return NULL;\n+\t  }\n+      }\n+      break;\n+    case RK_FIELD:\n+      {\n+\tconst field_region *summary_field_reg\n+\t  = as_a <const field_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\ttree field = summary_field_reg->get_field ();\n+\treturn mgr->get_field_region (caller_parent_reg, field);\n+      }\n+      break;\n+    case RK_ELEMENT:\n+      {\n+\tconst element_region *summary_element_reg\n+\t  = as_a <const element_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\tconst svalue *summary_index = summary_element_reg->get_index ();\n+\tconst svalue *caller_index\n+\t  = convert_svalue_from_summary (summary_index);\n+\tif (!caller_index)\n+\t  return NULL;\n+\treturn mgr->get_element_region (caller_parent_reg,\n+\t\t\t\t\tsummary_reg->get_type (),\n+\t\t\t\t\tcaller_index);\n+      }\n+      break;\n+    case RK_OFFSET:\n+      {\n+\tconst offset_region *summary_offset_reg\n+\t  = as_a <const offset_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\tconst svalue *summary_byte_offset\n+\t  = summary_offset_reg->get_byte_offset ();\n+\tconst svalue *caller_byte_offset\n+\t  = convert_svalue_from_summary (summary_byte_offset);\n+\tif (!caller_byte_offset)\n+\t  return NULL;\n+\treturn mgr->get_offset_region (caller_parent_reg,\n+\t\t\t\t       summary_reg->get_type (),\n+\t\t\t\t       caller_byte_offset);\n+      }\n+      break;\n+    case RK_SIZED:\n+      {\n+\tconst sized_region *summary_sized_reg\n+\t  = as_a <const sized_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\tconst svalue *summary_byte_size\n+\t  = summary_sized_reg->get_byte_size_sval (mgr);\n+\tconst svalue *caller_byte_size\n+\t  = convert_svalue_from_summary (summary_byte_size);\n+\tif (!caller_byte_size)\n+\t  return NULL;\n+\treturn mgr->get_sized_region (caller_parent_reg,\n+\t\t\t\t       summary_reg->get_type (),\n+\t\t\t\t       caller_byte_size);\n+      }\n+      break;\n+    case RK_CAST:\n+      {\n+\tconst cast_region *summary_cast_reg\n+\t  = as_a <const cast_region *> (summary_reg);\n+\tconst region *summary_original_reg\n+\t  = summary_cast_reg->get_original_region ();\n+\tconst region *caller_original_reg\n+\t  = convert_region_from_summary (summary_original_reg);\n+\tif (!caller_original_reg)\n+\t  return NULL;\n+\treturn mgr->get_cast_region (caller_original_reg,\n+\t\t\t\t     summary_reg->get_type ());\n+      }\n+      break;\n+    case RK_HEAP_ALLOCATED:\n+      {\n+\t/* If we have a heap-allocated region in the summary, then\n+\t   it was allocated within the callee.\n+\t   Create a new heap-allocated region to summarize this.  */\n+\treturn mgr->create_region_for_heap_alloc ();\n+      }\n+      break;\n+    case RK_ALLOCA:\n+      return NULL;\n+    case RK_BIT_RANGE:\n+      {\n+\tconst bit_range_region *summary_bit_range_reg\n+\t  = as_a <const bit_range_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\tconst bit_range &bits = summary_bit_range_reg->get_bits ();\n+\treturn mgr->get_bit_range (caller_parent_reg,\n+\t\t\t\t   summary_reg->get_type (),\n+\t\t\t\t   bits);\n+      }\n+      break;\n+    case RK_VAR_ARG:\n+      return NULL;\n+    }\n+}\n+\n+/* Try to convert SUMMARY_KEY in the summary to a corresponding binding key\n+   in the caller.\n+\n+   Return NULL if the conversion is not possible.  */\n+\n+const binding_key *\n+call_summary_replay::convert_key_from_summary (const binding_key *summary_key)\n+{\n+  if (summary_key->concrete_p ())\n+    return summary_key;\n+\n+  const symbolic_binding *symbolic_key = (const symbolic_binding *)summary_key;\n+  const region *summary_reg = symbolic_key->get_region ();\n+  const region *caller_reg = convert_region_from_summary (summary_reg);\n+  if (!caller_reg)\n+    return NULL;\n+  region_model_manager *mgr = get_manager ();\n+  store_manager *store_mgr = mgr->get_store_manager ();\n+  return store_mgr->get_symbolic_binding (caller_reg);\n+}\n+\n+/* Record that SUMMARY_SVAL maps to CALLER_SVAL for this replay.  */\n+\n+void\n+call_summary_replay::add_svalue_mapping (const svalue *summary_sval,\n+\t\t\t\t\t const svalue *caller_sval)\n+{\n+  gcc_assert (summary_sval);\n+  // CALLER_SVAL can be NULL\n+  m_map_svalue_from_summary_to_caller.put (summary_sval, caller_sval);\n+}\n+\n+/* Record that SUMMARY_REG maps to CALLER_REG for this replay.  */\n+\n+void\n+call_summary_replay::add_region_mapping (const region *summary_reg,\n+\t\t\t\t\t const region *caller_reg)\n+{\n+  gcc_assert (summary_reg);\n+  // CALLER_REG can be NULL\n+  m_map_region_from_summary_to_caller.put (summary_reg, caller_reg);\n+}\n+\n+/* Dump a multiline representation of this object to PP.  */\n+\n+void\n+call_summary_replay::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  pp_newline (pp);\n+  pp_string (pp, \"CALL DETAILS:\");\n+  pp_newline (pp);\n+  m_cd.dump_to_pp (pp, simple);\n+\n+  pp_newline (pp);\n+  pp_string (pp, \"CALLEE SUMMARY:\");\n+  pp_newline (pp);\n+  m_summary->dump_to_pp (m_ext_state, pp, simple);\n+\n+  /* Current state of caller (could be in mid-update).  */\n+  pp_newline (pp);\n+  pp_string (pp, \"CALLER:\");\n+  pp_newline (pp);\n+  m_cd.get_model ()->dump_to_pp (pp, simple, true);\n+\n+  pp_newline (pp);\n+  pp_string (pp, \"REPLAY STATE:\");\n+  pp_newline (pp);\n+  pp_string (pp, \"svalue mappings from summary to caller:\");\n+  pp_newline (pp);\n+  auto_vec <const svalue *> summary_svals;\n+  for (auto kv : m_map_svalue_from_summary_to_caller)\n+    summary_svals.safe_push (kv.first);\n+  summary_svals.qsort (svalue::cmp_ptr_ptr);\n+  for (auto summary_sval : summary_svals)\n+    {\n+      pp_string (pp, \"sval in summary: \");\n+      summary_sval->dump_to_pp (pp, simple);\n+      pp_newline (pp);\n+\n+      const svalue *caller_sval\n+\t= *((const_cast<svalue_map_t &>\n+\t     (m_map_svalue_from_summary_to_caller)).get (summary_sval));\n+      pp_string (pp, \" sval in caller: \");\n+      caller_sval->dump_to_pp (pp, simple);\n+      pp_newline (pp);\n+    }\n+\n+  pp_newline (pp);\n+  pp_string (pp, \"region mappings from summary to caller:\");\n+  pp_newline (pp);\n+  auto_vec <const region *> summary_regs;\n+  for (auto kv : m_map_region_from_summary_to_caller)\n+    summary_regs.safe_push (kv.first);\n+  summary_regs.qsort (region::cmp_ptr_ptr);\n+  for (auto summary_reg : summary_regs)\n+    {\n+      pp_string (pp, \"reg in summary: \");\n+      if (summary_reg)\n+\tsummary_reg->dump_to_pp (pp, simple);\n+      else\n+\tpp_string (pp, \"(null)\");\n+      pp_newline (pp);\n+\n+      const region *caller_reg\n+\t= *((const_cast<region_map_t &>\n+\t     (m_map_region_from_summary_to_caller)).get (summary_reg));\n+      pp_string (pp, \" reg in caller: \");\n+      if (caller_reg)\n+\tcaller_reg->dump_to_pp (pp, simple);\n+      else\n+\tpp_string (pp, \"(null)\");\n+      pp_newline (pp);\n+    }\n+}\n+\n+/* Dump a multiline representation of this object to FILE.  */\n+\n+void\n+call_summary_replay::dump (FILE *fp, bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = fp;\n+  dump_to_pp (&pp, simple);\n+  pp_flush (&pp);\n+}\n+\n+/* Dump a multiline representation of this object to stderr.  */\n+\n+DEBUG_FUNCTION void\n+call_summary_replay::dump (bool simple) const\n+{\n+  dump (stderr, simple);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "07cd3f53ce60beeb603a365c9d2c4291e9f23506", "filename": "gcc/analyzer/call-summary.h", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcall-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcall-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-summary.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -0,0 +1,117 @@\n+/* Classes for working with summaries of function calls.\n+   Copyright (C) 2022 David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_CALL_SUMMARY_H\n+#define GCC_ANALYZER_CALL_SUMMARY_H\n+\n+namespace ana {\n+\n+/* A class summarizing one particular outcome of a function that\n+   we've already analyzed.\n+   This lets us efficiently replay the analysis when we see calls\n+   to the function, providing an approximation of the behavior of\n+   the function without having to execute within the function itself.  */\n+\n+class call_summary\n+{\n+public:\n+  call_summary (per_function_data *per_fn_data,\n+\t\tconst exploded_node *enode)\n+  : m_per_fn_data (per_fn_data),\n+    m_enode (enode)\n+  {}\n+  const program_state &get_state () const;\n+  tree get_fndecl () const;\n+\n+  label_text get_desc () const;\n+\n+  void dump_to_pp (const extrinsic_state &ext_state,\n+\t\t   pretty_printer *pp,\n+\t\t   bool simple) const;\n+  void dump (const extrinsic_state &ext_state, FILE *fp, bool simple) const;\n+  void dump (const extrinsic_state &ext_state, bool simple) const;\n+\n+private:\n+  void get_user_facing_desc (pretty_printer *pp) const;\n+\n+  per_function_data *const m_per_fn_data;\n+  const exploded_node *const m_enode;\n+};\n+\n+/* A class for handling replaying a specific call summary at\n+   a specific call site.\n+\n+   Supports remapping svalues and regions, e.g. remapping\n+     INIT_VAL(param of callee)\n+   to:\n+     whatever that argument is at the call site.  */\n+\n+class call_summary_replay\n+{\n+public:\n+  call_summary_replay (const call_details &cd,\n+\t\t       function *called_fn,\n+\t\t       call_summary *m_summary,\n+\t\t       const extrinsic_state &ext_state);\n+\n+  const call_details &get_call_details () const { return m_cd; }\n+  const gcall *get_call_stmt () const { return m_cd.get_call_stmt (); }\n+  region_model_manager *get_manager () const { return m_cd.get_manager (); }\n+  store_manager *get_store_manager () const\n+  {\n+    return get_manager ()->get_store_manager ();\n+  }\n+  region_model_context *get_ctxt () const { return m_cd.get_ctxt (); }\n+  region_model *get_caller_model () const { return m_cd.get_model (); }\n+\n+  const svalue *convert_svalue_from_summary (const svalue *);\n+  const region *convert_region_from_summary (const region *);\n+  const binding_key *convert_key_from_summary (const binding_key *);\n+\n+  void add_svalue_mapping (const svalue *summary_sval,\n+\t\t\t   const svalue *caller_sval);\n+  void add_region_mapping (const region *summary_sval,\n+\t\t\t   const region *caller_sval);\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const;\n+  void dump (FILE *fp, bool simple) const;\n+  void dump (bool simple) const;\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (call_summary_replay);\n+\n+  const svalue *convert_svalue_from_summary_1 (const svalue *);\n+  const region *convert_region_from_summary_1 (const region *);\n+\n+  const call_details &m_cd;\n+  call_summary *m_summary;\n+  const extrinsic_state &m_ext_state;\n+\n+  // Mapping from svalues in summary to svalues for callsite:\n+  typedef hash_map <const svalue *, const svalue *> svalue_map_t;\n+  svalue_map_t m_map_svalue_from_summary_to_caller;\n+\n+  // Mapping from regions in summary to regions for callsite:\n+  typedef hash_map <const region *, const region *> region_map_t;\n+  region_map_t m_map_region_from_summary_to_caller;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_CALL_SUMMARY_H */"}, {"sha": "371111b288d9f724af80d9fb9dfa548e01ca77c4", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -28,26 +28,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"gimple-pretty-print.h\"\n #include \"fold-const.h\"\n-#include \"function.h\"\n #include \"diagnostic-path.h\"\n #include \"options.h\"\n #include \"cgraph.h\"\n-#include \"function.h\"\n #include \"cfg.h\"\n #include \"digraph.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n #include \"diagnostic-event-id.h\"\n-#include \"shortest-paths.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n-#include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n-#include \"selftest.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\""}, {"sha": "39fbbc133f44b2affa7a40a0f52d7b15037a290c", "filename": "gcc/analyzer/complexity.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcomplexity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fcomplexity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcomplexity.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -38,11 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"fold-const.h\"\n #include \"tree-pretty-print.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n-#include \"selftest.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"options.h\""}, {"sha": "96ae073841955a98f8a523d959cf531418580576", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -30,8 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest.h\"\n #include \"diagnostic-core.h\"\n #include \"graphviz.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n@@ -41,13 +39,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/supergraph.h\"\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n-#include \"tristate.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/constraint-manager.h\"\n+#include \"analyzer/call-summary.h\"\n #include \"analyzer/analyzer-selftests.h\"\n #include \"tree-pretty-print.h\"\n \n@@ -3043,6 +3041,60 @@ constraint_manager::for_each_fact (fact_visitor *visitor) const\n     }\n }\n \n+/* Subclass of fact_visitor for use by\n+   constraint_manager::replay_call_summary.  */\n+\n+class replay_fact_visitor : public fact_visitor\n+{\n+public:\n+  replay_fact_visitor (call_summary_replay &r,\n+\t\t       constraint_manager *out)\n+  : m_r (r), m_out (out), m_feasible (true)\n+  {}\n+\n+  bool feasible_p () const { return m_feasible; }\n+\n+  void on_fact (const svalue *lhs, enum tree_code code, const svalue *rhs)\n+    final override\n+  {\n+    const svalue *caller_lhs = m_r.convert_svalue_from_summary (lhs);\n+    if (!caller_lhs)\n+      return;\n+    const svalue *caller_rhs = m_r.convert_svalue_from_summary (rhs);\n+    if (!caller_rhs)\n+      return;\n+    if (!m_out->add_constraint (caller_lhs, code, caller_rhs))\n+      m_feasible = false;\n+  }\n+\n+  void on_ranges (const svalue *lhs_sval,\n+\t\t  const bounded_ranges *ranges) final override\n+  {\n+    const svalue *caller_lhs = m_r.convert_svalue_from_summary (lhs_sval);\n+    if (!caller_lhs)\n+      return;\n+    if (!m_out->add_bounded_ranges (caller_lhs, ranges))\n+      m_feasible = false;\n+  }\n+\n+private:\n+  call_summary_replay &m_r;\n+  constraint_manager *m_out;\n+  bool m_feasible;\n+};\n+\n+/* Attempt to use R to replay the constraints from SUMMARY into this object.\n+   Return true if it is feasible.  */\n+\n+bool\n+constraint_manager::replay_call_summary (call_summary_replay &r,\n+\t\t\t\t\t const constraint_manager &summary)\n+{\n+  replay_fact_visitor v (r, this);\n+  summary.for_each_fact (&v);\n+  return v.feasible_p ();\n+}\n+\n /* Assert that this object is valid.  */\n \n void"}, {"sha": "daacaa3e6a4007f688358734f5cd33160b755ff4", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -487,6 +487,9 @@ class constraint_manager\n \n   bounded_ranges_manager *get_range_manager () const;\n \n+  bool replay_call_summary (call_summary_replay &r,\n+\t\t\t    const constraint_manager &summary);\n+\n   auto_delete_vec<equiv_class> m_equiv_classes;\n   auto_vec<constraint> m_constraints;\n   auto_vec<bounded_ranges_constraint> m_bounded_ranges_constraints;"}, {"sha": "695bde5bee1b57d6abb97fe1fb2cd311f319bb82", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -29,15 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"diagnostic-event-id.h\"\n #include \"diagnostic-path.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n-#include \"shortest-paths.h\"\n-#include \"sbitmap.h\"\n #include \"bitmap.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"ordered-hash-map.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\""}, {"sha": "52978dd0d37a96e8f2c3a6e895143604bb2b2011", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 191, "deletions": 47, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -25,20 +25,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"fold-const.h\"\n #include \"gcc-rich-location.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n-#include \"shortest-paths.h\"\n #include \"diagnostic-core.h\"\n #include \"diagnostic-event-id.h\"\n #include \"diagnostic-path.h\"\n #include \"function.h\"\n #include \"pretty-print.h\"\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n-#include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n-#include \"selftest.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/call-string.h\"\n@@ -72,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"tree-dfa.h\"\n #include \"analyzer/known-function-manager.h\"\n+#include \"analyzer/call-summary.h\"\n \n /* For an overview, see gcc/doc/analyzer.texi.  */\n \n@@ -171,6 +166,8 @@ void\n impl_region_model_context::on_unknown_change (const svalue *sval,\n \t\t\t\t\t      bool is_mutable)\n {\n+  if (!sval->can_have_associated_state_p ())\n+    return;\n   for (sm_state_map *smap : m_new_state->m_checker_states)\n     smap->on_unknown_change (sval, is_mutable, m_ext_state);\n }\n@@ -217,35 +214,21 @@ impl_region_model_context::terminate_path ()\n }\n \n bool\n-impl_region_model_context::get_malloc_map (sm_state_map **out_smap,\n-\t\t\t\t\t   const state_machine **out_sm,\n-\t\t\t\t\t   unsigned *out_sm_idx)\n-{\n-  unsigned malloc_sm_idx;\n-  if (!m_ext_state.get_sm_idx_by_name (\"malloc\", &malloc_sm_idx))\n-    return false;\n-\n-  *out_smap = m_new_state->m_checker_states[malloc_sm_idx];\n-  *out_sm = &m_ext_state.get_sm (malloc_sm_idx);\n-  *out_sm_idx = malloc_sm_idx;\n-  return true;\n-}\n-\n-bool\n-impl_region_model_context::get_taint_map (sm_state_map **out_smap,\n-\t\t\t\t\t  const state_machine **out_sm,\n-\t\t\t\t\t  unsigned *out_sm_idx)\n+impl_region_model_context::get_state_map_by_name (const char *name,\n+\t\t\t\t\t\t  sm_state_map **out_smap,\n+\t\t\t\t\t\t  const state_machine **out_sm,\n+\t\t\t\t\t\t  unsigned *out_sm_idx)\n {\n   if (!m_new_state)\n     return false;\n \n-  unsigned taint_sm_idx;\n-  if (!m_ext_state.get_sm_idx_by_name (\"taint\", &taint_sm_idx))\n+  unsigned sm_idx;\n+  if (!m_ext_state.get_sm_idx_by_name (name, &sm_idx))\n     return false;\n \n-  *out_smap = m_new_state->m_checker_states[taint_sm_idx];\n-  *out_sm = &m_ext_state.get_sm (taint_sm_idx);\n-  *out_sm_idx = taint_sm_idx;\n+  *out_smap = m_new_state->m_checker_states[sm_idx];\n+  *out_sm = &m_ext_state.get_sm (sm_idx);\n+  *out_sm_idx = sm_idx;\n   return true;\n }\n \n@@ -1425,6 +1408,25 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t\t\t\t  &old_state, state, uncertainty,\n \t\t\t\t  path_ctxt, stmt);\n \n+  /* Handle call summaries here.  */\n+  if (cgraph_edge *cgedge\n+\t  = supergraph_call_edge (snode->get_function (), stmt))\n+    if (eg.get_analysis_plan ().use_summary_p (cgedge))\n+      {\n+\tfunction *called_fn = get_ultimate_function_for_cgraph_edge (cgedge);\n+\tper_function_data *called_fn_data\n+\t  = eg.get_per_function_data (called_fn);\n+\tif (called_fn_data)\n+\t  return replay_call_summaries (eg,\n+\t\t\t\t\tsnode,\n+\t\t\t\t\tas_a <const gcall *> (stmt),\n+\t\t\t\t\tstate,\n+\t\t\t\t\tpath_ctxt,\n+\t\t\t\t\tcalled_fn,\n+\t\t\t\t\tcalled_fn_data,\n+\t\t\t\t\t&ctxt);\n+      }\n+\n   bool unknown_side_effects = false;\n   bool terminate_path = false;\n \n@@ -1520,6 +1522,140 @@ exploded_node::on_stmt_post (const gimple *stmt,\n     state->m_region_model->on_call_post (call, unknown_side_effects, ctxt);\n }\n \n+/* A concrete call_info subclass representing a replay of a call summary.  */\n+\n+class call_summary_edge_info : public call_info\n+{\n+public:\n+  call_summary_edge_info (const call_details &cd,\n+\t\t\t  function *called_fn,\n+\t\t\t  call_summary *summary,\n+\t\t\t  const extrinsic_state &ext_state)\n+  : call_info (cd),\n+    m_called_fn (called_fn),\n+    m_summary (summary),\n+    m_ext_state (ext_state)\n+  {}\n+\n+  bool update_state (program_state *state,\n+\t\t     const exploded_edge *,\n+\t\t     region_model_context *ctxt) const final override\n+  {\n+    /* Update STATE based on summary_end_state.  */\n+    call_details cd (get_call_details (state->m_region_model, ctxt));\n+    call_summary_replay r (cd, m_called_fn, m_summary, m_ext_state);\n+    const program_state &summary_end_state = m_summary->get_state ();\n+    return state->replay_call_summary (r, summary_end_state);\n+  }\n+\n+  bool update_model (region_model *model,\n+\t\t     const exploded_edge *,\n+\t\t     region_model_context *ctxt) const final override\n+  {\n+    /* Update STATE based on summary_end_state.  */\n+    call_details cd (get_call_details (model, ctxt));\n+    call_summary_replay r (cd, m_called_fn, m_summary, m_ext_state);\n+    const program_state &summary_end_state = m_summary->get_state ();\n+    model->replay_call_summary (r, *summary_end_state.m_region_model);\n+    return true;\n+  }\n+\n+  label_text get_desc (bool /*can_colorize*/) const final override\n+  {\n+    return m_summary->get_desc ();\n+  }\n+\n+private:\n+  function *m_called_fn;\n+  call_summary *m_summary;\n+  const extrinsic_state &m_ext_state;\n+};\n+\n+/* Use PATH_CTXT to bifurcate, which when handled will add custom edges\n+   for a replay of the various feasible summaries in CALLED_FN_DATA.  */\n+\n+exploded_node::on_stmt_flags\n+exploded_node::replay_call_summaries (exploded_graph &eg,\n+\t\t\t\t      const supernode *snode,\n+\t\t\t\t      const gcall *call_stmt,\n+\t\t\t\t      program_state *state,\n+\t\t\t\t      path_context *path_ctxt,\n+\t\t\t\t      function *called_fn,\n+\t\t\t\t      per_function_data *called_fn_data,\n+\t\t\t\t      region_model_context *ctxt)\n+{\n+  logger *logger = eg.get_logger ();\n+  LOG_SCOPE (logger);\n+\n+  gcc_assert (called_fn);\n+  gcc_assert (called_fn_data);\n+\n+  /* Each summary will call bifurcate on the PATH_CTXT.  */\n+  for (auto summary : called_fn_data->m_summaries)\n+    replay_call_summary (eg, snode, call_stmt, state,\n+\t\t\t path_ctxt, called_fn, summary, ctxt);\n+  path_ctxt->terminate_path ();\n+\n+  return on_stmt_flags ();\n+}\n+\n+/* Use PATH_CTXT to bifurcate, which when handled will add a\n+   custom edge for a replay of SUMMARY, if the summary's\n+   conditions are feasible based on the current state.  */\n+\n+void\n+exploded_node::replay_call_summary (exploded_graph &eg,\n+\t\t\t\t    const supernode *snode,\n+\t\t\t\t    const gcall *call_stmt,\n+\t\t\t\t    program_state *old_state,\n+\t\t\t\t    path_context *path_ctxt,\n+\t\t\t\t    function *called_fn,\n+\t\t\t\t    call_summary *summary,\n+\t\t\t\t    region_model_context *ctxt)\n+{\n+  logger *logger = eg.get_logger ();\n+  LOG_SCOPE (logger);\n+  gcc_assert (snode);\n+  gcc_assert (call_stmt);\n+  gcc_assert (old_state);\n+  gcc_assert (called_fn);\n+  gcc_assert (summary);\n+\n+  if (logger)\n+    logger->log (\"using %s as summary for call to %qE from %qE\",\n+\t\t summary->get_desc ().get (),\n+\t\t called_fn->decl,\n+\t\t snode->get_function ()->decl);\n+  const extrinsic_state &ext_state = eg.get_ext_state ();\n+  const program_state &summary_end_state = summary->get_state ();\n+  if (logger)\n+    {\n+      pretty_printer *pp = logger->get_printer ();\n+\n+      logger->start_log_line ();\n+      pp_string (pp, \"callsite state: \");\n+      old_state->dump_to_pp (ext_state, true, false, pp);\n+      logger->end_log_line ();\n+\n+      logger->start_log_line ();\n+      pp_string (pp, \"summary end state: \");\n+      summary_end_state.dump_to_pp (ext_state, true, false, pp);\n+      logger->end_log_line ();\n+    }\n+\n+  program_state new_state (*old_state);\n+\n+  call_details cd (call_stmt, new_state.m_region_model, ctxt);\n+  call_summary_replay r (cd, called_fn, summary, ext_state);\n+\n+  if (path_ctxt)\n+    path_ctxt->bifurcate (new call_summary_edge_info (cd,\n+\t\t\t\t\t\t      called_fn,\n+\t\t\t\t\t\t      summary,\n+\t\t\t\t\t\t      ext_state));\n+}\n+\n+\n /* Consider the effect of following superedge SUCC from this node.\n \n    Return true if it's feasible to follow the edge, or false\n@@ -2115,6 +2251,20 @@ stats::get_total_enodes () const\n   return result;\n }\n \n+/* struct per_function_data.  */\n+\n+per_function_data::~per_function_data ()\n+{\n+  for (auto iter : m_summaries)\n+    delete iter;\n+}\n+\n+void\n+per_function_data::add_call_summary (exploded_node *node)\n+{\n+  m_summaries.safe_push (new call_summary (this, node));\n+}\n+\n /* strongly_connected_components's ctor.  Tarjan's SCC algorithm.  */\n \n strongly_connected_components::\n@@ -3980,7 +4130,7 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\t\tNULL, // uncertainty_t *uncertainty\n \t\t\t\tNULL, // path_context *path_ctxt\n \t\t\t\tstmt);\n-\t    if (edge_info->update_model (bifurcated_new_state.m_region_model,\n+\t    if (edge_info->update_state (&bifurcated_new_state,\n \t\t\t\t\t NULL, /* no exploded_edge yet.  */\n \t\t\t\t\t &bifurcation_ctxt))\n \t      {\n@@ -5350,24 +5500,17 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n     pretty_printer *pp = gv->get_pp ();\n \n     dump_dot_id (pp);\n-    pp_printf (pp, \" [shape=none,margin=0,style=filled,fillcolor=%s,label=<\",\n+    pp_printf (pp, \" [shape=none,margin=0,style=filled,fillcolor=%s,label=\\\"\",\n \t       \"lightgrey\");\n-    pp_string (pp, \"<TABLE BORDER=\\\"0\\\">\");\n     pp_write_text_to_stream (pp);\n \n-    gv->begin_trtd ();\n     pp_printf (pp, \"VCG: %i: %s\", m_index, function_name (m_fun));\n-    gv->end_tdtr ();\n     pp_newline (pp);\n \n-    gv->begin_trtd ();\n     pp_printf (pp, \"supernodes: %i\\n\", m_num_supernodes);\n-    gv->end_tdtr ();\n     pp_newline (pp);\n \n-    gv->begin_trtd ();\n     pp_printf (pp, \"superedges: %i\\n\", m_num_superedges);\n-    gv->end_tdtr ();\n     pp_newline (pp);\n \n     if (args.m_eg)\n@@ -5380,9 +5523,7 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \t    if (enode->get_point ().get_function () == m_fun)\n \t      num_enodes++;\n \t  }\n-\tgv->begin_trtd ();\n \tpp_printf (pp, \"enodes: %i\\n\", num_enodes);\n-\tgv->end_tdtr ();\n \tpp_newline (pp);\n \n \t// TODO: also show the per-callstring breakdown\n@@ -5404,11 +5545,8 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \t      }\n \t    if (num_enodes > 0)\n \t      {\n-\t\tgv->begin_trtd ();\n \t\tcs->print (pp);\n \t\tpp_printf (pp, \": %i\\n\", num_enodes);\n-\t\tpp_write_text_as_html_like_dot_to_stream (pp);\n-\t\tgv->end_tdtr ();\n \t      }\n \t  }\n \n@@ -5417,14 +5555,20 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \tif (data)\n \t  {\n \t    pp_newline (pp);\n-\t    gv->begin_trtd ();\n \t    pp_printf (pp, \"summaries: %i\\n\", data->m_summaries.length ());\n-\t    pp_write_text_as_html_like_dot_to_stream (pp);\n-\t    gv->end_tdtr ();\n+\t    for (auto summary : data->m_summaries)\n+\t      {\n+\t\tpp_printf (pp, \"\\nsummary: %s:\\n\", summary->get_desc ().get ());\n+\t\tconst extrinsic_state &ext_state = args.m_eg->get_ext_state ();\n+\t\tconst program_state &state = summary->get_state ();\n+\t\tstate.dump_to_pp (ext_state, false, true, pp);\n+\t\tpp_newline (pp);\n+\t      }\n \t  }\n       }\n \n-    pp_string (pp, \"</TABLE>>];\\n\\n\");\n+    pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n+    pp_string (pp, \"\\\"];\\n\\n\");\n     pp_flush (pp);\n   }\n "}, {"sha": "5996252f1fbc3aa566c7ecc09586d3c611346b4a", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -21,6 +21,15 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_EXPLODED_GRAPH_H\n #define GCC_ANALYZER_EXPLODED_GRAPH_H\n \n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"shortest-paths.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+\n namespace ana {\n \n /* Concrete implementation of region_model_context, wiring it up to the\n@@ -87,12 +96,10 @@ class impl_region_model_context : public region_model_context\n   {\n     return &m_ext_state;\n   }\n-  bool get_malloc_map (sm_state_map **out_smap,\n-\t\t       const state_machine **out_sm,\n-\t\t       unsigned *out_sm_idx) final override;\n-  bool get_taint_map (sm_state_map **out_smap,\n-\t\t       const state_machine **out_sm,\n-\t\t       unsigned *out_sm_idx) final override;\n+  bool get_state_map_by_name (const char *name,\n+\t\t\t      sm_state_map **out_smap,\n+\t\t\t      const state_machine **out_sm,\n+\t\t\t      unsigned *out_sm_idx) override;\n \n   const gimple *get_stmt () const override { return m_stmt; }\n \n@@ -258,6 +265,23 @@ class exploded_node : public dnode<eg_traits>\n \t\t     bool unknown_side_effects,\n \t\t     region_model_context *ctxt);\n \n+  on_stmt_flags replay_call_summaries (exploded_graph &eg,\n+\t\t\t\t       const supernode *snode,\n+\t\t\t\t       const gcall *call_stmt,\n+\t\t\t\t       program_state *state,\n+\t\t\t\t       path_context *path_ctxt,\n+\t\t\t\t       function *called_fn,\n+\t\t\t\t       per_function_data *called_fn_data,\n+\t\t\t\t       region_model_context *ctxt);\n+  void replay_call_summary (exploded_graph &eg,\n+\t\t\t    const supernode *snode,\n+\t\t\t    const gcall *call_stmt,\n+\t\t\t    program_state *state,\n+\t\t\t    path_context *path_ctxt,\n+\t\t\t    function *called_fn,\n+\t\t\t    call_summary *summary,\n+\t\t\t    region_model_context *ctxt);\n+\n   bool on_edge (exploded_graph &eg,\n \t\tconst superedge *succ,\n \t\tprogram_point *next_point,\n@@ -611,13 +635,11 @@ struct per_call_string_data\n struct per_function_data\n {\n   per_function_data () {}\n+  ~per_function_data ();\n \n-  void add_call_summary (exploded_node *node)\n-  {\n-    m_summaries.safe_push (node);\n-  }\n+  void add_call_summary (exploded_node *node);\n \n-  auto_vec<exploded_node *> m_summaries;\n+  auto_vec<call_summary *> m_summaries;\n };\n \n "}, {"sha": "a946e4c5a35a98c79bfc56d8865972ece3987bfb", "filename": "gcc/analyzer/feasible-graph.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Ffeasible-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Ffeasible-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -29,15 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"diagnostic-event-id.h\"\n #include \"diagnostic-path.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n-#include \"shortest-paths.h\"\n-#include \"sbitmap.h\"\n #include \"bitmap.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"ordered-hash-map.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\""}, {"sha": "48fb005e37e45166e5bf4744e5fd451a4bd4ecda", "filename": "gcc/analyzer/known-function-manager.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fknown-function-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fknown-function-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"function.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-core.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "2b95b7e2589843c6b3b74b2d0303add7416b1a68", "filename": "gcc/analyzer/known-function-manager.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fknown-function-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fknown-function-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_KNOWN_FUNCTION_MANAGER_H\n #define GCC_ANALYZER_KNOWN_FUNCTION_MANAGER_H\n \n+#include \"analyzer/analyzer-logging.h\"\n+\n namespace ana {\n \n class known_function_manager : public log_user"}, {"sha": "50a8afc6afd6f7d5f18f783912fd51e077c237e1", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -24,8 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"intl.h\"\n #include \"diagnostic.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\"\n@@ -34,8 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/diagnostic-manager.h\"\n-#include \"selftest.h\"\n-#include \"tristate.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n@@ -50,10 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/program-state.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n-#include \"shortest-paths.h\"\n-#include \"sbitmap.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"diagnostic-path.h\"\n #include \"analyzer/checker-path.h\""}, {"sha": "cfa4dda14df4a8c169ab061a87f39eecea392557", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -24,7 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"gimple-pretty-print.h\"\n #include \"gcc-rich-location.h\"\n-#include \"json.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n #include \"cgraph.h\"\n@@ -41,14 +40,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n-#include \"tristate.h\"\n #include \"selftest.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/program-state.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/diagnostic-manager.h\""}, {"sha": "f72b86de4eb892b8f934598a9e3eaa609afb2252", "filename": "gcc/analyzer/program-point.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -21,6 +21,9 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_PROGRAM_POINT_H\n #define GCC_ANALYZER_PROGRAM_POINT_H\n \n+#include \"pretty-print.h\"\n+#include \"analyzer/call-string.h\"\n+\n namespace ana {\n \n class exploded_graph;"}, {"sha": "7537dc03e41f72fcdf23b34cb6bf501306ddbfed", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -24,14 +24,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"diagnostic-core.h\"\n #include \"diagnostic.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n-#include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\"\n #include \"analyzer/call-string.h\"\n@@ -40,9 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/region-model.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/constraint-manager.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n-#include \"shortest-paths.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/diagnostic-manager.h\"\n@@ -56,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-state.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"analyzer/state-purge.h\"\n+#include \"analyzer/call-summary.h\"\n #include \"analyzer/analyzer-selftests.h\"\n \n #if ENABLE_ANALYZER\n@@ -743,6 +738,31 @@ program_state::program_state (const extrinsic_state &ext_state)\n     }\n }\n \n+/* Attempt to to use R to replay SUMMARY into this object.\n+   Return true if it is possible.  */\n+\n+bool\n+sm_state_map::replay_call_summary (call_summary_replay &r,\n+\t\t\t\t   const sm_state_map &summary)\n+{\n+  for (auto kv : summary.m_map)\n+    {\n+      const svalue *summary_sval = kv.first;\n+      const svalue *caller_sval = r.convert_svalue_from_summary (summary_sval);\n+      if (!caller_sval)\n+\tcontinue;\n+      const svalue *summary_origin = kv.second.m_origin;\n+      const svalue *caller_origin\n+\t= (summary_origin\n+\t   ? r.convert_svalue_from_summary (summary_origin)\n+\t   : NULL);\n+      // caller_origin can be NULL.\n+      m_map.put (caller_sval, entry_t (kv.second.m_state, caller_origin));\n+    }\n+  m_global_state = summary.m_global_state;\n+  return true;\n+}\n+\n /* program_state's copy ctor.  */\n \n program_state::program_state (const program_state &other)\n@@ -1437,6 +1457,28 @@ program_state::detect_leaks (const program_state &src_state,\n \tdest_state.m_region_model->unset_dynamic_extents (reg);\n }\n \n+/* Attempt to to use R to replay SUMMARY into this object.\n+   Return true if it is possible.  */\n+\n+bool\n+program_state::replay_call_summary (call_summary_replay &r,\n+\t\t\t\t    const program_state &summary)\n+{\n+  if (!m_region_model->replay_call_summary (r, *summary.m_region_model))\n+    return false;\n+\n+  for (unsigned sm_idx = 0; sm_idx < m_checker_states.length (); sm_idx++)\n+    {\n+      const sm_state_map *summary_sm_map = summary.m_checker_states[sm_idx];\n+      m_checker_states[sm_idx]->replay_call_summary (r, *summary_sm_map);\n+    }\n+\n+  if (!summary.m_valid)\n+    m_valid = false;\n+\n+  return true;\n+}\n+\n /* Handle calls to \"__analyzer_dump_state\".  */\n \n void"}, {"sha": "ad40578c7030e96cec44cb664cd8551fa1a8ae4c", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -171,6 +171,9 @@ class sm_state_map\n   static const svalue *\n   canonicalize_svalue (const svalue *sval, const extrinsic_state &ext_state);\n \n+  bool replay_call_summary (call_summary_replay &r,\n+\t\t\t    const sm_state_map &summary);\n+\n private:\n   const state_machine &m_sm;\n   map_t m_map;\n@@ -273,6 +276,9 @@ class program_state\n \t\t\t    const extrinsic_state &ext_state,\n \t\t\t    region_model_context *ctxt);\n \n+  bool replay_call_summary (call_summary_replay &r,\n+\t\t\t    const program_state &summary);\n+\n   void impl_call_analyzer_dump_state (const gcall *call,\n \t\t\t\t      const extrinsic_state &ext_state,\n \t\t\t\t      region_model_context *ctxt);"}, {"sha": "b4c1f9195ec7b8edc8de515e86f6f7c036337304", "filename": "gcc/analyzer/region-model-asm.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-asm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-asm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-asm.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -28,9 +28,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"diagnostic-core.h\"\n #include \"pretty-print.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"options.h\""}, {"sha": "52c4205cbeb52cb0cc54c984e15adafa81ab1309", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 80, "deletions": 7, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -38,18 +38,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"diagnostic-color.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n-#include \"selftest.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n-#include \"cgraph.h\"\n-#include \"cfg.h\"\n-#include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n #include \"sbitmap.h\"\n #include \"analyzer/call-string.h\"\n@@ -374,6 +367,16 @@ region_model::impl_call_analyzer_eval (const gcall *call,\n   warning_at (call->location, 0, \"%s\", t.as_string ());\n }\n \n+/* Handle the on_call_pre part of \"__analyzer_get_unknown_ptr\".  */\n+\n+void\n+region_model::impl_call_analyzer_get_unknown_ptr (const call_details &cd)\n+{\n+  const svalue *ptr_sval\n+    = m_mgr->get_or_create_unknown_svalue (cd.get_lhs_type ());\n+  cd.maybe_set_lhs (ptr_sval);\n+}\n+\n /* Handle the on_call_pre part of \"__builtin_expect\" etc.  */\n \n void\n@@ -560,6 +563,76 @@ region_model::impl_call_memset (const call_details &cd)\n   fill_region (sized_dest_reg, fill_value_u8);\n }\n \n+/* Handle the on_call_post part of \"pipe\".  */\n+\n+void\n+region_model::impl_call_pipe (const call_details &cd)\n+{\n+  class failure : public failed_call_info\n+  {\n+  public:\n+    failure (const call_details &cd) : failed_call_info (cd) {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      /* Return -1; everything else is unchanged.  */\n+      const call_details cd (get_call_details (model, ctxt));\n+      model->update_for_int_cst_return (cd, -1, true);\n+      return true;\n+    }\n+  };\n+\n+  class success : public success_call_info\n+  {\n+  public:\n+    success (const call_details &cd) : success_call_info (cd) {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+\n+      /* Return 0.  */\n+      model->update_for_zero_return (cd, true);\n+\n+      /* Update fd array.  */\n+      region_model_manager *mgr = cd.get_manager ();\n+      tree arr_tree = cd.get_arg_tree (0);\n+      const svalue *arr_sval = cd.get_arg_svalue (0);\n+      for (int idx = 0; idx < 2; idx++)\n+\t{\n+\t  const region *arr_reg\n+\t    = model->deref_rvalue (arr_sval, arr_tree, cd.get_ctxt ());\n+\t  const svalue *idx_sval\n+\t    = mgr->get_or_create_int_cst (integer_type_node, idx);\n+\t  const region *element_reg\n+\t    = mgr->get_element_region (arr_reg, integer_type_node, idx_sval);\n+\t  conjured_purge p (model, cd.get_ctxt ());\n+\t  const svalue *fd_sval\n+\t    = mgr->get_or_create_conjured_svalue (integer_type_node,\n+\t\t\t\t\t\t  cd.get_call_stmt (),\n+\t\t\t\t\t\t  element_reg,\n+\t\t\t\t\t\t  p);\n+\t  model->set_value (element_reg, fd_sval, cd.get_ctxt ());\n+\t  model->mark_as_valid_fd (fd_sval, cd.get_ctxt ());\n+\n+\t}\n+      return true;\n+    }\n+  };\n+\n+  /* Body of region_model::impl_call_pipe.  */\n+  if (cd.get_ctxt ())\n+    {\n+      cd.get_ctxt ()->bifurcate (new failure (cd));\n+      cd.get_ctxt ()->bifurcate (new success (cd));\n+      cd.get_ctxt ()->terminate_path ();\n+    }\n+}\n+\n /* A subclass of pending_diagnostic for complaining about 'putenv'\n    called on an auto var.  */\n "}, {"sha": "f5999e64d016eca3a551a6af3be1eefddee17922", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -38,18 +38,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"fold-const.h\"\n #include \"tree-pretty-print.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n-#include \"selftest.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n-#include \"cgraph.h\"\n-#include \"cfg.h\"\n-#include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n #include \"sbitmap.h\"\n #include \"analyzer/call-string.h\"\n@@ -432,6 +425,17 @@ region_model_manager::maybe_fold_unaryop (tree type, enum tree_code op,\n \t    }\n       }\n       break;\n+    case NEGATE_EXPR:\n+      {\n+\t/* -(-(VAL)) is VAL, for integer types.  */\n+\tif (const unaryop_svalue *unaryop = arg->dyn_cast_unaryop_svalue ())\n+\t  if (unaryop->get_op () == NEGATE_EXPR\n+\t      && type == unaryop->get_type ()\n+\t      && type\n+\t      && INTEGRAL_TYPE_P (type))\n+\t    return unaryop->get_arg ();\n+      }\n+      break;\n     }\n \n   /* Constants.  */\n@@ -1143,10 +1147,11 @@ region_model_manager::get_or_create_unmergeable (const svalue *arg)\n    and ITER_SVAL at POINT, creating it if necessary.  */\n \n const svalue *\n-region_model_manager::get_or_create_widening_svalue (tree type,\n-\t\t\t\t\t\t     const program_point &point,\n-\t\t\t\t\t\t     const svalue *base_sval,\n-\t\t\t\t\t\t     const svalue *iter_sval)\n+region_model_manager::\n+get_or_create_widening_svalue (tree type,\n+\t\t\t       const function_point &point,\n+\t\t\t       const svalue *base_sval,\n+\t\t\t       const svalue *iter_sval)\n {\n   gcc_assert (base_sval->get_kind () != SK_WIDENING);\n   gcc_assert (iter_sval->get_kind () != SK_WIDENING);\n@@ -1263,6 +1268,33 @@ get_or_create_asm_output_svalue (tree type,\n   return asm_output_sval;\n }\n \n+/* Return the svalue * of type TYPE for OUTPUT_IDX of a deterministic\n+   asm stmt with string ASM_STRING with NUM_OUTPUTS outputs, given\n+   INPUTS as inputs.  */\n+\n+const svalue *\n+region_model_manager::\n+get_or_create_asm_output_svalue (tree type,\n+\t\t\t\t const char *asm_string,\n+\t\t\t\t unsigned output_idx,\n+\t\t\t\t unsigned num_outputs,\n+\t\t\t\t const vec<const svalue *> &inputs)\n+{\n+  gcc_assert (inputs.length () <= asm_output_svalue::MAX_INPUTS);\n+\n+  if (const svalue *folded\n+\t= maybe_fold_asm_output_svalue (type, inputs))\n+    return folded;\n+\n+  asm_output_svalue::key_t key (type, asm_string, output_idx, inputs);\n+  if (asm_output_svalue **slot = m_asm_output_values_map.get (key))\n+    return *slot;\n+  asm_output_svalue *asm_output_sval\n+    = new asm_output_svalue (type, asm_string, output_idx, num_outputs, inputs);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (asm_output_sval);\n+  m_asm_output_values_map.put (key, asm_output_sval);\n+  return asm_output_sval;\n+}\n \n /* Return the svalue * of type TYPE for the result of a call to FNDECL\n    with __attribute__((const)), given INPUTS as inputs.  */"}, {"sha": "3d8f76ee24c393c0adfeaa26a4a16a1df3461a11", "filename": "gcc/analyzer/region-model-manager.h", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -0,0 +1,318 @@\n+/* Consolidation of svalues and regions.\n+   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_REGION_MODEL_MANAGER_H\n+#define GCC_ANALYZER_REGION_MODEL_MANAGER_H\n+\n+namespace ana {\n+\n+/* A class responsible for owning and consolidating region and svalue\n+   instances.\n+   region and svalue instances are immutable as far as clients are\n+   concerned, so they are provided as \"const\" ptrs.  */\n+\n+class region_model_manager\n+{\n+public:\n+  region_model_manager (logger *logger = NULL);\n+  ~region_model_manager ();\n+\n+  /* call_string consolidation.  */\n+  const call_string &get_empty_call_string () const\n+  {\n+    return m_empty_call_string;\n+  }\n+\n+  /* svalue consolidation.  */\n+  const svalue *get_or_create_constant_svalue (tree cst_expr);\n+  const svalue *get_or_create_int_cst (tree type, poly_int64);\n+  const svalue *get_or_create_unknown_svalue (tree type);\n+  const svalue *get_or_create_setjmp_svalue (const setjmp_record &r,\n+\t\t\t\t\t     tree type);\n+  const svalue *get_or_create_poisoned_svalue (enum poison_kind kind,\n+\t\t\t\t\t       tree type);\n+  const svalue *get_or_create_initial_value (const region *reg);\n+  const svalue *get_ptr_svalue (tree ptr_type, const region *pointee);\n+  const svalue *get_or_create_unaryop (tree type, enum tree_code op,\n+\t\t\t\t       const svalue *arg);\n+  const svalue *get_or_create_cast (tree type, const svalue *arg);\n+  const svalue *get_or_create_binop (tree type,\n+\t\t\t\t     enum tree_code op,\n+\t\t\t\t     const svalue *arg0, const svalue *arg1);\n+  const svalue *get_or_create_sub_svalue (tree type,\n+\t\t\t\t\t  const svalue *parent_svalue,\n+\t\t\t\t\t  const region *subregion);\n+  const svalue *get_or_create_repeated_svalue (tree type,\n+\t\t\t\t\t       const svalue *outer_size,\n+\t\t\t\t\t       const svalue *inner_svalue);\n+  const svalue *get_or_create_bits_within (tree type,\n+\t\t\t\t\t   const bit_range &bits,\n+\t\t\t\t\t   const svalue *inner_svalue);\n+  const svalue *get_or_create_unmergeable (const svalue *arg);\n+  const svalue *get_or_create_widening_svalue (tree type,\n+\t\t\t\t\t       const function_point &point,\n+\t\t\t\t\t       const svalue *base_svalue,\n+\t\t\t\t\t       const svalue *iter_svalue);\n+  const svalue *get_or_create_compound_svalue (tree type,\n+\t\t\t\t\t       const binding_map &map);\n+  const svalue *get_or_create_conjured_svalue (tree type, const gimple *stmt,\n+\t\t\t\t\t       const region *id_reg,\n+\t\t\t\t\t       const conjured_purge &p);\n+  const svalue *\n+  get_or_create_asm_output_svalue (tree type,\n+\t\t\t\t   const gasm *asm_stmt,\n+\t\t\t\t   unsigned output_idx,\n+\t\t\t\t   const vec<const svalue *> &inputs);\n+  const svalue *\n+  get_or_create_asm_output_svalue (tree type,\n+\t\t\t\t   const char *asm_string,\n+\t\t\t\t   unsigned output_idx,\n+\t\t\t\t   unsigned num_outputs,\n+\t\t\t\t   const vec<const svalue *> &inputs);\n+  const svalue *\n+  get_or_create_const_fn_result_svalue (tree type,\n+\t\t\t\t\ttree fndecl,\n+\t\t\t\t\tconst vec<const svalue *> &inputs);\n+\n+  const svalue *maybe_get_char_from_string_cst (tree string_cst,\n+\t\t\t\t\t\ttree byte_offset_cst);\n+\n+  /* Dynamically-allocated svalue instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  const svalue *create_unique_svalue (tree type);\n+\n+  /* region consolidation.  */\n+  const stack_region * get_stack_region () const { return &m_stack_region; }\n+  const heap_region *get_heap_region () const { return &m_heap_region; }\n+  const code_region *get_code_region () const { return &m_code_region; }\n+  const globals_region *get_globals_region () const\n+  {\n+    return &m_globals_region;\n+  }\n+  const function_region *get_region_for_fndecl (tree fndecl);\n+  const label_region *get_region_for_label (tree label);\n+  const decl_region *get_region_for_global (tree expr);\n+  const region *get_field_region (const region *parent, tree field);\n+  const region *get_element_region (const region *parent,\n+\t\t\t\t    tree element_type,\n+\t\t\t\t    const svalue *index);\n+  const region *get_offset_region (const region *parent,\n+\t\t\t\t   tree type,\n+\t\t\t\t   const svalue *byte_offset);\n+  const region *get_sized_region (const region *parent,\n+\t\t\t\t  tree type,\n+\t\t\t\t  const svalue *byte_size_sval);\n+  const region *get_cast_region (const region *original_region,\n+\t\t\t\t tree type);\n+  const frame_region *get_frame_region (const frame_region *calling_frame,\n+\t\t\t\t\tfunction *fun);\n+  const region *get_symbolic_region (const svalue *sval);\n+  const string_region *get_region_for_string (tree string_cst);\n+  const region *get_bit_range (const region *parent, tree type,\n+\t\t\t       const bit_range &bits);\n+  const var_arg_region *get_var_arg_region (const frame_region *parent,\n+\t\t\t\t\t    unsigned idx);\n+\n+  const region *get_unknown_symbolic_region (tree region_type);\n+\n+  const region *\n+  get_region_for_unexpected_tree_code (region_model_context *ctxt,\n+\t\t\t\t       tree t,\n+\t\t\t\t       const dump_location_t &loc);\n+\n+  unsigned alloc_region_id () { return m_next_region_id++; }\n+\n+  store_manager *get_store_manager () { return &m_store_mgr; }\n+  bounded_ranges_manager *get_range_manager () const { return m_range_mgr; }\n+\n+  known_function_manager *get_known_function_manager ()\n+  {\n+    return &m_known_fn_mgr;\n+  }\n+\n+  /* Dynamically-allocated region instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  const region *create_region_for_heap_alloc ();\n+  const region *create_region_for_alloca (const frame_region *frame);\n+\n+  void log_stats (logger *logger, bool show_objs) const;\n+\n+  void begin_checking_feasibility (void) { m_checking_feasibility = true; }\n+  void end_checking_feasibility (void) { m_checking_feasibility = false; }\n+\n+  logger *get_logger () const { return m_logger; }\n+\n+  void dump_untracked_regions () const;\n+\n+private:\n+  bool too_complex_p (const complexity &c) const;\n+  bool reject_if_too_complex (svalue *sval);\n+\n+  const svalue *maybe_fold_unaryop (tree type, enum tree_code op,\n+\t\t\t\t    const svalue *arg);\n+  const svalue *maybe_fold_binop (tree type, enum tree_code op,\n+\t\t\t\t  const svalue *arg0, const svalue *arg1);\n+  const svalue *maybe_fold_sub_svalue (tree type,\n+\t\t\t\t       const svalue *parent_svalue,\n+\t\t\t\t       const region *subregion);\n+  const svalue *maybe_fold_repeated_svalue (tree type,\n+\t\t\t\t\t    const svalue *outer_size,\n+\t\t\t\t\t    const svalue *inner_svalue);\n+  const svalue *maybe_fold_bits_within_svalue (tree type,\n+\t\t\t\t\t       const bit_range &bits,\n+\t\t\t\t\t       const svalue *inner_svalue);\n+  const svalue *maybe_undo_optimize_bit_field_compare (tree type,\n+\t\t\t\t\t\t       const compound_svalue *compound_sval,\n+\t\t\t\t\t\t       tree cst, const svalue *arg1);\n+  const svalue *maybe_fold_asm_output_svalue (tree type,\n+\t\t\t\t\t      const vec<const svalue *> &inputs);\n+\n+  logger *m_logger;\n+\n+  const call_string m_empty_call_string;\n+\n+  unsigned m_next_region_id;\n+  root_region m_root_region;\n+  stack_region m_stack_region;\n+  heap_region m_heap_region;\n+\n+  /* svalue consolidation.  */\n+  typedef hash_map<tree, constant_svalue *> constants_map_t;\n+  constants_map_t m_constants_map;\n+\n+  typedef hash_map<tree, unknown_svalue *> unknowns_map_t;\n+  unknowns_map_t m_unknowns_map;\n+  const unknown_svalue *m_unknown_NULL;\n+\n+  typedef hash_map<poisoned_svalue::key_t,\n+\t\t   poisoned_svalue *> poisoned_values_map_t;\n+  poisoned_values_map_t m_poisoned_values_map;\n+\n+  typedef hash_map<setjmp_svalue::key_t,\n+\t\t   setjmp_svalue *> setjmp_values_map_t;\n+  setjmp_values_map_t m_setjmp_values_map;\n+\n+  typedef hash_map<const region *, initial_svalue *> initial_values_map_t;\n+  initial_values_map_t m_initial_values_map;\n+\n+  typedef hash_map<region_svalue::key_t, region_svalue *> pointer_values_map_t;\n+  pointer_values_map_t m_pointer_values_map;\n+\n+  typedef hash_map<unaryop_svalue::key_t,\n+\t\t   unaryop_svalue *> unaryop_values_map_t;\n+  unaryop_values_map_t m_unaryop_values_map;\n+\n+  typedef hash_map<binop_svalue::key_t, binop_svalue *> binop_values_map_t;\n+  binop_values_map_t m_binop_values_map;\n+\n+  typedef hash_map<sub_svalue::key_t, sub_svalue *> sub_values_map_t;\n+  sub_values_map_t m_sub_values_map;\n+\n+  typedef hash_map<repeated_svalue::key_t,\n+\t\t   repeated_svalue *> repeated_values_map_t;\n+  repeated_values_map_t m_repeated_values_map;\n+\n+  typedef hash_map<bits_within_svalue::key_t,\n+\t\t   bits_within_svalue *> bits_within_values_map_t;\n+  bits_within_values_map_t m_bits_within_values_map;\n+\n+  typedef hash_map<const svalue *,\n+\t\t   unmergeable_svalue *> unmergeable_values_map_t;\n+  unmergeable_values_map_t m_unmergeable_values_map;\n+\n+  typedef hash_map<widening_svalue::key_t,\n+\t\t   widening_svalue */*,\n+\t\t   widening_svalue::key_t::hash_map_traits*/>\n+    widening_values_map_t;\n+  widening_values_map_t m_widening_values_map;\n+\n+  typedef hash_map<compound_svalue::key_t,\n+\t\t   compound_svalue *> compound_values_map_t;\n+  compound_values_map_t m_compound_values_map;\n+\n+  typedef hash_map<conjured_svalue::key_t,\n+\t\t   conjured_svalue *> conjured_values_map_t;\n+  conjured_values_map_t m_conjured_values_map;\n+\n+  typedef hash_map<asm_output_svalue::key_t,\n+\t\t   asm_output_svalue *> asm_output_values_map_t;\n+  asm_output_values_map_t m_asm_output_values_map;\n+\n+  typedef hash_map<const_fn_result_svalue::key_t,\n+\t\t   const_fn_result_svalue *> const_fn_result_values_map_t;\n+  const_fn_result_values_map_t m_const_fn_result_values_map;\n+\n+  bool m_checking_feasibility;\n+\n+  /* \"Dynamically-allocated\" svalue instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  auto_delete_vec<svalue> m_managed_dynamic_svalues;\n+\n+  /* Maximum complexity of svalues that weren't rejected.  */\n+  complexity m_max_complexity;\n+\n+  /* region consolidation.  */\n+\n+  code_region m_code_region;\n+  typedef hash_map<tree, function_region *> fndecls_map_t;\n+  typedef fndecls_map_t::iterator fndecls_iterator_t;\n+  fndecls_map_t m_fndecls_map;\n+\n+  typedef hash_map<tree, label_region *> labels_map_t;\n+  typedef labels_map_t::iterator labels_iterator_t;\n+  labels_map_t m_labels_map;\n+\n+  globals_region m_globals_region;\n+  typedef hash_map<tree, decl_region *> globals_map_t;\n+  typedef globals_map_t::iterator globals_iterator_t;\n+  globals_map_t m_globals_map;\n+\n+  consolidation_map<field_region> m_field_regions;\n+  consolidation_map<element_region> m_element_regions;\n+  consolidation_map<offset_region> m_offset_regions;\n+  consolidation_map<sized_region> m_sized_regions;\n+  consolidation_map<cast_region> m_cast_regions;\n+  consolidation_map<frame_region> m_frame_regions;\n+  consolidation_map<symbolic_region> m_symbolic_regions;\n+\n+  typedef hash_map<tree, string_region *> string_map_t;\n+  string_map_t m_string_map;\n+\n+  consolidation_map<bit_range_region> m_bit_range_regions;\n+  consolidation_map<var_arg_region> m_var_arg_regions;\n+\n+  store_manager m_store_mgr;\n+\n+  bounded_ranges_manager *m_range_mgr;\n+\n+  known_function_manager m_known_fn_mgr;\n+\n+  /* \"Dynamically-allocated\" region instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  auto_delete_vec<region> m_managed_dynamic_regions;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_REGION_MODEL_MANAGER_H */"}, {"sha": "be1372c9e80045118bb88aba31462c7f2b36c61a", "filename": "gcc/analyzer/region-model-reachability.cc", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -36,23 +36,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"fold-const.h\"\n #include \"tree-pretty-print.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n-#include \"selftest.h\"\n-#include \"function.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n-#include \"cgraph.h\"\n-#include \"cfg.h\"\n-#include \"digraph.h\"\n-#include \"json.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/region-model-reachability.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\"\n \n #if ENABLE_ANALYZER\n "}, {"sha": "7c44fc9e25302b7452b1471e4e5c17fb03d67f2a", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 130, "deletions": 33, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -39,18 +39,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"diagnostic-color.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n #include \"selftest.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n #include \"cgraph.h\"\n #include \"cfg.h\"\n-#include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n #include \"sbitmap.h\"\n #include \"analyzer/call-string.h\"\n@@ -66,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/region-model-reachability.h\"\n #include \"analyzer/analyzer-selftests.h\"\n #include \"analyzer/program-state.h\"\n+#include \"analyzer/call-summary.h\"\n #include \"stor-layout.h\"\n #include \"attribs.h\"\n #include \"tree-object-size.h\"\n@@ -1255,6 +1252,12 @@ region_model::on_stmt_pre (const gimple *stmt,\n \t  {\n \t    /* This is handled elsewhere.  */\n \t  }\n+\telse if (is_special_named_call_p (call, \"__analyzer_get_unknown_ptr\",\n+\t\t\t\t\t  0))\n+\t  {\n+\t    call_details cd (call, this, ctxt);\n+\t    impl_call_analyzer_get_unknown_ptr (cd);\n+\t  }\n \telse\n \t  *out_unknown_side_effects = on_call_pre (call, ctxt,\n \t\t\t\t\t\t   out_terminate_path);\n@@ -1973,23 +1976,36 @@ maybe_get_const_fn_result (const call_details &cd)\n   return sval;\n }\n \n-/* Update this model for an outcome of a call that returns zero.\n+/* Update this model for an outcome of a call that returns a specific\n+   integer constant.\n    If UNMERGEABLE, then make the result unmergeable, e.g. to prevent\n    the state-merger code from merging success and failure outcomes.  */\n \n void\n-region_model::update_for_zero_return (const call_details &cd,\n-\t\t\t\t      bool unmergeable)\n+region_model::update_for_int_cst_return (const call_details &cd,\n+\t\t\t\t\t int retval,\n+\t\t\t\t\t bool unmergeable)\n {\n   if (!cd.get_lhs_type ())\n     return;\n   const svalue *result\n-    = m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+    = m_mgr->get_or_create_int_cst (cd.get_lhs_type (), retval);\n   if (unmergeable)\n     result = m_mgr->get_or_create_unmergeable (result);\n   set_value (cd.get_lhs_region (), result, cd.get_ctxt ());\n }\n \n+/* Update this model for an outcome of a call that returns zero.\n+   If UNMERGEABLE, then make the result unmergeable, e.g. to prevent\n+   the state-merger code from merging success and failure outcomes.  */\n+\n+void\n+region_model::update_for_zero_return (const call_details &cd,\n+\t\t\t\t      bool unmergeable)\n+{\n+  update_for_int_cst_return (cd, 0, unmergeable);\n+}\n+\n /* Update this model for an outcome of a call that returns non-zero.  */\n \n void\n@@ -2299,6 +2315,14 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t  impl_call_memset (cd);\n \t  return false;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"pipe\", call, 1)\n+\t       || is_named_call_p (callee_fndecl, \"pipe2\", call, 2))\n+\t{\n+\t  /* Handle in \"on_call_post\"; bail now so that fd array\n+\t     is left untouched so that we can detect use-of-uninit\n+\t     for the case where the call fails.  */\n+\t  return false;\n+\t}\n       else if (is_named_call_p (callee_fndecl, \"putenv\", call, 1)\n \t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n \t{\n@@ -2379,6 +2403,12 @@ region_model::on_call_post (const gcall *call,\n \t  impl_call_operator_delete (cd);\n \t  return;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"pipe\", call, 1)\n+\t       || is_named_call_p (callee_fndecl, \"pipe2\", call, 2))\n+\t{\n+\t  impl_call_pipe (cd);\n+\t  return;\n+\t}\n       /* Was this fndecl referenced by\n \t __attribute__((malloc(FOO)))?  */\n       if (lookup_attribute (\"*dealloc\", DECL_ATTRIBUTES (callee_fndecl)))\n@@ -4182,10 +4212,19 @@ region_model::eval_condition_without_cm (const svalue *lhs,\n \t/* Otherwise, only known through constraints.  */\n       }\n \n-  /* If we have a pair of constants, compare them.  */\n   if (const constant_svalue *cst_lhs = lhs->dyn_cast_constant_svalue ())\n-    if (const constant_svalue *cst_rhs = rhs->dyn_cast_constant_svalue ())\n-      return constant_svalue::eval_condition (cst_lhs, op, cst_rhs);\n+    {\n+      /* If we have a pair of constants, compare them.  */\n+      if (const constant_svalue *cst_rhs = rhs->dyn_cast_constant_svalue ())\n+\treturn constant_svalue::eval_condition (cst_lhs, op, cst_rhs);\n+      else\n+\t{\n+\t  /* When we have one constant, put it on the RHS.  */\n+\t  std::swap (lhs, rhs);\n+\t  op = swap_tree_comparison (op);\n+\t}\n+    }\n+  gcc_assert (lhs->get_kind () != SK_CONSTANT);\n \n   /* Handle comparison against zero.  */\n   if (const constant_svalue *cst_rhs = rhs->dyn_cast_constant_svalue ())\n@@ -5038,11 +5077,8 @@ region_model::maybe_update_for_edge (const superedge &edge,\n       break;\n \n     case SUPEREDGE_INTRAPROCEDURAL_CALL:\n-      {\n-\tconst callgraph_superedge *cg_sedge\n-\t  = as_a <const callgraph_superedge *> (&edge);\n-\tupdate_for_call_summary (*cg_sedge, ctxt);\n-      }\n+      /* This is a no-op for call summaries; we should already\n+\t have handled the effect of the call summary at the call stmt.  */\n       break;\n     }\n \n@@ -5140,25 +5176,34 @@ region_model::update_for_return_superedge (const return_superedge &return_edge,\n   update_for_return_gcall (call_stmt, ctxt);\n }\n \n-/* Update this region_model with a summary of the effect of calling\n-   and returning from CG_SEDGE.\n+/* Attempt to to use R to replay SUMMARY into this object.\n+   Return true if it is possible.  */\n \n-   TODO: Currently this is extremely simplistic: we merely set the\n-   return value to \"unknown\".  A proper implementation would e.g. update\n-   sm-state, and presumably be reworked to support multiple outcomes.  */\n-\n-void\n-region_model::update_for_call_summary (const callgraph_superedge &cg_sedge,\n-\t\t\t\t       region_model_context *ctxt)\n+bool\n+region_model::replay_call_summary (call_summary_replay &r,\n+\t\t\t\t   const region_model &summary)\n {\n-  /* For now, set any return value to \"unknown\".  */\n-  const gcall *call_stmt = cg_sedge.get_call_stmt ();\n-  tree lhs = gimple_call_lhs (call_stmt);\n-  if (lhs)\n-    mark_region_as_unknown (get_lvalue (lhs, ctxt),\n-\t\t\t    ctxt ? ctxt->get_uncertainty () : NULL);\n+  gcc_assert (summary.get_stack_depth () == 1);\n+\n+  m_store.replay_call_summary (r, summary.m_store);\n+\n+  if (!m_constraints->replay_call_summary (r, *summary.m_constraints))\n+    return false;\n+\n+  for (auto kv : summary.m_dynamic_extents)\n+    {\n+      const region *summary_reg = kv.first;\n+      const region *caller_reg = r.convert_region_from_summary (summary_reg);\n+      if (!caller_reg)\n+\tcontinue;\n+      const svalue *summary_sval = kv.second;\n+      const svalue *caller_sval = r.convert_svalue_from_summary (summary_sval);\n+      if (!caller_sval)\n+\tcontinue;\n+      m_dynamic_extents.put (caller_reg, caller_sval);\n+    }\n \n-  // TODO: actually implement some kind of summary here\n+  return true;\n }\n \n /* Given a true or false edge guarded by conditional statement COND_STMT,\n@@ -7123,6 +7168,57 @@ test_sub_svalue_folding ()\n   ASSERT_EQ (sub->get_type (), TREE_TYPE (ct.m_x_field));\n }\n \n+/* Get BIT within VAL as a symbolic value within MGR.  */\n+\n+static const svalue *\n+get_bit (region_model_manager *mgr,\n+\t bit_offset_t bit,\n+\t unsigned HOST_WIDE_INT val)\n+{\n+  const svalue *inner_svalue\n+    = mgr->get_or_create_int_cst (unsigned_type_node, val);\n+  return mgr->get_or_create_bits_within (boolean_type_node,\n+\t\t\t\t\t bit_range (bit, 1),\n+\t\t\t\t\t inner_svalue);\n+}\n+\n+/* Verify that bits_within_svalues are folded as expected.  */\n+\n+static void\n+test_bits_within_svalue_folding ()\n+{\n+  region_model_manager mgr;\n+\n+  const svalue *zero = mgr.get_or_create_int_cst (boolean_type_node, 0);\n+  const svalue *one = mgr.get_or_create_int_cst (boolean_type_node, 1);\n+\n+  {\n+    const unsigned val = 0x0000;\n+    for (unsigned bit = 0; bit < 16; bit++)\n+      ASSERT_EQ (get_bit (&mgr, bit, val), zero);\n+  }\n+\n+  {\n+    const unsigned val = 0x0001;\n+    ASSERT_EQ (get_bit (&mgr, 0, val), one);\n+    for (unsigned bit = 1; bit < 16; bit++)\n+      ASSERT_EQ (get_bit (&mgr, bit, val), zero);\n+  }\n+\n+  {\n+    const unsigned val = 0x8000;\n+    for (unsigned bit = 0; bit < 15; bit++)\n+      ASSERT_EQ (get_bit (&mgr, bit, val), zero);\n+    ASSERT_EQ (get_bit (&mgr, 15, val), one);\n+  }\n+\n+  {\n+    const unsigned val = 0xFFFF;\n+    for (unsigned bit = 0; bit < 16; bit++)\n+      ASSERT_EQ (get_bit (&mgr, bit, val), one);\n+  }\n+}\n+\n /* Test that region::descendent_of_p works as expected.  */\n \n static void\n@@ -7956,7 +8052,7 @@ static void\n test_widening_constraints ()\n {\n   region_model_manager mgr;\n-  program_point point (program_point::origin (mgr));\n+  function_point point (program_point::origin (mgr).get_function_point ());\n   tree int_0 = build_int_cst (integer_type_node, 0);\n   tree int_m1 = build_int_cst (integer_type_node, -1);\n   tree int_1 = build_int_cst (integer_type_node, 1);\n@@ -8479,6 +8575,7 @@ analyzer_region_model_cc_tests ()\n   test_unaryop_svalue_folding ();\n   test_binop_svalue_folding ();\n   test_sub_svalue_folding ();\n+  test_bits_within_svalue_folding ();\n   test_descendent_of_p ();\n   test_bit_range_regions ();\n   test_assignment ();"}, {"sha": "19e8043daa404c36355b99cf10684abcc0f6ee3d", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 52, "deletions": 318, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -26,9 +26,11 @@ along with GCC; see the file COPYING3.  If not see\n       (Zhongxing Xu, Ted Kremenek, and Jian Zhang)\n      http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf  */\n \n+#include \"selftest.h\"\n #include \"analyzer/svalue.h\"\n #include \"analyzer/region.h\"\n #include \"analyzer/known-function-manager.h\"\n+#include \"analyzer/region-model-manager.h\"\n \n using namespace ana;\n \n@@ -230,294 +232,6 @@ class visitor\n   virtual void visit_region (const region *) {}\n };\n \n-} // namespace ana\n-\n-namespace ana {\n-\n-/* A class responsible for owning and consolidating region and svalue\n-   instances.\n-   region and svalue instances are immutable as far as clients are\n-   concerned, so they are provided as \"const\" ptrs.  */\n-\n-class region_model_manager\n-{\n-public:\n-  region_model_manager (logger *logger = NULL);\n-  ~region_model_manager ();\n-\n-  /* call_string consolidation.  */\n-  const call_string &get_empty_call_string () const\n-  {\n-    return m_empty_call_string;\n-  }\n-\n-  /* svalue consolidation.  */\n-  const svalue *get_or_create_constant_svalue (tree cst_expr);\n-  const svalue *get_or_create_int_cst (tree type, poly_int64);\n-  const svalue *get_or_create_unknown_svalue (tree type);\n-  const svalue *get_or_create_setjmp_svalue (const setjmp_record &r,\n-\t\t\t\t\t     tree type);\n-  const svalue *get_or_create_poisoned_svalue (enum poison_kind kind,\n-\t\t\t\t\t       tree type);\n-  const svalue *get_or_create_initial_value (const region *reg);\n-  const svalue *get_ptr_svalue (tree ptr_type, const region *pointee);\n-  const svalue *get_or_create_unaryop (tree type, enum tree_code op,\n-\t\t\t\t       const svalue *arg);\n-  const svalue *get_or_create_cast (tree type, const svalue *arg);\n-  const svalue *get_or_create_binop (tree type,\n-\t\t\t\t     enum tree_code op,\n-\t\t\t\t     const svalue *arg0, const svalue *arg1);\n-  const svalue *get_or_create_sub_svalue (tree type,\n-\t\t\t\t\t  const svalue *parent_svalue,\n-\t\t\t\t\t  const region *subregion);\n-  const svalue *get_or_create_repeated_svalue (tree type,\n-\t\t\t\t\t       const svalue *outer_size,\n-\t\t\t\t\t       const svalue *inner_svalue);\n-  const svalue *get_or_create_bits_within (tree type,\n-\t\t\t\t\t   const bit_range &bits,\n-\t\t\t\t\t   const svalue *inner_svalue);\n-  const svalue *get_or_create_unmergeable (const svalue *arg);\n-  const svalue *get_or_create_widening_svalue (tree type,\n-\t\t\t\t\t       const program_point &point,\n-\t\t\t\t\t       const svalue *base_svalue,\n-\t\t\t\t\t       const svalue *iter_svalue);\n-  const svalue *get_or_create_compound_svalue (tree type,\n-\t\t\t\t\t       const binding_map &map);\n-  const svalue *get_or_create_conjured_svalue (tree type, const gimple *stmt,\n-\t\t\t\t\t       const region *id_reg,\n-\t\t\t\t\t       const conjured_purge &p);\n-  const svalue *\n-  get_or_create_asm_output_svalue (tree type,\n-\t\t\t\t   const gasm *asm_stmt,\n-\t\t\t\t   unsigned output_idx,\n-\t\t\t\t   const vec<const svalue *> &inputs);\n-  const svalue *\n-  get_or_create_const_fn_result_svalue (tree type,\n-\t\t\t\t\ttree fndecl,\n-\t\t\t\t\tconst vec<const svalue *> &inputs);\n-\n-  const svalue *maybe_get_char_from_string_cst (tree string_cst,\n-\t\t\t\t\t\ttree byte_offset_cst);\n-\n-  /* Dynamically-allocated svalue instances.\n-     The number of these within the analysis can grow arbitrarily.\n-     They are still owned by the manager.  */\n-  const svalue *create_unique_svalue (tree type);\n-\n-  /* region consolidation.  */\n-  const stack_region * get_stack_region () const { return &m_stack_region; }\n-  const heap_region *get_heap_region () const { return &m_heap_region; }\n-  const code_region *get_code_region () const { return &m_code_region; }\n-  const globals_region *get_globals_region () const\n-  {\n-    return &m_globals_region;\n-  }\n-  const function_region *get_region_for_fndecl (tree fndecl);\n-  const label_region *get_region_for_label (tree label);\n-  const decl_region *get_region_for_global (tree expr);\n-  const region *get_field_region (const region *parent, tree field);\n-  const region *get_element_region (const region *parent,\n-\t\t\t\t    tree element_type,\n-\t\t\t\t    const svalue *index);\n-  const region *get_offset_region (const region *parent,\n-\t\t\t\t   tree type,\n-\t\t\t\t   const svalue *byte_offset);\n-  const region *get_sized_region (const region *parent,\n-\t\t\t\t  tree type,\n-\t\t\t\t  const svalue *byte_size_sval);\n-  const region *get_cast_region (const region *original_region,\n-\t\t\t\t tree type);\n-  const frame_region *get_frame_region (const frame_region *calling_frame,\n-\t\t\t\t\tfunction *fun);\n-  const region *get_symbolic_region (const svalue *sval);\n-  const string_region *get_region_for_string (tree string_cst);\n-  const region *get_bit_range (const region *parent, tree type,\n-\t\t\t       const bit_range &bits);\n-  const var_arg_region *get_var_arg_region (const frame_region *parent,\n-\t\t\t\t\t    unsigned idx);\n-\n-  const region *get_unknown_symbolic_region (tree region_type);\n-\n-  const region *\n-  get_region_for_unexpected_tree_code (region_model_context *ctxt,\n-\t\t\t\t       tree t,\n-\t\t\t\t       const dump_location_t &loc);\n-\n-  unsigned alloc_region_id () { return m_next_region_id++; }\n-\n-  store_manager *get_store_manager () { return &m_store_mgr; }\n-  bounded_ranges_manager *get_range_manager () const { return m_range_mgr; }\n-\n-  known_function_manager *get_known_function_manager ()\n-  {\n-    return &m_known_fn_mgr;\n-  }\n-\n-  /* Dynamically-allocated region instances.\n-     The number of these within the analysis can grow arbitrarily.\n-     They are still owned by the manager.  */\n-  const region *create_region_for_heap_alloc ();\n-  const region *create_region_for_alloca (const frame_region *frame);\n-\n-  void log_stats (logger *logger, bool show_objs) const;\n-\n-  void begin_checking_feasibility (void) { m_checking_feasibility = true; }\n-  void end_checking_feasibility (void) { m_checking_feasibility = false; }\n-\n-  logger *get_logger () const { return m_logger; }\n-\n-  void dump_untracked_regions () const;\n-\n-private:\n-  bool too_complex_p (const complexity &c) const;\n-  bool reject_if_too_complex (svalue *sval);\n-\n-  const svalue *maybe_fold_unaryop (tree type, enum tree_code op,\n-\t\t\t\t    const svalue *arg);\n-  const svalue *maybe_fold_binop (tree type, enum tree_code op,\n-\t\t\t\t  const svalue *arg0, const svalue *arg1);\n-  const svalue *maybe_fold_sub_svalue (tree type,\n-\t\t\t\t       const svalue *parent_svalue,\n-\t\t\t\t       const region *subregion);\n-  const svalue *maybe_fold_repeated_svalue (tree type,\n-\t\t\t\t\t    const svalue *outer_size,\n-\t\t\t\t\t    const svalue *inner_svalue);\n-  const svalue *maybe_fold_bits_within_svalue (tree type,\n-\t\t\t\t\t       const bit_range &bits,\n-\t\t\t\t\t       const svalue *inner_svalue);\n-  const svalue *maybe_undo_optimize_bit_field_compare (tree type,\n-\t\t\t\t\t\t       const compound_svalue *compound_sval,\n-\t\t\t\t\t\t       tree cst, const svalue *arg1);\n-  const svalue *maybe_fold_asm_output_svalue (tree type,\n-\t\t\t\t\t      const vec<const svalue *> &inputs);\n-\n-  logger *m_logger;\n-\n-  const call_string m_empty_call_string;\n-\n-  unsigned m_next_region_id;\n-  root_region m_root_region;\n-  stack_region m_stack_region;\n-  heap_region m_heap_region;\n-\n-  /* svalue consolidation.  */\n-  typedef hash_map<tree, constant_svalue *> constants_map_t;\n-  constants_map_t m_constants_map;\n-\n-  typedef hash_map<tree, unknown_svalue *> unknowns_map_t;\n-  unknowns_map_t m_unknowns_map;\n-  const unknown_svalue *m_unknown_NULL;\n-\n-  typedef hash_map<poisoned_svalue::key_t,\n-\t\t   poisoned_svalue *> poisoned_values_map_t;\n-  poisoned_values_map_t m_poisoned_values_map;\n-\n-  typedef hash_map<setjmp_svalue::key_t,\n-\t\t   setjmp_svalue *> setjmp_values_map_t;\n-  setjmp_values_map_t m_setjmp_values_map;\n-\n-  typedef hash_map<const region *, initial_svalue *> initial_values_map_t;\n-  initial_values_map_t m_initial_values_map;\n-\n-  typedef hash_map<region_svalue::key_t, region_svalue *> pointer_values_map_t;\n-  pointer_values_map_t m_pointer_values_map;\n-\n-  typedef hash_map<unaryop_svalue::key_t,\n-\t\t   unaryop_svalue *> unaryop_values_map_t;\n-  unaryop_values_map_t m_unaryop_values_map;\n-\n-  typedef hash_map<binop_svalue::key_t, binop_svalue *> binop_values_map_t;\n-  binop_values_map_t m_binop_values_map;\n-\n-  typedef hash_map<sub_svalue::key_t, sub_svalue *> sub_values_map_t;\n-  sub_values_map_t m_sub_values_map;\n-\n-  typedef hash_map<repeated_svalue::key_t,\n-\t\t   repeated_svalue *> repeated_values_map_t;\n-  repeated_values_map_t m_repeated_values_map;\n-\n-  typedef hash_map<bits_within_svalue::key_t,\n-\t\t   bits_within_svalue *> bits_within_values_map_t;\n-  bits_within_values_map_t m_bits_within_values_map;\n-\n-  typedef hash_map<const svalue *,\n-\t\t   unmergeable_svalue *> unmergeable_values_map_t;\n-  unmergeable_values_map_t m_unmergeable_values_map;\n-\n-  typedef hash_map<widening_svalue::key_t,\n-\t\t   widening_svalue */*,\n-\t\t   widening_svalue::key_t::hash_map_traits*/>\n-    widening_values_map_t;\n-  widening_values_map_t m_widening_values_map;\n-\n-  typedef hash_map<compound_svalue::key_t,\n-\t\t   compound_svalue *> compound_values_map_t;\n-  compound_values_map_t m_compound_values_map;\n-\n-  typedef hash_map<conjured_svalue::key_t,\n-\t\t   conjured_svalue *> conjured_values_map_t;\n-  conjured_values_map_t m_conjured_values_map;\n-\n-  typedef hash_map<asm_output_svalue::key_t,\n-\t\t   asm_output_svalue *> asm_output_values_map_t;\n-  asm_output_values_map_t m_asm_output_values_map;\n-\n-  typedef hash_map<const_fn_result_svalue::key_t,\n-\t\t   const_fn_result_svalue *> const_fn_result_values_map_t;\n-  const_fn_result_values_map_t m_const_fn_result_values_map;\n-\n-  bool m_checking_feasibility;\n-\n-  /* \"Dynamically-allocated\" svalue instances.\n-     The number of these within the analysis can grow arbitrarily.\n-     They are still owned by the manager.  */\n-  auto_delete_vec<svalue> m_managed_dynamic_svalues;\n-\n-  /* Maximum complexity of svalues that weren't rejected.  */\n-  complexity m_max_complexity;\n-\n-  /* region consolidation.  */\n-\n-  code_region m_code_region;\n-  typedef hash_map<tree, function_region *> fndecls_map_t;\n-  typedef fndecls_map_t::iterator fndecls_iterator_t;\n-  fndecls_map_t m_fndecls_map;\n-\n-  typedef hash_map<tree, label_region *> labels_map_t;\n-  typedef labels_map_t::iterator labels_iterator_t;\n-  labels_map_t m_labels_map;\n-\n-  globals_region m_globals_region;\n-  typedef hash_map<tree, decl_region *> globals_map_t;\n-  typedef globals_map_t::iterator globals_iterator_t;\n-  globals_map_t m_globals_map;\n-\n-  consolidation_map<field_region> m_field_regions;\n-  consolidation_map<element_region> m_element_regions;\n-  consolidation_map<offset_region> m_offset_regions;\n-  consolidation_map<sized_region> m_sized_regions;\n-  consolidation_map<cast_region> m_cast_regions;\n-  consolidation_map<frame_region> m_frame_regions;\n-  consolidation_map<symbolic_region> m_symbolic_regions;\n-\n-  typedef hash_map<tree, string_region *> string_map_t;\n-  string_map_t m_string_map;\n-\n-  consolidation_map<bit_range_region> m_bit_range_regions;\n-  consolidation_map<var_arg_region> m_var_arg_regions;\n-\n-  store_manager m_store_mgr;\n-\n-  bounded_ranges_manager *m_range_mgr;\n-\n-  known_function_manager m_known_fn_mgr;\n-\n-  /* \"Dynamically-allocated\" region instances.\n-     The number of these within the analysis can grow arbitrarily.\n-     They are still owned by the manager.  */\n-  auto_delete_vec<region> m_managed_dynamic_regions;\n-};\n-\n struct append_regions_cb_data;\n \n /* Helper class for handling calls to functions with known behavior.\n@@ -631,6 +345,7 @@ class region_model\n   void impl_call_analyzer_dump_escaped (const gcall *call);\n   void impl_call_analyzer_eval (const gcall *call,\n \t\t\t\tregion_model_context *ctxt);\n+  void impl_call_analyzer_get_unknown_ptr (const call_details &cd);\n   void impl_call_builtin_expect (const call_details &cd);\n   void impl_call_calloc (const call_details &cd);\n   bool impl_call_error (const call_details &cd, unsigned min_args,\n@@ -641,6 +356,7 @@ class region_model\n   void impl_call_malloc (const call_details &cd);\n   void impl_call_memcpy (const call_details &cd);\n   void impl_call_memset (const call_details &cd);\n+  void impl_call_pipe (const call_details &cd);\n   void impl_call_putenv (const call_details &cd);\n   void impl_call_realloc (const call_details &cd);\n   void impl_call_strchr (const call_details &cd);\n@@ -658,6 +374,9 @@ class region_model\n \n   const svalue *maybe_get_copy_bounds (const region *src_reg,\n \t\t\t\t       const svalue *num_bytes_sval);\n+  void update_for_int_cst_return (const call_details &cd,\n+\t\t\t\t  int retval,\n+\t\t\t\t  bool unmergeable);\n   void update_for_zero_return (const call_details &cd,\n \t\t\t       bool unmergeable);\n   void update_for_nonzero_return (const call_details &cd);\n@@ -816,11 +535,17 @@ class region_model\n   const svalue *get_string_size (const svalue *sval) const;\n   const svalue *get_string_size (const region *reg) const;\n \n+  bool replay_call_summary (call_summary_replay &r,\n+\t\t\t    const region_model &summary);\n+\n   void maybe_complain_about_infoleak (const region *dst_reg,\n \t\t\t\t      const svalue *copied_sval,\n \t\t\t\t      const region *src_reg,\n \t\t\t\t      region_model_context *ctxt);\n \n+  /* Implemented in sm-fd.cc  */\n+  void mark_as_valid_fd (const svalue *sval, region_model_context *ctxt);\n+\n   /* Implemented in sm-malloc.cc  */\n   void on_realloc_with_move (const call_details &cd,\n \t\t\t     const svalue *old_ptr_sval,\n@@ -857,8 +582,6 @@ class region_model\n \t\t\t\t  region_model_context *ctxt);\n   void update_for_return_superedge (const return_superedge &return_edge,\n \t\t\t\t    region_model_context *ctxt);\n-  void update_for_call_summary (const callgraph_superedge &cg_sedge,\n-\t\t\t\tregion_model_context *ctxt);\n   bool apply_constraints_for_gcond (const cfg_superedge &edge,\n \t\t\t\t    const gcond *cond_stmt,\n \t\t\t\t    region_model_context *ctxt,\n@@ -1014,15 +737,33 @@ class region_model_context\n \n   virtual const extrinsic_state *get_ext_state () const = 0;\n \n-  /* Hook for clients to access the \"malloc\" state machine in\n+  /* Hook for clients to access the a specific state machine in\n      any underlying program_state.  */\n-  virtual bool get_malloc_map (sm_state_map **out_smap,\n-\t\t\t       const state_machine **out_sm,\n-\t\t\t       unsigned *out_sm_idx) = 0;\n-  /* Likewise for the \"taint\" state machine.  */\n-  virtual bool get_taint_map (sm_state_map **out_smap,\n-\t\t\t      const state_machine **out_sm,\n-\t\t\t      unsigned *out_sm_idx) = 0;\n+  virtual bool get_state_map_by_name (const char *name,\n+\t\t\t\t      sm_state_map **out_smap,\n+\t\t\t\t      const state_machine **out_sm,\n+\t\t\t\t      unsigned *out_sm_idx) = 0;\n+\n+  /* Precanned ways for clients to access specific state machines.  */\n+  bool get_fd_map (sm_state_map **out_smap,\n+\t\t   const state_machine **out_sm,\n+\t\t   unsigned *out_sm_idx)\n+  {\n+    return get_state_map_by_name (\"file-descriptor\", out_smap, out_sm,\n+\t\t\t\t  out_sm_idx);\n+  }\n+  bool get_malloc_map (sm_state_map **out_smap,\n+\t\t       const state_machine **out_sm,\n+\t\t       unsigned *out_sm_idx)\n+  {\n+    return get_state_map_by_name (\"malloc\", out_smap, out_sm, out_sm_idx);\n+  }\n+  bool get_taint_map (sm_state_map **out_smap,\n+\t\t      const state_machine **out_sm,\n+\t\t      unsigned *out_sm_idx)\n+  {\n+    return get_state_map_by_name (\"taint\", out_smap, out_sm, out_sm_idx);\n+  }\n \n   /* Get the current statement, if any.  */\n   virtual const gimple *get_stmt () const = 0;\n@@ -1069,15 +810,10 @@ class noop_region_model_context : public region_model_context\n \n   const extrinsic_state *get_ext_state () const override { return NULL; }\n \n-  bool get_malloc_map (sm_state_map **,\n-\t\t       const state_machine **,\n-\t\t       unsigned *) override\n-  {\n-    return false;\n-  }\n-  bool get_taint_map (sm_state_map **,\n-\t\t      const state_machine **,\n-\t\t      unsigned *) override\n+  bool get_state_map_by_name (const char *,\n+\t\t\t      sm_state_map **,\n+\t\t\t      const state_machine **,\n+\t\t\t      unsigned *) override\n   {\n     return false;\n   }\n@@ -1196,18 +932,12 @@ class region_model_context_decorator : public region_model_context\n     return m_inner->get_ext_state ();\n   }\n \n-  bool get_malloc_map (sm_state_map **out_smap,\n-\t\t       const state_machine **out_sm,\n-\t\t       unsigned *out_sm_idx) override\n-  {\n-    return m_inner->get_malloc_map (out_smap, out_sm, out_sm_idx);\n-  }\n-\n-  bool get_taint_map (sm_state_map **out_smap,\n-\t\t      const state_machine **out_sm,\n-\t\t      unsigned *out_sm_idx) override\n+  bool get_state_map_by_name (const char *name,\n+\t\t\t      sm_state_map **out_smap,\n+\t\t\t      const state_machine **out_sm,\n+\t\t\t      unsigned *out_sm_idx) override\n   {\n-    return m_inner->get_taint_map (out_smap, out_sm, out_sm_idx);\n+    return m_inner->get_state_map_by_name (name, out_smap, out_sm, out_sm_idx);\n   }\n \n   const gimple *get_stmt () const override\n@@ -1282,6 +1012,10 @@ struct model_merger\n   }\n \n   bool mergeable_svalue_p (const svalue *) const;\n+  const function_point &get_function_point () const\n+  {\n+    return m_point.get_function_point ();\n+  }\n \n   const region_model *m_model_a;\n   const region_model *m_model_b;"}, {"sha": "da5a13ec0bee3489aef32933ddc165c4ca9ec3cf", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -40,11 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"diagnostic-color.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n-#include \"selftest.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\""}, {"sha": "ae846cd6ec839b13b79df214eeafbbe9fe7a6d79", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 69, "deletions": 25, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -28,24 +28,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/function-set.h\"\n #include \"analyzer/analyzer-selftests.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"bitmap.h\"\n+#include \"analyzer/program-state.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -125,6 +122,12 @@ class fd_state_machine : public state_machine\n   /* Function for one-to-one correspondence between valid\n      and unchecked states.  */\n   state_t valid_to_unchecked_state (state_t state) const;\n+\n+  void mark_as_valid_fd (region_model *model,\n+\t\t\t sm_state_map *smap,\n+\t\t\t const svalue *fd_sval,\n+\t\t\t const extrinsic_state &ext_state) const;\n+\n   /* State for a constant file descriptor (>= 0) */\n   state_t m_constant_fd;\n \n@@ -205,15 +208,19 @@ class fd_diagnostic : public pending_diagnostic\n   describe_state_change (const evdesc::state_change &change) override\n   {\n     if (change.m_old_state == m_sm.get_start_state ()\n-\t&& m_sm.is_unchecked_fd_p (change.m_new_state))\n+\t&& (m_sm.is_unchecked_fd_p (change.m_new_state)\n+\t    || m_sm.is_valid_fd_p (change.m_new_state)))\n       {\n-\tif (change.m_new_state == m_sm.m_unchecked_read_write)\n+\tif (change.m_new_state == m_sm.m_unchecked_read_write\n+\t    || change.m_new_state == m_sm.m_valid_read_write)\n \t  return change.formatted_print (\"opened here as read-write\");\n \n-\tif (change.m_new_state == m_sm.m_unchecked_read_only)\n+\tif (change.m_new_state == m_sm.m_unchecked_read_only\n+\t    || change.m_new_state == m_sm.m_valid_read_only)\n \t  return change.formatted_print (\"opened here as read-only\");\n \n-\tif (change.m_new_state == m_sm.m_unchecked_write_only)\n+\tif (change.m_new_state == m_sm.m_unchecked_write_only\n+\t    || change.m_new_state == m_sm.m_valid_write_only)\n \t  return change.formatted_print (\"opened here as write-only\");\n       }\n \n@@ -752,6 +759,15 @@ fd_state_machine::valid_to_unchecked_state (state_t state) const\n   return NULL;\n }\n \n+void\n+fd_state_machine::mark_as_valid_fd (region_model *model,\n+\t\t\t\t    sm_state_map *smap,\n+\t\t\t\t    const svalue *fd_sval,\n+\t\t\t\t    const extrinsic_state &ext_state) const\n+{\n+  smap->set_state (model, fd_sval, m_valid_read_write, NULL, ext_state);\n+}\n+\n bool\n fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n \t\t\t   const gimple *stmt) const\n@@ -768,6 +784,7 @@ fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n \tif (is_named_call_p (callee_fndecl, \"creat\", call, 2))\n \t  {\n \t    on_creat (sm_ctxt, node, stmt, call);\n+\t    return true;\n \t  } // \"creat\"\n \n \tif (is_named_call_p (callee_fndecl, \"close\", call, 1))\n@@ -923,25 +940,25 @@ fd_state_machine::on_open (sm_context *sm_ctxt, const supernode *node,\n   if (lhs)\n     {\n       tree arg = gimple_call_arg (call, 1);\n+      enum access_mode mode = READ_WRITE;\n       if (TREE_CODE (arg) == INTEGER_CST)\n \t{\n \t  int flag = TREE_INT_CST_LOW (arg);\n-\t  enum access_mode mode = get_access_mode_from_flag (flag);\n-\n-\t  switch (mode)\n-\t    {\n-\t    case READ_ONLY:\n-\t      sm_ctxt->on_transition (node, stmt, lhs, m_start,\n-\t\t\t\t      m_unchecked_read_only);\n-\t      break;\n-\t    case WRITE_ONLY:\n-\t      sm_ctxt->on_transition (node, stmt, lhs, m_start,\n-\t\t\t\t      m_unchecked_write_only);\n-\t      break;\n-\t    default:\n-\t      sm_ctxt->on_transition (node, stmt, lhs, m_start,\n-\t\t\t\t      m_unchecked_read_write);\n-\t    }\n+\t  mode = get_access_mode_from_flag (flag);\n+\t}\n+      switch (mode)\n+\t{\n+\tcase READ_ONLY:\n+\t  sm_ctxt->on_transition (node, stmt, lhs, m_start,\n+\t\t\t\t  m_unchecked_read_only);\n+\t  break;\n+\tcase WRITE_ONLY:\n+\t  sm_ctxt->on_transition (node, stmt, lhs, m_start,\n+\t\t\t\t  m_unchecked_write_only);\n+\t  break;\n+\tdefault:\n+\t  sm_ctxt->on_transition (node, stmt, lhs, m_start,\n+\t\t\t\t  m_unchecked_read_write);\n \t}\n     }\n   else\n@@ -1079,7 +1096,7 @@ fd_state_machine::check_for_open_fd (\n \n   else\n     {\n-      if (!(is_valid_fd_p (state) || (state == m_stop)))\n+      if (!(is_valid_fd_p (state) || state == m_start || state == m_stop))\n \t{\n \t  if (!is_constant_fd_p (state))\n \t    sm_ctxt->warn (\n@@ -1190,6 +1207,33 @@ make_fd_state_machine (logger *logger)\n {\n   return new fd_state_machine (logger);\n }\n+\n+/* Specialcase hook for handling pipe, for use by\n+   region_model::impl_call_pipe::success::update_model.  */\n+\n+void\n+region_model::mark_as_valid_fd (const svalue *sval, region_model_context *ctxt)\n+{\n+  if (!ctxt)\n+    return;\n+  const extrinsic_state *ext_state = ctxt->get_ext_state ();\n+  if (!ext_state)\n+    return;\n+\n+  sm_state_map *smap;\n+  const state_machine *sm;\n+  unsigned sm_idx;\n+  if (!ctxt->get_fd_map (&smap, &sm, &sm_idx))\n+    return;\n+\n+  gcc_assert (smap);\n+  gcc_assert (sm);\n+\n+  const fd_state_machine &fd_sm = (const fd_state_machine &)*sm;\n+\n+  fd_sm.mark_as_valid_fd (this, smap, sval, *ext_state);\n+}\n+\n } // namespace ana\n \n #endif // ENABLE_ANALYZER"}, {"sha": "175daae44ae9be55555b44b0996fb4e14fa71642", "filename": "gcc/analyzer/sm-fd.dot", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-fd.dot", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-fd.dot", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.dot?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -0,0 +1,109 @@\n+/* An overview of the state machine from sm-fd.cc.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Keep this in-sync with sm-dot.cc  */\n+\n+digraph \"fd\" {\n+\n+  /* STATES. */\n+\n+  /* Start state.  */\n+  start;\n+\n+  /* States representing a file descriptor that hasn't yet been\n+    checked for validity after opening, for three different\n+    access modes.  */\n+  unchecked_read_write;\n+  unchecked_read_only;\n+  unchecked_write_only;\n+\n+  /* States for representing a file descriptor that is known to be valid (>=\n+    0), for three different access modes.  */\n+  valid_read_write;\n+  valid_read_only;\n+  valid_write_only;\n+\n+  /* State for a file descriptor that is known to be invalid (< 0). */\n+  invalid;\n+\n+  /* State for a file descriptor that has been closed.  */\n+  closed;\n+\n+  /* State for a file descriptor that we do not want to track anymore . */\n+  stop;\n+\n+  /* TRANSITIONS. */\n+\n+  /* On \"open\".  */\n+  start -> unchecked_read_only [label=\"on 'X = open(..., O_RDONLY);'\"];\n+  start -> unchecked_write_only [label=\"on 'X = open(..., O_WRONLY);'\"];\n+  start -> unchecked_read_write [label=\"on 'X = open(..., ...);'\"];\n+\n+  /* On \"creat\".  */\n+  start -> unchecked_write_only [label=\"on 'X = create(...);'\"];\n+\n+  /* On \"close\".  */\n+  start -> closed [label=\"on 'close(X);'\"];\n+  unchecked_read_write -> closed [label=\"on 'close(X);'\"];\n+  unchecked_read_only -> closed [label=\"on 'close(X);'\"];\n+  unchecked_write_only -> closed [label=\"on 'close(X);'\"];\n+  valid_read_write -> closed [label=\"on 'close(X);'\"];\n+  valid_read_only -> closed [label=\"on 'close(X);'\"];\n+  valid_write_only -> closed [label=\"on 'close(X);'\"];\n+  constant_fd -> closed [label=\"on 'close(X);'\"];\n+  closed -> stop [label=\"on 'close(X);':\\nWarn('double close')\"];\n+\n+  /* On \"read\".  */\n+  closed -> closed [label=\"on 'read(X);':\\nWarn('use after close')\"];\n+  unchecked_read_write -> unchecked_read_write [label=\"on 'read(X);:\\nWarn('use without check')'\"];\n+  unchecked_read_only -> unchecked_read_only [label=\"on 'read(X);:\\nWarn('use without check')'\"];\n+  unchecked_write_only -> unchecked_write_only [label=\"on 'read(X);:\\nWarn('use without check')'\"];\n+  valid_write_only -> valid_write_only [label=\"on 'read(X);:\\nWarn('access mode mismatch')'\"];\n+\n+  /* On \"write\".  */\n+  closed -> closed [label=\"on 'write(X);':\\nWarn('use after close')\"];\n+  unchecked_read_write -> unchecked_read_write [label=\"on 'write(X);:\\nWarn('use without check')'\"];\n+  unchecked_read_only -> unchecked_read_only [label=\"on 'write(X);:\\nWarn('use without check')'\"];\n+  unchecked_write_only -> unchecked_write_only [label=\"on 'write(X);:\\nWarn('use without check')'\"];\n+  valid_read_only -> valid_read_only [label=\"on 'write(X);:\\nWarn('access mode mismatch')'\"];\n+\n+  /* On \"dup\".  */\n+  closed -> closed [label=\"on 'dup(X);':\\nWarn('use after close')\"];\n+  /* plus stuff for the new fd.  */\n+\n+  /* On \"pipe\".  */\n+  start -> valid_read_write [label=\"when 'pipe()' succeeds\"];\n+\n+  /* on_condition.  */\n+  unchecked_read_write -> valid_read_write [label=\"on 'X >= 0'\"];\n+  unchecked_read_only -> valid_read_only [label=\"on 'X >= 0'\"];\n+  unchecked_write_only -> valid_write_only [label=\"on 'X >= 0'\"];\n+  unchecked_read_write -> invalid [label=\"on 'X < 0'\"];\n+  unchecked_read_only -> invalid [label=\"on 'X < 0'\"];\n+  unchecked_write_only -> invalid [label=\"on 'X < 0'\"];\n+\n+  /* Leaks.  */\n+  unchecked_read_write -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  unchecked_read_only -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  unchecked_write_only -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  valid_read_write -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  valid_read_only -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  valid_write_only -> stop [label=\"on leak:\\nWarn('leak')\"];\n+}"}, {"sha": "13f2507f7c79db5c3e1724f122c8434eeca81dc4", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -28,16 +28,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/function-set.h\"\n #include \"analyzer/analyzer-selftests.h\"\n-#include \"tristate.h\"\n #include \"selftest.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\""}, {"sha": "fef6e63e1d7569791098940f5f70b8f9716bf909", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -29,15 +29,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\""}, {"sha": "3208132882ef6659fb05860090cf4e45b8bb1dc3", "filename": "gcc/analyzer/sm-pattern-test.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-pattern-test.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -30,15 +30,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\""}, {"sha": "cb5f8595b1f79c41dc80046c6ffc95ae9143c23d", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -24,14 +24,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"function.h\"\n-#include \"function.h\"\n #include \"basic-block.h\"\n #include \"gimple.h\"\n #include \"options.h\"\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "e3b08c38b30dcdbaea1611f6f07ad50058d2412c", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -31,15 +31,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"sbitmap.h\"\n-#include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\"\n #include \"analyzer/call-string.h\"\n@@ -48,13 +45,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/region-model.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/checker-path.h\"\n-#include \"digraph.h\"\n #include \"cfg.h\"\n #include \"gimple-iterator.h\"\n #include \"cgraph.h\"\n #include \"analyzer/supergraph.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n #include \"analyzer/diagnostic-manager.h\"\n #include \"shortest-paths.h\"\n #include \"analyzer/exploded-graph.h\""}, {"sha": "bc27533256fdb91c28ed91904f0b966432c14683", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -30,13 +30,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"gimple-iterator.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"ordered-hash-map.h\"\n #include \"cgraph.h\"\n #include \"cfg.h\""}, {"sha": "1ab4c21fa1d5127c70b3d88ad82bf2fa52ee1246", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -31,11 +31,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pretty-print.h\"\n #include \"diagnostic.h\"\n #include \"tree-diagnostic.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n-#include \"tristate.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\""}, {"sha": "d3f516a671c338e4f76e974c7552590ba274d1d2", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -36,24 +36,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa-iterators.h\"\n #include \"diagnostic-core.h\"\n #include \"gimple-pretty-print.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/call-string.h\"\n-#include \"digraph.h\"\n-#include \"ordered-hash-map.h\"\n-#include \"cfg.h\"\n-#include \"gimple-iterator.h\"\n-#include \"cgraph.h\"\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/state-purge.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"gimple-walk.h\"\n+#include \"cgraph.h\"\n \n #if ENABLE_ANALYZER\n "}, {"sha": "2631ea255593c18625cb66ec9880663916fbafcd", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 143, "deletions": 5, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -38,24 +38,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"diagnostic-color.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n #include \"selftest.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n-#include \"cgraph.h\"\n #include \"cfg.h\"\n-#include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n #include \"sbitmap.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-summary.h\"\n #include \"analyzer/analyzer-selftests.h\"\n #include \"stor-layout.h\"\n \n@@ -3130,6 +3126,148 @@ store::loop_replay_fixup (const store *other_store,\n     }\n }\n \n+/* Use R to replay the bindings from SUMMARY into this object.  */\n+\n+void\n+store::replay_call_summary (call_summary_replay &r,\n+\t\t\t    const store &summary)\n+{\n+  if (summary.m_called_unknown_fn)\n+    {\n+      /* A call to an external function occurred in the summary.\n+\t Hence we need to invalidate our knownledge of globals,\n+\t escaped regions, etc.  */\n+      on_unknown_fncall (r.get_call_stmt (),\n+\t\t\t r.get_store_manager (),\n+\t\t\t conjured_purge (r.get_caller_model (),\n+\t\t\t\t\t r.get_ctxt ()));\n+    }\n+\n+  auto_vec<const region *> keys (summary.m_cluster_map.elements ());\n+  for (auto kv : summary.m_cluster_map)\n+    keys.quick_push (kv.first);\n+  keys.qsort (region::cmp_ptr_ptr);\n+  for (auto base_reg : keys)\n+    replay_call_summary_cluster (r, summary, base_reg);\n+}\n+\n+/* Use R and SUMMARY to replay the bindings in SUMMARY_CLUSTER\n+   into this object.  */\n+\n+void\n+store::replay_call_summary_cluster (call_summary_replay &r,\n+\t\t\t\t    const store &summary,\n+\t\t\t\t    const region *summary_base_reg)\n+{\n+  const call_details &cd = r.get_call_details ();\n+  region_model_manager *reg_mgr = r.get_manager ();\n+  store_manager *mgr = reg_mgr->get_store_manager ();\n+  const binding_cluster *summary_cluster\n+    = summary.get_cluster (summary_base_reg);\n+\n+  /* Handle \"ESCAPED\" and \"TOUCHED\" flags.  */\n+  if (summary_cluster->escaped_p () || summary_cluster->touched_p ())\n+    if (const region *caller_reg\n+\t= r.convert_region_from_summary (summary_base_reg))\n+      {\n+\tconst region *caller_base_reg = caller_reg->get_base_region ();\n+\tif (caller_base_reg->tracked_p ()\n+\t    && !caller_base_reg->symbolic_for_unknown_ptr_p ())\n+\t  {\n+\t    binding_cluster *caller_cluster\n+\t      = get_or_create_cluster (caller_base_reg);\n+\t    if (summary_cluster->escaped_p ())\n+\t      caller_cluster->mark_as_escaped ();\n+\t    if (summary_cluster->touched_p ())\n+\t      caller_cluster->m_touched = true;\n+\t  }\n+      }\n+\n+  switch (summary_base_reg->get_kind ())\n+    {\n+    /* Top-level regions.  */\n+    case RK_FRAME:\n+    case RK_GLOBALS:\n+    case RK_CODE:\n+    case RK_STACK:\n+    case RK_HEAP:\n+    case RK_ROOT:\n+    /* Child regions.  */\n+    case RK_FIELD:\n+    case RK_ELEMENT:\n+    case RK_OFFSET:\n+    case RK_SIZED:\n+    case RK_CAST:\n+    case RK_BIT_RANGE:\n+    /* Other regions.  */\n+    case RK_VAR_ARG:\n+    case RK_UNKNOWN:\n+      /* These should never be the base region of a binding cluster.  */\n+      gcc_unreachable ();\n+      break;\n+\n+    case RK_FUNCTION:\n+    case RK_LABEL:\n+    case RK_STRING:\n+      /* These can be marked as escaping.  */\n+      break;\n+\n+    case RK_SYMBOLIC:\n+      {\n+\tconst symbolic_region *summary_symbolic_reg\n+\t  = as_a <const symbolic_region *> (summary_base_reg);\n+\tconst svalue *summary_ptr_sval = summary_symbolic_reg->get_pointer ();\n+\tconst svalue *caller_ptr_sval\n+\t  = r.convert_svalue_from_summary (summary_ptr_sval);\n+\tif (!caller_ptr_sval)\n+\t  return;\n+\tconst region *caller_dest_reg\n+\t  = cd.get_model ()->deref_rvalue (caller_ptr_sval,\n+\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t   cd.get_ctxt ());\n+\tconst svalue *summary_sval\n+\t  = summary.get_any_binding (mgr, summary_base_reg);\n+\tif (!summary_sval)\n+\t  return;\n+\tconst svalue *caller_sval\n+\t  = r.convert_svalue_from_summary (summary_sval);\n+\tif (!caller_sval)\n+\t  caller_sval =\n+\t    reg_mgr->get_or_create_unknown_svalue (summary_sval->get_type ());\n+\tset_value (mgr, caller_dest_reg,\n+\t\t   caller_sval, NULL /* uncertainty_t * */);\n+      }\n+      break;\n+\n+    case RK_HEAP_ALLOCATED:\n+    case RK_DECL:\n+      {\n+\tconst region *caller_dest_reg\n+\t  = r.convert_region_from_summary (summary_base_reg);\n+\tif (!caller_dest_reg)\n+\t  return;\n+\tconst svalue *summary_sval\n+\t  = summary.get_any_binding (mgr, summary_base_reg);\n+\tif (!summary_sval)\n+\t  summary_sval = reg_mgr->get_or_create_compound_svalue\n+\t    (summary_base_reg->get_type (),\n+\t     summary_cluster->get_map ());\n+\tconst svalue *caller_sval\n+\t  = r.convert_svalue_from_summary (summary_sval);\n+\tif (!caller_sval)\n+\t  caller_sval =\n+\t    reg_mgr->get_or_create_unknown_svalue (summary_sval->get_type ());\n+\tset_value (mgr, caller_dest_reg,\n+\t\t   caller_sval, NULL /* uncertainty_t * */);\n+      }\n+      break;\n+\n+    case RK_ALLOCA:\n+      /* Ignore bindings of alloca regions in the summary.  */\n+      break;\n+    }\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "1087782a3262a823651a71fd06b8e016937cdaea", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -418,6 +418,14 @@ class concrete_binding : public binding_key\n \n } // namespace ana\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <const ana::concrete_binding *>::test (const ana::binding_key *key)\n+{\n+  return key->concrete_p ();\n+}\n+\n template <> struct default_hash_traits<ana::concrete_binding>\n : public member_function_hash_traits<ana::concrete_binding>\n {\n@@ -786,6 +794,12 @@ class store\n   void loop_replay_fixup (const store *other_store,\n \t\t\t  region_model_manager *mgr);\n \n+  void replay_call_summary (call_summary_replay &r,\n+\t\t\t    const store &summary);\n+  void replay_call_summary_cluster (call_summary_replay &r,\n+\t\t\t\t    const store &summary,\n+\t\t\t\t    const region *base_reg);\n+\n private:\n   void remove_overlapping_bindings (store_manager *mgr, const region *reg,\n \t\t\t\t    uncertainty_t *uncertainty);"}, {"sha": "0e9a32500cb0635c774e03b6e72c14215b21192b", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -44,7 +44,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"cfganal.h\"\n #include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n@@ -62,7 +61,7 @@ namespace ana {\n /* Get the function of the ultimate alias target being called at EDGE,\n    if any.  */\n \n-static function *\n+function *\n get_ultimate_function_for_cgraph_edge (cgraph_edge *edge)\n {\n   cgraph_node *ultimate_node = edge->callee->ultimate_alias_target ();\n@@ -74,12 +73,13 @@ get_ultimate_function_for_cgraph_edge (cgraph_edge *edge)\n /* Get the cgraph_edge, but only if there's an underlying function body.  */\n \n cgraph_edge *\n-supergraph_call_edge (function *fun, gimple *stmt)\n+supergraph_call_edge (function *fun, const gimple *stmt)\n {\n-  gcall *call = dyn_cast<gcall *> (stmt);\n+  const gcall *call = dyn_cast<const gcall *> (stmt);\n   if (!call)\n     return NULL;\n-  cgraph_edge *edge = cgraph_node::get (fun->decl)->get_edge (stmt);\n+  cgraph_edge *edge\n+    = cgraph_node::get (fun->decl)->get_edge (const_cast <gimple *> (stmt));\n   if (!edge)\n     return NULL;\n   if (!edge->callee)"}, {"sha": "f66058cc3ec780ed2c962cdbaa6be94df03c02ca", "filename": "gcc/analyzer/supergraph.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -21,6 +21,13 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_SUPERGRAPH_H\n #define GCC_ANALYZER_SUPERGRAPH_H\n \n+#include \"ordered-hash-map.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"digraph.h\"\n+\n using namespace ana;\n \n namespace ana {\n@@ -605,7 +612,8 @@ class dot_annotator\n   }\n };\n \n-extern cgraph_edge *supergraph_call_edge (function *fun, gimple *stmt);\n+extern cgraph_edge *supergraph_call_edge (function *fun, const gimple *stmt);\n+extern function *get_ultimate_function_for_cgraph_edge (cgraph_edge *edge);\n \n } // namespace ana\n "}, {"sha": "4b00a81b31d01c5aeb4c729d6ba3a1561a26185c", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -38,22 +38,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"fold-const.h\"\n #include \"tree-pretty-print.h\"\n-#include \"tristate.h\"\n #include \"bitmap.h\"\n-#include \"selftest.h\"\n-#include \"function.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n-#include \"options.h\"\n-#include \"cgraph.h\"\n-#include \"cfg.h\"\n-#include \"digraph.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/svalue.h\"\n #include \"analyzer/region-model.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -207,7 +201,7 @@ svalue::can_merge_p (const svalue *other,\n   if (maybe_get_constant () && other->maybe_get_constant ())\n     {\n       return mgr->get_or_create_widening_svalue (other->get_type (),\n-\t\t\t\t\t\t merger->m_point,\n+\t\t\t\t\t\t merger->get_function_point (),\n \t\t\t\t\t\t other, this);\n     }\n \n@@ -220,7 +214,7 @@ svalue::can_merge_p (const svalue *other,\n \t&& binop_sval->get_arg1 ()->get_kind () == SK_CONSTANT\n \t&& other->get_kind () != SK_WIDENING)\n       return mgr->get_or_create_widening_svalue (other->get_type (),\n-\t\t\t\t\t\t merger->m_point,\n+\t\t\t\t\t\t merger->get_function_point (),\n \t\t\t\t\t\t other, this);\n \n   /* Merge: (Widen(existing_val, V), existing_val) -> Widen (existing_val, V)\n@@ -874,7 +868,7 @@ constant_svalue::eval_condition (const constant_svalue *lhs,\n \n const svalue *\n constant_svalue::maybe_fold_bits_within (tree type,\n-\t\t\t\t\t const bit_range &,\n+\t\t\t\t\t const bit_range &bits,\n \t\t\t\t\t region_model_manager *mgr) const\n {\n   /* Bits within an all-zero value are also all zero.  */\n@@ -885,6 +879,22 @@ constant_svalue::maybe_fold_bits_within (tree type,\n       else\n \treturn this;\n     }\n+\n+  /* Handle the case of extracting a single bit. */\n+  if (bits.m_size_in_bits == 1\n+      && TREE_CODE (m_cst_expr) == INTEGER_CST\n+      && type\n+      && INTEGRAL_TYPE_P (type)\n+      && tree_fits_uhwi_p (m_cst_expr))\n+    {\n+      unsigned HOST_WIDE_INT bit = bits.m_start_bit_offset.to_uhwi ();\n+      unsigned HOST_WIDE_INT mask = (1 << bit);\n+      unsigned HOST_WIDE_INT val_as_hwi = tree_to_uhwi (m_cst_expr);\n+      unsigned HOST_WIDE_INT masked_val = val_as_hwi & mask;\n+      int result = masked_val ? 1 : 0;\n+      return mgr->get_or_create_int_cst (type, result);\n+    }\n+\n   /* Otherwise, don't fold.  */\n   return NULL;\n }\n@@ -1728,13 +1738,17 @@ unmergeable_svalue::implicitly_live_p (const svalue_set *live_svalues,\n compound_svalue::compound_svalue (tree type, const binding_map &map)\n : svalue (calc_complexity (map), type), m_map (map)\n {\n-  /* All keys within the underlying binding_map are required to be concrete,\n-     not symbolic.  */\n #if CHECKING_P\n   for (iterator_t iter = begin (); iter != end (); ++iter)\n     {\n+      /* All keys within the underlying binding_map are required to be concrete,\n+\t not symbolic.  */\n       const binding_key *key = (*iter).first;\n       gcc_assert (key->concrete_p ());\n+\n+      /* We don't nest compound svalues.  */\n+      const svalue *sval = (*iter).second;\n+      gcc_assert (sval->get_kind () != SK_COMPOUND);\n     }\n #endif\n }"}, {"sha": "382b083d76a17e8a29944ecff1d977d82eaaeb5e", "filename": "gcc/analyzer/svalue.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_ANALYZER_SVALUE_H\n \n #include \"analyzer/complexity.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/program-point.h\"\n \n using namespace ana;\n \n@@ -1113,9 +1115,9 @@ class widening_svalue : public svalue\n   /* A support class for uniquifying instances of widening_svalue.  */\n   struct key_t\n   {\n-    key_t (tree type, const program_point &point,\n+    key_t (tree type, const function_point &point,\n \t   const svalue *base_sval, const svalue *iter_sval)\n-    : m_type (type), m_point (point.get_function_point ()),\n+    : m_type (type), m_point (point),\n       m_base_sval (base_sval), m_iter_sval (iter_sval)\n     {}\n \n@@ -1153,12 +1155,12 @@ class widening_svalue : public svalue\n      DIR_UNKNOWN\n     };\n \n-  widening_svalue (tree type, const program_point &point,\n+  widening_svalue (tree type, const function_point &point,\n \t\t   const svalue *base_sval, const svalue *iter_sval)\n   : svalue (complexity::from_pair (base_sval->get_complexity (),\n \t\t\t\t   iter_sval->get_complexity ()),\n \t    type),\n-    m_point (point.get_function_point ()),\n+    m_point (point),\n     m_base_sval (base_sval), m_iter_sval (iter_sval)\n   {\n     gcc_assert (base_sval->can_have_associated_state_p ());\n@@ -1527,6 +1529,7 @@ class asm_output_svalue : public svalue\n \n   const char *get_asm_string () const { return m_asm_string; }\n   unsigned get_output_idx () const { return m_output_idx; }\n+  unsigned get_num_outputs () const { return m_num_outputs; }\n   unsigned get_num_inputs () const { return m_num_inputs; }\n   const svalue *get_input (unsigned idx) const { return m_input_arr[idx]; }\n "}, {"sha": "9fdb4a9e240ad0d4f61bfc54e2591e42372bf2d3", "filename": "gcc/analyzer/trimmed-graph.cc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Ftrimmed-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Ftrimmed-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ftrimmed-graph.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -29,15 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"diagnostic-event-id.h\"\n #include \"diagnostic-path.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n-#include \"shortest-paths.h\"\n-#include \"sbitmap.h\"\n #include \"bitmap.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"ordered-hash-map.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n@@ -48,12 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/constraint-manager.h\"\n-#include \"cfg.h\"\n-#include \"basic-block.h\"\n-#include \"gimple.h\"\n-#include \"gimple-iterator.h\"\n-#include \"cgraph.h\"\n-#include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/exploded-graph.h\""}, {"sha": "e4dbad79f424bfd9beddad6a7946e0e36b9b5531", "filename": "gcc/analyzer/varargs.cc", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fanalyzer%2Fvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fvarargs.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -26,28 +26,17 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"gimple.h\"\n #include \"diagnostic-path.h\"\n-#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n-#include \"tristate.h\"\n-#include \"selftest.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/checker-path.h\"\n-#include \"digraph.h\"\n-#include \"ordered-hash-map.h\"\n-#include \"cfg.h\"\n-#include \"gimple-iterator.h\"\n #include \"analyzer/supergraph.h\"\n-#include \"alloc-pool.h\"\n-#include \"fibonacci_heap.h\"\n-#include \"shortest-paths.h\"\n-#include \"sbitmap.h\"\n #include \"analyzer/diagnostic-manager.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"diagnostic-metadata.h\"\n@@ -143,7 +132,7 @@ namespace ana {\n      __builtin_va_start (&ap, [...]);\n \n    except for the 2nd param of __builtin_va_copy, where the type\n-   is already target-dependent (see the discussion of BT_VALIST_ARG\n+   is already target-dependent (see the discussion of get_va_copy_arg\n    below).  */\n \n /* Get a tree for diagnostics.\n@@ -158,26 +147,32 @@ get_va_list_diag_arg (tree va_list_tree)\n   return va_list_tree;\n }\n \n-/* Get argument ARG_IDX of type BT_VALIST_ARG (for use by va_copy).\n+/* Get argument ARG_IDX of va_copy.\n \n    builtin-types.def has:\n      DEF_PRIMITIVE_TYPE (BT_VALIST_ARG, va_list_arg_type_node)\n \n    and c_common_nodes_and_builtins initializes va_list_arg_type_node\n    based on whether TREE_CODE (va_list_type_node) is of ARRAY_TYPE or\n-   not, giving either one or zero levels of indirection.  */\n+   not, giving either one or zero levels of indirection.\n+\n+   Alternatively we could be dealing with __builtin_ms_va_copy or\n+   __builtin_sysv_va_copy.\n+\n+   Handle this by looking at the types of the argument in question.  */\n \n static const svalue *\n-get_BT_VALIST_ARG (const region_model *model,\n-\t\t   region_model_context *ctxt,\n-\t\t   const gcall *call,\n-\t\t   unsigned arg_idx)\n+get_va_copy_arg (const region_model *model,\n+\t\t region_model_context *ctxt,\n+\t\t const gcall *call,\n+\t\t unsigned arg_idx)\n {\n   tree arg = gimple_call_arg (call, arg_idx);\n   const svalue *arg_sval = model->get_rvalue (arg, ctxt);\n   if (const svalue *cast = arg_sval->maybe_undo_cast ())\n     arg_sval = cast;\n-  if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n+  if (TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == ARRAY_TYPE)\n     {\n       /* va_list_arg_type_node is a pointer to a va_list;\n \t return *ARG_SVAL.  */\n@@ -562,19 +557,19 @@ va_list_state_machine::check_for_ended_va_list (sm_context *sm_ctxt,\n \t\t\t\t\t\t usage_fnname));\n }\n \n-/* Get the svalue with associated va_list_state_machine state for a\n-   BT_VALIST_ARG for ARG_IDX of CALL, if SM_CTXT supports this,\n+/* Get the svalue with associated va_list_state_machine state for\n+   ARG_IDX of CALL to va_copy, if SM_CTXT supports this,\n    or NULL otherwise.  */\n \n static const svalue *\n-get_stateful_BT_VALIST_ARG (sm_context *sm_ctxt,\n-\t\t\t    const gcall *call,\n-\t\t\t    unsigned arg_idx)\n+get_stateful_va_copy_arg (sm_context *sm_ctxt,\n+\t\t\t  const gcall *call,\n+\t\t\t  unsigned arg_idx)\n {\n   if (const program_state *new_state = sm_ctxt->get_new_program_state ())\n     {\n       const region_model *new_model = new_state->m_region_model;\n-      const svalue *arg = get_BT_VALIST_ARG (new_model, NULL, call, arg_idx);\n+      const svalue *arg = get_va_copy_arg (new_model, NULL, call, arg_idx);\n       return arg;\n     }\n   return NULL;\n@@ -587,7 +582,7 @@ va_list_state_machine::on_va_copy (sm_context *sm_ctxt,\n \t\t\t\t   const supernode *node,\n \t\t\t\t   const gcall *call) const\n {\n-  const svalue *src_arg = get_stateful_BT_VALIST_ARG (sm_ctxt, call, 1);\n+  const svalue *src_arg = get_stateful_va_copy_arg (sm_ctxt, call, 1);\n   if (src_arg)\n     check_for_ended_va_list (sm_ctxt, node, call, src_arg, \"va_copy\");\n \n@@ -697,7 +692,7 @@ region_model::impl_call_va_copy (const call_details &cd)\n {\n   const svalue *out_dst_ptr = cd.get_arg_svalue (0);\n   const svalue *in_va_list\n-    = get_BT_VALIST_ARG (this, cd.get_ctxt (), cd.get_call_stmt (), 1);\n+    = get_va_copy_arg (this, cd.get_ctxt (), cd.get_call_stmt (), 1);\n   in_va_list = check_for_poison (in_va_list,\n \t\t\t\t get_va_list_diag_arg (cd.get_arg_tree (1)),\n \t\t\t\t cd.get_ctxt ());"}, {"sha": "27dea7485616a40c55dbbae10002386c887c9b77", "filename": "gcc/attribs.cc", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fattribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fattribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -251,6 +251,7 @@ handle_ignored_attributes_option (vec<char *> *v)\n       /* We don't accept '::attr'.  */\n       if (cln == nullptr || cln == opt)\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"wrong argument to ignored attributes\");\n \t  inform (input_location, \"valid format is %<ns::attr%> or %<ns::%>\");\n \t  continue;\n@@ -732,6 +733,7 @@ decl_attributes (tree *node, tree attributes, int flags,\n \t      || (spec->max_length >= 0\n \t\t  && nargs > spec->max_length))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error (\"wrong number of arguments specified for %qE attribute\",\n \t\t     name);\n \t      if (spec->max_length < 0)\n@@ -1167,6 +1169,7 @@ common_function_versions (tree fn1, tree fn2)\n \t      std::swap (fn1, fn2);\n \t      attr1 = attr2;\n \t    }\n+\t  auto_diagnostic_group d;\n \t  error_at (DECL_SOURCE_LOCATION (fn2),\n \t\t    \"missing %<target%> attribute for multi-versioned %qD\",\n \t\t    fn2);\n@@ -1642,6 +1645,33 @@ remove_attribute (const char *attr_name, tree list)\n   return list;\n }\n \n+/* Similarly but also match namespace on the removed attributes.\n+   ATTR_NS \"\" stands for NULL or \"gnu\" namespace.  */\n+\n+tree\n+remove_attribute (const char *attr_ns, const char *attr_name, tree list)\n+{\n+  tree *p;\n+  gcc_checking_assert (attr_name[0] != '_');\n+  gcc_checking_assert (attr_ns == NULL || attr_ns[0] != '_');\n+\n+  for (p = &list; *p;)\n+    {\n+      tree l = *p;\n+\n+      tree attr = get_attribute_name (l);\n+      if (is_attribute_p (attr_name, attr)\n+\t  && is_attribute_namespace_p (attr_ns, l))\n+\t{\n+\t  *p = TREE_CHAIN (l);\n+\t  continue;\n+\t}\n+      p = &TREE_CHAIN (l);\n+    }\n+\n+  return list;\n+}\n+\n /* Return an attribute list that is the union of a1 and a2.  */\n \n tree\n@@ -2039,6 +2069,45 @@ private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n   return list;\n }\n \n+/* Similarly but with also attribute namespace.  */\n+\n+tree\n+private_lookup_attribute (const char *attr_ns, const char *attr_name,\n+\t\t\t  size_t attr_ns_len, size_t attr_len, tree list)\n+{\n+  while (list)\n+    {\n+      tree attr = get_attribute_name (list);\n+      size_t ident_len = IDENTIFIER_LENGTH (attr);\n+      if (cmp_attribs (attr_name, attr_len, IDENTIFIER_POINTER (attr),\n+\t\t       ident_len))\n+\t{\n+\t  tree ns = get_attribute_namespace (list);\n+\t  if (ns == NULL_TREE)\n+\t    {\n+\t      if (attr_ns_len == 0)\n+\t\tbreak;\n+\t    }\n+\t  else if (attr_ns)\n+\t    {\n+\t      ident_len = IDENTIFIER_LENGTH (ns);\n+\t      if (attr_ns_len == 0)\n+\t\t{\n+\t\t  if (cmp_attribs (\"gnu\", strlen (\"gnu\"),\n+\t\t\t\t   IDENTIFIER_POINTER (ns), ident_len))\n+\t\t    break;\n+\t\t}\n+\t      else if (cmp_attribs (attr_ns, attr_ns_len,\n+\t\t\t\t    IDENTIFIER_POINTER (ns), ident_len))\n+\t\tbreak;\n+\t    }\n+\t}\n+      list = TREE_CHAIN (list);\n+    }\n+\n+  return list;\n+}\n+\n /* Return true if the function decl or type NODE has been declared\n    with attribute ANAME among attributes ATTRS.  */\n "}, {"sha": "1dc16e4bc4e949d263b5b531db05d0c2f27217c4", "filename": "gcc/attribs.h", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -82,6 +82,10 @@ extern tree merge_type_attributes (tree, tree);\n \n extern tree remove_attribute (const char *, tree);\n \n+/* Similarly but also with specific attribute namespace.  */\n+\n+extern tree remove_attribute (const char *, const char *, tree);\n+\n /* Given two attributes lists, return a list of their union.  */\n \n extern tree merge_attributes (tree, tree);\n@@ -113,6 +117,10 @@ extern int attribute_list_contained (const_tree, const_tree);\n    for size.  */\n extern tree private_lookup_attribute (const char *attr_name, size_t attr_len,\n \t\t\t\t      tree list);\n+extern tree private_lookup_attribute (const char *attr_ns,\n+\t\t\t\t      const char *attr_name,\n+\t\t\t\t      size_t attr_ns_len, size_t attr_len,\n+\t\t\t\t      tree list);\n \n extern unsigned decls_mismatched_attributes (tree, tree, tree,\n \t\t\t\t\t     const char* const[],\n@@ -180,6 +188,22 @@ is_attribute_p (const char *attr_name, const_tree ident)\n \t\t      IDENTIFIER_POINTER (ident), IDENTIFIER_LENGTH (ident));\n }\n \n+/* Given an attribute ATTR and a string ATTR_NS, return true\n+   if the attribute namespace is valid for the string.  ATTR_NS \"\" stands\n+   for standard attribute (NULL get_attribute_namespace) or \"gnu\"\n+   namespace.  */\n+\n+static inline bool\n+is_attribute_namespace_p (const char *attr_ns, const_tree attr)\n+{\n+  tree ident = get_attribute_namespace (attr);\n+  if (attr_ns == NULL)\n+    return ident == NULL_TREE;\n+  if (attr_ns[0])\n+    return ident && is_attribute_p (attr_ns, ident);\n+  return ident == NULL_TREE || is_attribute_p (\"gnu\", ident);\n+}\n+\n /* Given an attribute name ATTR_NAME and a list of attributes LIST,\n    return a pointer to the attribute's list element if the attribute\n    is part of the list, or NULL_TREE if not found.  If the attribute\n@@ -209,6 +233,37 @@ lookup_attribute (const char *attr_name, tree list)\n     }\n }\n \n+/* Similar to lookup_attribute, but also match the attribute namespace.\n+   ATTR_NS \"\" stands for either standard attribute or \"gnu\" namespace.  */\n+\n+static inline tree\n+lookup_attribute (const char *attr_ns, const char *attr_name, tree list)\n+{\n+  if (CHECKING_P && attr_name[0] != '_')\n+    {\n+      size_t attr_len = strlen (attr_name);\n+      gcc_checking_assert (!canonicalize_attr_name (attr_name, attr_len));\n+    }\n+  if (CHECKING_P && attr_ns && attr_ns[0] != '_')\n+    {\n+      size_t attr_ns_len = strlen (attr_ns);\n+      gcc_checking_assert (!canonicalize_attr_name (attr_ns, attr_ns_len));\n+    }\n+  /* In most cases, list is NULL_TREE.  */\n+  if (list == NULL_TREE)\n+    return NULL_TREE;\n+  else\n+    {\n+      size_t attr_ns_len = attr_ns ? strlen (attr_ns) : 0;\n+      size_t attr_len = strlen (attr_name);\n+      /* Do the strlen() before calling the out-of-line implementation.\n+\t In most cases attr_name is a string constant, and the compiler\n+\t will optimize the strlen() away.  */\n+      return private_lookup_attribute (attr_ns, attr_name,\n+\t\t\t\t       attr_ns_len, attr_len, list);\n+    }\n+}\n+\n /* Given an attribute name ATTR_NAME and a list of attributes LIST,\n    return a pointer to the attribute's list first element if the attribute\n    starts with ATTR_NAME.  ATTR_NAME must be in the form 'text' (not\n@@ -236,8 +291,8 @@ lookup_attribute_by_prefix (const char *attr_name, tree list)\n \t    }\n \n \t  const char *p = IDENTIFIER_POINTER (name);\n-\t  gcc_checking_assert (attr_len == 0 || p[0] != '_');\n-\n+\t  gcc_checking_assert (attr_len == 0 || p[0] != '_'\n+\t\t\t       || (ident_len > 1 && p[1] != '_'));\n \t  if (strncmp (attr_name, p, attr_len) == 0)\n \t    break;\n "}, {"sha": "97307321cbfa1b5eb63dbf27dd8887572cba510e", "filename": "gcc/auto-profile.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fauto-profile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fauto-profile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -363,7 +363,8 @@ get_combined_location (location_t loc, tree decl)\n   /* TODO: allow more bits for line and less bits for discriminator.  */\n   if (LOCATION_LINE (loc) - DECL_SOURCE_LINE (decl) >= (1<<16))\n     warning_at (loc, OPT_Woverflow, \"offset exceeds 16 bytes\");\n-  return ((LOCATION_LINE (loc) - DECL_SOURCE_LINE (decl)) << 16);\n+  return ((LOCATION_LINE (loc) - DECL_SOURCE_LINE (decl)) << 16)\n+\t | get_discriminator_from_loc (loc);\n }\n \n /* Return the function decl of a given lexical BLOCK.  */\n@@ -388,7 +389,6 @@ get_inline_stack (location_t locus, inline_stack *stack)\n   tree block = LOCATION_BLOCK (locus);\n   if (block && TREE_CODE (block) == BLOCK)\n     {\n-      int level = 0;\n       for (block = BLOCK_SUPERCONTEXT (block);\n            block && (TREE_CODE (block) == BLOCK);\n            block = BLOCK_SUPERCONTEXT (block))\n@@ -401,7 +401,6 @@ get_inline_stack (location_t locus, inline_stack *stack)\n           stack->safe_push (\n               std::make_pair (decl, get_combined_location (locus, decl)));\n           locus = tmp_locus;\n-          level++;\n         }\n     }\n   stack->safe_push (\n@@ -654,7 +653,7 @@ function_instance::read_function_instance (function_instance_stack *stack,\n \n   for (unsigned i = 0; i < num_pos_counts; i++)\n     {\n-      unsigned offset = gcov_read_unsigned () & 0xffff0000;\n+      unsigned offset = gcov_read_unsigned ();\n       unsigned num_targets = gcov_read_unsigned ();\n       gcov_type count = gcov_read_counter ();\n       s->pos_counts[offset].count = count;"}, {"sha": "1eae03d1acad05df7ddacafc7ce8dd146bacea85", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -148,11 +148,6 @@ struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_d\n \n   /* Expected number of executions: calculated in profile.cc.  */\n   profile_count count;\n-\n-  /* The discriminator for this block.  The discriminator distinguishes\n-     among several basic blocks that share a common locus, allowing for\n-     more accurate sample-based profiling.  */\n-  int discriminator;\n };\n \n /* This ensures that struct gimple_bb_info is smaller than"}, {"sha": "aef9fd70a283c2a2804c8e2c1ab5489600e562d1", "filename": "gcc/btfout.cc", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbtfout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbtfout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbtfout.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -223,7 +223,9 @@ btf_calc_num_vbytes (ctf_dtdef_ref dtd)\n       break;\n \n     case BTF_KIND_ENUM:\n-      vlen_bytes += vlen * sizeof (struct btf_enum);\n+      vlen_bytes += (dtd->dtd_data.ctti_size == 0x8)\n+\t\t\t? vlen * sizeof (struct btf_enum64)\n+\t\t\t: vlen * sizeof (struct btf_enum);\n       break;\n \n     case BTF_KIND_FUNC_PROTO:\n@@ -622,6 +624,15 @@ btf_asm_type (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n       btf_size_type = 0;\n     }\n \n+  if (btf_kind == BTF_KIND_ENUM)\n+    {\n+      btf_kflag = dtd->dtd_enum_unsigned\n+\t\t    ? BTF_KF_ENUM_UNSIGNED\n+\t\t    : BTF_KF_ENUM_SIGNED;\n+      if (dtd->dtd_data.ctti_size == 0x8)\n+\tbtf_kind = BTF_KIND_ENUM64;\n+   }\n+\n   dw2_asm_output_data (4, dtd->dtd_data.ctti_name, \"btt_name\");\n   dw2_asm_output_data (4, BTF_TYPE_INFO (btf_kind, btf_kflag, btf_vlen),\n \t\t       \"btt_info: kind=%u, kflag=%u, vlen=%u\",\n@@ -634,6 +645,7 @@ btf_asm_type (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n     case BTF_KIND_UNION:\n     case BTF_KIND_ENUM:\n     case BTF_KIND_DATASEC:\n+    case BTF_KIND_ENUM64:\n       dw2_asm_output_data (4, dtd->dtd_data.ctti_size, \"btt_size: %uB\",\n \t\t\t   dtd->dtd_data.ctti_size);\n       return;\n@@ -707,13 +719,19 @@ btf_asm_sou_member (ctf_container_ref ctfc, ctf_dmdef_t * dmd)\n     }\n }\n \n-/* Asm'out an enum constant following a BTF_KIND_ENUM.  */\n+/* Asm'out an enum constant following a BTF_KIND_ENUM{,64}.  */\n \n static void\n-btf_asm_enum_const (ctf_dmdef_t * dmd)\n+btf_asm_enum_const (unsigned int size, ctf_dmdef_t * dmd)\n {\n   dw2_asm_output_data (4, dmd->dmd_name_offset, \"bte_name\");\n-  dw2_asm_output_data (4, dmd->dmd_value, \"bte_value\");\n+  if (size == 4)\n+    dw2_asm_output_data (size, dmd->dmd_value, \"bte_value\");\n+  else\n+    {\n+      dw2_asm_output_data (4, dmd->dmd_value & 0xffffffff, \"bte_value_lo32\");\n+      dw2_asm_output_data (4, (dmd->dmd_value >> 32) & 0xffffffff, \"bte_value_hi32\");\n+    }\n }\n \n /* Asm'out a function parameter description following a BTF_KIND_FUNC_PROTO.  */\n@@ -871,7 +889,7 @@ output_asm_btf_sou_fields (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n       btf_asm_sou_member (ctfc, dmd);\n }\n \n-/* Output all enumerator constants following a BTF_KIND_ENUM.  */\n+/* Output all enumerator constants following a BTF_KIND_ENUM{,64}.  */\n \n static void\n output_asm_btf_enum_list (ctf_container_ref ARG_UNUSED (ctfc),\n@@ -881,7 +899,7 @@ output_asm_btf_enum_list (ctf_container_ref ARG_UNUSED (ctfc),\n \n   for (dmd = dtd->dtd_u.dtu_members;\n        dmd != NULL; dmd = (ctf_dmdef_t *) ctf_dmd_list_next (dmd))\n-    btf_asm_enum_const (dmd);\n+    btf_asm_enum_const (dtd->dtd_data.ctti_size, dmd);\n }\n \n /* Output all function arguments following a BTF_KIND_FUNC_PROTO.  */"}, {"sha": "e1e25e9c48fbf30edade83311ea23bfac0838c9f", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -82,6 +82,9 @@ DEF_PRIMITIVE_TYPE (BT_UNWINDWORD, (*lang_hooks.types.type_for_mode)\n DEF_PRIMITIVE_TYPE (BT_FLOAT, float_type_node)\n DEF_PRIMITIVE_TYPE (BT_DOUBLE, double_type_node)\n DEF_PRIMITIVE_TYPE (BT_LONGDOUBLE, long_double_type_node)\n+DEF_PRIMITIVE_TYPE (BT_BFLOAT16, (bfloat16_type_node\n+\t\t\t\t  ? bfloat16_type_node\n+\t\t\t\t  : error_mark_node))\n DEF_PRIMITIVE_TYPE (BT_FLOAT16, (float16_type_node\n \t\t\t\t ? float16_type_node\n \t\t\t\t : error_mark_node))\n@@ -106,6 +109,34 @@ DEF_PRIMITIVE_TYPE (BT_FLOAT128X, (float128x_type_node\n DEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT, complex_float_type_node)\n DEF_PRIMITIVE_TYPE (BT_COMPLEX_DOUBLE, complex_double_type_node)\n DEF_PRIMITIVE_TYPE (BT_COMPLEX_LONGDOUBLE, complex_long_double_type_node)\n+DEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT16, (float16_type_node\n+\t\t\t\t\t ? build_complex_type\n+\t\t\t\t\t\t(float16_type_node)\n+\t\t\t\t\t : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT32, (float32_type_node\n+\t\t\t\t\t ? build_complex_type\n+\t\t\t\t\t\t(float32_type_node)\n+\t\t\t\t\t : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT64, (float64_type_node\n+\t\t\t\t\t ? build_complex_type\n+\t\t\t\t\t\t(float64_type_node)\n+\t\t\t\t\t : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT128, (float128_type_node\n+\t\t\t\t\t  ? build_complex_type\n+\t\t\t\t\t\t(float128_type_node)\n+\t\t\t\t\t  : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT32X, (float32x_type_node\n+\t\t\t\t\t  ? build_complex_type\n+\t\t\t\t\t\t(float32x_type_node)\n+\t\t\t\t\t  : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT64X, (float64x_type_node\n+\t\t\t\t\t  ? build_complex_type\n+\t\t\t\t\t\t(float64x_type_node)\n+\t\t\t\t\t  : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT128X, (float128x_type_node\n+\t\t\t\t\t   ? build_complex_type\n+\t\t\t\t\t\t(float128x_type_node)\n+\t\t\t\t\t   : error_mark_node))\n \n DEF_PRIMITIVE_TYPE (BT_PTR, ptr_type_node)\n DEF_PRIMITIVE_TYPE (BT_FILEPTR, fileptr_type_node)\n@@ -132,6 +163,27 @@ DEF_PRIMITIVE_TYPE (BT_CONST_DOUBLE_PTR,\n \t\t     (build_qualified_type (double_type_node,\n \t\t     \t\t\t    TYPE_QUAL_CONST)))\n DEF_PRIMITIVE_TYPE (BT_LONGDOUBLE_PTR, long_double_ptr_type_node)\n+DEF_PRIMITIVE_TYPE (BT_FLOAT16_PTR, (float16_type_node\n+\t\t\t\t      ? build_pointer_type (float16_type_node)\n+\t\t\t\t      : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_FLOAT32_PTR, (float32_type_node\n+\t\t\t\t      ? build_pointer_type (float32_type_node)\n+\t\t\t\t      : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_FLOAT64_PTR, (float64_type_node\n+\t\t\t\t      ? build_pointer_type (float64_type_node)\n+\t\t\t\t      : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_FLOAT128_PTR, (float128_type_node\n+\t\t\t\t      ? build_pointer_type (float128_type_node)\n+\t\t\t\t      : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_FLOAT32X_PTR, (float32x_type_node\n+\t\t\t\t      ? build_pointer_type (float32x_type_node)\n+\t\t\t\t      : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_FLOAT64X_PTR, (float64x_type_node\n+\t\t\t\t      ? build_pointer_type (float64x_type_node)\n+\t\t\t\t      : error_mark_node))\n+DEF_PRIMITIVE_TYPE (BT_FLOAT128X_PTR, (float128x_type_node\n+\t\t\t\t      ? build_pointer_type (float128x_type_node)\n+\t\t\t\t      : error_mark_node))\n DEF_PRIMITIVE_TYPE (BT_PID, pid_type_node)\n DEF_PRIMITIVE_TYPE (BT_SIZE, size_type_node)\n DEF_PRIMITIVE_TYPE (BT_CONST_SIZE,\n@@ -218,12 +270,40 @@ DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE,\n \t\t     BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n \t\t     BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT16_COMPLEX_FLOAT16,\n+\t\t     BT_COMPLEX_FLOAT16, BT_COMPLEX_FLOAT16)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT32_COMPLEX_FLOAT32,\n+\t\t     BT_COMPLEX_FLOAT32, BT_COMPLEX_FLOAT32)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT64_COMPLEX_FLOAT64,\n+\t\t     BT_COMPLEX_FLOAT64, BT_COMPLEX_FLOAT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT128_COMPLEX_FLOAT128,\n+\t\t     BT_COMPLEX_FLOAT128, BT_COMPLEX_FLOAT128)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT32X_COMPLEX_FLOAT32X,\n+\t\t     BT_COMPLEX_FLOAT32X, BT_COMPLEX_FLOAT32X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT64X_COMPLEX_FLOAT64X,\n+\t\t     BT_COMPLEX_FLOAT64X, BT_COMPLEX_FLOAT64X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT128X_COMPLEX_FLOAT128X,\n+\t\t     BT_COMPLEX_FLOAT128X, BT_COMPLEX_FLOAT128X)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_COMPLEX_FLOAT,\n \t\t     BT_FLOAT, BT_COMPLEX_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_COMPLEX_DOUBLE,\n \t\t     BT_DOUBLE, BT_COMPLEX_DOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n \t\t     BT_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT16_COMPLEX_FLOAT16,\n+\t\t     BT_FLOAT16, BT_COMPLEX_FLOAT16)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT32_COMPLEX_FLOAT32,\n+\t\t     BT_FLOAT32, BT_COMPLEX_FLOAT32)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT64_COMPLEX_FLOAT64,\n+\t\t     BT_FLOAT64, BT_COMPLEX_FLOAT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT128_COMPLEX_FLOAT128,\n+\t\t     BT_FLOAT128, BT_COMPLEX_FLOAT128)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT32X_COMPLEX_FLOAT32X,\n+\t\t     BT_FLOAT32X, BT_COMPLEX_FLOAT32X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT64X_COMPLEX_FLOAT64X,\n+\t\t     BT_FLOAT64X, BT_COMPLEX_FLOAT64X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT128X_COMPLEX_FLOAT128X,\n+\t\t     BT_FLOAT128X, BT_COMPLEX_FLOAT128X)\n DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT_FLOAT,\n \t\t     BT_COMPLEX_FLOAT, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_DOUBLE_DOUBLE,\n@@ -244,15 +324,36 @@ DEF_FUNCTION_TYPE_1 (BT_FN_INT_PTR, BT_INT, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT, BT_INT, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_DOUBLE, BT_INT, BT_DOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_LONGDOUBLE, BT_INT, BT_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT16, BT_INT, BT_FLOAT16)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT32, BT_INT, BT_FLOAT32)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT64, BT_INT, BT_FLOAT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT128, BT_INT, BT_FLOAT128)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT32X, BT_INT, BT_FLOAT32X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT64X, BT_INT, BT_FLOAT64X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT128X, BT_INT, BT_FLOAT128X)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_DFLOAT32, BT_INT, BT_DFLOAT32)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_DFLOAT64, BT_INT, BT_DFLOAT64)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_DFLOAT128, BT_INT, BT_DFLOAT128)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT, BT_LONG, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONG_DOUBLE, BT_LONG, BT_DOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONG_LONGDOUBLE, BT_LONG, BT_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT16, BT_LONG, BT_FLOAT16)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT32, BT_LONG, BT_FLOAT32)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT64, BT_LONG, BT_FLOAT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT128, BT_LONG, BT_FLOAT128)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT32X, BT_LONG, BT_FLOAT32X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT64X, BT_LONG, BT_FLOAT64X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT128X, BT_LONG, BT_FLOAT128X)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT, BT_LONGLONG, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_DOUBLE, BT_LONGLONG, BT_DOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_LONGDOUBLE, BT_LONGLONG, BT_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT16, BT_LONGLONG, BT_FLOAT16)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT32, BT_LONGLONG, BT_FLOAT32)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT64, BT_LONGLONG, BT_FLOAT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT128, BT_LONGLONG, BT_FLOAT128)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT32X, BT_LONGLONG, BT_FLOAT32X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT64X, BT_LONGLONG, BT_FLOAT64X)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT128X, BT_LONGLONG, BT_FLOAT128X)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTR, BT_VOID, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_SIZE_CONST_STRING, BT_SIZE, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_CONST_STRING, BT_INT, BT_CONST_STRING)\n@@ -264,6 +365,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_CONST_STRING, BT_FLOAT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_CONST_STRING, BT_DOUBLE, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_CONST_STRING,\n \t\t     BT_LONGDOUBLE, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_1 (BT_FN_BFLOAT16_CONST_STRING, BT_BFLOAT16, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT16_CONST_STRING, BT_FLOAT16, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT32_CONST_STRING, BT_FLOAT32, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT64_CONST_STRING, BT_FLOAT64, BT_CONST_STRING)\n@@ -415,12 +517,28 @@ DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64X_FLOAT64X_FLOAT64X,\n \t\t     BT_FLOAT64X, BT_FLOAT64X, BT_FLOAT64X)\n DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128X_FLOAT128X_FLOAT128X,\n \t\t     BT_FLOAT128X, BT_FLOAT128X, BT_FLOAT128X)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BFLOAT16_BFLOAT16_BFLOAT16,\n+\t\t     BT_BFLOAT16, BT_BFLOAT16, BT_BFLOAT16)\n DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_FLOATPTR,\n \t\t     BT_FLOAT, BT_FLOAT, BT_FLOAT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_DOUBLEPTR,\n \t\t     BT_DOUBLE, BT_DOUBLE, BT_DOUBLE_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLEPTR,\n \t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONGDOUBLE_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT16_FLOAT16_FLOAT16PTR,\n+\t\t     BT_FLOAT16, BT_FLOAT16, BT_FLOAT16_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT32_FLOAT32_FLOAT32PTR,\n+\t\t     BT_FLOAT32, BT_FLOAT32, BT_FLOAT32_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64_FLOAT64_FLOAT64PTR,\n+\t\t     BT_FLOAT64, BT_FLOAT64, BT_FLOAT64_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128_FLOAT128_FLOAT128PTR,\n+\t\t     BT_FLOAT128, BT_FLOAT128, BT_FLOAT128_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT32X_FLOAT32X_FLOAT32XPTR,\n+\t\t     BT_FLOAT32X, BT_FLOAT32X, BT_FLOAT32X_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64X_FLOAT64X_FLOAT64XPTR,\n+\t\t     BT_FLOAT64X, BT_FLOAT64X, BT_FLOAT64X_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128X_FLOAT128X_FLOAT128XPTR,\n+\t\t     BT_FLOAT128X, BT_FLOAT128X, BT_FLOAT128X_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_LONGDOUBLE,\n \t\t     BT_FLOAT, BT_FLOAT, BT_LONGDOUBLE)\n DEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_LONGDOUBLE,\n@@ -431,12 +549,40 @@ DEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_INT,\n \t\t     BT_DOUBLE, BT_DOUBLE, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_INT,\n \t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT16_FLOAT16_INT,\n+\t\t     BT_FLOAT16, BT_FLOAT16, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT32_FLOAT32_INT,\n+\t\t     BT_FLOAT32, BT_FLOAT32, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64_FLOAT64_INT,\n+\t\t     BT_FLOAT64, BT_FLOAT64, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128_FLOAT128_INT,\n+\t\t     BT_FLOAT128, BT_FLOAT128, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT32X_FLOAT32X_INT,\n+\t\t     BT_FLOAT32X, BT_FLOAT32X, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64X_FLOAT64X_INT,\n+\t\t     BT_FLOAT64X, BT_FLOAT64X, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128X_FLOAT128X_INT,\n+\t\t     BT_FLOAT128X, BT_FLOAT128X, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_INTPTR,\n \t\t     BT_FLOAT, BT_FLOAT, BT_INT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_INTPTR,\n \t\t     BT_DOUBLE, BT_DOUBLE, BT_INT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_INTPTR,\n \t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT16_FLOAT16_INTPTR,\n+\t\t     BT_FLOAT16, BT_FLOAT16, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT32_FLOAT32_INTPTR,\n+\t\t     BT_FLOAT32, BT_FLOAT32, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64_FLOAT64_INTPTR,\n+\t\t     BT_FLOAT64, BT_FLOAT64, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128_FLOAT128_INTPTR,\n+\t\t     BT_FLOAT128, BT_FLOAT128, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT32X_FLOAT32X_INTPTR,\n+\t\t     BT_FLOAT32X, BT_FLOAT32X, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64X_FLOAT64X_INTPTR,\n+\t\t     BT_FLOAT64X, BT_FLOAT64X, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128X_FLOAT128X_INTPTR,\n+\t\t     BT_FLOAT128X, BT_FLOAT128X, BT_INT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_INT_FLOAT,\n \t\t     BT_FLOAT, BT_INT, BT_FLOAT)\n DEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_INT_DOUBLE,\n@@ -449,6 +595,20 @@ DEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_LONG,\n \t\t     BT_DOUBLE, BT_DOUBLE, BT_LONG)\n DEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_LONG,\n \t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT16_FLOAT16_LONG,\n+\t\t     BT_FLOAT16, BT_FLOAT16, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT32_FLOAT32_LONG,\n+\t\t     BT_FLOAT32, BT_FLOAT32, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64_FLOAT64_LONG,\n+\t\t     BT_FLOAT64, BT_FLOAT64, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128_FLOAT128_LONG,\n+\t\t     BT_FLOAT128, BT_FLOAT128, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT32X_FLOAT32X_LONG,\n+\t\t     BT_FLOAT32X, BT_FLOAT32X, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT64X_FLOAT64X_LONG,\n+\t\t     BT_FLOAT64X, BT_FLOAT64X, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT128X_FLOAT128X_LONG,\n+\t\t     BT_FLOAT128X, BT_FLOAT128X, BT_LONG)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_2 (BT_FN_PTR_SIZE_SIZE,\n@@ -461,6 +621,20 @@ DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE_COMPLEX_DOUBLE,\n \t\t     BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE)\n DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n \t\t     BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT16_COMPLEX_FLOAT16_COMPLEX_FLOAT16,\n+\t\t     BT_COMPLEX_FLOAT16, BT_COMPLEX_FLOAT16, BT_COMPLEX_FLOAT16)\n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT32_COMPLEX_FLOAT32_COMPLEX_FLOAT32,\n+\t\t     BT_COMPLEX_FLOAT32, BT_COMPLEX_FLOAT32, BT_COMPLEX_FLOAT32)\n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT64_COMPLEX_FLOAT64_COMPLEX_FLOAT64,\n+\t\t     BT_COMPLEX_FLOAT64, BT_COMPLEX_FLOAT64, BT_COMPLEX_FLOAT64)\n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT128_COMPLEX_FLOAT128_COMPLEX_FLOAT128,\n+\t\t     BT_COMPLEX_FLOAT128, BT_COMPLEX_FLOAT128, BT_COMPLEX_FLOAT128)\n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT32X_COMPLEX_FLOAT32X_COMPLEX_FLOAT32X,\n+\t\t     BT_COMPLEX_FLOAT32X, BT_COMPLEX_FLOAT32X, BT_COMPLEX_FLOAT32X)\n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT64X_COMPLEX_FLOAT64X_COMPLEX_FLOAT64X,\n+\t\t     BT_COMPLEX_FLOAT64X, BT_COMPLEX_FLOAT64X, BT_COMPLEX_FLOAT64X)\n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT128X_COMPLEX_FLOAT128X_COMPLEX_FLOAT128X,\n+\t\t     BT_COMPLEX_FLOAT128X, BT_COMPLEX_FLOAT128X, BT_COMPLEX_FLOAT128X)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTR, BT_VOID, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_PTR_CONST_STRING,\n \t\t     BT_INT, BT_CONST_STRING, BT_PTR_CONST_STRING)\n@@ -574,6 +748,20 @@ DEF_FUNCTION_TYPE_3 (BT_FN_DOUBLE_DOUBLE_DOUBLE_INTPTR,\n \t\t     BT_DOUBLE, BT_DOUBLE, BT_DOUBLE, BT_INT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE_INTPTR,\n \t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONGDOUBLE, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT16_FLOAT16_FLOAT16_INTPTR,\n+\t\t     BT_FLOAT16, BT_FLOAT16, BT_FLOAT16, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT32_FLOAT32_FLOAT32_INTPTR,\n+\t\t     BT_FLOAT32, BT_FLOAT32, BT_FLOAT32, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT64_FLOAT64_FLOAT64_INTPTR,\n+\t\t     BT_FLOAT64, BT_FLOAT64, BT_FLOAT64, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT128_FLOAT128_FLOAT128_INTPTR,\n+\t\t     BT_FLOAT128, BT_FLOAT128, BT_FLOAT128, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT32X_FLOAT32X_FLOAT32X_INTPTR,\n+\t\t     BT_FLOAT32X, BT_FLOAT32X, BT_FLOAT32X, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT64X_FLOAT64X_FLOAT64X_INTPTR,\n+\t\t     BT_FLOAT64X, BT_FLOAT64X, BT_FLOAT64X, BT_INT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT128X_FLOAT128X_FLOAT128X_INTPTR,\n+\t\t     BT_FLOAT128X, BT_FLOAT128X, BT_FLOAT128X, BT_INT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_FLOAT_FLOATPTR_FLOATPTR,\n \t\t     BT_VOID, BT_FLOAT, BT_FLOAT_PTR, BT_FLOAT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_DOUBLE_DOUBLEPTR_DOUBLEPTR,"}, {"sha": "b359ce2fcede9df1eec633b4f72cded36c8cb820", "filename": "gcc/builtins.cc", "status": "modified", "additions": 97, "deletions": 51, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1934,90 +1934,90 @@ mathfn_built_in_2 (tree type, combined_fn fn)\n   switch (fn)\n     {\n #define SEQ_OF_CASE_MATHFN\t\t\t\\\n-    CASE_MATHFN (ACOS)\t\t\t\t\\\n-    CASE_MATHFN (ACOSH)\t\t\t\t\\\n-    CASE_MATHFN (ASIN)\t\t\t\t\\\n-    CASE_MATHFN (ASINH)\t\t\t\t\\\n-    CASE_MATHFN (ATAN)\t\t\t\t\\\n-    CASE_MATHFN (ATAN2)\t\t\t\t\\\n-    CASE_MATHFN (ATANH)\t\t\t\t\\\n-    CASE_MATHFN (CBRT)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (ACOS)\t\t\t\\\n+    CASE_MATHFN_FLOATN (ACOSH)\t\t\t\\\n+    CASE_MATHFN_FLOATN (ASIN)\t\t\t\\\n+    CASE_MATHFN_FLOATN (ASINH)\t\t\t\\\n+    CASE_MATHFN_FLOATN (ATAN)\t\t\t\\\n+    CASE_MATHFN_FLOATN (ATAN2)\t\t\t\\\n+    CASE_MATHFN_FLOATN (ATANH)\t\t\t\\\n+    CASE_MATHFN_FLOATN (CBRT)\t\t\t\\\n     CASE_MATHFN_FLOATN (CEIL)\t\t\t\\\n     CASE_MATHFN (CEXPI)\t\t\t\t\\\n     CASE_MATHFN_FLOATN (COPYSIGN)\t\t\\\n-    CASE_MATHFN (COS)\t\t\t\t\\\n-    CASE_MATHFN (COSH)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (COS)\t\t\t\\\n+    CASE_MATHFN_FLOATN (COSH)\t\t\t\\\n     CASE_MATHFN (DREM)\t\t\t\t\\\n-    CASE_MATHFN (ERF)\t\t\t\t\\\n-    CASE_MATHFN (ERFC)\t\t\t\t\\\n-    CASE_MATHFN (EXP)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (ERF)\t\t\t\\\n+    CASE_MATHFN_FLOATN (ERFC)\t\t\t\\\n+    CASE_MATHFN_FLOATN (EXP)\t\t\t\\\n     CASE_MATHFN (EXP10)\t\t\t\t\\\n-    CASE_MATHFN (EXP2)\t\t\t\t\\\n-    CASE_MATHFN (EXPM1)\t\t\t\t\\\n-    CASE_MATHFN (FABS)\t\t\t\t\\\n-    CASE_MATHFN (FDIM)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (EXP2)\t\t\t\\\n+    CASE_MATHFN_FLOATN (EXPM1)\t\t\t\\\n+    CASE_MATHFN_FLOATN (FABS)\t\t\t\\\n+    CASE_MATHFN_FLOATN (FDIM)\t\t\t\\\n     CASE_MATHFN_FLOATN (FLOOR)\t\t\t\\\n     CASE_MATHFN_FLOATN (FMA)\t\t\t\\\n     CASE_MATHFN_FLOATN (FMAX)\t\t\t\\\n     CASE_MATHFN_FLOATN (FMIN)\t\t\t\\\n-    CASE_MATHFN (FMOD)\t\t\t\t\\\n-    CASE_MATHFN (FREXP)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (FMOD)\t\t\t\\\n+    CASE_MATHFN_FLOATN (FREXP)\t\t\t\\\n     CASE_MATHFN (GAMMA)\t\t\t\t\\\n     CASE_MATHFN_REENT (GAMMA) /* GAMMA_R */\t\\\n-    CASE_MATHFN (HUGE_VAL)\t\t\t\\\n-    CASE_MATHFN (HYPOT)\t\t\t\t\\\n-    CASE_MATHFN (ILOGB)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (HUGE_VAL)\t\t\\\n+    CASE_MATHFN_FLOATN (HYPOT)\t\t\t\\\n+    CASE_MATHFN_FLOATN (ILOGB)\t\t\t\\\n     CASE_MATHFN (ICEIL)\t\t\t\t\\\n     CASE_MATHFN (IFLOOR)\t\t\t\\\n-    CASE_MATHFN (INF)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (INF)\t\t\t\\\n     CASE_MATHFN (IRINT)\t\t\t\t\\\n     CASE_MATHFN (IROUND)\t\t\t\\\n     CASE_MATHFN (ISINF)\t\t\t\t\\\n     CASE_MATHFN (J0)\t\t\t\t\\\n     CASE_MATHFN (J1)\t\t\t\t\\\n     CASE_MATHFN (JN)\t\t\t\t\\\n     CASE_MATHFN (LCEIL)\t\t\t\t\\\n-    CASE_MATHFN (LDEXP)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (LDEXP)\t\t\t\\\n     CASE_MATHFN (LFLOOR)\t\t\t\\\n-    CASE_MATHFN (LGAMMA)\t\t\t\\\n+    CASE_MATHFN_FLOATN (LGAMMA)\t\t\t\\\n     CASE_MATHFN_REENT (LGAMMA) /* LGAMMA_R */\t\\\n     CASE_MATHFN (LLCEIL)\t\t\t\\\n     CASE_MATHFN (LLFLOOR)\t\t\t\\\n-    CASE_MATHFN (LLRINT)\t\t\t\\\n-    CASE_MATHFN (LLROUND)\t\t\t\\\n-    CASE_MATHFN (LOG)\t\t\t\t\\\n-    CASE_MATHFN (LOG10)\t\t\t\t\\\n-    CASE_MATHFN (LOG1P)\t\t\t\t\\\n-    CASE_MATHFN (LOG2)\t\t\t\t\\\n-    CASE_MATHFN (LOGB)\t\t\t\t\\\n-    CASE_MATHFN (LRINT)\t\t\t\t\\\n-    CASE_MATHFN (LROUND)\t\t\t\\\n-    CASE_MATHFN (MODF)\t\t\t\t\\\n-    CASE_MATHFN (NAN)\t\t\t\t\\\n-    CASE_MATHFN (NANS)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (LLRINT)\t\t\t\\\n+    CASE_MATHFN_FLOATN (LLROUND)\t\t\\\n+    CASE_MATHFN_FLOATN (LOG)\t\t\t\\\n+    CASE_MATHFN_FLOATN (LOG10)\t\t\t\\\n+    CASE_MATHFN_FLOATN (LOG1P)\t\t\t\\\n+    CASE_MATHFN_FLOATN (LOG2)\t\t\t\\\n+    CASE_MATHFN_FLOATN (LOGB)\t\t\t\\\n+    CASE_MATHFN_FLOATN (LRINT)\t\t\t\\\n+    CASE_MATHFN_FLOATN (LROUND)\t\t\t\\\n+    CASE_MATHFN_FLOATN (MODF)\t\t\t\\\n+    CASE_MATHFN_FLOATN (NAN)\t\t\t\\\n+    CASE_MATHFN_FLOATN (NANS)\t\t\t\\\n     CASE_MATHFN_FLOATN (NEARBYINT)\t\t\\\n-    CASE_MATHFN (NEXTAFTER)\t\t\t\\\n+    CASE_MATHFN_FLOATN (NEXTAFTER)\t\t\\\n     CASE_MATHFN (NEXTTOWARD)\t\t\t\\\n-    CASE_MATHFN (POW)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (POW)\t\t\t\\\n     CASE_MATHFN (POWI)\t\t\t\t\\\n     CASE_MATHFN (POW10)\t\t\t\t\\\n-    CASE_MATHFN (REMAINDER)\t\t\t\\\n-    CASE_MATHFN (REMQUO)\t\t\t\\\n+    CASE_MATHFN_FLOATN (REMAINDER)\t\t\\\n+    CASE_MATHFN_FLOATN (REMQUO)\t\t\t\\\n     CASE_MATHFN_FLOATN (RINT)\t\t\t\\\n     CASE_MATHFN_FLOATN (ROUND)\t\t\t\\\n     CASE_MATHFN_FLOATN (ROUNDEVEN)\t\t\\\n     CASE_MATHFN (SCALB)\t\t\t\t\\\n-    CASE_MATHFN (SCALBLN)\t\t\t\\\n-    CASE_MATHFN (SCALBN)\t\t\t\\\n+    CASE_MATHFN_FLOATN (SCALBLN)\t\t\\\n+    CASE_MATHFN_FLOATN (SCALBN)\t\t\t\\\n     CASE_MATHFN (SIGNBIT)\t\t\t\\\n     CASE_MATHFN (SIGNIFICAND)\t\t\t\\\n-    CASE_MATHFN (SIN)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (SIN)\t\t\t\\\n     CASE_MATHFN (SINCOS)\t\t\t\\\n-    CASE_MATHFN (SINH)\t\t\t\t\\\n+    CASE_MATHFN_FLOATN (SINH)\t\t\t\\\n     CASE_MATHFN_FLOATN (SQRT)\t\t\t\\\n-    CASE_MATHFN (TAN)\t\t\t\t\\\n-    CASE_MATHFN (TANH)\t\t\t\t\\\n-    CASE_MATHFN (TGAMMA)\t\t\t\\\n+    CASE_MATHFN_FLOATN (TAN)\t\t\t\\\n+    CASE_MATHFN_FLOATN (TANH)\t\t\t\\\n+    CASE_MATHFN_FLOATN (TGAMMA)\t\t\t\\\n     CASE_MATHFN_FLOATN (TRUNC)\t\t\t\\\n     CASE_MATHFN (Y0)\t\t\t\t\\\n     CASE_MATHFN (Y1)\t\t\t\t\\\n@@ -7393,6 +7393,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       /* Just do a normal library call if we were unable to fold\n \t the values.  */\n     CASE_FLT_FN (BUILT_IN_CABS):\n+    CASE_FLT_FN_FLOATN_NX (BUILT_IN_CABS):\n       break;\n \n     CASE_FLT_FN (BUILT_IN_FMA):\n@@ -9521,10 +9522,10 @@ fold_builtin_FILE (location_t loc)\n \t __FILE__ macro so it appears appropriate to use the same file prefix\n \t mappings.  */\n       fname = remap_macro_filename (fname);\n-    return build_string_literal (strlen (fname) + 1, fname);\n+      return build_string_literal (fname);\n     }\n \n-  return build_string_literal (1, \"\");\n+  return build_string_literal (\"\");\n }\n \n /* Fold a call to __builtin_FUNCTION to a constant string.  */\n@@ -9537,7 +9538,7 @@ fold_builtin_FUNCTION ()\n   if (current_function_decl)\n     name = lang_hooks.decl_printable_name (current_function_decl, 0);\n \n-  return build_string_literal (strlen (name) + 1, name);\n+  return build_string_literal (name);\n }\n \n /* Fold a call to __builtin_LINE to an integer constant.  */\n@@ -9661,6 +9662,7 @@ fold_builtin_1 (location_t loc, tree expr, tree fndecl, tree arg0)\n     break;\n \n     CASE_FLT_FN (BUILT_IN_CARG):\n+    CASE_FLT_FN_FLOATN_NX (BUILT_IN_CARG):\n       return fold_builtin_carg (loc, arg0, type);\n \n     case BUILT_IN_ISASCII:\n@@ -11350,27 +11352,43 @@ builtin_with_linkage_p (tree decl)\n     switch (DECL_FUNCTION_CODE (decl))\n     {\n       CASE_FLT_FN (BUILT_IN_ACOS):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ACOS):\n       CASE_FLT_FN (BUILT_IN_ACOSH):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ACOSH):\n       CASE_FLT_FN (BUILT_IN_ASIN):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ASIN):\n       CASE_FLT_FN (BUILT_IN_ASINH):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ASINH):\n       CASE_FLT_FN (BUILT_IN_ATAN):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ATAN):\n       CASE_FLT_FN (BUILT_IN_ATANH):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ATANH):\n       CASE_FLT_FN (BUILT_IN_ATAN2):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ATAN2):\n       CASE_FLT_FN (BUILT_IN_CBRT):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_CBRT):\n       CASE_FLT_FN (BUILT_IN_CEIL):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_CEIL):\n       CASE_FLT_FN (BUILT_IN_COPYSIGN):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_COPYSIGN):\n       CASE_FLT_FN (BUILT_IN_COS):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_COS):\n       CASE_FLT_FN (BUILT_IN_COSH):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_COSH):\n       CASE_FLT_FN (BUILT_IN_ERF):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ERF):\n       CASE_FLT_FN (BUILT_IN_ERFC):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ERFC):\n       CASE_FLT_FN (BUILT_IN_EXP):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_EXP):\n       CASE_FLT_FN (BUILT_IN_EXP2):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_EXP2):\n       CASE_FLT_FN (BUILT_IN_EXPM1):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_EXPM1):\n       CASE_FLT_FN (BUILT_IN_FABS):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_FABS):\n       CASE_FLT_FN (BUILT_IN_FDIM):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FDIM):\n       CASE_FLT_FN (BUILT_IN_FLOOR):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_FLOOR):\n       CASE_FLT_FN (BUILT_IN_FMA):\n@@ -11380,43 +11398,71 @@ builtin_with_linkage_p (tree decl)\n       CASE_FLT_FN (BUILT_IN_FMIN):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMIN):\n       CASE_FLT_FN (BUILT_IN_FMOD):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMOD):\n       CASE_FLT_FN (BUILT_IN_FREXP):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FREXP):\n       CASE_FLT_FN (BUILT_IN_HYPOT):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_HYPOT):\n       CASE_FLT_FN (BUILT_IN_ILOGB):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ILOGB):\n       CASE_FLT_FN (BUILT_IN_LDEXP):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LDEXP):\n       CASE_FLT_FN (BUILT_IN_LGAMMA):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LGAMMA):\n       CASE_FLT_FN (BUILT_IN_LLRINT):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LLRINT):\n       CASE_FLT_FN (BUILT_IN_LLROUND):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LLROUND):\n       CASE_FLT_FN (BUILT_IN_LOG):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LOG):\n       CASE_FLT_FN (BUILT_IN_LOG10):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LOG10):\n       CASE_FLT_FN (BUILT_IN_LOG1P):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LOG1P):\n       CASE_FLT_FN (BUILT_IN_LOG2):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LOG2):\n       CASE_FLT_FN (BUILT_IN_LOGB):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LOGB):\n       CASE_FLT_FN (BUILT_IN_LRINT):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LRINT):\n       CASE_FLT_FN (BUILT_IN_LROUND):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_LROUND):\n       CASE_FLT_FN (BUILT_IN_MODF):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_MODF):\n       CASE_FLT_FN (BUILT_IN_NAN):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_NAN):\n       CASE_FLT_FN (BUILT_IN_NEARBYINT):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_NEARBYINT):\n       CASE_FLT_FN (BUILT_IN_NEXTAFTER):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_NEXTAFTER):\n       CASE_FLT_FN (BUILT_IN_NEXTTOWARD):\n       CASE_FLT_FN (BUILT_IN_POW):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_POW):\n       CASE_FLT_FN (BUILT_IN_REMAINDER):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_REMAINDER):\n       CASE_FLT_FN (BUILT_IN_REMQUO):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_REMQUO):\n       CASE_FLT_FN (BUILT_IN_RINT):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_RINT):\n       CASE_FLT_FN (BUILT_IN_ROUND):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_ROUND):\n       CASE_FLT_FN (BUILT_IN_SCALBLN):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_SCALBLN):\n       CASE_FLT_FN (BUILT_IN_SCALBN):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_SCALBN):\n       CASE_FLT_FN (BUILT_IN_SIN):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_SIN):\n       CASE_FLT_FN (BUILT_IN_SINH):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_SINH):\n       CASE_FLT_FN (BUILT_IN_SINCOS):\n       CASE_FLT_FN (BUILT_IN_SQRT):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_SQRT):\n       CASE_FLT_FN (BUILT_IN_TAN):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_TAN):\n       CASE_FLT_FN (BUILT_IN_TANH):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_TANH):\n       CASE_FLT_FN (BUILT_IN_TGAMMA):\n+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_TGAMMA):\n       CASE_FLT_FN (BUILT_IN_TRUNC):\n       CASE_FLT_FN_FLOATN_NX (BUILT_IN_TRUNC):\n \treturn true;"}, {"sha": "0ea8a2b2ca041e54aa0dff38767a9c0bcb8a56fc", "filename": "gcc/builtins.def", "status": "modified", "additions": 120, "deletions": 4, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -292,26 +292,40 @@ DEF_C99_C90RES_BUILTIN (BUILT_IN_ACOSF, \"acosf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_\n DEF_C99_BUILTIN        (BUILT_IN_ACOSH, \"acosh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ACOSHF, \"acoshf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ACOSHL, \"acoshl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define ACOSH_TYPE(F) BT_FN_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ACOSH, \"acosh\", ACOSH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ACOSL, \"acosl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ACOS, \"acos\", ACOSH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C11_BUILTIN        (BUILT_IN_ALIGNED_ALLOC, \"aligned_alloc\", BT_FN_PTR_SIZE_SIZE, ATTR_ALLOC_WARN_UNUSED_RESULT_SIZE_2_NOTHROW_LIST)\n DEF_LIB_BUILTIN        (BUILT_IN_ASIN, \"asin\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ASINF, \"asinf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ASINH, \"asinh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_ASINHF, \"asinhf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_ASINHL, \"asinhl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ASINH, \"asinh\", ACOSH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ASINL, \"asinl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ASIN, \"asin\", ACOSH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef ACOSH_TYPE\n DEF_LIB_BUILTIN        (BUILT_IN_ATAN, \"atan\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_LIB_BUILTIN        (BUILT_IN_ATAN2, \"atan2\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ATAN2F, \"atan2f\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ATAN2L, \"atan2l\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define ATAN2_TYPE(F) BT_FN_##F##_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ATAN2, \"atan2\", ATAN2_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef ATAN2_TYPE\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ATANF, \"atanf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_ATANH, \"atanh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ATANHF, \"atanhf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ATANHL, \"atanhl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define ATANH_TYPE(F) BT_FN_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ATANH, \"atanh\", ATANH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ATANL, \"atanl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ATAN, \"atan\", ATANH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_CBRT, \"cbrt\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_CBRTF, \"cbrtf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_CBRTL, \"cbrtl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CBRT, \"cbrt\", ATANH_TYPE, ATTR_MATHFN_FPROUNDING)\n+#undef ATANH_TYPE\n DEF_LIB_BUILTIN        (BUILT_IN_CEIL, \"ceil\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_CEILF, \"ceilf\", BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_CEILL, \"ceill\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -329,26 +343,35 @@ DEF_C99_C90RES_BUILTIN (BUILT_IN_COSF, \"cosf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FP\n DEF_LIB_BUILTIN        (BUILT_IN_COSH, \"cosh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_COSHF, \"coshf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_COSHL, \"coshl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define COSH_TYPE(F) BT_FN_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_COSH, \"cosh\", COSH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_COSL, \"cosl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_COS, \"cos\", COSH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_DREM, \"drem\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_DREMF, \"dremf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_DREML, \"dreml\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ERF, \"erf\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_ERFC, \"erfc\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ERFCF, \"erfcf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ERFCL, \"erfcl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ERFC, \"erfc\", COSH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ERFF, \"erff\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_ERFL, \"erfl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ERF, \"erf\", COSH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_LIB_BUILTIN        (BUILT_IN_EXP, \"exp\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C2X_BUILTIN        (BUILT_IN_EXP10, \"exp10\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C2X_BUILTIN        (BUILT_IN_EXP10F, \"exp10f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C2X_BUILTIN        (BUILT_IN_EXP10L, \"exp10l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_EXP2, \"exp2\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_EXP2F, \"exp2f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_EXP2L, \"exp2l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_EXP2, \"exp2\", COSH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_EXPF, \"expf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_EXPL, \"expl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_EXP, \"exp\", COSH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_EXPM1, \"expm1\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_EXPM1, \"expm1\", COSH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef COSH_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_EXPM1F, \"expm1f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_EXPM1L, \"expm1l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_LIB_BUILTIN        (BUILT_IN_FABS, \"fabs\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -363,6 +386,9 @@ DEF_C2X_BUILTIN        (BUILT_IN_FABSD128, \"fabsd128\", BT_FN_DFLOAT128_DFLOAT128\n DEF_C99_BUILTIN        (BUILT_IN_FDIM, \"fdim\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_FDIMF, \"fdimf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_FDIML, \"fdiml\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define FDIM_TYPE(F) BT_FN_##F##_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_FDIM, \"fdim\", FDIM_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef FDIM_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_FECLEAREXCEPT, \"feclearexcept\", BT_FN_INT_INT, ATTR_NOTHROW_LEAF_LIST)\n DEF_C99_BUILTIN        (BUILT_IN_FEGETENV, \"fegetenv\", BT_FN_INT_FENV_T_PTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_C99_BUILTIN        (BUILT_IN_FEGETEXCEPTFLAG, \"fegetexceptflag\", BT_FN_INT_FEXCEPT_T_PTR_INT, ATTR_NOTHROW_LEAF_LIST)\n@@ -397,13 +423,17 @@ DEF_C99_BUILTIN        (BUILT_IN_FMINF, \"fminf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_C\n DEF_C99_BUILTIN        (BUILT_IN_FMINL, \"fminl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n #define FMIN_TYPE(F) BT_FN_##F##_##F##_##F\n DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_FMIN, \"fmin\", FMIN_TYPE, ATTR_CONST_NOTHROW_LEAF_LIST)\n-#undef FMIN_TYPE\n DEF_LIB_BUILTIN        (BUILT_IN_FMOD, \"fmod\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_FMODF, \"fmodf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_FMODL, \"fmodl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_FMOD, \"fmod\", FMIN_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef FMIN_TYPE\n DEF_LIB_BUILTIN        (BUILT_IN_FREXP, \"frexp\", BT_FN_DOUBLE_DOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_FREXPF, \"frexpf\", BT_FN_FLOAT_FLOAT_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_FREXPL, \"frexpl\", BT_FN_LONGDOUBLE_LONGDOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n+#define FREXP_TYPE(F) BT_FN_##F##_##F##_INTPTR\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_FREXP, \"frexp\", FREXP_TYPE, ATTR_MATHFN_FPROUNDING_STORE)\n+#undef FREXP_TYPE\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_GAMMA, \"gamma\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_GAMMAF, \"gammaf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_GAMMAL, \"gammal\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_STORE)\n@@ -413,11 +443,15 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_GAMMAL_R, \"gammal_r\", BT_FN_LONGDOUBLE_LONGDOUB\n DEF_GCC_BUILTIN        (BUILT_IN_HUGE_VAL, \"huge_val\", BT_FN_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_HUGE_VALF, \"huge_valf\", BT_FN_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_HUGE_VALL, \"huge_vall\", BT_FN_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n-#define INF_TYPE(F) BT_FN_##F\n-DEF_GCC_FLOATN_NX_BUILTINS (BUILT_IN_HUGE_VAL, \"huge_val\", INF_TYPE, ATTR_CONST_NOTHROW_LEAF_LIST)\n+#define HUGE_VAL_TYPE(F) BT_FN_##F\n+DEF_GCC_FLOATN_NX_BUILTINS (BUILT_IN_HUGE_VAL, \"huge_val\", HUGE_VAL_TYPE, ATTR_CONST_NOTHROW_LEAF_LIST)\n+#undef HUGE_VAL_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_HYPOT, \"hypot\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_HYPOTF, \"hypotf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_HYPOTL, \"hypotl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define HYPOT_TYPE(F) BT_FN_##F##_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_HYPOT, \"hypot\", HYPOT_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef HYPOT_TYPE\n DEF_GCC_BUILTIN        (BUILT_IN_ICEIL, \"iceil\", BT_FN_INT_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_ICEILF, \"iceilf\", BT_FN_INT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_ICEILL, \"iceill\", BT_FN_INT_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -427,9 +461,13 @@ DEF_GCC_BUILTIN        (BUILT_IN_IFLOORL, \"ifloorl\", BT_FN_INT_LONGDOUBLE, ATTR_\n DEF_C99_BUILTIN        (BUILT_IN_ILOGB, \"ilogb\", BT_FN_INT_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ILOGBF, \"ilogbf\", BT_FN_INT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_ILOGBL, \"ilogbl\", BT_FN_INT_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define ILOGB_TYPE(F) BT_FN_INT_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_ILOGB, \"ilogb\", ILOGB_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef ILOGB_TYPE\n DEF_GCC_BUILTIN        (BUILT_IN_INF, \"inf\", BT_FN_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_INFF, \"inff\", BT_FN_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_INFL, \"infl\", BT_FN_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n+#define INF_TYPE(F) BT_FN_##F\n DEF_GCC_FLOATN_NX_BUILTINS (BUILT_IN_INF, \"inf\", INF_TYPE, ATTR_CONST_NOTHROW_LEAF_LIST)\n #undef INF_TYPE\n DEF_GCC_BUILTIN\t       (BUILT_IN_INFD32, \"infd32\", BT_FN_DFLOAT32, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -456,12 +494,18 @@ DEF_GCC_BUILTIN        (BUILT_IN_LCEILL, \"lceill\", BT_FN_LONG_LONGDOUBLE, ATTR_C\n DEF_LIB_BUILTIN        (BUILT_IN_LDEXP, \"ldexp\", BT_FN_DOUBLE_DOUBLE_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_LDEXPF, \"ldexpf\", BT_FN_FLOAT_FLOAT_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_LDEXPL, \"ldexpl\", BT_FN_LONGDOUBLE_LONGDOUBLE_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define LDEXP_TYPE(F) BT_FN_##F##_##F##_INT\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LDEXP, \"ldexp\", LDEXP_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef LDEXP_TYPE\n DEF_GCC_BUILTIN        (BUILT_IN_LFLOOR, \"lfloor\", BT_FN_LONG_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_LFLOORF, \"lfloorf\", BT_FN_LONG_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_LFLOORL, \"lfloorl\", BT_FN_LONG_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_BUILTIN        (BUILT_IN_LGAMMA, \"lgamma\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_C99_BUILTIN        (BUILT_IN_LGAMMAF, \"lgammaf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_C99_BUILTIN        (BUILT_IN_LGAMMAL, \"lgammal\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_STORE)\n+#define LGAMMA_TYPE(F) BT_FN_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LGAMMA, \"lgamma\", LGAMMA_TYPE, ATTR_MATHFN_FPROUNDING_STORE)\n+#undef LGAMMA_TYPE\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_LGAMMA_R, \"lgamma_r\", BT_FN_DOUBLE_DOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_LGAMMAF_R, \"lgammaf_r\", BT_FN_FLOAT_FLOAT_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_LGAMMAL_R, \"lgammal_r\", BT_FN_LONGDOUBLE_LONGDOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n@@ -474,33 +518,51 @@ DEF_GCC_BUILTIN        (BUILT_IN_LLFLOORL, \"llfloorl\", BT_FN_LONGLONG_LONGDOUBLE\n DEF_C99_BUILTIN        (BUILT_IN_LLRINT, \"llrint\", BT_FN_LONGLONG_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LLRINTF, \"llrintf\", BT_FN_LONGLONG_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LLRINTL, \"llrintl\", BT_FN_LONGLONG_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define LLRINT_TYPE(F) BT_FN_LONGLONG_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LLRINT, \"llrint\", LLRINT_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LLROUND, \"llround\", BT_FN_LONGLONG_DOUBLE, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LLROUNDF, \"llroundf\", BT_FN_LONGLONG_FLOAT, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LLROUNDL, \"llroundl\", BT_FN_LONGLONG_LONGDOUBLE, ATTR_MATHFN_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LLROUND, \"llround\", LLRINT_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef LLRINT_TYPE\n DEF_LIB_BUILTIN        (BUILT_IN_LOG, \"log\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_LIB_BUILTIN        (BUILT_IN_LOG10, \"log10\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_LOG10F, \"log10f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_LOG10L, \"log10l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define LOG10_TYPE(F) BT_FN_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LOG10, \"log10\", LOG10_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOG1P, \"log1p\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOG1PF, \"log1pf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOG1PL, \"log1pl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LOG1P, \"log1p\", LOG10_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOG2, \"log2\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOG2F, \"log2f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOG2L, \"log2l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LOG2, \"log2\", LOG10_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOGB, \"logb\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOGBF, \"logbf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LOGBL, \"logbl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LOGB, \"logb\", LOG10_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_LOGF, \"logf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_LOGL, \"logl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LOG, \"log\", LOG10_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef LOG10_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_LRINT, \"lrint\", BT_FN_LONG_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LRINTF, \"lrintf\", BT_FN_LONG_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LRINTL, \"lrintl\", BT_FN_LONG_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define LRINT_TYPE(F) BT_FN_LONG_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LRINT, \"lrint\", LRINT_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LROUND, \"lround\", BT_FN_LONG_DOUBLE, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LROUNDF, \"lroundf\", BT_FN_LONG_FLOAT, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_LROUNDL, \"lroundl\", BT_FN_LONG_LONGDOUBLE, ATTR_MATHFN_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_LROUND, \"lround\", LRINT_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef LRINT_TYPE\n DEF_LIB_BUILTIN        (BUILT_IN_MODF, \"modf\", BT_FN_DOUBLE_DOUBLE_DOUBLEPTR, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_MODFF, \"modff\", BT_FN_FLOAT_FLOAT_FLOATPTR, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_MODFL, \"modfl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLEPTR, ATTR_MATHFN_FPROUNDING_STORE)\n+#define MODF_TYPE(F) BT_FN_##F##_##F##_##F##PTR\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_MODF, \"modf\", MODF_TYPE, ATTR_MATHFN_FPROUNDING_STORE)\n+#undef MODF_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_NAN, \"nan\", BT_FN_DOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_C99_BUILTIN        (BUILT_IN_NANF, \"nanf\", BT_FN_FLOAT_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_C99_BUILTIN        (BUILT_IN_NANL, \"nanl\", BT_FN_LONGDOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n@@ -514,6 +576,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_NANSF, \"nansf\", BT_FN_FLOAT_CONST_STRING, ATTR_\n DEF_GCC_BUILTIN        (BUILT_IN_NANSL, \"nansl\", BT_FN_LONGDOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_FLOATN_NX_BUILTINS (BUILT_IN_NANS, \"nans\", NAN_TYPE, ATTR_CONST_NOTHROW_NONNULL)\n #undef NAN_TYPE\n+DEF_GCC_BUILTIN        (BUILT_IN_NANSF16B, \"nansf16b\", BT_FN_BFLOAT16_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANSD32, \"nansd32\", BT_FN_DFLOAT32_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANSD64, \"nansd64\", BT_FN_DFLOAT64_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANSD128, \"nansd128\", BT_FN_DFLOAT128_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n@@ -526,6 +589,9 @@ DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_NEARBYINT, \"nearbyint\", NEARBYINT_TYPE,\n DEF_C99_BUILTIN        (BUILT_IN_NEXTAFTER, \"nextafter\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_NEXTAFTERF, \"nextafterf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_NEXTAFTERL, \"nextafterl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_ERRNO)\n+#define NEXTAFTER_TYPE(F) BT_FN_##F##_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_NEXTAFTER, \"nextafter\", NEXTAFTER_TYPE, ATTR_MATHFN_ERRNO)\n+DEF_GCC_BUILTIN        (BUILT_IN_NEXTAFTERF16B, \"nextafterf16b\", BT_FN_BFLOAT16_BFLOAT16_BFLOAT16, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_NEXTTOWARD, \"nexttoward\", BT_FN_DOUBLE_DOUBLE_LONGDOUBLE, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_NEXTTOWARDF, \"nexttowardf\", BT_FN_FLOAT_FLOAT_LONGDOUBLE, ATTR_MATHFN_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_NEXTTOWARDL, \"nexttowardl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_ERRNO)\n@@ -538,12 +604,18 @@ DEF_GCC_BUILTIN        (BUILT_IN_POWI, \"powi\", BT_FN_DOUBLE_DOUBLE_INT, ATTR_MAT\n DEF_GCC_BUILTIN        (BUILT_IN_POWIF, \"powif\", BT_FN_FLOAT_FLOAT_INT, ATTR_MATHFN_FPROUNDING)\n DEF_GCC_BUILTIN        (BUILT_IN_POWIL, \"powil\", BT_FN_LONGDOUBLE_LONGDOUBLE_INT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_POWL, \"powl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_POW, \"pow\", NEXTAFTER_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_REMAINDER, \"remainder\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_REMAINDERF, \"remainderf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_REMAINDERL, \"remainderl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_REMAINDER, \"remainder\", NEXTAFTER_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef NEXTAFTER_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_REMQUO, \"remquo\", BT_FN_DOUBLE_DOUBLE_DOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_C99_BUILTIN        (BUILT_IN_REMQUOF, \"remquof\", BT_FN_FLOAT_FLOAT_FLOAT_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n DEF_C99_BUILTIN        (BUILT_IN_REMQUOL, \"remquol\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\n+#define REMQUO_TYPE(F) BT_FN_##F##_##F##_##F##_INTPTR\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_REMQUO, \"remquo\", REMQUO_TYPE, ATTR_MATHFN_FPROUNDING_STORE)\n+#undef REMQUO_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_RINT, \"rint\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_RINTF, \"rintf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_RINTL, \"rintl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n@@ -568,9 +640,15 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_SCALBL, \"scalbl\", BT_FN_LONGDOUBLE_LONGDOUBLE_L\n DEF_C99_BUILTIN        (BUILT_IN_SCALBLN, \"scalbln\", BT_FN_DOUBLE_DOUBLE_LONG, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_SCALBLNF, \"scalblnf\", BT_FN_FLOAT_FLOAT_LONG, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_SCALBLNL, \"scalblnl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONG, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define SCALBLN_TYPE(F) BT_FN_##F##_##F##_LONG\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_SCALBLN, \"scalbln\", SCALBLN_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef SCALBLN_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_SCALBN, \"scalbn\", BT_FN_DOUBLE_DOUBLE_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_SCALBNF, \"scalbnf\", BT_FN_FLOAT_FLOAT_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_SCALBNL, \"scalbnl\", BT_FN_LONGDOUBLE_LONGDOUBLE_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define SCALBN_TYPE(F) BT_FN_##F##_##F##_INT\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_SCALBN, \"scalbn\", SCALBN_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef SCALBN_TYPE\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_SIGNBIT, \"signbit\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_SIGNBITF, \"signbitf\", BT_FN_INT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_SIGNBITL, \"signbitl\", BT_FN_INT_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -588,22 +666,29 @@ DEF_C99_C90RES_BUILTIN (BUILT_IN_SINF, \"sinf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FP\n DEF_LIB_BUILTIN        (BUILT_IN_SINH, \"sinh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_SINHF, \"sinhf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_SINHL, \"sinhl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#define SINH_TYPE(F) BT_FN_##F##_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_SINH, \"sinh\", SINH_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_SINL, \"sinl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_SIN, \"sin\", SINH_TYPE, ATTR_MATHFN_FPROUNDING)\n+#undef SINH_TYPE\n DEF_LIB_BUILTIN        (BUILT_IN_SQRT, \"sqrt\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_SQRTF, \"sqrtf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_SQRTL, \"sqrtl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n #define SQRT_TYPE(F) BT_FN_##F##_##F\n DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_SQRT, \"sqrt\", SQRT_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n-#undef SQRT_TYPE\n DEF_LIB_BUILTIN        (BUILT_IN_TAN, \"tan\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_TANF, \"tanf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_LIB_BUILTIN        (BUILT_IN_TANH, \"tanh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_TANHF, \"tanhf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_TANHL, \"tanhl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_TANH, \"tanh\", SQRT_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_TANL, \"tanl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_TAN, \"tan\", SQRT_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_BUILTIN        (BUILT_IN_TGAMMA, \"tgamma\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_TGAMMAF, \"tgammaf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_BUILTIN        (BUILT_IN_TGAMMAL, \"tgammal\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_TGAMMA, \"tgamma\", SQRT_TYPE, ATTR_MATHFN_FPROUNDING_ERRNO)\n+#undef SQRT_TYPE\n DEF_C99_BUILTIN        (BUILT_IN_TRUNC, \"trunc\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_BUILTIN        (BUILT_IN_TRUNCF, \"truncf\", BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_BUILTIN        (BUILT_IN_TRUNCL, \"truncl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -624,36 +709,54 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_YNL, \"ynl\", BT_FN_LONGDOUBLE_INT_LONGDOUBLE, AT\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CABS, \"cabs\", BT_FN_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CABSF, \"cabsf\", BT_FN_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CABSL, \"cabsl\", BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+#define CABS_TYPE(F) BT_FN_##F##_COMPLEX_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CABS, \"cabs\", CABS_TYPE, ATTR_MATHFN_FPROUNDING)\n+#undef CABS_TYPE\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CACOS, \"cacos\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CACOSF, \"cacosf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CACOSH, \"cacosh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CACOSHF, \"cacoshf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CACOSHL, \"cacoshl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+#define CACOSH_TYPE(F) BT_FN_COMPLEX_##F##_COMPLEX_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CACOSH, \"cacosh\", CACOSH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CACOSL, \"cacosl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CACOS, \"cacos\", CACOSH_TYPE, ATTR_MATHFN_FPROUNDING)\n+#undef CACOSH_TYPE\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CARG, \"carg\", BT_FN_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CARGF, \"cargf\", BT_FN_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CARGL, \"cargl\", BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+#define CARG_TYPE(F) BT_FN_##F##_COMPLEX_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CARG, \"carg\", CARG_TYPE, ATTR_MATHFN_FPROUNDING)\n+#undef CARG_TYPE\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CASIN, \"casin\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CASINF, \"casinf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CASINH, \"casinh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CASINHF, \"casinhf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CASINHL, \"casinhl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+#define CASINH_TYPE(F) BT_FN_COMPLEX_##F##_COMPLEX_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CASINH, \"casinh\", CASINH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CASINL, \"casinl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CASIN, \"casin\", CASINH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CATAN, \"catan\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CATANF, \"catanf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CATANH, \"catanh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CATANHF, \"catanhf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CATANHL, \"catanhl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CATANH, \"catanh\", CASINH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CATANL, \"catanl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CATAN, \"catan\", CASINH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CCOS, \"ccos\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CCOSF, \"ccosf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CCOSH, \"ccosh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CCOSHF, \"ccoshf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CCOSHL, \"ccoshl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CCOSH, \"ccosh\", CASINH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CCOSL, \"ccosl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CCOS, \"ccos\", CASINH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CEXP, \"cexp\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CEXPF, \"cexpf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CEXPL, \"cexpl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CEXP, \"cexp\", CASINH_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_GCC_BUILTIN        (BUILT_IN_CEXPI, \"cexpi\", BT_FN_COMPLEX_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_GCC_BUILTIN        (BUILT_IN_CEXPIF, \"cexpif\", BT_FN_COMPLEX_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_GCC_BUILTIN        (BUILT_IN_CEXPIL, \"cexpil\", BT_FN_COMPLEX_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n@@ -663,6 +766,8 @@ DEF_C99_COMPL_BUILTIN        (BUILT_IN_CIMAGL, \"cimagl\", BT_FN_LONGDOUBLE_COMPLE\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CLOG, \"clog\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CLOGF, \"clogf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CLOGL, \"clogl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CLOG, \"clog\", CASINH_TYPE, ATTR_MATHFN_FPROUNDING)\n+#undef CASINH_TYPE\n DEF_EXT_C99RES_BUILTIN (BUILT_IN_CLOG10, \"clog10\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_EXT_C99RES_BUILTIN (BUILT_IN_CLOG10F, \"clog10f\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_EXT_C99RES_BUILTIN (BUILT_IN_CLOG10L, \"clog10l\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n@@ -672,9 +777,14 @@ DEF_C99_COMPL_BUILTIN        (BUILT_IN_CONJL, \"conjl\", BT_FN_COMPLEX_LONGDOUBLE_\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CPOW, \"cpow\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CPOWF, \"cpowf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CPOWL, \"cpowl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+#define CPOW_TYPE(F) BT_FN_COMPLEX_##F##_COMPLEX_##F##_COMPLEX_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CPOW, \"cpow\", CPOW_TYPE, ATTR_MATHFN_FPROUNDING)\n+#undef CPOW_TYPE\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CPROJ, \"cproj\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CPROJF, \"cprojf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CPROJL, \"cprojl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n+#define CPROJ_TYPE(F) BT_FN_COMPLEX_##F##_COMPLEX_##F\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CPROJ, \"cproj\", CPROJ_TYPE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CREAL, \"creal\", BT_FN_DOUBLE_COMPLEX_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CREALF, \"crealf\", BT_FN_FLOAT_COMPLEX_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CREALL, \"creall\", BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -683,16 +793,22 @@ DEF_C99_COMPL_BUILTIN        (BUILT_IN_CSINF, \"csinf\", BT_FN_COMPLEX_FLOAT_COMPL\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CSINH, \"csinh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CSINHF, \"csinhf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CSINHL, \"csinhl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CSINH, \"csinh\", CPROJ_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CSINL, \"csinl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CSIN, \"csin\", CPROJ_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CSQRT, \"csqrt\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CSQRTF, \"csqrtf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CSQRTL, \"csqrtl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CSQRT, \"csqrt\", CPROJ_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CTAN, \"ctan\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CTANF, \"ctanf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CTANH, \"ctanh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CTANHF, \"ctanhf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CTANHL, \"ctanhl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CTANH, \"ctanh\", CPROJ_TYPE, ATTR_MATHFN_FPROUNDING)\n DEF_C99_COMPL_BUILTIN        (BUILT_IN_CTANL, \"ctanl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n+DEF_EXT_LIB_FLOATN_NX_BUILTINS (BUILT_IN_CTAN, \"ctan\", CPROJ_TYPE, ATTR_MATHFN_FPROUNDING)\n+#undef CPROJ_TYPE\n \n /* Category: string/memory builtins.  */\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_BCMP, \"bcmp\", BT_FN_INT_CONST_PTR_CONST_PTR_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)"}, {"sha": "32e8fb18eadf6a6971073879d3d19b5c0854ec89", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,3 +1,216 @@\n+2022-10-28  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-common.cc (def_fn_type): Call build_function_type for\n+\tzero-argument variable-argument function.\n+\t(c_common_nodes_and_builtins): Build default_function_type with\n+\tbuild_function_type.\n+\t* c.opt (fallow-parameterless-variadic-functions): Mark as ignored\n+\toption.\n+\n+2022-10-28  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/61469\n+\t* c-common.h (ENUM_UNDERLYING_TYPE, ENUM_FIXED_UNDERLYING_TYPE_P):\n+\tNew.  Moved from cp/cp-tree.h.\n+\t* c-warn.cc (warnings_for_convert_and_check): Do not consider\n+\tconversions to enum with underlying type bool to overflow.\n+\n+2022-10-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/106393\n+\t* c.opt (Wdangling-reference): New.\n+\n+2022-10-19  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-format.h (enum format_lengths): Add FMT_LEN_w8, FMT_LEN_w16,\n+\tFMT_LEN_w32, FMT_LEN_w64, FMT_LEN_wf8, FMT_LEN_wf16, FMT_LEN_wf32\n+\tand FMT_LEN_wf64.\n+\t(NOARGUMENTS, NOLENGTHS): Update definitions.\n+\t(T_I8, T2X_I8, T_I16, T2X_I16, T_I32, T2X_I32, T_I64, T2X_I64)\n+\t(T_U8, T2X_U8, T_U16, T2X_U16, T_U32, T2X_U32, T_U64, T2X_U64)\n+\t(T_IF8, T2X_IF8, T_IF16, T2X_IF16, T_IF32, T2X_IF32, T_IF64)\n+\t(T2X_IF64, T_UF8, T2X_UF8, T_UF16, T2X_UF16, T_UF32, T2X_UF32)\n+\t(T_UF64, T2X_UF64): New macros.\n+\t* c-format.cc (printf_length_specs, scanf_length_specs): Add wN\n+\tand wfN length modifiers.\n+\t(print_char_table, scan_char_table): Add entries using wN and wfN\n+\tlength modifiers.\n+\n+2022-10-18  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/36113\n+\t* c-common.cc (c_common_type_for_size): Add fallback to\n+\twidest_unsigned_literal_type_node or\n+\twidest_integer_literal_type_node for precision that may not\n+\texactly match the precision of those types.\n+\n+2022-10-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-cppbuiltin.cc (c_cpp_builtins): If bfloat16_type_node,\n+\tpredefine __BFLT16_*__ macros and for C++23 also\n+\t__STDCPP_BFLOAT16_T__.  Predefine bfloat16_type_node related\n+\tmacros for -fbuilding-libgcc.\n+\t* c-lex.cc (interpret_float): Handle CPP_N_BFLOAT16.\n+\n+2022-10-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/323\n+\tPR c++/107097\n+\t* c-common.def (EXCESS_PRECISION_EXPR): Remove comment part about\n+\tthe tree being specific to C/ObjC.\n+\t* c-opts.cc (c_common_post_options): Handle flag_excess_precision\n+\tin C++ the same as in C.\n+\t* c-lex.cc (interpret_float): Set const_type to excess_precision ()\n+\teven for C++.\n+\n+2022-10-13  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-cppbuiltin.cc (builtin_define_float_constants): Do not use\n+\tvalue 2 for *_IS_IEC_60559.\n+\n+2022-10-12  Lewis Hyatt  <lhyatt@gmail.com>\n+\n+\tPR preprocessor/60014\n+\tPR preprocessor/60723\n+\t* c-ppoutput.cc (class token_streamer): Remove member\n+\tline_marker_emitted to...\n+\t(token_streamer::stream): ...a local variable here. Set\n+\tprint.prev_was_system_token on all code paths.\n+\n+2022-10-10  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* c-opts.cc (c_common_post_options): Bump abi to 18.\n+\n+2022-10-10  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/106937\n+\t* c-pretty-print.cc (pp_c_specifier_qualifier_list): Print only GNU\n+\tattributes here.\n+\t(c_pretty_printer::direct_abstract_declarator): Print the standard [[]]\n+\tattributes here.\n+\t(pp_c_attributes): Remove.\n+\t(pp_c_attributes_display): Print the [[]] form if appropriate.  Use\n+\tget_attribute_name.  Don't print a trailing space when printing the\n+\t[[]] form.\n+\t* c-pretty-print.h (pp_c_attributes): Remove.\n+\n+2022-10-07  Qing Zhao  <qing.zhao@oracle.com>\n+\n+\t* c-attribs.cc (handle_strict_flex_array_attribute): New function.\n+\t(c_common_attribute_table): New item for strict_flex_array.\n+\t* c.opt: (fstrict-flex-arrays): New option.\n+\t(fstrict-flex-arrays=): New option.\n+\n+2022-10-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* name-hint.h: Use std::move.\n+\n+2022-10-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.cc (attribute_fallthrough_p): Lookup fallthrough attribute\n+\tonly in gnu namespace or as standard attribute, treat fallthrough\n+\tattributes in other namespaces like any other unknown attribute.\n+\n+2022-10-06  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-common.cc (c_common_reswords): Mark typeof as D_EXT11.  Add\n+\ttypeof_unqual.\n+\t* c-common.h (enum rid): Add RID_TYPEOF_UNQUAL.\n+\t(D_EXT11): New macro.  Values of subsequent macros updated.\n+\n+2022-10-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/106654\n+\t* c-attribs.cc (handle_assume_attribute): New function.\n+\t(c_common_attribute_table): Add entry for assume attribute.\n+\t* c-lex.cc (c_common_has_attribute): Handle\n+\t__have_cpp_attribute (assume).\n+\n+2022-10-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-omp.cc (c_omp_directives): Uncomment begin declare target\n+\tentry.\n+\n+2022-10-03  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* c-common.cc (c_common_reswords): Use RID_IS_SAME instead of\n+\tRID_IS_SAME_AS.\n+\n+2022-10-03  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-cppbuiltin.cc (builtin_define_float_constants): Do not\n+\tspecial-case __*_EPSILON__ setting for IBM long double for C2x.\n+\n+2022-09-30  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* c-common.cc (c_common_reswords): Use cp/cp-trait.def to handle\n+\tC++ traits.\n+\t* c-common.h (enum rid): Likewise.\n+\n+2022-09-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-lex.cc (c_common_has_attribute): Handle noreturn attribute for\n+\tC.\n+\n+2022-09-29  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* c-common.cc (c_common_reswords): Add __remove_cv,\n+\t__remove_reference and __remove_cvref.\n+\t* c-common.h (enum rid): Add RID_REMOVE_CV, RID_REMOVE_REFERENCE\n+\tand RID_REMOVE_CVREF.\n+\n+2022-09-27  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/101165\n+\tPR c++/106882\n+\t* c-cppbuiltin.cc (c_cpp_builtins): Define __cpp_implicit_move.\n+\n+2022-09-27  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-format.cc (c_keywords): Drop nothrow.\n+\n+2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/106651\n+\t* c-cppbuiltin.cc (c_cpp_builtins): Predefine\n+\t__cpp_static_call_operator=202207L for C++23.\n+\n+2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_ASSUME,\n+\tPRAGMA_OMP_ASSUMES and PRAGMA_OMP_BEGIN.  Rename\n+\tPRAGMA_OMP_END_DECLARE_TARGET to PRAGMA_OMP_END.\n+\t* c-pragma.cc (omp_pragmas): Add assumes and begin.\n+\tFor end rename PRAGMA_OMP_END_DECLARE_TARGET to PRAGMA_OMP_END.\n+\t(omp_pragmas_simd): Add assume.\n+\t* c-common.h (c_omp_directives): Declare.\n+\t* c-omp.cc (omp_directives): Rename to ...\n+\t(c_omp_directives): ... this.  No longer static.  Uncomment\n+\tassume, assumes, begin assumes and end assumes entries.\n+\tIn end declare target entry rename PRAGMA_OMP_END_DECLARE_TARGET\n+\tto PRAGMA_OMP_END.\n+\t(c_omp_categorize_directive): Adjust for omp_directives to\n+\tc_omp_directives renaming.\n+\n+2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/106652\n+\tPR c++/85518\n+\t* c-common.cc (c_common_reswords): Change _Float{16,32,64,128} and\n+\t_Float{32,64,128}x flags from D_CONLY to 0.\n+\t(shorten_binary_op): Punt if common_type returns error_mark_node.\n+\t(shorten_compare): Likewise.\n+\t(c_common_nodes_and_builtins): For C++ record _Float{16,32,64,128}\n+\tand _Float{32,64,128}x builtin types if available.  For C++\n+\tclear float128t_type_node.\n+\t* c-cppbuiltin.cc (c_cpp_builtins): Predefine\n+\t__STDCPP_FLOAT{16,32,64,128}_T__ for C++23 if supported.\n+\t* c-lex.cc (interpret_float): For q/Q suffixes prefer\n+\tfloat128t_type_node over float128_type_node.  Allow\n+\t{f,F}{16,32,64,128} suffixes for C++ if supported with pedwarn\n+\tfor C++20 and older.  Allow {f,F}{32,64,128}x suffixes for C++\n+\twith pedwarn.  Don't call excess_precision_type for C++.\n+\n 2022-09-26  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/106656"}, {"sha": "92ac93ba2cedd3ba5ef1be6c883b48eba95d15eb", "filename": "gcc/c-family/c-attribs.cc", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -101,6 +101,8 @@ static tree handle_special_var_sec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_aligned_attribute (tree *, tree, tree, int, bool *);\n static tree handle_warn_if_not_aligned_attribute (tree *, tree, tree,\n \t\t\t\t\t\t  int, bool *);\n+static tree handle_strict_flex_array_attribute (tree *, tree, tree,\n+\t\t\t\t\t\t int, bool *);\n static tree handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_noplt_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_alias_ifunc_attribute (bool, tree *, tree, tree, bool *);\n@@ -144,6 +146,7 @@ static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_align_attribute (tree *, tree, tree, int, bool *);\n static tree handle_assume_aligned_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_assume_attribute (tree *, tree, tree, int, bool *);\n static tree handle_target_attribute (tree *, tree, tree, int, bool *);\n static tree handle_target_clones_attribute (tree *, tree, tree, int, bool *);\n static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n@@ -368,6 +371,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t                      attr_aligned_exclusions },\n   { \"warn_if_not_aligned\",    0, 1, false, false, false, false,\n \t\t\t      handle_warn_if_not_aligned_attribute, NULL },\n+  { \"strict_flex_array\",      1, 1, true, false, false, false,\n+\t\t\t      handle_strict_flex_array_attribute, NULL },\n   { \"weak\",                   0, 0, true,  false, false, false,\n \t\t\t      handle_weak_attribute, NULL },\n   { \"noplt\",                   0, 0, true,  false, false, false,\n@@ -530,6 +535,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_designated_init_attribute, NULL },\n   { \"fallthrough\",\t      0, 0, false, false, false, false,\n \t\t\t      handle_fallthrough_attribute, NULL },\n+  { \"assume\",\t\t      1, 1, false, false, false, false,\n+\t\t\t      handle_assume_attribute, NULL },\n   { \"patchable_function_entry\",\t1, 2, true, false, false, false,\n \t\t\t      handle_patchable_function_entry_attribute,\n \t\t\t      NULL },\n@@ -2505,6 +2512,49 @@ handle_warn_if_not_aligned_attribute (tree *node, tree name,\n \t\t\t\t\t  no_add_attrs, true);\n }\n \n+/* Handle a \"strict_flex_array\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_strict_flex_array_attribute (tree *node, tree name,\n+\t\t\t\t    tree args, int ARG_UNUSED (flags),\n+\t\t\t\t    bool *no_add_attrs)\n+{\n+  tree decl = *node;\n+  tree argval = TREE_VALUE (args);\n+\n+  /* This attribute only applies to field decls of a structure.  */\n+  if (TREE_CODE (decl) != FIELD_DECL)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute may not be specified for %q+D\", name, decl);\n+      *no_add_attrs = true;\n+    }\n+  /* This attribute only applies to field with array type.  */\n+  else if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute may not be specified for a non-array field\",\n+\t\tname);\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (argval) != INTEGER_CST)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute argument not an integer\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (!tree_fits_uhwi_p (argval) || tree_to_uhwi (argval) > 3)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute argument %qE is not an integer constant\"\n+\t\t\" between 0 and 3\", name, argval);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"weak\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n@@ -5741,6 +5791,18 @@ handle_fallthrough_attribute (tree *, tree name, tree, int,\n   return NULL_TREE;\n }\n \n+/* Handle a \"assume\" attribute; arguments as in struct\n+   attribute_spec.handler.  */\n+\n+tree\n+handle_assume_attribute (tree *, tree name, tree, int,\n+\t\t\t bool *no_add_attrs)\n+{\n+  pedwarn (input_location, OPT_Wattributes, \"%qE attribute ignored\", name);\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"patchable_function_entry\" attributes; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "5890c18bdc361c04f327fb8287143cd607ecaa59", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 24, "deletions": 52, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -378,7 +378,6 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n   { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n   { \"__auto_type\",\tRID_AUTO_TYPE,\tD_CONLY },\n-  { \"__bases\",          RID_BASES, D_CXXONLY },\n   { \"__builtin_addressof\", RID_ADDRESSOF, D_CXXONLY },\n   { \"__builtin_bit_cast\", RID_BUILTIN_BIT_CAST, D_CXXONLY },\n   { \"__builtin_call_with_static_chain\",\n@@ -401,44 +400,12 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__const__\",\tRID_CONST,\t0 },\n   { \"__constinit\",\tRID_CONSTINIT,\tD_CXXONLY },\n   { \"__decltype\",       RID_DECLTYPE,   D_CXXONLY },\n-  { \"__direct_bases\",   RID_DIRECT_BASES, D_CXXONLY },\n   { \"__extension__\",\tRID_EXTENSION,\t0 },\n   { \"__func__\",\t\tRID_C99_FUNCTION_NAME, 0 },\n-  { \"__has_nothrow_assign\", RID_HAS_NOTHROW_ASSIGN, D_CXXONLY },\n-  { \"__has_nothrow_constructor\", RID_HAS_NOTHROW_CONSTRUCTOR, D_CXXONLY },\n-  { \"__has_nothrow_copy\", RID_HAS_NOTHROW_COPY, D_CXXONLY },\n-  { \"__has_trivial_assign\", RID_HAS_TRIVIAL_ASSIGN, D_CXXONLY },\n-  { \"__has_trivial_constructor\", RID_HAS_TRIVIAL_CONSTRUCTOR, D_CXXONLY },\n-  { \"__has_trivial_copy\", RID_HAS_TRIVIAL_COPY, D_CXXONLY },\n-  { \"__has_trivial_destructor\", RID_HAS_TRIVIAL_DESTRUCTOR, D_CXXONLY },\n-  { \"__has_unique_object_representations\", RID_HAS_UNIQUE_OBJ_REPRESENTATIONS,\n-\t\t\t\t\tD_CXXONLY },\n-  { \"__has_virtual_destructor\", RID_HAS_VIRTUAL_DESTRUCTOR, D_CXXONLY },\n   { \"__imag\",\t\tRID_IMAGPART,\t0 },\n   { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n   { \"__inline\",\t\tRID_INLINE,\t0 },\n   { \"__inline__\",\tRID_INLINE,\t0 },\n-  { \"__is_abstract\",\tRID_IS_ABSTRACT, D_CXXONLY },\n-  { \"__is_aggregate\",\tRID_IS_AGGREGATE, D_CXXONLY },\n-  { \"__is_base_of\",\tRID_IS_BASE_OF, D_CXXONLY },\n-  { \"__is_class\",\tRID_IS_CLASS,\tD_CXXONLY },\n-  { \"__is_empty\",\tRID_IS_EMPTY,\tD_CXXONLY },\n-  { \"__is_enum\",\tRID_IS_ENUM,\tD_CXXONLY },\n-  { \"__is_final\",\tRID_IS_FINAL,\tD_CXXONLY },\n-  { \"__is_layout_compatible\", RID_IS_LAYOUT_COMPATIBLE, D_CXXONLY },\n-  { \"__is_literal_type\", RID_IS_LITERAL_TYPE, D_CXXONLY },\n-  { \"__is_pointer_interconvertible_base_of\",\n-\t\t\tRID_IS_POINTER_INTERCONVERTIBLE_BASE_OF, D_CXXONLY },\n-  { \"__is_pod\",\t\tRID_IS_POD,\tD_CXXONLY },\n-  { \"__is_polymorphic\",\tRID_IS_POLYMORPHIC, D_CXXONLY },\n-  { \"__is_same\",     RID_IS_SAME_AS, D_CXXONLY },\n-  { \"__is_same_as\",     RID_IS_SAME_AS, D_CXXONLY },\n-  { \"__is_standard_layout\", RID_IS_STD_LAYOUT, D_CXXONLY },\n-  { \"__is_trivial\",     RID_IS_TRIVIAL, D_CXXONLY },\n-  { \"__is_trivially_assignable\", RID_IS_TRIVIALLY_ASSIGNABLE, D_CXXONLY },\n-  { \"__is_trivially_constructible\", RID_IS_TRIVIALLY_CONSTRUCTIBLE, D_CXXONLY },\n-  { \"__is_trivially_copyable\", RID_IS_TRIVIALLY_COPYABLE, D_CXXONLY },\n-  { \"__is_union\",\tRID_IS_UNION,\tD_CXXONLY },\n   { \"__label__\",\tRID_LABEL,\t0 },\n   { \"__null\",\t\tRID_NULL,\t0 },\n   { \"__real\",\t\tRID_REALPART,\t0 },\n@@ -453,7 +420,6 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__transaction_cancel\", RID_TRANSACTION_CANCEL, 0 },\n   { \"__typeof\",\t\tRID_TYPEOF,\t0 },\n   { \"__typeof__\",\tRID_TYPEOF,\t0 },\n-  { \"__underlying_type\", RID_UNDERLYING_TYPE, D_CXXONLY },\n   { \"__volatile\",\tRID_VOLATILE,\t0 },\n   { \"__volatile__\",\tRID_VOLATILE,\t0 },\n   { \"__GIMPLE\",\t\tRID_GIMPLE,\tD_CONLY },\n@@ -528,7 +494,8 @@ const struct c_common_resword c_common_reswords[] =\n   { \"typedef\",\t\tRID_TYPEDEF,\t0 },\n   { \"typename\",\t\tRID_TYPENAME,\tD_CXXONLY | D_CXXWARN },\n   { \"typeid\",\t\tRID_TYPEID,\tD_CXXONLY | D_CXXWARN },\n-  { \"typeof\",\t\tRID_TYPEOF,\tD_ASM | D_EXT },\n+  { \"typeof\",\t\tRID_TYPEOF,\tD_EXT11 },\n+  { \"typeof_unqual\",\tRID_TYPEOF_UNQUAL,\tD_CONLY | D_C2X },\n   { \"union\",\t\tRID_UNION,\t0 },\n   { \"unsigned\",\t\tRID_UNSIGNED,\t0 },\n   { \"using\",\t\tRID_USING,\tD_CXXONLY | D_CXXWARN },\n@@ -537,16 +504,13 @@ const struct c_common_resword c_common_reswords[] =\n   { \"volatile\",\t\tRID_VOLATILE,\t0 },\n   { \"wchar_t\",\t\tRID_WCHAR,\tD_CXXONLY },\n   { \"while\",\t\tRID_WHILE,\t0 },\n-  { \"__is_assignable\", RID_IS_ASSIGNABLE, D_CXXONLY },\n-  { \"__is_constructible\", RID_IS_CONSTRUCTIBLE, D_CXXONLY },\n-  { \"__is_nothrow_assignable\", RID_IS_NOTHROW_ASSIGNABLE, D_CXXONLY },\n-  { \"__is_nothrow_constructible\", RID_IS_NOTHROW_CONSTRUCTIBLE, D_CXXONLY },\n-  { \"__is_convertible\", RID_IS_CONVERTIBLE, D_CXXONLY },\n-  { \"__is_nothrow_convertible\", RID_IS_NOTHROW_CONVERTIBLE, D_CXXONLY },\n-  { \"__reference_constructs_from_temporary\", RID_REF_CONSTRUCTS_FROM_TEMPORARY,\n-\t\t\t\t\tD_CXXONLY },\n-  { \"__reference_converts_from_temporary\", RID_REF_CONVERTS_FROM_TEMPORARY,\n-\t\t\t\t\tD_CXXONLY },\n+\n+#define DEFTRAIT(TCC, CODE, NAME, ARITY) \\\n+  { NAME,\t\tRID_##CODE,\tD_CXXONLY },\n+#include \"cp/cp-trait.def\"\n+#undef DEFTRAIT\n+  /* An alias for __is_same.  */\n+  { \"__is_same_as\",\tRID_IS_SAME,\tD_CXXONLY },\n \n   /* C++ transactional memory.  */\n   { \"synchronized\",\tRID_SYNCHRONIZED, D_CXX_OBJC | D_TRANSMEM },\n@@ -2334,6 +2298,10 @@ c_common_type_for_size (unsigned int bits, int unsignedp)\n   if (bits <= TYPE_PRECISION (intDI_type_node))\n     return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n \n+  if (bits <= TYPE_PRECISION (widest_integer_literal_type_node))\n+    return (unsignedp ? widest_unsigned_literal_type_node\n+\t    : widest_integer_literal_type_node);\n+\n   return NULL_TREE;\n }\n \n@@ -4096,7 +4064,8 @@ static tree builtin_types[(int) BT_LAST + 1];\n \n /* A helper function for c_common_nodes_and_builtins.  Build function type\n    for DEF with return type RET and N arguments.  If VAR is true, then the\n-   function should be variadic after those N arguments.\n+   function should be variadic after those N arguments, or, if N is zero,\n+   unprototyped.\n \n    Takes special care not to ICE if any of the types involved are\n    error_mark_node, which indicates that said type is not in fact available\n@@ -4125,7 +4094,10 @@ def_fn_type (builtin_type def, builtin_type ret, bool var, int n, ...)\n   if (t == error_mark_node)\n     goto egress;\n   if (var)\n-    t = build_varargs_function_type_array (t, n, args);\n+    if (n == 0)\n+      t = build_function_type (t, NULL_TREE);\n+    else\n+      t = build_varargs_function_type_array (t, n, args);\n   else\n     t = build_function_type_array (t, n, args);\n \n@@ -4693,8 +4665,7 @@ c_common_nodes_and_builtins (void)\n     uintptr_type_node =\n       TREE_TYPE (identifier_global_value (c_get_ident (UINTPTR_TYPE)));\n \n-  default_function_type\n-    = build_varargs_function_type_list (integer_type_node, NULL_TREE);\n+  default_function_type = build_function_type (integer_type_node, NULL_TREE);\n   unsigned_ptrdiff_type_node = c_common_unsigned_type (ptrdiff_type_node);\n \n   lang_hooks.decls.pushdecl\n@@ -6044,12 +6015,12 @@ attribute_fallthrough_p (tree attr)\n {\n   if (attr == error_mark_node)\n    return false;\n-  tree t = lookup_attribute (\"fallthrough\", attr);\n+  tree t = lookup_attribute (\"\", \"fallthrough\", attr);\n   if (t == NULL_TREE)\n     return false;\n   /* It is no longer true that \"this attribute shall appear at most once in\n      each attribute-list\", but we still give a warning.  */\n-  if (lookup_attribute (\"fallthrough\", TREE_CHAIN (t)))\n+  if (lookup_attribute (\"\", \"fallthrough\", TREE_CHAIN (t)))\n     warning (OPT_Wattributes, \"attribute %<fallthrough%> specified multiple \"\n \t     \"times\");\n   /* No attribute-argument-clause shall be present.  */\n@@ -6060,7 +6031,8 @@ attribute_fallthrough_p (tree attr)\n   for (t = attr; t != NULL_TREE; t = TREE_CHAIN (t))\n     {\n       tree name = get_attribute_name (t);\n-      if (!is_attribute_p (\"fallthrough\", name))\n+      if (!is_attribute_p (\"fallthrough\", name)\n+\t  || !is_attribute_namespace_p (\"\", t))\n \t{\n \t  if (!c_dialect_cxx () && get_attribute_namespace (t) == NULL_TREE)\n \t    /* The specifications of standard attributes in C mean"}, {"sha": "dd8be7fdd3dea936ec4e5ba1ad40a0ab2ec9728e", "filename": "gcc/c-family/c-common.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -38,10 +38,9 @@ along with GCC; see the file COPYING3.  If not see\n    not.  */\n DEFTREECODE (C_MAYBE_CONST_EXPR, \"c_maybe_const_expr\", tcc_expression, 2)\n \n-/* An EXCESS_PRECISION_EXPR, currently only used for C and Objective\n-   C, represents an expression evaluated in greater range or precision\n-   than its type.  The type of the EXCESS_PRECISION_EXPR is the\n-   semantic type while the operand represents what is actually being\n+/* An EXCESS_PRECISION_EXPR represents an expression evaluated in greater\n+   range or precision than its type.  The type of the EXCESS_PRECISION_EXPR\n+   is the semantic type while the operand represents what is actually being\n    evaluated.  */\n DEFTREECODE (EXCESS_PRECISION_EXPR, \"excess_precision_expr\", tcc_expression, 1)\n "}, {"sha": "f9d0d2945a56fa74f1a81a1c6e84b48de869f583", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -104,7 +104,8 @@ enum rid\n   RID_SIZEOF,\n \n   /* C extensions */\n-  RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n+  RID_ASM,       RID_TYPEOF,   RID_TYPEOF_UNQUAL, RID_ALIGNOF,  RID_ATTRIBUTE,\n+  RID_VA_ARG,\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n   RID_TYPES_COMPATIBLE_P,      RID_BUILTIN_COMPLEX,\t     RID_BUILTIN_SHUFFLE,\n   RID_BUILTIN_SHUFFLEVECTOR,   RID_BUILTIN_CONVERTVECTOR,   RID_BUILTIN_TGMATH,\n@@ -163,30 +164,14 @@ enum rid\n   RID_CONSTCAST, RID_DYNCAST, RID_REINTCAST, RID_STATCAST,\n \n   /* C++ extensions */\n-  RID_ADDRESSOF,               RID_BASES,\n-  RID_BUILTIN_LAUNDER,         RID_DIRECT_BASES,\n-  RID_HAS_NOTHROW_ASSIGN,      RID_HAS_NOTHROW_CONSTRUCTOR,\n-  RID_HAS_NOTHROW_COPY,        RID_HAS_TRIVIAL_ASSIGN,\n-  RID_HAS_TRIVIAL_CONSTRUCTOR, RID_HAS_TRIVIAL_COPY,\n-  RID_HAS_TRIVIAL_DESTRUCTOR,  RID_HAS_UNIQUE_OBJ_REPRESENTATIONS,\n-  RID_HAS_VIRTUAL_DESTRUCTOR,  RID_BUILTIN_BIT_CAST,\n-  RID_IS_ABSTRACT,             RID_IS_AGGREGATE,\n-  RID_IS_BASE_OF,              RID_IS_CLASS,\n-  RID_IS_EMPTY,                RID_IS_ENUM,\n-  RID_IS_FINAL,                RID_IS_LAYOUT_COMPATIBLE,\n-  RID_IS_LITERAL_TYPE,\n-  RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF,\n-  RID_IS_POD,                  RID_IS_POLYMORPHIC,\n-  RID_IS_SAME_AS,\n-  RID_IS_STD_LAYOUT,           RID_IS_TRIVIAL,\n-  RID_IS_TRIVIALLY_ASSIGNABLE, RID_IS_TRIVIALLY_CONSTRUCTIBLE,\n-  RID_IS_TRIVIALLY_COPYABLE,\n-  RID_IS_UNION,                RID_UNDERLYING_TYPE,\n-  RID_IS_ASSIGNABLE,           RID_IS_CONSTRUCTIBLE,\n-  RID_IS_NOTHROW_ASSIGNABLE,   RID_IS_NOTHROW_CONSTRUCTIBLE,\n-  RID_IS_CONVERTIBLE,\t\tRID_IS_NOTHROW_CONVERTIBLE,\n-  RID_REF_CONSTRUCTS_FROM_TEMPORARY,\n-  RID_REF_CONVERTS_FROM_TEMPORARY,\n+  RID_ADDRESSOF,\n+  RID_BUILTIN_LAUNDER,\n+  RID_BUILTIN_BIT_CAST,\n+\n+#define DEFTRAIT(TCC, CODE, NAME, ARITY) \\\n+  RID_##CODE,\n+#include \"cp/cp-trait.def\"\n+#undef DEFTRAIT\n \n   /* C++11 */\n   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,\n@@ -454,16 +439,17 @@ extern machine_mode c_default_pointer_mode;\n #define D_CXX11         0x0010\t/* In C++, C++11 only.  */\n #define D_EXT\t\t0x0020\t/* GCC extension.  */\n #define D_EXT89\t\t0x0040\t/* GCC extension incorporated in C99.  */\n-#define D_ASM\t\t0x0080\t/* Disabled by -fno-asm.  */\n-#define D_OBJC\t\t0x0100\t/* In Objective C and neither C nor C++.  */\n-#define D_CXX_OBJC\t0x0200\t/* In Objective C, and C++, but not C.  */\n-#define D_CXXWARN\t0x0400\t/* In C warn with -Wcxx-compat.  */\n-#define D_CXX_CONCEPTS  0x0800\t/* In C++, only with concepts.  */\n-#define D_TRANSMEM\t0x1000\t/* C++ transactional memory TS.  */\n-#define D_CXX_CHAR8_T\t0x2000\t/* In C++, only with -fchar8_t.  */\n-#define D_CXX20\t\t0x4000  /* In C++, C++20 only.  */\n-#define D_CXX_COROUTINES 0x8000  /* In C++, only with coroutines.  */\n-#define D_CXX_MODULES\t0x10000  /* In C++, only with modules.  */\n+#define D_EXT11\t\t0x0080\t/* GCC extension incorporated in C2X.  */\n+#define D_ASM\t\t0x0100\t/* Disabled by -fno-asm.  */\n+#define D_OBJC\t\t0x0200\t/* In Objective C and neither C nor C++.  */\n+#define D_CXX_OBJC\t0x0400\t/* In Objective C, and C++, but not C.  */\n+#define D_CXXWARN\t0x0800\t/* In C warn with -Wcxx-compat.  */\n+#define D_CXX_CONCEPTS  0x1000\t/* In C++, only with concepts.  */\n+#define D_TRANSMEM\t0x2000\t/* C++ transactional memory TS.  */\n+#define D_CXX_CHAR8_T\t0x4000\t/* In C++, only with -fchar8_t.  */\n+#define D_CXX20\t\t0x8000  /* In C++, C++20 only.  */\n+#define D_CXX_COROUTINES 0x10000  /* In C++, only with coroutines.  */\n+#define D_CXX_MODULES\t0x20000  /* In C++, only with modules.  */\n \n #define D_CXX_CONCEPTS_FLAGS D_CXXONLY | D_CXX_CONCEPTS\n #define D_CXX_CHAR8_T_FLAGS D_CXXONLY | D_CXX_CHAR8_T\n@@ -1018,6 +1004,30 @@ extern void c_parse_final_cleanups (void);\n /* True iff TYPE is cv decltype(nullptr).  */\n #define NULLPTR_TYPE_P(TYPE) (TREE_CODE (TYPE) == NULLPTR_TYPE)\n \n+/* Returns the underlying type of the given enumeration type. The\n+   underlying type is determined in different ways, depending on the\n+   properties of the enum:\n+\n+     - In C++0x or C2x, the underlying type can be explicitly specified, e.g.,\n+\n+         enum E1 : char { ... } // underlying type is char\n+\n+     - In a C++0x scoped enumeration, the underlying type is int\n+       unless otherwises specified:\n+\n+         enum class E2 { ... } // underlying type is int\n+\n+     - Otherwise, the underlying type is determined based on the\n+       values of the enumerators. In this case, the\n+       ENUM_UNDERLYING_TYPE will not be set until after the definition\n+       of the enumeration is completed by finish_enum.  */\n+#define ENUM_UNDERLYING_TYPE(TYPE) \\\n+  TREE_TYPE (ENUMERAL_TYPE_CHECK (TYPE))\n+\n+/* Determines whether an ENUMERAL_TYPE has an explicit\n+   underlying type.  */\n+#define ENUM_FIXED_UNDERLYING_TYPE_P(NODE) (TYPE_LANG_FLAG_5 (NODE))\n+\n extern tree do_case (location_t, tree, tree, tree);\n extern tree build_stmt (location_t, enum tree_code, ...);\n extern tree build_real_imag_expr (location_t, enum tree_code, tree);"}, {"sha": "cdb658f6ac97a110aba6849f93432acde409544e", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -279,7 +279,7 @@ builtin_define_float_constants (const char *name_prefix,\n   /* The difference between 1 and the least value greater than 1 that is\n      representable in the given floating point type, b**(1-p).  */\n   sprintf (name, \"__%s_EPSILON__\", name_prefix);\n-  if (fmt->pnan < fmt->p)\n+  if (fmt->pnan < fmt->p && (c_dialect_cxx () || !flag_isoc2x))\n     /* This is an IBM extended double format, so 1.0 + any double is\n        representable precisely.  */\n       sprintf (buf, \"0x1p%d\", fmt->emin - fmt->p);\n@@ -319,14 +319,10 @@ builtin_define_float_constants (const char *name_prefix,\n     }\n \n   /* For C2x *_IS_IEC_60559.  0 means the type does not match an IEC\n-     60559 format, 1 that it matches a format but not operations and 2\n-     that it matches a format and operations (but may not conform to\n-     Annex F; we take this as meaning exceptions and rounding modes\n-     need not be supported).  */\n+     60559 format, 1 that it matches a format but not necessarily\n+     operations.  */\n   sprintf (name, \"__%s_IS_IEC_60559__\", name_prefix);\n-  builtin_define_with_int_value (name,\n-\t\t\t\t (fmt->ieee_bits == 0\n-\t\t\t\t  ? 0 : (fmt->round_towards_zero ? 1 : 2)));\n+  builtin_define_with_int_value (name, fmt->ieee_bits != 0);\n }\n \n /* Define __DECx__ constants for TYPE using NAME_PREFIX and SUFFIX. */\n@@ -1082,6 +1078,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_multidimensional_subscript=202110L\");\n \t  cpp_define (pfile, \"__cpp_named_character_escapes=202207L\");\n \t  cpp_define (pfile, \"__cpp_static_call_operator=202207L\");\n+\t  cpp_define (pfile, \"__cpp_implicit_move=202207L\");\n \t}\n       if (flag_concepts)\n         {\n@@ -1263,6 +1260,13 @@ c_cpp_builtins (cpp_reader *pfile)\n       builtin_define_float_constants (prefix, ggc_strdup (csuffix), \"%s\",\n \t\t\t\t      csuffix, FLOATN_NX_TYPE_NODE (i));\n     }\n+  if (bfloat16_type_node)\n+    {\n+      if (c_dialect_cxx () && cxx_dialect > cxx20)\n+\tcpp_define (pfile, \"__STDCPP_BFLOAT16_T__=1\");\n+      builtin_define_float_constants (\"BFLT16\", \"BF16\", \"%s\",\n+\t\t\t\t      \"BF16\", bfloat16_type_node);\n+    }\n \n   /* For float.h.  */\n   if (targetm.decimal_float_supported_p ())\n@@ -1373,6 +1377,12 @@ c_cpp_builtins (cpp_reader *pfile)\n \t      suffix[0] = 'l';\n \t      memcpy (float_h_prefix, \"LDBL\", 5);\n \t    }\n+\t  else if (bfloat16_type_node\n+\t\t   && mode == TYPE_MODE (bfloat16_type_node))\n+\t    {\n+\t      memcpy (suffix, \"bf16\", 5);\n+\t      memcpy (float_h_prefix, \"BFLT16\", 7);\n+\t    }\n \t  else\n \t    {\n \t      bool found_suffix = false;\n@@ -1399,22 +1409,28 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  machine_mode float16_type_mode = (float16_type_node\n \t\t\t\t\t    ? TYPE_MODE (float16_type_node)\n \t\t\t\t\t    : VOIDmode);\n+\t  machine_mode bfloat16_type_mode = (bfloat16_type_node\n+\t\t\t\t\t     ? TYPE_MODE (bfloat16_type_node)\n+\t\t\t\t\t     : VOIDmode);\n \t  switch (targetm.c.excess_precision\n \t\t    (EXCESS_PRECISION_TYPE_IMPLICIT))\n \t    {\n \t    case FLT_EVAL_METHOD_UNPREDICTABLE:\n \t    case FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE:\n \t      excess_precision = (mode == float16_type_mode\n+\t\t\t\t  || mode == bfloat16_type_mode\n \t\t\t\t  || mode == TYPE_MODE (float_type_node)\n \t\t\t\t  || mode == TYPE_MODE (double_type_node));\n \t      break;\n \n \t    case FLT_EVAL_METHOD_PROMOTE_TO_DOUBLE:\n \t      excess_precision = (mode == float16_type_mode\n+\t\t\t\t  || mode == bfloat16_type_mode\n \t\t\t\t  || mode == TYPE_MODE (float_type_node));\n \t      break;\n \t    case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT:\n-\t      excess_precision = mode == float16_type_mode;\n+\t      excess_precision = (mode == float16_type_mode\n+\t\t\t\t  || mode == bfloat16_type_mode);\n \t      break;\n \t    case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT16:\n \t      excess_precision = false;"}, {"sha": "01adea4ff413019c5b6e6a07ab62a8f5d877587f", "filename": "gcc/c-family/c-format.cc", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-format.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-format.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -488,6 +488,14 @@ static const format_length_info printf_length_specs[] =\n   { \"j\", FMT_LEN_j, STD_C99, NO_FMT, 0 },\n   { \"H\", FMT_LEN_H, STD_C2X, NO_FMT, 0 },\n   { \"D\", FMT_LEN_D, STD_C2X, \"DD\", FMT_LEN_DD, STD_C2X, 0 },\n+  { \"w8\", FMT_LEN_w8, STD_C2X, NO_FMT, 0 },\n+  { \"w16\", FMT_LEN_w16, STD_C2X, NO_FMT, 0 },\n+  { \"w32\", FMT_LEN_w32, STD_C2X, NO_FMT, 0 },\n+  { \"w64\", FMT_LEN_w64, STD_C2X, NO_FMT, 0 },\n+  { \"wf8\", FMT_LEN_wf8, STD_C2X, NO_FMT, 0 },\n+  { \"wf16\", FMT_LEN_wf16, STD_C2X, NO_FMT, 0 },\n+  { \"wf32\", FMT_LEN_wf32, STD_C2X, NO_FMT, 0 },\n+  { \"wf64\", FMT_LEN_wf64, STD_C2X, NO_FMT, 0 },\n   { NO_FMT, NO_FMT, 0 }\n };\n \n@@ -525,6 +533,14 @@ static const format_length_info scanf_length_specs[] =\n   { \"j\", FMT_LEN_j, STD_C99, NO_FMT, 0 },\n   { \"H\", FMT_LEN_H, STD_C2X, NO_FMT, 0 },\n   { \"D\", FMT_LEN_D, STD_C2X, \"DD\", FMT_LEN_DD, STD_C2X, 0 },\n+  { \"w8\", FMT_LEN_w8, STD_C2X, NO_FMT, 0 },\n+  { \"w16\", FMT_LEN_w16, STD_C2X, NO_FMT, 0 },\n+  { \"w32\", FMT_LEN_w32, STD_C2X, NO_FMT, 0 },\n+  { \"w64\", FMT_LEN_w64, STD_C2X, NO_FMT, 0 },\n+  { \"wf8\", FMT_LEN_wf8, STD_C2X, NO_FMT, 0 },\n+  { \"wf16\", FMT_LEN_wf16, STD_C2X, NO_FMT, 0 },\n+  { \"wf32\", FMT_LEN_wf32, STD_C2X, NO_FMT, 0 },\n+  { \"wf64\", FMT_LEN_wf64, STD_C2X, NO_FMT, 0 },\n   { NO_FMT, NO_FMT, 0 }\n };\n \n@@ -693,26 +709,26 @@ static const format_flag_pair strfmon_flag_pairs[] =\n static const format_char_info print_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +'I\",  \"i\",  NULL },\n-  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN }, \"-wp0#\",     \"i\",  NULL },\n-  { \"u\",   0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN }, \"-wp0'I\",    \"i\",  NULL },\n-  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128 }, \"-wp0 +#'I\", \"\",   NULL },\n-  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128 }, \"-wp0 +#I\",  \"\",   NULL },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-w\",        \"\",   NULL },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-wp\",       \"cR\", NULL },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-w\",        \"c\",  NULL },\n-  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN }, \"\",          \"W\",  NULL },\n+  { \"di\",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN,   T2X_I8,  T2X_I16, T2X_I32, T2X_I64, T2X_IF8, T2X_IF16, T2X_IF32, T2X_IF64 }, \"-wp0 +'I\",  \"i\",  NULL },\n+  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN,   T2X_U8,  T2X_U16, T2X_U32, T2X_U64, T2X_UF8, T2X_UF16, T2X_UF32, T2X_UF64 }, \"-wp0#\",     \"i\",  NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN,   T2X_U8,  T2X_U16, T2X_U32, T2X_U64, T2X_UF8, T2X_UF16, T2X_UF32, T2X_UF64 }, \"-wp0'I\",    \"i\",  NULL },\n+  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-wp0 +#'I\", \"\",   NULL },\n+  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-wp0 +#I\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-w\",        \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-wp\",       \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-w\",        \"c\",  NULL },\n+  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN,   T2X_I8,  T2X_I16, T2X_I32, T2X_I64, T2X_IF8, T2X_IF16, T2X_IF32, T2X_IF64 }, \"\",          \"W\",  NULL },\n   /* C99 conversion specifiers.  */\n-  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128 }, \"-wp0 +#'I\", \"\",   NULL },\n-  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64,  T2X_D128 }, \"-wp0 +#\",   \"\",   NULL },\n+  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-wp0 +#'I\", \"\",   NULL },\n+  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-wp0 +#\",   \"\",   NULL },\n   /* C2X conversion specifiers.  */\n-  { \"b\",   0, STD_C2X, { T2X_UI,  T2X_UC,  T2X_US,  T2X_UL,  T2X_ULL, TEX_ULL, T2X_ST,  T2X_UPD, T2X_UIM, BADLEN,  BADLEN,  BADLEN }, \"-wp0#\",     \"i\",  NULL },\n+  { \"b\",   0, STD_C2X, { T2X_UI,  T2X_UC,  T2X_US,  T2X_UL,  T2X_ULL, TEX_ULL, T2X_ST,  T2X_UPD, T2X_UIM, BADLEN,  BADLEN,  BADLEN,   T2X_U8,  T2X_U16, T2X_U32, T2X_U64, T2X_UF8, T2X_UF16, T2X_UF32, T2X_UF64 }, \"-wp0#\",     \"i\",  NULL },\n   /* X/Open conversion specifiers.  */\n-  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-w\",        \"\",   NULL },\n-  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-wp\",       \"R\",  NULL },\n+  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-w\",        \"\",   NULL },\n+  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-wp\",       \"R\",  NULL },\n   /* GNU conversion specifiers.  */\n-  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"-wp\",       \"\",   NULL },\n-  { \"B\",   0, STD_EXT, { T2X_UI,  T2X_UC,  T2X_US,  T2X_UL,  T2X_ULL, TEX_ULL, T2X_ST,  T2X_UPD, T2X_UIM, BADLEN,  BADLEN,  BADLEN }, \"-wp0#\",     \"i\",  NULL },\n+  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"-wp\",       \"\",   NULL },\n+  { \"B\",   0, STD_EXT, { T2X_UI,  T2X_UC,  T2X_US,  T2X_UL,  T2X_ULL, TEX_ULL, T2X_ST,  T2X_UPD, T2X_UIM, BADLEN,  BADLEN,  BADLEN,   T2X_U8,  T2X_U16, T2X_U32, T2X_U64, T2X_UF8, T2X_UF16, T2X_UF32, T2X_UF64 }, \"-wp0#\",     \"i\",  NULL },\n   { NULL,  0, STD_C89, NOLENGTHS, NULL, NULL, NULL }\n };\n \n@@ -860,23 +876,23 @@ static const format_char_info gcc_dump_printf_char_table[] =\n static const format_char_info scan_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN }, \"*w'I\", \"W\",   NULL },\n-  { \"u\",     1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN }, \"*w'I\", \"W\",   NULL },\n-  { \"oxX\",   1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN }, \"*w\",   \"W\",   NULL },\n-  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128 }, \"*w'\",  \"W\",   NULL },\n-  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*mw\",   \"cW\",  NULL },\n-  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*amw\",  \"cW\",  NULL },\n-  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*amw\",  \"cW[\", NULL },\n-  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*w\",   \"W\",   NULL },\n-  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN }, \"\",     \"W\",   NULL },\n+  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN,   T2X_I8,  T2X_I16, T2X_I32, T2X_I64, T2X_IF8, T2X_IF16, T2X_IF32, T2X_IF64 }, \"*w'I\", \"W\",   NULL },\n+  { \"u\",     1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN,   T2X_U8,  T2X_U16, T2X_U32, T2X_U64, T2X_UF8, T2X_UF16, T2X_UF32, T2X_UF64 }, \"*w'I\", \"W\",   NULL },\n+  { \"oxX\",   1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM, BADLEN,  BADLEN,  BADLEN,   T2X_U8,  T2X_U16, T2X_U32, T2X_U64, T2X_UF8, T2X_UF16, T2X_UF32, T2X_UF64 }, \"*w\",   \"W\",   NULL },\n+  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*w'\",  \"W\",   NULL },\n+  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*mw\",   \"cW\",  NULL },\n+  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*amw\",  \"cW\",  NULL },\n+  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*amw\",  \"cW[\", NULL },\n+  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*w\",   \"W\",   NULL },\n+  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM,  BADLEN,  BADLEN,  BADLEN,   T2X_I8,  T2X_I16, T2X_I32, T2X_I64, T2X_IF8, T2X_IF16, T2X_IF32, T2X_IF64 }, \"\",     \"W\",   NULL },\n   /* C99 conversion specifiers.  */\n-  { \"F\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128 }, \"*w'\",  \"W\",   NULL },\n-  { \"aA\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32,  T2X_D64,  T2X_D128 }, \"*w'\",  \"W\",   NULL },\n+  { \"F\",   1, STD_C99,   { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*w'\",  \"W\",   NULL },\n+  { \"aA\",   1, STD_C99,  { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN,  T2X_D32, T2X_D64, T2X_D128, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*w'\",  \"W\",   NULL },\n   /* C2X conversion specifiers.  */\n-  { \"b\",     1, STD_C2X, { T2X_UI,  T2X_UC,  T2X_US,  T2X_UL,  T2X_ULL, TEX_ULL, T2X_ST,  T2X_UPD, T2X_UIM, BADLEN,  BADLEN,  BADLEN }, \"*w\",   \"W\",   NULL },\n+  { \"b\",     1, STD_C2X, { T2X_UI,  T2X_UC,  T2X_US,  T2X_UL,  T2X_ULL, TEX_ULL, T2X_ST,  T2X_UPD, T2X_UIM, BADLEN,  BADLEN,  BADLEN,   T2X_U8,  T2X_U16, T2X_U32, T2X_U64, T2X_UF8, T2X_UF16, T2X_UF32, T2X_UF64 }, \"*w\",   \"W\",   NULL },\n   /* X/Open conversion specifiers.  */\n-  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*mw\",   \"W\",   NULL },\n-  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, \"*amw\",  \"W\",   NULL },\n+  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*mw\",   \"W\",   NULL },\n+  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,   BADLEN,   BADLEN }, \"*amw\",  \"W\",   NULL },\n   { NULL, 0, STD_C89, NOLENGTHS, NULL, NULL, NULL }\n };\n \n@@ -2900,7 +2916,7 @@ static const token_t cxx_opers[] =\n   };\n \n /* Common C/C++ keywords that are expected to be quoted within the format\n-   string.  Keywords like auto, inline, or volatile are exccluded because\n+   string.  Keywords like auto, inline, or volatile are excluded because\n    they are sometimes used in common terms like /auto variables/, /inline\n    function/, or /volatile access/ where they should not be quoted.  */\n \n@@ -2927,7 +2943,6 @@ static const token_t c_keywords[] =\n    NAME (\"noinline\", NULL),\n    NAME (\"nonnull\", NULL),\n    NAME (\"noreturn\", NULL),\n-   NAME (\"nothrow\", NULL),\n    NAME (\"offsetof\", NULL),\n    NAME (\"readonly\", \"read-only\"),\n    NAME (\"readwrite\", \"read-write\"),"}, {"sha": "173d3cd82d3ce4e958c4601b300b74b24407eaee", "filename": "gcc/c-family/c-format.h", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -36,6 +36,14 @@ enum format_lengths\n   FMT_LEN_H,\n   FMT_LEN_D,\n   FMT_LEN_DD,\n+  FMT_LEN_w8,\n+  FMT_LEN_w16,\n+  FMT_LEN_w32,\n+  FMT_LEN_w64,\n+  FMT_LEN_wf8,\n+  FMT_LEN_wf16,\n+  FMT_LEN_wf32,\n+  FMT_LEN_wf64,\n   FMT_LEN_w,   /* GCC's HOST_WIDE_INT.  */\n   FMT_LEN_MAX\n };\n@@ -124,9 +132,9 @@ struct format_type_detail\n \n \n /* Macros to fill out tables of these.  */\n-#define NOARGUMENTS\t{ T89_V, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n+#define NOARGUMENTS\t{ T89_V, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n #define BADLEN\t{ STD_C89, NULL, NULL }\n-#define NOLENGTHS\t{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n+#define NOLENGTHS\t{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n \n \n /* Structure describing a format conversion specifier (or a set of specifiers\n@@ -338,6 +346,38 @@ struct format_kind_info\n #define T2X_D64 { STD_C2X, \"_Decimal64\", T_D64 }\n #define T_D128  &dfloat128_type_node\n #define T2X_D128 { STD_C2X, \"_Decimal128\", T_D128 }\n+#define T_I8\t&int_least8_type_node\n+#define T2X_I8\t{ STD_C2X, \"int_least8_t\", T_I8 }\n+#define T_I16\t&int_least16_type_node\n+#define T2X_I16\t{ STD_C2X, \"int_least16_t\", T_I16 }\n+#define T_I32\t&int_least32_type_node\n+#define T2X_I32\t{ STD_C2X, \"int_least32_t\", T_I32 }\n+#define T_I64\t&int_least64_type_node\n+#define T2X_I64\t{ STD_C2X, \"int_least64_t\", T_I64 }\n+#define T_U8\t&uint_least8_type_node\n+#define T2X_U8\t{ STD_C2X, \"uint_least8_t\", T_U8 }\n+#define T_U16\t&uint_least16_type_node\n+#define T2X_U16\t{ STD_C2X, \"uint_least16_t\", T_U16 }\n+#define T_U32\t&uint_least32_type_node\n+#define T2X_U32\t{ STD_C2X, \"uint_least32_t\", T_U32 }\n+#define T_U64\t&uint_least64_type_node\n+#define T2X_U64\t{ STD_C2X, \"uint_least64_t\", T_U64 }\n+#define T_IF8\t&int_fast8_type_node\n+#define T2X_IF8\t{ STD_C2X, \"int_fast8_t\", T_IF8 }\n+#define T_IF16\t&int_fast16_type_node\n+#define T2X_IF16 { STD_C2X, \"int_fast16_t\", T_IF16 }\n+#define T_IF32\t&int_fast32_type_node\n+#define T2X_IF32 { STD_C2X, \"int_fast32_t\", T_IF32 }\n+#define T_IF64\t&int_fast64_type_node\n+#define T2X_IF64 { STD_C2X, \"int_fast64_t\", T_IF64 }\n+#define T_UF8\t&uint_fast8_type_node\n+#define T2X_UF8\t{ STD_C2X, \"uint_fast8_t\", T_UF8 }\n+#define T_UF16\t&uint_fast16_type_node\n+#define T2X_UF16 { STD_C2X, \"uint_fast16_t\", T_UF16 }\n+#define T_UF32\t&uint_fast32_type_node\n+#define T2X_UF32 { STD_C2X, \"uint_fast32_t\", T_UF32 }\n+#define T_UF64\t&uint_fast64_type_node\n+#define T2X_UF64 { STD_C2X, \"uint_fast64_t\", T_UF64 }\n \n /* Structure describing how format attributes such as \"printf\" are\n    interpreted as \"gnu_printf\" or \"ms_printf\" on a particular system."}, {"sha": "89c65aca28a8438d25588b22ec86c01f5769dce3", "filename": "gcc/c-family/c-lex.cc", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -378,6 +378,8 @@ c_common_has_attribute (cpp_reader *pfile, bool std_syntax)\n \t\tresult = 201803;\n \t      else if (is_attribute_p (\"nodiscard\", attr_name))\n \t\tresult = 201907;\n+\t      else if (is_attribute_p (\"assume\", attr_name))\n+\t\tresult = 202207;\n \t    }\n \t  else\n \t    {\n@@ -389,6 +391,9 @@ c_common_has_attribute (cpp_reader *pfile, bool std_syntax)\n \t\tresult = 202003;\n \t      else if (is_attribute_p (\"maybe_unused\", attr_name))\n \t\tresult = 202106;\n+\t      else if (is_attribute_p (\"noreturn\", attr_name)\n+\t\t       || is_attribute_p (\"_Noreturn\", attr_name))\n+\t\tresult = 202202;\n \t    }\n \t  if (result)\n \t    attr_name = NULL_TREE;\n@@ -995,6 +1000,22 @@ interpret_float (const cpp_token *token, unsigned int flags,\n \t  pedwarn (input_location, OPT_Wpedantic,\n \t\t   \"non-standard suffix on floating constant\");\n       }\n+    else if ((flags & CPP_N_BFLOAT16) != 0)\n+      {\n+\ttype = bfloat16_type_node;\n+\tif (type == NULL_TREE)\n+\t  {\n+\t    error (\"unsupported non-standard suffix on floating constant\");\n+\t    return error_mark_node;\n+\t  }\n+\tif (!c_dialect_cxx ())\n+\t  pedwarn (input_location, OPT_Wpedantic,\n+\t\t   \"non-standard suffix on floating constant\");\n+\telse if (cxx_dialect < cxx23)\n+\t  pedwarn (input_location, OPT_Wpedantic,\n+\t\t   \"%<bf16%> or %<BF16%> suffix on floating constant only \"\n+\t\t   \"available with %<-std=c++2b%> or %<-std=gnu++2b%>\");\n+      }\n     else if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n       type = long_double_type_node;\n     else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL\n@@ -1003,10 +1024,7 @@ interpret_float (const cpp_token *token, unsigned int flags,\n     else\n       type = double_type_node;\n \n-  if (c_dialect_cxx ())\n-    const_type = NULL_TREE;\n-  else\n-    const_type = excess_precision_type (type);\n+  const_type = excess_precision_type (type);\n   if (!const_type)\n     const_type = type;\n "}, {"sha": "5bb10355751ad6d3f09b4a9f194d0bfaaa7b2f2e", "filename": "gcc/c-family/c-omp.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-omp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-omp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -3112,8 +3112,8 @@ const struct c_omp_directive c_omp_directives[] = {\n     C_OMP_DIR_STANDALONE, false },\n   { \"begin\", \"assumes\", nullptr, PRAGMA_OMP_BEGIN,\n     C_OMP_DIR_INFORMATIONAL, false },\n-  /* { \"begin\", \"declare\", \"target\", PRAGMA_OMP_BEGIN,\n-    C_OMP_DIR_DECLARATIVE, false }, */\n+  { \"begin\", \"declare\", \"target\", PRAGMA_OMP_BEGIN,\n+    C_OMP_DIR_DECLARATIVE, false },\n   /* { \"begin\", \"declare\", \"variant\", PRAGMA_OMP_BEGIN,\n     C_OMP_DIR_DECLARATIVE, false }, */\n   /* { \"begin\", \"metadirective\", nullptr, PRAGMA_OMP_BEGIN,"}, {"sha": "32b929e3ece489afa9f94ee29461e37df8a0f228", "filename": "gcc/c-family/c-opts.cc", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-opts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-opts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -812,17 +812,9 @@ c_common_post_options (const char **pfilename)\n   C_COMMON_OVERRIDE_OPTIONS;\n #endif\n \n-  /* Excess precision other than \"fast\" requires front-end\n-     support.  */\n-  if (c_dialect_cxx ())\n-    {\n-      if (flag_excess_precision == EXCESS_PRECISION_STANDARD)\n-\tsorry (\"%<-fexcess-precision=standard%> for C++\");\n-      flag_excess_precision = EXCESS_PRECISION_FAST;\n-    }\n-  else if (flag_excess_precision == EXCESS_PRECISION_DEFAULT)\n+  if (flag_excess_precision == EXCESS_PRECISION_DEFAULT)\n     flag_excess_precision = (flag_iso ? EXCESS_PRECISION_STANDARD\n-\t\t\t\t      : EXCESS_PRECISION_FAST);\n+\t\t\t     : EXCESS_PRECISION_FAST);\n \n   /* ISO C restricts floating-point expression contraction to within\n      source-language expressions (-ffp-contract=on, currently an alias\n@@ -975,7 +967,7 @@ c_common_post_options (const char **pfilename)\n \n   /* Change flag_abi_version to be the actual current ABI level, for the\n      benefit of c_cpp_builtins, and to make comparison simpler.  */\n-  const int latest_abi_version = 17;\n+  const int latest_abi_version = 18;\n   /* Generate compatibility aliases for ABI v13 (8.2) by default.  */\n   const int abi_compat_default = 13;\n "}, {"sha": "a99d9e9c5cac4ee2b81d41984123c5dc83cd9f71", "filename": "gcc/c-family/c-ppoutput.cc", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-ppoutput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-ppoutput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ppoutput.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -184,15 +184,13 @@ class token_streamer\n   bool avoid_paste;\n   bool do_line_adjustments;\n   bool in_pragma;\n-  bool line_marker_emitted;\n \n  public:\n   token_streamer (cpp_reader *pfile)\n     :avoid_paste (false),\n     do_line_adjustments (cpp_get_options (pfile)->lang != CLK_ASM\n \t\t\t && !flag_no_line_commands),\n-    in_pragma (false),\n-    line_marker_emitted (false)\n+    in_pragma (false)\n     {\n       gcc_assert (!print.streamer);\n       print.streamer = this;\n@@ -227,7 +225,14 @@ token_streamer::stream (cpp_reader *pfile, const cpp_token *token,\n   if (token->type == CPP_EOF)\n     return;\n \n+  /* Keep track when we move into and out of system locations.  */\n+  const bool is_system_token = in_system_header_at (loc);\n+  const bool system_state_changed\n+    = (is_system_token != print.prev_was_system_token);\n+  print.prev_was_system_token = is_system_token;\n+\n   /* Subtle logic to output a space if and only if necessary.  */\n+  bool line_marker_emitted = false;\n   if (avoid_paste)\n     {\n       unsigned src_line = LOCATION_LINE (loc);\n@@ -301,19 +306,17 @@ token_streamer::stream (cpp_reader *pfile, const cpp_token *token,\n       if (do_line_adjustments\n \t  && !in_pragma\n \t  && !line_marker_emitted\n-\t  && print.prev_was_system_token != !!in_system_header_at (loc)\n+\t  && system_state_changed\n \t  && !is_location_from_builtin_token (loc))\n \t/* The system-ness of this token is different from the one of\n \t   the previous token.  Let's emit a line change to mark the\n \t   new system-ness before we emit the token.  */\n \t{\n-\t  do_line_change (pfile, token, loc, false);\n-\t  print.prev_was_system_token = !!in_system_header_at (loc);\n+\t  line_marker_emitted = do_line_change (pfile, token, loc, false);\n \t}\n       if (!in_pragma || should_output_pragmas ())\n \t{\n \t  cpp_output_token (token, print.outf);\n-\t  line_marker_emitted = false;\n \t  print.printed = true;\n \t}\n     }"}, {"sha": "c99b2ceffe6501f1860c695ddad5ed5f02a58e6b", "filename": "gcc/c-family/c-pretty-print.cc", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -466,7 +466,12 @@ pp_c_specifier_qualifier_list (c_pretty_printer *pp, tree t)\n \t  {\n \t    pp_c_whitespace (pp);\n \t    pp_c_left_paren (pp);\n-\t    pp_c_attributes_display (pp, TYPE_ATTRIBUTES (pointee));\n+\t    /* If we're dealing with the GNU form of attributes, print this:\n+\t\t void (__attribute__((noreturn)) *f) ();\n+\t       If it is the standard [[]] attribute, we'll print the attribute\n+\t       in c_pretty_printer::direct_abstract_declarator/FUNCTION_TYPE.  */\n+\t    if (!cxx11_attribute_p (TYPE_ATTRIBUTES (pointee)))\n+\t      pp_c_attributes_display (pp, TYPE_ATTRIBUTES (pointee));\n \t  }\n \telse if (!c_dialect_cxx ())\n \t  pp_c_whitespace (pp);\n@@ -595,6 +600,13 @@ c_pretty_printer::direct_abstract_declarator (tree t)\n     case FUNCTION_TYPE:\n       pp_c_parameter_type_list (this, t);\n       direct_abstract_declarator (TREE_TYPE (t));\n+      /* If this is the standard [[]] attribute, print\n+\t void (*)() [[noreturn]];  */\n+      if (cxx11_attribute_p (TYPE_ATTRIBUTES (t)))\n+\t{\n+\t  pp_space (this);\n+\t  pp_c_attributes_display (this, TYPE_ATTRIBUTES (t));\n+\t}\n       break;\n \n     case ARRAY_TYPE:\n@@ -850,32 +862,7 @@ c_pretty_printer::declaration (tree t)\n   pp_c_init_declarator (this, t);\n }\n \n-/* Pretty-print ATTRIBUTES using GNU C extension syntax.  */\n-\n-void\n-pp_c_attributes (c_pretty_printer *pp, tree attributes)\n-{\n-  if (attributes == NULL_TREE)\n-    return;\n-\n-  pp_c_ws_string (pp, \"__attribute__\");\n-  pp_c_left_paren (pp);\n-  pp_c_left_paren (pp);\n-  for (; attributes != NULL_TREE; attributes = TREE_CHAIN (attributes))\n-    {\n-      pp_tree_identifier (pp, TREE_PURPOSE (attributes));\n-      if (TREE_VALUE (attributes))\n-\tpp_c_call_argument_list (pp, TREE_VALUE (attributes));\n-\n-      if (TREE_CHAIN (attributes))\n-\tpp_separate_with (pp, ',');\n-    }\n-  pp_c_right_paren (pp);\n-  pp_c_right_paren (pp);\n-}\n-\n-/* Pretty-print ATTRIBUTES using GNU C extension syntax for attributes\n-   marked to be displayed on disgnostic.  */\n+/* Pretty-print ATTRIBUTES marked to be displayed on diagnostic.  */\n \n void\n pp_c_attributes_display (c_pretty_printer *pp, tree a)\n@@ -885,37 +872,60 @@ pp_c_attributes_display (c_pretty_printer *pp, tree a)\n   if (a == NULL_TREE)\n     return;\n \n+  const bool std_p = cxx11_attribute_p (a);\n+\n   for (; a != NULL_TREE; a = TREE_CHAIN (a))\n     {\n-      const struct attribute_spec *as;\n-      as = lookup_attribute_spec (TREE_PURPOSE (a));\n+      const struct attribute_spec *as\n+\t= lookup_attribute_spec (get_attribute_name (a));\n       if (!as || as->affects_type_identity == false)\n         continue;\n       if (c_dialect_cxx ()\n \t  && !strcmp (\"transaction_safe\", as->name))\n \t/* In C++ transaction_safe is printed at the end of the declarator.  */\n \tcontinue;\n       if (is_first)\n-       {\n-         pp_c_ws_string (pp, \"__attribute__\");\n-         pp_c_left_paren (pp);\n-         pp_c_left_paren (pp);\n-         is_first = false;\n-       }\n+\t{\n+\t  if (std_p)\n+\t    {\n+\t      pp_c_left_bracket (pp);\n+\t      pp_c_left_bracket (pp);\n+\t    }\n+\t  else\n+\t    {\n+\t      pp_c_ws_string (pp, \"__attribute__\");\n+\t      pp_c_left_paren (pp);\n+\t      pp_c_left_paren (pp);\n+\t    }\n+\t  is_first = false;\n+\t}\n       else\n-       {\n-         pp_separate_with (pp, ',');\n-       }\n-      pp_tree_identifier (pp, TREE_PURPOSE (a));\n+\tpp_separate_with (pp, ',');\n+      tree ns;\n+      if (std_p && (ns = get_attribute_namespace (a)))\n+\t{\n+\t  pp_tree_identifier (pp, ns);\n+\t  pp_colon (pp);\n+\t  pp_colon (pp);\n+\t}\n+      pp_tree_identifier (pp, get_attribute_name (a));\n       if (TREE_VALUE (a))\n-       pp_c_call_argument_list (pp, TREE_VALUE (a));\n+\tpp_c_call_argument_list (pp, TREE_VALUE (a));\n     }\n \n   if (!is_first)\n     {\n-      pp_c_right_paren (pp);\n-      pp_c_right_paren (pp);\n-      pp_c_whitespace (pp);\n+      if (std_p)\n+\t{\n+\t  pp_c_right_bracket (pp);\n+\t  pp_c_right_bracket (pp);\n+\t}\n+      else\n+\t{\n+\t  pp_c_right_paren (pp);\n+\t  pp_c_right_paren (pp);\n+\t  pp_c_whitespace (pp);\n+\t}\n     }\n }\n "}, {"sha": "92674ab4d06a0d528bfbdf7c4fe7e306f936658b", "filename": "gcc/c-family/c-pretty-print.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -119,7 +119,6 @@ void pp_c_space_for_pointer_operator (c_pretty_printer *, tree);\n /* Declarations.  */\n void pp_c_tree_decl_identifier (c_pretty_printer *, tree);\n void pp_c_function_definition (c_pretty_printer *, tree);\n-void pp_c_attributes (c_pretty_printer *, tree);\n void pp_c_attributes_display (c_pretty_printer *, tree);\n void pp_c_cv_qualifiers (c_pretty_printer *pp, int qualifiers, bool func_type);\n void pp_c_type_qualifier_list (c_pretty_printer *, tree);"}, {"sha": "cd59c3cafa918c116be948397994bb21407d9f9e", "filename": "gcc/c-family/c-warn.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-warn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc-warn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1415,7 +1415,8 @@ warnings_for_convert_and_check (location_t loc, tree type, tree expr,\n \n   if (TREE_CODE (expr) == INTEGER_CST\n       && (TREE_CODE (type) == INTEGER_TYPE\n-\t  || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  || (TREE_CODE (type) == ENUMERAL_TYPE\n+\t      && TREE_CODE (ENUM_UNDERLYING_TYPE (type)) != BOOLEAN_TYPE))\n       && !int_fits_type_p (expr, type))\n     {\n       /* Do not diagnose overflow in a constant expression merely"}, {"sha": "63a300ecd7c582394a455218909ac53a6ca5c75a", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -555,6 +555,10 @@ Wdangling-pointer=\n C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_dangling_pointer) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall, 2, 0) IntegerRange(0, 2)\n Warn for uses of pointers to auto variables whose lifetime has ended.\n \n+Wdangling-reference\n+C++ ObjC++ Var(warn_dangling_reference) Warning LangEnabledBy(C++ ObjC++, Wall)\n+Warn when a reference is bound to a temporary whose lifetime has ended.\n+\n Wdate-time\n C ObjC C++ ObjC++ CPP(warn_date_time) CppReason(CPP_W_DATE_TIME) Var(cpp_warn_date_time) Init(0) Warning\n Warn about __TIME__, __DATE__ and __TIMESTAMP__ usage.\n@@ -1508,8 +1512,8 @@ fall-virtual\n C++ ObjC++ WarnRemoved\n \n fallow-parameterless-variadic-functions\n-C ObjC Var(flag_allow_parameterless_variadic_functions)\n-Allow variadic functions without named parameter.\n+C ObjC Ignore\n+Does nothing. Preserved for backward compatibility.\n \n falt-external-templates\n C++ ObjC++ WarnRemoved\n@@ -2076,6 +2080,13 @@ fsized-deallocation\n C++ ObjC++ Var(flag_sized_deallocation) Init(-1)\n Enable C++14 sized deallocation support.\n \n+fstrict-flex-arrays\n+C C++ Common Alias(fstrict-flex-arrays=,3,0)\n+\n+fstrict-flex-arrays=\n+C C++ Common Joined RejectNegative UInteger Var(flag_strict_flex_arrays) Init(0) IntegerRange(0,3)\n+-fstrict-flex-arrays=<level>    Control when to treat the trailing array of a structure as a flexible array member for the purposes of accessing the elements of such an array. The default is treating all trailing arrays of structures as flexible array members.\n+\n fsquangle\n C++ ObjC++ WarnRemoved\n "}, {"sha": "98392ce51c2e39509473c8c3484b30769f52f6bf", "filename": "gcc/c-family/name-hint.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fname-hint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc-family%2Fname-hint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fname-hint.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -106,7 +106,7 @@ class name_hint\n \n   /* Take ownership of this name_hint's deferred_diagnostic, for use\n      in chaining up deferred diagnostics.  */\n-  std::unique_ptr<deferred_diagnostic> take_deferred () { return move (m_deferred); }\n+  std::unique_ptr<deferred_diagnostic> take_deferred () { return std::move (m_deferred); }\n \n   /* Call this on a name_hint if the corresponding warning was not emitted,\n      in which case we should also not emit the deferred_diagnostic.  */"}, {"sha": "4e71198c50139c6fe157d868a95199273d883c3b", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1,3 +1,243 @@\n+2022-10-28  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-decl.cc (grokdeclarator): Pass\n+\targ_info->no_named_args_stdarg_p to build_function_type.\n+\t(grokparms): Check arg_info->no_named_args_stdarg_p before\n+\tconverting () to (void).\n+\t(build_arg_info): Initialize no_named_args_stdarg_p.\n+\t(get_parm_info): Set no_named_args_stdarg_p.\n+\t(start_function): Pass TYPE_NO_NAMED_ARGS_STDARG_P to\n+\tbuild_function_type.\n+\t(store_parm_decls): Count (...) functions as prototyped.\n+\t* c-parser.cc (c_parser_direct_declarator): Allow '...' after open\n+\tparenthesis to start parameter list.\n+\t(c_parser_parms_list_declarator): Always allow '...' with no\n+\targuments, call pedwarn_c11 and set no_named_args_stdarg_p.\n+\t* c-tree.h (struct c_arg_info): Add field no_named_args_stdarg_p.\n+\t* c-typeck.cc (composite_type): Handle\n+\tTYPE_NO_NAMED_ARGS_STDARG_P.\n+\t(function_types_compatible_p): Compare\n+\tTYPE_NO_NAMED_ARGS_STDARG_P.\n+\n+2022-10-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.cc (c_parser_omp_all_clauses): Allow optional\n+\tcomma before the first clause.\n+\t(c_parser_omp_allocate, c_parser_omp_atomic, c_parser_omp_depobj,\n+\tc_parser_omp_flush, c_parser_omp_scan_loop_body,\n+\tc_parser_omp_ordered, c_finish_omp_declare_variant,\n+\tc_parser_omp_declare_target, c_parser_omp_declare_reduction,\n+\tc_parser_omp_requires, c_parser_omp_error,\n+\tc_parser_omp_assumption_clauses): Likewise.\n+\n+2022-10-28  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/61469\n+\t* c-convert.cc (c_convert): Handle enums with underlying boolean\n+\ttype like bool.\n+\t* c-decl.cc (shadow_tag_warned): Allow shadowing declarations for\n+\tenums with enum type specifier, but give errors for storage class\n+\tspecifiers, qualifiers or alignment specifiers in non-definition\n+\tdeclarations of such enums.\n+\t(grokdeclarator): Give error for non-definition use of type\n+\tspecifier with an enum type specifier.\n+\t(parser_xref_tag): Add argument has_enum_type_specifier.  Pass it\n+\tto lookup_tag and use it to set ENUM_FIXED_UNDERLYING_TYPE_P.\n+\t(xref_tag): Update call to parser_xref_tag.\n+\t(start_enum): Add argument fixed_underlying_type.  Complete enum\n+\ttype with a fixed underlying type given in the definition.  Give\n+\terror for defining without a fixed underlying type in the\n+\tdefinition if one was given in a prior declaration.  Do not mark\n+\tenums with fixed underlying type as packed for -fshort-enums.\n+\tStore the enum type in the_enum.\n+\t(finish_enum): Do not adjust types of values or check their range\n+\tfor an enum with a fixed underlying type.  Set underlying type of\n+\tenum and variants.\n+\t(build_enumerator): Check enumeration constants for enum with\n+\tfixed underlying type against that type and convert to that type.\n+\tIncrement in the underlying integer type, with handling for bool.\n+\t(c_simulate_enum_decl): Update call to start_enum.\n+\t(declspecs_add_type): Set specs->enum_type_specifier_ref_p.\n+\t* c-objc-common.cc (c_get_alias_set): Use ENUM_UNDERLYING_TYPE\n+\trather than recomputing an underlying type based on size.\n+\t* c-parser.cc (c_parser_declspecs)\n+\t(c_parser_struct_or_union_specifier, c_parser_typeof_specifier):\n+\tSet has_enum_type_specifier for type specifiers.\n+\t(c_parser_enum_specifier): Handle enum type specifiers.\n+\t(c_parser_struct_or_union_specifier): Update call to\n+\tparser_xref_tag.\n+\t(c_parser_omp_atomic): Check for boolean increment or decrement\n+\tusing C_BOOLEAN_TYPE_P.\n+\t* c-tree.h (C_BOOLEAN_TYPE_P): New.\n+\t(struct c_typespec): Add has_enum_type_specifier.\n+\t(struct c_declspecs): Add enum_type_specifier_ref_p.\n+\t(struct c_enum_contents): Add enum_type.\n+\t(start_enum, parser_xref_tag): Update prototypes.\n+\t* c-typeck.cc (composite_type): Allow for enumerated types\n+\tcompatible with bool.\n+\t(common_type, comptypes_internal, perform_integral_promotions):\n+\tUse ENUM_UNDERLYING_TYPE.\n+\t(parser_build_binary_op, build_unary_op, convert_for_assignment)\n+\t(c_finish_return, c_start_switch, build_binary_op): Check for\n+\tboolean types using C_BOOLEAN_TYPE_P.\n+\n+2022-10-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/107358\n+\t* c-typeck.cc (build_binary_op): Pass operands before excess precision\n+\tpromotions to scalar_to_vector call.\n+\n+2022-10-24  Arsen Arsenovi\u0107  <arsen@aarsen.me>\n+\n+\t* c-decl.cc (finish_function): Ignore hosted when deciding\n+\twhether to implicitly return zero, but check noreturn.\n+\t* c-objc-common.cc (c_missing_noreturn_ok_p): Loosen the\n+\trequirements to just MAIN_NAME_P when hosted, or `int main'\n+\totherwise.\n+\n+2022-10-20  Richard Biener  <rguenther@suse.de>\n+\n+\tPR c/107305\n+\tPR c/107306\n+\t* gimple-parser.cc (c_parser_parse_gimple_body): Verify\n+\tthe parsed IL and zap the body on error.\n+\n+2022-10-18  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/107164\n+\t* c-decl.cc (shadow_tag_warned): If pedantic, diagnose \"enum tag;\"\n+\twith previous declaration visible.\n+\n+2022-10-18  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/36113\n+\t* c-decl.cc (finish_enum): If any enumerators do not fit in int,\n+\tconvert all to the type of the enumeration.  pedwarn if no integer\n+\ttype fits all enumerators and default to\n+\twidest_integer_literal_type_node in that case.  Otherwise pedwarn\n+\tfor type wider than intmax_t.\n+\t(build_enumerator): pedwarn for enumerators outside the range of\n+\tuintmax_t or intmax_t, and otherwise use pedwarn_c11 for\n+\tenumerators outside the range of int.  On overflow, attempt to\n+\tfind a wider type that can hold the value of the next enumerator.\n+\tDo not convert value to type determined with\n+\tc_common_type_for_size.\n+\n+2022-10-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-typeck.cc (convert_arguments): Don't promote __bf16 to\n+\tdouble.\n+\n+2022-10-14  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-decl.cc (build_compound_literal): Add parameter scspecs.\n+\tHandle storage class specifiers.\n+\t* c-parser.cc (c_token_starts_compound_literal)\n+\t(c_parser_compound_literal_scspecs): New.\n+\t(c_parser_postfix_expression_after_paren_type): Add parameter\n+\tscspecs.  Call pedwarn_c11 for use of storage class specifiers.\n+\tUpdate call to build_compound_literal.\n+\t(c_parser_cast_expression, c_parser_sizeof_expression)\n+\t(c_parser_alignof_expression): Handle storage class specifiers for\n+\tcompound literals.  Update calls to\n+\tc_parser_postfix_expression_after_paren_type.\n+\t(c_parser_postfix_expression): Update syntax comment.\n+\t* c-tree.h (build_compound_literal): Update prototype.\n+\t* c-typeck.cc (c_mark_addressable): Diagnose taking address of\n+\tregister compound literal.\n+\n+2022-10-07  Qing Zhao  <qing.zhao@oracle.com>\n+\n+\t* c-decl.cc (flexible_array_member_type_p): New function.\n+\t(one_element_array_type_p): Likewise.\n+\t(zero_length_array_type_p): Likewise.\n+\t(add_flexible_array_elts_to_size): Call new utility\n+\troutine flexible_array_member_type_p.\n+\t(is_flexible_array_member_p): New function.\n+\t(finish_struct): Set the new DECL_NOT_FLEXARRAY flag.\n+\n+2022-10-06  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-parser.cc (c_parse_init): Add D_EXT11 to mask if flag_no_asm\n+\tand not C2x.\n+\t(c_keyword_starts_typename, c_token_starts_declspecs)\n+\t(c_parser_declspecs, c_parser_objc_selector): Handle\n+\tRID_TYPEOF_UNQUAL.\n+\t(c_parser_typeof_specifier): Handle RID_TYPEOF_UNQUAL.\n+\tDistinguish typeof for C2x from __typeof__ for all standard\n+\tversions and typeof before C2x.\n+\t* c-typeck.cc (build_function_call_vec): Use unqualified version\n+\tof non-void return type.\n+\t(build_unary_op): Use unqualified type for increment and\n+\tdecrement.\n+\n+2022-10-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.cc (c_parser_omp_assumption_clauses): Emit IFN_ASSUME\n+\tcall for holds clause on assume construct.\n+\n+2022-10-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/106654\n+\t* c-parser.cc (handle_assume_attribute): New function.\n+\t(c_parser_declaration_or_fndef): Handle assume attribute.\n+\t(c_parser_attribute_arguments): Add assume_attr argument,\n+\tif true, parse first argument as conditional expression.\n+\t(c_parser_gnu_attribute, c_parser_std_attribute): Adjust\n+\tc_parser_attribute_arguments callers.\n+\t(c_parser_statement_after_labels) <case RID_ATTRIBUTE>: Handle\n+\tassume attribute.\n+\n+2022-10-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-lang.h (struct c_omp_declare_target_attr): New type.\n+\t(current_omp_declare_target_attribute): Change type from\n+\tint to vec<c_omp_declare_target_attr, va_gc> *.\n+\t* c-parser.cc (c_parser_translation_unit): Adjust for that change.\n+\tIf last pushed directive was begin declare target, use different\n+\twording and simplify format strings for easier translations.\n+\t(c_parser_omp_clause_device_type): Uncomment\n+\tcheck_no_duplicate_clause call.\n+\t(c_parser_omp_declare_target): Adjust for the\n+\tcurrent_omp_declare_target_attribute type change, push { -1 }.\n+\tUse error_at rather than warning_at for declare target with\n+\tonly device_type clauses.\n+\t(OMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK): Define.\n+\t(c_parser_omp_begin): Add begin declare target support.\n+\t(c_parser_omp_end): Adjust for the\n+\tcurrent_omp_declare_target_attribute type change, adjust\n+\tdiagnostics wording and simplify format strings for easier\n+\ttranslations.\n+\t* c-decl.cc (current_omp_declare_target_attribute): Change type from\n+\tint to vec<c_omp_declare_target_attr, va_gc> *.\n+\t(c_decl_attributes): Adjust for the\n+\tcurrent_omp_declare_target_attribute type change.  If device_type\n+\twas present on begin declare target, add \"omp declare target host\"\n+\tand/or \"omp declare target nohost\" attributes.\n+\n+2022-09-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-decl.cc (handle_std_noreturn_attribute): New function.\n+\t(std_attribute_table): Add _Noreturn and noreturn.\n+\n+2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-lang.h (current_omp_begin_assumes): Declare.\n+\t* c-parser.cc: Include bitmap.h.\n+\t(c_parser_omp_end_declare_target): Rename to ...\n+\t(c_parser_omp_end): ... this.  Handle also end assumes.\n+\t(c_parser_omp_begin, c_parser_omp_assumption_clauses,\n+\tc_parser_omp_assumes, c_parser_omp_assume): New functions.\n+\t(c_parser_translation_unit): Also diagnose #pragma omp begin assumes\n+\twithout corresponding #pragma omp end assumes.\n+\t(c_parser_pragma): Use %s in may only be used at file scope\n+\tdiagnostics to decrease number of translatable messages.  Handle\n+\tPRAGMA_OMP_BEGIN and PRAGMA_OMP_ASSUMES.  Handle PRAGMA_OMP_END\n+\trather than PRAGMA_OMP_END_DECLARE_TARGET and call c_parser_omp_end\n+\tfor it rather than c_parser_omp_end_declare_target.\n+\t(c_parser_omp_construct): Handle PRAGMA_OMP_ASSUME.\n+\t* c-decl.cc (current_omp_begin_assumes): Define.\n+\n 2022-09-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/106981"}, {"sha": "8a43e5f6f33c44e9a17c7af4015db62dd0b40434", "filename": "gcc/c/c-convert.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-convert.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -110,8 +110,13 @@ c_convert (tree type, tree expr, bool init_const)\n     case VOID_TYPE:\n       return fold_convert_loc (loc, type, e);\n \n-    case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n+      if (ENUM_UNDERLYING_TYPE (type) != NULL_TREE\n+\t  && TREE_CODE (ENUM_UNDERLYING_TYPE (type)) == BOOLEAN_TYPE)\n+\tgoto convert_to_boolean;\n+      gcc_fallthrough ();\n+\n+    case INTEGER_TYPE:\n       if (sanitize_flags_p (SANITIZE_FLOAT_CAST)\n \t  && current_function_decl != NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n@@ -129,6 +134,7 @@ c_convert (tree type, tree expr, bool init_const)\n       goto maybe_fold;\n \n     case BOOLEAN_TYPE:\n+    convert_to_boolean:\n       return fold_convert_loc\n \t(loc, type, c_objc_common_truthvalue_conversion (input_location, expr));\n "}, {"sha": "795c97134f2b45c636e140117778456a9107e8c5", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 483, "deletions": 102, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -153,9 +153,9 @@ static int warn_about_return_type;\n \n static bool undef_nested_function;\n \n-/* If non-zero, implicit \"omp declare target\" attribute is added into the\n-   attribute lists.  */\n-int current_omp_declare_target_attribute;\n+/* Vector of implicit \"omp declare target\" attributes to be added into\n+   the attribute lists.  */\n+vec<c_omp_declare_target_attr, va_gc> *current_omp_declare_target_attribute;\n \n /* If non-zero, we are inside of\n    #pragma omp begin assumes ... #pragma omp end assumes region.  */\n@@ -4480,11 +4480,34 @@ handle_nodiscard_attribute (tree *node, tree name, tree /*args*/,\n     }\n   return NULL_TREE;\n }\n+\n+/* Handle the standard [[noreturn]] attribute.  */\n+\n+static tree\n+handle_std_noreturn_attribute (tree *node, tree name, tree args,\n+\t\t\t       int flags, bool *no_add_attrs)\n+{\n+  /* Unlike GNU __attribute__ ((noreturn)), the standard [[noreturn]]\n+     only applies to functions, not function pointers.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    return handle_noreturn_attribute (node, name, args, flags, no_add_attrs);\n+  else\n+    {\n+      pedwarn (input_location, OPT_Wattributes,\n+\t       \"standard %qE attribute can only be applied to functions\",\n+\t       name);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+}\n+\n /* Table of supported standard (C2x) attributes.  */\n const struct attribute_spec std_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req,\n        affects_type_identity, handler, exclude } */\n+  { \"_Noreturn\", 0, 0, false, false, false, false,\n+    handle_std_noreturn_attribute, NULL },\n   { \"deprecated\", 0, 1, false, false, false, false,\n     handle_deprecated_attribute, NULL },\n   { \"fallthrough\", 0, 0, false, false, false, false,\n@@ -4493,6 +4516,8 @@ const struct attribute_spec std_attribute_table[] =\n     handle_unused_attribute, NULL },\n   { \"nodiscard\", 0, 1, false, false, false, false,\n     handle_nodiscard_attribute, NULL },\n+  { \"noreturn\", 0, 0, false, false, false, false,\n+    handle_std_noreturn_attribute, NULL },\n   { NULL, 0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -4789,6 +4814,21 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t      warned = 1;\n \t      pending_xref_error ();\n \t    }\n+\t  else if (declspecs->typespec_kind != ctsk_tagdef\n+\t\t   && declspecs->typespec_kind != ctsk_tagfirstref\n+\t\t   && declspecs->typespec_kind != ctsk_tagfirstref_attrs\n+\t\t   && code == ENUMERAL_TYPE\n+\t\t   && !declspecs->enum_type_specifier_ref_p)\n+\t    {\n+\t      bool warned_enum = false;\n+\t      if (warned != 1)\n+\t\twarned_enum = pedwarn (input_location, OPT_Wpedantic,\n+\t\t\t\t       \"empty declaration of %<enum%> type \"\n+\t\t\t\t       \"does not redeclare tag\");\n+\t      if (warned_enum)\n+\t\twarned = 1;\n+\t      pending_xref_error ();\n+\t    }\n \t  else\n \t    {\n \t      pending_invalid_xref = NULL_TREE;\n@@ -4844,6 +4884,38 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n       warned = 1;\n     }\n \n+  if (declspecs->enum_type_specifier_ref_p && !warned)\n+    {\n+      if (declspecs->storage_class != csc_none)\n+\t{\n+\t  error (\"storage class specifier in empty declaration with %<enum%> \"\n+\t\t \"underlying type\");\n+\t  warned = 1;\n+\t}\n+      else if (declspecs->thread_p)\n+\t{\n+\t  error (\"%qs in empty declaration with %<enum%> underlying type\",\n+\t\t declspecs->thread_gnu_p ? \"__thread\" : \"_Thread_local\");\n+\t  warned = 1;\n+\t}\n+      else if (declspecs->const_p\n+\t       || declspecs->volatile_p\n+\t       || declspecs->atomic_p\n+\t       || declspecs->restrict_p\n+\t       || declspecs->address_space)\n+\t{\n+\t  error (\"type qualifier in empty declaration with %<enum%> \"\n+\t\t \"underlying type\");\n+\t  warned = 1;\n+\t}\n+      else if (declspecs->alignas_p)\n+\t{\n+\t  error (\"%<alignas%> in empty declaration with %<enum%> \"\n+\t\t \"underlying type\");\n+\t  warned = 1;\n+\t}\n+    }\n+\n   if (!warned && !in_system_header_at (input_location)\n       && declspecs->storage_class != csc_none)\n     {\n@@ -5009,6 +5081,41 @@ set_array_declarator_inner (struct c_declarator *decl,\n   return decl;\n }\n \n+/* Determine whether TYPE is a ISO C99 flexible array memeber type \"[]\".  */\n+static bool\n+flexible_array_member_type_p (const_tree type)\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_SIZE (type) == NULL_TREE\n+      && TYPE_DOMAIN (type) != NULL_TREE\n+      && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Determine whether TYPE is a one-element array type \"[1]\".  */\n+static bool\n+one_element_array_type_p (const_tree type)\n+{\n+  if (TREE_CODE (type) != ARRAY_TYPE)\n+    return false;\n+  return integer_zerop (array_type_nelts (type));\n+}\n+\n+/* Determine whether TYPE is a zero-length array type \"[0]\".  */\n+static bool\n+zero_length_array_type_p (const_tree type)\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    if (tree type_size = TYPE_SIZE_UNIT (type))\n+      if ((integer_zerop (type_size))\n+\t   && TYPE_DOMAIN (type) != NULL_TREE\n+\t   && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE)\n+\treturn true;\n+  return false;\n+}\n+\n /* INIT is a constructor that forms DECL's initializer.  If the final\n    element initializes a flexible array field, add the size of that\n    initializer to DECL's size.  */\n@@ -5023,10 +5130,7 @@ add_flexible_array_elts_to_size (tree decl, tree init)\n \n   elt = CONSTRUCTOR_ELTS (init)->last ().value;\n   type = TREE_TYPE (elt);\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_SIZE (type) == NULL_TREE\n-      && TYPE_DOMAIN (type) != NULL_TREE\n-      && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE)\n+  if (flexible_array_member_type_p (type))\n     {\n       complete_array_type (&type, elt, false);\n       DECL_SIZE (decl)\n@@ -5080,7 +5184,7 @@ static tree\n c_decl_attributes (tree *node, tree attributes, int flags)\n {\n   /* Add implicit \"omp declare target\" attribute if requested.  */\n-  if (current_omp_declare_target_attribute\n+  if (vec_safe_length (current_omp_declare_target_attribute)\n       && ((VAR_P (*node) && is_global_var (*node))\n \t  || TREE_CODE (*node) == FUNCTION_DECL))\n     {\n@@ -5094,6 +5198,22 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n \t  attributes = tree_cons (get_identifier (\"omp declare target block\"),\n \t\t\t\t  NULL_TREE, attributes);\n \t}\n+      if (TREE_CODE (*node) == FUNCTION_DECL)\n+\t{\n+\t  int device_type\n+\t    = current_omp_declare_target_attribute->last ().device_type;\n+\t  device_type = MAX (device_type, 0);\n+\t  if ((device_type & OMP_CLAUSE_DEVICE_TYPE_HOST) != 0\n+\t      && !lookup_attribute (\"omp declare target host\", attributes))\n+\t    attributes\n+\t      = tree_cons (get_identifier (\"omp declare target host\"),\n+\t\t\t   NULL_TREE, attributes);\n+\t  if ((device_type & OMP_CLAUSE_DEVICE_TYPE_NOHOST) != 0\n+\t      && !lookup_attribute (\"omp declare target nohost\", attributes))\n+\t    attributes\n+\t      = tree_cons (get_identifier (\"omp declare target nohost\"),\n+\t\t\t   NULL_TREE, attributes);\n+\t}\n     }\n \n   /* Look up the current declaration with all the attributes merged\n@@ -5975,34 +6095,61 @@ mark_forward_parm_decls (void)\n    literal.  NON_CONST is true if the initializers contain something\n    that cannot occur in a constant expression.  If ALIGNAS_ALIGN is nonzero,\n    it is the (valid) alignment for this compound literal, as specified\n-   with _Alignas.  */\n+   with _Alignas.  SCSPECS are the storage class specifiers (C2x) from the\n+   compound literal.  */\n \n tree\n build_compound_literal (location_t loc, tree type, tree init, bool non_const,\n-\t\t\tunsigned int alignas_align)\n+\t\t\tunsigned int alignas_align,\n+\t\t\tstruct c_declspecs *scspecs)\n {\n   /* We do not use start_decl here because we have a type, not a declarator;\n      and do not use finish_decl because the decl should be stored inside\n      the COMPOUND_LITERAL_EXPR rather than added elsewhere as a DECL_EXPR.  */\n   tree decl;\n   tree complit;\n   tree stmt;\n+  bool threadp = scspecs ? scspecs->thread_p : false;\n+  enum c_storage_class storage_class = (scspecs\n+\t\t\t\t\t? scspecs->storage_class\n+\t\t\t\t\t: csc_none);\n \n   if (type == error_mark_node\n       || init == error_mark_node)\n     return error_mark_node;\n \n+  if (current_scope == file_scope && storage_class == csc_register)\n+    {\n+      error_at (loc, \"file-scope compound literal specifies %<register%>\");\n+      storage_class = csc_none;\n+    }\n+\n+  if (current_scope != file_scope && threadp && storage_class == csc_none)\n+    {\n+      error_at (loc, \"compound literal implicitly auto and declared %qs\",\n+\t\tscspecs->thread_gnu_p ? \"__thread\" : \"_Thread_local\");\n+      threadp = false;\n+    }\n+\n   decl = build_decl (loc, VAR_DECL, NULL_TREE, type);\n   DECL_EXTERNAL (decl) = 0;\n   TREE_PUBLIC (decl) = 0;\n-  TREE_STATIC (decl) = (current_scope == file_scope);\n+  TREE_STATIC (decl) = (current_scope == file_scope\n+\t\t\t|| storage_class == csc_static);\n   DECL_CONTEXT (decl) = current_function_decl;\n   TREE_USED (decl) = 1;\n   DECL_READ_P (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n   C_DECL_COMPOUND_LITERAL_P (decl) = 1;\n   TREE_TYPE (decl) = type;\n+  if (threadp)\n+    set_decl_tls_model (decl, decl_default_tls_model (decl));\n+  if (storage_class == csc_register)\n+    {\n+      C_DECL_REGISTER (decl) = 1;\n+      DECL_REGISTER (decl) = 1;\n+    }\n   c_apply_type_quals_to_decl (TYPE_QUALS (strip_array_types (type)), decl);\n   if (alignas_align)\n     {\n@@ -6382,6 +6529,16 @@ grokdeclarator (const struct c_declarator *declarator,\n       }\n   }\n \n+  /* An enum type specifier (\": specifier-qualifier-list\") may only be\n+     specified when the enum is being defined or in an empty\n+     declaration of the form \"enum identifier enum-type-specifier;\".\n+     Except for the case of an empty declaration that has additional\n+     declaration specifiers, all invalid contexts (declarations that\n+     aren't empty, type names, parameter declarations, member\n+     declarations) pass through grokdeclarator.  */\n+  if (declspecs->enum_type_specifier_ref_p)\n+    error_at (loc, \"%<enum%> underlying type may not be specified here\");\n+\n   /* A function definition's declarator must have the form of\n      a function declarator.  */\n \n@@ -7138,7 +7295,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t      }\n \t    type_quals = TYPE_UNQUALIFIED;\n \n-\t    type = build_function_type (type, arg_types);\n+\t    type = build_function_type (type, arg_types,\n+\t\t\t\t\targ_info->no_named_args_stdarg_p);\n \t    declarator = declarator->declarator;\n \n \t    /* Set the TYPE_CONTEXTs for each tagged type which is local to\n@@ -7903,7 +8061,8 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n       /* In C2X, convert () to (void).  */\n       if (flag_isoc2x\n \t  && !arg_types\n-\t  && !arg_info->parms)\n+\t  && !arg_info->parms\n+\t  && !arg_info->no_named_args_stdarg_p)\n \targ_types = arg_info->types = void_list_node;\n \n       /* If there is a parameter of incomplete type in a definition,\n@@ -7973,6 +8132,7 @@ build_arg_info (void)\n   ret->others = NULL_TREE;\n   ret->pending_sizes = NULL;\n   ret->had_vla_unspec = 0;\n+  ret->no_named_args_stdarg_p = 0;\n   return ret;\n }\n \n@@ -8164,31 +8324,37 @@ get_parm_info (bool ellipsis, tree expr)\n   arg_info->types = types;\n   arg_info->others = others;\n   arg_info->pending_sizes = expr;\n+  arg_info->no_named_args_stdarg_p = ellipsis && !types;\n   return arg_info;\n }\n \f\n /* Get the struct, enum or union (CODE says which) with tag NAME.\n    Define the tag as a forward-reference with location LOC if it is\n    not defined.  HAVE_STD_ATTRS says whether any standard attributes\n    were present after the struct, union or enum keyword; ATTRS are the\n-   standard attributes present there.  Return a c_typespec structure\n-   for the type specifier.  */\n+   standard attributes present there.  HAS_ENUM_TYPE_SPECIFIER says\n+   whether an enum type specifier (\": specifier-qualifier-list\") is\n+   present; if so, this is called before that specifier is parsed, so\n+   that the tag is in scope for that specifier.  Return a c_typespec\n+   structure for the type specifier.  */\n \n struct c_typespec\n parser_xref_tag (location_t loc, enum tree_code code, tree name,\n-\t\t bool have_std_attrs, tree attrs)\n+\t\t bool have_std_attrs, tree attrs, bool has_enum_type_specifier)\n {\n   struct c_typespec ret;\n   tree ref;\n   location_t refloc;\n \n   ret.expr = NULL_TREE;\n   ret.expr_const_operands = true;\n+  ret.has_enum_type_specifier = has_enum_type_specifier;\n \n-  /* If a cross reference is requested, look up the type\n-     already defined for this tag and return it.  */\n+  /* If a cross reference is requested, look up the type already\n+     defined for this tag and return it.  If an enum type specifier is\n+     present, only a definition in the current scope is relevant.  */\n \n-  ref = lookup_tag (code, name, false, &refloc);\n+  ref = lookup_tag (code, name, has_enum_type_specifier, &refloc);\n   /* If this is the right type of tag, return what we found.\n      (This reference will be shadowed by shadow_tag later if appropriate.)\n      If this is the wrong type of tag, do not return it.  If it was the\n@@ -8257,6 +8423,7 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name,\n       TYPE_PRECISION (ref) = TYPE_PRECISION (unsigned_type_node);\n       TYPE_MIN_VALUE (ref) = TYPE_MIN_VALUE (unsigned_type_node);\n       TYPE_MAX_VALUE (ref) = TYPE_MAX_VALUE (unsigned_type_node);\n+      ENUM_FIXED_UNDERLYING_TYPE_P (ref) = has_enum_type_specifier;\n     }\n \n   pushtag (loc, name, ref);\n@@ -8273,7 +8440,8 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name,\n tree\n xref_tag (enum tree_code code, tree name)\n {\n-  return parser_xref_tag (input_location, code, name, false, NULL_TREE).spec;\n+  return parser_xref_tag (input_location, code, name, false, NULL_TREE,\n+\t\t\t  false).spec;\n }\n \f\n /* Make sure that the tag NAME is defined *in the current scope*\n@@ -8714,6 +8882,81 @@ finish_incomplete_vars (tree incomplete_vars, bool toplevel)\n     }\n }\n \n+\n+/* Determine whether the FIELD_DECL X is a flexible array member according to\n+   the following info:\n+  A. whether the FIELD_DECL X is the last field of the DECL_CONTEXT;\n+  B. whether the FIELD_DECL is an array that is declared as \"[]\", \"[0]\",\n+     or \"[1]\";\n+  C. flag_strict_flex_arrays;\n+  D. the attribute strict_flex_array that is attached to the field\n+     if presenting.\n+  Return TRUE when it's a flexible array member, FALSE otherwise.  */\n+\n+static bool\n+is_flexible_array_member_p (bool is_last_field,\n+\t\t\t    tree x)\n+{\n+  /* If not the last field, return false.  */\n+  if (!is_last_field)\n+    return false;\n+\n+  /* If not an array field, return false.  */\n+  if (TREE_CODE (TREE_TYPE (x)) != ARRAY_TYPE)\n+    return false;\n+\n+  bool is_zero_length_array = zero_length_array_type_p (TREE_TYPE (x));\n+  bool is_one_element_array = one_element_array_type_p (TREE_TYPE (x));\n+  bool is_flexible_array = flexible_array_member_type_p (TREE_TYPE (x));\n+\n+  unsigned int strict_flex_array_level = flag_strict_flex_arrays;\n+\n+  tree attr_strict_flex_array = lookup_attribute (\"strict_flex_array\",\n+\t\t\t\t\t\t  DECL_ATTRIBUTES (x));\n+  /* If there is a strict_flex_array attribute attached to the field,\n+     override the flag_strict_flex_arrays.  */\n+  if (attr_strict_flex_array)\n+    {\n+      /* Get the value of the level first from the attribute.  */\n+      unsigned HOST_WIDE_INT attr_strict_flex_array_level = 0;\n+      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n+      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n+      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n+      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n+      gcc_assert (tree_fits_uhwi_p (attr_strict_flex_array));\n+      attr_strict_flex_array_level = tree_to_uhwi (attr_strict_flex_array);\n+\n+      /* The attribute has higher priority than flag_struct_flex_array.  */\n+      strict_flex_array_level = attr_strict_flex_array_level;\n+    }\n+\n+  switch (strict_flex_array_level)\n+    {\n+      case 0:\n+\t/* Default, all trailing arrays are flexible array members.  */\n+\treturn true;\n+      case 1:\n+\t/* Level 1: all \"[1]\", \"[0]\", and \"[]\" are flexible array members.  */\n+\tif (is_one_element_array)\n+\t  return true;\n+\t/* FALLTHROUGH.  */\n+      case 2:\n+\t/* Level 2: all \"[0]\", and \"[]\" are flexible array members.  */\n+\tif (is_zero_length_array)\n+\t  return true;\n+\t/* FALLTHROUGH.  */\n+      case 3:\n+\t/* Level 3: Only \"[]\" are flexible array members.  */\n+\tif (is_flexible_array)\n+\t  return true;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n+\n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n    LOC is the location of the RECORD_TYPE or UNION_TYPE's definition.\n    FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n@@ -8775,6 +9018,11 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   bool saw_named_field = false;\n   for (x = fieldlist; x; x = DECL_CHAIN (x))\n     {\n+      /* Whether this field is the last field of the structure or union.\n+\t for UNION, any field is the last field of it.  */\n+      bool is_last_field = (DECL_CHAIN (x) == NULL_TREE)\n+\t\t\t    || (TREE_CODE (t) == UNION_TYPE);\n+\n       if (TREE_TYPE (x) == error_mark_node)\n \tcontinue;\n \n@@ -8813,18 +9061,15 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \tDECL_PACKED (x) = 1;\n \n       /* Detect flexible array member in an invalid context.  */\n-      if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n-\t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n-\t  && TYPE_DOMAIN (TREE_TYPE (x)) != NULL_TREE\n-\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (x))) == NULL_TREE)\n+      if (flexible_array_member_type_p (TREE_TYPE (x)))\n \t{\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (x),\n \t\t\t\"flexible array member in union\");\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n-\t  else if (DECL_CHAIN (x) != NULL_TREE)\n+\t  else if (!is_last_field)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (x),\n \t\t\t\"flexible array member not at end of struct\");\n@@ -8844,6 +9089,9 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \tpedwarn (DECL_SOURCE_LOCATION (x), OPT_Wpedantic,\n \t\t \"invalid use of structure with flexible array member\");\n \n+      /* Set DECL_NOT_FLEXARRAY flag for FIELD_DECL x.  */\n+      DECL_NOT_FLEXARRAY (x) = !is_flexible_array_member_p (is_last_field, x);\n+\n       if (DECL_NAME (x)\n \t  || RECORD_OR_UNION_TYPE_P (TREE_TYPE (x)))\n \tsaw_named_field = true;\n@@ -9094,12 +9342,15 @@ layout_array_type (tree t)\n /* Begin compiling the definition of an enumeration type.\n    NAME is its name (or null if anonymous).\n    LOC is the enum's location.\n+   FIXED_UNDERLYING_TYPE is the (C2x) underlying type specified in the\n+   definition.\n    Returns the type object, as yet incomplete.\n    Also records info about it so that build_enumerator\n    may be used to declare the individual values as they are read.  */\n \n tree\n-start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n+start_enum (location_t loc, struct c_enum_contents *the_enum, tree name,\n+\t    tree fixed_underlying_type)\n {\n   tree enumtype = NULL_TREE;\n   location_t enumloc = UNKNOWN_LOCATION;\n@@ -9115,6 +9366,23 @@ start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n     {\n       enumtype = make_node (ENUMERAL_TYPE);\n       pushtag (loc, name, enumtype);\n+      if (fixed_underlying_type != NULL_TREE)\n+\t{\n+\t  /* For an enum definition with a fixed underlying type, the\n+\t     type is complete during the definition and the\n+\t     enumeration constants have that type.  If there was a\n+\t     tag, the type was completed in c_parser_enum_specifier.\n+\t     If not, it must be completed here.  */\n+\t  ENUM_FIXED_UNDERLYING_TYPE_P (enumtype) = true;\n+\t  TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (fixed_underlying_type);\n+\t  TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (fixed_underlying_type);\n+\t  TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (fixed_underlying_type);\n+\t  SET_TYPE_ALIGN (enumtype, TYPE_ALIGN (fixed_underlying_type));\n+\t  TYPE_SIZE (enumtype) = NULL_TREE;\n+\t  TYPE_PRECISION (enumtype) = TYPE_PRECISION (fixed_underlying_type);\n+\t  ENUM_UNDERLYING_TYPE (enumtype) = fixed_underlying_type;\n+\t  layout_type (enumtype);\n+\t}\n     }\n   /* Update type location to the one of the definition, instead of e.g.\n      a forward declaration.  */\n@@ -9142,10 +9410,16 @@ start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n       TYPE_VALUES (enumtype) = NULL_TREE;\n     }\n \n+  if (ENUM_FIXED_UNDERLYING_TYPE_P (enumtype)\n+      && fixed_underlying_type == NULL_TREE)\n+    error_at (loc, \"%<enum%> declared with but defined without \"\n+\t      \"fixed underlying type\");\n+\n   the_enum->enum_next_value = integer_zero_node;\n+  the_enum->enum_type = enumtype;\n   the_enum->enum_overflow = 0;\n \n-  if (flag_short_enums)\n+  if (flag_short_enums && !ENUM_FIXED_UNDERLYING_TYPE_P (enumtype))\n     for (tree v = TYPE_MAIN_VARIANT (enumtype); v; v = TYPE_NEXT_VARIANT (v))\n       TYPE_PACKED (v) = 1;\n \n@@ -9205,43 +9479,65 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   precision = MAX (tree_int_cst_min_precision (minnode, sign),\n \t\t   tree_int_cst_min_precision (maxnode, sign));\n \n-  /* If the precision of the type was specified with an attribute and it\n-     was too small, give an error.  Otherwise, use it.  */\n-  if (TYPE_PRECISION (enumtype) && lookup_attribute (\"mode\", attributes))\n+  bool wider_than_int =\n+    (tree_int_cst_lt (minnode, TYPE_MIN_VALUE (integer_type_node))\n+     || tree_int_cst_lt (TYPE_MAX_VALUE (integer_type_node), maxnode));\n+\n+\n+  if (!ENUM_FIXED_UNDERLYING_TYPE_P (enumtype))\n     {\n-      if (precision > TYPE_PRECISION (enumtype))\n+      /* If the precision of the type was specified with an attribute and it\n+\t was too small, give an error.  Otherwise, use it.  */\n+      if (TYPE_PRECISION (enumtype) && lookup_attribute (\"mode\", attributes))\n \t{\n-\t  TYPE_PRECISION (enumtype) = 0;\n-\t  error (\"specified mode too small for enumerated values\");\n+\t  if (precision > TYPE_PRECISION (enumtype))\n+\t    {\n+\t      TYPE_PRECISION (enumtype) = 0;\n+\t      error (\"specified mode too small for enumerated values\");\n+\t    }\n+\t  else\n+\t    precision = TYPE_PRECISION (enumtype);\n \t}\n       else\n-\tprecision = TYPE_PRECISION (enumtype);\n-    }\n-  else\n-    TYPE_PRECISION (enumtype) = 0;\n+\tTYPE_PRECISION (enumtype) = 0;\n \n-  if (TYPE_PACKED (enumtype)\n-      || precision > TYPE_PRECISION (integer_type_node)\n-      || TYPE_PRECISION (enumtype))\n-    {\n-      tem = c_common_type_for_size (precision, sign == UNSIGNED ? 1 : 0);\n-      if (tem == NULL)\n+      if (TYPE_PACKED (enumtype)\n+\t  || precision > TYPE_PRECISION (integer_type_node)\n+\t  || TYPE_PRECISION (enumtype))\n \t{\n-\t  warning (0, \"enumeration values exceed range of largest integer\");\n-\t  tem = long_long_integer_type_node;\n+\t  tem = c_common_type_for_size (precision, sign == UNSIGNED ? 1 : 0);\n+\t  if (tem == NULL)\n+\t    {\n+\t      /* This should only occur when both signed and unsigned\n+\t\t values of maximum precision occur among the\n+\t\t enumerators.  */\n+\t      pedwarn (input_location, 0,\n+\t\t       \"enumeration values exceed range of largest integer\");\n+\t      tem = widest_integer_literal_type_node;\n+\t    }\n+\t  else if (precision > TYPE_PRECISION (intmax_type_node)\n+\t\t   && !tree_int_cst_lt (minnode,\n+\t\t\t\t\tTYPE_MIN_VALUE (intmax_type_node))\n+\t\t   && !tree_int_cst_lt (TYPE_MAX_VALUE (uintmax_type_node),\n+\t\t\t\t\tmaxnode))\n+\t    pedwarn (input_location, OPT_Wpedantic,\n+\t\t     \"enumeration values exceed range of %qs\",\n+\t\t     sign == UNSIGNED ? \"uintmax_t\" : \"intmax_t\");\n \t}\n-    }\n-  else\n-    tem = sign == UNSIGNED ? unsigned_type_node : integer_type_node;\n+      else\n+\ttem = sign == UNSIGNED ? unsigned_type_node : integer_type_node;\n \n-  TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (tem);\n-  TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (tem);\n-  TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (tem);\n-  SET_TYPE_ALIGN (enumtype, TYPE_ALIGN (tem));\n-  TYPE_SIZE (enumtype) = NULL_TREE;\n-  TYPE_PRECISION (enumtype) = TYPE_PRECISION (tem);\n+      TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (tem);\n+      TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (tem);\n+      TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (tem);\n+      SET_TYPE_ALIGN (enumtype, TYPE_ALIGN (tem));\n+      TYPE_SIZE (enumtype) = NULL_TREE;\n+      TYPE_PRECISION (enumtype) = TYPE_PRECISION (tem);\n+      ENUM_UNDERLYING_TYPE (enumtype) =\n+\tc_common_type_for_size (TYPE_PRECISION (tem), TYPE_UNSIGNED (tem));\n \n-  layout_type (enumtype);\n+      layout_type (enumtype);\n+    }\n \n   if (values != error_mark_node)\n     {\n@@ -9259,17 +9555,19 @@ finish_enum (tree enumtype, tree values, tree attributes)\n \n \t  TREE_TYPE (enu) = enumtype;\n \n-\t  /* The ISO C Standard mandates enumerators to have type int,\n-\t     even though the underlying type of an enum type is\n-\t     unspecified.  However, GCC allows enumerators of any\n-\t     integer type as an extensions.  build_enumerator()\n-\t     converts any enumerators that fit in an int to type int,\n-\t     to avoid promotions to unsigned types when comparing\n-\t     integers with enumerators that fit in the int range.\n-\t     When -pedantic is given, build_enumerator() would have\n-\t     already warned about those that don't fit. Here we\n-\t     convert the rest to the enumerator type. */\n-\t  if (TREE_TYPE (ini) != integer_type_node)\n+\t  /* Before C2X, the ISO C Standard mandates enumerators to\n+\t     have type int, even though the underlying type of an enum\n+\t     type is unspecified.  However, C2X allows enumerators of\n+\t     any integer type, and if an enumeration has any\n+\t     enumerators wider than int, all enumerators have the\n+\t     enumerated type after it is parsed.  Any enumerators that\n+\t     fit in int are given type int in build_enumerator (which\n+\t     is the correct type while the enumeration is being\n+\t     parsed), so no conversions are needed here if all\n+\t     enumerators fit in int.  If the enum has a fixed\n+\t     underlying type, the correct type was also given in\n+\t     build_enumerator.  */\n+\t  if (!ENUM_FIXED_UNDERLYING_TYPE_P (enumtype) && wider_than_int)\n \t    ini = convert (enumtype, ini);\n \n \t  DECL_INITIAL (enu) = ini;\n@@ -9307,6 +9605,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n       TYPE_USER_ALIGN (tem) = TYPE_USER_ALIGN (enumtype);\n       TYPE_UNSIGNED (tem) = TYPE_UNSIGNED (enumtype);\n       TYPE_LANG_SPECIFIC (tem) = TYPE_LANG_SPECIFIC (enumtype);\n+      ENUM_UNDERLYING_TYPE (tem) = ENUM_UNDERLYING_TYPE (enumtype);\n     }\n \n   /* Finish debugging output for this type.  */\n@@ -9337,7 +9636,7 @@ tree\n build_enumerator (location_t decl_loc, location_t loc,\n \t\t  struct c_enum_contents *the_enum, tree name, tree value)\n {\n-  tree decl, type;\n+  tree decl;\n \n   /* Validate and default VALUE.  */\n \n@@ -9386,43 +9685,120 @@ build_enumerator (location_t decl_loc, location_t loc,\n       if (the_enum->enum_overflow)\n \terror_at (loc, \"overflow in enumeration values\");\n     }\n-  /* Even though the underlying type of an enum is unspecified, the\n-     type of enumeration constants is explicitly defined as int\n-     (6.4.4.3/2 in the C99 Standard).  GCC allows any integer type as\n-     an extension.  */\n-  else if (!int_fits_type_p (value, integer_type_node))\n-    pedwarn (loc, OPT_Wpedantic,\n-\t     \"ISO C restricts enumerator values to range of %<int%>\");\n-\n-  /* The ISO C Standard mandates enumerators to have type int, even\n-     though the underlying type of an enum type is unspecified.\n-     However, GCC allows enumerators of any integer type as an\n-     extensions.  Here we convert any enumerators that fit in an int\n-     to type int, to avoid promotions to unsigned types when comparing\n-     integers with enumerators that fit in the int range.  When\n-     -pedantic is given, we would have already warned about those that\n-     don't fit. We have to do this here rather than in finish_enum\n-     because this value may be used to define more enumerators.  */\n-  if (int_fits_type_p (value, integer_type_node))\n-    value = convert (integer_type_node, value);\n+  if (ENUM_FIXED_UNDERLYING_TYPE_P (the_enum->enum_type))\n+    {\n+      /* Enumeration constants must fit in the fixed underlying type.  */\n+      if (!int_fits_type_p (value, ENUM_UNDERLYING_TYPE (the_enum->enum_type)))\n+\terror_at (loc,\n+\t\t  \"enumerator value outside the range of underlying type\");\n+      /* Enumeration constants for an enum with fixed underlying type\n+\t have the enum type, both inside and outside the\n+\t definition.  */\n+      value = convert (the_enum->enum_type, value);\n+    }\n+  else\n+    {\n+      /* Even though the underlying type of an enum is unspecified, the\n+\t type of enumeration constants is explicitly defined as int\n+\t (6.4.4.3/2 in the C99 Standard).  C2X allows any integer type, and\n+\t GCC allows such types for older standards as an extension.  */\n+      bool warned_range = false;\n+      if (!int_fits_type_p (value,\n+\t\t\t    (TYPE_UNSIGNED (TREE_TYPE (value))\n+\t\t\t     ? uintmax_type_node\n+\t\t\t     : intmax_type_node)))\n+\t/* GCC does not consider its types larger than intmax_t to be\n+\t   extended integer types (although C2X would permit such types to\n+\t   be considered extended integer types if all the features\n+\t   required by <stdint.h> and <inttypes.h> macros, such as support\n+\t   for integer constants and I/O, were present), so diagnose if\n+\t   such a wider type is used.  (If the wider type arose from a\n+\t   constant of such a type, that will also have been diagnosed,\n+\t   but this is the only diagnostic in the case where it arises\n+\t   from choosing a wider type automatically when adding 1\n+\t   overflows.)  */\n+\twarned_range = pedwarn (loc, OPT_Wpedantic,\n+\t\t\t\t\"enumerator value outside the range of %qs\",\n+\t\t\t\t(TYPE_UNSIGNED (TREE_TYPE (value))\n+\t\t\t\t ? \"uintmax_t\"\n+\t\t\t\t : \"intmax_t\"));\n+      if (!warned_range && !int_fits_type_p (value, integer_type_node))\n+\tpedwarn_c11 (loc, OPT_Wpedantic,\n+\t\t     \"ISO C restricts enumerator values to range of %<int%> \"\n+\t\t     \"before C2X\");\n+\n+      /* The ISO C Standard mandates enumerators to have type int before\n+\t C2X, even though the underlying type of an enum type is\n+\t unspecified.  C2X allows enumerators of any integer type.  During\n+\t the parsing of the enumeration, C2X specifies that constants\n+\t representable in int have type int, constants not representable\n+\t in int have the type of the given expression if any, and\n+\t constants not representable in int and derived by adding 1 to the\n+\t previous constant have the type of that constant unless the\n+\t addition would overflow or wraparound, in which case a wider type\n+\t of the same signedness is chosen automatically; after the\n+\t enumeration is parsed, all the constants have the type of the\n+\t enumeration if any do not fit in int.  */\n+      if (int_fits_type_p (value, integer_type_node))\n+\tvalue = convert (integer_type_node, value);\n+    }\n \n   /* Set basis for default for next value.  */\n-  the_enum->enum_next_value\n-    = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n-\t\t       PLUS_EXPR, value, integer_one_node, false);\n+  if (ENUM_FIXED_UNDERLYING_TYPE_P (the_enum->enum_type))\n+    {\n+      tree underlying_type = ENUM_UNDERLYING_TYPE (the_enum->enum_type);\n+      if (TREE_CODE (underlying_type) == BOOLEAN_TYPE)\n+\t/* A value of 2 following a value of 1 overflows bool, but we\n+\t   cannot carry out addition directly on bool without\n+\t   promotion, and converting the result of arithmetic in a\n+\t   wider type back to bool would not produce the right result\n+\t   for this overflow check.  */\n+\tthe_enum->enum_next_value = invert_truthvalue_loc (loc, value);\n+      else\n+\tthe_enum->enum_next_value\n+\t  = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n+\t\t\t     PLUS_EXPR, convert (underlying_type, value),\n+\t\t\t     convert (underlying_type, integer_one_node),\n+\t\t\t     false);\n+    }\n+  else\n+    the_enum->enum_next_value\n+      = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n+\t\t\t PLUS_EXPR, value, integer_one_node, false);\n   the_enum->enum_overflow = tree_int_cst_lt (the_enum->enum_next_value, value);\n+  if (the_enum->enum_overflow\n+      && !ENUM_FIXED_UNDERLYING_TYPE_P (the_enum->enum_type))\n+    {\n+      /* Choose a wider type with the same signedness if\n+\t available.  */\n+      int prec = TYPE_PRECISION (TREE_TYPE (value)) + 1;\n+      bool unsignedp = TYPE_UNSIGNED (TREE_TYPE (value));\n+      tree new_type = (unsignedp\n+\t\t       ? long_unsigned_type_node\n+\t\t       : long_integer_type_node);\n+      if (prec > TYPE_PRECISION (new_type))\n+\tnew_type = (unsignedp\n+\t\t    ? long_long_unsigned_type_node\n+\t\t    : long_long_integer_type_node);\n+      if (prec > TYPE_PRECISION (new_type))\n+\tnew_type = (unsignedp\n+\t\t    ? widest_unsigned_literal_type_node\n+\t\t    : widest_integer_literal_type_node);\n+      if (prec <= TYPE_PRECISION (new_type))\n+\t{\n+\t  the_enum->enum_overflow = false;\n+\t  the_enum->enum_next_value\n+\t    = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n+\t\t\t       PLUS_EXPR, convert (new_type, value),\n+\t\t\t       integer_one_node, false);\n+\t  gcc_assert (!tree_int_cst_lt (the_enum->enum_next_value, value));\n+\t}\n+    }\n \n   /* Now create a declaration for the enum value name.  */\n \n-  type = TREE_TYPE (value);\n-  type = c_common_type_for_size (MAX (TYPE_PRECISION (type),\n-\t\t\t\t      TYPE_PRECISION (integer_type_node)),\n-\t\t\t\t (TYPE_PRECISION (type)\n-\t\t\t\t  >= TYPE_PRECISION (integer_type_node)\n-\t\t\t\t  && TYPE_UNSIGNED (type)));\n-\n-  decl = build_decl (decl_loc, CONST_DECL, name, type);\n-  DECL_INITIAL (decl) = convert (type, value);\n+  decl = build_decl (decl_loc, CONST_DECL, name, TREE_TYPE (value));\n+  DECL_INITIAL (decl) = value;\n   pushdecl (decl);\n \n   return tree_cons (decl, value, NULL_TREE);\n@@ -9438,7 +9814,8 @@ c_simulate_enum_decl (location_t loc, const char *name,\n   input_location = loc;\n \n   struct c_enum_contents the_enum;\n-  tree enumtype = start_enum (loc, &the_enum, get_identifier (name));\n+  tree enumtype = start_enum (loc, &the_enum, get_identifier (name),\n+\t\t\t      NULL_TREE);\n \n   tree value_chain = NULL_TREE;\n   string_int_pair *value;\n@@ -9562,7 +9939,8 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n       /* Make it return void instead.  */\n       TREE_TYPE (decl1)\n \t= build_function_type (void_type_node,\n-\t\t\t       TYPE_ARG_TYPES (TREE_TYPE (decl1)));\n+\t\t\t       TYPE_ARG_TYPES (TREE_TYPE (decl1)),\n+\t\t\t       TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (decl1)));\n     }\n \n   if (warn_about_return_type)\n@@ -10161,7 +10539,7 @@ store_parm_decls (void)\n      empty argument list was converted to (void) in grokparms; in\n      older C standard versions, it does not give the function a type\n      with a prototype for future calls.  */\n-  proto = arg_info->types != 0;\n+  proto = arg_info->types != 0 || arg_info->no_named_args_stdarg_p;\n \n   if (proto)\n     store_parm_decls_newstyle (fndecl, arg_info);\n@@ -10289,7 +10667,7 @@ finish_function (location_t end_loc)\n   if (DECL_RESULT (fndecl) && DECL_RESULT (fndecl) != error_mark_node)\n     DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n \n-  if (MAIN_NAME_P (DECL_NAME (fndecl)) && flag_hosted\n+  if (MAIN_NAME_P (DECL_NAME (fndecl)) && !TREE_THIS_VOLATILE (fndecl)\n       && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (fndecl)))\n       == integer_type_node && flag_isoc99)\n     {\n@@ -11727,6 +12105,9 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t    }\n \t}\n       specs->type = type;\n+      if (spec.has_enum_type_specifier\n+\t  && spec.kind != ctsk_tagdef)\n+\tspecs->enum_type_specifier_ref_p = true;\n     }\n \n   return specs;"}, {"sha": "49a5ec3d0482b398106815ce552a853fa80a10ac", "filename": "gcc/c/c-lang.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-lang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-lang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-lang.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -60,9 +60,14 @@ struct GTY(()) language_function {\n   int warn_about_return_type;\n };\n \n+struct GTY(()) c_omp_declare_target_attr {\n+  int device_type;\n+};\n+\n /* If non-zero, implicit \"omp declare target\" attribute is added into the\n    attribute lists.  */\n-extern GTY(()) int current_omp_declare_target_attribute;\n+extern GTY(()) vec<c_omp_declare_target_attr, va_gc>\n+  *current_omp_declare_target_attribute;\n /* Similarly whether we are in between #pragma omp begin assumes and\n    #pragma omp end assumes (and how many times when nested).  */\n extern GTY(()) int current_omp_begin_assumes;"}, {"sha": "1a8b162821885f32ec7d6960e677311219447fa5", "filename": "gcc/c/c-objc-common.cc", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-objc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-objc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -37,9 +37,12 @@ static bool c_tree_printer (pretty_printer *, text_info *, const char *,\n bool\n c_missing_noreturn_ok_p (tree decl)\n {\n-  /* A missing noreturn is not ok for freestanding implementations and\n-     ok for the `main' function in hosted implementations.  */\n-  return flag_hosted && MAIN_NAME_P (DECL_ASSEMBLER_NAME (decl));\n+  /* A missing noreturn is ok for the `main' function.  */\n+  if (!MAIN_NAME_P (DECL_ASSEMBLER_NAME (decl)))\n+    return false;\n+\n+  return flag_hosted\n+    || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl))) == integer_type_node;\n }\n \n /* Called from check_global_declaration.  */\n@@ -384,13 +387,7 @@ c_get_alias_set (tree t)\n   /* Allow aliasing between enumeral types and the underlying\n      integer type.  This is required since those are compatible types.  */\n   if (TREE_CODE (t) == ENUMERAL_TYPE)\n-    {\n-      tree t1 = c_common_type_for_size (tree_to_uhwi (TYPE_SIZE (t)),\n-\t\t\t\t\t/* short-cut commoning to signed\n-\t\t\t\t\t   type.  */\n-\t\t\t\t\tfalse);\n-      return get_alias_set (t1);\n-    }\n+    return get_alias_set (ENUM_UNDERLYING_TYPE (t));\n \n   return c_common_get_alias_set (t);\n }"}, {"sha": "ca533c9c6673d7e0603feb238a16a4df7053792a", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 450, "deletions": 108, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -127,6 +127,8 @@ c_parse_init (void)\n       mask |= D_ASM | D_EXT;\n       if (!flag_isoc99)\n \tmask |= D_EXT89;\n+      if (!flag_isoc2x)\n+\tmask |= D_EXT11;\n     }\n   if (!c_dialect_objc ())\n     mask |= D_OBJC | D_CXX_OBJC;\n@@ -580,6 +582,7 @@ c_keyword_starts_typename (enum rid keyword)\n     case RID_STRUCT:\n     case RID_UNION:\n     case RID_TYPEOF:\n+    case RID_TYPEOF_UNQUAL:\n     case RID_CONST:\n     case RID_ATOMIC:\n     case RID_VOLATILE:\n@@ -663,6 +666,30 @@ c_parser_next_tokens_start_typename (c_parser *parser, enum c_lookahead_kind la)\n   return false;\n }\n \n+/* Return true if TOKEN, after an open parenthesis, can start a\n+   compound literal (either a storage class specifier allowed in that\n+   context, or a type name), false otherwise.  */\n+static bool\n+c_token_starts_compound_literal (c_token *token)\n+{\n+  switch (token->type)\n+    {\n+    case CPP_KEYWORD:\n+      switch (token->keyword)\n+\t{\n+\tcase RID_REGISTER:\n+\tcase RID_STATIC:\n+\tcase RID_THREAD:\n+\t  return true;\n+\tdefault:\n+\t  break;\n+\t}\n+      /* Fall through.  */\n+    default:\n+      return c_token_starts_typename (token);\n+    }\n+}\n+\n /* Return true if TOKEN is a type qualifier, false otherwise.  */\n static bool\n c_token_is_qualifier (c_token *token)\n@@ -757,6 +784,7 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_STRUCT:\n \tcase RID_UNION:\n \tcase RID_TYPEOF:\n+\tcase RID_TYPEOF_UNQUAL:\n \tcase RID_CONST:\n \tcase RID_VOLATILE:\n \tcase RID_RESTRICT:\n@@ -1559,6 +1587,7 @@ static struct c_expr c_parser_sizeof_expression (c_parser *);\n static struct c_expr c_parser_alignof_expression (c_parser *);\n static struct c_expr c_parser_postfix_expression (c_parser *);\n static struct c_expr c_parser_postfix_expression_after_paren_type (c_parser *,\n+\t\t\t\t\t\t\t\t   struct c_declspecs *,\n \t\t\t\t\t\t\t\t   struct c_type_name *,\n \t\t\t\t\t\t\t\t   location_t);\n static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n@@ -1675,18 +1704,22 @@ c_parser_translation_unit (c_parser *parser)\n     if (DECL_SIZE (decl) == NULL_TREE && TREE_TYPE (decl) != error_mark_node)\n       error (\"storage size of %q+D isn%'t known\", decl);\n \n-  if (current_omp_declare_target_attribute)\n+  if (vec_safe_length (current_omp_declare_target_attribute))\n     {\n+      c_omp_declare_target_attr\n+\ta = current_omp_declare_target_attribute->pop ();\n       if (!errorcount)\n-        error (\"%<#pragma omp declare target%> without corresponding \"\n-\t       \"%<#pragma omp end declare target%>\");\n-      current_omp_declare_target_attribute = 0;\n+\terror (\"%qs without corresponding %qs\",\n+\t       a.device_type >= 0 ? \"#pragma omp begin declare target\"\n+\t\t\t\t  : \"#pragma omp declare target\",\n+\t       \"#pragma omp end declare target\");\n+      vec_safe_truncate (current_omp_declare_target_attribute, 0);\n     }\n   if (current_omp_begin_assumes)\n     {\n       if (!errorcount)\n-\terror (\"%<#pragma omp begin assumes%> without corresponding \"\n-\t       \"%<#pragma omp end assumes%>\");\n+\terror (\"%qs without corresponding %qs\",\n+\t       \"#pragma omp begin assumes\", \"#pragma omp end assumes\");\n       current_omp_begin_assumes = 0;\n     }\n }\n@@ -1819,6 +1852,46 @@ add_debug_begin_stmt (location_t loc)\n   add_stmt (stmt);\n }\n \n+/* Helper function for c_parser_declaration_or_fndef and\n+   Handle assume attribute(s).  */\n+\n+static tree\n+handle_assume_attribute (location_t here, tree attrs, bool nested)\n+{\n+  if (nested)\n+    for (tree attr = lookup_attribute (\"gnu\", \"assume\", attrs); attr;\n+\t attr = lookup_attribute (\"gnu\", \"assume\", TREE_CHAIN (attr)))\n+      {\n+\ttree args = TREE_VALUE (attr);\n+\tint nargs = list_length (args);\n+\tif (nargs != 1)\n+\t  {\n+\t    error_at (here, \"wrong number of arguments specified \"\n+\t\t\t    \"for %qE attribute\",\n+\t\t      get_attribute_name (attr));\n+\t    inform (here, \"expected %i, found %i\", 1, nargs);\n+\t  }\n+\telse\n+\t  {\n+\t    tree arg = TREE_VALUE (args);\n+\t    arg = c_objc_common_truthvalue_conversion (here, arg);\n+\t    arg = c_fully_fold (arg, false, NULL);\n+\t    if (arg != error_mark_node)\n+\t      {\n+\t\ttree fn = build_call_expr_internal_loc (here, IFN_ASSUME,\n+\t\t\t\t\t\t\tvoid_type_node, 1,\n+\t\t\t\t\t\t\targ);\n+\t\tadd_stmt (fn);\n+\t      }\n+\t  }\n+      }\n+  else\n+    pedwarn (here, OPT_Wattributes,\n+\t     \"%<assume%> attribute at top level\");\n+\n+  return remove_attribute (\"gnu\", \"assume\", attrs);\n+}\n+\n /* Parse a declaration or function definition (C90 6.5, 6.7.1, C99\n    6.7, 6.9.1, C11 6.7, 6.9.1).  If FNDEF_OK is true, a function definition\n    is accepted; otherwise (old-style parameter declarations) only other\n@@ -2033,6 +2106,14 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n   bool auto_type_p = specs->typespec_word == cts_auto_type;\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n+      bool handled_assume = false;\n+      if (specs->typespec_kind == ctsk_none\n+\t  && lookup_attribute (\"gnu\", \"assume\", specs->attrs))\n+\t{\n+\t  handled_assume = true;\n+\t  specs->attrs\n+\t    = handle_assume_attribute (here, specs->attrs, nested);\n+\t}\n       if (auto_type_p)\n \terror_at (here, \"%<__auto_type%> in empty declaration\");\n       else if (specs->typespec_kind == ctsk_none\n@@ -2050,13 +2131,15 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    pedwarn (here, OPT_Wattributes,\n \t\t     \"%<fallthrough%> attribute at top level\");\n \t}\n-      else if (empty_ok && !(have_attrs\n-\t\t\t     && specs->non_std_attrs_seen_p))\n+      else if (empty_ok\n+\t       && !(have_attrs && specs->non_std_attrs_seen_p)\n+\t       && !handled_assume)\n \tshadow_tag (specs);\n       else\n \t{\n \t  shadow_tag_warned (specs, 1);\n-\t  pedwarn (here, 0, \"empty declaration\");\n+\t  if (!handled_assume)\n+\t    pedwarn (here, 0, \"empty declaration\");\n \t}\n       c_parser_consume_token (parser);\n       if (oacc_routine_data)\n@@ -2156,6 +2239,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n   else if (attribute_fallthrough_p (specs->attrs))\n     warning_at (here, OPT_Wattributes,\n \t\t\"%<fallthrough%> attribute not followed by %<;%>\");\n+  else if (lookup_attribute (\"gnu\", \"assume\", specs->attrs))\n+    warning_at (here, OPT_Wattributes,\n+\t\t\"%<assume%> attribute not followed by %<;%>\");\n \n   pending_xref_error ();\n   prefix_attrs = specs->attrs;\n@@ -2925,6 +3011,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t    }\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n+\t  t.has_enum_type_specifier = false;\n \t  declspecs_add_type (name_token->location, specs, t);\n \t  continue;\n \t}\n@@ -2941,6 +3028,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  t.spec = objc_get_protocol_qualified_type (NULL_TREE, proto);\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n+\t  t.has_enum_type_specifier = false;\n \t  declspecs_add_type (loc, specs, t);\n \t  continue;\n \t}\n@@ -3001,6 +3089,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  t.spec = c_parser_peek_token (parser)->value;\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n+\t  t.has_enum_type_specifier = false;\n \t  declspecs_add_type (loc, specs, t);\n \t  c_parser_consume_token (parser);\n \t  break;\n@@ -3024,6 +3113,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  declspecs_add_type (loc, specs, t);\n \t  break;\n \tcase RID_TYPEOF:\n+\tcase RID_TYPEOF_UNQUAL:\n \t  /* ??? The old parser rejected typeof after other type\n \t     specifiers, but is a syntax error the best way of\n \t     handling this?  */\n@@ -3064,6 +3154,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t      t.spec = error_mark_node;\n \t      t.expr = NULL_TREE;\n \t      t.expr_const_operands = true;\n+\t      t.has_enum_type_specifier = false;\n \t      if (type != NULL)\n \t\tt.spec = groktypename (type, &t.expr,\n \t\t\t\t       &t.expr_const_operands);\n@@ -3131,17 +3222,20 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n /* Parse an enum specifier (C90 6.5.2.2, C99 6.7.2.2, C11 6.7.2.2).\n \n    enum-specifier:\n-     enum gnu-attributes[opt] identifier[opt] { enumerator-list }\n-       gnu-attributes[opt]\n-     enum gnu-attributes[opt] identifier[opt] { enumerator-list , }\n-       gnu-attributes[opt]\n+     enum gnu-attributes[opt] identifier[opt] enum-type-specifier[opt]\n+       { enumerator-list } gnu-attributes[opt]\n+     enum gnu-attributes[opt] identifier[opt] enum-type-specifier[opt]\n+       { enumerator-list , } gnu-attributes[opt] enum-type-specifier[opt]\n      enum gnu-attributes[opt] identifier\n \n-   The form with trailing comma is new in C99.  The forms with\n-   gnu-attributes are GNU extensions.  In GNU C, we accept any expression\n-   without commas in the syntax (assignment expressions, not just\n-   conditional expressions); assignment expressions will be diagnosed\n-   as non-constant.\n+   The form with trailing comma is new in C99; enum-type-specifiers\n+   are new in C2x.  The forms with gnu-attributes are GNU extensions.\n+   In GNU C, we accept any expression without commas in the syntax\n+   (assignment expressions, not just conditional expressions);\n+   assignment expressions will be diagnosed as non-constant.\n+\n+   enum-type-specifier:\n+     : specifier-qualifier-list\n \n    enumerator-list:\n      enumerator\n@@ -3169,6 +3263,7 @@ c_parser_enum_specifier (c_parser *parser)\n   tree std_attrs = NULL_TREE;\n   tree attrs;\n   tree ident = NULL_TREE;\n+  tree fixed_underlying_type = NULL_TREE;\n   location_t enum_loc;\n   location_t ident_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ENUM));\n@@ -3187,6 +3282,83 @@ c_parser_enum_specifier (c_parser *parser)\n       enum_loc = ident_loc;\n       c_parser_consume_token (parser);\n     }\n+  if (c_parser_next_token_is (parser, CPP_COLON)\n+      /* Distinguish an enum-type-specifier from a bit-field\n+\t declaration of the form \"enum e : constant-expression;\".  */\n+      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+    {\n+      pedwarn_c11 (enum_loc, OPT_Wpedantic,\n+\t\t   \"ISO C does not support specifying %<enum%> underlying \"\n+\t\t   \"types before C2X\");\n+      if (ident)\n+\t{\n+\t  /* The tag is in scope during the enum-type-specifier (which\n+\t     may refer to the tag inside typeof).  */\n+\t  ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident,\n+\t\t\t\t have_std_attrs, std_attrs, true);\n+\t  if (!ENUM_FIXED_UNDERLYING_TYPE_P (ret.spec))\n+\t    error_at (enum_loc, \"%<enum%> declared both with and without \"\n+\t\t      \"fixed underlying type\");\n+\t}\n+      else\n+\t{\n+\t  /* There must be an enum definition, so this initialization\n+\t     (to avoid possible warnings about uninitialized data)\n+\t     will be replaced later (either with the results of that\n+\t     definition, or with the results of error handling for the\n+\t     case of no tag and no definition).  */\n+\t  ret.spec = NULL_TREE;\n+\t  ret.kind = ctsk_tagdef;\n+\t  ret.expr = NULL_TREE;\n+\t  ret.expr_const_operands = true;\n+\t  ret.has_enum_type_specifier = true;\n+\t}\n+      c_parser_consume_token (parser);\n+      struct c_declspecs *specs = build_null_declspecs ();\n+      c_parser_declspecs (parser, specs, false, true, false, false, false,\n+\t\t\t  false, true, cla_prefer_id);\n+      finish_declspecs (specs);\n+      if (specs->default_int_p)\n+\terror_at (enum_loc, \"no %<enum%> underlying type specified\");\n+      else if (TREE_CODE (specs->type) != INTEGER_TYPE\n+\t       && TREE_CODE (specs->type) != BOOLEAN_TYPE)\n+\t{\n+\t  error_at (enum_loc, \"invalid %<enum%> underlying type\");\n+\t  specs->type = integer_type_node;\n+\t}\n+      else if (specs->restrict_p)\n+\terror_at (enum_loc, \"invalid use of %<restrict%>\");\n+      fixed_underlying_type = TYPE_MAIN_VARIANT (specs->type);\n+      if (ident)\n+\t{\n+\t  /* The type specified must be consistent with any previously\n+\t     specified underlying type.  If this is a newly declared\n+\t     type, it is now a complete type.  */\n+\t  if (ENUM_FIXED_UNDERLYING_TYPE_P (ret.spec)\n+\t      && ENUM_UNDERLYING_TYPE (ret.spec) == NULL_TREE)\n+\t    {\n+\t      TYPE_MIN_VALUE (ret.spec) =\n+\t\tTYPE_MIN_VALUE (fixed_underlying_type);\n+\t      TYPE_MAX_VALUE (ret.spec) =\n+\t\tTYPE_MAX_VALUE (fixed_underlying_type);\n+\t      TYPE_UNSIGNED (ret.spec) = TYPE_UNSIGNED (fixed_underlying_type);\n+\t      SET_TYPE_ALIGN (ret.spec, TYPE_ALIGN (fixed_underlying_type));\n+\t      TYPE_SIZE (ret.spec) = NULL_TREE;\n+\t      TYPE_PRECISION (ret.spec) =\n+\t\tTYPE_PRECISION (fixed_underlying_type);\n+\t      ENUM_UNDERLYING_TYPE (ret.spec) = fixed_underlying_type;\n+\t      layout_type (ret.spec);\n+\t    }\n+\t  else if (ENUM_FIXED_UNDERLYING_TYPE_P (ret.spec)\n+\t\t   && !comptypes (fixed_underlying_type,\n+\t\t\t\t  ENUM_UNDERLYING_TYPE (ret.spec)))\n+\t    {\n+\t      error_at (enum_loc, \"%<enum%> underlying type incompatible with \"\n+\t\t\t\"previous declaration\");\n+\t      fixed_underlying_type = ENUM_UNDERLYING_TYPE (ret.spec);\n+\t    }\n+\t}\n+    }\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     {\n       /* Parse an enum definition.  */\n@@ -3197,7 +3369,7 @@ c_parser_enum_specifier (c_parser *parser)\n \t forward order at the end.  */\n       tree values;\n       timevar_push (TV_PARSE_ENUM);\n-      type = start_enum (enum_loc, &the_enum, ident);\n+      type = start_enum (enum_loc, &the_enum, ident, fixed_underlying_type);\n       values = NULL_TREE;\n       c_parser_consume_token (parser);\n       while (true)\n@@ -3281,6 +3453,7 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      ret.has_enum_type_specifier = fixed_underlying_type != NULL_TREE;\n       timevar_pop (TV_PARSE_ENUM);\n       return ret;\n     }\n@@ -3291,6 +3464,7 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.kind = ctsk_tagref;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      ret.has_enum_type_specifier = false;\n       return ret;\n     }\n   /* Attributes may only appear when the members are defined or in\n@@ -3299,15 +3473,18 @@ c_parser_enum_specifier (c_parser *parser)\n      standard C).  */\n   if (have_std_attrs && c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n     c_parser_error (parser, \"expected %<;%>\");\n-  ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident, have_std_attrs,\n-\t\t\t std_attrs);\n-  /* In ISO C, enumerated types can be referred to only if already\n-     defined.  */\n-  if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n+  if (fixed_underlying_type == NULL_TREE)\n     {\n-      gcc_assert (ident);\n-      pedwarn (enum_loc, OPT_Wpedantic,\n-\t       \"ISO C forbids forward references to %<enum%> types\");\n+      ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident, have_std_attrs,\n+\t\t\t     std_attrs, false);\n+      /* In ISO C, enumerated types without a fixed underlying type\n+\t can be referred to only if already defined.  */\n+      if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n+\t{\n+\t  gcc_assert (ident);\n+\t  pedwarn (enum_loc, OPT_Wpedantic,\n+\t\t   \"ISO C forbids forward references to %<enum%> types\");\n+\t}\n     }\n   return ret;\n }\n@@ -3503,6 +3680,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      ret.has_enum_type_specifier = false;\n       timevar_pop (TV_PARSE_STRUCT);\n       return ret;\n     }\n@@ -3513,6 +3691,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.kind = ctsk_tagref;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      ret.has_enum_type_specifier = false;\n       return ret;\n     }\n   /* Attributes may only appear when the members are defined or in\n@@ -3521,7 +3700,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n     c_parser_error (parser, \"expected %<;%>\");\n   /* ??? Existing practice is that GNU attributes are ignored after\n      the struct or union keyword when not defining the members.  */\n-  ret = parser_xref_tag (ident_loc, code, ident, have_std_attrs, std_attrs);\n+  ret = parser_xref_tag (ident_loc, code, ident, have_std_attrs, std_attrs,\n+\t\t\t false);\n   return ret;\n }\n \n@@ -3711,22 +3891,39 @@ c_parser_struct_declaration (c_parser *parser)\n   return decls;\n }\n \n-/* Parse a typeof specifier (a GNU extension).\n+/* Parse a typeof specifier (a GNU extension adopted in C2X).\n \n    typeof-specifier:\n      typeof ( expression )\n      typeof ( type-name )\n+     typeof_unqual ( expression )\n+     typeof_unqual ( type-name )\n */\n \n static struct c_typespec\n c_parser_typeof_specifier (c_parser *parser)\n {\n+  bool is_unqual;\n+  bool is_std;\n   struct c_typespec ret;\n   ret.kind = ctsk_typeof;\n   ret.spec = error_mark_node;\n   ret.expr = NULL_TREE;\n   ret.expr_const_operands = true;\n-  gcc_assert (c_parser_next_token_is_keyword (parser, RID_TYPEOF));\n+  ret.has_enum_type_specifier = false;\n+  if (c_parser_next_token_is_keyword (parser, RID_TYPEOF))\n+    {\n+      is_unqual = false;\n+      tree spelling = c_parser_peek_token (parser)->value;\n+      is_std = (flag_isoc2x\n+\t\t&& strcmp (IDENTIFIER_POINTER (spelling), \"typeof\") == 0);\n+    }\n+  else\n+    {\n+      gcc_assert (c_parser_next_token_is_keyword (parser, RID_TYPEOF_UNQUAL));\n+      is_unqual = true;\n+      is_std = true;\n+    }\n   c_parser_consume_token (parser);\n   c_inhibit_evaluation_warnings++;\n   in_typeof++;\n@@ -3768,6 +3965,24 @@ c_parser_typeof_specifier (c_parser *parser)\n       pop_maybe_used (was_vm);\n     }\n   parens.skip_until_found_close (parser);\n+  if (ret.spec != error_mark_node)\n+    {\n+      if (is_unqual && TYPE_QUALS (ret.spec) != TYPE_UNQUALIFIED)\n+\tret.spec = TYPE_MAIN_VARIANT (ret.spec);\n+      if (is_std)\n+\t{\n+\t  /* In ISO C terms, _Noreturn is not part of the type of\n+\t     expressions such as &abort, but in GCC it is represented\n+\t     internally as a type qualifier.  */\n+\t  if (TREE_CODE (ret.spec) == FUNCTION_TYPE\n+\t      && TYPE_QUALS (ret.spec) != TYPE_UNQUALIFIED)\n+\t    ret.spec = TYPE_MAIN_VARIANT (ret.spec);\n+\t  else if (FUNCTION_POINTER_TYPE_P (ret.spec)\n+\t\t   && TYPE_QUALS (TREE_TYPE (ret.spec)) != TYPE_UNQUALIFIED)\n+\t    ret.spec\n+\t      = build_pointer_type (TYPE_MAIN_VARIANT (TREE_TYPE (ret.spec)));\n+\t}\n+    }\n   return ret;\n }\n \n@@ -3998,7 +4213,8 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n       if (kind != C_DTR_NORMAL\n \t  && (c_parser_next_token_starts_declspecs (parser)\n \t      || (!have_gnu_attrs\n-\t\t  && c_parser_nth_token_starts_std_attributes (parser, 1))\n+\t\t  && (c_parser_nth_token_starts_std_attributes (parser, 1)\n+\t\t      || c_parser_next_token_is (parser, CPP_ELLIPSIS)))\n \t      || c_parser_next_token_is (parser, CPP_CLOSE_PAREN)))\n \t{\n \t  struct c_arg_info *args\n@@ -4274,25 +4490,18 @@ c_parser_parms_list_declarator (c_parser *parser, tree attrs, tree expr,\n       c_parser_consume_token (parser);\n       return ret;\n     }\n-  if (c_parser_next_token_is (parser, CPP_ELLIPSIS))\n+  if (c_parser_next_token_is (parser, CPP_ELLIPSIS) && !have_gnu_attrs)\n     {\n       struct c_arg_info *ret = build_arg_info ();\n \n-      if (flag_allow_parameterless_variadic_functions)\n-        {\n-          /* F (...) is allowed.  */\n-          ret->types = NULL_TREE;\n-        }\n-      else\n-        {\n-          /* Suppress -Wold-style-definition for this case.  */\n-          ret->types = error_mark_node;\n-          error_at (c_parser_peek_token (parser)->location,\n-                    \"ISO C requires a named argument before %<...%>\");\n-        }\n+      ret->types = NULL_TREE;\n+      pedwarn_c11 (c_parser_peek_token (parser)->location, OPT_Wpedantic,\n+\t\t   \"ISO C requires a named argument before %<...%> \"\n+\t\t   \"before C2X\");\n       c_parser_consume_token (parser);\n       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t{\n+\t  ret->no_named_args_stdarg_p = true;\n \t  c_parser_consume_token (parser);\n \t  return ret;\n \t}\n@@ -4594,7 +4803,8 @@ c_parser_gnu_attribute_any_word (c_parser *parser)\n \n static tree\n c_parser_attribute_arguments (c_parser *parser, bool takes_identifier,\n-\t\t\t      bool require_string, bool allow_empty_args)\n+\t\t\t      bool require_string, bool assume_attr,\n+\t\t\t      bool allow_empty_args)\n {\n   vec<tree, va_gc> *expr_list;\n   tree attr_args;\n@@ -4613,6 +4823,7 @@ c_parser_attribute_arguments (c_parser *parser, bool takes_identifier,\n \t      == CPP_CLOSE_PAREN))\n       && (takes_identifier\n \t  || (c_dialect_objc ()\n+\t      && !assume_attr\n \t      && c_parser_peek_token (parser)->id_kind\n \t      == C_ID_CLASSNAME)))\n     {\n@@ -4649,6 +4860,23 @@ c_parser_attribute_arguments (c_parser *parser, bool takes_identifier,\n \t  tree string = c_parser_string_literal (parser, false, true).value;\n \t  attr_args = build_tree_list (NULL_TREE, string);\n \t}\n+      else if (assume_attr)\n+\t{\n+\t  tree cond\n+\t    = c_parser_conditional_expression (parser, NULL, NULL_TREE).value;\n+\t  if (!c_parser_next_token_is (parser, CPP_COMMA))\n+\t    attr_args = build_tree_list (NULL_TREE, cond);\n+\t  else\n+\t    {\n+\t      tree tree_list;\n+\t      c_parser_consume_token (parser);\n+\t      expr_list = c_parser_expr_list (parser, false, true,\n+\t\t\t\t\t      NULL, NULL, NULL, NULL);\n+\t      tree_list = build_tree_list_vec (expr_list);\n+\t      attr_args = tree_cons (NULL_TREE, cond, tree_list);\n+\t      release_tree_vector (expr_list);\n+\t    }\n+\t}\n       else\n \t{\n \t  expr_list = c_parser_expr_list (parser, false, true,\n@@ -4732,7 +4960,9 @@ c_parser_gnu_attribute (c_parser *parser, tree attrs,\n   tree attr_args\n     = c_parser_attribute_arguments (parser,\n \t\t\t\t    attribute_takes_identifier_p (attr_name),\n-\t\t\t\t    false, true);\n+\t\t\t\t    false,\n+\t\t\t\t    is_attribute_p (\"assume\", attr_name),\n+\t\t\t\t    true);\n \n   attr = build_tree_list (attr_name, attr_args);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -4978,9 +5208,13 @@ c_parser_std_attribute (c_parser *parser, bool for_tm)\n \t  = (ns == NULL_TREE\n \t     && (strcmp (IDENTIFIER_POINTER (name), \"deprecated\") == 0\n \t\t || strcmp (IDENTIFIER_POINTER (name), \"nodiscard\") == 0));\n+\tbool assume_attr\n+\t  = (ns != NULL_TREE\n+\t     && strcmp (IDENTIFIER_POINTER (ns), \"gnu\") == 0\n+\t     && strcmp (IDENTIFIER_POINTER (name), \"assume\") == 0);\n \tTREE_VALUE (attribute)\n \t  = c_parser_attribute_arguments (parser, takes_identifier,\n-\t\t\t\t\t  require_string, false);\n+\t\t\t\t\t  require_string, assume_attr, false);\n       }\n     else\n       c_parser_balanced_token_sequence (parser);\n@@ -6260,8 +6494,21 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t  break;\n \tcase RID_ATTRIBUTE:\n \t  {\n-\t    /* Allow '__attribute__((fallthrough));'.  */\n+\t    /* Allow '__attribute__((fallthrough));' or\n+\t       '__attribute__((assume(cond)));'.  */\n \t    tree attrs = c_parser_gnu_attributes (parser);\n+\t    bool has_assume = lookup_attribute (\"assume\", attrs);\n+\t    if (has_assume)\n+\t      {\n+\t\tif (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\t\t  attrs = handle_assume_attribute (loc, attrs, true);\n+\t\telse\n+\t\t  {\n+\t\t    warning_at (loc, OPT_Wattributes,\n+\t\t\t\t\"%<assume%> attribute not followed by %<;%>\");\n+\t\t    has_assume = false;\n+\t\t  }\n+\t      }\n \t    if (attribute_fallthrough_p (attrs))\n \t      {\n \t\tif (c_parser_next_token_is (parser, CPP_SEMICOLON))\n@@ -6278,9 +6525,13 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t\t\t      \"%<fallthrough%> attribute not followed \"\n \t\t\t      \"by %<;%>\");\n \t      }\n+\t    else if (has_assume)\n+\t      /* Eat the ';'.  */\n+\t      c_parser_consume_token (parser);\n \t    else if (attrs != NULL_TREE)\n-\t      warning_at (loc, OPT_Wattributes, \"only attribute %<fallthrough%>\"\n-\t\t\t  \" can be applied to a null statement\");\n+\t      warning_at (loc, OPT_Wattributes,\n+\t\t\t  \"only attribute %<fallthrough%> or %<assume%> can \"\n+\t\t\t  \"be applied to a null statement\");\n \t    break;\n \t  }\n \tdefault:\n@@ -8099,6 +8350,34 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n #undef POP\n }\n \n+/* Parse any storage class specifiers after an open parenthesis in a\n+   context where a compound literal is permitted.  */\n+\n+static struct c_declspecs *\n+c_parser_compound_literal_scspecs (c_parser *parser)\n+{\n+  bool seen_scspec = false;\n+  struct c_declspecs *specs = build_null_declspecs ();\n+  while (c_parser_next_token_is (parser, CPP_KEYWORD))\n+    {\n+      switch (c_parser_peek_token (parser)->keyword)\n+\t{\n+\tcase RID_REGISTER:\n+\tcase RID_STATIC:\n+\tcase RID_THREAD:\n+\t  seen_scspec = true;\n+\t  declspecs_add_scspec (c_parser_peek_token (parser)->location,\n+\t\t\t\tspecs, c_parser_peek_token (parser)->value);\n+\t  c_parser_consume_token (parser);\n+\t  break;\n+\tdefault:\n+\t  goto out;\n+\t}\n+    }\n+ out:\n+  return seen_scspec ? specs : NULL;\n+}\n+\n /* Parse a cast expression (C90 6.3.4, C99 6.5.4, C11 6.5.4).  If AFTER\n    is not NULL then it is an Objective-C message expression which is the\n    primary-expression starting the expression as an initializer.\n@@ -8122,13 +8401,15 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n      an unary expression.  Full detection of unknown typenames here\n      would require a 3-token lookahead.  */\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n-      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+      && c_token_starts_compound_literal (c_parser_peek_2nd_token (parser)))\n     {\n+      struct c_declspecs *scspecs;\n       struct c_type_name *type_name;\n       struct c_expr ret;\n       struct c_expr expr;\n       matching_parens parens;\n       parens.consume_open (parser);\n+      scspecs = c_parser_compound_literal_scspecs (parser);\n       type_name = c_parser_type_name (parser, true);\n       parens.skip_until_found_close (parser);\n       if (type_name == NULL)\n@@ -8143,8 +8424,11 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       used_types_insert (type_name->specs->type);\n \n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n-\treturn c_parser_postfix_expression_after_paren_type (parser, type_name,\n+\treturn c_parser_postfix_expression_after_paren_type (parser, scspecs,\n+\t\t\t\t\t\t\t     type_name,\n \t\t\t\t\t\t\t     cast_loc);\n+      if (scspecs)\n+\terror_at (cast_loc, \"storage class specifier in cast\");\n       if (type_name->specs->alignas_p)\n \terror_at (type_name->specs->locations[cdw_alignas],\n \t\t  \"alignment specified for type name in cast\");\n@@ -8347,14 +8631,16 @@ c_parser_sizeof_expression (c_parser *parser)\n   c_inhibit_evaluation_warnings++;\n   in_sizeof++;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n-      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+      && c_token_starts_compound_literal (c_parser_peek_2nd_token (parser)))\n     {\n       /* Either sizeof ( type-name ) or sizeof unary-expression\n \t starting with a compound literal.  */\n+      struct c_declspecs *scspecs;\n       struct c_type_name *type_name;\n       matching_parens parens;\n       parens.consume_open (parser);\n       expr_loc = c_parser_peek_token (parser)->location;\n+      scspecs = c_parser_compound_literal_scspecs (parser);\n       type_name = c_parser_type_name (parser, true);\n       parens.skip_until_found_close (parser);\n       finish = parser->tokens_buf[0].location;\n@@ -8370,13 +8656,15 @@ c_parser_sizeof_expression (c_parser *parser)\n \t}\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \t{\n-\t  expr = c_parser_postfix_expression_after_paren_type (parser,\n+\t  expr = c_parser_postfix_expression_after_paren_type (parser, scspecs,\n \t\t\t\t\t\t\t       type_name,\n \t\t\t\t\t\t\t       expr_loc);\n \t  finish = expr.get_finish ();\n \t  goto sizeof_expr;\n \t}\n       /* sizeof ( type-name ).  */\n+      if (scspecs)\n+\terror_at (expr_loc, \"storage class specifier in %<sizeof%>\");\n       if (type_name->specs->alignas_p)\n \terror_at (type_name->specs->locations[cdw_alignas],\n \t\t  \"alignment specified for type name in %<sizeof%>\");\n@@ -8434,16 +8722,18 @@ c_parser_alignof_expression (c_parser *parser)\n   c_inhibit_evaluation_warnings++;\n   in_alignof++;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n-      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+      && c_token_starts_compound_literal (c_parser_peek_2nd_token (parser)))\n     {\n       /* Either __alignof__ ( type-name ) or __alignof__\n \t unary-expression starting with a compound literal.  */\n       location_t loc;\n+      struct c_declspecs *scspecs;\n       struct c_type_name *type_name;\n       struct c_expr ret;\n       matching_parens parens;\n       parens.consume_open (parser);\n       loc = c_parser_peek_token (parser)->location;\n+      scspecs = c_parser_compound_literal_scspecs (parser);\n       type_name = c_parser_type_name (parser, true);\n       end_loc = c_parser_peek_token (parser)->location;\n       parens.skip_until_found_close (parser);\n@@ -8459,12 +8749,14 @@ c_parser_alignof_expression (c_parser *parser)\n \t}\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \t{\n-\t  expr = c_parser_postfix_expression_after_paren_type (parser,\n+\t  expr = c_parser_postfix_expression_after_paren_type (parser, scspecs,\n \t\t\t\t\t\t\t       type_name,\n \t\t\t\t\t\t\t       loc);\n \t  goto alignof_expr;\n \t}\n       /* alignof ( type-name ).  */\n+      if (scspecs)\n+\terror_at (loc, \"storage class specifier in %qE\", alignof_spelling);\n       if (type_name->specs->alignas_p)\n \terror_at (type_name->specs->locations[cdw_alignas],\n \t\t  \"alignment specified for type name in %qE\",\n@@ -9002,8 +9294,8 @@ c_parser_predefined_identifier (c_parser *parser)\n      postfix-expression -> identifier\n      postfix-expression ++\n      postfix-expression --\n-     ( type-name ) { initializer-list }\n-     ( type-name ) { initializer-list , }\n+     ( storage-class-specifiers[opt] type-name ) { initializer-list[opt] }\n+     ( storage-class-specifiers[opt] type-name ) { initializer-list , }\n \n    argument-expression-list:\n      argument-expression\n@@ -10345,6 +10637,7 @@ c_parser_postfix_expression (c_parser *parser)\n \n static struct c_expr\n c_parser_postfix_expression_after_paren_type (c_parser *parser,\n+\t\t\t\t\t      struct c_declspecs *scspecs,\n \t\t\t\t\t      struct c_type_name *type_name,\n \t\t\t\t\t      location_t type_loc)\n {\n@@ -10377,7 +10670,11 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n       type = error_mark_node;\n     }\n \n-  pedwarn_c90 (start_loc, OPT_Wpedantic, \"ISO C90 forbids compound literals\");\n+  if (!pedwarn_c90 (start_loc, OPT_Wpedantic,\n+\t\t    \"ISO C90 forbids compound literals\") && scspecs)\n+    pedwarn_c11 (start_loc, OPT_Wpedantic,\n+\t\t \"ISO C forbids storage class specifiers in compound literals \"\n+\t\t \"before C2X\");\n   non_const = ((init.value && TREE_CODE (init.value) == CONSTRUCTOR)\n \t       ? CONSTRUCTOR_NON_CONST (init.value)\n \t       : init.original_code == C_MAYBE_CONST_EXPR);\n@@ -10396,7 +10693,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n \t}\n     }\n   expr.value = build_compound_literal (start_loc, type, init.value, non_const,\n-\t\t\t\t       alignas_align);\n+\t\t\t\t       alignas_align, scspecs);\n   set_c_expr_source_range (&expr, init.src_range);\n   expr.m_decimal = 0;\n   expr.original_code = ERROR_MARK;\n@@ -11862,7 +12159,7 @@ c_parser_objc_synchronized_statement (c_parser *parser)\n      identifier\n      one of\n        enum struct union if else while do for switch case default\n-       break continue return goto asm sizeof typeof __alignof\n+       break continue return goto asm sizeof typeof typeof_unqual __alignof\n        unsigned long const short volatile signed restrict _Complex\n        in out inout bycopy byref oneway int char float double void _Bool\n        _Atomic\n@@ -11902,6 +12199,7 @@ c_parser_objc_selector (c_parser *parser)\n     case RID_ASM:\n     case RID_SIZEOF:\n     case RID_TYPEOF:\n+    case RID_TYPEOF_UNQUAL:\n     case RID_ALIGNOF:\n     case RID_UNSIGNED:\n     case RID_LONG:\n@@ -16818,8 +17116,8 @@ c_parser_omp_clause_device_type (c_parser *parser, tree list)\n   else\n     goto invalid_kind;\n \n-  /* check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE_TYPE,\n-\t\t\t\t\"device_type\");  */\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE_TYPE,\n+\t\t\t     \"device_type\");\n   c_parser_consume_token (parser);\n   parens.skip_until_found_close (parser);\n   c = build_omp_clause (clause_loc, OMP_CLAUSE_DEVICE_TYPE);\n@@ -17156,7 +17454,7 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n       if (nested && c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \tbreak;\n \n-      if (!first)\n+      if (!first || nested != 2)\n \t{\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    c_parser_consume_token (parser);\n@@ -18243,6 +18541,9 @@ c_parser_omp_allocate (location_t loc, c_parser *parser)\n {\n   tree allocator = NULL_TREE;\n   tree nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n+  if (c_parser_next_token_is (parser, CPP_COMMA)\n+      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+    c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       matching_parens parens;\n@@ -18381,7 +18682,6 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n   bool structured_block = false;\n   bool swapped = false;\n   bool non_lvalue_p;\n-  bool first = true;\n   tree clauses = NULL_TREE;\n   bool capture = false;\n   bool compare = false;\n@@ -18392,13 +18692,10 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n-\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n \t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n \tc_parser_consume_token (parser);\n \n-      first = false;\n-\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  const char *p\n@@ -18943,15 +19240,14 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t  && TREE_CODE (TREE_OPERAND (lhs, 1)) == COMPOUND_EXPR\n \t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (lhs, 1), 0)) == MODIFY_EXPR\n \t  && TREE_OPERAND (TREE_OPERAND (lhs, 1), 1) == TREE_OPERAND (lhs, 0)\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (TREE_OPERAND\n-\t\t\t\t\t      (TREE_OPERAND (lhs, 1), 0), 0)))\n-\t     == BOOLEAN_TYPE)\n+\t  && C_BOOLEAN_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND\n+\t\t\t\t\t      (TREE_OPERAND (lhs, 1), 0), 0))))\n \t/* Undo effects of boolean_increment for post {in,de}crement.  */\n \tlhs = TREE_OPERAND (TREE_OPERAND (lhs, 1), 0);\n       /* FALLTHRU */\n     case MODIFY_EXPR:\n       if (TREE_CODE (lhs) == MODIFY_EXPR\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (lhs, 0))) == BOOLEAN_TYPE)\n+\t  && C_BOOLEAN_TYPE_P (TREE_TYPE (TREE_OPERAND (lhs, 0))))\n \t{\n \t  /* Undo effects of boolean_increment.  */\n \t  if (integer_onep (TREE_OPERAND (lhs, 1)))\n@@ -19343,6 +19639,8 @@ c_parser_omp_depobj (c_parser *parser)\n   parens.skip_until_found_close (parser);\n   tree clause = NULL_TREE;\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INVALID;\n+  if (c_parser_next_token_is (parser, CPP_COMMA))\n+    c_parser_consume_token (parser);\n   location_t c_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -19419,6 +19717,9 @@ c_parser_omp_flush (c_parser *parser)\n   location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n   enum memmodel mo = MEMMODEL_LAST;\n+  if (c_parser_next_token_is (parser, CPP_COMMA)\n+      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+    c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *p\n@@ -19511,6 +19812,9 @@ c_parser_omp_scan_loop_body (c_parser *parser, bool open_brace_parsed)\n \n       c_parser_consume_pragma (parser);\n \n+      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  const char *p\n@@ -20294,9 +20598,14 @@ c_parser_omp_ordered (c_parser *parser, enum pragma_context context,\n       return false;\n     }\n \n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  int n = 1;\n+  if (c_parser_next_token_is (parser, CPP_COMMA))\n+    n = 2;\n+\n+  if (c_parser_peek_nth_token (parser, n)->type == CPP_NAME)\n     {\n-      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      const char *p\n+\t= IDENTIFIER_POINTER (c_parser_peek_nth_token (parser, n)->value);\n \n       if (!strcmp (\"depend\", p) || !strcmp (\"doacross\", p))\n \t{\n@@ -22169,6 +22478,10 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n \n   parens.require_close (parser);\n \n+  if (c_parser_next_token_is (parser, CPP_COMMA)\n+      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+    c_parser_consume_token (parser);\n+\n   const char *clause = \"\";\n   location_t match_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -22338,7 +22651,9 @@ c_parser_omp_declare_target (c_parser *parser)\n   tree clauses = NULL_TREE;\n   int device_type = 0;\n   bool only_device_type = true;\n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  if (c_parser_next_token_is (parser, CPP_NAME)\n+      || (c_parser_next_token_is (parser, CPP_COMMA)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME))\n     clauses = c_parser_omp_all_clauses (parser, OMP_DECLARE_TARGET_CLAUSE_MASK,\n \t\t\t\t\t\"#pragma omp declare target\");\n   else if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n@@ -22351,7 +22666,8 @@ c_parser_omp_declare_target (c_parser *parser)\n   else\n     {\n       c_parser_skip_to_pragma_eol (parser);\n-      current_omp_declare_target_attribute++;\n+      c_omp_declare_target_attr attr = { -1 };\n+      vec_safe_push (current_omp_declare_target_attribute, attr);\n       return;\n     }\n   for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n@@ -22429,12 +22745,17 @@ c_parser_omp_declare_target (c_parser *parser)\n \t}\n     }\n   if (device_type && only_device_type)\n-    warning_at (OMP_CLAUSE_LOCATION (clauses), 0,\n-\t\t\"directive with only %<device_type%> clauses ignored\");\n+    error_at (OMP_CLAUSE_LOCATION (clauses),\n+\t      \"directive with only %<device_type%> clause\");\n }\n \n /* OpenMP 5.1\n-   #pragma omp begin assumes clauses[optseq] new-line  */\n+   #pragma omp begin assumes clauses[optseq] new-line\n+\n+   #pragma omp begin declare target clauses[optseq] new-line  */\n+\n+#define OMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE_TYPE)\n \n static void\n c_parser_omp_begin (c_parser *parser)\n@@ -22443,15 +22764,41 @@ c_parser_omp_begin (c_parser *parser)\n   c_parser_consume_pragma (parser);\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-  if (strcmp (p, \"assumes\") == 0)\n+  if (strcmp (p, \"declare\") == 0)\n+    {\n+      c_parser_consume_token (parser);\n+      p = \"\";\n+      if (c_parser_next_token_is (parser, CPP_NAME))\n+\tp = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (p, \"target\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  tree clauses\n+\t    = c_parser_omp_all_clauses (parser,\n+\t\t\t\t\tOMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma omp begin declare target\");\n+\t  int device_type = 0;\n+\t  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEVICE_TYPE)\n+\t      device_type |= OMP_CLAUSE_DEVICE_TYPE_KIND (c);\n+\t  c_omp_declare_target_attr attr = { device_type };\n+\t  vec_safe_push (current_omp_declare_target_attribute, attr);\n+\t}\n+      else\n+\t{\n+\t  c_parser_error (parser, \"expected %<target%>\");\n+\t  c_parser_skip_to_pragma_eol (parser);\n+\t}\n+    }\n+  else if (strcmp (p, \"assumes\") == 0)\n     {\n       c_parser_consume_token (parser);\n       c_parser_omp_assumption_clauses (parser, false);\n       current_omp_begin_assumes++;\n     }\n   else\n     {\n-      c_parser_error (parser, \"expected %<assumes%>\");\n+      c_parser_error (parser, \"expected %<declare target%> or %<assumes%>\");\n       c_parser_skip_to_pragma_eol (parser);\n     }\n }\n@@ -22484,19 +22831,20 @@ c_parser_omp_end (c_parser *parser)\n \t  return;\n \t}\n       c_parser_skip_to_pragma_eol (parser);\n-      if (!current_omp_declare_target_attribute)\n+      if (!vec_safe_length (current_omp_declare_target_attribute))\n \terror_at (loc, \"%<#pragma omp end declare target%> without \"\n-\t\t       \"corresponding %<#pragma omp declare target%>\");\n+\t\t       \"corresponding %<#pragma omp declare target%> or \"\n+\t\t       \"%<#pragma omp begin declare target%>\");\n       else\n-\tcurrent_omp_declare_target_attribute--;\n+\tcurrent_omp_declare_target_attribute->pop ();\n     }\n   else if (strcmp (p, \"assumes\") == 0)\n     {\n       c_parser_consume_token (parser);\n       c_parser_skip_to_pragma_eol (parser);\n       if (!current_omp_begin_assumes)\n-\terror_at (loc, \"%<#pragma omp end assumes%> without \"\n-\t\t       \"corresponding %<#pragma omp begin assumes%>\");\n+\terror_at (loc, \"%qs without corresponding %qs\",\n+\t\t  \"#pragma omp end assumes\", \"#pragma omp begin assumes\");\n       else\n \tcurrent_omp_begin_assumes--;\n     }\n@@ -22726,10 +23074,14 @@ c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)\n       initializer.set_error ();\n       if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n \tbad = true;\n-      else if (c_parser_next_token_is (parser, CPP_NAME)\n-\t       && strcmp (IDENTIFIER_POINTER\n+      else if (c_parser_next_token_is (parser, CPP_COMMA)\n+\t       && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\tc_parser_consume_token (parser);\n+      if (!bad\n+\t  && (c_parser_next_token_is (parser, CPP_NAME)\n+\t      && strcmp (IDENTIFIER_POINTER\n \t\t\t\t(c_parser_peek_token (parser)->value),\n-\t\t\t  \"initializer\") == 0)\n+\t\t\t  \"initializer\") == 0))\n \t{\n \t  c_parser_consume_token (parser);\n \t  pop_scope ();\n@@ -22922,21 +23274,17 @@ c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n static void\n c_parser_omp_requires (c_parser *parser)\n {\n-  bool first = true;\n   enum omp_requires new_req = (enum omp_requires) 0;\n \n   c_parser_consume_pragma (parser);\n \n   location_t loc = c_parser_peek_token (parser)->location;\n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n-\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n \t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n \tc_parser_consume_token (parser);\n \n-      first = false;\n-\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  const char *p\n@@ -23207,21 +23555,17 @@ c_parser_omp_error (c_parser *parser, enum pragma_context context)\n   int at_compilation = -1;\n   int severity_fatal = -1;\n   tree message = NULL_TREE;\n-  bool first = true;\n   bool bad = false;\n   location_t loc = c_parser_peek_token (parser)->location;\n \n   c_parser_consume_pragma (parser);\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n-\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n \t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n \tc_parser_consume_token (parser);\n \n-      first = false;\n-\n       if (!c_parser_next_token_is (parser, CPP_NAME))\n \tbreak;\n \n@@ -23377,7 +23721,6 @@ c_parser_omp_error (c_parser *parser, enum pragma_context context)\n static void\n c_parser_omp_assumption_clauses (c_parser *parser, bool is_assume)\n {\n-  bool first = true;\n   bool no_openmp = false;\n   bool no_openmp_routines = false;\n   bool no_parallelism = false;\n@@ -23393,13 +23736,10 @@ c_parser_omp_assumption_clauses (c_parser *parser, bool is_assume)\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n-\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n \t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n \tc_parser_consume_token (parser);\n \n-      first = false;\n-\n       if (!c_parser_next_token_is (parser, CPP_NAME))\n \tbreak;\n \n@@ -23439,10 +23779,12 @@ c_parser_omp_assumption_clauses (c_parser *parser, bool is_assume)\n \t      tree t = convert_lvalue_to_rvalue (eloc, expr, true, true).value;\n \t      t = c_objc_common_truthvalue_conversion (eloc, t);\n \t      t = c_fully_fold (t, false, NULL);\n-\t      if (is_assume)\n+\t      if (is_assume && t != error_mark_node)\n \t\t{\n-\t\t  /* FIXME: Emit .ASSUME (t) call here.  */\n-\t\t  (void) t;\n+\t\t  tree fn = build_call_expr_internal_loc (eloc, IFN_ASSUME,\n+\t\t\t\t\t\t\t  void_type_node, 1,\n+\t\t\t\t\t\t\t  t);\n+\t\t  add_stmt (fn);\n \t\t}\n \t      parens.skip_until_found_close (parser);\n \t    }"}, {"sha": "facfc125371985bcf54e5e248ade272ea29fec3c", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -122,6 +122,14 @@ along with GCC; see the file COPYING3.  If not see\n    been folded.  */\n #define SAVE_EXPR_FOLDED_P(EXP)\tTREE_LANG_FLAG_1 (SAVE_EXPR_CHECK (EXP))\n \n+/* Whether a type has boolean semantics: either a boolean type or an\n+   enumeration type with a boolean type as its underlying type.  */\n+#define C_BOOLEAN_TYPE_P(TYPE)\t\t\t\t\t\t\\\n+  (TREE_CODE (TYPE) == BOOLEAN_TYPE\t\t\t\t\t\\\n+   || (TREE_CODE (TYPE) == ENUMERAL_TYPE\t\t\t\t\\\n+       && ENUM_UNDERLYING_TYPE (TYPE) != NULL_TREE\t\t\t\\\n+       && TREE_CODE (ENUM_UNDERLYING_TYPE (TYPE)) == BOOLEAN_TYPE))\n+\n /* Record parser information about an expression that is irrelevant\n    for code generation alongside a tree representing its value.  */\n struct c_expr\n@@ -216,6 +224,10 @@ struct c_typespec {\n   /* Whether the expression has operands suitable for use in constant\n      expressions.  */\n   bool expr_const_operands;\n+  /* Whether the type specifier includes an enum type specifier (that\n+     is, \": specifier-qualifier-list\" in a declaration using\n+     \"enum\").  */\n+  bool has_enum_type_specifier;\n   /* The specifier itself.  */\n   tree spec;\n   /* An expression to be evaluated before the type specifier, in the\n@@ -412,6 +424,12 @@ struct c_declspecs {\n   /* Whether any alignment specifier (even with zero alignment) was\n      specified.  */\n   BOOL_BITFIELD alignas_p : 1;\n+  /* Whether an enum type specifier (\": specifier-qualifier-list\") was\n+     specified other than in a definition of that enum (if so, this is\n+     invalid unless it is an empty declaration \"enum identifier\n+     enum-type-specifier;\", but such an empty declaration is valid in\n+     C2x when \"enum identifier;\" would not be).  */\n+  BOOL_BITFIELD enum_type_specifier_ref_p : 1;\n   /* The address space that the declaration belongs to.  */\n   addr_space_t address_space;\n };\n@@ -457,6 +475,8 @@ struct c_arg_info {\n   tree pending_sizes;\n   /* True when these arguments had [*].  */\n   BOOL_BITFIELD had_vla_unspec : 1;\n+  /* True when the arguments are a (...) prototype.  */\n+  BOOL_BITFIELD no_named_args_stdarg_p : 1;\n };\n \n /* A declarator.  */\n@@ -525,6 +545,9 @@ struct c_enum_contents\n      constant value.  */\n   tree enum_next_value;\n \n+  /* The enumeration type itself.  */\n+  tree enum_type;\n+\n   /* Nonzero means that there was overflow computing enum_next_value.  */\n   int enum_overflow;\n };\n@@ -625,7 +648,7 @@ extern void c_warn_unused_attributes (tree);\n extern tree c_warn_type_attributes (tree);\n extern void shadow_tag (const struct c_declspecs *);\n extern void shadow_tag_warned (const struct c_declspecs *, int);\n-extern tree start_enum (location_t, struct c_enum_contents *, tree);\n+extern tree start_enum (location_t, struct c_enum_contents *, tree, tree);\n extern bool start_function (struct c_declspecs *, struct c_declarator *, tree);\n extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,\n \t\t\ttree, location_t * = NULL);\n@@ -637,7 +660,7 @@ extern void temp_store_parm_decls (tree, tree);\n extern void temp_pop_parm_decls (void);\n extern tree xref_tag (enum tree_code, tree);\n extern struct c_typespec parser_xref_tag (location_t, enum tree_code, tree,\n-\t\t\t\t\t  bool, tree);\n+\t\t\t\t\t  bool, tree, bool);\n extern struct c_parm *build_c_parm (struct c_declspecs *, tree,\n \t\t\t\t    struct c_declarator *, location_t);\n extern struct c_declarator *build_attrs_declarator (tree,\n@@ -734,7 +757,7 @@ extern void set_init_label (location_t, tree, location_t, struct obstack *);\n extern void process_init_element (location_t, struct c_expr, bool,\n \t\t\t\t  struct obstack *);\n extern tree build_compound_literal (location_t, tree, tree, bool,\n-\t\t\t\t    unsigned int);\n+\t\t\t\t    unsigned int, struct c_declspecs *);\n extern void check_compound_literal_type (location_t, struct c_type_name *);\n extern tree c_start_switch (location_t, location_t, tree, bool);\n extern void c_finish_switch (tree, tree);"}, {"sha": "052ae6db0009e150e383e026d27fcc5c263dfe4c", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -420,9 +420,11 @@ composite_type (tree t1, tree t2)\n      (DR#013 question 3).  For consistency, use the enumerated type as\n      the composite type.  */\n \n-  if (code1 == ENUMERAL_TYPE && code2 == INTEGER_TYPE)\n+  if (code1 == ENUMERAL_TYPE\n+      && (code2 == INTEGER_TYPE || code2 == BOOLEAN_TYPE))\n     return t1;\n-  if (code2 == ENUMERAL_TYPE && code1 == INTEGER_TYPE)\n+  if (code2 == ENUMERAL_TYPE\n+      && (code1 == INTEGER_TYPE || code1 == BOOLEAN_TYPE))\n     return t2;\n \n   gcc_assert (code1 == code2);\n@@ -542,17 +544,19 @@ composite_type (tree t1, tree t2)\n \n \t/* Simple way if one arg fails to specify argument types.  */\n \tif (TYPE_ARG_TYPES (t1) == NULL_TREE)\n-\t {\n-\t    t1 = build_function_type (valtype, TYPE_ARG_TYPES (t2));\n+\t  {\n+\t    t1 = build_function_type (valtype, TYPE_ARG_TYPES (t2),\n+\t\t\t\t      TYPE_NO_NAMED_ARGS_STDARG_P (t2));\n \t    t1 = build_type_attribute_variant (t1, attributes);\n \t    return qualify_type (t1, t2);\n \t }\n \tif (TYPE_ARG_TYPES (t2) == NULL_TREE)\n-\t {\n-\t   t1 = build_function_type (valtype, TYPE_ARG_TYPES (t1));\n-\t   t1 = build_type_attribute_variant (t1, attributes);\n-\t   return qualify_type (t1, t2);\n-\t }\n+\t  {\n+\t    t1 = build_function_type (valtype, TYPE_ARG_TYPES (t1),\n+\t\t\t\t      TYPE_NO_NAMED_ARGS_STDARG_P (t1));\n+\t    t1 = build_type_attribute_variant (t1, attributes);\n+\t    return qualify_type (t1, t2);\n+\t  }\n \n \t/* If both args specify argument types, we must merge the two\n \t   lists, argument by argument.  */\n@@ -1025,9 +1029,9 @@ tree\n common_type (tree t1, tree t2)\n {\n   if (TREE_CODE (t1) == ENUMERAL_TYPE)\n-    t1 = c_common_type_for_size (TYPE_PRECISION (t1), 1);\n+    t1 = ENUM_UNDERLYING_TYPE (t1);\n   if (TREE_CODE (t2) == ENUMERAL_TYPE)\n-    t2 = c_common_type_for_size (TYPE_PRECISION (t2), 1);\n+    t2 = ENUM_UNDERLYING_TYPE (t2);\n \n   /* If both types are BOOLEAN_TYPE, then return boolean_type_node.  */\n   if (TREE_CODE (t1) == BOOLEAN_TYPE\n@@ -1125,7 +1129,7 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n       && COMPLETE_TYPE_P (t1)\n       && TREE_CODE (t2) != ENUMERAL_TYPE)\n     {\n-      t1 = c_common_type_for_size (TYPE_PRECISION (t1), TYPE_UNSIGNED (t1));\n+      t1 = ENUM_UNDERLYING_TYPE (t1);\n       if (TREE_CODE (t2) != VOID_TYPE)\n \t{\n \t  if (enum_and_int_p != NULL)\n@@ -1138,7 +1142,7 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n \t   && COMPLETE_TYPE_P (t2)\n \t   && TREE_CODE (t1) != ENUMERAL_TYPE)\n     {\n-      t2 = c_common_type_for_size (TYPE_PRECISION (t2), TYPE_UNSIGNED (t2));\n+      t2 = ENUM_UNDERLYING_TYPE (t2);\n       if (TREE_CODE (t1) != VOID_TYPE)\n \t{\n \t  if (enum_and_int_p != NULL)\n@@ -1700,6 +1704,8 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n \n   if (args1 == NULL_TREE)\n     {\n+      if (TYPE_NO_NAMED_ARGS_STDARG_P (f1) != TYPE_NO_NAMED_ARGS_STDARG_P (f2))\n+\treturn 0;\n       if (!self_promoting_args_p (args2))\n \treturn 0;\n       /* If one of these types comes from a non-prototype fn definition,\n@@ -1713,6 +1719,8 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n     }\n   if (args2 == NULL_TREE)\n     {\n+      if (TYPE_NO_NAMED_ARGS_STDARG_P (f1) != TYPE_NO_NAMED_ARGS_STDARG_P (f2))\n+\treturn 0;\n       if (!self_promoting_args_p (args1))\n \treturn 0;\n       if (TYPE_ACTUAL_ARG_TYPES (f2)\n@@ -2193,15 +2201,19 @@ perform_integral_promotions (tree exp)\n \n   gcc_assert (INTEGRAL_TYPE_P (type));\n \n-  /* Normally convert enums to int,\n-     but convert wide enums to something wider.  */\n+  /* Convert enums to the result of applying the integer promotions to\n+     their underlying type.  */\n   if (code == ENUMERAL_TYPE)\n     {\n-      type = c_common_type_for_size (MAX (TYPE_PRECISION (type),\n-\t\t\t\t\t  TYPE_PRECISION (integer_type_node)),\n-\t\t\t\t     ((TYPE_PRECISION (type)\n-\t\t\t\t       >= TYPE_PRECISION (integer_type_node))\n-\t\t\t\t      && TYPE_UNSIGNED (type)));\n+      type = ENUM_UNDERLYING_TYPE (type);\n+      if (c_promoting_integer_type_p (type))\n+\t{\n+\t  if (TYPE_UNSIGNED (type)\n+\t      && TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n+\t    type = unsigned_type_node;\n+\t  else\n+\t    type = integer_type_node;\n+\t}\n \n       return convert (type, exp);\n     }\n@@ -3187,6 +3199,7 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n \n   /* fntype now gets the type of function pointed to.  */\n   fntype = TREE_TYPE (fntype);\n+  tree return_type = TREE_TYPE (fntype);\n \n   /* Convert the parameters to the types declared in the\n      function prototype, or apply default promotions.  */\n@@ -3203,8 +3216,6 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n       && TREE_CODE (tem = TREE_OPERAND (tem, 0)) == FUNCTION_DECL\n       && !comptypes (fntype, TREE_TYPE (tem)))\n     {\n-      tree return_type = TREE_TYPE (fntype);\n-\n       /* This situation leads to run-time undefined behavior.  We can't,\n \t therefore, simply error unless we can prove that all possible\n \t executions of the program must execute the code.  */\n@@ -3229,22 +3240,25 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n   bool warned_p = check_function_arguments (loc, fundecl, fntype,\n \t\t\t\t\t    nargs, argarray, &arg_loc);\n \n+  if (TYPE_QUALS (return_type) != TYPE_UNQUALIFIED\n+      && !VOID_TYPE_P (return_type))\n+    return_type = c_build_qualified_type (return_type, TYPE_UNQUALIFIED);\n   if (name != NULL_TREE\n       && startswith (IDENTIFIER_POINTER (name), \"__builtin_\"))\n     {\n       if (require_constant_value)\n \tresult\n-\t  = fold_build_call_array_initializer_loc (loc, TREE_TYPE (fntype),\n+\t  = fold_build_call_array_initializer_loc (loc, return_type,\n \t\t\t\t\t\t   function, nargs, argarray);\n       else\n-\tresult = fold_build_call_array_loc (loc, TREE_TYPE (fntype),\n+\tresult = fold_build_call_array_loc (loc, return_type,\n \t\t\t\t\t    function, nargs, argarray);\n       if (TREE_CODE (result) == NOP_EXPR\n \t  && TREE_CODE (TREE_OPERAND (result, 0)) == INTEGER_CST)\n \tSTRIP_TYPE_NOPS (result);\n     }\n   else\n-    result = build_call_array_loc (loc, TREE_TYPE (fntype),\n+    result = build_call_array_loc (loc, return_type,\n \t\t\t\t   function, nargs, argarray);\n   /* If -Wnonnull warning has been diagnosed, avoid diagnosing it again\n      later.  */\n@@ -3676,6 +3690,9 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t\tpromote_float_arg = false;\n \t\tbreak;\n \t      }\n+\t  /* Don't promote __bf16 either.  */\n+\t  if (TYPE_MAIN_VARIANT (valtype) == bfloat16_type_node)\n+\t    promote_float_arg = false;\n \t}\n \n       if (type != NULL_TREE)\n@@ -3927,7 +3944,7 @@ parser_build_binary_op (location_t location, enum tree_code code,\n \t    }\n \t  while (1);\n \t}\n-      if (TREE_CODE (TREE_TYPE (t)) != BOOLEAN_TYPE)\n+      if (!C_BOOLEAN_TYPE_P (TREE_TYPE (t)))\n \twarn_logical_not_parentheses (location, code, arg1.value, arg2.value);\n     }\n \n@@ -4532,7 +4549,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t  while (TREE_CODE (e) == COMPOUND_EXPR)\n \t    e = TREE_OPERAND (e, 1);\n \n-\t  if ((TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE\n+\t  if ((C_BOOLEAN_TYPE_P (TREE_TYPE (arg))\n \t       || truth_value_p (TREE_CODE (e))))\n \t    {\n \t      auto_diagnostic_group d;\n@@ -4664,7 +4681,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t\t\t\"decrement of enumeration value is invalid in C++\");\n \t}\n \n-      if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n+      if (C_BOOLEAN_TYPE_P (TREE_TYPE (arg)))\n \t{\n \t  if (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n \t    warning_at (location, OPT_Wbool_operation,\n@@ -4826,11 +4843,14 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t    goto return_build_unary_op;\n \t  }\n \n-\tif (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n+\tif (C_BOOLEAN_TYPE_P (TREE_TYPE (arg)))\n \t  val = boolean_increment (code, arg);\n \telse\n \t  val = build2 (code, TREE_TYPE (arg), arg, inc);\n \tTREE_SIDE_EFFECTS (val) = 1;\n+\tif (TYPE_QUALS (TREE_TYPE (val)) != TYPE_UNQUALIFIED)\n+\t  TREE_TYPE (val) = c_build_qualified_type (TREE_TYPE (val),\n+\t\t\t\t\t\t    TYPE_UNQUALIFIED);\n \tret = val;\n \tgoto return_build_unary_op;\n       }\n@@ -5109,6 +5129,11 @@ c_mark_addressable (tree exp, bool array_ref_p)\n \tbreak;\n \n       case COMPOUND_LITERAL_EXPR:\n+\tif (C_DECL_REGISTER (COMPOUND_LITERAL_EXPR_DECL (x)))\n+\t  {\n+\t    error (\"address of register compound literal requested\");\n+\t    return false;\n+\t  }\n \tTREE_ADDRESSABLE (x) = 1;\n \tTREE_ADDRESSABLE (COMPOUND_LITERAL_EXPR_DECL (x)) = 1;\n \treturn true;\n@@ -7074,7 +7099,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t\t\t\t rhstype);\n \n       bool save = in_late_binary_op;\n-      if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE\n+      if (C_BOOLEAN_TYPE_P (type) || codel == COMPLEX_TYPE\n \t  || (coder == REAL_TYPE\n \t      && (codel == INTEGER_TYPE || codel == ENUMERAL_TYPE)\n \t      && sanitize_flags_p (SANITIZE_FLOAT_CAST)))\n@@ -7721,7 +7746,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \n       return convert (type, rhs);\n     }\n-  else if (codel == BOOLEAN_TYPE\n+  else if (C_BOOLEAN_TYPE_P (type)\n \t   /* The type nullptr_t may be converted to bool.  The\n \t      result is false.  */\n \t   && (coder == POINTER_TYPE || coder == NULLPTR_TYPE))\n@@ -10989,7 +11014,7 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n \treturn NULL_TREE;\n \n       save = in_late_binary_op;\n-      if (TREE_CODE (TREE_TYPE (res)) == BOOLEAN_TYPE\n+      if (C_BOOLEAN_TYPE_P (TREE_TYPE (res))\n \t  || TREE_CODE (TREE_TYPE (res)) == COMPLEX_TYPE\n \t  || (TREE_CODE (TREE_TYPE (t)) == REAL_TYPE\n \t      && (TREE_CODE (TREE_TYPE (res)) == INTEGER_TYPE\n@@ -11151,7 +11176,7 @@ c_start_switch (location_t switch_loc,\n \t  while (TREE_CODE (e) == COMPOUND_EXPR)\n \t    e = TREE_OPERAND (e, 1);\n \n-\t  if ((TREE_CODE (type) == BOOLEAN_TYPE\n+\t  if ((C_BOOLEAN_TYPE_P (type)\n \t       || truth_value_p (TREE_CODE (e)))\n \t      /* Explicit cast to int suppresses this warning.  */\n \t      && !(TREE_CODE (type) == INTEGER_TYPE\n@@ -11982,8 +12007,8 @@ build_binary_op (location_t location, enum tree_code code,\n   if ((gnu_vector_type_p (type0) && code1 != VECTOR_TYPE)\n       || (gnu_vector_type_p (type1) && code0 != VECTOR_TYPE))\n     {\n-      enum stv_conv convert_flag = scalar_to_vector (location, code, op0, op1,\n-\t\t\t\t\t\t     true);\n+      enum stv_conv convert_flag = scalar_to_vector (location, code, orig_op0,\n+\t\t\t\t\t\t     orig_op1, true);\n \n       switch (convert_flag)\n \t{\n@@ -12480,9 +12505,9 @@ build_binary_op (location_t location, enum tree_code code,\n       else if (code1 == NULLPTR_TYPE && null_pointer_constant_p (orig_op0))\n \tresult_type = (INTEGRAL_TYPE_P (type0)\n \t\t       ? build_pointer_type (type0) : type0);\n-      if ((TREE_CODE (TREE_TYPE (orig_op0)) == BOOLEAN_TYPE\n+      if ((C_BOOLEAN_TYPE_P (TREE_TYPE (orig_op0))\n \t   || truth_value_p (TREE_CODE (orig_op0)))\n-\t  ^ (TREE_CODE (TREE_TYPE (orig_op1)) == BOOLEAN_TYPE\n+\t  ^ (C_BOOLEAN_TYPE_P (TREE_TYPE (orig_op1))\n \t     || truth_value_p (TREE_CODE (orig_op1))))\n \tmaybe_warn_bool_compare (location, code, orig_op0, orig_op1);\n       break;\n@@ -12625,9 +12650,9 @@ build_binary_op (location_t location, enum tree_code code,\n \t  instrument_expr = build_call_expr_loc (location, tt, 2, op0, op1);\n \t}\n \n-      if ((TREE_CODE (TREE_TYPE (orig_op0)) == BOOLEAN_TYPE\n+      if ((C_BOOLEAN_TYPE_P (TREE_TYPE (orig_op0))\n \t   || truth_value_p (TREE_CODE (orig_op0)))\n-\t  ^ (TREE_CODE (TREE_TYPE (orig_op1)) == BOOLEAN_TYPE\n+\t  ^ (C_BOOLEAN_TYPE_P (TREE_TYPE (orig_op1))\n \t     || truth_value_p (TREE_CODE (orig_op1))))\n \tmaybe_warn_bool_compare (location, code, orig_op0, orig_op1);\n       break;"}, {"sha": "18ed4d4236d77a7824f3aca321d166a47e247585", "filename": "gcc/c/gimple-parser.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fgimple-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fc%2Fgimple-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -364,6 +364,16 @@ c_parser_parse_gimple_body (c_parser *cparser, char *gimple_pass,\n       cgraph_node::get_create (cfun->decl);\n       cgraph_edge::rebuild_edges ();\n     }\n+\n+  /* Perform IL validation and if any error is found abort compilation\n+     of this function by zapping its body.  */\n+  if ((cfun->curr_properties & PROP_cfg)\n+      && verify_gimple_in_cfg (cfun, false, false))\n+    init_empty_tree_cfg ();\n+  else if (!(cfun->curr_properties & PROP_cfg)\n+\t   && verify_gimple_in_seq (gimple_body (current_function_decl), false))\n+    gimple_set_body (current_function_decl, NULL);\n+\n   dump_function (TDI_gimple, current_function_decl);\n }\n "}, {"sha": "6dd6f73e978040f78931f90ca153bff10b55bdbd", "filename": "gcc/calls.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcalls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcalls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -60,6 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attr-fnspec.h\"\n #include \"value-query.h\"\n #include \"tree-pretty-print.h\"\n+#include \"tree-eh.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -3154,7 +3155,10 @@ expand_call (tree exp, rtx target, int ignore)\n       if (pass && (flags & ECF_MALLOC))\n \tstart_sequence ();\n \n-      if (pass == 0\n+      /* Check the canary value for sibcall or function which doesn't\n+\t return and could throw.  */\n+      if ((pass == 0\n+\t   || ((flags & ECF_NORETURN) != 0 && tree_could_throw_p (exp)))\n \t  && crtl->stack_protect_guard\n \t  && targetm.stack_protect_runtime_enabled_p ())\n \tstack_protect_epilogue ();"}, {"sha": "29ded570734a4dce3449d2cf376c6c6ecd496a50", "filename": "gcc/cfghooks.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcfghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcfghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -541,7 +541,6 @@ split_block_1 (basic_block bb, void *i)\n     return NULL;\n \n   new_bb->count = bb->count;\n-  new_bb->discriminator = bb->discriminator;\n \n   if (dom_info_available_p (CDI_DOMINATORS))\n     {"}, {"sha": "f31941a61f97dce69d0ce1c42d8f2d6cf0fe58a4", "filename": "gcc/cfgrtl.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcfgrtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcfgrtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -4055,6 +4055,7 @@ fixup_reorder_chain (void)\n \t  ret_label = PATTERN (ret);\n \t  dest = EXIT_BLOCK_PTR_FOR_FN (cfun);\n \n+\t  e_fall->flags &= ~EDGE_CROSSING;\n \t  /* E_FALL->dest might become unreachable as a result of\n \t     replacing the jump with a return.  So arrange to remove\n \t     unreachable blocks.  */"}, {"sha": "5851b2ffc6cfe684c2042e7db797a9b571012213", "filename": "gcc/cgraph.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1411,7 +1411,6 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n {\n   tree decl = gimple_call_fndecl (e->call_stmt);\n   gcall *new_stmt;\n-  gimple_stmt_iterator gsi;\n \n   if (e->speculative)\n     {\n@@ -1572,18 +1571,17 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n       && (VOID_TYPE_P (TREE_TYPE (gimple_call_fntype (new_stmt)))\n \t  || should_remove_lhs_p (lhs)))\n     {\n+      gimple_call_set_lhs (new_stmt, NULL_TREE);\n+      /* We need to fix up the SSA name to avoid checking errors.  */\n       if (TREE_CODE (lhs) == SSA_NAME)\n \t{\n \t  tree var = create_tmp_reg_fn (DECL_STRUCT_FUNCTION (e->caller->decl),\n \t\t\t\t\tTREE_TYPE (lhs), NULL);\n-\t  var = get_or_create_ssa_default_def\n-\t\t  (DECL_STRUCT_FUNCTION (e->caller->decl), var);\n-\t  gimple *set_stmt = gimple_build_assign (lhs, var);\n-\t  gsi = gsi_for_stmt (new_stmt);\n-\t  gsi_insert_before_without_update (&gsi, set_stmt, GSI_SAME_STMT);\n-\t  update_stmt_fn (DECL_STRUCT_FUNCTION (e->caller->decl), set_stmt);\n+\t  SET_SSA_NAME_VAR_OR_IDENTIFIER (lhs, var);\n+\t  SSA_NAME_DEF_STMT (lhs) = gimple_build_nop ();\n+\t  set_ssa_default_def (DECL_STRUCT_FUNCTION (e->caller->decl),\n+\t\t\t       var, lhs);\n \t}\n-      gimple_call_set_lhs (new_stmt, NULL_TREE);\n       update_stmt_fn (DECL_STRUCT_FUNCTION (e->caller->decl), new_stmt);\n     }\n \n@@ -3751,7 +3749,9 @@ cgraph_node::verify_node (void)\n \t   && (!DECL_EXTERNAL (decl) || inlined_to)\n \t   && !flag_wpa)\n     {\n-      if (this_cfun->cfg)\n+      if ((this_cfun->curr_properties & PROP_assumptions_done) != 0)\n+\t;\n+      else if (this_cfun->cfg)\n \t{\n \t  hash_set<gimple *> stmts;\n "}, {"sha": "bb4b3c5407d56c1ea23b97131a7b91fa5b362e02", "filename": "gcc/cgraphclones.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcgraphclones.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcgraphclones.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -375,6 +375,7 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n   if (!new_inlined_to)\n     prof_count = count.combine_with_ipa_count (prof_count);\n   new_node->count = prof_count;\n+  new_node->calls_declare_variant_alt = this->calls_declare_variant_alt;\n \n   /* Update IPA profile.  Local profiles need no updating in original.  */\n   if (update_original)"}, {"sha": "b05d790bf8da82b74252b7afe876a2a7a092eebb", "filename": "gcc/cgraphunit.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcgraphunit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcgraphunit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1882,6 +1882,16 @@ cgraph_node::expand (void)\n   ggc_collect ();\n   timevar_pop (TV_REST_OF_COMPILATION);\n \n+  if (DECL_STRUCT_FUNCTION (decl)\n+      && DECL_STRUCT_FUNCTION (decl)->assume_function)\n+    {\n+      /* Assume functions aren't expanded into RTL, on the other side\n+\t we don't want to release their body.  */\n+      if (cfun)\n+\tpop_cfun ();\n+      return;\n+    }\n+\n   /* Make sure that BE didn't give up on compiling.  */\n   gcc_assert (TREE_ASM_WRITTEN (decl));\n   if (cfun)\n@@ -2373,6 +2383,10 @@ symbol_table::compile (void)\n \tif (node->inlined_to\n \t    || gimple_has_body_p (node->decl))\n \t  {\n+\t    if (DECL_STRUCT_FUNCTION (node->decl)\n+\t\t&& (DECL_STRUCT_FUNCTION (node->decl)->curr_properties\n+\t\t    & PROP_assumptions_done) != 0)\n+\t      continue;\n \t    error_found = true;\n \t    node->debug ();\n \t  }"}, {"sha": "bce3e514f65bbf18c0d6394fca85292478c1f284", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1004,6 +1004,9 @@ Driver Undocumented\n ;     member initializers in C++14 and up.\n ;     Default in G++ 12.\n ;\n+; 18: Corrects errors in mangling of lambdas with additional context.\n+;     Default in G++ 13.\n+;\n ; Additional positive integers will be assigned as new versions of\n ; the ABI become the default version of the ABI.\n fabi-version=\n@@ -3317,7 +3320,7 @@ Common Driver JoinedOrMissing Negative(gdwarf-)\n Generate debug information in default version of DWARF format.\n \n gdwarf-\n-Common Driver Joined UInteger Var(dwarf_version) Init(5)\n+Common Driver Joined UInteger Var(dwarf_version) Init(DWARF_VERSION_DEFAULT)\n Generate debug information in DWARF v2 (or later) format.\n \n gdwarf32\n@@ -3419,7 +3422,10 @@ EnumValue\n Enum(compressed_debug_sections) String(zlib) Value(1)\n \n EnumValue\n-Enum(compressed_debug_sections) String(zlib-gnu) Value(2)\n+Enum(compressed_debug_sections) String(zstd) Value(2)\n+\n+EnumValue\n+Enum(compressed_debug_sections) String(zlib-gnu) Value(3)\n \n gz\n Common Driver"}, {"sha": "61007839d35b356270e8c17aed1b2d3b05dca8e9", "filename": "gcc/common/config/aarch64/aarch64-common.cc", "status": "modified", "additions": 87, "deletions": 218, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -30,6 +30,7 @@\n #include \"opts.h\"\n #include \"flags.h\"\n #include \"diagnostic.h\"\n+#include \"config/aarch64/aarch64-feature-deps.h\"\n \n #ifdef  TARGET_BIG_ENDIAN_DEFAULT\n #undef  TARGET_DEFAULT_TARGET_FLAGS\n@@ -41,8 +42,6 @@\n \n #undef\tTARGET_OPTION_OPTIMIZATION_TABLE\n #define TARGET_OPTION_OPTIMIZATION_TABLE aarch_option_optimization_table\n-#undef TARGET_OPTION_INIT_STRUCT\n-#define TARGET_OPTION_INIT_STRUCT aarch64_option_init_struct\n \n /* Set default optimization options.  */\n static const struct default_options aarch_option_optimization_table[] =\n@@ -65,6 +64,17 @@ static const struct default_options aarch_option_optimization_table[] =\n     { OPT_LEVELS_NONE, 0, NULL, 0 }\n   };\n \n+/* Set OPTS->x_aarch64_asm_isa_flags to FLAGS and update\n+   OPTS->x_aarch64_isa_flags accordingly.  */\n+void\n+aarch64_set_asm_isa_flags (gcc_options *opts, aarch64_feature_flags flags)\n+{\n+  opts->x_aarch64_asm_isa_flags = flags;\n+  opts->x_aarch64_isa_flags = flags;\n+  if (opts->x_target_flags & MASK_GENERAL_REGS_ONLY)\n+    opts->x_aarch64_isa_flags &= ~feature_deps::get_flags_off (AARCH64_FL_FP);\n+}\n+\n /* Implement TARGET_HANDLE_OPTION.\n    This function handles the target specific options for CPU/target selection.\n \n@@ -99,6 +109,7 @@ aarch64_handle_option (struct gcc_options *opts,\n \n     case OPT_mgeneral_regs_only:\n       opts->x_target_flags |= MASK_GENERAL_REGS_ONLY;\n+      aarch64_set_asm_isa_flags (opts, opts->x_aarch64_asm_isa_flags);\n       return true;\n \n     case OPT_mfix_cortex_a53_835769:\n@@ -128,64 +139,52 @@ aarch64_handle_option (struct gcc_options *opts,\n /* An ISA extension in the co-processor and main instruction set space.  */\n struct aarch64_option_extension\n {\n-  const char *const name;\n-  const uint64_t flag_canonical;\n-  const uint64_t flags_on;\n-  const uint64_t flags_off;\n-  const bool is_synthetic;\n+  const char *name;\n+  aarch64_feature_flags flag_canonical;\n+  aarch64_feature_flags flags_on;\n+  aarch64_feature_flags flags_off;\n };\n \n /* ISA extensions in AArch64.  */\n-static const struct aarch64_option_extension all_extensions[] =\n-{\n-#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \\\n-\t\t\t      SYNTHETIC, Z) \\\n-  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},\n-#include \"config/aarch64/aarch64-option-extensions.def\"\n-  {NULL, 0, 0, 0, false}\n-};\n-\n-/* A copy of the ISA extensions list for AArch64 sorted by the popcount of\n-   bits and extension turned on.  Cached for efficiency.  */\n-static struct aarch64_option_extension all_extensions_by_on[] =\n+static constexpr aarch64_option_extension all_extensions[] =\n {\n-#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \\\n-\t\t\t      SYNTHETIC, Z) \\\n-  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},\n+#define AARCH64_OPT_EXTENSION(NAME, IDENT, C, D, E, F) \\\n+  {NAME, AARCH64_FL_##IDENT, feature_deps::IDENT ().explicit_on, \\\n+   feature_deps::get_flags_off (feature_deps::root_off_##IDENT)},\n #include \"config/aarch64/aarch64-option-extensions.def\"\n-  {NULL, 0, 0, 0, false}\n+  {NULL, 0, 0, 0}\n };\n \n struct processor_name_to_arch\n {\n-  const std::string processor_name;\n-  const enum aarch64_arch arch;\n-  const uint64_t flags;\n+  const char *processor_name;\n+  aarch64_arch arch;\n+  aarch64_feature_flags flags;\n };\n \n struct arch_to_arch_name\n {\n-  const enum aarch64_arch arch;\n-  const std::string arch_name;\n-  const uint64_t flags;\n+  aarch64_arch arch;\n+  const char *arch_name;\n+  aarch64_feature_flags flags;\n };\n \n /* Map processor names to the architecture revision they implement and\n    the default set of architectural feature flags they support.  */\n-static const struct processor_name_to_arch all_cores[] =\n+static constexpr processor_name_to_arch all_cores[] =\n {\n-#define AARCH64_CORE(NAME, X, IDENT, ARCH_IDENT, FLAGS, COSTS, IMP, PART, VARIANT) \\\n-  {NAME, AARCH64_ARCH_##ARCH_IDENT, FLAGS},\n+#define AARCH64_CORE(NAME, CORE_IDENT, C, ARCH_IDENT, E, F, G, H, I) \\\n+  {NAME, AARCH64_ARCH_##ARCH_IDENT, feature_deps::cpu_##CORE_IDENT},\n #include \"config/aarch64/aarch64-cores.def\"\n-  {\"generic\", AARCH64_ARCH_8A, AARCH64_FL_FOR_ARCH8},\n+  {\"generic\", AARCH64_ARCH_V8A, feature_deps::V8A ().enable},\n   {\"\", aarch64_no_arch, 0}\n };\n \n /* Map architecture revisions to their string representation.  */\n-static const struct arch_to_arch_name all_architectures[] =\n+static constexpr arch_to_arch_name all_architectures[] =\n {\n-#define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH, FLAGS) \\\n-  {AARCH64_ARCH_##ARCH_IDENT, NAME, FLAGS},\n+#define AARCH64_ARCH(NAME, B, ARCH_IDENT, D, E)\t\\\n+  {AARCH64_ARCH_##ARCH_IDENT, NAME, feature_deps::ARCH_IDENT ().enable},\n #include \"config/aarch64/aarch64-arches.def\"\n   {aarch64_no_arch, \"\", 0}\n };\n@@ -197,7 +196,7 @@ static const struct arch_to_arch_name all_architectures[] =\n    a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n enum aarch64_parse_opt_result\n-aarch64_parse_extension (const char *str, uint64_t *isa_flags,\n+aarch64_parse_extension (const char *str, aarch64_feature_flags *isa_flags,\n \t\t\t std::string *invalid_extension)\n {\n   /* The extension string is parsed left to right.  */\n@@ -239,9 +238,9 @@ aarch64_parse_extension (const char *str, uint64_t *isa_flags,\n \t    {\n \t      /* Add or remove the extension.  */\n \t      if (adding_ext)\n-\t\t*isa_flags |= (opt->flags_on | opt->flag_canonical);\n+\t\t*isa_flags |= opt->flags_on;\n \t      else\n-\t\t*isa_flags &= ~(opt->flags_off | opt->flag_canonical);\n+\t\t*isa_flags &= ~opt->flags_off;\n \t      break;\n \t    }\n \t}\n@@ -270,200 +269,70 @@ aarch64_get_all_extension_candidates (auto_vec<const char *> *candidates)\n     candidates->safe_push (opt->name);\n }\n \n-/* Comparer to sort aarch64's feature extensions by population count. Largest\n-   first.  */\n-\n-typedef const struct aarch64_option_extension opt_ext;\n-\n-int opt_ext_cmp (const void* a, const void* b)\n-{\n-  opt_ext *opt_a = (opt_ext *)a;\n-  opt_ext *opt_b = (opt_ext *)b;\n-\n-  /* We consider the total set of bits an options turns on to be the union of\n-     the singleton set containing the option itself and the set of options it\n-     turns on as a dependency.  As an example +dotprod turns on FL_DOTPROD and\n-     FL_SIMD.  As such the set of bits represented by this option is\n-     {FL_DOTPROD, FL_SIMD}. */\n-  uint64_t total_flags_a = opt_a->flag_canonical & opt_a->flags_on;\n-  uint64_t total_flags_b = opt_b->flag_canonical & opt_b->flags_on;\n-  int popcnt_a = popcount_hwi ((HOST_WIDE_INT)total_flags_a);\n-  int popcnt_b = popcount_hwi ((HOST_WIDE_INT)total_flags_b);\n-  int order = popcnt_b - popcnt_a;\n-\n-  /* If they have the same amount of bits set, give it a more\n-     deterministic ordering by using the value of the bits themselves.  */\n-  if (order != 0)\n-    return order;\n-\n-  if (total_flags_a != total_flags_b)\n-    return total_flags_a < total_flags_b ? 1 : -1;\n-\n-  return 0;\n-}\n-\n-/* Implement TARGET_OPTION_INIT_STRUCT.  */\n-\n-static void\n-aarch64_option_init_struct (struct gcc_options *opts ATTRIBUTE_UNUSED)\n-{\n-    /* Sort the extensions based on how many bits they set, order the larger\n-       counts first.  We sort the list because this makes processing the\n-       feature bits O(n) instead of O(n^2).  While n is small, the function\n-       to calculate the feature strings is called on every options push,\n-       pop and attribute change (arm_neon headers, lto etc all cause this to\n-       happen quite frequently).  It is a trade-off between time and space and\n-       so time won.  */\n-    int n_extensions = ARRAY_SIZE (all_extensions);\n-    qsort (&all_extensions_by_on, n_extensions,\n-\t   sizeof (struct aarch64_option_extension), opt_ext_cmp);\n-}\n-\n-/* Checks to see if enough bits from the option OPT are enabled in\n-   ISA_FLAG_BITS to be able to replace the individual options with the\n-   canonicalized version of the option.  This is done based on two rules:\n-\n-   1) Synthetic groups, such as +crypto we only care about the bits that are\n-      turned on. e.g. +aes+sha2 can be replaced with +crypto.\n-\n-   2) Options that themselves have a bit, such as +rdma, in this case, all the\n-      feature bits they turn on must be available and the bit for the option\n-      itself must be.  In this case it's effectively a reduction rather than a\n-      grouping. e.g. +fp+simd is not enough to turn on +rdma, for that you would\n-      need +rdma+fp+simd which is reduced down to +rdma.\n-*/\n-\n-static bool\n-aarch64_contains_opt (uint64_t isa_flag_bits, opt_ext *opt)\n-{\n-  uint64_t flags_check\n-    = opt->is_synthetic ? opt->flags_on : opt->flag_canonical;\n-\n-  return (isa_flag_bits & flags_check) == flags_check;\n-}\n-\n /* Return a string representation of ISA_FLAGS.  DEFAULT_ARCH_FLAGS\n    gives the default set of flags which are implied by whatever -march\n    we'd put out.  Our job is to figure out the minimal set of \"+\" and\n    \"+no\" feature flags to put out, and to put them out grouped such\n    that all the \"+\" flags come before the \"+no\" flags.  */\n \n std::string\n-aarch64_get_extension_string_for_isa_flags (uint64_t isa_flags,\n-\t\t\t\t\t    uint64_t default_arch_flags)\n+aarch64_get_extension_string_for_isa_flags\n+  (aarch64_feature_flags isa_flags,\n+   aarch64_feature_flags default_arch_flags)\n {\n-  const struct aarch64_option_extension *opt = NULL;\n   std::string outstr = \"\";\n \n-  uint64_t isa_flag_bits = isa_flags;\n-\n-  /* Pass one: Minimize the search space by reducing the set of options\n-     to the smallest set that still turns on the same features as before in\n-     conjunction with the bits that are turned on by default for the selected\n-     architecture.  */\n-  for (opt = all_extensions_by_on; opt->name != NULL; opt++)\n+  aarch64_feature_flags current_flags = default_arch_flags;\n+\n+  /* As a special case, do not assume that the assembler will enable CRC\n+     even if it is the default for the architecture.  This is required\n+     because some CPUs had an incorrect specification in older assemblers:\n+     even though CRC should be the default for these cases the -mcpu\n+     values would not turn it on.\n+\n+     However, assemblers with Armv8-R AArch64 support should not have this\n+     issue, so we don't need this fix when targeting Armv8-R.  */\n+  auto explicit_flags = (!(current_flags & AARCH64_FL_V8R)\n+\t\t\t ? AARCH64_FL_CRC : 0);\n+\n+  /* Add the features in isa_flags & ~current_flags using the smallest\n+     possible number of extensions.  We can do this by iterating over the\n+     array in reverse order, since the array is sorted topologically.\n+     But in order to make the output more readable, it seems better\n+     to add the strings in definition order.  */\n+  aarch64_feature_flags added = 0;\n+  for (unsigned int i = ARRAY_SIZE (all_extensions); i-- > 0; )\n     {\n-      /* If the bit is on by default, then all the options it turns on are also\n-\t on by default due to the transitive dependencies.\n-\n-         If the option is enabled explicitly in the set then we need to emit\n-\t an option for it.  Since this list is sorted by extensions setting the\n-\t largest number of featers first, we can be sure that nothing else will\n-\t ever need to set the bits we already set.  Consider the following\n-\t situation:\n-\n-\t  Feat1 = A + B + C\n-\t  Feat2 = A + B\n-\t  Feat3 = A + D\n-\t  Feat4 = B + C\n-\t  Feat5 = C\n-\n-\tThe following results are expected:\n-\n-\t  A + C = A + Feat5\n-\t  B + C = Feat4\n-\t  Feat4 + A = Feat1\n-\t  Feat2 + Feat5 = Feat1\n-\t  Feat1 + C = Feat1\n-          Feat3 + Feat4 = Feat1 + D\n-\n-\tThis search assumes that all invidual feature bits are use visible,\n-\tin other words the user must be able to do +A, +B, +C and +D.  */\n-      if (aarch64_contains_opt (isa_flag_bits | default_arch_flags, opt))\n-      {\n-\t/* We remove all the dependent bits, to prevent them from being turned\n-\t   on twice.  This only works because we assume that all there are\n-\t   individual options to set all bits standalone.  */\n-\n-\t/* PR target/94396.\n-\n-\t   For flags which would already imply a bit that's on by default (e.g\n-\t   fp16fml which implies +fp,+fp16) we must emit the flags that are not\n-\t   on by default.  i.e. in Armv8.4-a +fp16fml is default if +fp16.  So\n-\t   if a user passes armv8.4-a+fp16 (or +fp16fml) then we need to emit\n-\t   +fp16.  But if +fp16fml is used in an architecture where it is\n-\t   completely optional we only have to emit the canonical flag.  */\n-\tuint64_t toggle_bits = opt->flags_on & default_arch_flags;\n-\t/* Now check to see if the canonical flag is on by default.  If it\n-\t   is not then enabling it will enable all bits in flags_on.  */\n-\tif ((opt->flag_canonical & default_arch_flags) == 0)\n-\t  toggle_bits = opt->flags_on;\n-\n-\tisa_flag_bits &= ~toggle_bits;\n-\tisa_flag_bits |= opt->flag_canonical;\n-      }\n-    }\n+      auto &opt = all_extensions[i];\n \n-   /* By toggling bits on and off, we may have set bits on that are already\n-      enabled by default.  So we mask the default set out so we don't emit an\n-      option for them.  Instead of checking for this each time during Pass One\n-      we just mask all default bits away at the end.  */\n-   isa_flag_bits &= ~default_arch_flags;\n-\n-   /* We now have the smallest set of features we need to process.  A subsequent\n-      linear scan of the bits in isa_flag_bits will allow us to print the ext\n-      names.  However as a special case if CRC was enabled before, always print\n-      it.  This is required because some CPUs have an incorrect specification\n-      in older assemblers.  Even though CRC should be the default for these\n-      cases the -mcpu values won't turn it on.\n-\n-      Note that assemblers with Armv8-R AArch64 support should not have this\n-      issue, so we don't need this fix when targeting Armv8-R.  */\n-  if ((isa_flags & AARCH64_ISA_CRC) && !AARCH64_ISA_V8_R)\n-    isa_flag_bits |= AARCH64_ISA_CRC;\n-\n-  /* Pass Two:\n-     Print the option names that we're sure we must turn on.  These are only\n-     optional extension names.  Mandatory ones have already been removed and\n-     ones we explicitly want off have been too.  */\n-  for (opt = all_extensions_by_on; opt->name != NULL; opt++)\n-    {\n-      if (isa_flag_bits & opt->flag_canonical)\n-\t{\n-\t  outstr += \"+\";\n-\t  outstr += opt->name;\n-\t}\n-    }\n+      /* As a special case, emit +crypto rather than +aes+sha2,\n+\t in order to support assemblers that predate the separate\n+\t per-feature crypto flags.  */\n+      auto flags = opt.flag_canonical;\n+      if (flags == AARCH64_FL_CRYPTO)\n+\tflags = AARCH64_FL_AES | AARCH64_FL_SHA2;\n \n-  /* Pass Three:\n-     Print out a +no for any mandatory extension that we are\n-     turning off.  By this point aarch64_parse_extension would have ensured\n-     that any optional extensions are turned off.  The only things left are\n-     things that can't be turned off usually, e.g. something that is on by\n-     default because it's mandatory and we want it off.  For turning off bits\n-     we don't guarantee the smallest set of flags, but instead just emit all\n-     options the user has specified.\n-\n-     The assembler requires all +<opts> to be printed before +no<opts>.  */\n-  for (opt = all_extensions_by_on; opt->name != NULL; opt++)\n-    {\n-      if ((~isa_flags) & opt->flag_canonical\n-\t\t&& !((~default_arch_flags) & opt->flag_canonical))\n+      if ((flags & isa_flags & (explicit_flags | ~current_flags)) == flags)\n \t{\n-\t  outstr += \"+no\";\n-\t  outstr += opt->name;\n+\t  current_flags |= opt.flags_on;\n+\t  added |= opt.flag_canonical;\n \t}\n     }\n+  for (auto &opt : all_extensions)\n+    if (added & opt.flag_canonical)\n+      {\n+\toutstr += \"+\";\n+\toutstr += opt.name;\n+      }\n+\n+  /* Remove the features in current_flags & ~isa_flags.  */\n+  for (auto &opt : all_extensions)\n+    if (opt.flag_canonical & current_flags & ~isa_flags)\n+      {\n+\tcurrent_flags &= ~opt.flags_off;\n+\toutstr += \"+no\";\n+\toutstr += opt.name;\n+      }\n \n   return outstr;\n }\n@@ -517,7 +386,7 @@ aarch64_rewrite_selected_cpu (const char *name)\n       || a_to_an->arch == aarch64_no_arch)\n     fatal_error (input_location, \"unknown value %qs for %<-mcpu%>\", name);\n \n-  uint64_t extensions = p_to_a->flags;\n+  aarch64_feature_flags extensions = p_to_a->flags;\n   aarch64_parse_extension (extension_str.c_str (), &extensions, NULL);\n \n   std::string outstr = a_to_an->arch_name"}, {"sha": "62fe54234e0d0294ff23cd5cdef5b2f923589d54", "filename": "gcc/common/config/arc/arc-common.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -44,8 +44,6 @@ arc_option_init_struct (struct gcc_options *opts ATTRIBUTE_UNUSED)\n #define OPT_LEVELS_3_PLUS_SPEED_ONLY OPT_LEVELS_3_PLUS\n static const struct default_options arc_option_optimization_table[] =\n   {\n-    { OPT_LEVELS_ALL, OPT_mRcq, NULL, 1 },\n-    { OPT_LEVELS_ALL, OPT_mRcw, NULL, 1 },\n     { OPT_LEVELS_ALL, OPT_msize_level_, NULL, 1 },\n     { OPT_LEVELS_ALL, OPT_mearly_cbranchsi, NULL, 1 },\n     { OPT_LEVELS_ALL, OPT_mbbit_peephole, NULL, 1 },"}, {"sha": "22e2cfcb7b2168cf036e850e3ccbf5a8064847da", "filename": "gcc/common/config/h8300/h8300-common.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fh8300%2Fh8300-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fh8300%2Fh8300-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fh8300%2Fh8300-common.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -32,6 +32,8 @@ static const struct default_options h8300_option_optimization_table[] =\n        and/or variable-cycle branches where (cycle count taken !=\n        cycle count not taken).  */\n     { OPT_LEVELS_ALL, OPT_freorder_blocks, NULL, 0 },\n+    /* Enable redundant extension instructions removal at -O2 and higher.  */\n+    { OPT_LEVELS_2_PLUS, OPT_free, NULL, 1 },\n     { OPT_LEVELS_NONE, 0, NULL, 0 }\n   };\n "}, {"sha": "62c3d1b6b0013bc7152441f935e3048a64586c1f", "filename": "gcc/common/config/i386/cpuinfo.h", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -76,6 +76,8 @@ has_cpu_feature (struct __processor_model *cpu_model,\n     }\n }\n \n+/* Save FEATURE to either CPU_MODEL or CPU_FEATURES2.  */\n+\n static inline void\n set_cpu_feature (struct __processor_model *cpu_model,\n \t\t unsigned int *cpu_features2,\n@@ -100,6 +102,32 @@ set_cpu_feature (struct __processor_model *cpu_model,\n     }\n }\n \n+/* Drop FEATURE from either CPU_MODEL or CPU_FEATURES2.  */\n+\n+static inline void\n+reset_cpu_feature (struct __processor_model *cpu_model,\n+\t\t   unsigned int *cpu_features2,\n+\t\t   enum processor_features feature)\n+{\n+  unsigned index, offset;\n+  unsigned f = feature;\n+\n+  if (f < 32)\n+    {\n+      /* The first 32 features.  */\n+      cpu_model->__cpu_features[0] &= ~(1U << f);\n+    }\n+  else\n+    {\n+      /* The rest of features.  cpu_features2[i] contains features from\n+\t (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */\n+      f -= 32;\n+      index = f / 32;\n+      offset = f % 32;\n+      cpu_features2[index] &= ~(1U << offset);\n+    }\n+}\n+\n /* Get the specific type of AMD CPU and return AMD CPU name.  Return\n    NULL for unknown AMD CPU.  */\n \n@@ -253,13 +281,27 @@ get_amd_cpu (struct __processor_model *cpu_model,\n       break;\n     case 0x19:\n       cpu_model->__cpu_type = AMDFAM19H;\n-      /* AMD family 19h version 1.  */\n+      /* AMD family 19h.  */\n       if (model <= 0x0f)\n \t{\n \t  cpu = \"znver3\";\n \t  CHECK___builtin_cpu_is (\"znver3\");\n \t  cpu_model->__cpu_subtype = AMDFAM19H_ZNVER3;\n \t}\n+      else if ((model >= 0x10 && model <= 0x1f)\n+\t\t|| (model >= 0x60 && model <= 0xaf))\n+\t{\n+\t  cpu = \"znver4\";\n+\t  CHECK___builtin_cpu_is (\"znver4\");\n+\t  cpu_model->__cpu_subtype = AMDFAM19H_ZNVER4;\n+\t}\n+      else if (has_cpu_feature (cpu_model, cpu_features2,\n+\t\t\t\tFEATURE_AVX512F))\n+\t{\n+\t  cpu = \"znver4\";\n+\t  CHECK___builtin_cpu_is (\"znver4\");\n+\t  cpu_model->__cpu_subtype = AMDFAM19H_ZNVER4;\n+\t}\n       else if (has_cpu_feature (cpu_model, cpu_features2,\n \t\t\t\tFEATURE_VAES))\n \t{\n@@ -496,6 +538,12 @@ get_intel_cpu (struct __processor_model *cpu_model,\n     case 0x9a:\n     case 0xbf:\n       /* Alder Lake.  */\n+    case 0xb7:\n+      /* Raptor Lake.  */\n+    case 0xb5:\n+    case 0xaa:\n+    case 0xac:\n+      /* Meteor Lake.  */\n       cpu = \"alderlake\";\n       CHECK___builtin_cpu_is (\"corei7\");\n       CHECK___builtin_cpu_is (\"alderlake\");\n@@ -545,11 +593,11 @@ get_zhaoxin_cpu (struct __processor_model *cpu_model,\n       cpu_model->__cpu_type = ZHAOXIN_FAM7H;\n       if (model == 0x3b)\n \t{\n-\tcpu = \"lujiazui\";\n-\tCHECK___builtin_cpu_is (\"lujiazui\");\n-\tcpu_model->__cpu_features[0] &= ~(1U <<(FEATURE_AVX & 31));\n-\tcpu_features2[0] &= ~(1U <<((FEATURE_F16C - 32) & 31));\n-\tcpu_model->__cpu_subtype = ZHAOXIN_FAM7H_LUJIAZUI;\n+\t  cpu = \"lujiazui\";\n+\t  CHECK___builtin_cpu_is (\"lujiazui\");\n+\t  reset_cpu_feature (cpu_model, cpu_features2, FEATURE_AVX);\n+\t  reset_cpu_feature (cpu_model, cpu_features2, FEATURE_F16C);\n+\t  cpu_model->__cpu_subtype = ZHAOXIN_FAM7H_LUJIAZUI;\n \t}\n       break;\n     default:\n@@ -787,6 +835,12 @@ get_available_features (struct __processor_model *cpu_model,\n \t{\n \t  if (eax & bit_AVXVNNI)\n \t    set_feature (FEATURE_AVXVNNI);\n+\t  if (eax & bit_AVXIFMA)\n+\t    set_feature (FEATURE_AVXIFMA);\n+\t  if (edx & bit_AVXVNNIINT8)\n+\t    set_feature (FEATURE_AVXVNNIINT8);\n+\t  if (edx & bit_AVXNECONVERT)\n+\t    set_feature (FEATURE_AVXNECONVERT);\n \t}\n       if (avx512_usable)\n \t{"}, {"sha": "cd6ad2c477b6b8e837940d01938978976015d71f", "filename": "gcc/common/config/i386/i386-common.cc", "status": "modified", "additions": 70, "deletions": 28, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n   (OPTION_MASK_ISA_AVX512VL | OPTION_MASK_ISA_AVX512F_SET)\n #define OPTION_MASK_ISA_AVX512IFMA_SET \\\n   (OPTION_MASK_ISA_AVX512IFMA | OPTION_MASK_ISA_AVX512F_SET)\n+#define OPTION_MASK_ISA2_AVXIFMA_SET OPTION_MASK_ISA2_AVXIFMA\n #define OPTION_MASK_ISA_AVX512VBMI_SET \\\n   (OPTION_MASK_ISA_AVX512VBMI | OPTION_MASK_ISA_AVX512BW_SET)\n #define OPTION_MASK_ISA2_AVX5124FMAPS_SET OPTION_MASK_ISA2_AVX5124FMAPS\n@@ -107,6 +108,8 @@ along with GCC; see the file COPYING3.  If not see\n #define OPTION_MASK_ISA2_AMX_TILE_SET OPTION_MASK_ISA2_AMX_TILE\n #define OPTION_MASK_ISA2_AMX_INT8_SET OPTION_MASK_ISA2_AMX_INT8\n #define OPTION_MASK_ISA2_AMX_BF16_SET OPTION_MASK_ISA2_AMX_BF16\n+#define OPTION_MASK_ISA2_AVXVNNIINT8_SET OPTION_MASK_ISA2_AVXVNNIINT8\n+#define OPTION_MASK_ISA2_AVXNECONVERT_SET OPTION_MASK_ISA2_AVXNECONVERT\n \n /* SSE4 includes both SSE4.1 and SSE4.2. -msse4 should be the same\n    as -msse4.2.  */\n@@ -212,7 +215,9 @@ along with GCC; see the file COPYING3.  If not see\n #define OPTION_MASK_ISA_AVX2_UNSET \\\n   (OPTION_MASK_ISA_AVX2 | OPTION_MASK_ISA_AVX512F_UNSET)\n #define OPTION_MASK_ISA2_AVX2_UNSET \\\n-  (OPTION_MASK_ISA2_AVXVNNI_UNSET | OPTION_MASK_ISA2_AVX512F_UNSET)\n+  (OPTION_MASK_ISA2_AVXIFMA_UNSET | OPTION_MASK_ISA2_AVXVNNI_UNSET \\\n+   | OPTION_MASK_ISA2_AVXVNNIINT8_UNSET | OPTION_MASK_ISA2_AVXNECONVERT_UNSET \\\n+   | OPTION_MASK_ISA2_AVX512F_UNSET)\n #define OPTION_MASK_ISA_AVX512F_UNSET \\\n   (OPTION_MASK_ISA_AVX512F | OPTION_MASK_ISA_AVX512CD_UNSET \\\n    | OPTION_MASK_ISA_AVX512PF_UNSET | OPTION_MASK_ISA_AVX512ER_UNSET \\\n@@ -230,6 +235,7 @@ along with GCC; see the file COPYING3.  If not see\n   (OPTION_MASK_ISA_AVX512BW | OPTION_MASK_ISA_AVX512VBMI_UNSET)\n #define OPTION_MASK_ISA_AVX512VL_UNSET OPTION_MASK_ISA_AVX512VL\n #define OPTION_MASK_ISA_AVX512IFMA_UNSET OPTION_MASK_ISA_AVX512IFMA\n+#define OPTION_MASK_ISA2_AVXIFMA_UNSET OPTION_MASK_ISA2_AVXIFMA\n #define OPTION_MASK_ISA_AVX512VBMI_UNSET OPTION_MASK_ISA_AVX512VBMI\n #define OPTION_MASK_ISA2_AVX5124FMAPS_UNSET OPTION_MASK_ISA2_AVX5124FMAPS\n #define OPTION_MASK_ISA2_AVX5124VNNIW_UNSET OPTION_MASK_ISA2_AVX5124VNNIW\n@@ -275,6 +281,8 @@ along with GCC; see the file COPYING3.  If not see\n #define OPTION_MASK_ISA2_KL_UNSET \\\n   (OPTION_MASK_ISA2_KL | OPTION_MASK_ISA2_WIDEKL_UNSET)\n #define OPTION_MASK_ISA2_WIDEKL_UNSET OPTION_MASK_ISA2_WIDEKL\n+#define OPTION_MASK_ISA2_AVXVNNIINT8_UNSET OPTION_MASK_ISA2_AVXVNNIINT8\n+#define OPTION_MASK_ISA2_AVXNECONVERT_UNSET OPTION_MASK_ISA2_AVXNECONVERT\n \n /* SSE4 includes both SSE4.1 and SSE4.2.  -mno-sse4 should the same\n    as -mno-sse4.1. */\n@@ -1124,6 +1132,55 @@ ix86_handle_option (struct gcc_options *opts,\n \t}\n       return true;\n \n+    case OPT_mavxifma:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA2_AVXIFMA_SET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA2_AVXIFMA_SET;\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX2_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX2_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags2 &= ~OPTION_MASK_ISA2_AVXIFMA_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA2_AVXIFMA_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mavxvnniint8:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA2_AVXVNNIINT8_SET;\n+\t  opts->x_ix86_isa_flags2_explicit |=\n+\t    OPTION_MASK_ISA2_AVXVNNIINT8_SET;\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX2_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX2_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags2 &=\n+\t    ~OPTION_MASK_ISA2_AVXVNNIINT8_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit |=\n+\t    OPTION_MASK_ISA2_AVXVNNIINT8_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mavxneconvert:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA2_AVXNECONVERT_SET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA2_AVXNECONVERT_SET;\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX2_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX2_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags2 &= ~OPTION_MASK_ISA2_AVXNECONVERT_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit\n+\t    |= OPTION_MASK_ISA2_AVXNECONVERT_UNSET;\n+\t}\n+      return true;\n+\n     case OPT_mfma:\n       if (value)\n \t{\n@@ -1830,7 +1887,8 @@ const char *const processor_names[] =\n   \"btver2\",\n   \"znver1\",\n   \"znver2\",\n-  \"znver3\"\n+  \"znver3\",\n+  \"znver4\"\n };\n \n /* Guarantee that the array is aligned with enum processor_type.  */\n@@ -1929,6 +1987,10 @@ const pta processor_alias_table[] =\n     M_CPU_SUBTYPE (INTEL_COREI7_SAPPHIRERAPIDS), P_PROC_AVX512F},\n   {\"alderlake\", PROCESSOR_ALDERLAKE, CPU_HASWELL, PTA_ALDERLAKE,\n     M_CPU_SUBTYPE (INTEL_COREI7_ALDERLAKE), P_PROC_AVX2},\n+  {\"raptorlake\", PROCESSOR_ALDERLAKE, CPU_HASWELL, PTA_ALDERLAKE,\n+    M_CPU_SUBTYPE (INTEL_COREI7_ALDERLAKE), P_PROC_AVX2},\n+  {\"meteorlake\", PROCESSOR_ALDERLAKE, CPU_HASWELL, PTA_ALDERLAKE,\n+    M_CPU_SUBTYPE (INTEL_COREI7_ALDERLAKE), P_PROC_AVX2},\n   {\"bonnell\", PROCESSOR_BONNELL, CPU_ATOM, PTA_BONNELL,\n     M_CPU_TYPE (INTEL_BONNELL), P_PROC_SSSE3},\n   {\"atom\", PROCESSOR_BONNELL, CPU_ATOM, PTA_BONNELL,\n@@ -2062,37 +2124,17 @@ const pta processor_alias_table[] =\n       | PTA_MOVBE | PTA_MWAITX,\n     M_CPU_SUBTYPE (AMDFAM15H_BDVER4), P_PROC_AVX2},\n   {\"znver1\", PROCESSOR_ZNVER1, CPU_ZNVER1,\n-    PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n-      | PTA_SSE4A | PTA_CX16 | PTA_ABM | PTA_SSSE3 | PTA_SSE4_1\n-      | PTA_SSE4_2 | PTA_AES | PTA_PCLMUL | PTA_AVX | PTA_AVX2\n-      | PTA_BMI | PTA_BMI2 | PTA_F16C | PTA_FMA | PTA_PRFCHW\n-      | PTA_FXSR | PTA_XSAVE | PTA_XSAVEOPT | PTA_FSGSBASE\n-      | PTA_RDRND | PTA_MOVBE | PTA_MWAITX | PTA_ADX | PTA_RDSEED\n-      | PTA_CLZERO | PTA_CLFLUSHOPT | PTA_XSAVEC | PTA_XSAVES\n-      | PTA_SHA | PTA_LZCNT | PTA_POPCNT,\n+    PTA_ZNVER1,\n     M_CPU_SUBTYPE (AMDFAM17H_ZNVER1), P_PROC_AVX2},\n   {\"znver2\", PROCESSOR_ZNVER2, CPU_ZNVER2,\n-    PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n-      | PTA_SSE4A | PTA_CX16 | PTA_ABM | PTA_SSSE3 | PTA_SSE4_1\n-      | PTA_SSE4_2 | PTA_AES | PTA_PCLMUL | PTA_AVX | PTA_AVX2\n-      | PTA_BMI | PTA_BMI2 | PTA_F16C | PTA_FMA | PTA_PRFCHW\n-      | PTA_FXSR | PTA_XSAVE | PTA_XSAVEOPT | PTA_FSGSBASE\n-      | PTA_RDRND | PTA_MOVBE | PTA_MWAITX | PTA_ADX | PTA_RDSEED\n-      | PTA_CLZERO | PTA_CLFLUSHOPT | PTA_XSAVEC | PTA_XSAVES\n-      | PTA_SHA | PTA_LZCNT | PTA_POPCNT | PTA_CLWB | PTA_RDPID\n-      | PTA_WBNOINVD,\n+    PTA_ZNVER2,\n     M_CPU_SUBTYPE (AMDFAM17H_ZNVER2), P_PROC_AVX2},\n   {\"znver3\", PROCESSOR_ZNVER3, CPU_ZNVER3,\n-    PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n-      | PTA_SSE4A | PTA_CX16 | PTA_ABM | PTA_SSSE3 | PTA_SSE4_1\n-      | PTA_SSE4_2 | PTA_AES | PTA_PCLMUL | PTA_AVX | PTA_AVX2\n-      | PTA_BMI | PTA_BMI2 | PTA_F16C | PTA_FMA | PTA_PRFCHW\n-      | PTA_FXSR | PTA_XSAVE | PTA_XSAVEOPT | PTA_FSGSBASE\n-      | PTA_RDRND | PTA_MOVBE | PTA_MWAITX | PTA_ADX | PTA_RDSEED\n-      | PTA_CLZERO | PTA_CLFLUSHOPT | PTA_XSAVEC | PTA_XSAVES\n-      | PTA_SHA | PTA_LZCNT | PTA_POPCNT | PTA_CLWB | PTA_RDPID\n-      | PTA_WBNOINVD | PTA_VAES | PTA_VPCLMULQDQ | PTA_PKU,\n+    PTA_ZNVER3,\n     M_CPU_SUBTYPE (AMDFAM19H_ZNVER3), P_PROC_AVX2},\n+  {\"znver4\", PROCESSOR_ZNVER4, CPU_ZNVER3,\n+    PTA_ZNVER4,\n+    M_CPU_SUBTYPE (AMDFAM19H_ZNVER4), P_PROC_AVX512F},\n   {\"btver1\", PROCESSOR_BTVER1, CPU_GENERIC,\n     PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n       | PTA_SSSE3 | PTA_SSE4A | PTA_ABM | PTA_CX16 | PTA_PRFCHW"}, {"sha": "4fbbfa5b701c7a4b4028504c41a18af73b0817a1", "filename": "gcc/common/config/i386/i386-cpuinfo.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-cpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-cpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-cpuinfo.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -34,8 +34,10 @@ enum processor_vendor\n   VENDOR_CENTAUR,\n   VENDOR_CYRIX,\n   VENDOR_NSC,\n-  BUILTIN_VENDOR_MAX = VENDOR_OTHER,\n-  VENDOR_MAX\n+\n+  /* Maximum values must be at the end of this enum.  */\n+  VENDOR_MAX,\n+  BUILTIN_VENDOR_MAX = VENDOR_OTHER\n };\n \n /* Any new types or subtypes have to be inserted at the end. */\n@@ -92,6 +94,7 @@ enum processor_subtypes\n   AMDFAM19H_ZNVER3,\n   INTEL_COREI7_ROCKETLAKE,\n   ZHAOXIN_FAM7H_LUJIAZUI,\n+  AMDFAM19H_ZNVER4,\n   CPU_SUBTYPE_MAX\n };\n \n@@ -240,6 +243,9 @@ enum processor_features\n   FEATURE_X86_64_V2,\n   FEATURE_X86_64_V3,\n   FEATURE_X86_64_V4,\n+  FEATURE_AVXIFMA,\n+  FEATURE_AVXVNNIINT8,\n+  FEATURE_AVXNECONVERT,\n   CPU_FEATURE_MAX\n };\n "}, {"sha": "bceaee589ee3c3a1ee36c7ec22929f3b7c0815a6", "filename": "gcc/common/config/i386/i386-isas.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-isas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-isas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-isas.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -175,4 +175,9 @@ ISA_NAMES_TABLE_START\n   ISA_NAMES_TABLE_ENTRY(\"x86-64-v2\", FEATURE_X86_64_V2, P_X86_64_V2, NULL)\n   ISA_NAMES_TABLE_ENTRY(\"x86-64-v3\", FEATURE_X86_64_V3, P_X86_64_V3, NULL)\n   ISA_NAMES_TABLE_ENTRY(\"x86-64-v4\", FEATURE_X86_64_V4, P_X86_64_V4, NULL)\n+  ISA_NAMES_TABLE_ENTRY(\"avxifma\", FEATURE_AVXIFMA, P_NONE, \"-mavxifma\")\n+  ISA_NAMES_TABLE_ENTRY(\"avxvnniint8\", FEATURE_AVXVNNIINT8,\n+\t\t\tP_NONE, \"-mavxvnniint8\")\n+  ISA_NAMES_TABLE_ENTRY(\"avxneconvert\", FEATURE_AVXNECONVERT,\n+\t\t\tP_NONE, \"-mavxneconvert\")\n ISA_NAMES_TABLE_END"}, {"sha": "d6404a01205eb206af50e446fd9f8389e30f6a54", "filename": "gcc/common/config/riscv/riscv-common.cc", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -51,6 +51,11 @@ static const riscv_implied_info_t riscv_implied_info[] =\n   {\"d\", \"f\"},\n   {\"f\", \"zicsr\"},\n   {\"d\", \"zicsr\"},\n+\n+  {\"zdinx\", \"zfinx\"},\n+  {\"zfinx\", \"zicsr\"},\n+  {\"zdinx\", \"zicsr\"},\n+\n   {\"zk\", \"zkn\"},\n   {\"zk\", \"zkr\"},\n   {\"zk\", \"zkt\"},\n@@ -99,6 +104,9 @@ static const riscv_implied_info_t riscv_implied_info[] =\n \n   {\"zfh\", \"zfhmin\"},\n   {\"zfhmin\", \"f\"},\n+  \n+  {\"zhinx\", \"zhinxmin\"},\n+  {\"zhinxmin\", \"zfinx\"},\n \n   {NULL, NULL}\n };\n@@ -145,6 +153,8 @@ static const struct riscv_ext_version riscv_ext_version_table[] =\n   {\"c\", ISA_SPEC_CLASS_20190608, 2, 0},\n   {\"c\", ISA_SPEC_CLASS_2P2,      2, 0},\n \n+  {\"h\",       ISA_SPEC_CLASS_NONE, 1, 0},\n+\n   {\"v\",       ISA_SPEC_CLASS_NONE, 1, 0},\n \n   {\"zicsr\", ISA_SPEC_CLASS_20191213, 2, 0},\n@@ -158,6 +168,11 @@ static const struct riscv_ext_version riscv_ext_version_table[] =\n   {\"zbc\", ISA_SPEC_CLASS_NONE, 1, 0},\n   {\"zbs\", ISA_SPEC_CLASS_NONE, 1, 0},\n \n+  {\"zfinx\", ISA_SPEC_CLASS_NONE, 1, 0},\n+  {\"zdinx\", ISA_SPEC_CLASS_NONE, 1, 0},\n+  {\"zhinx\", ISA_SPEC_CLASS_NONE, 1, 0},\n+  {\"zhinxmin\", ISA_SPEC_CLASS_NONE, 1, 0},\n+\n   {\"zbkb\",  ISA_SPEC_CLASS_NONE, 1, 0},\n   {\"zbkc\",  ISA_SPEC_CLASS_NONE, 1, 0},\n   {\"zbkx\",  ISA_SPEC_CLASS_NONE, 1, 0},\n@@ -202,6 +217,9 @@ static const struct riscv_ext_version riscv_ext_version_table[] =\n \n   {\"zmmul\", ISA_SPEC_CLASS_NONE, 1, 0},\n \n+  {\"svinval\", ISA_SPEC_CLASS_NONE, 1, 0},\n+  {\"svnapot\", ISA_SPEC_CLASS_NONE, 1, 0},\n+\n   /* Terminate the list.  */\n   {NULL, ISA_SPEC_CLASS_NONE, 0, 0}\n };\n@@ -224,6 +242,14 @@ static const riscv_cpu_info riscv_cpu_tables[] =\n     {NULL, NULL, NULL}\n };\n \n+static const char *riscv_tunes[] =\n+{\n+#define RISCV_TUNE(TUNE_NAME, PIPELINE_MODEL, TUNE_INFO) \\\n+    TUNE_NAME,\n+#include \"../../../config/riscv/riscv-cores.def\"\n+    NULL\n+};\n+\n static const char *riscv_supported_std_ext (void);\n \n static riscv_subset_list *current_subset_list = NULL;\n@@ -353,21 +379,18 @@ multi_letter_subset_rank (const std::string &subset)\n   gcc_assert (subset.length () >= 2);\n   int high_order = -1;\n   int low_order = 0;\n-  /* The order between multi-char extensions: s -> h -> z -> x.  */\n+  /* The order between multi-char extensions: s -> z -> x.  */\n   char multiletter_class = subset[0];\n   switch (multiletter_class)\n     {\n     case 's':\n       high_order = 0;\n       break;\n-    case 'h':\n-      high_order = 1;\n-      break;\n     case 'z':\n-      high_order = 2;\n+      high_order = 1;\n       break;\n     case 'x':\n-      high_order = 3;\n+      high_order = 2;\n       break;\n     default:\n       gcc_unreachable ();\n@@ -663,7 +686,7 @@ riscv_subset_list::lookup (const char *subset, int major_version,\n static const char *\n riscv_supported_std_ext (void)\n {\n-  return \"mafdqlcbkjtpvn\";\n+  return \"mafdqlcbkjtpvnh\";\n }\n \n /* Parsing subset version.\n@@ -822,7 +845,7 @@ riscv_subset_list::parse_std_ext (const char *p)\n     {\n       char subset[2] = {0, 0};\n \n-      if (*p == 'x' || *p == 's' || *p == 'h' || *p == 'z')\n+      if (*p == 'x' || *p == 's' || *p == 'z')\n \tbreak;\n \n       if (*p == '_')\n@@ -947,7 +970,7 @@ riscv_subset_list::handle_combine_ext ()\n \n    Arguments:\n      `p`: Current parsing position.\n-     `ext_type`: What kind of extensions, 's', 'h', 'z' or 'x'.\n+     `ext_type`: What kind of extensions, 's', 'z' or 'x'.\n      `ext_type_str`: Full name for kind of extension.  */\n \n const char *\n@@ -1086,12 +1109,6 @@ riscv_subset_list::parse (const char *arch, location_t loc)\n   /* Parsing supervisor extension.  */\n   p = subset_list->parse_multiletter_ext (p, \"s\", \"supervisor extension\");\n \n-  if (p == NULL)\n-    goto fail;\n-\n-  /* Parsing hypervisor extension.  */\n-  p = subset_list->parse_multiletter_ext (p, \"h\", \"hypervisor extension\");\n-\n   if (p == NULL)\n     goto fail;\n \n@@ -1168,6 +1185,11 @@ static const riscv_ext_flag_table_t riscv_ext_flag_table[] =\n   {\"zbc\",    &gcc_options::x_riscv_zb_subext, MASK_ZBC},\n   {\"zbs\",    &gcc_options::x_riscv_zb_subext, MASK_ZBS},\n \n+  {\"zfinx\",    &gcc_options::x_riscv_zinx_subext, MASK_ZFINX},\n+  {\"zdinx\",    &gcc_options::x_riscv_zinx_subext, MASK_ZDINX},\n+  {\"zhinx\",    &gcc_options::x_riscv_zinx_subext, MASK_ZHINX},\n+  {\"zhinxmin\", &gcc_options::x_riscv_zinx_subext, MASK_ZHINXMIN},\n+\n   {\"zbkb\",   &gcc_options::x_riscv_zk_subext, MASK_ZBKB},\n   {\"zbkc\",   &gcc_options::x_riscv_zk_subext, MASK_ZBKC},\n   {\"zbkx\",   &gcc_options::x_riscv_zk_subext, MASK_ZBKX},\n@@ -1218,6 +1240,9 @@ static const riscv_ext_flag_table_t riscv_ext_flag_table[] =\n \n   {\"zmmul\", &gcc_options::x_riscv_zm_subext, MASK_ZMMUL},\n \n+  {\"svinval\", &gcc_options::x_riscv_sv_subext, MASK_SVINVAL},\n+  {\"svnapot\", &gcc_options::x_riscv_sv_subext, MASK_SVNAPOT},\n+\n   {NULL, NULL, 0}\n };\n \n@@ -1687,6 +1712,41 @@ riscv_compute_multilib (\n #define TARGET_COMPUTE_MULTILIB riscv_compute_multilib\n #endif\n \n+vec<const char *>\n+riscv_get_valid_option_values (int option_code,\n+\t\t\t       const char *prefix ATTRIBUTE_UNUSED)\n+{\n+  vec<const char *> v;\n+  v.create (0);\n+  opt_code opt = (opt_code) option_code;\n+\n+  switch (opt)\n+    {\n+    case OPT_mtune_:\n+      {\n+\tconst char **tune = &riscv_tunes[0];\n+\tfor (;*tune; ++tune)\n+\t  v.safe_push (*tune);\n+\n+\tconst riscv_cpu_info *cpu_info = &riscv_cpu_tables[0];\n+\tfor (;cpu_info->name; ++cpu_info)\n+\t  v.safe_push (cpu_info->name);\n+      }\n+      break;\n+    case OPT_mcpu_:\n+      {\n+\tconst riscv_cpu_info *cpu_info = &riscv_cpu_tables[0];\n+\tfor (;cpu_info->name; ++cpu_info)\n+\t  v.safe_push (cpu_info->name);\n+      }\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return v;\n+}\n+\n /* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n static const struct default_options riscv_option_optimization_table[] =\n   {\n@@ -1701,4 +1761,7 @@ static const struct default_options riscv_option_optimization_table[] =\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION riscv_handle_option\n \n+#undef  TARGET_GET_VALID_OPTION_VALUES\n+#define TARGET_GET_VALID_OPTION_VALUES riscv_get_valid_option_values\n+\n struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "98a905e0db18424e92eec3031455d15036c6992f", "filename": "gcc/config.gcc", "status": "modified", "additions": 65, "deletions": 18, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -432,7 +432,8 @@ i[34567]86-*-* | x86_64-*-*)\n \t\t       tsxldtrkintrin.h amxtileintrin.h amxint8intrin.h\n \t\t       amxbf16intrin.h x86gprintrin.h uintrintrin.h\n \t\t       hresetintrin.h keylockerintrin.h avxvnniintrin.h\n-\t\t       mwaitintrin.h avx512fp16intrin.h avx512fp16vlintrin.h\"\n+\t\t       mwaitintrin.h avx512fp16intrin.h avx512fp16vlintrin.h\n+\t\t       avxifmaintrin.h avxvnniint8intrin.h avxneconvertintrin.h\"\n \t;;\n ia64-*-*)\n \textra_headers=ia64intrin.h\n@@ -526,8 +527,12 @@ pru-*-*)\n \t;;\n riscv*)\n \tcpu_type=riscv\n-\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o riscv-selftests.o\"\n+\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o riscv-selftests.o riscv-v.o\"\n+\textra_objs=\"${extra_objs} riscv-vector-builtins.o riscv-vector-builtins-shapes.o riscv-vector-builtins-bases.o\"\n \td_target_objs=\"riscv-d.o\"\n+\textra_headers=\"riscv_vector.h\"\n+\ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/riscv/riscv-vector-builtins.cc\"\n+\ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/riscv/riscv-vector-builtins.h\"\n \t;;\n rs6000*-*-*)\n \textra_options=\"${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt\"\n@@ -676,7 +681,7 @@ c7 esther\"\n # 64-bit x86 processors supported by --with-arch=.  Each processor\n # MUST be separated by exactly one space.\n x86_64_archs=\"amdfam10 athlon64 athlon64-sse3 barcelona bdver1 bdver2 \\\n-bdver3 bdver4 znver1 znver2 znver3 btver1 btver2 k8 k8-sse3 opteron \\\n+bdver3 bdver4 znver1 znver2 znver3 znver4 btver1 btver2 k8 k8-sse3 opteron \\\n opteron-sse3 nocona core2 corei7 corei7-avx core-avx-i core-avx2 atom \\\n slm nehalem westmere sandybridge ivybridge haswell broadwell bonnell \\\n silvermont knl knm skylake-avx512 cannonlake icelake-client icelake-server \\\n@@ -907,10 +912,8 @@ case ${target} in\n   esac\n   c_target_objs=\"${c_target_objs} glibc-c.o\"\n   cxx_target_objs=\"${cxx_target_objs} glibc-c.o\"\n-  d_target_objs=\"${d_target_objs} glibc-d.o\"\n   tmake_file=\"${tmake_file} t-glibc\"\n   target_has_targetcm=yes\n-  target_has_targetdm=yes\n   case $target in\n     *-*-*uclibc* | *-*-uclinuxfdpiceabi)\n       ;;\n@@ -920,10 +923,24 @@ case ${target} in\n       ;;\n   esac\n   case $target in\n-    *linux*)\n+    *-*-*linux*)\n+      d_target_objs=\"${d_target_objs} linux-d.o\"\n+      target_has_targetdm=yes\n       rust_target_objs=\"${rust_target_objs} linux-rust.o\"\n       target_has_targetrustm=yes\n       ;;\n+    *-*-kfreebsd*-gnu)\n+      d_target_objs=\"${d_target_objs} kfreebsd-d.o\"\n+      target_has_targetdm=yes\n+      ;;\n+    *-*-kopensolaris*-gnu)\n+      d_target_objs=\"${d_target_objs} kopensolaris-d.o\"\n+      target_has_targetdm=yes\n+      ;;\n+    *-*-gnu*)\n+      d_target_objs=\"${d_target_objs} gnu-d.o\"\n+      target_has_targetdm=yes\n+      ;;\n   esac\n   ;;\n *-*-netbsd*)\n@@ -1065,6 +1082,8 @@ case ${target} in\n   rust_target_objs=\"${rust_target_objs} vxworks-rust.o\"\n   target_has_targetrustm=yes\n \n+  extra_gcc_objs=\"vxworks-driver.o\"\n+\n   # This private header exposes a consistent interface for checks on\n   # the VxWorks version our runtime header files need to perform, based on\n   # what the system headers adverstise:\n@@ -1123,6 +1142,11 @@ case ${target} in\n   # Assume that newlib is being used and so __cxa_atexit is provided.\n   default_use_cxa_atexit=yes\n   use_gcc_stdint=wrap\n+\n+  case \"${with_newlib}-${with_headers}\" in\n+  no-no) use_gcc_stdint=provide ;;\n+  *) ;;\n+  esac\n   ;;\n esac\n \n@@ -2087,7 +2111,7 @@ i[34567]86-*-cygwin*)\n \textra_objs=\"${extra_objs} winnt.o winnt-stubs.o\"\n \tc_target_objs=\"${c_target_objs} msformat-c.o\"\n \tcxx_target_objs=\"${cxx_target_objs} winnt-cxx.o msformat-c.o\"\n-\td_target_objs=\"${d_target_objs} winnt-d.o\"\n+\td_target_objs=\"${d_target_objs} cygwin-d.o\"\n \ttarget_has_targetdm=\"yes\"\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='posix'\n@@ -2105,7 +2129,7 @@ x86_64-*-cygwin*)\n \textra_objs=\"${extra_objs} winnt.o winnt-stubs.o\"\n \tc_target_objs=\"${c_target_objs} msformat-c.o\"\n \tcxx_target_objs=\"${cxx_target_objs} winnt-cxx.o msformat-c.o\"\n-\td_target_objs=\"${d_target_objs} winnt-d.o\"\n+\td_target_objs=\"${d_target_objs} cygwin-d.o\"\n \ttarget_has_targetdm=\"yes\"\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='posix'\n@@ -2134,6 +2158,9 @@ i[34567]86-*-mingw* | x86_64-*-mingw*)\n \tif test x$enable_threads = xposix ; then\n \t\ttm_file=\"${tm_file} i386/mingw-pthread.h\"\n \tfi\n+\tif test x$enable_threads = xmcf ; then\n+\t\ttm_file=\"${tm_file} i386/mingw-mcfgthread.h\"\n+\tfi\n \ttm_file=\"${tm_file} i386/mingw32.h\"\n \t# This makes the logic if mingw's or the w64 feature set has to be used\n \tcase ${target} in\n@@ -3679,6 +3706,10 @@ case ${target} in\n \tarch=znver3\n \tcpu=znver3\n \t;;\n+      znver4-*)\n+\tarch=znver4\n+\tcpu=znver4\n+\t;;\n       bdver4-*)\n         arch=bdver4\n         cpu=bdver4\n@@ -3807,6 +3838,10 @@ case ${target} in\n       znver3-*)\n \tarch=znver3\n \tcpu=znver3\n+\t;;\n+\t  znver4-*)\n+\tarch=znver4\n+\tcpu=znver4\n \t;;\n       bdver4-*)\n         arch=bdver4\n@@ -4150,14 +4185,6 @@ case \"${target}\" in\n \t\t\t  options_parsed=\"`$ac_cv_prog_CPP -D\"$opt_macro\" -x c \\\n \t\t\t\t${srcdir}/config/aarch64/aarch64-option-extensions.def`\"\n \n-\t\t\t  # Match one element inside AARCH64_OPT_EXTENSION, we\n-\t\t\t  # consume anything that's not a ,.\n-\t\t\t  elem=\"[ \t]*\\([^,]\\+\\)[ \t]*\"\n-\n-\t\t\t  # Repeat the pattern for the number of entries in the\n-\t\t\t  # AARCH64_OPT_EXTENSION, currently 6 times.\n-\t\t\t  sed_patt=\"^$elem,$elem,$elem,$elem,$elem,$elem\"\n-\n \t\t\t  while [ x\"$ext_val\" != x ]\n \t\t\t  do\n \t\t\t\text_val=`echo $ext_val | sed -e 's/\\+//'`\n@@ -4711,7 +4738,7 @@ case \"${target}\" in\n \t\t;;\n \n \tmips*-*-*)\n-\t\tsupported_defaults=\"abi arch arch_32 arch_64 float fpu nan fp_32 odd_spreg_32 tune tune_32 tune_64 divide llsc mips-plt synci lxc1-sxc1 madd4\"\n+\t\tsupported_defaults=\"abi arch arch_32 arch_64 float fpu nan fp_32 odd_spreg_32 tune tune_32 tune_64 divide llsc mips-plt synci lxc1-sxc1 madd4 compact-branches\"\n \n \t\tcase ${with_float} in\n \t\t\"\" | soft | hard)\n@@ -4864,6 +4891,15 @@ case \"${target}\" in\n \t\t\texit 1\n \t\t\t;;\n \t\tesac\n+\n+\t\tcase ${with_compact_branches} in\n+\t\t\"\" | never | always | optimal)\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"Unknown compact-branches policy used in --with-compact-branches\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n \t\t;;\n \n \tloongarch*-*-*)\n@@ -5573,6 +5609,15 @@ case \"${target}\" in\n \t\t;;\n esac\n \n+# VxWorks support for shared libraries has to be requested explicitly,\n+# so we can factor this part here:\n+\n+case \"${target}-${enable_shared}\" in\n+  *-*-vxworks*-yes)\n+    tmake_file=\"${tmake_file} t-slibgcc\"\n+    ;;\n+esac\n+\n # Targets for which there is at least one VxWorks port should include\n # vxworks-dummy.h to allow safe references to various TARGET_VXWORKS kinds\n # of markers from other files in the port, including the vxworks*.h files to\n@@ -5663,6 +5708,8 @@ case ${target} in\n \t\tesac\n \t\tif test x$with_arch != x; then\n \t\t\tdefault_mips_arch=$with_arch\n+\t\telse\n+\t\t\twith_arch=$default_mips_arch\n \t\tfi\n \t\tif test x$with_abi != x; then\n \t\t\tdefault_mips_abi=$with_abi\n@@ -5797,7 +5844,7 @@ case ${target} in\n esac\n \n t=\n-all_defaults=\"abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu nan fp_32 odd_spreg_32 divide llsc mips-plt synci tls lxc1-sxc1 madd4 isa_spec\"\n+all_defaults=\"abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu nan fp_32 odd_spreg_32 divide llsc mips-plt synci tls lxc1-sxc1 madd4 isa_spec compact-branches\"\n for option in $all_defaults\n do\n \teval \"val=\\$with_\"`echo $option | sed s/-/_/g`"}, {"sha": "38ef792bd67123a99eb13bef6e374e5d67d40966", "filename": "gcc/config.in", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1451,6 +1451,12 @@\n #endif\n \n \n+/* Define to 1 if you have the `getauxval' function. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_GETAUXVAL\n+#endif\n+\n+\n /* Define to 1 if you have the `getchar_unlocked' function. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_GETCHAR_UNLOCKED\n@@ -1939,6 +1945,12 @@\n #endif\n \n \n+/* Define to 1 if you have the <sys/auxv.h> header file. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_SYS_AUXV_H\n+#endif\n+\n+\n /* Define to 1 if you have the <sys/file.h> header file. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_SYS_FILE_H\n@@ -2312,6 +2324,12 @@\n #endif\n \n \n+/* Specify if mutliarch is enabled. */\n+#ifndef USED_FOR_TARGET\n+#undef ENABLE_MULTIARCH\n+#endif\n+\n+\n /* The size of `dev_t', as computed by sizeof. */\n #ifndef USED_FOR_TARGET\n #undef SIZEOF_DEV_T"}, {"sha": "5a9eff3364894e74dd3bf7c79ebf273b6520c754", "filename": "gcc/config/aarch64/aarch64-arches.def", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-arches.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-arches.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-arches.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -28,21 +28,21 @@\n    ARCH_REV is an integer specifying the architecture major revision.\n    FLAGS are the flags implied by the architecture.\n    Due to the assumptions about the positions of these fields in config.gcc,\n-   the NAME should be kept as the first argument and FLAGS as the last.  */\n-\n-AARCH64_ARCH(\"armv8-a\",\t      generic,\t     8A,\t8,  AARCH64_FL_FOR_ARCH8)\n-AARCH64_ARCH(\"armv8.1-a\",     generic,\t     8_1A,\t8,  AARCH64_FL_FOR_ARCH8_1)\n-AARCH64_ARCH(\"armv8.2-a\",     generic,\t     8_2A,\t8,  AARCH64_FL_FOR_ARCH8_2)\n-AARCH64_ARCH(\"armv8.3-a\",     generic,\t     8_3A,\t8,  AARCH64_FL_FOR_ARCH8_3)\n-AARCH64_ARCH(\"armv8.4-a\",     generic,\t     8_4A,\t8,  AARCH64_FL_FOR_ARCH8_4)\n-AARCH64_ARCH(\"armv8.5-a\",     generic,\t     8_5A,\t8,  AARCH64_FL_FOR_ARCH8_5)\n-AARCH64_ARCH(\"armv8.6-a\",     generic,\t     8_6A,\t8,  AARCH64_FL_FOR_ARCH8_6)\n-AARCH64_ARCH(\"armv8.7-a\",     generic,       8_7A,      8,  AARCH64_FL_FOR_ARCH8_7)\n-AARCH64_ARCH(\"armv8.8-a\",     generic,       8_8A,      8,  AARCH64_FL_FOR_ARCH8_8)\n-AARCH64_ARCH(\"armv8-r\",       generic,\t     8R  ,\t8,  AARCH64_FL_FOR_ARCH8_R)\n-AARCH64_ARCH(\"armv9-a\",       generic,\t     9A  ,\t9,  AARCH64_FL_FOR_ARCH9)\n-AARCH64_ARCH(\"armv9.1-a\",     generic,       9_1A,      9,  AARCH64_FL_FOR_ARCH9_1)\n-AARCH64_ARCH(\"armv9.2-a\",     generic,       9_2A,      9,  AARCH64_FL_FOR_ARCH9_2)\n-AARCH64_ARCH(\"armv9.3-a\",     generic,       9_3A,      9,  AARCH64_FL_FOR_ARCH9_3)\n+   NAME should be kept as the first argument.  */\n+\n+AARCH64_ARCH(\"armv8-a\",       generic,       V8A,       8,  (SIMD))\n+AARCH64_ARCH(\"armv8.1-a\",     generic,       V8_1A,     8,  (V8A, LSE, CRC, RDMA))\n+AARCH64_ARCH(\"armv8.2-a\",     generic,       V8_2A,     8,  (V8_1A))\n+AARCH64_ARCH(\"armv8.3-a\",     generic,       V8_3A,     8,  (V8_2A, PAUTH, RCPC))\n+AARCH64_ARCH(\"armv8.4-a\",     generic,       V8_4A,     8,  (V8_3A, F16FML, DOTPROD, FLAGM))\n+AARCH64_ARCH(\"armv8.5-a\",     generic,       V8_5A,     8,  (V8_4A, SB, SSBS, PREDRES))\n+AARCH64_ARCH(\"armv8.6-a\",     generic,       V8_6A,     8,  (V8_5A, I8MM, BF16))\n+AARCH64_ARCH(\"armv8.7-a\",     generic,       V8_7A,     8,  (V8_6A, LS64))\n+AARCH64_ARCH(\"armv8.8-a\",     generic,       V8_8A,     8,  (V8_7A, MOPS))\n+AARCH64_ARCH(\"armv8-r\",       generic,       V8R  ,     8,  (V8_4A))\n+AARCH64_ARCH(\"armv9-a\",       generic,       V9A  ,     9,  (V8_5A, SVE2))\n+AARCH64_ARCH(\"armv9.1-a\",     generic,       V9_1A,     9,  (V8_6A, V9A))\n+AARCH64_ARCH(\"armv9.2-a\",     generic,       V9_2A,     9,  (V8_7A, V9_1A))\n+AARCH64_ARCH(\"armv9.3-a\",     generic,       V9_3A,     9,  (V8_8A, V9_2A))\n \n #undef AARCH64_ARCH"}, {"sha": "b533082592822b002561192246d5500f11ecfe4c", "filename": "gcc/config/aarch64/aarch64-builtins.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -1549,20 +1549,20 @@ aarch64_scalar_builtin_type_p (aarch64_simd_type t)\n /* Enable AARCH64_FL_* flags EXTRA_FLAGS on top of the base Advanced SIMD\n    set.  */\n aarch64_simd_switcher::aarch64_simd_switcher (unsigned int extra_flags)\n-  : m_old_isa_flags (aarch64_isa_flags),\n+  : m_old_asm_isa_flags (aarch64_asm_isa_flags),\n     m_old_general_regs_only (TARGET_GENERAL_REGS_ONLY)\n {\n   /* Changing the ISA flags should be enough here.  We shouldn't need to\n      pay the compile-time cost of a full target switch.  */\n-  aarch64_isa_flags = AARCH64_FL_FP | AARCH64_FL_SIMD | extra_flags;\n   global_options.x_target_flags &= ~MASK_GENERAL_REGS_ONLY;\n+  aarch64_set_asm_isa_flags (AARCH64_FL_FP | AARCH64_FL_SIMD | extra_flags);\n }\n \n aarch64_simd_switcher::~aarch64_simd_switcher ()\n {\n   if (m_old_general_regs_only)\n     global_options.x_target_flags |= MASK_GENERAL_REGS_ONLY;\n-  aarch64_isa_flags = m_old_isa_flags;\n+  aarch64_set_asm_isa_flags (m_old_asm_isa_flags);\n }\n \n /* Implement #pragma GCC aarch64 \"arm_neon.h\"."}, {"sha": "e296c73350f1ec70f6017c11be54e0749bf114d5", "filename": "gcc/config/aarch64/aarch64-c.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -64,7 +64,7 @@ aarch64_define_unconditional_macros (cpp_reader *pfile)\n   builtin_define (\"__ARM_ARCH_8A\");\n \n   builtin_define_with_int_value (\"__ARM_ARCH_PROFILE\",\n-      AARCH64_ISA_V8_R ? 'R' : 'A');\n+      AARCH64_ISA_V8R ? 'R' : 'A');\n   builtin_define (\"__ARM_FEATURE_CLZ\");\n   builtin_define (\"__ARM_FEATURE_IDIV\");\n   builtin_define (\"__ARM_FEATURE_UNALIGNED\");\n@@ -82,7 +82,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)\n {\n   aarch64_def_or_undef (flag_unsafe_math_optimizations, \"__ARM_FP_FAST\", pfile);\n \n-  builtin_define_with_int_value (\"__ARM_ARCH\", AARCH64_ISA_V9 ? 9 : 8);\n+  builtin_define_with_int_value (\"__ARM_ARCH\", AARCH64_ISA_V9A ? 9 : 8);\n \n   builtin_define_with_int_value (\"__ARM_SIZEOF_MINIMAL_ENUM\",\n \t\t\t\t flag_short_enums ? 1 : 4);\n@@ -92,7 +92,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)\n \n   aarch64_def_or_undef (TARGET_FLOAT, \"__ARM_FEATURE_FMA\", pfile);\n \n-  if (TARGET_FLOAT || TARGET_SIMD)\n+  if (TARGET_FLOAT)\n     {\n       builtin_define_with_int_value (\"__ARM_FP\", 0x0E);\n       builtin_define (\"__ARM_FP16_FORMAT_IEEE\");\n@@ -202,6 +202,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)\n \t\t\t\"__ARM_FEATURE_BF16_SCALAR_ARITHMETIC\", pfile);\n   aarch64_def_or_undef (TARGET_LS64,\n \t\t\t\"__ARM_FEATURE_LS64\", pfile);\n+  aarch64_def_or_undef (AARCH64_ISA_RCPC, \"__ARM_FEATURE_RCPC\", pfile);\n \n   /* Not for ACLE, but required to keep \"float.h\" correct if we switch\n      target between implementations that do or do not support ARMv8.2-A"}, {"sha": "e9a4b622be018d92a790db10f4d5cf926bba512c", "filename": "gcc/config/aarch64/aarch64-cores.def", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -46,132 +46,132 @@\n /* ARMv8-A Architecture Processors.  */\n \n /* ARM ('A') cores. */\n-AARCH64_CORE(\"cortex-a34\",  cortexa34, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa35, 0x41, 0xd02, -1)\n-AARCH64_CORE(\"cortex-a35\",  cortexa35, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa35, 0x41, 0xd04, -1)\n-AARCH64_CORE(\"cortex-a53\",  cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53, 0x41, 0xd03, -1)\n-AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, 0x41, 0xd07, -1)\n-AARCH64_CORE(\"cortex-a72\",  cortexa72, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, 0x41, 0xd08, -1)\n-AARCH64_CORE(\"cortex-a73\",  cortexa73, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, 0x41, 0xd09, -1)\n+AARCH64_CORE(\"cortex-a34\",  cortexa34, cortexa53, V8A,  (CRC), cortexa35, 0x41, 0xd02, -1)\n+AARCH64_CORE(\"cortex-a35\",  cortexa35, cortexa53, V8A,  (CRC), cortexa35, 0x41, 0xd04, -1)\n+AARCH64_CORE(\"cortex-a53\",  cortexa53, cortexa53, V8A,  (CRC), cortexa53, 0x41, 0xd03, -1)\n+AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, V8A,  (CRC), cortexa57, 0x41, 0xd07, -1)\n+AARCH64_CORE(\"cortex-a72\",  cortexa72, cortexa57, V8A,  (CRC), cortexa72, 0x41, 0xd08, -1)\n+AARCH64_CORE(\"cortex-a73\",  cortexa73, cortexa57, V8A,  (CRC), cortexa73, 0x41, 0xd09, -1)\n \n /* Cavium ('C') cores. */\n-AARCH64_CORE(\"thunderx\",      thunderx,      thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a0, -1)\n+AARCH64_CORE(\"thunderx\",      thunderx,      thunderx,  V8A,  (CRC, CRYPTO), thunderx,  0x43, 0x0a0, -1)\n /* Do not swap around \"thunderxt88p1\" and \"thunderxt88\",\n    this order is required to handle variant correctly. */\n-AARCH64_CORE(\"thunderxt88p1\", thunderxt88p1, thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO,\tthunderxt88,  0x43, 0x0a1, 0)\n-AARCH64_CORE(\"thunderxt88\",   thunderxt88,   thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderxt88,  0x43, 0x0a1, -1)\n+AARCH64_CORE(\"thunderxt88p1\", thunderxt88p1, thunderx,  V8A,  (CRC, CRYPTO),\tthunderxt88,  0x43, 0x0a1, 0)\n+AARCH64_CORE(\"thunderxt88\",   thunderxt88,   thunderx,  V8A,  (CRC, CRYPTO), thunderxt88,  0x43, 0x0a1, -1)\n \n /* OcteonTX is the official name for T81/T83. */\n-AARCH64_CORE(\"octeontx\",      octeontx,      thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a0, -1)\n-AARCH64_CORE(\"octeontx81\",    octeontxt81,   thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a2, -1)\n-AARCH64_CORE(\"octeontx83\",    octeontxt83,   thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a3, -1)\n+AARCH64_CORE(\"octeontx\",      octeontx,      thunderx,  V8A,  (CRC, CRYPTO), thunderx,  0x43, 0x0a0, -1)\n+AARCH64_CORE(\"octeontx81\",    octeontxt81,   thunderx,  V8A,  (CRC, CRYPTO), thunderx,  0x43, 0x0a2, -1)\n+AARCH64_CORE(\"octeontx83\",    octeontxt83,   thunderx,  V8A,  (CRC, CRYPTO), thunderx,  0x43, 0x0a3, -1)\n \n-AARCH64_CORE(\"thunderxt81\",   thunderxt81,   thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a2, -1)\n-AARCH64_CORE(\"thunderxt83\",   thunderxt83,   thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a3, -1)\n+AARCH64_CORE(\"thunderxt81\",   thunderxt81,   thunderx,  V8A,  (CRC, CRYPTO), thunderx,  0x43, 0x0a2, -1)\n+AARCH64_CORE(\"thunderxt83\",   thunderxt83,   thunderx,  V8A,  (CRC, CRYPTO), thunderx,  0x43, 0x0a3, -1)\n \n /* Ampere Computing ('\\xC0') cores. */\n-AARCH64_CORE(\"ampere1\", ampere1, cortexa57, 8_6A, AARCH64_FL_FOR_ARCH8_6, ampere1, 0xC0, 0xac3, -1)\n+AARCH64_CORE(\"ampere1\", ampere1, cortexa57, V8_6A, (F16, RNG, AES, SHA3), ampere1, 0xC0, 0xac3, -1)\n /* Do not swap around \"emag\" and \"xgene1\",\n    this order is required to handle variant correctly. */\n-AARCH64_CORE(\"emag\",        emag,      xgene1,    8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, emag, 0x50, 0x000, 3)\n+AARCH64_CORE(\"emag\",        emag,      xgene1,    V8A,  (CRC, CRYPTO), emag, 0x50, 0x000, 3)\n \n /* APM ('P') cores. */\n-AARCH64_CORE(\"xgene1\",      xgene1,    xgene1,    8A,  AARCH64_FL_FOR_ARCH8, xgene1, 0x50, 0x000, -1)\n+AARCH64_CORE(\"xgene1\",      xgene1,    xgene1,    V8A,  (), xgene1, 0x50, 0x000, -1)\n \n /* Qualcomm ('Q') cores. */\n-AARCH64_CORE(\"falkor\",      falkor,    falkor,    8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO | AARCH64_FL_RDMA, qdf24xx,   0x51, 0xC00, -1)\n-AARCH64_CORE(\"qdf24xx\",     qdf24xx,   falkor,    8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO | AARCH64_FL_RDMA, qdf24xx,   0x51, 0xC00, -1)\n+AARCH64_CORE(\"falkor\",      falkor,    falkor,    V8A,  (CRC, CRYPTO, RDMA), qdf24xx,   0x51, 0xC00, -1)\n+AARCH64_CORE(\"qdf24xx\",     qdf24xx,   falkor,    V8A,  (CRC, CRYPTO, RDMA), qdf24xx,   0x51, 0xC00, -1)\n \n /* Samsung ('S') cores. */\n-AARCH64_CORE(\"exynos-m1\",   exynosm1,  exynosm1,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, exynosm1,  0x53, 0x001, -1)\n+AARCH64_CORE(\"exynos-m1\",   exynosm1,  exynosm1,  V8A,  (CRC, CRYPTO), exynosm1,  0x53, 0x001, -1)\n \n /* HXT ('h') cores. */\n-AARCH64_CORE(\"phecda\",      phecda,    falkor,    8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, qdf24xx,   0x68, 0x000, -1)\n+AARCH64_CORE(\"phecda\",      phecda,    falkor,    V8A,  (CRC, CRYPTO), qdf24xx,   0x68, 0x000, -1)\n \n /* ARMv8.1-A Architecture Processors.  */\n \n /* Broadcom ('B') cores. */\n-AARCH64_CORE(\"thunderx2t99p1\",  thunderx2t99p1, thunderx2t99, 8_1A,  AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_CRYPTO, thunderx2t99, 0x42, 0x516, -1)\n-AARCH64_CORE(\"vulcan\",  vulcan, thunderx2t99, 8_1A,  AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_CRYPTO, thunderx2t99, 0x42, 0x516, -1)\n+AARCH64_CORE(\"thunderx2t99p1\",  thunderx2t99p1, thunderx2t99, V8_1A,  (CRYPTO), thunderx2t99, 0x42, 0x516, -1)\n+AARCH64_CORE(\"vulcan\",  vulcan, thunderx2t99, V8_1A,  (CRYPTO), thunderx2t99, 0x42, 0x516, -1)\n \n /* Cavium ('C') cores. */\n-AARCH64_CORE(\"thunderx2t99\",  thunderx2t99,  thunderx2t99, 8_1A,  AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_CRYPTO, thunderx2t99, 0x43, 0x0af, -1)\n+AARCH64_CORE(\"thunderx2t99\",  thunderx2t99,  thunderx2t99, V8_1A,  (CRYPTO), thunderx2t99, 0x43, 0x0af, -1)\n \n /* ARMv8.2-A Architecture Processors.  */\n \n /* ARM ('A') cores. */\n-AARCH64_CORE(\"cortex-a55\",  cortexa55, cortexa53, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD, cortexa53, 0x41, 0xd05, -1)\n-AARCH64_CORE(\"cortex-a75\",  cortexa75, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD, cortexa73, 0x41, 0xd0a, -1)\n-AARCH64_CORE(\"cortex-a76\",  cortexa76, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD, neoversen1, 0x41, 0xd0b, -1)\n-AARCH64_CORE(\"cortex-a76ae\",  cortexa76ae, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS, neoversen1, 0x41, 0xd0e, -1)\n-AARCH64_CORE(\"cortex-a77\",  cortexa77, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS, neoversen1, 0x41, 0xd0d, -1)\n-AARCH64_CORE(\"cortex-a78\",  cortexa78, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS | AARCH64_FL_PROFILE, neoversen1, 0x41, 0xd41, -1)\n-AARCH64_CORE(\"cortex-a78ae\",  cortexa78ae, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS | AARCH64_FL_PROFILE, neoversen1, 0x41, 0xd42, -1)\n-AARCH64_CORE(\"cortex-a78c\",  cortexa78c, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS | AARCH64_FL_PROFILE | AARCH64_FL_FLAGM | AARCH64_FL_PAUTH, neoversen1, 0x41, 0xd4b, -1)\n-AARCH64_CORE(\"cortex-a65\",  cortexa65, cortexa53, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS, cortexa73, 0x41, 0xd06, -1)\n-AARCH64_CORE(\"cortex-a65ae\",  cortexa65ae, cortexa53, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS, cortexa73, 0x41, 0xd43, -1)\n-AARCH64_CORE(\"cortex-x1\",  cortexx1, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS | AARCH64_FL_PROFILE, neoversen1, 0x41, 0xd44, -1)\n-AARCH64_CORE(\"ares\",  ares, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_PROFILE, neoversen1, 0x41, 0xd0c, -1)\n-AARCH64_CORE(\"neoverse-n1\",  neoversen1, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_PROFILE, neoversen1, 0x41, 0xd0c, -1)\n-AARCH64_CORE(\"neoverse-e1\",  neoversee1, cortexa53, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS, cortexa73, 0x41, 0xd4a, -1)\n+AARCH64_CORE(\"cortex-a55\",  cortexa55, cortexa53, V8_2A,  (F16, RCPC, DOTPROD), cortexa53, 0x41, 0xd05, -1)\n+AARCH64_CORE(\"cortex-a75\",  cortexa75, cortexa57, V8_2A,  (F16, RCPC, DOTPROD), cortexa73, 0x41, 0xd0a, -1)\n+AARCH64_CORE(\"cortex-a76\",  cortexa76, cortexa57, V8_2A,  (F16, RCPC, DOTPROD), neoversen1, 0x41, 0xd0b, -1)\n+AARCH64_CORE(\"cortex-a76ae\",  cortexa76ae, cortexa57, V8_2A,  (F16, RCPC, DOTPROD, SSBS), neoversen1, 0x41, 0xd0e, -1)\n+AARCH64_CORE(\"cortex-a77\",  cortexa77, cortexa57, V8_2A,  (F16, RCPC, DOTPROD, SSBS), neoversen1, 0x41, 0xd0d, -1)\n+AARCH64_CORE(\"cortex-a78\",  cortexa78, cortexa57, V8_2A,  (F16, RCPC, DOTPROD, SSBS, PROFILE), neoversen1, 0x41, 0xd41, -1)\n+AARCH64_CORE(\"cortex-a78ae\",  cortexa78ae, cortexa57, V8_2A,  (F16, RCPC, DOTPROD, SSBS, PROFILE), neoversen1, 0x41, 0xd42, -1)\n+AARCH64_CORE(\"cortex-a78c\",  cortexa78c, cortexa57, V8_2A,  (F16, RCPC, DOTPROD, SSBS, PROFILE, FLAGM, PAUTH), neoversen1, 0x41, 0xd4b, -1)\n+AARCH64_CORE(\"cortex-a65\",  cortexa65, cortexa53, V8_2A,  (F16, RCPC, DOTPROD, SSBS), cortexa73, 0x41, 0xd06, -1)\n+AARCH64_CORE(\"cortex-a65ae\",  cortexa65ae, cortexa53, V8_2A,  (F16, RCPC, DOTPROD, SSBS), cortexa73, 0x41, 0xd43, -1)\n+AARCH64_CORE(\"cortex-x1\",  cortexx1, cortexa57, V8_2A,  (F16, RCPC, DOTPROD, SSBS, PROFILE), neoversen1, 0x41, 0xd44, -1)\n+AARCH64_CORE(\"ares\",  ares, cortexa57, V8_2A,  (F16, RCPC, DOTPROD, PROFILE), neoversen1, 0x41, 0xd0c, -1)\n+AARCH64_CORE(\"neoverse-n1\",  neoversen1, cortexa57, V8_2A,  (F16, RCPC, DOTPROD, PROFILE), neoversen1, 0x41, 0xd0c, -1)\n+AARCH64_CORE(\"neoverse-e1\",  neoversee1, cortexa53, V8_2A,  (F16, RCPC, DOTPROD, SSBS), cortexa73, 0x41, 0xd4a, -1)\n \n /* Cavium ('C') cores. */\n-AARCH64_CORE(\"octeontx2\",      octeontx2,      cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_PROFILE, cortexa57, 0x43, 0x0b0, -1)\n-AARCH64_CORE(\"octeontx2t98\",   octeontx2t98,   cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_PROFILE, cortexa57, 0x43, 0x0b1, -1)\n-AARCH64_CORE(\"octeontx2t96\",   octeontx2t96,   cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_PROFILE, cortexa57, 0x43, 0x0b2, -1)\n+AARCH64_CORE(\"octeontx2\",      octeontx2,      cortexa57, V8_2A,  (CRYPTO, PROFILE), cortexa57, 0x43, 0x0b0, -1)\n+AARCH64_CORE(\"octeontx2t98\",   octeontx2t98,   cortexa57, V8_2A,  (CRYPTO, PROFILE), cortexa57, 0x43, 0x0b1, -1)\n+AARCH64_CORE(\"octeontx2t96\",   octeontx2t96,   cortexa57, V8_2A,  (CRYPTO, PROFILE), cortexa57, 0x43, 0x0b2, -1)\n /* Note OcteonTX2 T93 is an alias to OcteonTX2 T96. */\n-AARCH64_CORE(\"octeontx2t93\",   octeontx2t93,   cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_PROFILE, cortexa57, 0x43, 0x0b2, -1)\n-AARCH64_CORE(\"octeontx2f95\",   octeontx2f95,   cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_PROFILE, cortexa57, 0x43, 0x0b3, -1)\n-AARCH64_CORE(\"octeontx2f95n\",  octeontx2f95n,  cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_PROFILE, cortexa57, 0x43, 0x0b4, -1)\n-AARCH64_CORE(\"octeontx2f95mm\", octeontx2f95mm, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_PROFILE, cortexa57, 0x43, 0x0b5, -1)\n+AARCH64_CORE(\"octeontx2t93\",   octeontx2t93,   cortexa57, V8_2A,  (CRYPTO, PROFILE), cortexa57, 0x43, 0x0b2, -1)\n+AARCH64_CORE(\"octeontx2f95\",   octeontx2f95,   cortexa57, V8_2A,  (CRYPTO, PROFILE), cortexa57, 0x43, 0x0b3, -1)\n+AARCH64_CORE(\"octeontx2f95n\",  octeontx2f95n,  cortexa57, V8_2A,  (CRYPTO, PROFILE), cortexa57, 0x43, 0x0b4, -1)\n+AARCH64_CORE(\"octeontx2f95mm\", octeontx2f95mm, cortexa57, V8_2A,  (CRYPTO, PROFILE), cortexa57, 0x43, 0x0b5, -1)\n \n /* Fujitsu ('F') cores. */\n-AARCH64_CORE(\"a64fx\", a64fx, a64fx, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_SVE, a64fx, 0x46, 0x001, -1)\n+AARCH64_CORE(\"a64fx\", a64fx, a64fx, V8_2A,  (F16, SVE), a64fx, 0x46, 0x001, -1)\n \n /* HiSilicon ('H') cores. */\n-AARCH64_CORE(\"tsv110\",  tsv110, tsv110, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2, tsv110,   0x48, 0xd01, -1)\n+AARCH64_CORE(\"tsv110\",  tsv110, tsv110, V8_2A,  (CRYPTO, F16), tsv110,   0x48, 0xd01, -1)\n \n /* ARMv8.3-A Architecture Processors.  */\n \n /* Marvell cores (TX3). */\n-AARCH64_CORE(\"thunderx3t110\",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC | AARCH64_FL_SM4 | AARCH64_FL_SHA3 | AARCH64_FL_F16FML | AARCH64_FL_RCPC8_4, thunderx3t110, 0x43, 0x0b8, 0x0a)\n+AARCH64_CORE(\"thunderx3t110\",  thunderx3t110,  thunderx3t110, V8_3A,  (CRYPTO, SM4, SHA3, F16FML), thunderx3t110, 0x43, 0x0b8, 0x0a)\n \n /* ARMv8.4-A Architecture Processors.  */\n \n /* Arm ('A') cores.  */\n-AARCH64_CORE(\"zeus\", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)\n-AARCH64_CORE(\"neoverse-v1\", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)\n-AARCH64_CORE(\"neoverse-512tvb\", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoverse512tvb, INVALID_IMP, INVALID_CORE, -1)\n+AARCH64_CORE(\"zeus\", zeus, cortexa57, V8_4A,  (SVE, I8MM, BF16, PROFILE, SSBS, RNG), neoversev1, 0x41, 0xd40, -1)\n+AARCH64_CORE(\"neoverse-v1\", neoversev1, cortexa57, V8_4A,  (SVE, I8MM, BF16, PROFILE, SSBS, RNG), neoversev1, 0x41, 0xd40, -1)\n+AARCH64_CORE(\"neoverse-512tvb\", neoverse512tvb, cortexa57, V8_4A,  (SVE, I8MM, BF16, PROFILE, SSBS, RNG), neoverse512tvb, INVALID_IMP, INVALID_CORE, -1)\n \n /* Qualcomm ('Q') cores. */\n-AARCH64_CORE(\"saphira\",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)\n+AARCH64_CORE(\"saphira\",     saphira,    saphira,    V8_4A,  (CRYPTO), saphira,   0x51, 0xC01, -1)\n \n /* ARMv8-A big.LITTLE implementations.  */\n \n-AARCH64_CORE(\"cortex-a57.cortex-a53\",  cortexa57cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, 0x41, AARCH64_BIG_LITTLE (0xd07, 0xd03), -1)\n-AARCH64_CORE(\"cortex-a72.cortex-a53\",  cortexa72cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, 0x41, AARCH64_BIG_LITTLE (0xd08, 0xd03), -1)\n-AARCH64_CORE(\"cortex-a73.cortex-a35\",  cortexa73cortexa35, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, 0x41, AARCH64_BIG_LITTLE (0xd09, 0xd04), -1)\n-AARCH64_CORE(\"cortex-a73.cortex-a53\",  cortexa73cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, 0x41, AARCH64_BIG_LITTLE (0xd09, 0xd03), -1)\n+AARCH64_CORE(\"cortex-a57.cortex-a53\",  cortexa57cortexa53, cortexa53, V8A,  (CRC), cortexa57, 0x41, AARCH64_BIG_LITTLE (0xd07, 0xd03), -1)\n+AARCH64_CORE(\"cortex-a72.cortex-a53\",  cortexa72cortexa53, cortexa53, V8A,  (CRC), cortexa72, 0x41, AARCH64_BIG_LITTLE (0xd08, 0xd03), -1)\n+AARCH64_CORE(\"cortex-a73.cortex-a35\",  cortexa73cortexa35, cortexa53, V8A,  (CRC), cortexa73, 0x41, AARCH64_BIG_LITTLE (0xd09, 0xd04), -1)\n+AARCH64_CORE(\"cortex-a73.cortex-a53\",  cortexa73cortexa53, cortexa53, V8A,  (CRC), cortexa73, 0x41, AARCH64_BIG_LITTLE (0xd09, 0xd03), -1)\n \n /* ARM DynamIQ big.LITTLE configurations.  */\n \n-AARCH64_CORE(\"cortex-a75.cortex-a55\",  cortexa75cortexa55, cortexa53, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD, cortexa73, 0x41, AARCH64_BIG_LITTLE (0xd0a, 0xd05), -1)\n-AARCH64_CORE(\"cortex-a76.cortex-a55\",  cortexa76cortexa55, cortexa53, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD, neoversen1, 0x41, AARCH64_BIG_LITTLE (0xd0b, 0xd05), -1)\n+AARCH64_CORE(\"cortex-a75.cortex-a55\",  cortexa75cortexa55, cortexa53, V8_2A,  (F16, RCPC, DOTPROD), cortexa73, 0x41, AARCH64_BIG_LITTLE (0xd0a, 0xd05), -1)\n+AARCH64_CORE(\"cortex-a76.cortex-a55\",  cortexa76cortexa55, cortexa53, V8_2A,  (F16, RCPC, DOTPROD), neoversen1, 0x41, AARCH64_BIG_LITTLE (0xd0b, 0xd05), -1)\n \n /* Armv8-R Architecture Processors.  */\n-AARCH64_CORE(\"cortex-r82\", cortexr82, cortexa53, 8R, AARCH64_FL_FOR_ARCH8_R, cortexa53, 0x41, 0xd15, -1)\n+AARCH64_CORE(\"cortex-r82\", cortexr82, cortexa53, V8R, (), cortexa53, 0x41, 0xd15, -1)\n \n /* Armv9.0-A Architecture Processors.  */\n \n /* Arm ('A') cores. */\n-AARCH64_CORE(\"cortex-a510\",  cortexa510, cortexa55, 9A,  AARCH64_FL_FOR_ARCH9 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_MEMTAG | AARCH64_FL_I8MM | AARCH64_FL_BF16, cortexa53, 0x41, 0xd46, -1)\n+AARCH64_CORE(\"cortex-a510\",  cortexa510, cortexa55, V9A,  (SVE2_BITPERM, MEMTAG, I8MM, BF16), cortexa53, 0x41, 0xd46, -1)\n \n-AARCH64_CORE(\"cortex-a710\",  cortexa710, cortexa57, 9A,  AARCH64_FL_FOR_ARCH9 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_MEMTAG | AARCH64_FL_I8MM | AARCH64_FL_BF16, neoversen2, 0x41, 0xd47, -1)\n+AARCH64_CORE(\"cortex-a710\",  cortexa710, cortexa57, V9A,  (SVE2_BITPERM, MEMTAG, I8MM, BF16), neoversen2, 0x41, 0xd47, -1)\n \n-AARCH64_CORE(\"cortex-x2\",  cortexx2, cortexa57, 9A,  AARCH64_FL_FOR_ARCH9 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_MEMTAG | AARCH64_FL_I8MM | AARCH64_FL_BF16, neoversen2, 0x41, 0xd48, -1)\n+AARCH64_CORE(\"cortex-x2\",  cortexx2, cortexa57, V9A,  (SVE2_BITPERM, MEMTAG, I8MM, BF16), neoversen2, 0x41, 0xd48, -1)\n \n-AARCH64_CORE(\"neoverse-n2\", neoversen2, cortexa57, 9A, AARCH64_FL_FOR_ARCH9 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG | AARCH64_FL_PROFILE, neoversen2, 0x41, 0xd49, -1)\n+AARCH64_CORE(\"neoverse-n2\", neoversen2, cortexa57, V9A, (I8MM, BF16, SVE2_BITPERM, RNG, MEMTAG, PROFILE), neoversen2, 0x41, 0xd49, -1)\n \n-AARCH64_CORE(\"demeter\", demeter, cortexa57, 9A, AARCH64_FL_FOR_ARCH9 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG | AARCH64_FL_PROFILE, neoversev2, 0x41, 0xd4f, -1)\n-AARCH64_CORE(\"neoverse-v2\", neoversev2, cortexa57, 9A, AARCH64_FL_FOR_ARCH9 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG | AARCH64_FL_PROFILE, neoversev2, 0x41, 0xd4f, -1)\n+AARCH64_CORE(\"demeter\", demeter, cortexa57, V9A, (I8MM, BF16, SVE2_BITPERM, RNG, MEMTAG, PROFILE), neoversev2, 0x41, 0xd4f, -1)\n+AARCH64_CORE(\"neoverse-v2\", neoversev2, cortexa57, V9A, (I8MM, BF16, SVE2_BITPERM, RNG, MEMTAG, PROFILE), neoversev2, 0x41, 0xd4f, -1)\n \n #undef AARCH64_CORE"}, {"sha": "3e33cb2ce8467754cfc4a4a34e9d08f54adc2c73", "filename": "gcc/config/aarch64/aarch64-feature-deps.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-feature-deps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-feature-deps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-feature-deps.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -0,0 +1,121 @@\n+/* Feature dependency helpers for AArch64.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef AARCH64_FEATURE_DEPS_H\n+#define AARCH64_FEATURE_DEPS_H 1\n+\n+namespace {\n+namespace feature_deps {\n+\n+/* Together, these definitions of get_flags take a list of\n+   feature names (representing functions that are defined below)\n+   and return the set of associated flags.  */\n+constexpr aarch64_feature_flags get_flags () { return 0; }\n+\n+template<typename T1, typename ...Ts>\n+constexpr aarch64_feature_flags\n+get_flags (T1 i, Ts... args)\n+{\n+  return i ().flag | get_flags (args...);\n+}\n+\n+/* Like get_flags, but return the transitive closure of those features\n+   and the ones that they rely on.  */\n+constexpr aarch64_feature_flags get_enable () { return 0; }\n+\n+template<typename T1, typename ...Ts>\n+constexpr aarch64_feature_flags\n+get_enable (T1 i, Ts... args)\n+{\n+  return i ().enable | get_enable (args...);\n+}\n+\n+/* Define info<FEATURE> such that it has the following static constant\n+   variables:\n+\n+   - flag: the aarch64_feature_flags bit associated with FEATURE\n+\n+   - enable: the transitive closure of the features that FEATURE requires,\n+     plus FLAG itself\n+\n+   - explicit_on: the transitive closure of the features that an\n+     explicit +FEATURE enables, including FLAG itself.  This is\n+     always a superset of ENABLE\n+\n+   Also define a function FEATURE () that returns an info<FEATURE>\n+   (which is an empty structure, since all members are static).\n+\n+   Building up the list feature-by-feature ensures that the definition\n+   files are in topological order.  */\n+template<aarch64_feature> struct info;\n+\n+#define HANDLE(IDENT, REQUIRES, EXPLICIT_ON)\t\t\t\t\\\n+  template<> struct info<aarch64_feature::IDENT> {\t\t\t\\\n+    static constexpr auto flag = AARCH64_FL_##IDENT;\t\t\t\\\n+    static constexpr auto enable = flag | get_enable REQUIRES;\t\t\\\n+    static constexpr auto explicit_on = enable | get_enable EXPLICIT_ON; \\\n+  };\t\t\t\t\t\t\t\t\t\\\n+  constexpr info<aarch64_feature::IDENT> IDENT ()\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return info<aarch64_feature::IDENT> ();\t\t\t\t\\\n+  }\n+#define AARCH64_OPT_EXTENSION(A, IDENT, REQUIRES, EXPLICIT_ON, E, F) \\\n+  HANDLE (IDENT, REQUIRES, EXPLICIT_ON)\n+#define AARCH64_ARCH(A, B, IDENT, D, REQUIRES) HANDLE (IDENT, REQUIRES, ())\n+#include \"config/aarch64/aarch64-option-extensions.def\"\n+#include \"config/aarch64/aarch64-arches.def\"\n+#undef HANDLE\n+\n+/* Return the set of all features that would need to be disabled if\n+   the features in MASK are disabled.\n+\n+   Note that the size of the expression varies linearly with the number\n+   of features, which means that invoking this function once per feature\n+   is quadratic in the number of features.  However, collecting the same\n+   information at compiler start-up is likely to be quadratic too, so\n+   we're better off paying the cost once per compiler build rather than\n+   once per compiler run.  */\n+constexpr aarch64_feature_flags\n+get_flags_off (aarch64_feature_flags mask)\n+{\n+  return (0\n+#define AARCH64_OPT_EXTENSION(A, IDENT, C, D, E, F) \\\n+\t  | (feature_deps::IDENT ().enable & mask ? AARCH64_FL_##IDENT : 0)\n+#include \"config/aarch64/aarch64-option-extensions.def\"\n+\t  );\n+}\n+\n+/* Define root_off_<IDENT> variables for each feature, giving the set of\n+   features that must be turned off by +noIDENT.  This set is not transitively\n+   closed; use get_flags_off to complete the closure.  */\n+#define AARCH64_OPT_EXTENSION(A, IDENT, C, D, EXPLICIT_OFF, F) \\\n+  constexpr auto root_off_##IDENT \\\n+    = AARCH64_FL_##IDENT | get_flags EXPLICIT_OFF;\n+#include \"config/aarch64/aarch64-option-extensions.def\"\n+\n+/* Define cpu_<NAME> variables for each CPU, giving the transitive\n+   closure of all the features that the CPU supports.  */\n+#define AARCH64_CORE(A, CORE_IDENT, C, ARCH_IDENT, FEATURES, F, G, H, I) \\\n+  constexpr auto cpu_##CORE_IDENT = ARCH_IDENT ().enable | get_enable FEATURES;\n+#include \"config/aarch64/aarch64-cores.def\"\n+\n+}\n+}\n+\n+#endif"}, {"sha": "0fd4c32ad0bd09f8651d1b8a77378fa4504ff488", "filename": "gcc/config/aarch64/aarch64-modes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -35,6 +35,7 @@ CC_MODE (CCFPE);\n CC_MODE (CC_SWP);\n CC_MODE (CC_NZC);   /* Only N, Z and C bits of condition flags are valid.\n \t\t       (Used with SVE predicate tests.)  */\n+CC_MODE (CC_NZV);   /* Only N, Z and V bits of condition flags are valid.  */\n CC_MODE (CC_NZ);    /* Only N and Z bits of condition flags are valid.  */\n CC_MODE (CC_Z);     /* Only Z bit of condition flags is valid.  */\n CC_MODE (CC_C);     /* C represents unsigned overflow of a simple addition.  */"}, {"sha": "bdf4baf309c02a08f74eec7b9cb77bc1f3247de3", "filename": "gcc/config/aarch64/aarch64-option-extensions.def", "status": "modified", "additions": 116, "deletions": 205, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -21,23 +21,34 @@\n \n    Before using #include to read this file, define a macro:\n \n-      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF,\n-\t\t\t    SYNTHETIC, FEATURE_STRING)\n-\n-   - EXT_NAME is the name of the extension, represented as a string constant.\n-   - FLAGS_CANONICAL is the canonical internal name for this flag.\n-   - FLAGS_ON are the bitwise-or of the features that enabling the extension\n-     adds, or zero if enabling this extension has no effect on other features.\n-   - FLAGS_OFF are the bitwise-or of the features that disabling the extension\n-     removes, or zero if disabling this extension has no effect on other\n-     features.\n-   - SYNTHETIC is a boolean to indicate whether the option is a purely synthetic\n-     grouping of options and that the option itself has no feature bit (e.g.\n-     crypto).  This is used to determine when sum of the individual options in\n-     FLAGS_ON can be replaced by FLAG_CANONICAL in options minimization.  If the\n-     group is synthetic then they can be replaced when all options in FLAGS_ON\n-     are enabled, otherwise they can only be replaced when\n-     FLAGS_ON | FLAG_CANONICAL are enabled.\n+      AARCH64_OPT_EXTENSION(NAME, IDENT, REQUIRES, EXPLICIT_ON,\n+\t\t\t    EXPLICIT_OFF, FEATURE_STRING)\n+\n+   - NAME is the name of the extension, represented as a string constant.\n+\n+   - IDENT is the canonical internal name for this flag.\n+\n+   - REQUIRES is a list of features that must be enabled whenever this\n+     feature is enabled.  The relationship is implicitly transitive:\n+     if A appears in B's REQUIRES and B appears in C's REQUIRES then\n+     A and B must be enabled whenever C is.  Thus, turning on C also\n+     turns on A and B, while turning off A or B also turns off C.\n+\n+   - EXPLICIT_ON is a list of features that are enabled by an explicit\n+     +NAME specification, in addition to those listed in REQUIRES.\n+     Usually this is an empty list; comments below explain the exceptions.\n+     The list is implicitly transitively closed wrt REQUIRES (but *not*\n+     to EXPLICIT_ON, since NAME is the only thing explicit in +NAME).\n+     Thus if A is in B's REQUIRES and B is in C's EXPLICIT_ON, +C will\n+     enable both B and A.  B's EXPLICIT_ON has no effect on +C.\n+\n+   - EXPLICIT_OFF is a list of features that are disabled by an explicit\n+     +noNAME specification, in addition to the features that are transitively\n+     dependent on NAME (according to REQUIRES).  As with EXPLICIT_ON,\n+     this is usually an empty list; comments below explain the exceptions.\n+     If a feature A appears in this list then the list implicitly includes\n+     any features that are transitively dependent on A (according to REQUIRES).\n+\n    - FEAT_STRING is a string containing the entries in the 'Features' field of\n      /proc/cpuinfo on a GNU/Linux system that correspond to this architecture\n      extension being available.  Sometimes multiple entries are needed to enable\n@@ -47,195 +58,95 @@\n      that are required.  Their order is not important.  An empty string means\n      do not detect this feature during auto detection.\n \n-     NOTE: Any changes to the AARCH64_OPT_EXTENSION macro need to be mirrored in\n-     config.gcc.  */\n-\n-/* Enabling \"fp\" just enables \"fp\".\n-   Disabling \"fp\" also disables \"simd\", \"crypto\", \"fp16\", \"aes\", \"sha2\",\n-   \"sha3\", sm3/sm4, \"sve\", \"sve2\", \"sve2-aes\", \"sve2-sha3\", \"sve2-sm4\",\n-   \"sve2-bitperm\", \"i8mm\", \"f32mm\", \"f64mm\", and \"bf16\".  */\n-AARCH64_OPT_EXTENSION(\"fp\", AARCH64_FL_FP, 0, AARCH64_FL_SIMD | \\\n-\t\t      AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_AES | \\\n-\t\t      AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | AARCH64_FL_SM4 | \\\n-\t\t      AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_SVE2_AES | \\\n-\t\t      AARCH64_FL_SVE2_SHA3 | AARCH64_FL_SVE2_SM4 | \\\n-\t\t      AARCH64_FL_SVE2_BITPERM | AARCH64_FL_I8MM | \\\n-\t\t      AARCH64_FL_F32MM | AARCH64_FL_F64MM | AARCH64_FL_BF16,\n-\t\t       false, \"fp\")\n-\n-/* Enabling \"simd\" also enables \"fp\".\n-   Disabling \"simd\" also disables \"crypto\", \"dotprod\", \"aes\", \"sha2\", \"sha3\",\n-   \"sm3/sm4\", \"sve\", \"sve2\", \"sve2-aes\", \"sve2-sha3\", \"sve2-sm4\",\n-   \"sve2-bitperm\", \"i8mm\", \"f32mm\" and \"f64mm\".  */\n-AARCH64_OPT_EXTENSION(\"simd\", AARCH64_FL_SIMD, AARCH64_FL_FP, \\\n-\t\t      AARCH64_FL_CRYPTO | AARCH64_FL_DOTPROD | \\\n-\t\t      AARCH64_FL_AES | AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | \\\n-\t\t      AARCH64_FL_SM4 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | \\\n-\t\t      AARCH64_FL_SVE2_AES | AARCH64_FL_SVE2_SHA3 | \\\n-\t\t      AARCH64_FL_SVE2_SM4 | AARCH64_FL_SVE2_BITPERM | \\\n-\t\t      AARCH64_FL_I8MM | AARCH64_FL_F32MM | AARCH64_FL_F64MM, \\\n-\t\t      false, \"asimd\")\n-\n-/* Enabling \"crypto\" also enables \"fp\", \"simd\", \"aes\" and \"sha2\".\n-   Disabling \"crypto\" disables \"crypto\", \"aes\", \"sha2\", \"sha3\" and \"sm3/sm4\",\n-   \"sve2-aes\", \"sve2-sha3\", \"sve2-sm4\".  */\n-AARCH64_OPT_EXTENSION(\"crypto\", AARCH64_FL_CRYPTO, AARCH64_FL_FP | \\\n-\t\t      AARCH64_FL_SIMD | AARCH64_FL_AES | AARCH64_FL_SHA2, \\\n-\t\t      AARCH64_FL_AES | AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | \\\n-\t\t      AARCH64_FL_SM4 | AARCH64_FL_SVE2_AES | \\\n-\t\t      AARCH64_FL_SVE2_SHA3 | AARCH64_FL_SVE2_SM4, true, \\\n+   The list of features must follow topological order wrt REQUIRES\n+   and EXPLICIT_ON.  For example, if A is in B's REQUIRES list, A must\n+   come before B.  This is enforced by aarch64-feature-deps.h.\n+\n+   NOTE: Any changes to the AARCH64_OPT_EXTENSION macro need to be mirrored in\n+   config.gcc.  */\n+\n+AARCH64_OPT_EXTENSION(\"fp\", FP, (), (), (), \"fp\")\n+\n+AARCH64_OPT_EXTENSION(\"simd\", SIMD, (FP), (), (), \"asimd\")\n+\n+AARCH64_OPT_EXTENSION(\"crc\", CRC, (), (), (), \"crc32\")\n+\n+AARCH64_OPT_EXTENSION(\"lse\", LSE, (), (), (), \"atomics\")\n+\n+/* +nofp16 disables an implicit F16FML, even though an implicit F16FML\n+   does not imply F16.  See F16FML for more details.  */\n+AARCH64_OPT_EXTENSION(\"fp16\", F16, (FP), (), (F16FML), \"fphp asimdhp\")\n+\n+AARCH64_OPT_EXTENSION(\"rcpc\", RCPC, (), (), (), \"lrcpc\")\n+\n+/* An explicit +rdma implies +simd, but +rdma+nosimd still enables scalar\n+   RDMA instructions.  */\n+AARCH64_OPT_EXTENSION(\"rdma\", RDMA, (), (SIMD), (), \"asimdrdm\")\n+\n+AARCH64_OPT_EXTENSION(\"dotprod\", DOTPROD, (SIMD), (), (), \"asimddp\")\n+\n+AARCH64_OPT_EXTENSION(\"aes\", AES, (SIMD), (), (), \"aes\")\n+\n+AARCH64_OPT_EXTENSION(\"sha2\", SHA2, (SIMD), (), (), \"sha1 sha2\")\n+\n+/* +nocrypto disables AES, SHA2 and SM4, and anything that depends on them\n+   (such as SHA3 and the SVE2 crypto extensions).  */\n+AARCH64_OPT_EXTENSION(\"crypto\", CRYPTO, (AES, SHA2), (), (AES, SHA2, SM4),\n \t\t      \"aes pmull sha1 sha2\")\n \n-/* Enabling or disabling \"crc\" only changes \"crc\".  */\n-AARCH64_OPT_EXTENSION(\"crc\", AARCH64_FL_CRC, 0, 0, false, \"crc32\")\n-\n-/* Enabling or disabling \"lse\" only changes \"lse\".  */\n-AARCH64_OPT_EXTENSION(\"lse\", AARCH64_FL_LSE, 0, 0, false, \"atomics\")\n-\n-/* Enabling \"fp16\" also enables \"fp\".\n-   Disabling \"fp16\" disables \"fp16\", \"fp16fml\", \"sve\", \"sve2\",\n-   \"sve2-aes\", \"sve2-sha3\", \"sve2-sm4\", \"sve2-bitperm\", \"f32mm\" and\n-    \"f64mm\".  */\n-AARCH64_OPT_EXTENSION(\"fp16\", AARCH64_FL_F16, AARCH64_FL_FP, \\\n-\t\t      AARCH64_FL_F16FML | AARCH64_FL_SVE | AARCH64_FL_F32MM | \\\n-\t\t      AARCH64_FL_F64MM | AARCH64_FL_SVE2 | \\\n-\t\t      AARCH64_FL_SVE2_AES | AARCH64_FL_SVE2_SHA3 | \\\n-\t\t      AARCH64_FL_SVE2_SM4 | AARCH64_FL_SVE2_BITPERM, false, \\\n-\t\t      \"fphp asimdhp\")\n-\n-/* Enabling or disabling \"rcpc\" only changes \"rcpc\".  */\n-AARCH64_OPT_EXTENSION(\"rcpc\", AARCH64_FL_RCPC, 0, 0, false, \"lrcpc\")\n-\n-/* Enabling \"rdma\" also enables \"fp\", \"simd\".\n-   Disabling \"rdma\" just disables \"rdma\".  */\n-AARCH64_OPT_EXTENSION(\"rdma\", AARCH64_FL_RDMA, \\\n-\t\t      AARCH64_FL_FP | AARCH64_FL_SIMD, 0, false, \"asimdrdm\")\n-\n-/* Enabling \"dotprod\" also enables \"simd\".\n-   Disabling \"dotprod\" only disables \"dotprod\".  */\n-AARCH64_OPT_EXTENSION(\"dotprod\", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, \\\n-\t\t      false, \"asimddp\")\n-\n-/* Enabling \"aes\" also enables \"simd\".\n-   Disabling \"aes\" disables \"aes\" and \"sve2-aes'.  */\n-AARCH64_OPT_EXTENSION(\"aes\", AARCH64_FL_AES, AARCH64_FL_SIMD, \\\n-\t\t      AARCH64_FL_SVE2_AES, false, \"aes\")\n-\n-/* Enabling \"sha2\" also enables \"simd\".\n-   Disabling \"sha2\" just disables \"sha2\".  */\n-AARCH64_OPT_EXTENSION(\"sha2\", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, false, \\\n-\t\t      \"sha1 sha2\")\n-\n-/* Enabling \"sha3\" enables \"simd\" and \"sha2\".\n-   Disabling \"sha3\" disables \"sha3\" and \"sve2-sha3\".  */\n-AARCH64_OPT_EXTENSION(\"sha3\", AARCH64_FL_SHA3, AARCH64_FL_SIMD | \\\n-\t\t      AARCH64_FL_SHA2, AARCH64_FL_SVE2_SHA3, false, \\\n-\t\t      \"sha3 sha512\")\n-\n-/* Enabling \"sm4\" also enables \"simd\".\n-   Disabling \"sm4\" disables \"sm4\" and \"sve2-sm4\".  */\n-AARCH64_OPT_EXTENSION(\"sm4\", AARCH64_FL_SM4, AARCH64_FL_SIMD, \\\n-\t\t      AARCH64_FL_SVE2_SM4, false, \"sm3 sm4\")\n-\n-/* Enabling \"fp16fml\" also enables \"fp\" and \"fp16\".\n-   Disabling \"fp16fml\" just disables \"fp16fml\".  */\n-AARCH64_OPT_EXTENSION(\"fp16fml\", AARCH64_FL_F16FML, \\\n-\t\t      AARCH64_FL_FP | AARCH64_FL_F16, 0, false, \"asimdfhm\")\n-\n-/* Enabling \"sve\" also enables \"fp16\", \"fp\" and \"simd\".\n-   Disabling \"sve\" disables \"sve\", \"f32mm\", \"f64mm\", \"sve2\", \"sve2-aes\",\n-   \"sve2-sha3\", \"sve2-sm4\" and \"sve2-bitperm\".  */\n-AARCH64_OPT_EXTENSION(\"sve\", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | \\\n-\t\t      AARCH64_FL_F16, AARCH64_FL_F32MM | AARCH64_FL_F64MM | \\\n-\t\t      AARCH64_FL_SVE2 | AARCH64_FL_SVE2_AES | \\\n-\t\t      AARCH64_FL_SVE2_SHA3 | AARCH64_FL_SVE2_SM4 | \\\n-\t\t      AARCH64_FL_SVE2_BITPERM, false, \"sve\")\n-\n-/* Enabling/Disabling \"profile\" does not enable/disable any other feature.  */\n-AARCH64_OPT_EXTENSION(\"profile\", AARCH64_FL_PROFILE, 0, 0, false, \"\")\n-\n-/* Enabling/Disabling \"rng\" only changes \"rng\".  */\n-AARCH64_OPT_EXTENSION(\"rng\", AARCH64_FL_RNG, 0, 0, false, \"rng\")\n-\n-/* Enabling/Disabling \"memtag\" only changes \"memtag\".  */\n-AARCH64_OPT_EXTENSION(\"memtag\", AARCH64_FL_MEMTAG, 0, 0, false, \"\")\n-\n-/* Enabling/Disabling \"sb\" only changes \"sb\".  */\n-AARCH64_OPT_EXTENSION(\"sb\", AARCH64_FL_SB, 0, 0, false, \"sb\")\n-\n-/* Enabling/Disabling \"ssbs\" only changes \"ssbs\".  */\n-AARCH64_OPT_EXTENSION(\"ssbs\", AARCH64_FL_SSBS, 0, 0, false, \"ssbs\")\n-\n-/* Enabling/Disabling \"predres\" only changes \"predres\".  */\n-AARCH64_OPT_EXTENSION(\"predres\", AARCH64_FL_PREDRES, 0, 0, false, \"\")\n-\n-/* Enabling \"sve2\" also enables \"sve\", \"fp16\", \"fp\", and \"simd\".\n-   Disabling \"sve2\" disables \"sve2\", \"sve2-aes\", \"sve2-sha3\", \"sve2-sm4\", and\n-   \"sve2-bitperm\".  */\n-AARCH64_OPT_EXTENSION(\"sve2\", AARCH64_FL_SVE2, AARCH64_FL_SVE | \\\n-\t\t      AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_F16, \\\n-\t\t      AARCH64_FL_SVE2_AES | AARCH64_FL_SVE2_SHA3 | \\\n-\t\t      AARCH64_FL_SVE2_SM4 | AARCH64_FL_SVE2_BITPERM, false, \"sve2\")\n-\n-/* Enabling \"sve2-sm4\" also enables \"sm4\", \"simd\", \"fp16\", \"fp\", \"sve\", and\n-   \"sve2\". Disabling \"sve2-sm4\" just disables \"sve2-sm4\".  */\n-AARCH64_OPT_EXTENSION(\"sve2-sm4\", AARCH64_FL_SVE2_SM4, AARCH64_FL_SM4 | \\\n-\t\t      AARCH64_FL_SIMD | AARCH64_FL_F16 | AARCH64_FL_FP | \\\n-\t\t      AARCH64_FL_SVE | AARCH64_FL_SVE2, 0, false, \"svesm4\")\n-\n-/* Enabling \"sve2-aes\" also enables \"aes\", \"simd\", \"fp16\", \"fp\", \"sve\", and\n-   \"sve2\". Disabling \"sve2-aes\" just disables \"sve2-aes\".  */\n-AARCH64_OPT_EXTENSION(\"sve2-aes\", AARCH64_FL_SVE2_AES, AARCH64_FL_AES | \\\n-\t\t      AARCH64_FL_SIMD | AARCH64_FL_F16 | AARCH64_FL_FP | \\\n-\t\t      AARCH64_FL_SVE | AARCH64_FL_SVE2, 0, false, \"sveaes\")\n-\n-/* Enabling \"sve2-sha3\" also enables \"sha3\", \"simd\", \"fp16\", \"fp\", \"sve\", and\n-   \"sve2\". Disabling \"sve2-sha3\" just disables \"sve2-sha3\".  */\n-AARCH64_OPT_EXTENSION(\"sve2-sha3\", AARCH64_FL_SVE2_SHA3, AARCH64_FL_SHA3 | \\\n-\t\t      AARCH64_FL_SIMD | AARCH64_FL_F16 | AARCH64_FL_FP | \\\n-\t\t      AARCH64_FL_SVE | AARCH64_FL_SVE2, 0, false, \"svesha3\")\n-\n-/* Enabling \"sve2-bitperm\" also enables \"simd\", \"fp16\", \"fp\", \"sve\", and\n-   \"sve2\".  Disabling \"sve2-bitperm\" just disables \"sve2-bitperm\".  */\n-AARCH64_OPT_EXTENSION(\"sve2-bitperm\", AARCH64_FL_SVE2_BITPERM, AARCH64_FL_SIMD | \\\n-\t\t      AARCH64_FL_F16 | AARCH64_FL_FP | AARCH64_FL_SVE | \\\n-\t\t      AARCH64_FL_SVE2, 0, false, \"svebitperm\")\n-\n-/* Enabling or disabling \"tme\" only changes \"tme\".  */\n-AARCH64_OPT_EXTENSION(\"tme\", AARCH64_FL_TME, 0, 0, false, \"\")\n-\n-/* Enabling \"i8mm\" also enables \"simd\" and \"fp\".\n-   Disabling \"i8mm\" only disables \"i8mm\".  */\n-AARCH64_OPT_EXTENSION(\"i8mm\", AARCH64_FL_I8MM, \\\n-\t\t      AARCH64_FL_SIMD | AARCH64_FL_FP, 0, false, \"i8mm\")\n-\n-/* Enabling \"f32mm\" also enables \"sve\", \"fp16\", \"fp\", and \"simd\".\n-   Disabling \"f32mm\" only disables \"f32mm\".  */\n-AARCH64_OPT_EXTENSION(\"f32mm\", AARCH64_FL_F32MM, \\\n-\t\t      AARCH64_FL_SVE | AARCH64_FL_F16 | AARCH64_FL_FP | \\\n-\t\t      AARCH64_FL_SIMD, 0, false, \"f32mm\")\n-\n-/* Enabling \"f64mm\" also enables \"sve\", \"fp16\", \"fp\", and \"simd\".\n-   Disabling \"f64mm\" only disables \"f64mm\".  */\n-AARCH64_OPT_EXTENSION(\"f64mm\", AARCH64_FL_F64MM, \\\n-\t\t      AARCH64_FL_SVE | AARCH64_FL_F16 | AARCH64_FL_FP | \\\n-\t\t      AARCH64_FL_SIMD, 0, false, \"f64mm\")\n-\n-/* Enabling \"bf16\" also enables \"simd\" and \"fp\".\n-   Disabling \"bf16\" only disables \"bf16\".  */\n-AARCH64_OPT_EXTENSION(\"bf16\", AARCH64_FL_BF16, \\\n-\t\t      AARCH64_FL_SIMD | AARCH64_FL_FP, 0, false, \"bf16\")\n-\n-/* Enabling/Disabling \"flagm\" only changes \"flagm\".  */\n-AARCH64_OPT_EXTENSION(\"flagm\", AARCH64_FL_FLAGM, 0, 0, false, \"flagm\")\n-\n-/* Enabling/Disabling \"pauth\" only changes \"pauth\".  */\n-AARCH64_OPT_EXTENSION(\"pauth\", AARCH64_FL_PAUTH, 0, 0, false, \"paca pacg\")\n-\n-/* Enabling/Disabling \"ls64\" only changes \"ls64\".  */\n-AARCH64_OPT_EXTENSION(\"ls64\", AARCH64_FL_LS64, 0, 0, false, \"\")\n-\n-/* Enabling/disabling \"mops\" only changes \"mops\".  */\n-AARCH64_OPT_EXTENSION(\"mops\", AARCH64_FL_MOPS, 0, 0, false, \"\")\n+AARCH64_OPT_EXTENSION(\"sha3\", SHA3, (SHA2), (), (), \"sha3 sha512\")\n+\n+AARCH64_OPT_EXTENSION(\"sm4\", SM4, (SIMD), (), (), \"sm3 sm4\")\n+\n+/* An explicit +fp16fml implies +fp16, but a dependence on it does not.\n+   Thus -march=armv8.4-a implies F16FML but not F16.  -march=armv8.4-a+fp16\n+   and -march=armv8.4-a+fp16fml are equivalent and enable both F16FML and F16.\n+   -march=armv8.4-a+nofp16+fp16 enables F16 but not F16FML.  */\n+AARCH64_OPT_EXTENSION(\"fp16fml\", F16FML, (), (F16), (), \"asimdfhm\")\n+\n+AARCH64_OPT_EXTENSION(\"sve\", SVE, (SIMD, F16), (), (), \"sve\")\n+\n+AARCH64_OPT_EXTENSION(\"profile\", PROFILE, (), (), (), \"\")\n+\n+AARCH64_OPT_EXTENSION(\"rng\", RNG, (), (), (), \"rng\")\n+\n+AARCH64_OPT_EXTENSION(\"memtag\", MEMTAG, (), (), (), \"\")\n+\n+AARCH64_OPT_EXTENSION(\"sb\", SB, (), (), (), \"sb\")\n+\n+AARCH64_OPT_EXTENSION(\"ssbs\", SSBS, (), (), (), \"ssbs\")\n+\n+AARCH64_OPT_EXTENSION(\"predres\", PREDRES, (), (), (), \"\")\n+\n+AARCH64_OPT_EXTENSION(\"sve2\", SVE2, (SVE), (), (), \"sve2\")\n+\n+AARCH64_OPT_EXTENSION(\"sve2-sm4\", SVE2_SM4, (SVE2, SM4), (), (), \"svesm4\")\n+\n+AARCH64_OPT_EXTENSION(\"sve2-aes\", SVE2_AES, (SVE2, AES), (), (), \"sveaes\")\n+\n+AARCH64_OPT_EXTENSION(\"sve2-sha3\", SVE2_SHA3, (SVE2, SHA3), (), (), \"svesha3\")\n+\n+AARCH64_OPT_EXTENSION(\"sve2-bitperm\", SVE2_BITPERM, (SVE2), (), (),\n+\t\t      \"svebitperm\")\n+\n+AARCH64_OPT_EXTENSION(\"tme\", TME, (), (), (), \"\")\n+\n+AARCH64_OPT_EXTENSION(\"i8mm\", I8MM, (SIMD), (), (), \"i8mm\")\n+\n+AARCH64_OPT_EXTENSION(\"f32mm\", F32MM, (SVE), (), (), \"f32mm\")\n+\n+AARCH64_OPT_EXTENSION(\"f64mm\", F64MM, (SVE), (), (), \"f64mm\")\n+\n+/* An explicit +bf16 implies +simd, but +bf16+nosimd still enables scalar BF16\n+   instructions.  */\n+AARCH64_OPT_EXTENSION(\"bf16\", BF16, (FP), (SIMD), (), \"bf16\")\n+\n+AARCH64_OPT_EXTENSION(\"flagm\", FLAGM, (), (), (), \"flagm\")\n+\n+AARCH64_OPT_EXTENSION(\"pauth\", PAUTH, (), (), (), \"paca pacg\")\n+\n+AARCH64_OPT_EXTENSION(\"ls64\", LS64, (), (), (), \"\")\n+\n+AARCH64_OPT_EXTENSION(\"mops\", MOPS, (), (), (), \"\")\n \n #undef AARCH64_OPT_EXTENSION"}, {"sha": "ba23c90c411a4e6c909089ad503eff7e34566ec9", "filename": "gcc/config/aarch64/aarch64-opts.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -22,6 +22,10 @@\n #ifndef GCC_AARCH64_OPTS_H\n #define GCC_AARCH64_OPTS_H\n \n+#ifndef USED_FOR_TARGET\n+typedef uint64_t aarch64_feature_flags;\n+#endif\n+\n /* The various cores that implement AArch64.  */\n enum aarch64_processor\n {"}, {"sha": "238820581c5ee7617f8eed1df2cf5418b1127e19", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -254,7 +254,7 @@ typedef struct simd_vec_cost advsimd_vec_cost;\n /* SVE-specific extensions to the information provided by simd_vec_cost.  */\n struct sve_vec_cost : simd_vec_cost\n {\n-  constexpr sve_vec_cost (const simd_vec_cost &base,\n+  CONSTEXPR sve_vec_cost (const simd_vec_cost &base,\n \t\t\t  unsigned int clast_cost,\n \t\t\t  unsigned int fadda_f16_cost,\n \t\t\t  unsigned int fadda_f32_cost,\n@@ -354,7 +354,7 @@ using aarch64_scalar_vec_issue_info = aarch64_base_vec_issue_info;\n    Advanced SIMD and SVE.  */\n struct aarch64_simd_vec_issue_info : aarch64_base_vec_issue_info\n {\n-  constexpr aarch64_simd_vec_issue_info (aarch64_base_vec_issue_info base,\n+  CONSTEXPR aarch64_simd_vec_issue_info (aarch64_base_vec_issue_info base,\n \t\t\t\t\t unsigned int ld2_st2_general_ops,\n \t\t\t\t\t unsigned int ld3_st3_general_ops,\n \t\t\t\t\t unsigned int ld4_st4_general_ops)\n@@ -382,7 +382,7 @@ using aarch64_advsimd_vec_issue_info = aarch64_simd_vec_issue_info;\n    is a concept of \"predicate operations\".  */\n struct aarch64_sve_vec_issue_info : aarch64_simd_vec_issue_info\n {\n-  constexpr aarch64_sve_vec_issue_info\n+  CONSTEXPR aarch64_sve_vec_issue_info\n     (aarch64_simd_vec_issue_info base,\n      unsigned int pred_ops_per_cycle,\n      unsigned int while_pred_ops,\n@@ -747,7 +747,7 @@ class aarch64_simd_switcher\n   ~aarch64_simd_switcher ();\n \n private:\n-  unsigned long m_old_isa_flags;\n+  unsigned long m_old_asm_isa_flags;\n   bool m_old_general_regs_only;\n };\n \n@@ -1029,15 +1029,19 @@ extern bool aarch64_classify_address (struct aarch64_address_info *, rtx,\n \t\t\t\t      machine_mode, bool,\n \t\t\t\t      aarch64_addr_query_type = ADDR_QUERY_M);\n \n+void aarch64_set_asm_isa_flags (aarch64_feature_flags);\n+\n /* Defined in common/config/aarch64-common.cc.  */\n+void aarch64_set_asm_isa_flags (gcc_options *, aarch64_feature_flags);\n bool aarch64_handle_option (struct gcc_options *, struct gcc_options *,\n \t\t\t     const struct cl_decoded_option *, location_t);\n const char *aarch64_rewrite_selected_cpu (const char *name);\n enum aarch64_parse_opt_result aarch64_parse_extension (const char *,\n-\t\t\t\t\t\t       uint64_t *,\n+\t\t\t\t\t\t       aarch64_feature_flags *,\n \t\t\t\t\t\t       std::string *);\n void aarch64_get_all_extension_candidates (auto_vec<const char *> *candidates);\n-std::string aarch64_get_extension_string_for_isa_flags (uint64_t, uint64_t);\n+std::string aarch64_get_extension_string_for_isa_flags (aarch64_feature_flags,\n+\t\t\t\t\t\t\taarch64_feature_flags);\n \n rtl_opt_pass *make_pass_fma_steering (gcc::context *);\n rtl_opt_pass *make_pass_track_speculation (gcc::context *);"}, {"sha": "5386043739a9b2e328bfb2fc9067da8feeac1a92", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -716,7 +716,7 @@\n   [(match_operand:VHSDF 0 \"register_operand\")\n    (match_operand:VHSDF 1 \"register_operand\")\n    (match_operand:VHSDF 2 \"register_operand\")]\n-  \"TARGET_FLOAT && TARGET_SIMD\"\n+  \"TARGET_SIMD\"\n {\n   rtx v_bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);\n   int bits = GET_MODE_UNIT_BITSIZE (<MODE>mode) - 1;\n@@ -8097,7 +8097,7 @@\n \t\t (match_operand:V16QI 1 \"register_operand\" \"%0\")\n \t\t (match_operand:V16QI 2 \"register_operand\" \"w\"))]\n          CRYPTO_AES))]\n-  \"TARGET_SIMD && TARGET_AES\"\n+  \"TARGET_AES\"\n   \"aes<aes_op>\\\\t%0.16b, %2.16b\"\n   [(set_attr \"type\" \"crypto_aese\")]\n )\n@@ -8106,7 +8106,7 @@\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=w\")\n \t(unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"w\")]\n \t CRYPTO_AESMC))]\n-  \"TARGET_SIMD && TARGET_AES\"\n+  \"TARGET_AES\"\n   \"aes<aesmc_op>\\\\t%0.16b, %1.16b\"\n   [(set_attr \"type\" \"crypto_aesmc\")]\n )\n@@ -8125,7 +8125,7 @@\n \t\t(match_operand:V16QI 2 \"register_operand\" \"w\"))]\n \t     UNSPEC_AESE)]\n \tUNSPEC_AESMC))]\n-  \"TARGET_SIMD && TARGET_AES\n+  \"TARGET_AES\n    && aarch64_fusion_enabled_p (AARCH64_FUSE_AES_AESMC)\"\n   \"aese\\\\t%0.16b, %2.16b\\;aesmc\\\\t%0.16b, %0.16b\"\n   [(set_attr \"type\" \"crypto_aese\")\n@@ -8146,7 +8146,7 @@\n \t\t\t(match_operand:V16QI 2 \"register_operand\" \"w\"))]\n \t\tUNSPEC_AESD)]\n \t  UNSPEC_AESIMC))]\n-  \"TARGET_SIMD && TARGET_AES\n+  \"TARGET_AES\n    && aarch64_fusion_enabled_p (AARCH64_FUSE_AES_AESMC)\"\n   \"aesd\\\\t%0.16b, %2.16b\\;aesimc\\\\t%0.16b, %0.16b\"\n   [(set_attr \"type\" \"crypto_aese\")\n@@ -8160,7 +8160,7 @@\n         (unspec:SI [(match_operand:SI 1\n                        \"register_operand\" \"w\")]\n          UNSPEC_SHA1H))]\n-  \"TARGET_SIMD && TARGET_SHA2\"\n+  \"TARGET_SHA2\"\n   \"sha1h\\\\t%s0, %s1\"\n   [(set_attr \"type\" \"crypto_sha1_fast\")]\n )\n@@ -8170,7 +8170,7 @@\n \t(unspec:SI [(vec_select:SI (match_operand:V4SI 1 \"register_operand\" \"w\")\n \t\t     (parallel [(const_int 0)]))]\n \t UNSPEC_SHA1H))]\n-  \"TARGET_SIMD && TARGET_SHA2 && !BYTES_BIG_ENDIAN\"\n+  \"TARGET_SHA2 && !BYTES_BIG_ENDIAN\"\n   \"sha1h\\\\t%s0, %s1\"\n   [(set_attr \"type\" \"crypto_sha1_fast\")]\n )\n@@ -8180,7 +8180,7 @@\n \t(unspec:SI [(vec_select:SI (match_operand:V4SI 1 \"register_operand\" \"w\")\n \t\t     (parallel [(const_int 3)]))]\n \t UNSPEC_SHA1H))]\n-  \"TARGET_SIMD && TARGET_SHA2 && BYTES_BIG_ENDIAN\"\n+  \"TARGET_SHA2 && BYTES_BIG_ENDIAN\"\n   \"sha1h\\\\t%s0, %s1\"\n   [(set_attr \"type\" \"crypto_sha1_fast\")]\n )\n@@ -8190,7 +8190,7 @@\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"0\")\n                       (match_operand:V4SI 2 \"register_operand\" \"w\")]\n          UNSPEC_SHA1SU1))]\n-  \"TARGET_SIMD && TARGET_SHA2\"\n+  \"TARGET_SHA2\"\n   \"sha1su1\\\\t%0.4s, %2.4s\"\n   [(set_attr \"type\" \"crypto_sha1_fast\")]\n )\n@@ -8201,7 +8201,7 @@\n                       (match_operand:SI 2 \"register_operand\" \"w\")\n                       (match_operand:V4SI 3 \"register_operand\" \"w\")]\n          CRYPTO_SHA1))]\n-  \"TARGET_SIMD && TARGET_SHA2\"\n+  \"TARGET_SHA2\"\n   \"sha1<sha1_op>\\\\t%q0, %s2, %3.4s\"\n   [(set_attr \"type\" \"crypto_sha1_slow\")]\n )\n@@ -8212,7 +8212,7 @@\n                       (match_operand:V4SI 2 \"register_operand\" \"w\")\n                       (match_operand:V4SI 3 \"register_operand\" \"w\")]\n          UNSPEC_SHA1SU0))]\n-  \"TARGET_SIMD && TARGET_SHA2\"\n+  \"TARGET_SHA2\"\n   \"sha1su0\\\\t%0.4s, %2.4s, %3.4s\"\n   [(set_attr \"type\" \"crypto_sha1_xor\")]\n )\n@@ -8225,7 +8225,7 @@\n                       (match_operand:V4SI 2 \"register_operand\" \"w\")\n                       (match_operand:V4SI 3 \"register_operand\" \"w\")]\n          CRYPTO_SHA256))]\n-  \"TARGET_SIMD && TARGET_SHA2\"\n+  \"TARGET_SHA2\"\n   \"sha256h<sha256_op>\\\\t%q0, %q2, %3.4s\"\n   [(set_attr \"type\" \"crypto_sha256_slow\")]\n )\n@@ -8235,7 +8235,7 @@\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"0\")\n                       (match_operand:V4SI 2 \"register_operand\" \"w\")]\n          UNSPEC_SHA256SU0))]\n-  \"TARGET_SIMD && TARGET_SHA2\"\n+  \"TARGET_SHA2\"\n   \"sha256su0\\\\t%0.4s, %2.4s\"\n   [(set_attr \"type\" \"crypto_sha256_fast\")]\n )\n@@ -8246,7 +8246,7 @@\n                       (match_operand:V4SI 2 \"register_operand\" \"w\")\n                       (match_operand:V4SI 3 \"register_operand\" \"w\")]\n          UNSPEC_SHA256SU1))]\n-  \"TARGET_SIMD && TARGET_SHA2\"\n+  \"TARGET_SHA2\"\n   \"sha256su1\\\\t%0.4s, %2.4s, %3.4s\"\n   [(set_attr \"type\" \"crypto_sha256_slow\")]\n )\n@@ -8259,7 +8259,7 @@\n                       (match_operand:V2DI 2 \"register_operand\" \"w\")\n                       (match_operand:V2DI 3 \"register_operand\" \"w\")]\n          CRYPTO_SHA512))]\n-  \"TARGET_SIMD && TARGET_SHA3\"\n+  \"TARGET_SHA3\"\n   \"sha512h<sha512_op>\\\\t%q0, %q2, %3.2d\"\n   [(set_attr \"type\" \"crypto_sha512\")]\n )\n@@ -8269,7 +8269,7 @@\n         (unspec:V2DI [(match_operand:V2DI 1 \"register_operand\" \"0\")\n                       (match_operand:V2DI 2 \"register_operand\" \"w\")]\n          UNSPEC_SHA512SU0))]\n-  \"TARGET_SIMD && TARGET_SHA3\"\n+  \"TARGET_SHA3\"\n   \"sha512su0\\\\t%0.2d, %2.2d\"\n   [(set_attr \"type\" \"crypto_sha512\")]\n )\n@@ -8280,7 +8280,7 @@\n                       (match_operand:V2DI 2 \"register_operand\" \"w\")\n                       (match_operand:V2DI 3 \"register_operand\" \"w\")]\n          UNSPEC_SHA512SU1))]\n-  \"TARGET_SIMD && TARGET_SHA3\"\n+  \"TARGET_SHA3\"\n   \"sha512su1\\\\t%0.2d, %2.2d, %3.2d\"\n   [(set_attr \"type\" \"crypto_sha512\")]\n )\n@@ -8294,7 +8294,7 @@\n \t  (match_operand:VQ_I 2 \"register_operand\" \"w\")\n \t  (match_operand:VQ_I 3 \"register_operand\" \"w\"))\n \t (match_operand:VQ_I 1 \"register_operand\" \"w\")))]\n-  \"TARGET_SIMD && TARGET_SHA3\"\n+  \"TARGET_SHA3\"\n   \"eor3\\\\t%0.16b, %1.16b, %2.16b, %3.16b\"\n   [(set_attr \"type\" \"crypto_sha3\")]\n )\n@@ -8306,7 +8306,7 @@\n \t  (match_operand:V2DI 2 \"register_operand\" \"w\")\n \t  (const_int 1))\n \t (match_operand:V2DI 1 \"register_operand\" \"w\")))]\n-  \"TARGET_SIMD && TARGET_SHA3\"\n+  \"TARGET_SHA3\"\n   \"rax1\\\\t%0.2d, %1.2d, %2.2d\"\n   [(set_attr \"type\" \"crypto_sha3\")]\n )\n@@ -8318,7 +8318,7 @@\n \t  (match_operand:V2DI 1 \"register_operand\" \"%w\")\n \t  (match_operand:V2DI 2 \"register_operand\" \"w\"))\n \t (match_operand:SI 3 \"aarch64_simd_shift_imm_di\" \"Usd\")))]\n-  \"TARGET_SIMD && TARGET_SHA3\"\n+  \"TARGET_SHA3\"\n   \"xar\\\\t%0.2d, %1.2d, %2.2d, %3\"\n   [(set_attr \"type\" \"crypto_sha3\")]\n )\n@@ -8330,7 +8330,7 @@\n \t  (not:VQ_I (match_operand:VQ_I 3 \"register_operand\" \"w\"))\n \t  (match_operand:VQ_I 2 \"register_operand\" \"w\"))\n \t (match_operand:VQ_I 1 \"register_operand\" \"w\")))]\n-  \"TARGET_SIMD && TARGET_SHA3\"\n+  \"TARGET_SHA3\"\n   \"bcax\\\\t%0.16b, %1.16b, %2.16b, %3.16b\"\n   [(set_attr \"type\" \"crypto_sha3\")]\n )\n@@ -8343,7 +8343,7 @@\n \t\t      (match_operand:V4SI 2 \"register_operand\" \"w\")\n \t\t      (match_operand:V4SI 3 \"register_operand\" \"w\")]\n \t UNSPEC_SM3SS1))]\n-  \"TARGET_SIMD && TARGET_SM4\"\n+  \"TARGET_SM4\"\n   \"sm3ss1\\\\t%0.4s, %1.4s, %2.4s, %3.4s\"\n   [(set_attr \"type\" \"crypto_sm3\")]\n )\n@@ -8356,7 +8356,7 @@\n \t\t      (match_operand:V4SI 3 \"register_operand\" \"w\")\n \t\t      (match_operand:SI 4 \"aarch64_imm2\" \"Ui2\")]\n \t CRYPTO_SM3TT))]\n-  \"TARGET_SIMD && TARGET_SM4\"\n+  \"TARGET_SM4\"\n   \"sm3tt<sm3tt_op>\\\\t%0.4s, %2.4s, %3.4s[%4]\"\n   [(set_attr \"type\" \"crypto_sm3\")]\n )\n@@ -8367,7 +8367,7 @@\n \t\t      (match_operand:V4SI 2 \"register_operand\" \"w\")\n \t\t      (match_operand:V4SI 3 \"register_operand\" \"w\")]\n \t CRYPTO_SM3PART))]\n-  \"TARGET_SIMD && TARGET_SM4\"\n+  \"TARGET_SM4\"\n   \"sm3partw<sm3part_op>\\\\t%0.4s, %2.4s, %3.4s\"\n   [(set_attr \"type\" \"crypto_sm3\")]\n )\n@@ -8379,7 +8379,7 @@\n \t(unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"0\")\n \t\t      (match_operand:V4SI 2 \"register_operand\" \"w\")]\n \t UNSPEC_SM4E))]\n-  \"TARGET_SIMD && TARGET_SM4\"\n+  \"TARGET_SM4\"\n   \"sm4e\\\\t%0.4s, %2.4s\"\n   [(set_attr \"type\" \"crypto_sm4\")]\n )\n@@ -8389,7 +8389,7 @@\n \t(unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"w\")\n \t\t      (match_operand:V4SI 2 \"register_operand\" \"w\")]\n \t UNSPEC_SM4EKEY))]\n-  \"TARGET_SIMD && TARGET_SM4\"\n+  \"TARGET_SM4\"\n   \"sm4ekey\\\\t%0.4s, %1.4s, %2.4s\"\n   [(set_attr \"type\" \"crypto_sm4\")]\n )\n@@ -8975,7 +8975,7 @@\n         (unspec:TI  [(match_operand:DI 1 \"register_operand\" \"w\")\n \t\t     (match_operand:DI 2 \"register_operand\" \"w\")]\n \t\t    UNSPEC_PMULL))]\n- \"TARGET_SIMD && TARGET_AES\"\n+ \"TARGET_AES\"\n  \"pmull\\\\t%0.1q, %1.1d, %2.1d\"\n   [(set_attr \"type\" \"crypto_pmull\")]\n )\n@@ -8985,7 +8985,7 @@\n        (unspec:TI [(match_operand:V2DI 1 \"register_operand\" \"w\")\n \t\t   (match_operand:V2DI 2 \"register_operand\" \"w\")]\n \t\t  UNSPEC_PMULL2))]\n-  \"TARGET_SIMD && TARGET_AES\"\n+  \"TARGET_AES\"\n   \"pmull2\\\\t%0.1q, %1.2d, %2.2d\"\n   [(set_attr \"type\" \"crypto_pmull\")]\n )"}, {"sha": "6347407555fef985263e92f2d57b38928f43e400", "filename": "gcc/config/aarch64/aarch64-sve-builtins-base.cc", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -517,9 +517,7 @@ class svcnt_bhwd_impl : public function_base\n   gimple *\n   fold (gimple_folder &f) const override\n   {\n-    tree count = build_int_cstu (TREE_TYPE (f.lhs),\n-\t\t\t\t GET_MODE_NUNITS (m_ref_mode));\n-    return gimple_build_assign (f.lhs, count);\n+    return f.fold_to_cstu (GET_MODE_NUNITS (m_ref_mode));\n   }\n \n   rtx\n@@ -536,8 +534,7 @@ class svcnt_bhwd_impl : public function_base\n class svcnt_bhwd_pat_impl : public svcnt_bhwd_impl\n {\n public:\n-  CONSTEXPR svcnt_bhwd_pat_impl (machine_mode ref_mode)\n-    : svcnt_bhwd_impl (ref_mode) {}\n+  using svcnt_bhwd_impl::svcnt_bhwd_impl;\n \n   gimple *\n   fold (gimple_folder &f) const override\n@@ -554,10 +551,7 @@ class svcnt_bhwd_pat_impl : public svcnt_bhwd_impl\n     unsigned int elements_per_vq = 128 / GET_MODE_UNIT_BITSIZE (m_ref_mode);\n     HOST_WIDE_INT value = aarch64_fold_sve_cnt_pat (pattern, elements_per_vq);\n     if (value >= 0)\n-      {\n-\ttree count = build_int_cstu (TREE_TYPE (f.lhs), value);\n-\treturn gimple_build_assign (f.lhs, count);\n-      }\n+      return f.fold_to_cstu (value);\n \n     return NULL;\n   }\n@@ -588,8 +582,7 @@ class svcntp_impl : public function_base\n class svcreate_impl : public quiet<multi_vector_function>\n {\n public:\n-  CONSTEXPR svcreate_impl (unsigned int vectors_per_tuple)\n-    : quiet<multi_vector_function> (vectors_per_tuple) {}\n+  using quiet<multi_vector_function>::quiet;\n \n   gimple *\n   fold (gimple_folder &f) const override\n@@ -722,12 +715,7 @@ class svdot_impl : public function_base\n class svdotprod_lane_impl : public unspec_based_function_base\n {\n public:\n-  CONSTEXPR svdotprod_lane_impl (int unspec_for_sint,\n-\t\t\t\t int unspec_for_uint,\n-\t\t\t\t int unspec_for_float)\n-    : unspec_based_function_base (unspec_for_sint,\n-\t\t\t\t  unspec_for_uint,\n-\t\t\t\t  unspec_for_float) {}\n+  using unspec_based_function_base::unspec_based_function_base;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -1003,8 +991,7 @@ class svext_bhw_impl : public function_base\n class svget_impl : public quiet<multi_vector_function>\n {\n public:\n-  CONSTEXPR svget_impl (unsigned int vectors_per_tuple)\n-    : quiet<multi_vector_function> (vectors_per_tuple) {}\n+  using quiet<multi_vector_function>::quiet;\n \n   gimple *\n   fold (gimple_folder &f) const override\n@@ -1118,8 +1105,7 @@ class svld1_impl : public full_width_access\n class svld1_extend_impl : public extending_load\n {\n public:\n-  CONSTEXPR svld1_extend_impl (type_suffix_index memory_type)\n-    : extending_load (memory_type) {}\n+  using extending_load::extending_load;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -1158,8 +1144,7 @@ class svld1_gather_impl : public full_width_access\n class svld1_gather_extend_impl : public extending_load\n {\n public:\n-  CONSTEXPR svld1_gather_extend_impl (type_suffix_index memory_type)\n-    : extending_load (memory_type) {}\n+  using extending_load::extending_load;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -1289,8 +1274,7 @@ class svld1ro_impl : public load_replicate\n class svld234_impl : public full_width_access\n {\n public:\n-  CONSTEXPR svld234_impl (unsigned int vectors_per_tuple)\n-    : full_width_access (vectors_per_tuple) {}\n+  using full_width_access::full_width_access;\n \n   unsigned int\n   call_properties (const function_instance &) const override\n@@ -1372,8 +1356,7 @@ class svldff1_gather_impl : public full_width_access\n class svldff1_gather_extend : public extending_load\n {\n public:\n-  CONSTEXPR svldff1_gather_extend (type_suffix_index memory_type)\n-    : extending_load (memory_type) {}\n+  using extending_load::extending_load;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -2070,8 +2053,7 @@ class svsel_impl : public quiet<function_base>\n class svset_impl : public quiet<multi_vector_function>\n {\n public:\n-  CONSTEXPR svset_impl (unsigned int vectors_per_tuple)\n-    : quiet<multi_vector_function> (vectors_per_tuple) {}\n+  using quiet<multi_vector_function>::quiet;\n \n   gimple *\n   fold (gimple_folder &f) const override\n@@ -2199,8 +2181,7 @@ class svst1_scatter_impl : public full_width_access\n class svst1_scatter_truncate_impl : public truncating_store\n {\n public:\n-  CONSTEXPR svst1_scatter_truncate_impl (scalar_int_mode to_mode)\n-    : truncating_store (to_mode) {}\n+  using truncating_store::truncating_store;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -2219,8 +2200,7 @@ class svst1_scatter_truncate_impl : public truncating_store\n class svst1_truncate_impl : public truncating_store\n {\n public:\n-  CONSTEXPR svst1_truncate_impl (scalar_int_mode to_mode)\n-    : truncating_store (to_mode) {}\n+  using truncating_store::truncating_store;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -2235,8 +2215,7 @@ class svst1_truncate_impl : public truncating_store\n class svst234_impl : public full_width_access\n {\n public:\n-  CONSTEXPR svst234_impl (unsigned int vectors_per_tuple)\n-    : full_width_access (vectors_per_tuple) {}\n+  using full_width_access::full_width_access;\n \n   unsigned int\n   call_properties (const function_instance &) const override\n@@ -2351,8 +2330,7 @@ class svtrn_impl : public binary_permute\n class svundef_impl : public quiet<multi_vector_function>\n {\n public:\n-  CONSTEXPR svundef_impl (unsigned int vectors_per_tuple)\n-    : quiet<multi_vector_function> (vectors_per_tuple) {}\n+  using quiet<multi_vector_function>::quiet;\n \n   rtx\n   expand (function_expander &e) const override"}, {"sha": "472e26c17ff010832971427bd87a3dae0589dbdf", "filename": "gcc/config/aarch64/aarch64-sve-builtins-functions.h", "status": "modified", "additions": 8, "deletions": 48, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-functions.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -30,18 +30,7 @@ template<typename T>\n class quiet : public T\n {\n public:\n-  CONSTEXPR quiet () : T () {}\n-\n-  /* Unfortunately we can't use parameter packs yet.  */\n-  template<typename T1>\n-  CONSTEXPR quiet (const T1 &t1) : T (t1) {}\n-\n-  template<typename T1, typename T2>\n-  CONSTEXPR quiet (const T1 &t1, const T2 &t2) : T (t1, t2) {}\n-\n-  template<typename T1, typename T2, typename T3>\n-  CONSTEXPR quiet (const T1 &t1, const T2 &t2, const T3 &t3)\n-    : T (t1, t2, t3) {}\n+  using T::T;\n \n   unsigned int\n   call_properties (const function_instance &) const override\n@@ -200,9 +189,7 @@ class rtx_code_function_base : public function_base\n class rtx_code_function : public rtx_code_function_base\n {\n public:\n-  CONSTEXPR rtx_code_function (rtx_code code_for_sint, rtx_code code_for_uint,\n-\t\t\t       int unspec_for_fp = -1)\n-    : rtx_code_function_base (code_for_sint, code_for_uint, unspec_for_fp) {}\n+  using rtx_code_function_base::rtx_code_function_base;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -219,10 +206,7 @@ class rtx_code_function : public rtx_code_function_base\n class rtx_code_function_rotated : public rtx_code_function_base\n {\n public:\n-  CONSTEXPR rtx_code_function_rotated (rtx_code code_for_sint,\n-\t\t\t\t       rtx_code code_for_uint,\n-\t\t\t\t       int unspec_for_fp = -1)\n-    : rtx_code_function_base (code_for_sint, code_for_uint, unspec_for_fp) {}\n+  using rtx_code_function_base::rtx_code_function_base;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -272,11 +256,7 @@ class unspec_based_function_base : public function_base\n class unspec_based_function : public unspec_based_function_base\n {\n public:\n-  CONSTEXPR unspec_based_function (int unspec_for_sint, int unspec_for_uint,\n-\t\t\t\t   int unspec_for_fp)\n-    : unspec_based_function_base (unspec_for_sint, unspec_for_uint,\n-\t\t\t\t  unspec_for_fp)\n-  {}\n+  using unspec_based_function_base::unspec_based_function_base;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -293,12 +273,7 @@ class unspec_based_function : public unspec_based_function_base\n class unspec_based_function_rotated : public unspec_based_function_base\n {\n public:\n-  CONSTEXPR unspec_based_function_rotated (int unspec_for_sint,\n-\t\t\t\t\t   int unspec_for_uint,\n-\t\t\t\t\t   int unspec_for_fp)\n-    : unspec_based_function_base (unspec_for_sint, unspec_for_uint,\n-\t\t\t\t  unspec_for_fp)\n-  {}\n+  using unspec_based_function_base::unspec_based_function_base;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -321,12 +296,7 @@ template<insn_code (*CODE) (int, machine_mode)>\n class unspec_based_function_exact_insn : public unspec_based_function_base\n {\n public:\n-  CONSTEXPR unspec_based_function_exact_insn (int unspec_for_sint,\n-\t\t\t\t\t      int unspec_for_uint,\n-\t\t\t\t\t      int unspec_for_fp)\n-    : unspec_based_function_base (unspec_for_sint, unspec_for_uint,\n-\t\t\t\t  unspec_for_fp)\n-  {}\n+  using unspec_based_function_base::unspec_based_function_base;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -378,12 +348,7 @@ template<insn_code (*INT_CODE) (int, machine_mode)>\n class unspec_based_fused_function : public unspec_based_function_base\n {\n public:\n-  CONSTEXPR unspec_based_fused_function (int unspec_for_sint,\n-\t\t\t\t\t int unspec_for_uint,\n-\t\t\t\t\t int unspec_for_fp)\n-    : unspec_based_function_base (unspec_for_sint, unspec_for_uint,\n-\t\t\t\t  unspec_for_fp)\n-  {}\n+  using unspec_based_function_base::unspec_based_function_base;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -413,12 +378,7 @@ template<insn_code (*INT_CODE) (int, machine_mode)>\n class unspec_based_fused_lane_function : public unspec_based_function_base\n {\n public:\n-  CONSTEXPR unspec_based_fused_lane_function (int unspec_for_sint,\n-\t\t\t\t\t      int unspec_for_uint,\n-\t\t\t\t\t      int unspec_for_fp)\n-    : unspec_based_function_base (unspec_for_sint, unspec_for_uint,\n-\t\t\t\t  unspec_for_fp)\n-  {}\n+  using unspec_based_function_base::unspec_based_function_base;\n \n   rtx\n   expand (function_expander &e) const override"}, {"sha": "a7d7435afda06f6b874c3c80bff04a960ceb7bf0", "filename": "gcc/config/aarch64/aarch64-sve-builtins-sve2.cc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-sve2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-sve2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-sve2.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -138,8 +138,7 @@ class svldnt1_gather_impl : public full_width_access\n class svldnt1_gather_extend_impl : public extending_load\n {\n public:\n-  CONSTEXPR svldnt1_gather_extend_impl (type_suffix_index memory_type)\n-    : extending_load (memory_type) {}\n+  using extending_load::extending_load;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -178,11 +177,7 @@ class svmatch_svnmatch_impl : public function_base\n class svmovl_lb_impl : public unspec_based_function_base\n {\n public:\n-  CONSTEXPR svmovl_lb_impl (int unspec_for_sint, int unspec_for_uint,\n-\t\t\t    int unspec_for_fp)\n-    : unspec_based_function_base (unspec_for_sint, unspec_for_uint,\n-\t\t\t\t  unspec_for_fp)\n-  {}\n+  using unspec_based_function_base::unspec_based_function_base;\n \n   rtx\n   expand (function_expander &e) const override\n@@ -393,8 +388,7 @@ class svstnt1_scatter_impl : public full_width_access\n class svstnt1_scatter_truncate_impl : public truncating_store\n {\n public:\n-  CONSTEXPR svstnt1_scatter_truncate_impl (scalar_int_mode to_mode)\n-    : truncating_store (to_mode) {}\n+  using truncating_store::truncating_store;\n \n   rtx\n   expand (function_expander &e) const override"}, {"sha": "e168c83344a0d487e3109718333c918b233473cd", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -82,7 +82,7 @@ class GTY(()) registered_function\n \n   /* The architecture extensions that the function requires, as a set of\n      AARCH64_FL_* flags.  */\n-  uint64_t required_extensions;\n+  aarch64_feature_flags required_extensions;\n \n   /* True if the decl represents an overloaded function that needs to be\n      resolved by function_resolver.  */\n@@ -694,16 +694,18 @@ check_required_registers (location_t location, tree fndecl)\n    Report an error against LOCATION if not.  */\n static bool\n check_required_extensions (location_t location, tree fndecl,\n-\t\t\t   uint64_t required_extensions)\n+\t\t\t   aarch64_feature_flags required_extensions)\n {\n-  uint64_t missing_extensions = required_extensions & ~aarch64_isa_flags;\n+  auto missing_extensions = required_extensions & ~aarch64_asm_isa_flags;\n   if (missing_extensions == 0)\n     return check_required_registers (location, fndecl);\n \n-  static const struct { uint64_t flag; const char *name; } extensions[] = {\n-#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \\\n-\t\t\t      SYNTHETIC, FEATURE_STRING) \\\n-    { FLAG_CANONICAL, EXT_NAME },\n+  static const struct {\n+    aarch64_feature_flags flag;\n+    const char *name;\n+  } extensions[] = {\n+#define AARCH64_OPT_EXTENSION(EXT_NAME, IDENT, C, D, E, F) \\\n+    { AARCH64_FL_##IDENT, EXT_NAME },\n #include \"aarch64-option-extensions.def\"\n   };\n \n@@ -993,7 +995,7 @@ function_builder::get_attributes (const function_instance &instance)\n registered_function &\n function_builder::add_function (const function_instance &instance,\n \t\t\t\tconst char *name, tree fntype, tree attrs,\n-\t\t\t\tuint64_t required_extensions,\n+\t\t\t\taarch64_feature_flags required_extensions,\n \t\t\t\tbool overloaded_p,\n \t\t\t\tbool placeholder_p)\n {\n@@ -1035,11 +1037,12 @@ function_builder::add_function (const function_instance &instance,\n    one-to-one mapping between \"short\" and \"full\" names, and if standard\n    overload resolution therefore isn't necessary.  */\n void\n-function_builder::add_unique_function (const function_instance &instance,\n-\t\t\t\t       tree return_type,\n-\t\t\t\t       vec<tree> &argument_types,\n-\t\t\t\t       uint64_t required_extensions,\n-\t\t\t\t       bool force_direct_overloads)\n+function_builder::\n+add_unique_function (const function_instance &instance,\n+\t\t     tree return_type,\n+\t\t     vec<tree> &argument_types,\n+\t\t     aarch64_feature_flags required_extensions,\n+\t\t     bool force_direct_overloads)\n {\n   /* Add the function under its full (unique) name.  */\n   char *name = get_name (instance, false);\n@@ -1082,8 +1085,9 @@ function_builder::add_unique_function (const function_instance &instance,\n    features are available as part of resolving the function to the\n    relevant unique function.  */\n void\n-function_builder::add_overloaded_function (const function_instance &instance,\n-\t\t\t\t\t   uint64_t required_extensions)\n+function_builder::\n+add_overloaded_function (const function_instance &instance,\n+\t\t\t aarch64_feature_flags required_extensions)\n {\n   char *name = get_name (instance, true);\n   if (registered_function **map_value = m_overload_names.get (name))\n@@ -2611,6 +2615,13 @@ gimple_folder::redirect_call (const function_instance &instance)\n   return call;\n }\n \n+/* Fold the call to constant VAL.  */\n+gimple *\n+gimple_folder::fold_to_cstu (poly_uint64 val)\n+{\n+  return gimple_build_assign (lhs, build_int_cstu (TREE_TYPE (lhs), val));\n+}\n+\n /* Fold the call to a PTRUE, taking the element size from type suffix 0.  */\n gimple *\n gimple_folder::fold_to_ptrue ()"}, {"sha": "0d130b871d0976b96ecfb3acee2edf7ab3b26b2e", "filename": "gcc/config/aarch64/aarch64-sve-builtins.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -263,7 +263,7 @@ struct function_group_info\n \n   /* The architecture extensions that the functions require, as a set of\n      AARCH64_FL_* flags.  */\n-  uint64_t required_extensions;\n+  aarch64_feature_flags required_extensions;\n };\n \n /* Describes a single fully-resolved function (i.e. one that has a\n@@ -321,8 +321,9 @@ class function_builder\n   ~function_builder ();\n \n   void add_unique_function (const function_instance &, tree,\n-\t\t\t    vec<tree> &, uint64_t, bool);\n-  void add_overloaded_function (const function_instance &, uint64_t);\n+\t\t\t    vec<tree> &, aarch64_feature_flags, bool);\n+  void add_overloaded_function (const function_instance &,\n+\t\t\t\taarch64_feature_flags);\n   void add_overloaded_functions (const function_group_info &,\n \t\t\t\t mode_suffix_index);\n \n@@ -338,7 +339,7 @@ class function_builder\n \n   registered_function &add_function (const function_instance &,\n \t\t\t\t     const char *, tree, tree,\n-\t\t\t\t     uint64_t, bool, bool);\n+\t\t\t\t     aarch64_feature_flags, bool, bool);\n \n   /* The function type to use for functions that are resolved by\n      function_resolver.  */\n@@ -499,6 +500,7 @@ class gimple_folder : public function_call_info\n   tree load_store_cookie (tree);\n \n   gimple *redirect_call (const function_instance &);\n+  gimple *fold_to_cstu (poly_uint64);\n   gimple *fold_to_pfalse ();\n   gimple *fold_to_ptrue ();\n   gimple *fold_to_vl_pred (unsigned int);"}, {"sha": "b8cc47ef5fcee84f9b4c6637f99a79ca632fab61", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 72, "deletions": 22, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -9612,45 +9612,41 @@\n (define_insn \"*aarch64_brk<brk_op>_cc\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n-\t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upa, Upa\")\n+\t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upa\")\n \t   (match_dup 1)\n \t   (match_operand:SI 4 \"aarch64_sve_ptrue_flag\")\n \t   (unspec:VNx16BI\n \t     [(match_dup 1)\n-\t      (match_operand:VNx16BI 2 \"register_operand\" \"Upa, Upa\")\n-\t      (match_operand:VNx16BI 3 \"aarch64_simd_reg_or_zero\" \"Dz, 0\")]\n+\t      (match_operand:VNx16BI 2 \"register_operand\" \"Upa\")\n+\t      (match_operand:VNx16BI 3 \"aarch64_simd_imm_zero\")]\n \t     SVE_BRK_UNARY)]\n \t  UNSPEC_PTEST))\n-   (set (match_operand:VNx16BI 0 \"register_operand\" \"=Upa, Upa\")\n+   (set (match_operand:VNx16BI 0 \"register_operand\" \"=Upa\")\n \t(unspec:VNx16BI\n \t  [(match_dup 1)\n \t   (match_dup 2)\n \t   (match_dup 3)]\n \t  SVE_BRK_UNARY))]\n   \"TARGET_SVE\"\n-  \"@\n-   brk<brk_op>s\\t%0.b, %1/z, %2.b\n-   brk<brk_op>s\\t%0.b, %1/m, %2.b\"\n+  \"brk<brk_op>s\\t%0.b, %1/z, %2.b\"\n )\n \n ;; Same, but with only the flags result being interesting.\n (define_insn \"*aarch64_brk<brk_op>_ptest\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n-\t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upa, Upa\")\n+\t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upa\")\n \t   (match_dup 1)\n \t   (match_operand:SI 4 \"aarch64_sve_ptrue_flag\")\n \t   (unspec:VNx16BI\n \t     [(match_dup 1)\n-\t      (match_operand:VNx16BI 2 \"register_operand\" \"Upa, Upa\")\n-\t      (match_operand:VNx16BI 3 \"aarch64_simd_reg_or_zero\" \"Dz, 0\")]\n+\t      (match_operand:VNx16BI 2 \"register_operand\" \"Upa\")\n+\t      (match_operand:VNx16BI 3 \"aarch64_simd_imm_zero\")]\n \t     SVE_BRK_UNARY)]\n \t  UNSPEC_PTEST))\n-   (clobber (match_scratch:VNx16BI 0 \"=Upa, Upa\"))]\n+   (clobber (match_scratch:VNx16BI 0 \"=Upa\"))]\n   \"TARGET_SVE\"\n-  \"@\n-   brk<brk_op>s\\t%0.b, %1/z, %2.b\n-   brk<brk_op>s\\t%0.b, %1/m, %2.b\"\n+  \"brk<brk_op>s\\t%0.b, %1/z, %2.b\"\n )\n \n ;; -------------------------------------------------------------------------\n@@ -9677,7 +9673,61 @@\n   \"brk<brk_op>\\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b\"\n )\n \n-;; Same, but also producing a flags result.\n+;; BRKN, producing both a predicate and a flags result.  Unlike other\n+;; flag-setting instructions, these flags are always set wrt a ptrue.\n+(define_insn_and_rewrite \"*aarch64_brkn_cc\"\n+  [(set (reg:CC_NZC CC_REGNUM)\n+\t(unspec:CC_NZC\n+\t  [(match_operand:VNx16BI 4)\n+\t   (match_operand:VNx16BI 5)\n+\t   (const_int SVE_KNOWN_PTRUE)\n+\t   (unspec:VNx16BI\n+\t     [(match_operand:VNx16BI 1 \"register_operand\" \"Upa\")\n+\t      (match_operand:VNx16BI 2 \"register_operand\" \"Upa\")\n+\t      (match_operand:VNx16BI 3 \"register_operand\" \"0\")]\n+\t     UNSPEC_BRKN)]\n+\t  UNSPEC_PTEST))\n+   (set (match_operand:VNx16BI 0 \"register_operand\" \"=Upa\")\n+\t(unspec:VNx16BI\n+\t  [(match_dup 1)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  UNSPEC_BRKN))]\n+  \"TARGET_SVE\"\n+  \"brkns\\t%0.b, %1/z, %2.b, %0.b\"\n+  \"&& (operands[4] != CONST0_RTX (VNx16BImode)\n+       || operands[5] != CONST0_RTX (VNx16BImode))\"\n+  {\n+    operands[4] = CONST0_RTX (VNx16BImode);\n+    operands[5] = CONST0_RTX (VNx16BImode);\n+  }\n+)\n+\n+;; Same, but with only the flags result being interesting.\n+(define_insn_and_rewrite \"*aarch64_brkn_ptest\"\n+  [(set (reg:CC_NZC CC_REGNUM)\n+\t(unspec:CC_NZC\n+\t  [(match_operand:VNx16BI 4)\n+\t   (match_operand:VNx16BI 5)\n+\t   (const_int SVE_KNOWN_PTRUE)\n+\t   (unspec:VNx16BI\n+\t     [(match_operand:VNx16BI 1 \"register_operand\" \"Upa\")\n+\t      (match_operand:VNx16BI 2 \"register_operand\" \"Upa\")\n+\t      (match_operand:VNx16BI 3 \"register_operand\" \"0\")]\n+\t     UNSPEC_BRKN)]\n+\t  UNSPEC_PTEST))\n+   (clobber (match_scratch:VNx16BI 0 \"=Upa\"))]\n+  \"TARGET_SVE\"\n+  \"brkns\\t%0.b, %1/z, %2.b, %0.b\"\n+  \"&& (operands[4] != CONST0_RTX (VNx16BImode)\n+       || operands[5] != CONST0_RTX (VNx16BImode))\"\n+  {\n+    operands[4] = CONST0_RTX (VNx16BImode);\n+    operands[5] = CONST0_RTX (VNx16BImode);\n+  }\n+)\n+\n+;; BRKPA and BRKPB, producing both a predicate and a flags result.\n (define_insn \"*aarch64_brk<brk_op>_cc\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n@@ -9687,17 +9737,17 @@\n \t   (unspec:VNx16BI\n \t     [(match_dup 1)\n \t      (match_operand:VNx16BI 2 \"register_operand\" \"Upa\")\n-\t      (match_operand:VNx16BI 3 \"register_operand\" \"<brk_reg_con>\")]\n-\t     SVE_BRK_BINARY)]\n+\t      (match_operand:VNx16BI 3 \"register_operand\" \"Upa\")]\n+\t     SVE_BRKP)]\n \t  UNSPEC_PTEST))\n    (set (match_operand:VNx16BI 0 \"register_operand\" \"=Upa\")\n \t(unspec:VNx16BI\n \t  [(match_dup 1)\n \t   (match_dup 2)\n \t   (match_dup 3)]\n-\t  SVE_BRK_BINARY))]\n+\t  SVE_BRKP))]\n   \"TARGET_SVE\"\n-  \"brk<brk_op>s\\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b\"\n+  \"brk<brk_op>s\\t%0.b, %1/z, %2.b, %3.b\"\n )\n \n ;; Same, but with only the flags result being interesting.\n@@ -9710,12 +9760,12 @@\n \t   (unspec:VNx16BI\n \t     [(match_dup 1)\n \t      (match_operand:VNx16BI 2 \"register_operand\" \"Upa\")\n-\t      (match_operand:VNx16BI 3 \"register_operand\" \"<brk_reg_con>\")]\n-\t     SVE_BRK_BINARY)]\n+\t      (match_operand:VNx16BI 3 \"register_operand\" \"Upa\")]\n+\t     SVE_BRKP)]\n \t  UNSPEC_PTEST))\n    (clobber (match_scratch:VNx16BI 0 \"=Upa\"))]\n   \"TARGET_SVE\"\n-  \"brk<brk_op>s\\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b\"\n+  \"brk<brk_op>s\\t%0.b, %1/z, %2.b, %3.b\"\n )\n \n ;; -------------------------------------------------------------------------"}, {"sha": "d1f979ebcf80333d957f8ad8631deef47dc693a5", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 355, "deletions": 270, "changes": 625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -81,6 +81,7 @@\n #include \"rtlanal.h\"\n #include \"tree-dfa.h\"\n #include \"asan.h\"\n+#include \"aarch64-feature-deps.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -304,7 +305,6 @@ static bool aarch64_builtin_support_vector_misalignment (machine_mode mode,\n static machine_mode aarch64_simd_container_mode (scalar_mode, poly_int64);\n static bool aarch64_print_address_internal (FILE*, machine_mode, rtx,\n \t\t\t\t\t    aarch64_addr_query_type);\n-static HOST_WIDE_INT aarch64_clamp_to_uimm12_shift (HOST_WIDE_INT val);\n \n /* The processor for which instructions should be scheduled.  */\n enum aarch64_processor aarch64_tune = cortexa53;\n@@ -2670,32 +2670,33 @@ aarch64_tuning_override_functions[] =\n /* A processor implementing AArch64.  */\n struct processor\n {\n-  const char *const name;\n-  enum aarch64_processor ident;\n-  enum aarch64_processor sched_core;\n-  enum aarch64_arch arch;\n-  const uint64_t flags;\n-  const struct tune_params *const tune;\n+  const char *name;\n+  aarch64_processor ident;\n+  aarch64_processor sched_core;\n+  aarch64_arch arch;\n+  aarch64_feature_flags flags;\n+  const tune_params *tune;\n };\n \n /* Architectures implementing AArch64.  */\n-static const struct processor all_architectures[] =\n+static CONSTEXPR const processor all_architectures[] =\n {\n-#define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH_REV, FLAGS) \\\n-  {NAME, CORE, CORE, AARCH64_ARCH_##ARCH_IDENT, FLAGS, NULL},\n+#define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, D, E) \\\n+  {NAME, CORE, CORE, AARCH64_ARCH_##ARCH_IDENT, \\\n+   feature_deps::ARCH_IDENT ().enable, NULL},\n #include \"aarch64-arches.def\"\n   {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, NULL}\n };\n \n /* Processor cores implementing AArch64.  */\n static const struct processor all_cores[] =\n {\n-#define AARCH64_CORE(NAME, IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART, VARIANT) \\\n-  {NAME, IDENT, SCHED, AARCH64_ARCH_##ARCH,\t\t\t\t\\\n-  FLAGS, &COSTS##_tunings},\n+#define AARCH64_CORE(NAME, IDENT, SCHED, ARCH, E, COSTS, G, H, I) \\\n+  {NAME, IDENT, SCHED, AARCH64_ARCH_##ARCH, \\\n+   feature_deps::cpu_##IDENT, &COSTS##_tunings},\n #include \"aarch64-cores.def\"\n-  {\"generic\", generic, cortexa53, AARCH64_ARCH_8A,\n-    AARCH64_FL_FOR_ARCH8, &generic_tunings},\n+  {\"generic\", generic, cortexa53, AARCH64_ARCH_V8A,\n+   feature_deps::V8A ().enable, &generic_tunings},\n   {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, NULL}\n };\n \n@@ -5500,6 +5501,143 @@ aarch64_output_sve_vector_inc_dec (const char *operands, rtx x)\n \t\t\t\t\t     factor, nelts_per_vq);\n }\n \n+/* Multipliers for repeating bitmasks of width 32, 16, 8, 4, and 2.  */\n+\n+static const unsigned HOST_WIDE_INT bitmask_imm_mul[] =\n+  {\n+    0x0000000100000001ull,\n+    0x0001000100010001ull,\n+    0x0101010101010101ull,\n+    0x1111111111111111ull,\n+    0x5555555555555555ull,\n+  };\n+\n+\n+\n+/* Return true if 64-bit VAL is a valid bitmask immediate.  */\n+static bool\n+aarch64_bitmask_imm (unsigned HOST_WIDE_INT val)\n+{\n+  unsigned HOST_WIDE_INT tmp, mask, first_one, next_one;\n+  int bits;\n+\n+  /* Check for a single sequence of one bits and return quickly if so.\n+     The special cases of all ones and all zeroes returns false.  */\n+  tmp = val + (val & -val);\n+\n+  if (tmp == (tmp & -tmp))\n+    return (val + 1) > 1;\n+\n+  /* Invert if the immediate doesn't start with a zero bit - this means we\n+     only need to search for sequences of one bits.  */\n+  if (val & 1)\n+    val = ~val;\n+\n+  /* Find the first set bit and set tmp to val with the first sequence of one\n+     bits removed.  Return success if there is a single sequence of ones.  */\n+  first_one = val & -val;\n+  tmp = val & (val + first_one);\n+\n+  if (tmp == 0)\n+    return true;\n+\n+  /* Find the next set bit and compute the difference in bit position.  */\n+  next_one = tmp & -tmp;\n+  bits = clz_hwi (first_one) - clz_hwi (next_one);\n+  mask = val ^ tmp;\n+\n+  /* Check the bit position difference is a power of 2, and that the first\n+     sequence of one bits fits within 'bits' bits.  */\n+  if ((mask >> bits) != 0 || bits != (bits & -bits))\n+    return false;\n+\n+  /* Check the sequence of one bits is repeated 64/bits times.  */\n+  return val == mask * bitmask_imm_mul[__builtin_clz (bits) - 26];\n+}\n+\n+\n+/* Return true if VAL is a valid bitmask immediate for MODE.  */\n+bool\n+aarch64_bitmask_imm (HOST_WIDE_INT val_in, machine_mode mode)\n+{\n+  if (mode == DImode)\n+    return aarch64_bitmask_imm (val_in);\n+\n+  unsigned HOST_WIDE_INT val = val_in;\n+\n+  if (mode == SImode)\n+    return aarch64_bitmask_imm ((val & 0xffffffff) | (val << 32));\n+\n+  /* Replicate small immediates to fit 64 bits.  */\n+  int size = GET_MODE_UNIT_PRECISION (mode);\n+  val &= (HOST_WIDE_INT_1U << size) - 1;\n+  val *= bitmask_imm_mul[__builtin_clz (size) - 26];\n+\n+  return aarch64_bitmask_imm (val);\n+}\n+\n+\n+/* Return true if the immediate VAL can be a bitfield immediate\n+   by changing the given MASK bits in VAL to zeroes, ones or bits\n+   from the other half of VAL.  Return the new immediate in VAL2.  */\n+static inline bool\n+aarch64_check_bitmask (unsigned HOST_WIDE_INT val,\n+\t\t       unsigned HOST_WIDE_INT &val2,\n+\t\t       unsigned HOST_WIDE_INT mask)\n+{\n+  val2 = val & ~mask;\n+  if (val2 != val && aarch64_bitmask_imm (val2))\n+    return true;\n+  val2 = val | mask;\n+  if (val2 != val && aarch64_bitmask_imm (val2))\n+    return true;\n+  val = val & ~mask;\n+  val2 = val | (((val >> 32) | (val << 32)) & mask);\n+  if (val2 != val && aarch64_bitmask_imm (val2))\n+    return true;\n+  val2 = val | (((val >> 16) | (val << 48)) & mask);\n+  if (val2 != val && aarch64_bitmask_imm (val2))\n+    return true;\n+  return false;\n+}\n+\n+\n+/* Return true if val is an immediate that can be loaded into a\n+   register by a MOVZ instruction.  */\n+static bool\n+aarch64_movw_imm (HOST_WIDE_INT val, scalar_int_mode mode)\n+{\n+  if (GET_MODE_SIZE (mode) > 4)\n+    {\n+      if ((val & (((HOST_WIDE_INT) 0xffff) << 32)) == val\n+\t   || (val & (((HOST_WIDE_INT) 0xffff) << 48)) == val)\n+\treturn 1;\n+    }\n+  else\n+    {\n+      /* Ignore sign extension.  */\n+      val &= (HOST_WIDE_INT) 0xffffffff;\n+    }\n+  return ((val & (((HOST_WIDE_INT) 0xffff) << 0)) == val\n+\t  || (val & (((HOST_WIDE_INT) 0xffff) << 16)) == val);\n+}\n+\n+\n+/* Return true if VAL is an immediate that can be loaded into a\n+   register in a single instruction.  */\n+bool\n+aarch64_move_imm (HOST_WIDE_INT val, machine_mode mode)\n+{\n+  scalar_int_mode int_mode;\n+  if (!is_a <scalar_int_mode> (mode, &int_mode))\n+    return false;\n+\n+  if (aarch64_movw_imm (val, int_mode) || aarch64_movw_imm (~val, int_mode))\n+    return 1;\n+  return aarch64_bitmask_imm (val, int_mode);\n+}\n+\n+\n static int\n aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n \t\t\t\tscalar_int_mode mode)\n@@ -5530,7 +5668,7 @@ aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n \temit_insn (gen_rtx_SET (dest, GEN_INT (val2)));\n \n       /* Check if we have to emit a second instruction by checking to see\n-         if any of the upper 32 bits of the original DI mode value is set.  */\n+\t if any of the upper 32 bits of the original DI mode value is set.  */\n       if (val == val2)\n \treturn 1;\n \n@@ -5566,36 +5704,43 @@ aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n   one_match = ((~val & mask) == 0) + ((~val & (mask << 16)) == 0) +\n     ((~val & (mask << 32)) == 0) + ((~val & (mask << 48)) == 0);\n \n-  if (zero_match != 2 && one_match != 2)\n+  if (zero_match < 2 && one_match < 2)\n     {\n       /* Try emitting a bitmask immediate with a movk replacing 16 bits.\n \t For a 64-bit bitmask try whether changing 16 bits to all ones or\n \t zeroes creates a valid bitmask.  To check any repeated bitmask,\n \t try using 16 bits from the other 32-bit half of val.  */\n \n-      for (i = 0; i < 64; i += 16, mask <<= 16)\n-\t{\n-\t  val2 = val & ~mask;\n-\t  if (val2 != val && aarch64_bitmask_imm (val2, mode))\n-\t    break;\n-\t  val2 = val | mask;\n-\t  if (val2 != val && aarch64_bitmask_imm (val2, mode))\n-\t    break;\n-\t  val2 = val2 & ~mask;\n-\t  val2 = val2 | (((val2 >> 32) | (val2 << 32)) & mask);\n-\t  if (val2 != val && aarch64_bitmask_imm (val2, mode))\n-\t    break;\n-\t}\n-      if (i != 64)\n-\t{\n-\t  if (generate)\n+      for (i = 0; i < 64; i += 16)\n+\tif (aarch64_check_bitmask (val, val2, mask << i))\n+\t  {\n+\t    if (generate)\n+\t      {\n+\t\temit_insn (gen_rtx_SET (dest, GEN_INT (val2)));\n+\t\temit_insn (gen_insv_immdi (dest, GEN_INT (i),\n+\t\t\t\t\t   GEN_INT ((val >> i) & 0xffff)));\n+\t      }\n+\t    return 2;\n+\t  }\n+    }\n+\n+  /* Try a bitmask plus 2 movk to generate the immediate in 3 instructions.  */\n+  if (zero_match + one_match == 0)\n+    {\n+      for (i = 0; i < 48; i += 16)\n+\tfor (int j = i + 16; j < 64; j += 16)\n+\t  if (aarch64_check_bitmask (val, val2, (mask << i) | (mask << j)))\n \t    {\n-\t      emit_insn (gen_rtx_SET (dest, GEN_INT (val2)));\n-\t      emit_insn (gen_insv_immdi (dest, GEN_INT (i),\n-\t\t\t\t\t GEN_INT ((val >> i) & 0xffff)));\n+\t      if (generate)\n+\t\t{\n+\t\t  emit_insn (gen_rtx_SET (dest, GEN_INT (val2)));\n+\t\t  emit_insn (gen_insv_immdi (dest, GEN_INT (i),\n+\t\t\t\t\t     GEN_INT ((val >> i) & 0xffff)));\n+\t\t  emit_insn (gen_insv_immdi (dest, GEN_INT (j),\n+\t\t\t\t\t       GEN_INT ((val >> j) & 0xffff)));\n+\t\t}\n+\t      return 3;\n \t    }\n-\t  return 2;\n-\t}\n     }\n \n   /* Generate 2-4 instructions, skipping 16 bits of all zeroes or ones which\n@@ -5642,6 +5787,99 @@ aarch64_mov128_immediate (rtx imm)\n }\n \n \n+/* Return true if val can be encoded as a 12-bit unsigned immediate with\n+   a left shift of 0 or 12 bits.  */\n+bool\n+aarch64_uimm12_shift (HOST_WIDE_INT val)\n+{\n+  return ((val & (((HOST_WIDE_INT) 0xfff) << 0)) == val\n+\t  || (val & (((HOST_WIDE_INT) 0xfff) << 12)) == val\n+\t  );\n+}\n+\n+/* Returns the nearest value to VAL that will fit as a 12-bit unsigned immediate\n+   that can be created with a left shift of 0 or 12.  */\n+static HOST_WIDE_INT\n+aarch64_clamp_to_uimm12_shift (HOST_WIDE_INT val)\n+{\n+  /* Check to see if the value fits in 24 bits, as that is the maximum we can\n+     handle correctly.  */\n+  gcc_assert ((val & 0xffffff) == val);\n+\n+  if (((val & 0xfff) << 0) == val)\n+    return val;\n+\n+  return val & (0xfff << 12);\n+}\n+\n+\n+/* Test whether:\n+\n+     X = (X & AND_VAL) | IOR_VAL;\n+\n+   can be implemented using:\n+\n+     MOVK X, #(IOR_VAL >> shift), LSL #shift\n+\n+   Return the shift if so, otherwise return -1.  */\n+int\n+aarch64_movk_shift (const wide_int_ref &and_val,\n+\t\t    const wide_int_ref &ior_val)\n+{\n+  unsigned int precision = and_val.get_precision ();\n+  unsigned HOST_WIDE_INT mask = 0xffff;\n+  for (unsigned int shift = 0; shift < precision; shift += 16)\n+    {\n+      if (and_val == ~mask && (ior_val & mask) == ior_val)\n+\treturn shift;\n+      mask <<= 16;\n+    }\n+  return -1;\n+}\n+\n+/* Create mask of ones, covering the lowest to highest bits set in VAL_IN.\n+   Assumed precondition: VAL_IN Is not zero.  */\n+\n+unsigned HOST_WIDE_INT\n+aarch64_and_split_imm1 (HOST_WIDE_INT val_in)\n+{\n+  int lowest_bit_set = ctz_hwi (val_in);\n+  int highest_bit_set = floor_log2 (val_in);\n+  gcc_assert (val_in != 0);\n+\n+  return ((HOST_WIDE_INT_UC (2) << highest_bit_set) -\n+\t  (HOST_WIDE_INT_1U << lowest_bit_set));\n+}\n+\n+/* Create constant where bits outside of lowest bit set to highest bit set\n+   are set to 1.  */\n+\n+unsigned HOST_WIDE_INT\n+aarch64_and_split_imm2 (HOST_WIDE_INT val_in)\n+{\n+  return val_in | ~aarch64_and_split_imm1 (val_in);\n+}\n+\n+/* Return true if VAL_IN is a valid 'and' bitmask immediate.  */\n+\n+bool\n+aarch64_and_bitmask_imm (unsigned HOST_WIDE_INT val_in, machine_mode mode)\n+{\n+  scalar_int_mode int_mode;\n+  if (!is_a <scalar_int_mode> (mode, &int_mode))\n+    return false;\n+\n+  if (aarch64_bitmask_imm (val_in, int_mode))\n+    return false;\n+\n+  if (aarch64_move_imm (val_in, int_mode))\n+    return false;\n+\n+  unsigned HOST_WIDE_INT imm2 = aarch64_and_split_imm2 (val_in);\n+\n+  return aarch64_bitmask_imm (imm2, int_mode);\n+}\n+\n /* Return the number of temporary registers that aarch64_add_offset_1\n    would need to add OFFSET to a register.  */\n \n@@ -10097,207 +10335,6 @@ aarch64_tls_referenced_p (rtx x)\n }\n \n \n-/* Return true if val can be encoded as a 12-bit unsigned immediate with\n-   a left shift of 0 or 12 bits.  */\n-bool\n-aarch64_uimm12_shift (HOST_WIDE_INT val)\n-{\n-  return ((val & (((HOST_WIDE_INT) 0xfff) << 0)) == val\n-\t  || (val & (((HOST_WIDE_INT) 0xfff) << 12)) == val\n-\t  );\n-}\n-\n-/* Returns the nearest value to VAL that will fit as a 12-bit unsigned immediate\n-   that can be created with a left shift of 0 or 12.  */\n-static HOST_WIDE_INT\n-aarch64_clamp_to_uimm12_shift (HOST_WIDE_INT val)\n-{\n-  /* Check to see if the value fits in 24 bits, as that is the maximum we can\n-     handle correctly.  */\n-  gcc_assert ((val & 0xffffff) == val);\n-\n-  if (((val & 0xfff) << 0) == val)\n-    return val;\n-\n-  return val & (0xfff << 12);\n-}\n-\n-/* Return true if val is an immediate that can be loaded into a\n-   register by a MOVZ instruction.  */\n-static bool\n-aarch64_movw_imm (HOST_WIDE_INT val, scalar_int_mode mode)\n-{\n-  if (GET_MODE_SIZE (mode) > 4)\n-    {\n-      if ((val & (((HOST_WIDE_INT) 0xffff) << 32)) == val\n-\t  || (val & (((HOST_WIDE_INT) 0xffff) << 48)) == val)\n-\treturn 1;\n-    }\n-  else\n-    {\n-      /* Ignore sign extension.  */\n-      val &= (HOST_WIDE_INT) 0xffffffff;\n-    }\n-  return ((val & (((HOST_WIDE_INT) 0xffff) << 0)) == val\n-\t  || (val & (((HOST_WIDE_INT) 0xffff) << 16)) == val);\n-}\n-\n-/* Test whether:\n-\n-     X = (X & AND_VAL) | IOR_VAL;\n-\n-   can be implemented using:\n-\n-     MOVK X, #(IOR_VAL >> shift), LSL #shift\n-\n-   Return the shift if so, otherwise return -1.  */\n-int\n-aarch64_movk_shift (const wide_int_ref &and_val,\n-\t\t    const wide_int_ref &ior_val)\n-{\n-  unsigned int precision = and_val.get_precision ();\n-  unsigned HOST_WIDE_INT mask = 0xffff;\n-  for (unsigned int shift = 0; shift < precision; shift += 16)\n-    {\n-      if (and_val == ~mask && (ior_val & mask) == ior_val)\n-\treturn shift;\n-      mask <<= 16;\n-    }\n-  return -1;\n-}\n-\n-/* VAL is a value with the inner mode of MODE.  Replicate it to fill a\n-   64-bit (DImode) integer.  */\n-\n-static unsigned HOST_WIDE_INT\n-aarch64_replicate_bitmask_imm (unsigned HOST_WIDE_INT val, machine_mode mode)\n-{\n-  unsigned int size = GET_MODE_UNIT_PRECISION (mode);\n-  while (size < 64)\n-    {\n-      val &= (HOST_WIDE_INT_1U << size) - 1;\n-      val |= val << size;\n-      size *= 2;\n-    }\n-  return val;\n-}\n-\n-/* Multipliers for repeating bitmasks of width 32, 16, 8, 4, and 2.  */\n-\n-static const unsigned HOST_WIDE_INT bitmask_imm_mul[] =\n-  {\n-    0x0000000100000001ull,\n-    0x0001000100010001ull,\n-    0x0101010101010101ull,\n-    0x1111111111111111ull,\n-    0x5555555555555555ull,\n-  };\n-\n-\n-/* Return true if val is a valid bitmask immediate.  */\n-\n-bool\n-aarch64_bitmask_imm (HOST_WIDE_INT val_in, machine_mode mode)\n-{\n-  unsigned HOST_WIDE_INT val, tmp, mask, first_one, next_one;\n-  int bits;\n-\n-  /* Check for a single sequence of one bits and return quickly if so.\n-     The special cases of all ones and all zeroes returns false.  */\n-  val = aarch64_replicate_bitmask_imm (val_in, mode);\n-  tmp = val + (val & -val);\n-\n-  if (tmp == (tmp & -tmp))\n-    return (val + 1) > 1;\n-\n-  /* Replicate 32-bit immediates so we can treat them as 64-bit.  */\n-  if (mode == SImode)\n-    val = (val << 32) | (val & 0xffffffff);\n-\n-  /* Invert if the immediate doesn't start with a zero bit - this means we\n-     only need to search for sequences of one bits.  */\n-  if (val & 1)\n-    val = ~val;\n-\n-  /* Find the first set bit and set tmp to val with the first sequence of one\n-     bits removed.  Return success if there is a single sequence of ones.  */\n-  first_one = val & -val;\n-  tmp = val & (val + first_one);\n-\n-  if (tmp == 0)\n-    return true;\n-\n-  /* Find the next set bit and compute the difference in bit position.  */\n-  next_one = tmp & -tmp;\n-  bits = clz_hwi (first_one) - clz_hwi (next_one);\n-  mask = val ^ tmp;\n-\n-  /* Check the bit position difference is a power of 2, and that the first\n-     sequence of one bits fits within 'bits' bits.  */\n-  if ((mask >> bits) != 0 || bits != (bits & -bits))\n-    return false;\n-\n-  /* Check the sequence of one bits is repeated 64/bits times.  */\n-  return val == mask * bitmask_imm_mul[__builtin_clz (bits) - 26];\n-}\n-\n-/* Create mask of ones, covering the lowest to highest bits set in VAL_IN.  \n-   Assumed precondition: VAL_IN Is not zero.  */\n-\n-unsigned HOST_WIDE_INT\n-aarch64_and_split_imm1 (HOST_WIDE_INT val_in)\n-{\n-  int lowest_bit_set = ctz_hwi (val_in);\n-  int highest_bit_set = floor_log2 (val_in);\n-  gcc_assert (val_in != 0);\n-\n-  return ((HOST_WIDE_INT_UC (2) << highest_bit_set) -\n-\t  (HOST_WIDE_INT_1U << lowest_bit_set));\n-}\n-\n-/* Create constant where bits outside of lowest bit set to highest bit set\n-   are set to 1.  */\n-\n-unsigned HOST_WIDE_INT\n-aarch64_and_split_imm2 (HOST_WIDE_INT val_in)\n-{\n-  return val_in | ~aarch64_and_split_imm1 (val_in);\n-}\n-\n-/* Return true if VAL_IN is a valid 'and' bitmask immediate.  */\n-\n-bool\n-aarch64_and_bitmask_imm (unsigned HOST_WIDE_INT val_in, machine_mode mode)\n-{\n-  scalar_int_mode int_mode;\n-  if (!is_a <scalar_int_mode> (mode, &int_mode))\n-    return false;\n-\n-  if (aarch64_bitmask_imm (val_in, int_mode))\n-    return false;\n-\n-  if (aarch64_move_imm (val_in, int_mode))\n-    return false;\n-\n-  unsigned HOST_WIDE_INT imm2 = aarch64_and_split_imm2 (val_in);\n-\n-  return aarch64_bitmask_imm (imm2, int_mode);\n-}\n-\n-/* Return true if val is an immediate that can be loaded into a\n-   register in a single instruction.  */\n-bool\n-aarch64_move_imm (HOST_WIDE_INT val, machine_mode mode)\n-{\n-  scalar_int_mode int_mode;\n-  if (!is_a <scalar_int_mode> (mode, &int_mode))\n-    return false;\n-\n-  if (aarch64_movw_imm (val, int_mode) || aarch64_movw_imm (~val, int_mode))\n-    return 1;\n-  return aarch64_bitmask_imm (val, int_mode);\n-}\n-\n static bool\n aarch64_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n@@ -11272,23 +11309,37 @@ aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)\n   if (y == const0_rtx && (REG_P (x) || SUBREG_P (x))\n       && (code == EQ || code == NE)\n       && (mode_x == HImode || mode_x == QImode))\n-    return CC_NZmode;\n+    return CC_Zmode;\n \n   /* Similarly, comparisons of zero_extends from shorter modes can\n      be performed using an ANDS with an immediate mask.  */\n   if (y == const0_rtx && code_x == ZERO_EXTEND\n       && (mode_x == SImode || mode_x == DImode)\n       && (GET_MODE (XEXP (x, 0)) == HImode || GET_MODE (XEXP (x, 0)) == QImode)\n       && (code == EQ || code == NE))\n-    return CC_NZmode;\n+    return CC_Zmode;\n \n+  /* Zero extracts support equality comparisons.  */\n+  if ((mode_x == SImode || mode_x == DImode)\n+      && y == const0_rtx\n+      && (code_x == ZERO_EXTRACT && CONST_INT_P (XEXP (x, 1))\n+\t  && CONST_INT_P (XEXP (x, 2)))\n+      && (code == EQ || code == NE))\n+    return CC_Zmode;\n+\n+  /* ANDS/BICS/TST support equality and all signed comparisons.  */\n+  if ((mode_x == SImode || mode_x == DImode)\n+      && y == const0_rtx\n+      && (code_x == AND)\n+      && (code == EQ || code == NE || code == LT || code == GE\n+\t  || code == GT || code == LE))\n+    return CC_NZVmode;\n+\n+  /* ADDS/SUBS correctly set N and Z flags.  */\n   if ((mode_x == SImode || mode_x == DImode)\n       && y == const0_rtx\n       && (code == EQ || code == NE || code == LT || code == GE)\n-      && (code_x == PLUS || code_x == MINUS || code_x == AND\n-\t  || code_x == NEG\n-\t  || (code_x == ZERO_EXTRACT && CONST_INT_P (XEXP (x, 1))\n-\t      && CONST_INT_P (XEXP (x, 2)))))\n+      && (code_x == PLUS || code_x == MINUS || code_x == NEG))\n     return CC_NZmode;\n \n   /* A compare with a shifted operand.  Because of canonicalization,\n@@ -11425,6 +11476,19 @@ aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n \t}\n       break;\n \n+    case E_CC_NZVmode:\n+      switch (comp_code)\n+\t{\n+\tcase NE: return AARCH64_NE;\n+\tcase EQ: return AARCH64_EQ;\n+\tcase GE: return AARCH64_PL;\n+\tcase LT: return AARCH64_MI;\n+\tcase GT: return AARCH64_GT;\n+\tcase LE: return AARCH64_LE;\n+\tdefault: return -1;\n+\t}\n+      break;\n+\n     case E_CC_NZmode:\n       switch (comp_code)\n \t{\n@@ -17119,7 +17183,8 @@ static void initialize_aarch64_code_model (struct gcc_options *);\n \n static enum aarch64_parse_opt_result\n aarch64_parse_arch (const char *to_parse, const struct processor **res,\n-\t\t    uint64_t *isa_flags, std::string *invalid_extension)\n+\t\t    aarch64_feature_flags *isa_flags,\n+\t\t    std::string *invalid_extension)\n {\n   const char *ext;\n   const struct processor *arch;\n@@ -17142,7 +17207,7 @@ aarch64_parse_arch (const char *to_parse, const struct processor **res,\n       if (strlen (arch->name) == len\n \t  && strncmp (arch->name, to_parse, len) == 0)\n \t{\n-\t  uint64_t isa_temp = arch->flags;\n+\t  auto isa_temp = arch->flags;\n \n \t  if (ext != NULL)\n \t    {\n@@ -17174,7 +17239,8 @@ aarch64_parse_arch (const char *to_parse, const struct processor **res,\n \n static enum aarch64_parse_opt_result\n aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n-\t\t   uint64_t *isa_flags, std::string *invalid_extension)\n+\t\t   aarch64_feature_flags *isa_flags,\n+\t\t   std::string *invalid_extension)\n {\n   const char *ext;\n   const struct processor *cpu;\n@@ -17196,8 +17262,7 @@ aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n     {\n       if (strlen (cpu->name) == len && strncmp (cpu->name, to_parse, len) == 0)\n \t{\n-\t  uint64_t isa_temp = cpu->flags;\n-\n+\t  auto isa_temp = cpu->flags;\n \n \t  if (ext != NULL)\n \t    {\n@@ -17828,7 +17893,7 @@ aarch64_print_hint_for_extensions (const std::string &str)\n \n static bool\n aarch64_validate_mcpu (const char *str, const struct processor **res,\n-\t\t       uint64_t *isa_flags)\n+\t\t       aarch64_feature_flags *isa_flags)\n {\n   std::string invalid_extension;\n   enum aarch64_parse_opt_result parse_res\n@@ -18042,7 +18107,7 @@ aarch64_validate_mbranch_protection (const char *const_str)\n \n static bool\n aarch64_validate_march (const char *str, const struct processor **res,\n-\t\t\t uint64_t *isa_flags)\n+\t\t\taarch64_feature_flags *isa_flags)\n {\n   std::string invalid_extension;\n   enum aarch64_parse_opt_result parse_res\n@@ -18127,19 +18192,28 @@ aarch64_convert_sve_vector_bits (aarch64_sve_vector_bits_enum value)\n     return (int) value / 64;\n }\n \n+/* Set the global aarch64_asm_isa_flags to FLAGS and update\n+   aarch64_isa_flags accordingly.  */\n+\n+void\n+aarch64_set_asm_isa_flags (aarch64_feature_flags flags)\n+{\n+  aarch64_set_asm_isa_flags (&global_options, flags);\n+}\n+\n /* Implement TARGET_OPTION_OVERRIDE.  This is called once in the beginning\n    and is used to parse the -m{cpu,tune,arch} strings and setup the initial\n    tuning structs.  In particular it must set selected_tune and\n-   aarch64_isa_flags that define the available ISA features and tuning\n+   aarch64_asm_isa_flags that define the available ISA features and tuning\n    decisions.  It must also set selected_arch as this will be used to\n    output the .arch asm tags for each function.  */\n \n static void\n aarch64_override_options (void)\n {\n-  uint64_t cpu_isa = 0;\n-  uint64_t arch_isa = 0;\n-  aarch64_isa_flags = 0;\n+  aarch64_feature_flags cpu_isa = 0;\n+  aarch64_feature_flags arch_isa = 0;\n+  aarch64_set_asm_isa_flags (0);\n \n   const struct processor *cpu = NULL;\n   const struct processor *arch = NULL;\n@@ -18179,25 +18253,25 @@ aarch64_override_options (void)\n \t}\n \n       selected_arch = arch->arch;\n-      aarch64_isa_flags = arch_isa;\n+      aarch64_set_asm_isa_flags (arch_isa);\n     }\n   else if (cpu)\n     {\n       selected_arch = cpu->arch;\n-      aarch64_isa_flags = cpu_isa;\n+      aarch64_set_asm_isa_flags (cpu_isa);\n     }\n   else if (arch)\n     {\n       cpu = &all_cores[arch->ident];\n       selected_arch = arch->arch;\n-      aarch64_isa_flags = arch_isa;\n+      aarch64_set_asm_isa_flags (arch_isa);\n     }\n   else\n     {\n       /* No -mcpu or -march specified, so use the default CPU.  */\n       cpu = &all_cores[TARGET_CPU_DEFAULT];\n       selected_arch = cpu->arch;\n-      aarch64_isa_flags = cpu->flags;\n+      aarch64_set_asm_isa_flags (cpu->flags);\n     }\n \n   selected_tune = tune ? tune->ident : cpu->ident;\n@@ -18339,7 +18413,7 @@ aarch64_option_print (FILE *file, int indent, struct cl_target_option *ptr)\n     = aarch64_get_tune_cpu (ptr->x_selected_tune);\n   const struct processor *arch = aarch64_get_arch (ptr->x_selected_arch);\n   std::string extension\n-    = aarch64_get_extension_string_for_isa_flags (ptr->x_aarch64_isa_flags,\n+    = aarch64_get_extension_string_for_isa_flags (ptr->x_aarch64_asm_isa_flags,\n \t\t\t\t\t\t  arch->flags);\n \n   fprintf (file, \"%*sselected tune = %s\\n\", indent, \"\", cpu->name);\n@@ -18447,13 +18521,15 @@ aarch64_handle_attr_arch (const char *str)\n {\n   const struct processor *tmp_arch = NULL;\n   std::string invalid_extension;\n+  aarch64_feature_flags tmp_flags;\n   enum aarch64_parse_opt_result parse_res\n-    = aarch64_parse_arch (str, &tmp_arch, &aarch64_isa_flags, &invalid_extension);\n+    = aarch64_parse_arch (str, &tmp_arch, &tmp_flags, &invalid_extension);\n \n   if (parse_res == AARCH64_PARSE_OK)\n     {\n       gcc_assert (tmp_arch);\n       selected_arch = tmp_arch->arch;\n+      aarch64_set_asm_isa_flags (tmp_flags);\n       return true;\n     }\n \n@@ -18485,14 +18561,16 @@ aarch64_handle_attr_cpu (const char *str)\n {\n   const struct processor *tmp_cpu = NULL;\n   std::string invalid_extension;\n+  aarch64_feature_flags tmp_flags;\n   enum aarch64_parse_opt_result parse_res\n-    = aarch64_parse_cpu (str, &tmp_cpu, &aarch64_isa_flags, &invalid_extension);\n+    = aarch64_parse_cpu (str, &tmp_cpu, &tmp_flags, &invalid_extension);\n \n   if (parse_res == AARCH64_PARSE_OK)\n     {\n       gcc_assert (tmp_cpu);\n       selected_tune = tmp_cpu->ident;\n       selected_arch = tmp_cpu->arch;\n+      aarch64_set_asm_isa_flags (tmp_flags);\n       return true;\n     }\n \n@@ -18586,7 +18664,7 @@ static bool\n aarch64_handle_attr_isa_flags (char *str)\n {\n   enum aarch64_parse_opt_result parse_res;\n-  uint64_t isa_flags = aarch64_isa_flags;\n+  auto isa_flags = aarch64_asm_isa_flags;\n \n   /* We allow \"+nothing\" in the beginning to clear out all architectural\n      features if the user wants to handpick specific features.  */\n@@ -18601,7 +18679,7 @@ aarch64_handle_attr_isa_flags (char *str)\n \n   if (parse_res == AARCH64_PARSE_OK)\n     {\n-      aarch64_isa_flags = isa_flags;\n+      aarch64_set_asm_isa_flags (isa_flags);\n       return true;\n     }\n \n@@ -18858,7 +18936,7 @@ aarch64_process_target_attr (tree args)\n \t{\n \t  /* Check if token is possibly an arch extension without\n \t     leading '+'.  */\n-\t  uint64_t isa_temp = 0;\n+\t  aarch64_feature_flags isa_temp = 0;\n \t  auto with_plus = std::string (\"+\") + token;\n \t  enum aarch64_parse_opt_result ext_res\n \t    = aarch64_parse_extension (with_plus.c_str (), &isa_temp, nullptr);\n@@ -19011,8 +19089,12 @@ aarch64_can_inline_p (tree caller, tree callee)\n \t\t\t\t\t   : target_option_default_node);\n \n   /* Callee's ISA flags should be a subset of the caller's.  */\n+  if ((caller_opts->x_aarch64_asm_isa_flags\n+       & callee_opts->x_aarch64_asm_isa_flags)\n+      != callee_opts->x_aarch64_asm_isa_flags)\n+    return false;\n   if ((caller_opts->x_aarch64_isa_flags & callee_opts->x_aarch64_isa_flags)\n-       != callee_opts->x_aarch64_isa_flags)\n+      != callee_opts->x_aarch64_isa_flags)\n     return false;\n \n   /* Allow non-strict aligned functions inlining into strict\n@@ -19809,7 +19891,8 @@ aarch64_setup_incoming_varargs (cumulative_args_t cum_v,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   local_cum = *cum;\n-  aarch64_function_arg_advance (pack_cumulative_args(&local_cum), arg);\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl)))\n+    aarch64_function_arg_advance (pack_cumulative_args(&local_cum), arg);\n \n   /* Found out how many registers we need to save.\n      Honor tree-stdvar analysis results.  */\n@@ -20644,6 +20727,8 @@ aarch64_mangle_type (const_tree type)\n   /* Half-precision floating point types.  */\n   if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)\n     {\n+      if (TYPE_MAIN_VARIANT (type) == float16_type_node)\n+\treturn NULL;\n       if (TYPE_MODE (type) == BFmode)\n \treturn \"u6__bf16\";\n       else\n@@ -22474,7 +22559,7 @@ aarch64_declare_function_name (FILE *stream, const char* name,\n   const struct processor *this_arch\n     = aarch64_get_arch (targ_options->x_selected_arch);\n \n-  uint64_t isa_flags = targ_options->x_aarch64_isa_flags;\n+  auto isa_flags = targ_options->x_aarch64_asm_isa_flags;\n   std::string extension\n     = aarch64_get_extension_string_for_isa_flags (isa_flags,\n \t\t\t\t\t\t  this_arch->flags);\n@@ -22578,7 +22663,7 @@ aarch64_start_file (void)\n \n   const struct processor *default_arch\n     = aarch64_get_arch (default_options->x_selected_arch);\n-  uint64_t default_isa_flags = default_options->x_aarch64_isa_flags;\n+  auto default_isa_flags = default_options->x_aarch64_asm_isa_flags;\n   std::string extension\n     = aarch64_get_extension_string_for_isa_flags (default_isa_flags,\n \t\t\t\t\t\t  default_arch->flags);"}, {"sha": "e60f9bce023b2cd5e7233ee9b8c61fc93c1494c2", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 65, "deletions": 182, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -22,6 +22,17 @@\n #ifndef GCC_AARCH64_H\n #define GCC_AARCH64_H\n \n+/* Make these flags read-only so that all uses go via\n+   aarch64_set_asm_isa_flags.  */\n+#ifndef GENERATOR_FILE\n+#undef aarch64_asm_isa_flags\n+#define aarch64_asm_isa_flags \\\n+  ((aarch64_feature_flags) global_options.x_aarch64_asm_isa_flags)\n+#undef aarch64_isa_flags\n+#define aarch64_isa_flags \\\n+  ((aarch64_feature_flags) global_options.x_aarch64_isa_flags)\n+#endif\n+\n /* Target CPU builtins.  */\n #define TARGET_CPU_CPP_BUILTINS()\t\\\n   aarch64_cpu_cpp_builtins (pfile)\n@@ -51,8 +62,8 @@\n \n /* AdvSIMD is supported in the default configuration, unless disabled by\n    -mgeneral-regs-only or by the +nosimd extension.  */\n-#define TARGET_SIMD (!TARGET_GENERAL_REGS_ONLY && AARCH64_ISA_SIMD)\n-#define TARGET_FLOAT (!TARGET_GENERAL_REGS_ONLY && AARCH64_ISA_FP)\n+#define TARGET_SIMD (AARCH64_ISA_SIMD)\n+#define TARGET_FLOAT (AARCH64_ISA_FP)\n \n #define UNITS_PER_WORD\t\t8\n \n@@ -144,150 +155,27 @@\n \n #define PCC_BITFIELD_TYPE_MATTERS\t1\n \n-/* Instruction tuning/selection flags.  */\n-\n-/* Bit values used to identify processor capabilities.  */\n-#define AARCH64_FL_SIMD       (1 << 0)\t/* Has SIMD instructions.  */\n-#define AARCH64_FL_FP         (1 << 1)\t/* Has FP.  */\n-#define AARCH64_FL_CRYPTO     (1 << 2)\t/* Has crypto.  */\n-#define AARCH64_FL_CRC        (1 << 3)\t/* Has CRC.  */\n-/* ARMv8.1-A architecture extensions.  */\n-#define AARCH64_FL_LSE\t      (1 << 4)  /* Has Large System Extensions.  */\n-#define AARCH64_FL_RDMA       (1 << 5)  /* Has Round Double Multiply Add.  */\n-#define AARCH64_FL_V8_1       (1 << 6)  /* Has ARMv8.1-A extensions.  */\n-/* Armv8-R.  */\n-#define AARCH64_FL_V8_R       (1 << 7)  /* Armv8-R AArch64.  */\n-/* ARMv8.2-A architecture extensions.  */\n-#define AARCH64_FL_V8_2       (1 << 8)  /* Has ARMv8.2-A features.  */\n-#define AARCH64_FL_F16\t      (1 << 9)  /* Has ARMv8.2-A FP16 extensions.  */\n-#define AARCH64_FL_SVE        (1 << 10) /* Has Scalable Vector Extensions.  */\n-/* ARMv8.3-A architecture extensions.  */\n-#define AARCH64_FL_V8_3       (1 << 11)  /* Has ARMv8.3-A features.  */\n-#define AARCH64_FL_RCPC       (1 << 12)  /* Has support for RCpc model.  */\n-#define AARCH64_FL_DOTPROD    (1 << 13)  /* Has ARMv8.2-A Dot Product ins.  */\n-/* New flags to split crypto into aes and sha2.  */\n-#define AARCH64_FL_AES\t      (1 << 14)  /* Has Crypto AES.  */\n-#define AARCH64_FL_SHA2\t      (1 << 15)  /* Has Crypto SHA2.  */\n-/* ARMv8.4-A architecture extensions.  */\n-#define AARCH64_FL_V8_4\t      (1 << 16)  /* Has ARMv8.4-A features.  */\n-#define AARCH64_FL_SM4\t      (1 << 17)  /* Has ARMv8.4-A SM3 and SM4.  */\n-#define AARCH64_FL_SHA3\t      (1 << 18)  /* Has ARMv8.4-a SHA3 and SHA512.  */\n-#define AARCH64_FL_F16FML     (1 << 19)  /* Has ARMv8.4-a FP16 extensions.  */\n-#define AARCH64_FL_RCPC8_4    (1 << 20)  /* Has ARMv8.4-a RCPC extensions.  */\n-\n-/* Statistical Profiling extensions.  */\n-#define AARCH64_FL_PROFILE    (1 << 21)\n-\n-/* ARMv8.5-A architecture extensions.  */\n-#define AARCH64_FL_V8_5\t      (1 << 22)  /* Has ARMv8.5-A features.  */\n-#define AARCH64_FL_RNG\t      (1 << 23)  /* ARMv8.5-A Random Number Insns.  */\n-#define AARCH64_FL_MEMTAG     (1 << 24)  /* ARMv8.5-A Memory Tagging\n-\t\t\t\t\t    Extensions.  */\n-\n-/* Speculation Barrier instruction supported.  */\n-#define AARCH64_FL_SB\t      (1 << 25)\n-\n-/* Speculative Store Bypass Safe instruction supported.  */\n-#define AARCH64_FL_SSBS\t      (1 << 26)\n-\n-/* Execution and Data Prediction Restriction instructions supported.  */\n-#define AARCH64_FL_PREDRES    (1 << 27)\n-\n-/* SVE2 instruction supported.  */\n-#define AARCH64_FL_SVE2\t\t(1 << 28)\n-#define AARCH64_FL_SVE2_AES\t(1 << 29)\n-#define AARCH64_FL_SVE2_SM4\t(1 << 30)\n-#define AARCH64_FL_SVE2_SHA3\t(1ULL << 31)\n-#define AARCH64_FL_SVE2_BITPERM\t(1ULL << 32)\n-\n-/* Transactional Memory Extension.  */\n-#define AARCH64_FL_TME\t      (1ULL << 33)  /* Has TME instructions.  */\n-\n-/* Armv8.6-A architecture extensions.  */\n-#define AARCH64_FL_V8_6\t      (1ULL << 34)\n-\n-/* 8-bit Integer Matrix Multiply (I8MM) extensions.  */\n-#define AARCH64_FL_I8MM\t      (1ULL << 35)\n-\n-/* Brain half-precision floating-point (BFloat16) Extension.  */\n-#define AARCH64_FL_BF16\t      (1ULL << 36)\n-\n-/* 32-bit Floating-point Matrix Multiply (F32MM) extensions.  */\n-#define AARCH64_FL_F32MM      (1ULL << 37)\n-\n-/* 64-bit Floating-point Matrix Multiply (F64MM) extensions.  */\n-#define AARCH64_FL_F64MM      (1ULL << 38)\n-\n-/* Flag Manipulation Instructions (FLAGM) extension.  */\n-#define AARCH64_FL_FLAGM      (1ULL << 39)\n-\n-/* Pointer Authentication (PAUTH) extension.  */\n-#define AARCH64_FL_PAUTH      (1ULL << 40)\n-\n-/* Armv9.0-A.  */\n-#define AARCH64_FL_V9         (1ULL << 41)  /* Armv9.0-A Architecture.  */\n-\n-/* 64-byte atomic load/store extensions.  */\n-#define AARCH64_FL_LS64      (1ULL << 42)\n-\n-/* Armv8.7-a architecture extensions.  */\n-#define AARCH64_FL_V8_7       (1ULL << 43)\n-\n-/* Hardware memory operation instructions.  */\n-#define AARCH64_FL_MOPS       (1ULL << 44)\n-\n-/* Armv8.8-a architecture extensions.  */\n-#define AARCH64_FL_V8_8       (1ULL << 45)\n-\n-/* Armv9.1-A.  */\n-#define AARCH64_FL_V9_1       (1ULL << 46)\n-\n-/* Armv9.2-A.  */\n-#define AARCH64_FL_V9_2       (1ULL << 47)\n-\n-/* Armv9.3-A.  */\n-#define AARCH64_FL_V9_3       (1ULL << 48)\n-\n-/* Has FP and SIMD.  */\n-#define AARCH64_FL_FPSIMD     (AARCH64_FL_FP | AARCH64_FL_SIMD)\n-\n-/* Has FP without SIMD.  */\n-#define AARCH64_FL_FPQ16      (AARCH64_FL_FP & ~AARCH64_FL_SIMD)\n-\n-/* Architecture flags that effect instruction selection.  */\n-#define AARCH64_FL_FOR_ARCH8       (AARCH64_FL_FPSIMD)\n-#define AARCH64_FL_FOR_ARCH8_1\t\t\t       \\\n-  (AARCH64_FL_FOR_ARCH8 | AARCH64_FL_LSE | AARCH64_FL_CRC \\\n-   | AARCH64_FL_RDMA | AARCH64_FL_V8_1)\n-#define AARCH64_FL_FOR_ARCH8_2\t\t\t\\\n-  (AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_V8_2)\n-#define AARCH64_FL_FOR_ARCH8_3\t\t\t\\\n-  (AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_V8_3 | AARCH64_FL_PAUTH)\n-#define AARCH64_FL_FOR_ARCH8_4\t\t\t\\\n-  (AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_V8_4 | AARCH64_FL_F16FML \\\n-   | AARCH64_FL_DOTPROD | AARCH64_FL_RCPC8_4 | AARCH64_FL_FLAGM)\n-#define AARCH64_FL_FOR_ARCH8_5\t\t\t\\\n-  (AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_V8_5\t\\\n-   | AARCH64_FL_SB | AARCH64_FL_SSBS | AARCH64_FL_PREDRES)\n-#define AARCH64_FL_FOR_ARCH8_6\t\t\t\\\n-  (AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_V8_6 | AARCH64_FL_FPSIMD \\\n-   | AARCH64_FL_I8MM | AARCH64_FL_BF16)\n-#define AARCH64_FL_FOR_ARCH8_7\t\t\t\\\n-  (AARCH64_FL_FOR_ARCH8_6 | AARCH64_FL_V8_7 | AARCH64_FL_LS64)\n-#define AARCH64_FL_FOR_ARCH8_8\t\t\t\\\n-  (AARCH64_FL_FOR_ARCH8_7 | AARCH64_FL_V8_8 | AARCH64_FL_MOPS)\n-\n-#define AARCH64_FL_FOR_ARCH8_R     \\\n-  (AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_V8_R)\n-#define AARCH64_FL_FOR_ARCH9       \\\n-  (AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_V9 \\\n-   | AARCH64_FL_F16)\n-#define AARCH64_FL_FOR_ARCH9_1\t\\\n-  (AARCH64_FL_FOR_ARCH9 | AARCH64_FL_FOR_ARCH8_6 | AARCH64_FL_V9_1)\n-#define AARCH64_FL_FOR_ARCH9_2\t\\\n-  (AARCH64_FL_FOR_ARCH9_1 | AARCH64_FL_FOR_ARCH8_7 | AARCH64_FL_V9_2)\n-#define AARCH64_FL_FOR_ARCH9_3\t\\\n-  (AARCH64_FL_FOR_ARCH9_2 | AARCH64_FL_FOR_ARCH8_8 | AARCH64_FL_V9_3)\n+#ifndef USED_FOR_TARGET\n+\n+/* Define an enum of all features (architectures and extensions).  */\n+enum class aarch64_feature : unsigned char {\n+#define AARCH64_OPT_EXTENSION(A, IDENT, C, D, E, F) IDENT,\n+#define AARCH64_ARCH(A, B, IDENT, D, E) IDENT,\n+#include \"aarch64-option-extensions.def\"\n+#include \"aarch64-arches.def\"\n+};\n+\n+/* Define unique flags for each of the above.  */\n+#define HANDLE(IDENT) \\\n+  constexpr auto AARCH64_FL_##IDENT \\\n+    = aarch64_feature_flags (1) << int (aarch64_feature::IDENT);\n+#define AARCH64_OPT_EXTENSION(A, IDENT, C, D, E, F) HANDLE (IDENT)\n+#define AARCH64_ARCH(A, B, IDENT, D, E) HANDLE (IDENT)\n+#include \"aarch64-option-extensions.def\"\n+#include \"aarch64-arches.def\"\n+#undef HANDLE\n+\n+#endif\n \n /* Macros to test ISA flags.  */\n \n@@ -297,56 +185,57 @@\n #define AARCH64_ISA_SIMD           (aarch64_isa_flags & AARCH64_FL_SIMD)\n #define AARCH64_ISA_LSE\t\t   (aarch64_isa_flags & AARCH64_FL_LSE)\n #define AARCH64_ISA_RDMA\t   (aarch64_isa_flags & AARCH64_FL_RDMA)\n-#define AARCH64_ISA_V8_2\t   (aarch64_isa_flags & AARCH64_FL_V8_2)\n+#define AARCH64_ISA_V8_2A\t   (aarch64_isa_flags & AARCH64_FL_V8_2A)\n #define AARCH64_ISA_F16\t\t   (aarch64_isa_flags & AARCH64_FL_F16)\n #define AARCH64_ISA_SVE            (aarch64_isa_flags & AARCH64_FL_SVE)\n #define AARCH64_ISA_SVE2\t   (aarch64_isa_flags & AARCH64_FL_SVE2)\n #define AARCH64_ISA_SVE2_AES\t   (aarch64_isa_flags & AARCH64_FL_SVE2_AES)\n #define AARCH64_ISA_SVE2_BITPERM  (aarch64_isa_flags & AARCH64_FL_SVE2_BITPERM)\n #define AARCH64_ISA_SVE2_SHA3\t   (aarch64_isa_flags & AARCH64_FL_SVE2_SHA3)\n #define AARCH64_ISA_SVE2_SM4\t   (aarch64_isa_flags & AARCH64_FL_SVE2_SM4)\n-#define AARCH64_ISA_V8_3\t   (aarch64_isa_flags & AARCH64_FL_V8_3)\n+#define AARCH64_ISA_V8_3A\t   (aarch64_isa_flags & AARCH64_FL_V8_3A)\n #define AARCH64_ISA_DOTPROD\t   (aarch64_isa_flags & AARCH64_FL_DOTPROD)\n #define AARCH64_ISA_AES\t           (aarch64_isa_flags & AARCH64_FL_AES)\n #define AARCH64_ISA_SHA2\t   (aarch64_isa_flags & AARCH64_FL_SHA2)\n-#define AARCH64_ISA_V8_4\t   (aarch64_isa_flags & AARCH64_FL_V8_4)\n+#define AARCH64_ISA_V8_4A\t   (aarch64_isa_flags & AARCH64_FL_V8_4A)\n #define AARCH64_ISA_SM4\t           (aarch64_isa_flags & AARCH64_FL_SM4)\n #define AARCH64_ISA_SHA3\t   (aarch64_isa_flags & AARCH64_FL_SHA3)\n #define AARCH64_ISA_F16FML\t   (aarch64_isa_flags & AARCH64_FL_F16FML)\n-#define AARCH64_ISA_RCPC8_4\t   (aarch64_isa_flags & AARCH64_FL_RCPC8_4)\n+#define AARCH64_ISA_RCPC\t   (aarch64_isa_flags & AARCH64_FL_RCPC)\n+#define AARCH64_ISA_RCPC8_4\t   (aarch64_isa_flags & AARCH64_FL_V8_4A)\n #define AARCH64_ISA_RNG\t\t   (aarch64_isa_flags & AARCH64_FL_RNG)\n-#define AARCH64_ISA_V8_5\t   (aarch64_isa_flags & AARCH64_FL_V8_5)\n+#define AARCH64_ISA_V8_5A\t   (aarch64_isa_flags & AARCH64_FL_V8_5A)\n #define AARCH64_ISA_TME\t\t   (aarch64_isa_flags & AARCH64_FL_TME)\n #define AARCH64_ISA_MEMTAG\t   (aarch64_isa_flags & AARCH64_FL_MEMTAG)\n-#define AARCH64_ISA_V8_6\t   (aarch64_isa_flags & AARCH64_FL_V8_6)\n+#define AARCH64_ISA_V8_6A\t   (aarch64_isa_flags & AARCH64_FL_V8_6A)\n #define AARCH64_ISA_I8MM\t   (aarch64_isa_flags & AARCH64_FL_I8MM)\n #define AARCH64_ISA_F32MM\t   (aarch64_isa_flags & AARCH64_FL_F32MM)\n #define AARCH64_ISA_F64MM\t   (aarch64_isa_flags & AARCH64_FL_F64MM)\n #define AARCH64_ISA_BF16\t   (aarch64_isa_flags & AARCH64_FL_BF16)\n #define AARCH64_ISA_SB\t\t   (aarch64_isa_flags & AARCH64_FL_SB)\n-#define AARCH64_ISA_V8_R\t   (aarch64_isa_flags & AARCH64_FL_V8_R)\n+#define AARCH64_ISA_V8R\t\t   (aarch64_isa_flags & AARCH64_FL_V8R)\n #define AARCH64_ISA_PAUTH\t   (aarch64_isa_flags & AARCH64_FL_PAUTH)\n-#define AARCH64_ISA_V9\t\t   (aarch64_isa_flags & AARCH64_FL_V9)\n-#define AARCH64_ISA_V9_1           (aarch64_isa_flags & AARCH64_FL_V9_1)\n-#define AARCH64_ISA_V9_2           (aarch64_isa_flags & AARCH64_FL_V9_2)\n-#define AARCH64_ISA_V9_3           (aarch64_isa_flags & AARCH64_FL_V9_3)\n+#define AARCH64_ISA_V9A\t\t   (aarch64_isa_flags & AARCH64_FL_V9A)\n+#define AARCH64_ISA_V9_1A          (aarch64_isa_flags & AARCH64_FL_V9_1A)\n+#define AARCH64_ISA_V9_2A          (aarch64_isa_flags & AARCH64_FL_V9_2A)\n+#define AARCH64_ISA_V9_3A          (aarch64_isa_flags & AARCH64_FL_V9_3A)\n #define AARCH64_ISA_MOPS\t   (aarch64_isa_flags & AARCH64_FL_MOPS)\n #define AARCH64_ISA_LS64\t   (aarch64_isa_flags & AARCH64_FL_LS64)\n \n /* Crypto is an optional extension to AdvSIMD.  */\n-#define TARGET_CRYPTO (TARGET_SIMD && AARCH64_ISA_CRYPTO)\n+#define TARGET_CRYPTO (AARCH64_ISA_CRYPTO)\n \n /* SHA2 is an optional extension to AdvSIMD.  */\n-#define TARGET_SHA2 ((TARGET_SIMD && AARCH64_ISA_SHA2) || TARGET_CRYPTO)\n+#define TARGET_SHA2 (AARCH64_ISA_SHA2)\n \n /* SHA3 is an optional extension to AdvSIMD.  */\n-#define TARGET_SHA3 (TARGET_SIMD && AARCH64_ISA_SHA3)\n+#define TARGET_SHA3 (AARCH64_ISA_SHA3)\n \n /* AES is an optional extension to AdvSIMD.  */\n-#define TARGET_AES ((TARGET_SIMD && AARCH64_ISA_AES) || TARGET_CRYPTO)\n+#define TARGET_AES (AARCH64_ISA_AES)\n \n /* SM is an optional extension to AdvSIMD.  */\n-#define TARGET_SM4 (TARGET_SIMD && AARCH64_ISA_SM4)\n+#define TARGET_SM4 (AARCH64_ISA_SM4)\n \n /* FP16FML is an optional extension to AdvSIMD.  */\n #define TARGET_F16FML (TARGET_SIMD && AARCH64_ISA_F16FML && TARGET_FP_F16INST)\n@@ -358,41 +247,41 @@\n #define TARGET_LSE (AARCH64_ISA_LSE)\n \n /* ARMv8.2-A FP16 support that can be enabled through the +fp16 extension.  */\n-#define TARGET_FP_F16INST (TARGET_FLOAT && AARCH64_ISA_F16)\n+#define TARGET_FP_F16INST (AARCH64_ISA_F16)\n #define TARGET_SIMD_F16INST (TARGET_SIMD && AARCH64_ISA_F16)\n \n /* Dot Product is an optional extension to AdvSIMD enabled through +dotprod.  */\n-#define TARGET_DOTPROD (TARGET_SIMD && AARCH64_ISA_DOTPROD)\n+#define TARGET_DOTPROD (AARCH64_ISA_DOTPROD)\n \n /* SVE instructions, enabled through +sve.  */\n-#define TARGET_SVE (!TARGET_GENERAL_REGS_ONLY && AARCH64_ISA_SVE)\n+#define TARGET_SVE (AARCH64_ISA_SVE)\n \n /* SVE2 instructions, enabled through +sve2.  */\n-#define TARGET_SVE2 (TARGET_SVE && AARCH64_ISA_SVE2)\n+#define TARGET_SVE2 (AARCH64_ISA_SVE2)\n \n /* SVE2 AES instructions, enabled through +sve2-aes.  */\n-#define TARGET_SVE2_AES (TARGET_SVE2 && AARCH64_ISA_SVE2_AES)\n+#define TARGET_SVE2_AES (AARCH64_ISA_SVE2_AES)\n \n /* SVE2 BITPERM instructions, enabled through +sve2-bitperm.  */\n-#define TARGET_SVE2_BITPERM (TARGET_SVE2 && AARCH64_ISA_SVE2_BITPERM)\n+#define TARGET_SVE2_BITPERM (AARCH64_ISA_SVE2_BITPERM)\n \n /* SVE2 SHA3 instructions, enabled through +sve2-sha3.  */\n-#define TARGET_SVE2_SHA3 (TARGET_SVE2 && AARCH64_ISA_SVE2_SHA3)\n+#define TARGET_SVE2_SHA3 (AARCH64_ISA_SVE2_SHA3)\n \n /* SVE2 SM4 instructions, enabled through +sve2-sm4.  */\n-#define TARGET_SVE2_SM4 (TARGET_SVE2 && AARCH64_ISA_SVE2_SM4)\n+#define TARGET_SVE2_SM4 (AARCH64_ISA_SVE2_SM4)\n \n /* ARMv8.3-A features.  */\n-#define TARGET_ARMV8_3\t(AARCH64_ISA_V8_3)\n+#define TARGET_ARMV8_3\t(AARCH64_ISA_V8_3A)\n \n /* Javascript conversion instruction from Armv8.3-a.  */\n-#define TARGET_JSCVT\t(TARGET_FLOAT && AARCH64_ISA_V8_3)\n+#define TARGET_JSCVT\t(TARGET_FLOAT && AARCH64_ISA_V8_3A)\n \n /* Armv8.3-a Complex number extension to AdvSIMD extensions.  */\n #define TARGET_COMPLEX (TARGET_SIMD && TARGET_ARMV8_3)\n \n /* Floating-point rounding instructions from Armv8.5-a.  */\n-#define TARGET_FRINT (AARCH64_ISA_V8_5 && TARGET_FLOAT)\n+#define TARGET_FRINT (AARCH64_ISA_V8_5A && TARGET_FLOAT)\n \n /* TME instructions are enabled.  */\n #define TARGET_TME (AARCH64_ISA_TME)\n@@ -401,19 +290,17 @@\n #define TARGET_RNG (AARCH64_ISA_RNG)\n \n /* Memory Tagging instructions optional to Armv8.5 enabled through +memtag.  */\n-#define TARGET_MEMTAG (AARCH64_ISA_V8_5 && AARCH64_ISA_MEMTAG)\n+#define TARGET_MEMTAG (AARCH64_ISA_V8_5A && AARCH64_ISA_MEMTAG)\n \n /* I8MM instructions are enabled through +i8mm.  */\n #define TARGET_I8MM (AARCH64_ISA_I8MM)\n #define TARGET_SVE_I8MM (TARGET_SVE && AARCH64_ISA_I8MM)\n \n /* F32MM instructions are enabled through +f32mm.  */\n-#define TARGET_F32MM (AARCH64_ISA_F32MM)\n-#define TARGET_SVE_F32MM (TARGET_SVE && AARCH64_ISA_F32MM)\n+#define TARGET_SVE_F32MM (AARCH64_ISA_F32MM)\n \n /* F64MM instructions are enabled through +f64mm.  */\n-#define TARGET_F64MM (AARCH64_ISA_F64MM)\n-#define TARGET_SVE_F64MM (TARGET_SVE && AARCH64_ISA_F64MM)\n+#define TARGET_SVE_F64MM (AARCH64_ISA_F64MM)\n \n /* BF16 instructions are enabled through +bf16.  */\n #define TARGET_BF16_FP (AARCH64_ISA_BF16)\n@@ -684,10 +571,6 @@\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, R4_REGNUM)\n #define EH_RETURN_HANDLER_RTX  aarch64_eh_return_handler_rtx ()\n \n-/* Don't use __builtin_setjmp until we've defined it.  */\n-#undef DONT_USE_BUILTIN_SETJMP\n-#define DONT_USE_BUILTIN_SETJMP 1\n-\n #undef TARGET_COMPUTE_FRAME_LAYOUT\n #define TARGET_COMPUTE_FRAME_LAYOUT aarch64_layout_frame\n "}, {"sha": "f2e3d905dbbeb2949f2947f5cfd68208c94c9272", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -4514,8 +4514,8 @@\n )\n \n (define_insn \"*and<mode>3_compare0\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (match_operand:GPI 1 \"register_operand\" \"%r,r\")\n \t\t  (match_operand:GPI 2 \"aarch64_logical_operand\" \"r,<lconst>\"))\n \t (const_int 0)))\n@@ -4530,8 +4530,8 @@\n \n ;; zero_extend version of above\n (define_insn \"*andsi3_compare0_uxtw\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n \t\t (match_operand:SI 2 \"aarch64_logical_operand\" \"r,K\"))\n \t (const_int 0)))\n@@ -4545,8 +4545,8 @@\n )\n \n (define_insn \"*and_<SHIFT:optab><mode>3_compare0\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (SHIFT:GPI\n \t\t   (match_operand:GPI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:QI 2 \"aarch64_shift_imm_<mode>\" \"n\"))\n@@ -4565,8 +4565,8 @@\n \n ;; zero_extend version of above\n (define_insn \"*and_<SHIFT:optab>si3_compare0_uxtw\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:SI (SHIFT:SI\n \t\t  (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t  (match_operand:QI 2 \"aarch64_shift_imm_si\" \"n\"))\n@@ -4770,8 +4770,8 @@\n )\n \n (define_insn \"*and_one_cmpl<mode>3_compare0\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (not:GPI\n \t\t   (match_operand:GPI 1 \"register_operand\" \"r\"))\n \t\t  (match_operand:GPI 2 \"register_operand\" \"r\"))\n@@ -4785,8 +4785,8 @@\n \n ;; zero_extend version of above\n (define_insn \"*and_one_cmplsi3_compare0_uxtw\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:SI (not:SI\n \t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (match_operand:SI 2 \"register_operand\" \"r\"))\n@@ -4799,8 +4799,8 @@\n )\n \n (define_insn \"*and_one_cmpl<mode>3_compare0_no_reuse\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-    (compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+    (compare:CC_NZV\n      (and:GPI (not:GPI\n            (match_operand:GPI 0 \"register_operand\" \"r\"))\n           (match_operand:GPI 1 \"register_operand\" \"r\"))\n@@ -4878,8 +4878,8 @@\n )\n \n (define_insn \"*and_one_cmpl_<SHIFT:optab><mode>3_compare0\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (not:GPI\n \t\t   (SHIFT:GPI\n \t\t    (match_operand:GPI 1 \"register_operand\" \"r\")\n@@ -4901,8 +4901,8 @@\n \n ;; zero_extend version of above\n (define_insn \"*and_one_cmpl_<SHIFT:optab>si3_compare0_uxtw\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:SI (not:SI\n \t\t  (SHIFT:SI\n \t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -4923,8 +4923,8 @@\n )\n \n (define_insn \"*and_one_cmpl_<SHIFT:optab><mode>3_compare0_no_reuse\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-    (compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+    (compare:CC_NZV\n      (and:GPI (not:GPI\n            (SHIFT:GPI\n             (match_operand:GPI 0 \"register_operand\" \"r\")\n@@ -5029,8 +5029,8 @@\n \")\n \n (define_insn \"*and<mode>_compare0\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_Z CC_REGNUM)\n+\t(compare:CC_Z\n \t (match_operand:SHORT 0 \"register_operand\" \"r\")\n \t (const_int 0)))]\n   \"\"\n@@ -5039,8 +5039,8 @@\n )\n \n (define_insn \"*ands<GPI:mode>_compare0\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_Z CC_REGNUM)\n+\t(compare:CC_Z\n \t (zero_extend:GPI (match_operand:SHORT 1 \"register_operand\" \"r\"))\n \t (const_int 0)))\n    (set (match_operand:GPI 0 \"register_operand\" \"=r\")\n@@ -5051,8 +5051,8 @@\n )\n \n (define_insn \"*and<mode>3nr_compare0\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (match_operand:GPI 0 \"register_operand\" \"%r,r\")\n \t\t  (match_operand:GPI 1 \"aarch64_logical_operand\" \"r,<lconst>\"))\n \t (const_int 0)))]\n@@ -5064,24 +5064,24 @@\n )\n \n (define_split\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (match_operand:GPI 0 \"register_operand\")\n \t\t  (match_operand:GPI 1 \"aarch64_mov_imm_operand\"))\n \t (const_int 0)))\n    (clobber (match_operand:SI 2 \"register_operand\"))]\n   \"\"\n   [(set (match_dup 2) (match_dup 1))\n-   (set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+   (set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (match_dup 0)\n \t\t  (match_dup 2))\n \t (const_int 0)))]\n )\n \n (define_insn \"*and<mode>3nr_compare0_zextract\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_Z CC_REGNUM)\n+\t(compare:CC_Z\n \t (zero_extract:GPI (match_operand:GPI 0 \"register_operand\" \"r\")\n \t\t  (match_operand:GPI 1 \"const_int_operand\" \"n\")\n \t\t  (match_operand:GPI 2 \"const_int_operand\" \"n\"))\n@@ -5102,8 +5102,8 @@\n )\n \n (define_insn \"*and_<SHIFT:optab><mode>3nr_compare0\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (SHIFT:GPI\n \t\t   (match_operand:GPI 0 \"register_operand\" \"r\")\n \t\t   (match_operand:QI 1 \"aarch64_shift_imm_<mode>\" \"n\"))\n@@ -5119,8 +5119,8 @@\n )\n \n (define_split\n-  [(set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+  [(set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (SHIFT:GPI\n \t\t   (match_operand:GPI 0 \"register_operand\")\n \t\t   (match_operand:QI 1 \"aarch64_shift_imm_<mode>\"))\n@@ -5129,8 +5129,8 @@\n     (clobber (match_operand:SI 3 \"register_operand\"))]\n   \"\"\n   [(set (match_dup 3) (match_dup 2))\n-   (set (reg:CC_NZ CC_REGNUM)\n-\t(compare:CC_NZ\n+   (set (reg:CC_NZV CC_REGNUM)\n+\t(compare:CC_NZV\n \t (and:GPI (SHIFT:GPI\n \t\t   (match_dup 0)\n \t\t   (match_dup 1))\n@@ -6468,7 +6468,7 @@\n (define_expand \"<optab>dihf2\"\n   [(set (match_operand:HF 0 \"register_operand\")\n \t(FLOATUORS:HF (match_operand:DI 1 \"register_operand\")))]\n-  \"TARGET_FLOAT && (TARGET_FP_F16INST || TARGET_SIMD)\"\n+  \"TARGET_FP_F16INST || TARGET_SIMD\"\n {\n   if (TARGET_FP_F16INST)\n     emit_insn (gen_aarch64_fp16_<optab>dihf2 (operands[0], operands[1]));\n@@ -6727,7 +6727,7 @@\n   [(match_operand:GPF 0 \"register_operand\")\n    (match_operand:GPF 1 \"register_operand\")\n    (match_operand:GPF 2 \"register_operand\")]\n-  \"TARGET_FLOAT && TARGET_SIMD\"\n+  \"TARGET_SIMD\"\n {\n   rtx bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);\n   emit_move_insn (bitmask, GEN_INT (HOST_WIDE_INT_M1U\n@@ -6744,7 +6744,7 @@\n \t\t     (match_operand:GPF 2 \"register_operand\" \"w,w,0,0\")\n \t\t     (match_operand:<V_INT_EQUIV> 3 \"register_operand\" \"0,w,w,X\")]\n \t UNSPEC_COPYSIGN))]\n-  \"TARGET_FLOAT && TARGET_SIMD\"\n+  \"TARGET_SIMD\"\n   \"@\n    bsl\\\\t%0.<Vbtype>, %2.<Vbtype>, %1.<Vbtype>\n    bit\\\\t%0.<Vbtype>, %2.<Vbtype>, %3.<Vbtype>\n@@ -6765,7 +6765,7 @@\n   [(match_operand:GPF 0 \"register_operand\")\n    (match_operand:GPF 1 \"register_operand\")\n    (match_operand:GPF 2 \"register_operand\")]\n-  \"TARGET_FLOAT && TARGET_SIMD\"\n+  \"TARGET_SIMD\"\n {\n \n   machine_mode imode = <V_INT_EQUIV>mode;"}, {"sha": "b89b20450710592101b93f4f3b5dc33d152d1eb6", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -28,7 +28,10 @@ TargetVariable\n enum aarch64_arch selected_arch = aarch64_no_arch\n \n TargetVariable\n-uint64_t aarch64_isa_flags = 0\n+aarch64_feature_flags aarch64_asm_isa_flags = 0\n+\n+TargetVariable\n+aarch64_feature_flags aarch64_isa_flags = 0\n \n TargetVariable\n unsigned aarch64_enable_bti = 2"}, {"sha": "bc95f6d9d15f190a3e33704b4def2860d5f339bd", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -640,6 +640,23 @@\n   }\n )\n \n+(define_insn \"*atomic_load<ALLX:mode>_zext<SD_HSDI:mode>\"\n+  [(set (match_operand:SD_HSDI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SD_HSDI\n+\t  (unspec_volatile:ALLX\n+\t    [(match_operand:ALLX 1 \"aarch64_sync_memory_operand\" \"Q\")\n+\t     (match_operand:SI 2 \"const_int_operand\")]\t\t\t;; model\n+\t   UNSPECV_LDA)))]\n+  \"GET_MODE_SIZE (<SD_HSDI:MODE>mode) > GET_MODE_SIZE (<ALLX:MODE>mode)\"\n+  {\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))\n+      return \"ldr<ALLX:atomic_sfx>\\t%<ALLX:w>0, %1\";\n+    else\n+      return \"ldar<ALLX:atomic_sfx>\\t%<ALLX:w>0, %1\";\n+  }\n+)\n+\n (define_insn \"atomic_load<mode>\"\n   [(set (match_operand:ALLI 0 \"register_operand\" \"=r\")\n     (unspec_volatile:ALLI"}, {"sha": "a1d412cb7b40cec779691263d9f4319df9ac2710", "filename": "gcc/config/aarch64/driver-aarch64.cc", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -26,17 +26,17 @@\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"aarch64-protos.h\"\n+#include \"aarch64-feature-deps.h\"\n \n struct aarch64_arch_extension\n {\n   const char *ext;\n-  uint64_t flag;\n+  aarch64_feature_flags flag;\n   const char *feat_string;\n };\n \n-#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \\\n-\t\t\t      SYNTHETIC, FEATURE_STRING) \\\n-  { EXT_NAME, FLAG_CANONICAL, FEATURE_STRING },\n+#define AARCH64_OPT_EXTENSION(EXT_NAME, IDENT, C, D, E, FEATURE_STRING) \\\n+  { EXT_NAME, AARCH64_FL_##IDENT, FEATURE_STRING },\n static struct aarch64_arch_extension aarch64_extensions[] =\n {\n #include \"aarch64-option-extensions.def\"\n@@ -50,7 +50,7 @@ struct aarch64_core_data\n   unsigned char implementer_id; /* Exactly 8 bits */\n   unsigned int part_no; /* 12 bits + 12 bits */\n   unsigned variant;\n-  const uint64_t flags;\n+  aarch64_feature_flags flags;\n };\n \n #define AARCH64_BIG_LITTLE(BIG, LITTLE) \\\n@@ -62,9 +62,9 @@ struct aarch64_core_data\n #define DEFAULT_ARCH \"8A\"\n \n #define AARCH64_CORE(CORE_NAME, CORE_IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART, VARIANT) \\\n-  { CORE_NAME, #ARCH, IMP, PART, VARIANT, FLAGS },\n+  { CORE_NAME, #ARCH, IMP, PART, VARIANT, feature_deps::cpu_##CORE_IDENT },\n \n-static struct aarch64_core_data aarch64_cpu_data[] =\n+static CONSTEXPR const aarch64_core_data aarch64_cpu_data[] =\n {\n #include \"aarch64-cores.def\"\n   { NULL, NULL, INVALID_IMP, INVALID_CORE, ALL_VARIANTS, 0 }\n@@ -75,13 +75,14 @@ struct aarch64_arch_driver_info\n {\n   const char* id;\n   const char* name;\n-  const uint64_t flags;\n+  aarch64_feature_flags flags;\n };\n \n+/* Skip the leading \"V\" in the architecture name.  */\n #define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH_REV, FLAGS) \\\n-  { #ARCH_IDENT, NAME, FLAGS },\n+  { #ARCH_IDENT + 1, NAME, feature_deps::ARCH_IDENT ().enable },\n \n-static struct aarch64_arch_driver_info aarch64_arches[] =\n+static CONSTEXPR const aarch64_arch_driver_info aarch64_arches[] =\n {\n #include \"aarch64-arches.def\"\n   {NULL, NULL, 0}\n@@ -91,7 +92,7 @@ static struct aarch64_arch_driver_info aarch64_arches[] =\n /* Return an aarch64_arch_driver_info for the architecture described\n    by ID, or NULL if ID describes something we don't know about.  */\n \n-static struct aarch64_arch_driver_info*\n+static const aarch64_arch_driver_info *\n get_arch_from_id (const char* id)\n {\n   unsigned int i = 0;\n@@ -202,9 +203,9 @@ readline (FILE *f)\n \treturn std::string ();\n       /* If we're not at the end of the line then override the\n \t \\0 added by fgets.  */\n-      last = strnlen (buf, size) - 1;\n+      last = strnlen (buf, size);\n     }\n-  while (!feof (f) && buf[last] != '\\n');\n+  while (!feof (f) && last > 0 && buf[last - 1] != '\\n');\n \n   std::string result (buf);\n   free (buf);\n@@ -260,8 +261,8 @@ host_detect_local_cpu (int argc, const char **argv)\n   unsigned int variants[2] = { ALL_VARIANTS, ALL_VARIANTS };\n   unsigned int n_variants = 0;\n   bool processed_exts = false;\n-  uint64_t extension_flags = 0;\n-  uint64_t default_flags = 0;\n+  aarch64_feature_flags extension_flags = 0;\n+  aarch64_feature_flags default_flags = 0;\n   std::string buf;\n   size_t sep_pos = -1;\n   char *fcpu_info;\n@@ -395,8 +396,7 @@ host_detect_local_cpu (int argc, const char **argv)\n \n       if (aarch64_cpu_data[i].name == NULL)\n \t{\n-\t  aarch64_arch_driver_info* arch_info\n-\t    = get_arch_from_id (DEFAULT_ARCH);\n+\t  auto arch_info = get_arch_from_id (DEFAULT_ARCH);\n \n \t  gcc_assert (arch_info);\n \n@@ -406,7 +406,7 @@ host_detect_local_cpu (int argc, const char **argv)\n       else if (arch)\n \t{\n \t  const char *arch_id = aarch64_cpu_data[i].arch;\n-\t  aarch64_arch_driver_info* arch_info = get_arch_from_id (arch_id);\n+\t  auto arch_info = get_arch_from_id (arch_id);\n \n \t  /* We got some arch indentifier that's not in aarch64-arches.def?  */\n \t  if (!arch_info)"}, {"sha": "a8ad4e5ff215ade06c3ca13a24ef18d259afcb6c", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -3138,6 +3138,8 @@\n \n (define_int_iterator SVE_BRK_UNARY [UNSPEC_BRKA UNSPEC_BRKB])\n \n+(define_int_iterator SVE_BRKP [UNSPEC_BRKPA UNSPEC_BRKPB])\n+\n (define_int_iterator SVE_BRK_BINARY [UNSPEC_BRKN UNSPEC_BRKPA UNSPEC_BRKPB])\n \n (define_int_iterator SVE_PITER [UNSPEC_PFIRST UNSPEC_PNEXT])"}, {"sha": "e672bb313ac0addf6768c90c075f579cc39fb740", "filename": "gcc/config/aarch64/t-aarch64-vxworks", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Ft-aarch64-vxworks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Faarch64%2Ft-aarch64-vxworks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64-vxworks?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -20,3 +20,8 @@\n \n MULTILIB_OPTIONS += mrtp\n MULTILIB_DIRNAMES += mrtp\n+\n+# Setup a separate multilib for mcmodel=large, for which\n+# we may not have shared lib support unlike with -mrtp alone.\n+MULTILIB_OPTIONS += mcmodel=large\n+MULTILIB_DIRNAMES += large"}, {"sha": "333f2c602c45871ba4562f14941118f4dbf64187", "filename": "gcc/config/alpha/alpha.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Falpha%2Falpha.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Falpha%2Falpha.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -6084,8 +6084,9 @@ alpha_setup_incoming_varargs (cumulative_args_t pcum,\n {\n   CUMULATIVE_ARGS cum = *get_cumulative_args (pcum);\n \n-  /* Skip the current argument.  */\n-  targetm.calls.function_arg_advance (pack_cumulative_args (&cum), arg);\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl)))\n+    /* Skip the current argument.  */\n+    targetm.calls.function_arg_advance (pack_cumulative_args (&cum), arg);\n \n #if TARGET_ABI_OPEN_VMS\n   /* For VMS, we allocate space for all 6 arg registers plus a count."}, {"sha": "604a116e966ddaaddc3908c29283edc1f86c35af", "filename": "gcc/config/arc/arc.cc", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Farc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Farc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2450,7 +2450,8 @@ arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n   /* We must treat `__builtin_va_alist' as an anonymous arg.  */\n \n   next_cum = *get_cumulative_args (args_so_far);\n-  arc_function_arg_advance (pack_cumulative_args (&next_cum), arg);\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl)))\n+    arc_function_arg_advance (pack_cumulative_args (&next_cum), arg);\n   first_anon_arg = next_cum;\n \n   if (FUNCTION_ARG_REGNO_P (first_anon_arg))\n@@ -2474,6 +2475,20 @@ arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n     }\n }\n \n+/* Return TRUE if reg is ok for short instrcutions.  */\n+\n+static bool\n+arc_check_short_reg_p (rtx op)\n+{\n+  if (!REG_P (op))\n+    return false;\n+\n+  if (IN_RANGE (REGNO (op) ^ 4, 4, 11))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Cost functions.  */\n \n /* Provide the costs of an addressing mode that contains ADDR.\n@@ -2485,7 +2500,7 @@ arc_address_cost (rtx addr, machine_mode, addr_space_t, bool speed)\n   switch (GET_CODE (addr))\n     {\n     case REG :\n-      return speed || satisfies_constraint_Rcq (addr) ? 0 : 1;\n+      return speed || arc_check_short_reg_p (addr) ? 0 : 1;\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n     case PRE_MODIFY: case POST_MODIFY:\n       return !speed;\n@@ -2517,14 +2532,14 @@ arc_address_cost (rtx addr, machine_mode, addr_space_t, bool speed)\n \t\t    ? COSTS_N_INSNS (1)\n \t\t    : speed\n \t\t    ? 0\n-\t\t    : (satisfies_constraint_Rcq (plus0)\n+\t\t    : (arc_check_short_reg_p (plus0)\n \t\t       && satisfies_constraint_O (plus1))\n \t\t    ? 0\n \t\t    : 1);\n \t  case REG:\n \t    return (speed < 1 ? 0\n-\t\t    : (satisfies_constraint_Rcq (plus0)\n-\t\t       && satisfies_constraint_Rcq (plus1))\n+\t\t    : (arc_check_short_reg_p (plus0)\n+\t\t       && arc_check_short_reg_p (plus1))\n \t\t    ? 0 : 1);\n \t  case CONST :\n \t  case SYMBOL_REF :\n@@ -3356,7 +3371,7 @@ arc_save_callee_enter (uint64_t gmask,\n       reg = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n       mem = gen_frame_mem (Pmode, plus_constant (Pmode,\n \t\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t\t off));\n+\t\t\t\t\t\t -off));\n       XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, reg);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n       off -= UNITS_PER_WORD;\n@@ -3370,7 +3385,7 @@ arc_save_callee_enter (uint64_t gmask,\n       reg = gen_rtx_REG (SImode, regno);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n \t\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t\t  off));\n+\t\t\t\t\t\t  -off));\n       XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, reg);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n       gmask = gmask & ~(1ULL << regno);\n@@ -3380,7 +3395,7 @@ arc_save_callee_enter (uint64_t gmask,\n     {\n       mem = gen_frame_mem (Pmode, plus_constant (Pmode,\n \t\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t\t off));\n+\t\t\t\t\t\t -off));\n       XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, hard_frame_pointer_rtx);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n       off -= UNITS_PER_WORD;\n@@ -9003,8 +9018,8 @@ arc_output_addsi (rtx *operands, bool cond_p, bool output_p)\n   int intval = (REG_P (operands[2]) ? 1\n \t\t: CONST_INT_P (operands[2]) ? INTVAL (operands[2]) : 0xbadc057);\n   int neg_intval = -intval;\n-  int short_0 = satisfies_constraint_Rcq (operands[0]);\n-  int short_p = (!cond_p && short_0 && satisfies_constraint_Rcq (operands[1]));\n+  int short_0 = arc_check_short_reg_p (operands[0]);\n+  int short_p = (!cond_p && short_0 && arc_check_short_reg_p (operands[1]));\n   int ret = 0;\n \n #define REG_H_P(OP) (REG_P (OP) && ((TARGET_V2 && REGNO (OP) <= 31\t\\\n@@ -9037,7 +9052,7 @@ arc_output_addsi (rtx *operands, bool cond_p, bool output_p)\n \t patterns.  */\n       if (short_p\n \t  && ((REG_H_P (operands[2])\n-\t       && (match || satisfies_constraint_Rcq (operands[2])))\n+\t       && (match || arc_check_short_reg_p (operands[2])))\n \t      || (CONST_INT_P (operands[2])\n \t\t  && ((unsigned) intval <= (match ? 127 : 7)))))\n \tADDSI_OUTPUT1 (\"add%? %0,%1,%2 ;1\");\n@@ -9064,7 +9079,7 @@ arc_output_addsi (rtx *operands, bool cond_p, bool output_p)\n       /* Generate add_s r0,b,u6; add_s r1,b,u6 patterns.  */\n       if (TARGET_CODE_DENSITY && REG_P (operands[0]) && REG_P (operands[1])\n \t  && ((REGNO (operands[0]) == 0) || (REGNO (operands[0]) == 1))\n-\t  && satisfies_constraint_Rcq (operands[1])\n+\t  && arc_check_short_reg_p (operands[1])\n \t  && satisfies_constraint_L (operands[2]))\n \tADDSI_OUTPUT1 (\"add%? %0,%1,%2 ;6\");\n     }\n@@ -10033,7 +10048,7 @@ split_addsi (rtx *operands)\n   /* Try for two short insns first.  Lengths being equal, we prefer\n      expansions with shorter register lifetimes.  */\n   if (val > 127 && val <= 255\n-      && satisfies_constraint_Rcq (operands[0]))\n+      && arc_check_short_reg_p (operands[0]))\n     {\n       operands[3] = operands[2];\n       operands[4] = gen_rtx_PLUS (SImode, operands[0], operands[1]);\n@@ -10057,8 +10072,8 @@ split_subsi (rtx *operands)\n \n   /* Try for two short insns first.  Lengths being equal, we prefer\n      expansions with shorter register lifetimes.  */\n-  if (satisfies_constraint_Rcq (operands[0])\n-      && satisfies_constraint_Rcq (operands[2]))\n+  if (arc_check_short_reg_p (operands[0])\n+      && arc_check_short_reg_p (operands[2]))\n     {\n       if (val >= -31 && val <= 127)\n \t{\n@@ -10436,12 +10451,12 @@ arc_lra_p (void)\n   return arc_lra_flag;\n }\n \n-/* ??? Should we define TARGET_REGISTER_PRIORITY?  We might perfer to use\n-   Rcq registers, because some insn are shorter with them.  OTOH we already\n-   have separate alternatives for this purpose, and other insns don't\n-   mind, so maybe we should rather prefer the other registers?\n-   We need more data, and we can only get that if we allow people to\n-   try all options.  */\n+/* ??? Should we define TARGET_REGISTER_PRIORITY?  We might perfer to\n+   use q registers, because some insn are shorter with them.  OTOH we\n+   already have separate alternatives for this purpose, and other\n+   insns don't mind, so maybe we should rather prefer the other\n+   registers?  We need more data, and we can only get that if we allow\n+   people to try all options.  */\n static int\n arc_register_priority (int r)\n {"}, {"sha": "458d3edf716c640dad3a9410c915120f3443c40d", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 183, "deletions": 189, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -696,15 +696,13 @@ archs4x, archs4xd\"\n ; In order to allow the ccfsm machinery to do its work, the leading compact\n ; alternatives say 'canuse' - there is another alternative that will match\n ; when the condition codes are used.\n-; Rcq won't match if the condition is actually used; to avoid a spurious match\n-; via q, q is inactivated as constraint there.\n ; Likewise, the length of an alternative that might be shifted to conditional\n ; execution must reflect this, lest out-of-range branches are created.\n ; The iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n (define_insn \"*movqi_insn\"\n-  [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h, w, w,???w,h, w,Rcq,  S,!*x,  r,r, Ucm,m,???m,  m,Usc\")\n-\t(match_operand:QI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1,cL, I,?Rac,i,?i,  T,Rcq,Usd,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n+  [(set (match_operand:QI 0 \"move_dest_operand\" \"=q, q,r,q,   h, w, w,???w,h, w,q,S,!*x,  r,r, Ucm,m,???m,  m,Usc\")\n+\t(match_operand:QI 1 \"move_src_operand\"  \"rL,rP,q,P,hCm1,cL, I,?Rac,i,?i,T,q,Usd,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n   \"register_operand (operands[0], QImode)\n    || register_operand (operands[1], QImode)\n    || (satisfies_constraint_Cm3 (operands[1])\n@@ -742,8 +740,8 @@ archs4x, archs4xd\"\n   \"if (prepare_move_operands (operands, HImode)) DONE;\")\n \n (define_insn \"*movhi_insn\"\n-  [(set (match_operand:HI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h, w, w,???w,Rcq#q,h, w,Rcq,  S,  r,r, Ucm,m,???m,  m,VUsc\")\n-\t(match_operand:HI 1 \"move_src_operand\" \"   cL,   cP,Rcq#q,    P,hCm1,cL, I,?Rac,    i,i,?i,  T,Rcq,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n+  [(set (match_operand:HI 0 \"move_dest_operand\" \"=q, q,r,q,   h, w, w,???w,q,h, w,q,S,  r,r, Ucm,m,???m,  m,VUsc\")\n+\t(match_operand:HI 1 \"move_src_operand\" \" rL,rP,q,P,hCm1,cL, I,?Rac,i,i,?i,T,q,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n   \"register_operand (operands[0], HImode)\n    || register_operand (operands[1], HImode)\n    || (CONSTANT_P (operands[1])\n@@ -793,8 +791,8 @@ archs4x, archs4xd\"\n ; the iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n (define_insn_and_split \"*movsi_insn\"\t\t; 0  1 2 3    4   5 6   7   8   9  10  11  12  13  14  15  16    17      18  19  20    21   22 23  24   25 26  27  28\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=q, q,r,q,   h, rl,r,  r,  r,  r, ?r,  r,  q,  h, rl,  q,  S,   Us<,RcqRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,  m,VUsc\")\n-\t(match_operand:SI 1 \"move_src_operand\"  \"rL,rP,q,P,hCm1,rLl,I,Clo,Chi,Cbi,Cpc,Clb,Cax,Cal,Cal,Uts,Rcq,RcqRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  r,!*Rzd,r,Cm3, C32\"))]\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=q, q,r,q,   h, rl,r,  r,  r,  r, ?r,  r,  q,  h, rl,  q,  S,   Us<,qRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,  m,VUsc\")\n+\t(match_operand:SI 1 \"move_src_operand\"  \"rL,rP,q,P,hCm1,rLl,I,Clo,Chi,Cbi,Cpc,Clb,Cax,Cal,Cal,Uts,q,qRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  r,!*Rzd,r,Cm3, C32\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\n    || (CONSTANT_P (operands[1])\n@@ -998,8 +996,8 @@ archs4x, archs4xd\"\n      (match_operand 0 \"cc_register\" \"\")\n      (match_operator 4 \"zn_compare_operator\"\n        [(and:SI\n-\t  (match_operand:SI 1 \"register_operand\"  \"%Rcq,Rcq, c,  c,  c,  c,Rrq,Rrq,  c\")\n-\t  (match_operand:SI 2 \"nonmemory_operand\"  \"Rcq,C0p,cI,C1p,Ccp,Chs,Cbf,Cbf,???Cal\"))\n+\t  (match_operand:SI 1 \"register_operand\"  \"%q,  q, c,  c,  c,  c,  q,  q,  c\")\n+\t  (match_operand:SI 2 \"nonmemory_operand\"  \"q,C0p,cI,C1p,Ccp,Chs,Cbf,Cbf,???Cal\"))\n \t(const_int 0)]))\n    (clobber (match_scratch:SI 3 \"=X,X,X,X,X,X,Rrq,1,c\"))]\n   \"TARGET_NPS_BITOPS\"\n@@ -1014,9 +1012,9 @@ archs4x, archs4xd\"\n      (match_operator 3 \"zn_compare_operator\"\n        [(and:SI\n \t  (match_operand:SI 1 \"register_operand\"\n-\t   \"%Rcq,Rcq, c, c, c,  c,  c,  c\")\n+\t   \"%q,  q, c, c, c,  c,  c,  c\")\n \t  (match_operand:SI 2 \"nonmemory_operand\"\n-\t   \" Rcq,C0p,cI,cL,C1p,Ccp,Chs,Cal\"))\n+\t   \" q,C0p,cI,cL,C1p,Ccp,Chs,Cal\"))\n \t(const_int 0)]))]\n   \"reload_completed\n    || !satisfies_constraint_Cbf (operands[2])\n@@ -1092,9 +1090,9 @@ archs4x, archs4xd\"\n   [(set (match_operand:CC_ZN 0 \"cc_set_register\" \"\")\n \t(match_operator 5 \"zn_compare_operator\"\n \t  [(zero_extract:SI\n-\t     (match_operand:SI 1 \"register_operand\" \"%Rcqq,c,  c,Rrq,c\")\n-\t     (match_operand:SI 2 \"const_int_operand\"    \"N,N,  n,Cbn,n\")\n-\t     (match_operand:SI 3 \"const_int_operand\"    \"n,n,C_0,Cbn,n\"))\n+\t     (match_operand:SI 1 \"register_operand\" \"%q,c,  c,Rrq,c\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"N,N,  n,Cbn,n\")\n+\t     (match_operand:SI 3 \"const_int_operand\" \"n,n,C_0,Cbn,n\"))\n \t   (const_int 0)]))\n    (clobber (match_scratch:SI 4 \"=X,X,X,Rrq,X\"))]\n   \"\"\n@@ -1678,7 +1676,7 @@ archs4x, archs4xd\"\n   \"\"\n {\n   if (rtx_equal_p (operands[1], const0_rtx) && GET_CODE (operands[3]) == NE\n-      && satisfies_constraint_Rcq (operands[0]))\n+      && IN_RANGE (REGNO (operands[0]) ^ 4, 4, 11))\n     return \"sub%?.ne %0,%0,%0\";\n   /* ??? might be good for speed on ARC600 too, *if* properly scheduled.  */\n   if ((optimize_size && (!TARGET_ARC600_FAMILY))\n@@ -1980,8 +1978,8 @@ archs4x, archs4xd\"\n ;; Absolute instructions\n \n (define_insn \"abssi2\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcq#q,w,w\")\n-\t(abs:SI (match_operand:SI 1 \"nonmemory_operand\" \"Rcq#q,cL,Cal\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=q,w,w\")\n+\t(abs:SI (match_operand:SI 1 \"nonmemory_operand\" \"q,cL,Cal\")))]\n   \"\"\n   \"abs%? %0,%1%&\"\n   [(set_attr \"type\" \"two_cycle_core\")\n@@ -1991,22 +1989,22 @@ archs4x, archs4xd\"\n ;; Maximum and minimum insns\n \n (define_insn \"smaxsi3\"\n-   [(set (match_operand:SI 0 \"dest_reg_operand\"         \"=Rcw, w,  w\")\n-\t (smax:SI (match_operand:SI 1 \"register_operand\"  \"%0, c,  c\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"cL,cL,Cal\")))]\n+   [(set (match_operand:SI 0 \"dest_reg_operand\"           \"=r, r,  r\")\n+\t (smax:SI (match_operand:SI 1 \"register_operand\"  \"%0, r,  r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rL,rL,Cal\")))]\n   \"\"\n-  \"max%? %0,%1,%2\"\n+  \"max%?\\\\t%0,%1,%2\"\n   [(set_attr \"type\" \"two_cycle_core\")\n    (set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")]\n )\n \n (define_insn \"sminsi3\"\n-   [(set (match_operand:SI 0 \"dest_reg_operand\"         \"=Rcw, w,  w\")\n-\t (smin:SI (match_operand:SI 1 \"register_operand\"  \"%0, c,  c\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"cL,cL,Cal\")))]\n+   [(set (match_operand:SI 0 \"dest_reg_operand\"           \"=r, r,  r\")\n+\t (smin:SI (match_operand:SI 1 \"register_operand\"  \"%0, r,  r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rL,rL,Cal\")))]\n   \"\"\n-  \"min%? %0,%1,%2\"\n+  \"min%?\\\\t%0,%1,%2\"\n   [(set_attr \"type\" \"two_cycle_core\")\n    (set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")]\n@@ -2028,10 +2026,10 @@ archs4x, archs4xd\"\n ; We avoid letting this pattern use LP_COUNT as a register by specifying\n ;  register class 'W' instead of 'w'.\n (define_insn_and_split \"*addsi3_mixed\"\n-  ;;                                                      0       1    2    3   4   5   6     7    8   9   a    b     c   d e   f  10  11  12\n-  [(set (match_operand:SI 0 \"dest_reg_operand\"          \"=Rcq#q,Rcq,   h,!*Rsd,Rcq,Rcb,Rcq, Rcqq,Rcqq,Rcw,Rcw, Rcw,    W,  W,W,  W,Rcqq,Rcw,  W\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,      c,   0, Rcqq,  0,  0,Rcb, Rcqq,   0,  0,  c,   0,    c,  c,0,  0,   0,  0,  c\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"cL,     0, Cm1,    L,CL2,Csp,CM4,RcqqK,  cO, cL,  0,cCca,cLCmL,Cca,I,C2a, Cal,Cal,Cal\")))]\n+  ;;                                                      0  1    2     3   4   5   6  7  8  9 a    b     c   d e   f  10  11  12\n+  [(set (match_operand:SI 0 \"dest_reg_operand\"           \"=q,q,   h,!*Rsd,  q,Rcb,  q, q, q, r,r,   r,    W,  W,W,  W,  q,  r,  W\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0,c,   0,    q,  0,  0,Rcb, q, 0, 0,r,   0,    c,  c,0,  0,  0,  0,  c\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"cL,0, Cm1,    L,CL2,Csp,CM4,qK,cO,rL,0,rCca,cLCmL,Cca,I,C2a,Cal,Cal,Cal\")))]\n   \"\"\n {\n   arc_output_addsi (operands, arc_ccfsm_cond_exec_p (), true);\n@@ -2083,9 +2081,9 @@ archs4x, archs4xd\"\n    ])\n \n (define_insn \"mulhisi3_reg\"\n-  [(set (match_operand:SI 0 \"register_operand\"                          \"=Rcqq,r,r\")\n-\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\"  \"   0,0,r\"))\n-\t\t (sign_extend:SI (match_operand:HI 2 \"nonmemory_operand\" \"Rcqq,r,r\"))))]\n+  [(set (match_operand:SI 0 \"register_operand\"                          \"=q,r,r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\"  \"0,0,r\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"nonmemory_operand\" \"q,r,r\"))))]\n   \"TARGET_MPYW\"\n   \"mpyw%? %0,%1,%2\"\n   [(set_attr \"length\" \"*,4,4\")\n@@ -2123,9 +2121,9 @@ archs4x, archs4xd\"\n    ])\n \n (define_insn \"umulhisi3_reg\"\n-  [(set (match_operand:SI 0 \"register_operand\"                          \"=Rcqq, r, r\")\n-\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"   %0, 0, r\"))\n-\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \" Rcqq, r, r\"))))]\n+  [(set (match_operand:SI 0 \"register_operand\"                          \"=q, r, r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0, 0, r\"))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\"  \"q, r, r\"))))]\n   \"TARGET_MPYW\"\n   \"mpyuw%? %0,%1,%2\"\n   [(set_attr \"length\" \"*,4,4\")\n@@ -2246,8 +2244,8 @@ archs4x, archs4xd\"\n \n (define_insn \"mulsi_600\"\n   [(set (match_operand:SI 2 \"mlo_operand\" \"\")\n-\t(mult:SI (match_operand:SI 0 \"register_operand\"  \"%Rcq#q,c,c,c\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"Rcq#q,cL,I,Cal\")))\n+\t(mult:SI (match_operand:SI 0 \"register_operand\" \"%q,c,c,c\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"q,cL,I,Cal\")))\n    (clobber (match_operand:SI 3 \"mhi_operand\" \"\"))]\n   \"TARGET_MUL64_SET\"\n   \"mul64%?\\\\t0,%0,%1\"\n@@ -2282,8 +2280,8 @@ archs4x, archs4xd\"\n (define_insn \"mul64\"\n   [(set (reg:DI MUL64_OUT_REG)\n \t(mult:DI\n-\t (sign_extend:DI (match_operand:SI 0 \"register_operand\" \"%Rcq#q, c,c,  c\"))\n-\t (sign_extend:DI (match_operand:SI 1 \"nonmemory_operand\" \"Rcq#q,cL,L,C32\"))))]\n+\t (sign_extend:DI (match_operand:SI 0 \"register_operand\" \"%q, c,c,  c\"))\n+\t (sign_extend:DI (match_operand:SI 1 \"nonmemory_operand\" \"q,cL,L,C32\"))))]\n   \"TARGET_MUL64_SET\"\n   \"mul64%? \\t0, %0, %1%&\"\n   [(set_attr \"length\" \"*,4,4,8\")\n@@ -2336,11 +2334,11 @@ archs4x, archs4xd\"\n ; registers, since it cannot be the destination of a multi-cycle insn\n ; like MPY or MPYU.\n (define_insn \"mulsi3_700\"\n- [(set (match_operand:SI 0 \"mpy_dest_reg_operand\"        \"=Rcr,r,r,Rcr,r\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\"  \"%0,c,0,0,c\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"cL,cL,I,Cal,Cal\")))]\n+ [(set (match_operand:SI 0 \"mpy_dest_reg_operand\"        \"=r, r,r,  r,r\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\"  \"%0, r,0,  0,r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rL,rL,I,Cal,Cal\")))]\n  \"TARGET_ARC700_MPY\"\n-  \"mpyu%? %0,%1,%2\"\n+  \"mpyu%?\\\\t%0,%1,%2\"\n   [(set_attr \"length\" \"4,4,4,8,8\")\n    (set_attr \"type\" \"umulti\")\n    (set_attr \"predicable\" \"yes,no,no,yes,no\")\n@@ -2501,15 +2499,15 @@ archs4x, archs4xd\"\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"register_operand\"                  \"=Rcr,r,Rcr,r\")\n+  [(set (match_operand:SI 0 \"register_operand\"                    \"=r,r,r,r\")\n \t(truncate:SI\n \t (lshiftrt:DI\n \t  (mult:DI\n-\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,c,  0,c\"))\n-\t   (sign_extend:DI (match_operand:SI 2 \"extend_operand\"    \"c,c,  i,i\")))\n+\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,r,0,r\"))\n+\t   (sign_extend:DI (match_operand:SI 2 \"extend_operand\"    \"r,r,i,i\")))\n \t  (const_int 32))))]\n   \"TARGET_MPY\"\n-  \"mpy%+%? %0,%1,%2\"\n+  \"mpy%+%?\\\\t%0,%1,%2\"\n   [(set_attr \"length\" \"4,4,8,8\")\n    (set_attr \"type\" \"multi\")\n    (set_attr \"predicable\" \"yes,no,yes,no\")\n@@ -2518,15 +2516,15 @@ archs4x, archs4xd\"\n ; Note that mpyhu has the same latency as mpy / mpyh,\n ; thus we use the type multi.\n (define_insn \"*umulsi3_highpart_i\"\n-  [(set (match_operand:SI 0 \"register_operand\"                  \"=Rcr,r,Rcr,r\")\n+  [(set (match_operand:SI 0 \"register_operand\"                    \"=r,r,r,r\")\n \t(truncate:SI\n \t (lshiftrt:DI\n \t  (mult:DI\n-\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,c,  0,c\"))\n-\t   (zero_extend:DI (match_operand:SI 2 \"extend_operand\"    \"c,c,  i,i\")))\n+\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,r,0,r\"))\n+\t   (zero_extend:DI (match_operand:SI 2 \"extend_operand\"    \"r,r,i,i\")))\n \t  (const_int 32))))]\n   \"TARGET_MPY\"\n-  \"mpy%+u%? %0,%1,%2\"\n+  \"mpy%+u%?\\\\t%0,%1,%2\"\n   [(set_attr \"length\" \"4,4,8,8\")\n    (set_attr \"type\" \"multi\")\n    (set_attr \"predicable\" \"yes,no,yes,no\")\n@@ -2536,15 +2534,15 @@ archs4x, archs4xd\"\n ;; need a separate pattern for immediates\n ;; ??? This is fine for combine, but not for reload.\n (define_insn \"umulsi3_highpart_int\"\n-  [(set (match_operand:SI 0 \"register_operand\"            \"=Rcr, r, r,Rcr,  r\")\n+  [(set (match_operand:SI 0 \"register_operand\"            \"=r, r, r,r,  r\")\n \t(truncate:SI\n \t (lshiftrt:DI\n \t  (mult:DI\n-\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\"  \" 0, c, 0,  0,  c\"))\n-\t   (match_operand:DI 2 \"immediate_usidi_operand\" \"L, L, I, Cal, Cal\"))\n+\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\"  \" 0, r, 0,  0,  r\"))\n+\t   (match_operand:DI 2 \"immediate_usidi_operand\" \"L, L, I,Cal,Cal\"))\n \t  (const_int 32))))]\n   \"TARGET_MPY\"\n-  \"mpy%+u%? %0,%1,%2\"\n+  \"mpy%+u%?\\\\t%0,%1,%2\"\n   [(set_attr \"length\" \"4,4,4,8,8\")\n    (set_attr \"type\" \"multi\")\n    (set_attr \"predicable\" \"yes,no,no,yes,no\")\n@@ -2792,13 +2790,13 @@ archs4x, archs4xd\"\n (define_insn \"*add_f_2\"\n   [(set (reg:CC_C CC_REG)\n \t(compare:CC_C\n-\t  (plus:SI (match_operand:SI 1 \"register_operand\" \"c,0,c\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cL,I,cCal\"))\n+\t  (plus:SI (match_operand:SI 1 \"register_operand\"  \"r ,0,r\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"rL,I,rCal\"))\n \t  (match_dup 2)))\n-   (set (match_operand:SI 0 \"dest_reg_operand\" \"=w,Rcw,w\")\n+   (set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"add.f %0,%1,%2\"\n+  \"add.f\\\\t%0,%1,%2\"\n   [(set_attr \"cond\" \"set\")\n    (set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,4,8\")])\n@@ -2895,22 +2893,22 @@ archs4x, archs4xd\"\n ; the casesi expander might generate a sub of zero, so we have to recognize it.\n ; combine should make such an insn go away.\n (define_insn_and_split \"subsi3_insn\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\"           \"=Rcqq,Rcqq,Rcw,Rcw,w,w,w,  w,  w,  w\")\n-\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\"    \"0,Rcqq,  0, cL,c,L,I,Cal,Cal,  c\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"Rcqq,Rcqq,  c,  0,c,c,0,  0,  c,Cal\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\"           \"=q,q,r, r,r,r,r,  r,  r,  r\")\n+\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,q,0,rL,r,L,I,Cal,Cal,  r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"q,q,r, 0,r,r,0,  0,  r,Cal\")))]\n   \"register_operand (operands[1], SImode)\n    || register_operand (operands[2], SImode)\"\n   \"@\n-    sub%? %0,%1,%2%&\n-    sub%? %0,%1,%2%&\n-    sub%? %0,%1,%2\n-    rsub%? %0,%2,%1\n-    sub %0,%1,%2\n-    rsub %0,%2,%1\n-    rsub %0,%2,%1\n-    rsub%? %0,%2,%1\n-    rsub %0,%2,%1\n-    sub %0,%1,%2\"\n+    sub%?\\\\t%0,%1,%2%&\n+    sub%?\\\\t%0,%1,%2%&\n+    sub%?\\\\t%0,%1,%2\n+    rsub%?\\\\t%0,%2,%1\n+    sub\\\\t%0,%1,%2\n+    rsub\\\\t%0,%2,%1\n+    rsub\\\\t%0,%2,%1\n+    rsub%?\\\\t%0,%2,%1\n+    rsub\\\\t%0,%2,%1\n+    sub\\\\t%0,%1,%2\"\n   \"reload_completed && get_attr_length (insn) == 8\n    && satisfies_constraint_I (operands[1])\n    && GET_CODE (PATTERN (insn)) != COND_EXEC\"\n@@ -2990,19 +2988,19 @@ archs4x, archs4xd\"\n \n (define_insn \"sub_f\"\n   [(set (reg:CC CC_REG)\n-\t(compare:CC (match_operand:SI 1 \"nonmemory_operand\" \" c,L,0,I,c,Cal\")\n-\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"cL,c,I,0,Cal,c\")))\n-   (set (match_operand:SI 0 \"dest_reg_operand\" \"=w,w,Rcw,Rcw,w,w\")\n+\t(compare:CC (match_operand:SI 1 \"nonmemory_operand\" \" r,L,0,I,r,Cal\")\n+\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"rL,r,I,0,Cal,r\")))\n+   (set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r,r,r,r\")\n \t(minus:SI (match_dup 1) (match_dup 2)))]\n   \"register_operand (operands[1], SImode)\n    || register_operand (operands[2], SImode)\"\n   \"@\n-\tsub.f %0,%1,%2\n-\trsub.f %0,%2,%1\n-\tsub.f %0,%1,%2\n-\trsub.f %0,%2,%1\n-\tsub.f %0,%1,%2\n-\tsub.f %0,%1,%2\"\n+\tsub.f\\\\t%0,%1,%2\n+\trsub.f\\\\t%0,%2,%1\n+\tsub.f\\\\t%0,%1,%2\n+\trsub.f\\\\t%0,%2,%1\n+\tsub.f\\\\t%0,%1,%2\n+\tsub.f\\\\t%0,%1,%2\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,4,4,4,8,8\")])\n \n@@ -3051,25 +3049,25 @@ archs4x, archs4xd\"\n ;; N.B. sub[123] has the operands of the MINUS in the opposite order from\n ;; what synth_mult likes.\n (define_insn \"*sub_n\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n-\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,c,?Cal\")\n-\t\t  (ashift:SI (match_operand:SI 2 \"register_operand\" \"c,c,c\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n+\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,?Cal\")\n+\t\t  (ashift:SI (match_operand:SI 2 \"register_operand\" \"r,r,r\")\n \t\t\t     (match_operand:SI 3 \"_1_2_3_operand\" \"\"))))]\n   \"\"\n-  \"sub%c3%? %0,%1,%2\"\n+  \"sub%c3%?\\\\t%0,%1,%2\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n    (set_attr \"cond\" \"canuse,nocond,nocond\")\n    (set_attr \"iscompact\" \"false\")])\n \n (define_insn \"*sub_n\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n-\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,c,?Cal\")\n-\t\t  (mult:SI (match_operand:SI 2 \"register_operand\" \"c,c,c\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n+\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,?Cal\")\n+\t\t  (mult:SI (match_operand:SI 2 \"register_operand\" \"r,r,r\")\n \t\t\t   (match_operand:SI 3 \"_2_4_8_operand\" \"\"))))]\n   \"\"\n-  \"sub%z3%? %0,%1,%2\"\n+  \"sub%z3%?\\\\t%0,%1,%2\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n@@ -3078,38 +3076,38 @@ archs4x, archs4xd\"\n \n ; ??? check if combine matches this.\n (define_insn \"*bset\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n \t(ior:SI (ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 1 \"nonmemory_operand\" \"cL,cL,c\"))\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,c,Cal\")))]\n+\t\t\t   (match_operand:SI 1 \"nonmemory_operand\" \"rL,rL,r\"))\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,r,Cal\")))]\n   \"\"\n-  \"bset%? %0,%2,%1\"\n+  \"bset%?\\\\t%0,%2,%1\"\n   [(set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n    (set_attr \"cond\" \"canuse,nocond,nocond\")]\n )\n \n ; ??? check if combine matches this.\n (define_insn \"*bxor\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n \t(xor:SI (ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 1 \"nonmemory_operand\" \"cL,cL,c\"))\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,c,Cal\")))]\n+\t\t\t   (match_operand:SI 1 \"nonmemory_operand\" \"rL,rL,r\"))\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,r,Cal\")))]\n   \"\"\n-  \"bxor%? %0,%2,%1\"\n+  \"bxor%?\\\\t%0,%2,%1\"\n   [(set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n    (set_attr \"cond\" \"canuse,nocond,nocond\")]\n )\n \n ; ??? check if combine matches this.\n (define_insn \"*bclr\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n \t(and:SI (not:SI (ashift:SI (const_int 1)\n-\t\t\t\t   (match_operand:SI 1 \"nonmemory_operand\" \"cL,cL,c\")))\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,c,Cal\")))]\n+\t\t\t\t   (match_operand:SI 1 \"nonmemory_operand\" \"rL,rL,r\")))\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,r,Cal\")))]\n   \"\"\n-  \"bclr%? %0,%2,%1\"\n+  \"bclr%?\\\\t%0,%2,%1\"\n   [(set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n    (set_attr \"cond\" \"canuse,nocond,nocond\")]\n@@ -3121,65 +3119,65 @@ archs4x, archs4xd\"\n \n ; see also iorsi3 for use with constant bit number.\n (define_insn \"*bset_insn\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n-\t(ior:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,c,Cal\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,Cal\")\n \t\t(ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cL,cL,c\"))) ) ]\n+\t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"rL,rL,r\"))) ) ]\n   \"\"\n   \"@\n-     bset%? %0,%1,%2 ;;peep2, constr 1\n-     bset %0,%1,%2 ;;peep2, constr 2\n-     bset %0,%1,%2 ;;peep2, constr 3\"\n+     bset%?\\\\t%0,%1,%2 ;;peep2, constr 1\n+     bset\\\\t%0,%1,%2 ;;peep2, constr 2\n+     bset\\\\t%0,%1,%2 ;;peep2, constr 3\"\n   [(set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n    (set_attr \"cond\" \"canuse,nocond,nocond\")]\n )\n \n ; see also xorsi3 for use with constant bit number.\n (define_insn \"*bxor_insn\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n-\t(xor:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,c,Cal\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n+\t(xor:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,Cal\")\n \t\t(ashift:SI (const_int 1)\n-\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"cL,cL,c\"))) ) ]\n+\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL,rL,r\"))) ) ]\n   \"\"\n   \"@\n-     bxor%? %0,%1,%2\n-     bxor %0,%1,%2\n-     bxor %0,%1,%2\"\n+     bxor%?\\\\t%0,%1,%2\n+     bxor\\\\t%0,%1,%2\n+     bxor\\\\t%0,%1,%2\"\n   [(set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n    (set_attr \"cond\" \"canuse,nocond,nocond\")]\n )\n \n ; see also andsi3 for use with constant bit number.\n (define_insn \"*bclr_insn\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n \t(and:SI (not:SI (ashift:SI (const_int 1)\n-\t\t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cL,rL,r\")))\n-\t\t(match_operand:SI 1 \"nonmemory_operand\" \"0,c,Cal\")))]\n+\t\t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"rL,rL,r\")))\n+\t\t(match_operand:SI 1 \"nonmemory_operand\" \"0,r,Cal\")))]\n   \"\"\n   \"@\n-     bclr%? %0,%1,%2\n-     bclr %0,%1,%2\n-     bclr %0,%1,%2\"\n+     bclr%?\\\\t%0,%1,%2\n+     bclr\\\\t%0,%1,%2\n+     bclr\\\\t%0,%1,%2\"\n   [(set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n    (set_attr \"cond\" \"canuse,nocond,nocond\")]\n )\n \n ; see also andsi3 for use with constant bit number.\n (define_insn \"*bmsk_insn\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcw,w,w\")\n-\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,c,Cal\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,Cal\")\n \t\t(plus:SI (ashift:SI (const_int 1)\n \t\t\t\t    (plus:SI (match_operand:SI 2 \"nonmemory_operand\" \"rL,rL,r\")\n \t\t\t\t\t     (const_int 1)))\n \t\t\t (const_int -1))))]\n   \"\"\n   \"@\n-     bmsk%? %0,%1,%2\n-     bmsk %0,%1,%2\n-     bmsk %0,%1,%2\"\n+     bmsk%?\\\\t%0,%1,%2\n+     bmsk\\\\t%0,%1,%2\n+     bmsk\\\\t%0,%1,%2\"\n   [(set_attr \"length\" \"4,4,8\")\n    (set_attr \"predicable\" \"yes,no,no\")\n    (set_attr \"cond\" \"canuse,nocond,nocond\")]\n@@ -3282,18 +3280,18 @@ archs4x, archs4xd\"\n \n ;;bic define_insn that allows limm to be the first operand\n (define_insn \"*bicsi3_insn\"\n-   [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcqq,Rcw,Rcw,Rcw,w,w,w\")\n- \t(and:SI\t(not:SI (match_operand:SI 1 \"nonmemory_operand\" \"Rcqq,Lc,I,Cal,Lc,Cal,c\"))\n- \t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,0,0,0,c,c,Cal\")))]\n+   [(set (match_operand:SI 0 \"dest_reg_operand\" \"=q,r,r,r,r,r,r\")\n+ \t(and:SI\t(not:SI (match_operand:SI 1 \"nonmemory_operand\" \"q,Lr,I,Cal,Lr,Cal,r\"))\n+ \t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,0,0,0,r,r,Cal\")))]\n   \"\"\n   \"@\n-   bic%? %0, %2, %1%& ;;constraint 0\n-   bic%? %0,%2,%1  ;;constraint 1\n-   bic %0,%2,%1    ;;constraint 2, FIXME: will it ever get generated ???\n-   bic%? %0,%2,%1  ;;constraint 3, FIXME: will it ever get generated ???\n-   bic %0,%2,%1    ;;constraint 4\n-   bic %0,%2,%1    ;;constraint 5, FIXME: will it ever get generated ???\n-   bic %0,%2,%1    ;;constraint 6\"\n+   bic%?\\\\t%0, %2, %1%& ;;constraint 0\n+   bic%?\\\\t%0,%2,%1  ;;constraint 1\n+   bic\\\\t%0,%2,%1    ;;constraint 2, FIXME: will it ever get generated ???\n+   bic%?\\\\t%0,%2,%1  ;;constraint 3, FIXME: will it ever get generated ???\n+   bic\\\\t%0,%2,%1    ;;constraint 4\n+   bic\\\\t%0,%2,%1    ;;constraint 5, FIXME: will it ever get generated ???\n+   bic\\\\t%0,%2,%1    ;;constraint 6\"\n   [(set_attr \"length\" \"*,4,4,8,4,8,8\")\n   (set_attr \"iscompact\" \"maybe, false, false, false, false, false, false\")\n   (set_attr \"predicable\" \"no,yes,no,yes,no,no,no\")\n@@ -3334,19 +3332,19 @@ archs4x, archs4xd\"\n    (set_attr \"cond\" \"canuse,canuse,canuse,canuse,canuse,canuse,canuse_limm,nocond,nocond,canuse_limm,nocond,canuse,nocond\")])\n \n (define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\"          \"=Rcqq,Rcq,Rcw,Rcw,Rcw,Rcw, w,  w,w,  w,  w\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\"  \"%0,   Rcq,  0,  c,  0,  0, c,  c,0,  0,  c\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \" Rcqq,  0, cL,  0,C0p,  I,cL,C0p,I,Cal,Cal\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\"         \"=q,q, r,r,  r,r, r,  r,r,  r,  r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,q, 0,r,  0,0, r,  r,0,  0,  r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"q,0,rL,0,C0p,I,rL,C0p,I,Cal,Cal\")))]\n   \"\"\n   \"*\n   switch (which_alternative)\n     {\n     case 0: case 2: case 5: case 6: case 8: case 9: case 10:\n-      return \\\"xor%? %0,%1,%2%&\\\";\n+      return \\\"xor%?\\\\t%0,%1,%2%&\\\";\n     case 1: case 3:\n-      return \\\"xor%? %0,%2,%1%&\\\";\n+      return \\\"xor%?\\\\t%0,%2,%1%&\\\";\n     case 4: case 7:\n-      return \\\"bxor%? %0,%1,%z2\\\";\n+      return \\\"bxor%?\\\\t%0,%1,%z2\\\";\n     default:\n       gcc_unreachable ();\n     }\n@@ -3358,17 +3356,17 @@ archs4x, archs4xd\"\n    (set_attr \"cond\" \"canuse,canuse,canuse,canuse,canuse,canuse_limm,nocond,nocond,canuse_limm,canuse,nocond\")])\n \n (define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcqq,Rcqq,Rcw,w\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0,Rcqq,0,c\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=q,q,r,r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0,q,0,r\")))]\n   \"\"\n-  \"neg%? %0,%1%&\"\n+  \"neg%?\\\\t%0,%1%&\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"iscompact\" \"maybe,true,false,false\")\n    (set_attr \"predicable\" \"no,no,yes,no\")])\n \n (define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcqq,w\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"Rcqq,c\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=q,w\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"q,c\")))]\n   \"\"\n   \"not%? %0,%1%&\"\n   [(set_attr \"type\" \"unary,unary\")\n@@ -3498,14 +3496,14 @@ archs4x, archs4xd\"\n    (set_attr \"cond\" \"canuse,nocond,canuse,canuse,nocond,nocond\")])\n \n (define_insn \"*lshrsi3_insn\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\"             \"=Rcq,Rcqq,Rcqq,Rcw, w,   w\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"nonmemory_operand\" \"!0,Rcqq,   0,  0, c,cCal\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\"  \"N,  N,RcqqM, cL,cL,cCal\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\"               \"=q,q, q, r, r,   r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"nonmemory_operand\" \"!0,q, 0, 0, r,rCal\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\"  \"N,N,qM,rL,rL,rCal\")))]\n   \"TARGET_BARREL_SHIFTER\n    && (register_operand (operands[1], SImode)\n        || register_operand (operands[2], SImode))\"\n   \"*return (which_alternative <= 1 && !arc_ccfsm_cond_exec_p ()\n-\t    ?  \\\"lsr%? %0,%1%&\\\" : \\\"lsr%? %0,%1,%2%&\\\");\"\n+\t    ?  \\\"lsr%?\\\\t%0,%1%&\\\" : \\\"lsr%?\\\\t%0,%1,%2%&\\\");\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false\")\n    (set_attr \"predicable\" \"no,no,no,yes,no,no\")\n@@ -3546,8 +3544,8 @@ archs4x, archs4xd\"\n ;; modifed cc user if second, but not first operand is a compact register.\n (define_insn \"cmpsi_cc_insn_mixed\"\n   [(set (reg:CC CC_REG)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"Rcq#q,Rcqq,  h, c, c,qRcq,c\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\"   \"cO,  hO,Cm1,cI,cL, Cal,Cal\")))]\n+\t(compare:CC (match_operand:SI 0 \"register_operand\"   \"q, q,  h, c, c,  q,c\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"cO,hO,Cm1,cI,cL,Cal,Cal\")))]\n   \"\"\n   \"cmp%? %0,%B1%&\"\n   [(set_attr \"type\" \"compare\")\n@@ -3559,7 +3557,7 @@ archs4x, archs4xd\"\n \n (define_insn \"*cmpsi_cc_zn_insn\"\n   [(set (reg:CC_ZN CC_REG)\n-\t(compare:CC_ZN (match_operand:SI 0 \"register_operand\"  \"qRcq,c\")\n+\t(compare:CC_ZN (match_operand:SI 0 \"register_operand\"  \"q,c\")\n \t\t       (const_int 0)))]\n   \"\"\n   \"tst%? %0,%0%&\"\n@@ -3573,7 +3571,7 @@ archs4x, archs4xd\"\n (define_insn \"*btst\"\n   [(set (reg:CC_ZN CC_REG)\n \t(compare:CC_ZN\n-\t  (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"Rcqq,c\")\n+\t  (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"q,c\")\n \t\t\t   (const_int 1)\n \t\t\t   (match_operand:SI 1 \"nonmemory_operand\" \"L,Lc\"))\n \t  (const_int 0)))]\n@@ -3618,7 +3616,7 @@ archs4x, archs4xd\"\n \n (define_insn \"*cmpsi_cc_z_insn\"\n   [(set (reg:CC_Z CC_REG)\n-\t(compare:CC_Z (match_operand:SI 0 \"register_operand\"  \"qRcq,c\")\n+\t(compare:CC_Z (match_operand:SI 0 \"register_operand\"  \"q,c\")\n \t\t      (match_operand:SI 1 \"p2_immediate_operand\"  \"O,n\")))]\n   \"\"\n   \"@\n@@ -3631,8 +3629,8 @@ archs4x, archs4xd\"\n \n (define_insn \"*cmpsi_cc_c_insn\"\n   [(set (reg:CC_C CC_REG)\n-\t(compare:CC_C (match_operand:SI 0 \"register_operand\"  \"Rcqq,Rcqq,  h, c,Rcqq,  c\")\n-\t\t      (match_operand:SI 1 \"nonmemory_operand\"   \"cO,  hO,Cm1,cI, Cal,Cal\")))]\n+\t(compare:CC_C (match_operand:SI 0 \"register_operand\"   \"q, q,  h, c,  q,  c\")\n+\t\t      (match_operand:SI 1 \"nonmemory_operand\" \"cO,hO,Cm1,cI,Cal,Cal\")))]\n   \"\"\n   \"cmp%? %0,%1%&\"\n   [(set_attr \"type\" \"compare\")\n@@ -3944,7 +3942,7 @@ archs4x, archs4xd\"\n \t (const_int 2)))])\n \n (define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"nonmemory_operand\" \"L,I,Cal,Rcqq,r\"))]\n+  [(set (pc) (match_operand:SI 0 \"nonmemory_operand\" \"L,I,Cal,q,r\"))]\n   \"\"\n   \"@\n    j%!%* %0%&\n@@ -4076,7 +4074,7 @@ archs4x, archs4xd\"\n ; Unlike the canonical tablejump, this pattern always uses a jump address,\n ; even for CASE_VECTOR_PC_RELATIVE.\n (define_insn \"casesi_jump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"Cal,Rcqq,c\"))\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"Cal,q,c\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"j%!%* [%0]%&\"\n@@ -4106,17 +4104,15 @@ archs4x, archs4xd\"\n   }\n \")\n \n-; Rcq, which is used in alternative 0, checks for conditional execution.\n ; At instruction output time, if it doesn't match and we end up with\n ; alternative 1 (\"q\"), that means that we can't use the short form.\n (define_insn \"*call_i\"\n   [(call (mem:SI (match_operand:SI 0\n-\t\t  \"call_address_operand\" \"Rcq,q,c,Cji,Csc,Cbp,Cbr,L,I,Cal\"))\n+\t\t  \"call_address_operand\" \"q,c,Cji,Csc,Cbp,Cbr,L,I,Cal\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI 31))]\n   \"\"\n   \"@\n-   jl%!%* [%0]%&\n    jl%!%* [%0]%&\n    jl%!%* [%0]\n    jli_s %S0\n@@ -4126,10 +4122,10 @@ archs4x, archs4xd\"\n    jl%!%* %0\n    jl%* %0\n    jl%! %0\"\n-  [(set_attr \"type\" \"call,call,call,call_no_delay_slot,call_no_delay_slot,call,call,call,call,call_no_delay_slot\")\n-   (set_attr \"iscompact\" \"maybe,false,*,true,*,*,*,*,*,*\")\n-   (set_attr \"predicable\" \"no,no,yes,no,no,yes,no,yes,no,yes\")\n-   (set_attr \"length\" \"*,*,4,2,4,4,4,4,4,8\")])\n+  [(set_attr \"type\" \"call,call,call_no_delay_slot,call_no_delay_slot,call,call,call,call,call_no_delay_slot\")\n+   (set_attr \"iscompact\" \"maybe,*,true,*,*,*,*,*,*\")\n+   (set_attr \"predicable\" \"no,yes,no,no,yes,no,yes,no,yes\")\n+   (set_attr \"length\" \"*,4,2,4,4,4,4,4,8\")])\n \n (define_expand \"call_value\"\n   ;; operand 2 is stack_size_rtx\n@@ -4151,18 +4147,16 @@ archs4x, archs4xd\"\n       XEXP (operands[1], 0) = force_reg (Pmode, callee);\n   }\")\n \n-; Rcq, which is used in alternative 0, checks for conditional execution.\n ; At instruction output time, if it doesn't match and we end up with\n ; alternative 1 (\"q\"), that means that we can't use the short form.\n (define_insn \"*call_value_i\"\n-  [(set (match_operand 0 \"dest_reg_operand\"  \"=Rcq,q,w,  w,  w,  w,  w,w,w,  w\")\n+  [(set (match_operand 0 \"dest_reg_operand\"  \"=q,w,  w,  w,  w,  w,w,w,  w\")\n \t(call (mem:SI (match_operand:SI 1\n-\t\t       \"call_address_operand\" \"Rcq,q,c,Cji,Csc,Cbp,Cbr,L,I,Cal\"))\n+\t\t       \"call_address_operand\" \"q,c,Cji,Csc,Cbp,Cbr,L,I,Cal\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI 31))]\n   \"\"\n   \"@\n-   jl%!%* [%1]%&\n    jl%!%* [%1]%&\n    jl%!%* [%1]\n    jli_s %S1\n@@ -4172,10 +4166,10 @@ archs4x, archs4xd\"\n    jl%!%* %1\n    jl%* %1\n    jl%! %1\"\n-  [(set_attr \"type\" \"call,call,call,call_no_delay_slot,call_no_delay_slot,call,call,call,call,call_no_delay_slot\")\n-   (set_attr \"iscompact\" \"maybe,false,*,true,false,*,*,*,*,*\")\n-   (set_attr \"predicable\" \"no,no,yes,no,no,yes,no,yes,no,yes\")\n-   (set_attr \"length\" \"*,*,4,2,4,4,4,4,4,8\")])\n+  [(set_attr \"type\" \"call,call,call_no_delay_slot,call_no_delay_slot,call,call,call,call,call_no_delay_slot\")\n+   (set_attr \"iscompact\" \"maybe,*,true,false,*,*,*,*,*\")\n+   (set_attr \"predicable\" \"no,yes,no,no,yes,no,yes,no,yes\")\n+   (set_attr \"length\" \"*,4,2,4,4,4,4,4,8\")])\n \n ; There is a bl_s instruction (16 bit opcode branch-and-link), but we can't\n ; use it for lack of inter-procedural branch shortening.\n@@ -4943,7 +4937,7 @@ archs4x, archs4xd\"\n   [(set (pc)\n \t(if_then_else\n \t  (match_operator 3 \"equality_comparison_operator\"\n-\t    [(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"Rcqq,c\")\n+\t    [(zero_extract:SI (match_operand:SI 1 \"register_operand\"  \"q,c\")\n \t\t\t      (const_int 1)\n \t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"L,Lc\"))\n \t     (const_int 0)])\n@@ -5153,20 +5147,20 @@ archs4x, archs4xd\"\n    (set_attr \"predicable\" \"yes\")])\n \n (define_insn \"abssf2\"\n-  [(set (match_operand:SF 0 \"dest_reg_operand\"    \"=Rcq#q,Rcw,w\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0,  0,c\")))]\n+  [(set (match_operand:SF 0 \"dest_reg_operand\"    \"=q,r,r\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0,0,r\")))]\n   \"\"\n-  \"bclr%? %0,%1,31%&\"\n+  \"bclr%?\\\\t%0,%1,31%&\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"iscompact\" \"maybe,false,false\")\n    (set_attr \"length\" \"2,4,4\")\n    (set_attr \"predicable\" \"no,yes,no\")])\n \n (define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"dest_reg_operand\" \"=Rcw,w\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"0,c\")))]\n+  [(set (match_operand:SF 0 \"dest_reg_operand\" \"=r,r\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"0,r\")))]\n   \"\"\n-  \"bxor%? %0,%1,31\"\n+  \"bxor%?\\\\t%0,%1,31\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"predicable\" \"yes,no\")])\n \n@@ -5966,8 +5960,8 @@ archs4x, archs4xd\"\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*ashlsi2_cnt1\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\"           \"=Rcqq,w\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"Rcqq,c\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\"           \"=q,w\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"q,c\")\n \t\t   (const_int 1)))]\n   \"\"\n   \"asl%? %0,%1%&\"\n@@ -5999,8 +5993,8 @@ archs4x, archs4xd\"\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*lshrsi3_cnt1\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\"             \"=Rcqq,w\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"Rcqq,c\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\"             \"=q,w\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"q,c\")\n \t\t     (const_int 1)))]\n   \"\"\n   \"lsr%? %0,%1%&\"\n@@ -6009,8 +6003,8 @@ archs4x, archs4xd\"\n    (set_attr \"predicable\" \"no,no\")])\n \n (define_insn \"*ashrsi3_cnt1\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\"             \"=Rcqq,w\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"Rcqq,c\")\n+  [(set (match_operand:SI 0 \"dest_reg_operand\"             \"=q,w\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"q,c\")\n \t\t     (const_int 1)))]\n   \"\"\n   \"asr%? %0,%1%&\"\n@@ -6141,7 +6135,7 @@ archs4x, archs4xd\"\n    (set_attr \"length\" \"36\")])\n \n (define_insn \"macd\"\n-  [(set (match_operand:DI 0 \"even_register_operand\"\t       \"=Rcr,r,r\")\n+  [(set (match_operand:DI 0 \"even_register_operand\"\t\"=r,r,r\")\n \t(plus:DI\n \t (mult:DI\n \t  (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,r,r\"))\n@@ -6243,7 +6237,7 @@ archs4x, archs4xd\"\n    (set_attr \"length\" \"36\")])\n \n (define_insn \"macdu\"\n-  [(set (match_operand:DI 0 \"even_register_operand\"\t       \"=Rcr,r,r\")\n+  [(set (match_operand:DI 0 \"even_register_operand\"\t\"=r,r,r\")\n \t(plus:DI\n \t (mult:DI\n \t  (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,r,r\"))"}, {"sha": "b58273255f70c913301bf5b1547a1835f75b1e30", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -308,12 +308,14 @@ Target Ignore\n Does nothing.  Preserved for backward compatibility.\n \n mRcq\n-Target Var(TARGET_Rcq)\n-Enable Rcq constraint handling - most short code generation depends on this.\n+Target Ignore\n+Does nothing.  Preserved for backward compatibility.\n+\n \n mRcw\n-Target Var(TARGET_Rcw)\n-Enable Rcw constraint handling - ccfsm condexec mostly depends on this.\n+Target Ignore\n+Does nothing.  Preserved for backward compatibility.\n+\n \n mearly-cbranchsi\n Target Var(TARGET_EARLY_CBRANCHSI)"}, {"sha": "38bda1230b8df9496b8886660cf6b5f0a8a8ce64", "filename": "gcc/config/arc/constraints.md", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fconstraints.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -432,50 +432,6 @@\n \t       && !arc_legitimate_pic_addr_p (op)\n \t       && !(satisfies_constraint_I (op) && optimize_size)\"))\n \n-; Note that the 'cryptic' register constraints will not make reload use the\n-; associated class to reload into, but this will not penalize reloading of any\n-; other operands, or using an alternate part of the same alternative.\n-\n-; Rcq is different in three important ways from a register class constraint:\n-; - It does not imply a register class, hence reload will not use it to drive\n-;   reloads.\n-; - It matches even when there is no register class to describe its accepted\n-;   set; not having such a set again lessens the impact on register allocation.\n-; - It won't match when the instruction is conditionalized by the ccfsm.\n-(define_constraint \"Rcq\"\n-  \"@internal\n-   Cryptic q - for short insn generation while not affecting register allocation\n-   Registers usable in ARCompact 16-bit instructions: @code{r0}-@code{r3},\n-   @code{r12}-@code{r15}\"\n-  (and (match_code \"reg\")\n-       (match_test \"TARGET_Rcq\n-\t\t    && !arc_ccfsm_cond_exec_p ()\n-\t\t    && IN_RANGE (REGNO (op) ^ 4, 4, 11)\")))\n-\n-; If we need a reload, we generally want to steer reload to use three-address\n-; alternatives in preference of two-address alternatives, unless the\n-; three-address alternative introduces a LIMM that is unnecessary for the\n-; two-address alternative.\n-(define_constraint \"Rcw\"\n-  \"@internal\n-   Cryptic w - for use in early alternatives with matching constraint\"\n-  (and (match_code \"reg\")\n-       (match_test\n-\t\"TARGET_Rcw\n-\t && REGNO (op) < FIRST_PSEUDO_REGISTER\n-\t && TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS],\n-\t\t\t       REGNO (op))\")))\n-\n-(define_constraint \"Rcr\"\n-  \"@internal\n-   Cryptic r - for use in early alternatives with matching constraint\"\n-  (and (match_code \"reg\")\n-       (match_test\n-\t\"TARGET_Rcw\n-\t && REGNO (op) < FIRST_PSEUDO_REGISTER\n-\t && TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS],\n-\t\t\t       REGNO (op))\")))\n-\n (define_constraint \"Rcb\"\n   \"@internal\n    Stack Pointer register @code{r28} - do not reload into its class\""}, {"sha": "6ebbb143895e99ee154e20899173f7f3f503e3c9", "filename": "gcc/config/arc/linux.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Flinux.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -45,7 +45,6 @@ along with GCC; see the file COPYING3.  If not see\n     %{!shared:-dynamic-linker \" GNU_USER_DYNAMIC_LINKER \"}} \\\n   -X \\\n   %{mbig-endian:-EB} %{EB} %{EL} \\\n-  %{!z:-z max-page-size=0x2000 -z common-page-size=0x2000} \\\n   %{mcpu=nps400:-marclinux_nps; :-marclinux}\"\n \n #undef STARTFILE_SPEC"}, {"sha": "86c56bf26800e273a8b244ff68299db1ea16f43e", "filename": "gcc/config/arm/arm-c.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farm%2Farm-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farm%2Farm-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -202,6 +202,8 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_QBIT\", TARGET_ARM_QBIT);\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_SAT\", TARGET_ARM_SAT);\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_CRYPTO\", TARGET_CRYPTO);\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_AES\", TARGET_CRYPTO);\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_SHA2\", TARGET_CRYPTO);\n \n   def_or_undef_macro (pfile, \"__ARM_FEATURE_UNALIGNED\", unaligned_access);\n "}, {"sha": "2eb4d51e4a3ca28e97238bd913e993622cf4fdc1", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -29143,7 +29143,8 @@ arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n   if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n     {\n       nregs = pcum->aapcs_ncrn;\n-      if (nregs & 1)\n+      if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl))\n+\t  && (nregs & 1))\n \t{\n \t  int res = arm_needs_doubleword_align (arg.mode, arg.type);\n \t  if (res < 0 && warn_psabi)\n@@ -30359,6 +30360,8 @@ arm_mangle_type (const_tree type)\n   /* Half-precision floating point types.  */\n   if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)\n     {\n+      if (TYPE_MAIN_VARIANT (type) == float16_type_node)\n+\treturn NULL;\n       if (TYPE_MODE (type) == BFmode)\n \treturn \"u6__bf16\";\n       else"}, {"sha": "6d803ceca1e402b462562b68de2d667fab5e3f14", "filename": "gcc/config/arm/linux-eabi.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farm%2Flinux-eabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farm%2Flinux-eabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-eabi.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -30,9 +30,6 @@\n     }\t\t\t\t\t\t\\\n   while (false)\n \n-#define EXTRA_TARGET_D_OS_VERSIONS()\t\t\\\n-  ANDROID_TARGET_D_OS_VERSIONS();\n-\n /* We default to a soft-float ABI so that binaries can run on all\n    target hardware.  If you override this to use the hard-float ABI then\n    change the setting of GLIBC_DYNAMIC_LINKER_DEFAULT as well.  */"}, {"sha": "62186f124da183fe1b1eb57a1aea1e8fff680a22", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -3503,7 +3503,7 @@\n ;;\n (define_insn \"mve_vrev64q_m_<supf><mode>\"\n   [\n-   (set (match_operand:MVE_2 0 \"s_register_operand\" \"=w\")\n+   (set (match_operand:MVE_2 0 \"s_register_operand\" \"=&w\")\n \t(unspec:MVE_2 [(match_operand:MVE_2 1 \"s_register_operand\" \"0\")\n \t\t       (match_operand:MVE_2 2 \"s_register_operand\" \"w\")\n \t\t       (match_operand:<MVE_VPRED> 3 \"vpr_register_operand\" \"Up\")]\n@@ -4598,7 +4598,7 @@\n ;;\n (define_insn \"mve_vrev64q_m_f<mode>\"\n   [\n-   (set (match_operand:MVE_0 0 \"s_register_operand\" \"=w\")\n+   (set (match_operand:MVE_0 0 \"s_register_operand\" \"=&w\")\n \t(unspec:MVE_0 [(match_operand:MVE_0 1 \"s_register_operand\" \"0\")\n \t\t       (match_operand:MVE_0 2 \"s_register_operand\" \"w\")\n \t\t       (match_operand:<MVE_VPRED> 3 \"vpr_register_operand\" \"Up\")]"}, {"sha": "ea8ca64d1d6ee2291dd78b93abf338270903de71", "filename": "gcc/config/bpf/bpf.cc", "status": "modified", "additions": 330, "deletions": 72, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -184,13 +184,13 @@ enum bpf_builtins\n \n   /* Compile Once - Run Everywhere (CO-RE) support.  */\n   BPF_BUILTIN_PRESERVE_ACCESS_INDEX,\n+  BPF_BUILTIN_PRESERVE_FIELD_INFO,\n \n   BPF_BUILTIN_MAX,\n };\n \n static GTY (()) tree bpf_builtins[(int) BPF_BUILTIN_MAX];\n \n-\n void bpf_register_coreattr_pass (void);\n \n /* Initialize the per-function machine status.  */\n@@ -966,6 +966,9 @@ bpf_init_builtins (void)\n   def_builtin (\"__builtin_preserve_access_index\",\n \t       BPF_BUILTIN_PRESERVE_ACCESS_INDEX,\n \t       build_function_type_list (ptr_type_node, ptr_type_node, 0));\n+  def_builtin (\"__builtin_preserve_field_info\",\n+\t       BPF_BUILTIN_PRESERVE_FIELD_INFO,\n+\t       build_function_type_list (unsigned_type_node, ptr_type_node, unsigned_type_node, 0));\n }\n \n #undef TARGET_INIT_BUILTINS\n@@ -975,6 +978,199 @@ static tree bpf_core_compute (tree, vec<unsigned int> *);\n static int bpf_core_get_index (const tree);\n static bool is_attr_preserve_access (tree);\n \n+/* BPF Compile Once - Run Everywhere (CO-RE) support. Construct a CO-RE\n+   relocation record for EXPR of kind KIND to be emitted in the .BTF.ext\n+   section. Does nothing if we are not targetting BPF CO-RE, or if the\n+   constructed relocation would be a no-op.  */\n+\n+static void\n+maybe_make_core_relo (tree expr, enum btf_core_reloc_kind kind)\n+{\n+  /* If we are not targetting BPF CO-RE, do not make a relocation. We\n+     might not be generating any debug info at all.  */\n+  if (!TARGET_BPF_CORE)\n+    return;\n+\n+  auto_vec<unsigned int, 16> accessors;\n+  tree container = bpf_core_compute (expr, &accessors);\n+\n+  /* Any valid use of the builtin must have at least one access. Otherwise,\n+     there is nothing to record and nothing to do. This is primarily a\n+     guard against optimizations leading to unexpected expressions in the\n+     argument of the builtin. For example, if the builtin is used to read\n+     a field of a structure which can be statically determined to hold a\n+     constant value, the argument to the builtin will be optimized to that\n+     constant. This is OK, and means the builtin call is superfluous.\n+     e.g.\n+     struct S foo;\n+     foo.a = 5;\n+     int x = __preserve_access_index (foo.a);\n+     ... do stuff with x\n+     'foo.a' in the builtin argument will be optimized to '5' with -01+.\n+     This sequence does not warrant recording a CO-RE relocation.  */\n+\n+  if (accessors.length () < 1)\n+    return;\n+  accessors.reverse ();\n+\n+  rtx_code_label *label = gen_label_rtx ();\n+  LABEL_PRESERVE_P (label) = 1;\n+  emit_label (label);\n+\n+  /* Determine what output section this relocation will apply to.\n+     If this function is associated with a section, use that. Otherwise,\n+     fall back on '.text'.  */\n+  const char * section_name;\n+  if (current_function_decl && DECL_SECTION_NAME (current_function_decl))\n+    section_name = DECL_SECTION_NAME (current_function_decl);\n+  else\n+    section_name = \".text\";\n+\n+  /* Add the CO-RE relocation information to the BTF container.  */\n+  bpf_core_reloc_add (TREE_TYPE (container), section_name, &accessors, label,\n+\t\t      kind);\n+}\n+\n+/* Expand a call to __builtin_preserve_field_info by evaluating the requested\n+   information about SRC according to KIND, and return a tree holding\n+   the result.  */\n+\n+static tree\n+bpf_core_field_info (tree src, enum btf_core_reloc_kind kind)\n+{\n+  unsigned int result;\n+  poly_int64 bitsize, bitpos;\n+  tree var_off = NULL_TREE;\n+  machine_mode mode;\n+  int unsignedp, reversep, volatilep;\n+  location_t loc = EXPR_LOCATION (src);\n+\n+  get_inner_reference (src, &bitsize, &bitpos, &var_off, &mode, &unsignedp,\n+\t\t       &reversep, &volatilep);\n+\n+  /* Note: Use DECL_BIT_FIELD_TYPE rather than DECL_BIT_FIELD here, because it\n+     remembers whether the field in question was originally declared as a\n+     bitfield, regardless of how it has been optimized.  */\n+  bool bitfieldp = (TREE_CODE (src) == COMPONENT_REF\n+\t\t    && DECL_BIT_FIELD_TYPE (TREE_OPERAND (src, 1)));\n+\n+  unsigned int align = TYPE_ALIGN (TREE_TYPE (src));\n+  if (TREE_CODE (src) == COMPONENT_REF)\n+    {\n+      tree field = TREE_OPERAND (src, 1);\n+      if (DECL_BIT_FIELD_TYPE (field))\n+\talign = TYPE_ALIGN (DECL_BIT_FIELD_TYPE (field));\n+      else\n+\talign = TYPE_ALIGN (TREE_TYPE (field));\n+    }\n+\n+  unsigned int start_bitpos = bitpos & ~(align - 1);\n+  unsigned int end_bitpos = start_bitpos + align;\n+\n+  switch (kind)\n+    {\n+    case BPF_RELO_FIELD_BYTE_OFFSET:\n+      {\n+\tif (var_off != NULL_TREE)\n+\t  {\n+\t    error_at (loc, \"unsupported variable field offset\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\tif (bitfieldp)\n+\t  result = start_bitpos / 8;\n+\telse\n+\t  result = bitpos / 8;\n+      }\n+      break;\n+\n+    case BPF_RELO_FIELD_BYTE_SIZE:\n+      {\n+\tif (mode == BLKmode && bitsize == -1)\n+\t  {\n+\t    error_at (loc, \"unsupported variable size field access\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\tif (bitfieldp)\n+\t  {\n+\t    /* To match LLVM behavior, byte size of bitfields is recorded as\n+\t       the full size of the base type. A 3-bit bitfield of type int is\n+\t       therefore recorded as having a byte size of 4 bytes. */\n+\t    result = end_bitpos - start_bitpos;\n+\t    if (result & (result - 1))\n+\t      {\n+\t\terror_at (loc, \"unsupported field expression\");\n+\t\treturn error_mark_node;\n+\t      }\n+\t    result = result / 8;\n+\t  }\n+\telse\n+\t  result = bitsize / 8;\n+      }\n+      break;\n+\n+    case BPF_RELO_FIELD_EXISTS:\n+      /* The field always exists at compile time.  */\n+      result = 1;\n+      break;\n+\n+    case BPF_RELO_FIELD_SIGNED:\n+      result = !unsignedp;\n+      break;\n+\n+    case BPF_RELO_FIELD_LSHIFT_U64:\n+    case BPF_RELO_FIELD_RSHIFT_U64:\n+      {\n+\tif (mode == BLKmode && bitsize == -1)\n+\t  {\n+\t    error_at (loc, \"unsupported variable size field access\");\n+\t    return error_mark_node;\n+\t  }\n+\tif (var_off != NULL_TREE)\n+\t  {\n+\t    error_at (loc, \"unsupported variable field offset\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\tif (!bitfieldp)\n+\t  {\n+\t    if (bitsize > 64)\n+\t      {\n+\t\terror_at (loc, \"field size too large\");\n+\t\treturn error_mark_node;\n+\t      }\n+\t    result = 64 - bitsize;\n+\t    break;\n+\t  }\n+\n+\tif (end_bitpos - start_bitpos > 64)\n+\t  {\n+\t    error_at (loc, \"field size too large\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\tif (kind == BPF_RELO_FIELD_LSHIFT_U64)\n+\t  {\n+\t    if (TARGET_BIG_ENDIAN)\n+\t      result = bitpos + 64 - start_bitpos - align;\n+\t    else\n+\t      result = start_bitpos + 64 - bitpos - bitsize;\n+\t  }\n+\telse /* RSHIFT_U64 */\n+\t  result = 64 - bitsize;\n+      }\n+      break;\n+\n+    default:\n+      error (\"invalid second argument to built-in function\");\n+      return error_mark_node;\n+      break;\n+    }\n+\n+  return build_int_cst (unsigned_type_node, result);\n+}\n+\n /* Expand a call to a BPF-specific built-in function that was set up\n    with bpf_init_builtins.  */\n \n@@ -1025,17 +1221,15 @@ bpf_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       /* The result of the load is in R0.  */\n       return gen_rtx_REG (ops[0].mode, BPF_R0);\n     }\n+\n   else if (code == -1)\n     {\n-      /* A resolved overloaded builtin, e.g. __bpf_preserve_access_index_si */\n+      /* A resolved overloaded __builtin_preserve_access_index.  */\n       tree arg = CALL_EXPR_ARG (exp, 0);\n \n       if (arg == NULL_TREE)\n \treturn NULL_RTX;\n \n-      auto_vec<unsigned int, 16> accessors;\n-      tree container;\n-\n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n \t  gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n@@ -1049,51 +1243,42 @@ bpf_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       /* Avoid double-recording information if the argument is an access to\n \t a struct/union marked __attribute__((preserve_access_index)). This\n \t Will be handled by the attribute handling pass.  */\n-      if (is_attr_preserve_access (arg))\n-\treturn expand_normal (arg);\n-\n-      container = bpf_core_compute (arg, &accessors);\n-\n-      /* Any valid use of the builtin must have at least one access. Otherwise,\n-\t there is nothing to record and nothing to do. This is primarily a\n-\t guard against optimizations leading to unexpected expressions in the\n-\t argument of the builtin. For example, if the builtin is used to read\n-\t a field of a structure which can be statically determined to hold a\n-\t constant value, the argument to the builtin will be optimized to that\n-\t constant. This is OK, and means the builtin call is superfluous.\n-\t e.g.\n-\t   struct S foo;\n-\t   foo.a = 5;\n-\t   int x = __preserve_access_index (foo.a);\n-\t   ... do stuff with x\n-\t 'foo.a' in the builtin argument will be optimized to '5' with -01+.\n-\t This sequence does not warrant recording a CO-RE relocation.  */\n-\n-      if (accessors.length () < 1)\n-\treturn expand_normal (arg);\n-\n-      accessors.reverse ();\n-\n-      container = TREE_TYPE (container);\n-\n-      rtx_code_label *label = gen_label_rtx ();\n-      LABEL_PRESERVE_P (label) = 1;\n-      emit_label (label);\n-\n-      /* Determine what output section this relocation will apply to.\n-\t If this function is associated with a section, use that. Otherwise,\n-\t fall back on '.text'.  */\n-      const char * section_name;\n-      if (current_function_decl && DECL_SECTION_NAME (current_function_decl))\n-\tsection_name = DECL_SECTION_NAME (current_function_decl);\n+      if (!is_attr_preserve_access (arg))\n+\tmaybe_make_core_relo (arg, BPF_RELO_FIELD_BYTE_OFFSET);\n+\n+      return expand_normal (arg);\n+    }\n+\n+  else if (code == -2)\n+    {\n+      /* A resolved overloaded __builtin_preserve_field_info.  */\n+      tree src = CALL_EXPR_ARG (exp, 0);\n+      tree kind_tree = CALL_EXPR_ARG (exp, 1);\n+      unsigned HOST_WIDE_INT kind_val;\n+      if (tree_fits_uhwi_p (kind_tree))\n+\tkind_val = tree_to_uhwi (kind_tree);\n       else\n-\tsection_name = \".text\";\n+\terror (\"invalid argument to built-in function\");\n \n-      /* Add the CO-RE relocation information to the BTF container.  */\n-      bpf_core_reloc_add (container, section_name, &accessors, label);\n+      enum btf_core_reloc_kind kind = (enum btf_core_reloc_kind) kind_val;\n \n-      return expand_normal (arg);\n+      if (TREE_CODE (src) == SSA_NAME)\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (src);\n+\t  if (is_gimple_assign (def_stmt))\n+\t    src = gimple_assign_rhs1 (def_stmt);\n+\t}\n+      if (TREE_CODE (src) == ADDR_EXPR)\n+\tsrc = TREE_OPERAND (src, 0);\n+\n+      tree result = bpf_core_field_info (src, kind);\n+\n+      if (result != error_mark_node)\n+\tmaybe_make_core_relo (src, kind);\n+\n+      return expand_normal (result);\n     }\n+\n   gcc_unreachable ();\n }\n \n@@ -1259,41 +1444,64 @@ bpf_core_get_index (const tree node)\n    __builtin_preserve_access_index.  */\n \n static tree\n-bpf_core_newdecl (tree type)\n+bpf_core_newdecl (tree type, bool is_pai)\n {\n-  tree rettype = build_function_type_list (type, type, NULL);\n+  tree rettype;\n   char name[80];\n-  int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pai_\");\n+  static unsigned long pai_count = 0;\n+  static unsigned long pfi_count = 0;\n \n-  static unsigned long cnt = 0;\n-  len = snprintf (name + len, sizeof (name) - len, \"%lu\", cnt++);\n+  if (is_pai)\n+    {\n+      rettype = build_function_type_list (type, type, NULL);\n+      int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pai_\");\n+      len = snprintf (name + len, sizeof (name) - len, \"%lu\", pai_count++);\n+    }\n+  else\n+    {\n+      rettype = build_function_type_list (unsigned_type_node, type,\n+\t\t\t\t\t  unsigned_type_node, NULL);\n+      int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pfi_\");\n+      len = snprintf (name + len, sizeof (name) - len, \"%lu\", pfi_count++);\n+    }\n \n-  return add_builtin_function_ext_scope (name, rettype, -1, BUILT_IN_MD, NULL,\n-\t\t\t\t\t NULL_TREE);\n+  return add_builtin_function_ext_scope (name, rettype, is_pai ? -1 : -2,\n+\t\t\t\t\t BUILT_IN_MD, NULL, NULL_TREE);\n }\n \n /* Return whether EXPR could access some aggregate data structure that\n    BPF CO-RE support needs to know about.  */\n \n-static int\n+static bool\n bpf_core_is_maybe_aggregate_access (tree expr)\n {\n-  enum tree_code code = TREE_CODE (expr);\n-  if (code == COMPONENT_REF || code == ARRAY_REF)\n-    return 1;\n-\n-  if (code == ADDR_EXPR)\n+  switch (TREE_CODE (expr))\n+    {\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      return true;\n+    case ADDR_EXPR:\n+    case NOP_EXPR:\n       return bpf_core_is_maybe_aggregate_access (TREE_OPERAND (expr, 0));\n-\n-  return 0;\n+    default:\n+      return false;\n+    }\n }\n \n+struct core_walk_data {\n+  location_t loc;\n+  tree arg;\n+};\n+\n /* Callback function used with walk_tree from bpf_resolve_overloaded_builtin.  */\n \n static tree\n bpf_core_walk (tree *tp, int *walk_subtrees, void *data)\n {\n-  location_t loc = *((location_t *) data);\n+  struct core_walk_data *dat = (struct core_walk_data *) data;\n+  bool is_pai = dat->arg == NULL_TREE;\n \n   /* If this is a type, don't do anything. */\n   if (TYPE_P (*tp))\n@@ -1302,10 +1510,18 @@ bpf_core_walk (tree *tp, int *walk_subtrees, void *data)\n       return NULL_TREE;\n     }\n \n+  /* Build a new function call to a resolved builtin for the desired operation.\n+     If this is a preserve_field_info call, pass along the argument to the\n+     resolved builtin call. */\n   if (bpf_core_is_maybe_aggregate_access (*tp))\n     {\n-      tree newdecl = bpf_core_newdecl (TREE_TYPE (*tp));\n-      tree newcall = build_call_expr_loc (loc, newdecl, 1, *tp);\n+      tree newdecl = bpf_core_newdecl (TREE_TYPE (*tp), is_pai);\n+      tree newcall;\n+      if (is_pai)\n+\tnewcall = build_call_expr_loc (dat->loc, newdecl, 1, *tp);\n+      else\n+\tnewcall = build_call_expr_loc (dat->loc, newdecl, 2, *tp, dat->arg);\n+\n       *tp = newcall;\n       *walk_subtrees = 0;\n     }\n@@ -1330,6 +1546,30 @@ bpf_small_register_classes_for_mode_p (machine_mode mode)\n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P \\\n   bpf_small_register_classes_for_mode_p\n \n+/* Return whether EXPR is a valid first argument for a call to\n+   __builtin_preserve_field_info.  */\n+\n+static bool\n+bpf_is_valid_preserve_field_info_arg (tree expr)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      return true;\n+    case NOP_EXPR:\n+      return bpf_is_valid_preserve_field_info_arg (TREE_OPERAND (expr, 0));\n+    case ADDR_EXPR:\n+      /* Do not accept ADDR_EXPRs like &foo.bar, but do accept accesses like\n+\t foo.baz where baz is an array.  */\n+      return (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == ARRAY_TYPE);\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Implement TARGET_RESOLVE_OVERLOADED_BUILTIN (see gccint manual section\n    Target Macros::Misc.).\n    We use this for the __builtin_preserve_access_index builtin for CO-RE\n@@ -1344,26 +1584,39 @@ bpf_small_register_classes_for_mode_p (machine_mode mode)\n static tree\n bpf_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)\n {\n-  if (DECL_MD_FUNCTION_CODE (fndecl) != BPF_BUILTIN_PRESERVE_ACCESS_INDEX)\n+  bool is_pai = DECL_MD_FUNCTION_CODE (fndecl)\n+    == BPF_BUILTIN_PRESERVE_ACCESS_INDEX;\n+  bool is_pfi = DECL_MD_FUNCTION_CODE (fndecl)\n+    == BPF_BUILTIN_PRESERVE_FIELD_INFO;\n+\n+  if (!is_pai && !is_pfi)\n     return NULL_TREE;\n \n   /* We only expect one argument, but it may be an arbitrarily-complicated\n      statement-expression. */\n   vec<tree, va_gc> *params = static_cast<vec<tree, va_gc> *> (arglist);\n   unsigned n_params = params ? params->length() : 0;\n \n-  if (n_params != 1)\n+  if ((is_pai && n_params != 1) || (is_pfi && n_params != 2))\n     {\n-      error_at (loc, \"expected exactly 1 argument\");\n-      return NULL_TREE;\n+      error_at (loc, \"wrong number of arguments\");\n+      return error_mark_node;\n     }\n \n   tree param = (*params)[0];\n \n-  /* If not generating BPF_CORE information, the builtin does nothing.  */\n-  if (!TARGET_BPF_CORE)\n+  /* If not generating BPF_CORE information, preserve_access_index does nothing,\n+     and simply \"resolves to\" the argument.  */\n+  if (!TARGET_BPF_CORE && is_pai)\n     return param;\n \n+  if (is_pfi && !bpf_is_valid_preserve_field_info_arg (param))\n+    {\n+      error_at (EXPR_LOC_OR_LOC (param, loc),\n+\t\t\"argument is not a field access\");\n+      return error_mark_node;\n+    }\n+\n   /* Do remove_c_maybe_const_expr for the arg.\n      TODO: WHY do we have to do this here? Why doesn't c-typeck take care\n      of it before or after this hook? */\n@@ -1387,7 +1640,11 @@ bpf_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)\n      This ensures that all the relevant information remains within the\n      expression trees the builtin finally gets.  */\n \n-  walk_tree (&param, bpf_core_walk, (void *) &loc, NULL);\n+  struct core_walk_data data;\n+  data.loc = loc;\n+  data.arg = is_pai ? NULL_TREE : (*params)[1];\n+\n+  walk_tree (&param, bpf_core_walk, (void *) &data, NULL);\n \n   return param;\n }\n@@ -1524,7 +1781,8 @@ handle_attr_preserve (function *fn)\n \t\t      emit_label (label);\n \n \t\t      /* Add the CO-RE relocation information to the BTF container.  */\n-\t\t      bpf_core_reloc_add (container, section_name, &accessors, label);\n+\t\t      bpf_core_reloc_add (container, section_name, &accessors, label,\n+\t\t\t\t\t  BPF_RELO_FIELD_BYTE_OFFSET);\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "9f71040846b522ceffc7a97e0e1089b65e8e66dd", "filename": "gcc/config/bpf/coreout.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fbpf%2Fcoreout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fbpf%2Fcoreout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fcoreout.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -152,7 +152,8 @@ static GTY (()) vec<bpf_core_section_ref, va_gc> *bpf_core_sections;\n \n void\n bpf_core_reloc_add (const tree type, const char * section_name,\n-\t\t    vec<unsigned int> *accessors, rtx_code_label *label)\n+\t\t    vec<unsigned int> *accessors, rtx_code_label *label,\n+\t\t    enum btf_core_reloc_kind kind)\n {\n   char buf[40];\n   unsigned int i, n = 0;\n@@ -173,7 +174,7 @@ bpf_core_reloc_add (const tree type, const char * section_name,\n \n   bpfcr->bpfcr_type = get_btf_id (ctf_lookup_tree_type (ctfc, type));\n   bpfcr->bpfcr_insn_label = label;\n-  bpfcr->bpfcr_kind = BPF_RELO_FIELD_BYTE_OFFSET;\n+  bpfcr->bpfcr_kind = kind;\n \n   /* Add the CO-RE reloc to the appropriate section.  */\n   bpf_core_section_ref sec;"}, {"sha": "498853f6e001240e790932e85e83802e9a376111", "filename": "gcc/config/bpf/coreout.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fbpf%2Fcoreout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fbpf%2Fcoreout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fcoreout.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -103,7 +103,7 @@ extern void btf_ext_init (void);\n extern void btf_ext_output (void);\n \n extern void bpf_core_reloc_add (const tree, const char *, vec<unsigned int> *,\n-\t\t\t\trtx_code_label *);\n+\t\t\t\trtx_code_label *, enum btf_core_reloc_kind);\n extern int bpf_core_get_sou_member_index (ctf_container_ref, const tree);\n \n #ifdef\t__cplusplus"}, {"sha": "537eee6ab88029171098f18d29daea1d36690d44", "filename": "gcc/config/csky/csky.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fcsky%2Fcsky.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fcsky%2Fcsky.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2086,7 +2086,8 @@ csky_setup_incoming_varargs (cumulative_args_t pcum_v,\n \n   cfun->machine->uses_anonymous_args = 1;\n   local_cum = *pcum;\n-  csky_function_arg_advance (local_cum_v, arg);\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl)))\n+    csky_function_arg_advance (local_cum_v, arg);\n   regs_to_push = CSKY_NPARM_REGS - local_cum.reg;\n   if (regs_to_push)\n     *pretend_size  = regs_to_push * UNITS_PER_WORD;\n@@ -7300,7 +7301,7 @@ csky_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n void\n csky_init_builtins (void)\n {\n-  /* Inint fp16.  */\n+  /* Init fp16.  */\n   static tree csky_floatHF_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (csky_floatHF_type_node) = GET_MODE_PRECISION (HFmode);\n   layout_type (csky_floatHF_type_node);\n@@ -7313,10 +7314,10 @@ csky_init_builtins (void)\n static const char *\n csky_mangle_type (const_tree type)\n {\n-  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-      && DECL_NAME (TYPE_NAME (type))\n-      && !strcmp (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))), \"__fp16\"))\n-    return \"__fp16\";\n+  if (TREE_CODE (type) == REAL_TYPE\n+      && TYPE_PRECISION (type) == 16\n+      && TYPE_MAIN_VARIANT (type) != float16_type_node)\n+    return \"Dh\";\n \n   /* Use the default mangling.  */\n   return NULL;"}, {"sha": "97304947c0a8c9a76b8b20eb7fbbf22a45e0f2b9", "filename": "gcc/config/darwin-d.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fdarwin-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fdarwin-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-d.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -67,10 +67,10 @@ darwin_d_register_target_info (void)\n #undef TARGET_D_MINFO_SECTION\n #define TARGET_D_MINFO_SECTION \"__DATA,__minfodata\"\n \n-#undef TARGET_D_MINFO_START_NAME\n-#define TARGET_D_MINFO_START_NAME \"*section$start$__DATA$__minfodata\"\n+#undef TARGET_D_MINFO_SECTION_START\n+#define TARGET_D_MINFO_SECTION_START \"*section$start$__DATA$__minfodata\"\n \n-#undef TARGET_D_MINFO_END_NAME\n-#define TARGET_D_MINFO_END_NAME \"*section$end$__DATA$__minfodata\"\n+#undef TARGET_D_MINFO_SECTION_END\n+#define TARGET_D_MINFO_SECTION_END \"*section$end$__DATA$__minfodata\"\n \n struct gcc_targetdm targetdm = TARGETDM_INITIALIZER;"}, {"sha": "f8b3be4358ac896599b98bd1dd102500b84c3025", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -482,9 +482,3 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #undef TARGET_LIBC_HAS_FUNCTION\n #define TARGET_LIBC_HAS_FUNCTION no_c99_libc_has_function\n-\n-/* ELF support needed only by D front-end.  */\n-\n-#define TARGET_D_MINFO_SECTION \"minfo\"\n-#define TARGET_D_MINFO_START_NAME \"__start_minfo\"\n-#define TARGET_D_MINFO_END_NAME \"__stop_minfo\""}, {"sha": "c4e3ceaeb2ab4b1866d3d2dab70f1f8a4721fbcb", "filename": "gcc/config/epiphany/epiphany.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fepiphany%2Fepiphany.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fepiphany%2Fepiphany.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -727,11 +727,13 @@ epiphany_setup_incoming_varargs (cumulative_args_t cum,\n   machine_function_t *mf = MACHINE_FUNCTION (cfun);\n \n   /* All BLKmode values are passed by reference.  */\n-  gcc_assert (arg.mode != BLKmode);\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl)))\n+    gcc_assert (arg.mode != BLKmode);\n \n   next_cum = *get_cumulative_args (cum);\n-  next_cum = (ROUND_ADVANCE_CUM (next_cum, arg.mode, arg.type)\n-\t      + ROUND_ADVANCE_ARG (arg.mode, arg.type));\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl)))\n+    next_cum = (ROUND_ADVANCE_CUM (next_cum, arg.mode, arg.type)\n+\t\t+ ROUND_ADVANCE_ARG (arg.mode, arg.type));\n   first_anon_arg = next_cum;\n \n   if (first_anon_arg < MAX_EPIPHANY_PARM_REGS && !no_rtl)"}, {"sha": "334bb44e37f86124278cad7dc98ef80043bcfdef", "filename": "gcc/config/fr30/fr30.cc", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Ffr30%2Ffr30.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Ffr30%2Ffr30.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -471,16 +471,19 @@ fr30_setup_incoming_varargs (cumulative_args_t arg_regs_used_so_far_v,\n     = get_cumulative_args (arg_regs_used_so_far_v);\n   int size;\n \n-  /* All BLKmode values are passed by reference.  */\n-  gcc_assert (arg.mode != BLKmode);\n-\n-  /* ??? This run-time test as well as the code inside the if\n-     statement is probably unnecessary.  */\n-  if (targetm.calls.strict_argument_naming (arg_regs_used_so_far_v))\n-    /* If TARGET_STRICT_ARGUMENT_NAMING returns true, then the last named\n-       arg must not be treated as an anonymous arg.  */\n-    /* ??? This is a pointer increment, which makes no sense.  */\n-    arg_regs_used_so_far += fr30_num_arg_regs (arg);\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl)))\n+    {\n+      /* All BLKmode values are passed by reference.  */\n+      gcc_assert (arg.mode != BLKmode);\n+\n+      /* ??? This run-time test as well as the code inside the if\n+\t statement is probably unnecessary.  */\n+      if (targetm.calls.strict_argument_naming (arg_regs_used_so_far_v))\n+\t/* If TARGET_STRICT_ARGUMENT_NAMING returns true, then the last named\n+\t   arg must not be treated as an anonymous arg.  */\n+\t/* ??? This is a pointer increment, which makes no sense.  */\n+\targ_regs_used_so_far += fr30_num_arg_regs (arg);\n+    }\n \n   size = FR30_NUM_ARG_REGS - (* arg_regs_used_so_far);\n "}, {"sha": "5cdb0bfe6e9fbb0b540b86e5dc32444330d55801", "filename": "gcc/config/frv/frv.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Ffrv%2Ffrv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Ffrv%2Ffrv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -2104,7 +2104,8 @@ frv_setup_incoming_varargs (cumulative_args_t cum_v,\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (TARGET_DEBUG_ARG)\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl))\n+      && TARGET_DEBUG_ARG)\n     fprintf (stderr,\n \t     \"setup_vararg: words = %2d, mode = %4s, pretend_size = %d, second_time = %d\\n\",\n \t     *cum, GET_MODE_NAME (arg.mode), *pretend_size, second_time);"}, {"sha": "d6b73d4868669e3fa572e917ce0f9db97e43e6fe", "filename": "gcc/config/ft32/ft32.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fft32%2Fft32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fft32%2Fft32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -634,8 +634,10 @@ ft32_setup_incoming_varargs (cumulative_args_t cum_v,\n \t\t\t     int *pretend_size, int no_rtl ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int named_size =\n-    GET_MODE_SIZE (SImode) * (*cum - FT32_R0) + GET_MODE_SIZE (arg.mode);\n+  int named_size = 0;\n+  if (!TYPE_NO_NAMED_ARGS_STDARG_P (TREE_TYPE (current_function_decl)))\n+    named_size =\n+      GET_MODE_SIZE (SImode) * (*cum - FT32_R0) + GET_MODE_SIZE (arg.mode);\n \n   if (named_size < 24)\n     *pretend_size = 24 - named_size;"}, {"sha": "1b8a3203463d85fa64d9220d6d3f9ca4c15c0958", "filename": "gcc/config/gcn/gcn-modes.def", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-modes.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -29,6 +29,48 @@ VECTOR_MODE (FLOAT, HF, 64);    /*\t\t  V64HF */\n VECTOR_MODE (FLOAT, SF, 64);    /*\t\t  V64SF */\n VECTOR_MODE (FLOAT, DF, 64);    /*\t\t  V64DF */\n \n+/* Artificial vector modes, for when vector masking doesn't work (yet).  */\n+VECTOR_MODE (INT, QI, 32);      /*\t\t  V32QI */\n+VECTOR_MODE (INT, HI, 32);      /*\t\t  V32HI */\n+VECTOR_MODE (INT, SI, 32);      /*\t\t  V32SI */\n+VECTOR_MODE (INT, DI, 32);      /*\t\t  V32DI */\n+VECTOR_MODE (INT, TI, 32);      /*\t\t  V32TI */\n+VECTOR_MODE (FLOAT, HF, 32);    /*\t\t  V32HF */\n+VECTOR_MODE (FLOAT, SF, 32);    /*\t\t  V32SF */\n+VECTOR_MODE (FLOAT, DF, 32);    /*\t\t  V32DF */\n+VECTOR_MODE (INT, QI, 16);      /*\t\t  V16QI */\n+VECTOR_MODE (INT, HI, 16);      /*\t\t  V16HI */\n+VECTOR_MODE (INT, SI, 16);      /*\t\t  V16SI */\n+VECTOR_MODE (INT, DI, 16);      /*\t\t  V16DI */\n+VECTOR_MODE (INT, TI, 16);      /*\t\t  V16TI */\n+VECTOR_MODE (FLOAT, HF, 16);    /*\t\t  V16HF */\n+VECTOR_MODE (FLOAT, SF, 16);    /*\t\t  V16SF */\n+VECTOR_MODE (FLOAT, DF, 16);    /*\t\t  V16DF */\n+VECTOR_MODE (INT, QI, 8);      /*\t\t  V8QI */\n+VECTOR_MODE (INT, HI, 8);      /*\t\t  V8HI */\n+VECTOR_MODE (INT, SI, 8);      /*\t\t  V8SI */\n+VECTOR_MODE (INT, DI, 8);      /*\t\t  V8DI */\n+VECTOR_MODE (INT, TI, 8);      /*\t\t  V8TI */\n+VECTOR_MODE (FLOAT, HF, 8);    /*\t\t  V8HF */\n+VECTOR_MODE (FLOAT, SF, 8);    /*\t\t  V8SF */\n+VECTOR_MODE (FLOAT, DF, 8);    /*\t\t  V8DF */\n+VECTOR_MODE (INT, QI, 4);      /*\t\t  V4QI */\n+VECTOR_MODE (INT, HI, 4);      /*\t\t  V4HI */\n+VECTOR_MODE (INT, SI, 4);      /*\t\t  V4SI */\n+VECTOR_MODE (INT, DI, 4);      /*\t\t  V4DI */\n+VECTOR_MODE (INT, TI, 4);      /*\t\t  V4TI */\n+VECTOR_MODE (FLOAT, HF, 4);    /*\t\t  V4HF */\n+VECTOR_MODE (FLOAT, SF, 4);    /*\t\t  V4SF */\n+VECTOR_MODE (FLOAT, DF, 4);    /*\t\t  V4DF */\n+VECTOR_MODE (INT, QI, 2);      /*\t\t  V2QI */\n+VECTOR_MODE (INT, HI, 2);      /*\t\t  V2HI */\n+VECTOR_MODE (INT, SI, 2);      /*\t\t  V2SI */\n+VECTOR_MODE (INT, DI, 2);      /*\t\t  V2DI */\n+VECTOR_MODE (INT, TI, 2);      /*\t\t  V2TI */\n+VECTOR_MODE (FLOAT, HF, 2);    /*\t\t  V2HF */\n+VECTOR_MODE (FLOAT, SF, 2);    /*\t\t  V2SF */\n+VECTOR_MODE (FLOAT, DF, 2);    /*\t\t  V2DF */\n+\n /* Vector units handle reads independently and thus no large alignment\n    needed.  */\n ADJUST_ALIGNMENT (V64QI, 1);\n@@ -39,3 +81,43 @@ ADJUST_ALIGNMENT (V64TI, 16);\n ADJUST_ALIGNMENT (V64HF, 2);\n ADJUST_ALIGNMENT (V64SF, 4);\n ADJUST_ALIGNMENT (V64DF, 8);\n+ADJUST_ALIGNMENT (V32QI, 1);\n+ADJUST_ALIGNMENT (V32HI, 2);\n+ADJUST_ALIGNMENT (V32SI, 4);\n+ADJUST_ALIGNMENT (V32DI, 8);\n+ADJUST_ALIGNMENT (V32TI, 16);\n+ADJUST_ALIGNMENT (V32HF, 2);\n+ADJUST_ALIGNMENT (V32SF, 4);\n+ADJUST_ALIGNMENT (V32DF, 8);\n+ADJUST_ALIGNMENT (V16QI, 1);\n+ADJUST_ALIGNMENT (V16HI, 2);\n+ADJUST_ALIGNMENT (V16SI, 4);\n+ADJUST_ALIGNMENT (V16DI, 8);\n+ADJUST_ALIGNMENT (V16TI, 16);\n+ADJUST_ALIGNMENT (V16HF, 2);\n+ADJUST_ALIGNMENT (V16SF, 4);\n+ADJUST_ALIGNMENT (V16DF, 8);\n+ADJUST_ALIGNMENT (V8QI, 1);\n+ADJUST_ALIGNMENT (V8HI, 2);\n+ADJUST_ALIGNMENT (V8SI, 4);\n+ADJUST_ALIGNMENT (V8DI, 8);\n+ADJUST_ALIGNMENT (V8TI, 16);\n+ADJUST_ALIGNMENT (V8HF, 2);\n+ADJUST_ALIGNMENT (V8SF, 4);\n+ADJUST_ALIGNMENT (V8DF, 8);\n+ADJUST_ALIGNMENT (V4QI, 1);\n+ADJUST_ALIGNMENT (V4HI, 2);\n+ADJUST_ALIGNMENT (V4SI, 4);\n+ADJUST_ALIGNMENT (V4DI, 8);\n+ADJUST_ALIGNMENT (V4TI, 16);\n+ADJUST_ALIGNMENT (V4HF, 2);\n+ADJUST_ALIGNMENT (V4SF, 4);\n+ADJUST_ALIGNMENT (V4DF, 8);\n+ADJUST_ALIGNMENT (V2QI, 1);\n+ADJUST_ALIGNMENT (V2HI, 2);\n+ADJUST_ALIGNMENT (V2SI, 4);\n+ADJUST_ALIGNMENT (V2DI, 8);\n+ADJUST_ALIGNMENT (V2TI, 16);\n+ADJUST_ALIGNMENT (V2HF, 2);\n+ADJUST_ALIGNMENT (V2SF, 4);\n+ADJUST_ALIGNMENT (V2DF, 8);"}, {"sha": "f9a1fc00b4f0c1561c5b7e6ddd31282f4f849e68", "filename": "gcc/config/gcn/gcn-protos.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "patch": "@@ -24,6 +24,8 @@ extern bool gcn_constant64_p (rtx);\n extern bool gcn_constant_p (rtx);\n extern rtx gcn_convert_mask_mode (rtx reg);\n extern unsigned int gcn_dwarf_register_number (unsigned int regno);\n+extern rtx get_exec (int64_t);\n+extern rtx get_exec (machine_mode mode);\n extern char * gcn_expand_dpp_shr_insn (machine_mode, const char *, int, int);\n extern void gcn_expand_epilogue ();\n extern rtx gcn_expand_scaled_offsets (addr_space_t as, rtx base, rtx offsets,\n@@ -34,8 +36,6 @@ extern rtx gcn_expand_scalar_to_vector_address (machine_mode, rtx, rtx, rtx);\n extern void gcn_expand_vector_init (rtx, rtx);\n extern bool gcn_flat_address_p (rtx, machine_mode);\n extern bool gcn_fp_constant_p (rtx, bool);\n-extern rtx gcn_full_exec ();\n-extern rtx gcn_full_exec_reg ();\n extern rtx gcn_gen_undef (machine_mode);\n extern bool gcn_global_address_p (rtx);\n extern tree gcn_goacc_adjust_private_decl (location_t, tree var, int level);\n@@ -67,8 +67,6 @@ extern rtx gcn_operand_part (machine_mode, rtx, int);\n extern bool gcn_regno_mode_code_ok_for_base_p (int, machine_mode,\n \t\t\t\t\t       addr_space_t, int, int);\n extern reg_class gcn_regno_reg_class (int regno);\n-extern rtx gcn_scalar_exec ();\n-extern rtx gcn_scalar_exec_reg ();\n extern bool gcn_scalar_flat_address_p (rtx);\n extern bool gcn_scalar_flat_mem_p (rtx);\n extern bool gcn_sgpr_move_p (rtx, rtx);\n@@ -105,9 +103,11 @@ extern gimple_opt_pass *make_pass_omp_gcn (gcc::context *ctxt);\n inline bool\n vgpr_1reg_mode_p (machine_mode mode)\n {\n-  return (mode == SImode || mode == SFmode || mode == HImode || mode == QImode\n-\t  || mode == V64QImode || mode == V64HImode || mode == V64SImode\n-\t  || mode == V64HFmode || mode == V64SFmode || mode == BImode);\n+  if (VECTOR_MODE_P (mode))\n+    mode = GET_MODE_INNER (mode);\n+\n+  return (mode == SImode || mode == SFmode || mode == HImode || mode == HFmode\n+\t  || mode == QImode || mode == BImode);\n }\n \n /* Return true if MODE is valid for 1 SGPR register.  */\n@@ -124,18 +124,18 @@ sgpr_1reg_mode_p (machine_mode mode)\n inline bool\n vgpr_2reg_mode_p (machine_mode mode)\n {\n-  return (mode == DImode || mode == DFmode\n-\t  || mode == V64DImode || mode == V64DFmode);\n+  if (VECTOR_MODE_P (mode))\n+    mode = GET_MODE_INNER (mode);\n+\n+  return (mode == DImode || mode == DFmode);\n }\n \n /* Return true if MODE can be handled directly by VGPR operations.  */\n \n inline bool\n vgpr_vector_mode_p (machine_mode mode)\n {\n-  return (mode == V64QImode || mode == V64HImode\n-\t  || mode == V64SImode || mode == V64DImode\n-\t  || mode == V64HFmode || mode == V64SFmode || mode == V64DFmode);\n+  return VECTOR_MODE_P (mode);\n }\n \n "}, {"sha": "3b619512e13fbbb078795c6467ee002bf9f3b4b8", "filename": "gcc/config/gcn/gcn-valu.md", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "b9d9170f167650dd336f616737b8760c950153f4", "filename": "gcc/config/gcn/gcn.cc", "status": "modified", "additions": 726, "deletions": 379, "changes": 1105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "38f7212db59a209ca0762f62e26b924562878261", "filename": "gcc/config/gcn/gcn.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "987b76396cc110fe1cbe8a695fdc1f84ef5216c7", "filename": "gcc/config/gcn/gcn.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgcn%2Fgcn.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "1c0dff2afe7b0f0bcb00ab98b786afe70d8f7e3b", "filename": "gcc/config/gnu-d.cc", "status": "renamed", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgnu-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgnu-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgnu-d.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "previous_filename": "gcc/config/glibc-d.cc"}, {"sha": "e8d72463ab23eb775fc4dcaae787ecfb929e9772", "filename": "gcc/config/gnu.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fgnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgnu.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "fd5cf2f4af4aa068686093803a01d49df3109000", "filename": "gcc/config/h8300/combiner.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fcombiner.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fcombiner.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fcombiner.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "7e6681c44921b5d6fa53983a732e1553801fd871", "filename": "gcc/config/h8300/constraints.md", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fconstraints.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "7149dc0ac52ef0157ce516bfa0f1b340d8ade883", "filename": "gcc/config/h8300/extensions.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fextensions.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fextensions.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fextensions.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "77adfaba07b28dcfc61ac21659f9fb72b2e4a0c6", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "cd7975e2fff202d77f854760a1328817b68f5006", "filename": "gcc/config/h8300/h8300.cc", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fh8300.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fh8300.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "45cc4fc77969545d94dcf9edd1c5203b68bf7eb0", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "f592af1d5f7ccb7c9aa1c9863096db62ff959a03", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "e536602a01d6ecb4ef2385aabc002bc87084ff57", "filename": "gcc/config/h8300/movepush.md", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fmovepush.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Fmovepush.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fmovepush.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "81dce1d0bc1feaf9f014871005f4c699a1647039", "filename": "gcc/config/h8300/testcompare.md", "status": "modified", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ftestcompare.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "ea1d0125b3fb704338ccac5755a6b678cd8469d4", "filename": "gcc/config/i386/avx512bf16intrin.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favx512bf16intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favx512bf16intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favx512bf16intrin.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "e70690342cf5a4ee575fe949fb0caa26800bc2c5", "filename": "gcc/config/i386/avx512bf16vlintrin.h", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favx512bf16vlintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favx512bf16vlintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favx512bf16vlintrin.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "506dce8e4772ee8abfa2493023694f890dccd526", "filename": "gcc/config/i386/avx512ifmavlintrin.h", "status": "modified", "additions": 20, "deletions": 39, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favx512ifmavlintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favx512ifmavlintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favx512ifmavlintrin.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "3878d10f991d0f588a309e93492e80073fe33703", "filename": "gcc/config/i386/avxifmaintrin.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favxifmaintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favxifmaintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favxifmaintrin.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "916f00a6676914e97b331d25871b42d832471a7a", "filename": "gcc/config/i386/avxneconvertintrin.h", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favxneconvertintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favxneconvertintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favxneconvertintrin.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "362e6f65c2ad9da3ea9cdd730176584e7032c67e", "filename": "gcc/config/i386/avxvnniint8intrin.h", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favxvnniint8intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Favxvnniint8intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favxvnniint8intrin.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "18bbc0cb7bed7e9862deaa0672c9f8391a01109a", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "6d70d499eef2760f7f166dc8e5d92420eb09505b", "filename": "gcc/config/i386/cygwin-d.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fcygwin-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fcygwin-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin-d.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "0a604d65b320645b389e4e9e2eb373a0545cf975", "filename": "gcc/config/i386/cygwin.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fcygwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fcygwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "aa16895442f7575e19d37355237982261fa73867", "filename": "gcc/config/i386/driver-i386.cc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fdriver-i386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fdriver-i386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "abbb50b1192ea6710756f7c1e9beec1f6c1a36d6", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "9345b8c5d6944f2ef64d78cf1b3e64f946ec07a8", "filename": "gcc/config/i386/i386-builtin.def", "status": "modified", "additions": 71, "deletions": 39, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "9412cf1acc86f3edc162ed742b2cbd9c243b7398", "filename": "gcc/config/i386/i386-builtins.cc", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "fa195e739a6434ffbf6969b45ab1eda0777f483b", "filename": "gcc/config/i386/i386-c.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "7d17bfeadeacc4576d5e903e1b31874203ad6349", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 113, "deletions": 25, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "4ea3f96f69fb4434c9732c2e077f79c8345c6154", "filename": "gcc/config/i386/i386-isa.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-isa.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-isa.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-isa.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "dbc3165c5fc6b15515e5e427b3b82ebbdb4c72b7", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "ef9c888980c0c88a5df870865717d4d1eefd146c", "filename": "gcc/config/i386/i386-options.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-options.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-options.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "5318fc7fddfe7b7b36cca4490793f6f06ef10bb5", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "f8586499cd10e4ad5706fe01e8fc2a847c592451", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 17, "deletions": 67, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "16d9c60607751cb070714dbc50d2d738ea3a853f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "85567980aa379d685d53169fdf02bf9e1f97725c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 338, "deletions": 31, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "6e07b89ac4c86fd2214860eb49c6faad0d7cccdb", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "8629abaf30c2cd3d41fd045bd102a74c273ed7cb", "filename": "gcc/config/i386/immintrin.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fimmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fimmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fimmintrin.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "53cf86f58e77e21d7b0f41019086c5d16131423d", "filename": "gcc/config/i386/linux-common.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Flinux-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Flinux-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux-common.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "7d4eda3ed49424b6bc17a49a86461b77b4902f3f", "filename": "gcc/config/i386/mingw-mcfgthread.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fmingw-mcfgthread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fmingw-mcfgthread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw-mcfgthread.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "19a98c3d995157ab61d824ec72e1f207d5b6d697", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "d5134cc351efcf3233ba01eab24f9d42346e388c", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "c4141a9673558899b6a0c583fb3bb445efaa4c5e", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "fa93ae7bf21574f862133f16b7ac3aa544a69f8e", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 377, "deletions": 150, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "f892c27b71d66b4a1567d37e18be418d6544603e", "filename": "gcc/config/i386/t-cygming", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Ft-cygming", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Ft-cygming", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-cygming?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "1596408aa76122ff0296ddee408dfa01a3d67896", "filename": "gcc/config/i386/t-i386", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Ft-i386", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Ft-i386", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-i386?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "843c7139cb25b504d6f63fb05f0999aeee4a81fe", "filename": "gcc/config/i386/winnt-d.cc", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fwinnt-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fwinnt-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt-d.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "aeaa7eb008e2e6776072c48069f63cae1ab90ec7", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "96eb06a5b6dd67e13ad02609fb9b39add7dc3c28", "filename": "gcc/config/i386/x86-tune-sched.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fx86-tune-sched.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fx86-tune-sched.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-sched.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "4aa098fd80cca2b2807aceb7983b3fb10a127d9d", "filename": "gcc/config/i386/znver.md", "status": "renamed", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fznver.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fi386%2Fznver.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fznver.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6", "previous_filename": "gcc/config/i386/znver1.md"}, {"sha": "6df1ce736bcb6704aa204e58c1ecaea3c73ca255", "filename": "gcc/config/ia64/ia64.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fia64%2Fia64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fia64%2Fia64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "0bfa6bd8a56991c69781e5bd2b659b6aca5515f2", "filename": "gcc/config/kfreebsd-d.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fkfreebsd-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fkfreebsd-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fkfreebsd-d.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "c28fcaf54f5b5a7cfc8e787af5ff753b0977f1ce", "filename": "gcc/config/kfreebsd-gnu.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fkfreebsd-gnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fkfreebsd-gnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fkfreebsd-gnu.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "197471ab92730050df213843e6acca6bef2d4ae1", "filename": "gcc/config/kopensolaris-d.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fkopensolaris-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fkopensolaris-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fkopensolaris-d.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "3929d4b6955026334f5348321601626c0cf0786b", "filename": "gcc/config/kopensolaris-gnu.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fkopensolaris-gnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fkopensolaris-gnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fkopensolaris-gnu.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "f335ceabab53efa517f9274c025d80b4e851d73e", "filename": "gcc/config/linux-android.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Flinux-android.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Flinux-android.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux-android.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "f2ef2f03e71156425f0060ce674b33561d191adc", "filename": "gcc/config/linux-d.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Flinux-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Flinux-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux-d.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "d1d6753a2f629b8aeb1cc46d67f1aff7bd851c7e", "filename": "gcc/config/linux.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "f54c233f90c69a42f08dcf9e1db3766dafed5ad6", "filename": "gcc/config/loongarch/loongarch.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "214b14bddd399b49e14497272ef12126ba121e63", "filename": "gcc/config/loongarch/loongarch.md", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Floongarch%2Floongarch.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Floongarch%2Floongarch.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "e3489fb4dc06880d653abf2481562d61a4e90004", "filename": "gcc/config/m32r/m32r.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fm32r%2Fm32r.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fm32r%2Fm32r.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "605d63b6a709bd6b4927730ef2cc80ac2c46ef0a", "filename": "gcc/config/mcore/mcore.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmcore%2Fmcore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmcore%2Fmcore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "9290a1f3958ece79e6099f6d88fe89adb2a075db", "filename": "gcc/config/microblaze/microblaze.cc", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "327ad255c3e7e22e59775b8aa2196171b1e47092", "filename": "gcc/config/mips/driver-native.cc", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Fdriver-native.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Fdriver-native.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fdriver-native.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "b29f4aa3a0e6f0a4f4e443cfdb425249431bc9c8", "filename": "gcc/config/mips/linux-common.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Flinux-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Flinux-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flinux-common.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "0ac0248fb9e3f444c11312e46cfb4470df8e1a25", "filename": "gcc/config/mips/mips.cc", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Fmips.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Fmips.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "69de74eb416a104bd5810eb965d86b63820c827a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "37d176ea30943ac8e9a11964565fc99366173d7d", "filename": "gcc/config/mips/t-linux64", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Ft-linux64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmips%2Ft-linux64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-linux64?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "1ac7b883ac5c3632c3230759089d3cfab4488577", "filename": "gcc/config/mmix/mmix.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmmix%2Fmmix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fmmix%2Fmmix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "639baef6c1752b3a992a72c48e93836ae9f87932", "filename": "gcc/config/nds32/nds32.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fnds32%2Fnds32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fnds32%2Fnds32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "6a894ec345e537077c0cd90973ac319ca7527b49", "filename": "gcc/config/nios2/nios2.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fnios2%2Fnios2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fnios2%2Fnios2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "0ce7b234417d7d17fae5339050690cde5e242ccd", "filename": "gcc/config/or1k/or1k.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2For1k%2For1k.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2For1k%2For1k.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "517fa02e272925e9e6f75939ff4a6d555352e0a4", "filename": "gcc/config/pru/pru-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-protos.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "0029dcbc6aaddd02ba835d0fc4eb83ff220ed11d", "filename": "gcc/config/pru/pru.cc", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fpru%2Fpru.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fpru%2Fpru.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "bdc5ad79ba06008e9fbf2aade395b4195e1b2a76", "filename": "gcc/config/pru/pru.md", "status": "modified", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fpru%2Fpru.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Fpru%2Fpru.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "2498db506b7abc65d1f1131b16e8ca73b6350623", "filename": "gcc/config/riscv/arch-canonicalize", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Farch-canonicalize", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Farch-canonicalize", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Farch-canonicalize?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "4088c48150a573db608a70942511291c5f567fee", "filename": "gcc/config/riscv/constraints.md", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fconstraints.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "50380ecfac96b149966b65afddfb32cc0982ca3f", "filename": "gcc/config/riscv/iterators.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fiterators.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "c2ff41bb0fd87635cdaef88acaecae301110a96c", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "021f6c6b69a6500ee126d81a7c5f2f86022eba6f", "filename": "gcc/config/riscv/riscv-builtins.cc", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "826ae0067bb8c5e19c74191520aff96042f777b7", "filename": "gcc/config/riscv/riscv-c.cc", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-c.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "b84ad999ac14f773b88f4f779c658a7732954ef7", "filename": "gcc/config/riscv/riscv-cores.def", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-cores.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "556b5c552537be88dd7ab1cb831bd2123ad60ede", "filename": "gcc/config/riscv/riscv-modes.def", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-modes.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "1dfe8c8920912f241c34ad855ec2a5afe9ad39f2", "filename": "gcc/config/riscv/riscv-opts.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-opts.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "5a718bb62b45339e95a601db67d02921488c1a49", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "6615a5c7ffe977d1e4001bac148fc1f284735635", "filename": "gcc/config/riscv/riscv-v.cc", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "231b63a610d32a3fa1d2cf198a1dee3b8084bb98", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "a0ae18eef03c3e473090dfea496f9dcc816ea0b8", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "dc41537865e271221a8ca84311d7785dbde8ad44", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "24fc1c02341015b739471b73d98e7745b02b463a", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "f2d876fb1334add797817adf402608898314e7fc", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "f282a5e7654aaeb6849a9cf89704f685336df147", "filename": "gcc/config/riscv/riscv-vector-builtins-types.def", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "43150aa47a4797d111faa86bf1a6db27931aaf5f", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "added", "additions": 888, "deletions": 0, "changes": 888, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "b7a633ed376ba79b743a85e9771f2450bdad36c2", "filename": "gcc/config/riscv/riscv-vector-builtins.def", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "425da12326c8e6883147ddffafbf903850d4eb29", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "ee8ebd5f1ccafbefca1f383ee00b211016e93eea", "filename": "gcc/config/riscv/riscv-vector-switch.def", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "32f9ef9ade9f3e00f292bad67ae1cebb471b3367", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 211, "deletions": 18, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "1385f0a16dcb51fc49040939d3fcceafcb00ac06", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "798f7370a08fe9c5907758d07cb3f97171e4ca70", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "426ea95cd141ba48191776032f8f6e052f2044c7", "filename": "gcc/config/riscv/riscv.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.opt?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "1efe3f888b5afeb1a94ee67b14acf564c7b82694", "filename": "gcc/config/riscv/riscv_vector.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Friscv_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv_vector.h?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "449f275e6a2512ce8d3563999ad921fd20dcc371", "filename": "gcc/config/riscv/sync.md", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fsync.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "7997db3d898b6e0de56de6bfce13b4d5588514ec", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "627e2f78f65d6cc47d08d978b29234c17bbec569", "filename": "gcc/config/riscv/vector-iterators.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "451ed23ef5ae6b9cba3bb14e83e65c2f95cd051f", "filename": "gcc/config/riscv/vector.md", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "54fef8d9996e371282a4662fec7c042fcad5a522", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}, {"sha": "6da4de67137871ee887f052ec87a937b9c1c8a88", "filename": "gcc/config/rs6000/rs6000-call.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Frs6000%2Frs6000-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a59abbfc74c3961fb01323d9fbff8427518fde6/gcc%2Fconfig%2Frs6000%2Frs6000-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.cc?ref=0a59abbfc74c3961fb01323d9fbff8427518fde6"}]}