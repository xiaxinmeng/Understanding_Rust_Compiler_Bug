{"sha": "d47d0a8d97e00479a3efd3913bc996f319ac8139", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ3ZDBhOGQ5N2UwMDQ3OWEzZWZkMzkxM2JjOTk2ZjMxOWFjODEzOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-08T20:16:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-08T20:16:36Z"}, "message": "tree.h (TREE_ADDRESSABLE): Document its effect for function types.\n\n\t* tree.h (TREE_ADDRESSABLE): Document its effect for function types.\n\t* calls.c (expand_call): Pass the function type to aggregate_value_p.\n\t* function.c (aggregate_value_p): Do not honor DECL_BY_REFERENCE on\n\tthe target function of a CALL_EXPR.  Honor TREE_ADDRESSABLE on the\n\tfunction type instead.  Reorder and simplify checks.\n\n\t* gimplify.c (gimplify_modify_expr_rhs) <WITH_SIZE_EXPR>: New case.\nada/\n\t* gcc-interface/ada-tree.h (TYPE_RETURNS_UNCONSTRAINED_P): Rename into.\n\t(TYPE_RETURN_UNCONSTRAINED_P): ...this.\n\t(TYPE_RETURNS_BY_REF_P): Rename into.\n\t(TYPE_RETURN_BY_DIRECT_REF_P): ...this.\n\t(TYPE_RETURNS_BY_TARGET_PTR_P): Delete.\n\t* gcc-interface/gigi.h (create_subprog_type): Adjust parameter names.\n\t(build_return_expr): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Subprogram_Type>:\n\tRename local variables.  If the return Mechanism is By_Reference, pass\n\treturn_by_invisible_ref_p to create_subprog_type instead of toggling\n\tTREE_ADDRESSABLE.  Test return_by_invisible_ref_p in order to annotate\n\tthe mechanism.  Use regular return for contrained types with non-static\n\tsize and return by invisible reference for unconstrained return types\n\twith default discriminants.  Update comment.\n\t* gcc-interface/trans.c (Subprogram_Body_to_gnu): If the function\n\treturns by invisible reference, turn the RESULT_DECL into a pointer.\n\tDo not handle DECL_BY_REF_P in the CICO case here.\n\t(call_to_gnu): Remove code handling return by target pointer.  For a\n\tfunction call, if the return type has non-constant size, generate the\n\tassignment with an INIT_EXPR.\n\t(gnat_to_gnu) <N_Return_Statement>: Remove dead code in the CICO case.\n\tIf the function returns by invisible reference, build the copy return\n\toperation manually.\n\t(add_decl_expr): Initialize the variable with an INIT_EXPR.\n\t* gcc-interface/utils.c (create_subprog_type): Adjust parameter names.\n\tAdjust for renaming of macros.  Copy the node only when necessary.\n\t(create_subprog_decl): Do not toggle TREE_ADDRESSABLE on the return\n\ttype, only change DECL_BY_REFERENCE on the RETURN_DECL.\n\t(convert_from_reference): Delete.\n\t(is_byref_result): Likewise.\n\t(gnat_genericize_r): Likewise.\n\t(gnat_genericize): Likewise.\n\t(end_subprog_body): Do not call gnat_genericize.\n\t* gcc-interface/utils2.c (build_binary_op) <INIT_EXPR>: New case.\n\t(build_return_expr): Adjust parameter names, logic and comment.\n\nFrom-SVN: r158139", "tree": {"sha": "3bbe3665b3ad0f65e64b4973b9c1ddee13f15d9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bbe3665b3ad0f65e64b4973b9c1ddee13f15d9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d47d0a8d97e00479a3efd3913bc996f319ac8139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d47d0a8d97e00479a3efd3913bc996f319ac8139", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d47d0a8d97e00479a3efd3913bc996f319ac8139", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d47d0a8d97e00479a3efd3913bc996f319ac8139/comments", "author": null, "committer": null, "parents": [{"sha": "dc5ee869f578f51a2691833b4d60054bf7e2a0a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc5ee869f578f51a2691833b4d60054bf7e2a0a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc5ee869f578f51a2691833b4d60054bf7e2a0a9"}], "stats": {"total": 869, "additions": 334, "deletions": 535}, "files": [{"sha": "9b1c69edb4e327059b271094b22132e4f6fe7dc7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -1,3 +1,13 @@\n+2010-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree.h (TREE_ADDRESSABLE): Document its effect for function types.\n+\t* calls.c (expand_call): Pass the function type to aggregate_value_p.\n+\t* function.c (aggregate_value_p): Do not honor DECL_BY_REFERENCE on\n+\tthe target function of a CALL_EXPR.  Honor TREE_ADDRESSABLE on the\n+\tfunction type instead.  Reorder and simplify checks.\n+\n+\t* gimplify.c (gimplify_modify_expr_rhs) <WITH_SIZE_EXPR>: New case.\n+\n 2010-04-08  Jing Yu  <jingyu@google.com>\n \t    Zdenek Dvorak  <ook@ucw.cz>\n "}, {"sha": "e43a534a792a5f963591541fefda14c2ff4cc7f1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -1,3 +1,41 @@\n+2010-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_RETURNS_UNCONSTRAINED_P): Rename into.\n+\t(TYPE_RETURN_UNCONSTRAINED_P): ...this.\n+\t(TYPE_RETURNS_BY_REF_P): Rename into.\n+\t(TYPE_RETURN_BY_DIRECT_REF_P): ...this.\n+\t(TYPE_RETURNS_BY_TARGET_PTR_P): Delete.\n+\t* gcc-interface/gigi.h (create_subprog_type): Adjust parameter names.\n+\t(build_return_expr): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Subprogram_Type>:\n+\tRename local variables.  If the return Mechanism is By_Reference, pass\n+\treturn_by_invisible_ref_p to create_subprog_type instead of toggling\n+\tTREE_ADDRESSABLE.  Test return_by_invisible_ref_p in order to annotate\n+\tthe mechanism.  Use regular return for contrained types with non-static\n+\tsize and return by invisible reference for unconstrained return types\n+\twith default discriminants.  Update comment.\n+\t* gcc-interface/trans.c (Subprogram_Body_to_gnu): If the function\n+\treturns by invisible reference, turn the RESULT_DECL into a pointer.\n+\tDo not handle DECL_BY_REF_P in the CICO case here.\n+\t(call_to_gnu): Remove code handling return by target pointer.  For a\n+\tfunction call, if the return type has non-constant size, generate the\n+\tassignment with an INIT_EXPR.\n+\t(gnat_to_gnu) <N_Return_Statement>: Remove dead code in the CICO case.\n+\tIf the function returns by invisible reference, build the copy return\n+\toperation manually.\n+\t(add_decl_expr): Initialize the variable with an INIT_EXPR.\n+\t* gcc-interface/utils.c (create_subprog_type): Adjust parameter names.\n+\tAdjust for renaming of macros.  Copy the node only when necessary.\n+\t(create_subprog_decl): Do not toggle TREE_ADDRESSABLE on the return\n+\ttype, only change DECL_BY_REFERENCE on the RETURN_DECL.\n+\t(convert_from_reference): Delete.\n+\t(is_byref_result): Likewise.\n+\t(gnat_genericize_r): Likewise.\n+\t(gnat_genericize): Likewise.\n+\t(end_subprog_body): Do not call gnat_genericize.\n+\t* gcc-interface/utils2.c (build_binary_op) <INIT_EXPR>: New case.\n+\t(build_return_expr): Adjust parameter names, logic and comment.\n+\n 2010-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_pakd.adb (Create_Packed_Array_Type): Always use a modular type"}, {"sha": "8a646fe370412bae1dfaf1a067aae352b7c94413", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -90,7 +90,7 @@ do {\t\t\t\t\t\t\t    \\\n \n /* For FUNCTION_TYPE, nonzero if this denotes a function returning an\n    unconstrained array or record.  */\n-#define TYPE_RETURNS_UNCONSTRAINED_P(NODE) \\\n+#define TYPE_RETURN_UNCONSTRAINED_P(NODE) \\\n   TYPE_LANG_FLAG_1 (FUNCTION_TYPE_CHECK (NODE))\n \n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this denotes\n@@ -135,8 +135,10 @@ do {\t\t\t\t\t\t\t    \\\n #define TYPE_CONVENTION_FORTRAN_P(NODE) \\\n   TYPE_LANG_FLAG_4 (ARRAY_TYPE_CHECK (NODE))\n \n-/* For FUNCTION_TYPEs, nonzero if the function returns by reference.  */\n-#define TYPE_RETURNS_BY_REF_P(NODE) \\\n+/* For FUNCTION_TYPEs, nonzero if the function returns by direct reference,\n+   i.e. the callee returns a pointer to a memory location it has allocated\n+   and the caller only needs to dereference the pointer.  */\n+#define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \\\n   TYPE_LANG_FLAG_4 (FUNCTION_TYPE_CHECK (NODE))\n \n /* For VOID_TYPE, ENUMERAL_TYPE, UNION_TYPE, and RECORD_TYPE, nonzero if this\n@@ -148,11 +150,6 @@ do {\t\t\t\t\t\t\t    \\\n     || TREE_CODE (NODE) == UNION_TYPE || TREE_CODE (NODE) == ENUMERAL_TYPE) \\\n    && TYPE_DUMMY_P (NODE))\n \n-/* For FUNCTION_TYPEs, nonzero if function returns by being passed a pointer\n-   to a place to store its result.  */\n-#define TYPE_RETURNS_BY_TARGET_PTR_P(NODE) \\\n-  TYPE_LANG_FLAG_5 (FUNCTION_TYPE_CHECK (NODE))\n-\n /* For an INTEGER_TYPE, nonzero if TYPE_ACTUAL_BOUNDS is present.  */\n #define TYPE_HAS_ACTUAL_BOUNDS_P(NODE) \\\n   TYPE_LANG_FLAG_5 (INTEGER_TYPE_CHECK (NODE))"}, {"sha": "25b4c07fc46c26ecae455b4f5219fbb9cace34da", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -3799,13 +3799,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree gnu_field_list = NULL_TREE;\n \t/* Non-null for subprograms containing parameters passed by copy-in\n \t   copy-out (Ada In Out or Out parameters not passed by reference),\n-\t   in which case it is the list of nodes used to specify the values of\n-\t   the in out/out parameters that are returned as a record upon\n+\t   in which case it is the list of nodes used to specify the values\n+\t   of the In Out/Out parameters that are returned as a record upon\n \t   procedure return.  The TREE_PURPOSE of an element of this list is\n \t   a field of the record and the TREE_VALUE is the PARM_DECL\n \t   corresponding to that field.  This list will be saved in the\n \t   TYPE_CI_CO_LIST field of the FUNCTION_TYPE node we create.  */\n-\ttree gnu_return_list = NULL_TREE;\n+\ttree gnu_cico_list = NULL_TREE;\n \t/* If an import pragma asks to map this subprogram to a GCC builtin,\n \t   this is the builtin DECL node.  */\n \ttree gnu_builtin_decl = NULL_TREE;\n@@ -3831,9 +3831,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     && Is_Pure (gnat_entity));\n \n \tbool volatile_flag = No_Return (gnat_entity);\n-\tbool returns_by_ref = false;\n-\tbool returns_unconstrained = false;\n-\tbool returns_by_target_ptr = false;\n+\tbool return_by_direct_ref_p = false;\n+\tbool return_by_invisi_ref_p = false;\n+\tbool return_unconstrained_p = false;\n \tbool has_copy_in_out = false;\n \tbool has_stub = false;\n \tint parmnum;\n@@ -3885,37 +3885,39 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (kind == E_Function || kind == E_Subprogram_Type)\n \t  gnu_return_type = gnat_to_gnu_type (Etype (gnat_entity));\n \n-\t/* If this function returns by reference, make the actual\n-\t   return type of this function the pointer and mark the decl.  */\n+\t/* If this function returns by reference, make the actual return\n+\t   type of this function the pointer and mark the decl.  */\n \tif (Returns_By_Ref (gnat_entity))\n \t  {\n-\t    returns_by_ref = true;\n \t    gnu_return_type = build_pointer_type (gnu_return_type);\n+\t    return_by_direct_ref_p = true;\n \t  }\n \n-\t/* If the Mechanism is By_Reference, ensure the return type uses\n-\t   the machine's by-reference mechanism, which may not the same\n-\t   as above (e.g., it might be by passing a fake parameter).  */\n-\telse if (kind == E_Function\n-\t\t && Mechanism (gnat_entity) == By_Reference)\n-\t  {\n-\t    TREE_ADDRESSABLE (gnu_return_type) = 1;\n-\n-\t    /* We expect this bit to be reset by gigi shortly, so can avoid a\n-\t       type node copy here.  This actually also prevents troubles with\n-\t       the generation of debug information for the function, because\n-\t       we might have issued such info for this type already, and would\n-\t       be attaching a distinct type node to the function if we made a\n-\t       copy here.  */\n-\t  }\n-\n-\t/* If we are supposed to return an unconstrained array,\n-\t   actually return a fat pointer and make a note of that.  Return\n-\t   a pointer to an unconstrained record of variable size.  */\n+\t/* If the Mechanism is By_Reference, ensure this function uses the\n+\t   target's by-invisible-reference mechanism, which may not be the\n+\t   same as above (e.g. it might be passing an extra parameter).\n+\n+\t   Prior to GCC 4, this was handled by just setting TREE_ADDRESSABLE\n+\t   on the result type.  Everything required to pass by invisible\n+\t   reference using the target's mechanism (e.g. an extra parameter)\n+\t   was handled at RTL expansion time.\n+\n+\t   This doesn't work with GCC 4 any more for several reasons.  First,\n+\t   the gimplification process might need to create temporaries of this\n+\t   type and the gimplifier ICEs on such attempts; that's why the flag\n+\t   is now set on the function type instead.  Second, the middle-end\n+\t   now also relies on a different attribute, DECL_BY_REFERENCE on the\n+\t   RESULT_DECL, and expects the by-invisible-reference-ness to be made\n+\t   explicit in the function body.  */\n+\telse if (kind == E_Function && Mechanism (gnat_entity) == By_Reference)\n+\t  return_by_invisi_ref_p = true;\n+\n+\t/* If we are supposed to return an unconstrained array, actually return\n+\t   a fat pointer and make a note of that.  */\n \telse if (TREE_CODE (gnu_return_type) == UNCONSTRAINED_ARRAY_TYPE)\n \t  {\n \t    gnu_return_type = TREE_TYPE (gnu_return_type);\n-\t    returns_unconstrained = true;\n+\t    return_unconstrained_p = true;\n \t  }\n \n \t/* If the type requires a transient scope, the result is allocated\n@@ -3924,7 +3926,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse if (Requires_Transient_Scope (Etype (gnat_entity)))\n \t  {\n \t    gnu_return_type = build_pointer_type (gnu_return_type);\n-\t    returns_unconstrained = true;\n+\t    return_unconstrained_p = true;\n \t  }\n \n \t/* If the type is a padded type and the underlying type would not\n@@ -3936,20 +3938,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     || Has_Foreign_Convention (gnat_entity)))\n \t  gnu_return_type = TREE_TYPE (TYPE_FIELDS (gnu_return_type));\n \n-\t/* If the return type has a non-constant size, we convert the function\n-\t   into a procedure and its caller will pass a pointer to an object as\n-\t   the first parameter when we call the function.  This can happen for\n-\t   an unconstrained type with a maximum size or a constrained type with\n-\t   a size not known at compile time.  */\n-\tif (TYPE_SIZE_UNIT (gnu_return_type)\n-\t    && !TREE_CONSTANT (TYPE_SIZE_UNIT (gnu_return_type)))\n+\t/* If the return type is unconstrained, that means it must have a\n+\t   maximum size.  Use the padded type as the effective return type.\n+\t   And ensure the function uses the target's by-invisible-reference\n+\t   mechanism to avoid copying too much data when it returns.  */\n+\tif (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_return_type)))\n \t  {\n-\t    returns_by_target_ptr = true;\n-\t    gnu_param_list\n-\t      = create_param_decl (get_identifier (\"TARGET\"),\n-\t\t\t\t   build_reference_type (gnu_return_type),\n-\t\t\t\t   true);\n-\t    gnu_return_type = void_type_node;\n+\t    gnu_return_type\n+\t      = maybe_pad_type (gnu_return_type,\n+\t\t\t\tmax_size (TYPE_SIZE (gnu_return_type), true),\n+\t\t\t\t0, gnat_entity, false, false, false, true);\n+\t    return_by_invisi_ref_p = true;\n \t  }\n \n \t/* If the return type has a size that overflows, we cannot have\n@@ -4091,8 +4090,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t       &DECL_SOURCE_LOCATION (gnu_field));\n \t\tTREE_CHAIN (gnu_field) = gnu_field_list;\n \t\tgnu_field_list = gnu_field;\n-\t\tgnu_return_list = tree_cons (gnu_field, gnu_param,\n-\t\t\t\t\t     gnu_return_list);\n+\t\tgnu_cico_list\n+\t\t  = tree_cons (gnu_field, gnu_param, gnu_cico_list);\n \t      }\n \t  }\n \n@@ -4105,8 +4104,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* If we have a CICO list but it has only one entry, we convert\n \t   this function into a function that simply returns that one\n \t   object.  */\n-\tif (list_length (gnu_return_list) == 1)\n-\t  gnu_return_type = TREE_TYPE (TREE_PURPOSE (gnu_return_list));\n+\tif (list_length (gnu_cico_list) == 1)\n+\t  gnu_return_type = TREE_TYPE (TREE_PURPOSE (gnu_cico_list));\n \n \tif (Has_Stdcall_Convention (gnat_entity))\n \t  prepend_one_attribute_to\n@@ -4131,22 +4130,25 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_param_list = nreverse (gnu_param_list);\n \tif (has_stub)\n \t  gnu_stub_param_list = nreverse (gnu_stub_param_list);\n-\tgnu_return_list = nreverse (gnu_return_list);\n+\tgnu_cico_list = nreverse (gnu_cico_list);\n \n \tif (Ekind (gnat_entity) == E_Function)\n-\t  Set_Mechanism (gnat_entity,\n-\t\t\t (returns_by_ref || returns_unconstrained\n-\t\t\t  ? By_Reference : By_Copy));\n+\t  Set_Mechanism (gnat_entity, return_unconstrained_p\n+\t\t\t\t      || return_by_direct_ref_p\n+\t\t\t\t      || return_by_invisi_ref_p\n+\t\t\t\t      ? By_Reference : By_Copy);\n \tgnu_type\n \t  = create_subprog_type (gnu_return_type, gnu_param_list,\n-\t\t\t\t gnu_return_list, returns_unconstrained,\n-\t\t\t\t returns_by_ref, returns_by_target_ptr);\n+\t\t\t\t gnu_cico_list, return_unconstrained_p,\n+\t\t\t\t return_by_direct_ref_p,\n+\t\t\t\t return_by_invisi_ref_p);\n \n \tif (has_stub)\n \t  gnu_stub_type\n \t    = create_subprog_type (gnu_return_type, gnu_stub_param_list,\n-\t\t\t\t   gnu_return_list, returns_unconstrained,\n-\t\t\t\t   returns_by_ref, returns_by_target_ptr);\n+\t\t\t\t   gnu_cico_list, return_unconstrained_p,\n+\t\t\t\t   return_by_direct_ref_p,\n+\t\t\t\t   return_by_invisi_ref_p);\n \n \t/* A subprogram (something that doesn't return anything) shouldn't\n \t   be considered const since there would be no reason for such a"}, {"sha": "e9956b00634fb93021807ef6366057f3acea545f", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -545,19 +545,19 @@ extern void add_parallel_type (tree decl, tree parallel_type);\n /* Return the parallel type associated to a type, if any.  */\n extern tree get_parallel_type (tree type);\n \n-/* Returns a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n-   subprogram. If it is void_type_node, then we are dealing with a procedure,\n-   otherwise we are dealing with a function. PARAM_DECL_LIST is a list of\n-   PARM_DECL nodes that are the subprogram arguments.  CICO_LIST is the\n-   copy-in/copy-out list to be stored into TYPE_CI_CO_LIST.\n-   RETURNS_UNCONSTRAINED is true if the function returns an unconstrained\n-   object.  RETURNS_BY_REF is true if the function returns by reference.\n-   RETURNS_BY_TARGET_PTR is true if the function is to be passed (as its\n-   first parameter) the address of the place to copy its result.  */\n+/* Return a FUNCTION_TYPE node.  RETURN_TYPE is the type returned by the\n+   subprogram.  If it is VOID_TYPE, then we are dealing with a procedure,\n+   otherwise we are dealing with a function.  PARAM_DECL_LIST is a list of\n+   PARM_DECL nodes that are the subprogram parameters.  CICO_LIST is the\n+   copy-in/copy-out list to be stored into the TYPE_CICO_LIST field.\n+   RETURN_UNCONSTRAINED_P is true if the function returns an unconstrained\n+   object.  RETURN_BY_DIRECT_REF_P is true if the function returns by direct\n+   reference.  RETURN_BY_INVISI_REF_P is true if the function returns by\n+   invisible reference.  */\n extern tree create_subprog_type (tree return_type, tree param_decl_list,\n-                                 tree cico_list, bool returns_unconstrained,\n-                                 bool returns_by_ref,\n-                                 bool returns_by_target_ptr);\n+\t\t\t\t tree cico_list, bool return_unconstrained_p,\n+\t\t\t\t bool return_by_direct_ref_p,\n+\t\t\t\t bool return_by_invisi_ref_p);\n \n /* Return a copy of TYPE, but safe to modify in any way.  */\n extern tree copy_type (tree type);\n@@ -804,7 +804,7 @@ extern tree build_cond_expr (tree result_type, tree condition_operand,\n                              tree true_operand, tree false_operand);\n \n /* Similar, but for RETURN_EXPR.  */\n-extern tree build_return_expr (tree result_decl, tree ret_val);\n+extern tree build_return_expr (tree ret_obj, tree ret_val);\n \n /* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n    the CALL_EXPR.  */"}, {"sha": "049c20155265986176bb487efc60d44ef57c0d27", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 111, "deletions": 186, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -2196,6 +2196,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n        ? Corresponding_Spec (gnat_node) : Defining_Entity (gnat_node));\n   /* The FUNCTION_DECL node corresponding to the subprogram spec.   */\n   tree gnu_subprog_decl;\n+  /* Its RESULT_DECL node.  */\n+  tree gnu_result_decl;\n   /* The FUNCTION_TYPE node corresponding to the subprogram spec.  */\n   tree gnu_subprog_type;\n   tree gnu_cico_list;\n@@ -2219,9 +2221,18 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n     = gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE,\n \t\t\t  Acts_As_Spec (gnat_node)\n \t\t\t  && !present_gnu_tree (gnat_subprog_id));\n-\n+  gnu_result_decl = DECL_RESULT (gnu_subprog_decl);\n   gnu_subprog_type = TREE_TYPE (gnu_subprog_decl);\n \n+  /* If the function returns by invisible reference, make it explicit in the\n+     function body.  See gnat_to_gnu_entity, E_Subprogram_Type case.  */\n+  if (TREE_ADDRESSABLE (gnu_subprog_type))\n+    {\n+      TREE_TYPE (gnu_result_decl)\n+\t= build_reference_type (TREE_TYPE (gnu_result_decl));\n+      relayout_decl (gnu_result_decl);\n+    }\n+\n   /* Propagate the debug mode.  */\n   if (!Needs_Debug_Info (gnat_subprog_id))\n     DECL_IGNORED_P (gnu_subprog_decl) = 1;\n@@ -2319,9 +2330,18 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       gnu_result = end_stmt_group ();\n     }\n \n-  /* If we made a special return label, we need to make a block that contains\n-     the definition of that label and the copying to the return value.  That\n-     block first contains the function, then the label and copy statement.  */\n+    /* If we are dealing with a return from an Ada procedure with parameters\n+       passed by copy-in/copy-out, we need to return a record containing the\n+       final values of these parameters.  If the list contains only one entry,\n+       return just that entry though.\n+\n+       For a full description of the copy-in/copy-out parameter mechanism, see\n+       the part of the gnat_to_gnu_entity routine dealing with the translation\n+       of subprograms.\n+\n+       We need to make a block that contains the definition of that label and\n+       the copying of the return value.  It first contains the function, then\n+       the label and copy statement.  */\n   if (TREE_VALUE (gnu_return_label_stack))\n     {\n       tree gnu_retval;\n@@ -2339,12 +2359,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \tgnu_retval = gnat_build_constructor (TREE_TYPE (gnu_subprog_type),\n \t\t\t\t\t     gnu_cico_list);\n \n-      if (DECL_P (gnu_retval) && DECL_BY_REF_P (gnu_retval))\n-\tgnu_retval = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_retval);\n-\n-      add_stmt_with_node\n-\t(build_return_expr (DECL_RESULT (gnu_subprog_decl), gnu_retval),\n-\t End_Label (Handled_Statement_Sequence (gnat_node)));\n+      add_stmt_with_node (build_return_expr (gnu_result_decl, gnu_retval),\n+\t\t\t  End_Label (Handled_Statement_Sequence (gnat_node)));\n       gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n     }\n@@ -2396,8 +2412,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   tree gnu_subprog_node = gnat_to_gnu (Name (gnat_node));\n   /* The FUNCTION_TYPE node giving the GCC type of the subprogram.  */\n   tree gnu_subprog_type = TREE_TYPE (gnu_subprog_node);\n-  tree gnu_subprog_addr = build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t  gnu_subprog_node);\n+  tree gnu_subprog_addr\n+    = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_subprog_node);\n   Entity_Id gnat_formal;\n   Node_Id gnat_actual;\n   tree gnu_actual_list = NULL_TREE;\n@@ -2433,51 +2449,6 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       }\n     }\n \n-  /* If we are calling by supplying a pointer to a target, set up that pointer\n-     as the first argument.  Use GNU_TARGET if one was passed; otherwise, make\n-     a target by building a variable and use the maximum size of the type if\n-     it has self-referential size.  */\n-  if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n-    {\n-      tree gnu_ret_type\n-\t= TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (gnu_subprog_type)));\n-\n-      if (!gnu_target)\n-\t{\n-\t  tree gnu_obj_type;\n-\n-\t  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_ret_type)))\n-\t    gnu_obj_type\n-\t      = maybe_pad_type (gnu_ret_type,\n-\t\t\t\tmax_size (TYPE_SIZE (gnu_ret_type), true),\n-\t\t\t\t0, Etype (Name (gnat_node)), false, false,\n-\t\t\t\tfalse, true);\n-\t  else\n-\t    gnu_obj_type = gnu_ret_type;\n-\n-\t  /* ??? We may be about to create a static temporary if we happen to\n-\t     be at the global binding level.  That's a regression from what\n-\t     the 3.x back-end would generate in the same situation, but we\n-\t     don't have a mechanism in Gigi for creating automatic variables\n-\t     in the elaboration routines.  */\n-\t  gnu_target\n-\t    = create_var_decl (create_tmp_var_name (\"LR\"), NULL, gnu_obj_type,\n-\t\t\t       NULL, false, false, false, false, NULL,\n-\t\t\t       gnat_node);\n-\n-\t  *gnu_result_type_p = gnu_ret_type;\n-\t}\n-\n-      gnu_actual_list\n-\t= tree_cons (NULL_TREE,\n-\t\t     build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t     unchecked_convert (gnu_ret_type,\n-\t\t\t\t\t\t\tgnu_target,\n-\t\t\t\t\t\t\tfalse)),\n-\t\t     NULL_TREE);\n-\n-    }\n-\n   /* The only way we can be making a call via an access type is if Name is an\n      explicit dereference.  In that case, get the list of formal args from the\n      type the access type is pointing to.  Otherwise, get the formals from\n@@ -2784,53 +2755,43 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t      nreverse (gnu_actual_list));\n   set_expr_location_from_node (gnu_subprog_call, gnat_node);\n \n-  /* If we return by passing a target, the result is the target after the\n-     call.  We must not emit the call directly here because this might be\n-     evaluated as part of an expression with conditions to control whether\n-     the call should be emitted or not.  */\n-  if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n-    {\n-      /* Conceptually, what we need is a COMPOUND_EXPR of the call followed by\n-\t the target object.  Doing so would potentially be inefficient though,\n-\t as this expression might be wrapped up into a SAVE_EXPR later, which\n-\t would incur a pointless temporary copy of the whole object.\n-\n-\t What we do instead is build a COMPOUND_EXPR returning the address of\n-\t the target, and then dereference.  Wrapping up the COMPOUND_EXPR into\n-\t a SAVE_EXPR then only incurs a mere pointer copy.  */\n-      tree gnu_target_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_target);\n-      set_expr_location_from_node (gnu_target_addr, gnat_node);\n-      gnu_result = build2 (COMPOUND_EXPR, TREE_TYPE (gnu_target_addr),\n-\t\t\t   gnu_subprog_call, gnu_target_addr);\n-      return build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n-    }\n-\n-  /* If it is a function call, the result is the call expression unless\n-     a target is specified, in which case we copy the result into the target\n-     and return the assignment statement.  */\n-  else if (Nkind (gnat_node) == N_Function_Call)\n+  /* If it's a function call, the result is the call expression unless a target\n+     is specified, in which case we copy the result into the target and return\n+     the assignment statement.  */\n+  if (Nkind (gnat_node) == N_Function_Call)\n     {\n       gnu_result = gnu_subprog_call;\n+      enum tree_code op_code;\n \n-      /* If the function returns an unconstrained array or by reference,\n-\t we have to de-dereference the pointer.  */\n-      if (TYPE_RETURNS_UNCONSTRAINED_P (gnu_subprog_type)\n-\t  || TYPE_RETURNS_BY_REF_P (gnu_subprog_type))\n+      /* If the function returns an unconstrained array or by direct reference,\n+\t we have to dereference the pointer.  */\n+      if (TYPE_RETURN_UNCONSTRAINED_P (gnu_subprog_type)\n+\t  || TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type))\n \tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n \n       if (gnu_target)\n-\tgnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t      gnu_target, gnu_result);\n+\t{\n+\t  /* ??? If the return type has non-constant size, then force the\n+\t     return slot optimization as we would not be able to generate\n+\t     a temporary.  That's what has been done historically.  */\n+\t  if (TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_subprog_type))))\n+\t    op_code = MODIFY_EXPR;\n+\t  else\n+\t    op_code = INIT_EXPR;\n+\n+\t  gnu_result\n+\t    = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_result);\n+\t}\n       else\n \t*gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n \n       return gnu_result;\n     }\n \n-  /* If this is the case where the GNAT tree contains a procedure call\n-     but the Ada procedure has copy in copy out parameters, the special\n-     parameter passing mechanism must be used.  */\n-  else if (TYPE_CI_CO_LIST (gnu_subprog_type) != NULL_TREE)\n+  /* If this is the case where the GNAT tree contains a procedure call but the\n+     Ada procedure has copy-in/copy-out parameters, then the special parameter\n+     passing mechanism must be used.  */\n+  if (TYPE_CI_CO_LIST (gnu_subprog_type))\n     {\n       /* List of FIELD_DECLs associated with the PARM_DECLs of the copy\n \t in copy out parameters.  */\n@@ -4636,116 +4597,80 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Return_Statement:\n       {\n-\t/* The gnu function type of the subprogram currently processed.  */\n-\ttree gnu_subprog_type = TREE_TYPE (current_function_decl);\n-\t/* The return value from the subprogram.  */\n-\ttree gnu_ret_val = NULL_TREE;\n-\t/* The place to put the return value.  */\n-\ttree gnu_lhs;\n-\n-\t/* If we are dealing with a \"return;\" from an Ada procedure with\n-\t   parameters passed by copy in copy out, we need to return a record\n-\t   containing the final values of these parameters.  If the list\n-\t   contains only one entry, return just that entry.\n-\n-\t   For a full description of the copy in copy out parameter mechanism,\n-\t   see the part of the gnat_to_gnu_entity routine dealing with the\n-\t   translation of subprograms.\n-\n-\t   But if we have a return label defined, convert this into\n-\t   a branch to that label.  */\n+\ttree gnu_ret_val, gnu_ret_obj;\n \n+\t/* If we have a return label defined, convert this into a branch to\n+\t   that label.  The return proper will be handled elsewhere.  */\n \tif (TREE_VALUE (gnu_return_label_stack))\n \t  {\n \t    gnu_result = build1 (GOTO_EXPR, void_type_node,\n \t\t\t\t TREE_VALUE (gnu_return_label_stack));\n \t    break;\n \t  }\n \n-\telse if (TYPE_CI_CO_LIST (gnu_subprog_type))\n-\t  {\n-\t    gnu_lhs = DECL_RESULT (current_function_decl);\n-\t    if (list_length (TYPE_CI_CO_LIST (gnu_subprog_type)) == 1)\n-\t      gnu_ret_val = TREE_VALUE (TYPE_CI_CO_LIST (gnu_subprog_type));\n-\t    else\n-\t      gnu_ret_val\n-\t\t= gnat_build_constructor (TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t\t  TYPE_CI_CO_LIST (gnu_subprog_type));\n-\t  }\n-\n-\t/* If the Ada subprogram is a function, we just need to return the\n-\t   expression.   If the subprogram returns an unconstrained\n-\t   array, we have to allocate a new version of the result and\n-\t   return it.  If we return by reference, return a pointer.  */\n-\n-\telse if (Present (Expression (gnat_node)))\n+\t/* If the subprogram is a function, we must return the expression.  */\n+\tif (Present (Expression (gnat_node)))\n \t  {\n-\t    /* If the current function returns by target pointer and we\n-\t       are doing a call, pass that target to the call.  */\n-\t    if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type)\n-\t\t&& Nkind (Expression (gnat_node)) == N_Function_Call)\n+\t    tree gnu_subprog_type = TREE_TYPE (current_function_decl);\n+\t    tree gnu_result_decl = DECL_RESULT (current_function_decl);\n+\t    gnu_ret_val = gnat_to_gnu (Expression (gnat_node));\n+\n+\t    /* Do not remove the padding from GNU_RET_VAL if the inner type is\n+\t       self-referential since we want to allocate the fixed size.  */\n+\t    if (TREE_CODE (gnu_ret_val) == COMPONENT_REF\n+\t\t&& TYPE_IS_PADDING_P\n+\t\t   (TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0)))\n+\t\t&& CONTAINS_PLACEHOLDER_P\n+\t\t   (TYPE_SIZE (TREE_TYPE (gnu_ret_val))))\n+\t      gnu_ret_val = TREE_OPERAND (gnu_ret_val, 0);\n+\n+\t    /* If the subprogram returns by direct reference, return a pointer\n+\t       to the return value.  */\n+\t    if (TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type)\n+\t\t|| By_Ref (gnat_node))\n+\t      gnu_ret_val = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_ret_val);\n+\n+\t    /* Otherwise, if it returns an unconstrained array, we have to\n+\t       allocate a new version of the result and return it.  */\n+\t    else if (TYPE_RETURN_UNCONSTRAINED_P (gnu_subprog_type))\n \t      {\n-\t\tgnu_lhs\n-\t\t  = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t    DECL_ARGUMENTS (current_function_decl));\n-\t\tgnu_result = call_to_gnu (Expression (gnat_node),\n-\t\t\t\t\t  &gnu_result_type, gnu_lhs);\n+\t\tgnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n+\t\tgnu_ret_val = build_allocator (TREE_TYPE (gnu_ret_val),\n+\t\t\t\t\t       gnu_ret_val,\n+\t\t\t\t\t       TREE_TYPE (gnu_subprog_type),\n+\t\t\t\t\t       Procedure_To_Call (gnat_node),\n+\t\t\t\t\t       Storage_Pool (gnat_node),\n+\t\t\t\t\t       gnat_node, false);\n \t      }\n-\t    else\n+\n+\t    /* If the subprogram returns by invisible reference, dereference\n+\t       the pointer it is passed using the type of the return value\n+\t       and build the copy operation manually.  This ensures that we\n+\t       don't copy too much data, for example if the return type is\n+\t       unconstrained with a maximum size.  */\n+\t    if (TREE_ADDRESSABLE (gnu_subprog_type))\n \t      {\n-\t\tgnu_ret_val = gnat_to_gnu (Expression (gnat_node));\n-\n-\t\tif (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n-\t\t  /* The original return type was unconstrained so dereference\n-\t\t     the TARGET pointer in the actual return value's type.  */\n-\t\t  gnu_lhs\n-\t\t    = build_unary_op (INDIRECT_REF, TREE_TYPE (gnu_ret_val),\n-\t\t\t\t      DECL_ARGUMENTS (current_function_decl));\n-\t\telse\n-\t\t  gnu_lhs = DECL_RESULT (current_function_decl);\n-\n-\t\t/* Do not remove the padding from GNU_RET_VAL if the inner\n-\t\t   type is self-referential since we want to allocate the fixed\n-\t\t   size in that case.  */\n-\t\tif (TREE_CODE (gnu_ret_val) == COMPONENT_REF\n-\t\t    && TYPE_IS_PADDING_P\n-\t\t       (TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0)))\n-\t\t    && CONTAINS_PLACEHOLDER_P\n-\t\t       (TYPE_SIZE (TREE_TYPE (gnu_ret_val))))\n-\t\t  gnu_ret_val = TREE_OPERAND (gnu_ret_val, 0);\n-\n-\t\tif (TYPE_RETURNS_BY_REF_P (gnu_subprog_type)\n-\t\t    || By_Ref (gnat_node))\n-\t\t  gnu_ret_val\n-\t\t    = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_ret_val);\n-\n-\t\telse if (TYPE_RETURNS_UNCONSTRAINED_P (gnu_subprog_type))\n-\t\t  {\n-\t\t    gnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n-\t\t    gnu_ret_val\n-\t\t      = build_allocator (TREE_TYPE (gnu_ret_val),\n-\t\t\t\t\t gnu_ret_val,\n-\t\t\t\t\t TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t\t Procedure_To_Call (gnat_node),\n-\t\t\t\t\t Storage_Pool (gnat_node),\n-\t\t\t\t\t gnat_node, false);\n-\t\t  }\n+\t\tgnu_ret_obj\n+\t\t  = build_unary_op (INDIRECT_REF, TREE_TYPE (gnu_ret_val),\n+\t\t\t\t    gnu_result_decl);\n+\t\tgnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t\t      gnu_ret_obj, gnu_ret_val);\n+\t\tadd_stmt_with_node (gnu_result, gnat_node);\n+\t\tgnu_ret_val = NULL_TREE;\n+\t\tgnu_ret_obj = gnu_result_decl;\n \t      }\n+\n+\t    /* Otherwise, build a regular return.  */\n+\t    else\n+\t      gnu_ret_obj = gnu_result_decl;\n \t  }\n \telse\n-\t  /* If the Ada subprogram is a regular procedure, just return.  */\n-\t  gnu_lhs = NULL_TREE;\n-\n-\tif (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n \t  {\n-\t    if (gnu_ret_val)\n-\t      gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t    gnu_lhs, gnu_ret_val);\n-\t    add_stmt_with_node (gnu_result, gnat_node);\n-\t    gnu_lhs = NULL_TREE;\n+\t    gnu_ret_val = NULL_TREE;\n+\t    gnu_ret_obj = NULL_TREE;\n \t  }\n \n-\tgnu_result = build_return_expr (gnu_lhs, gnu_ret_val);\n+\tgnu_result = build_return_expr (gnu_ret_obj, gnu_ret_val);\n       }\n       break;\n \n@@ -5605,7 +5530,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n       else\n \tt = gnu_decl;\n \n-      gnu_stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, t, gnu_init);\n+      gnu_stmt = build_binary_op (INIT_EXPR, NULL_TREE, t, gnu_init);\n \n       DECL_INITIAL (gnu_decl) = NULL_TREE;\n       if (TREE_READONLY (gnu_decl))"}, {"sha": "412aa3a6f0ac8f0f795cb93c1ded7c26bdb8999f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 40, "deletions": 215, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -1095,58 +1095,54 @@ split_plus (tree in, tree *pvar)\n     return bitsize_zero_node;\n }\n \f\n-/* Return a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n-   subprogram. If it is void_type_node, then we are dealing with a procedure,\n-   otherwise we are dealing with a function. PARAM_DECL_LIST is a list of\n-   PARM_DECL nodes that are the subprogram arguments.  CICO_LIST is the\n-   copy-in/copy-out list to be stored into TYPE_CICO_LIST.\n-   RETURNS_UNCONSTRAINED is true if the function returns an unconstrained\n-   object.  RETURNS_BY_REF is true if the function returns by reference.\n-   RETURNS_BY_TARGET_PTR is true if the function is to be passed (as its\n-   first parameter) the address of the place to copy its result.  */\n+/* Return a FUNCTION_TYPE node.  RETURN_TYPE is the type returned by the\n+   subprogram.  If it is VOID_TYPE, then we are dealing with a procedure,\n+   otherwise we are dealing with a function.  PARAM_DECL_LIST is a list of\n+   PARM_DECL nodes that are the subprogram parameters.  CICO_LIST is the\n+   copy-in/copy-out list to be stored into the TYPE_CICO_LIST field.\n+   RETURN_UNCONSTRAINED_P is true if the function returns an unconstrained\n+   object.  RETURN_BY_DIRECT_REF_P is true if the function returns by direct\n+   reference.  RETURN_BY_INVISI_REF_P is true if the function returns by\n+   invisible reference.  */\n \n tree\n create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n-                     bool returns_unconstrained, bool returns_by_ref,\n-                     bool returns_by_target_ptr)\n+\t\t     bool return_unconstrained_p, bool return_by_direct_ref_p,\n+\t\t     bool return_by_invisi_ref_p)\n {\n   /* A chain of TREE_LIST nodes whose TREE_VALUEs are the data type nodes of\n-     the subprogram formal parameters. This list is generated by traversing the\n-     input list of PARM_DECL nodes.  */\n-  tree param_type_list = NULL;\n-  tree param_decl;\n-  tree type;\n+     the subprogram formal parameters.  This list is generated by traversing\n+     the input list of PARM_DECL nodes.  */\n+  tree param_type_list = NULL_TREE;\n+  tree t, type;\n \n-  for (param_decl = param_decl_list; param_decl;\n-       param_decl = TREE_CHAIN (param_decl))\n-    param_type_list = tree_cons (NULL_TREE, TREE_TYPE (param_decl),\n-\t\t\t\t param_type_list);\n+  for (t = param_decl_list; t; t = TREE_CHAIN (t))\n+    param_type_list = tree_cons (NULL_TREE, TREE_TYPE (t), param_type_list);\n \n   /* The list of the function parameter types has to be terminated by the void\n      type to signal to the back-end that we are not dealing with a variable\n-     parameter subprogram, but that the subprogram has a fixed number of\n-     parameters.  */\n+     parameter subprogram, but that it has a fixed number of parameters.  */\n   param_type_list = tree_cons (NULL_TREE, void_type_node, param_type_list);\n \n-  /* The list of argument types has been created in reverse\n-     so nreverse it.   */\n+  /* The list of argument types has been created in reverse so reverse it.  */\n   param_type_list = nreverse (param_type_list);\n \n   type = build_function_type (return_type, param_type_list);\n \n-  /* TYPE may have been shared since GCC hashes types.  If it has a CICO_LIST\n-     or the new type should, make a copy of TYPE.  Likewise for\n-     RETURNS_UNCONSTRAINED and RETURNS_BY_REF.  */\n-  if (TYPE_CI_CO_LIST (type) || cico_list\n-      || TYPE_RETURNS_UNCONSTRAINED_P (type) != returns_unconstrained\n-      || TYPE_RETURNS_BY_REF_P (type) != returns_by_ref\n-      || TYPE_RETURNS_BY_TARGET_PTR_P (type) != returns_by_target_ptr)\n-    type = copy_type (type);\n+  /* TYPE may have been shared since GCC hashes types.  If it has a different\n+     CICO_LIST, make a copy.  Likewise for the various flags.  */\n+  if (TYPE_CI_CO_LIST (type) != cico_list\n+      || TYPE_RETURN_UNCONSTRAINED_P (type) != return_unconstrained_p\n+      || TYPE_RETURN_BY_DIRECT_REF_P (type) != return_by_direct_ref_p\n+      || TREE_ADDRESSABLE (type) != return_by_invisi_ref_p)\n+    {\n+      type = copy_type (type);\n+      TYPE_CI_CO_LIST (type) = cico_list;\n+      TYPE_RETURN_UNCONSTRAINED_P (type) = return_unconstrained_p;\n+      TYPE_RETURN_BY_DIRECT_REF_P (type) = return_by_direct_ref_p;\n+      TREE_ADDRESSABLE (type) = return_by_invisi_ref_p;\n+    }\n \n-  TYPE_CI_CO_LIST (type) = cico_list;\n-  TYPE_RETURNS_UNCONSTRAINED_P (type) = returns_unconstrained;\n-  TYPE_RETURNS_BY_REF_P (type) = returns_by_ref;\n-  TYPE_RETURNS_BY_TARGET_PTR_P (type) = returns_by_target_ptr;\n   return type;\n }\n \f\n@@ -1828,9 +1824,10 @@ create_subprog_decl (tree subprog_name, tree asm_name,\n \t\t     bool public_flag, bool extern_flag,\n                      struct attrib *attr_list, Node_Id gnat_node)\n {\n-  tree return_type  = TREE_TYPE (subprog_type);\n-  tree subprog_decl = build_decl (input_location,\n-\t\t\t\t  FUNCTION_DECL, subprog_name, subprog_type);\n+  tree subprog_decl = build_decl (input_location, FUNCTION_DECL, subprog_name,\n+\t\t\t\t  subprog_type);\n+  tree result_decl = build_decl (input_location, RESULT_DECL, NULL_TREE,\n+\t\t\t\t TREE_TYPE (subprog_type));\n \n   /* If this is a non-inline function nested inside an inlined external\n      function, we cannot honor both requests without cloning the nested\n@@ -1851,23 +1848,11 @@ create_subprog_decl (tree subprog_name, tree asm_name,\n   TREE_SIDE_EFFECTS (subprog_decl) = TYPE_VOLATILE (subprog_type);\n   DECL_DECLARED_INLINE_P (subprog_decl) = inline_flag;\n   DECL_ARGUMENTS (subprog_decl) = param_decl_list;\n-  DECL_RESULT (subprog_decl)    = build_decl (input_location,\n-\t\t\t\t\t      RESULT_DECL, 0, return_type);\n-  DECL_ARTIFICIAL (DECL_RESULT (subprog_decl)) = 1;\n-  DECL_IGNORED_P (DECL_RESULT (subprog_decl)) = 1;\n-\n-  /* TREE_ADDRESSABLE is set on the result type to request the use of the\n-     target by-reference return mechanism.  This is not supported all the\n-     way down to RTL expansion with GCC 4, which ICEs on temporary creation\n-     attempts with such a type and expects DECL_BY_REFERENCE to be set on\n-     the RESULT_DECL instead - see gnat_genericize for more details.  */\n-  if (TREE_ADDRESSABLE (TREE_TYPE (DECL_RESULT (subprog_decl))))\n-    {\n-      tree result_decl = DECL_RESULT (subprog_decl);\n \n-      TREE_ADDRESSABLE (TREE_TYPE (result_decl)) = 0;\n-      DECL_BY_REFERENCE (result_decl) = 1;\n-    }\n+  DECL_ARTIFICIAL (result_decl) = 1;\n+  DECL_IGNORED_P (result_decl) = 1;\n+  DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (subprog_type);\n+  DECL_RESULT (subprog_decl) = result_decl;\n \n   if (asm_name)\n     {\n@@ -1921,163 +1906,6 @@ begin_subprog_body (tree subprog_decl)\n   get_pending_sizes ();\n }\n \n-\n-/* Helper for the genericization callback.  Return a dereference of VAL\n-   if it is of a reference type.  */\n-\n-static tree\n-convert_from_reference (tree val)\n-{\n-  tree value_type, ref;\n-\n-  if (TREE_CODE (TREE_TYPE (val)) != REFERENCE_TYPE)\n-    return val;\n-\n-  value_type =  TREE_TYPE (TREE_TYPE (val));\n-  ref = build1 (INDIRECT_REF, value_type, val);\n-\n-  /* See if what we reference is CONST or VOLATILE, which requires\n-     looking into array types to get to the component type.  */\n-\n-  while (TREE_CODE (value_type) == ARRAY_TYPE)\n-    value_type = TREE_TYPE (value_type);\n-\n-  TREE_READONLY (ref)\n-    = (TYPE_QUALS (value_type) & TYPE_QUAL_CONST);\n-  TREE_THIS_VOLATILE (ref)\n-    = (TYPE_QUALS (value_type) & TYPE_QUAL_VOLATILE);\n-\n-  TREE_SIDE_EFFECTS (ref)\n-    = (TREE_THIS_VOLATILE (ref) || TREE_SIDE_EFFECTS (val));\n-\n-  return ref;\n-}\n-\n-/* Helper for the genericization callback.  Returns true if T denotes\n-   a RESULT_DECL with DECL_BY_REFERENCE set.  */\n-\n-static inline bool\n-is_byref_result (tree t)\n-{\n-  return (TREE_CODE (t) == RESULT_DECL && DECL_BY_REFERENCE (t));\n-}\n-\n-\n-/* Tree walking callback for gnat_genericize. Currently ...\n-\n-   o Adjust references to the function's DECL_RESULT if it is marked\n-     DECL_BY_REFERENCE and so has had its type turned into a reference\n-     type at the end of the function compilation.  */\n-\n-static tree\n-gnat_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n-{\n-  /* This implementation is modeled after what the C++ front-end is\n-     doing, basis of the downstream passes behavior.  */\n-\n-  tree stmt = *stmt_p;\n-  struct pointer_set_t *p_set = (struct pointer_set_t*) data;\n-\n-  /* If we have a direct mention of the result decl, dereference.  */\n-  if (is_byref_result (stmt))\n-    {\n-      *stmt_p = convert_from_reference (stmt);\n-      *walk_subtrees = 0;\n-      return NULL;\n-    }\n-\n-  /* Otherwise, no need to walk the same tree twice.  */\n-  if (pointer_set_contains (p_set, stmt))\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-\n-  /* If we are taking the address of what now is a reference, just get the\n-     reference value.  */\n-  if (TREE_CODE (stmt) == ADDR_EXPR\n-      && is_byref_result (TREE_OPERAND (stmt, 0)))\n-    {\n-      *stmt_p = convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n-      *walk_subtrees = 0;\n-    }\n-\n-  /* Don't dereference an by-reference RESULT_DECL inside a RETURN_EXPR.  */\n-  else if (TREE_CODE (stmt) == RETURN_EXPR\n-           && TREE_OPERAND (stmt, 0)\n-\t   && is_byref_result (TREE_OPERAND (stmt, 0)))\n-    *walk_subtrees = 0;\n-\n-  /* Don't look inside trees that cannot embed references of interest.  */\n-  else if (IS_TYPE_OR_DECL_P (stmt))\n-    *walk_subtrees = 0;\n-\n-  pointer_set_insert (p_set, *stmt_p);\n-\n-  return NULL;\n-}\n-\n-/* Perform lowering of Ada trees to GENERIC. In particular:\n-\n-   o Turn a DECL_BY_REFERENCE RESULT_DECL into a real by-reference decl\n-     and adjust all the references to this decl accordingly.  */\n-\n-static void\n-gnat_genericize (tree fndecl)\n-{\n-  /* Prior to GCC 4, an explicit By_Reference result mechanism for a function\n-     was handled by simply setting TREE_ADDRESSABLE on the result type.\n-     Everything required to actually pass by invisible ref using the target\n-     mechanism (e.g. extra parameter) was handled at RTL expansion time.\n-\n-     This doesn't work with GCC 4 any more for several reasons.  First, the\n-     gimplification process might need the creation of temporaries of this\n-     type, and the gimplifier ICEs on such attempts.  Second, the middle-end\n-     now relies on a different attribute for such cases (DECL_BY_REFERENCE on\n-     RESULT/PARM_DECLs), and expects the user invisible by-reference-ness to\n-     be explicitly accounted for by the front-end in the function body.\n-\n-     We achieve the complete transformation in two steps:\n-\n-     1/ create_subprog_decl performs early attribute tweaks: it clears\n-        TREE_ADDRESSABLE from the result type and sets DECL_BY_REFERENCE on\n-        the result decl.  The former ensures that the bit isn't set in the GCC\n-        tree saved for the function, so prevents ICEs on temporary creation.\n-        The latter we use here to trigger the rest of the processing.\n-\n-     2/ This function performs the type transformation on the result decl\n-        and adjusts all the references to this decl from the function body\n-\taccordingly.\n-\n-     Clearing TREE_ADDRESSABLE from the type differs from the C++ front-end\n-     strategy, which escapes the gimplifier temporary creation issues by\n-     creating it's own temporaries using TARGET_EXPR nodes.  Our way relies\n-     on simple specific support code in aggregate_value_p to look at the\n-     target function result decl explicitly.  */\n-\n-  struct pointer_set_t *p_set;\n-  tree decl_result = DECL_RESULT (fndecl);\n-\n-  if (!DECL_BY_REFERENCE (decl_result))\n-    return;\n-\n-  /* Make the DECL_RESULT explicitly by-reference and adjust all the\n-     occurrences in the function body using the common tree-walking facility.\n-     We want to see every occurrence of the result decl to adjust the\n-     referencing tree, so need to use our own pointer set to control which\n-     trees should be visited again or not.  */\n-\n-  p_set = pointer_set_create ();\n-\n-  TREE_TYPE (decl_result) = build_reference_type (TREE_TYPE (decl_result));\n-  TREE_ADDRESSABLE (decl_result) = 0;\n-  relayout_decl (decl_result);\n-\n-  walk_tree (&DECL_SAVED_TREE (fndecl), gnat_genericize_r, p_set, NULL);\n-\n-  pointer_set_destroy (p_set);\n-}\n-\n /* Finish the definition of the current subprogram BODY and finalize it.  */\n \n void\n@@ -2111,9 +1939,6 @@ end_subprog_body (tree body)\n   if (type_annotate_only)\n     return;\n \n-  /* Perform the required pre-gimplification transformations on the tree.  */\n-  gnat_genericize (fndecl);\n-\n   /* Dump functions before gimplification.  */\n   dump_function (TDI_original, fndecl);\n "}, {"sha": "e3b3ec9d18b664d01fbed07ed338aee4d8d6b448", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -609,6 +609,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n   switch (op_code)\n     {\n+    case INIT_EXPR:\n     case MODIFY_EXPR:\n       /* If there were integral or pointer conversions on the LHS, remove\n \t them; we'll be putting them back below if needed.  Likewise for\n@@ -1397,45 +1398,40 @@ build_cond_expr (tree result_type, tree condition_operand,\n   return result;\n }\n \n-/* Similar, but for RETURN_EXPR.  If RESULT_DECL is non-zero, build\n-   a RETURN_EXPR around the assignment of RET_VAL to RESULT_DECL.\n-   If RESULT_DECL is zero, build a bare RETURN_EXPR.  */\n+/* Similar, but for RETURN_EXPR.  If RET_VAL is non-null, build a RETURN_EXPR\n+   around the assignment of RET_VAL to RET_OBJ.  Otherwise just build a bare\n+   RETURN_EXPR around RESULT_OBJ, which may be null in this case.  */\n \n tree\n-build_return_expr (tree result_decl, tree ret_val)\n+build_return_expr (tree ret_obj, tree ret_val)\n {\n   tree result_expr;\n \n-  if (result_decl)\n+  if (ret_val)\n     {\n       /* The gimplifier explicitly enforces the following invariant:\n \n-           RETURN_EXPR\n-               |\n-           MODIFY_EXPR\n-           /        \\\n-          /          \\\n-      RESULT_DECL    ...\n+\t      RETURN_EXPR\n+\t\t  |\n+\t      MODIFY_EXPR\n+\t      /        \\\n+\t     /          \\\n+\t RET_OBJ        ...\n \n-      As a consequence, type-homogeneity dictates that we use the type\n-      of the RESULT_DECL as the operation type.  */\n-\n-      tree operation_type = TREE_TYPE (result_decl);\n-\n-      /* Convert the right operand to the operation type.  Note that\n-         it's the same transformation as in the MODIFY_EXPR case of\n-         build_binary_op with the additional guarantee that the type\n-         cannot involve a placeholder, since otherwise the function\n-         would use the \"target pointer\" return mechanism.  */\n+\t As a consequence, type consistency dictates that we use the type\n+\t of the RET_OBJ as the operation type.  */\n+      tree operation_type = TREE_TYPE (ret_obj);\n \n+      /* Convert the right operand to the operation type.  Note that it's the\n+\t same transformation as in the MODIFY_EXPR case of build_binary_op,\n+\t with the assumption that the type cannot involve a placeholder.  */\n       if (operation_type != TREE_TYPE (ret_val))\n \tret_val = convert (operation_type, ret_val);\n \n-      result_expr\n-\t= build2 (MODIFY_EXPR, operation_type, result_decl, ret_val);\n+      result_expr = build2 (MODIFY_EXPR, operation_type, ret_obj, ret_val);\n     }\n   else\n-    result_expr = NULL_TREE;\n+    result_expr = ret_obj;\n \n   return build1 (RETURN_EXPR, void_type_node, result_expr);\n }"}, {"sha": "496ec602bc614d8524bb43d702e0d7bcfd1f3429", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -2089,7 +2089,7 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Set up a place to return a structure.  */\n \n   /* Cater to broken compilers.  */\n-  if (aggregate_value_p (exp, (!fndecl ? fntype : fndecl)))\n+  if (aggregate_value_p (exp, fntype))\n     {\n       /* This call returns a big structure.  */\n       flags &= ~(ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE);"}, {"sha": "21cbb5273913fd0d3713552a54a136d4ca4b3f2a", "filename": "gcc/function.c", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -1853,41 +1853,36 @@ struct rtl_opt_pass pass_instantiate_virtual_regs =\n int\n aggregate_value_p (const_tree exp, const_tree fntype)\n {\n+  const_tree type = (TYPE_P (exp)) ? exp : TREE_TYPE (exp);\n   int i, regno, nregs;\n   rtx reg;\n \n-  const_tree type = (TYPE_P (exp)) ? exp : TREE_TYPE (exp);\n-\n-  /* DECL node associated with FNTYPE when relevant, which we might need to\n-     check for by-invisible-reference returns, typically for CALL_EXPR input\n-     EXPressions.  */\n-  const_tree fndecl = NULL_TREE;\n-\n   if (fntype)\n     switch (TREE_CODE (fntype))\n       {\n       case CALL_EXPR:\n-\tfndecl = get_callee_fndecl (fntype);\n-\tfntype = (fndecl\n-\t\t  ? TREE_TYPE (fndecl)\n-\t\t  : TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (fntype))));\n+\t{\n+\t  tree fndecl = get_callee_fndecl (fntype);\n+\t  fntype = (fndecl\n+\t\t    ? TREE_TYPE (fndecl)\n+\t\t    : TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (fntype))));\n+\t}\n \tbreak;\n       case FUNCTION_DECL:\n-\tfndecl = fntype;\n-\tfntype = TREE_TYPE (fndecl);\n+\tfntype = TREE_TYPE (fntype);\n \tbreak;\n       case FUNCTION_TYPE:\n       case METHOD_TYPE:\n         break;\n       case IDENTIFIER_NODE:\n-\tfntype = 0;\n+\tfntype = NULL_TREE;\n \tbreak;\n       default:\n-\t/* We don't expect other rtl types here.  */\n+\t/* We don't expect other tree types here.  */\n \tgcc_unreachable ();\n       }\n \n-  if (TREE_CODE (type) == VOID_TYPE)\n+  if (VOID_TYPE_P (type))\n     return 0;\n \n   /* If a record should be passed the same as its first (and only) member\n@@ -1901,24 +1896,21 @@ aggregate_value_p (const_tree exp, const_tree fntype)\n       && DECL_BY_REFERENCE (exp))\n     return 1;\n \n-  /* If the EXPression is a CALL_EXPR, honor DECL_BY_REFERENCE set on the\n-     called function RESULT_DECL, meaning the function returns in memory by\n-     invisible reference.  This check lets front-ends not set TREE_ADDRESSABLE\n-     on the function type, which used to be the way to request such a return\n-     mechanism but might now be causing troubles at gimplification time if\n-     temporaries with the function type need to be created.  */\n-  if (TREE_CODE (exp) == CALL_EXPR && fndecl && DECL_RESULT (fndecl)\n-      && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n+  /* Function types that are TREE_ADDRESSABLE force return in memory.  */\n+  if (fntype && TREE_ADDRESSABLE (fntype))\n     return 1;\n \n-  if (targetm.calls.return_in_memory (type, fntype))\n-    return 1;\n   /* Types that are TREE_ADDRESSABLE must be constructed in memory,\n      and thus can't be returned in registers.  */\n   if (TREE_ADDRESSABLE (type))\n     return 1;\n+\n   if (flag_pcc_struct_return && AGGREGATE_TYPE_P (type))\n     return 1;\n+\n+  if (targetm.calls.return_in_memory (type, fntype))\n+    return 1;\n+\n   /* Make sure we have suitable call-clobbered regs to return\n      the value in; if not, we must return it in memory.  */\n   reg = hard_function_value (type, 0, fntype, 0);\n@@ -1933,6 +1925,7 @@ aggregate_value_p (const_tree exp, const_tree fntype)\n   for (i = 0; i < nregs; i++)\n     if (! call_used_regs[regno + i])\n       return 1;\n+\n   return 0;\n }\n \f"}, {"sha": "bfe82dd6ad24d7f81bd8cbfcf6df42f9ca59682d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -4278,6 +4278,18 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n \tret = GS_UNHANDLED;\n \tbreak;\n \n+      case WITH_SIZE_EXPR:\n+\t/* Likewise for calls that return an aggregate of non-constant size,\n+\t   since we would not be able to generate a temporary at all.  */\n+\tif (TREE_CODE (TREE_OPERAND (*from_p, 0)) == CALL_EXPR)\n+\t  {\n+\t    *from_p = TREE_OPERAND (*from_p, 0);\n+\t    ret = GS_OK;\n+\t  }\n+\telse\n+\t  ret = GS_UNHANDLED;\n+\tbreak;\n+\n \t/* If we're initializing from a container, push the initialization\n \t   inside it.  */\n       case CLEANUP_POINT_EXPR:"}, {"sha": "1c7c3b3ca417267547722d721fda59d061d1c884", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47d0a8d97e00479a3efd3913bc996f319ac8139/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d47d0a8d97e00479a3efd3913bc996f319ac8139", "patch": "@@ -1110,9 +1110,10 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    In CONSTRUCTOR nodes, it means object constructed must be in memory.\n    In LABEL_DECL nodes, it means a goto for this label has been seen\n    from a place outside all binding contours that restore stack levels.\n-   In ..._TYPE nodes, it means that objects of this type must\n-   be fully addressable.  This means that pieces of this\n-   object cannot go into register parameters, for example.\n+   In ..._TYPE nodes, it means that objects of this type must be fully\n+   addressable.  This means that pieces of this object cannot go into\n+   register parameters, for example.  If this a function type, this\n+   means that the value must be returned in memory.\n    In IDENTIFIER_NODEs, this means that some extern decl for this name\n    had its address taken.  That matters for inline functions.  */\n #define TREE_ADDRESSABLE(NODE) ((NODE)->base.addressable_flag)"}]}