{"sha": "f142e9fab708f504623b901a33dfc696c6a4d57d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE0MmU5ZmFiNzA4ZjUwNDYyM2I5MDFhMzNkZmM2OTZjNmE0ZDU3ZA==", "commit": {"author": {"name": "Cyrille Comar", "email": "comar@act-europe.fr", "date": "2004-10-27T13:56:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-27T13:56:19Z"}, "message": "gnat_ugn.texi: Generalize \"finding memory problems\" section into a \"memory management issues\"...\n\n2004-10-26  Cyrille Comar    <comar@act-europe.fr>\n\t    Vasiliy Fofanov  <fofanov@act-europe.fr>\n\t    Vincent Celier   <celier@gnat.com>\n\n\t* gnat_ugn.texi: Generalize \"finding memory problems\" section into a\n\t\"memory management issues\" section and document some of the useful\n\tmemory pools provided as part of the GNAT library.\n\tRemove \"virtual\" from declaration of A::method2 in\n\tthe simple example of Ada/C++ mixed system.\n\tLibrary Projects may be virtually extended: their virtual extensions\n\tare not Library Projects.\n\tAdded section on extending project hierarchies.\n\nFrom-SVN: r89678", "tree": {"sha": "15153eba8be51ec43a9e0a2ffcc89dfc446ed6ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15153eba8be51ec43a9e0a2ffcc89dfc446ed6ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f142e9fab708f504623b901a33dfc696c6a4d57d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f142e9fab708f504623b901a33dfc696c6a4d57d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f142e9fab708f504623b901a33dfc696c6a4d57d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f142e9fab708f504623b901a33dfc696c6a4d57d/comments", "author": null, "committer": null, "parents": [{"sha": "1cfd6c3a597923e35835256a0fb373ecb7e82966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cfd6c3a597923e35835256a0fb373ecb7e82966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cfd6c3a597923e35835256a0fb373ecb7e82966"}], "stats": {"total": 472, "additions": 309, "deletions": 163}, "files": [{"sha": "4b2c00a131a29871dc3f558187d63966888fe6fc", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 309, "deletions": 163, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f142e9fab708f504623b901a33dfc696c6a4d57d/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f142e9fab708f504623b901a33dfc696c6a4d57d/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=f142e9fab708f504623b901a33dfc696c6a4d57d", "patch": "@@ -187,7 +187,7 @@ Ada Core Technologies, Inc.@*\n * GNAT and Libraries::\n * Using the GNU make Utility::\n @end ifclear\n-* Finding Memory Problems::\n+* Memory Management Issues::\n * Creating Sample Bodies Using gnatstub::\n * Other Utility Programs::\n * Running and Debugging Ada Programs::\n@@ -368,6 +368,7 @@ GNAT Project Manager\n * Objects and Sources in Project Files::\n * Importing Projects::\n * Project Extension::\n+* Project Hierarchy Extension::\n * External References in Project Files::\n * Packages in Project Files::\n * Variables from Imported Projects::\n@@ -445,12 +446,17 @@ Using the GNU make Utility\n * Overcoming Command Line Length Limits::\n @end ifclear\n \n-Finding Memory Problems\n+Memory Management Issues\n \n+* Some Useful Memory Pools::\n+* The GNAT Debug Pool Facility::\n @ifclear vms\n * The gnatmem Tool::\n @end ifclear\n-* The GNAT Debug Pool Facility::\n+\n+Some Useful Memory Pools\n+\n+The GNAT Debug Pool Facility\n \n @ifclear vms\n The gnatmem Tool\n@@ -460,9 +466,7 @@ The gnatmem Tool\n * Example of gnatmem Usage::\n @end ifclear\n \n-The GNAT Debug Pool Facility\n-\n-Creating Sample Bodies Using gnatstub\n+ Sample Bodies Using gnatstub\n \n * Running gnatstub::\n * Switches for gnatstub::\n@@ -758,12 +762,13 @@ the GNAT toolset in Makefiles.\n @end ifclear\n \n @item\n-@ref{Finding Memory Problems}, describes\n+@ref{Memory Management Issues}, describes some useful predefined storage pools\n+and in particular the GNAT Debug Pool facility, which helps detect incorrect\n+memory references.\n @ifclear vms\n-@command{gnatmem}, a utility that monitors dynamic allocation and deallocation\n-and helps detect ``memory leaks'', and\n+It also describes @command{gnatmem}, a utility that monitors dynamic\n+allocation and deallocation and helps detect ``memory leaks''.\n @end ifclear\n-the GNAT Debug Pool facility, which helps detect incorrect memory references.\n \n @item\n @ref{Creating Sample Bodies Using gnatstub}, discusses @code{gnatstub},\n@@ -3258,7 +3263,7 @@ class Origin @{\n class A : public Origin @{\n  public:\n   void method1 (void);\n-  virtual void method2 (int v);\n+  void method2 (int v);\n   A();\n   int   a_value;\n @};\n@@ -10286,6 +10291,7 @@ are used in this example.\n * Objects and Sources in Project Files::\n * Importing Projects::\n * Project Extension::\n+* Project Hierarchy Extension::\n * External References in Project Files::\n * Packages in Project Files::\n * Variables from Imported Projects::\n@@ -12030,6 +12036,78 @@ projects.\n A project is not allowed to import directly or indirectly at the same time a\n child project and any of its ancestors.\n \n+@c *******************************\n+@c * Project Hierarchy Extension *\n+@c *******************************\n+\n+@node Project Hierarchy Extension\n+@section Project Hierarchy Extension\n+\n+@noindent\n+When extending a large system spanning multiple projects, it is often\n+inconvenient to extend every project in the hierarchy that is impacted by a\n+small change introduced. In such cases, it is possible to create a virtual\n+extension of entire hierarchy using @code{extends all} relationship.\n+\n+When the project is extended using @code{extends all} inheritance, all projects\n+that are imported by it, both directly and indirectly, are considered virtually\n+extended. That is, the Project Manager creates \"virtual projects\"\n+that extend every project in the hierarchy; all these virtual projects have\n+no sources of their own and have as object directory the object directory of\n+the root of \"extending all\" project.\n+\n+It is possible to explicitly extend one or more projects in the hierarchy\n+in order to modify the sources. These extending projects must be imported by\n+the \"extending all\" project, which will replace the corresponding virtual\n+projects with the explicit ones.\n+\n+When building such a project hierarchy extension, the Project Manager will\n+ensure that both modified sources and sources in virtual extending projects\n+that depend on them, are recompiled.\n+\n+By means of example, consider the following hierarchy of projects.\n+\n+@enumerate\n+@item\n+project A, containing package P1\n+@item\n+project B importing A and containing package P2 which depends on P1\n+@item\n+project C importing B and containing package P3 which depends on P2\n+@end enumerate\n+\n+@noindent\n+We want to modify packages P1 and P3.\n+\n+This project hierarchy will need to be extended as follows:\n+\n+@enumerate\n+@item\n+Create project A1 that extends A, placing modified P1 there:\n+\n+@smallexample @c 0projectfile\n+project A1 extends \"(...)/A\" is\n+end A1;\n+@end smallexample\n+\n+@item\n+Create project C1 that \"extends all\" C and imports A1, placing modified\n+P3 there:\n+\n+@smallexample @c 0projectfile\n+with \"(...)/A1\";\n+project C1 extends all \"(...)/C\" is\n+end C1;\n+@end smallexample\n+@end enumerate\n+\n+When you build project C1, your entire modified project space will be\n+recompiled, including the virtual project B1 that has been impacted by the\n+\"extending all\" inheritance of project C.\n+\n+Note that if a Library Project in the hierarchy is virtually extended,\n+the virtual project that extends the Library Project is not a Library Project.\n+\n @c ****************************************\n @c * External References in Project Files *\n @c ****************************************\n@@ -17137,25 +17215,237 @@ all:\n @end smallexample\n @end ifclear\n \n-@node Finding Memory Problems\n-@chapter Finding Memory Problems\n+@node Memory Management Issues\n+@chapter Memory Management Issues\n \n @noindent\n-This chapter describes\n+This chapter describes some useful memory pools provided in the GNAT library\n+and in particular the GNAT Debug Pool facility, which can be used to detect\n+incorrect uses of access values (including ``dangling references'').\n @ifclear vms\n-the @command{gnatmem} tool, which can be used to track down\n-``memory leaks'', and\n+It also describes the @command{gnatmem} tool, which can be used to track down\n+``memory leaks''.\n @end ifclear\n-the GNAT Debug Pool facility, which can be used to detect incorrect uses of\n-access values (including ``dangling references'').\n \n @menu\n+* Some Useful Memory Pools::\n+* The GNAT Debug Pool Facility::\n @ifclear vms\n * The gnatmem Tool::\n @end ifclear\n-* The GNAT Debug Pool Facility::\n @end menu\n \n+@node Some Useful Memory Pools\n+@section Some Useful Memory Pools\n+@findex Memory Pool\n+@cindex storage, pool\n+\n+@noindent\n+The @code{System.Pool_Global} package offers the Unbounded_No_Reclaim_Pool\n+storage pool. Allocations use the standard system call @code{malloc} while\n+deallocations use the standard system call @code{free}. No reclamation is\n+performed when the pool goes out of scope. For performance reasons, the\n+standard default Ada allocators/deallocators do not use any explicit storage\n+pools but if they did, they could use this storage pool without any change in\n+behavior. That is why this storage pool is used  when the user\n+manages to make the default implicit allocator explicit as in this example:\n+@smallexample @c ada\n+   type T1 is access Something;\n+    -- no Storage pool is defined for T2\n+   type T2 is access Something_Else;\n+   for T2'Storage_Pool use T1'Storage_Pool;\n+   -- the above is equivalent to\n+   for T2'Storage_Pool use System.Pool_Global.Global_Pool_Object;\n+@end smallexample\n+\n+@noindent\n+The @code{System.Pool_Local} package offers the Unbounded_Reclaim_Pool storage\n+pool. The allocation strategy is similar to @code{Pool_Local}'s\n+except that the all\n+storage allocated with this pool is reclaimed when the pool object goes out of\n+scope. This pool provides a explicit mechanism similar to the implicit one\n+provided by several Ada 83 compilers for allocations performed through a local\n+access type and whose purpose was to reclaim memory when exiting the\n+scope of a given local access. As an example, the following program does not\n+leak memory even though it does not perform explicit deallocation:\n+\n+@smallexample @c ada\n+with System.Pool_Local;\n+procedure Pooloc1 is\n+   procedure Internal is\n+      type A is access Integer;\n+      X : System.Pool_Local.Unbounded_Reclaim_Pool;\n+      for A'Storage_Pool use X;\n+      v : A;\n+   begin\n+      for I in  1 .. 50 loop\n+         v := new Integer;\n+      end loop;\n+   end Internal;\n+begin\n+   for I in  1 .. 100 loop\n+      Internal;\n+   end loop;\n+end Pooloc1;\n+@end smallexample\n+\n+@noindent\n+The @code{System.Pool_Size} package implements the Stack_Bounded_Pool used when\n+@code{Storage_Size} is specified for an access type.\n+The whole storage for the pool is\n+allocated at once, usually on the stack at the point where the access type is\n+elaborated. It is automatically reclaimed when exiting the scope where the\n+access type is defined. This package is not intended to be used directly by the\n+user and it is implicitly used for each such declaration:\n+\n+@smallexample @c ada\n+   type T1 is access Something;\n+   for T1'Storage_Size use 10_000;\n+@end smallexample\n+\n+\n+@node The GNAT Debug Pool Facility\n+@section The GNAT Debug Pool Facility\n+@findex Debug Pool\n+@cindex storage, pool, memory corruption\n+\n+@noindent\n+The use of unchecked deallocation and unchecked conversion can easily\n+lead to incorrect memory references. The problems generated by such\n+references are usually difficult to tackle because the symptoms can be\n+very remote from the origin of the problem. In such cases, it is\n+very helpful to detect the problem as early as possible. This is the\n+purpose of the Storage Pool provided by @code{GNAT.Debug_Pools}.\n+\n+In order to use the GNAT specific debugging pool, the user must\n+associate a debug pool object with each of the access types that may be\n+related to suspected memory problems. See Ada Reference Manual 13.11.\n+@smallexample @c ada\n+type Ptr is access Some_Type;\n+Pool : GNAT.Debug_Pools.Debug_Pool;\n+for Ptr'Storage_Pool use Pool;\n+@end smallexample\n+\n+@noindent\n+@code{GNAT.Debug_Pools} is derived from a GNAT-specific kind of\n+pool: the @code{Checked_Pool}. Such pools, like standard Ada storage pools,\n+allow the user to redefine allocation and deallocation strategies. They\n+also provide a checkpoint for each dereference, through the use of\n+the primitive operation @code{Dereference} which is implicitly called at\n+each dereference of an access value.\n+\n+Once an access type has been associated with a debug pool, operations on\n+values of the type may raise four distinct exceptions,\n+which correspond to four potential kinds of memory corruption:\n+@itemize @bullet\n+@item\n+@code{GNAT.Debug_Pools.Accessing_Not_Allocated_Storage}\n+@item\n+@code{GNAT.Debug_Pools.Accessing_Deallocated_Storage}\n+@item\n+@code{GNAT.Debug_Pools.Freeing_Not_Allocated_Storage}\n+@item\n+@code{GNAT.Debug_Pools.Freeing_Deallocated_Storage }\n+@end itemize\n+\n+@noindent\n+For types associated with a Debug_Pool, dynamic allocation is performed using\n+the standard GNAT allocation routine. References to all allocated chunks of\n+memory are kept in an internal dictionary. Several deallocation strategies are\n+provided, whereupon the user can choose to release the memory to the system,\n+keep it allocated for further invalid access checks, or fill it with an easily\n+recognizable pattern for debug sessions. The memory pattern is the old IBM\n+hexadecimal convention: @code{16#DEADBEEF#}.\n+\n+See the documentation in the file g-debpoo.ads for more information on the\n+various strategies.\n+\n+Upon each dereference, a check is made that the access value denotes a\n+properly allocated memory location. Here is a complete example of use of\n+@code{Debug_Pools}, that includes typical instances of  memory corruption:\n+@smallexample @c ada\n+@iftex\n+@leftskip=0cm\n+@end iftex\n+with Gnat.Io; use Gnat.Io;\n+with Unchecked_Deallocation;\n+with Unchecked_Conversion;\n+with GNAT.Debug_Pools;\n+with System.Storage_Elements;\n+with Ada.Exceptions; use Ada.Exceptions;\n+procedure Debug_Pool_Test is\n+\n+   type T is access Integer;\n+   type U is access all T;\n+\n+   P : GNAT.Debug_Pools.Debug_Pool;\n+   for T'Storage_Pool use P;\n+\n+   procedure Free is new Unchecked_Deallocation (Integer, T);\n+   function UC is new Unchecked_Conversion (U, T);\n+   A, B : aliased T;\n+\n+   procedure Info is new GNAT.Debug_Pools.Print_Info(Put_Line);\n+\n+begin\n+   Info (P);\n+   A := new Integer;\n+   B := new Integer;\n+   B := A;\n+   Info (P);\n+   Free (A);\n+   begin\n+      Put_Line (Integer'Image(B.all));\n+   exception\n+      when E : others => Put_Line (\"raised: \" & Exception_Name (E));\n+   end;\n+   begin\n+      Free (B);\n+   exception\n+      when E : others => Put_Line (\"raised: \" & Exception_Name (E));\n+   end;\n+   B := UC(A'Access);\n+   begin\n+      Put_Line (Integer'Image(B.all));\n+   exception\n+      when E : others => Put_Line (\"raised: \" & Exception_Name (E));\n+   end;\n+   begin\n+      Free (B);\n+   exception\n+      when E : others => Put_Line (\"raised: \" & Exception_Name (E));\n+   end;\n+   Info (P);\n+end Debug_Pool_Test;\n+@end smallexample\n+\n+@noindent\n+The debug pool mechanism provides the following precise diagnostics on the\n+execution of this erroneous program:\n+@smallexample\n+Debug Pool info:\n+  Total allocated bytes :  0\n+  Total deallocated bytes :  0\n+  Current Water Mark:  0\n+  High Water Mark:  0\n+\n+Debug Pool info:\n+  Total allocated bytes :  8\n+  Total deallocated bytes :  0\n+  Current Water Mark:  8\n+  High Water Mark:  8\n+\n+raised: GNAT.DEBUG_POOLS.ACCESSING_DEALLOCATED_STORAGE\n+raised: GNAT.DEBUG_POOLS.FREEING_DEALLOCATED_STORAGE\n+raised: GNAT.DEBUG_POOLS.ACCESSING_NOT_ALLOCATED_STORAGE\n+raised: GNAT.DEBUG_POOLS.FREEING_NOT_ALLOCATED_STORAGE\n+Debug Pool info:\n+  Total allocated bytes :  8\n+  Total deallocated bytes :  4\n+  Current Water Mark:  4\n+  High Water Mark:  8\n+@end smallexample\n+\n @ifclear vms\n @node The gnatmem Tool\n @section The @command{gnatmem} Tool\n@@ -17498,150 +17788,6 @@ and #3 thanks to the more precise associated backtrace.\n \n @end ifclear\n \n-@node The GNAT Debug Pool Facility\n-@section The GNAT Debug Pool Facility\n-@findex Debug Pool\n-@cindex storage, pool, memory corruption\n-\n-@noindent\n-The use of unchecked deallocation and unchecked conversion can easily\n-lead to incorrect memory references. The problems generated by such\n-references are usually difficult to tackle because the symptoms can be\n-very remote from the origin of the problem. In such cases, it is\n-very helpful to detect the problem as early as possible. This is the\n-purpose of the Storage Pool provided by @code{GNAT.Debug_Pools}.\n-\n-In order to use the GNAT specific debugging pool, the user must\n-associate a debug pool object with each of the access types that may be\n-related to suspected memory problems. See Ada Reference Manual 13.11.\n-@smallexample @c ada\n-type Ptr is access Some_Type;\n-Pool : GNAT.Debug_Pools.Debug_Pool;\n-for Ptr'Storage_Pool use Pool;\n-@end smallexample\n-\n-@noindent\n-@code{GNAT.Debug_Pools} is derived from a GNAT-specific kind of\n-pool: the @code{Checked_Pool}. Such pools, like standard Ada storage pools,\n-allow the user to redefine allocation and deallocation strategies. They\n-also provide a checkpoint for each dereference, through the use of\n-the primitive operation @code{Dereference} which is implicitly called at\n-each dereference of an access value.\n-\n-Once an access type has been associated with a debug pool, operations on\n-values of the type may raise four distinct exceptions,\n-which correspond to four potential kinds of memory corruption:\n-@itemize @bullet\n-@item\n-@code{GNAT.Debug_Pools.Accessing_Not_Allocated_Storage}\n-@item\n-@code{GNAT.Debug_Pools.Accessing_Deallocated_Storage}\n-@item\n-@code{GNAT.Debug_Pools.Freeing_Not_Allocated_Storage}\n-@item\n-@code{GNAT.Debug_Pools.Freeing_Deallocated_Storage }\n-@end itemize\n-\n-@noindent\n-For types associated with a Debug_Pool, dynamic allocation is performed using\n-the standard\n-GNAT allocation routine. References to all allocated chunks of memory\n-are kept in an internal dictionary.\n-Several deallocation strategies are provided, whereupon the user can choose\n-to release the memory to the system, keep it allocated for further invalid\n-access checks, or fill it with an easily recognizable pattern for debug\n-sessions.\n-The memory pattern is the old IBM hexadecimal convention: @code{16#DEADBEEF#}.\n-\n-See the documentation in the file g-debpoo.ads for more information on the\n-various strategies.\n-\n-Upon each dereference, a check is made that the access value denotes a\n-properly allocated memory location. Here is a complete example of use of\n-@code{Debug_Pools}, that includes typical instances of  memory corruption:\n-@smallexample @c ada\n-@iftex\n-@leftskip=0cm\n-@end iftex\n-with Gnat.Io; use Gnat.Io;\n-with Unchecked_Deallocation;\n-with Unchecked_Conversion;\n-with GNAT.Debug_Pools;\n-with System.Storage_Elements;\n-with Ada.Exceptions; use Ada.Exceptions;\n-procedure Debug_Pool_Test is\n-\n-   type T is access Integer;\n-   type U is access all T;\n-\n-   P : GNAT.Debug_Pools.Debug_Pool;\n-   for T'Storage_Pool use P;\n-\n-   procedure Free is new Unchecked_Deallocation (Integer, T);\n-   function UC is new Unchecked_Conversion (U, T);\n-   A, B : aliased T;\n-\n-   procedure Info is new GNAT.Debug_Pools.Print_Info(Put_Line);\n-\n-begin\n-   Info (P);\n-   A := new Integer;\n-   B := new Integer;\n-   B := A;\n-   Info (P);\n-   Free (A);\n-   begin\n-      Put_Line (Integer'Image(B.all));\n-   exception\n-      when E : others => Put_Line (\"raised: \" & Exception_Name (E));\n-   end;\n-   begin\n-      Free (B);\n-   exception\n-      when E : others => Put_Line (\"raised: \" & Exception_Name (E));\n-   end;\n-   B := UC(A'Access);\n-   begin\n-      Put_Line (Integer'Image(B.all));\n-   exception\n-      when E : others => Put_Line (\"raised: \" & Exception_Name (E));\n-   end;\n-   begin\n-      Free (B);\n-   exception\n-      when E : others => Put_Line (\"raised: \" & Exception_Name (E));\n-   end;\n-   Info (P);\n-end Debug_Pool_Test;\n-@end smallexample\n-\n-@noindent\n-The debug pool mechanism provides the following precise diagnostics on the\n-execution of this erroneous program:\n-@smallexample\n-Debug Pool info:\n-  Total allocated bytes :  0\n-  Total deallocated bytes :  0\n-  Current Water Mark:  0\n-  High Water Mark:  0\n-\n-Debug Pool info:\n-  Total allocated bytes :  8\n-  Total deallocated bytes :  0\n-  Current Water Mark:  8\n-  High Water Mark:  8\n-\n-raised: GNAT.DEBUG_POOLS.ACCESSING_DEALLOCATED_STORAGE\n-raised: GNAT.DEBUG_POOLS.FREEING_DEALLOCATED_STORAGE\n-raised: GNAT.DEBUG_POOLS.ACCESSING_NOT_ALLOCATED_STORAGE\n-raised: GNAT.DEBUG_POOLS.FREEING_NOT_ALLOCATED_STORAGE\n-Debug Pool info:\n-  Total allocated bytes :  8\n-  Total deallocated bytes :  4\n-  Current Water Mark:  4\n-  High Water Mark:  8\n-@end smallexample\n-\n @node Creating Sample Bodies Using gnatstub\n @chapter Creating Sample Bodies Using @command{gnatstub}\n @findex gnatstub"}]}