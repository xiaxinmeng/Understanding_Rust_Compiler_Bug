{"sha": "10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBkYTExMzE5YjA5MDJhMGIxMGU2ZmNkM2NjYjFjNjE3NzNiZGIxOA==", "commit": {"author": {"name": "Bob Manson", "email": "manson@charmed.cygnus.com", "date": "1998-04-06T20:51:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-06T20:51:28Z"}, "message": "gcc.c: Add linker spec.\n\n        * gcc.c: Add linker spec.\n        (link_command_spec): Use %(linker) instead of ld.\n        (main): If collect2 is requested as the linker, see if it exists;\n        if not, use ld instead.\n        * Makefile.in (USE_COLLECT2): It's named collect2 now, not ld.\n        (ld:) Deleted.\n        (install-collect2): Install as collect2, not ld.\n        * configure.in(will_use_collect2): It's named collect2 now.\n        * collect2: Remove checks to see if we were invoked recursively.\n        (collect_execute): Use _spawnvp under cygwin32.\n\nFrom-SVN: r19022", "tree": {"sha": "126d2a145b4faeac130fc25530eea4daca1beda3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/126d2a145b4faeac130fc25530eea4daca1beda3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/comments", "author": null, "committer": null, "parents": [{"sha": "a8afd67b0172b66bb0c08d798054eb409adce196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8afd67b0172b66bb0c08d798054eb409adce196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8afd67b0172b66bb0c08d798054eb409adce196"}], "stats": {"total": 198, "additions": 53, "deletions": 145}, "files": [{"sha": "5054a6580562b6fbed7569d2b6ad6e98997c2e4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "patch": "@@ -1,3 +1,19 @@\n+Mon Apr  6 21:49:57 1998  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* gcc.c: Add linker spec.\n+\t(link_command_spec): Use %(linker) instead of ld.\n+\t(main): If collect2 is requested as the linker, see if it exists;\n+ \tif not, use ld instead.\n+\n+\t* Makefile.in (USE_COLLECT2): It's named collect2 now, not ld.\n+\t(ld:) Deleted.\n+\t(install-collect2): Install as collect2, not ld.\n+\n+\t* configure.in(will_use_collect2): It's named collect2 now.\n+\n+\t* collect2: Remove checks to see if we were invoked recursively.\n+\t(collect_execute): Use _spawnvp under cygwin32.\n+\n Mon Apr  6 17:23:41 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* haifa-sched.c (build_control_flow): Set unreachable for block whose"}, {"sha": "66db829d4e7575ed3aa78b1c8fbba6187ed4922a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "patch": "@@ -334,12 +334,12 @@ EXTRA_GCC_OBJS =@host_extra_gcc_objs@\n # Often this is edited directly by `configure'.\n EXTRA_HEADERS =@extra_headers_list@\n \n-# Set this to `ld' to enable use of collect2.\n+# Set this to `collect2' to enable use of collect2.\n USE_COLLECT2 = @will_use_collect2@\n MAYBE_USE_COLLECT2 = @maybe_use_collect2@\n # It is convenient for configure to add the assignment at the beginning,\n # so don't override it here.\n-USE_COLLECT2 = ld$(exeext)\n+USE_COLLECT2 = collect2$(exeext)\n \n # List of extra C and assembler files to add to libgcc1.a.\n # Assembler files should have names ending in `.asm'.\n@@ -1254,11 +1254,6 @@ c-pragma.o: c-pragma.c $(CONFIG_H) system.h $(TREE_H) except.h function.h \\\n c-iterate.o: c-iterate.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n     flags.h\n \n-# To make a configuration always use collect2, set USE_COLLECT2 to ld.\n-ld$(exeext): collect2$(exeext)\n-\trm -f ld$(exeext)\n-\t$(LN) collect2$(exeext) ld$(exeext)\n-\n collect2$(exeext): collect2.o tlink.o hash.o cplus-dem.o underscore.o \\\n \tversion.o choose-temp.o $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n@@ -2390,9 +2385,9 @@ install-assert-h: assert.h installdirs\n \t  chmod a-x $(assertdir)/assert.h; \\\n \tfi\n \n-# Use this target to install the program `collect2' under the name `ld'.\n+# Use this target to install the program `collect2' under the name `collect2'.\n install-collect2: collect2 installdirs\n-\t$(INSTALL_PROGRAM) collect2$(exeext) $(libsubdir)/ld$(exeext)\n+\t$(INSTALL_PROGRAM) collect2$(exeext) $(libsubdir)/collect2$(exeext)\n # Install the driver program as $(libsubdir)/gcc for collect2.\n \t$(INSTALL_PROGRAM) xgcc$(exeext) $(libsubdir)/gcc$(exeext)\n "}, {"sha": "a1b7ddccf145964bcbfe2c1ad7cfb3157ecd1e5d", "filename": "gcc/collect2.c", "status": "modified", "additions": 15, "deletions": 132, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "patch": "@@ -35,6 +35,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"demangle.h\"\n #include \"obstack.h\"\n #include \"gansidecl.h\"\n+#ifdef __CYGWIN32__\n+#include <process.h>\n+#endif\n \n #ifndef HAVE_STRERROR\n extern char *sys_errlist[];\n@@ -281,7 +284,6 @@ void collect_execute\t\tPROTO((char *, char **, char *));\n void dump_file\t\t\tPROTO((char *));\n static void handler\t\tPROTO((int));\n static int is_ctor_dtor\t\tPROTO((char *));\n-static int is_in_prefix_list\tPROTO((struct path_prefix *, char *, int));\n static char *find_a_file\tPROTO((struct path_prefix *, char *));\n static void add_prefix\t\tPROTO((struct path_prefix *, char *));\n static void prefix_from_env\tPROTO((char *, struct path_prefix *));\n@@ -733,48 +735,6 @@ static struct path_prefix cpath, path;\n static char *target_machine = TARGET_MACHINE;\n #endif\n \n-/* Names under which we were executed.  Never return one of those files in our\n-   searches.  */\n-\n-static struct path_prefix our_file_names;\n-\f\n-/* Determine if STRING is in PPREFIX.\n-\n-   This utility is currently only used to look up file names.  Prefix lists\n-   record directory names.  This matters to us because the latter has a \n-   trailing slash, so I've added a flag to handle both.  */\n-\n-static int\n-is_in_prefix_list (pprefix, string, filep)\n-     struct path_prefix *pprefix;\n-     char *string;\n-     int filep;\n-{\n-  struct prefix_list *pl;\n-\n-  if (filep)\n-    {\n-      int len = strlen (string);\n-\n-      for (pl = pprefix->plist; pl; pl = pl->next)\n-\t{\n-\t  if (strncmp (pl->prefix, string, len) == 0\n-\t      && strcmp (pl->prefix + len, \"/\") == 0)\n-\t    return 1;\n-\t}\n-    }\n-  else\n-    {\n-      for (pl = pprefix->plist; pl; pl = pl->next)\n-\t{\n-\t  if (strcmp (pl->prefix, string) == 0)\n-\t    return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n /* Search for NAME using prefix list PPREFIX.  We only look for executable\n    files. \n \n@@ -825,40 +785,18 @@ find_a_file (pprefix, name)\n       {\n \tstrcpy (temp, pl->prefix);\n \tstrcat (temp, name);\n-\n-\tif (debug)\n-\t  fprintf (stderr, \"  - try: %s\\n\", temp);\n \t\n-\tif (! is_in_prefix_list (&our_file_names, temp, 1)\n-\t    /* This is a kludge, but there seems no way around it.  */\n-\t    && strcmp (temp, \"./ld\") != 0\n-\t    && access (temp, X_OK) == 0)\n-\t  {\n-\t    if (debug)\n-\t      fprintf (stderr, \"  - found!\\n\");\n-\t    \n-\t    return temp;\n-\t  }\n+\tif (access (temp, X_OK) == 0)\n+\t  return temp;\n \n #ifdef EXECUTABLE_SUFFIX\n \t/* Some systems have a suffix for executable files.\n \t   So try appending that.  */\n \tstrcat (temp, EXECUTABLE_SUFFIX);\n \t\n-\tif (debug)\n-\t  fprintf (stderr, \"  - try: %s\\n\", temp);\n-\t\n-\tif (! is_in_prefix_list (&our_file_names, temp, 1)\n-\t    && access (temp, X_OK) == 0)\n-\t  {\n-\t    if (debug)\n-\t      fprintf (stderr, \"  - found!  (Uses executable suffix)\\n\");\n-\t    \n-\t    return temp;\n-\t  }\n-#endif\n-\tif (debug && pl->next == NULL)\n-\t  fprintf (stderr, \"  - failed to locate using relative paths\\n\");\n+\tif (access (temp, X_OK) == 0)\n+\t  return temp;\n+#endif\n       }\n \n   if (debug && pprefix->plist == NULL)\n@@ -990,8 +928,6 @@ main (argc, argv)\n   FILE *importf;\n #endif\n   char *ld_file_name;\n-  char *collect_name;\n-  char *collect_names;\n   char *p;\n   char **c_argv;\n   char **c_ptr;\n@@ -1029,51 +965,8 @@ main (argc, argv)\n   obstack_begin (&temporary_obstack, 0);\n   obstack_begin (&permanent_obstack, 0);\n   temporary_firstobj = (char *) obstack_alloc (&temporary_obstack, 0);\n-  current_demangling_style = gnu_demangling;\n-\n-  /* We must check that we do not call ourselves in an infinite\n-     recursion loop. We append the name used for us to the COLLECT_NAMES\n-     environment variable.\n-\n-     In practice, collect will rarely invoke itself.  This can happen now\n-     that we are no longer called gld.  A perfect example is when running\n-     gcc in a build directory that has been installed.  When looking for\n-     ld's, we will find our installed version and believe that's the real ld.  */\n-\n-  /* We must also append COLLECT_NAME to COLLECT_NAMES to watch for the\n-     previous version of collect (the one that used COLLECT_NAME and only\n-     handled two levels of recursion).  If we do not we may mutually recurse\n-     forever.  This can happen (I think) when bootstrapping the old version\n-     and a new one is installed (rare, but we should handle it).\n-     ??? Hopefully references to COLLECT_NAME can be removed at some point.  */\n-\n-  GET_ENVIRONMENT (collect_name,  \"COLLECT_NAME\");\n-  GET_ENVIRONMENT (collect_names, \"COLLECT_NAMES\");\n-\n-  p = (char *) xmalloc (strlen (\"COLLECT_NAMES=\")\n-\t\t\t+ (collect_name ? strlen (collect_name) + 1 : 0)\n-\t\t\t+ (collect_names ? strlen (collect_names) + 1 : 0)\n-\t\t\t+ strlen (argv[0]) + 1);\n-  strcpy (p, \"COLLECT_NAMES=\");\n-  if (collect_name != 0)\n-    sprintf (p + strlen (p), \"%s%c\", collect_name, PATH_SEPARATOR);\n-  if (collect_names != 0)\n-    sprintf (p + strlen (p), \"%s%c\", collect_names, PATH_SEPARATOR);\n-  strcat (p, argv[0]);\n-  putenv (p);\n-\n-  prefix_from_env (\"COLLECT_NAMES\", &our_file_names);\n-\n-  /* Set environment variable COLLECT_NAME to our name so the previous version\n-     of collect will not find us.  If it does we will mutually recurse forever.\n-     This can happen when bootstrapping the new version and an old version is\n-     installed.\n-     ??? Hopefully this bit of code can be removed at some point.  */\n-\n-  p = xmalloc (strlen (\"COLLECT_NAME=\") + strlen (argv[0]) + 1);\n-  sprintf (p, \"COLLECT_NAME=%s\", argv[0]);\n-  putenv (p);\n \n+  current_demangling_style = gnu_demangling;\n   p = getenv (\"COLLECT_GCC_OPTIONS\");\n   while (p && *p)\n     {\n@@ -1188,18 +1081,6 @@ main (argc, argv)\n   if (ld_file_name == 0)\n     ld_file_name = find_a_file (&path, full_ld_suffix);\n \n-  /* If we've invoked ourselves, try again with LD_FILE_NAME.  */\n-\n-  if (collect_names != 0)\n-    {\n-      if (ld_file_name != 0)\n-\t{\n-\t  argv[0] = ld_file_name;\n-\t  execvp (argv[0], argv);\n-\t}\n-      fatal (\"cannot find `ld' (%s)\", ld_file_name);\n-    }\n-\n #ifdef REAL_NM_FILE_NAME\n   nm_file_name = find_a_file (&path, REAL_NM_FILE_NAME);\n   if (nm_file_name == 0)\n@@ -1518,10 +1399,6 @@ main (argc, argv)\n       fprintf (stderr, \"o_file              = %s\\n\",\n \t       (o_file ? o_file : \"not found\"));\n \n-      ptr = getenv (\"COLLECT_NAMES\");\n-      if (ptr)\n-\tfprintf (stderr, \"COLLECT_NAMES       = %s\\n\", ptr);\n-\n       ptr = getenv (\"COLLECT_GCC_OPTIONS\");\n       if (ptr)\n \tfprintf (stderr, \"COLLECT_GCC_OPTIONS = %s\\n\", ptr);\n@@ -1773,6 +1650,7 @@ collect_execute (prog, argv, redir)\n   if (argv[0] == 0)\n     fatal (\"cannot find `%s'\", prog);\n \n+#ifndef __CYGWIN32__\n   pid = vfork ();\n   if (pid == -1)\n     {\n@@ -1797,6 +1675,11 @@ collect_execute (prog, argv, redir)\n       execvp (argv[0], argv);\n       fatal_perror (\"executing %s\", prog);\n     }\n+#else\n+  pid = _spawnvp (_P_NOWAIT, argv[0], argv);\n+  if (pid == -1)\n+    fatal (\"spawnvp failed\");\n+#endif\n }\n \n static void"}, {"sha": "cc419d499388f08c18816cf29d15d91afa1dac34", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "patch": "@@ -4792,7 +4792,7 @@ then\n \twill_use_collect2=\n \tmaybe_use_collect2=\n else\n-\twill_use_collect2=\"ld\"\n+\twill_use_collect2=\"collect2\"\n \tmaybe_use_collect2=\"-DUSE_COLLECT2\"\n fi\n "}, {"sha": "2bb5892c4cf8426968e6579fdc9d61e59ff01213", "filename": "gcc/configure.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "patch": "@@ -3109,7 +3109,7 @@ then\n \twill_use_collect2=\n \tmaybe_use_collect2=\n else\n-\twill_use_collect2=\"ld\"\n+\twill_use_collect2=\"collect2\"\n \tmaybe_use_collect2=\"-DUSE_COLLECT2\"\n fi\n "}, {"sha": "ff4cf956b9cc22aa773387af3c9afd293f099071", "filename": "gcc/gcc.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10da11319b0902a0b10e6fcd3ccb1c61773bdb18/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=10da11319b0902a0b10e6fcd3ccb1c61773bdb18", "patch": "@@ -477,6 +477,10 @@ proper position among the other output files.  */\n #endif\n #endif\n \n+#ifndef LINKER_NAME\n+#define LINKER_NAME \"collect2\"\n+#endif\n+\n static char *cpp_spec = CPP_SPEC;\n static char *cpp_predefines = CPP_PREDEFINES;\n static char *cc1_spec = CC1_SPEC;\n@@ -490,6 +494,7 @@ static char *libgcc_spec = LIBGCC_SPEC;\n static char *endfile_spec = ENDFILE_SPEC;\n static char *startfile_spec = STARTFILE_SPEC;\n static char *switches_need_spaces = SWITCHES_NEED_SPACES;\n+static char *linker_name_spec = LINKER_NAME;\n \n /* Some compilers have limits on line lengths, and the multilib_select\n    and/or multilib_matches strings can be very long, so we build them at\n@@ -708,7 +713,7 @@ static int n_default_compilers\n /* Don't generate -L options.  */\n static char *link_command_spec = \"\\\n %{!fsyntax-only: \\\n- %{!c:%{!M:%{!MM:%{!E:%{!S:ld %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} \\\n+ %{!c:%{!M:%{!MM:%{!E:%{!S:%(linker) %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} \\\n \t\t\t%{r} %{s} %{t} %{u*} %{x} %{z} %{Z}\\\n \t\t\t%{!A:%{!nostdlib:%{!nostartfiles:%S}}}\\\n \t\t\t%{static:} %{L*} %o\\\n@@ -720,7 +725,7 @@ static char *link_command_spec = \"\\\n /* Use -L.  */\n static char *link_command_spec = \"\\\n %{!fsyntax-only: \\\n- %{!c:%{!M:%{!MM:%{!E:%{!S:ld %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} \\\n+ %{!c:%{!M:%{!MM:%{!E:%{!S:%(linker) %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} \\\n \t\t\t%{r} %{s} %{t} %{u*} %{x} %{z} %{Z}\\\n \t\t\t%{!A:%{!nostdlib:%{!nostartfiles:%S}}}\\\n \t\t\t%{static:} %{L*} %D %o\\\n@@ -1093,6 +1098,7 @@ static struct spec_list static_specs[] = {\n   INIT_STATIC_SPEC (\"multilib_defaults\",\t&multilib_defaults),\n   INIT_STATIC_SPEC (\"multilib_extra\",\t\t&multilib_extra),\n   INIT_STATIC_SPEC (\"multilib_matches\",\t\t&multilib_matches),\n+  INIT_STATIC_SPEC (\"linker\",\t\t\t&linker_name_spec),\n };\n \n #ifdef EXTRA_SPECS\t\t/* additional specs needed */\n@@ -2130,6 +2136,7 @@ execute ()\n   commands[0].prog = argbuf[0]; /* first command.  */\n   commands[0].argv = &argbuf[0];\n   string = find_a_file (&exec_prefixes, commands[0].prog, X_OK);\n+\n   if (string)\n     commands[0].argv[0] = string;\n \n@@ -4797,6 +4804,13 @@ main (argc, argv)\n     {\n       int tmp = execution_count;\n \n+      /* We'll use ld if we can't find collect2. */\n+      if (! strcmp (linker_name_spec, \"collect2\"))\n+\t{\n+\t  char *s = find_a_file (&exec_prefixes, \"collect2\", X_OK);\n+\t  if (s == NULL)\n+\t    linker_name_spec = \"ld\";\n+\t}\n       /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables\n \t for collect.  */\n       putenv_from_prefixes (&exec_prefixes, \"COMPILER_PATH=\");"}]}