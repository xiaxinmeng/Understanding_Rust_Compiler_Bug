{"sha": "cd9643f75b2f7bc41642bd988532a03ba923c3f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q5NjQzZjc1YjJmN2JjNDE2NDJiZDk4ODUzMmEwM2JhOTIzYzNmNA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-05-05T21:10:07Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-05-05T21:10:07Z"}, "message": "class.c (make_field_value): DECL_INITIAL may be a string literal...\n\nd\n\t* class.c (make_field_value):  DECL_INITIAL may be a string literal;\n\ttemporarily zero it while calling rest_of_decl_compilation.\n\t* java-tree.h (string_ptr_type_node):  Add declaration.\n\t* decl.c:  Define and initialize string_ptr_type_node.\n\t* parse.y (patch_string_cst):  Use string_ptr_type_node.\n\t* parse.h (LOOP_HAS_LABEL_P, LOOP_HAS_LABEL_SKIP_P):  Removed.\n\t* parse.y (for_statement):  Now unconditionally exit_block.\n\t(finish_labeled_statement):  No longer exit_block if for-loop.\n\t(patch_loop_statement):  Check harder if the loop is already labeled.\n\t* parse.y (patch_initialized_static_field):  Removed function.\n\t(maybe_generate_clinit):  Removed special handling for interfaces.\n\t(java_complete_expand_methods):  Do a preliminary java_complete_tree\n\ton <clinit> to determine if it can be removed.\n\t(java_complete_expand_method):  Remove special handling for <clinit>.\n\t(java_complete_lhs):  For BLOCK and EXPR_WITH_FILE_LOCATION\n\toptimize if we get back empty_stmt_node.\n\tFor MODIFY_EXPR, re-do checking of static initializers.\n\t(fold_constant_for_init):  Don't return immediate if VAR_DECL.\n\tFor VAR_DECL, pass correct context.\n\nFrom-SVN: r26790", "tree": {"sha": "6125e0290d9b6e83ae6f4e2dd48bdf11dfdaa937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6125e0290d9b6e83ae6f4e2dd48bdf11dfdaa937"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd9643f75b2f7bc41642bd988532a03ba923c3f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9643f75b2f7bc41642bd988532a03ba923c3f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd9643f75b2f7bc41642bd988532a03ba923c3f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9643f75b2f7bc41642bd988532a03ba923c3f4/comments", "author": null, "committer": null, "parents": [{"sha": "c14cff58e5c6d6052e940cb1adf03733154ec9b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c14cff58e5c6d6052e940cb1adf03733154ec9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c14cff58e5c6d6052e940cb1adf03733154ec9b6"}], "stats": {"total": 1222, "additions": 610, "deletions": 612}, "files": [{"sha": "2e00e74eb47617f714d247f42594fe73f7a360be", "filename": "gcc/java/class.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=cd9643f75b2f7bc41642bd988532a03ba923c3f4", "patch": "@@ -1025,9 +1025,16 @@ make_class_data (type)\n \t  tree init = make_field_value (field);\n \t  if (FIELD_STATIC (field))\n \t    {\n+\t      tree initial = DECL_INITIAL (field);\n \t      static_field_count++;\n \t      static_fields = tree_cons (NULL_TREE, init, static_fields);\n+\t      /* If the initial value is a string constant,\n+\t\t prevent output_constant from trying to assemble the value. */\n+\t      if (initial != NULL_TREE\n+\t\t  && TREE_TYPE (initial) == string_ptr_type_node)\n+\t\tDECL_INITIAL (field) = NULL_TREE;\n \t      rest_of_decl_compilation (field, (char*) 0, 1, 1);\n+\t      DECL_INITIAL (field) = initial;\n \t    }\n \t  else\n \t    {"}, {"sha": "409df66f540436c20fa515f99814c584306a4a18", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=cd9643f75b2f7bc41642bd988532a03ba923c3f4", "patch": "@@ -254,6 +254,7 @@ tree object_type_node;\n tree unqualified_object_id_node;\n tree object_ptr_type_node;\n tree string_type_node;\n+tree string_ptr_type_node;\n tree throwable_type_node;\n tree runtime_exception_type_node;\n tree error_exception_type_node;\n@@ -549,6 +550,7 @@ init_decl_processing ()\n   object_type_node = lookup_class (get_identifier (\"java.lang.Object\"));\n   object_ptr_type_node = promote_type (object_type_node);\n   string_type_node = lookup_class (get_identifier (\"java.lang.String\"));\n+  string_ptr_type_node = promote_type (string_type_node);\n   class_type_node = lookup_class (get_identifier (\"java.lang.Class\"));\n   throwable_type_node = lookup_class (get_identifier (\"java.lang.Throwable\"));\n   runtime_exception_type_node = "}, {"sha": "2b4acb83e10d46122280caee3fcf88a2be62c7a8", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=cd9643f75b2f7bc41642bd988532a03ba923c3f4", "patch": "@@ -198,6 +198,7 @@ extern tree object_type_node;\n extern tree unqualified_object_id_node;\n extern tree object_ptr_type_node;\n extern tree string_type_node;\n+extern tree string_ptr_type_node;\n extern tree throwable_type_node;\n extern tree runtime_exception_type_node;\n extern tree error_exception_type_node;"}, {"sha": "5e604e0be983d5943bc018c04d8b89229b1320a5", "filename": "gcc/java/parse.c", "status": "modified", "additions": 512, "deletions": 512, "changes": 1024, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=cd9643f75b2f7bc41642bd988532a03ba923c3f4", "patch": "@@ -313,7 +313,6 @@ static tree patch_new_array_init PROTO ((tree, tree));\n static tree maybe_build_array_element_wfl PROTO ((tree));\n static int array_constructor_check_entry PROTO ((tree, tree));\n static char *purify_type_name PROTO ((char *));\n-static tree patch_initialized_static_field PROTO ((tree));\n static tree fold_constant_for_init PROTO ((tree, tree));\n static tree strip_out_static_field_access_decl PROTO ((tree));\n static jdeplist *reverse_jdep_list PROTO ((struct parser_ctxt *));\n@@ -373,7 +372,7 @@ static tree java_lang_cloneable = NULL_TREE;\n static tree current_static_block = NULL_TREE;\n \n \n-#line 301 \"./parse.y\"\n+#line 300 \"./parse.y\"\n typedef union {\n   tree node;\n   int sub_token;\n@@ -383,7 +382,7 @@ typedef union {\n   } operator;\n   int value;\n } YYSTYPE;\n-#line 311 \"./parse.y\"\n+#line 310 \"./parse.y\"\n \n #include \"lex.c\"\n #ifndef YYDEBUG\n@@ -680,56 +679,56 @@ static const short yyrhs[] = {   123,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   455,   461,   463,   464,   465,   466,   467,   471,   473,   476,\n-   478,   479,   482,   484,   487,   491,   495,   499,   505,   507,\n-   509,   511,   516,   518,   521,   525,   530,   535,   537,   538,\n-   539,   540,   541,   542,   543,   546,   551,   557,   559,   562,\n-   565,   567,   571,   573,   576,   603,   605,   609,   622,   624,\n-   628,   635,   640,   642,   652,   657,   672,   676,   679,   682,\n-   685,   687,   689,   694,   698,   700,   702,   704,   708,   710,\n-   712,   719,   725,   730,   734,   743,   753,   755,   758,   760,\n-   761,   762,   766,   768,   770,   771,   773,   778,   781,   791,\n-   794,   796,   800,   803,   810,   816,   824,   826,   828,   830,\n-   832,   836,   838,   842,   849,   850,   854,   857,   859,   861,\n-   863,   865,   867,   869,   871,   878,   881,   883,   892,   894,\n-   898,   903,   908,   912,   917,   919,   921,   928,   930,   932,\n-   936,   939,   941,   945,   947,   948,   953,   959,   966,   974,\n-   981,   984,   987,   991,   994,   998,  1007,  1009,  1011,  1016,\n-  1023,  1031,  1033,  1037,  1044,  1054,  1058,  1061,  1064,  1067,\n-  1070,  1073,  1076,  1079,  1081,  1085,  1091,  1096,  1098,  1102,\n-  1105,  1109,  1111,  1114,  1116,  1117,  1119,  1123,  1127,  1133,\n-  1138,  1141,  1143,  1147,  1153,  1157,  1162,  1171,  1175,  1180,\n-  1192,  1194,  1197,  1199,  1201,  1205,  1209,  1212,  1216,  1218,\n-  1219,  1220,  1221,  1222,  1232,  1234,  1235,  1236,  1237,  1240,\n-  1242,  1243,  1244,  1245,  1246,  1247,  1248,  1249,  1250,  1251,\n-  1254,  1259,  1270,  1273,  1277,  1284,  1294,  1300,  1306,  1312,\n-  1314,  1320,  1322,  1328,  1330,  1332,  1334,  1336,  1340,  1342,\n-  1343,  1344,  1345,  1346,  1347,  1350,  1356,  1358,  1360,  1364,\n-  1369,  1374,  1380,  1390,  1396,  1398,  1400,  1407,  1410,  1412,\n-  1414,  1418,  1420,  1423,  1427,  1429,  1432,  1439,  1445,  1447,\n-  1449,  1453,  1461,  1464,  1466,  1468,  1472,  1477,  1486,  1491,\n-  1494,  1501,  1503,  1505,  1509,  1512,  1521,  1528,  1530,  1534,\n-  1547,  1549,  1555,  1561,  1565,  1567,  1571,  1574,  1576,  1580,\n-  1583,  1585,  1587,  1591,  1594,  1596,  1598,  1602,  1605,  1607,\n-  1609,  1613,  1619,  1621,  1625,  1632,  1634,  1636,  1638,  1642,\n-  1650,  1653,  1655,  1660,  1664,  1666,  1673,  1681,  1698,  1700,\n-  1702,  1706,  1709,  1714,  1716,  1719,  1721,  1723,  1725,  1726,\n-  1727,  1728,  1732,  1734,  1736,  1741,  1743,  1745,  1747,  1749,\n-  1753,  1756,  1761,  1763,  1768,  1769,  1770,  1771,  1772,  1774,\n-  1776,  1778,  1780,  1782,  1786,  1788,  1791,  1797,  1802,  1806,\n-  1809,  1811,  1813,  1817,  1819,  1821,  1823,  1827,  1830,  1834,\n-  1840,  1842,  1850,  1877,  1879,  1883,  1888,  1895,  1899,  1902,\n-  1904,  1915,  1926,  1931,  1940,  1942,  1946,  1949,  1951,  1956,\n-  1961,  1966,  1973,  1975,  1976,  1977,  1980,  1985,  1990,  1992,\n-  1993,  1995,  1997,  1998,  2000,  2004,  2007,  2011,  2014,  2018,\n-  2020,  2022,  2024,  2025,  2027,  2031,  2040,  2042,  2044,  2057,\n-  2059,  2065,  2067,  2069,  2073,  2075,  2080,  2085,  2090,  2092,\n-  2094,  2098,  2100,  2105,  2110,  2112,  2116,  2118,  2123,  2128,\n-  2133,  2135,  2137,  2141,  2143,  2148,  2153,  2158,  2163,  2165,\n-  2167,  2169,  2171,  2173,  2177,  2179,  2184,  2189,  2191,  2195,\n-  2197,  2202,  2206,  2208,  2213,  2217,  2219,  2224,  2228,  2230,\n-  2235,  2239,  2241,  2246,  2250,  2252,  2257,  2263,  2265,  2269,\n-  2271,  2274,  2277,  2285,  2287,  2288,  2291,  2293,  2296,  2300\n+   454,   460,   462,   463,   464,   465,   466,   470,   472,   475,\n+   477,   478,   481,   483,   486,   490,   494,   498,   504,   506,\n+   508,   510,   515,   517,   520,   524,   529,   534,   536,   537,\n+   538,   539,   540,   541,   542,   545,   550,   556,   558,   561,\n+   564,   566,   570,   572,   575,   602,   604,   608,   621,   623,\n+   627,   634,   639,   641,   651,   656,   671,   675,   678,   681,\n+   684,   686,   688,   693,   697,   699,   701,   703,   707,   709,\n+   711,   718,   724,   729,   733,   742,   752,   754,   757,   759,\n+   760,   761,   765,   767,   769,   770,   772,   777,   780,   790,\n+   793,   795,   799,   802,   809,   815,   823,   825,   827,   829,\n+   831,   835,   837,   841,   848,   849,   853,   856,   858,   860,\n+   862,   864,   866,   868,   870,   877,   880,   882,   891,   893,\n+   897,   902,   907,   911,   916,   918,   920,   927,   929,   931,\n+   935,   938,   940,   944,   946,   947,   952,   958,   965,   973,\n+   980,   983,   986,   990,   993,   997,  1006,  1008,  1010,  1015,\n+  1022,  1030,  1032,  1036,  1043,  1053,  1057,  1060,  1063,  1066,\n+  1069,  1072,  1075,  1078,  1080,  1084,  1090,  1095,  1097,  1101,\n+  1104,  1108,  1110,  1113,  1115,  1116,  1118,  1122,  1126,  1132,\n+  1137,  1140,  1142,  1146,  1152,  1156,  1161,  1170,  1174,  1179,\n+  1191,  1193,  1196,  1198,  1200,  1204,  1208,  1211,  1215,  1217,\n+  1218,  1219,  1220,  1221,  1225,  1227,  1228,  1229,  1230,  1233,\n+  1235,  1236,  1237,  1238,  1239,  1240,  1241,  1242,  1243,  1244,\n+  1247,  1252,  1263,  1266,  1270,  1277,  1287,  1293,  1299,  1305,\n+  1307,  1313,  1315,  1321,  1323,  1325,  1327,  1329,  1333,  1335,\n+  1336,  1337,  1338,  1339,  1340,  1343,  1349,  1351,  1353,  1357,\n+  1362,  1367,  1373,  1383,  1389,  1391,  1393,  1400,  1403,  1405,\n+  1407,  1411,  1413,  1416,  1420,  1422,  1425,  1432,  1438,  1440,\n+  1442,  1446,  1454,  1457,  1459,  1461,  1465,  1470,  1479,  1484,\n+  1487,  1494,  1496,  1498,  1502,  1505,  1514,  1521,  1523,  1527,\n+  1540,  1542,  1548,  1554,  1558,  1560,  1564,  1567,  1569,  1573,\n+  1576,  1578,  1580,  1584,  1587,  1589,  1591,  1595,  1598,  1600,\n+  1602,  1606,  1612,  1614,  1618,  1625,  1627,  1629,  1631,  1635,\n+  1643,  1646,  1648,  1653,  1657,  1659,  1666,  1674,  1691,  1693,\n+  1695,  1699,  1702,  1707,  1709,  1712,  1714,  1716,  1718,  1719,\n+  1720,  1721,  1725,  1727,  1729,  1734,  1736,  1738,  1740,  1742,\n+  1746,  1749,  1754,  1756,  1761,  1762,  1763,  1764,  1765,  1767,\n+  1769,  1771,  1773,  1775,  1779,  1781,  1784,  1790,  1795,  1799,\n+  1802,  1804,  1806,  1810,  1812,  1814,  1816,  1820,  1823,  1827,\n+  1833,  1835,  1843,  1870,  1872,  1876,  1881,  1888,  1892,  1895,\n+  1897,  1908,  1919,  1924,  1933,  1935,  1939,  1942,  1944,  1949,\n+  1954,  1959,  1966,  1968,  1969,  1970,  1973,  1978,  1983,  1985,\n+  1986,  1988,  1990,  1991,  1993,  1997,  2000,  2004,  2007,  2011,\n+  2013,  2015,  2017,  2018,  2020,  2024,  2033,  2035,  2037,  2050,\n+  2052,  2058,  2060,  2062,  2066,  2068,  2073,  2078,  2083,  2085,\n+  2087,  2091,  2093,  2098,  2103,  2105,  2109,  2111,  2116,  2121,\n+  2126,  2128,  2130,  2134,  2136,  2141,  2146,  2151,  2156,  2158,\n+  2160,  2162,  2164,  2166,  2170,  2172,  2177,  2182,  2184,  2188,\n+  2190,  2195,  2199,  2201,  2206,  2210,  2212,  2217,  2221,  2223,\n+  2228,  2232,  2234,  2239,  2243,  2245,  2250,  2256,  2258,  2262,\n+  2264,  2267,  2270,  2278,  2280,  2281,  2284,  2286,  2289,  2293\n };\n #endif\n \n@@ -2725,66 +2724,66 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 457 \"./parse.y\"\n+#line 456 \"./parse.y\"\n {;\n     break;}\n case 18:\n-#line 501 \"./parse.y\"\n+#line 500 \"./parse.y\"\n { \n \t\t  yyval.node = build_java_array_type (yyvsp[-2].node, -1);\n \t\t  CLASS_LOADED_P (yyval.node) = 1;\n \t\t;\n     break;}\n case 19:\n-#line 506 \"./parse.y\"\n+#line 505 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 20:\n-#line 508 \"./parse.y\"\n+#line 507 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 21:\n-#line 510 \"./parse.y\"\n+#line 509 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 22:\n-#line 512 \"./parse.y\"\n+#line 511 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 26:\n-#line 527 \"./parse.y\"\n+#line 526 \"./parse.y\"\n { yyval.node = make_qualified_name (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 28:\n-#line 536 \"./parse.y\"\n+#line 535 \"./parse.y\"\n {yyval.node = NULL;;\n     break;}\n case 36:\n-#line 548 \"./parse.y\"\n+#line 547 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 37:\n-#line 552 \"./parse.y\"\n+#line 551 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 40:\n-#line 564 \"./parse.y\"\n+#line 563 \"./parse.y\"\n { ctxp->package = EXPR_WFL_NODE (yyvsp[-1].node); ;\n     break;}\n case 41:\n-#line 566 \"./parse.y\"\n+#line 565 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 42:\n-#line 568 \"./parse.y\"\n+#line 567 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 45:\n-#line 578 \"./parse.y\"\n+#line 577 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-1].node), node, last_name;\n \t\t  int   i = IDENTIFIER_LENGTH (name)-1;\n@@ -2812,15 +2811,15 @@ case 45:\n \t\t;\n     break;}\n case 46:\n-#line 604 \"./parse.y\"\n+#line 603 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 47:\n-#line 606 \"./parse.y\"\n+#line 605 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 48:\n-#line 611 \"./parse.y\"\n+#line 610 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-3].node);\n \t\t  /* Don't import java.lang.* twice. */\n@@ -2834,47 +2833,47 @@ case 48:\n \t\t;\n     break;}\n case 49:\n-#line 623 \"./parse.y\"\n+#line 622 \"./parse.y\"\n {yyerror (\"'*' expected\"); RECOVER;;\n     break;}\n case 50:\n-#line 625 \"./parse.y\"\n+#line 624 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 51:\n-#line 630 \"./parse.y\"\n+#line 629 \"./parse.y\"\n {\n \t\t  maybe_generate_finit ();\n \t\t  maybe_generate_clinit ();\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 52:\n-#line 636 \"./parse.y\"\n+#line 635 \"./parse.y\"\n {\n \t\t  maybe_generate_clinit ();\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 53:\n-#line 641 \"./parse.y\"\n+#line 640 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 54:\n-#line 643 \"./parse.y\"\n+#line 642 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Class or interface declaration expected\");\n \t\t;\n     break;}\n case 55:\n-#line 654 \"./parse.y\"\n+#line 653 \"./parse.y\"\n {\n \t\t  yyval.value = (1 << yyvsp[0].value);\n \t\t;\n     break;}\n case 56:\n-#line 658 \"./parse.y\"\n+#line 657 \"./parse.y\"\n {\n \t\t  int acc = (1 << yyvsp[0].value);\n \t\t  if (yyval.value & acc)\n@@ -2888,95 +2887,95 @@ case 56:\n \t\t;\n     break;}\n case 57:\n-#line 674 \"./parse.y\"\n+#line 673 \"./parse.y\"\n { create_class (yyvsp[-4].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 58:\n-#line 676 \"./parse.y\"\n+#line 675 \"./parse.y\"\n { \n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 59:\n-#line 680 \"./parse.y\"\n+#line 679 \"./parse.y\"\n { create_class (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 60:\n-#line 682 \"./parse.y\"\n+#line 681 \"./parse.y\"\n { \t\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 61:\n-#line 686 \"./parse.y\"\n+#line 685 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 62:\n-#line 688 \"./parse.y\"\n+#line 687 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 63:\n-#line 690 \"./parse.y\"\n+#line 689 \"./parse.y\"\n {\n \t\t  if (!ctxp->class_err) yyerror (\"'{' expected\"); \n \t\t  DRECOVER(class1);\n \t\t;\n     break;}\n case 64:\n-#line 695 \"./parse.y\"\n+#line 694 \"./parse.y\"\n {if (!ctxp->class_err) yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 65:\n-#line 699 \"./parse.y\"\n+#line 698 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 66:\n-#line 701 \"./parse.y\"\n+#line 700 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 67:\n-#line 703 \"./parse.y\"\n+#line 702 \"./parse.y\"\n {yyerror (\"'{' expected\"); ctxp->class_err=1;;\n     break;}\n case 68:\n-#line 705 \"./parse.y\"\n+#line 704 \"./parse.y\"\n {yyerror (\"Missing super class name\"); ctxp->class_err=1;;\n     break;}\n case 69:\n-#line 709 \"./parse.y\"\n+#line 708 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 70:\n-#line 711 \"./parse.y\"\n+#line 710 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 71:\n-#line 713 \"./parse.y\"\n+#line 712 \"./parse.y\"\n {\n \t\t  ctxp->class_err=1;\n \t\t  yyerror (\"Missing interface name\"); \n \t\t;\n     break;}\n case 72:\n-#line 721 \"./parse.y\"\n+#line 720 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 73:\n-#line 726 \"./parse.y\"\n+#line 725 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 74:\n-#line 731 \"./parse.y\"\n+#line 730 \"./parse.y\"\n {yyerror (\"Missing interface name\"); RECOVER;;\n     break;}\n case 75:\n-#line 736 \"./parse.y\"\n+#line 735 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (flag_emit_xref)\n@@ -2986,7 +2985,7 @@ case 75:\n \t\t;\n     break;}\n case 76:\n-#line 744 \"./parse.y\"\n+#line 743 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (flag_emit_xref)\n@@ -2996,27 +2995,27 @@ case 76:\n \t\t;\n     break;}\n case 82:\n-#line 763 \"./parse.y\"\n+#line 762 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"instance initializer\"); ;\n     break;}\n case 84:\n-#line 769 \"./parse.y\"\n+#line 768 \"./parse.y\"\n { yyval.node = yyvsp[-1].node; ;\n     break;}\n case 86:\n-#line 772 \"./parse.y\"\n+#line 771 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner classe declaration\"); ;\n     break;}\n case 87:\n-#line 774 \"./parse.y\"\n+#line 773 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 88:\n-#line 780 \"./parse.y\"\n+#line 779 \"./parse.y\"\n { register_fields (0, yyvsp[-2].node, yyvsp[-1].node); ;\n     break;}\n case 89:\n-#line 782 \"./parse.y\"\n+#line 781 \"./parse.y\"\n {\n \t\t  check_modifiers \n \t\t    (\"Illegal modifier `%s' for field declaration\",\n@@ -3026,19 +3025,19 @@ case 89:\n \t\t;\n     break;}\n case 91:\n-#line 795 \"./parse.y\"\n+#line 794 \"./parse.y\"\n { yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 92:\n-#line 797 \"./parse.y\"\n+#line 796 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 93:\n-#line 802 \"./parse.y\"\n+#line 801 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 94:\n-#line 804 \"./parse.y\"\n+#line 803 \"./parse.y\"\n { \n \t\t  if (java_error_count)\n \t\t    yyvsp[0].node = NULL_TREE;\n@@ -3047,101 +3046,101 @@ case 94:\n \t\t;\n     break;}\n case 95:\n-#line 811 \"./parse.y\"\n+#line 810 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing variable initializer\");\n \t\t  yyval.node = build_tree_list (yyvsp[-2].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 96:\n-#line 817 \"./parse.y\"\n+#line 816 \"./parse.y\"\n {\n \t\t  yyerror (\"';' expected\");\n \t\t  yyval.node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 98:\n-#line 827 \"./parse.y\"\n+#line 826 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 99:\n-#line 829 \"./parse.y\"\n+#line 828 \"./parse.y\"\n {yyerror (\"Invalid declaration\"); DRECOVER(vdi);;\n     break;}\n case 100:\n-#line 831 \"./parse.y\"\n+#line 830 \"./parse.y\"\n {yyerror (\"']' expected\"); DRECOVER(vdi);;\n     break;}\n case 101:\n-#line 833 \"./parse.y\"\n+#line 832 \"./parse.y\"\n {yyerror (\"Unbalanced ']'\"); DRECOVER(vdi);;\n     break;}\n case 104:\n-#line 844 \"./parse.y\"\n+#line 843 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 105:\n-#line 849 \"./parse.y\"\n+#line 848 \"./parse.y\"\n { finish_method_declaration (yyvsp[0].node); ;\n     break;}\n case 106:\n-#line 851 \"./parse.y\"\n+#line 850 \"./parse.y\"\n {YYNOT_TWICE yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 107:\n-#line 856 \"./parse.y\"\n+#line 855 \"./parse.y\"\n { yyval.node = method_header (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 108:\n-#line 858 \"./parse.y\"\n+#line 857 \"./parse.y\"\n { yyval.node = method_header (0, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 109:\n-#line 860 \"./parse.y\"\n+#line 859 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 110:\n-#line 862 \"./parse.y\"\n+#line 861 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 111:\n-#line 864 \"./parse.y\"\n+#line 863 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 112:\n-#line 866 \"./parse.y\"\n+#line 865 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 113:\n-#line 868 \"./parse.y\"\n+#line 867 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 114:\n-#line 870 \"./parse.y\"\n+#line 869 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 115:\n-#line 872 \"./parse.y\"\n+#line 871 \"./parse.y\"\n {\n \t\t  yyerror (\"Invalid method declaration, return type required\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 116:\n-#line 880 \"./parse.y\"\n+#line 879 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 117:\n-#line 882 \"./parse.y\"\n+#line 881 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 118:\n-#line 884 \"./parse.y\"\n+#line 883 \"./parse.y\"\n {\n \t\t  EXPR_WFL_LINECOL (wfl_operator) = yyvsp[-1].operator.location;\n \t\t  TREE_PURPOSE (yyvsp[-2].node) = \n@@ -3152,313 +3151,313 @@ case 118:\n \t\t;\n     break;}\n case 119:\n-#line 893 \"./parse.y\"\n+#line 892 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER(method_declarator);;\n     break;}\n case 120:\n-#line 895 \"./parse.y\"\n+#line 894 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 121:\n-#line 900 \"./parse.y\"\n+#line 899 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number = 1;\n \t\t;\n     break;}\n case 122:\n-#line 904 \"./parse.y\"\n+#line 903 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 123:\n-#line 909 \"./parse.y\"\n+#line 908 \"./parse.y\"\n {yyerror (\"Missing formal parameter term\"); RECOVER;;\n     break;}\n case 124:\n-#line 914 \"./parse.y\"\n+#line 913 \"./parse.y\"\n {\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);\n \t\t;\n     break;}\n case 125:\n-#line 918 \"./parse.y\"\n+#line 917 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"final parameters\"); ;\n     break;}\n case 126:\n-#line 920 \"./parse.y\"\n+#line 919 \"./parse.y\"\n {yyerror (\"Missing identifier\"); RECOVER;;\n     break;}\n case 127:\n-#line 922 \"./parse.y\"\n+#line 921 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[-2].value));\n \t\t  yyerror (\"Missing identifier\"); RECOVER;\n \t\t;\n     break;}\n case 128:\n-#line 929 \"./parse.y\"\n+#line 928 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 129:\n-#line 931 \"./parse.y\"\n+#line 930 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 130:\n-#line 933 \"./parse.y\"\n+#line 932 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 131:\n-#line 938 \"./parse.y\"\n+#line 937 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, yyvsp[0].node); ;\n     break;}\n case 132:\n-#line 940 \"./parse.y\"\n+#line 939 \"./parse.y\"\n { yyval.node = tree_cons (yyvsp[0].node, yyvsp[0].node, yyvsp[-2].node); ;\n     break;}\n case 133:\n-#line 942 \"./parse.y\"\n+#line 941 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 136:\n-#line 949 \"./parse.y\"\n+#line 948 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 137:\n-#line 955 \"./parse.y\"\n+#line 954 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[0].node) = ctxp->static_initialized;\n \t\t  ctxp->static_initialized = yyvsp[0].node;\n \t\t;\n     break;}\n case 138:\n-#line 960 \"./parse.y\"\n+#line 959 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[-1].node) = ctxp->static_initialized;\n \t\t  ctxp->static_initialized = yyvsp[-1].node;\n \t\t;\n     break;}\n case 139:\n-#line 968 \"./parse.y\"\n+#line 967 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[0].value));\n \t\t;\n     break;}\n case 140:\n-#line 976 \"./parse.y\"\n+#line 975 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 141:\n-#line 981 \"./parse.y\"\n+#line 980 \"./parse.y\"\n { finish_method_declaration (yyvsp[0].node); ;\n     break;}\n case 142:\n-#line 986 \"./parse.y\"\n+#line 985 \"./parse.y\"\n { yyval.node = method_header (0, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 143:\n-#line 988 \"./parse.y\"\n+#line 987 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-2].value, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 144:\n-#line 993 \"./parse.y\"\n+#line 992 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 145:\n-#line 995 \"./parse.y\"\n+#line 994 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 146:\n-#line 1003 \"./parse.y\"\n+#line 1002 \"./parse.y\"\n { \n \t\t  BLOCK_EXPR_BODY (yyvsp[0].node) = empty_stmt_node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 147:\n-#line 1008 \"./parse.y\"\n+#line 1007 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 148:\n-#line 1010 \"./parse.y\"\n+#line 1009 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 149:\n-#line 1012 \"./parse.y\"\n+#line 1011 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 150:\n-#line 1018 \"./parse.y\"\n+#line 1017 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-3].node, NULL_TREE); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-3].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 151:\n-#line 1024 \"./parse.y\"\n+#line 1023 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-4].node, yyvsp[-2].node); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-4].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 152:\n-#line 1032 \"./parse.y\"\n+#line 1031 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 153:\n-#line 1034 \"./parse.y\"\n+#line 1033 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 154:\n-#line 1039 \"./parse.y\"\n+#line 1038 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (this_identifier_node);\n \t\t  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;\n \t\t  yyval.node = wfl;\n \t\t;\n     break;}\n case 155:\n-#line 1045 \"./parse.y\"\n+#line 1044 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (super_identifier_node);\n \t\t  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;\n \t\t  yyval.node = wfl;\n \t\t;\n     break;}\n case 156:\n-#line 1056 \"./parse.y\"\n+#line 1055 \"./parse.y\"\n { create_interface (0, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 157:\n-#line 1058 \"./parse.y\"\n+#line 1057 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 158:\n-#line 1062 \"./parse.y\"\n+#line 1061 \"./parse.y\"\n { create_interface (yyvsp[-2].value, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 159:\n-#line 1064 \"./parse.y\"\n+#line 1063 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 160:\n-#line 1068 \"./parse.y\"\n+#line 1067 \"./parse.y\"\n { create_interface (0, yyvsp[-1].node, yyvsp[0].node);\t;\n     break;}\n case 161:\n-#line 1070 \"./parse.y\"\n+#line 1069 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 162:\n-#line 1074 \"./parse.y\"\n+#line 1073 \"./parse.y\"\n { create_interface (yyvsp[-3].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 163:\n-#line 1076 \"./parse.y\"\n+#line 1075 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 164:\n-#line 1080 \"./parse.y\"\n+#line 1079 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 165:\n-#line 1082 \"./parse.y\"\n+#line 1081 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 166:\n-#line 1087 \"./parse.y\"\n+#line 1086 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 167:\n-#line 1092 \"./parse.y\"\n+#line 1091 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 168:\n-#line 1097 \"./parse.y\"\n+#line 1096 \"./parse.y\"\n {yyerror (\"Invalid interface type\"); RECOVER;;\n     break;}\n case 169:\n-#line 1099 \"./parse.y\"\n+#line 1098 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 170:\n-#line 1104 \"./parse.y\"\n+#line 1103 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 171:\n-#line 1106 \"./parse.y\"\n+#line 1105 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 176:\n-#line 1118 \"./parse.y\"\n+#line 1117 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 177:\n-#line 1120 \"./parse.y\"\n+#line 1119 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 179:\n-#line 1129 \"./parse.y\"\n+#line 1128 \"./parse.y\"\n { \n \t\t  check_abstract_method_header (yyvsp[-1].node);\n \t\t  current_function_decl = NULL_TREE; /* FIXME ? */\n \t\t;\n     break;}\n case 180:\n-#line 1134 \"./parse.y\"\n+#line 1133 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 181:\n-#line 1140 \"./parse.y\"\n+#line 1139 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 182:\n-#line 1142 \"./parse.y\"\n+#line 1141 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 183:\n-#line 1144 \"./parse.y\"\n+#line 1143 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-3].operator.location, yyvsp[-2].node); ;\n     break;}\n case 184:\n-#line 1149 \"./parse.y\"\n+#line 1148 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), \n \t\t\t\t  yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 185:\n-#line 1154 \"./parse.y\"\n+#line 1153 \"./parse.y\"\n {\n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 186:\n-#line 1158 \"./parse.y\"\n+#line 1157 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 187:\n-#line 1164 \"./parse.y\"\n+#line 1163 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (current_function_decl && flag_emit_xref)\n@@ -3468,15 +3467,15 @@ case 187:\n \t\t;\n     break;}\n case 188:\n-#line 1172 \"./parse.y\"\n+#line 1171 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 189:\n-#line 1177 \"./parse.y\"\n+#line 1176 \"./parse.y\"\n { enter_block (); ;\n     break;}\n case 190:\n-#line 1182 \"./parse.y\"\n+#line 1181 \"./parse.y\"\n { \n \t\t  maybe_absorb_scoping_blocks ();\n \t\t  /* Store the location of the `}' when doing xrefs */\n@@ -3487,37 +3486,31 @@ case 190:\n \t\t;\n     break;}\n case 194:\n-#line 1200 \"./parse.y\"\n+#line 1199 \"./parse.y\"\n { java_method_add_stmt (current_function_decl, yyvsp[0].node); ;\n     break;}\n case 195:\n-#line 1202 \"./parse.y\"\n+#line 1201 \"./parse.y\"\n { parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 197:\n-#line 1211 \"./parse.y\"\n+#line 1210 \"./parse.y\"\n { declare_local_variables (0, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 198:\n-#line 1213 \"./parse.y\"\n+#line 1212 \"./parse.y\"\n { declare_local_variables (yyvsp[-2].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 204:\n-#line 1223 \"./parse.y\"\n-{ \n-\t\t  /* If the for loop is unlabeled, we must return the\n-\t\t     block it was defined it. It our last chance to\n-\t\t     get a hold on it. */\n-\t\t  if (!LOOP_HAS_LABEL_P (yyval.node))\n-\t\t    yyval.node = exit_block ();\n-\t\t;\n+#line 1222 \"./parse.y\"\n+{ yyval.node = exit_block (); ;\n     break;}\n case 221:\n-#line 1256 \"./parse.y\"\n+#line 1249 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 222:\n-#line 1261 \"./parse.y\"\n+#line 1254 \"./parse.y\"\n {\n \t\t  yyval.node = build_labeled_block (EXPR_WFL_LINECOL (yyvsp[-1].node), \n \t\t\t\t\t    EXPR_WFL_NODE (yyvsp[-1].node));\n@@ -3527,19 +3520,19 @@ case 222:\n \t\t;\n     break;}\n case 223:\n-#line 1272 \"./parse.y\"\n+#line 1265 \"./parse.y\"\n { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 224:\n-#line 1274 \"./parse.y\"\n+#line 1267 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 225:\n-#line 1279 \"./parse.y\"\n+#line 1272 \"./parse.y\"\n { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 226:\n-#line 1286 \"./parse.y\"\n+#line 1279 \"./parse.y\"\n {\n \t\t  /* We have a statement. Generate a WFL around it so\n \t\t     we can debug it */\n@@ -3550,108 +3543,108 @@ case 226:\n \t\t;\n     break;}\n case 227:\n-#line 1295 \"./parse.y\"\n+#line 1288 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 228:\n-#line 1301 \"./parse.y\"\n+#line 1294 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 229:\n-#line 1307 \"./parse.y\"\n+#line 1300 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 230:\n-#line 1313 \"./parse.y\"\n+#line 1306 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 231:\n-#line 1315 \"./parse.y\"\n+#line 1308 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 232:\n-#line 1321 \"./parse.y\"\n+#line 1314 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 233:\n-#line 1323 \"./parse.y\"\n+#line 1316 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 234:\n-#line 1329 \"./parse.y\"\n+#line 1322 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 235:\n-#line 1331 \"./parse.y\"\n+#line 1324 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 236:\n-#line 1333 \"./parse.y\"\n+#line 1326 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 237:\n-#line 1335 \"./parse.y\"\n+#line 1328 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 238:\n-#line 1337 \"./parse.y\"\n+#line 1330 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 246:\n-#line 1352 \"./parse.y\"\n+#line 1345 \"./parse.y\"\n { \n \t\t  yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, \n \t\t\t\t\t\tyyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 247:\n-#line 1357 \"./parse.y\"\n+#line 1350 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 248:\n-#line 1359 \"./parse.y\"\n+#line 1352 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 249:\n-#line 1361 \"./parse.y\"\n+#line 1354 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 250:\n-#line 1366 \"./parse.y\"\n+#line 1359 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 251:\n-#line 1371 \"./parse.y\"\n+#line 1364 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 252:\n-#line 1376 \"./parse.y\"\n+#line 1369 \"./parse.y\"\n {\n \t\t  enter_block ();\n \t\t;\n     break;}\n case 253:\n-#line 1380 \"./parse.y\"\n+#line 1373 \"./parse.y\"\n { \n \t\t  /* Make into \"proper list\" of COMPOUND_EXPRs.\n \t\t     I.e. make the last statment also have its own\n@@ -3662,112 +3655,112 @@ case 253:\n \t\t;\n     break;}\n case 254:\n-#line 1392 \"./parse.y\"\n+#line 1385 \"./parse.y\"\n { \n \t\t  yyval.node = build (SWITCH_EXPR, NULL_TREE, yyvsp[-1].node, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 255:\n-#line 1397 \"./parse.y\"\n+#line 1390 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 256:\n-#line 1399 \"./parse.y\"\n+#line 1392 \"./parse.y\"\n {yyerror (\"Missing term or ')'\"); DRECOVER(switch_statement);;\n     break;}\n case 257:\n-#line 1401 \"./parse.y\"\n+#line 1394 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 258:\n-#line 1409 \"./parse.y\"\n+#line 1402 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 259:\n-#line 1411 \"./parse.y\"\n+#line 1404 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 260:\n-#line 1413 \"./parse.y\"\n+#line 1406 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 261:\n-#line 1415 \"./parse.y\"\n+#line 1408 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 267:\n-#line 1434 \"./parse.y\"\n+#line 1427 \"./parse.y\"\n { \n \t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-2].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 268:\n-#line 1440 \"./parse.y\"\n+#line 1433 \"./parse.y\"\n { \n \t\t  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-1].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 269:\n-#line 1446 \"./parse.y\"\n+#line 1439 \"./parse.y\"\n {yyerror (\"Missing or invalid constant expression\"); RECOVER;;\n     break;}\n case 270:\n-#line 1448 \"./parse.y\"\n+#line 1441 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 271:\n-#line 1450 \"./parse.y\"\n+#line 1443 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 272:\n-#line 1455 \"./parse.y\"\n+#line 1448 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 273:\n-#line 1463 \"./parse.y\"\n+#line 1456 \"./parse.y\"\n { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 274:\n-#line 1465 \"./parse.y\"\n+#line 1458 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 275:\n-#line 1467 \"./parse.y\"\n+#line 1460 \"./parse.y\"\n {yyerror (\"Missing term and ')' expected\"); RECOVER;;\n     break;}\n case 276:\n-#line 1469 \"./parse.y\"\n+#line 1462 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 277:\n-#line 1474 \"./parse.y\"\n+#line 1467 \"./parse.y\"\n { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 278:\n-#line 1479 \"./parse.y\"\n+#line 1472 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (0, NULL_TREE, 1);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 279:\n-#line 1488 \"./parse.y\"\n+#line 1481 \"./parse.y\"\n { yyval.node = finish_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;\n     break;}\n case 280:\n-#line 1493 \"./parse.y\"\n+#line 1486 \"./parse.y\"\n { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 281:\n-#line 1495 \"./parse.y\"\n+#line 1488 \"./parse.y\"\n { \n \t\t  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3776,23 +3769,23 @@ case 281:\n \t\t;\n     break;}\n case 282:\n-#line 1502 \"./parse.y\"\n+#line 1495 \"./parse.y\"\n {yyerror (\"Invalid control expression\"); RECOVER;;\n     break;}\n case 283:\n-#line 1504 \"./parse.y\"\n+#line 1497 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 284:\n-#line 1506 \"./parse.y\"\n+#line 1499 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 285:\n-#line 1511 \"./parse.y\"\n+#line 1504 \"./parse.y\"\n { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 286:\n-#line 1513 \"./parse.y\"\n+#line 1506 \"./parse.y\"\n { \n \t\t  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3801,23 +3794,23 @@ case 286:\n \t\t;\n     break;}\n case 287:\n-#line 1523 \"./parse.y\"\n+#line 1516 \"./parse.y\"\n { \n \t\t  /* This scope defined for local variable that may be\n                      defined within the scope of the for loop */\n \t\t  enter_block (); \n \t\t;\n     break;}\n case 288:\n-#line 1529 \"./parse.y\"\n+#line 1522 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(for_1);;\n     break;}\n case 289:\n-#line 1531 \"./parse.y\"\n+#line 1524 \"./parse.y\"\n {yyerror (\"Invalid init statement\"); RECOVER;;\n     break;}\n case 290:\n-#line 1536 \"./parse.y\"\n+#line 1529 \"./parse.y\"\n { \n \t\t  /* We now declare the loop body. The loop is\n                      declared as a for loop. */\n@@ -3830,179 +3823,179 @@ case 290:\n \t\t;\n     break;}\n case 291:\n-#line 1548 \"./parse.y\"\n+#line 1541 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 292:\n-#line 1550 \"./parse.y\"\n+#line 1543 \"./parse.y\"\n { \n \t\t  /* Init statement recorded within the previously\n                      defined block scope */\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t;\n     break;}\n case 293:\n-#line 1556 \"./parse.y\"\n+#line 1549 \"./parse.y\"\n { \n \t\t  /* Local variable are recorded within the previously\n \t\t     defined block scope */\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 294:\n-#line 1562 \"./parse.y\"\n+#line 1555 \"./parse.y\"\n {yyerror (\"';' expected\"); DRECOVER(for_init_1);;\n     break;}\n case 295:\n-#line 1566 \"./parse.y\"\n+#line 1559 \"./parse.y\"\n {yyval.node = empty_stmt_node;;\n     break;}\n case 296:\n-#line 1568 \"./parse.y\"\n+#line 1561 \"./parse.y\"\n { yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;\n     break;}\n case 297:\n-#line 1573 \"./parse.y\"\n+#line 1566 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 298:\n-#line 1575 \"./parse.y\"\n+#line 1568 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 299:\n-#line 1577 \"./parse.y\"\n+#line 1570 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 300:\n-#line 1582 \"./parse.y\"\n+#line 1575 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;\n     break;}\n case 301:\n-#line 1584 \"./parse.y\"\n+#line 1577 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;\n     break;}\n case 302:\n-#line 1586 \"./parse.y\"\n+#line 1579 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 303:\n-#line 1588 \"./parse.y\"\n+#line 1581 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 304:\n-#line 1593 \"./parse.y\"\n+#line 1586 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;\n     break;}\n case 305:\n-#line 1595 \"./parse.y\"\n+#line 1588 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;\n     break;}\n case 306:\n-#line 1597 \"./parse.y\"\n+#line 1590 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 307:\n-#line 1599 \"./parse.y\"\n+#line 1592 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 308:\n-#line 1604 \"./parse.y\"\n+#line 1597 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 309:\n-#line 1606 \"./parse.y\"\n+#line 1599 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 310:\n-#line 1608 \"./parse.y\"\n+#line 1601 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 311:\n-#line 1610 \"./parse.y\"\n+#line 1603 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 312:\n-#line 1615 \"./parse.y\"\n+#line 1608 \"./parse.y\"\n { \n \t\t  yyval.node = build1 (THROW_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 313:\n-#line 1620 \"./parse.y\"\n+#line 1613 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 314:\n-#line 1622 \"./parse.y\"\n+#line 1615 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 315:\n-#line 1627 \"./parse.y\"\n+#line 1620 \"./parse.y\"\n { \n \t\t  yyval.node = build (SYNCHRONIZED_EXPR, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = \n \t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n \t\t;\n     break;}\n case 316:\n-#line 1633 \"./parse.y\"\n+#line 1626 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 317:\n-#line 1635 \"./parse.y\"\n+#line 1628 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 318:\n-#line 1637 \"./parse.y\"\n+#line 1630 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 319:\n-#line 1639 \"./parse.y\"\n+#line 1632 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 320:\n-#line 1644 \"./parse.y\"\n+#line 1637 \"./parse.y\"\n {\n \t\t  if ((1 << yyvsp[0].value) != ACC_SYNCHRONIZED)\n \t\t    fatal (\"synchronized was '%d' - yyparse\", (1 << yyvsp[0].value));\n \t\t;\n     break;}\n case 321:\n-#line 1652 \"./parse.y\"\n+#line 1645 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 322:\n-#line 1654 \"./parse.y\"\n+#line 1647 \"./parse.y\"\n { yyval.node = build_try_finally_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 323:\n-#line 1656 \"./parse.y\"\n+#line 1649 \"./parse.y\"\n { yyval.node = build_try_finally_statement \n \t\t    (yyvsp[-3].operator.location, build_try_statement (yyvsp[-3].operator.location,\n \t\t\t\t\t\t       yyvsp[-2].node, yyvsp[-1].node), yyvsp[0].node);\n \t\t;\n     break;}\n case 324:\n-#line 1661 \"./parse.y\"\n+#line 1654 \"./parse.y\"\n {yyerror (\"'{' expected\"); DRECOVER (try_statement);;\n     break;}\n case 326:\n-#line 1667 \"./parse.y\"\n+#line 1660 \"./parse.y\"\n { \n \t\t  TREE_CHAIN (yyvsp[0].node) = yyvsp[-1].node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 327:\n-#line 1675 \"./parse.y\"\n+#line 1668 \"./parse.y\"\n { \n \t\t  java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t  exit_block ();\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 328:\n-#line 1683 \"./parse.y\"\n+#line 1676 \"./parse.y\"\n { \n \t\t  /* We add a block to define a scope for\n \t\t     formal_parameter (CCBP). The formal parameter is\n@@ -4020,184 +4013,184 @@ case 328:\n \t\t;\n     break;}\n case 329:\n-#line 1699 \"./parse.y\"\n+#line 1692 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 330:\n-#line 1701 \"./parse.y\"\n+#line 1694 \"./parse.y\"\n {yyerror (\"Missing term or ')' expected\"); DRECOVER (2);;\n     break;}\n case 331:\n-#line 1703 \"./parse.y\"\n+#line 1696 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER (1);;\n     break;}\n case 332:\n-#line 1708 \"./parse.y\"\n+#line 1701 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 333:\n-#line 1710 \"./parse.y\"\n+#line 1703 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER; ;\n     break;}\n case 337:\n-#line 1722 \"./parse.y\"\n+#line 1715 \"./parse.y\"\n { yyval.node = build_this (yyvsp[0].operator.location); ;\n     break;}\n case 338:\n-#line 1724 \"./parse.y\"\n+#line 1717 \"./parse.y\"\n {yyval.node = yyvsp[-1].node;;\n     break;}\n case 343:\n-#line 1733 \"./parse.y\"\n+#line 1726 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"named class literals\"); ;\n     break;}\n case 344:\n-#line 1735 \"./parse.y\"\n+#line 1728 \"./parse.y\"\n { yyval.node = build_class_ref (yyvsp[-2].node); ;\n     break;}\n case 345:\n-#line 1737 \"./parse.y\"\n+#line 1730 \"./parse.y\"\n { yyval.node = build_class_ref (void_type_node); ;\n     break;}\n case 346:\n-#line 1742 \"./parse.y\"\n+#line 1735 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n     break;}\n case 347:\n-#line 1744 \"./parse.y\"\n+#line 1737 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 348:\n-#line 1746 \"./parse.y\"\n+#line 1739 \"./parse.y\"\n {yyerror (\"'class' or 'this' expected\" ); RECOVER;;\n     break;}\n case 349:\n-#line 1748 \"./parse.y\"\n+#line 1741 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 350:\n-#line 1750 \"./parse.y\"\n+#line 1743 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 351:\n-#line 1755 \"./parse.y\"\n+#line 1748 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 352:\n-#line 1757 \"./parse.y\"\n+#line 1750 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 353:\n-#line 1762 \"./parse.y\"\n+#line 1755 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 354:\n-#line 1764 \"./parse.y\"\n+#line 1757 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 359:\n-#line 1773 \"./parse.y\"\n+#line 1766 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(new_1);;\n     break;}\n case 360:\n-#line 1775 \"./parse.y\"\n+#line 1768 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 361:\n-#line 1777 \"./parse.y\"\n+#line 1770 \"./parse.y\"\n {yyerror (\"')' or term expected\"); RECOVER;;\n     break;}\n case 362:\n-#line 1779 \"./parse.y\"\n+#line 1772 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 363:\n-#line 1781 \"./parse.y\"\n+#line 1774 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 364:\n-#line 1783 \"./parse.y\"\n+#line 1776 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 367:\n-#line 1793 \"./parse.y\"\n+#line 1786 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);\n \t\t  ctxp->formal_parameter_number = 1; \n \t\t;\n     break;}\n case 368:\n-#line 1798 \"./parse.y\"\n+#line 1791 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 369:\n-#line 1803 \"./parse.y\"\n+#line 1796 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 370:\n-#line 1808 \"./parse.y\"\n+#line 1801 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 371:\n-#line 1810 \"./parse.y\"\n+#line 1803 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 372:\n-#line 1812 \"./parse.y\"\n+#line 1805 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 373:\n-#line 1814 \"./parse.y\"\n+#line 1807 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 374:\n-#line 1818 \"./parse.y\"\n+#line 1811 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 375:\n-#line 1820 \"./parse.y\"\n+#line 1813 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 376:\n-#line 1822 \"./parse.y\"\n+#line 1815 \"./parse.y\"\n {yyerror (\"'[' expected\"); DRECOVER (\"]\");;\n     break;}\n case 377:\n-#line 1824 \"./parse.y\"\n+#line 1817 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 378:\n-#line 1829 \"./parse.y\"\n+#line 1822 \"./parse.y\"\n { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 379:\n-#line 1831 \"./parse.y\"\n+#line 1824 \"./parse.y\"\n { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;\n     break;}\n case 380:\n-#line 1836 \"./parse.y\"\n+#line 1829 \"./parse.y\"\n { \n \t\t  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 381:\n-#line 1841 \"./parse.y\"\n+#line 1834 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 382:\n-#line 1843 \"./parse.y\"\n+#line 1836 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term\");\n \t\t  yyerror (\"']' expected\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 383:\n-#line 1852 \"./parse.y\"\n+#line 1845 \"./parse.y\"\n { \n \t\t  int allocate = 0;\n \t\t  /* If not initialized, allocate memory for the osb\n@@ -4225,19 +4218,19 @@ case 383:\n \t\t;\n     break;}\n case 384:\n-#line 1878 \"./parse.y\"\n+#line 1871 \"./parse.y\"\n { CURRENT_OSB (ctxp)++; ;\n     break;}\n case 385:\n-#line 1880 \"./parse.y\"\n+#line 1873 \"./parse.y\"\n { yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 386:\n-#line 1885 \"./parse.y\"\n+#line 1878 \"./parse.y\"\n { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 387:\n-#line 1889 \"./parse.y\"\n+#line 1882 \"./parse.y\"\n {\n \t\t  tree super_wfl = \n \t\t    build_wfl_node (super_identifier_node);\n@@ -4246,19 +4239,19 @@ case 387:\n \t\t;\n     break;}\n case 388:\n-#line 1896 \"./parse.y\"\n+#line 1889 \"./parse.y\"\n {yyerror (\"Field expected\"); DRECOVER (super_field_acces);;\n     break;}\n case 389:\n-#line 1901 \"./parse.y\"\n+#line 1894 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 390:\n-#line 1903 \"./parse.y\"\n+#line 1896 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 391:\n-#line 1905 \"./parse.y\"\n+#line 1898 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4271,7 +4264,7 @@ case 391:\n \t\t;\n     break;}\n case 392:\n-#line 1916 \"./parse.y\"\n+#line 1909 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4284,121 +4277,121 @@ case 392:\n \t\t;\n     break;}\n case 393:\n-#line 1927 \"./parse.y\"\n+#line 1920 \"./parse.y\"\n { \n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);\n \t\t;\n     break;}\n case 394:\n-#line 1932 \"./parse.y\"\n+#line 1925 \"./parse.y\"\n {\n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);\n \t\t;\n     break;}\n case 395:\n-#line 1941 \"./parse.y\"\n+#line 1934 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 396:\n-#line 1943 \"./parse.y\"\n+#line 1936 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 397:\n-#line 1948 \"./parse.y\"\n+#line 1941 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 398:\n-#line 1950 \"./parse.y\"\n+#line 1943 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 399:\n-#line 1952 \"./parse.y\"\n+#line 1945 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 400:\n-#line 1957 \"./parse.y\"\n+#line 1950 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 401:\n-#line 1962 \"./parse.y\"\n+#line 1955 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 402:\n-#line 1967 \"./parse.y\"\n+#line 1960 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 407:\n-#line 1982 \"./parse.y\"\n+#line 1975 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 408:\n-#line 1987 \"./parse.y\"\n+#line 1980 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 411:\n-#line 1994 \"./parse.y\"\n+#line 1987 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 412:\n-#line 1996 \"./parse.y\"\n+#line 1989 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 414:\n-#line 1999 \"./parse.y\"\n+#line 1992 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 415:\n-#line 2001 \"./parse.y\"\n+#line 1994 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 416:\n-#line 2006 \"./parse.y\"\n+#line 1999 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 417:\n-#line 2008 \"./parse.y\"\n+#line 2001 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 418:\n-#line 2013 \"./parse.y\"\n+#line 2006 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 419:\n-#line 2015 \"./parse.y\"\n+#line 2008 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 421:\n-#line 2021 \"./parse.y\"\n+#line 2014 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 422:\n-#line 2023 \"./parse.y\"\n+#line 2016 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 424:\n-#line 2026 \"./parse.y\"\n+#line 2019 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 425:\n-#line 2028 \"./parse.y\"\n+#line 2021 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 426:\n-#line 2033 \"./parse.y\"\n+#line 2026 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-3].node;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4408,15 +4401,15 @@ case 426:\n \t\t;\n     break;}\n case 427:\n-#line 2041 \"./parse.y\"\n+#line 2034 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 428:\n-#line 2043 \"./parse.y\"\n+#line 2036 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 429:\n-#line 2045 \"./parse.y\"\n+#line 2038 \"./parse.y\"\n { \n \t\t  char *ptr;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4431,275 +4424,275 @@ case 429:\n \t\t;\n     break;}\n case 430:\n-#line 2058 \"./parse.y\"\n+#line 2051 \"./parse.y\"\n {yyerror (\"']' expected, invalid type expression\");;\n     break;}\n case 431:\n-#line 2060 \"./parse.y\"\n+#line 2053 \"./parse.y\"\n {\n \t          if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid type expression\"); RECOVER;\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 432:\n-#line 2066 \"./parse.y\"\n+#line 2059 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 433:\n-#line 2068 \"./parse.y\"\n+#line 2061 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 434:\n-#line 2070 \"./parse.y\"\n+#line 2063 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 436:\n-#line 2076 \"./parse.y\"\n+#line 2069 \"./parse.y\"\n { \n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), \n \t\t\t\t    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 437:\n-#line 2081 \"./parse.y\"\n+#line 2074 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 438:\n-#line 2086 \"./parse.y\"\n+#line 2079 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 439:\n-#line 2091 \"./parse.y\"\n+#line 2084 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 440:\n-#line 2093 \"./parse.y\"\n+#line 2086 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 441:\n-#line 2095 \"./parse.y\"\n+#line 2088 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 443:\n-#line 2101 \"./parse.y\"\n+#line 2094 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 444:\n-#line 2106 \"./parse.y\"\n+#line 2099 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 445:\n-#line 2111 \"./parse.y\"\n+#line 2104 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 446:\n-#line 2113 \"./parse.y\"\n+#line 2106 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 448:\n-#line 2119 \"./parse.y\"\n+#line 2112 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 449:\n-#line 2124 \"./parse.y\"\n+#line 2117 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 450:\n-#line 2129 \"./parse.y\"\n+#line 2122 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 451:\n-#line 2134 \"./parse.y\"\n+#line 2127 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 452:\n-#line 2136 \"./parse.y\"\n+#line 2129 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 453:\n-#line 2138 \"./parse.y\"\n+#line 2131 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 455:\n-#line 2144 \"./parse.y\"\n+#line 2137 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 456:\n-#line 2149 \"./parse.y\"\n+#line 2142 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 457:\n-#line 2154 \"./parse.y\"\n+#line 2147 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 458:\n-#line 2159 \"./parse.y\"\n+#line 2152 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 459:\n-#line 2164 \"./parse.y\"\n+#line 2157 \"./parse.y\"\n { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 460:\n-#line 2166 \"./parse.y\"\n+#line 2159 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 461:\n-#line 2168 \"./parse.y\"\n+#line 2161 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 462:\n-#line 2170 \"./parse.y\"\n+#line 2163 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 463:\n-#line 2172 \"./parse.y\"\n+#line 2165 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 464:\n-#line 2174 \"./parse.y\"\n+#line 2167 \"./parse.y\"\n {yyerror (\"Invalid reference type\"); RECOVER;;\n     break;}\n case 466:\n-#line 2180 \"./parse.y\"\n+#line 2173 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 467:\n-#line 2185 \"./parse.y\"\n+#line 2178 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 468:\n-#line 2190 \"./parse.y\"\n+#line 2183 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 469:\n-#line 2192 \"./parse.y\"\n+#line 2185 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 471:\n-#line 2198 \"./parse.y\"\n+#line 2191 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 472:\n-#line 2203 \"./parse.y\"\n+#line 2196 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 474:\n-#line 2209 \"./parse.y\"\n+#line 2202 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 475:\n-#line 2214 \"./parse.y\"\n+#line 2207 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 477:\n-#line 2220 \"./parse.y\"\n+#line 2213 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 478:\n-#line 2225 \"./parse.y\"\n+#line 2218 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 480:\n-#line 2231 \"./parse.y\"\n+#line 2224 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 481:\n-#line 2236 \"./parse.y\"\n+#line 2229 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 483:\n-#line 2242 \"./parse.y\"\n+#line 2235 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 484:\n-#line 2247 \"./parse.y\"\n+#line 2240 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 486:\n-#line 2253 \"./parse.y\"\n+#line 2246 \"./parse.y\"\n {\n \t\t  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;\n \t\t;\n     break;}\n case 487:\n-#line 2258 \"./parse.y\"\n+#line 2251 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Missing term\");\n \t\t  DRECOVER (1);\n \t\t;\n     break;}\n case 488:\n-#line 2264 \"./parse.y\"\n+#line 2257 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (2);;\n     break;}\n case 489:\n-#line 2266 \"./parse.y\"\n+#line 2259 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (3);;\n     break;}\n case 492:\n-#line 2276 \"./parse.y\"\n+#line 2269 \"./parse.y\"\n { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 493:\n-#line 2278 \"./parse.y\"\n+#line 2271 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Missing term\");\n@@ -4904,7 +4897,7 @@ case 493:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 2304 \"./parse.y\"\n+#line 2297 \"./parse.y\"\n \n \f\n \n@@ -5868,19 +5861,11 @@ static void\n maybe_generate_clinit ()\n {\n   tree mdecl, c;\n-  int is_interface = CLASS_INTERFACE (ctxp->current_parsed_class);\n   int has_non_primitive_fields = 0;\n \n   if (!ctxp->static_initialized || java_error_count)\n     return;\n \n-  if (is_interface)\n-    for (c = TYPE_FIELDS (TREE_TYPE (ctxp->current_parsed_class));\n-\t c; c = TREE_CHAIN (c))\n-      has_non_primitive_fields |= !JPRIMITIVE_TYPE_P (TREE_TYPE (c));\n-  if (!has_non_primitive_fields && is_interface)\n-    return;\n-\n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n \t\t\t\t    ACC_STATIC, void_type_node,\n \t\t\t\t    clinit_identifier_node, end_params_node);\n@@ -8332,18 +8317,41 @@ java_complete_expand_methods ()\n       decl = tree_last (TYPE_METHODS (class_type));\n       if (IS_CLINIT (decl))\n \t{\n-\t  tree list = nreverse (TYPE_METHODS (class_type));\n-\t  list = TREE_CHAIN (list);\n-\t  TREE_CHAIN (decl) = NULL_TREE;\n-\t  TYPE_METHODS (class_type) = chainon (decl, nreverse (list));\n+\t  tree fbody = DECL_FUNCTION_BODY (decl);\n+\t  tree list;\n+\t  if (fbody != NULL_TREE)\n+\t    {\n+\t      /* First check if we can ignore empty <clinit> */\n+\t      tree block_body = BLOCK_EXPR_BODY (fbody);\n+\n+\t      current_this = NULL_TREE;\n+\t      current_function_decl = decl;\n+\t      if (block_body != NULL_TREE)\n+\t\t{\n+\t\t  /* Prevent the use of `this' inside <clinit> */\n+\t\t  ctxp->explicit_constructor_p = 1;\n+\n+\t\t  block_body = java_complete_tree (block_body);\n+\t\t  ctxp->explicit_constructor_p = 0;\n+\t\t  BLOCK_EXPR_BODY (fbody) = block_body;\n+\t\t  if (block_body != NULL_TREE\n+\t\t      && TREE_CODE (block_body) == BLOCK\n+\t\t      && BLOCK_EXPR_BODY (block_body) == empty_stmt_node)\n+\t\t    decl = NULL_TREE;\n+\t\t}\n+\t    }\n+\t  list = nreverse (TREE_CHAIN (nreverse (TYPE_METHODS (class_type))));\n+\t  if (decl != NULL_TREE)\n+\t    {\n+\t      TREE_CHAIN (decl) = list;\n+\t      TYPE_METHODS (class_type) = decl;\n+\t    }\n+\t    else\n+\t      TYPE_METHODS (class_type) = list;\n \t}\n       \n       for (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n \t{\n-\t  /* Process only <clinit> method bodies in interfaces. */\n-\t  if (is_interface && decl != TYPE_METHODS (class_type))\n-\t    break;\n-\n \t  current_function_decl = decl;\n \t  /* Don't generate debug info on line zero when expanding a\n \t     generated constructor. */\n@@ -8420,10 +8428,6 @@ java_complete_expand_method (mdecl)\n \n       if (block_body != NULL_TREE)\n \t{\n-\t  /* Prevent the use of `this' inside <clinit> */\n-\t  if (IS_CLINIT (current_function_decl))\n-\t    ctxp->explicit_constructor_p = 1;\n-\n \t  block_body = java_complete_tree (block_body);\n \t  check_for_initialization (block_body);\n \t  ctxp->explicit_constructor_p = 0;\n@@ -10359,6 +10363,13 @@ java_complete_lhs (node)\n \t      tree cur = java_complete_tree (TREE_OPERAND (*ptr, 0));\n \t      tree *next = &TREE_OPERAND (*ptr, 1);\n \t      TREE_OPERAND (*ptr, 0) = cur;\n+\t      if (cur == empty_stmt_node)\n+\t\t{\n+\t\t  /* Optimization;  makes it easier to detect empty bodies.\n+\t\t     Most useful for <clinit> with all-constant initializer. */\n+\t\t  *ptr = *next;\n+\t\t  continue;\n+\t\t}\n \t      if (TREE_CODE (cur) == ERROR_MARK)\n \t\terror_seen++;\n \t      else if (! CAN_COMPLETE_NORMALLY (cur))\n@@ -10626,6 +10637,11 @@ java_complete_lhs (node)\n \t  EXPR_WFL_NODE (node) = body;\n \t  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (body);\n \t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n+\t  if (body == empty_stmt_node)\n+\t    {\n+\t      /* Optimization;  makes it easier to detect empty bodies. */\n+\t      return body;\n+\t    }\n \t  if (body == error_mark_node)\n \t    {\n \t      /* Its important for the evaluation of assignment that\n@@ -10695,8 +10711,22 @@ java_complete_lhs (node)\n     case MODIFY_EXPR:\n       /* Save potential wfls */\n       wfl_op1 = TREE_OPERAND (node, 0);\n+      TREE_OPERAND (node, 0) = nn = java_complete_lhs (wfl_op1);\n+      if (MODIFY_EXPR_FROM_INITIALIZATION_P (node)\n+\t  && TREE_CODE (nn) == VAR_DECL && TREE_STATIC (nn)\n+\t  && DECL_INITIAL (nn) != NULL_TREE)\n+\t{\n+\t  tree value = fold_constant_for_init (nn, nn);\n+\t  if (value != NULL_TREE)\n+\t    {\n+\t      tree type = TREE_TYPE (value);\n+\t      if (JPRIMITIVE_TYPE_P (type) || type == string_ptr_type_node)\n+\t\treturn empty_stmt_node;\n+\t    }\n+\t  DECL_INITIAL (nn) = NULL_TREE;\n+\t}\n       wfl_op2 = TREE_OPERAND (node, 1);\n-      TREE_OPERAND (node, 0) = java_complete_lhs (wfl_op1);\n+\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n \n@@ -10742,17 +10772,6 @@ java_complete_lhs (node)\n \tTREE_OPERAND (node, 1) = nn;\n       node = patch_assignment (node, wfl_op1, wfl_op2);\n       CAN_COMPLETE_NORMALLY (node) = 1;\n-\n-      /* Before returning the node, in the context of a static field\n-         assignment in <clinit>, we may want to carray further\n-         optimizations. (VAR_DECL means it's a static field. See\n-         add_field. */\n-      if (IS_CLINIT (current_function_decl) \n-\t  && MODIFY_EXPR_FROM_INITIALIZATION_P (node)\n-\t  && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n-\t  && !flag_emit_xref)\n-\tnode = patch_initialized_static_field (node);\n-\n       return node;\n \n     case MULT_EXPR:\n@@ -11404,35 +11423,6 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   return node;\n }\n \n-/* Optimize static (final) field initialized upon declaration.\n-     - If the field is static final and is assigned to a primitive\n-       constant type, then set its DECL_INITIAL to the value.\n-     - More to come.  */\n-\n-static tree\n-patch_initialized_static_field (node)\n-     tree node;\n-{\n-  tree field = TREE_OPERAND (node, 0);\n-  tree value = TREE_OPERAND (node, 1);\n-\n-  if (DECL_INITIAL (field) != NULL_TREE)\n-    {\n-      tree type = TREE_TYPE (value);\n-      if (FIELD_FINAL (field) && TREE_CONSTANT (value)\n-\t  && (JPRIMITIVE_TYPE_P (type)\n-\t      || (flag_emit_class_files\n-\t\t  && TREE_CODE (type) == POINTER_TYPE\n-\t\t  && TREE_TYPE (type) == string_type_node)))\n-\t{\n-\t  DECL_INITIAL (field) = value;\n-\t  return empty_stmt_node;\n-\t}\n-      DECL_INITIAL (field) = NULL_TREE;\n-    }\n-  return node;\n-}\n-\n /* Check that type SOURCE can be cast into type DEST. If the cast\n    can't occur at all, return 0 otherwise 1. This function is used to\n    produce accurate error messages on the reasons why an assignment\n@@ -12337,7 +12327,7 @@ patch_string_cst (node)\n       location = alloc_name_constant (CONSTANT_String, node);\n       node = build_ref_from_constant_pool (location);\n     }\n-  TREE_TYPE (node) = promote_type (string_type_node);\n+  TREE_TYPE (node) = string_ptr_type_node;\n   TREE_CONSTANT (node) = 1;\n   return node;\n }\n@@ -13236,15 +13226,6 @@ finish_labeled_statement (lbe, statement)\n {\n   /* In anyways, tie the loop to its statement */\n   LABELED_BLOCK_BODY (lbe) = statement;\n-\n-  /* Ok, if statement is a for loop, we have to attach the labeled\n-     statement to the block the for loop belongs to and return the\n-     block instead */\n-  if (TREE_CODE (statement) == LOOP_EXPR && IS_FOR_LOOP_P (statement))\n-    {\n-      java_method_add_stmt (current_function_decl, lbe);\n-      lbe = exit_block ();\n-    }\n   pop_labeled_block ();\n   POP_LABELED_BLOCK ();\n   return lbe;\n@@ -13356,14 +13337,33 @@ static tree\n patch_loop_statement (loop)\n      tree loop;\n {\n-  if (! LOOP_HAS_LABEL_P (loop))\n+  tree loop_label;\n+  tree block = ctxp->current_labeled_block;\n+  TREE_TYPE (loop) = void_type_node;\n+  if (block != NULL_TREE)\n     {\n-      tree loop_label = build_labeled_block (0, NULL_TREE);\n-      LABELED_BLOCK_BODY (loop_label) = loop;\n-      PUSH_LABELED_BLOCK (loop_label);\n-      loop = loop_label;\n+      tree block_body = LABELED_BLOCK_BODY (block);\n+      if (IS_FOR_LOOP_P (loop))\n+\t{\n+\t  if (TREE_CODE (block_body) == BLOCK)\n+\t    {\n+\t      block_body = BLOCK_EXPR_BODY (block_body);\n+\t      if (block_body == loop\n+\t\t  || (TREE_CODE (block_body) == COMPOUND_EXPR\n+\t\t      && TREE_OPERAND (block_body, 1) == loop))\n+\t\treturn loop;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (block_body == loop)\n+\t    return loop;\n+\t}\n     }\n-  TREE_TYPE (loop) = void_type_node;\n+  loop_label = build_labeled_block (0, NULL_TREE);\n+  LABELED_BLOCK_BODY (loop_label) = loop;\n+  PUSH_LABELED_BLOCK (loop_label);\n+  loop = loop_label;\n   return loop;\n }\n \n@@ -14035,7 +14035,7 @@ fold_constant_for_init (node, context)\n \n   if (code == INTEGER_CST || code == REAL_CST || code == STRING_CST)\n     return node;\n-  if (TREE_TYPE (node) != NULL_TREE)\n+  if (TREE_TYPE (node) != NULL_TREE && code != VAR_DECL)\n     return NULL_TREE;\n \n   switch (code)\n@@ -14107,7 +14107,7 @@ fold_constant_for_init (node, context)\n       val = DECL_INITIAL (node);\n       /* Guard against infinite recursion. */\n       DECL_INITIAL (node) = NULL_TREE;\n-      val = fold_constant_for_init (val, DECL_CONTEXT (node));\n+      val = fold_constant_for_init (val, node);\n       DECL_INITIAL (node) = val;\n       return val;\n \n@@ -14123,7 +14123,7 @@ fold_constant_for_init (node, context)\n \t  else if (! QUALIFIED_P (name))\n \t    {\n \t      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);\n-\t      if (! FIELD_STATIC (decl))\n+\t      if (decl == NULL_TREE || ! FIELD_STATIC (decl))\n \t\treturn NULL_TREE;\n \t      return fold_constant_for_init (decl, decl);\n \t    }"}, {"sha": "56bcbf4c541e153350310efcbd1c8ff3103f9888", "filename": "gcc/java/parse.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=cd9643f75b2f7bc41642bd988532a03ba923c3f4", "patch": "@@ -258,18 +258,6 @@ extern tree stabilize_reference PROTO ((tree));\n #define LOOP_EXPR_BODY_BODY_EXPR(NODE, R)\t\t\t\\\n   LABELED_BLOCK_BODY (LOOP_EXPR_BODY_LABELED_BODY(NODE, R))\n \n-/* Does a loop have a label ? */\n-#define LOOP_HAS_LABEL_P(LOOP)\t\t\t\t\t\\\n-  (ctxp->current_labeled_block\t\t\t\t\t\\\n-   && LABELED_BLOCK_BODY (ctxp->current_labeled_block) == (LOOP))\n-\n-/* Same operation than the one performed above, but considering the\n-   previous labeled block */\n-#define LOOP_HAS_LABEL_SKIP_P(LOOP)\t\t\t\t\t     \\\n-  (ctxp->current_labeled_block\t\t\t\t\t\t     \\\n-   && TREE_CHAIN (ctxp->current_labeled_block)\t\t\t\t     \\\n-   && LABELED_BLOCK_BODY (TREE_CHAIN (ctxp->current_labeled_block)) == (LOOP))\n-\n #define PUSH_LABELED_BLOCK(B)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n     TREE_CHAIN (B) = ctxp->current_labeled_block;\t\\"}, {"sha": "82598de46c868ecde7457772729f1dcffc4af31d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9643f75b2f7bc41642bd988532a03ba923c3f4/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=cd9643f75b2f7bc41642bd988532a03ba923c3f4", "patch": "@@ -237,7 +237,6 @@ static tree patch_new_array_init PROTO ((tree, tree));\n static tree maybe_build_array_element_wfl PROTO ((tree));\n static int array_constructor_check_entry PROTO ((tree, tree));\n static char *purify_type_name PROTO ((char *));\n-static tree patch_initialized_static_field PROTO ((tree));\n static tree fold_constant_for_init PROTO ((tree, tree));\n static tree strip_out_static_field_access_decl PROTO ((tree));\n static jdeplist *reverse_jdep_list PROTO ((struct parser_ctxt *));\n@@ -1220,13 +1219,7 @@ statement:\n |\tif_then_else_statement\n |\twhile_statement\n |\tfor_statement\n-\t\t{ \n-\t\t  /* If the for loop is unlabeled, we must return the\n-\t\t     block it was defined it. It our last chance to\n-\t\t     get a hold on it. */\n-\t\t  if (!LOOP_HAS_LABEL_P ($$))\n-\t\t    $$ = exit_block ();\n-\t\t}\n+\t\t{ $$ = exit_block (); }\n ;\n \n statement_nsi:\n@@ -3264,19 +3257,11 @@ static void\n maybe_generate_clinit ()\n {\n   tree mdecl, c;\n-  int is_interface = CLASS_INTERFACE (ctxp->current_parsed_class);\n   int has_non_primitive_fields = 0;\n \n   if (!ctxp->static_initialized || java_error_count)\n     return;\n \n-  if (is_interface)\n-    for (c = TYPE_FIELDS (TREE_TYPE (ctxp->current_parsed_class));\n-\t c; c = TREE_CHAIN (c))\n-      has_non_primitive_fields |= !JPRIMITIVE_TYPE_P (TREE_TYPE (c));\n-  if (!has_non_primitive_fields && is_interface)\n-    return;\n-\n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n \t\t\t\t    ACC_STATIC, void_type_node,\n \t\t\t\t    clinit_identifier_node, end_params_node);\n@@ -5728,18 +5713,41 @@ java_complete_expand_methods ()\n       decl = tree_last (TYPE_METHODS (class_type));\n       if (IS_CLINIT (decl))\n \t{\n-\t  tree list = nreverse (TYPE_METHODS (class_type));\n-\t  list = TREE_CHAIN (list);\n-\t  TREE_CHAIN (decl) = NULL_TREE;\n-\t  TYPE_METHODS (class_type) = chainon (decl, nreverse (list));\n+\t  tree fbody = DECL_FUNCTION_BODY (decl);\n+\t  tree list;\n+\t  if (fbody != NULL_TREE)\n+\t    {\n+\t      /* First check if we can ignore empty <clinit> */\n+\t      tree block_body = BLOCK_EXPR_BODY (fbody);\n+\n+\t      current_this = NULL_TREE;\n+\t      current_function_decl = decl;\n+\t      if (block_body != NULL_TREE)\n+\t\t{\n+\t\t  /* Prevent the use of `this' inside <clinit> */\n+\t\t  ctxp->explicit_constructor_p = 1;\n+\n+\t\t  block_body = java_complete_tree (block_body);\n+\t\t  ctxp->explicit_constructor_p = 0;\n+\t\t  BLOCK_EXPR_BODY (fbody) = block_body;\n+\t\t  if (block_body != NULL_TREE\n+\t\t      && TREE_CODE (block_body) == BLOCK\n+\t\t      && BLOCK_EXPR_BODY (block_body) == empty_stmt_node)\n+\t\t    decl = NULL_TREE;\n+\t\t}\n+\t    }\n+\t  list = nreverse (TREE_CHAIN (nreverse (TYPE_METHODS (class_type))));\n+\t  if (decl != NULL_TREE)\n+\t    {\n+\t      TREE_CHAIN (decl) = list;\n+\t      TYPE_METHODS (class_type) = decl;\n+\t    }\n+\t    else\n+\t      TYPE_METHODS (class_type) = list;\n \t}\n       \n       for (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n \t{\n-\t  /* Process only <clinit> method bodies in interfaces. */\n-\t  if (is_interface && decl != TYPE_METHODS (class_type))\n-\t    break;\n-\n \t  current_function_decl = decl;\n \t  /* Don't generate debug info on line zero when expanding a\n \t     generated constructor. */\n@@ -5816,10 +5824,6 @@ java_complete_expand_method (mdecl)\n \n       if (block_body != NULL_TREE)\n \t{\n-\t  /* Prevent the use of `this' inside <clinit> */\n-\t  if (IS_CLINIT (current_function_decl))\n-\t    ctxp->explicit_constructor_p = 1;\n-\n \t  block_body = java_complete_tree (block_body);\n \t  check_for_initialization (block_body);\n \t  ctxp->explicit_constructor_p = 0;\n@@ -7755,6 +7759,13 @@ java_complete_lhs (node)\n \t      tree cur = java_complete_tree (TREE_OPERAND (*ptr, 0));\n \t      tree *next = &TREE_OPERAND (*ptr, 1);\n \t      TREE_OPERAND (*ptr, 0) = cur;\n+\t      if (cur == empty_stmt_node)\n+\t\t{\n+\t\t  /* Optimization;  makes it easier to detect empty bodies.\n+\t\t     Most useful for <clinit> with all-constant initializer. */\n+\t\t  *ptr = *next;\n+\t\t  continue;\n+\t\t}\n \t      if (TREE_CODE (cur) == ERROR_MARK)\n \t\terror_seen++;\n \t      else if (! CAN_COMPLETE_NORMALLY (cur))\n@@ -8022,6 +8033,11 @@ java_complete_lhs (node)\n \t  EXPR_WFL_NODE (node) = body;\n \t  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (body);\n \t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n+\t  if (body == empty_stmt_node)\n+\t    {\n+\t      /* Optimization;  makes it easier to detect empty bodies. */\n+\t      return body;\n+\t    }\n \t  if (body == error_mark_node)\n \t    {\n \t      /* Its important for the evaluation of assignment that\n@@ -8091,8 +8107,22 @@ java_complete_lhs (node)\n     case MODIFY_EXPR:\n       /* Save potential wfls */\n       wfl_op1 = TREE_OPERAND (node, 0);\n+      TREE_OPERAND (node, 0) = nn = java_complete_lhs (wfl_op1);\n+      if (MODIFY_EXPR_FROM_INITIALIZATION_P (node)\n+\t  && TREE_CODE (nn) == VAR_DECL && TREE_STATIC (nn)\n+\t  && DECL_INITIAL (nn) != NULL_TREE)\n+\t{\n+\t  tree value = fold_constant_for_init (nn, nn);\n+\t  if (value != NULL_TREE)\n+\t    {\n+\t      tree type = TREE_TYPE (value);\n+\t      if (JPRIMITIVE_TYPE_P (type) || type == string_ptr_type_node)\n+\t\treturn empty_stmt_node;\n+\t    }\n+\t  DECL_INITIAL (nn) = NULL_TREE;\n+\t}\n       wfl_op2 = TREE_OPERAND (node, 1);\n-      TREE_OPERAND (node, 0) = java_complete_lhs (wfl_op1);\n+\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n \n@@ -8138,17 +8168,6 @@ java_complete_lhs (node)\n \tTREE_OPERAND (node, 1) = nn;\n       node = patch_assignment (node, wfl_op1, wfl_op2);\n       CAN_COMPLETE_NORMALLY (node) = 1;\n-\n-      /* Before returning the node, in the context of a static field\n-         assignment in <clinit>, we may want to carray further\n-         optimizations. (VAR_DECL means it's a static field. See\n-         add_field. */\n-      if (IS_CLINIT (current_function_decl) \n-\t  && MODIFY_EXPR_FROM_INITIALIZATION_P (node)\n-\t  && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n-\t  && !flag_emit_xref)\n-\tnode = patch_initialized_static_field (node);\n-\n       return node;\n \n     case MULT_EXPR:\n@@ -8800,35 +8819,6 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   return node;\n }\n \n-/* Optimize static (final) field initialized upon declaration.\n-     - If the field is static final and is assigned to a primitive\n-       constant type, then set its DECL_INITIAL to the value.\n-     - More to come.  */\n-\n-static tree\n-patch_initialized_static_field (node)\n-     tree node;\n-{\n-  tree field = TREE_OPERAND (node, 0);\n-  tree value = TREE_OPERAND (node, 1);\n-\n-  if (DECL_INITIAL (field) != NULL_TREE)\n-    {\n-      tree type = TREE_TYPE (value);\n-      if (FIELD_FINAL (field) && TREE_CONSTANT (value)\n-\t  && (JPRIMITIVE_TYPE_P (type)\n-\t      || (flag_emit_class_files\n-\t\t  && TREE_CODE (type) == POINTER_TYPE\n-\t\t  && TREE_TYPE (type) == string_type_node)))\n-\t{\n-\t  DECL_INITIAL (field) = value;\n-\t  return empty_stmt_node;\n-\t}\n-      DECL_INITIAL (field) = NULL_TREE;\n-    }\n-  return node;\n-}\n-\n /* Check that type SOURCE can be cast into type DEST. If the cast\n    can't occur at all, return 0 otherwise 1. This function is used to\n    produce accurate error messages on the reasons why an assignment\n@@ -9733,7 +9723,7 @@ patch_string_cst (node)\n       location = alloc_name_constant (CONSTANT_String, node);\n       node = build_ref_from_constant_pool (location);\n     }\n-  TREE_TYPE (node) = promote_type (string_type_node);\n+  TREE_TYPE (node) = string_ptr_type_node;\n   TREE_CONSTANT (node) = 1;\n   return node;\n }\n@@ -10632,15 +10622,6 @@ finish_labeled_statement (lbe, statement)\n {\n   /* In anyways, tie the loop to its statement */\n   LABELED_BLOCK_BODY (lbe) = statement;\n-\n-  /* Ok, if statement is a for loop, we have to attach the labeled\n-     statement to the block the for loop belongs to and return the\n-     block instead */\n-  if (TREE_CODE (statement) == LOOP_EXPR && IS_FOR_LOOP_P (statement))\n-    {\n-      java_method_add_stmt (current_function_decl, lbe);\n-      lbe = exit_block ();\n-    }\n   pop_labeled_block ();\n   POP_LABELED_BLOCK ();\n   return lbe;\n@@ -10752,14 +10733,33 @@ static tree\n patch_loop_statement (loop)\n      tree loop;\n {\n-  if (! LOOP_HAS_LABEL_P (loop))\n+  tree loop_label;\n+  tree block = ctxp->current_labeled_block;\n+  TREE_TYPE (loop) = void_type_node;\n+  if (block != NULL_TREE)\n     {\n-      tree loop_label = build_labeled_block (0, NULL_TREE);\n-      LABELED_BLOCK_BODY (loop_label) = loop;\n-      PUSH_LABELED_BLOCK (loop_label);\n-      loop = loop_label;\n+      tree block_body = LABELED_BLOCK_BODY (block);\n+      if (IS_FOR_LOOP_P (loop))\n+\t{\n+\t  if (TREE_CODE (block_body) == BLOCK)\n+\t    {\n+\t      block_body = BLOCK_EXPR_BODY (block_body);\n+\t      if (block_body == loop\n+\t\t  || (TREE_CODE (block_body) == COMPOUND_EXPR\n+\t\t      && TREE_OPERAND (block_body, 1) == loop))\n+\t\treturn loop;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (block_body == loop)\n+\t    return loop;\n+\t}\n     }\n-  TREE_TYPE (loop) = void_type_node;\n+  loop_label = build_labeled_block (0, NULL_TREE);\n+  LABELED_BLOCK_BODY (loop_label) = loop;\n+  PUSH_LABELED_BLOCK (loop_label);\n+  loop = loop_label;\n   return loop;\n }\n \n@@ -11431,7 +11431,7 @@ fold_constant_for_init (node, context)\n \n   if (code == INTEGER_CST || code == REAL_CST || code == STRING_CST)\n     return node;\n-  if (TREE_TYPE (node) != NULL_TREE)\n+  if (TREE_TYPE (node) != NULL_TREE && code != VAR_DECL)\n     return NULL_TREE;\n \n   switch (code)\n@@ -11503,7 +11503,7 @@ fold_constant_for_init (node, context)\n       val = DECL_INITIAL (node);\n       /* Guard against infinite recursion. */\n       DECL_INITIAL (node) = NULL_TREE;\n-      val = fold_constant_for_init (val, DECL_CONTEXT (node));\n+      val = fold_constant_for_init (val, node);\n       DECL_INITIAL (node) = val;\n       return val;\n \n@@ -11519,7 +11519,7 @@ fold_constant_for_init (node, context)\n \t  else if (! QUALIFIED_P (name))\n \t    {\n \t      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);\n-\t      if (! FIELD_STATIC (decl))\n+\t      if (decl == NULL_TREE || ! FIELD_STATIC (decl))\n \t\treturn NULL_TREE;\n \t      return fold_constant_for_init (decl, decl);\n \t    }"}]}