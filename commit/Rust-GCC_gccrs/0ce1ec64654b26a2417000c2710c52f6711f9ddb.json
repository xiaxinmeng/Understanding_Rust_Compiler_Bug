{"sha": "0ce1ec64654b26a2417000c2710c52f6711f9ddb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNlMWVjNjQ2NTRiMjZhMjQxNzAwMGMyNzEwYzUyZjY3MTFmOWRkYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-11-06T09:55:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T09:55:50Z"}, "message": "sem_prag.adb: Minor reformatting.\n\n2012-11-06  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb: Minor reformatting.\n\n2012-11-06  Robert Dewar  <dewar@adacore.com>\n\n\t* s-bignum.adb (Div_Rem): Fix bug in step D3.\n\t* uintp.adb (UI_Div_Rem): Add comment on bug in step D3.\n\nFrom-SVN: r193217", "tree": {"sha": "95cfe11f8aab43afcc3d4601e798f0cde9eee8ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95cfe11f8aab43afcc3d4601e798f0cde9eee8ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ce1ec64654b26a2417000c2710c52f6711f9ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce1ec64654b26a2417000c2710c52f6711f9ddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ce1ec64654b26a2417000c2710c52f6711f9ddb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce1ec64654b26a2417000c2710c52f6711f9ddb/comments", "author": null, "committer": null, "parents": [{"sha": "ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a"}], "stats": {"total": 88, "additions": 58, "deletions": 30}, "files": [{"sha": "dd82c971064a591a3c832698d0a87c58fee3dab9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce1ec64654b26a2417000c2710c52f6711f9ddb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce1ec64654b26a2417000c2710c52f6711f9ddb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0ce1ec64654b26a2417000c2710c52f6711f9ddb", "patch": "@@ -1,3 +1,12 @@\n+2012-11-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb: Minor reformatting.\n+\n+2012-11-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-bignum.adb (Div_Rem): Fix bug in step D3.\n+\t* uintp.adb (UI_Div_Rem): Add comment on bug in step D3.\n+\n 2012-11-06  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_prag.adb (Expand_Pragma_Loop_Assertion): Update the comment"}, {"sha": "84e9c8795d7405508c794e74517b206102272b98", "filename": "gcc/ada/s-bignum.adb", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce1ec64654b26a2417000c2710c52f6711f9ddb/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce1ec64654b26a2417000c2710c52f6711f9ddb/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=0ce1ec64654b26a2417000c2710c52f6711f9ddb", "patch": "@@ -776,7 +776,9 @@ package body System.Bignums is\n \n          d    : DD;\n          j    : Length;\n-         qhat : SD;\n+         qhat : DD;\n+         rhat : DD;\n+         temp : DD;\n \n       begin\n          --  Initialize data of left and right operands\n@@ -847,26 +849,37 @@ package body System.Bignums is\n          --  Loop through digits\n \n          loop\n-            --  D3. [Calculate qhat.] If uj = v1, set qhat to b-l; otherwise\n-            --  set qhat to (uj,uj+1)/v1.\n-\n-            if u (j) = v1 then\n-               qhat := -1;\n-            else\n-               qhat := SD ((u (j) & u (j + 1)) / DD (v1));\n-            end if;\n-\n-            --  D3 (continued). Now test if v2 * qhat is greater than (uj*b +\n-            --  uj+1 - qhat*v1)*b + uj+2. If so, decrease qhat by 1 and repeat\n-            --  this test, which determines at high speed most of the cases in\n-            --  which the trial value qhat is one too large, and it eliminates\n-            --  all cases where qhat is two too large.\n+            --  Note: In the original printing, step D3 was as follows:\n \n-            while DD (v2) * DD (qhat) >\n-                   ((u (j) & u (j + 1)) -\n-                     DD (qhat) * DD (v1)) * b + DD (u (j + 2))\n+            --  D3. [Calculate qhat.] If uj = v1, set qhat to b-l; otherwise\n+            --  set qhat to (uj,uj+1)/v1. Now test if v2 * qhat is greater than\n+            --  (uj*b + uj+1 - qhat*v1)*b + uj+2. If so, decrease qhat by 1 and\n+            --  repeat this test\n+\n+            --  This had a bug not discovered till 1995, see Vol 2 errata:\n+            --  http://www-cs-faculty.stanford.edu/~uno/err2-2e.ps.gz. Under\n+            --  rare circumstances the expression in the test could overflow.\n+            --  The code below is the fixed version of this step.\n+\n+            --  D3. [Calculate qhat.] Set qhat to (uj,uj+1)/v1 and rhat to\n+            --  to (uj,uj+1) mod v1.\n+\n+            temp := u (j) & u (j + 1);\n+            qhat := temp / DD (v1);\n+            rhat := temp mod DD (v1);\n+\n+            --  D3 (continued). Now test if qhat = b or v2*qhat > (rhat,uj+2):\n+            --  if so, decrease qhat by 1, increase rhat by v1, and repeat this\n+            --  test if rhat < b. [The test on v2 determines at at high speed\n+            --  most of the cases in which the trial value qhat is one too\n+            --  large, and eliminates all cases where qhat is two too large.]\n+\n+            while qhat = b\n+              or else DD (v2) * qhat > LSD (rhat) & u (j + 2)\n             loop\n                qhat := qhat - 1;\n+               rhat := rhat + DD (v1);\n+               exit when rhat >= b;\n             end loop;\n \n             --  D4. [Multiply and subtract.] Replace (uj,uj+1..uj+n) by\n@@ -892,7 +905,7 @@ package body System.Bignums is\n             begin\n                Borrow := 0;\n                for K in reverse 1 .. n loop\n-                  Temp := DD (qhat) * DD (v (K)) + DD (Borrow);\n+                  Temp := qhat * DD (v (K)) + DD (Borrow);\n                   Borrow := MSD (Temp);\n \n                   if LSD (Temp) > u (j + K) then\n@@ -908,7 +921,7 @@ package body System.Bignums is\n                --  D5. [Test remainder.] Set qj = qhat. If the result of step\n                --  D4 was negative, we will do the add back step (step D6).\n \n-               q (j) := qhat;\n+               q (j) := LSD (qhat);\n \n                if Negative then\n "}, {"sha": "c3f27e14f89283db2bd596d7b239b24973c61fa3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce1ec64654b26a2417000c2710c52f6711f9ddb/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce1ec64654b26a2417000c2710c52f6711f9ddb/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0ce1ec64654b26a2417000c2710c52f6711f9ddb", "patch": "@@ -11289,16 +11289,13 @@ package body Sem_Prag is\n          --------------------\n \n          --  pragma Loop_Assertion\n-         --    (   [Invariant =>] boolean_Expression\n-         --      | [Invariant =>] boolean_Expression ,\n-         --         Variant => TERMINATION_VARIANTS\n-         --      |  Variant => TERMINATION_VARIANTS );\n-         --\n-         --  TERMINATION_VARIANTS ::=\n-         --    ( TERMINATION_VARIANT {, TERMINATION_VARIANT} )\n-         --\n+         --        (  [Invariant =>] boolean_Expression );\n+         --     |  ( [[Invariant =>] boolean_Expression ,]\n+         --            Variant   =>\n+         --              ( TERMINATION_VARIANT {, TERMINATION_VARIANT ) );\n+\n          --  TERMINATION_VARIANT ::= CHANGE_MODIFIER => discrete_EXPRESSION\n-         --\n+\n          --  CHANGE_MODIFIER ::= Increasing | Decreasing\n \n          when Pragma_Loop_Assertion => Loop_Assertion : declare"}, {"sha": "0761f2df70b12c0e222f9eed299c83144c6f942f", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce1ec64654b26a2417000c2710c52f6711f9ddb/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce1ec64654b26a2417000c2710c52f6711f9ddb/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=0ce1ec64654b26a2417000c2710c52f6711f9ddb", "patch": "@@ -1216,6 +1216,15 @@ package body Uintp is\n \n                --  [ CALCULATE Q (hat) ] (step D3 in the algorithm)\n \n+               --  Note: this version of step D3 is from the original published\n+               --  algorithm, which is known to have a bug causing overflows.\n+               --  See: http://www-cs-faculty.stanford.edu/~uno/err2-2e.ps.gz.\n+               --  In this code we are safe since our representation of double\n+               --  length numbers allows an expanded range.\n+\n+               --  We don't have a proof of this claim, but the only cases we\n+               --  have found that show the bug in step D3 work fine here.\n+\n                Tmp_Int := Dividend (J) * Base + Dividend (J + 1);\n \n                --  Initial guess\n@@ -1230,7 +1239,7 @@ package body Uintp is\n \n                while Divisor_Dig2 * Q_Guess >\n                      (Tmp_Int - Q_Guess * Divisor_Dig1) * Base +\n-                                                          Dividend (J + 2)\n+                        Dividend (J + 2)\n                loop\n                   Q_Guess := Q_Guess - 1;\n                end loop;"}]}