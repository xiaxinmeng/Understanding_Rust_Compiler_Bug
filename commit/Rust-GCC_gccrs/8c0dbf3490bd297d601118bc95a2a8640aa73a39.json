{"sha": "8c0dbf3490bd297d601118bc95a2a8640aa73a39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMwZGJmMzQ5MGJkMjk3ZDYwMTExOGJjOTVhMmE4NjQwYWE3M2EzOQ==", "commit": {"author": {"name": "David Daney", "email": "ddaney@avtrex.com", "date": "2007-05-12T17:37:55Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2007-05-12T17:37:55Z"}, "message": "re PR libgcj/29324 (add wait handling hook)\n\n\tPR libgcj/29324\n\t* include/posix-threads.h (_Jv_BlockSigchld): Declare.\n\t(_Jv_UnBlockSigchld): Same.\n\t* posix-threads.cc: Include posix-threads.h.\n\t(block_sigchld) Rename to...\n\t(_Jv_BlockSigchld) ... this.\n\t(_Jv_UnBlockSigchld): New function.\n\t(_Jv_InitThreads): Call _Jv_BlockSigchld in place of block_sigchld.\n\t(_Jv_ThreadStart): Same.\n\t* java/lang/PosixProcess$ProcessManager.h: Regenerate.\n\t* java/lang/PosixProcess.java: Clean up imports.\n\t(ProcessManager): Make final.\n\t(ProcessManager.queue): Genericise and make private.\n\t(ProcessManager.pidToProcess): Remove.\n\t(ProcessManager.liveProcesses): New field.\n\t(ProcessManager.reaperPID): Remove.\n\t(ProcessManager.nativeData): New field.\n\t(ProcessManager.removeProcessFromMap): Remove.\n\t(ProcessManager.addProcessToMap):Remove.\n\t(ProcessManager.addToLiveProcesses): New method.\n\t(ProcessManager.run): Rewritten.\n\t(ProcessManager.reap): Change method signature,\n\t(getErrorStream): Correct formatting.\n\t(getInputStream): Same.\n\t(spawn): Add process to liveProcesses list.\n\t(pid): Make package private.\n\t* java/lang/PosixProcess.h: Regenerate.\n\t* java/lang/natPosixProcess.cc: Include posix.h and posix-threads.h.\n\tAdd useing namespace java::lang.\n\t(ProcessManagerInternal): New struct.\n\t(sigchld_handler): Rewritten.\n\t(init): Rewritten.\n\t(waitForSignal): Same.\n\t(reap): Same.\n\t(signalReaper): Same.\n\t(nativeDestroy): Call kill as ::kill.\n\t(nativeSpawn): Correct formatting.\n\t* classpath/lib/java/lang/PosixProcess$EOFInputStream.class: Regenerate.\n\t* classpath/lib/java/lang/PosixProcess.class: Same.\n\t* classpath/lib/java/lang/PosixProcess$ProcessManager.class: Same.\n\nFrom-SVN: r124638", "tree": {"sha": "c786d0bbe368ad9664be7de23b5d9d5b106c0f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c786d0bbe368ad9664be7de23b5d9d5b106c0f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c0dbf3490bd297d601118bc95a2a8640aa73a39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c0dbf3490bd297d601118bc95a2a8640aa73a39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c0dbf3490bd297d601118bc95a2a8640aa73a39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c0dbf3490bd297d601118bc95a2a8640aa73a39/comments", "author": null, "committer": null, "parents": [{"sha": "c4160806e1a116b18498c97b969cc45e453104ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4160806e1a116b18498c97b969cc45e453104ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4160806e1a116b18498c97b969cc45e453104ce"}], "stats": {"total": 420, "additions": 248, "deletions": 172}, "files": [{"sha": "dce155806cf62ffc75f0020cddb383f0bd4f1ade", "filename": "libjava/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39", "patch": "@@ -1,3 +1,46 @@\n+2007-05-12  David Daney  <ddaney@avtrex.com>\n+\n+\tPR libgcj/29324\n+\t* include/posix-threads.h (_Jv_BlockSigchld): Declare.\n+\t(_Jv_UnBlockSigchld): Same.\n+\t* posix-threads.cc: Include posix-threads.h.\n+\t(block_sigchld) Rename to...\n+\t(_Jv_BlockSigchld) ... this.\n+\t(_Jv_UnBlockSigchld): New function.\n+\t(_Jv_InitThreads): Call _Jv_BlockSigchld in place of block_sigchld.\n+\t(_Jv_ThreadStart): Same.\n+\t* java/lang/PosixProcess$ProcessManager.h: Regenerate.\n+\t* java/lang/PosixProcess.java: Clean up imports.\n+\t(ProcessManager): Make final.\n+\t(ProcessManager.queue): Genericise and make private.\n+\t(ProcessManager.pidToProcess): Remove.\n+\t(ProcessManager.liveProcesses): New field.\n+\t(ProcessManager.reaperPID): Remove.\n+\t(ProcessManager.nativeData): New field.\n+\t(ProcessManager.removeProcessFromMap): Remove.\n+\t(ProcessManager.addProcessToMap):Remove.\n+\t(ProcessManager.addToLiveProcesses): New method.\n+\t(ProcessManager.run): Rewritten.\n+\t(ProcessManager.reap): Change method signature,\n+\t(getErrorStream): Correct formatting.\n+\t(getInputStream): Same.\n+\t(spawn): Add process to liveProcesses list.\n+\t(pid): Make package private.\n+\t* java/lang/PosixProcess.h: Regenerate.\n+\t* java/lang/natPosixProcess.cc: Include posix.h and posix-threads.h.\n+\tAdd useing namespace java::lang.\n+\t(ProcessManagerInternal): New struct.\n+\t(sigchld_handler): Rewritten.\n+\t(init): Rewritten.\n+\t(waitForSignal): Same.\n+\t(reap): Same.\n+\t(signalReaper): Same.\n+\t(nativeDestroy): Call kill as ::kill.\n+\t(nativeSpawn): Correct formatting.\n+\t* classpath/lib/java/lang/PosixProcess$EOFInputStream.class: Regenerate.\n+\t* classpath/lib/java/lang/PosixProcess.class: Same.\n+\t* classpath/lib/java/lang/PosixProcess$ProcessManager.class: Same.\n+\n 2007-05-07  Ian Lance Taylor  <iant@google.com>\n \n \tPR java/31842"}, {"sha": "c4cc6c37ccbe1361ccaee911c67eaae572e71d86", "filename": "libjava/classpath/lib/java/lang/PosixProcess$EOFInputStream.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess%24EOFInputStream.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess%24EOFInputStream.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess%24EOFInputStream.class?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39"}, {"sha": "1d80a2d4cc15bbf7245b6f263e0c29babc71ffa9", "filename": "libjava/classpath/lib/java/lang/PosixProcess$ProcessManager.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess%24ProcessManager.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess%24ProcessManager.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess%24ProcessManager.class?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39"}, {"sha": "0241ae74f9eeb271438dda06633a028746098277", "filename": "libjava/classpath/lib/java/lang/PosixProcess.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FPosixProcess.class?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39"}, {"sha": "806ee556011a2afb09efab02dbd03f4476a124e5", "filename": "libjava/include/posix-threads.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Finclude%2Fposix-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Finclude%2Fposix-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix-threads.h?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39", "patch": "@@ -91,6 +91,14 @@ _Jv_GetPlatformThreadID(_Jv_Thread_t *t)\n   return t->thread;\n }\n \n+//\n+// Signal helpers.\n+//\n+\n+void _Jv_BlockSigchld();\n+void _Jv_UnBlockSigchld();\n+\n+\n //\n // Condition variables.\n //"}, {"sha": "4b3b62e13dd34dd6ec86e75e8bae04e2c8346ebf", "filename": "libjava/java/lang/PosixProcess$ProcessManager.h", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fjava%2Flang%2FPosixProcess%24ProcessManager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fjava%2Flang%2FPosixProcess%24ProcessManager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FPosixProcess%24ProcessManager.h?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39", "patch": "@@ -7,31 +7,37 @@\n #pragma interface\n \n #include <java/lang/Thread.h>\n+extern \"Java\"\n+{\n+  namespace gnu\n+  {\n+    namespace gcj\n+    {\n+        class RawDataManaged;\n+    }\n+  }\n+}\n \n class java::lang::PosixProcess$ProcessManager : public ::java::lang::Thread\n {\n \n public: // actually package-private\n   PosixProcess$ProcessManager();\n-private:\n-  ::java::lang::PosixProcess * removeProcessFromMap(jlong);\n-public: // actually package-private\n-  virtual void addProcessToMap(::java::lang::PosixProcess *);\n-  virtual void startExecuting(::java::lang::PosixProcess *);\n-  virtual void waitUntilReady();\n+  void addToLiveProcesses(::java::lang::PosixProcess *);\n+  void startExecuting(::java::lang::PosixProcess *);\n+  void waitUntilReady();\n public:\n-  virtual void run();\n+  void run();\n private:\n   void init();\n   void waitForSignal();\n-  jboolean reap();\n+  jboolean reap(::java::lang::PosixProcess *);\n   void signalReaper();\n-public: // actually package-private\n-  ::java::util::List * __attribute__((aligned(__alignof__( ::java::lang::Thread)))) queue;\n-private:\n-  ::java::util::Map * pidToProcess;\n+  ::java::util::LinkedList * __attribute__((aligned(__alignof__( ::java::lang::Thread)))) queue;\n+  ::java::util::LinkedList * liveProcesses;\n   jboolean ready;\n-  jlong reaperPID;\n+public: // actually package-private\n+  static ::gnu::gcj::RawDataManaged * nativeData;\n public:\n   static ::java::lang::Class class$;\n };"}, {"sha": "3254f5224cea46095c97bd67b05e382678d5161a", "filename": "libjava/java/lang/PosixProcess.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fjava%2Flang%2FPosixProcess.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fjava%2Flang%2FPosixProcess.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FPosixProcess.h?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39", "patch": "@@ -32,17 +32,16 @@ class java::lang::PosixProcess : public ::java::lang::Process\n   void nativeSpawn();\n public: // actually package-private\n   PosixProcess(JArray< ::java::lang::String * > *, JArray< ::java::lang::String * > *, ::java::io::File *, jboolean);\n-  static jlong access$0(::java::lang::PosixProcess *);\n-  static ::java::lang::Object * access$1();\n-  static void access$2(::java::lang::PosixProcess$ProcessManager *);\n+  static ::java::lang::Object * access$0();\n+  static void access$1(::java::lang::PosixProcess$ProcessManager *);\n private:\n   JArray< ::java::lang::String * > * __attribute__((aligned(__alignof__( ::java::lang::Process)))) progarray;\n   JArray< ::java::lang::String * > * envp;\n   ::java::io::File * dir;\n   jboolean redirect;\n   ::java::lang::Throwable * exception;\n-  jlong pid;\n public: // actually package-private\n+  jlong pid;\n   static const jint STATE_WAITING_TO_START = 0;\n   static const jint STATE_RUNNING = 1;\n   static const jint STATE_TERMINATED = 2;"}, {"sha": "dd59e7b93a11408a87110776daa1d3ef9694e341", "filename": "libjava/java/lang/PosixProcess.java", "status": "modified", "additions": 73, "deletions": 78, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fjava%2Flang%2FPosixProcess.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fjava%2Flang%2FPosixProcess.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FPosixProcess.java?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39", "patch": "@@ -13,11 +13,10 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n \n+import gnu.gcj.RawDataManaged;\n \n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n@@ -27,18 +26,20 @@\n  */\n final class PosixProcess extends Process\n {\n-  static class ProcessManager extends Thread\n+  static final class ProcessManager extends Thread\n   {\n     /**\n      * A list of {@link PosixProcess PosixProcesses} to be\n      * started.  The queueLock object is used as the lock Object\n      * for all process related operations. To avoid dead lock\n      * ensure queueLock is obtained before PosixProcess.\n      */\n-    List queue = new LinkedList();\n-    private Map pidToProcess = new HashMap();\n+    private LinkedList<PosixProcess> queue = new LinkedList<PosixProcess>();\n+    private LinkedList<PosixProcess> liveProcesses =\n+      new LinkedList<PosixProcess>();\n     private boolean ready = false;\n-    private long reaperPID;\n+\n+    static RawDataManaged nativeData;\n \n     ProcessManager()\n     {\n@@ -53,27 +54,14 @@ static class ProcessManager extends Thread\n     }\n \n     /**\n-     * Get the PosixProcess object with the given pid and\n-     * remove it from the map.  This method is called from the\n-     * native code for {@link #reap()).  The mapping is removed so\n-     * the PosixProcesses can be GCed after they terminate.\n-     *\n-     * @param p The pid of the process.\n-     */\n-    private PosixProcess removeProcessFromMap(long p)\n-    {\n-      return (PosixProcess) pidToProcess.remove(new Long(p));\n-    }\n-\n-    /**\n-     * Put the given PosixProcess in the map using the Long\n-     * value of its pid as the key.\n+     * Add a process to the list of running processes.  This must only\n+     * be called with the queueLock held.\n      *\n      * @param p The PosixProcess.\n      */\n-    void addProcessToMap(PosixProcess p)\n+    void addToLiveProcesses(PosixProcess p)\n     {\n-      pidToProcess.put(new Long(p.pid), p);\n+      liveProcesses.add(p);\n     }\n \n     /**\n@@ -122,61 +110,66 @@ public void run()\n       // Now ready to accept requests.\n       synchronized (this)\n         {\n-\t  ready = true;\n-\t  this.notifyAll();\n+          ready = true;\n+          this.notifyAll();\n         }\n \n       for (;;)\n         {\n-\t  try\n-\t    {\n-\t      synchronized (queueLock)\n-\t        {\n-\t\t  boolean haveMoreChildren = reap();\n-\t\t  if (! haveMoreChildren && queue.size() == 0)\n-\t\t    {\n-\t\t      // This reaper thread could exit, but we\n-\t\t      // keep it alive for a while in case\n-\t\t      // someone wants to start more Processes.\n-\t\t      try\n-\t\t        {\n-\t\t\t  queueLock.wait(1000L);\n-\t\t\t  if (queue.size() == 0)\n-\t\t\t    {\n-\t\t\t      processManager = null;\n-\t\t\t      return; // Timed out.\n-\t\t\t    }\n-\t\t        }\n-\t\t      catch (InterruptedException ie)\n-\t\t        {\n-\t\t\t  // Ignore and exit the thread.\n-\t\t\t  return;\n-\t\t        }\n-\t\t    }\n-\t\t  while (queue.size() > 0)\n-\t\t    {\n-\t\t      PosixProcess p = (PosixProcess) queue.remove(0);\n-\t\t      p.spawn(this);\n-\t\t    }\n-\t        }\n-\n-\t      // Wait for a SIGCHLD from either an exiting\n-\t      // process or the startExecuting() method.  This\n-\t      // is done outside of the synchronized block to\n-\t      // allow other threads to enter and submit more\n-\t      // jobs.\n-\t      waitForSignal();\n-\t    }\n-\t  catch (Exception ex)\n-\t    {\n-\t      ex.printStackTrace(System.err);\n-\t    }\n+          try\n+            {\n+              synchronized (queueLock)\n+                {\n+                  Iterator<PosixProcess> processIterator =\n+                    liveProcesses.iterator();\n+                  while (processIterator.hasNext())\n+                    {\n+                      boolean reaped = reap(processIterator.next());\n+                      if (reaped)\n+                        processIterator.remove();\n+                    }\n+                  if (liveProcesses.size() == 0 && queue.size() == 0)\n+                    {\n+                      // This reaper thread could exit, but we keep it\n+                      // alive for a while in case someone wants to\n+                      // start more Processes.\n+                      try\n+                        {\n+                          queueLock.wait(1000L);\n+                          if (queue.size() == 0)\n+                            {\n+                              processManager = null;\n+                              return; // Timed out.\n+                            }\n+                        }\n+                      catch (InterruptedException ie)\n+                        {\n+                          // Ignore and exit the thread.\n+                          return;\n+                        }\n+                    }\n+                  while (queue.size() > 0)\n+                    {\n+                      PosixProcess p = queue.remove(0);\n+                      p.spawn(this);\n+                    }\n+                }\n+\n+              // Wait for a SIGCHLD from either an exiting process or\n+              // the startExecuting() method.  This is done outside of\n+              // the synchronized block to allow other threads to\n+              // enter and submit more jobs.\n+              waitForSignal();\n+            }\n+          catch (Exception ex)\n+            {\n+              ex.printStackTrace(System.err);\n+            }\n         }\n     }\n \n     /**\n      * Setup native signal handlers and other housekeeping things.\n-     *\n      */\n     private native void init();\n \n@@ -187,12 +180,14 @@ public void run()\n     private native void waitForSignal();\n \n     /**\n-     * Try to reap as many children as possible without blocking.\n+     * Try to reap the specified child without blocking.\n+     *\n+     * @param p the process to try to reap.\n      *\n-     * @return true if more live children exist.\n+     * @return true if the process terminated.\n      *\n      */\n-    private native boolean reap();\n+    private native boolean reap(PosixProcess p);\n \n     /**\n      * Send SIGCHLD to the reaper thread.\n@@ -295,7 +290,7 @@ public synchronized InputStream getErrorStream()\n       returnedErrorStream = EOFInputStream.instance;\n     else\n       returnedErrorStream = errorStream;\n-            \n+\n     return returnedErrorStream;\n   }\n \n@@ -308,7 +303,7 @@ public synchronized InputStream getInputStream()\n       returnedInputStream = EOFInputStream.instance;\n     else\n       returnedInputStream = inputStream;\n-            \n+\n     return returnedInputStream;\n   }\n \n@@ -329,7 +324,7 @@ public int waitFor() throws InterruptedException\n \n   /**\n    * Start this process running.  This should only be called by the\n-   * ProcessManager.\n+   * ProcessManager with the queueLock held.\n    *\n    * @param pm The ProcessManager that made the call.\n    */\n@@ -342,7 +337,7 @@ void spawn(ProcessManager pm)\n \t// There is no race with reap() in the pidToProcess map\n \t// because this is always called from the same thread\n \t// doing the reaping.\n-\tpm.addProcessToMap(this);\n+\tpm.addToLiveProcesses(this);\n \tstate = STATE_RUNNING;\n \t// Notify anybody waiting on state change.\n \tthis.notifyAll();\n@@ -426,7 +421,7 @@ void spawn(ProcessManager pm)\n   private Throwable exception;\n \n   /** The process id.  This is cast to a pid_t on the native side. */\n-  private long pid;\n+  long pid;\n \n   // FIXME: Why doesn't the friend declaration in PosixProcess.h\n   // allow PosixProcess$ProcessManager native code access these"}, {"sha": "c7b8b6e5eb06570c475c19f27a2220d137762510", "filename": "libjava/java/lang/natPosixProcess.cc", "status": "modified", "additions": 85, "deletions": 72, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fjava%2Flang%2FnatPosixProcess.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fjava%2Flang%2FnatPosixProcess.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatPosixProcess.cc?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39", "patch": "@@ -30,6 +30,8 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <posix.h>\n+#include <posix-threads.h>\n \n #include <java/lang/PosixProcess$ProcessManager.h>\n #include <java/lang/PosixProcess.h>\n@@ -48,6 +50,7 @@ details.  */\n #include <java/lang/PosixProcess$EOFInputStream.h>\n \n using gnu::java::nio::channels::FileChannelImpl;\n+using namespace java::lang;\n \n extern char **environ;\n \n@@ -91,36 +94,73 @@ myclose (int &fd)\n   fd = -1;\n }\n \n+namespace\n+{\n+  struct ProcessManagerInternal\n+  {\n+    int pipe_ends[2];\n+    struct sigaction old_sigaction;\n+  };\n+}\n+\n+\n // There has to be a signal handler in order to be able to\n // sigwait() on SIGCHLD.  The information passed is ignored as it\n // will be recovered by the waitpid() call.\n static void\n-sigchld_handler (int)\n+sigchld_handler (int sig, siginfo_t *si, void *third)\n {\n-  // Ignore.\n+  if (PosixProcess$ProcessManager::nativeData != NULL)\n+    {\n+      ProcessManagerInternal *pmi =\n+        (ProcessManagerInternal *)PosixProcess$ProcessManager::nativeData;\n+      char c = 0;\n+      ::write(pmi->pipe_ends[1], &c, 1);\n+      if (pmi->old_sigaction.sa_handler != SIG_DFL\n+          && pmi->old_sigaction.sa_handler != SIG_IGN)\n+        {\n+          if ((pmi->old_sigaction.sa_flags & SA_SIGINFO) != 0)\n+            pmi->old_sigaction.sa_sigaction(sig, si, third);\n+          else\n+            (*pmi->old_sigaction.sa_handler)(sig);\n+        }\n+    }\n }\n \n \n // Get ready to enter the main reaper thread loop.\n void\n java::lang::PosixProcess$ProcessManager::init ()\n {\n-  using namespace java::lang;\n-  // Remenber our PID so other threads can kill us.\n-  reaperPID = (jlong) pthread_self ();\n+  // The nativeData is static to avoid races installing the signal\n+  // handler in the case that it is chained.\n+  if (nativeData == NULL )\n+    {\n+      ProcessManagerInternal *pmi =\n+        (ProcessManagerInternal *)JvAllocBytes(sizeof(ProcessManagerInternal));\n \n-  // SIGCHLD is blocked in all threads in posix-threads.cc.\n-  // Setup the SIGCHLD handler.\n-  struct sigaction sa;\n-  memset (&sa, 0, sizeof (sa));\n+      if (0 != ::pipe(pmi->pipe_ends))\n+        goto error;\n \n-  sa.sa_handler = sigchld_handler;\n-  // We only want signals when the things exit.\n-  sa.sa_flags = SA_NOCLDSTOP;\n+      // Make writing non-blocking so that the signal handler will\n+      // never block.\n+      int fl = ::fcntl(pmi->pipe_ends[1], F_GETFL);\n+      ::fcntl(pmi->pipe_ends[1], F_SETFL, fl | O_NONBLOCK);\n \n-  if (-1 == sigaction (SIGCHLD, &sa, NULL))\n-    goto error;\n+      nativeData = (::gnu::gcj::RawDataManaged *)pmi;\n \n+      // SIGCHLD is blocked in all threads in posix-threads.cc.\n+      // Setup the SIGCHLD handler.\n+      struct sigaction sa;\n+      memset (&sa, 0, sizeof (sa));\n+\n+      sa.sa_sigaction = sigchld_handler;\n+      // We only want signals when the things exit.\n+      sa.sa_flags = SA_NOCLDSTOP | SA_SIGINFO;\n+\n+      if (-1 == sigaction (SIGCHLD, &sa, &pmi->old_sigaction))\n+        goto error;\n+    }\n   // All OK.\n   return;\n \n@@ -132,79 +172,52 @@ void\n java::lang::PosixProcess$ProcessManager::waitForSignal ()\n {\n   // Wait for SIGCHLD\n-  sigset_t mask;\n-  pthread_sigmask (0, NULL, &mask);\n-  sigdelset (&mask, SIGCHLD);\n+  _Jv_UnBlockSigchld();\n+  ProcessManagerInternal *pmi = (ProcessManagerInternal *)nativeData;\n \n-  // Use sigsuspend() instead of sigwait() as sigwait() doesn't play\n-  // nicely with the GC's use of signals.\n-  sigsuspend (&mask);\n+  // Try to read multiple (64) notifications in one go.\n+  char c[64];\n+ ::read(pmi->pipe_ends[0], c, sizeof (c));\n \n-  // Do not check sigsuspend return value.  The only legitimate return\n-  // is EINTR, but there is a known kernel bug affecting alpha-linux\n-  // wrt sigsuspend+handler+sigreturn that can result in a return value\n-  // of __NR_sigsuspend and errno unset.  Don't fail unnecessarily on\n-  // older kernel versions.\n+  _Jv_BlockSigchld();\n \n-  // All OK.\n   return;\n }\n \n-jboolean java::lang::PosixProcess$ProcessManager::reap ()\n+jboolean java::lang::PosixProcess$ProcessManager::reap (PosixProcess *p)\n {\n-  using namespace java::lang;\n-\n-  pid_t pid;\n-\n-  for (;;)\n-    {\n-      // Get the return code from a dead child process.\n-      int status;\n-      pid = waitpid ((pid_t) - 1, &status, WNOHANG);\n-      if (pid == -1)\n-\t{\n-\t  if (errno == ECHILD)\n-\t    return false;\n-\t  else\n-\t    goto error;\n-\t}\n-\n-      if (pid == 0)\n-        return true;   // No children to wait for.\n-\n-      // Look up the process in our pid map.\n-      PosixProcess * process = removeProcessFromMap ((jlong) pid);\n-\n-      // Note that if process==NULL, then we have an unknown child.\n-      // This is not common, but can happen, and isn't an error.\n-      if (process)\n-\t{\n-\t  JvSynchronize sync (process);\n-\t  process->status = WIFEXITED (status) ? WEXITSTATUS (status) : -1;\n-\t  process->state = PosixProcess::STATE_TERMINATED;\n-          process->processTerminationCleanup();\n-\t  process->notifyAll ();\n-\t}\n-    }\n-\n-error:\n-  throw new InternalError (JvNewStringUTF (strerror (errno)));\n+  pid_t rv;\n+\n+  // Try to get the return code from the child process.\n+  int status;\n+  rv = ::waitpid ((pid_t)p->pid, &status, WNOHANG);\n+  if (rv == -1)\n+    throw new InternalError (JvNewStringUTF (strerror (errno)));\n+\n+  if (rv == 0)\n+    return false;   // No children to wait for.\n+\n+  JvSynchronize sync (p);\n+  p->status = WIFEXITED (status) ? WEXITSTATUS (status) : -1;\n+  p->state = PosixProcess::STATE_TERMINATED;\n+  p->processTerminationCleanup();\n+  p->notifyAll ();\n+  return true;\n }\n \n void\n java::lang::PosixProcess$ProcessManager::signalReaper ()\n {\n-  int c = pthread_kill ((pthread_t) reaperPID, SIGCHLD);\n-  if (c == 0)\n-    return;\n-  // pthread_kill() failed.\n-  throw new InternalError (JvNewStringUTF (strerror (c)));\n+  ProcessManagerInternal *pmi = (ProcessManagerInternal *)nativeData;\n+  char c = 0;\n+  ::write(pmi->pipe_ends[1], &c, 1);\n+  // Ignore errors.  If EPIPE the reaper has already exited.\n }\n \n void\n java::lang::PosixProcess::nativeDestroy ()\n {\n-  int c = kill ((pid_t) pid, SIGKILL);\n+  int c = ::kill ((pid_t) pid, SIGKILL);\n   if (c == 0)\n     return;\n   // kill() failed.\n@@ -427,9 +440,9 @@ java::lang::PosixProcess::nativeSpawn ()\n       char c;\n       int r = read (msgp[0], &c, 1);\n       if (r == -1)\n-      throw new IOException (JvNewStringUTF (strerror (errno)));\n+        throw new IOException (JvNewStringUTF (strerror (errno)));\n       else if (r != 0)\n-      throw new IOException (JvNewStringUTF (strerror (c)));\n+        throw new IOException (JvNewStringUTF (strerror (c)));\n     }\n   catch (java::lang::Throwable *thrown)\n     {"}, {"sha": "287d6b79a6f3e779c3e4be3e9dfef81bd1cac906", "filename": "libjava/posix-threads.cc", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fposix-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0dbf3490bd297d601118bc95a2a8640aa73a39/libjava%2Fposix-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix-threads.cc?ref=8c0dbf3490bd297d601118bc95a2a8640aa73a39", "patch": "@@ -14,6 +14,7 @@ details.  */\n #include <config.h>\n \n #include \"posix.h\"\n+#include \"posix-threads.h\"\n \n // If we're using the Boehm GC, then we need to override some of the\n // thread primitives.  This is fairly gross.\n@@ -472,8 +473,8 @@ handle_intr (int)\n   // Do nothing.\n }\n \n-static void\n-block_sigchld()\n+void\n+_Jv_BlockSigchld()\n {\n   sigset_t mask;\n   sigemptyset (&mask);\n@@ -483,6 +484,17 @@ block_sigchld()\n     JvFail (strerror (c));\n }\n \n+void\n+_Jv_UnBlockSigchld()\n+{\n+  sigset_t mask;\n+  sigemptyset (&mask);\n+  sigaddset (&mask, SIGCHLD);\n+  int c = pthread_sigmask (SIG_UNBLOCK, &mask, NULL);\n+  if (c != 0)\n+    JvFail (strerror (c));\n+}\n+\n void\n _Jv_InitThreads (void)\n {\n@@ -501,7 +513,7 @@ _Jv_InitThreads (void)\n \n   // Block SIGCHLD here to ensure that any non-Java threads inherit the new \n   // signal mask.\n-  block_sigchld();\n+  _Jv_BlockSigchld();\n \n   // Check/set the thread stack size.\n   size_t min_ss = 32 * 1024;\n@@ -581,7 +593,7 @@ _Jv_ThreadRegister (_Jv_Thread_t *data)\n       }\n # endif\n   // Block SIGCHLD which is used in natPosixProcess.cc.\n-  block_sigchld();\n+  _Jv_BlockSigchld();\n }\n \n void\n@@ -629,7 +641,7 @@ _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n \n   // Block SIGCHLD which is used in natPosixProcess.cc.\n   // The current mask is inherited by the child thread.\n-  block_sigchld();\n+  _Jv_BlockSigchld();\n \n   param.sched_priority = thread->getPriority();\n "}]}