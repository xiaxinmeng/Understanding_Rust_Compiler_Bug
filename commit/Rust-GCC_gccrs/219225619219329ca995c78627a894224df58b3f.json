{"sha": "219225619219329ca995c78627a894224df58b3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE5MjI1NjE5MjE5MzI5Y2E5OTVjNzg2MjdhODk0MjI0ZGY1OGIzZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2010-11-09T21:44:19Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2010-11-09T21:44:19Z"}, "message": "Improve powerpc floating point rounding\n\nFrom-SVN: r166510", "tree": {"sha": "188dd25b42448ce9d4a19497d84bc0355c876a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/188dd25b42448ce9d4a19497d84bc0355c876a5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/219225619219329ca995c78627a894224df58b3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/219225619219329ca995c78627a894224df58b3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/219225619219329ca995c78627a894224df58b3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/219225619219329ca995c78627a894224df58b3f/comments", "author": null, "committer": null, "parents": [{"sha": "9b999dc5ea45237cc7accead90a33e9c4a6893f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b999dc5ea45237cc7accead90a33e9c4a6893f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b999dc5ea45237cc7accead90a33e9c4a6893f5"}], "stats": {"total": 591, "additions": 351, "deletions": 240}, "files": [{"sha": "77b5e7e93b11f892be799336b3a01777b834d448", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/219225619219329ca995c78627a894224df58b3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/219225619219329ca995c78627a894224df58b3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=219225619219329ca995c78627a894224df58b3f", "patch": "@@ -1,3 +1,43 @@\n+2010-11-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.md (floatsi<mode>2_lfiwax): Rewrite so\n+\tsplit occurs before reload, and we allocate memory at the time of\n+\tthe split, not during expansion.  Add attributes.\n+\t(floatsi<mode>2_lfiwax_mem): Ditto.\n+\t(floatunssi<mode>2_lfiwzx): Ditto.\n+\t(floatunssi<mode>2_lfiwzx_mem): Ditto.\n+\t(floatsidf2): Ditto.\n+\t(floatunssisf2): Ditto.\n+\t(floatunssidf2): Ditto.\n+\t(fix_trunc<mode>si2): Ditto.\n+\t(fix_trunc<mode>si2_stfiwx): Ditto.\n+\t(fix_trunc<mode>si2_internal): Ditto.\n+\t(fix_trunc<mode>si2): Ditto.\n+\t(fix_trunc<mode>di2): Ditto.\n+\t(fixuns_trunc<mode>si2_stfiwx): Ditto.\n+\t(floatsisf2): Ditto.\n+\t(floatdidf2_mem): Ditto.\n+\t(floatunsdidf2_mem): Ditto.\n+\t(floatunsdidf2): Ditto.\n+\t(floatdisf2_internal1): Ditto.\n+\t(floatdisf2_mem): Ditto.\n+\t(floatunsdisf2_mem): Ditto.\n+\t(floatsi<mode>2_lfiwax_mem2): Delete.\n+\t(floatunssi<mode>2_lfiwzx_mem2): Ditto.\n+\t(fix_trunc<mode>si2_mem): Ditto.\n+\t(fixuns_trunc<mode>si2_mem): Ditto.\n+\t(round32<mode>2_fprs): New combiner insn to combine (double)(int)\n+\ttype operations to reduce copying the values to multiple memory\n+\tslots.\n+\t(roundu32<mode>2_fprs): Ditto.\n+\n+\t* config/rs6000/rs6000.c (rs6000_address_for_fpconvert): Handle\n+\tPRE_INC, PRE_DEC, PRE_MODIFY.\n+\t(rs6000_expand_convert_si_to_sfdf): Delete, no longer used.\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_expand_convert_si_to_sfdf):\n+\tDelete prototype.\n+\n 2010-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/43808"}, {"sha": "e5c6f0d85fe45b62723fab0082629c2f1bf36435", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/219225619219329ca995c78627a894224df58b3f/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/219225619219329ca995c78627a894224df58b3f/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=219225619219329ca995c78627a894224df58b3f", "patch": "@@ -130,7 +130,6 @@ extern rtx rs6000_machopic_legitimize_pic_address (rtx, enum machine_mode,\n \t\t\t\t\t\t   rtx);\n extern rtx rs6000_address_for_fpconvert (rtx);\n extern rtx rs6000_allocate_stack_temp (enum machine_mode, bool, bool);\n-extern void rs6000_expand_convert_si_to_sfdf (rtx, rtx, bool);\n extern int rs6000_loop_align (rtx);\n #endif /* RTX_CODE */\n "}, {"sha": "e441c70bd9b24a793ebcfdf417f8c7fcbc392e0b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 68, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/219225619219329ca995c78627a894224df58b3f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/219225619219329ca995c78627a894224df58b3f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=219225619219329ca995c78627a894224df58b3f", "patch": "@@ -27230,82 +27230,30 @@ rs6000_address_for_fpconvert (rtx x)\n   addr = XEXP (x, 0);\n   if (! legitimate_indirect_address_p (addr, strict_p)\n       && ! legitimate_indexed_address_p (addr, strict_p))\n-    x = replace_equiv_address (x, copy_addr_to_reg (addr));\n-\n-  return x;\n-}\n-\n-/* Expand 32-bit int -> floating point conversions.  Return true if\n-   successful.  */\n-\n-void\n-rs6000_expand_convert_si_to_sfdf (rtx dest, rtx src, bool unsigned_p)\n-{\n-  enum machine_mode dmode = GET_MODE (dest);\n-  rtx (*func_si) (rtx, rtx, rtx, rtx);\n-  rtx (*func_si_mem) (rtx, rtx);\n-  rtx (*func_di) (rtx, rtx);\n-  rtx reg, stack;\n-\n-  gcc_assert (GET_MODE (src) == SImode);\n-\n-  if (dmode == SFmode)\n     {\n-      if (unsigned_p)\n+      if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n \t{\n-\t  gcc_assert (TARGET_FCFIDUS && TARGET_LFIWZX);\n-\t  func_si = gen_floatunssisf2_lfiwzx;\n-\t  func_si_mem = gen_floatunssisf2_lfiwzx_mem;\n-\t  func_di = gen_floatunsdisf2;\n+\t  rtx reg = XEXP (addr, 0);\n+\t  HOST_WIDE_INT size = GET_MODE_SIZE (GET_MODE (x));\n+\t  rtx size_rtx = GEN_INT ((GET_CODE (addr) == PRE_DEC) ? -size : size);\n+\t  gcc_assert (REG_P (reg));\n+\t  emit_insn (gen_add3_insn (reg, reg, size_rtx));\n+\t  addr = reg;\n \t}\n-      else\n+      else if (GET_CODE (addr) == PRE_MODIFY)\n \t{\n-\t  gcc_assert (TARGET_FCFIDS && TARGET_LFIWAX);\n-\t  func_si = gen_floatsisf2_lfiwax;\n-\t  func_si_mem = gen_floatsisf2_lfiwax_mem;\n-\t  func_di = gen_floatdisf2;\n+\t  rtx reg = XEXP (addr, 0);\n+\t  rtx expr = XEXP (addr, 1);\n+\t  gcc_assert (REG_P (reg));\n+\t  gcc_assert (GET_CODE (expr) == PLUS);\n+\t  emit_insn (gen_add3_insn (reg, XEXP (expr, 0), XEXP (expr, 1)));\n+\t  addr = reg;\n \t}\n-    }\n \n-  else if (dmode == DFmode)\n-    {\n-      if (unsigned_p)\n-\t{\n-\t  gcc_assert (TARGET_FCFIDU && TARGET_LFIWZX);\n-\t  func_si = gen_floatunssidf2_lfiwzx;\n-\t  func_si_mem = gen_floatunssidf2_lfiwzx_mem;\n-\t  func_di = gen_floatunsdidf2;\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (TARGET_FCFID && TARGET_LFIWAX);\n-\t  func_si = gen_floatsidf2_lfiwax;\n-\t  func_si_mem = gen_floatsidf2_lfiwax_mem;\n-\t  func_di = gen_floatdidf2;\n-\t}\n+      x = replace_equiv_address (x, copy_addr_to_reg (addr));\n     }\n \n-  else\n-    gcc_unreachable ();\n-\n-  if (MEM_P (src))\n-    {\n-      src = rs6000_address_for_fpconvert (src);\n-      emit_insn (func_si_mem (dest, src));\n-    }\n-  else if (!TARGET_MFPGPR)\n-    {\n-      reg = gen_reg_rtx (DImode);\n-      stack = rs6000_allocate_stack_temp (SImode, false, true);\n-      emit_insn (func_si (dest, src, stack, reg));\n-    }\n-  else\n-    {\n-      if (!REG_P (src))\n-\tsrc = force_reg (SImode, src);\n-      reg = convert_to_mode (DImode, src, unsigned_p);\n-      emit_insn (func_di (dest, reg));\n-    }\n+  return x;\n }\n \n #include \"gt-rs6000.h\""}, {"sha": "200a3b1e9eda57e293ebd8a0cf52cd26be8a38fd", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 245, "deletions": 169, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/219225619219329ca995c78627a894224df58b3f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/219225619219329ca995c78627a894224df58b3f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=219225619219329ca995c78627a894224df58b3f", "patch": "@@ -6605,68 +6605,73 @@\n   \"lfiwax %0,%y1\"\n   [(set_attr \"type\" \"fpload\")])\n \n+; This split must be run before register allocation because it allocates the\n+; memory slot that is needed to move values to/from the FPR.  We don't allocate\n+; it earlier to allow for the combiner to merge insns together where it might\n+; not be needed and also in case the insns are deleted as dead code.\n+\n (define_insn_and_split \"floatsi<mode>2_lfiwax\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>,<rreg2>\")\n-\t(float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"Z,r\")))\n-   (clobber (match_operand:SI 2 \"indexed_or_indirect_operand\" \"=Z,Z\"))\n-   (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"=d,d\"))]\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d\")\n+\t(float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n-   && <SI_CONVERT_FP>\"\n+   && <SI_CONVERT_FP> && can_create_pseudo_p ()\"\n   \"#\"\n-  \"MEM_P (operands[1]) || reload_completed\"\n+  \"\"\n   [(pc)]\n   \"\n {\n-  if (MEM_P (operands[1]))\n-    {\n-      operands[1] = rs6000_address_for_fpconvert (operands[1]);\n-      emit_insn (gen_lfiwax (operands[3], operands[1]));\n-    }\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp;\n+\n+  if (!MEM_P (src) && TARGET_MFPGPR && TARGET_POWERPC64)\n+    tmp = convert_to_mode (DImode, src, false);\n   else\n     {\n-      emit_move_insn (operands[2], operands[1]);\n-      emit_insn (gen_lfiwax (operands[3], operands[2]));\n+      tmp = operands[2];\n+      if (GET_CODE (tmp) == SCRATCH)\n+\ttmp = gen_reg_rtx (DImode);\n+      if (MEM_P (src))\n+\t{\n+\t  src = rs6000_address_for_fpconvert (src);\n+\t  emit_insn (gen_lfiwax (tmp, src));\n+\t}\n+      else\n+\t{\n+\t  rtx stack = rs6000_allocate_stack_temp (SImode, false, true);\n+\t  emit_move_insn (stack, src);\n+\t  emit_insn (gen_lfiwax (tmp, stack));\n+\t}\n     }\n-  emit_insn (gen_floatdi<mode>2 (operands[0], operands[3]));\n+  emit_insn (gen_floatdi<mode>2 (dest, tmp));\n   DONE;\n }\"\n-  [(set_attr \"length\" \"8,12\")])\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"fpload\")])\n \n (define_insn_and_split \"floatsi<mode>2_lfiwax_mem\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n-\t(float:SFDF (match_operand:SI 1 \"memory_operand\" \"Z\")))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n-   && <SI_CONVERT_FP>\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(pc)]\n-  \"\n-{\n-  emit_insn (gen_lfiwax (operands[2], operands[1]));\n-  emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n-  DONE;\n-}\"\n-  [(set_attr \"length\" \"8\")])\n-\n-(define_insn_and_split \"floatsi<mode>2_lfiwax_mem2\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d,<rreg2>\")\n \t(float:SFDF\n \t (sign_extend:DI\n-\t  (match_operand:SI 1 \"memory_operand\" \"Z\"))))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n+\t  (match_operand:SI 1 \"memory_operand\" \"Z,Z\"))))\n+   (clobber (match_scratch:DI 2 \"=0,d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n    && <SI_CONVERT_FP>\"\n   \"#\"\n-  \"&& reload_completed\"\n+  \"\"\n   [(pc)]\n   \"\n {\n+  operands[1] = rs6000_address_for_fpconvert (operands[1]);\n+  if (GET_CODE (operands[2]) == SCRATCH)\n+    operands[2] = gen_reg_rtx (DImode);\n   emit_insn (gen_lfiwax (operands[2], operands[1]));\n   emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n   DONE;\n }\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"fpload\")])\n \n (define_insn \"lfiwzx\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n@@ -6677,67 +6682,67 @@\n   [(set_attr \"type\" \"fpload\")])\n \n (define_insn_and_split \"floatunssi<mode>2_lfiwzx\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>,<rreg2>\")\n-\t(unsigned_float:SFDF (match_operand:SI 1 \"gpc_reg_operand\" \"Z,r\")))\n-   (clobber (match_operand:SI 2 \"indexed_or_indirect_operand\" \"=Z,Z\"))\n-   (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"=d,d\"))]\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d\")\n+\t(unsigned_float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n    && <SI_CONVERT_FP>\"\n   \"#\"\n-  \"MEM_P (operands[1]) || reload_completed\"\n+  \"\"\n   [(pc)]\n   \"\n {\n-  if (MEM_P (operands[1]))\n-    {\n-      operands[1] = rs6000_address_for_fpconvert (operands[1]);\n-      emit_insn (gen_lfiwzx (operands[3], operands[1]));\n-    }\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp;\n+\n+  if (!MEM_P (src) && TARGET_MFPGPR && TARGET_POWERPC64)\n+    tmp = convert_to_mode (DImode, src, true);\n   else\n     {\n-      emit_move_insn (operands[2], operands[1]);\n-      emit_insn (gen_lfiwzx (operands[3], operands[2]));\n+      tmp = operands[2];\n+      if (GET_CODE (tmp) == SCRATCH)\n+\ttmp = gen_reg_rtx (DImode);\n+      if (MEM_P (src))\n+\t{\n+\t  src = rs6000_address_for_fpconvert (src);\n+\t  emit_insn (gen_lfiwzx (tmp, src));\n+\t}\n+      else\n+\t{\n+\t  rtx stack = rs6000_allocate_stack_temp (SImode, false, true);\n+\t  emit_move_insn (stack, src);\n+\t  emit_insn (gen_lfiwzx (tmp, stack));\n+\t}\n     }\n-  emit_insn (gen_floatdi<mode>2 (operands[0], operands[3]));\n+  emit_insn (gen_floatdi<mode>2 (dest, tmp));\n   DONE;\n }\"\n-  [(set_attr \"length\" \"8,12\")])\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"fpload\")])\n \n (define_insn_and_split \"floatunssi<mode>2_lfiwzx_mem\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n-\t(unsigned_float:SFDF (match_operand:SI 1 \"memory_operand\" \"Z\")))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n-   && <SI_CONVERT_FP>\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(pc)]\n-  \"\n-{\n-  emit_insn (gen_lfiwzx (operands[2], operands[1]));\n-  emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n-  DONE;\n-}\"\n-  [(set_attr \"length\" \"8\")])\n-\n-(define_insn_and_split \"floatunssi<mode>2_lfiwzx_mem2\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d,<rreg2>\")\n \t(unsigned_float:SFDF\n \t (zero_extend:DI\n-\t  (match_operand:SI 1 \"memory_operand\" \"Z\"))))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n+\t  (match_operand:SI 1 \"memory_operand\" \"Z,Z\"))))\n+   (clobber (match_scratch:DI 2 \"=0,d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n    && <SI_CONVERT_FP>\"\n   \"#\"\n-  \"&& reload_completed\"\n+  \"\"\n   [(pc)]\n   \"\n {\n+  operands[1] = rs6000_address_for_fpconvert (operands[1]);\n+  if (GET_CODE (operands[2]) == SCRATCH)\n+    operands[2] = gen_reg_rtx (DImode);\n   emit_insn (gen_lfiwzx (operands[2], operands[1]));\n   emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n   DONE;\n }\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"fpload\")])\n \n ; For each of these conversions, there is a define_expand, a define_insn\n ; with a '#' template, and a define_split (with C code).  The idea is\n@@ -6765,7 +6770,7 @@\n     }\n   else if (TARGET_LFIWAX && TARGET_FCFID)\n     {\n-      rs6000_expand_convert_si_to_sfdf (operands[0], operands[1], false);\n+      emit_insn (gen_floatsidf2_lfiwax (operands[0], operands[1]));\n       DONE;\n     }\n   else if (TARGET_FCFID)\n@@ -6819,7 +6824,8 @@\n   emit_insn (gen_subdf3 (operands[0], operands[5], operands[3]));\n   DONE;\n }\"\n-  [(set_attr \"length\" \"24\")])\n+  [(set_attr \"length\" \"24\")\n+   (set_attr \"type\" \"fp\")])\n \n ;; If we don't have a direct conversion to single precision, don't enable this\n ;; conversion for 32-bit without fast math, because we don't have the insn to\n@@ -6842,7 +6848,7 @@\n     }\n   else if (TARGET_LFIWZX && TARGET_FCFIDUS)\n     {\n-      rs6000_expand_convert_si_to_sfdf (operands[0], operands[1], true);\n+      emit_insn (gen_floatunssisf2_lfiwzx (operands[0], operands[1]));\n       DONE;\n     }\n   else\n@@ -6876,8 +6882,8 @@\n     }\n   else if (TARGET_LFIWZX && TARGET_FCFID)\n     {\n-       rs6000_expand_convert_si_to_sfdf (operands[0], operands[1], true);\n-       DONE;\n+      emit_insn (gen_floatunssidf2_lfiwzx (operands[0], operands[1]));\n+      DONE;\n     }\n   else if (TARGET_FCFID)\n     {\n@@ -6927,7 +6933,8 @@\n   emit_insn (gen_subdf3 (operands[0], operands[5], operands[3]));\n   DONE;\n }\"\n-  [(set_attr \"length\" \"20\")])\n+  [(set_attr \"length\" \"20\")\n+   (set_attr \"type\" \"fp\")])\n \n (define_expand \"fix_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n@@ -6941,12 +6948,7 @@\n       rtx tmp, stack;\n \n       if (TARGET_STFIWX)\n-\t{\n-\t  tmp = gen_reg_rtx (DImode);\n-\t  stack = rs6000_allocate_stack_temp (SImode, false, true);\n-\t  emit_insn (gen_fix_trunc<mode>si2_stfiwx (operands[0], operands[1],\n-\t\t\t\t\t\t    tmp, stack));\n-\t}\n+\temit_insn (gen_fix_trunc<mode>si2_stfiwx (operands[0], operands[1]));\n       else\n \t{\n \t  tmp = gen_reg_rtx (DImode);\n@@ -6958,58 +6960,56 @@\n     }\n }\")\n \n+; Like the convert to float patterns, this insn must be split before\n+; register allocation so that it can allocate the memory slot if it\n+; needed\n (define_insn_and_split \"fix_trunc<mode>si2_stfiwx\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")))\n-   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=d\"))\n-   (clobber (match_operand:SI 3 \"indexed_or_indirect_operand\" \"=Z\"))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && (<MODE>mode != SFmode || TARGET_SINGLE_FLOAT)\n-   && TARGET_STFIWX\"\n+   && TARGET_STFIWX && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& reload_completed\"\n+  \"\"\n   [(pc)]\n-  \"\n {\n-  emit_insn (gen_fctiwz_<mode> (operands[2], operands[1]));\n-  if (TARGET_MFPGPR && TARGET_POWERPC64 && REG_P (operands[0])\n-      && INT_REGNO_P (REGNO (operands[0])))\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp = operands[2];\n+\n+  if (GET_CODE (tmp) == SCRATCH)\n+    tmp = gen_reg_rtx (DImode);\n+\n+  emit_insn (gen_fctiwz_<mode> (tmp, src));\n+  if (MEM_P (dest))\n     {\n-      rtx reg = gen_lowpart (DImode, operands[0]);\n-      emit_move_insn (reg, operands[2]);\n+      dest = rs6000_address_for_fpconvert (dest);\n+      emit_insn (gen_stfiwx (dest, tmp));\n+      DONE;\n+    }\n+  else if (TARGET_MFPGPR && TARGET_POWERPC64)\n+    {\n+      dest = gen_lowpart (DImode, dest);\n+      emit_move_insn (dest, tmp);\n+      DONE;\n     }\n   else\n     {\n-      emit_insn (gen_stfiwx (operands[3], operands[2]));\n-      emit_move_insn (operands[0], operands[3]);\n+      rtx stack = rs6000_allocate_stack_temp (SImode, false, true);\n+      emit_insn (gen_stfiwx (stack, tmp));\n+      emit_move_insn (dest, stack);\n+      DONE;\n     }\n-  DONE;\n-}\"\n-  [(set_attr \"length\" \"12\")])\n-\n-(define_insn_and_split \"*fix_trunc<mode>si2_mem\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n-\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && (<MODE>mode != SFmode || TARGET_SINGLE_FLOAT)\n-   && TARGET_STFIWX\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(pc)]\n-  \"\n-{\n-  emit_insn (gen_fctiwz_<mode> (operands[2], operands[1]));\n-  emit_insn (gen_stfiwx (operands[0], operands[2]));\n-  DONE;\n-}\"\n-  [(set_attr \"length\" \"8\")])\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"fp\")])\n \n (define_insn_and_split \"fix_trunc<mode>si2_internal\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg>\")))\n-   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=d\"))\n-   (clobber (match_operand:DI 3 \"offsettable_mem_operand\" \"=o\"))]\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,?r\")\n+\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d,<rreg>\")))\n+   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=1,d\"))\n+   (clobber (match_operand:DI 3 \"offsettable_mem_operand\" \"=o,o\"))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT && TARGET_FPRS \n    && TARGET_DOUBLE_FLOAT\"\n   \"#\"\n@@ -7026,7 +7026,8 @@\n   emit_move_insn (operands[0], lowword);\n   DONE;\n }\"\n-  [(set_attr \"length\" \"16\")])\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"type\" \"fp\")])\n \n (define_expand \"fix_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n@@ -7053,59 +7054,51 @@\n {\n   if (!<E500_CONVERT>)\n     {\n-      rtx tmp = gen_reg_rtx (DImode);\n-      rtx stack = rs6000_allocate_stack_temp (SImode, false, true);\n-      emit_insn (gen_fixuns_trunc<mode>si2_stfiwx (operands[0], operands[1],\n-\t\t\t\t\t\t   tmp, stack));\n+      emit_insn (gen_fixuns_trunc<mode>si2_stfiwx (operands[0], operands[1]));\n       DONE;\n     }\n }\")\n \n (define_insn_and_split \"fixuns_trunc<mode>si2_stfiwx\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unsigned_fix:SI\n-\t (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")))\n-   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=d\"))\n-   (clobber (match_operand:SI 3 \"indexed_or_indirect_operand\" \"=Z\"))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\n-   && TARGET_STFIWX\"\n+   && TARGET_STFIWX && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& reload_completed\"\n+  \"\"\n   [(pc)]\n-  \"\n {\n-  emit_insn (gen_fctiwuz_<mode> (operands[2], operands[1]));\n-  if (TARGET_MFPGPR && TARGET_POWERPC64 && REG_P (operands[0])\n-      && INT_REGNO_P (REGNO (operands[0])))\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp = operands[2];\n+\n+  if (GET_CODE (tmp) == SCRATCH)\n+    tmp = gen_reg_rtx (DImode);\n+\n+  emit_insn (gen_fctiwuz_<mode> (tmp, src));\n+  if (MEM_P (dest))\n     {\n-      rtx reg = gen_lowpart (DImode, operands[0]);\n-      emit_move_insn (reg, operands[2]);\n+      dest = rs6000_address_for_fpconvert (dest);\n+      emit_insn (gen_stfiwx (dest, tmp));\n+      DONE;\n+    }\n+  else if (TARGET_MFPGPR && TARGET_POWERPC64)\n+    {\n+      dest = gen_lowpart (DImode, dest);\n+      emit_move_insn (dest, tmp);\n+      DONE;\n     }\n   else\n     {\n-      emit_insn (gen_stfiwx (operands[3], operands[2]));\n-      emit_move_insn (operands[0], operands[3]);\n+      rtx stack = rs6000_allocate_stack_temp (SImode, false, true);\n+      emit_insn (gen_stfiwx (stack, tmp));\n+      emit_move_insn (dest, stack);\n+      DONE;\n     }\n-  DONE;\n-}\"\n-  [(set_attr \"length\" \"12\")])\n-\n-(define_insn_and_split \"*fixuns_trunc<mode>si2_mem\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n-\t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\n-   && TARGET_STFIWX\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(pc)]\n-  \"\n-{\n-  emit_insn (gen_fctiwuz_<mode> (operands[2], operands[1]));\n-  emit_insn (gen_stfiwx (operands[0], operands[2]));\n-  DONE;\n-}\"\n-  [(set_attr \"length\" \"8\")])\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"fp\")])\n \n (define_expand \"fixuns_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -7155,6 +7148,76 @@\n   \"friz %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n+;; Since FCTIWZ doesn't sign extend the upper bits, we have to do a store and a\n+;; load to properly sign extend the value, but at least doing a store, load\n+;; into a GPR to sign extend, a store from the GPR and a load back into the FPR\n+;; if we have 32-bit memory ops\n+(define_insn_and_split \"*round32<mode>2_fprs\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d\")\n+\t(float:SFDF\n+\t (fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\"))))\n+   (clobber (match_scratch:DI 2 \"=d\"))\n+   (clobber (match_scratch:DI 3 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && <SI_CONVERT_FP> && TARGET_LFIWAX && TARGET_STFIWX && TARGET_FCFID\n+   && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"\"\n+  [(pc)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp1 = operands[2];\n+  rtx tmp2 = operands[3];\n+  rtx stack = rs6000_allocate_stack_temp (SImode, false, true);\n+\n+  if (GET_CODE (tmp1) == SCRATCH)\n+    tmp1 = gen_reg_rtx (DImode);\n+  if (GET_CODE (tmp2) == SCRATCH)\n+    tmp2 = gen_reg_rtx (DImode);\n+\n+  emit_insn (gen_fctiwz_<mode> (tmp1, src));\n+  emit_insn (gen_stfiwx (stack, tmp1));\n+  emit_insn (gen_lfiwax (tmp2, stack));\n+  emit_insn (gen_floatdi<mode>2 (dest, tmp2));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"16\")])\n+\n+(define_insn_and_split \"*roundu32<mode>2_fprs\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d\")\n+\t(unsigned_float:SFDF\n+\t (unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\"))))\n+   (clobber (match_scratch:DI 2 \"=d\"))\n+   (clobber (match_scratch:DI 3 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && TARGET_LFIWZX && TARGET_STFIWX && TARGET_FCFIDU\n+   && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"\"\n+  [(pc)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp1 = operands[2];\n+  rtx tmp2 = operands[3];\n+  rtx stack = rs6000_allocate_stack_temp (SImode, false, true);\n+\n+  if (GET_CODE (tmp1) == SCRATCH)\n+    tmp1 = gen_reg_rtx (DImode);\n+  if (GET_CODE (tmp2) == SCRATCH)\n+    tmp2 = gen_reg_rtx (DImode);\n+\n+  emit_insn (gen_fctiwuz_<mode> (tmp1, src));\n+  emit_insn (gen_stfiwx (stack, tmp1));\n+  emit_insn (gen_lfiwzx (tmp2, stack));\n+  emit_insn (gen_floatdi<mode>2 (dest, tmp2));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"16\")])\n+\n ;; No VSX equivalent to fctid\n (define_insn \"lrint<mode>di2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n@@ -7251,7 +7314,14 @@\n     }\n   else if (TARGET_FCFIDS && TARGET_LFIWAX)\n     {\n-      rs6000_expand_convert_si_to_sfdf (operands[0], operands[1], false);\n+      emit_insn (gen_floatsisf2_lfiwax (operands[0], operands[1]));\n+      DONE;\n+    }\n+  else if (TARGET_FCFID && TARGET_LFIWAX)\n+    {\n+      rtx dfreg = gen_reg_rtx (DFmode);\n+      emit_insn (gen_floatsidf2_lfiwax (dfreg, operands[1]));\n+      emit_insn (gen_truncdfsf2 (operands[0], dfreg));\n       DONE;\n     }\n   else\n@@ -7294,7 +7364,8 @@\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (float:DF (match_dup 2)))]\n   \"\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"fpload\")])\n \n (define_expand \"floatunsdidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n@@ -7321,7 +7392,8 @@\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (unsigned_float:DF (match_dup 2)))]\n   \"\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"fpload\")])\n \n (define_expand \"floatdisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n@@ -7373,6 +7445,7 @@\n ;; This is not IEEE compliant if rounding mode is \"round to nearest\".\n ;; If the DI->DF conversion is inexact, then it's possible to suffer\n ;; from double rounding.\n+;; Instead of creating a new cpu type for two FP operations, just use fp\n (define_insn_and_split \"floatdisf2_internal1\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n         (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))\n@@ -7384,7 +7457,9 @@\n         (float:DF (match_dup 1)))\n    (set (match_dup 0)\n         (float_truncate:SF (match_dup 2)))]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"fp\")])\n \n ;; Twiddles bits to avoid double rounding.\n ;; Bits that might be truncated when converting to DFmode are replaced\n@@ -7448,7 +7523,8 @@\n   emit_insn (gen_floatunsdisf2_fcfidus (operands[0], operands[2]));\n   DONE;\n }\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"fpload\")])\n \f\n ;; Define the DImode operations that can be done in a small number\n ;; of instructions.  The & constraints are to prevent the register"}, {"sha": "19f58b119a9e895203dd30fee359a32495d1bae9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/219225619219329ca995c78627a894224df58b3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/219225619219329ca995c78627a894224df58b3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=219225619219329ca995c78627a894224df58b3f", "patch": "@@ -1,3 +1,14 @@\n+2010-11-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc-fpconv-11.c: Use -mcpu=power5+, not\n+\tpower5 to enable generation of FRIZ.\n+\n+\t* gcc.target/powerpc/ppc-round.c: New file, test (double)(int)\n+\toptimization.\n+\n+\t* gcc.target/powerpc/ppc-fpconv-2.c: Update # times lfiwax is\n+\texpected.\n+\n 2010-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/43808"}, {"sha": "2eebbb42cddf769cdff89687de667df8d57540b5", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/219225619219329ca995c78627a894224df58b3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/219225619219329ca995c78627a894224df58b3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-11.c?ref=219225619219329ca995c78627a894224df58b3f", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-* } } } */\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n-/* { dg-options \"-O2 -mcpu=power5 -ffast-math\" } */\n+/* { dg-options \"-O2 -mcpu=power5+ -ffast-math\" } */\n /* { dg-final { scan-assembler-not \"xsrdpiz\" } } */\n /* { dg-final { scan-assembler \"friz\" } } */\n "}, {"sha": "e0a83422593e4bade3698347250445d0830592fa", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/219225619219329ca995c78627a894224df58b3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/219225619219329ca995c78627a894224df58b3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c?ref=219225619219329ca995c78627a894224df58b3f", "patch": "@@ -2,7 +2,7 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-options \"-O2 -mcpu=power6 -ffast-math\" } */\n-/* { dg-final { scan-assembler-times \"lfiwax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"lfiwax\" 2 } } */\n /* { dg-final { scan-assembler-not \"lfiwzx\" } } */\n /* { dg-final { scan-assembler-times \"fcfid \" 10 } } */\n /* { dg-final { scan-assembler-not \"fcfids\" } } */"}, {"sha": "20262aa449a6af6110c4709ad60298a51d3cc079", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-round.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/219225619219329ca995c78627a894224df58b3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/219225619219329ca995c78627a894224df58b3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round.c?ref=219225619219329ca995c78627a894224df58b3f", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler-times \"stfiwx\" 4 } } */\n+/* { dg-final { scan-assembler-times \"lfiwax\" 2 } } */\n+/* { dg-final { scan-assembler-times \"lfiwzx\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fctiwz\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xscvsxddp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fcfids\" 2 } } */\n+/* { dg-final { scan-assembler-not \"lwz\" } } */\n+/* { dg-final { scan-assembler-not \"stw\" } } */\n+\n+/* Make sure we don't have loads/stores to the GPR unit.  */\n+double\n+round_double_int (double a)\n+{\n+  return (double)(int)a;\n+}\n+\n+float\n+round_float_int (float a)\n+{\n+  return (float)(int)a;\n+}\n+\n+double\n+round_double_uint (double a)\n+{\n+  return (double)(unsigned int)a;\n+}\n+\n+float\n+round_float_uint (float a)\n+{\n+  return (float)(unsigned int)a;\n+}"}]}