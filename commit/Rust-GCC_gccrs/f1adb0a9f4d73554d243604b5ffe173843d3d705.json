{"sha": "f1adb0a9f4d73554d243604b5ffe173843d3d705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFhZGIwYTlmNGQ3MzU1NGQyNDM2MDRiNWZmZTE3Mzg0M2QzZDcwNQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2007-07-03T19:42:36Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2007-07-03T19:42:36Z"}, "message": "config.gcc (with_fpu): Allow --with-fpu=vfp3.\n\n\tgcc/\n\t* config.gcc (with_fpu): Allow --with-fpu=vfp3.\n\t* config/arm/aout.h (REGISTER_NAMES): Add D16-D31.\n\t* config/arm/aof.h (REGISTER_NAMES): Add D16-D31.\n\t* config/arm/arm.c (FL_VFPV3): New flag for VFPv3 processor\n\tcapability.\n\t(all_fpus): Add FPUTYPE_VFP3.\n\t(fp_model_for_fpu): Add VFPv3 field.\n\t(arm_rtx_costs_1): Give cost to VFPv3 constants.\n\t(vfp3_const_double_index): New function. Return integer index of\n\tVFPv3 constant suitable for fconst[sd] insns, or -1 if constant\n\tisn't suitable.\n\t(vfp3_const_double_rtx): New function. True if VFPv3 is enabled\n\tand argument represents a valid RTX for a VFPv3 constant.\n\t(vfp_output_fldmd): Split fldmd with > 16 registers in the list into\n\ttwo instructions.\n\t(vfp_emit_fstmd): Similar, for fstmd.\n\t(arm_print_operand): Implement new code 'G' for VFPv3 floating-point\n\tconstants, represented as integer indices.\n\t(arm_hard_regno_mode_ok): Use VFP_REGNO_OK_FOR_SINGLE,\n\tVFP_REGNO_OK_FOR_DOUBLE macros.\n\t(arm_regno_class): Handle VFPv3 d0-d7, low, high register split.\n\t(arm_file_start): Set float-abi attribute for VFPv3, and output\n\tcorrect \".fpu\" assembler directive.\n\t(arm_dbx_register_numbering): Add FIXME.\n\t* config/arm/arm.h (TARGET_VFP3): New macro. Target supports VFPv3.\n\t(fputype): Add FPUTYPE_VFP3.\n\t(FIXED_REGISTERS): Add 32 registers for D16-D31.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(CONDITIONAL_REGISTER_USAGE): Add note about conditional definition\n\tof LAST_VFP_REGNUM. Make D16-D31 caller-saved, if present.\n\t(LAST_VFP_REGNUM): Extend available VFP registers for VFPv3.\n\t(D7_VFP_REGNUM): New.\n\t(LAST_LO_VFP_REGNUM, FIRST_HI_VFP_REGNUM, LAST_HI_VFP_REGNUM)\n\t(VFP_REGNO_OK_FOR_SINGLE, VFP_REGNO_OK_FOR_SINGLE)\n\t(VFP_REGNO_OK_FOR_DOUBLE): Define new macros.\n\t(FIRST_PSEUDO_REGISTER): Shift up to 128 to accommodate VFPv3.\n\t(REG_ALLOC_ORDER): Adjust for VFPv3.\n\t(reg_class): Add VFP_D0_D7_REGS, VFP_LO_REGS, VFP_HI_REGS.\n\t(REG_CLASS_NAMES): Add entries corresponding to VFP_D0_D7_REGS,\n\tVFP_LO_REGS, VFP_HI_REGS.\n\t(REG_CLASS_CONTENTS): Likewise. Extend contents for VFP_REGS.\n\t(IS_VFP_CLASS): Define macro.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS, SECONDARY_INPUT_RELOAD_CLASS): Use\n\tIS_VFP_CLASS.\n\t(REGISTER_MOVE_COST): Likewise.\n\t* config/arm/arm-protos.h (vfp3_const_double_rtx): Add prototype.\n\t* config/arm/vfp.md (VFPCC_REGNUM): Redefine as 127.\n\t(*arm_movsi_vfp, *thumb2_movsi_vfp, *movsfcc_vfp)\n\t(*thumb2_movsfcc_vfp, *abssf2_vfp, *negsf2_vfp, *addsf3_vfp)\n\t(*subsf3_vfp, *divsf_vfp, *mulsf_vfp, *mulsf3negsf_vfp)\n\t(*mulsf3addsf_vfp, *mulsf3subsf_vfp, *mulsf3negsfaddsf_vfp)\n\t(*extendsfdf2_vfp, *truncdfsf2_vfp, *truncsisf2_vfp)\n\t(*truncsidf2_vfp, fixuns_truncsfsi2, fixuns_truncdfsi2)\n\t(*floatsisf2_vfp, *floatsidf2_vfp, floatunssisf2)\n\t(floatunssidf2, *sqrtsf2_vfp, *cmpsf_split_vfp)\n\t(*cmpsf_trap_split_vfp, *cmpsf_vfp, *cmpsf_trap_vfp): Use 't'\n\twhere appropriate for single-word registers.\n\t(*movsf_vfp, *thumb2_movsf_vfp, *movdf_vfp, *thumb2_movdf_vfp):\n\tAs above. Fix type attributes.\n\t* config/arm/constraints.md (register_contraint \"t\"): Define.\n\t(register_constraint \"w\"): Change to D0-D15, or D0-D31 for\n\tVFPv3/NEON.\n\t(register_constraint \"x\"): Define.\n\t(constraint \"Dv\"): Define.\n\nFrom-SVN: r126272", "tree": {"sha": "e271e1e30fa0f1bd69a1d4542437b7453aa640aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e271e1e30fa0f1bd69a1d4542437b7453aa640aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1adb0a9f4d73554d243604b5ffe173843d3d705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1adb0a9f4d73554d243604b5ffe173843d3d705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1adb0a9f4d73554d243604b5ffe173843d3d705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1adb0a9f4d73554d243604b5ffe173843d3d705/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2d5b90b2fdf5e67857942f6ffa6417ad61f4a929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5b90b2fdf5e67857942f6ffa6417ad61f4a929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d5b90b2fdf5e67857942f6ffa6417ad61f4a929"}], "stats": {"total": 658, "additions": 490, "deletions": 168}, "files": [{"sha": "4bf74fedf12f5b8e18a39f9baf7cf12168e9d2be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -1,3 +1,70 @@\n+2007-07-03  Julian Brown  <julian@codesourcery.com>\n+\n+\t* config.gcc (with_fpu): Allow --with-fpu=vfp3.\n+\t* config/arm/aout.h (REGISTER_NAMES): Add D16-D31.\n+\t* config/arm/aof.h (REGISTER_NAMES): Add D16-D31.\n+\t* config/arm/arm.c (FL_VFPV3): New flag for VFPv3 processor\n+\tcapability.\n+\t(all_fpus): Add FPUTYPE_VFP3.\n+\t(fp_model_for_fpu): Add VFPv3 field.\n+\t(arm_rtx_costs_1): Give cost to VFPv3 constants.\n+\t(vfp3_const_double_index): New function. Return integer index of\n+\tVFPv3 constant suitable for fconst[sd] insns, or -1 if constant\n+\tisn't suitable.\n+\t(vfp3_const_double_rtx): New function. True if VFPv3 is enabled\n+\tand argument represents a valid RTX for a VFPv3 constant.\n+\t(vfp_output_fldmd): Split fldmd with > 16 registers in the list into\n+\ttwo instructions.\n+\t(vfp_emit_fstmd): Similar, for fstmd.\n+\t(arm_print_operand): Implement new code 'G' for VFPv3 floating-point\n+\tconstants, represented as integer indices.\n+\t(arm_hard_regno_mode_ok): Use VFP_REGNO_OK_FOR_SINGLE,\n+\tVFP_REGNO_OK_FOR_DOUBLE macros.\n+\t(arm_regno_class): Handle VFPv3 d0-d7, low, high register split.\n+\t(arm_file_start): Set float-abi attribute for VFPv3, and output\n+\tcorrect \".fpu\" assembler directive.\n+\t(arm_dbx_register_numbering): Add FIXME.\n+\t* config/arm/arm.h (TARGET_VFP3): New macro. Target supports VFPv3.\n+\t(fputype): Add FPUTYPE_VFP3.\n+\t(FIXED_REGISTERS): Add 32 registers for D16-D31.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(CONDITIONAL_REGISTER_USAGE): Add note about conditional definition\n+\tof LAST_VFP_REGNUM. Make D16-D31 caller-saved, if present.\n+\t(LAST_VFP_REGNUM): Extend available VFP registers for VFPv3.\n+\t(D7_VFP_REGNUM): New.\n+\t(LAST_LO_VFP_REGNUM, FIRST_HI_VFP_REGNUM, LAST_HI_VFP_REGNUM)\n+\t(VFP_REGNO_OK_FOR_SINGLE, VFP_REGNO_OK_FOR_SINGLE)\n+\t(VFP_REGNO_OK_FOR_DOUBLE): Define new macros.\n+\t(FIRST_PSEUDO_REGISTER): Shift up to 128 to accommodate VFPv3.\n+\t(REG_ALLOC_ORDER): Adjust for VFPv3.\n+\t(reg_class): Add VFP_D0_D7_REGS, VFP_LO_REGS, VFP_HI_REGS.\n+\t(REG_CLASS_NAMES): Add entries corresponding to VFP_D0_D7_REGS,\n+\tVFP_LO_REGS, VFP_HI_REGS.\n+\t(REG_CLASS_CONTENTS): Likewise. Extend contents for VFP_REGS.\n+\t(IS_VFP_CLASS): Define macro.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS, SECONDARY_INPUT_RELOAD_CLASS): Use\n+\tIS_VFP_CLASS.\n+\t(REGISTER_MOVE_COST): Likewise.\n+\t* config/arm/arm-protos.h (vfp3_const_double_rtx): Add prototype.\n+\t* config/arm/vfp.md (VFPCC_REGNUM): Redefine as 127.\n+\t(*arm_movsi_vfp, *thumb2_movsi_vfp, *movsfcc_vfp)\n+\t(*thumb2_movsfcc_vfp, *abssf2_vfp, *negsf2_vfp, *addsf3_vfp)\n+\t(*subsf3_vfp, *divsf_vfp, *mulsf_vfp, *mulsf3negsf_vfp)\n+\t(*mulsf3addsf_vfp, *mulsf3subsf_vfp, *mulsf3negsfaddsf_vfp)\n+\t(*extendsfdf2_vfp, *truncdfsf2_vfp, *truncsisf2_vfp)\n+\t(*truncsidf2_vfp, fixuns_truncsfsi2, fixuns_truncdfsi2)\n+\t(*floatsisf2_vfp, *floatsidf2_vfp, floatunssisf2)\n+\t(floatunssidf2, *sqrtsf2_vfp, *cmpsf_split_vfp)\n+\t(*cmpsf_trap_split_vfp, *cmpsf_vfp, *cmpsf_trap_vfp): Use 't'\n+\twhere appropriate for single-word registers.\n+\t(*movsf_vfp, *thumb2_movsf_vfp, *movdf_vfp, *thumb2_movdf_vfp):\n+\tAs above. Fix type attributes.\n+\t* config/arm/constraints.md (register_contraint \"t\"): Define.\n+\t(register_constraint \"w\"): Change to D0-D15, or D0-D31 for\n+\tVFPv3/NEON.\n+\t(register_constraint \"x\"): Define.\n+\t(constraint \"Dv\"): Define.\n+\n 2007-07-03  Geoffrey Keating  <geoffk@apple.com>\n \n \t* tree.h (DECL_ALIGN): Prevent use on a FUNCTION_DECL."}, {"sha": "66c3dd9c875bde0551414c9d148062da8c482e6f", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -2835,7 +2835,7 @@ case \"${target}\" in\n \n \t\tcase \"$with_fpu\" in\n \t\t\"\" \\\n-\t\t| fpa | fpe2 | fpe3 | maverick | vfp )\n+\t\t| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 )\n \t\t\t# OK\n \t\t\t;;\n \t\t*)"}, {"sha": "71d87a520dbd891c924068e050378e6a02f49485", "filename": "gcc/config/arm/aof.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -187,7 +187,10 @@ do {\t\t\t\t\t\\\n #define CTORS_SECTION_ASM_OP \"\\tAREA\\t|C$$gnu_ctorsvec|, DATA, READONLY\"\n #define DTORS_SECTION_ASM_OP \"\\tAREA\\t|C$$gnu_dtorsvec|, DATA, READONLY\"\n \n-/* Output of Assembler Instructions.  */\n+/* Output of Assembler Instructions.  Note that the ?xx registers are\n+   there so that VFPv3/NEON registers D16-D31 have the same spacing as D0-D15\n+   (each of which is overlaid on two S registers), although there are no\n+   actual single-precision registers which correspond to D16-D31.  */\n \n #define REGISTER_NAMES\t\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -210,7 +213,11 @@ do {\t\t\t\t\t\\\n   \"s0\",  \"s1\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",  \\\n   \"s8\",  \"s9\",  \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\", \\\n   \"s16\", \"s17\", \"s18\", \"s19\", \"s20\", \"s21\", \"s22\", \"s23\", \\\n-  \"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\", \"s31\",  \\\n+  \"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\", \"s31\", \\\n+  \"d16\", \"?16\", \"d17\", \"?17\", \"d18\", \"?18\", \"d19\", \"?19\", \\\n+  \"d20\", \"?20\", \"d21\", \"?21\", \"d22\", \"?22\", \"d23\", \"?23\", \\\n+  \"d24\", \"?24\", \"d25\", \"?25\", \"d26\", \"?26\", \"d27\", \"?27\", \\\n+  \"d28\", \"?28\", \"d29\", \"?29\", \"d30\", \"?30\", \"d31\", \"?31\", \\\n   \"vfpcc\"\t\t\t\t\t\\\n }\n "}, {"sha": "a47859aa4cf51fb0b1c1548b40f4a5159642bd59", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -47,7 +47,10 @@\n #define LOCAL_LABEL_PREFIX \t\"\"\n #endif\n \n-/* The assembler's names for the registers.  */\n+/* The assembler's names for the registers.  Note that the ?xx registers are\n+   there so that VFPv3/NEON registers D16-D31 have the same spacing as D0-D15\n+   (each of which is overlaid on two S registers), although there are no\n+   actual single-precision registers which correspond to D16-D31.  */\n #ifndef REGISTER_NAMES\n #define REGISTER_NAMES\t\t\t\t   \\\n {\t\t\t\t                   \\\n@@ -68,6 +71,10 @@\n   \"s8\",  \"s9\",  \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\", \\\n   \"s16\", \"s17\", \"s18\", \"s19\", \"s20\", \"s21\", \"s22\", \"s23\", \\\n   \"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\", \"s31\", \\\n+  \"d16\", \"?16\", \"d17\", \"?17\", \"d18\", \"?18\", \"d19\", \"?19\", \\\n+  \"d20\", \"?20\", \"d21\", \"?21\", \"d22\", \"?22\", \"d23\", \"?23\", \\\n+  \"d24\", \"?24\", \"d25\", \"?25\", \"d26\", \"?26\", \"d27\", \"?27\", \\\n+  \"d28\", \"?28\", \"d29\", \"?29\", \"d30\", \"?30\", \"d31\", \"?31\", \\\n   \"vfpcc\"\t\t\t\t\t   \\\n }\n #endif"}, {"sha": "3f928b853a8f09bcef1a43572a50176f563880ce", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -67,6 +67,7 @@ extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n \t\t\t\t\t    int);\n extern int arm_const_double_rtx (rtx);\n extern int neg_const_double_rtx_ok_for_fpa (rtx);\n+extern int vfp3_const_double_rtx (rtx);\n extern enum reg_class coproc_secondary_reload_class (enum machine_mode, rtx,\n \t\t\t\t\t\t     bool);\n extern bool arm_tls_referenced_p (rtx);"}, {"sha": "6c9a69594baa3887d050aec8ae3e35e1368e6646", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 164, "deletions": 11, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -457,6 +457,7 @@ static int thumb_call_reg_needed;\n #define FL_NOTM\t      (1 << 17)\t      /* Instructions not present in the 'M'\n \t\t\t\t\t profile.  */\n #define FL_DIV\t      (1 << 18)\t      /* Hardware divide.  */\n+#define FL_VFPV3      (1 << 19)       /* Vector Floating Point V3.  */\n \n #define FL_IWMMXT     (1 << 29)\t      /* XScale v2 or \"Intel Wireless MMX technology\".  */\n \n@@ -700,7 +701,8 @@ static const struct fpu_desc all_fpus[] =\n   {\"fpe2\",\tFPUTYPE_FPA_EMU2},\n   {\"fpe3\",\tFPUTYPE_FPA_EMU2},\n   {\"maverick\",\tFPUTYPE_MAVERICK},\n-  {\"vfp\",\tFPUTYPE_VFP}\n+  {\"vfp\",\tFPUTYPE_VFP},\n+  {\"vfp3\",\tFPUTYPE_VFP3},\n };\n \n \n@@ -715,7 +717,8 @@ static const enum fputype fp_model_for_fpu[] =\n   ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA_EMU2  */\n   ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA_EMU3  */\n   ARM_FP_MODEL_MAVERICK,\t/* FPUTYPE_MAVERICK  */\n-  ARM_FP_MODEL_VFP\t\t/* FPUTYPE_VFP  */\n+  ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP  */\n+  ARM_FP_MODEL_VFP\t\t/* FPUTYPE_VFP3  */\n };\n \n \n@@ -4950,7 +4953,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n       return 6;\n \n     case CONST_DOUBLE:\n-      if (arm_const_double_rtx (x))\n+      if (arm_const_double_rtx (x) || vfp3_const_double_rtx (x))\n \treturn outer == SET ? 2 : -1;\n       else if ((outer == COMPARE || outer == PLUS)\n \t       && neg_const_double_rtx_ok_for_fpa (x))\n@@ -5649,6 +5652,108 @@ neg_const_double_rtx_ok_for_fpa (rtx x)\n \n   return 0;\n }\n+\n+\n+/* VFPv3 has a fairly wide range of representable immediates, formed from\n+   \"quarter-precision\" floating-point values. These can be evaluated using this\n+   formula (with ^ for exponentiation):\n+\n+     -1^s * n * 2^-r\n+\n+   Where 's' is a sign bit (0/1), 'n' and 'r' are integers such that\n+   16 <= n <= 31 and 0 <= r <= 7.\n+\n+   These values are mapped onto an 8-bit integer ABCDEFGH s.t.\n+\n+     - A (most-significant) is the sign bit.\n+     - BCD are the exponent (encoded as r XOR 3).\n+     - EFGH are the mantissa (encoded as n - 16).\n+*/\n+\n+/* Return an integer index for a VFPv3 immediate operand X suitable for the\n+   fconst[sd] instruction, or -1 if X isn't suitable.  */\n+static int\n+vfp3_const_double_index (rtx x)\n+{\n+  REAL_VALUE_TYPE r, m;\n+  int sign, exponent;\n+  unsigned HOST_WIDE_INT mantissa, mant_hi;\n+  unsigned HOST_WIDE_INT mask;\n+  int point_pos = 2 * HOST_BITS_PER_WIDE_INT - 1;\n+\n+  if (!TARGET_VFP3 || GET_CODE (x) != CONST_DOUBLE)\n+    return -1;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\n+  /* We can't represent these things, so detect them first.  */\n+  if (REAL_VALUE_ISINF (r) || REAL_VALUE_ISNAN (r) || REAL_VALUE_MINUS_ZERO (r))\n+    return -1;\n+\n+  /* Extract sign, exponent and mantissa.  */\n+  sign = REAL_VALUE_NEGATIVE (r) ? 1 : 0;\n+  r = REAL_VALUE_ABS (r);\n+  exponent = REAL_EXP (&r);\n+  /* For the mantissa, we expand into two HOST_WIDE_INTS, apart from the\n+     highest (sign) bit, with a fixed binary point at bit point_pos.\n+     WARNING: If there's ever a VFP version which uses more than 2 * H_W_I - 1\n+     bits for the mantissa, this may fail (low bits would be lost).  */\n+  real_ldexp (&m, &r, point_pos - exponent);\n+  REAL_VALUE_TO_INT (&mantissa, &mant_hi, m);\n+\n+  /* If there are bits set in the low part of the mantissa, we can't\n+     represent this value.  */\n+  if (mantissa != 0)\n+    return -1;\n+\n+  /* Now make it so that mantissa contains the most-significant bits, and move\n+     the point_pos to indicate that the least-significant bits have been\n+     discarded.  */\n+  point_pos -= HOST_BITS_PER_WIDE_INT;\n+  mantissa = mant_hi;\n+\n+  /* We can permit four significant bits of mantissa only, plus a high bit\n+     which is always 1.  */\n+  mask = ((unsigned HOST_WIDE_INT)1 << (point_pos - 5)) - 1;\n+  if ((mantissa & mask) != 0)\n+    return -1;\n+\n+  /* Now we know the mantissa is in range, chop off the unneeded bits.  */\n+  mantissa >>= point_pos - 5;\n+\n+  /* The mantissa may be zero. Disallow that case. (It's possible to load the\n+     floating-point immediate zero with Neon using an integer-zero load, but\n+     that case is handled elsewhere.)  */\n+  if (mantissa == 0)\n+    return -1;\n+\n+  gcc_assert (mantissa >= 16 && mantissa <= 31);\n+\n+  /* The value of 5 here would be 4 if GCC used IEEE754-like encoding (where\n+     normalised significands are in the range [1, 2). (Our mantissa is shifted\n+     left 4 places at this point relative to normalised IEEE754 values).  GCC\n+     internally uses [0.5, 1) (see real.c), so the exponent returned from\n+     REAL_EXP must be altered.  */\n+  exponent = 5 - exponent;\n+\n+  if (exponent < 0 || exponent > 7)\n+    return -1;\n+\n+  /* Sign, mantissa and exponent are now in the correct form to plug into the\n+     formulae described in the comment above.  */\n+  return (sign << 7) | ((exponent ^ 3) << 4) | (mantissa - 16);\n+}\n+\n+/* Return TRUE if rtx X is a valid immediate VFPv3 constant.  */\n+int\n+vfp3_const_double_rtx (rtx x)\n+{\n+  if (!TARGET_VFP3)\n+    return 0;\n+\n+  return vfp3_const_double_index (x) != -1;\n+}\n+\n \f\n /* Predicates for `match_operand' and `match_operator'.  */\n \n@@ -8808,6 +8913,15 @@ vfp_output_fldmd (FILE * stream, unsigned int base, int reg, int count)\n       count++;\n     }\n \n+  /* FLDMD may not load more than 16 doubleword registers at a time. Split the\n+     load into multiple parts if we have to handle more than 16 registers.  */\n+  if (count > 16)\n+    {\n+      vfp_output_fldmd (stream, base, reg, 16);\n+      vfp_output_fldmd (stream, base, reg + 16, count - 16);\n+      return;\n+    }\n+\n   fputc ('\\t', stream);\n   asm_fprintf (stream, \"fldmfdd\\t%r!, {\", base);\n \n@@ -8870,6 +8984,19 @@ vfp_emit_fstmd (int base_reg, int count)\n       count++;\n     }\n \n+  /* FSTMD may not store more than 16 doubleword registers at once.  Split\n+     larger stores into multiple parts (up to a maximum of two, in\n+     practice).  */\n+  if (count > 16)\n+    {\n+      int saved;\n+      /* NOTE: base_reg is an internal register number, so each D register\n+         counts as 2.  */\n+      saved = vfp_emit_fstmd (base_reg + 32, count - 16);\n+      saved += vfp_emit_fstmd (base_reg, 16);\n+      return saved;\n+    }\n+\n   par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n   dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));\n \n@@ -11982,6 +12109,16 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       }\n       return;\n \n+    /* Print a VFPv3 floating-point constant, represented as an integer\n+       index.  */\n+    case 'G':\n+      {\n+        int index = vfp3_const_double_index (x);\n+\tgcc_assert (index != -1);\n+\tfprintf (stream, \"%d\", index);\n+      }\n+      return;\n+\n     default:\n       if (x == 0)\n \t{\n@@ -12761,11 +12898,10 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n       && IS_VFP_REGNUM (regno))\n     {\n       if (mode == SFmode || mode == SImode)\n-\treturn TRUE;\n+\treturn VFP_REGNO_OK_FOR_SINGLE (regno);\n \n-      /* DFmode values are only valid in even register pairs.  */\n       if (mode == DFmode)\n-\treturn ((regno - FIRST_VFP_REGNUM) & 1) == 0;\n+\treturn VFP_REGNO_OK_FOR_DOUBLE (regno);\n       return FALSE;\n     }\n \n@@ -12828,7 +12964,14 @@ arm_regno_class (int regno)\n     return CIRRUS_REGS;\n \n   if (IS_VFP_REGNUM (regno))\n-    return VFP_REGS;\n+    {\n+      if (regno <= D7_VFP_REGNUM)\n+\treturn VFP_D0_D7_REGS;\n+      else if (regno <= LAST_LO_VFP_REGNUM)\n+        return VFP_LO_REGS;\n+      else\n+        return VFP_HI_REGS;\n+    }\n \n   if (IS_IWMMXT_REGNUM (regno))\n     return IWMMXT_REGS;\n@@ -15270,6 +15413,7 @@ arm_file_start (void)\n \t}\n       else\n \t{\n+\t  int set_float_abi_attributes = 0;\n \t  switch (arm_fpu_arch)\n \t    {\n \t    case FPUTYPE_FPA:\n@@ -15285,15 +15429,23 @@ arm_file_start (void)\n \t      fpu_name = \"maverick\";\n \t      break;\n \t    case FPUTYPE_VFP:\n-\t      if (TARGET_HARD_FLOAT)\n-\t\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 27, 3\\n\");\n-\t      if (TARGET_HARD_FLOAT_ABI)\n-\t\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 28, 1\\n\");\n \t      fpu_name = \"vfp\";\n+\t      set_float_abi_attributes = 1;\n+\t      break;\n+\t    case FPUTYPE_VFP3:\n+\t      fpu_name = \"vfp3\";\n+\t      set_float_abi_attributes = 1;\n \t      break;\n \t    default:\n \t      abort();\n \t    }\n+\t  if (set_float_abi_attributes)\n+\t    {\n+\t      if (TARGET_HARD_FLOAT)\n+\t\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 27, 3\\n\");\n+\t      if (TARGET_HARD_FLOAT_ABI)\n+\t\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 28, 1\\n\");\n+\t    }\n \t}\n       asm_fprintf (asm_out_file, \"\\t.fpu %s\\n\", fpu_name);\n \n@@ -16172,6 +16324,7 @@ arm_dbx_register_number (unsigned int regno)\n   if (IS_FPA_REGNUM (regno))\n     return (TARGET_AAPCS_BASED ? 96 : 16) + regno - FIRST_FPA_REGNUM;\n \n+  /* FIXME: VFPv3 register numbering.  */\n   if (IS_VFP_REGNUM (regno))\n     return 64 + regno - FIRST_VFP_REGNUM;\n "}, {"sha": "8aa88ab35a232fe75012311eab21cfc7ccf4c545", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 104, "deletions": 43, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -206,6 +206,11 @@ extern GTY(()) rtx aof_pic_label;\n /* 32-bit Thumb-2 code.  */\n #define TARGET_THUMB2\t\t\t(TARGET_THUMB && arm_arch_thumb2)\n \n+/* FPU is VFPv3 (with twice the number of D registers).  Setting the FPU to\n+   Neon automatically enables VFPv3 too.  */\n+#define TARGET_VFP3 (arm_fp_model == ARM_FP_MODEL_VFP \\\n+\t\t     && (arm_fpu_arch == FPUTYPE_VFP3))\n+\n /* \"DSP\" multiply instructions, eg. SMULxy.  */\n #define TARGET_DSP_MULTIPLY \\\n   (TARGET_32BIT && arm_arch5e && arm_arch_notm)\n@@ -275,7 +280,9 @@ enum fputype\n   /* Cirrus Maverick floating point co-processor.  */\n   FPUTYPE_MAVERICK,\n   /* VFP.  */\n-  FPUTYPE_VFP\n+  FPUTYPE_VFP,\n+  /* VFPv3.  */\n+  FPUTYPE_VFP3\n };\n \n /* Recast the floating point class to be the floating point attribute.  */\n@@ -643,6 +650,10 @@ extern int arm_structure_size_boundary;\n   1,1,1,1,1,1,1,1,\t\\\n   1,1,1,1,1,1,1,1,\t\\\n   1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n   1\t\t\t\\\n }\n \n@@ -669,6 +680,10 @@ extern int arm_structure_size_boundary;\n   1,1,1,1,1,1,1,1,\t     \\\n   1,1,1,1,1,1,1,1,\t     \\\n   1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n   1\t\t\t     \\\n }\n \n@@ -720,11 +735,15 @@ extern int arm_structure_size_boundary;\n \t}\t\t\t\t\t\t\t\\\n       if (TARGET_VFP)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n+\t  /* VFPv3 registers are disabled when earlier VFP\t\\\n+\t     versions are selected due to the definition of\t\\\n+\t     LAST_VFP_REGNUM.  */\t\t\t\t\\\n \t  for (regno = FIRST_VFP_REGNUM;\t\t\t\\\n \t       regno <= LAST_VFP_REGNUM; ++ regno)\t\t\\\n \t    {\t\t\t\t\t\t\t\\\n \t      fixed_regs[regno] = 0;\t\t\t\t\\\n-\t      call_used_regs[regno] = regno < FIRST_VFP_REGNUM + 16; \\\n+\t      call_used_regs[regno] = regno < FIRST_VFP_REGNUM + 16 \\\n+\t      \t|| regno >= FIRST_VFP_REGNUM + 32;\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n@@ -898,15 +917,35 @@ extern int arm_structure_size_boundary;\n   (((REGNUM) >= FIRST_CIRRUS_FP_REGNUM) && ((REGNUM) <= LAST_CIRRUS_FP_REGNUM))\n \n #define FIRST_VFP_REGNUM\t63\n-#define LAST_VFP_REGNUM\t\t94\n+#define D7_VFP_REGNUM\t\t78  /* Registers 77 and 78 == VFP reg D7.  */\n+#define LAST_VFP_REGNUM\t\\\n+  (TARGET_VFP3 ? LAST_HI_VFP_REGNUM : LAST_LO_VFP_REGNUM)\n+\n #define IS_VFP_REGNUM(REGNUM) \\\n   (((REGNUM) >= FIRST_VFP_REGNUM) && ((REGNUM) <= LAST_VFP_REGNUM))\n \n+/* VFP registers are split into two types: those defined by VFP versions < 3\n+   have D registers overlaid on consecutive pairs of S registers. VFP version 3\n+   defines 16 new D registers (d16-d31) which, for simplicity and correctness\n+   in various parts of the backend, we implement as \"fake\" single-precision\n+   registers (which would be S32-S63, but cannot be used in that way).  The\n+   following macros define these ranges of registers.  */\n+#define LAST_LO_VFP_REGNUM\t94\n+#define FIRST_HI_VFP_REGNUM\t95\n+#define LAST_HI_VFP_REGNUM\t126\n+\n+#define VFP_REGNO_OK_FOR_SINGLE(REGNUM) \\\n+  ((REGNUM) <= LAST_LO_VFP_REGNUM)\n+\n+/* DFmode values are only valid in even register pairs.  */\n+#define VFP_REGNO_OK_FOR_DOUBLE(REGNUM) \\\n+  ((((REGNUM) - FIRST_VFP_REGNUM) & 1) == 0)\n+\n /* The number of hard registers is 16 ARM + 8 FPA + 1 CC + 1 SFP + 1 AFP.  */\n /* + 16 Cirrus registers take us up to 43.  */\n /* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n-/* VFP adds 32 + 1 more.  */\n-#define FIRST_PSEUDO_REGISTER   96\n+/* VFP (VFP3) adds 32 (64) + 1 more.  */\n+#define FIRST_PSEUDO_REGISTER   128\n \n #define DBX_REGISTER_NUMBER(REGNO) arm_dbx_register_number (REGNO)\n \n@@ -960,24 +999,32 @@ extern int arm_structure_size_boundary;\n    function parameters.  It is quite good to use lr since other calls may\n    clobber it anyway.  Allocate r0 through r3 in reverse order since r3 is\n    least likely to contain a function parameter; in addition results are\n-   returned in r0.  */\n-\n-#define REG_ALLOC_ORDER  \t    \\\n-{                                   \\\n-     3,  2,  1,  0, 12, 14,  4,  5, \\\n-     6,  7,  8, 10,  9, 11, 13, 15, \\\n-    16, 17, 18, 19, 20, 21, 22, 23, \\\n-    27, 28, 29, 30, 31, 32, 33, 34, \\\n-    35, 36, 37, 38, 39, 40, 41, 42, \\\n-    43, 44, 45, 46, 47, 48, 49, 50, \\\n-    51, 52, 53, 54, 55, 56, 57, 58, \\\n-    59, 60, 61, 62,\t\t    \\\n-    24, 25, 26,\t\t\t    \\\n-    78, 77, 76, 75, 74, 73, 72, 71, \\\n-    70, 69, 68, 67, 66, 65, 64, 63, \\\n-    79, 80, 81, 82, 83, 84, 85, 86, \\\n-    87, 88, 89, 90, 91, 92, 93, 94, \\\n-    95\t\t\t\t    \\\n+   returned in r0.\n+   For VFP/VFPv3, allocate D16-D31 first, then caller-saved registers (D0-D7),\n+   then D8-D15.  The reason for doing this is to attempt to reduce register\n+   pressure when both single- and double-precision registers are used in a\n+   function.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+     3,  2,  1,  0, 12, 14,  4,  5,\t\t\\\n+     6,  7,  8, 10,  9, 11, 13, 15,\t\t\\\n+    16, 17, 18, 19, 20, 21, 22, 23,\t\t\\\n+    27, 28, 29, 30, 31, 32, 33, 34,\t\t\\\n+    35, 36, 37, 38, 39, 40, 41, 42,\t\t\\\n+    43, 44, 45, 46, 47, 48, 49, 50,\t\t\\\n+    51, 52, 53, 54, 55, 56, 57, 58,\t\t\\\n+    59, 60, 61, 62,\t\t\t\t\\\n+    24, 25, 26,\t\t\t\t\t\\\n+    95,  96,  97,  98,  99, 100, 101, 102,\t\\\n+   103, 104, 105, 106, 107, 108, 109, 110,\t\\\n+   111, 112, 113, 114, 115, 116, 117, 118,\t\\\n+   119, 120, 121, 122, 123, 124, 125, 126,\t\\\n+    78,  77,  76,  75,  74,  73,  72,  71,\t\\\n+    70,  69,  68,  67,  66,  65,  64,  63,\t\\\n+    79,  80,  81,  82,  83,  84,  85,  86,\t\\\n+    87,  88,  89,  90,  91,  92,  93,  94,\t\\\n+   127\t\t\t\t\t\t\\\n }\n \n /* Interrupt functions can only use registers that have already been\n@@ -996,6 +1043,9 @@ enum reg_class\n   NO_REGS,\n   FPA_REGS,\n   CIRRUS_REGS,\n+  VFP_D0_D7_REGS,\n+  VFP_LO_REGS,\n+  VFP_HI_REGS,\n   VFP_REGS,\n   IWMMXT_GR_REGS,\n   IWMMXT_REGS,\n@@ -1018,6 +1068,9 @@ enum reg_class\n   \"NO_REGS\",\t\t\\\n   \"FPA_REGS\",\t\t\\\n   \"CIRRUS_REGS\",\t\\\n+  \"VFP_D0_D7_REGS\",\t\\\n+  \"VFP_LO_REGS\",\t\\\n+  \"VFP_HI_REGS\",\t\\\n   \"VFP_REGS\",\t\t\\\n   \"IWMMXT_GR_REGS\",\t\\\n   \"IWMMXT_REGS\",\t\\\n@@ -1034,24 +1087,32 @@ enum reg_class\n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n-#define REG_CLASS_CONTENTS\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS  */\t\\\n-  { 0x00FF0000, 0x00000000, 0x00000000 }, /* FPA_REGS */\t\\\n-  { 0xF8000000, 0x000007FF, 0x00000000 }, /* CIRRUS_REGS */\t\\\n-  { 0x00000000, 0x80000000, 0x7FFFFFFF }, /* VFP_REGS  */\t\\\n-  { 0x00000000, 0x00007800, 0x00000000 }, /* IWMMXT_GR_REGS */\t\\\n-  { 0x00000000, 0x7FFF8000, 0x00000000 }, /* IWMMXT_REGS */\t\\\n-  { 0x000000FF, 0x00000000, 0x00000000 }, /* LO_REGS */\t\t\\\n-  { 0x00002000, 0x00000000, 0x00000000 }, /* STACK_REG */\t\\\n-  { 0x000020FF, 0x00000000, 0x00000000 }, /* BASE_REGS */\t\\\n-  { 0x0000FF00, 0x00000000, 0x00000000 }, /* HI_REGS */\t\t\\\n-  { 0x01000000, 0x00000000, 0x00000000 }, /* CC_REG */\t\t\\\n-  { 0x00000000, 0x00000000, 0x80000000 }, /* VFPCC_REG */\t\\\n-  { 0x0200FFFF, 0x00000000, 0x00000000 }, /* GENERAL_REGS */\t\\\n-  { 0xFAFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF }  /* ALL_REGS */\t\\\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS  */\t\\\n+  { 0x00FF0000, 0x00000000, 0x00000000, 0x00000000 }, /* FPA_REGS */\t\\\n+  { 0xF8000000, 0x000007FF, 0x00000000, 0x00000000 }, /* CIRRUS_REGS */\t\\\n+  { 0x00000000, 0x80000000, 0x00007FFF, 0x00000000 }, /* VFP_D0_D7_REGS  */ \\\n+  { 0x00000000, 0x80000000, 0x7FFFFFFF, 0x00000000 }, /* VFP_LO_REGS  */ \\\n+  { 0x00000000, 0x00000000, 0x80000000, 0x7FFFFFFF }, /* VFP_HI_REGS  */ \\\n+  { 0x00000000, 0x80000000, 0xFFFFFFFF, 0x7FFFFFFF }, /* VFP_REGS  */\t\\\n+  { 0x00000000, 0x00007800, 0x00000000, 0x00000000 }, /* IWMMXT_GR_REGS */ \\\n+  { 0x00000000, 0x7FFF8000, 0x00000000, 0x00000000 }, /* IWMMXT_REGS */\t\\\n+  { 0x000000FF, 0x00000000, 0x00000000, 0x00000000 }, /* LO_REGS */\t\\\n+  { 0x00002000, 0x00000000, 0x00000000, 0x00000000 }, /* STACK_REG */\t\\\n+  { 0x000020FF, 0x00000000, 0x00000000, 0x00000000 }, /* BASE_REGS */\t\\\n+  { 0x0000FF00, 0x00000000, 0x00000000, 0x00000000 }, /* HI_REGS */\t\\\n+  { 0x01000000, 0x00000000, 0x00000000, 0x00000000 }, /* CC_REG */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x80000000 }, /* VFPCC_REG */\t\\\n+  { 0x0200FFFF, 0x00000000, 0x00000000, 0x00000000 }, /* GENERAL_REGS */ \\\n+  { 0xFAFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF }  /* ALL_REGS */\t\\\n }\n \n+/* Any of the VFP register classes.  */\n+#define IS_VFP_CLASS(X) \\\n+  ((X) == VFP_D0_D7_REGS || (X) == VFP_LO_REGS \\\n+   || (X) == VFP_HI_REGS || (X) == VFP_REGS)\n+\n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n@@ -1125,7 +1186,7 @@ enum reg_class\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n   /* Restrict which direct reloads are allowed for VFP/iWMMXt regs.  */ \\\n   ((TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\t\\\n-    && (CLASS) == VFP_REGS)\t\t\t\t\t\\\n+    && IS_VFP_CLASS (CLASS))\t\t\t\t\t\\\n    ? coproc_secondary_reload_class (MODE, X, FALSE)\t\t\\\n    : (TARGET_IWMMXT && (CLASS) == IWMMXT_REGS)\t\t\t\\\n    ? coproc_secondary_reload_class (MODE, X, TRUE)\t\t\\\n@@ -1138,7 +1199,7 @@ enum reg_class\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n   /* Restrict which direct reloads are allowed for VFP/iWMMXt regs.  */ \\\n   ((TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\t\\\n-    && (CLASS) == VFP_REGS)\t\t\t\t\t\\\n+    && IS_VFP_CLASS (CLASS))\t\t\t\t\t\\\n     ? coproc_secondary_reload_class (MODE, X, FALSE) :\t\t\\\n     (TARGET_IWMMXT && (CLASS) == IWMMXT_REGS) ?\t\t\t\\\n     coproc_secondary_reload_class (MODE, X, TRUE) :\t\t\\\n@@ -1257,8 +1318,8 @@ do {\t\t\t\t\t\t\t\t\t      \\\n   (TARGET_32BIT ?\t\t\t\t\t\t\\\n    ((FROM) == FPA_REGS && (TO) != FPA_REGS ? 20 :\t\\\n     (FROM) != FPA_REGS && (TO) == FPA_REGS ? 20 :\t\\\n-    (FROM) == VFP_REGS && (TO) != VFP_REGS ? 10 :  \\\n-    (FROM) != VFP_REGS && (TO) == VFP_REGS ? 10 :  \\\n+    IS_VFP_CLASS (FROM) && !IS_VFP_CLASS (TO) ? 10 :\t\\\n+    !IS_VFP_CLASS (FROM) && IS_VFP_CLASS (TO) ? 10 :\t\\\n     (FROM) == IWMMXT_REGS && (TO) != IWMMXT_REGS ? 4 :  \\\n     (FROM) != IWMMXT_REGS && (TO) == IWMMXT_REGS ? 4 :  \\\n     (FROM) == IWMMXT_GR_REGS || (TO) == IWMMXT_GR_REGS ? 20 :  \\"}, {"sha": "9a6938d0897458d67d3fa409bde63aa1608510c2", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -20,7 +20,7 @@\n ;; Boston, MA 02110-1301, USA.\n \n ;; The following register constraints have been used:\n-;; - in ARM/Thumb-2 state: f, v, w, y, z\n+;; - in ARM/Thumb-2 state: f, t, v, w, x, y, z\n ;; - in Thumb state: h, k, b\n ;; - in both states: l, c\n ;; In ARM state, 'l' is an alias for 'r'\n@@ -30,7 +30,7 @@\n ;; in Thumb-1 state: I, J, K, L, M, N, O\n \n ;; The following multi-letter normal constraints have been used:\n-;; in ARM/Thumb-2 state: Da, Db, Dc\n+;; in ARM/Thumb-2 state: Da, Db, Dc, Dv\n \n ;; The following memory constraints have been used:\n ;; in ARM/Thumb-2 state: Q, Uv, Uy\n@@ -40,11 +40,18 @@\n (define_register_constraint \"f\" \"TARGET_ARM ? FPA_REGS : NO_REGS\"\n  \"Legacy FPA registers @code{f0}-@code{f7}.\")\n \n+(define_register_constraint \"t\" \"TARGET_32BIT ? VFP_LO_REGS : NO_REGS\"\n+ \"The VFP registers @code{s0}-@code{s31}.\")\n+\n (define_register_constraint \"v\" \"TARGET_ARM ? CIRRUS_REGS : NO_REGS\"\n  \"The Cirrus Maverick co-processor registers.\")\n \n-(define_register_constraint \"w\" \"TARGET_ARM ? VFP_REGS : NO_REGS\"\n- \"The VFP registers @code{s0}-@code{s31}.\")\n+(define_register_constraint \"w\"\n+  \"TARGET_32BIT ? (TARGET_VFP3 ? VFP_REGS : VFP_LO_REGS) : NO_REGS\"\n+ \"The VFP registers @code{d0}-@code{d15}, or @code{d0}-@code{d31} for VFPv3.\")\n+\n+(define_register_constraint \"x\" \"TARGET_32BIT ? VFP_D0_D7_REGS : NO_REGS\"\n+ \"The VFP registers @code{d0}-@code{d7}.\")\n \n (define_register_constraint \"y\" \"TARGET_REALLY_IWMMXT ? IWMMXT_REGS : NO_REGS\"\n  \"The Intel iWMMX co-processor registers.\")\n@@ -157,6 +164,13 @@\n       (match_test \"TARGET_32BIT && arm_const_double_inline_cost (op) == 4\n \t\t   && !(optimize_size || arm_ld_sched)\")))\n \n+(define_constraint \"Dv\"\n+ \"@internal\n+  In ARM/Thumb-2 state a const_double which can be used with a VFP fconsts\n+  or fconstd instruction.\"\n+ (and (match_code \"const_double\")\n+      (match_test \"TARGET_32BIT && vfp3_const_double_rtx (op)\")))\n+\n (define_memory_constraint \"Uv\"\n  \"@internal\n   In ARM/Thumb-2 state a valid VFP load/store address.\""}, {"sha": "d50877ca4978c2426f9205643d93cea6a7ca10b9", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 118, "deletions": 106, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adb0a9f4d73554d243604b5ffe173843d3d705/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=f1adb0a9f4d73554d243604b5ffe173843d3d705", "patch": "@@ -21,7 +21,7 @@\n \n ;; Additional register numbers\n (define_constants\n-  [(VFPCC_REGNUM 95)]\n+  [(VFPCC_REGNUM 127)]\n )\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n@@ -121,8 +121,8 @@\n ;; ??? For now do not allow loading constants into vfp regs.  This causes\n ;; problems because small constants get converted into adds.\n (define_insn \"*arm_movsi_vfp\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r ,m,*w,r,*w,*w, *Uv\")\n-      (match_operand:SI 1 \"general_operand\"\t   \"rI,K,N,mi,r,r,*w,*w,*Uvi,*w\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r ,m,*t,r,*t,*t, *Uv\")\n+      (match_operand:SI 1 \"general_operand\"\t   \"rI,K,N,mi,r,r,*t,*t,*Uvi,*t\"))]\n   \"TARGET_ARM && TARGET_VFP && TARGET_HARD_FLOAT\n    && (   s_register_operand (operands[0], SImode)\n        || s_register_operand (operands[1], SImode))\"\n@@ -158,8 +158,8 @@\n )\n \n (define_insn \"*thumb2_movsi_vfp\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,*w,r,*w,*w, *Uv\")\n-      (match_operand:SI 1 \"general_operand\"\t   \"rI,K,N,mi,r,r,*w,*w,*Uvi,*w\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,*t,r,*t,*t, *Uv\")\n+      (match_operand:SI 1 \"general_operand\"\t   \"rI,K,N,mi,r,r,*t,*t,*Uvi,*t\"))]\n   \"TARGET_THUMB2 && TARGET_VFP && TARGET_HARD_FLOAT\n    && (   s_register_operand (operands[0], SImode)\n        || s_register_operand (operands[1], SImode))\"\n@@ -262,8 +262,8 @@\n ;; preferable to loading the value via integer registers.\n \n (define_insn \"*movsf_vfp\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=w,?r,w  ,Uv,r ,m,w,r\")\n-\t(match_operand:SF 1 \"general_operand\"\t   \" ?r,w,UvE,w, mE,r,w,r\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=t,?r,t ,t  ,Uv,r ,m,t,r\")\n+\t(match_operand:SF 1 \"general_operand\"\t   \" ?r,t,Dv,UvE,t, mE,r,t,r\"))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n    && (   s_register_operand (operands[0], SFmode)\n        || s_register_operand (operands[1], SFmode))\"\n@@ -274,29 +274,32 @@\n       return \\\"fmsr%?\\\\t%0, %1\\\";\n     case 1:\n       return \\\"fmrs%?\\\\t%0, %1\\\";\n-    case 2: case 3:\n+    case 2:\n+      return \\\"fconsts%?\\\\t%0, #%G1\\\";\n+    case 3: case 4:\n       return output_move_vfp (operands);\n-    case 4:\n-      return \\\"ldr%?\\\\t%0, %1\\\\t%@ float\\\";\n     case 5:\n-      return \\\"str%?\\\\t%1, %0\\\\t%@ float\\\";\n+      return \\\"ldr%?\\\\t%0, %1\\\\t%@ float\\\";\n     case 6:\n-      return \\\"fcpys%?\\\\t%0, %1\\\";\n+      return \\\"str%?\\\\t%1, %0\\\\t%@ float\\\";\n     case 7:\n+      return \\\"fcpys%?\\\\t%0, %1\\\";\n+    case 8:\n       return \\\"mov%?\\\\t%0, %1\\\\t%@ float\\\";\n     default:\n       gcc_unreachable ();\n     }\n   \"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,f_loads,f_stores,load1,store1\")\n-   (set_attr \"pool_range\" \"*,*,1020,*,4096,*,*,*\")\n-   (set_attr \"neg_pool_range\" \"*,*,1008,*,4080,*,*,*\")]\n+   (set_attr \"type\"\n+     \"r_2_f,f_2_r,farith,f_loads,f_stores,load1,store1,ffarith,*\")\n+   (set_attr \"pool_range\" \"*,*,*,1020,*,4096,*,*,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,*,1008,*,4080,*,*,*\")]\n )\n \n (define_insn \"*thumb2_movsf_vfp\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=w,?r,w  ,Uv,r ,m,w,r\")\n-\t(match_operand:SF 1 \"general_operand\"\t   \" ?r,w,UvE,w, mE,r,w,r\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=t,?r,t, t  ,Uv,r ,m,t,r\")\n+\t(match_operand:SF 1 \"general_operand\"\t   \" ?r,t,Dv,UvE,t, mE,r,t,r\"))]\n   \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\n    && (   s_register_operand (operands[0], SFmode)\n        || s_register_operand (operands[1], SFmode))\"\n@@ -307,32 +310,35 @@\n       return \\\"fmsr%?\\\\t%0, %1\\\";\n     case 1:\n       return \\\"fmrs%?\\\\t%0, %1\\\";\n-    case 2: case 3:\n+    case 2:\n+      return \\\"fconsts%?\\\\t%0, #%G1\\\";\n+    case 3: case 4:\n       return output_move_vfp (operands);\n-    case 4:\n-      return \\\"ldr%?\\\\t%0, %1\\\\t%@ float\\\";\n     case 5:\n-      return \\\"str%?\\\\t%1, %0\\\\t%@ float\\\";\n+      return \\\"ldr%?\\\\t%0, %1\\\\t%@ float\\\";\n     case 6:\n-      return \\\"fcpys%?\\\\t%0, %1\\\";\n+      return \\\"str%?\\\\t%1, %0\\\\t%@ float\\\";\n     case 7:\n+      return \\\"fcpys%?\\\\t%0, %1\\\";\n+    case 8:\n       return \\\"mov%?\\\\t%0, %1\\\\t%@ float\\\";\n     default:\n       gcc_unreachable ();\n     }\n   \"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,f_load,f_store,load1,store1\")\n-   (set_attr \"pool_range\" \"*,*,1020,*,4092,*,*,*\")\n-   (set_attr \"neg_pool_range\" \"*,*,1008,*,0,*,*,*\")]\n+   (set_attr \"type\"\n+     \"r_2_f,f_2_r,farith,f_load,f_store,load1,store1,ffarith,*\")\n+   (set_attr \"pool_range\" \"*,*,*,1020,*,4092,*,*,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,*,1008,*,0,*,*,*\")]\n )\n \n \n ;; DFmode moves\n \n (define_insn \"*movdf_vfp\"\n-  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,r, m,w  ,Uv,w,r\")\n-\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,mF,r,UvF,w, w,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,w ,r, m,w  ,Uv,w,r\")\n+\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,Dv,mF,r,UvF,w, w,r\"))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n    && (   register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -344,28 +350,31 @@\n \treturn \\\"fmdrr%?\\\\t%P0, %Q1, %R1\\\";\n       case 1:\n \treturn \\\"fmrrd%?\\\\t%Q0, %R0, %P1\\\";\n-      case 2: case 3:\n+      case 2:\n+        return \\\"fconstd%?\\\\t%P0, #%G1\\\";\n+      case 3: case 4:\n \treturn output_move_double (operands);\n-      case 4: case 5:\n+      case 5: case 6:\n \treturn output_move_vfp (operands);\n-      case 6:\n-\treturn \\\"fcpyd%?\\\\t%P0, %P1\\\";\n       case 7:\n+\treturn \\\"fcpyd%?\\\\t%P0, %P1\\\";\n+      case 8:\n         return \\\"#\\\";\n       default:\n \tgcc_unreachable ();\n       }\n     }\n   \"\n-  [(set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,load2,store2,f_loadd,f_stored\")\n-   (set_attr \"length\" \"4,4,8,8,4,4,4,8\")\n-   (set_attr \"pool_range\" \"*,*,1020,*,1020,*,*,*\")\n-   (set_attr \"neg_pool_range\" \"*,*,1008,*,1008,*,*,*\")]\n+  [(set_attr \"type\"\n+     \"r_2_f,f_2_r,farith,f_loadd,f_stored,load2,store2,ffarith,*\")\n+   (set_attr \"length\" \"4,4,4,8,8,4,4,4,8\")\n+   (set_attr \"pool_range\" \"*,*,*,1020,*,1020,*,*,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,*,1008,*,1008,*,*,*\")]\n )\n \n (define_insn \"*thumb2_movdf_vfp\"\n-  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,r, m,w  ,Uv,w,r\")\n-\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,mF,r,UvF,w, w,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,w ,r, m,w  ,Uv,w,r\")\n+\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,Dv,mF,r,UvF,w, w,r\"))]\n   \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"*\n   {\n@@ -375,33 +384,36 @@\n \treturn \\\"fmdrr%?\\\\t%P0, %Q1, %R1\\\";\n       case 1:\n \treturn \\\"fmrrd%?\\\\t%Q0, %R0, %P1\\\";\n-      case 2: case 3: case 7:\n+      case 2:\n+\treturn \\\"fconstd%?\\\\t%P0, #%G1\\\";\n+      case 3: case 4: case 8:\n \treturn output_move_double (operands);\n-      case 4: case 5:\n+      case 5: case 6:\n \treturn output_move_vfp (operands);\n-      case 6:\n+      case 7:\n \treturn \\\"fcpyd%?\\\\t%P0, %P1\\\";\n       default:\n \tabort ();\n       }\n     }\n   \"\n-  [(set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,load2,store2,f_load,f_store\")\n-   (set_attr \"length\" \"4,4,8,8,4,4,4,8\")\n-   (set_attr \"pool_range\" \"*,*,4096,*,1020,*,*,*\")\n-   (set_attr \"neg_pool_range\" \"*,*,0,*,1008,*,*,*\")]\n+  [(set_attr \"type\"\n+     \"r_2_f,f_2_r,farith,load2,store2,f_load,f_store,ffarith,*\")\n+   (set_attr \"length\" \"4,4,4,8,8,4,4,4,8\")\n+   (set_attr \"pool_range\" \"*,*,*,4096,*,1020,*,*,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,*,0,*,1008,*,*,*\")]\n )\n \n \n ;; Conditional move patterns\n \n (define_insn \"*movsfcc_vfp\"\n-  [(set (match_operand:SF   0 \"s_register_operand\" \"=w,w,w,w,w,w,?r,?r,?r\")\n+  [(set (match_operand:SF   0 \"s_register_operand\" \"=t,t,t,t,t,t,?r,?r,?r\")\n \t(if_then_else:SF\n \t  (match_operator   3 \"arm_comparison_operator\"\n \t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n-\t  (match_operand:SF 1 \"s_register_operand\" \"0,w,w,0,?r,?r,0,w,w\")\n-\t  (match_operand:SF 2 \"s_register_operand\" \"w,0,w,?r,0,?r,w,0,w\")))]\n+\t  (match_operand:SF 1 \"s_register_operand\" \"0,t,t,0,?r,?r,0,t,t\")\n+\t  (match_operand:SF 2 \"s_register_operand\" \"t,0,t,?r,0,?r,t,0,t\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"@\n    fcpys%D3\\\\t%0, %2\n@@ -419,12 +431,12 @@\n )\n \n (define_insn \"*thumb2_movsfcc_vfp\"\n-  [(set (match_operand:SF   0 \"s_register_operand\" \"=w,w,w,w,w,w,?r,?r,?r\")\n+  [(set (match_operand:SF   0 \"s_register_operand\" \"=t,t,t,t,t,t,?r,?r,?r\")\n \t(if_then_else:SF\n \t  (match_operator   3 \"arm_comparison_operator\"\n \t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n-\t  (match_operand:SF 1 \"s_register_operand\" \"0,w,w,0,?r,?r,0,w,w\")\n-\t  (match_operand:SF 2 \"s_register_operand\" \"w,0,w,?r,0,?r,w,0,w\")))]\n+\t  (match_operand:SF 1 \"s_register_operand\" \"0,t,t,0,?r,?r,0,t,t\")\n+\t  (match_operand:SF 2 \"s_register_operand\" \"t,0,t,?r,0,?r,t,0,t\")))]\n   \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"@\n    it\\\\t%D3\\;fcpys%D3\\\\t%0, %2\n@@ -491,8 +503,8 @@\n ;; Sign manipulation functions\n \n (define_insn \"*abssf2_vfp\"\n-  [(set (match_operand:SF\t  0 \"s_register_operand\" \"=w\")\n-\t(abs:SF (match_operand:SF 1 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t  0 \"s_register_operand\" \"=t\")\n+\t(abs:SF (match_operand:SF 1 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fabss%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -509,8 +521,8 @@\n )\n \n (define_insn \"*negsf2_vfp\"\n-  [(set (match_operand:SF\t  0 \"s_register_operand\" \"=w,?r\")\n-\t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"w,r\")))]\n+  [(set (match_operand:SF\t  0 \"s_register_operand\" \"=t,?r\")\n+\t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"t,r\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"@\n    fnegs%?\\\\t%0, %1\n@@ -569,9 +581,9 @@\n ;; Arithmetic insns\n \n (define_insn \"*addsf3_vfp\"\n-  [(set (match_operand:SF\t   0 \"s_register_operand\" \"=w\")\n-\t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"w\")\n-\t\t (match_operand:SF 2 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t   0 \"s_register_operand\" \"=t\")\n+\t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n+\t\t (match_operand:SF 2 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fadds%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -590,9 +602,9 @@\n \n \n (define_insn \"*subsf3_vfp\"\n-  [(set (match_operand:SF\t    0 \"s_register_operand\" \"=w\")\n-\t(minus:SF (match_operand:SF 1 \"s_register_operand\" \"w\")\n-\t\t  (match_operand:SF 2 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t    0 \"s_register_operand\" \"=t\")\n+\t(minus:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n+\t\t  (match_operand:SF 2 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fsubs%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -613,9 +625,9 @@\n ;; Division insns\n \n (define_insn \"*divsf3_vfp\"\n-  [(set (match_operand:SF\t  0 \"s_register_operand\" \"+w\")\n-\t(div:SF (match_operand:SF 1 \"s_register_operand\" \"w\")\n-\t\t(match_operand:SF 2 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t  0 \"s_register_operand\" \"+t\")\n+\t(div:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n+\t\t(match_operand:SF 2 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fdivs%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -636,9 +648,9 @@\n ;; Multiplication insns\n \n (define_insn \"*mulsf3_vfp\"\n-  [(set (match_operand:SF\t   0 \"s_register_operand\" \"+w\")\n-\t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"w\")\n-\t\t (match_operand:SF 2 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t   0 \"s_register_operand\" \"+t\")\n+\t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n+\t\t (match_operand:SF 2 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fmuls%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -657,9 +669,9 @@\n \n \n (define_insn \"*mulsf3negsf_vfp\"\n-  [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"+w\")\n-\t(mult:SF (neg:SF (match_operand:SF 1 \"s_register_operand\" \"w\"))\n-\t\t (match_operand:SF\t   2 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"+t\")\n+\t(mult:SF (neg:SF (match_operand:SF 1 \"s_register_operand\" \"t\"))\n+\t\t (match_operand:SF\t   2 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fnmuls%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -681,9 +693,9 @@\n \n ;; 0 = 1 * 2 + 0\n (define_insn \"*mulsf3addsf_vfp\"\n-  [(set (match_operand:SF\t\t    0 \"s_register_operand\" \"=w\")\n-\t(plus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"w\")\n-\t\t\t  (match_operand:SF 3 \"s_register_operand\" \"w\"))\n+  [(set (match_operand:SF\t\t    0 \"s_register_operand\" \"=t\")\n+\t(plus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"t\")\n+\t\t\t  (match_operand:SF 3 \"s_register_operand\" \"t\"))\n \t\t (match_operand:SF\t    1 \"s_register_operand\" \"0\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fmacs%?\\\\t%0, %2, %3\"\n@@ -704,9 +716,9 @@\n \n ;; 0 = 1 * 2 - 0\n (define_insn \"*mulsf3subsf_vfp\"\n-  [(set (match_operand:SF\t\t     0 \"s_register_operand\" \"=w\")\n-\t(minus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"w\")\n-\t\t\t   (match_operand:SF 3 \"s_register_operand\" \"w\"))\n+  [(set (match_operand:SF\t\t     0 \"s_register_operand\" \"=t\")\n+\t(minus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"t\")\n+\t\t\t   (match_operand:SF 3 \"s_register_operand\" \"t\"))\n \t\t  (match_operand:SF\t     1 \"s_register_operand\" \"0\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fmscs%?\\\\t%0, %2, %3\"\n@@ -727,10 +739,10 @@\n \n ;; 0 = -(1 * 2) + 0\n (define_insn \"*mulsf3negsfaddsf_vfp\"\n-  [(set (match_operand:SF\t\t     0 \"s_register_operand\" \"=w\")\n+  [(set (match_operand:SF\t\t     0 \"s_register_operand\" \"=t\")\n \t(minus:SF (match_operand:SF\t     1 \"s_register_operand\" \"0\")\n-\t\t  (mult:SF (match_operand:SF 2 \"s_register_operand\" \"w\")\n-\t\t\t   (match_operand:SF 3 \"s_register_operand\" \"w\"))))]\n+\t\t  (mult:SF (match_operand:SF 2 \"s_register_operand\" \"t\")\n+\t\t\t   (match_operand:SF 3 \"s_register_operand\" \"t\"))))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fnmacs%?\\\\t%0, %2, %3\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -751,10 +763,10 @@\n \n ;; 0 = -(1 * 2) - 0\n (define_insn \"*mulsf3negsfsubsf_vfp\"\n-  [(set (match_operand:SF\t\t      0 \"s_register_operand\" \"=w\")\n+  [(set (match_operand:SF\t\t      0 \"s_register_operand\" \"=t\")\n \t(minus:SF (mult:SF\n-\t\t    (neg:SF (match_operand:SF 2 \"s_register_operand\" \"w\"))\n-\t\t    (match_operand:SF\t      3 \"s_register_operand\" \"w\"))\n+\t\t    (neg:SF (match_operand:SF 2 \"s_register_operand\" \"t\"))\n+\t\t    (match_operand:SF\t      3 \"s_register_operand\" \"t\"))\n \t\t  (match_operand:SF\t      1 \"s_register_operand\" \"0\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fnmscs%?\\\\t%0, %2, %3\"\n@@ -779,15 +791,15 @@\n \n (define_insn \"*extendsfdf2_vfp\"\n   [(set (match_operand:DF\t\t   0 \"s_register_operand\" \"=w\")\n-\t(float_extend:DF (match_operand:SF 1 \"s_register_operand\" \"w\")))]\n+\t(float_extend:DF (match_operand:SF 1 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fcvtds%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"*truncdfsf2_vfp\"\n-  [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=w\")\n+  [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=t\")\n \t(float_truncate:SF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fcvtsd%?\\\\t%0, %P1\"\n@@ -796,16 +808,16 @@\n )\n \n (define_insn \"*truncsisf2_vfp\"\n-  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=w\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"w\"))))]\n+  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"t\"))))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"ftosizs%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"*truncsidf2_vfp\"\n-  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=w\")\n+  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\" \"w\"))))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"ftosizd%?\\\\t%0, %P1\"\n@@ -815,17 +827,17 @@\n \n \n (define_insn \"fixuns_truncsfsi2\"\n-  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=w\")\n-\t(unsigned_fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"w\"))))]\n+  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n+\t(unsigned_fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"t\"))))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"ftouizs%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"fixuns_truncdfsi2\"\n-  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=w\")\n-\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\" \"w\"))))]\n+  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n+\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\" \"t\"))))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"ftouizd%?\\\\t%0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -834,8 +846,8 @@\n \n \n (define_insn \"*floatsisf2_vfp\"\n-  [(set (match_operand:SF\t    0 \"s_register_operand\" \"=w\")\n-\t(float:SF (match_operand:SI 1 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t    0 \"s_register_operand\" \"=t\")\n+\t(float:SF (match_operand:SI 1 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fsitos%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -844,7 +856,7 @@\n \n (define_insn \"*floatsidf2_vfp\"\n   [(set (match_operand:DF\t    0 \"s_register_operand\" \"=w\")\n-\t(float:DF (match_operand:SI 1 \"s_register_operand\" \"w\")))]\n+\t(float:DF (match_operand:SI 1 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fsitod%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -853,8 +865,8 @@\n \n \n (define_insn \"floatunssisf2\"\n-  [(set (match_operand:SF\t    0 \"s_register_operand\" \"=w\")\n-\t(unsigned_float:SF (match_operand:SI 1 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t    0 \"s_register_operand\" \"=t\")\n+\t(unsigned_float:SF (match_operand:SI 1 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fuitos%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -863,7 +875,7 @@\n \n (define_insn \"floatunssidf2\"\n   [(set (match_operand:DF\t    0 \"s_register_operand\" \"=w\")\n-\t(unsigned_float:DF (match_operand:SI 1 \"s_register_operand\" \"w\")))]\n+\t(unsigned_float:DF (match_operand:SI 1 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fuitod%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -874,8 +886,8 @@\n ;; Sqrt insns.\n \n (define_insn \"*sqrtsf2_vfp\"\n-  [(set (match_operand:SF\t   0 \"s_register_operand\" \"=w\")\n-\t(sqrt:SF (match_operand:SF 1 \"s_register_operand\" \"w\")))]\n+  [(set (match_operand:SF\t   0 \"s_register_operand\" \"=t\")\n+\t(sqrt:SF (match_operand:SF 1 \"s_register_operand\" \"t\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fsqrts%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n@@ -905,8 +917,8 @@\n \n (define_insn_and_split \"*cmpsf_split_vfp\"\n   [(set (reg:CCFP CC_REGNUM)\n-\t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"w\")\n-\t\t      (match_operand:SF 1 \"vfp_compare_operand\" \"wG\")))]\n+\t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"t\")\n+\t\t      (match_operand:SF 1 \"vfp_compare_operand\" \"tG\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"#\"\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n@@ -920,8 +932,8 @@\n \n (define_insn_and_split \"*cmpsf_trap_split_vfp\"\n   [(set (reg:CCFPE CC_REGNUM)\n-\t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\"  \"w\")\n-\t\t       (match_operand:SF 1 \"vfp_compare_operand\" \"wG\")))]\n+\t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\"  \"t\")\n+\t\t       (match_operand:SF 1 \"vfp_compare_operand\" \"tG\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"#\"\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n@@ -968,8 +980,8 @@\n \n (define_insn \"*cmpsf_vfp\"\n   [(set (reg:CCFP VFPCC_REGNUM)\n-\t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"w,w\")\n-\t\t      (match_operand:SF 1 \"vfp_compare_operand\" \"w,G\")))]\n+\t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"t,t\")\n+\t\t      (match_operand:SF 1 \"vfp_compare_operand\" \"t,G\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"@\n    fcmps%?\\\\t%0, %1\n@@ -980,8 +992,8 @@\n \n (define_insn \"*cmpsf_trap_vfp\"\n   [(set (reg:CCFPE VFPCC_REGNUM)\n-\t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\"  \"w,w\")\n-\t\t       (match_operand:SF 1 \"vfp_compare_operand\" \"w,G\")))]\n+\t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\"  \"t,t\")\n+\t\t       (match_operand:SF 1 \"vfp_compare_operand\" \"t,G\")))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"@\n    fcmpes%?\\\\t%0, %1"}]}