{"sha": "5a3c9cf200bc4614ae9b6390835759365d4663e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEzYzljZjIwMGJjNDYxNGFlOWI2MzkwODM1NzU5MzY1ZDQ2NjNlNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-05-10T21:14:09Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-05-10T21:14:09Z"}, "message": "re PR c++/53158 ([C++11] Bogus error in loop condition)\n\n/cp\n2012-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/53158\n\t* cvt.c (ocp_convert): Error out early for void -> bool conversions.\n\t* typeck.c (decay_conversion): Use error_at.\n\t* call.c (build_integral_nontype_arg_conv, convert_like_real,\n\tconvert_arg_to_ellipsis, perform_implicit_conversion_flags,\n\tinitialize_reference): Likewise.\n\t* cvt.c (warn_ref_binding): Add location_t parameter.\n\t(cp_convert_to_pointer, convert_to_reference, ocp_convert,\n\tconvert_to_void, ): Use error_at and warning_at.\n\n/c-family\n2012-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/53158\n\t* c-common.c (warnings_for_convert_and_check): Use warning_at.\n\n/testsuite\n2012-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/53158\n\t* g++.dg/cpp0x/lambda/lambda-err2.C: New.\n\t* g++.dg/parse/error26.C: Tweak dg-error column number.\n\nFrom-SVN: r187380", "tree": {"sha": "2c4209dd21db6e45465e20c55250c2a8de94b87d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c4209dd21db6e45465e20c55250c2a8de94b87d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a3c9cf200bc4614ae9b6390835759365d4663e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a3c9cf200bc4614ae9b6390835759365d4663e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a3c9cf200bc4614ae9b6390835759365d4663e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a3c9cf200bc4614ae9b6390835759365d4663e5/comments", "author": null, "committer": null, "parents": [{"sha": "e5f13bf49ae0c4fd0ee897c0614ad8631afdb407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f13bf49ae0c4fd0ee897c0614ad8631afdb407", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f13bf49ae0c4fd0ee897c0614ad8631afdb407"}], "stats": {"total": 392, "additions": 225, "deletions": 167}, "files": [{"sha": "a01f3eaef459000d4931e0e6ec261953b899c062", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -1,3 +1,8 @@\n+2012-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/53158\n+\t* c-common.c (warnings_for_convert_and_check): Use warning_at.\n+\n 2012-05-10  Richard Guenther  <rguenther@suse.de>\n \n \t* c-common.c (c_sizeof_or_alignof_type): Remove assert and"}, {"sha": "ad988286ee66b6f9a0aef43587064b45c106580c", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -2329,6 +2329,8 @@ conversion_warning (tree type, tree expr)\n void\n warnings_for_convert_and_check (tree type, tree expr, tree result)\n {\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n+\n   if (TREE_CODE (expr) == INTEGER_CST\n       && (TREE_CODE (type) == INTEGER_TYPE\n           || TREE_CODE (type) == ENUMERAL_TYPE)\n@@ -2344,8 +2346,8 @@ warnings_for_convert_and_check (tree type, tree expr, tree result)\n           /* This detects cases like converting -129 or 256 to\n              unsigned char.  */\n           if (!int_fits_type_p (expr, c_common_signed_type (type)))\n-            warning (OPT_Woverflow,\n-                     \"large integer implicitly truncated to unsigned type\");\n+            warning_at (loc, OPT_Woverflow,\n+\t\t\t\"large integer implicitly truncated to unsigned type\");\n           else\n             conversion_warning (type, expr);\n         }\n@@ -2357,16 +2359,16 @@ warnings_for_convert_and_check (tree type, tree expr, tree result)\n \t       && (TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE\n \t\t   || TYPE_PRECISION (TREE_TYPE (expr))\n \t\t   != TYPE_PRECISION (type)))\n-\twarning (OPT_Woverflow,\n-\t\t \"overflow in implicit constant conversion\");\n+\twarning_at (loc, OPT_Woverflow,\n+\t\t    \"overflow in implicit constant conversion\");\n \n       else\n \tconversion_warning (type, expr);\n     }\n   else if ((TREE_CODE (result) == INTEGER_CST\n \t    || TREE_CODE (result) == FIXED_CST) && TREE_OVERFLOW (result))\n-    warning (OPT_Woverflow,\n-             \"overflow in implicit constant conversion\");\n+    warning_at (loc, OPT_Woverflow,\n+\t\t\"overflow in implicit constant conversion\");\n   else\n     conversion_warning (type, expr);\n }"}, {"sha": "99b1eb5fdf27d97b09108ecbf642d6f9f91cc064", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -1,3 +1,15 @@\n+2012-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/53158\n+\t* cvt.c (ocp_convert): Error out early for void -> bool conversions.\n+\t* typeck.c (decay_conversion): Use error_at.\n+\t* call.c (build_integral_nontype_arg_conv, convert_like_real,\n+\tconvert_arg_to_ellipsis, perform_implicit_conversion_flags,\n+\tinitialize_reference): Likewise.\n+\t* cvt.c (warn_ref_binding): Add location_t parameter.\n+\t(cp_convert_to_pointer, convert_to_reference, ocp_convert,\n+\tconvert_to_void, ): Use error_at and warning_at.\n+\n 2012-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/53301"}, {"sha": "53ff78bf9efe34e4ad3ae1888b0fad89909f2240", "filename": "gcc/cp/call.c", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -3182,7 +3182,7 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n \t\tcandidate->convs[0]->type);\n     }\n   else if (TYPE_P (candidate->fn))\n-    inform (input_location, \"%s%T <conversion>\", msg, candidate->fn);\n+    inform (loc, \"%s%T <conversion>\", msg, candidate->fn);\n   else if (candidate->viable == -1)\n     inform (loc, \"%s%#D <near match>\", msg, candidate->fn);\n   else if (DECL_DELETED_FN (STRIP_TEMPLATE (candidate->fn)))\n@@ -3692,6 +3692,7 @@ build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n   conversion *conv;\n   void *p;\n   tree t;\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n \n   if (error_operand_p (expr))\n     return error_mark_node;\n@@ -3727,8 +3728,8 @@ build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n \t  break;\n \n \tif (complain & tf_error)\n-\t  error (\"conversion from %qT to %qT not considered for \"\n-\t\t \"non-type template argument\", t, type);\n+\t  error_at (loc, \"conversion from %qT to %qT not considered for \"\n+\t\t    \"non-type template argument\", t, type);\n \t/* and fall through.  */\n \n       default:\n@@ -5648,6 +5649,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n   tree totype = convs->type;\n   diagnostic_t diag_kind;\n   int flags;\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n \n   if (convs->bad_p && !(complain & tf_error))\n     return error_mark_node;\n@@ -5668,13 +5670,13 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  && SCALAR_TYPE_P (totype)\n \t  && CONSTRUCTOR_NELTS (expr) > 0\n \t  && BRACE_ENCLOSED_INITIALIZER_P (CONSTRUCTOR_ELT (expr, 0)->value))\n-\tpermerror (input_location, \"too many braces around initializer for %qT\", totype);\n+\tpermerror (loc, \"too many braces around initializer for %qT\", totype);\n \n       for (; t ; t = next_conversion (t))\n \t{\n \t  if (t->kind == ck_user && t->cand->reason)\n \t    {\n-\t      permerror (input_location, \"invalid user-defined conversion \"\n+\t      permerror (loc, \"invalid user-defined conversion \"\n \t\t\t \"from %qT to %qT\", TREE_TYPE (expr), totype);\n \t      print_z_candidate (\"candidate is:\", t->cand);\n \t      expr = convert_like_real (t, expr, fn, argnum, 1,\n@@ -5704,7 +5706,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    break;\n \t}\n \n-      permerror (input_location, \"invalid conversion from %qT to %qT\",\n+      permerror (loc, \"invalid conversion from %qT to %qT\",\n \t\t TREE_TYPE (expr), totype);\n       if (fn)\n \tpermerror (DECL_SOURCE_LOCATION (fn),\n@@ -5937,8 +5939,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    gcc_assert (TYPE_REF_IS_RVALUE (ref_type)\n \t\t\t&& real_lvalue_p (expr));\n \n-\t    error (\"cannot bind %qT lvalue to %qT\",\n-\t\t   TREE_TYPE (expr), totype);\n+\t    error_at (loc, \"cannot bind %qT lvalue to %qT\",\n+\t\t      TREE_TYPE (expr), totype);\n \t    if (fn)\n \t      error (\"  initializing argument %P of %q+D\", argnum, fn);\n \t    return error_mark_node;\n@@ -5969,13 +5971,14 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t/* If the reference is volatile or non-const, we\n \t\t   cannot create a temporary.  */\n \t\tif (lvalue & clk_bitfield)\n-\t\t  error (\"cannot bind bitfield %qE to %qT\",\n-\t\t\t expr, ref_type);\n+\t\t  error_at (loc, \"cannot bind bitfield %qE to %qT\",\n+\t\t\t    expr, ref_type);\n \t\telse if (lvalue & clk_packed)\n-\t\t  error (\"cannot bind packed field %qE to %qT\",\n-\t\t\t expr, ref_type);\n+\t\t  error_at (loc, \"cannot bind packed field %qE to %qT\",\n+\t\t\t    expr, ref_type);\n \t\telse\n-\t\t  error (\"cannot bind rvalue %qE to %qT\", expr, ref_type);\n+\t\t  error_at (loc, \"cannot bind rvalue %qE to %qT\",\n+\t\t\t    expr, ref_type);\n \t\treturn error_mark_node;\n \t      }\n \t    /* If the source is a packed field, and we must use a copy\n@@ -5988,8 +5991,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t&& CLASS_TYPE_P (type)\n \t\t&& type_has_nontrivial_copy_init (type))\n \t      {\n-\t\terror (\"cannot bind packed field %qE to %qT\",\n-\t\t       expr, ref_type);\n+\t\terror_at (loc, \"cannot bind packed field %qE to %qT\",\n+\t\t\t  expr, ref_type);\n \t\treturn error_mark_node;\n \t      }\n \t    if (lvalue & clk_bitfield)\n@@ -6055,6 +6058,7 @@ tree\n convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n {\n   tree arg_type;\n+  location_t loc = EXPR_LOC_OR_HERE (arg);\n \n   /* [expr.call]\n \n@@ -6076,10 +6080,10 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n     {\n       if ((complain & tf_warning)\n \t  && warn_double_promotion && !c_inhibit_evaluation_warnings)\n-\twarning (OPT_Wdouble_promotion,\n-\t\t \"implicit conversion from %qT to %qT when passing \"\n-\t\t \"argument to function\",\n-\t\t arg_type, double_type_node);\n+\twarning_at (loc, OPT_Wdouble_promotion,\n+\t\t    \"implicit conversion from %qT to %qT when passing \"\n+\t\t    \"argument to function\",\n+\t\t    arg_type, double_type_node);\n       arg = convert_to_real (double_type_node, arg);\n     }\n   else if (NULLPTR_TYPE_P (arg_type))\n@@ -6089,8 +6093,8 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n       if (SCOPED_ENUM_P (arg_type) && !abi_version_at_least (6))\n \t{\n \t  if (complain & tf_warning)\n-\t    warning (OPT_Wabi, \"scoped enum %qT will not promote to an \"\n-\t\t     \"integral type in a future version of GCC\", arg_type);\n+\t    warning_at (loc, OPT_Wabi, \"scoped enum %qT will not promote to an \"\n+\t\t\t\"integral type in a future version of GCC\", arg_type);\n \t  arg = cp_convert (ENUM_UNDERLYING_TYPE (arg_type), arg);\n \t}\n       arg = perform_integral_promotions (arg);\n@@ -6126,8 +6130,8 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n \t      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (arg_type)))\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"cannot pass objects of non-trivially-copyable \"\n-\t\t   \"type %q#T through %<...%>\", arg_type);\n+\t    error_at (loc, \"cannot pass objects of non-trivially-copyable \"\n+\t\t      \"type %q#T through %<...%>\", arg_type);\n \t  else\n \t    return error_mark_node;\n \t}\n@@ -8532,6 +8536,7 @@ perform_implicit_conversion_flags (tree type, tree expr,\n {\n   conversion *conv;\n   void *p;\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n \n   if (error_operand_p (expr))\n     return error_mark_node;\n@@ -8554,8 +8559,8 @@ perform_implicit_conversion_flags (tree type, tree expr,\n \t  else if (invalid_nonstatic_memfn_p (expr, complain))\n \t    /* We gave an error.  */;\n \t  else\n-\t    error (\"could not convert %qE from %qT to %qT\", expr,\n-\t\t   TREE_TYPE (expr), type);\n+\t    error_at (loc, \"could not convert %qE from %qT to %qT\", expr,\n+\t\t      TREE_TYPE (expr), type);\n \t}\n       expr = error_mark_node;\n     }\n@@ -8833,6 +8838,7 @@ initialize_reference (tree type, tree expr,\n {\n   conversion *conv;\n   void *p;\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n \n   if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;\n@@ -8851,13 +8857,13 @@ initialize_reference (tree type, tree expr,\n \t  else if (!CP_TYPE_CONST_P (TREE_TYPE (type))\n \t\t   && !TYPE_REF_IS_RVALUE (type)\n \t\t   && !real_lvalue_p (expr))\n-\t    error (\"invalid initialization of non-const reference of \"\n-\t\t   \"type %qT from an rvalue of type %qT\",\n-\t\t   type, TREE_TYPE (expr));\n+\t    error_at (loc, \"invalid initialization of non-const reference of \"\n+\t\t      \"type %qT from an rvalue of type %qT\",\n+\t\t      type, TREE_TYPE (expr));\n \t  else\n-\t    error (\"invalid initialization of reference of type \"\n-\t\t   \"%qT from expression of type %qT\", type,\n-\t\t   TREE_TYPE (expr));\n+\t    error_at (loc, \"invalid initialization of reference of type \"\n+\t\t      \"%qT from expression of type %qT\", type,\n+\t\t      TREE_TYPE (expr));\n \t}\n       return error_mark_node;\n     }"}, {"sha": "3d8f7021d1fa7b3ff81ab6970a5cab55da1c5298", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 141, "deletions": 127, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -42,7 +42,7 @@ static tree cp_convert_to_pointer (tree, tree);\n static tree convert_to_pointer_force (tree, tree);\n static tree build_type_conversion (tree, tree);\n static tree build_up_reference (tree, tree, int, tree);\n-static void warn_ref_binding (tree, tree, tree);\n+static void warn_ref_binding (location_t, tree, tree, tree);\n \n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things\n@@ -79,6 +79,8 @@ cp_convert_to_pointer (tree type, tree expr)\n   tree intype = TREE_TYPE (expr);\n   enum tree_code form;\n   tree rval;\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n+\n   if (intype == error_mark_node)\n     return error_mark_node;\n \n@@ -87,17 +89,17 @@ cp_convert_to_pointer (tree type, tree expr)\n       intype = complete_type (intype);\n       if (!COMPLETE_TYPE_P (intype))\n \t{\n-\t  error (\"can%'t convert from incomplete type %qT to %qT\",\n-\t\t intype, type);\n+\t  error_at (loc, \"can%'t convert from incomplete type %qT to %qT\",\n+\t\t    intype, type);\n \t  return error_mark_node;\n \t}\n \n       rval = build_type_conversion (type, expr);\n       if (rval)\n \t{\n \t  if (rval == error_mark_node)\n-\t    error (\"conversion of %qE from %qT to %qT is ambiguous\",\n-\t\t   expr, intype, type);\n+\t    error_at (loc, \"conversion of %qE from %qT to %qT is ambiguous\",\n+\t\t      expr, intype, type);\n \t  return rval;\n \t}\n     }\n@@ -166,8 +168,8 @@ cp_convert_to_pointer (tree type, tree expr)\n \n       if (TYPE_PTRMEMFUNC_P (type))\n \t{\n-\t  error (\"cannot convert %qE from type %qT to type %qT\",\n-\t\t expr, intype, type);\n+\t  error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n+\t\t    expr, intype, type);\n \t  return error_mark_node;\n \t}\n \n@@ -192,17 +194,17 @@ cp_convert_to_pointer (tree type, tree expr)\n \t\t\t\t\t\t       tf_warning_or_error);\n \t    }\n \t}\n-      error (\"cannot convert %qE from type %qT to type %qT\",\n-\t     expr, intype, type);\n+      error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n+\t\texpr, intype, type);\n       return error_mark_node;\n     }\n \n   if (null_ptr_cst_p (expr))\n     {\n       if (c_inhibit_evaluation_warnings == 0\n \t  && !NULLPTR_TYPE_P (TREE_TYPE (expr)))\n-\twarning (OPT_Wzero_as_null_pointer_constant,\n-\t\t \"zero as null pointer constant\");\n+\twarning_at (loc, OPT_Wzero_as_null_pointer_constant,\n+\t\t    \"zero as null pointer constant\");\n \n       if (TYPE_PTRMEMFUNC_P (type))\n \treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0,\n@@ -221,7 +223,7 @@ cp_convert_to_pointer (tree type, tree expr)\n     }\n   else if (TYPE_PTR_TO_MEMBER_P (type) && INTEGRAL_CODE_P (form))\n     {\n-      error (\"invalid conversion from %qT to %qT\", intype, type);\n+      error_at (loc, \"invalid conversion from %qT to %qT\", intype, type);\n       return error_mark_node;\n     }\n \n@@ -242,8 +244,8 @@ cp_convert_to_pointer (tree type, tree expr)\n   if (type_unknown_p (expr))\n     return instantiate_type (type, expr, tf_warning_or_error);\n \n-  error (\"cannot convert %qE from type %qT to type %qT\",\n-\t expr, intype, type);\n+  error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n+\t    expr, intype, type);\n   return error_mark_node;\n }\n \n@@ -367,7 +369,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n    non-volatile const type.  */\n \n static void\n-warn_ref_binding (tree reftype, tree intype, tree decl)\n+warn_ref_binding (location_t loc, tree reftype, tree intype, tree decl)\n {\n   tree ttl = TREE_TYPE (reftype);\n \n@@ -388,7 +390,7 @@ warn_ref_binding (tree reftype, tree intype, tree decl)\n \tmsg = G_(\"conversion to non-const reference type %q#T from \"\n \t         \"rvalue of type %qT\");\n \n-      permerror (input_location, msg, reftype, intype);\n+      permerror (loc, msg, reftype, intype);\n     }\n }\n \n@@ -410,6 +412,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   bool can_convert_intype_to_type;\n   tsubst_flags_t complain = ((flags & LOOKUP_COMPLAIN)\n \t\t\t     ? tf_warning_or_error : tf_none);\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       && TREE_TYPE (expr) == unknown_type_node)\n@@ -455,11 +458,11 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t  tree ttr = lvalue_type (expr);\n \n \t  if (! real_lvalue_p (expr))\n-\t    warn_ref_binding (reftype, intype, decl);\n+\t    warn_ref_binding (loc, reftype, intype, decl);\n \n \t  if (! (convtype & CONV_CONST)\n \t\t   && !at_least_as_qualified_p (ttl, ttr))\n-\t    permerror (input_location, \"conversion from %qT to %qT discards qualifiers\",\n+\t    permerror (loc, \"conversion from %qT to %qT discards qualifiers\",\n \t\t       ttr, reftype);\n \t}\n \n@@ -477,8 +480,8 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n       if (TREE_CODE (intype) == POINTER_TYPE\n \t  && (comptypes (TREE_TYPE (intype), type,\n \t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n-\twarning (0, \"casting %qT to %qT does not dereference pointer\",\n-\t\t intype, reftype);\n+\twarning_at (loc, 0, \"casting %qT to %qT does not dereference pointer\",\n+\t\t    intype, reftype);\n \n       rval = cp_build_addr_expr (expr, tf_warning_or_error);\n       if (rval != error_mark_node)\n@@ -494,7 +497,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n                                          tf_warning_or_error);\n       if (rval == NULL_TREE || rval == error_mark_node)\n \treturn rval;\n-      warn_ref_binding (reftype, intype, decl);\n+      warn_ref_binding (loc, reftype, intype, decl);\n       rval = build_up_reference (reftype, rval, flags, decl);\n     }\n \n@@ -505,7 +508,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n     }\n \n   if (flags & LOOKUP_COMPLAIN)\n-    error (\"cannot convert type %qT to type %qT\", intype, reftype);\n+    error_at (loc, \"cannot convert type %qT to type %qT\", intype, reftype);\n \n   return error_mark_node;\n }\n@@ -633,6 +636,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   enum tree_code code = TREE_CODE (type);\n   const char *invalid_conv_diag;\n   tree e1;\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n \n   if (error_operand_p (e) || type == error_mark_node)\n     return error_mark_node;\n@@ -711,8 +715,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t      || TREE_CODE (intype) == POINTER_TYPE)\n \t    {\n \t      if (flags & LOOKUP_COMPLAIN)\n-\t\tpermerror (input_location, \"conversion from %q#T to %q#T\", intype, type);\n-\n+\t\tpermerror (loc, \"conversion from %q#T to %q#T\", intype, type);\n \t      if (!flag_permissive)\n \t\treturn error_mark_node;\n \t    }\n@@ -726,10 +729,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t     unspecified.  */\n \t  if (TREE_CODE (expr) == INTEGER_CST\n \t      && !int_fits_type_p (expr, ENUM_UNDERLYING_TYPE (type)))\n-\t    warning (OPT_Wconversion, \n-\t\t     \"the result of the conversion is unspecified because \"\n-\t\t     \"%qE is outside the range of type %qT\",\n-\t\t     expr, type);\n+\t    warning_at (loc, OPT_Wconversion, \n+\t\t\t\"the result of the conversion is unspecified because \"\n+\t\t\t\"%qE is outside the range of type %qT\",\n+\t\t\texpr, type);\n \t}\n       if (MAYBE_CLASS_TYPE_P (intype))\n \t{\n@@ -738,11 +741,18 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t  if (rval)\n \t    return rval;\n \t  if (flags & LOOKUP_COMPLAIN)\n-\t    error (\"%q#T used where a %qT was expected\", intype, type);\n+\t    error_at (loc, \"%q#T used where a %qT was expected\", intype, type);\n \t  return error_mark_node;\n \t}\n       if (code == BOOLEAN_TYPE)\n \t{\n+\t  if (TREE_CODE (intype) == VOID_TYPE)\n+\t    {\n+\t      error_at (loc, \"could not convert %qE from %<void%> to %<bool%>\",\n+\t\t\texpr);\n+\t      return error_mark_node;\n+\t    }\n+\n \t  /* We can't implicitly convert a scoped enum to bool, so convert\n \t     to the underlying type first.  */\n \t  if (SCOPED_ENUM_P (intype) && (convtype & CONV_STATIC))\n@@ -769,7 +779,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t  if (ret_val)\n \t    return ret_val;\n \t  if (flags & LOOKUP_COMPLAIN)\n-\t    error (\"%q#T used where a %qT was expected\", in_vtype, type);\n+\t    error_at (loc, \"%q#T used where a %qT was expected\", in_vtype, type);\n \t  return error_mark_node;\n \t}\n       return fold_if_not_in_template (convert_to_vector (type, e));\n@@ -784,7 +794,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t    return rval;\n \t  else\n \t    if (flags & LOOKUP_COMPLAIN)\n-\t      error (\"%q#T used where a floating point value was expected\",\n+\t      error_at (loc, \"%q#T used where a floating point value was expected\",\n \t\t\tTREE_TYPE (e));\n \t}\n       if (code == REAL_TYPE)\n@@ -845,8 +855,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       if (invalid_nonstatic_memfn_p (expr, tf_warning_or_error))\n \t/* We displayed the error message.  */;\n       else\n-\terror (\"conversion from %qT to non-scalar type %qT requested\",\n-\t       TREE_TYPE (expr), type);\n+\terror_at (loc, \"conversion from %qT to non-scalar type %qT requested\",\n+\t\t  TREE_TYPE (expr), type);\n     }\n   return error_mark_node;\n }\n@@ -873,6 +883,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n tree\n convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n {\n+  location_t loc = EXPR_LOC_OR_HERE (expr);\n+\n   if (expr == error_mark_node\n       || TREE_TYPE (expr) == error_mark_node)\n     return error_mark_node;\n@@ -903,7 +915,7 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n   if (TREE_CODE (expr) == PSEUDO_DTOR_EXPR)\n     {\n       if (complain & tf_error)\n-        error (\"pseudo-destructor is not called\");\n+        error_at (loc, \"pseudo-destructor is not called\");\n       return error_mark_node;\n     }\n   if (VOID_TYPE_P (TREE_TYPE (expr)))\n@@ -980,35 +992,35 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n \t      switch (implicit)\n \t\t{\n \t      \t  case ICV_CAST:\n-\t\t    warning (0, \"conversion to void will not access \"\n+\t\t    warning_at (loc, 0, \"conversion to void will not access \"\n \t\t\t\t\"object of incomplete type %qT\", type);\n \t\t    break;\n \t\t  case ICV_SECOND_OF_COND:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t\t\t\"incomplete type %qT in second operand \"\n \t\t\t\t\"of conditional expression\", type);\n \t\t    break;\n \t\t  case ICV_THIRD_OF_COND:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t\t\t\"incomplete type %qT in third operand \"\n \t\t\t\t\"of conditional expression\", type);\n \t\t    break;\n \t\t  case ICV_RIGHT_OF_COMMA:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t\t\t\"incomplete type %qT in right operand of \"\n \t\t\t\t\"comma operator\", type);\n \t\t    break;\n \t\t  case ICV_LEFT_OF_COMMA:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t\t\t\"incomplete type %qT in left operand of \"\n \t\t\t\t\"comma operator\", type);\n \t\t    break;\n \t\t  case ICV_STATEMENT:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t\t\t\"incomplete type %qT in statement\", type);\n \t\t     break;\n \t\t  case ICV_THIRD_IN_FOR:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t\t\t\"incomplete type %qT in for increment \"\n \t\t\t\t\"expression\", type);\n \t\t    break;\n@@ -1024,37 +1036,37 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n \t      switch (implicit)\n \t\t{\n \t      \t  case ICV_CAST:\n-\t\t    warning (0, \"conversion to void will not access \"\n+\t\t    warning_at (loc, 0, \"conversion to void will not access \"\n \t\t\t\t\"object of type %qT\", type);\n \t\t    break;\n \t\t  case ICV_SECOND_OF_COND:\n-\t\t    warning (0, \"implicit dereference will not access object \"\n-\t\t\t\t\"of type %qT in second operand of \"\n+\t\t    warning_at (loc, 0, \"implicit dereference will not access \"\n+\t\t\t\t\"object of type %qT in second operand of \"\n \t\t\t\t\"conditional expression\", type);\n \t\t    break;\n \t\t  case ICV_THIRD_OF_COND:\n-\t\t    warning (0, \"implicit dereference will not access object \"\n-\t\t  \t      \t\"of type %qT in third operand of \"\n+\t\t    warning_at (loc, 0, \"implicit dereference will not access \"\n+\t\t\t\t\"object of type %qT in third operand of \"\n \t\t\t\t\"conditional expression\", type);\n \t\t    break;\n \t\t  case ICV_RIGHT_OF_COMMA:\n-\t\t    warning (0, \"implicit dereference will not access object \"\n-\t\t    \t\t\"of type %qT in right operand of \"\n+\t\t    warning_at (loc, 0, \"implicit dereference will not access \"\n+\t\t\t\t\"object of type %qT in right operand of \"\n \t\t\t\t\"comma operator\", type);\n \t\t    break;\n \t\t  case ICV_LEFT_OF_COMMA:\n-\t\t    warning (0, \"implicit dereference will not access object \"\n-\t\t    \t\t\"of type %qT in left operand of comma operator\",\n-\t\t\t     type);\n+\t\t    warning_at (loc, 0, \"implicit dereference will not access \"\n+\t\t\t\t\"object of type %qT in left operand of comma \"\n+\t\t\t\t\"operator\", type);\n \t\t    break;\n \t\t  case ICV_STATEMENT:\n-\t\t    warning (0, \"implicit dereference will not access object \"\n-\t\t     \t\t\"of type %qT in statement\",  type);\n+\t\t    warning_at (loc, 0, \"implicit dereference will not access \"\n+\t\t\t\t\"object of type %qT in statement\",  type);\n \t\t     break;\n \t\t  case ICV_THIRD_IN_FOR:\n-\t\t    warning (0, \"implicit dereference will not access object \"\n-\t\t    \t\t\"of type %qT in for increment expression\",\n-\t\t\t     type);\n+\t\t    warning_at (loc, 0, \"implicit dereference will not access \"\n+\t\t\t\t\"object of type %qT in for increment expression\",\n+\t\t\t\ttype);\n \t\t    break;\n \t\t  default:\n \t\t    gcc_unreachable ();\n@@ -1066,37 +1078,37 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n \t      switch (implicit)\n \t\t{\n \t      \t  case ICV_CAST:\n-\t\t    warning (0, \"conversion to void will not access \"\n+\t\t    warning_at (loc, 0, \"conversion to void will not access \"\n \t\t\t\t\"object of non-trivially-copyable type %qT\",\n-\t\t\t     type);\n+\t\t\t\ttype);\n \t\t    break;\n \t\t  case ICV_SECOND_OF_COND:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t\t\t\"non-trivially-copyable type %qT in second \"\n \t\t\t\t\"operand of conditional expression\", type);\n \t\t    break;\n \t\t  case ICV_THIRD_OF_COND:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t  \t      \t\"non-trivially-copyable type %qT in third \"\n \t\t\t\t\"operand of conditional expression\", type);\n \t\t    break;\n \t\t  case ICV_RIGHT_OF_COMMA:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t    \t\t\"non-trivially-copyable type %qT in right \"\n \t\t\t\t\"operand of comma operator\", type);\n \t\t    break;\n \t\t  case ICV_LEFT_OF_COMMA:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t    \t\t\"non-trivially-copyable type %qT in left \"\n \t\t\t\t\"operand of comma operator\", type);\n \t\t    break;\n \t\t  case ICV_STATEMENT:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t     \t\t\"non-trivially-copyable type %qT in statement\",\n-\t\t\t      type);\n+\t\t\t\ttype);\n \t\t     break;\n \t\t  case ICV_THIRD_IN_FOR:\n-\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    warning_at (loc, 0, \"indirection will not access object of \"\n \t\t    \t\t\"non-trivially-copyable type %qT in for \"\n \t\t\t\t\"increment expression\", type);\n \t\t    break;\n@@ -1117,7 +1129,7 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n                 && (complain & tf_warning)\n                 && !TREE_NO_WARNING (expr)\n                 && !is_reference)\n-              warning (OPT_Wunused_value, \"value computed is not used\");\n+              warning_at (loc, OPT_Wunused_value, \"value computed is not used\");\n             expr = TREE_OPERAND (expr, 0);\n           }\n \n@@ -1134,37 +1146,37 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n \t  switch (implicit)\n \t    {\n \t      case ICV_CAST:\n-\t\twarning (0, \"conversion to void will not access \"\n+\t\twarning_at (loc, 0, \"conversion to void will not access \"\n \t\t\t    \"object %qE of incomplete type %qT\", expr, type);\n \t\tbreak;\n \t      case ICV_SECOND_OF_COND:\n-\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n-\t\t\t    \"be accessed in second operand of \"\n+\t        warning_at (loc, 0, \"variable %qE of incomplete type %qT will \"\n+\t\t\t    \"not be accessed in second operand of \"\n \t\t\t    \"conditional expression\", expr, type);\n \t\tbreak;\n \t      case ICV_THIRD_OF_COND:\n-\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n-\t\t\t    \"be accessed in third operand of \"\n+\t        warning_at (loc, 0, \"variable %qE of incomplete type %qT will \"\n+\t\t\t    \"not be accessed in third operand of \"\n \t\t\t    \"conditional expression\", expr, type);\n \t\tbreak;\n \t      case ICV_RIGHT_OF_COMMA:\n-\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n-\t\t\t    \"be accessed in right operand of comma operator\",\n-\t\t\t expr, type);\n+\t        warning_at (loc, 0, \"variable %qE of incomplete type %qT will \"\n+\t\t\t    \"not be accessed in right operand of comma operator\",\n+\t\t\t    expr, type);\n \t\tbreak;\n \t      case ICV_LEFT_OF_COMMA:\n-\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n-\t\t\t    \"be accessed in left operand of comma operator\",\n-\t\t\t expr, type);\n+\t        warning_at (loc, 0, \"variable %qE of incomplete type %qT will \"\n+\t\t\t    \"not be accessed in left operand of comma operator\",\n+\t\t\t    expr, type);\n \t\tbreak;\n \t      case ICV_STATEMENT:\n-\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n-\t\t            \"be accessed in statement\", expr, type);\n+\t        warning_at (loc, 0, \"variable %qE of incomplete type %qT will \"\n+\t\t\t    \"not be accessed in statement\", expr, type);\n \t\tbreak;\n \t      case ICV_THIRD_IN_FOR:\n-\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n-\t\t\t    \"be accessed in for increment expression\",\n-\t\t         expr, type);\n+\t        warning_at (loc, 0, \"variable %qE of incomplete type %qT will \"\n+\t\t\t    \"not be accessed in for increment expression\",\n+\t\t\t    expr, type);\n \t\tbreak;\n \t      default:\n \t        gcc_unreachable ();\n@@ -1211,32 +1223,32 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n \t  switch (implicit)\n \t    {\n \t      case ICV_CAST:\n-\t\terror (\"conversion to void \"\n-\t\t       \"cannot resolve address of overloaded function\");\n+\t\terror_at (loc, \"conversion to void \"\n+\t\t\t  \"cannot resolve address of overloaded function\");\n \t\tbreak;\n \t      case ICV_SECOND_OF_COND:\n-\t\terror (\"second operand of conditional expression \"\n-\t\t       \"cannot resolve address of overloaded function\");\n+\t\terror_at (loc, \"second operand of conditional expression \"\n+\t\t\t  \"cannot resolve address of overloaded function\");\n \t\tbreak;\n \t      case ICV_THIRD_OF_COND:\n-\t\terror (\"third operand of conditional expression \"\n-\t\t       \"cannot resolve address of overloaded function\");\n+\t\terror_at (loc, \"third operand of conditional expression \"\n+\t\t\t  \"cannot resolve address of overloaded function\");\n \t\tbreak;\n \t      case ICV_RIGHT_OF_COMMA:\n-\t\terror (\"right operand of comma operator \"\n-\t\t       \"cannot resolve address of overloaded function\");\n+\t\terror_at (loc, \"right operand of comma operator \"\n+\t\t\t  \"cannot resolve address of overloaded function\");\n \t\tbreak;\n \t      case ICV_LEFT_OF_COMMA:\n-\t\terror (\"left operand of comma operator \"\n-\t\t       \"cannot resolve address of overloaded function\");\n+\t\terror_at (loc, \"left operand of comma operator \"\n+\t\t\t  \"cannot resolve address of overloaded function\");\n \t\tbreak;\n \t      case ICV_STATEMENT:\n-\t\terror (\"statement \"\n-\t\t       \"cannot resolve address of overloaded function\");\n+\t\terror_at (loc, \"statement \"\n+\t\t\t  \"cannot resolve address of overloaded function\");\n \t\tbreak;\n \t      case ICV_THIRD_IN_FOR:\n-\t\terror (\"for increment expression \"\n-\t\t       \"cannot resolve address of overloaded function\");\n+\t\terror_at (loc, \"for increment expression \"\n+\t\t\t  \"cannot resolve address of overloaded function\");\n \t\tbreak;\n \t    }\n \telse\n@@ -1250,34 +1262,34 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n \t  switch (implicit)\n \t    {\n \t      case ICV_SECOND_OF_COND:\n-\t        warning (OPT_Waddress,\n-\t\t\t \"second operand of conditional expression \"\n-\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t        warning_at (loc, OPT_Waddress,\n+\t\t\t    \"second operand of conditional expression \"\n+\t\t\t    \"is a reference, not call, to function %qE\", expr);\n \t\tbreak;\n \t      case ICV_THIRD_OF_COND:\n-\t        warning (OPT_Waddress,\n-\t\t\t \"third operand of conditional expression \"\n-\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t        warning_at (loc, OPT_Waddress,\n+\t\t\t    \"third operand of conditional expression \"\n+\t\t\t    \"is a reference, not call, to function %qE\", expr);\n \t\tbreak;\n \t      case ICV_RIGHT_OF_COMMA:\n-\t        warning (OPT_Waddress,\n-\t\t\t \"right operand of comma operator \"\n-\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t\twarning_at (loc, OPT_Waddress,\n+\t\t\t    \"right operand of comma operator \"\n+\t\t\t    \"is a reference, not call, to function %qE\", expr);\n \t\tbreak;\n \t      case ICV_LEFT_OF_COMMA:\n-\t        warning (OPT_Waddress,\n-\t\t\t \"left operand of comma operator \"\n-\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t        warning_at (loc, OPT_Waddress,\n+\t\t\t    \"left operand of comma operator \"\n+\t\t\t    \"is a reference, not call, to function %qE\", expr);\n \t\tbreak;\n \t      case ICV_STATEMENT:\n-\t        warning (OPT_Waddress,\n-\t\t\t \"statement is a reference, not call, to function %qE\",\n-\t\t\t expr);\n+\t        warning_at (loc, OPT_Waddress,\n+\t\t\t    \"statement is a reference, not call, to function %qE\",\n+\t\t\t    expr);\n \t\tbreak;\n \t      case ICV_THIRD_IN_FOR:\n-\t        warning (OPT_Waddress,\n-\t\t\t \"for increment expression \"\n-\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t        warning_at (loc, OPT_Waddress,\n+\t\t\t    \"for increment expression \"\n+\t\t\t    \"is a reference, not call, to function %qE\", expr);\n \t\tbreak;\n \t      default:\n \t        gcc_unreachable ();\n@@ -1302,28 +1314,30 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n \t      switch (implicit)\n \t\t{\n \t\t  case ICV_SECOND_OF_COND:\n-\t\t    warning (OPT_Wunused_value,\n-\t\t\t     \"second operand of conditional expression has no effect\");\n+\t\t    warning_at (loc, OPT_Wunused_value,\n+\t\t\t\t\"second operand of conditional expression \"\n+\t\t\t\t\"has no effect\");\n \t\t    break;\n \t\t  case ICV_THIRD_OF_COND:\n-\t\t    warning (OPT_Wunused_value,\n-\t\t    \t     \"third operand of conditional expression has no effect\");\n+\t\t    warning_at (loc, OPT_Wunused_value,\n+\t\t\t\t\"third operand of conditional expression \"\n+\t\t\t\t\"has no effect\");\n \t\t    break;\n \t\t  case ICV_RIGHT_OF_COMMA:\n-\t\t    warning (OPT_Wunused_value,\n-\t\t    \t     \"right operand of comma operator has no effect\");\n+\t\t    warning_at (loc, OPT_Wunused_value,\n+\t\t\t\t\"right operand of comma operator has no effect\");\n \t\t    break;\n \t\t  case ICV_LEFT_OF_COMMA:\n-\t\t    warning (OPT_Wunused_value,\n-\t\t    \t     \"left operand of comma operator has no effect\");\n+\t\t    warning_at (loc, OPT_Wunused_value,\n+\t\t\t\t\"left operand of comma operator has no effect\");\n \t\t    break;\n \t\t  case ICV_STATEMENT:\n-\t\t    warning (OPT_Wunused_value,\n-\t\t    \t     \"statement has no effect\");\n+\t\t    warning_at (loc, OPT_Wunused_value,\n+\t\t\t\t\"statement has no effect\");\n \t\t    break;\n \t\t  case ICV_THIRD_IN_FOR:\n-\t\t    warning (OPT_Wunused_value,\n-\t\t    \t     \"for increment expression has no effect\");\n+\t\t    warning_at (loc, OPT_Wunused_value,\n+\t\t\t\t\"for increment expression has no effect\");\n \t\t    break;\n \t\t  default:\n \t\t    gcc_unreachable ();\n@@ -1361,7 +1375,7 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n \t\t\t    || code == POSTDECREMENT_EXPR\n \t\t\t    || code == POSTINCREMENT_EXPR)))\n                   && (complain & tf_warning))\n-\t\twarning (OPT_Wunused_value, \"value computed is not used\");\n+\t\twarning_at (loc, OPT_Wunused_value, \"value computed is not used\");\n \t    }\n \t}\n       expr = build1 (CONVERT_EXPR, void_type_node, expr);"}, {"sha": "7eed7548562bfe80f0fe8566ffcbe4a1d75be917", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -1822,6 +1822,7 @@ decay_conversion (tree exp, tsubst_flags_t complain)\n {\n   tree type;\n   enum tree_code code;\n+  location_t loc = EXPR_LOC_OR_HERE (exp);\n \n   type = TREE_TYPE (exp);\n   if (type == error_mark_node)\n@@ -1853,7 +1854,7 @@ decay_conversion (tree exp, tsubst_flags_t complain)\n   if (code == VOID_TYPE)\n     {\n       if (complain & tf_error)\n-\terror (\"void value not ignored as it ought to be\");\n+\terror_at (loc, \"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n   if (invalid_nonstatic_memfn_p (exp, complain))\n@@ -1882,7 +1883,7 @@ decay_conversion (tree exp, tsubst_flags_t complain)\n \t  && ! (TREE_CODE (exp) == CONSTRUCTOR && TREE_STATIC (exp)))\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"invalid use of non-lvalue array\");\n+\t    error_at (loc, \"invalid use of non-lvalue array\");\n \t  return error_mark_node;\n \t}\n "}, {"sha": "e4e5611683a75c9440e82d4e9309ba0dcbe14273", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -1,3 +1,9 @@\n+2012-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/53158\n+\t* g++.dg/cpp0x/lambda/lambda-err2.C: New.\n+\t* g++.dg/parse/error26.C: Tweak dg-error column number.\n+\n 2012-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/53301"}, {"sha": "aaa80f47000602ae89a4ea23f2ce1e46f1e02287", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-err2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-err2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-err2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-err2.C?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/53158\n+// { dg-do compile { target c++11 } }\n+\n+int main()\n+{\n+  auto a = []() { return true; };\n+  auto b = []() { return a(); };  // { dg-error \"'a' is not captured\" }\n+  int c, d;\n+  while (b() && c < d) // { dg-error \"could not convert\" }\n+    {\n+    }\n+}"}, {"sha": "1084e76d34a89d02e0b788fb4add6721bc96402c", "filename": "gcc/testsuite/g++.dg/parse/error26.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3c9cf200bc4614ae9b6390835759365d4663e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror26.C?ref=5a3c9cf200bc4614ae9b6390835759365d4663e5", "patch": "@@ -4,7 +4,7 @@\n void foo()\n {\n   if (({int c[2];})) ; // { dg-error \"7:ISO C.. forbids\" \"7\" }\n-  // { dg-error \"20:could not convert\" \"20\" { target *-*-* } 6 }\n+  // { dg-error \"17:could not convert\" \"17\" { target *-*-* } 6 }\n }\n \n void bar()"}]}