{"sha": "72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJkNGEyYWQ3OGQyNGM4YjgxMzM1YWQzNjUxYzRjOGEwM2Y1ZjFkZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-07-04T18:53:41Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-07-04T18:53:41Z"}, "message": "cfgloopanal.c (count_strange_loop_iterations): New static function.\n\n\t* cfgloopanal.c (count_strange_loop_iterations): New static function.\n\t(constant_iterations, count_loop_iterations, simple_loop_exit_p):\n\tHandle strange loops.\n\nFrom-SVN: r68930", "tree": {"sha": "f1e75a8f0e63060ffdfa037cf1131a89ae713ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1e75a8f0e63060ffdfa037cf1131a89ae713ad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de/comments", "author": null, "committer": null, "parents": [{"sha": "8e9a4a4525580a9dc40a9de5d21640a5f81ea0c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e9a4a4525580a9dc40a9de5d21640a5f81ea0c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e9a4a4525580a9dc40a9de5d21640a5f81ea0c0"}], "stats": {"total": 141, "additions": 134, "deletions": 7}, "files": [{"sha": "8900ccc35e506c6401e83a7497f38aaaf7ed3c93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de", "patch": "@@ -1,3 +1,9 @@\n+2003-07-04  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfgloopanal.c (count_strange_loop_iterations): New static function.\n+\t(constant_iterations, count_loop_iterations, simple_loop_exit_p):\n+\tHandle strange loops.\n+\n 2003-07-04  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n \t* install.texi: Even the g77 manpage is derived from"}, {"sha": "e5fd46c97754318d0b5d142f9e1e380685f43aa5", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 128, "deletions": 7, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=72d4a2ad78d24c8b81335ad3651c4c8a03f5f1de", "patch": "@@ -47,6 +47,8 @@ static bool simple_condition_p (struct loop *, rtx, regset,\n \t\t\t\tstruct loop_desc *);\n static basic_block simple_increment (struct loops *, struct loop *, rtx *,\n \t\t\t\t     struct loop_desc *);\n+static rtx count_strange_loop_iterations (rtx, rtx, enum rtx_code,\n+\t\t\t\t\t  int, rtx, enum machine_mode);\n \n /* Checks whether BB is executed exactly once in each LOOP iteration.  */\n bool\n@@ -426,7 +428,7 @@ constant_iterations (struct loop_desc *desc, unsigned HOST_WIDE_INT *niter,\n     {\n       alim = XEXP (desc->lim_alts, 0);\n       if (!(expr = count_loop_iterations (desc, XEXP (ainit, 0), alim)))\n-\tabort ();\n+\tcontinue;\n       if (GET_CODE (expr) == CONST_INT)\n \t{\n \t  *niter = INTVAL (expr);\n@@ -437,7 +439,7 @@ constant_iterations (struct loop_desc *desc, unsigned HOST_WIDE_INT *niter,\n     {\n       ainit = XEXP (desc->var_alts, 0);\n       if (!(expr = count_loop_iterations (desc, ainit, XEXP (alim, 0))))\n-\tabort ();\n+\tcontinue;\n       if (GET_CODE (expr) == CONST_INT)\n \t{\n \t  *niter = INTVAL (expr);\n@@ -448,6 +450,123 @@ constant_iterations (struct loop_desc *desc, unsigned HOST_WIDE_INT *niter,\n   return false;\n }\n \n+/* Attempts to determine a number of iterations of a \"strange\" loop.\n+   Its induction variable starts with value INIT, is compared by COND\n+   with LIM.  If POSTINCR, it is incremented after the test.  It is incremented\n+   by STRIDE each iteration and iterates in MODE.\n+\n+   By \"strange\" we mean loops where induction variable increases in the wrong\n+   direction wrto comparison, i.e. for (i = 6; i > 5; i++).  */\n+static rtx\n+count_strange_loop_iterations (rtx init, rtx lim, enum rtx_code cond,\n+\t\t\t       int postincr, rtx stride, enum machine_mode mode)\n+{\n+  rtx rqmt, n_to_wrap, before_wrap, after_wrap;\n+  rtx mode_min, mode_max;\n+  int size;\n+\n+  if (!postincr)\n+    init = simplify_gen_binary (PLUS, mode, init, stride);\n+\n+  /* If we are able to prove that we don't pass the first test, we are\n+     done.  */\n+  rqmt = simplify_gen_relational (cond, SImode, mode, init, lim);\n+  if (rqmt == const0_rtx)\n+    return const0_rtx;\n+\n+  /* And if we don't know we pass it, the things are too complicated for us.  */\n+  if (rqmt != const_true_rtx)\n+    return NULL_RTX;\n+\n+  switch (cond)\n+    {\n+    case GE:\n+    case GT:\n+    case LE:\n+    case LT:\n+      size = GET_MODE_BITSIZE (mode);\n+      mode_min = GEN_INT (-((unsigned HOST_WIDEST_INT) 1 << (size - 1)));\n+      mode_max = GEN_INT (((unsigned HOST_WIDEST_INT) 1 << (size - 1)) - 1);\n+\t\t\t      \n+      break;\n+\n+    case GEU:\n+    case GTU:\n+    case LEU:\n+    case LTU:\n+    case EQ:\n+      mode_min = const0_rtx;\n+      mode_max = simplify_gen_binary (MINUS, mode, const0_rtx, const1_rtx);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  switch (cond)\n+    {\n+    case EQ:\n+      /* This iterates once, as init == lim.  */\n+      return const1_rtx;\n+\n+      /* The behavior is undefined in signed cases.  Never mind, we still\n+\t try to behave sanely.  */\n+    case GE:\n+    case GT:\n+    case GEU:\n+    case GTU:\n+      if (INTVAL (stride) <= 0)\n+\tabort ();\n+      n_to_wrap = simplify_gen_binary (MINUS, mode, mode_max, copy_rtx (init));\n+      n_to_wrap = simplify_gen_binary (UDIV, mode, n_to_wrap, stride);\n+      before_wrap = simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t copy_rtx (n_to_wrap), stride);\n+      before_wrap = simplify_gen_binary (PLUS, mode,\n+\t\t\t\t\t before_wrap, copy_rtx (init));\n+      after_wrap = simplify_gen_binary (PLUS, mode,\n+\t\t\t\t\tbefore_wrap, stride);\n+      if (GET_CODE (after_wrap) != CONST_INT)\n+\t{\n+\t  after_wrap = simplify_gen_binary (PLUS, mode, mode_min, stride);\n+\t  after_wrap = simplify_gen_binary (MINUS, mode, after_wrap, const1_rtx);\n+\t}\n+      break;\n+\n+    case LE:\n+    case LT:\n+    case LEU:\n+    case LTU:\n+      if (INTVAL (stride) >= 0)\n+\tabort ();\n+      stride = simplify_gen_unary (NEG, mode, stride, mode);\n+      n_to_wrap = simplify_gen_binary (MINUS, mode, copy_rtx (init), mode_min);\n+      n_to_wrap = simplify_gen_binary (UDIV, mode, n_to_wrap, stride);\n+      before_wrap = simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t copy_rtx (n_to_wrap), stride);\n+      before_wrap = simplify_gen_binary (MINUS, mode,\n+\t\t\t\t\t copy_rtx (init), before_wrap);\n+      after_wrap = simplify_gen_binary (MINUS, mode,\n+\t\t\t\t\tbefore_wrap, stride);\n+      if (GET_CODE (after_wrap) != CONST_INT)\n+\t{\n+\t  after_wrap = simplify_gen_binary (MINUS, mode, mode_max, stride);\n+\t  after_wrap = simplify_gen_binary (PLUS, mode, after_wrap, const1_rtx);\n+\t}\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  /* If this is const_true_rtx and we did not take a conservative aproximation\n+     of after_wrap above, we might iterate the calculation (but of course we\n+     would have to take care about infinite cases).  Ignore this for now.  */\n+  rqmt = simplify_gen_relational (cond, SImode, mode, after_wrap, lim);\n+  if (rqmt != const0_rtx)\n+    return NULL_RTX;\n+\n+  return simplify_gen_binary (PLUS, mode, n_to_wrap, const1_rtx);\n+}\n+\n /* Return RTX expression representing number of iterations of loop as bounded\n    by test described by DESC (in the case loop really has multiple exit\n    edges, fewer iterations may happen in the practice).\n@@ -482,10 +601,11 @@ count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n   /* Compute absolute value of the difference of initial and final value.  */\n   if (INTVAL (stride) > 0)\n     {\n-      /* Bypass nonsensical tests.  */\n+      /* Handle strange tests specially.  */\n       if (cond == EQ || cond == GE || cond == GT || cond == GEU\n \t  || cond == GTU)\n-\treturn NULL;\n+\treturn count_strange_loop_iterations (init, lim, cond, desc->postincr,\n+\t\t\t\t\t      stride, GET_MODE (desc->var));\n       exp = simplify_gen_binary (MINUS, GET_MODE (desc->var),\n \t\t\t\t lim, init);\n     }\n@@ -494,7 +614,8 @@ count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n       /* Bypass nonsensical tests.  */\n       if (cond == EQ || cond == LE || cond == LT || cond == LEU\n \t  || cond == LTU)\n-\treturn NULL;\n+\treturn count_strange_loop_iterations (init, lim, cond, desc->postincr,\n+\t\t\t\t\t      stride, GET_MODE (desc->var));\n       exp = simplify_gen_binary (MINUS, GET_MODE (desc->var),\n \t\t\t\t init, lim);\n       stride = simplify_gen_unary (NEG, GET_MODE (desc->var),\n@@ -675,10 +796,10 @@ simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n   desc->lim_alts = variable_initial_values (e, desc->lim);\n \n   /* Number of iterations.  */\n-  if (!count_loop_iterations (desc, NULL, NULL))\n-    return false;\n   desc->const_iter =\n     constant_iterations (desc, &desc->niter, &desc->may_be_zero);\n+  if (!desc->const_iter && !count_loop_iterations (desc, NULL, NULL))\n+    return false;\n   return true;\n }\n "}]}