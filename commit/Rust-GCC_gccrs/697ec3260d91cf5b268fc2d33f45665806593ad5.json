{"sha": "697ec3260d91cf5b268fc2d33f45665806593ad5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk3ZWMzMjYwZDkxY2Y1YjI2OGZjMmQzM2Y0NTY2NTgwNjU5M2FkNQ==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2003-02-12T23:39:50Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-02-12T23:39:50Z"}, "message": "decl.c (java_init_decl_processing): Change soft_lookupjnimethod_node to reflect the change in signature of...\n\n2003-02-12  Ranjit Mathew  <rmathew@hotmail.com>\n\n\t* decl.c (java_init_decl_processing): Change\n\tsoft_lookupjnimethod_node to reflect the change in\n\tsignature of _Jv_LookupJNIMethod in libjava/jni.cc\n\t* expr.c (build_jni_stub): Calculate and pass the size\n\ton the stack of the arguments to a JNI function. Use\n\tnew target macro MODIFY_JNI_METHOD_CALL to allow a\n\ttarget to modify the call to a JNI method.\n\nFrom-SVN: r62795", "tree": {"sha": "d6c0a327ca1e0c7251a002f72b3c77ceb151d70e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6c0a327ca1e0c7251a002f72b3c77ceb151d70e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/697ec3260d91cf5b268fc2d33f45665806593ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/697ec3260d91cf5b268fc2d33f45665806593ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/697ec3260d91cf5b268fc2d33f45665806593ad5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/697ec3260d91cf5b268fc2d33f45665806593ad5/comments", "author": null, "committer": null, "parents": [{"sha": "2bbfc54272ae1622f1935f916f47eec7373bd943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bbfc54272ae1622f1935f916f47eec7373bd943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bbfc54272ae1622f1935f916f47eec7373bd943"}], "stats": {"total": 50, "additions": 40, "deletions": 10}, "files": [{"sha": "084a704aa621afa4bb46f60282716dbf386d0f7e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/697ec3260d91cf5b268fc2d33f45665806593ad5/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/697ec3260d91cf5b268fc2d33f45665806593ad5/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=697ec3260d91cf5b268fc2d33f45665806593ad5", "patch": "@@ -1,3 +1,13 @@\n+2003-02-12  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* decl.c (java_init_decl_processing): Change \n+\tsoft_lookupjnimethod_node to reflect the change in\n+\tsignature of _Jv_LookupJNIMethod in libjava/jni.cc\n+\t* expr.c (build_jni_stub): Calculate and pass the size\n+\ton the stack of the arguments to a JNI function. Use\n+\tnew target macro MODIFY_JNI_METHOD_CALL to allow a \n+\ttarget to modify the call to a JNI method.\n+\n 2003-02-08  Roger Sayle  <roger@eyesopen.com>\n \n \t* jcf-io.c (java_or_class_file): Use libiberty's lbasename"}, {"sha": "05f80ea03c58fa5b1f2e1ef127380e8b238f0513", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/697ec3260d91cf5b268fc2d33f45665806593ad5/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/697ec3260d91cf5b268fc2d33f45665806593ad5/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=697ec3260d91cf5b268fc2d33f45665806593ad5", "patch": "@@ -868,7 +868,9 @@ java_init_decl_processing (void)\n \n   t = tree_cons (NULL_TREE, object_ptr_type_node,\n \t\t tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t    tree_cons (NULL_TREE, ptr_type_node, endlink)));\n+\t\t\t    tree_cons (NULL_TREE, ptr_type_node, \n+\t\t\t               tree_cons (NULL_TREE, int_type_node, \n+\t\t\t\t                  endlink))));\n   soft_lookupjnimethod_node\n     = builtin_function (\"_Jv_LookupJNIMethod\",\n \t\t\tbuild_function_type (ptr_type_node, t),"}, {"sha": "48e67dfe2278dc1ab0f84ccb4ba39c4a8b7d26a7", "filename": "gcc/java/expr.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/697ec3260d91cf5b268fc2d33f45665806593ad5/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/697ec3260d91cf5b268fc2d33f45665806593ad5/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=697ec3260d91cf5b268fc2d33f45665806593ad5", "patch": "@@ -2087,6 +2087,8 @@ build_jni_stub (tree method)\n   tree method_args, res_type;\n   tree meth_var;\n \n+  int args_size = 0;\n+\n   tree klass = DECL_CONTEXT (method);\n   int from_class = ! CLASS_FROM_SOURCE_P (klass);\n   klass = build_class_ref (klass);\n@@ -2148,7 +2150,16 @@ build_jni_stub (tree method)\n      special way, we would do that here.  */\n   args = NULL_TREE;\n   for (tem = method_args; tem != NULL_TREE; tem = TREE_CHAIN (tem))\n-    args = tree_cons (NULL_TREE, tem, args);\n+    {\n+      int arg_bits = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (tem)));\n+#ifdef PARM_BOUNDARY\n+      arg_bits = (((arg_bits + PARM_BOUNDARY - 1) / PARM_BOUNDARY)\n+                  * PARM_BOUNDARY);\n+#endif\n+      args_size += (arg_bits / BITS_PER_UNIT);\n+\n+      args = tree_cons (NULL_TREE, tem, args);\n+    }\n   args = nreverse (args);\n   arg_types = TYPE_ARG_TYPES (TREE_TYPE (method));\n \n@@ -2157,31 +2168,38 @@ build_jni_stub (tree method)\n      available in the argument list.  */\n   if (METHOD_STATIC (method))\n     {\n+      args_size += int_size_in_bytes (TREE_TYPE (klass));\n       args = tree_cons (NULL_TREE, klass, args);\n       arg_types = tree_cons (NULL_TREE, object_ptr_type_node, arg_types);\n     }\n \n   /* The JNIEnv structure is the first argument to the JNI function.  */\n+  args_size += int_size_in_bytes (TREE_TYPE (env_var));\n   args = tree_cons (NULL_TREE, env_var, args);\n   arg_types = tree_cons (NULL_TREE, ptr_type_node, arg_types);\n \n   /* We call _Jv_LookupJNIMethod to find the actual underlying\n      function pointer.  _Jv_LookupJNIMethod will throw the appropriate\n      exception if this function is not found at runtime.  */\n+  tem = build_tree_list (NULL_TREE, build_int_2 (args_size, 0));\n   method_sig = build_java_signature (TREE_TYPE (method));\n-  lookup_arg =\n-    build_tree_list (NULL_TREE,\n-\t\t     build_utf8_ref (unmangle_classname\n-\t\t\t\t     (IDENTIFIER_POINTER (method_sig),\n-\t\t\t\t      IDENTIFIER_LENGTH (method_sig))));\n+  lookup_arg = tree_cons (NULL_TREE,\n+                          build_utf8_ref (unmangle_classname\n+                                          (IDENTIFIER_POINTER (method_sig),\n+                                           IDENTIFIER_LENGTH (method_sig))), \n+                          tem);\n   tem = DECL_NAME (method);\n   lookup_arg\n     = tree_cons (NULL_TREE, klass,\n \t\t tree_cons (NULL_TREE, build_utf8_ref (tem), lookup_arg));\n+  \n+  tem = build_function_type (TREE_TYPE (TREE_TYPE (method)), arg_types);\n+\n+#ifdef MODIFY_JNI_METHOD_CALL\n+  tem = MODIFY_JNI_METHOD_CALL (tem);\n+#endif\n \n-  jni_func_type\n-    = build_pointer_type (build_function_type (TREE_TYPE (TREE_TYPE (method)),\n-\t\t\t\t\t       arg_types));\n+  jni_func_type = build_pointer_type (tem);\n \n   jnifunc = build (COND_EXPR, ptr_type_node,\n \t\t   meth_var, meth_var,"}]}