{"sha": "21213b4c933bcd5b84e5682ae15a1239add65685", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEyMTNiNGM5MzNiY2Q1Yjg0ZTU2ODJhZTE1YTEyMzlhZGQ2NTY4NQ==", "commit": {"author": {"name": "Devang Patel", "email": "dpatel@apple.com", "date": "2004-10-07T16:05:35Z"}, "committer": {"name": "Devang Patel", "email": "dpatel@gcc.gnu.org", "date": "2004-10-07T16:05:35Z"}, "message": "altivec.md (UNSPEC_VCMPBFP, [...]): New constant defines.\n\n        * rs6000/altivec.md (UNSPEC_VCMPBFP, UNSPEC_VCMPEQUB, UNSPEC_VCMPEQUH,\n        UNSPEC_VCMPEQUW, UNSPEC_VCMPGEFP, UNSPEC_VCMPGTUB, UNSPEC_VCMPGTSB,\n        UNSPEC_VCMPGTUH, UNSPEC_VCMPGTSH, UNSPEC_VCMPGTUW, UNSPEC_VCMPGTSW,\n        UNSPEC_VCMPGTFP, UNSPEC_VSEL4SI, UNSPEC_VSEL4SF, UNSPEC_VSEL8HI,\n        UNSPEC_VSEL16QI, UNSPEC_VCOND_V4SI, UNSPEC_VCOND_V4SF, UNSPEC_VCOND_V8HI,\n        UNSPEC_VCOND_V16QI, UNSPEC_VCONDU_V4SI, UNSPEC_VCONDU_V8HI,\n        UNSPEC_VCONDU_V16QI): New constant defines.\n        (vcondv4si, vcondv4sf, vcondv8hi, vcondv16qi, vconduv4si, vconduv8hi,\n        vconduv16qi): New patterns.\n        * rs6000/rs6000-protos.h (rs6000_emit_vector_cond_expr): New function.\n        * rs6000/rs6000.c (rs6000_emit_vector_cond_expr): New function.\n        (get_vec_cmp_insn): Same.\n        (get_vsel_insn): Same.\n        (rs6000_emit_vector_compare): Same.\n        (rs6000_emit_vector_select): Same.\n        (INSN_NOT_AVAILABLE): New.\n\nFrom-SVN: r88692", "tree": {"sha": "fbcbbf74c82a7820a2ee716e9732f688c72bcbc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbcbbf74c82a7820a2ee716e9732f688c72bcbc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21213b4c933bcd5b84e5682ae15a1239add65685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21213b4c933bcd5b84e5682ae15a1239add65685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21213b4c933bcd5b84e5682ae15a1239add65685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21213b4c933bcd5b84e5682ae15a1239add65685/comments", "author": null, "committer": null, "parents": [{"sha": "03d3f46d574bf224c2a72c1ab81173d048f72634", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d3f46d574bf224c2a72c1ab81173d048f72634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d3f46d574bf224c2a72c1ab81173d048f72634"}], "stats": {"total": 502, "additions": 485, "deletions": 17}, "files": [{"sha": "369a058530358b723d5ef7e67977fc58ff48f209", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21213b4c933bcd5b84e5682ae15a1239add65685/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21213b4c933bcd5b84e5682ae15a1239add65685/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21213b4c933bcd5b84e5682ae15a1239add65685", "patch": "@@ -1,3 +1,22 @@\n+2004-10-07  Devang Patel  <dpatel@apple.com>\n+\n+        * rs6000/altivec.md (UNSPEC_VCMPBFP, UNSPEC_VCMPEQUB, UNSPEC_VCMPEQUH,\n+        UNSPEC_VCMPEQUW, UNSPEC_VCMPGEFP, UNSPEC_VCMPGTUB, UNSPEC_VCMPGTSB,\n+        UNSPEC_VCMPGTUH, UNSPEC_VCMPGTSH, UNSPEC_VCMPGTUW, UNSPEC_VCMPGTSW,\n+        UNSPEC_VCMPGTFP, UNSPEC_VSEL4SI, UNSPEC_VSEL4SF, UNSPEC_VSEL8HI,\n+        UNSPEC_VSEL16QI, UNSPEC_VCOND_V4SI, UNSPEC_VCOND_V4SF, UNSPEC_VCOND_V8HI,\n+        UNSPEC_VCOND_V16QI, UNSPEC_VCONDU_V4SI, UNSPEC_VCONDU_V8HI, \n+\tUNSPEC_VCONDU_V16QI): New constant defines.\n+        (vcondv4si, vcondv4sf, vcondv8hi, vcondv16qi, vconduv4si, vconduv8hi,\n+\tvconduv16qi): New patterns.\n+        * rs6000/rs6000-protos.h (rs6000_emit_vector_cond_expr): New function.\n+        * rs6000/rs6000.c (rs6000_emit_vector_cond_expr): New function.\n+        (get_vec_cmp_insn): Same.\n+        (get_vsel_insn): Same.\n+        (rs6000_emit_vector_compare): Same.\n+        (rs6000_emit_vector_select): Same.\n+\t(INSN_NOT_AVAILABLE): New.\n+\t\n 2004-10-07  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/17749"}, {"sha": "17866a9131e224f665095ae5c9a630dfa59fc2fb", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 192, "deletions": 17, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21213b4c933bcd5b84e5682ae15a1239add65685/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21213b4c933bcd5b84e5682ae15a1239add65685/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=21213b4c933bcd5b84e5682ae15a1239add65685", "patch": "@@ -23,6 +23,30 @@\n   [(UNSPEC_VSPLTISW\t141)\n    (UNSPEC_VSPLTISH\t140)\n    (UNSPEC_VSPLTISB\t139)\n+   (UNSPEC_VCMPBFP       50)\n+   (UNSPEC_VCMPEQUB      51)\n+   (UNSPEC_VCMPEQUH      52)\n+   (UNSPEC_VCMPEQUW      53)\n+   (UNSPEC_VCMPEQFP      54)\n+   (UNSPEC_VCMPGEFP      55)\n+   (UNSPEC_VCMPGTUB      56)\n+   (UNSPEC_VCMPGTSB      57)\n+   (UNSPEC_VCMPGTUH      58)\n+   (UNSPEC_VCMPGTSH      59)\n+   (UNSPEC_VCMPGTUW      60)\n+   (UNSPEC_VCMPGTSW      61)\n+   (UNSPEC_VCMPGTFP      62)\n+   (UNSPEC_VSEL4SI      159)\n+   (UNSPEC_VSEL4SF      160)\n+   (UNSPEC_VSEL8HI      161)\n+   (UNSPEC_VSEL16QI     162)\n+   (UNSPEC_VCOND_V4SI   301)\n+   (UNSPEC_VCOND_V4SF   302)\n+   (UNSPEC_VCOND_V8HI   303)\n+   (UNSPEC_VCOND_V16QI  304)\n+   (UNSPEC_VCONDU_V4SI  305)\n+   (UNSPEC_VCONDU_V8HI  306)\n+   (UNSPEC_VCONDU_V16QI 307)\n    ])\n \n ;; Generic LVX load instruction.\n@@ -496,103 +520,116 @@\n (define_insn \"altivec_vcmpbfp\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SF 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SF 2 \"register_operand\" \"v\")] 50))]\n+                      (match_operand:V4SF 2 \"register_operand\" \"v\")] \n+                      UNSPEC_VCMPBFP))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpbfp %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n (define_insn \"altivec_vcmpequb\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n         (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n-                       (match_operand:V16QI 2 \"register_operand\" \"v\")] 51))]\n+                       (match_operand:V16QI 2 \"register_operand\" \"v\")] \n+                       UNSPEC_VCMPEQUB))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpequb %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpequh\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n-                      (match_operand:V8HI 2 \"register_operand\" \"v\")] 52))]\n+                      (match_operand:V8HI 2 \"register_operand\" \"v\")] \n+                      UNSPEC_VCMPEQUH))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpequh %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpequw\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SI 2 \"register_operand\" \"v\")] 53))]\n+                      (match_operand:V4SI 2 \"register_operand\" \"v\")] \n+\t              UNSPEC_VCMPEQUW))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpequw %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpeqfp\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SF 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SF 2 \"register_operand\" \"v\")] 54))]\n+                      (match_operand:V4SF 2 \"register_operand\" \"v\")] \n+\t              UNSPEC_VCMPEQFP))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpeqfp %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n (define_insn \"altivec_vcmpgefp\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SF 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SF 2 \"register_operand\" \"v\")] 55))]\n+                      (match_operand:V4SF 2 \"register_operand\" \"v\")] \n+\t               UNSPEC_VCMPGEFP))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpgefp %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n (define_insn \"altivec_vcmpgtub\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n         (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n-                       (match_operand:V16QI 2 \"register_operand\" \"v\")] 56))]\n+                       (match_operand:V16QI 2 \"register_operand\" \"v\")] \n+                       UNSPEC_VCMPGTUB))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpgtub %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpgtsb\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n         (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n-                       (match_operand:V16QI 2 \"register_operand\" \"v\")] 57))]\n+                       (match_operand:V16QI 2 \"register_operand\" \"v\")] \n+                       UNSPEC_VCMPGTSB))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpgtsb %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpgtuh\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n-                      (match_operand:V8HI 2 \"register_operand\" \"v\")] 58))]\n+                      (match_operand:V8HI 2 \"register_operand\" \"v\")] \n+                      UNSPEC_VCMPGTUH))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpgtuh %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpgtsh\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n-                      (match_operand:V8HI 2 \"register_operand\" \"v\")] 59))]\n+                      (match_operand:V8HI 2 \"register_operand\" \"v\")] \n+                      UNSPEC_VCMPGTSH))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpgtsh %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpgtuw\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SI 2 \"register_operand\" \"v\")] 60))]\n+                      (match_operand:V4SI 2 \"register_operand\" \"v\")] \n+\t              UNSPEC_VCMPGTUW))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpgtuw %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpgtsw\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SI 2 \"register_operand\" \"v\")] 61))]\n+                      (match_operand:V4SI 2 \"register_operand\" \"v\")] \n+\t              UNSPEC_VCMPGTSW))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpgtsw %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"altivec_vcmpgtfp\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SF 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SF 2 \"register_operand\" \"v\")] 62))]\n+                      (match_operand:V4SF 2 \"register_operand\" \"v\")] \n+\t              UNSPEC_VCMPGTFP))]\n   \"TARGET_ALTIVEC\"\n   \"vcmpgtfp %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n@@ -1640,11 +1677,146 @@\n   \"vrefp %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")])\n \n+(define_expand \"vcondv4si\"\n+\t[(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+\t      (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t       (match_operand:V4SI 2 \"register_operand\" \"v\")\n+\t       (match_operand:V4SI 3 \"comparison_operator\" \"\")\n+\t       (match_operand:V4SI 4 \"register_operand\" \"v\")\n+\t       (match_operand:V4SI 5 \"register_operand\" \"v\")\n+\t       ] UNSPEC_VCOND_V4SI))]\n+\t\"TARGET_ALTIVEC\"\n+\t\"\n+{\n+\tif (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3], operands[4], operands[5]))\n+\tDONE;\n+\telse\n+\tFAIL;\n+}\n+\t\")\n+\n+(define_expand \"vconduv4si\"\n+\t[(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+\t      (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t       (match_operand:V4SI 2 \"register_operand\" \"v\")\n+\t       (match_operand:V4SI 3 \"comparison_operator\" \"\")\n+\t       (match_operand:V4SI 4 \"register_operand\" \"v\")\n+\t       (match_operand:V4SI 5 \"register_operand\" \"v\")\n+\t       ] UNSPEC_VCONDU_V4SI))]\n+\t\"TARGET_ALTIVEC\"\n+\t\"\n+{\n+\tif (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3], operands[4], operands[5]))\n+\tDONE;\n+\telse\n+\tFAIL;\n+}\n+\t\")\n+\n+(define_expand \"vcondv4sf\"\n+\t[(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t      (unspec:V4SF [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t       (match_operand:V4SF 2 \"register_operand\" \"v\")\n+\t       (match_operand:V4SF 3 \"comparison_operator\" \"\")\n+\t       (match_operand:V4SF 4 \"register_operand\" \"v\")\n+\t       (match_operand:V4SF 5 \"register_operand\" \"v\")\n+\t       ] UNSPEC_VCOND_V4SF))]\n+\t\"TARGET_ALTIVEC\"\n+\t\"\n+{\n+\tif (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3], operands[4], operands[5]))\n+\tDONE;\n+\telse\n+\tFAIL;\n+}\n+\t\")\n+\n+(define_expand \"vcondv8hi\"\n+\t[(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t      (unspec:V8HI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t       (match_operand:V8HI 2 \"register_operand\" \"v\")\n+\t       (match_operand:V8HI 3 \"comparison_operator\" \"\")\n+\t       (match_operand:V8HI 4 \"register_operand\" \"v\")\n+\t       (match_operand:V8HI 5 \"register_operand\" \"v\")\n+\t       ] UNSPEC_VCOND_V8HI))]\n+\t\"TARGET_ALTIVEC\"\n+\t\"\n+{\n+\tif (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3], operands[4], operands[5]))\n+\tDONE;\n+\telse\n+\tFAIL;\n+}\n+\t\")\n+\n+(define_expand \"vconduv8hi\"\n+\t[(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t      (unspec:V8HI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t       (match_operand:V8HI 2 \"register_operand\" \"v\")\n+\t       (match_operand:V8HI 3 \"comparison_operator\" \"\")\n+\t       (match_operand:V8HI 4 \"register_operand\" \"v\")\n+\t       (match_operand:V8HI 5 \"register_operand\" \"v\")\n+\t       ] UNSPEC_VCONDU_V8HI))]\n+\t\"TARGET_ALTIVEC\"\n+\t\"\n+{\n+\tif (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3], operands[4], operands[5]))\n+\tDONE;\n+\telse\n+\tFAIL;\n+}\n+\t\")\n+\n+(define_expand \"vcondv16qi\"\n+\t[(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t      (unspec:V16QI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t       (match_operand:V16QI 2 \"register_operand\" \"v\")\n+\t       (match_operand:V16QI 3 \"comparison_operator\" \"\")\n+\t       (match_operand:V16QI 4 \"register_operand\" \"v\")\n+\t       (match_operand:V16QI 5 \"register_operand\" \"v\")\n+\t       ] UNSPEC_VCOND_V16QI))]\n+\t\"TARGET_ALTIVEC\"\n+\t\"\n+{\n+\tif (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3], operands[4], operands[5]))\n+\tDONE;\n+\telse\n+\tFAIL;\n+}\n+\t\")\n+\n+(define_expand \"vconduv16qi\"\n+\t[(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t      (unspec:V16QI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t       (match_operand:V16QI 2 \"register_operand\" \"v\")\n+\t       (match_operand:V16QI 3 \"comparison_operator\" \"\")\n+\t       (match_operand:V16QI 4 \"register_operand\" \"v\")\n+\t       (match_operand:V16QI 5 \"register_operand\" \"v\")\n+\t       ] UNSPEC_VCONDU_V16QI))]\n+\t\"TARGET_ALTIVEC\"\n+\t\"\n+{\n+\tif (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3], operands[4], operands[5]))\n+\tDONE;\n+\telse\n+\tFAIL;\n+}\n+\t\")\n+\n+\n (define_insn \"altivec_vsel_4si\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n                       (match_operand:V4SI 2 \"register_operand\" \"v\")\n-                      (match_operand:V4SI 3 \"register_operand\" \"v\")] 159))]\n+                      (match_operand:V4SI 3 \"register_operand\" \"v\")] \n+\t              UNSPEC_VSEL4SI))]\n   \"TARGET_ALTIVEC\"\n   \"vsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecperm\")])\n@@ -1653,7 +1825,8 @@\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n         (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")\n                       (match_operand:V4SF 2 \"register_operand\" \"v\")\n-                      (match_operand:V4SI 3 \"register_operand\" \"v\")] 160))]\n+                      (match_operand:V4SI 3 \"register_operand\" \"v\")] \n+\t              UNSPEC_VSEL4SF))]\n   \"TARGET_ALTIVEC\"\n   \"vsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecperm\")])\n@@ -1662,7 +1835,8 @@\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n                       (match_operand:V8HI 2 \"register_operand\" \"v\")\n-                      (match_operand:V8HI 3 \"register_operand\" \"v\")] 161))]\n+                      (match_operand:V8HI 3 \"register_operand\" \"v\")] \n+\t              UNSPEC_VSEL8HI))]\n   \"TARGET_ALTIVEC\"\n   \"vsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecperm\")])\n@@ -1671,7 +1845,8 @@\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n         (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n                        (match_operand:V16QI 2 \"register_operand\" \"v\")\n-                       (match_operand:V16QI 3 \"register_operand\" \"v\")] 162))]\n+                       (match_operand:V16QI 3 \"register_operand\" \"v\")] \n+\t               UNSPEC_VSEL16QI))]\n   \"TARGET_ALTIVEC\"\n   \"vsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecperm\")])"}, {"sha": "d3a3122ed5c2bb17c0bff780ae82ef9b3e8fec4e", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21213b4c933bcd5b84e5682ae15a1239add65685/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21213b4c933bcd5b84e5682ae15a1239add65685/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=21213b4c933bcd5b84e5682ae15a1239add65685", "patch": "@@ -124,6 +124,7 @@ extern char * output_cbranch (rtx, const char *, int, rtx);\n extern char * output_e500_flip_eq_bit (rtx, rtx);\n extern rtx rs6000_emit_set_const (rtx, enum machine_mode, rtx, int);\n extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n+extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);\n extern void output_toc (FILE *, rtx, int, enum machine_mode);\n extern void rs6000_initialize_trampoline (rtx, rtx, rtx);"}, {"sha": "570357779fa0952a261567a4cdb383c548603498", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21213b4c933bcd5b84e5682ae15a1239add65685/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21213b4c933bcd5b84e5682ae15a1239add65685/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=21213b4c933bcd5b84e5682ae15a1239add65685", "patch": "@@ -760,7 +760,15 @@ static tree rs6000_build_builtin_va_list (void);\n static tree rs6000_gimplify_va_arg (tree, tree, tree *, tree *);\n static bool rs6000_must_pass_in_stack (enum machine_mode, tree);\n static bool rs6000_vector_mode_supported_p (enum machine_mode);\n+static int get_vec_cmp_insn (enum rtx_code, enum machine_mode, \n+\t\t\t     enum machine_mode);\n+static rtx rs6000_emit_vector_compare (enum rtx_code, rtx, rtx, \n+\t\t\t\t       enum machine_mode);\n+static int get_vsel_insn (enum machine_mode);\n+static void rs6000_emit_vector_select (rtx, rtx, rtx, rtx);\n \n+\n+const int INSN_NOT_AVAILABLE = -1;\n static enum machine_mode rs6000_eh_return_filter_mode (void);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n@@ -11202,6 +11210,271 @@ output_e500_flip_eq_bit (rtx dst, rtx src)\n   return string;\n }\n \n+/* Return insn index for the vector compare instruction for given CODE,\n+   and DEST_MODE, OP_MODE. Return INSN_NOT_AVAILABLE if valid insn is\n+   not available.  */\n+\n+static int\n+get_vec_cmp_insn (enum rtx_code code, \n+\t\t  enum machine_mode dest_mode,\n+\t\t  enum machine_mode op_mode)\n+{\n+  if (!TARGET_ALTIVEC)\n+    return INSN_NOT_AVAILABLE;\n+\n+  switch (code)\n+    {\n+    case EQ:\n+      if (dest_mode == V16QImode && op_mode == V16QImode)\n+\treturn UNSPEC_VCMPEQUB;\n+      if (dest_mode == V8HImode && op_mode == V8HImode)\n+\treturn UNSPEC_VCMPEQUH;\n+      if (dest_mode == V4SImode && op_mode == V4SImode)\n+\treturn UNSPEC_VCMPEQUW;\n+      if (dest_mode == V4SImode && op_mode == V4SFmode)\n+\treturn UNSPEC_VCMPEQFP;\n+      break;\n+    case GE:\n+      if (dest_mode == V4SImode && op_mode == V4SFmode)\n+\treturn UNSPEC_VCMPGEFP;\n+    case GT:\n+      if (dest_mode == V16QImode && op_mode == V16QImode)\n+\treturn UNSPEC_VCMPGTSB;\n+      if (dest_mode == V8HImode && op_mode == V8HImode)\n+\treturn UNSPEC_VCMPGTSH;\n+      if (dest_mode == V4SImode && op_mode == V4SImode)\n+\treturn UNSPEC_VCMPGTSW;\n+      if (dest_mode == V4SImode && op_mode == V4SFmode)\n+\treturn UNSPEC_VCMPGTFP;\n+      break;\n+    case GTU:\n+      if (dest_mode == V16QImode && op_mode == V16QImode)\n+\treturn UNSPEC_VCMPGTUB;\n+      if (dest_mode == V8HImode && op_mode == V8HImode)\n+\treturn UNSPEC_VCMPGTUH;\n+      if (dest_mode == V4SImode && op_mode == V4SImode)\n+\treturn UNSPEC_VCMPGTUW;\n+      break;\n+    default:\n+      break;\n+    }\n+  return INSN_NOT_AVAILABLE;\n+}\n+\n+/* Emit vector compare for operands OP0 and OP1 using code RCODE.\n+   DMODE is expected destination mode. This is a recursive function.  */\n+\n+static rtx\n+rs6000_emit_vector_compare (enum rtx_code rcode,\n+\t\t\t    rtx op0, rtx op1,\n+\t\t\t    enum machine_mode dmode)\n+{\n+  int vec_cmp_insn;\n+  rtx mask;\n+  enum machine_mode dest_mode;\n+  enum machine_mode op_mode = GET_MODE (op1);\n+\n+#ifdef ENABLE_CHECKING\n+  if (!TARGET_ALTIVEC)\n+    abort ();\n+\n+  if (GET_MODE (op0) != GET_MODE (op1))\n+    abort ();\n+#endif\n+\n+  /* Floating point vector compare instructions uses destination V4SImode.\n+     Move destination to appropriate mode later.  */\n+  if (dmode == V4SFmode)\n+    dest_mode = V4SImode;\n+  else\n+    dest_mode = dmode;\n+\n+  mask = gen_reg_rtx (dest_mode);\n+  vec_cmp_insn = get_vec_cmp_insn (rcode, dest_mode, op_mode);\n+\n+  if (vec_cmp_insn == INSN_NOT_AVAILABLE)\n+    {\n+      bool swap_operands = false;\n+      bool try_again = false;\n+      switch (rcode)\n+\t{\n+\tcase LT:\n+\t  rcode = GT;\n+\t  swap_operands = true;\n+\t  try_again = true;\n+\t  break;\n+\tcase LTU:\n+\t  rcode = GTU;\n+\t  swap_operands = true;\n+\t  try_again = true;\n+\t  break;\n+\tcase NE:\n+\t  /* Treat A != B as ~(A==B).  */\n+\t  {\n+\t    enum insn_code nor_code;\n+\t    rtx eq_rtx = rs6000_emit_vector_compare (EQ, op0, op1,\n+\t\t\t\t\t\t     dest_mode);\n+\t    \n+\t    nor_code = one_cmpl_optab->handlers[(int)dest_mode].insn_code;\n+\t    if (nor_code == CODE_FOR_nothing)\n+\t      abort ();\n+\t    emit_insn (GEN_FCN (nor_code) (mask, eq_rtx));\n+\n+\t    if (dmode != dest_mode)\n+\t      {\n+\t\trtx temp = gen_reg_rtx (dest_mode);\n+\t\tconvert_move (temp, mask, 0);\n+\t\treturn temp;\n+\t      }\n+\t    return mask;\n+\t  }\n+\t  break;\n+\tcase GE:\n+\tcase GEU:\n+\tcase LE:\n+\tcase LEU:\n+\t  /* Try GT/GTU/LT/LTU OR EQ */\n+\t  {\n+\t    rtx c_rtx, eq_rtx;\n+\t    enum insn_code ior_code;\n+\t    enum rtx_code new_code;\n+\n+\t    if (rcode == GE)\n+\t      new_code = GT;\n+\t    else if (rcode == GEU)\n+\t      new_code = GTU;\n+\t    else if (rcode == LE)\n+\t      new_code = LT;\n+\t    else if (rcode == LEU)\n+\t      new_code = LTU;\n+\t    else\n+\t      abort ();\n+\n+\t    c_rtx = rs6000_emit_vector_compare (new_code,\n+\t\t\t\t\t\top0, op1, dest_mode);\n+\t    eq_rtx = rs6000_emit_vector_compare (EQ, op0, op1,\n+\t\t\t\t\t\t dest_mode);\n+\n+\t    ior_code = ior_optab->handlers[(int)dest_mode].insn_code;\n+\t    if (ior_code == CODE_FOR_nothing)\n+\t      abort ();\n+\t    emit_insn (GEN_FCN (ior_code) (mask, c_rtx, eq_rtx));\n+\t    if (dmode != dest_mode)\n+\t      {\n+\t\trtx temp = gen_reg_rtx (dest_mode);\n+\t\tconvert_move (temp, mask, 0);\n+\t\treturn temp;\n+\t      }\n+\t    return mask;\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      if (try_again)\n+\t{\n+\t  vec_cmp_insn = get_vec_cmp_insn (rcode, dest_mode, op_mode);\n+\t  if (vec_cmp_insn == INSN_NOT_AVAILABLE)\n+\t    /* You only get two chances.  */\n+\t    abort ();\n+\t}\n+\n+      if (swap_operands)\n+\t{\n+\t  rtx tmp;\n+\t  tmp = op0;\n+\t  op0 = op1;\n+\t  op1 = tmp;\n+\t}\n+    }\n+\n+  emit_insn (gen_rtx_fmt_ee (SET,\n+\t\t\t     VOIDmode,\n+\t\t\t     mask,\n+\t\t\t     gen_rtx_fmt_Ei (UNSPEC, dest_mode,\n+\t\t\t\t\t     gen_rtvec (2, op0, op1),\n+\t\t\t\t\t     vec_cmp_insn)));\n+  if (dmode != dest_mode)\n+    {\n+      rtx temp = gen_reg_rtx (dest_mode);\n+      convert_move (temp, mask, 0);\n+      return temp;\n+    }\n+  return mask;\n+}\n+\n+/* Return vector select instruction for MODE. Return INSN_NOT_AVAILABLE, if\n+   valid insn doesn exist for given mode.  */\n+\n+static int\n+get_vsel_insn (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case V4SImode:\n+      return UNSPEC_VSEL4SI;\n+      break;\n+    case V4SFmode:\n+      return UNSPEC_VSEL4SF;\n+      break;\n+    case V8HImode:\n+      return UNSPEC_VSEL8HI;\n+      break;\n+    case V16QImode:\n+      return UNSPEC_VSEL16QI;\n+      break;\n+    default:\n+      return INSN_NOT_AVAILABLE;\n+      break;\n+    }\n+  return INSN_NOT_AVAILABLE;\n+}\n+\n+/* Emit vector select insn where DEST is destination using\n+   operands OP1, OP2 and MASK.  */\n+\n+static void\n+rs6000_emit_vector_select (rtx dest, rtx op1, rtx op2, rtx mask)\n+{\n+  rtx t, temp;\n+  enum machine_mode dest_mode = GET_MODE (dest);\n+  int vsel_insn_index  = get_vsel_insn (GET_MODE (dest));\n+\n+  temp = gen_reg_rtx (dest_mode);\n+  \n+  t = gen_rtx_fmt_ee (SET, VOIDmode, temp,\n+\t\t      gen_rtx_fmt_Ei (UNSPEC, dest_mode,\n+\t\t\t\t      gen_rtvec (3, op1, op2, mask),\n+\t\t\t\t      vsel_insn_index));\n+  emit_insn (t);\n+  emit_move_insn (dest, temp);\n+  return;\n+}\n+\n+/* Emit vector conditional expression.  \n+   DEST is destination. OP1 and OP2 are two VEC_COND_EXPR operands.\n+   CC_OP0 and CC_OP1 are the two operands for the relation operation COND.  */\n+\n+int\n+rs6000_emit_vector_cond_expr (rtx dest, rtx op1, rtx op2,\n+\t\t\t      rtx cond, rtx cc_op0, rtx cc_op1)\n+{\n+  enum machine_mode dest_mode = GET_MODE (dest);\n+  enum rtx_code rcode = GET_CODE (cond);\n+  rtx mask;\n+\n+  if (!TARGET_ALTIVEC)\n+    return 0;\n+\n+  /* Get the vector mask for the given relational operations.  */\n+  mask = rs6000_emit_vector_compare (rcode, cc_op0, cc_op1, dest_mode);\n+\n+  rs6000_emit_vector_select (dest, op1, op2, mask);\n+\n+  return 1;\n+}\n+\n /* Emit a conditional move: move TRUE_COND to DEST if OP of the\n    operands of the last comparison is nonzero/true, FALSE_COND if it\n    is zero/false.  Return 0 if the hardware has no such operation.  */"}]}