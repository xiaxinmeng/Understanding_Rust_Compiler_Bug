{"sha": "643427d70f7a547a1db8a8492a6a124ff22c0d3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQzNDI3ZDcwZjdhNTQ3YTFkYjhhODQ5MmE2YTEyNGZmMjJjMGQzYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-11-20T08:59:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-11-20T08:59:30Z"}, "message": "re PR rtl-optimization/85925 (compilation of masking with 257 goes wrong in combine at -02)\n\n\tPR rtl-optimization/85925\n\t* rtl.h (word_register_operation_p): New predicate.\n\t* combine.c (record_dead_and_set_regs_1): Only apply specific handling\n\tfor WORD_REGISTER_OPERATIONS targets to word_register_operation_p RTX.\n\t* rtlanal.c (nonzero_bits1): Likewise.  Adjust couple of comments.\n\t(num_sign_bit_copies1): Likewise.\n\nFrom-SVN: r266302", "tree": {"sha": "e254592484859d6e99362a4041f1d06658035748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e254592484859d6e99362a4041f1d06658035748"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/643427d70f7a547a1db8a8492a6a124ff22c0d3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643427d70f7a547a1db8a8492a6a124ff22c0d3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/643427d70f7a547a1db8a8492a6a124ff22c0d3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643427d70f7a547a1db8a8492a6a124ff22c0d3a/comments", "author": null, "committer": null, "parents": [{"sha": "07b9f1de1ea532a66d8ac103f3a9827521d780f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b9f1de1ea532a66d8ac103f3a9827521d780f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b9f1de1ea532a66d8ac103f3a9827521d780f9"}], "stats": {"total": 88, "additions": 74, "deletions": 14}, "files": [{"sha": "affdfd6cdefbf41508efb4ee3dfe2354a50e783e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=643427d70f7a547a1db8a8492a6a124ff22c0d3a", "patch": "@@ -130,6 +130,15 @@\n \t* dwarf2out.c (dwarf2out_early_global_decl): For\n \tdecl_function_context recurse instead of calling dwarf2out_decl.\n \n+2018-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/85925\n+\t* rtl.h (word_register_operation_p): New predicate.\n+\t* combine.c (record_dead_and_set_regs_1): Only apply specific handling\n+\tfor WORD_REGISTER_OPERATIONS targets to word_register_operation_p RTX.\n+\t* rtlanal.c (nonzero_bits1): Likewise.  Adjust couple of comments.\n+\t(num_sign_bit_copies1): Likewise.\n+\n 2018-11-19  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/87229"}, {"sha": "ecc83f89bcef47deec236bebe16b2685aa0978ed", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=643427d70f7a547a1db8a8492a6a124ff22c0d3a", "patch": "@@ -13331,6 +13331,7 @@ record_dead_and_set_regs_1 (rtx dest, const_rtx setter, void *data)\n \t       && subreg_lowpart_p (SET_DEST (setter)))\n \trecord_value_for_reg (dest, record_dead_insn,\n \t\t\t      WORD_REGISTER_OPERATIONS\n+\t\t\t      && word_register_operation_p (SET_SRC (setter))\n \t\t\t      && paradoxical_subreg_p (SET_DEST (setter))\n \t\t\t      ? SET_SRC (setter)\n \t\t\t      : gen_lowpart (GET_MODE (dest),"}, {"sha": "4114cd029918cdf8600e96ba9a35af33f622f0f5", "filename": "gcc/rtl.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=643427d70f7a547a1db8a8492a6a124ff22c0d3a", "patch": "@@ -4374,6 +4374,25 @@ strip_offset_and_add (rtx x, poly_int64_pod *offset)\n   return x;\n }\n \n+/* Return true if X is an operation that always operates on the full\n+   registers for WORD_REGISTER_OPERATIONS architectures.  */\n+\n+inline bool\n+word_register_operation_p (const_rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case ROTATE:\n+    case ROTATERT:\n+    case SIGN_EXTRACT:\n+    case ZERO_EXTRACT:\n+      return false;\n+    \n+    default:\n+      return true;\n+    }\n+}\n+    \n /* gtype-desc.c.  */\n extern void gt_ggc_mx (rtx &);\n extern void gt_pch_nx (rtx &);"}, {"sha": "9220cbf33066ccdeceed9d29deb89927b7ce4fae", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=643427d70f7a547a1db8a8492a6a124ff22c0d3a", "patch": "@@ -4485,12 +4485,12 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n      might be nonzero in its own mode, taking into account the fact that, on\n      CISC machines, accessing an object in a wider mode generally causes the\n      high-order bits to become undefined, so they are not known to be zero.\n-     We extend this reasoning to RISC machines for rotate operations since the\n-     semantics of the operations in the larger mode is not well defined.  */\n+     We extend this reasoning to RISC machines for operations that might not\n+     operate on the full registers.  */\n   if (mode_width > xmode_width\n       && xmode_width <= BITS_PER_WORD\n       && xmode_width <= HOST_BITS_PER_WIDE_INT\n-      && (!WORD_REGISTER_OPERATIONS || code == ROTATE || code == ROTATERT))\n+      && !(WORD_REGISTER_OPERATIONS && word_register_operation_p (x)))\n     {\n       nonzero &= cached_nonzero_bits (x, xmode,\n \t\t\t\t      known_x, known_mode, known_ret);\n@@ -4758,13 +4758,16 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \t  nonzero &= cached_nonzero_bits (SUBREG_REG (x), mode,\n \t\t\t\t\t  known_x, known_mode, known_ret);\n \n-          /* On many CISC machines, accessing an object in a wider mode\n+          /* On a typical CISC machine, accessing an object in a wider mode\n \t     causes the high-order bits to become undefined.  So they are\n-\t     not known to be zero.  */\n+\t     not known to be zero.\n+\n+\t     On a typical RISC machine, we only have to worry about the way\n+\t     loads are extended.  Otherwise, if we get a reload for the inner\n+\t     part, it may be loaded from the stack, and then we may lose all\n+\t     the zero bits that existed before the store to the stack.  */\n \t  rtx_code extend_op;\n \t  if ((!WORD_REGISTER_OPERATIONS\n-\t       /* If this is a typical RISC machine, we only have to worry\n-\t\t  about the way loads are extended.  */\n \t       || ((extend_op = load_extend_op (inner_mode)) == SIGN_EXTEND\n \t\t   ? val_signbit_known_set_p (inner_mode, nonzero)\n \t\t   : extend_op != ZERO_EXTEND)\n@@ -5025,10 +5028,9 @@ num_sign_bit_copies1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n     {\n       /* If this machine does not do all register operations on the entire\n \t register and MODE is wider than the mode of X, we can say nothing\n-\t at all about the high-order bits.  We extend this reasoning to every\n-\t machine for rotate operations since the semantics of the operations\n-\t in the larger mode is not well defined.  */\n-      if (!WORD_REGISTER_OPERATIONS || code == ROTATE || code == ROTATERT)\n+\t at all about the high-order bits.  We extend this reasoning to RISC\n+\t machines for operations that might not operate on full registers.  */\n+      if (!(WORD_REGISTER_OPERATIONS && word_register_operation_p (x)))\n \treturn 1;\n \n       /* Likewise on machines that do, if the mode of the object is smaller\n@@ -5107,13 +5109,12 @@ num_sign_bit_copies1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \t  /* For paradoxical SUBREGs on machines where all register operations\n \t     affect the entire register, just look inside.  Note that we are\n \t     passing MODE to the recursive call, so the number of sign bit\n-\t     copies will remain relative to that mode, not the inner mode.  */\n+\t     copies will remain relative to that mode, not the inner mode.\n \n-\t  /* This works only if loads sign extend.  Otherwise, if we get a\n+\t     This works only if loads sign extend.  Otherwise, if we get a\n \t     reload for the inner part, it may be loaded from the stack, and\n \t     then we lose all sign bit copies that existed before the store\n \t     to the stack.  */\n-\n \t  if (WORD_REGISTER_OPERATIONS\n \t      && load_extend_op (inner_mode) == SIGN_EXTEND\n \t      && paradoxical_subreg_p (x)"}, {"sha": "e3780472a3d93301ad5d2993f307e62539e75ffa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=643427d70f7a547a1db8a8492a6a124ff22c0d3a", "patch": "@@ -1,3 +1,7 @@\n+2018-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/execute/20181120-1.c: New test.\n+\n 2018-11-20  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/88087"}, {"sha": "21e5f7a71fe3198ea6b13e5e8b440dabdde66049", "filename": "gcc/testsuite/gcc.c-torture/execute/20181120-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20181120-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643427d70f7a547a1db8a8492a6a124ff22c0d3a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20181120-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20181120-1.c?ref=643427d70f7a547a1db8a8492a6a124ff22c0d3a", "patch": "@@ -0,0 +1,26 @@\n+/* PR rtl-optimization/85925 */\n+/* Testcase by <sudi@gcc.gnu.org> */\n+\n+int a, c, d;\n+volatile int b;\n+int *e = &d;\n+\n+union U1 {\n+  unsigned f0;\n+  unsigned f1 : 15;\n+};\n+\n+int main (void)\n+{\n+  for (c = 0; c <= 1; c++) {\n+    union U1 f = {0x10101};\n+    if (c == 1)\n+      b;\n+    *e = f.f1;\n+  }\n+\n+  if (d != 0x101)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}]}