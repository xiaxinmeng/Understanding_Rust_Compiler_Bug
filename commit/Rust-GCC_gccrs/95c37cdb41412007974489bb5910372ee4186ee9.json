{"sha": "95c37cdb41412007974489bb5910372ee4186ee9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjMzdjZGI0MTQxMjAwNzk3NDQ4OWJiNTkxMDM3MmVlNDE4NmVlOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-09-01T05:29:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-09-01T05:29:03Z"}, "message": "re PR rtl-optimization/23478 (Miscompilation due to reloading of a var that is also used in EH pad)\n\n\tPR rtl-optimization/23478\n\t* local-alloc.c (struct qty): Add n_throwing_calls_crossed field.\n\t(alloc_qty): Initialize it.\n\t(update_equiv_regs): Clear REG_N_THROWING_CALLS_CROSSED.\n\t(combine_regs): Combine also n_throwing_calls_crossed fields.\n\t(find_free_reg): Don't attempt to caller-save pseudos crossing\n\tcalls that might throw.\n\t* global.c (struct allocno): Add throwing_calls_crossed field.\n\t(global_alloc): Revert 2005-08-22 change.  Initialize\n\tthrowing_calls_crossed.\n\t(find_reg): Don't attempt to caller-save pseudos crossing calls that\n\tmight throw.\n\nFrom-SVN: r103718", "tree": {"sha": "51f172c784c1a0fb89978ba5eedd01b262b307a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51f172c784c1a0fb89978ba5eedd01b262b307a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95c37cdb41412007974489bb5910372ee4186ee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c37cdb41412007974489bb5910372ee4186ee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c37cdb41412007974489bb5910372ee4186ee9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c37cdb41412007974489bb5910372ee4186ee9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1990cd79695bdc9214496c869fedf53a2194f555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1990cd79695bdc9214496c869fedf53a2194f555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1990cd79695bdc9214496c869fedf53a2194f555"}], "stats": {"total": 41, "additions": 36, "deletions": 5}, "files": [{"sha": "b30b116d4f104c8b212049c2e3c9493b8cce9e93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c37cdb41412007974489bb5910372ee4186ee9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c37cdb41412007974489bb5910372ee4186ee9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95c37cdb41412007974489bb5910372ee4186ee9", "patch": "@@ -1,3 +1,18 @@\n+2005-09-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/23478\n+\t* local-alloc.c (struct qty): Add n_throwing_calls_crossed field.\n+\t(alloc_qty): Initialize it.\n+\t(update_equiv_regs): Clear REG_N_THROWING_CALLS_CROSSED.\n+\t(combine_regs): Combine also n_throwing_calls_crossed fields.\n+\t(find_free_reg): Don't attempt to caller-save pseudos crossing\n+\tcalls that might throw.\n+\t* global.c (struct allocno): Add throwing_calls_crossed field.\n+\t(global_alloc): Revert 2005-08-22 change.  Initialize\n+\tthrowing_calls_crossed.\n+\t(find_reg): Don't attempt to caller-save pseudos crossing calls that\n+\tmight throw.\n+\n 2005-09-01  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/23649"}, {"sha": "d4e2b773559d592ec957ac16f18ae3f928f10d0c", "filename": "gcc/global.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c37cdb41412007974489bb5910372ee4186ee9/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c37cdb41412007974489bb5910372ee4186ee9/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=95c37cdb41412007974489bb5910372ee4186ee9", "patch": "@@ -97,6 +97,9 @@ struct allocno\n   /* Number of calls crossed by each allocno.  */\n   int calls_crossed;\n \n+  /* Number of calls that might throw crossed by each allocno.  */\n+  int throwing_calls_crossed;\n+\n   /* Number of refs to each allocno.  */\n   int n_refs;\n \n@@ -465,9 +468,7 @@ global_alloc (FILE *file)\n \t/* Don't allocate pseudos that cross calls,\n \t   if this function receives a nonlocal goto.  */\n \t&& (! current_function_has_nonlocal_label\n-\t    || REG_N_CALLS_CROSSED (i) == 0)\n-\t/* Don't allocate pseudos that cross calls that may throw.  */\n-\t&& REG_N_THROWING_CALLS_CROSSED (i) == 0)\n+\t    || REG_N_CALLS_CROSSED (i) == 0))\n       {\n \tif (reg_renumber[i] < 0\n \t    && reg_may_share[i] && reg_allocno[reg_may_share[i]] >= 0)\n@@ -488,6 +489,8 @@ global_alloc (FILE *file)\n \tallocno[num].reg = i;\n \tallocno[num].size = PSEUDO_REGNO_SIZE (i);\n \tallocno[num].calls_crossed += REG_N_CALLS_CROSSED (i);\n+\tallocno[num].throwing_calls_crossed\n+\t  += REG_N_THROWING_CALLS_CROSSED (i);\n \tallocno[num].n_refs += REG_N_REFS (i);\n \tallocno[num].freq += REG_FREQ (i);\n \tif (allocno[num].live_length < REG_LIVE_LENGTH (i))\n@@ -1207,9 +1210,11 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n     {\n       /* Did not find a register.  If it would be profitable to\n \t allocate a call-clobbered register and save and restore it\n-\t around calls, do that.  */\n+\t around calls, do that.  Don't do this if it crosses any calls\n+\t that might throw.  */\n       if (! accept_call_clobbered\n \t  && allocno[num].calls_crossed != 0\n+\t  && allocno[num].throwing_calls_crossed == 0\n \t  && CALLER_SAVE_PROFITABLE (allocno[num].n_refs,\n \t\t\t\t     allocno[num].calls_crossed))\n \t{"}, {"sha": "4ee4991d0cd5b8a6007ca6113c7beee91571466f", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c37cdb41412007974489bb5910372ee4186ee9/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c37cdb41412007974489bb5910372ee4186ee9/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=95c37cdb41412007974489bb5910372ee4186ee9", "patch": "@@ -123,6 +123,11 @@ struct qty\n \n   int n_calls_crossed;\n \n+  /* Number of times a reg tied to given qty lives across a CALL_INSN\n+     that might throw.  */\n+\n+  int n_throwing_calls_crossed;\n+\n   /* The register number of one pseudo register whose reg_qty value is Q.\n      This register should be the head of the chain\n      maintained in reg_next_in_qty.  */\n@@ -324,6 +329,7 @@ alloc_qty (int regno, enum machine_mode mode, int size, int birth)\n   qty[qtyno].mode = mode;\n   qty[qtyno].birth = birth;\n   qty[qtyno].n_calls_crossed = REG_N_CALLS_CROSSED (regno);\n+  qty[qtyno].n_throwing_calls_crossed = REG_N_THROWING_CALLS_CROSSED (regno);\n   qty[qtyno].min_class = reg_preferred_class (regno);\n   qty[qtyno].alternate_class = reg_alternate_class (regno);\n   qty[qtyno].n_refs = REG_N_REFS (regno);\n@@ -1170,6 +1176,7 @@ update_equiv_regs (void)\n \n \t\t      REG_BASIC_BLOCK (regno) = bb->index;\n \t\t      REG_N_CALLS_CROSSED (regno) = 0;\n+\t\t      REG_N_THROWING_CALLS_CROSSED (regno) = 0;\n \t\t      REG_LIVE_LENGTH (regno) = 2;\n \n \t\t      if (insn == BB_HEAD (bb))\n@@ -2011,6 +2018,8 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n \n       /* Update info about quantity SQTY.  */\n       qty[sqty].n_calls_crossed += REG_N_CALLS_CROSSED (sreg);\n+      qty[sqty].n_throwing_calls_crossed\n+\t+= REG_N_THROWING_CALLS_CROSSED (sreg);\n       qty[sqty].n_refs += REG_N_REFS (sreg);\n       qty[sqty].freq += REG_FREQ (sreg);\n       if (usize < ssize)\n@@ -2315,12 +2324,14 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n \n   /* We need not check to see if the current function has nonlocal\n      labels because we don't put any pseudos that are live over calls in\n-     registers in that case.  */\n+     registers in that case.  Avoid putting pseudos crossing calls that\n+     might throw into call used registers.  */\n \n   if (! accept_call_clobbered\n       && flag_caller_saves\n       && ! just_try_suggested\n       && qty[qtyno].n_calls_crossed != 0\n+      && qty[qtyno].n_throwing_calls_crossed == 0\n       && CALLER_SAVE_PROFITABLE (qty[qtyno].n_refs,\n \t\t\t\t qty[qtyno].n_calls_crossed))\n     {"}]}