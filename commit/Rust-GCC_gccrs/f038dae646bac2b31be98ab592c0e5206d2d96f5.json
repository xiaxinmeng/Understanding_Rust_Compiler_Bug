{"sha": "f038dae646bac2b31be98ab592c0e5206d2d96f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAzOGRhZTY0NmJhYzJiMzFiZTk4YWI1OTJjMGU1MjA2ZDJkOTZmNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-11-06T19:49:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-11-06T19:49:01Z"}, "message": "libgo: Update to October 24 version of master library.\n\nFrom-SVN: r204466", "tree": {"sha": "39530b071991b2326f881b2a30a2d82d6c133fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39530b071991b2326f881b2a30a2d82d6c133fd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f038dae646bac2b31be98ab592c0e5206d2d96f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f038dae646bac2b31be98ab592c0e5206d2d96f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f038dae646bac2b31be98ab592c0e5206d2d96f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f038dae646bac2b31be98ab592c0e5206d2d96f5/comments", "author": null, "committer": null, "parents": [{"sha": "f20f261304993444741e0f0a14d3147e591bc660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20f261304993444741e0f0a14d3147e591bc660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f20f261304993444741e0f0a14d3147e591bc660"}], "stats": {"total": 39403, "additions": 31983, "deletions": 7420}, "files": [{"sha": "28586372b0e5a064bf3124edc4a95083a8059fab", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -1,4 +1,4 @@\n-a7bd9a33067b\n+7ebbddd21330\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "9a8a1b45530e497adac8f5a12e2f53443c4edd67", "filename": "libgo/Makefile.am", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -37,7 +37,8 @@ AM_CPPFLAGS = -I $(srcdir)/runtime $(LIBFFIINCS) $(PTHREAD_CFLAGS)\n \n ACLOCAL_AMFLAGS = -I ./config -I ../config\n \n-AM_CFLAGS = -fexceptions -fplan9-extensions $(SPLIT_STACK) $(WARN_CFLAGS) \\\n+AM_CFLAGS = -fexceptions -fnon-call-exceptions -fplan9-extensions \\\n+\t$(SPLIT_STACK) $(WARN_CFLAGS) \\\n \t$(STRINGOPS_FLAG) $(OSCFLAGS) \\\n \t-I $(srcdir)/../libgcc -I $(srcdir)/../libbacktrace \\\n \t-I $(MULTIBUILDTOP)../../gcc/include\n@@ -103,6 +104,7 @@ toolexeclibgo_DATA = \\\n \tbufio.gox \\\n \tbytes.gox \\\n \tcrypto.gox \\\n+\tencoding.gox \\\n \terrors.gox \\\n \texpvar.gox \\\n \tflag.gox \\\n@@ -251,6 +253,11 @@ toolexeclibgoimage_DATA = \\\n \timage/jpeg.gox \\\n \timage/png.gox\n \n+toolexeclibgoimagecolordir = $(toolexeclibgoimagedir)/color\n+\n+toolexeclibgoimagecolor_DATA = \\\n+\timage/color/palette.gox\n+\n toolexeclibgoindexdir = $(toolexeclibgodir)/index\n \n toolexeclibgoindex_DATA = \\\n@@ -573,6 +580,9 @@ go_bytes_c_files = \\\n go_crypto_files = \\\n \tgo/crypto/crypto.go\n \n+go_encoding_files = \\\n+\tgo/encoding/encoding.go\n+\n go_errors_files = \\\n \tgo/errors/errors.go\n \n@@ -669,7 +679,7 @@ go_net_fd_os_file =\n go_net_newpollserver_file =\n else # !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n if LIBGO_IS_NETBSD\n-go_net_fd_os_file = go/net/fd_bsd.go\n+go_net_fd_os_file =\n go_net_newpollserver_file =\n else # !LIBGO_IS_NETBSD && !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n # By default use select with pipes.  Most systems should have\n@@ -726,33 +736,41 @@ else\n if LIBGO_IS_FREEBSD\n go_net_sendfile_file = go/net/sendfile_freebsd.go\n else\n+if LIBGO_IS_DRAGONFLY\n+go_net_sendfile_file = go/net/sendfile_dragonfly.go\n+else\n go_net_sendfile_file = go/net/sendfile_stub.go\n endif\n endif\n+endif\n \n if LIBGO_IS_LINUX\n go_net_interface_file = go/net/interface_linux.go\n else\n if LIBGO_IS_NETBSD\n go_net_interface_file = go/net/interface_netbsd.go\n else\n+if LIBGO_IS_DRAGONFLY\n+go_net_interface_file = go/net/interface_dragonfly.go\n+else\n go_net_interface_file = go/net/interface_stub.go\n endif\n endif\n+endif\n \n if LIBGO_IS_LINUX\n go_net_cloexec_file = go/net/sock_cloexec.go\n else\n go_net_cloexec_file = go/net/sys_cloexec.go\n endif\n \n-if LIBGO_IS_LINUX\n-go_net_poll_file = go/net/fd_poll_runtime.go\n+if LIBGO_IS_OPENBSD\n+go_net_tcpsockopt_file = go/net/tcpsockopt_openbsd.go\n else\n if LIBGO_IS_DARWIN\n-go_net_poll_file = go/net/fd_poll_runtime.go\n+go_net_tcpsockopt_file = go/net/tcpsockopt_darwin.go\n else\n-go_net_poll_file = go/net/fd_poll_unix.go\n+go_net_tcpsockopt_file =  go/net/tcpsockopt_unix.go\n endif\n endif\n \n@@ -766,6 +784,7 @@ go_net_files = \\\n \tgo/net/dnsconfig_unix.go \\\n \tgo/net/dnsmsg.go \\\n \t$(go_net_newpollserver_file) \\\n+\tgo/net/fd_mutex.go \\\n \tgo/net/fd_unix.go \\\n \t$(go_net_fd_os_file) \\\n \tgo/net/file_unix.go \\\n@@ -783,18 +802,21 @@ go_net_files = \\\n \tgo/net/net.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n-\t$(go_net_poll_file) \\\n+\tgo/net/fd_poll_runtime.go \\\n \tgo/net/port.go \\\n \tgo/net/port_unix.go \\\n+\tgo/net/race0.go \\\n \t$(go_net_sendfile_file) \\\n+\tgo/net/singleflight.go \\\n \tgo/net/sock_posix.go \\\n-\tgo/net/sock_unix.go \\\n \t$(go_net_sock_file) \\\n \tgo/net/sockopt_posix.go \\\n \t$(go_net_sockopt_file) \\\n \t$(go_net_sockoptip_file) \\\n \tgo/net/tcpsock.go \\\n \tgo/net/tcpsock_posix.go \\\n+\tgo/net/tcpsockopt_posix.go \\\n+\t$(go_net_tcpsockopt_file) \\\n \tgo/net/udpsock.go \\\n \tgo/net/udpsock_posix.go \\\n \tgo/net/unixsock.go \\\n@@ -818,6 +840,12 @@ go_os_dir_file = go/os/dir_regfile.go\n endif\n endif\n \n+if LIBGO_IS_DARWIN\n+go_os_getwd_file = go/os/getwd_darwin.go\n+else\n+go_os_getwd_file =\n+endif\n+\n if LIBGO_IS_LINUX\n go_os_sys_file = go/os/sys_linux.go\n else\n@@ -854,13 +882,17 @@ else\n if LIBGO_IS_NETBSD\n go_os_stat_file = go/os/stat_atimespec.go\n else\n+if LIBGO_IS_DRAGONFLY\n+go_os_stat_file = go/os/stat_dragonfly.go\n+else\n go_os_stat_file = go/os/stat.go\n endif\n endif\n endif\n endif\n endif\n endif\n+endif\n \n if LIBGO_IS_LINUX\n go_os_pipe_file = go/os/pipe_linux.go\n@@ -874,14 +906,15 @@ go_os_files = \\\n \tgo/os/doc.go \\\n \tgo/os/env.go \\\n \tgo/os/error.go \\\n-\tgo/os/error_posix.go \\\n+\tgo/os/error_unix.go \\\n \tgo/os/exec.go \\\n \tgo/os/exec_posix.go \\\n \tgo/os/exec_unix.go \\\n \tgo/os/file.go \\\n \tgo/os/file_posix.go \\\n \tgo/os/file_unix.go \\\n \tgo/os/getwd.go \\\n+\t$(go_os_getwd_file) \\\n \tgo/os/path.go \\\n \tgo/os/path_unix.go \\\n \t$(go_os_pipe_file) \\\n@@ -970,7 +1003,10 @@ go_strings_files = \\\n \tgo/strings/reader.go \\\n \tgo/strings/replace.go \\\n \tgo/strings/search.go \\\n-\tgo/strings/strings.go\n+\tgo/strings/strings.go \\\n+\tgo/strings/strings_decl.go\n+go_strings_c_files = \\\n+\tgo/strings/indexbyte.c\n \n go_sync_files = \\\n \tgo/sync/cond.go \\\n@@ -1000,6 +1036,7 @@ go_syslog_c_files = \\\n go_testing_files = \\\n \tgo/testing/allocs.go \\\n \tgo/testing/benchmark.go \\\n+\tgo/testing/cover.go \\\n \tgo/testing/example.go \\\n \tgo/testing/testing.go\n \n@@ -1048,6 +1085,7 @@ go_archive_tar_files = \\\n \n go_archive_zip_files = \\\n \tgo/archive/zip/reader.go \\\n+\tgo/archive/zip/register.go \\\n \tgo/archive/zip/struct.go \\\n \tgo/archive/zip/writer.go\n \n@@ -1098,6 +1136,7 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cfb.go \\\n \tgo/crypto/cipher/cipher.go \\\n \tgo/crypto/cipher/ctr.go \\\n+\tgo/crypto/cipher/gcm.go \\\n \tgo/crypto/cipher/io.go \\\n \tgo/crypto/cipher/ofb.go\n go_crypto_des_files = \\\n@@ -1110,7 +1149,8 @@ go_crypto_ecdsa_files = \\\n \tgo/crypto/ecdsa/ecdsa.go\n go_crypto_elliptic_files = \\\n \tgo/crypto/elliptic/elliptic.go \\\n-\tgo/crypto/elliptic/p224.go\n+\tgo/crypto/elliptic/p224.go \\\n+\tgo/crypto/elliptic/p256.go\n go_crypto_hmac_files = \\\n \tgo/crypto/hmac/hmac.go\n go_crypto_md5_files = \\\n@@ -1125,6 +1165,7 @@ go_crypto_rc4_files = \\\n \tgo/crypto/rc4/rc4_ref.go\n go_crypto_rsa_files = \\\n \tgo/crypto/rsa/pkcs1v15.go \\\n+\tgo/crypto/rsa/pss.go \\\n \tgo/crypto/rsa/rsa.go\n go_crypto_sha1_files = \\\n \tgo/crypto/sha1/sha1.go \\\n@@ -1308,11 +1349,15 @@ go_image_color_files = \\\n \tgo/image/color/color.go \\\n \tgo/image/color/ycbcr.go\n \n+go_image_color_palette_files = \\\n+\tgo/image/color/palette/palette.go\n+\n go_image_draw_files = \\\n \tgo/image/draw/draw.go\n \n go_image_gif_files = \\\n-\tgo/image/gif/reader.go\n+\tgo/image/gif/reader.go \\\n+\tgo/image/gif/writer.go\n \n go_image_jpeg_files = \\\n \tgo/image/jpeg/fdct.go \\\n@@ -1766,6 +1811,7 @@ libgo_go_objs = \\\n \tbytes.lo \\\n \tbytes/index.lo \\\n \tcrypto.lo \\\n+\tencoding.lo \\\n \terrors.lo \\\n \texpvar.lo \\\n \tflag.lo \\\n@@ -1787,6 +1833,7 @@ libgo_go_objs = \\\n \tsort.lo \\\n \tstrconv.lo \\\n \tstrings.lo \\\n+\tstrings/index.lo \\\n \tsync.lo \\\n \tsyscall.lo \\\n \tsyscall/errno.lo \\\n@@ -1863,6 +1910,7 @@ libgo_go_objs = \\\n \tnet/http/httputil.lo \\\n \tnet/http/pprof.lo \\\n \timage/color.lo \\\n+\timage/color/palette.lo \\\n \timage/draw.lo \\\n \timage/gif.lo \\\n \timage/jpeg.lo \\\n@@ -2033,6 +2081,15 @@ crypto/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/check\n \n+@go_include@ encoding.lo.dep\n+encoding.lo.dep: $(go_encoding_files)\n+\t$(BUILDDEPS)\n+encoding.lo: $(go_encoding_files)\n+\t$(BUILDPACKAGE)\n+encoding/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: encoding/check\n+\n @go_include@ errors.lo.dep\n errors.lo.dep: $(go_errors_files)\n \t$(BUILDDEPS)\n@@ -2214,6 +2271,9 @@ strings.lo.dep: $(go_strings_files)\n \t$(BUILDDEPS)\n strings.lo: $(go_strings_files)\n \t$(BUILDPACKAGE)\n+strings/index.lo: $(go_strings_c_files)\n+\t@$(MKDIR_P) strings\n+\t$(LTCOMPILE) -c -o strings/index.lo $(srcdir)/go/strings/indexbyte.c\n strings/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: strings/check\n@@ -2821,6 +2881,15 @@ image/color/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/color/check\n \n+@go_include@ image/color/palette.lo.dep\n+image/color/palette.lo.dep: $(go_image_color_palette_files)\n+\t$(BUILDDEPS)\n+image/color/palette.lo: $(go_image_color_palette_files)\n+\t$(BUILDPACKAGE)\n+image/color/palette/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: image/color/palette/check\n+\n @go_include@ image/draw.lo.dep\n image/draw.lo.dep: $(go_image_draw_files)\n \t$(BUILDDEPS)\n@@ -3236,6 +3305,8 @@ bytes.gox: bytes.lo\n \t$(BUILDGOX)\n crypto.gox: crypto.lo\n \t$(BUILDGOX)\n+encoding.gox: encoding.lo\n+\t$(BUILDGOX)\n errors.gox: errors.lo\n \t$(BUILDGOX)\n expvar.gox: expvar.lo\n@@ -3433,6 +3504,9 @@ image/jpeg.gox: image/jpeg.lo\n image/png.gox: image/png.lo\n \t$(BUILDGOX)\n \n+image/color/palette.gox: image/color/palette.lo\n+\t$(BUILDGOX)\n+\n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n "}, {"sha": "63e78b4e77aa99f9770b1986a70de7d49940c7b6", "filename": "libgo/Makefile.in", "status": "modified", "additions": 123, "deletions": 37, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -105,6 +105,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohashdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohtmldir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoimagedir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoimagecolordir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoindexdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoiodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgologdir)\" \\\n@@ -132,12 +133,12 @@ libgobegin_a_OBJECTS = $(am_libgobegin_a_OBJECTS)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n-\terrors.lo expvar.lo flag.lo fmt.lo hash.lo html.lo image.lo \\\n-\tio.lo log.lo math.lo mime.lo net.lo os.lo path.lo \\\n+\tencoding.lo errors.lo expvar.lo flag.lo fmt.lo hash.lo html.lo \\\n+\timage.lo io.lo log.lo math.lo mime.lo net.lo os.lo path.lo \\\n \treflect-go.lo reflect/makefunc.lo regexp.lo runtime-go.lo \\\n-\tsort.lo strconv.lo strings.lo sync.lo syscall.lo \\\n-\tsyscall/errno.lo syscall/signame.lo syscall/wait.lo testing.lo \\\n-\ttime-go.lo unicode.lo archive/tar.lo archive/zip.lo \\\n+\tsort.lo strconv.lo strings.lo strings/index.lo sync.lo \\\n+\tsyscall.lo syscall/errno.lo syscall/signame.lo syscall/wait.lo \\\n+\ttesting.lo time-go.lo unicode.lo archive/tar.lo archive/zip.lo \\\n \tcompress/bzip2.lo compress/flate.lo compress/gzip.lo \\\n \tcompress/lzw.lo compress/zlib.lo container/heap.lo \\\n \tcontainer/list.lo container/ring.lo crypto/aes.lo \\\n@@ -157,13 +158,13 @@ am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \thash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n \tnet/http/cookiejar.lo net/http/fcgi.lo net/http/httptest.lo \\\n \tnet/http/httputil.lo net/http/pprof.lo image/color.lo \\\n-\timage/draw.lo image/gif.lo image/jpeg.lo image/png.lo \\\n-\tindex/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n-\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n-\tmime/multipart.lo net/http.lo net/mail.lo net/rpc.lo \\\n-\tnet/smtp.lo net/textproto.lo net/url.lo old/regexp.lo \\\n-\told/template.lo os/exec.lo $(am__DEPENDENCIES_1) os/signal.lo \\\n-\tos/user.lo path/filepath.lo regexp/syntax.lo \\\n+\timage/color/palette.lo image/draw.lo image/gif.lo \\\n+\timage/jpeg.lo image/png.lo index/suffixarray.lo io/ioutil.lo \\\n+\tlog/syslog.lo log/syslog/syslog_c.lo math/big.lo math/cmplx.lo \\\n+\tmath/rand.lo mime/multipart.lo net/http.lo net/mail.lo \\\n+\tnet/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n+\told/regexp.lo old/template.lo os/exec.lo $(am__DEPENDENCIES_1) \\\n+\tos/signal.lo os/user.lo path/filepath.lo regexp/syntax.lo \\\n \tnet/rpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n \tsync/atomic.lo sync/atomic_c.lo text/scanner.lo \\\n \ttext/tabwriter.lo text/template.lo text/template/parse.lo \\\n@@ -260,16 +261,16 @@ DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgodebug_DATA) $(toolexeclibgoencoding_DATA) \\\n \t$(toolexeclibgoexp_DATA) $(toolexeclibgogo_DATA) \\\n \t$(toolexeclibgohash_DATA) $(toolexeclibgohtml_DATA) \\\n-\t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n-\t$(toolexeclibgoio_DATA) $(toolexeclibgolog_DATA) \\\n-\t$(toolexeclibgomath_DATA) $(toolexeclibgomime_DATA) \\\n-\t$(toolexeclibgonet_DATA) $(toolexeclibgonethttp_DATA) \\\n-\t$(toolexeclibgonetrpc_DATA) $(toolexeclibgoold_DATA) \\\n-\t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n-\t$(toolexeclibgoregexp_DATA) $(toolexeclibgoruntime_DATA) \\\n-\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA) \\\n-\t$(toolexeclibgotext_DATA) $(toolexeclibgotexttemplate_DATA) \\\n-\t$(toolexeclibgounicode_DATA)\n+\t$(toolexeclibgoimage_DATA) $(toolexeclibgoimagecolor_DATA) \\\n+\t$(toolexeclibgoindex_DATA) $(toolexeclibgoio_DATA) \\\n+\t$(toolexeclibgolog_DATA) $(toolexeclibgomath_DATA) \\\n+\t$(toolexeclibgomime_DATA) $(toolexeclibgonet_DATA) \\\n+\t$(toolexeclibgonethttp_DATA) $(toolexeclibgonetrpc_DATA) \\\n+\t$(toolexeclibgoold_DATA) $(toolexeclibgoos_DATA) \\\n+\t$(toolexeclibgopath_DATA) $(toolexeclibgoregexp_DATA) \\\n+\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n+\t$(toolexeclibgotesting_DATA) $(toolexeclibgotext_DATA) \\\n+\t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgounicode_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -443,7 +444,8 @@ WARN_CFLAGS = $(WARN_FLAGS) $(WERROR)\n # -I/-D flags to pass when compiling.\n AM_CPPFLAGS = -I $(srcdir)/runtime $(LIBFFIINCS) $(PTHREAD_CFLAGS)\n ACLOCAL_AMFLAGS = -I ./config -I ../config\n-AM_CFLAGS = -fexceptions -fplan9-extensions $(SPLIT_STACK) $(WARN_CFLAGS) \\\n+AM_CFLAGS = -fexceptions -fnon-call-exceptions -fplan9-extensions \\\n+\t$(SPLIT_STACK) $(WARN_CFLAGS) \\\n \t$(STRINGOPS_FLAG) $(OSCFLAGS) \\\n \t-I $(srcdir)/../libgcc -I $(srcdir)/../libbacktrace \\\n \t-I $(MULTIBUILDTOP)../../gcc/include\n@@ -506,6 +508,7 @@ toolexeclibgo_DATA = \\\n \tbufio.gox \\\n \tbytes.gox \\\n \tcrypto.gox \\\n+\tencoding.gox \\\n \terrors.gox \\\n \texpvar.gox \\\n \tflag.gox \\\n@@ -640,6 +643,10 @@ toolexeclibgoimage_DATA = \\\n \timage/jpeg.gox \\\n \timage/png.gox\n \n+toolexeclibgoimagecolordir = $(toolexeclibgoimagedir)/color\n+toolexeclibgoimagecolor_DATA = \\\n+\timage/color/palette.gox\n+\n toolexeclibgoindexdir = $(toolexeclibgodir)/index\n toolexeclibgoindex_DATA = \\\n \tindex/suffixarray.gox\n@@ -865,6 +872,9 @@ go_bytes_c_files = \\\n go_crypto_files = \\\n \tgo/crypto/crypto.go\n \n+go_encoding_files = \\\n+\tgo/encoding/encoding.go\n+\n go_errors_files = \\\n \tgo/errors/errors.go\n \n@@ -955,7 +965,7 @@ go_mime_files = \\\n # By default use select with pipes.  Most systems should have\n # something better.\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_select.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_bsd.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = \n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = \n @LIBGO_IS_RTEMS_TRUE@go_net_fd_os_file = go/net/fd_select.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = \n@@ -986,17 +996,19 @@ go_mime_files = \\\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n @LIBGO_IS_LINUX_TRUE@go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n-@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n+@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_dragonfly.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_freebsd.go\n @LIBGO_IS_LINUX_TRUE@go_net_sendfile_file = go/net/sendfile_linux.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_stub.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_stub.go\n+@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_dragonfly.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@go_net_interface_file = go/net/interface_netbsd.go\n @LIBGO_IS_LINUX_TRUE@go_net_interface_file = go/net/interface_linux.go\n @LIBGO_IS_LINUX_FALSE@go_net_cloexec_file = go/net/sys_cloexec.go\n @LIBGO_IS_LINUX_TRUE@go_net_cloexec_file = go/net/sock_cloexec.go\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_poll_file = go/net/fd_poll_unix.go\n-@LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_poll_file = go/net/fd_poll_runtime.go\n-@LIBGO_IS_LINUX_TRUE@go_net_poll_file = go/net/fd_poll_runtime.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_OPENBSD_FALSE@go_net_tcpsockopt_file = go/net/tcpsockopt_unix.go\n+@LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_OPENBSD_FALSE@go_net_tcpsockopt_file = go/net/tcpsockopt_darwin.go\n+@LIBGO_IS_OPENBSD_TRUE@go_net_tcpsockopt_file = go/net/tcpsockopt_openbsd.go\n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n \t$(go_net_cgo_file) \\\n@@ -1007,6 +1019,7 @@ go_net_files = \\\n \tgo/net/dnsconfig_unix.go \\\n \tgo/net/dnsmsg.go \\\n \t$(go_net_newpollserver_file) \\\n+\tgo/net/fd_mutex.go \\\n \tgo/net/fd_unix.go \\\n \t$(go_net_fd_os_file) \\\n \tgo/net/file_unix.go \\\n@@ -1024,18 +1037,21 @@ go_net_files = \\\n \tgo/net/net.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n-\t$(go_net_poll_file) \\\n+\tgo/net/fd_poll_runtime.go \\\n \tgo/net/port.go \\\n \tgo/net/port_unix.go \\\n+\tgo/net/race0.go \\\n \t$(go_net_sendfile_file) \\\n+\tgo/net/singleflight.go \\\n \tgo/net/sock_posix.go \\\n-\tgo/net/sock_unix.go \\\n \t$(go_net_sock_file) \\\n \tgo/net/sockopt_posix.go \\\n \t$(go_net_sockopt_file) \\\n \t$(go_net_sockoptip_file) \\\n \tgo/net/tcpsock.go \\\n \tgo/net/tcpsock_posix.go \\\n+\tgo/net/tcpsockopt_posix.go \\\n+\t$(go_net_tcpsockopt_file) \\\n \tgo/net/udpsock.go \\\n \tgo/net/udpsock_posix.go \\\n \tgo/net/unixsock.go \\\n@@ -1046,12 +1062,15 @@ go_net_files = \\\n @LIBGO_IS_386_TRUE@@LIBGO_IS_SOLARIS_TRUE@go_os_dir_file = go/os/dir_largefile.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_dir_file = go/os/dir_regfile.go\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_os_dir_file = go/os/dir_largefile.go\n+@LIBGO_IS_DARWIN_FALSE@go_os_getwd_file = \n+@LIBGO_IS_DARWIN_TRUE@go_os_getwd_file = go/os/getwd_darwin.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_sys_file = go/os/sys_bsd.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_os_sys_file = go/os/sys_uname.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_sys_file = go/os/sys_uname.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_os_sys_file = go/os/sys_uname.go\n @LIBGO_IS_LINUX_TRUE@go_os_sys_file = go/os/sys_linux.go\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_dragonfly.go\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atimespec.go\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atimespec.go\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atimespec.go\n@@ -1066,14 +1085,15 @@ go_os_files = \\\n \tgo/os/doc.go \\\n \tgo/os/env.go \\\n \tgo/os/error.go \\\n-\tgo/os/error_posix.go \\\n+\tgo/os/error_unix.go \\\n \tgo/os/exec.go \\\n \tgo/os/exec_posix.go \\\n \tgo/os/exec_unix.go \\\n \tgo/os/file.go \\\n \tgo/os/file_posix.go \\\n \tgo/os/file_unix.go \\\n \tgo/os/getwd.go \\\n+\t$(go_os_getwd_file) \\\n \tgo/os/path.go \\\n \tgo/os/path_unix.go \\\n \t$(go_os_pipe_file) \\\n@@ -1149,7 +1169,11 @@ go_strings_files = \\\n \tgo/strings/reader.go \\\n \tgo/strings/replace.go \\\n \tgo/strings/search.go \\\n-\tgo/strings/strings.go\n+\tgo/strings/strings.go \\\n+\tgo/strings/strings_decl.go\n+\n+go_strings_c_files = \\\n+\tgo/strings/indexbyte.c\n \n go_sync_files = \\\n \tgo/sync/cond.go \\\n@@ -1173,6 +1197,7 @@ go_syslog_c_files = \\\n go_testing_files = \\\n \tgo/testing/allocs.go \\\n \tgo/testing/benchmark.go \\\n+\tgo/testing/cover.go \\\n \tgo/testing/example.go \\\n \tgo/testing/testing.go\n \n@@ -1208,6 +1233,7 @@ go_archive_tar_files = \\\n \n go_archive_zip_files = \\\n \tgo/archive/zip/reader.go \\\n+\tgo/archive/zip/register.go \\\n \tgo/archive/zip/struct.go \\\n \tgo/archive/zip/writer.go\n \n@@ -1259,6 +1285,7 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cfb.go \\\n \tgo/crypto/cipher/cipher.go \\\n \tgo/crypto/cipher/ctr.go \\\n+\tgo/crypto/cipher/gcm.go \\\n \tgo/crypto/cipher/io.go \\\n \tgo/crypto/cipher/ofb.go\n \n@@ -1275,7 +1302,8 @@ go_crypto_ecdsa_files = \\\n \n go_crypto_elliptic_files = \\\n \tgo/crypto/elliptic/elliptic.go \\\n-\tgo/crypto/elliptic/p224.go\n+\tgo/crypto/elliptic/p224.go \\\n+\tgo/crypto/elliptic/p256.go\n \n go_crypto_hmac_files = \\\n \tgo/crypto/hmac/hmac.go\n@@ -1295,6 +1323,7 @@ go_crypto_rc4_files = \\\n \n go_crypto_rsa_files = \\\n \tgo/crypto/rsa/pkcs1v15.go \\\n+\tgo/crypto/rsa/pss.go \\\n \tgo/crypto/rsa/rsa.go\n \n go_crypto_sha1_files = \\\n@@ -1509,11 +1538,15 @@ go_image_color_files = \\\n \tgo/image/color/color.go \\\n \tgo/image/color/ycbcr.go\n \n+go_image_color_palette_files = \\\n+\tgo/image/color/palette/palette.go\n+\n go_image_draw_files = \\\n \tgo/image/draw/draw.go\n \n go_image_gif_files = \\\n-\tgo/image/gif/reader.go\n+\tgo/image/gif/reader.go \\\n+\tgo/image/gif/writer.go\n \n go_image_jpeg_files = \\\n \tgo/image/jpeg/fdct.go \\\n@@ -1849,6 +1882,7 @@ libgo_go_objs = \\\n \tbytes.lo \\\n \tbytes/index.lo \\\n \tcrypto.lo \\\n+\tencoding.lo \\\n \terrors.lo \\\n \texpvar.lo \\\n \tflag.lo \\\n@@ -1870,6 +1904,7 @@ libgo_go_objs = \\\n \tsort.lo \\\n \tstrconv.lo \\\n \tstrings.lo \\\n+\tstrings/index.lo \\\n \tsync.lo \\\n \tsyscall.lo \\\n \tsyscall/errno.lo \\\n@@ -1946,6 +1981,7 @@ libgo_go_objs = \\\n \tnet/http/httputil.lo \\\n \tnet/http/pprof.lo \\\n \timage/color.lo \\\n+\timage/color/palette.lo \\\n \timage/draw.lo \\\n \timage/gif.lo \\\n \timage/jpeg.lo \\\n@@ -3518,6 +3554,26 @@ uninstall-toolexeclibgoimageDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgoimagedir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgoimagedir)\" && rm -f $$files\n+install-toolexeclibgoimagecolorDATA: $(toolexeclibgoimagecolor_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoimagecolordir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoimagecolordir)\"\n+\t@list='$(toolexeclibgoimagecolor_DATA)'; test -n \"$(toolexeclibgoimagecolordir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoimagecolordir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgoimagecolorDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoimagecolor_DATA)'; test -n \"$(toolexeclibgoimagecolordir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoimagecolordir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" && rm -f $$files\n install-toolexeclibgoindexDATA: $(toolexeclibgoindex_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgoindexdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoindexdir)\"\n@@ -4019,7 +4075,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -4092,6 +4148,7 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohtmlDATA install-toolexeclibgoimageDATA \\\n+\tinstall-toolexeclibgoimagecolorDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgologDATA install-toolexeclibgomathDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n@@ -4159,6 +4216,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n+\tuninstall-toolexeclibgoimagecolorDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n \tuninstall-toolexeclibgologDATA uninstall-toolexeclibgomathDATA \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n@@ -4203,6 +4261,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohtmlDATA install-toolexeclibgoimageDATA \\\n+\tinstall-toolexeclibgoimagecolorDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgologDATA install-toolexeclibgomathDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n@@ -4234,6 +4293,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n+\tuninstall-toolexeclibgoimagecolorDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n \tuninstall-toolexeclibgologDATA uninstall-toolexeclibgomathDATA \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n@@ -4391,6 +4451,15 @@ crypto/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/check\n \n+@go_include@ encoding.lo.dep\n+encoding.lo.dep: $(go_encoding_files)\n+\t$(BUILDDEPS)\n+encoding.lo: $(go_encoding_files)\n+\t$(BUILDPACKAGE)\n+encoding/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: encoding/check\n+\n @go_include@ errors.lo.dep\n errors.lo.dep: $(go_errors_files)\n \t$(BUILDDEPS)\n@@ -4572,6 +4641,9 @@ strings.lo.dep: $(go_strings_files)\n \t$(BUILDDEPS)\n strings.lo: $(go_strings_files)\n \t$(BUILDPACKAGE)\n+strings/index.lo: $(go_strings_c_files)\n+\t@$(MKDIR_P) strings\n+\t$(LTCOMPILE) -c -o strings/index.lo $(srcdir)/go/strings/indexbyte.c\n strings/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: strings/check\n@@ -5179,6 +5251,15 @@ image/color/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/color/check\n \n+@go_include@ image/color/palette.lo.dep\n+image/color/palette.lo.dep: $(go_image_color_palette_files)\n+\t$(BUILDDEPS)\n+image/color/palette.lo: $(go_image_color_palette_files)\n+\t$(BUILDPACKAGE)\n+image/color/palette/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: image/color/palette/check\n+\n @go_include@ image/draw.lo.dep\n image/draw.lo.dep: $(go_image_draw_files)\n \t$(BUILDDEPS)\n@@ -5586,6 +5667,8 @@ bytes.gox: bytes.lo\n \t$(BUILDGOX)\n crypto.gox: crypto.lo\n \t$(BUILDGOX)\n+encoding.gox: encoding.lo\n+\t$(BUILDGOX)\n errors.gox: errors.lo\n \t$(BUILDGOX)\n expvar.gox: expvar.lo\n@@ -5783,6 +5866,9 @@ image/jpeg.gox: image/jpeg.lo\n image/png.gox: image/png.lo\n \t$(BUILDGOX)\n \n+image/color/palette.gox: image/color/palette.lo\n+\t$(BUILDGOX)\n+\n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n "}, {"sha": "8af626d62083cdf134973b7c1245443fe9f7546d", "filename": "libgo/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -147,6 +147,9 @@\n /* Define to 1 if you have the `mknodat' function. */\n #undef HAVE_MKNODAT\n \n+/* Define to 1 if you have the <netinet/icmp6.h> header file. */\n+#undef HAVE_NETINET_ICMP6_H\n+\n /* Define to 1 if you have the <netinet/if_ether.h> header file. */\n #undef HAVE_NETINET_IF_ETHER_H\n "}, {"sha": "d2ad366bbf0f6273b6d6aa2c253bbb3ceed91f2a", "filename": "libgo/configure", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -659,6 +659,8 @@ LIBGO_IS_SOLARIS_FALSE\n LIBGO_IS_SOLARIS_TRUE\n LIBGO_IS_RTEMS_FALSE\n LIBGO_IS_RTEMS_TRUE\n+LIBGO_IS_DRAGONFLY_FALSE\n+LIBGO_IS_DRAGONFLY_TRUE\n LIBGO_IS_OPENBSD_FALSE\n LIBGO_IS_OPENBSD_TRUE\n LIBGO_IS_NETBSD_FALSE\n@@ -11111,7 +11113,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11114 \"configure\"\n+#line 11116 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11217,7 +11219,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11220 \"configure\"\n+#line 11222 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13490,6 +13492,7 @@ is_irix=no\n is_linux=no\n is_netbsd=no\n is_openbsd=no\n+is_dragonfly=no\n is_rtems=no\n is_solaris=no\n GOOS=unknown\n@@ -13500,6 +13503,7 @@ case ${host} in\n   *-*-linux*)    is_linux=yes;   GOOS=linux ;;\n   *-*-netbsd*)\t is_netbsd=yes;  GOOS=netbsd ;;\n   *-*-openbsd*)  is_openbsd=yes; GOOS=openbsd ;;\n+  *-*-dragonfly*) is_dragonfly=yes; GOOS=dragonfly ;;\n   *-*-rtems*)    is_rtems=yes;   GOOS=rtems ;;\n   *-*-solaris2*) is_solaris=yes; GOOS=solaris ;;\n esac\n@@ -13551,6 +13555,14 @@ else\n   LIBGO_IS_OPENBSD_FALSE=\n fi\n \n+ if test $is_dragonly = yes; then\n+  LIBGO_IS_DRAGONFLY_TRUE=\n+  LIBGO_IS_DRAGONFLY_FALSE='#'\n+else\n+  LIBGO_IS_DRAGONFLY_TRUE='#'\n+  LIBGO_IS_DRAGONFLY_FALSE=\n+fi\n+\n  if test $is_rtems = yes; then\n   LIBGO_IS_RTEMS_TRUE=\n   LIBGO_IS_RTEMS_FALSE='#'\n@@ -14600,7 +14612,7 @@ no)\n   ;;\n esac\n \n-for ac_header in sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h\n+for ac_header in sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\n@@ -15502,6 +15514,10 @@ if test -z \"${LIBGO_IS_OPENBSD_TRUE}\" && test -z \"${LIBGO_IS_OPENBSD_FALSE}\"; th\n   as_fn_error \"conditional \\\"LIBGO_IS_OPENBSD\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${LIBGO_IS_DRAGONFLY_TRUE}\" && test -z \"${LIBGO_IS_DRAGONFLY_FALSE}\"; then\n+  as_fn_error \"conditional \\\"LIBGO_IS_DRAGONFLY\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${LIBGO_IS_RTEMS_TRUE}\" && test -z \"${LIBGO_IS_RTEMS_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_RTEMS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "1e84dc7c3802006bb2b41f1995d1b91f54384375", "filename": "libgo/configure.ac", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -133,6 +133,7 @@ is_irix=no\n is_linux=no\n is_netbsd=no\n is_openbsd=no\n+is_dragonfly=no\n is_rtems=no\n is_solaris=no\n GOOS=unknown\n@@ -143,6 +144,7 @@ case ${host} in\n   *-*-linux*)    is_linux=yes;   GOOS=linux ;;\n   *-*-netbsd*)\t is_netbsd=yes;  GOOS=netbsd ;;\n   *-*-openbsd*)  is_openbsd=yes; GOOS=openbsd ;;\n+  *-*-dragonfly*) is_dragonfly=yes; GOOS=dragonfly ;;\n   *-*-rtems*)    is_rtems=yes;   GOOS=rtems ;;\n   *-*-solaris2*) is_solaris=yes; GOOS=solaris ;;\n esac\n@@ -152,6 +154,7 @@ AM_CONDITIONAL(LIBGO_IS_IRIX, test $is_irix = yes)\n AM_CONDITIONAL(LIBGO_IS_LINUX, test $is_linux = yes)\n AM_CONDITIONAL(LIBGO_IS_NETBSD, test $is_netbsd = yes)\n AM_CONDITIONAL(LIBGO_IS_OPENBSD, test $is_openbsd = yes)\n+AM_CONDITIONAL(LIBGO_IS_DRAGONFLY, test $is_dragonly = yes)\n AM_CONDITIONAL(LIBGO_IS_RTEMS, test $is_rtems = yes)\n AM_CONDITIONAL(LIBGO_IS_SOLARIS, test $is_solaris = yes)\n AC_SUBST(GOOS)\n@@ -471,7 +474,7 @@ no)\n   ;;\n esac\n \n-AC_CHECK_HEADERS(sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h)\n+AC_CHECK_HEADERS(sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h)\n \n AC_CHECK_HEADERS([linux/filter.h linux/if_addr.h linux/if_ether.h linux/if_tun.h linux/netlink.h linux/rtnetlink.h], [], [],\n [#ifdef HAVE_SYS_SOCKET_H"}, {"sha": "1b961e3ec637c4630018d17ac69131cc3b364277", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -13,6 +13,7 @@\n package tar\n \n import (\n+\t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n \t\"os\"\n@@ -82,9 +83,9 @@ func (fi headerFileInfo) Sys() interface{}   { return fi.h }\n // Name returns the base name of the file.\n func (fi headerFileInfo) Name() string {\n \tif fi.IsDir() {\n-\t\treturn path.Clean(fi.h.Name)\n+\t\treturn path.Base(path.Clean(fi.h.Name))\n \t}\n-\treturn fi.h.Name\n+\treturn path.Base(fi.h.Name)\n }\n \n // Mode returns the permission and mode bits for the headerFileInfo.\n@@ -174,9 +175,29 @@ const (\n \tc_ISSOCK = 0140000 // Socket\n )\n \n+// Keywords for the PAX Extended Header\n+const (\n+\tpaxAtime    = \"atime\"\n+\tpaxCharset  = \"charset\"\n+\tpaxComment  = \"comment\"\n+\tpaxCtime    = \"ctime\" // please note that ctime is not a valid pax header.\n+\tpaxGid      = \"gid\"\n+\tpaxGname    = \"gname\"\n+\tpaxLinkpath = \"linkpath\"\n+\tpaxMtime    = \"mtime\"\n+\tpaxPath     = \"path\"\n+\tpaxSize     = \"size\"\n+\tpaxUid      = \"uid\"\n+\tpaxUname    = \"uname\"\n+\tpaxNone     = \"\"\n+)\n+\n // FileInfoHeader creates a partially-populated Header from fi.\n // If fi describes a symlink, FileInfoHeader records link as the link target.\n // If fi describes a directory, a slash is appended to the name.\n+// Because os.FileInfo's Name method returns only the base name of\n+// the file it describes, it may be necessary to modify the Name field\n+// of the returned header to provide the full path name of the file.\n func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n \tif fi == nil {\n \t\treturn nil, errors.New(\"tar: FileInfo is nil\")\n@@ -257,3 +278,25 @@ func (sp *slicer) next(n int) (b []byte) {\n \tb, *sp = s[0:n], s[n:]\n \treturn\n }\n+\n+func isASCII(s string) bool {\n+\tfor _, c := range s {\n+\t\tif c >= 0x80 {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func toASCII(s string) string {\n+\tif isASCII(s) {\n+\t\treturn s\n+\t}\n+\tvar buf bytes.Buffer\n+\tfor _, c := range s {\n+\t\tif c < 0x80 {\n+\t\t\tbuf.WriteByte(byte(c))\n+\t\t}\n+\t}\n+\treturn buf.String()\n+}"}, {"sha": "b2d62f3c51c171e10ff237fb25f5e6acbd03341a", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -95,45 +95,45 @@ func (tr *Reader) Next() (*Header, error) {\n func mergePAX(hdr *Header, headers map[string]string) error {\n \tfor k, v := range headers {\n \t\tswitch k {\n-\t\tcase \"path\":\n+\t\tcase paxPath:\n \t\t\thdr.Name = v\n-\t\tcase \"linkpath\":\n+\t\tcase paxLinkpath:\n \t\t\thdr.Linkname = v\n-\t\tcase \"gname\":\n+\t\tcase paxGname:\n \t\t\thdr.Gname = v\n-\t\tcase \"uname\":\n+\t\tcase paxUname:\n \t\t\thdr.Uname = v\n-\t\tcase \"uid\":\n+\t\tcase paxUid:\n \t\t\tuid, err := strconv.ParseInt(v, 10, 0)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\thdr.Uid = int(uid)\n-\t\tcase \"gid\":\n+\t\tcase paxGid:\n \t\t\tgid, err := strconv.ParseInt(v, 10, 0)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\thdr.Gid = int(gid)\n-\t\tcase \"atime\":\n+\t\tcase paxAtime:\n \t\t\tt, err := parsePAXTime(v)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\thdr.AccessTime = t\n-\t\tcase \"mtime\":\n+\t\tcase paxMtime:\n \t\t\tt, err := parsePAXTime(v)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\thdr.ModTime = t\n-\t\tcase \"ctime\":\n+\t\tcase paxCtime:\n \t\t\tt, err := parsePAXTime(v)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\thdr.ChangeTime = t\n-\t\tcase \"size\":\n+\t\tcase paxSize:\n \t\t\tsize, err := strconv.ParseInt(v, 10, 0)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n@@ -243,13 +243,15 @@ func (tr *Reader) octal(b []byte) int64 {\n \t\treturn x\n \t}\n \n-\t// Removing leading spaces.\n-\tfor len(b) > 0 && b[0] == ' ' {\n-\t\tb = b[1:]\n-\t}\n-\t// Removing trailing NULs and spaces.\n-\tfor len(b) > 0 && (b[len(b)-1] == ' ' || b[len(b)-1] == '\\x00') {\n-\t\tb = b[0 : len(b)-1]\n+\t// Because unused fields are filled with NULs, we need\n+\t// to skip leading NULs. Fields may also be padded with\n+\t// spaces or NULs.\n+\t// So we remove leading and trailing NULs and spaces to\n+\t// be sure.\n+\tb = bytes.Trim(b, \" \\x00\")\n+\n+\tif len(b) == 0 {\n+\t\treturn 0\n \t}\n \tx, err := strconv.ParseUint(cString(b), 8, 64)\n \tif err != nil {"}, {"sha": "12856165656a6bb477eddac8aba7e17790870636", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -142,6 +142,25 @@ var untarTests = []*untarTest{\n \t\t\t},\n \t\t},\n \t},\n+\t{\n+\t\tfile: \"testdata/nil-uid.tar\", // golang.org/issue/5290\n+\t\theaders: []*Header{\n+\t\t\t{\n+\t\t\t\tName:     \"P1050238.JPG.log\",\n+\t\t\t\tMode:     0664,\n+\t\t\t\tUid:      0,\n+\t\t\t\tGid:      0,\n+\t\t\t\tSize:     14,\n+\t\t\t\tModTime:  time.Unix(1365454838, 0),\n+\t\t\t\tTypeflag: TypeReg,\n+\t\t\t\tLinkname: \"\",\n+\t\t\t\tUname:    \"eyefi\",\n+\t\t\t\tGname:    \"eyefi\",\n+\t\t\t\tDevmajor: 0,\n+\t\t\t\tDevminor: 0,\n+\t\t\t},\n+\t\t},\n+\t},\n }\n \n func TestReader(t *testing.T) {\n@@ -152,6 +171,7 @@ testLoop:\n \t\t\tt.Errorf(\"test %d: Unexpected error: %v\", i, err)\n \t\t\tcontinue\n \t\t}\n+\t\tdefer f.Close()\n \t\ttr := NewReader(f)\n \t\tfor j, header := range test.headers {\n \t\t\thdr, err := tr.Next()\n@@ -172,7 +192,6 @@ testLoop:\n \t\tif hdr != nil || err != nil {\n \t\t\tt.Errorf(\"test %d: Unexpected entry or error: hdr=%v err=%v\", i, hdr, err)\n \t\t}\n-\t\tf.Close()\n \t}\n }\n "}, {"sha": "616a9cc57eee6884a500ec10499beb7243832b2c", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -8,7 +8,9 @@ import (\n \t\"bytes\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"path\"\n \t\"reflect\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -249,7 +251,14 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\tt.Error(err)\n \t\t\tcontinue\n \t\t}\n-\t\tif got, want := h2.Name, g.h.Name; got != want {\n+\t\tif strings.Contains(fi.Name(), \"/\") {\n+\t\t\tt.Errorf(\"FileInfo of %q contains slash: %q\", g.h.Name, fi.Name())\n+\t\t}\n+\t\tname := path.Base(g.h.Name)\n+\t\tif fi.IsDir() {\n+\t\t\tname += \"/\"\n+\t\t}\n+\t\tif got, want := h2.Name, name; got != want {\n \t\t\tt.Errorf(\"i=%d: Name: got %v, want %v\", i, got, want)\n \t\t}\n \t\tif got, want := h2.Size, g.h.Size; got != want {"}, {"sha": "cc9cfaa33cc5de0a28b4183c1705d801f788c96a", "filename": "libgo/go/archive/tar/testdata/nil-uid.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fnil-uid.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fnil-uid.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fnil-uid.tar?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "549f1464c38b0b2667843f1ba3db9c967525d3f7", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 119, "deletions": 55, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -24,6 +24,7 @@ var (\n \tErrFieldTooLong    = errors.New(\"archive/tar: header field too long\")\n \tErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n \terrNameTooLong     = errors.New(\"archive/tar: name too long\")\n+\terrInvalidHeader   = errors.New(\"archive/tar: header field too long or contains invalid values\")\n )\n \n // A Writer provides sequential writing of a tar archive in POSIX.1 format.\n@@ -37,6 +38,7 @@ type Writer struct {\n \tpad        int64 // amount of padding to write after current file entry\n \tclosed     bool\n \tusedBinary bool // whether the binary numeric field extension was used\n+\tpreferPax  bool // use pax header instead of binary numeric header\n }\n \n // NewWriter creates a new Writer writing to w.\n@@ -65,16 +67,23 @@ func (tw *Writer) Flush() error {\n }\n \n // Write s into b, terminating it with a NUL if there is room.\n-func (tw *Writer) cString(b []byte, s string) {\n+// If the value is too long for the field and allowPax is true add a paxheader record instead\n+func (tw *Writer) cString(b []byte, s string, allowPax bool, paxKeyword string, paxHeaders map[string]string) {\n+\tneedsPaxHeader := allowPax && len(s) > len(b) || !isASCII(s)\n+\tif needsPaxHeader {\n+\t\tpaxHeaders[paxKeyword] = s\n+\t\treturn\n+\t}\n \tif len(s) > len(b) {\n \t\tif tw.err == nil {\n \t\t\ttw.err = ErrFieldTooLong\n \t\t}\n \t\treturn\n \t}\n-\tcopy(b, s)\n-\tif len(s) < len(b) {\n-\t\tb[len(s)] = 0\n+\tascii := toASCII(s)\n+\tcopy(b, ascii)\n+\tif len(ascii) < len(b) {\n+\t\tb[len(ascii)] = 0\n \t}\n }\n \n@@ -85,17 +94,27 @@ func (tw *Writer) octal(b []byte, x int64) {\n \tfor len(s)+1 < len(b) {\n \t\ts = \"0\" + s\n \t}\n-\ttw.cString(b, s)\n+\ttw.cString(b, s, false, paxNone, nil)\n }\n \n // Write x into b, either as octal or as binary (GNUtar/star extension).\n-func (tw *Writer) numeric(b []byte, x int64) {\n+// If the value is too long for the field and writingPax is enabled both for the field and the add a paxheader record instead\n+func (tw *Writer) numeric(b []byte, x int64, allowPax bool, paxKeyword string, paxHeaders map[string]string) {\n \t// Try octal first.\n \ts := strconv.FormatInt(x, 8)\n \tif len(s) < len(b) {\n \t\ttw.octal(b, x)\n \t\treturn\n \t}\n+\n+\t// If it is too long for octal, and pax is preferred, use a pax header\n+\tif allowPax && tw.preferPax {\n+\t\ttw.octal(b, 0)\n+\t\ts := strconv.FormatInt(x, 10)\n+\t\tpaxHeaders[paxKeyword] = s\n+\t\treturn\n+\t}\n+\n \t// Too big: use binary (big-endian).\n \ttw.usedBinary = true\n \tfor i := len(b) - 1; x > 0 && i >= 0; i-- {\n@@ -115,6 +134,15 @@ var (\n // WriteHeader calls Flush if it is not the first header.\n // Calling after a Close will return ErrWriteAfterClose.\n func (tw *Writer) WriteHeader(hdr *Header) error {\n+\treturn tw.writeHeader(hdr, true)\n+}\n+\n+// WriteHeader writes hdr and prepares to accept the file's contents.\n+// WriteHeader calls Flush if it is not the first header.\n+// Calling after a Close will return ErrWriteAfterClose.\n+// As this method is called internally by writePax header to allow it to\n+// suppress writing the pax header.\n+func (tw *Writer) writeHeader(hdr *Header, allowPax bool) error {\n \tif tw.closed {\n \t\treturn ErrWriteAfterClose\n \t}\n@@ -124,59 +152,77 @@ func (tw *Writer) WriteHeader(hdr *Header) error {\n \tif tw.err != nil {\n \t\treturn tw.err\n \t}\n-\t// Decide whether or not to use PAX extensions\n+\n+\t// a map to hold pax header records, if any are needed\n+\tpaxHeaders := make(map[string]string)\n+\n \t// TODO(shanemhansen): we might want to use PAX headers for\n \t// subsecond time resolution, but for now let's just capture\n-\t// the long name/long symlink use case.\n-\tsuffix := hdr.Name\n-\tprefix := \"\"\n-\tif len(hdr.Name) > fileNameSize || len(hdr.Linkname) > fileNameSize {\n-\t\tvar err error\n-\t\tprefix, suffix, err = tw.splitUSTARLongName(hdr.Name)\n-\t\t// Either we were unable to pack the long name into ustar format\n-\t\t// or the link name is too long; use PAX headers.\n-\t\tif err == errNameTooLong || len(hdr.Linkname) > fileNameSize {\n-\t\t\tif err := tw.writePAXHeader(hdr); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t} else if err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\ttw.nb = int64(hdr.Size)\n-\ttw.pad = -tw.nb & (blockSize - 1) // blockSize is a power of two\n+\t// too long fields or non ascii characters\n \n \theader := make([]byte, blockSize)\n \ts := slicer(header)\n-\ttw.cString(s.next(fileNameSize), suffix)\n+\n+\t// keep a reference to the filename to allow to overwrite it later if we detect that we can use ustar longnames instead of pax\n+\tpathHeaderBytes := s.next(fileNameSize)\n+\n+\ttw.cString(pathHeaderBytes, hdr.Name, true, paxPath, paxHeaders)\n \n \t// Handle out of range ModTime carefully.\n \tvar modTime int64\n \tif !hdr.ModTime.Before(minTime) && !hdr.ModTime.After(maxTime) {\n \t\tmodTime = hdr.ModTime.Unix()\n \t}\n \n-\ttw.octal(s.next(8), hdr.Mode)          // 100:108\n-\ttw.numeric(s.next(8), int64(hdr.Uid))  // 108:116\n-\ttw.numeric(s.next(8), int64(hdr.Gid))  // 116:124\n-\ttw.numeric(s.next(12), hdr.Size)       // 124:136\n-\ttw.numeric(s.next(12), modTime)        // 136:148\n-\ts.next(8)                              // chksum (148:156)\n-\ts.next(1)[0] = hdr.Typeflag            // 156:157\n-\ttw.cString(s.next(100), hdr.Linkname)  // linkname (157:257)\n-\tcopy(s.next(8), []byte(\"ustar\\x0000\")) // 257:265\n-\ttw.cString(s.next(32), hdr.Uname)      // 265:297\n-\ttw.cString(s.next(32), hdr.Gname)      // 297:329\n-\ttw.numeric(s.next(8), hdr.Devmajor)    // 329:337\n-\ttw.numeric(s.next(8), hdr.Devminor)    // 337:345\n-\ttw.cString(s.next(155), prefix)        // 345:500\n+\ttw.octal(s.next(8), hdr.Mode)                                   // 100:108\n+\ttw.numeric(s.next(8), int64(hdr.Uid), true, paxUid, paxHeaders) // 108:116\n+\ttw.numeric(s.next(8), int64(hdr.Gid), true, paxGid, paxHeaders) // 116:124\n+\ttw.numeric(s.next(12), hdr.Size, true, paxSize, paxHeaders)     // 124:136\n+\ttw.numeric(s.next(12), modTime, false, paxNone, nil)            // 136:148 --- consider using pax for finer granularity\n+\ts.next(8)                                                       // chksum (148:156)\n+\ts.next(1)[0] = hdr.Typeflag                                     // 156:157\n+\n+\ttw.cString(s.next(100), hdr.Linkname, true, paxLinkpath, paxHeaders)\n+\n+\tcopy(s.next(8), []byte(\"ustar\\x0000\"))                        // 257:265\n+\ttw.cString(s.next(32), hdr.Uname, true, paxUname, paxHeaders) // 265:297\n+\ttw.cString(s.next(32), hdr.Gname, true, paxGname, paxHeaders) // 297:329\n+\ttw.numeric(s.next(8), hdr.Devmajor, false, paxNone, nil)      // 329:337\n+\ttw.numeric(s.next(8), hdr.Devminor, false, paxNone, nil)      // 337:345\n+\n+\t// keep a reference to the prefix to allow to overwrite it later if we detect that we can use ustar longnames instead of pax\n+\tprefixHeaderBytes := s.next(155)\n+\ttw.cString(prefixHeaderBytes, \"\", false, paxNone, nil) // 345:500  prefix\n+\n \t// Use the GNU magic instead of POSIX magic if we used any GNU extensions.\n \tif tw.usedBinary {\n \t\tcopy(header[257:265], []byte(\"ustar  \\x00\"))\n \t}\n-\t// Use the ustar magic if we used ustar long names.\n-\tif len(prefix) > 0 {\n-\t\tcopy(header[257:265], []byte(\"ustar\\000\"))\n+\n+\t_, paxPathUsed := paxHeaders[paxPath]\n+\t// try to use a ustar header when only the name is too long\n+\tif !tw.preferPax && len(paxHeaders) == 1 && paxPathUsed {\n+\t\tsuffix := hdr.Name\n+\t\tprefix := \"\"\n+\t\tif len(hdr.Name) > fileNameSize && isASCII(hdr.Name) {\n+\t\t\tvar err error\n+\t\t\tprefix, suffix, err = tw.splitUSTARLongName(hdr.Name)\n+\t\t\tif err == nil {\n+\t\t\t\t// ok we can use a ustar long name instead of pax, now correct the fields\n+\n+\t\t\t\t// remove the path field from the pax header. this will suppress the pax header\n+\t\t\t\tdelete(paxHeaders, paxPath)\n+\n+\t\t\t\t// update the path fields\n+\t\t\t\ttw.cString(pathHeaderBytes, suffix, false, paxNone, nil)\n+\t\t\t\ttw.cString(prefixHeaderBytes, prefix, false, paxNone, nil)\n+\n+\t\t\t\t// Use the ustar magic if we used ustar long names.\n+\t\t\t\tif len(prefix) > 0 {\n+\t\t\t\t\tcopy(header[257:265], []byte(\"ustar\\000\"))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n \t// The chksum field is terminated by a NUL and a space.\n@@ -190,8 +236,18 @@ func (tw *Writer) WriteHeader(hdr *Header) error {\n \t\treturn tw.err\n \t}\n \n-\t_, tw.err = tw.w.Write(header)\n+\tif len(paxHeaders) > 0 {\n+\t\tif !allowPax {\n+\t\t\treturn errInvalidHeader\n+\t\t}\n+\t\tif err := tw.writePAXHeader(hdr, paxHeaders); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\ttw.nb = int64(hdr.Size)\n+\ttw.pad = (blockSize - (tw.nb % blockSize)) % blockSize\n \n+\t_, tw.err = tw.w.Write(header)\n \treturn tw.err\n }\n \n@@ -207,8 +263,11 @@ func (tw *Writer) splitUSTARLongName(name string) (prefix, suffix string, err er\n \t\tlength--\n \t}\n \ti := strings.LastIndex(name[:length], \"/\")\n-\tnlen := length - i - 1\n-\tif i <= 0 || nlen > fileNameSize || nlen == 0 {\n+\t// nlen contains the resulting length in the name field.\n+\t// plen contains the resulting length in the prefix field.\n+\tnlen := len(name) - i - 1\n+\tplen := i\n+\tif i <= 0 || nlen > fileNameSize || nlen == 0 || plen > fileNamePrefixSize {\n \t\terr = errNameTooLong\n \t\treturn\n \t}\n@@ -218,7 +277,7 @@ func (tw *Writer) splitUSTARLongName(name string) (prefix, suffix string, err er\n \n // writePaxHeader writes an extended pax header to the\n // archive.\n-func (tw *Writer) writePAXHeader(hdr *Header) error {\n+func (tw *Writer) writePAXHeader(hdr *Header, paxHeaders map[string]string) error {\n \t// Prepare extended header\n \text := new(Header)\n \text.Typeflag = TypeXHeader\n@@ -229,18 +288,23 @@ func (tw *Writer) writePAXHeader(hdr *Header) error {\n \t// with the current pid.\n \tpid := os.Getpid()\n \tdir, file := path.Split(hdr.Name)\n-\text.Name = path.Join(dir,\n-\t\tfmt.Sprintf(\"PaxHeaders.%d\", pid), file)[0:100]\n+\tfullName := path.Join(dir,\n+\t\tfmt.Sprintf(\"PaxHeaders.%d\", pid), file)\n+\n+\tascii := toASCII(fullName)\n+\tif len(ascii) > 100 {\n+\t\tascii = ascii[:100]\n+\t}\n+\text.Name = ascii\n \t// Construct the body\n \tvar buf bytes.Buffer\n-\tif len(hdr.Name) > fileNameSize {\n-\t\tfmt.Fprint(&buf, paxHeader(\"path=\"+hdr.Name))\n-\t}\n-\tif len(hdr.Linkname) > fileNameSize {\n-\t\tfmt.Fprint(&buf, paxHeader(\"linkpath=\"+hdr.Linkname))\n+\n+\tfor k, v := range paxHeaders {\n+\t\tfmt.Fprint(&buf, paxHeader(k+\"=\"+v))\n \t}\n+\n \text.Size = int64(len(buf.Bytes()))\n-\tif err := tw.WriteHeader(ext); err != nil {\n+\tif err := tw.writeHeader(ext, false); err != nil {\n \t\treturn err\n \t}\n \tif _, err := tw.Write(buf.Bytes()); err != nil {"}, {"sha": "30ebf977acfc09f9c0764065004526069f12cd2b", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 134, "deletions": 3, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -243,15 +243,110 @@ func TestPax(t *testing.T) {\n \t}\n }\n \n+func TestPaxSymlink(t *testing.T) {\n+\t// Create an archive with a large linkname\n+\tfileinfo, err := os.Stat(\"testdata/small.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\thdr, err := FileInfoHeader(fileinfo, \"\")\n+\thdr.Typeflag = TypeSymlink\n+\tif err != nil {\n+\t\tt.Fatalf(\"os.Stat:1 %v\", err)\n+\t}\n+\t// Force a PAX long linkname to be written\n+\tlongLinkname := strings.Repeat(\"1234567890/1234567890\", 10)\n+\thdr.Linkname = longLinkname\n+\n+\thdr.Size = 0\n+\tvar buf bytes.Buffer\n+\twriter := NewWriter(&buf)\n+\tif err := writer.WriteHeader(hdr); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := writer.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// Simple test to make sure PAX extensions are in effect\n+\tif !bytes.Contains(buf.Bytes(), []byte(\"PaxHeaders.\")) {\n+\t\tt.Fatal(\"Expected at least one PAX header to be written.\")\n+\t}\n+\t// Test that we can get a long name back out of the archive.\n+\treader := NewReader(&buf)\n+\thdr, err = reader.Next()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif hdr.Linkname != longLinkname {\n+\t\tt.Fatal(\"Couldn't recover long link name\")\n+\t}\n+}\n+\n+func TestPaxNonAscii(t *testing.T) {\n+\t// Create an archive with non ascii. These should trigger a pax header\n+\t// because pax headers have a defined utf-8 encoding.\n+\tfileinfo, err := os.Stat(\"testdata/small.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\thdr, err := FileInfoHeader(fileinfo, \"\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"os.Stat:1 %v\", err)\n+\t}\n+\n+\t// some sample data\n+\tchineseFilename := \"\u6587\u4ef6\u540d\"\n+\tchineseGroupname := \"\u7d44\"\n+\tchineseUsername := \"\u7528\u6236\u540d\"\n+\n+\thdr.Name = chineseFilename\n+\thdr.Gname = chineseGroupname\n+\thdr.Uname = chineseUsername\n+\n+\tcontents := strings.Repeat(\" \", int(hdr.Size))\n+\n+\tvar buf bytes.Buffer\n+\twriter := NewWriter(&buf)\n+\tif err := writer.WriteHeader(hdr); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif _, err = writer.Write([]byte(contents)); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := writer.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// Simple test to make sure PAX extensions are in effect\n+\tif !bytes.Contains(buf.Bytes(), []byte(\"PaxHeaders.\")) {\n+\t\tt.Fatal(\"Expected at least one PAX header to be written.\")\n+\t}\n+\t// Test that we can get a long name back out of the archive.\n+\treader := NewReader(&buf)\n+\thdr, err = reader.Next()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif hdr.Name != chineseFilename {\n+\t\tt.Fatal(\"Couldn't recover unicode name\")\n+\t}\n+\tif hdr.Gname != chineseGroupname {\n+\t\tt.Fatal(\"Couldn't recover unicode group\")\n+\t}\n+\tif hdr.Uname != chineseUsername {\n+\t\tt.Fatal(\"Couldn't recover unicode user\")\n+\t}\n+}\n+\n func TestPAXHeader(t *testing.T) {\n \tmedName := strings.Repeat(\"CD\", 50)\n \tlongName := strings.Repeat(\"AB\", 100)\n \tpaxTests := [][2]string{\n-\t\t{\"name=/etc/hosts\", \"19 name=/etc/hosts\\n\"},\n+\t\t{paxPath + \"=/etc/hosts\", \"19 path=/etc/hosts\\n\"},\n \t\t{\"a=b\", \"6 a=b\\n\"},          // Single digit length\n \t\t{\"a=names\", \"11 a=names\\n\"}, // Test case involving carries\n-\t\t{\"name=\" + longName, fmt.Sprintf(\"210 name=%s\\n\", longName)},\n-\t\t{\"name=\" + medName, fmt.Sprintf(\"110 name=%s\\n\", medName)}}\n+\t\t{paxPath + \"=\" + longName, fmt.Sprintf(\"210 path=%s\\n\", longName)},\n+\t\t{paxPath + \"=\" + medName, fmt.Sprintf(\"110 path=%s\\n\", medName)}}\n \n \tfor _, test := range paxTests {\n \t\tkey, expected := test[0], test[1]\n@@ -260,3 +355,39 @@ func TestPAXHeader(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestUSTARLongName(t *testing.T) {\n+\t// Create an archive with a path that failed to split with USTAR extension in previous versions.\n+\tfileinfo, err := os.Stat(\"testdata/small.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\thdr, err := FileInfoHeader(fileinfo, \"\")\n+\thdr.Typeflag = TypeDir\n+\tif err != nil {\n+\t\tt.Fatalf(\"os.Stat:1 %v\", err)\n+\t}\n+\t// Force a PAX long name to be written. The name was taken from a practical example\n+\t// that fails and replaced ever char through numbers to anonymize the sample.\n+\tlongName := \"/0000_0000000/00000-000000000/0000_0000000/00000-0000000000000/0000_0000000/00000-0000000-00000000/0000_0000000/00000000/0000_0000000/000/0000_0000000/00000000v00/0000_0000000/000000/0000_0000000/0000000/0000_0000000/00000y-00/0000/0000/00000000/0x000000/\"\n+\thdr.Name = longName\n+\n+\thdr.Size = 0\n+\tvar buf bytes.Buffer\n+\twriter := NewWriter(&buf)\n+\tif err := writer.WriteHeader(hdr); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := writer.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// Test that we can get a long name back out of the archive.\n+\treader := NewReader(&buf)\n+\thdr, err = reader.Next()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif hdr.Name != longName {\n+\t\tt.Fatal(\"Couldn't recover long name\")\n+\t}\n+}"}, {"sha": "116737337fb36f0b536a1c4b0c9de21e840f1510", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,13 +6,11 @@ package zip\n \n import (\n \t\"bufio\"\n-\t\"compress/flate\"\n \t\"encoding/binary\"\n \t\"errors\"\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"os\"\n )\n \n@@ -116,6 +114,19 @@ func (rc *ReadCloser) Close() error {\n \treturn rc.f.Close()\n }\n \n+// DataOffset returns the offset of the file's possibly-compressed\n+// data, relative to the beginning of the zip file.\n+//\n+// Most callers should instead use Open, which transparently\n+// decompresses data and verifies checksums.\n+func (f *File) DataOffset() (offset int64, err error) {\n+\tbodyOffset, err := f.findBodyOffset()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn f.headerOffset + bodyOffset, nil\n+}\n+\n // Open returns a ReadCloser that provides access to the File's contents.\n // Multiple files may be read concurrently.\n func (f *File) Open() (rc io.ReadCloser, err error) {\n@@ -125,15 +136,12 @@ func (f *File) Open() (rc io.ReadCloser, err error) {\n \t}\n \tsize := int64(f.CompressedSize64)\n \tr := io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset, size)\n-\tswitch f.Method {\n-\tcase Store: // (no compression)\n-\t\trc = ioutil.NopCloser(r)\n-\tcase Deflate:\n-\t\trc = flate.NewReader(r)\n-\tdefault:\n+\tdcomp := decompressor(f.Method)\n+\tif dcomp == nil {\n \t\terr = ErrAlgorithm\n \t\treturn\n \t}\n+\trc = dcomp(r)\n \tvar desr io.Reader\n \tif f.hasDataDescriptor() {\n \t\tdesr = io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset+size, dataDescriptorLen)\n@@ -184,9 +192,8 @@ func (r *checksumReader) Close() error { return r.rc.Close() }\n // findBodyOffset does the minimum work to verify the file has a header\n // and returns the file body offset.\n func (f *File) findBodyOffset() (int64, error) {\n-\tr := io.NewSectionReader(f.zipr, f.headerOffset, f.zipsize-f.headerOffset)\n \tvar buf [fileHeaderLen]byte\n-\tif _, err := io.ReadFull(r, buf[:]); err != nil {\n+\tif _, err := f.zipr.ReadAt(buf[:], f.headerOffset); err != nil {\n \t\treturn 0, err\n \t}\n \tb := readBuf(buf[:])"}, {"sha": "78875ecbf0e0684018b9faae73df79a99d4e03b6", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -276,6 +276,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t\tvar rc *ReadCloser\n \t\trc, err = OpenReader(filepath.Join(\"testdata\", zt.Name))\n \t\tif err == nil {\n+\t\t\tdefer rc.Close()\n \t\t\tz = &rc.Reader\n \t\t}\n \t}"}, {"sha": "c046f081b736cd4cb884029097a1308595459d6b", "filename": "libgo/go/archive/zip/register.go", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package zip\n+\n+import (\n+\t\"compress/flate\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"sync\"\n+)\n+\n+// A Compressor returns a compressing writer, writing to the\n+// provided writer. On Close, any pending data should be flushed.\n+type Compressor func(io.Writer) (io.WriteCloser, error)\n+\n+// Decompressor is a function that wraps a Reader with a decompressing Reader.\n+// The decompressed ReadCloser is returned to callers who open files from\n+// within the archive.  These callers are responsible for closing this reader\n+// when they're finished reading.\n+type Decompressor func(io.Reader) io.ReadCloser\n+\n+var (\n+\tmu sync.RWMutex // guards compressor and decompressor maps\n+\n+\tcompressors = map[uint16]Compressor{\n+\t\tStore:   func(w io.Writer) (io.WriteCloser, error) { return &nopCloser{w}, nil },\n+\t\tDeflate: func(w io.Writer) (io.WriteCloser, error) { return flate.NewWriter(w, 5) },\n+\t}\n+\n+\tdecompressors = map[uint16]Decompressor{\n+\t\tStore:   ioutil.NopCloser,\n+\t\tDeflate: flate.NewReader,\n+\t}\n+)\n+\n+// RegisterDecompressor allows custom decompressors for a specified method ID.\n+func RegisterDecompressor(method uint16, d Decompressor) {\n+\tmu.Lock()\n+\tdefer mu.Unlock()\n+\n+\tif _, ok := decompressors[method]; ok {\n+\t\tpanic(\"decompressor already registered\")\n+\t}\n+\tdecompressors[method] = d\n+}\n+\n+// RegisterCompressor registers custom compressors for a specified method ID.\n+// The common methods Store and Deflate are built in.\n+func RegisterCompressor(method uint16, comp Compressor) {\n+\tmu.Lock()\n+\tdefer mu.Unlock()\n+\n+\tif _, ok := compressors[method]; ok {\n+\t\tpanic(\"compressor already registered\")\n+\t}\n+\tcompressors[method] = comp\n+}\n+\n+func compressor(method uint16) Compressor {\n+\tmu.RLock()\n+\tdefer mu.RUnlock()\n+\treturn compressors[method]\n+}\n+\n+func decompressor(method uint16) Decompressor {\n+\tmu.RLock()\n+\tdefer mu.RUnlock()\n+\treturn decompressors[method]\n+}"}, {"sha": "65e5238c3b45cd155f9299881ff37008d059381b", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -21,6 +21,7 @@ package zip\n \n import (\n \t\"os\"\n+\t\"path\"\n \t\"time\"\n )\n \n@@ -99,7 +100,7 @@ type headerFileInfo struct {\n \tfh *FileHeader\n }\n \n-func (fi headerFileInfo) Name() string { return fi.fh.Name }\n+func (fi headerFileInfo) Name() string { return path.Base(fi.fh.Name) }\n func (fi headerFileInfo) Size() int64 {\n \tif fi.fh.UncompressedSize64 > 0 {\n \t\treturn int64(fi.fh.UncompressedSize64)\n@@ -113,6 +114,9 @@ func (fi headerFileInfo) Sys() interface{}   { return fi.fh }\n \n // FileInfoHeader creates a partially-populated FileHeader from an\n // os.FileInfo.\n+// Because os.FileInfo's Name method returns only the base name of\n+// the file it describes, it may be necessary to modify the Name field\n+// of the returned header to provide the full path name of the file.\n func FileInfoHeader(fi os.FileInfo) (*FileHeader, error) {\n \tsize := fi.Size()\n \tfh := &FileHeader{"}, {"sha": "6c9800a78f7fae2f9eaa8734f0dada11de5e960c", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,7 +6,6 @@ package zip\n \n import (\n \t\"bufio\"\n-\t\"compress/flate\"\n \t\"encoding/binary\"\n \t\"errors\"\n \t\"hash\"\n@@ -198,18 +197,15 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \t\tcompCount: &countWriter{w: w.cw},\n \t\tcrc32:     crc32.NewIEEE(),\n \t}\n-\tswitch fh.Method {\n-\tcase Store:\n-\t\tfw.comp = nopCloser{fw.compCount}\n-\tcase Deflate:\n-\t\tvar err error\n-\t\tfw.comp, err = flate.NewWriter(fw.compCount, 5)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\tdefault:\n+\tcomp := compressor(fh.Method)\n+\tif comp == nil {\n \t\treturn nil, ErrAlgorithm\n \t}\n+\tvar err error\n+\tfw.comp, err = comp(fw.compCount)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \tfw.rawCount = &countWriter{w: fw.comp}\n \n \th := &header{"}, {"sha": "32a16a79efbcc78a617093d5f2751f140c17d77d", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 155, "deletions": 15, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -9,22 +9,24 @@ package zip\n import (\n \t\"bytes\"\n \t\"fmt\"\n+\t\"hash\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"sort\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n \n func TestOver65kFiles(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"slow test; skipping\")\n-\t}\n \tbuf := new(bytes.Buffer)\n \tw := NewWriter(buf)\n \tconst nFiles = (1 << 16) + 42\n \tfor i := 0; i < nFiles; i++ {\n-\t\t_, err := w.Create(fmt.Sprintf(\"%d.dat\", i))\n+\t\t_, err := w.CreateHeader(&FileHeader{\n+\t\t\tName:   fmt.Sprintf(\"%d.dat\", i),\n+\t\t\tMethod: Store, // avoid Issue 6136 and Issue 6138\n+\t\t})\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"creating file %d: %v\", i, err)\n \t\t}\n@@ -105,29 +107,156 @@ func TestFileHeaderRoundTrip64(t *testing.T) {\n \ttestHeaderRoundTrip(fh, uint32max, fh.UncompressedSize64, t)\n }\n \n+type repeatedByte struct {\n+\toff int64\n+\tb   byte\n+\tn   int64\n+}\n+\n+// rleBuffer is a run-length-encoded byte buffer.\n+// It's an io.Writer (like a bytes.Buffer) and also an io.ReaderAt,\n+// allowing random-access reads.\n+type rleBuffer struct {\n+\tbuf []repeatedByte\n+}\n+\n+func (r *rleBuffer) Size() int64 {\n+\tif len(r.buf) == 0 {\n+\t\treturn 0\n+\t}\n+\tlast := &r.buf[len(r.buf)-1]\n+\treturn last.off + last.n\n+}\n+\n+func (r *rleBuffer) Write(p []byte) (n int, err error) {\n+\tvar rp *repeatedByte\n+\tif len(r.buf) > 0 {\n+\t\trp = &r.buf[len(r.buf)-1]\n+\t\t// Fast path, if p is entirely the same byte repeated.\n+\t\tif lastByte := rp.b; len(p) > 0 && p[0] == lastByte {\n+\t\t\tall := true\n+\t\t\tfor _, b := range p {\n+\t\t\t\tif b != lastByte {\n+\t\t\t\t\tall = false\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif all {\n+\t\t\t\trp.n += int64(len(p))\n+\t\t\t\treturn len(p), nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor _, b := range p {\n+\t\tif rp == nil || rp.b != b {\n+\t\t\tr.buf = append(r.buf, repeatedByte{r.Size(), b, 1})\n+\t\t\trp = &r.buf[len(r.buf)-1]\n+\t\t} else {\n+\t\t\trp.n++\n+\t\t}\n+\t}\n+\treturn len(p), nil\n+}\n+\n+func (r *rleBuffer) ReadAt(p []byte, off int64) (n int, err error) {\n+\tif len(p) == 0 {\n+\t\treturn\n+\t}\n+\tskipParts := sort.Search(len(r.buf), func(i int) bool {\n+\t\tpart := &r.buf[i]\n+\t\treturn part.off+part.n > off\n+\t})\n+\tparts := r.buf[skipParts:]\n+\tif len(parts) > 0 {\n+\t\tskipBytes := off - parts[0].off\n+\t\tfor len(parts) > 0 {\n+\t\t\tpart := parts[0]\n+\t\t\tfor i := skipBytes; i < part.n; i++ {\n+\t\t\t\tif n == len(p) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tp[n] = part.b\n+\t\t\t\tn++\n+\t\t\t}\n+\t\t\tparts = parts[1:]\n+\t\t\tskipBytes = 0\n+\t\t}\n+\t}\n+\tif n != len(p) {\n+\t\terr = io.ErrUnexpectedEOF\n+\t}\n+\treturn\n+}\n+\n+// Just testing the rleBuffer used in the Zip64 test above. Not used by the zip code.\n+func TestRLEBuffer(t *testing.T) {\n+\tb := new(rleBuffer)\n+\tvar all []byte\n+\twrites := []string{\"abcdeee\", \"eeeeeee\", \"eeeefghaaiii\"}\n+\tfor _, w := range writes {\n+\t\tb.Write([]byte(w))\n+\t\tall = append(all, w...)\n+\t}\n+\tif len(b.buf) != 10 {\n+\t\tt.Fatalf(\"len(b.buf) = %d; want 10\", len(b.buf))\n+\t}\n+\n+\tfor i := 0; i < len(all); i++ {\n+\t\tfor j := 0; j < len(all)-i; j++ {\n+\t\t\tbuf := make([]byte, j)\n+\t\t\tn, err := b.ReadAt(buf, int64(i))\n+\t\t\tif err != nil || n != len(buf) {\n+\t\t\t\tt.Errorf(\"ReadAt(%d, %d) = %d, %v; want %d, nil\", i, j, n, err, len(buf))\n+\t\t\t}\n+\t\t\tif !bytes.Equal(buf, all[i:i+j]) {\n+\t\t\t\tt.Errorf(\"ReadAt(%d, %d) = %q; want %q\", i, j, buf, all[i:i+j])\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// fakeHash32 is a dummy Hash32 that always returns 0.\n+type fakeHash32 struct {\n+\thash.Hash32\n+}\n+\n+func (fakeHash32) Write(p []byte) (int, error) { return len(p), nil }\n+func (fakeHash32) Sum32() uint32               { return 0 }\n+\n func TestZip64(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"slow test; skipping\")\n \t}\n+\tconst size = 1 << 32 // before the \"END\\n\" part\n+\ttestZip64(t, size)\n+}\n+\n+func testZip64(t testing.TB, size int64) {\n+\tconst chunkSize = 1024\n+\tchunks := int(size / chunkSize)\n \t// write 2^32 bytes plus \"END\\n\" to a zip file\n-\tbuf := new(bytes.Buffer)\n+\tbuf := new(rleBuffer)\n \tw := NewWriter(buf)\n-\tf, err := w.Create(\"huge.txt\")\n+\tf, err := w.CreateHeader(&FileHeader{\n+\t\tName:   \"huge.txt\",\n+\t\tMethod: Store,\n+\t})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tchunk := make([]byte, 1024)\n+\tf.(*fileWriter).crc32 = fakeHash32{}\n+\tchunk := make([]byte, chunkSize)\n \tfor i := range chunk {\n \t\tchunk[i] = '.'\n \t}\n-\tchunk[len(chunk)-1] = '\\n'\n-\tend := []byte(\"END\\n\")\n-\tfor i := 0; i < (1<<32)/1024; i++ {\n+\tfor i := 0; i < chunks; i++ {\n \t\t_, err := f.Write(chunk)\n \t\tif err != nil {\n \t\t\tt.Fatal(\"write chunk:\", err)\n \t\t}\n \t}\n+\tend := []byte(\"END\\n\")\n \t_, err = f.Write(end)\n \tif err != nil {\n \t\tt.Fatal(\"write end:\", err)\n@@ -137,7 +266,7 @@ func TestZip64(t *testing.T) {\n \t}\n \n \t// read back zip file and check that we get to the end of it\n-\tr, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))\n+\tr, err := NewReader(buf, int64(buf.Size()))\n \tif err != nil {\n \t\tt.Fatal(\"reader:\", err)\n \t}\n@@ -146,7 +275,8 @@ func TestZip64(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"opening:\", err)\n \t}\n-\tfor i := 0; i < (1<<32)/1024; i++ {\n+\trc.(*checksumReader).hash = fakeHash32{}\n+\tfor i := 0; i < chunks; i++ {\n \t\t_, err := io.ReadFull(rc, chunk)\n \t\tif err != nil {\n \t\t\tt.Fatal(\"read:\", err)\n@@ -163,11 +293,13 @@ func TestZip64(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"closing:\", err)\n \t}\n-\tif got, want := f0.UncompressedSize, uint32(uint32max); got != want {\n-\t\tt.Errorf(\"UncompressedSize %d, want %d\", got, want)\n+\tif size == 1<<32 {\n+\t\tif got, want := f0.UncompressedSize, uint32(uint32max); got != want {\n+\t\t\tt.Errorf(\"UncompressedSize %d, want %d\", got, want)\n+\t\t}\n \t}\n \n-\tif got, want := f0.UncompressedSize64, (1<<32)+uint64(len(end)); got != want {\n+\tif got, want := f0.UncompressedSize64, uint64(size)+uint64(len(end)); got != want {\n \t\tt.Errorf(\"UncompressedSize64 %d, want %d\", got, want)\n \t}\n }\n@@ -253,3 +385,11 @@ func TestZeroLengthHeader(t *testing.T) {\n \t}\n \ttestValidHeader(&h, t)\n }\n+\n+// Just benchmarking how fast the Zip64 test above is. Not related to\n+// our zip performance, since the test above disabled CRC32 and flate.\n+func BenchmarkZip64Test(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\ttestZip64(b, 1<<26)\n+\t}\n+}"}, {"sha": "d1ff3c9edc16dead49f6d860c71a1a55dc23b192", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 60, "deletions": 26, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -51,19 +51,31 @@ func NewReaderSize(rd io.Reader, size int) *Reader {\n \tif size < minReadBufferSize {\n \t\tsize = minReadBufferSize\n \t}\n-\treturn &Reader{\n-\t\tbuf:          make([]byte, size),\n-\t\trd:           rd,\n-\t\tlastByte:     -1,\n-\t\tlastRuneSize: -1,\n-\t}\n+\tr := new(Reader)\n+\tr.reset(make([]byte, size), rd)\n+\treturn r\n }\n \n // NewReader returns a new Reader whose buffer has the default size.\n func NewReader(rd io.Reader) *Reader {\n \treturn NewReaderSize(rd, defaultBufSize)\n }\n \n+// Reset discards any buffered data, resets all state, and switches\n+// the buffered reader to read from r.\n+func (b *Reader) Reset(r io.Reader) {\n+\tb.reset(b.buf, r)\n+}\n+\n+func (b *Reader) reset(buf []byte, r io.Reader) {\n+\t*b = Reader{\n+\t\tbuf:          buf,\n+\t\trd:           r,\n+\t\tlastByte:     -1,\n+\t\tlastRuneSize: -1,\n+\t}\n+}\n+\n var errNegativeRead = errors.New(\"bufio: reader returned negative count from Read\")\n \n // fill reads a new chunk into the buffer.\n@@ -234,7 +246,7 @@ func (b *Reader) Buffered() int { return b.w - b.r }\n \n // ReadSlice reads until the first occurrence of delim in the input,\n // returning a slice pointing at the bytes in the buffer.\n-// The bytes stop being valid at the next read call.\n+// The bytes stop being valid at the next read.\n // If ReadSlice encounters an error before finding a delimiter,\n // it returns all the data in the buffer and the error itself (often io.EOF).\n // ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.\n@@ -381,7 +393,8 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err error) {\n // For simple uses, a Scanner may be more convenient.\n func (b *Reader) ReadString(delim byte) (line string, err error) {\n \tbytes, err := b.ReadBytes(delim)\n-\treturn string(bytes), err\n+\tline = string(bytes)\n+\treturn line, err\n }\n \n // WriteTo implements io.WriterTo.\n@@ -424,6 +437,9 @@ func (b *Reader) writeBuf(w io.Writer) (int64, error) {\n // Writer implements buffering for an io.Writer object.\n // If an error occurs writing to a Writer, no more data will be\n // accepted and all subsequent writes will return the error.\n+// After all data has been written, the client should call the\n+// Flush method to guarantee all data has been forwarded to\n+// the underlying io.Writer.\n type Writer struct {\n \terr error\n \tbuf []byte\n@@ -434,28 +450,41 @@ type Writer struct {\n // NewWriterSize returns a new Writer whose buffer has at least the specified\n // size. If the argument io.Writer is already a Writer with large enough\n // size, it returns the underlying Writer.\n-func NewWriterSize(wr io.Writer, size int) *Writer {\n+func NewWriterSize(w io.Writer, size int) *Writer {\n \t// Is it already a Writer?\n-\tb, ok := wr.(*Writer)\n+\tb, ok := w.(*Writer)\n \tif ok && len(b.buf) >= size {\n \t\treturn b\n \t}\n \tif size <= 0 {\n \t\tsize = defaultBufSize\n \t}\n-\tb = new(Writer)\n-\tb.buf = make([]byte, size)\n-\tb.wr = wr\n-\treturn b\n+\treturn &Writer{\n+\t\tbuf: make([]byte, size),\n+\t\twr:  w,\n+\t}\n }\n \n // NewWriter returns a new Writer whose buffer has the default size.\n-func NewWriter(wr io.Writer) *Writer {\n-\treturn NewWriterSize(wr, defaultBufSize)\n+func NewWriter(w io.Writer) *Writer {\n+\treturn NewWriterSize(w, defaultBufSize)\n+}\n+\n+// Reset discards any unflushed buffered data, clears any error, and\n+// resets b to write its output to w.\n+func (b *Writer) Reset(w io.Writer) {\n+\tb.err = nil\n+\tb.n = 0\n+\tb.wr = w\n }\n \n // Flush writes any buffered data to the underlying io.Writer.\n func (b *Writer) Flush() error {\n+\terr := b.flush()\n+\treturn err\n+}\n+\n+func (b *Writer) flush() error {\n \tif b.err != nil {\n \t\treturn b.err\n \t}\n@@ -498,7 +527,7 @@ func (b *Writer) Write(p []byte) (nn int, err error) {\n \t\t} else {\n \t\t\tn = copy(b.buf[b.n:], p)\n \t\t\tb.n += n\n-\t\t\tb.Flush()\n+\t\t\tb.flush()\n \t\t}\n \t\tnn += n\n \t\tp = p[n:]\n@@ -517,7 +546,7 @@ func (b *Writer) WriteByte(c byte) error {\n \tif b.err != nil {\n \t\treturn b.err\n \t}\n-\tif b.Available() <= 0 && b.Flush() != nil {\n+\tif b.Available() <= 0 && b.flush() != nil {\n \t\treturn b.err\n \t}\n \tb.buf[b.n] = c\n@@ -540,7 +569,7 @@ func (b *Writer) WriteRune(r rune) (size int, err error) {\n \t}\n \tn := b.Available()\n \tif n < utf8.UTFMax {\n-\t\tif b.Flush(); b.err != nil {\n+\t\tif b.flush(); b.err != nil {\n \t\t\treturn 0, b.err\n \t\t}\n \t\tn = b.Available()\n@@ -565,7 +594,7 @@ func (b *Writer) WriteString(s string) (int, error) {\n \t\tb.n += n\n \t\tnn += n\n \t\ts = s[n:]\n-\t\tb.Flush()\n+\t\tb.flush()\n \t}\n \tif b.err != nil {\n \t\treturn nn, b.err\n@@ -585,23 +614,28 @@ func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\n \t}\n \tvar m int\n \tfor {\n+\t\tif b.Available() == 0 {\n+\t\t\tif err1 := b.flush(); err1 != nil {\n+\t\t\t\treturn n, err1\n+\t\t\t}\n+\t\t}\n \t\tm, err = r.Read(b.buf[b.n:])\n \t\tif m == 0 {\n \t\t\tbreak\n \t\t}\n \t\tb.n += m\n \t\tn += int64(m)\n-\t\tif b.Available() == 0 {\n-\t\t\tif err1 := b.Flush(); err1 != nil {\n-\t\t\t\treturn n, err1\n-\t\t\t}\n-\t\t}\n \t\tif err != nil {\n \t\t\tbreak\n \t\t}\n \t}\n \tif err == io.EOF {\n-\t\terr = nil\n+\t\t// If we filled the buffer exactly, flush pre-emptively.\n+\t\tif b.Available() == 0 {\n+\t\t\terr = b.flush()\n+\t\t} else {\n+\t\t\terr = nil\n+\t\t}\n \t}\n \treturn n, err\n }"}, {"sha": "41bd3d45633854c02d7041c0cec83b9a65f70cc4", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -847,6 +847,10 @@ func TestWriterReadFrom(t *testing.T) {\n \t\t\t\tt.Errorf(\"ws[%d],rs[%d]: w.ReadFrom(r) = %d, %v, want %d, nil\", wi, ri, n, err, len(input))\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tif err := w.Flush(); err != nil {\n+\t\t\t\tt.Errorf(\"Flush returned %v\", err)\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tif got, want := b.String(), string(input); got != want {\n \t\t\t\tt.Errorf(\"ws[%d], rs[%d]:\\ngot  %q\\nwant %q\\n\", wi, ri, got, want)\n \t\t\t}\n@@ -1003,6 +1007,56 @@ func TestReaderClearError(t *testing.T) {\n \t}\n }\n \n+// Test for golang.org/issue/5947\n+func TestWriterReadFromWhileFull(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\tw := NewWriterSize(buf, 10)\n+\n+\t// Fill buffer exactly.\n+\tn, err := w.Write([]byte(\"0123456789\"))\n+\tif n != 10 || err != nil {\n+\t\tt.Fatalf(\"Write returned (%v, %v), want (10, nil)\", n, err)\n+\t}\n+\n+\t// Use ReadFrom to read in some data.\n+\tn2, err := w.ReadFrom(strings.NewReader(\"abcdef\"))\n+\tif n2 != 6 || err != nil {\n+\t\tt.Fatalf(\"ReadFrom returned (%v, %v), want (6, nil)\", n, err)\n+\t}\n+}\n+\n+func TestReaderReset(t *testing.T) {\n+\tr := NewReader(strings.NewReader(\"foo foo\"))\n+\tbuf := make([]byte, 3)\n+\tr.Read(buf)\n+\tif string(buf) != \"foo\" {\n+\t\tt.Errorf(\"buf = %q; want foo\", buf)\n+\t}\n+\tr.Reset(strings.NewReader(\"bar bar\"))\n+\tall, err := ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(all) != \"bar bar\" {\n+\t\tt.Errorf(\"ReadAll = %q; want bar bar\", all)\n+\t}\n+}\n+\n+func TestWriterReset(t *testing.T) {\n+\tvar buf1, buf2 bytes.Buffer\n+\tw := NewWriter(&buf1)\n+\tw.WriteString(\"foo\")\n+\tw.Reset(&buf2) // and not flushed\n+\tw.WriteString(\"bar\")\n+\tw.Flush()\n+\tif buf1.String() != \"\" {\n+\t\tt.Errorf(\"buf1 = %q; want empty\", buf1.String())\n+\t}\n+\tif buf2.String() != \"bar\" {\n+\t\tt.Errorf(\"buf2 = %q; want bar\", buf2.String())\n+\t}\n+}\n+\n // An onlyReader only implements io.Reader, no matter what other methods the underlying implementation may have.\n type onlyReader struct {\n \tr io.Reader\n@@ -1083,3 +1137,46 @@ func BenchmarkWriterCopyNoReadFrom(b *testing.B) {\n \t\tio.Copy(dst, src)\n \t}\n }\n+\n+func BenchmarkReaderEmpty(b *testing.B) {\n+\tb.ReportAllocs()\n+\tstr := strings.Repeat(\"x\", 16<<10)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbr := NewReader(strings.NewReader(str))\n+\t\tn, err := io.Copy(ioutil.Discard, br)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t\tif n != int64(len(str)) {\n+\t\t\tb.Fatal(\"wrong length\")\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkWriterEmpty(b *testing.B) {\n+\tb.ReportAllocs()\n+\tstr := strings.Repeat(\"x\", 1<<10)\n+\tbs := []byte(str)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbw := NewWriter(ioutil.Discard)\n+\t\tbw.Flush()\n+\t\tbw.WriteByte('a')\n+\t\tbw.Flush()\n+\t\tbw.WriteRune('B')\n+\t\tbw.Flush()\n+\t\tbw.Write(bs)\n+\t\tbw.Flush()\n+\t\tbw.WriteString(str)\n+\t\tbw.Flush()\n+\t}\n+}\n+\n+func BenchmarkWriterFlush(b *testing.B) {\n+\tb.ReportAllocs()\n+\tbw := NewWriter(ioutil.Discard)\n+\tstr := strings.Repeat(\"x\", 50)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbw.WriteString(str)\n+\t\tbw.Flush()\n+\t}\n+}"}, {"sha": "3da914142194895ea37e660c621d3835fb251a86", "filename": "libgo/go/bufio/example_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbufio%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbufio%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fexample_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -12,6 +12,14 @@ import (\n \t\"strings\"\n )\n \n+func ExampleWriter() {\n+\tw := bufio.NewWriter(os.Stdout)\n+\tfmt.Fprint(w, \"Hello, \")\n+\tfmt.Fprint(w, \"world!\")\n+\tw.Flush() // Don't forget to flush!\n+\t// Output: Hello, world!\n+}\n+\n // The simplest use of a Scanner, to read standard input as a set of lines.\n func ExampleScanner_lines() {\n \tscanner := bufio.NewScanner(os.Stdin)"}, {"sha": "423505fbcbbb232219c4b927a024d92ebba44a7a", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -44,8 +44,8 @@ type Scanner struct {\n // to give. The return values are the number of bytes to advance the input\n // and the next token to return to the user, plus an error, if any. If the\n // data does not yet hold a complete token, for instance if it has no newline\n-// while scanning lines, SplitFunc can return (0, nil) to signal the Scanner\n-// to read more data into the slice and try again with a longer slice\n+// while scanning lines, SplitFunc can return (0, nil, nil) to signal the\n+// Scanner to read more data into the slice and try again with a longer slice\n // starting at the same point in the input.\n //\n // If the returned error is non-nil, scanning stops and the error\n@@ -287,7 +287,7 @@ func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error) {\n \treturn 0, nil, nil\n }\n \n-// isSpace returns whether the character is a Unicode white space character.\n+// isSpace reports whether the character is a Unicode white space character.\n // We avoid dependency on the unicode package, but check validity of the implementation\n // in the tests.\n func isSpace(r rune) bool {"}, {"sha": "51550a459cb69788d5b9060b4cb69a8d82ccb6df", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -236,6 +236,19 @@ func panic(v interface{})\n // panicking.\n func recover() interface{}\n \n+// The print built-in function formats its arguments in an implementation-\n+// specific way and writes the result to standard error.\n+// Print is useful for bootstrapping and debugging; it is not guaranteed\n+// to stay in the language.\n+func print(args ...Type)\n+\n+// The println built-in function formats its arguments in an implementation-\n+// specific way and writes the result to standard error.\n+// Spaces are always added between arguments and a newline is appended.\n+// Println is useful for bootstrapping and debugging; it is not guaranteed\n+// to stay in the language.\n+func println(args ...Type)\n+\n // The error built-in interface type is the conventional interface for\n // representing an error condition, with the nil value representing no error.\n type error interface {"}, {"sha": "01a5d9ae4ecaa7d5622efd2c4c8ff36beaf8807b", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -11,32 +11,6 @@ import (\n \t\"unicode/utf8\"\n )\n \n-// Compare returns an integer comparing two byte slices lexicographically.\n-// The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n-// A nil argument is equivalent to an empty slice.\n-func Compare(a, b []byte) int {\n-\tm := len(a)\n-\tif m > len(b) {\n-\t\tm = len(b)\n-\t}\n-\tfor i, ac := range a[0:m] {\n-\t\tbc := b[i]\n-\t\tswitch {\n-\t\tcase ac > bc:\n-\t\t\treturn 1\n-\t\tcase ac < bc:\n-\t\t\treturn -1\n-\t\t}\n-\t}\n-\tswitch {\n-\tcase len(a) < len(b):\n-\t\treturn -1\n-\tcase len(a) > len(b):\n-\t\treturn 1\n-\t}\n-\treturn 0\n-}\n-\n func equalPortable(a, b []byte) bool {\n \tif len(a) != len(b) {\n \t\treturn false\n@@ -103,7 +77,7 @@ func Count(s, sep []byte) int {\n \treturn count\n }\n \n-// Contains returns whether subslice is within b.\n+// Contains reports whether subslice is within b.\n func Contains(b, subslice []byte) bool {\n \treturn Index(b, subslice) != -1\n }\n@@ -401,10 +375,7 @@ func Repeat(b []byte, count int) []byte {\n \tnb := make([]byte, len(b)*count)\n \tbp := 0\n \tfor i := 0; i < count; i++ {\n-\t\tfor j := 0; j < len(b); j++ {\n-\t\t\tnb[bp] = b[j]\n-\t\t\tbp++\n-\t\t}\n+\t\tbp += copy(nb[bp:], b)\n \t}\n \treturn nb\n }"}, {"sha": "617d7489a6a835124748b5820a1fd6dcd2fdc6ca", "filename": "libgo/go/bytes/bytes_decl.go", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_decl.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -7,10 +7,18 @@ package bytes\n //go:noescape\n \n // IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n-func IndexByte(s []byte, c byte) int // asm_$GOARCH.s\n+func IndexByte(s []byte, c byte) int // ../runtime/asm_$GOARCH.s\n \n //go:noescape\n \n-// Equal returns a boolean reporting whether a == b.\n+// Equal returns a boolean reporting whether a and b\n+// are the same length and contain the same bytes.\n // A nil argument is equivalent to an empty slice.\n-func Equal(a, b []byte) bool // asm_arm.s or ../runtime/asm_{386,amd64}.s\n+func Equal(a, b []byte) bool // ../runtime/asm_$GOARCH.s\n+\n+//go:noescape\n+\n+// Compare returns an integer comparing two byte slices lexicographically.\n+// The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n+// A nil argument is equivalent to an empty slice.\n+func Compare(a, b []byte) int // ../runtime/noasm_arm.goc or ../runtime/asm_{386,amd64}.s"}, {"sha": "ab5da4fbf08b8705fa7622ac423c0721af0390e9", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -47,7 +47,7 @@ type BinOpTest struct {\n \ti int\n }\n \n-var compareTests = []struct {\n+var equalTests = []struct {\n \ta, b []byte\n \ti    int\n }{\n@@ -73,12 +73,8 @@ var compareTests = []struct {\n \t{nil, []byte(\"a\"), -1},\n }\n \n-func TestCompare(t *testing.T) {\n+func TestEqual(t *testing.T) {\n \tfor _, tt := range compareTests {\n-\t\tcmp := Compare(tt.a, tt.b)\n-\t\tif cmp != tt.i {\n-\t\t\tt.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp)\n-\t\t}\n \t\teql := Equal(tt.a, tt.b)\n \t\tif eql != (tt.i == 0) {\n \t\t\tt.Errorf(`Equal(%q, %q) = %v`, tt.a, tt.b, eql)\n@@ -90,7 +86,7 @@ func TestCompare(t *testing.T) {\n \t}\n }\n \n-func TestEqual(t *testing.T) {\n+func TestEqualExhaustive(t *testing.T) {\n \tvar size = 128\n \tif testing.Short() {\n \t\tsize = 32\n@@ -147,6 +143,7 @@ var indexTests = []BinOpTest{\n \t{\"\", \"a\", -1},\n \t{\"\", \"foo\", -1},\n \t{\"fo\", \"foo\", -1},\n+\t{\"foo\", \"baz\", -1},\n \t{\"foo\", \"foo\", 0},\n \t{\"oofofoofooo\", \"f\", 2},\n \t{\"oofofoofooo\", \"foo\", 4},\n@@ -1086,6 +1083,24 @@ func TestTitle(t *testing.T) {\n \t}\n }\n \n+var ToTitleTests = []TitleTest{\n+\t{\"\", \"\"},\n+\t{\"a\", \"A\"},\n+\t{\" aaa aaa aaa \", \" AAA AAA AAA \"},\n+\t{\" Aaa Aaa Aaa \", \" AAA AAA AAA \"},\n+\t{\"123a456\", \"123A456\"},\n+\t{\"double-blind\", \"DOUBLE-BLIND\"},\n+\t{\"\u00ff\u00f8\u00fb\", \"\u0178\u00d8\u00db\"},\n+}\n+\n+func TestToTitle(t *testing.T) {\n+\tfor _, tt := range ToTitleTests {\n+\t\tif s := string(ToTitle([]byte(tt.in))); s != tt.out {\n+\t\t\tt.Errorf(\"ToTitle(%q) = %q, want %q\", tt.in, s, tt.out)\n+\t\t}\n+\t}\n+}\n+\n var EqualFoldTests = []struct {\n \ts, t string\n \tout  bool\n@@ -1114,6 +1129,37 @@ func TestEqualFold(t *testing.T) {\n \t}\n }\n \n+func TestBufferGrowNegative(t *testing.T) {\n+\tdefer func() {\n+\t\tif err := recover(); err == nil {\n+\t\t\tt.Fatal(\"Grow(-1) should have paniced\")\n+\t\t}\n+\t}()\n+\tvar b Buffer\n+\tb.Grow(-1)\n+}\n+\n+func TestBufferTruncateNegative(t *testing.T) {\n+\tdefer func() {\n+\t\tif err := recover(); err == nil {\n+\t\t\tt.Fatal(\"Truncate(-1) should have paniced\")\n+\t\t}\n+\t}()\n+\tvar b Buffer\n+\tb.Truncate(-1)\n+}\n+\n+func TestBufferTruncateOutOfRange(t *testing.T) {\n+\tdefer func() {\n+\t\tif err := recover(); err == nil {\n+\t\t\tt.Fatal(\"Truncate(20) should have paniced\")\n+\t\t}\n+\t}()\n+\tvar b Buffer\n+\tb.Write(make([]byte, 10))\n+\tb.Truncate(20)\n+}\n+\n var makeFieldsInput = func() []byte {\n \tx := make([]byte, 1<<20)\n \t// Input is ~10% space, ~10% 2-byte UTF-8, rest ASCII non-space."}, {"sha": "0a36f5ad39be6a1da630e394b65c2e3c6ee08bf7", "filename": "libgo/go/bytes/compare_test.go", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fcompare_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -0,0 +1,204 @@\n+package bytes_test\n+\n+import (\n+\t. \"bytes\"\n+\t\"testing\"\n+)\n+\n+var compareTests = []struct {\n+\ta, b []byte\n+\ti    int\n+}{\n+\t{[]byte(\"\"), []byte(\"\"), 0},\n+\t{[]byte(\"a\"), []byte(\"\"), 1},\n+\t{[]byte(\"\"), []byte(\"a\"), -1},\n+\t{[]byte(\"abc\"), []byte(\"abc\"), 0},\n+\t{[]byte(\"ab\"), []byte(\"abc\"), -1},\n+\t{[]byte(\"abc\"), []byte(\"ab\"), 1},\n+\t{[]byte(\"x\"), []byte(\"ab\"), 1},\n+\t{[]byte(\"ab\"), []byte(\"x\"), -1},\n+\t{[]byte(\"x\"), []byte(\"a\"), 1},\n+\t{[]byte(\"b\"), []byte(\"x\"), -1},\n+\t// test runtime\u00b7memeq's chunked implementation\n+\t{[]byte(\"abcdefgh\"), []byte(\"abcdefgh\"), 0},\n+\t{[]byte(\"abcdefghi\"), []byte(\"abcdefghi\"), 0},\n+\t{[]byte(\"abcdefghi\"), []byte(\"abcdefghj\"), -1},\n+\t// nil tests\n+\t{nil, nil, 0},\n+\t{[]byte(\"\"), nil, 0},\n+\t{nil, []byte(\"\"), 0},\n+\t{[]byte(\"a\"), nil, 1},\n+\t{nil, []byte(\"a\"), -1},\n+}\n+\n+func TestCompare(t *testing.T) {\n+\tfor _, tt := range compareTests {\n+\t\tcmp := Compare(tt.a, tt.b)\n+\t\tif cmp != tt.i {\n+\t\t\tt.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp)\n+\t\t}\n+\t}\n+}\n+\n+func TestCompareIdenticalSlice(t *testing.T) {\n+\tvar b = []byte(\"Hello Gophers!\")\n+\tif Compare(b, b) != 0 {\n+\t\tt.Error(\"b != b\")\n+\t}\n+\tif Compare(b, b[:1]) != 1 {\n+\t\tt.Error(\"b > b[:1] failed\")\n+\t}\n+}\n+\n+func TestCompareBytes(t *testing.T) {\n+\tn := 128\n+\ta := make([]byte, n+1)\n+\tb := make([]byte, n+1)\n+\tfor len := 0; len < 128; len++ {\n+\t\t// randomish but deterministic data.  No 0 or 255.\n+\t\tfor i := 0; i < len; i++ {\n+\t\t\ta[i] = byte(1 + 31*i%254)\n+\t\t\tb[i] = byte(1 + 31*i%254)\n+\t\t}\n+\t\t// data past the end is different\n+\t\tfor i := len; i <= n; i++ {\n+\t\t\ta[i] = 8\n+\t\t\tb[i] = 9\n+\t\t}\n+\t\tcmp := Compare(a[:len], b[:len])\n+\t\tif cmp != 0 {\n+\t\t\tt.Errorf(`CompareIdentical(%d) = %d`, len, cmp)\n+\t\t}\n+\t\tif len > 0 {\n+\t\t\tcmp = Compare(a[:len-1], b[:len])\n+\t\t\tif cmp != -1 {\n+\t\t\t\tt.Errorf(`CompareAshorter(%d) = %d`, len, cmp)\n+\t\t\t}\n+\t\t\tcmp = Compare(a[:len], b[:len-1])\n+\t\t\tif cmp != 1 {\n+\t\t\t\tt.Errorf(`CompareBshorter(%d) = %d`, len, cmp)\n+\t\t\t}\n+\t\t}\n+\t\tfor k := 0; k < len; k++ {\n+\t\t\tb[k] = a[k] - 1\n+\t\t\tcmp = Compare(a[:len], b[:len])\n+\t\t\tif cmp != 1 {\n+\t\t\t\tt.Errorf(`CompareAbigger(%d,%d) = %d`, len, k, cmp)\n+\t\t\t}\n+\t\t\tb[k] = a[k] + 1\n+\t\t\tcmp = Compare(a[:len], b[:len])\n+\t\t\tif cmp != -1 {\n+\t\t\t\tt.Errorf(`CompareBbigger(%d,%d) = %d`, len, k, cmp)\n+\t\t\t}\n+\t\t\tb[k] = a[k]\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkCompareBytesEqual(b *testing.B) {\n+\tb1 := []byte(\"Hello Gophers!\")\n+\tb2 := []byte(\"Hello Gophers!\")\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2) != 0 {\n+\t\t\tb.Fatal(\"b1 != b2\")\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkCompareBytesToNil(b *testing.B) {\n+\tb1 := []byte(\"Hello Gophers!\")\n+\tvar b2 []byte\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2) != 1 {\n+\t\t\tb.Fatal(\"b1 > b2 failed\")\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkCompareBytesEmpty(b *testing.B) {\n+\tb1 := []byte(\"\")\n+\tb2 := b1\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2) != 0 {\n+\t\t\tb.Fatal(\"b1 != b2\")\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkCompareBytesIdentical(b *testing.B) {\n+\tb1 := []byte(\"Hello Gophers!\")\n+\tb2 := b1\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2) != 0 {\n+\t\t\tb.Fatal(\"b1 != b2\")\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkCompareBytesSameLength(b *testing.B) {\n+\tb1 := []byte(\"Hello Gophers!\")\n+\tb2 := []byte(\"Hello, Gophers\")\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2) != -1 {\n+\t\t\tb.Fatal(\"b1 < b2 failed\")\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkCompareBytesDifferentLength(b *testing.B) {\n+\tb1 := []byte(\"Hello Gophers!\")\n+\tb2 := []byte(\"Hello, Gophers!\")\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2) != -1 {\n+\t\t\tb.Fatal(\"b1 < b2 failed\")\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkCompareBytesBigUnaligned(b *testing.B) {\n+\tb.StopTimer()\n+\tb1 := make([]byte, 0, 1<<20)\n+\tfor len(b1) < 1<<20 {\n+\t\tb1 = append(b1, \"Hello Gophers!\"...)\n+\t}\n+\tb2 := append([]byte(\"hello\"), b1...)\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2[len(\"hello\"):]) != 0 {\n+\t\t\tb.Fatal(\"b1 != b2\")\n+\t\t}\n+\t}\n+\tb.SetBytes(int64(len(b1)))\n+}\n+\n+func BenchmarkCompareBytesBig(b *testing.B) {\n+\tb.StopTimer()\n+\tb1 := make([]byte, 0, 1<<20)\n+\tfor len(b1) < 1<<20 {\n+\t\tb1 = append(b1, \"Hello Gophers!\"...)\n+\t}\n+\tb2 := append([]byte{}, b1...)\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2) != 0 {\n+\t\t\tb.Fatal(\"b1 != b2\")\n+\t\t}\n+\t}\n+\tb.SetBytes(int64(len(b1)))\n+}\n+\n+func BenchmarkCompareBytesBigIdentical(b *testing.B) {\n+\tb.StopTimer()\n+\tb1 := make([]byte, 0, 1<<20)\n+\tfor len(b1) < 1<<20 {\n+\t\tb1 = append(b1, \"Hello Gophers!\"...)\n+\t}\n+\tb2 := b1\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif Compare(b1, b2) != 0 {\n+\t\t\tb.Fatal(\"b1 != b2\")\n+\t\t}\n+\t}\n+\tb.SetBytes(int64(len(b1)))\n+}"}, {"sha": "b248108e404a5dec4e19a730d50a272bbeafdff5", "filename": "libgo/go/bytes/indexbyte.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Findexbyte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Findexbyte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Findexbyte.c?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -41,3 +41,33 @@ Equal (struct __go_open_array a, struct __go_open_array b)\n     return 0;\n   return __builtin_memcmp (a.__values, b.__values, a.__count) == 0;\n }\n+\n+intgo Compare (struct __go_open_array a, struct __go_open_array b)\n+  __asm__ (GOSYM_PREFIX \"bytes.Compare\")\n+  __attribute__ ((no_split_stack));\n+\n+intgo\n+Compare (struct __go_open_array a, struct __go_open_array b)\n+{\n+  intgo len;\n+\n+  len = a.__count;\n+  if (len > b.__count)\n+    len = b.__count;\n+  if (len > 0)\n+    {\n+      intgo ret;\n+\n+      ret = __builtin_memcmp (a.__values, b.__values, len);\n+      if (ret < 0)\n+\treturn -1;\n+      else if (ret > 0)\n+\treturn 1;\n+    }\n+  if (a.__count < b.__count)\n+    return -1;\n+  else if (a.__count > b.__count)\n+    return 1;\n+  else\n+    return 0;\n+}"}, {"sha": "19f014da030aa4162ad0b4efa1658aecbe167b71", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -113,6 +113,41 @@ func TestReaderWriteTo(t *testing.T) {\n \t}\n }\n \n+func TestReaderLen(t *testing.T) {\n+\tconst data = \"hello world\"\n+\tr := NewReader([]byte(data))\n+\tif got, want := r.Len(), 11; got != want {\n+\t\tt.Errorf(\"r.Len(): got %d, want %d\", got, want)\n+\t}\n+\tif n, err := r.Read(make([]byte, 10)); err != nil || n != 10 {\n+\t\tt.Errorf(\"Read failed: read %d %v\", n, err)\n+\t}\n+\tif got, want := r.Len(), 1; got != want {\n+\t\tt.Errorf(\"r.Len(): got %d, want %d\", got, want)\n+\t}\n+\tif n, err := r.Read(make([]byte, 1)); err != nil || n != 1 {\n+\t\tt.Errorf(\"Read failed: read %d %v\", n, err)\n+\t}\n+\tif got, want := r.Len(), 0; got != want {\n+\t\tt.Errorf(\"r.Len(): got %d, want %d\", got, want)\n+\t}\n+}\n+\n+func TestReaderDoubleUnreadRune(t *testing.T) {\n+\tbuf := NewBuffer([]byte(\"groucho\"))\n+\tif _, _, err := buf.ReadRune(); err != nil {\n+\t\t// should not happen\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := buf.UnreadByte(); err != nil {\n+\t\t// should not happen\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := buf.UnreadByte(); err == nil {\n+\t\tt.Fatal(\"UnreadByte: expected error, got nil\")\n+\t}\n+}\n+\n // verify that copying from an empty reader always has the same results,\n // regardless of the presence of a WriteTo method.\n func TestReaderCopyNothing(t *testing.T) {"}, {"sha": "32d1036ae1b759df5f4094e5641867e1b8555038", "filename": "libgo/go/compress/bzip2/bit_reader.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -77,6 +77,14 @@ func (br *bitReader) ReadBit() bool {\n \treturn n != 0\n }\n \n+func (br *bitReader) TryReadBit() (bit byte, ok bool) {\n+\tif br.bits > 0 {\n+\t\tbr.bits--\n+\t\treturn byte(br.n>>br.bits) & 1, true\n+\t}\n+\treturn 0, false\n+}\n+\n func (br *bitReader) Err() error {\n \treturn br.err\n }"}, {"sha": "82e30c7c9d70d484265d7a69cc0e606cb8a4103d", "filename": "libgo/go/compress/bzip2/bzip2.go", "status": "modified", "additions": 132, "deletions": 35, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -22,14 +22,17 @@ func (s StructuralError) Error() string {\n \n // A reader decompresses bzip2 compressed data.\n type reader struct {\n-\tbr        bitReader\n-\tsetupDone bool // true if we have parsed the bzip2 header.\n-\tblockSize int  // blockSize in bytes, i.e. 900 * 1024.\n-\teof       bool\n-\tbuf       []byte    // stores Burrows-Wheeler transformed data.\n-\tc         [256]uint // the `C' array for the inverse BWT.\n-\ttt        []uint32  // mirrors the `tt' array in the bzip2 source and contains the P array in the upper 24 bits.\n-\ttPos      uint32    // Index of the next output byte in tt.\n+\tbr           bitReader\n+\tfileCRC      uint32\n+\tblockCRC     uint32\n+\twantBlockCRC uint32\n+\tsetupDone    bool // true if we have parsed the bzip2 header.\n+\tblockSize    int  // blockSize in bytes, i.e. 900 * 1024.\n+\teof          bool\n+\tbuf          []byte    // stores Burrows-Wheeler transformed data.\n+\tc            [256]uint // the `C' array for the inverse BWT.\n+\ttt           []uint32  // mirrors the `tt' array in the bzip2 source and contains the P array in the upper 24 bits.\n+\ttPos         uint32    // Index of the next output byte in tt.\n \n \tpreRLE      []uint32 // contains the RLE data still to be processed.\n \tpreRLEUsed  int      // number of entries of preRLE used.\n@@ -50,12 +53,14 @@ const bzip2BlockMagic = 0x314159265359\n const bzip2FinalMagic = 0x177245385090\n \n // setup parses the bzip2 header.\n-func (bz2 *reader) setup() error {\n+func (bz2 *reader) setup(needMagic bool) error {\n \tbr := &bz2.br\n \n-\tmagic := br.ReadBits(16)\n-\tif magic != bzip2FileMagic {\n-\t\treturn StructuralError(\"bad magic value\")\n+\tif needMagic {\n+\t\tmagic := br.ReadBits(16)\n+\t\tif magic != bzip2FileMagic {\n+\t\t\treturn StructuralError(\"bad magic value\")\n+\t\t}\n \t}\n \n \tt := br.ReadBits(8)\n@@ -68,8 +73,11 @@ func (bz2 *reader) setup() error {\n \t\treturn StructuralError(\"invalid compression level\")\n \t}\n \n+\tbz2.fileCRC = 0\n \tbz2.blockSize = 100 * 1024 * (int(level) - '0')\n-\tbz2.tt = make([]uint32, bz2.blockSize)\n+\tif bz2.blockSize > len(bz2.tt) {\n+\t\tbz2.tt = make([]uint32, bz2.blockSize)\n+\t}\n \treturn nil\n }\n \n@@ -79,7 +87,7 @@ func (bz2 *reader) Read(buf []byte) (n int, err error) {\n \t}\n \n \tif !bz2.setupDone {\n-\t\terr = bz2.setup()\n+\t\terr = bz2.setup(true)\n \t\tbrErr := bz2.br.Err()\n \t\tif brErr != nil {\n \t\t\terr = brErr\n@@ -98,14 +106,14 @@ func (bz2 *reader) Read(buf []byte) (n int, err error) {\n \treturn\n }\n \n-func (bz2 *reader) read(buf []byte) (n int, err error) {\n+func (bz2 *reader) readFromBlock(buf []byte) int {\n \t// bzip2 is a block based compressor, except that it has a run-length\n \t// preprocessing step. The block based nature means that we can\n \t// preallocate fixed-size buffers and reuse them. However, the RLE\n \t// preprocessing would require allocating huge buffers to store the\n \t// maximum expansion. Thus we process blocks all at once, except for\n \t// the RLE which we decompress as required.\n-\n+\tn := 0\n \tfor (bz2.repeats > 0 || bz2.preRLEUsed < len(bz2.preRLE)) && n < len(buf) {\n \t\t// We have RLE data pending.\n \n@@ -148,34 +156,87 @@ func (bz2 *reader) read(buf []byte) (n int, err error) {\n \t\tn++\n \t}\n \n-\tif n > 0 {\n-\t\treturn\n-\t}\n+\treturn n\n+}\n \n-\t// No RLE data is pending so we need to read a block.\n+func (bz2 *reader) read(buf []byte) (int, error) {\n+\tfor {\n+\t\tn := bz2.readFromBlock(buf)\n+\t\tif n > 0 {\n+\t\t\tbz2.blockCRC = updateCRC(bz2.blockCRC, buf[:n])\n+\t\t\treturn n, nil\n+\t\t}\n \n-\tbr := &bz2.br\n-\tmagic := br.ReadBits64(48)\n-\tif magic == bzip2FinalMagic {\n-\t\tbr.ReadBits64(32) // ignored CRC\n-\t\tbz2.eof = true\n-\t\treturn 0, io.EOF\n-\t} else if magic != bzip2BlockMagic {\n-\t\treturn 0, StructuralError(\"bad magic value found\")\n-\t}\n+\t\t// End of block. Check CRC.\n+\t\tif bz2.blockCRC != bz2.wantBlockCRC {\n+\t\t\tbz2.br.err = StructuralError(\"block checksum mismatch\")\n+\t\t\treturn 0, bz2.br.err\n+\t\t}\n \n-\terr = bz2.readBlock()\n-\tif err != nil {\n-\t\treturn 0, err\n-\t}\n+\t\t// Find next block.\n+\t\tbr := &bz2.br\n+\t\tswitch br.ReadBits64(48) {\n+\t\tdefault:\n+\t\t\treturn 0, StructuralError(\"bad magic value found\")\n+\n+\t\tcase bzip2BlockMagic:\n+\t\t\t// Start of block.\n+\t\t\terr := bz2.readBlock()\n+\t\t\tif err != nil {\n+\t\t\t\treturn 0, err\n+\t\t\t}\n \n-\treturn bz2.read(buf)\n+\t\tcase bzip2FinalMagic:\n+\t\t\t// Check end-of-file CRC.\n+\t\t\twantFileCRC := uint32(br.ReadBits64(32))\n+\t\t\tif br.err != nil {\n+\t\t\t\treturn 0, br.err\n+\t\t\t}\n+\t\t\tif bz2.fileCRC != wantFileCRC {\n+\t\t\t\tbr.err = StructuralError(\"file checksum mismatch\")\n+\t\t\t\treturn 0, br.err\n+\t\t\t}\n+\n+\t\t\t// Skip ahead to byte boundary.\n+\t\t\t// Is there a file concatenated to this one?\n+\t\t\t// It would start with BZ.\n+\t\t\tif br.bits%8 != 0 {\n+\t\t\t\tbr.ReadBits(br.bits % 8)\n+\t\t\t}\n+\t\t\tb, err := br.r.ReadByte()\n+\t\t\tif err == io.EOF {\n+\t\t\t\tbr.err = io.EOF\n+\t\t\t\tbz2.eof = true\n+\t\t\t\treturn 0, io.EOF\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tbr.err = err\n+\t\t\t\treturn 0, err\n+\t\t\t}\n+\t\t\tz, err := br.r.ReadByte()\n+\t\t\tif err != nil {\n+\t\t\t\tif err == io.EOF {\n+\t\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\t\t}\n+\t\t\t\tbr.err = err\n+\t\t\t\treturn 0, err\n+\t\t\t}\n+\t\t\tif b != 'B' || z != 'Z' {\n+\t\t\t\treturn 0, StructuralError(\"bad magic value in continuation file\")\n+\t\t\t}\n+\t\t\tif err := bz2.setup(false); err != nil {\n+\t\t\t\treturn 0, err\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n // readBlock reads a bzip2 block. The magic number should already have been consumed.\n func (bz2 *reader) readBlock() (err error) {\n \tbr := &bz2.br\n-\tbr.ReadBits64(32) // skip checksum. TODO: check it if we can figure out what it is.\n+\tbz2.wantBlockCRC = uint32(br.ReadBits64(32)) // skip checksum. TODO: check it if we can figure out what it is.\n+\tbz2.blockCRC = 0\n+\tbz2.fileCRC = (bz2.fileCRC<<1 | bz2.fileCRC>>31) ^ bz2.wantBlockCRC\n \trandomized := br.ReadBits(1)\n \tif randomized != 0 {\n \t\treturn StructuralError(\"deprecated randomized files\")\n@@ -316,6 +377,9 @@ func (bz2 *reader) readBlock() (err error) {\n \t\tif repeat > 0 {\n \t\t\t// We have decoded a complete run-length so we need to\n \t\t\t// replicate the last output symbol.\n+\t\t\tif repeat > bz2.blockSize-bufIndex {\n+\t\t\t\treturn StructuralError(\"repeats past end of block\")\n+\t\t\t}\n \t\t\tfor i := 0; i < repeat; i++ {\n \t\t\t\tb := byte(mtf.First())\n \t\t\t\tbz2.tt[bufIndex] = uint32(b)\n@@ -339,6 +403,9 @@ func (bz2 *reader) readBlock() (err error) {\n \t\t// doesn't need to be encoded and we have |v-1| in the next\n \t\t// line.\n \t\tb := byte(mtf.Decode(int(v - 1)))\n+\t\tif bufIndex >= bz2.blockSize {\n+\t\t\treturn StructuralError(\"data exceeds block size\")\n+\t\t}\n \t\tbz2.tt[bufIndex] = uint32(b)\n \t\tbz2.c[b]++\n \t\tbufIndex++\n@@ -385,3 +452,33 @@ func inverseBWT(tt []uint32, origPtr uint, c []uint) uint32 {\n \n \treturn tt[origPtr] >> 8\n }\n+\n+// This is a standard CRC32 like in hash/crc32 except that all the shifts are reversed,\n+// causing the bits in the input to be processed in the reverse of the usual order.\n+\n+var crctab [256]uint32\n+\n+func init() {\n+\tconst poly = 0x04C11DB7\n+\tfor i := range crctab {\n+\t\tcrc := uint32(i) << 24\n+\t\tfor j := 0; j < 8; j++ {\n+\t\t\tif crc&0x80000000 != 0 {\n+\t\t\t\tcrc = (crc << 1) ^ poly\n+\t\t\t} else {\n+\t\t\t\tcrc <<= 1\n+\t\t\t}\n+\t\t}\n+\t\tcrctab[i] = crc\n+\t}\n+}\n+\n+// updateCRC updates the crc value to incorporate the data in b.\n+// The initial value is 0.\n+func updateCRC(val uint32, b []byte) uint32 {\n+\tcrc := ^val\n+\tfor _, v := range b {\n+\t\tcrc = crctab[byte(crc>>24)^v] ^ (crc << 8)\n+\t}\n+\treturn ^crc\n+}"}, {"sha": "ada1f9a001636ff977061007ae452350db047496", "filename": "libgo/go/compress/bzip2/bzip2_test.go", "status": "modified", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,6 +6,7 @@ package bzip2\n \n import (\n \t\"bytes\"\n+\t\"encoding/base64\"\n \t\"encoding/hex\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -62,6 +63,19 @@ func TestHelloWorldBZ2(t *testing.T) {\n \t}\n }\n \n+func TestConcat(t *testing.T) {\n+\tout, err := decompressHex(helloWorldBZ2Hex + helloWorldBZ2Hex)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Read: %s\", err)\n+\t\treturn\n+\t}\n+\n+\thello2 := bytes.Repeat(helloWorld, 2)\n+\tif !bytes.Equal(hello2, out) {\n+\t\tt.Errorf(\"got %x, want %x\", out, hello2)\n+\t}\n+}\n+\n func testZeros(t *testing.T, inHex string, n int) {\n \tout, err := decompressHex(inHex)\n \tif err != nil {\n@@ -155,3 +169,195 @@ const rand2Hex = \"92d5652616ac444a4a04af1a8a3964aca0450d43d6cf233bd03233f4ba92f8\n \n const rand3BZ2Hex = \"425a68393141592653593be669d00000327ffffffffffffffffffffffffffffffffffff7ffffffffffffffffffffffffffffffc002b3b2b1b6e2bae400004c00132300004c0d268c004c08c0130026001a008683234c0684c34008c230261a04c0260064d07a8d00034000d27a1268c9931a8d327a3427a41faa69ea0da264c1a34219326869b51b49a6469a3268c689fa53269a62794687a9a68f5189994c9e487a8f534fd49a3d34043629e8c93d04da4f4648d30d4f44d3234c4d3023d0840680984d309934c234d3131a000640984f536a6132601300130130c8d00d04d1841ea7a8d31a02609b40023460010c01a34d4c1a0d04d3069306810034d0d0d4c0046130d034d0131a9a64d321804c68003400098344c13000991808c0001a00000000098004d3d4da4604c47a13012140aadf8d673c922c607ef6212a8c0403adea4b28aee578900e653b9cdeb8d11e6b838815f3ebaad5a01c5408d84a332170aff8734d4e06612d3c2889f31925fb89e33561f5100ae89b1f7047102e729373d3667e58d73aaa80fa7be368a1cc2dadd81d81ec8e1b504bd772ca31d03649269b01ceddaca07bf3d4eba24de141be3f86f93601e03714c0f64654671684f9f9528626fd4e1b76753dc0c54b842486b8d59d8ab314e86ca818e7a1f079463cbbd70d9b79b283c7edc419406311022e4be98c2c1374df9cdde2d008ce1d00e5f06ad1024baf555631f70831fc1023034e62be7c4bcb648caf276963ffa20e96bb50377fe1c113da0db4625b50741c35a058edb009c6ee5dbf93b8a6b060eec568180e8db791b82aab96cbf4326ca98361461379425ba8dcc347be670bdba7641883e5526ae3d833f6e9cb9bac9557747c79e206151072f7f0071dff3880411846f66bf4075c7462f302b53cb3400a74cf35652ad5641ed33572fd54e7ed7f85f58a0acba89327e7c6be5c58cb71528b99df2431f1d0358f8d28d81d95292da631fb06701decabb205fac59ff0fb1df536afc681eece6ea658c4d9eaa45f1342aa1ff70bdaff2ddaf25ec88c22f12829a0553db1ec2505554cb17d7b282e213a5a2aa30431ded2bce665bb199d023840832fedb2c0c350a27291407ff77440792872137df281592e82076a05c64c345ffb058c64f7f7c207ef78420b7010520610f17e302cc4dfcfaef72a0ed091aab4b541eb0531bbe941ca2f792bf7b31ca6162882b68054a8470115bc2c19f2df2023f7800432b39b04d3a304e8085ba3f1f0ca5b1ba4d38d339e6084de979cdea6d0e244c6c9fa0366bd890621e3d30846f5e8497e21597b8f29bbf52c961a485dfbea647600da0fc1f25ce4d203a8352ece310c39073525044e7ac46acf2ed9120bae1b4f6f02364abfe343f80b290983160c103557af1c68416480d024cc31b6c06cfec011456f1e95c420a12b48b1c3fe220c2879a982fb099948ac440db844b9a112a5188c7783fd3b19593290785f908d95c9db4b280bafe89c1313aeec24772046d9bc089645f0d182a21184e143823c5f52de50e5d7e98d3d7ab56f5413bbccd1415c9bcff707def475b643fb7f29842582104d4cc1dbaaca8f10a2f44273c339e0984f2b1e06ab2f0771db01fafa8142298345f3196f23e5847bda024034b6f59b11c29e981c881456e40d211929fd4f766200258aad8212016322bd5c605790dcfdf1bd2a93d99c9b8f498722d311d7eae7ff420496a31804c55f4759a7b13aaaf5f7ce006c3a8a998897d5e0a504398c2b627852545baf440798bcc5cc049357cf3f17d9771e4528a1af3d77dc794a11346e1bdf5efe37a405b127b4c43b616d61fbc5dc914e14240ef99a7400\"\n const rand3Hex = \"1744b384d68c042371244e13500d4bfb98c6244e3d71a5b700224420b59c593553f33bd786e3d0ce31626f511bc985f59d1a88aa38ba8ad6218d306abee60dd9172540232b95be1af146c69e72e5fde667a090dc3f93bdc5c5af0ab80acdbaa7a505f628c59dc0247b31a439cacf5010a94376d71521df08c178b02fb96fdb1809144ea38c68536187c53201fea8631fb0a880b4451ccdca7cc61f6aafca21cc7449d920599db61789ac3b1e164b3390124f95022aeea39ccca3ec1053f4fa10de2978e2861ea58e477085c2220021a0927aa94c5d0006b5055abba340e4f9eba22e969978dfd18e278a8b89d877328ae34268bc0174cfe211954c0036f078025217d1269fac1932a03b05a0b616012271bbe1fb554171c7a59b196d8a4479f45a77931b5d97aaf6c0c673cbe597b79b96e2a0c1eae2e66e46ccc8c85798e23ffe972ebdaa3f6caea243c004e60321eb47cd79137d78fd0613be606feacc5b3637bdc96a89c13746db8cad886f3ccf912b2178c823bcac395f06d28080269bdca2debf3419c66c690fd1adcfbd53e32e79443d7a42511a84cb22ca94fffad9149275a075b2f8ae0b021dcde9bf62b102db920733b897560518b06e1ad7f4b03458493ddaa7f4fa2c1609f7a1735aeeb1b3e2cea3ab45fc376323cc91873b7e9c90d07c192e38d3f5dfc9bfab1fd821c854da9e607ea596c391c7ec4161c6c4493929a8176badaa5a5af7211c623f29643a937677d3df0da9266181b7c4da5dd40376db677fe8f4a1dc456adf6f33c1e37cec471dd318c2647644fe52f93707a77da7d1702380a80e14cc0fdce7bf2eed48a529090bae0388ee277ce6c7018c5fb00b88362554362205c641f0d0fab94fd5b8357b5ff08b207fee023709bc126ec90cfb17c006754638f8186aaeb1265e80be0c1189ec07d01d5f6f96cb9ce82744147d18490de7dc72862f42f024a16968891a356f5e7e0e695d8c933ba5b5e43ad4c4ade5399bc2cae9bb6189b7870d7f22956194d277f28b10e01c10c6ffe3e065f7e2d6d056aa790db5649ca84dc64c35566c0af1b68c32b5b7874aaa66467afa44f40e9a0846a07ae75360a641dd2acc69d93219b2891f190621511e62a27f5e4fbe641ece1fa234fc7e9a74f48d2a760d82160d9540f649256b169d1fed6fbefdc491126530f3cbad7913e19fbd7aa53b1e243fbf28d5f38c10ebd77c8b986775975cc1d619efb27cdcd733fa1ca36cffe9c0a33cc9f02463c91a886601fd349efee85ef1462065ef9bd2c8f533220ad93138b8382d5938103ab25b2d9af8ae106e1211eb9b18793fba033900c809c02cd6d17e2f3e6fc84dae873411f8e87c3f0a8f1765b7825d185ce3730f299c3028d4a62da9ee95c2b870fb70c79370d485f9d5d9acb78926d20444033d960524d2776dc31988ec7c0dbf23b9905d\"\n+\n+const (\n+\tdigits = iota\n+\ttwain\n+)\n+\n+var testfiles = []string{\n+\t// Digits is the digits of the irrational number e. Its decimal representation\n+\t// does not repeat, but there are only 10 posible digits, so it should be\n+\t// reasonably compressible.\n+\tdigits: \"testdata/e.txt.bz2\",\n+\t// Twain is Project Gutenberg's edition of Mark Twain's classic English novel.\n+\ttwain: \"testdata/Mark.Twain-Tom.Sawyer.txt.bz2\",\n+}\n+\n+func benchmarkDecode(b *testing.B, testfile int) {\n+\tcompressed, err := ioutil.ReadFile(testfiles[testfile])\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tb.SetBytes(int64(len(compressed)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tr := bytes.NewBuffer(compressed)\n+\t\tio.Copy(ioutil.Discard, NewReader(r))\n+\t}\n+}\n+\n+func BenchmarkDecodeDigits(b *testing.B) { benchmarkDecode(b, digits) }\n+func BenchmarkDecodeTwain(b *testing.B)  { benchmarkDecode(b, twain) }\n+\n+func TestBufferOverrun(t *testing.T) {\n+\t// Tests https://code.google.com/p/go/issues/detail?id=5747.\n+\tbuffer := bytes.NewBuffer([]byte(bufferOverrunBase64))\n+\tdecoder := base64.NewDecoder(base64.StdEncoding, buffer)\n+\tdecompressor := NewReader(decoder)\n+\t// This shouldn't panic.\n+\tioutil.ReadAll(decompressor)\n+}\n+\n+var bufferOverrunBase64 string = `\n+QlpoNTFBWSZTWTzyiGcACMP/////////////////////////////////3/7f3///\n+////4N/fCZODak2Xo44GIHZgkGzDRbFAuwAAKoFV7T6AO6qwA6APb6s2rOoAkAAD\n+oACUoDtndh0iQAPkAAAAaPWihQoCgr5t97Obju21ChQB0NBm3RbA7apXrRoBooAA\n+AhA+IAHWl2Us3O7t9yieb3udvd76+4+fd33nd3HO1bVvfcGRne6+3vfPvfc++995\n+w7k973eJhasLVec970tzDNXdX28LoPXZ3H3K9z0s5ufWAfes49d5594c3dUYtI+2\n++h1dvtpRa+uvrVEAG9bl893RVEN7cWvroSqWjPMGgAQi7Gq8TJSgKKdjKFBIB9Ae\n+LqWxleu715eXe7ml9e5098Z6G1vr7t1QZ6ot76YzPd3j7333t2ql2Chm7XrA9ICQ\n+VF77z3rVBWqkSXtlfb099hyezAr6USbGpICTSCFAaqHrKo+tUnm32rpE4Ue+t2mj\n+bKUeipEqwc93EdhhTwmQpOhhesC9iqDSPNTWYNSnUtBdm1nsA0nqqNd7OWwDXtFL\n+ONmmA6Ubke26I9UblvWIPR5VOWOnctai443URunnDy77uVC59OfRvezlDu33Z7Ly\n+3NNuuHW63088xu3t3NHZhkZbG7tXRlj00qOtbaXTJUUdspTbABR9R6EUwQAEAAAA\n+EMEwRpoAAAABMmhoAAjBNNAaCMhponpoGpgJpk9TEyp6niGKZkAaAEfqMQ09U80p\n++pMGSCKngIAAAAgAAg0AAJhGgABGCEaaTyTKeNI1PE0wkj01GajMSNPSZGnqbU9T\n+anlPUNAHqGQ0DQAMg9TamgAAYRU/IAAICAmjQJgjQBMEwp5DTSaaYmhTeqfplPID\n+U1T9TynoU82pT1NPU/VP0j1NHqRpk9TTR7SnqaNNGmmQAaAD1Aeo0PSAAAAaaBiK\n+eBAQBGgIABGQA0AmBNNBoaAgaJmpglPEyYap6npiTT0agGjJjUaaDTQAAAAAAM1A\n+9QAaAAAADU8iEAQAEyAJk0NNNJgIZTJ5E00YSemiaZNGm1MpGNJ+lPU9qm9U2RDM\n+oY0EzJB6h6nqDID1NMBDDRpo1AGNAjCMmhkMgaYSJIgAAAQyAAEyBoATECCNhTT0\n+U/IZAmCM1DSTxkzUE8p6NDaGiZGJqntTFHvUyU9qPQp7Kn5GgKNPU9QAGg9QAAA3\n+wz0Pk/g/m/m9P9H4vxv2+dH3gCS8nhbbbbbYxtgNsBsG0m2MbG0NNtsbYNsaY0wb\n+bBibGmm22mxptNpsaGNDTY02JsG0MY0xg2MaYNNDbGwG0L5vsK/F9DO+EAA447Kq\n+p7Wdf6Y+5c20T7DfHyMXIzRKrZexw72uiQI+y55vOe52xpqbCLC2uR20JdER7Zvr\n+7ufuKb6zhiBxLuj0eA27v8RpMLucw9Ohwcizi2wrpt+yU1FdpM7ZYPcwS3XTef+A\n+Wzjxwhdrgw3aH1LeC1eZW900x8V9Nv4hTPXp4l067P/4ANVZFF/imOe/d5bdueam\n+/DFFokQWnFaU+ZqLBCM+d0PialJQWnLqRQZk/KhfbbYc2pCUTgffcSYbrCM1N+8l\n+HU6gSz+h2GJXs+tbrNviL83M97X0vcTn/F82P8wen8/3/h3sHY+sf9CSej9ThYTV\n+3lQ+FUHpfpGD4kv7dYMV995dpDX/y3xR8FoXx1bjUxBTNxuutwQ/h/Eedn9wpn6w\n+E3+ND8YhN1HSriIxRE/6uFyMv6/oC6Elarw3aHMMqHJkGiiz6tejmvnYLQa+Qm6G\n+deZ7jXTZV6NlpocgDnRdimS06bTYSkvPAL/xoWNLkX6N6VljU0dfKSBmm2uZE/xu\n+sutQ1EdP7GdjhglIq4xlOFUFEQpmX+xx7R8y6c0GSAaqusOjNZwxZRudOvmXm1tZ\n+T+YnbeB2ir9eiHNrtJNSLD/J/WDyuQpwBUtLKo0krccY/wIILP7f86teb9Z/9oyz\n+OX05qEWbObfhpRw+9+rCvp/35ML8KX3aHaI0n+tudbFRsV5FLW+Oa8ruLN4peyVL\n+DWjTHrXNthq/s7zAJYMeFJZkZt5mT9rfpH+5g3nc+piOSZ+J5nHtOnKI7Ff8Xl+j\n+0t76XTNucCHQ6whav1OHdF53TY5wuv5OzvrdnxoId8fTyUvERr0ERINu/8XxZZ5f\n+B5/kTZ8bBO0wv54Jp+ED/GQI8lZHzIQCP3vfQhwnCTj9TvITic7P4mYLDbH3fyzR\n+i+6EajCcpXLWSGf+ZXkOrWspDWDhXtEKas0v3UqWksqgY1rTj45krX4KihN+daXs\n+pZl5WPlta5p06CX6Xm2SfzqkMw12/3ix1bpnnZ+kFeBNX7A+E9zzG6OZaN78GOpl\n+9Ht/eZn9PqWdav852zr0zqkDK2H5IjdvNah+b1YVGdQGzwR4Nw+f13yEKnV+y66W\n+djfq7zWp7m5w+hzfv+Ly8O7oet5Vvd8/wQvO7qzOZ2vjf9X8Tj8PnMb/nc/nKqRR\n++ml4UEhOOwfCeJEEI109CMYSh91iAJqPjMyH6KjrPD7W25llZVcREYNCTg6htbQt\n+M38wYoquCWP6tdKYlVIv14xTNUeUf4El/FunCf6csZkmv+9tfWx7t59wuKIa3saU\n+tZs9M+3HFOZtz3OLg/Unoaj9BYazYqA78xBU9tZzrtmF/rQL9CGJt90o/oYnSfcS\n+SL3haaw351LXWQ1XOsv1SmH3v6ymuxEpPPnEDmBELaTYsvvMIWJsmPZFFww++Kd7\n+s/Jo0JFeUU7uNtI+gVosAIpVVuWfI/9tOIycz7I5Z7zjV+NR2OuZbYtW5F08KX4o\n+2k/xuJIchcNFPtxPfw9dkDgscRbMckyFMrzuZ3IvrcGzk0J6iI5ytrv37bGpAXMz\n+WK9mMMPebepNevmLjjo/QWoM968Sjv7ldlPS5AinHcXwsFv6dmmh8lJt7UOJWoKu\n+lMD1cB2ksIGpMdv8iuqR42Rn/kn+17BhhUZcwDBaUXVdX6bKW7fxlUYbq+mlqIcf\n+a9v8HF87M9ANbi9bq9onf9TD7nQ6Xf6vZci8TBPX+/GI0He6j31fTVQYW+NsQxvO\n+J8xrx+e58CCLQNjxeIyPt+F+qk/QMiXw+LyxGVkV/XcGQT9X03jSDP6beJ5QG1JW\n+9Q3qLv/YixWI7gPV9Mrhf2oRYTc/9KLFRhkE3SjKOTKuSSBKQ24fI+hEznamH71D\n+66Hwez8/0et7AtTv9zvamv2OD5He6fMV4k+ePl6+qPfO5CdHtK+eCDZL5+4f5yrl\n+gTcRFiq8fXbc5IaI5fbbc1KMM/2T0Mr7+Hwaco6FtXm0fmhCgTZRqY4pKiEIfmaz\n+QwHNOOCrtMJ2VwsyMumt7xsOolGnizRev6lILH43qPcczQM7Gc5zRin80YvFt1Qm\n+h/57Z0auR2h0fuX50MBO4XQ+26y5l6v4j902R66c0j3z2KHstKQ04J/h6LbuNQE4\n+D6cu/lyfK69DxxX8wb8XaQkMUcJdo1LzqUGDAb3Kfn/A3P/JYc99MO9qv67+SxWb\n+wYTyqKdWTd+1KbR/Rcn0Io5zI/QquX7FA1bxfMytjQ/X+l0fh0Pf+Hx97meH4fQL\n+7/T8/sdTm9Tn8nELvedyhydLlPPTScINdXyLIq9wgIJr4fWPbp9ZhFh/56fdSgOG\n+HDXg+gkXsN2Rddr4HQ5P3u+RhLzmSjhzoqY5EsPC4QvRlX9JXjB84rPV5USR66qa\n+/kjw4156GJnzoXtydKJE53t6PHfZWO+3ujsfI6iAdshc7OFzGXiZB9PtItKodhYq\n+nABkTKdcpu4+TOpf9h5piX5slsaBjkeTnj/Ba02ilboQfcDVigxrYn/iTH5ySWUW\n+/lHtg78s5UZM8sErwhNe3N3w+6ZOMnU+5i86/xFNtqZfDdXTGy1H3PzGbdtZXYT+\n+Ixx2vpwBYzbPVYHxKosM5rPiVmcTllI9nuoSfeh9ib4foFWauOpvdmhBDqpTpKTX\n+u8EO2l2Z195G2RIV7TlKSxGWjR5sl/nALu1uzBeLd9zpSujzMTd1uTX9Qk/Q1S+r\n+vaW6bm8qqPO4jb6Wx6XIkm321nrIF6Ae25d1+Dpv/P5G4NoLd2j6/EtENC3FeR5z\n+oo7bA+tI8yEQRhiF0z1FlJXLD5ZbhNNWQm/j/IbzRfh8JtOFZU7ruShLvHXysW9S\n+9V909tr9jn8/E/Hb5N/1NVNHnZu2HIUvJvHJiHd2ucmeI9PWUMnppmE65GQ5E9xV\n+ZRlGEH0X85EvmHyEupkMrCC0oMv9RCq+/H8gcfpe00Hs/S+regT5p58cyYomh93v\n+qvuw/A06BE/wzJESuYbN9pqYpoXqXFemW1NksHEJ2w+PYMJ27WJyD5FpaXB85VaW\n+qMOhDfO8E3QdH8ybyKt/UgI8/tDGpFbyOlaVdIv1FXJhoLp8soAA4Djg6/KZ066N\n+ZFYuS8WdjpSZGP4/Lw+1yaXlzNznc/k2uHe2uXP3uFuPcHx+Dm44utxldoO1uBPy\n++jzOs14+MIgOjOHMVNqAbMd8fUedLlhJMCfMtm4uz01enLNKcMrtLlPIR37Yukh1\n+YEMXYpm7eU4XU+j+Jj3pDyaXtXs+p1fWfTN/cy9/Oxs4umUXQ4uHh1kObtayDJ56\n+/QMxiHobjHNKuKfMxsrYEwN+QVIyVjAwMDYuMjQ1AAA9IwJniiBLRkZDAAAXt0Ja\n+aDQxQVkmU1lZtwytAACLf///////////////////+//////v//////////bv78//\n+/+AXO133uwO2xB2UxIvbKXrCqCoURUBL2ytFI82AFdcOwMhVTHtk5rD3szEVNYD4\n+aIQINCaMRoTaSn7SbSMJiYmEwieTEp+psqbMCp+VNPaFNpqbBNR7UmanlPUeKfqm\n+j1PU0/VPU08o9Q9EeKHlPJtKbYqeTCYhN6U9T1NH6mp+lPyoGNTI/Knkyg1MggAg\n+CaMEyQnqZoaaRtRtJpppppoDaTR6hpphGh6mmgHpMQBpkGTTEAAaAAAA00AZDag0\n+ADIBkGgABqemiRNTI0k8aU0PRGRoAZlP0UAAAGgAAAyAADQaAAAaAAAAAAAAAAAA\n+AaAAAAM0kgRBJ5MlPFP1Gj0jTTTUaekxNAbUGjTQMgaZANNAAAAaAADTQAAAAAAA\n+ANAA0AAANADQ0QAAAAAAAAAaGgAAAAAAABoA0AAA0AAAAAAAAAAAAANAAAAAkSEI\n+aTRpomp5DUxNNDTJPTKaep6T09Kemmo2JG0aTQ9ENogaaGhkABo0NHqaBoDTI0DC\n+Gj0gNAMhoDQ9QMQNAGQAaDDwyMPIMlbG1vhRBTFo6JksSupgpAjPbY0ec02IGXjb\n+eS+FBsh01+O4ZOaD+srUZCFaT4DRjVDLx7uKIsFtESIDUg1ZkhyCSYov05C00MtR\n+BdNNa/AYPGOQZWcs+VegXOPrkushFbZ3mBoRD6WamClkpBaHZrUhUl02bIfRXX4w\n+b3/9cW9nHDVxh2qFBxqgRKfmq7/Jc/tdJk05nVrGbckGVy2PnIy30CDhpWmqrSot\n+K2bOnX0NbP1iy2cd0Na0ZmbRstm4MzMzbbMySTd35F7f+zPP8DC+NJLYcakkkkRd\n+NZlupJt3OMFoDAD2g+N3FAMCydhIpoRHRQAdFI5nNg4ugEXHCYxkMyGCwtaJmial\n+y0IMlpSYYM/weXNJAhFqS0GNmvaPEtYGjbvaucMdklOTmBX1vfVAkTYB1uXCSK64\n+UNIixOqRKLuRCFtqIQtgwqaFrCkIYbbewErWABa+VGADWsJXJjfx5SJViLuwiGXq\n+Ru6vCuwmU5CJiJz3UiBpmLv0r2wskxUhY4tzPVGQ9RMXJl65eLSNwZVwaSyGZ9Cm\n+A3jztQUUpFeUryBTskW95iVwRMFrhBCwZBAFJBZvhMEMNoDJJlUoIhQkAkjbExp2\n+YZio+ZYeAZUwmH1qUbdQixmxf0+61+aVgJ1hwxsO1yG3hFx4pfjc09ITVht0pG8u\n+FtVFhPa1KE0gTRUSVXywkITucqk0Waz5Fs6qJpVHYdNrbYRFxnFsQGY1qmsTLjK6\n+4QX5Rddo6krM/Bx9CqIAKq4CzVQYHrmIAd2EBhYmwVYwLvhzKIUrc2EirnGIvyuD\n+O4YZDSwsVTA0BpVvUOjDErkCraBoSutcKwUSSLGhVvNYHLz3klgZD++wWsa/swLw\n+gvNDY2De+sncOv8X2lq4HD95ZdwPuTIMXCwSbg4RrIqv+L0y6F17pqDecyQYPEj3\n+iN/0BBeWZlJAyBMi5U3Q1zAlsK8IlDhaXGmvZrgISq5CfNjmUgxDeMggOKqxu4sI\n+OrilS49Lkl1J3u3GjXTuH+rX+4ccyFAQnizCpPClcY77F59j63S6fr5vr+y99tuO\n+7Ox7Wg/ljwhdyaK4xMmXczeJbx7x07htJNtC4xcQfAtvzeznLrN6MN/ILIBOI65I\n+qIA2D5fHHj1XN4aN6TvOjWDaSbSWqxCSCvXUpzkNJAkWXAuTwF8k5uSJvQj/rVo0\n+hAhEMEIYkCRGx9AX+byIuXWlLMbbVeliHNUL5AQYmNwLFu4SkmGD+UWtBMyVHQOQ\n+ss0ggoVKSKOBUgnVS6ljt7WE1qXqJJ4QA1pEwYNLEaguEE1LtPNoVr5WzjbSbWPk\n+V9OW3y9IneUDLoIV5pAkEFTEFGFVjeTFxtpzBBfGgycBxVCdz8eESBIzsamRchAa\n+TQunQH8DHnpfod9QuAuRvc7JBlKUCYmCjMvynLcxIFohxCaYrDvGw4QbXZB7oWQ7\n+hpoGlz23ayDfB8NrRRzdilsEQyQniu9ASLQg7RrGZnoTr1ai12IbCEUCGdFq03P5\n+nBnRFAGmisQGcyykV9gKtcVMWLhCuVmXg86dndn7slUpRNSSEAU20oaWIm1maFTu\n+E0DT4gTbg0nuhjtz3kNOz+i7sBm0bkXjxQWuLqlZEmp60ZTyRZJDUqKSEKg6hqcy\n+ERxdU22CSNOO10RYUUiDVpKhPNdKTOIE1thp02sBNoNTFSht8WJtaBQ09qN3jd5r\n+dOLX4IA5fevRyCCzDgRXfV4wzik4KROjmxmTMglBySlIMEzcXehnDXCRiZSlvwA2\n+0YsIOROcm4UrIRFxJHctJH7OdN5u1aHVHb5UaLHpv48NgmFRE56KTSoaWunqm2st\n+S0mrAdOiqcR12PWVbdVRJKcQ0DQuhwlAPcRtpxN3D4kbXJjToSYJIFw406G2CSaK\n+jQMIJPZGlQmgyFhoCSzeGS1VSq5SKKQQxs5RqKUcVUNY57YUETb4mXzV84SPngKi\n+nsce0mXByZq5BKUA9puHZWLNwQIYuDaJUNgG+E01E3pDYVNLKYQ0hsVesgV5gZY0\n+htDsRdGtm0+iGnkN6+Ea9YJtUZNAkx2GgSoix12nTW0avTUfxR3oYcpvZ7IdtABE\n+UhBcjG4qZtDZsS1JQHys243vhLaDTSvvTeBiJA2tmokqECTBcSOCAGkAxMKlVAva\n+4IsLRaBBqhxDbcGtgdw03mFcLUaFuhtKuuEIEkUleJQwby/zwu9uvvZK4xTV+ECM\n+a8lmzxKmqkBggYK1+xPdbmJclm6tSZhE/OSJtCEjs+unJIQkT9hCWgBJqGMS07Eh\n+AJNmBiuVEVdTyjkIJkavuZmx2sJF13htgEZUCC23lZFOE6gWbM9WyYNJTM8yCQrb\n+0Sx3OQvBML5cRATAQkSQkAJOAhoxpQkNi4ZiEVDbdtJAME0RXNDXGHA3M3Q0mm1o\n+IEwbWpaM1DQCSMbGRCAu3iRIQiT6RlBpT1n3tfwvUXz3gIVlx3mEximY/kZW1kNG\n+sgEJIrBisaEoGYPJ+1CQUYFBw+eGEHJQBpNHjErXUJY2iWHQ30hXwFBuMSxQ2lB5\n+bg+/LX3euG6HsHUB1lFvBvaiaBrITVwkCTa1d0s9CHZCiDZjbWReKyrpPE2oSa7o\n+LPrR4BJvys9ttjUpzETSSMxh8vsr9dXTwKBtK+1xCTGDQmNIaE29HmHdS5GSxpya\n+MismcAUSEgSxHBrKtgsZzduG7vHZn16l3kFkVITtENIzS2JsiBwFTDlhgexsjBHv\n+5HXOYxHBzoSDCcPZ0ctvkY9aS5XpoQuFYkGJgCsqjJZeUMNUEpDSbKcnUc1PifIA\n+CbR2UoXawBlspkEBr9HBfvUi/MUakZVOf1WKYrqSaIXce62JOyhJLq3qJBloTA0F\n+VbILEtM+heFmNRCFt70GJrExVJri0ArYbCRbADSGDBpBXxxb/6fo+s3C7uaL7RjM\n+LV2IQBNrAJrKFeJwTsPnxbAsemirUx2lk1kaxschzdK4TQNJN5wQnolIFg401OZ4\n+2na11LnT3lR+1k1TMJhiAjXMk0F1ooHnYlt9LKfJ3ZIOmeY+2l9bUQHWFNGyEyfj\n+EAcu3kpGLq0Ez7XOS+EpAASRQTAYMATfVQibHLTT30zG732+pNe9za1JNt8sNJYn\n+RjWuJ6jL5ILV0rcd9vT7X9fObvcXitpvJ2XBJE+PhX2HaTkyWeF9pwnlQNrTe9hV\n+tzhA+ihZrDrHNmLcQjZbnv/IMubqq8egxY80t5n6vZ6U5TR6U9uZJvai1xtqAyCR\n+NWkW52m00rDTEuO6BA4q2RHDWwbETF55rRsWLIgNW9qJCyMHPbTM/dMBmWMQSMxz\n+4M2pRzt47SICxA327UqSCEERqMFybmYi3nUxePtLgHYplqRiw4ynMbXd/kiQ0LE0\n+PKJSSCXA42ymziCpAxNWflzpzQdJZusahRFr6t6m+4p273/Taj7k+hZyNgBAgXAY\n+8F7pTts6orLb8IA6o4TOwkwQYmKvKu9VwMrE7+GUhVIAgY9a8DyQMiDBkEAwh7S1\n+KgCBfao8DK1CwSS8Z3WjL5MEgt93z2koUQCD/YxMBppiCMp7SDVSmkkIHptfGpeh\n+t+M13Ccv1tavIASFiaQl6rBz3K4N3DSGwNkCibrvEAC0fQirOWnc4NVbcLKpFG1l\n+NQXF/eqdT79wq1Mvlap3QSCLhcD2D3fCkKVWid4aSjtp9FOX1Uaf7P9eT93zd9Sv\n+mj2yNLRUGzyI/0oONNSzmmkvJ5Cq2X2CdldIWMGZO57RJ8oyATAWTQmRmNkfh0Sx\n+uuR/J9oUsomVy1AEntc0dlPivkqBkBqrxU3j5PnWkaI3ZRGc0gg9spCQEISh4xEU\n+pMhVrnmDQLfLP8Ouqpx917MAw7hkjQk6BJFTAbXDsz3LSHIxo/gB8qrA1vbvdZZh\n+LtR0frJdfdppX8nAQX/TAxOQ8+H6yw8a9i7/zJEfSYIhop59N/fhcWW2F14cj2Xc\n+fyHaZ04lTO4uPnly91jwuFPaREuZVp8AxImIhlkxkAN61tWdWG7tEbaCgszh6VIz\n+ThFnHo2Vi8SQXPrXCN7J9Tc9ZYiAYqoThV/u6SYsea5aZL8deOvKBQCgZZuIxX1z\n+4EnfcqG176vY4VqMBIC4pMJz0WcHJYqN+j7BiwGoMBwExrIdTB7q4XIFLotcIpS0\n+1MqyVsesvoQq7WObmGQXdMliMirSLcDuSx8Qy+4pIBgGDIyMp1qbonnGdcHYvU8S\n+O0A8s/iua5oFdNZTWvbVI4FUH9sKcLiB3/fIAF+sB4n8q6L+UCfmbPcAo/crQ6b3\n+HqhDBMY9J0q/jdz9GNYZ/1fbXdkUqAQKFePhtzJDRBZba27+LPQNMCcrHMq06F1T\n+4QmLmkHt7LxB2pAczUO+T2O9bHEw/HWw+dYf2MoRDUw=\n+`"}, {"sha": "8f6b0c9cad33789f6c2622020404fcb00cacafba", "filename": "libgo/go/compress/bzip2/huffman.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -33,14 +33,17 @@ const invalidNodeValue = 0xffff\n \n // Decode reads bits from the given bitReader and navigates the tree until a\n // symbol is found.\n-func (t huffmanTree) Decode(br *bitReader) (v uint16) {\n+func (t *huffmanTree) Decode(br *bitReader) (v uint16) {\n \tnodeIndex := uint16(0) // node 0 is the root of the tree.\n \n \tfor {\n \t\tnode := &t.nodes[nodeIndex]\n-\t\tbit := br.ReadBit()\n+\t\tbit, ok := br.TryReadBit()\n+\t\tif !ok && br.ReadBit() {\n+\t\t\tbit = 1\n+\t\t}\n \t\t// bzip2 encodes left as a true bit.\n-\t\tif bit {\n+\t\tif bit != 0 {\n \t\t\t// left\n \t\t\tif node.left == invalidNodeValue {\n \t\t\t\treturn node.leftValue"}, {"sha": "b7e75a700a18815843fe3964868445677c9f372a", "filename": "libgo/go/compress/bzip2/move_to_front.go", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -15,10 +15,11 @@ type moveToFrontDecoder struct {\n \t// Rather than actually keep the list in memory, the symbols are stored\n \t// as a circular, double linked list with the symbol indexed by head\n \t// at the front of the list.\n-\tsymbols []byte\n-\tnext    []uint8\n-\tprev    []uint8\n+\tsymbols [256]byte\n+\tnext    [256]uint8\n+\tprev    [256]uint8\n \thead    uint8\n+\tlen     int\n }\n \n // newMTFDecoder creates a move-to-front decoder with an explicit initial list\n@@ -28,12 +29,9 @@ func newMTFDecoder(symbols []byte) *moveToFrontDecoder {\n \t\tpanic(\"too many symbols\")\n \t}\n \n-\tm := &moveToFrontDecoder{\n-\t\tsymbols: symbols,\n-\t\tnext:    make([]uint8, len(symbols)),\n-\t\tprev:    make([]uint8, len(symbols)),\n-\t}\n-\n+\tm := new(moveToFrontDecoder)\n+\tcopy(m.symbols[:], symbols)\n+\tm.len = len(symbols)\n \tm.threadLinkedList()\n \treturn m\n }\n@@ -45,34 +43,29 @@ func newMTFDecoderWithRange(n int) *moveToFrontDecoder {\n \t\tpanic(\"newMTFDecoderWithRange: cannot have > 256 symbols\")\n \t}\n \n-\tm := &moveToFrontDecoder{\n-\t\tsymbols: make([]uint8, n),\n-\t\tnext:    make([]uint8, n),\n-\t\tprev:    make([]uint8, n),\n-\t}\n-\n+\tm := new(moveToFrontDecoder)\n \tfor i := 0; i < n; i++ {\n-\t\tm.symbols[i] = byte(i)\n+\t\tm.symbols[byte(i)] = byte(i)\n \t}\n-\n+\tm.len = n\n \tm.threadLinkedList()\n \treturn m\n }\n \n // threadLinkedList creates the initial linked-list pointers.\n func (m *moveToFrontDecoder) threadLinkedList() {\n-\tif len(m.symbols) == 0 {\n+\tif m.len == 0 {\n \t\treturn\n \t}\n \n-\tm.prev[0] = uint8(len(m.symbols) - 1)\n+\tm.prev[0] = uint8(m.len - 1)\n \n-\tfor i := 0; i < len(m.symbols)-1; i++ {\n+\tfor i := byte(0); int(i) < m.len-1; i++ {\n \t\tm.next[i] = uint8(i + 1)\n \t\tm.prev[i+1] = uint8(i)\n \t}\n \n-\tm.next[len(m.symbols)-1] = 0\n+\tm.next[m.len-1] = 0\n }\n \n func (m *moveToFrontDecoder) Decode(n int) (b byte) {"}, {"sha": "a3200a8f49e8cf106cbc77b0c1029c69877f797a", "filename": "libgo/go/compress/flate/copy.go", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,12 +6,27 @@ package flate\n \n // forwardCopy is like the built-in copy function except that it always goes\n // forward from the start, even if the dst and src overlap.\n-func forwardCopy(dst, src []byte) int {\n-\tif len(src) > len(dst) {\n-\t\tsrc = src[:len(dst)]\n+// It is equivalent to:\n+//   for i := 0; i < n; i++ {\n+//     mem[dst+i] = mem[src+i]\n+//   }\n+func forwardCopy(mem []byte, dst, src, n int) {\n+\tif dst <= src {\n+\t\tcopy(mem[dst:dst+n], mem[src:src+n])\n+\t\treturn\n \t}\n-\tfor i, x := range src {\n-\t\tdst[i] = x\n+\tfor {\n+\t\tif dst >= src+n {\n+\t\t\tcopy(mem[dst:dst+n], mem[src:src+n])\n+\t\t\treturn\n+\t\t}\n+\t\t// There is some forward overlap.  The destination\n+\t\t// will be filled with a repeated pattern of mem[src:src+k].\n+\t\t// We copy one instance of the pattern here, then repeat.\n+\t\t// Each time around this loop k will double.\n+\t\tk := dst - src\n+\t\tcopy(mem[dst:dst+k], mem[src:src+k])\n+\t\tn -= k\n+\t\tdst += k\n \t}\n-\treturn len(src)\n }"}, {"sha": "2011b1547c934cccae2540cd378b600ce789a0e8", "filename": "libgo/go/compress/flate/copy_test.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -30,10 +30,12 @@ func TestForwardCopy(t *testing.T) {\n \t}\n \tfor _, tc := range testCases {\n \t\tb := []byte(\"0123456789\")\n-\t\tdst := b[tc.dst0:tc.dst1]\n-\t\tsrc := b[tc.src0:tc.src1]\n-\t\tn := forwardCopy(dst, src)\n-\t\tgot := string(dst[:n])\n+\t\tn := tc.dst1 - tc.dst0\n+\t\tif tc.src1-tc.src0 < n {\n+\t\t\tn = tc.src1 - tc.src0\n+\t\t}\n+\t\tforwardCopy(b, tc.dst0, tc.src0, n)\n+\t\tgot := string(b[tc.dst0 : tc.dst0+n])\n \t\tif got != tc.want {\n \t\t\tt.Errorf(\"dst=b[%d:%d], src=b[%d:%d]: got %q, want %q\",\n \t\t\t\ttc.dst0, tc.dst1, tc.src0, tc.src1, got, tc.want)"}, {"sha": "8c79df0c607d8e3415757dde544b9cacc68b8e11", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -416,6 +416,50 @@ func (d *compressor) init(w io.Writer, level int) (err error) {\n \treturn nil\n }\n \n+var zeroes [32]int\n+var bzeroes [256]byte\n+\n+func (d *compressor) reset(w io.Writer) {\n+\td.w.reset(w)\n+\td.sync = false\n+\td.err = nil\n+\tswitch d.compressionLevel.chain {\n+\tcase 0:\n+\t\t// level was NoCompression.\n+\t\tfor i := range d.window {\n+\t\t\td.window[i] = 0\n+\t\t}\n+\t\td.windowEnd = 0\n+\tdefault:\n+\t\td.chainHead = -1\n+\t\tfor s := d.hashHead; len(s) > 0; {\n+\t\t\tn := copy(s, zeroes[:])\n+\t\t\ts = s[n:]\n+\t\t}\n+\t\tfor s := d.hashPrev; len(s) > 0; s = s[len(zeroes):] {\n+\t\t\tcopy(s, zeroes[:])\n+\t\t}\n+\t\td.hashOffset = 1\n+\n+\t\td.index, d.windowEnd = 0, 0\n+\t\tfor s := d.window; len(s) > 0; {\n+\t\t\tn := copy(s, bzeroes[:])\n+\t\t\ts = s[n:]\n+\t\t}\n+\t\td.blockStart, d.byteAvailable = 0, false\n+\n+\t\td.tokens = d.tokens[:maxFlateBlockTokens+1]\n+\t\tfor i := 0; i <= maxFlateBlockTokens; i++ {\n+\t\t\td.tokens[i] = 0\n+\t\t}\n+\t\td.tokens = d.tokens[:0]\n+\t\td.length = minMatchLength - 1\n+\t\td.offset = 0\n+\t\td.hash = 0\n+\t\td.maxInsertIndex = 0\n+\t}\n+}\n+\n func (d *compressor) close() error {\n \td.sync = true\n \td.step(d)\n@@ -439,7 +483,6 @@ func (d *compressor) close() error {\n // If level is in the range [-1, 9] then the error returned will be nil.\n // Otherwise the error returned will be non-nil.\n func NewWriter(w io.Writer, level int) (*Writer, error) {\n-\tconst logWindowSize = logMaxOffsetSize\n \tvar dw Writer\n \tif err := dw.d.init(w, level); err != nil {\n \t\treturn nil, err\n@@ -462,6 +505,7 @@ func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n \tzw.Write(dict)\n \tzw.Flush()\n \tdw.enabled = true\n+\tzw.dict = append(zw.dict, dict...) // duplicate dictionary for Reset method.\n \treturn zw, err\n }\n \n@@ -480,7 +524,8 @@ func (w *dictWriter) Write(b []byte) (n int, err error) {\n // A Writer takes data written to it and writes the compressed\n // form of that data to an underlying writer (see NewWriter).\n type Writer struct {\n-\td compressor\n+\td    compressor\n+\tdict []byte\n }\n \n // Write writes data to w, which will eventually write the\n@@ -506,3 +551,21 @@ func (w *Writer) Flush() error {\n func (w *Writer) Close() error {\n \treturn w.d.close()\n }\n+\n+// Reset discards the writer's state and makes it equivalent to\n+// the result of NewWriter or NewWriterDict called with dst\n+// and w's level and dictionary.\n+func (w *Writer) Reset(dst io.Writer) {\n+\tif dw, ok := w.d.w.w.(*dictWriter); ok {\n+\t\t// w was created with NewWriterDict\n+\t\tdw.w = dst\n+\t\tw.d.reset(dw)\n+\t\tdw.enabled = false\n+\t\tw.Write(w.dict)\n+\t\tw.Flush()\n+\t\tdw.enabled = true\n+\t} else {\n+\t\t// w was created with NewWriter\n+\t\tw.d.reset(dst)\n+\t}\n+}"}, {"sha": "730234c385039510249bd0aa482a793c2871fb5f", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"reflect\"\n \t\"sync\"\n \t\"testing\"\n )\n@@ -424,3 +425,66 @@ func TestRegression2508(t *testing.T) {\n \t}\n \tw.Close()\n }\n+\n+func TestWriterReset(t *testing.T) {\n+\tfor level := 0; level <= 9; level++ {\n+\t\tif testing.Short() && level > 1 {\n+\t\t\tbreak\n+\t\t}\n+\t\tw, err := NewWriter(ioutil.Discard, level)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"NewWriter: %v\", err)\n+\t\t}\n+\t\tbuf := []byte(\"hello world\")\n+\t\tfor i := 0; i < 1024; i++ {\n+\t\t\tw.Write(buf)\n+\t\t}\n+\t\tw.Reset(ioutil.Discard)\n+\n+\t\twref, err := NewWriter(ioutil.Discard, level)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"NewWriter: %v\", err)\n+\t\t}\n+\n+\t\t// DeepEqual doesn't compare functions.\n+\t\tw.d.fill, wref.d.fill = nil, nil\n+\t\tw.d.step, wref.d.step = nil, nil\n+\t\tif !reflect.DeepEqual(w, wref) {\n+\t\t\tt.Errorf(\"level %d Writer not reset after Reset\", level)\n+\t\t}\n+\t}\n+\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriter(w, NoCompression) })\n+\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriter(w, DefaultCompression) })\n+\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriter(w, BestCompression) })\n+\tdict := []byte(\"we are the world\")\n+\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriterDict(w, NoCompression, dict) })\n+\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriterDict(w, DefaultCompression, dict) })\n+\ttestResetOutput(t, func(w io.Writer) (*Writer, error) { return NewWriterDict(w, BestCompression, dict) })\n+}\n+\n+func testResetOutput(t *testing.T, newWriter func(w io.Writer) (*Writer, error)) {\n+\tbuf := new(bytes.Buffer)\n+\tw, err := newWriter(buf)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewWriter: %v\", err)\n+\t}\n+\tb := []byte(\"hello world\")\n+\tfor i := 0; i < 1024; i++ {\n+\t\tw.Write(b)\n+\t}\n+\tw.Close()\n+\tout1 := buf.String()\n+\n+\tbuf2 := new(bytes.Buffer)\n+\tw.Reset(buf2)\n+\tfor i := 0; i < 1024; i++ {\n+\t\tw.Write(b)\n+\t}\n+\tw.Close()\n+\tout2 := buf2.String()\n+\n+\tif out1 != out2 {\n+\t\tt.Errorf(\"got %q, expected %q\", out2, out1)\n+\t}\n+\tt.Logf(\"got %d bytes\", len(out1))\n+}"}, {"sha": "57fea5ab4dcfa65a207a60396827d510ae13962f", "filename": "libgo/go/compress/flate/flate_test.go", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -24,3 +24,39 @@ func TestUncompressedSource(t *testing.T) {\n \t\tt.Errorf(\"output[0] = %x, want 0x11\", output[0])\n \t}\n }\n+\n+// The following test should not panic.\n+func TestIssue5915(t *testing.T) {\n+\tbits := []int{4, 0, 0, 6, 4, 3, 2, 3, 3, 4, 4, 5, 0, 0, 0, 0, 5, 5, 6,\n+\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 6, 0, 11, 0, 8, 0, 6, 6, 10, 8}\n+\th := new(huffmanDecoder)\n+\tok := h.init(bits)\n+\tif ok == true {\n+\t\tt.Fatalf(\"Given sequence of bits is bad, and should not succeed.\")\n+\t}\n+}\n+\n+// The following test should not panic.\n+func TestIssue5962(t *testing.T) {\n+\tbits := []int{4, 0, 0, 6, 4, 3, 2, 3, 3, 4, 4, 5, 0, 0, 0, 0,\n+\t\t5, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11}\n+\th := new(huffmanDecoder)\n+\tok := h.init(bits)\n+\tif ok == true {\n+\t\tt.Fatalf(\"Given sequence of bits is bad, and should not succeed.\")\n+\t}\n+}\n+\n+// The following test should not panic.\n+func TestIssue6255(t *testing.T) {\n+\tbits1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11}\n+\tbits2 := []int{11, 13}\n+\th := new(huffmanDecoder)\n+\tif !h.init(bits1) {\n+\t\tt.Fatalf(\"Given sequence of bits is good and should succeed.\")\n+\t}\n+\tif h.init(bits2) {\n+\t\tt.Fatalf(\"Given sequence of bits is bad and should not succeed.\")\n+\t}\n+}"}, {"sha": "b182a710b9af9ab3767c8684d68c9ae2a7fab48c", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -97,6 +97,31 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n \t}\n }\n \n+func (w *huffmanBitWriter) reset(writer io.Writer) {\n+\tw.w = writer\n+\tw.bits, w.nbits, w.nbytes, w.err = 0, 0, 0, nil\n+\tw.bytes = [64]byte{}\n+\tfor i := range w.codegen {\n+\t\tw.codegen[i] = 0\n+\t}\n+\tfor _, s := range [...][]int32{w.literalFreq, w.offsetFreq, w.codegenFreq} {\n+\t\tfor i := range s {\n+\t\t\ts[i] = 0\n+\t\t}\n+\t}\n+\tfor _, enc := range [...]*huffmanEncoder{\n+\t\tw.literalEncoding,\n+\t\tw.offsetEncoding,\n+\t\tw.codegenEncoding} {\n+\t\tfor i := range enc.code {\n+\t\t\tenc.code[i] = 0\n+\t\t}\n+\t\tfor i := range enc.codeBits {\n+\t\t\tenc.codeBits[i] = 0\n+\t\t}\n+\t}\n+}\n+\n func (w *huffmanBitWriter) flushBits() {\n \tif w.err != nil {\n \t\tw.nbits = 0"}, {"sha": "3b9fce466ed242667d1fe024342cacac4af3013b", "filename": "libgo/go/compress/flate/huffman_code.go", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -19,23 +19,13 @@ type literalNode struct {\n \tfreq    int32\n }\n \n-type chain struct {\n-\t// The sum of the leaves in this tree\n-\tfreq int32\n-\n-\t// The number of literals to the left of this item at this level\n-\tleafCount int32\n-\n-\t// The right child of this chain in the previous level.\n-\tup *chain\n-}\n-\n+// A levelInfo describes the state of the constructed tree for a given depth.\n type levelInfo struct {\n \t// Our level.  for better printing\n \tlevel int32\n \n-\t// The most recent chain generated for this level\n-\tlastChain *chain\n+\t// The frequency of the last node at this level\n+\tlastFreq int32\n \n \t// The frequency of the next character to add to this level\n \tnextCharFreq int32\n@@ -47,12 +37,6 @@ type levelInfo struct {\n \t// The number of chains remaining to generate for this level before moving\n \t// up to the next level\n \tneeded int32\n-\n-\t// The levelInfo for level+1\n-\tup *levelInfo\n-\n-\t// The levelInfo for level-1\n-\tdown *levelInfo\n }\n \n func maxNode() literalNode { return literalNode{math.MaxUint16, math.MaxInt32} }\n@@ -121,6 +105,8 @@ func (h *huffmanEncoder) bitLength(freq []int32) int64 {\n \treturn total\n }\n \n+const maxBitsLimit = 16\n+\n // Return the number of literals assigned to each bit size in the Huffman encoding\n //\n // This method is only called when list.length >= 3\n@@ -131,9 +117,13 @@ func (h *huffmanEncoder) bitLength(freq []int32) int64 {\n //             frequency, and has as its last element a special element with frequency\n //             MaxInt32\n // maxBits     The maximum number of bits that should be used to encode any literal.\n+//             Must be less than 16.\n // return      An integer array in which array[i] indicates the number of literals\n //             that should be encoded in i bits.\n func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {\n+\tif maxBits >= maxBitsLimit {\n+\t\tpanic(\"flate: maxBits too large\")\n+\t}\n \tn := int32(len(list))\n \tlist = list[0 : n+1]\n \tlist[n] = maxNode()\n@@ -148,87 +138,95 @@ func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {\n \t// A bogus \"Level 0\" whose sole purpose is so that\n \t// level1.prev.needed==0.  This makes level1.nextPairFreq\n \t// be a legitimate value that never gets chosen.\n-\ttop := &levelInfo{needed: 0}\n-\tchain2 := &chain{list[1].freq, 2, new(chain)}\n+\tvar levels [maxBitsLimit]levelInfo\n+\t// leafCounts[i] counts the number of literals at the left\n+\t// of ancestors of the rightmost node at level i.\n+\t// leafCounts[i][j] is the number of literals at the left\n+\t// of the level j ancestor.\n+\tvar leafCounts [maxBitsLimit][maxBitsLimit]int32\n+\n \tfor level := int32(1); level <= maxBits; level++ {\n \t\t// For every level, the first two items are the first two characters.\n \t\t// We initialize the levels as if we had already figured this out.\n-\t\ttop = &levelInfo{\n+\t\tlevels[level] = levelInfo{\n \t\t\tlevel:        level,\n-\t\t\tlastChain:    chain2,\n+\t\t\tlastFreq:     list[1].freq,\n \t\t\tnextCharFreq: list[2].freq,\n \t\t\tnextPairFreq: list[0].freq + list[1].freq,\n-\t\t\tdown:         top,\n \t\t}\n-\t\ttop.down.up = top\n+\t\tleafCounts[level][level] = 2\n \t\tif level == 1 {\n-\t\t\ttop.nextPairFreq = math.MaxInt32\n+\t\t\tlevels[level].nextPairFreq = math.MaxInt32\n \t\t}\n \t}\n \n \t// We need a total of 2*n - 2 items at top level and have already generated 2.\n-\ttop.needed = 2*n - 4\n+\tlevels[maxBits].needed = 2*n - 4\n \n-\tl := top\n+\tlevel := maxBits\n \tfor {\n+\t\tl := &levels[level]\n \t\tif l.nextPairFreq == math.MaxInt32 && l.nextCharFreq == math.MaxInt32 {\n \t\t\t// We've run out of both leafs and pairs.\n \t\t\t// End all calculations for this level.\n-\t\t\t// To m sure we never come back to this level or any lower level,\n+\t\t\t// To make sure we never come back to this level or any lower level,\n \t\t\t// set nextPairFreq impossibly large.\n-\t\t\tl.lastChain = nil\n \t\t\tl.needed = 0\n-\t\t\tl = l.up\n-\t\t\tl.nextPairFreq = math.MaxInt32\n+\t\t\tlevels[level+1].nextPairFreq = math.MaxInt32\n+\t\t\tlevel++\n \t\t\tcontinue\n \t\t}\n \n-\t\tprevFreq := l.lastChain.freq\n+\t\tprevFreq := l.lastFreq\n \t\tif l.nextCharFreq < l.nextPairFreq {\n \t\t\t// The next item on this row is a leaf node.\n-\t\t\tn := l.lastChain.leafCount + 1\n-\t\t\tl.lastChain = &chain{l.nextCharFreq, n, l.lastChain.up}\n+\t\t\tn := leafCounts[level][level] + 1\n+\t\t\tl.lastFreq = l.nextCharFreq\n+\t\t\t// Lower leafCounts are the same of the previous node.\n+\t\t\tleafCounts[level][level] = n\n \t\t\tl.nextCharFreq = list[n].freq\n \t\t} else {\n \t\t\t// The next item on this row is a pair from the previous row.\n \t\t\t// nextPairFreq isn't valid until we generate two\n \t\t\t// more values in the level below\n-\t\t\tl.lastChain = &chain{l.nextPairFreq, l.lastChain.leafCount, l.down.lastChain}\n-\t\t\tl.down.needed = 2\n+\t\t\tl.lastFreq = l.nextPairFreq\n+\t\t\t// Take leaf counts from the lower level, except counts[level] remains the same.\n+\t\t\tcopy(leafCounts[level][:level], leafCounts[level-1][:level])\n+\t\t\tlevels[l.level-1].needed = 2\n \t\t}\n \n \t\tif l.needed--; l.needed == 0 {\n \t\t\t// We've done everything we need to do for this level.\n \t\t\t// Continue calculating one level up.  Fill in nextPairFreq\n \t\t\t// of that level with the sum of the two nodes we've just calculated on\n \t\t\t// this level.\n-\t\t\tup := l.up\n-\t\t\tif up == nil {\n+\t\t\tif l.level == maxBits {\n \t\t\t\t// All done!\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tup.nextPairFreq = prevFreq + l.lastChain.freq\n-\t\t\tl = up\n+\t\t\tlevels[l.level+1].nextPairFreq = prevFreq + l.lastFreq\n+\t\t\tlevel++\n \t\t} else {\n \t\t\t// If we stole from below, move down temporarily to replenish it.\n-\t\t\tfor l.down.needed > 0 {\n-\t\t\t\tl = l.down\n+\t\t\tfor levels[level-1].needed > 0 {\n+\t\t\t\tlevel--\n \t\t\t}\n \t\t}\n \t}\n \n \t// Somethings is wrong if at the end, the top level is null or hasn't used\n \t// all of the leaves.\n-\tif top.lastChain.leafCount != n {\n-\t\tpanic(\"top.lastChain.leafCount != n\")\n+\tif leafCounts[maxBits][maxBits] != n {\n+\t\tpanic(\"leafCounts[maxBits][maxBits] != n\")\n \t}\n \n \tbitCount := make([]int32, maxBits+1)\n \tbits := 1\n-\tfor chain := top.lastChain; chain.up != nil; chain = chain.up {\n+\tcounts := &leafCounts[maxBits]\n+\tfor level := maxBits; level > 0; level-- {\n \t\t// chain.leafCount gives the number of literals requiring at least \"bits\"\n \t\t// bits to encode.\n-\t\tbitCount[bits] = chain.leafCount - chain.up.leafCount\n+\t\tbitCount[bits] = counts[level] - counts[level-1]\n \t\tbits++\n \t}\n \treturn bitCount"}, {"sha": "3eb3b2b83e6d224670f03286418dbfb22d1fe67d", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -91,6 +91,10 @@ type huffmanDecoder struct {\n \n // Initialize Huffman decoding tables from array of code lengths.\n func (h *huffmanDecoder) init(bits []int) bool {\n+\tif h.min != 0 {\n+\t\t*h = huffmanDecoder{}\n+\t}\n+\n \t// Count number of codes of each length,\n \t// compute min and max length.\n \tvar count [maxCodeLen]int\n@@ -125,6 +129,9 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\tif i == huffmanChunkBits+1 {\n \t\t\t// create link tables\n \t\t\tlink := code >> 1\n+\t\t\tif huffmanNumChunks < link {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\th.links = make([][]uint32, huffmanNumChunks-link)\n \t\t\tfor j := uint(link); j < huffmanNumChunks; j++ {\n \t\t\t\treverse := int(reverseByte[j>>8]) | int(reverseByte[j&0xff])<<8\n@@ -154,7 +161,11 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\t\t\th.chunks[off] = chunk\n \t\t\t}\n \t\t} else {\n-\t\t\tlinktab := h.links[h.chunks[reverse&(huffmanNumChunks-1)]>>huffmanValueShift]\n+\t\t\tvalue := h.chunks[reverse&(huffmanNumChunks-1)] >> huffmanValueShift\n+\t\t\tif value >= uint32(len(h.links)) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tlinktab := h.links[value]\n \t\t\treverse >>= huffmanChunkBits\n \t\t\tfor off := reverse; off < numLinks; off += 1 << uint(n-huffmanChunkBits) {\n \t\t\t\tlinktab[off] = chunk\n@@ -511,7 +522,7 @@ func (f *decompressor) copyHist() bool {\n \t\tif x := len(f.hist) - p; n > x {\n \t\t\tn = x\n \t\t}\n-\t\tforwardCopy(f.hist[f.hp:f.hp+n], f.hist[p:p+n])\n+\t\tforwardCopy(f.hist[:], f.hp, p, n)\n \t\tp += n\n \t\tf.hp += n\n \t\tf.copyLen -= n\n@@ -633,6 +644,10 @@ func (f *decompressor) huffSym(h *huffmanDecoder) (int, error) {\n \t\tif n > huffmanChunkBits {\n \t\t\tchunk = h.links[chunk>>huffmanValueShift][(f.b>>huffmanChunkBits)&h.linkMask]\n \t\t\tn = uint(chunk & huffmanCountMask)\n+\t\t\tif n == 0 {\n+\t\t\t\tf.err = CorruptInputError(f.roffset)\n+\t\t\t\treturn 0, f.err\n+\t\t\t}\n \t\t}\n \t\tif n <= f.nb {\n \t\t\tf.b >>= n"}, {"sha": "2a8ebbc9438d5952eba84d2130c1f8c4970de7d0", "filename": "libgo/go/compress/flate/reader_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -37,6 +37,7 @@ var testfiles = []string{\n }\n \n func benchmarkDecode(b *testing.B, testfile, level, n int) {\n+\tb.ReportAllocs()\n \tb.StopTimer()\n \tb.SetBytes(int64(n))\n \tbuf0, err := ioutil.ReadFile(testfiles[testfile])\n@@ -55,15 +56,15 @@ func benchmarkDecode(b *testing.B, testfile, level, n int) {\n \t\tif len(buf0) > n-i {\n \t\t\tbuf0 = buf0[:n-i]\n \t\t}\n-\t\tio.Copy(w, bytes.NewBuffer(buf0))\n+\t\tio.Copy(w, bytes.NewReader(buf0))\n \t}\n \tw.Close()\n \tbuf1 := compressed.Bytes()\n \tbuf0, compressed, w = nil, nil, nil\n \truntime.GC()\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n-\t\tio.Copy(ioutil.Discard, NewReader(bytes.NewBuffer(buf1)))\n+\t\tio.Copy(ioutil.Discard, NewReader(bytes.NewReader(buf1)))\n \t}\n }\n "}, {"sha": "572fb584885fbfd35e73abfe2f84e3b938ecf6f2", "filename": "libgo/go/compress/gzip/gunzip_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -7,7 +7,10 @@ package gzip\n import (\n \t\"bytes\"\n \t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type gunzipTest struct {\n@@ -302,3 +305,31 @@ func TestDecompressor(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestIssue6550(t *testing.T) {\n+\tf, err := os.Open(\"testdata/issue6550.gz\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tgzip, err := NewReader(f)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewReader(testdata/issue6550.gz): %v\", err)\n+\t}\n+\tdefer gzip.Close()\n+\tdone := make(chan bool, 1)\n+\tgo func() {\n+\t\t_, err := io.Copy(ioutil.Discard, gzip)\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"Copy succeeded\")\n+\t\t} else {\n+\t\t\tt.Logf(\"Copy failed (correctly): %v\", err)\n+\t\t}\n+\t\tdone <- true\n+\t}()\n+\tselect {\n+\tcase <-time.After(1 * time.Second):\n+\t\tt.Errorf(\"Copy hung\")\n+\tcase <-done:\n+\t\t// ok\n+\t}\n+}"}, {"sha": "fe32d6871ae950985b1775c354745fca73f16048", "filename": "libgo/go/compress/gzip/gzip.go", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -26,14 +26,15 @@ const (\n // to its wrapped io.Writer.\n type Writer struct {\n \tHeader\n-\tw          io.Writer\n-\tlevel      int\n-\tcompressor *flate.Writer\n-\tdigest     hash.Hash32\n-\tsize       uint32\n-\tclosed     bool\n-\tbuf        [10]byte\n-\terr        error\n+\tw           io.Writer\n+\tlevel       int\n+\twroteHeader bool\n+\tcompressor  *flate.Writer\n+\tdigest      hash.Hash32\n+\tsize        uint32\n+\tclosed      bool\n+\tbuf         [10]byte\n+\terr         error\n }\n \n // NewWriter creates a new Writer that satisfies writes by compressing data\n@@ -62,14 +63,39 @@ func NewWriterLevel(w io.Writer, level int) (*Writer, error) {\n \tif level < DefaultCompression || level > BestCompression {\n \t\treturn nil, fmt.Errorf(\"gzip: invalid compression level: %d\", level)\n \t}\n-\treturn &Writer{\n+\tz := new(Writer)\n+\tz.init(w, level)\n+\treturn z, nil\n+}\n+\n+func (z *Writer) init(w io.Writer, level int) {\n+\tdigest := z.digest\n+\tif digest != nil {\n+\t\tdigest.Reset()\n+\t} else {\n+\t\tdigest = crc32.NewIEEE()\n+\t}\n+\tcompressor := z.compressor\n+\tif compressor != nil {\n+\t\tcompressor.Reset(w)\n+\t}\n+\t*z = Writer{\n \t\tHeader: Header{\n \t\t\tOS: 255, // unknown\n \t\t},\n-\t\tw:      w,\n-\t\tlevel:  level,\n-\t\tdigest: crc32.NewIEEE(),\n-\t}, nil\n+\t\tw:          w,\n+\t\tlevel:      level,\n+\t\tdigest:     digest,\n+\t\tcompressor: compressor,\n+\t}\n+}\n+\n+// Reset discards the Writer z's state and makes it equivalent to the\n+// result of its original state from NewWriter or NewWriterLevel, but\n+// writing to w instead. This permits reusing a Writer rather than\n+// allocating a new one.\n+func (z *Writer) Reset(w io.Writer) {\n+\tz.init(w, z.level)\n }\n \n // GZIP (RFC 1952) is little-endian, unlike ZLIB (RFC 1950).\n@@ -138,7 +164,8 @@ func (z *Writer) Write(p []byte) (int, error) {\n \t}\n \tvar n int\n \t// Write the GZIP header lazily.\n-\tif z.compressor == nil {\n+\tif !z.wroteHeader {\n+\t\tz.wroteHeader = true\n \t\tz.buf[0] = gzipID1\n \t\tz.buf[1] = gzipID2\n \t\tz.buf[2] = gzipDeflate\n@@ -183,7 +210,9 @@ func (z *Writer) Write(p []byte) (int, error) {\n \t\t\t\treturn n, z.err\n \t\t\t}\n \t\t}\n-\t\tz.compressor, _ = flate.NewWriter(z.w, z.level)\n+\t\tif z.compressor == nil {\n+\t\t\tz.compressor, _ = flate.NewWriter(z.w, z.level)\n+\t\t}\n \t}\n \tz.size += uint32(len(p))\n \tz.digest.Write(p)\n@@ -206,8 +235,11 @@ func (z *Writer) Flush() error {\n \tif z.closed {\n \t\treturn nil\n \t}\n-\tif z.compressor == nil {\n+\tif !z.wroteHeader {\n \t\tz.Write(nil)\n+\t\tif z.err != nil {\n+\t\t\treturn z.err\n+\t\t}\n \t}\n \tz.err = z.compressor.Flush()\n \treturn z.err\n@@ -222,7 +254,7 @@ func (z *Writer) Close() error {\n \t\treturn nil\n \t}\n \tz.closed = true\n-\tif z.compressor == nil {\n+\tif !z.wroteHeader {\n \t\tz.Write(nil)\n \t\tif z.err != nil {\n \t\t\treturn z.err"}, {"sha": "119be2e135be34defe891aa2b7226f92305bfa83", "filename": "libgo/go/compress/gzip/gzip_test.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -197,3 +197,35 @@ func TestWriterFlush(t *testing.T) {\n \t\tt.Fatal(\"Flush didn't flush any data\")\n \t}\n }\n+\n+// Multiple gzip files concatenated form a valid gzip file.\n+func TestConcat(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tw := NewWriter(&buf)\n+\tw.Write([]byte(\"hello \"))\n+\tw.Close()\n+\tw = NewWriter(&buf)\n+\tw.Write([]byte(\"world\\n\"))\n+\tw.Close()\n+\n+\tr, err := NewReader(&buf)\n+\tdata, err := ioutil.ReadAll(r)\n+\tif string(data) != \"hello world\\n\" || err != nil {\n+\t\tt.Fatalf(\"ReadAll = %q, %v, want %q, nil\", data, err, \"hello world\")\n+\t}\n+}\n+\n+func TestWriterReset(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\tbuf2 := new(bytes.Buffer)\n+\tz := NewWriter(buf)\n+\tmsg := []byte(\"hello world\")\n+\tz.Write(msg)\n+\tz.Close()\n+\tz.Reset(buf2)\n+\tz.Write(msg)\n+\tz.Close()\n+\tif buf.String() != buf2.String() {\n+\t\tt.Errorf(\"buf2 %q != original buf of %q\", buf2.String(), buf.String())\n+\t}\n+}"}, {"sha": "57972b636680170bbe26d3876481b24f54d4ab55", "filename": "libgo/go/compress/gzip/testdata/issue6550.gz", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fgzip%2Ftestdata%2Fissue6550.gz", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fgzip%2Ftestdata%2Fissue6550.gz", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Ftestdata%2Fissue6550.gz?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "99ff6549acb751494fdc9a649cbabb485bc231f2", "filename": "libgo/go/compress/zlib/writer.go", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -70,6 +70,23 @@ func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n \t}, nil\n }\n \n+// Reset clears the state of the Writer z such that it is equivalent to its\n+// initial state from NewWriterLevel or NewWriterLevelDict, but instead writing\n+// to w.\n+func (z *Writer) Reset(w io.Writer) {\n+\tz.w = w\n+\t// z.level and z.dict left unchanged.\n+\tif z.compressor != nil {\n+\t\tz.compressor.Reset(w)\n+\t}\n+\tif z.digest != nil {\n+\t\tz.digest.Reset()\n+\t}\n+\tz.err = nil\n+\tz.scratch = [4]byte{}\n+\tz.wroteHeader = false\n+}\n+\n // writeHeader writes the ZLIB header.\n func (z *Writer) writeHeader() (err error) {\n \tz.wroteHeader = true\n@@ -111,11 +128,15 @@ func (z *Writer) writeHeader() (err error) {\n \t\t\treturn err\n \t\t}\n \t}\n-\tz.compressor, err = flate.NewWriterDict(z.w, z.level, z.dict)\n-\tif err != nil {\n-\t\treturn err\n+\tif z.compressor == nil {\n+\t\t// Initialize deflater unless the Writer is being reused\n+\t\t// after a Reset call.\n+\t\tz.compressor, err = flate.NewWriterDict(z.w, z.level, z.dict)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tz.digest = adler32.New()\n \t}\n-\tz.digest = adler32.New()\n \treturn nil\n }\n "}, {"sha": "cf9c832545554639bf1ec81384ca5bdf0bd90ce0", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -89,6 +89,56 @@ func testLevelDict(t *testing.T, fn string, b0 []byte, level int, d string) {\n \t}\n }\n \n+func testFileLevelDictReset(t *testing.T, fn string, level int, dict []byte) {\n+\tvar b0 []byte\n+\tvar err error\n+\tif fn != \"\" {\n+\t\tb0, err = ioutil.ReadFile(fn)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// Compress once.\n+\tbuf := new(bytes.Buffer)\n+\tvar zlibw *Writer\n+\tif dict == nil {\n+\t\tzlibw, err = NewWriterLevel(buf, level)\n+\t} else {\n+\t\tzlibw, err = NewWriterLevelDict(buf, level, dict)\n+\t}\n+\tif err == nil {\n+\t\t_, err = zlibw.Write(b0)\n+\t}\n+\tif err == nil {\n+\t\terr = zlibw.Close()\n+\t}\n+\tif err != nil {\n+\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n+\t\treturn\n+\t}\n+\tout := buf.String()\n+\n+\t// Reset and comprses again.\n+\tbuf2 := new(bytes.Buffer)\n+\tzlibw.Reset(buf2)\n+\t_, err = zlibw.Write(b0)\n+\tif err == nil {\n+\t\terr = zlibw.Close()\n+\t}\n+\tif err != nil {\n+\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n+\t\treturn\n+\t}\n+\tout2 := buf2.String()\n+\n+\tif out2 != out {\n+\t\tt.Errorf(\"%s (level=%d): different output after reset (got %d bytes, expected %d\",\n+\t\t\tfn, level, len(out2), len(out))\n+\t}\n+}\n+\n func TestWriter(t *testing.T) {\n \tfor i, s := range data {\n \t\tb := []byte(s)\n@@ -122,6 +172,21 @@ func TestWriterDict(t *testing.T) {\n \t}\n }\n \n+func TestWriterReset(t *testing.T) {\n+\tconst dictionary = \"0123456789.\"\n+\tfor _, fn := range filenames {\n+\t\ttestFileLevelDictReset(t, fn, NoCompression, nil)\n+\t\ttestFileLevelDictReset(t, fn, DefaultCompression, nil)\n+\t\ttestFileLevelDictReset(t, fn, NoCompression, []byte(dictionary))\n+\t\ttestFileLevelDictReset(t, fn, DefaultCompression, []byte(dictionary))\n+\t\tif !testing.Short() {\n+\t\t\tfor level := BestSpeed; level <= BestCompression; level++ {\n+\t\t\t\ttestFileLevelDictReset(t, fn, level, nil)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n func TestWriterDictIsUsed(t *testing.T) {\n \tvar input = []byte(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\")\n \tvar buf bytes.Buffer"}, {"sha": "52c8507b4219bfe9af5a19d449b2fcf0bd2b5e52", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,6 +6,8 @@\n // heap.Interface. A heap is a tree with the property that each node is the\n // minimum-valued node in its subtree.\n //\n+// The minimum element in the tree is the root, at index 0.\n+//\n // A heap is a common way to implement a priority queue. To build a priority\n // queue, implement the Heap interface with the (negative) priority as the\n // ordering for the Less method, so Push adds items while Pop removes the\n@@ -54,7 +56,7 @@ func Push(h Interface, x interface{}) {\n \n // Pop removes the minimum element (according to Less) from the heap\n // and returns it. The complexity is O(log(n)) where n = h.Len().\n-// Same as Remove(h, 0).\n+// It is equivalent to Remove(h, 0).\n //\n func Pop(h Interface) interface{} {\n \tn := h.Len() - 1\n@@ -76,6 +78,15 @@ func Remove(h Interface, i int) interface{} {\n \treturn h.Pop()\n }\n \n+// Fix reestablishes the heap ordering after the element at index i has changed its value.\n+// Changing the value of the element at index i and then calling Fix is equivalent to,\n+// but less expensive than, calling Remove(h, i) followed by a Push of the new value.\n+// The complexity is O(log(n)) where n = h.Len().\n+func Fix(h Interface, i int) {\n+\tdown(h, i, h.Len())\n+\tup(h, i)\n+}\n+\n func up(h Interface, j int) {\n \tfor {\n \t\ti := (j - 1) / 2 // parent"}, {"sha": "b3d054c5f39783e3832ec3d68d15431caa9651a0", "filename": "libgo/go/container/heap/heap_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -5,6 +5,7 @@\n package heap\n \n import (\n+\t\"math/rand\"\n \t\"testing\"\n )\n \n@@ -182,3 +183,31 @@ func BenchmarkDup(b *testing.B) {\n \t\t}\n \t}\n }\n+\n+func TestFix(t *testing.T) {\n+\th := new(myHeap)\n+\th.verify(t, 0)\n+\n+\tfor i := 200; i > 0; i -= 10 {\n+\t\tPush(h, i)\n+\t}\n+\th.verify(t, 0)\n+\n+\tif (*h)[0] != 10 {\n+\t\tt.Fatalf(\"Expected head to be 10, was %d\", (*h)[0])\n+\t}\n+\t(*h)[0] = 210\n+\tFix(h, 0)\n+\th.verify(t, 0)\n+\n+\tfor i := 100; i > 0; i-- {\n+\t\telem := rand.Intn(h.Len())\n+\t\tif i&1 == 0 {\n+\t\t\t(*h)[elem] *= 2\n+\t\t} else {\n+\t\t\t(*h)[elem] /= 2\n+\t\t}\n+\t\tFix(h, elem)\n+\t\th.verify(t, 0)\n+\t}\n+}"}, {"sha": "ed2d15a45756a32d3346e6e931e24a26935afd35", "filename": "libgo/go/container/list/list.go", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -29,15 +29,15 @@ type Element struct {\n \n // Next returns the next list element or nil.\n func (e *Element) Next() *Element {\n-\tif p := e.next; p != &e.list.root {\n+\tif p := e.next; e.list != nil && p != &e.list.root {\n \t\treturn p\n \t}\n \treturn nil\n }\n \n // Prev returns the previous list element or nil.\n func (e *Element) Prev() *Element {\n-\tif p := e.prev; p != &e.list.root {\n+\tif p := e.prev; e.list != nil && p != &e.list.root {\n \t\treturn p\n \t}\n \treturn nil\n@@ -62,6 +62,7 @@ func (l *List) Init() *List {\n func New() *List { return new(List).Init() }\n \n // Len returns the number of elements of list l.\n+// The complexity is O(1).\n func (l *List) Len() int { return l.len }\n \n // Front returns the first element of list l or nil\n@@ -126,7 +127,7 @@ func (l *List) Remove(e *Element) interface{} {\n \treturn e.Value\n }\n \n-// Pushfront inserts a new element e with value v at the front of list l and returns e.\n+// PushFront inserts a new element e with value v at the front of list l and returns e.\n func (l *List) PushFront(v interface{}) *Element {\n \tl.lazyInit()\n \treturn l.insertValue(v, &l.root)\n@@ -178,6 +179,24 @@ func (l *List) MoveToBack(e *Element) {\n \tl.insert(l.remove(e), l.root.prev)\n }\n \n+// MoveBefore moves element e to its new position before mark.\n+// If e is not an element of l, or e == mark, the list is not modified.\n+func (l *List) MoveBefore(e, mark *Element) {\n+\tif e.list != l || e == mark {\n+\t\treturn\n+\t}\n+\tl.insert(l.remove(e), mark.prev)\n+}\n+\n+// MoveAfter moves element e to its new position after mark.\n+// If e is not an element of l, or e == mark, the list is not modified.\n+func (l *List) MoveAfter(e, mark *Element) {\n+\tif e.list != l || e == mark {\n+\t\treturn\n+\t}\n+\tl.insert(l.remove(e), mark)\n+}\n+\n // PushBackList inserts a copy of an other list at the back of list l.\n // The lists l and other may be the same.\n func (l *List) PushBackList(other *List) {"}, {"sha": "ee52afe82b9aac13c4ad0d6cd10edf62009f0d20", "filename": "libgo/go/container/list/list_test.go", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -233,3 +233,55 @@ func TestIssue4103(t *testing.T) {\n \t\tt.Errorf(\"l1.Len() = %d, want 3\", n)\n \t}\n }\n+\n+func TestIssue6349(t *testing.T) {\n+\tl := New()\n+\tl.PushBack(1)\n+\tl.PushBack(2)\n+\n+\te := l.Front()\n+\tl.Remove(e)\n+\tif e.Value != 1 {\n+\t\tt.Errorf(\"e.value = %d, want 1\", e.Value)\n+\t}\n+\tif e.Next() != nil {\n+\t\tt.Errorf(\"e.Next() != nil\")\n+\t}\n+\tif e.Prev() != nil {\n+\t\tt.Errorf(\"e.Prev() != nil\")\n+\t}\n+}\n+\n+func TestMove(t *testing.T) {\n+\tl := New()\n+\te1 := l.PushBack(1)\n+\te2 := l.PushBack(2)\n+\te3 := l.PushBack(3)\n+\te4 := l.PushBack(4)\n+\n+\tl.MoveAfter(e3, e3)\n+\tcheckListPointers(t, l, []*Element{e1, e2, e3, e4})\n+\tl.MoveBefore(e2, e2)\n+\tcheckListPointers(t, l, []*Element{e1, e2, e3, e4})\n+\n+\tl.MoveAfter(e3, e2)\n+\tcheckListPointers(t, l, []*Element{e1, e2, e3, e4})\n+\tl.MoveBefore(e2, e3)\n+\tcheckListPointers(t, l, []*Element{e1, e2, e3, e4})\n+\n+\tl.MoveBefore(e2, e4)\n+\tcheckListPointers(t, l, []*Element{e1, e3, e2, e4})\n+\te1, e2, e3, e4 = e1, e3, e2, e4\n+\n+\tl.MoveBefore(e4, e1)\n+\tcheckListPointers(t, l, []*Element{e4, e1, e2, e3})\n+\te1, e2, e3, e4 = e4, e1, e2, e3\n+\n+\tl.MoveAfter(e4, e1)\n+\tcheckListPointers(t, l, []*Element{e1, e4, e2, e3})\n+\te1, e2, e3, e4 = e1, e4, e2, e3\n+\n+\tl.MoveAfter(e2, e3)\n+\tcheckListPointers(t, l, []*Element{e1, e3, e2, e4})\n+\te1, e2, e3, e4 = e1, e3, e2, e4\n+}"}, {"sha": "4189677e390a470338d6e655c569558a26f9b93e", "filename": "libgo/go/crypto/cipher/cbc.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -61,6 +61,13 @@ func (x *cbcEncrypter) CryptBlocks(dst, src []byte) {\n \t}\n }\n \n+func (x *cbcEncrypter) SetIV(iv []byte) {\n+\tif len(iv) != len(x.iv) {\n+\t\tpanic(\"cipher: incorrect length IV\")\n+\t}\n+\tcopy(x.iv, iv)\n+}\n+\n type cbcDecrypter cbc\n \n // NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\n@@ -94,3 +101,10 @@ func (x *cbcDecrypter) CryptBlocks(dst, src []byte) {\n \t\tdst = dst[x.blockSize:]\n \t}\n }\n+\n+func (x *cbcDecrypter) SetIV(iv []byte) {\n+\tif len(iv) != len(x.iv) {\n+\t\tpanic(\"cipher: incorrect length IV\")\n+\t}\n+\tcopy(x.iv, iv)\n+}"}, {"sha": "2bcb469852b83f1715eeeb177ad28070e04e9e2d", "filename": "libgo/go/crypto/cipher/gcm.go", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -0,0 +1,350 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cipher\n+\n+import (\n+\t\"crypto/subtle\"\n+\t\"errors\"\n+)\n+\n+// AEAD is a cipher mode providing authenticated encryption with associated\n+// data.\n+type AEAD interface {\n+\t// NonceSize returns the size of the nonce that must be passed to Seal\n+\t// and Open.\n+\tNonceSize() int\n+\n+\t// Overhead returns the maximum difference between the lengths of a\n+\t// plaintext and ciphertext.\n+\tOverhead() int\n+\n+\t// Seal encrypts and authenticates plaintext, authenticates the\n+\t// additional data and appends the result to dst, returning the updated\n+\t// slice. The nonce must be NonceSize() bytes long and unique for all\n+\t// time, for a given key.\n+\t//\n+\t// The plaintext and dst may alias exactly or not at all.\n+\tSeal(dst, nonce, plaintext, data []byte) []byte\n+\n+\t// Open decrypts and authenticates ciphertext, authenticates the\n+\t// additional data and, if successful, appends the resulting plaintext\n+\t// to dst, returning the updated slice and true. On error, nil and\n+\t// false is returned. The nonce must be NonceSize() bytes long and both\n+\t// it and the additional data must match the value passed to Seal.\n+\t//\n+\t// The ciphertext and dst may alias exactly or not at all.\n+\tOpen(dst, nonce, ciphertext, data []byte) ([]byte, error)\n+}\n+\n+// gcmFieldElement represents a value in GF(2\u00b9\u00b2\u2078). In order to reflect the GCM\n+// standard and make getUint64 suitable for marshaling these values, the bits\n+// are stored backwards. For example:\n+//   the coefficient of x\u2070 can be obtained by v.low >> 63.\n+//   the coefficient of x\u2076\u00b3 can be obtained by v.low & 1.\n+//   the coefficient of x\u2076\u2074 can be obtained by v.high >> 63.\n+//   the coefficient of x\u00b9\u00b2\u2077 can be obtained by v.high & 1.\n+type gcmFieldElement struct {\n+\tlow, high uint64\n+}\n+\n+// gcm represents a Galois Counter Mode with a specific key. See\n+// http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-revised-spec.pdf\n+type gcm struct {\n+\tcipher Block\n+\t// productTable contains the first sixteen powers of the key, H.\n+\t// However, they are in bit reversed order. See NewGCM.\n+\tproductTable [16]gcmFieldElement\n+}\n+\n+// NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode.\n+func NewGCM(cipher Block) (AEAD, error) {\n+\tif cipher.BlockSize() != gcmBlockSize {\n+\t\treturn nil, errors.New(\"cipher: NewGCM requires 128-bit block cipher\")\n+\t}\n+\n+\tvar key [gcmBlockSize]byte\n+\tcipher.Encrypt(key[:], key[:])\n+\n+\tg := &gcm{cipher: cipher}\n+\n+\t// We precompute 16 multiples of |key|. However, when we do lookups\n+\t// into this table we'll be using bits from a field element and\n+\t// therefore the bits will be in the reverse order. So normally one\n+\t// would expect, say, 4*key to be in index 4 of the table but due to\n+\t// this bit ordering it will actually be in index 0010 (base 2) = 2.\n+\tx := gcmFieldElement{\n+\t\tgetUint64(key[:8]),\n+\t\tgetUint64(key[8:]),\n+\t}\n+\tg.productTable[reverseBits(1)] = x\n+\n+\tfor i := 2; i < 16; i += 2 {\n+\t\tg.productTable[reverseBits(i)] = gcmDouble(&g.productTable[reverseBits(i/2)])\n+\t\tg.productTable[reverseBits(i+1)] = gcmAdd(&g.productTable[reverseBits(i)], &x)\n+\t}\n+\n+\treturn g, nil\n+}\n+\n+const (\n+\tgcmBlockSize = 16\n+\tgcmTagSize   = 16\n+\tgcmNonceSize = 12\n+)\n+\n+func (*gcm) NonceSize() int {\n+\treturn gcmNonceSize\n+}\n+\n+func (*gcm) Overhead() int {\n+\treturn gcmTagSize\n+}\n+\n+func (g *gcm) Seal(dst, nonce, plaintext, data []byte) []byte {\n+\tif len(nonce) != gcmNonceSize {\n+\t\tpanic(\"cipher: incorrect nonce length given to GCM\")\n+\t}\n+\n+\tret, out := sliceForAppend(dst, len(plaintext)+gcmTagSize)\n+\n+\t// See GCM spec, section 7.1.\n+\tvar counter, tagMask [gcmBlockSize]byte\n+\tcopy(counter[:], nonce)\n+\tcounter[gcmBlockSize-1] = 1\n+\n+\tg.cipher.Encrypt(tagMask[:], counter[:])\n+\tgcmInc32(&counter)\n+\n+\tg.counterCrypt(out, plaintext, &counter)\n+\tg.auth(out[len(plaintext):], out[:len(plaintext)], data, &tagMask)\n+\n+\treturn ret\n+}\n+\n+var errOpen = errors.New(\"cipher: message authentication failed\")\n+\n+func (g *gcm) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n+\tif len(nonce) != gcmNonceSize {\n+\t\tpanic(\"cipher: incorrect nonce length given to GCM\")\n+\t}\n+\n+\tif len(ciphertext) < gcmTagSize {\n+\t\treturn nil, errOpen\n+\t}\n+\ttag := ciphertext[len(ciphertext)-gcmTagSize:]\n+\tciphertext = ciphertext[:len(ciphertext)-gcmTagSize]\n+\n+\t// See GCM spec, section 7.1.\n+\tvar counter, tagMask [gcmBlockSize]byte\n+\tcopy(counter[:], nonce)\n+\tcounter[gcmBlockSize-1] = 1\n+\n+\tg.cipher.Encrypt(tagMask[:], counter[:])\n+\tgcmInc32(&counter)\n+\n+\tvar expectedTag [gcmTagSize]byte\n+\tg.auth(expectedTag[:], ciphertext, data, &tagMask)\n+\n+\tif subtle.ConstantTimeCompare(expectedTag[:], tag) != 1 {\n+\t\treturn nil, errOpen\n+\t}\n+\n+\tret, out := sliceForAppend(dst, len(ciphertext))\n+\tg.counterCrypt(out, ciphertext, &counter)\n+\n+\treturn ret, nil\n+}\n+\n+// reverseBits reverses the order of the bits of 4-bit number in i.\n+func reverseBits(i int) int {\n+\ti = ((i << 2) & 0xc) | ((i >> 2) & 0x3)\n+\ti = ((i << 1) & 0xa) | ((i >> 1) & 0x5)\n+\treturn i\n+}\n+\n+// gcmAdd adds two elements of GF(2\u00b9\u00b2\u2078) and returns the sum.\n+func gcmAdd(x, y *gcmFieldElement) gcmFieldElement {\n+\t// Addition in a characteristic 2 field is just XOR.\n+\treturn gcmFieldElement{x.low ^ y.low, x.high ^ y.high}\n+}\n+\n+// gcmDouble returns the result of doubling an element of GF(2\u00b9\u00b2\u2078).\n+func gcmDouble(x *gcmFieldElement) (double gcmFieldElement) {\n+\tmsbSet := x.high&1 == 1\n+\n+\t// Because of the bit-ordering, doubling is actually a right shift.\n+\tdouble.high = x.high >> 1\n+\tdouble.high |= x.low << 63\n+\tdouble.low = x.low >> 1\n+\n+\t// If the most-significant bit was set before shifting then it,\n+\t// conceptually, becomes a term of x^128. This is greater than the\n+\t// irreducible polynomial so the result has to be reduced. The\n+\t// irreducible polynomial is 1+x+x^2+x^7+x^128. We can subtract that to\n+\t// eliminate the term at x^128 which also means subtracting the other\n+\t// four terms. In characteristic 2 fields, subtraction == addition ==\n+\t// XOR.\n+\tif msbSet {\n+\t\tdouble.low ^= 0xe100000000000000\n+\t}\n+\n+\treturn\n+}\n+\n+var gcmReductionTable = []uint16{\n+\t0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0,\n+\t0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0,\n+}\n+\n+// mul sets y to y*H, where H is the GCM key, fixed during NewGCM.\n+func (g *gcm) mul(y *gcmFieldElement) {\n+\tvar z gcmFieldElement\n+\n+\tfor i := 0; i < 2; i++ {\n+\t\tword := y.high\n+\t\tif i == 1 {\n+\t\t\tword = y.low\n+\t\t}\n+\n+\t\t// Multiplication works by multiplying z by 16 and adding in\n+\t\t// one of the precomputed multiples of H.\n+\t\tfor j := 0; j < 64; j += 4 {\n+\t\t\tmsw := z.high & 0xf\n+\t\t\tz.high >>= 4\n+\t\t\tz.high |= z.low << 60\n+\t\t\tz.low >>= 4\n+\t\t\tz.low ^= uint64(gcmReductionTable[msw]) << 48\n+\n+\t\t\t// the values in |table| are ordered for\n+\t\t\t// little-endian bit positions. See the comment\n+\t\t\t// in NewGCM.\n+\t\t\tt := &g.productTable[word&0xf]\n+\n+\t\t\tz.low ^= t.low\n+\t\t\tz.high ^= t.high\n+\t\t\tword >>= 4\n+\t\t}\n+\t}\n+\n+\t*y = z\n+}\n+\n+// updateBlocks extends y with more polynomial terms from blocks, based on\n+// Horner's rule. There must be a multiple of gcmBlockSize bytes in blocks.\n+func (g *gcm) updateBlocks(y *gcmFieldElement, blocks []byte) {\n+\tfor len(blocks) > 0 {\n+\t\ty.low ^= getUint64(blocks)\n+\t\ty.high ^= getUint64(blocks[8:])\n+\t\tg.mul(y)\n+\t\tblocks = blocks[gcmBlockSize:]\n+\t}\n+}\n+\n+// update extends y with more polynomial terms from data. If data is not a\n+// multiple of gcmBlockSize bytes long then the remainder is zero padded.\n+func (g *gcm) update(y *gcmFieldElement, data []byte) {\n+\tfullBlocks := (len(data) >> 4) << 4\n+\tg.updateBlocks(y, data[:fullBlocks])\n+\n+\tif len(data) != fullBlocks {\n+\t\tvar partialBlock [gcmBlockSize]byte\n+\t\tcopy(partialBlock[:], data[fullBlocks:])\n+\t\tg.updateBlocks(y, partialBlock[:])\n+\t}\n+}\n+\n+// gcmInc32 treats the final four bytes of counterBlock as a big-endian value\n+// and increments it.\n+func gcmInc32(counterBlock *[16]byte) {\n+\tc := 1\n+\tfor i := gcmBlockSize - 1; i >= gcmBlockSize-4; i-- {\n+\t\tc += int(counterBlock[i])\n+\t\tcounterBlock[i] = byte(c)\n+\t\tc >>= 8\n+\t}\n+}\n+\n+// sliceForAppend takes a slice and a requested number of bytes. It returns a\n+// slice with the contents of the given slice followed by that many bytes and a\n+// second slice that aliases into it and contains only the extra bytes. If the\n+// original slice has sufficient capacity then no allocation is performed.\n+func sliceForAppend(in []byte, n int) (head, tail []byte) {\n+\tif total := len(in) + n; cap(in) >= total {\n+\t\thead = in[:total]\n+\t} else {\n+\t\thead = make([]byte, total)\n+\t\tcopy(head, in)\n+\t}\n+\ttail = head[len(in):]\n+\treturn\n+}\n+\n+// counterCrypt crypts in to out using g.cipher in counter mode.\n+func (g *gcm) counterCrypt(out, in []byte, counter *[gcmBlockSize]byte) {\n+\tvar mask [gcmBlockSize]byte\n+\n+\tfor len(in) >= gcmBlockSize {\n+\t\tg.cipher.Encrypt(mask[:], counter[:])\n+\t\tgcmInc32(counter)\n+\n+\t\tfor i := range mask {\n+\t\t\tout[i] = in[i] ^ mask[i]\n+\t\t}\n+\t\tout = out[gcmBlockSize:]\n+\t\tin = in[gcmBlockSize:]\n+\t}\n+\n+\tif len(in) > 0 {\n+\t\tg.cipher.Encrypt(mask[:], counter[:])\n+\t\tgcmInc32(counter)\n+\n+\t\tfor i := range in {\n+\t\t\tout[i] = in[i] ^ mask[i]\n+\t\t}\n+\t}\n+}\n+\n+// auth calculates GHASH(ciphertext, additionalData), masks the result with\n+// tagMask and writes the result to out.\n+func (g *gcm) auth(out, ciphertext, additionalData []byte, tagMask *[gcmTagSize]byte) {\n+\tvar y gcmFieldElement\n+\tg.update(&y, additionalData)\n+\tg.update(&y, ciphertext)\n+\n+\ty.low ^= uint64(len(additionalData)) * 8\n+\ty.high ^= uint64(len(ciphertext)) * 8\n+\n+\tg.mul(&y)\n+\n+\tputUint64(out, y.low)\n+\tputUint64(out[8:], y.high)\n+\n+\tfor i := range tagMask {\n+\t\tout[i] ^= tagMask[i]\n+\t}\n+}\n+\n+func getUint64(data []byte) uint64 {\n+\tr := uint64(data[0])<<56 |\n+\t\tuint64(data[1])<<48 |\n+\t\tuint64(data[2])<<40 |\n+\t\tuint64(data[3])<<32 |\n+\t\tuint64(data[4])<<24 |\n+\t\tuint64(data[5])<<16 |\n+\t\tuint64(data[6])<<8 |\n+\t\tuint64(data[7])\n+\treturn r\n+}\n+\n+func putUint64(out []byte, v uint64) {\n+\tout[0] = byte(v >> 56)\n+\tout[1] = byte(v >> 48)\n+\tout[2] = byte(v >> 40)\n+\tout[3] = byte(v >> 32)\n+\tout[4] = byte(v >> 24)\n+\tout[5] = byte(v >> 16)\n+\tout[6] = byte(v >> 8)\n+\tout[7] = byte(v)\n+}"}, {"sha": "02d421590061bac3c3a9ae2c3545115618159d72", "filename": "libgo/go/crypto/cipher/gcm_test.go", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -0,0 +1,175 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cipher_test\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/aes\"\n+\t\"crypto/cipher\"\n+\t\"encoding/hex\"\n+\t\"testing\"\n+)\n+\n+// AES-GCM test vectors taken from gcmEncryptExtIV128.rsp from\n+// http://csrc.nist.gov/groups/STM/cavp/index.html.\n+var aesGCMTests = []struct {\n+\tkey, nonce, plaintext, ad, result string\n+}{\n+\t{\n+\t\t\"11754cd72aec309bf52f7687212e8957\",\n+\t\t\"3c819d9a9bed087615030b65\",\n+\t\t\"\",\n+\t\t\"\",\n+\t\t\"250327c674aaf477aef2675748cf6971\",\n+\t},\n+\t{\n+\t\t\"ca47248ac0b6f8372a97ac43508308ed\",\n+\t\t\"ffd2b598feabc9019262d2be\",\n+\t\t\"\",\n+\t\t\"\",\n+\t\t\"60d20404af527d248d893ae495707d1a\",\n+\t},\n+\t{\n+\t\t\"77be63708971c4e240d1cb79e8d77feb\",\n+\t\t\"e0e00f19fed7ba0136a797f3\",\n+\t\t\"\",\n+\t\t\"7a43ec1d9c0a5a78a0b16533a6213cab\",\n+\t\t\"209fcc8d3675ed938e9c7166709dd946\",\n+\t},\n+\t{\n+\t\t\"7680c5d3ca6154758e510f4d25b98820\",\n+\t\t\"f8f105f9c3df4965780321f8\",\n+\t\t\"\",\n+\t\t\"c94c410194c765e3dcc7964379758ed3\",\n+\t\t\"94dca8edfcf90bb74b153c8d48a17930\",\n+\t},\n+\t{\n+\t\t\"7fddb57453c241d03efbed3ac44e371c\",\n+\t\t\"ee283a3fc75575e33efd4887\",\n+\t\t\"d5de42b461646c255c87bd2962d3b9a2\",\n+\t\t\"\",\n+\t\t\"2ccda4a5415cb91e135c2a0f78c9b2fdb36d1df9b9d5e596f83e8b7f52971cb3\",\n+\t},\n+\t{\n+\t\t\"ab72c77b97cb5fe9a382d9fe81ffdbed\",\n+\t\t\"54cc7dc2c37ec006bcc6d1da\",\n+\t\t\"007c5e5b3e59df24a7c355584fc1518d\",\n+\t\t\"\",\n+\t\t\"0e1bde206a07a9c2c1b65300f8c649972b4401346697138c7a4891ee59867d0c\",\n+\t},\n+\t{\n+\t\t\"fe47fcce5fc32665d2ae399e4eec72ba\",\n+\t\t\"5adb9609dbaeb58cbd6e7275\",\n+\t\t\"7c0e88c88899a779228465074797cd4c2e1498d259b54390b85e3eef1c02df60e743f1b840382c4bccaf3bafb4ca8429bea063\",\n+\t\t\"88319d6e1d3ffa5f987199166c8a9b56c2aeba5a\",\n+\t\t\"98f4826f05a265e6dd2be82db241c0fbbbf9ffb1c173aa83964b7cf5393043736365253ddbc5db8778371495da76d269e5db3e291ef1982e4defedaa2249f898556b47\",\n+\t},\n+\t{\n+\t\t\"ec0c2ba17aa95cd6afffe949da9cc3a8\",\n+\t\t\"296bce5b50b7d66096d627ef\",\n+\t\t\"b85b3753535b825cbe5f632c0b843c741351f18aa484281aebec2f45bb9eea2d79d987b764b9611f6c0f8641843d5d58f3a242\",\n+\t\t\"f8d00f05d22bf68599bcdeb131292ad6e2df5d14\",\n+\t\t\"a7443d31c26bdf2a1c945e29ee4bd344a99cfaf3aa71f8b3f191f83c2adfc7a07162995506fde6309ffc19e716eddf1a828c5a890147971946b627c40016da1ecf3e77\",\n+\t},\n+\t{\n+\t\t\"2c1f21cf0f6fb3661943155c3e3d8492\",\n+\t\t\"23cb5ff362e22426984d1907\",\n+\t\t\"42f758836986954db44bf37c6ef5e4ac0adaf38f27252a1b82d02ea949c8a1a2dbc0d68b5615ba7c1220ff6510e259f06655d8\",\n+\t\t\"5d3624879d35e46849953e45a32a624d6a6c536ed9857c613b572b0333e701557a713e3f010ecdf9a6bd6c9e3e44b065208645aff4aabee611b391528514170084ccf587177f4488f33cfb5e979e42b6e1cfc0a60238982a7aec\",\n+\t\t\"81824f0e0d523db30d3da369fdc0d60894c7a0a20646dd015073ad2732bd989b14a222b6ad57af43e1895df9dca2a5344a62cc57a3ee28136e94c74838997ae9823f3a\",\n+\t},\n+\t{\n+\t\t\"d9f7d2411091f947b4d6f1e2d1f0fb2e\",\n+\t\t\"e1934f5db57cc983e6b180e7\",\n+\t\t\"73ed042327f70fe9c572a61545eda8b2a0c6e1d6c291ef19248e973aee6c312012f490c2c6f6166f4a59431e182663fcaea05a\",\n+\t\t\"0a8a18a7150e940c3d87b38e73baee9a5c049ee21795663e264b694a949822b639092d0e67015e86363583fcf0ca645af9f43375f05fdb4ce84f411dcbca73c2220dea03a20115d2e51398344b16bee1ed7c499b353d6c597af8\",\n+\t\t\"aaadbd5c92e9151ce3db7210b8714126b73e43436d242677afa50384f2149b831f1d573c7891c2a91fbc48db29967ec9542b2321b51ca862cb637cdd03b99a0f93b134\",\n+\t},\n+\t{\n+\t\t\"fe9bb47deb3a61e423c2231841cfd1fb\",\n+\t\t\"4d328eb776f500a2f7fb47aa\",\n+\t\t\"f1cc3818e421876bb6b8bbd6c9\",\n+\t\t\"\",\n+\t\t\"b88c5c1977b35b517b0aeae96743fd4727fe5cdb4b5b42818dea7ef8c9\",\n+\t},\n+\t{\n+\t\t\"6703df3701a7f54911ca72e24dca046a\",\n+\t\t\"12823ab601c350ea4bc2488c\",\n+\t\t\"793cd125b0b84a043e3ac67717\",\n+\t\t\"\",\n+\t\t\"b2051c80014f42f08735a7b0cd38e6bcd29962e5f2c13626b85a877101\",\n+\t},\n+}\n+\n+func TestAESGCM(t *testing.T) {\n+\tfor i, test := range aesGCMTests {\n+\t\tkey, _ := hex.DecodeString(test.key)\n+\t\taes, err := aes.NewCipher(key)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tnonce, _ := hex.DecodeString(test.nonce)\n+\t\tplaintext, _ := hex.DecodeString(test.plaintext)\n+\t\tad, _ := hex.DecodeString(test.ad)\n+\t\taesgcm, err := cipher.NewGCM(aes)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tct := aesgcm.Seal(nil, nonce, plaintext, ad)\n+\t\tif ctHex := hex.EncodeToString(ct); ctHex != test.result {\n+\t\t\tt.Errorf(\"#%d: got %s, want %s\", i, ctHex, test.result)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tplaintext2, err := aesgcm.Open(nil, nonce, ct, ad)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: Open failed\", i)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif !bytes.Equal(plaintext, plaintext2) {\n+\t\t\tt.Errorf(\"#%d: plaintext's don't match: got %x vs %x\", i, plaintext2, plaintext)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif len(ad) > 0 {\n+\t\t\tad[0] ^= 0x80\n+\t\t\tif _, err := aesgcm.Open(nil, nonce, ct, ad); err == nil {\n+\t\t\t\tt.Errorf(\"#%d: Open was successful after altering additional data\", i)\n+\t\t\t}\n+\t\t\tad[0] ^= 0x80\n+\t\t}\n+\n+\t\tnonce[0] ^= 0x80\n+\t\tif _, err := aesgcm.Open(nil, nonce, ct, ad); err == nil {\n+\t\t\tt.Errorf(\"#%d: Open was successful after altering nonce\", i)\n+\t\t}\n+\t\tnonce[0] ^= 0x80\n+\n+\t\tct[0] ^= 0x80\n+\t\tif _, err := aesgcm.Open(nil, nonce, ct, ad); err == nil {\n+\t\t\tt.Errorf(\"#%d: Open was successful after altering ciphertext\", i)\n+\t\t}\n+\t\tct[0] ^= 0x80\n+\t}\n+}\n+\n+func BenchmarkAESGCM(b *testing.B) {\n+\tbuf := make([]byte, 1024)\n+\tb.SetBytes(int64(len(buf)))\n+\n+\tvar key [16]byte\n+\tvar nonce [12]byte\n+\taes, _ := aes.NewCipher(key[:])\n+\taesgcm, _ := cipher.NewGCM(aes)\n+\tvar out []byte\n+\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tout = aesgcm.Seal(out[:0], nonce[:], buf, nonce[:])\n+\t}\n+}"}, {"sha": "3938c0a4c8883e20a0d8989a9786bc09845d5d71", "filename": "libgo/go/crypto/cipher/io.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -25,6 +25,8 @@ func (r StreamReader) Read(dst []byte) (n int, err error) {\n // StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream\n // to process each slice of data which passes through. If any Write call\n // returns short then the StreamWriter is out of sync and must be discarded.\n+// A StreamWriter has no internal buffering; Close does not need\n+// to be called to flush write data.\n type StreamWriter struct {\n \tS   Stream\n \tW   io.Writer\n@@ -43,8 +45,11 @@ func (w StreamWriter) Write(src []byte) (n int, err error) {\n \treturn\n }\n \n+// Close closes the underlying Writer and returns its Close return value, if the Writer\n+// is also an io.Closer. Otherwise it returns nil.\n func (w StreamWriter) Close() error {\n-\t// This saves us from either requiring a WriteCloser or having a\n-\t// StreamWriterCloser.\n-\treturn w.W.(io.Closer).Close()\n+\tif c, ok := w.W.(io.Closer); ok {\n+\t\treturn c.Close()\n+\t}\n+\treturn nil\n }"}, {"sha": "4b03628e69297f6ce303d7c8ed65c0f1de5f3987", "filename": "libgo/go/crypto/crypto.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -7,6 +7,7 @@ package crypto\n \n import (\n \t\"hash\"\n+\t\"strconv\"\n )\n \n // Hash identifies a cryptographic hash function that is implemented in another\n@@ -59,7 +60,7 @@ func (h Hash) New() hash.Hash {\n \t\t\treturn f()\n \t\t}\n \t}\n-\tpanic(\"crypto: requested hash function is unavailable\")\n+\tpanic(\"crypto: requested hash function #\" + strconv.Itoa(int(h)) + \" is unavailable\")\n }\n \n // Available reports whether the given hash function is linked into the binary.\n@@ -77,5 +78,8 @@ func RegisterHash(h Hash, f func() hash.Hash) {\n \thashes[h] = f\n }\n \n+// PublicKey represents a public key using an unspecified algorithm.\n+type PublicKey interface{}\n+\n // PrivateKey represents a private key using an unspecified algorithm.\n type PrivateKey interface{}"}, {"sha": "26355a22e714bebecc0a9c6243a1954e0dbf82d3", "filename": "libgo/go/crypto/des/block.go", "status": "modified", "additions": 131, "deletions": 6, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -10,7 +10,7 @@ import (\n \n func cryptBlock(subkeys []uint64, dst, src []byte, decrypt bool) {\n \tb := binary.BigEndian.Uint64(src)\n-\tb = permuteBlock(b, initialPermutation[:])\n+\tb = permuteInitialBlock(b)\n \tleft, right := uint32(b>>32), uint32(b)\n \n \tvar subkey uint64\n@@ -25,7 +25,7 @@ func cryptBlock(subkeys []uint64, dst, src []byte, decrypt bool) {\n \t}\n \t// switch left & right and perform final permutation\n \tpreOutput := (uint64(right) << 32) | uint64(left)\n-\tbinary.BigEndian.PutUint64(dst, permuteBlock(preOutput, finalPermutation[:]))\n+\tbinary.BigEndian.PutUint64(dst, permuteFinalBlock(preOutput))\n }\n \n // Encrypt one block from src into dst, using the subkeys.\n@@ -40,20 +40,24 @@ func decryptBlock(subkeys []uint64, dst, src []byte) {\n \n // DES Feistel function\n func feistel(right uint32, key uint64) (result uint32) {\n-\tsBoxLocations := key ^ permuteBlock(uint64(right), expansionFunction[:])\n+\tsBoxLocations := key ^ expandBlock(right)\n \tvar sBoxResult uint32\n \tfor i := uint8(0); i < 8; i++ {\n \t\tsBoxLocation := uint8(sBoxLocations>>42) & 0x3f\n \t\tsBoxLocations <<= 6\n \t\t// row determined by 1st and 6th bit\n-\t\trow := (sBoxLocation & 0x1) | ((sBoxLocation & 0x20) >> 4)\n \t\t// column is middle four bits\n+\t\trow := (sBoxLocation & 0x1) | ((sBoxLocation & 0x20) >> 4)\n \t\tcolumn := (sBoxLocation >> 1) & 0xf\n-\t\tsBoxResult |= uint32(sBoxes[i][row][column]) << (4 * (7 - i))\n+\t\tsBoxResult ^= feistelBox[i][16*row+column]\n \t}\n-\treturn uint32(permuteBlock(uint64(sBoxResult), permutationFunction[:]))\n+\treturn sBoxResult\n }\n \n+// feistelBox[s][16*i+j] contains the output of permutationFunction\n+// for sBoxes[s][i][j] << 4*(7-s)\n+var feistelBox [8][64]uint32\n+\n // general purpose function to perform DES block permutations\n func permuteBlock(src uint64, permutation []uint8) (block uint64) {\n \tfor position, n := range permutation {\n@@ -63,6 +67,127 @@ func permuteBlock(src uint64, permutation []uint8) (block uint64) {\n \treturn\n }\n \n+func init() {\n+\tfor s := range sBoxes {\n+\t\tfor i := 0; i < 4; i++ {\n+\t\t\tfor j := 0; j < 16; j++ {\n+\t\t\t\tf := uint64(sBoxes[s][i][j]) << (4 * (7 - uint(s)))\n+\t\t\t\tf = permuteBlock(uint64(f), permutationFunction[:])\n+\t\t\t\tfeistelBox[s][16*i+j] = uint32(f)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// expandBlock expands an input block of 32 bits,\n+// producing an output block of 48 bits.\n+func expandBlock(src uint32) (block uint64) {\n+\t// rotate the 5 highest bits to the right.\n+\tsrc = (src << 5) | (src >> 27)\n+\tfor i := 0; i < 8; i++ {\n+\t\tblock <<= 6\n+\t\t// take the 6 bits on the right\n+\t\tblock |= uint64(src) & (1<<6 - 1)\n+\t\t// advance by 4 bits.\n+\t\tsrc = (src << 4) | (src >> 28)\n+\t}\n+\treturn\n+}\n+\n+// permuteInitialBlock is equivalent to the permutation defined\n+// by initialPermutation.\n+func permuteInitialBlock(block uint64) uint64 {\n+\t// block = b7 b6 b5 b4 b3 b2 b1 b0 (8 bytes)\n+\tb1 := block >> 48\n+\tb2 := block << 48\n+\tblock ^= b1 ^ b2 ^ b1<<48 ^ b2>>48\n+\n+\t// block = b1 b0 b5 b4 b3 b2 b7 b6\n+\tb1 = block >> 32 & 0xff00ff\n+\tb2 = (block & 0xff00ff00)\n+\tblock ^= b1<<32 ^ b2 ^ b1<<8 ^ b2<<24 // exchange b0 b4 with b3 b7\n+\n+\t// block is now b1 b3 b5 b7 b0 b2 b4 b7, the permutation:\n+\t//                  ...  8\n+\t//                  ... 24\n+\t//                  ... 40\n+\t//                  ... 56\n+\t//  7  6  5  4  3  2  1  0\n+\t// 23 22 21 20 19 18 17 16\n+\t//                  ... 32\n+\t//                  ... 48\n+\n+\t// exchange 4,5,6,7 with 32,33,34,35 etc.\n+\tb1 = block & 0x0f0f00000f0f0000\n+\tb2 = block & 0x0000f0f00000f0f0\n+\tblock ^= b1 ^ b2 ^ b1>>12 ^ b2<<12\n+\n+\t// block is the permutation:\n+\t//\n+\t//   [+8]         [+40]\n+\t//\n+\t//  7  6  5  4\n+\t// 23 22 21 20\n+\t//  3  2  1  0\n+\t// 19 18 17 16    [+32]\n+\n+\t// exchange 0,1,4,5 with 18,19,22,23\n+\tb1 = block & 0x3300330033003300\n+\tb2 = block & 0x00cc00cc00cc00cc\n+\tblock ^= b1 ^ b2 ^ b1>>6 ^ b2<<6\n+\n+\t// block is the permutation:\n+\t// 15 14\n+\t// 13 12\n+\t// 11 10\n+\t//  9  8\n+\t//  7  6\n+\t//  5  4\n+\t//  3  2\n+\t//  1  0 [+16] [+32] [+64]\n+\n+\t// exchange 0,2,4,6 with 9,11,13,15:\n+\tb1 = block & 0xaaaaaaaa55555555\n+\tblock ^= b1 ^ b1>>33 ^ b1<<33\n+\n+\t// block is the permutation:\n+\t// 6 14 22 30 38 46 54 62\n+\t// 4 12 20 28 36 44 52 60\n+\t// 2 10 18 26 34 42 50 58\n+\t// 0  8 16 24 32 40 48 56\n+\t// 7 15 23 31 39 47 55 63\n+\t// 5 13 21 29 37 45 53 61\n+\t// 3 11 19 27 35 43 51 59\n+\t// 1  9 17 25 33 41 49 57\n+\treturn block\n+}\n+\n+// permuteInitialBlock is equivalent to the permutation defined\n+// by finalPermutation.\n+func permuteFinalBlock(block uint64) uint64 {\n+\t// Perform the same bit exchanges as permuteInitialBlock\n+\t// but in reverse order.\n+\tb1 := block & 0xaaaaaaaa55555555\n+\tblock ^= b1 ^ b1>>33 ^ b1<<33\n+\n+\tb1 = block & 0x3300330033003300\n+\tb2 := block & 0x00cc00cc00cc00cc\n+\tblock ^= b1 ^ b2 ^ b1>>6 ^ b2<<6\n+\n+\tb1 = block & 0x0f0f00000f0f0000\n+\tb2 = block & 0x0000f0f00000f0f0\n+\tblock ^= b1 ^ b2 ^ b1>>12 ^ b2<<12\n+\n+\tb1 = block >> 32 & 0xff00ff\n+\tb2 = (block & 0xff00ff00)\n+\tblock ^= b1<<32 ^ b2 ^ b1<<8 ^ b2<<24\n+\n+\tb1 = block >> 48\n+\tb2 = block << 48\n+\tblock ^= b1 ^ b2 ^ b1<<48 ^ b2>>48\n+\treturn block\n+}\n+\n // creates 16 28-bit blocks rotated according\n // to the rotation schedule\n func ksRotate(in uint32) (out []uint32) {"}, {"sha": "2bd525afecce9503b36672031ab8d50f386636e5", "filename": "libgo/go/crypto/des/des_test.go", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -1504,20 +1504,63 @@ func TestSubstitutionTableKnownAnswerDecrypt(t *testing.T) {\n \t}\n }\n \n-func ExampleNewTripleDESCipher() {\n-\t// NewTripleDESCipher can also be used when EDE2 is required by\n-\t// duplicating the first 8 bytes of the 16-byte key.\n-\tede2Key := []byte(\"example key 1234\")\n+func TestInitialPermute(t *testing.T) {\n+\tfor i := uint(0); i < 64; i++ {\n+\t\tbit := uint64(1) << i\n+\t\tgot := permuteInitialBlock(bit)\n+\t\twant := uint64(1) << finalPermutation[63-i]\n+\t\tif got != want {\n+\t\t\tt.Errorf(\"permute(%x) = %x, want %x\", bit, got, want)\n+\t\t}\n+\t}\n+}\n \n-\tvar tripleDESKey []byte\n-\ttripleDESKey = append(tripleDESKey, ede2Key[:16]...)\n-\ttripleDESKey = append(tripleDESKey, ede2Key[:8]...)\n+func TestFinalPermute(t *testing.T) {\n+\tfor i := uint(0); i < 64; i++ {\n+\t\tbit := uint64(1) << i\n+\t\tgot := permuteFinalBlock(bit)\n+\t\twant := uint64(1) << initialPermutation[63-i]\n+\t\tif got != want {\n+\t\t\tt.Errorf(\"permute(%x) = %x, want %x\", bit, got, want)\n+\t\t}\n+\t}\n+}\n \n-\t_, err := NewTripleDESCipher(tripleDESKey)\n+func TestExpandBlock(t *testing.T) {\n+\tfor i := uint(0); i < 32; i++ {\n+\t\tbit := uint32(1) << i\n+\t\tgot := expandBlock(bit)\n+\t\twant := permuteBlock(uint64(bit), expansionFunction[:])\n+\t\tif got != want {\n+\t\t\tt.Errorf(\"expand(%x) = %x, want %x\", bit, got, want)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkEncrypt(b *testing.B) {\n+\ttt := encryptDESTests[0]\n+\tc, err := NewCipher(tt.key)\n \tif err != nil {\n-\t\tpanic(err)\n+\t\tb.Fatal(\"NewCipher:\", err)\n+\t}\n+\tout := make([]byte, len(tt.in))\n+\tb.SetBytes(int64(len(out)))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tc.Encrypt(out, tt.in)\n \t}\n+}\n \n-\t// See crypto/cipher for how to use a cipher.Block for encryption and\n-\t// decryption.\n+func BenchmarkDecrypt(b *testing.B) {\n+\ttt := encryptDESTests[0]\n+\tc, err := NewCipher(tt.key)\n+\tif err != nil {\n+\t\tb.Fatal(\"NewCipher:\", err)\n+\t}\n+\tout := make([]byte, len(tt.out))\n+\tb.SetBytes(int64(len(out)))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tc.Decrypt(out, tt.out)\n+\t}\n }"}, {"sha": "d02f15c34d9ab8eab9f2016e6a011c052eec6211", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -123,8 +123,8 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \treturn\n }\n \n-// Verify verifies the signature in r, s of hash using the public key, pub. It\n-// returns true iff the signature is valid.\n+// Verify verifies the signature in r, s of hash using the public key, pub. Its\n+// return value records whether the signature is valid.\n func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n \t// See [NSA] 3.4.2\n \tc := pub.Curve"}, {"sha": "ba673f80ca6f9454180bb06c56ee41e6a7a6c555", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -322,7 +322,6 @@ func Unmarshal(curve Curve, data []byte) (x, y *big.Int) {\n }\n \n var initonce sync.Once\n-var p256 *CurveParams\n var p384 *CurveParams\n var p521 *CurveParams\n \n@@ -333,17 +332,6 @@ func initAll() {\n \tinitP521()\n }\n \n-func initP256() {\n-\t// See FIPS 186-3, section D.2.3\n-\tp256 = new(CurveParams)\n-\tp256.P, _ = new(big.Int).SetString(\"115792089210356248762697446949407573530086143415290314195533631308867097853951\", 10)\n-\tp256.N, _ = new(big.Int).SetString(\"115792089210356248762697446949407573529996955224135760342422259061068512044369\", 10)\n-\tp256.B, _ = new(big.Int).SetString(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)\n-\tp256.Gx, _ = new(big.Int).SetString(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16)\n-\tp256.Gy, _ = new(big.Int).SetString(\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", 16)\n-\tp256.BitSize = 256\n-}\n-\n func initP384() {\n \t// See FIPS 186-3, section D.2.4\n \tp384 = new(CurveParams)"}, {"sha": "4dc27c92bf43eaf7264f5c695b0ffdcbdbffb219", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -322,6 +322,52 @@ func TestGenericBaseMult(t *testing.T) {\n \t}\n }\n \n+func TestP256BaseMult(t *testing.T) {\n+\tp256 := P256()\n+\tp256Generic := p256.Params()\n+\n+\tscalars := make([]*big.Int, 0, len(p224BaseMultTests)+1)\n+\tfor _, e := range p224BaseMultTests {\n+\t\tk, _ := new(big.Int).SetString(e.k, 10)\n+\t\tscalars = append(scalars, k)\n+\t}\n+\tk := new(big.Int).SetInt64(1)\n+\tk.Lsh(k, 500)\n+\tscalars = append(scalars, k)\n+\n+\tfor i, k := range scalars {\n+\t\tx, y := p256.ScalarBaseMult(k.Bytes())\n+\t\tx2, y2 := p256Generic.ScalarBaseMult(k.Bytes())\n+\t\tif x.Cmp(x2) != 0 || y.Cmp(y2) != 0 {\n+\t\t\tt.Errorf(\"#%d: got (%x, %x), want (%x, %x)\", i, x, y, x2, y2)\n+\t\t}\n+\n+\t\tif testing.Short() && i > 5 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+func TestP256Mult(t *testing.T) {\n+\tp256 := P256()\n+\tp256Generic := p256.Params()\n+\n+\tfor i, e := range p224BaseMultTests {\n+\t\tx, _ := new(big.Int).SetString(e.x, 16)\n+\t\ty, _ := new(big.Int).SetString(e.y, 16)\n+\t\tk, _ := new(big.Int).SetString(e.k, 10)\n+\n+\t\txx, yy := p256.ScalarMult(x, y, k.Bytes())\n+\t\txx2, yy2 := p256Generic.ScalarMult(x, y, k.Bytes())\n+\t\tif xx.Cmp(xx2) != 0 || yy.Cmp(yy2) != 0 {\n+\t\t\tt.Errorf(\"#%d: got (%x, %x), want (%x, %x)\", i, xx, yy, xx2, yy2)\n+\t\t}\n+\t\tif testing.Short() && i > 5 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n func TestInfinity(t *testing.T) {\n \ttests := []struct {\n \t\tname  string\n@@ -371,6 +417,17 @@ func BenchmarkBaseMult(b *testing.B) {\n \t}\n }\n \n+func BenchmarkBaseMultP256(b *testing.B) {\n+\tb.ResetTimer()\n+\tp256 := P256()\n+\te := p224BaseMultTests[25]\n+\tk, _ := new(big.Int).SetString(e.k, 10)\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tp256.ScalarBaseMult(k.Bytes())\n+\t}\n+}\n+\n func TestMarshal(t *testing.T) {\n \tp224 := P224()\n \t_, x, y, err := GenerateKey(p224, rand.Reader)"}, {"sha": "82be51e62cd0afdbe4656d2dcc18cdcce86b2d57", "filename": "libgo/go/crypto/elliptic/p256.go", "status": "added", "additions": 1186, "deletions": 0, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -0,0 +1,1186 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package elliptic\n+\n+// This file contains a constant-time, 32-bit implementation of P256.\n+\n+import (\n+\t\"math/big\"\n+)\n+\n+type p256Curve struct {\n+\t*CurveParams\n+}\n+\n+var (\n+\tp256 p256Curve\n+\t// RInverse contains 1/R mod p - the inverse of the Montgomery constant\n+\t// (2**257).\n+\tp256RInverse *big.Int\n+)\n+\n+func initP256() {\n+\t// See FIPS 186-3, section D.2.3\n+\tp256.CurveParams = new(CurveParams)\n+\tp256.P, _ = new(big.Int).SetString(\"115792089210356248762697446949407573530086143415290314195533631308867097853951\", 10)\n+\tp256.N, _ = new(big.Int).SetString(\"115792089210356248762697446949407573529996955224135760342422259061068512044369\", 10)\n+\tp256.B, _ = new(big.Int).SetString(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)\n+\tp256.Gx, _ = new(big.Int).SetString(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16)\n+\tp256.Gy, _ = new(big.Int).SetString(\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", 16)\n+\tp256.BitSize = 256\n+\n+\tp256RInverse, _ = new(big.Int).SetString(\"7fffffff00000001fffffffe8000000100000000ffffffff0000000180000000\", 16)\n+}\n+\n+func (curve p256Curve) Params() *CurveParams {\n+\treturn curve.CurveParams\n+}\n+\n+// p256GetScalar endian-swaps the big-endian scalar value from in and writes it\n+// to out. If the scalar is equal or greater than the order of the group, it's\n+// reduced modulo that order.\n+func p256GetScalar(out *[32]byte, in []byte) {\n+\tn := new(big.Int).SetBytes(in)\n+\tvar scalarBytes []byte\n+\n+\tif n.Cmp(p256.N) >= 0 {\n+\t\tn.Mod(n, p256.N)\n+\t\tscalarBytes = n.Bytes()\n+\t} else {\n+\t\tscalarBytes = in\n+\t}\n+\n+\tfor i, v := range scalarBytes {\n+\t\tout[len(scalarBytes)-(1+i)] = v\n+\t}\n+}\n+\n+func (p256Curve) ScalarBaseMult(scalar []byte) (x, y *big.Int) {\n+\tvar scalarReversed [32]byte\n+\tp256GetScalar(&scalarReversed, scalar)\n+\n+\tvar x1, y1, z1 [p256Limbs]uint32\n+\tp256ScalarBaseMult(&x1, &y1, &z1, &scalarReversed)\n+\treturn p256ToAffine(&x1, &y1, &z1)\n+}\n+\n+func (p256Curve) ScalarMult(bigX, bigY *big.Int, scalar []byte) (x, y *big.Int) {\n+\tvar scalarReversed [32]byte\n+\tp256GetScalar(&scalarReversed, scalar)\n+\n+\tvar px, py, x1, y1, z1 [p256Limbs]uint32\n+\tp256FromBig(&px, bigX)\n+\tp256FromBig(&py, bigY)\n+\tp256ScalarMult(&x1, &y1, &z1, &px, &py, &scalarReversed)\n+\treturn p256ToAffine(&x1, &y1, &z1)\n+}\n+\n+// Field elements are represented as nine, unsigned 32-bit words.\n+//\n+// The value of an field element is:\n+//   x[0] + (x[1] * 2**29) + (x[2] * 2**57) + ... + (x[8] * 2**228)\n+//\n+// That is, each limb is alternately 29 or 28-bits wide in little-endian\n+// order.\n+//\n+// This means that a field element hits 2**257, rather than 2**256 as we would\n+// like. A 28, 29, ... pattern would cause us to hit 2**256, but that causes\n+// problems when multiplying as terms end up one bit short of a limb which\n+// would require much bit-shifting to correct.\n+//\n+// Finally, the values stored in a field element are in Montgomery form. So the\n+// value |y| is stored as (y*R) mod p, where p is the P-256 prime and R is\n+// 2**257.\n+\n+const (\n+\tp256Limbs    = 9\n+\tbottom29Bits = 0x1fffffff\n+)\n+\n+var (\n+\t// p256One is the number 1 as a field element.\n+\tp256One  = [p256Limbs]uint32{2, 0, 0, 0xffff800, 0x1fffffff, 0xfffffff, 0x1fbfffff, 0x1ffffff, 0}\n+\tp256Zero = [p256Limbs]uint32{0, 0, 0, 0, 0, 0, 0, 0, 0}\n+\t// p256P is the prime modulus as a field element.\n+\tp256P = [p256Limbs]uint32{0x1fffffff, 0xfffffff, 0x1fffffff, 0x3ff, 0, 0, 0x200000, 0xf000000, 0xfffffff}\n+\t// p2562P is the twice prime modulus as a field element.\n+\tp2562P = [p256Limbs]uint32{0x1ffffffe, 0xfffffff, 0x1fffffff, 0x7ff, 0, 0, 0x400000, 0xe000000, 0x1fffffff}\n+)\n+\n+// p256Precomputed contains precomputed values to aid the calculation of scalar\n+// multiples of the base point, G. It's actually two, equal length, tables\n+// concatenated.\n+//\n+// The first table contains (x,y) field element pairs for 16 multiples of the\n+// base point, G.\n+//\n+//   Index  |  Index (binary) | Value\n+//       0  |           0000  | 0G (all zeros, omitted)\n+//       1  |           0001  | G\n+//       2  |           0010  | 2**64G\n+//       3  |           0011  | 2**64G + G\n+//       4  |           0100  | 2**128G\n+//       5  |           0101  | 2**128G + G\n+//       6  |           0110  | 2**128G + 2**64G\n+//       7  |           0111  | 2**128G + 2**64G + G\n+//       8  |           1000  | 2**192G\n+//       9  |           1001  | 2**192G + G\n+//      10  |           1010  | 2**192G + 2**64G\n+//      11  |           1011  | 2**192G + 2**64G + G\n+//      12  |           1100  | 2**192G + 2**128G\n+//      13  |           1101  | 2**192G + 2**128G + G\n+//      14  |           1110  | 2**192G + 2**128G + 2**64G\n+//      15  |           1111  | 2**192G + 2**128G + 2**64G + G\n+//\n+// The second table follows the same style, but the terms are 2**32G,\n+// 2**96G, 2**160G, 2**224G.\n+//\n+// This is ~2KB of data.\n+var p256Precomputed = [p256Limbs * 2 * 15 * 2]uint32{\n+\t0x11522878, 0xe730d41, 0xdb60179, 0x4afe2ff, 0x12883add, 0xcaddd88, 0x119e7edc, 0xd4a6eab, 0x3120bee,\n+\t0x1d2aac15, 0xf25357c, 0x19e45cdd, 0x5c721d0, 0x1992c5a5, 0xa237487, 0x154ba21, 0x14b10bb, 0xae3fe3,\n+\t0xd41a576, 0x922fc51, 0x234994f, 0x60b60d3, 0x164586ae, 0xce95f18, 0x1fe49073, 0x3fa36cc, 0x5ebcd2c,\n+\t0xb402f2f, 0x15c70bf, 0x1561925c, 0x5a26704, 0xda91e90, 0xcdc1c7f, 0x1ea12446, 0xe1ade1e, 0xec91f22,\n+\t0x26f7778, 0x566847e, 0xa0bec9e, 0x234f453, 0x1a31f21a, 0xd85e75c, 0x56c7109, 0xa267a00, 0xb57c050,\n+\t0x98fb57, 0xaa837cc, 0x60c0792, 0xcfa5e19, 0x61bab9e, 0x589e39b, 0xa324c5, 0x7d6dee7, 0x2976e4b,\n+\t0x1fc4124a, 0xa8c244b, 0x1ce86762, 0xcd61c7e, 0x1831c8e0, 0x75774e1, 0x1d96a5a9, 0x843a649, 0xc3ab0fa,\n+\t0x6e2e7d5, 0x7673a2a, 0x178b65e8, 0x4003e9b, 0x1a1f11c2, 0x7816ea, 0xf643e11, 0x58c43df, 0xf423fc2,\n+\t0x19633ffa, 0x891f2b2, 0x123c231c, 0x46add8c, 0x54700dd, 0x59e2b17, 0x172db40f, 0x83e277d, 0xb0dd609,\n+\t0xfd1da12, 0x35c6e52, 0x19ede20c, 0xd19e0c0, 0x97d0f40, 0xb015b19, 0x449e3f5, 0xe10c9e, 0x33ab581,\n+\t0x56a67ab, 0x577734d, 0x1dddc062, 0xc57b10d, 0x149b39d, 0x26a9e7b, 0xc35df9f, 0x48764cd, 0x76dbcca,\n+\t0xca4b366, 0xe9303ab, 0x1a7480e7, 0x57e9e81, 0x1e13eb50, 0xf466cf3, 0x6f16b20, 0x4ba3173, 0xc168c33,\n+\t0x15cb5439, 0x6a38e11, 0x73658bd, 0xb29564f, 0x3f6dc5b, 0x53b97e, 0x1322c4c0, 0x65dd7ff, 0x3a1e4f6,\n+\t0x14e614aa, 0x9246317, 0x1bc83aca, 0xad97eed, 0xd38ce4a, 0xf82b006, 0x341f077, 0xa6add89, 0x4894acd,\n+\t0x9f162d5, 0xf8410ef, 0x1b266a56, 0xd7f223, 0x3e0cb92, 0xe39b672, 0x6a2901a, 0x69a8556, 0x7e7c0,\n+\t0x9b7d8d3, 0x309a80, 0x1ad05f7f, 0xc2fb5dd, 0xcbfd41d, 0x9ceb638, 0x1051825c, 0xda0cf5b, 0x812e881,\n+\t0x6f35669, 0x6a56f2c, 0x1df8d184, 0x345820, 0x1477d477, 0x1645db1, 0xbe80c51, 0xc22be3e, 0xe35e65a,\n+\t0x1aeb7aa0, 0xc375315, 0xf67bc99, 0x7fdd7b9, 0x191fc1be, 0x61235d, 0x2c184e9, 0x1c5a839, 0x47a1e26,\n+\t0xb7cb456, 0x93e225d, 0x14f3c6ed, 0xccc1ac9, 0x17fe37f3, 0x4988989, 0x1a90c502, 0x2f32042, 0xa17769b,\n+\t0xafd8c7c, 0x8191c6e, 0x1dcdb237, 0x16200c0, 0x107b32a1, 0x66c08db, 0x10d06a02, 0x3fc93, 0x5620023,\n+\t0x16722b27, 0x68b5c59, 0x270fcfc, 0xfad0ecc, 0xe5de1c2, 0xeab466b, 0x2fc513c, 0x407f75c, 0xbaab133,\n+\t0x9705fe9, 0xb88b8e7, 0x734c993, 0x1e1ff8f, 0x19156970, 0xabd0f00, 0x10469ea7, 0x3293ac0, 0xcdc98aa,\n+\t0x1d843fd, 0xe14bfe8, 0x15be825f, 0x8b5212, 0xeb3fb67, 0x81cbd29, 0xbc62f16, 0x2b6fcc7, 0xf5a4e29,\n+\t0x13560b66, 0xc0b6ac2, 0x51ae690, 0xd41e271, 0xf3e9bd4, 0x1d70aab, 0x1029f72, 0x73e1c35, 0xee70fbc,\n+\t0xad81baf, 0x9ecc49a, 0x86c741e, 0xfe6be30, 0x176752e7, 0x23d416, 0x1f83de85, 0x27de188, 0x66f70b8,\n+\t0x181cd51f, 0x96b6e4c, 0x188f2335, 0xa5df759, 0x17a77eb6, 0xfeb0e73, 0x154ae914, 0x2f3ec51, 0x3826b59,\n+\t0xb91f17d, 0x1c72949, 0x1362bf0a, 0xe23fddf, 0xa5614b0, 0xf7d8f, 0x79061, 0x823d9d2, 0x8213f39,\n+\t0x1128ae0b, 0xd095d05, 0xb85c0c2, 0x1ecb2ef, 0x24ddc84, 0xe35e901, 0x18411a4a, 0xf5ddc3d, 0x3786689,\n+\t0x52260e8, 0x5ae3564, 0x542b10d, 0x8d93a45, 0x19952aa4, 0x996cc41, 0x1051a729, 0x4be3499, 0x52b23aa,\n+\t0x109f307e, 0x6f5b6bb, 0x1f84e1e7, 0x77a0cfa, 0x10c4df3f, 0x25a02ea, 0xb048035, 0xe31de66, 0xc6ecaa3,\n+\t0x28ea335, 0x2886024, 0x1372f020, 0xf55d35, 0x15e4684c, 0xf2a9e17, 0x1a4a7529, 0xcb7beb1, 0xb2a78a1,\n+\t0x1ab21f1f, 0x6361ccf, 0x6c9179d, 0xb135627, 0x1267b974, 0x4408bad, 0x1cbff658, 0xe3d6511, 0xc7d76f,\n+\t0x1cc7a69, 0xe7ee31b, 0x54fab4f, 0x2b914f, 0x1ad27a30, 0xcd3579e, 0xc50124c, 0x50daa90, 0xb13f72,\n+\t0xb06aa75, 0x70f5cc6, 0x1649e5aa, 0x84a5312, 0x329043c, 0x41c4011, 0x13d32411, 0xb04a838, 0xd760d2d,\n+\t0x1713b532, 0xbaa0c03, 0x84022ab, 0x6bcf5c1, 0x2f45379, 0x18ae070, 0x18c9e11e, 0x20bca9a, 0x66f496b,\n+\t0x3eef294, 0x67500d2, 0xd7f613c, 0x2dbbeb, 0xb741038, 0xe04133f, 0x1582968d, 0xbe985f7, 0x1acbc1a,\n+\t0x1a6a939f, 0x33e50f6, 0xd665ed4, 0xb4b7bd6, 0x1e5a3799, 0x6b33847, 0x17fa56ff, 0x65ef930, 0x21dc4a,\n+\t0x2b37659, 0x450fe17, 0xb357b65, 0xdf5efac, 0x15397bef, 0x9d35a7f, 0x112ac15f, 0x624e62e, 0xa90ae2f,\n+\t0x107eecd2, 0x1f69bbe, 0x77d6bce, 0x5741394, 0x13c684fc, 0x950c910, 0x725522b, 0xdc78583, 0x40eeabb,\n+\t0x1fde328a, 0xbd61d96, 0xd28c387, 0x9e77d89, 0x12550c40, 0x759cb7d, 0x367ef34, 0xae2a960, 0x91b8bdc,\n+\t0x93462a9, 0xf469ef, 0xb2e9aef, 0xd2ca771, 0x54e1f42, 0x7aaa49, 0x6316abb, 0x2413c8e, 0x5425bf9,\n+\t0x1bed3e3a, 0xf272274, 0x1f5e7326, 0x6416517, 0xea27072, 0x9cedea7, 0x6e7633, 0x7c91952, 0xd806dce,\n+\t0x8e2a7e1, 0xe421e1a, 0x418c9e1, 0x1dbc890, 0x1b395c36, 0xa1dc175, 0x1dc4ef73, 0x8956f34, 0xe4b5cf2,\n+\t0x1b0d3a18, 0x3194a36, 0x6c2641f, 0xe44124c, 0xa2f4eaa, 0xa8c25ba, 0xf927ed7, 0x627b614, 0x7371cca,\n+\t0xba16694, 0x417bc03, 0x7c0a7e3, 0x9c35c19, 0x1168a205, 0x8b6b00d, 0x10e3edc9, 0x9c19bf2, 0x5882229,\n+\t0x1b2b4162, 0xa5cef1a, 0x1543622b, 0x9bd433e, 0x364e04d, 0x7480792, 0x5c9b5b3, 0xe85ff25, 0x408ef57,\n+\t0x1814cfa4, 0x121b41b, 0xd248a0f, 0x3b05222, 0x39bb16a, 0xc75966d, 0xa038113, 0xa4a1769, 0x11fbc6c,\n+\t0x917e50e, 0xeec3da8, 0x169d6eac, 0x10c1699, 0xa416153, 0xf724912, 0x15cd60b7, 0x4acbad9, 0x5efc5fa,\n+\t0xf150ed7, 0x122b51, 0x1104b40a, 0xcb7f442, 0xfbb28ff, 0x6ac53ca, 0x196142cc, 0x7bf0fa9, 0x957651,\n+\t0x4e0f215, 0xed439f8, 0x3f46bd5, 0x5ace82f, 0x110916b6, 0x6db078, 0xffd7d57, 0xf2ecaac, 0xca86dec,\n+\t0x15d6b2da, 0x965ecc9, 0x1c92b4c2, 0x1f3811, 0x1cb080f5, 0x2d8b804, 0x19d1c12d, 0xf20bd46, 0x1951fa7,\n+\t0xa3656c3, 0x523a425, 0xfcd0692, 0xd44ddc8, 0x131f0f5b, 0xaf80e4a, 0xcd9fc74, 0x99bb618, 0x2db944c,\n+\t0xa673090, 0x1c210e1, 0x178c8d23, 0x1474383, 0x10b8743d, 0x985a55b, 0x2e74779, 0x576138, 0x9587927,\n+\t0x133130fa, 0xbe05516, 0x9f4d619, 0xbb62570, 0x99ec591, 0xd9468fe, 0x1d07782d, 0xfc72e0b, 0x701b298,\n+\t0x1863863b, 0x85954b8, 0x121a0c36, 0x9e7fedf, 0xf64b429, 0x9b9d71e, 0x14e2f5d8, 0xf858d3a, 0x942eea8,\n+\t0xda5b765, 0x6edafff, 0xa9d18cc, 0xc65e4ba, 0x1c747e86, 0xe4ea915, 0x1981d7a1, 0x8395659, 0x52ed4e2,\n+\t0x87d43b7, 0x37ab11b, 0x19d292ce, 0xf8d4692, 0x18c3053f, 0x8863e13, 0x4c146c0, 0x6bdf55a, 0x4e4457d,\n+\t0x16152289, 0xac78ec2, 0x1a59c5a2, 0x2028b97, 0x71c2d01, 0x295851f, 0x404747b, 0x878558d, 0x7d29aa4,\n+\t0x13d8341f, 0x8daefd7, 0x139c972d, 0x6b7ea75, 0xd4a9dde, 0xff163d8, 0x81d55d7, 0xa5bef68, 0xb7b30d8,\n+\t0xbe73d6f, 0xaa88141, 0xd976c81, 0x7e7a9cc, 0x18beb771, 0xd773cbd, 0x13f51951, 0x9d0c177, 0x1c49a78,\n+}\n+\n+// Field element operations:\n+\n+// nonZeroToAllOnes returns:\n+//   0xffffffff for 0 < x <= 2**31\n+//   0 for x == 0 or x > 2**31.\n+func nonZeroToAllOnes(x uint32) uint32 {\n+\treturn ((x - 1) >> 31) - 1\n+}\n+\n+// p256ReduceCarry adds a multiple of p in order to cancel |carry|,\n+// which is a term at 2**257.\n+//\n+// On entry: carry < 2**3, inout[0,2,...] < 2**29, inout[1,3,...] < 2**28.\n+// On exit: inout[0,2,..] < 2**30, inout[1,3,...] < 2**29.\n+func p256ReduceCarry(inout *[p256Limbs]uint32, carry uint32) {\n+\tcarry_mask := nonZeroToAllOnes(carry)\n+\n+\tinout[0] += carry << 1\n+\tinout[3] += 0x10000000 & carry_mask\n+\t// carry < 2**3 thus (carry << 11) < 2**14 and we added 2**28 in the\n+\t// previous line therefore this doesn't underflow.\n+\tinout[3] -= carry << 11\n+\tinout[4] += (0x20000000 - 1) & carry_mask\n+\tinout[5] += (0x10000000 - 1) & carry_mask\n+\tinout[6] += (0x20000000 - 1) & carry_mask\n+\tinout[6] -= carry << 22\n+\t// This may underflow if carry is non-zero but, if so, we'll fix it in the\n+\t// next line.\n+\tinout[7] -= 1 & carry_mask\n+\tinout[7] += carry << 25\n+}\n+\n+// p256Sum sets out = in+in2.\n+//\n+// On entry, in[i]+in2[i] must not overflow a 32-bit word.\n+// On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29\n+func p256Sum(out, in, in2 *[p256Limbs]uint32) {\n+\tcarry := uint32(0)\n+\tfor i := 0; ; i++ {\n+\t\tout[i] = in[i] + in2[i]\n+\t\tout[i] += carry\n+\t\tcarry = out[i] >> 29\n+\t\tout[i] &= bottom29Bits\n+\n+\t\ti++\n+\t\tif i == p256Limbs {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tout[i] = in[i] + in2[i]\n+\t\tout[i] += carry\n+\t\tcarry = out[i] >> 28\n+\t\tout[i] &= bottom28Bits\n+\t}\n+\n+\tp256ReduceCarry(out, carry)\n+}\n+\n+const (\n+\ttwo30m2    = 1<<30 - 1<<2\n+\ttwo30p13m2 = 1<<30 + 1<<13 - 1<<2\n+\ttwo31m2    = 1<<31 - 1<<2\n+\ttwo31p24m2 = 1<<31 + 1<<24 - 1<<2\n+\ttwo30m27m2 = 1<<30 - 1<<27 - 1<<2\n+)\n+\n+// p256Zero31 is 0 mod p.\n+var p256Zero31 = [p256Limbs]uint32{two31m3, two30m2, two31m2, two30p13m2, two31m2, two30m2, two31p24m2, two30m27m2, two31m2}\n+\n+// p256Diff sets out = in-in2.\n+//\n+// On entry: in[0,2,...] < 2**30, in[1,3,...] < 2**29 and\n+//           in2[0,2,...] < 2**30, in2[1,3,...] < 2**29.\n+// On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+func p256Diff(out, in, in2 *[p256Limbs]uint32) {\n+\tvar carry uint32\n+\n+\tfor i := 0; ; i++ {\n+\t\tout[i] = in[i] - in2[i]\n+\t\tout[i] += p256Zero31[i]\n+\t\tout[i] += carry\n+\t\tcarry = out[i] >> 29\n+\t\tout[i] &= bottom29Bits\n+\n+\t\ti++\n+\t\tif i == p256Limbs {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tout[i] = in[i] - in2[i]\n+\t\tout[i] += p256Zero31[i]\n+\t\tout[i] += carry\n+\t\tcarry = out[i] >> 28\n+\t\tout[i] &= bottom28Bits\n+\t}\n+\n+\tp256ReduceCarry(out, carry)\n+}\n+\n+// p256ReduceDegree sets out = tmp/R mod p where tmp contains 64-bit words with\n+// the same 29,28,... bit positions as an field element.\n+//\n+// The values in field elements are in Montgomery form: x*R mod p where R =\n+// 2**257. Since we just multiplied two Montgomery values together, the result\n+// is x*y*R*R mod p. We wish to divide by R in order for the result also to be\n+// in Montgomery form.\n+//\n+// On entry: tmp[i] < 2**64\n+// On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29\n+func p256ReduceDegree(out *[p256Limbs]uint32, tmp [17]uint64) {\n+\t// The following table may be helpful when reading this code:\n+\t//\n+\t// Limb number:   0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10...\n+\t// Width (bits):  29| 28| 29| 28| 29| 28| 29| 28| 29| 28| 29\n+\t// Start bit:     0 | 29| 57| 86|114|143|171|200|228|257|285\n+\t//   (odd phase): 0 | 28| 57| 85|114|142|171|199|228|256|285\n+\tvar tmp2 [18]uint32\n+\tvar carry, x, xMask uint32\n+\n+\t// tmp contains 64-bit words with the same 29,28,29-bit positions as an\n+\t// field element. So the top of an element of tmp might overlap with\n+\t// another element two positions down. The following loop eliminates\n+\t// this overlap.\n+\ttmp2[0] = uint32(tmp[0]) & bottom29Bits\n+\n+\ttmp2[1] = uint32(tmp[0]) >> 29\n+\ttmp2[1] |= (uint32(tmp[0]>>32) << 3) & bottom28Bits\n+\ttmp2[1] += uint32(tmp[1]) & bottom28Bits\n+\tcarry = tmp2[1] >> 28\n+\ttmp2[1] &= bottom28Bits\n+\n+\tfor i := 2; i < 17; i++ {\n+\t\ttmp2[i] = (uint32(tmp[i-2] >> 32)) >> 25\n+\t\ttmp2[i] += (uint32(tmp[i-1])) >> 28\n+\t\ttmp2[i] += (uint32(tmp[i-1]>>32) << 4) & bottom29Bits\n+\t\ttmp2[i] += uint32(tmp[i]) & bottom29Bits\n+\t\ttmp2[i] += carry\n+\t\tcarry = tmp2[i] >> 29\n+\t\ttmp2[i] &= bottom29Bits\n+\n+\t\ti++\n+\t\tif i == 17 {\n+\t\t\tbreak\n+\t\t}\n+\t\ttmp2[i] = uint32(tmp[i-2]>>32) >> 25\n+\t\ttmp2[i] += uint32(tmp[i-1]) >> 29\n+\t\ttmp2[i] += ((uint32(tmp[i-1] >> 32)) << 3) & bottom28Bits\n+\t\ttmp2[i] += uint32(tmp[i]) & bottom28Bits\n+\t\ttmp2[i] += carry\n+\t\tcarry = tmp2[i] >> 28\n+\t\ttmp2[i] &= bottom28Bits\n+\t}\n+\n+\ttmp2[17] = uint32(tmp[15]>>32) >> 25\n+\ttmp2[17] += uint32(tmp[16]) >> 29\n+\ttmp2[17] += uint32(tmp[16]>>32) << 3\n+\ttmp2[17] += carry\n+\n+\t// Montgomery elimination of terms:\n+\t//\n+\t// Since R is 2**257, we can divide by R with a bitwise shift if we can\n+\t// ensure that the right-most 257 bits are all zero. We can make that true\n+\t// by adding multiplies of p without affecting the value.\n+\t//\n+\t// So we eliminate limbs from right to left. Since the bottom 29 bits of p\n+\t// are all ones, then by adding tmp2[0]*p to tmp2 we'll make tmp2[0] == 0.\n+\t// We can do that for 8 further limbs and then right shift to eliminate the\n+\t// extra factor of R.\n+\tfor i := 0; ; i += 2 {\n+\t\ttmp2[i+1] += tmp2[i] >> 29\n+\t\tx = tmp2[i] & bottom29Bits\n+\t\txMask = nonZeroToAllOnes(x)\n+\t\ttmp2[i] = 0\n+\n+\t\t// The bounds calculations for this loop are tricky. Each iteration of\n+\t\t// the loop eliminates two words by adding values to words to their\n+\t\t// right.\n+\t\t//\n+\t\t// The following table contains the amounts added to each word (as an\n+\t\t// offset from the value of i at the top of the loop). The amounts are\n+\t\t// accounted for from the first and second half of the loop separately\n+\t\t// and are written as, for example, 28 to mean a value <2**28.\n+\t\t//\n+\t\t// Word:                   3   4   5   6   7   8   9   10\n+\t\t// Added in top half:     28  11      29  21  29  28\n+\t\t//                                        28  29\n+\t\t//                                            29\n+\t\t// Added in bottom half:      29  10      28  21  28   28\n+\t\t//                                            29\n+\t\t//\n+\t\t// The value that is currently offset 7 will be offset 5 for the next\n+\t\t// iteration and then offset 3 for the iteration after that. Therefore\n+\t\t// the total value added will be the values added at 7, 5 and 3.\n+\t\t//\n+\t\t// The following table accumulates these values. The sums at the bottom\n+\t\t// are written as, for example, 29+28, to mean a value < 2**29+2**28.\n+\t\t//\n+\t\t// Word:                   3   4   5   6   7   8   9  10  11  12  13\n+\t\t//                        28  11  10  29  21  29  28  28  28  28  28\n+\t\t//                            29  28  11  28  29  28  29  28  29  28\n+\t\t//                                    29  28  21  21  29  21  29  21\n+\t\t//                                        10  29  28  21  28  21  28\n+\t\t//                                        28  29  28  29  28  29  28\n+\t\t//                                            11  10  29  10  29  10\n+\t\t//                                            29  28  11  28  11\n+\t\t//                                                    29      29\n+\t\t//                        --------------------------------------------\n+\t\t//                                                30+ 31+ 30+ 31+ 30+\n+\t\t//                                                28+ 29+ 28+ 29+ 21+\n+\t\t//                                                21+ 28+ 21+ 28+ 10\n+\t\t//                                                10  21+ 10  21+\n+\t\t//                                                    11      11\n+\t\t//\n+\t\t// So the greatest amount is added to tmp2[10] and tmp2[12]. If\n+\t\t// tmp2[10/12] has an initial value of <2**29, then the maximum value\n+\t\t// will be < 2**31 + 2**30 + 2**28 + 2**21 + 2**11, which is < 2**32,\n+\t\t// as required.\n+\t\ttmp2[i+3] += (x << 10) & bottom28Bits\n+\t\ttmp2[i+4] += (x >> 18)\n+\n+\t\ttmp2[i+6] += (x << 21) & bottom29Bits\n+\t\ttmp2[i+7] += x >> 8\n+\n+\t\t// At position 200, which is the starting bit position for word 7, we\n+\t\t// have a factor of 0xf000000 = 2**28 - 2**24.\n+\t\ttmp2[i+7] += 0x10000000 & xMask\n+\t\ttmp2[i+8] += (x - 1) & xMask\n+\t\ttmp2[i+7] -= (x << 24) & bottom28Bits\n+\t\ttmp2[i+8] -= x >> 4\n+\n+\t\ttmp2[i+8] += 0x20000000 & xMask\n+\t\ttmp2[i+8] -= x\n+\t\ttmp2[i+8] += (x << 28) & bottom29Bits\n+\t\ttmp2[i+9] += ((x >> 1) - 1) & xMask\n+\n+\t\tif i+1 == p256Limbs {\n+\t\t\tbreak\n+\t\t}\n+\t\ttmp2[i+2] += tmp2[i+1] >> 28\n+\t\tx = tmp2[i+1] & bottom28Bits\n+\t\txMask = nonZeroToAllOnes(x)\n+\t\ttmp2[i+1] = 0\n+\n+\t\ttmp2[i+4] += (x << 11) & bottom29Bits\n+\t\ttmp2[i+5] += (x >> 18)\n+\n+\t\ttmp2[i+7] += (x << 21) & bottom28Bits\n+\t\ttmp2[i+8] += x >> 7\n+\n+\t\t// At position 199, which is the starting bit of the 8th word when\n+\t\t// dealing with a context starting on an odd word, we have a factor of\n+\t\t// 0x1e000000 = 2**29 - 2**25. Since we have not updated i, the 8th\n+\t\t// word from i+1 is i+8.\n+\t\ttmp2[i+8] += 0x20000000 & xMask\n+\t\ttmp2[i+9] += (x - 1) & xMask\n+\t\ttmp2[i+8] -= (x << 25) & bottom29Bits\n+\t\ttmp2[i+9] -= x >> 4\n+\n+\t\ttmp2[i+9] += 0x10000000 & xMask\n+\t\ttmp2[i+9] -= x\n+\t\ttmp2[i+10] += (x - 1) & xMask\n+\t}\n+\n+\t// We merge the right shift with a carry chain. The words above 2**257 have\n+\t// widths of 28,29,... which we need to correct when copying them down.\n+\tcarry = 0\n+\tfor i := 0; i < 8; i++ {\n+\t\t// The maximum value of tmp2[i + 9] occurs on the first iteration and\n+\t\t// is < 2**30+2**29+2**28. Adding 2**29 (from tmp2[i + 10]) is\n+\t\t// therefore safe.\n+\t\tout[i] = tmp2[i+9]\n+\t\tout[i] += carry\n+\t\tout[i] += (tmp2[i+10] << 28) & bottom29Bits\n+\t\tcarry = out[i] >> 29\n+\t\tout[i] &= bottom29Bits\n+\n+\t\ti++\n+\t\tout[i] = tmp2[i+9] >> 1\n+\t\tout[i] += carry\n+\t\tcarry = out[i] >> 28\n+\t\tout[i] &= bottom28Bits\n+\t}\n+\n+\tout[8] = tmp2[17]\n+\tout[8] += carry\n+\tcarry = out[8] >> 29\n+\tout[8] &= bottom29Bits\n+\n+\tp256ReduceCarry(out, carry)\n+}\n+\n+// p256Square sets out=in*in.\n+//\n+// On entry: in[0,2,...] < 2**30, in[1,3,...] < 2**29.\n+// On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+func p256Square(out, in *[p256Limbs]uint32) {\n+\tvar tmp [17]uint64\n+\n+\ttmp[0] = uint64(in[0]) * uint64(in[0])\n+\ttmp[1] = uint64(in[0]) * (uint64(in[1]) << 1)\n+\ttmp[2] = uint64(in[0])*(uint64(in[2])<<1) +\n+\t\tuint64(in[1])*(uint64(in[1])<<1)\n+\ttmp[3] = uint64(in[0])*(uint64(in[3])<<1) +\n+\t\tuint64(in[1])*(uint64(in[2])<<1)\n+\ttmp[4] = uint64(in[0])*(uint64(in[4])<<1) +\n+\t\tuint64(in[1])*(uint64(in[3])<<2) +\n+\t\tuint64(in[2])*uint64(in[2])\n+\ttmp[5] = uint64(in[0])*(uint64(in[5])<<1) +\n+\t\tuint64(in[1])*(uint64(in[4])<<1) +\n+\t\tuint64(in[2])*(uint64(in[3])<<1)\n+\ttmp[6] = uint64(in[0])*(uint64(in[6])<<1) +\n+\t\tuint64(in[1])*(uint64(in[5])<<2) +\n+\t\tuint64(in[2])*(uint64(in[4])<<1) +\n+\t\tuint64(in[3])*(uint64(in[3])<<1)\n+\ttmp[7] = uint64(in[0])*(uint64(in[7])<<1) +\n+\t\tuint64(in[1])*(uint64(in[6])<<1) +\n+\t\tuint64(in[2])*(uint64(in[5])<<1) +\n+\t\tuint64(in[3])*(uint64(in[4])<<1)\n+\t// tmp[8] has the greatest value of 2**61 + 2**60 + 2**61 + 2**60 + 2**60,\n+\t// which is < 2**64 as required.\n+\ttmp[8] = uint64(in[0])*(uint64(in[8])<<1) +\n+\t\tuint64(in[1])*(uint64(in[7])<<2) +\n+\t\tuint64(in[2])*(uint64(in[6])<<1) +\n+\t\tuint64(in[3])*(uint64(in[5])<<2) +\n+\t\tuint64(in[4])*uint64(in[4])\n+\ttmp[9] = uint64(in[1])*(uint64(in[8])<<1) +\n+\t\tuint64(in[2])*(uint64(in[7])<<1) +\n+\t\tuint64(in[3])*(uint64(in[6])<<1) +\n+\t\tuint64(in[4])*(uint64(in[5])<<1)\n+\ttmp[10] = uint64(in[2])*(uint64(in[8])<<1) +\n+\t\tuint64(in[3])*(uint64(in[7])<<2) +\n+\t\tuint64(in[4])*(uint64(in[6])<<1) +\n+\t\tuint64(in[5])*(uint64(in[5])<<1)\n+\ttmp[11] = uint64(in[3])*(uint64(in[8])<<1) +\n+\t\tuint64(in[4])*(uint64(in[7])<<1) +\n+\t\tuint64(in[5])*(uint64(in[6])<<1)\n+\ttmp[12] = uint64(in[4])*(uint64(in[8])<<1) +\n+\t\tuint64(in[5])*(uint64(in[7])<<2) +\n+\t\tuint64(in[6])*uint64(in[6])\n+\ttmp[13] = uint64(in[5])*(uint64(in[8])<<1) +\n+\t\tuint64(in[6])*(uint64(in[7])<<1)\n+\ttmp[14] = uint64(in[6])*(uint64(in[8])<<1) +\n+\t\tuint64(in[7])*(uint64(in[7])<<1)\n+\ttmp[15] = uint64(in[7]) * (uint64(in[8]) << 1)\n+\ttmp[16] = uint64(in[8]) * uint64(in[8])\n+\n+\tp256ReduceDegree(out, tmp)\n+}\n+\n+// p256Mul sets out=in*in2.\n+//\n+// On entry: in[0,2,...] < 2**30, in[1,3,...] < 2**29 and\n+//           in2[0,2,...] < 2**30, in2[1,3,...] < 2**29.\n+// On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+func p256Mul(out, in, in2 *[p256Limbs]uint32) {\n+\tvar tmp [17]uint64\n+\n+\ttmp[0] = uint64(in[0]) * uint64(in2[0])\n+\ttmp[1] = uint64(in[0])*(uint64(in2[1])<<0) +\n+\t\tuint64(in[1])*(uint64(in2[0])<<0)\n+\ttmp[2] = uint64(in[0])*(uint64(in2[2])<<0) +\n+\t\tuint64(in[1])*(uint64(in2[1])<<1) +\n+\t\tuint64(in[2])*(uint64(in2[0])<<0)\n+\ttmp[3] = uint64(in[0])*(uint64(in2[3])<<0) +\n+\t\tuint64(in[1])*(uint64(in2[2])<<0) +\n+\t\tuint64(in[2])*(uint64(in2[1])<<0) +\n+\t\tuint64(in[3])*(uint64(in2[0])<<0)\n+\ttmp[4] = uint64(in[0])*(uint64(in2[4])<<0) +\n+\t\tuint64(in[1])*(uint64(in2[3])<<1) +\n+\t\tuint64(in[2])*(uint64(in2[2])<<0) +\n+\t\tuint64(in[3])*(uint64(in2[1])<<1) +\n+\t\tuint64(in[4])*(uint64(in2[0])<<0)\n+\ttmp[5] = uint64(in[0])*(uint64(in2[5])<<0) +\n+\t\tuint64(in[1])*(uint64(in2[4])<<0) +\n+\t\tuint64(in[2])*(uint64(in2[3])<<0) +\n+\t\tuint64(in[3])*(uint64(in2[2])<<0) +\n+\t\tuint64(in[4])*(uint64(in2[1])<<0) +\n+\t\tuint64(in[5])*(uint64(in2[0])<<0)\n+\ttmp[6] = uint64(in[0])*(uint64(in2[6])<<0) +\n+\t\tuint64(in[1])*(uint64(in2[5])<<1) +\n+\t\tuint64(in[2])*(uint64(in2[4])<<0) +\n+\t\tuint64(in[3])*(uint64(in2[3])<<1) +\n+\t\tuint64(in[4])*(uint64(in2[2])<<0) +\n+\t\tuint64(in[5])*(uint64(in2[1])<<1) +\n+\t\tuint64(in[6])*(uint64(in2[0])<<0)\n+\ttmp[7] = uint64(in[0])*(uint64(in2[7])<<0) +\n+\t\tuint64(in[1])*(uint64(in2[6])<<0) +\n+\t\tuint64(in[2])*(uint64(in2[5])<<0) +\n+\t\tuint64(in[3])*(uint64(in2[4])<<0) +\n+\t\tuint64(in[4])*(uint64(in2[3])<<0) +\n+\t\tuint64(in[5])*(uint64(in2[2])<<0) +\n+\t\tuint64(in[6])*(uint64(in2[1])<<0) +\n+\t\tuint64(in[7])*(uint64(in2[0])<<0)\n+\t// tmp[8] has the greatest value but doesn't overflow. See logic in\n+\t// p256Square.\n+\ttmp[8] = uint64(in[0])*(uint64(in2[8])<<0) +\n+\t\tuint64(in[1])*(uint64(in2[7])<<1) +\n+\t\tuint64(in[2])*(uint64(in2[6])<<0) +\n+\t\tuint64(in[3])*(uint64(in2[5])<<1) +\n+\t\tuint64(in[4])*(uint64(in2[4])<<0) +\n+\t\tuint64(in[5])*(uint64(in2[3])<<1) +\n+\t\tuint64(in[6])*(uint64(in2[2])<<0) +\n+\t\tuint64(in[7])*(uint64(in2[1])<<1) +\n+\t\tuint64(in[8])*(uint64(in2[0])<<0)\n+\ttmp[9] = uint64(in[1])*(uint64(in2[8])<<0) +\n+\t\tuint64(in[2])*(uint64(in2[7])<<0) +\n+\t\tuint64(in[3])*(uint64(in2[6])<<0) +\n+\t\tuint64(in[4])*(uint64(in2[5])<<0) +\n+\t\tuint64(in[5])*(uint64(in2[4])<<0) +\n+\t\tuint64(in[6])*(uint64(in2[3])<<0) +\n+\t\tuint64(in[7])*(uint64(in2[2])<<0) +\n+\t\tuint64(in[8])*(uint64(in2[1])<<0)\n+\ttmp[10] = uint64(in[2])*(uint64(in2[8])<<0) +\n+\t\tuint64(in[3])*(uint64(in2[7])<<1) +\n+\t\tuint64(in[4])*(uint64(in2[6])<<0) +\n+\t\tuint64(in[5])*(uint64(in2[5])<<1) +\n+\t\tuint64(in[6])*(uint64(in2[4])<<0) +\n+\t\tuint64(in[7])*(uint64(in2[3])<<1) +\n+\t\tuint64(in[8])*(uint64(in2[2])<<0)\n+\ttmp[11] = uint64(in[3])*(uint64(in2[8])<<0) +\n+\t\tuint64(in[4])*(uint64(in2[7])<<0) +\n+\t\tuint64(in[5])*(uint64(in2[6])<<0) +\n+\t\tuint64(in[6])*(uint64(in2[5])<<0) +\n+\t\tuint64(in[7])*(uint64(in2[4])<<0) +\n+\t\tuint64(in[8])*(uint64(in2[3])<<0)\n+\ttmp[12] = uint64(in[4])*(uint64(in2[8])<<0) +\n+\t\tuint64(in[5])*(uint64(in2[7])<<1) +\n+\t\tuint64(in[6])*(uint64(in2[6])<<0) +\n+\t\tuint64(in[7])*(uint64(in2[5])<<1) +\n+\t\tuint64(in[8])*(uint64(in2[4])<<0)\n+\ttmp[13] = uint64(in[5])*(uint64(in2[8])<<0) +\n+\t\tuint64(in[6])*(uint64(in2[7])<<0) +\n+\t\tuint64(in[7])*(uint64(in2[6])<<0) +\n+\t\tuint64(in[8])*(uint64(in2[5])<<0)\n+\ttmp[14] = uint64(in[6])*(uint64(in2[8])<<0) +\n+\t\tuint64(in[7])*(uint64(in2[7])<<1) +\n+\t\tuint64(in[8])*(uint64(in2[6])<<0)\n+\ttmp[15] = uint64(in[7])*(uint64(in2[8])<<0) +\n+\t\tuint64(in[8])*(uint64(in2[7])<<0)\n+\ttmp[16] = uint64(in[8]) * (uint64(in2[8]) << 0)\n+\n+\tp256ReduceDegree(out, tmp)\n+}\n+\n+func p256Assign(out, in *[p256Limbs]uint32) {\n+\t*out = *in\n+}\n+\n+// p256Invert calculates |out| = |in|^{-1}\n+//\n+// Based on Fermat's Little Theorem:\n+//   a^p = a (mod p)\n+//   a^{p-1} = 1 (mod p)\n+//   a^{p-2} = a^{-1} (mod p)\n+func p256Invert(out, in *[p256Limbs]uint32) {\n+\tvar ftmp, ftmp2 [p256Limbs]uint32\n+\n+\t// each e_I will hold |in|^{2^I - 1}\n+\tvar e2, e4, e8, e16, e32, e64 [p256Limbs]uint32\n+\n+\tp256Square(&ftmp, in)     // 2^1\n+\tp256Mul(&ftmp, in, &ftmp) // 2^2 - 2^0\n+\tp256Assign(&e2, &ftmp)\n+\tp256Square(&ftmp, &ftmp)   // 2^3 - 2^1\n+\tp256Square(&ftmp, &ftmp)   // 2^4 - 2^2\n+\tp256Mul(&ftmp, &ftmp, &e2) // 2^4 - 2^0\n+\tp256Assign(&e4, &ftmp)\n+\tp256Square(&ftmp, &ftmp)   // 2^5 - 2^1\n+\tp256Square(&ftmp, &ftmp)   // 2^6 - 2^2\n+\tp256Square(&ftmp, &ftmp)   // 2^7 - 2^3\n+\tp256Square(&ftmp, &ftmp)   // 2^8 - 2^4\n+\tp256Mul(&ftmp, &ftmp, &e4) // 2^8 - 2^0\n+\tp256Assign(&e8, &ftmp)\n+\tfor i := 0; i < 8; i++ {\n+\t\tp256Square(&ftmp, &ftmp)\n+\t} // 2^16 - 2^8\n+\tp256Mul(&ftmp, &ftmp, &e8) // 2^16 - 2^0\n+\tp256Assign(&e16, &ftmp)\n+\tfor i := 0; i < 16; i++ {\n+\t\tp256Square(&ftmp, &ftmp)\n+\t} // 2^32 - 2^16\n+\tp256Mul(&ftmp, &ftmp, &e16) // 2^32 - 2^0\n+\tp256Assign(&e32, &ftmp)\n+\tfor i := 0; i < 32; i++ {\n+\t\tp256Square(&ftmp, &ftmp)\n+\t} // 2^64 - 2^32\n+\tp256Assign(&e64, &ftmp)\n+\tp256Mul(&ftmp, &ftmp, in) // 2^64 - 2^32 + 2^0\n+\tfor i := 0; i < 192; i++ {\n+\t\tp256Square(&ftmp, &ftmp)\n+\t} // 2^256 - 2^224 + 2^192\n+\n+\tp256Mul(&ftmp2, &e64, &e32) // 2^64 - 2^0\n+\tfor i := 0; i < 16; i++ {\n+\t\tp256Square(&ftmp2, &ftmp2)\n+\t} // 2^80 - 2^16\n+\tp256Mul(&ftmp2, &ftmp2, &e16) // 2^80 - 2^0\n+\tfor i := 0; i < 8; i++ {\n+\t\tp256Square(&ftmp2, &ftmp2)\n+\t} // 2^88 - 2^8\n+\tp256Mul(&ftmp2, &ftmp2, &e8) // 2^88 - 2^0\n+\tfor i := 0; i < 4; i++ {\n+\t\tp256Square(&ftmp2, &ftmp2)\n+\t} // 2^92 - 2^4\n+\tp256Mul(&ftmp2, &ftmp2, &e4) // 2^92 - 2^0\n+\tp256Square(&ftmp2, &ftmp2)   // 2^93 - 2^1\n+\tp256Square(&ftmp2, &ftmp2)   // 2^94 - 2^2\n+\tp256Mul(&ftmp2, &ftmp2, &e2) // 2^94 - 2^0\n+\tp256Square(&ftmp2, &ftmp2)   // 2^95 - 2^1\n+\tp256Square(&ftmp2, &ftmp2)   // 2^96 - 2^2\n+\tp256Mul(&ftmp2, &ftmp2, in)  // 2^96 - 3\n+\n+\tp256Mul(out, &ftmp2, &ftmp) // 2^256 - 2^224 + 2^192 + 2^96 - 3\n+}\n+\n+// p256Scalar3 sets out=3*out.\n+//\n+// On entry: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+// On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+func p256Scalar3(out *[p256Limbs]uint32) {\n+\tvar carry uint32\n+\n+\tfor i := 0; ; i++ {\n+\t\tout[i] *= 3\n+\t\tout[i] += carry\n+\t\tcarry = out[i] >> 29\n+\t\tout[i] &= bottom29Bits\n+\n+\t\ti++\n+\t\tif i == p256Limbs {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tout[i] *= 3\n+\t\tout[i] += carry\n+\t\tcarry = out[i] >> 28\n+\t\tout[i] &= bottom28Bits\n+\t}\n+\n+\tp256ReduceCarry(out, carry)\n+}\n+\n+// p256Scalar4 sets out=4*out.\n+//\n+// On entry: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+// On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+func p256Scalar4(out *[p256Limbs]uint32) {\n+\tvar carry, nextCarry uint32\n+\n+\tfor i := 0; ; i++ {\n+\t\tnextCarry = out[i] >> 27\n+\t\tout[i] <<= 2\n+\t\tout[i] &= bottom29Bits\n+\t\tout[i] += carry\n+\t\tcarry = nextCarry + (out[i] >> 29)\n+\t\tout[i] &= bottom29Bits\n+\n+\t\ti++\n+\t\tif i == p256Limbs {\n+\t\t\tbreak\n+\t\t}\n+\t\tnextCarry = out[i] >> 26\n+\t\tout[i] <<= 2\n+\t\tout[i] &= bottom28Bits\n+\t\tout[i] += carry\n+\t\tcarry = nextCarry + (out[i] >> 28)\n+\t\tout[i] &= bottom28Bits\n+\t}\n+\n+\tp256ReduceCarry(out, carry)\n+}\n+\n+// p256Scalar8 sets out=8*out.\n+//\n+// On entry: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+// On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n+func p256Scalar8(out *[p256Limbs]uint32) {\n+\tvar carry, nextCarry uint32\n+\n+\tfor i := 0; ; i++ {\n+\t\tnextCarry = out[i] >> 26\n+\t\tout[i] <<= 3\n+\t\tout[i] &= bottom29Bits\n+\t\tout[i] += carry\n+\t\tcarry = nextCarry + (out[i] >> 29)\n+\t\tout[i] &= bottom29Bits\n+\n+\t\ti++\n+\t\tif i == p256Limbs {\n+\t\t\tbreak\n+\t\t}\n+\t\tnextCarry = out[i] >> 25\n+\t\tout[i] <<= 3\n+\t\tout[i] &= bottom28Bits\n+\t\tout[i] += carry\n+\t\tcarry = nextCarry + (out[i] >> 28)\n+\t\tout[i] &= bottom28Bits\n+\t}\n+\n+\tp256ReduceCarry(out, carry)\n+}\n+\n+// Group operations:\n+//\n+// Elements of the elliptic curve group are represented in Jacobian\n+// coordinates: (x, y, z). An affine point (x', y') is x'=x/z**2, y'=y/z**3 in\n+// Jacobian form.\n+\n+// p256PointDouble sets {xOut,yOut,zOut} = 2*{x,y,z}.\n+//\n+// See http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n+func p256PointDouble(xOut, yOut, zOut, x, y, z *[p256Limbs]uint32) {\n+\tvar delta, gamma, alpha, beta, tmp, tmp2 [p256Limbs]uint32\n+\n+\tp256Square(&delta, z)\n+\tp256Square(&gamma, y)\n+\tp256Mul(&beta, x, &gamma)\n+\n+\tp256Sum(&tmp, x, &delta)\n+\tp256Diff(&tmp2, x, &delta)\n+\tp256Mul(&alpha, &tmp, &tmp2)\n+\tp256Scalar3(&alpha)\n+\n+\tp256Sum(&tmp, y, z)\n+\tp256Square(&tmp, &tmp)\n+\tp256Diff(&tmp, &tmp, &gamma)\n+\tp256Diff(zOut, &tmp, &delta)\n+\n+\tp256Scalar4(&beta)\n+\tp256Square(xOut, &alpha)\n+\tp256Diff(xOut, xOut, &beta)\n+\tp256Diff(xOut, xOut, &beta)\n+\n+\tp256Diff(&tmp, &beta, xOut)\n+\tp256Mul(&tmp, &alpha, &tmp)\n+\tp256Square(&tmp2, &gamma)\n+\tp256Scalar8(&tmp2)\n+\tp256Diff(yOut, &tmp, &tmp2)\n+}\n+\n+// p256PointAddMixed sets {xOut,yOut,zOut} = {x1,y1,z1} + {x2,y2,1}.\n+// (i.e. the second point is affine.)\n+//\n+// See http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl\n+//\n+// Note that this function does not handle P+P, infinity+P nor P+infinity\n+// correctly.\n+func p256PointAddMixed(xOut, yOut, zOut, x1, y1, z1, x2, y2 *[p256Limbs]uint32) {\n+\tvar z1z1, z1z1z1, s2, u2, h, i, j, r, rr, v, tmp [p256Limbs]uint32\n+\n+\tp256Square(&z1z1, z1)\n+\tp256Sum(&tmp, z1, z1)\n+\n+\tp256Mul(&u2, x2, &z1z1)\n+\tp256Mul(&z1z1z1, z1, &z1z1)\n+\tp256Mul(&s2, y2, &z1z1z1)\n+\tp256Diff(&h, &u2, x1)\n+\tp256Sum(&i, &h, &h)\n+\tp256Square(&i, &i)\n+\tp256Mul(&j, &h, &i)\n+\tp256Diff(&r, &s2, y1)\n+\tp256Sum(&r, &r, &r)\n+\tp256Mul(&v, x1, &i)\n+\n+\tp256Mul(zOut, &tmp, &h)\n+\tp256Square(&rr, &r)\n+\tp256Diff(xOut, &rr, &j)\n+\tp256Diff(xOut, xOut, &v)\n+\tp256Diff(xOut, xOut, &v)\n+\n+\tp256Diff(&tmp, &v, xOut)\n+\tp256Mul(yOut, &tmp, &r)\n+\tp256Mul(&tmp, y1, &j)\n+\tp256Diff(yOut, yOut, &tmp)\n+\tp256Diff(yOut, yOut, &tmp)\n+}\n+\n+// p256PointAdd sets {xOut,yOut,zOut} = {x1,y1,z1} + {x2,y2,z2}.\n+//\n+// See http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl\n+//\n+// Note that this function does not handle P+P, infinity+P nor P+infinity\n+// correctly.\n+func p256PointAdd(xOut, yOut, zOut, x1, y1, z1, x2, y2, z2 *[p256Limbs]uint32) {\n+\tvar z1z1, z1z1z1, z2z2, z2z2z2, s1, s2, u1, u2, h, i, j, r, rr, v, tmp [p256Limbs]uint32\n+\n+\tp256Square(&z1z1, z1)\n+\tp256Square(&z2z2, z2)\n+\tp256Mul(&u1, x1, &z2z2)\n+\n+\tp256Sum(&tmp, z1, z2)\n+\tp256Square(&tmp, &tmp)\n+\tp256Diff(&tmp, &tmp, &z1z1)\n+\tp256Diff(&tmp, &tmp, &z2z2)\n+\n+\tp256Mul(&z2z2z2, z2, &z2z2)\n+\tp256Mul(&s1, y1, &z2z2z2)\n+\n+\tp256Mul(&u2, x2, &z1z1)\n+\tp256Mul(&z1z1z1, z1, &z1z1)\n+\tp256Mul(&s2, y2, &z1z1z1)\n+\tp256Diff(&h, &u2, &u1)\n+\tp256Sum(&i, &h, &h)\n+\tp256Square(&i, &i)\n+\tp256Mul(&j, &h, &i)\n+\tp256Diff(&r, &s2, &s1)\n+\tp256Sum(&r, &r, &r)\n+\tp256Mul(&v, &u1, &i)\n+\n+\tp256Mul(zOut, &tmp, &h)\n+\tp256Square(&rr, &r)\n+\tp256Diff(xOut, &rr, &j)\n+\tp256Diff(xOut, xOut, &v)\n+\tp256Diff(xOut, xOut, &v)\n+\n+\tp256Diff(&tmp, &v, xOut)\n+\tp256Mul(yOut, &tmp, &r)\n+\tp256Mul(&tmp, &s1, &j)\n+\tp256Diff(yOut, yOut, &tmp)\n+\tp256Diff(yOut, yOut, &tmp)\n+}\n+\n+// p256CopyConditional sets out=in if mask = 0xffffffff in constant time.\n+//\n+// On entry: mask is either 0 or 0xffffffff.\n+func p256CopyConditional(out, in *[p256Limbs]uint32, mask uint32) {\n+\tfor i := 0; i < p256Limbs; i++ {\n+\t\ttmp := mask & (in[i] ^ out[i])\n+\t\tout[i] ^= tmp\n+\t}\n+}\n+\n+// p256SelectAffinePoint sets {out_x,out_y} to the index'th entry of table.\n+// On entry: index < 16, table[0] must be zero.\n+func p256SelectAffinePoint(xOut, yOut *[p256Limbs]uint32, table []uint32, index uint32) {\n+\tfor i := range xOut {\n+\t\txOut[i] = 0\n+\t}\n+\tfor i := range yOut {\n+\t\tyOut[i] = 0\n+\t}\n+\n+\tfor i := uint32(1); i < 16; i++ {\n+\t\tmask := i ^ index\n+\t\tmask |= mask >> 2\n+\t\tmask |= mask >> 1\n+\t\tmask &= 1\n+\t\tmask--\n+\t\tfor j := range xOut {\n+\t\t\txOut[j] |= table[0] & mask\n+\t\t\ttable = table[1:]\n+\t\t}\n+\t\tfor j := range yOut {\n+\t\t\tyOut[j] |= table[0] & mask\n+\t\t\ttable = table[1:]\n+\t\t}\n+\t}\n+}\n+\n+// p256SelectJacobianPoint sets {out_x,out_y,out_z} to the index'th entry of\n+// table.\n+// On entry: index < 16, table[0] must be zero.\n+func p256SelectJacobianPoint(xOut, yOut, zOut *[p256Limbs]uint32, table *[16][3][p256Limbs]uint32, index uint32) {\n+\tfor i := range xOut {\n+\t\txOut[i] = 0\n+\t}\n+\tfor i := range yOut {\n+\t\tyOut[i] = 0\n+\t}\n+\tfor i := range zOut {\n+\t\tzOut[i] = 0\n+\t}\n+\n+\t// The implicit value at index 0 is all zero. We don't need to perform that\n+\t// iteration of the loop because we already set out_* to zero.\n+\tfor i := uint32(1); i < 16; i++ {\n+\t\tmask := i ^ index\n+\t\tmask |= mask >> 2\n+\t\tmask |= mask >> 1\n+\t\tmask &= 1\n+\t\tmask--\n+\t\tfor j := range xOut {\n+\t\t\txOut[j] |= table[i][0][j] & mask\n+\t\t}\n+\t\tfor j := range yOut {\n+\t\t\tyOut[j] |= table[i][1][j] & mask\n+\t\t}\n+\t\tfor j := range zOut {\n+\t\t\tzOut[j] |= table[i][2][j] & mask\n+\t\t}\n+\t}\n+}\n+\n+// p256GetBit returns the bit'th bit of scalar.\n+func p256GetBit(scalar *[32]uint8, bit uint) uint32 {\n+\treturn uint32(((scalar[bit>>3]) >> (bit & 7)) & 1)\n+}\n+\n+// p256ScalarBaseMult sets {xOut,yOut,zOut} = scalar*G where scalar is a\n+// little-endian number. Note that the value of scalar must be less than the\n+// order of the group.\n+func p256ScalarBaseMult(xOut, yOut, zOut *[p256Limbs]uint32, scalar *[32]uint8) {\n+\tnIsInfinityMask := ^uint32(0)\n+\tvar pIsNoninfiniteMask, mask, tableOffset uint32\n+\tvar px, py, tx, ty, tz [p256Limbs]uint32\n+\n+\tfor i := range xOut {\n+\t\txOut[i] = 0\n+\t}\n+\tfor i := range yOut {\n+\t\tyOut[i] = 0\n+\t}\n+\tfor i := range zOut {\n+\t\tzOut[i] = 0\n+\t}\n+\n+\t// The loop adds bits at positions 0, 64, 128 and 192, followed by\n+\t// positions 32,96,160 and 224 and does this 32 times.\n+\tfor i := uint(0); i < 32; i++ {\n+\t\tif i != 0 {\n+\t\t\tp256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut)\n+\t\t}\n+\t\ttableOffset = 0\n+\t\tfor j := uint(0); j <= 32; j += 32 {\n+\t\t\tbit0 := p256GetBit(scalar, 31-i+j)\n+\t\t\tbit1 := p256GetBit(scalar, 95-i+j)\n+\t\t\tbit2 := p256GetBit(scalar, 159-i+j)\n+\t\t\tbit3 := p256GetBit(scalar, 223-i+j)\n+\t\t\tindex := bit0 | (bit1 << 1) | (bit2 << 2) | (bit3 << 3)\n+\n+\t\t\tp256SelectAffinePoint(&px, &py, p256Precomputed[tableOffset:], index)\n+\t\t\ttableOffset += 30 * p256Limbs\n+\n+\t\t\t// Since scalar is less than the order of the group, we know that\n+\t\t\t// {xOut,yOut,zOut} != {px,py,1}, unless both are zero, which we handle\n+\t\t\t// below.\n+\t\t\tp256PointAddMixed(&tx, &ty, &tz, xOut, yOut, zOut, &px, &py)\n+\t\t\t// The result of pointAddMixed is incorrect if {xOut,yOut,zOut} is zero\n+\t\t\t// (a.k.a.  the point at infinity). We handle that situation by\n+\t\t\t// copying the point from the table.\n+\t\t\tp256CopyConditional(xOut, &px, nIsInfinityMask)\n+\t\t\tp256CopyConditional(yOut, &py, nIsInfinityMask)\n+\t\t\tp256CopyConditional(zOut, &p256One, nIsInfinityMask)\n+\n+\t\t\t// Equally, the result is also wrong if the point from the table is\n+\t\t\t// zero, which happens when the index is zero. We handle that by\n+\t\t\t// only copying from {tx,ty,tz} to {xOut,yOut,zOut} if index != 0.\n+\t\t\tpIsNoninfiniteMask = nonZeroToAllOnes(index)\n+\t\t\tmask = pIsNoninfiniteMask & ^nIsInfinityMask\n+\t\t\tp256CopyConditional(xOut, &tx, mask)\n+\t\t\tp256CopyConditional(yOut, &ty, mask)\n+\t\t\tp256CopyConditional(zOut, &tz, mask)\n+\t\t\t// If p was not zero, then n is now non-zero.\n+\t\t\tnIsInfinityMask &= ^pIsNoninfiniteMask\n+\t\t}\n+\t}\n+}\n+\n+// p256PointToAffine converts a Jacobian point to an affine point. If the input\n+// is the point at infinity then it returns (0, 0) in constant time.\n+func p256PointToAffine(xOut, yOut, x, y, z *[p256Limbs]uint32) {\n+\tvar zInv, zInvSq [p256Limbs]uint32\n+\n+\tp256Invert(&zInv, z)\n+\tp256Square(&zInvSq, &zInv)\n+\tp256Mul(xOut, x, &zInvSq)\n+\tp256Mul(&zInv, &zInv, &zInvSq)\n+\tp256Mul(yOut, y, &zInv)\n+}\n+\n+// p256ToAffine returns a pair of *big.Int containing the affine representation\n+// of {x,y,z}.\n+func p256ToAffine(x, y, z *[p256Limbs]uint32) (xOut, yOut *big.Int) {\n+\tvar xx, yy [p256Limbs]uint32\n+\tp256PointToAffine(&xx, &yy, x, y, z)\n+\treturn p256ToBig(&xx), p256ToBig(&yy)\n+}\n+\n+// p256ScalarMult sets {xOut,yOut,zOut} = scalar*{x,y}.\n+func p256ScalarMult(xOut, yOut, zOut, x, y *[p256Limbs]uint32, scalar *[32]uint8) {\n+\tvar px, py, pz, tx, ty, tz [p256Limbs]uint32\n+\tvar precomp [16][3][p256Limbs]uint32\n+\tvar nIsInfinityMask, index, pIsNoninfiniteMask, mask uint32\n+\n+\t// We precompute 0,1,2,... times {x,y}.\n+\tprecomp[1][0] = *x\n+\tprecomp[1][1] = *y\n+\tprecomp[1][2] = p256One\n+\n+\tfor i := 2; i < 16; i += 2 {\n+\t\tp256PointDouble(&precomp[i][0], &precomp[i][1], &precomp[i][2], &precomp[i/2][0], &precomp[i/2][1], &precomp[i/2][2])\n+\t\tp256PointAddMixed(&precomp[i+1][0], &precomp[i+1][1], &precomp[i+1][2], &precomp[i][0], &precomp[i][1], &precomp[i][2], x, y)\n+\t}\n+\n+\tfor i := range xOut {\n+\t\txOut[i] = 0\n+\t}\n+\tfor i := range yOut {\n+\t\tyOut[i] = 0\n+\t}\n+\tfor i := range zOut {\n+\t\tzOut[i] = 0\n+\t}\n+\tnIsInfinityMask = ^uint32(0)\n+\n+\t// We add in a window of four bits each iteration and do this 64 times.\n+\tfor i := 0; i < 64; i++ {\n+\t\tif i != 0 {\n+\t\t\tp256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut)\n+\t\t\tp256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut)\n+\t\t\tp256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut)\n+\t\t\tp256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut)\n+\t\t}\n+\n+\t\tindex = uint32(scalar[31-i/2])\n+\t\tif (i & 1) == 1 {\n+\t\t\tindex &= 15\n+\t\t} else {\n+\t\t\tindex >>= 4\n+\t\t}\n+\n+\t\t// See the comments in scalarBaseMult about handling infinities.\n+\t\tp256SelectJacobianPoint(&px, &py, &pz, &precomp, index)\n+\t\tp256PointAdd(&tx, &ty, &tz, xOut, yOut, zOut, &px, &py, &pz)\n+\t\tp256CopyConditional(xOut, &px, nIsInfinityMask)\n+\t\tp256CopyConditional(yOut, &py, nIsInfinityMask)\n+\t\tp256CopyConditional(zOut, &pz, nIsInfinityMask)\n+\n+\t\tpIsNoninfiniteMask = nonZeroToAllOnes(index)\n+\t\tmask = pIsNoninfiniteMask & ^nIsInfinityMask\n+\t\tp256CopyConditional(xOut, &tx, mask)\n+\t\tp256CopyConditional(yOut, &ty, mask)\n+\t\tp256CopyConditional(zOut, &tz, mask)\n+\t\tnIsInfinityMask &= ^pIsNoninfiniteMask\n+\t}\n+}\n+\n+// p256FromBig sets out = R*in.\n+func p256FromBig(out *[p256Limbs]uint32, in *big.Int) {\n+\ttmp := new(big.Int).Lsh(in, 257)\n+\ttmp.Mod(tmp, p256.P)\n+\n+\tfor i := 0; i < p256Limbs; i++ {\n+\t\tif bits := tmp.Bits(); len(bits) > 0 {\n+\t\t\tout[i] = uint32(bits[0]) & bottom29Bits\n+\t\t} else {\n+\t\t\tout[i] = 0\n+\t\t}\n+\t\ttmp.Rsh(tmp, 29)\n+\n+\t\ti++\n+\t\tif i == p256Limbs {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tif bits := tmp.Bits(); len(bits) > 0 {\n+\t\t\tout[i] = uint32(bits[0]) & bottom28Bits\n+\t\t} else {\n+\t\t\tout[i] = 0\n+\t\t}\n+\t\ttmp.Rsh(tmp, 28)\n+\t}\n+}\n+\n+// p256ToBig returns a *big.Int containing the value of in.\n+func p256ToBig(in *[p256Limbs]uint32) *big.Int {\n+\tresult, tmp := new(big.Int), new(big.Int)\n+\n+\tresult.SetInt64(int64(in[p256Limbs-1]))\n+\tfor i := p256Limbs - 2; i >= 0; i-- {\n+\t\tif (i & 1) == 0 {\n+\t\t\tresult.Lsh(result, 29)\n+\t\t} else {\n+\t\t\tresult.Lsh(result, 28)\n+\t\t}\n+\t\ttmp.SetInt64(int64(in[i]))\n+\t\tresult.Add(result, tmp)\n+\t}\n+\n+\tresult.Mul(result, p256RInverse)\n+\tresult.Mod(result, p256.P)\n+\treturn result\n+}"}, {"sha": "ccaa7c13d38d56d9d0af077bad1d4f35de862d9c", "filename": "libgo/go/crypto/md5/gen.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -164,7 +164,7 @@ var program = `\n // DO NOT EDIT.\n // Generate with: go run gen.go{{if .Full}} -full{{end}} | gofmt >md5block.go\n \n-// +build !amd64\n+// +build !amd64,!386,!arm\n \n package md5\n "}, {"sha": "1a1f35fabc0d7b696d1201ec3601583f260bc6ac", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -88,7 +88,11 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := *d0\n+\thash := d.checkSum()\n+\treturn append(in, hash[:]...)\n+}\n \n+func (d *digest) checkSum() [Size]byte {\n \t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tlen := d.len\n \tvar tmp [64]byte\n@@ -118,5 +122,13 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t\tdigest[i*4+3] = byte(s >> 24)\n \t}\n \n-\treturn append(in, digest[:]...)\n+\treturn digest\n+}\n+\n+// Sum returns the MD5 checksum of the data.\n+func Sum(data []byte) [Size]byte {\n+\tvar d digest\n+\td.Reset()\n+\td.Write(data)\n+\treturn d.checkSum()\n }"}, {"sha": "a8b7a1a525284b3f72cb32ca3b8cf6f26312cac7", "filename": "libgo/go/crypto/md5/md5_test.go", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -53,6 +53,10 @@ var golden = []md5Test{\n func TestGolden(t *testing.T) {\n \tfor i := 0; i < len(golden); i++ {\n \t\tg := golden[i]\n+\t\ts := fmt.Sprintf(\"%x\", Sum([]byte(g.in)))\n+\t\tif s != g.out {\n+\t\t\tt.Fatalf(\"Sum function: md5(%s) = %s want %s\", g.in, s, g.out)\n+\t\t}\n \t\tc := New()\n \t\tbuf := make([]byte, len(g.in)+4)\n \t\tfor j := 0; j < 3+4; j++ {\n@@ -77,12 +81,28 @@ func TestGolden(t *testing.T) {\n \t}\n }\n \n-func ExampleNew() {\n-\th := New()\n-\tio.WriteString(h, \"The fog is getting thicker!\")\n-\tio.WriteString(h, \"And Leon's getting laaarger!\")\n-\tfmt.Printf(\"%x\", h.Sum(nil))\n-\t// Output: e2c569be17396eca2a2e3c11578123ed\n+func TestLarge(t *testing.T) {\n+\tconst N = 10000\n+\tok := \"2bb571599a4180e1d542f76904adc3df\" // md5sum of \"0123456789\" * 1000\n+\tblock := make([]byte, 10004)\n+\tc := New()\n+\tfor offset := 0; offset < 4; offset++ {\n+\t\tfor i := 0; i < N; i++ {\n+\t\t\tblock[offset+i] = '0' + byte(i%10)\n+\t\t}\n+\t\tfor blockSize := 10; blockSize <= N; blockSize *= 10 {\n+\t\t\tblocks := N / blockSize\n+\t\t\tb := block[offset : offset+blockSize]\n+\t\t\tc.Reset()\n+\t\t\tfor i := 0; i < blocks; i++ {\n+\t\t\t\tc.Write(b)\n+\t\t\t}\n+\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n+\t\t\tif s != ok {\n+\t\t\t\tt.Fatalf(\"md5 TestLarge offset=%d, blockSize=%d = %s want %s\", offset, blockSize, s, ok)\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n var bench = New()"}, {"sha": "3e739e36ffd764790a20d6b15821f29ab396dc04", "filename": "libgo/go/crypto/md5/md5block.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -1,7 +1,7 @@\n // DO NOT EDIT.\n // Generate with: go run gen.go -full | gofmt >md5block.go\n \n-// +build !amd64,!386\n+// +build !amd64,!386,!arm\n \n package md5\n "}, {"sha": "c4d6aaaf03a1e33b46feac4bfda30c3639ae69f1", "filename": "libgo/go/crypto/md5/md5block_decl.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -2,8 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 386\n+// +build amd64 386 arm\n \n package md5\n \n+//go:noescape\n+\n func block(dig *digest, p []byte)"}, {"sha": "4da3adb7010535695838296e7eca00c59a9aa811", "filename": "libgo/go/crypto/rand/rand.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -14,5 +14,8 @@ import \"io\"\n // On Windows systems, Reader uses the CryptGenRandom API.\n var Reader io.Reader\n \n-// Read is a helper function that calls Reader.Read.\n-func Read(b []byte) (n int, err error) { return Reader.Read(b) }\n+// Read is a helper function that calls Reader.Read using io.ReadFull.\n+// On return, n == len(b) if and only if err == nil.\n+func Read(b []byte) (n int, err error) {\n+\treturn io.ReadFull(Reader, b)\n+}"}, {"sha": "238ceee557dbcb391cf09e2941186d04af0c5c69", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux netbsd openbsd plan9\n+// +build darwin dragonfly freebsd linux netbsd openbsd plan9\n \n // Unix cryptographically secure pseudorandom number\n // generator."}, {"sha": "1a055a3d623c251e24f24a056d2ede50b0c7ae20", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -124,7 +124,11 @@ func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid\n \t\tlookingForIndex = subtle.ConstantTimeSelect(equals0, 0, lookingForIndex)\n \t}\n \n-\tvalid = firstByteIsZero & secondByteIsTwo & (^lookingForIndex & 1)\n+\t// The PS padding must be at least 8 bytes long, and it starts two\n+\t// bytes into em.\n+\tvalidPS := subtle.ConstantTimeLessOrEq(2+8, index)\n+\n+\tvalid = firstByteIsZero & secondByteIsTwo & (^lookingForIndex & 1) & validPS\n \tmsg = em[index+1:]\n \treturn\n }"}, {"sha": "70bb2288996907b7034746d181050f663ddd950e", "filename": "libgo/go/crypto/rsa/pkcs1v15_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -197,6 +197,14 @@ func TestVerifyPKCS1v15(t *testing.T) {\n \t}\n }\n \n+func TestOverlongMessagePKCS1v15(t *testing.T) {\n+\tciphertext := decodeBase64(\"fjOVdirUzFoLlukv80dBllMLjXythIf22feqPrNo0YoIjzyzyoMFiLjAc/Y4krkeZ11XFThIrEvw\\nkRiZcCq5ng==\")\n+\t_, err := DecryptPKCS1v15(nil, rsaPrivateKey, ciphertext)\n+\tif err == nil {\n+\t\tt.Error(\"RSA decrypted a message that was too long.\")\n+\t}\n+}\n+\n // In order to generate new test vectors you'll need the PEM form of this key:\n // -----BEGIN RSA PRIVATE KEY-----\n // MIIBOgIBAAJBALKZD0nEffqM1ACuak0bijtqE2QrI/KLADv7l3kK3ppMyCuLKoF0"}, {"sha": "f9abec39490052209649619c53ef4935b5314d80", "filename": "libgo/go/crypto/rsa/pss.go", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -0,0 +1,282 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package rsa\n+\n+// This file implementes the PSS signature scheme [1].\n+//\n+// [1] http://www.rsa.com/rsalabs/pkcs/files/h11300-wp-pkcs-1v2-2-rsa-cryptography-standard.pdf\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto\"\n+\t\"errors\"\n+\t\"hash\"\n+\t\"io\"\n+\t\"math/big\"\n+)\n+\n+func emsaPSSEncode(mHash []byte, emBits int, salt []byte, hash hash.Hash) ([]byte, error) {\n+\t// See [1], section 9.1.1\n+\thLen := hash.Size()\n+\tsLen := len(salt)\n+\temLen := (emBits + 7) / 8\n+\n+\t// 1.  If the length of M is greater than the input limitation for the\n+\t//     hash function (2^61 - 1 octets for SHA-1), output \"message too\n+\t//     long\" and stop.\n+\t//\n+\t// 2.  Let mHash = Hash(M), an octet string of length hLen.\n+\n+\tif len(mHash) != hLen {\n+\t\treturn nil, errors.New(\"crypto/rsa: input must be hashed message\")\n+\t}\n+\n+\t// 3.  If emLen < hLen + sLen + 2, output \"encoding error\" and stop.\n+\n+\tif emLen < hLen+sLen+2 {\n+\t\treturn nil, errors.New(\"crypto/rsa: encoding error\")\n+\t}\n+\n+\tem := make([]byte, emLen)\n+\tdb := em[:emLen-sLen-hLen-2+1+sLen]\n+\th := em[emLen-sLen-hLen-2+1+sLen : emLen-1]\n+\n+\t// 4.  Generate a random octet string salt of length sLen; if sLen = 0,\n+\t//     then salt is the empty string.\n+\t//\n+\t// 5.  Let\n+\t//       M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;\n+\t//\n+\t//     M' is an octet string of length 8 + hLen + sLen with eight\n+\t//     initial zero octets.\n+\t//\n+\t// 6.  Let H = Hash(M'), an octet string of length hLen.\n+\n+\tvar prefix [8]byte\n+\n+\thash.Write(prefix[:])\n+\thash.Write(mHash)\n+\thash.Write(salt)\n+\n+\th = hash.Sum(h[:0])\n+\thash.Reset()\n+\n+\t// 7.  Generate an octet string PS consisting of emLen - sLen - hLen - 2\n+\t//     zero octets.  The length of PS may be 0.\n+\t//\n+\t// 8.  Let DB = PS || 0x01 || salt; DB is an octet string of length\n+\t//     emLen - hLen - 1.\n+\n+\tdb[emLen-sLen-hLen-2] = 0x01\n+\tcopy(db[emLen-sLen-hLen-1:], salt)\n+\n+\t// 9.  Let dbMask = MGF(H, emLen - hLen - 1).\n+\t//\n+\t// 10. Let maskedDB = DB \\xor dbMask.\n+\n+\tmgf1XOR(db, hash, h)\n+\n+\t// 11. Set the leftmost 8 * emLen - emBits bits of the leftmost octet in\n+\t//     maskedDB to zero.\n+\n+\tdb[0] &= (0xFF >> uint(8*emLen-emBits))\n+\n+\t// 12. Let EM = maskedDB || H || 0xbc.\n+\tem[emLen-1] = 0xBC\n+\n+\t// 13. Output EM.\n+\treturn em, nil\n+}\n+\n+func emsaPSSVerify(mHash, em []byte, emBits, sLen int, hash hash.Hash) error {\n+\t// 1.  If the length of M is greater than the input limitation for the\n+\t//     hash function (2^61 - 1 octets for SHA-1), output \"inconsistent\"\n+\t//     and stop.\n+\t//\n+\t// 2.  Let mHash = Hash(M), an octet string of length hLen.\n+\thLen := hash.Size()\n+\tif hLen != len(mHash) {\n+\t\treturn ErrVerification\n+\t}\n+\n+\t// 3.  If emLen < hLen + sLen + 2, output \"inconsistent\" and stop.\n+\temLen := (emBits + 7) / 8\n+\tif emLen < hLen+sLen+2 {\n+\t\treturn ErrVerification\n+\t}\n+\n+\t// 4.  If the rightmost octet of EM does not have hexadecimal value\n+\t//     0xbc, output \"inconsistent\" and stop.\n+\tif em[len(em)-1] != 0xBC {\n+\t\treturn ErrVerification\n+\t}\n+\n+\t// 5.  Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\n+\t//     let H be the next hLen octets.\n+\tdb := em[:emLen-hLen-1]\n+\th := em[emLen-hLen-1 : len(em)-1]\n+\n+\t// 6.  If the leftmost 8 * emLen - emBits bits of the leftmost octet in\n+\t//     maskedDB are not all equal to zero, output \"inconsistent\" and\n+\t//     stop.\n+\tif em[0]&(0xFF<<uint(8-(8*emLen-emBits))) != 0 {\n+\t\treturn ErrVerification\n+\t}\n+\n+\t// 7.  Let dbMask = MGF(H, emLen - hLen - 1).\n+\t//\n+\t// 8.  Let DB = maskedDB \\xor dbMask.\n+\tmgf1XOR(db, hash, h)\n+\n+\t// 9.  Set the leftmost 8 * emLen - emBits bits of the leftmost octet in DB\n+\t//     to zero.\n+\tdb[0] &= (0xFF >> uint(8*emLen-emBits))\n+\n+\tif sLen == PSSSaltLengthAuto {\n+\tFindSaltLength:\n+\t\tfor sLen = emLen - (hLen + 2); sLen >= 0; sLen-- {\n+\t\t\tswitch db[emLen-hLen-sLen-2] {\n+\t\t\tcase 1:\n+\t\t\t\tbreak FindSaltLength\n+\t\t\tcase 0:\n+\t\t\t\tcontinue\n+\t\t\tdefault:\n+\t\t\t\treturn ErrVerification\n+\t\t\t}\n+\t\t}\n+\t\tif sLen < 0 {\n+\t\t\treturn ErrVerification\n+\t\t}\n+\t} else {\n+\t\t// 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n+\t\t//     or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n+\t\t//     position is \"position 1\") does not have hexadecimal value 0x01,\n+\t\t//     output \"inconsistent\" and stop.\n+\t\tfor _, e := range db[:emLen-hLen-sLen-2] {\n+\t\t\tif e != 0x00 {\n+\t\t\t\treturn ErrVerification\n+\t\t\t}\n+\t\t}\n+\t\tif db[emLen-hLen-sLen-2] != 0x01 {\n+\t\t\treturn ErrVerification\n+\t\t}\n+\t}\n+\n+\t// 11.  Let salt be the last sLen octets of DB.\n+\tsalt := db[len(db)-sLen:]\n+\n+\t// 12.  Let\n+\t//          M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt ;\n+\t//     M' is an octet string of length 8 + hLen + sLen with eight\n+\t//     initial zero octets.\n+\t//\n+\t// 13. Let H' = Hash(M'), an octet string of length hLen.\n+\tvar prefix [8]byte\n+\thash.Write(prefix[:])\n+\thash.Write(mHash)\n+\thash.Write(salt)\n+\n+\th0 := hash.Sum(nil)\n+\n+\t// 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\"\n+\tif !bytes.Equal(h0, h) {\n+\t\treturn ErrVerification\n+\t}\n+\treturn nil\n+}\n+\n+// signPSSWithSalt calculates the signature of hashed using PSS [1] with specified salt.\n+// Note that hashed must be the result of hashing the input message using the\n+// given hash funcion. salt is a random sequence of bytes whose length will be\n+// later used to verify the signature.\n+func signPSSWithSalt(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed, salt []byte) (s []byte, err error) {\n+\tnBits := priv.N.BitLen()\n+\tem, err := emsaPSSEncode(hashed, nBits-1, salt, hash.New())\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tm := new(big.Int).SetBytes(em)\n+\tc, err := decrypt(rand, priv, m)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\ts = make([]byte, (nBits+7)/8)\n+\tcopyWithLeftPad(s, c.Bytes())\n+\treturn\n+}\n+\n+const (\n+\t// PSSSaltLengthAuto causes the salt in a PSS signature to be as large\n+\t// as possible when signing, and to be auto-detected when verifying.\n+\tPSSSaltLengthAuto = 0\n+\t// PSSSaltLengthEqualsHash causes the salt length to equal the length\n+\t// of the hash used in the signature.\n+\tPSSSaltLengthEqualsHash = -1\n+)\n+\n+// PSSOptions contains options for creating and verifying PSS signatures.\n+type PSSOptions struct {\n+\t// SaltLength controls the length of the salt used in the PSS\n+\t// signature. It can either be a number of bytes, or one of the special\n+\t// PSSSaltLength constants.\n+\tSaltLength int\n+}\n+\n+func (opts *PSSOptions) saltLength() int {\n+\tif opts == nil {\n+\t\treturn PSSSaltLengthAuto\n+\t}\n+\treturn opts.SaltLength\n+}\n+\n+// SignPSS calculates the signature of hashed using RSASSA-PSS [1].\n+// Note that hashed must be the result of hashing the input message using the\n+// given hash funcion. The opts argument may be nil, in which case sensible\n+// defaults are used.\n+func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) (s []byte, err error) {\n+\tsaltLength := opts.saltLength()\n+\tswitch saltLength {\n+\tcase PSSSaltLengthAuto:\n+\t\tsaltLength = (priv.N.BitLen()+7)/8 - 2 - hash.Size()\n+\tcase PSSSaltLengthEqualsHash:\n+\t\tsaltLength = hash.Size()\n+\t}\n+\n+\tsalt := make([]byte, saltLength)\n+\tif _, err = io.ReadFull(rand, salt); err != nil {\n+\t\treturn\n+\t}\n+\treturn signPSSWithSalt(rand, priv, hash, hashed, salt)\n+}\n+\n+// VerifyPSS verifies a PSS signature.\n+// hashed is the result of hashing the input message using the given hash\n+// function and sig is the signature. A valid signature is indicated by\n+// returning a nil error. The opts argument may be nil, in which case sensible\n+// defaults are used.\n+func VerifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions) error {\n+\treturn verifyPSS(pub, hash, hashed, sig, opts.saltLength())\n+}\n+\n+// verifyPSS verifies a PSS signature with the given salt length.\n+func verifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, saltLen int) error {\n+\tnBits := pub.N.BitLen()\n+\tif len(sig) != (nBits+7)/8 {\n+\t\treturn ErrVerification\n+\t}\n+\ts := new(big.Int).SetBytes(sig)\n+\tm := encrypt(new(big.Int), pub, s)\n+\temBits := nBits - 1\n+\temLen := (emBits + 7) / 8\n+\tif emLen < len(m.Bytes()) {\n+\t\treturn ErrVerification\n+\t}\n+\tem := make([]byte, emLen)\n+\tcopyWithLeftPad(em, m.Bytes())\n+\tif saltLen == PSSSaltLengthEqualsHash {\n+\t\tsaltLen = hash.Size()\n+\t}\n+\treturn emsaPSSVerify(hashed, em, emBits, saltLen, hash.New())\n+}"}, {"sha": "32e6fc39d291890bb17357f20d68af83f69aa474", "filename": "libgo/go/crypto/rsa/pss_test.go", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package rsa\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"compress/bzip2\"\n+\t\"crypto\"\n+\t_ \"crypto/md5\"\n+\t\"crypto/rand\"\n+\t\"crypto/sha1\"\n+\t_ \"crypto/sha256\"\n+\t\"encoding/hex\"\n+\t\"math/big\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestEMSAPSS(t *testing.T) {\n+\t// Test vector in file pss-int.txt from: ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip\n+\tmsg := []byte{\n+\t\t0x85, 0x9e, 0xef, 0x2f, 0xd7, 0x8a, 0xca, 0x00, 0x30, 0x8b,\n+\t\t0xdc, 0x47, 0x11, 0x93, 0xbf, 0x55, 0xbf, 0x9d, 0x78, 0xdb,\n+\t\t0x8f, 0x8a, 0x67, 0x2b, 0x48, 0x46, 0x34, 0xf3, 0xc9, 0xc2,\n+\t\t0x6e, 0x64, 0x78, 0xae, 0x10, 0x26, 0x0f, 0xe0, 0xdd, 0x8c,\n+\t\t0x08, 0x2e, 0x53, 0xa5, 0x29, 0x3a, 0xf2, 0x17, 0x3c, 0xd5,\n+\t\t0x0c, 0x6d, 0x5d, 0x35, 0x4f, 0xeb, 0xf7, 0x8b, 0x26, 0x02,\n+\t\t0x1c, 0x25, 0xc0, 0x27, 0x12, 0xe7, 0x8c, 0xd4, 0x69, 0x4c,\n+\t\t0x9f, 0x46, 0x97, 0x77, 0xe4, 0x51, 0xe7, 0xf8, 0xe9, 0xe0,\n+\t\t0x4c, 0xd3, 0x73, 0x9c, 0x6b, 0xbf, 0xed, 0xae, 0x48, 0x7f,\n+\t\t0xb5, 0x56, 0x44, 0xe9, 0xca, 0x74, 0xff, 0x77, 0xa5, 0x3c,\n+\t\t0xb7, 0x29, 0x80, 0x2f, 0x6e, 0xd4, 0xa5, 0xff, 0xa8, 0xba,\n+\t\t0x15, 0x98, 0x90, 0xfc,\n+\t}\n+\tsalt := []byte{\n+\t\t0xe3, 0xb5, 0xd5, 0xd0, 0x02, 0xc1, 0xbc, 0xe5, 0x0c, 0x2b,\n+\t\t0x65, 0xef, 0x88, 0xa1, 0x88, 0xd8, 0x3b, 0xce, 0x7e, 0x61,\n+\t}\n+\texpected := []byte{\n+\t\t0x66, 0xe4, 0x67, 0x2e, 0x83, 0x6a, 0xd1, 0x21, 0xba, 0x24,\n+\t\t0x4b, 0xed, 0x65, 0x76, 0xb8, 0x67, 0xd9, 0xa4, 0x47, 0xc2,\n+\t\t0x8a, 0x6e, 0x66, 0xa5, 0xb8, 0x7d, 0xee, 0x7f, 0xbc, 0x7e,\n+\t\t0x65, 0xaf, 0x50, 0x57, 0xf8, 0x6f, 0xae, 0x89, 0x84, 0xd9,\n+\t\t0xba, 0x7f, 0x96, 0x9a, 0xd6, 0xfe, 0x02, 0xa4, 0xd7, 0x5f,\n+\t\t0x74, 0x45, 0xfe, 0xfd, 0xd8, 0x5b, 0x6d, 0x3a, 0x47, 0x7c,\n+\t\t0x28, 0xd2, 0x4b, 0xa1, 0xe3, 0x75, 0x6f, 0x79, 0x2d, 0xd1,\n+\t\t0xdc, 0xe8, 0xca, 0x94, 0x44, 0x0e, 0xcb, 0x52, 0x79, 0xec,\n+\t\t0xd3, 0x18, 0x3a, 0x31, 0x1f, 0xc8, 0x96, 0xda, 0x1c, 0xb3,\n+\t\t0x93, 0x11, 0xaf, 0x37, 0xea, 0x4a, 0x75, 0xe2, 0x4b, 0xdb,\n+\t\t0xfd, 0x5c, 0x1d, 0xa0, 0xde, 0x7c, 0xec, 0xdf, 0x1a, 0x89,\n+\t\t0x6f, 0x9d, 0x8b, 0xc8, 0x16, 0xd9, 0x7c, 0xd7, 0xa2, 0xc4,\n+\t\t0x3b, 0xad, 0x54, 0x6f, 0xbe, 0x8c, 0xfe, 0xbc,\n+\t}\n+\n+\thash := sha1.New()\n+\thash.Write(msg)\n+\thashed := hash.Sum(nil)\n+\n+\tencoded, err := emsaPSSEncode(hashed, 1023, salt, sha1.New())\n+\tif err != nil {\n+\t\tt.Errorf(\"Error from emsaPSSEncode: %s\\n\", err)\n+\t}\n+\tif !bytes.Equal(encoded, expected) {\n+\t\tt.Errorf(\"Bad encoding. got %x, want %x\", encoded, expected)\n+\t}\n+\n+\tif err = emsaPSSVerify(hashed, encoded, 1023, len(salt), sha1.New()); err != nil {\n+\t\tt.Errorf(\"Bad verification: %s\", err)\n+\t}\n+}\n+\n+// TestPSSGolden tests all the test vectors in pss-vect.txt from\n+// ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip\n+func TestPSSGolden(t *testing.T) {\n+\tinFile, err := os.Open(\"testdata/pss-vect.txt.bz2\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to open input file: %s\", err)\n+\t}\n+\tdefer inFile.Close()\n+\n+\t// The pss-vect.txt file contains RSA keys and then a series of\n+\t// signatures. A goroutine is used to preprocess the input by merging\n+\t// lines, removing spaces in hex values and identifying the start of\n+\t// new keys and signature blocks.\n+\tconst newKeyMarker = \"START NEW KEY\"\n+\tconst newSignatureMarker = \"START NEW SIGNATURE\"\n+\n+\tvalues := make(chan string)\n+\n+\tgo func() {\n+\t\tdefer close(values)\n+\t\tscanner := bufio.NewScanner(bzip2.NewReader(inFile))\n+\t\tvar partialValue string\n+\t\tlastWasValue := true\n+\n+\t\tfor scanner.Scan() {\n+\t\t\tline := scanner.Text()\n+\t\t\tswitch {\n+\t\t\tcase len(line) == 0:\n+\t\t\t\tif len(partialValue) > 0 {\n+\t\t\t\t\tvalues <- strings.Replace(partialValue, \" \", \"\", -1)\n+\t\t\t\t\tpartialValue = \"\"\n+\t\t\t\t\tlastWasValue = true\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\tcase strings.HasPrefix(line, \"# ======\") && lastWasValue:\n+\t\t\t\tvalues <- newKeyMarker\n+\t\t\t\tlastWasValue = false\n+\t\t\tcase strings.HasPrefix(line, \"# ------\") && lastWasValue:\n+\t\t\t\tvalues <- newSignatureMarker\n+\t\t\t\tlastWasValue = false\n+\t\t\tcase strings.HasPrefix(line, \"#\"):\n+\t\t\t\tcontinue\n+\t\t\tdefault:\n+\t\t\t\tpartialValue += line\n+\t\t\t}\n+\t\t}\n+\t\tif err := scanner.Err(); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}()\n+\n+\tvar key *PublicKey\n+\tvar hashed []byte\n+\thash := crypto.SHA1\n+\th := hash.New()\n+\topts := &PSSOptions{\n+\t\tSaltLength: PSSSaltLengthEqualsHash,\n+\t}\n+\n+\tfor marker := range values {\n+\t\tswitch marker {\n+\t\tcase newKeyMarker:\n+\t\t\tkey = new(PublicKey)\n+\t\t\tnHex, ok := <-values\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tkey.N = bigFromHex(nHex)\n+\t\t\tkey.E = intFromHex(<-values)\n+\t\t\t// We don't care for d, p, q, dP, dQ or qInv.\n+\t\t\tfor i := 0; i < 6; i++ {\n+\t\t\t\t<-values\n+\t\t\t}\n+\t\tcase newSignatureMarker:\n+\t\t\tmsg := fromHex(<-values)\n+\t\t\t<-values // skip salt\n+\t\t\tsig := fromHex(<-values)\n+\n+\t\t\th.Reset()\n+\t\t\th.Write(msg)\n+\t\t\thashed = h.Sum(hashed[:0])\n+\n+\t\t\tif err := VerifyPSS(key, hash, hashed, sig, opts); err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tt.Fatalf(\"unknown marker: \" + marker)\n+\t\t}\n+\t}\n+}\n+\n+// TestPSSOpenSSL ensures that we can verify a PSS signature from OpenSSL with\n+// the default options. OpenSSL sets the salt length to be maximal.\n+func TestPSSOpenSSL(t *testing.T) {\n+\thash := crypto.SHA256\n+\th := hash.New()\n+\th.Write([]byte(\"testing\"))\n+\thashed := h.Sum(nil)\n+\n+\t// Generated with `echo -n testing | openssl dgst -sign key.pem -sigopt rsa_padding_mode:pss -sha256 > sig`\n+\tsig := []byte{\n+\t\t0x95, 0x59, 0x6f, 0xd3, 0x10, 0xa2, 0xe7, 0xa2, 0x92, 0x9d,\n+\t\t0x4a, 0x07, 0x2e, 0x2b, 0x27, 0xcc, 0x06, 0xc2, 0x87, 0x2c,\n+\t\t0x52, 0xf0, 0x4a, 0xcc, 0x05, 0x94, 0xf2, 0xc3, 0x2e, 0x20,\n+\t\t0xd7, 0x3e, 0x66, 0x62, 0xb5, 0x95, 0x2b, 0xa3, 0x93, 0x9a,\n+\t\t0x66, 0x64, 0x25, 0xe0, 0x74, 0x66, 0x8c, 0x3e, 0x92, 0xeb,\n+\t\t0xc6, 0xe6, 0xc0, 0x44, 0xf3, 0xb4, 0xb4, 0x2e, 0x8c, 0x66,\n+\t\t0x0a, 0x37, 0x9c, 0x69,\n+\t}\n+\n+\tif err := VerifyPSS(&rsaPrivateKey.PublicKey, hash, hashed, sig, nil); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestPSSSigning(t *testing.T) {\n+\tvar saltLengthCombinations = []struct {\n+\t\tsignSaltLength, verifySaltLength int\n+\t\tgood                             bool\n+\t}{\n+\t\t{PSSSaltLengthAuto, PSSSaltLengthAuto, true},\n+\t\t{PSSSaltLengthEqualsHash, PSSSaltLengthAuto, true},\n+\t\t{PSSSaltLengthEqualsHash, PSSSaltLengthEqualsHash, true},\n+\t\t{PSSSaltLengthEqualsHash, 8, false},\n+\t\t{PSSSaltLengthAuto, PSSSaltLengthEqualsHash, false},\n+\t\t{8, 8, true},\n+\t}\n+\n+\thash := crypto.MD5\n+\th := hash.New()\n+\th.Write([]byte(\"testing\"))\n+\thashed := h.Sum(nil)\n+\tvar opts PSSOptions\n+\n+\tfor i, test := range saltLengthCombinations {\n+\t\topts.SaltLength = test.signSaltLength\n+\t\tsig, err := SignPSS(rand.Reader, rsaPrivateKey, hash, hashed, &opts)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: error while signing: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\topts.SaltLength = test.verifySaltLength\n+\t\terr = VerifyPSS(&rsaPrivateKey.PublicKey, hash, hashed, sig, &opts)\n+\t\tif (err == nil) != test.good {\n+\t\t\tt.Errorf(\"#%d: bad result, wanted: %t, got: %s\", i, test.good, err)\n+\t\t}\n+\t}\n+}\n+\n+func bigFromHex(hex string) *big.Int {\n+\tn, ok := new(big.Int).SetString(hex, 16)\n+\tif !ok {\n+\t\tpanic(\"bad hex: \" + hex)\n+\t}\n+\treturn n\n+}\n+\n+func intFromHex(hex string) int {\n+\ti, err := strconv.ParseInt(hex, 16, 32)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn int(i)\n+}\n+\n+func fromHex(hexStr string) []byte {\n+\ts, err := hex.DecodeString(hexStr)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn s\n+}"}, {"sha": "c7353ea311aadc87c15c756b86073187a507e458", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -5,8 +5,6 @@\n // Package rsa implements RSA encryption as specified in PKCS#1.\n package rsa\n \n-// TODO(agl): Add support for PSS padding.\n-\n import (\n \t\"crypto/rand\"\n \t\"crypto/subtle\""}, {"sha": "cf193c669f3d7e452cbc525226af28a230d5e46a", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -120,8 +120,10 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {\n }\n \n func fromBase10(base10 string) *big.Int {\n-\ti := new(big.Int)\n-\ti.SetString(base10, 10)\n+\ti, ok := new(big.Int).SetString(base10, 10)\n+\tif !ok {\n+\t\tpanic(\"bad number: \" + base10)\n+\t}\n \treturn i\n }\n "}, {"sha": "ad3da1ac4ee62b68c166ea4e1fc1c540030e7e54", "filename": "libgo/go/crypto/rsa/testdata/pss-vect.txt.bz2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Ftestdata%2Fpss-vect.txt.bz2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Frsa%2Ftestdata%2Fpss-vect.txt.bz2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Ftestdata%2Fpss-vect.txt.bz2?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8eb3f7a798888d288e4fd8bd3ee086375c342261", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -90,9 +90,13 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := *d0\n+\thash := d.checkSum()\n+\treturn append(in, hash[:]...)\n+}\n \n-\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n+func (d *digest) checkSum() [Size]byte {\n \tlen := d.len\n+\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tvar tmp [64]byte\n \ttmp[0] = 0x80\n \tif len%64 < 56 {\n@@ -120,5 +124,13 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t\tdigest[i*4+3] = byte(s)\n \t}\n \n-\treturn append(in, digest[:]...)\n+\treturn digest\n+}\n+\n+// Sum returns the SHA1 checksum of the data.\n+func Sum(data []byte) [Size]byte {\n+\tvar d digest\n+\td.Reset()\n+\td.Write(data)\n+\treturn d.checkSum()\n }"}, {"sha": "c3868d702accc61b5f2f633be8d1a7ddeb80d7c5", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -54,6 +54,10 @@ var golden = []sha1Test{\n func TestGolden(t *testing.T) {\n \tfor i := 0; i < len(golden); i++ {\n \t\tg := golden[i]\n+\t\ts := fmt.Sprintf(\"%x\", Sum([]byte(g.in)))\n+\t\tif s != g.out {\n+\t\t\tt.Fatalf(\"Sum function: sha1(%s) = %s want %s\", g.in, s, g.out)\n+\t\t}\n \t\tc := New()\n \t\tfor j := 0; j < 3; j++ {\n \t\t\tif j < 2 {\n@@ -72,13 +76,6 @@ func TestGolden(t *testing.T) {\n \t}\n }\n \n-func ExampleNew() {\n-\th := New()\n-\tio.WriteString(h, \"His money is twice tainted: 'taint yours and 'taint mine.\")\n-\tfmt.Printf(\"% x\", h.Sum(nil))\n-\t// Output: 59 7f 6a 54 00 10 f9 4c 15 d7 18 06 a9 9a 2c 87 10 e7 47 bd\n-}\n-\n var bench = New()\n var buf = make([]byte, 8192)\n "}, {"sha": "4cb157fff6d608809f8c63f5f7e28090df406065", "filename": "libgo/go/crypto/sha1/sha1block_decl.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,4 +6,6 @@\n \n package sha1\n \n+//go:noescape\n+\n func block(dig *digest, p []byte)"}, {"sha": "d69ed24a3b425a0b489497bda448c8b48059fd92", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -134,9 +134,16 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := *d0\n+\thash := d.checkSum()\n+\tif d.is224 {\n+\t\treturn append(in, hash[:Size224]...)\n+\t}\n+\treturn append(in, hash[:]...)\n+}\n \n-\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n+func (d *digest) checkSum() [Size]byte {\n \tlen := d.len\n+\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tvar tmp [64]byte\n \ttmp[0] = 0x80\n \tif len%64 < 56 {\n@@ -157,10 +164,8 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t}\n \n \th := d.h[:]\n-\tsize := Size\n \tif d.is224 {\n \t\th = d.h[:7]\n-\t\tsize = Size224\n \t}\n \n \tvar digest [Size]byte\n@@ -171,5 +176,24 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t\tdigest[i*4+3] = byte(s)\n \t}\n \n-\treturn append(in, digest[:size]...)\n+\treturn digest\n+}\n+\n+// Sum256 returns the SHA256 checksum of the data.\n+func Sum256(data []byte) [Size]byte {\n+\tvar d digest\n+\td.Reset()\n+\td.Write(data)\n+\treturn d.checkSum()\n+}\n+\n+// Sum224 returns the SHA224 checksum of the data.\n+func Sum224(data []byte) (sum224 [Size224]byte) {\n+\tvar d digest\n+\td.is224 = true\n+\td.Reset()\n+\td.Write(data)\n+\tsum := d.checkSum()\n+\tcopy(sum224[:], sum[:Size224])\n+\treturn\n }"}, {"sha": "bb1ec3b162675d3d32edc9506e6063e42ba3bc23", "filename": "libgo/go/crypto/sha256/sha256_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -88,6 +88,10 @@ var golden224 = []sha256Test{\n func TestGolden(t *testing.T) {\n \tfor i := 0; i < len(golden); i++ {\n \t\tg := golden[i]\n+\t\ts := fmt.Sprintf(\"%x\", Sum256([]byte(g.in)))\n+\t\tif s != g.out {\n+\t\t\tt.Fatalf(\"Sum256 function: sha256(%s) = %s want %s\", g.in, s, g.out)\n+\t\t}\n \t\tc := New()\n \t\tfor j := 0; j < 3; j++ {\n \t\t\tif j < 2 {\n@@ -106,6 +110,10 @@ func TestGolden(t *testing.T) {\n \t}\n \tfor i := 0; i < len(golden224); i++ {\n \t\tg := golden224[i]\n+\t\ts := fmt.Sprintf(\"%x\", Sum224([]byte(g.in)))\n+\t\tif s != g.out {\n+\t\t\tt.Fatalf(\"Sum224 function: sha224(%s) = %s want %s\", g.in, s, g.out)\n+\t\t}\n \t\tc := New224()\n \t\tfor j := 0; j < 3; j++ {\n \t\t\tif j < 2 {"}, {"sha": "d2ada51373cb501a4cad34ffc56c2fa1a012460e", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -135,7 +135,14 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := new(digest)\n \t*d = *d0\n+\thash := d.checkSum()\n+\tif d.is384 {\n+\t\treturn append(in, hash[:Size384]...)\n+\t}\n+\treturn append(in, hash[:]...)\n+}\n \n+func (d *digest) checkSum() [Size]byte {\n \t// Padding.  Add a 1 bit and 0 bits until 112 bytes mod 128.\n \tlen := d.len\n \tvar tmp [128]byte\n@@ -158,10 +165,8 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t}\n \n \th := d.h[:]\n-\tsize := Size\n \tif d.is384 {\n \t\th = d.h[:6]\n-\t\tsize = Size384\n \t}\n \n \tvar digest [Size]byte\n@@ -176,5 +181,24 @@ func (d0 *digest) Sum(in []byte) []byte {\n \t\tdigest[i*8+7] = byte(s)\n \t}\n \n-\treturn append(in, digest[:size]...)\n+\treturn digest\n+}\n+\n+// Sum512 returns the SHA512 checksum of the data.\n+func Sum512(data []byte) [Size]byte {\n+\tvar d digest\n+\td.Reset()\n+\td.Write(data)\n+\treturn d.checkSum()\n+}\n+\n+// Sum384 returns the SHA384 checksum of the data.\n+func Sum384(data []byte) (sum384 [Size384]byte) {\n+\tvar d digest\n+\td.is384 = true\n+\td.Reset()\n+\td.Write(data)\n+\tsum := d.checkSum()\n+\tcopy(sum384[:], sum[:Size384])\n+\treturn\n }"}, {"sha": "167c20ad0754514a0977c5f44208127ce3951b8e", "filename": "libgo/go/crypto/sha512/sha512_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -88,6 +88,10 @@ var golden384 = []sha512Test{\n func TestGolden(t *testing.T) {\n \tfor i := 0; i < len(golden); i++ {\n \t\tg := golden[i]\n+\t\ts := fmt.Sprintf(\"%x\", Sum512([]byte(g.in)))\n+\t\tif s != g.out {\n+\t\t\tt.Fatalf(\"Sum512 function: sha512(%s) = %s want %s\", g.in, s, g.out)\n+\t\t}\n \t\tc := New()\n \t\tfor j := 0; j < 3; j++ {\n \t\t\tif j < 2 {\n@@ -106,6 +110,10 @@ func TestGolden(t *testing.T) {\n \t}\n \tfor i := 0; i < len(golden384); i++ {\n \t\tg := golden384[i]\n+\t\ts := fmt.Sprintf(\"%x\", Sum384([]byte(g.in)))\n+\t\tif s != g.out {\n+\t\t\tt.Fatalf(\"Sum384 function: sha384(%s) = %s want %s\", g.in, s, g.out)\n+\t\t}\n \t\tc := New384()\n \t\tfor j := 0; j < 3; j++ {\n \t\t\tif j < 2 {"}, {"sha": "dfb658465e9bdffaec2e5f7f0b1165c8ee6b8661", "filename": "libgo/go/crypto/subtle/constant_time.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -55,3 +55,11 @@ func ConstantTimeCopy(v int, x, y []byte) {\n \t}\n \treturn\n }\n+\n+// ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\n+// Its behavior is undefined if x or y are negative or > 2**31 - 1.\n+func ConstantTimeLessOrEq(x, y int) int {\n+\tx32 := int32(x)\n+\ty32 := int32(y)\n+\treturn int(((x32 - y32 - 1) >> 31) & 1)\n+}"}, {"sha": "d8e321ec04a7f8294efd62fb26086424b66814cd", "filename": "libgo/go/crypto/subtle/constant_time_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -103,3 +103,23 @@ func TestConstantTimeCopy(t *testing.T) {\n \t\tt.Error(err)\n \t}\n }\n+\n+var lessOrEqTests = []struct {\n+\tx, y, result int\n+}{\n+\t{0, 0, 1},\n+\t{1, 0, 0},\n+\t{0, 1, 1},\n+\t{10, 20, 1},\n+\t{20, 10, 0},\n+\t{10, 10, 1},\n+}\n+\n+func TestConstantTimeLessOrEq(t *testing.T) {\n+\tfor i, test := range lessOrEqTests {\n+\t\tresult := ConstantTimeLessOrEq(test.x, test.y)\n+\t\tif result != test.result {\n+\t\t\tt.Errorf(\"#%d: %d <= %d gave %d, expected %d\", i, test.x, test.y, result, test.result)\n+\t\t}\n+\t}\n+}"}, {"sha": "39a51459d288fc516248af612c6fabb0a8989258", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 112, "deletions": 34, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -34,6 +34,22 @@ type keyAgreement interface {\n \tgenerateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)\n }\n \n+const (\n+\t// suiteECDH indicates that the cipher suite involves elliptic curve\n+\t// Diffie-Hellman. This means that it should only be selected when the\n+\t// client indicates that it supports ECC with a curve and point format\n+\t// that we're happy with.\n+\tsuiteECDHE = 1 << iota\n+\t// suiteECDSA indicates that the cipher suite involves an ECDSA\n+\t// signature and therefore may only be selected when the server's\n+\t// certificate is ECDSA. If this is not set then the cipher suite is\n+\t// RSA based.\n+\tsuiteECDSA\n+\t// suiteTLS12 indicates that the cipher suite should only be advertised\n+\t// and accepted when using TLS 1.2.\n+\tsuiteTLS12\n+)\n+\n // A cipherSuite is a specific combination of key agreement, cipher and MAC\n // function. All cipher suites currently assume RSA key agreement.\n type cipherSuite struct {\n@@ -42,24 +58,30 @@ type cipherSuite struct {\n \tkeyLen int\n \tmacLen int\n \tivLen  int\n-\tka     func() keyAgreement\n-\t// If elliptic is set, a server will only consider this ciphersuite if\n-\t// the ClientHello indicated that the client supports an elliptic curve\n-\t// and point format that we can handle.\n-\telliptic bool\n-\tcipher   func(key, iv []byte, isRead bool) interface{}\n-\tmac      func(version uint16, macKey []byte) macFunction\n+\tka     func(version uint16) keyAgreement\n+\t// flags is a bitmask of the suite* values, above.\n+\tflags  int\n+\tcipher func(key, iv []byte, isRead bool) interface{}\n+\tmac    func(version uint16, macKey []byte) macFunction\n+\taead   func(key, fixedNonce []byte) cipher.AEAD\n }\n \n var cipherSuites = []*cipherSuite{\n-\t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, false, cipherRC4, macSHA1},\n-\t{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, false, cipher3DES, macSHA1},\n-\t{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, false, cipherAES, macSHA1},\n-\t{TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, false, cipherAES, macSHA1},\n-\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, true, cipherRC4, macSHA1},\n-\t{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, true, cipher3DES, macSHA1},\n-\t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n-\t{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n+\t// Ciphersuite order is chosen so that ECDHE comes before plain RSA\n+\t// and RC4 comes before AES (because of the Lucky13 attack).\n+\t{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadAESGCM},\n+\t{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12, nil, nil, aeadAESGCM},\n+\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE, cipherRC4, macSHA1, nil},\n+\t{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherRC4, macSHA1, nil},\n+\t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},\n+\t{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},\n+\t{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},\n+\t{TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},\n+\t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, 0, cipherRC4, macSHA1, nil},\n+\t{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},\n+\t{TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},\n+\t{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, suiteECDHE, cipher3DES, macSHA1, nil},\n+\t{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, 0, cipher3DES, macSHA1, nil},\n }\n \n func cipherRC4(key, iv []byte, isRead bool) interface{} {\n@@ -85,7 +107,7 @@ func cipherAES(key, iv []byte, isRead bool) interface{} {\n \n // macSHA1 returns a macFunction for the given protocol version.\n func macSHA1(version uint16, key []byte) macFunction {\n-\tif version == versionSSL30 {\n+\tif version == VersionSSL30 {\n \t\tmac := ssl30MAC{\n \t\t\th:   sha1.New(),\n \t\t\tkey: make([]byte, len(key)),\n@@ -98,7 +120,47 @@ func macSHA1(version uint16, key []byte) macFunction {\n \n type macFunction interface {\n \tSize() int\n-\tMAC(digestBuf, seq, data []byte) []byte\n+\tMAC(digestBuf, seq, header, data []byte) []byte\n+}\n+\n+// fixedNonceAEAD wraps an AEAD and prefixes a fixed portion of the nonce to\n+// each call.\n+type fixedNonceAEAD struct {\n+\t// sealNonce and openNonce are buffers where the larger nonce will be\n+\t// constructed. Since a seal and open operation may be running\n+\t// concurrently, there is a separate buffer for each.\n+\tsealNonce, openNonce []byte\n+\taead                 cipher.AEAD\n+}\n+\n+func (f *fixedNonceAEAD) NonceSize() int { return 8 }\n+func (f *fixedNonceAEAD) Overhead() int  { return f.aead.Overhead() }\n+\n+func (f *fixedNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte {\n+\tcopy(f.sealNonce[len(f.sealNonce)-8:], nonce)\n+\treturn f.aead.Seal(out, f.sealNonce, plaintext, additionalData)\n+}\n+\n+func (f *fixedNonceAEAD) Open(out, nonce, plaintext, additionalData []byte) ([]byte, error) {\n+\tcopy(f.openNonce[len(f.openNonce)-8:], nonce)\n+\treturn f.aead.Open(out, f.openNonce, plaintext, additionalData)\n+}\n+\n+func aeadAESGCM(key, fixedNonce []byte) cipher.AEAD {\n+\taes, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\taead, err := cipher.NewGCM(aes)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tnonce1, nonce2 := make([]byte, 12), make([]byte, 12)\n+\tcopy(nonce1, fixedNonce)\n+\tcopy(nonce2, fixedNonce)\n+\n+\treturn &fixedNonceAEAD{nonce1, nonce2, aead}\n }\n \n // ssl30MAC implements the SSLv3 MAC function, as defined in\n@@ -116,7 +178,7 @@ var ssl30Pad1 = [48]byte{0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0\n \n var ssl30Pad2 = [48]byte{0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c}\n \n-func (s ssl30MAC) MAC(digestBuf, seq, record []byte) []byte {\n+func (s ssl30MAC) MAC(digestBuf, seq, header, data []byte) []byte {\n \tpadLength := 48\n \tif s.h.Size() == 20 {\n \t\tpadLength = 40\n@@ -126,9 +188,9 @@ func (s ssl30MAC) MAC(digestBuf, seq, record []byte) []byte {\n \ts.h.Write(s.key)\n \ts.h.Write(ssl30Pad1[:padLength])\n \ts.h.Write(seq)\n-\ts.h.Write(record[:1])\n-\ts.h.Write(record[3:5])\n-\ts.h.Write(record[recordHeaderLen:])\n+\ts.h.Write(header[:1])\n+\ts.h.Write(header[3:5])\n+\ts.h.Write(data)\n \tdigestBuf = s.h.Sum(digestBuf[:0])\n \n \ts.h.Reset()\n@@ -147,19 +209,30 @@ func (s tls10MAC) Size() int {\n \treturn s.h.Size()\n }\n \n-func (s tls10MAC) MAC(digestBuf, seq, record []byte) []byte {\n+func (s tls10MAC) MAC(digestBuf, seq, header, data []byte) []byte {\n \ts.h.Reset()\n \ts.h.Write(seq)\n-\ts.h.Write(record)\n+\ts.h.Write(header)\n+\ts.h.Write(data)\n \treturn s.h.Sum(digestBuf[:0])\n }\n \n-func rsaKA() keyAgreement {\n+func rsaKA(version uint16) keyAgreement {\n \treturn rsaKeyAgreement{}\n }\n \n-func ecdheRSAKA() keyAgreement {\n-\treturn new(ecdheRSAKeyAgreement)\n+func ecdheECDSAKA(version uint16) keyAgreement {\n+\treturn &ecdheKeyAgreement{\n+\t\tsigType: signatureECDSA,\n+\t\tversion: version,\n+\t}\n+}\n+\n+func ecdheRSAKA(version uint16) keyAgreement {\n+\treturn &ecdheKeyAgreement{\n+\t\tsigType: signatureRSA,\n+\t\tversion: version,\n+\t}\n }\n \n // mutualCipherSuite returns a cipherSuite given a list of supported\n@@ -181,12 +254,17 @@ func mutualCipherSuite(have []uint16, want uint16) *cipherSuite {\n // A list of the possible cipher suite ids. Taken from\n // http://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n const (\n-\tTLS_RSA_WITH_RC4_128_SHA            uint16 = 0x0005\n-\tTLS_RSA_WITH_3DES_EDE_CBC_SHA       uint16 = 0x000a\n-\tTLS_RSA_WITH_AES_128_CBC_SHA        uint16 = 0x002f\n-\tTLS_RSA_WITH_AES_256_CBC_SHA        uint16 = 0x0035\n-\tTLS_ECDHE_RSA_WITH_RC4_128_SHA      uint16 = 0xc011\n-\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xc012\n-\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA  uint16 = 0xc013\n-\tTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA  uint16 = 0xc014\n+\tTLS_RSA_WITH_RC4_128_SHA                uint16 = 0x0005\n+\tTLS_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0x000a\n+\tTLS_RSA_WITH_AES_128_CBC_SHA            uint16 = 0x002f\n+\tTLS_RSA_WITH_AES_256_CBC_SHA            uint16 = 0x0035\n+\tTLS_ECDHE_ECDSA_WITH_RC4_128_SHA        uint16 = 0xc007\n+\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    uint16 = 0xc009\n+\tTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    uint16 = 0xc00a\n+\tTLS_ECDHE_RSA_WITH_RC4_128_SHA          uint16 = 0xc011\n+\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     uint16 = 0xc012\n+\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      uint16 = 0xc013\n+\tTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0xc014\n+\tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   uint16 = 0xc02f\n+\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b\n )"}, {"sha": "b7229d29f8b73499770b5039f65c6e398ac1ed84", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 110, "deletions": 36, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -9,22 +9,27 @@ import (\n \t\"crypto/rand\"\n \t\"crypto/x509\"\n \t\"io\"\n+\t\"math/big\"\n \t\"strings\"\n \t\"sync\"\n \t\"time\"\n )\n \n+const (\n+\tVersionSSL30 = 0x0300\n+\tVersionTLS10 = 0x0301\n+\tVersionTLS11 = 0x0302\n+\tVersionTLS12 = 0x0303\n+)\n+\n const (\n \tmaxPlaintext    = 16384        // maximum plaintext payload length\n \tmaxCiphertext   = 16384 + 2048 // maximum ciphertext payload length\n \trecordHeaderLen = 5            // record header length\n \tmaxHandshake    = 65536        // maximum handshake we support (protocol max is 16 MB)\n \n-\tversionSSL30 = 0x0300\n-\tversionTLS10 = 0x0301\n-\n-\tminVersion = versionSSL30\n-\tmaxVersion = versionTLS10\n+\tminVersion = VersionSSL30\n+\tmaxVersion = VersionTLS12\n )\n \n // TLS record types.\n@@ -60,12 +65,13 @@ const (\n \n // TLS extension numbers\n var (\n-\textensionServerName      uint16 = 0\n-\textensionStatusRequest   uint16 = 5\n-\textensionSupportedCurves uint16 = 10\n-\textensionSupportedPoints uint16 = 11\n-\textensionSessionTicket   uint16 = 35\n-\textensionNextProtoNeg    uint16 = 13172 // not IANA assigned\n+\textensionServerName          uint16 = 0\n+\textensionStatusRequest       uint16 = 5\n+\textensionSupportedCurves     uint16 = 10\n+\textensionSupportedPoints     uint16 = 11\n+\textensionSignatureAlgorithms uint16 = 13\n+\textensionSessionTicket       uint16 = 35\n+\textensionNextProtoNeg        uint16 = 13172 // not IANA assigned\n )\n \n // TLS Elliptic Curves\n@@ -93,25 +99,60 @@ const (\n \tcertTypeDSSSign    = 2 // A certificate containing a DSA key\n \tcertTypeRSAFixedDH = 3 // A certificate containing a static DH key\n \tcertTypeDSSFixedDH = 4 // A certificate containing a static DH key\n+\n+\t// See RFC4492 sections 3 and 5.5.\n+\tcertTypeECDSASign      = 64 // A certificate containing an ECDSA-capable public key, signed with ECDSA.\n+\tcertTypeRSAFixedECDH   = 65 // A certificate containing an ECDH-capable public key, signed with RSA.\n+\tcertTypeECDSAFixedECDH = 66 // A certificate containing an ECDH-capable public key, signed with ECDSA.\n+\n \t// Rest of these are reserved by the TLS spec\n )\n \n+// Hash functions for TLS 1.2 (See RFC 5246, section A.4.1)\n+const (\n+\thashSHA1   uint8 = 2\n+\thashSHA256 uint8 = 4\n+)\n+\n+// Signature algorithms for TLS 1.2 (See RFC 5246, section A.4.1)\n+const (\n+\tsignatureRSA   uint8 = 1\n+\tsignatureECDSA uint8 = 3\n+)\n+\n+// signatureAndHash mirrors the TLS 1.2, SignatureAndHashAlgorithm struct. See\n+// RFC 5246, section A.4.1.\n+type signatureAndHash struct {\n+\thash, signature uint8\n+}\n+\n+// supportedSKXSignatureAlgorithms contains the signature and hash algorithms\n+// that the code advertises as supported in a TLS 1.2 ClientHello.\n+var supportedSKXSignatureAlgorithms = []signatureAndHash{\n+\t{hashSHA256, signatureRSA},\n+\t{hashSHA256, signatureECDSA},\n+\t{hashSHA1, signatureRSA},\n+\t{hashSHA1, signatureECDSA},\n+}\n+\n+// supportedClientCertSignatureAlgorithms contains the signature and hash\n+// algorithms that the code advertises as supported in a TLS 1.2\n+// CertificateRequest.\n+var supportedClientCertSignatureAlgorithms = []signatureAndHash{\n+\t{hashSHA256, signatureRSA},\n+\t{hashSHA256, signatureECDSA},\n+}\n+\n // ConnectionState records basic TLS details about the connection.\n type ConnectionState struct {\n-\tHandshakeComplete          bool\n-\tDidResume                  bool\n-\tCipherSuite                uint16\n-\tNegotiatedProtocol         string\n-\tNegotiatedProtocolIsMutual bool\n-\n-\t// ServerName contains the server name indicated by the client, if any.\n-\t// (Only valid for server connections.)\n-\tServerName string\n-\n-\t// the certificate chain that was presented by the other side\n-\tPeerCertificates []*x509.Certificate\n-\t// the verified certificate chains built from PeerCertificates.\n-\tVerifiedChains [][]*x509.Certificate\n+\tHandshakeComplete          bool                  // TLS handshake is complete\n+\tDidResume                  bool                  // connection resumes a previous TLS connection\n+\tCipherSuite                uint16                // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)\n+\tNegotiatedProtocol         string                // negotiated next protocol (from Config.NextProtos)\n+\tNegotiatedProtocolIsMutual bool                  // negotiated protocol was advertised by server\n+\tServerName                 string                // server name requested by client, if any (server side only)\n+\tPeerCertificates           []*x509.Certificate   // certificate chain presented by remote peer\n+\tVerifiedChains             [][]*x509.Certificate // verified chains built from PeerCertificates\n }\n \n // ClientAuthType declares the policy the server will follow for\n@@ -204,6 +245,15 @@ type Config struct {\n \t// connections using that key are compromised.\n \tSessionTicketKey [32]byte\n \n+\t// MinVersion contains the minimum SSL/TLS version that is acceptable.\n+\t// If zero, then SSLv3 is taken as the minimum.\n+\tMinVersion uint16\n+\n+\t// MaxVersion contains the maximum SSL/TLS version that is acceptable.\n+\t// If zero, then the maximum version supported by this package is used,\n+\t// which is currently TLS 1.2.\n+\tMaxVersion uint16\n+\n \tserverInitOnce sync.Once // guards calling (*Config).serverInit\n }\n \n@@ -248,6 +298,35 @@ func (c *Config) cipherSuites() []uint16 {\n \treturn s\n }\n \n+func (c *Config) minVersion() uint16 {\n+\tif c == nil || c.MinVersion == 0 {\n+\t\treturn minVersion\n+\t}\n+\treturn c.MinVersion\n+}\n+\n+func (c *Config) maxVersion() uint16 {\n+\tif c == nil || c.MaxVersion == 0 {\n+\t\treturn maxVersion\n+\t}\n+\treturn c.MaxVersion\n+}\n+\n+// mutualVersion returns the protocol version to use given the advertised\n+// version of the peer.\n+func (c *Config) mutualVersion(vers uint16) (uint16, bool) {\n+\tminVersion := c.minVersion()\n+\tmaxVersion := c.maxVersion()\n+\n+\tif vers < minVersion {\n+\t\treturn 0, false\n+\t}\n+\tif vers > maxVersion {\n+\t\tvers = maxVersion\n+\t}\n+\treturn vers, true\n+}\n+\n // getCertificateForName returns the best certificate for the given name,\n // defaulting to the first element of c.Certificates if there are no good\n // options.\n@@ -304,7 +383,7 @@ func (c *Config) BuildNameToCertificate() {\n // A Certificate is a chain of one or more certificates, leaf first.\n type Certificate struct {\n \tCertificate [][]byte\n-\tPrivateKey  crypto.PrivateKey // supported types: *rsa.PrivateKey\n+\tPrivateKey  crypto.PrivateKey // supported types: *rsa.PrivateKey, *ecdsa.PrivateKey\n \t// OCSPStaple contains an optional OCSP response which will be served\n \t// to clients that request it.\n \tOCSPStaple []byte\n@@ -327,18 +406,13 @@ type handshakeMessage interface {\n \tunmarshal([]byte) bool\n }\n \n-// mutualVersion returns the protocol version to use given the advertised\n-// version of the peer.\n-func mutualVersion(vers uint16) (uint16, bool) {\n-\tif vers < minVersion {\n-\t\treturn 0, false\n-\t}\n-\tif vers > maxVersion {\n-\t\tvers = maxVersion\n-\t}\n-\treturn vers, true\n+// TODO(jsing): Make these available to both crypto/x509 and crypto/tls.\n+type dsaSignature struct {\n+\tR, S *big.Int\n }\n \n+type ecdsaSignature dsaSignature\n+\n var emptyConfig Config\n \n func defaultConfig() *Config {"}, {"sha": "2e64b88a68971f35340b1db04facb63abf041674", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 150, "deletions": 42, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -146,6 +146,9 @@ func (hc *halfConn) changeCipherSpec() error {\n \thc.mac = hc.nextMac\n \thc.nextCipher = nil\n \thc.nextMac = nil\n+\tfor i := range hc.seq {\n+\t\thc.seq[i] = 0\n+\t}\n \treturn nil\n }\n \n@@ -229,8 +232,16 @@ func roundUp(a, b int) int {\n \treturn a + (b-a%b)%b\n }\n \n-// decrypt checks and strips the mac and decrypts the data in b.\n-func (hc *halfConn) decrypt(b *block) (bool, alert) {\n+// cbcMode is an interface for block ciphers using cipher block chaining.\n+type cbcMode interface {\n+\tcipher.BlockMode\n+\tSetIV([]byte)\n+}\n+\n+// decrypt checks and strips the mac and decrypts the data in b. Returns a\n+// success boolean, the number of bytes to skip from the start of the record in\n+// order to get the application payload, and an optional alert value.\n+func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert) {\n \t// pull out payload\n \tpayload := b.data[recordHeaderLen:]\n \n@@ -240,26 +251,54 @@ func (hc *halfConn) decrypt(b *block) (bool, alert) {\n \t}\n \n \tpaddingGood := byte(255)\n+\texplicitIVLen := 0\n \n \t// decrypt\n \tif hc.cipher != nil {\n \t\tswitch c := hc.cipher.(type) {\n \t\tcase cipher.Stream:\n \t\t\tc.XORKeyStream(payload, payload)\n-\t\tcase cipher.BlockMode:\n+\t\tcase cipher.AEAD:\n+\t\t\texplicitIVLen = 8\n+\t\t\tif len(payload) < explicitIVLen {\n+\t\t\t\treturn false, 0, alertBadRecordMAC\n+\t\t\t}\n+\t\t\tnonce := payload[:8]\n+\t\t\tpayload = payload[8:]\n+\n+\t\t\tvar additionalData [13]byte\n+\t\t\tcopy(additionalData[:], hc.seq[:])\n+\t\t\tcopy(additionalData[8:], b.data[:3])\n+\t\t\tn := len(payload) - c.Overhead()\n+\t\t\tadditionalData[11] = byte(n >> 8)\n+\t\t\tadditionalData[12] = byte(n)\n+\t\t\tvar err error\n+\t\t\tpayload, err = c.Open(payload[:0], nonce, payload, additionalData[:])\n+\t\t\tif err != nil {\n+\t\t\t\treturn false, 0, alertBadRecordMAC\n+\t\t\t}\n+\t\t\tb.resize(recordHeaderLen + explicitIVLen + len(payload))\n+\t\tcase cbcMode:\n \t\t\tblockSize := c.BlockSize()\n+\t\t\tif hc.version >= VersionTLS11 {\n+\t\t\t\texplicitIVLen = blockSize\n+\t\t\t}\n \n-\t\t\tif len(payload)%blockSize != 0 || len(payload) < roundUp(macSize+1, blockSize) {\n-\t\t\t\treturn false, alertBadRecordMAC\n+\t\t\tif len(payload)%blockSize != 0 || len(payload) < roundUp(explicitIVLen+macSize+1, blockSize) {\n+\t\t\t\treturn false, 0, alertBadRecordMAC\n \t\t\t}\n \n+\t\t\tif explicitIVLen > 0 {\n+\t\t\t\tc.SetIV(payload[:explicitIVLen])\n+\t\t\t\tpayload = payload[explicitIVLen:]\n+\t\t\t}\n \t\t\tc.CryptBlocks(payload, payload)\n-\t\t\tif hc.version == versionSSL30 {\n+\t\t\tif hc.version == VersionSSL30 {\n \t\t\t\tpayload, paddingGood = removePaddingSSL30(payload)\n \t\t\t} else {\n \t\t\t\tpayload, paddingGood = removePadding(payload)\n \t\t\t}\n-\t\t\tb.resize(recordHeaderLen + len(payload))\n+\t\t\tb.resize(recordHeaderLen + explicitIVLen + len(payload))\n \n \t\t\t// note that we still have a timing side-channel in the\n \t\t\t// MAC check, below. An attacker can align the record\n@@ -279,25 +318,25 @@ func (hc *halfConn) decrypt(b *block) (bool, alert) {\n \t// check, strip mac\n \tif hc.mac != nil {\n \t\tif len(payload) < macSize {\n-\t\t\treturn false, alertBadRecordMAC\n+\t\t\treturn false, 0, alertBadRecordMAC\n \t\t}\n \n \t\t// strip mac off payload, b.data\n \t\tn := len(payload) - macSize\n \t\tb.data[3] = byte(n >> 8)\n \t\tb.data[4] = byte(n)\n-\t\tb.resize(recordHeaderLen + n)\n+\t\tb.resize(recordHeaderLen + explicitIVLen + n)\n \t\tremoteMAC := payload[n:]\n-\t\tlocalMAC := hc.mac.MAC(hc.inDigestBuf, hc.seq[0:], b.data)\n-\t\thc.incSeq()\n+\t\tlocalMAC := hc.mac.MAC(hc.inDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], payload[:n])\n \n \t\tif subtle.ConstantTimeCompare(localMAC, remoteMAC) != 1 || paddingGood != 255 {\n-\t\t\treturn false, alertBadRecordMAC\n+\t\t\treturn false, 0, alertBadRecordMAC\n \t\t}\n \t\thc.inDigestBuf = localMAC\n \t}\n+\thc.incSeq()\n \n-\treturn true, 0\n+\treturn true, recordHeaderLen + explicitIVLen, 0\n }\n \n // padToBlockSize calculates the needed padding block, if any, for a payload.\n@@ -318,11 +357,10 @@ func padToBlockSize(payload []byte, blockSize int) (prefix, finalBlock []byte) {\n }\n \n // encrypt encrypts and macs the data in b.\n-func (hc *halfConn) encrypt(b *block) (bool, alert) {\n+func (hc *halfConn) encrypt(b *block, explicitIVLen int) (bool, alert) {\n \t// mac\n \tif hc.mac != nil {\n-\t\tmac := hc.mac.MAC(hc.outDigestBuf, hc.seq[0:], b.data)\n-\t\thc.incSeq()\n+\t\tmac := hc.mac.MAC(hc.outDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], b.data[recordHeaderLen+explicitIVLen:])\n \n \t\tn := len(b.data)\n \t\tb.resize(n + len(mac))\n@@ -337,11 +375,30 @@ func (hc *halfConn) encrypt(b *block) (bool, alert) {\n \t\tswitch c := hc.cipher.(type) {\n \t\tcase cipher.Stream:\n \t\t\tc.XORKeyStream(payload, payload)\n-\t\tcase cipher.BlockMode:\n-\t\t\tprefix, finalBlock := padToBlockSize(payload, c.BlockSize())\n-\t\t\tb.resize(recordHeaderLen + len(prefix) + len(finalBlock))\n-\t\t\tc.CryptBlocks(b.data[recordHeaderLen:], prefix)\n-\t\t\tc.CryptBlocks(b.data[recordHeaderLen+len(prefix):], finalBlock)\n+\t\tcase cipher.AEAD:\n+\t\t\tpayloadLen := len(b.data) - recordHeaderLen - explicitIVLen\n+\t\t\tb.resize(len(b.data) + c.Overhead())\n+\t\t\tnonce := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]\n+\t\t\tpayload := b.data[recordHeaderLen+explicitIVLen:]\n+\t\t\tpayload = payload[:payloadLen]\n+\n+\t\t\tvar additionalData [13]byte\n+\t\t\tcopy(additionalData[:], hc.seq[:])\n+\t\t\tcopy(additionalData[8:], b.data[:3])\n+\t\t\tadditionalData[11] = byte(payloadLen >> 8)\n+\t\t\tadditionalData[12] = byte(payloadLen)\n+\n+\t\t\tc.Seal(payload[:0], nonce, payload, additionalData[:])\n+\t\tcase cbcMode:\n+\t\t\tblockSize := c.BlockSize()\n+\t\t\tif explicitIVLen > 0 {\n+\t\t\t\tc.SetIV(payload[:explicitIVLen])\n+\t\t\t\tpayload = payload[explicitIVLen:]\n+\t\t\t}\n+\t\t\tprefix, finalBlock := padToBlockSize(payload, blockSize)\n+\t\t\tb.resize(recordHeaderLen + explicitIVLen + len(prefix) + len(finalBlock))\n+\t\t\tc.CryptBlocks(b.data[recordHeaderLen+explicitIVLen:], prefix)\n+\t\t\tc.CryptBlocks(b.data[recordHeaderLen+explicitIVLen+len(prefix):], finalBlock)\n \t\tdefault:\n \t\t\tpanic(\"unknown cipher type\")\n \t\t}\n@@ -351,6 +408,7 @@ func (hc *halfConn) encrypt(b *block) (bool, alert) {\n \tn := len(b.data) - recordHeaderLen\n \tb.data[3] = byte(n >> 8)\n \tb.data[4] = byte(n)\n+\thc.incSeq()\n \n \treturn true, 0\n }\n@@ -534,10 +592,11 @@ Again:\n \n \t// Process message.\n \tb, c.rawInput = c.in.splitBlock(b, recordHeaderLen+n)\n-\tb.off = recordHeaderLen\n-\tif ok, err := c.in.decrypt(b); !ok {\n+\tok, off, err := c.in.decrypt(b)\n+\tif !ok {\n \t\treturn c.sendAlert(err)\n \t}\n+\tb.off = off\n \tdata := b.data[b.off:]\n \tif len(data) > maxPlaintext {\n \t\tc.sendAlert(alertRecordOverflow)\n@@ -637,18 +696,52 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {\n \t\tif m > maxPlaintext {\n \t\t\tm = maxPlaintext\n \t\t}\n-\t\tb.resize(recordHeaderLen + m)\n+\t\texplicitIVLen := 0\n+\t\texplicitIVIsSeq := false\n+\n+\t\tvar cbc cbcMode\n+\t\tif c.out.version >= VersionTLS11 {\n+\t\t\tvar ok bool\n+\t\t\tif cbc, ok = c.out.cipher.(cbcMode); ok {\n+\t\t\t\texplicitIVLen = cbc.BlockSize()\n+\t\t\t}\n+\t\t}\n+\t\tif explicitIVLen == 0 {\n+\t\t\tif _, ok := c.out.cipher.(cipher.AEAD); ok {\n+\t\t\t\texplicitIVLen = 8\n+\t\t\t\t// The AES-GCM construction in TLS has an\n+\t\t\t\t// explicit nonce so that the nonce can be\n+\t\t\t\t// random. However, the nonce is only 8 bytes\n+\t\t\t\t// which is too small for a secure, random\n+\t\t\t\t// nonce. Therefore we use the sequence number\n+\t\t\t\t// as the nonce.\n+\t\t\t\texplicitIVIsSeq = true\n+\t\t\t}\n+\t\t}\n+\t\tb.resize(recordHeaderLen + explicitIVLen + m)\n \t\tb.data[0] = byte(typ)\n \t\tvers := c.vers\n \t\tif vers == 0 {\n-\t\t\tvers = maxVersion\n+\t\t\t// Some TLS servers fail if the record version is\n+\t\t\t// greater than TLS 1.0 for the initial ClientHello.\n+\t\t\tvers = VersionTLS10\n \t\t}\n \t\tb.data[1] = byte(vers >> 8)\n \t\tb.data[2] = byte(vers)\n \t\tb.data[3] = byte(m >> 8)\n \t\tb.data[4] = byte(m)\n-\t\tcopy(b.data[recordHeaderLen:], data)\n-\t\tc.out.encrypt(b)\n+\t\tif explicitIVLen > 0 {\n+\t\t\texplicitIV := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]\n+\t\t\tif explicitIVIsSeq {\n+\t\t\t\tcopy(explicitIV, c.out.seq[:])\n+\t\t\t} else {\n+\t\t\t\tif _, err = io.ReadFull(c.config.rand(), explicitIV); err != nil {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcopy(b.data[recordHeaderLen+explicitIVLen:], data)\n+\t\tc.out.encrypt(b, explicitIVLen)\n \t\t_, err = c.conn.Write(b.data)\n \t\tif err != nil {\n \t\t\tbreak\n@@ -709,7 +802,9 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \tcase typeCertificate:\n \t\tm = new(certificateMsg)\n \tcase typeCertificateRequest:\n-\t\tm = new(certificateRequestMsg)\n+\t\tm = &certificateRequestMsg{\n+\t\t\thasSignatureAndHash: c.vers >= VersionTLS12,\n+\t\t}\n \tcase typeCertificateStatus:\n \t\tm = new(certificateStatusMsg)\n \tcase typeServerKeyExchange:\n@@ -719,7 +814,9 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \tcase typeClientKeyExchange:\n \t\tm = new(clientKeyExchangeMsg)\n \tcase typeCertificateVerify:\n-\t\tm = new(certificateVerifyMsg)\n+\t\tm = &certificateVerifyMsg{\n+\t\t\thasSignatureAndHash: c.vers >= VersionTLS12,\n+\t\t}\n \tcase typeNextProtocol:\n \t\tm = new(nextProtoMsg)\n \tcase typeFinished:\n@@ -768,7 +865,7 @@ func (c *Conn) Write(b []byte) (int, error) {\n \t// http://www.imperialviolet.org/2012/01/15/beastfollowup.html\n \n \tvar m int\n-\tif len(b) > 1 && c.vers <= versionTLS10 {\n+\tif len(b) > 1 && c.vers <= VersionTLS10 {\n \t\tif _, ok := c.out.cipher.(cipher.BlockMode); ok {\n \t\t\tn, err := c.writeRecord(recordTypeApplicationData, b[:1])\n \t\t\tif err != nil {\n@@ -792,21 +889,32 @@ func (c *Conn) Read(b []byte) (n int, err error) {\n \tc.in.Lock()\n \tdefer c.in.Unlock()\n \n-\tfor c.input == nil && c.error() == nil {\n-\t\tif err := c.readRecord(recordTypeApplicationData); err != nil {\n-\t\t\t// Soft error, like EAGAIN\n+\t// Some OpenSSL servers send empty records in order to randomize the\n+\t// CBC IV. So this loop ignores a limited number of empty records.\n+\tconst maxConsecutiveEmptyRecords = 100\n+\tfor emptyRecordCount := 0; emptyRecordCount <= maxConsecutiveEmptyRecords; emptyRecordCount++ {\n+\t\tfor c.input == nil && c.error() == nil {\n+\t\t\tif err := c.readRecord(recordTypeApplicationData); err != nil {\n+\t\t\t\t// Soft error, like EAGAIN\n+\t\t\t\treturn 0, err\n+\t\t\t}\n+\t\t}\n+\t\tif err := c.error(); err != nil {\n \t\t\treturn 0, err\n \t\t}\n+\n+\t\tn, err = c.input.Read(b)\n+\t\tif c.input.off >= len(c.input.data) {\n+\t\t\tc.in.freeBlock(c.input)\n+\t\t\tc.input = nil\n+\t\t}\n+\n+\t\tif n != 0 || err != nil {\n+\t\t\treturn n, err\n+\t\t}\n \t}\n-\tif err := c.error(); err != nil {\n-\t\treturn 0, err\n-\t}\n-\tn, err = c.input.Read(b)\n-\tif c.input.off >= len(c.input.data) {\n-\t\tc.in.freeBlock(c.input)\n-\t\tc.input = nil\n-\t}\n-\treturn n, nil\n+\n+\treturn 0, io.ErrNoProgress\n }\n \n // Close closes the connection."}, {"sha": "b417ea4640fef84fbac2d0dfc655f5ab6249bdd5", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -30,7 +30,7 @@ var (\n \tvalidFrom = flag.String(\"start-date\", \"\", \"Creation date formatted as Jan 1 15:04:05 2011\")\n \tvalidFor  = flag.Duration(\"duration\", 365*24*time.Hour, \"Duration that certificate is valid for\")\n \tisCA      = flag.Bool(\"ca\", false, \"whether this cert should be its own Certificate Authority\")\n-\trsaBits   = flag.Int(\"rsa-bits\", 1024, \"Size of RSA key to generate\")\n+\trsaBits   = flag.Int(\"rsa-bits\", 2048, \"Size of RSA key to generate\")\n )\n \n func main() {"}, {"sha": "85e4adefcb0944a8c88a200ebabd311fbca9c97a", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 112, "deletions": 49, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,25 +6,23 @@ package tls\n \n import (\n \t\"bytes\"\n-\t\"crypto\"\n+\t\"crypto/ecdsa\"\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n+\t\"encoding/asn1\"\n \t\"errors\"\n \t\"io\"\n \t\"strconv\"\n )\n \n func (c *Conn) clientHandshake() error {\n-\tfinishedHash := newFinishedHash(versionTLS10)\n-\n \tif c.config == nil {\n \t\tc.config = defaultConfig()\n \t}\n \n \thello := &clientHelloMsg{\n-\t\tvers:               maxVersion,\n-\t\tcipherSuites:       c.config.cipherSuites(),\n+\t\tvers:               c.config.maxVersion(),\n \t\tcompressionMethods: []uint8{compressionNone},\n \t\trandom:             make([]byte, 32),\n \t\tocspStapling:       true,\n@@ -34,6 +32,25 @@ func (c *Conn) clientHandshake() error {\n \t\tnextProtoNeg:       len(c.config.NextProtos) > 0,\n \t}\n \n+\tpossibleCipherSuites := c.config.cipherSuites()\n+\thello.cipherSuites = make([]uint16, 0, len(possibleCipherSuites))\n+\n+NextCipherSuite:\n+\tfor _, suiteId := range possibleCipherSuites {\n+\t\tfor _, suite := range cipherSuites {\n+\t\t\tif suite.id != suiteId {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// Don't advertise TLS 1.2-only cipher suites unless\n+\t\t\t// we're attempting TLS 1.2.\n+\t\t\tif hello.vers < VersionTLS12 && suite.flags&suiteTLS12 != 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\thello.cipherSuites = append(hello.cipherSuites, suiteId)\n+\t\t\tcontinue NextCipherSuite\n+\t\t}\n+\t}\n+\n \tt := uint32(c.config.time().Unix())\n \thello.random[0] = byte(t >> 24)\n \thello.random[1] = byte(t >> 16)\n@@ -45,7 +62,10 @@ func (c *Conn) clientHandshake() error {\n \t\treturn errors.New(\"short read from Rand\")\n \t}\n \n-\tfinishedHash.Write(hello.marshal())\n+\tif hello.vers >= VersionTLS12 {\n+\t\thello.signatureAndHashes = supportedSKXSignatureAlgorithms\n+\t}\n+\n \tc.writeRecord(recordTypeHandshake, hello.marshal())\n \n \tmsg, err := c.readHandshake()\n@@ -56,16 +76,19 @@ func (c *Conn) clientHandshake() error {\n \tif !ok {\n \t\treturn c.sendAlert(alertUnexpectedMessage)\n \t}\n-\tfinishedHash.Write(serverHello.marshal())\n \n-\tvers, ok := mutualVersion(serverHello.vers)\n-\tif !ok || vers < versionTLS10 {\n+\tvers, ok := c.config.mutualVersion(serverHello.vers)\n+\tif !ok || vers < VersionTLS10 {\n \t\t// TLS 1.0 is the minimum version supported as a client.\n \t\treturn c.sendAlert(alertProtocolVersion)\n \t}\n \tc.vers = vers\n \tc.haveVers = true\n \n+\tfinishedHash := newFinishedHash(c.vers)\n+\tfinishedHash.Write(hello.marshal())\n+\tfinishedHash.Write(serverHello.marshal())\n+\n \tif serverHello.compressionMethod != compressionNone {\n \t\treturn c.sendAlert(alertUnexpectedMessage)\n \t}\n@@ -121,7 +144,10 @@ func (c *Conn) clientHandshake() error {\n \t\t}\n \t}\n \n-\tif _, ok := certs[0].PublicKey.(*rsa.PublicKey); !ok {\n+\tswitch certs[0].PublicKey.(type) {\n+\tcase *rsa.PublicKey, *ecdsa.PublicKey:\n+\t\tbreak\n+\tdefault:\n \t\treturn c.sendAlert(alertUnsupportedCertificate)\n \t}\n \n@@ -148,7 +174,7 @@ func (c *Conn) clientHandshake() error {\n \t\treturn err\n \t}\n \n-\tkeyAgreement := suite.ka()\n+\tkeyAgreement := suite.ka(c.vers)\n \n \tskx, ok := msg.(*serverKeyExchangeMsg)\n \tif ok {\n@@ -165,7 +191,7 @@ func (c *Conn) clientHandshake() error {\n \t\t}\n \t}\n \n-\tvar certToSend *Certificate\n+\tvar chainToSend *Certificate\n \tvar certRequested bool\n \tcertReq, ok := msg.(*certificateRequestMsg)\n \tif ok {\n@@ -184,48 +210,56 @@ func (c *Conn) clientHandshake() error {\n \n \t\tfinishedHash.Write(certReq.marshal())\n \n-\t\t// For now, we only know how to sign challenges with RSA\n-\t\trsaAvail := false\n+\t\tvar rsaAvail, ecdsaAvail bool\n \t\tfor _, certType := range certReq.certificateTypes {\n-\t\t\tif certType == certTypeRSASign {\n+\t\t\tswitch certType {\n+\t\t\tcase certTypeRSASign:\n \t\t\t\trsaAvail = true\n-\t\t\t\tbreak\n+\t\t\tcase certTypeECDSASign:\n+\t\t\t\tecdsaAvail = true\n \t\t\t}\n \t\t}\n \n \t\t// We need to search our list of client certs for one\n \t\t// where SignatureAlgorithm is RSA and the Issuer is in\n \t\t// certReq.certificateAuthorities\n \tfindCert:\n-\t\tfor i, cert := range c.config.Certificates {\n-\t\t\tif !rsaAvail {\n+\t\tfor i, chain := range c.config.Certificates {\n+\t\t\tif !rsaAvail && !ecdsaAvail {\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\tleaf := cert.Leaf\n-\t\t\tif leaf == nil {\n-\t\t\t\tif leaf, err = x509.ParseCertificate(cert.Certificate[0]); err != nil {\n-\t\t\t\t\tc.sendAlert(alertInternalError)\n-\t\t\t\t\treturn errors.New(\"tls: failed to parse client certificate #\" + strconv.Itoa(i) + \": \" + err.Error())\n+\t\t\tfor j, cert := range chain.Certificate {\n+\t\t\t\tx509Cert := chain.Leaf\n+\t\t\t\t// parse the certificate if this isn't the leaf\n+\t\t\t\t// node, or if chain.Leaf was nil\n+\t\t\t\tif j != 0 || x509Cert == nil {\n+\t\t\t\t\tif x509Cert, err = x509.ParseCertificate(cert); err != nil {\n+\t\t\t\t\t\tc.sendAlert(alertInternalError)\n+\t\t\t\t\t\treturn errors.New(\"tls: failed to parse client certificate #\" + strconv.Itoa(i) + \": \" + err.Error())\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif leaf.PublicKeyAlgorithm != x509.RSA {\n-\t\t\t\tcontinue\n-\t\t\t}\n \n-\t\t\tif len(certReq.certificateAuthorities) == 0 {\n-\t\t\t\t// they gave us an empty list, so just take the\n-\t\t\t\t// first RSA cert from c.config.Certificates\n-\t\t\t\tcertToSend = &cert\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\t\t\tswitch {\n+\t\t\t\tcase rsaAvail && x509Cert.PublicKeyAlgorithm == x509.RSA:\n+\t\t\t\tcase ecdsaAvail && x509Cert.PublicKeyAlgorithm == x509.ECDSA:\n+\t\t\t\tdefault:\n+\t\t\t\t\tcontinue findCert\n+\t\t\t\t}\n \n-\t\t\tfor _, ca := range certReq.certificateAuthorities {\n-\t\t\t\tif bytes.Equal(leaf.RawIssuer, ca) {\n-\t\t\t\t\tcertToSend = &cert\n+\t\t\t\tif len(certReq.certificateAuthorities) == 0 {\n+\t\t\t\t\t// they gave us an empty list, so just take the\n+\t\t\t\t\t// first RSA cert from c.config.Certificates\n+\t\t\t\t\tchainToSend = &chain\n \t\t\t\t\tbreak findCert\n \t\t\t\t}\n+\n+\t\t\t\tfor _, ca := range certReq.certificateAuthorities {\n+\t\t\t\t\tif bytes.Equal(x509Cert.RawIssuer, ca) {\n+\t\t\t\t\t\tchainToSend = &chain\n+\t\t\t\t\t\tbreak findCert\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n@@ -246,8 +280,8 @@ func (c *Conn) clientHandshake() error {\n \t// certificate to send.\n \tif certRequested {\n \t\tcertMsg = new(certificateMsg)\n-\t\tif certToSend != nil {\n-\t\t\tcertMsg.certificates = certToSend.Certificate\n+\t\tif chainToSend != nil {\n+\t\t\tcertMsg.certificates = chainToSend.Certificate\n \t\t}\n \t\tfinishedHash.Write(certMsg.marshal())\n \t\tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n@@ -263,12 +297,29 @@ func (c *Conn) clientHandshake() error {\n \t\tc.writeRecord(recordTypeHandshake, ckx.marshal())\n \t}\n \n-\tif certToSend != nil {\n-\t\tcertVerify := new(certificateVerifyMsg)\n-\t\tdigest := make([]byte, 0, 36)\n-\t\tdigest = finishedHash.serverMD5.Sum(digest)\n-\t\tdigest = finishedHash.serverSHA1.Sum(digest)\n-\t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey.(*rsa.PrivateKey), crypto.MD5SHA1, digest)\n+\tif chainToSend != nil {\n+\t\tvar signed []byte\n+\t\tcertVerify := &certificateVerifyMsg{\n+\t\t\thasSignatureAndHash: c.vers >= VersionTLS12,\n+\t\t}\n+\n+\t\tswitch key := c.config.Certificates[0].PrivateKey.(type) {\n+\t\tcase *ecdsa.PrivateKey:\n+\t\t\tdigest, _, hashId := finishedHash.hashForClientCertificate(signatureECDSA)\n+\t\t\tr, s, err := ecdsa.Sign(c.config.rand(), key, digest)\n+\t\t\tif err == nil {\n+\t\t\t\tsigned, err = asn1.Marshal(ecdsaSignature{r, s})\n+\t\t\t}\n+\t\t\tcertVerify.signatureAndHash.signature = signatureECDSA\n+\t\t\tcertVerify.signatureAndHash.hash = hashId\n+\t\tcase *rsa.PrivateKey:\n+\t\t\tdigest, hashFunc, hashId := finishedHash.hashForClientCertificate(signatureRSA)\n+\t\t\tsigned, err = rsa.SignPKCS1v15(c.config.rand(), key, hashFunc, digest)\n+\t\t\tcertVerify.signatureAndHash.signature = signatureRSA\n+\t\t\tcertVerify.signatureAndHash.hash = hashId\n+\t\tdefault:\n+\t\t\terr = errors.New(\"unknown private key type\")\n+\t\t}\n \t\tif err != nil {\n \t\t\treturn c.sendAlert(alertInternalError)\n \t\t}\n@@ -282,8 +333,14 @@ func (c *Conn) clientHandshake() error {\n \tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n \t\tkeysFromMasterSecret(c.vers, masterSecret, hello.random, serverHello.random, suite.macLen, suite.keyLen, suite.ivLen)\n \n-\tclientCipher := suite.cipher(clientKey, clientIV, false /* not for reading */)\n-\tclientHash := suite.mac(c.vers, clientMAC)\n+\tvar clientCipher interface{}\n+\tvar clientHash macFunction\n+\tif suite.cipher != nil {\n+\t\tclientCipher = suite.cipher(clientKey, clientIV, false /* not for reading */)\n+\t\tclientHash = suite.mac(c.vers, clientMAC)\n+\t} else {\n+\t\tclientCipher = suite.aead(clientKey, clientIV)\n+\t}\n \tc.out.prepareCipherSpec(c.vers, clientCipher, clientHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n \n@@ -303,8 +360,14 @@ func (c *Conn) clientHandshake() error {\n \tfinishedHash.Write(finished.marshal())\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n \n-\tserverCipher := suite.cipher(serverKey, serverIV, true /* for reading */)\n-\tserverHash := suite.mac(c.vers, serverMAC)\n+\tvar serverCipher interface{}\n+\tvar serverHash macFunction\n+\tif suite.cipher != nil {\n+\t\tserverCipher = suite.cipher(serverKey, serverIV, true /* for reading */)\n+\t\tserverHash = suite.mac(c.vers, serverMAC)\n+\t} else {\n+\t\tserverCipher = suite.aead(serverKey, serverIV)\n+\t}\n \tc.in.prepareCipherSpec(c.vers, serverCipher, serverHash)\n \tc.readRecord(recordTypeChangeCipherSpec)\n \tif err := c.error(); err != nil {"}, {"sha": "6c564001b0d5d78a2c02ad9a5a8fb4a64307fad5", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 2648, "deletions": 6, "changes": 2654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "83952000f6ec8130c5331daf0367a0f0aef146ce", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 137, "deletions": 11, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -20,6 +20,7 @@ type clientHelloMsg struct {\n \tsupportedPoints    []uint8\n \tticketSupported    bool\n \tsessionTicket      []uint8\n+\tsignatureAndHashes []signatureAndHash\n }\n \n func (m *clientHelloMsg) equal(i interface{}) bool {\n@@ -40,7 +41,8 @@ func (m *clientHelloMsg) equal(i interface{}) bool {\n \t\teqUint16s(m.supportedCurves, m1.supportedCurves) &&\n \t\tbytes.Equal(m.supportedPoints, m1.supportedPoints) &&\n \t\tm.ticketSupported == m1.ticketSupported &&\n-\t\tbytes.Equal(m.sessionTicket, m1.sessionTicket)\n+\t\tbytes.Equal(m.sessionTicket, m1.sessionTicket) &&\n+\t\teqSignatureAndHashes(m.signatureAndHashes, m1.signatureAndHashes)\n }\n \n func (m *clientHelloMsg) marshal() []byte {\n@@ -74,6 +76,10 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\textensionsLength += len(m.sessionTicket)\n \t\tnumExtensions++\n \t}\n+\tif len(m.signatureAndHashes) > 0 {\n+\t\textensionsLength += 2 + 2*len(m.signatureAndHashes)\n+\t\tnumExtensions++\n+\t}\n \tif numExtensions > 0 {\n \t\textensionsLength += 4 * numExtensions\n \t\tlength += 2 + extensionsLength\n@@ -199,6 +205,25 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\tcopy(z, m.sessionTicket)\n \t\tz = z[len(m.sessionTicket):]\n \t}\n+\tif len(m.signatureAndHashes) > 0 {\n+\t\t// https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1\n+\t\tz[0] = byte(extensionSignatureAlgorithms >> 8)\n+\t\tz[1] = byte(extensionSignatureAlgorithms)\n+\t\tl := 2 + 2*len(m.signatureAndHashes)\n+\t\tz[2] = byte(l >> 8)\n+\t\tz[3] = byte(l)\n+\t\tz = z[4:]\n+\n+\t\tl -= 2\n+\t\tz[0] = byte(l >> 8)\n+\t\tz[1] = byte(l)\n+\t\tz = z[2:]\n+\t\tfor _, sigAndHash := range m.signatureAndHashes {\n+\t\t\tz[0] = sigAndHash.hash\n+\t\t\tz[1] = sigAndHash.signature\n+\t\t\tz = z[2:]\n+\t\t}\n+\t}\n \n \tm.raw = x\n \n@@ -249,6 +274,7 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \tm.ocspStapling = false\n \tm.ticketSupported = false\n \tm.sessionTicket = nil\n+\tm.signatureAndHashes = nil\n \n \tif len(data) == 0 {\n \t\t// ClientHello is optionally followed by extension data\n@@ -336,6 +362,23 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \t\t\t// http://tools.ietf.org/html/rfc5077#section-3.2\n \t\t\tm.ticketSupported = true\n \t\t\tm.sessionTicket = data[:length]\n+\t\tcase extensionSignatureAlgorithms:\n+\t\t\t// https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1\n+\t\t\tif length < 2 || length&1 != 0 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tl := int(data[0])<<8 | int(data[1])\n+\t\t\tif l != length-2 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tn := l / 2\n+\t\t\td := data[2:]\n+\t\t\tm.signatureAndHashes = make([]signatureAndHash, n)\n+\t\t\tfor i := range m.signatureAndHashes {\n+\t\t\t\tm.signatureAndHashes[i].hash = d[0]\n+\t\t\t\tm.signatureAndHashes[i].signature = d[1]\n+\t\t\t\td = d[2:]\n+\t\t\t}\n \t\t}\n \t\tdata = data[length:]\n \t}\n@@ -899,8 +942,14 @@ func (m *nextProtoMsg) unmarshal(data []byte) bool {\n }\n \n type certificateRequestMsg struct {\n-\traw                    []byte\n+\traw []byte\n+\t// hasSignatureAndHash indicates whether this message includes a list\n+\t// of signature and hash functions. This change was introduced with TLS\n+\t// 1.2.\n+\thasSignatureAndHash bool\n+\n \tcertificateTypes       []byte\n+\tsignatureAndHashes     []signatureAndHash\n \tcertificateAuthorities [][]byte\n }\n \n@@ -912,7 +961,8 @@ func (m *certificateRequestMsg) equal(i interface{}) bool {\n \n \treturn bytes.Equal(m.raw, m1.raw) &&\n \t\tbytes.Equal(m.certificateTypes, m1.certificateTypes) &&\n-\t\teqByteSlices(m.certificateAuthorities, m1.certificateAuthorities)\n+\t\teqByteSlices(m.certificateAuthorities, m1.certificateAuthorities) &&\n+\t\teqSignatureAndHashes(m.signatureAndHashes, m1.signatureAndHashes)\n }\n \n func (m *certificateRequestMsg) marshal() (x []byte) {\n@@ -928,6 +978,10 @@ func (m *certificateRequestMsg) marshal() (x []byte) {\n \t}\n \tlength += casLength\n \n+\tif m.hasSignatureAndHash {\n+\t\tlength += 2 + 2*len(m.signatureAndHashes)\n+\t}\n+\n \tx = make([]byte, 4+length)\n \tx[0] = typeCertificateRequest\n \tx[1] = uint8(length >> 16)\n@@ -938,6 +992,19 @@ func (m *certificateRequestMsg) marshal() (x []byte) {\n \n \tcopy(x[5:], m.certificateTypes)\n \ty := x[5+len(m.certificateTypes):]\n+\n+\tif m.hasSignatureAndHash {\n+\t\tn := len(m.signatureAndHashes) * 2\n+\t\ty[0] = uint8(n >> 8)\n+\t\ty[1] = uint8(n)\n+\t\ty = y[2:]\n+\t\tfor _, sigAndHash := range m.signatureAndHashes {\n+\t\t\ty[0] = sigAndHash.hash\n+\t\t\ty[1] = sigAndHash.signature\n+\t\t\ty = y[2:]\n+\t\t}\n+\t}\n+\n \ty[0] = uint8(casLength >> 8)\n \ty[1] = uint8(casLength)\n \ty = y[2:]\n@@ -978,6 +1045,27 @@ func (m *certificateRequestMsg) unmarshal(data []byte) bool {\n \n \tdata = data[numCertTypes:]\n \n+\tif m.hasSignatureAndHash {\n+\t\tif len(data) < 2 {\n+\t\t\treturn false\n+\t\t}\n+\t\tsigAndHashLen := uint16(data[0])<<8 | uint16(data[1])\n+\t\tdata = data[2:]\n+\t\tif sigAndHashLen&1 != 0 {\n+\t\t\treturn false\n+\t\t}\n+\t\tif len(data) < int(sigAndHashLen) {\n+\t\t\treturn false\n+\t\t}\n+\t\tnumSigAndHash := sigAndHashLen / 2\n+\t\tm.signatureAndHashes = make([]signatureAndHash, numSigAndHash)\n+\t\tfor i := range m.signatureAndHashes {\n+\t\t\tm.signatureAndHashes[i].hash = data[0]\n+\t\t\tm.signatureAndHashes[i].signature = data[1]\n+\t\t\tdata = data[2:]\n+\t\t}\n+\t}\n+\n \tif len(data) < 2 {\n \t\treturn false\n \t}\n@@ -1013,8 +1101,10 @@ func (m *certificateRequestMsg) unmarshal(data []byte) bool {\n }\n \n type certificateVerifyMsg struct {\n-\traw       []byte\n-\tsignature []byte\n+\traw                 []byte\n+\thasSignatureAndHash bool\n+\tsignatureAndHash    signatureAndHash\n+\tsignature           []byte\n }\n \n func (m *certificateVerifyMsg) equal(i interface{}) bool {\n@@ -1024,6 +1114,9 @@ func (m *certificateVerifyMsg) equal(i interface{}) bool {\n \t}\n \n \treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tm.hasSignatureAndHash == m1.hasSignatureAndHash &&\n+\t\tm.signatureAndHash.hash == m1.signatureAndHash.hash &&\n+\t\tm.signatureAndHash.signature == m1.signatureAndHash.signature &&\n \t\tbytes.Equal(m.signature, m1.signature)\n }\n \n@@ -1035,14 +1128,23 @@ func (m *certificateVerifyMsg) marshal() (x []byte) {\n \t// See http://tools.ietf.org/html/rfc4346#section-7.4.8\n \tsiglength := len(m.signature)\n \tlength := 2 + siglength\n+\tif m.hasSignatureAndHash {\n+\t\tlength += 2\n+\t}\n \tx = make([]byte, 4+length)\n \tx[0] = typeCertificateVerify\n \tx[1] = uint8(length >> 16)\n \tx[2] = uint8(length >> 8)\n \tx[3] = uint8(length)\n-\tx[4] = uint8(siglength >> 8)\n-\tx[5] = uint8(siglength)\n-\tcopy(x[6:], m.signature)\n+\ty := x[4:]\n+\tif m.hasSignatureAndHash {\n+\t\ty[0] = m.signatureAndHash.hash\n+\t\ty[1] = m.signatureAndHash.signature\n+\t\ty = y[2:]\n+\t}\n+\ty[0] = uint8(siglength >> 8)\n+\ty[1] = uint8(siglength)\n+\tcopy(y[2:], m.signature)\n \n \tm.raw = x\n \n@@ -1061,12 +1163,23 @@ func (m *certificateVerifyMsg) unmarshal(data []byte) bool {\n \t\treturn false\n \t}\n \n-\tsiglength := int(data[4])<<8 + int(data[5])\n-\tif len(data)-6 != siglength {\n+\tdata = data[4:]\n+\tif m.hasSignatureAndHash {\n+\t\tm.signatureAndHash.hash = data[0]\n+\t\tm.signatureAndHash.signature = data[1]\n+\t\tdata = data[2:]\n+\t}\n+\n+\tif len(data) < 2 {\n+\t\treturn false\n+\t}\n+\tsiglength := int(data[0])<<8 + int(data[1])\n+\tdata = data[2:]\n+\tif len(data) != siglength {\n \t\treturn false\n \t}\n \n-\tm.signature = data[6:]\n+\tm.signature = data\n \n \treturn true\n }\n@@ -1165,3 +1278,16 @@ func eqByteSlices(x, y [][]byte) bool {\n \t}\n \treturn true\n }\n+\n+func eqSignatureAndHashes(x, y []signatureAndHash) bool {\n+\tif len(x) != len(y) {\n+\t\treturn false\n+\t}\n+\tfor i, v := range x {\n+\t\tv2 := y[i]\n+\t\tif v.hash != v2.hash || v.signature != v2.signature {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}"}, {"sha": "4f569eeb1389eddae09ea48f84bd85733ccbafe4", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -135,6 +135,9 @@ func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \t\t\tm.sessionTicket = randomBytes(rand.Intn(300), rand)\n \t\t}\n \t}\n+\tif rand.Intn(10) > 5 {\n+\t\tm.signatureAndHashes = supportedSKXSignatureAlgorithms\n+\t}\n \n \treturn reflect.ValueOf(m)\n }"}, {"sha": "c9ccf675cd8a14b73955899c98fe422d43443910", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 85, "deletions": 36, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,9 +6,11 @@ package tls\n \n import (\n \t\"crypto\"\n+\t\"crypto/ecdsa\"\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n+\t\"encoding/asn1\"\n \t\"errors\"\n \t\"io\"\n )\n@@ -21,10 +23,12 @@ type serverHandshakeState struct {\n \thello           *serverHelloMsg\n \tsuite           *cipherSuite\n \tellipticOk      bool\n+\tecdsaOk         bool\n \tsessionState    *sessionState\n \tfinishedHash    finishedHash\n \tmasterSecret    []byte\n \tcertsFromClient [][]byte\n+\tcert            *Certificate\n }\n \n // serverHandshake performs a TLS handshake as a server.\n@@ -98,7 +102,7 @@ func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) {\n \tif !ok {\n \t\treturn false, c.sendAlert(alertUnexpectedMessage)\n \t}\n-\tc.vers, ok = mutualVersion(hs.clientHello.vers)\n+\tc.vers, ok = config.mutualVersion(hs.clientHello.vers)\n \tif !ok {\n \t\treturn false, c.sendAlert(alertProtocolVersion)\n \t}\n@@ -156,11 +160,25 @@ Curves:\n \tif len(hs.clientHello.serverName) > 0 {\n \t\tc.serverName = hs.clientHello.serverName\n \t}\n-\tif hs.clientHello.nextProtoNeg {\n+\t// Although sending an empty NPN extension is reasonable, Firefox has\n+\t// had a bug around this. Best to send nothing at all if\n+\t// config.NextProtos is empty. See\n+\t// https://code.google.com/p/go/issues/detail?id=5445.\n+\tif hs.clientHello.nextProtoNeg && len(config.NextProtos) > 0 {\n \t\ths.hello.nextProtoNeg = true\n \t\ths.hello.nextProtos = config.NextProtos\n \t}\n \n+\tif len(config.Certificates) == 0 {\n+\t\treturn false, c.sendAlert(alertInternalError)\n+\t}\n+\ths.cert = &config.Certificates[0]\n+\tif len(hs.clientHello.serverName) > 0 {\n+\t\ths.cert = config.getCertificateForName(hs.clientHello.serverName)\n+\t}\n+\n+\t_, hs.ecdsaOk = hs.cert.PrivateKey.(*ecdsa.PrivateKey)\n+\n \tif hs.checkForResumption() {\n \t\treturn true, nil\n \t}\n@@ -175,7 +193,7 @@ Curves:\n \t}\n \n \tfor _, id := range preferenceList {\n-\t\tif hs.suite = c.tryCipherSuite(id, supportedList, hs.ellipticOk); hs.suite != nil {\n+\t\tif hs.suite = c.tryCipherSuite(id, supportedList, c.vers, hs.ellipticOk, hs.ecdsaOk); hs.suite != nil {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -199,7 +217,7 @@ func (hs *serverHandshakeState) checkForResumption() bool {\n \tif hs.sessionState.vers > hs.clientHello.vers {\n \t\treturn false\n \t}\n-\tif vers, ok := mutualVersion(hs.sessionState.vers); !ok || vers != hs.sessionState.vers {\n+\tif vers, ok := c.config.mutualVersion(hs.sessionState.vers); !ok || vers != hs.sessionState.vers {\n \t\treturn false\n \t}\n \n@@ -216,7 +234,7 @@ func (hs *serverHandshakeState) checkForResumption() bool {\n \t}\n \n \t// Check that we also support the ciphersuite from the session.\n-\ths.suite = c.tryCipherSuite(hs.sessionState.cipherSuite, c.config.cipherSuites(), hs.ellipticOk)\n+\ths.suite = c.tryCipherSuite(hs.sessionState.cipherSuite, c.config.cipherSuites(), hs.sessionState.vers, hs.ellipticOk, hs.ecdsaOk)\n \tif hs.suite == nil {\n \t\treturn false\n \t}\n@@ -258,15 +276,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \tconfig := hs.c.config\n \tc := hs.c\n \n-\tif len(config.Certificates) == 0 {\n-\t\treturn c.sendAlert(alertInternalError)\n-\t}\n-\tcert := &config.Certificates[0]\n-\tif len(hs.clientHello.serverName) > 0 {\n-\t\tcert = config.getCertificateForName(hs.clientHello.serverName)\n-\t}\n-\n-\tif hs.clientHello.ocspStapling && len(cert.OCSPStaple) > 0 {\n+\tif hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0 {\n \t\ths.hello.ocspStapling = true\n \t}\n \n@@ -276,20 +286,20 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \tc.writeRecord(recordTypeHandshake, hs.hello.marshal())\n \n \tcertMsg := new(certificateMsg)\n-\tcertMsg.certificates = cert.Certificate\n+\tcertMsg.certificates = hs.cert.Certificate\n \ths.finishedHash.Write(certMsg.marshal())\n \tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n \n \tif hs.hello.ocspStapling {\n \t\tcertStatus := new(certificateStatusMsg)\n \t\tcertStatus.statusType = statusTypeOCSP\n-\t\tcertStatus.response = cert.OCSPStaple\n+\t\tcertStatus.response = hs.cert.OCSPStaple\n \t\ths.finishedHash.Write(certStatus.marshal())\n \t\tc.writeRecord(recordTypeHandshake, certStatus.marshal())\n \t}\n \n-\tkeyAgreement := hs.suite.ka()\n-\tskx, err := keyAgreement.generateServerKeyExchange(config, cert, hs.clientHello, hs.hello)\n+\tkeyAgreement := hs.suite.ka(c.vers)\n+\tskx, err := keyAgreement.generateServerKeyExchange(config, hs.cert, hs.clientHello, hs.hello)\n \tif err != nil {\n \t\tc.sendAlert(alertHandshakeFailure)\n \t\treturn err\n@@ -302,7 +312,14 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \tif config.ClientAuth >= RequestClientCert {\n \t\t// Request a client certificate\n \t\tcertReq := new(certificateRequestMsg)\n-\t\tcertReq.certificateTypes = []byte{certTypeRSASign}\n+\t\tcertReq.certificateTypes = []byte{\n+\t\t\tbyte(certTypeRSASign),\n+\t\t\tbyte(certTypeECDSASign),\n+\t\t}\n+\t\tif c.vers >= VersionTLS12 {\n+\t\t\tcertReq.hasSignatureAndHash = true\n+\t\t\tcertReq.signatureAndHashes = supportedClientCertSignatureAlgorithms\n+\t\t}\n \n \t\t// An empty list of certificateAuthorities signals to\n \t\t// the client that it may send any certificate in response\n@@ -320,7 +337,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \ths.finishedHash.Write(helloDone.marshal())\n \tc.writeRecord(recordTypeHandshake, helloDone.marshal())\n \n-\tvar pub *rsa.PublicKey // public key for client auth, if any\n+\tvar pub crypto.PublicKey // public key for client auth, if any\n \n \tmsg, err := c.readHandshake()\n \tif err != nil {\n@@ -365,7 +382,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \n \t// If we received a client cert in response to our certificate request message,\n \t// the client will send us a certificateVerifyMsg immediately after the\n-\t// clientKeyExchangeMsg.  This message is a MD5SHA1 digest of all preceding\n+\t// clientKeyExchangeMsg.  This message is a digest of all preceding\n \t// handshake-layer messages that is signed using the private key corresponding\n \t// to the client's certificate. This allows us to verify that the client is in\n \t// possession of the private key of the certificate.\n@@ -379,10 +396,25 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t\t\treturn c.sendAlert(alertUnexpectedMessage)\n \t\t}\n \n-\t\tdigest := make([]byte, 0, 36)\n-\t\tdigest = hs.finishedHash.serverMD5.Sum(digest)\n-\t\tdigest = hs.finishedHash.serverSHA1.Sum(digest)\n-\t\terr = rsa.VerifyPKCS1v15(pub, crypto.MD5SHA1, digest, certVerify.signature)\n+\t\tswitch key := pub.(type) {\n+\t\tcase *ecdsa.PublicKey:\n+\t\t\tecdsaSig := new(ecdsaSignature)\n+\t\t\tif _, err = asn1.Unmarshal(certVerify.signature, ecdsaSig); err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 {\n+\t\t\t\terr = errors.New(\"ECDSA signature contained zero or negative values\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tdigest, _, _ := hs.finishedHash.hashForClientCertificate(signatureECDSA)\n+\t\t\tif !ecdsa.Verify(key, digest, ecdsaSig.R, ecdsaSig.S) {\n+\t\t\t\terr = errors.New(\"ECDSA verification failure\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\tcase *rsa.PublicKey:\n+\t\t\tdigest, hashFunc, _ := hs.finishedHash.hashForClientCertificate(signatureRSA)\n+\t\t\terr = rsa.VerifyPKCS1v15(key, hashFunc, digest, certVerify.signature)\n+\t\t}\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n \t\t\treturn errors.New(\"could not validate signature of connection nonces: \" + err.Error())\n@@ -391,7 +423,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t\ths.finishedHash.Write(certVerify.marshal())\n \t}\n \n-\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(config, cert, ckx, c.vers)\n+\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(config, hs.cert, ckx, c.vers)\n \tif err != nil {\n \t\tc.sendAlert(alertHandshakeFailure)\n \t\treturn err\n@@ -407,12 +439,20 @@ func (hs *serverHandshakeState) establishKeys() error {\n \tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n \t\tkeysFromMasterSecret(c.vers, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n \n-\tclientCipher := hs.suite.cipher(clientKey, clientIV, true /* for reading */)\n-\tclientHash := hs.suite.mac(c.vers, clientMAC)\n-\tc.in.prepareCipherSpec(c.vers, clientCipher, clientHash)\n+\tvar clientCipher, serverCipher interface{}\n+\tvar clientHash, serverHash macFunction\n \n-\tserverCipher := hs.suite.cipher(serverKey, serverIV, false /* not for reading */)\n-\tserverHash := hs.suite.mac(c.vers, serverMAC)\n+\tif hs.suite.aead == nil {\n+\t\tclientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)\n+\t\tclientHash = hs.suite.mac(c.vers, clientMAC)\n+\t\tserverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */)\n+\t\tserverHash = hs.suite.mac(c.vers, serverMAC)\n+\t} else {\n+\t\tclientCipher = hs.suite.aead(clientKey, clientIV)\n+\t\tserverCipher = hs.suite.aead(serverKey, serverIV)\n+\t}\n+\n+\tc.in.prepareCipherSpec(c.vers, clientCipher, clientHash)\n \tc.out.prepareCipherSpec(c.vers, serverCipher, serverHash)\n \n \treturn nil\n@@ -502,7 +542,7 @@ func (hs *serverHandshakeState) sendFinished() error {\n // processCertsFromClient takes a chain of client certificates either from a\n // Certificates message or from a sessionState and verifies them. It returns\n // the public key of the leaf certificate.\n-func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (*rsa.PublicKey, error) {\n+func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (crypto.PublicKey, error) {\n \tc := hs.c\n \n \ths.certsFromClient = certificates\n@@ -549,8 +589,11 @@ func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (*\n \t}\n \n \tif len(certs) > 0 {\n-\t\tpub, ok := certs[0].PublicKey.(*rsa.PublicKey)\n-\t\tif !ok {\n+\t\tvar pub crypto.PublicKey\n+\t\tswitch key := certs[0].PublicKey.(type) {\n+\t\tcase *ecdsa.PublicKey, *rsa.PublicKey:\n+\t\t\tpub = key\n+\t\tdefault:\n \t\t\treturn nil, c.sendAlert(alertUnsupportedCertificate)\n \t\t}\n \t\tc.peerCertificates = certs\n@@ -562,7 +605,7 @@ func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (*\n \n // tryCipherSuite returns a cipherSuite with the given id if that cipher suite\n // is acceptable to use.\n-func (c *Conn) tryCipherSuite(id uint16, supportedCipherSuites []uint16, ellipticOk bool) *cipherSuite {\n+func (c *Conn) tryCipherSuite(id uint16, supportedCipherSuites []uint16, version uint16, ellipticOk, ecdsaOk bool) *cipherSuite {\n \tfor _, supported := range supportedCipherSuites {\n \t\tif id == supported {\n \t\t\tvar candidate *cipherSuite\n@@ -578,7 +621,13 @@ func (c *Conn) tryCipherSuite(id uint16, supportedCipherSuites []uint16, ellipti\n \t\t\t}\n \t\t\t// Don't select a ciphersuite which we can't\n \t\t\t// support for this client.\n-\t\t\tif candidate.elliptic && !ellipticOk {\n+\t\t\tif (candidate.flags&suiteECDHE != 0) && !ellipticOk {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif (candidate.flags&suiteECDSA != 0) != ecdsaOk {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif version < VersionTLS12 && candidate.flags&suiteTLS12 != 0 {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\treturn candidate"}, {"sha": "c08eba7f17ce91996130ab68bf6083830e4b4840", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 2098, "deletions": 303, "changes": 2401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "7e820c1e7e91c978e41f489fa04ddfae80899c24", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 165, "deletions": 18, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,11 +6,14 @@ package tls\n \n import (\n \t\"crypto\"\n+\t\"crypto/ecdsa\"\n \t\"crypto/elliptic\"\n \t\"crypto/md5\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n+\t\"crypto/sha256\"\n \t\"crypto/x509\"\n+\t\"encoding/asn1\"\n \t\"errors\"\n \t\"io\"\n \t\"math/big\"\n@@ -36,7 +39,7 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certifi\n \t}\n \n \tciphertext := ckx.ciphertext\n-\tif version != versionSSL30 {\n+\tif version != VersionSSL30 {\n \t\tciphertextLen := int(ckx.ciphertext[0])<<8 | int(ckx.ciphertext[1])\n \t\tif ciphertextLen != len(ckx.ciphertext)-2 {\n \t\t\treturn nil, errors.New(\"bad ClientKeyExchange\")\n@@ -82,34 +85,94 @@ func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello\n \treturn preMasterSecret, ckx, nil\n }\n \n+// sha1Hash calculates a SHA1 hash over the given byte slices.\n+func sha1Hash(slices [][]byte) []byte {\n+\thsha1 := sha1.New()\n+\tfor _, slice := range slices {\n+\t\thsha1.Write(slice)\n+\t}\n+\treturn hsha1.Sum(nil)\n+}\n+\n // md5SHA1Hash implements TLS 1.0's hybrid hash function which consists of the\n // concatenation of an MD5 and SHA1 hash.\n-func md5SHA1Hash(slices ...[]byte) []byte {\n+func md5SHA1Hash(slices [][]byte) []byte {\n \tmd5sha1 := make([]byte, md5.Size+sha1.Size)\n \thmd5 := md5.New()\n \tfor _, slice := range slices {\n \t\thmd5.Write(slice)\n \t}\n \tcopy(md5sha1, hmd5.Sum(nil))\n+\tcopy(md5sha1[md5.Size:], sha1Hash(slices))\n+\treturn md5sha1\n+}\n \n-\thsha1 := sha1.New()\n+// sha256Hash implements TLS 1.2's hash function.\n+func sha256Hash(slices [][]byte) []byte {\n+\th := sha256.New()\n \tfor _, slice := range slices {\n-\t\thsha1.Write(slice)\n+\t\th.Write(slice)\n \t}\n-\tcopy(md5sha1[md5.Size:], hsha1.Sum(nil))\n-\treturn md5sha1\n+\treturn h.Sum(nil)\n+}\n+\n+// hashForServerKeyExchange hashes the given slices and returns their digest\n+// and the identifier of the hash function used. The hashFunc argument is only\n+// used for >= TLS 1.2 and precisely identifies the hash function to use.\n+func hashForServerKeyExchange(sigType, hashFunc uint8, version uint16, slices ...[]byte) ([]byte, crypto.Hash, error) {\n+\tif version >= VersionTLS12 {\n+\t\tswitch hashFunc {\n+\t\tcase hashSHA256:\n+\t\t\treturn sha256Hash(slices), crypto.SHA256, nil\n+\t\tcase hashSHA1:\n+\t\t\treturn sha1Hash(slices), crypto.SHA1, nil\n+\t\tdefault:\n+\t\t\treturn nil, crypto.Hash(0), errors.New(\"tls: unknown hash function used by peer\")\n+\t\t}\n+\t}\n+\tif sigType == signatureECDSA {\n+\t\treturn sha1Hash(slices), crypto.SHA1, nil\n+\t}\n+\treturn md5SHA1Hash(slices), crypto.MD5SHA1, nil\n+}\n+\n+// pickTLS12HashForSignature returns a TLS 1.2 hash identifier for signing a\n+// ServerKeyExchange given the signature type being used and the client's\n+// advertized list of supported signature and hash combinations.\n+func pickTLS12HashForSignature(sigType uint8, clientSignatureAndHashes []signatureAndHash) (uint8, error) {\n+\tif len(clientSignatureAndHashes) == 0 {\n+\t\t// If the client didn't specify any signature_algorithms\n+\t\t// extension then we can assume that it supports SHA1. See\n+\t\t// http://tools.ietf.org/html/rfc5246#section-7.4.1.4.1\n+\t\treturn hashSHA1, nil\n+\t}\n+\n+\tfor _, sigAndHash := range clientSignatureAndHashes {\n+\t\tif sigAndHash.signature != sigType {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch sigAndHash.hash {\n+\t\tcase hashSHA1, hashSHA256:\n+\t\t\treturn sigAndHash.hash, nil\n+\t\t}\n+\t}\n+\n+\treturn 0, errors.New(\"tls: client doesn't support any common hash functions\")\n }\n \n // ecdheRSAKeyAgreement implements a TLS key agreement where the server\n // generates a ephemeral EC public/private key pair and signs it. The\n-// pre-master secret is then calculated using ECDH.\n-type ecdheRSAKeyAgreement struct {\n+// pre-master secret is then calculated using ECDH. The signature may\n+// either be ECDSA or RSA.\n+type ecdheKeyAgreement struct {\n+\tversion    uint16\n+\tsigType    uint8\n \tprivateKey []byte\n \tcurve      elliptic.Curve\n \tx, y       *big.Int\n }\n \n-func (ka *ecdheRSAKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) {\n+func (ka *ecdheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) {\n \tvar curveid uint16\n \n Curve:\n@@ -150,24 +213,63 @@ Curve:\n \tserverECDHParams[3] = byte(len(ecdhePublic))\n \tcopy(serverECDHParams[4:], ecdhePublic)\n \n-\tmd5sha1 := md5SHA1Hash(clientHello.random, hello.random, serverECDHParams)\n-\tsig, err := rsa.SignPKCS1v15(config.rand(), cert.PrivateKey.(*rsa.PrivateKey), crypto.MD5SHA1, md5sha1)\n+\tvar tls12HashId uint8\n+\tif ka.version >= VersionTLS12 {\n+\t\tif tls12HashId, err = pickTLS12HashForSignature(ka.sigType, clientHello.signatureAndHashes); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tdigest, hashFunc, err := hashForServerKeyExchange(ka.sigType, tls12HashId, ka.version, clientHello.random, hello.random, serverECDHParams)\n \tif err != nil {\n-\t\treturn nil, errors.New(\"failed to sign ECDHE parameters: \" + err.Error())\n+\t\treturn nil, err\n+\t}\n+\tvar sig []byte\n+\tswitch ka.sigType {\n+\tcase signatureECDSA:\n+\t\tprivKey, ok := cert.PrivateKey.(*ecdsa.PrivateKey)\n+\t\tif !ok {\n+\t\t\treturn nil, errors.New(\"ECDHE ECDSA requires an ECDSA server private key\")\n+\t\t}\n+\t\tr, s, err := ecdsa.Sign(config.rand(), privKey, digest)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.New(\"failed to sign ECDHE parameters: \" + err.Error())\n+\t\t}\n+\t\tsig, err = asn1.Marshal(ecdsaSignature{r, s})\n+\tcase signatureRSA:\n+\t\tprivKey, ok := cert.PrivateKey.(*rsa.PrivateKey)\n+\t\tif !ok {\n+\t\t\treturn nil, errors.New(\"ECDHE RSA requires a RSA server private key\")\n+\t\t}\n+\t\tsig, err = rsa.SignPKCS1v15(config.rand(), privKey, hashFunc, digest)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.New(\"failed to sign ECDHE parameters: \" + err.Error())\n+\t\t}\n+\tdefault:\n+\t\treturn nil, errors.New(\"unknown ECDHE signature algorithm\")\n \t}\n \n \tskx := new(serverKeyExchangeMsg)\n-\tskx.key = make([]byte, len(serverECDHParams)+2+len(sig))\n+\tsigAndHashLen := 0\n+\tif ka.version >= VersionTLS12 {\n+\t\tsigAndHashLen = 2\n+\t}\n+\tskx.key = make([]byte, len(serverECDHParams)+sigAndHashLen+2+len(sig))\n \tcopy(skx.key, serverECDHParams)\n \tk := skx.key[len(serverECDHParams):]\n+\tif ka.version >= VersionTLS12 {\n+\t\tk[0] = tls12HashId\n+\t\tk[1] = ka.sigType\n+\t\tk = k[2:]\n+\t}\n \tk[0] = byte(len(sig) >> 8)\n \tk[1] = byte(len(sig))\n \tcopy(k[2:], sig)\n \n \treturn skx, nil\n }\n \n-func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {\n+func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {\n \tif len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {\n \t\treturn nil, errors.New(\"bad ClientKeyExchange\")\n \t}\n@@ -185,7 +287,7 @@ func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, cert *C\n \n var errServerKeyExchange = errors.New(\"invalid ServerKeyExchange\")\n \n-func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error {\n+func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error {\n \tif len(skx.key) < 4 {\n \t\treturn errServerKeyExchange\n \t}\n@@ -219,17 +321,62 @@ func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientH\n \tif len(sig) < 2 {\n \t\treturn errServerKeyExchange\n \t}\n+\n+\tvar tls12HashId uint8\n+\tif ka.version >= VersionTLS12 {\n+\t\t// handle SignatureAndHashAlgorithm\n+\t\tvar sigAndHash []uint8\n+\t\tsigAndHash, sig = sig[:2], sig[2:]\n+\t\tif sigAndHash[1] != ka.sigType {\n+\t\t\treturn errServerKeyExchange\n+\t\t}\n+\t\ttls12HashId = sigAndHash[0]\n+\t\tif len(sig) < 2 {\n+\t\t\treturn errServerKeyExchange\n+\t\t}\n+\t}\n \tsigLen := int(sig[0])<<8 | int(sig[1])\n \tif sigLen+2 != len(sig) {\n \t\treturn errServerKeyExchange\n \t}\n \tsig = sig[2:]\n \n-\tmd5sha1 := md5SHA1Hash(clientHello.random, serverHello.random, serverECDHParams)\n-\treturn rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), crypto.MD5SHA1, md5sha1, sig)\n+\tdigest, hashFunc, err := hashForServerKeyExchange(ka.sigType, tls12HashId, ka.version, clientHello.random, serverHello.random, serverECDHParams)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tswitch ka.sigType {\n+\tcase signatureECDSA:\n+\t\tpubKey, ok := cert.PublicKey.(*ecdsa.PublicKey)\n+\t\tif !ok {\n+\t\t\treturn errors.New(\"ECDHE ECDSA requires a ECDSA server public key\")\n+\t\t}\n+\t\tecdsaSig := new(ecdsaSignature)\n+\t\tif _, err := asn1.Unmarshal(sig, ecdsaSig); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 {\n+\t\t\treturn errors.New(\"ECDSA signature contained zero or negative values\")\n+\t\t}\n+\t\tif !ecdsa.Verify(pubKey, digest, ecdsaSig.R, ecdsaSig.S) {\n+\t\t\treturn errors.New(\"ECDSA verification failure\")\n+\t\t}\n+\tcase signatureRSA:\n+\t\tpubKey, ok := cert.PublicKey.(*rsa.PublicKey)\n+\t\tif !ok {\n+\t\t\treturn errors.New(\"ECDHE RSA requires a RSA server public key\")\n+\t\t}\n+\t\tif err := rsa.VerifyPKCS1v15(pubKey, hashFunc, digest, sig); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\tdefault:\n+\t\treturn errors.New(\"unknown ECDHE signature algorithm\")\n+\t}\n+\n+\treturn nil\n }\n \n-func (ka *ecdheRSAKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) {\n+func (ka *ecdheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) {\n \tif ka.curve == nil {\n \t\treturn nil, nil, errors.New(\"missing ServerKeyExchange message\")\n \t}"}, {"sha": "fb8b3ab4d1e398045b6cdde4c48ed7b8618dfc5a", "filename": "libgo/go/crypto/tls/prf.go", "status": "modified", "additions": 93, "deletions": 48, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -5,9 +5,11 @@\n package tls\n \n import (\n+\t\"crypto\"\n \t\"crypto/hmac\"\n \t\"crypto/md5\"\n \t\"crypto/sha1\"\n+\t\"crypto/sha256\"\n \t\"hash\"\n )\n \n@@ -43,8 +45,8 @@ func pHash(result, secret, seed []byte, hash func() hash.Hash) {\n \t}\n }\n \n-// pRF10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, section 5.\n-func pRF10(result, secret, label, seed []byte) {\n+// prf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, section 5.\n+func prf10(result, secret, label, seed []byte) {\n \thashSHA1 := sha1.New\n \thashMD5 := md5.New\n \n@@ -62,9 +64,18 @@ func pRF10(result, secret, label, seed []byte) {\n \t}\n }\n \n-// pRF30 implements the SSL 3.0 pseudo-random function, as defined in\n+// prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, section 5.\n+func prf12(result, secret, label, seed []byte) {\n+\tlabelAndSeed := make([]byte, len(label)+len(seed))\n+\tcopy(labelAndSeed, label)\n+\tcopy(labelAndSeed[len(label):], seed)\n+\n+\tpHash(result, secret, labelAndSeed, sha256.New)\n+}\n+\n+// prf30 implements the SSL 3.0 pseudo-random function, as defined in\n // www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt section 6.\n-func pRF30(result, secret, label, seed []byte) {\n+func prf30(result, secret, label, seed []byte) {\n \thashSHA1 := sha1.New()\n \thashMD5 := md5.New()\n \n@@ -106,38 +117,41 @@ var keyExpansionLabel = []byte(\"key expansion\")\n var clientFinishedLabel = []byte(\"client finished\")\n var serverFinishedLabel = []byte(\"server finished\")\n \n+func prfForVersion(version uint16) func(result, secret, label, seed []byte) {\n+\tswitch version {\n+\tcase VersionSSL30:\n+\t\treturn prf30\n+\tcase VersionTLS10, VersionTLS11:\n+\t\treturn prf10\n+\tcase VersionTLS12:\n+\t\treturn prf12\n+\tdefault:\n+\t\tpanic(\"unknown version\")\n+\t}\n+}\n+\n // masterFromPreMasterSecret generates the master secret from the pre-master\n // secret. See http://tools.ietf.org/html/rfc5246#section-8.1\n func masterFromPreMasterSecret(version uint16, preMasterSecret, clientRandom, serverRandom []byte) []byte {\n-\tprf := pRF10\n-\tif version == versionSSL30 {\n-\t\tprf = pRF30\n-\t}\n-\n \tvar seed [tlsRandomLength * 2]byte\n \tcopy(seed[0:len(clientRandom)], clientRandom)\n \tcopy(seed[len(clientRandom):], serverRandom)\n \tmasterSecret := make([]byte, masterSecretLength)\n-\tprf(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])\n+\tprfForVersion(version)(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])\n \treturn masterSecret\n }\n \n // keysFromMasterSecret generates the connection keys from the master\n // secret, given the lengths of the MAC key, cipher key and IV, as defined in\n // RFC 2246, section 6.3.\n func keysFromMasterSecret(version uint16, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {\n-\tprf := pRF10\n-\tif version == versionSSL30 {\n-\t\tprf = pRF30\n-\t}\n-\n \tvar seed [tlsRandomLength * 2]byte\n \tcopy(seed[0:len(clientRandom)], serverRandom)\n \tcopy(seed[len(serverRandom):], clientRandom)\n \n \tn := 2*macLen + 2*keyLen + 2*ivLen\n \tkeyMaterial := make([]byte, n)\n-\tprf(keyMaterial, masterSecret, keyExpansionLabel, seed[0:])\n+\tprfForVersion(version)(keyMaterial, masterSecret, keyExpansionLabel, seed[0:])\n \tclientMAC = keyMaterial[:macLen]\n \tkeyMaterial = keyMaterial[macLen:]\n \tserverMAC = keyMaterial[:macLen]\n@@ -153,37 +167,34 @@ func keysFromMasterSecret(version uint16, masterSecret, clientRandom, serverRand\n }\n \n func newFinishedHash(version uint16) finishedHash {\n-\treturn finishedHash{md5.New(), sha1.New(), md5.New(), sha1.New(), version}\n+\tif version >= VersionTLS12 {\n+\t\treturn finishedHash{sha256.New(), sha256.New(), nil, nil, version}\n+\t}\n+\treturn finishedHash{sha1.New(), sha1.New(), md5.New(), md5.New(), version}\n }\n \n // A finishedHash calculates the hash of a set of handshake messages suitable\n // for including in a Finished message.\n type finishedHash struct {\n-\tclientMD5  hash.Hash\n-\tclientSHA1 hash.Hash\n-\tserverMD5  hash.Hash\n-\tserverSHA1 hash.Hash\n-\tversion    uint16\n+\tclient hash.Hash\n+\tserver hash.Hash\n+\n+\t// Prior to TLS 1.2, an additional MD5 hash is required.\n+\tclientMD5 hash.Hash\n+\tserverMD5 hash.Hash\n+\n+\tversion uint16\n }\n \n func (h finishedHash) Write(msg []byte) (n int, err error) {\n-\th.clientMD5.Write(msg)\n-\th.clientSHA1.Write(msg)\n-\th.serverMD5.Write(msg)\n-\th.serverSHA1.Write(msg)\n-\treturn len(msg), nil\n-}\n+\th.client.Write(msg)\n+\th.server.Write(msg)\n \n-// finishedSum10 calculates the contents of the verify_data member of a TLSv1\n-// Finished message given the MD5 and SHA1 hashes of a set of handshake\n-// messages.\n-func finishedSum10(md5, sha1, label, masterSecret []byte) []byte {\n-\tseed := make([]byte, len(md5)+len(sha1))\n-\tcopy(seed, md5)\n-\tcopy(seed[len(md5):], sha1)\n-\tout := make([]byte, finishedVerifyLength)\n-\tpRF10(out, masterSecret, label, seed)\n-\treturn out\n+\tif h.version < VersionTLS12 {\n+\t\th.clientMD5.Write(msg)\n+\t\th.serverMD5.Write(msg)\n+\t}\n+\treturn len(msg), nil\n }\n \n // finishedSum30 calculates the contents of the verify_data member of a SSLv3\n@@ -224,23 +235,57 @@ var ssl3ServerFinishedMagic = [4]byte{0x53, 0x52, 0x56, 0x52}\n // clientSum returns the contents of the verify_data member of a client's\n // Finished message.\n func (h finishedHash) clientSum(masterSecret []byte) []byte {\n-\tif h.version == versionSSL30 {\n-\t\treturn finishedSum30(h.clientMD5, h.clientSHA1, masterSecret, ssl3ClientFinishedMagic)\n+\tif h.version == VersionSSL30 {\n+\t\treturn finishedSum30(h.clientMD5, h.client, masterSecret, ssl3ClientFinishedMagic)\n \t}\n \n-\tmd5 := h.clientMD5.Sum(nil)\n-\tsha1 := h.clientSHA1.Sum(nil)\n-\treturn finishedSum10(md5, sha1, clientFinishedLabel, masterSecret)\n+\tout := make([]byte, finishedVerifyLength)\n+\tif h.version >= VersionTLS12 {\n+\t\tseed := h.client.Sum(nil)\n+\t\tprf12(out, masterSecret, clientFinishedLabel, seed)\n+\t} else {\n+\t\tseed := make([]byte, 0, md5.Size+sha1.Size)\n+\t\tseed = h.clientMD5.Sum(seed)\n+\t\tseed = h.client.Sum(seed)\n+\t\tprf10(out, masterSecret, clientFinishedLabel, seed)\n+\t}\n+\treturn out\n }\n \n // serverSum returns the contents of the verify_data member of a server's\n // Finished message.\n func (h finishedHash) serverSum(masterSecret []byte) []byte {\n-\tif h.version == versionSSL30 {\n-\t\treturn finishedSum30(h.serverMD5, h.serverSHA1, masterSecret, ssl3ServerFinishedMagic)\n+\tif h.version == VersionSSL30 {\n+\t\treturn finishedSum30(h.serverMD5, h.server, masterSecret, ssl3ServerFinishedMagic)\n+\t}\n+\n+\tout := make([]byte, finishedVerifyLength)\n+\tif h.version >= VersionTLS12 {\n+\t\tseed := h.server.Sum(nil)\n+\t\tprf12(out, masterSecret, serverFinishedLabel, seed)\n+\t} else {\n+\t\tseed := make([]byte, 0, md5.Size+sha1.Size)\n+\t\tseed = h.serverMD5.Sum(seed)\n+\t\tseed = h.server.Sum(seed)\n+\t\tprf10(out, masterSecret, serverFinishedLabel, seed)\n+\t}\n+\treturn out\n+}\n+\n+// hashForClientCertificate returns a digest, hash function, and TLS 1.2 hash\n+// id suitable for signing by a TLS client certificate.\n+func (h finishedHash) hashForClientCertificate(sigType uint8) ([]byte, crypto.Hash, uint8) {\n+\tif h.version >= VersionTLS12 {\n+\t\tdigest := h.server.Sum(nil)\n+\t\treturn digest, crypto.SHA256, hashSHA256\n+\t}\n+\tif sigType == signatureECDSA {\n+\t\tdigest := h.server.Sum(nil)\n+\t\treturn digest, crypto.SHA1, hashSHA1\n \t}\n \n-\tmd5 := h.serverMD5.Sum(nil)\n-\tsha1 := h.serverSHA1.Sum(nil)\n-\treturn finishedSum10(md5, sha1, serverFinishedLabel, masterSecret)\n+\tdigest := make([]byte, 0, 36)\n+\tdigest = h.serverMD5.Sum(digest)\n+\tdigest = h.server.Sum(digest)\n+\treturn digest, crypto.MD5SHA1, 0 /* not specified in TLS 1.2. */\n }"}, {"sha": "a9b6c9e4c79d8bc60aff785e161b09d0b5172c9e", "filename": "libgo/go/crypto/tls/prf_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -72,7 +72,7 @@ func TestKeysFromPreMasterSecret(t *testing.T) {\n // These test vectors were generated from GnuTLS using `gnutls-cli --insecure -d 9 `\n var testKeysFromTests = []testKeysFromTest{\n \t{\n-\t\tversionTLS10,\n+\t\tVersionTLS10,\n \t\t\"0302cac83ad4b1db3b9ab49ad05957de2a504a634a386fc600889321e1a971f57479466830ac3e6f468e87f5385fa0c5\",\n \t\t\"4ae66303755184a3917fcb44880605fcc53baa01912b22ed94473fc69cebd558\",\n \t\t\"4ae663020ec16e6bb5130be918cfcafd4d765979a3136a5d50c593446e4e44db\",\n@@ -85,7 +85,7 @@ var testKeysFromTests = []testKeysFromTest{\n \t\t16,\n \t},\n \t{\n-\t\tversionTLS10,\n+\t\tVersionTLS10,\n \t\t\"03023f7527316bc12cbcd69e4b9e8275d62c028f27e65c745cfcddc7ce01bd3570a111378b63848127f1c36e5f9e4890\",\n \t\t\"4ae66364b5ea56b20ce4e25555aed2d7e67f42788dd03f3fee4adae0459ab106\",\n \t\t\"4ae66363ab815cbf6a248b87d6b556184e945e9b97fbdf247858b0bdafacfa1c\",\n@@ -98,7 +98,7 @@ var testKeysFromTests = []testKeysFromTest{\n \t\t16,\n \t},\n \t{\n-\t\tversionTLS10,\n+\t\tVersionTLS10,\n \t\t\"832d515f1d61eebb2be56ba0ef79879efb9b527504abb386fb4310ed5d0e3b1f220d3bb6b455033a2773e6d8bdf951d278a187482b400d45deb88a5d5a6bb7d6a7a1decc04eb9ef0642876cd4a82d374d3b6ff35f0351dc5d411104de431375355addc39bfb1f6329fb163b0bc298d658338930d07d313cd980a7e3d9196cac1\",\n \t\t\"4ae663b2ee389c0de147c509d8f18f5052afc4aaf9699efe8cb05ece883d3a5e\",\n \t\t\"4ae664d503fd4cff50cfc1fb8fc606580f87b0fcdac9554ba0e01d785bdf278e\",\n@@ -111,7 +111,7 @@ var testKeysFromTests = []testKeysFromTest{\n \t\t16,\n \t},\n \t{\n-\t\tversionSSL30,\n+\t\tVersionSSL30,\n \t\t\"832d515f1d61eebb2be56ba0ef79879efb9b527504abb386fb4310ed5d0e3b1f220d3bb6b455033a2773e6d8bdf951d278a187482b400d45deb88a5d5a6bb7d6a7a1decc04eb9ef0642876cd4a82d374d3b6ff35f0351dc5d411104de431375355addc39bfb1f6329fb163b0bc298d658338930d07d313cd980a7e3d9196cac1\",\n \t\t\"4ae663b2ee389c0de147c509d8f18f5052afc4aaf9699efe8cb05ece883d3a5e\",\n \t\t\"4ae664d503fd4cff50cfc1fb8fc606580f87b0fcdac9554ba0e01d785bdf278e\","}, {"sha": "6c67506fc3610aee314b138e7ccad5666684c46b", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package tls partially implements TLS 1.0, as specified in RFC 2246.\n+// Package tls partially implements TLS 1.2, as specified in RFC 5246.\n package tls\n \n import ("}, {"sha": "babe94d41c553e4c5cbf2f395c2a7f5992dab08f", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -25,9 +25,10 @@ func NewCertPool() *CertPool {\n }\n \n // findVerifiedParents attempts to find certificates in s which have signed the\n-// given certificate. If no such certificate can be found or the signature\n-// doesn't match, it returns nil.\n-func (s *CertPool) findVerifiedParents(cert *Certificate) (parents []int) {\n+// given certificate. If any candidates were rejected then errCert will be set\n+// to one of them, arbitrarily, and err will contain the reason that it was\n+// rejected.\n+func (s *CertPool) findVerifiedParents(cert *Certificate) (parents []int, errCert *Certificate, err error) {\n \tif s == nil {\n \t\treturn\n \t}\n@@ -41,8 +42,10 @@ func (s *CertPool) findVerifiedParents(cert *Certificate) (parents []int) {\n \t}\n \n \tfor _, c := range candidates {\n-\t\tif cert.CheckSignatureFrom(s.certs[c]) == nil {\n+\t\tif err = cert.CheckSignatureFrom(s.certs[c]); err == nil {\n \t\t\tparents = append(parents, c)\n+\t\t} else {\n+\t\t\terrCert = s.certs[c]\n \t\t}\n \t}\n "}, {"sha": "acebe3513981aaad060a1d8816c8f2ad93262f03", "filename": "libgo/go/crypto/x509/pkcs1.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -52,7 +52,7 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error) {\n \t}\n \n \tif priv.N.Sign() <= 0 || priv.D.Sign() <= 0 || priv.P.Sign() <= 0 || priv.Q.Sign() <= 0 {\n-\t\treturn nil, errors.New(\"private key contains zero or negative value\")\n+\t\treturn nil, errors.New(\"x509: private key contains zero or negative value\")\n \t}\n \n \tkey = new(rsa.PrivateKey)\n@@ -67,7 +67,7 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error) {\n \tkey.Primes[1] = priv.Q\n \tfor i, a := range priv.AdditionalPrimes {\n \t\tif a.Prime.Sign() <= 0 {\n-\t\t\treturn nil, errors.New(\"private key contains zero or negative prime\")\n+\t\t\treturn nil, errors.New(\"x509: private key contains zero or negative prime\")\n \t\t}\n \t\tkey.Primes[i+2] = a.Prime\n \t\t// We ignore the other two values because rsa will calculate"}, {"sha": "ba19989cba1311bf9efac6b6f259efcf41181d04", "filename": "libgo/go/crypto/x509/pkcs8.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -32,7 +32,7 @@ func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error) {\n \tcase privKey.Algo.Algorithm.Equal(oidPublicKeyRSA):\n \t\tkey, err = ParsePKCS1PrivateKey(privKey.PrivateKey)\n \t\tif err != nil {\n-\t\t\treturn nil, errors.New(\"crypto/x509: failed to parse RSA private key embedded in PKCS#8: \" + err.Error())\n+\t\t\treturn nil, errors.New(\"x509: failed to parse RSA private key embedded in PKCS#8: \" + err.Error())\n \t\t}\n \t\treturn key, nil\n \n@@ -44,11 +44,11 @@ func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error) {\n \t\t}\n \t\tkey, err = parseECPrivateKey(namedCurveOID, privKey.PrivateKey)\n \t\tif err != nil {\n-\t\t\treturn nil, errors.New(\"crypto/x509: failed to parse EC private key embedded in PKCS#8: \" + err.Error())\n+\t\t\treturn nil, errors.New(\"x509: failed to parse EC private key embedded in PKCS#8: \" + err.Error())\n \t\t}\n \t\treturn key, nil\n \n \tdefault:\n-\t\treturn nil, fmt.Errorf(\"crypto/x509: PKCS#8 wrapping contained private key with unknown algorithm: %v\", privKey.Algo.Algorithm)\n+\t\treturn nil, fmt.Errorf(\"x509: PKCS#8 wrapping contained private key with unknown algorithm: %v\", privKey.Algo.Algorithm)\n \t}\n }"}, {"sha": "5034946f7103d38af2d6ba3d57ab1c47fbf5f7b2", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -144,7 +144,7 @@ type CertificateList struct {\n \tSignatureValue     asn1.BitString\n }\n \n-// HasExpired returns true iff now is past the expiry time of certList.\n+// HasExpired reports whether now is past the expiry time of certList.\n func (certList *CertificateList) HasExpired(now time.Time) bool {\n \treturn now.After(certList.TBSCertList.NextUpdate)\n }"}, {"sha": "324f855b135c67bf69b11b0b32c4e47dd6085f1b", "filename": "libgo/go/crypto/x509/root_unix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -2,19 +2,19 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build freebsd linux openbsd netbsd\n+// +build dragonfly freebsd linux openbsd netbsd\n \n package x509\n \n import \"io/ioutil\"\n \n // Possible certificate files; stop after finding one.\n var certFiles = []string{\n-\t\"/etc/ssl/certs/ca-certificates.crt\",     // Linux etc\n+\t\"/etc/ssl/certs/ca-certificates.crt\",     // Debian/Ubuntu/Gentoo etc.\n \t\"/etc/pki/tls/certs/ca-bundle.crt\",       // Fedora/RHEL\n \t\"/etc/ssl/ca-bundle.pem\",                 // OpenSUSE\n \t\"/etc/ssl/cert.pem\",                      // OpenBSD\n-\t\"/usr/local/share/certs/ca-root-nss.crt\", // FreeBSD\n+\t\"/usr/local/share/certs/ca-root-nss.crt\", // FreeBSD/DragonFly\n }\n \n func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {"}, {"sha": "81018b78fe66fabda6475e07d5cc256cf79486ed", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -89,7 +89,7 @@ func checkChainTrustStatus(c *Certificate, chainCtx *syscall.CertChainContext) e\n \t\tcase syscall.CERT_TRUST_IS_NOT_TIME_VALID:\n \t\t\treturn CertificateInvalidError{c, Expired}\n \t\tdefault:\n-\t\t\treturn UnknownAuthorityError{c}\n+\t\t\treturn UnknownAuthorityError{c, nil, nil}\n \t\t}\n \t}\n \treturn nil\n@@ -129,9 +129,9 @@ func checkChainSSLServerPolicy(c *Certificate, chainCtx *syscall.CertChainContex\n \t\tcase syscall.CERT_E_CN_NO_MATCH:\n \t\t\treturn HostnameError{c, opts.DNSName}\n \t\tcase syscall.CERT_E_UNTRUSTEDROOT:\n-\t\t\treturn UnknownAuthorityError{c}\n+\t\t\treturn UnknownAuthorityError{c, nil, nil}\n \t\tdefault:\n-\t\t\treturn UnknownAuthorityError{c}\n+\t\t\treturn UnknownAuthorityError{c, nil, nil}\n \t\t}\n \t}\n "}, {"sha": "7de66754eeb082a0d3984cf571a5e849c53249a3", "filename": "libgo/go/crypto/x509/sec1.go", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -33,17 +33,31 @@ func ParseECPrivateKey(der []byte) (key *ecdsa.PrivateKey, err error) {\n \treturn parseECPrivateKey(nil, der)\n }\n \n+// MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\n+func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error) {\n+\toid, ok := oidFromNamedCurve(key.Curve)\n+\tif !ok {\n+\t\treturn nil, errors.New(\"x509: unknown elliptic curve\")\n+\t}\n+\treturn asn1.Marshal(ecPrivateKey{\n+\t\tVersion:       1,\n+\t\tPrivateKey:    key.D.Bytes(),\n+\t\tNamedCurveOID: oid,\n+\t\tPublicKey:     asn1.BitString{Bytes: elliptic.Marshal(key.Curve, key.X, key.Y)},\n+\t})\n+}\n+\n // parseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n // The OID for the named curve may be provided from another source (such as\n // the PKCS8 container) - if it is provided then use this instead of the OID\n // that may exist in the EC private key structure.\n func parseECPrivateKey(namedCurveOID *asn1.ObjectIdentifier, der []byte) (key *ecdsa.PrivateKey, err error) {\n \tvar privKey ecPrivateKey\n \tif _, err := asn1.Unmarshal(der, &privKey); err != nil {\n-\t\treturn nil, errors.New(\"crypto/x509: failed to parse EC private key: \" + err.Error())\n+\t\treturn nil, errors.New(\"x509: failed to parse EC private key: \" + err.Error())\n \t}\n \tif privKey.Version != ecPrivKeyVersion {\n-\t\treturn nil, fmt.Errorf(\"crypto/x509: unknown EC private key version %d\", privKey.Version)\n+\t\treturn nil, fmt.Errorf(\"x509: unknown EC private key version %d\", privKey.Version)\n \t}\n \n \tvar curve elliptic.Curve\n@@ -53,12 +67,12 @@ func parseECPrivateKey(namedCurveOID *asn1.ObjectIdentifier, der []byte) (key *e\n \t\tcurve = namedCurveFromOID(privKey.NamedCurveOID)\n \t}\n \tif curve == nil {\n-\t\treturn nil, errors.New(\"crypto/x509: unknown elliptic curve\")\n+\t\treturn nil, errors.New(\"x509: unknown elliptic curve\")\n \t}\n \n \tk := new(big.Int).SetBytes(privKey.PrivateKey)\n \tif k.Cmp(curve.Params().N) >= 0 {\n-\t\treturn nil, errors.New(\"crypto/x509: invalid elliptic curve private key value\")\n+\t\treturn nil, errors.New(\"x509: invalid elliptic curve private key value\")\n \t}\n \tpriv := new(ecdsa.PrivateKey)\n \tpriv.Curve = curve"}, {"sha": "95f18e77de0e4d58aaa10e98d42b8c3657029c28", "filename": "libgo/go/crypto/x509/sec1_test.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -5,6 +5,7 @@\n package x509\n \n import (\n+\t\"bytes\"\n \t\"encoding/hex\"\n \t\"testing\"\n )\n@@ -15,8 +16,15 @@ var ecPrivateKeyHex = `3081a40201010430bdb9839c08ee793d1157886a7a758a3c8b2a17a4d\n \n func TestParseECPrivateKey(t *testing.T) {\n \tderBytes, _ := hex.DecodeString(ecPrivateKeyHex)\n-\t_, err := ParseECPrivateKey(derBytes)\n+\tkey, err := ParseECPrivateKey(derBytes)\n \tif err != nil {\n \t\tt.Errorf(\"failed to decode EC private key: %s\", err)\n \t}\n+\tserialized, err := MarshalECPrivateKey(key)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to encode EC private key: %s\", err)\n+\t}\n+\tif !bytes.Equal(serialized, derBytes) {\n+\t\tt.Fatalf(\"serialized key differs: got %x, want %x\", serialized, derBytes)\n+\t}\n }"}, {"sha": "8327463ca867aa6ea17e072d3d9f1ee1bbbe7ca4", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -5,6 +5,7 @@\n package x509\n \n import (\n+\t\"fmt\"\n \t\"net\"\n \t\"runtime\"\n \t\"strings\"\n@@ -91,10 +92,27 @@ func (h HostnameError) Error() string {\n // UnknownAuthorityError results when the certificate issuer is unknown\n type UnknownAuthorityError struct {\n \tcert *Certificate\n+\t// hintErr contains an error that may be helpful in determining why an\n+\t// authority wasn't found.\n+\thintErr error\n+\t// hintCert contains a possible authority certificate that was rejected\n+\t// because of the error in hintErr.\n+\thintCert *Certificate\n }\n \n func (e UnknownAuthorityError) Error() string {\n-\treturn \"x509: certificate signed by unknown authority\"\n+\ts := \"x509: certificate signed by unknown authority\"\n+\tif e.hintErr != nil {\n+\t\tcertName := e.hintCert.Subject.CommonName\n+\t\tif len(certName) == 0 {\n+\t\t\tif len(e.hintCert.Subject.Organization) > 0 {\n+\t\t\t\tcertName = e.hintCert.Subject.Organization[0]\n+\t\t\t}\n+\t\t\tcertName = \"serial:\" + e.hintCert.SerialNumber.String()\n+\t\t}\n+\t\ts += fmt.Sprintf(\" (possibly because of %q while trying to verify candidate authority certificate %q)\", e.hintErr, certName)\n+\t}\n+\treturn s\n }\n \n // SystemRootsError results when we fail to load the system root certificates.\n@@ -136,14 +154,18 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n \t}\n \n \tif len(c.PermittedDNSDomains) > 0 {\n+\t\tok := false\n \t\tfor _, domain := range c.PermittedDNSDomains {\n \t\t\tif opts.DNSName == domain ||\n \t\t\t\t(strings.HasSuffix(opts.DNSName, domain) &&\n \t\t\t\t\tlen(opts.DNSName) >= 1+len(domain) &&\n \t\t\t\t\topts.DNSName[len(opts.DNSName)-len(domain)-1] == '.') {\n-\t\t\t\tcontinue\n+\t\t\t\tok = true\n+\t\t\t\tbreak\n \t\t\t}\n+\t\t}\n \n+\t\tif !ok {\n \t\t\treturn CertificateInvalidError{c, CANotAuthorizedForThisName}\n \t\t}\n \t}\n@@ -249,7 +271,8 @@ func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate\n }\n \n func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain []*Certificate, opts *VerifyOptions) (chains [][]*Certificate, err error) {\n-\tfor _, rootNum := range opts.Roots.findVerifiedParents(c) {\n+\tpossibleRoots, failedRoot, rootErr := opts.Roots.findVerifiedParents(c)\n+\tfor _, rootNum := range possibleRoots {\n \t\troot := opts.Roots.certs[rootNum]\n \t\terr = root.isValid(rootCertificate, currentChain, opts)\n \t\tif err != nil {\n@@ -258,8 +281,9 @@ func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain [\n \t\tchains = append(chains, appendToFreshChain(currentChain, root))\n \t}\n \n+\tpossibleIntermediates, failedIntermediate, intermediateErr := opts.Intermediates.findVerifiedParents(c)\n nextIntermediate:\n-\tfor _, intermediateNum := range opts.Intermediates.findVerifiedParents(c) {\n+\tfor _, intermediateNum := range possibleIntermediates {\n \t\tintermediate := opts.Intermediates.certs[intermediateNum]\n \t\tfor _, cert := range currentChain {\n \t\t\tif cert == intermediate {\n@@ -284,7 +308,13 @@ nextIntermediate:\n \t}\n \n \tif len(chains) == 0 && err == nil {\n-\t\terr = UnknownAuthorityError{c}\n+\t\thintErr := rootErr\n+\t\thintCert := failedRoot\n+\t\tif hintErr == nil {\n+\t\t\thintErr = intermediateErr\n+\t\t\thintCert = failedIntermediate\n+\t\t}\n+\t\terr = UnknownAuthorityError{c, hintErr, hintCert}\n \t}\n \n \treturn"}, {"sha": "ba6c13d45102e666a3debb96a76bbb581b7a684f", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -126,6 +126,18 @@ var verifyTests = []verifyTest{\n \t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\", \"StartCom Certification Authority\"},\n \t\t},\n \t},\n+\t{\n+\t\tleaf:          googleLeafWithInvalidHash,\n+\t\tintermediates: []string{thawteIntermediate},\n+\t\troots:         []string{verisignRoot},\n+\t\tcurrentTime:   1302726541,\n+\t\tdnsName:       \"www.google.com\",\n+\n+\t\t// The specific error message may not occur when using system\n+\t\t// verification.\n+\t\tsystemSkip:    true,\n+\t\terrorCallback: expectHashError,\n+\t},\n \t{\n \t\t// The default configuration should reject an S/MIME chain.\n \t\tleaf:        smimeLeaf,\n@@ -171,6 +183,24 @@ var verifyTests = []verifyTest{\n \t\t\t{\"mega.co.nz\", \"EssentialSSL CA\", \"COMODO Certification Authority\"},\n \t\t},\n \t},\n+\t{\n+\t\t// Check that a name constrained intermediate works even when\n+\t\t// it lists multiple constraints.\n+\t\tleaf:          nameConstraintsLeaf,\n+\t\tintermediates: []string{nameConstraintsIntermediate1, nameConstraintsIntermediate2},\n+\t\troots:         []string{globalSignRoot},\n+\t\tcurrentTime:   1382387896,\n+\t\tdnsName:       \"secure.iddl.vt.edu\",\n+\n+\t\texpectedChains: [][]string{\n+\t\t\t{\n+\t\t\t\t\"Technology-enhanced Learning and Online Strategies\",\n+\t\t\t\t\"Virginia Tech Global Qualified Server CA\",\n+\t\t\t\t\"Trusted Root CA G2\",\n+\t\t\t\t\"GlobalSign Root CA\",\n+\t\t\t},\n+\t\t},\n+\t},\n }\n \n func expectHostnameError(t *testing.T, i int, err error) (ok bool) {\n@@ -213,6 +243,18 @@ func expectSystemRootsError(t *testing.T, i int, err error) bool {\n \treturn true\n }\n \n+func expectHashError(t *testing.T, i int, err error) bool {\n+\tif err == nil {\n+\t\tt.Errorf(\"#%d: no error resulted from invalid hash\", i)\n+\t\treturn false\n+\t}\n+\tif expected := \"algorithm unimplemented\"; !strings.Contains(err.Error(), expected) {\n+\t\tt.Errorf(\"#%d: error resulting from invalid hash didn't contain '%s', rather it was: %s\", i, expected, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n func certificateFromPEM(pemBytes string) (*Certificate, error) {\n \tblock, _ := pem.Decode([]byte(pemBytes))\n \tif block == nil {\n@@ -400,6 +442,28 @@ u2ONgJd8IyAPkU0Wueru9G2Jysa9zCRo1kNbzipYvzwY4OA8Ys+WAi0oR1A04Se6\n z5nRUP8pJcA2NhUzUnC+MY+f6H/nEQyNv4SgQhqAibAxWEEHXw==\n -----END CERTIFICATE-----`\n \n+// googleLeafWithInvalidHash is the same as googleLeaf, but the signature\n+// algorithm in the certificate contains a nonsense OID.\n+const googleLeafWithInvalidHash = `-----BEGIN CERTIFICATE-----\n+MIIDITCCAoqgAwIBAgIQL9+89q6RUm0PmqPfQDQ+mjANBgkqhkiG9w0BATIFADBM\n+MQswCQYDVQQGEwJaQTElMCMGA1UEChMcVGhhd3RlIENvbnN1bHRpbmcgKFB0eSkg\n+THRkLjEWMBQGA1UEAxMNVGhhd3RlIFNHQyBDQTAeFw0wOTEyMTgwMDAwMDBaFw0x\n+MTEyMTgyMzU5NTlaMGgxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlh\n+MRYwFAYDVQQHFA1Nb3VudGFpbiBWaWV3MRMwEQYDVQQKFApHb29nbGUgSW5jMRcw\n+FQYDVQQDFA53d3cuZ29vZ2xlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkC\n+gYEA6PmGD5D6htffvXImttdEAoN4c9kCKO+IRTn7EOh8rqk41XXGOOsKFQebg+jN\n+gtXj9xVoRaELGYW84u+E593y17iYwqG7tcFR39SDAqc9BkJb4SLD3muFXxzW2k6L\n+05vuuWciKh0R73mkszeK9P4Y/bz5RiNQl/Os/CRGK1w7t0UCAwEAAaOB5zCB5DAM\n+BgNVHRMBAf8EAjAAMDYGA1UdHwQvMC0wK6ApoCeGJWh0dHA6Ly9jcmwudGhhd3Rl\n+LmNvbS9UaGF3dGVTR0NDQS5jcmwwKAYDVR0lBCEwHwYIKwYBBQUHAwEGCCsGAQUF\n+BwMCBglghkgBhvhCBAEwcgYIKwYBBQUHAQEEZjBkMCIGCCsGAQUFBzABhhZodHRw\n+Oi8vb2NzcC50aGF3dGUuY29tMD4GCCsGAQUFBzAChjJodHRwOi8vd3d3LnRoYXd0\n+ZS5jb20vcmVwb3NpdG9yeS9UaGF3dGVfU0dDX0NBLmNydDANBgkqhkiG9w0BAVAF\n+AAOBgQCfQ89bxFApsb/isJr/aiEdLRLDLE5a+RLizrmCUi3nHX4adpaQedEkUjh5\n+u2ONgJd8IyAPkU0Wueru9G2Jysa9zCRo1kNbzipYvzwY4OA8Ys+WAi0oR1A04Se6\n+z5nRUP8pJcA2NhUzUnC+MY+f6H/nEQyNv4SgQhqAibAxWEEHXw==\n+-----END CERTIFICATE-----`\n+\n const dnssecExpLeaf = `-----BEGIN CERTIFICATE-----\n MIIGzTCCBbWgAwIBAgIDAdD6MA0GCSqGSIb3DQEBBQUAMIGMMQswCQYDVQQGEwJJ\n TDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0\n@@ -522,6 +586,50 @@ um0ABj6y6koQOdjQK/W/7HW/lwLFCRsI3FU34oH7N4RDYiDK51ZLZer+bMEkkySh\n NOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14=\n -----END CERTIFICATE-----`\n \n+const startComRootSHA256 = `-----BEGIN CERTIFICATE-----\n+MIIHhzCCBW+gAwIBAgIBLTANBgkqhkiG9w0BAQsFADB9MQswCQYDVQQGEwJJTDEW\n+MBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwg\n+Q2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNh\n+dGlvbiBBdXRob3JpdHkwHhcNMDYwOTE3MTk0NjM3WhcNMzYwOTE3MTk0NjM2WjB9\n+MQswCQYDVQQGEwJJTDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMi\n+U2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3Rh\n+cnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\n+A4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul38kMKogZk\n+pMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf\n+OQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/C\n+Ji/6tRYccjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYT\n+Kqi5pquDSR3l8u/d5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNi\n+HzvEvqBTViVsUQn3qqvKv3b9bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMM\n+Av+Z6+hsTXBbKWWc3apdzK8BMewM69KN6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w\n++2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHuEhANxjJ/GP/89PrNbpHoNkm+\n+Gkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZPV/+Qt+OR0t3vwmC3\n+Zzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOzEmDyei+B\n+26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID\n+AQABo4ICEDCCAgwwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD\n+VR0OBBYEFE4L7xqkQFulF2mHMMo0aEPQQa7yMB8GA1UdIwQYMBaAFE4L7xqkQFul\n+F2mHMMo0aEPQQa7yMIIBWgYDVR0gBIIBUTCCAU0wggFJBgsrBgEEAYG1NwEBATCC\n+ATgwLgYIKwYBBQUHAgEWImh0dHA6Ly93d3cuc3RhcnRzc2wuY29tL3BvbGljeS5w\n+ZGYwNAYIKwYBBQUHAgEWKGh0dHA6Ly93d3cuc3RhcnRzc2wuY29tL2ludGVybWVk\n+aWF0ZS5wZGYwgc8GCCsGAQUFBwICMIHCMCcWIFN0YXJ0IENvbW1lcmNpYWwgKFN0\n+YXJ0Q29tKSBMdGQuMAMCAQEagZZMaW1pdGVkIExpYWJpbGl0eSwgcmVhZCB0aGUg\n+c2VjdGlvbiAqTGVnYWwgTGltaXRhdGlvbnMqIG9mIHRoZSBTdGFydENvbSBDZXJ0\n+aWZpY2F0aW9uIEF1dGhvcml0eSBQb2xpY3kgYXZhaWxhYmxlIGF0IGh0dHA6Ly93\n+d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYwEQYJYIZIAYb4QgEBBAQDAgAHMDgG\n+CWCGSAGG+EIBDQQrFilTdGFydENvbSBGcmVlIFNTTCBDZXJ0aWZpY2F0aW9uIEF1\n+dGhvcml0eTANBgkqhkiG9w0BAQsFAAOCAgEAjo/n3JR5fPGFf59Jb2vKXfuM/gTF\n+wWLRfUKKvFO3lANmMD+x5wqnUCBVJX92ehQN6wQOQOY+2IirByeDqXWmN3PH/UvS\n+Ta0XQMhGvjt/UfzDtgUx3M2FIk5xt/JxXrAaxrqTi3iSSoX4eA+D/i+tLPfkpLst\n+0OcNOrg+zvZ49q5HJMqjNTbOx8aHmNrs++myziebiMMEofYLWWivydsQD032ZGNc\n+pRJvkrKTlMeIFw6Ttn5ii5B/q06f/ON1FE8qMt9bDeD1e5MNq6HPh+GlBEXoPBKl\n+CcWw0bdT82AUuoVpaiF8H3VhFyAXe2w7QSlc4axa0c2Mm+tgHRns9+Ww2vl5GKVF\n+P0lDV9LdJNUso/2RjSe15esUBppMeyG7Oq0wBhjA2MFrLH9ZXF2RsXAiV+uKa0hK\n+1Q8p7MZAwC+ITGgBF3f0JBlPvfrhsiAhS90a2Cl9qrjeVOwhVYBsHvUwyKMQ5bLm\n+KhQxw4UtjJixhlpPiVktucf3HMiKf8CdBUrmQk9io20ppB+Fq9vlgcitKj1MXVuE\n+JnHEhV5xJMqlG2zYYdMa4FTbzrqpMrUi9nNBCV24F10OD5mQ1kfabwo6YigUZ4LZ\n+8dCAWZvLMdibD4x3TrVoivJs9iQOLWxwxXPR3hTQcY+203sC9uO41Alua551hDnm\n+fyWl8kgAwKQB2j8=\n+-----END CERTIFICATE-----`\n+\n const smimeLeaf = `-----BEGIN CERTIFICATE-----\n MIIFBjCCA+6gAwIBAgISESFvrjT8XcJTEe6rBlPptILlMA0GCSqGSIb3DQEBBQUA\n MFQxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMSowKAYD\n@@ -663,3 +771,168 @@ zJVSk/BwJVmcIGfE7vmLV2H0knZ9P4SNVbfo5azV8fUZVqZa+5Acr5Pr5RzUZ5dd\n BA6+C4OmF4O5MBKgxTMVBbkN+8cFduPYSo38NBejxiEovjBFMR7HeL5YYTisO+IB\n ZQ==\n -----END CERTIFICATE-----`\n+\n+var nameConstraintsLeaf = `-----BEGIN CERTIFICATE-----\n+MIIHMTCCBRmgAwIBAgIIIZaV/3ezOJkwDQYJKoZIhvcNAQEFBQAwgcsxCzAJBgNV\n+BAYTAlVTMREwDwYDVQQIEwhWaXJnaW5pYTETMBEGA1UEBxMKQmxhY2tzYnVyZzEj\n+MCEGA1UECxMaR2xvYmFsIFF1YWxpZmllZCBTZXJ2ZXIgQ0ExPDA6BgNVBAoTM1Zp\n+cmdpbmlhIFBvbHl0ZWNobmljIEluc3RpdHV0ZSBhbmQgU3RhdGUgVW5pdmVyc2l0\n+eTExMC8GA1UEAxMoVmlyZ2luaWEgVGVjaCBHbG9iYWwgUXVhbGlmaWVkIFNlcnZl\n+ciBDQTAeFw0xMzA5MTkxNDM2NTVaFw0xNTA5MTkxNDM2NTVaMIHNMQswCQYDVQQG\n+EwJVUzERMA8GA1UECAwIVmlyZ2luaWExEzARBgNVBAcMCkJsYWNrc2J1cmcxPDA6\n+BgNVBAoMM1ZpcmdpbmlhIFBvbHl0ZWNobmljIEluc3RpdHV0ZSBhbmQgU3RhdGUg\n+VW5pdmVyc2l0eTE7MDkGA1UECwwyVGVjaG5vbG9neS1lbmhhbmNlZCBMZWFybmlu\n+ZyBhbmQgT25saW5lIFN0cmF0ZWdpZXMxGzAZBgNVBAMMEnNlY3VyZS5pZGRsLnZ0\n+LmVkdTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKkOyPpsOK/6IuPG\n+WnIBlVwlHzeYf+cUlggqkLq0b0+vZbiTXgio9/VCuNQ8opSoss7J7o3ygV9to+9Y\n+YwJKVC5WDT/y5JWpQey0CWILymViJnpNSwnxBc8A+Q8w5NUGDd/UhtPx/U8/hqbd\n+WPDYj2hbOqyq8UlRhfS5pwtnv6BbCTaY11I6FhCLK7zttISyTuWCf9p9o/ggiipP\n+ii/5oh4dkl+r5SfuSp5GPNHlYO8lWqys5NAPoDD4fc/kuflcK7Exx7XJ+Oqu0W0/\n+psjEY/tES1ZgDWU/ParcxxFpFmKHbD5DXsfPOObzkVWXIY6tGMutSlE1Froy/Nn0\n+OZsAOrcCAwEAAaOCAhMwggIPMIG4BggrBgEFBQcBAQSBqzCBqDBYBggrBgEFBQcw\n+AoZMaHR0cDovL3d3dy5wa2kudnQuZWR1L2dsb2JhbHF1YWxpZmllZHNlcnZlci9j\n+YWNlcnQvZ2xvYmFscXVhbGlmaWVkc2VydmVyLmNydDBMBggrBgEFBQcwAYZAaHR0\n+cDovL3Z0Y2EtcC5lcHJvdi5zZXRpLnZ0LmVkdTo4MDgwL2VqYmNhL3B1YmxpY3dl\n+Yi9zdGF0dXMvb2NzcDAdBgNVHQ4EFgQUp7xbO6iHkvtZbPE4jmndmnAbSEcwDAYD\n+VR0TAQH/BAIwADAfBgNVHSMEGDAWgBS8YmAn1eM1SBfpS6tFatDIqHdxjDBqBgNV\n+HSAEYzBhMA4GDCsGAQQBtGgFAgICATAOBgwrBgEEAbRoBQICAQEwPwYMKwYBBAG0\n+aAUCAgMBMC8wLQYIKwYBBQUHAgEWIWh0dHA6Ly93d3cucGtpLnZ0LmVkdS9nbG9i\n+YWwvY3BzLzBKBgNVHR8EQzBBMD+gPaA7hjlodHRwOi8vd3d3LnBraS52dC5lZHUv\n+Z2xvYmFscXVhbGlmaWVkc2VydmVyL2NybC9jYWNybC5jcmwwDgYDVR0PAQH/BAQD\n+AgTwMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNVHREEFjAUghJz\n+ZWN1cmUuaWRkbC52dC5lZHUwDQYJKoZIhvcNAQEFBQADggIBAEgoYo4aUtatY3gI\n+OyyKp7QlIOaLbTJZywESHqy+L5EGDdJW2DJV+mcE0LDGvqa2/1Lo+AR1ntsZwfOi\n+Y718JwgVVaX/RCd5+QKP25c5/x72xI8hb/L1bgS0ED9b0YAhd7Qm1K1ot82+6mqX\n+DW6WiGeDr8Z07MQ3143qQe2rBlq+QI69DYzm2GOqAIAnUIWv7tCyLUm31b4DwmrJ\n+TeudVreTKUbBNB1TWRFHEPkWhjjXKZnNGRO11wHXcyBu6YekIvVZ+vmx8ePee4jJ\n+3GFOi7lMuWOeq57jTVL7KOKaKLVXBb6gqo5aq+Wwt8RUD5MakrCAEeQZj7DKaFmZ\n+oQCO0Pxrsl3InCGvxnGzT+bFVO9nJ/BAMj7hknFdm9Jr6Bg5q33Z+gnf909AD9QF\n+ESqUSykaHu2LVdJx2MaCH1CyKnRgMw5tEwE15EXpUjCm24m8FMOYC+rNtf18pgrz\n+5D8Jhh+oxK9PjcBYqXNtnioIxiMCYcV0q5d4w4BYFEh71tk7/bYB0R55CsBUVPmp\n+timWNOdRd57Tfpk3USaVsumWZAf9MP3wPiC7gb4d5tYEEAG5BuDT8ruFw838wU8G\n+1VvAVutSiYBg7k3NYO7AUqZ+Ax4klQX3aM9lgonmJ78Qt94UPtbptrfZ4/lSqEf8\n+GBUwDrQNTb+gsXsDkjd5lcYxNx6l\n+-----END CERTIFICATE-----`\n+\n+var nameConstraintsIntermediate1 = `-----BEGIN CERTIFICATE-----\n+MIINLjCCDBagAwIBAgIRIqpyf/YoGgvHc8HiDAxAI8owDQYJKoZIhvcNAQEFBQAw\n+XDELMAkGA1UEBhMCQkUxFTATBgNVBAsTDFRydXN0ZWQgUm9vdDEZMBcGA1UEChMQ\n+R2xvYmFsU2lnbiBudi1zYTEbMBkGA1UEAxMSVHJ1c3RlZCBSb290IENBIEcyMB4X\n+DTEyMTIxMzAwMDAwMFoXDTE3MTIxMzAwMDAwMFowgcsxCzAJBgNVBAYTAlVTMREw\n+DwYDVQQIEwhWaXJnaW5pYTETMBEGA1UEBxMKQmxhY2tzYnVyZzEjMCEGA1UECxMa\n+R2xvYmFsIFF1YWxpZmllZCBTZXJ2ZXIgQ0ExPDA6BgNVBAoTM1ZpcmdpbmlhIFBv\n+bHl0ZWNobmljIEluc3RpdHV0ZSBhbmQgU3RhdGUgVW5pdmVyc2l0eTExMC8GA1UE\n+AxMoVmlyZ2luaWEgVGVjaCBHbG9iYWwgUXVhbGlmaWVkIFNlcnZlciBDQTCCAiIw\n+DQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALgIZhEaptBWADBqdJ45ueFGzMXa\n+GHnzNxoxR1fQIaaRQNdCg4cw3A4dWKMeEgYLtsp65ai3Xfw62Qaus0+KJ3RhgV+r\n+ihqK81NUzkls78fJlADVDI4fCTlothsrE1CTOMiy97jKHai5mVTiWxmcxpmjv7fm\n+5Nhc+uHgh2hIz6npryq495mD51ZrUTIaqAQN6Pw/VHfAmR524vgriTOjtp1t4lA9\n+pXGWjF/vkhAKFFheOQSQ00rngo2wHgCqMla64UTN0oz70AsCYNZ3jDLx0kOP0YmM\n+R3Ih91VA63kLqPXA0R6yxmmhhxLZ5bcyAy1SLjr1N302MIxLM/pSy6aquEnbELhz\n+qyp9yGgRyGJay96QH7c4RJY6gtcoPDbldDcHI9nXngdAL4DrZkJ9OkDkJLyqG66W\n+ZTF5q4EIs6yMdrywz0x7QP+OXPJrjYpbeFs6tGZCFnWPFfmHCRJF8/unofYrheq+\n+9J7Jx3U55S/k57NXbAM1RAJOuMTlfn9Etf9Dpoac9poI4Liav6rBoUQk3N3JWqnV\n+HNx/NdCyJ1/6UbKMJUZsStAVglsi6lVPo289HHOE4f7iwl3SyekizVOp01wUin3y\n+cnbZB/rXmZbwapSxTTSBf0EIOr9i4EGfnnhCAVA9U5uLrI5OEB69IY8PNX0071s3\n+Z2a2fio5c8m3JkdrAgMBAAGjggh5MIIIdTAOBgNVHQ8BAf8EBAMCAQYwTAYDVR0g\n+BEUwQzBBBgkrBgEEAaAyATwwNDAyBggrBgEFBQcCARYmaHR0cHM6Ly93d3cuZ2xv\n+YmFsc2lnbi5jb20vcmVwb3NpdG9yeS8wEgYDVR0TAQH/BAgwBgEB/wIBADCCBtAG\n+A1UdHgSCBscwggbDoIIGvzASghAzZGJsYWNrc2J1cmcub3JnMBiCFmFjY2VsZXJh\n+dGV2aXJnaW5pYS5jb20wGIIWYWNjZWxlcmF0ZXZpcmdpbmlhLm9yZzALgglhY3Zj\n+cC5vcmcwCYIHYmV2Lm5ldDAJggdiZXYub3JnMAuCCWNsaWdzLm9yZzAMggpjbWl3\n+ZWIub3JnMBeCFWVhc3Rlcm5icm9va3Ryb3V0Lm5ldDAXghVlYXN0ZXJuYnJvb2t0\n+cm91dC5vcmcwEYIPZWNvcnJpZG9ycy5pbmZvMBOCEWVkZ2FycmVzZWFyY2gub3Jn\n+MBKCEGdldC1lZHVjYXRlZC5jb20wE4IRZ2V0LWVkdWNhdGVkLmluZm8wEYIPZ2V0\n+ZWR1Y2F0ZWQubmV0MBKCEGdldC1lZHVjYXRlZC5uZXQwEYIPZ2V0ZWR1Y2F0ZWQu\n+b3JnMBKCEGdldC1lZHVjYXRlZC5vcmcwD4INaG9raWVjbHViLmNvbTAQgg5ob2tp\n+ZXBob3RvLmNvbTAPgg1ob2tpZXNob3AuY29tMBGCD2hva2llc3BvcnRzLmNvbTAS\n+ghBob2tpZXRpY2tldHMuY29tMBKCEGhvdGVscm9hbm9rZS5jb20wE4IRaHVtYW53\n+aWxkbGlmZS5vcmcwF4IVaW5uYXR2aXJnaW5pYXRlY2guY29tMA+CDWlzY2hwMjAx\n+MS5vcmcwD4INbGFuZHJlaGFiLm9yZzAggh5uYXRpb25hbHRpcmVyZXNlYXJjaGNl\n+bnRlci5jb20wFYITbmV0d29ya3ZpcmdpbmlhLm5ldDAMggpwZHJjdnQuY29tMBiC\n+FnBldGVkeWVyaXZlcmNvdXJzZS5jb20wDYILcmFkaW9pcS5vcmcwFYITcml2ZXJj\n+b3Vyc2Vnb2xmLmNvbTALgglzZGltaS5vcmcwEIIOc292YW1vdGlvbi5jb20wHoIc\n+c3VzdGFpbmFibGUtYmlvbWF0ZXJpYWxzLmNvbTAeghxzdXN0YWluYWJsZS1iaW9t\n+YXRlcmlhbHMub3JnMBWCE3RoaXNpc3RoZWZ1dHVyZS5jb20wGIIWdGhpcy1pcy10\n+aGUtZnV0dXJlLmNvbTAVghN0aGlzaXN0aGVmdXR1cmUubmV0MBiCFnRoaXMtaXMt\n+dGhlLWZ1dHVyZS5uZXQwCoIIdmFkcy5vcmcwDIIKdmFsZWFmLm9yZzANggt2YXRl\n+Y2guaW5mbzANggt2YXRlY2gubW9iaTAcghp2YXRlY2hsaWZlbG9uZ2xlYXJuaW5n\n+LmNvbTAcghp2YXRlY2hsaWZlbG9uZ2xlYXJuaW5nLm5ldDAcghp2YXRlY2hsaWZl\n+bG9uZ2xlYXJuaW5nLm9yZzAKggh2Y29tLmVkdTASghB2aXJnaW5pYXZpZXcubmV0\n+MDSCMnZpcmdpbmlhcG9seXRlY2huaWNpbnN0aXR1dGVhbmRzdGF0ZXVuaXZlcnNp\n+dHkuY29tMDWCM3ZpcmdpbmlhcG9seXRlY2huaWNpbnN0aXR1dGVhbmRzdGF0ZXVu\n+aXZlcnNpdHkuaW5mbzA0gjJ2aXJnaW5pYXBvbHl0ZWNobmljaW5zdGl0dXRlYW5k\n+c3RhdGV1bml2ZXJzaXR5Lm5ldDA0gjJ2aXJnaW5pYXBvbHl0ZWNobmljaW5zdGl0\n+dXRlYW5kc3RhdGV1bml2ZXJzaXR5Lm9yZzAZghd2aXJnaW5pYXB1YmxpY3JhZGlv\n+Lm9yZzASghB2aXJnaW5pYXRlY2guZWR1MBOCEXZpcmdpbmlhdGVjaC5tb2JpMByC\n+GnZpcmdpbmlhdGVjaGZvdW5kYXRpb24ub3JnMAiCBnZ0LmVkdTALggl2dGFyYy5v\n+cmcwDIIKdnQtYXJjLm9yZzALggl2dGNyYy5jb20wCoIIdnRpcC5vcmcwDIIKdnRs\n+ZWFuLm9yZzAWghR2dGtub3dsZWRnZXdvcmtzLmNvbTAYghZ2dGxpZmVsb25nbGVh\n+cm5pbmcuY29tMBiCFnZ0bGlmZWxvbmdsZWFybmluZy5uZXQwGIIWdnRsaWZlbG9u\n+Z2xlYXJuaW5nLm9yZzATghF2dHNwb3J0c21lZGlhLmNvbTALggl2dHdlaS5jb20w\n+D4INd2l3YXR3ZXJjLmNvbTAKggh3dnRmLm9yZzAIgQZ2dC5lZHUwd6R1MHMxCzAJ\n+BgNVBAYTAlVTMREwDwYDVQQIEwhWaXJnaW5pYTETMBEGA1UEBxMKQmxhY2tzYnVy\n+ZzE8MDoGA1UEChMzVmlyZ2luaWEgUG9seXRlY2huaWMgSW5zdGl0dXRlIGFuZCBT\n+dGF0ZSBVbml2ZXJzaXR5MCcGA1UdJQQgMB4GCCsGAQUFBwMCBggrBgEFBQcDAQYI\n+KwYBBQUHAwkwPQYDVR0fBDYwNDAyoDCgLoYsaHR0cDovL2NybC5nbG9iYWxzaWdu\n+LmNvbS9ncy90cnVzdHJvb3RnMi5jcmwwgYQGCCsGAQUFBwEBBHgwdjAzBggrBgEF\n+BQcwAYYnaHR0cDovL29jc3AyLmdsb2JhbHNpZ24uY29tL3RydXN0cm9vdGcyMD8G\n+CCsGAQUFBzAChjNodHRwOi8vc2VjdXJlLmdsb2JhbHNpZ24uY29tL2NhY2VydC90\n+cnVzdHJvb3RnMi5jcnQwHQYDVR0OBBYEFLxiYCfV4zVIF+lLq0Vq0Miod3GMMB8G\n+A1UdIwQYMBaAFBT25YsxtkWASkxt/MKHico2w5BiMA0GCSqGSIb3DQEBBQUAA4IB\n+AQAyJm/lOB2Er4tHXhc/+fSufSzgjohJgYfMkvG4LknkvnZ1BjliefR8tTXX49d2\n+SCDFWfGjqyJZwavavkl/4p3oXPG/nAMDMvxh4YAT+CfEK9HH+6ICV087kD4BLegi\n++aFJMj8MMdReWCzn5sLnSR1rdse2mo2arX3Uod14SW+PGrbUmTuWNyvRbz3fVmxp\n+UdbGmj3laknO9YPsBGgHfv73pVVsTJkW4ZfY/7KdD/yaVv6ophpOB3coXfjl2+kd\n+Z4ypn2zK+cx9IL/LSewqd/7W9cD55PCUy4X9OTbEmAccwiz3LB66mQoUGfdHdkoB\n+jUY+v9vLQXmaVwI0AYL7g9LN\n+-----END CERTIFICATE-----`\n+\n+var nameConstraintsIntermediate2 = `-----BEGIN CERTIFICATE-----\n+MIIEXTCCA0WgAwIBAgILBAAAAAABNuk6OrMwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n+A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n+b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw0xMjA0MjUxMTAw\n+MDBaFw0yNzA0MjUxMTAwMDBaMFwxCzAJBgNVBAYTAkJFMRUwEwYDVQQLEwxUcnVz\n+dGVkIFJvb3QxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExGzAZBgNVBAMTElRy\n+dXN0ZWQgUm9vdCBDQSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\n+AKyuvqrtcMr7g7EuNbu4sKwxM127UsCmx1RxbxxgcArGS7rjiefpBH/w4LYrymjf\n+vcw1ueyMNoqLo9nJMz/ORXupb35NNfE667prQYHa+tTjl1IiKpB7QUwt3wXPuTMF\n+Ja1tXtjKzkqJyuJlNuPKT76HcjgNqgV1s9qG44MD5I2JvI12du8zI1bgdQ+l/KsX\n+kTfbGjUvhOLOlVNWVQDpL+YMIrGqgBYxy5TUNgrAcRtwpNdS2KkF5otSmMweVb5k\n+hoUVv3u8UxQH/WWbNhHq1RrIlg/0rBUfi/ziShYFSB7U+aLx5DxPphTFBiDquQGp\n+tB+FC4JvnukDStFihZCZ1R8CAwEAAaOCASMwggEfMA4GA1UdDwEB/wQEAwIBBjAP\n+BgNVHRMBAf8EBTADAQH/MEcGA1UdIARAMD4wPAYEVR0gADA0MDIGCCsGAQUFBwIB\n+FiZodHRwczovL3d3dy5nbG9iYWxzaWduLmNvbS9yZXBvc2l0b3J5LzAdBgNVHQ4E\n+FgQUFPblizG2RYBKTG38woeJyjbDkGIwMwYDVR0fBCwwKjAooCagJIYiaHR0cDov\n+L2NybC5nbG9iYWxzaWduLm5ldC9yb290LmNybDA+BggrBgEFBQcBAQQyMDAwLgYI\n+KwYBBQUHMAGGImh0dHA6Ly9vY3NwMi5nbG9iYWxzaWduLmNvbS9yb290cjEwHwYD\n+VR0jBBgwFoAUYHtmGkUNl8qJUC99BM00qP/8/UswDQYJKoZIhvcNAQEFBQADggEB\n+AL7IG0l+k4LkcpI+a/kvZsSRwSM4uA6zGX34e78A2oytr8RG8bJwVb8+AHMUD+Xe\n+2kYdh/Uj/waQXfqR0OgxQXL9Ct4ZM+JlR1avsNKXWL5AwYXAXCOB3J5PW2XOck7H\n+Zw0vRbGQhjWjQx+B4KOUFg1b3ov/z6Xkr3yaCfRQhXh7KC0Bc0RXPPG5Nv5lCW+z\n+tbbg0zMm3kyfQITRusMSg6IBsDJqOnjaiaKQRcXiD0Sk43ZXb2bUKMxC7+Td3QL4\n+RyHcWJbQ7YylLTS/x+jxWIcOQ0oO5/54t5PTQ14neYhOz9x4gUk2AYAW6d1vePwb\n+hcC8roQwkHT7HvfYBoc74FM=\n+-----END CERTIFICATE-----`\n+\n+var globalSignRoot = `-----BEGIN CERTIFICATE-----\n+MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n+A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n+b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\n+MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\n+YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\n+aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\n+jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\n+xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\n+1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\n+snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\n+U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\n+9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\n+BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\n+AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\n+yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\n+38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\n+AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\n+DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\n+HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\n+-----END CERTIFICATE-----`"}, {"sha": "57f68ba7edce0f6837e4ddee9231720d137a7067", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 230, "deletions": 69, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -40,38 +40,60 @@ func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error) {\n \t}\n \talgo := getPublicKeyAlgorithmFromOID(pki.Algorithm.Algorithm)\n \tif algo == UnknownPublicKeyAlgorithm {\n-\t\treturn nil, errors.New(\"ParsePKIXPublicKey: unknown public key algorithm\")\n+\t\treturn nil, errors.New(\"x509: unknown public key algorithm\")\n \t}\n \treturn parsePublicKey(algo, &pki)\n }\n \n-// MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n-func MarshalPKIXPublicKey(pub interface{}) ([]byte, error) {\n-\tvar pubBytes []byte\n-\n+func marshalPublicKey(pub interface{}) (publicKeyBytes []byte, publicKeyAlgorithm pkix.AlgorithmIdentifier, err error) {\n \tswitch pub := pub.(type) {\n \tcase *rsa.PublicKey:\n-\t\tpubBytes, _ = asn1.Marshal(rsaPublicKey{\n+\t\tpublicKeyBytes, err = asn1.Marshal(rsaPublicKey{\n \t\t\tN: pub.N,\n \t\t\tE: pub.E,\n \t\t})\n+\t\tpublicKeyAlgorithm.Algorithm = oidPublicKeyRSA\n+\t\t// This is a NULL parameters value which is technically\n+\t\t// superfluous, but most other code includes it and, by\n+\t\t// doing this, we match their public key hashes.\n+\t\tpublicKeyAlgorithm.Parameters = asn1.RawValue{\n+\t\t\tTag: 5,\n+\t\t}\n+\tcase *ecdsa.PublicKey:\n+\t\tpublicKeyBytes = elliptic.Marshal(pub.Curve, pub.X, pub.Y)\n+\t\toid, ok := oidFromNamedCurve(pub.Curve)\n+\t\tif !ok {\n+\t\t\treturn nil, pkix.AlgorithmIdentifier{}, errors.New(\"x509: unsupported elliptic curve\")\n+\t\t}\n+\t\tpublicKeyAlgorithm.Algorithm = oidPublicKeyECDSA\n+\t\tvar paramBytes []byte\n+\t\tparamBytes, err = asn1.Marshal(oid)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tpublicKeyAlgorithm.Parameters.FullBytes = paramBytes\n \tdefault:\n-\t\treturn nil, errors.New(\"MarshalPKIXPublicKey: unknown public key type\")\n+\t\treturn nil, pkix.AlgorithmIdentifier{}, errors.New(\"x509: only RSA and ECDSA public keys supported\")\n+\t}\n+\n+\treturn publicKeyBytes, publicKeyAlgorithm, nil\n+}\n+\n+// MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n+func MarshalPKIXPublicKey(pub interface{}) ([]byte, error) {\n+\tvar publicKeyBytes []byte\n+\tvar publicKeyAlgorithm pkix.AlgorithmIdentifier\n+\tvar err error\n+\n+\tif publicKeyBytes, publicKeyAlgorithm, err = marshalPublicKey(pub); err != nil {\n+\t\treturn nil, err\n \t}\n \n \tpkix := pkixPublicKey{\n-\t\tAlgo: pkix.AlgorithmIdentifier{\n-\t\t\tAlgorithm: []int{1, 2, 840, 113549, 1, 1, 1},\n-\t\t\t// This is a NULL parameters value which is technically\n-\t\t\t// superfluous, but most other code includes it and, by\n-\t\t\t// doing this, we match their public key hashes.\n-\t\t\tParameters: asn1.RawValue{\n-\t\t\t\tTag: 5,\n-\t\t\t},\n-\t\t},\n+\t\tAlgo: publicKeyAlgorithm,\n \t\tBitString: asn1.BitString{\n-\t\t\tBytes:     pubBytes,\n-\t\t\tBitLength: 8 * len(pubBytes),\n+\t\t\tBytes:     publicKeyBytes,\n+\t\t\tBitLength: 8 * len(publicKeyBytes),\n \t\t},\n \t}\n \n@@ -453,6 +475,18 @@ type Certificate struct {\n \tNotBefore, NotAfter time.Time // Validity bounds.\n \tKeyUsage            KeyUsage\n \n+\t// Extensions contains raw X.509 extensions. When parsing certificates,\n+\t// this can be used to extract non-critical extensions that are not\n+\t// parsed by this package. When marshaling certificates, the Extensions\n+\t// field is ignored, see ExtraExtensions.\n+\tExtensions []pkix.Extension\n+\n+\t// ExtraExtensions contains extensions to be copied, raw, into any\n+\t// marshaled certificates. Values override any extensions that would\n+\t// otherwise be produced based on the other fields. The ExtraExtensions\n+\t// field is not populated when parsing certificates, see Extensions.\n+\tExtraExtensions []pkix.Extension\n+\n \tExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n \tUnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.\n \n@@ -463,6 +497,10 @@ type Certificate struct {\n \tSubjectKeyId   []byte\n \tAuthorityKeyId []byte\n \n+\t// RFC 5280, 4.2.2.1 (Authority Information Access)\n+\tOCSPServer            []string\n+\tIssuingCertificateURL []string\n+\n \t// Subject Alternate Name values\n \tDNSNames       []string\n \tEmailAddresses []string\n@@ -472,20 +510,23 @@ type Certificate struct {\n \tPermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.\n \tPermittedDNSDomains         []string\n \n+\t// CRL Distribution Points\n+\tCRLDistributionPoints []string\n+\n \tPolicyIdentifiers []asn1.ObjectIdentifier\n }\n \n // ErrUnsupportedAlgorithm results from attempting to perform an operation that\n // involves algorithms that are not currently implemented.\n-var ErrUnsupportedAlgorithm = errors.New(\"crypto/x509: cannot verify signature: algorithm unimplemented\")\n+var ErrUnsupportedAlgorithm = errors.New(\"x509: cannot verify signature: algorithm unimplemented\")\n \n // ConstraintViolationError results when a requested usage is not permitted by\n // a certificate. For example: checking a signature when the public key isn't a\n // certificate signing key.\n type ConstraintViolationError struct{}\n \n func (ConstraintViolationError) Error() string {\n-\treturn \"crypto/x509: invalid signature: parent certificate cannot sign this kind of certificate\"\n+\treturn \"x509: invalid signature: parent certificate cannot sign this kind of certificate\"\n }\n \n func (c *Certificate) Equal(other *Certificate) bool {\n@@ -604,10 +645,10 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \t\t\treturn err\n \t\t}\n \t\tif dsaSig.R.Sign() <= 0 || dsaSig.S.Sign() <= 0 {\n-\t\t\treturn errors.New(\"DSA signature contained zero or negative values\")\n+\t\t\treturn errors.New(\"x509: DSA signature contained zero or negative values\")\n \t\t}\n \t\tif !dsa.Verify(pub, digest, dsaSig.R, dsaSig.S) {\n-\t\t\treturn errors.New(\"DSA verification failure\")\n+\t\t\treturn errors.New(\"x509: DSA verification failure\")\n \t\t}\n \t\treturn\n \tcase *ecdsa.PublicKey:\n@@ -616,10 +657,10 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \t\t\treturn err\n \t\t}\n \t\tif ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 {\n-\t\t\treturn errors.New(\"crypto/x509: ECDSA signature contained zero or negative values\")\n+\t\t\treturn errors.New(\"x509: ECDSA signature contained zero or negative values\")\n \t\t}\n \t\tif !ecdsa.Verify(pub, digest, ecdsaSig.R, ecdsaSig.S) {\n-\t\t\treturn errors.New(\"crypto/x509: ECDSA verification failure\")\n+\t\t\treturn errors.New(\"x509: ECDSA verification failure\")\n \t\t}\n \t\treturn\n \t}\n@@ -635,7 +676,7 @@ func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) (err error) {\n type UnhandledCriticalExtension struct{}\n \n func (h UnhandledCriticalExtension) Error() string {\n-\treturn \"unhandled critical extension\"\n+\treturn \"x509: unhandled critical extension\"\n }\n \n type basicConstraints struct {\n@@ -659,6 +700,24 @@ type generalSubtree struct {\n \tName string `asn1:\"tag:2,optional,ia5\"`\n }\n \n+// RFC 5280, 4.2.2.1\n+type authorityInfoAccess struct {\n+\tMethod   asn1.ObjectIdentifier\n+\tLocation asn1.RawValue\n+}\n+\n+// RFC 5280, 4.2.1.14\n+type distributionPoint struct {\n+\tDistributionPoint distributionPointName `asn1:\"optional,tag:0\"`\n+\tReason            asn1.BitString        `asn1:\"optional,tag:1\"`\n+\tCRLIssuer         asn1.RawValue         `asn1:\"optional,tag:2\"`\n+}\n+\n+type distributionPointName struct {\n+\tFullName     asn1.RawValue    `asn1:\"optional,tag:0\"`\n+\tRelativeName pkix.RDNSequence `asn1:\"optional,tag:1\"`\n+}\n+\n func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{}, error) {\n \tasn1Data := keyData.PublicKey.RightAlign()\n \tswitch algo {\n@@ -694,7 +753,7 @@ func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{\n \t\t\treturn nil, err\n \t\t}\n \t\tif p.Sign() <= 0 || params.P.Sign() <= 0 || params.Q.Sign() <= 0 || params.G.Sign() <= 0 {\n-\t\t\treturn nil, errors.New(\"zero or negative DSA parameter\")\n+\t\t\treturn nil, errors.New(\"x509: zero or negative DSA parameter\")\n \t\t}\n \t\tpub := &dsa.PublicKey{\n \t\t\tParameters: dsa.Parameters{\n@@ -714,11 +773,11 @@ func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{\n \t\t}\n \t\tnamedCurve := namedCurveFromOID(*namedCurveOID)\n \t\tif namedCurve == nil {\n-\t\t\treturn nil, errors.New(\"crypto/x509: unsupported elliptic curve\")\n+\t\t\treturn nil, errors.New(\"x509: unsupported elliptic curve\")\n \t\t}\n \t\tx, y := elliptic.Unmarshal(namedCurve, asn1Data)\n \t\tif x == nil {\n-\t\t\treturn nil, errors.New(\"crypto/x509: failed to unmarshal elliptic curve point\")\n+\t\t\treturn nil, errors.New(\"x509: failed to unmarshal elliptic curve point\")\n \t\t}\n \t\tpub := &ecdsa.PublicKey{\n \t\t\tCurve: namedCurve,\n@@ -752,7 +811,7 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t}\n \n \tif in.TBSCertificate.SerialNumber.Sign() < 0 {\n-\t\treturn nil, errors.New(\"negative serial number\")\n+\t\treturn nil, errors.New(\"x509: negative serial number\")\n \t}\n \n \tout.Version = in.TBSCertificate.Version + 1\n@@ -773,6 +832,8 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \tout.NotAfter = in.TBSCertificate.Validity.NotAfter\n \n \tfor _, e := range in.TBSCertificate.Extensions {\n+\t\tout.Extensions = append(out.Extensions, e)\n+\n \t\tif len(e.Id) == 4 && e.Id[0] == 2 && e.Id[1] == 5 && e.Id[2] == 29 {\n \t\t\tswitch e.Id[3] {\n \t\t\tcase 15:\n@@ -896,6 +957,39 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t\t\t\t}\n \t\t\t\tcontinue\n \n+\t\t\tcase 31:\n+\t\t\t\t// RFC 5280, 4.2.1.14\n+\n+\t\t\t\t// CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint\n+\t\t\t\t//\n+\t\t\t\t// DistributionPoint ::= SEQUENCE {\n+\t\t\t\t//     distributionPoint       [0]     DistributionPointName OPTIONAL,\n+\t\t\t\t//     reasons                 [1]     ReasonFlags OPTIONAL,\n+\t\t\t\t//     cRLIssuer               [2]     GeneralNames OPTIONAL }\n+\t\t\t\t//\n+\t\t\t\t// DistributionPointName ::= CHOICE {\n+\t\t\t\t//     fullName                [0]     GeneralNames,\n+\t\t\t\t//     nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }\n+\n+\t\t\t\tvar cdp []distributionPoint\n+\t\t\t\t_, err := asn1.Unmarshal(e.Value, &cdp)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\n+\t\t\t\tfor _, dp := range cdp {\n+\t\t\t\t\tvar n asn1.RawValue\n+\t\t\t\t\t_, err = asn1.Unmarshal(dp.DistributionPoint.FullName.Bytes, &n)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn nil, err\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif n.Tag == 6 {\n+\t\t\t\t\t\tout.CRLDistributionPoints = append(out.CRLDistributionPoints, string(n.Bytes))\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\n \t\t\tcase 35:\n \t\t\t\t// RFC 5280, 4.2.1.1\n \t\t\t\tvar a authKeyId\n@@ -952,6 +1046,24 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t\t\t\t\tout.PolicyIdentifiers[i] = policy.Policy\n \t\t\t\t}\n \t\t\t}\n+\t\t} else if e.Id.Equal(oidExtensionAuthorityInfoAccess) {\n+\t\t\t// RFC 5280 4.2.2.1: Authority Information Access\n+\t\t\tvar aia []authorityInfoAccess\n+\t\t\tif _, err = asn1.Unmarshal(e.Value, &aia); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tfor _, v := range aia {\n+\t\t\t\t// GeneralName: uniformResourceIdentifier [6] IA5String\n+\t\t\t\tif v.Location.Tag != 6 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif v.Method.Equal(oidAuthorityInfoAccessOcsp) {\n+\t\t\t\t\tout.OCSPServer = append(out.OCSPServer, string(v.Location.Bytes))\n+\t\t\t\t} else if v.Method.Equal(oidAuthorityInfoAccessIssuers) {\n+\t\t\t\t\tout.IssuingCertificateURL = append(out.IssuingCertificateURL, string(v.Location.Bytes))\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \n \t\tif e.Critical {\n@@ -1011,21 +1123,40 @@ func reverseBitsInAByte(in byte) byte {\n }\n \n var (\n-\toidExtensionSubjectKeyId        = []int{2, 5, 29, 14}\n-\toidExtensionKeyUsage            = []int{2, 5, 29, 15}\n-\toidExtensionExtendedKeyUsage    = []int{2, 5, 29, 37}\n-\toidExtensionAuthorityKeyId      = []int{2, 5, 29, 35}\n-\toidExtensionBasicConstraints    = []int{2, 5, 29, 19}\n-\toidExtensionSubjectAltName      = []int{2, 5, 29, 17}\n-\toidExtensionCertificatePolicies = []int{2, 5, 29, 32}\n-\toidExtensionNameConstraints     = []int{2, 5, 29, 30}\n+\toidExtensionSubjectKeyId          = []int{2, 5, 29, 14}\n+\toidExtensionKeyUsage              = []int{2, 5, 29, 15}\n+\toidExtensionExtendedKeyUsage      = []int{2, 5, 29, 37}\n+\toidExtensionAuthorityKeyId        = []int{2, 5, 29, 35}\n+\toidExtensionBasicConstraints      = []int{2, 5, 29, 19}\n+\toidExtensionSubjectAltName        = []int{2, 5, 29, 17}\n+\toidExtensionCertificatePolicies   = []int{2, 5, 29, 32}\n+\toidExtensionNameConstraints       = []int{2, 5, 29, 30}\n+\toidExtensionCRLDistributionPoints = []int{2, 5, 29, 31}\n+\toidExtensionAuthorityInfoAccess   = []int{1, 3, 6, 1, 5, 5, 7, 1, 1}\n+)\n+\n+var (\n+\toidAuthorityInfoAccessOcsp    = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 48, 1}\n+\toidAuthorityInfoAccessIssuers = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 48, 2}\n )\n \n+// oidNotInExtensions returns whether an extension with the given oid exists in\n+// extensions.\n+func oidInExtensions(oid asn1.ObjectIdentifier, extensions []pkix.Extension) bool {\n+\tfor _, e := range extensions {\n+\t\tif e.Id.Equal(oid) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n-\tret = make([]pkix.Extension, 8 /* maximum number of elements. */)\n+\tret = make([]pkix.Extension, 10 /* maximum number of elements. */)\n \tn := 0\n \n-\tif template.KeyUsage != 0 {\n+\tif template.KeyUsage != 0 &&\n+\t\t!oidInExtensions(oidExtensionKeyUsage, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionKeyUsage\n \t\tret[n].Critical = true\n \n@@ -1045,7 +1176,8 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif len(template.ExtKeyUsage) > 0 || len(template.UnknownExtKeyUsage) > 0 {\n+\tif (len(template.ExtKeyUsage) > 0 || len(template.UnknownExtKeyUsage) > 0) &&\n+\t\t!oidInExtensions(oidExtensionExtendedKeyUsage, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionExtendedKeyUsage\n \n \t\tvar oids []asn1.ObjectIdentifier\n@@ -1066,7 +1198,7 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif template.BasicConstraintsValid {\n+\tif template.BasicConstraintsValid && !oidInExtensions(oidExtensionBasicConstraints, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionBasicConstraints\n \t\tret[n].Value, err = asn1.Marshal(basicConstraints{template.IsCA, template.MaxPathLen})\n \t\tret[n].Critical = true\n@@ -1076,7 +1208,7 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif len(template.SubjectKeyId) > 0 {\n+\tif len(template.SubjectKeyId) > 0 && !oidInExtensions(oidExtensionSubjectKeyId, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionSubjectKeyId\n \t\tret[n].Value, err = asn1.Marshal(template.SubjectKeyId)\n \t\tif err != nil {\n@@ -1085,7 +1217,7 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif len(template.AuthorityKeyId) > 0 {\n+\tif len(template.AuthorityKeyId) > 0 && !oidInExtensions(oidExtensionAuthorityKeyId, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionAuthorityKeyId\n \t\tret[n].Value, err = asn1.Marshal(authKeyId{template.AuthorityKeyId})\n \t\tif err != nil {\n@@ -1094,7 +1226,31 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif len(template.DNSNames) > 0 || len(template.EmailAddresses) > 0 || len(template.IPAddresses) > 0 {\n+\tif (len(template.OCSPServer) > 0 || len(template.IssuingCertificateURL) > 0) &&\n+\t\t!oidInExtensions(oidExtensionAuthorityInfoAccess, template.ExtraExtensions) {\n+\t\tret[n].Id = oidExtensionAuthorityInfoAccess\n+\t\tvar aiaValues []authorityInfoAccess\n+\t\tfor _, name := range template.OCSPServer {\n+\t\t\taiaValues = append(aiaValues, authorityInfoAccess{\n+\t\t\t\tMethod:   oidAuthorityInfoAccessOcsp,\n+\t\t\t\tLocation: asn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)},\n+\t\t\t})\n+\t\t}\n+\t\tfor _, name := range template.IssuingCertificateURL {\n+\t\t\taiaValues = append(aiaValues, authorityInfoAccess{\n+\t\t\t\tMethod:   oidAuthorityInfoAccessIssuers,\n+\t\t\t\tLocation: asn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)},\n+\t\t\t})\n+\t\t}\n+\t\tret[n].Value, err = asn1.Marshal(aiaValues)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tn++\n+\t}\n+\n+\tif (len(template.DNSNames) > 0 || len(template.EmailAddresses) > 0 || len(template.IPAddresses) > 0) &&\n+\t\t!oidInExtensions(oidExtensionSubjectAltName, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionSubjectAltName\n \t\tvar rawValues []asn1.RawValue\n \t\tfor _, name := range template.DNSNames {\n@@ -1118,7 +1274,8 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif len(template.PolicyIdentifiers) > 0 {\n+\tif len(template.PolicyIdentifiers) > 0 &&\n+\t\t!oidInExtensions(oidExtensionCertificatePolicies, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionCertificatePolicies\n \t\tpolicies := make([]policyInformation, len(template.PolicyIdentifiers))\n \t\tfor i, policy := range template.PolicyIdentifiers {\n@@ -1131,7 +1288,8 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif len(template.PermittedDNSDomains) > 0 {\n+\tif len(template.PermittedDNSDomains) > 0 &&\n+\t\t!oidInExtensions(oidExtensionNameConstraints, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionNameConstraints\n \t\tret[n].Critical = template.PermittedDNSDomainsCritical\n \n@@ -1147,10 +1305,33 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n+\tif len(template.CRLDistributionPoints) > 0 &&\n+\t\t!oidInExtensions(oidExtensionCRLDistributionPoints, template.ExtraExtensions) {\n+\t\tret[n].Id = oidExtensionCRLDistributionPoints\n+\n+\t\tvar crlDp []distributionPoint\n+\t\tfor _, name := range template.CRLDistributionPoints {\n+\t\t\trawFullName, _ := asn1.Marshal(asn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)})\n+\n+\t\t\tdp := distributionPoint{\n+\t\t\t\tDistributionPoint: distributionPointName{\n+\t\t\t\t\tFullName: asn1.RawValue{Tag: 0, Class: 2, Bytes: rawFullName},\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\tcrlDp = append(crlDp, dp)\n+\t\t}\n+\n+\t\tret[n].Value, err = asn1.Marshal(crlDp)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tn++\n+\t}\n+\n \t// Adding another extension here? Remember to update the maximum number\n \t// of elements in the make() at the top of the function.\n \n-\treturn ret[0:n], nil\n+\treturn append(ret[:n], template.ExtraExtensions...), nil\n }\n \n func subjectBytes(cert *Certificate) ([]byte, error) {\n@@ -1179,28 +1360,8 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interf\n \tvar publicKeyBytes []byte\n \tvar publicKeyAlgorithm pkix.AlgorithmIdentifier\n \n-\tswitch pub := pub.(type) {\n-\tcase *rsa.PublicKey:\n-\t\tpublicKeyBytes, err = asn1.Marshal(rsaPublicKey{\n-\t\t\tN: pub.N,\n-\t\t\tE: pub.E,\n-\t\t})\n-\t\tpublicKeyAlgorithm.Algorithm = oidPublicKeyRSA\n-\tcase *ecdsa.PublicKey:\n-\t\toid, ok := oidFromNamedCurve(pub.Curve)\n-\t\tif !ok {\n-\t\t\treturn nil, errors.New(\"x509: unknown elliptic curve\")\n-\t\t}\n-\t\tpublicKeyAlgorithm.Algorithm = oidPublicKeyECDSA\n-\t\tvar paramBytes []byte\n-\t\tparamBytes, err = asn1.Marshal(oid)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tpublicKeyAlgorithm.Parameters.FullBytes = paramBytes\n-\t\tpublicKeyBytes = elliptic.Marshal(pub.Curve, pub.X, pub.Y)\n-\tdefault:\n-\t\treturn nil, errors.New(\"x509: only RSA and ECDSA public keys supported\")\n+\tif publicKeyBytes, publicKeyAlgorithm, err = marshalPublicKey(pub); err != nil {\n+\t\treturn nil, err\n \t}\n \n \tvar signatureAlgorithm pkix.AlgorithmIdentifier"}, {"sha": "f1097e992e706dab810404c8c38aabf87f917957", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -237,6 +237,11 @@ func TestCertificateParse(t *testing.T) {\n \tif err := certs[0].VerifyHostname(\"mail.google.com\"); err != nil {\n \t\tt.Error(err)\n \t}\n+\n+\tconst expectedExtensions = 4\n+\tif n := len(certs[0].Extensions); n != expectedExtensions {\n+\t\tt.Errorf(\"want %d extensions, got %d\", expectedExtensions, n)\n+\t}\n }\n \n var certBytes = \"308203223082028ba00302010202106edf0d9499fd4533dd1297fc42a93be1300d06092a864886\" +\n@@ -308,7 +313,8 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t}\n \n \ttestExtKeyUsage := []ExtKeyUsage{ExtKeyUsageClientAuth, ExtKeyUsageServerAuth}\n-\ttestUnknownExtKeyUsage := []asn1.ObjectIdentifier{[]int{1, 2, 3}, []int{3, 2, 1}}\n+\ttestUnknownExtKeyUsage := []asn1.ObjectIdentifier{[]int{1, 2, 3}, []int{2, 59, 1}}\n+\textraExtensionData := []byte(\"extra extension\")\n \n \tfor _, test := range tests {\n \t\tcommonName := \"test.example.com\"\n@@ -330,12 +336,30 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\t\tBasicConstraintsValid: true,\n \t\t\tIsCA: true,\n \n+\t\t\tOCSPServer:            []string{\"http://ocsp.example.com\"},\n+\t\t\tIssuingCertificateURL: []string{\"http://crt.example.com/ca1.crt\"},\n+\n \t\t\tDNSNames:       []string{\"test.example.com\"},\n \t\t\tEmailAddresses: []string{\"gopher@golang.org\"},\n \t\t\tIPAddresses:    []net.IP{net.IPv4(127, 0, 0, 1).To4(), net.ParseIP(\"2001:4860:0:2001::68\")},\n \n \t\t\tPolicyIdentifiers:   []asn1.ObjectIdentifier{[]int{1, 2, 3}},\n \t\t\tPermittedDNSDomains: []string{\".example.com\", \"example.com\"},\n+\n+\t\t\tCRLDistributionPoints: []string{\"http://crl1.example.com/ca1.crl\", \"http://crl2.example.com/ca1.crl\"},\n+\n+\t\t\tExtraExtensions: []pkix.Extension{\n+\t\t\t\t{\n+\t\t\t\t\tId:    []int{1, 2, 3, 4},\n+\t\t\t\t\tValue: extraExtensionData,\n+\t\t\t\t},\n+\t\t\t\t// This extension should override the SubjectKeyId, above.\n+\t\t\t\t{\n+\t\t\t\t\tId:       oidExtensionSubjectKeyId,\n+\t\t\t\t\tCritical: false,\n+\t\t\t\t\tValue:    []byte{0x04, 0x04, 4, 3, 2, 1},\n+\t\t\t\t},\n+\t\t\t},\n \t\t}\n \n \t\tderBytes, err := CreateCertificate(random, &template, &template, test.pub, test.priv)\n@@ -374,6 +398,14 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\t\tt.Errorf(\"%s: unknown extkeyusage wasn't correctly copied from the template. Got %v, want %v\", test.name, cert.UnknownExtKeyUsage, testUnknownExtKeyUsage)\n \t\t}\n \n+\t\tif !reflect.DeepEqual(cert.OCSPServer, template.OCSPServer) {\n+\t\t\tt.Errorf(\"%s: OCSP servers differ from template. Got %v, want %v\", test.name, cert.OCSPServer, template.OCSPServer)\n+\t\t}\n+\n+\t\tif !reflect.DeepEqual(cert.IssuingCertificateURL, template.IssuingCertificateURL) {\n+\t\t\tt.Errorf(\"%s: Issuing certificate URLs differ from template. Got %v, want %v\", test.name, cert.IssuingCertificateURL, template.IssuingCertificateURL)\n+\t\t}\n+\n \t\tif !reflect.DeepEqual(cert.DNSNames, template.DNSNames) {\n \t\t\tt.Errorf(\"%s: SAN DNS names differ from template. Got %v, want %v\", test.name, cert.DNSNames, template.DNSNames)\n \t\t}\n@@ -386,6 +418,18 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\t\tt.Errorf(\"%s: SAN IPs differ from template. Got %v, want %v\", test.name, cert.IPAddresses, template.IPAddresses)\n \t\t}\n \n+\t\tif !reflect.DeepEqual(cert.CRLDistributionPoints, template.CRLDistributionPoints) {\n+\t\t\tt.Errorf(\"%s: CRL distribution points differ from template. Got %v, want %v\", test.name, cert.CRLDistributionPoints, template.CRLDistributionPoints)\n+\t\t}\n+\n+\t\tif !bytes.Equal(cert.SubjectKeyId, []byte{4, 3, 2, 1}) {\n+\t\t\tt.Errorf(\"%s: ExtraExtensions didn't override SubjectKeyId\", test.name)\n+\t\t}\n+\n+\t\tif bytes.Index(derBytes, extraExtensionData) == -1 {\n+\t\t\tt.Errorf(\"%s: didn't find extra extension in DER output\", test.name)\n+\t\t}\n+\n \t\tif test.checkSig {\n \t\t\terr = cert.CheckSignatureFrom(cert)\n \t\t\tif err != nil {"}, {"sha": "a39c2c54fba68599c2e87ba76ce9345e9608c1b0", "filename": "libgo/go/database/sql/convert_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -267,14 +267,14 @@ func TestValueConverters(t *testing.T) {\n \t\t\tgoterr = err.Error()\n \t\t}\n \t\tif goterr != tt.err {\n-\t\t\tt.Errorf(\"test %d: %s(%T(%v)) error = %q; want error = %q\",\n+\t\t\tt.Errorf(\"test %d: %T(%T(%v)) error = %q; want error = %q\",\n \t\t\t\ti, tt.c, tt.in, tt.in, goterr, tt.err)\n \t\t}\n \t\tif tt.err != \"\" {\n \t\t\tcontinue\n \t\t}\n \t\tif !reflect.DeepEqual(out, tt.out) {\n-\t\t\tt.Errorf(\"test %d: %s(%T(%v)) = %v (%T); want %v (%T)\",\n+\t\t\tt.Errorf(\"test %d: %T(%T(%v)) = %v (%T); want %v (%T)\",\n \t\t\t\ti, tt.c, tt.in, tt.in, out, out, tt.out, tt.out)\n \t\t}\n \t}"}, {"sha": "1ce0ff06541844a5d4155f6d9d779eb252674fe7", "filename": "libgo/go/database/sql/driver/types_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -51,14 +51,14 @@ func TestValueConverters(t *testing.T) {\n \t\t\tgoterr = err.Error()\n \t\t}\n \t\tif goterr != tt.err {\n-\t\t\tt.Errorf(\"test %d: %s(%T(%v)) error = %q; want error = %q\",\n+\t\t\tt.Errorf(\"test %d: %T(%T(%v)) error = %q; want error = %q\",\n \t\t\t\ti, tt.c, tt.in, tt.in, goterr, tt.err)\n \t\t}\n \t\tif tt.err != \"\" {\n \t\t\tcontinue\n \t\t}\n \t\tif !reflect.DeepEqual(out, tt.out) {\n-\t\t\tt.Errorf(\"test %d: %s(%T(%v)) = %v (%T); want %v (%T)\",\n+\t\t\tt.Errorf(\"test %d: %T(%T(%v)) = %v (%T); want %v (%T)\",\n \t\t\t\ti, tt.c, tt.in, tt.in, out, out, tt.out, tt.out)\n \t\t}\n \t}"}, {"sha": "a8adfdd9424b15e52072bc32e7a40f4cbb9a2758", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -38,6 +38,8 @@ type fakeDriver struct {\n \tmu         sync.Mutex // guards 3 following fields\n \topenCount  int        // conn opens\n \tcloseCount int        // conn closes\n+\twaitCh     chan struct{}\n+\twaitingCh  chan struct{}\n \tdbs        map[string]*fakeDB\n }\n \n@@ -146,6 +148,12 @@ func (d *fakeDriver) Open(dsn string) (driver.Conn, error) {\n \tif len(parts) >= 2 && parts[1] == \"badConn\" {\n \t\tconn.bad = true\n \t}\n+\tif d.waitCh != nil {\n+\t\td.waitingCh <- struct{}{}\n+\t\t<-d.waitCh\n+\t\td.waitCh = nil\n+\t\td.waitingCh = nil\n+\t}\n \treturn conn, nil\n }\n \n@@ -447,6 +455,10 @@ func (c *fakeConn) Prepare(query string) (driver.Stmt, error) {\n \t\treturn c.prepareCreate(stmt, parts)\n \tcase \"INSERT\":\n \t\treturn c.prepareInsert(stmt, parts)\n+\tcase \"NOSERT\":\n+\t\t// Do all the prep-work like for an INSERT but don't actually insert the row.\n+\t\t// Used for some of the concurrent tests.\n+\t\treturn c.prepareInsert(stmt, parts)\n \tdefault:\n \t\tstmt.Close()\n \t\treturn nil, errf(\"unsupported command type %q\", cmd)\n@@ -497,13 +509,20 @@ func (s *fakeStmt) Exec(args []driver.Value) (driver.Result, error) {\n \t\t}\n \t\treturn driver.ResultNoRows, nil\n \tcase \"INSERT\":\n-\t\treturn s.execInsert(args)\n+\t\treturn s.execInsert(args, true)\n+\tcase \"NOSERT\":\n+\t\t// Do all the prep-work like for an INSERT but don't actually insert the row.\n+\t\t// Used for some of the concurrent tests.\n+\t\treturn s.execInsert(args, false)\n \t}\n \tfmt.Printf(\"EXEC statement, cmd=%q: %#v\\n\", s.cmd, s)\n \treturn nil, fmt.Errorf(\"unimplemented statement Exec command type of %q\", s.cmd)\n }\n \n-func (s *fakeStmt) execInsert(args []driver.Value) (driver.Result, error) {\n+// When doInsert is true, add the row to the table.\n+// When doInsert is false do prep-work and error checking, but don't\n+// actually add the row to the table.\n+func (s *fakeStmt) execInsert(args []driver.Value, doInsert bool) (driver.Result, error) {\n \tdb := s.c.db\n \tif len(args) != s.placeholders {\n \t\tpanic(\"error in pkg db; should only get here if size is correct\")\n@@ -518,7 +537,10 @@ func (s *fakeStmt) execInsert(args []driver.Value) (driver.Result, error) {\n \tt.mu.Lock()\n \tdefer t.mu.Unlock()\n \n-\tcols := make([]interface{}, len(t.colname))\n+\tvar cols []interface{}\n+\tif doInsert {\n+\t\tcols = make([]interface{}, len(t.colname))\n+\t}\n \targPos := 0\n \tfor n, colname := range s.colName {\n \t\tcolidx := t.columnIndex(colname)\n@@ -532,10 +554,14 @@ func (s *fakeStmt) execInsert(args []driver.Value) (driver.Result, error) {\n \t\t} else {\n \t\t\tval = s.colValue[n]\n \t\t}\n-\t\tcols[colidx] = val\n+\t\tif doInsert {\n+\t\t\tcols[colidx] = val\n+\t\t}\n \t}\n \n-\tt.rows = append(t.rows, &row{cols: cols})\n+\tif doInsert {\n+\t\tt.rows = append(t.rows, &row{cols: cols})\n+\t}\n \treturn driver.RowsAffected(1), nil\n }\n \n@@ -608,9 +634,10 @@ rows:\n \t}\n \n \tcursor := &rowsCursor{\n-\t\tpos:  -1,\n-\t\trows: mrows,\n-\t\tcols: s.colName,\n+\t\tpos:    -1,\n+\t\trows:   mrows,\n+\t\tcols:   s.colName,\n+\t\terrPos: -1,\n \t}\n \treturn cursor, nil\n }\n@@ -635,6 +662,10 @@ type rowsCursor struct {\n \trows   []*row\n \tclosed bool\n \n+\t// errPos and err are for making Next return early with error.\n+\terrPos int\n+\terr    error\n+\n \t// a clone of slices to give out to clients, indexed by the\n \t// the original slice's first byte address.  we clone them\n \t// just so we're able to corrupt them on close.\n@@ -660,6 +691,9 @@ func (rc *rowsCursor) Next(dest []driver.Value) error {\n \t\treturn errors.New(\"fakedb: cursor is closed\")\n \t}\n \trc.pos++\n+\tif rc.pos == rc.errPos {\n+\t\treturn rc.err\n+\t}\n \tif rc.pos >= len(rc.rows) {\n \t\treturn io.EOF // per interface spec\n \t}"}, {"sha": "f7b4f8cdab8285d8cc98fd0222ffa3f4b68535cb", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 287, "deletions": 84, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -7,9 +7,13 @@\n //\n // The sql package must be used in conjunction with a database driver.\n // See http://golang.org/s/sqldrivers for a list of drivers.\n+//\n+// For more usage examples, see the wiki page at\n+// http://golang.org/s/sqlwiki.\n package sql\n \n import (\n+\t\"container/list\"\n \t\"database/sql/driver\"\n \t\"errors\"\n \t\"fmt\"\n@@ -192,12 +196,22 @@ type DB struct {\n \tdriver driver.Driver\n \tdsn    string\n \n-\tmu       sync.Mutex // protects following fields\n-\tfreeConn []*driverConn\n+\tmu           sync.Mutex // protects following fields\n+\tfreeConn     *list.List // of *driverConn\n+\tconnRequests *list.List // of connRequest\n+\tnumOpen      int\n+\tpendingOpens int\n+\t// Used to sygnal the need for new connections\n+\t// a goroutine running connectionOpener() reads on this chan and\n+\t// maybeOpenNewConnections sends on the chan (one send per needed connection)\n+\t// It is closed during db.Close(). The close tells the connectionOpener\n+\t// goroutine to exit.\n+\topenerCh chan struct{}\n \tclosed   bool\n \tdep      map[finalCloser]depSet\n \tlastPut  map[*driverConn]string // stacktrace of last conn's put; debug only\n \tmaxIdle  int                    // zero means defaultMaxIdleConns; negative means 0\n+\tmaxOpen  int                    // <= 0 means unlimited\n }\n \n // driverConn wraps a driver.Conn with a mutex, to\n@@ -217,6 +231,13 @@ type driverConn struct {\n \tinUse      bool\n \tonPut      []func() // code (with db.mu held) run when conn is next returned\n \tdbmuClosed bool     // same as closed, but guarded by db.mu, for connIfFree\n+\t// This is the Element returned by db.freeConn.PushFront(conn).\n+\t// It's used by connIfFree to remove the conn from the freeConn list.\n+\tlistElem *list.Element\n+}\n+\n+func (dc *driverConn) releaseConn(err error) {\n+\tdc.db.putConn(dc, err)\n }\n \n func (dc *driverConn) removeOpenStmt(si driver.Stmt) {\n@@ -250,15 +271,14 @@ func (dc *driverConn) prepareLocked(query string) (driver.Stmt, error) {\n }\n \n // the dc.db's Mutex is held.\n-func (dc *driverConn) closeDBLocked() error {\n+func (dc *driverConn) closeDBLocked() func() error {\n \tdc.Lock()\n+\tdefer dc.Unlock()\n \tif dc.closed {\n-\t\tdc.Unlock()\n-\t\treturn errors.New(\"sql: duplicate driverConn close\")\n+\t\treturn func() error { return errors.New(\"sql: duplicate driverConn close\") }\n \t}\n \tdc.closed = true\n-\tdc.Unlock() // not defer; removeDep finalClose calls may need to lock\n-\treturn dc.db.removeDepLocked(dc, dc)()\n+\treturn dc.db.removeDepLocked(dc, dc)\n }\n \n func (dc *driverConn) Close() error {\n@@ -289,8 +309,13 @@ func (dc *driverConn) finalClose() error {\n \terr := dc.ci.Close()\n \tdc.ci = nil\n \tdc.finalClosed = true\n-\n \tdc.Unlock()\n+\n+\tdc.db.mu.Lock()\n+\tdc.db.numOpen--\n+\tdc.db.maybeOpenNewConnections()\n+\tdc.db.mu.Unlock()\n+\n \treturn err\n }\n \n@@ -353,26 +378,36 @@ func (db *DB) removeDep(x finalCloser, dep interface{}) error {\n \n func (db *DB) removeDepLocked(x finalCloser, dep interface{}) func() error {\n \t//println(fmt.Sprintf(\"removeDep(%T %p, %T %p)\", x, x, dep, dep))\n-\tdone := false\n \n-\txdep := db.dep[x]\n-\tif xdep != nil {\n-\t\tdelete(xdep, dep)\n-\t\tif len(xdep) == 0 {\n-\t\t\tdelete(db.dep, x)\n-\t\t\tdone = true\n-\t\t}\n+\txdep, ok := db.dep[x]\n+\tif !ok {\n+\t\tpanic(fmt.Sprintf(\"unpaired removeDep: no deps for %T\", x))\n \t}\n \n-\tif !done {\n+\tl0 := len(xdep)\n+\tdelete(xdep, dep)\n+\n+\tswitch len(xdep) {\n+\tcase l0:\n+\t\t// Nothing removed. Shouldn't happen.\n+\t\tpanic(fmt.Sprintf(\"unpaired removeDep: no %T dep on %T\", dep, x))\n+\tcase 0:\n+\t\t// No more dependencies.\n+\t\tdelete(db.dep, x)\n+\t\treturn x.finalClose\n+\tdefault:\n+\t\t// Dependencies remain.\n \t\treturn func() error { return nil }\n \t}\n-\treturn func() error {\n-\t\t//println(fmt.Sprintf(\"calling final close on %T %v (%#v)\", x, x, x))\n-\t\treturn x.finalClose()\n-\t}\n }\n \n+// This is the size of the connectionOpener request chan (dn.openerCh).\n+// This value should be larger than the maximum typical value\n+// used for db.maxOpen. If maxOpen is significantly larger than\n+// connectionRequestQueueSize then it is possible for ALL calls into the *DB\n+// to block until the connectionOpener can satify the backlog of requests.\n+var connectionRequestQueueSize = 1000000\n+\n // Open opens a database specified by its database driver name and a\n // driver-specific data source name, usually consisting of at least a\n // database name and connection information.\n@@ -391,10 +426,14 @@ func Open(driverName, dataSourceName string) (*DB, error) {\n \t\treturn nil, fmt.Errorf(\"sql: unknown driver %q (forgotten import?)\", driverName)\n \t}\n \tdb := &DB{\n-\t\tdriver:  driveri,\n-\t\tdsn:     dataSourceName,\n-\t\tlastPut: make(map[*driverConn]string),\n-\t}\n+\t\tdriver:   driveri,\n+\t\tdsn:      dataSourceName,\n+\t\topenerCh: make(chan struct{}, connectionRequestQueueSize),\n+\t\tlastPut:  make(map[*driverConn]string),\n+\t}\n+\tdb.freeConn = list.New()\n+\tdb.connRequests = list.New()\n+\tgo db.connectionOpener()\n \treturn db, nil\n }\n \n@@ -415,16 +454,32 @@ func (db *DB) Ping() error {\n // Close closes the database, releasing any open resources.\n func (db *DB) Close() error {\n \tdb.mu.Lock()\n-\tdefer db.mu.Unlock()\n+\tif db.closed { // Make DB.Close idempotent\n+\t\tdb.mu.Unlock()\n+\t\treturn nil\n+\t}\n+\tclose(db.openerCh)\n \tvar err error\n-\tfor _, dc := range db.freeConn {\n-\t\terr1 := dc.closeDBLocked()\n+\tfns := make([]func() error, 0, db.freeConn.Len())\n+\tfor db.freeConn.Front() != nil {\n+\t\tdc := db.freeConn.Front().Value.(*driverConn)\n+\t\tdc.listElem = nil\n+\t\tfns = append(fns, dc.closeDBLocked())\n+\t\tdb.freeConn.Remove(db.freeConn.Front())\n+\t}\n+\tdb.closed = true\n+\tfor db.connRequests.Front() != nil {\n+\t\treq := db.connRequests.Front().Value.(connRequest)\n+\t\tdb.connRequests.Remove(db.connRequests.Front())\n+\t\tclose(req)\n+\t}\n+\tdb.mu.Unlock()\n+\tfor _, fn := range fns {\n+\t\terr1 := fn()\n \t\tif err1 != nil {\n \t\t\terr = err1\n \t\t}\n \t}\n-\tdb.freeConn = nil\n-\tdb.closed = true\n \treturn err\n }\n \n@@ -446,50 +501,168 @@ func (db *DB) maxIdleConnsLocked() int {\n // SetMaxIdleConns sets the maximum number of connections in the idle\n // connection pool.\n //\n+// If MaxOpenConns is greater than 0 but less than the new MaxIdleConns\n+// then the new MaxIdleConns will be reduced to match the MaxOpenConns limit\n+//\n // If n <= 0, no idle connections are retained.\n func (db *DB) SetMaxIdleConns(n int) {\n \tdb.mu.Lock()\n-\tdefer db.mu.Unlock()\n \tif n > 0 {\n \t\tdb.maxIdle = n\n \t} else {\n \t\t// No idle connections.\n \t\tdb.maxIdle = -1\n \t}\n-\tfor len(db.freeConn) > 0 && len(db.freeConn) > n {\n-\t\tnfree := len(db.freeConn)\n-\t\tdc := db.freeConn[nfree-1]\n-\t\tdb.freeConn[nfree-1] = nil\n-\t\tdb.freeConn = db.freeConn[:nfree-1]\n-\t\tgo dc.Close()\n+\t// Make sure maxIdle doesn't exceed maxOpen\n+\tif db.maxOpen > 0 && db.maxIdleConnsLocked() > db.maxOpen {\n+\t\tdb.maxIdle = db.maxOpen\n+\t}\n+\tvar closing []*driverConn\n+\tfor db.freeConn.Len() > db.maxIdleConnsLocked() {\n+\t\tdc := db.freeConn.Back().Value.(*driverConn)\n+\t\tdc.listElem = nil\n+\t\tdb.freeConn.Remove(db.freeConn.Back())\n+\t\tclosing = append(closing, dc)\n+\t}\n+\tdb.mu.Unlock()\n+\tfor _, c := range closing {\n+\t\tc.Close()\n \t}\n }\n \n+// SetMaxOpenConns sets the maximum number of open connections to the database.\n+//\n+// If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than\n+// MaxIdleConns, then MaxIdleConns will be reduced to match the new\n+// MaxOpenConns limit\n+//\n+// If n <= 0, then there is no limit on the number of open connections.\n+// The default is 0 (unlimited).\n+func (db *DB) SetMaxOpenConns(n int) {\n+\tdb.mu.Lock()\n+\tdb.maxOpen = n\n+\tif n < 0 {\n+\t\tdb.maxOpen = 0\n+\t}\n+\tsyncMaxIdle := db.maxOpen > 0 && db.maxIdleConnsLocked() > db.maxOpen\n+\tdb.mu.Unlock()\n+\tif syncMaxIdle {\n+\t\tdb.SetMaxIdleConns(n)\n+\t}\n+}\n+\n+// Assumes db.mu is locked.\n+// If there are connRequests and the connection limit hasn't been reached,\n+// then tell the connectionOpener to open new connections.\n+func (db *DB) maybeOpenNewConnections() {\n+\tnumRequests := db.connRequests.Len() - db.pendingOpens\n+\tif db.maxOpen > 0 {\n+\t\tnumCanOpen := db.maxOpen - (db.numOpen + db.pendingOpens)\n+\t\tif numRequests > numCanOpen {\n+\t\t\tnumRequests = numCanOpen\n+\t\t}\n+\t}\n+\tfor numRequests > 0 {\n+\t\tdb.pendingOpens++\n+\t\tnumRequests--\n+\t\tdb.openerCh <- struct{}{}\n+\t}\n+}\n+\n+// Runs in a seperate goroutine, opens new connections when requested.\n+func (db *DB) connectionOpener() {\n+\tfor _ = range db.openerCh {\n+\t\tdb.openNewConnection()\n+\t}\n+}\n+\n+// Open one new connection\n+func (db *DB) openNewConnection() {\n+\tci, err := db.driver.Open(db.dsn)\n+\tdb.mu.Lock()\n+\tdefer db.mu.Unlock()\n+\tif db.closed {\n+\t\tif err == nil {\n+\t\t\tci.Close()\n+\t\t}\n+\t\treturn\n+\t}\n+\tdb.pendingOpens--\n+\tif err != nil {\n+\t\tdb.putConnDBLocked(nil, err)\n+\t\treturn\n+\t}\n+\tdc := &driverConn{\n+\t\tdb: db,\n+\t\tci: ci,\n+\t}\n+\tif db.putConnDBLocked(dc, err) {\n+\t\tdb.addDepLocked(dc, dc)\n+\t\tdb.numOpen++\n+\t} else {\n+\t\tci.Close()\n+\t}\n+}\n+\n+// connRequest represents one request for a new connection\n+// When there are no idle connections available, DB.conn will create\n+// a new connRequest and put it on the db.connRequests list.\n+type connRequest chan<- interface{} // takes either a *driverConn or an error\n+\n+var errDBClosed = errors.New(\"sql: database is closed\")\n+\n // conn returns a newly-opened or cached *driverConn\n func (db *DB) conn() (*driverConn, error) {\n \tdb.mu.Lock()\n \tif db.closed {\n \t\tdb.mu.Unlock()\n-\t\treturn nil, errors.New(\"sql: database is closed\")\n+\t\treturn nil, errDBClosed\n+\t}\n+\n+\t// If db.maxOpen > 0 and the number of open connections is over the limit\n+\t// or there are no free connection, then make a request and wait.\n+\tif db.maxOpen > 0 && (db.numOpen >= db.maxOpen || db.freeConn.Len() == 0) {\n+\t\t// Make the connRequest channel. It's buffered so that the\n+\t\t// connectionOpener doesn't block while waiting for the req to be read.\n+\t\tch := make(chan interface{}, 1)\n+\t\treq := connRequest(ch)\n+\t\tdb.connRequests.PushBack(req)\n+\t\tdb.maybeOpenNewConnections()\n+\t\tdb.mu.Unlock()\n+\t\tret, ok := <-ch\n+\t\tif !ok {\n+\t\t\treturn nil, errDBClosed\n+\t\t}\n+\t\tswitch ret.(type) {\n+\t\tcase *driverConn:\n+\t\t\treturn ret.(*driverConn), nil\n+\t\tcase error:\n+\t\t\treturn nil, ret.(error)\n+\t\tdefault:\n+\t\t\tpanic(\"sql: Unexpected type passed through connRequest.ch\")\n+\t\t}\n \t}\n-\tif n := len(db.freeConn); n > 0 {\n-\t\tconn := db.freeConn[n-1]\n-\t\tdb.freeConn = db.freeConn[:n-1]\n+\n+\tif f := db.freeConn.Front(); f != nil {\n+\t\tconn := f.Value.(*driverConn)\n+\t\tconn.listElem = nil\n+\t\tdb.freeConn.Remove(f)\n \t\tconn.inUse = true\n \t\tdb.mu.Unlock()\n \t\treturn conn, nil\n \t}\n-\tdb.mu.Unlock()\n \n+\tdb.mu.Unlock()\n \tci, err := db.driver.Open(db.dsn)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tdb.mu.Lock()\n+\tdb.numOpen++\n \tdc := &driverConn{\n \t\tdb: db,\n \t\tci: ci,\n \t}\n-\tdb.mu.Lock()\n \tdb.addDepLocked(dc, dc)\n \tdc.inUse = true\n \tdb.mu.Unlock()\n@@ -511,18 +684,15 @@ var (\n func (db *DB) connIfFree(wanted *driverConn) (*driverConn, error) {\n \tdb.mu.Lock()\n \tdefer db.mu.Unlock()\n-\tif wanted.inUse {\n-\t\treturn nil, errConnBusy\n-\t}\n \tif wanted.dbmuClosed {\n \t\treturn nil, errConnClosed\n \t}\n-\tfor i, conn := range db.freeConn {\n-\t\tif conn != wanted {\n-\t\t\tcontinue\n-\t\t}\n-\t\tdb.freeConn[i] = db.freeConn[len(db.freeConn)-1]\n-\t\tdb.freeConn = db.freeConn[:len(db.freeConn)-1]\n+\tif wanted.inUse {\n+\t\treturn nil, errConnBusy\n+\t}\n+\tif wanted.listElem != nil {\n+\t\tdb.freeConn.Remove(wanted.listElem)\n+\t\twanted.listElem = nil\n \t\twanted.inUse = true\n \t\treturn wanted, nil\n \t}\n@@ -582,20 +752,50 @@ func (db *DB) putConn(dc *driverConn, err error) {\n \n \tif err == driver.ErrBadConn {\n \t\t// Don't reuse bad connections.\n+\t\t// Since the conn is considered bad and is being discarded, treat it\n+\t\t// as closed. Don't decrement the open count here, finalClose will\n+\t\t// take care of that.\n+\t\tdb.maybeOpenNewConnections()\n \t\tdb.mu.Unlock()\n+\t\tdc.Close()\n \t\treturn\n \t}\n \tif putConnHook != nil {\n \t\tputConnHook(db, dc)\n \t}\n-\tif n := len(db.freeConn); !db.closed && n < db.maxIdleConnsLocked() {\n-\t\tdb.freeConn = append(db.freeConn, dc)\n-\t\tdb.mu.Unlock()\n-\t\treturn\n-\t}\n+\tadded := db.putConnDBLocked(dc, nil)\n \tdb.mu.Unlock()\n \n-\tdc.Close()\n+\tif !added {\n+\t\tdc.Close()\n+\t}\n+}\n+\n+// Satisfy a connRequest or put the driverConn in the idle pool and return true\n+// or return false.\n+// putConnDBLocked will satisfy a connRequest if there is one, or it will\n+// return the *driverConn to the freeConn list if err != nil and the idle\n+// connection limit would not be reached.\n+// If err != nil, the value of dc is ignored.\n+// If err == nil, then dc must not equal nil.\n+// If a connRequest was fullfilled or the *driverConn was placed in the\n+// freeConn list, then true is returned, otherwise false is returned.\n+func (db *DB) putConnDBLocked(dc *driverConn, err error) bool {\n+\tif db.connRequests.Len() > 0 {\n+\t\treq := db.connRequests.Front().Value.(connRequest)\n+\t\tdb.connRequests.Remove(db.connRequests.Front())\n+\t\tif err != nil {\n+\t\t\treq <- err\n+\t\t} else {\n+\t\t\tdc.inUse = true\n+\t\t\treq <- dc\n+\t\t}\n+\t\treturn true\n+\t} else if err == nil && !db.closed && db.maxIdleConnsLocked() > 0 && db.maxIdleConnsLocked() > db.freeConn.Len() {\n+\t\tdc.listElem = db.freeConn.PushFront(dc)\n+\t\treturn true\n+\t}\n+\treturn false\n }\n \n // Prepare creates a prepared statement for later queries or executions.\n@@ -710,9 +910,7 @@ func (db *DB) query(query string, args []interface{}) (*Rows, error) {\n \t\treturn nil, err\n \t}\n \n-\treleaseConn := func(err error) { db.putConn(ci, err) }\n-\n-\treturn db.queryConn(ci, releaseConn, query, args)\n+\treturn db.queryConn(ci, ci.releaseConn, query, args)\n }\n \n // queryConn executes a query on the given connection.\n@@ -754,10 +952,10 @@ func (db *DB) queryConn(dc *driverConn, releaseConn func(error), query string, a\n \tds := driverStmt{dc, si}\n \trowsi, err := rowsiFromStatement(ds, args...)\n \tif err != nil {\n-\t\treleaseConn(err)\n \t\tdc.Lock()\n \t\tsi.Close()\n \t\tdc.Unlock()\n+\t\treleaseConn(err)\n \t\treturn nil, err\n \t}\n \n@@ -1154,8 +1352,7 @@ func (s *Stmt) connStmt() (ci *driverConn, releaseConn func(error), si driver.St\n \t}\n \n \tconn := cs.dc\n-\treleaseConn = func(err error) { s.db.putConn(conn, err) }\n-\treturn conn, releaseConn, cs.si, nil\n+\treturn conn, conn.releaseConn, cs.si, nil\n }\n \n // Query executes a prepared query statement with the given arguments\n@@ -1245,27 +1442,32 @@ func (s *Stmt) Close() error {\n \t\treturn s.stickyErr\n \t}\n \ts.mu.Lock()\n-\tdefer s.mu.Unlock()\n \tif s.closed {\n+\t\ts.mu.Unlock()\n \t\treturn nil\n \t}\n \ts.closed = true\n \n \tif s.tx != nil {\n \t\ts.txsi.Close()\n+\t\ts.mu.Unlock()\n \t\treturn nil\n \t}\n+\ts.mu.Unlock()\n \n \treturn s.db.removeDep(s, s)\n }\n \n func (s *Stmt) finalClose() error {\n-\tfor _, v := range s.css {\n-\t\ts.db.noteUnusedDriverStatement(v.dc, v.si)\n-\t\tv.dc.removeOpenStmt(v.si)\n-\t\ts.db.removeDep(v.dc, s)\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\tif s.css != nil {\n+\t\tfor _, v := range s.css {\n+\t\t\ts.db.noteUnusedDriverStatement(v.dc, v.si)\n+\t\t\tv.dc.removeOpenStmt(v.si)\n+\t\t}\n+\t\ts.css = nil\n \t}\n-\ts.css = nil\n \treturn nil\n }\n \n@@ -1289,7 +1491,7 @@ type Rows struct {\n \n \tclosed    bool\n \tlastcols  []driver.Value\n-\tlasterr   error\n+\tlasterr   error       // non-nil only if closed is true\n \tcloseStmt driver.Stmt // if non-nil, statement to Close on close\n }\n \n@@ -1301,20 +1503,19 @@ func (rs *Rows) Next() bool {\n \tif rs.closed {\n \t\treturn false\n \t}\n-\tif rs.lasterr != nil {\n-\t\treturn false\n-\t}\n \tif rs.lastcols == nil {\n \t\trs.lastcols = make([]driver.Value, len(rs.rowsi.Columns()))\n \t}\n \trs.lasterr = rs.rowsi.Next(rs.lastcols)\n-\tif rs.lasterr == io.EOF {\n+\tif rs.lasterr != nil {\n \t\trs.Close()\n+\t\treturn false\n \t}\n-\treturn rs.lasterr == nil\n+\treturn true\n }\n \n // Err returns the error, if any, that was encountered during iteration.\n+// Err may be called after an explicit or implicit Close.\n func (rs *Rows) Err() error {\n \tif rs.lasterr == io.EOF {\n \t\treturn nil\n@@ -1349,10 +1550,7 @@ func (rs *Rows) Columns() ([]string, error) {\n // is of type []byte, a copy is made and the caller owns the result.\n func (rs *Rows) Scan(dest ...interface{}) error {\n \tif rs.closed {\n-\t\treturn errors.New(\"sql: Rows closed\")\n-\t}\n-\tif rs.lasterr != nil {\n-\t\treturn rs.lasterr\n+\t\treturn errors.New(\"sql: Rows are closed\")\n \t}\n \tif rs.lastcols == nil {\n \t\treturn errors.New(\"sql: Scan called without calling Next\")\n@@ -1369,15 +1567,20 @@ func (rs *Rows) Scan(dest ...interface{}) error {\n \treturn nil\n }\n \n-// Close closes the Rows, preventing further enumeration. If the\n-// end is encountered, the Rows are closed automatically. Close\n-// is idempotent.\n+var rowsCloseHook func(*Rows, *error)\n+\n+// Close closes the Rows, preventing further enumeration. If Next returns\n+// false, the Rows are closed automatically and it will suffice to check the\n+// result of Err. Close is idempotent and does not affect the result of Err.\n func (rs *Rows) Close() error {\n \tif rs.closed {\n \t\treturn nil\n \t}\n \trs.closed = true\n \terr := rs.rowsi.Close()\n+\tif fn := rowsCloseHook; fn != nil {\n+\t\tfn(rs, &err)\n+\t}\n \tif rs.closeStmt != nil {\n \t\trs.closeStmt.Close()\n \t}\n@@ -1414,13 +1617,13 @@ func (r *Row) Scan(dest ...interface{}) error {\n \t// from Next will not be modified again.\" (for instance, if\n \t// they were obtained from the network anyway) But for now we\n \t// don't care.\n+\tdefer r.rows.Close()\n \tfor _, dp := range dest {\n \t\tif _, ok := dp.(*RawBytes); ok {\n \t\t\treturn errors.New(\"sql: RawBytes isn't allowed on Row.Scan\")\n \t\t}\n \t}\n \n-\tdefer r.rows.Close()\n \tif !r.rows.Next() {\n \t\treturn ErrNoRows\n \t}"}, {"sha": "093c0d64caceecc170153abf96d500ccf7372097", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 722, "deletions": 37, "changes": 759, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -5,7 +5,10 @@\n package sql\n \n import (\n+\t\"database/sql/driver\"\n+\t\"errors\"\n \t\"fmt\"\n+\t\"math/rand\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"strings\"\n@@ -21,14 +24,12 @@ func init() {\n \t}\n \tfreedFrom := make(map[dbConn]string)\n \tputConnHook = func(db *DB, c *driverConn) {\n-\t\tfor _, oc := range db.freeConn {\n-\t\t\tif oc == c {\n-\t\t\t\t// print before panic, as panic may get lost due to conflicting panic\n-\t\t\t\t// (all goroutines asleep) elsewhere, since we might not unlock\n-\t\t\t\t// the mutex in freeConn here.\n-\t\t\t\tprintln(\"double free of conn. conflicts are:\\nA) \" + freedFrom[dbConn{db, c}] + \"\\n\\nand\\nB) \" + stack())\n-\t\t\t\tpanic(\"double free of conn.\")\n-\t\t\t}\n+\t\tif c.listElem != nil {\n+\t\t\t// print before panic, as panic may get lost due to conflicting panic\n+\t\t\t// (all goroutines asleep) elsewhere, since we might not unlock\n+\t\t\t// the mutex in freeConn here.\n+\t\t\tprintln(\"double free of conn. conflicts are:\\nA) \" + freedFrom[dbConn{db, c}] + \"\\n\\nand\\nB) \" + stack())\n+\t\t\tpanic(\"double free of conn.\")\n \t\t}\n \t\tfreedFrom[dbConn{db, c}] = stack()\n \t}\n@@ -38,15 +39,7 @@ const fakeDBName = \"foo\"\n \n var chrisBirthday = time.Unix(123456789, 0)\n \n-type testOrBench interface {\n-\tFatalf(string, ...interface{})\n-\tErrorf(string, ...interface{})\n-\tFatal(...interface{})\n-\tError(...interface{})\n-\tLogf(string, ...interface{})\n-}\n-\n-func newTestDB(t testOrBench, name string) *DB {\n+func newTestDB(t testing.TB, name string) *DB {\n \tdb, err := Open(\"test\", fakeDBName)\n \tif err != nil {\n \t\tt.Fatalf(\"Open: %v\", err)\n@@ -68,14 +61,14 @@ func newTestDB(t testOrBench, name string) *DB {\n \treturn db\n }\n \n-func exec(t testOrBench, db *DB, query string, args ...interface{}) {\n+func exec(t testing.TB, db *DB, query string, args ...interface{}) {\n \t_, err := db.Exec(query, args...)\n \tif err != nil {\n \t\tt.Fatalf(\"Exec of %q: %v\", query, err)\n \t}\n }\n \n-func closeDB(t testOrBench, db *DB) {\n+func closeDB(t testing.TB, db *DB) {\n \tif e := recover(); e != nil {\n \t\tfmt.Printf(\"Panic: %v\\n\", e)\n \t\tpanic(e)\n@@ -86,29 +79,36 @@ func closeDB(t testOrBench, db *DB) {\n \t\t\tt.Errorf(\"Error closing fakeConn: %v\", err)\n \t\t}\n \t})\n-\tfor i, dc := range db.freeConn {\n+\tfor node, i := db.freeConn.Front(), 0; node != nil; node, i = node.Next(), i+1 {\n+\t\tdc := node.Value.(*driverConn)\n \t\tif n := len(dc.openStmt); n > 0 {\n \t\t\t// Just a sanity check. This is legal in\n \t\t\t// general, but if we make the tests clean up\n \t\t\t// their statements first, then we can safely\n \t\t\t// verify this is always zero here, and any\n \t\t\t// other value is a leak.\n-\t\t\tt.Errorf(\"while closing db, freeConn %d/%d had %d open stmts; want 0\", i, len(db.freeConn), n)\n+\t\t\tt.Errorf(\"while closing db, freeConn %d/%d had %d open stmts; want 0\", i, db.freeConn.Len(), n)\n \t\t}\n \t}\n \terr := db.Close()\n \tif err != nil {\n \t\tt.Fatalf(\"error closing DB: %v\", err)\n \t}\n+\tdb.mu.Lock()\n+\tcount := db.numOpen\n+\tdb.mu.Unlock()\n+\tif count != 0 {\n+\t\tt.Fatalf(\"%d connections still open after closing DB\", db.numOpen)\n+\t}\n }\n \n // numPrepares assumes that db has exactly 1 idle conn and returns\n // its count of calls to Prepare\n func numPrepares(t *testing.T, db *DB) int {\n-\tif n := len(db.freeConn); n != 1 {\n+\tif n := db.freeConn.Len(); n != 1 {\n \t\tt.Fatalf(\"free conns = %d; want 1\", n)\n \t}\n-\treturn db.freeConn[0].ci.(*fakeConn).numPrepare\n+\treturn (db.freeConn.Front().Value.(*driverConn)).ci.(*fakeConn).numPrepare\n }\n \n func (db *DB) numDeps() int {\n@@ -133,7 +133,7 @@ func (db *DB) numDepsPollUntil(want int, d time.Duration) int {\n func (db *DB) numFreeConns() int {\n \tdb.mu.Lock()\n \tdefer db.mu.Unlock()\n-\treturn len(db.freeConn)\n+\treturn db.freeConn.Len()\n }\n \n func (db *DB) dumpDeps(t *testing.T) {\n@@ -252,6 +252,9 @@ func TestRowsColumns(t *testing.T) {\n \tif !reflect.DeepEqual(cols, want) {\n \t\tt.Errorf(\"got %#v; want %#v\", cols, want)\n \t}\n+\tif err := rows.Close(); err != nil {\n+\t\tt.Errorf(\"error closing rows: %s\", err)\n+\t}\n }\n \n func TestQueryRow(t *testing.T) {\n@@ -648,10 +651,10 @@ func TestQueryRowClosingStmt(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tif len(db.freeConn) != 1 {\n+\tif db.freeConn.Len() != 1 {\n \t\tt.Fatalf(\"expected 1 free conn\")\n \t}\n-\tfakeConn := db.freeConn[0].ci.(*fakeConn)\n+\tfakeConn := (db.freeConn.Front().Value.(*driverConn)).ci.(*fakeConn)\n \tif made, closed := fakeConn.stmtsMade, fakeConn.stmtsClosed; made != closed {\n \t\tt.Errorf(\"statement close mismatch: made %d, closed %d\", made, closed)\n \t}\n@@ -847,13 +850,13 @@ func TestMaxIdleConns(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \ttx.Commit()\n-\tif got := len(db.freeConn); got != 1 {\n+\tif got := db.freeConn.Len(); got != 1 {\n \t\tt.Errorf(\"freeConns = %d; want 1\", got)\n \t}\n \n \tdb.SetMaxIdleConns(0)\n \n-\tif got := len(db.freeConn); got != 0 {\n+\tif got := db.freeConn.Len(); got != 0 {\n \t\tt.Errorf(\"freeConns after set to zero = %d; want 0\", got)\n \t}\n \n@@ -862,11 +865,146 @@ func TestMaxIdleConns(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \ttx.Commit()\n-\tif got := len(db.freeConn); got != 0 {\n+\tif got := db.freeConn.Len(); got != 0 {\n \t\tt.Errorf(\"freeConns = %d; want 0\", got)\n \t}\n }\n \n+func TestMaxOpenConns(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping in short mode\")\n+\t}\n+\tdefer setHookpostCloseConn(nil)\n+\tsetHookpostCloseConn(func(_ *fakeConn, err error) {\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Error closing fakeConn: %v\", err)\n+\t\t}\n+\t})\n+\n+\tdb := newTestDB(t, \"magicquery\")\n+\tdefer closeDB(t, db)\n+\n+\tdriver := db.driver.(*fakeDriver)\n+\n+\t// Force the number of open connections to 0 so we can get an accurate\n+\t// count for the test\n+\tdb.SetMaxIdleConns(0)\n+\n+\tif g, w := db.numFreeConns(), 0; g != w {\n+\t\tt.Errorf(\"free conns = %d; want %d\", g, w)\n+\t}\n+\n+\tif n := db.numDepsPollUntil(0, time.Second); n > 0 {\n+\t\tt.Errorf(\"number of dependencies = %d; expected 0\", n)\n+\t\tdb.dumpDeps(t)\n+\t}\n+\n+\tdriver.mu.Lock()\n+\topens0 := driver.openCount\n+\tcloses0 := driver.closeCount\n+\tdriver.mu.Unlock()\n+\n+\tdb.SetMaxIdleConns(10)\n+\tdb.SetMaxOpenConns(10)\n+\n+\tstmt, err := db.Prepare(\"SELECT|magicquery|op|op=?,millis=?\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// Start 50 parallel slow queries.\n+\tconst (\n+\t\tnquery      = 50\n+\t\tsleepMillis = 25\n+\t\tnbatch      = 2\n+\t)\n+\tvar wg sync.WaitGroup\n+\tfor batch := 0; batch < nbatch; batch++ {\n+\t\tfor i := 0; i < nquery; i++ {\n+\t\t\twg.Add(1)\n+\t\t\tgo func() {\n+\t\t\t\tdefer wg.Done()\n+\t\t\t\tvar op string\n+\t\t\t\tif err := stmt.QueryRow(\"sleep\", sleepMillis).Scan(&op); err != nil && err != ErrNoRows {\n+\t\t\t\t\tt.Error(err)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t}\n+\t\t// Sleep for twice the expected length of time for the\n+\t\t// batch of 50 queries above to finish before starting\n+\t\t// the next round.\n+\t\ttime.Sleep(2 * sleepMillis * time.Millisecond)\n+\t}\n+\twg.Wait()\n+\n+\tif g, w := db.numFreeConns(), 10; g != w {\n+\t\tt.Errorf(\"free conns = %d; want %d\", g, w)\n+\t}\n+\n+\tif n := db.numDepsPollUntil(20, time.Second); n > 20 {\n+\t\tt.Errorf(\"number of dependencies = %d; expected <= 20\", n)\n+\t\tdb.dumpDeps(t)\n+\t}\n+\n+\tdriver.mu.Lock()\n+\topens := driver.openCount - opens0\n+\tcloses := driver.closeCount - closes0\n+\tdriver.mu.Unlock()\n+\n+\tif opens > 10 {\n+\t\tt.Logf(\"open calls = %d\", opens)\n+\t\tt.Logf(\"close calls = %d\", closes)\n+\t\tt.Errorf(\"db connections opened = %d; want <= 10\", opens)\n+\t\tdb.dumpDeps(t)\n+\t}\n+\n+\tif err := stmt.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif g, w := db.numFreeConns(), 10; g != w {\n+\t\tt.Errorf(\"free conns = %d; want %d\", g, w)\n+\t}\n+\n+\tif n := db.numDepsPollUntil(10, time.Second); n > 10 {\n+\t\tt.Errorf(\"number of dependencies = %d; expected <= 10\", n)\n+\t\tdb.dumpDeps(t)\n+\t}\n+\n+\tdb.SetMaxOpenConns(5)\n+\n+\tif g, w := db.numFreeConns(), 5; g != w {\n+\t\tt.Errorf(\"free conns = %d; want %d\", g, w)\n+\t}\n+\n+\tif n := db.numDepsPollUntil(5, time.Second); n > 5 {\n+\t\tt.Errorf(\"number of dependencies = %d; expected 0\", n)\n+\t\tdb.dumpDeps(t)\n+\t}\n+\n+\tdb.SetMaxOpenConns(0)\n+\n+\tif g, w := db.numFreeConns(), 5; g != w {\n+\t\tt.Errorf(\"free conns = %d; want %d\", g, w)\n+\t}\n+\n+\tif n := db.numDepsPollUntil(5, time.Second); n > 5 {\n+\t\tt.Errorf(\"number of dependencies = %d; expected 0\", n)\n+\t\tdb.dumpDeps(t)\n+\t}\n+\n+\tdb.SetMaxIdleConns(0)\n+\n+\tif g, w := db.numFreeConns(), 0; g != w {\n+\t\tt.Errorf(\"free conns = %d; want %d\", g, w)\n+\t}\n+\n+\tif n := db.numDepsPollUntil(0, time.Second); n > 0 {\n+\t\tt.Errorf(\"number of dependencies = %d; expected 0\", n)\n+\t\tdb.dumpDeps(t)\n+\t}\n+}\n+\n // golang.org/issue/5323\n func TestStmtCloseDeps(t *testing.T) {\n \tif testing.Short() {\n@@ -932,8 +1070,8 @@ func TestStmtCloseDeps(t *testing.T) {\n \tdriver.mu.Lock()\n \topens := driver.openCount - opens0\n \tcloses := driver.closeCount - closes0\n-\tdriver.mu.Unlock()\n \topenDelta := (driver.openCount - driver.closeCount) - openDelta0\n+\tdriver.mu.Unlock()\n \n \tif openDelta > 2 {\n \t\tt.Logf(\"open calls = %d\", opens)\n@@ -991,10 +1129,10 @@ func TestCloseConnBeforeStmts(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \n-\tif len(db.freeConn) != 1 {\n-\t\tt.Fatalf(\"expected 1 freeConn; got %d\", len(db.freeConn))\n+\tif db.freeConn.Len() != 1 {\n+\t\tt.Fatalf(\"expected 1 freeConn; got %d\", db.freeConn.Len())\n \t}\n-\tdc := db.freeConn[0]\n+\tdc := db.freeConn.Front().Value.(*driverConn)\n \tif dc.closed {\n \t\tt.Errorf(\"conn shouldn't be closed\")\n \t}\n@@ -1046,7 +1184,393 @@ func TestRowsCloseOrder(t *testing.T) {\n \t}\n }\n \n-func manyConcurrentQueries(t testOrBench) {\n+func TestRowsImplicitClose(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\trows, err := db.Query(\"SELECT|people|age,name|\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\twant, fail := 2, errors.New(\"fail\")\n+\tr := rows.rowsi.(*rowsCursor)\n+\tr.errPos, r.err = want, fail\n+\n+\tgot := 0\n+\tfor rows.Next() {\n+\t\tgot++\n+\t}\n+\tif got != want {\n+\t\tt.Errorf(\"got %d rows, want %d\", got, want)\n+\t}\n+\tif err := rows.Err(); err != fail {\n+\t\tt.Errorf(\"got error %v, want %v\", err, fail)\n+\t}\n+\tif !r.closed {\n+\t\tt.Errorf(\"r.closed is false, want true\")\n+\t}\n+}\n+\n+func TestStmtCloseOrder(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\tdb.SetMaxIdleConns(0)\n+\tsetStrictFakeConnClose(t)\n+\tdefer setStrictFakeConnClose(nil)\n+\n+\t_, err := db.Query(\"SELECT|non_existent|name|\")\n+\tif err == nil {\n+\t\tt.Fatal(\"Quering non-existent table should fail\")\n+\t}\n+}\n+\n+type concurrentTest interface {\n+\tinit(t testing.TB, db *DB)\n+\tfinish(t testing.TB)\n+\ttest(t testing.TB) error\n+}\n+\n+type concurrentDBQueryTest struct {\n+\tdb *DB\n+}\n+\n+func (c *concurrentDBQueryTest) init(t testing.TB, db *DB) {\n+\tc.db = db\n+}\n+\n+func (c *concurrentDBQueryTest) finish(t testing.TB) {\n+\tc.db = nil\n+}\n+\n+func (c *concurrentDBQueryTest) test(t testing.TB) error {\n+\trows, err := c.db.Query(\"SELECT|people|name|\")\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn err\n+\t}\n+\tvar name string\n+\tfor rows.Next() {\n+\t\trows.Scan(&name)\n+\t}\n+\trows.Close()\n+\treturn nil\n+}\n+\n+type concurrentDBExecTest struct {\n+\tdb *DB\n+}\n+\n+func (c *concurrentDBExecTest) init(t testing.TB, db *DB) {\n+\tc.db = db\n+}\n+\n+func (c *concurrentDBExecTest) finish(t testing.TB) {\n+\tc.db = nil\n+}\n+\n+func (c *concurrentDBExecTest) test(t testing.TB) error {\n+\t_, err := c.db.Exec(\"NOSERT|people|name=Chris,age=?,photo=CPHOTO,bdate=?\", 3, chrisBirthday)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+type concurrentStmtQueryTest struct {\n+\tdb   *DB\n+\tstmt *Stmt\n+}\n+\n+func (c *concurrentStmtQueryTest) init(t testing.TB, db *DB) {\n+\tc.db = db\n+\tvar err error\n+\tc.stmt, err = db.Prepare(\"SELECT|people|name|\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func (c *concurrentStmtQueryTest) finish(t testing.TB) {\n+\tif c.stmt != nil {\n+\t\tc.stmt.Close()\n+\t\tc.stmt = nil\n+\t}\n+\tc.db = nil\n+}\n+\n+func (c *concurrentStmtQueryTest) test(t testing.TB) error {\n+\trows, err := c.stmt.Query()\n+\tif err != nil {\n+\t\tt.Errorf(\"error on query:  %v\", err)\n+\t\treturn err\n+\t}\n+\n+\tvar name string\n+\tfor rows.Next() {\n+\t\trows.Scan(&name)\n+\t}\n+\trows.Close()\n+\treturn nil\n+}\n+\n+type concurrentStmtExecTest struct {\n+\tdb   *DB\n+\tstmt *Stmt\n+}\n+\n+func (c *concurrentStmtExecTest) init(t testing.TB, db *DB) {\n+\tc.db = db\n+\tvar err error\n+\tc.stmt, err = db.Prepare(\"NOSERT|people|name=Chris,age=?,photo=CPHOTO,bdate=?\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func (c *concurrentStmtExecTest) finish(t testing.TB) {\n+\tif c.stmt != nil {\n+\t\tc.stmt.Close()\n+\t\tc.stmt = nil\n+\t}\n+\tc.db = nil\n+}\n+\n+func (c *concurrentStmtExecTest) test(t testing.TB) error {\n+\t_, err := c.stmt.Exec(3, chrisBirthday)\n+\tif err != nil {\n+\t\tt.Errorf(\"error on exec:  %v\", err)\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+type concurrentTxQueryTest struct {\n+\tdb *DB\n+\ttx *Tx\n+}\n+\n+func (c *concurrentTxQueryTest) init(t testing.TB, db *DB) {\n+\tc.db = db\n+\tvar err error\n+\tc.tx, err = c.db.Begin()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func (c *concurrentTxQueryTest) finish(t testing.TB) {\n+\tif c.tx != nil {\n+\t\tc.tx.Rollback()\n+\t\tc.tx = nil\n+\t}\n+\tc.db = nil\n+}\n+\n+func (c *concurrentTxQueryTest) test(t testing.TB) error {\n+\trows, err := c.db.Query(\"SELECT|people|name|\")\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn err\n+\t}\n+\tvar name string\n+\tfor rows.Next() {\n+\t\trows.Scan(&name)\n+\t}\n+\trows.Close()\n+\treturn nil\n+}\n+\n+type concurrentTxExecTest struct {\n+\tdb *DB\n+\ttx *Tx\n+}\n+\n+func (c *concurrentTxExecTest) init(t testing.TB, db *DB) {\n+\tc.db = db\n+\tvar err error\n+\tc.tx, err = c.db.Begin()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func (c *concurrentTxExecTest) finish(t testing.TB) {\n+\tif c.tx != nil {\n+\t\tc.tx.Rollback()\n+\t\tc.tx = nil\n+\t}\n+\tc.db = nil\n+}\n+\n+func (c *concurrentTxExecTest) test(t testing.TB) error {\n+\t_, err := c.tx.Exec(\"NOSERT|people|name=Chris,age=?,photo=CPHOTO,bdate=?\", 3, chrisBirthday)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+type concurrentTxStmtQueryTest struct {\n+\tdb   *DB\n+\ttx   *Tx\n+\tstmt *Stmt\n+}\n+\n+func (c *concurrentTxStmtQueryTest) init(t testing.TB, db *DB) {\n+\tc.db = db\n+\tvar err error\n+\tc.tx, err = c.db.Begin()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tc.stmt, err = c.tx.Prepare(\"SELECT|people|name|\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func (c *concurrentTxStmtQueryTest) finish(t testing.TB) {\n+\tif c.stmt != nil {\n+\t\tc.stmt.Close()\n+\t\tc.stmt = nil\n+\t}\n+\tif c.tx != nil {\n+\t\tc.tx.Rollback()\n+\t\tc.tx = nil\n+\t}\n+\tc.db = nil\n+}\n+\n+func (c *concurrentTxStmtQueryTest) test(t testing.TB) error {\n+\trows, err := c.stmt.Query()\n+\tif err != nil {\n+\t\tt.Errorf(\"error on query:  %v\", err)\n+\t\treturn err\n+\t}\n+\n+\tvar name string\n+\tfor rows.Next() {\n+\t\trows.Scan(&name)\n+\t}\n+\trows.Close()\n+\treturn nil\n+}\n+\n+type concurrentTxStmtExecTest struct {\n+\tdb   *DB\n+\ttx   *Tx\n+\tstmt *Stmt\n+}\n+\n+func (c *concurrentTxStmtExecTest) init(t testing.TB, db *DB) {\n+\tc.db = db\n+\tvar err error\n+\tc.tx, err = c.db.Begin()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tc.stmt, err = c.tx.Prepare(\"NOSERT|people|name=Chris,age=?,photo=CPHOTO,bdate=?\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func (c *concurrentTxStmtExecTest) finish(t testing.TB) {\n+\tif c.stmt != nil {\n+\t\tc.stmt.Close()\n+\t\tc.stmt = nil\n+\t}\n+\tif c.tx != nil {\n+\t\tc.tx.Rollback()\n+\t\tc.tx = nil\n+\t}\n+\tc.db = nil\n+}\n+\n+func (c *concurrentTxStmtExecTest) test(t testing.TB) error {\n+\t_, err := c.stmt.Exec(3, chrisBirthday)\n+\tif err != nil {\n+\t\tt.Errorf(\"error on exec:  %v\", err)\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+type concurrentRandomTest struct {\n+\ttests []concurrentTest\n+}\n+\n+func (c *concurrentRandomTest) init(t testing.TB, db *DB) {\n+\tc.tests = []concurrentTest{\n+\t\tnew(concurrentDBQueryTest),\n+\t\tnew(concurrentDBExecTest),\n+\t\tnew(concurrentStmtQueryTest),\n+\t\tnew(concurrentStmtExecTest),\n+\t\tnew(concurrentTxQueryTest),\n+\t\tnew(concurrentTxExecTest),\n+\t\tnew(concurrentTxStmtQueryTest),\n+\t\tnew(concurrentTxStmtExecTest),\n+\t}\n+\tfor _, ct := range c.tests {\n+\t\tct.init(t, db)\n+\t}\n+}\n+\n+func (c *concurrentRandomTest) finish(t testing.TB) {\n+\tfor _, ct := range c.tests {\n+\t\tct.finish(t)\n+\t}\n+}\n+\n+func (c *concurrentRandomTest) test(t testing.TB) error {\n+\tct := c.tests[rand.Intn(len(c.tests))]\n+\treturn ct.test(t)\n+}\n+\n+func doConcurrentTest(t testing.TB, ct concurrentTest) {\n+\tmaxProcs, numReqs := 1, 500\n+\tif testing.Short() {\n+\t\tmaxProcs, numReqs = 4, 50\n+\t}\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(maxProcs))\n+\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\tct.init(t, db)\n+\tdefer ct.finish(t)\n+\n+\tvar wg sync.WaitGroup\n+\twg.Add(numReqs)\n+\n+\treqs := make(chan bool)\n+\tdefer close(reqs)\n+\n+\tfor i := 0; i < maxProcs*2; i++ {\n+\t\tgo func() {\n+\t\t\tfor _ = range reqs {\n+\t\t\t\terr := ct.test(t)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\twg.Done()\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\twg.Done()\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\tfor i := 0; i < numReqs; i++ {\n+\t\treqs <- true\n+\t}\n+\n+\twg.Wait()\n+}\n+\n+func manyConcurrentQueries(t testing.TB) {\n \tmaxProcs, numReqs := 16, 500\n \tif testing.Short() {\n \t\tmaxProcs, numReqs = 4, 50\n@@ -1096,13 +1620,174 @@ func manyConcurrentQueries(t testOrBench) {\n \twg.Wait()\n }\n \n+func TestIssue6081(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\tdrv := db.driver.(*fakeDriver)\n+\tdrv.mu.Lock()\n+\topens0 := drv.openCount\n+\tcloses0 := drv.closeCount\n+\tdrv.mu.Unlock()\n+\n+\tstmt, err := db.Prepare(\"SELECT|people|name|\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\trowsCloseHook = func(rows *Rows, err *error) {\n+\t\t*err = driver.ErrBadConn\n+\t}\n+\tdefer func() { rowsCloseHook = nil }()\n+\tfor i := 0; i < 10; i++ {\n+\t\trows, err := stmt.Query()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\trows.Close()\n+\t}\n+\tif n := len(stmt.css); n > 1 {\n+\t\tt.Errorf(\"len(css slice) = %d; want <= 1\", n)\n+\t}\n+\tstmt.Close()\n+\tif n := len(stmt.css); n != 0 {\n+\t\tt.Errorf(\"len(css slice) after Close = %d; want 0\", n)\n+\t}\n+\n+\tdrv.mu.Lock()\n+\topens := drv.openCount - opens0\n+\tcloses := drv.closeCount - closes0\n+\tdrv.mu.Unlock()\n+\tif opens < 9 {\n+\t\tt.Errorf(\"opens = %d; want >= 9\", opens)\n+\t}\n+\tif closes < 9 {\n+\t\tt.Errorf(\"closes = %d; want >= 9\", closes)\n+\t}\n+}\n+\n func TestConcurrency(t *testing.T) {\n-\tmanyConcurrentQueries(t)\n+\tdoConcurrentTest(t, new(concurrentDBQueryTest))\n+\tdoConcurrentTest(t, new(concurrentDBExecTest))\n+\tdoConcurrentTest(t, new(concurrentStmtQueryTest))\n+\tdoConcurrentTest(t, new(concurrentStmtExecTest))\n+\tdoConcurrentTest(t, new(concurrentTxQueryTest))\n+\tdoConcurrentTest(t, new(concurrentTxExecTest))\n+\tdoConcurrentTest(t, new(concurrentTxStmtQueryTest))\n+\tdoConcurrentTest(t, new(concurrentTxStmtExecTest))\n+\tdoConcurrentTest(t, new(concurrentRandomTest))\n+}\n+\n+func TestConnectionLeak(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\t// Start by opening defaultMaxIdleConns\n+\trows := make([]*Rows, defaultMaxIdleConns)\n+\t// We need to SetMaxOpenConns > MaxIdleConns, so the DB can open\n+\t// a new connection and we can fill the idle queue with the released\n+\t// connections.\n+\tdb.SetMaxOpenConns(len(rows) + 1)\n+\tfor ii := range rows {\n+\t\tr, err := db.Query(\"SELECT|people|name|\")\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tr.Next()\n+\t\tif err := r.Err(); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\trows[ii] = r\n+\t}\n+\t// Now we have defaultMaxIdleConns busy connections. Open\n+\t// a new one, but wait until the busy connections are released\n+\t// before returning control to DB.\n+\tdrv := db.driver.(*fakeDriver)\n+\tdrv.waitCh = make(chan struct{}, 1)\n+\tdrv.waitingCh = make(chan struct{}, 1)\n+\tvar wg sync.WaitGroup\n+\twg.Add(1)\n+\tgo func() {\n+\t\tr, err := db.Query(\"SELECT|people|name|\")\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tr.Close()\n+\t\twg.Done()\n+\t}()\n+\t// Wait until the goroutine we've just created has started waiting.\n+\t<-drv.waitingCh\n+\t// Now close the busy connections. This provides a connection for\n+\t// the blocked goroutine and then fills up the idle queue.\n+\tfor _, v := range rows {\n+\t\tv.Close()\n+\t}\n+\t// At this point we give the new connection to DB. This connection is\n+\t// now useless, since the idle queue is full and there are no pending\n+\t// requests. DB should deal with this situation without leaking the\n+\t// connection.\n+\tdrv.waitCh <- struct{}{}\n+\twg.Wait()\n+}\n+\n+func BenchmarkConcurrentDBExec(b *testing.B) {\n+\tb.ReportAllocs()\n+\tct := new(concurrentDBExecTest)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdoConcurrentTest(b, ct)\n+\t}\n+}\n+\n+func BenchmarkConcurrentStmtQuery(b *testing.B) {\n+\tb.ReportAllocs()\n+\tct := new(concurrentStmtQueryTest)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdoConcurrentTest(b, ct)\n+\t}\n+}\n+\n+func BenchmarkConcurrentStmtExec(b *testing.B) {\n+\tb.ReportAllocs()\n+\tct := new(concurrentStmtExecTest)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdoConcurrentTest(b, ct)\n+\t}\n+}\n+\n+func BenchmarkConcurrentTxQuery(b *testing.B) {\n+\tb.ReportAllocs()\n+\tct := new(concurrentTxQueryTest)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdoConcurrentTest(b, ct)\n+\t}\n+}\n+\n+func BenchmarkConcurrentTxExec(b *testing.B) {\n+\tb.ReportAllocs()\n+\tct := new(concurrentTxExecTest)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdoConcurrentTest(b, ct)\n+\t}\n+}\n+\n+func BenchmarkConcurrentTxStmtQuery(b *testing.B) {\n+\tb.ReportAllocs()\n+\tct := new(concurrentTxStmtQueryTest)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdoConcurrentTest(b, ct)\n+\t}\n+}\n+\n+func BenchmarkConcurrentTxStmtExec(b *testing.B) {\n+\tb.ReportAllocs()\n+\tct := new(concurrentTxStmtExecTest)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdoConcurrentTest(b, ct)\n+\t}\n }\n \n-func BenchmarkConcurrency(b *testing.B) {\n+func BenchmarkConcurrentRandom(b *testing.B) {\n \tb.ReportAllocs()\n+\tct := new(concurrentRandomTest)\n \tfor i := 0; i < b.N; i++ {\n-\t\tmanyConcurrentQueries(b)\n+\t\tdoConcurrentTest(b, ct)\n \t}\n }"}, {"sha": "4775283ca3a5f1725432ddc7afa68a9ed174d051", "filename": "libgo/go/debug/dwarf/entry.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -10,7 +10,10 @@\n \n package dwarf\n \n-import \"errors\"\n+import (\n+\t\"errors\"\n+\t\"strconv\"\n+)\n \n // a single entry's description: a sequence of attributes\n type abbrev struct {\n@@ -152,7 +155,7 @@ func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {\n \t\tvar val interface{}\n \t\tswitch fmt {\n \t\tdefault:\n-\t\t\tb.error(\"unknown entry attr format\")\n+\t\t\tb.error(\"unknown entry attr format 0x\" + strconv.FormatInt(int64(fmt), 16))\n \n \t\t// address\n \t\tcase formAddr:"}, {"sha": "1fbae6c144ea53d609dc547dc3f76a4c9182ff72", "filename": "libgo/go/debug/dwarf/type.go", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -271,24 +271,43 @@ func (d *Data) Type(off Offset) (Type, error) {\n \t// d.Type recursively, to handle circular types correctly.\n \tvar typ Type\n \n+\tnextDepth := 0\n+\n \t// Get next child; set err if error happens.\n \tnext := func() *Entry {\n \t\tif !e.Children {\n \t\t\treturn nil\n \t\t}\n-\t\tkid, err1 := r.Next()\n-\t\tif err1 != nil {\n-\t\t\terr = err1\n-\t\t\treturn nil\n-\t\t}\n-\t\tif kid == nil {\n-\t\t\terr = DecodeError{\"info\", r.b.off, \"unexpected end of DWARF entries\"}\n-\t\t\treturn nil\n-\t\t}\n-\t\tif kid.Tag == 0 {\n-\t\t\treturn nil\n+\t\t// Only return direct children.\n+\t\t// Skip over composite entries that happen to be nested\n+\t\t// inside this one. Most DWARF generators wouldn't generate\n+\t\t// such a thing, but clang does.\n+\t\t// See golang.org/issue/6472.\n+\t\tfor {\n+\t\t\tkid, err1 := r.Next()\n+\t\t\tif err1 != nil {\n+\t\t\t\terr = err1\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif kid == nil {\n+\t\t\t\terr = DecodeError{\"info\", r.b.off, \"unexpected end of DWARF entries\"}\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif kid.Tag == 0 {\n+\t\t\t\tif nextDepth > 0 {\n+\t\t\t\t\tnextDepth--\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif kid.Children {\n+\t\t\t\tnextDepth++\n+\t\t\t}\n+\t\t\tif nextDepth > 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn kid\n \t\t}\n-\t\treturn kid\n \t}\n \n \t// Get Type referred to by Entry's AttrType field."}, {"sha": "38b5f9e70756b6f304d0bb7ea1fd5114cebba3e1", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -166,6 +166,7 @@ func TestOpen(t *testing.T) {\n \t\t} else {\n \t\t\tf, err = Open(tt.file)\n \t\t}\n+\t\tdefer f.Close()\n \t\tif err != nil {\n \t\t\tt.Errorf(\"cannot open file %s: %v\", tt.file, err)\n \t\t\tcontinue"}, {"sha": "3e6a8046b3e35e45beb591b747532ba92a6673d8", "filename": "libgo/go/debug/gosym/pclntab.go", "status": "modified", "additions": 352, "deletions": 8, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -8,16 +8,47 @@\n \n package gosym\n \n-import \"encoding/binary\"\n+import (\n+\t\"encoding/binary\"\n+\t\"sync\"\n+)\n \n+// A LineTable is a data structure mapping program counters to line numbers.\n+//\n+// In Go 1.1 and earlier, each function (represented by a Func) had its own LineTable,\n+// and the line number corresponded to a numbering of all source lines in the\n+// program, across all files. That absolute line number would then have to be\n+// converted separately to a file name and line number within the file.\n+//\n+// In Go 1.2, the format of the data changed so that there is a single LineTable\n+// for the entire program, shared by all Funcs, and there are no absolute line\n+// numbers, just line numbers within specific files.\n+//\n+// For the most part, LineTable's methods should be treated as an internal\n+// detail of the package; callers should use the methods on Table instead.\n type LineTable struct {\n \tData []byte\n \tPC   uint64\n \tLine int\n+\n+\t// Go 1.2 state\n+\tmu       sync.Mutex\n+\tgo12     int // is this in Go 1.2 format? -1 no, 0 unknown, 1 yes\n+\tbinary   binary.ByteOrder\n+\tquantum  uint32\n+\tptrsize  uint32\n+\tfunctab  []byte\n+\tnfunctab uint32\n+\tfiletab  []byte\n+\tnfiletab uint32\n+\tfileMap  map[string]uint32\n }\n \n-// TODO(rsc): Need to pull in quantum from architecture definition.\n-const quantum = 1\n+// NOTE(rsc): This is wrong for GOARCH=arm, which uses a quantum of 4,\n+// but we have no idea whether we're using arm or not. This only\n+// matters in the old (pre-Go 1.2) symbol table format, so it's not worth\n+// fixing.\n+const oldQuantum = 1\n \n func (t *LineTable) parse(targetPC uint64, targetLine int) (b []byte, pc uint64, line int) {\n \t// The PC/line table can be thought of as a sequence of\n@@ -46,37 +77,350 @@ func (t *LineTable) parse(targetPC uint64, targetLine int) (b []byte, pc uint64,\n \t\tcase code <= 128:\n \t\t\tline -= int(code - 64)\n \t\tdefault:\n-\t\t\tpc += quantum * uint64(code-128)\n+\t\t\tpc += oldQuantum * uint64(code-128)\n \t\t\tcontinue\n \t\t}\n-\t\tpc += quantum\n+\t\tpc += oldQuantum\n \t}\n \treturn b, pc, line\n }\n \n func (t *LineTable) slice(pc uint64) *LineTable {\n \tdata, pc, line := t.parse(pc, -1)\n-\treturn &LineTable{data, pc, line}\n+\treturn &LineTable{Data: data, PC: pc, Line: line}\n }\n \n+// PCToLine returns the line number for the given program counter.\n+// Callers should use Table's PCToLine method instead.\n func (t *LineTable) PCToLine(pc uint64) int {\n+\tif t.isGo12() {\n+\t\treturn t.go12PCToLine(pc)\n+\t}\n \t_, _, line := t.parse(pc, -1)\n \treturn line\n }\n \n+// LineToPC returns the program counter for the given line number,\n+// considering only program counters before maxpc.\n+// Callers should use Table's LineToPC method instead.\n func (t *LineTable) LineToPC(line int, maxpc uint64) uint64 {\n+\tif t.isGo12() {\n+\t\treturn 0\n+\t}\n \t_, pc, line1 := t.parse(maxpc, line)\n \tif line1 != line {\n \t\treturn 0\n \t}\n \t// Subtract quantum from PC to account for post-line increment\n-\treturn pc - quantum\n+\treturn pc - oldQuantum\n }\n \n // NewLineTable returns a new PC/line table\n // corresponding to the encoded data.\n // Text must be the start address of the\n // corresponding text segment.\n func NewLineTable(data []byte, text uint64) *LineTable {\n-\treturn &LineTable{data, text, 0}\n+\treturn &LineTable{Data: data, PC: text, Line: 0}\n+}\n+\n+// Go 1.2 symbol table format.\n+// See golang.org/s/go12symtab.\n+//\n+// A general note about the methods here: rather than try to avoid\n+// index out of bounds errors, we trust Go to detect them, and then\n+// we recover from the panics and treat them as indicative of a malformed\n+// or incomplete table.\n+//\n+// The methods called by symtab.go, which begin with \"go12\" prefixes,\n+// are expected to have that recovery logic.\n+\n+// isGo12 reports whether this is a Go 1.2 (or later) symbol table.\n+func (t *LineTable) isGo12() bool {\n+\tt.go12Init()\n+\treturn t.go12 == 1\n+}\n+\n+const go12magic = 0xfffffffb\n+\n+// uintptr returns the pointer-sized value encoded at b.\n+// The pointer size is dictated by the table being read.\n+func (t *LineTable) uintptr(b []byte) uint64 {\n+\tif t.ptrsize == 4 {\n+\t\treturn uint64(t.binary.Uint32(b))\n+\t}\n+\treturn t.binary.Uint64(b)\n+}\n+\n+// go12init initializes the Go 1.2 metadata if t is a Go 1.2 symbol table.\n+func (t *LineTable) go12Init() {\n+\tt.mu.Lock()\n+\tdefer t.mu.Unlock()\n+\tif t.go12 != 0 {\n+\t\treturn\n+\t}\n+\n+\tdefer func() {\n+\t\t// If we panic parsing, assume it's not a Go 1.2 symbol table.\n+\t\trecover()\n+\t}()\n+\n+\t// Check header: 4-byte magic, two zeros, pc quantum, pointer size.\n+\tt.go12 = -1 // not Go 1.2 until proven otherwise\n+\tif len(t.Data) < 16 || t.Data[4] != 0 || t.Data[5] != 0 ||\n+\t\t(t.Data[6] != 1 && t.Data[6] != 4) || // pc quantum\n+\t\t(t.Data[7] != 4 && t.Data[7] != 8) { // pointer size\n+\t\treturn\n+\t}\n+\n+\tswitch uint32(go12magic) {\n+\tcase binary.LittleEndian.Uint32(t.Data):\n+\t\tt.binary = binary.LittleEndian\n+\tcase binary.BigEndian.Uint32(t.Data):\n+\t\tt.binary = binary.BigEndian\n+\tdefault:\n+\t\treturn\n+\t}\n+\n+\tt.quantum = uint32(t.Data[6])\n+\tt.ptrsize = uint32(t.Data[7])\n+\n+\tt.nfunctab = uint32(t.uintptr(t.Data[8:]))\n+\tt.functab = t.Data[8+t.ptrsize:]\n+\tfunctabsize := t.nfunctab*2*t.ptrsize + t.ptrsize\n+\tfileoff := t.binary.Uint32(t.functab[functabsize:])\n+\tt.functab = t.functab[:functabsize]\n+\tt.filetab = t.Data[fileoff:]\n+\tt.nfiletab = t.binary.Uint32(t.filetab)\n+\tt.filetab = t.filetab[:t.nfiletab*4]\n+\n+\tt.go12 = 1 // so far so good\n+}\n+\n+// findFunc returns the func corresponding to the given program counter.\n+func (t *LineTable) findFunc(pc uint64) []byte {\n+\tif pc < t.uintptr(t.functab) || pc >= t.uintptr(t.functab[len(t.functab)-int(t.ptrsize):]) {\n+\t\treturn nil\n+\t}\n+\n+\t// The function table is a list of 2*nfunctab+1 uintptrs,\n+\t// alternating program counters and offsets to func structures.\n+\tf := t.functab\n+\tnf := t.nfunctab\n+\tfor nf > 0 {\n+\t\tm := nf / 2\n+\t\tfm := f[2*t.ptrsize*m:]\n+\t\tif t.uintptr(fm) <= pc && pc < t.uintptr(fm[2*t.ptrsize:]) {\n+\t\t\treturn t.Data[t.uintptr(fm[t.ptrsize:]):]\n+\t\t} else if pc < t.uintptr(fm) {\n+\t\t\tnf = m\n+\t\t} else {\n+\t\t\tf = f[(m+1)*2*t.ptrsize:]\n+\t\t\tnf -= m + 1\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// readvarint reads, removes, and returns a varint from *pp.\n+func (t *LineTable) readvarint(pp *[]byte) uint32 {\n+\tvar v, shift uint32\n+\tp := *pp\n+\tfor shift = 0; ; shift += 7 {\n+\t\tb := p[0]\n+\t\tp = p[1:]\n+\t\tv |= (uint32(b) & 0x7F) << shift\n+\t\tif b&0x80 == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\t*pp = p\n+\treturn v\n+}\n+\n+// string returns a Go string found at off.\n+func (t *LineTable) string(off uint32) string {\n+\tfor i := off; ; i++ {\n+\t\tif t.Data[i] == 0 {\n+\t\t\treturn string(t.Data[off:i])\n+\t\t}\n+\t}\n+}\n+\n+// step advances to the next pc, value pair in the encoded table.\n+func (t *LineTable) step(p *[]byte, pc *uint64, val *int32, first bool) bool {\n+\tuvdelta := t.readvarint(p)\n+\tif uvdelta == 0 && !first {\n+\t\treturn false\n+\t}\n+\tif uvdelta&1 != 0 {\n+\t\tuvdelta = ^(uvdelta >> 1)\n+\t} else {\n+\t\tuvdelta >>= 1\n+\t}\n+\tvdelta := int32(uvdelta)\n+\tpcdelta := t.readvarint(p) * t.quantum\n+\t*pc += uint64(pcdelta)\n+\t*val += vdelta\n+\treturn true\n+}\n+\n+// pcvalue reports the value associated with the target pc.\n+// off is the offset to the beginning of the pc-value table,\n+// and entry is the start PC for the corresponding function.\n+func (t *LineTable) pcvalue(off uint32, entry, targetpc uint64) int32 {\n+\tif off == 0 {\n+\t\treturn -1\n+\t}\n+\tp := t.Data[off:]\n+\n+\tval := int32(-1)\n+\tpc := entry\n+\tfor t.step(&p, &pc, &val, pc == entry) {\n+\t\tif targetpc < pc {\n+\t\t\treturn val\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n+// findFileLine scans one function in the binary looking for a\n+// program counter in the given file on the given line.\n+// It does so by running the pc-value tables mapping program counter\n+// to file number. Since most functions come from a single file, these\n+// are usually short and quick to scan. If a file match is found, then the\n+// code goes to the expense of looking for a simultaneous line number match.\n+func (t *LineTable) findFileLine(entry uint64, filetab, linetab uint32, filenum, line int32) uint64 {\n+\tif filetab == 0 || linetab == 0 {\n+\t\treturn 0\n+\t}\n+\n+\tfp := t.Data[filetab:]\n+\tfl := t.Data[linetab:]\n+\tfileVal := int32(-1)\n+\tfilePC := entry\n+\tlineVal := int32(-1)\n+\tlinePC := entry\n+\tfileStartPC := filePC\n+\tfor t.step(&fp, &filePC, &fileVal, filePC == entry) {\n+\t\tif fileVal == filenum && fileStartPC < filePC {\n+\t\t\t// fileVal is in effect starting at fileStartPC up to\n+\t\t\t// but not including filePC, and it's the file we want.\n+\t\t\t// Run the PC table looking for a matching line number\n+\t\t\t// or until we reach filePC.\n+\t\t\tlineStartPC := linePC\n+\t\t\tfor linePC < filePC && t.step(&fl, &linePC, &lineVal, linePC == entry) {\n+\t\t\t\t// lineVal is in effect until linePC, and lineStartPC < filePC.\n+\t\t\t\tif lineVal == line {\n+\t\t\t\t\tif fileStartPC <= lineStartPC {\n+\t\t\t\t\t\treturn lineStartPC\n+\t\t\t\t\t}\n+\t\t\t\t\tif fileStartPC < linePC {\n+\t\t\t\t\t\treturn fileStartPC\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tlineStartPC = linePC\n+\t\t\t}\n+\t\t}\n+\t\tfileStartPC = filePC\n+\t}\n+\treturn 0\n+}\n+\n+// go12PCToLine maps program counter to line number for the Go 1.2 pcln table.\n+func (t *LineTable) go12PCToLine(pc uint64) (line int) {\n+\tdefer func() {\n+\t\tif recover() != nil {\n+\t\t\tline = -1\n+\t\t}\n+\t}()\n+\n+\tf := t.findFunc(pc)\n+\tif f == nil {\n+\t\treturn -1\n+\t}\n+\tentry := t.uintptr(f)\n+\tlinetab := t.binary.Uint32(f[t.ptrsize+5*4:])\n+\treturn int(t.pcvalue(linetab, entry, pc))\n+}\n+\n+// go12PCToFile maps program counter to file name for the Go 1.2 pcln table.\n+func (t *LineTable) go12PCToFile(pc uint64) (file string) {\n+\tdefer func() {\n+\t\tif recover() != nil {\n+\t\t\tfile = \"\"\n+\t\t}\n+\t}()\n+\n+\tf := t.findFunc(pc)\n+\tif f == nil {\n+\t\treturn \"\"\n+\t}\n+\tentry := t.uintptr(f)\n+\tfiletab := t.binary.Uint32(f[t.ptrsize+4*4:])\n+\tfno := t.pcvalue(filetab, entry, pc)\n+\tif fno <= 0 {\n+\t\treturn \"\"\n+\t}\n+\treturn t.string(t.binary.Uint32(t.filetab[4*fno:]))\n+}\n+\n+// go12LineToPC maps a (file, line) pair to a program counter for the Go 1.2 pcln table.\n+func (t *LineTable) go12LineToPC(file string, line int) (pc uint64) {\n+\tdefer func() {\n+\t\tif recover() != nil {\n+\t\t\tpc = 0\n+\t\t}\n+\t}()\n+\n+\tt.initFileMap()\n+\tfilenum := t.fileMap[file]\n+\tif filenum == 0 {\n+\t\treturn 0\n+\t}\n+\n+\t// Scan all functions.\n+\t// If this turns out to be a bottleneck, we could build a map[int32][]int32\n+\t// mapping file number to a list of functions with code from that file.\n+\tfor i := uint32(0); i < t.nfunctab; i++ {\n+\t\tf := t.Data[t.uintptr(t.functab[2*t.ptrsize*i+t.ptrsize:]):]\n+\t\tentry := t.uintptr(f)\n+\t\tfiletab := t.binary.Uint32(f[t.ptrsize+4*4:])\n+\t\tlinetab := t.binary.Uint32(f[t.ptrsize+5*4:])\n+\t\tpc := t.findFileLine(entry, filetab, linetab, int32(filenum), int32(line))\n+\t\tif pc != 0 {\n+\t\t\treturn pc\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+// initFileMap initializes the map from file name to file number.\n+func (t *LineTable) initFileMap() {\n+\tt.mu.Lock()\n+\tdefer t.mu.Unlock()\n+\n+\tif t.fileMap != nil {\n+\t\treturn\n+\t}\n+\tm := make(map[string]uint32)\n+\n+\tfor i := uint32(1); i < t.nfiletab; i++ {\n+\t\ts := t.string(t.binary.Uint32(t.filetab[4*i:]))\n+\t\tm[s] = i\n+\t}\n+\tt.fileMap = m\n+}\n+\n+// go12MapFiles adds to m a key for every file in the Go 1.2 LineTable.\n+// Every key maps to obj. That's not a very interesting map, but it provides\n+// a way for callers to obtain the list of files in the program.\n+func (t *LineTable) go12MapFiles(m map[string]*Obj, obj *Obj) {\n+\tdefer func() {\n+\t\trecover()\n+\t}()\n+\n+\tt.initFileMap()\n+\tfor file := range t.fileMap {\n+\t\tm[file] = obj\n+\t}\n }"}, {"sha": "35502e8c39551b835a755a8454aecf228e495405", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -21,9 +21,17 @@ var (\n \tpclinetestBinary string\n )\n \n-func dotest() bool {\n-\t// For now, only works on ELF platforms.\n-\tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n+func dotest(self bool) bool {\n+\t// For now, only works on amd64 platforms.\n+\tif runtime.GOARCH != \"amd64\" {\n+\t\treturn false\n+\t}\n+\t// Self test reads test binary; only works on Linux.\n+\tif self && runtime.GOOS != \"linux\" {\n+\t\treturn false\n+\t}\n+\t// Command below expects \"sh\", so Unix.\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n \t\treturn false\n \t}\n \tif pclinetestBinary != \"\" {\n@@ -41,7 +49,7 @@ func dotest() bool {\n \t// the resulting binary looks like it was built from pclinetest.s,\n \t// but we have renamed it to keep it away from the go tool.\n \tpclinetestBinary = filepath.Join(pclineTempDir, \"pclinetest\")\n-\tcommand := fmt.Sprintf(\"go tool 6a -o %s.6 pclinetest.asm && go tool 6l -E main -o %s %s.6\",\n+\tcommand := fmt.Sprintf(\"go tool 6a -o %s.6 pclinetest.asm && go tool 6l -H linux -E main -o %s %s.6\",\n \t\tpclinetestBinary, pclinetestBinary, pclinetestBinary)\n \tcmd := exec.Command(\"sh\", \"-c\", command)\n \tcmd.Stdout = os.Stdout\n@@ -100,12 +108,16 @@ func parse(file string, f *elf.File, t *testing.T) (*elf.File, *Table) {\n var goarch = os.Getenv(\"O\")\n \n func TestLineFromAline(t *testing.T) {\n-\tif !dotest() {\n+\tif !dotest(true) {\n \t\treturn\n \t}\n \tdefer endtest()\n \n \ttab := getTable(t)\n+\tif tab.go12line != nil {\n+\t\t// aline's don't exist in the Go 1.2 table.\n+\t\tt.Skip(\"not relevant to Go 1.2 symbol table\")\n+\t}\n \n \t// Find the sym package\n \tpkg := tab.LookupFunc(\"debug/gosym.TestLineFromAline\").Obj\n@@ -148,12 +160,16 @@ func TestLineFromAline(t *testing.T) {\n }\n \n func TestLineAline(t *testing.T) {\n-\tif !dotest() {\n+\tif !dotest(true) {\n \t\treturn\n \t}\n \tdefer endtest()\n \n \ttab := getTable(t)\n+\tif tab.go12line != nil {\n+\t\t// aline's don't exist in the Go 1.2 table.\n+\t\tt.Skip(\"not relevant to Go 1.2 symbol table\")\n+\t}\n \n \tfor _, o := range tab.Files {\n \t\t// A source file can appear multiple times in a\n@@ -190,7 +206,7 @@ func TestLineAline(t *testing.T) {\n }\n \n func TestPCLine(t *testing.T) {\n-\tif !dotest() {\n+\tif !dotest(false) {\n \t\treturn\n \t}\n \tdefer endtest()\n@@ -206,16 +222,17 @@ func TestPCLine(t *testing.T) {\n \tsym := tab.LookupFunc(\"linefrompc\")\n \twantLine := 0\n \tfor pc := sym.Entry; pc < sym.End; pc++ {\n-\t\tfile, line, fn := tab.PCToLine(pc)\n \t\toff := pc - text.Addr // TODO(rsc): should not need off; bug in 8g\n+\t\tif textdat[off] == 255 {\n+\t\t\tbreak\n+\t\t}\n \t\twantLine += int(textdat[off])\n-\t\tt.Logf(\"off is %d\", off)\n+\t\tt.Logf(\"off is %d %#x (max %d)\", off, textdat[off], sym.End-pc)\n+\t\tfile, line, fn := tab.PCToLine(pc)\n \t\tif fn == nil {\n \t\t\tt.Errorf(\"failed to get line of PC %#x\", pc)\n-\t\t} else if !strings.HasSuffix(file, \"pclinetest.asm\") {\n-\t\t\tt.Errorf(\"expected %s (%s) at PC %#x, got %s (%s)\", \"pclinetest.asm\", sym.Name, pc, file, fn.Name)\n-\t\t} else if line != wantLine || fn != sym {\n-\t\t\tt.Errorf(\"expected :%d (%s) at PC %#x, got :%d (%s)\", wantLine, sym.Name, pc, line, fn.Name)\n+\t\t} else if !strings.HasSuffix(file, \"pclinetest.asm\") || line != wantLine || fn != sym {\n+\t\t\tt.Errorf(\"PCToLine(%#x) = %s:%d (%s), want %s:%d (%s)\", pc, file, line, fn.Name, \"pclinetest.asm\", wantLine, sym.Name)\n \t\t}\n \t}\n \n@@ -227,6 +244,9 @@ func TestPCLine(t *testing.T) {\n \tfor pc := sym.Value; pc < sym.End; pc += 2 + uint64(textdat[off]) {\n \t\tfile, line, fn := tab.PCToLine(pc)\n \t\toff = pc - text.Addr\n+\t\tif textdat[off] == 255 {\n+\t\t\tbreak\n+\t\t}\n \t\twantLine += int(textdat[off])\n \t\tif line != wantLine {\n \t\t\tt.Errorf(\"expected line %d at PC %#x in pcfromline, got %d\", wantLine, pc, line)"}, {"sha": "9ab05bac2f70af17e9edb7417956eb56e196f8df", "filename": "libgo/go/debug/gosym/symtab.go", "status": "modified", "additions": 74, "deletions": 19, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -34,7 +34,7 @@ type Sym struct {\n \tFunc *Func\n }\n \n-// Static returns whether this symbol is static (not visible outside its file).\n+// Static reports whether this symbol is static (not visible outside its file).\n func (s *Sym) Static() bool { return s.Type >= 'a' }\n \n // PackageName returns the package part of the symbol name,\n@@ -77,10 +77,26 @@ type Func struct {\n \tObj       *Obj\n }\n \n-// An Obj represents a single object file.\n+// An Obj represents a collection of functions in a symbol table.\n+//\n+// The exact method of division of a binary into separate Objs is an internal detail\n+// of the symbol table format.\n+//\n+// In early versions of Go each source file became a different Obj.\n+//\n+// In Go 1 and Go 1.1, each package produced one Obj for all Go sources\n+// and one Obj per C source file.\n+//\n+// In Go 1.2, there is a single Obj for the entire program.\n type Obj struct {\n+\t// Funcs is a list of functions in the Obj.\n \tFuncs []Func\n-\tPaths []Sym\n+\n+\t// In Go 1.1 and earlier, Paths is a list of symbols corresponding\n+\t// to the source file names that produced the Obj.\n+\t// In Go 1.2, Paths is nil.\n+\t// Use the keys of Table.Files to obtain a list of source files.\n+\tPaths []Sym // meta\n }\n \n /*\n@@ -93,9 +109,10 @@ type Obj struct {\n type Table struct {\n \tSyms  []Sym\n \tFuncs []Func\n-\tFiles map[string]*Obj\n-\tObjs  []Obj\n-\t//\ttextEnd uint64;\n+\tFiles map[string]*Obj // nil for Go 1.2 and later binaries\n+\tObjs  []Obj           // nil for Go 1.2 and later binaries\n+\n+\tgo12line *LineTable // Go 1.2 line number table\n }\n \n type sym struct {\n@@ -105,10 +122,11 @@ type sym struct {\n \tname   []byte\n }\n \n-var littleEndianSymtab = []byte{0xFD, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00}\n-var bigEndianSymtab = []byte{0xFF, 0xFF, 0xFF, 0xFD, 0x00, 0x00, 0x00}\n-\n-var oldLittleEndianSymtab = []byte{0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00}\n+var (\n+\tlittleEndianSymtab    = []byte{0xFD, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00}\n+\tbigEndianSymtab       = []byte{0xFF, 0xFF, 0xFF, 0xFD, 0x00, 0x00, 0x00}\n+\toldLittleEndianSymtab = []byte{0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00}\n+)\n \n func walksymtab(data []byte, fn func(sym) error) error {\n \tvar order binary.ByteOrder = binary.BigEndian\n@@ -260,6 +278,9 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, error) {\n \t}\n \n \tvar t Table\n+\tif pcln.isGo12() {\n+\t\tt.go12line = pcln\n+\t}\n \tfname := make(map[uint16]string)\n \tt.Syms = make([]Sym, 0, n)\n \tnf := 0\n@@ -316,17 +337,29 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, error) {\n \t}\n \n \tt.Funcs = make([]Func, 0, nf)\n-\tt.Objs = make([]Obj, 0, nz)\n \tt.Files = make(map[string]*Obj)\n \n+\tvar obj *Obj\n+\tif t.go12line != nil {\n+\t\t// Put all functions into one Obj.\n+\t\tt.Objs = make([]Obj, 1)\n+\t\tobj = &t.Objs[0]\n+\t\tt.go12line.go12MapFiles(t.Files, obj)\n+\t} else {\n+\t\tt.Objs = make([]Obj, 0, nz)\n+\t}\n+\n \t// Count text symbols and attach frame sizes, parameters, and\n \t// locals to them.  Also, find object file boundaries.\n-\tvar obj *Obj\n \tlastf := 0\n \tfor i := 0; i < len(t.Syms); i++ {\n \t\tsym := &t.Syms[i]\n \t\tswitch sym.Type {\n \t\tcase 'Z', 'z': // path symbol\n+\t\t\tif t.go12line != nil {\n+\t\t\t\t// Go 1.2 binaries have the file information elsewhere. Ignore.\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t\t// Finish the current object\n \t\t\tif obj != nil {\n \t\t\t\tobj.Funcs = t.Funcs[lastf:]\n@@ -395,7 +428,12 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, error) {\n \t\t\tfn.Sym = sym\n \t\t\tfn.Entry = sym.Value\n \t\t\tfn.Obj = obj\n-\t\t\tif pcln != nil {\n+\t\t\tif t.go12line != nil {\n+\t\t\t\t// All functions share the same line table.\n+\t\t\t\t// It knows how to narrow down to a specific\n+\t\t\t\t// function quickly.\n+\t\t\t\tfn.LineTable = t.go12line\n+\t\t\t} else if pcln != nil {\n \t\t\t\tfn.LineTable = pcln.slice(fn.Entry)\n \t\t\t\tpcln = fn.LineTable\n \t\t\t}\n@@ -448,18 +486,32 @@ func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func) {\n \tif fn = t.PCToFunc(pc); fn == nil {\n \t\treturn\n \t}\n-\tfile, line = fn.Obj.lineFromAline(fn.LineTable.PCToLine(pc))\n+\tif t.go12line != nil {\n+\t\tfile = t.go12line.go12PCToFile(pc)\n+\t\tline = t.go12line.go12PCToLine(pc)\n+\t} else {\n+\t\tfile, line = fn.Obj.lineFromAline(fn.LineTable.PCToLine(pc))\n+\t}\n \treturn\n }\n \n // LineToPC looks up the first program counter on the given line in\n-// the named file.  Returns UnknownPathError or UnknownLineError if\n+// the named file.  It returns UnknownPathError or UnknownLineError if\n // there is an error looking up this line.\n func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err error) {\n \tobj, ok := t.Files[file]\n \tif !ok {\n \t\treturn 0, nil, UnknownFileError(file)\n \t}\n+\n+\tif t.go12line != nil {\n+\t\tpc := t.go12line.go12LineToPC(file, line)\n+\t\tif pc == 0 {\n+\t\t\treturn 0, nil, &UnknownLineError{file, line}\n+\t\t}\n+\t\treturn pc, t.PCToFunc(pc), nil\n+\t}\n+\n \tabs, err := obj.alineFromLine(file, line)\n \tif err != nil {\n \t\treturn\n@@ -503,9 +555,7 @@ func (t *Table) LookupFunc(name string) *Func {\n }\n \n // SymByAddr returns the text, data, or bss symbol starting at the given address.\n-// TODO(rsc): Allow lookup by any address within the symbol.\n func (t *Table) SymByAddr(addr uint64) *Sym {\n-\t// TODO(austin) Maybe make a map\n \tfor i := range t.Syms {\n \t\ts := &t.Syms[i]\n \t\tswitch s.Type {\n@@ -522,6 +572,13 @@ func (t *Table) SymByAddr(addr uint64) *Sym {\n  * Object files\n  */\n \n+// This is legacy code for Go 1.1 and earlier, which used the\n+// Plan 9 format for pc-line tables. This code was never quite\n+// correct. It's probably very close, and it's usually correct, but\n+// we never quite found all the corner cases.\n+//\n+// Go 1.2 and later use a simpler format, documented at golang.org/s/go12symtab.\n+\n func (o *Obj) lineFromAline(aline int) (string, int) {\n \ttype stackEnt struct {\n \t\tpath   string\n@@ -533,8 +590,6 @@ func (o *Obj) lineFromAline(aline int) (string, int) {\n \tnoPath := &stackEnt{\"\", 0, 0, nil}\n \ttos := noPath\n \n-\t// TODO(austin) I have no idea how 'Z' symbols work, except\n-\t// that they pop the stack.\n pathloop:\n \tfor _, s := range o.Paths {\n \t\tval := int(s.Value)"}, {"sha": "992356c263bce00537cddadc59a506349d56f0e4", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -32,14 +32,14 @@ type StructuralError struct {\n \tMsg string\n }\n \n-func (e StructuralError) Error() string { return \"ASN.1 structure error: \" + e.Msg }\n+func (e StructuralError) Error() string { return \"asn1: structure error: \" + e.Msg }\n \n // A SyntaxError suggests that the ASN.1 data is invalid.\n type SyntaxError struct {\n \tMsg string\n }\n \n-func (e SyntaxError) Error() string { return \"ASN.1 syntax error: \" + e.Msg }\n+func (e SyntaxError) Error() string { return \"asn1: syntax error: \" + e.Msg }\n \n // We start by dealing with each of the primitive types in turn.\n \n@@ -51,7 +51,19 @@ func parseBool(bytes []byte) (ret bool, err error) {\n \t\treturn\n \t}\n \n-\treturn bytes[0] != 0, nil\n+\t// DER demands that \"If the encoding represents the boolean value TRUE,\n+\t// its single contents octet shall have all eight bits set to one.\"\n+\t// Thus only 0 and 255 are valid encoded values.\n+\tswitch bytes[0] {\n+\tcase 0:\n+\t\tret = false\n+\tcase 0xff:\n+\t\tret = true\n+\tdefault:\n+\t\terr = SyntaxError{\"invalid boolean\"}\n+\t}\n+\n+\treturn\n }\n \n // INTEGER\n@@ -171,7 +183,7 @@ func parseBitString(bytes []byte) (ret BitString, err error) {\n // An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.\n type ObjectIdentifier []int\n \n-// Equal returns true iff oi and other represent the same identifier.\n+// Equal reports whether oi and other represent the same identifier.\n func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool {\n \tif len(oi) != len(other) {\n \t\treturn false\n@@ -198,12 +210,24 @@ func parseObjectIdentifier(bytes []byte) (s []int, err error) {\n \t// encoded differently) and then every varint is a single byte long.\n \ts = make([]int, len(bytes)+1)\n \n-\t// The first byte is 40*value1 + value2:\n-\ts[0] = int(bytes[0]) / 40\n-\ts[1] = int(bytes[0]) % 40\n+\t// The first varint is 40*value1 + value2:\n+\t// According to this packing, value1 can take the values 0, 1 and 2 only.\n+\t// When value1 = 0 or value1 = 1, then value2 is <= 39. When value1 = 2,\n+\t// then there are no restrictions on value2.\n+\tv, offset, err := parseBase128Int(bytes, 0)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif v < 80 {\n+\t\ts[0] = v / 40\n+\t\ts[1] = v % 40\n+\t} else {\n+\t\ts[0] = 2\n+\t\ts[1] = v - 80\n+\t}\n+\n \ti := 2\n-\tfor offset := 1; offset < len(bytes); i++ {\n-\t\tvar v int\n+\tfor ; offset < len(bytes); i++ {\n \t\tv, offset, err = parseBase128Int(bytes, offset)\n \t\tif err != nil {\n \t\t\treturn\n@@ -573,7 +597,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif fieldType != flagType {\n-\t\t\t\t\terr = StructuralError{\"Zero length explicit tag was not an asn1.Flag\"}\n+\t\t\t\t\terr = StructuralError{\"zero length explicit tag was not an asn1.Flag\"}\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tv.SetBool(true)"}, {"sha": "f68804ebffd2faff24f4e7cfd7b9f498a8e3ebc8", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -12,6 +12,32 @@ import (\n \t\"time\"\n )\n \n+type boolTest struct {\n+\tin  []byte\n+\tok  bool\n+\tout bool\n+}\n+\n+var boolTestData = []boolTest{\n+\t{[]byte{0x00}, true, false},\n+\t{[]byte{0xff}, true, true},\n+\t{[]byte{0x00, 0x00}, false, false},\n+\t{[]byte{0xff, 0xff}, false, false},\n+\t{[]byte{0x01}, false, false},\n+}\n+\n+func TestParseBool(t *testing.T) {\n+\tfor i, test := range boolTestData {\n+\t\tret, err := parseBool(test.in)\n+\t\tif (err == nil) != test.ok {\n+\t\t\tt.Errorf(\"#%d: Incorrect error result (did fail? %v, expected: %v)\", i, err == nil, test.ok)\n+\t\t}\n+\t\tif test.ok && ret != test.out {\n+\t\t\tt.Errorf(\"#%d: Bad result: %v (expected %v)\", i, ret, test.out)\n+\t\t}\n+\t}\n+}\n+\n type int64Test struct {\n \tin  []byte\n \tok  bool\n@@ -183,6 +209,7 @@ var objectIdentifierTestData = []objectIdentifierTest{\n \t{[]byte{85}, true, []int{2, 5}},\n \t{[]byte{85, 0x02}, true, []int{2, 5, 2}},\n \t{[]byte{85, 0x02, 0xc0, 0x00}, true, []int{2, 5, 2, 0x2000}},\n+\t{[]byte{0x81, 0x34, 0x03}, true, []int{2, 100, 3}},\n \t{[]byte{85, 0x02, 0xc0, 0x80, 0x80, 0x80, 0x80}, false, []int{}},\n }\n \n@@ -378,7 +405,7 @@ var unmarshalTestData = []struct {\n \t{[]byte{0x30, 0x03, 0x81, 0x01, 0x01}, &TestContextSpecificTags{1}},\n \t{[]byte{0x30, 0x08, 0xa1, 0x03, 0x02, 0x01, 0x01, 0x02, 0x01, 0x02}, &TestContextSpecificTags2{1, 2}},\n \t{[]byte{0x01, 0x01, 0x00}, newBool(false)},\n-\t{[]byte{0x01, 0x01, 0x01}, newBool(true)},\n+\t{[]byte{0x01, 0x01, 0xff}, newBool(true)},\n \t{[]byte{0x30, 0x0b, 0x13, 0x03, 0x66, 0x6f, 0x6f, 0x02, 0x01, 0x22, 0x02, 0x01, 0x33}, &TestElementsAfterString{\"foo\", 0x22, 0x33}},\n \t{[]byte{0x30, 0x05, 0x02, 0x03, 0x12, 0x34, 0x56}, &TestBigInt{big.NewInt(0x123456)}},\n }"}, {"sha": "ed17e41a55cfd9f5d1e6ac9f703520eecb597db1", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -240,11 +240,11 @@ func marshalBitString(out *forkableWriter, b BitString) (err error) {\n }\n \n func marshalObjectIdentifier(out *forkableWriter, oid []int) (err error) {\n-\tif len(oid) < 2 || oid[0] > 6 || oid[1] >= 40 {\n+\tif len(oid) < 2 || oid[0] > 2 || (oid[0] < 2 && oid[1] >= 40) {\n \t\treturn StructuralError{\"invalid object identifier\"}\n \t}\n \n-\terr = out.WriteByte(byte(oid[0]*40 + oid[1]))\n+\terr = marshalBase128Int(out, int64(oid[0]*40+oid[1]))\n \tif err != nil {\n \t\treturn\n \t}\n@@ -304,7 +304,7 @@ func marshalUTCTime(out *forkableWriter, t time.Time) (err error) {\n \tcase 2000 <= year && year < 2050:\n \t\terr = marshalTwoDigits(out, int(year-2000))\n \tdefault:\n-\t\treturn StructuralError{\"Cannot represent time as UTCTime\"}\n+\t\treturn StructuralError{\"cannot represent time as UTCTime\"}\n \t}\n \tif err != nil {\n \t\treturn\n@@ -441,11 +441,11 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\t\treturn\n \t\t}\n \n-\t\tvar params fieldParameters\n+\t\tvar fp fieldParameters\n \t\tfor i := 0; i < v.Len(); i++ {\n \t\t\tvar pre *forkableWriter\n \t\t\tpre, out = out.fork()\n-\t\t\terr = marshalField(pre, v.Index(i), params)\n+\t\t\terr = marshalField(pre, v.Index(i), fp)\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}\n@@ -501,7 +501,7 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \tclass := classUniversal\n \n \tif params.stringType != 0 && tag != tagPrintableString {\n-\t\treturn StructuralError{\"Explicit string type given to non-string member\"}\n+\t\treturn StructuralError{\"explicit string type given to non-string member\"}\n \t}\n \n \tif tag == tagPrintableString {\n@@ -525,7 +525,7 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \n \tif params.set {\n \t\tif tag != tagSequence {\n-\t\t\treturn StructuralError{\"Non sequence tagged as set\"}\n+\t\t\treturn StructuralError{\"non sequence tagged as set\"}\n \t\t}\n \t\ttag = tagSet\n \t}"}, {"sha": "763c86da23f5b0b5b2ea7e2cb361fd8e8f6375e0", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -87,6 +87,7 @@ var marshalTests = []marshalTest{\n \t{BitString{[]byte{0x81, 0xf0}, 12}, \"03030481f0\"},\n \t{ObjectIdentifier([]int{1, 2, 3, 4}), \"06032a0304\"},\n \t{ObjectIdentifier([]int{1, 2, 840, 133549, 1, 1, 5}), \"06092a864888932d010105\"},\n+\t{ObjectIdentifier([]int{2, 100, 3}), \"0603813403\"},\n \t{\"test\", \"130474657374\"},\n \t{\n \t\t\"\" +"}, {"sha": "f3466b9af0313e279dcf93de8cea6bcf84e307b1", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 167, "deletions": 76, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package binary implements translation between numbers and byte sequences\n-// and encoding and decoding of varints.\n+// Package binary implements simple translation between numbers and byte\n+// sequences and encoding and decoding of varints.\n //\n // Numbers are translated by reading and writing fixed-size values.\n // A fixed-size value is either a fixed-size arithmetic\n@@ -13,6 +13,11 @@\n // Varints are a method of encoding integers using one or more bytes;\n // numbers with smaller absolute value take a smaller number of bytes.\n // For a specification, see http://code.google.com/apis/protocolbuffers/docs/encoding.html.\n+//\n+// This package favors simplicity over efficiency. Clients that require\n+// high-performance serialization, especially for large data structures,\n+// should look at more advanced solutions such as the encoding/gob\n+// package or protocol buffers.\n package binary\n \n import (\n@@ -129,30 +134,65 @@ func (bigEndian) GoString() string { return \"binary.BigEndian\" }\n // blank (_) field names is skipped; i.e., blank field names\n // may be used for padding.\n func Read(r io.Reader, order ByteOrder, data interface{}) error {\n-\t// Fast path for basic types.\n-\tif n := intDestSize(data); n != 0 {\n+\t// Fast path for basic types and slices.\n+\tif n := intDataSize(data); n != 0 {\n \t\tvar b [8]byte\n-\t\tbs := b[:n]\n+\t\tvar bs []byte\n+\t\tif n > len(b) {\n+\t\t\tbs = make([]byte, n)\n+\t\t} else {\n+\t\t\tbs = b[:n]\n+\t\t}\n \t\tif _, err := io.ReadFull(r, bs); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tswitch v := data.(type) {\n+\t\tswitch data := data.(type) {\n \t\tcase *int8:\n-\t\t\t*v = int8(b[0])\n+\t\t\t*data = int8(b[0])\n \t\tcase *uint8:\n-\t\t\t*v = b[0]\n+\t\t\t*data = b[0]\n \t\tcase *int16:\n-\t\t\t*v = int16(order.Uint16(bs))\n+\t\t\t*data = int16(order.Uint16(bs))\n \t\tcase *uint16:\n-\t\t\t*v = order.Uint16(bs)\n+\t\t\t*data = order.Uint16(bs)\n \t\tcase *int32:\n-\t\t\t*v = int32(order.Uint32(bs))\n+\t\t\t*data = int32(order.Uint32(bs))\n \t\tcase *uint32:\n-\t\t\t*v = order.Uint32(bs)\n+\t\t\t*data = order.Uint32(bs)\n \t\tcase *int64:\n-\t\t\t*v = int64(order.Uint64(bs))\n+\t\t\t*data = int64(order.Uint64(bs))\n \t\tcase *uint64:\n-\t\t\t*v = order.Uint64(bs)\n+\t\t\t*data = order.Uint64(bs)\n+\t\tcase []int8:\n+\t\t\tfor i, x := range bs { // Easier to loop over the input for 8-bit values.\n+\t\t\t\tdata[i] = int8(x)\n+\t\t\t}\n+\t\tcase []uint8:\n+\t\t\tcopy(data, bs)\n+\t\tcase []int16:\n+\t\t\tfor i := range data {\n+\t\t\t\tdata[i] = int16(order.Uint16(bs[2*i:]))\n+\t\t\t}\n+\t\tcase []uint16:\n+\t\t\tfor i := range data {\n+\t\t\t\tdata[i] = order.Uint16(bs[2*i:])\n+\t\t\t}\n+\t\tcase []int32:\n+\t\t\tfor i := range data {\n+\t\t\t\tdata[i] = int32(order.Uint32(bs[4*i:]))\n+\t\t\t}\n+\t\tcase []uint32:\n+\t\t\tfor i := range data {\n+\t\t\t\tdata[i] = order.Uint32(bs[4*i:])\n+\t\t\t}\n+\t\tcase []int64:\n+\t\t\tfor i := range data {\n+\t\t\t\tdata[i] = int64(order.Uint64(bs[8*i:]))\n+\t\t\t}\n+\t\tcase []uint64:\n+\t\t\tfor i := range data {\n+\t\t\t\tdata[i] = order.Uint64(bs[8*i:])\n+\t\t\t}\n \t\t}\n \t\treturn nil\n \t}\n@@ -187,60 +227,95 @@ func Read(r io.Reader, order ByteOrder, data interface{}) error {\n // When writing structs, zero values are written for fields\n // with blank (_) field names.\n func Write(w io.Writer, order ByteOrder, data interface{}) error {\n-\t// Fast path for basic types.\n-\tvar b [8]byte\n-\tvar bs []byte\n-\tswitch v := data.(type) {\n-\tcase *int8:\n-\t\tbs = b[:1]\n-\t\tb[0] = byte(*v)\n-\tcase int8:\n-\t\tbs = b[:1]\n-\t\tb[0] = byte(v)\n-\tcase *uint8:\n-\t\tbs = b[:1]\n-\t\tb[0] = *v\n-\tcase uint8:\n-\t\tbs = b[:1]\n-\t\tb[0] = byte(v)\n-\tcase *int16:\n-\t\tbs = b[:2]\n-\t\torder.PutUint16(bs, uint16(*v))\n-\tcase int16:\n-\t\tbs = b[:2]\n-\t\torder.PutUint16(bs, uint16(v))\n-\tcase *uint16:\n-\t\tbs = b[:2]\n-\t\torder.PutUint16(bs, *v)\n-\tcase uint16:\n-\t\tbs = b[:2]\n-\t\torder.PutUint16(bs, v)\n-\tcase *int32:\n-\t\tbs = b[:4]\n-\t\torder.PutUint32(bs, uint32(*v))\n-\tcase int32:\n-\t\tbs = b[:4]\n-\t\torder.PutUint32(bs, uint32(v))\n-\tcase *uint32:\n-\t\tbs = b[:4]\n-\t\torder.PutUint32(bs, *v)\n-\tcase uint32:\n-\t\tbs = b[:4]\n-\t\torder.PutUint32(bs, v)\n-\tcase *int64:\n-\t\tbs = b[:8]\n-\t\torder.PutUint64(bs, uint64(*v))\n-\tcase int64:\n-\t\tbs = b[:8]\n-\t\torder.PutUint64(bs, uint64(v))\n-\tcase *uint64:\n-\t\tbs = b[:8]\n-\t\torder.PutUint64(bs, *v)\n-\tcase uint64:\n-\t\tbs = b[:8]\n-\t\torder.PutUint64(bs, v)\n-\t}\n-\tif bs != nil {\n+\t// Fast path for basic types and slices.\n+\tif n := intDataSize(data); n != 0 {\n+\t\tvar b [8]byte\n+\t\tvar bs []byte\n+\t\tif n > len(b) {\n+\t\t\tbs = make([]byte, n)\n+\t\t} else {\n+\t\t\tbs = b[:n]\n+\t\t}\n+\t\tswitch v := data.(type) {\n+\t\tcase *int8:\n+\t\t\tbs = b[:1]\n+\t\t\tb[0] = byte(*v)\n+\t\tcase int8:\n+\t\t\tbs = b[:1]\n+\t\t\tb[0] = byte(v)\n+\t\tcase []int8:\n+\t\t\tfor i, x := range v {\n+\t\t\t\tbs[i] = byte(x)\n+\t\t\t}\n+\t\tcase *uint8:\n+\t\t\tbs = b[:1]\n+\t\t\tb[0] = *v\n+\t\tcase uint8:\n+\t\t\tbs = b[:1]\n+\t\t\tb[0] = byte(v)\n+\t\tcase []uint8:\n+\t\t\tbs = v\n+\t\tcase *int16:\n+\t\t\tbs = b[:2]\n+\t\t\torder.PutUint16(bs, uint16(*v))\n+\t\tcase int16:\n+\t\t\tbs = b[:2]\n+\t\t\torder.PutUint16(bs, uint16(v))\n+\t\tcase []int16:\n+\t\t\tfor i, x := range v {\n+\t\t\t\torder.PutUint16(bs[2*i:], uint16(x))\n+\t\t\t}\n+\t\tcase *uint16:\n+\t\t\tbs = b[:2]\n+\t\t\torder.PutUint16(bs, *v)\n+\t\tcase uint16:\n+\t\t\tbs = b[:2]\n+\t\t\torder.PutUint16(bs, v)\n+\t\tcase []uint16:\n+\t\t\tfor i, x := range v {\n+\t\t\t\torder.PutUint16(bs[2*i:], x)\n+\t\t\t}\n+\t\tcase *int32:\n+\t\t\tbs = b[:4]\n+\t\t\torder.PutUint32(bs, uint32(*v))\n+\t\tcase int32:\n+\t\t\tbs = b[:4]\n+\t\t\torder.PutUint32(bs, uint32(v))\n+\t\tcase []int32:\n+\t\t\tfor i, x := range v {\n+\t\t\t\torder.PutUint32(bs[4*i:], uint32(x))\n+\t\t\t}\n+\t\tcase *uint32:\n+\t\t\tbs = b[:4]\n+\t\t\torder.PutUint32(bs, *v)\n+\t\tcase uint32:\n+\t\t\tbs = b[:4]\n+\t\t\torder.PutUint32(bs, v)\n+\t\tcase []uint32:\n+\t\t\tfor i, x := range v {\n+\t\t\t\torder.PutUint32(bs[4*i:], x)\n+\t\t\t}\n+\t\tcase *int64:\n+\t\t\tbs = b[:8]\n+\t\t\torder.PutUint64(bs, uint64(*v))\n+\t\tcase int64:\n+\t\t\tbs = b[:8]\n+\t\t\torder.PutUint64(bs, uint64(v))\n+\t\tcase []int64:\n+\t\t\tfor i, x := range v {\n+\t\t\t\torder.PutUint64(bs[8*i:], uint64(x))\n+\t\t\t}\n+\t\tcase *uint64:\n+\t\t\tbs = b[:8]\n+\t\t\torder.PutUint64(bs, *v)\n+\t\tcase uint64:\n+\t\t\tbs = b[:8]\n+\t\t\torder.PutUint64(bs, v)\n+\t\tcase []uint64:\n+\t\t\tfor i, x := range v {\n+\t\t\t\torder.PutUint64(bs[8*i:], x)\n+\t\t\t}\n+\t\t}\n \t\t_, err := w.Write(bs)\n \t\treturn err\n \t}\n@@ -530,18 +605,34 @@ func (e *encoder) skip(v reflect.Value) {\n \te.buf = e.buf[n:]\n }\n \n-// intDestSize returns the size of the integer that ptrType points to,\n-// or 0 if the type is not supported.\n-func intDestSize(ptrType interface{}) int {\n-\tswitch ptrType.(type) {\n-\tcase *int8, *uint8:\n+// intDataSize returns the size of the data required to represent the data when encoded.\n+// It returns zero if the type cannot be implemented by the fast path in Read or Write.\n+func intDataSize(data interface{}) int {\n+\tswitch data := data.(type) {\n+\tcase int8, *int8, *uint8:\n \t\treturn 1\n-\tcase *int16, *uint16:\n+\tcase []int8:\n+\t\treturn len(data)\n+\tcase []uint8:\n+\t\treturn len(data)\n+\tcase int16, *int16, *uint16:\n \t\treturn 2\n-\tcase *int32, *uint32:\n+\tcase []int16:\n+\t\treturn 2 * len(data)\n+\tcase []uint16:\n+\t\treturn 2 * len(data)\n+\tcase int32, *int32, *uint32:\n \t\treturn 4\n-\tcase *int64, *uint64:\n+\tcase []int32:\n+\t\treturn 4 * len(data)\n+\tcase []uint32:\n+\t\treturn 4 * len(data)\n+\tcase int64, *int64, *uint64:\n \t\treturn 8\n+\tcase []int64:\n+\t\treturn 8 * len(data)\n+\tcase []uint64:\n+\t\treturn 8 * len(data)\n \t}\n \treturn 0\n }"}, {"sha": "fdfee7d871148e5f00132d8322c5a2b38015afdd", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -141,6 +141,52 @@ func TestWriteSlice(t *testing.T) {\n \tcheckResult(t, \"WriteSlice\", BigEndian, err, buf.Bytes(), src)\n }\n \n+// Addresses of arrays are easier to manipulate with reflection than are slices.\n+var intArrays = []interface{}{\n+\t&[100]int8{},\n+\t&[100]int16{},\n+\t&[100]int32{},\n+\t&[100]int64{},\n+\t&[100]uint8{},\n+\t&[100]uint16{},\n+\t&[100]uint32{},\n+\t&[100]uint64{},\n+}\n+\n+func TestSliceRoundTrip(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\tfor _, array := range intArrays {\n+\t\tsrc := reflect.ValueOf(array).Elem()\n+\t\tunsigned := false\n+\t\tswitch src.Index(0).Kind() {\n+\t\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n+\t\t\tunsigned = true\n+\t\t}\n+\t\tfor i := 0; i < src.Len(); i++ {\n+\t\t\tif unsigned {\n+\t\t\t\tsrc.Index(i).SetUint(uint64(i * 0x07654321))\n+\t\t\t} else {\n+\t\t\t\tsrc.Index(i).SetInt(int64(i * 0x07654321))\n+\t\t\t}\n+\t\t}\n+\t\tbuf.Reset()\n+\t\tsrcSlice := src.Slice(0, src.Len())\n+\t\terr := Write(buf, BigEndian, srcSlice.Interface())\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdst := reflect.New(src.Type()).Elem()\n+\t\tdstSlice := dst.Slice(0, dst.Len())\n+\t\terr = Read(buf, BigEndian, dstSlice.Interface())\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(src.Interface(), dst.Interface()) {\n+\t\t\tt.Fatal(src)\n+\t\t}\n+\t}\n+}\n+\n func TestWriteT(t *testing.T) {\n \tbuf := new(bytes.Buffer)\n \tts := T{}\n@@ -312,3 +358,16 @@ func BenchmarkWriteInts(b *testing.B) {\n \t\tb.Fatalf(\"first half doesn't match: %x %x\", buf.Bytes(), big[:30])\n \t}\n }\n+\n+func BenchmarkWriteSlice1000Int32s(b *testing.B) {\n+\tslice := make([]int32, 1000)\n+\tbuf := new(bytes.Buffer)\n+\tvar w io.Writer = buf\n+\tb.SetBytes(4 * 1000)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\tWrite(w, BigEndian, slice)\n+\t}\n+\tb.StopTimer()\n+}"}, {"sha": "b328dcc375cd7cccf8f680540fe34cc01c791be8", "filename": "libgo/go/encoding/csv/reader.go", "status": "modified", "additions": 14, "deletions": 44, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -72,7 +72,7 @@ func (e *ParseError) Error() string {\n \n // These are the errors that can be returned in ParseError.Error\n var (\n-\tErrTrailingComma = errors.New(\"extra delimiter at end of line\")\n+\tErrTrailingComma = errors.New(\"extra delimiter at end of line\") // no longer used\n \tErrBareQuote     = errors.New(\"bare \\\" in non-quoted-field\")\n \tErrQuote         = errors.New(\"extraneous \\\" in field\")\n \tErrFieldCount    = errors.New(\"wrong number of fields in line\")\n@@ -98,16 +98,14 @@ var (\n // If LazyQuotes is true, a quote may appear in an unquoted field and a\n // non-doubled quote may appear in a quoted field.\n //\n-// If TrailingComma is true, the last field may be an unquoted empty field.\n-//\n // If TrimLeadingSpace is true, leading white space in a field is ignored.\n type Reader struct {\n-\tComma            rune // Field delimiter (set to ',' by NewReader)\n-\tComment          rune // Comment character for start of line\n-\tFieldsPerRecord  int  // Number of expected fields per record\n-\tLazyQuotes       bool // Allow lazy quotes\n-\tTrailingComma    bool // Allow trailing comma\n-\tTrimLeadingSpace bool // Trim leading space\n+\tComma            rune // field delimiter (set to ',' by NewReader)\n+\tComment          rune // comment character for start of line\n+\tFieldsPerRecord  int  // number of expected fields per record\n+\tLazyQuotes       bool // allow lazy quotes\n+\tTrailingComma    bool // ignored; here for backwards compatibility\n+\tTrimLeadingSpace bool // trim leading space\n \tline             int\n \tcolumn           int\n \tr                *bufio.Reader\n@@ -257,23 +255,15 @@ func (r *Reader) parseField() (haveField bool, delim rune, err error) {\n \tr.field.Reset()\n \n \tr1, err := r.readRune()\n-\tif err != nil {\n-\t\t// If we have EOF and are not at the start of a line\n-\t\t// then we return the empty field.  We have already\n-\t\t// checked for trailing commas if needed.\n-\t\tif err == io.EOF && r.column != 0 {\n-\t\t\treturn true, 0, err\n-\t\t}\n-\t\treturn false, 0, err\n+\tfor err == nil && r.TrimLeadingSpace && r1 != '\\n' && unicode.IsSpace(r1) {\n+\t\tr1, err = r.readRune()\n \t}\n \n-\tif r.TrimLeadingSpace {\n-\t\tfor r1 != '\\n' && unicode.IsSpace(r1) {\n-\t\t\tr1, err = r.readRune()\n-\t\t\tif err != nil {\n-\t\t\t\treturn false, 0, err\n-\t\t\t}\n-\t\t}\n+\tif err == io.EOF && r.column != 0 {\n+\t\treturn true, 0, err\n+\t}\n+\tif err != nil {\n+\t\treturn false, 0, err\n \t}\n \n \tswitch r1 {\n@@ -349,25 +339,5 @@ func (r *Reader) parseField() (haveField bool, delim rune, err error) {\n \t\treturn false, 0, err\n \t}\n \n-\tif !r.TrailingComma {\n-\t\t// We don't allow trailing commas.  See if we\n-\t\t// are at the end of the line (being mindful\n-\t\t// of trimming spaces).\n-\t\tc := r.column\n-\t\tr1, err = r.readRune()\n-\t\tif r.TrimLeadingSpace {\n-\t\t\tfor r1 != '\\n' && unicode.IsSpace(r1) {\n-\t\t\t\tr1, err = r.readRune()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif err == io.EOF || r1 == '\\n' {\n-\t\t\tr.column = c // report the comma\n-\t\t\treturn false, 0, r.error(ErrTrailingComma)\n-\t\t}\n-\t\tr.unreadRune()\n-\t}\n \treturn true, r1, nil\n }"}, {"sha": "123df06bc85e7e781b7ca80bb1561ed4061047f4", "filename": "libgo/go/encoding/csv/reader_test.go", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -171,32 +171,32 @@ field\"`,\n \t\tOutput: [][]string{{\"a\", \"b\", \"c\"}, {\"d\", \"e\"}},\n \t},\n \t{\n-\t\tName:  \"BadTrailingCommaEOF\",\n-\t\tInput: \"a,b,c,\",\n-\t\tError: \"extra delimiter at end of line\", Line: 1, Column: 5,\n+\t\tName:   \"TrailingCommaEOF\",\n+\t\tInput:  \"a,b,c,\",\n+\t\tOutput: [][]string{{\"a\", \"b\", \"c\", \"\"}},\n \t},\n \t{\n-\t\tName:  \"BadTrailingCommaEOL\",\n-\t\tInput: \"a,b,c,\\n\",\n-\t\tError: \"extra delimiter at end of line\", Line: 1, Column: 5,\n+\t\tName:   \"TrailingCommaEOL\",\n+\t\tInput:  \"a,b,c,\\n\",\n+\t\tOutput: [][]string{{\"a\", \"b\", \"c\", \"\"}},\n \t},\n \t{\n-\t\tName:             \"BadTrailingCommaSpaceEOF\",\n+\t\tName:             \"TrailingCommaSpaceEOF\",\n \t\tTrimLeadingSpace: true,\n \t\tInput:            \"a,b,c, \",\n-\t\tError:            \"extra delimiter at end of line\", Line: 1, Column: 5,\n+\t\tOutput:           [][]string{{\"a\", \"b\", \"c\", \"\"}},\n \t},\n \t{\n-\t\tName:             \"BadTrailingCommaSpaceEOL\",\n+\t\tName:             \"TrailingCommaSpaceEOL\",\n \t\tTrimLeadingSpace: true,\n \t\tInput:            \"a,b,c, \\n\",\n-\t\tError:            \"extra delimiter at end of line\", Line: 1, Column: 5,\n+\t\tOutput:           [][]string{{\"a\", \"b\", \"c\", \"\"}},\n \t},\n \t{\n-\t\tName:             \"BadTrailingCommaLine3\",\n+\t\tName:             \"TrailingCommaLine3\",\n \t\tTrimLeadingSpace: true,\n \t\tInput:            \"a,b,c\\nd,e,f\\ng,hi,\",\n-\t\tError:            \"extra delimiter at end of line\", Line: 3, Column: 4,\n+\t\tOutput:           [][]string{{\"a\", \"b\", \"c\"}, {\"d\", \"e\", \"f\"}, {\"g\", \"hi\", \"\"}},\n \t},\n \t{\n \t\tName:   \"NotTrailingComma3\",\n@@ -231,7 +231,7 @@ x,,,\n \t\t},\n \t},\n \t{\n-\t\tName:             \"Issue 2366\",\n+\t\tName:             \"TrailingCommaIneffective1\",\n \t\tTrailingComma:    true,\n \t\tTrimLeadingSpace: true,\n \t\tInput:            \"a,b,\\nc,d,e\",\n@@ -241,11 +241,14 @@ x,,,\n \t\t},\n \t},\n \t{\n-\t\tName:             \"Issue 2366a\",\n+\t\tName:             \"TrailingCommaIneffective2\",\n \t\tTrailingComma:    false,\n \t\tTrimLeadingSpace: true,\n \t\tInput:            \"a,b,\\nc,d,e\",\n-\t\tError:            \"extra delimiter at end of line\",\n+\t\tOutput: [][]string{\n+\t\t\t{\"a\", \"b\", \"\"},\n+\t\t\t{\"c\", \"d\", \"e\"},\n+\t\t},\n \t},\n }\n "}, {"sha": "6d218071b7ae4f9c54293c4c161b836128b39e69", "filename": "libgo/go/encoding/encoding.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fencoding.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fencoding.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fencoding.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package encoding defines interfaces shared by other packages that\n+// convert data to and from byte-level and textual representations.\n+// Packages that check for these interfaces include encoding/gob,\n+// encoding/json, and encoding/xml. As a result, implementing an\n+// interface once can make a type useful in multiple encodings.\n+// Standard types that implement these interfaces include time.Time and net.IP.\n+// The interfaces come in pairs that produce and consume encoded data.\n+package encoding\n+\n+// BinaryMarshaler is the interface implemented by an object that can\n+// marshal itself into a binary form.\n+//\n+// MarshalBinary encodes the receiver into a binary form and returns the result.\n+type BinaryMarshaler interface {\n+\tMarshalBinary() (data []byte, err error)\n+}\n+\n+// BinaryUnmarshaler is the interface implemented by an object that can\n+// unmarshal a binary representation of itself.\n+//\n+// UnmarshalBinary must be able to decode the form generated by MarshalBinary.\n+// UnmarshalBinary must copy the data if it wishes to retain the data\n+// after returning.\n+type BinaryUnmarshaler interface {\n+\tUnmarshalBinary(data []byte) error\n+}\n+\n+// TextMarshaler is the interface implemented by an object that can\n+// marshal itself into a textual form.\n+//\n+// MarshalText encodes the receiver into UTF-8-encoded text and returns the result.\n+type TextMarshaler interface {\n+\tMarshalText() (text []byte, err error)\n+}\n+\n+// TextUnmarshaler is the interface implemented by an object that can\n+// unmarshal a textual representation of itself.\n+//\n+// UnmarshalText must be able to decode the form generated by MarshalText.\n+// UnmarshalText must copy the text if it wishes to retain the text\n+// after returning.\n+type TextUnmarshaler interface {\n+\tUnmarshalText(text []byte) error\n+}"}, {"sha": "b40f78360c235b59eb476c95e551c4cfc150ed67", "filename": "libgo/go/encoding/gob/codec_test.go", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -1009,24 +1009,6 @@ func TestBadRecursiveType(t *testing.T) {\n \t// Can't test decode easily because we can't encode one, so we can't pass one to a Decoder.\n }\n \n-type Bad0 struct {\n-\tCH chan int\n-\tC  float64\n-}\n-\n-func TestInvalidField(t *testing.T) {\n-\tvar bad0 Bad0\n-\tbad0.CH = make(chan int)\n-\tb := new(bytes.Buffer)\n-\tdummyEncoder := new(Encoder) // sufficient for this purpose.\n-\tdummyEncoder.encode(b, reflect.ValueOf(&bad0), userType(reflect.TypeOf(&bad0)))\n-\tif err := dummyEncoder.err; err == nil {\n-\t\tt.Error(\"expected error; got none\")\n-\t} else if strings.Index(err.Error(), \"type\") < 0 {\n-\t\tt.Error(\"expected type error; got\", err)\n-\t}\n-}\n-\n type Indirect struct {\n \tA ***[3]int\n \tS ***[]int"}, {"sha": "6117eb083733668fd80b0e982035975e6456b13b", "filename": "libgo/go/encoding/gob/debug.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -415,6 +415,16 @@ func (deb *debugger) typeDefinition(indent tab, id typeId) {\n \t\tdeb.delta(1)\n \t\tcom := deb.common()\n \t\twire.GobEncoderT = &gobEncoderType{com}\n+\tcase 5: // BinaryMarshaler type, one field of {{Common}}\n+\t\t// Field number 0 is CommonType\n+\t\tdeb.delta(1)\n+\t\tcom := deb.common()\n+\t\twire.BinaryMarshalerT = &gobEncoderType{com}\n+\tcase 6: // TextMarshaler type, one field of {{Common}}\n+\t\t// Field number 0 is CommonType\n+\t\tdeb.delta(1)\n+\t\tcom := deb.common()\n+\t\twire.TextMarshalerT = &gobEncoderType{com}\n \tdefault:\n \t\terrorf(\"bad field in type %d\", fieldNum)\n \t}"}, {"sha": "3e76f4c9066b146b7baa2111031873732907d1cd", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 51, "deletions": 38, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -9,6 +9,7 @@ package gob\n \n import (\n \t\"bytes\"\n+\t\"encoding\"\n \t\"errors\"\n \t\"io\"\n \t\"math\"\n@@ -450,25 +451,25 @@ type decEngine struct {\n \n // allocate makes sure storage is available for an object of underlying type rtyp\n // that is indir levels of indirection through p.\n-func allocate(rtyp reflect.Type, p uintptr, indir int) uintptr {\n+func allocate(rtyp reflect.Type, p unsafe.Pointer, indir int) unsafe.Pointer {\n \tif indir == 0 {\n \t\treturn p\n \t}\n-\tup := unsafe.Pointer(p)\n+\tup := p\n \tif indir > 1 {\n \t\tup = decIndirect(up, indir)\n \t}\n \tif *(*unsafe.Pointer)(up) == nil {\n \t\t// Allocate object.\n \t\t*(*unsafe.Pointer)(up) = unsafe.Pointer(reflect.New(rtyp).Pointer())\n \t}\n-\treturn *(*uintptr)(up)\n+\treturn *(*unsafe.Pointer)(up)\n }\n \n // decodeSingle decodes a top-level value that is not a struct and stores it through p.\n // Such values are preceded by a zero, making them have the memory layout of a\n // struct field (although with an illegal field number).\n-func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uintptr) {\n+func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep unsafe.Pointer) {\n \tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = singletonField\n \tdelta := int(state.decodeUint())\n@@ -479,7 +480,7 @@ func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uint\n \tif instr.indir != ut.indir {\n \t\terrorf(\"internal error: inconsistent indirection instr %d ut %d\", instr.indir, ut.indir)\n \t}\n-\tptr := unsafe.Pointer(basep) // offset will be zero\n+\tptr := basep // offset will be zero\n \tif instr.indir > 1 {\n \t\tptr = decIndirect(ptr, instr.indir)\n \t}\n@@ -492,7 +493,7 @@ func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uint\n // differ from ut.indir, which was computed when the engine was built.\n // This state cannot arise for decodeSingle, which is called directly\n // from the user's value, not from the innards of an engine.\n-func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p uintptr, indir int) {\n+func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p unsafe.Pointer, indir int) {\n \tp = allocate(ut.base, p, indir)\n \tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = -1\n@@ -511,7 +512,7 @@ func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p uintptr,\n \t\t\tbreak\n \t\t}\n \t\tinstr := &engine.instr[fieldnum]\n-\t\tp := unsafe.Pointer(basep + instr.offset)\n+\t\tp := unsafe.Pointer(uintptr(basep) + instr.offset)\n \t\tif instr.indir > 1 {\n \t\t\tp = decIndirect(p, instr.indir)\n \t\t}\n@@ -559,25 +560,25 @@ func (dec *Decoder) ignoreSingle(engine *decEngine) {\n }\n \n // decodeArrayHelper does the work for decoding arrays and slices.\n-func (dec *Decoder) decodeArrayHelper(state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl error) {\n+func (dec *Decoder) decodeArrayHelper(state *decoderState, p unsafe.Pointer, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl error) {\n \tinstr := &decInstr{elemOp, 0, elemIndir, 0, ovfl}\n \tfor i := 0; i < length; i++ {\n \t\tif state.b.Len() == 0 {\n \t\t\terrorf(\"decoding array or slice: length exceeds input size (%d elements)\", length)\n \t\t}\n-\t\tup := unsafe.Pointer(p)\n+\t\tup := p\n \t\tif elemIndir > 1 {\n \t\t\tup = decIndirect(up, elemIndir)\n \t\t}\n \t\telemOp(instr, state, up)\n-\t\tp += uintptr(elemWid)\n+\t\tp = unsafe.Pointer(uintptr(p) + elemWid)\n \t}\n }\n \n // decodeArray decodes an array and stores it through p, that is, p points to the zeroth element.\n // The length is an unsigned integer preceding the elements.  Even though the length is redundant\n // (it's part of the type), it's a useful check and is included in the encoding.\n-func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl error) {\n+func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, p unsafe.Pointer, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl error) {\n \tif indir > 0 {\n \t\tp = allocate(atyp, p, 1) // All but the last level has been allocated by dec.Indirect\n \t}\n@@ -591,7 +592,7 @@ func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, p uintpt\n // unlike the other items we can't use a pointer directly.\n func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value, ovfl error) reflect.Value {\n \tinstr := &decInstr{op, 0, indir, 0, ovfl}\n-\tup := unsafe.Pointer(unsafeAddr(v))\n+\tup := unsafeAddr(v)\n \tif indir > 1 {\n \t\tup = decIndirect(up, indir)\n \t}\n@@ -603,7 +604,7 @@ func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value,\n // Maps are encoded as a length followed by key:value pairs.\n // Because the internals of maps are not visible to us, we must\n // use reflection rather than pointer magic.\n-func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, p uintptr, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl error) {\n+func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, p unsafe.Pointer, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl error) {\n \tif indir > 0 {\n \t\tp = allocate(mtyp, p, 1) // All but the last level has been allocated by dec.Indirect\n \t}\n@@ -673,7 +674,7 @@ func (dec *Decoder) decodeSlice(atyp reflect.Type, state *decoderState, p uintpt\n \t\thdrp.Cap = n\n \t}\n \thdrp.Len = n\n-\tdec.decodeArrayHelper(state, hdrp.Data, elemOp, elemWid, n, elemIndir, ovfl)\n+\tdec.decodeArrayHelper(state, unsafe.Pointer(hdrp.Data), elemOp, elemWid, n, elemIndir, ovfl)\n }\n \n // ignoreSlice skips over the data for a slice value with no destination.\n@@ -693,7 +694,7 @@ func setInterfaceValue(ivalue reflect.Value, value reflect.Value) {\n // decodeInterface decodes an interface value and stores it through p.\n // Interfaces are encoded as the name of a concrete type followed by a value.\n // If the name is empty, the value is nil and no value is sent.\n-func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p uintptr, indir int) {\n+func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p unsafe.Pointer, indir int) {\n \t// Create a writable interface reflect.Value.  We need one even for the nil case.\n \tivalue := allocValue(ityp)\n \t// Read the name of the concrete type.\n@@ -767,15 +768,22 @@ func (dec *Decoder) ignoreInterface(state *decoderState) {\n \n // decodeGobDecoder decodes something implementing the GobDecoder interface.\n // The data is encoded as a byte slice.\n-func (dec *Decoder) decodeGobDecoder(state *decoderState, v reflect.Value) {\n+func (dec *Decoder) decodeGobDecoder(ut *userTypeInfo, state *decoderState, v reflect.Value) {\n \t// Read the bytes for the value.\n \tb := make([]byte, state.decodeUint())\n \t_, err := state.b.Read(b)\n \tif err != nil {\n \t\terror_(err)\n \t}\n-\t// We know it's a GobDecoder, so just call the method directly.\n-\terr = v.Interface().(GobDecoder).GobDecode(b)\n+\t// We know it's one of these.\n+\tswitch ut.externalDec {\n+\tcase xGob:\n+\t\terr = v.Interface().(GobDecoder).GobDecode(b)\n+\tcase xBinary:\n+\t\terr = v.Interface().(encoding.BinaryUnmarshaler).UnmarshalBinary(b)\n+\tcase xText:\n+\t\terr = v.Interface().(encoding.TextUnmarshaler).UnmarshalText(b)\n+\t}\n \tif err != nil {\n \t\terror_(err)\n \t}\n@@ -825,9 +833,10 @@ var decIgnoreOpMap = map[typeId]decOp{\n func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProgress map[reflect.Type]*decOp) (*decOp, int) {\n \tut := userType(rt)\n \t// If the type implements GobEncoder, we handle it without further processing.\n-\tif ut.isGobDecoder {\n+\tif ut.externalDec != 0 {\n \t\treturn dec.gobDecodeOpFor(ut)\n \t}\n+\n \t// If this type is already in progress, it's a recursive type (e.g. map[string]*T).\n \t// Return the pointer to the op we're already building.\n \tif opPtr := inProgress[rt]; opPtr != nil {\n@@ -850,7 +859,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t\t\tstate.dec.decodeArray(t, state, uintptr(p), *elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl)\n+\t\t\t\tstate.dec.decodeArray(t, state, p, *elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl)\n \t\t\t}\n \n \t\tcase reflect.Map:\n@@ -860,8 +869,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), \"element of \"+name, inProgress)\n \t\t\tovfl := overflow(name)\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t\t\tup := unsafe.Pointer(p)\n-\t\t\t\tstate.dec.decodeMap(t, state, uintptr(up), *keyOp, *elemOp, i.indir, keyIndir, elemIndir, ovfl)\n+\t\t\t\tstate.dec.decodeMap(t, state, p, *keyOp, *elemOp, i.indir, keyIndir, elemIndir, ovfl)\n \t\t\t}\n \n \t\tcase reflect.Slice:\n@@ -890,11 +898,11 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t}\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs.\n-\t\t\t\tdec.decodeStruct(*enginePtr, userType(typ), uintptr(p), i.indir)\n+\t\t\t\tdec.decodeStruct(*enginePtr, userType(typ), p, i.indir)\n \t\t\t}\n \t\tcase reflect.Interface:\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t\t\tstate.dec.decodeInterface(t, state, uintptr(p), i.indir)\n+\t\t\t\tstate.dec.decodeInterface(t, state, p, i.indir)\n \t\t\t}\n \t\t}\n \t}\n@@ -955,7 +963,7 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\t\t\tstate.dec.ignoreStruct(*enginePtr)\n \t\t\t}\n \n-\t\tcase wire.GobEncoderT != nil:\n+\t\tcase wire.GobEncoderT != nil, wire.BinaryMarshalerT != nil, wire.TextMarshalerT != nil:\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tstate.dec.ignoreGobDecoder(state)\n \t\t\t}\n@@ -994,7 +1002,7 @@ func (dec *Decoder) gobDecodeOpFor(ut *userTypeInfo) (*decOp, int) {\n \t\t} else {\n \t\t\tv = reflect.NewAt(rcvrType, p).Elem()\n \t\t}\n-\t\tstate.dec.decodeGobDecoder(state, v)\n+\t\tstate.dec.decodeGobDecoder(ut, state, v)\n \t}\n \treturn &op, int(ut.indir)\n \n@@ -1011,12 +1019,18 @@ func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[re\n \tinProgress[fr] = fw\n \tut := userType(fr)\n \twire, ok := dec.wireType[fw]\n-\t// If fr is a GobDecoder, the wire type must be GobEncoder.\n-\t// And if fr is not a GobDecoder, the wire type must not be either.\n-\tif ut.isGobDecoder != (ok && wire.GobEncoderT != nil) { // the parentheses look odd but are correct.\n+\t// If wire was encoded with an encoding method, fr must have that method.\n+\t// And if not, it must not.\n+\t// At most one of the booleans in ut is set.\n+\t// We could possibly relax this constraint in the future in order to\n+\t// choose the decoding method using the data in the wireType.\n+\t// The parentheses look odd but are correct.\n+\tif (ut.externalDec == xGob) != (ok && wire.GobEncoderT != nil) ||\n+\t\t(ut.externalDec == xBinary) != (ok && wire.BinaryMarshalerT != nil) ||\n+\t\t(ut.externalDec == xText) != (ok && wire.TextMarshalerT != nil) {\n \t\treturn false\n \t}\n-\tif ut.isGobDecoder { // This test trumps all others.\n+\tif ut.externalDec != 0 { // This test trumps all others.\n \t\treturn true\n \t}\n \tswitch t := ut.base; t.Kind() {\n@@ -1115,8 +1129,7 @@ func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err\n func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err error) {\n \trt := ut.base\n \tsrt := rt\n-\tif srt.Kind() != reflect.Struct ||\n-\t\tut.isGobDecoder {\n+\tif srt.Kind() != reflect.Struct || ut.externalDec != 0 {\n \t\treturn dec.compileSingle(remoteId, ut)\n \t}\n \tvar wireStruct *structType\n@@ -1224,14 +1237,14 @@ func (dec *Decoder) decodeValue(wireId typeId, val reflect.Value) {\n \t\treturn\n \t}\n \tengine := *enginePtr\n-\tif st := base; st.Kind() == reflect.Struct && !ut.isGobDecoder {\n+\tif st := base; st.Kind() == reflect.Struct && ut.externalDec == 0 {\n \t\tif engine.numInstr == 0 && st.NumField() > 0 && len(dec.wireType[wireId].StructT.Field) > 0 {\n \t\t\tname := base.Name()\n \t\t\terrorf(\"type mismatch: no fields matched compiling decoder for %s\", name)\n \t\t}\n-\t\tdec.decodeStruct(engine, ut, uintptr(unsafeAddr(val)), ut.indir)\n+\t\tdec.decodeStruct(engine, ut, unsafeAddr(val), ut.indir)\n \t} else {\n-\t\tdec.decodeSingle(engine, ut, uintptr(unsafeAddr(val)))\n+\t\tdec.decodeSingle(engine, ut, unsafeAddr(val))\n \t}\n }\n \n@@ -1283,13 +1296,13 @@ func init() {\n // into existing structs or slices cannot be addressed,\n // so simulate it by returning a pointer to a copy.\n // Each call allocates once.\n-func unsafeAddr(v reflect.Value) uintptr {\n+func unsafeAddr(v reflect.Value) unsafe.Pointer {\n \tif v.CanAddr() {\n-\t\treturn v.UnsafeAddr()\n+\t\treturn unsafe.Pointer(v.UnsafeAddr())\n \t}\n \tx := reflect.New(v.Type()).Elem()\n \tx.Set(v)\n-\treturn x.UnsafeAddr()\n+\treturn unsafe.Pointer(x.UnsafeAddr())\n }\n \n // Gob depends on being able to take the address"}, {"sha": "28f0c05a5c5fdc3d919f8fa7b29eec95f02ac98f", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -8,6 +8,12 @@ Encoder (transmitter) and a Decoder (receiver).  A typical use is transporting\n arguments and results of remote procedure calls (RPCs) such as those provided by\n package \"rpc\".\n \n+The implementation compiles a custom codec for each data type in the stream and\n+is most efficient when a single Encoder is used to transmit a stream of values,\n+amortizing the cost of compilation.\n+\n+Basics\n+\n A stream of gobs is self-describing.  Each data item in the stream is preceded by\n a specification of its type, expressed in terms of a small set of predefined\n types.  Pointers are not transmitted, but the things they point to are\n@@ -20,6 +26,8 @@ all type information is sent before it is needed.  At the receive side, a\n Decoder retrieves values from the encoded stream and unpacks them into local\n variables.\n \n+Types and Values\n+\n The source and destination values/types need not correspond exactly.  For structs,\n fields (identified by name) that are in the source but absent from the receiving\n variable will be ignored.  Fields that are in the receiving variable but missing\n@@ -67,19 +75,29 @@ point values may be received into any floating point variable.  However,\n the destination variable must be able to represent the value or the decode\n operation will fail.\n \n-Structs, arrays and slices are also supported.  Structs encode and\n-decode only exported fields. Strings and arrays of bytes are supported\n-with a special, efficient representation (see below).  When a slice\n-is decoded, if the existing slice has capacity the slice will be\n-extended in place; if not, a new array is allocated.  Regardless,\n-the length of the resulting slice reports the number of elements\n-decoded.\n+Structs, arrays and slices are also supported. Structs encode and decode only\n+exported fields. Strings and arrays of bytes are supported with a special,\n+efficient representation (see below). When a slice is decoded, if the existing\n+slice has capacity the slice will be extended in place; if not, a new array is\n+allocated. Regardless, the length of the resulting slice reports the number of\n+elements decoded.\n+\n+Functions and channels will not be sent in a gob. Attempting to encode such a value\n+at top the level will fail. A struct field of chan or func type is treated exactly\n+like an unexported field and is ignored.\n+\n+Gob can encode a value of any type implementing the GobEncoder,\n+encoding.BinaryMarshaler, or encoding.TextMarshaler interfaces by calling the\n+corresponding method, in that order of preference.\n+\n+Gob can decode a value of any type implementing the GobDecoder,\n+encoding.BinaryUnmarshaler, or encoding.TextUnmarshaler interfaces by calling\n+the corresponding method, again in that order of preference.\n \n-Functions and channels cannot be sent in a gob.  Attempting\n-to encode a value that contains one will fail.\n+Encoding Details\n \n-The rest of this comment documents the encoding, details that are not important\n-for most users.  Details are presented bottom-up.\n+This section documents the encoding, details that are not important for most\n+users. Details are presented bottom-up.\n \n An unsigned integer is sent one of two ways.  If it is less than 128, it is sent\n as a byte with that value.  Otherwise it is sent as a minimal-length big-endian"}, {"sha": "d158b6442a8c7f9f3348d3443683cdfbe2d1504a", "filename": "libgo/go/encoding/gob/encode.go", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,6 +6,7 @@ package gob\n \n import (\n \t\"bytes\"\n+\t\"encoding\"\n \t\"math\"\n \t\"reflect\"\n \t\"unsafe\"\n@@ -338,14 +339,14 @@ type encEngine struct {\n const singletonField = 0\n \n // encodeSingle encodes a single top-level non-struct value.\n-func (enc *Encoder) encodeSingle(b *bytes.Buffer, engine *encEngine, basep uintptr) {\n+func (enc *Encoder) encodeSingle(b *bytes.Buffer, engine *encEngine, basep unsafe.Pointer) {\n \tstate := enc.newEncoderState(b)\n \tstate.fieldnum = singletonField\n \t// There is no surrounding struct to frame the transmission, so we must\n \t// generate data even if the item is zero.  To do this, set sendZero.\n \tstate.sendZero = true\n \tinstr := &engine.instr[singletonField]\n-\tp := unsafe.Pointer(basep) // offset will be zero\n+\tp := basep // offset will be zero\n \tif instr.indir > 0 {\n \t\tif p = encIndirect(p, instr.indir); p == nil {\n \t\t\treturn\n@@ -356,12 +357,12 @@ func (enc *Encoder) encodeSingle(b *bytes.Buffer, engine *encEngine, basep uintp\n }\n \n // encodeStruct encodes a single struct value.\n-func (enc *Encoder) encodeStruct(b *bytes.Buffer, engine *encEngine, basep uintptr) {\n+func (enc *Encoder) encodeStruct(b *bytes.Buffer, engine *encEngine, basep unsafe.Pointer) {\n \tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tfor i := 0; i < len(engine.instr); i++ {\n \t\tinstr := &engine.instr[i]\n-\t\tp := unsafe.Pointer(basep + instr.offset)\n+\t\tp := unsafe.Pointer(uintptr(basep) + instr.offset)\n \t\tif instr.indir > 0 {\n \t\t\tif p = encIndirect(p, instr.indir); p == nil {\n \t\t\t\tcontinue\n@@ -373,22 +374,22 @@ func (enc *Encoder) encodeStruct(b *bytes.Buffer, engine *encEngine, basep uintp\n }\n \n // encodeArray encodes the array whose 0th element is at p.\n-func (enc *Encoder) encodeArray(b *bytes.Buffer, p uintptr, op encOp, elemWid uintptr, elemIndir int, length int) {\n+func (enc *Encoder) encodeArray(b *bytes.Buffer, p unsafe.Pointer, op encOp, elemWid uintptr, elemIndir int, length int) {\n \tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n \tstate.encodeUint(uint64(length))\n \tfor i := 0; i < length; i++ {\n \t\telemp := p\n-\t\tup := unsafe.Pointer(elemp)\n \t\tif elemIndir > 0 {\n-\t\t\tif up = encIndirect(up, elemIndir); up == nil {\n+\t\t\tup := encIndirect(elemp, elemIndir)\n+\t\t\tif up == nil {\n \t\t\t\terrorf(\"encodeArray: nil element\")\n \t\t\t}\n-\t\t\telemp = uintptr(up)\n+\t\t\telemp = up\n \t\t}\n-\t\top(nil, state, unsafe.Pointer(elemp))\n-\t\tp += uintptr(elemWid)\n+\t\top(nil, state, elemp)\n+\t\tp = unsafe.Pointer(uintptr(p) + elemWid)\n \t}\n \tenc.freeEncoderState(state)\n }\n@@ -401,7 +402,7 @@ func encodeReflectValue(state *encoderState, v reflect.Value, op encOp, indir in\n \tif !v.IsValid() {\n \t\terrorf(\"encodeReflectValue: nil element\")\n \t}\n-\top(nil, state, unsafe.Pointer(unsafeAddr(v)))\n+\top(nil, state, unsafeAddr(v))\n }\n \n // encodeMap encodes a map as unsigned count followed by key:value pairs.\n@@ -474,7 +475,7 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n \tenc.freeEncoderState(state)\n }\n \n-// isZero returns whether the value is the zero of its type.\n+// isZero reports whether the value is the zero of its type.\n func isZero(val reflect.Value) bool {\n \tswitch val.Kind() {\n \tcase reflect.Array:\n@@ -511,10 +512,20 @@ func isZero(val reflect.Value) bool {\n \n // encGobEncoder encodes a value that implements the GobEncoder interface.\n // The data is sent as a byte array.\n-func (enc *Encoder) encodeGobEncoder(b *bytes.Buffer, v reflect.Value) {\n+func (enc *Encoder) encodeGobEncoder(b *bytes.Buffer, ut *userTypeInfo, v reflect.Value) {\n \t// TODO: should we catch panics from the called method?\n-\t// We know it's a GobEncoder, so just call the method directly.\n-\tdata, err := v.Interface().(GobEncoder).GobEncode()\n+\n+\tvar data []byte\n+\tvar err error\n+\t// We know it's one of these.\n+\tswitch ut.externalEnc {\n+\tcase xGob:\n+\t\tdata, err = v.Interface().(GobEncoder).GobEncode()\n+\tcase xBinary:\n+\t\tdata, err = v.Interface().(encoding.BinaryMarshaler).MarshalBinary()\n+\tcase xText:\n+\t\tdata, err = v.Interface().(encoding.TextMarshaler).MarshalText()\n+\t}\n \tif err != nil {\n \t\terror_(err)\n \t}\n@@ -550,7 +561,7 @@ var encOpTable = [...]encOp{\n func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp) (*encOp, int) {\n \tut := userType(rt)\n \t// If the type implements GobEncoder, we handle it without further processing.\n-\tif ut.isGobEncoder {\n+\tif ut.externalEnc != 0 {\n \t\treturn enc.gobEncodeOpFor(ut)\n \t}\n \t// If this type is already in progress, it's a recursive type (e.g. map[string]*T).\n@@ -575,21 +586,21 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\t\tbreak\n \t\t\t}\n \t\t\t// Slices have a header; we decode it to find the underlying array.\n-\t\t\telemOp, indir := enc.encOpFor(t.Elem(), inProgress)\n+\t\t\telemOp, elemIndir := enc.encOpFor(t.Elem(), inProgress)\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\tslice := (*reflect.SliceHeader)(p)\n \t\t\t\tif !state.sendZero && slice.Len == 0 {\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tstate.update(i)\n-\t\t\t\tstate.enc.encodeArray(state.b, slice.Data, *elemOp, t.Elem().Size(), indir, int(slice.Len))\n+\t\t\t\tstate.enc.encodeArray(state.b, unsafe.Pointer(slice.Data), *elemOp, t.Elem().Size(), elemIndir, int(slice.Len))\n \t\t\t}\n \t\tcase reflect.Array:\n \t\t\t// True arrays have size in the type.\n-\t\t\telemOp, indir := enc.encOpFor(t.Elem(), inProgress)\n+\t\t\telemOp, elemIndir := enc.encOpFor(t.Elem(), inProgress)\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\tstate.update(i)\n-\t\t\t\tstate.enc.encodeArray(state.b, uintptr(p), *elemOp, t.Elem().Size(), indir, t.Len())\n+\t\t\t\tstate.enc.encodeArray(state.b, p, *elemOp, t.Elem().Size(), elemIndir, t.Len())\n \t\t\t}\n \t\tcase reflect.Map:\n \t\t\tkeyOp, keyIndir := enc.encOpFor(t.Key(), inProgress)\n@@ -615,7 +626,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\tstate.update(i)\n \t\t\t\t// indirect through info to delay evaluation for recursive structs\n-\t\t\t\tstate.enc.encodeStruct(state.b, info.encoder, uintptr(p))\n+\t\t\t\tstate.enc.encodeStruct(state.b, info.encoder, p)\n \t\t\t}\n \t\tcase reflect.Interface:\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n@@ -661,7 +672,7 @@ func (enc *Encoder) gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n \t\t\treturn\n \t\t}\n \t\tstate.update(i)\n-\t\tstate.enc.encodeGobEncoder(state.b, v)\n+\t\tstate.enc.encodeGobEncoder(state.b, ut, v)\n \t}\n \treturn &op, int(ut.encIndir) // encIndir: op will get called with p == address of receiver.\n }\n@@ -672,14 +683,13 @@ func (enc *Encoder) compileEnc(ut *userTypeInfo) *encEngine {\n \tengine := new(encEngine)\n \tseen := make(map[reflect.Type]*encOp)\n \trt := ut.base\n-\tif ut.isGobEncoder {\n+\tif ut.externalEnc != 0 {\n \t\trt = ut.user\n \t}\n-\tif !ut.isGobEncoder &&\n-\t\tsrt.Kind() == reflect.Struct {\n+\tif ut.externalEnc == 0 && srt.Kind() == reflect.Struct {\n \t\tfor fieldNum, wireFieldNum := 0, 0; fieldNum < srt.NumField(); fieldNum++ {\n \t\t\tf := srt.Field(fieldNum)\n-\t\t\tif !isExported(f.Name) {\n+\t\t\tif !isSent(&f) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\top, indir := enc.encOpFor(f.Type, seen)\n@@ -736,13 +746,13 @@ func (enc *Encoder) encode(b *bytes.Buffer, value reflect.Value, ut *userTypeInf\n \tdefer catchError(&enc.err)\n \tengine := enc.lockAndGetEncEngine(ut)\n \tindir := ut.indir\n-\tif ut.isGobEncoder {\n+\tif ut.externalEnc != 0 {\n \t\tindir = int(ut.encIndir)\n \t}\n \tfor i := 0; i < indir; i++ {\n \t\tvalue = reflect.Indirect(value)\n \t}\n-\tif !ut.isGobEncoder && value.Type().Kind() == reflect.Struct {\n+\tif ut.externalEnc == 0 && value.Type().Kind() == reflect.Struct {\n \t\tenc.encodeStruct(b, engine, unsafeAddr(value))\n \t} else {\n \t\tenc.encodeSingle(b, engine, unsafeAddr(value))"}, {"sha": "a3301c3bd338304b3722d1e8b41e427018ae8e77", "filename": "libgo/go/encoding/gob/encoder.go", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,7 +6,6 @@ package gob\n \n import (\n \t\"bytes\"\n-\t\"errors\"\n \t\"io\"\n \t\"reflect\"\n \t\"sync\"\n@@ -54,10 +53,6 @@ func (enc *Encoder) popWriter() {\n \tenc.w = enc.w[0 : len(enc.w)-1]\n }\n \n-func (enc *Encoder) badType(rt reflect.Type) {\n-\tenc.setError(errors.New(\"gob: can't encode type \" + rt.String()))\n-}\n-\n func (enc *Encoder) setError(err error) {\n \tif enc.err == nil { // remember the first.\n \t\tenc.err = err\n@@ -135,7 +130,7 @@ func (enc *Encoder) sendActualType(w io.Writer, state *encoderState, ut *userTyp\n // sendType sends the type info to the other side, if necessary.\n func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Type) (sent bool) {\n \tut := userType(origt)\n-\tif ut.isGobEncoder {\n+\tif ut.externalEnc != 0 {\n \t\t// The rules are different: regardless of the underlying type's representation,\n \t\t// we need to tell the other side that the base type is a GobEncoder.\n \t\treturn enc.sendActualType(w, state, ut, ut.base)\n@@ -163,8 +158,7 @@ func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Typ\n \t\t// structs must be sent so we know their fields.\n \t\tbreak\n \tcase reflect.Chan, reflect.Func:\n-\t\t// Probably a bad field in a struct.\n-\t\tenc.badType(rt)\n+\t\t// If we get here, it's a field of a struct; ignore it.\n \t\treturn\n \t}\n \n@@ -184,7 +178,7 @@ func (enc *Encoder) sendTypeDescriptor(w io.Writer, state *encoderState, ut *use\n \t// Make sure the type is known to the other side.\n \t// First, have we already sent this type?\n \trt := ut.base\n-\tif ut.isGobEncoder {\n+\tif ut.externalEnc != 0 {\n \t\trt = ut.user\n \t}\n \tif _, alreadySent := enc.sent[rt]; !alreadySent {"}, {"sha": "4ecf51d122b755939f51690a100f7efcace27eda", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -131,7 +131,7 @@ func TestBadData(t *testing.T) {\n \tcorruptDataCheck(\"\\x03now is the time for all good men\", errBadType, t)\n }\n \n-// Types not supported by the Encoder.\n+// Types not supported at top level by the Encoder.\n var unsupportedValues = []interface{}{\n \tmake(chan int),\n \tfunc(a int) bool { return true },\n@@ -662,19 +662,35 @@ func TestSequentialDecoder(t *testing.T) {\n \t}\n }\n \n-// Should be able to have unrepresentable fields (chan, func) as long as they\n-// are unexported.\n+// Should be able to have unrepresentable fields (chan, func, *chan etc.); we just ignore them.\n type Bug2 struct {\n-\tA int\n-\tb chan int\n-}\n-\n-func TestUnexportedChan(t *testing.T) {\n-\tb := Bug2{23, make(chan int)}\n-\tvar stream bytes.Buffer\n-\tenc := NewEncoder(&stream)\n-\tif err := enc.Encode(b); err != nil {\n-\t\tt.Fatalf(\"error encoding unexported channel: %s\", err)\n+\tA   int\n+\tC   chan int\n+\tCP  *chan int\n+\tF   func()\n+\tFPP **func()\n+}\n+\n+func TestChanFuncIgnored(t *testing.T) {\n+\tc := make(chan int)\n+\tf := func() {}\n+\tfp := &f\n+\tb0 := Bug2{23, c, &c, f, &fp}\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\tif err := enc.Encode(b0); err != nil {\n+\t\tt.Fatal(\"error encoding:\", err)\n+\t}\n+\tvar b1 Bug2\n+\terr := NewDecoder(&buf).Decode(&b1)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode:\", err)\n+\t}\n+\tif b1.A != b0.A {\n+\t\tt.Fatalf(\"got %d want %d\", b1.A, b0.A)\n+\t}\n+\tif b1.C != nil || b1.CP != nil || b1.F != nil || b1.FPP != nil {\n+\t\tt.Fatal(\"unexpected value for chan or func\")\n \t}\n }\n "}, {"sha": "301551db48a7158c70db9d3f21a5daf96c958a22", "filename": "libgo/go/encoding/gob/gobencdec_test.go", "status": "modified", "additions": 127, "deletions": 19, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -34,6 +34,14 @@ type Gobber int\n \n type ValueGobber string // encodes with a value, decodes with a pointer.\n \n+type BinaryGobber int\n+\n+type BinaryValueGobber string\n+\n+type TextGobber int\n+\n+type TextValueGobber string\n+\n // The relevant methods\n \n func (g *ByteStruct) GobEncode() ([]byte, error) {\n@@ -101,6 +109,24 @@ func (g *Gobber) GobDecode(data []byte) error {\n \treturn err\n }\n \n+func (g *BinaryGobber) MarshalBinary() ([]byte, error) {\n+\treturn []byte(fmt.Sprintf(\"VALUE=%d\", *g)), nil\n+}\n+\n+func (g *BinaryGobber) UnmarshalBinary(data []byte) error {\n+\t_, err := fmt.Sscanf(string(data), \"VALUE=%d\", (*int)(g))\n+\treturn err\n+}\n+\n+func (g *TextGobber) MarshalText() ([]byte, error) {\n+\treturn []byte(fmt.Sprintf(\"VALUE=%d\", *g)), nil\n+}\n+\n+func (g *TextGobber) UnmarshalText(data []byte) error {\n+\t_, err := fmt.Sscanf(string(data), \"VALUE=%d\", (*int)(g))\n+\treturn err\n+}\n+\n func (v ValueGobber) GobEncode() ([]byte, error) {\n \treturn []byte(fmt.Sprintf(\"VALUE=%s\", v)), nil\n }\n@@ -110,6 +136,24 @@ func (v *ValueGobber) GobDecode(data []byte) error {\n \treturn err\n }\n \n+func (v BinaryValueGobber) MarshalBinary() ([]byte, error) {\n+\treturn []byte(fmt.Sprintf(\"VALUE=%s\", v)), nil\n+}\n+\n+func (v *BinaryValueGobber) UnmarshalBinary(data []byte) error {\n+\t_, err := fmt.Sscanf(string(data), \"VALUE=%s\", (*string)(v))\n+\treturn err\n+}\n+\n+func (v TextValueGobber) MarshalText() ([]byte, error) {\n+\treturn []byte(fmt.Sprintf(\"VALUE=%s\", v)), nil\n+}\n+\n+func (v *TextValueGobber) UnmarshalText(data []byte) error {\n+\t_, err := fmt.Sscanf(string(data), \"VALUE=%s\", (*string)(v))\n+\treturn err\n+}\n+\n // Structs that include GobEncodable fields.\n \n type GobTest0 struct {\n@@ -130,28 +174,42 @@ type GobTest2 struct {\n type GobTest3 struct {\n \tX int // guarantee we have  something in common with GobTest*\n \tG *Gobber\n+\tB *BinaryGobber\n+\tT *TextGobber\n }\n \n type GobTest4 struct {\n-\tX int // guarantee we have  something in common with GobTest*\n-\tV ValueGobber\n+\tX  int // guarantee we have  something in common with GobTest*\n+\tV  ValueGobber\n+\tBV BinaryValueGobber\n+\tTV TextValueGobber\n }\n \n type GobTest5 struct {\n-\tX int // guarantee we have  something in common with GobTest*\n-\tV *ValueGobber\n+\tX  int // guarantee we have  something in common with GobTest*\n+\tV  *ValueGobber\n+\tBV *BinaryValueGobber\n+\tTV *TextValueGobber\n }\n \n type GobTest6 struct {\n-\tX int // guarantee we have  something in common with GobTest*\n-\tV ValueGobber\n-\tW *ValueGobber\n+\tX  int // guarantee we have  something in common with GobTest*\n+\tV  ValueGobber\n+\tW  *ValueGobber\n+\tBV BinaryValueGobber\n+\tBW *BinaryValueGobber\n+\tTV TextValueGobber\n+\tTW *TextValueGobber\n }\n \n type GobTest7 struct {\n-\tX int // guarantee we have  something in common with GobTest*\n-\tV *ValueGobber\n-\tW ValueGobber\n+\tX  int // guarantee we have  something in common with GobTest*\n+\tV  *ValueGobber\n+\tW  ValueGobber\n+\tBV *BinaryValueGobber\n+\tBW BinaryValueGobber\n+\tTV *TextValueGobber\n+\tTW TextValueGobber\n }\n \n type GobTestIgnoreEncoder struct {\n@@ -198,7 +256,9 @@ func TestGobEncoderField(t *testing.T) {\n \t// Now a field that's not a structure.\n \tb.Reset()\n \tgobber := Gobber(23)\n-\terr = enc.Encode(GobTest3{17, &gobber})\n+\tbgobber := BinaryGobber(24)\n+\ttgobber := TextGobber(25)\n+\terr = enc.Encode(GobTest3{17, &gobber, &bgobber, &tgobber})\n \tif err != nil {\n \t\tt.Fatal(\"encode error:\", err)\n \t}\n@@ -207,7 +267,7 @@ func TestGobEncoderField(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"decode error:\", err)\n \t}\n-\tif *y.G != 23 {\n+\tif *y.G != 23 || *y.B != 24 || *y.T != 25 {\n \t\tt.Errorf(\"expected '23 got %d\", *y.G)\n \t}\n }\n@@ -357,7 +417,7 @@ func TestGobEncoderValueEncoder(t *testing.T) {\n \t// first, string in field to byte in field\n \tb := new(bytes.Buffer)\n \tenc := NewEncoder(b)\n-\terr := enc.Encode(GobTest4{17, ValueGobber(\"hello\")})\n+\terr := enc.Encode(GobTest4{17, ValueGobber(\"hello\"), BinaryValueGobber(\"\u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1\"), TextValueGobber(\"\u3053\u3093\u306b\u3061\u306f\")})\n \tif err != nil {\n \t\tt.Fatal(\"encode error:\", err)\n \t}\n@@ -367,8 +427,8 @@ func TestGobEncoderValueEncoder(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"decode error:\", err)\n \t}\n-\tif *x.V != \"hello\" {\n-\t\tt.Errorf(\"expected `hello` got %s\", x.V)\n+\tif *x.V != \"hello\" || *x.BV != \"\u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1\" || *x.TV != \"\u3053\u3093\u306b\u3061\u306f\" {\n+\t\tt.Errorf(\"expected `hello` got %s\", *x.V)\n \t}\n }\n \n@@ -377,20 +437,25 @@ func TestGobEncoderValueEncoder(t *testing.T) {\n func TestGobEncoderValueThenPointer(t *testing.T) {\n \tv := ValueGobber(\"forty-two\")\n \tw := ValueGobber(\"six-by-nine\")\n+\tbv := BinaryValueGobber(\"1nanocentury\")\n+\tbw := BinaryValueGobber(\"\u03c0seconds\")\n+\ttv := TextValueGobber(\"gravitationalacceleration\")\n+\ttw := TextValueGobber(\"\u03c0\u00b2ft/s\u00b2\")\n \n \t// this was a bug: encoding a GobEncoder by value before a GobEncoder\n \t// pointer would cause duplicate type definitions to be sent.\n \n \tb := new(bytes.Buffer)\n \tenc := NewEncoder(b)\n-\tif err := enc.Encode(GobTest6{42, v, &w}); err != nil {\n+\tif err := enc.Encode(GobTest6{42, v, &w, bv, &bw, tv, &tw}); err != nil {\n \t\tt.Fatal(\"encode error:\", err)\n \t}\n \tdec := NewDecoder(b)\n \tx := new(GobTest6)\n \tif err := dec.Decode(x); err != nil {\n \t\tt.Fatal(\"decode error:\", err)\n \t}\n+\n \tif got, want := x.V, v; got != want {\n \t\tt.Errorf(\"v = %q, want %q\", got, want)\n \t}\n@@ -399,32 +464,73 @@ func TestGobEncoderValueThenPointer(t *testing.T) {\n \t} else if *got != want {\n \t\tt.Errorf(\"w = %q, want %q\", *got, want)\n \t}\n+\n+\tif got, want := x.BV, bv; got != want {\n+\t\tt.Errorf(\"bv = %q, want %q\", got, want)\n+\t}\n+\tif got, want := x.BW, bw; got == nil {\n+\t\tt.Errorf(\"bw = nil, want %q\", want)\n+\t} else if *got != want {\n+\t\tt.Errorf(\"bw = %q, want %q\", *got, want)\n+\t}\n+\n+\tif got, want := x.TV, tv; got != want {\n+\t\tt.Errorf(\"tv = %q, want %q\", got, want)\n+\t}\n+\tif got, want := x.TW, tw; got == nil {\n+\t\tt.Errorf(\"tw = nil, want %q\", want)\n+\t} else if *got != want {\n+\t\tt.Errorf(\"tw = %q, want %q\", *got, want)\n+\t}\n }\n \n // Test that we can use a pointer then a value type of a GobEncoder\n // in the same encoded value.\n func TestGobEncoderPointerThenValue(t *testing.T) {\n \tv := ValueGobber(\"forty-two\")\n \tw := ValueGobber(\"six-by-nine\")\n+\tbv := BinaryValueGobber(\"1nanocentury\")\n+\tbw := BinaryValueGobber(\"\u03c0seconds\")\n+\ttv := TextValueGobber(\"gravitationalacceleration\")\n+\ttw := TextValueGobber(\"\u03c0\u00b2ft/s\u00b2\")\n \n \tb := new(bytes.Buffer)\n \tenc := NewEncoder(b)\n-\tif err := enc.Encode(GobTest7{42, &v, w}); err != nil {\n+\tif err := enc.Encode(GobTest7{42, &v, w, &bv, bw, &tv, tw}); err != nil {\n \t\tt.Fatal(\"encode error:\", err)\n \t}\n \tdec := NewDecoder(b)\n \tx := new(GobTest7)\n \tif err := dec.Decode(x); err != nil {\n \t\tt.Fatal(\"decode error:\", err)\n \t}\n+\n \tif got, want := x.V, v; got == nil {\n \t\tt.Errorf(\"v = nil, want %q\", want)\n \t} else if *got != want {\n-\t\tt.Errorf(\"v = %q, want %q\", got, want)\n+\t\tt.Errorf(\"v = %q, want %q\", *got, want)\n \t}\n \tif got, want := x.W, w; got != want {\n \t\tt.Errorf(\"w = %q, want %q\", got, want)\n \t}\n+\n+\tif got, want := x.BV, bv; got == nil {\n+\t\tt.Errorf(\"bv = nil, want %q\", want)\n+\t} else if *got != want {\n+\t\tt.Errorf(\"bv = %q, want %q\", *got, want)\n+\t}\n+\tif got, want := x.BW, bw; got != want {\n+\t\tt.Errorf(\"bw = %q, want %q\", got, want)\n+\t}\n+\n+\tif got, want := x.TV, tv; got == nil {\n+\t\tt.Errorf(\"tv = nil, want %q\", want)\n+\t} else if *got != want {\n+\t\tt.Errorf(\"tv = %q, want %q\", *got, want)\n+\t}\n+\tif got, want := x.TW, tw; got != want {\n+\t\tt.Errorf(\"tw = %q, want %q\", got, want)\n+\t}\n }\n \n func TestGobEncoderFieldTypeError(t *testing.T) {\n@@ -521,7 +627,9 @@ func TestGobEncoderIgnoreNonStructField(t *testing.T) {\n \t// First a field that's a structure.\n \tenc := NewEncoder(b)\n \tgobber := Gobber(23)\n-\terr := enc.Encode(GobTest3{17, &gobber})\n+\tbgobber := BinaryGobber(24)\n+\ttgobber := TextGobber(25)\n+\terr := enc.Encode(GobTest3{17, &gobber, &bgobber, &tgobber})\n \tif err != nil {\n \t\tt.Fatal(\"encode error:\", err)\n \t}"}, {"sha": "9fbb0ac6d5a556029d97e1e2100a078a352b49bf", "filename": "libgo/go/encoding/gob/timing_test.go", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,7 +6,6 @@ package gob\n \n import (\n \t\"bytes\"\n-\t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"runtime\"\n@@ -50,6 +49,9 @@ func BenchmarkEndToEndByteBuffer(b *testing.B) {\n }\n \n func TestCountEncodeMallocs(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping malloc count in short mode\")\n+\t}\n \tif runtime.GOMAXPROCS(0) > 1 {\n \t\tt.Skip(\"skipping; GOMAXPROCS>1\")\n \t}\n@@ -66,10 +68,15 @@ func TestCountEncodeMallocs(t *testing.T) {\n \t\t\tt.Fatal(\"encode:\", err)\n \t\t}\n \t})\n-\tfmt.Printf(\"mallocs per encode of type Bench: %v\\n\", allocs)\n+\tif allocs != 0 {\n+\t\tt.Fatalf(\"mallocs per encode of type Bench: %v; wanted 0\\n\", allocs)\n+\t}\n }\n \n func TestCountDecodeMallocs(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping malloc count in short mode\")\n+\t}\n \tif runtime.GOMAXPROCS(0) > 1 {\n \t\tt.Skip(\"skipping; GOMAXPROCS>1\")\n \t}\n@@ -96,5 +103,7 @@ func TestCountDecodeMallocs(t *testing.T) {\n \t\t\tt.Fatal(\"decode:\", err)\n \t\t}\n \t})\n-\tfmt.Printf(\"mallocs per decode of type Bench: %v\\n\", allocs)\n+\tif allocs != 3 {\n+\t\tt.Fatalf(\"mallocs per decode of type Bench: %v; wanted 3\\n\", allocs)\n+\t}\n }"}, {"sha": "65bf17b7f02b33bf56af6f5a48bdf7d05efe9643", "filename": "libgo/go/encoding/gob/type.go", "status": "modified", "additions": 82, "deletions": 22, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -5,6 +5,7 @@\n package gob\n \n import (\n+\t\"encoding\"\n \t\"errors\"\n \t\"fmt\"\n \t\"os\"\n@@ -18,14 +19,21 @@ import (\n // to the package.  It's computed once and stored in a map keyed by reflection\n // type.\n type userTypeInfo struct {\n-\tuser         reflect.Type // the type the user handed us\n-\tbase         reflect.Type // the base type after all indirections\n-\tindir        int          // number of indirections to reach the base type\n-\tisGobEncoder bool         // does the type implement GobEncoder?\n-\tisGobDecoder bool         // does the type implement GobDecoder?\n-\tencIndir     int8         // number of indirections to reach the receiver type; may be negative\n-\tdecIndir     int8         // number of indirections to reach the receiver type; may be negative\n-}\n+\tuser        reflect.Type // the type the user handed us\n+\tbase        reflect.Type // the base type after all indirections\n+\tindir       int          // number of indirections to reach the base type\n+\texternalEnc int          // xGob, xBinary, or xText\n+\texternalDec int          // xGob, xBinary or xText\n+\tencIndir    int8         // number of indirections to reach the receiver type; may be negative\n+\tdecIndir    int8         // number of indirections to reach the receiver type; may be negative\n+}\n+\n+// externalEncoding bits\n+const (\n+\txGob    = 1 + iota // GobEncoder or GobDecoder\n+\txBinary            // encoding.BinaryMarshaler or encoding.BinaryUnmarshaler\n+\txText              // encoding.TextMarshaler or encoding.TextUnmarshaler\n+)\n \n var (\n \t// Protected by an RWMutex because we read it a lot and write\n@@ -75,15 +83,34 @@ func validUserType(rt reflect.Type) (ut *userTypeInfo, err error) {\n \t\t}\n \t\tut.indir++\n \t}\n-\tut.isGobEncoder, ut.encIndir = implementsInterface(ut.user, gobEncoderInterfaceType)\n-\tut.isGobDecoder, ut.decIndir = implementsInterface(ut.user, gobDecoderInterfaceType)\n+\n+\tif ok, indir := implementsInterface(ut.user, gobEncoderInterfaceType); ok {\n+\t\tut.externalEnc, ut.encIndir = xGob, indir\n+\t} else if ok, indir := implementsInterface(ut.user, binaryMarshalerInterfaceType); ok {\n+\t\tut.externalEnc, ut.encIndir = xBinary, indir\n+\t} else if ok, indir := implementsInterface(ut.user, textMarshalerInterfaceType); ok {\n+\t\tut.externalEnc, ut.encIndir = xText, indir\n+\t}\n+\n+\tif ok, indir := implementsInterface(ut.user, gobDecoderInterfaceType); ok {\n+\t\tut.externalDec, ut.decIndir = xGob, indir\n+\t} else if ok, indir := implementsInterface(ut.user, binaryUnmarshalerInterfaceType); ok {\n+\t\tut.externalDec, ut.decIndir = xBinary, indir\n+\t} else if ok, indir := implementsInterface(ut.user, textUnmarshalerInterfaceType); ok {\n+\t\tut.externalDec, ut.decIndir = xText, indir\n+\t}\n+\n \tuserTypeCache[rt] = ut\n \treturn\n }\n \n var (\n-\tgobEncoderInterfaceType = reflect.TypeOf((*GobEncoder)(nil)).Elem()\n-\tgobDecoderInterfaceType = reflect.TypeOf((*GobDecoder)(nil)).Elem()\n+\tgobEncoderInterfaceType        = reflect.TypeOf((*GobEncoder)(nil)).Elem()\n+\tgobDecoderInterfaceType        = reflect.TypeOf((*GobDecoder)(nil)).Elem()\n+\tbinaryMarshalerInterfaceType   = reflect.TypeOf((*encoding.BinaryMarshaler)(nil)).Elem()\n+\tbinaryUnmarshalerInterfaceType = reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()\n+\ttextMarshalerInterfaceType     = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()\n+\ttextUnmarshalerInterfaceType   = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()\n )\n \n // implementsInterface reports whether the type implements the\n@@ -412,7 +439,7 @@ func newStructType(name string) *structType {\n // works through typeIds and userTypeInfos alone.\n func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, error) {\n \t// Does this type implement GobEncoder?\n-\tif ut.isGobEncoder {\n+\tif ut.externalEnc != 0 {\n \t\treturn newGobEncoderType(name), nil\n \t}\n \tvar err error\n@@ -499,7 +526,7 @@ func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, err\n \t\tidToType[st.id()] = st\n \t\tfor i := 0; i < t.NumField(); i++ {\n \t\t\tf := t.Field(i)\n-\t\t\tif !isExported(f.Name) {\n+\t\t\tif !isSent(&f) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\ttyp := userType(f.Type).base\n@@ -534,6 +561,25 @@ func isExported(name string) bool {\n \treturn unicode.IsUpper(rune)\n }\n \n+// isSent reports whether this struct field is to be transmitted.\n+// It will be transmitted only if it is exported and not a chan or func field\n+// or pointer to chan or func.\n+func isSent(field *reflect.StructField) bool {\n+\tif !isExported(field.Name) {\n+\t\treturn false\n+\t}\n+\t// If the field is a chan or func or pointer thereto, don't send it.\n+\t// That is, treat it like an unexported field.\n+\ttyp := field.Type\n+\tfor typ.Kind() == reflect.Ptr {\n+\t\ttyp = typ.Elem()\n+\t}\n+\tif typ.Kind() == reflect.Chan || typ.Kind() == reflect.Func {\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n // getBaseType returns the Gob type describing the given reflect.Type's base type.\n // typeLock must be held.\n func getBaseType(name string, rt reflect.Type) (gobType, error) {\n@@ -593,11 +639,13 @@ func bootstrapType(name string, e interface{}, expect typeId) typeId {\n // To maintain binary compatibility, if you extend this type, always put\n // the new fields last.\n type wireType struct {\n-\tArrayT      *arrayType\n-\tSliceT      *sliceType\n-\tStructT     *structType\n-\tMapT        *mapType\n-\tGobEncoderT *gobEncoderType\n+\tArrayT           *arrayType\n+\tSliceT           *sliceType\n+\tStructT          *structType\n+\tMapT             *mapType\n+\tGobEncoderT      *gobEncoderType\n+\tBinaryMarshalerT *gobEncoderType\n+\tTextMarshalerT   *gobEncoderType\n }\n \n func (w *wireType) string() string {\n@@ -616,6 +664,10 @@ func (w *wireType) string() string {\n \t\treturn w.MapT.Name\n \tcase w.GobEncoderT != nil:\n \t\treturn w.GobEncoderT.Name\n+\tcase w.BinaryMarshalerT != nil:\n+\t\treturn w.BinaryMarshalerT.Name\n+\tcase w.TextMarshalerT != nil:\n+\t\treturn w.TextMarshalerT.Name\n \t}\n \treturn unknown\n }\n@@ -631,7 +683,7 @@ var typeInfoMap = make(map[reflect.Type]*typeInfo) // protected by typeLock\n // typeLock must be held.\n func getTypeInfo(ut *userTypeInfo) (*typeInfo, error) {\n \trt := ut.base\n-\tif ut.isGobEncoder {\n+\tif ut.externalEnc != 0 {\n \t\t// We want the user type, not the base type.\n \t\trt = ut.user\n \t}\n@@ -646,12 +698,20 @@ func getTypeInfo(ut *userTypeInfo) (*typeInfo, error) {\n \t}\n \tinfo.id = gt.id()\n \n-\tif ut.isGobEncoder {\n+\tif ut.externalEnc != 0 {\n \t\tuserType, err := getType(rt.Name(), ut, rt)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tinfo.wire = &wireType{GobEncoderT: userType.id().gobType().(*gobEncoderType)}\n+\t\tgt := userType.id().gobType().(*gobEncoderType)\n+\t\tswitch ut.externalEnc {\n+\t\tcase xGob:\n+\t\t\tinfo.wire = &wireType{GobEncoderT: gt}\n+\t\tcase xBinary:\n+\t\t\tinfo.wire = &wireType{BinaryMarshalerT: gt}\n+\t\tcase xText:\n+\t\t\tinfo.wire = &wireType{TextMarshalerT: gt}\n+\t\t}\n \t\ttypeInfoMap[ut.user] = info\n \t\treturn info, nil\n \t}"}, {"sha": "458fb39ec0123e02bc589cebadd089d5b6a67341", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -8,6 +8,7 @@\n package json\n \n import (\n+\t\"encoding\"\n \t\"encoding/base64\"\n \t\"errors\"\n \t\"fmt\"\n@@ -37,9 +38,7 @@ import (\n // keys to the keys used by Marshal (either the struct field name or its tag),\n // preferring an exact match but also accepting a case-insensitive match.\n //\n-// To unmarshal JSON into an interface value, Unmarshal unmarshals\n-// the JSON into the concrete value contained in the interface value.\n-// If the interface value is nil, that is, has no concrete value stored in it,\n+// To unmarshal JSON into an interface value,\n // Unmarshal stores one of these in the interface value:\n //\n //\tbool, for JSON booleans\n@@ -293,7 +292,7 @@ func (d *decodeState) value(v reflect.Value) {\n // until it gets to a non-pointer.\n // if it encounters an Unmarshaler, indirect stops and returns that.\n // if decodingNull is true, indirect stops at the last pointer so it can be set to nil.\n-func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler, reflect.Value) {\n+func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value) {\n \t// If v is a named type and is addressable,\n \t// start with its address, so that if the type has pointer methods,\n \t// we find them.\n@@ -322,28 +321,38 @@ func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler,\n \t\t\tv.Set(reflect.New(v.Type().Elem()))\n \t\t}\n \t\tif v.Type().NumMethod() > 0 {\n-\t\t\tif unmarshaler, ok := v.Interface().(Unmarshaler); ok {\n-\t\t\t\treturn unmarshaler, reflect.Value{}\n+\t\t\tif u, ok := v.Interface().(Unmarshaler); ok {\n+\t\t\t\treturn u, nil, reflect.Value{}\n+\t\t\t}\n+\t\t\tif u, ok := v.Interface().(encoding.TextUnmarshaler); ok {\n+\t\t\t\treturn nil, u, reflect.Value{}\n \t\t\t}\n \t\t}\n \t\tv = v.Elem()\n \t}\n-\treturn nil, v\n+\treturn nil, nil, v\n }\n \n // array consumes an array from d.data[d.off-1:], decoding into the value v.\n // the first byte of the array ('[') has been read already.\n func (d *decodeState) array(v reflect.Value) {\n \t// Check for unmarshaler.\n-\tunmarshaler, pv := d.indirect(v, false)\n-\tif unmarshaler != nil {\n+\tu, ut, pv := d.indirect(v, false)\n+\tif u != nil {\n \t\td.off--\n-\t\terr := unmarshaler.UnmarshalJSON(d.next())\n+\t\terr := u.UnmarshalJSON(d.next())\n \t\tif err != nil {\n \t\t\td.error(err)\n \t\t}\n \t\treturn\n \t}\n+\tif ut != nil {\n+\t\td.saveError(&UnmarshalTypeError{\"array\", v.Type()})\n+\t\td.off--\n+\t\td.next()\n+\t\treturn\n+\t}\n+\n \tv = pv\n \n \t// Check type of target.\n@@ -434,15 +443,21 @@ func (d *decodeState) array(v reflect.Value) {\n // the first byte of the object ('{') has been read already.\n func (d *decodeState) object(v reflect.Value) {\n \t// Check for unmarshaler.\n-\tunmarshaler, pv := d.indirect(v, false)\n-\tif unmarshaler != nil {\n+\tu, ut, pv := d.indirect(v, false)\n+\tif u != nil {\n \t\td.off--\n-\t\terr := unmarshaler.UnmarshalJSON(d.next())\n+\t\terr := u.UnmarshalJSON(d.next())\n \t\tif err != nil {\n \t\t\td.error(err)\n \t\t}\n \t\treturn\n \t}\n+\tif ut != nil {\n+\t\td.saveError(&UnmarshalTypeError{\"object\", v.Type()})\n+\t\td.off--\n+\t\td.next() // skip over { } in input\n+\t\treturn\n+\t}\n \tv = pv\n \n \t// Decoding into nil interface?  Switch to non-reflect code.\n@@ -611,14 +626,37 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\treturn\n \t}\n \twantptr := item[0] == 'n' // null\n-\tunmarshaler, pv := d.indirect(v, wantptr)\n-\tif unmarshaler != nil {\n-\t\terr := unmarshaler.UnmarshalJSON(item)\n+\tu, ut, pv := d.indirect(v, wantptr)\n+\tif u != nil {\n+\t\terr := u.UnmarshalJSON(item)\n+\t\tif err != nil {\n+\t\t\td.error(err)\n+\t\t}\n+\t\treturn\n+\t}\n+\tif ut != nil {\n+\t\tif item[0] != '\"' {\n+\t\t\tif fromQuoted {\n+\t\t\t\td.saveError(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type()))\n+\t\t\t} else {\n+\t\t\t\td.saveError(&UnmarshalTypeError{\"string\", v.Type()})\n+\t\t\t}\n+\t\t}\n+\t\ts, ok := unquoteBytes(item)\n+\t\tif !ok {\n+\t\t\tif fromQuoted {\n+\t\t\t\td.error(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type()))\n+\t\t\t} else {\n+\t\t\t\td.error(errPhase)\n+\t\t\t}\n+\t\t}\n+\t\terr := ut.UnmarshalText(s)\n \t\tif err != nil {\n \t\t\td.error(err)\n \t\t}\n \t\treturn\n \t}\n+\n \tv = pv\n \n \tswitch c := item[0]; c {"}, {"sha": "22c5f89f7981a1af5cb2c3f6d4ec44265e2ac1ed", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 146, "deletions": 21, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,6 +6,7 @@ package json\n \n import (\n \t\"bytes\"\n+\t\"encoding\"\n \t\"fmt\"\n \t\"image\"\n \t\"reflect\"\n@@ -50,30 +51,55 @@ type tx struct {\n \tx int\n }\n \n-var txType = reflect.TypeOf((*tx)(nil)).Elem()\n-\n // A type that can unmarshal itself.\n \n type unmarshaler struct {\n \tT bool\n }\n \n func (u *unmarshaler) UnmarshalJSON(b []byte) error {\n-\t*u = unmarshaler{true} // All we need to see that UnmarshalJson is called.\n+\t*u = unmarshaler{true} // All we need to see that UnmarshalJSON is called.\n \treturn nil\n }\n \n type ustruct struct {\n \tM unmarshaler\n }\n \n+type unmarshalerText struct {\n+\tT bool\n+}\n+\n+// needed for re-marshaling tests\n+func (u *unmarshalerText) MarshalText() ([]byte, error) {\n+\treturn []byte(\"\"), nil\n+}\n+\n+func (u *unmarshalerText) UnmarshalText(b []byte) error {\n+\t*u = unmarshalerText{true} // All we need to see that UnmarshalText is called.\n+\treturn nil\n+}\n+\n+var _ encoding.TextUnmarshaler = (*unmarshalerText)(nil)\n+\n+type ustructText struct {\n+\tM unmarshalerText\n+}\n+\n var (\n \tum0, um1 unmarshaler // target2 of unmarshaling\n \tump      = &um1\n \tumtrue   = unmarshaler{true}\n \tumslice  = []unmarshaler{{true}}\n \tumslicep = new([]unmarshaler)\n \tumstruct = ustruct{unmarshaler{true}}\n+\n+\tum0T, um1T unmarshalerText // target2 of unmarshaling\n+\tumpT       = &um1T\n+\tumtrueT    = unmarshalerText{true}\n+\tumsliceT   = []unmarshalerText{{true}}\n+\tumslicepT  = new([]unmarshalerText)\n+\tumstructT  = ustructText{unmarshalerText{true}}\n )\n \n // Test data structures for anonymous fields.\n@@ -184,6 +210,12 @@ type Ambig struct {\n \tSecond int `json:\"Hello\"`\n }\n \n+type XYZ struct {\n+\tX interface{}\n+\tY interface{}\n+\tZ interface{}\n+}\n+\n var unmarshalTests = []unmarshalTest{\n \t// basic types\n \t{in: `true`, ptr: new(bool), out: true},\n@@ -263,6 +295,13 @@ var unmarshalTests = []unmarshalTest{\n \t{in: `[{\"T\":false}]`, ptr: &umslicep, out: &umslice},\n \t{in: `{\"M\":{\"T\":false}}`, ptr: &umstruct, out: umstruct},\n \n+\t// UnmarshalText interface test\n+\t{in: `\"X\"`, ptr: &um0T, out: umtrueT}, // use \"false\" so test will fail if custom unmarshaler is not called\n+\t{in: `\"X\"`, ptr: &umpT, out: &umtrueT},\n+\t{in: `[\"X\"]`, ptr: &umsliceT, out: umsliceT},\n+\t{in: `[\"X\"]`, ptr: &umslicepT, out: &umsliceT},\n+\t{in: `{\"M\":\"X\"}`, ptr: &umstructT, out: umstructT},\n+\n \t{\n \t\tin: `{\n \t\t\t\"Level0\": 1,\n@@ -391,17 +430,23 @@ func TestMarshal(t *testing.T) {\n \t}\n }\n \n+var badUTF8 = []struct {\n+\tin, out string\n+}{\n+\t{\"hello\\xffworld\", `\"hello\\ufffdworld\"`},\n+\t{\"\", `\"\"`},\n+\t{\"\\xff\", `\"\\ufffd\"`},\n+\t{\"\\xff\\xff\", `\"\\ufffd\\ufffd\"`},\n+\t{\"a\\xffb\", `\"a\\ufffdb\"`},\n+\t{\"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xff\\xaa\\x9e\", `\"\u65e5\u672c\\ufffd\\ufffd\\ufffd\"`},\n+}\n+\n func TestMarshalBadUTF8(t *testing.T) {\n-\ts := \"hello\\xffworld\"\n-\tb, err := Marshal(s)\n-\tif err == nil {\n-\t\tt.Fatal(\"Marshal bad UTF8: no error\")\n-\t}\n-\tif len(b) != 0 {\n-\t\tt.Fatal(\"Marshal returned data\")\n-\t}\n-\tif _, ok := err.(*InvalidUTF8Error); !ok {\n-\t\tt.Fatalf(\"Marshal did not return InvalidUTF8Error: %T %v\", err, err)\n+\tfor _, tt := range badUTF8 {\n+\t\tb, err := Marshal(tt.in)\n+\t\tif string(b) != tt.out || err != nil {\n+\t\t\tt.Errorf(\"Marshal(%q) = %#q, %v, want %#q, nil\", tt.in, b, err, tt.out)\n+\t\t}\n \t}\n }\n \n@@ -417,6 +462,45 @@ func TestMarshalNumberZeroVal(t *testing.T) {\n \t}\n }\n \n+func TestMarshalEmbeds(t *testing.T) {\n+\ttop := &Top{\n+\t\tLevel0: 1,\n+\t\tEmbed0: Embed0{\n+\t\t\tLevel1b: 2,\n+\t\t\tLevel1c: 3,\n+\t\t},\n+\t\tEmbed0a: &Embed0a{\n+\t\t\tLevel1a: 5,\n+\t\t\tLevel1b: 6,\n+\t\t},\n+\t\tEmbed0b: &Embed0b{\n+\t\t\tLevel1a: 8,\n+\t\t\tLevel1b: 9,\n+\t\t\tLevel1c: 10,\n+\t\t\tLevel1d: 11,\n+\t\t\tLevel1e: 12,\n+\t\t},\n+\t\tLoop: Loop{\n+\t\t\tLoop1: 13,\n+\t\t\tLoop2: 14,\n+\t\t},\n+\t\tEmbed0p: Embed0p{\n+\t\t\tPoint: image.Point{X: 15, Y: 16},\n+\t\t},\n+\t\tEmbed0q: Embed0q{\n+\t\t\tPoint: Point{Z: 17},\n+\t\t},\n+\t}\n+\tb, err := Marshal(top)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\twant := \"{\\\"Level0\\\":1,\\\"Level1b\\\":2,\\\"Level1c\\\":3,\\\"Level1a\\\":5,\\\"LEVEL1B\\\":6,\\\"e\\\":{\\\"Level1a\\\":8,\\\"Level1b\\\":9,\\\"Level1c\\\":10,\\\"Level1d\\\":11,\\\"x\\\":12},\\\"Loop1\\\":13,\\\"Loop2\\\":14,\\\"X\\\":15,\\\"Y\\\":16,\\\"Z\\\":17}\"\n+\tif string(b) != want {\n+\t\tt.Errorf(\"Wrong marshal result.\\n got: %q\\nwant: %q\", b, want)\n+\t}\n+}\n+\n func TestUnmarshal(t *testing.T) {\n \tfor i, tt := range unmarshalTests {\n \t\tvar scan scanner\n@@ -432,7 +516,7 @@ func TestUnmarshal(t *testing.T) {\n \t\t}\n \t\t// v = new(right-type)\n \t\tv := reflect.New(reflect.TypeOf(tt.ptr).Elem())\n-\t\tdec := NewDecoder(bytes.NewBuffer(in))\n+\t\tdec := NewDecoder(bytes.NewReader(in))\n \t\tif tt.useNumber {\n \t\t\tdec.UseNumber()\n \t\t}\n@@ -457,16 +541,18 @@ func TestUnmarshal(t *testing.T) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tvv := reflect.New(reflect.TypeOf(tt.ptr).Elem())\n-\t\t\tdec = NewDecoder(bytes.NewBuffer(enc))\n+\t\t\tdec = NewDecoder(bytes.NewReader(enc))\n \t\t\tif tt.useNumber {\n \t\t\t\tdec.UseNumber()\n \t\t\t}\n \t\t\tif err := dec.Decode(vv.Interface()); err != nil {\n-\t\t\t\tt.Errorf(\"#%d: error re-unmarshaling: %v\", i, err)\n+\t\t\t\tt.Errorf(\"#%d: error re-unmarshaling %#q: %v\", i, enc, err)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif !reflect.DeepEqual(v.Elem().Interface(), vv.Elem().Interface()) {\n \t\t\t\tt.Errorf(\"#%d: mismatch\\nhave: %#+v\\nwant: %#+v\", i, v.Elem().Interface(), vv.Elem().Interface())\n+\t\t\t\tt.Errorf(\"     In: %q\", strings.Map(noSpace, string(in)))\n+\t\t\t\tt.Errorf(\"Marshal: %q\", strings.Map(noSpace, string(enc)))\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n@@ -568,14 +654,14 @@ func TestUnmarshalPtrPtr(t *testing.T) {\n }\n \n func TestEscape(t *testing.T) {\n-\tconst input = `\"foobar\"<html>`\n-\tconst expected = `\"\\\"foobar\\\"\\u003chtml\\u003e\"`\n+\tconst input = `\"foobar\"<html>` + \" [\\u2028 \\u2029]\"\n+\tconst expected = `\"\\\"foobar\\\"\\u003chtml\\u003e [\\u2028 \\u2029]\"`\n \tb, err := Marshal(input)\n \tif err != nil {\n \t\tt.Fatalf(\"Marshal error: %v\", err)\n \t}\n \tif s := string(b); s != expected {\n-\t\tt.Errorf(\"Encoding of [%s] was [%s], want [%s]\", input, s, expected)\n+\t\tt.Errorf(\"Encoding of [%s]:\\n got [%s]\\nwant [%s]\", input, s, expected)\n \t}\n }\n \n@@ -934,15 +1020,20 @@ func TestRefUnmarshal(t *testing.T) {\n \t\t// Ref is defined in encode_test.go.\n \t\tR0 Ref\n \t\tR1 *Ref\n+\t\tR2 RefText\n+\t\tR3 *RefText\n \t}\n \twant := S{\n \t\tR0: 12,\n \t\tR1: new(Ref),\n+\t\tR2: 13,\n+\t\tR3: new(RefText),\n \t}\n \t*want.R1 = 12\n+\t*want.R3 = 13\n \n \tvar got S\n-\tif err := Unmarshal([]byte(`{\"R0\":\"ref\",\"R1\":\"ref\"}`), &got); err != nil {\n+\tif err := Unmarshal([]byte(`{\"R0\":\"ref\",\"R1\":\"ref\",\"R2\":\"ref\",\"R3\":\"ref\"}`), &got); err != nil {\n \t\tt.Fatalf(\"Unmarshal: %v\", err)\n \t}\n \tif !reflect.DeepEqual(got, want) {\n@@ -1064,7 +1155,6 @@ func TestUnmarshalNulls(t *testing.T) {\n \n func TestStringKind(t *testing.T) {\n \ttype stringKind string\n-\ttype aMap map[stringKind]int\n \n \tvar m1, m2 map[stringKind]int\n \tm1 = map[stringKind]int{\n@@ -1191,3 +1281,38 @@ func TestSkipArrayObjects(t *testing.T) {\n \t\tt.Errorf(\"got error %q, want nil\", err)\n \t}\n }\n+\n+// Test semantics of pre-filled struct fields and pre-filled map fields.\n+// Issue 4900.\n+func TestPrefilled(t *testing.T) {\n+\tptrToMap := func(m map[string]interface{}) *map[string]interface{} { return &m }\n+\n+\t// Values here change, cannot reuse table across runs.\n+\tvar prefillTests = []struct {\n+\t\tin  string\n+\t\tptr interface{}\n+\t\tout interface{}\n+\t}{\n+\t\t{\n+\t\t\tin:  `{\"X\": 1, \"Y\": 2}`,\n+\t\t\tptr: &XYZ{X: float32(3), Y: int16(4), Z: 1.5},\n+\t\t\tout: &XYZ{X: float64(1), Y: float64(2), Z: 1.5},\n+\t\t},\n+\t\t{\n+\t\t\tin:  `{\"X\": 1, \"Y\": 2}`,\n+\t\t\tptr: ptrToMap(map[string]interface{}{\"X\": float32(3), \"Y\": int16(4), \"Z\": 1.5}),\n+\t\t\tout: ptrToMap(map[string]interface{}{\"X\": float64(1), \"Y\": float64(2), \"Z\": 1.5}),\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range prefillTests {\n+\t\tptrstr := fmt.Sprintf(\"%v\", tt.ptr)\n+\t\terr := Unmarshal([]byte(tt.in), tt.ptr) // tt.ptr edited here\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Unmarshal: %v\", err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(tt.ptr, tt.out) {\n+\t\t\tt.Errorf(\"Unmarshal(%#q, %s): have %v, want %v\", tt.in, ptrstr, tt.ptr, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "7d6c71d7a9016a276c3199b4054111005e1d20f4", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 555, "deletions": 159, "changes": 714, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -12,6 +12,7 @@ package json\n \n import (\n \t\"bytes\"\n+\t\"encoding\"\n \t\"encoding/base64\"\n \t\"math\"\n \t\"reflect\"\n@@ -149,14 +150,14 @@ func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {\n \treturn buf.Bytes(), nil\n }\n \n-// HTMLEscape appends to dst the JSON-encoded src with <, >, and &\n-// characters inside string literals changed to \\u003c, \\u003e, \\u0026\n+// HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\n+// characters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\n // so that the JSON will be safe to embed inside HTML <script> tags.\n // For historical reasons, web browsers don't honor standard HTML\n // escaping within <script> tags, so an alternative JSON encoding must\n // be used.\n func HTMLEscape(dst *bytes.Buffer, src []byte) {\n-\t// < > & can only appear in string literals,\n+\t// The characters can only appear in string literals,\n \t// so just scan the string one byte at a time.\n \tstart := 0\n \tfor i, c := range src {\n@@ -169,6 +170,15 @@ func HTMLEscape(dst *bytes.Buffer, src []byte) {\n \t\t\tdst.WriteByte(hex[c&0xF])\n \t\t\tstart = i + 1\n \t\t}\n+\t\t// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).\n+\t\tif c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {\n+\t\t\tif start < i {\n+\t\t\t\tdst.Write(src[start:i])\n+\t\t\t}\n+\t\t\tdst.WriteString(`\\u202`)\n+\t\t\tdst.WriteByte(hex[src[i+2]&0xF])\n+\t\t\tstart = i + 3\n+\t\t}\n \t}\n \tif start < len(src) {\n \t\tdst.Write(src[start:])\n@@ -200,8 +210,12 @@ func (e *UnsupportedValueError) Error() string {\n \treturn \"json: unsupported value: \" + e.Str\n }\n \n-// An InvalidUTF8Error is returned by Marshal when attempting\n-// to encode a string value with invalid UTF-8 sequences.\n+// Before Go 1.2, an InvalidUTF8Error was returned by Marshal when\n+// attempting to encode a string value with invalid UTF-8 sequences.\n+// As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by\n+// replacing invalid bytes with the Unicode replacement rune U+FFFD.\n+// This error is no longer generated but is kept for backwards compatibility\n+// with programs that might mention it.\n type InvalidUTF8Error struct {\n \tS string // the whole string value that caused the error\n }\n@@ -227,12 +241,35 @@ type encodeState struct {\n \tscratch      [64]byte\n }\n \n+// TODO(bradfitz): use a sync.Cache here\n+var encodeStatePool = make(chan *encodeState, 8)\n+\n+func newEncodeState() *encodeState {\n+\tselect {\n+\tcase e := <-encodeStatePool:\n+\t\te.Reset()\n+\t\treturn e\n+\tdefault:\n+\t\treturn new(encodeState)\n+\t}\n+}\n+\n+func putEncodeState(e *encodeState) {\n+\tselect {\n+\tcase encodeStatePool <- e:\n+\tdefault:\n+\t}\n+}\n+\n func (e *encodeState) marshal(v interface{}) (err error) {\n \tdefer func() {\n \t\tif r := recover(); r != nil {\n \t\t\tif _, ok := r.(runtime.Error); ok {\n \t\t\t\tpanic(r)\n \t\t\t}\n+\t\t\tif s, ok := r.(string); ok {\n+\t\t\t\tpanic(s)\n+\t\t\t}\n \t\t\terr = r.(error)\n \t\t}\n \t}()\n@@ -265,186 +302,438 @@ func isEmptyValue(v reflect.Value) bool {\n }\n \n func (e *encodeState) reflectValue(v reflect.Value) {\n-\te.reflectValueQuoted(v, false)\n+\tvalueEncoder(v)(e, v, false)\n+}\n+\n+type encoderFunc func(e *encodeState, v reflect.Value, quoted bool)\n+\n+var encoderCache struct {\n+\tsync.RWMutex\n+\tm map[reflect.Type]encoderFunc\n }\n \n-// reflectValueQuoted writes the value in v to the output.\n-// If quoted is true, the serialization is wrapped in a JSON string.\n-func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n+func valueEncoder(v reflect.Value) encoderFunc {\n \tif !v.IsValid() {\n-\t\te.WriteString(\"null\")\n-\t\treturn\n+\t\treturn invalidValueEncoder\n \t}\n+\treturn typeEncoder(v.Type())\n+}\n \n-\tm, ok := v.Interface().(Marshaler)\n-\tif !ok {\n-\t\t// T doesn't match the interface. Check against *T too.\n-\t\tif v.Kind() != reflect.Ptr && v.CanAddr() {\n-\t\t\tm, ok = v.Addr().Interface().(Marshaler)\n-\t\t\tif ok {\n-\t\t\t\tv = v.Addr()\n-\t\t\t}\n-\t\t}\n+func typeEncoder(t reflect.Type) encoderFunc {\n+\tencoderCache.RLock()\n+\tf := encoderCache.m[t]\n+\tencoderCache.RUnlock()\n+\tif f != nil {\n+\t\treturn f\n+\t}\n+\n+\t// To deal with recursive types, populate the map with an\n+\t// indirect func before we build it. This type waits on the\n+\t// real func (f) to be ready and then calls it.  This indirect\n+\t// func is only used for recursive types.\n+\tencoderCache.Lock()\n+\tif encoderCache.m == nil {\n+\t\tencoderCache.m = make(map[reflect.Type]encoderFunc)\n+\t}\n+\tvar wg sync.WaitGroup\n+\twg.Add(1)\n+\tencoderCache.m[t] = func(e *encodeState, v reflect.Value, quoted bool) {\n+\t\twg.Wait()\n+\t\tf(e, v, quoted)\n+\t}\n+\tencoderCache.Unlock()\n+\n+\t// Compute fields without lock.\n+\t// Might duplicate effort but won't hold other computations back.\n+\tf = newTypeEncoder(t, true)\n+\twg.Done()\n+\tencoderCache.Lock()\n+\tencoderCache.m[t] = f\n+\tencoderCache.Unlock()\n+\treturn f\n+}\n+\n+var (\n+\tmarshalerType     = reflect.TypeOf(new(Marshaler)).Elem()\n+\ttextMarshalerType = reflect.TypeOf(new(encoding.TextMarshaler)).Elem()\n+)\n+\n+// newTypeEncoder constructs an encoderFunc for a type.\n+// The returned encoder only checks CanAddr when allowAddr is true.\n+func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {\n+\tif t.Implements(marshalerType) {\n+\t\treturn marshalerEncoder\n \t}\n-\tif ok && (v.Kind() != reflect.Ptr || !v.IsNil()) {\n-\t\tb, err := m.MarshalJSON()\n-\t\tif err == nil {\n-\t\t\t// copy JSON into buffer, checking validity.\n-\t\t\terr = compact(&e.Buffer, b, true)\n+\tif t.Kind() != reflect.Ptr && allowAddr {\n+\t\tif reflect.PtrTo(t).Implements(marshalerType) {\n+\t\t\treturn newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))\n \t\t}\n-\t\tif err != nil {\n-\t\t\te.error(&MarshalerError{v.Type(), err})\n+\t}\n+\n+\tif t.Implements(textMarshalerType) {\n+\t\treturn textMarshalerEncoder\n+\t}\n+\tif t.Kind() != reflect.Ptr && allowAddr {\n+\t\tif reflect.PtrTo(t).Implements(textMarshalerType) {\n+\t\t\treturn newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))\n \t\t}\n+\t}\n+\n+\tswitch t.Kind() {\n+\tcase reflect.Bool:\n+\t\treturn boolEncoder\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn intEncoder\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n+\t\treturn uintEncoder\n+\tcase reflect.Float32:\n+\t\treturn float32Encoder\n+\tcase reflect.Float64:\n+\t\treturn float64Encoder\n+\tcase reflect.String:\n+\t\treturn stringEncoder\n+\tcase reflect.Interface:\n+\t\treturn interfaceEncoder\n+\tcase reflect.Struct:\n+\t\treturn newStructEncoder(t)\n+\tcase reflect.Map:\n+\t\treturn newMapEncoder(t)\n+\tcase reflect.Slice:\n+\t\treturn newSliceEncoder(t)\n+\tcase reflect.Array:\n+\t\treturn newArrayEncoder(t)\n+\tcase reflect.Ptr:\n+\t\treturn newPtrEncoder(t)\n+\tdefault:\n+\t\treturn unsupportedTypeEncoder\n+\t}\n+}\n+\n+func invalidValueEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\te.WriteString(\"null\")\n+}\n+\n+func marshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tif v.Kind() == reflect.Ptr && v.IsNil() {\n+\t\te.WriteString(\"null\")\n+\t\treturn\n+\t}\n+\tm := v.Interface().(Marshaler)\n+\tb, err := m.MarshalJSON()\n+\tif err == nil {\n+\t\t// copy JSON into buffer, checking validity.\n+\t\terr = compact(&e.Buffer, b, true)\n+\t}\n+\tif err != nil {\n+\t\te.error(&MarshalerError{v.Type(), err})\n+\t}\n+}\n+\n+func addrMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tva := v.Addr()\n+\tif va.IsNil() {\n+\t\te.WriteString(\"null\")\n \t\treturn\n \t}\n+\tm := va.Interface().(Marshaler)\n+\tb, err := m.MarshalJSON()\n+\tif err == nil {\n+\t\t// copy JSON into buffer, checking validity.\n+\t\terr = compact(&e.Buffer, b, true)\n+\t}\n+\tif err != nil {\n+\t\te.error(&MarshalerError{v.Type(), err})\n+\t}\n+}\n \n-\twriteString := (*encodeState).WriteString\n+func textMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tif v.Kind() == reflect.Ptr && v.IsNil() {\n+\t\te.WriteString(\"null\")\n+\t\treturn\n+\t}\n+\tm := v.Interface().(encoding.TextMarshaler)\n+\tb, err := m.MarshalText()\n+\tif err == nil {\n+\t\t_, err = e.stringBytes(b)\n+\t}\n+\tif err != nil {\n+\t\te.error(&MarshalerError{v.Type(), err})\n+\t}\n+}\n+\n+func addrTextMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tva := v.Addr()\n+\tif va.IsNil() {\n+\t\te.WriteString(\"null\")\n+\t\treturn\n+\t}\n+\tm := va.Interface().(encoding.TextMarshaler)\n+\tb, err := m.MarshalText()\n+\tif err == nil {\n+\t\t_, err = e.stringBytes(b)\n+\t}\n+\tif err != nil {\n+\t\te.error(&MarshalerError{v.Type(), err})\n+\t}\n+}\n+\n+func boolEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tif quoted {\n+\t\te.WriteByte('\"')\n+\t}\n+\tif v.Bool() {\n+\t\te.WriteString(\"true\")\n+\t} else {\n+\t\te.WriteString(\"false\")\n+\t}\n+\tif quoted {\n+\t\te.WriteByte('\"')\n+\t}\n+}\n+\n+func intEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tb := strconv.AppendInt(e.scratch[:0], v.Int(), 10)\n+\tif quoted {\n+\t\te.WriteByte('\"')\n+\t}\n+\te.Write(b)\n \tif quoted {\n-\t\twriteString = (*encodeState).string\n+\t\te.WriteByte('\"')\n \t}\n+}\n \n-\tswitch v.Kind() {\n-\tcase reflect.Bool:\n-\t\tx := v.Bool()\n-\t\tif x {\n-\t\t\twriteString(e, \"true\")\n-\t\t} else {\n-\t\t\twriteString(e, \"false\")\n-\t\t}\n+func uintEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tb := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)\n+\tif quoted {\n+\t\te.WriteByte('\"')\n+\t}\n+\te.Write(b)\n+\tif quoted {\n+\t\te.WriteByte('\"')\n+\t}\n+}\n \n-\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\tb := strconv.AppendInt(e.scratch[:0], v.Int(), 10)\n-\t\tif quoted {\n-\t\t\twriteString(e, string(b))\n-\t\t} else {\n-\t\t\te.Write(b)\n+type floatEncoder int // number of bits\n+\n+func (bits floatEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {\n+\tf := v.Float()\n+\tif math.IsInf(f, 0) || math.IsNaN(f) {\n+\t\te.error(&UnsupportedValueError{v, strconv.FormatFloat(f, 'g', -1, int(bits))})\n+\t}\n+\tb := strconv.AppendFloat(e.scratch[:0], f, 'g', -1, int(bits))\n+\tif quoted {\n+\t\te.WriteByte('\"')\n+\t}\n+\te.Write(b)\n+\tif quoted {\n+\t\te.WriteByte('\"')\n+\t}\n+}\n+\n+var (\n+\tfloat32Encoder = (floatEncoder(32)).encode\n+\tfloat64Encoder = (floatEncoder(64)).encode\n+)\n+\n+func stringEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tif v.Type() == numberType {\n+\t\tnumStr := v.String()\n+\t\tif numStr == \"\" {\n+\t\t\tnumStr = \"0\" // Number's zero-val\n \t\t}\n-\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\tb := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)\n-\t\tif quoted {\n-\t\t\twriteString(e, string(b))\n-\t\t} else {\n-\t\t\te.Write(b)\n+\t\te.WriteString(numStr)\n+\t\treturn\n+\t}\n+\tif quoted {\n+\t\tsb, err := Marshal(v.String())\n+\t\tif err != nil {\n+\t\t\te.error(err)\n \t\t}\n-\tcase reflect.Float32, reflect.Float64:\n-\t\tf := v.Float()\n-\t\tif math.IsInf(f, 0) || math.IsNaN(f) {\n-\t\t\te.error(&UnsupportedValueError{v, strconv.FormatFloat(f, 'g', -1, v.Type().Bits())})\n+\t\te.string(string(sb))\n+\t} else {\n+\t\te.string(v.String())\n+\t}\n+}\n+\n+func interfaceEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\tif v.IsNil() {\n+\t\te.WriteString(\"null\")\n+\t\treturn\n+\t}\n+\te.reflectValue(v.Elem())\n+}\n+\n+func unsupportedTypeEncoder(e *encodeState, v reflect.Value, quoted bool) {\n+\te.error(&UnsupportedTypeError{v.Type()})\n+}\n+\n+type structEncoder struct {\n+\tfields    []field\n+\tfieldEncs []encoderFunc\n+}\n+\n+func (se *structEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {\n+\te.WriteByte('{')\n+\tfirst := true\n+\tfor i, f := range se.fields {\n+\t\tfv := fieldByIndex(v, f.index)\n+\t\tif !fv.IsValid() || f.omitEmpty && isEmptyValue(fv) {\n+\t\t\tcontinue\n \t\t}\n-\t\tb := strconv.AppendFloat(e.scratch[:0], f, 'g', -1, v.Type().Bits())\n-\t\tif quoted {\n-\t\t\twriteString(e, string(b))\n+\t\tif first {\n+\t\t\tfirst = false\n \t\t} else {\n-\t\t\te.Write(b)\n-\t\t}\n-\tcase reflect.String:\n-\t\tif v.Type() == numberType {\n-\t\t\tnumStr := v.String()\n-\t\t\tif numStr == \"\" {\n-\t\t\t\tnumStr = \"0\" // Number's zero-val\n-\t\t\t}\n-\t\t\te.WriteString(numStr)\n-\t\t\tbreak\n-\t\t}\n-\t\tif quoted {\n-\t\t\tsb, err := Marshal(v.String())\n-\t\t\tif err != nil {\n-\t\t\t\te.error(err)\n-\t\t\t}\n-\t\t\te.string(string(sb))\n-\t\t} else {\n-\t\t\te.string(v.String())\n+\t\t\te.WriteByte(',')\n \t\t}\n+\t\te.string(f.name)\n+\t\te.WriteByte(':')\n+\t\tse.fieldEncs[i](e, fv, f.quoted)\n+\t}\n+\te.WriteByte('}')\n+}\n \n-\tcase reflect.Struct:\n-\t\te.WriteByte('{')\n-\t\tfirst := true\n-\t\tfor _, f := range cachedTypeFields(v.Type()) {\n-\t\t\tfv := fieldByIndex(v, f.index)\n-\t\t\tif !fv.IsValid() || f.omitEmpty && isEmptyValue(fv) {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif first {\n-\t\t\t\tfirst = false\n-\t\t\t} else {\n-\t\t\t\te.WriteByte(',')\n-\t\t\t}\n-\t\t\te.string(f.name)\n-\t\t\te.WriteByte(':')\n-\t\t\te.reflectValueQuoted(fv, f.quoted)\n-\t\t}\n-\t\te.WriteByte('}')\n+func newStructEncoder(t reflect.Type) encoderFunc {\n+\tfields := cachedTypeFields(t)\n+\tse := &structEncoder{\n+\t\tfields:    fields,\n+\t\tfieldEncs: make([]encoderFunc, len(fields)),\n+\t}\n+\tfor i, f := range fields {\n+\t\tse.fieldEncs[i] = typeEncoder(typeByIndex(t, f.index))\n+\t}\n+\treturn se.encode\n+}\n \n-\tcase reflect.Map:\n-\t\tif v.Type().Key().Kind() != reflect.String {\n-\t\t\te.error(&UnsupportedTypeError{v.Type()})\n-\t\t}\n-\t\tif v.IsNil() {\n-\t\t\te.WriteString(\"null\")\n-\t\t\tbreak\n-\t\t}\n-\t\te.WriteByte('{')\n-\t\tvar sv stringValues = v.MapKeys()\n-\t\tsort.Sort(sv)\n-\t\tfor i, k := range sv {\n-\t\t\tif i > 0 {\n-\t\t\t\te.WriteByte(',')\n-\t\t\t}\n-\t\t\te.string(k.String())\n-\t\t\te.WriteByte(':')\n-\t\t\te.reflectValue(v.MapIndex(k))\n-\t\t}\n-\t\te.WriteByte('}')\n+type mapEncoder struct {\n+\telemEnc encoderFunc\n+}\n \n-\tcase reflect.Slice:\n-\t\tif v.IsNil() {\n-\t\t\te.WriteString(\"null\")\n-\t\t\tbreak\n-\t\t}\n-\t\tif v.Type().Elem().Kind() == reflect.Uint8 {\n-\t\t\t// Byte slices get special treatment; arrays don't.\n-\t\t\ts := v.Bytes()\n-\t\t\te.WriteByte('\"')\n-\t\t\tif len(s) < 1024 {\n-\t\t\t\t// for small buffers, using Encode directly is much faster.\n-\t\t\t\tdst := make([]byte, base64.StdEncoding.EncodedLen(len(s)))\n-\t\t\t\tbase64.StdEncoding.Encode(dst, s)\n-\t\t\t\te.Write(dst)\n-\t\t\t} else {\n-\t\t\t\t// for large buffers, avoid unnecessary extra temporary\n-\t\t\t\t// buffer space.\n-\t\t\t\tenc := base64.NewEncoder(base64.StdEncoding, e)\n-\t\t\t\tenc.Write(s)\n-\t\t\t\tenc.Close()\n-\t\t\t}\n-\t\t\te.WriteByte('\"')\n-\t\t\tbreak\n-\t\t}\n-\t\t// Slices can be marshalled as nil, but otherwise are handled\n-\t\t// as arrays.\n-\t\tfallthrough\n-\tcase reflect.Array:\n-\t\te.WriteByte('[')\n-\t\tn := v.Len()\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\tif i > 0 {\n-\t\t\t\te.WriteByte(',')\n-\t\t\t}\n-\t\t\te.reflectValue(v.Index(i))\n+func (me *mapEncoder) encode(e *encodeState, v reflect.Value, _ bool) {\n+\tif v.IsNil() {\n+\t\te.WriteString(\"null\")\n+\t\treturn\n+\t}\n+\te.WriteByte('{')\n+\tvar sv stringValues = v.MapKeys()\n+\tsort.Sort(sv)\n+\tfor i, k := range sv {\n+\t\tif i > 0 {\n+\t\t\te.WriteByte(',')\n \t\t}\n-\t\te.WriteByte(']')\n+\t\te.string(k.String())\n+\t\te.WriteByte(':')\n+\t\tme.elemEnc(e, v.MapIndex(k), false)\n+\t}\n+\te.WriteByte('}')\n+}\n \n-\tcase reflect.Interface, reflect.Ptr:\n-\t\tif v.IsNil() {\n-\t\t\te.WriteString(\"null\")\n-\t\t\treturn\n+func newMapEncoder(t reflect.Type) encoderFunc {\n+\tif t.Key().Kind() != reflect.String {\n+\t\treturn unsupportedTypeEncoder\n+\t}\n+\tme := &mapEncoder{typeEncoder(t.Elem())}\n+\treturn me.encode\n+}\n+\n+func encodeByteSlice(e *encodeState, v reflect.Value, _ bool) {\n+\tif v.IsNil() {\n+\t\te.WriteString(\"null\")\n+\t\treturn\n+\t}\n+\ts := v.Bytes()\n+\te.WriteByte('\"')\n+\tif len(s) < 1024 {\n+\t\t// for small buffers, using Encode directly is much faster.\n+\t\tdst := make([]byte, base64.StdEncoding.EncodedLen(len(s)))\n+\t\tbase64.StdEncoding.Encode(dst, s)\n+\t\te.Write(dst)\n+\t} else {\n+\t\t// for large buffers, avoid unnecessary extra temporary\n+\t\t// buffer space.\n+\t\tenc := base64.NewEncoder(base64.StdEncoding, e)\n+\t\tenc.Write(s)\n+\t\tenc.Close()\n+\t}\n+\te.WriteByte('\"')\n+}\n+\n+// sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil.\n+type sliceEncoder struct {\n+\tarrayEnc encoderFunc\n+}\n+\n+func (se *sliceEncoder) encode(e *encodeState, v reflect.Value, _ bool) {\n+\tif v.IsNil() {\n+\t\te.WriteString(\"null\")\n+\t\treturn\n+\t}\n+\tse.arrayEnc(e, v, false)\n+}\n+\n+func newSliceEncoder(t reflect.Type) encoderFunc {\n+\t// Byte slices get special treatment; arrays don't.\n+\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\treturn encodeByteSlice\n+\t}\n+\tenc := &sliceEncoder{newArrayEncoder(t)}\n+\treturn enc.encode\n+}\n+\n+type arrayEncoder struct {\n+\telemEnc encoderFunc\n+}\n+\n+func (ae *arrayEncoder) encode(e *encodeState, v reflect.Value, _ bool) {\n+\te.WriteByte('[')\n+\tn := v.Len()\n+\tfor i := 0; i < n; i++ {\n+\t\tif i > 0 {\n+\t\t\te.WriteByte(',')\n \t\t}\n-\t\te.reflectValue(v.Elem())\n+\t\tae.elemEnc(e, v.Index(i), false)\n+\t}\n+\te.WriteByte(']')\n+}\n \n-\tdefault:\n-\t\te.error(&UnsupportedTypeError{v.Type()})\n+func newArrayEncoder(t reflect.Type) encoderFunc {\n+\tenc := &arrayEncoder{typeEncoder(t.Elem())}\n+\treturn enc.encode\n+}\n+\n+type ptrEncoder struct {\n+\telemEnc encoderFunc\n+}\n+\n+func (pe *ptrEncoder) encode(e *encodeState, v reflect.Value, _ bool) {\n+\tif v.IsNil() {\n+\t\te.WriteString(\"null\")\n+\t\treturn\n+\t}\n+\tpe.elemEnc(e, v.Elem(), false)\n+}\n+\n+func newPtrEncoder(t reflect.Type) encoderFunc {\n+\tenc := &ptrEncoder{typeEncoder(t.Elem())}\n+\treturn enc.encode\n+}\n+\n+type condAddrEncoder struct {\n+\tcanAddrEnc, elseEnc encoderFunc\n+}\n+\n+func (ce *condAddrEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {\n+\tif v.CanAddr() {\n+\t\tce.canAddrEnc(e, v, quoted)\n+\t} else {\n+\t\tce.elseEnc(e, v, quoted)\n \t}\n-\treturn\n+}\n+\n+// newCondAddrEncoder returns an encoder that checks whether its value\n+// CanAddr and delegates to canAddrEnc if so, else to elseEnc.\n+func newCondAddrEncoder(canAddrEnc, elseEnc encoderFunc) encoderFunc {\n+\tenc := &condAddrEncoder{canAddrEnc: canAddrEnc, elseEnc: elseEnc}\n+\treturn enc.encode\n }\n \n func isValidTag(s string) bool {\n@@ -479,6 +768,16 @@ func fieldByIndex(v reflect.Value, index []int) reflect.Value {\n \treturn v\n }\n \n+func typeByIndex(t reflect.Type, index []int) reflect.Type {\n+\tfor _, i := range index {\n+\t\tif t.Kind() == reflect.Ptr {\n+\t\t\tt = t.Elem()\n+\t\t}\n+\t\tt = t.Field(i).Type\n+\t}\n+\treturn t\n+}\n+\n // stringValues is a slice of reflect.Value holding *reflect.StringValue.\n // It implements the methods to sort by string.\n type stringValues []reflect.Value\n@@ -488,13 +787,14 @@ func (sv stringValues) Swap(i, j int)      { sv[i], sv[j] = sv[j], sv[i] }\n func (sv stringValues) Less(i, j int) bool { return sv.get(i) < sv.get(j) }\n func (sv stringValues) get(i int) string   { return sv[i].String() }\n \n+// NOTE: keep in sync with stringBytes below.\n func (e *encodeState) string(s string) (int, error) {\n \tlen0 := e.Len()\n \te.WriteByte('\"')\n \tstart := 0\n \tfor i := 0; i < len(s); {\n \t\tif b := s[i]; b < utf8.RuneSelf {\n-\t\t\tif 0x20 <= b && b != '\\\\' && b != '\"' && b != '<' && b != '>' {\n+\t\t\tif 0x20 <= b && b != '\\\\' && b != '\"' && b != '<' && b != '>' && b != '&' {\n \t\t\t\ti++\n \t\t\t\tcontinue\n \t\t\t}\n@@ -526,7 +826,30 @@ func (e *encodeState) string(s string) (int, error) {\n \t\t}\n \t\tc, size := utf8.DecodeRuneInString(s[i:])\n \t\tif c == utf8.RuneError && size == 1 {\n-\t\t\te.error(&InvalidUTF8Error{s})\n+\t\t\tif start < i {\n+\t\t\t\te.WriteString(s[start:i])\n+\t\t\t}\n+\t\t\te.WriteString(`\\ufffd`)\n+\t\t\ti += size\n+\t\t\tstart = i\n+\t\t\tcontinue\n+\t\t}\n+\t\t// U+2028 is LINE SEPARATOR.\n+\t\t// U+2029 is PARAGRAPH SEPARATOR.\n+\t\t// They are both technically valid characters in JSON strings,\n+\t\t// but don't work in JSONP, which has to be evaluated as JavaScript,\n+\t\t// and can lead to security holes there. It is valid JSON to\n+\t\t// escape them, so we do so unconditionally.\n+\t\t// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.\n+\t\tif c == '\\u2028' || c == '\\u2029' {\n+\t\t\tif start < i {\n+\t\t\t\te.WriteString(s[start:i])\n+\t\t\t}\n+\t\t\te.WriteString(`\\u202`)\n+\t\t\te.WriteByte(hex[c&0xF])\n+\t\t\ti += size\n+\t\t\tstart = i\n+\t\t\tcontinue\n \t\t}\n \t\ti += size\n \t}\n@@ -537,6 +860,79 @@ func (e *encodeState) string(s string) (int, error) {\n \treturn e.Len() - len0, nil\n }\n \n+// NOTE: keep in sync with string above.\n+func (e *encodeState) stringBytes(s []byte) (int, error) {\n+\tlen0 := e.Len()\n+\te.WriteByte('\"')\n+\tstart := 0\n+\tfor i := 0; i < len(s); {\n+\t\tif b := s[i]; b < utf8.RuneSelf {\n+\t\t\tif 0x20 <= b && b != '\\\\' && b != '\"' && b != '<' && b != '>' && b != '&' {\n+\t\t\t\ti++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif start < i {\n+\t\t\t\te.Write(s[start:i])\n+\t\t\t}\n+\t\t\tswitch b {\n+\t\t\tcase '\\\\', '\"':\n+\t\t\t\te.WriteByte('\\\\')\n+\t\t\t\te.WriteByte(b)\n+\t\t\tcase '\\n':\n+\t\t\t\te.WriteByte('\\\\')\n+\t\t\t\te.WriteByte('n')\n+\t\t\tcase '\\r':\n+\t\t\t\te.WriteByte('\\\\')\n+\t\t\t\te.WriteByte('r')\n+\t\t\tdefault:\n+\t\t\t\t// This encodes bytes < 0x20 except for \\n and \\r,\n+\t\t\t\t// as well as < and >. The latter are escaped because they\n+\t\t\t\t// can lead to security holes when user-controlled strings\n+\t\t\t\t// are rendered into JSON and served to some browsers.\n+\t\t\t\te.WriteString(`\\u00`)\n+\t\t\t\te.WriteByte(hex[b>>4])\n+\t\t\t\te.WriteByte(hex[b&0xF])\n+\t\t\t}\n+\t\t\ti++\n+\t\t\tstart = i\n+\t\t\tcontinue\n+\t\t}\n+\t\tc, size := utf8.DecodeRune(s[i:])\n+\t\tif c == utf8.RuneError && size == 1 {\n+\t\t\tif start < i {\n+\t\t\t\te.Write(s[start:i])\n+\t\t\t}\n+\t\t\te.WriteString(`\\ufffd`)\n+\t\t\ti += size\n+\t\t\tstart = i\n+\t\t\tcontinue\n+\t\t}\n+\t\t// U+2028 is LINE SEPARATOR.\n+\t\t// U+2029 is PARAGRAPH SEPARATOR.\n+\t\t// They are both technically valid characters in JSON strings,\n+\t\t// but don't work in JSONP, which has to be evaluated as JavaScript,\n+\t\t// and can lead to security holes there. It is valid JSON to\n+\t\t// escape them, so we do so unconditionally.\n+\t\t// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.\n+\t\tif c == '\\u2028' || c == '\\u2029' {\n+\t\t\tif start < i {\n+\t\t\t\te.Write(s[start:i])\n+\t\t\t}\n+\t\t\te.WriteString(`\\u202`)\n+\t\t\te.WriteByte(hex[c&0xF])\n+\t\t\ti += size\n+\t\t\tstart = i\n+\t\t\tcontinue\n+\t\t}\n+\t\ti += size\n+\t}\n+\tif start < len(s) {\n+\t\te.Write(s[start:])\n+\t}\n+\te.WriteByte('\"')\n+\treturn e.Len() - len0, nil\n+}\n+\n // A field represents a single field found in a struct.\n type field struct {\n \tname      string"}, {"sha": "9395db7cb6fd543bae8e340ed59c4f77e726bebb", "filename": "libgo/go/encoding/json/encode_test.go", "status": "modified", "additions": 119, "deletions": 4, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"math\"\n \t\"reflect\"\n \t\"testing\"\n+\t\"unicode\"\n )\n \n type Optionals struct {\n@@ -146,19 +147,46 @@ func (Val) MarshalJSON() ([]byte, error) {\n \treturn []byte(`\"val\"`), nil\n }\n \n+// RefText has Marshaler and Unmarshaler methods with pointer receiver.\n+type RefText int\n+\n+func (*RefText) MarshalText() ([]byte, error) {\n+\treturn []byte(`\"ref\"`), nil\n+}\n+\n+func (r *RefText) UnmarshalText([]byte) error {\n+\t*r = 13\n+\treturn nil\n+}\n+\n+// ValText has Marshaler methods with value receiver.\n+type ValText int\n+\n+func (ValText) MarshalText() ([]byte, error) {\n+\treturn []byte(`\"val\"`), nil\n+}\n+\n func TestRefValMarshal(t *testing.T) {\n \tvar s = struct {\n \t\tR0 Ref\n \t\tR1 *Ref\n+\t\tR2 RefText\n+\t\tR3 *RefText\n \t\tV0 Val\n \t\tV1 *Val\n+\t\tV2 ValText\n+\t\tV3 *ValText\n \t}{\n \t\tR0: 12,\n \t\tR1: new(Ref),\n+\t\tR2: 14,\n+\t\tR3: new(RefText),\n \t\tV0: 13,\n \t\tV1: new(Val),\n+\t\tV2: 15,\n+\t\tV3: new(ValText),\n \t}\n-\tconst want = `{\"R0\":\"ref\",\"R1\":\"ref\",\"V0\":\"val\",\"V1\":\"val\"}`\n+\tconst want = `{\"R0\":\"ref\",\"R1\":\"ref\",\"R2\":\"\\\"ref\\\"\",\"R3\":\"\\\"ref\\\"\",\"V0\":\"val\",\"V1\":\"val\",\"V2\":\"\\\"val\\\"\",\"V3\":\"\\\"val\\\"\"}`\n \tb, err := Marshal(&s)\n \tif err != nil {\n \t\tt.Fatalf(\"Marshal: %v\", err)\n@@ -175,15 +203,32 @@ func (C) MarshalJSON() ([]byte, error) {\n \treturn []byte(`\"<&>\"`), nil\n }\n \n+// CText implements Marshaler and returns unescaped text.\n+type CText int\n+\n+func (CText) MarshalText() ([]byte, error) {\n+\treturn []byte(`\"<&>\"`), nil\n+}\n+\n func TestMarshalerEscaping(t *testing.T) {\n \tvar c C\n-\tconst want = `\"\\u003c\\u0026\\u003e\"`\n+\twant := `\"\\u003c\\u0026\\u003e\"`\n \tb, err := Marshal(c)\n \tif err != nil {\n-\t\tt.Fatalf(\"Marshal: %v\", err)\n+\t\tt.Fatalf(\"Marshal(c): %v\", err)\n \t}\n \tif got := string(b); got != want {\n-\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t\tt.Errorf(\"Marshal(c) = %#q, want %#q\", got, want)\n+\t}\n+\n+\tvar ct CText\n+\twant = `\"\\\"\\u003c\\u0026\\u003e\\\"\"`\n+\tb, err = Marshal(ct)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal(ct): %v\", err)\n+\t}\n+\tif got := string(b); got != want {\n+\t\tt.Errorf(\"Marshal(ct) = %#q, want %#q\", got, want)\n \t}\n }\n \n@@ -310,3 +355,73 @@ func TestDuplicatedFieldDisappears(t *testing.T) {\n \t\tt.Fatalf(\"Marshal: got %s want %s\", got, want)\n \t}\n }\n+\n+func TestStringBytes(t *testing.T) {\n+\t// Test that encodeState.stringBytes and encodeState.string use the same encoding.\n+\tes := &encodeState{}\n+\tvar r []rune\n+\tfor i := '\\u0000'; i <= unicode.MaxRune; i++ {\n+\t\tr = append(r, i)\n+\t}\n+\ts := string(r) + \"\\xff\\xff\\xffhello\" // some invalid UTF-8 too\n+\t_, err := es.string(s)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tesBytes := &encodeState{}\n+\t_, err = esBytes.stringBytes([]byte(s))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tenc := es.Buffer.String()\n+\tencBytes := esBytes.Buffer.String()\n+\tif enc != encBytes {\n+\t\ti := 0\n+\t\tfor i < len(enc) && i < len(encBytes) && enc[i] == encBytes[i] {\n+\t\t\ti++\n+\t\t}\n+\t\tenc = enc[i:]\n+\t\tencBytes = encBytes[i:]\n+\t\ti = 0\n+\t\tfor i < len(enc) && i < len(encBytes) && enc[len(enc)-i-1] == encBytes[len(encBytes)-i-1] {\n+\t\t\ti++\n+\t\t}\n+\t\tenc = enc[:len(enc)-i]\n+\t\tencBytes = encBytes[:len(encBytes)-i]\n+\n+\t\tif len(enc) > 20 {\n+\t\t\tenc = enc[:20] + \"...\"\n+\t\t}\n+\t\tif len(encBytes) > 20 {\n+\t\t\tencBytes = encBytes[:20] + \"...\"\n+\t\t}\n+\n+\t\tt.Errorf(\"encodings differ at %#q vs %#q\", enc, encBytes)\n+\t}\n+}\n+\n+func TestIssue6458(t *testing.T) {\n+\ttype Foo struct {\n+\t\tM RawMessage\n+\t}\n+\tx := Foo{RawMessage(`\"foo\"`)}\n+\n+\tb, err := Marshal(&x)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif want := `{\"M\":\"foo\"}`; string(b) != want {\n+\t\tt.Errorf(\"Marshal(&x) = %#q; want %#q\", b, want)\n+\t}\n+\n+\tb, err = Marshal(x)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif want := `{\"M\":\"ImZvbyI=\"}`; string(b) != want {\n+\t\tt.Errorf(\"Marshal(x) = %#q; want %#q\", b, want)\n+\t}\n+}"}, {"sha": "11ef709cce7ce9478c1cfef733c4f59c3978ac6a", "filename": "libgo/go/encoding/json/indent.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -27,6 +27,15 @@ func compact(dst *bytes.Buffer, src []byte, escape bool) error {\n \t\t\tdst.WriteByte(hex[c&0xF])\n \t\t\tstart = i + 1\n \t\t}\n+\t\t// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).\n+\t\tif c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {\n+\t\t\tif start < i {\n+\t\t\t\tdst.Write(src[start:i])\n+\t\t\t}\n+\t\t\tdst.WriteString(`\\u202`)\n+\t\t\tdst.WriteByte(hex[src[i+2]&0xF])\n+\t\t\tstart = i + 3\n+\t\t}\n \t\tv := scan.step(&scan, int(c))\n \t\tif v >= scanSkipSpace {\n \t\t\tif v == scanError {"}, {"sha": "a4609c89505f0dbb25d782f08cb3f6df47ac0ee7", "filename": "libgo/go/encoding/json/scanner.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -390,7 +390,7 @@ func stateInStringEscU123(s *scanner, c int) int {\n \treturn s.error(c, \"in \\\\u hexadecimal character escape\")\n }\n \n-// stateInStringEscU123 is the state after reading `-` during a number.\n+// stateNeg is the state after reading `-` during a number.\n func stateNeg(s *scanner, c int) int {\n \tif c == '0' {\n \t\ts.step = state0"}, {"sha": "90e45ff0369081d2f97618cb228c21bcefdd797e", "filename": "libgo/go/encoding/json/scanner_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -63,6 +63,25 @@ func TestCompact(t *testing.T) {\n \t}\n }\n \n+func TestCompactSeparators(t *testing.T) {\n+\t// U+2028 and U+2029 should be escaped inside strings.\n+\t// They should not appear outside strings.\n+\ttests := []struct {\n+\t\tin, compact string\n+\t}{\n+\t\t{\"{\\\"\\u2028\\\": 1}\", `{\"\\u2028\":1}`},\n+\t\t{\"{\\\"\\u2029\\\" :2}\", `{\"\\u2029\":2}`},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tvar buf bytes.Buffer\n+\t\tif err := Compact(&buf, []byte(tt.in)); err != nil {\n+\t\t\tt.Errorf(\"Compact(%q): %v\", tt.in, err)\n+\t\t} else if s := buf.String(); s != tt.compact {\n+\t\t\tt.Errorf(\"Compact(%q) = %q, want %q\", tt.in, s, tt.compact)\n+\t\t}\n+\t}\n+}\n+\n func TestIndent(t *testing.T) {\n \tvar buf bytes.Buffer\n \tfor _, tt := range examples {"}, {"sha": "1928abadb7d4ae40613ef8b8b46000d734d932c2", "filename": "libgo/go/encoding/json/stream.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -148,16 +148,16 @@ func NewEncoder(w io.Writer) *Encoder {\n \treturn &Encoder{w: w}\n }\n \n-// Encode writes the JSON encoding of v to the connection.\n+// Encode writes the JSON encoding of v to the stream.\n //\n // See the documentation for Marshal for details about the\n // conversion of Go values to JSON.\n func (enc *Encoder) Encode(v interface{}) error {\n \tif enc.err != nil {\n \t\treturn enc.err\n \t}\n-\tenc.e.Reset()\n-\terr := enc.e.marshal(v)\n+\te := newEncodeState()\n+\terr := e.marshal(v)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -168,11 +168,12 @@ func (enc *Encoder) Encode(v interface{}) error {\n \t// is required if the encoded value was a number,\n \t// so that the reader knows there aren't more\n \t// digits coming.\n-\tenc.e.WriteByte('\\n')\n+\te.WriteByte('\\n')\n \n-\tif _, err = enc.w.Write(enc.e.Bytes()); err != nil {\n+\tif _, err = enc.w.Write(e.Bytes()); err != nil {\n \t\tenc.err = err\n \t}\n+\tputEncodeState(e)\n \treturn err\n }\n "}, {"sha": "b562e87690d5ee9b140b8a9de9e68308bae9407a", "filename": "libgo/go/encoding/json/stream_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -191,3 +191,16 @@ func TestBlocking(t *testing.T) {\n \t\tw.Close()\n \t}\n }\n+\n+func BenchmarkEncoderEncode(b *testing.B) {\n+\tb.ReportAllocs()\n+\ttype T struct {\n+\t\tX, Y string\n+\t}\n+\tv := &T{\"foo\", \"bar\"}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif err := NewEncoder(ioutil.Discard).Encode(v); err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t}\n+}"}, {"sha": "c38fd5102f6302deb1e10639dbe4552ee255837e", "filename": "libgo/go/encoding/json/tags.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Ftags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fjson%2Ftags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Ftags.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -21,7 +21,7 @@ func parseTag(tag string) (string, tagOptions) {\n \treturn tag, tagOptions(\"\")\n }\n \n-// Contains returns whether checks that a comma-separated list of options\n+// Contains reports whether a comma-separated list of options\n // contains a particular substr flag. substr must be surrounded by a\n // string boundary or commas.\n func (o tagOptions) Contains(optionName string) bool {"}, {"sha": "d9522e0b39f718c0a24dfadfdd9a5ade616cd2f6", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 473, "deletions": 102, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -7,12 +7,12 @@ package xml\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"encoding\"\n \t\"fmt\"\n \t\"io\"\n \t\"reflect\"\n \t\"strconv\"\n \t\"strings\"\n-\t\"time\"\n )\n \n const (\n@@ -75,6 +75,41 @@ func Marshal(v interface{}) ([]byte, error) {\n \treturn b.Bytes(), nil\n }\n \n+// Marshaler is the interface implemented by objects that can marshal\n+// themselves into valid XML elements.\n+//\n+// MarshalXML encodes the receiver as zero or more XML elements.\n+// By convention, arrays or slices are typically encoded as a sequence\n+// of elements, one per entry.\n+// Using start as the element tag is not required, but doing so\n+// will enable Unmarshal to match the XML elements to the correct\n+// struct field.\n+// One common implementation strategy is to construct a separate\n+// value with a layout corresponding to the desired XML and then\n+// to encode it using e.EncodeElement.\n+// Another common strategy is to use repeated calls to e.EncodeToken\n+// to generate the XML output one token at a time.\n+// The sequence of encoded tokens must make up zero or more valid\n+// XML elements.\n+type Marshaler interface {\n+\tMarshalXML(e *Encoder, start StartElement) error\n+}\n+\n+// MarshalerAttr is the interface implemented by objects that can marshal\n+// themselves into valid XML attributes.\n+//\n+// MarshalXMLAttr returns an XML attribute with the encoded value of the receiver.\n+// Using name as the attribute name is not required, but doing so\n+// will enable Unmarshal to match the attribute to the correct\n+// struct field.\n+// If MarshalXMLAttr returns the zero attribute Attr{}, no attribute\n+// will be generated in the output.\n+// MarshalXMLAttr is used only for struct fields with the\n+// \"attr\" option in the field tag.\n+type MarshalerAttr interface {\n+\tMarshalXMLAttr(name Name) (Attr, error)\n+}\n+\n // MarshalIndent works like Marshal, but each XML element begins on a new\n // indented line that starts with prefix and is followed by one or more\n // copies of indent according to the nesting depth.\n@@ -90,36 +125,124 @@ func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {\n \n // An Encoder writes XML data to an output stream.\n type Encoder struct {\n-\tprinter\n+\tp printer\n }\n \n // NewEncoder returns a new encoder that writes to w.\n func NewEncoder(w io.Writer) *Encoder {\n-\treturn &Encoder{printer{Writer: bufio.NewWriter(w)}}\n+\te := &Encoder{printer{Writer: bufio.NewWriter(w)}}\n+\te.p.encoder = e\n+\treturn e\n }\n \n // Indent sets the encoder to generate XML in which each element\n // begins on a new indented line that starts with prefix and is followed by\n // one or more copies of indent according to the nesting depth.\n func (enc *Encoder) Indent(prefix, indent string) {\n-\tenc.prefix = prefix\n-\tenc.indent = indent\n+\tenc.p.prefix = prefix\n+\tenc.p.indent = indent\n }\n \n // Encode writes the XML encoding of v to the stream.\n //\n // See the documentation for Marshal for details about the conversion\n // of Go values to XML.\n+//\n+// Encode calls Flush before returning.\n func (enc *Encoder) Encode(v interface{}) error {\n-\terr := enc.marshalValue(reflect.ValueOf(v), nil)\n+\terr := enc.p.marshalValue(reflect.ValueOf(v), nil, nil)\n \tif err != nil {\n \t\treturn err\n \t}\n-\treturn enc.Flush()\n+\treturn enc.p.Flush()\n+}\n+\n+// EncodeElement writes the XML encoding of v to the stream,\n+// using start as the outermost tag in the encoding.\n+//\n+// See the documentation for Marshal for details about the conversion\n+// of Go values to XML.\n+//\n+// EncodeElement calls Flush before returning.\n+func (enc *Encoder) EncodeElement(v interface{}, start StartElement) error {\n+\terr := enc.p.marshalValue(reflect.ValueOf(v), nil, &start)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn enc.p.Flush()\n+}\n+\n+var (\n+\tendComment   = []byte(\"-->\")\n+\tendProcInst  = []byte(\"?>\")\n+\tendDirective = []byte(\">\")\n+)\n+\n+// EncodeToken writes the given XML token to the stream.\n+// It returns an error if StartElement and EndElement tokens are not properly matched.\n+//\n+// EncodeToken does not call Flush, because usually it is part of a larger operation\n+// such as Encode or EncodeElement (or a custom Marshaler's MarshalXML invoked\n+// during those), and those will call Flush when finished.\n+//\n+// Callers that create an Encoder and then invoke EncodeToken directly, without\n+// using Encode or EncodeElement, need to call Flush when finished to ensure\n+// that the XML is written to the underlying writer.\n+func (enc *Encoder) EncodeToken(t Token) error {\n+\tp := &enc.p\n+\tswitch t := t.(type) {\n+\tcase StartElement:\n+\t\tif err := p.writeStart(&t); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\tcase EndElement:\n+\t\tif err := p.writeEnd(t.Name); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\tcase CharData:\n+\t\tEscapeText(p, t)\n+\tcase Comment:\n+\t\tif bytes.Contains(t, endComment) {\n+\t\t\treturn fmt.Errorf(\"xml: EncodeToken of Comment containing --> marker\")\n+\t\t}\n+\t\tp.WriteString(\"<!--\")\n+\t\tp.Write(t)\n+\t\tp.WriteString(\"-->\")\n+\t\treturn p.cachedWriteError()\n+\tcase ProcInst:\n+\t\tif t.Target == \"xml\" || !isNameString(t.Target) {\n+\t\t\treturn fmt.Errorf(\"xml: EncodeToken of ProcInst with invalid Target\")\n+\t\t}\n+\t\tif bytes.Contains(t.Inst, endProcInst) {\n+\t\t\treturn fmt.Errorf(\"xml: EncodeToken of ProcInst containing ?> marker\")\n+\t\t}\n+\t\tp.WriteString(\"<?\")\n+\t\tp.WriteString(t.Target)\n+\t\tif len(t.Inst) > 0 {\n+\t\t\tp.WriteByte(' ')\n+\t\t\tp.Write(t.Inst)\n+\t\t}\n+\t\tp.WriteString(\"?>\")\n+\tcase Directive:\n+\t\tif bytes.Contains(t, endDirective) {\n+\t\t\treturn fmt.Errorf(\"xml: EncodeToken of Directive containing > marker\")\n+\t\t}\n+\t\tp.WriteString(\"<!\")\n+\t\tp.Write(t)\n+\t\tp.WriteString(\">\")\n+\t}\n+\treturn p.cachedWriteError()\n+}\n+\n+// Flush flushes any buffered XML to the underlying writer.\n+// See the EncodeToken documentation for details about when it is necessary.\n+func (enc *Encoder) Flush() error {\n+\treturn enc.p.Flush()\n }\n \n type printer struct {\n \t*bufio.Writer\n+\tencoder    *Encoder\n \tseq        int\n \tindent     string\n \tprefix     string\n@@ -128,21 +251,23 @@ type printer struct {\n \tputNewline bool\n \tattrNS     map[string]string // map prefix -> name space\n \tattrPrefix map[string]string // map name space -> prefix\n+\tprefixes   []string\n+\ttags       []Name\n }\n \n // createAttrPrefix finds the name space prefix attribute to use for the given name space,\n-// defining a new prefix if necessary. It returns the prefix and whether it is new.\n-func (p *printer) createAttrPrefix(url string) (prefix string, isNew bool) {\n-\tif prefix = p.attrPrefix[url]; prefix != \"\" {\n-\t\treturn prefix, false\n+// defining a new prefix if necessary. It returns the prefix.\n+func (p *printer) createAttrPrefix(url string) string {\n+\tif prefix := p.attrPrefix[url]; prefix != \"\" {\n+\t\treturn prefix\n \t}\n \n \t// The \"http://www.w3.org/XML/1998/namespace\" name space is predefined as \"xml\"\n \t// and must be referred to that way.\n \t// (The \"http://www.w3.org/2000/xmlns/\" name space is also predefined as \"xmlns\",\n \t// but users should not be trying to use that one directly - that's our job.)\n \tif url == xmlURL {\n-\t\treturn \"xml\", false\n+\t\treturn \"xml\"\n \t}\n \n \t// Need to define a new name space.\n@@ -153,7 +278,7 @@ func (p *printer) createAttrPrefix(url string) (prefix string, isNew bool) {\n \n \t// Pick a name. We try to use the final element of the path\n \t// but fall back to _.\n-\tprefix = strings.TrimRight(url, \"/\")\n+\tprefix := strings.TrimRight(url, \"/\")\n \tif i := strings.LastIndex(prefix, \"/\"); i >= 0 {\n \t\tprefix = prefix[i+1:]\n \t}\n@@ -183,7 +308,9 @@ func (p *printer) createAttrPrefix(url string) (prefix string, isNew bool) {\n \tEscapeText(p, []byte(url))\n \tp.WriteString(`\" `)\n \n-\treturn prefix, true\n+\tp.prefixes = append(p.prefixes, prefix)\n+\n+\treturn prefix\n }\n \n // deleteAttrPrefix removes an attribute name space prefix.\n@@ -192,31 +319,80 @@ func (p *printer) deleteAttrPrefix(prefix string) {\n \tdelete(p.attrNS, prefix)\n }\n \n+func (p *printer) markPrefix() {\n+\tp.prefixes = append(p.prefixes, \"\")\n+}\n+\n+func (p *printer) popPrefix() {\n+\tfor len(p.prefixes) > 0 {\n+\t\tprefix := p.prefixes[len(p.prefixes)-1]\n+\t\tp.prefixes = p.prefixes[:len(p.prefixes)-1]\n+\t\tif prefix == \"\" {\n+\t\t\tbreak\n+\t\t}\n+\t\tp.deleteAttrPrefix(prefix)\n+\t}\n+}\n+\n+var (\n+\tmarshalerType     = reflect.TypeOf((*Marshaler)(nil)).Elem()\n+\tmarshalerAttrType = reflect.TypeOf((*MarshalerAttr)(nil)).Elem()\n+\ttextMarshalerType = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()\n+)\n+\n // marshalValue writes one or more XML elements representing val.\n // If val was obtained from a struct field, finfo must have its details.\n-func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n+func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo, startTemplate *StartElement) error {\n+\tif startTemplate != nil && startTemplate.Name.Local == \"\" {\n+\t\treturn fmt.Errorf(\"xml: EncodeElement of StartElement with missing name\")\n+\t}\n+\n \tif !val.IsValid() {\n \t\treturn nil\n \t}\n \tif finfo != nil && finfo.flags&fOmitEmpty != 0 && isEmptyValue(val) {\n \t\treturn nil\n \t}\n \n+\t// Drill into interfaces and pointers.\n+\t// This can turn into an infinite loop given a cyclic chain,\n+\t// but it matches the Go 1 behavior.\n+\tfor val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr {\n+\t\tif val.IsNil() {\n+\t\t\treturn nil\n+\t\t}\n+\t\tval = val.Elem()\n+\t}\n+\n \tkind := val.Kind()\n \ttyp := val.Type()\n \n-\t// Drill into pointers/interfaces\n-\tif kind == reflect.Ptr || kind == reflect.Interface {\n-\t\tif val.IsNil() {\n-\t\t\treturn nil\n+\t// Check for marshaler.\n+\tif val.CanInterface() && typ.Implements(marshalerType) {\n+\t\treturn p.marshalInterface(val.Interface().(Marshaler), defaultStart(typ, finfo, startTemplate))\n+\t}\n+\tif val.CanAddr() {\n+\t\tpv := val.Addr()\n+\t\tif pv.CanInterface() && pv.Type().Implements(marshalerType) {\n+\t\t\treturn p.marshalInterface(pv.Interface().(Marshaler), defaultStart(pv.Type(), finfo, startTemplate))\n+\t\t}\n+\t}\n+\n+\t// Check for text marshaler.\n+\tif val.CanInterface() && typ.Implements(textMarshalerType) {\n+\t\treturn p.marshalTextInterface(val.Interface().(encoding.TextMarshaler), defaultStart(typ, finfo, startTemplate))\n+\t}\n+\tif val.CanAddr() {\n+\t\tpv := val.Addr()\n+\t\tif pv.CanInterface() && pv.Type().Implements(textMarshalerType) {\n+\t\t\treturn p.marshalTextInterface(pv.Interface().(encoding.TextMarshaler), defaultStart(pv.Type(), finfo, startTemplate))\n \t\t}\n-\t\treturn p.marshalValue(val.Elem(), finfo)\n \t}\n \n \t// Slices and arrays iterate over the elements. They do not have an enclosing tag.\n \tif (kind == reflect.Slice || kind == reflect.Array) && typ.Elem().Kind() != reflect.Uint8 {\n \t\tfor i, n := 0, val.Len(); i < n; i++ {\n-\t\t\tif err := p.marshalValue(val.Index(i), finfo); err != nil {\n+\t\t\tif err := p.marshalValue(val.Index(i), finfo, startTemplate); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n@@ -228,40 +404,34 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\treturn err\n \t}\n \n+\t// Create start element.\n \t// Precedence for the XML element name is:\n+\t// 0. startTemplate\n \t// 1. XMLName field in underlying struct;\n \t// 2. field name/tag in the struct field; and\n \t// 3. type name\n-\tvar xmlns, name string\n-\tif tinfo.xmlname != nil {\n+\tvar start StartElement\n+\n+\tif startTemplate != nil {\n+\t\tstart.Name = startTemplate.Name\n+\t\tstart.Attr = append(start.Attr, startTemplate.Attr...)\n+\t} else if tinfo.xmlname != nil {\n \t\txmlname := tinfo.xmlname\n \t\tif xmlname.name != \"\" {\n-\t\t\txmlns, name = xmlname.xmlns, xmlname.name\n+\t\t\tstart.Name.Space, start.Name.Local = xmlname.xmlns, xmlname.name\n \t\t} else if v, ok := xmlname.value(val).Interface().(Name); ok && v.Local != \"\" {\n-\t\t\txmlns, name = v.Space, v.Local\n+\t\t\tstart.Name = v\n \t\t}\n \t}\n-\tif name == \"\" && finfo != nil {\n-\t\txmlns, name = finfo.xmlns, finfo.name\n+\tif start.Name.Local == \"\" && finfo != nil {\n+\t\tstart.Name.Space, start.Name.Local = finfo.xmlns, finfo.name\n \t}\n-\tif name == \"\" {\n-\t\tname = typ.Name()\n+\tif start.Name.Local == \"\" {\n+\t\tname := typ.Name()\n \t\tif name == \"\" {\n \t\t\treturn &UnsupportedTypeError{typ}\n \t\t}\n-\t}\n-\n-\tp.writeIndent(1)\n-\tp.WriteByte('<')\n-\tp.WriteString(name)\n-\n-\tif xmlns != \"\" {\n-\t\tp.WriteString(` xmlns=\"`)\n-\t\t// TODO: EscapeString, to avoid the allocation.\n-\t\tif err := EscapeText(p, []byte(xmlns)); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tp.WriteByte('\"')\n+\t\tstart.Name.Local = name\n \t}\n \n \t// Attributes\n@@ -271,100 +441,301 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\t\tcontinue\n \t\t}\n \t\tfv := finfo.value(val)\n+\t\tname := Name{Space: finfo.xmlns, Local: finfo.name}\n+\n \t\tif finfo.flags&fOmitEmpty != 0 && isEmptyValue(fv) {\n \t\t\tcontinue\n \t\t}\n-\t\tp.WriteByte(' ')\n-\t\tif finfo.xmlns != \"\" {\n-\t\t\tprefix, created := p.createAttrPrefix(finfo.xmlns)\n-\t\t\tif created {\n-\t\t\t\tdefer p.deleteAttrPrefix(prefix)\n+\n+\t\tif fv.Kind() == reflect.Interface && fv.IsNil() {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif fv.CanInterface() && fv.Type().Implements(marshalerAttrType) {\n+\t\t\tattr, err := fv.Interface().(MarshalerAttr).MarshalXMLAttr(name)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n \t\t\t}\n-\t\t\tp.WriteString(prefix)\n-\t\t\tp.WriteByte(':')\n+\t\t\tif attr.Name.Local != \"\" {\n+\t\t\t\tstart.Attr = append(start.Attr, attr)\n+\t\t\t}\n+\t\t\tcontinue\n \t\t}\n-\t\tp.WriteString(finfo.name)\n-\t\tp.WriteString(`=\"`)\n-\t\tif err := p.marshalSimple(fv.Type(), fv); err != nil {\n+\n+\t\tif fv.CanAddr() {\n+\t\t\tpv := fv.Addr()\n+\t\t\tif pv.CanInterface() && pv.Type().Implements(marshalerAttrType) {\n+\t\t\t\tattr, err := pv.Interface().(MarshalerAttr).MarshalXMLAttr(name)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tif attr.Name.Local != \"\" {\n+\t\t\t\t\tstart.Attr = append(start.Attr, attr)\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\tif fv.CanInterface() && fv.Type().Implements(textMarshalerType) {\n+\t\t\ttext, err := fv.Interface().(encoding.TextMarshaler).MarshalText()\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tstart.Attr = append(start.Attr, Attr{name, string(text)})\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif fv.CanAddr() {\n+\t\t\tpv := fv.Addr()\n+\t\t\tif pv.CanInterface() && pv.Type().Implements(textMarshalerType) {\n+\t\t\t\ttext, err := pv.Interface().(encoding.TextMarshaler).MarshalText()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tstart.Attr = append(start.Attr, Attr{name, string(text)})\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Dereference or skip nil pointer, interface values.\n+\t\tswitch fv.Kind() {\n+\t\tcase reflect.Ptr, reflect.Interface:\n+\t\t\tif fv.IsNil() {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfv = fv.Elem()\n+\t\t}\n+\n+\t\ts, b, err := p.marshalSimple(fv.Type(), fv)\n+\t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tp.WriteByte('\"')\n+\t\tif b != nil {\n+\t\t\ts = string(b)\n+\t\t}\n+\t\tstart.Attr = append(start.Attr, Attr{name, s})\n+\t}\n+\n+\tif err := p.writeStart(&start); err != nil {\n+\t\treturn err\n \t}\n-\tp.WriteByte('>')\n \n \tif val.Kind() == reflect.Struct {\n \t\terr = p.marshalStruct(tinfo, val)\n \t} else {\n-\t\terr = p.marshalSimple(typ, val)\n+\t\ts, b, err1 := p.marshalSimple(typ, val)\n+\t\tif err1 != nil {\n+\t\t\terr = err1\n+\t\t} else if b != nil {\n+\t\t\tEscapeText(p, b)\n+\t\t} else {\n+\t\t\tp.EscapeString(s)\n+\t\t}\n \t}\n \tif err != nil {\n \t\treturn err\n \t}\n \n-\tp.writeIndent(-1)\n-\tp.WriteByte('<')\n-\tp.WriteByte('/')\n-\tp.WriteString(name)\n-\tp.WriteByte('>')\n+\tif err := p.writeEnd(start.Name); err != nil {\n+\t\treturn err\n+\t}\n \n \treturn p.cachedWriteError()\n }\n \n-var timeType = reflect.TypeOf(time.Time{})\n+// defaultStart returns the default start element to use,\n+// given the reflect type, field info, and start template.\n+func defaultStart(typ reflect.Type, finfo *fieldInfo, startTemplate *StartElement) StartElement {\n+\tvar start StartElement\n+\t// Precedence for the XML element name is as above,\n+\t// except that we do not look inside structs for the first field.\n+\tif startTemplate != nil {\n+\t\tstart.Name = startTemplate.Name\n+\t\tstart.Attr = append(start.Attr, startTemplate.Attr...)\n+\t} else if finfo != nil && finfo.name != \"\" {\n+\t\tstart.Name.Local = finfo.name\n+\t\tstart.Name.Space = finfo.xmlns\n+\t} else if typ.Name() != \"\" {\n+\t\tstart.Name.Local = typ.Name()\n+\t} else {\n+\t\t// Must be a pointer to a named type,\n+\t\t// since it has the Marshaler methods.\n+\t\tstart.Name.Local = typ.Elem().Name()\n+\t}\n+\treturn start\n+}\n \n-func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) error {\n-\t// Normally we don't see structs, but this can happen for an attribute.\n-\tif val.Type() == timeType {\n-\t\tp.WriteString(val.Interface().(time.Time).Format(time.RFC3339Nano))\n-\t\treturn nil\n+// marshalInterface marshals a Marshaler interface value.\n+func (p *printer) marshalInterface(val Marshaler, start StartElement) error {\n+\t// Push a marker onto the tag stack so that MarshalXML\n+\t// cannot close the XML tags that it did not open.\n+\tp.tags = append(p.tags, Name{})\n+\tn := len(p.tags)\n+\n+\terr := val.MarshalXML(p.encoder, start)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Make sure MarshalXML closed all its tags. p.tags[n-1] is the mark.\n+\tif len(p.tags) > n {\n+\t\treturn fmt.Errorf(\"xml: %s.MarshalXML wrote invalid XML: <%s> not closed\", receiverType(val), p.tags[len(p.tags)-1].Local)\n+\t}\n+\tp.tags = p.tags[:n-1]\n+\treturn nil\n+}\n+\n+// marshalTextInterface marshals a TextMarshaler interface value.\n+func (p *printer) marshalTextInterface(val encoding.TextMarshaler, start StartElement) error {\n+\tif err := p.writeStart(&start); err != nil {\n+\t\treturn err\n+\t}\n+\ttext, err := val.MarshalText()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tEscapeText(p, text)\n+\treturn p.writeEnd(start.Name)\n+}\n+\n+// writeStart writes the given start element.\n+func (p *printer) writeStart(start *StartElement) error {\n+\tif start.Name.Local == \"\" {\n+\t\treturn fmt.Errorf(\"xml: start tag with no name\")\n+\t}\n+\n+\tp.tags = append(p.tags, start.Name)\n+\tp.markPrefix()\n+\n+\tp.writeIndent(1)\n+\tp.WriteByte('<')\n+\tp.WriteString(start.Name.Local)\n+\n+\tif start.Name.Space != \"\" {\n+\t\tp.WriteString(` xmlns=\"`)\n+\t\tp.EscapeString(start.Name.Space)\n+\t\tp.WriteByte('\"')\n+\t}\n+\n+\t// Attributes\n+\tfor _, attr := range start.Attr {\n+\t\tname := attr.Name\n+\t\tif name.Local == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tp.WriteByte(' ')\n+\t\tif name.Space != \"\" {\n+\t\t\tp.WriteString(p.createAttrPrefix(name.Space))\n+\t\t\tp.WriteByte(':')\n+\t\t}\n+\t\tp.WriteString(name.Local)\n+\t\tp.WriteString(`=\"`)\n+\t\tp.EscapeString(attr.Value)\n+\t\tp.WriteByte('\"')\n \t}\n+\tp.WriteByte('>')\n+\treturn nil\n+}\n+\n+func (p *printer) writeEnd(name Name) error {\n+\tif name.Local == \"\" {\n+\t\treturn fmt.Errorf(\"xml: end tag with no name\")\n+\t}\n+\tif len(p.tags) == 0 || p.tags[len(p.tags)-1].Local == \"\" {\n+\t\treturn fmt.Errorf(\"xml: end tag </%s> without start tag\", name.Local)\n+\t}\n+\tif top := p.tags[len(p.tags)-1]; top != name {\n+\t\tif top.Local != name.Local {\n+\t\t\treturn fmt.Errorf(\"xml: end tag </%s> does not match start tag <%s>\", name.Local, top.Local)\n+\t\t}\n+\t\treturn fmt.Errorf(\"xml: end tag </%s> in namespace %s does not match start tag <%s> in namespace %s\", name.Local, name.Space, top.Local, top.Space)\n+\t}\n+\tp.tags = p.tags[:len(p.tags)-1]\n+\n+\tp.writeIndent(-1)\n+\tp.WriteByte('<')\n+\tp.WriteByte('/')\n+\tp.WriteString(name.Local)\n+\tp.WriteByte('>')\n+\tp.popPrefix()\n+\treturn nil\n+}\n+\n+func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) (string, []byte, error) {\n \tswitch val.Kind() {\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\tp.WriteString(strconv.FormatInt(val.Int(), 10))\n+\t\treturn strconv.FormatInt(val.Int(), 10), nil, nil\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\tp.WriteString(strconv.FormatUint(val.Uint(), 10))\n+\t\treturn strconv.FormatUint(val.Uint(), 10), nil, nil\n \tcase reflect.Float32, reflect.Float64:\n-\t\tp.WriteString(strconv.FormatFloat(val.Float(), 'g', -1, val.Type().Bits()))\n+\t\treturn strconv.FormatFloat(val.Float(), 'g', -1, val.Type().Bits()), nil, nil\n \tcase reflect.String:\n-\t\t// TODO: Add EscapeString.\n-\t\tEscapeText(p, []byte(val.String()))\n+\t\treturn val.String(), nil, nil\n \tcase reflect.Bool:\n-\t\tp.WriteString(strconv.FormatBool(val.Bool()))\n+\t\treturn strconv.FormatBool(val.Bool()), nil, nil\n \tcase reflect.Array:\n-\t\t// will be [...]byte\n+\t\tif typ.Elem().Kind() != reflect.Uint8 {\n+\t\t\tbreak\n+\t\t}\n+\t\t// [...]byte\n \t\tvar bytes []byte\n \t\tif val.CanAddr() {\n \t\t\tbytes = val.Slice(0, val.Len()).Bytes()\n \t\t} else {\n \t\t\tbytes = make([]byte, val.Len())\n \t\t\treflect.Copy(reflect.ValueOf(bytes), val)\n \t\t}\n-\t\tEscapeText(p, bytes)\n+\t\treturn \"\", bytes, nil\n \tcase reflect.Slice:\n-\t\t// will be []byte\n-\t\tEscapeText(p, val.Bytes())\n-\tdefault:\n-\t\treturn &UnsupportedTypeError{typ}\n+\t\tif typ.Elem().Kind() != reflect.Uint8 {\n+\t\t\tbreak\n+\t\t}\n+\t\t// []byte\n+\t\treturn \"\", val.Bytes(), nil\n \t}\n-\treturn p.cachedWriteError()\n+\treturn \"\", nil, &UnsupportedTypeError{typ}\n }\n \n var ddBytes = []byte(\"--\")\n \n func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n-\tif val.Type() == timeType {\n-\t\t_, err := p.WriteString(val.Interface().(time.Time).Format(time.RFC3339Nano))\n-\t\treturn err\n-\t}\n-\ts := parentStack{printer: p}\n+\ts := parentStack{p: p}\n \tfor i := range tinfo.fields {\n \t\tfinfo := &tinfo.fields[i]\n \t\tif finfo.flags&fAttr != 0 {\n \t\t\tcontinue\n \t\t}\n \t\tvf := finfo.value(val)\n+\n+\t\t// Dereference or skip nil pointer, interface values.\n+\t\tswitch vf.Kind() {\n+\t\tcase reflect.Ptr, reflect.Interface:\n+\t\t\tif !vf.IsNil() {\n+\t\t\t\tvf = vf.Elem()\n+\t\t\t}\n+\t\t}\n+\n \t\tswitch finfo.flags & fMode {\n \t\tcase fCharData:\n+\t\t\tif vf.CanInterface() && vf.Type().Implements(textMarshalerType) {\n+\t\t\t\tdata, err := vf.Interface().(encoding.TextMarshaler).MarshalText()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tEscape(p, data)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif vf.CanAddr() {\n+\t\t\t\tpv := vf.Addr()\n+\t\t\t\tif pv.CanInterface() && pv.Type().Implements(textMarshalerType) {\n+\t\t\t\t\tdata, err := pv.Interface().(encoding.TextMarshaler).MarshalText()\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn err\n+\t\t\t\t\t}\n+\t\t\t\t\tEscape(p, data)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tvar scratch [64]byte\n \t\t\tswitch vf.Kind() {\n \t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n@@ -385,10 +756,6 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\tcase reflect.Struct:\n-\t\t\t\tif vf.Type() == timeType {\n-\t\t\t\t\tEscape(p, []byte(vf.Interface().(time.Time).Format(time.RFC3339Nano)))\n-\t\t\t\t}\n \t\t\t}\n \t\t\tcontinue\n \n@@ -444,14 +811,18 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \t\t\t}\n \n \t\tcase fElement, fElement | fAny:\n-\t\t\ts.trim(finfo.parents)\n+\t\t\tif err := s.trim(finfo.parents); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t\tif len(finfo.parents) > len(s.stack) {\n \t\t\t\tif vf.Kind() != reflect.Ptr && vf.Kind() != reflect.Interface || !vf.IsNil() {\n-\t\t\t\t\ts.push(finfo.parents[len(s.stack):])\n+\t\t\t\t\tif err := s.push(finfo.parents[len(s.stack):]); err != nil {\n+\t\t\t\t\t\treturn err\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif err := p.marshalValue(vf, finfo); err != nil {\n+\t\tif err := p.marshalValue(vf, finfo, nil); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -497,38 +868,38 @@ func (p *printer) writeIndent(depthDelta int) {\n }\n \n type parentStack struct {\n-\t*printer\n+\tp     *printer\n \tstack []string\n }\n \n // trim updates the XML context to match the longest common prefix of the stack\n // and the given parents.  A closing tag will be written for every parent\n // popped.  Passing a zero slice or nil will close all the elements.\n-func (s *parentStack) trim(parents []string) {\n+func (s *parentStack) trim(parents []string) error {\n \tsplit := 0\n \tfor ; split < len(parents) && split < len(s.stack); split++ {\n \t\tif parents[split] != s.stack[split] {\n \t\t\tbreak\n \t\t}\n \t}\n \tfor i := len(s.stack) - 1; i >= split; i-- {\n-\t\ts.writeIndent(-1)\n-\t\ts.WriteString(\"</\")\n-\t\ts.WriteString(s.stack[i])\n-\t\ts.WriteByte('>')\n+\t\tif err := s.p.writeEnd(Name{Local: s.stack[i]}); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \ts.stack = parents[:split]\n+\treturn nil\n }\n \n // push adds parent elements to the stack and writes open tags.\n-func (s *parentStack) push(parents []string) {\n+func (s *parentStack) push(parents []string) error {\n \tfor i := 0; i < len(parents); i++ {\n-\t\ts.writeIndent(1)\n-\t\ts.WriteByte('<')\n-\t\ts.WriteString(parents[i])\n-\t\ts.WriteByte('>')\n+\t\tif err := s.p.writeStart(&StartElement{Name: Name{Local: parents[i]}}); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \ts.stack = append(s.stack, parents...)\n+\treturn nil\n }\n \n // A MarshalXMLError is returned when Marshal encounters a type"}, {"sha": "d34118a3d8b7f7cf9708387e4936eec3fa891dd5", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -276,6 +276,54 @@ type Strings struct {\n \tX []string `xml:\"A>B,omitempty\"`\n }\n \n+type PointerFieldsTest struct {\n+\tXMLName  Name    `xml:\"dummy\"`\n+\tName     *string `xml:\"name,attr\"`\n+\tAge      *uint   `xml:\"age,attr\"`\n+\tEmpty    *string `xml:\"empty,attr\"`\n+\tContents *string `xml:\",chardata\"`\n+}\n+\n+type ChardataEmptyTest struct {\n+\tXMLName  Name    `xml:\"test\"`\n+\tContents *string `xml:\",chardata\"`\n+}\n+\n+type MyMarshalerTest struct {\n+}\n+\n+var _ Marshaler = (*MyMarshalerTest)(nil)\n+\n+func (m *MyMarshalerTest) MarshalXML(e *Encoder, start StartElement) error {\n+\te.EncodeToken(start)\n+\te.EncodeToken(CharData([]byte(\"hello world\")))\n+\te.EncodeToken(EndElement{start.Name})\n+\treturn nil\n+}\n+\n+type MyMarshalerAttrTest struct {\n+}\n+\n+var _ MarshalerAttr = (*MyMarshalerAttrTest)(nil)\n+\n+func (m *MyMarshalerAttrTest) MarshalXMLAttr(name Name) (Attr, error) {\n+\treturn Attr{name, \"hello world\"}, nil\n+}\n+\n+type MarshalerStruct struct {\n+\tFoo MyMarshalerAttrTest `xml:\",attr\"`\n+}\n+\n+func ifaceptr(x interface{}) interface{} {\n+\treturn &x\n+}\n+\n+var (\n+\tnameAttr     = \"Sarah\"\n+\tageAttr      = uint(12)\n+\tcontentsAttr = \"lorem ipsum\"\n+)\n+\n // Unless explicitly stated as such (or *Plain), all of the\n // tests below are two-way tests. When introducing new tests,\n // please try to make them two-way as well to ensure that\n@@ -312,6 +360,7 @@ var marshalTests = []struct {\n \t{Value: &Plain{NamedType(\"potato\")}, ExpectXML: `<Plain><V>potato</V></Plain>`},\n \t{Value: &Plain{[]int{1, 2, 3}}, ExpectXML: `<Plain><V>1</V><V>2</V><V>3</V></Plain>`},\n \t{Value: &Plain{[3]int{1, 2, 3}}, ExpectXML: `<Plain><V>1</V><V>2</V><V>3</V></Plain>`},\n+\t{Value: ifaceptr(true), MarshalOnly: true, ExpectXML: `<bool>true</bool>`},\n \n \t// Test time.\n \t{\n@@ -673,6 +722,20 @@ var marshalTests = []struct {\n \t\tExpectXML: `<OmitAttrTest></OmitAttrTest>`,\n \t},\n \n+\t// pointer fields\n+\t{\n+\t\tValue:       &PointerFieldsTest{Name: &nameAttr, Age: &ageAttr, Contents: &contentsAttr},\n+\t\tExpectXML:   `<dummy name=\"Sarah\" age=\"12\">lorem ipsum</dummy>`,\n+\t\tMarshalOnly: true,\n+\t},\n+\n+\t// empty chardata pointer field\n+\t{\n+\t\tValue:       &ChardataEmptyTest{},\n+\t\tExpectXML:   `<test></test>`,\n+\t\tMarshalOnly: true,\n+\t},\n+\n \t// omitempty on fields\n \t{\n \t\tValue: &OmitFieldTest{\n@@ -811,6 +874,15 @@ var marshalTests = []struct {\n \t\tExpectXML: `<Strings><A></A></Strings>`,\n \t\tValue:     &Strings{},\n \t},\n+\t// Custom marshalers.\n+\t{\n+\t\tExpectXML: `<MyMarshalerTest>hello world</MyMarshalerTest>`,\n+\t\tValue:     &MyMarshalerTest{},\n+\t},\n+\t{\n+\t\tExpectXML: `<MarshalerStruct Foo=\"hello world\"></MarshalerStruct>`,\n+\t\tValue:     &MarshalerStruct{},\n+\t},\n }\n \n func TestMarshal(t *testing.T) {\n@@ -837,6 +909,10 @@ type AttrParent struct {\n \tX string `xml:\"X>Y,attr\"`\n }\n \n+type BadAttr struct {\n+\tName []string `xml:\"name,attr\"`\n+}\n+\n var marshalErrorTests = []struct {\n \tValue interface{}\n \tErr   string\n@@ -869,6 +945,10 @@ var marshalErrorTests = []struct {\n \t\tValue: &AttrParent{},\n \t\tErr:   `xml: X>Y chain not valid with attr flag`,\n \t},\n+\t{\n+\t\tValue: BadAttr{[]string{\"X\", \"Y\"}},\n+\t\tErr:   `xml: unsupported type: []string`,\n+\t},\n }\n \n var marshalIndentTests = []struct {\n@@ -1009,6 +1089,23 @@ func TestMarshalWriteIOErrors(t *testing.T) {\n \t}\n }\n \n+func TestMarshalFlush(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\tif err := enc.EncodeToken(CharData(\"hello world\")); err != nil {\n+\t\tt.Fatalf(\"enc.EncodeToken: %v\", err)\n+\t}\n+\tif buf.Len() > 0 {\n+\t\tt.Fatalf(\"enc.EncodeToken caused actual write: %q\", buf.Bytes())\n+\t}\n+\tif err := enc.Flush(); err != nil {\n+\t\tt.Fatalf(\"enc.Flush: %v\", err)\n+\t}\n+\tif buf.String() != \"hello world\" {\n+\t\tt.Fatalf(\"after enc.Flush, buf.String() = %q, want %q\", buf.String(), \"hello world\")\n+\t}\n+}\n+\n func BenchmarkMarshal(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tMarshal(atomValue)\n@@ -1021,3 +1118,34 @@ func BenchmarkUnmarshal(b *testing.B) {\n \t\tUnmarshal(xml, &Feed{})\n \t}\n }\n+\n+// golang.org/issue/6556\n+func TestStructPointerMarshal(t *testing.T) {\n+\ttype A struct {\n+\t\tXMLName string `xml:\"a\"`\n+\t\tB       []interface{}\n+\t}\n+\ttype C struct {\n+\t\tXMLName Name\n+\t\tValue   string `xml:\"value\"`\n+\t}\n+\n+\ta := new(A)\n+\ta.B = append(a.B, &C{\n+\t\tXMLName: Name{Local: \"c\"},\n+\t\tValue:   \"x\",\n+\t})\n+\n+\tb, err := Marshal(a)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif x := string(b); x != \"<a><c><value>x</value></c></a>\" {\n+\t\tt.Fatal(x)\n+\t}\n+\tvar v A\n+\terr = Unmarshal(b, &v)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}"}, {"sha": "da7ad3baedc28ee0a755c26a61280aed9309f08c", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 185, "deletions": 21, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -6,11 +6,12 @@ package xml\n \n import (\n \t\"bytes\"\n+\t\"encoding\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"reflect\"\n \t\"strconv\"\n \t\"strings\"\n-\t\"time\"\n )\n \n // BUG(rsc): Mapping between XML elements and data structures is inherently flawed:\n@@ -57,7 +58,7 @@ import (\n //      If there is no such field, the character data is discarded.\n //\n //   * If the XML element contains comments, they are accumulated in\n-//      the first struct field that has tag \",comments\".  The struct\n+//      the first struct field that has tag \",comment\".  The struct\n //      field may have type []byte or string.  If there is no such\n //      field, the comments are discarded.\n //\n@@ -137,6 +138,136 @@ type UnmarshalError string\n \n func (e UnmarshalError) Error() string { return string(e) }\n \n+// Unmarshaler is the interface implemented by objects that can unmarshal\n+// an XML element description of themselves.\n+//\n+// UnmarshalXML decodes a single XML element\n+// beginning with the given start element.\n+// If it returns an error, the outer call to Unmarshal stops and\n+// returns that error.\n+// UnmarshalXML must consume exactly one XML element.\n+// One common implementation strategy is to unmarshal into\n+// a separate value with a layout matching the expected XML\n+// using d.DecodeElement,  and then to copy the data from\n+// that value into the receiver.\n+// Another common strategy is to use d.Token to process the\n+// XML object one token at a time.\n+// UnmarshalXML may not use d.RawToken.\n+type Unmarshaler interface {\n+\tUnmarshalXML(d *Decoder, start StartElement) error\n+}\n+\n+// UnmarshalerAttr is the interface implemented by objects that can unmarshal\n+// an XML attribute description of themselves.\n+//\n+// UnmarshalXMLAttr decodes a single XML attribute.\n+// If it returns an error, the outer call to Unmarshal stops and\n+// returns that error.\n+// UnmarshalXMLAttr is used only for struct fields with the\n+// \"attr\" option in the field tag.\n+type UnmarshalerAttr interface {\n+\tUnmarshalXMLAttr(attr Attr) error\n+}\n+\n+// receiverType returns the receiver type to use in an expression like \"%s.MethodName\".\n+func receiverType(val interface{}) string {\n+\tt := reflect.TypeOf(val)\n+\tif t.Name() != \"\" {\n+\t\treturn t.String()\n+\t}\n+\treturn \"(\" + t.String() + \")\"\n+}\n+\n+// unmarshalInterface unmarshals a single XML element into val.\n+// start is the opening tag of the element.\n+func (p *Decoder) unmarshalInterface(val Unmarshaler, start *StartElement) error {\n+\t// Record that decoder must stop at end tag corresponding to start.\n+\tp.pushEOF()\n+\n+\tp.unmarshalDepth++\n+\terr := val.UnmarshalXML(p, *start)\n+\tp.unmarshalDepth--\n+\tif err != nil {\n+\t\tp.popEOF()\n+\t\treturn err\n+\t}\n+\n+\tif !p.popEOF() {\n+\t\treturn fmt.Errorf(\"xml: %s.UnmarshalXML did not consume entire <%s> element\", receiverType(val), start.Name.Local)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// unmarshalTextInterface unmarshals a single XML element into val.\n+// The chardata contained in the element (but not its children)\n+// is passed to the text unmarshaler.\n+func (p *Decoder) unmarshalTextInterface(val encoding.TextUnmarshaler, start *StartElement) error {\n+\tvar buf []byte\n+\tdepth := 1\n+\tfor depth > 0 {\n+\t\tt, err := p.Token()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tswitch t := t.(type) {\n+\t\tcase CharData:\n+\t\t\tif depth == 1 {\n+\t\t\t\tbuf = append(buf, t...)\n+\t\t\t}\n+\t\tcase StartElement:\n+\t\t\tdepth++\n+\t\tcase EndElement:\n+\t\t\tdepth--\n+\t\t}\n+\t}\n+\treturn val.UnmarshalText(buf)\n+}\n+\n+// unmarshalAttr unmarshals a single XML attribute into val.\n+func (p *Decoder) unmarshalAttr(val reflect.Value, attr Attr) error {\n+\tif val.Kind() == reflect.Ptr {\n+\t\tif val.IsNil() {\n+\t\t\tval.Set(reflect.New(val.Type().Elem()))\n+\t\t}\n+\t\tval = val.Elem()\n+\t}\n+\n+\tif val.CanInterface() && val.Type().Implements(unmarshalerAttrType) {\n+\t\t// This is an unmarshaler with a non-pointer receiver,\n+\t\t// so it's likely to be incorrect, but we do what we're told.\n+\t\treturn val.Interface().(UnmarshalerAttr).UnmarshalXMLAttr(attr)\n+\t}\n+\tif val.CanAddr() {\n+\t\tpv := val.Addr()\n+\t\tif pv.CanInterface() && pv.Type().Implements(unmarshalerAttrType) {\n+\t\t\treturn pv.Interface().(UnmarshalerAttr).UnmarshalXMLAttr(attr)\n+\t\t}\n+\t}\n+\n+\t// Not an UnmarshalerAttr; try encoding.TextUnmarshaler.\n+\tif val.CanInterface() && val.Type().Implements(textUnmarshalerType) {\n+\t\t// This is an unmarshaler with a non-pointer receiver,\n+\t\t// so it's likely to be incorrect, but we do what we're told.\n+\t\treturn val.Interface().(encoding.TextUnmarshaler).UnmarshalText([]byte(attr.Value))\n+\t}\n+\tif val.CanAddr() {\n+\t\tpv := val.Addr()\n+\t\tif pv.CanInterface() && pv.Type().Implements(textUnmarshalerType) {\n+\t\t\treturn pv.Interface().(encoding.TextUnmarshaler).UnmarshalText([]byte(attr.Value))\n+\t\t}\n+\t}\n+\n+\tcopyValue(val, []byte(attr.Value))\n+\treturn nil\n+}\n+\n+var (\n+\tunmarshalerType     = reflect.TypeOf((*Unmarshaler)(nil)).Elem()\n+\tunmarshalerAttrType = reflect.TypeOf((*UnmarshalerAttr)(nil)).Elem()\n+\ttextUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()\n+)\n+\n // Unmarshal a single XML element into val.\n func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t// Find start element if we need it.\n@@ -153,11 +284,35 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t\t}\n \t}\n \n-\tif pv := val; pv.Kind() == reflect.Ptr {\n-\t\tif pv.IsNil() {\n-\t\t\tpv.Set(reflect.New(pv.Type().Elem()))\n+\tif val.Kind() == reflect.Ptr {\n+\t\tif val.IsNil() {\n+\t\t\tval.Set(reflect.New(val.Type().Elem()))\n+\t\t}\n+\t\tval = val.Elem()\n+\t}\n+\n+\tif val.CanInterface() && val.Type().Implements(unmarshalerType) {\n+\t\t// This is an unmarshaler with a non-pointer receiver,\n+\t\t// so it's likely to be incorrect, but we do what we're told.\n+\t\treturn p.unmarshalInterface(val.Interface().(Unmarshaler), start)\n+\t}\n+\n+\tif val.CanAddr() {\n+\t\tpv := val.Addr()\n+\t\tif pv.CanInterface() && pv.Type().Implements(unmarshalerType) {\n+\t\t\treturn p.unmarshalInterface(pv.Interface().(Unmarshaler), start)\n+\t\t}\n+\t}\n+\n+\tif val.CanInterface() && val.Type().Implements(textUnmarshalerType) {\n+\t\treturn p.unmarshalTextInterface(val.Interface().(encoding.TextUnmarshaler), start)\n+\t}\n+\n+\tif val.CanAddr() {\n+\t\tpv := val.Addr()\n+\t\tif pv.CanInterface() && pv.Type().Implements(textUnmarshalerType) {\n+\t\t\treturn p.unmarshalTextInterface(pv.Interface().(encoding.TextUnmarshaler), start)\n \t\t}\n-\t\tval = pv.Elem()\n \t}\n \n \tvar (\n@@ -222,10 +377,6 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t\t\tv.Set(reflect.ValueOf(start.Name))\n \t\t\tbreak\n \t\t}\n-\t\tif typ == timeType {\n-\t\t\tsaveData = v\n-\t\t\tbreak\n-\t\t}\n \n \t\tsv = v\n \t\ttinfo, err = getTypeInfo(typ)\n@@ -264,7 +415,9 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t\t\t\t// Look for attribute.\n \t\t\t\tfor _, a := range start.Attr {\n \t\t\t\t\tif a.Name.Local == finfo.name && (finfo.xmlns == \"\" || finfo.xmlns == a.Name.Space) {\n-\t\t\t\t\t\tcopyValue(strv, []byte(a.Value))\n+\t\t\t\t\t\tif err := p.unmarshalAttr(strv, a); err != nil {\n+\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -352,6 +505,23 @@ Loop:\n \t\t}\n \t}\n \n+\tif saveData.IsValid() && saveData.CanInterface() && saveData.Type().Implements(textUnmarshalerType) {\n+\t\tif err := saveData.Interface().(encoding.TextUnmarshaler).UnmarshalText(data); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tsaveData = reflect.Value{}\n+\t}\n+\n+\tif saveData.IsValid() && saveData.CanAddr() {\n+\t\tpv := saveData.Addr()\n+\t\tif pv.CanInterface() && pv.Type().Implements(textUnmarshalerType) {\n+\t\t\tif err := pv.Interface().(encoding.TextUnmarshaler).UnmarshalText(data); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tsaveData = reflect.Value{}\n+\t\t}\n+\t}\n+\n \tif err := copyValue(saveData, data); err != nil {\n \t\treturn err\n \t}\n@@ -374,6 +544,8 @@ Loop:\n }\n \n func copyValue(dst reflect.Value, src []byte) (err error) {\n+\tdst0 := dst\n+\n \tif dst.Kind() == reflect.Ptr {\n \t\tif dst.IsNil() {\n \t\t\tdst.Set(reflect.New(dst.Type().Elem()))\n@@ -384,9 +556,9 @@ func copyValue(dst reflect.Value, src []byte) (err error) {\n \t// Save accumulated data.\n \tswitch dst.Kind() {\n \tcase reflect.Invalid:\n-\t\t// Probably a commendst.\n+\t\t// Probably a comment.\n \tdefault:\n-\t\treturn errors.New(\"cannot happen: unknown type \" + dst.Type().String())\n+\t\treturn errors.New(\"cannot unmarshal into \" + dst0.Type().String())\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\titmp, err := strconv.ParseInt(string(src), 10, dst.Type().Bits())\n \t\tif err != nil {\n@@ -419,14 +591,6 @@ func copyValue(dst reflect.Value, src []byte) (err error) {\n \t\t\tsrc = []byte{}\n \t\t}\n \t\tdst.SetBytes(src)\n-\tcase reflect.Struct:\n-\t\tif dst.Type() == timeType {\n-\t\t\ttv, err := time.Parse(time.RFC3339, string(src))\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tdst.Set(reflect.ValueOf(tv))\n-\t\t}\n \t}\n \treturn nil\n }"}, {"sha": "1404c900f50506977c98c3f6d80f02cd0c841fa3", "filename": "libgo/go/encoding/xml/read_test.go", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -5,6 +5,7 @@\n package xml\n \n import (\n+\t\"io\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -621,3 +622,66 @@ func TestMarshalNSAttr(t *testing.T) {\n \t\tt.Errorf(\"Unmarshal = %q, want %q\", dst, src)\n \t}\n }\n+\n+type MyCharData struct {\n+\tbody string\n+}\n+\n+func (m *MyCharData) UnmarshalXML(d *Decoder, start StartElement) error {\n+\tfor {\n+\t\tt, err := d.Token()\n+\t\tif err == io.EOF { // found end of element\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif char, ok := t.(CharData); ok {\n+\t\t\tm.body += string(char)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+var _ Unmarshaler = (*MyCharData)(nil)\n+\n+func (m *MyCharData) UnmarshalXMLAttr(attr Attr) error {\n+\tpanic(\"must not call\")\n+}\n+\n+type MyAttr struct {\n+\tattr string\n+}\n+\n+func (m *MyAttr) UnmarshalXMLAttr(attr Attr) error {\n+\tm.attr = attr.Value\n+\treturn nil\n+}\n+\n+var _ UnmarshalerAttr = (*MyAttr)(nil)\n+\n+type MyStruct struct {\n+\tData *MyCharData\n+\tAttr *MyAttr `xml:\",attr\"`\n+\n+\tData2 MyCharData\n+\tAttr2 MyAttr `xml:\",attr\"`\n+}\n+\n+func TestUnmarshaler(t *testing.T) {\n+\txml := `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+\t\t<MyStruct Attr=\"attr1\" Attr2=\"attr2\">\n+\t\t<Data>hello <!-- comment -->world</Data>\n+\t\t<Data2>howdy <!-- comment -->world</Data2>\n+\t\t</MyStruct>\n+\t`\n+\n+\tvar m MyStruct\n+\tif err := Unmarshal([]byte(xml), &m); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif m.Data == nil || m.Attr == nil || m.Data.body != \"hello world\" || m.Attr.attr != \"attr1\" || m.Data2.body != \"howdy world\" || m.Attr2.attr != \"attr2\" {\n+\t\tt.Errorf(\"m=%#+v\\n\", m)\n+\t}\n+}"}, {"sha": "5b9d670024e792e022db314e6e87d29d7addc680", "filename": "libgo/go/encoding/xml/xml.go", "status": "modified", "additions": 142, "deletions": 18, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -16,6 +16,7 @@ package xml\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"strconv\"\n@@ -66,6 +67,11 @@ func (e StartElement) Copy() StartElement {\n \treturn e\n }\n \n+// End returns the corresponding XML end element.\n+func (e StartElement) End() EndElement {\n+\treturn EndElement{e.Name}\n+}\n+\n // An EndElement represents an XML end element.\n type EndElement struct {\n \tName Name\n@@ -144,6 +150,10 @@ type Decoder struct {\n \t//\td.Entity = HTMLEntity\n \t//\n \t// creates a parser that can handle typical HTML.\n+\t//\n+\t// Strict mode does not enforce the requirements of the XML name spaces TR.\n+\t// In particular it does not reject name space tags using undefined prefixes.\n+\t// Such tags are recorded with the unknown prefix as the name space URL.\n \tStrict bool\n \n \t// When Strict == false, AutoClose indicates a set of elements to\n@@ -174,18 +184,19 @@ type Decoder struct {\n \t// the attribute xmlns=\"DefaultSpace\".\n \tDefaultSpace string\n \n-\tr         io.ByteReader\n-\tbuf       bytes.Buffer\n-\tsaved     *bytes.Buffer\n-\tstk       *stack\n-\tfree      *stack\n-\tneedClose bool\n-\ttoClose   Name\n-\tnextToken Token\n-\tnextByte  int\n-\tns        map[string]string\n-\terr       error\n-\tline      int\n+\tr              io.ByteReader\n+\tbuf            bytes.Buffer\n+\tsaved          *bytes.Buffer\n+\tstk            *stack\n+\tfree           *stack\n+\tneedClose      bool\n+\ttoClose        Name\n+\tnextToken      Token\n+\tnextByte       int\n+\tns             map[string]string\n+\terr            error\n+\tline           int\n+\tunmarshalDepth int\n }\n \n // NewDecoder creates a new XML parser reading from r.\n@@ -223,10 +234,14 @@ func NewDecoder(r io.Reader) *Decoder {\n // If Token encounters an unrecognized name space prefix,\n // it uses the prefix as the Space rather than report an error.\n func (d *Decoder) Token() (t Token, err error) {\n+\tif d.stk != nil && d.stk.kind == stkEOF {\n+\t\terr = io.EOF\n+\t\treturn\n+\t}\n \tif d.nextToken != nil {\n \t\tt = d.nextToken\n \t\td.nextToken = nil\n-\t} else if t, err = d.RawToken(); err != nil {\n+\t} else if t, err = d.rawToken(); err != nil {\n \t\treturn\n \t}\n \n@@ -322,6 +337,7 @@ type stack struct {\n const (\n \tstkStart = iota\n \tstkNs\n+\tstkEOF\n )\n \n func (d *Decoder) push(kind int) *stack {\n@@ -347,6 +363,43 @@ func (d *Decoder) pop() *stack {\n \treturn s\n }\n \n+// Record that after the current element is finished\n+// (that element is already pushed on the stack)\n+// Token should return EOF until popEOF is called.\n+func (d *Decoder) pushEOF() {\n+\t// Walk down stack to find Start.\n+\t// It might not be the top, because there might be stkNs\n+\t// entries above it.\n+\tstart := d.stk\n+\tfor start.kind != stkStart {\n+\t\tstart = start.next\n+\t}\n+\t// The stkNs entries below a start are associated with that\n+\t// element too; skip over them.\n+\tfor start.next != nil && start.next.kind == stkNs {\n+\t\tstart = start.next\n+\t}\n+\ts := d.free\n+\tif s != nil {\n+\t\td.free = s.next\n+\t} else {\n+\t\ts = new(stack)\n+\t}\n+\ts.kind = stkEOF\n+\ts.next = start.next\n+\tstart.next = s\n+}\n+\n+// Undo a pushEOF.\n+// The element must have been finished, so the EOF should be at the top of the stack.\n+func (d *Decoder) popEOF() bool {\n+\tif d.stk == nil || d.stk.kind != stkEOF {\n+\t\treturn false\n+\t}\n+\td.pop()\n+\treturn true\n+}\n+\n // Record that we are starting an element with the given name.\n func (d *Decoder) pushElement(name Name) {\n \ts := d.push(stkStart)\n@@ -395,9 +448,9 @@ func (d *Decoder) popElement(t *EndElement) bool {\n \t\treturn false\n \t}\n \n-\t// Pop stack until a Start is on the top, undoing the\n+\t// Pop stack until a Start or EOF is on the top, undoing the\n \t// translations that were associated with the element we just closed.\n-\tfor d.stk != nil && d.stk.kind != stkStart {\n+\tfor d.stk != nil && d.stk.kind != stkStart && d.stk.kind != stkEOF {\n \t\ts := d.pop()\n \t\tif s.ok {\n \t\t\td.ns[s.name.Local] = s.name.Space\n@@ -429,10 +482,19 @@ func (d *Decoder) autoClose(t Token) (Token, bool) {\n \treturn nil, false\n }\n \n+var errRawToken = errors.New(\"xml: cannot use RawToken from UnmarshalXML method\")\n+\n // RawToken is like Token but does not verify that\n // start and end elements match and does not translate\n // name space prefixes to their corresponding URLs.\n func (d *Decoder) RawToken() (Token, error) {\n+\tif d.unmarshalDepth > 0 {\n+\t\treturn nil, errRawToken\n+\t}\n+\treturn d.rawToken()\n+}\n+\n+func (d *Decoder) rawToken() (Token, error) {\n \tif d.err != nil {\n \t\treturn nil, d.err\n \t}\n@@ -484,8 +546,7 @@ func (d *Decoder) RawToken() (Token, error) {\n \n \tcase '?':\n \t\t// <?: Processing instruction.\n-\t\t// TODO(rsc): Should parse the <?xml declaration to make sure\n-\t\t// the version is 1.0 and the encoding is UTF-8.\n+\t\t// TODO(rsc): Should parse the <?xml declaration to make sure the version is 1.0.\n \t\tvar target string\n \t\tif target, ok = d.name(); !ok {\n \t\t\tif d.err == nil {\n@@ -1112,6 +1173,30 @@ func isName(s []byte) bool {\n \treturn true\n }\n \n+func isNameString(s string) bool {\n+\tif len(s) == 0 {\n+\t\treturn false\n+\t}\n+\tc, n := utf8.DecodeRuneInString(s)\n+\tif c == utf8.RuneError && n == 1 {\n+\t\treturn false\n+\t}\n+\tif !unicode.Is(first, c) {\n+\t\treturn false\n+\t}\n+\tfor n < len(s) {\n+\t\ts = s[n:]\n+\t\tc, n = utf8.DecodeRuneInString(s)\n+\t\tif c == utf8.RuneError && n == 1 {\n+\t\t\treturn false\n+\t\t}\n+\t\tif !unicode.Is(first, c) && !unicode.Is(second, c) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n // These tables were generated by cut and paste from Appendix B of\n // the XML spec at http://www.xml.com/axml/testaxml.htm\n // and then reformatting.  First corresponds to (Letter | '_' | ':')\n@@ -1758,7 +1843,7 @@ func EscapeText(w io.Writer, s []byte) error {\n \t\tcase '\\r':\n \t\t\tesc = esc_cr\n \t\tdefault:\n-\t\t\tif !isInCharacterRange(r) {\n+\t\t\tif !isInCharacterRange(r) || (r == 0xFFFD && width == 1) {\n \t\t\t\tesc = esc_fffd\n \t\t\t\tbreak\n \t\t\t}\n@@ -1778,6 +1863,45 @@ func EscapeText(w io.Writer, s []byte) error {\n \treturn nil\n }\n \n+// EscapeString writes to p the properly escaped XML equivalent\n+// of the plain text data s.\n+func (p *printer) EscapeString(s string) {\n+\tvar esc []byte\n+\tlast := 0\n+\tfor i := 0; i < len(s); {\n+\t\tr, width := utf8.DecodeRuneInString(s[i:])\n+\t\ti += width\n+\t\tswitch r {\n+\t\tcase '\"':\n+\t\t\tesc = esc_quot\n+\t\tcase '\\'':\n+\t\t\tesc = esc_apos\n+\t\tcase '&':\n+\t\t\tesc = esc_amp\n+\t\tcase '<':\n+\t\t\tesc = esc_lt\n+\t\tcase '>':\n+\t\t\tesc = esc_gt\n+\t\tcase '\\t':\n+\t\t\tesc = esc_tab\n+\t\tcase '\\n':\n+\t\t\tesc = esc_nl\n+\t\tcase '\\r':\n+\t\t\tesc = esc_cr\n+\t\tdefault:\n+\t\t\tif !isInCharacterRange(r) || (r == 0xFFFD && width == 1) {\n+\t\t\t\tesc = esc_fffd\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tp.WriteString(s[last : i-width])\n+\t\tp.Write(esc)\n+\t\tlast = i\n+\t}\n+\tp.WriteString(s[last:])\n+}\n+\n // Escape is like EscapeText but omits the error return value.\n // It is provided for backwards compatibility with Go 1.0.\n // Code targeting Go 1.1 or later should use EscapeText."}, {"sha": "7723ab1c9f09a033e43e7b56c98eb29c53b11801", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\t\"unicode/utf8\"\n )\n \n const testInput = `\n@@ -246,10 +247,8 @@ func (d *downCaser) Read(p []byte) (int, error) {\n }\n \n func TestRawTokenAltEncoding(t *testing.T) {\n-\tsawEncoding := \"\"\n \td := NewDecoder(strings.NewReader(testInputAltEncoding))\n \td.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {\n-\t\tsawEncoding = charset\n \t\tif charset != \"x-testing-uppercase\" {\n \t\t\tt.Fatalf(\"unexpected charset %q\", charset)\n \t\t}\n@@ -714,3 +713,14 @@ func TestEscapeTextInvalidChar(t *testing.T) {\n \t\tt.Errorf(\"have %v, want %v\", text, expected)\n \t}\n }\n+\n+func TestIssue5880(t *testing.T) {\n+\ttype T []byte\n+\tdata, err := Marshal(T{192, 168, 0, 1})\n+\tif err != nil {\n+\t\tt.Errorf(\"Marshal error: %v\", err)\n+\t}\n+\tif !utf8.Valid(data) {\n+\t\tt.Errorf(\"Marshal generated invalid UTF-8: %x\", data)\n+\t}\n+}"}, {"sha": "56cda58b36c4738af61b160643d926f6d4cdee15", "filename": "libgo/go/flag/export_test.go", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fflag%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fflag%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fexport_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -12,11 +12,6 @@ import \"os\"\n // After calling ResetForTesting, parse errors in flag handling will not\n // exit the program.\n func ResetForTesting(usage func()) {\n-\tcommandLine = NewFlagSet(os.Args[0], ContinueOnError)\n+\tCommandLine = NewFlagSet(os.Args[0], ContinueOnError)\n \tUsage = usage\n }\n-\n-// CommandLine returns the default FlagSet.\n-func CommandLine() *FlagSet {\n-\treturn commandLine\n-}"}, {"sha": "e7c863ee92d2d3ba9590a4b377fb61d5e8b61f43", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 75, "deletions": 38, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -89,6 +89,8 @@ func (b *boolValue) Set(s string) error {\n \treturn err\n }\n \n+func (b *boolValue) Get() interface{} { return bool(*b) }\n+\n func (b *boolValue) String() string { return fmt.Sprintf(\"%v\", *b) }\n \n func (b *boolValue) IsBoolFlag() bool { return true }\n@@ -114,6 +116,8 @@ func (i *intValue) Set(s string) error {\n \treturn err\n }\n \n+func (i *intValue) Get() interface{} { return int(*i) }\n+\n func (i *intValue) String() string { return fmt.Sprintf(\"%v\", *i) }\n \n // -- int64 Value\n@@ -130,6 +134,8 @@ func (i *int64Value) Set(s string) error {\n \treturn err\n }\n \n+func (i *int64Value) Get() interface{} { return int64(*i) }\n+\n func (i *int64Value) String() string { return fmt.Sprintf(\"%v\", *i) }\n \n // -- uint Value\n@@ -146,6 +152,8 @@ func (i *uintValue) Set(s string) error {\n \treturn err\n }\n \n+func (i *uintValue) Get() interface{} { return uint(*i) }\n+\n func (i *uintValue) String() string { return fmt.Sprintf(\"%v\", *i) }\n \n // -- uint64 Value\n@@ -162,6 +170,8 @@ func (i *uint64Value) Set(s string) error {\n \treturn err\n }\n \n+func (i *uint64Value) Get() interface{} { return uint64(*i) }\n+\n func (i *uint64Value) String() string { return fmt.Sprintf(\"%v\", *i) }\n \n // -- string Value\n@@ -177,6 +187,8 @@ func (s *stringValue) Set(val string) error {\n \treturn nil\n }\n \n+func (s *stringValue) Get() interface{} { return string(*s) }\n+\n func (s *stringValue) String() string { return fmt.Sprintf(\"%s\", *s) }\n \n // -- float64 Value\n@@ -193,6 +205,8 @@ func (f *float64Value) Set(s string) error {\n \treturn err\n }\n \n+func (f *float64Value) Get() interface{} { return float64(*f) }\n+\n func (f *float64Value) String() string { return fmt.Sprintf(\"%v\", *f) }\n \n // -- time.Duration Value\n@@ -209,6 +223,8 @@ func (d *durationValue) Set(s string) error {\n \treturn err\n }\n \n+func (d *durationValue) Get() interface{} { return time.Duration(*d) }\n+\n func (d *durationValue) String() string { return (*time.Duration)(d).String() }\n \n // Value is the interface to the dynamic value stored in a flag.\n@@ -222,6 +238,15 @@ type Value interface {\n \tSet(string) error\n }\n \n+// Getter is an interface that allows the contents of a Value to be retrieved.\n+// It wraps the Value interface, rather than being part of it, because it\n+// appeared after Go 1 and its compatibility rules. All Value types provided\n+// by this package satisfy the Getter interface.\n+type Getter interface {\n+\tValue\n+\tGet() interface{}\n+}\n+\n // ErrorHandling defines how to handle flag parsing errors.\n type ErrorHandling int\n \n@@ -231,7 +256,8 @@ const (\n \tPanicOnError\n )\n \n-// A FlagSet represents a set of defined flags.\n+// A FlagSet represents a set of defined flags.  The zero value of a FlagSet\n+// has no name and has ContinueOnError error handling.\n type FlagSet struct {\n \t// Usage is the function called when an error occurs while parsing flags.\n \t// The field is a function (not a method) that may be changed to point to\n@@ -296,7 +322,7 @@ func (f *FlagSet) VisitAll(fn func(*Flag)) {\n // VisitAll visits the command-line flags in lexicographical order, calling\n // fn for each.  It visits all flags, even those not set.\n func VisitAll(fn func(*Flag)) {\n-\tcommandLine.VisitAll(fn)\n+\tCommandLine.VisitAll(fn)\n }\n \n // Visit visits the flags in lexicographical order, calling fn for each.\n@@ -310,7 +336,7 @@ func (f *FlagSet) Visit(fn func(*Flag)) {\n // Visit visits the command-line flags in lexicographical order, calling fn\n // for each.  It visits only those flags that have been set.\n func Visit(fn func(*Flag)) {\n-\tcommandLine.Visit(fn)\n+\tCommandLine.Visit(fn)\n }\n \n // Lookup returns the Flag structure of the named flag, returning nil if none exists.\n@@ -321,7 +347,7 @@ func (f *FlagSet) Lookup(name string) *Flag {\n // Lookup returns the Flag structure of the named command-line flag,\n // returning nil if none exists.\n func Lookup(name string) *Flag {\n-\treturn commandLine.formal[name]\n+\treturn CommandLine.formal[name]\n }\n \n // Set sets the value of the named flag.\n@@ -343,7 +369,7 @@ func (f *FlagSet) Set(name, value string) error {\n \n // Set sets the value of the named command-line flag.\n func Set(name, value string) error {\n-\treturn commandLine.Set(name, value)\n+\treturn CommandLine.Set(name, value)\n }\n \n // PrintDefaults prints, to standard error unless configured\n@@ -361,16 +387,20 @@ func (f *FlagSet) PrintDefaults() {\n \n // PrintDefaults prints to standard error the default values of all defined command-line flags.\n func PrintDefaults() {\n-\tcommandLine.PrintDefaults()\n+\tCommandLine.PrintDefaults()\n }\n \n // defaultUsage is the default function to print a usage message.\n func defaultUsage(f *FlagSet) {\n-\tfmt.Fprintf(f.out(), \"Usage of %s:\\n\", f.name)\n+\tif f.name == \"\" {\n+\t\tfmt.Fprintf(f.out(), \"Usage:\\n\")\n+\t} else {\n+\t\tfmt.Fprintf(f.out(), \"Usage of %s:\\n\", f.name)\n+\t}\n \tf.PrintDefaults()\n }\n \n-// NOTE: Usage is not just defaultUsage(commandLine)\n+// NOTE: Usage is not just defaultUsage(CommandLine)\n // because it serves (via godoc flag Usage) as the example\n // for how to write your own usage function.\n \n@@ -385,7 +415,7 @@ var Usage = func() {\n func (f *FlagSet) NFlag() int { return len(f.actual) }\n \n // NFlag returns the number of command-line flags that have been set.\n-func NFlag() int { return len(commandLine.actual) }\n+func NFlag() int { return len(CommandLine.actual) }\n \n // Arg returns the i'th argument.  Arg(0) is the first remaining argument\n // after flags have been processed.\n@@ -399,20 +429,20 @@ func (f *FlagSet) Arg(i int) string {\n // Arg returns the i'th command-line argument.  Arg(0) is the first remaining argument\n // after flags have been processed.\n func Arg(i int) string {\n-\treturn commandLine.Arg(i)\n+\treturn CommandLine.Arg(i)\n }\n \n // NArg is the number of arguments remaining after flags have been processed.\n func (f *FlagSet) NArg() int { return len(f.args) }\n \n // NArg is the number of arguments remaining after flags have been processed.\n-func NArg() int { return len(commandLine.args) }\n+func NArg() int { return len(CommandLine.args) }\n \n // Args returns the non-flag arguments.\n func (f *FlagSet) Args() []string { return f.args }\n \n // Args returns the non-flag command-line arguments.\n-func Args() []string { return commandLine.args }\n+func Args() []string { return CommandLine.args }\n \n // BoolVar defines a bool flag with specified name, default value, and usage string.\n // The argument p points to a bool variable in which to store the value of the flag.\n@@ -423,7 +453,7 @@ func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string) {\n // BoolVar defines a bool flag with specified name, default value, and usage string.\n // The argument p points to a bool variable in which to store the value of the flag.\n func BoolVar(p *bool, name string, value bool, usage string) {\n-\tcommandLine.Var(newBoolValue(value, p), name, usage)\n+\tCommandLine.Var(newBoolValue(value, p), name, usage)\n }\n \n // Bool defines a bool flag with specified name, default value, and usage string.\n@@ -437,7 +467,7 @@ func (f *FlagSet) Bool(name string, value bool, usage string) *bool {\n // Bool defines a bool flag with specified name, default value, and usage string.\n // The return value is the address of a bool variable that stores the value of the flag.\n func Bool(name string, value bool, usage string) *bool {\n-\treturn commandLine.Bool(name, value, usage)\n+\treturn CommandLine.Bool(name, value, usage)\n }\n \n // IntVar defines an int flag with specified name, default value, and usage string.\n@@ -449,7 +479,7 @@ func (f *FlagSet) IntVar(p *int, name string, value int, usage string) {\n // IntVar defines an int flag with specified name, default value, and usage string.\n // The argument p points to an int variable in which to store the value of the flag.\n func IntVar(p *int, name string, value int, usage string) {\n-\tcommandLine.Var(newIntValue(value, p), name, usage)\n+\tCommandLine.Var(newIntValue(value, p), name, usage)\n }\n \n // Int defines an int flag with specified name, default value, and usage string.\n@@ -463,7 +493,7 @@ func (f *FlagSet) Int(name string, value int, usage string) *int {\n // Int defines an int flag with specified name, default value, and usage string.\n // The return value is the address of an int variable that stores the value of the flag.\n func Int(name string, value int, usage string) *int {\n-\treturn commandLine.Int(name, value, usage)\n+\treturn CommandLine.Int(name, value, usage)\n }\n \n // Int64Var defines an int64 flag with specified name, default value, and usage string.\n@@ -475,7 +505,7 @@ func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string) {\n // Int64Var defines an int64 flag with specified name, default value, and usage string.\n // The argument p points to an int64 variable in which to store the value of the flag.\n func Int64Var(p *int64, name string, value int64, usage string) {\n-\tcommandLine.Var(newInt64Value(value, p), name, usage)\n+\tCommandLine.Var(newInt64Value(value, p), name, usage)\n }\n \n // Int64 defines an int64 flag with specified name, default value, and usage string.\n@@ -489,7 +519,7 @@ func (f *FlagSet) Int64(name string, value int64, usage string) *int64 {\n // Int64 defines an int64 flag with specified name, default value, and usage string.\n // The return value is the address of an int64 variable that stores the value of the flag.\n func Int64(name string, value int64, usage string) *int64 {\n-\treturn commandLine.Int64(name, value, usage)\n+\treturn CommandLine.Int64(name, value, usage)\n }\n \n // UintVar defines a uint flag with specified name, default value, and usage string.\n@@ -501,7 +531,7 @@ func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string) {\n // UintVar defines a uint flag with specified name, default value, and usage string.\n // The argument p points to a uint  variable in which to store the value of the flag.\n func UintVar(p *uint, name string, value uint, usage string) {\n-\tcommandLine.Var(newUintValue(value, p), name, usage)\n+\tCommandLine.Var(newUintValue(value, p), name, usage)\n }\n \n // Uint defines a uint flag with specified name, default value, and usage string.\n@@ -515,7 +545,7 @@ func (f *FlagSet) Uint(name string, value uint, usage string) *uint {\n // Uint defines a uint flag with specified name, default value, and usage string.\n // The return value is the address of a uint  variable that stores the value of the flag.\n func Uint(name string, value uint, usage string) *uint {\n-\treturn commandLine.Uint(name, value, usage)\n+\treturn CommandLine.Uint(name, value, usage)\n }\n \n // Uint64Var defines a uint64 flag with specified name, default value, and usage string.\n@@ -527,7 +557,7 @@ func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string)\n // Uint64Var defines a uint64 flag with specified name, default value, and usage string.\n // The argument p points to a uint64 variable in which to store the value of the flag.\n func Uint64Var(p *uint64, name string, value uint64, usage string) {\n-\tcommandLine.Var(newUint64Value(value, p), name, usage)\n+\tCommandLine.Var(newUint64Value(value, p), name, usage)\n }\n \n // Uint64 defines a uint64 flag with specified name, default value, and usage string.\n@@ -541,7 +571,7 @@ func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64 {\n // Uint64 defines a uint64 flag with specified name, default value, and usage string.\n // The return value is the address of a uint64 variable that stores the value of the flag.\n func Uint64(name string, value uint64, usage string) *uint64 {\n-\treturn commandLine.Uint64(name, value, usage)\n+\treturn CommandLine.Uint64(name, value, usage)\n }\n \n // StringVar defines a string flag with specified name, default value, and usage string.\n@@ -553,7 +583,7 @@ func (f *FlagSet) StringVar(p *string, name string, value string, usage string)\n // StringVar defines a string flag with specified name, default value, and usage string.\n // The argument p points to a string variable in which to store the value of the flag.\n func StringVar(p *string, name string, value string, usage string) {\n-\tcommandLine.Var(newStringValue(value, p), name, usage)\n+\tCommandLine.Var(newStringValue(value, p), name, usage)\n }\n \n // String defines a string flag with specified name, default value, and usage string.\n@@ -567,7 +597,7 @@ func (f *FlagSet) String(name string, value string, usage string) *string {\n // String defines a string flag with specified name, default value, and usage string.\n // The return value is the address of a string variable that stores the value of the flag.\n func String(name string, value string, usage string) *string {\n-\treturn commandLine.String(name, value, usage)\n+\treturn CommandLine.String(name, value, usage)\n }\n \n // Float64Var defines a float64 flag with specified name, default value, and usage string.\n@@ -579,7 +609,7 @@ func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage strin\n // Float64Var defines a float64 flag with specified name, default value, and usage string.\n // The argument p points to a float64 variable in which to store the value of the flag.\n func Float64Var(p *float64, name string, value float64, usage string) {\n-\tcommandLine.Var(newFloat64Value(value, p), name, usage)\n+\tCommandLine.Var(newFloat64Value(value, p), name, usage)\n }\n \n // Float64 defines a float64 flag with specified name, default value, and usage string.\n@@ -593,7 +623,7 @@ func (f *FlagSet) Float64(name string, value float64, usage string) *float64 {\n // Float64 defines a float64 flag with specified name, default value, and usage string.\n // The return value is the address of a float64 variable that stores the value of the flag.\n func Float64(name string, value float64, usage string) *float64 {\n-\treturn commandLine.Float64(name, value, usage)\n+\treturn CommandLine.Float64(name, value, usage)\n }\n \n // DurationVar defines a time.Duration flag with specified name, default value, and usage string.\n@@ -605,7 +635,7 @@ func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration\n // DurationVar defines a time.Duration flag with specified name, default value, and usage string.\n // The argument p points to a time.Duration variable in which to store the value of the flag.\n func DurationVar(p *time.Duration, name string, value time.Duration, usage string) {\n-\tcommandLine.Var(newDurationValue(value, p), name, usage)\n+\tCommandLine.Var(newDurationValue(value, p), name, usage)\n }\n \n // Duration defines a time.Duration flag with specified name, default value, and usage string.\n@@ -619,7 +649,7 @@ func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time\n // Duration defines a time.Duration flag with specified name, default value, and usage string.\n // The return value is the address of a time.Duration variable that stores the value of the flag.\n func Duration(name string, value time.Duration, usage string) *time.Duration {\n-\treturn commandLine.Duration(name, value, usage)\n+\treturn CommandLine.Duration(name, value, usage)\n }\n \n // Var defines a flag with the specified name and usage string. The type and\n@@ -633,7 +663,12 @@ func (f *FlagSet) Var(value Value, name string, usage string) {\n \tflag := &Flag{name, usage, value, value.String()}\n \t_, alreadythere := f.formal[name]\n \tif alreadythere {\n-\t\tmsg := fmt.Sprintf(\"%s flag redefined: %s\", f.name, name)\n+\t\tvar msg string\n+\t\tif f.name == \"\" {\n+\t\t\tmsg = fmt.Sprintf(\"flag redefined: %s\", name)\n+\t\t} else {\n+\t\t\tmsg = fmt.Sprintf(\"%s flag redefined: %s\", f.name, name)\n+\t\t}\n \t\tfmt.Fprintln(f.out(), msg)\n \t\tpanic(msg) // Happens only if flags are declared with identical names\n \t}\n@@ -650,7 +685,7 @@ func (f *FlagSet) Var(value Value, name string, usage string) {\n // of strings by giving the slice the methods of Value; in particular, Set would\n // decompose the comma-separated string into the slice.\n func Var(value Value, name string, usage string) {\n-\tcommandLine.Var(value, name, usage)\n+\tCommandLine.Var(value, name, usage)\n }\n \n // failf prints to standard error a formatted error and usage message and\n@@ -663,9 +698,9 @@ func (f *FlagSet) failf(format string, a ...interface{}) error {\n }\n \n // usage calls the Usage method for the flag set, or the usage function if\n-// the flag set is commandLine.\n+// the flag set is CommandLine.\n func (f *FlagSet) usage() {\n-\tif f == commandLine {\n+\tif f == CommandLine {\n \t\tUsage()\n \t} else if f.Usage == nil {\n \t\tdefaultUsage(f)\n@@ -674,7 +709,7 @@ func (f *FlagSet) usage() {\n \t}\n }\n \n-// parseOne parses one flag. It returns whether a flag was seen.\n+// parseOne parses one flag. It reports whether a flag was seen.\n func (f *FlagSet) parseOne() (bool, error) {\n \tif len(f.args) == 0 {\n \t\treturn false, nil\n@@ -781,17 +816,19 @@ func (f *FlagSet) Parsed() bool {\n // Parse parses the command-line flags from os.Args[1:].  Must be called\n // after all flags are defined and before flags are accessed by the program.\n func Parse() {\n-\t// Ignore errors; commandLine is set for ExitOnError.\n-\tcommandLine.Parse(os.Args[1:])\n+\t// Ignore errors; CommandLine is set for ExitOnError.\n+\tCommandLine.Parse(os.Args[1:])\n }\n \n // Parsed returns true if the command-line flags have been parsed.\n func Parsed() bool {\n-\treturn commandLine.Parsed()\n+\treturn CommandLine.Parsed()\n }\n \n-// The default set of command-line flags, parsed from os.Args.\n-var commandLine = NewFlagSet(os.Args[0], ExitOnError)\n+// CommandLine is the default set of command-line flags, parsed from os.Args.\n+// The top-level functions such as BoolVar, Arg, and on are wrappers for the\n+// methods of CommandLine.\n+var CommandLine = NewFlagSet(os.Args[0], ExitOnError)\n \n // NewFlagSet returns a new, empty flag set with the specified name and\n // error handling property."}, {"sha": "2c0387269791b3004db2f5bb9e31c9dc7556980c", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -92,10 +92,54 @@ func TestEverything(t *testing.T) {\n \t}\n }\n \n+func TestGet(t *testing.T) {\n+\tResetForTesting(nil)\n+\tBool(\"test_bool\", true, \"bool value\")\n+\tInt(\"test_int\", 1, \"int value\")\n+\tInt64(\"test_int64\", 2, \"int64 value\")\n+\tUint(\"test_uint\", 3, \"uint value\")\n+\tUint64(\"test_uint64\", 4, \"uint64 value\")\n+\tString(\"test_string\", \"5\", \"string value\")\n+\tFloat64(\"test_float64\", 6, \"float64 value\")\n+\tDuration(\"test_duration\", 7, \"time.Duration value\")\n+\n+\tvisitor := func(f *Flag) {\n+\t\tif len(f.Name) > 5 && f.Name[0:5] == \"test_\" {\n+\t\t\tg, ok := f.Value.(Getter)\n+\t\t\tif !ok {\n+\t\t\t\tt.Errorf(\"Visit: value does not satisfy Getter: %T\", f.Value)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tswitch f.Name {\n+\t\t\tcase \"test_bool\":\n+\t\t\t\tok = g.Get() == true\n+\t\t\tcase \"test_int\":\n+\t\t\t\tok = g.Get() == int(1)\n+\t\t\tcase \"test_int64\":\n+\t\t\t\tok = g.Get() == int64(2)\n+\t\t\tcase \"test_uint\":\n+\t\t\t\tok = g.Get() == uint(3)\n+\t\t\tcase \"test_uint64\":\n+\t\t\t\tok = g.Get() == uint64(4)\n+\t\t\tcase \"test_string\":\n+\t\t\t\tok = g.Get() == \"5\"\n+\t\t\tcase \"test_float64\":\n+\t\t\t\tok = g.Get() == float64(6)\n+\t\t\tcase \"test_duration\":\n+\t\t\t\tok = g.Get() == time.Duration(7)\n+\t\t\t}\n+\t\t\tif !ok {\n+\t\t\t\tt.Errorf(\"Visit: bad value %T(%v) for %s\", g.Get(), g.Get(), f.Name)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tVisitAll(visitor)\n+}\n+\n func TestUsage(t *testing.T) {\n \tcalled := false\n \tResetForTesting(func() { called = true })\n-\tif CommandLine().Parse([]string{\"-x\"}) == nil {\n+\tif CommandLine.Parse([]string{\"-x\"}) == nil {\n \t\tt.Error(\"parse did not fail for unknown flag\")\n \t}\n \tif !called {\n@@ -171,7 +215,7 @@ func testParse(f *FlagSet, t *testing.T) {\n \n func TestParse(t *testing.T) {\n \tResetForTesting(func() { t.Error(\"bad parse\") })\n-\ttestParse(CommandLine(), t)\n+\ttestParse(CommandLine, t)\n }\n \n func TestFlagSetParse(t *testing.T) {\n@@ -267,7 +311,7 @@ func TestChangingArgs(t *testing.T) {\n \tdefer func() { os.Args = oldArgs }()\n \tos.Args = []string{\"cmd\", \"-before\", \"subcmd\", \"-after\", \"args\"}\n \tbefore := Bool(\"before\", false, \"\")\n-\tif err := CommandLine().Parse(os.Args[1:]); err != nil {\n+\tif err := CommandLine.Parse(os.Args[1:]); err != nil {\n \t\tt.Fatal(err)\n \t}\n \tcmd := Arg(0)"}, {"sha": "095fd03b23ddd4042d09852dd906790f3accbb99", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -118,6 +118,28 @@\n \tconvert the value before recurring:\n \t\tfunc (x X) String() string { return Sprintf(\"<%s>\", string(x)) }\n \n+\tExplicit argument indexes:\n+\n+\tIn Printf, Sprintf, and Fprintf, the default behavior is for each\n+\tformatting verb to format successive arguments passed in the call.\n+\tHowever, the notation [n] immediately before the verb indicates that the\n+\tnth one-indexed argument is to be formatted instead. The same notation\n+\tbefore a '*' for a width or precision selects the argument index holding\n+\tthe value. After processing a bracketed expression [n], arguments n+1,\n+\tn+2, etc. will be processed unless otherwise directed.\n+\n+\tFor example,\n+\t\tfmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)\n+\twill yield \"22, 11\", while\n+\t\tfmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6),\n+\tequivalent to\n+\t\tfmt.Sprintf(\"%6.2f\", 12.0),\n+\twill yield \" 12.00\". Because an explicit index affects subsequent verbs,\n+\tthis notation can be used to print the same values multiple times\n+\tby resetting the index for the first argument to be repeated:\n+\t\tfmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17)\n+\twill yield \"16 17 0x10 0x11\".\n+\n \tFormat errors:\n \n \tIf an invalid argument is given for a verb, such as providing\n@@ -133,6 +155,9 @@\n \t\tNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n \t\t\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n \t\t\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\n+\t\tInvalid or invalid use of argument index: %!(BADINDEX)\n+\t\t\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n+\t\t\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\n \n \tAll errors begin with the string \"%!\" followed sometimes\n \tby a single character (the verb) and end with a parenthesized\n@@ -144,9 +169,9 @@\n \tthrough the fmt package.  For example, if a String method\n \tcalls panic(\"bad\"), the resulting formatted message will look\n \tlike\n-\t\t%s(PANIC=bad)\n+\t\t%!s(PANIC=bad)\n \n-\tThe %s just shows the print verb in use when the failure\n+\tThe %!s just shows the print verb in use when the failure\n \toccurred.\n \n \tScanning\n@@ -190,6 +215,10 @@\n \tstops if it does not, with the return value of the function\n \tindicating the number of arguments scanned.\n \n+\tIn all the scanning functions, a carriage return followed\n+\timmediately by a newline is treated as a plain newline\n+\t(\\r\\n means the same as \\n).\n+\n \tIn all the scanning functions, if an operand implements method\n \tScan (that is, it implements the Scanner interface) that\n \tmethod will be used to scan the text for that operand.  Also,"}, {"sha": "bbca2c574b039ac39d3f542cea083f17f3c7507d", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 78, "deletions": 11, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -110,7 +110,7 @@ var bslice = barray[:]\n \n var b byte\n \n-var fmttests = []struct {\n+var fmtTests = []struct {\n \tfmt string\n \tval interface{}\n \tout string\n@@ -227,6 +227,8 @@ var fmttests = []struct {\n \t{\"%+.3g\", -1.0, \"-1\"},\n \t{\"% .3g\", -1.0, \"-1\"},\n \t{\"% .3g\", 1.0, \" 1\"},\n+\t{\"%b\", float32(1.0), \"8388608p-23\"},\n+\t{\"%b\", 1.0, \"4503599627370496p-52\"},\n \n \t// complex values\n \t{\"%+.3e\", 0i, \"(+0.000e+00+0.000e+00i)\"},\n@@ -247,6 +249,8 @@ var fmttests = []struct {\n \t{\"% .3E\", -1 - 2i, \"(-1.000E+00-2.000E+00i)\"},\n \t{\"%+.3g\", complex64(1 + 2i), \"(+1+2i)\"},\n \t{\"%+.3g\", complex128(1 + 2i), \"(+1+2i)\"},\n+\t{\"%b\", complex64(1 + 2i), \"(8388608p-23+8388608p-22i)\"},\n+\t{\"%b\", 1 + 2i, \"(4503599627370496p-52+4503599627370496p-51i)\"},\n \n \t// erroneous formats\n \t{\"\", 2, \"%!(EXTRA int=2)\"},\n@@ -493,6 +497,17 @@ var fmttests = []struct {\n \t// Used to crash because nByte didn't allow for a sign.\n \t{\"%b\", int64(-1 << 63), \"-1000000000000000000000000000000000000000000000000000000000000000\"},\n \n+\t// Used to panic.\n+\t{\"%0100d\", 1, \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"},\n+\t{\"%0100d\", -1, \"-000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"},\n+\t{\"%0.100f\", 1.0, \"1.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"},\n+\t{\"%0.100f\", -1.0, \"-1.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"},\n+\n+\t// Zero padding floats used to put the minus sign in the middle.\n+\t{\"%020f\", -1.0, \"-000000000001.000000\"},\n+\t{\"%20f\", -1.0, \"           -1.000000\"},\n+\t{\"%0100f\", -1.0, \"-00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001.000000\"},\n+\n \t// Complex fmt used to leave the plus flag set for future entries in the array\n \t// causing +2+0i and +3+0i instead of 2+0i and 3+0i.\n \t{\"%v\", []complex64{1, 2, 3}, \"[(1+0i) (2+0i) (3+0i)]\"},\n@@ -503,7 +518,7 @@ var fmttests = []struct {\n }\n \n func TestSprintf(t *testing.T) {\n-\tfor _, tt := range fmttests {\n+\tfor _, tt := range fmtTests {\n \t\ts := Sprintf(tt.fmt, tt.val)\n \t\tif i := strings.Index(tt.out, \"PTR\"); i >= 0 {\n \t\t\tpattern := \"PTR\"\n@@ -539,6 +554,55 @@ func TestSprintf(t *testing.T) {\n \t}\n }\n \n+type SE []interface{} // slice of empty; notational compactness.\n+\n+var reorderTests = []struct {\n+\tfmt string\n+\tval SE\n+\tout string\n+}{\n+\t{\"%[1]d\", SE{1}, \"1\"},\n+\t{\"%[2]d\", SE{2, 1}, \"1\"},\n+\t{\"%[2]d %[1]d\", SE{1, 2}, \"2 1\"},\n+\t{\"%[2]*[1]d\", SE{2, 5}, \"    2\"},\n+\t{\"%6.2f\", SE{12.0}, \" 12.00\"}, // Explicit version of next line.\n+\t{\"%[3]*.[2]*[1]f\", SE{12.0, 2, 6}, \" 12.00\"},\n+\t{\"%[1]*.[2]*[3]f\", SE{6, 2, 12.0}, \" 12.00\"},\n+\t{\"%10f\", SE{12.0}, \" 12.000000\"},\n+\t{\"%[1]*[3]f\", SE{10, 99, 12.0}, \" 12.000000\"},\n+\t{\"%.6f\", SE{12.0}, \"12.000000\"}, // Explicit version of next line.\n+\t{\"%.[1]*[3]f\", SE{6, 99, 12.0}, \"12.000000\"},\n+\t{\"%6.f\", SE{12.0}, \"    12\"}, //  // Explicit version of next line; empty precision means zero.\n+\t{\"%[1]*.[3]f\", SE{6, 3, 12.0}, \"    12\"},\n+\t// An actual use! Print the same arguments twice.\n+\t{\"%d %d %d %#[1]o %#o %#o\", SE{11, 12, 13}, \"11 12 13 013 014 015\"},\n+\n+\t// Erroneous cases.\n+\t{\"%[d\", SE{2, 1}, \"%!d(BADINDEX)\"},\n+\t{\"%]d\", SE{2, 1}, \"%!](int=2)d%!(EXTRA int=1)\"},\n+\t{\"%[]d\", SE{2, 1}, \"%!d(BADINDEX)\"},\n+\t{\"%[-3]d\", SE{2, 1}, \"%!d(BADINDEX)\"},\n+\t{\"%[99]d\", SE{2, 1}, \"%!d(BADINDEX)\"},\n+\t{\"%[3]\", SE{2, 1}, \"%!(NOVERB)\"},\n+\t{\"%[1].2d\", SE{5, 6}, \"%!d(BADINDEX)\"},\n+\t{\"%[1]2d\", SE{2, 1}, \"%!d(BADINDEX)\"},\n+\t{\"%3.[2]d\", SE{7}, \"%!d(BADINDEX)\"},\n+\t{\"%.[2]d\", SE{7}, \"%!d(BADINDEX)\"},\n+\t{\"%d %d %d %#[1]o %#o %#o %#o\", SE{11, 12, 13}, \"11 12 13 013 014 015 %!o(MISSING)\"},\n+\t{\"%[5]d %[2]d %d\", SE{1, 2, 3}, \"%!d(BADINDEX) 2 3\"},\n+\t{\"%d %[3]d %d\", SE{1, 2}, \"1 %!d(BADINDEX) 2\"}, // Erroneous index does not affect sequence.\n+}\n+\n+func TestReorder(t *testing.T) {\n+\tfor _, tt := range reorderTests {\n+\t\ts := Sprintf(tt.fmt, tt.val...)\n+\t\tif s != tt.out {\n+\t\t\tt.Errorf(\"Sprintf(%q, %v) = <%s> want <%s>\", tt.fmt, tt.val, s, tt.out)\n+\t\t} else {\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkSprintfEmpty(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tSprintf(\"\")\n@@ -607,6 +671,9 @@ var mallocTest = []struct {\n var _ bytes.Buffer\n \n func TestCountMallocs(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping malloc count in short mode\")\n+\t}\n \tif runtime.GOMAXPROCS(0) > 1 {\n \t\tt.Skip(\"skipping; GOMAXPROCS>1\")\n \t}\n@@ -832,16 +899,16 @@ var panictests = []struct {\n }{\n \t// String\n \t{\"%s\", (*Panic)(nil), \"<nil>\"}, // nil pointer special case\n-\t{\"%s\", Panic{io.ErrUnexpectedEOF}, \"%s(PANIC=unexpected EOF)\"},\n-\t{\"%s\", Panic{3}, \"%s(PANIC=3)\"},\n+\t{\"%s\", Panic{io.ErrUnexpectedEOF}, \"%!s(PANIC=unexpected EOF)\"},\n+\t{\"%s\", Panic{3}, \"%!s(PANIC=3)\"},\n \t// GoString\n \t{\"%#v\", (*Panic)(nil), \"<nil>\"}, // nil pointer special case\n-\t{\"%#v\", Panic{io.ErrUnexpectedEOF}, \"%v(PANIC=unexpected EOF)\"},\n-\t{\"%#v\", Panic{3}, \"%v(PANIC=3)\"},\n+\t{\"%#v\", Panic{io.ErrUnexpectedEOF}, \"%!v(PANIC=unexpected EOF)\"},\n+\t{\"%#v\", Panic{3}, \"%!v(PANIC=3)\"},\n \t// Format\n \t{\"%s\", (*PanicF)(nil), \"<nil>\"}, // nil pointer special case\n-\t{\"%s\", PanicF{io.ErrUnexpectedEOF}, \"%s(PANIC=unexpected EOF)\"},\n-\t{\"%s\", PanicF{3}, \"%s(PANIC=3)\"},\n+\t{\"%s\", PanicF{io.ErrUnexpectedEOF}, \"%!s(PANIC=unexpected EOF)\"},\n+\t{\"%s\", PanicF{3}, \"%!s(PANIC=3)\"},\n }\n \n func TestPanics(t *testing.T) {\n@@ -861,7 +928,7 @@ type Recur struct {\n \tfailed *bool\n }\n \n-func (r Recur) String() string {\n+func (r *Recur) String() string {\n \tif recurCount++; recurCount > 10 {\n \t\t*r.failed = true\n \t\treturn \"FAIL\"\n@@ -874,13 +941,13 @@ func (r Recur) String() string {\n \n func TestBadVerbRecursion(t *testing.T) {\n \tfailed := false\n-\tr := Recur{3, &failed}\n+\tr := &Recur{3, &failed}\n \tSprintf(\"recur@%p value: %d\\n\", &r, r.i)\n \tif failed {\n \t\tt.Error(\"fail with pointer\")\n \t}\n \tfailed = false\n-\tr = Recur{4, &failed}\n+\tr = &Recur{4, &failed}\n \tSprintf(\"recur@%p, value: %d\\n\", r, r.i)\n \tif failed {\n \t\tt.Error(\"fail with value\")"}, {"sha": "2e2b0716edc822e4486415580c673da6280311d2", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -24,8 +24,6 @@ const (\n var padZeroBytes = make([]byte, nByte)\n var padSpaceBytes = make([]byte, nByte)\n \n-var newline = []byte{'\\n'}\n-\n func init() {\n \tfor i := 0; i < nByte; i++ {\n \t\tpadZeroBytes[i] = '0'\n@@ -162,6 +160,11 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {\n \t}\n \n \tvar buf []byte = f.intbuf[0:]\n+\tif f.widPresent && f.wid > nByte {\n+\t\t// We're going to need a bigger boat.\n+\t\tbuf = make([]byte, f.wid)\n+\t}\n+\n \tnegative := signedness == signed && a < 0\n \tif negative {\n \t\ta = -a\n@@ -184,7 +187,7 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {\n \t// a is made into unsigned ua.  we could make things\n \t// marginally faster by splitting the 32-bit case out into a separate\n \t// block but it's not worth the duplication, so ua has 64 bits.\n-\ti := len(f.intbuf)\n+\ti := len(buf)\n \tua := uint64(a)\n \tfor ua >= base {\n \t\ti--\n@@ -193,7 +196,7 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {\n \t}\n \ti--\n \tbuf[i] = digits[ua]\n-\tfor i > 0 && prec > nByte-i {\n+\tfor i > 0 && prec > len(buf)-i {\n \t\ti--\n \t\tbuf[i] = '0'\n \t}\n@@ -356,6 +359,14 @@ func (f *fmt) formatFloat(v float64, verb byte, prec, n int) {\n \t// The formatted number starts at slice[1].\n \tswitch slice[1] {\n \tcase '-', '+':\n+\t\t// If we're zero padding, want the sign before the leading zeros.\n+\t\t// Achieve this by writing the sign out and padding the postive number.\n+\t\tif f.zero && f.widPresent && f.wid > len(slice) {\n+\t\t\tf.buf.WriteByte(slice[1])\n+\t\t\tf.wid--\n+\t\t\tf.pad(slice[2:])\n+\t\t\treturn\n+\t\t}\n \t\t// We're set; drop the leading space.\n \t\tslice = slice[1:]\n \tdefault:\n@@ -418,6 +429,8 @@ func (f *fmt) fmt_c64(v complex64, verb rune) {\n \toldPlus := f.plus\n \tfor i := 0; ; i++ {\n \t\tswitch verb {\n+\t\tcase 'b':\n+\t\t\tf.fmt_fb32(r)\n \t\tcase 'e':\n \t\t\tf.fmt_e32(r)\n \t\tcase 'E':\n@@ -446,6 +459,8 @@ func (f *fmt) fmt_c128(v complex128, verb rune) {\n \toldPlus := f.plus\n \tfor i := 0; ; i++ {\n \t\tswitch verb {\n+\t\tcase 'b':\n+\t\t\tf.fmt_fb64(r)\n \t\tcase 'e':\n \t\t\tf.fmt_e64(r)\n \t\tcase 'E':"}, {"sha": "1ea816d6d5f26c37a2c360e40845f298d497ed6e", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 178, "deletions": 104, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5", "patch": "@@ -16,19 +16,21 @@ import (\n // Some constants in the form of bytes, to avoid string overhead.\n // Needlessly fastidious, I suppose.\n var (\n-\tcommaSpaceBytes = []byte(\", \")\n-\tnilAngleBytes   = []byte(\"<nil>\")\n-\tnilParenBytes   = []byte(\"(nil)\")\n-\tnilBytes        = []byte(\"nil\")\n-\tmapBytes        = []byte(\"map[\")\n-\tmissingBytes    = []byte(\"(MISSING)\")\n-\tpanicBytes      = []byte(\"(PANIC=\")\n-\textraBytes      = []byte(\"%!(EXTRA \")\n-\tirparenBytes    = []byte(\"i)\")\n-\tbytesBytes      = []byte(\"[]byte{\")\n-\tbadWidthBytes   = []byte(\"%!(BADWIDTH)\")\n-\tbadPrecBytes    = []byte(\"%!(BADPREC)\")\n-\tnoVerbBytes     = []byte(\"%!(NOVERB)\")\n+\tcommaSpaceBytes  = []byte(\", \")\n+\tnilAngleBytes    = []byte(\"<nil>\")\n+\tnilParenBytes    = []byte(\"(nil)\")\n+\tnilBytes         = []byte(\"nil\")\n+\tmapBytes         = []byte(\"map[\")\n+\tpercentBangBytes = []byte(\"%!\")\n+\tmissingBytes     = []byte(\"(MISSING)\")\n+\tbadIndexBytes    = []byte(\"(BADINDEX)\")\n+\tpanicBytes       = []byte(\"(PANIC=\")\n+\textraBytes       = []byte(\"%!(EXTRA \")\n+\tirparenBytes     = []byte(\"i)\")\n+\tbytesBytes       = []byte(\"[]byte{\")\n+\tbadWidthBytes    = []byte(\"%!(BADWIDTH)\")\n+\tbadPrecBytes     = []byte(\"%!(BADPREC)\")\n+\tnoVerbBytes      = []byte(\"%!(NOVERB)\")\n )\n \n // State represents the printer state passed to custom formatters.\n@@ -42,7 +44,7 @@ type State interface {\n \t// Precision returns the value of the precision option and whether it has been set.\n \tPrecision() (prec int, ok bool)\n \n-\t// Flag returns whether the flag c, a character, has been set.\n+\t// Flag reports whether the flag c, a character, has been set.\n \tFlag(c int) bool\n }\n \n@@ -109,13 +111,17 @@ type pp struct {\n \tpanicking bool\n \terroring  bool // printing an error condition\n \tbuf       buffer\n-\t// field holds the current item, as an interface{}.\n-\tfield interface{}\n+\t// arg holds the current item, as an interface{}.\n+\targ interface{}\n \t// value holds the current item, as a reflect.Value, and will be\n \t// the zero Value if the item has not been reflected.\n-\tvalue   reflect.Value\n-\truneBuf [utf8.UTFMax]byte\n-\tfmt     fmt\n+\tvalue reflect.Value\n+\t// reordered records whether the format string used argument reordering.\n+\treordered bool\n+\t// goodArgNum records whether the most recent reordering directive was valid.\n+\tgoodArgNum bool\n+\truneBuf    [utf8.UTFMax]byte\n+\tfmt        fmt\n }\n \n // A cache holds a set of reusable objects.\n@@ -170,7 +176,7 @@ func (p *pp) free() {\n \t\treturn\n \t}\n \tp.buf = p.buf[:0]\n-\tp.field = nil\n+\tp.arg = nil\n \tp.value = reflect.Value{}\n \tppFree.put(p)\n }\n@@ -212,9 +218,9 @@ func (p *pp) Write(b []byte) (ret int, err error) {\n func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrintf(format, a)\n-\tn64, err := w.Write(p.buf)\n+\tn, err = w.Write(p.buf)\n \tp.free()\n-\treturn int(n64), err\n+\treturn\n }\n \n // Printf formats according to a format specifier and writes to standard output.\n@@ -246,9 +252,9 @@ func Errorf(format string, a ...interface{}) error {\n func Fprint(w io.Writer, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrint(a, false, false)\n-\tn64, err := w.Write(p.buf)\n+\tn, err = w.Write(p.buf)\n \tp.free()\n-\treturn int(n64), err\n+\treturn\n }\n \n // Print formats using the default formats for its operands and writes to standard output.\n@@ -278,9 +284,9 @@ func Sprint(a ...interface{}) string {\n func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrint(a, true, true)\n-\tn64, err := w.Write(p.buf)\n+\tn, err = w.Write(p.buf)\n \tp.free()\n-\treturn int(n64), err\n+\treturn\n }\n \n // Println formats using the default formats for its operands and writes to standard output.\n@@ -300,8 +306,8 @@ func Sprintln(a ...interface{}) string {\n \treturn s\n }\n \n-// getField gets the i'th arg of the struct value.\n-// If the arg itself is an interface, return a value for\n+// getField gets the i'th field of the struct value.\n+// If the field is itself is an interface, return a value for\n // the thing inside the interface, not the interface itself.\n func getField(v reflect.Value, i int) reflect.Value {\n \tval := v.Field(i)\n@@ -340,10 +346,10 @@ func (p *pp) badVerb(verb rune) {\n \tp.add(verb)\n \tp.add('(')\n \tswitch {\n-\tcase p.field != nil:\n-\t\tp.buf.WriteString(reflect.TypeOf(p.field).String())\n+\tcase p.arg != nil:\n+\t\tp.buf.WriteString(reflect.TypeOf(p.arg).String())\n \t\tp.add('=')\n-\t\tp.printField(p.field, 'v', false, false, 0)\n+\t\tp.printArg(p.arg, 'v', false, false, 0)\n \tcase p.value.IsValid():\n \t\tp.buf.WriteString(p.value.Type().String())\n \t\tp.add('=')\n@@ -505,7 +511,7 @@ func (p *pp) fmtFloat64(v float64, verb rune) {\n \n func (p *pp) fmtComplex64(v complex64, verb rune) {\n \tswitch verb {\n-\tcase 'e', 'E', 'f', 'F', 'g', 'G':\n+\tcase 'b', 'e', 'E', 'f', 'F', 'g', 'G':\n \t\tp.fmt.fmt_c64(v, verb)\n \tcase 'v':\n \t\tp.fmt.fmt_c64(v, 'g')\n@@ -516,7 +522,7 @@ func (p *pp) fmtComplex64(v complex64, verb rune) {\n \n func (p *pp) fmtComplex128(v complex128, verb rune) {\n \tswitch verb {\n-\tcase 'e', 'E', 'f', 'F', 'g', 'G':\n+\tcase 'b', 'e', 'E', 'f', 'F', 'g', 'G':\n \t\tp.fmt.fmt_c128(v, verb)\n \tcase 'v':\n \t\tp.fmt.fmt_c128(v, 'g')\n@@ -566,7 +572,7 @@ func (p *pp) fmtBytes(v []byte, verb rune, goSyntax bool, typ reflect.Type, dept\n \t\t\t\t\tp.buf.WriteByte(' ')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printField(c, 'v', p.fmt.plus, goSyntax, depth+1)\n+\t\t\tp.printArg(c, 'v', p.fmt.plus, goSyntax, depth+1)\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteByte('}')\n@@ -635,31 +641,29 @@ func (p *pp) fmtPointer(value reflect.Value, verb rune, goSyntax bool) {\n \n var (\n \tintBits     = reflect.TypeOf(0).Bits()\n-\tfloatBits   = reflect.TypeOf(0.0).Bits()\n-\tcomplexBits = reflect.TypeOf(1i).Bits()\n \tuintptrBits = reflect.TypeOf(uintptr(0)).Bits()\n )\n \n-func (p *pp) catchPanic(field interface{}, verb rune) {\n+func (p *pp) catchPanic(arg interface{}, verb rune) {\n \tif err := recover(); err != nil {\n \t\t// If it's a nil pointer, just say \"<nil>\". The likeliest causes are a\n \t\t// Stringer that fails to guard against nil or a nil pointer for a\n \t\t// value receiver, and in either case, \"<nil>\" is a nice result.\n-\t\tif v := reflect.ValueOf(field); v.Kind() == reflect.Ptr && v.IsNil() {\n+\t\tif v := reflect.ValueOf(arg); v.Kind() == reflect.Ptr && v.IsNil() {\n \t\t\tp.buf.Write(nilAngleBytes)\n \t\t\treturn\n \t\t}\n \t\t// Otherwise print a concise panic message. Most of the time the panic\n \t\t// value will print itself nicely.\n \t\tif p.panicking {\n-\t\t\t// Nested panics; the recursion in printField cannot succeed.\n+\t\t\t// Nested panics; the recursion in printArg cannot succeed.\n \t\t\tpanic(err)\n \t\t}\n-\t\tp.buf.WriteByte('%')\n+\t\tp.buf.Write(percentBangBytes)\n \t\tp.add(verb)\n \t\tp.buf.Write(panicBytes)\n \t\tp.panicking = true\n-\t\tp.printField(err, 'v', false, false, 0)\n+\t\tp.printArg(err, 'v', false, false, 0)\n \t\tp.panicking = false\n \t\tp.buf.WriteByte(')')\n \t}\n@@ -670,10 +674,10 @@ func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString\n \t\treturn\n \t}\n \t// Is it a Formatter?\n-\tif formatter, ok := p.field.(Formatter); ok {\n+\tif formatter, ok := p.arg.(Formatter); ok {\n \t\thandled = true\n \t\twasString = false\n-\t\tdefer p.catchPanic(p.field, verb)\n+\t\tdefer p.catchPanic(p.arg, verb)\n \t\tformatter.Format(p, verb)\n \t\treturn\n \t}\n@@ -682,13 +686,13 @@ func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString\n \t\tp.fmt.plus = false\n \t}\n \n-\t// If we're doing Go syntax and the field knows how to supply it, take care of it now.\n+\t// If we're doing Go syntax and the argument knows how to supply it, take care of it now.\n \tif goSyntax {\n \t\tp.fmt.sharp = false\n-\t\tif stringer, ok := p.field.(GoStringer); ok {\n+\t\tif stringer, ok := p.arg.(GoStringer); ok {\n \t\t\twasString = false\n \t\t\thandled = true\n-\t\t\tdefer p.catchPanic(p.field, verb)\n+\t\t\tdefer p.catchPanic(p.arg, verb)\n \t\t\t// Print the result of GoString unadorned.\n \t\t\tp.fmtString(stringer.GoString(), 's', false)\n \t\t\treturn\n@@ -703,19 +707,19 @@ func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString\n \t\t\t// The duplication in the bodies is necessary:\n \t\t\t// setting wasString and handled, and deferring catchPanic,\n \t\t\t// must happen before calling the method.\n-\t\t\tswitch v := p.field.(type) {\n+\t\t\tswitch v := p.arg.(type) {\n \t\t\tcase error:\n \t\t\t\twasString = false\n \t\t\t\thandled = true\n-\t\t\t\tdefer p.catchPanic(p.field, verb)\n-\t\t\t\tp.printField(v.Error(), verb, plus, false, depth)\n+\t\t\t\tdefer p.catchPanic(p.arg, verb)\n+\t\t\t\tp.printArg(v.Error(), verb, plus, false, depth)\n \t\t\t\treturn\n \n \t\t\tcase Stringer:\n \t\t\t\twasString = false\n \t\t\t\thandled = true\n-\t\t\t\tdefer p.catchPanic(p.field, verb)\n-\t\t\t\tp.printField(v.String(), verb, plus, false, depth)\n+\t\t\t\tdefer p.catchPanic(p.arg, verb)\n+\t\t\t\tp.printArg(v.String(), verb, plus, false, depth)\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n@@ -724,11 +728,11 @@ func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString\n \treturn\n }\n \n-func (p *pp) printField(field interface{}, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n-\tp.field = field\n+func (p *pp) printArg(arg interface{}, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n+\tp.arg = arg\n \tp.value = reflect.Value{}\n \n-\tif field == nil {\n+\tif arg == nil {\n \t\tif verb == 'T' || verb == 'v' {\n \t\t\tp.fmt.pad(nilAngleBytes)\n \t\t} else {\n@@ -741,10 +745,10 @@ func (p *pp) printField(field interface{}, verb rune, plus, goSyntax bool, depth\n \t// %T (the value's type) and %p (its address) are special; we always do them first.\n \tswitch verb {\n \tcase 'T':\n-\t\tp.printField(reflect.TypeOf(field).String(), 's', false, false, 0)\n+\t\tp.printArg(reflect.TypeOf(arg).String(), 's', false, false, 0)\n \t\treturn false\n \tcase 'p':\n-\t\tp.fmtPointer(reflect.ValueOf(field), verb, goSyntax)\n+\t\tp.fmtPointer(reflect.ValueOf(arg), verb, goSyntax)\n \t\treturn false\n \t}\n \n@@ -762,15 +766,15 @@ func (p *pp) printField(field interface{}, verb rune, plus, goSyntax bool, depth\n \t}\n \n \t// Some types can be done without reflection.\n-\tswitch f := field.(type) {\n+\tswitch f := arg.(type) {\n \tcase bool:\n \t\tp.fmtBool(f, verb)\n \tcase float32:\n \t\tp.fmtFloat32(f, verb)\n \tcase float64:\n \t\tp.fmtFloat64(f, verb)\n \tcase complex64:\n-\t\tp.fmtComplex64(complex64(f), verb)\n+\t\tp.fmtComplex64(f, verb)\n \tcase complex128:\n \t\tp.fmtComplex128(f, verb)\n \tcase int:\n@@ -806,17 +810,17 @@ func (p *pp) printField(field interface{}, verb rune, plus, goSyntax bool, depth\n \t\tp.fmt.plus = oldPlus\n \t\tp.fmt.sharp = oldSharp\n \t\t// If the type is not simple, it might have methods.\n-\t\tif wasString, handled := p.handleMethods(verb, plus, goSyntax, depth); handled {\n-\t\t\treturn wasString\n+\t\tif isString, handled := p.handleMethods(verb, plus, goSyntax, depth); handled {\n+\t\t\treturn isString\n \t\t}\n \t\t// Need to use reflection\n-\t\treturn p.printReflectValue(reflect.ValueOf(field), verb, plus, goSyntax, depth)\n+\t\treturn p.printReflectValue(reflect.ValueOf(arg), verb, plus, goSyntax, depth)\n \t}\n-\tp.field = nil\n+\tp.arg = nil\n \treturn\n }\n \n-// printValue is like printField but starts with a reflect value, not an interface{} value.\n+// printValue is like printArg but starts with a reflect value, not an interface{} value.\n func (p *pp) printValue(value reflect.Value, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n \tif !value.IsValid() {\n \t\tif verb == 'T' || verb == 'v' {\n@@ -831,27 +835,27 @@ func (p *pp) printValue(value reflect.Value, verb rune, plus, goSyntax bool, dep\n \t// %T (the value's type) and %p (its address) are special; we always do them first.\n \tswitch verb {\n \tcase 'T':\n-\t\tp.printField(value.Type().String(), 's', false, false, 0)\n+\t\tp.printArg(value.Type().String(), 's', false, false, 0)\n \t\treturn false\n \tcase 'p':\n \t\tp.fmtPointer(value, verb, goSyntax)\n \t\treturn false\n \t}\n \n \t// Handle values with special methods.\n-\t// Call always, even when field == nil, because handleMethods clears p.fmt.plus for us.\n-\tp.field = nil // Make sure it's cleared, for safety.\n+\t// Call always, even when arg == nil, because handleMethods clears p.fmt.plus for us.\n+\tp.arg = nil // Make sure it's cleared, for safety.\n \tif value.CanInterface() {\n-\t\tp.field = value.Interface()\n+\t\tp.arg = value.Interface()\n \t}\n-\tif wasString, handled := p.handleMethods(verb, plus, goSyntax, depth); handled {\n-\t\treturn wasString\n+\tif isString, handled := p.handleMethods(verb, plus, goSyntax, depth); handled {\n+\t\treturn isString\n \t}\n \n \treturn p.printReflectValue(value, verb, plus, goSyntax, depth)\n }\n \n-// printReflectValue is the fallback for both printField and printValue.\n+// printReflectValue is the fallback for both printArg and printValue.\n // It uses reflect to print the value.\n func (p *pp) printReflectValue(value reflect.Value, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n \toldValue := p.value\n@@ -863,18 +867,18 @@ BigSwitch:\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\tp.fmtInt64(f.Int(), verb)\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\tp.fmtUint64(uint64(f.Uint()), verb, goSyntax)\n+\t\tp.fmtUint64(f.Uint(), verb, goSyntax)\n \tcase reflect.Float32, reflect.Float64:\n \t\tif f.Type().Size() == 4 {\n \t\t\tp.fmtFloat32(float32(f.Float()), verb)\n \t\t} else {\n-\t\t\tp.fmtFloat64(float64(f.Float()), verb)\n+\t\t\tp.fmtFloat64(f.Float(), verb)\n \t\t}\n \tcase reflect.Complex64, reflect.Complex128:\n \t\tif f.Type().Size() == 8 {\n \t\t\tp.fmtComplex64(complex64(f.Complex()), verb)\n \t\t} else {\n-\t\t\tp.fmtComplex128(complex128(f.Complex()), verb)\n+\t\t\tp.fmtComplex128(f.Complex(), verb)\n \t\t}\n \tcase reflect.String:\n \t\tp.fmtString(f.String(), verb, goSyntax)\n@@ -1015,20 +1019,59 @@ BigSwitch:\n \treturn wasString\n }\n \n-// intFromArg gets the fieldnumth element of a. On return, isInt reports whether the argument has type int.\n-func intFromArg(a []interface{}, end, i, fieldnum int) (num int, isInt bool, newi, newfieldnum int) {\n-\tnewi, newfieldnum = end, fieldnum\n-\tif i < end && fieldnum < len(a) {\n-\t\tnum, isInt = a[fieldnum].(int)\n-\t\tnewi, newfieldnum = i+1, fieldnum+1\n+// intFromArg gets the argNumth element of a. On return, isInt reports whether the argument has type int.\n+func intFromArg(a []interface{}, argNum int) (num int, isInt bool, newArgNum int) {\n+\tnewArgNum = argNum\n+\tif argNum < len(a) {\n+\t\tnum, isInt = a[argNum].(int)\n+\t\tnewArgNum = argNum + 1\n \t}\n \treturn\n }\n \n+// parseArgNumber returns the value of the bracketed number, minus 1\n+// (explicit argument numbers are one-indexed but we want zero-indexed).\n+// The opening bracket is known to be present at format[0].\n+// The returned values are the index, the number of bytes to consume\n+// up to the closing paren, if present, and whether the number parsed\n+// ok. The bytes to consume will be 1 if no closing paren is present.\n+func parseArgNumber(format string) (index int, wid int, ok bool) {\n+\t// Find closing bracket.\n+\tfor i := 1; i < len(format); i++ {\n+\t\tif format[i] == ']' {\n+\t\t\twidth, ok, newi := parsenum(format, 1, i)\n+\t\t\tif !ok || newi != i {\n+\t\t\t\treturn 0, i + 1, false\n+\t\t\t}\n+\t\t\treturn width - 1, i + 1, true // arg numbers are one-indexed and skip paren.\n+\t\t}\n+\t}\n+\treturn 0, 1, false\n+}\n+\n+// argNumber returns the next argument to evaluate, which is either the value of the passed-in\n+// argNum or the value of the bracketed integer that begins format[i:]. It also returns\n+// the new value of i, that is, the index of the next byte of the format to process.\n+func (p *pp) argNumber(argNum int, format string, i int, numArgs int) (newArgNum, newi int, found bool) {\n+\tif len(format) <= i || format[i] != '[' {\n+\t\treturn argNum, i, false\n+\t}\n+\tp.reordered = true\n+\tindex, wid, ok := parseArgNumber(format[i:])\n+\tif ok && 0 <= index && index < numArgs {\n+\t\treturn index, i + wid, true\n+\t}\n+\tp.goodArgNum = false\n+\treturn argNum, i + wid, true\n+}\n+\n func (p *pp) doPrintf(format string, a []interface{}) {\n \tend := len(format)\n-\tfieldnum := 0 // we process one field per non-trivial format\n+\targNum := 0         // we process one argument per non-trivial format\n+\tafterIndex := false // previous item in format was an index like [3].\n+\tp.reordered = false\n \tfor i := 0; i < end; {\n+\t\tp.goodArgNum = true\n \t\tlasti := i\n \t\tfor i < end && format[i] != '%' {\n \t\t\ti++\n@@ -1043,7 +1086,8 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \n \t\t// Process one verb\n \t\ti++\n-\t\t// flags and widths\n+\n+\t\t// Do we have flags?\n \t\tp.fmt.clearflags()\n \tF:\n \t\tfor ; i < end; i++ {\n@@ -1062,30 +1106,52 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \t\t\t\tbreak F\n \t\t\t}\n \t\t}\n-\t\t// do we have width?\n+\n+\t\t// Do we have an explicit argument index?\n+\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n+\n+\t\t// Do we have width?\n \t\tif i < end && format[i] == '*' {\n-\t\t\tp.fmt.wid, p.fmt.widPresent, i, fieldnum = intFromArg(a, end, i, fieldnum)\n+\t\t\ti++\n+\t\t\tp.fmt.wid, p.fmt.widPresent, argNum = intFromArg(a, argNum)\n \t\t\tif !p.fmt.widPresent {\n \t\t\t\tp.buf.Write(badWidthBytes)\n \t\t\t}\n+\t\t\tafterIndex = false\n \t\t} else {\n \t\t\tp.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end)\n+\t\t\tif afterIndex && p.fmt.widPresent { // \"%[3]2d\"\n+\t\t\t\tp.goodArgNum = false\n+\t\t\t}\n \t\t}\n-\t\t// do we have precision?\n+\n+\t\t// Do we have precision?\n \t\tif i+1 < end && format[i] == '.' {\n-\t\t\tif format[i+1] == '*' {\n-\t\t\t\tp.fmt.prec, p.fmt.precPresent, i, fieldnum = intFromArg(a, end, i+1, fieldnum)\n+\t\t\ti++\n+\t\t\tif afterIndex { // \"%[3].2d\"\n+\t\t\t\tp.goodArgNum = false\n+\t\t\t}\n+\t\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n+\t\t\tif format[i] == '*' {\n+\t\t\t\ti++\n+\t\t\t\tp.fmt.prec, p.fmt.precPresent, argNum = intFromArg(a, argNum)\n \t\t\t\tif !p.fmt.precPresent {\n \t\t\t\t\tp.buf.Write(badPrecBytes)\n \t\t\t\t}\n+\t\t\t\tafterIndex = false\n \t\t\t} else {\n-\t\t\t\tp.fmt.prec, p.fmt.precPresent, i = parsenum(format, i+1, end)\n+\t\t\t\tp.fmt.prec, p.fmt.precPresent, i = parsenum(format, i, end)\n \t\t\t\tif !p.fmt.precPresent {\n \t\t\t\t\tp.fmt.prec = 0\n \t\t\t\t\tp.fmt.precPresent = true\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\n+\t\tif !afterIndex {\n+\t\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n+\t\t}\n+\n \t\tif i >= end {\n \t\t\tp.buf.Write(noVerbBytes)\n \t\t\tcontinue\n@@ -1097,30 +1163,38 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \t\t\tp.buf.WriteByte('%') // We ignore width and prec.\n \t\t\tcontinue\n \t\t}\n-\t\tif fieldnum >= len(a) { // out of operands\n-\t\t\tp.buf.WriteByte('%')\n+\t\tif !p.goodArgNum {\n+\t\t\tp.buf.Write(percentBangBytes)\n+\t\t\tp.add(c)\n+\t\t\tp.buf.Write(badIndexBytes)\n+\t\t\tcontinue\n+\t\t} else if argNum >= len(a) { // out of operands\n+\t\t\tp.buf.Write(percentBangBytes)\n \t\t\tp.add(c)\n \t\t\tp.buf.Write(missingBytes)\n \t\t\tcontinue\n \t\t}\n-\t\tfield := a[fieldnum]\n-\t\tfieldnum++\n+\t\targ := a[argNum]\n+\t\targNum++\n \n \t\tgoSyntax := c == 'v' && p.fmt.sharp\n \t\tplus := c == 'v' && p.fmt.plus\n-\t\tp.printField(field, c, plus, goSyntax, 0)\n+\t\tp.printArg(arg, c, plus, goSyntax, 0)\n \t}\n \n-\tif fieldnum < len(a) {\n+\t// Check for extra arguments unless the call accessed the arguments\n+\t// out of order, in which case it's too expensive to detect if they've all\n+\t// been used and arguably OK if they're not.\n+\tif !p.reordered && argNum < len(a) {\n \t\tp.buf.Write(extraBytes)\n-\t\tfor ; fieldnum < len(a); fieldnum++ {\n-\t\t\tfield := a[fieldnum]\n-\t\t\tif field != nil {\n-\t\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n+\t\tfor ; argNum < len(a); argNum++ {\n+\t\t\targ := a[argNum]\n+\t\t\tif arg != nil {\n+\t\t\t\tp.buf.WriteString(reflect.TypeOf(arg).String())\n \t\t\t\tp.buf.WriteByte('=')\n \t\t\t}\n-\t\t\tp.printField(field, 'v', false, false, 0)\n-\t\t\tif fieldnum+1 < len(a) {\n+\t\t\tp.printArg(arg, 'v', false, false, 0)\n+\t\t\tif argNum+1 < len(a) {\n \t\t\t\tp.buf.Write(commaSpaceBytes)\n \t\t\t}\n \t\t}\n@@ -1130,17 +1204,17 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \n func (p *pp) doPrint(a []interface{}, addspace, addnewline bool) {\n \tprevString := false\n-\tfor fieldnum := 0; fieldnum < len(a); fieldnum++ {\n+\tfor argNum := 0; argNum < len(a); argNum++ {\n \t\tp.fmt.clearflags()\n \t\t// always add spaces if we're doing Println\n-\t\tfield := a[fieldnum]\n-\t\tif fieldnum > 0 {\n-\t\t\tisString := field != nil && reflect.TypeOf(field).Kind() == reflect.String\n+\t\targ := a[argNum]\n+\t\tif argNum > 0 {\n+\t\t\tisString := arg != nil && reflect.TypeOf(arg).Kind() == reflect.String\n \t\t\tif addspace || !isString && !prevString {\n \t\t\t\tp.buf.WriteByte(' ')\n \t\t\t}\n \t\t}\n-\t\tprevString = p.printField(field, 'v', false, false, 0)\n+\t\tprevString = p.printArg(arg, 'v', false, false, 0)\n \t}\n \tif addnewline {\n \t\tp.buf.WriteByte('\\n')"}, {"sha": "5b1be5891b8fd9b47cec2247f76dda4f62b89be7", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "d903f0c3ff74cfcf254729439b2293ad1ba3cf1e", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "6e635cd0166962670fe7317674a67c53a4d3a596", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "1fb4867dd28439382adf616714683ff489df738f", "filename": "libgo/go/go/ast/commentmap.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "fc3eeb4a1db73d5c9c5b42f0688df43cd9746596", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "d2770d16cf862b8346832ee985a3bfb2624e051b", "filename": "libgo/go/go/ast/import.go", "status": "modified", "additions": 80, "deletions": 18, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fimport.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "fedffb3f22f8d95395cace9b6455832e4d77d0c4", "filename": "libgo/go/go/ast/walk.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "50d2fb4aeba4bc6536ab7004d5a1f6a36df75e88", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 189, "deletions": 96, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "fca8d4bdb27d42da2cdc380d52b129439fd56a21", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 86, "deletions": 19, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "dd162c7db7ff11057ff9a7daa94a16ca4a4803eb", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "b2f04ea45cf9434b70421edb8f4da713c854627e", "filename": "libgo/go/go/build/doc.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "3be2928f5253b8eeecd6eeb4807e156ce19b0f6b", "filename": "libgo/go/go/build/syslist_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "5c8c43e0c1aa6ee77469512c31460d6ace89a0de", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "ad8ba5378f3f13f7db193b5416bebb4439d0c18c", "filename": "libgo/go/go/doc/doc_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "2358ed38902f36f9f4758f27b788a6bc08e6eeda", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "e154ea8bfc5be8a79d16b6e3d99269b36978e37e", "filename": "libgo/go/go/doc/example_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "ed82c47cd99385a634ec3a60fcf8e41fa4b9b8c8", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "d1ad86c74166edf238ec798f3140373eb4b4a277", "filename": "libgo/go/go/doc/synopsis.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "7e680b80b4c565503c75f49ecdcafcee3e52fcf7", "filename": "libgo/go/go/doc/testdata/a.0.golden", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.0.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "7e680b80b4c565503c75f49ecdcafcee3e52fcf7", "filename": "libgo/go/go/doc/testdata/a.1.golden", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.1.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "7e680b80b4c565503c75f49ecdcafcee3e52fcf7", "filename": "libgo/go/go/doc/testdata/a.2.golden", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.2.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "5804859501edc8b84781d97d4a6ab6400b79cd24", "filename": "libgo/go/go/doc/testdata/bugpara.0.golden", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.0.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "5804859501edc8b84781d97d4a6ab6400b79cd24", "filename": "libgo/go/go/doc/testdata/bugpara.1.golden", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.1.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "5804859501edc8b84781d97d4a6ab6400b79cd24", "filename": "libgo/go/go/doc/testdata/bugpara.2.golden", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.2.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "f5345a797532b36b7bb61995f3d287378620d691", "filename": "libgo/go/go/doc/testdata/bugpara.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbugpara.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "1b07382611660bd28daf1fd32d2ae73e4b9f12bd", "filename": "libgo/go/go/doc/testdata/template.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftemplate.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftemplate.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftemplate.txt?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "f8348f1ac34a493cc0d43d834cc0f215f85fce5a", "filename": "libgo/go/go/doc/testdata/testing.0.golden", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.0.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "282bb1015ad577d11d70e5cf08f53b36e37fa532", "filename": "libgo/go/go/doc/testdata/testing.1.golden", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "f8348f1ac34a493cc0d43d834cc0f215f85fce5a", "filename": "libgo/go/go/doc/testdata/testing.2.golden", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.2.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "93ed494c32b166391532286fdd9067d0be03e8e6", "filename": "libgo/go/go/doc/testdata/testing.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "93f0992477ca380d4520f8f8889abd8eea8f250a", "filename": "libgo/go/go/format/format_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "0f83ca9314362f3d6cd09e86a0931bc0b7dcbb9b", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "c4523318f2614773d54b5b856931f79495a9f333", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "0a34b7e505e9b3277b9872ff0d54bdc0097e3187", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "0ef0c560c4a50d95be87d4c7d2012959c74dd04e", "filename": "libgo/go/go/parser/short_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "583c6c37090b60d2271f1c158dc742bb8bb13523", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "fbe8275b3a577a589f747d3759cc4b8f79084551", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "f4d20fa0f77466cd02c19c4a583bac9d02378b8c", "filename": "libgo/go/go/printer/testdata/expressions.input", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "97bc81dad87e916be2c4e2e1b2b3ebf5ccbeeab8", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "e6f0ae6a6738f7c33e2581c8b51870838aa3177d", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "ef6cfd93c25e0c47d8a1b1c098e5f9a43f7a13be", "filename": "libgo/go/go/token/position_test.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8d138d07f93516afa84a64c6e15fc379454a6580", "filename": "libgo/go/hash/hash.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhash%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhash%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fhash.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "dd5dfa7cd75f22a85fb4fff16a5454f572bfe065", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "b405d4b4a778cc65f29d0a679a91352d618ee360", "filename": "libgo/go/html/escape_test.go", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "e11bff2c5dfa7bf7c4dc20e3b16fde484f1ce82b", "filename": "libgo/go/html/template/clone_test.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "41b1116a661cb0d81022722b3a8553fbbec9576c", "filename": "libgo/go/html/template/content.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "5f3ffe2d3259725fb7b15339782e1b51090be9fe", "filename": "libgo/go/html/template/content_test.go", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "eb47e2be3c79e3d932bf694d6d3d74588a6c1580", "filename": "libgo/go/html/template/context.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontext.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "634f183f7963502084c9cc2ec7d7d22ef5b8e499", "filename": "libgo/go/html/template/css.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcss.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcss.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcss.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "9ae9749db0c408220e83ee45cfd70e24fd872dd9", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "58383a6cd4e291454d659776b8fca56d8778face", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "d594e0ad7116b1fb8d97a4757edbbe6662396213", "filename": "libgo/go/html/template/js.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "11cc34a50a38eb80297d54da58808bbe39c07625", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "7f30a7ab8deb33609e3062e09bf820eb65a5d26b", "filename": "libgo/go/html/template/transition.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "ff596a76a367632484689e60220811b2a7b2c8ed", "filename": "libgo/go/image/color/color.go", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "f20c021de13c5ea3417b54b52d21822afdf7f57c", "filename": "libgo/go/image/color/palette/gen.go", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgen.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "3aba7401d1a94c135d43c5bd0bb36c94491a1325", "filename": "libgo/go/image/color/palette/palette.go", "status": "added", "additions": 500, "deletions": 0, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fpalette.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fpalette.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fpalette.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "21e90fea4f8bf91c3f068e62ae232d716e22b7d8", "filename": "libgo/go/image/decode_example_test.go", "status": "modified", "additions": 87, "deletions": 26, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fdecode_example_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fdecode_example_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_example_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "661230e7c5994385c3da434d7534fd5476abd798", "filename": "libgo/go/image/draw/draw.go", "status": "modified", "additions": 190, "deletions": 19, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "0dd7fbd479aff6cdf58140d6dc925aa8d97ea7b2", "filename": "libgo/go/image/draw/draw_test.go", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "3668de4e6858afdf4a1ffd2185bc980b96c996ff", "filename": "libgo/go/image/format.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fformat.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "6ebaf67da846d55d2297445ba62cf72f8511092f", "filename": "libgo/go/image/geom.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgeom.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgeom.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgeom.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8b0298a29f3dde2aabef870e31136cf52eac5434", "filename": "libgo/go/image/gif/reader.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Freader.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "09867132d3d11b3ed6ab6bd35a6c68aaa5a7b12c", "filename": "libgo/go/image/gif/reader_test.go", "status": "modified", "additions": 71, "deletions": 12, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgif%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgif%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Freader_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "15cd40fadf6d729383394461372b93cd503bb795", "filename": "libgo/go/image/gif/writer.go", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgif%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgif%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Fwriter.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "c1ada769c2c40b4ba2a6ec1a5104d49d31a97a4f", "filename": "libgo/go/image/gif/writer_test.go", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgif%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fgif%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Fwriter_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "32a89ef34ca8c1e9326bf136ffc9445a25bdbc40", "filename": "libgo/go/image/image.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "845e758878934fe67848796ca34e4efb0d43a999", "filename": "libgo/go/image/jpeg/dct_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "356d56220a7596b3bf5b9068e06b39ced4639795", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8985f492140aaf5710c698a5d1dad7bce2ebc4f9", "filename": "libgo/go/image/names.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fnames.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fimage%2Fnames.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fnames.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "f7073ffc06841e8d353a77ec7e481eca80732406", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "bd7a82f17b63c335bb27aaa1df80a8e29ba1f221", "filename": "libgo/go/io/io_test.go", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "b2508b7899ea6d39e05f23ad6c756000f50778e8", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "f65354a7f253b65a4c1718b3dae1908c55229efe", "filename": "libgo/go/io/pipe.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fpipe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fpipe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fpipe.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "b16e6530693578680d79fe5794ef7818a141d635", "filename": "libgo/go/io/pipe_test.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fpipe_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fio%2Fpipe_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fpipe_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "0cbfa9011b8e0fa0dd9648634797bec0816bd6c1", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "760a5c7d1e99169e399db5da6af4c8a3732816be", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "28a294af96387eb96a2546522b54df304f62723d", "filename": "libgo/go/log/syslog/syslog_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "46a5fe9d808793a2bb1734eaa86cf2d46e4dcd2f", "filename": "libgo/go/math/asin.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fasin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fasin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fasin.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "d942bce0968e537bdccb21f024673ec44e3814a4", "filename": "libgo/go/math/atan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fatan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fatan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fatan.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "7bbb152d79cac16bc9cac3f3ca35a2f55306a19b", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "87b975d5c4b6763170124918bdf6eb2c5857a9c9", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "1d4dfe80d3d66479d0f013ed6015b4d1fff63b32", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "7faee61a465c64b67a8215357f711916ee307b0a", "filename": "libgo/go/math/big/rat.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Frat.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "0d432637ba19764d65d7ef4f138d72bd652c1c84", "filename": "libgo/go/math/big/rat_test.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Frat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbig%2Frat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Frat_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "d85ee9cb137775ad39aaafc9c2e72b851449abdd", "filename": "libgo/go/math/bits.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbits.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fbits.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbits.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "2157cdb46581ca6c40bad5a185dbd283cee59878", "filename": "libgo/go/math/rand/rand.go", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Frand%2Frand.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "1c5491f6dc48f815ac9223cb664b1f8e024d1399", "filename": "libgo/go/math/sin.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fsin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Fsin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsin.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "e544b276b5dbb1e4403791d40921d8044df52df3", "filename": "libgo/go/math/tan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Ftan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmath%2Ftan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ftan.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "2347324aa5ada2eeeb20ac97cc84a32a68a31bd5", "filename": "libgo/go/mime/grammar.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Fgrammar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Fgrammar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fgrammar.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "608f759da8f315795310291f25fbc9a92c2c5a29", "filename": "libgo/go/mime/mediatype.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Fmediatype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Fmediatype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "29511445bcffcdf323c5e3e8d7c40e04f0e27391", "filename": "libgo/go/mime/mediatype_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Fmediatype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Fmediatype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "2b4f5b433ec51c3b6643349e1268dd7db0f8d0f3", "filename": "libgo/go/mime/multipart/multipart.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "b8f0511ee7d6530b1aca49cda88819f7502e67ce", "filename": "libgo/go/mime/type_plan9.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Ftype_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Ftype_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype_plan9.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "713e301cdf27d2a35a7a603f207f861682cd44c4", "filename": "libgo/go/mime/type_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Ftype_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fmime%2Ftype_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "3852fc22987ae3bdebf9d1b13bebecab884a2f6a", "filename": "libgo/go/net/cgo_bsd.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_bsd.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "77522f9141bdcc0ba7f8a2b9a2a07c14177e119a", "filename": "libgo/go/net/cgo_linux.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_linux.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "3c13103831f6aef54e0828bd97ecea8c0bb2af08", "filename": "libgo/go/net/cgo_netbsd.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_netbsd.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "09c5ad2d9fde595bd5a3dbdef199d98d356bf8a3", "filename": "libgo/go/net/cgo_openbsd.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_openbsd.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "f533c14212fb9836dec8eeb35348ae625b415060", "filename": "libgo/go/net/cgo_stub.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_stub.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "0abf43410e12fdafdf7dafffa6eb37c6d8802509", "filename": "libgo/go/net/cgo_unix.go", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "6304818bf14062c3bde0be0913d7a7bbbad4600a", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 101, "deletions": 27, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "ada6233003fececed91924146c274f5d2661a6ed", "filename": "libgo/go/net/dial_gen.go", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdial_gen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdial_gen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_gen.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "c7ffdd3d9c8f0e10aa7527ec54b9e0beac5e8d1e", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 163, "deletions": 15, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "b4ebad0e0dc8733920ab31d3dcaaeb435b0bb2da", "filename": "libgo/go/net/dialgoogle_test.go", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "01db4372945c230f7df3a4f6d72bb7bae353e321", "filename": "libgo/go/net/dnsclient.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "16cf420dcdb87e2cd80914496b3b05eb35f9f642", "filename": "libgo/go/net/dnsclient_unix.go", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "47dcb563bc54e8a91ee7dbd199a3ebbd8c597650", "filename": "libgo/go/net/dnsclient_unix_test.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "2f0f6c031f13ff89fe32ee7de8333ab3b84379ea", "filename": "libgo/go/net/dnsconfig_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsconfig_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsconfig_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsconfig_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "57dd25fe4c6dec1752858c13c926ed1bc228a74a", "filename": "libgo/go/net/dnsname_test.go", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsname_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fdnsname_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsname_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8bb1ae53847a83aab2739e179df6ca89c7bf0e47", "filename": "libgo/go/net/fd_bsd.go", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20f261304993444741e0f0a14d3147e591bc660/libgo%2Fgo%2Fnet%2Ffd_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20f261304993444741e0f0a14d3147e591bc660/libgo%2Fgo%2Fnet%2Ffd_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_bsd.go?ref=f20f261304993444741e0f0a14d3147e591bc660"}, {"sha": "6d5509d7f2a3c7f528adb66a33dc2c2ec20c8e54", "filename": "libgo/go/net/fd_mutex.go", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_mutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_mutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_mutex.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8383084b7a284cbad7429bf16799c7c1f7dd7ef4", "filename": "libgo/go/net/fd_mutex_test.go", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_mutex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_mutex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_mutex_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "acc8294021716f9742f1576a20ce96851c209bcb", "filename": "libgo/go/net/fd_plan9.go", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_plan9.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "e2b2768864afb537da731c8e6a9f9c0fec2275c1", "filename": "libgo/go/net/fd_poll_runtime.go", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_poll_runtime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_poll_runtime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_poll_runtime.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "307e577e999833bb696c683c4f3fe70079e2e507", "filename": "libgo/go/net/fd_poll_unix.go", "status": "removed", "additions": 0, "deletions": 360, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20f261304993444741e0f0a14d3147e591bc660/libgo%2Fgo%2Fnet%2Ffd_poll_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20f261304993444741e0f0a14d3147e591bc660/libgo%2Fgo%2Fnet%2Ffd_poll_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_poll_unix.go?ref=f20f261304993444741e0f0a14d3147e591bc660"}, {"sha": "8be0335d61ce228bc9384c3fceeab60cc2883a04", "filename": "libgo/go/net/fd_posix_test.go", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20f261304993444741e0f0a14d3147e591bc660/libgo%2Fgo%2Fnet%2Ffd_posix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20f261304993444741e0f0a14d3147e591bc660/libgo%2Fgo%2Fnet%2Ffd_posix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_posix_test.go?ref=f20f261304993444741e0f0a14d3147e591bc660"}, {"sha": "9ed4f753649aeeb13ee0a6404503eba919e3a2fe", "filename": "libgo/go/net/fd_unix.go", "status": "modified", "additions": 145, "deletions": 93, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "65d3e69a764036a397dafbef211252c8ff0b261a", "filename": "libgo/go/net/fd_unix_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "64d56c73e06c4316fb0c9fcc143257120db03775", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 317, "deletions": 398, "changes": 715, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8fe1b0eb035f5b18d9330504c3c8bce76df32279", "filename": "libgo/go/net/file_unix.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_unix.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "45fc2e57cd7e7de212c1043fd277899a455cc9f8", "filename": "libgo/go/net/http/cgi/child.go", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "075d8411bcf2e1a6a8e72500ca8405b90dbf82f6", "filename": "libgo/go/net/http/cgi/child_test.go", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "22f2e865cf7d69ef3fc0e10f9bd9e621d517c692", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "997d04151c224eb1579c4a061352f152f07df48b", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8b01c508eb1e305d398e3db710bd1738632d8278", "filename": "libgo/go/net/http/cookie.go", "status": "modified", "additions": 128, "deletions": 7, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "11b01cc5713de70f06e3c0e676c630e5833cb819", "filename": "libgo/go/net/http/cookie_test.go", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "389ab58e4182f5d84c5d0fae15d974748e9cf4ee", "filename": "libgo/go/net/http/cookiejar/jar.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcookiejar%2Fjar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fcookiejar%2Fjar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookiejar%2Fjar.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "b1216e8dafa5b701a59cd4f167085d1bfcd8553e", "filename": "libgo/go/net/http/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "88b97d9e3d7f4e09c0f09c762771f2af11e08736", "filename": "libgo/go/net/http/example_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "22b7f279689bccdb78e1aa3233ae4b366a84d50e", "filename": "libgo/go/net/http/export_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "8b32ca1d0eaf4652d4bbf649657a793124458c68", "filename": "libgo/go/net/http/fs.go", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}, {"sha": "dd3e9fefeace860f13fd58f0b24fe4be3969202b", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f038dae646bac2b31be98ab592c0e5206d2d96f5/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=f038dae646bac2b31be98ab592c0e5206d2d96f5"}]}