{"sha": "4185202700f518a5dd483cf5f45b9b438c52108c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE4NTIwMjcwMGY1MThhNWRkNDgzY2Y1ZjQ1YjliNDM4YzUyMTA4Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-01-15T19:10:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-01-15T19:10:09Z"}, "message": "re PR c++/59659 (large zero-initialized std::array compile time excessive)\n\n\tPR c++/59659\n\t* typeck2.c (massage_init_elt): New.\n\t(process_init_constructor_record)\n\t(process_init_constructor_union): Use it.\n\t(process_init_constructor_array): Use it.  Use RANGE_EXPR.\n\t(split_nonconstant_init_1): Handle it.\n\t* semantics.c (cxx_eval_vec_init_1): Use force_rvalue.\n\nFrom-SVN: r206639", "tree": {"sha": "959783072fc5872bc6501b82629d354e383f17ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/959783072fc5872bc6501b82629d354e383f17ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4185202700f518a5dd483cf5f45b9b438c52108c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4185202700f518a5dd483cf5f45b9b438c52108c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4185202700f518a5dd483cf5f45b9b438c52108c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4185202700f518a5dd483cf5f45b9b438c52108c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6a2d67b0adf891b823b2b492a9d1cc98e09835a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a2d67b0adf891b823b2b492a9d1cc98e09835a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a2d67b0adf891b823b2b492a9d1cc98e09835a"}], "stats": {"total": 191, "additions": 124, "deletions": 67}, "files": [{"sha": "c15c8fd511c501b2b80807d011f6ccc6520641ae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4185202700f518a5dd483cf5f45b9b438c52108c", "patch": "@@ -1,3 +1,13 @@\n+2014-01-14  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/59659\n+\t* typeck2.c (massage_init_elt): New.\n+\t(process_init_constructor_record)\n+\t(process_init_constructor_union): Use it.\n+\t(process_init_constructor_array): Use it.  Use RANGE_EXPR.\n+\t(split_nonconstant_init_1): Handle it.\n+\t* semantics.c (cxx_eval_vec_init_1): Use force_rvalue.\n+\n 2014-01-09  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \tPR c++/59631"}, {"sha": "eb04266aee81f10a76910c4506051c0ac4cc3b3a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4185202700f518a5dd483cf5f45b9b438c52108c", "patch": "@@ -8961,19 +8961,13 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n       else\n \t{\n \t  /* Copying an element.  */\n-\t  vec<tree, va_gc> *argvec;\n \t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n \t\t      (atype, TREE_TYPE (init)));\n \t  eltinit = cp_build_array_ref (input_location, init, idx,\n \t\t\t\t\ttf_warning_or_error);\n \t  if (!real_lvalue_p (init))\n \t    eltinit = move (eltinit);\n-\t  argvec = make_tree_vector ();\n-\t  argvec->quick_push (eltinit);\n-\t  eltinit = (build_special_member_call\n-\t\t     (NULL_TREE, complete_ctor_identifier, &argvec,\n-\t\t      elttype, LOOKUP_NORMAL, tf_warning_or_error));\n-\t  release_tree_vector (argvec);\n+\t  eltinit = force_rvalue (eltinit, tf_warning_or_error);\n \t  eltinit = cxx_eval_constant_expression\n \t    (call, eltinit, allow_non_constant, addr, non_constant_p, overflow_p);\n \t}"}, {"sha": "25edbacce96e85d51a4766803974ec05308eb0b7", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 87, "deletions": 60, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4185202700f518a5dd483cf5f45b9b438c52108c", "patch": "@@ -631,24 +631,40 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t      CONSTRUCTOR_ELTS (init)->ordered_remove (idx);\n \t      --idx;\n \n-\t      if (array_type_p)\n-\t\tsub = build4 (ARRAY_REF, inner_type, dest, field_index,\n-\t\t\t      NULL_TREE, NULL_TREE);\n+\t      if (TREE_CODE (field_index) == RANGE_EXPR)\n+\t\t{\n+\t\t  /* Use build_vec_init to initialize a range.  */\n+\t\t  tree low = TREE_OPERAND (field_index, 0);\n+\t\t  tree hi = TREE_OPERAND (field_index, 1);\n+\t\t  sub = build4 (ARRAY_REF, inner_type, dest, low,\n+\t\t\t\tNULL_TREE, NULL_TREE);\n+\t\t  sub = cp_build_addr_expr (sub, tf_warning_or_error);\n+\t\t  tree max = size_binop (MINUS_EXPR, hi, low);\n+\t\t  code = build_vec_init (sub, max, value, false, 0,\n+\t\t\t\t\t tf_warning_or_error);\n+\t\t  add_stmt (code);\n+\t\t}\n \t      else\n-\t\tsub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n-\t\t\t      NULL_TREE);\n-\n-\t      code = build2 (INIT_EXPR, inner_type, sub, value);\n-\t      code = build_stmt (input_location, EXPR_STMT, code);\n-\t      code = maybe_cleanup_point_expr_void (code);\n-\t      add_stmt (code);\n-\t      if (type_build_dtor_call (inner_type))\n \t\t{\n-\t\t  code = (build_special_member_call\n-\t\t\t  (sub, complete_dtor_identifier, NULL, inner_type,\n-\t\t\t   LOOKUP_NORMAL, tf_warning_or_error));\n-\t\t  if (!TYPE_HAS_TRIVIAL_DESTRUCTOR (inner_type))\n-\t\t    finish_eh_cleanup (code);\n+\t\t  if (array_type_p)\n+\t\t    sub = build4 (ARRAY_REF, inner_type, dest, field_index,\n+\t\t\t\t  NULL_TREE, NULL_TREE);\n+\t\t  else\n+\t\t    sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n+\t\t\t\t  NULL_TREE);\n+\n+\t\t  code = build2 (INIT_EXPR, inner_type, sub, value);\n+\t\t  code = build_stmt (input_location, EXPR_STMT, code);\n+\t\t  code = maybe_cleanup_point_expr_void (code);\n+\t\t  add_stmt (code);\n+\t\t  if (type_build_dtor_call (inner_type))\n+\t\t    {\n+\t\t      code = (build_special_member_call\n+\t\t\t      (sub, complete_dtor_identifier, NULL, inner_type,\n+\t\t\t       LOOKUP_NORMAL, tf_warning_or_error));\n+\t\t      if (!TYPE_HAS_TRIVIAL_DESTRUCTOR (inner_type))\n+\t\t\tfinish_eh_cleanup (code);\n+\t\t    }\n \t\t}\n \n \t      num_split_elts++;\n@@ -1101,6 +1117,22 @@ picflag_from_initializer (tree init)\n   return 0;\n }\n \n+/* Adjust INIT for going into a CONSTRUCTOR.  */\n+\n+static tree\n+massage_init_elt (tree type, tree init, tsubst_flags_t complain)\n+{\n+  init = digest_init_r (type, init, true, LOOKUP_IMPLICIT, complain);\n+  /* Strip a simple TARGET_EXPR when we know this is an initializer.  */\n+  if (TREE_CODE (init) == TARGET_EXPR\n+      && !VOID_TYPE_P (TREE_TYPE (TARGET_EXPR_INITIAL (init))))\n+    init = TARGET_EXPR_INITIAL (init);\n+  /* When we defer constant folding within a statement, we may want to\n+     defer this folding as well.  */\n+  init = maybe_constant_init (init);\n+  return init;\n+}\n+\n /* Subroutine of process_init_constructor, which will process an initializer\n    INIT for an array or vector of type TYPE. Returns the flags (PICFLAG_*)\n    which describe the initializers.  */\n@@ -1158,8 +1190,7 @@ process_init_constructor_array (tree type, tree init,\n       else\n \tce->index = size_int (i);\n       gcc_assert (ce->value);\n-      ce->value = digest_init_r (TREE_TYPE (type), ce->value, true,\n-\t\t\t\t LOOKUP_IMPLICIT, complain);\n+      ce->value = massage_init_elt (TREE_TYPE (type), ce->value, complain);\n \n       if (ce->value != error_mark_node)\n \tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n@@ -1168,33 +1199,42 @@ process_init_constructor_array (tree type, tree init,\n       flags |= picflag_from_initializer (ce->value);\n     }\n \n-  /* No more initializers. If the array is unbounded, we are done. Otherwise,\n-     we must add initializers ourselves.  */\n-  if (!unbounded)\n-    for (; i < len; ++i)\n-      {\n-\ttree next;\n-\n-\tif (type_build_ctor_call (TREE_TYPE (type)))\n-\t  {\n-\t    /* If this type needs constructors run for default-initialization,\n-\t      we can't rely on the back end to do it for us, so make the\n-\t      initialization explicit by list-initializing from {}.  */\n-\t    next = build_constructor (init_list_type_node, NULL);\n-\t    next = digest_init (TREE_TYPE (type), next, complain);\n-\t  }\n-\telse if (!zero_init_p (TREE_TYPE (type)))\n-\t  next = build_zero_init (TREE_TYPE (type),\n-\t\t\t\t  /*nelts=*/NULL_TREE,\n-\t\t\t\t  /*static_storage_p=*/false);\n-\telse\n-\t  /* The default zero-initialization is fine for us; don't\n-\t     add anything to the CONSTRUCTOR.  */\n-\t  break;\n+  /* No more initializers. If the array is unbounded, or we've initialized\n+     all the elements, we are done. Otherwise, we must add initializers\n+     ourselves.  */\n+  if (!unbounded && i < len)\n+    {\n+      tree next;\n \n-\tflags |= picflag_from_initializer (next);\n-\tCONSTRUCTOR_APPEND_ELT (v, size_int (i), next);\n-      }\n+      if (type_build_ctor_call (TREE_TYPE (type)))\n+\t{\n+\t  /* If this type needs constructors run for default-initialization,\n+\t     we can't rely on the back end to do it for us, so make the\n+\t     initialization explicit by list-initializing from {}.  */\n+\t  next = build_constructor (init_list_type_node, NULL);\n+\t  next = massage_init_elt (TREE_TYPE (type), next, complain);\n+\t  if (initializer_zerop (next))\n+\t    /* The default zero-initialization is fine for us; don't\n+\t       add anything to the CONSTRUCTOR.  */\n+\t    next = NULL_TREE;\n+\t}\n+      else if (!zero_init_p (TREE_TYPE (type)))\n+\tnext = build_zero_init (TREE_TYPE (type),\n+\t\t\t\t/*nelts=*/NULL_TREE,\n+\t\t\t\t/*static_storage_p=*/false);\n+      else\n+\t/* The default zero-initialization is fine for us; don't\n+\t   add anything to the CONSTRUCTOR.  */\n+\tnext = NULL_TREE;\n+\n+      if (next)\n+\t{\n+\t  flags |= picflag_from_initializer (next);\n+\t  tree index = build2 (RANGE_EXPR, sizetype, size_int (i),\n+\t\t\t       size_int (len - 1));\n+\t  CONSTRUCTOR_APPEND_ELT (v, index, next);\n+\t}\n+    }\n \n   CONSTRUCTOR_ELTS (init) = v;\n   return flags;\n@@ -1263,8 +1303,7 @@ process_init_constructor_record (tree type, tree init,\n \t    }\n \n \t  gcc_assert (ce->value);\n-\t  next = digest_init_r (type, ce->value, true,\n-\t\t\t\tLOOKUP_IMPLICIT, complain);\n+\t  next = massage_init_elt (type, ce->value, complain);\n \t  ++idx;\n \t}\n       else if (type_build_ctor_call (TREE_TYPE (field)))\n@@ -1274,18 +1313,7 @@ process_init_constructor_record (tree type, tree init,\n \t     for us, so build up TARGET_EXPRs.  If the type in question is\n \t     a class, just build one up; if it's an array, recurse.  */\n \t  next = build_constructor (init_list_type_node, NULL);\n-\t  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (field)))\n-\t    {\n-\t      next = finish_compound_literal (TREE_TYPE (field), next,\n-\t\t\t\t\t      complain);\n-\t      /* direct-initialize the target. No temporary is going\n-\t\t  to be involved.  */\n-\t      if (TREE_CODE (next) == TARGET_EXPR)\n-\t\tTARGET_EXPR_DIRECT_INIT_P (next) = true;\n-\t    }\n-\n-\t  next = digest_init_r (TREE_TYPE (field), next, true,\n-\t\t\t\tLOOKUP_IMPLICIT, complain);\n+\t  next = massage_init_elt (TREE_TYPE (field), next, complain);\n \n \t  /* Warn when some struct elements are implicitly initialized.  */\n \t  warning (OPT_Wmissing_field_initializers,\n@@ -1422,8 +1450,7 @@ process_init_constructor_union (tree type, tree init,\n     }\n \n   if (ce->value && ce->value != error_mark_node)\n-    ce->value = digest_init_r (TREE_TYPE (ce->index), ce->value,\n-\t\t\t       true, LOOKUP_IMPLICIT, complain);\n+    ce->value = massage_init_elt (TREE_TYPE (ce->index), ce->value, complain);\n \n   return picflag_from_initializer (ce->value);\n }"}, {"sha": "fd38b2e0264d13ac71f1c2d16be34be109a9a7d6", "filename": "gcc/testsuite/g++.dg/opt/value-init1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvalue-init1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvalue-init1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvalue-init1.C?ref=4185202700f518a5dd483cf5f45b9b438c52108c", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/59659\n+// { dg-options \"-fdump-tree-gimple -std=c++11\" }\n+// { dg-final { scan-tree-dump-times \"i = 0\" 0 \"gimple\" } }\n+// { dg-final { cleanup-tree-dump \"gimple\" } }\n+\n+struct S { S () = default; S (int i); int i; };\n+struct A { S s[100]; };\n+\n+void\n+foo ()\n+{\n+  A a = {{}};\n+}"}, {"sha": "515cca07ac183e6779e59f8ada3afba541190e78", "filename": "gcc/testsuite/g++.dg/opt/value-init2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvalue-init2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4185202700f518a5dd483cf5f45b9b438c52108c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvalue-init2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvalue-init2.C?ref=4185202700f518a5dd483cf5f45b9b438c52108c", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/59659\n+// { dg-options \"-fdump-tree-gimple\" }\n+// { dg-final { scan-tree-dump-times \"S::S\" 1 \"gimple\" } }\n+// { dg-final { cleanup-tree-dump \"gimple\" } }\n+\n+struct S { S (); S (int i); int i; };\n+struct A { S s[100]; };\n+\n+void\n+foo ()\n+{\n+  A a = {{}};\n+}"}]}