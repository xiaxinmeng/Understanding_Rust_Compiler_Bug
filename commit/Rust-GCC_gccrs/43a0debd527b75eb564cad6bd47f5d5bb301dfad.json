{"sha": "43a0debd527b75eb564cad6bd47f5d5bb301dfad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNhMGRlYmQ1MjdiNzVlYjU2NGNhZDZiZDQ3ZjVkNWJiMzAxZGZhZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-19T10:04:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-19T10:04:52Z"}, "message": "Enhance debug info for fixed-point types\n\nThe Ada language supports fixed-point types as first-class citizens so\nthey need to be described as-is in the debug info.  We devised the\nlanghook get_fixed_point_type_info for this purpose a few years ago,\nbut it comes with a limitation for the representation of the scale\nfactor that we would need to lift in order to be able to represent\nmore fixed-point types.\n\ngcc/ChangeLog:\n\t* dwarf2out.h (struct fixed_point_type_info) <scale_factor>: Turn\n\tnumerator and denominator into a tree.\n\t* dwarf2out.c (base_type_die): In the case of a fixed-point type\n\twith arbitrary scale factor, call add_scalar_info on numerator and\n\tdenominator to emit the appropriate attributes.\n\ngcc/ada/ChangeLog:\n\t* exp_dbug.adb (Is_Handled_Scale_Factor): Delete.\n\t(Get_Encoded_Name): Do not call it.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <Fixed_Point_Type>:\n\tTidy up and always use a meaningful description for arbitrary\n\tscale factors.\n\t* gcc-interface/misc.c (gnat_get_fixed_point_type_info): Remove\n\tobsolete block and adjust the description of the scale factor.", "tree": {"sha": "da21597c3e40f05e45153c7ba9c0bedfb42495d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da21597c3e40f05e45153c7ba9c0bedfb42495d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43a0debd527b75eb564cad6bd47f5d5bb301dfad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a0debd527b75eb564cad6bd47f5d5bb301dfad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a0debd527b75eb564cad6bd47f5d5bb301dfad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a0debd527b75eb564cad6bd47f5d5bb301dfad/comments", "author": null, "committer": null, "parents": [{"sha": "0d8290959ecf2c5f1dd062e57782b5e91be0f8f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8290959ecf2c5f1dd062e57782b5e91be0f8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8290959ecf2c5f1dd062e57782b5e91be0f8f6"}], "stats": {"total": 119, "additions": 27, "deletions": 92}, "files": [{"sha": "dc6cd265af438320bb57ec5edaf0a077a6fde0e5", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=43a0debd527b75eb564cad6bd47f5d5bb301dfad", "patch": "@@ -133,11 +133,6 @@ package body Exp_Dbug is\n    --  Determine whether the bounds of E match the size of the type. This is\n    --  used to determine whether encoding is required for a discrete type.\n \n-   function Is_Handled_Scale_Factor (U : Ureal) return Boolean;\n-   --  The argument U is the Small_Value of a fixed-point type. This function\n-   --  determines whether the back-end can handle this scale factor. When it\n-   --  cannot, we have to output a GNAT encoding for the corresponding type.\n-\n    procedure Output_Homonym_Numbers_Suffix;\n    --  If homonym numbers are stored, then output them into Name_Buffer\n \n@@ -594,27 +589,6 @@ package body Exp_Dbug is\n          return Make_Null_Statement (Loc);\n    end Debug_Renaming_Declaration;\n \n-   -----------------------------\n-   -- Is_Handled_Scale_Factor --\n-   -----------------------------\n-\n-   function Is_Handled_Scale_Factor (U : Ureal) return Boolean is\n-   begin\n-      --  Keep in sync with gigi (see E_*_Fixed_Point_Type handling in\n-      --  decl.c:gnat_to_gnu_entity).\n-\n-      if UI_Eq (Numerator (U), Uint_1) then\n-         if Rbase (U) = 2 or else Rbase (U) = 10 then\n-            return True;\n-         end if;\n-      end if;\n-\n-      return\n-        (UI_Is_In_Int_Range (Norm_Num (U))\n-           and then\n-         UI_Is_In_Int_Range (Norm_Den (U)));\n-   end Is_Handled_Scale_Factor;\n-\n    ----------------------\n    -- Get_Encoded_Name --\n    ----------------------\n@@ -671,12 +645,10 @@ package body Exp_Dbug is\n \n       Has_Suffix := True;\n \n-      --  Fixed-point case: generate GNAT encodings when asked to or when we\n-      --  know the back-end will not be able to handle the scale factor.\n+      --  Fixed-point case: generate GNAT encodings when asked to\n \n       if Is_Fixed_Point_Type (E)\n-        and then (GNAT_Encodings /= DWARF_GNAT_Encodings_Minimal\n-                   or else not Is_Handled_Scale_Factor (Small_Value (E)))\n+        and then GNAT_Encodings /= DWARF_GNAT_Encodings_Minimal\n       then\n          Get_External_Name (E, True, \"XF_\");\n          Add_Real_To_Buffer (Delta_Value (E));"}, {"sha": "a0f17b1aafcb08c8dc9f739fbec0d8b96094f2e1", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=43a0debd527b75eb564cad6bd47f5d5bb301dfad", "patch": "@@ -1743,24 +1743,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \tgnu_type = make_signed_type (esize);\n \n-\t/* Try to decode the scale factor and to save it for the fixed-point\n-\t   types debug hook.  */\n-\n-\t/* There are various ways to describe the scale factor, however there\n-\t   are cases where back-end internals cannot hold it.  In such cases,\n-\t   we output invalid scale factor for such cases (i.e. the 0/0\n-\t   rational constant) but we expect GNAT to output GNAT encodings,\n-\t   then.  Thus, keep this in sync with\n-\t   Exp_Dbug.Is_Handled_Scale_Factor.  */\n-\n \t/* When encoded as 1/2**N or 1/10**N, describe the scale factor as a\n \t   binary or decimal scale: it is easier to read for humans.  */\n \tif (UI_Eq (Numerator (gnat_small_value), Uint_1)\n \t    && (Rbase (gnat_small_value) == 2\n \t\t|| Rbase (gnat_small_value) == 10))\n \t  {\n-\t    /* Given RM restrictions on 'Small values, we assume here that\n-\t       the denominator fits in an int.  */\n \t    tree base\n \t      = build_int_cst (integer_type_node, Rbase (gnat_small_value));\n \t    tree exponent\n@@ -1773,29 +1761,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\tbase, exponent));\n \t  }\n \n-\t/* Default to arbitrary scale factors descriptions.  */\n-\telse\n+\t/* Use the arbitrary scale factor description.  Note that we support\n+\t   a Small_Value whose magnitude is larger than 64-bit even on 32-bit\n+\t   platforms, so we unconditionally use a (dummy) 128-bit type.  */\n \t  {\n-\t    const Uint num = Norm_Num (gnat_small_value);\n-\t    const Uint den = Norm_Den (gnat_small_value);\n+\t    const Uint gnat_num = Norm_Num (gnat_small_value);\n+\t    const Uint gnat_den = Norm_Den (gnat_small_value);\n+\t    tree gnu_small_type = make_unsigned_type (128);\n+\t    tree gnu_num = UI_To_gnu (gnat_num, gnu_small_type);\n+\t    tree gnu_den = UI_To_gnu (gnat_den, gnu_small_type);\n \n-\t    if (UI_Is_In_Int_Range (num) && UI_Is_In_Int_Range (den))\n-\t      {\n-\t\ttree gnu_num\n-\t\t  = build_int_cst (integer_type_node,\n-\t\t\t\t   UI_To_Int (Norm_Num (gnat_small_value)));\n-\t\ttree gnu_den\n-\t\t  = build_int_cst (integer_type_node,\n-\t\t\t\t   UI_To_Int (Norm_Den (gnat_small_value)));\n-\t\tscale_factor = build2 (RDIV_EXPR, integer_type_node,\n-\t\t\t\t       gnu_num, gnu_den);\n-\t      }\n-\t    else\n-\t      /* If compiler internals cannot represent arbitrary scale\n-\t\t factors, output an invalid scale factor so that debugger\n-\t\t don't try to handle them but so that we still have a type\n-\t\t in the output.  Note that GNAT  */\n-\t      scale_factor = integer_zero_node;\n+\t    scale_factor\n+\t      = build2 (RDIV_EXPR, gnu_small_type, gnu_num, gnu_den);\n \t  }\n \n \tTYPE_FIXED_POINT_P (gnu_type) = 1;"}, {"sha": "d0867e00c852da0112e3bc4bf2ba19292278d80f", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=43a0debd527b75eb564cad6bd47f5d5bb301dfad", "patch": "@@ -628,16 +628,6 @@ gnat_get_fixed_point_type_info (const_tree type,\n   /* We expect here only a finite set of pattern.  See fixed-point types\n      handling in gnat_to_gnu_entity.  */\n \n-  /* Put invalid values when compiler internals cannot represent the scale\n-     factor.  */\n-  if (scale_factor == integer_zero_node)\n-    {\n-      info->scale_factor_kind = fixed_point_scale_factor_arbitrary;\n-      info->scale_factor.arbitrary.numerator = 0;\n-      info->scale_factor.arbitrary.denominator = 0;\n-      return true;\n-    }\n-\n   if (TREE_CODE (scale_factor) == RDIV_EXPR)\n     {\n       tree num = TREE_OPERAND (scale_factor, 0);\n@@ -677,8 +667,8 @@ gnat_get_fixed_point_type_info (const_tree type,\n \t\t  && TREE_CODE (den) == INTEGER_CST);\n \n       info->scale_factor_kind = fixed_point_scale_factor_arbitrary;\n-      info->scale_factor.arbitrary.numerator = tree_to_uhwi (num);\n-      info->scale_factor.arbitrary.denominator = tree_to_shwi (den);\n+      info->scale_factor.arbitrary.numerator = num;\n+      info->scale_factor.arbitrary.denominator = den;\n       return true;\n     }\n "}, {"sha": "ea2a22a304200e5d87b3d76385192d1d6f9ecb25", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=43a0debd527b75eb564cad6bd47f5d5bb301dfad", "patch": "@@ -12973,18 +12973,19 @@ base_type_die (tree type, bool reverse)\n \t  break;\n \n \tcase fixed_point_scale_factor_arbitrary:\n-\t  /* Arbitrary scale factors cannot be described in standard DWARF,\n-\t     yet.  */\n+\t  /* Arbitrary scale factors cannot be described in standard DWARF.  */\n \t  if (!dwarf_strict)\n \t    {\n \t      /* Describe the scale factor as a rational constant.  */\n \t      const dw_die_ref scale_factor\n \t\t= new_die (DW_TAG_constant, comp_unit_die (), type);\n \n-\t      add_AT_unsigned (scale_factor, DW_AT_GNU_numerator,\n-\t\t\t       fpt_info.scale_factor.arbitrary.numerator);\n-\t      add_AT_int (scale_factor, DW_AT_GNU_denominator,\n-\t\t\t  fpt_info.scale_factor.arbitrary.denominator);\n+\t      add_scalar_info (scale_factor, DW_AT_GNU_numerator,\n+\t\t\t       fpt_info.scale_factor.arbitrary.numerator,\n+\t\t\t       dw_scalar_form_constant, NULL);\n+\t      add_scalar_info (scale_factor, DW_AT_GNU_denominator,\n+\t\t\t       fpt_info.scale_factor.arbitrary.denominator,\n+\t\t\t       dw_scalar_form_constant, NULL);\n \n \t      add_AT_die_ref (base_type_result, DW_AT_small, scale_factor);\n \t    }"}, {"sha": "0b06cff477b9d5bc1e7f7f35a840f754707bce7c", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a0debd527b75eb564cad6bd47f5d5bb301dfad/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=43a0debd527b75eb564cad6bd47f5d5bb301dfad", "patch": "@@ -362,23 +362,18 @@ enum fixed_point_scale_factor\n \n struct fixed_point_type_info\n {\n-  /* A scale factor is the value one has to multiply with physical data in\n-     order to get the fixed point logical data.  The DWARF standard enables one\n-     to encode it in three ways.  */\n+  /* The scale factor is the value one has to multiply the actual data with\n+     to get the fixed point value.  We support three ways to encode it.  */\n   enum fixed_point_scale_factor scale_factor_kind;\n   union\n     {\n-      /* For binary scale factor, the scale factor is: 2 ** binary.  */\n+      /* For a binary scale factor, the scale factor is 2 ** binary.  */\n       int binary;\n-      /* For decimal scale factor, the scale factor is: 10 ** binary.  */\n+      /* For a decimal scale factor, the scale factor is 10 ** decimal.  */\n       int decimal;\n-      /* For arbitrary scale factor, the scale factor is:\n+      /* For an arbitrary scale factor, the scale factor is the ratio\n \t numerator / denominator.  */\n-      struct\n-\t{\n-\t  unsigned HOST_WIDE_INT numerator;\n-\t  HOST_WIDE_INT denominator;\n-\t} arbitrary;\n+      struct { tree numerator; tree denominator; } arbitrary;\n     } scale_factor;\n };\n "}]}