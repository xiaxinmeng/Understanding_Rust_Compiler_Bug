{"sha": "dc55c941abf8293107a7ab179dddb66747c946e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM1NWM5NDFhYmY4MjkzMTA3YTdhYjE3OWRkZGI2Njc0N2M5NDZlMg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-01-15T14:41:48Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-01-15T14:41:48Z"}, "message": "re PR c++/13594 (namespace association vs. templates part two)\n\nPR c++/13594\nPR c++/13658\n* name-lookup.c (qualified_lookup_using_namespace): Search\nstrongly-associated namespaces first, and only then try other\nnamespaces.\n\nFrom-SVN: r75921", "tree": {"sha": "8a49524c6095a1d43990f0be1719fffc89666ea7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a49524c6095a1d43990f0be1719fffc89666ea7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc55c941abf8293107a7ab179dddb66747c946e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc55c941abf8293107a7ab179dddb66747c946e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc55c941abf8293107a7ab179dddb66747c946e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc55c941abf8293107a7ab179dddb66747c946e2/comments", "author": null, "committer": null, "parents": [{"sha": "b5eb5a5eb8a7145ca4dd4d43b9d7f6dd229af4a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5eb5a5eb8a7145ca4dd4d43b9d7f6dd229af4a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5eb5a5eb8a7145ca4dd4d43b9d7f6dd229af4a1"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "2edab86495f92c004bbaee80439f06ce395f2bb1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc55c941abf8293107a7ab179dddb66747c946e2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc55c941abf8293107a7ab179dddb66747c946e2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dc55c941abf8293107a7ab179dddb66747c946e2", "patch": "@@ -1,3 +1,11 @@\n+2004-01-15  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR c++/13594\n+\tPR c++/13658\n+\t* name-lookup.c (qualified_lookup_using_namespace): Search\n+\tstrongly-associated namespaces first, and only then try other\n+\tnamespaces.\n+\n 2004-01-15  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Make-lang.in (c++.srcextra): Dummy entry."}, {"sha": "91f6466465c441103e6aae3a0dccd68d64a9f2f4", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc55c941abf8293107a7ab179dddb66747c946e2/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc55c941abf8293107a7ab179dddb66747c946e2/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=dc55c941abf8293107a7ab179dddb66747c946e2", "patch": "@@ -3778,14 +3778,15 @@ qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n   tree seen = NULL_TREE;\n   /* ... and a list of namespace yet to see.  */\n   tree todo = NULL_TREE;\n+  tree todo_maybe = NULL_TREE;\n   tree usings;\n   timevar_push (TV_NAME_LOOKUP);\n   /* Look through namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n   while (scope && result->value != error_mark_node)\n     {\n       cxx_binding *binding =\n-        cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+\tcxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n       seen = tree_cons (scope, NULL_TREE, seen);\n       if (binding)\n         result = ambiguous_decl (name, result, binding, flags);\n@@ -3797,16 +3798,36 @@ qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n       for (usings = DECL_NAMESPACE_USING (scope); usings;\n \t   usings = TREE_CHAIN (usings))\n \t/* If this was a real directive, and we have not seen it.  */\n-\tif (!TREE_INDIRECT_USING (usings)\n-\t    && ((!result->value && !result->type)\n-\t\t|| is_associated_namespace (scope, TREE_PURPOSE (usings)))\n-\t    && !purpose_member (TREE_PURPOSE (usings), seen))\n-\t  todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n+\tif (!TREE_INDIRECT_USING (usings))\n+\t  {\n+\t    /* Try to avoid queuing the same namespace more than once,\n+\t       the exception being when a namespace was already\n+\t       enqueued for todo_maybe and then a strong using is\n+\t       found for it.  We could try to remove it from\n+\t       todo_maybe, but it's probably not worth the effort.  */\n+\t    if (is_associated_namespace (scope, TREE_PURPOSE (usings))\n+\t\t&& !purpose_member (TREE_PURPOSE (usings), seen)\n+\t\t&& !purpose_member (TREE_PURPOSE (usings), todo))\n+\t      todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n+\t    else if ((!result->value && !result->type)\n+\t\t     && !purpose_member (TREE_PURPOSE (usings), seen)\n+\t\t     && !purpose_member (TREE_PURPOSE (usings), todo)\n+\t\t     && !purpose_member (TREE_PURPOSE (usings), todo_maybe))\n+\t      todo_maybe = tree_cons (TREE_PURPOSE (usings), NULL_TREE,\n+\t\t\t\t      todo_maybe);\n+\t  }\n       if (todo)\n \t{\n \t  scope = TREE_PURPOSE (todo);\n \t  todo = TREE_CHAIN (todo);\n \t}\n+      else if (todo_maybe\n+\t       && (!result->value && !result->type))\n+\t{\n+\t  scope = TREE_PURPOSE (todo_maybe);\n+\t  todo = TREE_CHAIN (todo_maybe);\n+\t  todo_maybe = NULL_TREE;\n+\t}\n       else\n \tscope = NULL_TREE; /* If there never was a todo list.  */\n     }"}]}