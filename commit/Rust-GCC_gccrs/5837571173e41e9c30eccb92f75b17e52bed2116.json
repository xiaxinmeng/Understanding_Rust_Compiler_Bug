{"sha": "5837571173e41e9c30eccb92f75b17e52bed2116", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgzNzU3MTE3M2U0MWU5YzMwZWNjYjkyZjc1YjE3ZTUyYmVkMjExNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2018-01-31T05:02:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-01-31T05:02:30Z"}, "message": "re PR target/84064 (ICE in ix86_expand_prologue related to -fstack-clash-protection and memcpy on i686)\n\n\tPR target/84064\n\t* i386.c (ix86_adjust_stack_and_probe_stack_clash): New argument\n\tINT_REGISTERS_SAVED.  Check it prior to calling\n\tget_scratch_register_on_entry.\n\t(ix86_adjust_stack_and_probe): Similarly.\n\t(ix86_emit_probe_stack_range): Similarly.\n\t(ix86_expand_prologue): Corresponding changes.\n\n\tPR target/84064\n\t* gcc.target/i386/pr84064: New test.\n\nFrom-SVN: r257217", "tree": {"sha": "fd770f27e33c3026b19133dbaf888d40763d84a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd770f27e33c3026b19133dbaf888d40763d84a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5837571173e41e9c30eccb92f75b17e52bed2116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5837571173e41e9c30eccb92f75b17e52bed2116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5837571173e41e9c30eccb92f75b17e52bed2116", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5837571173e41e9c30eccb92f75b17e52bed2116/comments", "author": null, "committer": null, "parents": [{"sha": "61ddc5ea25a0e5dc691c0c5d4357a47fbdc3ded0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ddc5ea25a0e5dc691c0c5d4357a47fbdc3ded0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ddc5ea25a0e5dc691c0c5d4357a47fbdc3ded0"}], "stats": {"total": 94, "additions": 74, "deletions": 20}, "files": [{"sha": "4b18ca160db2f623a620519973b41f2520220ffc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837571173e41e9c30eccb92f75b17e52bed2116/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837571173e41e9c30eccb92f75b17e52bed2116/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5837571173e41e9c30eccb92f75b17e52bed2116", "patch": "@@ -1,3 +1,13 @@\n+2017-01-30  Jeff Law  <law@redhat.com>\n+\n+\tPR target/84064\n+\t* i386.c (ix86_adjust_stack_and_probe_stack_clash): New argument\n+\tINT_REGISTERS_SAVED.  Check it prior to calling\n+\tget_scratch_register_on_entry.\n+\t(ix86_adjust_stack_and_probe): Similarly.\n+\t(ix86_emit_probe_stack_range): Similarly.\n+\t(ix86_expand_prologue): Corresponding changes.\n+\n 2018-01-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/40411\n@@ -376,7 +386,7 @@\n \t* config/m68k/m68k.c (m68k_promote_function_mode): New function.\n \t(TARGET_PROMOTE_FUNCTION_MODE): New macro.\n \n-2017-01-08  Jeff Law  <law@redhat.com>\n+2017-01-24  Jeff Law  <law@redhat.com>\n \n \tPR target/83994\n \t* i386.c (get_probe_interval): Move to earlier point."}, {"sha": "fef34a1ef64005b5a681f7488e4ad699e4bda7bf", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837571173e41e9c30eccb92f75b17e52bed2116/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837571173e41e9c30eccb92f75b17e52bed2116/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5837571173e41e9c30eccb92f75b17e52bed2116", "patch": "@@ -12591,10 +12591,14 @@ release_scratch_register_on_entry (struct scratch_reg *sr)\n    This differs from the next routine in that it tries hard to prevent\n    attacks that jump the stack guard.  Thus it is never allowed to allocate\n    more than PROBE_INTERVAL bytes of stack space without a suitable\n-   probe.  */\n+   probe.\n+\n+   INT_REGISTERS_SAVED is true if integer registers have already been\n+   pushed on the stack.  */\n \n static void\n-ix86_adjust_stack_and_probe_stack_clash (const HOST_WIDE_INT size)\n+ix86_adjust_stack_and_probe_stack_clash (const HOST_WIDE_INT size,\n+\t\t\t\t\t const bool int_registers_saved)\n {\n   struct machine_function *m = cfun->machine;\n \n@@ -12700,6 +12704,12 @@ ix86_adjust_stack_and_probe_stack_clash (const HOST_WIDE_INT size)\n     }\n   else\n     {\n+      /* We expect the GP registers to be saved when probes are used\n+\t as the probing sequences might need a scratch register and\n+\t the routine to allocate one assumes the integer registers\n+\t have already been saved.  */\n+      gcc_assert (int_registers_saved);\n+\n       struct scratch_reg sr;\n       get_scratch_register_on_entry (&sr);\n \n@@ -12758,10 +12768,14 @@ ix86_adjust_stack_and_probe_stack_clash (const HOST_WIDE_INT size)\n   emit_insn (gen_blockage ());\n }\n \n-/* Emit code to adjust the stack pointer by SIZE bytes while probing it.  */\n+/* Emit code to adjust the stack pointer by SIZE bytes while probing it.\n+\n+   INT_REGISTERS_SAVED is true if integer registers have already been\n+   pushed on the stack.  */\n \n static void\n-ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n+ix86_adjust_stack_and_probe (const HOST_WIDE_INT size,\n+\t\t\t     const bool int_registers_saved)\n {\n   /* We skip the probe for the first interval + a small dope of 4 words and\n      probe that many bytes past the specified size to maintain a protection\n@@ -12822,6 +12836,12 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n      equality test for the loop condition.  */\n   else\n     {\n+      /* We expect the GP registers to be saved when probes are used\n+\t as the probing sequences might need a scratch register and\n+\t the routine to allocate one assumes the integer registers\n+\t have already been saved.  */\n+      gcc_assert (int_registers_saved);\n+\n       HOST_WIDE_INT rounded_size;\n       struct scratch_reg sr;\n \n@@ -12949,10 +12969,14 @@ output_adjust_stack_and_probe (rtx reg)\n }\n \n /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,\n-   inclusive.  These are offsets from the current stack pointer.  */\n+   inclusive.  These are offsets from the current stack pointer.\n+\n+   INT_REGISTERS_SAVED is true if integer registers have already been\n+   pushed on the stack.  */\n \n static void\n-ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n+ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size,\n+\t\t\t     const bool int_registers_saved)\n {\n   /* See if we have a constant small number of probes to generate.  If so,\n      that's the easy case.  The run-time loop is made up of 6 insns in the\n@@ -12980,6 +13004,12 @@ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n      equality test for the loop condition.  */\n   else\n     {\n+      /* We expect the GP registers to be saved when probes are used\n+\t as the probing sequences might need a scratch register and\n+\t the routine to allocate one assumes the integer registers\n+\t have already been saved.  */\n+      gcc_assert (int_registers_saved);\n+\n       HOST_WIDE_INT rounded_size, last;\n       struct scratch_reg sr;\n \n@@ -13733,23 +13763,18 @@ ix86_expand_prologue (void)\n       && (flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n \t  || flag_stack_clash_protection))\n     {\n-      /* We expect the GP registers to be saved when probes are used\n-\t as the probing sequences might need a scratch register and\n-\t the routine to allocate one assumes the integer registers\n-\t have already been saved.  */\n-      gcc_assert (int_registers_saved);\n-\n       if (flag_stack_clash_protection)\n \t{\n-\t  ix86_adjust_stack_and_probe_stack_clash (allocate);\n+\t  ix86_adjust_stack_and_probe_stack_clash (allocate,\n+\t\t\t\t\t\t   int_registers_saved);\n \t  allocate = 0;\n \t}\n       else if (STACK_CHECK_MOVING_SP)\n \t{\n \t  if (!(crtl->is_leaf && !cfun->calls_alloca\n \t\t&& allocate <= get_probe_interval ()))\n \t    {\n-\t      ix86_adjust_stack_and_probe (allocate);\n+\t      ix86_adjust_stack_and_probe (allocate, int_registers_saved);\n \t      allocate = 0;\n \t    }\n \t}\n@@ -13765,11 +13790,12 @@ ix86_expand_prologue (void)\n \t      if (crtl->is_leaf && !cfun->calls_alloca)\n \t\t{\n \t\t  if (size > get_probe_interval ())\n-\t\t    ix86_emit_probe_stack_range (0, size);\n+\t\t    ix86_emit_probe_stack_range (0, size, int_registers_saved);\n \t\t}\n \t      else\n \t\tix86_emit_probe_stack_range (0,\n-\t\t\t\t\t     size + get_stack_check_protect ());\n+\t\t\t\t\t     size + get_stack_check_protect (),\n+\t\t\t\t\t     int_registers_saved);\n \t    }\n \t  else\n \t    {\n@@ -13778,10 +13804,13 @@ ix86_expand_prologue (void)\n \t\t  if (size > get_probe_interval ()\n \t\t      && size > get_stack_check_protect ())\n \t\t    ix86_emit_probe_stack_range (get_stack_check_protect (),\n-\t\t\t\t\t\t size - get_stack_check_protect ());\n+\t\t\t\t\t\t (size\n+\t\t\t\t\t\t  - get_stack_check_protect ()),\n+\t\t\t\t\t\t int_registers_saved);\n \t\t}\n \t      else\n-\t\tix86_emit_probe_stack_range (get_stack_check_protect (), size);\n+\t\tix86_emit_probe_stack_range (get_stack_check_protect (), size,\n+\t\t\t\t\t     int_registers_saved);\n \t    }\n \t}\n     }"}, {"sha": "a83ec029f63522dfe75143f31ffa6f38ba79efa2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837571173e41e9c30eccb92f75b17e52bed2116/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837571173e41e9c30eccb92f75b17e52bed2116/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5837571173e41e9c30eccb92f75b17e52bed2116", "patch": "@@ -1,3 +1,8 @@\n+2018-01-30  Jeff Law  <law@redhat.com>\n+\n+\tPR target/84064\n+\t* gcc.target/i386/pr84064: New test.\n+\n 2017-01-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/84134\n@@ -76,7 +81,7 @@\n \t* gcc.target/i386/avx512bitalgvl-vpopcntb-1.c: Ditto.\n \t* gcc.target/i386/avx512bitalgvl-vpopcntw-1.c: Ditto.\n \n-2018-01-19  Jeff Law  <law@redhat.com>\n+2018-01-29  Jeff Law  <law@redhat.com>\n \n \tPR testsuite/81010\n \t* gcc.target/powerpc/pr56605.c: Update various dg- directives to"}, {"sha": "01f8d9e945a36bac2e25bbe0021ecdae2011fa3e", "filename": "gcc/testsuite/gcc.target/i386/pr84064.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837571173e41e9c30eccb92f75b17e52bed2116/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84064.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837571173e41e9c30eccb92f75b17e52bed2116/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84064.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84064.c?ref=5837571173e41e9c30eccb92f75b17e52bed2116", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=i686 -fstack-clash-protection\" } */\n+/* { dg-require-effective-target ia32 } */\n+\n+void\n+f (void *p1, void *p2)\n+{\n+  __builtin_memcpy (p1, p2, 1000);\n+}\n+"}]}