{"sha": "e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRmZDIyYzZkNWEwMTRhZTA1NWQxZWQ3NDk5Yzg3ZjlkYmI5YTNjZA==", "commit": {"author": {"name": "Brooks Moses", "email": "brooks.moses@codesourcery.com", "date": "2007-04-30T19:14:04Z"}, "committer": {"name": "Brooks Moses", "email": "brooks@gcc.gnu.org", "date": "2007-04-30T19:14:04Z"}, "message": "double-int.c (mpz_set_double_int): Moved from tree-ssa-loop-niter.c.\n\n* double-int.c (mpz_set_double_int): Moved from\ntree-ssa-loop-niter.c.\n(mpz_get_double_int): Likewise; also, add option to wrap\nout-of-range integers.\n* double-int.h: New prototypes for above.\n* tree.c (get_static_type_bounds): Moved from\ntree-ssa-loop-niter.c; now returns TYPE_MIN_VALUE and\nTYPE_MAX_VALUE if they exist..\n* tree.h: New prototype for above.\n* tree-ssa-loop-niter.c: Adjust mpz_to_double_int and\nget_type_bounds calls.\n(mpz_set_double_int): Move to double-int.c.\n(get_type_bounds): Move to tree.c, rename to\nget_static_type_bounds.\n(mpz_to_double_int): Move to double-int.c, rename to\nmpz_get_double_int.\n\nFrom-SVN: r124304", "tree": {"sha": "6479ca4b9aae9944979b25e103b6a70c19c8e7fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6479ca4b9aae9944979b25e103b6a70c19c8e7fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/comments", "author": null, "committer": null, "parents": [{"sha": "0a21c1d2bae57035c0f46cca64e85f228c6b4388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a21c1d2bae57035c0f46cca64e85f228c6b4388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a21c1d2bae57035c0f46cca64e85f228c6b4388"}], "stats": {"total": 242, "additions": 152, "deletions": 90}, "files": [{"sha": "b1f1205eb41a8176800d86ced8d10d4034650da9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "patch": "@@ -1,3 +1,22 @@\n+2007-04-30  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\t* double-int.c (mpz_set_double_int): Moved from\n+\ttree-ssa-loop-niter.c.\n+\t(mpz_get_double_int): Likewise; also, add option to wrap\n+\tout-of-range integers.\n+\t* double-int.h: New prototypes for above.\n+\t* tree.c (get_static_type_bounds): Moved from\n+\ttree-ssa-loop-niter.c; now returns TYPE_MIN_VALUE and\n+\tTYPE_MAX_VALUE if they exist..\n+\t* tree.h: New prototype for above.\n+\t* tree-ssa-loop-niter.c: Adjust mpz_to_double_int and\n+\tget_type_bounds calls.\n+\t(mpz_set_double_int): Move to double-int.c.\n+\t(get_type_bounds): Move to tree.c, rename to\n+\tget_static_type_bounds.\n+\t(mpz_to_double_int): Move to double-int.c, rename to\n+\tmpz_get_double_int.\n+\n 2007-04-30  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/lib1funcs.asm (__umodsi3, __modsi3): Rearrange so that"}, {"sha": "8cbd3abc653e9b183c173ccf7810e9fca92b1906", "filename": "gcc/double-int.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "patch": "@@ -413,3 +413,81 @@ dump_double_int (FILE *file, double_int cst, bool uns)\n   for (i = n - 1; i >= 0; i--)\n     fprintf (file, \"%u\", digits[i]);\n }\n+\n+\n+/* Sets RESULT to VAL, taken unsigned if UNS is true and as signed\n+   otherwise.  */\n+\n+void\n+mpz_set_double_int (mpz_t result, double_int val, bool uns)\n+{\n+  bool negate = false;\n+  unsigned HOST_WIDE_INT vp[2];\n+\n+  if (!uns && double_int_negative_p (val))\n+    {\n+      negate = true;\n+      val = double_int_neg (val);\n+    }\n+\n+  vp[0] = val.low;\n+  vp[1] = (unsigned HOST_WIDE_INT) val.high;\n+  mpz_import (result, 2, -1, sizeof (HOST_WIDE_INT), 0, 0, vp);\n+\n+  if (negate)\n+    mpz_neg (result, result);\n+}\n+\n+/* Returns VAL converted to TYPE.  If WRAP is true, then out-of-range\n+   values of VAL will be wrapped; otherwise, they will be set to the\n+   appropriate minimum or maximum TYPE bound.  */\n+\n+double_int\n+mpz_get_double_int (tree type, mpz_t val, bool wrap)\n+{\n+  unsigned HOST_WIDE_INT *vp;\n+  size_t count, numb;\n+  double_int res;\n+\n+  if (!wrap)\n+    {  \n+      mpz_t min, max;\n+\n+      mpz_init (min);\n+      mpz_init (max);\n+      get_type_static_bounds (type, min, max);\n+\n+      if (mpz_cmp (val, min) < 0)\n+\tmpz_set (val, min);\n+      else if (mpz_cmp (val, max) > 0)\n+\tmpz_set (val, max);\n+\n+      mpz_clear (min);\n+      mpz_clear (max);\n+    }\n+\n+  /* Determine the number of unsigned HOST_WIDE_INT that are required\n+     for representing the value.  The code to calculate count is\n+     extracted from the GMP manual, section \"Integer Import and Export\":\n+     http://gmplib.org/manual/Integer-Import-and-Export.html  */\n+  numb = 8*sizeof(HOST_WIDE_INT);\n+  count = (mpz_sizeinbase (val, 2) + numb-1) / numb;\n+  if (count < 2)\n+    count = 2;\n+  vp = (unsigned HOST_WIDE_INT *) alloca (count * sizeof(HOST_WIDE_INT));\n+\n+  vp[0] = 0;\n+  vp[1] = 0;\n+  mpz_export (vp, &count, -1, sizeof (HOST_WIDE_INT), 0, 0, val);\n+\n+  gcc_assert (wrap || count <= 2);\n+\n+  res.low = vp[0];\n+  res.high = (HOST_WIDE_INT) vp[1];\n+\n+  res = double_int_ext (res, TYPE_PRECISION (type), TYPE_UNSIGNED (type));\n+  if (mpz_sgn (val) < 0)\n+    res = double_int_neg (res);\n+\n+  return res;\n+}"}, {"sha": "33641bd06dc366e3fe97bc778f9e47391f3eb12a", "filename": "gcc/double-int.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "patch": "@@ -21,6 +21,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #ifndef DOUBLE_INT_H\n #define DOUBLE_INT_H\n \n+#include <gmp.h>\n+#include \"coretypes.h\"\n+\n /* A large integer is currently represented as a pair of HOST_WIDE_INTs.\n    It therefore represents a number with precision of\n    2 * HOST_BITS_PER_WIDE_INT bits (it is however possible that the\n@@ -174,4 +177,10 @@ double_int_equal_p (double_int cst1, double_int cst2)\n   return cst1.low == cst2.low && cst1.high == cst2.high;\n }\n \n+/* Conversion to and from GMP integer representations.  */\n+\n+void mpz_set_double_int (mpz_t, double_int, bool);\n+double_int mpz_get_double_int (tree, mpz_t, bool);\n+\n+\n #endif /* DOUBLE_INT_H */"}, {"sha": "814b23a78432430d729fdfdfbe39be7f97428532", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 4, "deletions": 90, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "patch": "@@ -64,92 +64,6 @@ typedef struct\n   mpz_t below, up;\n } bounds;\n \n-/* Sets RESULT to VAL, taken unsigned if UNS is true and as signed\n-   otherwise.  */\n-\n-static void\n-mpz_set_double_int (mpz_t result, double_int val, bool uns)\n-{\n-  bool negate = false;\n-  unsigned HOST_WIDE_INT vp[2];\n-\n-  if (!uns && double_int_negative_p (val))\n-    {\n-      negate = true;\n-      val = double_int_neg (val);\n-    }\n-\n-  vp[0] = val.low;\n-  vp[1] = (unsigned HOST_WIDE_INT) val.high;\n-  mpz_import (result, 2, -1, sizeof (HOST_WIDE_INT), 0, 0, vp);\n-\n-  if (negate)\n-    mpz_neg (result, result);\n-}\n-\n-/* Stores bounds of TYPE to MIN and MAX.  */\n-\n-static void\n-get_type_bounds (tree type, mpz_t min, mpz_t max)\n-{\n-  if (TYPE_UNSIGNED (type))\n-    {\n-      mpz_set_ui (min, 0);\n-      mpz_set_double_int (max, double_int_mask (TYPE_PRECISION (type)), true);\n-    }\n-  else\n-    {\n-      double_int mx, mn;\n-      \n-      mx = double_int_mask (TYPE_PRECISION (type) - 1);\n-      mn = double_int_sext (double_int_add (mx, double_int_one),\n-\t\t\t    TYPE_PRECISION (type));\n-      mpz_set_double_int (max, mx, true);\n-      mpz_set_double_int (min, mn, false);\n-    }\n-}\n-\n-/* Returns VAL converted to TYPE.  If VAL does not fit in TYPE,\n-   the minimum or maximum value of the type is returned instead.  */\n-\n-static double_int\n-mpz_to_double_int (tree type, mpz_t val)\n-{\n-  mpz_t min, max;\n-  unsigned HOST_WIDE_INT vp[2];\n-  bool negate = false;\n-  size_t count;\n-  double_int res;\n-\n-  mpz_init (min);\n-  mpz_init (max);\n-  get_type_bounds (type, min, max);\n-\n-  if (mpz_cmp (val, min) < 0)\n-    mpz_set (val, min);\n-  else if (mpz_cmp (val, max) > 0)\n-    mpz_set (val, max);\n-\n-  if (mpz_sgn (val) < 0)\n-    negate = true;\n-\n-  vp[0] = 0;\n-  vp[1] = 0;\n-  mpz_export (vp, &count, -1, sizeof (HOST_WIDE_INT), 0, 0, val);\n-  gcc_assert (count <= 2);\n-  \n-  mpz_clear (min);\n-  mpz_clear (max);\n-\n-  res.low = vp[0];\n-  res.high = (HOST_WIDE_INT) vp[1];\n-\n-  res = double_int_ext (res, TYPE_PRECISION (type), TYPE_UNSIGNED (type));\n-  if (negate)\n-    res = double_int_neg (res);\n-\n-  return res;\n-}\n \n /* Splits expression EXPR to a variable part VAR and constant OFFSET.  */\n \n@@ -212,7 +126,7 @@ determine_value_range (tree type, tree var, mpz_t off,\n \n   /* If the computation may wrap, we know nothing about the value, except for\n      the range of the type.  */\n-  get_type_bounds (type, min, max);\n+  get_type_static_bounds (type, min, max);\n   if (!nowrap_type_p (type))\n     return;\n \n@@ -703,7 +617,7 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n \n   mpz_init (max);\n   number_of_iterations_ne_max (max, iv->no_overflow, c, s, bnds);\n-  niter->max = mpz_to_double_int (niter_type, max);\n+  niter->max = mpz_get_double_int (niter_type, max, false);\n   mpz_clear (max);\n \n   /* First the trivial cases -- when the step is 1.  */\n@@ -1081,7 +995,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \tniter->may_be_zero = fold_build2 (LT_EXPR, boolean_type_node,\n \t\t\t\t\t  iv1->base, iv0->base);\n       niter->niter = delta;\n-      niter->max = mpz_to_double_int (niter_type, bnds->up);\n+      niter->max = mpz_get_double_int (niter_type, bnds->up, false);\n       return true;\n     }\n \n@@ -1128,7 +1042,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   mpz_add (tmp, bnds->up, mstep);\n   mpz_sub_ui (tmp, tmp, 1);\n   mpz_fdiv_q (tmp, tmp, mstep);\n-  niter->max = mpz_to_double_int (niter_type, tmp);\n+  niter->max = mpz_get_double_int (niter_type, tmp, false);\n   mpz_clear (mstep);\n   mpz_clear (tmp);\n "}, {"sha": "472477c49ae5c4492ad6922dc2b60acafc3e12d4", "filename": "gcc/tree.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "patch": "@@ -6138,6 +6138,47 @@ int_fits_type_p (tree c, tree type)\n   return !fit_double_type (low, high, &low, &high, type);\n }\n \n+/* Stores bounds of an integer TYPE in MIN and MAX.  If TYPE has non-constant\n+   bounds or is a POINTER_TYPE, the maximum and/or minimum values that can be\n+   represented (assuming two's-complement arithmetic) within the bit\n+   precision of the type are returned instead.  */\n+\n+void\n+get_type_static_bounds (tree type, mpz_t min, mpz_t max)\n+{\n+  if (!POINTER_TYPE_P (type) && TYPE_MIN_VALUE (type)\n+      && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST)\n+    mpz_set_double_int (min, tree_to_double_int (TYPE_MIN_VALUE (type)),\n+\t\t\tTYPE_UNSIGNED (type));\n+  else\n+    {\n+      if (TYPE_UNSIGNED (type))\n+\tmpz_set_ui (min, 0);\n+      else\n+\t{\n+\t  double_int mn;\n+\t  mn = double_int_mask (TYPE_PRECISION (type) - 1);\n+\t  mn = double_int_sext (double_int_add (mn, double_int_one),\n+\t\t\t\tTYPE_PRECISION (type));\n+\t  mpz_set_double_int (min, mn, false);\n+\t}\n+    }\n+\n+  if (!POINTER_TYPE_P (type) && TYPE_MAX_VALUE (type) \n+      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST)\n+    mpz_set_double_int (max, tree_to_double_int (TYPE_MAX_VALUE (type)),\n+\t\t\tTYPE_UNSIGNED (type));\n+  else\n+    {\n+      if (TYPE_UNSIGNED (type))\n+\tmpz_set_double_int (max, double_int_mask (TYPE_PRECISION (type)),\n+\t\t\t    true);\n+      else\n+\tmpz_set_double_int (max, double_int_mask (TYPE_PRECISION (type) - 1),\n+\t\t\t    true);\n+    }\n+}\n+\n /* Subprogram of following function.  Called by walk_tree.\n \n    Return *TP if it is an automatic variable or parameter of the"}, {"sha": "c076fc1aa7a65bb84d2c24ebb16b46e8ec4f87a4", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "patch": "@@ -4539,6 +4539,7 @@ extern int objects_must_conflict_p (tree, tree);\n /* In tree.c */\n extern int really_constant_p (tree);\n extern int int_fits_type_p (tree, tree);\n+extern void get_type_static_bounds (tree, mpz_t, mpz_t);\n extern bool variably_modified_type_p (tree, tree);\n extern int tree_log2 (tree);\n extern int tree_floor_log2 (tree);"}]}