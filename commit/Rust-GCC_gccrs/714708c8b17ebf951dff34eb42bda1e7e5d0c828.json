{"sha": "714708c8b17ebf951dff34eb42bda1e7e5d0c828", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE0NzA4YzhiMTdlYmY5NTFkZmYzNGViNDJiZGExZTdlNWQwYzgyOA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-04-21T09:37:49Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-04-21T09:37:49Z"}, "message": "dwarf2-signal.h (SIGNAL_HANDLER): Name siginfo_t pointer arg.\n\n2002-04-19  David S. Miller  <davem@redhat.com>\n\n\t* include/dwarf2-signal.h (SIGNAL_HANDLER): Name siginfo_t pointer\n\targ.\n\t(MAKE_THROW_FRAME): Define for 32-bit and 64-bit sparc.\n\t(INIT_SEGV, INIT_FPE): Use direct __libc_sigaction installation\n\ton Sparc too.\n\t* include/sparc-signal.h (FLUSH_REGISTER_WINDOWS): Define properly\n\tfor 64-bit sparc.\n\t(MAKE_THROW_FRAME): Use long for sp/retaddr so 64-bit works.\n\t* sysdeps/sparc/locks.h: New file.\n\t* configure.in (SIGNAL_HANDLER): Set to include/sparc-signal.h\n\ton all sparc Solaris configurations.  Set to\n\tinclude/dwarf2-signal.h on sparc Linux.\n\t* configure: Regenerate\n\t* configure.host (can_unwind_signal): sparc*-linux* can do it now.\n\nFrom-SVN: r52575", "tree": {"sha": "a376bafb010afb2652958e6006378e2f08558082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a376bafb010afb2652958e6006378e2f08558082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/714708c8b17ebf951dff34eb42bda1e7e5d0c828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/714708c8b17ebf951dff34eb42bda1e7e5d0c828", "html_url": "https://github.com/Rust-GCC/gccrs/commit/714708c8b17ebf951dff34eb42bda1e7e5d0c828", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/714708c8b17ebf951dff34eb42bda1e7e5d0c828/comments", "author": null, "committer": null, "parents": [{"sha": "25c52eacb297f53e64231e5493be27834de44165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c52eacb297f53e64231e5493be27834de44165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c52eacb297f53e64231e5493be27834de44165"}], "stats": {"total": 212, "additions": 204, "deletions": 8}, "files": [{"sha": "7b889fe606c1c2c57a890c4d098c6b8617a83af0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=714708c8b17ebf951dff34eb42bda1e7e5d0c828", "patch": "@@ -1,3 +1,20 @@\n+2002-04-19  David S. Miller  <davem@redhat.com>\n+\n+\t* include/dwarf2-signal.h (SIGNAL_HANDLER): Name siginfo_t pointer\n+\targ.\n+\t(MAKE_THROW_FRAME): Define for 32-bit and 64-bit sparc.\n+\t(INIT_SEGV, INIT_FPE): Use direct __libc_sigaction installation\n+\ton Sparc too.\n+\t* include/sparc-signal.h (FLUSH_REGISTER_WINDOWS): Define properly\n+\tfor 64-bit sparc.\n+\t(MAKE_THROW_FRAME): Use long for sp/retaddr so 64-bit works.\n+\t* sysdeps/sparc/locks.h: New file.\n+\t* configure.in (SIGNAL_HANDLER): Set to include/sparc-signal.h\n+\ton all sparc Solaris configurations.  Set to\n+\tinclude/dwarf2-signal.h on sparc Linux.\n+\t* configure: Regenerate\n+\t* configure.host (can_unwind_signal): sparc*-linux* can do it now.\n+\n 2002-04-19  Hans Boehm <Hans_Boehm@hp.com>\n \n \t* configure: Rebuilt."}, {"sha": "711f39eedefdecff4d09e9f4a718b4bf3b4b3de5", "filename": "libjava/configure", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=714708c8b17ebf951dff34eb42bda1e7e5d0c828", "patch": "@@ -6465,7 +6465,7 @@ case \"${host}\" in\n  i?86-*-linux*)\n     SIGNAL_HANDLER=include/i386-signal.h\n     ;;\n- sparc-sun-solaris*)\n+ sparc*-sun-solaris*)\n     SIGNAL_HANDLER=include/sparc-signal.h\n     ;;\n # ia64-*)\n@@ -6481,6 +6481,9 @@ case \"${host}\" in\n  alpha*-*-linux*)\n     SIGNAL_HANDLER=include/dwarf2-signal.h\n     ;;\n+sparc*-*-linux*)\n+   SIGNAL_HANDLER=include/dwarf2-signal.h\n+   ;;\n  *mingw*)\n     SIGNAL_HANDLER=include/win32-signal.h\n     ;;"}, {"sha": "16e4cd8baa4e9d36966693039bcee43805411350", "filename": "libjava/configure.host", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=714708c8b17ebf951dff34eb42bda1e7e5d0c828", "patch": "@@ -125,6 +125,7 @@ case \"${host}\" in\n   i[34567]86*-linux* | \\\n   powerpc*-linux* | \\\n   alpha*-linux* | \\\n+  sparc*-linux* | \\\n   ia64-*)\n   \tcan_unwind_signal=yes\n \t;;"}, {"sha": "14ff72569f1f2e3154174054554b626d639e8e54", "filename": "libjava/configure.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=714708c8b17ebf951dff34eb42bda1e7e5d0c828", "patch": "@@ -867,7 +867,7 @@ case \"${host}\" in\n  i?86-*-linux*)\n     SIGNAL_HANDLER=include/i386-signal.h\n     ;;\n- sparc-sun-solaris*)\n+ sparc*-sun-solaris*)\n     SIGNAL_HANDLER=include/sparc-signal.h\n     ;;\n # ia64-*)\n@@ -883,6 +883,9 @@ case \"${host}\" in\n  alpha*-*-linux*)\n     SIGNAL_HANDLER=include/dwarf2-signal.h\n     ;;\n+ sparc*-*-linux*)\n+    SIGNAL_HANDLER=include/dwarf2-signal.h\n+    ;;\n  *mingw*)\n     SIGNAL_HANDLER=include/win32-signal.h\n     ;;"}, {"sha": "08287056705a16e2b233805af75d3e490250ff9d", "filename": "libjava/include/dwarf2-signal.h", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Finclude%2Fdwarf2-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Finclude%2Fdwarf2-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fdwarf2-signal.h?ref=714708c8b17ebf951dff34eb42bda1e7e5d0c828", "patch": "@@ -21,7 +21,7 @@ details.  */\n #undef HANDLE_FPE\n \n #define SIGNAL_HANDLER(_name)\t\\\n-static void _Jv_##_name (int, siginfo_t *, void *_p)\n+static void _Jv_##_name (int, siginfo_t *_sip, void *_p)\n \n class java::lang::Throwable;\n \n@@ -58,6 +58,53 @@ do\t\t\t\t\t\t\t\t\t\\\n   _sc->sc_ip++;\t\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n while (0)\n+#elif defined(__sparc__)\n+/* We could do the unwind of the signal frame quickly by hand here like\n+   sparc-signal.h does under Solaris, but that makes debugging unwind\n+   failures almost impossible.  */\n+#if !defined(__arch64__)\n+#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  /* Sparc-32 leaves PC pointing at a faulting instruction\t\t\\\n+   always.  So we adjust the saved PC to point to the following\t\t\\\n+   instruction; this is what the handler in libgcc expects.  */\t\t\\\n+  /* Note that we are lying to the unwinder here, which expects the\t\\\n+   faulting pc, not pc+1.  But we claim the unwind information can't\t\\\n+   be changed by such a ld or st instruction, so it doesn't matter. */\t\\\n+  struct sig_regs {\t\t\t\t\t\t\t\\\n+    unsigned int psr, pc, npc, y, u_regs[16];\t\t\t\t\\\n+  } *regp;\t\t\t\t\t\t\t\t\\\n+  unsigned int insn;\t\t\t\t\t\t\t\\\n+  __asm__ __volatile__(\"ld [%%i7 + 8], %0\" : \"=r\" (insn));\t\t\\\n+  if (insn == 0x821020d8)\t\t\t\t\t\t\\\n+    regp = (struct sig_regs *) _sip;\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    regp = (struct sig_regs *) (_sip + 1);\t\t\t\t\\\n+  regp->pc = regp->npc;\t\t\t\t\t\t\t\\\n+  regp->npc += 4;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+#else\n+#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  /* Sparc-64 leaves PC pointing at a faulting instruction\t\t\\\n+   always.  So we adjust the saved PC to point to the following\t\t\\\n+   instruction; this is what the handler in libgcc expects.  */\t\t\\\n+  /* Note that we are lying to the unwinder here, which expects the\t\\\n+   faulting pc, not pc+1.  But we claim the unwind information can't\t\\\n+   be changed by such a ld or st instruction, so it doesn't matter. */\t\\\n+  struct pt_regs {\t\t\t\t\t\t\t\\\n+    unsigned long u_regs[16];\t\t\t\t\t\t\\\n+    unsigned long tstate, tpc, tnpc;\t\t\t\t\t\\\n+    unsigned int y, fprs;\t\t\t\t\t\t\\\n+  } *regp = (struct pt_regs *) (_sip + 1);\t\t\t\t\\\n+  regp->tpc = regp->tnpc;\t\t\t\t\t\t\\\n+  regp->tnpc += 4;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+#endif\n #else\n #define MAKE_THROW_FRAME(_exception)\t\t\\\n do\t\t\t\t\t\t\\\n@@ -67,7 +114,7 @@ do\t\t\t\t\t\t\\\n while (0)\n #endif\n \n-#ifndef __ia64__\n+#if !(defined(__ia64__) || defined(__sparc__))\n #define INIT_SEGV\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n@@ -100,7 +147,7 @@ while (0)\n  * go away once all systems have pthreads libraries that are\n  * compiled with full unwind info.  */\n \n-#else  /* __ia64__ */\n+#else  /* __ia64__ || __sparc__ */\n \n // FIXME: We shouldn't be using libc_sigaction here, since it should\n // be glibc private.  But using syscall here would mean translating to\n@@ -136,5 +183,5 @@ do\t\t\t\t\t\t\t\t\\\n     __libc_sigaction (SIGFPE, &act, NULL);\t\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)  \n-#endif /* __ia64__ */\n+#endif /* __ia64__ || __sparc__ */\n #endif /* JAVA_SIGNAL_H */"}, {"sha": "8694fc598ed372786a73ff222681f518e73f9012", "filename": "libjava/include/sparc-signal.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Finclude%2Fsparc-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Finclude%2Fsparc-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fsparc-signal.h?ref=714708c8b17ebf951dff34eb42bda1e7e5d0c828", "patch": "@@ -20,17 +20,22 @@ details.  */\n #define SIGNAL_HANDLER(_name) \t\t\t\t\t\t\\\n static void _name (int _dummy, siginfo_t *_info, void *arg)\n \n+#ifdef __arch64__\n+#define FLUSH_REGISTER_WINDOWS\t\t\t\t\t\\\n+  asm volatile (\"flushw\");\n+#else\n #define FLUSH_REGISTER_WINDOWS\t\t\t\t\t\\\n   asm volatile (\"ta 3\");\n+#endif\n \n #define MAKE_THROW_FRAME(_exception)\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   ucontext_t *_context = (ucontext_t *) arg;                    \\\n   (void)_dummy;\t\t\t\t\t\t\t\\\n   (void)_info;\t\t\t\t\t\t\t\\\n-  register int sp = _context->uc_mcontext.gregs[REG_SP];\t\\\n-  register int retaddr = _context->uc_mcontext.gregs[REG_O7];\t\\\n+  register long sp = _context->uc_mcontext.gregs[REG_SP];\t\\\n+  register long retaddr = _context->uc_mcontext.gregs[REG_O7];\t\\\n   FLUSH_REGISTER_WINDOWS;\t\t\t\t\t\\\n   asm volatile (\"mov %0, %%i6; mov %1, %%i7\"\t\t\t\\\n \t\t: : \"r\"(sp), \"r\"(retaddr));\t\t\t\\"}, {"sha": "503417c98a68b3147cf0bcac5554bb54038a45ea", "filename": "libjava/sysdep/sparc/locks.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Fsysdep%2Fsparc%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714708c8b17ebf951dff34eb42bda1e7e5d0c828/libjava%2Fsysdep%2Fsparc%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fsparc%2Flocks.h?ref=714708c8b17ebf951dff34eb42bda1e7e5d0c828", "patch": "@@ -0,0 +1,120 @@\n+// locks.h - Thread synchronization primitives. Sparc implementation.\n+\n+/* Copyright (C) 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __SYSDEP_LOCKS_H__\n+#define __SYSDEP_LOCKS_H__\n+\n+typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n+\t\t\t\t/* address.\t\t\t\t*/\n+\n+#ifdef __arch64__\n+/* Sparc64 implementation, use cas instruction.  */\n+inline static bool\n+compare_and_swap(volatile obj_addr_t *addr,\n+\t\t obj_addr_t old,\n+\t\t obj_addr_t new_val)\n+{\n+  __asm__ __volatile__(\"casx [%2], %3, %0\\n\\t\"\n+\t\t       \"membar #StoreLoad | #StoreStore\"\n+\t\t       : \"=&r\" (new_val)\n+\t\t       : \"0\" (new_val), \"r\" (addr), \"r\" (old)\n+\t\t       : \"memory\");\n+\n+  return (new_val == old) ? true : false;\n+}\n+\n+inline static void\n+release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n+{\n+  __asm__ __volatile__(\"membar #StoreStore | #LoadStore\" : : : \"memory\");\n+  *(addr) = new_val;\n+}\n+\n+inline static bool\n+compare_and_swap_release(volatile obj_addr_t *addr,\n+\t\t  \t\t\t\t     obj_addr_t old,\n+\t\t\t\t\t\t     obj_addr_t new_val)\n+{\n+  return compare_and_swap(addr, old, new_val);\n+}\n+#else\n+/* Sparc32 implementation, use a spinlock.  */\n+static unsigned char __cas_lock = 0;\n+\n+inline static void\n+__cas_start_atomic(void)\n+{\n+  unsigned int tmp;\n+  __asm__ __volatile__(\n+\"1:\tldstub\t[%1], %0\\n\"\n+\"\torcc\t%0, 0x0, %g0\\n\"\n+\"\tbe\t3f\\n\"\n+\"\t nop\\n\"\n+\"2:\tldub\t[%1], %0\\n\"\n+\"\torcc\t%0, 0x0, %g0\\n\"\n+\"\tbne\t2b\\n\"\n+\"\t nop\\n\"\n+\"3:\"\t: \"=&r\" (tmp)\n+\t: \"r\" (&__cas_lock)\n+\t: \"memory\", \"cc\");\n+}\n+\n+inline static void\n+__cas_end_atomic(void)\n+{\n+  __asm__ __volatile__(\n+  \"stb %%g0, [%0]\"\n+  : /* no outputs */\n+  : \"r\" (&__cas_lock)\n+  : \"memory\");\n+}\n+\n+inline static bool\n+compare_and_swap(volatile obj_addr_t *addr,\n+\t\t obj_addr_t old,\n+\t\t obj_addr_t new_val)\n+{\n+  bool ret;\n+\n+  __cas_start_atomic ();\n+  if (*addr != old)\n+    {\n+      ret = false;\n+    }\n+  else\n+    {\n+      *addr = new_val;\n+      ret = true;\n+    }\n+  __cas_end_atomic ();\n+\n+  return ret;\n+}\n+\n+inline static void\n+release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n+{\n+  /* Technically stbar would be needed here but no sparc32\n+     system actually requires it.  Also the stbar would mean\n+     this code would not work on sparcv7 chips.  */\n+  __asm__ __volatile__(\"\" : : : \"memory\");\n+  *(addr) = new_val;\n+}\n+\n+inline static bool\n+compare_and_swap_release(volatile obj_addr_t *addr,\n+\t\t  \t\t\t\t     obj_addr_t old,\n+\t\t\t\t\t\t     obj_addr_t new_val)\n+{\n+  return compare_and_swap(addr, old, new_val);\n+}\n+#endif /* __arch64__ */\n+\n+#endif /* ! __SYSDEP_LOCKS_H__ */"}]}