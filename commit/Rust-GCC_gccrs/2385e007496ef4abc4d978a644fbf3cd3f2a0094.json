{"sha": "2385e007496ef4abc4d978a644fbf3cd3f2a0094", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM4NWUwMDc0OTZlZjRhYmM0ZDk3OGE2NDRmYmYzY2QzZjJhMDA5NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-07T12:24:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-07T12:24:31Z"}, "message": "[multiple changes]\n\n2010-10-07  Robert Dewar  <dewar@adacore.com>\n\n\t* scng.adb (Skip_Other_Format_Characters): New procedure\n\t(Start_Of_Wide_Character): New procedure\n\t(Scan): Use Start_Of_Wide_Character where appropriate\n\t(Scan): Improve error message for other_format chars in identifier\n\t(Scan): Allow other_format chars between tokens\n\n2010-10-07  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_util.adb (Safe_Prefixed_Reference): When removing side effects,\n\tAdd missing support for explicit dereferences.\n\n2010-10-07  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch10.adb, par-ch3.adb, par.adb: Minor reformatting.\n\nFrom-SVN: r165097", "tree": {"sha": "6cd2acd72a2a4954e6c1c0fce434c13e8a7e9ad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cd2acd72a2a4954e6c1c0fce434c13e8a7e9ad2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2385e007496ef4abc4d978a644fbf3cd3f2a0094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2385e007496ef4abc4d978a644fbf3cd3f2a0094", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2385e007496ef4abc4d978a644fbf3cd3f2a0094", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2385e007496ef4abc4d978a644fbf3cd3f2a0094/comments", "author": null, "committer": null, "parents": [{"sha": "0bfed5d4cd543a48e5826ef8eb7d4b39b2bbf94f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfed5d4cd543a48e5826ef8eb7d4b39b2bbf94f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bfed5d4cd543a48e5826ef8eb7d4b39b2bbf94f"}], "stats": {"total": 239, "additions": 161, "deletions": 78}, "files": [{"sha": "2901a1cb14c993827f5acf94da86df924ebe90e0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2385e007496ef4abc4d978a644fbf3cd3f2a0094", "patch": "@@ -1,3 +1,20 @@\n+2010-10-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* scng.adb (Skip_Other_Format_Characters): New procedure\n+\t(Start_Of_Wide_Character): New procedure\n+\t(Scan): Use Start_Of_Wide_Character where appropriate\n+\t(Scan): Improve error message for other_format chars in identifier\n+\t(Scan): Allow other_format chars between tokens\n+\n+2010-10-07  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_util.adb (Safe_Prefixed_Reference): When removing side effects,\n+\tAdd missing support for explicit dereferences.\n+\n+2010-10-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch10.adb, par-ch3.adb, par.adb: Minor reformatting.\n+\n 2010-10-07  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_disp.adb, exp_dist.adb, exp_util.ads, exp_util.adb,"}, {"sha": "112fe0451966d72b3944fb0d0ce050ee5467a336", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2385e007496ef4abc4d978a644fbf3cd3f2a0094", "patch": "@@ -4538,6 +4538,25 @@ package body Exp_Util is\n                  or else Ekind (Entity (Prefix (N))) = E_In_Parameter;\n             end if;\n \n+         --  If the prefix is an explicit dereference that is not access-to-\n+         --  constant then this construct is a variable reference, which means\n+         --  it is to be considered to have side effects if Variable_Ref is\n+         --  True.\n+\n+         --  Exception is an access to an entity that is a constant or an\n+         --  in-parameter.\n+\n+         elsif Nkind (Prefix (N)) = N_Explicit_Dereference\n+           and then not Is_Access_Constant (Etype (Prefix (Prefix (N))))\n+           and then Variable_Ref\n+         then\n+            declare\n+               DDT : constant Entity_Id :=\n+                       Designated_Type (Etype (Prefix (Prefix (N))));\n+            begin\n+               return Ekind_In (DDT, E_Constant, E_In_Parameter);\n+            end;\n+\n          --  The following test is the simplest way of solving a complex\n          --  problem uncovered by BB08-010: Side effect on loop bound that\n          --  is a subcomponent of a global variable:"}, {"sha": "c7dfee88150bebcd3b369df5c7cc37080c770fdd", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=2385e007496ef4abc4d978a644fbf3cd3f2a0094", "patch": "@@ -634,7 +634,6 @@ package body Ch10 is\n          --  Check we did not with any child units\n \n          Item := First (Context_Items (Comp_Unit_Node));\n-\n          while Present (Item) loop\n             if Nkind (Item) = N_With_Clause\n               and then Nkind (Name (Item)) /= N_Identifier"}, {"sha": "18188ba43b18da201b6942d93cd140d6daf5c647", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=2385e007496ef4abc4d978a644fbf3cd3f2a0094", "patch": "@@ -4335,23 +4335,23 @@ package body Ch3 is\n                Done := True;\n             end if;\n \n-            --  Normally an END terminates the scan for basic declarative\n-            --  items. The one exception is END RECORD, which is probably\n-            --  left over from some other junk.\n+         --  Normally an END terminates the scan for basic declarative items.\n+         --  The one exception is END RECORD, which is probably left over from\n+         --  some other junk.\n \n-            when Tok_End =>\n-               Save_Scan_State (Scan_State); -- at END\n-               Scan; -- past END\n+         when Tok_End =>\n+            Save_Scan_State (Scan_State); -- at END\n+            Scan; -- past END\n \n-               if Token = Tok_Record then\n-                  Error_Msg_SP (\"no RECORD for this `end record`!\");\n-                  Scan; -- past RECORD\n-                  TF_Semicolon;\n+            if Token = Tok_Record then\n+               Error_Msg_SP (\"no RECORD for this `end record`!\");\n+               Scan; -- past RECORD\n+               TF_Semicolon;\n \n-               else\n-                  Restore_Scan_State (Scan_State); -- to END\n-                  Done := True;\n-               end if;\n+            else\n+               Restore_Scan_State (Scan_State); -- to END\n+               Done := True;\n+            end if;\n \n          --  The following tokens which can only be the start of a statement\n          --  are considered to end a declarative part (i.e. we have a missing"}, {"sha": "8a0c9014e2e6c86628c8af8b54418464d449e214", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=2385e007496ef4abc4d978a644fbf3cd3f2a0094", "patch": "@@ -361,17 +361,17 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    function F return Boolean renames False;\n \n    Pf_Decl_Gins_Pbod_Rnam_Stub : constant Pf_Rec :=\n-                                             Pf_Rec'(F, T, T, T, T, T, F, F);\n+                                   Pf_Rec'(F, T, T, T, T, T, F, F);\n    Pf_Decl                     : constant Pf_Rec :=\n-                                             Pf_Rec'(F, T, F, F, F, F, F, F);\n+                                   Pf_Rec'(F, T, F, F, F, F, F, F);\n    Pf_Decl_Gins_Pbod_Rnam      : constant Pf_Rec :=\n-                                             Pf_Rec'(F, T, T, T, T, F, F, F);\n+                                   Pf_Rec'(F, T, T, T, T, F, F, F);\n    Pf_Decl_Pbod                : constant Pf_Rec :=\n-                                             Pf_Rec'(F, T, F, T, F, F, F, F);\n+                                   Pf_Rec'(F, T, F, T, F, F, F, F);\n    Pf_Pbod                     : constant Pf_Rec :=\n-                                             Pf_Rec'(F, F, F, T, F, F, F, F);\n+                                   Pf_Rec'(F, F, F, T, F, F, F, F);\n    Pf_Spcn                     : constant Pf_Rec :=\n-                                             Pf_Rec'(T, F, F, F, F, F, F, F);\n+                                   Pf_Rec'(T, F, F, F, F, F, F, F);\n    --  The above are the only allowed values of Pf_Rec arguments\n \n    type SS_Rec is record"}, {"sha": "d838445e9c1ccd54fbd22664d92d26b01610f90a", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 105, "deletions": 57, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2385e007496ef4abc4d978a644fbf3cd3f2a0094/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=2385e007496ef4abc4d978a644fbf3cd3f2a0094", "patch": "@@ -241,6 +241,14 @@ package body Scng is\n       --  past the closing quote of the string literal, Token and Token_Node\n       --  are set appropriately, and the checksum is updated.\n \n+      procedure Skip_Other_Format_Characters;\n+      --  Skips past any \"other format\" category characters at the current\n+      --  cursor location (does not skip past spaces or any other characters).\n+\n+      function Start_Of_Wide_Character return Boolean;\n+      --  Returns True if the scan pointer is pointing to the start of a wide\n+      --  character sequence, does not modify the scan pointer in any case.\n+\n       -----------------------\n       -- Check_End_Of_Line --\n       -----------------------\n@@ -1039,15 +1047,7 @@ package body Scng is\n                   Code := Get_Char_Code (C);\n                   Scan_Ptr := Scan_Ptr + 1;\n \n-               elsif (C = ESC\n-                        and then Wide_Character_Encoding_Method\n-                                   in WC_ESC_Encoding_Method)\n-                 or else (C in Upper_Half_Character\n-                            and then Upper_Half_Encoding)\n-                 or else (C = '['\n-                            and then Source (Scan_Ptr + 1) = '\"'\n-                            and then Identifier_Char (Source (Scan_Ptr + 2)))\n-               then\n+               elsif Start_Of_Wide_Character then\n                   Wptr := Scan_Ptr;\n                   Scan_Wide (Source, Scan_Ptr, Code, Err);\n \n@@ -1109,6 +1109,62 @@ package body Scng is\n          return;\n       end Slit;\n \n+      ----------------------------------\n+      -- Skip_Other_Format_Characters --\n+      ----------------------------------\n+\n+      procedure Skip_Other_Format_Characters is\n+         P    : Source_Ptr;\n+         Code : Char_Code;\n+         Err  : Boolean;\n+\n+      begin\n+         while Start_Of_Wide_Character loop\n+            P := Scan_Ptr;\n+            Scan_Wide (Source, Scan_Ptr, Code, Err);\n+\n+            if not Is_UTF_32_Other (UTF_32 (Code)) then\n+               Scan_Ptr := P;\n+               return;\n+            end if;\n+         end loop;\n+      end Skip_Other_Format_Characters;\n+\n+      -----------------------------\n+      -- Start_Of_Wide_Character --\n+      -----------------------------\n+\n+      function Start_Of_Wide_Character return Boolean is\n+         C : constant Character := Source (Scan_Ptr);\n+\n+      begin\n+         --  ESC encoding method with ESC present\n+\n+         if C = ESC\n+           and then Wide_Character_Encoding_Method in WC_ESC_Encoding_Method\n+         then\n+            return True;\n+\n+         --  Upper half character with upper half encoding\n+\n+         elsif C in Upper_Half_Character and then Upper_Half_Encoding then\n+            return True;\n+\n+         --  Brackets encoding\n+\n+         elsif C = '['\n+           and then Source (Scan_Ptr + 1) = '\"'\n+           and then Identifier_Char (Source (Scan_Ptr + 2))\n+         then\n+            return True;\n+\n+         --  Not the start of a wide character\n+\n+         else\n+            return False;\n+         end if;\n+      end Start_Of_Wide_Character;\n+\n    --  Start of processing for Scan\n \n    begin\n@@ -1513,12 +1569,7 @@ package body Scng is\n                   --  If we have a wide character, we have to scan it out,\n                   --  because it might be a legitimate line terminator\n \n-                  elsif (Source (Scan_Ptr) = ESC\n-                           and then Identifier_Char (ESC))\n-                    or else\n-                         (Source (Scan_Ptr) in Upper_Half_Character\n-                            and then Upper_Half_Encoding)\n-                  then\n+                  elsif Start_Of_Wide_Character then\n                      declare\n                         Wptr : constant Source_Ptr := Scan_Ptr;\n                         Code : Char_Code;\n@@ -1626,18 +1677,7 @@ package body Scng is\n             else\n                --  Case of wide character literal\n \n-               if (Source (Scan_Ptr) = ESC\n-                     and then\n-                    Wide_Character_Encoding_Method in WC_ESC_Encoding_Method)\n-                 or else\n-                   (Source (Scan_Ptr) in Upper_Half_Character\n-                     and then\n-                    Upper_Half_Encoding)\n-                 or else\n-                   (Source (Scan_Ptr) = '['\n-                     and then\n-                    Source (Scan_Ptr + 1) = '\"')\n-               then\n+               if Start_Of_Wide_Character then\n                   Wptr := Scan_Ptr;\n                   Scan_Wide (Source, Scan_Ptr, Code, Err);\n                   Accumulate_Checksum (Code);\n@@ -1872,6 +1912,10 @@ package body Scng is\n \n             Nlit;\n \n+            --  Check for proper delimiter, ignoring other format characters\n+\n+            Skip_Other_Format_Characters;\n+\n             if Identifier_Char (Source (Scan_Ptr)) then\n                Error_Msg_S\n                  (\"delimiter required between literal and identifier\");\n@@ -2039,6 +2083,12 @@ package body Scng is\n             elsif Is_UTF_32_Space (Cat) then\n                goto Scan_Next_Character;\n \n+            --  If other format character, ignore and keep scanning (again we\n+            --  do not include in the checksum) (this is for AI-0079).\n+\n+            elsif Is_UTF_32_Other (Cat) then\n+               goto Scan_Next_Character;\n+\n             --  If OK wide line terminator, terminate current line\n \n             elsif Is_UTF_32_Line_Terminator (UTF_32 (Code)) then\n@@ -2063,16 +2113,6 @@ package body Scng is\n                Underline_Found := False;\n                goto Scan_Identifier;\n \n-            --  Other format character is an error (at start of identifier)\n-\n-            elsif Is_UTF_32_Other (Cat) then\n-               Error_Msg\n-                 (\"identifier cannot start with other format character\", Wptr);\n-               Scan_Ptr := Wptr;\n-               Name_Len := 0;\n-               Underline_Found := False;\n-               goto Scan_Identifier;\n-\n             --  Extended digit character is an error. Could be bad start of\n             --  identifier or bad literal. Not worth doing too much to try to\n             --  distinguish these cases, but we will do a little bit.\n@@ -2255,6 +2295,33 @@ package body Scng is\n                   --  Here if not a normal identifier character\n \n                   else\n+                     Cat := Get_Category (UTF_32 (Code));\n+\n+                     --  Wide character in Unicode category \"Other, Format\"\n+                     --  is not accepted in an identifier. This is because it\n+                     --  it is considered a security risk (AI-0091).\n+\n+                     --  However, it is OK for such a character to appear at\n+                     --  the end of an identifier.\n+\n+                     if Is_UTF_32_Other (Cat) then\n+                        if not Identifier_Char (Source (Scan_Ptr)) then\n+                           goto Scan_Identifier_Complete;\n+                        else\n+                           Error_Msg\n+                             (\"identifier cannot contain other_format \"\n+                              & \"character\", Wptr);\n+                           goto Scan_Identifier;\n+                        end if;\n+\n+                     --  Wide character in category Separator,Space terminates\n+\n+                     elsif Is_UTF_32_Space (Cat) then\n+                        goto Scan_Identifier_Complete;\n+                     end if;\n+\n+                     --  Here if wide character is part of the identifier\n+\n                      --  Make sure we are allowing wide characters in\n                      --  identifiers. Note that we allow wide character\n                      --  notation for an OK identifier character. This in\n@@ -2267,11 +2334,9 @@ package body Scng is\n                        and then Ada_Version < Ada_05\n                      then\n                         Error_Msg\n-                       (\"wide character not allowed in identifier\", Wptr);\n+                          (\"wide character not allowed in identifier\", Wptr);\n                      end if;\n \n-                     Cat := Get_Category (UTF_32 (Code));\n-\n                      --  If OK letter, store it folding to upper case. Note\n                      --  that we include the folded letter in the checksum.\n \n@@ -2311,23 +2376,6 @@ package body Scng is\n                            Underline_Found := True;\n                         end if;\n \n-                     --  Wide character in Unicode category \"Other, Format\"\n-                     --  is accepted in an identifier, but is ignored and not\n-                     --  stored. It seems reasonable to exclude it from the\n-                     --  checksum.\n-\n-                     --  Note that it is correct (see AI-395) to simply strip\n-                     --  other format characters, before testing for double\n-                     --  underlines, or for reserved words).\n-\n-                     elsif Is_UTF_32_Other (Cat) then\n-                        null;\n-\n-                     --  Wide character in category Separator,Space terminates\n-\n-                     elsif Is_UTF_32_Space (Cat) then\n-                        goto Scan_Identifier_Complete;\n-\n                      --  Any other wide character is not acceptable\n \n                      else"}]}