{"sha": "57bfa49ae1ca6b049392285801bb1438e38a911a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdiZmE0OWFlMWNhNmIwNDkzOTIyODU4MDFiYjE0MzhlMzhhOTExYQ==", "commit": {"author": {"name": "Roman Zippel", "email": "zippel@linux-m68k.org", "date": "2001-08-31T22:54:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-08-31T22:54:19Z"}, "message": "expmed.c (store_bit_field): Update to patch from 2001-08-27: move adjustment of bitpos instead.\n\n        * expmed.c (store_bit_field): Update to patch from 2001-08-27:\n        move adjustment of bitpos instead.\n\nFrom-SVN: r45338", "tree": {"sha": "880c6af2091fa66bdabd679d60dc406fd0219dec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/880c6af2091fa66bdabd679d60dc406fd0219dec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57bfa49ae1ca6b049392285801bb1438e38a911a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57bfa49ae1ca6b049392285801bb1438e38a911a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57bfa49ae1ca6b049392285801bb1438e38a911a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57bfa49ae1ca6b049392285801bb1438e38a911a/comments", "author": null, "committer": null, "parents": [{"sha": "4504a6554658e2b23a73856e99c50bc70ca6a324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4504a6554658e2b23a73856e99c50bc70ca6a324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4504a6554658e2b23a73856e99c50bc70ca6a324"}], "stats": {"total": 23, "additions": 14, "deletions": 9}, "files": [{"sha": "e03aa816e481653a6da0e4dcc45961dbd1a6e984", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bfa49ae1ca6b049392285801bb1438e38a911a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bfa49ae1ca6b049392285801bb1438e38a911a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57bfa49ae1ca6b049392285801bb1438e38a911a", "patch": "@@ -1,3 +1,8 @@\n+2001-08-30  Roman Zippel  <zippel@linux-m68k.org>\n+\n+\t* expmed.c (store_bit_field): Update to patch from 2001-08-27:\n+\tmove adjustment of bitpos instead.\n+\n 2001-08-31  Zack Weinberg  <zack@codesourcery.com>\n \n \t* function.c: Remove all_functions.  Make outer_function_chain"}, {"sha": "8bc66b27cd4f6c5bbedbe173b6300308094e2773", "filename": "gcc/expmed.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bfa49ae1ca6b049392285801bb1438e38a911a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bfa49ae1ca6b049392285801bb1438e38a911a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=57bfa49ae1ca6b049392285801bb1438e38a911a", "patch": "@@ -330,14 +330,6 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       op0 = SUBREG_REG (op0);\n     }\n \n-  /* If OP0 is a register, BITPOS must count within a word.\n-     But as we have it, it counts within whatever size OP0 now has.\n-     On a bigendian machine, these are not the same, so convert.  */\n-  if (BYTES_BIG_ENDIAN\n-      && GET_CODE (op0) != MEM\n-      && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n-    bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n-\n   value = protect_from_queue (value, 0);\n \n   if (flag_force_mem)\n@@ -350,7 +342,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n      done with a simple store.  For targets that support fast unaligned\n      memory, any naturally sized, unit aligned field can be done directly.  */\n      \n-  if (bitnum == 0\n+  if (bitpos == 0\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n       && (GET_CODE (op0) != MEM\n \t  ? (GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n@@ -401,6 +393,14 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       }\n   }\n \n+  /* If OP0 is a register, BITPOS must count within a word.\n+     But as we have it, it counts within whatever size OP0 now has.\n+     On a bigendian machine, these are not the same, so convert.  */\n+  if (BYTES_BIG_ENDIAN\n+      && GET_CODE (op0) != MEM\n+      && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n+    bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n+\n   /* Storing an lsb-aligned field in a register\n      can be done with a movestrict instruction.  */\n "}]}