{"sha": "ad238e4ff7d574bf58d5345ca050949c866867d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyMzhlNGZmN2Q1NzRiZjU4ZDUzNDVjYTA1MDk0OWM4NjY4NjdkMw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2005-10-23T20:43:54Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2005-10-23T20:43:54Z"}, "message": "re PR libfortran/23272 ([mingw32] inquire via filename fails)\n\n\tPR libfortran/23272\n\t* acinclude.m4 (LIBGFOR_CHECK_WORKING_STAT): New check.\n\t* configure.ac: Use LIBGFOR_CHECK_WORKING_STAT.\n\t* Makefile.in: Regenerate.\n\t* aclocal.m4: Regenerate.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\t* io/unix.c (compare_file_filename): Add fallback case for\n\tsystems without working stat.\n\t* io/open.c (already_open): Correct call to\n\tcompare_file_filename.\n\t* io/io.h: Correct proto for compare_file_filename.\n\nFrom-SVN: r105824", "tree": {"sha": "5d5bd3e427e9311346a6f6558c309b3c7348fc9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d5bd3e427e9311346a6f6558c309b3c7348fc9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad238e4ff7d574bf58d5345ca050949c866867d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad238e4ff7d574bf58d5345ca050949c866867d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad238e4ff7d574bf58d5345ca050949c866867d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad238e4ff7d574bf58d5345ca050949c866867d3/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f700e6de038a05c3068dac9199b21bbdc70c2e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f700e6de038a05c3068dac9199b21bbdc70c2e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f700e6de038a05c3068dac9199b21bbdc70c2e9"}], "stats": {"total": 159, "additions": 153, "deletions": 6}, "files": [{"sha": "12bf51a5027bc262b1e63f7dfca3fbaba8f44776", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ad238e4ff7d574bf58d5345ca050949c866867d3", "patch": "@@ -1,3 +1,18 @@\n+2005-10-23  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR libfortran/23272\n+\t* acinclude.m4 (LIBGFOR_CHECK_WORKING_STAT): New check.\n+\t* configure.ac: Use LIBGFOR_CHECK_WORKING_STAT.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* aclocal.m4: Regenerate.\n+\t* io/unix.c (compare_file_filename): Add fallback case for\n+\tsystems without working stat.\n+\t* io/open.c (already_open): Correct call to\n+\tcompare_file_filename.\n+\t* io/io.h: Correct proto for compare_file_filename.\n+\n 2005-10-23  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* runtime/fpu.c: Add _GNU_SOURCE definition."}, {"sha": "a94dafafacb35d25da4c8bdd8809cebca8dc069e", "filename": "libgfortran/acinclude.m4", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Facinclude.m4?ref=ad238e4ff7d574bf58d5345ca050949c866867d3", "patch": "@@ -349,3 +349,38 @@ esac])]\n if test x\"$have_broken_fpclassify\" = xyes; then\n   AC_DEFINE(HAVE_BROKEN_FPCLASSIFY, 1, [Define if fpclassify is broken.])\n fi])\n+\n+dnl Check whether the st_ino and st_dev stat fields taken together uniquely\n+dnl identify the file within the system. This is should be true for POSIX\n+dnl systems; it is known to be false on mingw32.\n+AC_DEFUN([LIBGFOR_CHECK_WORKING_STAT], [\n+  AC_CACHE_CHECK([whether the target stat is reliable],\n+                  have_working_stat, [\n+  AC_TRY_RUN([\n+#include <stdio.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+\n+int main ()\n+{ \n+  FILE *f, *g;\n+  struct stat st1, st2;\n+\n+  f = fopen (\"foo\", \"w\");\n+  g = fopen (\"bar\", \"w\");\n+  if (stat (\"foo\", &st1) != 0 || stat (\"bar\", &st2))\n+    return 1;\n+  if (st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)\n+    return 1;\n+  fclose(f);\n+  fclose(g);\n+  return 0;\n+}], have_working_stat=yes, have_working_stat=no, [\n+case \"${target}\" in\n+  *mingw*) have_working_stat=no ;;\n+  *) have_working_stat=yes;;\n+esac])])\n+if test x\"$have_working_stat\" = xyes; then\n+  AC_DEFINE(HAVE_WORKING_STAT, 1, [Define if target has a reliable stat.])\n+fi])"}, {"sha": "8d6f6d4b2044d2430d948f74b2002798a8f1f911", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=ad238e4ff7d574bf58d5345ca050949c866867d3", "patch": "@@ -600,6 +600,9 @@\n /* Define if target can unlink open files. */\n #undef HAVE_UNLINK_OPEN_FILE\n \n+/* Define if target has a reliable stat. */\n+#undef HAVE_WORKING_STAT\n+\n /* libm includes y0 */\n #undef HAVE_Y0\n "}, {"sha": "b3cc868364c952739147b24bd7f01dff1891095a", "filename": "libgfortran/configure", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=ad238e4ff7d574bf58d5345ca050949c866867d3", "patch": "@@ -19353,6 +19353,82 @@ _ACEOF\n \n fi\n \n+# Check whether the system has a working stat()\n+\n+  echo \"$as_me:$LINENO: checking whether the target stat is reliable\" >&5\n+echo $ECHO_N \"checking whether the target stat is reliable... $ECHO_C\" >&6\n+if test \"${have_working_stat+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+\n+  if test \"$cross_compiling\" = yes; then\n+\n+case \"${target}\" in\n+  *mingw*) have_working_stat=no ;;\n+  *) have_working_stat=yes;;\n+esac\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+#include <stdio.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+\n+int main ()\n+{\n+  FILE *f, *g;\n+  struct stat st1, st2;\n+\n+  f = fopen (\"foo\", \"w\");\n+  g = fopen (\"bar\", \"w\");\n+  if (stat (\"foo\", &st1) != 0 || stat (\"bar\", &st2))\n+    return 1;\n+  if (st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)\n+    return 1;\n+  fclose(f);\n+  fclose(g);\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  have_working_stat=yes\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+( exit $ac_status )\n+have_working_stat=no\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+fi\n+echo \"$as_me:$LINENO: result: $have_working_stat\" >&5\n+echo \"${ECHO_T}$have_working_stat\" >&6\n+if test x\"$have_working_stat\" = xyes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_WORKING_STAT 1\n+_ACEOF\n+\n+fi\n+\n # Fallback in case isfinite is not available.\n echo \"$as_me:$LINENO: checking for finite in -lm\" >&5\n echo $ECHO_N \"checking for finite in -lm... $ECHO_C\" >&6"}, {"sha": "59354c9e18850aaa6659a7ba552b061c08bec913", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=ad238e4ff7d574bf58d5345ca050949c866867d3", "patch": "@@ -337,6 +337,9 @@ LIBGFOR_CHECK_FOR_BROKEN_ISNAN\n # Check for a fpclassify macro that works on long doubles.\n LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY\n \n+# Check whether the system has a working stat()\n+LIBGFOR_CHECK_WORKING_STAT\n+\n # Fallback in case isfinite is not available.\n AC_CHECK_LIB([m],[finite],[AC_DEFINE([HAVE_FINITE],[1],[libm includes finite])])\n "}, {"sha": "5e3adbc42d93f05da4d9a99edd6980f3424a63d0", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=ad238e4ff7d574bf58d5345ca050949c866867d3", "patch": "@@ -450,7 +450,7 @@ internal_proto(output_stream);\n extern stream *error_stream (void);\n internal_proto(error_stream);\n \n-extern int compare_file_filename (stream *, const char *, int);\n+extern int compare_file_filename (gfc_unit *, const char *, int);\n internal_proto(compare_file_filename);\n \n extern gfc_unit *find_file (void);"}, {"sha": "203964b5dea8ac5727c64856610d0b244a2474a9", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=ad238e4ff7d574bf58d5345ca050949c866867d3", "patch": "@@ -415,7 +415,7 @@ already_open (gfc_unit * u, unit_flags * flags)\n   /* If the file is connected to something else, close it and open a\n      new unit.  */\n \n-  if (!compare_file_filename (u->s, ioparm.file, ioparm.file_len))\n+  if (!compare_file_filename (u, ioparm.file, ioparm.file_len))\n     {\n       if (close_unit (u))\n \t{"}, {"sha": "2026a3649278d75ca46f53f55ceaa69019e55ada", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad238e4ff7d574bf58d5345ca050949c866867d3/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=ad238e4ff7d574bf58d5345ca050949c866867d3", "patch": "@@ -1287,10 +1287,13 @@ init_error_stream (void)\n  * filename. */\n \n int\n-compare_file_filename (stream * s, const char *name, int len)\n+compare_file_filename (gfc_unit *u, const char *name, int len)\n {\n   char path[PATH_MAX + 1];\n-  struct stat st1, st2;\n+  struct stat st1;\n+#ifdef HAVE_WORKING_STAT\n+  struct stat st2;\n+#endif\n \n   if (unpack_filename (path, name, len))\n     return 0;\t\t\t/* Can't be the same */\n@@ -1301,9 +1304,14 @@ compare_file_filename (stream * s, const char *name, int len)\n   if (stat (path, &st1) < 0)\n     return 0;\n \n-  fstat (((unix_stream *) s)->fd, &st2);\n-\n+#ifdef HAVE_WORKING_STAT\n+  fstat (((unix_stream *) (u->s))->fd, &st2);\n   return (st1.st_dev == st2.st_dev) && (st1.st_ino == st2.st_ino);\n+#else\n+  if (len != u->file_len)\n+    return 0;\n+  return (memcmp(path, u->file, len) == 0);\n+#endif\n }\n \n \n@@ -1312,15 +1320,22 @@ compare_file_filename (stream * s, const char *name, int len)\n static gfc_unit *\n find_file0 (gfc_unit * u, struct stat *st1)\n {\n+#ifdef HAVE_WORKING_STAT\n   struct stat st2;\n+#endif\n   gfc_unit *v;\n \n   if (u == NULL)\n     return NULL;\n \n+#ifdef HAVE_WORKING_STAT\n   if (fstat (((unix_stream *) u->s)->fd, &st2) >= 0 &&\n       st1->st_dev == st2.st_dev && st1->st_ino == st2.st_ino)\n     return u;\n+#else\n+  if (compare_string(u->file_len, u->file, ioparm.file_len, ioparm.file) == 0)\n+    return u;\n+#endif\n \n   v = find_file0 (u->left, st1);\n   if (v != NULL)"}]}