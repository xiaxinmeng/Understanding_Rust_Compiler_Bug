{"sha": "09d0a1f33d910422b4674d8635b8b99bcb20ae5d", "node_id": "C_kwDOANBUbNoAKDA5ZDBhMWYzM2Q5MTA0MjJiNDY3NGQ4NjM1YjhiOTliY2IyMGFlNWQ", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2023-03-28T01:21:13Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2023-03-28T01:21:13Z"}, "message": "CRIS: Add peephole2 to handle gcc.target/cris/rld-legit1.c for LRA\n\nThe test-case gcc.target/cris/rld-legit1.c is a reduced\ntest-case that required defining LEGITIMIZE_RELOAD_ADDRESS\nto stop the address from being decomposed into several insns\nby reload.  Valid but suboptimal code was generated.\n\n(Before implementing that hook for CRIS, the same test-case\nalso exposed a bug in reload, and a fix was committed to\navoid an ICE; see e.g. git r0-71992-gff0d9879ab0f30 and\nrelated commits.  But, post-cc0, reload no longer handles\nthis test-case without LEGITIMIZE_RELOAD_ADDRESS helping and\nthere'd again an be ICE for CRIS (again: only if\nLEGITIMIZE_RELOAD_ADDRESS is disabled).  There's a patch to\nreload to fix that, at\nhttps://gcc.gnu.org/pipermail/gcc-patches/2023-February/612039.html)\n\nBut, LRA also does not handle that test-case gracefully, and\nlike reload without LEGITIMIZE_RELOAD_ADDRESS for CRIS,\ndecomposes the address into a suboptimal (but valid)\nsequence, about as messy as that from reload, and\ngcc.target/cris/rld-legit1.c would regress for LRA.  There's\nnothing equivalent to LEGITIMIZE_RELOAD_ADDRESS for LRA.\n(Stepping through LRA, I can't find an obvious place where\nto put such a hook.  Granted, I haven't seen this kind of\nmessy decomposition in other code, so I'm not insisting a\nLEGITIMIZE_RELOAD_ADDRESS-like hook is a good idea.)\n\nThese new peephole2's are required to not regress\ngcc.target/cris/rld-legit1.c with LRA enabled for CRIS.\nThey don't appear to otherwise make a difference for neither\nlibgcc, newlib libc, my own at-a-glance tests nor coremark,\nfor neither LRA nor reload.\n\n\t* config/cris/cris.md (BW2): New mode-iterator.\n\t(lra_szext_decomposed, lra_szext_decomposed_indirect_with_offset): New\n\tpeephole2s.", "tree": {"sha": "c8ec0d50825f233e97f10b053cf5272ba6f083c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8ec0d50825f233e97f10b053cf5272ba6f083c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09d0a1f33d910422b4674d8635b8b99bcb20ae5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d0a1f33d910422b4674d8635b8b99bcb20ae5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09d0a1f33d910422b4674d8635b8b99bcb20ae5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d0a1f33d910422b4674d8635b8b99bcb20ae5d/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75be4badfeda2448383429f6061e095afd5a4ee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75be4badfeda2448383429f6061e095afd5a4ee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75be4badfeda2448383429f6061e095afd5a4ee5"}], "stats": {"total": 50, "additions": 50, "deletions": 0}, "files": [{"sha": "366b4bc304bfd09681d7a47224298e48b0caacbe", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d0a1f33d910422b4674d8635b8b99bcb20ae5d/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d0a1f33d910422b4674d8635b8b99bcb20ae5d/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=09d0a1f33d910422b4674d8635b8b99bcb20ae5d", "patch": "@@ -183,6 +183,10 @@\n \n (define_mode_iterator WD [SI HI])\n (define_mode_iterator BW [HI QI])\n+\n+; Another \"BW\" for use where an independent iteration is needed.\n+(define_mode_iterator BW2 [HI QI])\n+\n (define_mode_attr S [(SI \"HI\") (HI \"QI\")])\n (define_mode_attr s [(SI \"hi\") (HI \"qi\")])\n (define_mode_attr m [(SI \".d\") (HI \".w\") (QI \".b\")])\n@@ -2883,6 +2887,52 @@\n   operands[3] = gen_rtx_ZERO_EXTEND (SImode, op1);\n   operands[4] = GEN_INT (trunc_int_for_mode (INTVAL (operands[1]), QImode));\n })\n+\n+;; Fix a decomposed szext: fuse it with the memory operand of the\n+;; load.  This is typically the sign-extension part of a decomposed\n+;; \"indirect offset\" address.\n+(define_peephole2 ; lra_szext_decomposed\n+  [(parallel\n+    [(set (match_operand:BW 0 \"register_operand\")\n+\t  (match_operand:BW 1 \"memory_operand\"))\n+     (clobber (reg:CC CRIS_CC0_REGNUM))])\n+   (parallel\n+    [(set (match_operand:SI 2 \"register_operand\") (szext:SI (match_dup 0)))\n+     (clobber (reg:CC CRIS_CC0_REGNUM))])]\n+  \"REGNO (operands[0]) == REGNO (operands[2])\n+   || peep2_reg_dead_p (2, operands[0])\"\n+  [(parallel\n+    [(set (match_dup 2) (szext:SI (match_dup 1)))\n+     (clobber (reg:CC CRIS_CC0_REGNUM))])])\n+\n+;; Re-compose a decomposed \"indirect offset\" address for a szext\n+;; operation.  The non-clobbering \"addi\" is generated by LRA.\n+;; This and lra_szext_decomposed is covered by cris/rld-legit1.c.\n+(define_peephole2 ; lra_szext_decomposed_indirect_with_offset\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\")\n+\t  (sign_extend:SI (mem:BW (match_operand:SI 1 \"register_operand\"))))\n+     (clobber (reg:CC CRIS_CC0_REGNUM))])\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0) (match_operand:SI 2 \"register_operand\")))\n+   (parallel\n+    [(set (match_operand:SI 3 \"register_operand\")\n+\t  (szext:SI (mem:BW2 (match_dup 0))))\n+     (clobber (reg:CC CRIS_CC0_REGNUM))])]\n+  \"(REGNO (operands[0]) == REGNO (operands[3])\n+    || peep2_reg_dead_p (3, operands[0]))\n+   && (REGNO (operands[0]) == REGNO (operands[1])\n+       || peep2_reg_dead_p (3, operands[0]))\"\n+  [(parallel\n+    [(set\n+      (match_dup 3)\n+      (szext:SI\n+       (mem:BW2 (plus:SI (szext:SI (mem:BW (match_dup 1))) (match_dup 2)))))\n+     (clobber (reg:CC CRIS_CC0_REGNUM))])])\n+\n+;; Add operations with similar or same decomposed addresses here, when\n+;; encountered - but only when covered by mentioned test-cases for at\n+;; least one of the cases generalized in the pattern.\n \f\n ;; Local variables:\n ;; mode:emacs-lisp"}]}