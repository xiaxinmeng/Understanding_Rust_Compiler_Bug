{"sha": "9965d119133a5cb80938b829d28fa45777667a0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk2NWQxMTkxMzNhNWNiODA5MzhiODI5ZDI4ZmE0NTc3NzY2N2EwYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-02-05T11:45:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-02-05T11:45:16Z"}, "message": "invoke.texi (-fdump-class-layout): Document.\n\ngcc:\n\t* invoke.texi (-fdump-class-layout): Document.\n\t(-fdump-translation-unit): Use `=' as filename separator.\ncp:\n\tFix specification and implementation bugs in V3 ABI\n\tconstruction vtables.\n\t* cp-tree.h (flag_dump_class_layout): New flag.\n\t(BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P): Remove.\n\t(BINFO_LOST_PRIMARY_P): New flag.\n\t(SET_BINFO_NEW_VTABLE_MARKED): Adjust asserts.\n\t(BINFO_PRIMARY_MARKED_P): Rename to ...\n\t(BINFO_PRIMARY_P): ... here.\n\t(binfo_via_virtual): New prototype.\n\t* decl2.c (flag_dump_class_layout): New flag.\n\t(cxx_decode_option): Set it. Adjust -fdump-translation-unit to\n\tuse `=' as a file name separator.\n\t* init.c (dfs_initialize_vtbl_ptrs): Walk into virtual primary\n\tbases.\n\t(build_vtbl_address): If this is a virtual primary base, then\n\tget the vtbl of what it is ultimately primary for.\n\t* search.c (dfs_skip_nonprimary_vbases_unmarkedp): Adjust\n\tfor BINFO_PRIMARY_P.\n\t(dfs_skip_nonprimary_vbases_markedp): Likewise.\n\t(get_shared_vbase_if_not_primary): Likewise.\n\t(dfs_get_pure_virtuals): Likewise.\n\t(expand_upcast_fixups): Likewise.\n\t(fixup_virtual_upcast_offsets): Likewise.\n\t(dfs_find_vbase_instance): Likewise.\n\t(find_vbase_instance): Likewise.\n\t(binfo_from_vbase): Adjust comment to reflect reality.\n\t(binfo_via_virtual): New function.\n\t* class.c (VTT_TOP_LEVEL_P, VTT_MARKED_BINFO_P): New macros\n\tfor binfo walking during VTT construction.\n\t(dfs_mark_primary_bases): Remove.\n\t(force_canonical_binfo_r): New function.\n\t(force_canonical_binfo): New function.\n\t(mark_primary_virtual_base): New function.\n\t(mark_primary_bases): Walk in inheritance graph order, use\n\tmark_primary_virtual_base.\n\t(determine_primary_base): Use some more intermediate variables.\n\t(dfs_find_final_overrider): Don't check for overriding along a\n\tvirtual path.\n\t(dfs_modify_vtables): Walk into primary virtual bases too.\n\t(walk_subobject_offsets): Adjust for BINFO_PRIMARY_P.\n\t(build_base_fields): Likewise.\n\t(dfs_set_offset_for_unshared_vbases): Likewise.\n\t(layout_virtual_bases): Likewise.\n\t(end_of_class): Likewise.\n\t(finish_struct_1): Call dump_class_hierarchy, if requested.\n\t(dfs_get_primary_binfo): Use BINFO_TYPE for binfos.\n\t(dump_class_hierarchy_r): Add stream parameter. Emit more information.\n\t(dump_class_hierarchy): Add file parameter. Append to file, if\n\trequired.\n\t(finish_vtbls): Adjust accumulate_vtbl_inits call.\n\tUse canonical base for virtual bases.\n\t(build_vtt): Add more comments. Adjust build_vtt_inits call.\n\t(build_vtt_inits): Remove VIRTUAL_VTTS_P parm.\n\tOnly set BINFO_VPTR_INDEX on top level. Use VTT_TOP_LEVEL_P,\n\tVTT_MARKED_BINFO_P for binfo walking. Use canonical vbase for\n\tvirtual VTTs.\n\t(dfs_build_secondary_vptr_vtt_inits): Extract VTT_TOP_LEVEL_P\n\tfrom DATA.  We want virtual primary bases and all bases via virtual.\n\tOnly set BINFO_VPTR_INDEX for top level. Look up from a primary\n\tvirtual base when not a construction vtable.\n\t(dfs_ctor_vtable_bases_queue_p): New DFS predicate.\n\t(build_ctor_vtbl_group): Adjust accumulate_vtbl_inits call.\n\tUse canonical bases when processing virtual bases.\n\t(accumulate_vtbl_inits): We're interested in any base via a\n\tvirtual path.\n\t(dfs_accumulate_vtbl_inits): If this is a primary virtual base\n\twithin a construction vtable, determine what is being overridden.\n\t(build_vtbl_initializer): Add more comments\n\t(add_vcall_offset_vtbl_entries_1): Adjust comment.\n\t(build_rtti_vtbl_entries): Check if the base has lost its\n\tprimary.\ntestsuite:\n\t* g++.old-deja/g++.abi/primary2.C: New test.\n\t* g++.old-deja/g++.abi/primary3.C: New test.\n\t* g++.old-deja/g++.abi/primary4.C: New test.\n\t* g++.old-deja/g++.abi/primary5.C: New test.\n\t* g++.old-deja/g++.abi/vtable3.h: New test.\n\t* g++.old-deja/g++.abi/vtable3a.C: New test.\n\t* g++.old-deja/g++.abi/vtable3b.C: New test.\n\t* g++.old-deja/g++.abi/vtable3c.C: New test.\n\t* g++.old-deja/g++.abi/vtable3d.C: New test.\n\t* g++.old-deja/g++.abi/vtable3e.C: New test.\n\t* g++.old-deja/g++.abi/vtable3f.C: New test.\n\t* g++.old-deja/g++.abi/vtable3g.C: New test.\n\t* g++.old-deja/g++.abi/vtable3h.C: New test.\n\t* g++.old-deja/g++.abi/vtable3i.C: New test.\n\t* g++.old-deja/g++.abi/vtable3j.C: New test.\n\t* g++.old-deja/g++.oliva/thunk1.C: Remove XFAIL.\n\nFrom-SVN: r39455", "tree": {"sha": "e552da6fa53e49d793b63acc246a7fe949765502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e552da6fa53e49d793b63acc246a7fe949765502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9965d119133a5cb80938b829d28fa45777667a0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9965d119133a5cb80938b829d28fa45777667a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9965d119133a5cb80938b829d28fa45777667a0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9965d119133a5cb80938b829d28fa45777667a0c/comments", "author": null, "committer": null, "parents": [{"sha": "36ca672c97a7f1d07e274626eab0dabb5710b49a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ca672c97a7f1d07e274626eab0dabb5710b49a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ca672c97a7f1d07e274626eab0dabb5710b49a"}], "stats": {"total": 1244, "additions": 1011, "deletions": 233}, "files": [{"sha": "0046ae185e9ed0ff6c68f2f4a00a0ce77b0c781c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -1,3 +1,8 @@\n+2001-02-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* invoke.texi (-fdump-class-layout): Document.\n+\t(-fdump-translation-unit): Use `=' as filename separator.\n+\n 2001-02-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (s-mlib): Don't build multilibs if"}, {"sha": "04d64a0c824c7ae5eb6e6362a6c9ff3bcaf52637", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -1,3 +1,77 @@\n+2001-02-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tFix specification and implementation bugs in V3 ABI\n+\tconstruction vtables.\n+\t* cp-tree.h (flag_dump_class_layout): New flag.\n+\t(BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P): Remove.\n+\t(BINFO_LOST_PRIMARY_P): New flag.\n+\t(SET_BINFO_NEW_VTABLE_MARKED): Adjust asserts.\n+\t(BINFO_PRIMARY_MARKED_P): Rename to ...\n+\t(BINFO_PRIMARY_P): ... here.\n+\t(binfo_via_virtual): New prototype.\n+\t* decl2.c (flag_dump_class_layout): New flag.\n+\t(cxx_decode_option): Set it. Adjust -fdump-translation-unit to\n+\tuse `=' as a file name separator.\n+\t* init.c (dfs_initialize_vtbl_ptrs): Walk into virtual primary\n+\tbases.\n+\t(build_vtbl_address): If this is a virtual primary base, then\n+\tget the vtbl of what it is ultimately primary for.\n+\t* search.c (dfs_skip_nonprimary_vbases_unmarkedp): Adjust\n+\tfor BINFO_PRIMARY_P.\n+\t(dfs_skip_nonprimary_vbases_markedp): Likewise.\n+\t(get_shared_vbase_if_not_primary): Likewise.\n+\t(dfs_get_pure_virtuals): Likewise.\n+\t(expand_upcast_fixups): Likewise.\n+\t(fixup_virtual_upcast_offsets): Likewise.\n+\t(dfs_find_vbase_instance): Likewise.\n+\t(find_vbase_instance): Likewise.\n+\t(binfo_from_vbase): Adjust comment to reflect reality.\n+\t(binfo_via_virtual): New function.\n+\t* class.c (VTT_TOP_LEVEL_P, VTT_MARKED_BINFO_P): New macros\n+\tfor binfo walking during VTT construction.\n+\t(dfs_mark_primary_bases): Remove.\n+\t(force_canonical_binfo_r): New function.\n+\t(force_canonical_binfo): New function.\n+\t(mark_primary_virtual_base): New function.\n+\t(mark_primary_bases): Walk in inheritance graph order, use\n+\tmark_primary_virtual_base.\n+\t(determine_primary_base): Use some more intermediate variables.\n+\t(dfs_find_final_overrider): Don't check for overriding along a\n+\tvirtual path.\n+\t(dfs_modify_vtables): Walk into primary virtual bases too.\n+\t(walk_subobject_offsets): Adjust for BINFO_PRIMARY_P.\n+\t(build_base_fields): Likewise.\n+\t(dfs_set_offset_for_unshared_vbases): Likewise.\n+\t(layout_virtual_bases): Likewise.\n+\t(end_of_class): Likewise.\n+\t(finish_struct_1): Call dump_class_hierarchy, if requested.\n+\t(dfs_get_primary_binfo): Use BINFO_TYPE for binfos.\n+\t(dump_class_hierarchy_r): Add stream parameter. Emit more information.\n+\t(dump_class_hierarchy): Add file parameter. Append to file, if\n+\trequired.\n+\t(finish_vtbls): Adjust accumulate_vtbl_inits call.\n+\tUse canonical base for virtual bases.\n+\t(build_vtt): Add more comments. Adjust build_vtt_inits call.\n+\t(build_vtt_inits): Remove VIRTUAL_VTTS_P parm.\n+\tOnly set BINFO_VPTR_INDEX on top level. Use VTT_TOP_LEVEL_P,\n+\tVTT_MARKED_BINFO_P for binfo walking. Use canonical vbase for\n+\tvirtual VTTs.\n+\t(dfs_build_secondary_vptr_vtt_inits): Extract VTT_TOP_LEVEL_P\n+\tfrom DATA.  We want virtual primary bases and all bases via virtual.\n+\tOnly set BINFO_VPTR_INDEX for top level. Look up from a primary\n+\tvirtual base when not a construction vtable.\n+\t(dfs_ctor_vtable_bases_queue_p): New DFS predicate.\n+\t(build_ctor_vtbl_group): Adjust accumulate_vtbl_inits call.\n+\tUse canonical bases when processing virtual bases.\n+\t(accumulate_vtbl_inits): We're interested in any base via a\n+\tvirtual path.\n+\t(dfs_accumulate_vtbl_inits): If this is a primary virtual base\n+\twithin a construction vtable, determine what is being overridden.\n+\t(build_vtbl_initializer): Add more comments\n+\t(add_vcall_offset_vtbl_entries_1): Adjust comment.\n+\t(build_rtti_vtbl_entries): Check if the base has lost its\n+\tprimary.\n+\n 2001-02-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (g++spec.o): Adjust use of DRIVER_DEFINES."}, {"sha": "376260b0d6a099744413f2e736ab79abde1d0e90", "filename": "gcc/cp/class.c", "status": "modified", "additions": 419, "deletions": 205, "changes": 624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -111,8 +111,6 @@ static tree get_basefndecls PARAMS ((tree, tree));\n static int build_primary_vtable PARAMS ((tree, tree));\n static int build_secondary_vtable PARAMS ((tree, tree));\n static tree dfs_finish_vtbls PARAMS ((tree, void *));\n-static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t       tree));\n static void finish_vtbls PARAMS ((tree));\n static void modify_vtable_entry PARAMS ((tree, tree, tree, tree, tree *));\n static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n@@ -171,8 +169,8 @@ static void layout_vtable_decl PARAMS ((tree, int));\n static tree dfs_find_final_overrider PARAMS ((tree, void *));\n static tree find_final_overrider PARAMS ((tree, tree, tree));\n static int make_new_vtable PARAMS ((tree, tree));\n-static void dump_class_hierarchy_r PARAMS ((tree, tree, int));\n-extern void dump_class_hierarchy PARAMS ((tree));\n+static void dump_class_hierarchy_r PARAMS ((FILE *, tree, tree, int));\n+extern void dump_class_hierarchy PARAMS ((const char *, tree));\n static tree build_vtable PARAMS ((tree, tree, tree));\n static void initialize_vtable PARAMS ((tree, tree));\n static void initialize_array PARAMS ((tree, tree));\n@@ -182,20 +180,25 @@ static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n static void layout_empty_base PARAMS ((tree, tree, splay_tree));\n static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n+static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n+\t\t\t\t\t       tree));\n static void set_vindex PARAMS ((tree, tree, int *));\n static void build_rtti_vtbl_entries PARAMS ((tree, tree, vtbl_init_data *));\n static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree, \n \t\t\t\t\t\t\tvtbl_init_data *));\n-static tree dfs_mark_primary_bases PARAMS ((tree, void *));\n+static void force_canonical_binfo_r PARAMS ((tree, tree, tree, tree));\n+static void force_canonical_binfo PARAMS ((tree, tree, tree, tree));\n static void mark_primary_bases PARAMS ((tree));\n+static tree mark_primary_virtual_base PARAMS ((tree, tree, tree));\n static void clone_constructors_and_destructors PARAMS ((tree));\n static tree build_clone PARAMS ((tree, tree));\n static void update_vtable_entry_for_fn PARAMS ((tree, tree, tree, tree *));\n static tree copy_virtuals PARAMS ((tree));\n static void build_ctor_vtbl_group PARAMS ((tree, tree));\n static void build_vtt PARAMS ((tree));\n-static tree *build_vtt_inits PARAMS ((tree, tree, int, tree *, tree *));\n+static tree *build_vtt_inits PARAMS ((tree, tree, tree *, tree *));\n static tree dfs_build_secondary_vptr_vtt_inits PARAMS ((tree, void *));\n+static tree dfs_ctor_vtable_bases_queue_p PARAMS ((tree, void *data));\n static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n static tree get_matching_base PARAMS ((tree, tree));\n static tree dfs_get_primary_binfo PARAMS ((tree, void*));\n@@ -208,6 +211,13 @@ static int layout_conflict_p PARAMS ((tree, tree, splay_tree, int));\n static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n \t\t\t\t\t\t    splay_tree_key k2));\n \n+\n+/* Macros for dfs walking during vtt construction. See\n+   dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits\n+   and dfs_fixup_binfo_vtbls.  */\n+#define VTT_TOP_LEVEL_P(node) TREE_UNSIGNED(node)\n+#define VTT_MARKED_BINFO_P(node) TREE_USED(node)\n+\n /* Variables shared between class.c and call.c.  */\n \n #ifdef GATHER_STATISTICS\n@@ -1719,92 +1729,142 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n     }\n }\n \n-/* Called via dfs_walk from mark_primary_bases.  Sets\n-   BINFO_PRIMARY_MARKED_P for BINFO, if appropriate.  */\n+/* Binfo FROM is within a virtual heirarchy which is being reseated to\n+   TO. Move primary information from FROM to TO, and recursively traverse\n+   into FROM's bases. The heirarchy is dominated by TYPE.  MAPPINGS is an\n+   assoc list of binfos that have already been reseated.  */\n \n-static tree\n-dfs_mark_primary_bases (binfo, data)\n-     tree binfo;\n-     void *data;\n+static void\n+force_canonical_binfo_r (to, from, type, mappings)\n+     tree to;\n+     tree from;\n+     tree type;\n+     tree mappings;\n {\n-  tree base_binfo;\n+  int i, n_baseclasses = BINFO_N_BASETYPES (from);\n+  \n+  BINFO_INDIRECT_PRIMARY_P (to)\n+          = BINFO_INDIRECT_PRIMARY_P (from);\n+  BINFO_INDIRECT_PRIMARY_P (from) = 0;\n+  if (BINFO_PRIMARY_P (from))\n+    {\n+      tree primary = BINFO_PRIMARY_BASE_OF (from);\n+      tree assoc;\n+      \n+      /* We might have just moved the primary base too, see if it's on our\n+         mappings.  */\n+      assoc = purpose_member (primary, mappings);\n+      if (assoc)\n+        primary = TREE_VALUE (assoc);\n+      BINFO_PRIMARY_BASE_OF (to) = primary;\n+      BINFO_PRIMARY_BASE_OF (from) = NULL_TREE;\n+    }\n+  my_friendly_assert (same_type_p (BINFO_TYPE (to), BINFO_TYPE (from)), 20010104);\n+  mappings = tree_cons (from, to, mappings);\n+  for (i = 0; i != n_baseclasses; i++)\n+    {\n+      tree from_binfo = BINFO_BASETYPE (from, i);\n+      tree to_binfo = BINFO_BASETYPE (to, i);\n+      \n+      if (TREE_VIA_VIRTUAL (from_binfo))\n+        {\n+          tree shared_binfo = binfo_for_vbase (BINFO_TYPE (from_binfo), type);\n+          \n+          if (shared_binfo == from_binfo)\n+            force_canonical_binfo (to_binfo, from_binfo, type, mappings);\n+        }\n+      else\n+        force_canonical_binfo_r (to_binfo, from_binfo, type, mappings);\n+    }\n+}\n \n-  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n-    return NULL_TREE;\n+/* FROM is the canonical binfo for a virtual base. It is being reseated to\n+   make TO the canonical binfo, within the heirarchy dominated by TYPE.\n+   MAPPINGS is an assoc list of binfos that have already been reseated.\n+   Adjust any non-virtual bases within FROM, and also move any virtual bases\n+   which are canonical.  This complication arises because selecting primary\n+   bases walks in inheritance graph order, but we don't share binfos for\n+   virtual bases, hence we can fill in the primaries for a virtual base,\n+   and then discover that a later base requires the virtual as its\n+   primary.  */\n \n-  base_binfo = get_primary_binfo (binfo);\n+static void\n+force_canonical_binfo (to, from, type, mappings)\n+     tree to;\n+     tree from;\n+     tree type;\n+     tree mappings;\n+{\n+  tree assoc = purpose_member (BINFO_TYPE (to),\n+\t\t               CLASSTYPE_VBASECLASSES (type));\n+  TREE_VALUE (assoc) = to;\n+  force_canonical_binfo_r (to, from, type, mappings);\n+}\n \n-  if (TREE_VIA_VIRTUAL (base_binfo))\n-    {\n-      tree shared_binfo;\n-      tree type;\n+/* Make BASE_BINFO the primary virtual base of BINFO within the hierarchy\n+   dominated by TYPE. Returns BASE_BINFO, if it can be made so, NULL\n+   otherwise (because something else has already made it primary).  */\n \n-      type = (tree) data;\n-      shared_binfo = binfo_for_vbase (BINFO_TYPE (base_binfo), type);\n+static tree\n+mark_primary_virtual_base (binfo, base_binfo, type)\n+     tree binfo;\n+     tree base_binfo;\n+     tree type;\n+{\n+  tree shared_binfo = binfo_for_vbase (BINFO_TYPE (base_binfo), type);\n+  tree delta;\n \n-      /* If this virtual base is not already primary somewhere else in\n-\t the hiearchy, then we'll be using this copy.  */\n-      if (!BINFO_PRIMARY_MARKED_P (shared_binfo))\n-\t{\n-\t  /* Make sure the CLASSTYPE_VBASECLASSES list contains the\n-\t     primary copy; it's the one that really exists.  */\n-\t  if (base_binfo != shared_binfo)\n-\t    TREE_VALUE (purpose_member (BINFO_TYPE (base_binfo),\n-\t\t\t\t\tCLASSTYPE_VBASECLASSES (type)))\n-\t      = base_binfo;\n-\t}\n-      else\n-\tbase_binfo = NULL_TREE;\n+  if (BINFO_PRIMARY_P (shared_binfo))\n+    {\n+      /* It's already allocated in the hierarchy. BINFO won't have a\n+         primary base in this hierachy, even though the complete object\n+         BINFO is for, would do.  */\n+      BINFO_LOST_PRIMARY_P (binfo) = 1;\n+      \n+      return NULL_TREE;\n     }\n+     \n+  /* We need to make sure that the assoc list\n+     CLASSTYPE_VBASECLASSES of TYPE, indicates this particular\n+     primary BINFO for the virtual base, as this is the one\n+     that'll really exist.  */\n+  if (base_binfo != shared_binfo)\n+    force_canonical_binfo (base_binfo, shared_binfo, type, NULL);\n \n-  if (base_binfo)\n-    BINFO_PRIMARY_BASE_OF (base_binfo) = binfo;\n-\n-  return NULL_TREE;\n+  delta = size_diffop (BINFO_OFFSET (binfo), BINFO_OFFSET (base_binfo));\n+  if (!integer_zerop (delta))\n+    {\n+      propagate_binfo_offsets (base_binfo, delta);\n+      BINFO_OFFSET (base_binfo) = BINFO_OFFSET (binfo);\n+    }\n+  return base_binfo;\n }\n \n-/* Set BINFO_PRIMARY_MARKED_P for all binfos in the hierarchy\n-   dominated by BINFO that are primary bases.  */\n+/* Set BINFO_PRIMARY_BASE_OF for all binfos in the hierarchy\n+   dominated by TYPE that are primary bases.  */\n \n static void\n mark_primary_bases (type)\n      tree type;\n {\n-  tree vbases;\n-\n-  /* Mark the TYPE_BINFO hierarchy.  We need to mark primary bases in\n-     pre-order to deal with primary virtual bases.  (The virtual base\n-     would be skipped if it were not marked as primary, and that\n-     requires getting to dfs_mark_primary_bases before\n-     dfs_skip_nonprimary_vbases_unmarkedp has a chance to skip the\n-     virtual base.)  */\n-  dfs_walk_real (TYPE_BINFO (type), dfs_mark_primary_bases, NULL,\n-\t\t dfs_skip_nonprimary_vbases_unmarkedp, type);\n-\n-  /* Now go through the virtual base classes in inheritance graph\n-     order.  Any that are not already primary will need to be\n-     allocated in TYPE, and so we need to mark their primary bases.  */\n-  for (vbases = TYPE_BINFO (type); vbases; vbases = TREE_CHAIN (vbases))\n+  tree binfo;\n+  \n+  /* Walk the bases in inheritance graph order.  */\n+  for (binfo = TYPE_BINFO (type); binfo; binfo = TREE_CHAIN (binfo))\n     {\n-      tree vbase;\n-\n-      /* Make sure that only BINFOs appear on this list.\n-\t Historically, the TREE_CHAIN was used for other purposes, and\n-\t we want to make sure that none of those uses remain.  */\n-      my_friendly_assert (TREE_CODE (vbases) == TREE_VEC, 20000402);\n+      tree base_binfo;\n+      \n+      if (!CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+        /* Not a dynamic base. */\n+        continue;\n \n-      if (!TREE_VIA_VIRTUAL (vbases))\n-\tcontinue;\n+      base_binfo = get_primary_binfo (binfo);\n \n-      vbase = binfo_for_vbase (BINFO_TYPE (vbases), type);\n-      if (BINFO_PRIMARY_MARKED_P (vbase))\n-\t/* This virtual base was already included in the hierarchy, so\n-\t   there's nothing to do here.  */\n-\tcontinue;\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+        base_binfo = mark_primary_virtual_base (binfo, base_binfo, type);\n \n-      /* Now, walk its bases.  */\n-      dfs_walk_real (vbase, dfs_mark_primary_bases, NULL,\n-\t\t     dfs_skip_nonprimary_vbases_unmarkedp, type);\n+      if (base_binfo)\n+        BINFO_PRIMARY_BASE_OF (base_binfo) = binfo;\n     }\n }\n \n@@ -1892,40 +1952,41 @@ determine_primary_base (t, vfuns_p)\n   if (!TYPE_VFIELD (t))\n     CLASSTYPE_PRIMARY_BINFO (t) = NULL_TREE;\n \n-  /* Mark the indirect primary bases.  */\n+  /* Find the indirect primary bases - those virtual bases which are primary\n+     bases of something else in this hierarchy.  */\n   for (vbases = CLASSTYPE_VBASECLASSES (t);\n        vbases;\n        vbases = TREE_CHAIN (vbases)) \n     {\n-      tree binfo = TREE_VALUE (vbases);\n+      tree vbase_binfo = TREE_VALUE (vbases);\n \n-      /* See if this virtual base is an indirect primary base.  If so,\n-\t it must be either a primary base or an indirect primary base\n-\t in one of the direct bases.  */\n+      /* See if this virtual base is an indirect primary base.  To be so,\n+         it must be a primary base within the hierarchy of one of our\n+         direct bases.  */\n       for (i = 0; i < n_baseclasses; ++i) \n \t{\n-\t  tree basetype;\n+\t  tree basetype = TYPE_BINFO_BASETYPE (t, i);\n \t  tree v;\n \n-\t  basetype = TYPE_BINFO_BASETYPE (t, i);\n \t  for (v = CLASSTYPE_VBASECLASSES (basetype); \n \t       v; \n \t       v = TREE_CHAIN (v))\n \t    {\n-\t      tree b = TREE_VALUE (v);\n-\t      if ((BINFO_PRIMARY_MARKED_P (b)\n-\t\t   || BINFO_INDIRECT_PRIMARY_P (b))\n-\t\t  && same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n+\t      tree base_vbase = TREE_VALUE (v);\n+\t      \n+\t      if (BINFO_PRIMARY_P (base_vbase)\n+\t\t  && same_type_p (BINFO_TYPE (base_vbase),\n+\t                          BINFO_TYPE (vbase_binfo)))\n \t\t{\n-\t\t  BINFO_INDIRECT_PRIMARY_P (binfo) = 1;\n+\t\t  BINFO_INDIRECT_PRIMARY_P (vbase_binfo) = 1;\n \t\t  break;\n \t\t}\n \t    }\n \n \t  /* If we've discovered that this virtual base is an indirect\n \t     primary base, then we can move on to the next virtual\n \t     base.  */\n-\t  if (BINFO_INDIRECT_PRIMARY_P (binfo))\n+\t  if (BINFO_INDIRECT_PRIMARY_P (vbase_binfo))\n \t    break;\n \t}\n     }\n@@ -1957,10 +2018,12 @@ determine_primary_base (t, vfuns_p)\n \t\t  candidate = base_binfo;\n \t\t  break;\n \t\t}\n-\t      /* If this was an indirect primary base, it's still our\n-\t\t primary base -- unless there's another nearly-empty\n-\t\t virtual base that isn't an indirect primary base.  */\n-\t      else if (!candidate)\n+\n+\t      /* If this is an indirect primary base, it still could be\n+\t         our primary base -- unless we later find there's another\n+\t         nearly-empty virtual base that isn't an indirect\n+\t         primary base.  */\n+\t      if (!candidate)\n \t\tcandidate = base_binfo;\n \t    }\n \t}\n@@ -2516,12 +2579,6 @@ dfs_find_final_overrider (binfo, data)\n \t    if (TREE_VIA_VIRTUAL (TREE_VALUE (base)))\n \t      {\n \t\tbase = ffod->declaring_base;\n-\t\twhile (BINFO_PRIMARY_MARKED_P (base))\n-\t\t  {\n-\t\t    BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P (base) = 1;\n-\t\t    base = BINFO_INHERITANCE_CHAIN (base);\n-\t\t  }\n-\t\tBINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P (base) = 1;\n \t\tbreak;\n \t      }\n \n@@ -2748,9 +2805,11 @@ dfs_modify_vtables (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  if (/* There's no need to modify the vtable for a primary base;\n-\t we're not going to use that vtable anyhow.  */\n-      !BINFO_PRIMARY_MARKED_P (binfo)\n+  if (/* There's no need to modify the vtable for a non-virtual\n+         primary base; we're not going to use that vtable anyhow\n+         (virtual primary bases can become non-primary in a\n+         class derivation of this one.) */\n+      (!BINFO_PRIMARY_P (binfo) || TREE_VIA_VIRTUAL (binfo))\n       /* Similarly, a base without a vtable needs no modification.  */\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n@@ -3734,7 +3793,7 @@ check_subobject_offset (type, offset, offsets)\n \n /* Walk through all the subobjects of TYPE (located at OFFSET).  Call\n    F for every subobject, passing it the type, offset, and table of\n-   OFFSETS.  If VBASES_P is non-zero, then even non-virtual primary\n+   OFFSETS.  If VBASES_P is non-zero, then even virtual non-primary\n    bases should be traversed; otherwise, they are ignored.  If F\n    returns a non-zero value, the traversal ceases, and that value is\n    returned.  Otherwise, returns zero.  */\n@@ -3766,7 +3825,7 @@ walk_subobject_offsets (type, f, offset, offsets, vbases_p)\n \n \t  if (!vbases_p \n \t      && TREE_VIA_VIRTUAL (binfo) \n-\t      && !BINFO_PRIMARY_MARKED_P (binfo))\n+\t      && !BINFO_PRIMARY_P (binfo))\n \t    continue;\n \n \t  r = walk_subobject_offsets (BINFO_TYPE (binfo),\n@@ -4085,7 +4144,7 @@ build_base_fields (rli, empty_p, offsets)\n \t base class, but a non-primary virtual base is allocated\n \t later, in layout_virtual_bases.  */\n       if (TREE_VIA_VIRTUAL (base_binfo) \n-\t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n+\t  && !BINFO_PRIMARY_P (base_binfo))\n \tcontinue;\n \n       build_base_field (rli, base_binfo, empty_p, &base_align, offsets);\n@@ -4649,7 +4708,7 @@ dfs_set_offset_for_unshared_vbases (binfo, data)\n   /* If this is a virtual base, make sure it has the same offset as\n      the shared copy.  If it's a primary base, then we know it's\n      correct.  */\n-  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_P (binfo))\n     {\n       tree t = (tree) data;\n       tree vbase;\n@@ -4713,7 +4772,7 @@ layout_virtual_bases (t, offsets)\n       else\n \tvbase = TREE_VALUE (vbases);\n \n-      if (!BINFO_PRIMARY_MARKED_P (vbase))\n+      if (!BINFO_PRIMARY_P (vbase))\n \t{\n \t  /* This virtual base is not a primary base of any class in the\n \t     hierarchy, so we have to add space for it.  */\n@@ -4824,7 +4883,7 @@ end_of_class (t, include_virtuals_p)\n \n       if (!include_virtuals_p\n \t  && TREE_VIA_VIRTUAL (base_binfo) \n-\t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n+\t  && !BINFO_PRIMARY_P (base_binfo))\n \tcontinue;\n \n       offset = size_binop (PLUS_EXPR, \n@@ -5143,6 +5202,11 @@ finish_struct_1 (t)\n   layout_class_type (t, &empty, &vfuns,\n \t\t     &new_virtuals, &overridden_virtuals);\n \n+  if (flag_dump_class_layout)\n+    dump_class_hierarchy (*flag_dump_class_layout\n+                          ? flag_dump_class_layout : NULL,\n+                          t);\n+  \n   /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we\n      might need to know it for setting up the offsets in the vtable\n      (or in thunks) below.  */\n@@ -5277,6 +5341,7 @@ finish_struct_1 (t)\n   /* Make the rtl for any new vtables we have created, and unmark\n      the base types we marked.  */\n   finish_vtbls (t);\n+  \n   /* Build the VTT for T.  */\n   build_vtt (t);\n \n@@ -6587,7 +6652,7 @@ dfs_get_primary_binfo (binfo, data)\n   tree primary_base = (tree) data;\n \n   if (TREE_VIA_VIRTUAL (binfo) \n-      && same_type_p (TREE_TYPE (binfo), TREE_TYPE (primary_base)))\n+      && same_type_p (BINFO_TYPE (binfo), BINFO_TYPE (primary_base)))\n     return binfo;\n   \n   return NULL_TREE;\n@@ -6598,7 +6663,7 @@ dfs_get_primary_binfo (binfo, data)\n    primary.  In particular if the resulting BINFO is a virtual base,\n    and it occurs elsewhere in the hierarchy, then this occurrence may\n    not actually be a primary base in the complete object.  Check\n-   BINFO_PRIMARY_MARKED_P to be sure.  */\n+   BINFO_PRIMARY_P to be sure.  */\n \n tree\n get_primary_binfo (binfo)\n@@ -6645,38 +6710,68 @@ get_primary_binfo (binfo)\n    the top level; it is incremented recursively.  */\n \n static void\n-dump_class_hierarchy_r (t, binfo, indent)\n+dump_class_hierarchy_r (stream, t, binfo, indent)\n+     FILE *stream;\n      tree t;\n      tree binfo;\n      int indent;\n {\n   int i;\n \n-  fprintf (stderr, \"%*s0x%lx (%s) \", indent, \"\",\n+  fprintf (stream, \"%*s0x%lx (%s) \", indent, \"\",\n \t   (unsigned long) binfo,\n \t   type_as_string (binfo, TFF_PLAIN_IDENTIFIER));\n-  fprintf (stderr, HOST_WIDE_INT_PRINT_DEC,\n+  fprintf (stream, HOST_WIDE_INT_PRINT_DEC,\n \t   tree_low_cst (BINFO_OFFSET (binfo), 0));\n+  if (is_empty_class (BINFO_TYPE (binfo)))\n+    fprintf (stream, \" empty\");\n+  else if (CLASSTYPE_NEARLY_EMPTY_P (BINFO_TYPE (binfo)))\n+    fprintf (stream, \" nearly-empty\");\n   if (TREE_VIA_VIRTUAL (binfo))\n-    fprintf (stderr, \" virtual\");\n-  if (BINFO_PRIMARY_MARKED_P (binfo)\n-      || (TREE_VIA_VIRTUAL (binfo) \n-\t  && BINFO_PRIMARY_MARKED_P (binfo_for_vbase (BINFO_TYPE (binfo), \n-\t\t\t\t\t\t      t))))\n-    fprintf (stderr, \" primary\");\n-  fprintf (stderr, \"\\n\");\n+    {\n+      tree canonical = binfo_for_vbase (BINFO_TYPE (binfo), t);\n+      \n+      if (canonical == binfo)\n+        fprintf (stream, \" virtual-canonical\");\n+      else\n+        fprintf (stream, \" virtual-non-canonical\");\n+    }\n+  if (BINFO_PRIMARY_P (binfo))\n+    fprintf (stream, \" primary-for 0x%lx (%s)\",\n+             (unsigned long)BINFO_PRIMARY_BASE_OF (binfo),\n+             type_as_string (BINFO_PRIMARY_BASE_OF (binfo), TFF_PLAIN_IDENTIFIER));\n+  if (BINFO_LOST_PRIMARY_P (binfo))\n+    fprintf (stream, \" lost-primary\");\n+  fprintf (stream, \"\\n\");\n \n   for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n-    dump_class_hierarchy_r (t, BINFO_BASETYPE (binfo, i), indent + 2);\n+    dump_class_hierarchy_r (stream, t, BINFO_BASETYPE (binfo, i), indent + 2);\n }\n \n /* Dump the BINFO hierarchy for T.  */\n \n void\n-dump_class_hierarchy (t)\n+dump_class_hierarchy (name, t)\n+     const char *name;\n      tree t;\n {\n-  dump_class_hierarchy_r (t, TYPE_BINFO (t), 0);\n+  FILE *stream = stderr;\n+  \n+  if (name)\n+    {\n+      static int append = 0;\n+      \n+      stream = fopen (name, append++ ? \"a\" : \"w\");\n+      if (!stream)\n+        error (\"could not open dump file `%s'\", name);\n+      return;\n+    }\n+  fprintf (stream, \"%s\\n\",\n+           type_as_string (t, TFF_PLAIN_IDENTIFIER));\n+  dump_class_hierarchy_r (stream, t, TYPE_BINFO (t), 0);\n+  fprintf (stream, \"\\n\");\n+  if (name)\n+    fclose (stream);\n }\n \n /* Virtual function table initialization.  */\n@@ -6703,10 +6798,17 @@ finish_vtbls (t)\n \t order.  */\n       for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n \t{\n+\t  tree real_base;\n+\t  \n \t  if (!TREE_VIA_VIRTUAL (vbase))\n \t    continue;\n-\n-\t  accumulate_vtbl_inits (vbase, vbase, TYPE_BINFO (t), t, list);\n+          \n+          /* Although we walk in inheritance order, that might not get the\n+             canonical base.  */\n+          real_base = binfo_for_vbase (BINFO_TYPE (vbase), t);\n+          \n+\t  accumulate_vtbl_inits (real_base, real_base,\n+\t                         TYPE_BINFO (t), t, list);\n \t}\n \n       if (TYPE_BINFO_VTABLE (t))\n@@ -6771,7 +6873,17 @@ initialize_array (decl, inits)\n   DECL_CONTEXT (decl) = context;\n }\n \n-/* Build the VTT (virtual table table) for T.  */\n+/* Build the VTT (virtual table table) for T.\n+   A class requires a VTT if it has virtual bases.\n+   \n+   This holds\n+   1 - primary virtual pointer for complete object T\n+   2 - secondary VTTs for each direct non-virtual base of T which requires a VTT\n+   3 - secondary virtual pointers for each direct or indirect base of T which\n+       has virtual bases or is reachable via a virtual path from T.\n+   4 - secondary VTTs for each direct or indirect virtual base of T.\n+   \n+   Secondary VTTs look like complete object VTTs without part 4.  */\n \n static void\n build_vtt (t)\n@@ -6789,8 +6901,7 @@ build_vtt (t)\n   /* Build up the initializers for the VTT.  */\n   inits = NULL_TREE;\n   index = size_zero_node;\n-  build_vtt_inits (TYPE_BINFO (t), t, /*virtual_vtts_p=*/1, \n-\t\t   &inits, &index);\n+  build_vtt_inits (TYPE_BINFO (t), t, &inits, &index);\n \n   /* If we didn't need a VTT, we're done.  */\n   if (!inits)\n@@ -6835,33 +6946,33 @@ get_matching_base (binfo, t)\n }\n \n /* Recursively build the VTT-initializer for BINFO (which is in the\n-   hierarchy dominated by T).  If VIRTUAL_VTTS_P is non-zero, then\n-   sub-VTTs for virtual bases are included.  INITS points to the end\n-   of the initializer list to date.  INDEX is the VTT index where the\n-   next element will be placed.  */\n+   hierarchy dominated by T).  INITS points to the end of the initializer\n+   list to date.  INDEX is the VTT index where the next element will be\n+   replaced.  Iff BINFO is the binfo for T, this is the top level VTT (i.e.\n+   not a subvtt for some base of T).  When that is so, we emit the sub-VTTs\n+   for virtual bases of T. When it is not so, we build the constructor\n+   vtables for the BINFO-in-T variant.  */\n \n static tree *\n-build_vtt_inits (binfo, t, virtual_vtts_p, inits, index)\n+build_vtt_inits (binfo, t, inits, index)\n      tree binfo;\n      tree t;\n-     int virtual_vtts_p;\n      tree *inits;\n      tree *index;\n {\n   int i;\n   tree b;\n   tree init;\n   tree secondary_vptrs;\n-  int ctor_vtbl_p;\n+  int top_level_p = same_type_p (TREE_TYPE (binfo), t);\n \n   /* We only need VTTs for subobjects with virtual bases.  */\n   if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n     return inits;\n \n   /* We need to use a construction vtable if this is not the primary\n      VTT.  */\n-  ctor_vtbl_p = !same_type_p (TREE_TYPE (binfo), t);\n-  if (ctor_vtbl_p)\n+  if (!top_level_p)\n     {\n       build_ctor_vtbl_group (binfo, t);\n \n@@ -6875,7 +6986,11 @@ build_vtt_inits (binfo, t, virtual_vtts_p, inits, index)\n     init = TREE_VALUE (init);\n   *inits = build_tree_list (NULL_TREE, init);\n   inits = &TREE_CHAIN (*inits);\n-  BINFO_VPTR_INDEX (binfo) = *index;\n+  if (top_level_p)\n+    {\n+      my_friendly_assert (!BINFO_VPTR_INDEX (binfo), 20010129);\n+      BINFO_VPTR_INDEX (binfo) = *index;\n+    }\n   *index = size_binop (PLUS_EXPR, *index, TYPE_SIZE_UNIT (ptr_type_node));\n \t\t       \n   /* Recursively add the secondary VTTs for non-virtual bases.  */\n@@ -6884,22 +6999,26 @@ build_vtt_inits (binfo, t, virtual_vtts_p, inits, index)\n       b = BINFO_BASETYPE (binfo, i);\n       if (!TREE_VIA_VIRTUAL (b))\n \tinits = build_vtt_inits (BINFO_BASETYPE (binfo, i), t, \n-\t\t\t\t /*virtuals_vtts_p=*/0,\n \t\t\t\t inits, index);\n     }\n       \n   /* Add secondary virtual pointers for all subobjects of BINFO with\n-     either virtual bases or virtual functions overridden along a\n-     virtual path between the declaration and D, except subobjects\n-     that are non-virtual primary bases.  */\n+     either virtual bases or reachable along a virtual path, except\n+     subobjects that are non-virtual primary bases.  */\n   secondary_vptrs = tree_cons (t, NULL_TREE, BINFO_TYPE (binfo));\n   TREE_TYPE (secondary_vptrs) = *index;\n+  VTT_TOP_LEVEL_P (secondary_vptrs) = top_level_p;\n+  VTT_MARKED_BINFO_P (secondary_vptrs) = 0;\n+  \n   dfs_walk_real (binfo,\n \t\t dfs_build_secondary_vptr_vtt_inits,\n \t\t NULL,\n-\t\t dfs_unmarked_real_bases_queue_p,\n+\t         dfs_ctor_vtable_bases_queue_p,\n \t\t secondary_vptrs);\n-  dfs_walk (binfo, dfs_unmark, dfs_marked_real_bases_queue_p, t);\n+  VTT_MARKED_BINFO_P (secondary_vptrs) = 1;\n+  dfs_walk (binfo, dfs_unmark, dfs_ctor_vtable_bases_queue_p,\n+            secondary_vptrs);\n+\n   *index = TREE_TYPE (secondary_vptrs);\n \n   /* The secondary vptrs come back in reverse order.  After we reverse\n@@ -6914,7 +7033,7 @@ build_vtt_inits (binfo, t, virtual_vtts_p, inits, index)\n     }\n \n   /* Add the secondary VTTs for virtual bases.  */\n-  if (virtual_vtts_p)\n+  if (top_level_p)\n     for (b = TYPE_BINFO (BINFO_TYPE (binfo)); b; b = TREE_CHAIN (b))\n       {\n \ttree vbase;\n@@ -6923,18 +7042,29 @@ build_vtt_inits (binfo, t, virtual_vtts_p, inits, index)\n \t  continue;\n \t\n \tvbase = binfo_for_vbase (BINFO_TYPE (b), t);\n-\tinits = build_vtt_inits (vbase, t, /*virtual_vtts_p=*/0, \n-\t\t\t\t inits, index);\n+\tinits = build_vtt_inits (vbase, t, inits, index);\n       }\n \n-  dfs_walk (binfo, dfs_fixup_binfo_vtbls,\n-\t    dfs_unmarked_real_bases_queue_p,\n-\t    build_tree_list (t, binfo));\n+  if (!top_level_p)\n+    {\n+      tree data = tree_cons (t, binfo, NULL_TREE);\n+      VTT_TOP_LEVEL_P (data) = 0;\n+      VTT_MARKED_BINFO_P (data) = 0;\n+      \n+      dfs_walk (binfo, dfs_fixup_binfo_vtbls,\n+\t        dfs_ctor_vtable_bases_queue_p,\n+\t        data);\n+    }\n \n   return inits;\n }\n \n-/* Called from build_vtt_inits via dfs_walk.  */\n+/* Called from build_vtt_inits via dfs_walk.  BINFO is the binfo\n+   for the base in most derived. DATA is a TREE_LIST who's\n+   TREE_CHAIN is the type of the base being\n+   constructed whilst this secondary vptr is live.  The TREE_UNSIGNED\n+   flag of DATA indicates that this is a constructor vtable.  The\n+   TREE_TOP_LEVEL flag indicates that this is the primary VTT.  */\n \n static tree\n dfs_build_secondary_vptr_vtt_inits (binfo, data)\n@@ -6945,10 +7075,12 @@ dfs_build_secondary_vptr_vtt_inits (binfo, data)\n   tree t;\n   tree init;\n   tree index;\n+  int top_level_p;\n \n   l = (tree) data;\n   t = TREE_CHAIN (l);\n-\n+  top_level_p = VTT_TOP_LEVEL_P (l);\n+  \n   SET_BINFO_MARKED (binfo);\n \n   /* We don't care about bases that don't have vtables.  */\n@@ -6960,32 +7092,34 @@ dfs_build_secondary_vptr_vtt_inits (binfo, data)\n     return NULL_TREE;\n \n   /* We're not interested in non-virtual primary bases.  */\n-  if (!TREE_VIA_VIRTUAL (binfo) && BINFO_PRIMARY_MARKED_P (binfo))\n+  if (!TREE_VIA_VIRTUAL (binfo) && BINFO_PRIMARY_P (binfo))\n     return NULL_TREE;\n \n-  /* If BINFO doesn't have virtual bases, then we have to look to see\n-     whether or not any virtual functions were overidden along a\n-     virtual path.  The point is that given:\n-\n-       struct V { virtual void f(); int i; };\n-       struct C : public virtual V { void f (); };\n-\n-     when we constrct C we need a secondary vptr for V-in-C because we\n-     don't know what the vcall offset for `f' should be.  If `V' ends\n-     up in a different place in the complete object, then we'll need a\n-     different vcall offset than that present in the normal V-in-C\n-     vtable.  */\n+  /* If BINFO has virtual bases or is reachable via a virtual path\n+     from T, it'll have a secondary vptr.  */\n   if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo))\n-      && !BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P (get_matching_base (binfo, t)))\n+      && !binfo_via_virtual (binfo, t))\n     return NULL_TREE;\n \n   /* Record the index where this secondary vptr can be found.  */\n   index = TREE_TYPE (l);\n-  BINFO_VPTR_INDEX (binfo) = index;\n+  if (top_level_p)\n+    {\n+      my_friendly_assert (!BINFO_VPTR_INDEX (binfo), 20010129);\n+      BINFO_VPTR_INDEX (binfo) = index;\n+    }\n   TREE_TYPE (l) = size_binop (PLUS_EXPR, index, \n \t\t\t      TYPE_SIZE_UNIT (ptr_type_node));\n \n   /* Add the initializer for the secondary vptr itself.  */\n+  if (top_level_p && TREE_VIA_VIRTUAL (binfo))\n+    {\n+      /* It's a primary virtual base, and this is not the construction\n+         vtable. Find the base this is primary of in the inheritance graph,\n+         and use that base's vtable now. */\n+      while (BINFO_PRIMARY_BASE_OF (binfo))\n+        binfo = BINFO_PRIMARY_BASE_OF (binfo);\n+    }\n   init = BINFO_VTABLE (binfo);\n   if (TREE_CODE (init) == TREE_LIST)\n     init = TREE_VALUE (init);\n@@ -6994,7 +7128,34 @@ dfs_build_secondary_vptr_vtt_inits (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Called from build_vtt_inits via dfs_walk.  */\n+/* dfs_walk_real predicate for building vtables. DATA is a TREE_LIST,\n+   TREE_UNSIGNED indicates that a constructor vtable is being built.\n+   TREE_USED indicates whether marked or unmarked bases should be walked.\n+   TREE_PURPOSE is the TREE_TYPE that dominates the hierarchy.  */\n+\n+static tree\n+dfs_ctor_vtable_bases_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_P (binfo))\n+    {\n+      tree type = TREE_PURPOSE ((tree) data);\n+\n+      /* This is a non-primary virtual base, get the shared version.  */\n+      binfo = binfo_for_vbase (BINFO_TYPE (binfo), type);\n+      if (VTT_TOP_LEVEL_P ((tree) data) && BINFO_PRIMARY_P (binfo))\n+        return NULL_TREE;\n+    }\n+  if (!BINFO_MARKED (binfo) == VTT_MARKED_BINFO_P ((tree) data))\n+    return NULL_TREE;\n+  return binfo;\n+}\n+\n+/* Called from build_vtt_inits via dfs_walk. After building constructor\n+   vtables and generating the sub-vtt from them, we need to restore the\n+   BINFO_VTABLES that were scribbled on.  DATA is a TREE_LIST whose\n+   TREE_VALUE is the TREE_TYPE of the base whose sub vtt was generated.  */\n \n static tree\n dfs_fixup_binfo_vtbls (binfo, data)\n@@ -7040,26 +7201,31 @@ build_ctor_vtbl_group (binfo, t)\n   if (IDENTIFIER_GLOBAL_VALUE (id))\n     return;\n \n+  my_friendly_assert (!same_type_p (BINFO_TYPE (binfo), t), 20010124);\n   /* Build a version of VTBL (with the wrong type) for use in\n      constructing the addresses of secondary vtables in the\n      construction vtable group.  */\n   vtbl = build_vtable (t, id, ptr_type_node);\n   list = build_tree_list (vtbl, NULL_TREE);\n   accumulate_vtbl_inits (binfo, TYPE_BINFO (TREE_TYPE (binfo)),\n \t\t\t binfo, t, list);\n-  for (vbase = TYPE_BINFO (TREE_TYPE (binfo)); \n+\n+  /* Add the vtables for each of our virtual bases using the vbase in T\n+     binfo.  */\n+  for (vbase = TYPE_BINFO (BINFO_TYPE (binfo)); \n        vbase; \n        vbase = TREE_CHAIN (vbase))\n     {\n       tree b;\n+      tree orig_base;\n \n       if (!TREE_VIA_VIRTUAL (vbase))\n \tcontinue;\n-\n       b = binfo_for_vbase (BINFO_TYPE (vbase), t);\n-      accumulate_vtbl_inits (b, vbase, binfo, t, list);\n+      orig_base = binfo_for_vbase (BINFO_TYPE (vbase), BINFO_TYPE (binfo));\n+      \n+      accumulate_vtbl_inits (b, orig_base, binfo, t, list);\n     }\n-\n   inits = TREE_VALUE (list);\n \n   /* Figure out the type of the construction vtable.  */\n@@ -7072,12 +7238,15 @@ build_ctor_vtbl_group (binfo, t)\n   initialize_array (vtbl, inits);\n }\n \n-/* Add the vtbl initializers for BINFO (and its non-primary,\n-   non-virtual bases) to the list of INITS.  BINFO is in the hierarchy\n-   dominated by T.  ORIG_BINFO must have the same type as BINFO, but\n-   may be different from BINFO if we are building a construction\n-   vtable.  RTTI_BINFO gives the object that should be used as the\n-   complete object for BINFO.  */\n+/* Add the vtbl initializers for BINFO (and its bases other than\n+   non-virtual primaries) to the list of INITS.  BINFO is in the\n+   hierarchy dominated by T.  RTTI_BINFO is the binfo within T of\n+   the constructor the vtbl inits should be accumulated for. (If this\n+   is the complete object vtbl then RTTI_BINFO will be TYPE_BINFO (T).)\n+   ORIG_BINFO is the binfo for this object within BINFO_TYPE (RTTI_BINFO).\n+   BINFO is the active base equivalent of ORIG_BINFO in the inheritance\n+   graph of T. Both BINFO and ORIG_BINFO will have the same BINFO_TYPE,\n+   but are not necessarily the same in terms of layout.  */\n \n static void\n accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n@@ -7088,22 +7257,17 @@ accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n      tree inits;\n {\n   int i;\n-  int ctor_vtbl_p;\n+  int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n \n   my_friendly_assert (same_type_p (BINFO_TYPE (binfo),\n \t\t\t\t   BINFO_TYPE (orig_binfo)),\n \t\t      20000517);\n \n-  /* This is a construction vtable if the RTTI type is not the most\n-     derived type in the hierarchy.  */\n-  ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n-\n   /* If we're building a construction vtable, we're not interested in\n      subobjects that don't require construction vtables.  */\n   if (ctor_vtbl_p \n       && !TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo))\n-      && !(BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P \n-\t   (get_matching_base (binfo, BINFO_TYPE (rtti_binfo)))))\n+      && !binfo_via_virtual (orig_binfo, BINFO_TYPE (rtti_binfo)))\n     return;\n \n   /* Build the initializers for the BINFO-in-T vtable.  */\n@@ -7119,21 +7283,19 @@ accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n      and RTTI_BINFO simultaneously.  */\n   for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n     {\n-      tree base_binfo;\n-\n-      base_binfo = BINFO_BASETYPE (binfo, i);\n+      tree base_binfo = BINFO_BASETYPE (binfo, i);\n+      \n       /* Skip virtual bases.  */\n       if (TREE_VIA_VIRTUAL (base_binfo))\n \tcontinue;\n       accumulate_vtbl_inits (base_binfo,\n \t\t\t     BINFO_BASETYPE (orig_binfo, i),\n-\t\t\t     rtti_binfo,\n-\t\t\t     t,\n+\t\t\t     rtti_binfo, t,\n \t\t\t     inits);\n     }\n }\n \n-/* Called from finish_vtbls via dfs_walk when using the new ABI.\n+/* Called from accumulate_vtbl_inits when using the new ABI.\n    Accumulates the vtable initializers for all of the vtables into\n    TREE_VALUE (DATA).  Returns the initializers for the BINFO vtable.  */\n \n@@ -7146,10 +7308,57 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n      tree l;\n {\n   tree inits = NULL_TREE;\n+  tree vtbl = NULL_TREE;\n+  int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n+\n+  if (ctor_vtbl_p\n+      && TREE_VIA_VIRTUAL (orig_binfo) && BINFO_PRIMARY_P (orig_binfo))\n+    {\n+      /* In the hierarchy of BINFO_TYPE (RTTI_BINFO), this is a primary\n+         virtual base.  If it is not the same primary in the hierarchy of T,\n+         we'll need to generate a ctor vtable for it, to place at its\n+         location in T.  If it is the same primary, we still need a VTT\n+         entry for the vtable, but that must be the base it is a\n+         primary for within the sub-hierarchy of RTTI_BINFO.  */\n+      tree parent;\n+      tree best_primary = NULL;\n+      tree primary_for;\n+      \n+      my_friendly_assert (BINFO_PRIMARY_P (binfo), 20010131);\n \n-  if (BINFO_NEW_VTABLE_MARKED (orig_binfo, t))\n+      for (primary_for = BINFO_PRIMARY_BASE_OF (binfo);\n+           primary_for;\n+           primary_for = BINFO_PRIMARY_BASE_OF (primary_for))\n+        {\n+          for (parent = primary_for;\n+               parent;\n+               parent = BINFO_INHERITANCE_CHAIN (parent))\n+             {\n+               if (parent == rtti_binfo)\n+                 {\n+                   best_primary = primary_for;\n+                   break;\n+                 }\n+             }\n+           if (!parent)\n+             break;\n+        }\n+      if (best_primary)\n+        {\n+          vtbl = BINFO_VTABLE (best_primary);\n+          if (TREE_CODE (vtbl) == TREE_LIST)\n+            {\n+              my_friendly_assert (TREE_PURPOSE (vtbl) == rtti_binfo,\n+                                  20010126);\n+              vtbl = TREE_VALUE (vtbl);\n+            }\n+        }\n+    }\n+  else if (!BINFO_NEW_VTABLE_MARKED (orig_binfo, BINFO_TYPE (rtti_binfo)))\n+    return inits;\n+  \n+  if (!vtbl)\n     {\n-      tree vtbl;\n       tree index;\n       int non_fn_entries;\n \n@@ -7170,25 +7379,30 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n \t\t\t  index);\n       vtbl = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, index);\n       TREE_CONSTANT (vtbl) = 1;\n+    }\n \n+  if (!ctor_vtbl_p)\n+    {\n       /* For an ordinary vtable, set BINFO_VTABLE.  */\n-      if (same_type_p (BINFO_TYPE (rtti_binfo), t))\n-\tBINFO_VTABLE (binfo) = vtbl;\n-      /* For a construction vtable, we can't overwrite BINFO_VTABLE.\n-\t So, we make a TREE_LIST.  Later, dfs_fixup_binfo_vtbls will\n-\t straighten this out.  */\n-      else\n-\tBINFO_VTABLE (binfo) = \n-\t  tree_cons (rtti_binfo, vtbl, BINFO_VTABLE (binfo));\n+      BINFO_VTABLE (binfo) = vtbl;\n+      if (BINFO_PRIMARY_P (binfo) && TREE_VIA_VIRTUAL (binfo))\n+        inits = NULL_TREE;\n     }\n+  else\n+    /* For a construction vtable, we can't overwrite BINFO_VTABLE.\n+       So, we make a TREE_LIST.  Later, dfs_fixup_binfo_vtbls will\n+       straighten this out.  */\n+    BINFO_VTABLE (binfo) = tree_cons (rtti_binfo, vtbl, BINFO_VTABLE (binfo));\n \n   return inits;\n }\n \n /* Construct the initializer for BINFOs virtual function table.  BINFO\n    is part of the hierarchy dominated by T.  If we're building a\n    construction vtable, the ORIG_BINFO is the binfo we should use to\n-   find the actual function pointers to put in the vtable.  Otherwise,\n+   find the actual function pointers to put in the vtable - but they\n+   can be overridden on the path to most-derived in the graph that\n+   ORIG_BINFO belongs.  Otherwise,\n    ORIG_BINFO should be the same as BINFO.  The RTTI_BINFO is the\n    BINFO that should be indicated by the RTTI information in the\n    vtable; it will be a base class of T, rather than T itself, if we\n@@ -7200,9 +7414,9 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n    number of non-function entries in the vtable.  \n \n    It might seem that this function should never be called with a\n-   BINFO for which BINFO_PRIMARY_MARKED_P holds, the vtable for such a\n+   BINFO for which BINFO_PRIMARY_P holds, the vtable for such a\n    base is always subsumed by a derived class vtable.  However, when\n-   we are building construction vtables we do build vtables for\n+   we are building construction vtables, we do build vtables for\n    primary bases; we need these while the primary base is being\n    constructed.  */\n \n@@ -7489,7 +7703,7 @@ add_vcall_offset_vtbl_entries_r (binfo, vid)\n     }\n }\n \n-/* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n+/* Called from build_vcall_offset_vtbl_entries_r.  */\n \n static void\n add_vcall_offset_vtbl_entries_1 (binfo, vid)\n@@ -7579,7 +7793,7 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n       if (i != VARRAY_ACTIVE_SIZE (vid->fns))\n \tcontinue;\n \n-      /* The FN comes from BASE.  So, we must caculate the adjustment\n+      /* The FN comes from BASE.  So, we must calculate the adjustment\n \t from the virtual base that derived from BINFO to BASE.  */\n       base = DECL_CONTEXT (fn);\n       base_binfo = get_binfo (base, vid->derived, /*protect=*/0);\n@@ -7635,13 +7849,13 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vid)\n   /* To find the complete object, we will first convert to our most\n      primary base, and then add the offset in the vtbl to that value.  */\n   b = binfo;\n-  while (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (b)))\n+  while (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (b))\n+         && !BINFO_LOST_PRIMARY_P (b))\n     {\n       tree primary_base;\n \n       primary_base = get_primary_binfo (b);\n-      if (!BINFO_PRIMARY_MARKED_P (primary_base))\n-\tbreak;\n+      my_friendly_assert (BINFO_PRIMARY_BASE_OF (primary_base) == b, 20010127);\n       b = primary_base;\n     }\n   offset = size_diffop (BINFO_OFFSET (rtti_binfo), BINFO_OFFSET (b));"}, {"sha": "d473006f24e8ead2e4d5383140680f988448d4f7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -60,7 +60,7 @@ Boston, MA 02111-1307, USA.  */\n       TYPE_POLYMORHPIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n       BINDING_HAS_LEVEL_P (in CPLUS_BINDING)\n-      BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P (in BINFO)\n+      BINFO_LOST_PRIMARY_P (in BINFO)\n       TREE_PARMLIST (in TREE_LIST)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n       BINFO_VTABLE_PATH_MARKED.\n@@ -1158,6 +1158,10 @@ extern int flag_access_control;\n \n extern int flag_check_new;\n \n+/* Nonnull if we want to dump class heirarchies. */\n+\n+extern const char *flag_dump_class_layout;\n+\n \f\n /* C++ language-specific tree codes.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n@@ -1672,11 +1676,11 @@ struct lang_type\n   (TREE_LANG_FLAG_4 (CANONICAL_BINFO (B, C)))\n \n /* Any subobject that needs a new vtable must have a vptr and must not\n-   be a primary base (since it would then use the vtable from a\n-   derived class.)  */\n+   be a non-virtual primary base (since it would then use the vtable from a\n+   derived class and never become non-primary.)  */\n #define SET_BINFO_NEW_VTABLE_MARKED(B, C)\t\t\t\t \\\n   (BINFO_NEW_VTABLE_MARKED (B, C) = 1,\t\t\t\t\t \\\n-   my_friendly_assert (!BINFO_PRIMARY_MARKED_P (B), 20000517),\t\t \\\n+   my_friendly_assert (!BINFO_PRIMARY_P (B) || TREE_VIA_VIRTUAL (B), 20000517),\t\t \\\n    my_friendly_assert (CLASSTYPE_VFIELDS (BINFO_TYPE (B)) != NULL_TREE,  \\\n \t\t       20000517))\n \n@@ -1691,7 +1695,7 @@ struct lang_type\n    class of a non-primary virtual base.  This flag is only valid for\n    paths (given by BINFO_INHERITANCE_CHAIN) that really exist in the\n    final object.  */\n-#define BINFO_PRIMARY_MARKED_P(NODE) \\\n+#define BINFO_PRIMARY_P(NODE) \\\n   (BINFO_PRIMARY_BASE_OF (NODE) != NULL_TREE)\n \n /* The index in the VTT where this subobject's sub-VTT can be found.\n@@ -1708,9 +1712,10 @@ struct lang_type\n    immediate base.)  */\n #define BINFO_PRIMARY_BASE_OF(NODE) TREE_VEC_ELT ((NODE), 10)\n \n-/* Nonzero if this binfo declares a virtual function which is\n-   overridden along a virtual path.  */\n-#define BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P(NODE) TREE_LANG_FLAG_2 (NODE)\n+/* Nonzero if this binfo has lost its primary base binfo (because that\n+   is a nearly-empty virtual base that has been taken by some other\n+   base in the complete heirarchy.  */\n+#define BINFO_LOST_PRIMARY_P(NODE) TREE_LANG_FLAG_2 (NODE)\n \n /* Nonzero if this binfo is an indirect primary base, i.e. a virtual\n    base that is a primary base of some of other class in the\n@@ -4248,6 +4253,7 @@ extern tree unmarked_vtable_pathp               PARAMS ((tree, void *));\n extern tree convert_pointer_to_vbase            PARAMS ((tree, tree));\n extern tree find_vbase_instance                 PARAMS ((tree, tree));\n extern tree binfo_for_vbase                     PARAMS ((tree, tree));\n+extern tree binfo_via_virtual                   PARAMS ((tree, tree));\n extern void fixup_all_virtual_upcast_offsets    PARAMS ((tree));\n \n /* in semantics.c */"}, {"sha": "fff395670a7cc8f1e88bc4d0f803499f7c83b237", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -403,6 +403,10 @@ int flag_operator_names = 1;\n \n int flag_check_new;\n \n+/* Nonnull if we want to dump class heirarchies.  */\n+\n+const char *flag_dump_class_layout;\n+\n /* Nonzero if we want the new ISO rules for pushing a new scope for `for'\n    initialization variables.\n    0: Old rules, set by -fno-for-scope.\n@@ -647,13 +651,23 @@ cxx_decode_option (argc, argv)\n \tname_mangling_version \n \t  = read_integral_parameter (option_value, p - 2, name_mangling_version);\n       else if ((option_value\n-                = skip_leading_substring (p, \"dump-translation-unit-\")))\n+                = skip_leading_substring (p, \"dump-translation-unit=\")))\n \t{\n-\t  if (p[22] == '\\0')\n+\t  if (!*option_value)\n \t    error (\"no file specified with -fdump-translation-unit\");\n \t  else\n \t    flag_dump_translation_unit = option_value;\n \t}\n+      else if ((option_value\n+                = skip_leading_substring (p, \"dump-class-layout=\")))\n+\t{\n+\t  if (!*option_value)\n+\t    error (\"no file specified with -fdump-class-layout\");\n+\t  else\n+\t    flag_dump_class_layout = option_value;\n+\t}\n+      else if (!strcmp (p, \"dump-class-layout\"))\n+\tflag_dump_class_layout = \"\"; /* empty string for stderr */\n       else \n \t{\n \t  int found = 0;"}, {"sha": "e7d62934d6da11010699a7bdc96c0e1eb9a46098", "filename": "gcc/cp/init.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -137,7 +137,7 @@ dfs_initialize_vtbl_ptrs (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  if (!BINFO_PRIMARY_MARKED_P (binfo) \n+  if ((!BINFO_PRIMARY_P (binfo) || TREE_VIA_VIRTUAL (binfo))\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n       tree base_ptr = TREE_VALUE ((tree) data);\n@@ -802,16 +802,27 @@ static tree\n build_vtbl_address (binfo)\n      tree binfo;\n {\n+  tree binfo_for = binfo;\n   tree vtbl;\n \n+  if (BINFO_VPTR_INDEX (binfo) && TREE_VIA_VIRTUAL (binfo)\n+      && BINFO_PRIMARY_P (binfo))\n+    /* If this is a virtual primary base, then the vtable we want to store\n+       is that for the base this is being used as the primary base of.  We\n+       can't simply skip the initialization, because we may be expanding the\n+       inits of a subobject constructor where the virtual base layout\n+       can be different.  */\n+    while (BINFO_PRIMARY_BASE_OF (binfo_for))\n+      binfo_for = BINFO_PRIMARY_BASE_OF (binfo_for);\n+\n   /* Figure out what vtable BINFO's vtable is based on, and mark it as\n      used.  */\n-  vtbl = get_vtbl_decl_for_binfo (binfo);\n+  vtbl = get_vtbl_decl_for_binfo (binfo_for);\n   assemble_external (vtbl);\n   TREE_USED (vtbl) = 1;\n \n   /* Now compute the address to use when initializing the vptr.  */\n-  vtbl = BINFO_VTABLE (binfo);\n+  vtbl = BINFO_VTABLE (binfo_for);\n   if (TREE_CODE (vtbl) == VAR_DECL)\n     {\n       vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);"}, {"sha": "1699c325f6691113a8384190c38b092866ae4b19", "filename": "gcc/cp/search.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -2045,7 +2045,7 @@ dfs_skip_nonprimary_vbases_unmarkedp (binfo, data)\n      tree binfo;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_P (binfo))\n     /* This is a non-primary virtual base.  Skip it.  */\n     return NULL_TREE;\n \n@@ -2060,7 +2060,7 @@ dfs_skip_nonprimary_vbases_markedp (binfo, data)\n      tree binfo;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_P (binfo))\n     /* This is a non-primary virtual base.  Skip it.  */\n     return NULL_TREE;\n \n@@ -2078,7 +2078,7 @@ get_shared_vbase_if_not_primary (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_P (binfo))\n     {\n       tree type = (tree) data;\n \n@@ -2088,7 +2088,7 @@ get_shared_vbase_if_not_primary (binfo, data)\n       /* This is a non-primary virtual base.  If there is no primary\n \t version, get the shared version.  */\n       binfo = binfo_for_vbase (BINFO_TYPE (binfo), type);\n-      if (BINFO_PRIMARY_MARKED_P (binfo))\n+      if (BINFO_PRIMARY_P (binfo))\n \treturn NULL_TREE;\n     }\n \n@@ -2152,7 +2152,7 @@ dfs_get_pure_virtuals (binfo, data)\n   /* We're not interested in primary base classes; the derived class\n      of which they are a primary base will contain the information we\n      need.  */\n-  if (!BINFO_PRIMARY_MARKED_P (binfo))\n+  if (!BINFO_PRIMARY_P (binfo))\n     {\n       tree virtuals;\n       \n@@ -2455,7 +2455,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n   tree delta;\n   HOST_WIDE_INT n;\n \n-  while (BINFO_PRIMARY_MARKED_P (binfo))\n+  while (BINFO_PRIMARY_P (binfo))\n     {\n       binfo = BINFO_INHERITANCE_CHAIN (binfo);\n       if (TREE_VIA_VIRTUAL (binfo))\n@@ -2593,7 +2593,7 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n       tree real_base_binfo = TREE_VEC_ELT (real_binfos, i);\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       int is_not_base_vtable\n-\t= !BINFO_PRIMARY_MARKED_P (real_base_binfo);\n+\t= !BINFO_PRIMARY_P (real_base_binfo);\n       if (! TREE_VIA_VIRTUAL (real_base_binfo))\n \tfixup_virtual_upcast_offsets (real_base_binfo, base_binfo,\n \t\t\t\t      is_not_base_vtable, can_elide, addr,\n@@ -2737,7 +2737,7 @@ dfs_find_vbase_instance (binfo, data)\n {\n   tree base = TREE_VALUE ((tree) data);\n \n-  if (BINFO_PRIMARY_MARKED_P (binfo)\n+  if (BINFO_PRIMARY_P (binfo)\n       && same_type_p (BINFO_TYPE (binfo), base))\n     return binfo;\n \n@@ -2755,7 +2755,7 @@ find_vbase_instance (base, type)\n   tree instance;\n \n   instance = binfo_for_vbase (base, type);\n-  if (!BINFO_PRIMARY_MARKED_P (instance))\n+  if (!BINFO_PRIMARY_P (instance))\n     return instance;\n \n   return dfs_walk (TYPE_BINFO (type), \n@@ -3249,8 +3249,8 @@ binfo_for_vtable (var)\n   return main_binfo;\n }\n \n-/* Returns the binfo of the first direct or indirect virtual base from\n-   which BINFO is derived, or NULL if binfo is not via virtual.  */\n+/* Returns the binfo of the first direct or indirect virtual base derived\n+   from BINFO, or NULL if binfo is not via virtual.  */\n \n tree\n binfo_from_vbase (binfo)\n@@ -3264,6 +3264,24 @@ binfo_from_vbase (binfo)\n   return NULL_TREE;\n }\n \n+/* Returns the binfo of the first direct or indirect virtual base derived\n+   from BINFO up to the TREE_TYPE, LIMIT, or NULL if binfo is not\n+   via virtual.  */\n+\n+tree\n+binfo_via_virtual (binfo, limit)\n+     tree binfo;\n+     tree limit;\n+{\n+  for (; binfo && (!limit || !same_type_p (BINFO_TYPE (binfo), limit));\n+       binfo = BINFO_INHERITANCE_CHAIN (binfo))\n+    {\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\treturn binfo;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Returns the BINFO (if any) for the virtual baseclass T of the class\n    C from the CLASSTYPE_VBASECLASSES list.  */\n "}, {"sha": "8052be177ec393f92769e66d282cd2c075fedbc5", "filename": "gcc/invoke.texi", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -223,8 +223,8 @@ in the following sections.\n @item Debugging Options\n @xref{Debugging Options,,Options for Debugging Your Program or GCC}.\n @gccoptlist{\n--a  -ax  -d@var{letters}  -fdump-unnumbered -fdump-translation-unit-@var{file} @gol\n--fpretend-float -fprofile-arcs  -ftest-coverage @gol\n+-a  -ax  -d@var{letters}  -fdump-unnumbered -fdump-translation-unit=@var{file} @gol\n+-fdump-class-layout=@var{file} -fpretend-float -fprofile-arcs  -ftest-coverage @gol\n -g  -g@var{level}  -gcoff  -gdwarf  -gdwarf-1  -gdwarf-1+  -gdwarf-2 @gol\n -ggdb  -gstabs  -gstabs+  -gxcoff  -gxcoff+ @gol\n -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol\n@@ -2679,10 +2679,15 @@ numbers and line number note output.  This makes it more feasible to\n use diff on debugging dumps for compiler invocations with different\n options, in particular with and without -g.\n \n-@item -fdump-translation-unit-@var{file} (C and C++ only)\n+@item -fdump-translation-unit=@var{file} (C and C++ only)\n Dump a representation of the tree structure for the entire translation\n unit to @var{file}.\n \n+@item -fdump-class_layout=@var{file} (C++ only)\n+@item -fdump-class_layout (C++ only)\n+Dump a representation of each class's heirarchy to @var{file}, or\n+@code{stderr} if not specified.\n+\n @item -fpretend-float\n When running a cross-compiler, pretend that the target machine uses the\n same floating point format as the host machine.  This causes incorrect"}, {"sha": "2cec5af45117ca8aff7690bbe742688c69df4839", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -1,3 +1,22 @@\n+2001-02-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.abi/primary2.C: New test.\n+\t* g++.old-deja/g++.abi/primary3.C: New test.\n+\t* g++.old-deja/g++.abi/primary4.C: New test.\n+\t* g++.old-deja/g++.abi/primary5.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3.h: New test.\n+\t* g++.old-deja/g++.abi/vtable3a.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3b.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3c.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3d.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3e.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3f.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3g.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3h.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3i.C: New test.\n+\t* g++.old-deja/g++.abi/vtable3j.C: New test.\n+\t* g++.old-deja/g++.oliva/thunk1.C: Remove XFAIL.\n+\n 2001-02-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.old-deja/g++.other/anon6.C: New test."}, {"sha": "795eb4d61c0e2a97295b8b54ee70c6573f89da34", "filename": "gcc/testsuite/g++.old-deja/g++.abi/primary2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary2.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check primary bases are chosen correctly.\n+\n+struct A {virtual void Foo () {}};\n+struct B : virtual A {};\n+struct C : virtual B {};\n+struct D : virtual B, virtual C {};\n+\n+int main ()\n+{\n+  D d;\n+\n+#if __GXX_ABI_VERSION >= 100\n+  if (sizeof (D) != sizeof (A))\n+    return 1;\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "ef245ef789ea83c6ed7987485f089de57435f432", "filename": "gcc/testsuite/g++.old-deja/g++.abi/primary3.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary3.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check primary bases are chosen correctly.\n+\n+struct A {virtual void Foo () {}};\n+struct B1 : virtual A {};\n+struct B2 : virtual A {};\n+struct C : virtual B1, B2 {};\n+struct D : virtual C {};\n+\n+int main ()\n+{\n+  C c;\n+  D d;\n+  \n+  A *apc = &c;\n+  B1 *b1pc = &c;\n+  B2 *b2pc = &c;\n+  \n+  A *apd = &d;\n+  B1 *b1pd = &d;\n+  B2 *b2pd = &d;\n+  \n+#if __GXX_ABI_VERSION >= 100\n+  if (static_cast <void *> (apc) != static_cast <void *> (b1pc))\n+    return 1;\n+  if (static_cast <void *> (apd) != static_cast <void *> (b1pd))\n+    return 2;\n+  if (static_cast <void *> (apd) != static_cast <void *> (&d))\n+    return 3;\n+#endif\n+  return 0;\n+}"}, {"sha": "d18f24297d6af49f77e1f09d08ed457b855d3b99", "filename": "gcc/testsuite/g++.old-deja/g++.abi/primary4.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary4.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check primary bases are chosen correctly.\n+\n+struct A { virtual void Foo () {}};\n+\n+struct B1 : virtual A {};\n+struct B2 : virtual A {};\n+\n+struct C : virtual B1 {};\n+\n+struct D : virtual B1, B2, C {};\n+\n+int main ()\n+{\n+  D d;\n+  A *ap = &d;\n+  C *cp = &d;\n+  \n+#if __GXX_ABI_VERSION >= 100\n+  if (static_cast <void *> (ap) != static_cast <void *> (cp))\n+    return 1;\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "422e66e11d6ce208193593902231361f44ffb58d", "filename": "gcc/testsuite/g++.old-deja/g++.abi/primary5.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fprimary5.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check primary bases are chosen correctly.\n+\n+struct A1\n+{\n+   virtual void Foo () {};\n+};\n+\n+struct A : A1\n+{\n+};\n+\n+struct B : A\n+{\n+};\n+\n+struct C : virtual B\n+{\n+};\n+\n+struct D : virtual B, virtual C\n+{\n+};\n+\n+int main()\n+{\n+  D d;\n+#if __GXX_ABI_VERSION >= 100\n+  if (sizeof (D) != sizeof (A))\n+    return 1;\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "327d346db2767047a4e9991e9dd7a9af5560065c", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3.h", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3.h?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,181 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work. This is included from numerous test\n+// files, which set the #defines necessary to specify the heirarchy.\n+\n+#include <typeinfo>\n+#include <stdio.h>\n+\n+// XXX. vcall offsets are still broken, remove this define to re-enable\n+// testing when fixed.\n+#define NO_VCALL_TEST\n+\n+int fail;\n+\n+template <typename BASE, typename DERIVED>\n+int Test (DERIVED *d, int expect)\n+{\n+  BASE *b = static_cast <BASE *> (d);\n+  void *full_b = dynamic_cast <void *> (b);\n+  void *full_d = dynamic_cast <void *> (d);\n+  \n+  if (full_b != full_d)\n+    {\n+      fail++;\n+      fprintf (stderr, \"base %s and derived %s have different full objects\\n\",\n+              typeid (BASE).name (), typeid (DERIVED).name ());\n+      return 1;\n+    }\n+\n+  DERIVED *dynamic_d = dynamic_cast <DERIVED *> (b);\n+  \n+  if (dynamic_d != d)\n+    {\n+      fail++;\n+      fprintf (stderr, \"dynamic_cast from %s to %s failed\\n\",\n+              typeid (BASE).name (), typeid (DERIVED).name ());\n+      return 1;\n+    }\n+#ifndef NO_VCALL_TEST\n+  b->Baz (static_cast <void *> (b));\n+  \n+  int res = b->Foo (static_cast <void *> (d));\n+  \n+  if (res != expect)\n+    {\n+      fail++;\n+      fprintf (stderr, \"%s::Foo returned %d, expected %d\\n\",\n+              typeid (BASE).name (), res, expect);\n+      return 1;\n+    }\n+#endif\n+  return 0;\n+}\n+\n+template <typename T>\n+int Test (T *self, void *expected, int result)\n+{\n+  if (self != expected)\n+    {\n+      fail++;\n+      fprintf (stderr, \"%s::Foo wrong this pointer\\n\", typeid (T).name ());\n+    }\n+  return result;\n+}\n+\n+struct A {\n+#ifndef A_EMPTY\n+  int a_m;\n+#endif\n+  virtual int Foo (void *p) {return Test (this, p, 1);}\n+  virtual int Baz (void *p) {return Test (this, p, 1);}\n+  A ();\n+  ~A ();\n+};\n+\n+struct B1: virtual A {\n+#ifndef B1_EMPTY\n+  int b1_m;\n+#endif\n+  virtual int Foo (void *p) {return Test (this, p, 2);}\n+  B1();\n+  ~B1();\n+};\n+\n+struct B2: virtual A {\n+#ifndef B2_EMPTY\n+  int b2_m;\n+#endif\n+  virtual int Foo (void *p) {return Test (this, p, 3);}\n+  B2();\n+  ~B2();\n+};\n+\n+struct Empty {};\n+\n+struct C : C_PARENTS {\n+#ifndef C_EMPTY\n+  int c_m;\n+#endif\n+  virtual int Foo (void *p) {return Test (this, p, 4);}\n+  C();\n+  ~C();\n+};\n+\n+A::A ()\n+{\n+  fprintf (stderr, \"%s\\n\", __PRETTY_FUNCTION__);\n+  Test <A> (this, 1);\n+}\n+A::~A ()\n+{\n+  fprintf (stderr, \"%s\\n\", __PRETTY_FUNCTION__);\n+  Test <A> (this, 1);\n+}\n+\n+B1::B1()\n+{\n+  fprintf (stderr, \"%s\\n\", __PRETTY_FUNCTION__);\n+  Test <A> (this, 2);\n+  Test <B1> (this, 2);\n+}\n+B1::~B1()\n+{\n+  fprintf (stderr, \"%s\\n\", __PRETTY_FUNCTION__);\n+  Test <A> (this, 2);\n+  Test <B1> (this, 2);\n+}\n+B2::B2()\n+{\n+  fprintf (stderr, \"%s\\n\", __PRETTY_FUNCTION__);\n+  Test <A> (this, 3);\n+  Test <B2> (this, 3);\n+}\n+B2::~B2()\n+{\n+  fprintf (stderr, \"%s\\n\", __PRETTY_FUNCTION__);\n+  Test <A> (this, 3);\n+  Test <B2> (this, 3);\n+}\n+C::C()\n+{\n+  fprintf (stderr, \"%s\\n\", __PRETTY_FUNCTION__);\n+  Test <A> (this, 4);\n+  Test <C> (this, 4);\n+}\n+C::~C()\n+{\n+  fprintf (stderr, \"%s\\n\", __PRETTY_FUNCTION__);\n+  Test <A> (this, 4);\n+  Test <C> (this, 4);\n+}\n+\n+struct D : C {};\n+struct D1 : virtual C {};\n+struct D2 : virtual A, virtual C {};\n+\n+int main()\n+{\n+  {\n+    fprintf (stderr, \"C\\n\");\n+    C c;\n+  }\n+  {\n+    fprintf (stderr, \"D\\n\");\n+    D d;\n+  }\n+  {\n+    fprintf (stderr, \"D1\\n\");\n+    D1 d1;\n+  }\n+  {\n+    fprintf (stderr, \"D2\\n\");\n+    D2 d2;\n+  }\n+  if (fail)\n+    fprintf (stderr, \"There are %d failings\\n\", fail);\n+  else\n+    fprintf (stderr, \"Passed\\n\");\n+  return fail ? 1 : 0;\n+}"}, {"sha": "99d3d0b9ecd0fb18798f9c8f2564c517c88f0b02", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3a.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3a.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,12 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define A_EMPTY\n+#define B1_EMPTY\n+#define B2_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS B1, B2\n+\n+#include \"vtable3.h\""}, {"sha": "4d4bd99851225787dbbe26a3de0f79b5caf01053", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3b.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3b.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define B1_EMPTY\n+#define B2_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS B1, B2\n+\n+#include \"vtable3.h\""}, {"sha": "2863ca5ec5f7039657f21e6066d4702e9571743a", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3c.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3c.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define A_EMPTY\n+#define B2_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS B1, B2\n+\n+#include \"vtable3.h\""}, {"sha": "a3a2cbcb5a9ba302ee281af23ee1b10e76f753e3", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3d.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3d.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3d.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3d.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define A_EMPTY\n+#define B1_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS B1, B2\n+\n+#include \"vtable3.h\""}, {"sha": "a1c8a9d59e400d8bcb304309e4941ad61f3fddb8", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3e.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3e.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3e.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3e.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define A_EMPTY\n+#define B1_EMPTY\n+#define B2_EMPTY\n+#define C_PARENTS B1, B2\n+\n+#include \"vtable3.h\""}, {"sha": "7bcf40ccf4b7ba73e1de55d0a16a0047e41a0355", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3f.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3f.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3f.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3f.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,12 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define A_EMPTY\n+#define B1_EMPTY\n+#define B2_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS B1, virtual B2\n+\n+#include \"vtable3.h\""}, {"sha": "1ad70bc31604003dd6bf8dac1a080d6d3b719f1f", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3g.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3g.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3g.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3g.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,12 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define A_EMPTY\n+#define B1_EMPTY\n+#define B2_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS virtual B1, B2\n+\n+#include \"vtable3.h\""}, {"sha": "074bda44c7a277f5b19f47c1ba345597f96051ce", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3h.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3h.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3h.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3h.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,12 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define A_EMPTY\n+#define B1_EMPTY\n+#define B2_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS virtual B1, virtual B2\n+\n+#include \"vtable3.h\""}, {"sha": "d6fc3a3506b7c67d945505be26f0bd04b65e0151", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3i.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3i.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3i.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3i.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define B1_EMPTY\n+#define B2_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS virtual B1, B2\n+\n+#include \"vtable3.h\""}, {"sha": "1af5225c536b8aa8bfeb1ce60a24be6990068d5b", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable3j.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3j.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3j.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable3j.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 February 2001 <nathan@codesourcery.com>\n+\n+// Check constructor vtables work.\n+\n+#define B1_EMPTY\n+#define B2_EMPTY\n+#define C_EMPTY\n+#define C_PARENTS virtual B1, virtual B2\n+\n+#include \"vtable3.h\""}, {"sha": "225a1f981039e544357f2bedb16e5ea86aaf0c18", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/thunk1.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fthunk1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9965d119133a5cb80938b829d28fa45777667a0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fthunk1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fthunk1.C?ref=9965d119133a5cb80938b829d28fa45777667a0c", "patch": "@@ -4,7 +4,6 @@\n // based on bug report by Fredrik \ufffdhrstr\ufffdm <d92-foh@nada.kth.se>\n \n // Special g++ Options: -fvtable-thunks\n-// execution test - XFAIL *-*-*\n \n #include <cstdlib>\n "}]}