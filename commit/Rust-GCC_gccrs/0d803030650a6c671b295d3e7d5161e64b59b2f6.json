{"sha": "0d803030650a6c671b295d3e7d5161e64b59b2f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ4MDMwMzA2NTBhNmM2NzFiMjk1ZDNlN2Q1MTYxZTY0YjU5YjJmNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-15T12:56:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-15T12:56:34Z"}, "message": "Turn CANNOT_CHANGE_MODE_CLASS into a hook\n\nThis also seemed like a good opportunity to reverse the sense of the\nhook to \"can\", to avoid the awkward double negative in !CANNOT.\n\n2017-09-15  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayard  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (can_change_mode_class): New hook.\n\t(mode_rep_extended): Refer to it instead of CANNOT_CHANGE_MODE_CLASS.\n\t(hard_regno_nregs): Likewise.\n\t* hooks.h (hook_bool_mode_mode_reg_class_t_true): Declare.\n\t* hooks.c (hook_bool_mode_mode_reg_class_t_true): New function.\n\t* doc/tm.texi.in (CANNOT_CHANGE_MODE_CLASS): Replace with...\n\t(TARGET_CAN_CHANGE_MODE_CLASS): ...this.\n\t(LOAD_EXTEND_OP): Update accordingly.\n\t* doc/tm.texi: Regenerate.\n\t* doc/rtl.texi: Refer to TARGET_CAN_CHANGE_MODE_CLASS instead of\n\tCANNOT_CHANGE_MODE_CLASS.\n\t* hard-reg-set.h (REG_CANNOT_CHANGE_MODE_P): Replace with...\n\t(REG_CAN_CHANGE_MODE_P): ...this new macro.\n\t* combine.c (simplify_set): Update accordingly.\n\t* emit-rtl.c (validate_subreg): Likewise.\n\t* recog.c (general_operand): Likewise.\n\t* regcprop.c (mode_change_ok): Likewise.\n\t* reload1.c (choose_reload_regs): Likewise.\n\t(inherit_piecemeal_p): Likewise.\n\t* rtlanal.c (simplify_subreg_regno): Likewise.\n\t* postreload.c (reload_cse_simplify_set): Use REG_CAN_CHANGE_MODE_P\n\tinstead of CANNOT_CHANGE_MODE_CLASS.\n\t(reload_cse_simplify_operands): Likewise.\n\t* reload.c (push_reload): Use targetm.can_change_mode_class\n\tinstead of CANNOT_CHANGE_MODE_CLASS.\n\t(push_reload): Likewise.  Also use REG_CAN_CHANGE_MODE_P instead of\n\tREG_CANNOT_CHANGE_MODE_P.\n\t* config/alpha/alpha.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/alpha/alpha.c (alpha_can_change_mode_class): New function.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t* config/arm/arm.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/arm/arm.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(arm_can_change_mode_class): New function.\n\t* config/arm/neon.md: Refer to TARGET_CAN_CHANGE_MODE_CLASS rather\n\tthan CANNOT_CHANGE_MODE_CLASS in comments.\n\t* config/i386/i386.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/i386/i386-protos.h (ix86_cannot_change_mode_class): Delete.\n\t* config/i386/i386.c (ix86_cannot_change_mode_class): Replace with...\n\t(ix86_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t* config/ia64/ia64.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/ia64/ia64.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(ia64_can_change_mode_class): New function.\n\t* config/m32c/m32c.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/m32c/m32c-protos.h (m32c_cannot_change_mode_class): Delete.\n\t* config/m32c/m32c.c (m32c_cannot_change_mode_class): Replace with...\n\t(m32c_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t* config/mips/mips.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/mips/mips-protos.h (mips_cannot_change_mode_class): Delete.\n\t* config/mips/mips.c (mips_cannot_change_mode_class): Replace with...\n\t(mips_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t* config/msp430/msp430.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/msp430/msp430.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(msp430_can_change_mode_class): New function.\n\t* config/nvptx/nvptx.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/nvptx/nvptx.c (nvptx_can_change_mode_class): New function.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t* config/pa/pa32-regs.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/pa/pa64-regs.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/pa/pa-protos.h (pa_cannot_change_mode_class): Delete.\n\t* config/pa/pa.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(pa_cannot_change_mode_class): Replace with...\n\t(pa_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t(pa_modes_tieable_p): Refer to TARGET_CAN_CHANGE_MODE_CLASS rather\n\tthan CANNOT_CHANGE_MODE_CLASS in comments.\n\t* config/pdp11/pdp11.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/pdp11/pdp11-protos.h (pdp11_cannot_change_mode_class): Delete.\n\t* config/pdp11/pdp11.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(pdp11_cannot_change_mode_class): Replace with...\n\t(pdp11_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t* config/powerpcspe/powerpcspe.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/powerpcspe/powerpcspe-protos.h\n\t(rs6000_cannot_change_mode_class_ptr): Delete.\n\t* config/powerpcspe/powerpcspe.c\n\t(rs6000_cannot_change_mode_class_ptr): Delete.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(rs6000_option_override_internal): Assign to\n\ttargetm.can_change_mode_class instead of\n\trs6000_cannot_change_mode_class_ptr.\n\t(rs6000_cannot_change_mode_class): Replace with...\n\t(rs6000_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t(rs6000_debug_cannot_change_mode_class): Replace with...\n\t(rs6000_debug_can_change_mode_class): ...this new function.\n\t* config/riscv/riscv.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/riscv/riscv.c (riscv_can_change_mode_class): New function.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t* config/rs6000/rs6000.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/rs6000/rs6000-protos.h (rs6000_cannot_change_mode_class_ptr):\n\tDelete.\n\t* config/rs6000/rs6000.c (rs6000_cannot_change_mode_class_ptr): Delete.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(rs6000_option_override_internal): Assign to\n\ttargetm.can_change_mode_class instead of\n\trs6000_cannot_change_mode_class_ptr.\n\t(rs6000_cannot_change_mode_class): Replace with...\n\t(rs6000_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t(rs6000_debug_cannot_change_mode_class): Replace with...\n\t(rs6000_debug_can_change_mode_class): ...this new function.\n\t* config/s390/s390.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/s390/s390-protos.h (s390_cannot_change_mode_class): Delete.\n\t* config/s390/s390.c (s390_cannot_change_mode_class): Replace with...\n\t(s390_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t* config/sh/sh.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/sh/sh-protos.h (sh_cannot_change_mode_class): Delete.\n\t* config/sh/sh.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(sh_cannot_change_mode_class): Replace with...\n\t(sh_can_change_mode_class): ...this new function, inverting the\n\tsense of the return value.\n\t* config/sparc/sparc.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/sparc/sparc.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(sparc_can_change_mode_class): New function.\n\t* config/spu/spu.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/spu/spu.c (spu_can_change_mode_class): New function.\n\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t* config/visium/visium.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n\t* config/visium/visium.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n\t(visium_can_change_mode_class): New function.\n\t* system.h (CANNOT_CHANGE_MODE_CLASS): Poison.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252816", "tree": {"sha": "854fba2d2be98f794a0e01b4efb9f6621aab2d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/854fba2d2be98f794a0e01b4efb9f6621aab2d03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d803030650a6c671b295d3e7d5161e64b59b2f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d803030650a6c671b295d3e7d5161e64b59b2f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d803030650a6c671b295d3e7d5161e64b59b2f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d803030650a6c671b295d3e7d5161e64b59b2f6/comments", "author": null, "committer": null, "parents": [{"sha": "fa0cdfb651f59951d10331b782c422baad93d3e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa0cdfb651f59951d10331b782c422baad93d3e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa0cdfb651f59951d10331b782c422baad93d3e4"}], "stats": {"total": 971, "additions": 557, "deletions": 414}, "files": [{"sha": "fa5f73476243b122dc4ea450e20627fa874268e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1,3 +1,137 @@\n+2017-09-15  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayard  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (can_change_mode_class): New hook.\n+\t(mode_rep_extended): Refer to it instead of CANNOT_CHANGE_MODE_CLASS.\n+\t(hard_regno_nregs): Likewise.\n+\t* hooks.h (hook_bool_mode_mode_reg_class_t_true): Declare.\n+\t* hooks.c (hook_bool_mode_mode_reg_class_t_true): New function.\n+\t* doc/tm.texi.in (CANNOT_CHANGE_MODE_CLASS): Replace with...\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): ...this.\n+\t(LOAD_EXTEND_OP): Update accordingly.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/rtl.texi: Refer to TARGET_CAN_CHANGE_MODE_CLASS instead of\n+\tCANNOT_CHANGE_MODE_CLASS.\n+\t* hard-reg-set.h (REG_CANNOT_CHANGE_MODE_P): Replace with...\n+\t(REG_CAN_CHANGE_MODE_P): ...this new macro.\n+\t* combine.c (simplify_set): Update accordingly.\n+\t* emit-rtl.c (validate_subreg): Likewise.\n+\t* recog.c (general_operand): Likewise.\n+\t* regcprop.c (mode_change_ok): Likewise.\n+\t* reload1.c (choose_reload_regs): Likewise.\n+\t(inherit_piecemeal_p): Likewise.\n+\t* rtlanal.c (simplify_subreg_regno): Likewise.\n+\t* postreload.c (reload_cse_simplify_set): Use REG_CAN_CHANGE_MODE_P\n+\tinstead of CANNOT_CHANGE_MODE_CLASS.\n+\t(reload_cse_simplify_operands): Likewise.\n+\t* reload.c (push_reload): Use targetm.can_change_mode_class\n+\tinstead of CANNOT_CHANGE_MODE_CLASS.\n+\t(push_reload): Likewise.  Also use REG_CAN_CHANGE_MODE_P instead of\n+\tREG_CANNOT_CHANGE_MODE_P.\n+\t* config/alpha/alpha.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/alpha/alpha.c (alpha_can_change_mode_class): New function.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t* config/arm/arm.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/arm/arm.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(arm_can_change_mode_class): New function.\n+\t* config/arm/neon.md: Refer to TARGET_CAN_CHANGE_MODE_CLASS rather\n+\tthan CANNOT_CHANGE_MODE_CLASS in comments.\n+\t* config/i386/i386.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/i386/i386-protos.h (ix86_cannot_change_mode_class): Delete.\n+\t* config/i386/i386.c (ix86_cannot_change_mode_class): Replace with...\n+\t(ix86_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t* config/ia64/ia64.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/ia64/ia64.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(ia64_can_change_mode_class): New function.\n+\t* config/m32c/m32c.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/m32c/m32c-protos.h (m32c_cannot_change_mode_class): Delete.\n+\t* config/m32c/m32c.c (m32c_cannot_change_mode_class): Replace with...\n+\t(m32c_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t* config/mips/mips.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/mips/mips-protos.h (mips_cannot_change_mode_class): Delete.\n+\t* config/mips/mips.c (mips_cannot_change_mode_class): Replace with...\n+\t(mips_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t* config/msp430/msp430.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/msp430/msp430.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(msp430_can_change_mode_class): New function.\n+\t* config/nvptx/nvptx.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/nvptx/nvptx.c (nvptx_can_change_mode_class): New function.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t* config/pa/pa32-regs.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/pa/pa64-regs.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/pa/pa-protos.h (pa_cannot_change_mode_class): Delete.\n+\t* config/pa/pa.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(pa_cannot_change_mode_class): Replace with...\n+\t(pa_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t(pa_modes_tieable_p): Refer to TARGET_CAN_CHANGE_MODE_CLASS rather\n+\tthan CANNOT_CHANGE_MODE_CLASS in comments.\n+\t* config/pdp11/pdp11.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/pdp11/pdp11-protos.h (pdp11_cannot_change_mode_class): Delete.\n+\t* config/pdp11/pdp11.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(pdp11_cannot_change_mode_class): Replace with...\n+\t(pdp11_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t* config/powerpcspe/powerpcspe.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/powerpcspe/powerpcspe-protos.h\n+\t(rs6000_cannot_change_mode_class_ptr): Delete.\n+\t* config/powerpcspe/powerpcspe.c\n+\t(rs6000_cannot_change_mode_class_ptr): Delete.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(rs6000_option_override_internal): Assign to\n+\ttargetm.can_change_mode_class instead of\n+\trs6000_cannot_change_mode_class_ptr.\n+\t(rs6000_cannot_change_mode_class): Replace with...\n+\t(rs6000_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t(rs6000_debug_cannot_change_mode_class): Replace with...\n+\t(rs6000_debug_can_change_mode_class): ...this new function.\n+\t* config/riscv/riscv.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/riscv/riscv.c (riscv_can_change_mode_class): New function.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t* config/rs6000/rs6000.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/rs6000/rs6000-protos.h (rs6000_cannot_change_mode_class_ptr):\n+\tDelete.\n+\t* config/rs6000/rs6000.c (rs6000_cannot_change_mode_class_ptr): Delete.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(rs6000_option_override_internal): Assign to\n+\ttargetm.can_change_mode_class instead of\n+\trs6000_cannot_change_mode_class_ptr.\n+\t(rs6000_cannot_change_mode_class): Replace with...\n+\t(rs6000_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t(rs6000_debug_cannot_change_mode_class): Replace with...\n+\t(rs6000_debug_can_change_mode_class): ...this new function.\n+\t* config/s390/s390.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/s390/s390-protos.h (s390_cannot_change_mode_class): Delete.\n+\t* config/s390/s390.c (s390_cannot_change_mode_class): Replace with...\n+\t(s390_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t* config/sh/sh.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/sh/sh-protos.h (sh_cannot_change_mode_class): Delete.\n+\t* config/sh/sh.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(sh_cannot_change_mode_class): Replace with...\n+\t(sh_can_change_mode_class): ...this new function, inverting the\n+\tsense of the return value.\n+\t* config/sparc/sparc.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/sparc/sparc.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(sparc_can_change_mode_class): New function.\n+\t* config/spu/spu.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/spu/spu.c (spu_can_change_mode_class): New function.\n+\t(TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t* config/visium/visium.h (CANNOT_CHANGE_MODE_CLASS): Delete.\n+\t* config/visium/visium.c (TARGET_CAN_CHANGE_MODE_CLASS): Redefine.\n+\t(visium_can_change_mode_class): New function.\n+\t* system.h (CANNOT_CHANGE_MODE_CLASS): Poison.\n+\n 2017-09-15  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82217"}, {"sha": "affc1489ebec1d8b856aa32e7f479a2a0ba47b5d", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -6869,12 +6869,10 @@ simplify_set (rtx x)\n \t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n \t       + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n       && (WORD_REGISTER_OPERATIONS || !paradoxical_subreg_p (src))\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n       && ! (REG_P (dest) && REGNO (dest) < FIRST_PSEUDO_REGISTER\n-\t    && REG_CANNOT_CHANGE_MODE_P (REGNO (dest),\n-\t\t\t\t\t GET_MODE (SUBREG_REG (src)),\n-\t\t\t\t\t GET_MODE (src)))\n-#endif\n+\t    && !REG_CAN_CHANGE_MODE_P (REGNO (dest),\n+\t\t\t\t       GET_MODE (SUBREG_REG (src)),\n+\t\t\t\t       GET_MODE (src)))\n       && (REG_P (dest)\n \t  || (GET_CODE (dest) == SUBREG\n \t      && REG_P (SUBREG_REG (dest)))))"}, {"sha": "e0f458c9109727d6541eae168ba2efe2bf3c3784", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -9936,6 +9936,16 @@ alpha_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n \t  ? alpha_hard_regno_mode_ok (32, mode2)\n \t  : true);\n }\n+\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n+\n+static bool\n+alpha_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t     reg_class_t rclass)\n+{\n+  return (GET_MODE_SIZE (from) == GET_MODE_SIZE (to)\n+\t  || !reg_classes_intersect_p (FLOAT_REGS, rclass));\n+}\n \f\n /* Initialize the GCC target structure.  */\n #if TARGET_ABI_OPEN_VMS\n@@ -10140,6 +10150,9 @@ alpha_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P alpha_modes_tieable_p\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS alpha_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "6177020605aaffcb1b9a89e115eecc93411d833b", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -479,12 +479,6 @@ enum reg_class {\n \n #define PREFERRED_RELOAD_CLASS  alpha_preferred_reload_class\n \n-/* Return the class of registers that cannot change mode from FROM to TO.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\t\\\n-   ? reg_classes_intersect_p (FLOAT_REGS, CLASS) : 0)\n-\n /* Provide the cost of a branch.  Exact meaning under development.  */\n #define BRANCH_COST(speed_p, predictable_p) 5\n \f"}, {"sha": "bc802adc3e33cff4a4ee6cf918d4ab396e16468a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -793,6 +793,9 @@ static const struct attribute_spec arm_attribute_table[] =\n \n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P arm_modes_tieable_p\n+\n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS arm_can_change_mode_class\n \f\n /* Obstack for minipool constant handling.  */\n static struct obstack minipool_obstack;\n@@ -31243,6 +31246,33 @@ arm_coproc_ldc_stc_legitimate_address (rtx op)\n   return false;\n }\n \n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.\n+\n+   In VFPv1, VFP registers could only be accessed in the mode they were\n+   set, so subregs would be invalid there.  However, we don't support\n+   VFPv1 at the moment, and the restriction was lifted in VFPv2.\n+\n+   In big-endian mode, modes greater than word size (i.e. DFmode) are stored in\n+   VFP registers in little-endian order.  We can't describe that accurately to\n+   GCC, so avoid taking subregs of such values.\n+\n+   The only exception is going from a 128-bit to a 64-bit type.  In that\n+   case the data layout happens to be consistent for big-endian, so we\n+   explicitly allow that case.  */\n+\n+static bool\n+arm_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t   reg_class_t rclass)\n+{\n+  if (TARGET_BIG_END\n+      && !(GET_MODE_SIZE (from) == 16 && GET_MODE_SIZE (to) == 8)\n+      && (GET_MODE_SIZE (from) > UNITS_PER_WORD\n+\t  || GET_MODE_SIZE (to) > UNITS_PER_WORD)\n+      && reg_classes_intersect_p (VFP_REGS, rclass))\n+    return false;\n+  return true;\n+}\n+\n #if CHECKING_P\n namespace selftest {\n "}, {"sha": "1dc136110d53214fbdabf54eb5656aa9737f0cae", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1152,23 +1152,6 @@ enum reg_class\n    or could index an array.  */\n #define REGNO_REG_CLASS(REGNO)  arm_regno_class (REGNO)\n \n-/* In VFPv1, VFP registers could only be accessed in the mode they\n-   were set, so subregs would be invalid there.  However, we don't\n-   support VFPv1 at the moment, and the restriction was lifted in\n-   VFPv2.\n-   In big-endian mode, modes greater than word size (i.e. DFmode) are stored in\n-   VFP registers in little-endian order.  We can't describe that accurately to\n-   GCC, so avoid taking subregs of such values.\n-   The only exception is going from a 128-bit to a 64-bit type.  In that case\n-   the data layout happens to be consistent for big-endian, so we explicitly allow\n-   that case.  */\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\\n-  (TARGET_BIG_END\t\t\t\t\t\t\\\n-   && !(GET_MODE_SIZE (FROM) == 16 && GET_MODE_SIZE (TO) == 8)\t\\\n-   && (GET_MODE_SIZE (FROM) > UNITS_PER_WORD\t\t\t\\\n-       || GET_MODE_SIZE (TO) > UNITS_PER_WORD)\t\t\t\\\n-   && reg_classes_intersect_p (VFP_REGS, (CLASS)))\n-\n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  (TARGET_THUMB1 ? LO_REGS : GENERAL_REGS)\n #define BASE_REG_CLASS   (TARGET_THUMB1 ? LO_REGS : CORE_REGS)"}, {"sha": "12ba2d98a0ae0517465dd61cefe8e59011508a88", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -142,7 +142,7 @@\n \t(match_operand:V4HF 1 \"s_register_operand\"))]\n   \"TARGET_NEON && TARGET_FP16\"\n {\n-  /* We need to use force_reg to avoid CANNOT_CHANGE_MODE_CLASS\n+  /* We need to use force_reg to avoid TARGET_CAN_CHANGE_MODE_CLASS\n      causing an ICE on big-endian because it cannot extract subregs in\n      this case.  */\n   if (can_create_pseudo_p ())\n@@ -157,7 +157,7 @@\n \t(match_operand:V8HF 1 \"\"))]\n   \"TARGET_NEON && TARGET_FP16\"\n { \n-  /* We need to use force_reg to avoid CANNOT_CHANGE_MODE_CLASS\n+  /* We need to use force_reg to avoid TARGET_CAN_CHANGE_MODE_CLASS\n      causing an ICE on big-endian because it cannot extract subregs in\n      this case.  */\n   if (can_create_pseudo_p ())"}, {"sha": "4df6274add2e55fb6c5580f8dd4de4fa89caaef3", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -167,8 +167,6 @@ extern int ix86_reg_parm_stack_space (const_tree);\n \n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n \t\t\t\t  rtx, rtx, rtx);\n-extern bool ix86_cannot_change_mode_class (machine_mode,\n-\t\t\t\t\t   machine_mode, enum reg_class);\n \n extern bool ix86_libc_has_function (enum function_class fn_class);\n "}, {"sha": "fa79762a9229999d1b9b3dcc418cfa9923405ae2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -41204,20 +41204,19 @@ ix86_class_max_nregs (reg_class_t rclass, machine_mode mode)\n     }\n }\n \n-/* Return true if the registers in CLASS cannot represent the change from\n-   modes FROM to TO.  */\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n \n-bool\n-ix86_cannot_change_mode_class (machine_mode from, machine_mode to,\n-\t\t\t       enum reg_class regclass)\n+static bool\n+ix86_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t    reg_class_t regclass)\n {\n   if (from == to)\n-    return false;\n+    return true;\n \n   /* x87 registers can't do subreg at all, as all values are reformatted\n      to extended precision.  */\n   if (MAYBE_FLOAT_CLASS_P (regclass))\n-    return true;\n+    return false;\n \n   if (MAYBE_SSE_CLASS_P (regclass) || MAYBE_MMX_CLASS_P (regclass))\n     {\n@@ -41226,10 +41225,10 @@ ix86_cannot_change_mode_class (machine_mode from, machine_mode to,\n \t drop the subreg from (subreg:SI (reg:HI 100) 0).  This affects\n \t the vec_dupv4hi pattern.  */\n       if (GET_MODE_SIZE (from) < 4)\n-\treturn true;\n+\treturn false;\n     }\n \n-  return false;\n+  return true;\n }\n \n /* Return the cost of moving data of mode M between a\n@@ -53434,6 +53433,9 @@ ix86_run_selftests (void)\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   ix86_hard_regno_call_part_clobbered\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS ix86_can_change_mode_class\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::ix86_run_selftests"}, {"sha": "2f5ed83c89e637c25559b3c6b39377c3b108f709", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1518,11 +1518,6 @@ enum reg_class\n \n #define INDEX_REG_CLASS INDEX_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n-\n-/* Return a class of registers that cannot change FROM mode to TO mode.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  ix86_cannot_change_mode_class (FROM, TO, CLASS)\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "b4d63592ea0e0f3738b92c74a8d56b5052d117ce", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -339,6 +339,8 @@ static bool ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n static unsigned int ia64_hard_regno_nregs (unsigned int, machine_mode);\n static bool ia64_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool ia64_modes_tieable_p (machine_mode, machine_mode);\n+static bool ia64_can_change_mode_class (machine_mode, machine_mode,\n+\t\t\t\t\treg_class_t);\n \n #define MAX_VECT_LEN\t8\n \n@@ -668,6 +670,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P ia64_modes_tieable_p\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS ia64_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Returns TRUE iff the target attribute indicated by ATTR_ID takes a plain\n@@ -11908,4 +11913,21 @@ ia64_expand_vec_perm_even_odd (rtx target, rtx op0, rtx op1, int odd)\n   gcc_assert (ok);\n }\n \n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.\n+\n+   In BR regs, we can't change the DImode at all.\n+   In FP regs, we can't change FP values to integer values and vice versa,\n+   but we can change e.g. DImode to SImode, and V2SFmode into DImode.  */\n+\n+static bool\n+ia64_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t    reg_class_t rclass)\n+{\n+  if (reg_classes_intersect_p (rclass, BR_REGS))\n+    return from == to;\n+  if (SCALAR_FLOAT_MODE_P (from) != SCALAR_FLOAT_MODE_P (to))\n+    return !reg_classes_intersect_p (rclass, FR_REGS);\n+  return true;\n+}\n+\n #include \"gt-ia64.h\""}, {"sha": "b08824f2ccd6fc7e2ca98ad102f5f900d834bcfb", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -777,17 +777,6 @@ enum reg_class\n    : (((CLASS) == FR_REGS || (CLASS) == FP_REGS) && (MODE) == RFmode) ? 1 \\\n    : (((CLASS) == FR_REGS || (CLASS) == FP_REGS) && (MODE) == XCmode) ? 2 \\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* In BR regs, we can't change the DImode at all.\n-   In FP regs, we can't change FP values to integer values and vice versa,\n-   but we can change e.g. DImode to SImode, and V2SFmode into DImode.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \t\t\\\n-  (reg_classes_intersect_p (CLASS, BR_REGS)\t\t\t\\\n-   ? (FROM) != (TO)\t\t\t\t\t\t\\\n-   : (SCALAR_FLOAT_MODE_P (FROM) != SCALAR_FLOAT_MODE_P (TO)\t\\\n-      ? reg_classes_intersect_p (CLASS, FR_REGS)\t\t\\\n-      : 0))\n \f\n /* Basic Stack Layout */\n "}, {"sha": "8647a208420e48e8b816f22b5fc6fa50dbd7634b", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -38,7 +38,6 @@ int  m32c_trampoline_size (void);\n \n #ifdef RTX_CODE\n \n-int  m32c_cannot_change_mode_class (machine_mode, machine_mode, int);\n rtx  m32c_eh_return_stackadj_rtx (void);\n void m32c_emit_eh_epilogue (rtx);\n int  m32c_expand_cmpstr (rtx *);"}, {"sha": "5987513e97d144d196acd114971ce02c52522e59", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -799,17 +799,17 @@ m32c_class_max_nregs (reg_class_t regclass, machine_mode mode)\n   return max;\n }\n \n-/* Implements CANNOT_CHANGE_MODE_CLASS.  Only r0 and r1 can change to\n+/* Implements TARGET_CAN_CHANGE_MODE_CLASS.  Only r0 and r1 can change to\n    QI (r0l, r1l) because the chip doesn't support QI ops on other\n    registers (well, it does on a0/a1 but if we let gcc do that, reload\n    suffers).  Otherwise, we allow changes to larger modes.  */\n-int\n-m32c_cannot_change_mode_class (machine_mode from,\n-\t\t\t       machine_mode to, int rclass)\n+static bool\n+m32c_can_change_mode_class (machine_mode from,\n+\t\t\t    machine_mode to, reg_class_t rclass)\n {\n   int rn;\n #if DEBUG0\n-  fprintf (stderr, \"cannot change from %s to %s in %s\\n\",\n+  fprintf (stderr, \"can change from %s to %s in %s\\n\",\n \t   mode_name[from], mode_name[to], class_names[rclass]);\n #endif\n \n@@ -818,18 +818,18 @@ m32c_cannot_change_mode_class (machine_mode from,\n   for (rn = 0; rn < FIRST_PSEUDO_REGISTER; rn++)\n     if (class_contents[rclass][0] & (1 << rn))\n       if (! m32c_hard_regno_mode_ok (rn, to))\n-\treturn 1;\n+\treturn false;\n \n   if (to == QImode)\n-    return (class_contents[rclass][0] & 0x1ffa);\n+    return (class_contents[rclass][0] & 0x1ffa) == 0;\n \n   if (class_contents[rclass][0] & 0x0005\t/* r0, r1 */\n       && GET_MODE_SIZE (from) > 1)\n-    return 0;\n+    return true;\n   if (GET_MODE_SIZE (from) > 2)\t/* all other regs */\n-    return 0;\n+    return true;\n \n-  return 1;\n+  return false;\n }\n \n /* Helpers for the rest of the file.  */\n@@ -4496,6 +4496,9 @@ m32c_output_compare (rtx_insn *insn, rtx *operands)\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P m32c_modes_tieable_p\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS m32c_can_change_mode_class\n+\n /* The Global `targetm' Variable. */\n \n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "c4c0da088236ae554c64823a018c502d25cec7b7", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -411,8 +411,6 @@ enum reg_class\n \n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n-#define CANNOT_CHANGE_MODE_CLASS(F,T,C) m32c_cannot_change_mode_class(F,T,C)\n-\n /* STACK AND CALLING */\n \n /* Frame Layout */"}, {"sha": "1c4167a836a8886dd4f4538d3004747fd0c3150d", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -294,8 +294,6 @@ extern bool mips_const_vector_bitimm_set_p (rtx, machine_mode);\n extern bool mips_const_vector_bitimm_clr_p (rtx, machine_mode);\n extern rtx mips_msa_vec_parallel_const_half (machine_mode, bool);\n extern rtx mips_gen_const_int_vector (machine_mode, HOST_WIDE_INT);\n-extern bool mips_cannot_change_mode_class (machine_mode,\n-\t\t\t\t\t   machine_mode, enum reg_class);\n extern bool mips_dangerous_for_la25_p (rtx);\n extern enum reg_class mips_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   machine_mode,"}, {"sha": "2af93d73142ad7dc43d4cfe2204c52e8ea8115e7", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -12945,22 +12945,21 @@ mips_class_max_nregs (enum reg_class rclass, machine_mode mode)\n   return (GET_MODE_SIZE (mode) + size - 1) / size;\n }\n \n-/* Implement CANNOT_CHANGE_MODE_CLASS.  */\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n \n-bool\n-mips_cannot_change_mode_class (machine_mode from,\n-\t\t\t       machine_mode to,\n-\t\t\t       enum reg_class rclass)\n+static bool\n+mips_can_change_mode_class (machine_mode from,\n+\t\t\t    machine_mode to, reg_class_t rclass)\n {\n   /* Allow conversions between different Loongson integer vectors,\n      and between those vectors and DImode.  */\n   if (GET_MODE_SIZE (from) == 8 && GET_MODE_SIZE (to) == 8\n       && INTEGRAL_MODE_P (from) && INTEGRAL_MODE_P (to))\n-    return false;\n+    return true;\n \n   /* Allow conversions between different MSA vector modes.  */\n   if (MSA_SUPPORTED_MODE_P (from) && MSA_SUPPORTED_MODE_P (to))\n-    return false;\n+    return true;\n \n   /* Otherwise, there are several problems with changing the modes of\n      values in floating-point registers:\n@@ -12985,7 +12984,7 @@ mips_cannot_change_mode_class (machine_mode from,\n \n      We therefore disallow all mode changes involving FPRs.  */\n \n-  return reg_classes_intersect_p (FP_REGS, rclass);\n+  return !reg_classes_intersect_p (FP_REGS, rclass);\n }\n \n /* Implement target hook small_register_classes_for_mode_p.  */\n@@ -22621,6 +22620,9 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_SECONDARY_MEMORY_NEEDED\n #define TARGET_SECONDARY_MEMORY_NEEDED mips_secondary_memory_needed\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS mips_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-mips.h\""}, {"sha": "991bd8d5049d005928265abe08d396b8778cbe03", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -2302,9 +2302,6 @@ enum reg_class\n    needed to represent mode MODE in a register of class CLASS.  */\n \n #define CLASS_MAX_NREGS(CLASS, MODE) mips_class_max_nregs (CLASS, MODE)\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  mips_cannot_change_mode_class (FROM, TO, CLASS)\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "80ea1190fbaac9713e2f4deef9ccab21e43dbc8b", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -3812,6 +3812,22 @@ msp430x_logical_shift_right (rtx amount)\n      right shift instruction to perform the rest of the shift.  */\n   return \"rrum.w\\t#1, %0 { rpt\\t%Z2 { rrax.w\\t%0\"; /* Six bytes.  */\n }\n+\n+/* Stop GCC from thinking that it can eliminate (SUBREG:PSI (SI)).  */\n+\n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS msp430_can_change_mode_class\n+\n+static bool\n+msp430_can_change_mode_class (machine_mode from, machine_mode to, reg_class_t)\n+{\n+  if ((to == PSImode && from == SImode)\n+      || (to == SImode && from == PSImode)\n+      || (to == DImode && from == PSImode)\n+      || (to == PSImode && from == DImode))\n+    return false;\n+  return true;\n+}\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "8494bf29acd5a9a16c8835cad38b806ed387e0f7", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -407,14 +407,6 @@ typedef struct\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO,NREGS,MODE) \\\n   ((TARGET_LARGE && ((NREGS) <= 2)) ? PSImode : choose_hard_reg_mode ((REGNO), (NREGS), false))\n \n-/* Also stop GCC from thinking that it can eliminate (SUBREG:PSI (SI)).  */\n-#define CANNOT_CHANGE_MODE_CLASS(FROM,TO,CLASS) \\\n-  (   ((TO) == PSImode && (FROM) == SImode)\t\\\n-   || ((TO) == SImode  && (FROM) == PSImode)    \\\n-   || ((TO) == DImode  && (FROM) == PSImode)    \\\n-   || ((TO) == PSImode && (FROM) == DImode)     \\\n-      )\n-\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n #undef  ASM_DECLARE_FUNCTION_NAME"}, {"sha": "6cf9a6627631c1facc49fd785cb6e7de678e5d63", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -5529,6 +5529,14 @@ nvptx_hard_regno_nregs (unsigned int, machine_mode)\n   return 1;\n }\n \n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n+\n+static bool\n+nvptx_can_change_mode_class (machine_mode, machine_mode, reg_class_t)\n+{\n+  return false;\n+}\n+\n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE nvptx_option_override\n \n@@ -5659,6 +5667,9 @@ nvptx_hard_regno_nregs (unsigned int, machine_mode)\n #undef TARGET_HARD_REGNO_NREGS\n #define TARGET_HARD_REGNO_NREGS nvptx_hard_regno_nregs\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS nvptx_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-nvptx.h\""}, {"sha": "ab00e472ceb29508d34f4a3aebedbe8b524e0795", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -95,9 +95,6 @@\n #define FIXED_REGISTERS\t    { 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n #define CALL_USED_REGISTERS { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n \n-#define CANNOT_CHANGE_MODE_CLASS(M1, M2, CLS)\t\\\n-  ((void)(M1), (void)(M2), (void)(CLS), true)\n-\n /* Register Classes.  */\n enum reg_class             {  NO_REGS,    ALL_REGS,\tLIM_REG_CLASSES };\n #define REG_CLASS_NAMES    { \"NO_REGS\",  \"ALL_REGS\" }"}, {"sha": "cbf25af19c89ec14cb99a8f8e8bfe46c2051ae5f", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -106,8 +106,6 @@ extern void pa_asm_output_aligned_local (FILE *, const char *,\n \t\t\t\t\t unsigned HOST_WIDE_INT,\n \t\t\t\t\t unsigned int);\n extern void pa_hpux_asm_output_external (FILE *, tree, const char *);\n-extern bool pa_cannot_change_mode_class (machine_mode, machine_mode,\n-\t\t\t\t\t enum reg_class);\n extern HOST_WIDE_INT pa_initial_elimination_offset (int, int);\n \n extern const int pa_magic_milli[];"}, {"sha": "651ae59378d4ed34255ab086d2f2a9addfc02b7d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -204,6 +204,7 @@ static bool pa_callee_copies (cumulative_args_t, machine_mode,\n static unsigned int pa_hard_regno_nregs (unsigned int, machine_mode);\n static bool pa_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool pa_modes_tieable_p (machine_mode, machine_mode);\n+static bool pa_can_change_mode_class (machine_mode, machine_mode, reg_class_t);\n \n /* The following extra sections are only used for SOM.  */\n static GTY(()) section *som_readonly_data_section;\n@@ -421,6 +422,9 @@ static size_t n_deferred_plabels = 0;\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P pa_modes_tieable_p\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS pa_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Parse the -mfixed-range= option string.  */\n@@ -10001,44 +10005,43 @@ pa_hpux_file_end (void)\n }\n #endif\n \n-/* Return true if a change from mode FROM to mode TO for a register\n-   in register class RCLASS is invalid.  */\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n \n-bool\n-pa_cannot_change_mode_class (machine_mode from, machine_mode to,\n-\t\t\t     enum reg_class rclass)\n+static bool\n+pa_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t  reg_class_t rclass)\n {\n   if (from == to)\n-    return false;\n+    return true;\n \n   if (GET_MODE_SIZE (from) == GET_MODE_SIZE (to))\n-    return false;\n+    return true;\n \n   /* Reject changes to/from modes with zero size.  */\n   if (!GET_MODE_SIZE (from) || !GET_MODE_SIZE (to))\n-    return true;\n+    return false;\n \n   /* Reject changes to/from complex and vector modes.  */\n   if (COMPLEX_MODE_P (from) || VECTOR_MODE_P (from)\n       || COMPLEX_MODE_P (to) || VECTOR_MODE_P (to))\n-    return true;\n+    return false;\n       \n   /* There is no way to load QImode or HImode values directly from memory\n      to a FP register.  SImode loads to the FP registers are not zero\n      extended.  On the 64-bit target, this conflicts with the definition\n      of LOAD_EXTEND_OP.  Thus, we can't allow changing between modes with\n      different sizes in the floating-point registers.  */\n   if (MAYBE_FP_REG_CLASS_P (rclass))\n-    return true;\n+    return false;\n \n   /* TARGET_HARD_REGNO_MODE_OK places modes with sizes larger than a word\n      in specific sets of registers.  Thus, we cannot allow changing\n      to a larger mode when it's larger than a word.  */\n   if (GET_MODE_SIZE (to) > UNITS_PER_WORD\n       && GET_MODE_SIZE (to) > GET_MODE_SIZE (from))\n-    return true;\n+    return false;\n \n-  return false;\n+  return true;\n }\n \n /* Implement TARGET_MODES_TIEABLE_P.\n@@ -10047,7 +10050,7 @@ pa_cannot_change_mode_class (machine_mode from, machine_mode to,\n    are not ok in the floating-point registers.  However, this prevents\n    tieing these modes to SImode and DImode in the general registers.\n    So, this isn't a good idea.  We rely on TARGET_HARD_REGNO_MODE_OK and\n-   CANNOT_CHANGE_MODE_CLASS to prevent these modes from being used\n+   TARGET_CAN_CHANGE_MODE_CLASS to prevent these modes from being used\n    in the floating-point registers.  */\n \n static bool"}, {"sha": "d479b1aee7ebb3ca90d9d66e0608735c6e428415", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -294,11 +294,6 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n   {0x00000000, 0x00000000, 0x01000000},\t/* SHIFT_REGS */\t\t\\\n   {0xfffffffe, 0xffffffff, 0x03ffffff}}\t/* ALL_REGS */\n \n-/* Defines invalid mode changes.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  pa_cannot_change_mode_class (FROM, TO, CLASS)\n-\n /* Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */"}, {"sha": "d9c8dd419e7cc7833f2f9af41229e3bf38712f5b", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -230,11 +230,6 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n   {0x00000000, 0x10000000},\t/* SHIFT_REGS */\t\t\\\n   {0xfffffffe, 0x3fffffff}}\t/* ALL_REGS */\n \n-/* Defines invalid mode changes.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  pa_cannot_change_mode_class (FROM, TO, CLASS)\n-\n /* Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */"}, {"sha": "f6c7d1a7f1b651d864786a6b2d8f66093b3d4e47", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -29,8 +29,6 @@ extern const char *output_move_multiple (rtx *);\n extern const char *output_block_move (rtx *);\n extern const char *output_jump (enum rtx_code, int, int);\n extern void print_operand_address (FILE *, rtx);\n-extern bool pdp11_cannot_change_mode_class (machine_mode,\n-                                            machine_mode, enum reg_class);\n typedef enum { no_action, dec_before, inc_after } pdp11_action;\n typedef enum { little, either, big } pdp11_partorder;\n extern bool pdp11_expand_operands (rtx *, rtx [][2], int, "}, {"sha": "4fdb077479d5cab55656c28c90c62c1b7d1167ae", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -246,6 +246,9 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n \n #undef  TARGET_SECONDARY_MEMORY_NEEDED\n #define TARGET_SECONDARY_MEMORY_NEEDED pdp11_secondary_memory_needed\n+\n+#undef  TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS pdp11_can_change_mode_class\n \f\n /* A helper function to determine if REGNO should be saved in the\n    current function's stack frame.  */\n@@ -1372,20 +1375,20 @@ legitimate_const_double_p (rtx address)\n   return 0;\n }\n \n-/* Implement CANNOT_CHANGE_MODE_CLASS.  */\n-bool\n-pdp11_cannot_change_mode_class (machine_mode from,\n-\t\t\t\tmachine_mode to,\n-\t\t\t\tenum reg_class rclass)\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n+static bool\n+pdp11_can_change_mode_class (machine_mode from,\n+\t\t\t     machine_mode to,\n+\t\t\t     reg_class_t rclass)\n {\n   /* Also, FPU registers contain a whole float value and the parts of\n      it are not separately accessible.\n \n      So we disallow all mode changes involving FPRs.  */\n   if (FLOAT_MODE_P (from) != FLOAT_MODE_P (to))\n-    return true;\n+    return false;\n   \n-  return reg_classes_intersect_p (FPU_REGS, rclass);\n+  return !reg_classes_intersect_p (FPU_REGS, rclass);\n }\n \n /* TARGET_PREFERRED_RELOAD_CLASS"}, {"sha": "2a59f659156fe71f417326d810ad7c7bb8dfab97", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -243,9 +243,6 @@ enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REG\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD):\t\\\n   1\t\t\t\t\t\t\t\t\t\\\n )\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  pdp11_cannot_change_mode_class (FROM, TO, CLASS)\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "78baeecad38f8c87e985f93bed70d11bc78c3111", "filename": "gcc/config/powerpcspe/powerpcspe-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -109,9 +109,6 @@ extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n \t\t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t\t    rtx);\n-extern bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n-\t\t\t\t\t\t    machine_mode,\n-\t\t\t\t\t\t    enum reg_class);\n extern void rs6000_secondary_reload_inner (rtx, rtx, rtx, bool);\n extern void rs6000_secondary_reload_gpr (rtx, rtx, rtx, bool);\n extern int paired_emit_vector_cond_expr (rtx, rtx, rtx,"}, {"sha": "11664eed4e0e2b72cfb5b6ca7422a343d24ffbd6", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1387,12 +1387,9 @@ static enum reg_class rs6000_debug_preferred_reload_class (rtx,\n static bool rs6000_debug_secondary_memory_needed (machine_mode,\n \t\t\t\t\t\t  reg_class_t,\n \t\t\t\t\t\t  reg_class_t);\n-static bool rs6000_cannot_change_mode_class (machine_mode,\n-\t\t\t\t\t     machine_mode,\n-\t\t\t\t\t     enum reg_class);\n-static bool rs6000_debug_cannot_change_mode_class (machine_mode,\n-\t\t\t\t\t\t   machine_mode,\n-\t\t\t\t\t\t   enum reg_class);\n+static bool rs6000_debug_can_change_mode_class (machine_mode,\n+\t\t\t\t\t\tmachine_mode,\n+\t\t\t\t\t\treg_class_t);\n static bool rs6000_save_toc_in_prologue_p (void);\n static rtx rs6000_internal_arg_pointer (void);\n \n@@ -1410,11 +1407,6 @@ enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx, enum reg_class)\n   = rs6000_preferred_reload_class;\n \n-bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n-\t\t\t\t\t     machine_mode,\n-\t\t\t\t\t     enum reg_class)\n-  = rs6000_cannot_change_mode_class;\n-\n const int INSN_NOT_AVAILABLE = -1;\n \n static void rs6000_print_isa_options (FILE *, int, const char *,\n@@ -1989,6 +1981,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_SLOW_UNALIGNED_ACCESS\n #define TARGET_SLOW_UNALIGNED_ACCESS rs6000_slow_unaligned_access\n+\n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS rs6000_can_change_mode_class\n \f\n \n /* Processor table.  */\n@@ -5096,8 +5091,8 @@ rs6000_option_override_internal (bool global_init_p)\n \t    = rs6000_debug_secondary_reload_class;\n \t  targetm.secondary_memory_needed\n \t    = rs6000_debug_secondary_memory_needed;\n-\t  rs6000_cannot_change_mode_class_ptr\n-\t    = rs6000_debug_cannot_change_mode_class;\n+\t  targetm.can_change_mode_class\n+\t    = rs6000_debug_can_change_mode_class;\n \t  rs6000_preferred_reload_class_ptr\n \t    = rs6000_debug_preferred_reload_class;\n \t  rs6000_legitimize_reload_address_ptr\n@@ -23297,12 +23292,12 @@ rs6000_debug_secondary_reload_class (enum reg_class rclass,\n   return ret;\n }\n \n-/* Return nonzero if for CLASS a mode change from FROM to TO is invalid.  */\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n \n static bool\n-rs6000_cannot_change_mode_class (machine_mode from,\n-\t\t\t\t machine_mode to,\n-\t\t\t\t enum reg_class rclass)\n+rs6000_can_change_mode_class (machine_mode from,\n+\t\t\t      machine_mode to,\n+\t\t\t      reg_class_t rclass)\n {\n   unsigned from_size = GET_MODE_SIZE (from);\n   unsigned to_size = GET_MODE_SIZE (to);\n@@ -23326,31 +23321,31 @@ rs6000_cannot_change_mode_class (machine_mode from,\n \t     values.  */\n \n \t  if (to_float128_vector_p && from_float128_vector_p)\n-\t    return false;\n+\t    return true;\n \n \t  else if (to_float128_vector_p || from_float128_vector_p)\n-\t    return true;\n+\t    return false;\n \n \t  /* TDmode in floating-mode registers must always go into a register\n \t     pair with the most significant word in the even-numbered register\n \t     to match ISA requirements.  In little-endian mode, this does not\n \t     match subreg numbering, so we cannot allow subregs.  */\n \t  if (!BYTES_BIG_ENDIAN && (to == TDmode || from == TDmode))\n-\t    return true;\n+\t    return false;\n \n \t  if (from_size < 8 || to_size < 8)\n-\t    return true;\n+\t    return false;\n \n \t  if (from_size == 8 && (8 * to_nregs) != to_size)\n-\t    return true;\n+\t    return false;\n \n \t  if (to_size == 8 && (8 * from_nregs) != from_size)\n-\t    return true;\n+\t    return false;\n \n-\t  return false;\n+\t  return true;\n \t}\n       else\n-\treturn false;\n+\treturn true;\n     }\n \n   if (TARGET_E500_DOUBLE\n@@ -23361,7 +23356,7 @@ rs6000_cannot_change_mode_class (machine_mode from,\n \t  || (((to) == DDmode) + ((from) == DDmode)) == 1\n \t  || (((to) == TDmode) + ((from) == TDmode)) == 1\n \t  || (((to) == DImode) + ((from) == DImode)) == 1))\n-    return true;\n+    return false;\n \n   /* Since the VSX register set includes traditional floating point registers\n      and altivec registers, just check for the size being different instead of\n@@ -23374,32 +23369,32 @@ rs6000_cannot_change_mode_class (machine_mode from,\n       unsigned num_regs = (from_size + 15) / 16;\n       if (hard_regno_nregs (FIRST_FPR_REGNO, to) > num_regs\n \t  || hard_regno_nregs (FIRST_FPR_REGNO, from) > num_regs)\n-\treturn true;\n+\treturn false;\n \n-      return (from_size != 8 && from_size != 16);\n+      return (from_size == 8 || from_size == 16);\n     }\n \n   if (TARGET_ALTIVEC && rclass == ALTIVEC_REGS\n       && (ALTIVEC_VECTOR_MODE (from) + ALTIVEC_VECTOR_MODE (to)) == 1)\n-    return true;\n+    return false;\n \n   if (TARGET_SPE && (SPE_VECTOR_MODE (from) + SPE_VECTOR_MODE (to)) == 1\n       && reg_classes_intersect_p (GENERAL_REGS, rclass))\n-    return true;\n+    return false;\n \n-  return false;\n+  return true;\n }\n \n-/* Debug version of rs6000_cannot_change_mode_class.  */\n+/* Debug version of rs6000_can_change_mode_class.  */\n static bool\n-rs6000_debug_cannot_change_mode_class (machine_mode from,\n-\t\t\t\t       machine_mode to,\n-\t\t\t\t       enum reg_class rclass)\n+rs6000_debug_can_change_mode_class (machine_mode from,\n+\t\t\t\t    machine_mode to,\n+\t\t\t\t    reg_class_t rclass)\n {\n-  bool ret = rs6000_cannot_change_mode_class (from, to, rclass);\n+  bool ret = rs6000_can_change_mode_class (from, to, rclass);\n \n   fprintf (stderr,\n-\t   \"rs6000_cannot_change_mode_class, return %s, from = %s, \"\n+\t   \"rs6000_can_change_mode_class, return %s, from = %s, \"\n \t   \"to = %s, rclass = %s\\n\",\n \t   ret ? \"true\" : \"false\",\n \t   GET_MODE_NAME (from), GET_MODE_NAME (to),"}, {"sha": "4a316615d838c12bf94cf89f9a36a94b1a9ad847", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1611,11 +1611,6 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n    registers can hold 128 bits.  */\n #define CLASS_MAX_NREGS(CLASS, MODE) rs6000_class_max_nregs[(MODE)][(CLASS)]\n \n-/* Return nonzero if for CLASS a mode change from FROM to TO is invalid.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\t\\\n-  rs6000_cannot_change_mode_class_ptr (FROM, TO, CLASS)\n-\n /* Stack layout; function entry, exit and calling.  */\n \n /* Define this if pushing a word on the stack"}, {"sha": "42ddac997a600cec9eca79cc18d89c48b4c958f8", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -3987,6 +3987,14 @@ riscv_slow_unaligned_access (machine_mode, unsigned int)\n   return riscv_slow_unaligned_access_p;\n }\n \n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n+\n+static bool\n+riscv_can_change_mode_class (machine_mode, machine_mode, reg_class_t rclass)\n+{\n+  return !reg_classes_intersect_p (FP_REGS, rclass);\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n@@ -4131,6 +4139,9 @@ riscv_slow_unaligned_access (machine_mode, unsigned int)\n #undef TARGET_SECONDARY_MEMORY_NEEDED\n #define TARGET_SECONDARY_MEMORY_NEEDED riscv_secondary_memory_needed\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS riscv_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-riscv.h\""}, {"sha": "53141bcfbe6d56dd8f46eda74c8efd366eeed278", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -456,9 +456,6 @@ enum reg_class\n   (((VALUE) | ((1UL<<31) - IMM_REACH)) == ((1UL<<31) - IMM_REACH)\t\\\n    || ((VALUE) | ((1UL<<31) - IMM_REACH)) + IMM_REACH == 0)\n \n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  reg_classes_intersect_p (FP_REGS, CLASS)\n-\n /* Stack layout; function entry, exit and calling.  */\n \n #define STACK_GROWS_DOWNWARD 1"}, {"sha": "3f86aba947e7d34579b2bcc398fc61416141e142", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -110,9 +110,6 @@ extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n \t\t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t\t    rtx);\n-extern bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n-\t\t\t\t\t\t    machine_mode,\n-\t\t\t\t\t\t    enum reg_class);\n extern void rs6000_secondary_reload_inner (rtx, rtx, rtx, bool);\n extern void rs6000_secondary_reload_gpr (rtx, rtx, rtx, bool);\n extern int paired_emit_vector_cond_expr (rtx, rtx, rtx,"}, {"sha": "9058f1fb47ab1fa873ee48f65fe3eeeff65edf6b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1392,12 +1392,9 @@ static enum reg_class rs6000_debug_preferred_reload_class (rtx,\n static bool rs6000_debug_secondary_memory_needed (machine_mode,\n \t\t\t\t\t\t  reg_class_t,\n \t\t\t\t\t\t  reg_class_t);\n-static bool rs6000_cannot_change_mode_class (machine_mode,\n-\t\t\t\t\t     machine_mode,\n-\t\t\t\t\t     enum reg_class);\n-static bool rs6000_debug_cannot_change_mode_class (machine_mode,\n-\t\t\t\t\t\t   machine_mode,\n-\t\t\t\t\t\t   enum reg_class);\n+static bool rs6000_debug_can_change_mode_class (machine_mode,\n+\t\t\t\t\t\tmachine_mode,\n+\t\t\t\t\t\treg_class_t);\n static bool rs6000_save_toc_in_prologue_p (void);\n static rtx rs6000_internal_arg_pointer (void);\n \n@@ -1415,11 +1412,6 @@ enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx, enum reg_class)\n   = rs6000_preferred_reload_class;\n \n-bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n-\t\t\t\t\t     machine_mode,\n-\t\t\t\t\t     enum reg_class)\n-  = rs6000_cannot_change_mode_class;\n-\n const int INSN_NOT_AVAILABLE = -1;\n \n static void rs6000_print_isa_options (FILE *, int, const char *,\n@@ -1979,6 +1971,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_SLOW_UNALIGNED_ACCESS\n #define TARGET_SLOW_UNALIGNED_ACCESS rs6000_slow_unaligned_access\n+\n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS rs6000_can_change_mode_class\n \f\n \n /* Processor table.  */\n@@ -4715,8 +4710,8 @@ rs6000_option_override_internal (bool global_init_p)\n \t    = rs6000_debug_secondary_reload_class;\n \t  targetm.secondary_memory_needed\n \t    = rs6000_debug_secondary_memory_needed;\n-\t  rs6000_cannot_change_mode_class_ptr\n-\t    = rs6000_debug_cannot_change_mode_class;\n+\t  targetm.can_change_mode_class\n+\t    = rs6000_debug_can_change_mode_class;\n \t  rs6000_preferred_reload_class_ptr\n \t    = rs6000_debug_preferred_reload_class;\n \t  rs6000_legitimize_reload_address_ptr\n@@ -20643,12 +20638,12 @@ rs6000_debug_secondary_reload_class (enum reg_class rclass,\n   return ret;\n }\n \n-/* Return nonzero if for CLASS a mode change from FROM to TO is invalid.  */\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n \n static bool\n-rs6000_cannot_change_mode_class (machine_mode from,\n-\t\t\t\t machine_mode to,\n-\t\t\t\t enum reg_class rclass)\n+rs6000_can_change_mode_class (machine_mode from,\n+\t\t\t      machine_mode to,\n+\t\t\t      reg_class_t rclass)\n {\n   unsigned from_size = GET_MODE_SIZE (from);\n   unsigned to_size = GET_MODE_SIZE (to);\n@@ -20672,31 +20667,31 @@ rs6000_cannot_change_mode_class (machine_mode from,\n \t     values.  */\n \n \t  if (to_float128_vector_p && from_float128_vector_p)\n-\t    return false;\n+\t    return true;\n \n \t  else if (to_float128_vector_p || from_float128_vector_p)\n-\t    return true;\n+\t    return false;\n \n \t  /* TDmode in floating-mode registers must always go into a register\n \t     pair with the most significant word in the even-numbered register\n \t     to match ISA requirements.  In little-endian mode, this does not\n \t     match subreg numbering, so we cannot allow subregs.  */\n \t  if (!BYTES_BIG_ENDIAN && (to == TDmode || from == TDmode))\n-\t    return true;\n+\t    return false;\n \n \t  if (from_size < 8 || to_size < 8)\n-\t    return true;\n+\t    return false;\n \n \t  if (from_size == 8 && (8 * to_nregs) != to_size)\n-\t    return true;\n+\t    return false;\n \n \t  if (to_size == 8 && (8 * from_nregs) != from_size)\n-\t    return true;\n+\t    return false;\n \n-\t  return false;\n+\t  return true;\n \t}\n       else\n-\treturn false;\n+\treturn true;\n     }\n \n   /* Since the VSX register set includes traditional floating point registers\n@@ -20710,28 +20705,28 @@ rs6000_cannot_change_mode_class (machine_mode from,\n       unsigned num_regs = (from_size + 15) / 16;\n       if (hard_regno_nregs (FIRST_FPR_REGNO, to) > num_regs\n \t  || hard_regno_nregs (FIRST_FPR_REGNO, from) > num_regs)\n-\treturn true;\n+\treturn false;\n \n-      return (from_size != 8 && from_size != 16);\n+      return (from_size == 8 || from_size == 16);\n     }\n \n   if (TARGET_ALTIVEC && rclass == ALTIVEC_REGS\n       && (ALTIVEC_VECTOR_MODE (from) + ALTIVEC_VECTOR_MODE (to)) == 1)\n-    return true;\n+    return false;\n \n-  return false;\n+  return true;\n }\n \n-/* Debug version of rs6000_cannot_change_mode_class.  */\n+/* Debug version of rs6000_can_change_mode_class.  */\n static bool\n-rs6000_debug_cannot_change_mode_class (machine_mode from,\n-\t\t\t\t       machine_mode to,\n-\t\t\t\t       enum reg_class rclass)\n+rs6000_debug_can_change_mode_class (machine_mode from,\n+\t\t\t\t    machine_mode to,\n+\t\t\t\t    reg_class_t rclass)\n {\n-  bool ret = rs6000_cannot_change_mode_class (from, to, rclass);\n+  bool ret = rs6000_can_change_mode_class (from, to, rclass);\n \n   fprintf (stderr,\n-\t   \"rs6000_cannot_change_mode_class, return %s, from = %s, \"\n+\t   \"rs6000_can_change_mode_class, return %s, from = %s, \"\n \t   \"to = %s, rclass = %s\\n\",\n \t   ret ? \"true\" : \"false\",\n \t   GET_MODE_NAME (from), GET_MODE_NAME (to),"}, {"sha": "3866cb39344f919044ebb4d1d8ea1ffe672ba0c2", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1515,11 +1515,6 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n    registers can hold 128 bits.  */\n #define CLASS_MAX_NREGS(CLASS, MODE) rs6000_class_max_nregs[(MODE)][(CLASS)]\n \n-/* Return nonzero if for CLASS a mode change from FROM to TO is invalid.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\t\\\n-  rs6000_cannot_change_mode_class_ptr (FROM, TO, CLASS)\n-\n /* Stack layout; function entry, exit and calling.  */\n \n /* Define this if pushing a word on the stack"}, {"sha": "84b30704d9e56e8435d74a5ed0b81fbd8cdf269b", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -49,8 +49,6 @@ extern void s390_function_profiler (FILE *, int);\n extern void s390_set_has_landing_pad_p (bool);\n extern bool s390_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int s390_class_max_nregs (enum reg_class, machine_mode);\n-extern int s390_cannot_change_mode_class (machine_mode, machine_mode,\n-\t\t\t\t\t  enum reg_class);\n extern bool s390_function_arg_vector (machine_mode, const_tree);\n #if S390_USE_TARGET_ATTRIBUTE\n extern tree s390_valid_target_attribute_tree (tree args,"}, {"sha": "f8cf213901d5ddc0675635e56e1d06ebe4796c8d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -10630,13 +10630,12 @@ s390_class_max_nregs (enum reg_class rclass, machine_mode mode)\n   return (GET_MODE_SIZE (mode) + reg_size - 1) / reg_size;\n }\n \n-/* Return TRUE if changing mode from FROM to TO should not be allowed\n-   for register class CLASS.  */\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n \n-int\n-s390_cannot_change_mode_class (machine_mode from_mode,\n-\t\t\t       machine_mode to_mode,\n-\t\t\t       enum reg_class rclass)\n+static bool\n+s390_can_change_mode_class (machine_mode from_mode,\n+\t\t\t    machine_mode to_mode,\n+\t\t\t    reg_class_t rclass)\n {\n   machine_mode small_mode;\n   machine_mode big_mode;\n@@ -10646,10 +10645,10 @@ s390_cannot_change_mode_class (machine_mode from_mode,\n   if (reg_classes_intersect_p (VEC_REGS, rclass)\n       && ((from_mode == V1TFmode && to_mode == TFmode)\n \t  || (from_mode == TFmode && to_mode == V1TFmode)))\n-    return 1;\n+    return false;\n \n   if (GET_MODE_SIZE (from_mode) == GET_MODE_SIZE (to_mode))\n-    return 0;\n+    return true;\n \n   if (GET_MODE_SIZE (from_mode) < GET_MODE_SIZE (to_mode))\n     {\n@@ -10672,14 +10671,14 @@ s390_cannot_change_mode_class (machine_mode from_mode,\n   if (reg_classes_intersect_p (VEC_REGS, rclass)\n       && (GET_MODE_SIZE (small_mode) < 8\n \t  || s390_class_max_nregs (VEC_REGS, big_mode) == 1))\n-    return 1;\n+    return false;\n \n   /* Likewise for access registers, since they have only half the\n      word size on 64-bit.  */\n   if (reg_classes_intersect_p (ACCESS_REGS, rclass))\n-    return 1;\n+    return false;\n \n-  return 0;\n+  return true;\n }\n \n /* Return true if we use LRA instead of reload pass.  */\n@@ -16115,6 +16114,9 @@ s390_asan_shadow_offset (void)\n #undef TARGET_OPTION_RESTORE\n #define TARGET_OPTION_RESTORE s390_function_specific_restore\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS s390_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-s390.h\""}, {"sha": "0f6ea874983e08935a23d0fe4846b282cf20e6f6", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -477,9 +477,6 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n #define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n   s390_class_max_nregs ((CLASS), (MODE))\n \n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t        \\\n-  s390_cannot_change_mode_class ((FROM), (TO), (CLASS))\n-\n /* We can reverse a CC mode safely if we know whether it comes from a\n    floating point compare or not.  With the vector modes it is encoded\n    as part of the mode."}, {"sha": "e98030d31bd7d73fea07e7bfddd2c28e2806790f", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -324,8 +324,6 @@ extern bool sh_cfun_interrupt_handler_p (void);\n extern bool sh_cfun_resbank_handler_p (void);\n extern bool sh_attr_renesas_p (const_tree);\n extern bool sh_cfun_attr_renesas_p (void);\n-extern bool sh_cannot_change_mode_class\n-\t      (machine_mode, machine_mode, enum reg_class);\n extern bool sh_small_register_classes_for_mode_p (machine_mode);\n extern void sh_mark_label (rtx, int);\n extern bool check_use_sfunc_addr (rtx_insn *, rtx);"}, {"sha": "fa9f9ad17a6cdceaff3260d631d3a6ee21c4b27e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -325,6 +325,7 @@ static void sh_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n static unsigned int sh_hard_regno_nregs (unsigned int, machine_mode);\n static bool sh_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool sh_modes_tieable_p (machine_mode, machine_mode);\n+static bool sh_can_change_mode_class (machine_mode, machine_mode, reg_class_t);\n \f\n static const struct attribute_spec sh_attribute_table[] =\n {\n@@ -653,6 +654,9 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P sh_modes_tieable_p\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS sh_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -10628,11 +10632,10 @@ sh_hard_regno_caller_save_mode (unsigned int regno, unsigned int nregs,\n   return choose_hard_reg_mode (regno, nregs, false);\n }\n \n-/* Return the class of registers for which a mode change from FROM to TO\n-   is invalid.  */\n-bool\n-sh_cannot_change_mode_class (machine_mode from, machine_mode to,\n-\t\t\t     enum reg_class rclass)\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  */\n+static bool\n+sh_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t  reg_class_t rclass)\n {\n   /* We want to enable the use of SUBREGs as a means to\n      VEC_SELECT a single element of a vector.  */\n@@ -10642,22 +10645,22 @@ sh_cannot_change_mode_class (machine_mode from, machine_mode to,\n      on the stack with displacement addressing, as it happens with -O0.\n      Thus we disallow the mode change for -O0.  */\n   if (to == SFmode && VECTOR_MODE_P (from) && GET_MODE_INNER (from) == SFmode)\n-    return optimize ? (reg_classes_intersect_p (GENERAL_REGS, rclass)) : false;\n+    return optimize ? !reg_classes_intersect_p (GENERAL_REGS, rclass) : true;\n \n   if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n     {\n       if (TARGET_LITTLE_ENDIAN)\n \t{\n \t  if (GET_MODE_SIZE (to) < 8 || GET_MODE_SIZE (from) < 8)\n-\t    return reg_classes_intersect_p (DF_REGS, rclass);\n+\t    return !reg_classes_intersect_p (DF_REGS, rclass);\n \t}\n       else\n \t{\n \t  if (GET_MODE_SIZE (from) < 8)\n-\t    return reg_classes_intersect_p (DF_REGS, rclass);\n+\t    return !reg_classes_intersect_p (DF_REGS, rclass);\n \t}\n     }\n-  return false;\n+  return true;\n }\n \n /* Return true if registers in machine mode MODE will likely be"}, {"sha": "f020972931ad1a2849f09d1de2530666abb1470e", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1087,13 +1087,6 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n    Otherwise we will need at most one register per word.  */\n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* If defined, gives a class of registers that cannot be used as the\n-   operand of a SUBREG that changes the mode of the object illegally.\n-   ??? We need to renumber the internal numbers for the frnn registers\n-   when in little endian in order to allow mode size changes.  */\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  sh_cannot_change_mode_class (FROM, TO, CLASS)\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "749a7f866cb5c077cc4a5709e2d9dca91cd95859", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -682,7 +682,8 @@ static unsigned int sparc_min_arithmetic_precision (void);\n static unsigned int sparc_hard_regno_nregs (unsigned int, machine_mode);\n static bool sparc_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool sparc_modes_tieable_p (machine_mode, machine_mode);\n-\n+static bool sparc_can_change_mode_class (machine_mode, machine_mode,\n+\t\t\t\t\t reg_class_t);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -921,6 +922,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P sparc_modes_tieable_p\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS sparc_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Return the memory reference contained in X if any, zero otherwise.  */\n@@ -13401,4 +13405,26 @@ sparc_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n     = compound_expr (compound_expr (update_stfsr, update_ldfsr), update_call);\n }\n \n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  Borrowed from the PA port.\n+\n+   SImode loads to floating-point registers are not zero-extended.\n+   The definition for LOAD_EXTEND_OP specifies that integer loads\n+   narrower than BITS_PER_WORD will be zero-extended.  As a result,\n+   we inhibit changes from SImode unless they are to a mode that is\n+   identical in size.\n+\n+   Likewise for SFmode, since word-mode paradoxical subregs are\n+   problematic on big-endian architectures.  */\n+\n+static bool\n+sparc_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t     reg_class_t rclass)\n+{\n+  if (TARGET_ARCH64\n+      && GET_MODE_SIZE (from) == 4\n+      && GET_MODE_SIZE (to) != 4)\n+    return !reg_classes_intersect_p (rclass, FP_REGS);\n+  return true;\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "af350d7a11acc051d39b2b9a272be7a62aa2ae10", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -907,23 +907,6 @@ extern enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n #define REGNO_REG_CLASS(REGNO) sparc_regno_reg_class[(REGNO)]\n \n-/* Defines invalid mode changes.  Borrowed from the PA port.\n-\n-   SImode loads to floating-point registers are not zero-extended.\n-   The definition for LOAD_EXTEND_OP specifies that integer loads\n-   narrower than BITS_PER_WORD will be zero-extended.  As a result,\n-   we inhibit changes from SImode unless they are to a mode that is\n-   identical in size.\n-\n-   Likewise for SFmode, since word-mode paradoxical subregs are\n-   problematic on big-endian architectures.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\\n-  (TARGET_ARCH64\t\t\t\t\t\t\\\n-   && GET_MODE_SIZE (FROM) == 4\t\t\t\t\t\\\n-   && GET_MODE_SIZE (TO) != 4\t\t\t\t\t\\\n-   ? reg_classes_intersect_p (CLASS, FP_REGS) : 0)\n-\n /* This is the order in which to allocate registers normally.\n \n    We put %f0-%f7 last among the float registers, so as to make it more"}, {"sha": "413567ba2bd9a4022d87eba3d7d49cca9c628564", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -7162,6 +7162,17 @@ spu_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n   return (GET_MODE_BITSIZE (mode1) <= MAX_FIXED_MODE_SIZE\n \t  && GET_MODE_BITSIZE (mode2) <= MAX_FIXED_MODE_SIZE);\n }\n+\n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.  GCC assumes that modes are\n+   in the lowpart of a register, which is only true for SPU.  */\n+\n+static bool\n+spu_can_change_mode_class (machine_mode from, machine_mode to, reg_class_t)\n+{\n+  return (GET_MODE_SIZE (from) == GET_MODE_SIZE (to)\n+\t  || (GET_MODE_SIZE (from) <= 4 && GET_MODE_SIZE (to) <= 4)\n+\t  || (GET_MODE_SIZE (from) >= 16 && GET_MODE_SIZE (to) >= 16));\n+}\n \f\n /*  Table of machine attributes.  */\n static const struct attribute_spec spu_attribute_table[] =\n@@ -7393,6 +7404,9 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_HARD_REGNO_NREGS\n #define TARGET_HARD_REGNO_NREGS spu_hard_regno_nregs\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS spu_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-spu.h\""}, {"sha": "f41117e071dd0bfcf169eb45220997d0348a88a6", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -211,13 +211,6 @@ enum reg_class {\n #define INT_REG_OK_FOR_BASE_P(X,STRICT) \\\n \t((!(STRICT) || REGNO_OK_FOR_BASE_P (REGNO (X))))\n \n-/* GCC assumes that modes are in the lowpart of a register, which is\n-   only true for SPU. */\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-        ((GET_MODE_SIZE (FROM) > 4 || GET_MODE_SIZE (TO) > 4) \\\n-\t && (GET_MODE_SIZE (FROM) < 16 || GET_MODE_SIZE (TO) < 16) \\\n-\t && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n-\n #define REGISTER_TARGET_PRAGMAS() do {\t\t\t\t\t\\\n c_register_addr_space (\"__ea\", ADDR_SPACE_EA);\t\t\t\t\\\n targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\"}, {"sha": "4dd66dcd40b3322c19977d98c3fb519f54471140", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -234,6 +234,9 @@ static bool visium_hard_regno_mode_ok (unsigned int, machine_mode);\n \n static bool visium_modes_tieable_p (machine_mode, machine_mode);\n \n+static bool visium_can_change_mode_class (machine_mode, machine_mode,\n+\t\t\t\t\t  reg_class_t);\n+\n /* Setup the global target hooks structure.  */\n \n #undef  TARGET_MAX_ANCHOR_OFFSET\n@@ -354,6 +357,9 @@ static bool visium_modes_tieable_p (machine_mode, machine_mode);\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P visium_modes_tieable_p\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS visium_can_change_mode_class\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n namespace {\n@@ -4293,4 +4299,24 @@ reg_or_subreg_regno (rtx op)\n   return regno;\n }\n \n+/* Implement TARGET_CAN_CHANGE_MODE_CLASS.\n+\n+   It's not obvious from the documentation of the hook that MDB cannot\n+   change mode.  However difficulties arise from expressions of the form\n+\n+   (subreg:SI (reg:DI R_MDB) 0)\n+\n+   There is no way to convert that reference to a single machine\n+   register and, without the following definition, reload will quietly\n+   convert it to\n+\n+   (reg:SI R_MDB).  */\n+\n+static bool\n+visium_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t      reg_class_t rclass)\n+{\n+  return (rclass != MDB || GET_MODE_SIZE (from) == GET_MODE_SIZE (to));\n+}\n+\n #include \"gt-visium.h\""}, {"sha": "b415e3c221d42dfab4c5557254b2243aa3c9543a", "filename": "gcc/config/visium/visium.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -723,24 +723,6 @@ enum reg_class\n    registers. */\n #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n \n-/*  `CANNOT_CHANGE_MODE_CLASS (from, to, class)\n-\n-    If defined, a C expression that returns nonzero for a `class' for\n-    which a change from mode `from' to mode `to' is invalid.\n-\n-    It's not obvious from the above that MDB cannot change mode. However\n-    difficulties arise from expressions of the form\n-\n-    (subreg:SI (reg:DI R_MDB) 0)\n- \n-    There is no way to convert that reference to a single machine\n-    register and, without the following definition, reload will quietly\n-    convert it to\n- \n-     (reg:SI R_MDB)  */\n-#define CANNOT_CHANGE_MODE_CLASS(FROM,TO,CLASS) \\\n-  (CLASS == MDB ? (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)) : 0)\n-\n #define CLASS_MAX_NREGS(CLASS, MODE)    \\\n   ((CLASS) == MDB ?                     \\\n   ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\"}, {"sha": "3b2b24748b885f36284db3217ef24d1de4b2dda2", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -2024,17 +2024,17 @@ has an unknown number of undefined bits, so the assignment:\n does not guarantee that @samp{(subreg:HI (reg:PSI 0) 0)} has the\n value @samp{(reg:HI 4)}.\n \n-@cindex @code{CANNOT_CHANGE_MODE_CLASS} and subreg semantics\n+@cindex @code{TARGET_CAN_CHANGE_MODE_CLASS} and subreg semantics\n The rules above apply to both pseudo @var{reg}s and hard @var{reg}s.\n If the semantics are not correct for particular combinations of\n @var{m1}, @var{m2} and hard @var{reg}, the target-specific code\n must ensure that those combinations are never used.  For example:\n \n @smallexample\n-CANNOT_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})\n+TARGET_CAN_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})\n @end smallexample\n \n-must be true for every class @var{class} that includes @var{reg}.\n+must be false for every class @var{class} that includes @var{reg}.\n \n @findex SUBREG_REG\n @findex SUBREG_BYTE"}, {"sha": "5b9e2b34f54e64734378188f522ab8a0dec8e941", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -2018,8 +2018,8 @@ This hook returns the number of consecutive hard registers, starting\n at register number @var{regno}, required to hold a value of mode\n @var{mode}.  This hook must never return zero, even if a register\n cannot hold the requested mode - indicate that with\n-@code{TARGET_HARD_REGNO_MODE_OK} and/or @code{CANNOT_CHANGE_MODE_CLASS}\n-instead.\n+@code{TARGET_HARD_REGNO_MODE_OK} and/or\n+@code{TARGET_CAN_CHANGE_MODE_CLASS} instead.\n \n The default definition returns the number of words in @var{mode}.\n @end deftypefn\n@@ -2814,34 +2814,35 @@ This macro helps control the handling of multiple-word values\n in the reload pass.\n @end defmac\n \n-@defmac CANNOT_CHANGE_MODE_CLASS (@var{from}, @var{to}, @var{class})\n-If defined, a C expression that returns nonzero for a @var{class} for which\n-a change from mode @var{from} to mode @var{to} is invalid.\n+@deftypefn {Target Hook} bool TARGET_CAN_CHANGE_MODE_CLASS (machine_mode @var{from}, machine_mode @var{to}, reg_class_t @var{rclass})\n+This hook returns true if it is possible to bitcast values held in\n+registers of class @var{rclass} from mode @var{from} to mode @var{to}\n+and if doing so preserves the low-order bits that are common to both modes.\n+The result is only meaningful if @var{rclass} has registers that can hold\n+both @code{from} and @code{to}.  The default implementation returns true.\n \n-For example, loading 32-bit integer or floating-point objects into\n-floating-point registers on Alpha extends them to 64 bits.\n-Therefore loading a 64-bit object and then storing it as a 32-bit object\n-does not store the low-order 32 bits, as would be the case for a normal\n-register.  Therefore, @file{alpha.h} defines @code{CANNOT_CHANGE_MODE_CLASS}\n-as below:\n+As an example of when such bitcasting is invalid, loading 32-bit integer or\n+floating-point objects into floating-point registers on Alpha extends them\n+to 64 bits.  Therefore loading a 64-bit object and then storing it as a\n+32-bit object does not store the low-order 32 bits, as would be the case\n+for a normal register.  Therefore, @file{alpha.h} defines\n+@code{TARGET_CAN_CHANGE_MODE_CLASS} to return:\n \n @smallexample\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \\\n-   ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)\n+(GET_MODE_SIZE (from) == GET_MODE_SIZE (to)\n+ || !reg_classes_intersect_p (FLOAT_REGS, rclass))\n @end smallexample\n \n Even if storing from a register in mode @var{to} would be valid,\n-if both @var{from} and @code{raw_reg_mode} for @var{class} are wider\n+if both @var{from} and @code{raw_reg_mode} for @var{rclass} are wider\n than @code{word_mode}, then we must prevent @var{to} narrowing the\n mode.  This happens when the middle-end assumes that it can load\n or store pieces of an @var{N}-word pseudo, and that the pseudo will\n eventually be allocated to @var{N} @code{word_mode} hard registers.\n Failure to prevent this kind of mode change will result in the\n entire @code{raw_reg_mode} being modified instead of the partial\n value that the middle-end intended.\n-\n-@end defmac\n+@end deftypefn\n \n @deftypefn {Target Hook} reg_class_t TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS (int, @var{reg_class_t}, @var{reg_class_t})\n A target hook which can change allocno class for given pseudo from\n@@ -10695,12 +10696,12 @@ define it as the constant @code{SIGN_EXTEND} or @code{ZERO_EXTEND}.\n \n You may return a non-@code{UNKNOWN} value even if for some hard registers\n the sign extension is not performed, if for the @code{REGNO_REG_CLASS}\n-of these hard registers @code{CANNOT_CHANGE_MODE_CLASS} returns nonzero\n+of these hard registers @code{TARGET_CAN_CHANGE_MODE_CLASS} returns false\n when the @var{from} mode is @var{mem_mode} and the @var{to} mode is any\n integral mode larger than this but not larger than @code{word_mode}.\n \n You must return @code{UNKNOWN} if for some hard registers that allow this\n-mode, @code{CANNOT_CHANGE_MODE_CLASS} says that they cannot change to\n+mode, @code{TARGET_CAN_CHANGE_MODE_CLASS} says that they cannot change to\n @code{word_mode}, but that they can change to another integral mode that\n is larger then @var{mem_mode} but still smaller than @code{word_mode}.\n @end defmac\n@@ -10813,7 +10814,7 @@ widest integral mode and currently we take advantage of this fact.)\n Similarly to @code{LOAD_EXTEND_OP} you may return a non-@code{UNKNOWN}\n value even if the extension is not performed on certain hard registers\n as long as for the @code{REGNO_REG_CLASS} of these hard registers\n-@code{CANNOT_CHANGE_MODE_CLASS} returns nonzero.\n+@code{TARGET_CAN_CHANGE_MODE_CLASS} returns false.\n \n Note that @code{TARGET_MODE_REP_EXTENDED} and @code{LOAD_EXTEND_OP}\n describe two related properties.  If you define"}, {"sha": "57b017fb81dbfd2ac13d1db639474fd0b469ca00", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -2334,34 +2334,7 @@ This macro helps control the handling of multiple-word values\n in the reload pass.\n @end defmac\n \n-@defmac CANNOT_CHANGE_MODE_CLASS (@var{from}, @var{to}, @var{class})\n-If defined, a C expression that returns nonzero for a @var{class} for which\n-a change from mode @var{from} to mode @var{to} is invalid.\n-\n-For example, loading 32-bit integer or floating-point objects into\n-floating-point registers on Alpha extends them to 64 bits.\n-Therefore loading a 64-bit object and then storing it as a 32-bit object\n-does not store the low-order 32 bits, as would be the case for a normal\n-register.  Therefore, @file{alpha.h} defines @code{CANNOT_CHANGE_MODE_CLASS}\n-as below:\n-\n-@smallexample\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \\\n-   ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)\n-@end smallexample\n-\n-Even if storing from a register in mode @var{to} would be valid,\n-if both @var{from} and @code{raw_reg_mode} for @var{class} are wider\n-than @code{word_mode}, then we must prevent @var{to} narrowing the\n-mode.  This happens when the middle-end assumes that it can load\n-or store pieces of an @var{N}-word pseudo, and that the pseudo will\n-eventually be allocated to @var{N} @code{word_mode} hard registers.\n-Failure to prevent this kind of mode change will result in the\n-entire @code{raw_reg_mode} being modified instead of the partial\n-value that the middle-end intended.\n-\n-@end defmac\n+@hook TARGET_CAN_CHANGE_MODE_CLASS\n \n @hook TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS\n \n@@ -7451,12 +7424,12 @@ define it as the constant @code{SIGN_EXTEND} or @code{ZERO_EXTEND}.\n \n You may return a non-@code{UNKNOWN} value even if for some hard registers\n the sign extension is not performed, if for the @code{REGNO_REG_CLASS}\n-of these hard registers @code{CANNOT_CHANGE_MODE_CLASS} returns nonzero\n+of these hard registers @code{TARGET_CAN_CHANGE_MODE_CLASS} returns false\n when the @var{from} mode is @var{mem_mode} and the @var{to} mode is any\n integral mode larger than this but not larger than @code{word_mode}.\n \n You must return @code{UNKNOWN} if for some hard registers that allow this\n-mode, @code{CANNOT_CHANGE_MODE_CLASS} says that they cannot change to\n+mode, @code{TARGET_CAN_CHANGE_MODE_CLASS} says that they cannot change to\n @code{word_mode}, but that they can change to another integral mode that\n is larger then @var{mem_mode} but still smaller than @code{word_mode}.\n @end defmac"}, {"sha": "e790cbcb6ff0989453ed618563c3a12435fbf713", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -866,13 +866,11 @@ validate_subreg (machine_mode omode, machine_mode imode,\n     {\n       unsigned int regno = REGNO (reg);\n \n-#ifdef CANNOT_CHANGE_MODE_CLASS\n       if ((COMPLEX_MODE_P (imode) || VECTOR_MODE_P (imode))\n \t  && GET_MODE_INNER (imode) == omode)\n \t;\n-      else if (REG_CANNOT_CHANGE_MODE_P (regno, imode, omode))\n+      else if (!REG_CAN_CHANGE_MODE_P (regno, imode, omode))\n \treturn false;\n-#endif\n \n       return subreg_offset_representable_p (regno, imode, offset, omode);\n     }"}, {"sha": "42a85a16a4ef90cb27e28984f130544908b8e96b", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -765,9 +765,9 @@ extern struct target_hard_regs *this_target_hard_regs;\n \n extern const char * reg_class_names[];\n \n-/* Given a hard REGN a FROM mode and a TO mode, return nonzero if\n-   REGN cannot change modes between the specified modes.  */\n-#define REG_CANNOT_CHANGE_MODE_P(REGN, FROM, TO)                          \\\n-         CANNOT_CHANGE_MODE_CLASS (FROM, TO, REGNO_REG_CLASS (REGN))\n+/* Given a hard REGN a FROM mode and a TO mode, return true if\n+   REGN can change from mode FROM to mode TO.  */\n+#define REG_CAN_CHANGE_MODE_P(REGN, FROM, TO)                          \\\n+  (targetm.can_change_mode_class (FROM, TO, REGNO_REG_CLASS (REGN)))\n \n #endif /* ! GCC_HARD_REG_SET_H */"}, {"sha": "3af7795a7ef9a7caba5cd89ae1ccfac7c29d28ea", "filename": "gcc/hooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -495,6 +495,14 @@ hook_bool_reg_class_t_false (reg_class_t regclass ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Generic hook that takes 2 machine_modes and a register class and\n+   returns true.  */\n+bool\n+hook_bool_mode_mode_reg_class_t_true (machine_mode, machine_mode, reg_class_t)\n+{\n+  return true;\n+}\n+\n /* Generic hook that takes a machine_mode and 2 register classes\n    and returns false.  */\n bool"}, {"sha": "6838c23cf2c01fd30a698b6d5151777d47209c40", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -59,6 +59,8 @@ extern bool hook_bool_rtx_false (rtx);\n extern bool hook_bool_rtx_insn_int_false (rtx_insn *, int);\n extern bool hook_bool_uintp_uintp_false (unsigned int *, unsigned int *);\n extern bool hook_bool_reg_class_t_false (reg_class_t regclass);\n+extern bool hook_bool_mode_mode_reg_class_t_true (machine_mode, machine_mode,\n+\t\t\t\t\t\t  reg_class_t);\n extern bool hook_bool_mode_reg_class_t_reg_class_t_false (machine_mode,\n \t\t\t\t\t\t\t  reg_class_t,\n \t\t\t\t\t\t\t  reg_class_t);"}, {"sha": "000ed341b0347c1358eff03616926fcfac72a142", "filename": "gcc/postreload.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -335,12 +335,8 @@ reload_cse_simplify_set (rtx set, rtx_insn *insn)\n \t      && !REG_P (SET_SRC (set))))\n \t{\n \t  if (extend_op != UNKNOWN\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SET_DEST (set)),\n-\t\t\t\t\t    word_mode,\n-\t\t\t\t\t    REGNO_REG_CLASS (REGNO (SET_DEST (set))))\n-#endif\n-\t      )\n+\t      && REG_CAN_CHANGE_MODE_P (REGNO (SET_DEST (set)),\n+\t\t\t\t\tGET_MODE (SET_DEST (set)), word_mode))\n \t    {\n \t      rtx wide_dest = gen_rtx_REG (word_mode, REGNO (SET_DEST (set)));\n \t      ORIGINAL_REGNO (wide_dest) = ORIGINAL_REGNO (SET_DEST (set));\n@@ -437,15 +433,13 @@ reload_cse_simplify_operands (rtx_insn *insn, rtx testreg)\n \t\t   || GET_CODE (SET_SRC (set)) == ZERO_EXTEND\n \t\t   || GET_CODE (SET_SRC (set)) == SIGN_EXTEND)\n \t    ; /* Continue ordinary processing.  */\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n \t  /* If the register cannot change mode to word_mode, it follows that\n \t     it cannot have been used in word_mode.  */\n \t  else if (REG_P (SET_DEST (set))\n-\t\t   && CANNOT_CHANGE_MODE_CLASS (GET_MODE (SET_DEST (set)),\n-\t\t\t\t\t\tword_mode,\n-\t\t\t\t\t\tREGNO_REG_CLASS (REGNO (SET_DEST (set)))))\n+\t\t   && !REG_CAN_CHANGE_MODE_P (REGNO (SET_DEST (set)),\n+\t\t\t\t\t      GET_MODE (SET_DEST (set)),\n+\t\t\t\t\t      word_mode))\n \t    ; /* Continue ordinary processing.  */\n-#endif\n \t  /* If this is a straight load, make the extension explicit.  */\n \t  else if (REG_P (SET_DEST (set))\n \t\t   && recog_data.n_operands == 2"}, {"sha": "cfce0291ba03732abe98c21cccec423db95fbe4c", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1009,18 +1009,16 @@ general_operand (rtx op, machine_mode mode)\n \t  && MEM_P (sub))\n \treturn 0;\n \n-#ifdef CANNOT_CHANGE_MODE_CLASS\n       if (REG_P (sub)\n \t  && REGNO (sub) < FIRST_PSEUDO_REGISTER\n-\t  && REG_CANNOT_CHANGE_MODE_P (REGNO (sub), GET_MODE (sub), mode)\n+\t  && !REG_CAN_CHANGE_MODE_P (REGNO (sub), GET_MODE (sub), mode)\n \t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_INT\n \t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_FLOAT\n \t  /* LRA can generate some invalid SUBREGS just for matched\n \t     operand reload presentation.  LRA needs to treat them as\n \t     valid.  */\n \t  && ! LRA_SUBREG_P (op))\n \treturn 0;\n-#endif\n \n       /* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally\n \t create such rtl, and we must reject it.  */"}, {"sha": "73e945d45ae651b704f0dc072c3fd7211a6f0fe8", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -376,11 +376,7 @@ mode_change_ok (machine_mode orig_mode, machine_mode new_mode,\n   if (partial_subreg_p (orig_mode, new_mode))\n     return false;\n \n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-  return !REG_CANNOT_CHANGE_MODE_P (regno, orig_mode, new_mode);\n-#endif\n-\n-  return true;\n+  return REG_CAN_CHANGE_MODE_P (regno, orig_mode, new_mode);\n }\n \n /* Register REGNO was originally set in ORIG_MODE.  It - or a copy of it -"}, {"sha": "dae3b027bb387d52f5a84697308fecd993f3db6d", "filename": "gcc/reload.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -1038,9 +1038,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   scalar_int_mode inner_mode;\n   if (in != 0 && GET_CODE (in) == SUBREG\n       && (subreg_lowpart_p (in) || strict_low)\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SUBREG_REG (in)), inmode, rclass)\n-#endif\n+      && targetm.can_change_mode_class (GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\tinmode, rclass)\n       && contains_allocatable_reg_of_mode[rclass][GET_MODE (SUBREG_REG (in))]\n       && (CONSTANT_P (SUBREG_REG (in))\n \t  || GET_CODE (SUBREG_REG (in)) == PLUS\n@@ -1076,13 +1075,10 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t      && (secondary_reload_class (1, rclass, GET_MODE (SUBREG_REG (in)),\n \t\t\t\t\t  SUBREG_REG (in))\n \t\t  == NO_REGS))\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n \t  || (REG_P (SUBREG_REG (in))\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n-\t      && REG_CANNOT_CHANGE_MODE_P\n-\t      (REGNO (SUBREG_REG (in)), GET_MODE (SUBREG_REG (in)), inmode))\n-#endif\n-\t  ))\n+\t      && !REG_CAN_CHANGE_MODE_P (REGNO (SUBREG_REG (in)),\n+\t\t\t\t\t GET_MODE (SUBREG_REG (in)), inmode))))\n     {\n #ifdef LIMIT_RELOAD_CLASS\n       in_subreg_loc = inloc;\n@@ -1143,9 +1139,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n      label it input-output.)  */\n   if (out != 0 && GET_CODE (out) == SUBREG\n       && (subreg_lowpart_p (out) || strict_low)\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SUBREG_REG (out)), outmode, rclass)\n-#endif\n+      && targetm.can_change_mode_class (GET_MODE (SUBREG_REG (out)),\n+\t\t\t\t\toutmode, rclass)\n       && contains_allocatable_reg_of_mode[rclass][GET_MODE (SUBREG_REG (out))]\n       && (CONSTANT_P (SUBREG_REG (out))\n \t  || strict_low\n@@ -1170,14 +1165,11 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t      && (secondary_reload_class (0, rclass, GET_MODE (SUBREG_REG (out)),\n \t\t\t\t\t  SUBREG_REG (out))\n \t\t  == NO_REGS))\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n \t  || (REG_P (SUBREG_REG (out))\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n-\t      && REG_CANNOT_CHANGE_MODE_P (REGNO (SUBREG_REG (out)),\n-\t\t\t\t\t   GET_MODE (SUBREG_REG (out)),\n-\t\t\t\t\t   outmode))\n-#endif\n-\t  ))\n+\t      && !REG_CAN_CHANGE_MODE_P (REGNO (SUBREG_REG (out)),\n+\t\t\t\t\t GET_MODE (SUBREG_REG (out)),\n+\t\t\t\t\t outmode))))\n     {\n #ifdef LIMIT_RELOAD_CLASS\n       out_subreg_loc = outloc;"}, {"sha": "5e200b94ebb238abe0927533c5bbe59320f043d3", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -6557,14 +6557,12 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t  && reg_last_reload_reg[regno] != 0\n \t\t  && (GET_MODE_SIZE (GET_MODE (reg_last_reload_reg[regno]))\n \t\t      >= GET_MODE_SIZE (mode) + byte)\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n \t\t  /* Verify that the register it's in can be used in\n \t\t     mode MODE.  */\n-\t\t  && !REG_CANNOT_CHANGE_MODE_P (REGNO (reg_last_reload_reg[regno]),\n-\t\t\t\t\t\tGET_MODE (reg_last_reload_reg[regno]),\n-\t\t\t\t\t\tmode)\n-#endif\n-\t\t  )\n+\t\t  && (REG_CAN_CHANGE_MODE_P\n+\t\t      (REGNO (reg_last_reload_reg[regno]),\n+\t\t       GET_MODE (reg_last_reload_reg[regno]),\n+\t\t       mode)))\n \t\t{\n \t\t  enum reg_class rclass = rld[r].rclass, last_class;\n \t\t  rtx last_reg = reg_last_reload_reg[regno];\n@@ -8035,12 +8033,8 @@ inherit_piecemeal_p (int dest ATTRIBUTE_UNUSED,\n \t\t     int src ATTRIBUTE_UNUSED,\n \t\t     machine_mode mode ATTRIBUTE_UNUSED)\n {\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-  return (!REG_CANNOT_CHANGE_MODE_P (dest, mode, reg_raw_mode[dest])\n-\t  && !REG_CANNOT_CHANGE_MODE_P (src, mode, reg_raw_mode[src]));\n-#else\n-  return true;\n-#endif\n+  return (REG_CAN_CHANGE_MODE_P (dest, mode, reg_raw_mode[dest])\n+\t  && REG_CAN_CHANGE_MODE_P (src, mode, reg_raw_mode[src]));\n }\n \n /* Output insns to reload values in and out of the chosen reload regs.  */"}, {"sha": "b28325e644ba37c4817b62de52b6d74026a6b5a9", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -3861,15 +3861,13 @@ simplify_subreg_regno (unsigned int xregno, machine_mode xmode,\n   struct subreg_info info;\n   unsigned int yregno;\n \n-#ifdef CANNOT_CHANGE_MODE_CLASS\n   /* Give the backend a chance to disallow the mode change.  */\n   if (GET_MODE_CLASS (xmode) != MODE_COMPLEX_INT\n       && GET_MODE_CLASS (xmode) != MODE_COMPLEX_FLOAT\n-      && REG_CANNOT_CHANGE_MODE_P (xregno, xmode, ymode)\n+      && !REG_CAN_CHANGE_MODE_P (xregno, xmode, ymode)\n       /* We can use mode change in LRA for some transformations.  */\n       && ! lra_in_progress)\n     return -1;\n-#endif\n \n   /* We shouldn't simplify stack-related registers.  */\n   if ((!reload_completed || frame_pointer_needed)"}, {"sha": "1663a78891f3de58727d9319598d9ab404e758b5", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -914,7 +914,7 @@ extern void fancy_abort (const char *, int, const char *)\n \tHARD_REGNO_CALL_PART_CLOBBERED HARD_REGNO_MODE_OK\t\t\\\n \tMODES_TIEABLE_P FUNCTION_ARG_PADDING SLOW_UNALIGNED_ACCESS\t\\\n \tHARD_REGNO_NREGS SECONDARY_MEMORY_NEEDED_MODE\t\t\t\\\n-\tSECONDARY_MEMORY_NEEDED\n+\tSECONDARY_MEMORY_NEEDED CANNOT_CHANGE_MODE_CLASS\n \n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */"}, {"sha": "ed995494954baa798f05924b6dff6f7fa75dc0cd", "filename": "gcc/target.def", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d803030650a6c671b295d3e7d5161e64b59b2f6/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=0d803030650a6c671b295d3e7d5161e64b59b2f6", "patch": "@@ -3151,7 +3151,7 @@ widest integral mode and currently we take advantage of this fact.)\\n\\\n Similarly to @code{LOAD_EXTEND_OP} you may return a non-@code{UNKNOWN}\\n\\\n value even if the extension is not performed on certain hard registers\\n\\\n as long as for the @code{REGNO_REG_CLASS} of these hard registers\\n\\\n-@code{CANNOT_CHANGE_MODE_CLASS} returns nonzero.\\n\\\n+@code{TARGET_CAN_CHANGE_MODE_CLASS} returns false.\\n\\\n \\n\\\n Note that @code{TARGET_MODE_REP_EXTENDED} and @code{LOAD_EXTEND_OP}\\n\\\n describe two related properties.  If you define\\n\\\n@@ -5043,6 +5043,38 @@ This is currently used only by the C and C++ front ends.\",\n  tree, (tree type, tree expr),\n  hook_tree_tree_tree_null)\n \n+DEFHOOK\n+(can_change_mode_class,\n+ \"This hook returns true if it is possible to bitcast values held in\\n\\\n+registers of class @var{rclass} from mode @var{from} to mode @var{to}\\n\\\n+and if doing so preserves the low-order bits that are common to both modes.\\n\\\n+The result is only meaningful if @var{rclass} has registers that can hold\\n\\\n+both @code{from} and @code{to}.  The default implementation returns true.\\n\\\n+\\n\\\n+As an example of when such bitcasting is invalid, loading 32-bit integer or\\n\\\n+floating-point objects into floating-point registers on Alpha extends them\\n\\\n+to 64 bits.  Therefore loading a 64-bit object and then storing it as a\\n\\\n+32-bit object does not store the low-order 32 bits, as would be the case\\n\\\n+for a normal register.  Therefore, @file{alpha.h} defines\\n\\\n+@code{TARGET_CAN_CHANGE_MODE_CLASS} to return:\\n\\\n+\\n\\\n+@smallexample\\n\\\n+(GET_MODE_SIZE (from) == GET_MODE_SIZE (to)\\n\\\n+ || !reg_classes_intersect_p (FLOAT_REGS, rclass))\\n\\\n+@end smallexample\\n\\\n+\\n\\\n+Even if storing from a register in mode @var{to} would be valid,\\n\\\n+if both @var{from} and @code{raw_reg_mode} for @var{rclass} are wider\\n\\\n+than @code{word_mode}, then we must prevent @var{to} narrowing the\\n\\\n+mode.  This happens when the middle-end assumes that it can load\\n\\\n+or store pieces of an @var{N}-word pseudo, and that the pseudo will\\n\\\n+eventually be allocated to @var{N} @code{word_mode} hard registers.\\n\\\n+Failure to prevent this kind of mode change will result in the\\n\\\n+entire @code{raw_reg_mode} being modified instead of the partial\\n\\\n+value that the middle-end intended.\",\n+ bool, (machine_mode from, machine_mode to, reg_class_t rclass),\n+ hook_bool_mode_mode_reg_class_t_true)\n+\n /* Change pseudo allocno class calculated by IRA.  */\n DEFHOOK\n (ira_change_pseudo_allocno_class,\n@@ -5466,8 +5498,8 @@ DEFHOOK\n at register number @var{regno}, required to hold a value of mode\\n\\\n @var{mode}.  This hook must never return zero, even if a register\\n\\\n cannot hold the requested mode - indicate that with\\n\\\n-@code{TARGET_HARD_REGNO_MODE_OK} and/or @code{CANNOT_CHANGE_MODE_CLASS}\\n\\\n-instead.\\n\\\n+@code{TARGET_HARD_REGNO_MODE_OK} and/or\\n\\\n+@code{TARGET_CAN_CHANGE_MODE_CLASS} instead.\\n\\\n \\n\\\n The default definition returns the number of words in @var{mode}.\",\n  unsigned int, (unsigned int regno, machine_mode mode),"}]}