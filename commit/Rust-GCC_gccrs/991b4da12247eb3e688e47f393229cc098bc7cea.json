{"sha": "991b4da12247eb3e688e47f393229cc098bc7cea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkxYjRkYTEyMjQ3ZWIzZTY4OGU0N2YzOTMyMjljYzA5OGJjN2NlYQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-04-24T09:28:32Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-04-24T09:28:32Z"}, "message": "re PR fortran/43841 (Missing temporary for ELEMENTAL function call)\n\n2010-04-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43841\n\tPR fortran/43843\n\t* trans-expr.c (gfc_conv_expr): Supply an address expression for\n\tGFC_SS_REFERENCE.\n\t(gfc_conv_expr_reference): Call gfc_conv_expr and return for\n\tGFC_SS_REFERENCE.\n\t* trans-array.c (gfc_add_loop_ss_code): Store the value rather\n\tthan the address of a GFC_SS_REFERENCE.\n\t* trans.h : Change comment on GFC_SS_REFERENCE. \n\n2010-04-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43841\n\tPR fortran/43843\n\t* gfortran.dg/elemental_scalar_args_1.f90 : New test.\n\nFrom-SVN: r158683", "tree": {"sha": "f478c03fe05157ce3c385681dcb888a51104ffd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f478c03fe05157ce3c385681dcb888a51104ffd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/991b4da12247eb3e688e47f393229cc098bc7cea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991b4da12247eb3e688e47f393229cc098bc7cea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/991b4da12247eb3e688e47f393229cc098bc7cea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991b4da12247eb3e688e47f393229cc098bc7cea/comments", "author": null, "committer": null, "parents": [{"sha": "7b65808d33edf19143af6d0f272cf126f87ca147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b65808d33edf19143af6d0f272cf126f87ca147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b65808d33edf19143af6d0f272cf126f87ca147"}], "stats": {"total": 123, "additions": 116, "deletions": 7}, "files": [{"sha": "6072c0562f28399909649a138f3ea3702250ab4f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=991b4da12247eb3e688e47f393229cc098bc7cea", "patch": "@@ -1,3 +1,15 @@\n+2010-04-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43841\n+\tPR fortran/43843\n+\t* trans-expr.c (gfc_conv_expr): Supply an address expression for\n+\tGFC_SS_REFERENCE.\n+\t(gfc_conv_expr_reference): Call gfc_conv_expr and return for\n+\tGFC_SS_REFERENCE.\n+\t* trans-array.c (gfc_add_loop_ss_code): Store the value rather\n+\tthan the address of a GFC_SS_REFERENCE.\n+\t* trans.h : Change comment on GFC_SS_REFERENCE. \n+\n 2010-04-22  Richard Guenther  <rguenther@suse.de>\n \n \tPR fortran/43829"}, {"sha": "c3a92bc320eb7d6412cdb94fa677b40f85762ab6", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=991b4da12247eb3e688e47f393229cc098bc7cea", "patch": "@@ -2054,9 +2054,10 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  break;\n \n \tcase GFC_SS_REFERENCE:\n-\t  /* Scalar reference.  Evaluate this now.  */\n+\t  /* Scalar argument to elemental procedure.  Evaluate this\n+\t     now.  */\n \t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr_reference (&se, ss->expr);\n+\t  gfc_conv_expr (&se, ss->expr);\n \t  gfc_add_block_to_block (&loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&loop->post, &se.post);\n "}, {"sha": "dc138a37b9642d9142ff6782192b93b649abf29f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=991b4da12247eb3e688e47f393229cc098bc7cea", "patch": "@@ -4541,6 +4541,8 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n       /* Substitute a scalar expression evaluated outside the scalarization\n          loop.  */\n       se->expr = se->ss->data.scalar.expr;\n+      if (se->ss->type == GFC_SS_REFERENCE)\n+\tse->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n       se->string_length = se->ss->string_length;\n       gfc_advance_se_ss_chain (se);\n       return;\n@@ -4661,9 +4663,9 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n   if (se->ss && se->ss->expr == expr\n       && se->ss->type == GFC_SS_REFERENCE)\n     {\n-      se->expr = se->ss->data.scalar.expr;\n-      se->string_length = se->ss->string_length;\n-      gfc_advance_se_ss_chain (se);\n+      /* Returns a reference to the scalar evaluated outside the loop\n+\t for this case.  */\n+      gfc_conv_expr (se, expr);\n       return;\n     }\n "}, {"sha": "b332c8e0446f0db176473a848553e0d442c5c481", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=991b4da12247eb3e688e47f393229cc098bc7cea", "patch": "@@ -126,8 +126,9 @@ typedef enum\n      scalarization loop.  */\n   GFC_SS_SCALAR,\n \n-  /* Like GFC_SS_SCALAR except it evaluates a pointer to the expression.\n-     Used for elemental function parameters.  */\n+  /* Like GFC_SS_SCALAR it evaluates the expression outside the\n+     loop. Is always evaluated as a reference to the temporary.\n+     Used for elemental function arguments.  */\n   GFC_SS_REFERENCE,\n \n   /* An array section.  Scalarization indices will be substituted during"}, {"sha": "d4331be406109363845af2a6bfd2b1b2144c2476", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=991b4da12247eb3e688e47f393229cc098bc7cea", "patch": "@@ -1,3 +1,9 @@\n+2010-04-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43841\n+\tPR fortran/43843\n+\t* gfortran.dg/elemental_scalar_args_1.f90 : New test.\n+\n 2010-04-23  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* gcc.dg/Wconversion-integer.c: Update."}, {"sha": "d180bc931d293e2349ca1e61fc99e068e4e71897", "filename": "gcc/testsuite/gfortran.dg/elemental_scalar_args_1.f90", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_scalar_args_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991b4da12247eb3e688e47f393229cc098bc7cea/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_scalar_args_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_scalar_args_1.f90?ref=991b4da12247eb3e688e47f393229cc098bc7cea", "patch": "@@ -0,0 +1,87 @@\n+! { dg-do compile }\n+! Test the fix for PR43843, in which the temporary for b(1) in\n+! test_member was an indirect reference, rather then the value.\n+!\n+! Contributed by Kyle Horne <horne.kyle@gmail.com>\n+! Reported by Tobias Burnus <burnus@gcc.gno.org>\n+! Reported by Harald Anlauf <anlauf@gmx.de> (PR43841)\n+!\n+module polar_mod\n+  implicit none\n+  complex, parameter :: i = (0.0,1.0)\n+  real, parameter :: pi = 3.14159265359\n+  real, parameter :: e = exp (1.0)\n+  type :: polar_t\n+    real :: l, th\n+  end type\n+  type(polar_t) :: one = polar_t (1.0, 0)\n+  interface operator(/)\n+    module procedure div_pp\n+  end interface\n+  interface operator(.ne.)\n+    module procedure ne_pp\n+  end interface\n+contains\n+  elemental function div_pp(u,v) result(o)\n+    type(polar_t), intent(in) :: u, v\n+    type(polar_t) :: o\n+    complex :: a, b, c\n+    a = u%l*exp (i*u%th*pi)\n+    b = v%l*exp (i*v%th*pi)\n+    c = a/b\n+    o%l = abs (c)\n+    o%th = atan2 (imag (c), real (c))/pi\n+  end function div_pp\n+  elemental function ne_pp(u,v) result(o)\n+    type(polar_t), intent(in) :: u, v\n+    LOGICAL :: o\n+    if (u%l .ne. v%l) then\n+      o = .true.\n+    else if (u%th .ne. v%th) then\n+      o = .true.\n+    else\n+      o = .false.\n+    end if\n+  end function ne_pp\n+end module polar_mod\n+\n+program main\n+  use polar_mod\n+  implicit none\n+  call test_member\n+  call test_other\n+  call test_scalar\n+  call test_real\n+contains\n+  subroutine test_member\n+    type(polar_t), dimension(3) :: b\n+    b = polar_t (2.0,0.5)\n+    b(:) = b(:)/b(1)\n+    if (any (b .ne. one)) call abort   \n+  end subroutine test_member\n+  subroutine test_other\n+    type(polar_t), dimension(3) :: b\n+    type(polar_t), dimension(3) :: c\n+    b = polar_t (3.0,1.0)\n+    c = polar_t (3.0,1.0)\n+    b(:) = b(:)/c(1)\n+    if (any (b .ne. one)) call abort   \n+  end subroutine test_other\n+  subroutine test_scalar\n+    type(polar_t), dimension(3) :: b\n+    type(polar_t) :: c\n+    b = polar_t (4.0,1.5)\n+    c = b(1)\n+    b(:) = b(:)/c\n+    if (any (b .ne. one)) call abort   \n+  end subroutine test_scalar\n+  subroutine test_real\n+    real,dimension(3) :: b\n+    real :: real_one\n+    b = 2.0\n+    real_one = b(2)/b(1)\n+    b(:) = b(:)/b(1)\n+    if (any (b .ne. real_one)) call abort   \n+  end subroutine test_real\n+end program main\n+! { dg-final { cleanup-modules \"polar_mod\" } }"}]}