{"sha": "d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmZjRlM2YxMTA2M2FjYzM2MzE4ZjBjN2E2ZGQ5NjQzNjc5YzkyZg==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2003-07-25T05:32:23Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2003-07-25T05:32:23Z"}, "message": "char_traits.h (class char_traits): Put all the real work into the new class template __gnu_cxx::char_traits.\n\n\n\t* /include/bits/char_traits.h (class char_traits): Put all the\n\treal work into the new class template __gnu_cxx::char_traits.\n\tGave generic definitions for member functions.  Types are taken\n\tfrom the new class template __gnu_cxx::_Char_types.\n\t* testsuite/21_strings/char_traits/requirements/short/1.cc: New\n\tfile.  Test of std::char_traits<short>, which serves as a test of\n\tthe char_traits primary template.\n\nFrom-SVN: r69772", "tree": {"sha": "daafc5fbd41b3216271b3bd59a964e539d218bd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daafc5fbd41b3216271b3bd59a964e539d218bd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ff4e3f11063acc36318f0c7a6dd9643679c92f/comments", "author": null, "committer": null, "parents": [{"sha": "b3179b0d5148aabc9635eee8759e8057518cef83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3179b0d5148aabc9635eee8759e8057518cef83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3179b0d5148aabc9635eee8759e8057518cef83"}], "stats": {"total": 373, "additions": 336, "deletions": 37}, "files": [{"sha": "f2925d0e65e98122ac9f439500a21f4a3b0d2b4f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5ff4e3f11063acc36318f0c7a6dd9643679c92f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5ff4e3f11063acc36318f0c7a6dd9643679c92f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "patch": "@@ -1,3 +1,13 @@\n+2003-07-24  Matt Austern  <austern@apple.com>\n+\n+\t* /include/bits/char_traits.h (class char_traits): Put all the\n+\treal work into the new class template __gnu_cxx::char_traits.\n+\tGave generic definitions for member functions.  Types are taken\n+\tfrom the new class template __gnu_cxx::_Char_types.\n+\t* testsuite/21_strings/char_traits/requirements/short/1.cc: New\n+\tfile.  Test of std::char_traits<short>, which serves as a test of\n+\tthe char_traits primary template.\n+\n 2003-07-24  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/*: Change __gnu_cxx_test to __gnu_test."}, {"sha": "23b69f32bfd5191cd6e6cded5ca4e72133133f38", "filename": "libstdc++-v3/include/bits/char_traits.h", "status": "modified", "additions": 154, "deletions": 37, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5ff4e3f11063acc36318f0c7a6dd9643679c92f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5ff4e3f11063acc36318f0c7a6dd9643679c92f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h?ref=d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "patch": "@@ -43,83 +43,200 @@\n #pragma GCC system_header\n \n #include <cstring>            // For memmove, memset, memchr\n+#include <bits/stl_algobase.h>// For copy, lexicographical_compare, fill_n\n #include <bits/fpos.h>        // For streampos\n \n-namespace std \n+namespace __gnu_cxx\n {\n-  // 21.1\n+\n   /**\n-   *  @brief  Basis for explicit traits specializations.\n+   *  @brief  Mapping from character type to associated types.\n+   * \n    *\n-   *  @note  For any given actual character type, this definition is\n-   *  probably wrong.\n+   *  @note This is an implementation class for the generic version\n+   *  of char_traits.  It defines int_type, off_type, pos_type, and\n+   *  state_type.  By default these are unsigned long, streamoff,\n+   *  streampos, and mbstate_t.  Users who need a different set of \n+   *  types, but who don't need to change the definitions of any function\n+   *  defined in char_traits, can specialize __gnu_cxx::_Char_types\n+   *  while leaving __gnu_cxx::char_traits alone. */\n+  template <class _CharT>\n+    struct _Char_types\n+    {\n+      typedef unsigned long   int_type;\n+      typedef std::streampos  pos_type;\n+      typedef std::streamoff  off_type;\n+      typedef std::mbstate_t  state_type;\n+    };\n+\n+\n+  /**\n+   *  @brief  Base class used to implement std::char_traits.\n+   *\n+   *  @note For any given actual character type, this definition is\n+   *  probably wrong.  (Most of the member functions are likely to be\n+   *  right, but the int_type and state_type typedefs, and the eof()\n+   *  member function, are likely to be wrong.)  The reason this class\n+   *  exists is so users can specialize it.  Classes in namespace std\n+   *  may not be specialized for fundamentl types, but classes in\n+   *  namespace __gnu_cxx may be.\n    *\n    *  See http://gcc.gnu.org/onlinedocs/libstdc++/21_strings/howto.html#5\n    *  for advice on how to make use of this class for \"unusual\" character\n-   *  types. Also, check out include/ext/pod_char_traits.h.\n-  */\n-  template<class _CharT>\n+   *  types. Also, check out include/ext/pod_char_traits.h.  */\n+  template<typename _CharT>\n     struct char_traits\n     {\n-      typedef _CharT \t\tchar_type;\n-      typedef unsigned long  \tint_type;\n-      typedef streampos \tpos_type;\n-      typedef streamoff \toff_type;\n-      typedef mbstate_t \tstate_type;\n+      typedef _CharT                                    char_type;\n+      typedef typename _Char_types<_CharT>::int_type    int_type;\n+      typedef typename _Char_types<_CharT>::pos_type    pos_type;\n+      typedef typename _Char_types<_CharT>::off_type    off_type;\n+      typedef typename _Char_types<_CharT>::state_type  state_type;\n       \n       static void \n-      assign(char_type& __c1, const char_type& __c2);\n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n \n       static bool \n-      eq(const char_type& __c1, const char_type& __c2);\n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n \n       static bool \n-      lt(const char_type& __c1, const char_type& __c2);\n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n \n       static int \n-      compare(const char_type* __s1, const char_type* __s2, size_t __n);\n+      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);\n \n-      static size_t\n+      static std::size_t\n       length(const char_type* __s);\n \n       static const char_type* \n-      find(const char_type* __s, size_t __n, const char_type& __a);\n+      find(const char_type* __s, std::size_t __n, const char_type& __a);\n \n       static char_type* \n-      move(char_type* __s1, const char_type* __s2, size_t __n);\n+      move(char_type* __s1, const char_type* __s2, std::size_t __n);\n \n       static char_type* \n-      copy(char_type* __s1, const char_type* __s2, size_t __n);\n+      copy(char_type* __s1, const char_type* __s2, std::size_t __n);\n \n       static char_type* \n-      assign(char_type* __s, size_t __n, char_type __a);\n+      assign(char_type* __s, std::size_t __n, char_type __a);\n \n       static char_type \n-      to_char_type(const int_type& __c);\n+      to_char_type(const int_type& __c)\n+      { return static_cast<char_type>(__c); }\n \n       static int_type \n-      to_int_type(const char_type& __c);\n+      to_int_type(const char_type& __c)\n+      { return static_cast<int_type>(__c); }\n \n       static bool \n-      eq_int_type(const int_type& __c1, const int_type& __c2);\n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n \n       static int_type \n-      eof(); \n+      eof()\n+      { return static_cast<int_type>(EOF); }\n \n       static int_type \n-      not_eof(const int_type& __c);\n+      not_eof(const int_type& __c)\n+      { return !eq_int_type(__c, eof()) ? __c : char_type(); }\n     };\n \n+  template<typename _CharT>\n+    int\n+    char_traits<_CharT>::\n+    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)\n+    {\n+      for (size_t __i = 0; __i < __n; ++__i)\n+\tif (lt(__s1[__i], __s2[__i]))\n+\t  return -1;\n+\telse if (lt(__s2[__i], __s1[__i]))\n+\t  return 1;\n+      return 0;\n+    }\n+\n+  template<typename _CharT>\n+    std::size_t\n+    char_traits<_CharT>::\n+    length(const char_type* __p)\n+    {\n+      std::size_t __i = 0;\n+      while (!eq(__p[__i], char_type()))\n+        ++__i;\n+      return __i;\n+    }\n+\n+  template<typename _CharT>\n+    const typename char_traits<_CharT>::char_type* \n+    char_traits<_CharT>::\n+    find(const char_type* __s, std::size_t __n, const char_type& __a)\n+    {\n+      for (std::size_t __i = 0; __i < __n; ++__i)\n+        if (eq(__s[__i], __a))\n+          return __s + __i;\n+      return 0;\n+    }\n+\n+  template<typename _CharT>\n+    typename char_traits<_CharT>::char_type*\n+    char_traits<_CharT>::\n+    move(char_type* __s1, const char_type* __s2, std::size_t __n)\n+    {\n+      return static_cast<_CharT*>(std::memmove(__s1, __s2,\n+\t\t\t\t\t       __n * sizeof(char_type)));\n+    }\n+\n+  template<typename _CharT>\n+    typename char_traits<_CharT>::char_type* \n+    char_traits<_CharT>::\n+    copy(char_type* __s1, const char_type* __s2, std::size_t __n)\n+    {\n+      std::copy(__s2, __s2 + __n, __s1);\n+      return __s1;\n+    }\n+\n+  template<typename _CharT>\n+    typename char_traits<_CharT>::char_type* \n+    char_traits<_CharT>::\n+    assign(char_type* __s, std::size_t __n, char_type __a)\n+    {\n+      std::fill_n(__s, __n, __a);\n+      return __s;\n+    }\n+}\n+\n+namespace std \n+{\n+  // 21.1\n+  /**\n+   *  @brief  Basis for explicit traits specializations.\n+   *\n+   *  @note  For any given actual character type, this definition is\n+   *  probably wrong.  Since this is just a thin wrapper around\n+   *  __gnu_cxx::char_traits, it is possible to achieve a more\n+   *  appropriate definition by specializing __gnu_cxx::char_traits.\n+   *\n+   *  See http://gcc.gnu.org/onlinedocs/libstdc++/21_strings/howto.html#5\n+   *  for advice on how to make use of this class for \"unusual\" character\n+   *  types. Also, check out include/ext/pod_char_traits.h.\n+  */\n+  template<class _CharT>\n+    struct char_traits\n+      : public __gnu_cxx::char_traits<_CharT>\n+    { };\n+\n \n   /// 21.1.3.1  char_traits specializations\n   template<>\n     struct char_traits<char>\n     {\n-      typedef char \t\tchar_type;\n-      typedef int \t        int_type;\n-      typedef streampos \tpos_type;\n-      typedef streamoff \toff_type;\n-      typedef mbstate_t \tstate_type;\n+      typedef char              char_type;\n+      typedef int               int_type;\n+      typedef streampos         pos_type;\n+      typedef streamoff         off_type;\n+      typedef mbstate_t         state_type;\n \n       static void \n       assign(char_type& __c1, const char_type& __c2)\n@@ -185,11 +302,11 @@ namespace std\n   template<>\n     struct char_traits<wchar_t>\n     {\n-      typedef wchar_t \t\tchar_type;\n-      typedef wint_t \t\tint_type;\n-      typedef streamoff \toff_type;\n-      typedef wstreampos \tpos_type;\n-      typedef mbstate_t \tstate_type;\n+      typedef wchar_t           char_type;\n+      typedef wint_t            int_type;\n+      typedef streamoff         off_type;\n+      typedef wstreampos        pos_type;\n+      typedef mbstate_t         state_type;\n       \n       static void \n       assign(char_type& __c1, const char_type& __c2)"}, {"sha": "4a61942efc7a5cc729bc56078bf177c7544b0e75", "filename": "libstdc++-v3/testsuite/21_strings/char_traits/requirements/short/1.cc", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5ff4e3f11063acc36318f0c7a6dd9643679c92f/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fchar_traits%2Frequirements%2Fshort%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5ff4e3f11063acc36318f0c7a6dd9643679c92f/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fchar_traits%2Frequirements%2Fshort%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fchar_traits%2Frequirements%2Fshort%2F1.cc?ref=d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "patch": "@@ -0,0 +1,172 @@\n+// 1999-06-03 bkoz\n+// 2003-07-22 Matt Austern\n+\n+// Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 21.1.1 Character traits requirements\n+// Make sure we can instantiate char_traits and basic_string for\n+// charT = 'short', and make sure the char_traits memeber functions\n+// satisfy the requirements of 21.1.1.\n+\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void test02(void)\n+{\n+  bool test = true;\n+ \n+  // 21.1.1 character traits requirements\n+\n+  // Key for decoding what function signatures really mean:\n+  // X                == char_traits<_CharT>\n+  // [c,d]    == _CharT\n+  // [p,q]    == const _CharT*\n+  // s                == _CharT*\n+  // [n,i,j]  == size_t\n+  // f                == X::int_type\n+  // pos      == X::pos_type\n+  // state    == X::state_type\n+\n+  // void X::assign(short c, short d)\n+  // assigns c = d;\n+  short c1 = 'z';\n+  short c2 = 'u';\n+  VERIFY( c1 != c2 );\n+  std::char_traits<short>::assign(c1,c2);\n+  VERIFY( c1 == 'u' );\n+\n+  // bool X::eq(short c, short d)\n+  c1 = 'z';\n+  c2 = 'u';\n+  VERIFY ( !std::char_traits<short>::eq(c1, c2) );\n+  VERIFY ( std::char_traits<short>::eq(c1, c1) );\n+  VERIFY ( std::char_traits<short>::eq(c2, c2) );\n+\n+  // bool X::lt(short c, short d)\n+  c1 = 'z';\n+  c2 = 'u';\n+  VERIFY ( std::char_traits<short>::lt(c2, c1) );\n+  VERIFY ( !std::char_traits<short>::lt(c1, c2) );\n+  VERIFY ( !std::char_traits<short>::lt(c1, c1) );\n+  VERIFY ( !std::char_traits<short>::lt(c2, c2) );\n+\n+  // short* X::move(short* s, const short* p, size_t n)\n+  // for each i in [0,n) performs X::assign(s[i], p[i]). Copies\n+  // correctly even where p is in [s, s + n), and yields s.   \n+  short array1[] = {'z', 'u', 'm', 'a', ' ', 'b', 'e', 'a', 'c', 'h',  0};\n+  const std::basic_string<short> str_01(array1 + 0, array1 + 10);\n+\n+  const short str_lit1[] = {'m', 'o', 'n', 't', 'a', 'r', 'a', ' ', 'a', 'n', 'd', ' ', 'o', 'c', 'e', 'a', 'n', ' ', 'b', 'e', 'a', 'c', 'h', 0};\n+\n+  int len = sizeof(str_lit1)/sizeof(short) + sizeof(array1)/sizeof(short) - 1;\n+  // two terminating chars\n+  short array2[len];\n+\n+  VERIFY( str_lit1[0] == 'm' );\n+  c1 = array2[0];\n+  c2 = str_lit1[0];\n+  short c3 = array2[1];\n+  short c4 = str_lit1[1];\n+  std::char_traits<short>::move(array2, str_lit1, 0);\n+  VERIFY( array2[0] == c1 );\n+  VERIFY( str_lit1[0] == c2 );\n+  std::char_traits<short>::move(array2, str_lit1, 1);\n+  VERIFY( array2[0] == c2 );\n+  VERIFY( str_lit1[0] == c2 );\n+  VERIFY( array2[1] == c3 );\n+  VERIFY( str_lit1[1] == c4 );\n+  std::char_traits<short>::move(array2, str_lit1, 2);\n+  VERIFY( array2[0] == c2 );\n+  VERIFY( str_lit1[0] == c2 );\n+  VERIFY( array2[1] == c4 );\n+  VERIFY( str_lit1[1] == c4 );\n+ \n+  short* pc1 = array1 + 1;\n+  c1 = pc1[0];\n+  c2 = array1[0];\n+  VERIFY( c1 != c2 );\n+  short* pc2 = std::char_traits<short>::move(array1, pc1, 0);\n+  c3 = pc1[0];\n+  c4 = array1[0];\n+  VERIFY( c1 == c3 );\n+  VERIFY( c2 == c4 );\n+  VERIFY( pc2 == array1 );\n+\n+  c1 = pc1[0];\n+  c2 = array1[0];\n+  short* pc3 = pc1;\n+  pc2 = std::char_traits<short>::move(array1, pc1, 10);\n+  c3 = pc1[0];\n+  c4 = array1[0];\n+  VERIFY( c1 != c3 ); // underlying short array changed.\n+  VERIFY( c4 != c3 );\n+  VERIFY( pc2 == array1 );\n+  VERIFY( pc3 == pc1 ); // but pointers o-tay\n+  c1 = *(str_01.data());\n+  c2 = array1[0];\n+  VERIFY( c1 != c2 );\n+\n+  // size_t X::length(const short* p)\n+  len = std::char_traits<short>::length(str_lit1);\n+  VERIFY( len == sizeof(str_lit1) / sizeof(short) - 1 );\n+\n+  // const short* X::find(const short* s, size_t n, short c)\n+  const int N4 = sizeof(str_lit1) / sizeof(short);\n+  const short* pc4 = std::char_traits<short>::find(str_lit1, N4, 'a');\n+  VERIFY( pc4 != 0 );\n+  VERIFY( *pc4 == 'a' );\n+\n+  pc4 = std::char_traits<short>::find(str_lit1, N4, 0x0a73);\n+  VERIFY( pc4 == 0 );\n+\n+  // short* X::assign(short* s, size_t n, short c)\n+  len = sizeof(array2) / sizeof(short);\n+  memset(array2, 0xaf, len * sizeof(short));\n+  VERIFY( array2[0] != 0x15a8 );\n+\n+  pc1 = std::char_traits<short>::assign (array2, len, 0x15a8);\n+  VERIFY( pc1 == array2 );\n+  for (int i = 0; i < len; ++i)\n+    VERIFY( array2[i] == 0x15a8 );\n+\n+  // short* X::copy(short* s, const short* p, size_t n)\n+  int n1 = sizeof(str_lit1) / sizeof(short);\n+  pc1 = std::char_traits<short>::copy(array2, str_lit1, n1);\n+  len = std::char_traits<short>::length(array2);\n+  VERIFY( len == n1 - 1 );\n+  for (int i = 0; i < len; ++i)\n+    VERIFY( str_lit1[i] == array2[i] );\n+\n+  // int X::compare(const short* p, const short* q, size_t n)\n+  const short* pconst1 = str_01.data();\n+  const short* pconst2 = str_lit1;\n+\n+  VERIFY( std::char_traits<short>::compare(pconst1, pconst2, 10) > 0 );\n+  VERIFY( std::char_traits<short>::compare(pconst2, pconst1, 10) < 0 );\n+  VERIFY( std::char_traits<short>::compare(pconst1, pconst1, 10) == 0 );\n+  VERIFY( std::char_traits<short>::compare(pconst2, pconst2, 10) == 0 );\n+}\n+\n+\n+\n+int main()\n+{ \n+  test02();\n+  return 0;\n+}"}]}