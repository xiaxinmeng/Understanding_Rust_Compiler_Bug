{"sha": "80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAyOThjM2I0NjQwMGE4ZjI0YmUzNWRkZjkxNjljY2MxOGU1Y2Y5Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-13T10:20:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-13T10:20:53Z"}, "message": "[multiple changes]\n\n2014-06-13  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference, case Pred/Succ): Change\n\treason to Overflow.\n\n2014-06-13  Robert Dewar  <dewar@adacore.com>\n\n\t* makeutl.adb: Minor reformatting.\n\n2014-06-13  Gail Schenker  <schenker@adacore.com>\n\n\t* debug.adb, sem_eval.adb (Why_Not_Static): Remove temporary code and\n\tassociated flag (d.z), no longer needed.\n\n2014-06-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): For Import and\n\tExport aspects, do not check whether a corresponding Convention\n\taspect has been specified. Convention is optional in Ada2012,\n\tand defaults to Convention_Ada.\n\nFrom-SVN: r211624", "tree": {"sha": "d0113c6bb07ea51e9404e924779d8e78843f1eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0113c6bb07ea51e9404e924779d8e78843f1eae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/comments", "author": null, "committer": null, "parents": [{"sha": "0083dd669163646b53f80d35dc3c57e403ba7637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0083dd669163646b53f80d35dc3c57e403ba7637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0083dd669163646b53f80d35dc3c57e403ba7637"}], "stats": {"total": 466, "additions": 192, "deletions": 274}, "files": [{"sha": "5023f979520e936b4a85b5cf4e187c0936303f4e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "patch": "@@ -1,3 +1,24 @@\n+2014-06-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference, case Pred/Succ): Change\n+\treason to Overflow.\n+\n+2014-06-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* makeutl.adb: Minor reformatting.\n+\n+2014-06-13  Gail Schenker  <schenker@adacore.com>\n+\n+\t* debug.adb, sem_eval.adb (Why_Not_Static): Remove temporary code and\n+\tassociated flag (d.z), no longer needed.\n+\n+2014-06-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): For Import and\n+\tExport aspects, do not check whether a corresponding Convention\n+\taspect has been specified. Convention is optional in Ada2012,\n+\tand defaults to Convention_Ada.\n+\n 2014-06-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* checks.adb (Apply_Address_Clause_Check): Only issue the new"}, {"sha": "e54b631d2416144a27d57922b5fd3373f43eb066", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "patch": "@@ -116,7 +116,7 @@ package body Debug is\n    --  d.w  Do not check for infinite loops\n    --  d.x  No exception handlers\n    --  d.y\n-   --  d.z  Temporary ASIS kludge for why non-static messages\n+   --  d.z\n \n    --  d.A  Read/write Aspect_Specifications hash table to tree\n    --  d.B\n@@ -599,11 +599,6 @@ package body Debug is\n    --       fully compiled and analyzed, they just get eliminated from the\n    --       code generation step.\n \n-   --  d.z  Temporary debug switch for control of the why non-static messages\n-   --       generated by Why_Non_Static. Normally these messages are suppressed\n-   --       in ASIS mode (d2), but if d.z is set they are not suppressed. This\n-   --       is a temporary switch to aid in updating ASIS base lines.\n-\n    --  d.A  There seems to be a problem with ASIS if we activate the circuit\n    --       for reading and writing the aspect specification hash table, so\n    --       for now, this is controlled by the debug flag d.A. The hash table"}, {"sha": "58c4126d0d1958a9840c46a5c340906c6ec9d9a5", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "patch": "@@ -4536,7 +4536,7 @@ package body Exp_Attr is\n                               Attribute_Name => Name_First,\n                               Prefix         =>\n                                 New_Occurrence_Of (Base_Type (Ptyp), Loc))),\n-                      Reason => CE_Range_Check_Failed),\n+                      Reason => CE_Overflow_Check_Failed),\n                   Suppress => All_Checks);\n                end if;\n             end;\n@@ -5611,7 +5611,7 @@ package body Exp_Attr is\n                               Attribute_Name => Name_Last,\n                               Prefix         =>\n                                 New_Occurrence_Of (Base_Type (Ptyp), Loc))),\n-                      Reason    => CE_Range_Check_Failed),\n+                      Reason    => CE_Overflow_Check_Failed),\n                     Suppress => All_Checks);\n                end if;\n             end;"}, {"sha": "4518959780611d28d416443fba19ea7a3f69aa13", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "patch": "@@ -309,10 +309,10 @@ package body Makeutl is\n                      if Replacement /= No_File then\n                         if Verbose_Mode then\n                            Write_Line\n-                             (\"source file\" &\n-                              Get_Name_String (SD.Sfile) &\n-                              \" has been replaced by \" &\n-                              Get_Name_String (Replacement));\n+                             (\"source file\"\n+                              & Get_Name_String (SD.Sfile)\n+                              & \" has been replaced by \"\n+                              & Get_Name_String (Replacement));\n                         end if;\n \n                         return No_Name;\n@@ -648,21 +648,21 @@ package body Makeutl is\n                         if Sw (J) = Directory_Separator then\n                            Switch :=\n                              new String'\n-                               (Sw (1 .. Start - 1) &\n-                                Parent &\n-                                Directory_Separator &\n-                                Sw (Start .. Sw'Last));\n+                               (Sw (1 .. Start - 1)\n+                                & Parent\n+                                & Directory_Separator\n+                                & Sw (Start .. Sw'Last));\n                            return;\n                         end if;\n                      end loop;\n \n                   else\n                      Switch :=\n                        new String'\n-                         (Sw (1 .. Start - 1) &\n-                          Parent &\n-                          Directory_Separator &\n-                          Sw (Start .. Sw'Last));\n+                         (Sw (1 .. Start - 1)\n+                          & Parent\n+                          & Directory_Separator\n+                          & Sw (Start .. Sw'Last));\n                   end if;\n                end if;\n \n@@ -1999,8 +1999,8 @@ package body Makeutl is\n                      if Project.Library then\n                         Fail_Program\n                           (Tree,\n-                           \"cannot specify a main program \" &\n-                           \"for a library project file\");\n+                           \"cannot specify a main program \"\n+                           & \"for a library project file\");\n                      end if;\n \n                      Add_Main (Name     => Get_Name_String (Element.Value),\n@@ -2118,8 +2118,8 @@ package body Makeutl is\n             if Names.Last = 0 then\n                Fail_Program\n                  (Project_Tree,\n-                  \"cannot specify a multi-unit index but no main \" &\n-                  \"on the command line\");\n+                  \"cannot specify a multi-unit index but no main \"\n+                  & \"on the command line\");\n \n             elsif Names.Last > 1 then\n                Fail_Program\n@@ -3153,10 +3153,10 @@ package body Makeutl is\n          if Current_Verbosity = High then\n             Debug_Output (\"compilation phases: \"\n                           & \" compile=\" & Data.Need_Compilation'Img\n-                          & \" bind=\" & Data.Need_Binding'Img\n-                          & \" link=\" & Data.Need_Linking'Img\n+                          & \" bind=\"    & Data.Need_Binding'Img\n+                          & \" link=\"    & Data.Need_Linking'Img\n                           & \" closure=\" & Data.Closure_Needed'Img\n-                          & \" mains=\" & Data.Number_Of_Mains'Img,\n+                          & \" mains=\"   & Data.Number_Of_Mains'Img,\n                           Project.Name);\n          end if;\n       end Do_Compute;\n@@ -3313,13 +3313,12 @@ package body Makeutl is\n          then\n             Prj.Err.Error_Msg\n               (Env.Flags,\n-               \"Default_Switches forbidden in presence of \" &\n-               \"Global_Compilation_Switches. Use Switches instead.\",\n+               \"Default_Switches forbidden in presence of \"\n+               & \"Global_Compilation_Switches. Use Switches instead.\",\n                Project_Tree.Shared.Arrays.Table\n                  (Default_Switches_Array).Location);\n             Fail_Program\n-              (Project_Tree,\n-               \"*** illegal combination of Builder attributes\");\n+              (Project_Tree, \"*** illegal combination of Builder attributes\");\n          end if;\n \n          if Lang /= No_Name then\n@@ -3433,14 +3432,14 @@ package body Makeutl is\n \n                      Prj.Err.Error_Msg\n                        (Env.Flags,\n-                        '\"' & Name_Buffer (1 .. Name_Len) &\n-                        \"\"\" is not a builder switch. Consider moving \" &\n-                        \"it to Global_Compilation_Switches.\",\n+                        '\"' & Name_Buffer (1 .. Name_Len)\n+                        & \"\"\" is not a builder switch. Consider moving \"\n+                        & \"it to Global_Compilation_Switches.\",\n                         Element.Location);\n                      Fail_Program\n                        (Project_Tree,\n-                        \"*** illegal switch \"\"\" &\n-                        Get_Name_String (Element.Value) & '\"');\n+                        \"*** illegal switch \"\"\"\n+                        & Get_Name_String (Element.Value) & '\"');\n                   end if;\n                end if;\n "}, {"sha": "47bdff0386bae3b1fc71458870bca58a27b06369", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 6, "deletions": 44, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "patch": "@@ -2704,50 +2704,12 @@ package body Sem_Ch13 is\n                         Set_Never_Set_In_Source (E, False);\n                      end if;\n \n-                     --  Verify that there is an aspect Convention that will\n-                     --  incorporate the Import/Export aspect, and eventual\n-                     --  Link/External names.\n-\n-                     declare\n-                        A : Node_Id;\n-\n-                     begin\n-                        A := First (L);\n-                        while Present (A) loop\n-                           exit when Chars (Identifier (A)) = Name_Convention;\n-                           Next (A);\n-                        end loop;\n-\n-                        --  It is legal to specify Import for a variable, in\n-                        --  order to suppress initialization for it, without\n-                        --  specifying explicitly its convention. However this\n-                        --  is only legal if the convention of the object type\n-                        --  is Ada or similar.\n-\n-                        if No (A) then\n-                           if Ekind (E) = E_Variable\n-                             and then A_Id = Aspect_Import\n-                           then\n-                              declare\n-                                 C : constant Convention_Id :=\n-                                       Convention (Etype (E));\n-                              begin\n-                                 if C = Convention_Ada              or else\n-                                    C = Convention_Ada_Pass_By_Copy or else\n-                                    C = Convention_Ada_Pass_By_Reference\n-                                 then\n-                                    goto Continue;\n-                                 end if;\n-                              end;\n-                           end if;\n-\n-                           --  Otherwise, Convention must be specified\n-\n-                           Error_Msg_N\n-                             (\"missing Convention aspect for Export/Import\",\n-                              Aspect);\n-                        end if;\n-                     end;\n+                     --  In older versions of Ada the corresponding pragmas\n+                     --  specified a Convention. In Ada 2012 the convention\n+                     --  is specified as a separate aspect, and it is optional,\n+                     --  given that it defaults to Convention_Ada. The code\n+                     --  that verifed that there was a matching convention\n+                     --  is now obsolete.\n \n                      goto Continue;\n                   end if;"}, {"sha": "27eab6e2d19142e2731f22fa2c38c111a862453a", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 135, "deletions": 194, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80298c3b46400a8f24be35ddf9169ccc18e5cf9b/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "patch": "@@ -102,7 +102,7 @@ package body Sem_Eval is\n    type Bits is array (Nat range <>) of Boolean;\n    --  Used to convert unsigned (modular) values for folding logical ops\n \n-   --  The following definitions are used to maintain a cache of nodes that\n+   --  The following declarations are used to maintain a cache of nodes that\n    --  have compile time known values. The cache is maintained only for\n    --  discrete types (the most common case), and is populated by calls to\n    --  Compile_Time_Known_Value and Expr_Value, but only used by Expr_Value\n@@ -138,43 +138,43 @@ package body Sem_Eval is\n    -----------------------\n \n    function From_Bits (B : Bits; T : Entity_Id) return Uint;\n-   --  Converts a bit string of length B'Length to a Uint value to be used\n-   --  for a target of type T, which is a modular type. This procedure\n-   --  includes the necessary reduction by the modulus in the case of a\n-   --  non-binary modulus (for a binary modulus, the bit string is the\n-   --  right length any way so all is well).\n+   --  Converts a bit string of length B'Length to a Uint value to be used for\n+   --  a target of type T, which is a modular type. This procedure includes the\n+   --  necessary reduction by the modulus in the case of a non-binary modulus\n+   --  (for a binary modulus, the bit string is the right length any way so all\n+   --  is well).\n \n    function Get_String_Val (N : Node_Id) return Node_Id;\n-   --  Given a tree node for a folded string or character value, returns\n-   --  the corresponding string literal or character literal (one of the\n-   --  two must be available, or the operand would not have been marked\n-   --  as foldable in the earlier analysis of the operation).\n+   --  Given a tree node for a folded string or character value, returns the\n+   --  corresponding string literal or character literal (one of the two must\n+   --  be available, or the operand would not have been marked as foldable in\n+   --  the earlier analysis of the operation).\n \n    function OK_Bits (N : Node_Id; Bits : Uint) return Boolean;\n    --  Bits represents the number of bits in an integer value to be computed\n    --  (but the value has not been computed yet). If this value in Bits is\n-   --  reasonable, a result of True is returned, with the implication that\n-   --  the caller should go ahead and complete the calculation. If the value\n-   --  in Bits is unreasonably large, then an error is posted on node N, and\n+   --  reasonable, a result of True is returned, with the implication that the\n+   --  caller should go ahead and complete the calculation. If the value in\n+   --  Bits is unreasonably large, then an error is posted on node N, and\n    --  False is returned (and the caller skips the proposed calculation).\n \n    procedure Out_Of_Range (N : Node_Id);\n-   --  This procedure is called if it is determined that node N, which\n-   --  appears in a non-static context, is a compile time known value\n-   --  which is outside its range, i.e. the range of Etype. This is used\n-   --  in contexts where this is an illegality if N is static, and should\n-   --  generate a warning otherwise.\n+   --  This procedure is called if it is determined that node N, which appears\n+   --  in a non-static context, is a compile time known value which is outside\n+   --  its range, i.e. the range of Etype. This is used in contexts where\n+   --  this is an illegality if N is static, and should generate a warning\n+   --  otherwise.\n \n    procedure Rewrite_In_Raise_CE (N : Node_Id; Exp : Node_Id);\n-   --  N and Exp are nodes representing an expression, Exp is known\n-   --  to raise CE. N is rewritten in term of Exp in the optimal way.\n+   --  N and Exp are nodes representing an expression, Exp is known to raise\n+   --  CE. N is rewritten in term of Exp in the optimal way.\n \n    function String_Type_Len (Stype : Entity_Id) return Uint;\n-   --  Given a string type, determines the length of the index type, or,\n-   --  if this index type is non-static, the length of the base type of\n-   --  this index type. Note that if the string type is itself static,\n-   --  then the index type is static, so the second case applies only\n-   --  if the string type passed is non-static.\n+   --  Given a string type, determines the length of the index type, or, if\n+   --  this index type is non-static, the length of the base type of this index\n+   --  type. Note that if the string type is itself static, then the index type\n+   --  is static, so the second case applies only if the string type passed is\n+   --  non-static.\n \n    function Test (Cond : Boolean) return Uint;\n    pragma Inline (Test);\n@@ -184,13 +184,12 @@ package body Sem_Eval is\n    --  logical operators\n \n    function Find_Universal_Operator_Type (N : Node_Id) return Entity_Id;\n-   --  Check whether an arithmetic operation with universal operands which\n-   --  is a rewritten function call with an explicit scope indication is\n-   --  ambiguous: P.\"+\" (1, 2) will be ambiguous if there is more than one\n-   --  visible numeric type declared in P and the context does not impose a\n-   --  type on the result (e.g. in the expression of a type conversion).\n-   --  If ambiguous, emit an error and return Empty, else return the result\n-   --  type of the operator.\n+   --  Check whether an arithmetic operation with universal operands which is a\n+   --  rewritten function call with an explicit scope indication is ambiguous:\n+   --  P.\"+\" (1, 2) will be ambiguous if there is more than one visible numeric\n+   --  type declared in P and the context does not impose a type on the result\n+   --  (e.g. in the expression of a type conversion). If ambiguous, emit an\n+   --  error and return Empty, else return the result type of the operator.\n \n    procedure Test_Expression_Is_Foldable\n      (N    : Node_Id;\n@@ -199,29 +198,29 @@ package body Sem_Eval is\n       Fold : out Boolean);\n    --  Tests to see if expression N whose single operand is Op1 is foldable,\n    --  i.e. the operand value is known at compile time. If the operation is\n-   --  foldable, then Fold is True on return, and Stat indicates whether\n-   --  the result is static (i.e. the operand was static). Note that it\n-   --  is quite possible for Fold to be True, and Stat to be False, since\n-   --  there are cases in which we know the value of an operand even though\n-   --  it is not technically static (e.g. the static lower bound of a range\n-   --  whose upper bound is non-static).\n+   --  foldable, then Fold is True on return, and Stat indicates whether the\n+   --  result is static (i.e. the operand was static). Note that it is quite\n+   --  possible for Fold to be True, and Stat to be False, since there are\n+   --  cases in which we know the value of an operand even though it is not\n+   --  technically static (e.g. the static lower bound of a range whose upper\n+   --  bound is non-static).\n    --\n-   --  If Stat is set False on return, then Test_Expression_Is_Foldable makes a\n-   --  call to Check_Non_Static_Context on the operand. If Fold is False on\n-   --  return, then all processing is complete, and the caller should\n-   --  return, since there is nothing else to do.\n+   --  If Stat is set False on return, then Test_Expression_Is_Foldable makes\n+   --  a call to Check_Non_Static_Context on the operand. If Fold is False on\n+   --  return, then all processing is complete, and the caller should return,\n+   --  since there is nothing else to do.\n    --\n    --  If Stat is set True on return, then Is_Static_Expression is also set\n    --  true in node N. There are some cases where this is over-enthusiastic,\n-   --  e.g. in the two operand case below, for string comparison, the result\n-   --  is not static even though the two operands are static. In such cases,\n-   --  the caller must reset the Is_Static_Expression flag in N.\n+   --  e.g. in the two operand case below, for string comparison, the result is\n+   --  not static even though the two operands are static. In such cases, the\n+   --  caller must reset the Is_Static_Expression flag in N.\n    --\n    --  If Fold and Stat are both set to False then this routine performs also\n    --  the following extra actions:\n    --\n-   --    If either operand is Any_Type then propagate it to result to\n-   --    prevent cascaded errors.\n+   --    If either operand is Any_Type then propagate it to result to prevent\n+   --    cascaded errors.\n    --\n    --    If some operand raises constraint error, then replace the node N\n    --    with the raise constraint error node. This replacement inherits the\n@@ -278,8 +277,8 @@ package body Sem_Eval is\n       end if;\n \n       --  At this stage we have a scalar type. If we have an expression that\n-      --  raises CE, then we already issued a warning or error msg so there\n-      --  is nothing more to be done in this routine.\n+      --  raises CE, then we already issued a warning or error msg so there is\n+      --  nothing more to be done in this routine.\n \n       if Raises_Constraint_Error (N) then\n          return;\n@@ -370,7 +369,7 @@ package body Sem_Eval is\n         and then Nkind (Parent (N)) in N_Subexpr\n         and then\n           (Intval (N) < Expr_Value (Type_Low_Bound (Universal_Integer))\n-            or else\n+             or else\n            Intval (N) > Expr_Value (Type_High_Bound (Universal_Integer)))\n       then\n          Apply_Compile_Time_Constraint_Error\n@@ -387,9 +386,7 @@ package body Sem_Eval is\n       --  appears in a range that could be null (warnings are handled elsewhere\n       --  for this case).\n \n-      elsif T /= Base_Type (T)\n-        and then Nkind (Parent (N)) /= N_Range\n-      then\n+      elsif T /= Base_Type (T) and then Nkind (Parent (N)) /= N_Range then\n          if Is_In_Range (N, T, Assume_Valid => True) then\n             null;\n \n@@ -413,8 +410,7 @@ package body Sem_Eval is\n    procedure Check_String_Literal_Length (N : Node_Id; Ttype : Entity_Id) is\n    begin\n       if not Raises_Constraint_Error (N) and then Is_Constrained (Ttype) then\n-         if\n-           UI_From_Int (String_Length (Strval (N))) /= String_Type_Len (Ttype)\n+         if UI_From_Int (String_Length (Strval (N))) /= String_Type_Len (Ttype)\n          then\n             Apply_Compile_Time_Constraint_Error\n               (N, \"string length wrong for}??\",\n@@ -550,9 +546,9 @@ package body Sem_Eval is\n                Xtyp := Designated_Type (Xtyp);\n             end if;\n \n-            --  If we don't have an array type at this stage, something\n-            --  is peculiar, e.g. another error, and we abandon the attempt\n-            --  at a fixup.\n+            --  If we don't have an array type at this stage, something is\n+            --  peculiar, e.g. another error, and we abandon the attempt at\n+            --  a fixup.\n \n             if not Is_Array_Type (Xtyp) then\n                return N;\n@@ -567,11 +563,11 @@ package body Sem_Eval is\n             if Ekind (Xtyp) = E_String_Literal_Subtype then\n                if Attribute_Name (N) = Name_First then\n                   return String_Literal_Low_Bound (Xtyp);\n-\n                else\n-                  return Make_Integer_Literal (Sloc (N),\n-                    Intval => Intval (String_Literal_Low_Bound (Xtyp))\n-                                + String_Literal_Length (Xtyp));\n+                  return\n+                    Make_Integer_Literal (Sloc (N),\n+                      Intval => Intval (String_Literal_Low_Bound (Xtyp)) +\n+                                          String_Literal_Length (Xtyp));\n                end if;\n             end if;\n \n@@ -611,7 +607,7 @@ package body Sem_Eval is\n                       or else Ekind (Entity (Opnd)) = E_In_Parameter\n                       or else\n                         (Ekind (Entity (Opnd)) in Object_Kind\n-                           and then Present (Current_Value (Entity (Opnd))))))\n+                          and then Present (Current_Value (Entity (Opnd))))))\n            or else Is_OK_Static_Expression (Opnd);\n       end Is_Known_Valid_Operand;\n \n@@ -814,7 +810,8 @@ package body Sem_Eval is\n       --  Case where comparison involves two compile time known values\n \n       elsif Compile_Time_Known_Value (L)\n-        and then Compile_Time_Known_Value (R)\n+              and then\n+            Compile_Time_Known_Value (R)\n       then\n          --  For the floating-point case, we have to be a little careful, since\n          --  at compile time we are dealing with universal exact values, but at\n@@ -828,7 +825,6 @@ package body Sem_Eval is\n             declare\n                Lo : constant Ureal := Expr_Value_R (L);\n                Hi : constant Ureal := Expr_Value_R (R);\n-\n             begin\n                if Lo < Hi then\n                   return LE;\n@@ -880,15 +876,12 @@ package body Sem_Eval is\n             declare\n                Lo : constant Uint := Expr_Value (L);\n                Hi : constant Uint := Expr_Value (R);\n-\n             begin\n                if Lo < Hi then\n                   Diff.all := Hi - Lo;\n                   return LT;\n-\n                elsif Lo = Hi then\n                   return EQ;\n-\n                else\n                   Diff.all := Lo - Hi;\n                   return GT;\n@@ -902,7 +895,8 @@ package body Sem_Eval is\n          --  Remaining checks apply only for discrete types\n \n          if not Is_Discrete_Type (Ltyp)\n-           or else not Is_Discrete_Type (Rtyp)\n+              or else\n+            not Is_Discrete_Type (Rtyp)\n          then\n             return Unknown;\n          end if;\n@@ -933,9 +927,9 @@ package body Sem_Eval is\n             return Unknown;\n          end if;\n \n-         --  Replace types by base types for the case of entities which are\n-         --  not known to have valid representations. This takes care of\n-         --  properly dealing with invalid representations.\n+         --  Replace types by base types for the case of entities which are not\n+         --  known to have valid representations. This takes care of properly\n+         --  dealing with invalid representations.\n \n          if not Assume_Valid and then not Assume_No_Invalid_Values then\n             if Is_Entity_Name (L) and then not Is_Known_Valid (Entity (L)) then\n@@ -977,11 +971,9 @@ package body Sem_Eval is\n             if Is_Same_Value (Lnode, Rnode) then\n                if Loffs = Roffs then\n                   return EQ;\n-\n                elsif Loffs < Roffs then\n                   Diff.all := Roffs - Loffs;\n                   return LT;\n-\n                else\n                   Diff.all := Loffs - Roffs;\n                   return GT;\n@@ -1072,9 +1064,9 @@ package body Sem_Eval is\n \n          if not Rec then\n \n-            --  See if we can get a decisive check against one operand and\n-            --  a bound of the other operand (four possible tests here).\n-            --  Note that we avoid testing junk bounds of a generic type.\n+            --  See if we can get a decisive check against one operand and a\n+            --  bound of the other operand (four possible tests here). Note\n+            --  that we avoid testing junk bounds of a generic type.\n \n             if not Is_Generic_Type (Rtyp) then\n                case Compile_Time_Compare (L, Type_Low_Bound (Rtyp),\n@@ -1351,13 +1343,10 @@ package body Sem_Eval is\n          --  Other literals and NULL are known at compile time\n \n          elsif\n-            K = N_Character_Literal\n-              or else\n-            K = N_Real_Literal\n-              or else\n-            K = N_String_Literal\n-              or else\n-            K = N_Null\n+            Nkind_In (K, N_Character_Literal,\n+                         N_Real_Literal,\n+                         N_String_Literal,\n+                         N_Null)\n          then\n             return True;\n \n@@ -1422,15 +1411,14 @@ package body Sem_Eval is\n             if Present (Expressions (Op)) then\n                declare\n                   Expr : Node_Id;\n-\n                begin\n                   Expr := First (Expressions (Op));\n                   while Present (Expr) loop\n                      if not Compile_Time_Known_Value_Or_Aggr (Expr) then\n                         return False;\n+                     else\n+                        Next (Expr);\n                      end if;\n-\n-                     Next (Expr);\n                   end loop;\n                end;\n             end if;\n@@ -1502,7 +1490,6 @@ package body Sem_Eval is\n \n    procedure Eval_Allocator (N : Node_Id) is\n       Expr : constant Node_Id := Expression (N);\n-\n    begin\n       if Nkind (Expr) = N_Qualified_Expression then\n          Check_Non_Static_Context (Expression (Expr));\n@@ -1553,7 +1540,6 @@ package body Sem_Eval is\n \n          begin\n             case Nkind (N) is\n-\n                when N_Op_Add =>\n                   Result := Left_Int + Right_Int;\n \n@@ -1577,8 +1563,7 @@ package body Sem_Eval is\n \n                   if Right_Int = 0 then\n                      Apply_Compile_Time_Constraint_Error\n-                       (N, \"division by zero\",\n-                        CE_Divide_By_Zero,\n+                       (N, \"division by zero\", CE_Divide_By_Zero,\n                         Warn => not Stat);\n                      return;\n \n@@ -1593,8 +1578,7 @@ package body Sem_Eval is\n \n                   if Right_Int = 0 then\n                      Apply_Compile_Time_Constraint_Error\n-                       (N, \"mod with zero divisor\",\n-                        CE_Divide_By_Zero,\n+                       (N, \"mod with zero divisor\", CE_Divide_By_Zero,\n                         Warn => not Stat);\n                      return;\n                   else\n@@ -1608,8 +1592,7 @@ package body Sem_Eval is\n \n                   if Right_Int = 0 then\n                      Apply_Compile_Time_Constraint_Error\n-                       (N, \"rem with zero divisor\",\n-                        CE_Divide_By_Zero,\n+                       (N, \"rem with zero divisor\", CE_Divide_By_Zero,\n                         Warn => not Stat);\n                      return;\n \n@@ -1776,7 +1759,6 @@ package body Sem_Eval is\n \n       if Is_Static_Expression (Expression (N)) then\n          Val := Expr_Value (Expression (N));\n-\n       else\n          Check_Non_Static_Context (Expression (N));\n          Is_Static := False;\n@@ -2246,11 +2228,11 @@ package body Sem_Eval is\n          --  but those have bounds smaller that those of any integer base type,\n          --  so we can safely ignore these cases.\n \n-         return    K = N_Number_Declaration\n-           or else K = N_Attribute_Reference\n-           or else K = N_Attribute_Definition_Clause\n-           or else K = N_Modular_Type_Definition\n-           or else K = N_Signed_Integer_Type_Definition;\n+         return Nkind_In (K, N_Number_Declaration,\n+                             N_Attribute_Reference,\n+                             N_Attribute_Definition_Clause,\n+                             N_Modular_Type_Definition,\n+                             N_Signed_Integer_Type_Definition);\n       end In_Any_Integer_Context;\n \n    --  Start of processing for Eval_Integer_Literal\n@@ -2422,7 +2404,6 @@ package body Sem_Eval is\n          if not Is_String_Type (Def_Id) then\n             Lo := Type_Low_Bound (Def_Id);\n             Hi := Type_High_Bound (Def_Id);\n-\n          else\n             Lo := Empty;\n             Hi := Empty;\n@@ -2480,7 +2461,6 @@ package body Sem_Eval is\n       elsif Is_Real_Type (Etype (Right)) then\n          declare\n             Leftval : constant Ureal := Expr_Value_R (Left);\n-\n          begin\n             Result := Expr_Value_R (Lo) <= Leftval\n                         and then Leftval <= Expr_Value_R (Hi);\n@@ -2489,7 +2469,6 @@ package body Sem_Eval is\n       else\n          declare\n             Leftval : constant Uint := Expr_Value (Left);\n-\n          begin\n             Result := Expr_Value (Lo) <= Leftval\n                         and then Leftval <= Expr_Value (Hi);\n@@ -2573,8 +2552,7 @@ package body Sem_Eval is\n \n                if Right_Int < 0 then\n                   Apply_Compile_Time_Constraint_Error\n-                    (N, \"integer exponent negative\",\n-                     CE_Range_Check_Failed,\n+                    (N, \"integer exponent negative\", CE_Range_Check_Failed,\n                      Warn => not Stat);\n                   return;\n \n@@ -2606,8 +2584,7 @@ package body Sem_Eval is\n \n                   if Right_Int < 0 then\n                      Apply_Compile_Time_Constraint_Error\n-                       (N, \"zero ** negative integer\",\n-                        CE_Range_Check_Failed,\n+                       (N, \"zero ** negative integer\", CE_Range_Check_Failed,\n                         Warn => not Stat);\n                      return;\n                   else\n@@ -2657,9 +2634,7 @@ package body Sem_Eval is\n \n          if Is_Modular_Integer_Type (Typ) then\n             Fold_Uint (N, Modulus (Typ) - 1 - Rint, Stat);\n-\n-         else\n-            pragma Assert (Is_Boolean_Type (Typ));\n+         else pragma Assert (Is_Boolean_Type (Typ));\n             Fold_Uint (N, Test (not Is_True (Rint)), Stat);\n          end if;\n \n@@ -2812,7 +2787,8 @@ package body Sem_Eval is\n         and then (Nkind (N) = N_Op_Eq or else Nkind (N) = N_Op_Ne)\n       then\n          if Raises_Constraint_Error (Left)\n-           or else Raises_Constraint_Error (Right)\n+              or else\n+            Raises_Constraint_Error (Right)\n          then\n             return;\n          end if;\n@@ -2854,10 +2830,8 @@ package body Sem_Eval is\n                --  The simple case, both bounds are known at compile time\n \n                if Is_Discrete_Type (T)\n-                 and then\n-                   Compile_Time_Known_Value (Type_Low_Bound (T))\n-                 and then\n-                   Compile_Time_Known_Value (Type_High_Bound (T))\n+                 and then Compile_Time_Known_Value (Type_Low_Bound (T))\n+                 and then Compile_Time_Known_Value (Type_High_Bound (T))\n                then\n                   Len := UI_Max (Uint_0,\n                                  Expr_Value (Type_High_Bound (T)) -\n@@ -2879,11 +2853,11 @@ package body Sem_Eval is\n                      Ent  : out Entity_Id;\n                      Kind : out Character;\n                      Cons : out Uint);\n-                  --  Given an expression, see if is of the form above,\n-                  --  X [+/- K]. If so Ent is set to the entity in X,\n-                  --  Kind is 'F','L','E' for 'First/'Last/simple entity,\n-                  --  and Cons is the value of K. If the expression is\n-                  --  not of the required form, Ent is set to Empty.\n+                  --  Given an expression see if it is of the form given above,\n+                  --  X [+/- K]. If so Ent is set to the entity in X, Kind is\n+                  --  'F','L','E' for 'First/'Last/simple entity, and Cons is\n+                  --  the value of K. If the expression is not of the required\n+                  --  form, Ent is set to Empty.\n \n                   --------------------\n                   -- Decompose_Expr --\n@@ -2940,10 +2914,8 @@ package body Sem_Eval is\n                      if Nkind (Exp) = N_Attribute_Reference then\n                         if Attribute_Name (Exp) = Name_First then\n                            Kind := 'F';\n-\n                         elsif Attribute_Name (Exp) = Name_Last then\n                            Kind := 'L';\n-\n                         else\n                            Ent := Empty;\n                            return;\n@@ -2955,8 +2927,7 @@ package body Sem_Eval is\n                         Kind := 'E';\n                      end if;\n \n-                     if Is_Entity_Name (Exp)\n-                       and then Present (Entity (Exp))\n+                     if Is_Entity_Name (Exp) and then Present (Entity (Exp))\n                      then\n                         Ent := Entity (Exp);\n                      else\n@@ -3013,7 +2984,8 @@ package body Sem_Eval is\n \n       declare\n          Is_Static_Expression : Boolean;\n-         Is_Foldable          : Boolean;\n+\n+         Is_Foldable : Boolean;\n          pragma Unreferenced (Is_Foldable);\n \n       begin\n@@ -3287,6 +3259,7 @@ package body Sem_Eval is\n \n    procedure Eval_Slice (N : Node_Id) is\n       Drange : constant Node_Id := Discrete_Range (N);\n+\n    begin\n       if Nkind (Drange) = N_Range then\n          Check_Non_Static_Context (Low_Bound (Drange));\n@@ -3301,6 +3274,7 @@ package body Sem_Eval is\n          declare\n             E : constant Entity_Id := Entity (Prefix (N));\n             T : constant Entity_Id := Etype (E);\n+\n          begin\n             if Ekind (E) = E_Constant\n               and then Is_Array_Type (T)\n@@ -3345,10 +3319,11 @@ package body Sem_Eval is\n       --  membership test can be evaluated statically. The caller transforms\n       --  a result of False into a static contraint error.\n \n-      Test := Make_In (Loc,\n-         Left_Opnd    => New_Copy_Tree (N),\n-         Right_Opnd   => Empty,\n-         Alternatives => Pred);\n+      Test :=\n+        Make_In (Loc,\n+          Left_Opnd    => New_Copy_Tree (N),\n+          Right_Opnd   => Empty,\n+          Alternatives => Pred);\n       Analyze_And_Resolve (Test, Standard_Boolean);\n \n       return Nkind (Test) = N_Identifier\n@@ -3389,7 +3364,7 @@ package body Sem_Eval is\n       --  but may be possible in future).\n \n       elsif not Is_OK_Static_Expression\n-                    (Type_Low_Bound (Etype (First_Index (Typ))))\n+                  (Type_Low_Bound (Etype (First_Index (Typ))))\n       then\n          Set_Is_Static_Expression (N, False);\n          return;\n@@ -3534,7 +3509,6 @@ package body Sem_Eval is\n       if not Is_Static_Subtype (Target_Type) then\n          Check_Non_Static_Context (Operand);\n          return;\n-\n       elsif Error_Posted (N) then\n          return;\n       end if;\n@@ -3561,7 +3535,6 @@ package body Sem_Eval is\n \n       if Is_String_Type (Target_Type) then\n          Fold_Str (N, Strval (Get_String_Val (Operand)), Static => False);\n-\n          return;\n \n       --  Fold conversion, case of integer target type\n@@ -3698,10 +3671,8 @@ package body Sem_Eval is\n          begin\n             if Nkind (N) = N_Op_Plus then\n                Result := Rreal;\n-\n             elsif Nkind (N) = N_Op_Minus then\n                Result := UR_Negate (Rreal);\n-\n             else\n                pragma Assert (Nkind (N) = N_Op_Abs);\n                Result := abs Rreal;\n@@ -3848,7 +3819,6 @@ package body Sem_Eval is\n       --  obtain the desired value from Corresponding_Integer_Value.\n \n       elsif Kind = N_Real_Literal then\n-\n          pragma Assert (Is_Fixed_Point_Type (Underlying_Type (Etype (N))));\n          Val := Corresponding_Integer_Value (N);\n \n@@ -3891,7 +3861,6 @@ package body Sem_Eval is\n \n    function Expr_Value_E (N : Node_Id) return Entity_Id is\n       Ent  : constant Entity_Id := Entity (N);\n-\n    begin\n       if Ekind (Ent) = E_Enumeration_Literal then\n          return Ent;\n@@ -4046,10 +4015,9 @@ package body Sem_Eval is\n               and then Nkind (Parent (E)) /= N_Subtype_Declaration\n               and then Comes_From_Source (E)\n               and then Is_Integer_Type (E) = Is_Int\n-              and then\n-                (Nkind (N) in N_Unary_Op\n-                  or else Is_Relational\n-                  or else Is_Fixed_Point_Type (E) = Is_Fix)\n+              and then (Nkind (N) in N_Unary_Op\n+                         or else Is_Relational\n+                         or else Is_Fixed_Point_Type (E) = Is_Fix)\n             then\n                if No (Typ1) then\n                   Typ1 := E;\n@@ -4141,9 +4109,7 @@ package body Sem_Eval is\n       --  If we are folding a named number, retain the entity in the literal,\n       --  for ASIS use.\n \n-      if Is_Entity_Name (N)\n-        and then Ekind (Entity (N)) = E_Named_Integer\n-      then\n+      if Is_Entity_Name (N) and then Ekind (Entity (N)) = E_Named_Integer then\n          Ent := Entity (N);\n       else\n          Ent := Empty;\n@@ -4160,7 +4126,6 @@ package body Sem_Eval is\n \n       if Is_Integer_Type (Typ) then\n          Rewrite (N, Make_Integer_Literal (Loc, Val));\n-\n          Set_Original_Entity (N, Ent);\n \n       --  Otherwise we have an enumeration type, and we substitute either\n@@ -4201,9 +4166,7 @@ package body Sem_Eval is\n       --  If we are folding a named number, retain the entity in the literal,\n       --  for ASIS use.\n \n-      if Is_Entity_Name (N)\n-        and then Ekind (Entity (N)) = E_Named_Real\n-      then\n+      if Is_Entity_Name (N) and then Ekind (Entity (N)) = E_Named_Real then\n          Ent := Entity (N);\n       else\n          Ent := Empty;\n@@ -4258,12 +4221,8 @@ package body Sem_Eval is\n \n    function Get_String_Val (N : Node_Id) return Node_Id is\n    begin\n-      if Nkind (N) = N_String_Literal then\n-         return N;\n-\n-      elsif Nkind (N) = N_Character_Literal then\n+      if Nkind_In (N, N_String_Literal, N_Character_Literal) then\n          return N;\n-\n       else\n          pragma Assert (Is_Entity_Name (N));\n          return Get_String_Val (Constant_Value (Entity (N)));\n@@ -4402,8 +4361,8 @@ package body Sem_Eval is\n       Int_Real     : Boolean := False) return Boolean\n    is\n    begin\n-      return Test_In_Range (N, Typ, Assume_Valid, Fixed_Int, Int_Real)\n-               = In_Range;\n+      return\n+        Test_In_Range (N, Typ, Assume_Valid, Fixed_Int, Int_Real) = In_Range;\n    end Is_In_Range;\n \n    -------------------\n@@ -4422,9 +4381,7 @@ package body Sem_Eval is\n \n       if Is_Discrete_Type (Typ) then\n          return Expr_Value (Lo) > Expr_Value (Hi);\n-\n-      else\n-         pragma Assert (Is_Real_Type (Typ));\n+      else pragma Assert (Is_Real_Type (Typ));\n          return Expr_Value_R (Lo) > Expr_Value_R (Hi);\n       end if;\n    end Is_Null_Range;\n@@ -4435,8 +4392,7 @@ package body Sem_Eval is\n \n    function Is_OK_Static_Expression (N : Node_Id) return Boolean is\n    begin\n-      return Is_Static_Expression (N)\n-        and then not Raises_Constraint_Error (N);\n+      return Is_Static_Expression (N) and then not Raises_Constraint_Error (N);\n    end Is_OK_Static_Expression;\n \n    ------------------------\n@@ -4528,8 +4484,8 @@ package body Sem_Eval is\n       Int_Real     : Boolean := False) return Boolean\n    is\n    begin\n-      return Test_In_Range (N, Typ, Assume_Valid, Fixed_Int, Int_Real)\n-               = Out_Of_Range;\n+      return Test_In_Range (N, Typ, Assume_Valid, Fixed_Int, Int_Real) =\n+                                                               Out_Of_Range;\n    end Is_Out_Of_Range;\n \n    ---------------------\n@@ -4544,7 +4500,8 @@ package body Sem_Eval is\n    function Is_Static_Range (N : Node_Id) return Boolean is\n    begin\n       return Is_Static_Expression (Low_Bound (N))\n-        and then Is_Static_Expression (High_Bound (N));\n+               and then\n+             Is_Static_Expression (High_Bound (N));\n    end Is_Static_Range;\n \n    -----------------------\n@@ -4620,10 +4577,7 @@ package body Sem_Eval is\n \n       if Is_Discrete_Type (Typ) then\n          return Expr_Value (Lo) <= Expr_Value (Hi);\n-\n-      else\n-         pragma Assert (Is_Real_Type (Typ));\n-\n+      else pragma Assert (Is_Real_Type (Typ));\n          return Expr_Value_R (Lo) <= Expr_Value_R (Hi);\n       end if;\n    end Not_Null_Range;\n@@ -4639,6 +4593,8 @@ package body Sem_Eval is\n       if Bits < 500_000 then\n          return True;\n \n+      --  Error if this maximum is exceeded\n+\n       else\n          Error_Msg_N (\"static value too large, capacity exceeded\", N);\n          return False;\n@@ -5104,8 +5060,7 @@ package body Sem_Eval is\n       --  checking on an inherited operation may compare the actual with the\n       --  subtype that renames it in the instance.\n \n-      elsif\n-         Has_Unknown_Discriminants (T1) /= Has_Unknown_Discriminants (T2)\n+      elsif Has_Unknown_Discriminants (T1) /= Has_Unknown_Discriminants (T2)\n       then\n          return\n            Is_Generic_Actual_Type (T1) or else Is_Generic_Actual_Type (T2);\n@@ -5257,7 +5212,8 @@ package body Sem_Eval is\n       CRT_Safe : Boolean := False)\n    is\n       Rstat : constant Boolean := Is_Static_Expression (Op1)\n-                                    and then Is_Static_Expression (Op2);\n+                                    and then\n+                                  Is_Static_Expression (Op2);\n \n    begin\n       Stat := False;\n@@ -5435,9 +5391,7 @@ package body Sem_Eval is\n                Val := Expr_Value (N);\n \n                if LB_Known and HB_Known then\n-                  if Val >= Expr_Value (Lo)\n-                       and then\n-                     Val <= Expr_Value (Hi)\n+                  if Val >= Expr_Value (Lo) and then Val <= Expr_Value (Hi)\n                   then\n                      return In_Range;\n                   else\n@@ -5501,15 +5455,6 @@ package body Sem_Eval is\n    --  Start of processing for Why_Not_Static\n \n    begin\n-      --  If in ACATS mode (debug flag 2), then suppress all these messages,\n-      --  this avoids massive updates to the ACATS base line. But if the flag\n-      --  d.z is set, then don't suppress the messages. This is a temporary\n-      --  kludge to aid in doing the necessary updates to the ACATS base line.\n-\n-      if Debug_Flag_2 and then not Debug_Flag_Dot_Z then\n-         return;\n-      end if;\n-\n       --  Ignore call on error or empty node\n \n       if No (Expr) or else Nkind (Expr) = N_Error then\n@@ -5530,8 +5475,8 @@ package body Sem_Eval is\n \n          if Raises_Constraint_Error (Expr) then\n             Error_Msg_N\n-              (\"!expression raises exception, cannot be static \" &\n-               \"(RM 4.9(34))\", N);\n+              (\"!expression raises exception, cannot be static (RM 4.9(34))\",\n+               N);\n             return;\n          end if;\n \n@@ -5592,6 +5537,7 @@ package body Sem_Eval is\n                      if Nkind (Original_Node (N)) = N_Aggregate then\n                         Error_Msg_Sloc := Sloc (Original_Node (N));\n                         return True;\n+\n                      elsif Is_Entity_Name (N)\n                        and then Ekind (Entity (N)) = E_Constant\n                        and then\n@@ -5601,6 +5547,7 @@ package body Sem_Eval is\n                         Error_Msg_Sloc :=\n                           Sloc (Original_Node (Constant_Value (Entity (N))));\n                         return True;\n+\n                      else\n                         return False;\n                      end if;\n@@ -5635,7 +5582,6 @@ package body Sem_Eval is\n             if Nkind (N) in N_Op_Shift then\n                Error_Msg_N\n                 (\"!shift functions are never static (RM 4.9(6,18))\", N);\n-\n             else\n                Why_Not_Static (Left_Opnd (N));\n                Why_Not_Static (Right_Opnd (N));\n@@ -5667,11 +5613,9 @@ package body Sem_Eval is\n             --  Flag array cases\n \n             elsif Is_Array_Type (E) then\n-               if Attribute_Name (N) /= Name_First\n-                    and then\n-                  Attribute_Name (N) /= Name_Last\n-                    and then\n-                  Attribute_Name (N) /= Name_Length\n+               if not Nam_In (Attribute_Name (N), Name_First,\n+                                                  Name_Last,\n+                                                  Name_Length)\n                then\n                   Error_Msg_N\n                     (\"!static array attribute must be Length, First, or Last \"\n@@ -5690,10 +5634,7 @@ package body Sem_Eval is\n             --  Special case generic types, since again this is a common source\n             --  of confusion.\n \n-            elsif Is_Generic_Actual_Type (E)\n-                    or else\n-                  Is_Generic_Type (E)\n-            then\n+            elsif Is_Generic_Actual_Type (E) or else Is_Generic_Type (E) then\n                Error_Msg_N\n                  (\"!attribute of generic type is never static \"\n                   & \"(RM 4.9(7,8))\", N);"}]}