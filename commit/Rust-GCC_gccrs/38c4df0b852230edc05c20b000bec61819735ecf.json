{"sha": "38c4df0b852230edc05c20b000bec61819735ecf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhjNGRmMGI4NTIyMzBlZGMwNWMyMGIwMDBiZWM2MTgxOTczNWVjZg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2008-09-18T01:09:40Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2008-09-18T01:09:40Z"}, "message": "expr.c (emit_group_store): Do not shift before moving via a stack slot.\n\n\t* expr.c (emit_group_store): Do not shift before moving via a\n\tstack slot.\n\nFrom-SVN: r140442", "tree": {"sha": "c0cfca6716c8f6cbcceac8450b8516d949cd8c34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0cfca6716c8f6cbcceac8450b8516d949cd8c34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38c4df0b852230edc05c20b000bec61819735ecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c4df0b852230edc05c20b000bec61819735ecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c4df0b852230edc05c20b000bec61819735ecf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c4df0b852230edc05c20b000bec61819735ecf/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2acafa84bd7685b95391d143d2b2421b5371c7a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2acafa84bd7685b95391d143d2b2421b5371c7a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2acafa84bd7685b95391d143d2b2421b5371c7a1"}], "stats": {"total": 50, "additions": 30, "deletions": 20}, "files": [{"sha": "81cddbc05fa1eea08799feba2fca412383598152", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c4df0b852230edc05c20b000bec61819735ecf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c4df0b852230edc05c20b000bec61819735ecf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38c4df0b852230edc05c20b000bec61819735ecf", "patch": "@@ -1,3 +1,8 @@\n+2008-09-17  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* expr.c (emit_group_store): Do not shift before moving via a\n+\tstack slot.\n+\n 2008-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* varasm.c (initializer_constant_valid_p): Forbid view-conversions"}, {"sha": "ae0daf0b251fd89a02fa1562af1b4882374dc924", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c4df0b852230edc05c20b000bec61819735ecf/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c4df0b852230edc05c20b000bec61819735ecf/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=38c4df0b852230edc05c20b000bec61819735ecf", "patch": "@@ -2039,33 +2039,17 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n       HOST_WIDE_INT bytepos = INTVAL (XEXP (XVECEXP (src, 0, i), 1));\n       enum machine_mode mode = GET_MODE (tmps[i]);\n       unsigned int bytelen = GET_MODE_SIZE (mode);\n+      unsigned int adj_bytelen = bytelen;\n       rtx dest = dst;\n \n       /* Handle trailing fragments that run over the size of the struct.  */\n       if (ssize >= 0 && bytepos + (HOST_WIDE_INT) bytelen > ssize)\n-\t{\n-\t  /* store_bit_field always takes its value from the lsb.\n-\t     Move the fragment to the lsb if it's not already there.  */\n-\t  if (\n-#ifdef BLOCK_REG_PADDING\n-\t      BLOCK_REG_PADDING (GET_MODE (orig_dst), type, i == start)\n-\t      == (BYTES_BIG_ENDIAN ? upward : downward)\n-#else\n-\t      BYTES_BIG_ENDIAN\n-#endif\n-\t      )\n-\t    {\n-\t      int shift = (bytelen - (ssize - bytepos)) * BITS_PER_UNIT;\n-\t      tmps[i] = expand_shift (RSHIFT_EXPR, mode, tmps[i],\n-\t\t\t\t      build_int_cst (NULL_TREE, shift),\n-\t\t\t\t      tmps[i], 0);\n-\t    }\n-\t  bytelen = ssize - bytepos;\n-\t}\n+\tadj_bytelen = ssize - bytepos;\n \n       if (GET_CODE (dst) == CONCAT)\n \t{\n-\t  if (bytepos + bytelen <= GET_MODE_SIZE (GET_MODE (XEXP (dst, 0))))\n+\t  if (bytepos + adj_bytelen\n+\t      <= GET_MODE_SIZE (GET_MODE (XEXP (dst, 0))))\n \t    dest = XEXP (dst, 0);\n \t  else if (bytepos >= GET_MODE_SIZE (GET_MODE (XEXP (dst, 0))))\n \t    {\n@@ -2103,6 +2087,27 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t    }\n \t}\n \n+      if (ssize >= 0 && bytepos + (HOST_WIDE_INT) bytelen > ssize)\n+\t{\n+\t  /* store_bit_field always takes its value from the lsb.\n+\t     Move the fragment to the lsb if it's not already there.  */\n+\t  if (\n+#ifdef BLOCK_REG_PADDING\n+\t      BLOCK_REG_PADDING (GET_MODE (orig_dst), type, i == start)\n+\t      == (BYTES_BIG_ENDIAN ? upward : downward)\n+#else\n+\t      BYTES_BIG_ENDIAN\n+#endif\n+\t      )\n+\t    {\n+\t      int shift = (bytelen - (ssize - bytepos)) * BITS_PER_UNIT;\n+\t      tmps[i] = expand_shift (RSHIFT_EXPR, mode, tmps[i],\n+\t\t\t\t      build_int_cst (NULL_TREE, shift),\n+\t\t\t\t      tmps[i], 0);\n+\t    }\n+\t  bytelen = adj_bytelen;\n+\t}\n+\n       /* Optimize the access just a bit.  */\n       if (MEM_P (dest)\n \t  && (! SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (dest))"}]}