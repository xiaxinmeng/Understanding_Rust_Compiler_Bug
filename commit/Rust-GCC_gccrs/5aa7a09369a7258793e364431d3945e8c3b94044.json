{"sha": "5aa7a09369a7258793e364431d3945e8c3b94044", "node_id": "C_kwDOANBUbNoAKDVhYTdhMDkzNjlhNzI1ODc5M2UzNjQ0MzFkMzk0NWU4YzNiOTQwNDQ", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-11-09T15:23:55Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-11-09T16:44:05Z"}, "message": "rs6000: Debug support for builtins changes\n\n2021-11-09  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-call.c (rs6000_type_string): New function.\n\t(def_builtin): Change debug formatting for easier parsing and\n\tinclude more information.\n\t(rs6000_init_builtins): Add dump of autogenerated builtins.\n\t(altivec_init_builtins): Dump __builtin_altivec_mask_for_load for\n\tcompleteness.", "tree": {"sha": "722428c254df3bf1b8848981f2dd479ee313ac46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/722428c254df3bf1b8848981f2dd479ee313ac46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5aa7a09369a7258793e364431d3945e8c3b94044", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa7a09369a7258793e364431d3945e8c3b94044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa7a09369a7258793e364431d3945e8c3b94044", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa7a09369a7258793e364431d3945e8c3b94044/comments", "author": null, "committer": null, "parents": [{"sha": "a648acc3b4ce528464ca23ee233de8f320542195", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a648acc3b4ce528464ca23ee233de8f320542195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a648acc3b4ce528464ca23ee233de8f320542195"}], "stats": {"total": 195, "additions": 188, "deletions": 7}, "files": [{"sha": "1c392108314217236023c6bb06b24160019d44cc", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 188, "deletions": 7, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa7a09369a7258793e364431d3945e8c3b94044/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa7a09369a7258793e364431d3945e8c3b94044/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=5aa7a09369a7258793e364431d3945e8c3b94044", "patch": "@@ -8930,7 +8930,105 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   return build_va_arg_indirect_ref (addr);\n }\n \n-/* Builtins.  */\n+/* Debug utility to translate a type node to a single textual token.  */\n+static\n+const char *rs6000_type_string (tree type_node)\n+{\n+  if (type_node == void_type_node)\n+    return \"void\";\n+  else if (type_node == long_integer_type_node)\n+    return \"long\";\n+  else if (type_node == long_unsigned_type_node)\n+    return \"ulong\";\n+  else if (type_node == long_long_integer_type_node)\n+    return \"longlong\";\n+  else if (type_node == long_long_unsigned_type_node)\n+    return \"ulonglong\";\n+  else if (type_node == bool_V2DI_type_node)\n+    return \"vbll\";\n+  else if (type_node == bool_V4SI_type_node)\n+    return \"vbi\";\n+  else if (type_node == bool_V8HI_type_node)\n+    return \"vbs\";\n+  else if (type_node == bool_V16QI_type_node)\n+    return \"vbc\";\n+  else if (type_node == bool_int_type_node)\n+    return \"bool\";\n+  else if (type_node == dfloat64_type_node)\n+    return \"_Decimal64\";\n+  else if (type_node == double_type_node)\n+    return \"double\";\n+  else if (type_node == intDI_type_node)\n+    return \"sll\";\n+  else if (type_node == intHI_type_node)\n+    return \"ss\";\n+  else if (type_node == ibm128_float_type_node)\n+    return \"__ibm128\";\n+  else if (type_node == opaque_V4SI_type_node)\n+    return \"opaque\";\n+  else if (POINTER_TYPE_P (type_node))\n+    return \"void*\";\n+  else if (type_node == intQI_type_node || type_node == char_type_node)\n+    return \"sc\";\n+  else if (type_node == dfloat32_type_node)\n+    return \"_Decimal32\";\n+  else if (type_node == float_type_node)\n+    return \"float\";\n+  else if (type_node == intSI_type_node || type_node == integer_type_node)\n+    return \"si\";\n+  else if (type_node == dfloat128_type_node)\n+    return \"_Decimal128\";\n+  else if (type_node == long_double_type_node)\n+    return \"longdouble\";\n+  else if (type_node == intTI_type_node)\n+    return \"sq\";\n+  else if (type_node == unsigned_intDI_type_node)\n+    return \"ull\";\n+  else if (type_node == unsigned_intHI_type_node)\n+    return \"us\";\n+  else if (type_node == unsigned_intQI_type_node)\n+    return \"uc\";\n+  else if (type_node == unsigned_intSI_type_node)\n+    return \"ui\";\n+  else if (type_node == unsigned_intTI_type_node)\n+    return \"uq\";\n+  else if (type_node == unsigned_V1TI_type_node)\n+    return \"vuq\";\n+  else if (type_node == unsigned_V2DI_type_node)\n+    return \"vull\";\n+  else if (type_node == unsigned_V4SI_type_node)\n+    return \"vui\";\n+  else if (type_node == unsigned_V8HI_type_node)\n+    return \"vus\";\n+  else if (type_node == unsigned_V16QI_type_node)\n+    return \"vuc\";\n+  else if (type_node == V16QI_type_node)\n+    return \"vsc\";\n+  else if (type_node == V1TI_type_node)\n+    return \"vsq\";\n+  else if (type_node == V2DF_type_node)\n+    return \"vd\";\n+  else if (type_node == V2DI_type_node)\n+    return \"vsll\";\n+  else if (type_node == V4SF_type_node)\n+    return \"vf\";\n+  else if (type_node == V4SI_type_node)\n+    return \"vsi\";\n+  else if (type_node == V8HI_type_node)\n+    return \"vss\";\n+  else if (type_node == pixel_V8HI_type_node)\n+    return \"vp\";\n+  else if (type_node == pcvoid_type_node)\n+    return \"voidc*\";\n+  else if (type_node == float128_type_node)\n+    return \"_Float128\";\n+  else if (type_node == vector_pair_type_node)\n+    return \"__vector_pair\";\n+  else if (type_node == vector_quad_type_node)\n+    return \"__vector_quad\";\n+\n+  return \"unknown\";\n+}\n \n static void\n def_builtin (const char *name, tree type, enum rs6000_builtins code)\n@@ -8960,15 +9058,15 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n       /* const function, function only depends on the inputs.  */\n       TREE_READONLY (t) = 1;\n       TREE_NOTHROW (t) = 1;\n-      attr_string = \", const\";\n+      attr_string = \"= const\";\n     }\n   else if ((classify & RS6000_BTC_PURE) != 0)\n     {\n       /* pure function, function can read global memory, but does not set any\n \t external state.  */\n       DECL_PURE_P (t) = 1;\n       TREE_NOTHROW (t) = 1;\n-      attr_string = \", pure\";\n+      attr_string = \"= pure\";\n     }\n   else if ((classify & RS6000_BTC_FP) != 0)\n     {\n@@ -8982,12 +9080,12 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n \t{\n \t  DECL_PURE_P (t) = 1;\n \t  DECL_IS_NOVOPS (t) = 1;\n-\t  attr_string = \", fp, pure\";\n+\t  attr_string = \"= fp, pure\";\n \t}\n       else\n \t{\n \t  TREE_READONLY (t) = 1;\n-\t  attr_string = \", fp, const\";\n+\t  attr_string = \"= fp, const\";\n \t}\n     }\n   else if ((classify & (RS6000_BTC_QUAD | RS6000_BTC_PAIR)) != 0)\n@@ -8997,8 +9095,22 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n     gcc_unreachable ();\n \n   if (TARGET_DEBUG_BUILTIN)\n-    fprintf (stderr, \"rs6000_builtin, code = %4d, %s%s\\n\",\n-\t     (int)code, name, attr_string);\n+    {\n+      tree t = TREE_TYPE (type);\n+      fprintf (stderr, \"%s %s (\", rs6000_type_string (t), name);\n+      t = TYPE_ARG_TYPES (type);\n+      gcc_assert (t);\n+\n+      while (TREE_VALUE (t) != void_type_node)\n+\t{\n+\t  fprintf (stderr, \"%s\", rs6000_type_string (TREE_VALUE (t)));\n+\t  t = TREE_CHAIN (t);\n+\t  gcc_assert (t);\n+\t  if (TREE_VALUE (t) != void_type_node)\n+\t    fprintf (stderr, \", \");\n+\t}\n+      fprintf (stderr, \"); %s [%4d]\\n\", attr_string, (int) code);\n+    }\n }\n \n static const struct builtin_compatibility bdesc_compat[] =\n@@ -16272,6 +16384,67 @@ rs6000_init_builtins (void)\n   /* Execute the autogenerated initialization code for builtins.  */\n   rs6000_init_generated_builtins ();\n \n+  if (TARGET_DEBUG_BUILTIN)\n+    {\n+      fprintf (stderr, \"\\nAutogenerated built-in functions:\\n\\n\");\n+      for (int i = 1; i < (int) RS6000_BIF_MAX; i++)\n+\t{\n+\t  bif_enable e = rs6000_builtin_info_x[i].enable;\n+\t  if (e == ENB_P5 && !TARGET_POPCNTB)\n+\t    continue;\n+\t  if (e == ENB_P6 && !TARGET_CMPB)\n+\t    continue;\n+\t  if (e == ENB_ALTIVEC && !TARGET_ALTIVEC)\n+\t    continue;\n+\t  if (e == ENB_VSX && !TARGET_VSX)\n+\t    continue;\n+\t  if (e == ENB_P7 && !TARGET_POPCNTD)\n+\t    continue;\n+\t  if (e == ENB_P7_64 && !(TARGET_POPCNTD && TARGET_POWERPC64))\n+\t    continue;\n+\t  if (e == ENB_P8 && !TARGET_DIRECT_MOVE)\n+\t    continue;\n+\t  if (e == ENB_P8V && !TARGET_P8_VECTOR)\n+\t    continue;\n+\t  if (e == ENB_P9 && !TARGET_MODULO)\n+\t    continue;\n+\t  if (e == ENB_P9_64 && !(TARGET_MODULO && TARGET_POWERPC64))\n+\t    continue;\n+\t  if (e == ENB_P9V && !TARGET_P9_VECTOR)\n+\t    continue;\n+\t  if (e == ENB_IEEE128_HW && !TARGET_FLOAT128_HW)\n+\t    continue;\n+\t  if (e == ENB_DFP && !TARGET_DFP)\n+\t    continue;\n+\t  if (e == ENB_CRYPTO && !TARGET_CRYPTO)\n+\t    continue;\n+\t  if (e == ENB_HTM && !TARGET_HTM)\n+\t    continue;\n+\t  if (e == ENB_P10 && !TARGET_POWER10)\n+\t    continue;\n+\t  if (e == ENB_P10_64 && !(TARGET_POWER10 && TARGET_POWERPC64))\n+\t    continue;\n+\t  if (e == ENB_MMA && !TARGET_MMA)\n+\t    continue;\n+\t  tree fntype = rs6000_builtin_info_x[i].fntype;\n+\t  tree t = TREE_TYPE (fntype);\n+\t  fprintf (stderr, \"%s %s (\", rs6000_type_string (t),\n+\t\t   rs6000_builtin_info_x[i].bifname);\n+\t  t = TYPE_ARG_TYPES (fntype);\n+\t  while (t && TREE_VALUE (t) != void_type_node)\n+\t    {\n+\t      fprintf (stderr, \"%s\",\n+\t\t       rs6000_type_string (TREE_VALUE (t)));\n+\t      t = TREE_CHAIN (t);\n+\t      if (t && TREE_VALUE (t) != void_type_node)\n+\t\tfprintf (stderr, \", \");\n+\t    }\n+\t  fprintf (stderr, \"); %s [%4d]\\n\",\n+\t\t   rs6000_builtin_info_x[i].attr_string, (int) i);\n+\t}\n+      fprintf (stderr, \"\\nEnd autogenerated built-in functions.\\n\\n\\n\");\n+     }\n+\n   if (new_builtins_are_live)\n     {\n       altivec_builtin_mask_for_load\n@@ -16938,6 +17111,14 @@ altivec_init_builtins (void)\n \t\t\t       ALTIVEC_BUILTIN_MASK_FOR_LOAD,\n \t\t\t       BUILT_IN_MD, NULL, NULL_TREE);\n   TREE_READONLY (decl) = 1;\n+  if (TARGET_DEBUG_BUILTIN)\n+    {\n+      tree arg_type = TREE_VALUE (TYPE_ARG_TYPES (v16qi_ftype_pcvoid));\n+      fprintf (stderr, \"%s __builtin_altivec_mask_for_load (%s); [%4d]\\n\",\n+\t       rs6000_type_string (TREE_TYPE (v16qi_ftype_pcvoid)),\n+\t       rs6000_type_string (arg_type),\n+\t       (int) ALTIVEC_BUILTIN_MASK_FOR_LOAD);\n+    }\n   /* Record the decl. Will be used by rs6000_builtin_mask_for_load.  */\n   altivec_builtin_mask_for_load = decl;\n "}]}