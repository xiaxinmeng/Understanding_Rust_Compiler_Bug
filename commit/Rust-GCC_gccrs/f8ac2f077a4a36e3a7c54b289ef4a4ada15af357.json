{"sha": "f8ac2f077a4a36e3a7c54b289ef4a4ada15af357", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhhYzJmMDc3YTRhMzZlM2E3YzU0YjI4OWVmNGE0YWRhMTVhZjM1Nw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-10-26T10:28:12Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-10-26T10:28:12Z"}, "message": "[optabs.c] Fix PR 67989: Handle const0_rtx target in expand_atomic_compare_and_swap\n\n\tPR middle-end/67989\n\t* optabs.c (expand_atomic_compare_and_swap): Handle case when\n\tptarget_oval or ptarget_bool are const0_rtx.\n\n\t* g++.dg/pr67989.C: New test.\n\nFrom-SVN: r229317", "tree": {"sha": "426eb71f12eed0495b4e17dcb79040d32e2822f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/426eb71f12eed0495b4e17dcb79040d32e2822f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c14315a0de2a70121941f646942a476767fad4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c14315a0de2a70121941f646942a476767fad4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c14315a0de2a70121941f646942a476767fad4e"}], "stats": {"total": 98, "additions": 95, "deletions": 3}, "files": [{"sha": "c115b0da82c88f2fd5f2013115e5b94266d8cddf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8ac2f077a4a36e3a7c54b289ef4a4ada15af357", "patch": "@@ -1,3 +1,9 @@\n+2015-10-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR middle-end/67989\n+\t* optabs.c (expand_atomic_compare_and_swap): Handle case when\n+\tptarget_oval or ptarget_bool are const0_rtx.\n+\n 2015-10-26  Christian Bruel  <christian.bruel@st.com>\n \n \t* function.h (MINIMUM_METHOD_BOUNDARY): New macro."}, {"sha": "4e93d3c745157de4bc00f1e39a35c2fe6a0f1148", "filename": "gcc/optabs.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f8ac2f077a4a36e3a7c54b289ef4a4ada15af357", "patch": "@@ -5810,9 +5810,9 @@ expand_atomic_exchange (rtx target, rtx mem, rtx val, enum memmodel model)\n \n    *PTARGET_BOOL is an optional place to store the boolean success/failure.\n    *PTARGET_OVAL is an optional place to store the old value from memory.\n-   Both target parameters may be NULL to indicate that we do not care about\n-   that return value.  Both target parameters are updated on success to\n-   the actual location of the corresponding result.\n+   Both target parameters may be NULL or const0_rtx to indicate that we do\n+   not care about that return value.  Both target parameters are updated on\n+   success to the actual location of the corresponding result.\n \n    MEMMODEL is the memory model variant to use.\n \n@@ -5837,6 +5837,9 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n   /* Make sure we always have some place to put the return oldval.\n      Further, make sure that place is distinct from the input expected,\n      just in case we need that path down below.  */\n+  if (ptarget_oval && *ptarget_oval == const0_rtx)\n+    ptarget_oval = NULL;\n+\n   if (ptarget_oval == NULL\n       || (target_oval = *ptarget_oval) == NULL\n       || reg_overlap_mentioned_p (expected, target_oval))\n@@ -5847,6 +5850,9 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n     {\n       machine_mode bool_mode = insn_data[icode].operand[0].mode;\n \n+      if (ptarget_bool && *ptarget_bool == const0_rtx)\n+\tptarget_bool = NULL;\n+\n       /* Make sure we always have a place for the bool operand.  */\n       if (ptarget_bool == NULL\n \t  || (target_bool = *ptarget_bool) == NULL"}, {"sha": "d12338a514860c13d23b59328b095737c7de73e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8ac2f077a4a36e3a7c54b289ef4a4ada15af357", "patch": "@@ -1,3 +1,8 @@\n+2015-10-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR middle-end/67989\n+\t* g++.dg/pr67989.C: New test.\n+\n 2015-10-26  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n \n \t* gfortran.dg/streamio_4.f90, gfortran.dg/streamio_5.f90,"}, {"sha": "90261c450b4b9429fb989f7df62f3743017c7363", "filename": "gcc/testsuite/g++.dg/pr67989.C", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr67989.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ac2f077a4a36e3a7c54b289ef4a4ada15af357/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr67989.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr67989.C?ref=f8ac2f077a4a36e3a7c54b289ef4a4ada15af357", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++11 -O2\" } */\n+/* { dg-additional-options \"-marm -march=armv4t\" { target arm*-*-* } } */\n+\n+__extension__ typedef unsigned long long int uint64_t;\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  typedef enum memory_order\n+  {\n+    memory_order_seq_cst\n+  } memory_order;\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _Tp > struct atomic\n+  {\n+    static constexpr int _S_min_alignment\n+      = (sizeof (_Tp) & (sizeof (_Tp) - 1)) || sizeof (_Tp) > 16\n+      ? 0 : sizeof (_Tp);\n+    static constexpr int _S_alignment\n+      = _S_min_alignment > alignof (_Tp) ? _S_min_alignment : alignof (_Tp);\n+      alignas (_S_alignment) _Tp _M_i;\n+    operator  _Tp () const noexcept\n+    {\n+      return load ();\n+    }\n+    _Tp load (memory_order __m = memory_order_seq_cst) const noexcept\n+    {\n+      _Tp tmp;\n+        __atomic_load (&_M_i, &tmp, __m);\n+    }\n+  };\n+}\n+\n+namespace lldb_private\n+{\n+  namespace imp\n+  {\n+  }\n+  class Address;\n+}\n+namespace lldb\n+{\n+  typedef uint64_t addr_t;\n+  class SBSection\n+  {\n+  };\n+  class SBAddress\n+  {\n+    void SetAddress (lldb::SBSection section, lldb::addr_t offset);\n+      lldb_private::Address & ref ();\n+  };\n+}\n+namespace lldb_private\n+{\n+  class Address\n+  {\n+  public:\n+    const Address & SetOffset (lldb::addr_t offset)\n+    {\n+      bool changed = m_offset != offset;\n+    }\n+    std::atomic < lldb::addr_t > m_offset;\n+  };\n+}\n+\n+using namespace lldb;\n+using namespace lldb_private;\n+void\n+SBAddress::SetAddress (lldb::SBSection section, lldb::addr_t offset)\n+{\n+  Address & addr = ref ();\n+  addr.SetOffset (offset);\n+}"}]}