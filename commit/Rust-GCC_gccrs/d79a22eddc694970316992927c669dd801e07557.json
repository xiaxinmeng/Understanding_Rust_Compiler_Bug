{"sha": "d79a22eddc694970316992927c669dd801e07557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc5YTIyZWRkYzY5NDk3MDMxNjk5MjkyN2M2NjlkZDgwMWUwNzU1Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-04-08T23:51:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-04-10T03:14:25Z"}, "message": "libgo: update to final 1.14.2 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/227551", "tree": {"sha": "b44a8aa76830fc8624e310bf1eeb87dde46ffb85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b44a8aa76830fc8624e310bf1eeb87dde46ffb85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d79a22eddc694970316992927c669dd801e07557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79a22eddc694970316992927c669dd801e07557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79a22eddc694970316992927c669dd801e07557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79a22eddc694970316992927c669dd801e07557/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d09f80ae014613edb0197b36d94242f83da75696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d09f80ae014613edb0197b36d94242f83da75696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d09f80ae014613edb0197b36d94242f83da75696"}], "stats": {"total": 239, "additions": 164, "deletions": 75}, "files": [{"sha": "138425a19d26018113042eb3803c99c9205ddd38", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -1,4 +1,4 @@\n-b31fbf7d8f23508cfbd578c5c44b13eefd8f359e\n+89fbf55a409d37ae898e5c4ea4250035f86bed1b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "8cae45f6b8eb875cb41c4c1f037b2cd863305049", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -1,4 +1,4 @@\n-edea4a79e8d7dea2456b688f492c8af33d381dc2\n+96745b980cfde139e8611772e2bc0c59a8e6cdf7\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "c2678c3dd3c5e79457e12177b11444f6fbcc2c98", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -2506,13 +2506,21 @@\n // The \"go get\" command remains permitted to update go.mod even with -mod=readonly,\n // and the \"go mod\" commands do not take the -mod flag (or any other build flags).\n //\n-// If invoked with -mod=vendor, the go command assumes that the vendor\n-// directory holds the correct copies of dependencies and ignores\n-// the dependency descriptions in go.mod.\n+// If invoked with -mod=vendor, the go command loads packages from the main\n+// module's vendor directory instead of downloading modules to and loading packages\n+// from the module cache. The go command assumes the vendor directory holds\n+// correct copies of dependencies, and it does not compute the set of required\n+// module versions from go.mod files. However, the go command does check that\n+// vendor/modules.txt (generated by 'go mod vendor') contains metadata consistent\n+// with go.mod.\n //\n // If invoked with -mod=mod, the go command loads modules from the module cache\n // even if there is a vendor directory present.\n //\n+// If the go command is not invoked with a -mod flag and the vendor directory\n+// is present and the \"go\" version in go.mod is 1.14 or higher, the go command\n+// will act as if it were invoked with -mod=vendor.\n+//\n // Pseudo-versions\n //\n // The go.mod file and the go command more generally use semantic versions as\n@@ -2710,22 +2718,28 @@\n //\n // Modules and vendoring\n //\n-// When using modules, the go command completely ignores vendor directories.\n-//\n-// By default, the go command satisfies dependencies by downloading modules\n-// from their sources and using those downloaded copies (after verification,\n-// as described in the previous section). To allow interoperation with older\n-// versions of Go, or to ensure that all files used for a build are stored\n-// together in a single file tree, 'go mod vendor' creates a directory named\n-// vendor in the root directory of the main module and stores there all the\n-// packages from dependency modules that are needed to support builds and\n-// tests of packages in the main module.\n-//\n-// To build using the main module's top-level vendor directory to satisfy\n-// dependencies (disabling use of the usual network sources and local\n-// caches), use 'go build -mod=vendor'. Note that only the main module's\n-// top-level vendor directory is used; vendor directories in other locations\n-// are still ignored.\n+// When using modules, the go command typically satisfies dependencies by\n+// downloading modules from their sources and using those downloaded copies\n+// (after verification, as described in the previous section). Vendoring may\n+// be used to allow interoperation with older versions of Go, or to ensure\n+// that all files used for a build are stored together in a single file tree.\n+//\n+// The command 'go mod vendor' constructs a directory named vendor in the main\n+// module's root directory that contains copies of all packages needed to support\n+// builds and tests of packages in the main module. 'go mod vendor' also\n+// creates the file vendor/modules.txt that contains metadata about vendored\n+// packages and module versions. This file should be kept consistent with go.mod:\n+// when vendoring is used, 'go mod vendor' should be run after go.mod is updated.\n+//\n+// If the vendor directory is present in the main module's root directory, it will\n+// be used automatically if the \"go\" version in the main module's go.mod file is\n+// 1.14 or higher. Build commands like 'go build' and 'go test' will load packages\n+// from the vendor directory instead of accessing the network or the local module\n+// cache. To explicitly enable vendoring, invoke the go command with the flag\n+// -mod=vendor. To disable vendoring, use the flag -mod=mod.\n+//\n+// Unlike vendoring in GOPATH, the go command ignores vendor directories in\n+// locations other than the main module's root directory.\n //\n //\n // Module authentication using go.sum"}, {"sha": "ac3f1351c879eb0cc4a8eda938ce91d5b78ac8a6", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -6,6 +6,7 @@ package modcmd\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -67,12 +68,10 @@ func verifyMod(mod module.Version) bool {\n \t\t_, zipErr = os.Stat(zip)\n \t}\n \tdir, dirErr := modfetch.DownloadDir(mod)\n-\tif dirErr == nil {\n-\t\t_, dirErr = os.Stat(dir)\n-\t}\n \tdata, err := ioutil.ReadFile(zip + \"hash\")\n \tif err != nil {\n-\t\tif zipErr != nil && os.IsNotExist(zipErr) && dirErr != nil && os.IsNotExist(dirErr) {\n+\t\tif zipErr != nil && errors.Is(zipErr, os.ErrNotExist) &&\n+\t\t\tdirErr != nil && errors.Is(dirErr, os.ErrNotExist) {\n \t\t\t// Nothing downloaded yet. Nothing to verify.\n \t\t\treturn true\n \t\t}\n@@ -81,7 +80,7 @@ func verifyMod(mod module.Version) bool {\n \t}\n \th := string(bytes.TrimSpace(data))\n \n-\tif zipErr != nil && os.IsNotExist(zipErr) {\n+\tif zipErr != nil && errors.Is(zipErr, os.ErrNotExist) {\n \t\t// ok\n \t} else {\n \t\thZ, err := dirhash.HashZip(zip, dirhash.DefaultHash)\n@@ -93,7 +92,7 @@ func verifyMod(mod module.Version) bool {\n \t\t\tok = false\n \t\t}\n \t}\n-\tif dirErr != nil && os.IsNotExist(dirErr) {\n+\tif dirErr != nil && errors.Is(dirErr, os.ErrNotExist) {\n \t\t// ok\n \t} else {\n \t\thD, err := dirhash.HashDir(dir, mod.Path+\"@\"+mod.Version, dirhash.DefaultHash)"}, {"sha": "d6ff068e7bccc9222e090381e381b51a7953ac14", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -7,6 +7,7 @@ package modfetch\n import (\n \t\"bytes\"\n \t\"encoding/json\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -56,8 +57,11 @@ func CachePath(m module.Version, suffix string) (string, error) {\n \treturn filepath.Join(dir, encVer+\".\"+suffix), nil\n }\n \n-// DownloadDir returns the directory to which m should be downloaded.\n-// Note that the directory may not yet exist.\n+// DownloadDir returns the directory to which m should have been downloaded.\n+// An error will be returned if the module path or version cannot be escaped.\n+// An error satisfying errors.Is(err, os.ErrNotExist) will be returned\n+// along with the directory if the directory does not exist or if the directory\n+// is not completely populated.\n func DownloadDir(m module.Version) (string, error) {\n \tif PkgMod == \"\" {\n \t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n@@ -76,9 +80,39 @@ func DownloadDir(m module.Version) (string, error) {\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\treturn filepath.Join(PkgMod, enc+\"@\"+encVer), nil\n+\n+\tdir := filepath.Join(PkgMod, enc+\"@\"+encVer)\n+\tif fi, err := os.Stat(dir); os.IsNotExist(err) {\n+\t\treturn dir, err\n+\t} else if err != nil {\n+\t\treturn dir, &DownloadDirPartialError{dir, err}\n+\t} else if !fi.IsDir() {\n+\t\treturn dir, &DownloadDirPartialError{dir, errors.New(\"not a directory\")}\n+\t}\n+\tpartialPath, err := CachePath(m, \"partial\")\n+\tif err != nil {\n+\t\treturn dir, err\n+\t}\n+\tif _, err := os.Stat(partialPath); err == nil {\n+\t\treturn dir, &DownloadDirPartialError{dir, errors.New(\"not completely extracted\")}\n+\t} else if !os.IsNotExist(err) {\n+\t\treturn dir, err\n+\t}\n+\treturn dir, nil\n+}\n+\n+// DownloadDirPartialError is returned by DownloadDir if a module directory\n+// exists but was not completely populated.\n+//\n+// DownloadDirPartialError is equivalent to os.ErrNotExist.\n+type DownloadDirPartialError struct {\n+\tDir string\n+\tErr error\n }\n \n+func (e *DownloadDirPartialError) Error() string     { return fmt.Sprintf(\"%s: %v\", e.Dir, e.Err) }\n+func (e *DownloadDirPartialError) Is(err error) bool { return err == os.ErrNotExist }\n+\n // lockVersion locks a file within the module cache that guards the downloading\n // and extraction of the zipfile for the given module version.\n func lockVersion(mod module.Version) (unlock func(), err error) {"}, {"sha": "aadf88345747e11b44e7f2cbc58a383d4015f3fd", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -22,6 +22,7 @@ import (\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/renameio\"\n+\t\"cmd/go/internal/robustio\"\n \n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/sumdb/dirhash\"\n@@ -45,47 +46,52 @@ func Download(mod module.Version) (dir string, err error) {\n \t\terr error\n \t}\n \tc := downloadCache.Do(mod, func() interface{} {\n-\t\tdir, err := DownloadDir(mod)\n+\t\tdir, err := download(mod)\n \t\tif err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n-\t\tif err := download(mod, dir); err != nil {\n-\t\t\treturn cached{\"\", err}\n-\t\t}\n \t\tcheckMod(mod)\n \t\treturn cached{dir, nil}\n \t}).(cached)\n \treturn c.dir, c.err\n }\n \n-func download(mod module.Version, dir string) (err error) {\n-\t// If the directory exists, the module has already been extracted.\n-\tfi, err := os.Stat(dir)\n-\tif err == nil && fi.IsDir() {\n-\t\treturn nil\n+func download(mod module.Version) (dir string, err error) {\n+\t// If the directory exists, and no .partial file exists,\n+\t// the module has already been completely extracted.\n+\t// .partial files may be created when future versions of cmd/go\n+\t// extract module zip directories in place instead of extracting\n+\t// to a random temporary directory and renaming.\n+\tdir, err = DownloadDir(mod)\n+\tif err == nil {\n+\t\treturn dir, nil\n+\t} else if dir == \"\" || !errors.Is(err, os.ErrNotExist) {\n+\t\treturn \"\", err\n \t}\n \n \t// To avoid cluttering the cache with extraneous files,\n \t// DownloadZip uses the same lockfile as Download.\n \t// Invoke DownloadZip before locking the file.\n \tzipfile, err := DownloadZip(mod)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn \"\", err\n \t}\n \n \tunlock, err := lockVersion(mod)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn \"\", err\n \t}\n \tdefer unlock()\n \n \t// Check whether the directory was populated while we were waiting on the lock.\n-\tfi, err = os.Stat(dir)\n-\tif err == nil && fi.IsDir() {\n-\t\treturn nil\n+\t_, dirErr := DownloadDir(mod)\n+\tif dirErr == nil {\n+\t\treturn dir, nil\n \t}\n+\t_, dirExists := dirErr.(*DownloadDirPartialError)\n \n-\t// Clean up any remaining temporary directories from previous runs.\n+\t// Clean up any remaining temporary directories from previous runs, as well\n+\t// as partially extracted diectories created by future versions of cmd/go.\n \t// This is only safe to do because the lock file ensures that their writers\n \t// are no longer active.\n \tparentDir := filepath.Dir(dir)\n@@ -95,18 +101,31 @@ func download(mod module.Version, dir string) (err error) {\n \t\t\tRemoveAll(path) // best effort\n \t\t}\n \t}\n+\tif dirExists {\n+\t\tif err := RemoveAll(dir); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t}\n+\n+\tpartialPath, err := CachePath(mod, \"partial\")\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif err := os.Remove(partialPath); err != nil && !os.IsNotExist(err) {\n+\t\treturn \"\", err\n+\t}\n \n \t// Extract the zip file to a temporary directory, then rename it to the\n \t// final path. That way, we can use the existence of the source directory to\n \t// signal that it has been extracted successfully, and if someone deletes\n \t// the entire directory (e.g. as an attempt to prune out file corruption)\n \t// the module cache will still be left in a recoverable state.\n \tif err := os.MkdirAll(parentDir, 0777); err != nil {\n-\t\treturn err\n+\t\treturn \"\", err\n \t}\n \ttmpDir, err := ioutil.TempDir(parentDir, tmpPrefix)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn \"\", err\n \t}\n \tdefer func() {\n \t\tif err != nil {\n@@ -116,19 +135,19 @@ func download(mod module.Version, dir string) (err error) {\n \n \tif err := modzip.Unzip(tmpDir, mod, zipfile); err != nil {\n \t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n-\t\treturn err\n+\t\treturn \"\", err\n \t}\n \n-\tif err := os.Rename(tmpDir, dir); err != nil {\n-\t\treturn err\n+\tif err := robustio.Rename(tmpDir, dir); err != nil {\n+\t\treturn \"\", err\n \t}\n \n \tif !cfg.ModCacheRW {\n \t\t// Make dir read-only only *after* renaming it.\n \t\t// os.Rename was observed to fail for read-only directories on macOS.\n \t\tmakeDirsReadOnly(dir)\n \t}\n-\treturn nil\n+\treturn dir, nil\n }\n \n var downloadZipCache par.Cache"}, {"sha": "2a69d5953d3764b0a5118b458f436b958c6131b3", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -148,9 +148,7 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\t\t}\n \t\t\tdir, err := modfetch.DownloadDir(mod)\n \t\t\tif err == nil {\n-\t\t\t\tif info, err := os.Stat(dir); err == nil && info.IsDir() {\n-\t\t\t\t\tm.Dir = dir\n-\t\t\t\t}\n+\t\t\t\tm.Dir = dir\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "bd19bb43aa00b0eea9b52634104e42474b7c309d", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -176,13 +176,21 @@ not need updates, such as in a continuous integration and testing system.\n The \"go get\" command remains permitted to update go.mod even with -mod=readonly,\n and the \"go mod\" commands do not take the -mod flag (or any other build flags).\n \n-If invoked with -mod=vendor, the go command assumes that the vendor\n-directory holds the correct copies of dependencies and ignores\n-the dependency descriptions in go.mod.\n+If invoked with -mod=vendor, the go command loads packages from the main\n+module's vendor directory instead of downloading modules to and loading packages\n+from the module cache. The go command assumes the vendor directory holds\n+correct copies of dependencies, and it does not compute the set of required\n+module versions from go.mod files. However, the go command does check that\n+vendor/modules.txt (generated by 'go mod vendor') contains metadata consistent\n+with go.mod.\n \n If invoked with -mod=mod, the go command loads modules from the module cache\n even if there is a vendor directory present.\n \n+If the go command is not invoked with a -mod flag and the vendor directory\n+is present and the \"go\" version in go.mod is 1.14 or higher, the go command\n+will act as if it were invoked with -mod=vendor.\n+\n Pseudo-versions\n \n The go.mod file and the go command more generally use semantic versions as\n@@ -380,22 +388,28 @@ the format of the cached downloaded packages.\n \n Modules and vendoring\n \n-When using modules, the go command completely ignores vendor directories.\n-\n-By default, the go command satisfies dependencies by downloading modules\n-from their sources and using those downloaded copies (after verification,\n-as described in the previous section). To allow interoperation with older\n-versions of Go, or to ensure that all files used for a build are stored\n-together in a single file tree, 'go mod vendor' creates a directory named\n-vendor in the root directory of the main module and stores there all the\n-packages from dependency modules that are needed to support builds and\n-tests of packages in the main module.\n-\n-To build using the main module's top-level vendor directory to satisfy\n-dependencies (disabling use of the usual network sources and local\n-caches), use 'go build -mod=vendor'. Note that only the main module's\n-top-level vendor directory is used; vendor directories in other locations\n-are still ignored.\n+When using modules, the go command typically satisfies dependencies by\n+downloading modules from their sources and using those downloaded copies\n+(after verification, as described in the previous section). Vendoring may\n+be used to allow interoperation with older versions of Go, or to ensure\n+that all files used for a build are stored together in a single file tree.\n+\n+The command 'go mod vendor' constructs a directory named vendor in the main\n+module's root directory that contains copies of all packages needed to support\n+builds and tests of packages in the main module. 'go mod vendor' also\n+creates the file vendor/modules.txt that contains metadata about vendored\n+packages and module versions. This file should be kept consistent with go.mod:\n+when vendoring is used, 'go mod vendor' should be run after go.mod is updated.\n+\n+If the vendor directory is present in the main module's root directory, it will\n+be used automatically if the \"go\" version in the main module's go.mod file is\n+1.14 or higher. Build commands like 'go build' and 'go test' will load packages\n+from the vendor directory instead of accessing the network or the local module\n+cache. To explicitly enable vendoring, invoke the go command with the flag\n+-mod=vendor. To disable vendoring, use the flag -mod=mod.\n+\n+Unlike vendoring in GOPATH, the go command ignores vendor directories in\n+locations other than the main module's root directory.\n \t`,\n }\n "}, {"sha": "d4cb7e6457fc05d8d548f12399b390258bfb4f80", "filename": "libgo/go/cmd/go/internal/robustio/robustio_flaky.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -15,7 +15,7 @@ import (\n \t\"time\"\n )\n \n-const arbitraryTimeout = 500 * time.Millisecond\n+const arbitraryTimeout = 2000 * time.Millisecond\n \n // retry retries ephemeral errors from f up to an arbitrary timeout\n // to work around filesystem flakiness on Windows and Darwin."}, {"sha": "be8e00c20251a3338a976d47e34c048e841bb5cd", "filename": "libgo/go/runtime/mbitmap.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fruntime%2Fmbitmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fruntime%2Fmbitmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmbitmap.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -1941,7 +1941,11 @@ Run:\n // The bitmask starts at s.startAddr.\n // The result must be deallocated with dematerializeGCProg.\n func materializeGCProg(ptrdata uintptr, prog *byte) *mspan {\n-\ts := mheap_.allocManual((ptrdata/(8*sys.PtrSize)+pageSize-1)/pageSize, &memstats.gc_sys)\n+\t// Each word of ptrdata needs one bit in the bitmap.\n+\tbitmapBytes := divRoundUp(ptrdata, 8*sys.PtrSize)\n+\t// Compute the number of pages needed for bitmapBytes.\n+\tpages := divRoundUp(bitmapBytes, pageSize)\n+\ts := mheap_.allocManual(pages, &memstats.gc_sys)\n \trunGCProg(addb(prog, 4), nil, (*byte)(unsafe.Pointer(s.startAddr)), 1)\n \treturn s\n }"}, {"sha": "4a06da51fe5d868ef7e319b55e439b470835403d", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79a22eddc694970316992927c669dd801e07557/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=d79a22eddc694970316992927c669dd801e07557", "patch": "@@ -250,6 +250,13 @@ func alignDown(n, a uintptr) uintptr {\n \treturn n &^ (a - 1)\n }\n \n+// divRoundUp returns ceil(n / a).\n+func divRoundUp(n, a uintptr) uintptr {\n+\t// a is generally a power of two. This will get inlined and\n+\t// the compiler will optimize the division.\n+\treturn (n + a - 1) / a\n+}\n+\n // checkASM returns whether assembly runtime checks have passed.\n func checkASM() bool {\n \treturn true"}]}