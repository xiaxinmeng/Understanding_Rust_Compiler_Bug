{"sha": "4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMyYjI5MDZiMGMxNGMyYWY3YWJlMjBmMDBlYzJiNGZjZjY0M2E0Yw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-11-15T22:23:29Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-11-15T22:23:29Z"}, "message": "sched-deps.c (set_sched_group_p): Delete.\n\n2004-11-15  Eric Christopher  <echristo@redhat.com>\n\n\t* sched-deps.c (set_sched_group_p): Delete.\n\t(delete_all_dependencies): New function.\n\t(fixup_sched_groups): Use. New function.\n\t(sched_analyze_insn): Use.\n\nFrom-SVN: r90698", "tree": {"sha": "96ada1c0418c242be55dd6a1184854623bd4563d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96ada1c0418c242be55dd6a1184854623bd4563d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c/comments", "author": null, "committer": null, "parents": [{"sha": "37b2f2904b3320e3775a2bbd219623c15b6a974e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b2f2904b3320e3775a2bbd219623c15b6a974e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b2f2904b3320e3775a2bbd219623c15b6a974e"}], "stats": {"total": 93, "additions": 68, "deletions": 25}, "files": [{"sha": "a50706dbb66d97cb4870b991ba7bb2dddc0c8aeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c", "patch": "@@ -1,3 +1,10 @@\n+2004-11-15  Eric Christopher  <echristo@redhat.com>\n+\n+\t* sched-deps.c (set_sched_group_p): Delete.\n+\t(delete_all_dependencies): New function.\n+\t(fixup_sched_groups): Use. New function.\n+\t(sched_analyze_insn): Use.\n+\n 2004-11-15  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* c-common.c (binary_op_error): Don't allow LROTATE_EXPR,\n@@ -221,7 +228,7 @@\n \n 2004-11-13  Kelley Cook  <kcook@gcc.gnu.org>\n \n-\t* doc/install.texi (automake): Correctly document that everything now \n+\t* doc/install.texi (automake): Correctly document that everything now\n \twill use automake 1.9.3.\n \n 2004-11-13  Hans-Peter Nilsson  <hp@bitrange.com>\n@@ -307,7 +314,7 @@\n \t* doc/install.texi: Likewise.\n \t* doc/makefile.texi: Likewise.\n \t* doc/sourcebuild.texi: Likewise.\n-\t\n+\n 2004-11-13  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-ssa-loop-manip.c: Fix a comment typo.\n@@ -352,12 +359,12 @@\n 2004-11-12  Devang Patel  <dpatel@apple.com>\n \n \t* optabs.c (vector_compare_rtx): Use COMPARISON_CLASS_P.\n-\t\n+\n 2004-11-12  Devang Patel  <dpatel@apple.com>\n \n \t* tree-if-conv.c (clean_predicate_lists): Use loop header\n \tand latch directly.\n-\t\n+\n 2004-11-12  Richard Henderson  <rth@redhat.com>\n \n \tPR 17778\n@@ -377,7 +384,7 @@\n \t* passes.c (rest_of_decl_compilation): Do not look at DECL_RTL\n \twhen deciding whether to pass a variable to\n \tcgraph_varpool_finalize_decl or assemble_variable.\n-\t* toplev.c (check_global_declarations): Do not clear DECL_RTL. \n+\t* toplev.c (check_global_declarations): Do not clear DECL_RTL.\n \n 2004-11-12  Kazu Hirata  <kazu@cs.umass.edu>\n \n@@ -420,7 +427,7 @@\n 2004-11-12  Sebastian Pop  <pop@cri.ensmp.fr>\n \n \tPR middle-end/18005\n-\t* tree-data-ref.c (estimate_niter_from_size_of_data): Ensure \n+\t* tree-data-ref.c (estimate_niter_from_size_of_data): Ensure\n \tthat arguments of EXACT_DIV_EXPR are INTEGER_CST.\n \n 2004-11-12  Steven Bosscher  <stevenb@suse.de>\n@@ -484,7 +491,7 @@\n \n 2004-11-11  Sebastian Pop  <pop@cri.ensmp.fr>\n \n-\t* tree-scalar-evolution.c (follow_ssa_edge_in_condition_phi): \n+\t* tree-scalar-evolution.c (follow_ssa_edge_in_condition_phi):\n \tGive up as soon as the evolution is known not computable.\n \n 2004-11-11  Nathan Sidwell  <nathan@codesourcery.com>"}, {"sha": "0d916c6e956a118ac91441bbe6eaaa80e1775edf", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 54, "deletions": 18, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=4c2b2906b0c14c2af7abe20f00ec2b4fcf643a4c", "patch": "@@ -94,7 +94,8 @@ static bitmap_head *forward_dependency_cache;\n static int deps_may_trap_p (rtx);\n static void add_dependence_list (rtx, rtx, enum reg_note);\n static void add_dependence_list_and_free (rtx, rtx *, enum reg_note);\n-static void set_sched_group_p (rtx);\n+static void delete_all_dependences (rtx);\n+static void fixup_sched_groups (rtx);\n \n static void flush_pending_lists (struct deps *, rtx, int, int);\n static void sched_analyze_1 (struct deps *, rtx, rtx);\n@@ -369,18 +370,54 @@ add_dependence_list_and_free (rtx insn, rtx *listp, enum reg_note dep_type)\n     }\n }\n \n-/* Set SCHED_GROUP_P and care for the rest of the bookkeeping that\n-   goes along with that.  */\n+/* Clear all dependencies for an insn.  */\n \n static void\n-set_sched_group_p (rtx insn)\n+delete_all_dependences (rtx insn)\n {\n-  rtx prev;\n+  /* Clear caches, if they exist, as well as free the dependence.  */\n \n-  SCHED_GROUP_P (insn) = 1;\n+#ifdef INSN_SCHEDULING\n+  if (true_dependency_cache != NULL)\n+    {\n+      bitmap_clear (&true_dependency_cache[INSN_LUID (insn)]);\n+      bitmap_clear (&anti_dependency_cache[INSN_LUID (insn)]);\n+      bitmap_clear (&output_dependency_cache[INSN_LUID (insn)]);\n+    }\n+#endif\n+\n+  free_INSN_LIST_list (&LOG_LINKS (insn));\n+}\n+\n+/* All insns in a scheduling group except the first should only have\n+   dependencies on the previous insn in the group.  So we find the\n+   first instruction in the scheduling group by walking the dependence\n+   chains backwards. Then we add the dependencies for the group to\n+   the previous nonnote insn.  */\n+\n+static void\n+fixup_sched_groups (rtx insn)\n+{\n+  rtx link;\n \n-  prev = prev_nonnote_insn (insn);\n-  add_dependence (insn, prev, REG_DEP_ANTI);\n+  for (link = LOG_LINKS (insn); link ; link = XEXP (link, 1))\n+    {\n+      rtx i = insn;\n+      do\n+\t{\n+\t  i = prev_nonnote_insn (i);\n+\n+\t  if (XEXP (link, 0) == i)\n+\t    goto next_link;\n+\t} while (SCHED_GROUP_P (i));\n+      add_dependence (i, XEXP (link, 0), REG_NOTE_KIND (link));\n+    next_link:;\n+    }\n+\n+  delete_all_dependences (insn);\n+\n+  if (BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (prev_nonnote_insn (insn)))\n+    add_dependence (insn, prev_nonnote_insn (insn), REG_DEP_ANTI);\n }\n \f\n /* Process an insn's memory dependencies.  There are four kinds of\n@@ -643,7 +680,7 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n #ifdef HAVE_cc0\n     case CC0:\n       /* User of CC0 depends on immediately preceding insn.  */\n-      set_sched_group_p (insn);\n+      SCHED_GROUP_P (insn) = 1;\n        /* Don't move CC0 setter to another block (it can set up the\n         same flag for previous CC0 users which is safe).  */\n       CANT_MOVE (prev_nonnote_insn (insn)) = 1;\n@@ -1112,7 +1149,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \n   if (deps->libcall_block_tail_insn)\n     {\n-      set_sched_group_p (insn);\n+      SCHED_GROUP_P (insn) = 1;\n       CANT_MOVE (insn) = 1;\n     }\n \n@@ -1158,15 +1195,10 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n       if (src_regno < FIRST_PSEUDO_REGISTER\n \t  || dest_regno < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  /* If we are inside a post-call group right at the start of the\n-\t     scheduling region, we must not add a dependency.  */\n \t  if (deps->in_post_call_group_p == post_call_initial)\n-\t    {\n-\t      SCHED_GROUP_P (insn) = 1;\n-\t      deps->in_post_call_group_p = post_call;\n-\t    }\n-\t  else\n-\t    set_sched_group_p (insn);\n+\t    deps->in_post_call_group_p = post_call;\n+\n+\t  SCHED_GROUP_P (insn) = 1;\n \t  CANT_MOVE (insn) = 1;\n \t}\n       else\n@@ -1175,6 +1207,10 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  deps->in_post_call_group_p = not_post_call;\n \t}\n     }\n+\n+  /* Fixup the dependencies in the sched group.  */\n+  if (SCHED_GROUP_P (insn))\n+    fixup_sched_groups (insn);\n }\n \n /* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS"}]}