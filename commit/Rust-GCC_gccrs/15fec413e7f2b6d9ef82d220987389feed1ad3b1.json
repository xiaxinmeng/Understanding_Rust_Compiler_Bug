{"sha": "15fec413e7f2b6d9ef82d220987389feed1ad3b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVmZWM0MTNlN2YyYjZkOWVmODJkMjIwOTg3Mzg5ZmVlZDFhZDNiMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-29T21:41:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-29T21:41:04Z"}, "message": "unroll.c (unroll_loop): Do not abort for an UNROLL_MODULO or UNROLL_COMPLETELY loop that starts with a...\n\nP\n        * unroll.c (unroll_loop): Do not abort for an UNROLL_MODULO\n        or UNROLL_COMPLETELY loop that starts with a jump to its\n        exit code.\n\nFrom-SVN: r21476", "tree": {"sha": "dd6d6854d6e3adc3d7672a0402bee0e1fe9b48d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd6d6854d6e3adc3d7672a0402bee0e1fe9b48d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15fec413e7f2b6d9ef82d220987389feed1ad3b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fec413e7f2b6d9ef82d220987389feed1ad3b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15fec413e7f2b6d9ef82d220987389feed1ad3b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fec413e7f2b6d9ef82d220987389feed1ad3b1/comments", "author": null, "committer": null, "parents": [{"sha": "47d41103c544ec845b1ffa9d58d9bac571373e62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d41103c544ec845b1ffa9d58d9bac571373e62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d41103c544ec845b1ffa9d58d9bac571373e62"}], "stats": {"total": 29, "additions": 24, "deletions": 5}, "files": [{"sha": "72f1f046442b7937a785b93a971398c9c5833ba8", "filename": "gcc/unroll.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fec413e7f2b6d9ef82d220987389feed1ad3b1/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fec413e7f2b6d9ef82d220987389feed1ad3b1/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=15fec413e7f2b6d9ef82d220987389feed1ad3b1", "patch": "@@ -431,15 +431,34 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   if (unroll_type == UNROLL_COMPLETELY || unroll_type == UNROLL_MODULO)\n     {\n-      /* Loops of these types should never start with a jump down to\n-\t the exit condition test.  For now, check for this case just to\n-\t be sure.  UNROLL_NAIVE loops can be of this form, this case is\n-\t handled below.  */\n+      /* Loops of these types can start with jump down to the exit condition\n+\t in rare circumstances.\n+\n+\t Consider a pair of nested loops where the inner loop is part\n+\t of the exit code for the outer loop.\n+\n+\t In this case jump.c will not duplicate the exit test for the outer\n+\t loop, so it will start with a jump to the exit code.\n+\n+\t Then consider if the inner loop turns out to iterate once and\n+\t only once.  We will end up deleting the jumps associated with\n+\t the inner loop.  However, the loop notes are not removed from\n+\t the instruction stream.\n+\n+\t And finally assume that we can compute the number of iterations\n+\t for the outer loop.\n+\n+\t In this case unroll may want to unroll the outer loop even though\n+\t it starts with a jump to the outer loop's exit code.\n+\n+\t We could try to optimize this case, but it hardly seems worth it.\n+\t Just return without unrolling the loop in such cases.  */\n+\n       insn = loop_start;\n       while (GET_CODE (insn) != CODE_LABEL && GET_CODE (insn) != JUMP_INSN)\n \tinsn = NEXT_INSN (insn);\n       if (GET_CODE (insn) == JUMP_INSN)\n-\tabort ();\n+\treturn;\n     }\n \n   if (unroll_type == UNROLL_COMPLETELY)"}]}