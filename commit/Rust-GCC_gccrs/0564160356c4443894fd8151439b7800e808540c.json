{"sha": "0564160356c4443894fd8151439b7800e808540c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU2NDE2MDM1NmM0NDQzODk0ZmQ4MTUxNDM5Yjc4MDBlODA4NTQwYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2012-04-11T14:40:48Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2012-04-11T14:40:48Z"}, "message": "haifa-sched.c (prune_ready_list): Rework handling of SCHED_GROUP_P insns so that no other insn is queued for a...\n\n\t* haifa-sched.c (prune_ready_list): Rework handling of SCHED_GROUP_P\n\tinsns so that no other insn is queued for a time before them.\n\nFrom-SVN: r186325", "tree": {"sha": "f54a5d51e49dcb0a6c257ee21a4720f3ec45826b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f54a5d51e49dcb0a6c257ee21a4720f3ec45826b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0564160356c4443894fd8151439b7800e808540c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0564160356c4443894fd8151439b7800e808540c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0564160356c4443894fd8151439b7800e808540c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0564160356c4443894fd8151439b7800e808540c/comments", "author": null, "committer": null, "parents": [{"sha": "7861732fe8bf66cc6d0590d410aacee2618b2ffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7861732fe8bf66cc6d0590d410aacee2618b2ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7861732fe8bf66cc6d0590d410aacee2618b2ffa"}], "stats": {"total": 149, "additions": 85, "deletions": 64}, "files": [{"sha": "1f1b2b471bd6e6993066bdc9b6fee3ac6fb633e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0564160356c4443894fd8151439b7800e808540c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0564160356c4443894fd8151439b7800e808540c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0564160356c4443894fd8151439b7800e808540c", "patch": "@@ -3,6 +3,9 @@\n \t* sel-sched.c (sel_global_init): Swap order of sched_rgn_init and\n \tsched_init calls.\n \n+\t* haifa-sched.c (prune_ready_list): Rework handling of SCHED_GROUP_P\n+\tinsns so that no other insn is queued for a time before them.\n+\n 2012-04-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/52621"}, {"sha": "569cd2bace46f53e478b5eb57c1272b0b640015f", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 82, "deletions": 64, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0564160356c4443894fd8151439b7800e808540c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0564160356c4443894fd8151439b7800e808540c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=0564160356c4443894fd8151439b7800e808540c", "patch": "@@ -3946,88 +3946,106 @@ static void\n prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n \t\t  bool shadows_only_p, bool modulo_epilogue_p)\n {\n-  int i;\n+  int i, pass;\n   bool sched_group_found = false;\n+  int min_cost_group = 1;\n \n- restart:\n   for (i = 0; i < ready.n_ready; i++)\n     {\n       rtx insn = ready_element (&ready, i);\n-      int cost = 0;\n-      const char *reason = \"resource conflict\";\n-\n-      if (DEBUG_INSN_P (insn))\n-\tcontinue;\n-\n-      if (SCHED_GROUP_P (insn) && !sched_group_found)\n+      if (SCHED_GROUP_P (insn))\n \t{\n \t  sched_group_found = true;\n-\t  if (i > 0)\n-\t    goto restart;\n+\t  break;\n \t}\n+    }\n \n-      if (sched_group_found && !SCHED_GROUP_P (insn))\n-\t{\n-\t  cost = 1;\n-\t  reason = \"not in sched group\";\n-\t}\n-      else if (modulo_epilogue_p && INSN_EXACT_TICK (insn) == INVALID_TICK)\n-\t{\n-\t  cost = max_insn_queue_index;\n-\t  reason = \"not an epilogue insn\";\n-\t}\n-      else if (shadows_only_p && !SHADOW_P (insn))\n-\t{\n-\t  cost = 1;\n-\t  reason = \"not a shadow\";\n-\t}\n-      else if (recog_memoized (insn) < 0)\n-\t{\n-\t  if (!first_cycle_insn_p\n-\t      && (GET_CODE (PATTERN (insn)) == ASM_INPUT\n-\t\t  || asm_noperands (PATTERN (insn)) >= 0))\n-\t    cost = 1;\n-\t  reason = \"asm\";\n-\t}\n-      else if (sched_pressure_p)\n-\tcost = 0;\n-      else\n+  /* Make two passes if there's a SCHED_GROUP_P insn; make sure to handle\n+     such an insn first and note its cost, then schedule all other insns\n+     for one cycle later.  */\n+  for (pass = sched_group_found ? 0 : 1; pass < 2; )\n+    {\n+      int n = ready.n_ready;\n+      for (i = 0; i < n; i++)\n \t{\n-\t  int delay_cost = 0;\n+\t  rtx insn = ready_element (&ready, i);\n+\t  int cost = 0;\n+\t  const char *reason = \"resource conflict\";\n \n-\t  if (delay_htab)\n+\t  if (DEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  if (sched_group_found && !SCHED_GROUP_P (insn))\n \t    {\n-\t      struct delay_pair *delay_entry;\n-\t      delay_entry\n-\t\t= (struct delay_pair *)htab_find_with_hash (delay_htab, insn,\n-\t\t\t\t\t\t\t    htab_hash_pointer (insn));\n-\t      while (delay_entry && delay_cost == 0)\n+\t      if (pass == 0)\n+\t\tcontinue;\n+\t      cost = min_cost_group;\n+\t      reason = \"not in sched group\";\n+\t    }\n+\t  else if (modulo_epilogue_p\n+\t\t   && INSN_EXACT_TICK (insn) == INVALID_TICK)\n+\t    {\n+\t      cost = max_insn_queue_index;\n+\t      reason = \"not an epilogue insn\";\n+\t    }\n+\t  else if (shadows_only_p && !SHADOW_P (insn))\n+\t    {\n+\t      cost = 1;\n+\t      reason = \"not a shadow\";\n+\t    }\n+\t  else if (recog_memoized (insn) < 0)\n+\t    {\n+\t      if (!first_cycle_insn_p\n+\t\t  && (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t      || asm_noperands (PATTERN (insn)) >= 0))\n+\t\tcost = 1;\n+\t      reason = \"asm\";\n+\t    }\n+\t  else if (sched_pressure_p)\n+\t    cost = 0;\n+\t  else\n+\t    {\n+\t      int delay_cost = 0;\n+\n+\t      if (delay_htab)\n \t\t{\n-\t\t  delay_cost = estimate_shadow_tick (delay_entry);\n-\t\t  if (delay_cost > max_insn_queue_index)\n-\t\t    delay_cost = max_insn_queue_index;\n-\t\t  delay_entry = delay_entry->next_same_i1;\n+\t\t  struct delay_pair *delay_entry;\n+\t\t  delay_entry\n+\t\t    = (struct delay_pair *)htab_find_with_hash (delay_htab, insn,\n+\t\t\t\t\t\t\t\thtab_hash_pointer (insn));\n+\t\t  while (delay_entry && delay_cost == 0)\n+\t\t    {\n+\t\t      delay_cost = estimate_shadow_tick (delay_entry);\n+\t\t      if (delay_cost > max_insn_queue_index)\n+\t\t\tdelay_cost = max_insn_queue_index;\n+\t\t      delay_entry = delay_entry->next_same_i1;\n+\t\t    }\n \t\t}\n-\t    }\n \n-\t  memcpy (temp_state, curr_state, dfa_state_size);\n-\t  cost = state_transition (temp_state, insn);\n-\t  if (cost < 0)\n-\t    cost = 0;\n-\t  else if (cost == 0)\n-\t    cost = 1;\n-\t  if (cost < delay_cost)\n+\t      memcpy (temp_state, curr_state, dfa_state_size);\n+\t      cost = state_transition (temp_state, insn);\n+\t      if (cost < 0)\n+\t\tcost = 0;\n+\t      else if (cost == 0)\n+\t\tcost = 1;\n+\t      if (cost < delay_cost)\n+\t\t{\n+\t\t  cost = delay_cost;\n+\t\t  reason = \"shadow tick\";\n+\t\t}\n+\t    }\n+\t  if (cost >= 1)\n \t    {\n-\t      cost = delay_cost;\n-\t      reason = \"shadow tick\";\n+\t      if (SCHED_GROUP_P (insn) && cost > min_cost_group)\n+\t\tmin_cost_group = cost;\n+\t      ready_remove (&ready, i);\n+\t      queue_insn (insn, cost, reason);\n+\t      if (i + 1 < n)\n+\t\tbreak;\n \t    }\n \t}\n-      if (cost >= 1)\n-\t{\n-\t  ready_remove (&ready, i);\n-\t  queue_insn (insn, cost, reason);\n-\t  goto restart;\n-\t}\n+      if (i == n)\n+\tpass++;\n     }\n }\n "}]}