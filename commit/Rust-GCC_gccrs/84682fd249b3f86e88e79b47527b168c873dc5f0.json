{"sha": "84682fd249b3f86e88e79b47527b168c873dc5f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ2ODJmZDI0OWIzZjg2ZTg4ZTc5YjQ3NTI3YjE2OGM4NzNkYzVmMA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2017-06-30T16:36:57Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2017-06-30T16:36:57Z"}, "message": "[rtlanal] Do a better job of costing parallel sets containing flag-setting operations.\n\n    \nMany parallel set insns are of the form of a single set that also sets\nthe condition code flags.  In this case the cost of such an insn is\nnormally the cost of the part that doesn't set the flags, since\nupdating the condition flags is simply a side effect.\n\nAt present all such insns are treated as having unknown cost (ie 0)\nand combine assumes that such insns are infinitely more expensive than\nany other insn sequence with a non-zero cost.\n\nThis patch addresses this problem by allowing insn_rtx_cost to ignore\nthe condition setting part of a PARALLEL iff there is exactly one\ncomparison set and one non-comparison set.  If the only set operation\nis a comparison we still use that as the basis of the insn cost.\n\n\t* rtlanal.c (insn_rtx_cost): If a parallel contains exactly one\n\tcomparison set and one other set, use the cost of the non-comparison\n\tset.\n\nBootstrapped on aarch64-none-linuxgnu\n\nFrom-SVN: r249850", "tree": {"sha": "06028456c6a0a69b566fff5f08954e8b2046407d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06028456c6a0a69b566fff5f08954e8b2046407d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84682fd249b3f86e88e79b47527b168c873dc5f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84682fd249b3f86e88e79b47527b168c873dc5f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84682fd249b3f86e88e79b47527b168c873dc5f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84682fd249b3f86e88e79b47527b168c873dc5f0/comments", "author": null, "committer": null, "parents": [{"sha": "e886224be7e4e75c06abf95676c1b408aa2583ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e886224be7e4e75c06abf95676c1b408aa2583ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e886224be7e4e75c06abf95676c1b408aa2583ef"}], "stats": {"total": 34, "additions": 29, "deletions": 5}, "files": [{"sha": "e0a9cc009aa38107952ce4b65c4fd1b60d1af66c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84682fd249b3f86e88e79b47527b168c873dc5f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84682fd249b3f86e88e79b47527b168c873dc5f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84682fd249b3f86e88e79b47527b168c873dc5f0", "patch": "@@ -1,3 +1,9 @@\n+2017-06-30  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* rtlanal.c (insn_rtx_cost): If a parallel contains exactly one\n+\tcomparison set and one other set, use the cost of the non-comparison\n+\tset.\n+\n 2017-06-30  Nathan Sidwell  <nathan@acm.org>\n \n \t* ggc.h: Replace all 'static inline' with plain 'inline'.  Fix"}, {"sha": "9bfae8cb9b03d70469cc3b151563284840b3c6d7", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84682fd249b3f86e88e79b47527b168c873dc5f0/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84682fd249b3f86e88e79b47527b168c873dc5f0/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=84682fd249b3f86e88e79b47527b168c873dc5f0", "patch": "@@ -5263,23 +5263,41 @@ insn_rtx_cost (rtx pat, bool speed)\n   int i, cost;\n   rtx set;\n \n-  /* Extract the single set rtx from the instruction pattern.\n-     We can't use single_set since we only have the pattern.  */\n+  /* Extract the single set rtx from the instruction pattern.  We\n+     can't use single_set since we only have the pattern.  We also\n+     consider PARALLELs of a normal set and a single comparison.  In\n+     that case we use the cost of the non-comparison SET operation,\n+     which is most-likely to be the real cost of this operation.  */\n   if (GET_CODE (pat) == SET)\n     set = pat;\n   else if (GET_CODE (pat) == PARALLEL)\n     {\n       set = NULL_RTX;\n+      rtx comparison = NULL_RTX;\n+\n       for (i = 0; i < XVECLEN (pat, 0); i++)\n \t{\n \t  rtx x = XVECEXP (pat, 0, i);\n \t  if (GET_CODE (x) == SET)\n \t    {\n-\t      if (set)\n-\t\treturn 0;\n-\t      set = x;\n+\t      if (GET_CODE (SET_SRC (x)) == COMPARE)\n+\t\t{\n+\t\t  if (comparison)\n+\t\t    return 0;\n+\t\t  comparison = x;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (set)\n+\t\t    return 0;\n+\t\t  set = x;\n+\t\t}\n \t    }\n \t}\n+\n+      if (!set && comparison)\n+\tset = comparison;\n+\n       if (!set)\n \treturn 0;\n     }"}]}