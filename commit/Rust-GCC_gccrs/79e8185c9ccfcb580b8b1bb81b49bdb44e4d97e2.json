{"sha": "79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzllODE4NWM5Y2NmY2I1ODBiOGIxYmI4MWI0OWJkYjQ0ZTRkOTdlMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-10-15T04:50:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-15T04:50:09Z"}, "message": "fold-const.c (fold): Move bit_rotate code to the EXPR_PLUS case, falltrought to assocate code.\n\n        * fold-const.c (fold): Move bit_rotate code to the EXPR_PLUS case,\n        falltrought to assocate code.\n        Convert XOR to OR in code like (a&c1)^(a&c2) where c1 and c2 don't have\n        bits in common.\n\n        * combine.c (simplify_logical): Convert XOR to IOR if operands have\n        no bits in common; remove XOR to ROTATE conversion.\n\nFrom-SVN: r29998", "tree": {"sha": "6884eb392c55198115c06f8cb78b15c8588568a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6884eb392c55198115c06f8cb78b15c8588568a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2/comments", "author": null, "committer": null, "parents": [{"sha": "ce57746769bfa0d19afef76e07960fd6bf86264d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce57746769bfa0d19afef76e07960fd6bf86264d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce57746769bfa0d19afef76e07960fd6bf86264d"}], "stats": {"total": 197, "additions": 108, "deletions": 89}, "files": [{"sha": "af463a9c3ae3806be131729ca2bbef84c6d653da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2", "patch": "@@ -1,3 +1,13 @@\n+Thu Oct 14 19:44:08 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* fold-const.c (fold): Move bit_rotate code to the EXPR_PLUS case,\n+\tfalltrought to assocate code.\n+\tConvert XOR to OR in code like (a&c1)^(a&c2) where c1 and c2 don't have\n+\tbits in common.\n+\n+\t* combine.c (simplify_logical): Convert XOR to IOR if operands have\n+\tno bits in common; remove XOR to ROTATE conversion.\n+\n Fri Oct 15 17:40:11 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.h (c4x_va_start, c4x_va_arg): Declare."}, {"sha": "7273e8f237e207b23ee62fe0f2337fc0630ce2e1", "filename": "gcc/combine.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2", "patch": "@@ -5163,6 +5163,15 @@ simplify_logical (x, last)\n       break;\n \n     case XOR:\n+      /* If we are XORing two things that have no bits in common,\n+\t convert them into an IOR.  This helps to detect rotation encoded\n+\t using those methods and possibly other simplifications.  */\n+\n+      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t  && (nonzero_bits (op0, mode)\n+\t      & nonzero_bits (op1, mode)) == 0)\n+\treturn (gen_binary (IOR, mode, op0, op1));\n+\n       /* Convert (XOR (NOT x) (NOT y)) to (XOR x y).\n \t Also convert (XOR (NOT x) y) to (NOT (XOR x y)), similarly for\n \t (NOT y).  */\n@@ -5232,20 +5241,6 @@ simplify_logical (x, last)\n \treturn gen_rtx_combine (reverse_condition (GET_CODE (op0)),\n \t\t\t\tmode, XEXP (op0, 0), XEXP (op0, 1));\n \n-      /* Convert (xor (ashift A CX) (lshiftrt A CY)) where CX+CY equals the\n-\t mode size to (rotate A CX).  */\n-\n-      if (((GET_CODE (op0) == ASHIFT && GET_CODE (op1) == LSHIFTRT)\n-\t   || (GET_CODE (op1) == ASHIFT && GET_CODE (op0) == LSHIFTRT))\n-\t  && rtx_equal_p (XEXP (op0, 0), XEXP (op1, 0))\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (op1, 1)) == CONST_INT\n-\t  && (INTVAL (XEXP (op0, 1)) + INTVAL (XEXP (op1, 1))\n-\t      == GET_MODE_BITSIZE (mode)))\n-\treturn gen_rtx_ROTATE (mode, XEXP (op0, 0),\n-\t\t\t       (GET_CODE (op0) == ASHIFT\n-\t\t\t\t? XEXP (op0, 1) : XEXP (op1, 1)));\n-\n       break;\n \n     default:"}, {"sha": "5ea6129de8046fb7bf966579718c08c8ebcbfe39", "filename": "gcc/fold-const.c", "status": "modified", "additions": 89, "deletions": 75, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=79e8185c9ccfcb580b8b1bb81b49bdb44e4d97e2", "patch": "@@ -4874,6 +4874,74 @@ fold (expr)\n       else if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (arg1)))\n \treturn non_lvalue (convert (type, arg0));\n \n+     bit_rotate:\n+      /* (A << C1) + (A >> C2) if A is unsigned and C1+C2 is the size of A\n+\t is a rotate of A by C1 bits.  */\n+      /* (A << B) + (A >> (Z - B)) if A is unsigned and Z is the size of A\n+\t is a rotate of A by B bits.  */\n+      {\n+        register enum tree_code code0, code1;\n+        code0 = TREE_CODE (arg0);\n+        code1 = TREE_CODE (arg1);\n+        if (((code0 == RSHIFT_EXPR && code1 == LSHIFT_EXPR)\n+\t    || (code1 == RSHIFT_EXPR && code0 == LSHIFT_EXPR))\n+\t    && operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t        TREE_OPERAND (arg1,0), 0)\n+\t    && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n+\t  {\n+\t    register tree tree01, tree11;\n+\t    register enum tree_code code01, code11;\n+\n+\t    tree01 = TREE_OPERAND (arg0, 1);\n+\t    tree11 = TREE_OPERAND (arg1, 1);\n+\t    STRIP_NOPS (tree01);\n+\t    STRIP_NOPS (tree11);\n+\t    code01 = TREE_CODE (tree01);\n+\t    code11 = TREE_CODE (tree11);\n+\t    if (code01 == INTEGER_CST\n+\t      && code11 == INTEGER_CST\n+\t      && TREE_INT_CST_HIGH (tree01) == 0\n+\t      && TREE_INT_CST_HIGH (tree11) == 0\n+\t      && ((TREE_INT_CST_LOW (tree01) + TREE_INT_CST_LOW (tree11))\n+\t        == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n+\t      return build (LROTATE_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t        code0 == LSHIFT_EXPR ? tree01 : tree11);\n+\t    else if (code11 == MINUS_EXPR)\n+\t      {\n+\t        tree tree110, tree111;\n+\t        tree110 = TREE_OPERAND (tree11, 0);\n+\t        tree111 = TREE_OPERAND (tree11, 1);\n+\t        STRIP_NOPS (tree110);\n+\t        STRIP_NOPS (tree111);\n+\t        if (TREE_CODE (tree110) == INTEGER_CST\n+\t\t    && TREE_INT_CST_HIGH (tree110) == 0\n+\t\t    && (TREE_INT_CST_LOW (tree110)\n+\t\t        == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n+\t\t    && operand_equal_p (tree01, tree111, 0))\n+\t\t  return build ((code0 == LSHIFT_EXPR \n+\t\t\t         ? LROTATE_EXPR \n+\t\t\t         : RROTATE_EXPR),\n+\t\t\t        type, TREE_OPERAND (arg0, 0), tree01);\n+\t      }\n+\t    else if (code01 == MINUS_EXPR)\n+\t      {\n+\t        tree tree010, tree011;\n+\t        tree010 = TREE_OPERAND (tree01, 0);\n+\t        tree011 = TREE_OPERAND (tree01, 1);\n+\t        STRIP_NOPS (tree010);\n+\t        STRIP_NOPS (tree011);\n+\t        if (TREE_CODE (tree010) == INTEGER_CST\n+\t\t    && TREE_INT_CST_HIGH (tree010) == 0\n+\t\t    && (TREE_INT_CST_LOW (tree010)\n+\t\t        == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n+\t\t    && operand_equal_p (tree11, tree011, 0))\n+\t\t  return build ((code0 != LSHIFT_EXPR \n+\t\t\t         ? LROTATE_EXPR \n+\t\t\t         : RROTATE_EXPR),\n+\t\t\t         type, TREE_OPERAND (arg0, 0), tree11);\n+\t      }\n+\t  }\n+      }\n \n     associate:\n       /* In most languages, can't associate operations on floats\n@@ -5107,9 +5175,6 @@ fold (expr)\n \n     case BIT_IOR_EXPR:\n     bit_ior:\n-      {\n-      register enum tree_code code0, code1;\n-\n       if (integer_all_onesp (arg1))\n \treturn omit_one_operand (type, arg1, arg0);\n       if (integer_zerop (arg1))\n@@ -5118,85 +5183,34 @@ fold (expr)\n       if (t1 != NULL_TREE)\n \treturn t1;\n \n-     bit_rotate:\n-      /* (A << C1) | (A >> C2) if A is unsigned and C1+C2 is the size of A\n-\t is a rotate of A by C1 bits.  */\n-      /* (A << B) | (A >> (Z - B)) if A is unsigned and Z is the size of A\n-\t is a rotate of A by B bits.  */\n-\n-      /* Both transformations noted above also apply to when the inner\n-\t operation is an XOR.  */\n-\n-      code0 = TREE_CODE (arg0);\n-      code1 = TREE_CODE (arg1);\n-      if (((code0 == RSHIFT_EXPR && code1 == LSHIFT_EXPR)\n-\t  || (code1 == RSHIFT_EXPR && code0 == LSHIFT_EXPR))\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg1,0), 0)\n-\t  && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n-\t{\n-\t  register tree tree01, tree11;\n-\t  register enum tree_code code01, code11;\n-\n-\t  tree01 = TREE_OPERAND (arg0, 1);\n-\t  tree11 = TREE_OPERAND (arg1, 1);\n-\t  STRIP_NOPS (tree01);\n-\t  STRIP_NOPS (tree11);\n-\t  code01 = TREE_CODE (tree01);\n-\t  code11 = TREE_CODE (tree11);\n-\t  if (code01 == INTEGER_CST\n-\t    && code11 == INTEGER_CST\n-\t    && TREE_INT_CST_HIGH (tree01) == 0\n-\t    && TREE_INT_CST_HIGH (tree11) == 0\n-\t    && ((TREE_INT_CST_LOW (tree01) + TREE_INT_CST_LOW (tree11))\n-\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n-\t    return build (LROTATE_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t      code0 == LSHIFT_EXPR ? tree01 : tree11);\n-\t  else if (code11 == MINUS_EXPR)\n-\t    {\n-\t      tree tree110, tree111;\n-\t      tree110 = TREE_OPERAND (tree11, 0);\n-\t      tree111 = TREE_OPERAND (tree11, 1);\n-\t      STRIP_NOPS (tree110);\n-\t      STRIP_NOPS (tree111);\n-\t      if (TREE_CODE (tree110) == INTEGER_CST\n-\t\t  && TREE_INT_CST_HIGH (tree110) == 0\n-\t\t  && (TREE_INT_CST_LOW (tree110)\n-\t\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n-\t\t  && operand_equal_p (tree01, tree111, 0))\n-\t\treturn build ((code0 == LSHIFT_EXPR \n-\t\t\t       ? LROTATE_EXPR \n-\t\t\t       : RROTATE_EXPR),\n-\t\t\t      type, TREE_OPERAND (arg0, 0), tree01);\n-\t    }\n-\t  else if (code01 == MINUS_EXPR)\n-\t    {\n-\t      tree tree010, tree011;\n-\t      tree010 = TREE_OPERAND (tree01, 0);\n-\t      tree011 = TREE_OPERAND (tree01, 1);\n-\t      STRIP_NOPS (tree010);\n-\t      STRIP_NOPS (tree011);\n-\t      if (TREE_CODE (tree010) == INTEGER_CST\n-\t\t  && TREE_INT_CST_HIGH (tree010) == 0\n-\t\t  && (TREE_INT_CST_LOW (tree010)\n-\t\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n-\t\t  && operand_equal_p (tree11, tree011, 0))\n-\t\treturn build ((code0 != LSHIFT_EXPR \n-\t\t\t       ? LROTATE_EXPR \n-\t\t\t       : RROTATE_EXPR),\n-\t\t\t       type, TREE_OPERAND (arg0, 0), tree11);\n-\t    }\n-\t}\n-\n-      goto associate;\n-      }\n+      /* See if this can be simplified into a rotate first.  If that\n+\t is unsuccessful continue in the association code.  */\n+      goto bit_rotate;\n \n     case BIT_XOR_EXPR:\n       if (integer_zerop (arg1))\n \treturn non_lvalue (convert (type, arg0));\n       if (integer_all_onesp (arg1))\n \treturn fold (build1 (BIT_NOT_EXPR, type, arg0));\n+\n+      /* If we are XORing two BIT_AND_EXPR's, both of which are and'ing\n+         with a constant, and the two constants have no bits in common,\n+\t we should treat this as a BIT_IOR_EXPR since this may produce more\n+\t simplifications.  */\n+      if (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && TREE_CODE (arg1) == BIT_AND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+\t  && TREE_CODE (TREE_OPERAND (arg1, 1)) == INTEGER_CST\n+\t  && integer_zerop (const_binop (BIT_AND_EXPR,\n+\t\t\t\t\t TREE_OPERAND (arg0, 1),\n+\t\t\t\t\t TREE_OPERAND (arg1, 1), 0)))\n+        {\n+           code = BIT_IOR_EXPR;\n+\t   goto bit_ior;\n+        }\n+\n       /* See if this can be simplified into a rotate first.  If that\n-\t is unsuccessful we will jump to the association code.  */\n+\t is unsuccessful continue in the association code.  */\n       goto bit_rotate;\n \n     case BIT_AND_EXPR:"}]}