{"sha": "04b80dbb54360ddefb7c7303063141d811bf3d16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRiODBkYmI1NDM2MGRkZWZiN2M3MzAzMDYzMTQxZDgxMWJmM2QxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-01-02T11:43:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-01-02T11:43:59Z"}, "message": "gcc/\n\t* builtins.c (expand_builtin_mathfn, expand_builtin_mathfn_2)\n\t(expand_builtin_mathfn_ternary, expand_builtin_mathfn_3)\n\t(expand_builtin_int_roundingfn_2): Keep the original target around\n\tfor the fallback case.\n\nFrom-SVN: r194801", "tree": {"sha": "1683eb7ab2e71b0e623d654d08d69bc002c69f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1683eb7ab2e71b0e623d654d08d69bc002c69f16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04b80dbb54360ddefb7c7303063141d811bf3d16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b80dbb54360ddefb7c7303063141d811bf3d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04b80dbb54360ddefb7c7303063141d811bf3d16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b80dbb54360ddefb7c7303063141d811bf3d16/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "635b0b0cfcbad6c9807d58307d316072f1303011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635b0b0cfcbad6c9807d58307d316072f1303011", "html_url": "https://github.com/Rust-GCC/gccrs/commit/635b0b0cfcbad6c9807d58307d316072f1303011"}], "stats": {"total": 91, "additions": 46, "deletions": 45}, "files": [{"sha": "73bd92e71baa48c225c7160de66c03c2a3c1702f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04b80dbb54360ddefb7c7303063141d811bf3d16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04b80dbb54360ddefb7c7303063141d811bf3d16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04b80dbb54360ddefb7c7303063141d811bf3d16", "patch": "@@ -1,3 +1,10 @@\n+2013-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* builtins.c (expand_builtin_mathfn, expand_builtin_mathfn_2)\n+\t(expand_builtin_mathfn_ternary, expand_builtin_mathfn_3)\n+\t(expand_builtin_int_roundingfn_2): Keep the original target around\n+\tfor the fallback case.\n+\n 2013-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* tree-vrp.c (range_fits_type_p): Require the MSB of the double_int"}, {"sha": "67c96df2689b654cb32e50e3399ad72c3979796e", "filename": "gcc/builtins.c", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04b80dbb54360ddefb7c7303063141d811bf3d16/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04b80dbb54360ddefb7c7303063141d811bf3d16/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=04b80dbb54360ddefb7c7303063141d811bf3d16", "patch": "@@ -2031,7 +2031,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n   if (optab_handler (builtin_optab, mode) != CODE_FOR_nothing\n       && (!errno_set || !optimize_insn_for_size_p ()))\n     {\n-      target = gen_reg_rtx (mode);\n+      rtx result = gen_reg_rtx (mode);\n \n       /* Wrap the computation of the argument in a SAVE_EXPR, as we may\n \t need to expand the argument again.  This way, we will not perform\n@@ -2042,20 +2042,20 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n \n       start_sequence ();\n \n-      /* Compute into TARGET.\n-\t Set TARGET to wherever the result comes back.  */\n-      target = expand_unop (mode, builtin_optab, op0, target, 0);\n+      /* Compute into RESULT.\n+\t Set RESULT to wherever the result comes back.  */\n+      result = expand_unop (mode, builtin_optab, op0, result, 0);\n \n-      if (target != 0)\n+      if (result != 0)\n \t{\n \t  if (errno_set)\n-\t    expand_errno_check (exp, target);\n+\t    expand_errno_check (exp, result);\n \n \t  /* Output the entire sequence.  */\n \t  insns = get_insns ();\n \t  end_sequence ();\n \t  emit_insn (insns);\n-\t  return target;\n+\t  return result;\n \t}\n \n       /* If we were unable to expand via the builtin, stop the sequence\n@@ -2078,7 +2078,7 @@ static rtx\n expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n {\n   optab builtin_optab;\n-  rtx op0, op1, insns;\n+  rtx op0, op1, insns, result;\n   int op1_type = REAL_TYPE;\n   tree fndecl = get_callee_fndecl (exp);\n   tree arg0, arg1;\n@@ -2134,7 +2134,7 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   if (optab_handler (builtin_optab, mode) == CODE_FOR_nothing)\n     return NULL_RTX;\n \n-  target = gen_reg_rtx (mode);\n+  result = gen_reg_rtx (mode);\n \n   if (! flag_errno_math || ! HONOR_NANS (mode))\n     errno_set = false;\n@@ -2151,29 +2151,29 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n \n   start_sequence ();\n \n-  /* Compute into TARGET.\n-     Set TARGET to wherever the result comes back.  */\n-  target = expand_binop (mode, builtin_optab, op0, op1,\n-\t\t\t target, 0, OPTAB_DIRECT);\n+  /* Compute into RESULT.\n+     Set RESULT to wherever the result comes back.  */\n+  result = expand_binop (mode, builtin_optab, op0, op1,\n+\t\t\t result, 0, OPTAB_DIRECT);\n \n   /* If we were unable to expand via the builtin, stop the sequence\n      (without outputting the insns) and call to the library function\n      with the stabilized argument list.  */\n-  if (target == 0)\n+  if (result == 0)\n     {\n       end_sequence ();\n       return expand_call (exp, target, target == const0_rtx);\n     }\n \n   if (errno_set)\n-    expand_errno_check (exp, target);\n+    expand_errno_check (exp, result);\n \n   /* Output the entire sequence.  */\n   insns = get_insns ();\n   end_sequence ();\n   emit_insn (insns);\n \n-  return target;\n+  return result;\n }\n \n /* Expand a call to the builtin trinary math functions (fma).\n@@ -2187,7 +2187,7 @@ static rtx\n expand_builtin_mathfn_ternary (tree exp, rtx target, rtx subtarget)\n {\n   optab builtin_optab;\n-  rtx op0, op1, op2, insns;\n+  rtx op0, op1, op2, insns, result;\n   tree fndecl = get_callee_fndecl (exp);\n   tree arg0, arg1, arg2;\n   enum machine_mode mode;\n@@ -2214,7 +2214,7 @@ expand_builtin_mathfn_ternary (tree exp, rtx target, rtx subtarget)\n   if (optab_handler (builtin_optab, mode) == CODE_FOR_nothing)\n     return NULL_RTX;\n \n-  target = gen_reg_rtx (mode);\n+  result = gen_reg_rtx (mode);\n \n   /* Always stabilize the argument list.  */\n   CALL_EXPR_ARG (exp, 0) = arg0 = builtin_save_expr (arg0);\n@@ -2227,15 +2227,15 @@ expand_builtin_mathfn_ternary (tree exp, rtx target, rtx subtarget)\n \n   start_sequence ();\n \n-  /* Compute into TARGET.\n-     Set TARGET to wherever the result comes back.  */\n-  target = expand_ternary_op (mode, builtin_optab, op0, op1, op2,\n-\t\t\t      target, 0);\n+  /* Compute into RESULT.\n+     Set RESULT to wherever the result comes back.  */\n+  result = expand_ternary_op (mode, builtin_optab, op0, op1, op2,\n+\t\t\t      result, 0);\n \n   /* If we were unable to expand via the builtin, stop the sequence\n      (without outputting the insns) and call to the library function\n      with the stabilized argument list.  */\n-  if (target == 0)\n+  if (result == 0)\n     {\n       end_sequence ();\n       return expand_call (exp, target, target == const0_rtx);\n@@ -2246,7 +2246,7 @@ expand_builtin_mathfn_ternary (tree exp, rtx target, rtx subtarget)\n   end_sequence ();\n   emit_insn (insns);\n \n-  return target;\n+  return result;\n }\n \n /* Expand a call to the builtin sin and cos math functions.\n@@ -2298,7 +2298,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n   /* Before working hard, check whether the instruction is available.  */\n   if (optab_handler (builtin_optab, mode) != CODE_FOR_nothing)\n     {\n-      target = gen_reg_rtx (mode);\n+      rtx result = gen_reg_rtx (mode);\n \n       /* Wrap the computation of the argument in a SAVE_EXPR, as we may\n \t need to expand the argument again.  This way, we will not perform\n@@ -2309,37 +2309,35 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n \n       start_sequence ();\n \n-      /* Compute into TARGET.\n-\t Set TARGET to wherever the result comes back.  */\n+      /* Compute into RESULT.\n+\t Set RESULT to wherever the result comes back.  */\n       if (builtin_optab == sincos_optab)\n \t{\n-\t  int result;\n+\t  int ok;\n \n \t  switch (DECL_FUNCTION_CODE (fndecl))\n \t    {\n \t    CASE_FLT_FN (BUILT_IN_SIN):\n-\t      result = expand_twoval_unop (builtin_optab, op0, 0, target, 0);\n+\t      ok = expand_twoval_unop (builtin_optab, op0, 0, result, 0);\n \t      break;\n \t    CASE_FLT_FN (BUILT_IN_COS):\n-\t      result = expand_twoval_unop (builtin_optab, op0, target, 0, 0);\n+\t      ok = expand_twoval_unop (builtin_optab, op0, result, 0, 0);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n-\t  gcc_assert (result);\n+\t  gcc_assert (ok);\n \t}\n       else\n-\t{\n-\t  target = expand_unop (mode, builtin_optab, op0, target, 0);\n-\t}\n+\tresult = expand_unop (mode, builtin_optab, op0, result, 0);\n \n-      if (target != 0)\n+      if (result != 0)\n \t{\n \t  /* Output the entire sequence.  */\n \t  insns = get_insns ();\n \t  end_sequence ();\n \t  emit_insn (insns);\n-\t  return target;\n+\t  return result;\n \t}\n \n       /* If we were unable to expand via the builtin, stop the sequence\n@@ -2348,9 +2346,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n       end_sequence ();\n     }\n \n-  target = expand_call (exp, target, target == const0_rtx);\n-\n-  return target;\n+  return expand_call (exp, target, target == const0_rtx);\n }\n \n /* Given an interclass math builtin decl FNDECL and it's argument ARG\n@@ -2819,7 +2815,7 @@ expand_builtin_int_roundingfn_2 (tree exp, rtx target)\n   /* There's no easy way to detect the case we need to set EDOM.  */\n   if (!flag_errno_math)\n     {\n-      target = gen_reg_rtx (mode);\n+      rtx result = gen_reg_rtx (mode);\n \n       /* Wrap the computation of the argument in a SAVE_EXPR, as we may\n \t need to expand the argument again.  This way, we will not perform\n@@ -2830,13 +2826,13 @@ expand_builtin_int_roundingfn_2 (tree exp, rtx target)\n \n       start_sequence ();\n \n-      if (expand_sfix_optab (target, op0, builtin_optab))\n+      if (expand_sfix_optab (result, op0, builtin_optab))\n \t{\n \t  /* Output the entire sequence.  */\n \t  insns = get_insns ();\n \t  end_sequence ();\n \t  emit_insn (insns);\n-\t  return target;\n+\t  return result;\n \t}\n \n       /* If we were unable to expand via the builtin, stop the sequence\n@@ -2863,9 +2859,7 @@ expand_builtin_int_roundingfn_2 (tree exp, rtx target)\n       return convert_to_mode (mode, target, 0);\n     }\n \n-  target = expand_call (exp, target, target == const0_rtx);\n-\n-  return target;\n+  return expand_call (exp, target, target == const0_rtx);\n }\n \n /* Expand a call to the powi built-in mathematical function.  Return NULL_RTX if"}]}