{"sha": "1a61c29f8ac1bb7a507a26a6e2069e01734f3a79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2MWMyOWY4YWMxYmI3YTUwN2EyNmE2ZTIwNjllMDE3MzRmM2E3OQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-03-18T12:45:22Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-03-18T12:45:22Z"}, "message": "Fix sparc-sun-solaris2 -O2 -fPIC bootstrap failure with gcse code.\n\n\t* loop.c (struct movable): New field move_insn_first.\n\t(scan_loop): In consec sets code, set it.  Clear it otherwise.\n\t(move_movables): In consec sets code, use it.  Copy REG_NOTES from\n\tp to i1 only if i1 does not have REG_NOTES.  Delete obsolete ifdefed\n\tout code.\n\nFrom-SVN: r18669", "tree": {"sha": "dc379393257fcf76e99c1a751828c8bf90045de4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc379393257fcf76e99c1a751828c8bf90045de4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a61c29f8ac1bb7a507a26a6e2069e01734f3a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a61c29f8ac1bb7a507a26a6e2069e01734f3a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a61c29f8ac1bb7a507a26a6e2069e01734f3a79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a61c29f8ac1bb7a507a26a6e2069e01734f3a79/comments", "author": null, "committer": null, "parents": [{"sha": "74ef3b26f3efc6b3c36aaf2bad21f035c8aa3ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74ef3b26f3efc6b3c36aaf2bad21f035c8aa3ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74ef3b26f3efc6b3c36aaf2bad21f035c8aa3ad1"}], "stats": {"total": 70, "additions": 47, "deletions": 23}, "files": [{"sha": "cb9b882c67b30b8fa45049ddd4ff4bd00499e747", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a61c29f8ac1bb7a507a26a6e2069e01734f3a79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a61c29f8ac1bb7a507a26a6e2069e01734f3a79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a61c29f8ac1bb7a507a26a6e2069e01734f3a79", "patch": "@@ -1,3 +1,11 @@\n+Wed Mar 18 12:43:20 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* loop.c (struct movable): New field move_insn_first.\n+\t(scan_loop): In consec sets code, set it.  Clear it otherwise.\n+\t(move_movables): In consec sets code, use it.  Copy REG_NOTES from\n+\tp to i1 only if i1 does not have REG_NOTES.  Delete obsolete ifdefed\n+\tout code.\n+\n Wed Mar 18 09:52:56 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* rtl.c (read_rtx): Fall back on homebrew atoll if HOST_WIDE_INT"}, {"sha": "5e3039f18ff3d5603a31c6500189123063d39efa", "filename": "gcc/loop.c", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a61c29f8ac1bb7a507a26a6e2069e01734f3a79/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a61c29f8ac1bb7a507a26a6e2069e01734f3a79/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=1a61c29f8ac1bb7a507a26a6e2069e01734f3a79", "patch": "@@ -262,6 +262,8 @@ struct movable\n \t\t\t\t   invariant.  */\n   unsigned int move_insn : 1;\t/* 1 means that we call emit_move_insn to\n \t\t\t\t   load SRC, rather than copying INSN.  */\n+  unsigned int move_insn_first:1;/* Same as above, if this is necessary for the\n+\t\t\t\t    first insn of a consecutive sets group.  */\n   unsigned int is_equiv : 1;\t/* 1 means a REG_EQUIV is present on INSN.  */\n   enum machine_mode savemode;   /* Nonzero means it is a mode for a low part\n \t\t\t\t   that we should avoid changing when clearing\n@@ -861,6 +863,7 @@ scan_loop (loop_start, end, nregs, unroll_p)\n \t      m->forces = 0;\n \t      m->partial = 0;\n \t      m->move_insn = move_insn;\n+\t      m->move_insn_first = 0;\n \t      m->is_equiv = (find_reg_note (p, REG_EQUIV, NULL_RTX) != 0);\n \t      m->savemode = VOIDmode;\n \t      m->regno = regno;\n@@ -885,6 +888,12 @@ scan_loop (loop_start, end, nregs, unroll_p)\n \n \t      if (m->consec > 0)\n \t\t{\n+\t\t  /* It is possible for the first instruction to have a\n+\t\t     REG_EQUAL note but a non-invariant SET_SRC, so we must\n+\t\t     remember the status of the first instruction in case\n+\t\t     the last instruction doesn't have a REG_EQUAL note.  */\n+\t\t  m->move_insn_first = m->move_insn;\n+\n \t\t  /* Skip this insn, not checking REG_LIBCALL notes.  */\n \t\t  p = next_nonnote_insn (p);\n \t\t  /* Skip the consecutive insns, if there are any.  */\n@@ -1943,20 +1952,41 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t\t    CALL_INSN_FUNCTION_USAGE (i1)\n \t\t\t      = copy_rtx (CALL_INSN_FUNCTION_USAGE (p));\n \t\t\t}\n+\t\t      else if (count == m->consec && m->move_insn_first)\n+\t\t\t{\n+\t\t\t  /* The SET_SRC might not be invariant, so we must\n+\t\t\t     use the REG_EQUAL note.  */\n+\t\t\t  start_sequence ();\n+\t\t\t  emit_move_insn (m->set_dest, m->set_src);\n+\t\t\t  temp = get_insns ();\n+\t\t\t  end_sequence ();\n+\n+\t\t\t  add_label_notes (m->set_src, temp);\n+\n+\t\t\t  i1 = emit_insns_before (temp, loop_start);\n+\t\t\t  if (! find_reg_note (i1, REG_EQUAL, NULL_RTX))\n+\t\t\t    REG_NOTES (i1)\n+\t\t\t      = gen_rtx_EXPR_LIST ((m->is_equiv ? REG_EQUIV\n+\t\t\t\t\t\t    : REG_EQUAL),\n+\t\t\t\t\t\t   m->set_src, REG_NOTES (i1));\n+\t\t\t}\n \t\t      else\n \t\t\ti1 = emit_insn_before (PATTERN (p), loop_start);\n \n-\t\t      REG_NOTES (i1) = REG_NOTES (p);\n+\t\t      if (REG_NOTES (i1) == 0)\n+\t\t\t{\n+\t\t\t  REG_NOTES (i1) = REG_NOTES (p);\n \n-\t\t      /* If there is a REG_EQUAL note present whose value is\n-\t\t\t not loop invariant, then delete it, since it may\n-\t\t\t cause problems with later optimization passes.\n-\t\t\t It is possible for cse to create such notes\n-\t\t\t like this as a result of record_jump_cond.  */\n+\t\t\t  /* If there is a REG_EQUAL note present whose value\n+\t\t\t     is not loop invariant, then delete it, since it\n+\t\t\t     may cause problems with later optimization passes.\n+\t\t\t     It is possible for cse to create such notes\n+\t\t\t     like this as a result of record_jump_cond.  */\n \t\t      \n-\t\t      if ((temp = find_reg_note (i1, REG_EQUAL, NULL_RTX))\n-\t\t\t  && ! invariant_p (XEXP (temp, 0)))\n-\t\t\tremove_note (i1, temp);\n+\t\t\t  if ((temp = find_reg_note (i1, REG_EQUAL, NULL_RTX))\n+\t\t\t      && ! invariant_p (XEXP (temp, 0)))\n+\t\t\t    remove_note (i1, temp);\n+\t\t\t}\n \n \t\t      if (new_start == 0)\n \t\t\tnew_start = i1;\n@@ -1965,20 +1995,6 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t\tfprintf (loop_dump_stream, \" moved to %d\",\n \t\t\t\t INSN_UID (i1));\n \n-#if 0\n-\t\t      /* This isn't needed because REG_NOTES is copied\n-\t\t\t below and is wrong since P might be a PARALLEL.  */\n-\t\t      if (REG_NOTES (i1) == 0\n-\t\t\t  && ! m->partial /* But not if it's a zero-extend clr.  */\n-\t\t\t  && ! m->global /* and not if used outside the loop\n-\t\t\t\t\t    (since it might get set outside).  */\n-\t\t\t  && CONSTANT_P (SET_SRC (PATTERN (p))))\n-\t\t\tREG_NOTES (i1)\n-\t\t\t  = gen_rtx_EXPR_LIST (REG_EQUAL,\n-\t\t\t\t\t       SET_SRC (PATTERN (p)),\n-\t\t\t\t\t       REG_NOTES (i1));\n-#endif\n-\n \t\t      /* If library call, now fix the REG_NOTES that contain\n \t\t\t insn pointers, namely REG_LIBCALL on FIRST\n \t\t\t and REG_RETVAL on I1.  */"}]}