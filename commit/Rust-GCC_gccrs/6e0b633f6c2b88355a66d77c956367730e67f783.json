{"sha": "6e0b633f6c2b88355a66d77c956367730e67f783", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwYjYzM2Y2YzJiODgzNTVhNjZkNzdjOTU2MzY3NzMwZTY3Zjc4Mw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2006-11-14T08:46:26Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-11-14T08:46:26Z"}, "message": "re PR rtl-optimization/29798 (-O2 gives wrong results)\n\n2006-11-14  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR rtl-optimization/29798\n\n\t* fwprop.c (use_killed_between): Check that DEF_INSN dominates\n\tTARGET_INSN before any other check.\n\t(fwprop_init): Always calculate dominators.\n\t(fwprop_done): Always free them.\n\n2006-11-14  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR rtl-optimization/29798\n\n\t* gcc.c-torture/execute/pr29798.c: New.\n\nFrom-SVN: r118808", "tree": {"sha": "c55d31f7d81769bc6d0eda9eb0cb9aac25e6818f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c55d31f7d81769bc6d0eda9eb0cb9aac25e6818f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e0b633f6c2b88355a66d77c956367730e67f783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0b633f6c2b88355a66d77c956367730e67f783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e0b633f6c2b88355a66d77c956367730e67f783", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0b633f6c2b88355a66d77c956367730e67f783/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7e85170cf309a3a6e9f3049c61632f7c9284547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e85170cf309a3a6e9f3049c61632f7c9284547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e85170cf309a3a6e9f3049c61632f7c9284547"}], "stats": {"total": 80, "additions": 59, "deletions": 21}, "files": [{"sha": "d1f36dfa6b7f244bbdee803a7fe04ea487d240ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0b633f6c2b88355a66d77c956367730e67f783/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0b633f6c2b88355a66d77c956367730e67f783/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e0b633f6c2b88355a66d77c956367730e67f783", "patch": "@@ -1,3 +1,12 @@\n+2006-11-14  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR rtl-optimization/29798\n+\n+\t* fwprop.c (use_killed_between): Check that DEF_INSN dominates\n+\tTARGET_INSN before any other check.\n+\t(fwprop_init): Always calculate dominators.\n+\t(fwprop_done): Always free them.\n+\n 2006-11-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* fold-const.c (fold_strip_sign_ops): Handle COMPOUND_EXPR and"}, {"sha": "fb601e1a4f00367b6fb7e160af35b5c768bbfb30", "filename": "gcc/fwprop.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0b633f6c2b88355a66d77c956367730e67f783/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0b633f6c2b88355a66d77c956367730e67f783/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=6e0b633f6c2b88355a66d77c956367730e67f783", "patch": "@@ -466,33 +466,32 @@ local_ref_killed_between_p (struct df_ref * ref, rtx from, rtx to)\n static bool\n use_killed_between (struct df_ref *use, rtx def_insn, rtx target_insn)\n {\n-  basic_block def_bb, target_bb;\n+  basic_block def_bb = BLOCK_FOR_INSN (def_insn);\n+  basic_block target_bb = BLOCK_FOR_INSN (target_insn);\n   int regno;\n   struct df_ref * def;\n \n+  /* In some obscure situations we can have a def reaching a use\n+     that is _before_ the def.  In other words the def does not\n+     dominate the use even though the use and def are in the same\n+     basic block.  This can happen when a register may be used\n+     uninitialized in a loop.  In such cases, we must assume that\n+     DEF is not available.  */\n+  if (def_bb == target_bb\n+      ? DF_INSN_LUID (df, def_insn) >= DF_INSN_LUID (df, target_insn)\n+      : !dominated_by_p (CDI_DOMINATORS, target_bb, def_bb))\n+    return true;\n+\n   /* Check if the reg in USE has only one definition.  We already\n      know that this definition reaches use, or we wouldn't be here.  */\n   regno = DF_REF_REGNO (use);\n   def = DF_REG_DEF_GET (df, regno)->reg_chain;\n   if (def && (def->next_reg == NULL))\n     return false;\n \n-  /* Check if we are in the same basic block.  */\n-  def_bb = BLOCK_FOR_INSN (def_insn);\n-  target_bb = BLOCK_FOR_INSN (target_insn);\n+  /* Check locally if we are in the same basic block.  */\n   if (def_bb == target_bb)\n-    {\n-      /* In some obscure situations we can have a def reaching a use\n-\t that is _before_ the def.  In other words the def does not\n-\t dominate the use even though the use and def are in the same\n-\t basic block.  This can happen when a register may be used\n-\t uninitialized in a loop.  In such cases, we must assume that\n-\t DEF is not available.  */\n-      if (DF_INSN_LUID (df, def_insn) >= DF_INSN_LUID (df, target_insn))\n-\treturn true;\n-\n-      return local_ref_killed_between_p (use, def_insn, target_insn);\n-    }\n+    return local_ref_killed_between_p (use, def_insn, target_insn);\n \n   /* Finally, if DEF_BB is the sole predecessor of TARGET_BB.  */\n   if (single_pred_p (target_bb)\n@@ -890,16 +889,14 @@ static void\n fwprop_init (void)\n {\n   num_changes = 0;\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n   /* We do not always want to propagate into loops, so we have to find\n      loops and be careful about them.  But we have to call flow_loops_find\n      before df_analyze, because flow_loops_find may introduce new jump\n      insns (sadly) if we are not working in cfglayout mode.  */\n   if (flag_rerun_cse_after_loop && (flag_unroll_loops || flag_peel_loops))\n-    {\n-      calculate_dominance_info (CDI_DOMINATORS);\n-      flow_loops_find (&loops);\n-    }\n+    flow_loops_find (&loops);\n \n   /* Now set up the dataflow problem (we only want use-def chains) and\n      put the dataflow solver to work.  */\n@@ -917,10 +914,10 @@ fwprop_done (void)\n   if (flag_rerun_cse_after_loop && (flag_unroll_loops || flag_peel_loops))\n     {\n       flow_loops_free (&loops);\n-      free_dominance_info (CDI_DOMINATORS);\n       loops.num = 0;\n     }\n \n+  free_dominance_info (CDI_DOMINATORS);\n   cleanup_cfg (0);\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n "}, {"sha": "9693e4da1aafa1a7ba333508c751bf6ce83349f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0b633f6c2b88355a66d77c956367730e67f783/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0b633f6c2b88355a66d77c956367730e67f783/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e0b633f6c2b88355a66d77c956367730e67f783", "patch": "@@ -1,3 +1,9 @@\n+2006-11-14  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR rtl-optimization/29798\n+\n+\t* gcc.c-torture/execute/pr29798.c: New.\n+\n 2006-11-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/builtins-20.c: Add more cases."}, {"sha": "f7b90da02000fb7e2201c7b2f7e38dafd32c641b", "filename": "gcc/testsuite/gcc.c-torture/execute/pr29798.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0b633f6c2b88355a66d77c956367730e67f783/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr29798.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0b633f6c2b88355a66d77c956367730e67f783/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr29798.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr29798.c?ref=6e0b633f6c2b88355a66d77c956367730e67f783", "patch": "@@ -0,0 +1,26 @@\n+extern void abort ();\n+\n+int\n+main ()\n+{\n+  int i;\n+  double oldrho;\n+  double beta = 0.0;\n+  double work = 1.0;\n+  for (i = 1; i <= 2; i++)\n+    {\n+      double rho = work * work;\n+      if (i != 1)\n+        beta = rho / oldrho;\n+      if (beta == 1.0)\n+        abort ();\n+\n+      /* All targets even remotely likely to ever get supported\n+\t use at least an even base, so there will never be any\n+\t floating-point rounding. All computation in this test\n+\t case is exact for even bases.  */\n+      work /= 2.0;\n+      oldrho = rho;\n+    }\n+  return 0;\n+}"}]}