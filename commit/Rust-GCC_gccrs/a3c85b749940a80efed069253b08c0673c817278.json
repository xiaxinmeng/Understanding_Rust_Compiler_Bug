{"sha": "a3c85b749940a80efed069253b08c0673c817278", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNjODViNzQ5OTQwYTgwZWZlZDA2OTI1M2IwOGMwNjczYzgxNzI3OA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2010-08-27T21:24:13Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2010-08-27T21:24:13Z"}, "message": "re PR fortran/32049 (Support on x86_64 also kind=16)\n\n\tPR fortran/32049\n\n\t* gfortran.h (gfc_real_info): Add c_float128 field.\n\t* mathbuiltins.def: Indicate which builtins are const.\n\t* trans-types.h (float128_type_node, complex_float128_type_node,\n\tgfc_real16_is_float128): New variables.\n\t* trans-types.c (float128_type_node, complex_float128_type_node,\n\tgfc_real16_is_float128): New variables.\n\t(gfc_init_kinds): Allow TFmode.\n\t(gfc_build_real_type): Mark __float128 types as such.\n\t(gfc_init_types): Initialize float128_type_node and\n\tcomplex_float128_type_node\n\t* f95-lang.c (gfc_init_builtin_functions): Adjust for new\n\targument of OTHER_BUILTIN macro.\n\t* trans-intrinsic.c (gfc_intrinsic_map_t): Likewise.\n\t(builtin_decl_for_precision): Special case for __float128.\n\t(builtin_decl_for_float_kind): Likewise.\n\t(define_quad_builtin): New function.\n\t(gfc_build_intrinsic_lib_fndecls): Create all __float128\n\tlibrary decls if necessary. Store them in the real16_decl and\n\tcomplex16_decl builtin map fields.\n\t(gfc_get_intrinsic_lib_fndecl): Handle q-suffixed __float128\n\tlibrary function names.\n\n\t* gfortran.dg/random_seed_1.f90: Adjust test.\n\t* gfortran.dg/float128_1.f90: New test.\n\nFrom-SVN: r163597", "tree": {"sha": "95a7a9868fbc4e7dc6996735a655e2232741c4a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95a7a9868fbc4e7dc6996735a655e2232741c4a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3c85b749940a80efed069253b08c0673c817278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3c85b749940a80efed069253b08c0673c817278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3c85b749940a80efed069253b08c0673c817278", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3c85b749940a80efed069253b08c0673c817278/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ba2db5e3323ac177a1d31cf8e562a1faba5a078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba2db5e3323ac177a1d31cf8e562a1faba5a078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ba2db5e3323ac177a1d31cf8e562a1faba5a078"}], "stats": {"total": 265, "additions": 236, "deletions": 29}, "files": [{"sha": "b98e37c8c88ec42382e4a234258ce9e6bc289147", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -1,3 +1,28 @@\n+2010-08-27  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/32049\n+\t* gfortran.h (gfc_real_info): Add c_float128 field.\n+\t* mathbuiltins.def: Indicate which builtins are const.\n+\t* trans-types.h (float128_type_node, complex_float128_type_node,\n+\tgfc_real16_is_float128): New variables.\n+\t* trans-types.c (float128_type_node, complex_float128_type_node,\n+\tgfc_real16_is_float128): New variables.\n+\t(gfc_init_kinds): Allow TFmode.\n+\t(gfc_build_real_type): Mark __float128 types as such.\n+\t(gfc_init_types): Initialize float128_type_node and\n+\tcomplex_float128_type_node\n+\t* f95-lang.c (gfc_init_builtin_functions): Adjust for new\n+\targument of OTHER_BUILTIN macro.\n+\t* trans-intrinsic.c (gfc_intrinsic_map_t): Likewise.\n+\t(builtin_decl_for_precision): Special case for __float128.\n+\t(builtin_decl_for_float_kind): Likewise.\n+\t(define_quad_builtin): New function.\n+\t(gfc_build_intrinsic_lib_fndecls): Create all __float128\n+\tlibrary decls if necessary. Store them in the real16_decl and\n+\tcomplex16_decl builtin map fields.\n+\t(gfc_get_intrinsic_lib_fndecl): Handle q-suffixed __float128\n+\tlibrary function names.\n+\n 2010-08-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/33197"}, {"sha": "91dc491032c79885ab287be738919e9d194cd7c8", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -788,7 +788,7 @@ gfc_init_builtin_functions (void)\n     build_function_type_list (void_type_node, ptype, ptype, NULL_TREE);\n \n /* Non-math builtins are defined manually, so they're not included here.  */\n-#define OTHER_BUILTIN(ID,NAME,TYPE)\n+#define OTHER_BUILTIN(ID,NAME,TYPE,CONST)\n \n #include \"mathbuiltins.def\"\n "}, {"sha": "66c378efbaf9041b4dd74484e0fe5df3205d743f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -1822,6 +1822,7 @@ typedef struct\n   unsigned int c_float : 1;\n   unsigned int c_double : 1;\n   unsigned int c_long_double : 1;\n+  unsigned int c_float128 : 1;\n }\n gfc_real_info;\n "}, {"sha": "074390e9631fe02b701652ea14100e7d6720b3f0", "filename": "gcc/fortran/mathbuiltins.def", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Fmathbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Fmathbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmathbuiltins.def?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -52,19 +52,19 @@ DEFINE_MATH_BUILTIN   (TGAMMA,\"tgamma\", 0)\n DEFINE_MATH_BUILTIN   (LGAMMA,\"lgamma\", 0)\n DEFINE_MATH_BUILTIN   (HYPOT, \"hypot\",  1)\n \n-/* OTHER_BUILTIN (CODE, NAME, PROTOTYPE_TYPE)\n+/* OTHER_BUILTIN (CODE, NAME, PROTOTYPE_TYPE, CONST)\n    For floating-point builtins that do not directly correspond to a\n    Fortran intrinsic. This is used to map the different variants (float,\n    double and long double) and to build the quad-precision decls.  */\n-OTHER_BUILTIN (CABS,      \"cabs\",      cabs)\n-OTHER_BUILTIN (COPYSIGN,  \"copysign\",  2)\n-OTHER_BUILTIN (FABS,      \"fabs\",      1)\n-OTHER_BUILTIN (FMOD,      \"fmod\",      2)\n-OTHER_BUILTIN (FREXP,     \"frexp\",     frexp)\n-OTHER_BUILTIN (HUGE_VAL,  \"huge_val\",  0)\n-OTHER_BUILTIN (LLROUND,   \"llround\",   llround)\n-OTHER_BUILTIN (LROUND,    \"lround\",    lround)\n-OTHER_BUILTIN (NEXTAFTER, \"nextafter\", 2)\n-OTHER_BUILTIN (ROUND,     \"round\",     1)\n-OTHER_BUILTIN (SCALBN,    \"scalbn\",    scalbn)\n-OTHER_BUILTIN (TRUNC,     \"trunc\",     1)\n+OTHER_BUILTIN (CABS,      \"cabs\",      cabs,    true)\n+OTHER_BUILTIN (COPYSIGN,  \"copysign\",  2,       true)\n+OTHER_BUILTIN (FABS,      \"fabs\",      1,       true)\n+OTHER_BUILTIN (FMOD,      \"fmod\",      2,       true)\n+OTHER_BUILTIN (FREXP,     \"frexp\",     frexp,   false)\n+OTHER_BUILTIN (HUGE_VAL,  \"huge_val\",  0,       true)\n+OTHER_BUILTIN (LLROUND,   \"llround\",   llround, true)\n+OTHER_BUILTIN (LROUND,    \"lround\",    lround,  true)\n+OTHER_BUILTIN (NEXTAFTER, \"nextafter\", 2,       true)\n+OTHER_BUILTIN (ROUND,     \"round\",     1,       true)\n+OTHER_BUILTIN (SCALBN,    \"scalbn\",    scalbn,  true)\n+OTHER_BUILTIN (TRUNC,     \"trunc\",     1,       true)"}, {"sha": "256cd8d67fcc7853f0dcfc0f53a294fcf9875407", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 121, "deletions": 8, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -105,10 +105,10 @@ gfc_intrinsic_map_t;\n     false, HAVE_COMPLEX, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, \\\n     NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE }\n \n-#define OTHER_BUILTIN(ID, NAME, TYPE) \\\n+#define OTHER_BUILTIN(ID, NAME, TYPE, CONST) \\\n   { GFC_ISYM_NONE, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, \\\n     BUILT_IN_ ## ID ## L, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n-    true, false, true, NAME, NULL_TREE, NULL_TREE, \\\n+    true, false, CONST, NAME, NULL_TREE, NULL_TREE, \\\n     NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n \n static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =\n@@ -151,6 +151,12 @@ builtin_decl_for_precision (enum built_in_function base_built_in,\n     i = m->double_built_in;\n   else if (precision == TYPE_PRECISION (long_double_type_node))\n     i = m->long_double_built_in;\n+  else if (precision == TYPE_PRECISION (float128_type_node))\n+    {\n+      /* Special treatment, because it is not exactly a built-in, but\n+\t a library function.  */\n+      return m->real16_decl;\n+    }\n \n   return (i == END_BUILTINS ? NULL_TREE : built_in_decls[i]);\n }\n@@ -160,6 +166,18 @@ static tree\n builtin_decl_for_float_kind (enum built_in_function double_built_in, int kind)\n {\n   int i = gfc_validate_kind (BT_REAL, kind, false);\n+\n+  if (gfc_real_kinds[i].c_float128)\n+    {\n+      /* For __float128, the story is a bit different, because we return\n+\t a decl to a library function rather than a built-in.  */\n+      gfc_intrinsic_map_t *m; \n+      for (m = gfc_intrinsic_map; m->double_built_in != double_built_in ; m++)\n+\t;\n+\n+      return m->real16_decl;\n+    }\n+\n   return builtin_decl_for_precision (double_built_in,\n \t\t\t\t     gfc_real_kinds[i].mode_precision);\n }\n@@ -557,13 +575,91 @@ gfc_conv_intrinsic_conjg (gfc_se * se, gfc_expr * expr)\n }\n \n \n+\n+static tree\n+define_quad_builtin (const char *name, tree type, bool is_const)\n+{\n+  tree fndecl;\n+  fndecl = build_decl (input_location, FUNCTION_DECL, get_identifier (name),\n+\t\t       type);\n+\n+  /* Mark the decl as external.  */\n+  DECL_EXTERNAL (fndecl) = 1;\n+  TREE_PUBLIC (fndecl) = 1;\n+\n+  /* Mark it __attribute__((const)).  */\n+  TREE_READONLY (fndecl) = is_const;\n+\n+  rest_of_decl_compilation (fndecl, 1, 0);\n+\n+  return fndecl;\n+}\n+\n+\n+\n /* Initialize function decls for library functions.  The external functions\n    are created as required.  Builtin functions are added here.  */\n \n void\n gfc_build_intrinsic_lib_fndecls (void)\n {\n   gfc_intrinsic_map_t *m;\n+  tree quad_decls[(int) END_BUILTINS];\n+\n+  if (gfc_real16_is_float128)\n+  {\n+    /* If we have soft-float types, we create the decls for their\n+       C99-like library functions.  For now, we only handle __float128\n+       q-suffixed functions.  */\n+\n+    tree tmp, func_0, func_1, func_2, func_cabs, func_frexp;\n+    tree func_lround, func_llround, func_scalbn;\n+\n+    memset (quad_decls, 0, sizeof(tree) * (int) END_BUILTINS);\n+\n+    /* type (*) (void) */\n+    func_0 = build_function_type (float128_type_node, void_list_node);\n+    /* type (*) (type) */\n+    tmp = tree_cons (NULL_TREE, float128_type_node, void_list_node);\n+    func_1 = build_function_type (float128_type_node, tmp);\n+    /* long (*) (type) */\n+    func_lround = build_function_type (long_integer_type_node, tmp);\n+    /* long long (*) (type) */\n+    func_llround = build_function_type (long_long_integer_type_node, tmp);\n+    /* type (*) (type, type) */\n+    tmp = tree_cons (NULL_TREE, float128_type_node, tmp);\n+    func_2 = build_function_type (float128_type_node, tmp);\n+    /* type (*) (type, &int) */\n+    tmp = tree_cons (NULL_TREE, float128_type_node, void_list_node);\n+    tmp = tree_cons (NULL_TREE, build_pointer_type (integer_type_node), tmp);\n+    func_frexp = build_function_type (float128_type_node, tmp);\n+    /* type (*) (type, int) */\n+    tmp = tree_cons (NULL_TREE, float128_type_node, void_list_node);\n+    tmp = tree_cons (NULL_TREE, integer_type_node, tmp);\n+    func_scalbn = build_function_type (float128_type_node, tmp);\n+    /* type (*) (complex type) */\n+    tmp = tree_cons (NULL_TREE, complex_float128_type_node, void_list_node);\n+    func_cabs = build_function_type (float128_type_node, tmp);\n+\n+#define DEFINE_MATH_BUILTIN(ID, NAME, ARGTYPE)\n+#define DEFINE_MATH_BUILTIN_C(ID, NAME, ARGTYPE)\n+#define LIB_FUNCTION(ID, NAME, HAVE_COMPLEX)\n+\n+    /* Only these built-ins are actually needed here. These are used directly\n+       from the code, when calling builtin_decl_for_precision() or\n+       builtin_decl_for_float_type(). The others are all constructed by\n+       gfc_get_intrinsic_lib_fndecl().  */\n+#define OTHER_BUILTIN(ID, NAME, TYPE, CONST) \\\n+  quad_decls[BUILT_IN_ ## ID] = define_quad_builtin (NAME \"q\", func_ ## TYPE, CONST);\n+\n+#include \"mathbuiltins.def\"\n+\n+#undef OTHER_BUILTIN\n+#undef LIB_FUNCTION\n+#undef DEFINE_MATH_BUILTIN\n+#undef DEFINE_MATH_BUILTIN_C\n+\n+  }\n \n   /* Add GCC builtin functions.  */\n   for (m = gfc_intrinsic_map;\n@@ -584,12 +680,26 @@ gfc_build_intrinsic_lib_fndecls (void)\n       if (m->complex_long_double_built_in != END_BUILTINS)\n \tm->complex10_decl = built_in_decls[m->complex_long_double_built_in];\n \n-      /* For now, we assume that if real(kind=16) exists, it is long double.\n-\t Later, we will deal with __float128 and break this assumption.  */\n-      if (m->long_double_built_in != END_BUILTINS)\n-\tm->real16_decl = built_in_decls[m->long_double_built_in];\n-      if (m->complex_long_double_built_in != END_BUILTINS)\n-\tm->complex16_decl = built_in_decls[m->complex_long_double_built_in];\n+      if (!gfc_real16_is_float128)\n+\t{\n+\t  if (m->long_double_built_in != END_BUILTINS)\n+\t    m->real16_decl = built_in_decls[m->long_double_built_in];\n+\t  if (m->complex_long_double_built_in != END_BUILTINS)\n+\t    m->complex16_decl = built_in_decls[m->complex_long_double_built_in];\n+\t}\n+      else if (quad_decls[m->double_built_in] != NULL_TREE)\n+        {\n+\t  /* Quad-precision function calls are constructed when first\n+\t     needed by builtin_decl_for_precision(), except for those\n+\t     that will be used directly (define by OTHER_BUILTIN).  */\n+\t  m->real16_decl = quad_decls[m->double_built_in];\n+\t}\n+      else if (quad_decls[m->complex_double_built_in] != NULL_TREE)\n+        {\n+\t  /* Same thing for the complex ones.  */\n+\t  m->complex16_decl = quad_decls[m->double_built_in];\n+\t  m->real16_decl = quad_decls[m->double_built_in];\n+\t}\n     }\n }\n \n@@ -668,6 +778,9 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n       else if (gfc_real_kinds[n].c_long_double)\n \tsnprintf (name, sizeof (name), \"%s%s%s\",\n \t\t  ts->type == BT_COMPLEX ? \"c\" : \"\", m->name, \"l\");\n+      else if (gfc_real_kinds[n].c_float128)\n+\tsnprintf (name, sizeof (name), \"%s%s%s\",\n+\t\t  ts->type == BT_COMPLEX ? \"c\" : \"\", m->name, \"q\");\n       else\n \tgcc_unreachable ();\n     }"}, {"sha": "348ffeae1ca086ad339aff40495df913e32eeb13", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -64,6 +64,11 @@ tree pfunc_type_node;\n \n tree gfc_charlen_type_node;\n \n+tree float128_type_node = NULL_TREE;\n+tree complex_float128_type_node = NULL_TREE;\n+\n+bool gfc_real16_is_float128 = false;\n+\n static GTY(()) tree gfc_desc_dim_type;\n static GTY(()) tree gfc_max_array_element_size;\n static GTY(()) tree gfc_array_descriptor_base[2 * GFC_MAX_DIMENSIONS];\n@@ -403,12 +408,14 @@ gfc_init_kinds (void)\n       if (!targetm.scalar_mode_supported_p ((enum machine_mode) mode))\n \tcontinue;\n \n-      /* Only let float/double/long double go through because the fortran\n-\t library assumes these are the only floating point types.  */\n-\n-      if (mode != TYPE_MODE (float_type_node)\n+      /* Only let float, double, long double and __float128 go through.\n+\t Runtime support for others is not provided, so they would be\n+\t useless.  TFmode support is only enabled with option\n+\t -fsoft-float. \t*/\n+\tif (mode != TYPE_MODE (float_type_node)\n \t  && (mode != TYPE_MODE (double_type_node))\n-          && (mode != TYPE_MODE (long_double_type_node)))\n+          && (mode != TYPE_MODE (long_double_type_node))\n+\t  && (mode != TFmode))\n \tcontinue;\n \n       /* Let the kind equal the precision divided by 8, rounding up.  Again,\n@@ -711,6 +718,11 @@ gfc_build_real_type (gfc_real_info *info)\n     info->c_double = 1;\n   if (mode_precision == LONG_DOUBLE_TYPE_SIZE)\n     info->c_long_double = 1;\n+  if (mode_precision != LONG_DOUBLE_TYPE_SIZE && mode_precision == 128)\n+    {\n+      info->c_float128 = 1;\n+      gfc_real16_is_float128 = true;\n+    }\n \n   if (TYPE_PRECISION (float_type_node) == mode_precision)\n     return float_type_node;\n@@ -835,11 +847,17 @@ gfc_init_types (void)\n \t\tgfc_real_kinds[index].kind);\n       PUSH_TYPE (name_buf, type);\n \n+      if (gfc_real_kinds[index].c_float128)\n+\tfloat128_type_node = type;\n+\n       type = gfc_build_complex_type (type);\n       gfc_complex_types[index] = type;\n       snprintf (name_buf, sizeof(name_buf), \"complex(kind=%d)\",\n \t\tgfc_real_kinds[index].kind);\n       PUSH_TYPE (name_buf, type);\n+\n+      if (gfc_real_kinds[index].c_float128)\n+\tcomplex_float128_type_node = type;\n     }\n \n   for (index = 0; gfc_character_kinds[index].kind != 0; ++index)"}, {"sha": "1741b9bf6605c2d23af1396fda997e2c58ad5889", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -31,13 +31,20 @@ extern GTY(()) tree ppvoid_type_node;\n extern GTY(()) tree pvoid_type_node;\n extern GTY(()) tree prvoid_type_node;\n extern GTY(()) tree pchar_type_node;\n+extern GTY(()) tree float128_type_node;\n+extern GTY(()) tree complex_float128_type_node;\n \n /* This is the type used to hold the lengths of character variables.\n    It must be the same as the corresponding definition in gfortran.h.  */\n /* TODO: This is still hardcoded as kind=4 in some bits of the compiler\n    and runtime library.  */\n extern GTY(()) tree gfc_charlen_type_node;\n \n+/* The following flags give us information on the correspondance of\n+   real (and complex) kinds with C floating-point types long double\n+   and __float128.  */\n+extern bool gfc_real16_is_float128;\n+\n typedef enum {\n   PACKED_NO = 0,\n   PACKED_PARTIAL,"}, {"sha": "8fc8458354fd7428ad084d9f5642077f8ac9f830", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -1,3 +1,9 @@\n+2010-08-27  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/32049\n+\t* gfortran.dg/random_seed_1.f90: Adjust test.\n+\t* gfortran.dg/float128_1.f90: New test.\n+\n 2010-08-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/33197"}, {"sha": "e045dce98e0222b1b9547a6f6c510ff1ca574f4d", "filename": "gcc/testsuite/gfortran.dg/float128_1.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ftestsuite%2Fgfortran.dg%2Ffloat128_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ftestsuite%2Fgfortran.dg%2Ffloat128_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffloat128_1.f90?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -0,0 +1,28 @@\n+! Check that __float128 can be used where it's supported\n+!\n+! { dg-do compile { target ia64-*-* i?86-*-* x86_64-*-* } }\n+! { dg-options \"-fdump-tree-original\" }\n+! { dg-final { scan-tree-dump \"sqrtq\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cabsq\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cosl\" \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+!\n+  real(kind=16) :: x1, x2\n+  complex(kind=16) :: z1, z2\n+\n+  real(kind=10) :: y\n+\n+  read (*,*) x1\n+  x2 = sqrt(x1)                         ! sqrtq\n+  z1 = x1 + (0._16 , 1.0_16)\n+  z2 = z1 / (1._16, 2._16)\n+\n+  x1 = abs(z2)                          ! cabsq\n+\n+\n+  y = 2\n+  y = cos(y)                            ! cosl\n+\n+  print *, x1, x2, z1, z2, y\n+\n+end"}, {"sha": "ccbcf00cf1286112f868adcd680a4bc1dd30da19", "filename": "gcc/testsuite/gfortran.dg/random_seed_1.f90", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c85b749940a80efed069253b08c0673c817278/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90?ref=a3c85b749940a80efed069253b08c0673c817278", "patch": "@@ -13,8 +13,17 @@\n \n PROGRAM random_seed_1\n   IMPLICIT NONE\n-  INTEGER, PARAMETER :: k = selected_real_kind (precision (0.0_8) + 1)\n-  INTEGER, PARAMETER :: nbytes = MERGE(48, 32, k == 16)\n+\n+  ! Find out what the's largest kind size\n+  INTEGER, PARAMETER :: k1 = kind (0.d0)\n+  INTEGER, PARAMETER :: &\n+    k2 = max (k1, selected_real_kind (precision (0._k1) + 1))\n+  INTEGER, PARAMETER :: &\n+    k3 = max (k2, selected_real_kind (precision (0._k2) + 1))\n+  INTEGER, PARAMETER :: &\n+    k4 = max (k3, selected_real_kind (precision (0._k3) + 1))\n+\n+  INTEGER, PARAMETER :: nbytes = MERGE(48, 32, k4 == 16)\n \n   ! '+1' to avoid out-of-bounds warnings\n   INTEGER, PARAMETER    :: n = nbytes / KIND(n) + 1"}]}