{"sha": "3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E2NmMyODlhM2YzOTVlNTBkZTc5NDI0ZTFlNmY0MDFhNGRjMWFiNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-04-08T13:46:03Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-04-08T13:46:03Z"}, "message": "analyzer: fix leak false +ves due to maybe-clobbered regions [PR99042,PR99774]\n\nPrior to this patch, program_state::detect_leaks worked by finding all\nlive svalues in the old state and in the new state, and calling\non_svalue_leak for each svalue that has changed from being live to\nnot being live.\n\nPR analyzer/99042 and PR analyzer/99774 both describe false leak\ndiagnostics from -fanalyzer (a false FILE * leak in git, and a false\nmalloc leak in qemu, respectively).\n\nIn both cases the root cause of the false leak diagnostic relates to\nsvalues no longer being explicitly bound in the store due to regions\nbeing conservatively clobbered, due to an unknown function being\ncalled, or due to a write through a pointer that could alias the\nregion, respectively.\n\nWe have a transition from an svalue being explicitly live to not\nbeing explicitly live - but only because the store is being\nconservative, clobbering the binding.  The leak detection is looking\nfor transitions from \"definitely live\" to \"not definitely live\",\nwhen it should be looking for transitions from \"definitely live\"\nto \"definitely not live\".\n\nThis patch introduces a new class to temporarily capture information\nabout svalues that were explicitly live, but for which a region bound\nto them got clobbered for conservative reasons.  This new\n\"uncertainty_t\" class is passed around to capture the data long enough\nfor use in program_state::detect_leaks, where it is used to only\ncomplain about svalues that were definitely live and are now both\nnot definitely live *or* possibly-live i.e. definitely not-live.\n\nThe class also captures for which svalues we can't meaningfully track\nsm-state anymore, and resets the svalues back to the \"start\" state.\n\nTogether, these changes fix the false leak reports.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/99042\n\tPR analyzer/99774\n\t* engine.cc\n\t(impl_region_model_context::impl_region_model_context): Add\n\tuncertainty param and use it to initialize m_uncertainty.\n\t(impl_region_model_context::get_uncertainty): New.\n\t(impl_sm_context::get_fndecl_for_call): Add NULL for new\n\tuncertainty param when constructing impl_region_model_context.\n\t(impl_sm_context::get_state): Likewise.\n\t(impl_sm_context::set_next_state): Likewise.\n\t(impl_sm_context::warn): Likewise.\n\t(exploded_node::on_stmt): Add uncertainty param\n\tand use it when constructing impl_region_model_context.\n\t(exploded_node::on_edge): Add uncertainty param and pass\n\tto on_edge call.\n\t(exploded_node::detect_leaks): Create uncertainty_t and pass to\n\timpl_region_model_context.\n\t(exploded_graph::get_or_create_node): Create uncertainty_t and\n\tpass to prune_for_point.\n\t(maybe_process_run_of_before_supernode_enodes): Create\n\tuncertainty_t and pass to impl_region_model_context.\n\t(exploded_graph::process_node): Create uncertainty_t instances and\n\tpass around as needed.\n\t* exploded-graph.h\n\t(impl_region_model_context::impl_region_model_context): Add\n\tuncertainty param.\n\t(impl_region_model_context::get_uncertainty): New decl.\n\t(impl_region_model_context::m_uncertainty): New field.\n\t(exploded_node::on_stmt): Add uncertainty param.\n\t(exploded_node::on_edge): Likewise.\n\t* program-state.cc (sm_state_map::on_liveness_change): Get\n\tuncertainty from context and use it to unset sm-state from\n\tsvalues as appropriate.\n\t(program_state::on_edge): Add uncertainty param and use it when\n\tconstructing impl_region_model_context.  Fix indentation.\n\t(program_state::prune_for_point): Add uncertainty param and use it\n\twhen constructing impl_region_model_context.\n\t(program_state::detect_leaks): Get any uncertainty from ctxt and\n\tuse it to get maybe-live svalues for dest_state, rather than\n\tdefinitely-live ones; use this when determining which svalues\n\thave leaked.\n\t(selftest::test_program_state_merging): Create uncertainty_t and\n\tpass to impl_region_model_context.\n\t* program-state.h (program_state::on_edge): Add uncertainty param.\n\t(program_state::prune_for_point): Likewise.\n\t* region-model-impl-calls.cc (call_details::get_uncertainty): New.\n\t(region_model::impl_call_memcpy): Pass uncertainty to\n\tmark_region_as_unknown call.\n\t(region_model::impl_call_memset): Likewise.\n\t(region_model::impl_call_strcpy): Likewise.\n\t* region-model-reachability.cc (reachable_regions::handle_sval):\n\tAlso add sval to m_mutable_svals.\n\t* region-model.cc (region_model::on_assignment): Pass any\n\tuncertainty from ctxt to the store::set_value call.\n\t(region_model::handle_unrecognized_call): Get any uncertainty from\n\tctxt and use it to record mutable svalues at the unknown call.\n\t(region_model::get_reachable_svalues): Add uncertainty param and\n\tuse it to mark any maybe-bound svalues as being reachable.\n\t(region_model::set_value): Pass any uncertainty from ctxt to the\n\tstore::set_value call.\n\t(region_model::mark_region_as_unknown): Add uncertainty param and\n\tpass it on to the store::mark_region_as_unknown call.\n\t(region_model::update_for_call_summary): Add uncertainty param and\n\tpass it on to the region_model::mark_region_as_unknown call.\n\t* region-model.h (call_details::get_uncertainty): New decl.\n\t(region_model::get_reachable_svalues): Add uncertainty param.\n\t(region_model::mark_region_as_unknown): Add uncertainty param.\n\t(region_model_context::get_uncertainty): New vfunc.\n\t(noop_region_model_context::get_uncertainty): New vfunc\n\timplementation.\n\t* store.cc (dump_svalue_set): New.\n\t(uncertainty_t::dump_to_pp): New.\n\t(uncertainty_t::dump): New.\n\t(binding_cluster::clobber_region): Pass NULL for uncertainty to\n\tremove_overlapping_bindings.\n\t(binding_cluster::mark_region_as_unknown): Add uncertainty param\n\tand pass it to remove_overlapping_bindings.\n\t(binding_cluster::remove_overlapping_bindings): Add uncertainty param.\n\tUse it to record any svalues that were in clobbered bindings.\n\t(store::set_value): Add uncertainty param.  Pass it to\n\tbinding_cluster::mark_region_as_unknown when handling symbolic\n\tregions.\n\t(store::mark_region_as_unknown): Add uncertainty param and pass it\n\tto binding_cluster::mark_region_as_unknown.\n\t(store::remove_overlapping_bindings): Add uncertainty param and\n\tpass it to binding_cluster::remove_overlapping_bindings.\n\t* store.h (binding_cluster::mark_region_as_unknown): Add\n\tuncertainty param.\n\t(binding_cluster::remove_overlapping_bindings): Likewise.\n\t(store::set_value): Likewise.\n\t(store::mark_region_as_unknown): Likewise.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/99042\n\tPR analyzer/99774\n\t* gcc.dg/analyzer/pr99042.c: New test.\n\t* gcc.dg/analyzer/pr99774-1.c: New test.\n\t* gcc.dg/analyzer/pr99774-2.c: New test.", "tree": {"sha": "3172c6eddc63beb32dc40b78df987ecb11766421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3172c6eddc63beb32dc40b78df987ecb11766421"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e84a142913a1f3084d415462024964f97356bee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e84a142913a1f3084d415462024964f97356bee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e84a142913a1f3084d415462024964f97356bee"}], "stats": {"total": 640, "additions": 567, "deletions": 73}, "files": [{"sha": "5b519fdf38591a024345a82bde3930b8d92a2ccd", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -78,6 +78,7 @@ impl_region_model_context (exploded_graph &eg,\n \t\t\t   exploded_node *enode_for_diag,\n \t\t\t   const program_state *old_state,\n \t\t\t   program_state *new_state,\n+\t\t\t   uncertainty_t *uncertainty,\n \t\t\t   const gimple *stmt,\n \t\t\t   stmt_finder *stmt_finder)\n : m_eg (&eg), m_logger (eg.get_logger ()),\n@@ -86,20 +87,23 @@ impl_region_model_context (exploded_graph &eg,\n   m_new_state (new_state),\n   m_stmt (stmt),\n   m_stmt_finder (stmt_finder),\n-  m_ext_state (eg.get_ext_state ())\n+  m_ext_state (eg.get_ext_state ()),\n+  m_uncertainty (uncertainty)\n {\n }\n \n impl_region_model_context::\n impl_region_model_context (program_state *state,\n \t\t\t   const extrinsic_state &ext_state,\n+\t\t\t   uncertainty_t *uncertainty,\n \t\t\t   logger *logger)\n : m_eg (NULL), m_logger (logger), m_enode_for_diag (NULL),\n   m_old_state (NULL),\n   m_new_state (state),\n   m_stmt (NULL),\n   m_stmt_finder (NULL),\n-  m_ext_state (ext_state)\n+  m_ext_state (ext_state),\n+  m_uncertainty (uncertainty)\n {\n }\n \n@@ -150,6 +154,12 @@ impl_region_model_context::on_escaped_function (tree fndecl)\n   m_eg->on_escaped_function (fndecl);\n }\n \n+uncertainty_t *\n+impl_region_model_context::get_uncertainty ()\n+{\n+  return m_uncertainty;\n+}\n+\n /* struct setjmp_record.  */\n \n int\n@@ -220,7 +230,7 @@ class impl_sm_context : public sm_context\n   {\n     impl_region_model_context old_ctxt\n       (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n-       call);\n+       NULL, call);\n     region_model *model = m_new_state->m_region_model;\n     return model->get_fndecl_for_call (call, &old_ctxt);\n   }\n@@ -232,7 +242,7 @@ class impl_sm_context : public sm_context\n     LOG_FUNC (logger);\n     impl_region_model_context old_ctxt\n       (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n-       stmt);\n+       NULL, stmt);\n     const svalue *var_old_sval\n       = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n \n@@ -250,12 +260,13 @@ class impl_sm_context : public sm_context\n     LOG_FUNC (logger);\n     impl_region_model_context old_ctxt\n       (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n-       stmt);\n+       NULL, stmt);\n     const svalue *var_old_sval\n       = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n \n     impl_region_model_context new_ctxt (m_eg, m_enode_for_diag,\n \t\t\t\t\tm_old_state, m_new_state,\n+\t\t\t\t\tNULL,\n \t\t\t\t\tstmt);\n     const svalue *var_new_sval\n       = m_new_state->m_region_model->get_rvalue (var, &new_ctxt);\n@@ -280,7 +291,7 @@ class impl_sm_context : public sm_context\n     LOG_FUNC (get_logger ());\n     gcc_assert (d); // take ownership\n     impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL);\n+      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, NULL);\n \n     const svalue *var_old_sval\n       = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n@@ -340,7 +351,7 @@ class impl_sm_context : public sm_context\n     if (!assign_stmt)\n      return NULL_TREE;\n     impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, m_old_state, m_new_state, stmt);\n+      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, stmt);\n     if (const svalue *sval\n \t= m_new_state->m_region_model->get_gassign_result (assign_stmt,\n \t\t\t\t\t\t\t    &old_ctxt))\n@@ -1116,7 +1127,8 @@ exploded_node::on_stmt_flags\n exploded_node::on_stmt (exploded_graph &eg,\n \t\t\tconst supernode *snode,\n \t\t\tconst gimple *stmt,\n-\t\t\tprogram_state *state)\n+\t\t\tprogram_state *state,\n+\t\t\tuncertainty_t *uncertainty)\n {\n   logger *logger = eg.get_logger ();\n   LOG_SCOPE (logger);\n@@ -1140,7 +1152,7 @@ exploded_node::on_stmt (exploded_graph &eg,\n   const program_state old_state (*state);\n \n   impl_region_model_context ctxt (eg, this,\n-\t\t\t\t  &old_state, state,\n+\t\t\t\t  &old_state, state, uncertainty,\n \t\t\t\t  stmt);\n \n   bool unknown_side_effects = false;\n@@ -1300,14 +1312,15 @@ bool\n exploded_node::on_edge (exploded_graph &eg,\n \t\t\tconst superedge *succ,\n \t\t\tprogram_point *next_point,\n-\t\t\tprogram_state *next_state)\n+\t\t\tprogram_state *next_state,\n+\t\t\tuncertainty_t *uncertainty)\n {\n   LOG_FUNC (eg.get_logger ());\n \n   if (!next_point->on_edge (eg, succ))\n     return false;\n \n-  if (!next_state->on_edge (eg, this, succ))\n+  if (!next_state->on_edge (eg, this, succ, uncertainty))\n     return false;\n \n   return true;\n@@ -1563,8 +1576,9 @@ exploded_node::detect_leaks (exploded_graph &eg)\n \n   gcc_assert (new_state.m_region_model);\n \n+  uncertainty_t uncertainty;\n   impl_region_model_context ctxt (eg, this,\n-\t\t\t\t  &old_state, &new_state,\n+\t\t\t\t  &old_state, &new_state, &uncertainty,\n \t\t\t\t  get_stmt ());\n   const svalue *result = NULL;\n   new_state.m_region_model->pop_frame (NULL, &result, &ctxt);\n@@ -2195,8 +2209,9 @@ exploded_graph::get_or_create_node (const program_point &point,\n \n   /* Prune state to try to improve the chances of a cache hit,\n      avoiding generating redundant nodes.  */\n+  uncertainty_t uncertainty;\n   program_state pruned_state\n-    = state.prune_for_point (*this, point, enode_for_diag);\n+    = state.prune_for_point (*this, point, enode_for_diag, &uncertainty);\n \n   pruned_state.validate (get_ext_state ());\n \n@@ -2775,8 +2790,10 @@ maybe_process_run_of_before_supernode_enodes (exploded_node *enode)\n       const program_point &iter_point = iter_enode->get_point ();\n       if (const superedge *iter_sedge = iter_point.get_from_edge ())\n \t{\n+\t  uncertainty_t uncertainty;\n \t  impl_region_model_context ctxt (*this, iter_enode,\n-\t\t\t\t\t  &state, next_state, NULL);\n+\t\t\t\t\t  &state, next_state,\n+\t\t\t\t\t  &uncertainty, NULL);\n \t  const cfg_superedge *last_cfg_superedge\n \t    = iter_sedge->dyn_cast_cfg_superedge ();\n \t  if (last_cfg_superedge)\n@@ -2950,11 +2967,13 @@ exploded_graph::process_node (exploded_node *node)\n     case PK_BEFORE_SUPERNODE:\n       {\n \tprogram_state next_state (state);\n+\tuncertainty_t uncertainty;\n \n \tif (point.get_from_edge ())\n \t  {\n \t    impl_region_model_context ctxt (*this, node,\n-\t\t\t\t\t    &state, &next_state, NULL);\n+\t\t\t\t\t    &state, &next_state,\n+\t\t\t\t\t    &uncertainty, NULL);\n \t    const cfg_superedge *last_cfg_superedge\n \t      = point.get_from_edge ()->dyn_cast_cfg_superedge ();\n \t    if (last_cfg_superedge)\n@@ -2992,6 +3011,7 @@ exploded_graph::process_node (exploded_node *node)\n \t   the sm-state-change occurs on an edge where the src enode has\n \t   exactly one stmt, the one that caused the change. */\n \tprogram_state next_state (state);\n+\tuncertainty_t uncertainty;\n \tconst supernode *snode = point.get_supernode ();\n \tunsigned stmt_idx;\n \tconst gimple *prev_stmt = NULL;\n@@ -3013,7 +3033,7 @@ exploded_graph::process_node (exploded_node *node)\n \n \t    /* Process the stmt.  */\n \t    exploded_node::on_stmt_flags flags\n-\t      = node->on_stmt (*this, snode, stmt, &next_state);\n+\t      = node->on_stmt (*this, snode, stmt, &next_state, &uncertainty);\n \t    node->m_num_processed_stmts++;\n \n \t    /* If flags.m_terminate_path, stop analyzing; any nodes/edges\n@@ -3024,7 +3044,8 @@ exploded_graph::process_node (exploded_node *node)\n \t    if (next_state.m_region_model)\n \t      {\n \t\timpl_region_model_context ctxt (*this, node,\n-\t\t\t\t\t\t&old_state, &next_state, stmt);\n+\t\t\t\t\t\t&old_state, &next_state,\n+\t\t\t\t\t\t&uncertainty, stmt);\n \t\tprogram_state::detect_leaks (old_state, next_state, NULL,\n \t\t\t\t\t     get_ext_state (), &ctxt);\n \t      }\n@@ -3036,7 +3057,8 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\t\t\t       point.get_call_string ())\n \t\t : program_point::after_supernode (point.get_supernode (),\n \t\t\t\t\t\t   point.get_call_string ()));\n-\t    next_state = next_state.prune_for_point (*this, next_point, node);\n+\t    next_state = next_state.prune_for_point (*this, next_point, node,\n+\t\t\t\t\t\t     &uncertainty);\n \n \t    if (flags.m_sm_changes || flag_analyzer_fine_grained)\n \t      {\n@@ -3128,15 +3150,15 @@ exploded_graph::process_node (exploded_node *node)\n \t      = program_point::before_supernode (succ->m_dest, succ,\n \t\t\t\t\t\t point.get_call_string ());\n \t    program_state next_state (state);\n-\n-\t    if (!node->on_edge (*this, succ, &next_point, &next_state))\n+\t    uncertainty_t uncertainty;\n+\t    if (!node->on_edge (*this, succ, &next_point, &next_state,\n+\t\t\t\t&uncertainty))\n \t      {\n \t\tif (logger)\n \t\t  logger->log (\"skipping impossible edge to SN: %i\",\n \t\t\t       succ->m_dest->m_index);\n \t\tcontinue;\n \t      }\n-\n \t    exploded_node *next = get_or_create_node (next_point, next_state,\n \t\t\t\t\t\t      node);\n \t    if (next)"}, {"sha": "c67f7b70605a47394f7310cff0602899b85edd31", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -36,12 +36,14 @@ class impl_region_model_context : public region_model_context\n \t\t\t\told state, rather than the new?  */\n \t\t\t     const program_state *old_state,\n \t\t\t     program_state *new_state,\n+\t\t\t     uncertainty_t *uncertainty,\n \n \t\t\t     const gimple *stmt,\n \t\t\t     stmt_finder *stmt_finder = NULL);\n \n   impl_region_model_context (program_state *state,\n \t\t\t     const extrinsic_state &ext_state,\n+\t\t\t     uncertainty_t *uncertainty,\n \t\t\t     logger *logger = NULL);\n \n   void warn (pending_diagnostic *d) FINAL OVERRIDE;\n@@ -68,6 +70,8 @@ class impl_region_model_context : public region_model_context\n \n   void on_escaped_function (tree fndecl) FINAL OVERRIDE;\n \n+  uncertainty_t *get_uncertainty () FINAL OVERRIDE;\n+\n   exploded_graph *m_eg;\n   log_user m_logger;\n   exploded_node *m_enode_for_diag;\n@@ -76,6 +80,7 @@ class impl_region_model_context : public region_model_context\n   const gimple *m_stmt;\n   stmt_finder *m_stmt_finder;\n   const extrinsic_state &m_ext_state;\n+  uncertainty_t *m_uncertainty;\n };\n \n /* A <program_point, program_state> pair, used internally by\n@@ -226,11 +231,13 @@ class exploded_node : public dnode<eg_traits>\n   on_stmt_flags on_stmt (exploded_graph &eg,\n \t\t\t const supernode *snode,\n \t\t\t const gimple *stmt,\n-\t\t\t program_state *state);\n+\t\t\t program_state *state,\n+\t\t\t uncertainty_t *uncertainty);\n   bool on_edge (exploded_graph &eg,\n \t\tconst superedge *succ,\n \t\tprogram_point *next_point,\n-\t\tprogram_state *next_state);\n+\t\tprogram_state *next_state,\n+\t\tuncertainty_t *uncertainty);\n   void on_longjmp (exploded_graph &eg,\n \t\t   const gcall *call,\n \t\t   program_state *new_state,"}, {"sha": "f8094621309996984708fd0551045b2409ac8910", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -516,6 +516,7 @@ sm_state_map::on_liveness_change (const svalue_set &live_svalues,\n \t\t\t\t  impl_region_model_context *ctxt)\n {\n   svalue_set svals_to_unset;\n+  uncertainty_t *uncertainty = ctxt->get_uncertainty ();\n \n   auto_vec<const svalue *> leaked_svals (m_map.elements ());\n   for (map_t::iterator iter = m_map.begin ();\n@@ -530,6 +531,9 @@ sm_state_map::on_liveness_change (const svalue_set &live_svalues,\n \t  if (!m_sm.can_purge_p (e.m_state))\n \t    leaked_svals.quick_push (iter_sval);\n \t}\n+      if (uncertainty)\n+\tif (uncertainty->unknown_sm_state_p (iter_sval))\n+\t  svals_to_unset.add (iter_sval);\n     }\n \n   leaked_svals.qsort (svalue::cmp_ptr_ptr);\n@@ -960,7 +964,8 @@ program_state::get_current_function () const\n bool\n program_state::on_edge (exploded_graph &eg,\n \t\t\texploded_node *enode,\n-\t\t\tconst superedge *succ)\n+\t\t\tconst superedge *succ,\n+\t\t\tuncertainty_t *uncertainty)\n {\n   /* Update state.  */\n   const program_point &point = enode->get_point ();\n@@ -978,6 +983,7 @@ program_state::on_edge (exploded_graph &eg,\n   impl_region_model_context ctxt (eg, enode,\n \t\t\t\t  &enode->get_state (),\n \t\t\t\t  this,\n+\t\t\t\t  uncertainty,\n \t\t\t\t  last_stmt);\n   if (!m_region_model->maybe_update_for_edge (*succ,\n \t\t\t\t\t      last_stmt,\n@@ -992,8 +998,8 @@ program_state::on_edge (exploded_graph &eg,\n     }\n \n   program_state::detect_leaks (enode->get_state (), *this,\n-\t\t\t\tNULL, eg.get_ext_state (),\n-\t\t\t\t&ctxt);\n+\t\t\t       NULL, eg.get_ext_state (),\n+\t\t\t       &ctxt);\n \n   return true;\n }\n@@ -1007,7 +1013,8 @@ program_state::on_edge (exploded_graph &eg,\n program_state\n program_state::prune_for_point (exploded_graph &eg,\n \t\t\t\tconst program_point &point,\n-\t\t\t\texploded_node *enode_for_diag) const\n+\t\t\t\texploded_node *enode_for_diag,\n+\t\t\t\tuncertainty_t *uncertainty) const\n {\n   logger * const logger = eg.get_logger ();\n   LOG_SCOPE (logger);\n@@ -1071,6 +1078,7 @@ program_state::prune_for_point (exploded_graph &eg,\n \t  impl_region_model_context ctxt (eg, enode_for_diag,\n \t\t\t\t\t  this,\n \t\t\t\t\t  &new_state,\n+\t\t\t\t\t  uncertainty,\n \t\t\t\t\t  point.get_stmt ());\n \t  detect_leaks (*this, new_state, NULL, eg.get_ext_state (), &ctxt);\n \t}\n@@ -1189,6 +1197,7 @@ program_state::detect_leaks (const program_state &src_state,\n {\n   logger *logger = ext_state.get_logger ();\n   LOG_SCOPE (logger);\n+  const uncertainty_t *uncertainty = ctxt->get_uncertainty ();\n   if (logger)\n     {\n       pretty_printer *pp = logger->get_printer ();\n@@ -1207,31 +1216,46 @@ program_state::detect_leaks (const program_state &src_state,\n \t  extra_sval->dump_to_pp (pp, true);\n \t  logger->end_log_line ();\n \t}\n+      if (uncertainty)\n+\t{\n+\t  logger->start_log_line ();\n+\t  pp_string (pp, \"uncertainty: \");\n+\t  uncertainty->dump_to_pp (pp, true);\n+\t  logger->end_log_line ();\n+\t}\n     }\n \n-  /* Get svalues reachable from each of src_state and dst_state.  */\n-  svalue_set src_svalues;\n-  svalue_set dest_svalues;\n-  src_state.m_region_model->get_reachable_svalues (&src_svalues, NULL);\n-  dest_state.m_region_model->get_reachable_svalues (&dest_svalues, extra_sval);\n+  /* Get svalues reachable from each of src_state and dest_state.\n+     Get svalues *known* to be reachable in src_state.\n+     Pass in uncertainty for dest_state so that we additionally get svalues that\n+     *might* still be reachable in dst_state.  */\n+  svalue_set known_src_svalues;\n+  src_state.m_region_model->get_reachable_svalues (&known_src_svalues,\n+\t\t\t\t\t\t   NULL, NULL);\n+  svalue_set maybe_dest_svalues;\n+  dest_state.m_region_model->get_reachable_svalues (&maybe_dest_svalues,\n+\t\t\t\t\t\t    extra_sval, uncertainty);\n \n   if (logger)\n     {\n-      log_set_of_svalues (logger, \"src_state reachable svalues:\", src_svalues);\n-      log_set_of_svalues (logger, \"dest_state reachable svalues:\",\n-\t\t\t  dest_svalues);\n+      log_set_of_svalues (logger, \"src_state known reachable svalues:\",\n+\t\t\t  known_src_svalues);\n+      log_set_of_svalues (logger, \"dest_state maybe reachable svalues:\",\n+\t\t\t  maybe_dest_svalues);\n     }\n \n-  auto_vec <const svalue *> dead_svals (src_svalues.elements ());\n-  for (svalue_set::iterator iter = src_svalues.begin ();\n-       iter != src_svalues.end (); ++iter)\n+  auto_vec <const svalue *> dead_svals (known_src_svalues.elements ());\n+  for (svalue_set::iterator iter = known_src_svalues.begin ();\n+       iter != known_src_svalues.end (); ++iter)\n     {\n       const svalue *sval = (*iter);\n       /* For each sval reachable from SRC_STATE, determine if it is\n-\t live in DEST_STATE: either explicitly reachable, or implicitly\n-\t live based on the set of explicitly reachable svalues.\n-\t Record those that have ceased to be live.  */\n-      if (!sval->live_p (&dest_svalues, dest_state.m_region_model))\n+\t live in DEST_STATE: either explicitly reachable, implicitly\n+\t live based on the set of explicitly reachable svalues,\n+\t or possibly reachable as recorded in uncertainty.\n+\t Record those that have ceased to be live i.e. were known\n+\t to be live, and are now not known to be even possibly-live.  */\n+      if (!sval->live_p (&maybe_dest_svalues, dest_state.m_region_model))\n \tdead_svals.quick_push (sval);\n     }\n \n@@ -1244,11 +1268,12 @@ program_state::detect_leaks (const program_state &src_state,\n     ctxt->on_svalue_leak (sval);\n \n   /* Purge dead svals from sm-state.  */\n-  ctxt->on_liveness_change (dest_svalues, dest_state.m_region_model);\n+  ctxt->on_liveness_change (maybe_dest_svalues,\n+\t\t\t    dest_state.m_region_model);\n \n   /* Purge dead svals from constraints.  */\n   dest_state.m_region_model->get_constraints ()->on_liveness_change\n-    (dest_svalues, dest_state.m_region_model);\n+    (maybe_dest_svalues, dest_state.m_region_model);\n }\n \n #if CHECKING_P\n@@ -1456,7 +1481,8 @@ test_program_state_merging ()\n   region_model_manager *mgr = eng.get_model_manager ();\n \n   program_state s0 (ext_state);\n-  impl_region_model_context ctxt (&s0, ext_state);\n+  uncertainty_t uncertainty;\n+  impl_region_model_context ctxt (&s0, ext_state, &uncertainty);\n \n   region_model *model0 = s0.m_region_model;\n   const svalue *size_in_bytes"}, {"sha": "898c57ff8337b09634cb128fc607af1530a805b3", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -222,11 +222,13 @@ class program_state\n \n   bool on_edge (exploded_graph &eg,\n \t\texploded_node *enode,\n-\t\tconst superedge *succ);\n+\t\tconst superedge *succ,\n+\t\tuncertainty_t *uncertainty);\n \n   program_state prune_for_point (exploded_graph &eg,\n \t\t\t\t const program_point &point,\n-\t\t\t\t exploded_node *enode_for_diag) const;\n+\t\t\t\t exploded_node *enode_for_diag,\n+\t\t\t\t uncertainty_t *uncertainty) const;\n \n   tree get_representative_tree (const svalue *sval) const;\n "}, {"sha": "4052bb393f82dcb68f740429ced42369d1095a6b", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -79,6 +79,14 @@ call_details::call_details (const gcall *call, region_model *model,\n     }\n }\n \n+/* Get any uncertainty_t associated with the region_model_context.  */\n+\n+uncertainty_t *\n+call_details::get_uncertainty () const\n+{\n+  return m_ctxt->get_uncertainty ();\n+}\n+\n /* If the callsite has a left-hand-side region, set it to RESULT\n    and return true.\n    Otherwise do nothing and return false.  */\n@@ -346,7 +354,7 @@ region_model::impl_call_memcpy (const call_details &cd)\n   check_for_writable_region (dest_reg, cd.get_ctxt ());\n \n   /* Otherwise, mark region's contents as unknown.  */\n-  mark_region_as_unknown (dest_reg);\n+  mark_region_as_unknown (dest_reg, cd.get_uncertainty ());\n }\n \n /* Handle the on_call_pre part of \"memset\" and \"__builtin_memset\".  */\n@@ -389,7 +397,7 @@ region_model::impl_call_memset (const call_details &cd)\n   check_for_writable_region (dest_reg, cd.get_ctxt ());\n \n   /* Otherwise, mark region's contents as unknown.  */\n-  mark_region_as_unknown (dest_reg);\n+  mark_region_as_unknown (dest_reg, cd.get_uncertainty ());\n   return false;\n }\n \n@@ -453,7 +461,7 @@ region_model::impl_call_strcpy (const call_details &cd)\n   check_for_writable_region (dest_reg, cd.get_ctxt ());\n \n   /* For now, just mark region's contents as unknown.  */\n-  mark_region_as_unknown (dest_reg);\n+  mark_region_as_unknown (dest_reg, cd.get_uncertainty ());\n }\n \n /* Handle the on_call_pre part of \"strlen\"."}, {"sha": "e165cda014feefe3780d24462625c29cd798167c", "filename": "gcc/analyzer/region-model-reachability.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.cc?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -170,6 +170,7 @@ void\n reachable_regions::handle_sval (const svalue *sval)\n {\n   m_reachable_svals.add (sval);\n+  m_mutable_svals.add (sval);\n   if (const region_svalue *ptr = sval->dyn_cast_region_svalue ())\n     {\n       const region *pointee = ptr->get_pointee ();"}, {"sha": "2d3880bf8cc2d1b3d9347ad1f402836c5322062b", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -726,7 +726,7 @@ region_model::on_assignment (const gassign *assign, region_model_context *ctxt)\n \t   access will \"inherit\" the individual chars.  */\n \tconst svalue *rhs_sval = get_rvalue (rhs1, ctxt);\n \tm_store.set_value (m_mgr->get_store_manager(), lhs_reg, rhs_sval,\n-\t\t\t   BK_default);\n+\t\t\t   BK_default, ctxt->get_uncertainty ());\n       }\n       break;\n     }\n@@ -1003,6 +1003,8 @@ region_model::handle_unrecognized_call (const gcall *call,\n       }\n   }\n \n+  uncertainty_t *uncertainty = ctxt->get_uncertainty ();\n+\n   /* Purge sm-state for the svalues that were reachable,\n      both in non-mutable and mutable form.  */\n   for (svalue_set::iterator iter\n@@ -1018,6 +1020,8 @@ region_model::handle_unrecognized_call (const gcall *call,\n     {\n       const svalue *sval = (*iter);\n       ctxt->on_unknown_change (sval, true);\n+      if (uncertainty)\n+\tuncertainty->on_mutable_sval_at_unknown_call (sval);\n     }\n \n   /* Mark any clusters that have escaped.  */\n@@ -1035,11 +1039,15 @@ region_model::handle_unrecognized_call (const gcall *call,\n    for reachability (for handling return values from functions when\n    analyzing return of the only function on the stack).\n \n+   If UNCERTAINTY is non-NULL, treat any svalues that were recorded\n+   within it as being maybe-bound as additional \"roots\" for reachability.\n+\n    Find svalues that haven't leaked.    */\n \n void\n region_model::get_reachable_svalues (svalue_set *out,\n-\t\t\t\t     const svalue *extra_sval)\n+\t\t\t\t     const svalue *extra_sval,\n+\t\t\t\t     const uncertainty_t *uncertainty)\n {\n   reachable_regions reachable_regs (this);\n \n@@ -1051,6 +1059,12 @@ region_model::get_reachable_svalues (svalue_set *out,\n   if (extra_sval)\n     reachable_regs.handle_sval (extra_sval);\n \n+  if (uncertainty)\n+    for (uncertainty_t::iterator iter\n+\t   = uncertainty->begin_maybe_bound_svals ();\n+\t iter != uncertainty->end_maybe_bound_svals (); ++iter)\n+      reachable_regs.handle_sval (*iter);\n+\n   /* Get regions for locals that have explicitly bound values.  */\n   for (store::cluster_map_t::iterator iter = m_store.begin ();\n        iter != m_store.end (); ++iter)\n@@ -1798,7 +1812,7 @@ region_model::set_value (const region *lhs_reg, const svalue *rhs_sval,\n   check_for_writable_region (lhs_reg, ctxt);\n \n   m_store.set_value (m_mgr->get_store_manager(), lhs_reg, rhs_sval,\n-\t\t     BK_direct);\n+\t\t     BK_direct, ctxt ? ctxt->get_uncertainty () : NULL);\n }\n \n /* Set the value of the region given by LHS to the value given by RHS.  */\n@@ -1840,9 +1854,11 @@ region_model::zero_fill_region (const region *reg)\n /* Mark REG as having unknown content.  */\n \n void\n-region_model::mark_region_as_unknown (const region *reg)\n+region_model::mark_region_as_unknown (const region *reg,\n+\t\t\t\t      uncertainty_t *uncertainty)\n {\n-  m_store.mark_region_as_unknown (m_mgr->get_store_manager(), reg);\n+  m_store.mark_region_as_unknown (m_mgr->get_store_manager(), reg,\n+\t\t\t\t  uncertainty);\n }\n \n /* Determine what is known about the condition \"LHS_SVAL OP RHS_SVAL\" within\n@@ -2666,7 +2682,8 @@ region_model::update_for_call_summary (const callgraph_superedge &cg_sedge,\n   const gcall *call_stmt = cg_sedge.get_call_stmt ();\n   tree lhs = gimple_call_lhs (call_stmt);\n   if (lhs)\n-    mark_region_as_unknown (get_lvalue (lhs, ctxt));\n+    mark_region_as_unknown (get_lvalue (lhs, ctxt),\n+\t\t\t    ctxt ? ctxt->get_uncertainty () : NULL);\n \n   // TODO: actually implement some kind of summary here\n }"}, {"sha": "4123500f3bc775892487668c4968b735a934fa52", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -378,6 +378,7 @@ class call_details\n \t\tregion_model_context *ctxt);\n \n   region_model_context *get_ctxt () const { return m_ctxt; }\n+  uncertainty_t *get_uncertainty () const;\n   tree get_lhs_type () const { return m_lhs_type; }\n   const region *get_lhs_region () const { return m_lhs_region; }\n \n@@ -474,7 +475,8 @@ class region_model\n   void handle_unrecognized_call (const gcall *call,\n \t\t\t\t region_model_context *ctxt);\n   void get_reachable_svalues (svalue_set *out,\n-\t\t\t      const svalue *extra_sval);\n+\t\t\t      const svalue *extra_sval,\n+\t\t\t      const uncertainty_t *uncertainty);\n \n   void on_return (const greturn *stmt, region_model_context *ctxt);\n   void on_setjmp (const gcall *stmt, const exploded_node *enode,\n@@ -518,7 +520,7 @@ class region_model\n   void clobber_region (const region *reg);\n   void purge_region (const region *reg);\n   void zero_fill_region (const region *reg);\n-  void mark_region_as_unknown (const region *reg);\n+  void mark_region_as_unknown (const region *reg, uncertainty_t *uncertainty);\n \n   void copy_region (const region *dst_reg, const region *src_reg,\n \t\t    region_model_context *ctxt);\n@@ -698,6 +700,8 @@ class region_model_context\n \n   /* Hook for clients to be notified when a function_decl escapes.  */\n   virtual void on_escaped_function (tree fndecl) = 0;\n+\n+  virtual uncertainty_t *get_uncertainty () = 0;\n };\n \n /* A \"do nothing\" subclass of region_model_context.  */\n@@ -726,6 +730,8 @@ class noop_region_model_context : public region_model_context\n   void on_unexpected_tree_code (tree, const dump_location_t &) OVERRIDE {}\n \n   void on_escaped_function (tree) OVERRIDE {}\n+\n+  uncertainty_t *get_uncertainty () OVERRIDE { return NULL; }\n };\n \n /* A subclass of region_model_context for determining if operations fail"}, {"sha": "b1874a5a2d3f35ac8b0d60cc63787e83b1faf1b0", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 77, "deletions": 11, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -63,6 +63,61 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n+/* Dump SVALS to PP, sorting them to ensure determinism.  */\n+\n+static void\n+dump_svalue_set (const hash_set <const svalue *> &svals,\n+\t\t pretty_printer *pp, bool simple)\n+{\n+  auto_vec <const svalue *> v;\n+  for (hash_set<const svalue *>::iterator iter = svals.begin ();\n+       iter != svals.end (); ++iter)\n+    {\n+      v.safe_push (*iter);\n+    }\n+  v.qsort (svalue::cmp_ptr_ptr);\n+\n+  pp_character (pp, '{');\n+  const svalue *sval;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (v, i, sval)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      sval->dump_to_pp (pp, simple);\n+    }\n+  pp_character (pp, '}');\n+}\n+\n+/* class uncertainty_t.  */\n+\n+/* Dump this object to PP.  */\n+\n+void\n+uncertainty_t::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  pp_string (pp, \"{m_maybe_bound_svals: \");\n+  dump_svalue_set (m_maybe_bound_svals, pp, simple);\n+\n+  pp_string (pp, \", m_mutable_at_unknown_call_svals: \");\n+  dump_svalue_set (m_mutable_at_unknown_call_svals, pp, simple);\n+  pp_string (pp, \"}\");\n+}\n+\n+/* Dump this object to stderr.  */\n+\n+DEBUG_FUNCTION void\n+uncertainty_t::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n /* Get a human-readable string for KIND for dumps.  */\n \n const char *binding_kind_to_string (enum binding_kind kind)\n@@ -876,7 +931,7 @@ binding_cluster::bind_compound_sval (store_manager *mgr,\n void\n binding_cluster::clobber_region (store_manager *mgr, const region *reg)\n {\n-  remove_overlapping_bindings (mgr, reg);\n+  remove_overlapping_bindings (mgr, reg, NULL);\n }\n \n /* Remove any bindings for REG within this cluster.  */\n@@ -913,13 +968,16 @@ binding_cluster::zero_fill_region (store_manager *mgr, const region *reg)\n   m_touched = false;\n }\n \n-/* Mark REG within this cluster as being unknown.  */\n+/* Mark REG within this cluster as being unknown.\n+   If UNCERTAINTY is non-NULL, use it to record any svalues that\n+   had bindings to them removed, as being maybe-bound.  */\n \n void\n binding_cluster::mark_region_as_unknown (store_manager *mgr,\n-\t\t\t\t\t const region *reg)\n+\t\t\t\t\t const region *reg,\n+\t\t\t\t\t uncertainty_t *uncertainty)\n {\n-  remove_overlapping_bindings (mgr, reg);\n+  remove_overlapping_bindings (mgr, reg, uncertainty);\n \n   /* Add a default binding to \"unknown\".  */\n   region_model_manager *sval_mgr = mgr->get_svalue_manager ();\n@@ -1143,11 +1201,14 @@ binding_cluster::get_overlapping_bindings (store_manager *mgr,\n \n /* Remove any bindings within this cluster that overlap REG,\n    but retain default bindings that overlap but aren't fully covered\n-   by REG.  */\n+   by REG.\n+   If UNCERTAINTY is non-NULL, use it to record any svalues that\n+   were removed, as being maybe-bound.  */\n \n void\n binding_cluster::remove_overlapping_bindings (store_manager *mgr,\n-\t\t\t\t\t      const region *reg)\n+\t\t\t\t\t      const region *reg,\n+\t\t\t\t\t      uncertainty_t *uncertainty)\n {\n   auto_vec<const binding_key *> bindings;\n   get_overlapping_bindings (mgr, reg, &bindings);\n@@ -1165,6 +1226,8 @@ binding_cluster::remove_overlapping_bindings (store_manager *mgr,\n \t  if (reg_binding != iter_binding)\n \t    continue;\n \t}\n+      if (uncertainty)\n+\tuncertainty->on_maybe_bound_sval (m_map.get (iter_binding));\n       m_map.remove (iter_binding);\n     }\n }\n@@ -1826,7 +1889,8 @@ store::get_any_binding (store_manager *mgr, const region *reg) const\n \n void\n store::set_value (store_manager *mgr, const region *lhs_reg,\n-\t\t  const svalue *rhs_sval, enum binding_kind kind)\n+\t\t  const svalue *rhs_sval, enum binding_kind kind,\n+\t\t  uncertainty_t *uncertainty)\n {\n   remove_overlapping_bindings (mgr, lhs_reg);\n \n@@ -1880,7 +1944,8 @@ store::set_value (store_manager *mgr, const region *lhs_reg,\n \t      gcc_unreachable ();\n \n \t    case tristate::TS_UNKNOWN:\n-\t      iter_cluster->mark_region_as_unknown (mgr, iter_base_reg);\n+\t      iter_cluster->mark_region_as_unknown (mgr, iter_base_reg,\n+\t\t\t\t\t\t    uncertainty);\n \t      break;\n \n \t    case tristate::TS_TRUE:\n@@ -2021,13 +2086,14 @@ store::zero_fill_region (store_manager *mgr, const region *reg)\n /* Mark REG as having unknown content.  */\n \n void\n-store::mark_region_as_unknown (store_manager *mgr, const region *reg)\n+store::mark_region_as_unknown (store_manager *mgr, const region *reg,\n+\t\t\t       uncertainty_t *uncertainty)\n {\n   const region *base_reg = reg->get_base_region ();\n   if (base_reg->symbolic_for_unknown_ptr_p ())\n     return;\n   binding_cluster *cluster = get_or_create_cluster (base_reg);\n-  cluster->mark_region_as_unknown (mgr, reg);\n+  cluster->mark_region_as_unknown (mgr, reg, uncertainty);\n }\n \n /* Get the cluster for BASE_REG, or NULL (const version).  */\n@@ -2238,7 +2304,7 @@ store::remove_overlapping_bindings (store_manager *mgr, const region *reg)\n \t  delete cluster;\n \t  return;\n \t}\n-      cluster->remove_overlapping_bindings (mgr, reg);\n+      cluster->remove_overlapping_bindings (mgr, reg, NULL);\n     }\n }\n "}, {"sha": "dc22d96f186e76b8626fb31ae3152aeaf6d3a283", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -119,6 +119,83 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n+/* A class for keeping track of aspects of a program_state that we don't\n+   know about, to avoid false positives about leaks.\n+\n+   Consider:\n+\n+      p->field = malloc (1024);\n+      q->field = NULL;\n+\n+   where we don't know whether or not p and q point to the same memory,\n+   and:\n+\n+      p->field = malloc (1024);\n+      unknown_fn (p);\n+\n+   In both cases, the svalue for the address of the allocated buffer\n+   goes from being bound to p->field to not having anything explicitly bound\n+   to it.\n+\n+   Given that we conservatively discard bindings due to possible aliasing or\n+   calls to unknown function, the store loses references to svalues,\n+   but these svalues could still be live.  We don't want to warn about\n+   them leaking - they're effectively in a \"maybe live\" state.\n+\n+   This \"maybe live\" information is somewhat transient.\n+\n+   We don't want to store this \"maybe live\" information in the program_state,\n+   region_model, or store, since we don't want to bloat these objects (and\n+   potentially bloat the exploded_graph with more nodes).\n+   However, we can't store it in the region_model_context, as these context\n+   objects sometimes don't last long enough to be around when comparing the\n+   old vs the new state.\n+\n+   This class is a way to track a set of such svalues, so that we can\n+   temporarily capture that they are in a \"maybe live\" state whilst\n+   comparing old and new states.  */\n+\n+class uncertainty_t\n+{\n+public:\n+  typedef hash_set<const svalue *>::iterator iterator;\n+\n+  void on_maybe_bound_sval (const svalue *sval)\n+  {\n+    m_maybe_bound_svals.add (sval);\n+  }\n+  void on_mutable_sval_at_unknown_call (const svalue *sval)\n+  {\n+    m_mutable_at_unknown_call_svals.add (sval);\n+  }\n+\n+  bool unknown_sm_state_p (const svalue *sval)\n+  {\n+    return (m_maybe_bound_svals.contains (sval)\n+\t    || m_mutable_at_unknown_call_svals.contains (sval));\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const;\n+  void dump (bool simple) const;\n+\n+  iterator begin_maybe_bound_svals () const\n+  {\n+    return m_maybe_bound_svals.begin ();\n+  }\n+  iterator end_maybe_bound_svals () const\n+  {\n+    return m_maybe_bound_svals.end ();\n+  }\n+\n+private:\n+\n+  /* svalues that might or might not still be bound.  */\n+  hash_set<const svalue *> m_maybe_bound_svals;\n+\n+  /* svalues that have mutable sm-state at unknown calls.  */\n+  hash_set<const svalue *> m_mutable_at_unknown_call_svals;\n+};\n+\n class concrete_binding;\n \n /* An enum for discriminating between \"direct\" vs \"default\" levels of\n@@ -409,7 +486,8 @@ class binding_cluster\n   void clobber_region (store_manager *mgr, const region *reg);\n   void purge_region (store_manager *mgr, const region *reg);\n   void zero_fill_region (store_manager *mgr, const region *reg);\n-  void mark_region_as_unknown (store_manager *mgr, const region *reg);\n+  void mark_region_as_unknown (store_manager *mgr, const region *reg,\n+\t\t\t       uncertainty_t *uncertainty);\n \n   const svalue *get_binding (store_manager *mgr, const region *reg,\n \t\t\t      binding_kind kind) const;\n@@ -421,7 +499,8 @@ class binding_cluster\n   const svalue *maybe_get_compound_binding (store_manager *mgr,\n \t\t\t\t\t     const region *reg) const;\n \n-  void remove_overlapping_bindings (store_manager *mgr, const region *reg);\n+  void remove_overlapping_bindings (store_manager *mgr, const region *reg,\n+\t\t\t\t    uncertainty_t *uncertainty);\n \n   template <typename T>\n   void for_each_value (void (*cb) (const svalue *sval, T user_data),\n@@ -539,11 +618,13 @@ class store\n   bool called_unknown_fn_p () const { return m_called_unknown_fn; }\n \n   void set_value (store_manager *mgr, const region *lhs_reg,\n-\t\t  const svalue *rhs_sval, enum binding_kind kind);\n+\t\t  const svalue *rhs_sval, enum binding_kind kind,\n+\t\t  uncertainty_t *uncertainty);\n   void clobber_region (store_manager *mgr, const region *reg);\n   void purge_region (store_manager *mgr, const region *reg);\n   void zero_fill_region (store_manager *mgr, const region *reg);\n-  void mark_region_as_unknown (store_manager *mgr, const region *reg);\n+  void mark_region_as_unknown (store_manager *mgr, const region *reg,\n+\t\t\t       uncertainty_t *uncertainty);\n \n   const binding_cluster *get_cluster (const region *base_reg) const;\n   binding_cluster *get_cluster (const region *base_reg);"}, {"sha": "c3d124f3e31b6aa687ee7d65d9e16e15eddc5462", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99042.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99042.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99042.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99042.c?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -0,0 +1,53 @@\n+#include <stdio.h>\n+\n+struct foo {\n+  FILE *file;\n+};\n+\n+extern void unknown_fn ();\n+extern void unknown_fn2 (const struct foo *f);\n+\n+int test_1 (struct foo *p)\n+{\n+  if ((p->file = fopen(\"test.txt\", \"w\")) == NULL)\n+    return 1;\n+  unknown_fn ();\n+  return 0; /* { dg-bogus \"leak\" } */\n+}\n+\n+int test_2 (struct foo *p)\n+{\n+  if ((p->file = fopen(\"test.txt\", \"w\")) == NULL)\n+    return 1;\n+  return 0; /* { dg-bogus \"leak\" } */\n+}\n+\n+int test_3 (void)\n+{\n+  struct foo f;\n+  struct foo *p = &f;\n+  if ((p->file = fopen(\"test.txt\", \"w\")) == NULL)\n+    return 1;\n+  unknown_fn ();\n+  return 0; /* { dg-warning \"leak\" } */\n+}\n+\n+int test_4 (void)\n+{\n+  struct foo f;\n+  struct foo *p = &f;\n+  if ((p->file = fopen(\"test.txt\", \"w\")) == NULL)\n+    return 1;\n+  return 0; /* { dg-warning \"leak\" } */\n+}\n+\n+int test_5 (void)\n+{\n+  struct foo f;\n+  struct foo *p = &f;\n+  if ((p->file = fopen(\"test.txt\", \"w\")) == NULL)\n+    return 1;\n+  /* Although p is const, the underlying FILE * is not and could be closed.  */\n+  unknown_fn2 (p);\n+  return 0; /* { dg-bogus \"leak\" } */\n+}"}, {"sha": "620cf6571edabc496e123ad9137acd6bba51cb65", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99774-1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99774-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99774-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99774-1.c?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -0,0 +1,61 @@\n+/* Reproducer for report from -Wanalyzer-malloc-leak\n+   Reduced from\n+     https://git.qemu.org/?p=qemu.git;a=blob;f=subprojects/libvhost-user/libvhost-user.c;h=fab7ca17ee1fb27bcfc338527d1aeb9f923aade5;hb=HEAD#l1184\n+   which is licensed under GNU GPLv2 or later. */\n+\n+typedef unsigned char uint8_t;\n+typedef unsigned short uint16_t;\n+typedef unsigned long uint64_t;\n+typedef unsigned long uint64_t;\n+typedef long unsigned int size_t;\n+\n+extern void *calloc(size_t __nmemb, size_t __size)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__malloc__))\n+  __attribute__((__alloc_size__(1, 2)))\n+  __attribute__((__warn_unused_result__));\n+\n+typedef struct VuDescStateSplit {\n+  uint8_t inflight;\n+  uint64_t counter;\n+} VuDescStateSplit;\n+\n+typedef struct VuVirtqInflight {\n+  uint16_t desc_num;\n+  VuDescStateSplit desc[];\n+} VuVirtqInflight;\n+\n+typedef struct VuVirtqInflightDesc {\n+  uint16_t index;\n+  uint64_t counter;\n+} VuVirtqInflightDesc;\n+\n+typedef struct VuVirtq {\n+  VuVirtqInflight *inflight;\n+  VuVirtqInflightDesc *resubmit_list;\n+  uint16_t resubmit_num;\n+  uint64_t counter;\n+  int inuse;\n+} VuVirtq;\n+\n+int vu_check_queue_inflights(VuVirtq *vq) {\n+  int i = 0;\n+\n+  if (vq->inuse) {\n+    vq->resubmit_list = calloc(vq->inuse, sizeof(VuVirtqInflightDesc));\n+    if (!vq->resubmit_list) {\n+      return -1;\n+    }\n+\n+    for (i = 0; i < vq->inflight->desc_num; i++) {\n+      if (vq->inflight->desc[i].inflight) {\n+        vq->resubmit_list[vq->resubmit_num].index = i; /* { dg-bogus \"leak\" } */\n+        vq->resubmit_list[vq->resubmit_num].counter =\n+            vq->inflight->desc[i].counter;\n+        vq->resubmit_num++;\n+      }\n+    }\n+  }\n+\n+  return 0;\n+}"}, {"sha": "d9704dee6f22b3a40477678b6e7e08e93732bf84", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99774-2.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99774-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a66c289a3f395e50de79424e1e6f401a4dc1ab7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99774-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99774-2.c?ref=3a66c289a3f395e50de79424e1e6f401a4dc1ab7", "patch": "@@ -0,0 +1,144 @@\n+#include <stdlib.h>\n+\n+struct st\n+{\n+  void *m_f;\n+};\n+\n+struct node\n+{\n+  struct node *m_next;\n+};\n+\n+extern void unknown_fn (void *);\n+extern void const_unknown_fn (const void *);\n+\n+void\n+test_1 (struct st *p, struct st *q)\n+{\n+  p->m_f = malloc (1024);\n+  q->m_f = NULL; /* { dg-bogus \"leak\" } */\n+  free (p->m_f);\n+}\n+\n+void\n+test_2 (void)\n+{\n+  struct st s;\n+  s.m_f = malloc (1024);\n+  unknown_fn (&s);\n+  free (s.m_f);\n+}\n+\n+void\n+test_3 (void)\n+{\n+  struct st s;\n+  s.m_f = malloc (1024);\n+  const_unknown_fn (&s);\n+  free (s.m_f);\n+}\n+\n+void\n+test_4 (void)\n+{\n+  struct st s;\n+  s.m_f = malloc (1024);\n+  unknown_fn (&s);\n+} /* { dg-bogus \"leak\" } */\n+\n+void\n+test_5 (void)\n+{\n+  struct st s;\n+  s.m_f = malloc (1024);\n+  /* s is const, but the pointer could still be freed; hence not a leak.  */\n+  const_unknown_fn (&s);\n+} /* { dg-bogus \"leak\" } */\n+\n+void\n+test_6 (void)\n+{\n+  struct st s;\n+  s.m_f = malloc (1024);\n+} /* { dg-warning \"leak\" } */\n+\n+struct st\n+test_7 (void)\n+{\n+  struct st s;\n+  s.m_f = malloc (1024);\n+  return s;\n+} /* { dg-bogus \"leak\" } */\n+\n+struct node *\n+test_8 (void)\n+{\n+  struct node *n1 = malloc (sizeof (struct node));\n+  if (!n1)\n+    return NULL;\n+  n1->m_next = malloc (sizeof (struct node));\n+  return n1;\n+}\n+\n+void\n+test_9 (void)\n+{\n+  struct node *n1 = malloc (sizeof (struct node));\n+  if (!n1)\n+    return;\n+  n1->m_next = malloc (sizeof (struct node));\n+  /* Could free n1 and n1->m_next.  */\n+  unknown_fn (n1);\n+}\n+\n+void\n+test_10 (void)\n+{\n+  struct node *n1 = malloc (sizeof (struct node));\n+  if (!n1)\n+    return;\n+  n1->m_next = malloc (sizeof (struct node));\n+  /* Could free n1->m_next, but not n1.  */\n+  const_unknown_fn (n1); /* { dg-warning \"leak of 'n1'\" } */\n+}\n+\n+void\n+test_11 (void)\n+{\n+  struct node *n1 = malloc (sizeof (struct node));\n+  if (!n1)\n+    return;\n+  n1->m_next = malloc (sizeof (struct node));\n+  /* Could free n1->m_next, but not n1.  */\n+  unknown_fn (n1->m_next); /* { dg-warning \"leak of 'n1'\" } */\n+}\n+\n+void\n+test_12a (void)\n+{\n+  int *ip = malloc (sizeof (int));\n+  *ip = 42; /* { dg-warning \"dereference of possibly-NULL 'ip'\" } */\n+  free (ip);\n+}\n+\n+void\n+test_12b (void)\n+{\n+  int *ip = malloc (sizeof (int));\n+  unknown_fn (ip);\n+  /* Might not be a null-deref, as unknown_fn could abort on NULL.  */\n+  *ip = 42;\n+  free (ip);\n+}\n+\n+void\n+test_12c (void)\n+{\n+  int *ip = malloc (sizeof (int));\n+  /* Might not be a null-deref, as const_unknown_fn could abort on NULL.\n+     Right now we don't have a great way of handling this.  */\n+  const_unknown_fn (ip);\n+  *ip = 42; /* { dg-bogus \"dereference of possibly-NULL 'ip'\" \"\" { xfail *-*-* } } */\n+  free (ip);\n+}"}]}