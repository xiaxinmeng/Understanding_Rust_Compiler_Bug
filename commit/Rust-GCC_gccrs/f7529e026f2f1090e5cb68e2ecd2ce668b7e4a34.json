{"sha": "f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc1MjllMDI2ZjJmMTA5MGU1Y2I2OGUyZWNkMmNlNjY4YjdlNGEzNA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-05-05T13:35:15Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-05-05T13:35:15Z"}, "message": "DataInputStream.java: Reordered methods to match libgcj.\n\n2003-05-04  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/DataInputStream.java:\n\tReordered methods to match libgcj.\n\nFrom-SVN: r66478", "tree": {"sha": "336a61ba98f9752f6d6a453ad29dcbdcabfefd3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/336a61ba98f9752f6d6a453ad29dcbdcabfefd3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34/comments", "author": null, "committer": null, "parents": [{"sha": "7df878256c6bb1edf30764f71dac7e9aec02d82c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df878256c6bb1edf30764f71dac7e9aec02d82c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df878256c6bb1edf30764f71dac7e9aec02d82c"}], "stats": {"total": 120, "additions": 71, "deletions": 49}, "files": [{"sha": "6affacc9b42f4641684b6e6e6be8034266ed7c81", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34", "patch": "@@ -1,3 +1,8 @@\n+2003-05-04  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/DataInputStream.java:\n+\tReordered methods to match libgcj.\n+\n 2003-05-03  Matt Kraai  <kraai@alumni.cmu.edu>\n \n \t* gnu/awt/gtk/GtkButtonPeer.java: Fix misspelling of"}, {"sha": "8c2f0e1ce159d986b434e97a87b2b299d09c27ef", "filename": "libjava/java/io/DataInputStream.java", "status": "modified", "additions": 66, "deletions": 49, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=f7529e026f2f1090e5cb68e2ecd2ce668b7e4a34", "patch": "@@ -129,6 +129,8 @@ public final int read(byte[] b, int off, int len) throws IOException\n    * @exception EOFException If end of file is reached before reading\n    * the boolean\n    * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput#writeBoolean\n    */\n   public final boolean readBoolean() throws IOException\n   {\n@@ -148,7 +150,7 @@ public final boolean readBoolean() throws IOException\n    * @exception EOFException If end of file is reached before reading the byte\n    * @exception IOException If any other error occurs\n    *\n-   * @see DataOutput\n+   * @see DataOutput#writeByte\n    */\n   public final byte readByte() throws IOException\n   {\n@@ -178,7 +180,7 @@ public final byte readByte() throws IOException\n    * @exception EOFException If end of file is reached before reading the char\n    * @exception IOException If any other error occurs\n    *\n-   * @see DataOutput\n+   * @see DataOutput#writeChar\n    */\n   public final char readChar() throws IOException\n   {\n@@ -204,8 +206,8 @@ public final char readChar() throws IOException\n    * the double\n    * @exception IOException If any other error occurs\n    *\n-   * @see java.lang.Double\n-   * @see DataOutput\n+   * @see DataOutput#writeDouble\n+   * @see java.lang.Double#longBitsToDouble\n    */\n   public final double readDouble() throws IOException\n   {\n@@ -221,16 +223,17 @@ public final double readDouble() throws IOException\n    * in the class <code>java.lang.Float</code>\n    * <p>\n    * This method can read a <code>float</code> written by an object\n-   * implementing the * <code>writeFloat()</code> method in the\n+   * implementing the <code>writeFloat()</code> method in the\n    * <code>DataOutput</code> interface.\n    *\n    * @return The <code>float</code> value read\n    *\n    * @exception EOFException If end of file is reached before reading the float\n    * @exception IOException If any other error occurs\n    *\n-   * @see java.lang.Float\n-   * @see DataOutput */\n+   * @see DataOutput#writeFloat \n+   * @see java.lang.Float#intBitsToFloat\n+   */\n   public final float readFloat() throws IOException\n   {\n     return Float.intBitsToFloat(readInt());\n@@ -240,32 +243,38 @@ public final float readFloat() throws IOException\n    * This method reads raw bytes into the passed array until the array is\n    * full.  Note that this method blocks until the data is available and\n    * throws an exception if there is not enough data left in the stream to\n-   * fill the buffer\n+   * fill the buffer.  Note also that zero length buffers are permitted.\n+   * In this case, the method will return immediately without reading any\n+   * bytes from the stream.\n    *\n    * @param b The buffer into which to read the data\n    *\n-   * @exception EOFException If end of file is reached before filling\n-   * the buffer\n-   * @exception IOException If any other error occurs */\n+   * @exception EOFException If end of file is reached before filling the\n+   * buffer\n+   * @exception IOException If any other error occurs\n+   */\n   public final void readFully(byte[] b) throws IOException\n   {\n     readFully(b, 0, b.length);\n   }\n \n   /**\n-   * This method reads raw bytes into the passed array\n-   * <code>buf</code> starting <code>offset</code> bytes into the\n-   * buffer.  The number of bytes read will be exactly\n-   * <code>len</code> Note that this method blocks until the data is\n-   * available and * throws an exception if there is not enough data\n-   * left in the stream to read <code>len</code> bytes.\n+   * This method reads raw bytes into the passed array <code>buf</code>\n+   * starting\n+   * <code>offset</code> bytes into the buffer.  The number of bytes read\n+   * will be\n+   * exactly <code>len</code>.  Note that this method blocks until the data is\n+   * available and throws an exception if there is not enough data left in\n+   * the stream to read <code>len</code> bytes.  Note also that zero length\n+   * buffers are permitted.  In this case, the method will return immediately\n+   * without reading any bytes from the stream.\n    *\n    * @param buf The buffer into which to read the data\n    * @param offset The offset into the buffer to start storing data\n    * @param len The number of bytes to read into the buffer\n    *\n-   * @exception EOFException If end of file is reached before filling\n-   * the buffer\n+   * @exception EOFException If end of file is reached before filling the\n+   * buffer\n    * @exception IOException If any other error occurs\n    */\n   public final void readFully(byte[] b, int off, int len) throws IOException\n@@ -282,20 +291,20 @@ public final void readFully(byte[] b, int off, int len) throws IOException\n   }\n \n   /**\n-   * This method reads a Java <code>int</code> value from an input\n-   * stream It operates by reading four bytes from the stream and\n-   * converting them to a single Java <code>int</code> The bytes are\n-   * stored most significant byte first (i.e., \"big endian\")\n-   * regardless of the native host byte ordering.\n-   * <p>\n-   * As an example, if <code>byte1</code> through <code>byte4</code>\n-   * represent the first four bytes read from the stream, they will be\n+   * This method reads a Java <code>int</code> value from an input stream\n+   * It operates by reading four bytes from the stream and converting them to\n+   * a single Java <code>int</code>.  The bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering.\n+   * <p>\n+   * As an example, if <code>byte1</code> through <code>byte4</code> represent\n+   * the first four bytes read from the stream, they will be\n    * transformed to an <code>int</code> in the following manner:\n    * <p>\n-   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) + \n-   * ((byte3 & 0xFF) << 8) + (byte4 & 0xFF)))</code>\n+   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) +\n+   * ((byte3 & 0xFF)<< 8) + (byte4 & 0xFF)))</code>\n    * <p>\n-   * The value returned is in the range of 0 to 65535.\n+   * The value returned is in the range of -2147483648 to 2147483647.\n    * <p>\n    * This method can read an <code>int</code> written by an object\n    * implementing the <code>writeInt()</code> method in the\n@@ -306,7 +315,7 @@ public final void readFully(byte[] b, int off, int len) throws IOException\n    * @exception EOFException If end of file is reached before reading the int\n    * @exception IOException If any other error occurs\n    *\n-   * @see DataOutput\n+   * @see DataOutput#writeInt\n    */\n   public final int readInt() throws IOException\n   {\n@@ -428,22 +437,24 @@ else if (markSupported())\n   }\n \n   /**\n-   * This method reads a Java long value from an input stream\n-   * It operates by reading eight bytes from the stream and converting them to \n-   * a single Java <code>long</code>  The bytes are stored most\n+   * This method reads a Java <code>long</code> value from an input stream\n+   * It operates by reading eight bytes from the stream and converting them to\n+   * a single Java <code>long</code>.  The bytes are stored most\n    * significant byte first (i.e., \"big endian\") regardless of the native\n-   * host byte ordering. \n+   * host byte ordering.\n    * <p>\n-   * As an example, if <code>byte1</code> through <code>byte8</code>\n-   * represent the first eight bytes read from the stream, they will\n-   * be transformed to an <code>long</code> in the following manner:\n+   * As an example, if <code>byte1</code> through <code>byte8</code> represent\n+   * the first eight bytes read from the stream, they will be\n+   * transformed to an <code>long</code> in the following manner:\n    * <p>\n-   * <code>(long)((((long)byte1 & 0xFF) << 56) + (((long)byte2 & 0xFF) << 48) + \n-   * (((long)byte3 & 0xFF) << 40) + (((long)byte4 & 0xFF) << 32) + \n-   * (((long)byte5 & 0xFF) << 24) + (((long)byte6 & 0xFF) << 16) + \n-   * (((long)byte7 & 0xFF) << 8) + ((long)byte9 & 0xFF)))</code>\n+   * <code>(long)(((byte1 & 0xFF) << 56) + ((byte2 & 0xFF) << 48) +\n+   * ((byte3 & 0xFF) << 40) + ((byte4 & 0xFF) << 32) +\n+   * ((byte5 & 0xFF) << 24) + ((byte6 & 0xFF) << 16) +\n+   * ((byte7 & 0xFF) << 8) + (byte8 & 0xFF)))\n+   * </code>\n    * <p>\n-   * The value returned is in the range of 0 to 65535.\n+   * The value returned is in the range of -9223372036854775808 to\n+   * 9223372036854775807.\n    * <p>\n    * This method can read an <code>long</code> written by an object\n    * implementing the <code>writeLong()</code> method in the\n@@ -454,7 +465,7 @@ else if (markSupported())\n    * @exception EOFException If end of file is reached before reading the long\n    * @exception IOException If any other error occurs\n    *\n-   * @see DataOutput\n+   * @see DataOutput#writeLong\n    */\n   public final long readLong() throws IOException\n   {\n@@ -474,7 +485,7 @@ public final long readLong() throws IOException\n    * respectively, they will be transformed to a <code>short</code>. in\n    * the following manner:\n    * <p>\n-   * <code>(short)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF)</code>\n+   * <code>(short)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF))</code>\n    * <p>\n    * The value returned is in the range of -32768 to 32767.\n    * <p>\n@@ -487,14 +498,14 @@ public final long readLong() throws IOException\n    * @exception EOFException If end of file is reached before reading the value\n    * @exception IOException If any other error occurs\n    *\n-   * @see DataOutput\n+   * @see DataOutput#writeShort\n    */\n   public final short readShort() throws IOException\n   {\n     readFully (buf, 0, 2);\n     return convertToShort(buf);\n   }\n-\n+  \n   /**\n    * This method reads 8 unsigned bits into a Java <code>int</code>\n    * value from the stream. The value returned is in the range of 0 to\n@@ -509,7 +520,7 @@ public final short readShort() throws IOException\n    * @exception EOFException If end of file is reached before reading the value\n    * @exception IOException If any other error occurs\n    *\n-   * @see DataOutput\n+   * @see DataOutput#writeByte\n    */\n   public final int readUnsignedByte() throws IOException\n   {\n@@ -540,6 +551,8 @@ public final int readUnsignedByte() throws IOException\n    *\n    * @exception EOFException If end of file is reached before reading the value\n    * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput#writeShort\n    */\n   public final int readUnsignedShort() throws IOException\n   {\n@@ -616,7 +629,7 @@ public final int readUnsignedShort() throws IOException\n    * @exception UTFDataFormatException If the data is not in UTF-8 format\n    * @exception IOException If any other error occurs\n    *\n-   * @see DataOutput\n+   * @see DataOutput#writeUTF\n    */\n   public final String readUTF() throws IOException\n   {\n@@ -632,6 +645,8 @@ public final String readUTF() throws IOException\n    * @return The String read from the source\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see DataInput#readUTF\n    */\n   public final static String readUTF(DataInput in) throws IOException\n   {\n@@ -654,7 +669,9 @@ public final static String readUTF(DataInput in) throws IOException\n    * to skip. \n    *\n    * @param n The requested number of bytes to skip.\n+   *\n    * @return The requested number of bytes to skip.\n+   *\n    * @exception IOException If an error occurs.\n    * @specnote The JDK docs claim that this returns the number of bytes \n    *  actually skipped. The JCL claims that this method can throw an "}]}