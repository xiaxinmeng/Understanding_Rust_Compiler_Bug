{"sha": "c9d74da68c27d7af5c5c2edef7f723190ab461d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlkNzRkYTY4YzI3ZDdhZjVjNWMyZWRlZjdmNzIzMTkwYWI0NjFkMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-10-02T19:34:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-10-02T19:34:38Z"}, "message": "ira.h (target_ira): Add x_ira_class_singleton.\n\ngcc/\n\t* ira.h (target_ira): Add x_ira_class_singleton.\n\t(ira_class_singleton): New macro.\n\t* ira.c (setup_prohibited_class_mode_regs): Set up ira_class_singleton.\n\t* ira-build.c (update_conflict_hard_reg_costs): Use\n\tira_class_singleton to check for classes with a single\n\tallocatable register.\n\t* ira-lives.c (ira_implicitly_set_insn_hard_regs): Likewise.\n\t(single_reg_class): Likewise.  When more than one class is specified,\n\tcheck whether they have the same singleton register.\n\t(process_single_reg_class_operands): Require single_reg_class\n\tto return NO_REGS or a class with a single allocatable register.\n\tObtain that register from ira_class_singleton.\n\nFrom-SVN: r191995", "tree": {"sha": "db8ded671097465c0fd2ce2c9d3774344bcda7fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db8ded671097465c0fd2ce2c9d3774344bcda7fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9d74da68c27d7af5c5c2edef7f723190ab461d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9d74da68c27d7af5c5c2edef7f723190ab461d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9d74da68c27d7af5c5c2edef7f723190ab461d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9d74da68c27d7af5c5c2edef7f723190ab461d2/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59a2dfe8d754913ff356c83e1c9a7106a69aad11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a2dfe8d754913ff356c83e1c9a7106a69aad11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a2dfe8d754913ff356c83e1c9a7106a69aad11"}], "stats": {"total": 76, "additions": 55, "deletions": 21}, "files": [{"sha": "ad6c14bac818ca27288795def10d8a1e1f476fbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9d74da68c27d7af5c5c2edef7f723190ab461d2", "patch": "@@ -1,3 +1,18 @@\n+2012-10-02  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* ira.h (target_ira): Add x_ira_class_singleton.\n+\t(ira_class_singleton): New macro.\n+\t* ira.c (setup_prohibited_class_mode_regs): Set up ira_class_singleton.\n+\t* ira-build.c (update_conflict_hard_reg_costs): Use\n+\tira_class_singleton to check for classes with a single\n+\tallocatable register.\n+\t* ira-lives.c (ira_implicitly_set_insn_hard_regs): Likewise.\n+\t(single_reg_class): Likewise.  When more than one class is specified,\n+\tcheck whether they have the same singleton register.\n+\t(process_single_reg_class_operands): Require single_reg_class\n+\tto return NO_REGS or a class with a single allocatable register.\n+\tObtain that register from ira_class_singleton.\n+\n 2012-10-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_option_override_internal): If"}, {"sha": "1181813d92b98ffa529f19c18e51daecedea5f3c", "filename": "gcc/ira-build.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=c9d74da68c27d7af5c5c2edef7f723190ab461d2", "patch": "@@ -3047,11 +3047,10 @@ update_conflict_hard_reg_costs (void)\n     {\n       reg_class_t aclass = ALLOCNO_CLASS (a);\n       reg_class_t pref = reg_preferred_class (ALLOCNO_REGNO (a));\n-\n-      if (reg_class_size[(int) pref] != 1)\n+      int singleton = ira_class_singleton[pref][ALLOCNO_MODE (a)];\n+      if (singleton < 0)\n \tcontinue;\n-      index = ira_class_hard_reg_index[(int) aclass]\n-\t\t\t\t      [ira_class_hard_regs[(int) pref][0]];\n+      index = ira_class_hard_reg_index[(int) aclass][singleton];\n       if (index < 0)\n \tcontinue;\n       if (ALLOCNO_CONFLICT_HARD_REG_COSTS (a) == NULL"}, {"sha": "853832e3c9faefacda22d746de84be6dc697ff5f", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=c9d74da68c27d7af5c5c2edef7f723190ab461d2", "patch": "@@ -849,9 +849,10 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t  next_cl = (c == 'r'\n \t\t     ? GENERAL_REGS\n \t\t     : REG_CLASS_FROM_CONSTRAINT (c, constraints));\n-\t  if ((cl != NO_REGS && next_cl != cl)\n-\t      || (ira_class_hard_regs_num[next_cl]\n-\t\t  > ira_reg_class_max_nregs[next_cl][GET_MODE (op)]))\n+\t  if (cl == NO_REGS\n+\t      ? ira_class_singleton[next_cl][GET_MODE (op)] < 0\n+\t      : (ira_class_singleton[cl][GET_MODE (op)]\n+\t\t != ira_class_singleton[next_cl][GET_MODE (op)]))\n \t    return NO_REGS;\n \t  cl = next_cl;\n \t  break;\n@@ -861,10 +862,10 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t  next_cl\n \t    = single_reg_class (recog_data.constraints[c - '0'],\n \t\t\t\trecog_data.operand[c - '0'], NULL_RTX);\n-\t  if ((cl != NO_REGS && next_cl != cl)\n-\t      || next_cl == NO_REGS\n-\t      || (ira_class_hard_regs_num[next_cl]\n-\t\t  > ira_reg_class_max_nregs[next_cl][GET_MODE (op)]))\n+\t  if (cl == NO_REGS\n+\t      ? ira_class_singleton[next_cl][GET_MODE (op)] < 0\n+\t      : (ira_class_singleton[cl][GET_MODE (op)]\n+\t\t != ira_class_singleton[next_cl][GET_MODE (op)]))\n \t    return NO_REGS;\n \t  cl = next_cl;\n \t  break;\n@@ -939,13 +940,14 @@ ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n \t\t  cl = (c == 'r'\n \t\t\t? GENERAL_REGS\n \t\t\t: REG_CLASS_FROM_CONSTRAINT (c, p));\n-\t\t  if (cl != NO_REGS\n+\t\t  if (cl != NO_REGS)\n+\t\t    {\n \t\t      /* There is no register pressure problem if all of the\n \t\t\t regs in this class are fixed.  */\n-\t\t      && ira_class_hard_regs_num[cl] != 0\n-\t\t      && (ira_class_hard_regs_num[cl]\n-\t\t\t  <= ira_reg_class_max_nregs[cl][mode]))\n-\t\t    IOR_HARD_REG_SET (*set, reg_class_contents[cl]);\n+\t\t      int regno = ira_class_singleton[cl][mode];\n+\t\t      if (regno >= 0)\n+\t\t\tadd_to_hard_reg_set (set, mode, regno);\n+\t\t    }\n \t\t  break;\n \t\t}\n \t}\n@@ -989,8 +991,7 @@ process_single_reg_class_operands (bool in_p, int freq)\n \n \t  operand_a = ira_curr_regno_allocno_map[regno];\n \t  aclass = ALLOCNO_CLASS (operand_a);\n-\t  if (ira_class_subset_p[cl][aclass]\n-\t      && ira_class_hard_regs_num[cl] != 0)\n+\t  if (ira_class_subset_p[cl][aclass])\n \t    {\n \t      /* View the desired allocation of OPERAND as:\n \n@@ -1004,7 +1005,8 @@ process_single_reg_class_operands (bool in_p, int freq)\n \t      HOST_WIDE_INT offset;\n \n \t      xmode = recog_data.operand_mode[i];\n-\t      xregno = ira_class_hard_regs[cl][0];\n+\t      xregno = ira_class_singleton[cl][xmode];\n+\t      gcc_assert (xregno >= 0);\n \t      ymode = ALLOCNO_MODE (operand_a);\n \t      offset = subreg_lowpart_offset (ymode, xmode);\n \t      yregno = simplify_subreg_regno (xregno, xmode, offset, ymode);"}, {"sha": "8436f606d97800a00eae9e914514688c4d61fe44", "filename": "gcc/ira.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=c9d74da68c27d7af5c5c2edef7f723190ab461d2", "patch": "@@ -1451,24 +1451,36 @@ setup_reg_class_nregs (void)\n \n \f\n \n-/* Set up IRA_PROHIBITED_CLASS_MODE_REGS.  */\n+/* Set up IRA_PROHIBITED_CLASS_MODE_REGS and IRA_CLASS_SINGLETON.\n+   This function is called once IRA_CLASS_HARD_REGS has been initialized.  */\n static void\n setup_prohibited_class_mode_regs (void)\n {\n-  int j, k, hard_regno, cl;\n+  int j, k, hard_regno, cl, last_hard_regno, count;\n \n   for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n     {\n+      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       for (j = 0; j < NUM_MACHINE_MODES; j++)\n \t{\n+\t  count = 0;\n+\t  last_hard_regno = -1;\n \t  CLEAR_HARD_REG_SET (ira_prohibited_class_mode_regs[cl][j]);\n \t  for (k = ira_class_hard_regs_num[cl] - 1; k >= 0; k--)\n \t    {\n \t      hard_regno = ira_class_hard_regs[cl][k];\n \t      if (! HARD_REGNO_MODE_OK (hard_regno, (enum machine_mode) j))\n \t\tSET_HARD_REG_BIT (ira_prohibited_class_mode_regs[cl][j],\n \t\t\t\t  hard_regno);\n+\t      else if (in_hard_reg_set_p (temp_hard_regset,\n+\t\t\t\t\t  (enum machine_mode) j, hard_regno))\n+\t\t{\n+\t\t  last_hard_regno = hard_regno;\n+\t\t  count++;\n+\t\t}\n \t    }\n+\t  ira_class_singleton[cl][j] = (count == 1 ? last_hard_regno : -1);\n \t}\n     }\n }"}, {"sha": "6870c4bf3039e570065f77137d689511825b94f2", "filename": "gcc/ira.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d74da68c27d7af5c5c2edef7f723190ab461d2/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=c9d74da68c27d7af5c5c2edef7f723190ab461d2", "patch": "@@ -79,6 +79,10 @@ struct target_ira {\n      class.  */\n   int x_ira_class_hard_regs_num[N_REG_CLASSES];\n \n+  /* If class CL has a single allocatable register of mode M,\n+     index [CL][M] gives the number of that register, otherwise it is -1.  */\n+  short x_ira_class_singleton[N_REG_CLASSES][MAX_MACHINE_MODE];\n+\n   /* Function specific hard registers can not be used for the register\n      allocation.  */\n   HARD_REG_SET x_ira_no_alloc_regs;\n@@ -117,6 +121,8 @@ extern struct target_ira *this_target_ira;\n   (this_target_ira->x_ira_class_hard_regs)\n #define ira_class_hard_regs_num \\\n   (this_target_ira->x_ira_class_hard_regs_num)\n+#define ira_class_singleton \\\n+  (this_target_ira->x_ira_class_singleton)\n #define ira_no_alloc_regs \\\n   (this_target_ira->x_ira_no_alloc_regs)\n "}]}