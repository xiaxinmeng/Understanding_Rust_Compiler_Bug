{"sha": "a79fe53d6ce6074d083e925b6b19773e45817405", "node_id": "C_kwDOANBUbNoAKGE3OWZlNTNkNmNlNjA3NGQwODNlOTI1YjZiMTk3NzNlNDU4MTc0MDU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-05T14:01:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-05T16:38:22Z"}, "message": "Amend split vector loop analysis into main and epilogue analysis\n\nI forgot to commit the changes done as response to Richards review\nbefore committing.\n\n2021-11-05  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_analyze_loop): Remove obsolete\n\tcomment and expand on another one.  Combine nested if.", "tree": {"sha": "6264c302ce035f8216a1ecd70de65daad66cf4ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6264c302ce035f8216a1ecd70de65daad66cf4ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a79fe53d6ce6074d083e925b6b19773e45817405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79fe53d6ce6074d083e925b6b19773e45817405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a79fe53d6ce6074d083e925b6b19773e45817405", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79fe53d6ce6074d083e925b6b19773e45817405/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db89d474ad812e57895cb8866ebaeedad0cc3e3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db89d474ad812e57895cb8866ebaeedad0cc3e3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db89d474ad812e57895cb8866ebaeedad0cc3e3f"}], "stats": {"total": 48, "additions": 10, "deletions": 38}, "files": [{"sha": "b56b7a4a38640e477e13c8a1a80d5b3318f7da3a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 38, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79fe53d6ce6074d083e925b6b19773e45817405/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79fe53d6ce6074d083e925b6b19773e45817405/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a79fe53d6ce6074d083e925b6b19773e45817405", "patch": "@@ -2998,35 +2998,6 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n       return opt_loop_vec_info::propagate_failure (res);\n     }\n \n-  /* When pick_lowest_cost_p is true, we should in principle iterate\n-     over all the loop_vec_infos that LOOP_VINFO could replace and\n-     try to vectorize LOOP_VINFO under the same conditions.\n-     E.g. when trying to replace an epilogue loop, we should vectorize\n-     LOOP_VINFO as an epilogue loop with the same VF limit.  When trying\n-     to replace the main loop, we should vectorize LOOP_VINFO as a main\n-     loop too.\n-\n-     However, autovectorize_vector_modes is usually sorted as follows:\n-\n-     - Modes that naturally produce lower VFs usually follow modes that\n-     naturally produce higher VFs.\n-\n-     - When modes naturally produce the same VF, maskable modes\n-     usually follow unmaskable ones, so that the maskable mode\n-     can be used to vectorize the epilogue of the unmaskable mode.\n-\n-     This order is preferred because it leads to the maximum\n-     epilogue vectorization opportunities.  Targets should only use\n-     a different order if they want to make wide modes available while\n-     disparaging them relative to earlier, smaller modes.  The assumption\n-     in that case is that the wider modes are more expensive in some\n-     way that isn't reflected directly in the costs.\n-\n-     There should therefore be few interesting cases in which\n-     LOOP_VINFO fails when treated as an epilogue loop, succeeds when\n-     treated as a standalone loop, and ends up being genuinely cheaper\n-     than FIRST_LOOP_VINFO.  */\n-\n   auto_vector_modes vector_modes;\n   /* Autodetect first vector size we try.  */\n   vector_modes.safe_push (VOIDmode);\n@@ -3042,7 +3013,10 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n   unsigned int first_loop_next_i = 0;\n   unsigned HOST_WIDE_INT simdlen = loop->simdlen;\n \n-  /* First determine the main loop vectorization mode.  */\n+  /* First determine the main loop vectorization mode, either the first\n+     one that works, starting with auto-detecting the vector mode and then\n+     following the targets order of preference, or the one with the\n+     lowest cost if pick_lowest_cost_p.  */\n   while (1)\n     {\n       unsigned int loop_vinfo_i = mode_i;\n@@ -3065,15 +3039,13 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n \t      simdlen = 0;\n \t    }\n-\t  else if (pick_lowest_cost_p && first_loop_vinfo)\n+\t  else if (pick_lowest_cost_p\n+\t\t   && first_loop_vinfo\n+\t\t   && vect_joust_loop_vinfos (loop_vinfo, first_loop_vinfo))\n \t    {\n-\t      /* Keep trying to roll back vectorization attempts while the\n-\t\t loop_vec_infos they produced were worse than this one.  */\n-\t      if (vect_joust_loop_vinfos (loop_vinfo, first_loop_vinfo))\n-\t\t{\n-\t\t  delete first_loop_vinfo;\n-\t\t  first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-\t\t}\n+\t      /* Pick loop_vinfo over first_loop_vinfo.  */\n+\t      delete first_loop_vinfo;\n+\t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n \t    }\n \t  if (first_loop_vinfo == NULL)\n \t    {"}]}