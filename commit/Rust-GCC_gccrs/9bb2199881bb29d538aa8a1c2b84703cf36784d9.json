{"sha": "9bb2199881bb29d538aa8a1c2b84703cf36784d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJiMjE5OTg4MWJiMjlkNTM4YWE4YTFjMmI4NDcwM2NmMzY3ODRkOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-08-18T17:16:40Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-08-18T17:16:40Z"}, "message": "Indentation fixes\n\nFrom-SVN: r28751", "tree": {"sha": "eeb8db87eb3d7dbbaecf464dadcdfecaf6f6390e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeb8db87eb3d7dbbaecf464dadcdfecaf6f6390e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bb2199881bb29d538aa8a1c2b84703cf36784d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb2199881bb29d538aa8a1c2b84703cf36784d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb2199881bb29d538aa8a1c2b84703cf36784d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb2199881bb29d538aa8a1c2b84703cf36784d9/comments", "author": null, "committer": null, "parents": [{"sha": "3648099b8b44fcb028629dd2c8fff27dfa6d3205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3648099b8b44fcb028629dd2c8fff27dfa6d3205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3648099b8b44fcb028629dd2c8fff27dfa6d3205"}], "stats": {"total": 116, "additions": 58, "deletions": 58}, "files": [{"sha": "c65d101bf630e6485870097f5bd010f85b4266c5", "filename": "gcc/unroll.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb2199881bb29d538aa8a1c2b84703cf36784d9/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb2199881bb29d538aa8a1c2b84703cf36784d9/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=9bb2199881bb29d538aa8a1c2b84703cf36784d9", "patch": "@@ -353,7 +353,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n       return;\n     }\n   else if (loop_info->n_iterations > 0\n-      && loop_info->n_iterations * insn_count < MAX_UNROLLED_INSNS)\n+\t   && loop_info->n_iterations * insn_count < MAX_UNROLLED_INSNS)\n     {\n       unroll_number = loop_info->n_iterations;\n       unroll_type = UNROLL_COMPLETELY;\n@@ -783,71 +783,71 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   /* Mark all local registers, i.e. the ones which are referenced only\n      inside the loop.  */\n   if (INSN_UID (copy_end) < max_uid_for_loop)\n-  {\n-    int copy_start_luid = INSN_LUID (copy_start);\n-    int copy_end_luid = INSN_LUID (copy_end);\n+    {\n+      int copy_start_luid = INSN_LUID (copy_start);\n+      int copy_end_luid = INSN_LUID (copy_end);\n \n-    /* If a register is used in the jump insn, we must not duplicate it\n-       since it will also be used outside the loop.  */\n-    if (GET_CODE (copy_end) == JUMP_INSN)\n-      copy_end_luid--;\n+      /* If a register is used in the jump insn, we must not duplicate it\n+\t since it will also be used outside the loop.  */\n+      if (GET_CODE (copy_end) == JUMP_INSN)\n+\tcopy_end_luid--;\n \n-    /* If we have a target that uses cc0, then we also must not duplicate\n-       the insn that sets cc0 before the jump insn.  */\n+      /* If we have a target that uses cc0, then we also must not duplicate\n+\t the insn that sets cc0 before the jump insn.  */\n #ifdef HAVE_cc0\n-    if (GET_CODE (copy_end) == JUMP_INSN)\n-      copy_end_luid--;\n+      if (GET_CODE (copy_end) == JUMP_INSN)\n+\tcopy_end_luid--;\n #endif\n \n-    /* If copy_start points to the NOTE that starts the loop, then we must\n-       use the next luid, because invariant pseudo-regs moved out of the loop\n-       have their lifetimes modified to start here, but they are not safe\n-       to duplicate.  */\n-    if (copy_start == loop_start)\n-      copy_start_luid++;\n-\n-    /* If a pseudo's lifetime is entirely contained within this loop, then we\n-       can use a different pseudo in each unrolled copy of the loop.  This\n-       results in better code.  */\n-    /* We must limit the generic test to max_reg_before_loop, because only\n-       these pseudo registers have valid regno_first_uid info.  */\n-    for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; ++j)\n-      if (REGNO_FIRST_UID (j) > 0 && REGNO_FIRST_UID (j) <= max_uid_for_loop\n-\t  && uid_luid[REGNO_FIRST_UID (j)] >= copy_start_luid\n-\t  && REGNO_LAST_UID (j) > 0 && REGNO_LAST_UID (j) <= max_uid_for_loop\n-\t  && uid_luid[REGNO_LAST_UID (j)] <= copy_end_luid)\n+      /* If copy_start points to the NOTE that starts the loop, then we must\n+\t use the next luid, because invariant pseudo-regs moved out of the loop\n+\t have their lifetimes modified to start here, but they are not safe\n+\t to duplicate.  */\n+      if (copy_start == loop_start)\n+\tcopy_start_luid++;\n+\n+      /* If a pseudo's lifetime is entirely contained within this loop, then we\n+\t can use a different pseudo in each unrolled copy of the loop.  This\n+\t results in better code.  */\n+      /* We must limit the generic test to max_reg_before_loop, because only\n+\t these pseudo registers have valid regno_first_uid info.  */\n+      for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; ++j)\n+\tif (REGNO_FIRST_UID (j) > 0 && REGNO_FIRST_UID (j) <= max_uid_for_loop\n+\t    && uid_luid[REGNO_FIRST_UID (j)] >= copy_start_luid\n+\t    && REGNO_LAST_UID (j) > 0 && REGNO_LAST_UID (j) <= max_uid_for_loop\n+\t    && uid_luid[REGNO_LAST_UID (j)] <= copy_end_luid)\n+\t  {\n+\t    /* However, we must also check for loop-carried dependencies.\n+\t       If the value the pseudo has at the end of iteration X is\n+\t       used by iteration X+1, then we can not use a different pseudo\n+\t       for each unrolled copy of the loop.  */\n+\t    /* A pseudo is safe if regno_first_uid is a set, and this\n+\t       set dominates all instructions from regno_first_uid to\n+\t       regno_last_uid.  */\n+\t    /* ??? This check is simplistic.  We would get better code if\n+\t       this check was more sophisticated.  */\n+\t    if (set_dominates_use (j, REGNO_FIRST_UID (j), REGNO_LAST_UID (j),\n+\t\t\t\t   copy_start, copy_end))\n+\t      local_regno[j] = 1;\n+\n+\t    if (loop_dump_stream)\n+\t      {\n+\t\tif (local_regno[j])\n+\t\t  fprintf (loop_dump_stream, \"Marked reg %d as local\\n\", j);\n+\t\telse\n+\t\t  fprintf (loop_dump_stream, \"Did not mark reg %d as local\\n\",\n+\t\t\t   j);\n+\t      }\n+\t  }\n+      /* Givs that have been created from multiple biv increments always have\n+\t local registers.  */\n+      for (j = first_increment_giv; j <= last_increment_giv; j++)\n \t{\n-\t  /* However, we must also check for loop-carried dependencies.\n-\t     If the value the pseudo has at the end of iteration X is\n-\t     used by iteration X+1, then we can not use a different pseudo\n-\t     for each unrolled copy of the loop.  */\n-\t  /* A pseudo is safe if regno_first_uid is a set, and this\n-\t     set dominates all instructions from regno_first_uid to\n-\t     regno_last_uid.  */\n-\t  /* ??? This check is simplistic.  We would get better code if\n-\t     this check was more sophisticated.  */\n-\t  if (set_dominates_use (j, REGNO_FIRST_UID (j), REGNO_LAST_UID (j),\n-\t\t\t\t copy_start, copy_end))\n-\t    local_regno[j] = 1;\n-\n+\t  local_regno[j] = 1;\n \t  if (loop_dump_stream)\n-\t    {\n-\t      if (local_regno[j])\n-\t\tfprintf (loop_dump_stream, \"Marked reg %d as local\\n\", j);\n-\t      else\n-\t\tfprintf (loop_dump_stream, \"Did not mark reg %d as local\\n\",\n-\t\t\t j);\n-\t    }\n+\t    fprintf (loop_dump_stream, \"Marked reg %d as local\\n\", j);\n \t}\n-    /* Givs that have been created from multiple biv increments always have\n-       local registers.  */\n-    for (j = first_increment_giv; j <= last_increment_giv; j++)\n-      {\n-\tlocal_regno[j] = 1;\n-\tif (loop_dump_stream)\n-\t  fprintf (loop_dump_stream, \"Marked reg %d as local\\n\", j);\n-      }\n-  }\n+    }\n \n   /* If this loop requires exit tests when unrolled, check to see if we\n      can precondition the loop so as to make the exit tests unnecessary."}]}