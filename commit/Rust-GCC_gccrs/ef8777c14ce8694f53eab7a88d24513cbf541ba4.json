{"sha": "ef8777c14ce8694f53eab7a88d24513cbf541ba4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY4Nzc3YzE0Y2U4Njk0ZjUzZWFiN2E4OGQyNDUxM2NiZjU0MWJhNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-11-19T14:00:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-11-19T14:00:46Z"}, "message": "re PR tree-optimization/92581 (condition chains vectorized wrongly)\n\n2019-11-19  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/92581\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): For\n\tcondition reduction chains gather all conditions involved\n\tfor computing the index reduction vector.\n\n\t* gcc.dg/vect/vect-cond-reduc-5.c: New testcase.\n\nFrom-SVN: r278445", "tree": {"sha": "2cbbd06661bf3326dfa440849a58b62a00d5e5c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cbbd06661bf3326dfa440849a58b62a00d5e5c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef8777c14ce8694f53eab7a88d24513cbf541ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef8777c14ce8694f53eab7a88d24513cbf541ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef8777c14ce8694f53eab7a88d24513cbf541ba4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef8777c14ce8694f53eab7a88d24513cbf541ba4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210"}], "stats": {"total": 106, "additions": 80, "deletions": 26}, "files": [{"sha": "99d6a51d51bf7a5bd990d8d95950142b8a80181c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef8777c14ce8694f53eab7a88d24513cbf541ba4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef8777c14ce8694f53eab7a88d24513cbf541ba4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef8777c14ce8694f53eab7a88d24513cbf541ba4", "patch": "@@ -1,3 +1,10 @@\n+2019-11-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92581\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): For\n+\tcondition reduction chains gather all conditions involved\n+\tfor computing the index reduction vector.\n+\n 2019-11-19  Dennis Zhang  <dennis.zhang@arm.com>\n \n \t* config/aarch64/aarch64-builtins.c (enum aarch64_builtins): Add"}, {"sha": "2acd0bde8f889dce26ff590bb70ccebf001871e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef8777c14ce8694f53eab7a88d24513cbf541ba4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef8777c14ce8694f53eab7a88d24513cbf541ba4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef8777c14ce8694f53eab7a88d24513cbf541ba4", "patch": "@@ -1,3 +1,8 @@\n+2019-11-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92581\n+\t* gcc.dg/vect/vect-cond-reduc-5.c: New testcase.\n+\n 2019-11-19  Dennis Zhang  <dennis.zhang@arm.com>\n \n \t* gcc.target/aarch64/acle/memtag_1.c: New test."}, {"sha": "1220875553b6845a50c316d1585fc3814d776020", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-reduc-5.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef8777c14ce8694f53eab7a88d24513cbf541ba4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef8777c14ce8694f53eab7a88d24513cbf541ba4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-5.c?ref=ef8777c14ce8694f53eab7a88d24513cbf541ba4", "patch": "@@ -0,0 +1,36 @@\n+#include \"tree-vect.h\"\n+\n+#define N 512\n+\n+int a[N], b[N];\n+\n+int __attribute__((noipa))\n+foo (int aval, int bval)\n+{\n+  int i, res = 0;\n+  for (i=0; i<N; i++)\n+  {\n+    if (a[i] != 0)\n+      res = aval;\n+    if (b[i] != 0)\n+      res = bval;\n+  }\n+  return res;\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+  if (foo (1, 2) != 0)\n+    abort ();\n+  a[3] = 1;\n+  b[4] = 1;\n+  if (foo (1, 2) != 2)\n+    abort ();\n+  a[7] = 1;\n+  if (foo (1, 2) != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_condition } } } */"}, {"sha": "e4a87e7afe3a150928dac4cd04aa0f3ee1ab3bf7", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef8777c14ce8694f53eab7a88d24513cbf541ba4/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef8777c14ce8694f53eab7a88d24513cbf541ba4/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ef8777c14ce8694f53eab7a88d24513cbf541ba4", "patch": "@@ -4552,18 +4552,26 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n      zeroes.  */\n   if (STMT_VINFO_REDUC_TYPE (reduc_info) == COND_REDUCTION)\n     {\n+      auto_vec<std::pair<tree, bool>, 2> ccompares;\n       stmt_vec_info cond_info = STMT_VINFO_REDUC_DEF (reduc_info);\n       cond_info = vect_stmt_to_vectorize (cond_info);\n-      while (gimple_assign_rhs_code (cond_info->stmt) != COND_EXPR)\n+      while (cond_info != reduc_info)\n \t{\n+\t  if (gimple_assign_rhs_code (cond_info->stmt) == COND_EXPR)\n+\t    {\n+\t      gimple *vec_stmt = STMT_VINFO_VEC_STMT (cond_info)->stmt;\n+\t      gcc_assert (gimple_assign_rhs_code (vec_stmt) == VEC_COND_EXPR);\n+\t      ccompares.safe_push\n+\t\t(std::make_pair (unshare_expr (gimple_assign_rhs1 (vec_stmt)),\n+\t\t\t\t STMT_VINFO_REDUC_IDX (cond_info) == 2));\n+\t    }\n \t  cond_info\n \t    = loop_vinfo->lookup_def (gimple_op (cond_info->stmt,\n \t\t\t\t\t\t 1 + STMT_VINFO_REDUC_IDX\n \t\t\t\t\t\t\t(cond_info)));\n \t  cond_info = vect_stmt_to_vectorize (cond_info);\n \t}\n-      gimple *vec_stmt = STMT_VINFO_VEC_STMT (cond_info)->stmt;\n-      gcc_assert (gimple_assign_rhs_code (vec_stmt) == VEC_COND_EXPR);\n+      gcc_assert (ccompares.length () != 0);\n \n       tree indx_before_incr, indx_after_incr;\n       poly_uint64 nunits_out = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -4605,37 +4613,35 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n       add_phi_arg (as_a <gphi *> (new_phi), vec_zero,\n \t\t   loop_preheader_edge (loop), UNKNOWN_LOCATION);\n \n-      /* Now take the condition from the loops original cond_expr\n-\t (VEC_STMT) and produce a new cond_expr (INDEX_COND_EXPR) which for\n+      /* Now take the condition from the loops original cond_exprs\n+\t and produce a new cond_exprs (INDEX_COND_EXPR) which for\n \t every match uses values from the induction variable\n \t (INDEX_BEFORE_INCR) otherwise uses values from the phi node\n \t (NEW_PHI_TREE).\n \t Finally, we update the phi (NEW_PHI_TREE) to take the value of\n \t the new cond_expr (INDEX_COND_EXPR).  */\n-\n-      /* Duplicate the condition from vec_stmt.  */\n-      tree ccompare = unshare_expr (gimple_assign_rhs1 (vec_stmt));\n-\n-      /* Create a conditional, where the condition is taken from vec_stmt\n-\t (CCOMPARE).  The then and else values mirror the main VEC_COND_EXPR:\n-\t the reduction phi corresponds to NEW_PHI_TREE and the new values\n-\t correspond to INDEX_BEFORE_INCR.  */\n-      gcc_assert (STMT_VINFO_REDUC_IDX (cond_info) >= 1);\n-      tree index_cond_expr;\n-      if (STMT_VINFO_REDUC_IDX (cond_info) == 2)\n-\tindex_cond_expr = build3 (VEC_COND_EXPR, cr_index_vector_type,\n-\t\t\t\t  ccompare, indx_before_incr, new_phi_tree);\n-      else\n-\tindex_cond_expr = build3 (VEC_COND_EXPR, cr_index_vector_type,\n-\t\t\t\t  ccompare, new_phi_tree, indx_before_incr);\n-      induction_index = make_ssa_name (cr_index_vector_type);\n-      gimple *index_condition = gimple_build_assign (induction_index,\n-\t\t\t\t\t\t     index_cond_expr);\n-      gsi_insert_before (&incr_gsi, index_condition, GSI_SAME_STMT);\n-      stmt_vec_info index_vec_info = loop_vinfo->add_stmt (index_condition);\n+      gimple_seq stmts = NULL;\n+      for (int i = ccompares.length () - 1; i != -1; --i)\n+\t{\n+\t  tree ccompare = ccompares[i].first;\n+\t  if (ccompares[i].second)\n+\t    new_phi_tree = gimple_build (&stmts, VEC_COND_EXPR,\n+\t\t\t\t\t cr_index_vector_type,\n+\t\t\t\t\t ccompare,\n+\t\t\t\t\t indx_before_incr, new_phi_tree);\n+\t  else\n+\t    new_phi_tree = gimple_build (&stmts, VEC_COND_EXPR,\n+\t\t\t\t\t cr_index_vector_type,\n+\t\t\t\t\t ccompare,\n+\t\t\t\t\t new_phi_tree, indx_before_incr);\n+\t}\n+      gsi_insert_seq_before (&incr_gsi, stmts, GSI_SAME_STMT);\n+      stmt_vec_info index_vec_info\n+\t= loop_vinfo->add_stmt (SSA_NAME_DEF_STMT (new_phi_tree));\n       STMT_VINFO_VECTYPE (index_vec_info) = cr_index_vector_type;\n \n       /* Update the phi with the vec cond.  */\n+      induction_index = new_phi_tree;\n       add_phi_arg (as_a <gphi *> (new_phi), induction_index,\n \t\t   loop_latch_edge (loop), UNKNOWN_LOCATION);\n     }"}]}