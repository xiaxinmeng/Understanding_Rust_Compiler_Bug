{"sha": "4d87f7a77cbb3865e5cc0aca0a900b324012254d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ4N2Y3YTc3Y2JiMzg2NWU1Y2MwYWNhMGE5MDBiMzI0MDEyMjU0ZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-03T12:48:48Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-02-03T12:48:48Z"}, "message": "loop.h (express_from): Declare.\n\n\t* loop.h (express_from): Declare.\n\t(struct induction): Replace derived flag with derived_from pointer.\n\t* loop.c (strength_reduce, record_giv, recombine_givs): Likewise.\n\t(express_from): No longer static.\n\t* unroll.c (find_splittable_givs): Replace derived with derived_from.\n\tWhen processing an address giv with which another giv has been\n\tcombined that has also been derived from a third giv, handle like\n\thaving combined with the third giv.\n\tSet splittable_regs_updates appropriately for derived givs.\n\nFrom-SVN: r25007", "tree": {"sha": "2745f7a520daf446daec4f2acf8993d311d58f60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2745f7a520daf446daec4f2acf8993d311d58f60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d87f7a77cbb3865e5cc0aca0a900b324012254d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d87f7a77cbb3865e5cc0aca0a900b324012254d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d87f7a77cbb3865e5cc0aca0a900b324012254d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d87f7a77cbb3865e5cc0aca0a900b324012254d/comments", "author": null, "committer": null, "parents": [{"sha": "6ebec6eed47e4066484b19d0bc9f44d739562d1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ebec6eed47e4066484b19d0bc9f44d739562d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ebec6eed47e4066484b19d0bc9f44d739562d1e"}], "stats": {"total": 84, "additions": 68, "deletions": 16}, "files": [{"sha": "95de3cb4c9c083a50b9d374b450d1990c4ad83be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87f7a77cbb3865e5cc0aca0a900b324012254d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87f7a77cbb3865e5cc0aca0a900b324012254d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d87f7a77cbb3865e5cc0aca0a900b324012254d", "patch": "@@ -1,3 +1,15 @@\n+Wed Feb  3 20:44:59 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.h (express_from): Declare.\n+\t(struct induction): Replace derived flag with derived_from pointer.\n+\t* loop.c (strength_reduce, record_giv, recombine_givs): Likewise.\n+\t(express_from): No longer static.\n+\t* unroll.c (find_splittable_givs): Replace derived with derived_from.\n+\tWhen processing an address giv with which another giv has been\n+\tcombined that has also been derived from a third giv, handle like\n+\thaving combined with the third giv.\n+\tSet splittable_regs_updates appropriately for derived givs.\n+\n Wed Feb  3 15:26:58 1999  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* config/mips/mips.md (div_trap_mips16): Remove nop's after branches."}, {"sha": "c0e78928ef700b5f237091d88a510b2fc39234d0", "filename": "gcc/loop.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87f7a77cbb3865e5cc0aca0a900b324012254d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87f7a77cbb3865e5cc0aca0a900b324012254d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=4d87f7a77cbb3865e5cc0aca0a900b324012254d", "patch": "@@ -320,7 +320,6 @@ static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *, int, int *));\n static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *, rtx *));\n static int check_dbra_loop PROTO((rtx, int, rtx, struct loop_info *));\n static rtx express_from_1 PROTO((rtx, rtx, rtx));\n-static rtx express_from PROTO((struct induction *, struct induction *));\n static rtx combine_givs_p PROTO((struct induction *, struct induction *));\n static void combine_givs PROTO((struct iv_class *));\n struct recombine_givs_stats;\n@@ -4180,7 +4179,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      v->auto_inc_opt = 0;\n \t      v->unrolled = 0;\n \t      v->shared = 0;\n-\t      v->derived = 0;\n+\t      v->derived_from = 0;\n \t      v->always_computable = 1;\n \t      v->always_executed = 1;\n \t      v->replaceable = 1;\n@@ -4622,7 +4621,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n \t      v->new_reg = gen_reg_rtx (v->mode);\n \n-\t      if (v->derived)\n+\t      if (v->derived_from)\n \t\t{\n \t\t  PATTERN (v->insn)\n \t\t    = replace_rtx (PATTERN (v->insn), v->dest_reg, v->new_reg);\n@@ -5273,7 +5272,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->auto_inc_opt = 0;\n   v->unrolled = 0;\n   v->shared = 0;\n-  v->derived = 0;\n+  v->derived_from = 0;\n   v->last_use = 0;\n \n   /* The v->always_computable field is used in update_giv_derive, to\n@@ -6632,7 +6631,7 @@ express_from_1 (a, b, mult)\n   return NULL_RTX;\n }\n \n-static rtx\n+rtx\n express_from (g1, g2)\n      struct induction *g1, *g2;\n {\n@@ -7290,7 +7289,7 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n \t  rtx sum;\n \n \t  v = giv_array[stats[i].giv_number];\n-\t  if (v->giv_type != DEST_REG || v->derived || v->same)\n+\t  if (v->giv_type != DEST_REG || v->derived_from || v->same)\n \t    continue;\n \t  if (! last_giv)\n \t    {\n@@ -7347,7 +7346,7 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n \t\t\t\t  gen_rtx_SET (GET_MODE (v->dest_reg),\n \t\t\t\t\t       v->dest_reg, sum), 0))\n \t    {\n-\t      v->derived = 1;\n+\t      v->derived_from = last_giv;\n \t      v->new_reg = v->dest_reg;\n \t      life_end = stats[i].end_luid;\n "}, {"sha": "50279bb09ecd2d77ce071feb72c3c06ca7cc5f3a", "filename": "gcc/loop.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87f7a77cbb3865e5cc0aca0a900b324012254d/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87f7a77cbb3865e5cc0aca0a900b324012254d/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=4d87f7a77cbb3865e5cc0aca0a900b324012254d", "patch": "@@ -101,8 +101,6 @@ struct induction\n \t\t\t\t   initialized in unrolled loop.  */\n   unsigned shared : 1;\n   unsigned no_const_addval : 1; /* 1 if add_val does not contain a const. */\n-  unsigned derived : 1;         /* For a giv, 1 if we decided to derive this\n-\t\t\t\t   giv from another one.  */\n   int lifetime;\t\t\t/* Length of life of this giv */\n   rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n \t\t\t\t   subtracted from add_val when this giv\n@@ -115,6 +113,8 @@ struct induction\n   struct induction *same;\t/* If this giv has been combined with another\n \t\t\t\t   giv, this points to the base giv.  The base\n \t\t\t\t   giv will have COMBINED_WITH non-zero.  */\n+  struct induction *derived_from;/* For a giv, if we decided to derive this\n+\t\t\t\t   giv from another one.  */\n   HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n \t\t\t\t   is split, and a constant is eliminated from\n \t\t\t\t   the address, the -constant is stored here\n@@ -226,6 +226,7 @@ extern int first_increment_giv, last_increment_giv;\n int invariant_p PROTO((rtx));\n rtx get_condition_for_loop PROTO((rtx));\n void emit_iv_add_mult PROTO((rtx, rtx, rtx, rtx, rtx));\n+rtx express_from PROTO((struct induction *, struct induction *));\n \n /* Forward declarations for non-static functions declared in stmt.c.  */\n void find_loop_tree_blocks PROTO((void));"}, {"sha": "341b80598820927f0b48c1b8352a9fdef56c70e4", "filename": "gcc/unroll.c", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87f7a77cbb3865e5cc0aca0a900b324012254d/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87f7a77cbb3865e5cc0aca0a900b324012254d/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=4d87f7a77cbb3865e5cc0aca0a900b324012254d", "patch": "@@ -1794,6 +1794,10 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t      giv_dest_reg = SET_DEST (set);\n \t      if (derived_regs[regno])\n \t\t{\n+\t\t  /* ??? This relies on SET_SRC (SET) to be of\n+\t\t     the form (plus (reg) (const_int)), and thus\n+\t\t     forces recombine_givs to restrict the kind\n+\t\t     of giv derivations it does before unrolling.  */\n \t\t  giv_src_reg = XEXP (SET_SRC (set), 0);\n \t\t  giv_inc = XEXP (SET_SRC (set), 1);\n \t\t}\n@@ -2830,7 +2834,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t}\n \t\t\n \t      splittable_regs[REGNO (v->new_reg)] = value;\n-\t      derived_regs[REGNO (v->new_reg)] = v->derived;\n+\t      derived_regs[REGNO (v->new_reg)] = v->derived_from != 0;\n \t    }\n \t  else\n \t    {\n@@ -2886,17 +2890,36 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t     Emit insn to initialize its value before loop start.  */\n \n \t\t  rtx tem = gen_reg_rtx (v->mode);\n+\t\t  struct induction *same = v->same;\n+\t\t  rtx new_reg = v->new_reg;\n \t\t  record_base_value (REGNO (tem), v->add_val, 0);\n \n+\t\t  if (same && same->derived_from)\n+\t\t    {\n+\t\t      /* calculate_giv_inc doesn't work for derived givs.\n+\t\t\t copy_loop_body works around the problem for the\n+\t\t\t DEST_REG givs themselves, but it can't handle\n+\t\t\t DEST_ADDR givs that have been combined with\n+\t\t\t derived a derived DEST_REG giv.\n+\t\t\t So Handle V as if the giv from which V->SAME has\n+\t\t\t been derived has been combined with V.\n+\t\t\t recombine_givs only derives givs from givs that\n+\t\t\t are reduced the ordinary, so we need not worry\n+\t\t\t about same->derived_from being in turn derived.  */\n+\n+\t\t      same = same->derived_from;\n+\t\t      new_reg = express_from (same, v);\n+\t\t    }\n+\n \t\t  /* If the address giv has a constant in its new_reg value,\n \t\t     then this constant can be pulled out and put in value,\n \t\t     instead of being part of the initialization code.  */\n \t\t  \n-\t\t  if (GET_CODE (v->new_reg) == PLUS\n-\t\t      && GET_CODE (XEXP (v->new_reg, 1)) == CONST_INT)\n+\t\t  if (GET_CODE (new_reg) == PLUS\n+\t\t      && GET_CODE (XEXP (new_reg, 1)) == CONST_INT)\n \t\t    {\n \t\t      v->dest_reg\n-\t\t\t= plus_constant (tem, INTVAL (XEXP (v->new_reg,1)));\n+\t\t\t= plus_constant (tem, INTVAL (XEXP (new_reg, 1)));\n \n \t\t      /* Only succeed if this will give valid addresses.\n \t\t\t Try to validate both the first and the last\n@@ -2907,9 +2930,9 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t\t  /* Save the negative of the eliminated const, so\n \t\t\t     that we can calculate the dest_reg's increment\n \t\t\t     value later.  */\n-\t\t\t  v->const_adjust = - INTVAL (XEXP (v->new_reg, 1));\n+\t\t\t  v->const_adjust = - INTVAL (XEXP (new_reg, 1));\n \n-\t\t\t  v->new_reg = XEXP (v->new_reg, 0);\n+\t\t\t  new_reg = XEXP (new_reg, 0);\n \t\t\t  if (loop_dump_stream)\n \t\t\t    fprintf (loop_dump_stream,\n \t\t\t\t     \"Eliminating constant from giv %d\\n\",\n@@ -2938,6 +2961,9 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t\t\t INSN_UID (v->insn));\n \t\t      continue;\n \t\t    }\n+\n+\t\t  v->new_reg = new_reg;\n+\t\t  v->same = same;\n \t\t  \n \t\t  /* We set this after the address check, to guarantee that\n \t\t     the register will be initialized.  */\n@@ -2992,6 +3018,15 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t\t\t INSN_UID (v->insn));\n \t\t      continue;\n \t\t    }\n+\t\t  if (v->same && v->same->derived_from)\n+\t\t    {\n+\t\t      /* Handle V as if the giv from which V->SAME has\n+\t\t\t been derived has been combined with V.  */\n+\n+\t\t      v->same = v->same->derived_from;\n+\t\t      v->new_reg = express_from (v->same, v);\n+\t\t    }\n+\n \t\t}\n \t      \n \t      /* Store the value of dest_reg into the insn.  This sharing\n@@ -3014,7 +3049,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t     Make sure that it's giv is marked as splittable here.  */\n \t\t  \n \t\t  splittable_regs[REGNO (v->new_reg)] = value;\n-\t\t  derived_regs[REGNO (v->new_reg)] = v->derived;\n+\t\t  derived_regs[REGNO (v->new_reg)] = v->derived_from != 0;\n \t\t  \n \t\t  /* Make it appear to depend upon itself, so that the\n \t\t     giv will be properly split in the main loop above.  */\n@@ -3058,6 +3093,11 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t  if (! v->ignore)\n \t    count = reg_biv_class[REGNO (v->src_reg)]->biv_count;\n \n+\t  if (count > 1 && v->derived_from)\n+\t     /* In this case, there is one set where the giv insn was and one\n+\t\tset each after each biv increment.  (Most are likely dead.)  */\n+\t    count++;\n+\n \t  splittable_regs_updates[REGNO (v->new_reg)] = count;\n \t}\n "}]}