{"sha": "5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYwYWQ2YTU2MTNhM2I0MzZkZmQ5MWNlN2MzYjk2OWFlZWFhNTVlYg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2014-06-26T09:16:28Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2014-06-26T09:16:28Z"}, "message": "Part 2 of the collect-utils library, now also used for collect2.\n\n        * Makefile.in (COLLECT2_OBJS): Add collect-utils.o.\n        (LTO_WRAPPER_OBJS): New variable.\n        (lto-wrapper$(exeext)): Use it.\n        * collect2.c: Include \"collect-utils.h\".\n        (verbose, debug): Remove variables.\n        (at_file_supplied): No longer static.\n        (tool_name): New variable.\n        (do_wait, fork_execute, maybe_unlink): Don't declare.\n        (tool_cleanup): No longer static.\n        (notice): Remove function.\n        (maybe_run_lto_and_relink, main, do_dsymutil): Add new arg to\n        fork_execute calls.\n        (collect_wait, do_wait, collect_execute): Remove functions.\n        (maybe_unlink): No longer static.\n        * collect2.h (verbose, debug): Don't declare.\n        (at_file_supplied): Declare.\n        * collect-utils.c (utils_cleanup): New arg from_signal.  All callers\n        changed.\n        (collect_execute): Replace with implementation from collect2, plus a\n        new arg use_atfile.  All callers changed.\n        (collect_wait): Replace with implementation from collect2.\n        (maybe_unlink_file): Remove function.\n        (fork_execute): Replace with implementation from collect2, plus a\n        new arg use_atfile.  All callers changed.\n        (do_wait): Add call to utils_cleanup to the error path.\n        * collect-utils.h (collect_execute, fork_execute, utils_cleanup,\n        tool_cleanup): Adjust declarations.\n        * lto-wrapper.c (tool_cleanup): Add unused bool argument.\n        * tlink.c: Include \"collect-utils.h\".\n        (tlink_execute): New arg use_atfile.  All callers changed.\n        (tlink_init, tlink_execute): Remove declarations.\n\nFrom-SVN: r212020", "tree": {"sha": "ca9b56a1959b3c1e842cc178449311307ce1841f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca9b56a1959b3c1e842cc178449311307ce1841f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/comments", "author": null, "committer": null, "parents": [{"sha": "608508a67719de05d2144200325662bda7204adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/608508a67719de05d2144200325662bda7204adc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/608508a67719de05d2144200325662bda7204adc"}], "stats": {"total": 501, "additions": 191, "deletions": 310}, "files": [{"sha": "114622daa9ef4ecaa47b9d9ff6fac72f8aed1978", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "patch": "@@ -1,5 +1,37 @@\n 2014-06-26  Bernd Schmidt  <bernds@codesourcery.com>\n \n+        * Makefile.in (COLLECT2_OBJS): Add collect-utils.o.\n+        (LTO_WRAPPER_OBJS): New variable.\n+        (lto-wrapper$(exeext)): Use it.\n+        * collect2.c: Include \"collect-utils.h\".\n+        (verbose, debug): Remove variables.\n+        (at_file_supplied): No longer static.\n+        (tool_name): New variable.\n+        (do_wait, fork_execute, maybe_unlink): Don't declare.\n+        (tool_cleanup): No longer static.\n+        (notice): Remove function.\n+        (maybe_run_lto_and_relink, main, do_dsymutil): Add new arg to\n+        fork_execute calls.\n+        (collect_wait, do_wait, collect_execute): Remove functions.\n+        (maybe_unlink): No longer static.\n+        * collect2.h (verbose, debug): Don't declare.\n+        (at_file_supplied): Declare.\n+        * collect-utils.c (utils_cleanup): New arg from_signal.  All callers\n+        changed.\n+        (collect_execute): Replace with implementation from collect2, plus a\n+        new arg use_atfile.  All callers changed.\n+        (collect_wait): Replace with implementation from collect2.\n+        (maybe_unlink_file): Remove function.\n+        (fork_execute): Replace with implementation from collect2, plus a\n+        new arg use_atfile.  All callers changed.\n+        (do_wait): Add call to utils_cleanup to the error path.\n+        * collect-utils.h (collect_execute, fork_execute, utils_cleanup)\n+        (tool_cleanup): Adjust declarations.\n+        * lto-wrapper.c (tool_cleanup): Add unused bool argument.\n+        * tlink.c: Include \"collect-utils.h\".\n+        (tlink_execute): New arg use_atfile.  All callers changed.\n+        (tlink_init, tlink_execute): Remove declarations.\n+\n     \t* collect-utils.c (save_temps): New variable.\n     \t(do_wait): Use it instead of debug.  Use fatal_error.\n     \t* collect-utils.h (save_temps): Declare."}, {"sha": "3d15eff267d6ccaea56d3a10d52729e1b61b7e21", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "patch": "@@ -1899,7 +1899,8 @@ gcc-ranlib.c: gcc-ar.c\n gcc-nm.c: gcc-ar.c\n \tcp $^ $@\n \n-COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o vec.o ggc-none.o file-find.o\n+COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o vec.o ggc-none.o \\\n+  collect-utils.o file-find.o\n COLLECT2_LIBS = @COLLECT2_LIBS@\n collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this."}, {"sha": "febc5192d1460df46bc4fed9be5e6b3b4c05efe8", "filename": "gcc/collect-utils.c", "status": "modified", "additions": 117, "deletions": 110, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Fcollect-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Fcollect-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect-utils.c?ref=5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "patch": "@@ -35,24 +35,6 @@ bool debug;\n bool verbose;\n bool save_temps;\n \n-/* Delete tempfiles.  */\n-\n-void\n-utils_cleanup (void)\n-{\n-  static bool cleanup_done = false;\n-\n-  if (cleanup_done)\n-    return;\n-\n-  /* Setting cleanup_done prevents an infinite loop if one of the\n-     calls to maybe_unlink fails. */\n-  cleanup_done = true;\n-\n-  if (response_file)\n-    maybe_unlink (response_file);\n-  tool_cleanup ();\n-}\n \n /* Notify user of a non-error.  */\n void\n@@ -69,62 +51,13 @@ void\n fatal_signal (int signum)\n {\n   signal (signum, SIG_DFL);\n-  utils_cleanup ();\n+  utils_cleanup (true);\n   /* Get the same signal again, this time not handled,\n      so its normal effect occurs.  */\n   kill (getpid (), signum);\n }\n-\n-/* Execute a program, and wait for the reply. ARGV are the arguments. The\n-   last one must be NULL. */\n-\n-struct pex_obj *\n-collect_execute (char **argv)\n-{\n-  struct pex_obj *pex;\n-  const char *errmsg;\n-  int err;\n-\n-  if (verbose)\n-    {\n-      char **p_argv;\n-      const char *str;\n-\n-      for (p_argv = argv; (str = *p_argv) != (char *) 0; p_argv++)\n-\tfprintf (stderr, \" %s\", str);\n-\n-      fprintf (stderr, \"\\n\");\n-    }\n-\n-  fflush (stdout);\n-  fflush (stderr);\n-\n-  pex = pex_init (0, tool_name, NULL);\n-  if (pex == NULL)\n-    fatal_error (\"pex_init failed: %m\");\n-\n-  /* Do not use PEX_LAST here, we use our stdout for communicating with\n-     collect2 or the linker-plugin.  Any output from the sub-process\n-     will confuse that.  */\n-  errmsg = pex_run (pex, PEX_SEARCH, argv[0], argv, NULL,\n-\t\t    NULL, &err);\n-  if (errmsg != NULL)\n-    {\n-      if (err != 0)\n-\t{\n-\t  errno = err;\n-\t  fatal_error (\"%s: %m\", _(errmsg));\n-\t}\n-      else\n-\tfatal_error (errmsg);\n-    }\n-\n-  return pex;\n-}\n-\n-\n-/* Wait for a process to finish, and exit if a nonzero status is found.\n-   PROG is the program name. PEX is the process we should wait for. */\n+\f\n+/* Wait for a process to finish, and exit if a nonzero status is found.  */\n \n int\n collect_wait (const char *prog, struct pex_obj *pex)\n@@ -140,18 +73,14 @@ collect_wait (const char *prog, struct pex_obj *pex)\n       if (WIFSIGNALED (status))\n \t{\n \t  int sig = WTERMSIG (status);\n-\t  if (WCOREDUMP (status))\n-\t    fatal_error (\"%s terminated with signal %d [%s], core dumped\",\n-\t\t\t prog, sig, strsignal (sig));\n-\t  else\n-\t    fatal_error (\"%s terminated with signal %d [%s]\",\n-\t\t\t prog, sig, strsignal (sig));\n+\t  fatal_error (\"%s terminated with signal %d [%s]%s\",\n+\t\t       prog, sig, strsignal (sig),\n+\t\t       WCOREDUMP (status) ? \", core dumped\" : \"\");\n \t}\n \n       if (WIFEXITED (status))\n-\tfatal_error (\"%s returned %d exit status\", prog, WEXITSTATUS (status));\n+\treturn WEXITSTATUS (status);\n     }\n-\n   return 0;\n }\n \n@@ -169,52 +98,130 @@ do_wait (const char *prog, struct pex_obj *pex)\n     }\n }\n \n-/* Unlink a temporary LTRANS file unless requested otherwise.  */\n+\f\n+/* Execute a program, and wait for the reply.  */\n \n-void\n-maybe_unlink_file (const char *file)\n+struct pex_obj *\n+collect_execute (const char *prog, char **argv, const char *outname,\n+\t\t const char *errname, int flags, bool use_atfile)\n {\n-  if (!debug)\n+  struct pex_obj *pex;\n+  const char *errmsg;\n+  int err;\n+  char *response_arg = NULL;\n+  char *response_argv[3];\n+\n+  if (use_atfile && argv[0] != NULL)\n     {\n-      if (unlink_if_ordinary (file)\n-\t  && errno != ENOENT)\n-\tfatal_error (\"deleting file %s: %m\", file);\n+      /* If using @file arguments, create a temporary file and put the\n+         contents of argv into it.  Then change argv to an array corresponding\n+         to a single argument @FILE, where FILE is the temporary filename.  */\n+\n+      char **current_argv = argv + 1;\n+      char *argv0 = argv[0];\n+      int status;\n+      FILE *f;\n+\n+      /* Note: we assume argv contains at least one element; this is\n+         checked above.  */\n+\n+      response_file = make_temp_file (\"\");\n+\n+      f = fopen (response_file, \"w\");\n+\n+      if (f == NULL)\n+        fatal_error (\"could not open response file %s\", response_file);\n+\n+      status = writeargv (current_argv, f);\n+\n+      if (status)\n+        fatal_error (\"could not write to response file %s\", response_file);\n+\n+      status = fclose (f);\n+\n+      if (EOF == status)\n+        fatal_error (\"could not close response file %s\", response_file);\n+\n+      response_arg = concat (\"@\", response_file, NULL);\n+      response_argv[0] = argv0;\n+      response_argv[1] = response_arg;\n+      response_argv[2] = NULL;\n+\n+      argv = response_argv;\n     }\n-  else\n-    fprintf (stderr, \"[Leaving %s]\\n\", file);\n-}\n \n+  if (verbose || debug)\n+    {\n+      char **p_argv;\n+      const char *str;\n+\n+      if (argv[0])\n+\tfprintf (stderr, \"%s\", argv[0]);\n+      else\n+\tnotice (\"[cannot find %s]\", prog);\n+\n+      for (p_argv = &argv[1]; (str = *p_argv) != (char *) 0; p_argv++)\n+\tfprintf (stderr, \" %s\", str);\n+\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  fflush (stdout);\n+  fflush (stderr);\n+\n+  /* If we cannot find a program we need, complain error.  Do this here\n+     since we might not end up needing something that we could not find.  */\n+\n+  if (argv[0] == 0)\n+    fatal_error (\"cannot find '%s'\", prog);\n+\n+  pex = pex_init (0, \"collect2\", NULL);\n+  if (pex == NULL)\n+    fatal_error (\"pex_init failed: %m\");\n+\n+  errmsg = pex_run (pex, flags, argv[0], argv, outname,\n+\t\t    errname, &err);\n+  if (errmsg != NULL)\n+    {\n+      if (err != 0)\n+\t{\n+\t  errno = err;\n+\t  fatal_error (\"%s: %m\", _(errmsg));\n+\t}\n+      else\n+\tfatal_error (errmsg);\n+    }\n \n-/* Execute program ARGV[0] with arguments ARGV. Wait for it to finish.  */\n+  free (response_arg);\n+\n+  return pex;\n+}\n \n void\n-fork_execute (char **argv)\n+fork_execute (const char *prog, char **argv, bool use_atfile)\n {\n   struct pex_obj *pex;\n-  char *new_argv[3];\n-  char *at_args;\n-  FILE *args;\n-  int status;\n-\n-  response_file = make_temp_file (\".args\");\n-  at_args = concat (\"@\", response_file, NULL);\n-  args = fopen (response_file, \"w\");\n-  if (args == NULL)\n-    fatal_error (\"failed to open %s\", response_file);\n \n-  status = writeargv (&argv[1], args);\n+  pex = collect_execute (prog, argv, NULL, NULL,\n+\t\t\t PEX_LAST | PEX_SEARCH, use_atfile);\n+  do_wait (prog, pex);\n+}\n \n-  if (status)\n-    fatal_error (\"could not write to temporary file %s\",  response_file);\n+/* Delete tempfiles.  */\n \n-  fclose (args);\n+void\n+utils_cleanup (bool from_signal)\n+{\n+  static bool cleanup_done = false;\n \n-  new_argv[0] = argv[0];\n-  new_argv[1] = at_args;\n-  new_argv[2] = NULL;\n+  if (cleanup_done)\n+    return;\n \n-  pex = collect_execute (new_argv);\n-  do_wait (new_argv[0], pex);\n+  /* Setting cleanup_done prevents an infinite loop if one of the\n+     calls to maybe_unlink fails. */\n+  cleanup_done = true;\n \n-  free (at_args);\n+  if (response_file)\n+    maybe_unlink (response_file);\n+  tool_cleanup (from_signal);\n }"}, {"sha": "2989c6b1da05fcd040d35809924c96ca824e4d49", "filename": "gcc/collect-utils.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Fcollect-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Fcollect-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect-utils.h?ref=5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "patch": "@@ -22,11 +22,14 @@ extern void notice (const char *, ...)\n   __attribute__ ((format (printf, 1, 2)));\n extern void fatal_signal (int);\n \n-extern struct pex_obj *collect_execute (char **);\n+extern struct pex_obj *collect_execute (const char *, char **,\n+\t\t\t\t\tconst char *, const char *,\n+\t\t\t\t\tint, bool);\n extern int collect_wait (const char *, struct pex_obj *);\n extern void do_wait (const char *, struct pex_obj *);\n-extern void fork_execute (char **);\n-extern void utils_cleanup (void);\n+extern void fork_execute (const char *, char **, bool);\n+extern void utils_cleanup (bool);\n+\n \n extern bool debug;\n extern bool verbose;\n@@ -37,5 +40,5 @@ extern bool save_temps;\n /* The name of the tool, printed in error messages.  */\n extern const char tool_name[];\n /* Called by utils_cleanup.  */\n-extern void tool_cleanup (void);\n+extern void tool_cleanup (bool);\n extern void maybe_unlink (const char *);"}, {"sha": "c54e6fb51578185696a33f2bf3dad8c0003d7f4c", "filename": "gcc/collect2.c", "status": "modified", "additions": 15, "deletions": 181, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"collect2.h\"\n #include \"collect2-aix.h\"\n+#include \"collect-utils.h\"\n #include \"diagnostic.h\"\n #include \"demangle.h\"\n #include \"obstack.h\"\n@@ -175,7 +176,6 @@ struct head\n   int number;\n };\n \n-bool verbose;\t\t\t\t/* true if -v or --version */ \n static int rflag;\t\t\t/* true if -r */\n static int strip_flag;\t\t\t/* true if -s */\n #ifdef COLLECT_EXPORT_LIST\n@@ -198,7 +198,6 @@ static enum lto_mode_d lto_mode = LTO_MODE_WHOPR;\n static enum lto_mode_d lto_mode = LTO_MODE_NONE;\n #endif\n \n-bool debug;\t\t\t\t/* true if -debug */\n bool helpflag;\t\t\t/* true if --help */\n \n static int shared_obj;\t\t\t/* true if -shared */\n@@ -234,8 +233,7 @@ static struct head exports;\t\t/* list of exported symbols */\n #endif\n static struct head frame_tables;\t/* list of frame unwind info tables */\n \n-static bool at_file_supplied;\t\t/* Whether to use @file arguments */\n-static char *response_file;\t\t/* Name of any current response file */\n+bool at_file_supplied;\t\t/* Whether to use @file arguments */\n \n struct obstack temporary_obstack;\n char * temporary_firstobj;\n@@ -296,12 +294,11 @@ typedef enum {\n   SYM_AIXD = 7\n } symkind;\n \n+const char tool_name[] = \"collect2\";\n+\n static symkind is_ctor_dtor (const char *);\n \n static void handler (int);\n-static void do_wait (const char *, struct pex_obj *);\n-static void fork_execute (const char *, char **);\n-static void maybe_unlink (const char *);\n static void maybe_unlink_list (char **);\n static void add_to_list (struct head *, const char *);\n static int extract_init_priority (const char *);\n@@ -382,7 +379,7 @@ static void scan_prog_file (const char *, scanpass, scanfilter);\n \f\n /* Delete tempfiles and exit function.  */\n \n-static void\n+void\n tool_cleanup (bool from_signal)\n {\n   if (c_file != 0 && c_file[0])\n@@ -428,18 +425,6 @@ handler (int signo)\n   signal (signo, SIG_DFL);\n   raise (signo);\n }\n-\f\n-/* Notify user of a non-error.  */\n-void\n-notice (const char *cmsgid, ...)\n-{\n-  va_list ap;\n-\n-  va_start (ap, cmsgid);\n-  vfprintf (stderr, _(cmsgid), ap);\n-  va_end (ap);\n-}\n-\n /* Notify user of a non-error, without translating the format string.  */\n void\n notice_translated (const char *cmsgid, ...)\n@@ -737,7 +722,8 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n       *lto_c_ptr = NULL;\n \n       /* Run the LTO back end.  */\n-      pex = collect_execute (prog, lto_c_argv, NULL, NULL, PEX_SEARCH);\n+      pex = collect_execute (prog, lto_c_argv, NULL, NULL, PEX_SEARCH,\n+\t\t\t     at_file_supplied);\n       {\n \tint c;\n \tFILE *stream;\n@@ -817,7 +803,7 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n \n       /* Run the linker again, this time replacing the object files\n          optimized by the LTO with the temporary file generated by the LTO.  */\n-      fork_execute (\"ld\", out_lto_ld_argv);\n+      fork_execute (\"ld\", out_lto_ld_argv, HAVE_GNU_LD && at_file_supplied);\n       post_ld_pass (true);\n       free (lto_ld_argv);\n \n@@ -827,7 +813,7 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n     {\n       /* Our caller is relying on us to do the link\n          even though there is no LTO back end work to be done.  */\n-      fork_execute (\"ld\", lto_ld_argv);\n+      fork_execute (\"ld\", lto_ld_argv, HAVE_GNU_LD && at_file_supplied);\n       post_ld_pass (false);\n     }\n   else\n@@ -1713,7 +1699,7 @@ main (int argc, char **argv)\n \t  strip_argv[0] = strip_file_name;\n \t  strip_argv[1] = output_file;\n \t  strip_argv[2] = (char *) 0;\n-\t  fork_execute (\"strip\", real_strip_argv);\n+\t  fork_execute (\"strip\", real_strip_argv, false);\n \t}\n \n #ifdef COLLECT_EXPORT_LIST\n@@ -1799,7 +1785,7 @@ main (int argc, char **argv)\n   /* Assemble the constructor and destructor tables.\n      Link the tables in with the rest of the program.  */\n \n-  fork_execute (\"gcc\",  c_argv);\n+  fork_execute (\"gcc\",  c_argv, at_file_supplied);\n #ifdef COLLECT_EXPORT_LIST\n   /* On AIX we must call tlink because of possible templates resolution.  */\n   do_tlink (ld2_argv, object_lst);\n@@ -1812,7 +1798,7 @@ main (int argc, char **argv)\n     maybe_run_lto_and_relink (ld2_argv, object_lst, object, true);\n   else\n     {\n-      fork_execute (\"ld\", ld2_argv);\n+      fork_execute (\"ld\", ld2_argv, HAVE_GNU_LD && at_file_supplied);\n       post_ld_pass (false);\n     }\n \n@@ -1831,164 +1817,11 @@ main (int argc, char **argv)\n   return 0;\n }\n \n-\f\n-/* Wait for a process to finish, and exit if a nonzero status is found.  */\n-\n-int\n-collect_wait (const char *prog, struct pex_obj *pex)\n-{\n-  int status;\n-\n-  if (!pex_get_status (pex, 1, &status))\n-    fatal_error (\"can't get program status: %m\");\n-  pex_free (pex);\n-\n-  if (status)\n-    {\n-      if (WIFSIGNALED (status))\n-\t{\n-\t  int sig = WTERMSIG (status);\n-\t  error (\"%s terminated with signal %d [%s]%s\",\n-\t\t prog, sig, strsignal (sig),\n-\t\t WCOREDUMP (status) ? \", core dumped\" : \"\");\n-\t  exit (FATAL_EXIT_CODE);\n-\t}\n-\n-      if (WIFEXITED (status))\n-\treturn WEXITSTATUS (status);\n-    }\n-  return 0;\n-}\n-\n-static void\n-do_wait (const char *prog, struct pex_obj *pex)\n-{\n-  int ret = collect_wait (prog, pex);\n-  if (ret != 0)\n-    {\n-      error (\"%s returned %d exit status\", prog, ret);\n-      exit (ret);\n-    }\n-\n-  if (response_file)\n-    {\n-      unlink (response_file);\n-      response_file = NULL;\n-    }\n-}\n-\n-\f\n-/* Execute a program, and wait for the reply.  */\n-\n-struct pex_obj *\n-collect_execute (const char *prog, char **argv, const char *outname,\n-\t\t const char *errname, int flags)\n-{\n-  struct pex_obj *pex;\n-  const char *errmsg;\n-  int err;\n-  char *response_arg = NULL;\n-  char *response_argv[3] ATTRIBUTE_UNUSED;\n-\n-  if (HAVE_GNU_LD && at_file_supplied && argv[0] != NULL)\n-    {\n-      /* If using @file arguments, create a temporary file and put the\n-         contents of argv into it.  Then change argv to an array corresponding\n-         to a single argument @FILE, where FILE is the temporary filename.  */\n-\n-      char **current_argv = argv + 1;\n-      char *argv0 = argv[0];\n-      int status;\n-      FILE *f;\n-\n-      /* Note: we assume argv contains at least one element; this is\n-         checked above.  */\n-\n-      response_file = make_temp_file (\"\");\n-\n-      f = fopen (response_file, \"w\");\n-\n-      if (f == NULL)\n-        fatal_error (\"could not open response file %s\", response_file);\n-\n-      status = writeargv (current_argv, f);\n-\n-      if (status)\n-        fatal_error (\"could not write to response file %s\", response_file);\n-\n-      status = fclose (f);\n-\n-      if (EOF == status)\n-        fatal_error (\"could not close response file %s\", response_file);\n-\n-      response_arg = concat (\"@\", response_file, NULL);\n-      response_argv[0] = argv0;\n-      response_argv[1] = response_arg;\n-      response_argv[2] = NULL;\n-\n-      argv = response_argv;\n-    }\n-\n-  if (verbose || debug)\n-    {\n-      char **p_argv;\n-      const char *str;\n-\n-      if (argv[0])\n-\tfprintf (stderr, \"%s\", argv[0]);\n-      else\n-\tnotice (\"[cannot find %s]\", prog);\n-\n-      for (p_argv = &argv[1]; (str = *p_argv) != (char *) 0; p_argv++)\n-\tfprintf (stderr, \" %s\", str);\n-\n-      fprintf (stderr, \"\\n\");\n-    }\n-\n-  fflush (stdout);\n-  fflush (stderr);\n-\n-  /* If we cannot find a program we need, complain error.  Do this here\n-     since we might not end up needing something that we could not find.  */\n-\n-  if (argv[0] == 0)\n-    fatal_error (\"cannot find '%s'\", prog);\n-\n-  pex = pex_init (0, \"collect2\", NULL);\n-  if (pex == NULL)\n-    fatal_error (\"pex_init failed: %m\");\n-\n-  errmsg = pex_run (pex, flags, argv[0], argv, outname,\n-\t\t    errname, &err);\n-  if (errmsg != NULL)\n-    {\n-      if (err != 0)\n-\t{\n-\t  errno = err;\n-\t  fatal_error (\"%s: %m\", _(errmsg));\n-\t}\n-      else\n-\tfatal_error (errmsg);\n-    }\n-\n-  free (response_arg);\n-\n-  return pex;\n-}\n-\n-static void\n-fork_execute (const char *prog, char **argv)\n-{\n-  struct pex_obj *pex;\n-\n-  pex = collect_execute (prog, argv, NULL, NULL, PEX_LAST | PEX_SEARCH);\n-  do_wait (prog, pex);\n-}\n \f\n /* Unlink FILE unless we are debugging or this is the output_file\n    and we may not unlink it.  */\n \n-static void\n+void\n maybe_unlink (const char *file)\n {\n   if (debug)\n@@ -3177,7 +3010,8 @@ do_dsymutil (const char *output_file) {\n   argv[1] = output_file;\n   argv[2] = (char *) 0;\n \n-  pex = collect_execute (dsymutil, real_argv, NULL, NULL, PEX_LAST | PEX_SEARCH);\n+  pex = collect_execute (dsymutil, real_argv, NULL, NULL,\n+\t\t\t PEX_LAST | PEX_SEARCH, false);\n   do_wait (dsymutil, pex);\n }\n "}, {"sha": "0fb7f515dd9ef648a74c964a02cd406ba0dea439", "filename": "gcc/collect2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Fcollect2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Fcollect2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.h?ref=5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "patch": "@@ -36,10 +36,10 @@ extern const char *lderrout;\n extern const char *c_file_name;\n extern struct obstack temporary_obstack;\n extern char *temporary_firstobj;\n-extern bool verbose, debug;\n extern bool may_unlink_output_file;\n \n extern void notice_translated (const char *, ...) ATTRIBUTE_PRINTF_1;\n extern void notice (const char *, ...) ATTRIBUTE_PRINTF_1;\n \n+extern bool at_file_supplied;\n #endif /* ! GCC_COLLECT2_H */"}, {"sha": "08fd090588fd948963e290b9188cb9ddb43fbd97", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "patch": "@@ -70,7 +70,7 @@ const char tool_name[] = \"lto-wrapper\";\n /* Delete tempfiles.  Called from utils_cleanup.  */\n \n void\n-tool_cleanup (void)\n+tool_cleanup (bool)\n {\n   unsigned int i;\n \n@@ -91,7 +91,7 @@ tool_cleanup (void)\n static void\n lto_wrapper_cleanup (void)\n {\n-  utils_cleanup ();\n+  utils_cleanup (false);\n }\n \n /* Unlink a temporary LTRANS file unless requested otherwise.  */\n@@ -684,7 +684,7 @@ run_gcc (unsigned argc, char *argv[])\n \n   new_argv = XOBFINISH (&argv_obstack, const char **);\n   argv_ptr = &new_argv[new_head_argc];\n-  fork_execute (CONST_CAST (char **, new_argv));\n+  fork_execute (new_argv[0], CONST_CAST (char **, new_argv), true);\n \n   if (lto_mode == LTO_MODE_LTO)\n     {\n@@ -792,7 +792,8 @@ run_gcc (unsigned argc, char *argv[])\n \t    }\n \t  else\n \t    {\n-\t      fork_execute (CONST_CAST (char **, new_argv));\n+\t      fork_execute (new_argv[0], CONST_CAST (char **, new_argv),\n+\t\t\t    true);\n \t      maybe_unlink (input_name);\n \t    }\n \n@@ -828,8 +829,9 @@ run_gcc (unsigned argc, char *argv[])\n \t    }\n \t  new_argv[i++] = \"all\";\n \t  new_argv[i++] = NULL;\n-\t  pex = collect_execute (CONST_CAST (char **, new_argv));\n-\t  collect_wait (new_argv[0], pex);\n+\t  pex = collect_execute (new_argv[0], CONST_CAST (char **, new_argv),\n+\t\t\t\t NULL, NULL, PEX_SEARCH, false);\n+\t  do_wait (new_argv[0], pex);\n \t  maybe_unlink (makefile);\n \t  makefile = NULL;\n \t  for (i = 0; i < nr; ++i)"}, {"sha": "89777ff7781854ebde888a68e1dba27e76b4e534", "filename": "gcc/tlink.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=5f0ad6a5613a3b436dfd91ce7c3b969aeeaa55eb", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"demangle.h\"\n #include \"collect2.h\"\n+#include \"collect-utils.h\"\n #include \"filenames.h\"\n #include \"diagnostic-core.h\"\n #include \"vec.h\"\n@@ -104,8 +105,6 @@ static void symbol_push (symbol *);\n static symbol * symbol_pop (void);\n static void file_push (file *);\n static file * file_pop (void);\n-static void tlink_init (void);\n-static int tlink_execute (const char *, char **, const char *, const char *);\n static char * frob_extension (const char *, const char *);\n static char * obstack_fgets (FILE *, struct obstack *);\n static char * tfgets (FILE *);\n@@ -286,11 +285,12 @@ tlink_init (void)\n \n static int\n tlink_execute (const char *prog, char **argv, const char *outname,\n-\t       const char *errname)\n+\t       const char *errname, bool use_atfile)\n {\n   struct pex_obj *pex;\n \n-  pex = collect_execute (prog, argv, outname, errname, PEX_LAST | PEX_SEARCH);\n+  pex = collect_execute (prog, argv, outname, errname,\n+\t\t\t PEX_LAST | PEX_SEARCH, use_atfile);\n   return collect_wait (prog, pex);\n }\n \n@@ -545,7 +545,7 @@ recompile_files (void)\n \tfprintf (stderr, _(\"collect: recompiling %s\\n\"), f->main);\n \n       if (chdir (f->dir) != 0\n-\t  || tlink_execute (c_file_name, argv, NULL, NULL) != 0\n+\t  || tlink_execute (c_file_name, argv, NULL, NULL, false) != 0\n \t  || chdir (initial_cwd) != 0)\n \treturn 0;\n \n@@ -817,7 +817,8 @@ scan_linker_output (const char *fname)\n void\n do_tlink (char **ld_argv, char **object_lst ATTRIBUTE_UNUSED)\n {\n-  int ret = tlink_execute (\"ld\", ld_argv, ldout, lderrout);\n+  int ret = tlink_execute (\"ld\", ld_argv, ldout, lderrout,\n+\t\t\t   HAVE_GNU_LD && at_file_supplied);\n \n   tlink_init ();\n \n@@ -843,7 +844,8 @@ do_tlink (char **ld_argv, char **object_lst ATTRIBUTE_UNUSED)\n \t      break;\n \t    if (tlink_verbose)\n \t      fprintf (stderr, _(\"collect: relinking\\n\"));\n-\t    ret = tlink_execute (\"ld\", ld_argv, ldout, lderrout);\n+\t    ret = tlink_execute (\"ld\", ld_argv, ldout, lderrout,\n+\t\t\t\t HAVE_GNU_LD && at_file_supplied);\n \t  }\n     }\n "}]}