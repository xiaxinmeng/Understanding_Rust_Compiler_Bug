{"sha": "827f44ebeb6eaefcbafd88e02eba9065756ba3db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI3ZjQ0ZWJlYjZlYWVmY2JhZmQ4OGUwMmViYTkwNjU3NTZiYTNkYg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-04-18T18:52:47Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-04-18T18:52:47Z"}, "message": "mmx.md (*vec_extractv2sf_0): Use gen_lowpart.\n\n\t* config/i386/mmx.md (*vec_extractv2sf_0): Use gen_lowpart.\n\t(*vec_extractv2si_0): Ditto.\n\t* config/i386/sse.md (*vec_extractv4sf_0): Ditto.\n\t(zero_extended_scalar_load_operand splitters): Ditto.\n\t(vec_extract splitters): Ditto.\n\t(*vec_extractv4si_0_zext): Ditto.\n\t(avx_<castmode><avxsizesuffix>_<castmode>): Use gen_lowpart\n\tand lowpart_subreg.\n\t(avx512f_<castmode><avxsizesuffix>_<castmode>): Ditto.\n\t(avx512f_<castmode><avxsizesuffix>_256<castmode>): Ditto.\n\t(*sse4_1_extractps): Use lowpart_subreg.\n\nFrom-SVN: r235164", "tree": {"sha": "47c2763d4b43527252d90008a4ed4ade6a39d63f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47c2763d4b43527252d90008a4ed4ade6a39d63f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/827f44ebeb6eaefcbafd88e02eba9065756ba3db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827f44ebeb6eaefcbafd88e02eba9065756ba3db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/827f44ebeb6eaefcbafd88e02eba9065756ba3db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827f44ebeb6eaefcbafd88e02eba9065756ba3db/comments", "author": null, "committer": null, "parents": [{"sha": "a8430f1914da98400c9b858419623527d3da159f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8430f1914da98400c9b858419623527d3da159f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8430f1914da98400c9b858419623527d3da159f"}], "stats": {"total": 195, "additions": 64, "deletions": 131}, "files": [{"sha": "69848874fd1bb20531de6229763f5d675c907115", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827f44ebeb6eaefcbafd88e02eba9065756ba3db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827f44ebeb6eaefcbafd88e02eba9065756ba3db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=827f44ebeb6eaefcbafd88e02eba9065756ba3db", "patch": "@@ -1,9 +1,22 @@\n+2016-04-18  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/mmx.md (*vec_extractv2sf_0): Use gen_lowpart.\n+\t(*vec_extractv2si_0): Ditto.\n+\t* config/i386/sse.md (*vec_extractv4sf_0): Ditto.\n+\t(zero_extended_scalar_load_operand splitters): Ditto.\n+\t(vec_extract splitters): Ditto.\n+\t(*vec_extractv4si_0_zext): Ditto.\n+\t(avx_<castmode><avxsizesuffix>_<castmode>): Use gen_lowpart\n+\tand lowpart_subreg.\n+\t(avx512f_<castmode><avxsizesuffix>_<castmode>): Ditto.\n+\t(avx512f_<castmode><avxsizesuffix>_256<castmode>): Ditto.\n+\t(*sse4_1_extractps): Use lowpart_subreg.\n+\n 2016-04-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* doc/install.texi (Specific, i?86-*-solaris2.10): Update gas and\n \tgld requirements.\n-\t(Specific, *-*-solaris2*): Update Solaris 11 bundled gcc\n-\tversions.\n+\t(Specific, *-*-solaris2*): Update Solaris 11 bundled gcc versions.\n \tMention Solaris 11 packaging changes.\n \tUpdate gas and gld requirements.\n \tRemove reference to pre-Solaris 10 bug.\n@@ -222,17 +235,15 @@\n \t(ipa_simd_modify_function_body, simd_clone_linear_addend)\n \t(simd_clone_adjust, expand_simd_clones, ipa_omp_simd_clone)\n \t(pass_data_omp_simd_clone, class pass_omp_simd_clone)\n-\t(pass_omp_simd_clone::gate, make_pass_omp_simd_clone): Move\n-\tinto...\n+\t(pass_omp_simd_clone::gate, make_pass_omp_simd_clone): Move into...\n \t* omp-simd-clone.c: ... this new file.\n \t(simd_clone_vector_of_formal_parm_types): Make it static.\n \t* Makefile.in (OBJS): Add omp-simd-clone.o.\n \n 2016-04-15  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \tPR target/70662\n-\t* config/i386/sse.md: Use proper memory operand\n-\tmodifiers.\n+\t* config/i386/sse.md: Use proper memory operand modifiers.\n \n \n 2016-04-15  Richard Biener  <rguenther@suse.de>"}, {"sha": "9a239c2facf717de881c8e595c117b3a71dd2480", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827f44ebeb6eaefcbafd88e02eba9065756ba3db/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827f44ebeb6eaefcbafd88e02eba9065756ba3db/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=827f44ebeb6eaefcbafd88e02eba9065756ba3db", "patch": "@@ -590,12 +590,7 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-{\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (SFmode, REGNO (operands[1]));\n-  else\n-    operands[1] = adjust_address (operands[1], SFmode, 0);\n-})\n+  \"operands[1] = gen_lowpart (SFmode, operands[1]);\")\n \n ;; Avoid combining registers from different units in a single alternative,\n ;; see comment above inline_secondary_memory_needed function in i386.c\n@@ -1283,12 +1278,7 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-{\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (SImode, REGNO (operands[1]));\n-  else\n-    operands[1] = adjust_address (operands[1], SImode, 0);\n-})\n+  \"operands[1] = gen_lowpart (SImode, operands[1]);\")\n \n ;; Avoid combining registers from different units in a single alternative,\n ;; see comment above inline_secondary_memory_needed function in i386.c"}, {"sha": "f46e732a4868255a559c669ad707947ce09f65a8", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 45, "deletions": 113, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827f44ebeb6eaefcbafd88e02eba9065756ba3db/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827f44ebeb6eaefcbafd88e02eba9065756ba3db/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=827f44ebeb6eaefcbafd88e02eba9065756ba3db", "patch": "@@ -1131,7 +1131,7 @@\n \t  (match_dup 2)\n \t  (const_int 1)))]\n {\n-  operands[1] = simplify_gen_subreg (SFmode, operands[1], V4SFmode, 0);\n+  operands[1] = gen_lowpart (SFmode, operands[1]);\n   operands[2] = CONST0_RTX (V4SFmode);\n })\n \n@@ -1141,7 +1141,7 @@\n   \"TARGET_SSE2 && reload_completed\"\n   [(set (match_dup 0) (vec_concat:V2DF (match_dup 1) (match_dup 2)))]\n {\n-  operands[1] = simplify_gen_subreg (DFmode, operands[1], V2DFmode, 0);\n+  operands[1] = gen_lowpart (DFmode, operands[1]);\n   operands[2] = CONST0_RTX (DFmode);\n })\n \n@@ -5993,7 +5993,8 @@\n       else\n \t{\n \t  tmp[5] = gen_reg_rtx (V8SFmode);\n-\t  ix86_expand_vec_extract_even_odd (tmp[5], gen_lowpart (V8SFmode, tmp[2]),\n+\t  ix86_expand_vec_extract_even_odd (tmp[5],\n+\t\t\t\t\t    gen_lowpart (V8SFmode, tmp[2]),\n \t\t\t\t\t    gen_lowpart (V8SFmode, tmp[3]), 0);\n \t  tmp[5] = gen_lowpart (V8SImode, tmp[5]);\n \t}\n@@ -6968,12 +6969,7 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-{\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (SFmode, REGNO (operands[1]));\n-  else\n-    operands[1] = adjust_address (operands[1], SFmode, 0);\n-})\n+  \"operands[1] = gen_lowpart (SFmode, operands[1]);\")\n \n (define_insn_and_split \"*sse4_1_extractps\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rm,rm,x,x\")\n@@ -6989,7 +6985,7 @@\n   \"&& reload_completed && SSE_REG_P (operands[0])\"\n   [(const_int 0)]\n {\n-  rtx dest = gen_rtx_REG (V4SFmode, REGNO (operands[0]));\n+  rtx dest = lowpart_subreg (V4SFmode, operands[0], SFmode);\n   switch (INTVAL (operands[2]))\n     {\n     case 1:\n@@ -7200,18 +7196,11 @@\n \t  (parallel [(const_int 0) (const_int 1)\n             (const_int 2) (const_int 3)])))]\n   \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-  && reload_completed\n-  && (TARGET_AVX512VL || (REG_P (operands[0]) && !EXT_REX_SSE_REG_P (operands[1])))\"\n-  [(const_int 0)]\n-{\n-  rtx op1 = operands[1];\n-  if (REG_P (op1))\n-    op1 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op1));\n-  else\n-    op1 = gen_lowpart (<ssehalfvecmode>mode, op1);\n-  emit_move_insn (operands[0], op1);\n-  DONE;\n-})\n+   && reload_completed\n+   && (TARGET_AVX512VL\n+       || (REG_P (operands[0]) && !EXT_REX_SSE_REG_P (operands[1])))\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[1] = gen_lowpart (<ssehalfvecmode>mode, operands[1]);\")\n \n (define_insn \"vec_extract_lo_<mode>_maskm\"\n   [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n@@ -7403,16 +7392,8 @@\n \t    (const_int 6) (const_int 7)])))]\n   \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && reload_completed\"\n-   [(const_int 0)]\n- {\n-  rtx op1 = operands[1];\n-  if (REG_P (op1))\n-    op1 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op1));\n-  else\n-    op1 = gen_lowpart (<ssehalfvecmode>mode, op1);\n-  emit_move_insn (operands[0], op1);\n-  DONE;\n-})\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[1] = gen_lowpart (<ssehalfvecmode>mode, operands[1]);\")\n \n (define_insn \"vec_extract_lo_<mode><mask_name>\"\n   [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=v,m\")\n@@ -7441,17 +7422,9 @@\n \t  (match_operand:VI8F_256 1 \"nonimmediate_operand\")\n \t  (parallel [(const_int 0) (const_int 1)])))]\n   \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-  && reload_completed\"\n-   [(const_int 0)]\n-{\n-  rtx op1 = operands[1];\n-  if (REG_P (op1))\n-    op1 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op1));\n-  else\n-    op1 = gen_lowpart (<ssehalfvecmode>mode, op1);\n-  emit_move_insn (operands[0], op1);\n-  DONE;\n-})\n+   && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[1] = gen_lowpart (<ssehalfvecmode>mode, operands[1]);\")\n \n (define_insn \"vec_extract_hi_<mode><mask_name>\"\n   [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=v,<store_mask_constraint>\")\n@@ -7483,18 +7456,10 @@\n \t  (match_operand:VI4F_256 1 \"nonimmediate_operand\")\n \t  (parallel [(const_int 0) (const_int 1)\n \t\t     (const_int 2) (const_int 3)])))]\n-  \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1])) && reload_completed\"\n-   [(const_int 0)]\n-{\n-  rtx op1 = operands[1];\n-  if (REG_P (op1))\n-    op1 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op1));\n-  else\n-    op1 = gen_lowpart (<ssehalfvecmode>mode, op1);\n-  emit_move_insn (operands[0], op1);\n-  DONE;\n-})\n-\n+  \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[1] = gen_lowpart (<ssehalfvecmode>mode, operands[1]);\")\n \n (define_insn \"vec_extract_lo_<mode><mask_name>\"\n   [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>\")\n@@ -7598,12 +7563,7 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-{\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (V16HImode, REGNO (operands[1]));\n-  else\n-    operands[1] = adjust_address (operands[1], V16HImode, 0);\n-})\n+  \"operands[1] = gen_lowpart (V16HImode, operands[1]);\")\n \n (define_insn \"vec_extract_hi_v32hi\"\n   [(set (match_operand:V16HI 0 \"nonimmediate_operand\" \"=v,m\")\n@@ -7638,12 +7598,7 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-{\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (V8HImode, REGNO (operands[1]));\n-  else\n-    operands[1] = adjust_address (operands[1], V8HImode, 0);\n-})\n+  \"operands[1] = gen_lowpart (V8HImode, operands[1]);\")\n \n (define_insn \"vec_extract_hi_v16hi\"\n   [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"=x,m\")\n@@ -7686,12 +7641,7 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-{\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (V32QImode, REGNO (operands[1]));\n-  else\n-    operands[1] = adjust_address (operands[1], V32QImode, 0);\n-})\n+  \"operands[1] = gen_lowpart (V32QImode, operands[1]);\")\n \n (define_insn \"vec_extract_hi_v64qi\"\n   [(set (match_operand:V32QI 0 \"nonimmediate_operand\" \"=v,m\")\n@@ -7738,12 +7688,7 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-{\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (V16QImode, REGNO (operands[1]));\n-  else\n-    operands[1] = adjust_address (operands[1], V16QImode, 0);\n-})\n+  \"operands[1] = gen_lowpart (V16QImode, operands[1]);\")\n \n (define_insn \"vec_extract_hi_v32qi\"\n   [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"=x,m\")\n@@ -8076,7 +8021,8 @@\n   \"TARGET_SSE3 && reload_completed\"\n   [(const_int 0)]\n {\n-  rtx low = gen_rtx_REG (DFmode, REGNO (operands[1]));\n+  rtx low = gen_lowpart (DFmode, operands[1]);\n+\n   emit_move_insn (adjust_address (operands[0], DFmode, 0), low);\n   emit_move_insn (adjust_address (operands[0], DFmode, 8), low);\n   DONE;\n@@ -8758,12 +8704,7 @@\n \t  (parallel [(const_int 0)])))]\n   \"TARGET_SSE2 && reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-{\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (DFmode, REGNO (operands[1]));\n-  else\n-    operands[1] = adjust_address (operands[1], DFmode, 0);\n-})\n+  \"operands[1] = gen_lowpart (DFmode, operands[1]);\")\n \n (define_insn \"*vec_extractv2df_0_sse\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,x,x\")\n@@ -13361,7 +13302,7 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (zero_extend:DI (match_dup 1)))]\n-  \"operands[1] = gen_rtx_REG (SImode, REGNO (operands[1]));\")\n+  \"operands[1] = gen_lowpart (SImode, operands[1]);\")\n \n (define_insn \"*vec_extractv2di_0_sse\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"     \"=x,m\")\n@@ -13379,7 +13320,7 @@\n \t  (parallel [(const_int 0)])))]\n   \"TARGET_SSE && reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n-  \"operands[1] = gen_rtx_REG (<MODE>mode, REGNO (operands[1]));\")\n+  \"operands[1] = gen_lowpart (<MODE>mode, operands[1]);\")\n \n (define_insn \"*vec_extractv4si\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,Yr,*x,x\")\n@@ -17466,7 +17407,7 @@\n \t(vec_duplicate:<ssehalfvecmode> (match_dup 1)))\n    (set (match_dup 0)\n \t(vec_concat:AVX_VEC_DUP_MODE (match_dup 2) (match_dup 2)))]\n-  \"operands[2] = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (operands[0]));\")\n+  \"operands[2] = gen_lowpart (<ssehalfvecmode>mode, operands[0]);\")\n \n (define_insn \"avx_vbroadcastf128_<mode>\"\n   [(set (match_operand:V_256 0 \"register_operand\" \"=x,x,x\")\n@@ -18407,16 +18348,13 @@\n   \"TARGET_AVX\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(const_int 0)]\n+  [(set (match_dup 0) (match_dup 1))]\n {\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-  if (REG_P (op0))\n-    op0 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op0));\n+  if (REG_P (operands[0]))\n+    operands[0] = gen_lowpart (<ssehalfvecmode>mode, operands[0]);\n   else\n-    op1 = gen_rtx_REG (<MODE>mode, REGNO (op1));\n-  emit_move_insn (op0, op1);\n-  DONE;\n+    operands[1] = lowpart_subreg (<MODE>mode, operands[1],\n+\t\t\t\t  <ssehalfvecmode>mode);\n })\n \n (define_expand \"vec_init<mode>\"\n@@ -19286,16 +19224,13 @@\n   \"TARGET_AVX512F\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(const_int 0)]\n+  [(set (match_dup 0) (match_dup 1))]\n {\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-  if (REG_P (op0))\n-    op0 = gen_rtx_REG (<ssequartermode>mode, REGNO (op0));\n+  if (REG_P (operands[0]))\n+    operands[0] = gen_lowpart (<ssequartermode>mode, operands[0]);\n   else\n-    op1 = gen_rtx_REG (<MODE>mode, REGNO (op1));\n-  emit_move_insn (op0, op1);\n-  DONE;\n+    operands[1] = lowpart_subreg (<MODE>mode, operands[1],\n+\t\t\t\t  <ssequartermode>mode);\n })\n \n (define_insn_and_split \"avx512f_<castmode><avxsizesuffix>_256<castmode>\"\n@@ -19306,16 +19241,13 @@\n   \"TARGET_AVX512F\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(const_int 0)]\n+  [(set (match_dup 0) (match_dup 1))]\n {\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-  if (REG_P (op0))\n-    op0 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op0));\n+  if (REG_P (operands[0]))\n+    operands[0] = gen_lowpart (<ssehalfvecmode>mode, operands[0]);\n   else\n-    op1 = gen_rtx_REG (<MODE>mode, REGNO (op1));\n-  emit_move_insn (op0, op1);\n-  DONE;\n+    operands[1] = lowpart_subreg (<MODE>mode, operands[1],\n+\t\t\t\t  <ssehalfvecmode>mode);\n })\n \n (define_int_iterator VPMADD52"}]}