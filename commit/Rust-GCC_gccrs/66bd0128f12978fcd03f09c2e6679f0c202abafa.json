{"sha": "66bd0128f12978fcd03f09c2e6679f0c202abafa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZiZDAxMjhmMTI5NzhmY2QwM2YwOWMyZTY2NzlmMGMyMDJhYmFmYQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-03-16T11:19:03Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-03-16T11:19:03Z"}, "message": "Instructions and patches for building GNAT with EGCS.\n\n\t* README.gnat: New file.\n\nFrom-SVN: r18619", "tree": {"sha": "3f70cbe41a51ca592f306e14eb1bb5798304fa99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f70cbe41a51ca592f306e14eb1bb5798304fa99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66bd0128f12978fcd03f09c2e6679f0c202abafa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66bd0128f12978fcd03f09c2e6679f0c202abafa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66bd0128f12978fcd03f09c2e6679f0c202abafa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66bd0128f12978fcd03f09c2e6679f0c202abafa/comments", "author": null, "committer": null, "parents": [{"sha": "544c188d00e2d25b484394bea9a6d28ab271d9a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544c188d00e2d25b484394bea9a6d28ab271d9a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544c188d00e2d25b484394bea9a6d28ab271d9a0"}], "stats": {"total": 197, "additions": 197, "deletions": 0}, "files": [{"sha": "532625af90c5744f2a6fd602e35a39be3e595b78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66bd0128f12978fcd03f09c2e6679f0c202abafa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66bd0128f12978fcd03f09c2e6679f0c202abafa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66bd0128f12978fcd03f09c2e6679f0c202abafa", "patch": "@@ -1,3 +1,7 @@\n+Mon Mar 16 11:16:50 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* README.gnat: New file.\n+\n Mon Mar 16 11:14:20 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n \n \t* config/m68k/m68k.c: Include <stdlib.h> for atoi.  Include"}, {"sha": "de25809a54fa71808263f25a59f671c45998b762", "filename": "gcc/README.gnat", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66bd0128f12978fcd03f09c2e6679f0c202abafa/gcc%2FREADME.gnat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66bd0128f12978fcd03f09c2e6679f0c202abafa/gcc%2FREADME.gnat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.gnat?ref=66bd0128f12978fcd03f09c2e6679f0c202abafa", "patch": "@@ -0,0 +1,193 @@\n+The following patches are needed in order to build GNAT with EGCS.\n+\n+These patches were tested with egcs-980308 and gnat-3.10p on a mips-sgi-irix6.3\n+system.  The gnat build succeeded as per the instructions in the gnat\n+README.BUILD file for building one library, except that CFLAGS=\"-O -g\" and\n+GNATLIBCFLAGS=\"-O -g\" were substituted for the recommended \"-O2\" so that the\n+build could be debugged.  There was no attempt to run the resulting build\n+against any testsuite or validation suite.\n+\n+--\n+\n+Developers Notes:\n+\n+Every use of sizetype in the Ada front end should be checked to see if perhaps\n+it should be using bitsizetype instead.  The change to maybe_pad_type is just\n+a hack to work around this problem, and may not be desirable in the long term.\n+\n+There are many places in the Ada front end where it calls operand_equal_p to\n+see if two type sizes are the same.  operand_equal_p fails if the two\n+arguments have different TYPE_MODEs.  sizetype and bitsizetype can have\n+different TYPE_MODEs.  Thus this code can fail if one type size is based\n+on sizetype, and the other is based on bitsizetype.  The change to\n+maybe_pad_type fixes one very critical place where this happens.  There may\n+be others.\n+\n+--\n+\n+Mon Mar 16 11:00:25 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* a-gtran3.c (maybe_pad_type): Convert both size and orig_size to\n+\tsizetype if they have differing modes.\n+\t* a-misc.c (gnat_tree_code_type): Change from string to char array.\n+\t(init_lex): Delete realloc calls for tree_code_* globals.  Adjust\n+\tbcopy call for gnat_tree_code_type change.\n+\t* a-tree.def: Adjust for tree_code_* type changes.\n+\n+diff -pr gnat-3.10p-src/src/ada/a-gtran3.c egcs-980308/gcc/ada/a-gtran3.c\n+*** gnat-3.10p-src/src/ada/a-gtran3.c\tWed Aug 13 21:02:17 1997\n+--- egcs-980308/gcc/ada/a-gtran3.c\tSat Mar 14 18:33:51 1998\n+*************** maybe_pad_type (type, size, align, gnat_\n+*** 3330,3335 ****\n+--- 3330,3342 ----\n+       changed.  Then return if we aren't doing anything.  */\n+  \n+    if (size != 0\n++       && TYPE_MODE (TREE_TYPE (size)) != TYPE_MODE (TREE_TYPE (orig_size)))\n++     {\n++       size = convert (sizetype, size);\n++       orig_size = convert (sizetype, orig_size);\n++     }\n++ \n++   if (size != 0\n+        && (operand_equal_p (size, orig_size, 0)\n+  \t  || (TREE_CODE (orig_size) == INTEGER_CST\n+  \t      && tree_int_cst_lt (size, orig_size)))\n+diff -pr gnat-3.10p-src/src/ada/a-misc.c egcs-980308/gcc/ada/a-misc.c\n+*** gnat-3.10p-src/src/ada/a-misc.c\tWed Aug 13 21:02:18 1997\n+--- egcs-980308/gcc/ada/a-misc.c\tTue Mar 10 18:39:13 1998\n+*************** extern char *main_input_filename;\n+*** 70,77 ****\n+  \n+  #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n+  \n+! char *gnat_tree_code_type[] = {\n+!   \"x\",\n+  #include \"a-tree.def\"\n+  };\n+  #undef DEFTREECODE\n+--- 70,77 ----\n+  \n+  #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n+  \n+! char gnat_tree_code_type[] = {\n+!   'x',\n+  #include \"a-tree.def\"\n+  };\n+  #undef DEFTREECODE\n+*************** init_lex ()\n+*** 607,626 ****\n+  {\n+    lang_expand_expr = gnat_expand_expr;\n+  \n+-   tree_code_type\n+-     = (char **) realloc (tree_code_type,\n+- \t\t\t sizeof (char *) * LAST_GNAT_TREE_CODE);\n+-   tree_code_length\n+-     = (int *) realloc (tree_code_length,\n+- \t\t       sizeof (int) * LAST_GNAT_TREE_CODE);\n+-   tree_code_name\n+-     = (char **) realloc (tree_code_name,\n+- \t\t\t sizeof (char *) * LAST_GNAT_TREE_CODE);\n+- \n+    bcopy ((char *) gnat_tree_code_type,\n+  \t (char *) (tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE),\n+! \t ((LAST_GNAT_TREE_CODE - (int) LAST_AND_UNUSED_TREE_CODE)\n+! \t  * sizeof (char *)));\n+  \n+    bcopy ((char *)gnat_tree_code_length,\n+  \t (char *) (tree_code_length + (int) LAST_AND_UNUSED_TREE_CODE),\n+--- 607,615 ----\n+  {\n+    lang_expand_expr = gnat_expand_expr;\n+  \n+    bcopy ((char *) gnat_tree_code_type,\n+  \t (char *) (tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE),\n+! \t LAST_GNAT_TREE_CODE - (int) LAST_AND_UNUSED_TREE_CODE);\n+  \n+    bcopy ((char *)gnat_tree_code_length,\n+  \t (char *) (tree_code_length + (int) LAST_AND_UNUSED_TREE_CODE),\n+diff -pr gnat-3.10p-src/src/ada/a-tree.def egcs-980308/gcc/ada/a-tree.def\n+*** gnat-3.10p-src/src/ada/a-tree.def\tWed Aug 13 21:02:20 1997\n+--- egcs-980308/gcc/ada/a-tree.def\tTue Mar 10 18:39:54 1998\n+***************\n+*** 31,69 ****\n+     The only field used if TREE_COMPLEXITY, which contains the GNAT node\n+     number.  */\n+  \n+! DEFTREECODE (TRANSFORM_EXPR, \"transform_expr\", \"e\", 0)\n+  \n+  /* Perform an unchecked conversion between the input and the output. \n+     if TREE_ADDRESSABLE is set, it means this is in an LHS; in that case,\n+     we can only use techniques, such as pointer punning, that leave the\n+     expression a \"name\".  */\n+  \n+! DEFTREECODE (UNCHECKED_CONVERT_EXPR, \"unchecked_convert_expr\", \"1\", 1)\n+  \n+  /* A type that is an unconstrained array itself.  This node is never passed\n+     to GCC. TREE_TYPE is the type of the fat pointer and TYPE_OBJECT_RECORD_TYPE\n+     is the type of a record containing the template and data.  */\n+  \n+! DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", \"t\", 0)\n+  \n+  /* A reference to an unconstrained array.  This node only exists as an\n+     intermediate node during the translation of a GNAT tree to a GCC tree;\n+     it is never passed to GCC.  The only field used is operand 0, which\n+     is the fat pointer object.  */\n+  \n+! DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\", \"r\", 1)\n+  \n+  /* An expression that returns an RTL suitable for its type.  Operand 0\n+     is an expression to be evaluated for side effects only.  */\n+  \n+! DEFTREECODE (NULL_EXPR, \"null_expr\", \"e\", 1)\n+  \n+  /* An expression that emits a USE for its single operand.  */\n+  \n+! DEFTREECODE (USE_EXPR, \"use_expr\", \"e\", 1)\n+  \n+  /* An expression that is treated as a conversion while generating code, but is\n+     used to prevent infinite recursion when conversions of biased types are\n+     involved.  */\n+  \n+! DEFTREECODE (GNAT_NOP_EXPR, \"gnat_nop_expr\", \"1\", 1)\n+--- 31,69 ----\n+     The only field used if TREE_COMPLEXITY, which contains the GNAT node\n+     number.  */\n+  \n+! DEFTREECODE (TRANSFORM_EXPR, \"transform_expr\", 'e', 0)\n+  \n+  /* Perform an unchecked conversion between the input and the output. \n+     if TREE_ADDRESSABLE is set, it means this is in an LHS; in that case,\n+     we can only use techniques, such as pointer punning, that leave the\n+     expression a \"name\".  */\n+  \n+! DEFTREECODE (UNCHECKED_CONVERT_EXPR, \"unchecked_convert_expr\", '1', 1)\n+  \n+  /* A type that is an unconstrained array itself.  This node is never passed\n+     to GCC. TREE_TYPE is the type of the fat pointer and TYPE_OBJECT_RECORD_TYPE\n+     is the type of a record containing the template and data.  */\n+  \n+! DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", 't', 0)\n+  \n+  /* A reference to an unconstrained array.  This node only exists as an\n+     intermediate node during the translation of a GNAT tree to a GCC tree;\n+     it is never passed to GCC.  The only field used is operand 0, which\n+     is the fat pointer object.  */\n+  \n+! DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\", 'r', 1)\n+  \n+  /* An expression that returns an RTL suitable for its type.  Operand 0\n+     is an expression to be evaluated for side effects only.  */\n+  \n+! DEFTREECODE (NULL_EXPR, \"null_expr\", 'e', 1)\n+  \n+  /* An expression that emits a USE for its single operand.  */\n+  \n+! DEFTREECODE (USE_EXPR, \"use_expr\", 'e', 1)\n+  \n+  /* An expression that is treated as a conversion while generating code, but is\n+     used to prevent infinite recursion when conversions of biased types are\n+     involved.  */\n+  \n+! DEFTREECODE (GNAT_NOP_EXPR, \"gnat_nop_expr\", '1', 1)"}]}