{"sha": "0580d8070754fa3ce59081f3906d9a4f2201757c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU4MGQ4MDcwNzU0ZmEzY2U1OTA4MWYzOTA2ZDlhNGYyMjAxNzU3Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T15:47:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T15:47:39Z"}, "message": "[multiple changes]\n\n2011-08-02  Robert Dewar  <dewar@adacore.com>\n\n\t* a-direct.adb, sinfo.ads, exp_ch9.adb, scng.adb, sem_util.adb,\n\tsem_util.ads, restrict.ads, par-prag.adb: Minor reformatting and/or\n\tcode reorganization.\n\n2011-08-02  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: Debug flag d.P to suppress length comparison optimization\n\t* exp_ch4.adb (Optimize_Length_Comparison): New routine to optimize\n\tcomparison of Length by comparing First/Last instead.\n\n2011-08-02  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cobove.ads: Code clean up.\n\nFrom-SVN: r177190", "tree": {"sha": "1c61ba45242501b4c599f20f31fce9d6bb99de5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c61ba45242501b4c599f20f31fce9d6bb99de5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0580d8070754fa3ce59081f3906d9a4f2201757c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0580d8070754fa3ce59081f3906d9a4f2201757c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0580d8070754fa3ce59081f3906d9a4f2201757c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0580d8070754fa3ce59081f3906d9a4f2201757c/comments", "author": null, "committer": null, "parents": [{"sha": "b191a12525973bac726397a591bbd636dc465e07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b191a12525973bac726397a591bbd636dc465e07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b191a12525973bac726397a591bbd636dc465e07"}], "stats": {"total": 557, "additions": 504, "deletions": 53}, "files": [{"sha": "a911edaab6d479cce334cbbad3eae2ad5de21536", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -1,3 +1,19 @@\n+2011-08-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-direct.adb, sinfo.ads, exp_ch9.adb, scng.adb, sem_util.adb,\n+\tsem_util.ads, restrict.ads, par-prag.adb: Minor reformatting and/or\n+\tcode reorganization.\n+\n+2011-08-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Debug flag d.P to suppress length comparison optimization\n+\t* exp_ch4.adb (Optimize_Length_Comparison): New routine to optimize\n+\tcomparison of Length by comparing First/Last instead.\n+\n+2011-08-02  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-cobove.ads: Code clean up.\n+\n 2011-08-02  Vincent Celier  <celier@adacore.com>\n \n \t* adaint.c (file_names_case_sensitive_cache): New static int."}, {"sha": "9fc7945da86a391f353081cef97b105e9b732887", "filename": "gcc/ada/a-cobove.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fa-cobove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fa-cobove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.ads?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -322,7 +322,7 @@ private\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n    type Vector (Capacity : Count_Type) is tagged record\n-      Elements : Elements_Array (1 .. Capacity);\n+      Elements : Elements_Array (1 .. Capacity) := (others => <>);\n       Last     : Extended_Index := No_Index;\n       Busy     : Natural := 0;\n       Lock     : Natural := 0;"}, {"sha": "6bb499ee2e8ef50283d19c43cbe977a50254716f", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -39,23 +39,23 @@ with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n with Ada.Characters.Handling;    use Ada.Characters.Handling;\n \n-with System.CRTL;    use System.CRTL;\n-with System.OS_Constants;\n-with System.OS_Lib;  use System.OS_Lib;\n-with System.Regexp;  use System.Regexp;\n-with System.File_IO; use System.File_IO;\n-with System;\n+with System.CRTL;         use System.CRTL;\n+with System.OS_Constants; use System.OS_Constants;\n+with System.OS_Lib;       use System.OS_Lib;\n+with System.Regexp;       use System.Regexp;\n+with System.File_IO;      use System.File_IO;\n+with System;              use System;\n \n package body Ada.Directories is\n \n    Filename_Max : constant Integer := 1024;\n    --  1024 is the value of FILENAME_MAX in stdio.h\n \n-   type Dir_Type_Value is new System.Address;\n+   type Dir_Type_Value is new Address;\n    --  This is the low-level address directory structure as returned by the C\n    --  opendir routine.\n \n-   No_Dir : constant Dir_Type_Value := Dir_Type_Value (System.Null_Address);\n+   No_Dir : constant Dir_Type_Value := Dir_Type_Value (Null_Address);\n \n    Dir_Separator : constant Character;\n    pragma Import (C, Dir_Separator, \"__gnat_dir_separator\");\n@@ -384,7 +384,7 @@ package body Ada.Directories is\n             end;\n          end if;\n \n-         --  The implementation uses System.OS_Lib.Copy_File\n+         --  Do actual copy using System.OS_Lib.Copy_File\n \n          Copy_File (Source_Name, Target_Name, Success, Mode, Preserve);\n \n@@ -496,9 +496,7 @@ package body Ada.Directories is\n       Path_Len : Natural := Max_Path;\n       Buffer   : String (1 .. 1 + Max_Path + 1);\n \n-      procedure Local_Get_Current_Dir\n-        (Dir    : System.Address;\n-         Length : System.Address);\n+      procedure Local_Get_Current_Dir (Dir : Address; Length : Address);\n       pragma Import (C, Local_Get_Current_Dir, \"__gnat_get_current_dir\");\n \n    begin\n@@ -563,7 +561,7 @@ package body Ada.Directories is\n          raise Name_Error with \"file \"\"\" & Name & \"\"\" does not exist\";\n \n       else\n-         --  The implementation uses System.OS_Lib.Delete_File\n+         --  Do actual deletion using System.OS_Lib.Delete_File\n \n          Delete_File (Name, Success);\n \n@@ -602,7 +600,7 @@ package body Ada.Directories is\n                File_Name : constant String := Simple_Name (Dir_Ent);\n \n             begin\n-               if System.OS_Lib.Is_Directory (File_Name) then\n+               if OS_Lib.Is_Directory (File_Name) then\n                   if File_Name /= \".\" and then File_Name /= \"..\" then\n                      Delete_Tree (File_Name);\n                   end if;\n@@ -698,34 +696,32 @@ package body Ada.Directories is\n       Kind : File_Kind := Ordinary_File;\n       --  Initialized to avoid a compilation warning\n \n-      Filename_Addr : System.Address;\n+      Filename_Addr : Address;\n       Filename_Len  : aliased Integer;\n \n       Buffer : array (0 .. Filename_Max + 12) of Character;\n       --  12 is the size of the dirent structure (see dirent.h), without the\n       --  field for the filename.\n \n       function readdir_gnat\n-        (Directory : System.Address;\n-         Buffer    : System.Address;\n-         Last      : not null access Integer) return System.Address;\n+        (Directory : Address;\n+         Buffer    : Address;\n+         Last      : not null access Integer) return Address;\n       pragma Import (C, readdir_gnat, \"__gnat_readdir\");\n \n-      use System;\n-\n    begin\n       --  Search.Value.Is_Valid is always True when Fetch_Next_Entry is called\n \n       loop\n          Filename_Addr :=\n            readdir_gnat\n-             (System.Address (Search.Value.Dir),\n+             (Address (Search.Value.Dir),\n               Buffer'Address,\n               Filename_Len'Access);\n \n          --  If no matching entry is found, set Is_Valid to False\n \n-         if Filename_Addr = System.Null_Address then\n+         if Filename_Addr = Null_Address then\n             Search.Value.Is_Valid := False;\n             exit;\n          end if;\n@@ -801,7 +797,7 @@ package body Ada.Directories is\n    -----------------\n \n    function File_Exists (Name : String) return Boolean is\n-      function C_File_Exists (A : System.Address) return Integer;\n+      function C_File_Exists (A : Address) return Integer;\n       pragma Import (C, C_File_Exists, \"__gnat_file_exists\");\n \n       C_Name : String (1 .. Name'Length + 1);\n@@ -848,9 +844,11 @@ package body Ada.Directories is\n \n          declare\n             --  We need to resolve links because of A.16(47), since we must not\n-            --  return alternative names for files\n+            --  return alternative names for files.\n+\n             Value : constant String := Normalize_Pathname (Name);\n             subtype Result is String (1 .. Value'Length);\n+\n          begin\n             return Result (Value);\n          end;\n@@ -1056,18 +1054,19 @@ package body Ada.Directories is\n            & \"\"\" designates a file that already exists\";\n \n       else\n-         --  The implementation uses System.OS_Lib.Rename_File\n+         --  Do actual rename using System.OS_Lib.Rename_File\n \n          Rename_File (Old_Name, New_Name, Success);\n \n          if not Success then\n+\n             --  AI05-0231-1: Name_Error should be raised in case a directory\n             --  component of New_Name does not exist (as in New_Name =>\n             --  \"/no-such-dir/new-filename\"). ENOENT indicates that. ENOENT\n             --  also indicate that the Old_Name does not exist, but we already\n             --  checked for that above. All other errors are Use_Error.\n \n-            if Errno = System.OS_Constants.ENOENT then\n+            if Errno = ENOENT then\n                raise Name_Error with\n                  \"file \"\"\" & Containing_Directory (New_Name) & \"\"\" not found\";\n \n@@ -1154,9 +1153,10 @@ package body Ada.Directories is\n          Cut_End := Path'Last;\n \n          Check_For_Standard_Dirs : declare\n-            BN               : constant String := Path (Cut_Start .. Cut_End);\n+            BN : constant String := Path (Cut_Start .. Cut_End);\n+\n             Has_Drive_Letter : constant Boolean :=\n-                                 System.OS_Lib.Path_Separator /= ':';\n+                                 OS_Lib.Path_Separator /= ':';\n             --  If Path separator is not ':' then we are on a DOS based OS\n             --  where this character is used as a drive letter separator.\n \n@@ -1221,7 +1221,7 @@ package body Ada.Directories is\n    function Size (Name : String) return File_Size is\n       C_Name : String (1 .. Name'Length + 1);\n \n-      function C_Size (Name : System.Address) return Long_Integer;\n+      function C_Size (Name : Address) return Long_Integer;\n       pragma Import (C, C_Size, \"__gnat_named_file_length\");\n \n    begin"}, {"sha": "65af4de796da399649fb089c60171f2a0a92a633", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -133,7 +133,7 @@ package body Debug is\n    --  d.M\n    --  d.N\n    --  d.O  Dump internal SCO tables\n-   --  d.P\n+   --  d.P  Previous (non-optimized) handling of length comparisons\n    --  d.Q\n    --  d.R\n    --  d.S  Force Optimize_Alignment (Space)\n@@ -597,6 +597,11 @@ package body Debug is\n    --       the ALI file, the internal SCO tables (SCO_Table/SCO_Unit_Table)\n    --       are dumped for debugging purposes.\n \n+   --  d.P  Previous non-optimized handling of length comparisons. Setting this\n+   --       flag inhibits the effect of Optimize_Length_Comparison in Exp_Ch4.\n+   --       This is there in case we find a situation where the optimization\n+   --       malfunctions, to provide a work around.\n+\n    --  d.S  Force Optimize_Alignment (Space) mode as the default\n \n    --  d.T  Force Optimize_Alignment (Time) mode as the default"}, {"sha": "abaf676b14824819eaa1fff0bd0646aca7bce051", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 413, "deletions": 4, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -202,6 +202,12 @@ package body Exp_Ch4 is\n    --  constrained type (the caller has ensured this by using\n    --  Convert_To_Actual_Subtype if necessary).\n \n+   procedure Optimize_Length_Comparison (N : Node_Id);\n+   --  Given an expression, if it is of the form X'Length op N (or the other\n+   --  way round), where N is known at compile time to be 0 or 1, and X is a\n+   --  simple entity, and op is a comparison operator, optimizes it into a\n+   --  comparison of First and Last.\n+\n    procedure Rewrite_Comparison (N : Node_Id);\n    --  If N is the node for a comparison whose outcome can be determined at\n    --  compile time, then the node N can be rewritten with True or False. If\n@@ -3197,9 +3203,9 @@ package body Exp_Ch4 is\n          if Inside_A_Return_Statement (N)\n            and then\n              (Ekind (PtrT) = E_Anonymous_Access_Type\n-                or else\n-                  (Ekind (PtrT) = E_Access_Type\n-                     and then No (Associated_Final_Chain (PtrT))))\n+               or else\n+                 (Ekind (PtrT) = E_Access_Type\n+                   and then No (Associated_Final_Chain (PtrT))))\n          then\n             declare\n                Decl    : Node_Id;\n@@ -6055,6 +6061,8 @@ package body Exp_Ch4 is\n          Expand_Vax_Comparison (N);\n          return;\n       end if;\n+\n+      Optimize_Length_Comparison (N);\n    end Expand_N_Op_Eq;\n \n    -----------------------\n@@ -6415,6 +6423,8 @@ package body Exp_Ch4 is\n          Expand_Vax_Comparison (N);\n          return;\n       end if;\n+\n+      Optimize_Length_Comparison (N);\n    end Expand_N_Op_Ge;\n \n    --------------------\n@@ -6450,6 +6460,8 @@ package body Exp_Ch4 is\n          Expand_Vax_Comparison (N);\n          return;\n       end if;\n+\n+      Optimize_Length_Comparison (N);\n    end Expand_N_Op_Gt;\n \n    --------------------\n@@ -6485,6 +6497,8 @@ package body Exp_Ch4 is\n          Expand_Vax_Comparison (N);\n          return;\n       end if;\n+\n+      Optimize_Length_Comparison (N);\n    end Expand_N_Op_Le;\n \n    --------------------\n@@ -6520,6 +6534,8 @@ package body Exp_Ch4 is\n          Expand_Vax_Comparison (N);\n          return;\n       end if;\n+\n+      Optimize_Length_Comparison (N);\n    end Expand_N_Op_Lt;\n \n    -----------------------\n@@ -6935,6 +6951,8 @@ package body Exp_Ch4 is\n             Analyze_And_Resolve (N, Standard_Boolean);\n          end;\n       end if;\n+\n+      Optimize_Length_Comparison (N);\n    end Expand_N_Op_Ne;\n \n    ---------------------\n@@ -10157,6 +10175,397 @@ package body Exp_Ch4 is\n       return Func_Body;\n    end Make_Boolean_Array_Op;\n \n+   --------------------------------\n+   -- Optimize_Length_Comparison --\n+   --------------------------------\n+\n+   procedure Optimize_Length_Comparison (N : Node_Id) is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Typ    : constant Entity_Id  := Etype (N);\n+      Result : Node_Id;\n+\n+      Left  : Node_Id;\n+      Right : Node_Id;\n+      --  First and Last attribute reference nodes, which end up as left and\n+      --  right operands of the optimized result.\n+\n+      Is_Zero : Boolean;\n+      --  True for comparison operand of zero\n+\n+      Comp : Node_Id;\n+      --  Comparison operand, set only if Is_Zero is false\n+\n+      Ent : Entity_Id;\n+      --  Entity whose length is being compared\n+\n+      Index : Node_Id;\n+      --  Integer_Literal node for length attribute expression, or Empty\n+      --  if there is no such expression present.\n+\n+      Ityp  : Entity_Id;\n+      --  Type of array index to which 'Length is applied\n+\n+      Op : Node_Kind := Nkind (N);\n+      --  Kind of comparison operator, gets flipped if operands backwards\n+\n+      function Is_Optimizable (N : Node_Id) return Boolean;\n+      --  Tests N to see if it is an optimizable comparison value (defined\n+      --  as constant zero or one, or something else where the value is known\n+      --  to be in range of 32-bits, and where the corresponding Length value\n+      --  is also known to be 32-bits. If result is true, sets Is_Zero, Ityp,\n+      --  and Comp accordingly.\n+\n+      function Is_Entity_Length (N : Node_Id) return Boolean;\n+      --  Tests if N is a length attribute applied to a simple entity. If so,\n+      --  returns True, and sets Ent to the entity, and Index to the integer\n+      --  literal provided as an attribute expression, or to Empty if none.\n+      --  Also returns True if the expression is a generated type conversion\n+      --  whose expression is of the desired form. This latter case arises\n+      --  when Apply_Universal_Integer_Attribute_Check installs a conversion\n+      --  to check for being in range, which is not needed in this context.\n+      --  Returns False if neither condition holds.\n+\n+      function Prepare_64 (N : Node_Id) return Node_Id;\n+      --  Given a discrete expression, returns a Long_Long_Integer typed\n+      --  expression representing the underlying value of the expression.\n+      --  This is done with an unchecked conversion to the result type. We\n+      --  use unchecked conversion to handle the enumeration type case.\n+\n+      ----------------------\n+      -- Is_Entity_Length --\n+      ----------------------\n+\n+      function Is_Entity_Length (N : Node_Id) return Boolean is\n+      begin\n+         if Nkind (N) = N_Attribute_Reference\n+           and then Attribute_Name (N) = Name_Length\n+           and then Is_Entity_Name (Prefix (N))\n+         then\n+            Ent := Entity (Prefix (N));\n+\n+            if Present (Expressions (N)) then\n+               Index := First (Expressions (N));\n+            else\n+               Index := Empty;\n+            end if;\n+\n+            return True;\n+\n+         elsif Nkind (N) = N_Type_Conversion\n+           and then not Comes_From_Source (N)\n+         then\n+            return Is_Entity_Length (Expression (N));\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Entity_Length;\n+\n+      --------------------\n+      -- Is_Optimizable --\n+      --------------------\n+\n+      function Is_Optimizable (N : Node_Id) return Boolean is\n+         Val  : Uint;\n+         OK   : Boolean;\n+         Lo   : Uint;\n+         Hi   : Uint;\n+         Indx : Node_Id;\n+\n+      begin\n+         if Compile_Time_Known_Value (N) then\n+            Val := Expr_Value (N);\n+\n+            if Val = Uint_0 then\n+               Is_Zero := True;\n+               Comp    := Empty;\n+               return True;\n+\n+            elsif Val = Uint_1 then\n+               Is_Zero := False;\n+               Comp    := Empty;\n+               return True;\n+            end if;\n+         end if;\n+\n+         --  Here we have to make sure of being within 32-bits\n+\n+         Determine_Range (N, OK, Lo, Hi, Assume_Valid => True);\n+\n+         if not OK\n+           or else Lo < UI_From_Int (Int'First)\n+           or else Hi > UI_From_Int (Int'Last)\n+         then\n+            return False;\n+         end if;\n+\n+         --  Comparison value was within 32-bits, so now we must check the\n+         --  index value to make sure it is also within 32-bits.\n+\n+         Indx := First_Index (Etype (Ent));\n+\n+         if Present (Index) then\n+            for J in 2 .. UI_To_Int (Intval (Index)) loop\n+               Next_Index (Indx);\n+            end loop;\n+         end if;\n+\n+         Ityp := Etype (Indx);\n+\n+         if Esize (Ityp) > 32 then\n+            return False;\n+         end if;\n+\n+         Is_Zero := False;\n+         Comp := N;\n+         return True;\n+      end Is_Optimizable;\n+\n+      ----------------\n+      -- Prepare_64 --\n+      ----------------\n+\n+      function Prepare_64 (N : Node_Id) return Node_Id is\n+      begin\n+         return Unchecked_Convert_To (Standard_Long_Long_Integer, N);\n+      end Prepare_64;\n+\n+   --  Start of processing for Optimize_Length_Comparison\n+\n+   begin\n+      --  Nothing to do if not a comparison\n+\n+      if Op not in N_Op_Compare then\n+         return;\n+      end if;\n+\n+      --  Nothing to do if special -gnatd.P debug flag set\n+\n+      if Debug_Flag_Dot_PP then\n+         return;\n+      end if;\n+\n+      --  Ent'Length op 0/1\n+\n+      if Is_Entity_Length (Left_Opnd (N))\n+        and then Is_Optimizable (Right_Opnd (N))\n+      then\n+         null;\n+\n+      --  0/1 op Ent'Length\n+\n+      elsif Is_Entity_Length (Right_Opnd (N))\n+        and then Is_Optimizable (Left_Opnd (N))\n+      then\n+         --  Flip comparison to opposite sense\n+\n+         case Op is\n+            when N_Op_Lt => Op := N_Op_Gt;\n+            when N_Op_Le => Op := N_Op_Ge;\n+            when N_Op_Gt => Op := N_Op_Lt;\n+            when N_Op_Ge => Op := N_Op_Le;\n+            when others  => null;\n+         end case;\n+\n+      --  Else optimization not possible\n+\n+      else\n+         return;\n+      end if;\n+\n+      --  Fall through if we will do the optimization\n+\n+      --  Cases to handle:\n+\n+      --    X'Length = 0  => X'First > X'Last\n+      --    X'Length = 1  => X'First = X'Last\n+      --    X'Length = n  => X'First + (n - 1) = X'Last\n+\n+      --    X'Length /= 0 => X'First <= X'Last\n+      --    X'Length /= 1 => X'First /= X'Last\n+      --    X'Length /= n => X'First + (n - 1) /= X'Last\n+\n+      --    X'Length >= 0 => always true, warn\n+      --    X'Length >= 1 => X'First <= X'Last\n+      --    X'Length >= n => X'First + (n - 1) <= X'Last\n+\n+      --    X'Length > 0  => X'First <= X'Last\n+      --    X'Length > 1  => X'First < X'Last\n+      --    X'Length > n  => X'First + (n - 1) < X'Last\n+\n+      --    X'Length <= 0 => X'First > X'Last (warn, could be =)\n+      --    X'Length <= 1 => X'First >= X'Last\n+      --    X'Length <= n => X'First + (n - 1) >= X'Last\n+\n+      --    X'Length < 0  => always false (warn)\n+      --    X'Length < 1  => X'First > X'Last\n+      --    X'Length < n  => X'First + (n - 1) > X'Last\n+\n+      --  Note: for the cases of n (not constant 0,1), we require that the\n+      --  corresponding index type be integer or shorter (i.e. not 64-bit),\n+      --  and the same for the comparison value. Then we do the comparison\n+      --  using 64-bit arithmetic (actually long long integer), so that we\n+      --  cannot have overflow intefering with the result.\n+\n+      --  First deal with warning cases\n+\n+      if Is_Zero then\n+         case Op is\n+\n+            --  X'Length >= 0\n+\n+            when N_Op_Ge =>\n+               Rewrite (N,\n+                 Convert_To (Typ, New_Occurrence_Of (Standard_True, Loc)));\n+               Analyze_And_Resolve (N, Typ);\n+               Warn_On_Known_Condition (N);\n+               return;\n+\n+            --  X'Length < 0\n+\n+            when N_Op_Lt =>\n+               Rewrite (N,\n+                 Convert_To (Typ, New_Occurrence_Of (Standard_False, Loc)));\n+               Analyze_And_Resolve (N, Typ);\n+               Warn_On_Known_Condition (N);\n+               return;\n+\n+            when N_Op_Le =>\n+               if Constant_Condition_Warnings\n+                 and then Comes_From_Source (Original_Node (N))\n+               then\n+                  Error_Msg_N (\"could replace by \"\"'=\"\"?\", N);\n+               end if;\n+\n+               Op := N_Op_Eq;\n+\n+            when others =>\n+               null;\n+         end case;\n+      end if;\n+\n+      --  Build the First reference we will use\n+\n+      Left :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix         => New_Occurrence_Of (Ent, Loc),\n+          Attribute_Name => Name_First);\n+\n+      if Present (Index) then\n+         Set_Expressions (Left, New_List (New_Copy (Index)));\n+      end if;\n+\n+      --  If general value case, then do the addition of (n - 1), and\n+      --  also add the needed conversions to type Long_Long_Integer.\n+\n+      if Present (Comp) then\n+         Left :=\n+           Make_Op_Add (Loc,\n+             Left_Opnd  => Prepare_64 (Left),\n+             Right_Opnd =>\n+               Make_Op_Subtract (Loc,\n+                 Left_Opnd  => Prepare_64 (Comp),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+      end if;\n+\n+      --  Build the Last reference we will use\n+\n+      Right :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix         => New_Occurrence_Of (Ent, Loc),\n+          Attribute_Name => Name_Last);\n+\n+      if Present (Index) then\n+         Set_Expressions (Right, New_List (New_Copy (Index)));\n+      end if;\n+\n+      --  If general operand, convert Last reference to Long_Long_Integer\n+\n+      if Present (Comp) then\n+         Right := Prepare_64 (Right);\n+      end if;\n+\n+      --  Check for cases to optimize\n+\n+      --  X'Length = 0  => X'First > X'Last\n+      --  X'Length < 1  => X'First > X'Last\n+      --  X'Length < n  => X'First + (n - 1) > X'Last\n+\n+      if (Is_Zero and then Op = N_Op_Eq)\n+        or else (not Is_Zero and then Op = N_Op_Lt)\n+      then\n+         Result :=\n+           Make_Op_Gt (Loc,\n+             Left_Opnd  => Left,\n+             Right_Opnd => Right);\n+\n+      --  X'Length = 1  => X'First = X'Last\n+      --  X'Length = n  => X'First + (n - 1) = X'Last\n+\n+      elsif not Is_Zero and then Op = N_Op_Eq then\n+         Result :=\n+           Make_Op_Eq (Loc,\n+             Left_Opnd  => Left,\n+             Right_Opnd => Right);\n+\n+      --  X'Length /= 0 => X'First <= X'Last\n+      --  X'Length > 0  => X'First <= X'Last\n+\n+      elsif Is_Zero and (Op = N_Op_Ne or else Op = N_Op_Gt) then\n+         Result :=\n+           Make_Op_Le (Loc,\n+             Left_Opnd  => Left,\n+             Right_Opnd => Right);\n+\n+      --  X'Length /= 1 => X'First /= X'Last\n+      --  X'Length /= n => X'First + (n - 1) /= X'Last\n+\n+      elsif not Is_Zero and then Op = N_Op_Ne then\n+         Result :=\n+           Make_Op_Ne (Loc,\n+             Left_Opnd  => Left,\n+             Right_Opnd => Right);\n+\n+      --  X'Length >= 1 => X'First <= X'Last\n+      --  X'Length >= n => X'First + (n - 1) <= X'Last\n+\n+      elsif not Is_Zero and then Op = N_Op_Ge then\n+         Result :=\n+           Make_Op_Le (Loc,\n+             Left_Opnd  => Left,\n+                       Right_Opnd => Right);\n+\n+      --  X'Length > 1  => X'First < X'Last\n+      --  X'Length > n  => X'First + (n = 1) < X'Last\n+\n+      elsif not Is_Zero and then Op = N_Op_Gt then\n+         Result :=\n+           Make_Op_Lt (Loc,\n+             Left_Opnd  => Left,\n+             Right_Opnd => Right);\n+\n+      --  X'Length <= 1 => X'First >= X'Last\n+      --  X'Length <= n => X'First + (n - 1) >= X'Last\n+\n+      elsif not Is_Zero and then Op = N_Op_Le then\n+         Result :=\n+           Make_Op_Ge (Loc,\n+             Left_Opnd  => Left,\n+             Right_Opnd => Right);\n+\n+      --  Should not happen at this stage\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      --  Rewrite and finish up\n+\n+      Rewrite (N, Result);\n+      Analyze_And_Resolve (N, Typ);\n+      return;\n+   end Optimize_Length_Comparison;\n+\n    ------------------------\n    -- Rewrite_Comparison --\n    ------------------------"}, {"sha": "15db8b9668b44e5ff1e14438dde1daf9c05eb088", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -11516,7 +11516,7 @@ package body Exp_Ch9 is\n       end if;\n \n       --  If the type of the dispatching object is an access type then return\n-      --  an explicit dereference\n+      --  an explicit dereference.\n \n       if Is_Access_Type (Etype (Object)) then\n          Object := Make_Explicit_Dereference (Sloc (N), Object);"}, {"sha": "f1320ec554e9e73cef9757c066f9f7bb58eb0ea6", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -89,13 +89,23 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n \n    procedure Process_Restrictions_Or_Restriction_Warnings;\n    --  Common processing for Restrictions and Restriction_Warnings pragmas.\n-   --  This routine processes the cases of No_Obsolescent_Features and SPARK,\n-   --  which are the only restriction that have syntactic effects. In the case\n-   --  of SPARK, it controls whether the scanner generates a token\n-   --  Tok_SPARK_Hide for HIDE directives formatted as Ada comments. No general\n-   --  error checking is done, since this will be done in Sem_Prag. The other\n-   --  case processed is pragma Restrictions No_Dependence, since otherwise\n-   --  this is done too late.\n+   --  For the most part, restrictions need not be processed at parse time,\n+   --  since they only affect semantic processing. This routine handles the\n+   --  exceptions as follows\n+   --\n+   --    No_Obsolescent_Features must be processed at parse time, since there\n+   --    are some obsolescent features (e.g. character replacements) which are\n+   --    handled at parse time.\n+   --\n+   --    SPARK must be processed at parse time, since this restriction controls\n+   --    whether the scanner recognizes a spark HIDE directive formatted as an\n+   --    Ada comment (and generates a Tok_SPARK_Hide token for the directive).\n+   --\n+   --    No_Dependence must be processed at parse time, since otherwise it gets\n+   --    handled too late.\n+   --\n+   --  Note that we don't need to do full error checking for badly formed cases\n+   --  of restrictions, since these will be caught during semantic analysis.\n \n    ----------\n    -- Arg1 --\n@@ -232,10 +242,12 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n                   Set_Restriction (No_Obsolescent_Features, Pragma_Node);\n                   Restriction_Warnings (No_Obsolescent_Features) :=\n                     Prag_Id = Pragma_Restriction_Warnings;\n+\n                when SPARK =>\n                   Set_Restriction (SPARK, Pragma_Node);\n                   Restriction_Warnings (SPARK) :=\n                     Prag_Id = Pragma_Restriction_Warnings;\n+\n                when others =>\n                   null;\n             end case;"}, {"sha": "92709c93526644eab094dd0de8bbb6448279f2a1", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -178,9 +178,9 @@ package Restrict is\n    -- SPARK Restriction Control --\n    -------------------------------\n \n-   --  SPARK HIDE directives allow turning off SPARK restriction for a\n-   --  specified region of code, and the following tables are the data\n-   --  structures used to keep track of these regions.\n+   --  SPARK HIDE directives allow the effect of the SPARK restriction to be\n+   --  turned off for a specified region of code, and the following tables are\n+   --  the data structures used to keep track of these regions.\n \n    --  The table contains pairs of source locations, the first being the start\n    --  location for hidden region, and the second being the end location."}, {"sha": "f0bc9de8b27f870817bc1adf4d208574b879fece", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -1764,8 +1764,8 @@ package body Scng is\n                   return;\n                end if;\n \n-               --  Generate a token Tok_SPARK_Hide for a SPARK HIDE directive\n-               --  only if the SPARK restriction is set for this unit.\n+               --  If the SPARK restriction is set for this unit, then generate\n+               --  a token Tok_SPARK_Hide for a SPARK HIDE directive.\n \n                if Restriction_Check_Required (SPARK)\n                  and then Source (Start_Of_Comment) = '#'"}, {"sha": "8d8980e194bedf4e57f415a0d1efe12c8e410878", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -2335,6 +2335,7 @@ package body Sem_Util is\n \n    procedure Mark_Non_ALFA_Subprogram_Unconditional is\n       Cur_Subp : constant Entity_Id := Current_Subprogram;\n+\n    begin\n       if Present (Cur_Subp)\n         and then (Is_Subprogram (Cur_Subp)\n@@ -2344,6 +2345,9 @@ package body Sem_Util is\n          --  then mark the subprogram as not in ALFA. Otherwise, mark the\n          --  subprogram body as not in ALFA.\n \n+         --  This comment just says what is done, but not why ??? and it\n+         --  just repeats what is in the spec ???\n+\n          if In_Pre_Post_Expression then\n             Set_Is_In_ALFA (Cur_Subp, False);\n          else"}, {"sha": "371afbb91034723927d3f1a5ba271d87ccea0a4c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -279,10 +279,14 @@ package Sem_Util is\n \n    procedure Mark_Non_ALFA_Subprogram;\n    --  If Current_Subprogram is not Empty, mark either its specification or its\n-   --  body as not being in ALFA. If called during the analysis of a\n-   --  precondition or postcondition, as indicated by the flag\n+   --  body as not being in ALFA. If this procedure is called during the\n+   --  analysis of a precondition or postcondition, as indicated by the flag\n    --  In_Pre_Post_Expression, mark the specification as not being in ALFA.\n    --  Otherwise, mark the body as not being in ALFA.\n+   --\n+   --  I would really like to see more comments on this peculiar processing\n+   --  for precondition/postcondition, the comment above says what is done\n+   --  but not why???\n \n    function Defining_Entity (N : Node_Id) return Entity_Id;\n    --  Given a declaration N, returns the associated defining entity. If the"}, {"sha": "48b138e4c7c120cd89778f4ec0f532da68217294", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0580d8070754fa3ce59081f3906d9a4f2201757c/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=0580d8070754fa3ce59081f3906d9a4f2201757c", "patch": "@@ -1116,7 +1116,7 @@ package Sinfo is\n    --    this is required, see Exp_Ch11.Remove_Handler_Entries.\n \n    --  Has_Dynamic_Length_Check (Flag10-Sem)\n-   --    This flag is present on all expression nodes. It is set to indicate\n+   --    This flag is present in all expression nodes. It is set to indicate\n    --    that one of the routines in unit Checks has generated a length check\n    --    action which has been inserted at the flagged node. This is used to\n    --    avoid the generation of duplicate checks.\n@@ -1126,7 +1126,8 @@ package Sinfo is\n    --    expression nodes. It is set to indicate that one of the routines in\n    --    unit Checks has generated a range check action which has been inserted\n    --    at the flagged node. This is used to avoid the generation of duplicate\n-   --    checks.\n+   --    checks. Why does this occur on N_Subtype_Declaration nodes, what does\n+   --    it mean in that context???\n \n    --  Has_Local_Raise (Flag8-Sem)\n    --    Present in exception handler nodes. Set if the handler can be entered"}]}