{"sha": "332072dbd12841f96ec5f6a5048777a8d7ad266d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMyMDcyZGJkMTI4NDFmOTZlYzVmNmE1MDQ4Nzc3YThkN2FkMjY2ZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "1998-09-19T07:46:45Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "1998-09-19T07:46:45Z"}, "message": "arm.c (add_constant): New parameter address_only, change caller.\n\n* arm.c (add_constant): New parameter address_only, change caller.\nSet it non-zero if taking the address of an item in the pool.\n(arm_reorg): Handle cases where we need the address of an item in\nthe pool.\n\nFrom-SVN: r22477", "tree": {"sha": "e165f4db0a977ab0e62ac85f50c889e3d68eff2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e165f4db0a977ab0e62ac85f50c889e3d68eff2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/332072dbd12841f96ec5f6a5048777a8d7ad266d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/332072dbd12841f96ec5f6a5048777a8d7ad266d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/332072dbd12841f96ec5f6a5048777a8d7ad266d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/332072dbd12841f96ec5f6a5048777a8d7ad266d/comments", "author": null, "committer": null, "parents": [{"sha": "e9904c1772e305c98c1bcdc61d85163060ceb6d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9904c1772e305c98c1bcdc61d85163060ceb6d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9904c1772e305c98c1bcdc61d85163060ceb6d5"}], "stats": {"total": 81, "additions": 56, "deletions": 25}, "files": [{"sha": "9c1bc65323590aeb1442f665e8993f577ed2012c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/332072dbd12841f96ec5f6a5048777a8d7ad266d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/332072dbd12841f96ec5f6a5048777a8d7ad266d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=332072dbd12841f96ec5f6a5048777a8d7ad266d", "patch": "@@ -1,3 +1,10 @@\n+Sat Sep 19 07:33:36 1998  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm.c (add_constant): New parameter address_only, change caller.\n+\tSet it non-zero if taking the address of an item in the pool.\n+\t(arm_reorg): Handle cases where we need the address of an item in\n+\tthe pool.\n+\n Sat Sep 19 01:00:32 1998  Michael Hayes  (mph@elec.canterbury.ac.nz)\n \n \t* README.C4X: New file with information about the c4x ports."}, {"sha": "7c2f9b1936d982aa89ecfe00f3d05b40be2af1e6", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/332072dbd12841f96ec5f6a5048777a8d7ad266d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/332072dbd12841f96ec5f6a5048777a8d7ad266d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=332072dbd12841f96ec5f6a5048777a8d7ad266d", "patch": "@@ -55,7 +55,7 @@ static int arm_naked_function_p PROTO ((tree));\n static void init_fpa_table PROTO ((void));\n static enum machine_mode select_dominance_cc_mode PROTO ((enum rtx_code, rtx,\n \t\t\t\t\t\t\t  rtx, HOST_WIDE_INT));\n-static HOST_WIDE_INT add_constant PROTO ((rtx, enum machine_mode));\n+static HOST_WIDE_INT add_constant PROTO ((rtx, enum machine_mode, int *));\n static void dump_table PROTO ((rtx));\n static int fixit PROTO ((rtx, enum machine_mode, int));\n static rtx find_barrier PROTO ((rtx, int));\n@@ -3446,18 +3446,30 @@ static pool_node pool_vector[MAX_POOL_SIZE];\n static int pool_size;\n static rtx pool_vector_label;\n \n-/* Add a constant to the pool and return its label.  */\n+/* Add a constant to the pool and return its offset within the current\n+   pool.\n+\n+   X is the rtx we want to replace. MODE is its mode.  On return,\n+   ADDRESS_ONLY will be non-zero if we really want the address of such\n+   a constant, not the constant itself.  */\n static HOST_WIDE_INT\n-add_constant (x, mode)\n+add_constant (x, mode, address_only)\n      rtx x;\n      enum machine_mode mode;\n+     int *address_only;\n {\n   int i;\n   HOST_WIDE_INT offset;\n \n+  *address_only = 0;\n   if (mode == SImode && GET_CODE (x) == MEM && CONSTANT_P (XEXP (x, 0))\n       && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n     x = get_pool_constant (XEXP (x, 0));\n+  else if (GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P(x))\n+    {\n+      *address_only = 1;\n+      x = get_pool_constant (x);\n+    }\n #ifndef AOF_ASSEMBLER\n   else if (GET_CODE (x) == UNSPEC && XINT (x, 1) == 3)\n     x = XVECEXP (x, 0, 0);\n@@ -3709,6 +3721,7 @@ arm_reorg (first)\n \t\t  rtx newsrc;\n \t\t  rtx addr;\n \t\t  int scratch;\n+\t\t  int address_only;\n \n \t\t  /* If this is an HImode constant load, convert it into\n \t\t     an SImode constant load.  Since the register is always\n@@ -3722,39 +3735,50 @@ arm_reorg (first)\n \t\t      PUT_MODE (dst, SImode);\n \t\t    }\n \n-\t\t  offset = add_constant (src, mode);\n+\t\t  offset = add_constant (src, mode, &address_only);\n \t\t  addr = plus_constant (gen_rtx (LABEL_REF, VOIDmode,\n \t\t\t\t\t\t pool_vector_label),\n \t\t\t\t\toffset);\n \n-\t\t  /* For wide moves to integer regs we need to split the\n-\t\t     address calculation off into a separate insn, so that\n-\t\t     the load can then be done with a load-multiple.  This is\n-\t\t     safe, since we have already noted the length of such\n-\t\t     insns to be 8, and we are immediately over-writing the\n-\t\t     scratch we have grabbed with the final result.  */\n-\t\t  if (GET_MODE_SIZE (mode) > 4\n+\t\t  /* If we only want the address of the pool entry, or\n+\t\t     for wide moves to integer regs we need to split\n+\t\t     the address calculation off into a separate insn.\n+\t\t     If necessary, the load can then be done with a\n+\t\t     load-multiple.  This is safe, since we have\n+\t\t     already noted the length of such insns to be 8,\n+\t\t     and we are immediately over-writing the scratch\n+\t\t     we have grabbed with the final result.  */\n+\t\t  if ((address_only || GET_MODE_SIZE (mode) > 4)\n \t\t      && (scratch = REGNO (dst)) < 16)\n \t\t    {\n-\t\t      rtx reg = gen_rtx (REG, SImode, scratch);\n+\t\t      rtx reg;\n+\n+\t\t      if (mode == SImode)\n+\t\t\treg = dst;\n+\t\t      else \n+\t\t\treg = gen_rtx (REG, SImode, scratch);\n+\n \t\t      newinsn = emit_insn_after (gen_movaddr (reg, addr),\n \t\t\t\t\t\t newinsn);\n \t\t      addr = reg;\n \t\t    }\n \n-\t\t  newsrc = gen_rtx (MEM, mode, addr);\n-\n-\t\t  /* Build a jump insn wrapper around the move instead\n-\t\t     of an ordinary insn, because we want to have room for\n-\t\t     the target label rtx in fld[7], which an ordinary\n-\t\t     insn doesn't have. */\n-\t\t  newinsn = emit_jump_insn_after (gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t\t\t   dst, newsrc),\n-\t\t\t\t\t\t  newinsn);\n-\t\t  JUMP_LABEL (newinsn) = pool_vector_label;\n-\n-\t\t  /* But it's still an ordinary insn */\n-\t\t  PUT_CODE (newinsn, INSN);\n+\t\t  if (! address_only)\n+\t\t    {\n+\t\t      newsrc = gen_rtx (MEM, mode, addr);\n+\n+\t\t      /* XXX Fixme -- I think the following is bogus.  */\n+\t\t      /* Build a jump insn wrapper around the move instead\n+\t\t\t of an ordinary insn, because we want to have room for\n+\t\t\t the target label rtx in fld[7], which an ordinary\n+\t\t\t insn doesn't have. */\n+\t\t      newinsn = emit_jump_insn_after\n+\t\t\t(gen_rtx (SET, VOIDmode, dst, newsrc), newinsn);\n+\t\t      JUMP_LABEL (newinsn) = pool_vector_label;\n+\n+\t\t      /* But it's still an ordinary insn */\n+\t\t      PUT_CODE (newinsn, INSN);\n+\t\t    }\n \n \t\t  /* Kill old insn */\n \t\t  delete_insn (scan);"}]}