{"sha": "585ddf9c47fb750de8713634a5e93ed4fe55814a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg1ZGRmOWM0N2ZiNzUwZGU4NzEzNjM0YTVlOTNlZDRmZTU1ODE0YQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2000-11-11T00:37:45Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2000-11-11T00:37:45Z"}, "message": "codecvt.h (__iconv_adaptor): New adaptor function...\n\n2000-11-10  Phil Edwards  <pme@sources.redhat.com>\n\n\t* include/bits/codecvt.h (__iconv_adaptor):  New adaptor function,\n\t  courtesy of Alexandre Oliva, to handle const/non-const signatures.\n\t  (codecvt::do_out):  Use.\n\t  (codecvt::do_in):  And here.\n\nFrom-SVN: r37379", "tree": {"sha": "d8e06c790e2f0d1609f45833171e8778efd60d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8e06c790e2f0d1609f45833171e8778efd60d80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/585ddf9c47fb750de8713634a5e93ed4fe55814a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/585ddf9c47fb750de8713634a5e93ed4fe55814a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/585ddf9c47fb750de8713634a5e93ed4fe55814a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/585ddf9c47fb750de8713634a5e93ed4fe55814a/comments", "author": null, "committer": null, "parents": [{"sha": "d2ea6600c851cf20e339d65cabc948b5bdd80b2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ea6600c851cf20e339d65cabc948b5bdd80b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2ea6600c851cf20e339d65cabc948b5bdd80b2d"}], "stats": {"total": 47, "additions": 36, "deletions": 11}, "files": [{"sha": "be17c8e6ab00d11d9670f2272aa7c59104a0d8ad", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/585ddf9c47fb750de8713634a5e93ed4fe55814a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/585ddf9c47fb750de8713634a5e93ed4fe55814a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=585ddf9c47fb750de8713634a5e93ed4fe55814a", "patch": "@@ -1,3 +1,10 @@\n+2000-11-10  Phil Edwards  <pme@sources.redhat.com>\n+\n+\t* include/bits/codecvt.h (__iconv_adaptor):  New adaptor function,\n+\t  courtesy of Alexandre Oliva, to handle const/non-const signatures.\n+\t  (codecvt::do_out):  Use.\n+\t  (codecvt::do_in):  And here.\n+\n 2000-11-10  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* include/bits/cpp_type_traits.h: Fix typos.  Adjust formatting."}, {"sha": "97fc015509c63c62a033dd8a92162f396534b7d0", "filename": "libstdc++-v3/include/bits/codecvt.h", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/585ddf9c47fb750de8713634a5e93ed4fe55814a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/585ddf9c47fb750de8713634a5e93ed4fe55814a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h?ref=585ddf9c47fb750de8713634a5e93ed4fe55814a", "patch": "@@ -372,6 +372,19 @@ namespace std\n     locale::id \n     codecvt<_InternT, _ExternT, __enc_traits>::id;\n \n+  // This adaptor works around the signature problems of the second\n+  // argument to iconv():  SUSv2 and others use 'const char**', but glibc 2.2\n+  // uses 'char**', which is what the standard is (apparently) due to use\n+  // in the future.  Using this adaptor, g++ will do the work for us.\n+  template<typename _T>\n+    inline size_t\n+    __iconv_adaptor(size_t(*iconv_func)(iconv_t, _T, size_t *, char**, size_t*),\n+                    iconv_t cd, char **inbuf, size_t *inbytesleft,\n+                    char **outbuf, size_t *outbytesleft)\n+    {\n+      return iconv_func (cd, (_T)inbuf, inbytesleft, outbuf, outbytesleft);\n+    }\n+\n   template<typename _InternT, typename _ExternT>\n     codecvt_base::result\n     codecvt<_InternT, _ExternT, __enc_traits>::\n@@ -393,7 +406,7 @@ namespace std\n \t  // Argument list for iconv specifies a byte sequence. Thus,\n \t  // all to/from arrays must be brutally casted to char*.\n \t  char* __cto = reinterpret_cast<char*>(__to);\n-\t  const char* __cfrom;\n+\t  char* __cfrom;\n \t  size_t __conv;\n \n \t  // Some encodings need a byte order marker as the first item\n@@ -408,14 +421,16 @@ namespace std\n \t      intern_type __cfixed[__size + 1];\n \t      __cfixed[0] = static_cast<intern_type>(__int_bom);\n \t      char_traits<intern_type>::copy(__cfixed + 1, __from, __size);\n-\t      __cfrom = reinterpret_cast<const char*>(__cfixed);\n-\t      __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t      __cfrom = reinterpret_cast<char*>(__cfixed);\n+\t      __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,\n+                                        &__flen, &__cto, &__tlen); \n \t    }\n \t  else\n \t    {\n \t      intern_type* __cfixed = const_cast<intern_type*>(__from);\n-\t      __cfrom = reinterpret_cast<const char*>(__cfixed);\n-\t      __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t      __cfrom = reinterpret_cast<char*>(__cfixed);\n+\t      __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,\n+                                       &__flen, &__cto, &__tlen); \n \t    }\n \n \t  if (__conv != size_t(-1))\n@@ -456,7 +471,8 @@ namespace std\n \t  // Argument list for iconv specifies a byte sequence. Thus,\n \t  // all to/from arrays must be brutally casted to char*.\n \t  char* __cto = reinterpret_cast<char*>(__to);\n-\t  size_t __conv = iconv(*__desc, NULL, NULL, &__cto, &__tlen); \n+\t  size_t __conv = __iconv_adaptor(iconv,*__desc, NULL, NULL,\n+                                          &__cto, &__tlen); \n \t  \n \t  if (__conv != size_t(-1))\n \t    {\n@@ -495,7 +511,7 @@ namespace std\n \t  // Argument list for iconv specifies a byte sequence. Thus,\n \t  // all to/from arrays must be brutally casted to char*.\n \t  char* __cto = reinterpret_cast<char*>(__to);\n-\t  const char* __cfrom;\n+\t  char* __cfrom;\n \t  size_t __conv;\n \n \t  // Some encodings need a byte order marker as the first item\n@@ -510,14 +526,16 @@ namespace std\n \t      extern_type __cfixed[__size + 1];\n \t      __cfixed[0] = static_cast<extern_type>(__ext_bom);\n \t      char_traits<extern_type>::copy(__cfixed + 1, __from, __size);\n-\t      __cfrom = reinterpret_cast<const char*>(__cfixed);\n-\t      __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t      __cfrom = reinterpret_cast<char*>(__cfixed);\n+\t      __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,\n+                                       &__flen, &__cto, &__tlen); \n \t    }\n \t  else\n \t    {\n \t      extern_type* __cfixed = const_cast<extern_type*>(__from);\n-\t      __cfrom = reinterpret_cast<const char*>(__cfixed);\n-\t      __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t      __cfrom = reinterpret_cast<char*>(__cfixed);\n+\t      __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,\n+                                       &__flen, &__cto, &__tlen); \n \t    }\n \n \t  "}]}