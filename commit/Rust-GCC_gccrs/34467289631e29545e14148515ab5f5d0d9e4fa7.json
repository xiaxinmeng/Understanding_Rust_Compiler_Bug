{"sha": "34467289631e29545e14148515ab5f5d0d9e4fa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ0NjcyODk2MzFlMjk1NDVlMTQxNDg1MTVhYjVmNWQwZDllNGZhNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-14T07:58:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-14T07:58:30Z"}, "message": "[AArch64] Rework SVE PTEST patterns\n\nThis patch reworks the rtl representation of the SVE PTEST operation\nso that:\n\n- the governing predicate is always VNx16BI (and so all bits are defined)\n\n- it is still possible to pattern-match the governing predicate in the\n  mode that it had previously\n\n- a new hint operand says whether the governing predicate is known to be\n  all true for the element size of interest, rather than this being part\n  of the unspec name.\n\nThese changes make it easier to handle more flag-setting instructions\nas part of the ACLE work.\n\nSee the comment in aarch64-sve.md for more details.\n\n2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_ptrue_all): Declare.\n\t* config/aarch64/aarch64.c (aarch64_ptrue_all): New function.\n\t* config/aarch64/aarch64.md (UNSPEC_PTEST_PTRUE): Delete.\n\t(UNSPEC_PTEST): New unspec.\n\t(SVE_MAYBE_NOT_PTRUE, SVE_KNOWN_PTRUE): New constants.\n\t* config/aarch64/iterators.md (data_bytes): New mode attribute.\n\t* config/aarch64/predicates.md (aarch64_sve_ptrue_flag): New predicate.\n\t* config/aarch64/aarch64-sve.md: Add a new section describing the\n\thandling of UNSPEC_PTEST.\n\t(pred_<LOGICAL:optab><PRED_ALL:mode>3): Rename to...\n\t(@aarch64_pred_<LOGICAL:optab><PRED_ALL:mode>_z): ...this.\n\t(ptest_ptrue<mode>): Replace with...\n\t(aarch64_ptest<mode>): ...this new pattern.\n\t(cbranch<mode>4): Update after above changes.\n\t(*<LOGICAL:optab><PRED_ALL:mode>3_cc): Use UNSPEC_PTEST instead of\n\tUNSPEC_PTEST_PTRUE.\n\t(*cmp<SVE_INT_CMP:cmp_op><SVE_I:mode>_cc): Likewise.\n\t(*cmp<SVE_INT_CMP:cmp_op><SVE_I:mode>_ptest): Likewise.\n\t(*while_ult<GPI:mode><PRED_ALL:mode>_cc): Likewise.\n\nFrom-SVN: r274414", "tree": {"sha": "96a0240ecded5c49122b83ea2d46224ec416554d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96a0240ecded5c49122b83ea2d46224ec416554d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34467289631e29545e14148515ab5f5d0d9e4fa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34467289631e29545e14148515ab5f5d0d9e4fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34467289631e29545e14148515ab5f5d0d9e4fa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34467289631e29545e14148515ab5f5d0d9e4fa7/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ade8fdbbfd98aafdc12585885dea60460fea0a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade8fdbbfd98aafdc12585885dea60460fea0a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade8fdbbfd98aafdc12585885dea60460fea0a26"}], "stats": {"total": 213, "additions": 168, "deletions": 45}, "files": [{"sha": "9e2b2c15dcf47bf414c7bcb4eeda4ee2d1dc385a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34467289631e29545e14148515ab5f5d0d9e4fa7", "patch": "@@ -1,3 +1,25 @@\n+2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_ptrue_all): Declare.\n+\t* config/aarch64/aarch64.c (aarch64_ptrue_all): New function.\n+\t* config/aarch64/aarch64.md (UNSPEC_PTEST_PTRUE): Delete.\n+\t(UNSPEC_PTEST): New unspec.\n+\t(SVE_MAYBE_NOT_PTRUE, SVE_KNOWN_PTRUE): New constants.\n+\t* config/aarch64/iterators.md (data_bytes): New mode attribute.\n+\t* config/aarch64/predicates.md (aarch64_sve_ptrue_flag): New predicate.\n+\t* config/aarch64/aarch64-sve.md: Add a new section describing the\n+\thandling of UNSPEC_PTEST.\n+\t(pred_<LOGICAL:optab><PRED_ALL:mode>3): Rename to...\n+\t(@aarch64_pred_<LOGICAL:optab><PRED_ALL:mode>_z): ...this.\n+\t(ptest_ptrue<mode>): Replace with...\n+\t(aarch64_ptest<mode>): ...this new pattern.\n+\t(cbranch<mode>4): Update after above changes.\n+\t(*<LOGICAL:optab><PRED_ALL:mode>3_cc): Use UNSPEC_PTEST instead of\n+\tUNSPEC_PTEST_PTRUE.\n+\t(*cmp<SVE_INT_CMP:cmp_op><SVE_I:mode>_cc): Likewise.\n+\t(*cmp<SVE_INT_CMP:cmp_op><SVE_I:mode>_ptest): Likewise.\n+\t(*while_ult<GPI:mode><PRED_ALL:mode>_cc): Likewise.\n+\n 2019-08-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>\n \n \tPR lto/91287"}, {"sha": "22a5f9433db8e37b380c255a26c1b4a9c06862a8", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=34467289631e29545e14148515ab5f5d0d9e4fa7", "patch": "@@ -550,6 +550,7 @@ const char * aarch64_output_probe_stack_range (rtx, rtx);\n const char * aarch64_output_probe_sve_stack_clash (rtx, rtx, rtx, rtx);\n void aarch64_err_no_fpadvsimd (machine_mode);\n void aarch64_expand_epilogue (bool);\n+rtx aarch64_ptrue_all (unsigned int);\n void aarch64_expand_mov_immediate (rtx, rtx);\n rtx aarch64_ptrue_reg (machine_mode);\n rtx aarch64_pfalse_reg (machine_mode);"}, {"sha": "f94ad5cdbf472ff9703419824d8f75339f780f3d", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 110, "deletions": 44, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=34467289631e29545e14148515ab5f5d0d9e4fa7", "patch": "@@ -23,6 +23,7 @@\n ;;\n ;; == General notes\n ;; ---- Note on the handling of big-endian SVE\n+;; ---- Description of UNSPEC_PTEST\n ;;\n ;; == Moves\n ;; ---- Moves of single vectors\n@@ -166,7 +167,67 @@\n ;;   the order of the bytes within the elements is different.  We instead\n ;;   access spill slots via LD1 and ST1, using secondary reloads to\n ;;   reserve a predicate register.\n-\n+;;\n+;; -------------------------------------------------------------------------\n+;; ---- Description of UNSPEC_PTEST\n+;; -------------------------------------------------------------------------\n+;;\n+;; SVE provides a PTEST instruction for testing the active lanes of a\n+;; predicate and setting the flags based on the result.  The associated\n+;; condition code tests are:\n+;;\n+;; - any   (= ne): at least one active bit is set\n+;; - none  (= eq): all active bits are clear (*)\n+;; - first (= mi): the first active bit is set\n+;; - nfrst (= pl): the first active bit is clear (*)\n+;; - last  (= cc): the last active bit is set\n+;; - nlast (= cs): the last active bit is clear (*)\n+;;\n+;; where the conditions marked (*) are also true when there are no active\n+;; lanes (i.e. when the governing predicate is a PFALSE).  The flags results\n+;; of a PTEST use the condition code mode CC_NZC.\n+;;\n+;; PTEST is always a .B operation (i.e. it always operates on VNx16BI).\n+;; This means that for other predicate modes, we need a governing predicate\n+;; in which all bits are defined.\n+;;\n+;; For example, most predicated .H operations ignore the odd bits of the\n+;; governing predicate, so that an active lane is represented by the\n+;; bits \"1x\" and an inactive lane by the bits \"0x\", where \"x\" can be\n+;; any value.  To test a .H predicate, we instead need \"10\" and \"00\"\n+;; respectively, so that the condition only tests the even bits of the\n+;; predicate.\n+;;\n+;; Several instructions set the flags as a side-effect, in the same way\n+;; that a separate PTEST would.  It's important for code quality that we\n+;; use these flags results as often as possible, particularly in the case\n+;; of WHILE* and RDFFR.\n+;;\n+;; Also, some of the instructions that set the flags are unpredicated\n+;; and instead implicitly test all .B, .H, .S or .D elements, as though\n+;; they were predicated on a PTRUE of that size.  For example, a .S\n+;; WHILELO sets the flags in the same way as a PTEST with a .S PTRUE\n+;; would.\n+;;\n+;; We therefore need to represent PTEST operations in a way that\n+;; makes it easy to combine them with both predicated and unpredicated\n+;; operations, while using a VNx16BI governing predicate for all\n+;; predicate modes.  We do this using:\n+;;\n+;;   (unspec:CC_NZC [gp cast_gp ptrue_flag op] UNSPEC_PTEST)\n+;;\n+;; where:\n+;;\n+;; - GP is the real VNx16BI governing predicate\n+;;\n+;; - CAST_GP is GP cast to the mode of OP.  All bits dropped by casting\n+;;   GP to CAST_GP are guaranteed to be clear in GP.\n+;;\n+;; - PTRUE_FLAG is a CONST_INT (conceptually of mode SI) that has the value\n+;;   SVE_KNOWN_PTRUE if we know that CAST_GP (rather than GP) is all-true and\n+;;   SVE_MAYBE_NOT_PTRUE otherwise.\n+;;\n+;; - OP is the predicate we want to test, of the same mode as CAST_GP.\n \n ;; =========================================================================\n ;; == Moves\n@@ -2343,7 +2404,7 @@\n )\n \n ;; Predicated predicate AND, EOR and ORR.\n-(define_insn \"pred_<optab><mode>3\"\n+(define_insn \"@aarch64_pred_<optab><mode>_z\"\n   [(set (match_operand:PRED_ALL 0 \"register_operand\" \"=Upa\")\n \t(and:PRED_ALL\n \t  (LOGICAL:PRED_ALL\n@@ -2355,23 +2416,23 @@\n )\n \n ;; Perform a logical operation on operands 2 and 3, using operand 1 as\n-;; the GP (which is known to be a PTRUE).  Store the result in operand 0\n-;; and set the flags in the same way as for PTEST.  The (and ...) in the\n-;; UNSPEC_PTEST_PTRUE is logically redundant, but means that the tested\n-;; value is structurally equivalent to rhs of the second set.\n+;; the GP.  Store the result in operand 0 and set the flags in the same\n+;; way as for PTEST.\n (define_insn \"*<optab><mode>3_cc\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n-\t  [(match_operand:PRED_ALL 1 \"register_operand\" \"Upa\")\n+\t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upa\")\n+\t   (match_operand 4)\n+\t   (match_operand:SI 5 \"aarch64_sve_ptrue_flag\")\n \t   (and:PRED_ALL\n \t     (LOGICAL:PRED_ALL\n \t       (match_operand:PRED_ALL 2 \"register_operand\" \"Upa\")\n \t       (match_operand:PRED_ALL 3 \"register_operand\" \"Upa\"))\n-\t     (match_dup 1))]\n-\t  UNSPEC_PTEST_PTRUE))\n+\t     (match_dup 4))]\n+\t  UNSPEC_PTEST))\n    (set (match_operand:PRED_ALL 0 \"register_operand\" \"=Upa\")\n \t(and:PRED_ALL (LOGICAL:PRED_ALL (match_dup 2) (match_dup 3))\n-\t\t      (match_dup 1)))]\n+\t\t      (match_dup 4)))]\n   \"TARGET_SVE\"\n   \"<logical>s\\t%0.b, %1/z, %2.b, %3.b\"\n )\n@@ -2836,17 +2897,19 @@\n (define_insn \"*cmp<cmp_op><mode>_cc\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upl, Upl\")\n+\t   (match_operand 4)\n+\t   (match_operand:SI 5 \"aarch64_sve_ptrue_flag\")\n \t   (unspec:<VPRED>\n-\t     [(match_dup 1)\n+\t     [(match_dup 4)\n \t      (SVE_INT_CMP:<VPRED>\n \t\t(match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n \t\t(match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n \t     UNSPEC_MERGE_PTRUE)]\n-\t  UNSPEC_PTEST_PTRUE))\n+\t  UNSPEC_PTEST))\n    (set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(unspec:<VPRED>\n-\t  [(match_dup 1)\n+\t  [(match_dup 4)\n \t   (SVE_INT_CMP:<VPRED>\n \t     (match_dup 2)\n \t     (match_dup 3))]\n@@ -2862,14 +2925,16 @@\n (define_insn \"*cmp<cmp_op><mode>_ptest\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upl, Upl\")\n+\t   (match_operand 4)\n+\t   (match_operand:SI 5 \"aarch64_sve_ptrue_flag\")\n \t   (unspec:<VPRED>\n-\t     [(match_dup 1)\n+\t     [(match_dup 4)\n \t      (SVE_INT_CMP:<VPRED>\n \t\t(match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n \t\t(match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n \t     UNSPEC_MERGE_PTRUE)]\n-\t  UNSPEC_PTEST_PTRUE))\n+\t  UNSPEC_PTEST))\n    (clobber (match_scratch:<VPRED> 0 \"=Upa, Upa\"))]\n   \"TARGET_SVE\"\n   \"@\n@@ -2940,28 +3005,31 @@\n )\n \n ;; WHILELO sets the flags in the same way as a PTEST with a PTRUE GP.\n-;; Handle the case in which both results are useful.  The GP operand\n-;; to the PTEST isn't needed, so we allow it to be anything.\n+;; Handle the case in which both results are useful.  The GP operands\n+;; to the PTEST aren't needed, so we allow them to be anything.\n (define_insn_and_rewrite \"*while_ult<GPI:mode><PRED_ALL:mode>_cc\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n-\t  [(match_operand:PRED_ALL 1)\n+\t  [(match_operand 3)\n+\t   (match_operand 4)\n+\t   (const_int SVE_KNOWN_PTRUE)\n \t   (unspec:PRED_ALL\n-\t     [(match_operand:GPI 2 \"aarch64_reg_or_zero\" \"rZ\")\n-\t      (match_operand:GPI 3 \"aarch64_reg_or_zero\" \"rZ\")]\n+\t     [(match_operand:GPI 1 \"aarch64_reg_or_zero\" \"rZ\")\n+\t      (match_operand:GPI 2 \"aarch64_reg_or_zero\" \"rZ\")]\n \t     UNSPEC_WHILE_LO)]\n-\t  UNSPEC_PTEST_PTRUE))\n+\t  UNSPEC_PTEST))\n    (set (match_operand:PRED_ALL 0 \"register_operand\" \"=Upa\")\n-\t(unspec:PRED_ALL [(match_dup 2)\n-\t\t\t  (match_dup 3)]\n+\t(unspec:PRED_ALL [(match_dup 1)\n+\t\t\t  (match_dup 2)]\n \t\t\t UNSPEC_WHILE_LO))]\n   \"TARGET_SVE\"\n-  \"whilelo\\t%0.<PRED_ALL:Vetype>, %<w>2, %<w>3\"\n+  \"whilelo\\t%0.<PRED_ALL:Vetype>, %<w>1, %<w>2\"\n   ;; Force the compiler to drop the unused predicate operand, so that we\n   ;; don't have an unnecessary PTRUE.\n-  \"&& !CONSTANT_P (operands[1])\"\n+  \"&& (!CONSTANT_P (operands[3]) || !CONSTANT_P (operands[4]))\"\n   {\n-    operands[1] = CONSTM1_RTX (<PRED_ALL:MODE>mode);\n+    operands[3] = CONSTM1_RTX (VNx16BImode);\n+    operands[4] = CONSTM1_RTX (<PRED_ALL:MODE>mode);\n   }\n )\n \n@@ -3133,36 +3201,34 @@\n \t  (pc)))]\n   \"\"\n   {\n-    rtx ptrue = aarch64_ptrue_reg (<MODE>mode);\n+    rtx ptrue = force_reg (VNx16BImode, aarch64_ptrue_all (<data_bytes>));\n+    rtx cast_ptrue = gen_lowpart (<MODE>mode, ptrue);\n+    rtx ptrue_flag = gen_int_mode (SVE_KNOWN_PTRUE, SImode);\n     rtx pred;\n     if (operands[2] == CONST0_RTX (<MODE>mode))\n       pred = operands[1];\n     else\n       {\n \tpred = gen_reg_rtx (<MODE>mode);\n-\temit_insn (gen_pred_xor<mode>3 (pred, ptrue, operands[1],\n-\t\t\t\t\toperands[2]));\n+\temit_insn (gen_aarch64_pred_xor<mode>_z (pred, cast_ptrue, operands[1],\n+\t\t\t\t\t\t operands[2]));\n       }\n-    emit_insn (gen_ptest_ptrue<mode> (ptrue, pred));\n+    emit_insn (gen_aarch64_ptest<mode> (ptrue, cast_ptrue, ptrue_flag, pred));\n     operands[1] = gen_rtx_REG (CC_NZCmode, CC_REGNUM);\n     operands[2] = const0_rtx;\n   }\n )\n \n-;; Test all bits of operand 1.  Operand 0 is a GP that is known to hold PTRUE.\n-;;\n-;; Using UNSPEC_PTEST_PTRUE allows combine patterns to assume that the GP\n-;; is a PTRUE even if the optimizers haven't yet been able to propagate\n-;; the constant.  We would use a separate unspec code for PTESTs involving\n-;; GPs that might not be PTRUEs.\n-(define_insn \"ptest_ptrue<mode>\"\n+;; See \"Description of UNSPEC_PTEST\" above for details.\n+(define_insn \"aarch64_ptest<mode>\"\n   [(set (reg:CC_NZC CC_REGNUM)\n-\t(unspec:CC_NZC\n-\t  [(match_operand:PRED_ALL 0 \"register_operand\" \"Upa\")\n-\t   (match_operand:PRED_ALL 1 \"register_operand\" \"Upa\")]\n-\t  UNSPEC_PTEST_PTRUE))]\n+\t(unspec:CC_NZC [(match_operand:VNx16BI 0 \"register_operand\" \"Upa\")\n+\t\t\t(match_operand 1)\n+\t\t\t(match_operand:SI 2 \"aarch64_sve_ptrue_flag\")\n+\t\t\t(match_operand:PRED_ALL 3 \"register_operand\" \"Upa\")]\n+\t\t       UNSPEC_PTEST))]\n   \"TARGET_SVE\"\n-  \"ptest\\t%0, %1.b\"\n+  \"ptest\\t%0, %3.b\"\n )\n \n ;; ========================================================================="}, {"sha": "b2d49da843b99cdfcd4f0bcb6fc8d1db47c0fc04", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=34467289631e29545e14148515ab5f5d0d9e4fa7", "patch": "@@ -2699,6 +2699,22 @@ aarch64_svpattern_for_vl (machine_mode pred_mode, int vl)\n   return AARCH64_NUM_SVPATTERNS;\n }\n \n+/* Return a VNx16BImode constant in which every sequence of ELT_SIZE\n+   bits has the lowest bit set and the upper bits clear.  This is the\n+   VNx16BImode equivalent of a PTRUE for controlling elements of\n+   ELT_SIZE bytes.  However, because the constant is VNx16BImode,\n+   all bits are significant, even the upper zeros.  */\n+\n+rtx\n+aarch64_ptrue_all (unsigned int elt_size)\n+{\n+  rtx_vector_builder builder (VNx16BImode, elt_size, 1);\n+  builder.quick_push (const1_rtx);\n+  for (unsigned int i = 1; i < elt_size; ++i)\n+    builder.quick_push (const0_rtx);\n+  return builder.build ();\n+}\n+\n /* Return an all-true predicate register of mode MODE.  */\n \n rtx"}, {"sha": "3f802c79ee8cc9917bf3c4aa2c0a2514ffcbd277", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=34467289631e29545e14148515ab5f5d0d9e4fa7", "patch": "@@ -220,7 +220,7 @@\n     UNSPEC_LD1_GATHER\n     UNSPEC_ST1_SCATTER\n     UNSPEC_MERGE_PTRUE\n-    UNSPEC_PTEST_PTRUE\n+    UNSPEC_PTEST\n     UNSPEC_UNPACKSHI\n     UNSPEC_UNPACKUHI\n     UNSPEC_UNPACKSLO\n@@ -259,6 +259,15 @@\n   ]\n )\n \n+;; These constants are used as a const_int in various SVE unspecs\n+;; to indicate whether the governing predicate is known to be a PTRUE.\n+(define_constants\n+  [; Indicates that the predicate might not be a PTRUE.\n+   (SVE_MAYBE_NOT_PTRUE 0)\n+\n+   ; Indicates that the predicate is known to be a PTRUE.\n+   (SVE_KNOWN_PTRUE 1)])\n+\n ;; If further include files are added the defintion of MD_INCLUDES\n ;; must be updated.\n "}, {"sha": "f6ca6380b0525c3e99217b7f6b6579af7fa8dc1f", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=34467289631e29545e14148515ab5f5d0d9e4fa7", "patch": "@@ -1169,6 +1169,10 @@\n \t\t\t\t    (V4HF \"<Vetype>[%4]\") (V8HF \"<Vetype>[%4]\")\n \t\t\t\t    ])\n \n+;; The number of bytes controlled by a predicate\n+(define_mode_attr data_bytes [(VNx16BI \"1\") (VNx8BI \"2\")\n+\t\t\t      (VNx4BI \"4\") (VNx2BI \"8\")])\n+\n ;; -------------------------------------------------------------------\n ;; Code Iterators\n ;; -------------------------------------------------------------------"}, {"sha": "9038dfb71a19f345e8a842342657b9f1f94e4afb", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34467289631e29545e14148515ab5f5d0d9e4fa7/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=34467289631e29545e14148515ab5f5d0d9e4fa7", "patch": "@@ -684,6 +684,11 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_constant_vector_operand\")))\n \n+(define_predicate \"aarch64_sve_ptrue_flag\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"INTVAL (op) == SVE_MAYBE_NOT_PTRUE\")\n+\t    (match_test \"INTVAL (op) == SVE_KNOWN_PTRUE\"))))\n+\n (define_predicate \"aarch64_gather_scale_operand_w\"\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) == 1 || INTVAL (op) == 4\")))"}]}