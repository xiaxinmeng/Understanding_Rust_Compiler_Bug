{"sha": "03870a04825f25e05d8d466f133701de2988e56e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM4NzBhMDQ4MjVmMjVlMDVkOGQ0NjZmMTMzNzAxZGUyOTg4ZTU2ZQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2008-02-13T16:00:21Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2008-02-13T16:00:21Z"}, "message": "s390.c (struct constant_pool): New field emit_pool_after added.\n\n2008-02-13  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.c (struct constant_pool): New field\n\temit_pool_after added.\n\t(s390_mainpool_start): Set the emit_pool_after flag according\n\tto the section switch notes.\n\t(s390_mainpool_finish): Consider emit_pool_after when emitting\n\tthe literal pool at the end of the function.\n\t(s390_chunkify_start): Force literal pool splits at section\n\tswitch notes.\n\nFrom-SVN: r132287", "tree": {"sha": "7904f0bdd688985a0d9c5d00bfb84d8257975c7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7904f0bdd688985a0d9c5d00bfb84d8257975c7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03870a04825f25e05d8d466f133701de2988e56e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03870a04825f25e05d8d466f133701de2988e56e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03870a04825f25e05d8d466f133701de2988e56e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03870a04825f25e05d8d466f133701de2988e56e/comments", "author": null, "committer": null, "parents": [{"sha": "be71b673519ca207b2d8c1eeb5ec104587d55f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be71b673519ca207b2d8c1eeb5ec104587d55f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be71b673519ca207b2d8c1eeb5ec104587d55f9a"}], "stats": {"total": 84, "additions": 70, "deletions": 14}, "files": [{"sha": "d08725b0f212b6d7fd0f135d597a4e760b7cbfd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03870a04825f25e05d8d466f133701de2988e56e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03870a04825f25e05d8d466f133701de2988e56e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03870a04825f25e05d8d466f133701de2988e56e", "patch": "@@ -1,3 +1,14 @@\n+2008-02-13  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct constant_pool): New field\n+\temit_pool_after added.\n+\t(s390_mainpool_start): Set the emit_pool_after flag according\n+\tto the section switch notes.\n+\t(s390_mainpool_finish): Consider emit_pool_after when emitting\n+\tthe literal pool at the end of the function.\n+\t(s390_chunkify_start): Force literal pool splits at section\n+\tswitch notes.\n+\n 2008-02-13  Michael Matz  <matz@suse.de>\n \n \tPR debug/35065"}, {"sha": "2d90eef88cfdc0a678b0870a6fe0a5f5385a0ba6", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03870a04825f25e05d8d466f133701de2988e56e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03870a04825f25e05d8d466f133701de2988e56e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=03870a04825f25e05d8d466f133701de2988e56e", "patch": "@@ -5325,6 +5325,7 @@ struct constant_pool\n   rtx first_insn;\n   rtx pool_insn;\n   bitmap insns;\n+  rtx emit_pool_after;\n \n   struct constant *constants[NR_C_MODES];\n   struct constant *execute;\n@@ -5351,6 +5352,7 @@ s390_alloc_pool (void)\n   pool->pool_insn = NULL_RTX;\n   pool->insns = BITMAP_ALLOC (NULL);\n   pool->size = 0;\n+  pool->emit_pool_after = NULL_RTX;\n \n   return pool;\n }\n@@ -5681,6 +5683,7 @@ s390_mainpool_start (void)\n {\n   struct constant_pool *pool;\n   rtx insn;\n+  bool in_pool_section_p = false;\n \n   pool = s390_alloc_pool ();\n \n@@ -5693,6 +5696,7 @@ s390_mainpool_start (void)\n \t{\n \t  gcc_assert (!pool->pool_insn);\n \t  pool->pool_insn = insn;\n+\t  in_pool_section_p = true;\n \t}\n \n       if (!TARGET_CPU_ZARCH && s390_execute_label (insn))\n@@ -5710,6 +5714,20 @@ s390_mainpool_start (void)\n \t      s390_add_constant (pool, constant, mode);\n \t    }\n \t}\n+\n+      /* If hot/cold partitioning is enabled we have to make sure that\n+\t the literal pool is emitted in the same section where the\n+\t initialization of the literal pool base pointer takes place.\n+\t emit_pool_after is only used in the non-overflow case on non\n+\t Z cpus where we can emit the literal pool at the end of the\n+\t function body within the text section.  */\n+      if (NOTE_P (insn)\n+\t  && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n+\t{\n+\t  if (in_pool_section_p)\n+\t    pool->emit_pool_after = PREV_INSN (insn);\n+\t  in_pool_section_p = !in_pool_section_p;\n+\t}\n     }\n \n   gcc_assert (pool->pool_insn || pool->size == 0);\n@@ -5724,6 +5742,11 @@ s390_mainpool_start (void)\n       pool = NULL;\n     }\n \n+  /* If the functions ends with the section where the literal pool\n+     should be emitted set the marker to its end.  */\n+  if (pool && in_pool_section_p)\n+    pool->emit_pool_after = get_last_insn ();\n+\n   return pool;\n }\n \n@@ -5771,7 +5794,7 @@ s390_mainpool_finish (struct constant_pool *pool)\n   /* On S/390, if the total size of the function's code plus literal pool\n      does not exceed 4096 bytes, we use BASR to set up a function base\n      pointer, and emit the literal pool at the end of the function.  */\n-  else if (INSN_ADDRESSES (INSN_UID (get_last_insn ()))\n+  else if (INSN_ADDRESSES (INSN_UID (pool->emit_pool_after))\n \t   + pool->size + 8 /* alignment slop */ < 4096)\n     {\n       insn = gen_main_base_31_small (base_reg, pool->label);\n@@ -5782,7 +5805,11 @@ s390_mainpool_finish (struct constant_pool *pool)\n       insn = emit_label_after (pool->label, insn);\n       INSN_ADDRESSES_NEW (insn, -1);\n \n-      insn = get_last_insn ();\n+      /* emit_pool_after will be set by s390_mainpool_start to the\n+\t last insn of the section where the literal pool should be\n+\t emitted.  */\n+      insn = pool->emit_pool_after;\n+\n       pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n       INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n \n@@ -5881,6 +5908,8 @@ s390_chunkify_start (void)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n+      bool section_switch_p = false;\n+\n       /* Check for pending LTREL_BASE.  */\n       if (INSN_P (insn))\n \t{\n@@ -5935,6 +5964,9 @@ s390_chunkify_start (void)\n \t  gcc_assert (!pending_ltrel);\n \t}\n \n+      if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n+\tsection_switch_p = true;\n+\n       if (!curr_pool\n \t  || INSN_ADDRESSES_SIZE () <= (size_t) INSN_UID (insn)\n           || INSN_ADDRESSES (INSN_UID (insn)) == -1)\n@@ -5962,7 +5994,8 @@ s390_chunkify_start (void)\n \t    extra_size += 6;\n \n \t  if (chunk_size < S390_POOL_CHUNK_MIN\n-\t      && curr_pool->size < S390_POOL_CHUNK_MIN)\n+\t      && curr_pool->size < S390_POOL_CHUNK_MIN\n+\t      && !section_switch_p)\n \t    continue;\n \n \t  /* Pool chunks can only be inserted after BARRIERs ...  */\n@@ -5974,21 +6007,33 @@ s390_chunkify_start (void)\n \t    }\n \n \t  /* ... so if we don't find one in time, create one.  */\n-          else if ((chunk_size > S390_POOL_CHUNK_MAX\n-\t           || curr_pool->size > S390_POOL_CHUNK_MAX))\n+          else if (chunk_size > S390_POOL_CHUNK_MAX\n+\t           || curr_pool->size > S390_POOL_CHUNK_MAX\n+\t\t   || section_switch_p)\n \t    {\n               rtx label, jump, barrier;\n \n-\t      /* We can insert the barrier only after a 'real' insn.  */\n-\t      if (GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n-\t\tcontinue;\n-\t      if (get_attr_length (insn) == 0)\n-\t\tcontinue;\n-\n-\t      /* Don't separate LTREL_BASE from the corresponding\n+\t      if (!section_switch_p)\n+\t\t{\n+\t\t  /* We can insert the barrier only after a 'real' insn.  */\n+\t\t  if (GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n+\t\t    continue;\n+\t\t  if (get_attr_length (insn) == 0)\n+\t\t    continue;\n+\t\t  /* Don't separate LTREL_BASE from the corresponding\n \t\t LTREL_OFFSET load.  */\n-\t      if (pending_ltrel)\n-\t\tcontinue;\n+\t\t  if (pending_ltrel)\n+\t\t    continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (!pending_ltrel);\n+\n+\t\t  /* The old pool has to end before the section switch\n+\t\t     note in order to make it part of the current\n+\t\t     section.  */\n+\t\t  insn = PREV_INSN (insn);\n+\t\t}\n \n \t      label = gen_label_rtx ();\n \t      jump = emit_jump_insn_after (gen_jump (label), insn);"}]}