{"sha": "2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY1YjkxZjUyYWYyMDdkYmRkZDlkYTVhY2E1NGVlYjgyMDdmYjM3Yw==", "commit": {"author": {"name": "Shujing Zhao", "email": "pearly.zhao@oracle.com", "date": "2010-06-11T03:54:28Z"}, "committer": {"name": "Shujing Zhao", "email": "pzhao@gcc.gnu.org", "date": "2010-06-11T03:54:28Z"}, "message": "cp-tree.h (expr_list_kind): New type.\n\n2010-06-11  Shujing Zhao  <pearly.zhao@oracle.com>\n\n        * cp-tree.h (expr_list_kind): New type.\n        (impl_conv_rhs): New type.\n        (build_x_compound_expr_from_list, convert_for_initialization): Adjust\n        prototype.\n        (typeck.c (convert_arguments): Use impl_conv_rhs and emit the\n        diagnostics for easy translation. Change caller.\n        (convert_for_initialization): Use impl_conv_rhs and change caller.\n        (build_x_compound_expr_from_list): Use expr_list_kind and emit the\n        diagnostics for easy translation. Change caller.\n        * decl.c (bad_spec_place): New enum.\n        (bad_specifiers): Use it and emit the diagnostics for easy\n        translation. Change caller.\n        * pt.c (coerce_template_parms): Put the diagnostics in full sentence.\n\nFrom-SVN: r160591", "tree": {"sha": "1135234233cb1f6f8a89c523354f82322391101d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1135234233cb1f6f8a89c523354f82322391101d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/comments", "author": null, "committer": null, "parents": [{"sha": "66051b6074a5641299738aa1d698fc63175ca0de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66051b6074a5641299738aa1d698fc63175ca0de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66051b6074a5641299738aa1d698fc63175ca0de"}], "stats": {"total": 282, "additions": 217, "deletions": 65}, "files": [{"sha": "75a76005b929eda02c0f54afc9710c64870bc6dd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -1,3 +1,19 @@\n+2010-06-11  Shujing Zhao  <pearly.zhao@oracle.com>\n+\n+\t* cp-tree.h (expr_list_kind): New type.\n+\t(impl_conv_rhs): New type.\n+\t(build_x_compound_expr_from_list, convert_for_initialization): Adjust\n+\tprototype.\n+\t(typeck.c (convert_arguments): Use impl_conv_rhs and emit the\n+\tdiagnostics for easy translation. Change caller.\n+\t(convert_for_initialization): Use impl_conv_rhs and change caller.\n+\t(build_x_compound_expr_from_list): Use expr_list_kind and emit the\n+\tdiagnostics for easy translation. Change caller.\n+\t* decl.c (bad_spec_place): New enum.\n+\t(bad_specifiers): Use it and emit the diagnostics for easy\n+\ttranslation. Change caller.\n+\t* pt.c (coerce_template_parms): Put the diagnostics in full sentence.\n+\n 2010-06-09  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* cp-tree.h (struct saved_scope): Change decl_ns_list field type\n@@ -1736,3 +1752,4 @@ Copyright (C) 2010 Free Software Foundation, Inc.\n Copying and distribution of this file, with or without modification,\n are permitted in any medium without royalty provided the copyright\n notice and this notice are preserved.\n+"}, {"sha": "f46fbf7bce741f2ed9b1598d7d413c72accf78cc", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -5387,7 +5387,7 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n     {\n       arg = digest_init (type, arg);\n       arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n-\t\t\t\t\t\"default argument\", fn, parmnum,\n+\t\t\t\t\tICR_DEFAULT_ARGUMENT, fn, parmnum,\n                                         tf_warning_or_error);\n     }\n   else\n@@ -5401,7 +5401,7 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n       if (!CONSTANT_CLASS_P (arg))\n \targ = unshare_expr (arg);\n       arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n-\t\t\t\t\t\"default argument\", fn, parmnum,\n+\t\t\t\t\tICR_DEFAULT_ARGUMENT, fn, parmnum,\n                                         tf_warning_or_error);\n       arg = convert_for_arg_passing (type, arg);\n     }"}, {"sha": "b71f8af0a0cb215f613d64902a640315c7cfc601", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -418,6 +418,23 @@ typedef enum readonly_error_kind\n   REK_DECREMENT\n } readonly_error_kind;\n \n+/* Possible cases of expression list used by build_x_compound_expr_from_list. */\n+typedef enum expr_list_kind {\n+  ELK_INIT,\t\t/* initializer */\n+  ELK_MEM_INIT,\t\t/* member initializer */\n+  ELK_FUNC_CAST\t\t/* functional cast */\n+} expr_list_kind; \n+\n+/* Possible cases of implicit bad rhs conversions. */\n+typedef enum impl_conv_rhs {\n+  ICR_DEFAULT_ARGUMENT, /* default argument */\n+  ICR_CONVERTING,       /* converting */\n+  ICR_INIT,             /* initialization */\n+  ICR_ARGPASS,          /* argument passing */\n+  ICR_RETURN,           /* return */\n+  ICR_ASSIGN            /* assignment */\n+} impl_conv_rhs;\n+\n /* Macros for access to language-specific slots in an identifier.  */\n \n #define IDENTIFIER_NAMESPACE_BINDINGS(NODE)\t\\\n@@ -5400,7 +5417,7 @@ extern tree cp_build_unary_op                   (enum tree_code, tree, int,\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);\n extern tree build_x_conditional_expr\t\t(tree, tree, tree, \n                                                  tsubst_flags_t);\n-extern tree build_x_compound_expr_from_list\t(tree, const char *);\n+extern tree build_x_compound_expr_from_list\t(tree, expr_list_kind);\n extern tree build_x_compound_expr_from_vec\t(VEC(tree,gc) *, const char *);\n extern tree build_x_compound_expr\t\t(tree, tree, tsubst_flags_t);\n extern tree build_compound_expr                 (location_t, tree, tree);\n@@ -5415,7 +5432,7 @@ extern tree build_x_modify_expr\t\t\t(tree, enum tree_code, tree,\n extern tree cp_build_modify_expr\t\t(tree, enum tree_code, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree convert_for_initialization\t\t(tree, tree, tree, int,\n-\t\t\t\t\t\t const char *, tree, int,\n+\t\t\t\t\t\t impl_conv_rhs, tree, int,\n                                                  tsubst_flags_t);\n extern int comp_ptr_ttypes\t\t\t(tree, tree);\n extern bool comp_ptr_ttypes_const\t\t(tree, tree);"}, {"sha": "40a635153bcccb10e04fe706cb564052ba5b84b9", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -481,7 +481,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   else\n     {\n       rval = convert_for_initialization (NULL_TREE, type, expr, flags,\n-\t\t\t\t\t \"converting\", 0, 0,\n+\t\t\t\t\t ICR_CONVERTING, 0, 0,\n                                          tf_warning_or_error);\n       if (rval == NULL_TREE || rval == error_mark_node)\n \treturn rval;"}, {"sha": "3108f9d03632275d5693c385c836e56ee567310b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -56,6 +56,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"splay-tree.h\"\n #include \"plugin.h\"\n \n+/* Possible cases of bad specifiers type used by bad_specifiers. */\n+enum bad_spec_place {\n+  BSP_VAR,    /* variable */\n+  BSP_PARM,   /* parameter */\n+  BSP_TYPE,   /* type */\n+  BSP_FIELD   /* field */\n+};\n+\n static tree grokparms (tree parmlist, tree *);\n static const char *redeclaration_error_message (tree, tree);\n \n@@ -71,7 +79,7 @@ static void record_unknown_type (tree, const char *);\n static tree builtin_function_1 (tree, tree, bool);\n static tree build_library_fn_1 (tree, enum tree_code, tree);\n static int member_function_or_else (tree, tree, enum overload_flags);\n-static void bad_specifiers (tree, const char *, int, int, int, int,\n+static void bad_specifiers (tree, enum bad_spec_place, int, int, int, int,\n \t\t\t    int);\n static void check_for_uninitialized_const_var (tree);\n static hashval_t typename_hash (const void *);\n@@ -4450,7 +4458,7 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n     }\n \n   if (TREE_CODE (init) == TREE_LIST)\n-    init = build_x_compound_expr_from_list (init, \"initializer\");\n+    init = build_x_compound_expr_from_list (init, ELK_INIT);\n \n   if (TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)\n@@ -5671,7 +5679,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t  return;\n \t}\n       if (TREE_CODE (init) == TREE_LIST)\n-\tinit = build_x_compound_expr_from_list (init, \"initializer\");\n+\tinit = build_x_compound_expr_from_list (init, ELK_INIT);\n       if (describable_type (init))\n \t{\n \t  type = TREE_TYPE (decl) = do_auto_deduction (type, init, auto_node);\n@@ -6592,21 +6600,54 @@ member_function_or_else (tree ctype, tree cur_type, enum overload_flags flags)\n \n static void\n bad_specifiers (tree object,\n-\t\tconst char* type,\n+\t\tenum bad_spec_place type,\n \t\tint virtualp,\n \t\tint quals,\n \t\tint inlinep,\n \t\tint friendp,\n \t\tint raises)\n {\n-  if (virtualp)\n-    error (\"%qD declared as a %<virtual%> %s\", object, type);\n-  if (inlinep)\n-    error (\"%qD declared as an %<inline%> %s\", object, type);\n-  if (quals)\n-    error (\"%<const%> and %<volatile%> function specifiers on \"\n-\t   \"%qD invalid in %s declaration\",\n-\t   object, type);\n+  switch (type)\n+    {\n+      case BSP_VAR:\n+\tif (virtualp)\n+\t  error (\"%qD declared as a %<virtual%> variable\", object);\n+\tif (inlinep)\n+\t  error (\"%qD declared as an %<inline%> variable\", object);\n+\tif (quals)\n+\t  error (\"%<const%> and %<volatile%> function specifiers on \"\n+\t         \"%qD invalid in variable declaration\", object);\n+\tbreak;\n+      case BSP_PARM:\n+\tif (virtualp)\n+\t  error (\"%qD declared as a %<virtual%> parameter\", object);\n+\tif (inlinep)\n+\t  error (\"%qD declared as an %<inline%> parameter\", object);\n+\tif (quals)\n+\t  error (\"%<const%> and %<volatile%> function specifiers on \"\n+\t  \t \"%qD invalid in parameter declaration\", object);\n+\tbreak;\n+      case BSP_TYPE:\n+\tif (virtualp)\n+\t  error (\"%qD declared as a %<virtual%> type\", object);\n+\tif (inlinep)\n+\t  error (\"%qD declared as an %<inline%> type\", object);\n+\tif (quals)\n+\t  error (\"%<const%> and %<volatile%> function specifiers on \"\n+\t  \t \"%qD invalid in type declaration\", object);\n+\tbreak;\n+      case BSP_FIELD:\n+\tif (virtualp)\n+\t  error (\"%qD declared as a %<virtual%> field\", object);\n+\tif (inlinep)\n+\t  error (\"%qD declared as an %<inline%> field\", object);\n+\tif (quals)\n+\t  error (\"%<const%> and %<volatile%> function specifiers on \"\n+\t  \t \"%qD invalid in field declaration\", object);\n+\tbreak;\n+      default:\n+        gcc_unreachable();\n+    }\n   if (friendp)\n     error (\"%q+D declared as a friend\", object);\n   if (raises\n@@ -9128,7 +9169,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n \n-      bad_specifiers (decl, \"type\", virtualp,\n+      bad_specifiers (decl, BSP_TYPE, virtualp,\n \t\t      memfn_quals != TYPE_UNQUALIFIED,\n \t\t      inlinep, friendp, raises != NULL_TREE);\n \n@@ -9314,7 +9355,7 @@ grokdeclarator (const cp_declarator *declarator,\n       {\n \tdecl = cp_build_parm_decl (unqualified_id, type);\n \n-\tbad_specifiers (decl, \"parameter\", virtualp,\n+\tbad_specifiers (decl, BSP_PARM, virtualp,\n \t\t\tmemfn_quals != TYPE_UNQUALIFIED,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n       }\n@@ -9592,7 +9633,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \t      }\n \n-\t    bad_specifiers (decl, \"field\", virtualp,\n+\t    bad_specifiers (decl, BSP_FIELD, virtualp,\n \t\t\t    memfn_quals != TYPE_UNQUALIFIED,\n \t\t\t    inlinep, friendp, raises != NULL_TREE);\n \t  }\n@@ -9715,7 +9756,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t    initialized,\n \t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n \t\t\t    ctype ? ctype : in_namespace);\n-\tbad_specifiers (decl, \"variable\", virtualp,\n+\tbad_specifiers (decl, BSP_VAR, virtualp,\n \t\t\tmemfn_quals != TYPE_UNQUALIFIED,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n "}, {"sha": "84e486cea466f78e9ce45b7c7881369d8f5adf04", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -526,7 +526,7 @@ perform_member_init (tree member, tree init)\n       else if (TREE_CODE (init) == TREE_LIST)\n \t/* There was an explicit member initialization.  Do some work\n \t   in that case.  */\n-\tinit = build_x_compound_expr_from_list (init, \"member initializer\");\n+\tinit = build_x_compound_expr_from_list (init, ELK_MEM_INIT);\n \n       if (init)\n \tfinish_expr_stmt (cp_build_modify_expr (decl, INIT_EXPR, init,"}, {"sha": "55ea5397d8ae14025d9288e6a101e2f6cb447616", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -5921,15 +5921,15 @@ coerce_template_parms (tree parms,\n     {\n       if (complain & tf_error)\n \t{\n-          const char *or_more = \"\";\n           if (variadic_p)\n             {\n-              or_more = \" or more\";\n               --nparms;\n+\t      error (\"wrong number of template arguments \"\n+\t\t     \"(%d, should be %d or more)\", nargs, nparms);\n             }\n-\n-\t  error (\"wrong number of template arguments (%d, should be %d%s)\",\n-                 nargs, nparms, or_more);\n+\t  else\n+\t     error (\"wrong number of template arguments \"\n+\t\t    \"(%d, should be %d)\", nargs, nparms);\n \n \t  if (in_decl)\n \t    error (\"provided for %q+D\", in_decl);"}, {"sha": "75448d56f1501474e4dde7aa70203f2a568ca83b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 108, "deletions": 30, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static tree pfn_from_ptrmemfunc (tree);\n static tree delta_from_ptrmemfunc (tree);\n-static tree convert_for_assignment (tree, tree, const char *, tree, int,\n+static tree convert_for_assignment (tree, tree, impl_conv_rhs, tree, int,\n \t\t\t\t    tsubst_flags_t, int);\n static tree cp_pointer_int_sum (enum tree_code, tree, tree);\n static tree rationalize_conditional_expr (enum tree_code, tree, \n@@ -3493,7 +3493,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t    {\n \t      parmval = convert_for_initialization\n \t\t(NULL_TREE, type, val, flags,\n-\t\t \"argument passing\", fndecl, i, complain);\n+\t\t ICR_ARGPASS, fndecl, i, complain);\n \t      parmval = convert_for_arg_passing (type, parmval);\n \t    }\n \n@@ -5486,14 +5486,30 @@ build_x_conditional_expr (tree ifexp, tree op1, tree op2,\n /* Given a list of expressions, return a compound expression\n    that performs them all and returns the value of the last of them.  */\n \n-tree build_x_compound_expr_from_list (tree list, const char *msg)\n+tree\n+build_x_compound_expr_from_list (tree list, expr_list_kind exp)\n {\n   tree expr = TREE_VALUE (list);\n \n   if (TREE_CHAIN (list))\n     {\n-      if (msg)\n-\tpermerror (input_location, \"%s expression list treated as compound expression\", msg);\n+      switch (exp)\n+\t{\n+\t  case ELK_INIT:\n+\t    permerror (input_location, \"expression list treated as compound \"\n+\t\t\t\t       \"expression in initializer\");\n+\t    break;\n+\t  case ELK_MEM_INIT:\n+\t    permerror (input_location, \"expression list treated as compound \"\n+\t\t\t\t       \"expression in mem-initializer\");\n+\t    break;\n+\t  case ELK_FUNC_CAST:\n+\t    permerror (input_location, \"expression list treated as compound \"\n+\t\t\t\t       \"expression in functional cast\");\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n \n       for (list = TREE_CHAIN (list); list; list = TREE_CHAIN (list))\n \texpr = build_x_compound_expr (expr, TREE_VALUE (list), \n@@ -6767,10 +6783,10 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n     /* Calls with INIT_EXPR are all direct-initialization, so don't set\n        LOOKUP_ONLYCONVERTING.  */\n     newrhs = convert_for_initialization (lhs, olhstype, newrhs, LOOKUP_NORMAL,\n-\t\t\t\t\t \"initialization\", NULL_TREE, 0,\n+\t\t\t\t\t ICR_INIT, NULL_TREE, 0,\n                                          complain);\n   else\n-    newrhs = convert_for_assignment (olhstype, newrhs, \"assignment\",\n+    newrhs = convert_for_assignment (olhstype, newrhs, ICR_ASSIGN,\n \t\t\t\t     NULL_TREE, 0, complain, LOOKUP_IMPLICIT);\n \n   if (!same_type_p (lhstype, olhstype))\n@@ -7177,7 +7193,7 @@ delta_from_ptrmemfunc (tree t)\n \n static tree\n convert_for_assignment (tree type, tree rhs,\n-\t\t\tconst char *errtype, tree fndecl, int parmnum,\n+\t\t\timpl_conv_rhs errtype, tree fndecl, int parmnum,\n \t\t\ttsubst_flags_t complain, int flags)\n {\n   tree rhstype;\n@@ -7214,23 +7230,25 @@ convert_for_assignment (tree type, tree rhs,\n   if (c_dialect_objc ())\n     {\n       int parmno;\n+      tree selector;\n       tree rname = fndecl;\n \n-      if (!strcmp (errtype, \"assignment\"))\n-\tparmno = -1;\n-      else if (!strcmp (errtype, \"initialization\"))\n-\tparmno = -2;\n-      else\n-\t{\n-\t  tree selector = objc_message_selector ();\n-\n-\t  parmno = parmnum;\n-\n-\t  if (selector && parmno > 1)\n-\t    {\n-\t      rname = selector;\n-\t      parmno -= 1;\n-\t    }\n+      switch (errtype)\n+        {\n+\t  case ICR_ASSIGN:\n+\t    parmno = -1;\n+\t    break;\n+\t  case ICR_INIT:\n+\t    parmno = -2;\n+\t    break;\n+\t  default:\n+\t    selector = objc_message_selector ();\n+\t    parmno = parmnum;\n+\t    if (selector && parmno > 1)\n+\t      {\n+\t\trname = selector;\n+\t\tparmno -= 1;\n+\t      }\n \t}\n \n       if (objc_compare_types (type, rhstype, parmno, rname))\n@@ -7267,8 +7285,35 @@ convert_for_assignment (tree type, tree rhs,\n \t\terror (\"cannot convert %qT to %qT for argument %qP to %qD\",\n \t\t       rhstype, type, parmnum, fndecl);\n \t      else\n-\t\terror (\"cannot convert %qT to %qT in %s\", rhstype, type,\n-\t\t       errtype);\n+\t\tswitch (errtype)\n+\t\t  {\n+\t\t    case ICR_DEFAULT_ARGUMENT:\n+\t\t      error (\"cannot convert %qT to %qT in default argument\",\n+\t\t\t     rhstype, type);\n+\t\t      break;\n+\t\t    case ICR_ARGPASS:\n+\t\t      error (\"cannot convert %qT to %qT in argument passing\",\n+\t\t\t     rhstype, type);\n+\t\t      break;\n+\t\t    case ICR_CONVERTING:\n+\t\t      error (\"cannot convert %qT to %qT\",\n+\t\t\t     rhstype, type);\n+\t\t      break;\n+\t\t    case ICR_INIT:\n+\t\t      error (\"cannot convert %qT to %qT in initialization\",\n+\t\t\t     rhstype, type);\n+\t\t      break;\n+\t\t    case ICR_RETURN:\n+\t\t      error (\"cannot convert %qT to %qT in return\",\n+\t\t\t     rhstype, type);\n+\t\t      break;\n+\t\t    case ICR_ASSIGN:\n+\t\t      error (\"cannot convert %qT to %qT in assignment\",\n+\t\t\t     rhstype, type);\n+\t\t      break;\n+\t\t    default:\n+\t\t      gcc_unreachable();\n+\t\t  }\n \t    }\n \t  return error_mark_node;\n \t}\n@@ -7280,9 +7325,42 @@ convert_for_assignment (tree type, tree rhs,\n \t  && coder == codel\n \t  && check_missing_format_attribute (type, rhstype)\n \t  && (complain & tf_warning))\n-\twarning (OPT_Wmissing_format_attribute,\n-\t\t \"%s might be a candidate for a format attribute\",\n-\t\t errtype);\n+\tswitch (errtype)\n+\t  {\n+\t    case ICR_ARGPASS:\n+\t    case ICR_DEFAULT_ARGUMENT:\n+\t      if (fndecl)\n+\t\twarning (OPT_Wmissing_format_attribute,\n+\t\t\t \"parameter %d of %qD might be a candidate \"\n+\t\t\t \"for a format attribute\", parmnum, fndecl);\n+\t      else\n+\t\twarning (OPT_Wmissing_format_attribute,\n+\t\t\t \"parameter might be a candidate \"\n+\t\t\t \"for a format attribute\");\n+\t      break;\n+\t    case ICR_CONVERTING:\n+\t      warning (OPT_Wmissing_format_attribute,\n+\t\t       \"target of conversion might be might be a candidate \"\n+\t\t       \"for a format attribute\");\n+\t      break;\n+\t    case ICR_INIT:\n+\t      warning (OPT_Wmissing_format_attribute,\n+\t\t       \"target of initialization might be a candidate \"\n+\t\t       \"for a format attribute\");\n+\t      break;\n+\t    case ICR_RETURN:\n+\t      warning (OPT_Wmissing_format_attribute,\n+\t\t       \"return type might be a candidate \"\n+\t\t       \"for a format attribute\");\n+\t      break;\n+\t    case ICR_ASSIGN:\n+\t      warning (OPT_Wmissing_format_attribute,\n+\t\t       \"left-hand side of assignment might be a candidate \"\n+\t\t       \"for a format attribute\");\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable();\n+\t  }\n     }\n \n   /* If -Wparentheses, warn about a = b = c when a has type bool and b\n@@ -7324,7 +7402,7 @@ convert_for_assignment (tree type, tree rhs,\n \n tree\n convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n-\t\t\t    const char *errtype, tree fndecl, int parmnum,\n+\t\t\t    impl_conv_rhs errtype, tree fndecl, int parmnum,\n                             tsubst_flags_t complain)\n {\n   enum tree_code codel = TREE_CODE (type);\n@@ -7715,7 +7793,7 @@ check_return_expr (tree retval, bool *no_warning)\n \t to the type of return value's location to handle the\n \t case that functype is smaller than the valtype.  */\n       retval = convert_for_initialization\n-\t(NULL_TREE, functype, retval, flags, \"return\", NULL_TREE, 0,\n+\t(NULL_TREE, functype, retval, flags, ICR_RETURN, NULL_TREE, 0,\n          tf_warning_or_error);\n       retval = convert (valtype, retval);\n "}, {"sha": "2cc398628975369cc02fef7f85d5fd04b94f2255", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5b91f52af207dbddd9da5aca54eeb8207fb37c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=2f5b91f52af207dbddd9da5aca54eeb8207fb37c", "patch": "@@ -727,18 +727,17 @@ store_init_value (tree decl, tree init, int flags)\n   else if (TREE_CODE (init) == TREE_LIST\n \t   && TREE_TYPE (init) != unknown_type_node)\n     {\n-      if (TREE_CODE (decl) == RESULT_DECL)\n-\tinit = build_x_compound_expr_from_list (init,\n-\t\t\t\t\t\t\"return value initializer\");\n-      else if (TREE_CODE (init) == TREE_LIST\n+      gcc_assert (TREE_CODE (decl) != RESULT_DECL);\n+\n+      if (TREE_CODE (init) == TREE_LIST\n \t       && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t{\n \t  error (\"cannot initialize arrays using this syntax\");\n \t  return NULL_TREE;\n \t}\n       else\n \t/* We get here with code like `int a (2);' */\n-\tinit = build_x_compound_expr_from_list (init, \"initializer\");\n+\tinit = build_x_compound_expr_from_list (init, ELK_INIT);\n     }\n \n   /* End of special C++ code.  */\n@@ -909,7 +908,7 @@ digest_init_r (tree type, tree init, bool nested, int flags)\n       if (cxx_dialect != cxx98 && nested)\n \tcheck_narrowing (type, init);\n       init = convert_for_initialization (0, type, init, flags,\n-\t\t\t\t\t \"initialization\", NULL_TREE, 0,\n+\t\t\t\t\t ICR_INIT, NULL_TREE, 0,\n \t\t\t\t\t tf_warning_or_error);\n       exp = &init;\n \n@@ -963,7 +962,7 @@ digest_init_r (tree type, tree init, bool nested, int flags)\n \n       return convert_for_initialization (NULL_TREE, type, init,\n \t\t\t\t\t flags,\n-\t\t\t\t\t \"initialization\", NULL_TREE, 0,\n+\t\t\t\t\t ICR_INIT, NULL_TREE, 0,\n                                          tf_warning_or_error);\n     }\n }\n@@ -1596,7 +1595,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n \treturn cp_convert (type, integer_zero_node);\n \n       /* This must build a C cast.  */\n-      parms = build_x_compound_expr_from_list (parms, \"functional cast\");\n+      parms = build_x_compound_expr_from_list (parms, ELK_FUNC_CAST);\n       return cp_build_c_cast (type, parms, complain);\n     }\n "}]}