{"sha": "471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcxZWViODMwZDFmNGE3YzYwN2M3OGRjOWQyY2QzYTFkMmU3YzMxZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-12-17T07:18:35Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-12-17T07:18:35Z"}, "message": "tree-ssa-dom.c (update_rhs_and_lookup_avail_expr): Kill.\n\n\n\t* tree-ssa-dom.c (update_rhs_and_lookup_avail_expr): Kill.\n\t(simplify_rhs_and_lookup_avail_expr): Kill.  Remnants moved\n\tinto tree-ssa-forwprop.c.\n\t(eliminate_redundant_computations): Do not call\n\tsimplify_rhs_and_lookup_avail_expr anymore.\n\t* tree-ssa-forwprop.c (simplify_not_neg_expr): New function\n\textracted from remnants of simplify_rhs_and_lookup_avail_expr.\n\t(tree_ssa_forward_propagate_single_use_vars): Call\n\tsimplify_not_neg_expr appropriately.\n\nFrom-SVN: r108711", "tree": {"sha": "c5d222b408cbc0d7028d89b276a0d1febbc93f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5d222b408cbc0d7028d89b276a0d1febbc93f9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d/comments", "author": null, "committer": null, "parents": [{"sha": "b15e733f3c23987afbac235247d68fd1fd84b668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15e733f3c23987afbac235247d68fd1fd84b668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b15e733f3c23987afbac235247d68fd1fd84b668"}], "stats": {"total": 194, "additions": 75, "deletions": 119}, "files": [{"sha": "24902912746f9ac981c1bb35e9f845516a819d66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d", "patch": "@@ -1,3 +1,15 @@\n+2005-12-16  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (update_rhs_and_lookup_avail_expr): Kill.\n+\t(simplify_rhs_and_lookup_avail_expr): Kill.  Remnants moved\n+\tinto tree-ssa-forwprop.c.\n+\t(eliminate_redundant_computations): Do not call\n+\tsimplify_rhs_and_lookup_avail_expr anymore.\n+\t* tree-ssa-forwprop.c (simplify_not_neg_expr): New function\n+\textracted from remnants of simplify_rhs_and_lookup_avail_expr.\n+\t(tree_ssa_forward_propagate_single_use_vars): Call\n+\tsimplify_not_neg_expr appropriately.\n+\n 2005-12-16  Bernd Trog  <berndtrog@yahoo.com>\n \n \tPR target/20016"}, {"sha": "8e4a1995471728127bf3549d74fbce1586b279ae", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 114, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d", "patch": "@@ -273,8 +273,6 @@ static void htab_statistics (FILE *, htab_t);\n static void record_cond (tree, tree);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n-static tree update_rhs_and_lookup_avail_expr (tree, tree, bool);\n-static tree simplify_rhs_and_lookup_avail_expr (tree, int);\n static tree simplify_cond_and_lookup_avail_expr (tree, stmt_ann_t, int);\n static tree simplify_switch_and_lookup_avail_expr (tree, int);\n static tree find_equivalent_equality_comparison (tree);\n@@ -1795,51 +1793,6 @@ simple_iv_increment_p (tree stmt)\n   return false;\n }\n \n-/* STMT is a MODIFY_EXPR for which we were unable to find RHS in the\n-   hash tables.  Try to simplify the RHS using whatever equivalences\n-   we may have recorded.\n-\n-   If we are able to simplify the RHS, then lookup the simplified form in\n-   the hash table and return the result.  Otherwise return NULL.  */\n-\n-static tree\n-simplify_rhs_and_lookup_avail_expr (tree stmt, int insert)\n-{\n-  tree rhs = TREE_OPERAND (stmt, 1);\n-  enum tree_code rhs_code = TREE_CODE (rhs);\n-  tree result = NULL;\n-\n-  /* If we have lhs = ~x, look and see if we earlier had x = ~y.\n-     In which case we can change this statement to be lhs = y.\n-     Which can then be copy propagated. \n-\n-     Similarly for negation.  */\n-  if ((rhs_code == BIT_NOT_EXPR || rhs_code == NEGATE_EXPR)\n-      && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n-    {\n-      /* Get the definition statement for our RHS.  */\n-      tree rhs_def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n-\n-      /* See if the RHS_DEF_STMT has the same form as our statement.  */\n-      if (TREE_CODE (rhs_def_stmt) == MODIFY_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (rhs_def_stmt, 1)) == rhs_code)\n-\t{\n-\t  tree rhs_def_operand;\n-\n-\t  rhs_def_operand = TREE_OPERAND (TREE_OPERAND (rhs_def_stmt, 1), 0);\n-\n-\t  /* Verify that RHS_DEF_OPERAND is a suitable SSA variable.  */\n-\t  if (TREE_CODE (rhs_def_operand) == SSA_NAME\n-\t      && ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs_def_operand))\n-\t    result = update_rhs_and_lookup_avail_expr (stmt,\n-\t\t\t\t\t\t       rhs_def_operand,\n-\t\t\t\t\t\t       insert);\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n /* COND is a condition of the form:\n \n      x == const or x != const\n@@ -2516,15 +2469,9 @@ eliminate_redundant_computations (tree stmt, stmt_ann_t ann)\n   /* Check if the expression has been computed before.  */\n   cached_lhs = lookup_avail_expr (stmt, insert);\n \n-  /* If this is an assignment and the RHS was not in the hash table,\n-     then try to simplify the RHS and lookup the new RHS in the\n-     hash table.  */\n-  if (! cached_lhs && TREE_CODE (stmt) == MODIFY_EXPR)\n-    cached_lhs = simplify_rhs_and_lookup_avail_expr (stmt, insert);\n-  /* Similarly if this is a COND_EXPR and we did not find its\n-     expression in the hash table, simplify the condition and\n-     try again.  */\n-  else if (! cached_lhs && TREE_CODE (stmt) == COND_EXPR)\n+  /* If this is a COND_EXPR and we did not find its expression in\n+     the hash table, simplify the condition and try again.  */\n+  if (! cached_lhs && TREE_CODE (stmt) == COND_EXPR)\n     cached_lhs = simplify_cond_and_lookup_avail_expr (stmt, ann, insert);\n   /* Similarly for a SWITCH_EXPR.  */\n   else if (!cached_lhs && TREE_CODE (stmt) == SWITCH_EXPR)\n@@ -2991,64 +2938,6 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     VEC_safe_push (tree, heap, stmts_to_rescan, bsi_stmt (si));\n }\n \n-/* Replace the RHS of STMT with NEW_RHS.  If RHS can be found in the\n-   available expression hashtable, then return the LHS from the hash\n-   table.\n-\n-   If INSERT is true, then we also update the available expression\n-   hash table to account for the changes made to STMT.  */\n-\n-static tree\n-update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs, bool insert)\n-{\n-  tree cached_lhs = NULL;\n-\n-  /* Remove the old entry from the hash table.  */\n-  if (insert)\n-    {\n-      struct expr_hash_elt element;\n-\n-      initialize_hash_element (stmt, NULL, &element);\n-      htab_remove_elt_with_hash (avail_exprs, &element, element.hash);\n-    }\n-\n-  /* Now update the RHS of the assignment.  */\n-  TREE_OPERAND (stmt, 1) = new_rhs;\n-\n-  /* Now lookup the updated statement in the hash table.  */\n-  cached_lhs = lookup_avail_expr (stmt, insert);\n-\n-  /* We have now called lookup_avail_expr twice with two different\n-     versions of this same statement, once in optimize_stmt, once here.\n-\n-     We know the call in optimize_stmt did not find an existing entry\n-     in the hash table, so a new entry was created.  At the same time\n-     this statement was pushed onto the AVAIL_EXPRS_STACK vector. \n-\n-     If this call failed to find an existing entry on the hash table,\n-     then the new version of this statement was entered into the\n-     hash table.  And this statement was pushed onto BLOCK_AVAIL_EXPR\n-     for the second time.  So there are two copies on BLOCK_AVAIL_EXPRs\n-\n-     If this call succeeded, we still have one copy of this statement\n-     on the BLOCK_AVAIL_EXPRs vector.\n-\n-     For both cases, we need to pop the most recent entry off the\n-     BLOCK_AVAIL_EXPRs vector.  For the case where we never found this\n-     statement in the hash tables, that will leave precisely one\n-     copy of this statement on BLOCK_AVAIL_EXPRs.  For the case where\n-     we found a copy of this statement in the second hash table lookup\n-     we want _no_ copies of this statement in BLOCK_AVAIL_EXPRs.  */\n-  if (insert)\n-    VEC_pop (tree, avail_exprs_stack);\n-\n-  /* And make sure we record the fact that we modified this\n-     statement.  */\n-  mark_stmt_modified (stmt);\n-\n-  return cached_lhs;\n-}\n-\n /* Search for an existing instance of STMT in the AVAIL_EXPRS table.  If\n    found, return its LHS. Otherwise insert STMT in the table and return\n    NULL_TREE."}, {"sha": "e3978d8c2a24e49022c4b938e17dd689a00b523d", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=471eeb830d1f4a7c607c78dc9d2cd3a1d2e7c31d", "patch": "@@ -703,6 +703,41 @@ forward_propagate_addr_expr (tree stmt)\n   return all;\n }\n \n+/* If we have lhs = ~x (STMT), look and see if earlier we had x = ~y.\n+   If so, we can change STMT into lhs = y which can later be copy\n+   propagated.  Similarly for negation. \n+\n+   This could trivially be formulated as a forward propagation \n+   to immediate uses.  However, we already had an implementation\n+   from DOM which used backward propagation via the use-def links.\n+\n+   It turns out that backward propagation is actually faster as\n+   there's less work to do for each NOT/NEG expression we find.\n+   Backwards propagation needs to look at the statement in a single\n+   backlink.  Forward propagation needs to look at potentially more\n+   than one forward link.  */\n+\n+static void\n+simplify_not_neg_expr (tree stmt)\n+{\n+  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree rhs_def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n+\n+  /* See if the RHS_DEF_STMT has the same form as our statement.  */\n+  if (TREE_CODE (rhs_def_stmt) == MODIFY_EXPR\n+      && TREE_CODE (TREE_OPERAND (rhs_def_stmt, 1)) == TREE_CODE (rhs))\n+    {\n+      tree rhs_def_operand = TREE_OPERAND (TREE_OPERAND (rhs_def_stmt, 1), 0);\n+\n+      /* Verify that RHS_DEF_OPERAND is a suitable SSA_NAME.  */\n+      if (TREE_CODE (rhs_def_operand) == SSA_NAME\n+\t  && ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs_def_operand))\n+\t{\n+\t  TREE_OPERAND (stmt, 1) = rhs_def_operand;\n+\t  update_stmt (stmt);\n+\t}\n+    }\n+}\n \n /* Main entry point for the forward propagation optimizer.  */\n \n@@ -724,12 +759,32 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \n \t  /* If this statement sets an SSA_NAME to an address,\n \t     try to propagate the address into the uses of the SSA_NAME.  */\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME)\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n \t    {\n-\t      if (forward_propagate_addr_expr (stmt))\n-\t\tbsi_remove (&bsi);\n+\t      tree lhs = TREE_OPERAND (stmt, 0);\n+\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\n+\n+\t      if (TREE_CODE (lhs) != SSA_NAME)\n+\t\t{\n+\t\t  bsi_next (&bsi);\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t\t{\n+\t\t  if (forward_propagate_addr_expr (stmt))\n+\t\t    bsi_remove (&bsi);\n+\t\t  else\n+\t\t    bsi_next (&bsi);\n+\t\t}\n+\t      else if ((TREE_CODE (rhs) == BIT_NOT_EXPR\n+\t\t        || TREE_CODE (rhs) == NEGATE_EXPR)\n+\t\t       && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n+\t\t{\n+\t\t  simplify_not_neg_expr (stmt);\n+\t\t  bsi_next (&bsi);\n+\t\t}\n \t      else\n \t\tbsi_next (&bsi);\n \t    }"}]}