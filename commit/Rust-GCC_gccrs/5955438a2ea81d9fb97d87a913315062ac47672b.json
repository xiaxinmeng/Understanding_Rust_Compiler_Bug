{"sha": "5955438a2ea81d9fb97d87a913315062ac47672b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk1NTQzOGEyZWE4MWQ5ZmI5N2Q4N2E5MTMzMTUwNjJhYzQ3NjcyYg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2018-01-23T16:47:03Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2018-01-23T16:47:03Z"}, "message": "re PR tree-optimization/82604 (SPEC CPU2006 410.bwaves ~50% performance regression with trunk@253679 when ftree-parallelize-loops is used)\n\n\tPR tree-optimization/82604\n\t* tree-loop-distribution.c (enum partition_kind): New enum item\n\tPKIND_PARTIAL_MEMSET.\n\t(partition_builtin_p): Support above new enum item.\n\t(generate_code_for_partition): Ditto.\n\t(compute_access_range): Differentiate cases that equality can be\n\tproven at all loops, the innermost loops or no loops.\n\t(classify_builtin_st, classify_builtin_ldst): Adjust call to above\n\tfunction.  Set PKIND_PARTIAL_MEMSET for partition appropriately.\n\t(finalize_partitions, distribute_loop): Don't fuse partition of\n\tPKIND_PARTIAL_MEMSET kind when distributing 3-level loop nest.\n\t(prepare_perfect_loop_nest): Distribute 3-level loop nest only if\n\tparloop is enabled.\n\nFrom-SVN: r256990", "tree": {"sha": "a533f366b09c242acbf48fb0b193100fa5bd82ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a533f366b09c242acbf48fb0b193100fa5bd82ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5955438a2ea81d9fb97d87a913315062ac47672b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5955438a2ea81d9fb97d87a913315062ac47672b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5955438a2ea81d9fb97d87a913315062ac47672b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5955438a2ea81d9fb97d87a913315062ac47672b/comments", "author": null, "committer": null, "parents": [{"sha": "cde9b2f815e3ce01bb84fef4b1c9a0cd45312eda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde9b2f815e3ce01bb84fef4b1c9a0cd45312eda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde9b2f815e3ce01bb84fef4b1c9a0cd45312eda"}], "stats": {"total": 116, "additions": 87, "deletions": 29}, "files": [{"sha": "576d5a21dfd415d6efd6d18f86beb2d032068dcb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5955438a2ea81d9fb97d87a913315062ac47672b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5955438a2ea81d9fb97d87a913315062ac47672b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5955438a2ea81d9fb97d87a913315062ac47672b", "patch": "@@ -1,3 +1,19 @@\n+2018-01-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/82604\n+\t* tree-loop-distribution.c (enum partition_kind): New enum item\n+\tPKIND_PARTIAL_MEMSET.\n+\t(partition_builtin_p): Support above new enum item.\n+\t(generate_code_for_partition): Ditto.\n+\t(compute_access_range): Differentiate cases that equality can be\n+\tproven at all loops, the innermost loops or no loops.\n+\t(classify_builtin_st, classify_builtin_ldst): Adjust call to above\n+\tfunction.  Set PKIND_PARTIAL_MEMSET for partition appropriately.\n+\t(finalize_partitions, distribute_loop): Don't fuse partition of\n+\tPKIND_PARTIAL_MEMSET kind when distributing 3-level loop nest.\n+\t(prepare_perfect_loop_nest): Distribute 3-level loop nest only if\n+\tparloop is enabled.\n+\n 2018-01-23  Martin Liska  <mliska@suse.cz>\n \n \t* predict.def (PRED_INDIR_CALL): Set probability to PROB_EVEN in"}, {"sha": "67f27bad83cf30d694676476a7efde7a5da4d9e8", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 71, "deletions": 29, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5955438a2ea81d9fb97d87a913315062ac47672b/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5955438a2ea81d9fb97d87a913315062ac47672b/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=5955438a2ea81d9fb97d87a913315062ac47672b", "patch": "@@ -584,7 +584,19 @@ build_rdg (struct loop *loop, control_dependences *cd)\n \n /* Kind of distributed loop.  */\n enum partition_kind {\n-    PKIND_NORMAL, PKIND_MEMSET, PKIND_MEMCPY, PKIND_MEMMOVE\n+    PKIND_NORMAL,\n+    /* Partial memset stands for a paritition can be distributed into a loop\n+       of memset calls, rather than a single memset call.  It's handled just\n+       like a normal parition, i.e, distributed as separate loop, no memset\n+       call is generated.\n+\n+       Note: This is a hacking fix trying to distribute ZERO-ing stmt in a\n+       loop nest as deep as possible.  As a result, parloop achieves better\n+       parallelization by parallelizing deeper loop nest.  This hack should\n+       be unnecessary and removed once distributed memset can be understood\n+       and analyzed in data reference analysis.  See PR82604 for more.  */\n+    PKIND_PARTIAL_MEMSET,\n+    PKIND_MEMSET, PKIND_MEMCPY, PKIND_MEMMOVE\n };\n \n /* Type of distributed loop.  */\n@@ -659,7 +671,7 @@ partition_free (partition *partition)\n static bool\n partition_builtin_p (partition *partition)\n {\n-  return partition->kind != PKIND_NORMAL;\n+  return partition->kind > PKIND_PARTIAL_MEMSET;\n }\n \n /* Returns true if the partition contains a reduction.  */\n@@ -1127,6 +1139,7 @@ generate_code_for_partition (struct loop *loop,\n   switch (partition->kind)\n     {\n     case PKIND_NORMAL:\n+    case PKIND_PARTIAL_MEMSET:\n       /* Reductions all have to be in the last partition.  */\n       gcc_assert (!partition_reduction_p (partition)\n \t\t  || !copy_p);\n@@ -1399,17 +1412,22 @@ find_single_drs (struct loop *loop, struct graph *rdg, partition *partition,\n \n /* Given data reference DR in LOOP_NEST, this function checks the enclosing\n    loops from inner to outer to see if loop's step equals to access size at\n-   each level of loop.  Return true if yes; record access base and size in\n-   BASE and SIZE; save loop's step at each level of loop in STEPS if it is\n-   not null.  For example:\n+   each level of loop.  Return 2 if we can prove this at all level loops;\n+   record access base and size in BASE and SIZE; save loop's step at each\n+   level of loop in STEPS if it is not null.  For example:\n \n      int arr[100][100][100];\n      for (i = 0; i < 100; i++)       ;steps[2] = 40000\n        for (j = 100; j > 0; j--)     ;steps[1] = -400\n \t for (k = 0; k < 100; k++)   ;steps[0] = 4\n-\t   arr[i][j - 1][k] = 0;     ;base = &arr, size = 4000000.  */\n+\t   arr[i][j - 1][k] = 0;     ;base = &arr, size = 4000000\n \n-static bool\n+   Return 1 if we can prove the equality at the innermost loop, but not all\n+   level loops.  In this case, no information is recorded.\n+\n+   Return 0 if no equality can be proven at any level loops.  */\n+\n+static int\n compute_access_range (loop_p loop_nest, data_reference_p dr, tree *base,\n \t\t      tree *size, vec<tree> *steps = NULL)\n {\n@@ -1419,24 +1437,25 @@ compute_access_range (loop_p loop_nest, data_reference_p dr, tree *base,\n   tree ref = DR_REF (dr);\n   tree access_base = build_fold_addr_expr (ref);\n   tree access_size = TYPE_SIZE_UNIT (TREE_TYPE (ref));\n+  int res = 0;\n \n   do {\n       tree scev_fn = analyze_scalar_evolution (loop, access_base);\n       if (TREE_CODE (scev_fn) != POLYNOMIAL_CHREC)\n-\treturn false;\n+\treturn res;\n \n       access_base = CHREC_LEFT (scev_fn);\n       if (tree_contains_chrecs (access_base, NULL))\n-\treturn false;\n+\treturn res;\n \n       tree scev_step = CHREC_RIGHT (scev_fn);\n       /* Only support constant steps.  */\n       if (TREE_CODE (scev_step) != INTEGER_CST)\n-\treturn false;\n+\treturn res;\n \n       enum ev_direction access_dir = scev_direction (scev_fn);\n       if (access_dir == EV_DIR_UNKNOWN)\n-\treturn false;\n+\treturn res;\n \n       if (steps != NULL)\n \tsteps->safe_push (scev_step);\n@@ -1449,7 +1468,11 @@ compute_access_range (loop_p loop_nest, data_reference_p dr, tree *base,\n       /* At each level of loop, scev step must equal to access size.  In other\n \t words, DR must access consecutive memory between loop iterations.  */\n       if (!operand_equal_p (scev_step, access_size, 0))\n-\treturn false;\n+\treturn res;\n+\n+      /* Access stride can be computed for data reference at least for the\n+\t innermost loop.  */\n+      res = 1;\n \n       /* Compute DR's execution times in loop.  */\n       tree niters = number_of_latch_executions (loop);\n@@ -1471,7 +1494,8 @@ compute_access_range (loop_p loop_nest, data_reference_p dr, tree *base,\n \n   *base = access_base;\n   *size = access_size;\n-  return true;\n+  /* Access stride can be computed for data reference at each level loop.  */\n+  return 2;\n }\n \n /* Allocate and return builtin struct.  Record information like DST_DR,\n@@ -1510,8 +1534,14 @@ classify_builtin_st (loop_p loop, partition *partition, data_reference_p dr)\n       && flow_bb_inside_loop_p (loop, gimple_bb (SSA_NAME_DEF_STMT (rhs))))\n     return;\n \n-  if (!compute_access_range (loop, dr, &base, &size))\n+  int res = compute_access_range (loop, dr, &base, &size);\n+  if (res == 0)\n     return;\n+  if (res == 1)\n+    {\n+      partition->kind = PKIND_PARTIAL_MEMSET;\n+      return;\n+    }\n \n   poly_uint64 base_offset;\n   unsigned HOST_WIDE_INT const_base_offset;\n@@ -1537,11 +1567,16 @@ classify_builtin_ldst (loop_p loop, struct graph *rdg, partition *partition,\n   tree base, size, src_base, src_size;\n   auto_vec<tree> dst_steps, src_steps;\n \n-  /* Compute access range of both load and store.  They much have the same\n-     access size.  */\n-  if (!compute_access_range (loop, dst_dr, &base, &size, &dst_steps)\n-      || !compute_access_range (loop, src_dr, &src_base, &src_size, &src_steps)\n-      || !operand_equal_p (size, src_size, 0))\n+  /* Compute access range of both load and store.  */\n+  int res = compute_access_range (loop, dst_dr, &base, &size, &dst_steps);\n+  if (res != 2)\n+    return;\n+  res = compute_access_range (loop, src_dr, &src_base, &src_size, &src_steps);\n+  if (res != 2)\n+    return;\n+\n+  /* They much have the same access size.  */\n+  if (!operand_equal_p (size, src_size, 0))\n     return;\n \n   /* Load and store in loop nest must access memory in the same way, i.e,\n@@ -2623,22 +2658,27 @@ finalize_partitions (struct loop *loop, vec<struct partition *> *partitions,\n       || alias_ddrs->length () > 0)\n     return;\n \n-  unsigned num_builtin = 0, num_normal = 0;\n+  unsigned num_builtin = 0, num_normal = 0, num_partial_memset = 0;\n   bool same_type_p = true;\n   enum partition_type type = ((*partitions)[0])->type;\n   for (i = 0; partitions->iterate (i, &partition); ++i)\n     {\n       same_type_p &= (type == partition->type);\n-      if (partition->kind != PKIND_NORMAL)\n-\tnum_builtin++;\n-      else\n-\tnum_normal++;\n+      if (partition_builtin_p (partition))\n+\t{\n+\t  num_builtin++;\n+\t  continue;\n+\t}\n+      num_normal++;\n+      if (partition->kind == PKIND_PARTIAL_MEMSET)\n+\tnum_partial_memset++;\n     }\n \n   /* Don't distribute current loop into too many loops given we don't have\n      memory stream cost model.  Be even more conservative in case of loop\n      nest distribution.  */\n-  if ((same_type_p && num_builtin == 0)\n+  if ((same_type_p && num_builtin == 0\n+       && (loop->inner == NULL || num_normal != 2 || num_partial_memset != 1))\n       || (loop->inner != NULL\n \t  && i >= NUM_PARTITION_THRESHOLD && num_normal > 1)\n       || (loop->inner == NULL\n@@ -2786,7 +2826,7 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   for (i = 0; partitions.iterate (i, &into); ++i)\n     {\n       bool changed = false;\n-      if (partition_builtin_p (into))\n+      if (partition_builtin_p (into) || into->kind == PKIND_PARTIAL_MEMSET)\n \tcontinue;\n       for (int j = i + 1;\n \t   partitions.iterate (j, &partition); ++j)\n@@ -2966,10 +3006,12 @@ prepare_perfect_loop_nest (struct loop *loop)\n   struct loop *outer = loop_outer (loop);\n   tree niters = number_of_latch_executions (loop);\n \n-  /* TODO: We only support the innermost 2-level loop nest distribution\n+  /* TODO: We only support the innermost 3-level loop nest distribution\n      because of compilation time issue for now.  This should be relaxed\n-     in the future.  */\n-  while (loop->inner == NULL\n+     in the future.  Note we only allow 3-level loop nest distribution\n+     when parallelizing loops.  */\n+  while ((loop->inner == NULL\n+\t  || (loop->inner->inner == NULL && flag_tree_parallelize_loops > 1))\n \t && loop_outer (outer)\n \t && outer->inner == loop && loop->next == NULL\n \t && single_exit (outer)"}]}