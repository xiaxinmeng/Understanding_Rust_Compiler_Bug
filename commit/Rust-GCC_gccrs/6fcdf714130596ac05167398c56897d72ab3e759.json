{"sha": "6fcdf714130596ac05167398c56897d72ab3e759", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZjZGY3MTQxMzA1OTZhYzA1MTY3Mzk4YzU2ODk3ZDcyYWIzZTc1OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-07T06:42:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-07T06:42:43Z"}, "message": "cfgbuild.c (find_bb_boundaries): Initialize profile of split blocks.\n\n\n\t* cfgbuild.c (find_bb_boundaries): Initialize profile of split blocks.\n\t(compute_outgoing_frequencies): Also initialize zero counts.\n\t(find_many_sub_basic_blocks): Do not produce uninitialized profile\n\taround loops; preserve more of profile when nothing changes.\n\nFrom-SVN: r248945", "tree": {"sha": "48a46acbffe326fefb2dbd7126d7460aa6cd7f1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48a46acbffe326fefb2dbd7126d7460aa6cd7f1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fcdf714130596ac05167398c56897d72ab3e759", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fcdf714130596ac05167398c56897d72ab3e759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fcdf714130596ac05167398c56897d72ab3e759", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fcdf714130596ac05167398c56897d72ab3e759/comments", "author": null, "committer": null, "parents": [{"sha": "96feaf79b2285aca415fda727e51868b95a8e4d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96feaf79b2285aca415fda727e51868b95a8e4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96feaf79b2285aca415fda727e51868b95a8e4d9"}], "stats": {"total": 58, "additions": 54, "deletions": 4}, "files": [{"sha": "3b2c8b9d6aac57a56b1e4cdebfe826c0d9db6ba3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcdf714130596ac05167398c56897d72ab3e759/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcdf714130596ac05167398c56897d72ab3e759/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fcdf714130596ac05167398c56897d72ab3e759", "patch": "@@ -1,3 +1,10 @@\n+2017-06-06  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cfgbuild.c (find_bb_boundaries): Initialize profile of split blocks.\n+\t(compute_outgoing_frequencies): Also initialize zero counts.\n+\t(find_many_sub_basic_blocks): Do not produce uninitialized profile\n+\taround loops; preserve more of profile when nothing changes.\n+\n 2017-06-06  Jim Wilson  <jim.wilson@linaro.org>\n \n \t* config/aarch64/aarch64-cost-tables.h (qdf24xx_extra_costs): Move to"}, {"sha": "f4a4d088251bf0c39557064d95b9aacde19cd280", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcdf714130596ac05167398c56897d72ab3e759/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcdf714130596ac05167398c56897d72ab3e759/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=6fcdf714130596ac05167398c56897d72ab3e759", "patch": "@@ -475,6 +475,10 @@ find_bb_boundaries (basic_block bb)\n \n \t  bb = fallthru->dest;\n \t  remove_edge (fallthru);\n+\t  /* BB is unreachable at this point - we need to determine its profile\n+\t     once edges are built.  */\n+\t  bb->frequency = 0;\n+\t  bb->count = profile_count::uninitialized ();\n \t  flow_transfer_insn = NULL;\n \t  if (code == CODE_LABEL && LABEL_ALT_ENTRY_P (insn))\n \t    make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, 0);\n@@ -577,7 +581,7 @@ compute_outgoing_frequencies (basic_block b)\n         guess_outgoing_edge_probabilities (b);\n     }\n \n-  if (b->count > profile_count::zero ())\n+  if (b->count.initialized_p ())\n     FOR_EACH_EDGE (e, ei, b->succs)\n       e->count = b->count.apply_probability (e->probability);\n }\n@@ -590,18 +594,34 @@ void\n find_many_sub_basic_blocks (sbitmap blocks)\n {\n   basic_block bb, min, max;\n+  bool found = false;\n+  auto_vec<unsigned int> n_succs;\n+  n_succs.safe_grow_cleared (last_basic_block_for_fn (cfun));\n \n   FOR_EACH_BB_FN (bb, cfun)\n     SET_STATE (bb,\n \t       bitmap_bit_p (blocks, bb->index) ? BLOCK_TO_SPLIT : BLOCK_ORIGINAL);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     if (STATE (bb) == BLOCK_TO_SPLIT)\n-      find_bb_boundaries (bb);\n+      {\n+\tint n = last_basic_block_for_fn (cfun);\n+\tunsigned int ns = EDGE_COUNT (bb->succs);\n+\n+        find_bb_boundaries (bb);\n+\tif (n == last_basic_block_for_fn (cfun) && ns == EDGE_COUNT (bb->succs))\n+\t  n_succs[bb->index] = EDGE_COUNT (bb->succs);\n+      }\n \n   FOR_EACH_BB_FN (bb, cfun)\n     if (STATE (bb) != BLOCK_ORIGINAL)\n-      break;\n+      {\n+\tfound = true;\n+        break;\n+      }\n+\n+  if (!found)\n+    return;\n \n   min = max = bb;\n   for (; bb != EXIT_BLOCK_PTR_FOR_FN (cfun); bb = bb->next_bb)\n@@ -624,14 +644,37 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \t  continue;\n \tif (STATE (bb) == BLOCK_NEW)\n \t  {\n+\t    bool initialized_src = false, uninitialized_src = false;\n \t    bb->count = profile_count::zero ();\n \t    bb->frequency = 0;\n \t    FOR_EACH_EDGE (e, ei, bb->preds)\n \t      {\n-\t\tbb->count += e->count;\n+\t\tif (e->count.initialized_p ())\n+\t\t  {\n+\t\t    bb->count += e->count;\n+\t\t    initialized_src = true;\n+\t\t  }\n+\t\telse\n+\t\t  uninitialized_src = false;\n \t\tbb->frequency += EDGE_FREQUENCY (e);\n \t      }\n+\t    /* When some edges are missing with read profile, this is\n+\t       most likely because RTL expansion introduced loop.\n+\t       When profile is guessed we may have BB that is reachable\n+\t       from unlikely path as well as from normal path.\n+\n+\t       TODO: We should handle loops created during BB expansion\n+\t       correctly here.  For now we assume all those loop to cycle\n+\t       precisely once.  */\n+\t    if (!initialized_src\n+\t\t|| (uninitialized_src\n+\t\t     && profile_status_for_fn (cfun) != PROFILE_READ))\n+\t      bb->count = profile_count::uninitialized ();\n \t  }\n+\telse\n+\t  /* If nothing changed, there is no need to create new BBs.  */\n+\t  if (EDGE_COUNT (bb->succs) == n_succs[bb->index])\n+\t    continue;\n \n \tcompute_outgoing_frequencies (bb);\n       }"}]}