{"sha": "188c5e6ca8656feaa041ac6aa53c3b5f26a31678", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg4YzVlNmNhODY1NmZlYWEwNDFhYzZhYTUzYzNiNWYyNmEzMTY3OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-15T16:21:53Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-15T16:21:53Z"}, "message": "Don't make bogus libcall blocks\n\nFrom-SVN: r36435", "tree": {"sha": "48998e6a8ca5552902e07ac045be5a345d80b498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48998e6a8ca5552902e07ac045be5a345d80b498"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/188c5e6ca8656feaa041ac6aa53c3b5f26a31678", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/188c5e6ca8656feaa041ac6aa53c3b5f26a31678", "html_url": "https://github.com/Rust-GCC/gccrs/commit/188c5e6ca8656feaa041ac6aa53c3b5f26a31678", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/188c5e6ca8656feaa041ac6aa53c3b5f26a31678/comments", "author": null, "committer": null, "parents": [{"sha": "642dfa8b65d3f42e35df4ced39d8a58b1a8cc2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642dfa8b65d3f42e35df4ced39d8a58b1a8cc2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642dfa8b65d3f42e35df4ced39d8a58b1a8cc2e6"}], "stats": {"total": 46, "additions": 2, "deletions": 44}, "files": [{"sha": "ac895752a4a8feb8782f1752ae38744aadd25aa7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/188c5e6ca8656feaa041ac6aa53c3b5f26a31678/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/188c5e6ca8656feaa041ac6aa53c3b5f26a31678/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=188c5e6ca8656feaa041ac6aa53c3b5f26a31678", "patch": "@@ -4,6 +4,8 @@\n \tcopy to a temporary first.\n \t* expr.c (convert_move): When generating a libcall, make a libcall\n \tblock.\n+\t* calls.c (emit_library_call_value_1): Don't create a libcall\n+\tsequence here; our caller will in most cases do it.\n \n 2000-09-15  Richard Henderson  <rth@cygnus.com>\n "}, {"sha": "71866113ab9c45e706ddfd128b172c2245a252cf", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/188c5e6ca8656feaa041ac6aa53c3b5f26a31678/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/188c5e6ca8656feaa041ac6aa53c3b5f26a31678/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=188c5e6ca8656feaa041ac6aa53c3b5f26a31678", "patch": "@@ -3580,11 +3580,6 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n   count = 0;\n \n-  /* Now we are about to start emitting insns that can be deleted\n-     if a libcall is deleted.  */\n-  if (flags & (ECF_CONST | ECF_PURE))\n-    start_sequence ();\n-\n   push_temp_slots ();\n \n   /* If there's a structure value address to be passed,\n@@ -4022,45 +4017,6 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   /* Now restore inhibit_defer_pop to its actual original value.  */\n   OK_DEFER_POP;\n \n-  /* If call is cse'able, make appropriate pair of reg-notes around it.\n-     Test valreg so we don't crash; may safely ignore `const'\n-     if return type is void.  Disable for PARALLEL return values, because\n-     we have no way to move such values into a pseudo register.  */\n-  if ((flags & (ECF_CONST | ECF_PURE))\n-      && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n-    {\n-      rtx note = 0;\n-      rtx temp = gen_reg_rtx (GET_MODE (valreg));\n-      rtx insns;\n-      int i;\n-\n-      /* Construct an \"equal form\" for the value which mentions all the\n-\t arguments in order as well as the function name.  */\n-      for (i = 0; i < nargs; i++)\n-\tnote = gen_rtx_EXPR_LIST (VOIDmode, argvec[i].value, note);\n-      note = gen_rtx_EXPR_LIST (VOIDmode, fun, note);\n-\n-      insns = get_insns ();\n-      end_sequence ();\n-\n-      if (flags & ECF_PURE)\n-\tnote = gen_rtx_EXPR_LIST (VOIDmode,\n-\t   gen_rtx_USE (VOIDmode,\n-\t\t\tgen_rtx_MEM (BLKmode,\n-\t\t\t\t     gen_rtx_SCRATCH (VOIDmode))), note);\n-\n-      emit_libcall_block (insns, temp, valreg, note);\n-\n-      valreg = temp;\n-    }\n-  else if (flags & (ECF_CONST | ECF_PURE))\n-    {\n-      /* Otherwise, just write out the sequence without a note.  */\n-      rtx insns = get_insns ();\n-\n-      end_sequence ();\n-      emit_insns (insns);\n-    }\n   pop_temp_slots ();\n \n   /* Copy the value to the right place.  */"}]}