{"sha": "fc152a4b815a05abca79673fdf42c75f56bf8a1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMxNTJhNGI4MTVhMDVhYmNhNzk2NzNmZGY0MmM3NWY1NmJmOGExYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-08-28T10:26:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-08-28T10:26:23Z"}, "message": "Initial revision\n\nFrom-SVN: r33", "tree": {"sha": "6cb8196db6e2fd3a13f30d9827ae497acaf63c84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cb8196db6e2fd3a13f30d9827ae497acaf63c84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc152a4b815a05abca79673fdf42c75f56bf8a1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc152a4b815a05abca79673fdf42c75f56bf8a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc152a4b815a05abca79673fdf42c75f56bf8a1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc152a4b815a05abca79673fdf42c75f56bf8a1b/comments", "author": null, "committer": null, "parents": [{"sha": "3250221d1afe8f51f3265a71c680688daed4041f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3250221d1afe8f51f3265a71c680688daed4041f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3250221d1afe8f51f3265a71c680688daed4041f"}], "stats": {"total": 111, "additions": 111, "deletions": 0}, "files": [{"sha": "c61a23fc2cec3fae647a98a4d77d100cdb46a50c", "filename": "gcc/machmode.h", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc152a4b815a05abca79673fdf42c75f56bf8a1b/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc152a4b815a05abca79673fdf42c75f56bf8a1b/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=fc152a4b815a05abca79673fdf42c75f56bf8a1b", "patch": "@@ -0,0 +1,111 @@\n+/* Machine mode definitions for GNU C-Compiler; included by rtl.h and tree.h.\n+   Copyright (C) 1990-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#ifndef HAVE_MACHINE_MODES\n+\n+/* Strictly speaking, this isn't the proper place to include these definitions,\n+   but this file is included by every GCC file.\n+\n+   Some systems define these in, e.g., param.h.  We undefine these names\n+   here to avoid the warnings.  We prefer to use our definitions since we\n+   know they are correct.  */\n+\n+#undef MIN\n+#undef MAX\n+\n+#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))\n+#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))\n+\n+/* Make an enum class that gives all the machine modes.  */\n+\n+#define DEF_MACHMODE(SYM, NAME, TYPE, SIZE, UNIT, WIDER)  SYM,\n+\n+enum machine_mode {\n+#include \"machmode.def\"\n+\n+#ifdef EXTRA_CC_MODES\n+  EXTRA_CC_MODES,\n+#endif\n+MAX_MACHINE_MODE };\n+\n+#undef DEF_MACHMODE\n+\n+#define HAVE_MACHINE_MODES\n+\n+#ifndef NUM_MACHINE_MODES\n+#define NUM_MACHINE_MODES (int) MAX_MACHINE_MODE\n+#endif\n+\n+/* Get the name of mode MODE as a string.  */\n+\n+extern char *mode_name[];\n+#define GET_MODE_NAME(MODE)\t\t(mode_name[(int)(MODE)])\n+\n+enum mode_class { MODE_RANDOM, MODE_INT, MODE_FLOAT, MODE_PARTIAL_INT, MODE_CC,\n+\t\t  MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT };\n+\n+/* Get the general kind of object that mode MODE represents\n+   (integer, floating, complex, etc.)  */\n+\n+extern enum mode_class mode_class[];\n+#define GET_MODE_CLASS(MODE)\t\t(mode_class[(int)(MODE)])\n+\n+/* Get the size in bytes of an object of mode MODE.  */\n+\n+extern int mode_size[];\n+#define GET_MODE_SIZE(MODE)\t\t(mode_size[(int)(MODE)])\n+\n+/* Get the size in bytes of the basic parts of an object of mode MODE.  */\n+\n+extern int mode_unit_size[];\n+#define GET_MODE_UNIT_SIZE(MODE)\t(mode_unit_size[(int)(MODE)])\n+\n+/* Get the number of units in the object.  */\n+\n+#define GET_MODE_NUNITS(MODE)  \\\n+  (GET_MODE_SIZE ((MODE)) / GET_MODE_UNIT_SIZE ((MODE)))\n+\n+/* Get the size in bits of an object of mode MODE.  */\n+\n+#define GET_MODE_BITSIZE(MODE)  (BITS_PER_UNIT * mode_size[(int)(MODE)])\n+\n+/* Get a bitmask containing 1 for all bits in a word\n+   that fit within mode MODE.  */\n+\n+#define GET_MODE_MASK(MODE)  \\\n+   ((GET_MODE_BITSIZE (MODE) >= HOST_BITS_PER_INT)  \\\n+    ? -1 : ((1 << GET_MODE_BITSIZE (MODE)) - 1))\n+\n+/* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n+\n+extern enum machine_mode mode_wider_mode[];\n+#define GET_MODE_WIDER_MODE(MODE)\t(mode_wider_mode[(int)(MODE)])\n+\n+/* Find the best mode to use to access a bit field.  */\n+\n+extern enum machine_mode get_best_mode ();\n+\n+/* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n+\n+#define GET_MODE_ALIGNMENT(MODE)   \\\n+  MIN (BIGGEST_ALIGNMENT, \t   \\\n+       MAX (1, (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT)))\n+\n+#endif /* not HAVE_MACHINE_MODES */"}]}