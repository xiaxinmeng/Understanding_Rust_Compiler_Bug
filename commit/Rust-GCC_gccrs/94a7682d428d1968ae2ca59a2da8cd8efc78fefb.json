{"sha": "94a7682d428d1968ae2ca59a2da8cd8efc78fefb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRhNzY4MmQ0MjhkMTk2OGFlMmNhNTlhMmRhOGNkOGVmYzc4ZmVmYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-12T16:54:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-12T16:54:38Z"}, "message": "dse.c (find_shift_sequence): Reinstate \"<= UNITS_PER_WORD\" condition.\n\ngcc/\n\t* dse.c (find_shift_sequence): Reinstate \"<= UNITS_PER_WORD\" condition.\n\t* var-tracking.c (micro_operation_def): Update comment on u.loc.\n\t(mode_for_reg_attrs, var_lowpart): New functions.\n\t(add_uses): Consider recording a lowpart of LOC for MO_USE.\n\t(add_stores): Likewise MO_SET and MO_COPY.  If the source of a set\n\tor copy is known, set LOC to the SET that performs the set, instead\n\tof the destination.\n\t(find_src_status, find_src_set_src): Remove LOC parameter.\n\tReplace INSN with the source value.\n\t(compute_bb_dataflow, emit_notes_in_bb): Check for a SET u.loc when\n\thandling MO_SET and MO_COPY.  Update the calls to find_src_status\n\tand find_src_set_src.\n\nFrom-SVN: r129269", "tree": {"sha": "d696bcaec8c464af3761b07fd32df0c58afae383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d696bcaec8c464af3761b07fd32df0c58afae383"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94a7682d428d1968ae2ca59a2da8cd8efc78fefb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a7682d428d1968ae2ca59a2da8cd8efc78fefb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94a7682d428d1968ae2ca59a2da8cd8efc78fefb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a7682d428d1968ae2ca59a2da8cd8efc78fefb/comments", "author": null, "committer": null, "parents": [{"sha": "27372c38aa5b12ad197b47331e5bd663702490b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27372c38aa5b12ad197b47331e5bd663702490b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27372c38aa5b12ad197b47331e5bd663702490b3"}], "stats": {"total": 254, "additions": 162, "deletions": 92}, "files": [{"sha": "11005269fddb745bcc7eeca2730f453603c84ffb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a7682d428d1968ae2ca59a2da8cd8efc78fefb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a7682d428d1968ae2ca59a2da8cd8efc78fefb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94a7682d428d1968ae2ca59a2da8cd8efc78fefb", "patch": "@@ -1,3 +1,18 @@\n+2007-10-12  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* dse.c (find_shift_sequence): Reinstate \"<= UNITS_PER_WORD\" condition.\n+\t* var-tracking.c (micro_operation_def): Update comment on u.loc.\n+\t(mode_for_reg_attrs, var_lowpart): New functions.\n+\t(add_uses): Consider recording a lowpart of LOC for MO_USE.\n+\t(add_stores): Likewise MO_SET and MO_COPY.  If the source of a set\n+\tor copy is known, set LOC to the SET that performs the set, instead\n+\tof the destination.\n+\t(find_src_status, find_src_set_src): Remove LOC parameter.\n+\tReplace INSN with the source value.\n+\t(compute_bb_dataflow, emit_notes_in_bb): Check for a SET u.loc when\n+\thandling MO_SET and MO_COPY.  Update the calls to find_src_status\n+\tand find_src_set_src.\n+\n 2007-10-12  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR 11001"}, {"sha": "a5244e114142a955738b6ba03d7c13041de68415", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a7682d428d1968ae2ca59a2da8cd8efc78fefb/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a7682d428d1968ae2ca59a2da8cd8efc78fefb/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=94a7682d428d1968ae2ca59a2da8cd8efc78fefb", "patch": "@@ -1415,7 +1415,7 @@ find_shift_sequence (rtx read_reg,\n      justify the value we want to read but is available in one insn on\n      the machine.  */\n \n-  for (; access_size < UNITS_PER_WORD; access_size *= 2)\n+  for (; access_size <= UNITS_PER_WORD; access_size *= 2)\n     {\n       rtx target, new_reg, shift_seq, insn;\n       enum machine_mode new_mode;"}, {"sha": "ea6981ae4a7915335dc50262e75834cbca46a1d8", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 146, "deletions": 91, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a7682d428d1968ae2ca59a2da8cd8efc78fefb/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a7682d428d1968ae2ca59a2da8cd8efc78fefb/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=94a7682d428d1968ae2ca59a2da8cd8efc78fefb", "patch": "@@ -134,7 +134,9 @@ typedef struct micro_operation_def\n   enum micro_operation_type type;\n \n   union {\n-    /* Location.  */\n+    /* Location.  For MO_SET and MO_COPY, this is the SET that performs\n+       the assignment, if known, otherwise it is the target of the\n+       assignment.  */\n     rtx loc;\n \n     /* Stack adjustment.  */\n@@ -1672,6 +1674,54 @@ same_variable_part_p (rtx loc, tree expr, HOST_WIDE_INT offset)\n   return (expr == expr2 && offset == offset2);\n }\n \n+/* REG is a register we want to track.  If not all of REG contains useful\n+   information, return the mode of the lowpart that does contain useful\n+   information, otherwise return the mode of REG.\n+\n+   If REG was a paradoxical subreg, its REG_ATTRS will describe the\n+   whole subreg, but only the old inner part is really relevant.  */\n+\n+static enum machine_mode\n+mode_for_reg_attrs (rtx reg)\n+{\n+  enum machine_mode mode;\n+\n+  mode = GET_MODE (reg);\n+  if (!HARD_REGISTER_NUM_P (ORIGINAL_REGNO (reg)))\n+    {\n+      enum machine_mode pseudo_mode;\n+\n+      pseudo_mode = PSEUDO_REGNO_MODE (ORIGINAL_REGNO (reg));\n+      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (pseudo_mode))\n+\tmode = pseudo_mode;\n+    }\n+  return mode;\n+}\n+\n+/* Return the MODE lowpart of LOC, or null if LOC is not something we\n+   want to track.  When returning nonnull, make sure that the attributes\n+   on the returned value are updated.  */\n+\n+static rtx\n+var_lowpart (enum machine_mode mode, rtx loc)\n+{\n+  unsigned int offset, regno;\n+\n+  if (!REG_P (loc) && !MEM_P (loc))\n+    return NULL;\n+\n+  if (GET_MODE (loc) == mode)\n+    return loc;\n+\n+  offset = subreg_lowpart_offset (mode, GET_MODE (loc));\n+\n+  if (MEM_P (loc))\n+    return adjust_address_nv (loc, mode, offset);\n+\n+  regno = REGNO (loc) + subreg_regno_offset (REGNO (loc), GET_MODE (loc),\n+\t\t\t\t\t     offset, mode);\n+  return gen_rtx_REG_offset (loc, mode, regno, offset);\n+}\n \n /* Count uses (register and memory references) LOC which will be tracked.\n    INSN is instruction which the LOC is part of.  */\n@@ -1724,9 +1774,16 @@ add_uses (rtx *loc, void *insn)\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n-      mo->type = ((REG_EXPR (*loc) && track_expr_p (REG_EXPR (*loc)))\n-\t\t  ? MO_USE : MO_USE_NO_VAR);\n-      mo->u.loc = *loc;\n+      if (REG_EXPR (*loc) && track_expr_p (REG_EXPR (*loc)))\n+\t{\n+\t  mo->type = MO_USE;\n+\t  mo->u.loc = var_lowpart (mode_for_reg_attrs (*loc), *loc);\n+\t}\n+      else\n+\t{\n+\t  mo->type = MO_USE_NO_VAR;\n+\t  mo->u.loc = *loc;\n+\t}\n       mo->insn = (rtx) insn;\n     }\n   else if (MEM_P (*loc)\n@@ -1767,16 +1824,35 @@ add_stores (rtx loc, const_rtx expr, void *insn)\n       if (GET_CODE (expr) == CLOBBER\n \t  || ! REG_EXPR (loc)\n \t  || ! track_expr_p (REG_EXPR (loc)))\n-\tmo->type = MO_CLOBBER;\n-      else if (GET_CODE (expr) == SET\n-\t       && SET_DEST (expr) == loc\n-\t       && same_variable_part_p (SET_SRC (expr),\n-\t\t\t\t\tREG_EXPR (loc),\n-\t\t\t\t\tREG_OFFSET (loc)))\n-\tmo->type = MO_COPY;\n+\t{\n+\t  mo->type = MO_CLOBBER;\n+\t  mo->u.loc = loc;\n+\t}\n       else\n-\tmo->type = MO_SET;\n-      mo->u.loc = loc;\n+\t{\n+\t  enum machine_mode mode = mode_for_reg_attrs (loc);\n+\t  rtx src = NULL;\n+\n+\t  if (GET_CODE (expr) == SET && SET_DEST (expr) == loc)\n+\t    src = var_lowpart (mode, SET_SRC (expr));\n+\t  loc = var_lowpart (mode, loc);\n+\n+\t  if (src == NULL)\n+\t    {\n+\t      mo->type = MO_SET;\n+\t      mo->u.loc = loc;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (SET_SRC (expr) != src)\n+\t\texpr = gen_rtx_SET (VOIDmode, loc, src);\n+\t      if (same_variable_part_p (src, REG_EXPR (loc), REG_OFFSET (loc)))\n+\t\tmo->type = MO_COPY;\n+\t      else\n+\t\tmo->type = MO_SET;\n+\t      mo->u.loc = CONST_CAST_RTX (expr);\n+\t    }\n+\t}\n       mo->insn = (rtx) insn;\n     }\n   else if (MEM_P (loc)\n@@ -1787,49 +1863,47 @@ add_stores (rtx loc, const_rtx expr, void *insn)\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n       if (GET_CODE (expr) == CLOBBER)\n-\tmo->type = MO_CLOBBER;\n-      else if (GET_CODE (expr) == SET\n-\t       && SET_DEST (expr) == loc\n-\t       && same_variable_part_p (SET_SRC (expr),\n+\t{\n+\t  mo->type = MO_CLOBBER;\n+\t  mo->u.loc = loc;\n+\t}\n+      else\n+\t{\n+\t  rtx src = NULL;\n+\n+\t  if (GET_CODE (expr) == SET && SET_DEST (expr) == loc)\n+\t    src = var_lowpart (GET_MODE (loc), SET_SRC (expr));\n+\n+\t  if (src == NULL)\n+\t    {\n+\t      mo->type = MO_SET;\n+\t      mo->u.loc = loc;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (same_variable_part_p (SET_SRC (expr),\n \t\t\t\t\tMEM_EXPR (loc),\n \t\t\t\t\tMEM_OFFSET (loc)\n \t\t\t\t\t? INTVAL (MEM_OFFSET (loc)) : 0))\n-\tmo->type = MO_COPY;\n-      else\n-\tmo->type = MO_SET;\n-      mo->u.loc = loc;\n+\t\tmo->type = MO_COPY;\n+\t      else\n+\t\tmo->type = MO_SET;\n+\t      mo->u.loc = CONST_CAST_RTX (expr);\n+\t    }\n+\t}\n       mo->insn = (rtx) insn;\n     }\n }\n \n static enum var_init_status\n-find_src_status (dataflow_set *in, rtx loc, rtx insn)\n+find_src_status (dataflow_set *in, rtx src)\n {\n-  rtx src = NULL_RTX;\n-  rtx pattern;\n   tree decl = NULL_TREE;\n   enum var_init_status status = VAR_INIT_STATUS_UNINITIALIZED;\n \n   if (! flag_var_tracking_uninit)\n     status = VAR_INIT_STATUS_INITIALIZED;\n \n-  pattern = PATTERN (insn);\n-\n-  if (GET_CODE (pattern) == COND_EXEC)\n-    pattern = COND_EXEC_CODE (pattern);\n-\n-  if (GET_CODE (pattern) == SET)\n-    src = SET_SRC (pattern);\n-  else if (GET_CODE (pattern) == PARALLEL\n-\t   || GET_CODE (pattern) == SEQUENCE)\n-    {\n-      int i;\n-      for (i = XVECLEN (pattern, 0) - 1; i >= 0; i--)\n-\tif (GET_CODE (XVECEXP (pattern, 0, i)) == SET\n-\t    && SET_DEST (XVECEXP (pattern, 0, i)) == loc)\n-\t  src = SET_SRC (XVECEXP (pattern, 0, i));\n-    }\n-\n   if (src && REG_P (src))\n     decl = var_debug_decl (REG_EXPR (src));\n   else if (src && MEM_P (src))\n@@ -1841,39 +1915,21 @@ find_src_status (dataflow_set *in, rtx loc, rtx insn)\n   return status;\n }\n \n-/* LOC is the destination the variable is being copied to.  INSN \n-   contains the copy instruction.  SET is the dataflow set containing\n-   the variable in LOC.  */\n+/* SRC is the source of an assignment.  Use SET to try to find what\n+   was ultimately assigned to SRC.  Return that value if known,\n+   otherwise return SRC itself.  */\n \n static rtx\n-find_src_set_src (dataflow_set *set, rtx loc, rtx insn)\n+find_src_set_src (dataflow_set *set, rtx src)\n {\n   tree decl = NULL_TREE;   /* The variable being copied around.          */\n-  rtx src = NULL_RTX;      /* The location \"decl\" is being copied from.  */\n   rtx set_src = NULL_RTX;  /* The value for \"decl\" stored in \"src\".      */\n-  rtx pattern;\n   void **slot;\n   variable var;\n   location_chain nextp;\n   int i;\n   bool found;\n \n-\n-  pattern = PATTERN (insn);\n-  if (GET_CODE (pattern) == COND_EXEC)\n-    pattern = COND_EXEC_CODE (pattern);\n-\n-  if (GET_CODE (pattern) == SET)\n-    src = SET_SRC (pattern);\n-  else if (GET_CODE (pattern) == PARALLEL\n-\t   || GET_CODE (pattern) == SEQUENCE)\n-    {\n-      for (i = XVECLEN (pattern, 0) - 1; i >= 0; i--)\n-\tif (GET_CODE (XVECEXP (pattern, 0, i)) == SET\n-\t    && SET_DEST (XVECEXP (pattern, 0, i)) == loc)\n-\t  src = SET_SRC (XVECEXP (pattern, 0, i));\n-    }\n-\n   if (src && REG_P (src))\n     decl = var_debug_decl (REG_EXPR (src));\n   else if (src && MEM_P (src))\n@@ -1947,19 +2003,12 @@ compute_bb_dataflow (basic_block bb)\n \t  case MO_SET:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n-\t      rtx set_src =  NULL;\n-\t      rtx insn = VTI (bb)->mos[i].insn;\n+\t      rtx set_src = NULL;\n \n-\t      if (GET_CODE (PATTERN (insn)) == SET)\n-\t\tset_src = SET_SRC (PATTERN (insn));\n-\t      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t\t       || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t      if (GET_CODE (loc) == SET)\n \t\t{\n-\t\t  int j;\n-\t\t  for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n-\t\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n-\t\t\t&& SET_DEST (XVECEXP (PATTERN (insn), 0, j)) == loc)\n-\t\t      set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, j));\n+\t\t  set_src = SET_SRC (loc);\n+\t\t  loc = SET_DEST (loc);\n \t\t}\n \n \t      if (REG_P (loc))\n@@ -1975,17 +2024,23 @@ compute_bb_dataflow (basic_block bb)\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \t      enum var_init_status src_status;\n-\t      rtx set_src;\n+\t      rtx set_src = NULL;\n+\n+\t      if (GET_CODE (loc) == SET)\n+\t\t{\n+\t\t  set_src = SET_SRC (loc);\n+\t\t  loc = SET_DEST (loc);\n+\t\t}\n \n \t      if (! flag_var_tracking_uninit)\n \t\tsrc_status = VAR_INIT_STATUS_INITIALIZED;\n \t      else\n-\t\tsrc_status = find_src_status (in, loc, VTI (bb)->mos[i].insn);\n+\t\tsrc_status = find_src_status (in, set_src);\n \n \t      if (src_status == VAR_INIT_STATUS_UNKNOWN)\n-\t\tsrc_status = find_src_status (out, loc, VTI (bb)->mos[i].insn);\n+\t\tsrc_status = find_src_status (out, set_src);\n \n-\t      set_src = find_src_set_src (in, loc, VTI (bb)->mos[i].insn);\n+\t      set_src = find_src_set_src (in, set_src);\n \n \t      if (REG_P (loc))\n \t\tvar_reg_delete_and_set (out, loc, false, src_status, set_src);\n@@ -2883,18 +2938,12 @@ emit_notes_in_bb (basic_block bb)\n \t  case MO_SET:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n-\t      rtx set_src =  NULL;\n+\t      rtx set_src = NULL;\n \n-\t      if (GET_CODE (PATTERN (insn)) == SET)\n-\t\tset_src = SET_SRC (PATTERN (insn));\n-\t      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t\t       || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t      if (GET_CODE (loc) == SET)\n \t\t{\n-\t\t  int j;\n-\t\t  for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n-\t\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n-\t\t\t&& SET_DEST (XVECEXP (PATTERN (insn), 0, j)) == loc)\n-\t\t      set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, j));\n+\t\t  set_src = SET_SRC (loc);\n+\t\t  loc = SET_DEST (loc);\n \t\t}\n \n \t      if (REG_P (loc))\n@@ -2912,10 +2961,16 @@ emit_notes_in_bb (basic_block bb)\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \t      enum var_init_status src_status;\n-\t      rtx set_src;\n+\t      rtx set_src = NULL;\n+\n+\t      if (GET_CODE (loc) == SET)\n+\t\t{\n+\t\t  set_src = SET_SRC (loc);\n+\t\t  loc = SET_DEST (loc);\n+\t\t}\n \n-\t      src_status = find_src_status (&set, loc, VTI (bb)->mos[i].insn);\n-\t      set_src = find_src_set_src (&set, loc, VTI (bb)->mos[i].insn);\n+\t      src_status = find_src_status (&set, set_src);\n+\t      set_src = find_src_set_src (&set, set_src);\n \n \t      if (REG_P (loc))\n \t\tvar_reg_delete_and_set (&set, loc, false, src_status, set_src);"}]}