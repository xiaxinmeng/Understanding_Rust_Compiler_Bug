{"sha": "2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFiOGRiZjQ4ZWU3YzJlYmE5MTBlZTI1ZWUzN2FmZDQwZTI1OTczOA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-03-28T12:20:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-28T12:20:09Z"}, "message": "re PR tree-optimization/30317 (VRP cannot extract a range from (unsigned int) i + 0x0ffffffff > 4)\n\n2008-03-28  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/30317\n\tPR tree-optimization/30911\n\tPR tree-optimization/34793\n\t* tree-vrp.c (set_and_canonicalize_value_range): New function.\n\t(struct assert_locus_d): New member EXPR.\n\t(register_new_assert_for): Add EXPR parameter to support\n\tASSERT_EXPR <name, expr OP limit>.\n\t(register_edge_assert_for_1): Adjust callers.\n\t(find_assert_locations): Likewise.\n\t(process_assert_insertions_for): Build condition from\n\texpression.\n\t(extract_range_from_assert): Handle ASSERT_EXPRs\n\tof the form ASSERT_EXPR <name, expr OP limit>.\n\t(register_edge_assert_for_2): New helper registering\n\tasserts for comparisons.  Recognize range tests of the form\n\t(unsigned)i - CST1 OP CST2.\n\t(register_edge_assert_for_1): Use it.\n\t(register_edge_assert_for): Likewise.\n\t* tree.def (ASSERT_EXPR): Document extra allowed conditional\n\texpressions.\n\t(needs_overflow_infinity): Integer sub-types\n\tdo not need overflow infinities.\n\t(vrp_val_is_max): The extreme values of integer sub-types\n\tare those of the base type.\n\t(vrp_val_is_min): Likewise.\n\n\t* gcc.dg/tree-ssa/vrp35.c: New testcase.\n\t* gcc.dg/tree-ssa/vrp36.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp37.c: Likewise.\n\nFrom-SVN: r133680", "tree": {"sha": "7e98fd147828149c3866ab6ab9ae3e7ddbd75173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e98fd147828149c3866ab6ab9ae3e7ddbd75173"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0be8e5c63c8c89cf57b42566306c22b6654fda8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0be8e5c63c8c89cf57b42566306c22b6654fda8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0be8e5c63c8c89cf57b42566306c22b6654fda8"}], "stats": {"total": 366, "additions": 310, "deletions": 56}, "files": [{"sha": "ec6efa7776787feed85f2b970a5c4c5c3395b496", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "patch": "@@ -1,3 +1,31 @@\n+2008-03-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/30317\n+\tPR tree-optimization/30911\n+\tPR tree-optimization/34793\n+\t* tree-vrp.c (set_and_canonicalize_value_range): New function.\n+\t(struct assert_locus_d): New member EXPR.\n+\t(register_new_assert_for): Add EXPR parameter to support\n+\tASSERT_EXPR <name, expr OP limit>.\n+\t(register_edge_assert_for_1): Adjust callers.\n+\t(find_assert_locations): Likewise.\n+\t(process_assert_insertions_for): Build condition from\n+\texpression.\n+\t(extract_range_from_assert): Handle ASSERT_EXPRs\n+\tof the form ASSERT_EXPR <name, expr OP limit>.\n+\t(register_edge_assert_for_2): New helper registering\n+\tasserts for comparisons.  Recognize range tests of the form\n+\t(unsigned)i - CST1 OP CST2.\n+\t(register_edge_assert_for_1): Use it.\n+\t(register_edge_assert_for): Likewise.\n+\t(needs_overflow_infinity): Integer sub-types\n+\tdo not need overflow infinities.\n+\t(vrp_val_is_max): The extreme values of integer sub-types\n+\tare those of the base type.\n+\t(vrp_val_is_min): Likewise.\n+\t* tree.def (ASSERT_EXPR): Document extra allowed conditional\n+\texpressions.\n+\n 2008-03-28  Nick Clifton  <nickc@redhat.com>\n \n \t* config/mn10300/mn10300.c (mn10300_secondary_reload_class):"}, {"sha": "3fd0aa2c65bb571c6d6d607f9f0b744520309d7f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "patch": "@@ -1,3 +1,12 @@\n+2008-03-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/30317\n+\tPR tree-optimization/30911\n+\tPR tree-optimization/34793\n+\t* gcc.dg/tree-ssa/vrp35.c: New testcase.\n+\t* gcc.dg/tree-ssa/vrp36.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp37.c: Likewise.\n+\n 2008-03-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR target/31334"}, {"sha": "06b567d43e34d571a88903de8f470cf880ade237", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp35.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c?ref=2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int test1(int i, int k)\n+{\n+  if (i > 0 && i <= 5 && k >= 10 && k < 42)\n+    {\n+      int j = i + 1 + k;\n+      return j == 10;\n+    }\n+  return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Folding predicate j_.* == 10 to 0\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "9d61960c7ae853fabb23ab62dca5cbba7025edc3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp36.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c?ref=2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int foo(int i)\n+{\n+  if (i < 0 || i >= 5)\n+    return i == 1;\n+  return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Folding predicate i_.* == 1 to 0\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "fba35a48bbfc4f33392fc84303f0416ad325a7e7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp37.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp37.c?ref=2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+unsigned char x;\n+int foo(void)\n+{\n+  unsigned long long i = x;\n+  i = i + 0x80000000;\n+  if (i > 0xffffffff)\n+    return x;\n+  return 0;\n+}"}, {"sha": "a70d1b6171764d9765c76961629b1534886ec2a1", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 227, "deletions": 54, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "patch": "@@ -71,6 +71,9 @@ struct assert_locus_d\n   /* Value being compared against.  */\n   tree val;\n \n+  /* Expression to compare.  */\n+  tree expr;\n+\n   /* Next node in the linked list.  */\n   struct assert_locus_d *next;\n };\n@@ -109,7 +112,11 @@ static int *vr_phi_edge_counts;\n static inline bool\n needs_overflow_infinity (const_tree type)\n {\n-  return INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type);\n+  return (INTEGRAL_TYPE_P (type)\n+\t  && !TYPE_OVERFLOW_WRAPS (type)\n+\t  /* Integer sub-types never overflow as they are never\n+\t     operands of arithmetic operators.  */\n+\t  && !(TREE_TYPE (type) && TREE_TYPE (type) != type));\n }\n \n /* Return whether TYPE can support our overflow infinity\n@@ -231,7 +238,12 @@ avoid_overflow_infinity (tree val)\n static inline bool\n vrp_val_is_max (const_tree val)\n {\n-  tree type_max = TYPE_MAX_VALUE (TREE_TYPE (val));\n+  tree type_max, type = TREE_TYPE (val);\n+\n+  /* For integer sub-types the values for the base type are relevant.  */\n+  if (TREE_TYPE (type))\n+    type = TREE_TYPE (type);\n+  type_max = TYPE_MAX_VALUE (type);\n \n   return (val == type_max\n \t  || (type_max != NULL_TREE\n@@ -244,7 +256,12 @@ vrp_val_is_max (const_tree val)\n static inline bool\n vrp_val_is_min (const_tree val)\n {\n-  tree type_min = TYPE_MIN_VALUE (TREE_TYPE (val));\n+  tree type_min, type = TREE_TYPE (val);\n+\n+  /* For integer sub-types the values for the base type are relevant.  */\n+  if (TREE_TYPE (type))\n+    type = TREE_TYPE (type);\n+  type_min = TYPE_MIN_VALUE (type);\n \n   return (val == type_min\n \t  || (type_min != NULL_TREE\n@@ -300,6 +317,18 @@ nonnull_arg_p (const_tree arg)\n }\n \n \n+/* Set value range VR to VR_VARYING.  */\n+\n+static inline void\n+set_value_range_to_varying (value_range_t *vr)\n+{\n+  vr->type = VR_VARYING;\n+  vr->min = vr->max = NULL_TREE;\n+  if (vr->equiv)\n+    bitmap_clear (vr->equiv);\n+}\n+\n+\n /* Set value range VR to {T, MIN, MAX, EQUIV}.  */\n \n static void\n@@ -352,24 +381,57 @@ set_value_range (value_range_t *vr, enum value_range_type t, tree min,\n }\n \n \n-/* Copy value range FROM into value range TO.  */\n+/* Set value range VR to the canonical form of {T, MIN, MAX, EQUIV}.\n+   This means adjusting T, MIN and MAX representing the case of a\n+   wrapping range with MAX < MIN covering [MIN, type_max] U [type_min, MAX]\n+   as anti-rage ~[MAX+1, MIN-1].  Likewise for wrapping anti-ranges.\n+   In corner cases where MAX+1 or MIN-1 wraps this will fall back\n+   to varying.\n+   This routine exists to ease canonicalization in the case where we\n+   extract ranges from var + CST op limit.  */\n \n-static inline void\n-copy_value_range (value_range_t *to, value_range_t *from)\n+static void\n+set_and_canonicalize_value_range (value_range_t *vr, enum value_range_type t,\n+\t\t\t\t  tree min, tree max, bitmap equiv)\n {\n-  set_value_range (to, from->type, from->min, from->max, from->equiv);\n-}\n+  tree one, tmp;\n \n+  if ((t != VR_RANGE\n+       && t != VR_ANTI_RANGE)\n+      || TREE_CODE (min) != INTEGER_CST\n+      || TREE_CODE (max) != INTEGER_CST\n+      || !tree_int_cst_lt (max, min))\n+    {\n+      set_value_range (vr, t, min, max, equiv);\n+      return;\n+    }\n \n-/* Set value range VR to VR_VARYING.  */\n+  /* Wrong order for min and max, to swap them and the VR type we need\n+     to adjust them.  */\n+  one = build_int_cst (TREE_TYPE (min), 1);\n+  tmp = int_const_binop (PLUS_EXPR, max, one, 0);\n+  max = int_const_binop (MINUS_EXPR, min, one, 0);\n+  min = tmp;\n+\n+  /* There's one corner case, if we had [C+1, C] before we now have\n+     that again.  But this represents an empty value range, so drop\n+     to varying in this case.  */\n+  if (tree_int_cst_lt (max, min))\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+\n+  t = t == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n+  set_value_range (vr, t, min, max, equiv);\n+}\n+\n+/* Copy value range FROM into value range TO.  */\n \n static inline void\n-set_value_range_to_varying (value_range_t *vr)\n+copy_value_range (value_range_t *to, value_range_t *from)\n {\n-  vr->type = VR_VARYING;\n-  vr->min = vr->max = NULL_TREE;\n-  if (vr->equiv)\n-    bitmap_clear (vr->equiv);\n+  set_value_range (to, from->type, from->min, from->max, from->equiv);\n }\n \n /* Set value range VR to a single value.  This function is only called\n@@ -1102,20 +1164,24 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n   gcc_assert (COMPARISON_CLASS_P (cond));\n \n   /* Find VAR in the ASSERT_EXPR conditional.  */\n-  if (var == TREE_OPERAND (cond, 0))\n+  if (var == TREE_OPERAND (cond, 0)\n+      || TREE_CODE (TREE_OPERAND (cond, 0)) == PLUS_EXPR\n+      || TREE_CODE (TREE_OPERAND (cond, 0)) == NOP_EXPR)\n     {\n       /* If the predicate is of the form VAR COMP LIMIT, then we just\n \t take LIMIT from the RHS and use the same comparison code.  */\n-      limit = TREE_OPERAND (cond, 1);\n       cond_code = TREE_CODE (cond);\n+      limit = TREE_OPERAND (cond, 1);\n+      cond = TREE_OPERAND (cond, 0);\n     }\n   else\n     {\n       /* If the predicate is of the form LIMIT COMP VAR, then we need\n \t to flip around the comparison code to create the proper range\n \t for VAR.  */\n-      limit = TREE_OPERAND (cond, 0);\n       cond_code = swap_tree_comparison (TREE_CODE (cond));\n+      limit = TREE_OPERAND (cond, 0);\n+      cond = TREE_OPERAND (cond, 1);\n     }\n \n   limit = avoid_overflow_infinity (limit);\n@@ -1159,8 +1225,43 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n      instance, ASSERT_EXPR <x_2, x_2 <= b_4>.  If b_4 is ~[2, 10],\n      then b_4 takes on the ranges [-INF, 1] and [11, +INF].  There is\n      no single range for x_2 that could describe LE_EXPR, so we might\n-     as well build the range [b_4, +INF] for it.  */\n-  if (cond_code == EQ_EXPR)\n+     as well build the range [b_4, +INF] for it.\n+     One special case we handle is extracting a range from a\n+     range test encoded as (unsigned)var + CST <= limit.  */\n+  if (TREE_CODE (cond) == NOP_EXPR\n+      || TREE_CODE (cond) == PLUS_EXPR)\n+    {\n+      tree cst2 = NULL_TREE;\n+\n+      if (TREE_CODE (cond) == PLUS_EXPR)\n+        {\n+          min = TREE_OPERAND (cond, 1);\n+\t  cst2 = fold_build1 (NEGATE_EXPR, TREE_TYPE (min), min);\n+          min = fold_convert (TREE_TYPE (var), cst2);\n+\t  cond = TREE_OPERAND (cond, 0);\n+\t}\n+      else\n+\tmin = build_int_cst (TREE_TYPE (var), 0);\n+\n+      if (cst2 != NULL_TREE)\n+        max = int_const_binop (PLUS_EXPR, limit, min, 0);\n+      else\n+\tmax = limit;\n+      max = fold_convert (TREE_TYPE (var), max);\n+\n+      /* We can transform a max, min range to an anti-range or\n+         vice-versa.  Use set_and_canonicalize_value_range which does\n+\t this for us.  */\n+      if (cond_code == LE_EXPR)\n+        set_and_canonicalize_value_range (vr_p, VR_RANGE,\n+\t\t\t\t\t  min, max, vr_p->equiv);\n+      else if (cond_code == GT_EXPR)\n+        set_and_canonicalize_value_range (vr_p, VR_ANTI_RANGE,\n+\t\t\t\t\t  min, max, vr_p->equiv);\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (cond_code == EQ_EXPR)\n     {\n       enum value_range_type range_type;\n \n@@ -3388,9 +3489,9 @@ debug_all_asserts (void)\n \n \n /* If NAME doesn't have an ASSERT_EXPR registered for asserting\n-   'NAME COMP_CODE VAL' at a location that dominates block BB or\n+   'EXPR COMP_CODE VAL' at a location that dominates block BB or\n    E->DEST, then register this location as a possible insertion point\n-   for ASSERT_EXPR <NAME, NAME COMP_CODE VAL>.\n+   for ASSERT_EXPR <NAME, EXPR COMP_CODE VAL>.\n \n    BB, E and SI provide the exact insertion point for the new\n    ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted\n@@ -3399,7 +3500,7 @@ debug_all_asserts (void)\n    must not be NULL.  */\n \n static void\n-register_new_assert_for (tree name,\n+register_new_assert_for (tree name, tree expr,\n \t\t\t enum tree_code comp_code,\n \t\t\t tree val,\n \t\t\t basic_block bb,\n@@ -3453,7 +3554,9 @@ register_new_assert_for (tree name,\n     {\n       if (loc->comp_code == comp_code\n \t  && (loc->val == val\n-\t      || operand_equal_p (loc->val, val, 0)))\n+\t      || operand_equal_p (loc->val, val, 0))\n+\t  && (loc->expr == expr\n+\t      || operand_equal_p (loc->expr, expr, 0)))\n \t{\n \t  /* If the assertion NAME COMP_CODE VAL has already been\n \t     registered at a basic block that dominates DEST_BB, then\n@@ -3500,6 +3603,7 @@ register_new_assert_for (tree name,\n   n->si = si;\n   n->comp_code = comp_code;\n   n->val = val;\n+  n->expr = expr;\n   n->next = NULL;\n \n   if (last_loc)\n@@ -3588,6 +3692,94 @@ extract_code_and_val_from_cond (tree name, tree cond, bool invert,\n   return true;\n }\n \n+/* Try to register an edge assertion for SSA name NAME on edge E for\n+   the condition COND contributing to the conditional jump pointed to by BSI.\n+   Invert the condition COND if INVERT is true.\n+   Return true if an assertion for NAME could be registered.  */\n+\n+static bool\n+register_edge_assert_for_2 (tree name, edge e, block_stmt_iterator bsi,\n+\t\t\t    tree cond, bool invert)\n+{\n+  tree val;\n+  enum tree_code comp_code;\n+  bool retval = false;\n+\n+  if (!extract_code_and_val_from_cond (name, cond, invert, &comp_code, &val))\n+    return false;\n+\n+  /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n+     reachable from E.  */\n+  if (TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name))\n+      && !has_single_use (name))\n+    {\n+      register_new_assert_for (name, name, comp_code, val, NULL, e, bsi);\n+      retval = true;\n+    }\n+\n+  /* In the case of NAME <= CST and NAME being defined as\n+     NAME = (unsigned) NAME2 + CST2 we can assert NAME2 >= -CST2\n+     and NAME2 <= CST - CST2.  We can do the same for NAME > CST.\n+     This catches range and anti-range tests.  */\n+  if ((comp_code == LE_EXPR\n+       || comp_code == GT_EXPR)\n+      && TREE_CODE (val) == INTEGER_CST\n+      && TYPE_UNSIGNED (TREE_TYPE (val)))\n+    {\n+      tree def_stmt = SSA_NAME_DEF_STMT (name);\n+      tree cst2 = NULL_TREE, name2 = NULL_TREE;\n+\n+      /* Extract CST2 from the (optional) addition.  */\n+      if (TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n+\t  && TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == PLUS_EXPR)\n+\t{\n+\t  name2 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n+\t  cst2 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 1);\n+\t  if (TREE_CODE (name2) == SSA_NAME\n+\t      && TREE_CODE (cst2) == INTEGER_CST)\n+\t    def_stmt = SSA_NAME_DEF_STMT (name2);\n+\t}\n+\n+      /* Extract NAME2 from the (optional) cast.  */\n+      if (TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n+          && TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == NOP_EXPR)\n+\tname2 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n+\n+      if (name2 != NULL_TREE\n+      \t  && TREE_CODE (name2) == SSA_NAME\n+\t  && (cst2 == NULL_TREE\n+\t      || TREE_CODE (cst2) == INTEGER_CST)\n+\t  && TREE_CODE (TREE_TYPE (name2)) == INTEGER_TYPE\n+\t  && TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name2))\n+\t  && !has_single_use (name2))\n+\t{\n+\t  tree tmp;\n+\n+\t  /* Build an expression for the range test.  */\n+\t  tmp = name2;\n+\t  if (TREE_TYPE (name) != TREE_TYPE (name2))\n+\t    tmp = build1 (NOP_EXPR, TREE_TYPE (name), tmp);\n+\t  if (cst2 != NULL_TREE)\n+\t    tmp = build2 (PLUS_EXPR, TREE_TYPE (name), tmp, cst2);\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Adding assert for \");\n+\t      print_generic_expr (dump_file, name2, 0);\n+\t      fprintf (dump_file, \" from \");\n+\t      print_generic_expr (dump_file, tmp, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  register_new_assert_for (name2, tmp, comp_code, val, NULL, e, bsi);\n+\n+\t  retval = true;\n+\t}\n+    }\n+\n+  return retval;\n+}\n+\n /* OP is an operand of a truth value expression which is known to have\n    a particular value.  Register any asserts for OP and for any\n    operands in OP's defining statement. \n@@ -3615,7 +3807,7 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n   if (!has_single_use (op))\n     {\n       val = build_int_cst (TREE_TYPE (op), 0);\n-      register_new_assert_for (op, code, val, NULL, e, bsi);\n+      register_new_assert_for (op, op, code, val, NULL, e, bsi);\n       retval = true;\n     }\n \n@@ -3634,26 +3826,10 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       tree op0 = TREE_OPERAND (rhs, 0);\n       tree op1 = TREE_OPERAND (rhs, 1);\n \n-      /* Conditionally register an assert for each SSA_NAME in the\n-\t comparison.  */\n-      if (TREE_CODE (op0) == SSA_NAME\n-\t  && !has_single_use (op0)\n-\t  && extract_code_and_val_from_cond (op0, rhs,\n-\t\t\t\t\t     invert, &code, &val))\n-\t{\n-\t  register_new_assert_for (op0, code, val, NULL, e, bsi);\n-\t  retval = true;\n-\t}\n-\n-      /* Similarly for the second operand of the comparison.  */\n-      if (TREE_CODE (op1) == SSA_NAME\n-\t  && !has_single_use (op1)\n-\t  && extract_code_and_val_from_cond (op1, rhs,\n-\t\t\t\t\t     invert, &code, &val))\n-\t{\n-\t  register_new_assert_for (op1, code, val, NULL, e, bsi);\n-\t  retval = true;\n-\t}\n+      if (TREE_CODE (op0) == SSA_NAME)\n+        retval |= register_edge_assert_for_2 (op0, e, bsi, rhs, invert);\n+      if (TREE_CODE (op1) == SSA_NAME)\n+        retval |= register_edge_assert_for_2 (op1, e, bsi, rhs, invert);\n     }\n   else if ((code == NE_EXPR\n \t    && (TREE_CODE (rhs) == TRUTH_AND_EXPR\n@@ -3713,13 +3889,9 @@ register_edge_assert_for (tree name, edge e, block_stmt_iterator si, tree cond)\n \t\t\t\t       &comp_code, &val))\n     return false;\n \n-  /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n-     reachable from E.  */\n-  if (TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name)))\n-    {\n-      register_new_assert_for (name, comp_code, val, NULL, e, si);\n-      retval = true;\n-    }\n+  /* Register ASSERT_EXPRs for name.  */\n+  retval |= register_edge_assert_for_2 (name, e, si, cond, is_else_edge);\n+\n \n   /* If COND is effectively an equality test of an SSA_NAME against\n      the value zero or one, then we may be able to assert values\n@@ -4126,7 +4298,7 @@ find_assert_locations (basic_block bb)\n \t\t\t conversion.  */\n \t\t      if (! has_single_use (t))\n \t\t\t{\n-\t\t\t  register_new_assert_for (t, comp_code, value,\n+\t\t\t  register_new_assert_for (t, t, comp_code, value,\n \t\t\t\t\t\t   bb, NULL, si);\n \t\t\t  need_assert = true;\n \t\t\t}\n@@ -4138,7 +4310,8 @@ find_assert_locations (basic_block bb)\n \t\t ASSERT_EXPR would do nothing but increase compile time.  */\n \t      if (!has_single_use (op))\n \t\t{\n-\t\t  register_new_assert_for (op, comp_code, value, bb, NULL, si);\n+\t\t  register_new_assert_for (op, op, comp_code, value,\n+\t\t\t\t\t   bb, NULL, si);\n \t\t  need_assert = true;\n \t\t}\n \t    }\n@@ -4183,7 +4356,7 @@ process_assert_insertions_for (tree name, assert_locus_t loc)\n   edge_iterator ei;\n   edge e;\n \n-  cond = build2 (loc->comp_code, boolean_type_node, name, loc->val);\n+  cond = build2 (loc->comp_code, boolean_type_node, loc->expr, loc->val);\n   assert_expr = build_assert_expr_for (cond, name);\n \n   if (loc->e)"}, {"sha": "70b5c652f0ff1fd67bf45ecd504d65a81bab171b", "filename": "gcc/tree.def", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8dbf48ee7c2eba910ee25ee37afd40e259738/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "patch": "@@ -937,8 +937,13 @@ DEFTREECODE (VALUE_HANDLE, \"value_handle\", tcc_exceptional, 0)\n    two things:\n \n    \t1- X is a copy of Y.\n-\t2- EXPR is a GIMPLE conditional expression (as defined by\n-\t   is_gimple_condexpr) and is known to be true.\n+\t2- EXPR is a conditional expression and is known to be true.\n+\n+   Valid and to be expected forms of conditional expressions are\n+   valid GIMPLE condidional expressions (as defined by is_gimple_condexpr)\n+   and conditional expressions with the first operand being a\n+   PLUS_EXPR with a variable possibly wrapped in a NOP_EXPR first\n+   operand and an integer constant second operand.\n \n    The type of the expression is the same as Y.  */\n DEFTREECODE (ASSERT_EXPR, \"assert_expr\", tcc_expression, 2)"}]}