{"sha": "21ced2776a117924e52f6aab8b41afb613fef0e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFjZWQyNzc2YTExNzkyNGU1MmY2YWFiOGI0MWFmYjYxM2ZlZjBlNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-03-15T09:32:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-03-15T09:32:52Z"}, "message": "Fortran: Fix problem with allocate initialization [PR99545].\n\n2021-03-15  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran/ChangeLog\n\n\tPR fortran/99545\n\t* trans-stmt.c (gfc_trans_allocate): Mark the initialization\n\tassignment by setting init_flag.\n\ngcc/testsuite/ChangeLog\n\n\tPR fortran/99545\n\t* gfortran.dg/pr99545.f90: New test.", "tree": {"sha": "4449d2ebb5e4e9e6fc0a88f6efe7fcf1d586225b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4449d2ebb5e4e9e6fc0a88f6efe7fcf1d586225b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21ced2776a117924e52f6aab8b41afb613fef0e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ced2776a117924e52f6aab8b41afb613fef0e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21ced2776a117924e52f6aab8b41afb613fef0e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ced2776a117924e52f6aab8b41afb613fef0e7/comments", "author": null, "committer": null, "parents": [{"sha": "f20fe2cb213dffba47ec1b62c625590b5bbe50d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20fe2cb213dffba47ec1b62c625590b5bbe50d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f20fe2cb213dffba47ec1b62c625590b5bbe50d7"}], "stats": {"total": 42, "additions": 41, "deletions": 1}, "files": [{"sha": "7cbdef7a30453ce8f1d81ea9267ae99d74677a78", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ced2776a117924e52f6aab8b41afb613fef0e7/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ced2776a117924e52f6aab8b41afb613fef0e7/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=21ced2776a117924e52f6aab8b41afb613fef0e7", "patch": "@@ -7001,7 +7001,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_expr *init_expr = gfc_expr_to_initialize (expr);\n \t  gfc_expr *rhs = e3rhs ? e3rhs : gfc_copy_expr (code->expr3);\n \t  flag_realloc_lhs = 0;\n-\t  tmp = gfc_trans_assignment (init_expr, rhs, false, false, true,\n+\t  tmp = gfc_trans_assignment (init_expr, rhs, true, false, true,\n \t\t\t\t      false);\n \t  flag_realloc_lhs = realloc_lhs;\n \t  /* Free the expression allocated for init_expr.  */"}, {"sha": "1b5ed5da29b838008350f9429473fc5afcc62138", "filename": "gcc/testsuite/gfortran.dg/pr99545.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ced2776a117924e52f6aab8b41afb613fef0e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99545.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ced2776a117924e52f6aab8b41afb613fef0e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99545.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99545.f90?ref=21ced2776a117924e52f6aab8b41afb613fef0e7", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! { dg-options \"-fcheck=mem\" }\n+!\n+! Test the fix for PR99545, in which the allocate statements caused an ICE.\n+!\n+! Contributed by Juergen Reuter  <juergen.reuter@desy.de>\n+!\n+module commands\n+  implicit none\n+  private\n+\n+  type, abstract :: range_t\n+     integer :: step_mode = 0\n+     integer :: n_step = 0\n+  end type range_t\n+\n+  type, extends (range_t) :: range_int_t\n+     integer :: i_step = 0\n+  end type range_int_t\n+\n+  type, extends (range_t) :: range_real_t\n+     real :: lr_step = 0\n+end type range_real_t\n+\n+  type :: cmd_scan_t\n+     private\n+     class(range_t), dimension(:), allocatable :: range\n+   contains\n+     procedure :: compile => cmd_scan_compile\n+  end type cmd_scan_t\n+\n+contains\n+\n+  subroutine cmd_scan_compile (cmd)\n+    class(cmd_scan_t), intent(inout) :: cmd\n+    allocate (range_int_t :: cmd%range (3))\n+    allocate (range_real_t :: cmd%range (3))\n+  end subroutine cmd_scan_compile\n+\n+end module commands"}]}