{"sha": "7993382ed00da10f470ccfe78d9f67301b0cdadd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk5MzM4MmVkMDBkYTEwZjQ3MGNjZmU3OGQ5ZjY3MzAxYjBjZGFkZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-03-03T21:55:25Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-03-03T21:55:25Z"}, "message": "re PR c++/9878 (error: non-lvalue in unary `&' wrongly issued)\n\n\tPR c++/9878\n\t* call.c (convert_class_to_reference): Correct conversion\n\tsequences.\n\t(reference_binding): Add ref_bound_directly_to_rvalue_p parameter.\n\t(implicit_conversion): Adjust call to reference_binding.\n\t(add_candidate): Change type of candidates parameter.\n\t(add_function_candidate): Likewise.\n\t(add_conv_candidate): Likewise.\n\t(build_builtin_candidate): Likewise.\n\t(add_builtin_candidate): Likewise.\n\t(add_builtin_candidates): Likewise.\n\t(add_template_candidate_real): Likewise.\n\t(add_template_candidate): Likewise.\n\t(add_template_conv_candidate): Likewise.\n\t(build_user_type_conversion_1): Adjust accordingly.\n\t(build_object_call): Likewise.\n\t(build_conditional_expr): Likewise.\n\t(add_candidates): Likewise.\n\t(build_new_op): Likewise.\n\t(convert_like_real): Use USER_CONV_CAND.  Use build_nop.\n\t(build_new_method_call): Adjust calls to add_function_candidate.\n\t(make_temporary_var_for_ref_to_temp): New function.\n\t(initialize_reference): Add decl parameter.\n\t* class.c (build_rtti_vtbl_entries): Use build_address and\n\tbuild_nop.\n\t* cp-tree.h (initialize_reference): Change prototype.\n\t(make_temporary_var_for_ref_to_temp): New function.\n\t(build_type_conversion): Change prototype.\n\t(build_address): New function.\n\t(build_nop): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Adjust call to\n\tbuild_type_conversion.  Avoid indicating redundant NOP_EXPRs.\n\tUse build_nop.\n\t(convert_to_pointer_force): Use build_nop.\n\t(build_up_reference): Use make_temporary_var_for_ref_to_temp.\n\t(convert_to_reference): Adjust call to build_type_conversion.\n\t(ocp_convert): Likewise.\n\t(build_type_conversion): Remove for_sure parameter.\n\t* decl.c (grok_reference_init): Use initialize_reference.\n\t* typeck.c (build_address): New function.\n\t(build_nop): Likewise.\n\t(build_unary_op): Use them.\n\t(build_ptrmemfunc): Tidy slightly.\n\t(convert_for_initialization): Adjust call to\n\tinitialize_reference.\n\t* typeck2.c (store_init_value): Remove #if 0'd code.\n\n\tPR c++/9878\n\t* g++.dg/init/ref1.C: New test.\n\nFrom-SVN: r63735", "tree": {"sha": "843f3d43d5b4320d2aeb9c7f379499f22788a521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/843f3d43d5b4320d2aeb9c7f379499f22788a521"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7993382ed00da10f470ccfe78d9f67301b0cdadd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7993382ed00da10f470ccfe78d9f67301b0cdadd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7993382ed00da10f470ccfe78d9f67301b0cdadd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7993382ed00da10f470ccfe78d9f67301b0cdadd/comments", "author": null, "committer": null, "parents": [{"sha": "03275f8132e42ba83689b3a23a4518b4365e8f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03275f8132e42ba83689b3a23a4518b4365e8f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03275f8132e42ba83689b3a23a4518b4365e8f9e"}], "stats": {"total": 798, "additions": 462, "deletions": 336}, "files": [{"sha": "a53dd456336da09acac947c3d8f7ea7fa3ebaab8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -1,3 +1,52 @@\n+2003-03-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9878\n+\t* call.c (convert_class_to_reference): Correct conversion\n+\tsequences.\n+\t(reference_binding): Add ref_bound_directly_to_rvalue_p parameter.\n+\t(implicit_conversion): Adjust call to reference_binding.\n+\t(add_candidate): Change type of candidates parameter.\n+\t(add_function_candidate): Likewise.\n+\t(add_conv_candidate): Likewise.\n+\t(build_builtin_candidate): Likewise.\n+\t(add_builtin_candidate): Likewise.\n+\t(add_builtin_candidates): Likewise.\n+\t(add_template_candidate_real): Likewise.\n+\t(add_template_candidate): Likewise.\n+\t(add_template_conv_candidate): Likewise.\n+\t(build_user_type_conversion_1): Adjust accordingly.\n+\t(build_object_call): Likewise.\n+\t(build_conditional_expr): Likewise.\n+\t(add_candidates): Likewise.\n+\t(build_new_op): Likewise.\n+\t(convert_like_real): Use USER_CONV_CAND.  Use build_nop.\n+\t(build_new_method_call): Adjust calls to add_function_candidate.\n+\t(make_temporary_var_for_ref_to_temp): New function.\n+\t(initialize_reference): Add decl parameter.\n+\t* class.c (build_rtti_vtbl_entries): Use build_address and\n+\tbuild_nop.\n+\t* cp-tree.h (initialize_reference): Change prototype.\n+\t(make_temporary_var_for_ref_to_temp): New function.\n+\t(build_type_conversion): Change prototype.\n+\t(build_address): New function.\n+\t(build_nop): Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Adjust call to\n+\tbuild_type_conversion.  Avoid indicating redundant NOP_EXPRs.\n+\tUse build_nop.\n+\t(convert_to_pointer_force): Use build_nop.\n+\t(build_up_reference): Use make_temporary_var_for_ref_to_temp.\n+\t(convert_to_reference): Adjust call to build_type_conversion.\n+\t(ocp_convert): Likewise.\n+\t(build_type_conversion): Remove for_sure parameter.\n+\t* decl.c (grok_reference_init): Use initialize_reference.\n+\t* typeck.c (build_address): New function.\n+\t(build_nop): Likewise.\n+\t(build_unary_op): Use them.\n+\t(build_ptrmemfunc): Tidy slightly.\n+\t(convert_for_initialization): Adjust call to\n+\tinitialize_reference.\n+\t* typeck2.c (store_init_value): Remove #if 0'd code.\n+\t\n 2003-03-03  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (start_function): Clear DECL_NUM_STMTS."}, {"sha": "d59a320f28108b78ac3f9c8fa9ac731c5a641365", "filename": "gcc/cp/call.c", "status": "modified", "additions": 316, "deletions": 218, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -62,37 +62,37 @@ static struct z_candidate *splice_viable (struct z_candidate *);\n static bool any_viable (struct z_candidate *);\n static bool any_strictly_viable (struct z_candidate *);\n static struct z_candidate *add_template_candidate\n-        (struct z_candidate *, tree, tree, tree, tree, tree, \n+        (struct z_candidate **, tree, tree, tree, tree, tree, \n          tree, tree, int, unification_kind_t);\n static struct z_candidate *add_template_candidate_real\n-\t(struct z_candidate *, tree, tree, tree, tree, tree, \n+\t(struct z_candidate **, tree, tree, tree, tree, tree, \n            tree, tree, int, tree, unification_kind_t);\n static struct z_candidate *add_template_conv_candidate \n-        (struct z_candidate *, tree, tree, tree, tree, tree, tree);\n-static struct z_candidate *add_builtin_candidates\n-\t(struct z_candidate *, enum tree_code, enum tree_code,\n+        (struct z_candidate **, tree, tree, tree, tree, tree, tree);\n+static void add_builtin_candidates\n+\t(struct z_candidate **, enum tree_code, enum tree_code,\n \t       tree, tree *, int);\n-static struct z_candidate *add_builtin_candidate\n-\t(struct z_candidate *, enum tree_code, enum tree_code,\n+static void add_builtin_candidate\n+\t(struct z_candidate **, enum tree_code, enum tree_code,\n \t       tree, tree, tree, tree *, tree *, int);\n static bool is_complete (tree);\n-static struct z_candidate *build_builtin_candidate \n-\t(struct z_candidate *, tree, tree, tree, tree *, tree *,\n+static void build_builtin_candidate \n+\t(struct z_candidate **, tree, tree, tree, tree *, tree *,\n \t       int);\n static struct z_candidate *add_conv_candidate \n-\t(struct z_candidate *, tree, tree, tree, tree, tree);\n+\t(struct z_candidate **, tree, tree, tree, tree, tree);\n static struct z_candidate *add_function_candidate \n-\t(struct z_candidate *, tree, tree, tree, tree, tree, int);\n+\t(struct z_candidate **, tree, tree, tree, tree, tree, int);\n static tree implicit_conversion (tree, tree, tree, int);\n static tree standard_conversion (tree, tree, tree);\n-static tree reference_binding (tree, tree, tree, int);\n+static tree reference_binding (tree, tree, tree, int, bool *);\n static tree non_reference (tree);\n static tree build_conv (enum tree_code, tree, tree);\n static bool is_subseq (tree, tree);\n static tree maybe_handle_ref_bind (tree *);\n static void maybe_handle_implicit_object (tree *);\n static struct z_candidate *add_candidate \n-        (struct z_candidate *, tree, tree, tree, tree, tree, int);\n+        (struct z_candidate **, tree, tree, tree, tree, tree, int);\n static tree source_type (tree);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n static bool reference_related_p (tree, tree);\n@@ -104,8 +104,8 @@ static tree conditional_conversion (tree, tree);\n static char *name_as_c_string (tree, tree, bool *);\n static tree call_builtin_trap (void);\n static tree prep_operand (tree);\n-static struct z_candidate *add_candidates (tree, tree, tree, tree,\n-\t\t\t\t\t   int, struct z_candidate *);\n+static void add_candidates (tree, tree, tree, tree,\n+\t\t\t    int, struct z_candidate **);\n \n tree\n build_vfield_ref (tree datum, tree type)\n@@ -949,9 +949,14 @@ convert_class_to_reference (tree t, tree s, tree expr)\n   tree conversions;\n   tree arglist;\n   tree conv;\n+  tree reference_type;\n   struct z_candidate *candidates;\n   struct z_candidate *cand;\n \n+  conversions = lookup_conversions (s);\n+  if (!conversions)\n+    return NULL_TREE;\n+\n   /* [over.match.ref]\n \n      Assuming that \"cv1 T\" is the underlying type of the reference\n@@ -977,55 +982,69 @@ convert_class_to_reference (tree t, tree s, tree expr)\n   arglist = build_int_2 (0, 0);\n   TREE_TYPE (arglist) = build_pointer_type (s);\n   arglist = build_tree_list (NULL_TREE, arglist);\n-  \n-  for (conversions = lookup_conversions (s);\n-       conversions;\n-       conversions = TREE_CHAIN (conversions))\n+\n+  reference_type = build_reference_type (t);\n+\n+  while (conversions)\n     {\n       tree fns = TREE_VALUE (conversions);\n \n       for (; fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree f = OVL_CURRENT (fns);\n \t  tree t2 = TREE_TYPE (TREE_TYPE (f));\n-\t  struct z_candidate *old_candidates = candidates;\n+\t  \n+\t  cand = NULL;\n \n \t  /* If this is a template function, try to get an exact\n              match.  */\n \t  if (TREE_CODE (f) == TEMPLATE_DECL)\n \t    {\n-\t      candidates \n-\t\t= add_template_candidate (candidates,\n-\t\t\t\t\t  f, s,\n-\t\t\t\t\t  NULL_TREE,\n-\t\t\t\t\t  arglist,\n-\t\t\t\t\t  build_reference_type (t),\n-\t\t\t\t\t  TYPE_BINFO (s),\n-\t\t\t\t\t  TREE_PURPOSE (conversions),\n-\t\t\t\t\t  LOOKUP_NORMAL,\n-\t\t\t\t\t  DEDUCE_CONV);\n+\t      cand = add_template_candidate (&candidates,\n+\t\t\t\t\t     f, s,\n+\t\t\t\t\t     NULL_TREE,\n+\t\t\t\t\t     arglist,\n+\t\t\t\t\t     reference_type,\n+\t\t\t\t\t     TYPE_BINFO (s),\n+\t\t\t\t\t     TREE_PURPOSE (conversions),\n+\t\t\t\t\t     LOOKUP_NORMAL,\n+\t\t\t\t\t     DEDUCE_CONV);\n \t      \n-\t      if (candidates != old_candidates)\n+\t      if (cand)\n \t\t{\n \t\t  /* Now, see if the conversion function really returns\n \t\t     an lvalue of the appropriate type.  From the\n \t\t     point of view of unification, simply returning an\n \t\t     rvalue of the right type is good enough.  */\n-\t\t  f = candidates->fn;\n+\t\t  f = cand->fn;\n \t\t  t2 = TREE_TYPE (TREE_TYPE (f));\n \t\t  if (TREE_CODE (t2) != REFERENCE_TYPE\n \t\t      || !reference_compatible_p (t, TREE_TYPE (t2)))\n-\t\t    candidates = candidates->next;\n+\t\t    {\n+\t\t      candidates = candidates->next;\n+\t\t      cand = NULL;\n+\t\t    }\n \t\t}\n \t    }\n \t  else if (TREE_CODE (t2) == REFERENCE_TYPE\n \t\t   && reference_compatible_p (t, TREE_TYPE (t2)))\n-\t    candidates \n-\t      = add_function_candidate (candidates, f, s, arglist, \n-\t\t\t\t\tTYPE_BINFO (s), \t\n-\t\t\t\t\tTREE_PURPOSE (conversions),\n-\t\t\t\t\tLOOKUP_NORMAL);\n+\t    cand = add_function_candidate (&candidates, f, s, arglist, \n+\t\t\t\t\t   TYPE_BINFO (s), \t\n+\t\t\t\t\t   TREE_PURPOSE (conversions),\n+\t\t\t\t\t   LOOKUP_NORMAL);\n+\t  \n+\t  if (cand)\n+\t    {\n+\t      conv = build1 (IDENTITY_CONV, s, expr);\n+\t      conv = build_conv (USER_CONV, TREE_TYPE (TREE_TYPE (cand->fn)),\n+\t\t\t\t conv);\n+\t      TREE_OPERAND (conv, 1) = build_zc_wrapper (cand);\n+\t      ICS_USER_FLAG (conv) = 1;\n+\t      cand->second_conv\n+\t\t= direct_reference_binding (reference_type, conv);\n+\t    }\n \t}\n+      conversions = TREE_CHAIN (conversions);\n     }\n \n   /* If none of the conversion functions worked out, let our caller\n@@ -1044,15 +1063,10 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t\t\t  build_this (expr),\n \t\t\t  TREE_CHAIN (cand->args));\n \n-  conv = build1 (IDENTITY_CONV, s, expr);\n-  conv = build_conv (USER_CONV, TREE_TYPE (TREE_TYPE (cand->fn)),\n-\t\t     conv);\n-  TREE_OPERAND (conv, 1) = build_zc_wrapper (cand);\n-  ICS_USER_FLAG (conv) = 1;\n+  conv = cand->second_conv;\n   if (cand->viable == -1)\n     ICS_BAD_FLAG (conv) = 1;\n-  cand->second_conv = conv;\n-\n+  \n   return conv;\n }\n \n@@ -1097,10 +1111,14 @@ direct_reference_binding (tree type, tree conv)\n    purposes of reference binding.  For lvalue binding, either pass a\n    reference type to FROM or an lvalue expression to EXPR.  If the\n    reference will be bound to a temporary, NEED_TEMPORARY_P is set for\n-   the conversion returned.  */\n+   the conversion returned.  If non-NULL,\n+   *REF_BOUND_DIRECTLY_TO_RVALUE_P is set to true if and only if the\n+   conversion sequence returned binds the reference directly to an\n+   rvalue.  */\n \n static tree\n-reference_binding (tree rto, tree rfrom, tree expr, int flags)\n+reference_binding (tree rto, tree rfrom, tree expr, int flags,\n+\t\t   bool *ref_bound_directly_to_rvalue_p)\n {\n   tree conv = NULL_TREE;\n   tree to = TREE_TYPE (rto);\n@@ -1109,6 +1127,10 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n   bool compatible_p;\n   cp_lvalue_kind lvalue_p = clk_none;\n \n+  /* Assume that the reference is not bound directly to an rvalue.  */\n+  if (ref_bound_directly_to_rvalue_p)\n+    *ref_bound_directly_to_rvalue_p = false;\n+\n   if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))\n     {\n       expr = instantiate_type (to, expr, tf_none);\n@@ -1178,7 +1200,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n \tin the second case.  */\n       conv = convert_class_to_reference (to, from, expr);\n       if (conv)\n-\treturn direct_reference_binding (rto, conv);\n+\treturn conv;\n     }\n \n   /* From this point on, we conceptually need temporaries, even if we\n@@ -1219,6 +1241,8 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n      for direct binding.  */\n   if (CLASS_TYPE_P (from) && compatible_p)\n     {\n+      if (ref_bound_directly_to_rvalue_p)\n+\t*ref_bound_directly_to_rvalue_p = true;\n       conv = build1 (IDENTITY_CONV, from, expr);\n       return direct_reference_binding (rto, conv);\n     }\n@@ -1254,7 +1278,6 @@ static tree\n implicit_conversion (tree to, tree from, tree expr, int flags)\n {\n   tree conv;\n-  struct z_candidate *cand;\n \n   /* Resolve expressions like `A::p' that we thought might become\n      pointers-to-members.  */\n@@ -1274,7 +1297,8 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n   complete_type (to);\n \n   if (TREE_CODE (to) == REFERENCE_TYPE)\n-    conv = reference_binding (to, from, expr, flags);\n+    conv = reference_binding (to, from, expr, flags, \n+\t\t\t      /*ref_bound_directly_to_rvalue_p=*/NULL);\n   else\n     conv = standard_conversion (to, from, expr);\n \n@@ -1286,6 +1310,8 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n \t  || IS_AGGR_TYPE (to))\n       && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n+      struct z_candidate *cand;\n+\n       cand = build_user_type_conversion_1\n \t(to, expr, LOOKUP_ONLYCONVERTING);\n       if (cand)\n@@ -1304,7 +1330,7 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n    functions.  */\n \n static struct z_candidate *\n-add_candidate (struct z_candidate *candidates, \n+add_candidate (struct z_candidate **candidates, \n \t       tree fn, tree args, tree convs, tree access_path, \n \t       tree conversion_path, int viable)\n {\n@@ -1317,7 +1343,8 @@ add_candidate (struct z_candidate *candidates,\n   cand->access_path = access_path;\n   cand->conversion_path = conversion_path;\n   cand->viable = viable;\n-  cand->next = candidates;\n+  cand->next = *candidates;\n+  *candidates = cand;\n \n   return cand;\n }\n@@ -1330,7 +1357,7 @@ add_candidate (struct z_candidate *candidates,\n    comes from for purposes of overload resolution.  */\n \n static struct z_candidate *\n-add_function_candidate (struct z_candidate *candidates, \n+add_function_candidate (struct z_candidate **candidates, \n \t\t\ttree fn, tree ctype, tree arglist, \n \t\t\ttree access_path, tree conversion_path,\n \t\t\tint flags)\n@@ -1465,7 +1492,7 @@ add_function_candidate (struct z_candidate *candidates,\n    instead of the function.  */\n \n static struct z_candidate *\n-add_conv_candidate (struct z_candidate *candidates, tree fn, tree obj,\n+add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n                     tree arglist, tree access_path, tree conversion_path)\n {\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n@@ -1484,8 +1511,8 @@ add_conv_candidate (struct z_candidate *candidates, tree fn, tree obj,\n   flags = LOOKUP_NORMAL;\n \n   /* Don't bother looking up the same type twice.  */\n-  if (candidates && candidates->fn == totype)\n-    return candidates;\n+  if (*candidates && (*candidates)->fn == totype)\n+    return NULL;\n \n   for (i = 0; i < len; ++i)\n     {\n@@ -1530,8 +1557,8 @@ add_conv_candidate (struct z_candidate *candidates, tree fn, tree obj,\n \t\t\tconversion_path, viable);\n }\n \n-static struct z_candidate *\n-build_builtin_candidate (struct z_candidate *candidates, tree fnname,\n+static void\n+build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n                          tree type1, tree type2, tree *args, tree *argtypes,\n                          int flags)\n {\n@@ -1573,10 +1600,10 @@ build_builtin_candidate (struct z_candidate *candidates, tree fnname,\n \tviable = 0;\n     }      \n \n-  return add_candidate (candidates, fnname, /*args=*/NULL_TREE, convs, \n-\t\t\t/*access_path=*/NULL_TREE,\n-\t\t\t/*conversion_path=*/NULL_TREE,\n-\t\t\tviable);\n+  add_candidate (candidates, fnname, /*args=*/NULL_TREE, convs, \n+\t\t /*access_path=*/NULL_TREE,\n+\t\t /*conversion_path=*/NULL_TREE,\n+\t\t viable);\n }\n \n static bool\n@@ -1612,8 +1639,8 @@ promoted_arithmetic_type_p (tree type)\n    of which TYPE1 and TYPE2 are, we add both candidates\n    CODE (TYPE1, TYPE1) and CODE (TYPE2, TYPE2).  */\n \n-static struct z_candidate *\n-add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n+static void\n+add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n                        enum tree_code code2, tree fnname, tree type1,\n                        tree type2, tree *args, tree *argtypes, int flags)\n {\n@@ -1652,15 +1679,15 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n     case POSTDECREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n       if (TREE_CODE (type1) == BOOLEAN_TYPE)\n-\treturn candidates;\n+\treturn;\n     case POSTINCREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n       if (ARITHMETIC_TYPE_P (type1) || TYPE_PTROB_P (type1))\n \t{\n \t  type1 = build_reference_type (type1);\n \t  break;\n \t}\n-      return candidates;\n+      return;\n \n /* 7 For every cv-qualified or cv-unqualified complete object type T, there\n      exist candidate operator functions of the form\n@@ -1676,7 +1703,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \t  && (TYPE_PTROB_P (type1)\n \t      || TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE))\n \tbreak;\n-      return candidates;\n+      return; \n \n /* 9 For every type T, there exist candidate operator functions of the form\n \t     T*      operator+(T*);\n@@ -1693,7 +1720,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n     case NEGATE_EXPR:\n       if (ARITHMETIC_TYPE_P (type1))\n \tbreak;\n-      return candidates;\n+      return;\n \n /* 11For every promoted integral type T,  there  exist  candidate  operator\n      functions of the form\n@@ -1702,7 +1729,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n     case BIT_NOT_EXPR:\n       if (INTEGRAL_TYPE_P (type1))\n \tbreak;\n-      return candidates;\n+      return;\n \n /* 12For every quintuple C1, C2, T, CV1, CV2), where C2 is a class type, C1\n      is the same type as C2 or is a derived class of C2, T  is  a  complete\n@@ -1725,7 +1752,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \t\t  || is_complete (TREE_TYPE (TREE_TYPE (type2)))))\n \t    break;\n \t}\n-      return candidates;\n+      return;\n \n /* 13For every pair of promoted arithmetic types L and R, there exist  can-\n      didate operator functions of the form\n@@ -1781,7 +1808,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n     case TRUNC_DIV_EXPR:\n       if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n \tbreak;\n-      return candidates;\n+      return;\n \n     case EQ_EXPR:\n     case NE_EXPR:\n@@ -1823,7 +1850,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \t  type1 = type2;\n \t  break;\n \t}\n-      return candidates;\n+      return;\n \n     case PLUS_EXPR:\n       if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n@@ -1839,7 +1866,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \t  type2 = ptrdiff_type_node;\n \t  break;\n \t}\n-      return candidates;\n+      return;\n \n /* 18For  every pair of promoted integral types L and R, there exist candi-\n      date operator functions of the form\n@@ -1860,7 +1887,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n     case RSHIFT_EXPR:\n       if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n \tbreak;\n-      return candidates;\n+      return;\n \n /* 19For  every  triple  L, VQ, R), where L is an arithmetic or enumeration\n      type, VQ is either volatile or empty, and R is a  promoted  arithmetic\n@@ -1912,7 +1939,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \tcase TRUNC_DIV_EXPR:\n \t  if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n \t    break;\n-\t  return candidates;\n+\t  return;\n \n \tcase TRUNC_MOD_EXPR:\n \tcase BIT_AND_EXPR:\n@@ -1922,7 +1949,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \tcase RSHIFT_EXPR:\n \t  if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n \t    break;\n-\t  return candidates;\n+\t  return;\n \n \tcase NOP_EXPR:\n \t  if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n@@ -1937,7 +1964,7 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \t      type2 = type1;\n \t      break;\n \t    }\n-\t  return candidates;\n+\t  return;\n \n \tdefault:\n \t  abort ();\n@@ -1972,16 +1999,13 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \t  || !(TREE_CODE (type2) == POINTER_TYPE\n \t       || TYPE_PTRMEM_P (type2)\n \t       || TYPE_PTRMEMFUNC_P (type2)))\n-\treturn candidates;\n+\treturn;\n       \n       /* We don't check that the two types are the same; the logic\n \t below will actually create two candidates; one in which both\n \t parameter types are TYPE1, and one in which both parameter\n \t types are TYPE2.  */\n-\tbreak;\n-\n-      /* These arguments do not make for a valid overloaded operator.  */\n-      return candidates;\n+      break;\n \n     default:\n       abort ();\n@@ -1998,13 +2022,14 @@ add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n \t  || IS_AGGR_TYPE (type1)\n \t  || TREE_CODE (type1) == ENUMERAL_TYPE))\n     {\n-      candidates = build_builtin_candidate\n+      build_builtin_candidate\n \t(candidates, fnname, type1, type1, args, argtypes, flags);\n-      return build_builtin_candidate\n+      build_builtin_candidate\n \t(candidates, fnname, type2, type2, args, argtypes, flags);\n+      return;\n     }\n \n-  return build_builtin_candidate\n+  build_builtin_candidate\n     (candidates, fnname, type1, type2, args, argtypes, flags);\n }\n \n@@ -2031,8 +2056,8 @@ type_decays_to (tree type)\n    other cases which the standard disallows. add_builtin_candidate will\n    filter out the invalid set.  */\n \n-static struct z_candidate *\n-add_builtin_candidates (struct z_candidate *candidates, enum tree_code code,\n+static void\n+add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n                         enum tree_code code2, tree fnname, tree *args,\n                         int flags)\n {\n@@ -2074,20 +2099,22 @@ add_builtin_candidates (struct z_candidate *candidates, enum tree_code code,\n \t     bool    operator||(bool, bool);  */\n \n     case TRUTH_NOT_EXPR:\n-      return build_builtin_candidate\n+      build_builtin_candidate\n \t(candidates, fnname, boolean_type_node,\n \t NULL_TREE, args, argtypes, flags);\n+      return;\n \n     case TRUTH_ORIF_EXPR:\n     case TRUTH_ANDIF_EXPR:\n-      return build_builtin_candidate\n+      build_builtin_candidate\n \t(candidates, fnname, boolean_type_node,\n \t boolean_type_node, args, argtypes, flags);\n+      return;\n \n     case ADDR_EXPR:\n     case COMPOUND_EXPR:\n     case COMPONENT_REF:\n-      return candidates;\n+      return;\n \n     case COND_EXPR:\n     case EQ_EXPR:\n@@ -2114,7 +2141,7 @@ add_builtin_candidates (struct z_candidate *candidates, enum tree_code code,\n \t  tree convs;\n \n \t  if (i == 0 && code == MODIFY_EXPR && code2 == NOP_EXPR)\n-\t    return candidates;\n+\t    return;\n \n \t  convs = lookup_conversions (argtypes[i]);\n \n@@ -2129,7 +2156,7 @@ add_builtin_candidates (struct z_candidate *candidates, enum tree_code code,\n \t    }\n \n \t  else if (! convs)\n-\t    return candidates;\n+\t    return;\n \n \t  for (; convs; convs = TREE_CHAIN (convs))\n \t    {\n@@ -2181,16 +2208,16 @@ add_builtin_candidates (struct z_candidate *candidates, enum tree_code code,\n     {\n       if (types[1])\n \tfor (type = types[1]; type; type = TREE_CHAIN (type))\n-\t  candidates = add_builtin_candidate\n+\t  add_builtin_candidate\n \t    (candidates, code, code2, fnname, TREE_VALUE (types[0]),\n \t     TREE_VALUE (type), args, argtypes, flags);\n       else\n-\tcandidates = add_builtin_candidate\n+\tadd_builtin_candidate\n \t  (candidates, code, code2, fnname, TREE_VALUE (types[0]),\n \t   NULL_TREE, args, argtypes, flags);\n     }\n \n-  return candidates;\n+  return;\n }\n \n \n@@ -2205,7 +2232,7 @@ add_builtin_candidates (struct z_candidate *candidates, enum tree_code code,\n    add_conv_candidate.  */\n \n static struct z_candidate*\n-add_template_candidate_real (struct z_candidate *candidates, tree tmpl,\n+add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n                              tree ctype, tree explicit_targs, tree arglist,\n                              tree return_type, tree access_path,\n \t\t\t     tree conversion_path, int flags, tree obj,\n@@ -2233,11 +2260,11 @@ add_template_candidate_real (struct z_candidate *candidates, tree tmpl,\n \t\t\t   return_type, strict, -1);\n \n   if (i != 0)\n-    return candidates;\n+    return NULL;\n \n   fn = instantiate_template (tmpl, targs);\n   if (fn == error_mark_node)\n-    return candidates;\n+    return NULL;\n \n   /* In [class.copy]:\n \n@@ -2266,7 +2293,7 @@ add_template_candidate_real (struct z_candidate *candidates, tree tmpl,\n       tree arg_types = FUNCTION_FIRST_USER_PARMTYPE (fn);\n       if (arg_types && same_type_p (TYPE_MAIN_VARIANT (TREE_VALUE (arg_types)),\n \t\t\t\t    ctype))\n-\treturn candidates;\n+\treturn NULL;\n     }\n \n   if (obj != NULL_TREE)\n@@ -2304,7 +2331,7 @@ add_template_candidate_real (struct z_candidate *candidates, tree tmpl,\n \n \n static struct z_candidate *\n-add_template_candidate (struct z_candidate *candidates, tree tmpl, tree ctype,\n+add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n                         tree explicit_targs, tree arglist, tree return_type,\n                         tree access_path, tree conversion_path, int flags,\n                         unification_kind_t strict)\n@@ -2318,7 +2345,7 @@ add_template_candidate (struct z_candidate *candidates, tree tmpl, tree ctype,\n \n \n static struct z_candidate *\n-add_template_conv_candidate (struct z_candidate *candidates, tree tmpl,\n+add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,\n                              tree obj, tree arglist, tree return_type,\n \t\t\t     tree access_path, tree conversion_path)\n {\n@@ -2454,21 +2481,20 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \tcontinue;\n \n       if (TREE_CODE (ctor) == TEMPLATE_DECL) \n-\tcandidates = \n-\t  add_template_candidate (candidates, ctor, totype,\n-\t\t\t\t  NULL_TREE, args, NULL_TREE, \n-\t\t\t\t  TYPE_BINFO (totype),\n-\t\t\t\t  TYPE_BINFO (totype),\n-\t\t\t\t  flags,\n-\t\t\t\t  DEDUCE_CALL);\n+\tcand = add_template_candidate (&candidates, ctor, totype,\n+\t\t\t\t       NULL_TREE, args, NULL_TREE, \n+\t\t\t\t       TYPE_BINFO (totype),\n+\t\t\t\t       TYPE_BINFO (totype),\n+\t\t\t\t       flags,\n+\t\t\t\t       DEDUCE_CALL);\n       else \n-\tcandidates = add_function_candidate (candidates, ctor, totype,\n-\t\t\t\t\t     args, TYPE_BINFO (totype), \n-\t\t\t\t\t     TYPE_BINFO (totype),\n-\t\t\t\t\t     flags); \n+\tcand = add_function_candidate (&candidates, ctor, totype,\n+\t\t\t\t       args, TYPE_BINFO (totype), \n+\t\t\t\t       TYPE_BINFO (totype),\n+\t\t\t\t       flags); \n \n-      if (candidates) \n-\tcandidates->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n+      if (cand)\n+\tcand->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n     }\n \n   if (convs)\n@@ -2490,7 +2516,6 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       for (fns = TREE_VALUE (convs); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n-\t  struct z_candidate *old_candidates = candidates;\n \t  \n \t  /* [over.match.funcs] For conversion functions, the function\n \t     is considered to be a member of the class of the implicit\n@@ -2500,31 +2525,32 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t     So we pass fromtype as CTYPE to add_*_candidate.  */\n \n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    candidates = \n-\t      add_template_candidate (candidates, fn, fromtype, NULL_TREE,\n-\t\t\t\t      args, totype, TYPE_BINFO (fromtype), \n-\t\t\t\t      conversion_path,\n-\t\t\t\t      flags,\n-\t\t\t\t      DEDUCE_CONV);\n+\t    cand = add_template_candidate (&candidates, fn, fromtype, \n+\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t   args, totype, \n+\t\t\t\t\t   TYPE_BINFO (fromtype), \n+\t\t\t\t\t   conversion_path,\n+\t\t\t\t\t   flags,\n+\t\t\t\t\t   DEDUCE_CONV);\n \t  else \n-\t    candidates = add_function_candidate (candidates, fn, fromtype,\n-\t\t\t\t\t\t args,\n-\t\t\t\t\t\t TYPE_BINFO (fromtype),\n-\t\t\t\t\t\t conversion_path,\n-\t\t\t\t\t\t flags); \n+\t    cand = add_function_candidate (&candidates, fn, fromtype,\n+\t\t\t\t\t   args,\n+\t\t\t\t\t   TYPE_BINFO (fromtype),\n+\t\t\t\t\t   conversion_path,\n+\t\t\t\t\t   flags); \n \n-\t  if (candidates != old_candidates)\n+\t  if (cand)\n \t    {\n-\t      tree ics = implicit_conversion\n-\t\t(totype, TREE_TYPE (TREE_TYPE (candidates->fn)),\n-\t\t 0, convflags);\n+\t      tree ics = implicit_conversion (totype, \n+\t\t\t\t\t      TREE_TYPE (TREE_TYPE (cand->fn)),\n+\t\t\t\t\t      0, convflags);\n \n-\t      candidates->second_conv = ics;\n+\t      cand->second_conv = ics;\n \t      \n \t      if (ics == NULL_TREE)\n-\t\tcandidates->viable = 0;\n+\t\tcand->viable = 0;\n \t      else if (candidates->viable == 1 && ICS_BAD_FLAG (ics))\n-\t\tcandidates->viable = -1;\n+\t\tcand->viable = -1;\n \t    }\n \t}\n     }\n@@ -2718,14 +2744,14 @@ build_new_function_call (tree fn, tree args)\n \t  my_friendly_assert (!DECL_FUNCTION_MEMBER_P (t), 20020913);\n \n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t    candidates = add_template_candidate\n-\t      (candidates, t, NULL_TREE, explicit_targs, args, \n+\t    add_template_candidate\n+\t      (&candidates, t, NULL_TREE, explicit_targs, args, \n \t       NULL_TREE, /*access_path=*/NULL_TREE, \n \t       /*conversion_path=*/NULL_TREE,\n \t       LOOKUP_NORMAL, DEDUCE_CALL);  \n \t  else if (! template_only)\n-\t    candidates = add_function_candidate\n-\t      (candidates, t, NULL_TREE, args, \n+\t    add_function_candidate\n+\t      (&candidates, t, NULL_TREE, args, \n \t       /*access_path=*/NULL_TREE,\n \t       /*conversion_path=*/NULL_TREE, LOOKUP_NORMAL);\n \t}\n@@ -2793,15 +2819,14 @@ build_object_call (tree obj, tree args)\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    candidates \n-\t      = add_template_candidate (candidates, fn, base, NULL_TREE,\n-\t\t\t\t\tmem_args, NULL_TREE, \n-\t\t\t\t\tTYPE_BINFO (type),\n-\t\t\t\t\tTYPE_BINFO (type),\n-\t\t\t\t\tLOOKUP_NORMAL, DEDUCE_CALL);\n+\t    add_template_candidate (&candidates, fn, base, NULL_TREE,\n+\t\t\t\t    mem_args, NULL_TREE, \n+\t\t\t\t    TYPE_BINFO (type),\n+\t\t\t\t    TYPE_BINFO (type),\n+\t\t\t\t    LOOKUP_NORMAL, DEDUCE_CALL);\n \t  else\n-\t    candidates = add_function_candidate\n-\t      (candidates, fn, base, mem_args, TYPE_BINFO (type),\n+\t    add_function_candidate\n+\t      (&candidates, fn, base, mem_args, TYPE_BINFO (type),\n \t       TYPE_BINFO (type), LOOKUP_NORMAL);\n \t}\n     }\n@@ -2824,16 +2849,14 @@ build_object_call (tree obj, tree args)\n \t  {\n \t    tree fn = OVL_CURRENT (fns);\n \t    if (TREE_CODE (fn) == TEMPLATE_DECL) \n-\t      {\n-\t\tcandidates = (add_template_conv_candidate \n-\t\t\t      (candidates, fn, obj, args, totype,\n-\t\t\t       /*access_path=*/NULL_TREE,\n-\t\t\t       /*conversion_path=*/NULL_TREE));\n-\t      }\n+\t      add_template_conv_candidate \n+\t\t(&candidates, fn, obj, args, totype,\n+\t\t /*access_path=*/NULL_TREE,\n+\t\t /*conversion_path=*/NULL_TREE);\n \t    else\n-\t      candidates = add_conv_candidate (candidates, fn, obj, args,\n-\t\t\t\t\t       /*conversion_path=*/NULL_TREE,\n-\t\t\t\t\t       /*access_path=*/NULL_TREE);\n+\t      add_conv_candidate (&candidates, fn, obj, args,\n+\t\t\t\t  /*conversion_path=*/NULL_TREE,\n+\t\t\t\t  /*access_path=*/NULL_TREE);\n \t  }\n     }\n \n@@ -3139,12 +3162,12 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n       args[0] = arg2;\n       args[1] = arg3;\n       args[2] = arg1;\n-      candidates = add_builtin_candidates (candidates, \n-\t\t\t\t\t   COND_EXPR, \n-\t\t\t\t\t   NOP_EXPR,\n-\t\t\t\t\t   ansi_opname (COND_EXPR),\n-\t\t\t\t\t   args,\n-\t\t\t\t\t   LOOKUP_NORMAL);\n+      add_builtin_candidates (&candidates, \n+\t\t\t      COND_EXPR, \n+\t\t\t      NOP_EXPR,\n+\t\t\t      ansi_opname (COND_EXPR),\n+\t\t\t      args,\n+\t\t\t      LOOKUP_NORMAL);\n \n       /* [expr.cond]\n \n@@ -3327,11 +3350,11 @@ prep_operand (tree operand)\n    without any implicit object parameter.  CONVERSION_PATH,\n    ACCESS_PATH, and FLAGS are as for add_function_candidate.  */\n \n-static struct z_candidate *\n+static void\n add_candidates (tree fns, tree args,\n \t\ttree conversion_path, tree access_path,\n \t\tint flags,\n-\t\tstruct z_candidate *candidates)\n+\t\tstruct z_candidate **candidates)\n {\n   tree ctype;\n   tree non_static_args;\n@@ -3362,28 +3385,26 @@ add_candidates (tree fns, tree args,\n \tfn_args = args;\n \n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\tcandidates = add_template_candidate (candidates, \n-\t\t\t\t\t     fn, \n-\t\t\t\t\t     ctype,\n-\t\t\t\t\t     NULL_TREE,\n-\t\t\t\t\t     fn_args,\n-\t\t\t\t\t     NULL_TREE,\n-\t\t\t\t\t     access_path,\n-\t\t\t\t\t     conversion_path,\n-\t\t\t\t\t     flags,\n-\t\t\t\t\t     DEDUCE_CALL);\n+\tadd_template_candidate (candidates, \n+\t\t\t\tfn, \n+\t\t\t\tctype,\n+\t\t\t\tNULL_TREE,\n+\t\t\t\tfn_args,\n+\t\t\t\tNULL_TREE,\n+\t\t\t\taccess_path,\n+\t\t\t\tconversion_path,\n+\t\t\t\tflags,\n+\t\t\t\tDEDUCE_CALL);\n       else\n-\tcandidates = add_function_candidate (candidates,\n-\t\t\t\t\t     fn,\n-\t\t\t\t\t     ctype,\n-\t\t\t\t\t     fn_args,\n-\t\t\t\t\t     access_path,\n-\t\t\t\t\t     conversion_path,\n-\t\t\t\t\t     flags);\n+\tadd_function_candidate (candidates,\n+\t\t\t\tfn,\n+\t\t\t\tctype,\n+\t\t\t\tfn_args,\n+\t\t\t\taccess_path,\n+\t\t\t\tconversion_path,\n+\t\t\t\tflags);\n       fns = OVL_NEXT (fns);\n     }\n-\n-  return candidates;\n }\n \n tree\n@@ -3456,9 +3477,9 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \n   /* Add namespace-scope operators to the list of functions to\n      consider.  */\n-  candidates = add_candidates (lookup_function_nonclass (fnname, arglist),\n-\t\t\t       arglist, NULL_TREE, NULL_TREE,\n-\t\t\t       flags, candidates);\n+  add_candidates (lookup_function_nonclass (fnname, arglist),\n+\t\t  arglist, NULL_TREE, NULL_TREE,\n+\t\t  flags, &candidates);\n   /* Add class-member operators to the candidate set.  */\n   if (CLASS_TYPE_P (TREE_TYPE (arg1)))\n     {\n@@ -3468,10 +3489,10 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n       if (fns == error_mark_node)\n \treturn fns;\n       if (fns)\n-\tcandidates = add_candidates (BASELINK_FUNCTIONS (fns), arglist, \n-\t\t\t\t     BASELINK_BINFO (fns),\n-\t\t\t\t     TYPE_BINFO (TREE_TYPE (arg1)),\n-\t\t\t\t     flags, candidates);\n+\tadd_candidates (BASELINK_FUNCTIONS (fns), arglist, \n+\t\t\tBASELINK_BINFO (fns),\n+\t\t\tTYPE_BINFO (TREE_TYPE (arg1)),\n+\t\t\tflags, &candidates);\n     }\n \n   /* Rearrange the arguments for ?: so that add_builtin_candidate only has\n@@ -3491,8 +3512,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n       args[2] = NULL_TREE;\n     }\n \n-  candidates = add_builtin_candidates\n-    (candidates, code, code2, fnname, args, flags);\n+  add_builtin_candidates (&candidates, code, code2, fnname, args, flags);\n \n   switch (code)\n     {\n@@ -3899,8 +3919,7 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n     {\n     case USER_CONV:\n       {\n-\tstruct z_candidate *cand\n-\t  = WRAPPER_ZC (TREE_OPERAND (convs, 1));\n+\tstruct z_candidate *cand = USER_CONV_CAND (convs);\n \ttree convfn = cand->fn;\n \ttree args;\n \n@@ -4055,9 +4074,7 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n \texpr = cp_convert (build_pointer_type (TREE_TYPE (ref_type)), \n \t\t\t   expr);\n \t/* Convert the pointer to the desired reference type.  */\n-\texpr = build1 (NOP_EXPR, ref_type, expr);\n-\n-\treturn expr;\n+\treturn build_nop (ref_type, expr);\n       }\n \n     case LVALUE_CONV:\n@@ -4793,7 +4810,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n     {\n       tree type = build_pointer_type (basetype);\n       if (!same_type_p (type, TREE_TYPE (instance_ptr)))\n-\tinstance_ptr = build1 (NOP_EXPR, type, instance_ptr);\n+\tinstance_ptr = build_nop (type, instance_ptr);\n     }\n \n   class_type = (conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE);\n@@ -4815,25 +4832,22 @@ build_new_method_call (tree instance, tree fns, tree args,\n \tthis_arglist = args;\n \n       if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t{\n-\t  /* A member template.  */\n-\t  candidates = \n-\t    add_template_candidate (candidates, t, \n-\t\t\t\t    class_type,\n-\t\t\t\t    explicit_targs,\n-\t\t\t\t    this_arglist, optype,\n-\t\t\t\t    access_binfo, \n-\t\t\t\t    conversion_path,\n-\t\t\t\t    flags,\n-\t\t\t\t    DEDUCE_CALL);\n-\t}\n+\t/* A member template.  */\n+\tadd_template_candidate (&candidates, t, \n+\t\t\t\tclass_type,\n+\t\t\t\texplicit_targs,\n+\t\t\t\tthis_arglist, optype,\n+\t\t\t\taccess_binfo, \n+\t\t\t\tconversion_path,\n+\t\t\t\tflags,\n+\t\t\t\tDEDUCE_CALL);\n       else if (! template_only)\n-\tcandidates = add_function_candidate (candidates, t, \n-\t\t\t\t\t     class_type,\n-\t\t\t\t\t     this_arglist,\n-\t\t\t\t\t     access_binfo,\n-\t\t\t\t\t     conversion_path,\n-\t\t\t\t\t     flags);\n+\tadd_function_candidate (&candidates, t, \n+\t\t\t\tclass_type,\n+\t\t\t\tthis_arglist,\n+\t\t\t\taccess_binfo,\n+\t\t\t\tconversion_path,\n+\t\t\t\tflags);\n     }\n \n   if (! any_viable (candidates))\n@@ -5783,22 +5797,106 @@ perform_implicit_conversion (tree type, tree expr)\n   return convert_like (conv, expr);\n }\n \n+/* DECL is a VAR_DECL whose type is a REFERENCE_TYPE.  The reference\n+   is being bound to a temporary.  Create and return a new VAR_DECL\n+   whose type is the underlying type of the reference.  */\n+\n+tree \n+make_temporary_var_for_ref_to_temp (tree decl)\n+{\n+  tree type;\n+  tree var;\n+\n+  /* Get the type to which the reference refers.  */\n+  type = TREE_TYPE (decl);\n+  my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 200302);\n+  type = TREE_TYPE (type);\n+\n+  /* Create the variable.  */\n+  var = build_decl (VAR_DECL, NULL_TREE, type);\n+  DECL_ARTIFICIAL (var) = 1;\n+  TREE_USED (var) = 1;\n+\n+  /* Register the variable.  */\n+  if (TREE_STATIC (decl))\n+    {\n+      /* Namespace-scope or local static; give it a mangled name.  */\n+      tree name;\n+\n+      TREE_STATIC (var) = 1;\n+      name = mangle_ref_init_variable (decl);\n+      DECL_NAME (var) = name;\n+      SET_DECL_ASSEMBLER_NAME (var, name);\n+      var = pushdecl_top_level (var);\n+    }\n+  else\n+    {\n+      /* Create a new cleanup level if necessary.  */\n+      maybe_push_cleanup_level (type);\n+      /* Don't push unnamed temps.  Do set DECL_CONTEXT, though.  */\n+      DECL_CONTEXT (var) = current_function_decl;\n+    }\n+\n+  return var;\n+}\n+\n /* Convert EXPR to the indicated reference TYPE, in a way suitable for\n-   initializing a variable of that TYPE.  Return the converted\n-   expression.  */\n+   initializing a variable of that TYPE.   If DECL is non-NULL, it is\n+   the VAR_DECL being initialized with the EXPR.  (In that case, the\n+   type of DECL will be TYPE.)\n+\n+   Return the converted expression.  */\n \n tree\n-initialize_reference (tree type, tree expr)\n+initialize_reference (tree type, tree expr, tree decl)\n {\n   tree conv;\n+  bool ref_bound_directly_to_rvalue_p;\n+\n+  if (type == error_mark_node || error_operand_p (expr))\n+    return error_mark_node;\n \n-  conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL);\n+  conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL,\n+\t\t\t    &ref_bound_directly_to_rvalue_p);\n   if (!conv || ICS_BAD_FLAG (conv))\n     {\n       error (\"could not convert `%E' to `%T'\", expr, type);\n       return error_mark_node;\n     }\n \n+  /* If DECL is non-NULL, then this special rule applies:\n+\n+       [class.temporary]\n+\n+       The temporary to which the reference is bound or the temporary\n+       that is the complete object to which the temporary is bound\n+       persists for the lifetime of the reference.\n+\n+       The temporaries created during the evaluation of the expression\n+       initializing the reference, except the temporary to which the\n+       reference is bound, are destroyed at the end of the\n+       full-expression in which they are created.\n+\n+     In that case, we store the converted expression into a new\n+     VAR_DECL in a new scope.  */\n+  my_friendly_assert (TREE_CODE (conv) == REF_BIND, 20030302);\n+  if (decl && (NEED_TEMPORARY_P (conv) || ref_bound_directly_to_rvalue_p))\n+    {\n+      tree var;\n+      \n+      /* Process the initializer for the declaration.  */\n+      expr = convert_like (TREE_OPERAND (conv, 0), expr);\n+      /* Create the temporary variable.  */\n+      var = make_temporary_var_for_ref_to_temp (decl);\n+      DECL_INITIAL (var) = expr;\n+      cp_finish_decl (var, expr, NULL_TREE, \n+\t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n+\n+      /* Use its address to initialize the reference variable.  */\n+      return build_nop (type, build_address (var));\n+    }\n+\n+  /* Perform the conversion.  */\n   return convert_like (conv, expr);\n }\n "}, {"sha": "a12fd73ae174e21c2d997726c731af18ad9fea08", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -7922,22 +7922,20 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n \n   /* The second entry is the address of the typeinfo object.  */\n   if (flag_rtti)\n-    decl = build_unary_op (ADDR_EXPR, get_tinfo_decl (t), 0);\n+    decl = build_address (get_tinfo_decl (t));\n   else\n     decl = integer_zero_node;\n   \n   /* Convert the declaration to a type that can be stored in the\n      vtable.  */\n-  init = build1 (NOP_EXPR, vfunc_ptr_type_node, decl);\n-  TREE_CONSTANT (init) = 1;\n+  init = build_nop (vfunc_ptr_type_node, decl);\n   *vid->last_init = build_tree_list (NULL_TREE, init);\n   vid->last_init = &TREE_CHAIN (*vid->last_init);\n \n   /* Add the offset-to-top entry.  It comes earlier in the vtable that\n      the the typeinfo entry.  Convert the offset to look like a\n      function pointer, so that we can put it in the vtable.  */\n-  init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n-  TREE_CONSTANT (init) = 1;\n+  init = build_nop (vfunc_ptr_type_node, offset);\n   *vid->last_init = build_tree_list (NULL_TREE, init);\n   vid->last_init = &TREE_CHAIN (*vid->last_init);\n }"}, {"sha": "cf84fcb46e7f5bc1bb560c0d4c97774f69087c0c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -3576,7 +3576,8 @@ extern tree type_passed_as (tree);\n extern tree convert_for_arg_passing (tree, tree);\n extern tree cp_convert_parm_for_inlining        (tree, tree, tree);\n extern bool is_properly_derived_from (tree, tree);\n-extern tree initialize_reference (tree, tree);\n+extern tree initialize_reference (tree, tree, tree);\n+extern tree make_temporary_var_for_ref_to_temp (tree);\n extern tree strip_top_quals (tree);\n extern tree perform_implicit_conversion (tree, tree);\n extern tree in_charge_arg_for_name (tree);\n@@ -3638,7 +3639,7 @@ extern tree ocp_convert (tree, tree, int, int);\n extern tree cp_convert (tree, tree);\n extern tree convert_to_void (tree, const char */*implicit context*/);\n extern tree convert_force (tree, tree, int);\n-extern tree build_type_conversion (tree, tree, int);\n+extern tree build_type_conversion (tree, tree);\n extern tree build_expr_type_conversion (int, tree, bool);\n extern tree type_promotes_to (tree);\n extern tree perform_qualification_conversions (tree, tree);\n@@ -4355,6 +4356,8 @@ extern tree check_return_expr                   (tree);\n #define cxx_sizeof(T)  cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, true)\n #define cxx_alignof(T) cxx_sizeof_or_alignof_type (T, ALIGNOF_EXPR, true)\n extern tree build_ptrmemfunc_access_expr       (tree, tree);\n+extern tree build_address                       (tree);\n+extern tree build_nop                           (tree, tree);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);"}, {"sha": "ba5fbba1a1616d25aee0d94cf9a8c503ca683032", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 27, "deletions": 68, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -90,7 +90,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t  return error_mark_node;\n \t}\n \n-      rval = build_type_conversion (type, expr, true);\n+      rval = build_type_conversion (type, expr);\n       if (rval)\n \t{\n \t  if (rval == error_mark_node)\n@@ -148,31 +148,33 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t{\n \t  enum tree_code code = PLUS_EXPR;\n \t  tree binfo;\n+\t  tree intype_class;\n+\t  tree type_class;\n+\t  bool same_p;\n \n+\t  intype_class = TREE_TYPE (intype);\n+\t  type_class = TREE_TYPE (type);\n+\n+\t  same_p = same_type_p (TYPE_MAIN_VARIANT (intype_class), \n+\t\t\t\tTYPE_MAIN_VARIANT (type_class));\n+\t  binfo = NULL_TREE;\n \t  /* Try derived to base conversion.  */\n-\t  binfo = lookup_base (TREE_TYPE (intype), TREE_TYPE (type),\n-\t\t\t       ba_check, NULL);\n-\t  if (!binfo)\n+\t  if (!same_p)\n+\t    binfo = lookup_base (intype_class, type_class, ba_check, NULL);\n+\t  if (!same_p && !binfo)\n \t    {\n \t      /* Try base to derived conversion.  */\n-\t      binfo = lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n-\t\t\t\t   ba_check, NULL);\n+\t      binfo = lookup_base (type_class, intype_class, ba_check, NULL);\n \t      code = MINUS_EXPR;\n \t    }\n \t  if (binfo == error_mark_node)\n \t    return error_mark_node;\n-\t  if (binfo)\n+\t  if (binfo || same_p)\n \t    {\n-\t      expr = build_base_path (code, expr, binfo, 0);\n+\t      if (binfo)\n+\t\texpr = build_base_path (code, expr, binfo, 0);\n \t      /* Add any qualifier conversions.  */\n-\t      if (!same_type_p (TREE_TYPE (TREE_TYPE (expr)),\n-\t\t\t\tTREE_TYPE (type)))\n-\t\t{\n-\t\t  expr = build1 (NOP_EXPR, type, expr);\n-\t\t  TREE_CONSTANT (expr) =\n-\t\t    TREE_CONSTANT (TREE_OPERAND (expr, 0));\n-\t\t}\n-\t      return expr;\n+\t      return build_nop (type, expr);\n \t    }\n \t}\n \n@@ -225,9 +227,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t  return error_mark_node;\n \t}\n \n-      rval = build1 (NOP_EXPR, type, expr);\n-      TREE_CONSTANT (rval) = TREE_CONSTANT (expr);\n-      return rval;\n+      return build_nop (type, expr);\n     }\n   else if (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype))\n     return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n@@ -326,14 +326,9 @@ convert_to_pointer_force (tree type, tree expr)\n \t      /* Add any qualifier conversions.  */\n \t      if (!same_type_p (TREE_TYPE (TREE_TYPE (expr)),\n \t\t\t\tTREE_TYPE (type)))\n-\t\t{\n-\t\t  expr = build1 (NOP_EXPR, type, expr);\n-\t\t  TREE_CONSTANT (expr) =\n-\t\t    TREE_CONSTANT (TREE_OPERAND (expr, 0));\n-\t\t}\n+\t\texpr = build_nop (type, expr);\n \t      return expr;\n \t    }\n-\t  \n \t}\n     }\n \n@@ -354,7 +349,6 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n   tree rval;\n   tree argtype = TREE_TYPE (arg);\n   tree target_type = TREE_TYPE (type);\n-  tree stmt_expr = NULL_TREE;\n \n   my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 187);\n \n@@ -364,26 +358,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n \t here because it needs to live as long as DECL.  */\n       tree targ = arg;\n \n-      arg = build_decl (VAR_DECL, NULL_TREE, argtype);\n-      DECL_ARTIFICIAL (arg) = 1;\n-      TREE_USED (arg) = 1;\n-      TREE_STATIC (arg) = TREE_STATIC (decl);\n-\n-      if (TREE_STATIC (decl))\n-\t{\n-\t  /* Namespace-scope or local static; give it a mangled name.  */\n-\t  tree name = mangle_ref_init_variable (decl);\n-\t  DECL_NAME (arg) = name;\n-\t  SET_DECL_ASSEMBLER_NAME (arg, name);\n-\t  arg = pushdecl_top_level (arg);\n-\t}\n-      else\n-\t{\n-\t  /* Automatic; make sure we handle the cleanup properly.  */\n-\t  maybe_push_cleanup_level (argtype);\n-\t  /* Don't push unnamed temps.  Do set DECL_CONTEXT, though.  */\n-\t  DECL_CONTEXT (arg) = current_function_decl;\n-\t}\n+      arg = make_temporary_var_for_ref_to_temp (decl);\n \n       /* Process the initializer for the declaration.  */\n       DECL_INITIAL (arg) = targ;\n@@ -416,16 +391,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n   else\n     rval\n       = convert_to_pointer_force (build_pointer_type (target_type), rval);\n-  rval = build1 (NOP_EXPR, type, rval);\n-  TREE_CONSTANT (rval) = TREE_CONSTANT (TREE_OPERAND (rval, 0));\n-\n-  /* If we created and initialized a new temporary variable, add the\n-     representation of that initialization to the RVAL.  */\n-  if (stmt_expr)\n-    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), stmt_expr, rval);\n-\n-  /* And return the result.  */\n-  return rval;\n+  return build_nop (type, rval);\n }\n \n /* Subroutine of convert_to_reference. REFTYPE is the target reference type.\n@@ -500,7 +466,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n       /* Look for a user-defined conversion to lvalue that we can use.  */\n \n       rval_as_conversion\n-\t= build_type_conversion (reftype, expr, 1);\n+\t= build_type_conversion (reftype, expr);\n \n       if (rval_as_conversion && rval_as_conversion != error_mark_node\n \t  && real_lvalue_p (rval_as_conversion))\n@@ -705,7 +671,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       if (IS_AGGR_TYPE (intype))\n \t{\n \t  tree rval;\n-\t  rval = build_type_conversion (type, e, 1);\n+\t  rval = build_type_conversion (type, e);\n \t  if (rval)\n \t    return rval;\n \t  if (flags & LOOKUP_COMPLAIN)\n@@ -741,7 +707,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       if (IS_AGGR_TYPE (TREE_TYPE (e)))\n \t{\n \t  tree rval;\n-\t  rval = build_type_conversion (type, e, 1);\n+\t  rval = build_type_conversion (type, e);\n \t  if (rval)\n \t    return rval;\n \t  else\n@@ -1015,24 +981,17 @@ convert_force (tree type, tree expr, int convtype)\n    allowed (references private members, etc).\n    If no conversion exists, NULL_TREE is returned.\n \n-   If (FOR_SURE & 1) is nonzero, then we allow this type conversion\n-   to take place immediately.  Otherwise, we build a SAVE_EXPR\n-   which can be evaluated if the results are ever needed.\n-\n-   Changes to this functions should be mirrored in user_harshness.\n-\n    FIXME: Ambiguity checking is wrong.  Should choose one by the implicit\n    object parameter, or by the second standard conversion sequence if\n    that doesn't do it.  This will probably wait for an overloading rewrite.\n    (jason 8/9/95)  */\n \n tree\n-build_type_conversion (tree xtype, tree expr, int for_sure)\n+build_type_conversion (tree xtype, tree expr)\n {\n   /* C++: check to see if we can convert this aggregate type\n      into the required type.  */\n-  return build_user_type_conversion\n-    (xtype, expr, for_sure ? LOOKUP_NORMAL : 0);\n+  return build_user_type_conversion (xtype, expr, LOOKUP_NORMAL);\n }\n \n /* Convert the given EXPR to one of a group of types suitable for use in an"}, {"sha": "63072d3770902c59417afbfddb7ecee8128f945a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -7288,10 +7288,7 @@ grok_reference_init (tree decl, tree type, tree init)\n      DECL_INITIAL for local references (instead assigning to them\n      explicitly); we need to allow the temporary to be initialized\n      first.  */\n-  tmp = convert_to_reference\n-    (type, init, CONV_IMPLICIT,\n-     LOOKUP_ONLYCONVERTING|LOOKUP_SPECULATIVELY|LOOKUP_NORMAL|DIRECT_BIND,\n-     decl);\n+  tmp = initialize_reference (type, init, decl);\n \n   if (tmp == error_mark_node)\n     return NULL_TREE;"}, {"sha": "8c8e53104a6fafbb2d1d54cef8ac00f0ea340e94", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -4089,7 +4089,45 @@ condition_conversion (expr)\n   t = fold (build1 (CLEANUP_POINT_EXPR, boolean_type_node, t));\n   return t;\n }\n-\t\t\t       \n+\t\t\n+/* Return an ADDR_EXPR giving the address of T.  This function\n+   attempts no optimizations or simplifications; it is a low-level\n+   primitive.  */\n+\n+tree\n+build_address (tree t)\n+{\n+  tree addr;\n+\n+  if (error_operand_p (t) || !cxx_mark_addressable (t))\n+    return error_mark_node;\n+\n+  addr = build1 (ADDR_EXPR, \n+\t\t build_pointer_type (TREE_TYPE (t)),\n+\t\t t);\n+  if (staticp (t))\n+    TREE_CONSTANT (addr) = 1;\n+\n+  return addr;\n+}\n+\n+/* Return a NOP_EXPR converting EXPR to TYPE.  */\n+\n+tree\n+build_nop (tree type, tree expr)\n+{\n+  tree nop;\n+\n+  if (type == error_mark_node || error_operand_p (expr))\n+    return expr;\n+    \n+  nop = build1 (NOP_EXPR, type, expr);\n+  if (TREE_CONSTANT (expr))\n+    TREE_CONSTANT (nop) = 1;\n+  \n+  return nop;\n+}\n+\n /* C++: Must handle pointers to members.\n \n    Perhaps type instantiation should be extended to handle conversion\n@@ -4479,9 +4517,6 @@ build_unary_op (code, xarg, noconvert)\n       if (argtype != error_mark_node)\n \targtype = build_pointer_type (argtype);\n \n-      if (!cxx_mark_addressable (arg))\n-\treturn error_mark_node;\n-\n       {\n \ttree addr;\n \n@@ -4515,12 +4550,7 @@ build_unary_op (code, xarg, noconvert)\n \t\t\t\tcp_convert (argtype, byte_position (field))));\n \t  }\n \telse\n-\t  addr = build1 (ADDR_EXPR, argtype, arg);\n-\n-\t/* Address of a static or external variable or\n-\t   function counts as a constant */\n-\tif (staticp (arg))\n-\t  TREE_CONSTANT (addr) = 1;\n+\t  addr = build_address (arg);\n \n \tif (TREE_CODE (argtype) == POINTER_TYPE\n \t    && TREE_CODE (TREE_TYPE (argtype)) == METHOD_TYPE)\n@@ -5798,11 +5828,17 @@ build_ptrmemfunc (type, pfn, force)\n      int force;\n {\n   tree fn;\n-  tree pfn_type = TREE_TYPE (pfn);\n-  tree to_type = build_ptrmemfunc_type (type);\n+  tree pfn_type;\n+  tree to_type;\n+\n+  if (error_operand_p (pfn))\n+    return error_mark_node;\n+\n+  pfn_type = TREE_TYPE (pfn);\n+  to_type = build_ptrmemfunc_type (type);\n \n   /* Handle multiple conversions of pointer to member functions.  */\n-  if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n+  if (TYPE_PTRMEMFUNC_P (pfn_type))\n     {\n       tree delta = NULL_TREE;\n       tree npfn = NULL_TREE;\n@@ -6183,7 +6219,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \n       if (fndecl)\n \tsavew = warningcount, savee = errorcount;\n-      rhs = initialize_reference (type, rhs);\n+      rhs = initialize_reference (type, rhs, /*decl=*/NULL_TREE);\n       if (fndecl)\n \t{\n \t  if (warningcount > savew)"}, {"sha": "c4540481454269cce79d6d2881f319294eb1189f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -388,32 +388,8 @@ store_init_value (decl, init)\n     return value;\n   else if (TREE_STATIC (decl)\n \t   && (! TREE_CONSTANT (value)\n-\t       || ! initializer_constant_valid_p (value, TREE_TYPE (value))\n-#if 0\n-\t       /* A STATIC PUBLIC int variable doesn't have to be\n-\t\t  run time inited when doing pic.  (mrs) */\n-\t       /* Since ctors and dtors are the only things that can\n-\t\t  reference vtables, and they are always written down\n-\t\t  the vtable definition, we can leave the\n-\t\t  vtables in initialized data space.\n-\t\t  However, other initialized data cannot be initialized\n-\t\t  this way.  Instead a global file-level initializer\n-\t\t  must do the job.  */\n-\t       || (flag_pic && !DECL_VIRTUAL_P (decl) && TREE_PUBLIC (decl))\n-#endif\n-\t       ))\n-\n+\t       || ! initializer_constant_valid_p (value, TREE_TYPE (value))))\n     return value;\n-#if 0 /* No, that's C.  jason 9/19/94 */\n-  else\n-    {\n-      if (pedantic && TREE_CODE (value) == CONSTRUCTOR)\n-\t{\n-\t  if (! TREE_CONSTANT (value) || ! TREE_STATIC (value))\n-\t    pedwarn (\"ISO C++ forbids non-constant aggregate initializer expressions\");\n-\t}\n-    }\n-#endif\n   \n   /* Store the VALUE in DECL_INITIAL.  If we're building a\n      statement-tree we will actually expand the initialization later"}, {"sha": "926b42e906229f04fb5822cfe81096e1014001d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -1,3 +1,8 @@\n+2003-03-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9878\n+\t* g++.dg/init/ref1.C: New test.\n+\n Mon Mar  3 20:42:04 2003  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* gcc.dg/sh-relax.c: New SH-only test."}, {"sha": "12caff2d0ed3a6232346b69ed532f5fd1b64fa88", "filename": "gcc/testsuite/g++.dg/init/ref1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7993382ed00da10f470ccfe78d9f67301b0cdadd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref1.C?ref=7993382ed00da10f470ccfe78d9f67301b0cdadd", "patch": "@@ -0,0 +1,5 @@\n+void f(void)\n+{\n+  short x = 0;\n+  const int &y = x;\n+}"}]}