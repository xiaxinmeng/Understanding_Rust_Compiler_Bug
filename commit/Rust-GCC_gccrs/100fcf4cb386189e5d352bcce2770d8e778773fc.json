{"sha": "100fcf4cb386189e5d352bcce2770d8e778773fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAwZmNmNGNiMzg2MTg5ZTVkMzUyYmNjZTI3NzBkOGU3Nzg3NzNmYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-13T23:07:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-13T23:07:51Z"}, "message": "(PROMOTE_MODE, ADJUST_COST): New macros.\n\n(CALL_USED_REGISTERS): LR0 is call-used.\n(HARD_REGNO_MODE_OK): Handle MODE_PARTIAL_INT and the special\nregisters that can only hold those modes.\n(MODES_TIEABLE_P): Clean up and handle MODE_PARTIAL_INT modes.\n(enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS): Add new\nclasses LR0_REGS, FC_REGS, and CR_REGS.\n(REGNO_REG_CLASS, REG_CLASS_FROM_LETTER): Likewise.\n(PREDICATE_CODES): Update for new and deleted predicates.\n\nFrom-SVN: r2444", "tree": {"sha": "04c4394cee59ac31ed47bdd4e85faf57d21fe933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04c4394cee59ac31ed47bdd4e85faf57d21fe933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/100fcf4cb386189e5d352bcce2770d8e778773fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/100fcf4cb386189e5d352bcce2770d8e778773fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/100fcf4cb386189e5d352bcce2770d8e778773fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/100fcf4cb386189e5d352bcce2770d8e778773fc/comments", "author": null, "committer": null, "parents": [{"sha": "fba942c46dad90bc02695e422b89c4145b59419e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba942c46dad90bc02695e422b89c4145b59419e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba942c46dad90bc02695e422b89c4145b59419e"}], "stats": {"total": 77, "additions": 57, "deletions": 20}, "files": [{"sha": "882a5bdebc71060b2ba1c34e554ed716773ecd82", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/100fcf4cb386189e5d352bcce2770d8e778773fc/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/100fcf4cb386189e5d352bcce2770d8e778773fc/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=100fcf4cb386189e5d352bcce2770d8e778773fc", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for AMD Am29000 CPU.\n-   Copyright (C) 1988, 1990, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1990, 1991, 1992 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@nyu.edu)\n \n This file is part of GNU CC.\n@@ -122,6 +122,17 @@ extern int target_flags;\n #define WCHAR_TYPE \"char\"\n #define WCHAR_TYPE_SIZE BITS_PER_UNIT\n \n+/* Define this macro if it is advisible to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases, \n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\\\n+      && GET_MODE_SIZE (MODE) < 4)  \t\\\n+    (MODE) == SImode;\n+\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n    This is arbitrary on the 29k since it has no actual bit-field insns.\n@@ -307,7 +318,7 @@ extern int target_flags;\n #define CALL_USED_REGISTERS  \\\n  {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n@@ -383,7 +394,8 @@ extern int target_flags;\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On 29k, the cpu registers can hold any mode.  But a double-precision\n    floating-point value should start at an even register.  The special\n-   registers cannot hold floating-point values and the accumulators cannot\n+   registers cannot hold floating-point values, BP, CR, and FC cannot\n+   hold integer or floating-point values,  and the accumulators cannot\n    hold integer values.\n \n    DImode and larger values should start at an even register just like\n@@ -396,7 +408,9 @@ extern int target_flags;\n   (((REGNO) >= R_ACC (0)\t\t\t\t\t\t\\\n     && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n \t|| GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT))\t\t\\\n-   || ((REGNO) >= R_BP && (REGNO) < R_ACC (0)\t\t\t\t\\\n+   || ((REGNO) >= R_BP && (REGNO) <= R_CR\t\t\t\t\\\n+       && GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT)\t\t\t\\\n+   || ((REGNO) >= R_Q && (REGNO) < R_ACC (0)\t\t\t\t\\\n        && GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n        && GET_MODE_CLASS (MODE) != MODE_COMPLEX_FLOAT)\t\t\t\\\n    || ((REGNO) < R_BP\t\t\t\t\t\t\t\\\n@@ -413,12 +427,11 @@ extern int target_flags;\n    the special register's restriction to non-floating and the floating-point\n    accumulator's restriction to only floating.  This probably won't\n    cause any great inefficiencies in practice.  */\n+\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n   ((MODE1) == (MODE2)\t\t\t\t\t\\\n-   || (GET_MODE_CLASS (MODE1) != MODE_FLOAT\t\t\\\n-       && GET_MODE_CLASS (MODE1) != MODE_COMPLEX_FLOAT\t\\\n-       && GET_MODE_CLASS (MODE2) != MODE_FLOAT\t\t\\\n-       && GET_MODE_CLASS (MODE2) != MODE_COMPLEX_FLOAT))\n+   || (GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n+       && GET_MODE_CLASS (MODE2) == MODE_INT))\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -468,36 +481,40 @@ extern int target_flags;\n    For any two classes, it is very desirable that there be another\n    class that represents their union.\n    \n-   The 29k has six registers classes: GENERAL_REGS, SPECIAL_REGS,\n-   BP_REGS, Q_REGS, ACCUM_REGS, and ACCUM0_REGS.  BP_REGS contains just BP and\n-   is used for the extract and insert operations to allow combinations; Q\n-   contains just the Q register.  The latter two classes are used to represent\n-   the floating-point accumulator registers in the 29050.  We also define the\n-   union class FLOAT_REGS to represent any register that can be used to hold a\n+   The 29k has nine registers classes: LR0_REGS, GENERAL_REGS, SPECIAL_REGS,\n+   BP_REGS, FC_REGS, CR_REGS, Q_REGS, ACCUM_REGS, and ACCUM0_REGS.\n+   LR0_REGS, BP_REGS, FC_REGS, CR_REGS, and Q_REGS contain just the single\n+   register.  The latter two classes are used to represent the floating-point\n+   accumulator registers in the 29050.  We also define the union class\n+   FLOAT_REGS to represent any register that can be used to hold a\n    floating-point value.  The union of SPECIAL_REGS and ACCUM_REGS isn't\n    useful as the former cannot contain floating-point and the latter can only\n    contain floating-point.  */\n \n-enum reg_class { NO_REGS, GENERAL_REGS, BP_REGS, Q_REGS, SPECIAL_REGS, \n-\t\t ACCUM0_REGS, ACCUM_REGS, FLOAT_REGS, ALL_REGS,\n-\t\t LIM_REG_CLASSES };\n+enum reg_class { NO_REGS, LR0_REGS, GENERAL_REGS, BP_REGS, FC_REGS, CR_REGS,\n+\t\t Q_REGS, SPECIAL_REGS, ACCUM0_REGS, ACCUM_REGS, FLOAT_REGS,\n+\t\t ALL_REGS, LIM_REG_CLASSES };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES\t\t\t\t\\\n- {\"NO_REGS\", \"GENERAL_REGS\", \"BP_REGS\", \"Q_REGS\", \"SPECIAL_REGS\",\t\\\n-  \"ACCUM0_REGS\", \"ACCUM_REGS\", \"FLOAT_REGS\", \"ALL_REGS\" }\n+ {\"NO_REGS\", \"LR0_REGS\", \"GENERAL_REGS\", \"BP_REGS\", \"FC_REGS\", \"CR_REGS\", \\\n+  \"Q_REGS\", \"SPECIAL_REGS\", \"ACCUM0_REGS\", \"ACCUM_REGS\", \"FLOAT_REGS\",    \\\n+  \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS\t\\\n   { {0, 0, 0, 0, 0, 0, 0}, \t\\\n+    {0, 1, 0, 0, 0, 0, 0},\t\\\n     {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, 0},  \\\n     {0, 0, 0, 0, 0, 0x20000, 0}, \t\\\n+    {0, 0, 0, 0, 0, 0x40000, 0}, \t\\\n+    {0, 0, 0, 0, 0, 0x80000, 0}, \t\\\n     {0, 0, 0, 0, 0, 0x100000, 0}, \t\\\n     {0, 0, 0, 0, 0, 0xfffe0000, 0xff},\t\\\n     {0, 0, 0, 0, 0, 0, 0x100},\t\t\\\n@@ -512,10 +529,13 @@ enum reg_class { NO_REGS, GENERAL_REGS, BP_REGS, Q_REGS, SPECIAL_REGS,\n \n #define REGNO_REG_CLASS(REGNO)\t\t\\\n   ((REGNO) == R_BP ? BP_REGS\t\t\\\n+   : (REGNO) == R_FC ? FC_REGS\t\t\\\n+   : (REGNO) == R_CR ? CR_REGS\t\t\\\n    : (REGNO) == R_Q ? Q_REGS\t\t\\\n    : (REGNO) > R_BP && (REGNO) <= R_EXO ? SPECIAL_REGS\t\\\n    : (REGNO) == R_ACC (0) ? ACCUM0_REGS\t\\\n    : (REGNO) > R_ACC (0) ? ACCUM_REGS\t\\\n+   : (REGNO) == R_LR (0) ? LR0_REGS\t\\\n    : GENERAL_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n@@ -526,7 +546,10 @@ enum reg_class { NO_REGS, GENERAL_REGS, BP_REGS, Q_REGS, SPECIAL_REGS,\n \n #define REG_CLASS_FROM_LETTER(C)\t\\\n  ((C) == 'r' ? GENERAL_REGS\t\t\\\n+  : (C) == 'l' ? LR0_REGS\t\t\\\n   : (C) == 'b' ? BP_REGS\t\t\\\n+  : (C) == 'f' ? FC_REGS\t\t\\\n+  : (C) == 'c' ? CR_REGS\t\t\\\n   : (C) == 'q' ? Q_REGS\t\t\t\\\n   : (C) == 'h' ? SPECIAL_REGS\t\t\\\n   : (C) == 'a' ? ACCUM_REGS\t\t\\\n@@ -605,6 +628,10 @@ enum reg_class { NO_REGS, GENERAL_REGS, BP_REGS, Q_REGS, SPECIAL_REGS,\n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n   secondary_reload_class (CLASS, MODE, IN)\n \n+/* This function is used to get the address of an object.  */\n+\n+extern struct rtx_def *a29k_get_reloaded_address ();\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n \n@@ -621,6 +648,15 @@ enum reg_class { NO_REGS, GENERAL_REGS, BP_REGS, Q_REGS, SPECIAL_REGS,\n \n #define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\\\n   ((CLASS1) == GENERAL_REGS || (CLASS2) == GENERAL_REGS ? 2 : 4)\n+\n+/* A C statement (sans semicolon) to update the integer variable COST\n+   based on the relationship between INSN that is dependent on\n+   DEP_INSN through the dependence LINK.  The default is to make no\n+   adjustment to COST.  On the a29k, ignore the cost of anti- and\n+   output-dependencies.  */\n+#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n+  if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n+    (COST) = 0; /* Anti or output dependence.  */\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1544,10 +1580,11 @@ extern int a29k_debug_reg_map[];\n   {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"call_operand\", {SYMBOL_REF, CONST_INT}},\t\t\t\\\n   {\"in_operand\", {SUBREG, MEM, REG, CONST_INT, CONST, SYMBOL_REF, \\\n \t\t  LABEL_REF, CONST_DOUBLE}},\t\t\t\\\n   {\"out_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-  {\"extend_operator\", {ZERO_EXTEND, SIGN_EXTEND}},\t\t\\\n+  {\"reload_memory_operand\", {SUBREG, REG, MEM}},\t\t\\\n   {\"fp_comparison_operator\", {EQ, GT, GE}},\t\t\t\\\n   {\"branch_operator\", {GE, LT}},\t\t\t\t\\\n   {\"epilogue_operand\", {CODE_LABEL}},"}]}