{"sha": "122603fae22d9e7eebada39d917cc42f990a04de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIyNjAzZmFlMjJkOWU3ZWViYWRhMzlkOTE3Y2M0MmY5OTBhMDRkZQ==", "commit": {"author": {"name": "Naveen H.S", "email": "naveen.S@kpitcummins.com", "date": "2010-09-17T10:36:49Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2010-09-17T10:36:49Z"}, "message": "v850.c (v850_function_value_regno_p): Make static.\n\n        * config/v850/v850.c (v850_function_value_regno_p): Make static.\n        Adjust comments. Declare.\n        (TARGET_FUNCTION_VALUE_REGNO_P): Define.\n        * config/v850/v850.h (FUNCTION_VALUE_REGNO_P): Delete.\n\nFrom-SVN: r164365", "tree": {"sha": "35825a4151240a4f150dbaee136a8199ed13aa9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35825a4151240a4f150dbaee136a8199ed13aa9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/122603fae22d9e7eebada39d917cc42f990a04de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122603fae22d9e7eebada39d917cc42f990a04de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/122603fae22d9e7eebada39d917cc42f990a04de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122603fae22d9e7eebada39d917cc42f990a04de/comments", "author": null, "committer": null, "parents": [{"sha": "46936bf011ab06dd701ed45eb4967e0c2dfe49e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46936bf011ab06dd701ed45eb4967e0c2dfe49e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46936bf011ab06dd701ed45eb4967e0c2dfe49e5"}], "stats": {"total": 297, "additions": 139, "deletions": 158}, "files": [{"sha": "c70863ac88a8be9b2f6e73e4b72b19adaec8f144", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122603fae22d9e7eebada39d917cc42f990a04de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122603fae22d9e7eebada39d917cc42f990a04de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=122603fae22d9e7eebada39d917cc42f990a04de", "patch": "@@ -1,3 +1,10 @@\n+2010-09-03  Naveen H.S  <naveen.S@kpitcummins.com>\n+\n+\t* config/v850/v850.c (v850_function_value_regno_p): Make static.\n+\tAdjust comments. Declare.\n+\t(TARGET_FUNCTION_VALUE_REGNO_P): Define.\n+\t* config/v850/v850.h (FUNCTION_VALUE_REGNO_P): Delete.\n+\n 2010-09-17  Richard Guenther  <rguenther@suse.de>\n \n \t* common.opt (combine): Remove."}, {"sha": "dc047a2056c0cd8d761a0bfeba2e303ee5882eb7", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 126, "deletions": 152, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122603fae22d9e7eebada39d917cc42f990a04de/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122603fae22d9e7eebada39d917cc42f990a04de/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=122603fae22d9e7eebada39d917cc42f990a04de", "patch": "@@ -48,49 +48,12 @@\n #define streq(a,b) (strcmp (a, b) == 0)\n #endif\n \n-/* Function prototypes for stupid compilers:  */\n-static bool v850_handle_option       (size_t, const char *, int);\n-static void v850_option_optimization (int, int);\n-static void const_double_split       (rtx, HOST_WIDE_INT *, HOST_WIDE_INT *);\n-static int  const_costs_int          (HOST_WIDE_INT, int);\n-static int  const_costs\t\t     (rtx, enum rtx_code);\n-static bool v850_rtx_costs\t     (rtx, int, int, int *, bool);\n-static void substitute_ep_register   (rtx, rtx, int, int, rtx *, rtx *);\n-static void v850_reorg\t\t     (void);\n-static int  ep_memory_offset         (enum machine_mode, int);\n-static void v850_set_data_area       (tree, v850_data_area);\n-static tree v850_handle_interrupt_attribute (tree *, tree, tree, int, bool *);\n-static tree v850_handle_data_area_attribute (tree *, tree, tree, int, bool *);\n-static void v850_insert_attributes   (tree, tree *);\n-static void v850_asm_init_sections   (void);\n-static section *v850_select_section (tree, int, unsigned HOST_WIDE_INT);\n-static void v850_encode_data_area    (tree, rtx);\n-static void v850_encode_section_info (tree, rtx, int);\n-static int v850_issue_rate (void);\n-static bool v850_return_in_memory    (const_tree, const_tree);\n-static rtx v850_function_value (const_tree, const_tree, bool);\n-static void v850_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t\t tree, int *, int);\n-static bool v850_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t    const_tree, bool);\n-static int v850_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t   tree, bool);\n-static bool v850_strict_argument_naming (CUMULATIVE_ARGS *);\n-static rtx v850_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t      const_tree, bool);\n-static void v850_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t       const_tree, bool);\n-static bool v850_can_eliminate       (const int, const int);\n-static void v850_asm_trampoline_template (FILE *);\n-static void v850_trampoline_init (rtx, tree, rtx);\n-static void v850_print_operand (FILE *, rtx, int);\n static void v850_print_operand_address (FILE *, rtx);\n-static bool v850_print_operand_punct_valid_p (unsigned char code);\n \n /* Information about the various small memory areas.  */\n struct small_memory_info small_memory[ (int)SMALL_MEMORY_max ] =\n {\n-  /* name\tmax\tphysical max */\n+  /* Name\tMax\tPhysical max.  */\n   { \"tda\",\t0,\t\t256 },\n   { \"sda\",\t0,\t\t65536 },\n   { \"zda\",\t0,\t\t32768 },\n@@ -113,116 +76,11 @@ rtx v850_compare_op0, v850_compare_op1;\n /* Whether current function is an interrupt handler.  */\n static int v850_interrupt_p = FALSE;\n \n-static GTY(()) section *rosdata_section;\n-static GTY(()) section *rozdata_section;\n-static GTY(()) section *tdata_section;\n-static GTY(()) section *zdata_section;\n-static GTY(()) section *zbss_section;\n-\f\n-/* V850 specific attributes.  */\n-\n-static const struct attribute_spec v850_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"interrupt_handler\", 0, 0, true,  false, false, v850_handle_interrupt_attribute },\n-  { \"interrupt\",         0, 0, true,  false, false, v850_handle_interrupt_attribute },\n-  { \"sda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n-  { \"tda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n-  { \"zda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n-  { NULL,                0, 0, false, false, false, NULL }\n-};\n-\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n-\n-#undef TARGET_PRINT_OPERAND\n-#define TARGET_PRINT_OPERAND v850_print_operand\n-#undef TARGET_PRINT_OPERAND_ADDRESS\n-#define TARGET_PRINT_OPERAND_ADDRESS v850_print_operand_address\n-#undef TARGET_PRINT_OPERAND_PUNCT_VALID_P\n-#define TARGET_PRINT_OPERAND_PUNCT_VALID_P v850_print_operand_punct_valid_p\n-\n-#undef TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE v850_attribute_table\n-\n-#undef TARGET_INSERT_ATTRIBUTES\n-#define TARGET_INSERT_ATTRIBUTES v850_insert_attributes\n-\n-#undef  TARGET_ASM_SELECT_SECTION\n-#define TARGET_ASM_SELECT_SECTION  v850_select_section\n-\n-/* The assembler supports switchable .bss sections, but\n-   v850_select_section doesn't yet make use of them.  */\n-#undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n-#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false\n-\n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO v850_encode_section_info\n-\n-#undef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n-#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n-\n-#undef TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS (MASK_DEFAULT | MASK_APP_REGS)\n-#undef TARGET_HANDLE_OPTION\n-#define TARGET_HANDLE_OPTION v850_handle_option\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS v850_rtx_costs\n-\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n-\n-#undef TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG v850_reorg\n-\n-#undef TARGET_SCHED_ISSUE_RATE\n-#define TARGET_SCHED_ISSUE_RATE v850_issue_rate\n-\n-#undef TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n-\n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY v850_return_in_memory\n-\n-#undef TARGET_FUNCTION_VALUE\n-#define TARGET_FUNCTION_VALUE v850_function_value\n-\n-#undef TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE v850_pass_by_reference\n-\n-#undef TARGET_CALLEE_COPIES\n-#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n-\n-#undef TARGET_SETUP_INCOMING_VARARGS\n-#define TARGET_SETUP_INCOMING_VARARGS v850_setup_incoming_varargs\n-\n-#undef TARGET_ARG_PARTIAL_BYTES\n-#define TARGET_ARG_PARTIAL_BYTES v850_arg_partial_bytes\n-\n-#undef TARGET_FUNCTION_ARG\n-#define TARGET_FUNCTION_ARG v850_function_arg\n-\n-#undef TARGET_FUNCTION_ARG_ADVANCE\n-#define TARGET_FUNCTION_ARG_ADVANCE v850_function_arg_advance\n-\n-#undef TARGET_CAN_ELIMINATE\n-#define TARGET_CAN_ELIMINATE v850_can_eliminate\n-\n-#undef TARGET_ASM_TRAMPOLINE_TEMPLATE\n-#define TARGET_ASM_TRAMPOLINE_TEMPLATE v850_asm_trampoline_template\n-#undef TARGET_TRAMPOLINE_INIT\n-#define TARGET_TRAMPOLINE_INIT v850_trampoline_init\n-\n-#undef TARGET_STRICT_ARGUMENT_NAMING\n-#define TARGET_STRICT_ARGUMENT_NAMING v850_strict_argument_naming\n-\n-#undef TARGET_OPTION_OPTIMIZATION\n-#define TARGET_OPTION_OPTIMIZATION v850_option_optimization\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n+static GTY(()) section * rosdata_section;\n+static GTY(()) section * rozdata_section;\n+static GTY(()) section * tdata_section;\n+static GTY(()) section * zdata_section;\n+static GTY(()) section * zbss_section;\n \f\n /* Set the maximum size of small memory area TYPE to the value given\n    by VALUE.  Return true if VALUE was syntactically correct.  VALUE\n@@ -1120,7 +978,7 @@ v850_float_nz_comparison_operator (rtx op, enum machine_mode mode)\n }\n \n enum machine_mode\n-v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1)\n+v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1 ATTRIBUTE_UNUSED)\n {\n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n     {\n@@ -2022,8 +1880,6 @@ expand_epilogue (void)\n       && !interrupt_handler)\n     {\n       int alloc_stack = (4 * num_restore);\n-      int restore_func_len;\n-      int restore_normal_len;\n \n       /* Don't bother checking if we don't actually save any space.  */\n       if (use_prolog_function (num_restore, actual_fsize))\n@@ -2222,6 +2078,9 @@ notice_update_cc (rtx body, rtx insn)\n       /* Insn doesn't leave CC in a usable state.  */\n       CC_STATUS_INIT;\n       break;\n+\n+    default:\n+      break;\n     }\n }\n \n@@ -3157,6 +3016,14 @@ v850_select_section (tree exp,\n   return readonly_data_section;\n }\n \f\n+/* Worker function for TARGET_FUNCTION_VALUE_REGNO_P.  */\n+\n+static bool\n+v850_function_value_regno_p (const unsigned int regno)\n+{\n+  return (regno == 10);\n+}\n+\n /* Worker function for TARGET_RETURN_IN_MEMORY.  */\n \n static bool\n@@ -3168,7 +3035,7 @@ v850_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \n /* Worker function for TARGET_FUNCTION_VALUE.  */\n \n-rtx\n+static rtx\n v850_function_value (const_tree valtype, \n                     const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n                     bool outgoing ATTRIBUTE_UNUSED)\n@@ -3233,4 +3100,111 @@ v850_issue_rate (void)\n {\n   return (TARGET_V850E2_ALL? 2 : 1);\n }\n+\f\n+/* V850 specific attributes.  */\n+\n+static const struct attribute_spec v850_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt_handler\", 0, 0, true,  false, false, v850_handle_interrupt_attribute },\n+  { \"interrupt\",         0, 0, true,  false, false, v850_handle_interrupt_attribute },\n+  { \"sda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { \"tda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { \"zda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { NULL,                0, 0, false, false, false, NULL }\n+};\n+\f\n+/* Initialize the GCC target structure.  */\n+#undef  TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+\n+#undef  TARGET_PRINT_OPERAND\n+#define TARGET_PRINT_OPERAND v850_print_operand\n+#undef  TARGET_PRINT_OPERAND_ADDRESS\n+#define TARGET_PRINT_OPERAND_ADDRESS v850_print_operand_address\n+#undef  TARGET_PRINT_OPERAND_PUNCT_VALID_P\n+#define TARGET_PRINT_OPERAND_PUNCT_VALID_P v850_print_operand_punct_valid_p\n+\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE v850_attribute_table\n+\n+#undef  TARGET_INSERT_ATTRIBUTES\n+#define TARGET_INSERT_ATTRIBUTES v850_insert_attributes\n+\n+#undef  TARGET_ASM_SELECT_SECTION\n+#define TARGET_ASM_SELECT_SECTION  v850_select_section\n+\n+/* The assembler supports switchable .bss sections, but\n+   v850_select_section doesn't yet make use of them.  */\n+#undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false\n+\n+#undef  TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO v850_encode_section_info\n+\n+#undef  TARGET_ASM_FILE_START_FILE_DIRECTIVE\n+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n+\n+#undef  TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS (MASK_DEFAULT | MASK_APP_REGS)\n+#undef  TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION v850_handle_option\n+\n+#undef  TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS v850_rtx_costs\n+\n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n+\n+#undef  TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG v850_reorg\n+\n+#undef  TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE v850_issue_rate\n+\n+#undef  TARGET_FUNCTION_VALUE_REGNO_P\n+#define TARGET_FUNCTION_VALUE_REGNO_P v850_function_value_regno_p\n+#undef  TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE v850_function_value\n+\n+#undef  TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n+\n+#undef  TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY v850_return_in_memory\n+\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE v850_pass_by_reference\n+\n+#undef  TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n+\n+#undef  TARGET_SETUP_INCOMING_VARARGS\n+#define TARGET_SETUP_INCOMING_VARARGS v850_setup_incoming_varargs\n+\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES v850_arg_partial_bytes\n+\n+#undef  TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG v850_function_arg\n+\n+#undef  TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE v850_function_arg_advance\n+\n+#undef  TARGET_CAN_ELIMINATE\n+#define TARGET_CAN_ELIMINATE v850_can_eliminate\n+\n+#undef  TARGET_ASM_TRAMPOLINE_TEMPLATE\n+#define TARGET_ASM_TRAMPOLINE_TEMPLATE v850_asm_trampoline_template\n+#undef  TARGET_TRAMPOLINE_INIT\n+#define TARGET_TRAMPOLINE_INIT v850_trampoline_init\n+\n+#undef  TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING v850_strict_argument_naming\n+\n+#undef  TARGET_OPTION_OPTIMIZATION\n+#define TARGET_OPTION_OPTIMIZATION v850_option_optimization\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n #include \"gt-v850.h\""}, {"sha": "2afa3cb22a65b3b120d50d5c2029f9c77825e35f", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122603fae22d9e7eebada39d917cc42f990a04de/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122603fae22d9e7eebada39d917cc42f990a04de/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=122603fae22d9e7eebada39d917cc42f990a04de", "patch": "@@ -596,10 +596,6 @@ struct cum_arg { int nbytes; int anonymous_args; };\n #define LIBCALL_VALUE(MODE) \\\n   gen_rtx_REG (MODE, 10)\n \n-/* 1 if N is a possible register number for a function value.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 10)\n-\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n@@ -1071,6 +1067,10 @@ extern union tree_node * GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_K\n \n #define TARGET_ASM_INIT_SECTIONS v850_asm_init_sections\n \n-#endif /* ! GCC_V850_H */\n-\n+/* Define this so that the cc1plus will not think that system header files\n+   need an implicit 'extern \"C\" { ... }' assumed.  This breaks testing C++\n+   in a build directory where the libstdc++ header files are found via a\n+   -isystem <path-to-build-dir>.  */\n+#define NO_IMPLICIT_EXTERN_C\n \n+#endif /* ! GCC_V850_H */"}]}