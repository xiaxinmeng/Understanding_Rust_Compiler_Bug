{"sha": "5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "node_id": "C_kwDOANBUbNoAKDVmM2ZhMjY1NWNiMjU2ZDMzNmU5MGU3NGU0MmEyNDUyZDBmYmYwZTg", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-11-15T10:11:41Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-11-15T15:44:55Z"}, "message": "libsanitizer: merge from upstream ae59131d3ef311fb4b1e50627c6457be00e60dc9", "tree": {"sha": "374004f2a4a03bed153fff6a5d4ec156d105e0d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/374004f2a4a03bed153fff6a5d4ec156d105e0d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1288d850944f69a795e4ff444a427eba3fec11b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1288d850944f69a795e4ff444a427eba3fec11b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1288d850944f69a795e4ff444a427eba3fec11b"}], "stats": {"total": 774, "additions": 523, "deletions": 251}, "files": [{"sha": "6bb19c7d5ba81bcc0a3aa622ba5f262841414da6", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -1,4 +1,4 @@\n-84a71d5259c2682403cdbd8710592410a2f128ab\n+ae59131d3ef311fb4b1e50627c6457be00e60dc9\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "52d7eff7281e350b6a08510b5167672ed1593b73", "filename": "libsanitizer/asan/asan_allocator.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -803,8 +803,8 @@ struct Allocator {\n     sptr offset = 0;\n     if (!m1 || AsanChunkView(m1).AddrIsAtLeft(addr, 1, &offset)) {\n       // The address is in the chunk's left redzone, so maybe it is actually\n-      // a right buffer overflow from the other chunk to the left.\n-      // Search a bit to the left to see if there is another chunk.\n+      // a right buffer overflow from the other chunk before.\n+      // Search a bit before to see if there is another chunk.\n       AsanChunk *m2 = nullptr;\n       for (uptr l = 1; l < GetPageSizeCached(); l++) {\n         m2 = GetAsanChunkByAddr(addr - l);"}, {"sha": "0b4dbf03bb9d537135698cab586a69f614962d5d", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -135,12 +135,6 @@ typedef VeryCompactSizeClassMap SizeClassMap;\n const uptr kAllocatorSpace = ~(uptr)0;\n const uptr kAllocatorSize = 0x2000000000ULL;  // 128G.\n typedef VeryDenseSizeClassMap SizeClassMap;\n-# elif defined(__aarch64__)\n-// AArch64/SANITIZER_CAN_USE_ALLOCATOR64 is only for 42-bit VMA\n-// so no need to different values for different VMA.\n-const uptr kAllocatorSpace =  0x10000000000ULL;\n-const uptr kAllocatorSize  =  0x10000000000ULL;  // 3T.\n-typedef DefaultSizeClassMap SizeClassMap;\n #elif defined(__sparc__)\n const uptr kAllocatorSpace = ~(uptr)0;\n const uptr kAllocatorSize = 0x20000000000ULL;  // 2T."}, {"sha": "fbe92572b55b242fa1276fd69e12645bb29b8a23", "filename": "libsanitizer/asan/asan_descriptions.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_descriptions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_descriptions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -129,11 +129,11 @@ static void PrintHeapChunkAccess(uptr addr, const ChunkAccess &descr) {\n   str.append(\"%s\", d.Location());\n   switch (descr.access_type) {\n     case kAccessTypeLeft:\n-      str.append(\"%p is located %zd bytes to the left of\",\n+      str.append(\"%p is located %zd bytes before\",\n                  (void *)descr.bad_addr, descr.offset);\n       break;\n     case kAccessTypeRight:\n-      str.append(\"%p is located %zd bytes to the right of\",\n+      str.append(\"%p is located %zd bytes after\",\n                  (void *)descr.bad_addr, descr.offset);\n       break;\n     case kAccessTypeInside:\n@@ -279,17 +279,17 @@ static void DescribeAddressRelativeToGlobal(uptr addr, uptr access_size,\n   Decorator d;\n   str.append(\"%s\", d.Location());\n   if (addr < g.beg) {\n-    str.append(\"%p is located %zd bytes to the left\", (void *)addr,\n+    str.append(\"%p is located %zd bytes before\", (void *)addr,\n                g.beg - addr);\n   } else if (addr + access_size > g.beg + g.size) {\n     if (addr < g.beg + g.size) addr = g.beg + g.size;\n-    str.append(\"%p is located %zd bytes to the right\", (void *)addr,\n+    str.append(\"%p is located %zd bytes after\", (void *)addr,\n                addr - (g.beg + g.size));\n   } else {\n     // Can it happen?\n-    str.append(\"%p is located %zd bytes inside\", (void *)addr, addr - g.beg);\n+    str.append(\"%p is located %zd bytes inside of\", (void *)addr, addr - g.beg);\n   }\n-  str.append(\" of global variable '%s' defined in '\",\n+  str.append(\" global variable '%s' defined in '\",\n              MaybeDemangleGlobalName(g.name));\n   PrintGlobalLocation(&str, g);\n   str.append(\"' (0x%zx) of size %zu\\n\", g.beg, g.size);"}, {"sha": "f3befdf3c2b29bcfecd8918ffcdc3730e332c820", "filename": "libsanitizer/asan/asan_errors.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_errors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_errors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -539,7 +539,8 @@ static void PrintShadowBytes(InternalScopedString *str, const char *before,\n                              u8 *bytes, u8 *guilty, uptr n) {\n   Decorator d;\n   if (before)\n-    str->append(\"%s%p:\", before, (void *)bytes);\n+    str->append(\"%s%p:\", before,\n+                (void *)ShadowToMem(reinterpret_cast<uptr>(bytes)));\n   for (uptr i = 0; i < n; i++) {\n     u8 *p = bytes + i;\n     const char *before ="}, {"sha": "b780128c9adb431255babc43521f28dc16f4d8af", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -154,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -199,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);"}, {"sha": "c4bf087ea17f08f0b3082c523a82d2505b7b535d", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -81,12 +81,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else\n@@ -119,7 +114,7 @@ void InitializePlatformInterceptors();\n \n #if SANITIZER_LINUX &&                                                \\\n     (defined(__arm__) || defined(__aarch64__) || defined(__i386__) || \\\n-     defined(__x86_64__) || SANITIZER_RISCV64)\n+     defined(__x86_64__) || SANITIZER_RISCV64 || SANITIZER_LOONGARCH64)\n # define ASAN_INTERCEPT_VFORK 1\n #else\n # define ASAN_INTERCEPT_VFORK 0"}, {"sha": "bfc44b46196232fc6291beaffeec764541562e7e", "filename": "libsanitizer/asan/asan_interface.inc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface.inc?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -108,6 +108,13 @@ INTERFACE_FUNCTION(__asan_report_store_n_noabort)\n INTERFACE_FUNCTION(__asan_set_death_callback)\n INTERFACE_FUNCTION(__asan_set_error_report_callback)\n INTERFACE_FUNCTION(__asan_set_shadow_00)\n+INTERFACE_FUNCTION(__asan_set_shadow_01)\n+INTERFACE_FUNCTION(__asan_set_shadow_02)\n+INTERFACE_FUNCTION(__asan_set_shadow_03)\n+INTERFACE_FUNCTION(__asan_set_shadow_04)\n+INTERFACE_FUNCTION(__asan_set_shadow_05)\n+INTERFACE_FUNCTION(__asan_set_shadow_06)\n+INTERFACE_FUNCTION(__asan_set_shadow_07)\n INTERFACE_FUNCTION(__asan_set_shadow_f1)\n INTERFACE_FUNCTION(__asan_set_shadow_f2)\n INTERFACE_FUNCTION(__asan_set_shadow_f3)"}, {"sha": "987f855c0f9cefcc7aba01d2ebdf0b19ed46c5c4", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -90,6 +90,20 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_set_shadow_00(uptr addr, uptr size);\n   SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_01(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_02(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_03(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_04(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_05(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_06(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_07(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_set_shadow_f1(uptr addr, uptr size);\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_set_shadow_f2(uptr addr, uptr size);"}, {"sha": "c5f95c07a21056cf7cdf86142e95333226223c49", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -190,7 +190,7 @@\n #  elif defined(__aarch64__)\n #    define ASAN_SHADOW_OFFSET_CONST 0x0000001000000000\n #  elif defined(__powerpc64__)\n-#    define ASAN_SHADOW_OFFSET_CONST 0x0000020000000000\n+#    define ASAN_SHADOW_OFFSET_CONST 0x0000100000000000\n #  elif defined(__s390x__)\n #    define ASAN_SHADOW_OFFSET_CONST 0x0010000000000000\n #  elif SANITIZER_FREEBSD\n@@ -272,6 +272,8 @@ extern uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;  // Initialized in __asan_init.\n #  else\n #    define MEM_TO_SHADOW(mem) \\\n       (((mem) >> ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))\n+#    define SHADOW_TO_MEM(mem) \\\n+      (((mem) - (ASAN_SHADOW_OFFSET)) << (ASAN_SHADOW_SCALE))\n \n #    define kLowMemBeg 0\n #    define kLowMemEnd (ASAN_SHADOW_OFFSET ? ASAN_SHADOW_OFFSET - 1 : 0)\n@@ -376,6 +378,12 @@ static inline bool AddrIsInShadow(uptr a) {\n   return AddrIsInLowShadow(a) || AddrIsInMidShadow(a) || AddrIsInHighShadow(a);\n }\n \n+static inline uptr ShadowToMem(uptr p) {\n+  PROFILE_ASAN_MAPPING();\n+  CHECK(AddrIsInShadow(p));\n+  return SHADOW_TO_MEM(p);\n+}\n+\n static inline bool AddrIsAlignedByGranularity(uptr a) {\n   PROFILE_ASAN_MAPPING();\n   return (a & (ASAN_SHADOW_GRANULARITY - 1)) == 0;"}, {"sha": "e310c12fe301c74da19b27f7be43e76a60467d51", "filename": "libsanitizer/asan/asan_mapping_sparc64.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_mapping_sparc64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_mapping_sparc64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping_sparc64.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -28,6 +28,7 @@\n #define MEM_TO_SHADOW(mem)                                       \\\n   ((((mem) << HIGH_BITS) >> (HIGH_BITS + (ASAN_SHADOW_SCALE))) + \\\n    (ASAN_SHADOW_OFFSET))\n+#define SHADOW_TO_MEM(ptr) (__asan::ShadowToMemSparc64(ptr))\n \n #define kLowMemBeg 0\n #define kLowMemEnd (ASAN_SHADOW_OFFSET - 1)\n@@ -97,6 +98,24 @@ static inline bool AddrIsInShadowGap(uptr a) {\n   return a >= kShadowGapBeg && a <= kShadowGapEnd;\n }\n \n+static inline constexpr uptr ShadowToMemSparc64(uptr p) {\n+  PROFILE_ASAN_MAPPING();\n+  p -= ASAN_SHADOW_OFFSET;\n+  p <<= ASAN_SHADOW_SCALE;\n+  if (p >= 0x8000000000000) {\n+    p |= (~0ULL) << VMA_BITS;\n+  }\n+  return p;\n+}\n+\n+static_assert(ShadowToMemSparc64(MEM_TO_SHADOW(0x0000000000000000)) ==\n+              0x0000000000000000);\n+static_assert(ShadowToMemSparc64(MEM_TO_SHADOW(0xfff8000000000000)) ==\n+              0xfff8000000000000);\n+// Gets aligned down.\n+static_assert(ShadowToMemSparc64(MEM_TO_SHADOW(0x0007ffffffffffff)) ==\n+              0x0007fffffffffff8);\n+\n }  // namespace __asan\n \n #endif  // ASAN_MAPPING_SPARC64_H"}, {"sha": "e470256346314eb4cbf28669e036322d307acea1", "filename": "libsanitizer/asan/asan_poisoning.cpp", "status": "modified", "additions": 87, "deletions": 5, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -312,6 +312,34 @@ void __asan_set_shadow_00(uptr addr, uptr size) {\n   REAL(memset)((void *)addr, 0, size);\n }\n \n+void __asan_set_shadow_01(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0x01, size);\n+}\n+\n+void __asan_set_shadow_02(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0x02, size);\n+}\n+\n+void __asan_set_shadow_03(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0x03, size);\n+}\n+\n+void __asan_set_shadow_04(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0x04, size);\n+}\n+\n+void __asan_set_shadow_05(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0x05, size);\n+}\n+\n+void __asan_set_shadow_06(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0x06, size);\n+}\n+\n+void __asan_set_shadow_07(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0x07, size);\n+}\n+\n void __asan_set_shadow_f1(uptr addr, uptr size) {\n   REAL(memset)((void *)addr, 0xf1, size);\n }\n@@ -354,15 +382,64 @@ void __sanitizer_annotate_contiguous_container(const void *beg_p,\n   uptr old_mid = reinterpret_cast<uptr>(old_mid_p);\n   uptr new_mid = reinterpret_cast<uptr>(new_mid_p);\n   uptr granularity = ASAN_SHADOW_GRANULARITY;\n-  if (!(beg <= old_mid && beg <= new_mid && old_mid <= end && new_mid <= end &&\n-        IsAligned(beg, granularity))) {\n+  if (!(beg <= old_mid && beg <= new_mid && old_mid <= end && new_mid <= end)) {\n     GET_STACK_TRACE_FATAL_HERE;\n     ReportBadParamsToAnnotateContiguousContainer(beg, end, old_mid, new_mid,\n                                                  &stack);\n   }\n   CHECK_LE(end - beg,\n            FIRST_32_SECOND_64(1UL << 30, 1ULL << 40)); // Sanity check.\n \n+  if (old_mid == new_mid)\n+    return;  // Nothing to do here.\n+\n+  // Handle misaligned end and cut it off.\n+  if (UNLIKELY(!AddrIsAlignedByGranularity(end))) {\n+    uptr end_down = RoundDownTo(end, granularity);\n+    // Either new or old mid must be in the granule to affect it.\n+    if (new_mid > end_down) {\n+      if (AddressIsPoisoned(end)) {\n+        *(u8 *)MemToShadow(end_down) = static_cast<u8>(new_mid - end_down);\n+      } else {\n+        // Something after the container - don't touch.\n+      }\n+    } else if (old_mid > end_down) {\n+      if (AddressIsPoisoned(end)) {\n+        *(u8 *)MemToShadow(end_down) = kAsanContiguousContainerOOBMagic;\n+      } else {\n+        // Something after the container - don't touch.\n+      }\n+    }\n+\n+    if (beg >= end_down)\n+      return;  // Same granule.\n+\n+    old_mid = Min(end_down, old_mid);\n+    new_mid = Min(end_down, new_mid);\n+  }\n+\n+  // Handle misaligned begin and cut it off.\n+  if (UNLIKELY(!AddrIsAlignedByGranularity(beg))) {\n+    uptr beg_up = RoundUpTo(beg, granularity);\n+    uptr beg_down = RoundDownTo(beg, granularity);\n+    // As soon as we add first byte into container we will not be able to\n+    // determine the state of the byte before the container. So we assume it's\n+    // always unpoison.\n+\n+    // Either new or old mid must be in the granule to affect it.\n+    if (new_mid < beg_up) {\n+      *(u8 *)MemToShadow(beg_down) = static_cast<u8>(new_mid - beg_down);\n+    } else if (old_mid < beg_up) {\n+      *(u8 *)MemToShadow(beg_down) = 0;\n+    }\n+\n+    old_mid = Max(beg_up, old_mid);\n+    new_mid = Max(beg_up, new_mid);\n+  }\n+\n+  if (old_mid == new_mid)\n+    return;\n+\n   uptr a = RoundDownTo(Min(old_mid, new_mid), granularity);\n   uptr c = RoundUpTo(Max(old_mid, new_mid), granularity);\n   uptr d1 = RoundDownTo(old_mid, granularity);\n@@ -397,8 +474,13 @@ const void *__sanitizer_contiguous_container_find_bad_address(\n     const void *beg_p, const void *mid_p, const void *end_p) {\n   if (!flags()->detect_container_overflow)\n     return nullptr;\n+  uptr granularity = ASAN_SHADOW_GRANULARITY;\n   uptr beg = reinterpret_cast<uptr>(beg_p);\n   uptr end = reinterpret_cast<uptr>(end_p);\n+  uptr annotations_end =\n+      (!AddrIsAlignedByGranularity(end) && !AddressIsPoisoned(end))\n+          ? RoundDownTo(end, granularity)\n+          : end;\n   uptr mid = reinterpret_cast<uptr>(mid_p);\n   CHECK_LE(beg, mid);\n   CHECK_LE(mid, end);\n@@ -408,9 +490,9 @@ const void *__sanitizer_contiguous_container_find_bad_address(\n   uptr r1_beg = beg;\n   uptr r1_end = Min(beg + kMaxRangeToCheck, mid);\n   uptr r2_beg = Max(beg, mid - kMaxRangeToCheck);\n-  uptr r2_end = Min(end, mid + kMaxRangeToCheck);\n-  uptr r3_beg = Max(end - kMaxRangeToCheck, mid);\n-  uptr r3_end = end;\n+  uptr r2_end = Min(annotations_end, mid + kMaxRangeToCheck);\n+  uptr r3_beg = Max(annotations_end - kMaxRangeToCheck, mid);\n+  uptr r3_end = annotations_end;\n   for (uptr i = r1_beg; i < r1_end; i++)\n     if (AddressIsPoisoned(i))\n       return reinterpret_cast<const void *>(i);"}, {"sha": "853083182b487871f5063b107763cb19bb406bc0", "filename": "libsanitizer/asan/asan_rtl.cpp", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fasan%2Fasan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -288,11 +288,18 @@ static NOINLINE void force_interface_symbols() {\n     case 38: __asan_region_is_poisoned(0, 0); break;\n     case 39: __asan_describe_address(0); break;\n     case 40: __asan_set_shadow_00(0, 0); break;\n-    case 41: __asan_set_shadow_f1(0, 0); break;\n-    case 42: __asan_set_shadow_f2(0, 0); break;\n-    case 43: __asan_set_shadow_f3(0, 0); break;\n-    case 44: __asan_set_shadow_f5(0, 0); break;\n-    case 45: __asan_set_shadow_f8(0, 0); break;\n+    case 41: __asan_set_shadow_01(0, 0); break;\n+    case 42: __asan_set_shadow_02(0, 0); break;\n+    case 43: __asan_set_shadow_03(0, 0); break;\n+    case 44: __asan_set_shadow_04(0, 0); break;\n+    case 45: __asan_set_shadow_05(0, 0); break;\n+    case 46: __asan_set_shadow_06(0, 0); break;\n+    case 47: __asan_set_shadow_07(0, 0); break;\n+    case 48: __asan_set_shadow_f1(0, 0); break;\n+    case 49: __asan_set_shadow_f2(0, 0); break;\n+    case 50: __asan_set_shadow_f3(0, 0); break;\n+    case 51: __asan_set_shadow_f5(0, 0); break;\n+    case 52: __asan_set_shadow_f8(0, 0); break;\n   }\n   // clang-format on\n }"}, {"sha": "9db4fb09409cb887a8ba16854c8b377b85c496b7", "filename": "libsanitizer/hwasan/hwasan.cpp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fhwasan%2Fhwasan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fhwasan%2Fhwasan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -340,7 +340,13 @@ __attribute__((constructor(0))) void __hwasan_init() {\n   DisableCoreDumperIfNecessary();\n \n   InitInstrumentation();\n-  InitLoadedGlobals();\n+  if constexpr (!SANITIZER_FUCHSIA) {\n+    // Fuchsia's libc provides a hook (__sanitizer_module_loaded) that runs on\n+    // the startup path which calls into __hwasan_library_loaded on all\n+    // initially loaded modules, so explicitly registering the globals here\n+    // isn't needed.\n+    InitLoadedGlobals();\n+  }\n \n   // Needs to be called here because flags()->random_tags might not have been\n   // initialized when InitInstrumentation() was called."}, {"sha": "4a226ee2ab8acac1764fdee22a27ef9443073c22", "filename": "libsanitizer/hwasan/hwasan_flags.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fhwasan%2Fhwasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fhwasan%2Fhwasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_flags.inc?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -39,7 +39,7 @@ HWASAN_FLAG(\n \n HWASAN_FLAG(bool, free_checks_tail_magic, 1,\n     \"If set, free() will check the magic values \"\n-    \"to the right of the allocated object \"\n+    \"after the allocated object \"\n     \"if the allocation size is not a divident of the granule size\")\n HWASAN_FLAG(\n     int, max_free_fill_size, 0,"}, {"sha": "858fac05af23c0fef0ff11e888a4238f9029b8bb", "filename": "libsanitizer/hwasan/hwasan_fuchsia.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -224,6 +224,10 @@ void __sanitizer_thread_exit_hook(void *hook, thrd_t self) {\n   __hwasan::ThreadExitHook(hook, self);\n }\n \n+void __sanitizer_module_loaded(const struct dl_phdr_info *info, size_t) {\n+  __hwasan_library_loaded(info->dlpi_addr, info->dlpi_phdr, info->dlpi_phnum);\n+}\n+\n }  // extern \"C\"\n \n #endif  // SANITIZER_FUCHSIA"}, {"sha": "de082150b7056b259c935ed11d530ffd975ec853", "filename": "libsanitizer/hwasan/hwasan_report.cpp", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fhwasan%2Fhwasan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fhwasan%2Fhwasan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_report.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -309,16 +309,16 @@ static void ShowHeapOrGlobalCandidate(uptr untagged_addr, tag_t *candidate,\n       whence = \"inside\";\n     } else if (candidate == left) {\n       offset = untagged_addr - chunk.End();\n-      whence = \"to the right of\";\n+      whence = \"after\";\n     } else {\n       offset = chunk.Beg() - untagged_addr;\n-      whence = \"to the left of\";\n+      whence = \"before\";\n     }\n     Printf(\"%s\", d.Error());\n     Printf(\"\\nCause: heap-buffer-overflow\\n\");\n     Printf(\"%s\", d.Default());\n     Printf(\"%s\", d.Location());\n-    Printf(\"%p is located %zd bytes %s %zd-byte region [%p,%p)\\n\",\n+    Printf(\"%p is located %zd bytes %s a %zd-byte region [%p,%p)\\n\",\n            untagged_addr, offset, whence, chunk.UsedSize(), chunk.Beg(),\n            chunk.End());\n     Printf(\"%s\", d.Allocation());\n@@ -340,27 +340,27 @@ static void ShowHeapOrGlobalCandidate(uptr untagged_addr, tag_t *candidate,\n     Printf(\"%s\", d.Location());\n     if (sym->SymbolizeData(mem, &info) && info.start) {\n       Printf(\n-          \"%p is located %zd bytes to the %s of %zd-byte global variable \"\n+          \"%p is located %zd bytes %s a %zd-byte global variable \"\n           \"%s [%p,%p) in %s\\n\",\n           untagged_addr,\n           candidate == left ? untagged_addr - (info.start + info.size)\n                             : info.start - untagged_addr,\n-          candidate == left ? \"right\" : \"left\", info.size, info.name,\n+          candidate == left ? \"after\" : \"before\", info.size, info.name,\n           info.start, info.start + info.size, module_name);\n     } else {\n       uptr size = GetGlobalSizeFromDescriptor(mem);\n       if (size == 0)\n         // We couldn't find the size of the global from the descriptors.\n         Printf(\n-            \"%p is located to the %s of a global variable in \"\n+            \"%p is located %s a global variable in \"\n             \"\\n    #0 0x%x (%s+0x%x)\\n\",\n-            untagged_addr, candidate == left ? \"right\" : \"left\", mem,\n+            untagged_addr, candidate == left ? \"after\" : \"before\", mem,\n             module_name, module_address);\n       else\n         Printf(\n-            \"%p is located to the %s of a %zd-byte global variable in \"\n+            \"%p is located %s a %zd-byte global variable in \"\n             \"\\n    #0 0x%x (%s+0x%x)\\n\",\n-            untagged_addr, candidate == left ? \"right\" : \"left\", size, mem,\n+            untagged_addr, candidate == left ? \"after\" : \"before\", size, mem,\n             module_name, module_address);\n     }\n     Printf(\"%s\", d.Default());\n@@ -459,7 +459,7 @@ void PrintAddressDescription(\n       Printf(\"%s\", d.Error());\n       Printf(\"\\nCause: use-after-free\\n\");\n       Printf(\"%s\", d.Location());\n-      Printf(\"%p is located %zd bytes inside of %zd-byte region [%p,%p)\\n\",\n+      Printf(\"%p is located %zd bytes inside a %zd-byte region [%p,%p)\\n\",\n              untagged_addr, untagged_addr - UntagAddr(har.tagged_addr),\n              har.requested_size, UntagAddr(har.tagged_addr),\n              UntagAddr(har.tagged_addr) + har.requested_size);\n@@ -518,7 +518,7 @@ static void PrintTagInfoAroundAddr(tag_t *tag_ptr, uptr num_rows,\n   InternalScopedString s;\n   for (tag_t *row = beg_row; row < end_row; row += row_len) {\n     s.append(\"%s\", row == center_row_beg ? \"=>\" : \"  \");\n-    s.append(\"%p:\", (void *)row);\n+    s.append(\"%p:\", (void *)ShadowToMem(reinterpret_cast<uptr>(row)));\n     for (uptr i = 0; i < row_len; i++) {\n       s.append(\"%s\", row + i == tag_ptr ? \"[\" : \" \");\n       print_tag(s, &row[i]);\n@@ -660,7 +660,7 @@ void ReportTailOverwritten(StackTrace *stack, uptr tagged_addr, uptr orig_size,\n     s.append(\"%s \", actual_expected[i] != tail[i] ? \"^^\" : \"  \");\n \n   s.append(\"\\nThis error occurs when a buffer overflow overwrites memory\\n\"\n-    \"to the right of a heap object, but within the %zd-byte granule, e.g.\\n\"\n+    \"after a heap object, but within the %zd-byte granule, e.g.\\n\"\n     \"   char *x = new char[20];\\n\"\n     \"   x[25] = 42;\\n\"\n     \"%s does not detect such bugs in uninstrumented code at the time of write,\""}, {"sha": "854b12cda36ec266bb25f866919510becb44e38c", "filename": "libsanitizer/include/sanitizer/msan_interface.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -92,6 +92,8 @@ extern \"C\" {\n \n   /* Tell MSan about newly destroyed memory. Mark memory as uninitialized. */\n   void __sanitizer_dtor_callback(const volatile void* data, size_t size);\n+  void __sanitizer_dtor_callback_fields(const volatile void *data, size_t size);\n+  void __sanitizer_dtor_callback_vptr(const volatile void *data);\n \n   /* This function may be optionally provided by user and should return\n      a string containing Msan runtime options. See msan_flags.h for details. */"}, {"sha": "576274608c83e32252bfd22aedbe4b56d3df4355", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -26,6 +26,18 @@\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n \n #if CAN_SANITIZE_LEAKS\n+\n+#  if SANITIZER_APPLE\n+// https://github.com/apple-oss-distributions/objc4/blob/8701d5672d3fd3cd817aeb84db1077aafe1a1604/runtime/objc-runtime-new.h#L127\n+#    if SANITIZER_IOS && !SANITIZER_IOSSIM\n+#      define OBJC_DATA_MASK 0x0000007ffffffff8UL\n+#    else\n+#      define OBJC_DATA_MASK 0x00007ffffffffff8UL\n+#    endif\n+// https://github.com/apple-oss-distributions/objc4/blob/8701d5672d3fd3cd817aeb84db1077aafe1a1604/runtime/objc-runtime-new.h#L139\n+#    define OBJC_FAST_IS_RW 0x8000000000000000UL\n+#  endif\n+\n namespace __lsan {\n \n // This mutex is used to prevent races between DoLeakCheck and IgnoreObject, and\n@@ -160,6 +172,17 @@ static uptr GetCallerPC(const StackTrace &stack) {\n   return 0;\n }\n \n+#  if SANITIZER_APPLE\n+// Objective-C class data pointers are stored with flags in the low bits, so\n+// they need to be transformed back into something that looks like a pointer.\n+static inline void *MaybeTransformPointer(void *p) {\n+  uptr ptr = reinterpret_cast<uptr>(p);\n+  if ((ptr & OBJC_FAST_IS_RW) == OBJC_FAST_IS_RW)\n+    ptr &= OBJC_DATA_MASK;\n+  return reinterpret_cast<void *>(ptr);\n+}\n+#  endif\n+\n // On Linux, treats all chunks allocated from ld-linux.so as reachable, which\n // covers dynamically allocated TLS blocks, internal dynamic loader's loaded\n // modules accounting etc.\n@@ -276,6 +299,9 @@ void ScanRangeForPointers(uptr begin, uptr end, Frontier *frontier,\n     pp = pp + alignment - pp % alignment;\n   for (; pp + sizeof(void *) <= end; pp += alignment) {\n     void *p = *reinterpret_cast<void **>(pp);\n+#  if SANITIZER_APPLE\n+    p = MaybeTransformPointer(p);\n+#  endif\n     if (!MaybeUserPointer(reinterpret_cast<uptr>(p)))\n       continue;\n     uptr chunk = PointsIntoChunk(p);\n@@ -332,7 +358,8 @@ void ForEachExtraStackRangeCb(uptr begin, uptr end, void *arg) {\n #  if SANITIZER_FUCHSIA\n \n // Fuchsia handles all threads together with its own callback.\n-static void ProcessThreads(SuspendedThreadsList const &, Frontier *) {}\n+static void ProcessThreads(SuspendedThreadsList const &, Frontier *, tid_t,\n+                           uptr) {}\n \n #  else\n \n@@ -365,7 +392,8 @@ static void ProcessThreadRegistry(Frontier *frontier) {\n \n // Scans thread data (stacks and TLS) for heap pointers.\n static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n-                           Frontier *frontier) {\n+                           Frontier *frontier, tid_t caller_tid,\n+                           uptr caller_sp) {\n   InternalMmapVector<uptr> registers;\n   for (uptr i = 0; i < suspended_threads.ThreadCount(); i++) {\n     tid_t os_id = static_cast<tid_t>(suspended_threads.GetThreadID(i));\n@@ -392,6 +420,9 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n         continue;\n       sp = stack_begin;\n     }\n+    if (suspended_threads.GetThreadID(i) == caller_tid) {\n+      sp = caller_sp;\n+    }\n \n     if (flags()->use_registers && have_registers) {\n       uptr registers_begin = reinterpret_cast<uptr>(registers.data());\n@@ -572,7 +603,8 @@ static void CollectIgnoredCb(uptr chunk, void *arg) {\n \n // Sets the appropriate tag on each chunk.\n static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads,\n-                              Frontier *frontier) {\n+                              Frontier *frontier, tid_t caller_tid,\n+                              uptr caller_sp) {\n   const InternalMmapVector<u32> &suppressed_stacks =\n       GetSuppressionContext()->GetSortedSuppressedStacks();\n   if (!suppressed_stacks.empty()) {\n@@ -581,7 +613,7 @@ static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads,\n   }\n   ForEachChunk(CollectIgnoredCb, frontier);\n   ProcessGlobalRegions(frontier);\n-  ProcessThreads(suspended_threads, frontier);\n+  ProcessThreads(suspended_threads, frontier, caller_tid, caller_sp);\n   ProcessRootRegions(frontier);\n   FloodFillTag(frontier, kReachable);\n \n@@ -677,7 +709,8 @@ static void CheckForLeaksCallback(const SuspendedThreadsList &suspended_threads,\n   CHECK(param);\n   CHECK(!param->success);\n   ReportUnsuspendedThreads(suspended_threads);\n-  ClassifyAllChunks(suspended_threads, &param->frontier);\n+  ClassifyAllChunks(suspended_threads, &param->frontier, param->caller_tid,\n+                    param->caller_sp);\n   ForEachChunk(CollectLeaksCb, &param->leaks);\n   // Clean up for subsequent leak checks. This assumes we did not overwrite any\n   // kIgnored tags.\n@@ -716,6 +749,12 @@ static bool CheckForLeaks() {\n   for (int i = 0;; ++i) {\n     EnsureMainThreadIDIsCorrect();\n     CheckForLeaksParam param;\n+    // Capture calling thread's stack pointer early, to avoid false negatives.\n+    // Old frame with dead pointers might be overlapped by new frame inside\n+    // CheckForLeaks which does not use bytes with pointers before the\n+    // threads are suspended and stack pointers captured.\n+    param.caller_tid = GetTid();\n+    param.caller_sp = reinterpret_cast<uptr>(__builtin_frame_address(0));\n     LockStuffAndStopTheWorld(CheckForLeaksCallback, &param);\n     if (!param.success) {\n       Report(\"LeakSanitizer has encountered a fatal error.\\n\");"}, {"sha": "20ef7c458b42a5af3a0ffdf23e01586ec9af85e2", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -145,6 +145,8 @@ struct RootRegion {\n struct CheckForLeaksParam {\n   Frontier frontier;\n   LeakedChunks leaks;\n+  tid_t caller_tid;\n+  uptr caller_sp;\n   bool success = false;\n };\n "}, {"sha": "b6b15095744d7e8aefbe8e13acb52e46d56ffee5", "filename": "libsanitizer/lsan/lsan_common_mac.cpp", "status": "modified", "additions": 54, "deletions": 20, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_mac.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -17,21 +17,36 @@\n \n #if CAN_SANITIZE_LEAKS && SANITIZER_APPLE\n \n-#include \"sanitizer_common/sanitizer_allocator_internal.h\"\n-#include \"lsan_allocator.h\"\n+#  include <mach/mach.h>\n+#  include <mach/vm_statistics.h>\n+#  include <pthread.h>\n \n-#include <pthread.h>\n+#  include \"lsan_allocator.h\"\n+#  include \"sanitizer_common/sanitizer_allocator_internal.h\"\n+namespace __lsan {\n \n-#include <mach/mach.h>\n+enum class SeenRegion {\n+  None = 0,\n+  AllocOnce = 1 << 0,\n+  LibDispatch = 1 << 1,\n+  Foundation = 1 << 2,\n+  All = AllocOnce | LibDispatch | Foundation\n+};\n+\n+inline SeenRegion operator|(SeenRegion left, SeenRegion right) {\n+  return static_cast<SeenRegion>(static_cast<int>(left) |\n+                                 static_cast<int>(right));\n+}\n \n-// Only introduced in Mac OS X 10.9.\n-#ifdef VM_MEMORY_OS_ALLOC_ONCE\n-static const int kSanitizerVmMemoryOsAllocOnce = VM_MEMORY_OS_ALLOC_ONCE;\n-#else\n-static const int kSanitizerVmMemoryOsAllocOnce = 73;\n-#endif\n+inline SeenRegion &operator|=(SeenRegion &left, const SeenRegion &right) {\n+  left = left | right;\n+  return left;\n+}\n \n-namespace __lsan {\n+struct RegionScanState {\n+  SeenRegion seen_regions = SeenRegion::None;\n+  bool in_libdispatch = false;\n+};\n \n typedef struct {\n   int disable_counter;\n@@ -148,6 +163,7 @@ void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n \n   InternalMmapVectorNoCtor<RootRegion> const *root_regions = GetRootRegions();\n \n+  RegionScanState scan_state;\n   while (err == KERN_SUCCESS) {\n     vm_size_t size = 0;\n     unsigned depth = 1;\n@@ -157,17 +173,35 @@ void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n                                (vm_region_info_t)&info, &count);\n \n     uptr end_address = address + size;\n-\n-    // libxpc stashes some pointers in the Kernel Alloc Once page,\n-    // make sure not to report those as leaks.\n-    if (info.user_tag == kSanitizerVmMemoryOsAllocOnce) {\n+    if (info.user_tag == VM_MEMORY_OS_ALLOC_ONCE) {\n+      // libxpc stashes some pointers in the Kernel Alloc Once page,\n+      // make sure not to report those as leaks.\n+      scan_state.seen_regions |= SeenRegion::AllocOnce;\n       ScanRangeForPointers(address, end_address, frontier, \"GLOBAL\",\n                            kReachable);\n+    } else if (info.user_tag == VM_MEMORY_FOUNDATION) {\n+      // Objective-C block trampolines use the Foundation region.\n+      scan_state.seen_regions |= SeenRegion::Foundation;\n+      ScanRangeForPointers(address, end_address, frontier, \"GLOBAL\",\n+                           kReachable);\n+    } else if (info.user_tag == VM_MEMORY_LIBDISPATCH) {\n+      // Dispatch continuations use the libdispatch region. Empirically, there\n+      // can be more than one region with this tag, so we'll optimistically\n+      // assume that they're continguous. Otherwise, we would need to scan every\n+      // region to ensure we find them all.\n+      scan_state.in_libdispatch = true;\n+      ScanRangeForPointers(address, end_address, frontier, \"GLOBAL\",\n+                           kReachable);\n+    } else if (scan_state.in_libdispatch) {\n+      scan_state.seen_regions |= SeenRegion::LibDispatch;\n+      scan_state.in_libdispatch = false;\n+    }\n \n-      // Recursing over the full memory map is very slow, break out\n-      // early if we don't need the full iteration.\n-      if (!flags()->use_root_regions || !root_regions->size())\n-        break;\n+    // Recursing over the full memory map is very slow, break out\n+    // early if we don't need the full iteration.\n+    if (scan_state.seen_regions == SeenRegion::All &&\n+        !(flags()->use_root_regions && root_regions->size() > 0)) {\n+      break;\n     }\n \n     // This additional root region scan is required on Darwin in order to\n@@ -199,6 +233,6 @@ void LockStuffAndStopTheWorld(StopTheWorldCallback callback,\n   StopTheWorld(callback, argument);\n }\n \n-} // namespace __lsan\n+}  // namespace __lsan\n \n #endif // CAN_SANITIZE_LEAKS && SANITIZER_APPLE"}, {"sha": "b462e388c232ec1a68f037519b78e83b4126b98c", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -709,6 +709,7 @@ enum ModuleArch {\n   kModuleArchARMV7S,\n   kModuleArchARMV7K,\n   kModuleArchARM64,\n+  kModuleArchLoongArch64,\n   kModuleArchRISCV64,\n   kModuleArchHexagon\n };\n@@ -781,6 +782,8 @@ inline const char *ModuleArchToString(ModuleArch arch) {\n       return \"armv7k\";\n     case kModuleArchARM64:\n       return \"arm64\";\n+    case kModuleArchLoongArch64:\n+      return \"loongarch64\";\n     case kModuleArchRISCV64:\n       return \"riscv64\";\n     case kModuleArchHexagon:"}, {"sha": "ba4b80081f0f431eea38f3a03bfb5341f5321e16", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -6727,7 +6727,7 @@ INTERCEPTOR(int, sem_init, __sanitizer_sem_t *s, int pshared, unsigned value) {\n   COMMON_INTERCEPTOR_ENTER(ctx, sem_init, s, pshared, value);\n   // Workaround a bug in glibc's \"old\" semaphore implementation by\n   // zero-initializing the sem_t contents. This has to be done here because\n-  // interceptors bind to the lowest symbols version by default, hitting the\n+  // interceptors bind to the lowest version before glibc 2.36, hitting the\n   // buggy code path while the non-sanitized build of the same code works fine.\n   REAL(memset)(s, 0, sizeof(*s));\n   int res = REAL(sem_init)(s, pshared, value);"}, {"sha": "68782acb379d134c47bc5e7cf94fb58af3c5392f", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_loongarch64.inc.S", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_loongarch64.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_loongarch64.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_loongarch64.inc.S?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -5,12 +5,6 @@\n ASM_HIDDEN(COMMON_INTERCEPTOR_SPILL_AREA)\n ASM_HIDDEN(_ZN14__interception10real_vforkE)\n \n-.bss\n-.type _ZN14__interception10real_vforkE, @object\n-.size _ZN14__interception10real_vforkE, 8\n-_ZN14__interception10real_vforkE:\n-        .zero     8\n-\n .text\n .globl ASM_WRAPPER_NAME(vfork)\n ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))"}, {"sha": "f23ea9da37149ee991ae29eb2070a6d88f074b2d", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -1105,14 +1105,15 @@ uptr GetMaxVirtualAddress() {\n #if SANITIZER_NETBSD && defined(__x86_64__)\n   return 0x7f7ffffff000ULL;  // (0x00007f8000000000 - PAGE_SIZE)\n #elif SANITIZER_WORDSIZE == 64\n-# if defined(__powerpc64__) || defined(__aarch64__)\n+# if defined(__powerpc64__) || defined(__aarch64__) || defined(__loongarch__)\n   // On PowerPC64 we have two different address space layouts: 44- and 46-bit.\n   // We somehow need to figure out which one we are using now and choose\n   // one of 0x00000fffffffffffUL and 0x00003fffffffffffUL.\n   // Note that with 'ulimit -s unlimited' the stack is moved away from the top\n   // of the address space, so simply checking the stack address is not enough.\n   // This should (does) work for both PowerPC64 Endian modes.\n   // Similarly, aarch64 has multiple address space layouts: 39, 42 and 47-bit.\n+  // loongarch64 also has multiple address space layouts: default is 47-bit.\n   return (1ULL << (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1)) - 1;\n #elif SANITIZER_RISCV64\n   return (1ULL << 38) - 1;\n@@ -1955,6 +1956,13 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n   u64 esr;\n   if (!Aarch64GetESR(ucontext, &esr)) return Unknown;\n   return esr & ESR_ELx_WNR ? Write : Read;\n+#elif defined(__loongarch__)\n+  u32 flags = ucontext->uc_mcontext.__flags;\n+  if (flags & SC_ADDRERR_RD)\n+    return SignalContext::Read;\n+  if (flags & SC_ADDRERR_WR)\n+    return SignalContext::Write;\n+  return SignalContext::Unknown;\n #elif defined(__sparc__)\n   // Decode the instruction to determine the access type.\n   // From OpenSolaris $SRC/uts/sun4/os/trap.c (get_accesstype)."}, {"sha": "d74851c43e14e2627d596ee59ce5062f0b348b29", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -822,13 +822,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n "}, {"sha": "23c4c6619de82d2ca065564b52adee60f3ee4207", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -38,7 +38,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -71,15 +71,7 @@ extern \"C\" {\n #include <mach/mach_time.h>\n #include <mach/vm_statistics.h>\n #include <malloc/malloc.h>\n-#if defined(__has_builtin) && __has_builtin(__builtin_os_log_format)\n-# include <os/log.h>\n-#else\n-   /* Without support for __builtin_os_log_format, fall back to the older\n-      method.  */\n-# define OS_LOG_DEFAULT 0\n-# define os_log_error(A,B,C) \\\n-  asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", (C));\n-#endif\n+#include <os/log.h>\n #include <pthread.h>\n #include <pthread/introspection.h>\n #include <sched.h>\n@@ -1259,6 +1251,7 @@ uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n   mach_vm_address_t start_address =\n     (SANITIZER_WORDSIZE == 32) ? 0x000000001000 : 0x000100000000;\n \n+  const mach_vm_address_t max_vm_address = GetMaxVirtualAddress() + 1;\n   mach_vm_address_t address = start_address;\n   mach_vm_address_t free_begin = start_address;\n   kern_return_t kr = KERN_SUCCESS;\n@@ -1273,15 +1266,15 @@ uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n                                 (vm_region_info_t)&vminfo, &count);\n     if (kr == KERN_INVALID_ADDRESS) {\n       // No more regions beyond \"address\", consider the gap at the end of VM.\n-      address = GetMaxVirtualAddress() + 1;\n+      address = max_vm_address;\n       vmsize = 0;\n     } else {\n       if (max_occupied_addr) *max_occupied_addr = address + vmsize;\n     }\n     if (free_begin != address) {\n       // We found a free region [free_begin..address-1].\n       uptr gap_start = RoundUpTo((uptr)free_begin + left_padding, alignment);\n-      uptr gap_end = RoundDownTo((uptr)address, alignment);\n+      uptr gap_end = RoundDownTo((uptr)Min(address, max_vm_address), alignment);\n       uptr gap_size = gap_end > gap_start ? gap_end - gap_start : 0;\n       if (size < gap_size) {\n         return gap_start;"}, {"sha": "f0a97d098eea0e544deb96a50f2e69635e7a665d", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -14,26 +14,6 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_platform.h\"\n-\n-/* TARGET_OS_OSX is not present in SDKs before Darwin16 (macOS 10.12) use\n-   TARGET_OS_MAC (we have no support for iOS in any form for these versions,\n-   so there's no ambiguity).  */\n-#if !defined(TARGET_OS_OSX) && TARGET_OS_MAC\n-# define TARGET_OS_OSX 1\n-#endif\n-\n-/* Other TARGET_OS_xxx are not present on earlier versions, define them to\n-   0 (we have no support for them; they are not valid targets anyway).  */\n-#ifndef TARGET_OS_IOS\n-#define TARGET_OS_IOS 0\n-#endif\n-#ifndef TARGET_OS_TV\n-#define TARGET_OS_TV 0\n-#endif\n-#ifndef TARGET_OS_WATCH\n-#define TARGET_OS_WATCH 0\n-#endif\n-\n #if SANITIZER_APPLE\n #include \"sanitizer_posix.h\"\n "}, {"sha": "7ecc465bea97a5a20935a74cec0330874ac96125", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -286,8 +286,8 @@\n #ifndef SANITIZER_CAN_USE_ALLOCATOR64\n #  if (SANITIZER_ANDROID && defined(__aarch64__)) || SANITIZER_FUCHSIA\n #    define SANITIZER_CAN_USE_ALLOCATOR64 1\n-#  elif defined(__mips64) || defined(__aarch64__) || defined(__i386__) || \\\n-      defined(__arm__) || SANITIZER_RISCV64 || defined(__hexagon__)\n+#  elif defined(__mips64) || defined(__arm__) || defined(__i386__) || \\\n+      SANITIZER_RISCV64 || defined(__hexagon__)\n #    define SANITIZER_CAN_USE_ALLOCATOR64 0\n #  else\n #    define SANITIZER_CAN_USE_ALLOCATOR64 (SANITIZER_WORDSIZE == 64)"}, {"sha": "bf0f355847cb13332fac82fb756fe2afa068991a", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -26,10 +26,7 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n #  if defined(__x86_64__) || defined(__mips__) || defined(__hexagon__)\n #    include <sys/stat.h>"}, {"sha": "44dd3d9e22d1c6e748b1af4c6aaac865e8d45ed9", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -101,7 +101,7 @@ const unsigned struct_kernel_stat64_sz = 104;\n const unsigned struct_kernel_stat_sz =\n     SANITIZER_ANDROID\n         ? FIRST_32_SECOND_64(104, 128)\n-        : FIRST_32_SECOND_64((_MIPS_SIM == _ABIN32) ? 160 : 144, 216);\n+        : FIRST_32_SECOND_64((_MIPS_SIM == _ABIN32) ? 176 : 160, 216);\n const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n const unsigned struct_kernel_stat_sz = 64;"}, {"sha": "4b0e678197614583b66de6755a63785bd8392f85", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cpp", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -146,13 +146,8 @@ static bool IsDyldHdr(const mach_header *hdr) {\n // until we hit a Mach header matching dyld instead. These recurse\n // calls are expensive, but the first memory map generation occurs\n // early in the process, when dyld is one of the only images loaded,\n-// so it will be hit after only a few iterations.  These assumptions don't\n-// hold on macOS 13+ anymore (dyld itself has moved into the shared cache).\n-\n-// FIXME: Unfortunately, the upstream revised version to deal with macOS 13+\n-// is incompatible with GCC and also uses APIs not available on earlier\n-// systems which we support; backed out for now.\n-\n+// so it will be hit after only a few iterations.  These assumptions don't hold\n+// on macOS 13+ anymore (dyld itself has moved into the shared cache).\n static mach_header *GetDyldImageHeaderViaVMRegion() {\n   vm_address_t address = 0;\n \n@@ -176,17 +171,64 @@ static mach_header *GetDyldImageHeaderViaVMRegion() {\n   }\n }\n \n+extern \"C\" {\n+struct dyld_shared_cache_dylib_text_info {\n+  uint64_t version;  // current version 2\n+  // following fields all exist in version 1\n+  uint64_t loadAddressUnslid;\n+  uint64_t textSegmentSize;\n+  uuid_t dylibUuid;\n+  const char *path;  // pointer invalid at end of iterations\n+  // following fields all exist in version 2\n+  uint64_t textSegmentOffset;  // offset from start of cache\n+};\n+typedef struct dyld_shared_cache_dylib_text_info\n+    dyld_shared_cache_dylib_text_info;\n+\n+extern bool _dyld_get_shared_cache_uuid(uuid_t uuid);\n+extern const void *_dyld_get_shared_cache_range(size_t *length);\n+extern int dyld_shared_cache_iterate_text(\n+    const uuid_t cacheUuid,\n+    void (^callback)(const dyld_shared_cache_dylib_text_info *info));\n+}  // extern \"C\"\n+\n+static mach_header *GetDyldImageHeaderViaSharedCache() {\n+  uuid_t uuid;\n+  bool hasCache = _dyld_get_shared_cache_uuid(uuid);\n+  if (!hasCache)\n+    return nullptr;\n+\n+  size_t cacheLength;\n+  __block uptr cacheStart = (uptr)_dyld_get_shared_cache_range(&cacheLength);\n+  CHECK(cacheStart && cacheLength);\n+\n+  __block mach_header *dyldHdr = nullptr;\n+  int res = dyld_shared_cache_iterate_text(\n+      uuid, ^(const dyld_shared_cache_dylib_text_info *info) {\n+        CHECK_GE(info->version, 2);\n+        mach_header *hdr =\n+            (mach_header *)(cacheStart + info->textSegmentOffset);\n+        if (IsDyldHdr(hdr))\n+          dyldHdr = hdr;\n+      });\n+  CHECK_EQ(res, 0);\n+\n+  return dyldHdr;\n+}\n+\n const mach_header *get_dyld_hdr() {\n   if (!dyld_hdr) {\n     // On macOS 13+, dyld itself has moved into the shared cache.  Looking it up\n     // via vm_region_recurse_64() causes spins/hangs/crashes.\n-    // FIXME: find a way to do this compatible with GCC.\n     if (GetMacosAlignedVersion() >= MacosVersion(13, 0)) {\n+      dyld_hdr = GetDyldImageHeaderViaSharedCache();\n+      if (!dyld_hdr) {\n         VReport(1,\n-                \"looking up the dyld image header in the shared cache on \"\n-                \"macOS 13+ is not yet supported.  Falling back to \"\n+                \"Failed to lookup the dyld image header in the shared cache on \"\n+                \"macOS 13+ (or no shared cache in use).  Falling back to \"\n                 \"lookup via vm_region_recurse_64().\\n\");\n         dyld_hdr = GetDyldImageHeaderViaVMRegion();\n+      }\n     } else {\n       dyld_hdr = GetDyldImageHeaderViaVMRegion();\n     }"}, {"sha": "d24fae98213aa4daa15868afe06d432dcda91417", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -87,8 +87,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -111,21 +111,14 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n #elif defined(__loongarch__) || defined(__riscv)"}, {"sha": "3ebeac52280a3d55458ae830d04b85eb27be78ee", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_mac.cpp", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -87,11 +87,13 @@ void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n \n #if defined(__x86_64__)\n typedef x86_thread_state64_t regs_struct;\n+#define regs_flavor x86_THREAD_STATE64\n \n #define SP_REG __rsp\n \n #elif defined(__aarch64__)\n typedef arm_thread_state64_t regs_struct;\n+#define regs_flavor ARM_THREAD_STATE64\n \n # if __DARWIN_UNIX03\n #  define SP_REG __sp\n@@ -101,6 +103,7 @@ typedef arm_thread_state64_t regs_struct;\n \n #elif defined(__i386)\n typedef x86_thread_state32_t regs_struct;\n+#define regs_flavor x86_THREAD_STATE32\n \n #define SP_REG __esp\n \n@@ -146,8 +149,8 @@ PtraceRegistersStatus SuspendedThreadsListMac::GetRegistersAndSP(\n   thread_t thread = GetThread(index);\n   regs_struct regs;\n   int err;\n-  mach_msg_type_number_t reg_count = MACHINE_THREAD_STATE_COUNT;\n-  err = thread_get_state(thread, MACHINE_THREAD_STATE, (thread_state_t)&regs,\n+  mach_msg_type_number_t reg_count = sizeof(regs) / sizeof(natural_t);\n+  err = thread_get_state(thread, regs_flavor, (thread_state_t)&regs,\n                          &reg_count);\n   if (err != KERN_SUCCESS) {\n     VReport(1, \"Error - unable to get registers for a thread\\n\");"}, {"sha": "a6f82ced20367310fc13d8fecb3e1c1e70efe62b", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -256,6 +256,8 @@ class LLVMSymbolizerProcess final : public SymbolizerProcess {\n     const char* const kSymbolizerArch = \"--default-arch=x86_64\";\n #elif defined(__i386__)\n     const char* const kSymbolizerArch = \"--default-arch=i386\";\n+#elif SANITIZER_LOONGARCH64\n+    const char *const kSymbolizerArch = \"--default-arch=loongarch64\";\n #elif SANITIZER_RISCV64\n     const char *const kSymbolizerArch = \"--default-arch=riscv64\";\n #elif defined(__aarch64__)"}, {"sha": "80f5e6be8ad1459a7e6708dc2a02f1b585cfe0c4", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_loongarch64.inc", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_loongarch64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_loongarch64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_loongarch64.inc?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -14,18 +14,22 @@\n // About local register variables:\n // https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html#Local-Register-Variables\n //\n-// Kernel ABI...\n-//  syscall number is passed in a7\n-//  (http://man7.org/linux/man-pages/man2/syscall.2.html) results are return in\n-//  a0 and a1 (http://man7.org/linux/man-pages/man2/syscall.2.html) arguments\n-//  are passed in: a0-a7 (confirmed by inspecting glibc sources).\n+// Kernel ABI:\n+// https://lore.kernel.org/loongarch/1f353678-3398-e30b-1c87-6edb278f74db@xen0n.name/T/#m1613bc86c2d7bf5f6da92bd62984302bfd699a2f\n+//  syscall number is placed in a7\n+//  parameters, if present, are placed in a0-a6\n+//  upon return:\n+//    the return value is placed in a0\n+//    t0-t8 should be considered clobbered\n+//    all other registers are preserved\n #define SYSCALL(name) __NR_##name\n \n-#define INTERNAL_SYSCALL_CLOBBERS \"memory\"\n+#define INTERNAL_SYSCALL_CLOBBERS \\\n+  \"memory\", \"$t0\", \"$t1\", \"$t2\", \"$t3\", \"$t4\", \"$t5\", \"$t6\", \"$t7\", \"$t8\"\n \n static uptr __internal_syscall(u64 nr) {\n-  register u64 a7 asm(\"a7\") = nr;\n-  register u64 a0 asm(\"a0\");\n+  register u64 a7 asm(\"$a7\") = nr;\n+  register u64 a0 asm(\"$a0\");\n   __asm__ volatile(\"syscall 0\\n\\t\"\n                    : \"=r\"(a0)\n                    : \"r\"(a7)\n@@ -35,8 +39,8 @@ static uptr __internal_syscall(u64 nr) {\n #define __internal_syscall0(n) (__internal_syscall)(n)\n \n static uptr __internal_syscall(u64 nr, u64 arg1) {\n-  register u64 a7 asm(\"a7\") = nr;\n-  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a7 asm(\"$a7\") = nr;\n+  register u64 a0 asm(\"$a0\") = arg1;\n   __asm__ volatile(\"syscall 0\\n\\t\"\n                    : \"+r\"(a0)\n                    : \"r\"(a7)\n@@ -46,9 +50,9 @@ static uptr __internal_syscall(u64 nr, u64 arg1) {\n #define __internal_syscall1(n, a1) (__internal_syscall)(n, (u64)(a1))\n \n static uptr __internal_syscall(u64 nr, u64 arg1, long arg2) {\n-  register u64 a7 asm(\"a7\") = nr;\n-  register u64 a0 asm(\"a0\") = arg1;\n-  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a7 asm(\"$a7\") = nr;\n+  register u64 a0 asm(\"$a0\") = arg1;\n+  register u64 a1 asm(\"$a1\") = arg2;\n   __asm__ volatile(\"syscall 0\\n\\t\"\n                    : \"+r\"(a0)\n                    : \"r\"(a7), \"r\"(a1)\n@@ -59,10 +63,10 @@ static uptr __internal_syscall(u64 nr, u64 arg1, long arg2) {\n   (__internal_syscall)(n, (u64)(a1), (long)(a2))\n \n static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3) {\n-  register u64 a7 asm(\"a7\") = nr;\n-  register u64 a0 asm(\"a0\") = arg1;\n-  register u64 a1 asm(\"a1\") = arg2;\n-  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a7 asm(\"$a7\") = nr;\n+  register u64 a0 asm(\"$a0\") = arg1;\n+  register u64 a1 asm(\"$a1\") = arg2;\n+  register u64 a2 asm(\"$a2\") = arg3;\n   __asm__ volatile(\"syscall 0\\n\\t\"\n                    : \"+r\"(a0)\n                    : \"r\"(a7), \"r\"(a1), \"r\"(a2)\n@@ -74,11 +78,11 @@ static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3) {\n \n static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3,\n                                u64 arg4) {\n-  register u64 a7 asm(\"a7\") = nr;\n-  register u64 a0 asm(\"a0\") = arg1;\n-  register u64 a1 asm(\"a1\") = arg2;\n-  register u64 a2 asm(\"a2\") = arg3;\n-  register u64 a3 asm(\"a3\") = arg4;\n+  register u64 a7 asm(\"$a7\") = nr;\n+  register u64 a0 asm(\"$a0\") = arg1;\n+  register u64 a1 asm(\"$a1\") = arg2;\n+  register u64 a2 asm(\"$a2\") = arg3;\n+  register u64 a3 asm(\"$a3\") = arg4;\n   __asm__ volatile(\"syscall 0\\n\\t\"\n                    : \"+r\"(a0)\n                    : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3)\n@@ -90,12 +94,12 @@ static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3,\n \n static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n                                long arg5) {\n-  register u64 a7 asm(\"a7\") = nr;\n-  register u64 a0 asm(\"a0\") = arg1;\n-  register u64 a1 asm(\"a1\") = arg2;\n-  register u64 a2 asm(\"a2\") = arg3;\n-  register u64 a3 asm(\"a3\") = arg4;\n-  register u64 a4 asm(\"a4\") = arg5;\n+  register u64 a7 asm(\"$a7\") = nr;\n+  register u64 a0 asm(\"$a0\") = arg1;\n+  register u64 a1 asm(\"$a1\") = arg2;\n+  register u64 a2 asm(\"$a2\") = arg3;\n+  register u64 a3 asm(\"$a3\") = arg4;\n+  register u64 a4 asm(\"$a4\") = arg5;\n   __asm__ volatile(\"syscall 0\\n\\t\"\n                    : \"+r\"(a0)\n                    : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4)\n@@ -108,13 +112,13 @@ static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n \n static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n                                long arg5, long arg6) {\n-  register u64 a7 asm(\"a7\") = nr;\n-  register u64 a0 asm(\"a0\") = arg1;\n-  register u64 a1 asm(\"a1\") = arg2;\n-  register u64 a2 asm(\"a2\") = arg3;\n-  register u64 a3 asm(\"a3\") = arg4;\n-  register u64 a4 asm(\"a4\") = arg5;\n-  register u64 a5 asm(\"a5\") = arg6;\n+  register u64 a7 asm(\"$a7\") = nr;\n+  register u64 a0 asm(\"$a0\") = arg1;\n+  register u64 a1 asm(\"$a1\") = arg2;\n+  register u64 a2 asm(\"$a2\") = arg3;\n+  register u64 a3 asm(\"$a3\") = arg4;\n+  register u64 a4 asm(\"$a4\") = arg5;\n+  register u64 a5 asm(\"$a5\") = arg6;\n   __asm__ volatile(\"syscall 0\\n\\t\"\n                    : \"+r\"(a0)\n                    : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4), \"r\"(a5)\n@@ -127,14 +131,14 @@ static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n \n static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n                                long arg5, long arg6, long arg7) {\n-  register u64 a7 asm(\"a7\") = nr;\n-  register u64 a0 asm(\"a0\") = arg1;\n-  register u64 a1 asm(\"a1\") = arg2;\n-  register u64 a2 asm(\"a2\") = arg3;\n-  register u64 a3 asm(\"a3\") = arg4;\n-  register u64 a4 asm(\"a4\") = arg5;\n-  register u64 a5 asm(\"a5\") = arg6;\n-  register u64 a6 asm(\"a6\") = arg7;\n+  register u64 a7 asm(\"$a7\") = nr;\n+  register u64 a0 asm(\"$a0\") = arg1;\n+  register u64 a1 asm(\"$a1\") = arg2;\n+  register u64 a2 asm(\"$a2\") = arg3;\n+  register u64 a3 asm(\"$a3\") = arg4;\n+  register u64 a4 asm(\"$a4\") = arg5;\n+  register u64 a5 asm(\"$a5\") = arg6;\n+  register u64 a6 asm(\"$a6\") = arg7;\n   __asm__ volatile(\"syscall 0\\n\\t\"\n                    : \"+r\"(a0)\n                    : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4), \"r\"(a5),"}, {"sha": "60fbc58f988a2f68f4a165e4682328093f510a71", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -21,8 +21,9 @@ class ScopedInterceptor {\n \n  private:\n   ThreadState *const thr_;\n-  bool in_ignored_lib_;\n-  bool ignoring_;\n+  bool in_ignored_lib_ = false;\n+  bool in_blocking_func_ = false;\n+  bool ignoring_ = false;\n \n   void DisableIgnoresImpl();\n   void EnableIgnoresImpl();"}, {"sha": "c557d5ddc6abcce93b4494dbfad9515bdedd99d9", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "modified", "additions": 64, "deletions": 29, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -165,13 +165,26 @@ struct SignalDesc {\n \n struct ThreadSignalContext {\n   int int_signal_send;\n-  atomic_uintptr_t in_blocking_func;\n   SignalDesc pending_signals[kSigCount];\n   // emptyset and oldset are too big for stack.\n   __sanitizer_sigset_t emptyset;\n   __sanitizer_sigset_t oldset;\n };\n \n+void EnterBlockingFunc(ThreadState *thr) {\n+  for (;;) {\n+    // The order is important to not delay a signal infinitely if it's\n+    // delivered right before we set in_blocking_func. Note: we can't call\n+    // ProcessPendingSignals when in_blocking_func is set, or we can handle\n+    // a signal synchronously when we are already handling a signal.\n+    atomic_store(&thr->in_blocking_func, 1, memory_order_relaxed);\n+    if (atomic_load(&thr->pending_signals, memory_order_relaxed) == 0)\n+      break;\n+    atomic_store(&thr->in_blocking_func, 0, memory_order_relaxed);\n+    ProcessPendingSignals(thr);\n+  }\n+}\n+\n // The sole reason tsan wraps atexit callbacks is to establish synchronization\n // between callback setup and callback execution.\n struct AtExitCtx {\n@@ -245,8 +258,18 @@ static ThreadSignalContext *SigCtx(ThreadState *thr) {\n \n ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n                                      uptr pc)\n-    : thr_(thr), in_ignored_lib_(false), ignoring_(false) {\n+    : thr_(thr) {\n   LazyInitialize(thr);\n+  if (UNLIKELY(atomic_load(&thr->in_blocking_func, memory_order_relaxed))) {\n+    // pthread_join is marked as blocking, but it's also known to call other\n+    // intercepted functions (mmap, free). If we don't reset in_blocking_func\n+    // we can get deadlocks and memory corruptions if we deliver a synchronous\n+    // signal inside of an mmap/free interceptor.\n+    // So reset it and restore it back in the destructor.\n+    // See https://github.com/google/sanitizers/issues/1540\n+    atomic_store(&thr->in_blocking_func, 0, memory_order_relaxed);\n+    in_blocking_func_ = true;\n+  }\n   if (!thr_->is_inited) return;\n   if (!thr_->ignore_interceptors) FuncEntry(thr, pc);\n   DPrintf(\"#%d: intercept %s()\\n\", thr_->tid, fname);\n@@ -259,6 +282,8 @@ ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n ScopedInterceptor::~ScopedInterceptor() {\n   if (!thr_->is_inited) return;\n   DisableIgnores();\n+  if (UNLIKELY(in_blocking_func_))\n+    EnterBlockingFunc(thr_);\n   if (!thr_->ignore_interceptors) {\n     ProcessPendingSignals(thr_);\n     FuncExit(thr_);\n@@ -321,15 +346,8 @@ void ScopedInterceptor::DisableIgnoresImpl() {\n \n struct BlockingCall {\n   explicit BlockingCall(ThreadState *thr)\n-      : thr(thr)\n-      , ctx(SigCtx(thr)) {\n-    for (;;) {\n-      atomic_store(&ctx->in_blocking_func, 1, memory_order_relaxed);\n-      if (atomic_load(&thr->pending_signals, memory_order_relaxed) == 0)\n-        break;\n-      atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n-      ProcessPendingSignals(thr);\n-    }\n+      : thr(thr) {\n+    EnterBlockingFunc(thr);\n     // When we are in a \"blocking call\", we process signals asynchronously\n     // (right when they arrive). In this context we do not expect to be\n     // executing any user/runtime code. The known interceptor sequence when\n@@ -340,11 +358,10 @@ struct BlockingCall {\n \n   ~BlockingCall() {\n     thr->ignore_interceptors--;\n-    atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n+    atomic_store(&thr->in_blocking_func, 0, memory_order_relaxed);\n   }\n \n   ThreadState *thr;\n-  ThreadSignalContext *ctx;\n };\n \n TSAN_INTERCEPTOR(unsigned, sleep, unsigned sec) {\n@@ -517,9 +534,7 @@ static void SetJmp(ThreadState *thr, uptr sp) {\n   buf->shadow_stack_pos = thr->shadow_stack_pos;\n   ThreadSignalContext *sctx = SigCtx(thr);\n   buf->int_signal_send = sctx ? sctx->int_signal_send : 0;\n-  buf->in_blocking_func = sctx ?\n-      atomic_load(&sctx->in_blocking_func, memory_order_relaxed) :\n-      false;\n+  buf->in_blocking_func = atomic_load(&thr->in_blocking_func, memory_order_relaxed);\n   buf->in_signal_handler = atomic_load(&thr->in_signal_handler,\n       memory_order_relaxed);\n }\n@@ -535,11 +550,10 @@ static void LongJmp(ThreadState *thr, uptr *env) {\n       while (thr->shadow_stack_pos > buf->shadow_stack_pos)\n         FuncExit(thr);\n       ThreadSignalContext *sctx = SigCtx(thr);\n-      if (sctx) {\n+      if (sctx)\n         sctx->int_signal_send = buf->int_signal_send;\n-        atomic_store(&sctx->in_blocking_func, buf->in_blocking_func,\n-            memory_order_relaxed);\n-      }\n+      atomic_store(&thr->in_blocking_func, buf->in_blocking_func,\n+          memory_order_relaxed);\n       atomic_store(&thr->in_signal_handler, buf->in_signal_handler,\n           memory_order_relaxed);\n       JmpBufGarbageCollect(thr, buf->sp - 1);  // do not collect buf->sp\n@@ -1198,9 +1212,8 @@ void CondMutexUnlockCtx<Fn>::Unlock() const {\n   // tsan code. Also ScopedInterceptor and BlockingCall destructors won't run\n   // since the thread is cancelled, so we have to manually execute them\n   // (the thread still can run some user code due to pthread_cleanup_push).\n-  ThreadSignalContext *ctx = SigCtx(thr);\n-  CHECK_EQ(atomic_load(&ctx->in_blocking_func, memory_order_relaxed), 1);\n-  atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n+  CHECK_EQ(atomic_load(&thr->in_blocking_func, memory_order_relaxed), 1);\n+  atomic_store(&thr->in_blocking_func, 0, memory_order_relaxed);\n   MutexPostLock(thr, pc, (uptr)m, MutexFlagDoPreLockOnPostLock);\n   // Undo BlockingCall ctor effects.\n   thr->ignore_interceptors--;\n@@ -2089,12 +2102,12 @@ void sighandler(int sig, __sanitizer_siginfo *info, void *ctx) {\n       // If we are in blocking function, we can safely process it now\n       // (but check if we are in a recursive interceptor,\n       // i.e. pthread_join()->munmap()).\n-      (sctx && atomic_load(&sctx->in_blocking_func, memory_order_relaxed))) {\n+      atomic_load(&thr->in_blocking_func, memory_order_relaxed)) {\n     atomic_fetch_add(&thr->in_signal_handler, 1, memory_order_relaxed);\n-    if (sctx && atomic_load(&sctx->in_blocking_func, memory_order_relaxed)) {\n-      atomic_store(&sctx->in_blocking_func, 0, memory_order_relaxed);\n+    if (atomic_load(&thr->in_blocking_func, memory_order_relaxed)) {\n+      atomic_store(&thr->in_blocking_func, 0, memory_order_relaxed);\n       CallUserSignalHandler(thr, sync, true, sig, info, ctx);\n-      atomic_store(&sctx->in_blocking_func, 1, memory_order_relaxed);\n+      atomic_store(&thr->in_blocking_func, 1, memory_order_relaxed);\n     } else {\n       // Be very conservative with when we do acquire in this case.\n       // It's unsafe to do acquire in async handlers, because ThreadState\n@@ -3029,7 +3042,9 @@ void InitializeInterceptors() {\n constexpr u32 kBarrierThreadBits = 10;\n constexpr u32 kBarrierThreads = 1 << kBarrierThreadBits;\n \n-extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE void __tsan_testonly_barrier_init(\n+extern \"C\" {\n+\n+SANITIZER_INTERFACE_ATTRIBUTE void __tsan_testonly_barrier_init(\n     atomic_uint32_t *barrier, u32 num_threads) {\n   if (num_threads >= kBarrierThreads) {\n     Printf(\"barrier_init: count is too large (%d)\\n\", num_threads);\n@@ -3044,7 +3059,7 @@ static u32 barrier_epoch(u32 value) {\n   return (value >> kBarrierThreadBits) / (value & (kBarrierThreads - 1));\n }\n \n-extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE void __tsan_testonly_barrier_wait(\n+SANITIZER_INTERFACE_ATTRIBUTE void __tsan_testonly_barrier_wait(\n     atomic_uint32_t *barrier) {\n   u32 old = atomic_fetch_add(barrier, kBarrierThreads, memory_order_relaxed);\n   u32 old_epoch = barrier_epoch(old);\n@@ -3059,3 +3074,23 @@ extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE void __tsan_testonly_barrier_wait(\n     FutexWait(barrier, cur);\n   }\n }\n+\n+void *__tsan_memcpy(void *dst, const void *src, uptr size) {\n+  void *ctx;\n+#if PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE\n+  COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, dst, src, size);\n+#else\n+  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size);\n+#endif\n+}\n+\n+void *__tsan_memset(void *dst, int c, uptr size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, dst, c, size);\n+}\n+\n+void *__tsan_memmove(void *dst, const void *src, uptr size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size);\n+}\n+}"}, {"sha": "5b9d664e503fc4ee4321ab14f54bb0ae046322ce", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -72,6 +72,13 @@ SANITIZER_INTERFACE_ATTRIBUTE void __tsan_vptr_read(void **vptr_p);\n SANITIZER_INTERFACE_ATTRIBUTE\n void __tsan_vptr_update(void **vptr_p, void *new_val);\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__tsan_memcpy(void *dest, const void *src, uptr count);\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__tsan_memset(void *dest, int ch, uptr count);\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__tsan_memmove(void *dest, const void *src, uptr count);\n+\n SANITIZER_INTERFACE_ATTRIBUTE void __tsan_func_entry(void *call_pc);\n SANITIZER_INTERFACE_ATTRIBUTE void __tsan_func_exit();\n "}, {"sha": "f0918d86d4ec308a812d49e4b11cddac7f32766e", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -191,6 +191,7 @@ struct ThreadState {\n #if !SANITIZER_GO\n   Vector<JmpBuf> jmp_bufs;\n   int in_symbolizer;\n+  atomic_uintptr_t in_blocking_func;\n   bool in_ignored_lib;\n   bool is_inited;\n #endif\n@@ -627,6 +628,13 @@ class SlotLocker {\n   ALWAYS_INLINE\n   SlotLocker(ThreadState *thr, bool recursive = false)\n       : thr_(thr), locked_(recursive ? thr->slot_locked : false) {\n+#if !SANITIZER_GO\n+    // We are in trouble if we are here with in_blocking_func set.\n+    // If in_blocking_func is set, all signals will be delivered synchronously,\n+    // which means we can't lock slots since the signal handler will try\n+    // to lock it recursively and deadlock.\n+    DCHECK(!atomic_load(&thr->in_blocking_func, memory_order_relaxed));\n+#endif\n     if (!locked_)\n       SlotLock(thr_);\n   }\n@@ -670,8 +678,8 @@ ALWAYS_INLINE\n void LazyInitialize(ThreadState *thr) {\n   // If we can use .preinit_array, assume that __tsan_init\n   // called from .preinit_array initializes runtime before\n-  // any instrumented code.\n-#if !SANITIZER_CAN_USE_PREINIT_ARRAY\n+  // any instrumented code except ANDROID.\n+#if (!SANITIZER_CAN_USE_PREINIT_ARRAY || defined(__ANDROID__))\n   if (UNLIKELY(!is_initialized))\n     Initialize(thr);\n #endif"}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "25cefd46ce27ced7fb6092d8d04b5074c56ebe95", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -50,7 +50,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }"}, {"sha": "410292a0d53878d94f6592676168d5944382f12c", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -894,21 +894,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "219fb15de55fe02a4544422095baa0d8532baaa0", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -215,20 +215,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "d2cc2e10bd2f023b8d9aa1685a79a192a6d1e1e8", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3fa2655cb256d336e90e74e42a2452d0fbf0e8/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=5f3fa2655cb256d336e90e74e42a2452d0fbf0e8", "patch": "@@ -12,7 +12,6 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n     defined(__NetBSD__) || defined(__DragonFly__) ||                           \\\n@@ -22,6 +21,5 @@\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}]}