{"sha": "52ea1caf28cdcdff8c9b2be844e3f1be6c369f16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJlYTFjYWYyOGNkY2RmZjhjOWIyYmU4NDRlM2YxYmU2YzM2OWYxNg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-05-22T20:29:39Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-05-22T20:29:39Z"}, "message": "PR libstdc++/77691 fix resource_adaptor failures due to max_align_t bugs\n\nRemove the hardcoded whitelist of allocators expected to return memory\naligned to alignof(max_align_t), because that doesn't work when the\nplatform's malloc() and GCC's max_align_t do not agree what the largest\nfundamental alignment is. It's also sub-optimal for user-defined\nallocators that return memory suitable for any fundamental alignment.\n\nInstead use a hardcoded list of alignments that are definitely supported\nby the platform malloc, and use a copy of the allocator rebound to a POD\ntype with the requested alignment. Only allocate an oversized\nbuffer to use with std::align for alignments larger than any of the\nhardcoded values.\n\nFor 32-bit Solaris x86 do not include alignof(max_align_t) in the\nhardcoded values.\n\n\tPR libstdc++/77691\n\t* include/experimental/memory_resource: Add system header pragma.\n\t(__resource_adaptor_common::__guaranteed_alignment): Remove.\n\t(__resource_adaptor_common::_Types)\n\t(__resource_adaptor_common::__new_list)\n\t(__resource_adaptor_common::_New_list)\n\t(__resource_adaptor_common::_Alignments)\n\t(__resource_adaptor_common::_Fund_align_types): New utilities for\n\tcreating a list of types with fundamental alignments.\n\t(__resource_adaptor_imp::do_allocate): Call new _M_allocate function.\n\t(__resource_adaptor_imp::do_deallocate): Call new _M_deallocate\n\tfunction.\n\t(__resource_adaptor_imp::_M_allocate): New function that first tries\n\tto use an allocator rebound to a type with a fundamental alignment.\n\t(__resource_adaptor_imp::_M_deallocate): Likewise for deallocation.\n\t* testsuite/experimental/memory_resource/new_delete_resource.cc:\n\tAdjust expected allocation sizes.\n\t* testsuite/experimental/memory_resource/resource_adaptor.cc: Remove\n\txfail.\n\nFrom-SVN: r271522", "tree": {"sha": "63547ce3ad83431014ab3c999d5b8385aee6ee2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63547ce3ad83431014ab3c999d5b8385aee6ee2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d277e1796e2a54dd3bb0aea1793a2e0e5b45962", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d277e1796e2a54dd3bb0aea1793a2e0e5b45962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d277e1796e2a54dd3bb0aea1793a2e0e5b45962"}], "stats": {"total": 137, "additions": 94, "deletions": 43}, "files": [{"sha": "cf9d86a809c7e236a6240390cabefad0e06a722c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=52ea1caf28cdcdff8c9b2be844e3f1be6c369f16", "patch": "@@ -1,3 +1,21 @@\n+2019-05-22  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/77691\n+\t* include/experimental/memory_resource: Add system header pragma and\n+\tdo not define anything unless compiled as C++14 or later.\n+\t(__resource_adaptor_common::__guaranteed_alignment): Remove.\n+\t(__resource_adaptor_imp::do_allocate): If the requested alignment\n+\tis a fundamental alignment then either allocate directly from _M_alloc\n+\tor call the new _M_allocate function.\n+\t(__resource_adaptor_imp::do_deallocate): Likewise for deallocation.\n+\t(__resource_adaptor_imp::_M_allocate): New function that uses a copy\n+\tof the allocator rebound to a POD type with the specified alignment.\n+\t(__resource_adaptor_imp::_M_deallocate): Likewise for deallocation.\n+\t* testsuite/experimental/memory_resource/new_delete_resource.cc:\n+\tAdjust expected allocation sizes.\n+\t* testsuite/experimental/memory_resource/resource_adaptor.cc: Remove\n+\txfail for Solaris x86.\n+\n 2019-05-21  Thomas Rodgers  <trodgers@redhat.com>\n \n \tLWG 3062 - Unnecessary decay_t in is_execution_policy_v"}, {"sha": "dde3753fab7af2822a9e67f44afe359049025bbc", "filename": "libstdc++-v3/include/experimental/memory_resource", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource?ref=52ea1caf28cdcdff8c9b2be844e3f1be6c369f16", "patch": "@@ -30,6 +30,10 @@\n #ifndef _GLIBCXX_EXPERIMENTAL_MEMORY_RESOURCE\n #define _GLIBCXX_EXPERIMENTAL_MEMORY_RESOURCE 1\n \n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n #include <memory>\t\t\t// align, uses_allocator, __uses_alloc\n #include <experimental/utility>\t\t// pair, experimental::erased_type\n #include <atomic>\t\t\t// atomic\n@@ -358,23 +362,6 @@ namespace pmr {\n \t  return __val;\n \t}\n     };\n-\n-    template<typename _Alloc>\n-      struct __guaranteed_alignment : std::integral_constant<size_t, 1> { };\n-\n-    template<typename _Tp>\n-      struct __guaranteed_alignment<__gnu_cxx::new_allocator<_Tp>>\n-      : std::alignment_of<std::max_align_t>::type { };\n-\n-    template<typename _Tp>\n-      struct __guaranteed_alignment<__gnu_cxx::malloc_allocator<_Tp>>\n-      : std::alignment_of<std::max_align_t>::type { };\n-\n-#if _GLIBCXX_USE_ALLOCATOR_NEW\n-    template<typename _Tp>\n-      struct __guaranteed_alignment<std::allocator<_Tp>>\n-      : std::alignment_of<std::max_align_t>::type { };\n-#endif\n   };\n   /// @endcond\n \n@@ -425,14 +412,22 @@ namespace pmr {\n       virtual void*\n       do_allocate(size_t __bytes, size_t __alignment) override\n       {\n-\tif (__alignment <= __guaranteed_alignment<_Alloc>::value)\n+\t// Cannot use max_align_t on 32-bit Solaris x86, see PR libstdc++/77691\n+#if ! (defined __sun__ && defined __i386__)\n+\tif (__alignment == alignof(max_align_t))\n+\t  return _M_allocate<alignof(max_align_t)>(__bytes);\n+#endif\n+\tswitch (__alignment)\n \t  {\n-\t    if (__bytes < __alignment)\n-\t      __bytes = __alignment;\n+\t  case 1:\n \t    return _M_alloc.allocate(__bytes);\n+\t  case 2:\n+\t    return _M_allocate<2>(__bytes);\n+\t  case 4:\n+\t    return _M_allocate<4>(__bytes);\n+\t  case 8:\n+\t    return _M_allocate<8>(__bytes);\n \t  }\n-\n-\n \tconst _AlignMgr __mgr(__bytes, __alignment);\n \t// Assume _M_alloc returns 1-byte aligned memory, so allocate enough\n \t// space to fit a block of the right size and alignment, plus some\n@@ -441,21 +436,28 @@ namespace pmr {\n       }\n \n       virtual void\n-      do_deallocate(void* __p, size_t __bytes, size_t __alignment) noexcept\n+      do_deallocate(void* __ptr, size_t __bytes, size_t __alignment) noexcept\n       override\n       {\n-\tauto __ptr = static_cast<char*>(__p);\n-\tif (__alignment <= __guaranteed_alignment<_Alloc>::value)\n+#if ! (defined __sun__ && defined __i386__)\n+\tif (__alignment == alignof(max_align_t))\n+\t  return (void) _M_deallocate<alignof(max_align_t)>(__ptr, __bytes);\n+#endif\n+\tswitch (__alignment)\n \t  {\n-\t    if (__bytes < __alignment)\n-\t      __bytes = __alignment;\n-\t    _M_alloc.deallocate(__ptr, __bytes);\n-\t    return;\n+\t  case 1:\n+\t    return (void) _M_alloc.deallocate((char*)__ptr, __bytes);\n+\t  case 2:\n+\t    return (void) _M_deallocate<2>(__ptr, __bytes);\n+\t  case 4:\n+\t    return (void) _M_deallocate<4>(__ptr, __bytes);\n+\t  case 8:\n+\t    return (void) _M_deallocate<8>(__ptr, __bytes);\n \t  }\n-\n \tconst _AlignMgr __mgr(__bytes, __alignment);\n-\t// Use the stored token to retrieve the original pointer to deallocate.\n-\t_M_alloc.deallocate(__mgr._M_unadjust(__ptr), __mgr._M_alloc_size());\n+\t// Use the stored token to retrieve the original pointer.\n+\t_M_alloc.deallocate(__mgr._M_unadjust((char*)__ptr),\n+\t    __mgr._M_alloc_size());\n       }\n \n       virtual bool\n@@ -467,6 +469,31 @@ namespace pmr {\n       }\n \n     private:\n+      template<size_t _Num>\n+\tstruct _Aligned_type { alignas(_Num) char __c[_Num]; };\n+\n+      // Rebind the allocator to the specified type and use it to allocate.\n+      template<size_t _Num, typename _Tp = _Aligned_type<_Num>>\n+\tvoid*\n+\t_M_allocate(size_t __bytes)\n+\t{\n+\t  typename allocator_traits<_Alloc>::template\n+\t    rebind_alloc<_Tp> __a2(_M_alloc);\n+\t  const size_t __n = (__bytes + _Num - 1) / _Num;\n+\t  return __a2.allocate(__n);\n+\t}\n+\n+      // Rebind the allocator to the specified type and use it to deallocate.\n+      template<size_t _Num, typename _Tp = _Aligned_type<_Num>>\n+\tvoid\n+\t_M_deallocate(void* __ptr, size_t __bytes) noexcept\n+\t{\n+\t  typename allocator_traits<_Alloc>::template\n+\t    rebind_alloc<_Tp> __a2(_M_alloc);\n+\t  const size_t __n = (__bytes + _Num - 1) / _Num;\n+\t  __a2.deallocate((_Tp*)__ptr, __n);\n+\t}\n+\n       _Alloc _M_alloc{};\n     };\n \n@@ -537,4 +564,5 @@ namespace pmr {\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n+#endif // C++14\n #endif // _GLIBCXX_EXPERIMENTAL_MEMORY_RESOURCE"}, {"sha": "7dcb408f3f7d427193df2b5bd0f95d4ec5181a5d", "filename": "libstdc++-v3/testsuite/experimental/memory_resource/new_delete_resource.cc", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fnew_delete_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fnew_delete_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fnew_delete_resource.cc?ref=52ea1caf28cdcdff8c9b2be844e3f1be6c369f16", "patch": "@@ -23,6 +23,11 @@\n #include <cstdlib>\n #include <testsuite_hooks.h>\n \n+#if defined __sun__ && defined __i386__\n+// See PR libstdc++/77691\n+# define BAD_MAX_ALIGN_T 1\n+#endif\n+\n bool new_called = false;\n bool delete_called = false;\n std::size_t bytes_allocated = 0;\n@@ -38,14 +43,14 @@ void* operator new(std::size_t n)\n   throw std::bad_alloc();\n }\n \n-void operator delete(void* p)\n+void operator delete(void* p) noexcept\n {\n   delete_called = true;\n   std::free(p);\n   bytes_allocated = 0; // assume everything getting deleted\n }\n \n-void operator delete(void* p, std::size_t n)\n+void operator delete(void* p, std::size_t n) noexcept\n {\n   delete_called = true;\n   std::free(p);\n@@ -55,9 +60,7 @@ void operator delete(void* p, std::size_t n)\n \n template<std::size_t A>\n   bool aligned(void* p)\n-  {\n-    return (reinterpret_cast<std::uintptr_t>(p) % A) == 0;\n-  }\n+  { return (reinterpret_cast<std::uintptr_t>(p) % A) == 0; }\n \n template<typename T>\n   bool aligned(void* p)\n@@ -108,13 +111,17 @@ test03()\n   using std::size_t;\n   void* p = nullptr;\n \n-  auto max = [](int n, int a) { return n > a ? n : a; };\n+  auto round = [](size_t n, size_t a) { return n % a ? n + a - (n % a) : n; };\n \n   bytes_allocated = 0;\n \n   memory_resource* r1 = new_delete_resource();\n   p = r1->allocate(1); // uses alignment = alignof(max_align_t)\n-  VERIFY( bytes_allocated <= alignof(max_align_t) );\n+#ifdef BAD_MAX_ALIGN_T\n+  VERIFY( bytes_allocated != 0 );\n+#else\n+  VERIFY( bytes_allocated == alignof(max_align_t) );\n+#endif\n   VERIFY( aligned<max_align_t>(p) );\n   r1->deallocate(p, 1);\n   VERIFY( bytes_allocated == 0 );\n@@ -123,17 +130,16 @@ test03()\n   VERIFY( bytes_allocated == 2 );\n   VERIFY( aligned<max_align_t>(p) );\n   r1->deallocate(p, 2, alignof(char));\n-  __builtin_printf(\"%d\\n\", (int)bytes_allocated);\n   VERIFY( bytes_allocated == 0 );\n \n   p = r1->allocate(3, alignof(short));\n-  VERIFY( bytes_allocated == max(3, alignof(short)) );\n+  VERIFY( bytes_allocated == round(3, alignof(short)) );\n   VERIFY( aligned<short>(p) );\n   r1->deallocate(p, 3, alignof(short));\n   VERIFY( bytes_allocated == 0 );\n \n   p = r1->allocate(4, alignof(long));\n-  VERIFY( bytes_allocated == max(4, alignof(long)) );\n+  VERIFY( bytes_allocated == round(4, alignof(long)) );\n   VERIFY( aligned<long>(p) );\n   r1->deallocate(p, 4, alignof(long));\n   VERIFY( bytes_allocated == 0 );"}, {"sha": "56c8ffa280391038893aa1d46b3f8201e9f3de5c", "filename": "libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fresource_adaptor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ea1caf28cdcdff8c9b2be844e3f1be6c369f16/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fresource_adaptor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fresource_adaptor.cc?ref=52ea1caf28cdcdff8c9b2be844e3f1be6c369f16", "patch": "@@ -1,6 +1,5 @@\n // { dg-do run { target c++14 } }\n // { dg-require-cstdint \"\" }\n-// { dg-xfail-run-if \"PR libstdc++/77691\" { { i?86-*-solaris2.* x86_64-*-solaris2.* } && ilp32 } }\n \n // Copyright (C) 2016-2019 Free Software Foundation, Inc.\n //"}]}