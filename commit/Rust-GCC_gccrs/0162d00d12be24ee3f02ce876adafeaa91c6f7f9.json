{"sha": "0162d00d12be24ee3f02ce876adafeaa91c6f7f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE2MmQwMGQxMmJlMjRlZTNmMDJjZTg3NmFkYWZlYWE5MWM2ZjdmOQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-10-28T20:41:15Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-10-29T02:02:45Z"}, "message": "Call infer_non_null() directly when checking for non-null.\n\nSimply call infer_non_null directly and avoid uneccessary checks of\nthe statement being modified.\n\n\tgcc/\n\tPR tree-optimization/97609\n\t* gimple-range-cache.cc (non_null_ref::process_name): Call\n\tinfer_nonnull_range directly instead of infer_value_range.\n\tgcc/testsuite/\n\t* g++.dg/pr97609.C: New.", "tree": {"sha": "6ba997f13de10d9e7e4e7ffc8189b5508ae94f89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ba997f13de10d9e7e4e7ffc8189b5508ae94f89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0162d00d12be24ee3f02ce876adafeaa91c6f7f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0162d00d12be24ee3f02ce876adafeaa91c6f7f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0162d00d12be24ee3f02ce876adafeaa91c6f7f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0162d00d12be24ee3f02ce876adafeaa91c6f7f9/comments", "author": null, "committer": null, "parents": [{"sha": "c6bfc4eb3c961181912647781d7dd38057db655b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bfc4eb3c961181912647781d7dd38057db655b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6bfc4eb3c961181912647781d7dd38057db655b"}], "stats": {"total": 58, "additions": 50, "deletions": 8}, "files": [{"sha": "bc9243c1279af95059e7e2ee6ea3a67cdcfe4bf9", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0162d00d12be24ee3f02ce876adafeaa91c6f7f9/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0162d00d12be24ee3f02ce876adafeaa91c6f7f9/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=0162d00d12be24ee3f02ce876adafeaa91c6f7f9", "patch": "@@ -91,19 +91,15 @@ non_null_ref::process_name (tree name)\n     {\n       gimple *s = USE_STMT (use_p);\n       unsigned index = gimple_bb (s)->index;\n-      tree value;\n-      enum tree_code comp_code;\n \n       // If bit is already set for this block, dont bother looking again.\n       if (bitmap_bit_p (b, index))\n \tcontinue;\n \n-      // If we can infer a != 0 range, then set the bit for this BB\n-      if (infer_value_range (s, name, &comp_code, &value))\n-\t{\n-\t  if (comp_code == NE_EXPR && integer_zerop (value))\n-\t    bitmap_set_bit (b, index);\n-\t}\n+      // If we can infer a nonnull range, then set the bit for this BB\n+      if (!SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name)\n+\t  && infer_nonnull_range (s, name))\n+\tbitmap_set_bit (b, index);\n     }\n \n   m_nn[v] = b;"}, {"sha": "8e582c9ad494d51be311a8fff5e95d4dfc215dbe", "filename": "gcc/testsuite/g++.dg/pr97609.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0162d00d12be24ee3f02ce876adafeaa91c6f7f9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr97609.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0162d00d12be24ee3f02ce876adafeaa91c6f7f9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr97609.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr97609.C?ref=0162d00d12be24ee3f02ce876adafeaa91c6f7f9", "patch": "@@ -0,0 +1,46 @@\n+// PR tree-optimization/97609\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -fno-tree-fre -fnon-call-exceptions\" }\n+\n+struct _Fwd_list_node_base {\n+  _Fwd_list_node_base *_M_next;\n+  void _M_transfer_after() { _Fwd_list_node_base *__keep = _M_next = __keep; }\n+};\n+struct _Fwd_list_const_iterator {\n+  _Fwd_list_const_iterator(_Fwd_list_node_base *__n) : _M_node(__n) {}\n+  _Fwd_list_const_iterator(int);\n+  _Fwd_list_node_base *_M_node;\n+};\n+template <typename, typename> struct forward_list {\n+  _Fwd_list_node_base _M_head;\n+  template <typename _InputIterator>\n+  forward_list(_InputIterator, _InputIterator);\n+  forward_list(int);\n+  _Fwd_list_const_iterator cbefore_begin() { return &_M_head; }\n+  void splice_after(_Fwd_list_const_iterator) noexcept;\n+  void splice_after(_Fwd_list_const_iterator __pos, forward_list &) {\n+    splice_after(__pos, 0);\n+  }\n+  using __remove_return_type = void;\n+  __remove_return_type unique() { unique(0); }\n+  template <typename _BinPred> __remove_return_type unique(_BinPred);\n+};\n+template <typename _Tp, typename _Alloc>\n+void forward_list<_Tp, _Alloc>::splice_after(_Fwd_list_const_iterator __pos)\n+  noexcept {\n+  __pos._M_node->_M_transfer_after();\n+}\n+template <typename _Tp, typename _Alloc>\n+template <typename _BinPred>\n+auto forward_list<_Tp, _Alloc>::unique(_BinPred) -> __remove_return_type {\n+  forward_list __to_destroy(0);\n+  splice_after(__to_destroy.cbefore_begin());\n+}\n+\n+void\n+foo ()\n+{\n+  forward_list<int, int> c1 (0, 0);\n+  c1.unique ();\n+}\n+"}]}