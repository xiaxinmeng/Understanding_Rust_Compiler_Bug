{"sha": "4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI5YzIzZWE0ZTk4NWU0NTE2Yzc1YTAyOTQ4YjZjNDBjOGY4YTJhNw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-08-24T23:36:04Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-08-24T23:36:04Z"}, "message": "Speed-up ifcvt_memrefs_wont_trap caching previous results.\n\nThis patch speeds up the ifcvt_memrefs_wont_trap computation by\ncaching the results of the computations in the data references ->aux\nfields.\n\n\t* tree-if-conv.c (struct ifc_dr): New.\n\t(IFC_DR): New.\n\t(DR_WRITTEN_AT_LEAST_ONCE): New.\n\t(DR_RW_UNCONDITIONALLY): New.\n\t(memref_read_or_written_unconditionally): Use the cached values\n\twhen possible.\n\t(write_memref_written_at_least_once): Same.\n\t(if_convertible_loop_p): Initialize and free DR->aux fields.\n\nFrom-SVN: r163532", "tree": {"sha": "81847459ed3a48b0e2fb27223e2a7c6cbd045dca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81847459ed3a48b0e2fb27223e2a7c6cbd045dca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1fd038a0c859f7f669370f06f0516e4bd5307b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1fd038a0c859f7f669370f06f0516e4bd5307b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1fd038a0c859f7f669370f06f0516e4bd5307b9"}], "stats": {"total": 81, "additions": 77, "deletions": 4}, "files": [{"sha": "d0d6bb932c84cca0f2b8cb10c3f5e40be9955a37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7", "patch": "@@ -1,3 +1,14 @@\n+2010-08-24  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-if-conv.c (struct ifc_dr): New.\n+\t(IFC_DR): New.\n+\t(DR_WRITTEN_AT_LEAST_ONCE): New.\n+\t(DR_RW_UNCONDITIONALLY): New.\n+\t(memref_read_or_written_unconditionally): Use the cached values\n+\twhen possible.\n+\t(write_memref_written_at_least_once): Same.\n+\t(if_convertible_loop_p): Initialize and free DR->aux fields.\n+\n 2010-08-24  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* gimple.c (gimple_could_trap_p_1): Not static anymore."}, {"sha": "86b8f2686e4819a048bc604d027e527331699a54", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=4b9c23ea4e985e4516c75a02948b6c40c8f8a2a7", "patch": "@@ -446,6 +446,21 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n   return true;\n }\n \n+/* Records the status of a data reference.  This struct is attached to\n+   each DR->aux field.  */\n+\n+struct ifc_dr {\n+  /* -1 when not initialized, 0 when false, 1 when true.  */\n+  int written_at_least_once;\n+\n+  /* -1 when not initialized, 0 when false, 1 when true.  */\n+  int rw_unconditionally;\n+};\n+\n+#define IFC_DR(DR) ((struct ifc_dr *) (DR)->aux)\n+#define DR_WRITTEN_AT_LEAST_ONCE(DR) (IFC_DR (DR)->written_at_least_once)\n+#define DR_RW_UNCONDITIONALLY(DR) (IFC_DR (DR)->rw_unconditionally)\n+\n /* Returns true when the memory references of STMT are read or written\n    unconditionally.  In other words, this function returns true when\n    for every data reference A in STMT there exist other accesses to\n@@ -465,24 +480,37 @@ memrefs_read_or_written_unconditionally (gimple stmt,\n     if (DR_STMT (a) == stmt)\n       {\n \tbool found = false;\n+\tint x = DR_RW_UNCONDITIONALLY (a);\n+\n+\tif (x == 0)\n+\t  return false;\n+\n+\tif (x == 1)\n+\t  continue;\n \n \tfor (j = 0; VEC_iterate (data_reference_p, drs, j, b); j++)\n \t  if (DR_STMT (b) != stmt\n \t      && same_data_refs (a, b))\n \t    {\n \t      tree cb = bb_predicate (gimple_bb (DR_STMT (b)));\n \n-\t      if (is_true_predicate (cb)\n+\t      if (DR_RW_UNCONDITIONALLY (b) == 1\n+\t\t  || is_true_predicate (cb)\n \t\t  || is_true_predicate (ca = fold_or_predicates (EXPR_LOCATION (cb),\n \t\t\t\t\t\t\t\t ca, cb)))\n \t\t{\n+\t\t  DR_RW_UNCONDITIONALLY (a) = 1;\n+\t\t  DR_RW_UNCONDITIONALLY (b) = 1;\n \t\t  found = true;\n \t\t  break;\n \t\t}\n \t    }\n \n \tif (!found)\n-\t  return false;\n+\t  {\n+\t    DR_RW_UNCONDITIONALLY (a) = 0;\n+\t    return false;\n+\t  }\n       }\n \n   return true;\n@@ -508,6 +536,13 @@ write_memrefs_written_at_least_once (gimple stmt,\n \t&& !DR_IS_READ (a))\n       {\n \tbool found = false;\n+\tint x = DR_WRITTEN_AT_LEAST_ONCE (a);\n+\n+\tif (x == 0)\n+\t  return false;\n+\n+\tif (x == 1)\n+\t  continue;\n \n \tfor (j = 0; VEC_iterate (data_reference_p, drs, j, b); j++)\n \t  if (DR_STMT (b) != stmt\n@@ -516,17 +551,23 @@ write_memrefs_written_at_least_once (gimple stmt,\n \t    {\n \t      tree cb = bb_predicate (gimple_bb (DR_STMT (b)));\n \n-\t      if (is_true_predicate (cb)\n+\t      if (DR_WRITTEN_AT_LEAST_ONCE (b) == 1\n+\t\t  || is_true_predicate (cb)\n \t\t  || is_true_predicate (ca = fold_or_predicates (EXPR_LOCATION (cb),\n \t\t\t\t\t\t\t\t ca, cb)))\n \t\t{\n+\t\t  DR_WRITTEN_AT_LEAST_ONCE (a) = 1;\n+\t\t  DR_WRITTEN_AT_LEAST_ONCE (b) = 1;\n \t\t  found = true;\n \t\t  break;\n \t\t}\n \t    }\n \n \tif (!found)\n-\t  return false;\n+\t  {\n+\t    DR_WRITTEN_AT_LEAST_ONCE (a) = 0;\n+\t    return false;\n+\t  }\n       }\n \n   return true;\n@@ -972,6 +1013,18 @@ if_convertible_loop_p_1 (struct loop *loop,\n   if (!res)\n     return false;\n \n+  if (flag_tree_loop_if_convert_stores)\n+    {\n+      data_reference_p dr;\n+\n+      for (i = 0; VEC_iterate (data_reference_p, *refs, i, dr); i++)\n+\t{\n+\t  dr->aux = XNEW (struct ifc_dr);\n+\t  DR_WRITTEN_AT_LEAST_ONCE (dr) = -1;\n+\t  DR_RW_UNCONDITIONALLY (dr) = -1;\n+\t}\n+    }\n+\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       basic_block bb = ifc_bbs[i];\n@@ -1045,6 +1098,15 @@ if_convertible_loop_p (struct loop *loop)\n   ddrs = VEC_alloc (ddr_p, heap, 25);\n   res = if_convertible_loop_p_1 (loop, &refs, &ddrs);\n \n+  if (flag_tree_loop_if_convert_stores)\n+    {\n+      data_reference_p dr;\n+      unsigned int i;\n+\n+      for (i = 0; VEC_iterate (data_reference_p, refs, i, dr); i++)\n+\tfree (dr->aux);\n+    }\n+\n   free_data_refs (refs);\n   free_dependence_relations (ddrs);\n   return res;"}]}