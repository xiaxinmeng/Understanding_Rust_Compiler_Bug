{"sha": "eccf4d702029b48512d573382ef5534a5df23893", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNjZjRkNzAyMDI5YjQ4NTEyZDU3MzM4MmVmNTUzNGE1ZGYyMzg5Mw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2018-01-11T15:24:26Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-01-11T15:24:26Z"}, "message": "[arm][3/3] Implement fp16fml lane intrinsics\n\nThis patch implements the lane-wise fp16fml intrinsics.\nThere's quite a few of them so I've split them up from\nthe other simpler fp16fml intrinsics.\n\nThese ones expose instructions such as\n\nvfmal.f16 Dd, Sn, Sm[<index>]  0 <= index <= 1\nvfmal.f16 Qd, Dn, Dm[<index>]  0 <= index <= 3\nvfmsl.f16 Dd, Sn, Sm[<index>]  0 <= index <= 1\nvfmsl.f16 Qd, Dn, Dm[<index>]  0 <= index <= 3\n\nThese instructions extract a single half-precision\nfloating-point value from one of the source regs\nand perform a vfmal/vfmsl operation as per the\nnormal variant with that value.\n\nThe nuance here is that some of the intrinsics want\nto do things like:\n\nfloat32x2_t vfmlal_laneq_low_u32 (float32x2_t __r, float16x4_t __a, float16x8_t __b, const int __index)\n\n\nwhere the float16x8_t value of '__b' is held in a Q\nregister, so we need to be a bit smart about finding\nthe right D or S sub-register and translating the\nlane number to a lane in that sub-register, instead\nof just passing the language-level const-int down to\nthe assembly instruction.\n\nThat's where most of the complexity of this patch comes from\nbut hopefully it's orthogonal enough to make sense.\n\nBootstrapped and tested on arm-none-linux-gnueabihf as well as\narmeb-none-eabi.\n\n\t* config/arm/arm_neon.h (vfmlal_lane_low_u32, vfmlal_lane_high_u32,\n\tvfmlalq_laneq_low_u32, vfmlalq_lane_low_u32, vfmlal_laneq_low_u32,\n\tvfmlalq_laneq_high_u32, vfmlalq_lane_high_u32, vfmlal_laneq_high_u32,\n\tvfmlsl_lane_low_u32, vfmlsl_lane_high_u32, vfmlslq_laneq_low_u32,\n\tvfmlslq_lane_low_u32, vfmlsl_laneq_low_u32, vfmlslq_laneq_high_u32,\n\tvfmlslq_lane_high_u32, vfmlsl_laneq_high_u32): Define.\n\t* config/arm/arm_neon_builtins.def (vfmal_lane_low,\n\tvfmal_lane_lowv4hf, vfmal_lane_lowv8hf, vfmal_lane_high,\n\tvfmal_lane_highv4hf, vfmal_lane_highv8hf, vfmsl_lane_low,\n\tvfmsl_lane_lowv4hf, vfmsl_lane_lowv8hf, vfmsl_lane_high,\n\tvfmsl_lane_highv4hf, vfmsl_lane_highv8hf): New sets of builtins.\n\t* config/arm/iterators.md (VFMLSEL2, vfmlsel2): New mode attributes.\n\t(V_lane_reg): Likewise.\n\t* config/arm/neon.md (neon_vfm<vfml_op>l_lane_<vfml_half><VCVTF:mode>):\n\tNew define_expand.\n\t(neon_vfm<vfml_op>l_lane_<vfml_half><vfmlsel2><mode>): Likewise.\n\t(vfmal_lane_low<mode>_intrinsic,\n\tvfmal_lane_low<vfmlsel2><mode>_intrinsic,\n\tvfmal_lane_high<vfmlsel2><mode>_intrinsic,\n\tvfmal_lane_high<mode>_intrinsic, vfmsl_lane_low<mode>_intrinsic,\n\tvfmsl_lane_low<vfmlsel2><mode>_intrinsic,\n\tvfmsl_lane_high<vfmlsel2><mode>_intrinsic,\n\tvfmsl_lane_high<mode>_intrinsic): New define_insns.\n\n\t* gcc.target/arm/simd/fp16fml_lane_high.c: New test.\n\t* gcc.target/arm/simd/fp16fml_lane_low.c: New test.\n\nFrom-SVN: r256540", "tree": {"sha": "892cf4a49b015ac6bde38cf06a10b9164db54cd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/892cf4a49b015ac6bde38cf06a10b9164db54cd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eccf4d702029b48512d573382ef5534a5df23893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eccf4d702029b48512d573382ef5534a5df23893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eccf4d702029b48512d573382ef5534a5df23893", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eccf4d702029b48512d573382ef5534a5df23893/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "06e9571582b8b006209d4cc462697544885d83ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06e9571582b8b006209d4cc462697544885d83ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06e9571582b8b006209d4cc462697544885d83ae"}], "stats": {"total": 631, "additions": 631, "deletions": 0}, "files": [{"sha": "a23405a744d48b3be0a60a6886400db74be8edc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eccf4d702029b48512d573382ef5534a5df23893/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eccf4d702029b48512d573382ef5534a5df23893/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eccf4d702029b48512d573382ef5534a5df23893", "patch": "@@ -1,3 +1,29 @@\n+2018-01-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/arm/arm_neon.h (vfmlal_lane_low_u32, vfmlal_lane_high_u32,\n+\tvfmlalq_laneq_low_u32, vfmlalq_lane_low_u32, vfmlal_laneq_low_u32,\n+\tvfmlalq_laneq_high_u32, vfmlalq_lane_high_u32, vfmlal_laneq_high_u32,\n+\tvfmlsl_lane_low_u32, vfmlsl_lane_high_u32, vfmlslq_laneq_low_u32,\n+\tvfmlslq_lane_low_u32, vfmlsl_laneq_low_u32, vfmlslq_laneq_high_u32,\n+\tvfmlslq_lane_high_u32, vfmlsl_laneq_high_u32): Define.\n+\t* config/arm/arm_neon_builtins.def (vfmal_lane_low,\n+\tvfmal_lane_lowv4hf, vfmal_lane_lowv8hf, vfmal_lane_high,\n+\tvfmal_lane_highv4hf, vfmal_lane_highv8hf, vfmsl_lane_low,\n+\tvfmsl_lane_lowv4hf, vfmsl_lane_lowv8hf, vfmsl_lane_high,\n+\tvfmsl_lane_highv4hf, vfmsl_lane_highv8hf): New sets of builtins.\n+\t* config/arm/iterators.md (VFMLSEL2, vfmlsel2): New mode attributes.\n+\t(V_lane_reg): Likewise.\n+\t* config/arm/neon.md (neon_vfm<vfml_op>l_lane_<vfml_half><VCVTF:mode>):\n+\tNew define_expand.\n+\t(neon_vfm<vfml_op>l_lane_<vfml_half><vfmlsel2><mode>): Likewise.\n+\t(vfmal_lane_low<mode>_intrinsic,\n+\tvfmal_lane_low<vfmlsel2><mode>_intrinsic,\n+\tvfmal_lane_high<vfmlsel2><mode>_intrinsic,\n+\tvfmal_lane_high<mode>_intrinsic, vfmsl_lane_low<mode>_intrinsic,\n+\tvfmsl_lane_low<vfmlsel2><mode>_intrinsic,\n+\tvfmsl_lane_high<vfmlsel2><mode>_intrinsic,\n+\tvfmsl_lane_high<mode>_intrinsic): New define_insns.\n+\n 2018-01-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm-cpus.in (fp16fml): New feature."}, {"sha": "6213a4aa0dabec756441523eee870e11485bb1c7", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=eccf4d702029b48512d573382ef5534a5df23893", "patch": "@@ -18160,6 +18160,150 @@ vfmlslq_high_u32 (float32x4_t __r, float16x8_t __a, float16x8_t __b)\n   return __builtin_neon_vfmsl_highv4sf (__r, __a, __b);\n }\n \n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlal_lane_low_u32 (float32x2_t __r, float16x4_t __a, float16x4_t __b,\n+\t\t     const int __index)\n+{\n+  __builtin_arm_lane_check (4, __index);\n+  return __builtin_neon_vfmal_lane_lowv2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlal_lane_high_u32 (float32x2_t __r, float16x4_t __a, float16x4_t __b,\n+\t\t      const int __index)\n+{\n+  __builtin_arm_lane_check (4, __index);\n+  return __builtin_neon_vfmal_lane_highv2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlalq_laneq_low_u32 (float32x4_t __r, float16x8_t __a, float16x8_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (8, __index);\n+  return __builtin_neon_vfmal_lane_lowv4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlalq_lane_low_u32 (float32x4_t __r, float16x8_t __a, float16x4_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (4, __index);\n+  return __builtin_neon_vfmal_lane_lowv4hfv4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlal_laneq_low_u32 (float32x2_t __r, float16x4_t __a, float16x8_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (8, __index);\n+  return __builtin_neon_vfmal_lane_lowv8hfv2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlalq_laneq_high_u32 (float32x4_t __r, float16x8_t __a, float16x8_t __b,\n+\t\t\tconst int __index)\n+{\n+  __builtin_arm_lane_check (8, __index);\n+  return __builtin_neon_vfmal_lane_highv4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlalq_lane_high_u32 (float32x4_t __r, float16x8_t __a, float16x4_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (4, __index);\n+  return __builtin_neon_vfmal_lane_highv4hfv4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlal_laneq_high_u32 (float32x2_t __r, float16x4_t __a, float16x8_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (8, __index);\n+  return __builtin_neon_vfmal_lane_highv8hfv2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlsl_lane_low_u32 (float32x2_t __r, float16x4_t __a, float16x4_t __b,\n+\t\t     const int __index)\n+{\n+  __builtin_arm_lane_check (4, __index);\n+  return __builtin_neon_vfmsl_lane_lowv2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlsl_lane_high_u32 (float32x2_t __r, float16x4_t __a, float16x4_t __b,\n+\t\t      const int __index)\n+{\n+  __builtin_arm_lane_check (4, __index);\n+  return __builtin_neon_vfmsl_lane_highv2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlslq_laneq_low_u32 (float32x4_t __r, float16x8_t __a, float16x8_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (8, __index);\n+  return __builtin_neon_vfmsl_lane_lowv4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlslq_lane_low_u32 (float32x4_t __r, float16x8_t __a, float16x4_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (4, __index);\n+  return __builtin_neon_vfmsl_lane_lowv4hfv4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlsl_laneq_low_u32 (float32x2_t __r, float16x4_t __a, float16x8_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (8, __index);\n+  return __builtin_neon_vfmsl_lane_lowv8hfv2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlslq_laneq_high_u32 (float32x4_t __r, float16x8_t __a, float16x8_t __b,\n+\t\t\tconst int __index)\n+{\n+  __builtin_arm_lane_check (8, __index);\n+  return __builtin_neon_vfmsl_lane_highv4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlslq_lane_high_u32 (float32x4_t __r, float16x8_t __a, float16x4_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (4, __index);\n+  return __builtin_neon_vfmsl_lane_highv4hfv4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vfmlsl_laneq_high_u32 (float32x2_t __r, float16x4_t __a, float16x8_t __b,\n+\t\t       const int __index)\n+{\n+  __builtin_arm_lane_check (8, __index);\n+  return __builtin_neon_vfmsl_lane_highv8hfv2sf (__r, __a, __b, __index);\n+}\n+\n #pragma GCC pop_options\n #endif\n "}, {"sha": "6ec293324fb879d9528ad6cc998d8a893f2cbaab", "filename": "gcc/config/arm/arm_neon_builtins.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def?ref=eccf4d702029b48512d573382ef5534a5df23893", "patch": "@@ -55,6 +55,18 @@ VAR2 (TERNOP, vfmal_low, v2sf, v4sf)\n VAR2 (TERNOP, vfmal_high, v2sf, v4sf)\n VAR2 (TERNOP, vfmsl_low, v2sf, v4sf)\n VAR2 (TERNOP, vfmsl_high, v2sf, v4sf)\n+VAR2 (MAC_LANE, vfmal_lane_low, v2sf, v4sf)\n+VAR1 (MAC_LANE, vfmal_lane_lowv4hf, v4sf)\n+VAR1 (MAC_LANE, vfmal_lane_lowv8hf, v2sf)\n+VAR2 (MAC_LANE, vfmal_lane_high, v2sf, v4sf)\n+VAR1 (MAC_LANE, vfmal_lane_highv4hf, v4sf)\n+VAR1 (MAC_LANE, vfmal_lane_highv8hf, v2sf)\n+VAR2 (MAC_LANE, vfmsl_lane_low, v2sf, v4sf)\n+VAR1 (MAC_LANE, vfmsl_lane_lowv4hf, v4sf)\n+VAR1 (MAC_LANE, vfmsl_lane_lowv8hf, v2sf)\n+VAR2 (MAC_LANE, vfmsl_lane_high, v2sf, v4sf)\n+VAR1 (MAC_LANE, vfmsl_lane_highv4hf, v4sf)\n+VAR1 (MAC_LANE, vfmsl_lane_highv8hf, v2sf)\n VAR3 (BINOP, vmullp, v8qi, v4hi, v2si)\n VAR3 (BINOP, vmulls, v8qi, v4hi, v2si)\n VAR3 (BINOP, vmullu, v8qi, v4hi, v2si)"}, {"sha": "5772aa99cc92de66ef4438b76632e86325a96ef2", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=eccf4d702029b48512d573382ef5534a5df23893", "patch": "@@ -484,6 +484,12 @@\n ;; Mode mapping for VFM[A,S]L instructions for the vec_select result.\n (define_mode_attr VFMLSEL [(V2SF \"V2HF\") (V4SF \"V4HF\")])\n \n+;; Mode mapping for VFM[A,S]L instructions for some awkward lane-wise forms.\n+(define_mode_attr VFMLSEL2 [(V2SF \"V8HF\") (V4SF \"V4HF\")])\n+\n+;; Same as the above, but lowercase.\n+(define_mode_attr vfmlsel2 [(V2SF \"v8hf\") (V4SF \"v4hf\")])\n+\n ;; Similar, for three elements.\n (define_mode_attr V_three_elem [(V8QI \"BLK\") (V16QI \"BLK\")\n                                 (V4HI \"BLK\") (V8HI \"BLK\")\n@@ -516,6 +522,10 @@\n ;; Output template to select the low VFP register of a mult-register value.\n (define_mode_attr V_lo [(V2SF \"\") (V4SF  \"e\")])\n \n+;; Helper attribute for printing output templates for awkward forms of\n+;; vfmlal/vfmlsl intrinsics.\n+(define_mode_attr V_lane_reg [(V2SF \"\") (V4SF  \"P\")])\n+\n ;; Wider modes with the same number of elements.\n (define_mode_attr V_widen [(V8QI \"V8HI\") (V4HI \"V4SI\") (V2SI \"V2DI\")])\n "}, {"sha": "59fb6435da8abfe46254558e8646cd4606acb4fa", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=eccf4d702029b48512d573382ef5534a5df23893", "patch": "@@ -2382,6 +2382,314 @@\n  [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n )\n \n+(define_expand \"neon_vfm<vfml_op>l_lane_<vfml_half><VCVTF:mode>\"\n+  [(set:VCVTF (match_operand:VCVTF 0 \"s_register_operand\")\n+     (unspec:VCVTF\n+\t[(match_operand:VCVTF 1 \"s_register_operand\")\n+\t (PLUSMINUS:<VFML>\n+\t   (match_operand:<VFML> 2 \"s_register_operand\")\n+\t   (match_operand:<VFML> 3 \"s_register_operand\"))\n+\t (match_operand:SI 4 \"const_int_operand\")] VFMLHALVES))]\n+  \"TARGET_FP16FML\"\n+{\n+  rtx lane = GEN_INT (NEON_ENDIAN_LANE_N (<VFML>mode, INTVAL (operands[4])));\n+  rtx half = arm_simd_vect_par_cnst_half (<VFML>mode, <vfml_half_selector>);\n+  emit_insn (gen_vfm<vfml_op>l_lane_<vfml_half><mode>_intrinsic\n+\t\t\t\t\t       (operands[0], operands[1],\n+\t\t\t\t\t\toperands[2], operands[3],\n+\t\t\t\t\t\thalf, lane));\n+  DONE;\n+})\n+\n+(define_insn \"vfmal_lane_low<mode>_intrinsic\"\n+ [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(fma:VCVTF\n+\t (float_extend:VCVTF\n+\t  (vec_select:<VFMLSEL>\n+\t   (match_operand:<VFML> 2 \"s_register_operand\" \"<VF_constraint>\")\n+\t   (match_operand:<VFML> 4 \"vect_par_constant_low\" \"\")))\n+\t (float_extend:VCVTF\n+\t   (vec_duplicate:<VFMLSEL>\n+\t     (vec_select:HF\n+\t       (match_operand:<VFML> 3 \"s_register_operand\" \"x\")\n+\t       (parallel [(match_operand:SI 5 \"const_int_operand\" \"n\")]))))\n+\t (match_operand:VCVTF 1 \"s_register_operand\" \"0\")))]\n+ \"TARGET_FP16FML\"\n+ {\n+    int lane = NEON_ENDIAN_LANE_N (<VFML>mode, INTVAL (operands[5]));\n+    if (lane > GET_MODE_NUNITS (<VFMLSEL>mode) - 1)\n+      {\n+\toperands[5] = GEN_INT (lane - GET_MODE_NUNITS (<VFMLSEL>mode));\n+\treturn \"vfmal.f16\\\\t%<V_reg>0, %<V_lo>2, %<V_hi>3[%c5]\";\n+      }\n+    else\n+      {\n+\toperands[5] = GEN_INT (lane);\n+\treturn \"vfmal.f16\\\\t%<V_reg>0, %<V_lo>2, %<V_lo>3[%c5]\";\n+      }\n+  }\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n+(define_expand \"neon_vfm<vfml_op>l_lane_<vfml_half><vfmlsel2><mode>\"\n+  [(set:VCVTF (match_operand:VCVTF 0 \"s_register_operand\")\n+     (unspec:VCVTF\n+\t[(match_operand:VCVTF 1 \"s_register_operand\")\n+\t (PLUSMINUS:<VFML>\n+\t   (match_operand:<VFML> 2 \"s_register_operand\")\n+\t   (match_operand:<VFMLSEL2> 3 \"s_register_operand\"))\n+\t (match_operand:SI 4 \"const_int_operand\")] VFMLHALVES))]\n+  \"TARGET_FP16FML\"\n+{\n+  rtx lane\n+    = GEN_INT (NEON_ENDIAN_LANE_N (<VFMLSEL2>mode, INTVAL (operands[4])));\n+  rtx half = arm_simd_vect_par_cnst_half (<VFML>mode, <vfml_half_selector>);\n+  emit_insn (gen_vfm<vfml_op>l_lane_<vfml_half><vfmlsel2><mode>_intrinsic\n+\t\t(operands[0], operands[1], operands[2], operands[3],\n+\t\t half, lane));\n+  DONE;\n+})\n+\n+;; Used to implement the intrinsics:\n+;; float32x4_t vfmlalq_lane_low_u32 (float32x4_t r, float16x8_t a, float16x4_t b, const int lane)\n+;; float32x2_t vfmlal_laneq_low_u32 (float32x2_t r, float16x4_t a, float16x8_t b, const int lane)\n+;; Needs a bit of care to get the modes of the different sub-expressions right\n+;; due to 'a' and 'b' having different sizes and make sure we use the right\n+;; S or D subregister to select the appropriate lane from.\n+\n+(define_insn \"vfmal_lane_low<vfmlsel2><mode>_intrinsic\"\n+ [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(fma:VCVTF\n+\t (float_extend:VCVTF\n+\t  (vec_select:<VFMLSEL>\n+\t   (match_operand:<VFML> 2 \"s_register_operand\" \"<VF_constraint>\")\n+\t   (match_operand:<VFML> 4 \"vect_par_constant_low\" \"\")))\n+\t (float_extend:VCVTF\n+\t   (vec_duplicate:<VFMLSEL>\n+\t     (vec_select:HF\n+\t       (match_operand:<VFMLSEL2> 3 \"s_register_operand\" \"x\")\n+\t       (parallel [(match_operand:SI 5 \"const_int_operand\" \"n\")]))))\n+\t (match_operand:VCVTF 1 \"s_register_operand\" \"0\")))]\n+ \"TARGET_FP16FML\"\n+ {\n+   int lane = NEON_ENDIAN_LANE_N (<VFMLSEL2>mode, INTVAL (operands[5]));\n+   int elts_per_reg = GET_MODE_NUNITS (<VFMLSEL>mode);\n+   int new_lane = lane % elts_per_reg;\n+   int regdiff = lane / elts_per_reg;\n+   operands[5] = GEN_INT (new_lane);\n+   /* We re-create operands[2] and operands[3] in the halved VFMLSEL modes\n+      because we want the print_operand code to print the appropriate\n+      S or D register prefix.  */\n+   operands[3] = gen_rtx_REG (<VFMLSEL>mode, REGNO (operands[3]) + regdiff);\n+   operands[2] = gen_rtx_REG (<VFMLSEL>mode, REGNO (operands[2]));\n+   return \"vfmal.f16\\\\t%<V_reg>0, %<V_lane_reg>2, %<V_lane_reg>3[%c5]\";\n+ }\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n+;; Used to implement the intrinsics:\n+;; float32x4_t vfmlalq_lane_high_u32 (float32x4_t r, float16x8_t a, float16x4_t b, const int lane)\n+;; float32x2_t vfmlal_laneq_high_u32 (float32x2_t r, float16x4_t a, float16x8_t b, const int lane)\n+;; Needs a bit of care to get the modes of the different sub-expressions right\n+;; due to 'a' and 'b' having different sizes and make sure we use the right\n+;; S or D subregister to select the appropriate lane from.\n+\n+(define_insn \"vfmal_lane_high<vfmlsel2><mode>_intrinsic\"\n+ [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(fma:VCVTF\n+\t (float_extend:VCVTF\n+\t  (vec_select:<VFMLSEL>\n+\t   (match_operand:<VFML> 2 \"s_register_operand\" \"<VF_constraint>\")\n+\t   (match_operand:<VFML> 4 \"vect_par_constant_high\" \"\")))\n+\t (float_extend:VCVTF\n+\t   (vec_duplicate:<VFMLSEL>\n+\t     (vec_select:HF\n+\t       (match_operand:<VFMLSEL2> 3 \"s_register_operand\" \"x\")\n+\t       (parallel [(match_operand:SI 5 \"const_int_operand\" \"n\")]))))\n+\t (match_operand:VCVTF 1 \"s_register_operand\" \"0\")))]\n+ \"TARGET_FP16FML\"\n+ {\n+   int lane = NEON_ENDIAN_LANE_N (<VFMLSEL2>mode, INTVAL (operands[5]));\n+   int elts_per_reg = GET_MODE_NUNITS (<VFMLSEL>mode);\n+   int new_lane = lane % elts_per_reg;\n+   int regdiff = lane / elts_per_reg;\n+   operands[5] = GEN_INT (new_lane);\n+   /* We re-create operands[3] in the halved VFMLSEL mode\n+      because we've calculated the correct half-width subreg to extract\n+      the lane from and we want to print *that* subreg instead.  */\n+   operands[3] = gen_rtx_REG (<VFMLSEL>mode, REGNO (operands[3]) + regdiff);\n+   return \"vfmal.f16\\\\t%<V_reg>0, %<V_hi>2, %<V_lane_reg>3[%c5]\";\n+ }\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n+(define_insn \"vfmal_lane_high<mode>_intrinsic\"\n+ [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(fma:VCVTF\n+\t (float_extend:VCVTF\n+\t  (vec_select:<VFMLSEL>\n+\t   (match_operand:<VFML> 2 \"s_register_operand\" \"<VF_constraint>\")\n+\t   (match_operand:<VFML> 4 \"vect_par_constant_high\" \"\")))\n+\t (float_extend:VCVTF\n+\t   (vec_duplicate:<VFMLSEL>\n+\t     (vec_select:HF\n+\t       (match_operand:<VFML> 3 \"s_register_operand\" \"x\")\n+\t       (parallel [(match_operand:SI 5 \"const_int_operand\" \"n\")]))))\n+\t (match_operand:VCVTF 1 \"s_register_operand\" \"0\")))]\n+ \"TARGET_FP16FML\"\n+  {\n+    int lane = NEON_ENDIAN_LANE_N (<VFML>mode, INTVAL (operands[5]));\n+    if (lane > GET_MODE_NUNITS (<VFMLSEL>mode) - 1)\n+      {\n+\toperands[5] = GEN_INT (lane - GET_MODE_NUNITS (<VFMLSEL>mode));\n+\treturn \"vfmal.f16\\\\t%<V_reg>0, %<V_hi>2, %<V_hi>3[%c5]\";\n+      }\n+    else\n+      {\n+\toperands[5] = GEN_INT (lane);\n+\treturn \"vfmal.f16\\\\t%<V_reg>0, %<V_hi>2, %<V_lo>3[%c5]\";\n+      }\n+  }\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n+(define_insn \"vfmsl_lane_low<mode>_intrinsic\"\n+ [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(fma:VCVTF\n+\t (float_extend:VCVTF\n+\t  (neg:<VFMLSEL>\n+\t    (vec_select:<VFMLSEL>\n+\t      (match_operand:<VFML> 2 \"s_register_operand\" \"<VF_constraint>\")\n+\t      (match_operand:<VFML> 4 \"vect_par_constant_low\" \"\"))))\n+\t (float_extend:VCVTF\n+\t   (vec_duplicate:<VFMLSEL>\n+\t     (vec_select:HF\n+\t       (match_operand:<VFML> 3 \"s_register_operand\" \"x\")\n+\t       (parallel [(match_operand:SI 5 \"const_int_operand\" \"n\")]))))\n+\t (match_operand:VCVTF 1 \"s_register_operand\" \"0\")))]\n+ \"TARGET_FP16FML\"\n+ {\n+    int lane = NEON_ENDIAN_LANE_N (<VFML>mode, INTVAL (operands[5]));\n+    if (lane > GET_MODE_NUNITS (<VFMLSEL>mode) - 1)\n+      {\n+\toperands[5] = GEN_INT (lane - GET_MODE_NUNITS (<VFMLSEL>mode));\n+\treturn \"vfmsl.f16\\\\t%<V_reg>0, %<V_lo>2, %<V_hi>3[%c5]\";\n+      }\n+    else\n+      {\n+\toperands[5] = GEN_INT (lane);\n+\treturn \"vfmsl.f16\\\\t%<V_reg>0, %<V_lo>2, %<V_lo>3[%c5]\";\n+      }\n+  }\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n+;; Used to implement the intrinsics:\n+;; float32x4_t vfmlslq_lane_low_u32 (float32x4_t r, float16x8_t a, float16x4_t b, const int lane)\n+;; float32x2_t vfmlsl_laneq_low_u32 (float32x2_t r, float16x4_t a, float16x8_t b, const int lane)\n+;; Needs a bit of care to get the modes of the different sub-expressions right\n+;; due to 'a' and 'b' having different sizes and make sure we use the right\n+;; S or D subregister to select the appropriate lane from.\n+\n+(define_insn \"vfmsl_lane_low<vfmlsel2><mode>_intrinsic\"\n+ [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(fma:VCVTF\n+\t (float_extend:VCVTF\n+\t  (neg:<VFMLSEL>\n+\t    (vec_select:<VFMLSEL>\n+\t      (match_operand:<VFML> 2 \"s_register_operand\" \"<VF_constraint>\")\n+\t      (match_operand:<VFML> 4 \"vect_par_constant_low\" \"\"))))\n+\t (float_extend:VCVTF\n+\t   (vec_duplicate:<VFMLSEL>\n+\t     (vec_select:HF\n+\t       (match_operand:<VFMLSEL2> 3 \"s_register_operand\" \"x\")\n+\t       (parallel [(match_operand:SI 5 \"const_int_operand\" \"n\")]))))\n+\t (match_operand:VCVTF 1 \"s_register_operand\" \"0\")))]\n+ \"TARGET_FP16FML\"\n+ {\n+   int lane = NEON_ENDIAN_LANE_N (<VFMLSEL2>mode, INTVAL (operands[5]));\n+   int elts_per_reg = GET_MODE_NUNITS (<VFMLSEL>mode);\n+   int new_lane = lane % elts_per_reg;\n+   int regdiff = lane / elts_per_reg;\n+   operands[5] = GEN_INT (new_lane);\n+   /* We re-create operands[2] and operands[3] in the halved VFMLSEL modes\n+      because we want the print_operand code to print the appropriate\n+      S or D register prefix.  */\n+   operands[3] = gen_rtx_REG (<VFMLSEL>mode, REGNO (operands[3]) + regdiff);\n+   operands[2] = gen_rtx_REG (<VFMLSEL>mode, REGNO (operands[2]));\n+   return \"vfmsl.f16\\\\t%<V_reg>0, %<V_lane_reg>2, %<V_lane_reg>3[%c5]\";\n+ }\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n+;; Used to implement the intrinsics:\n+;; float32x4_t vfmlslq_lane_high_u32 (float32x4_t r, float16x8_t a, float16x4_t b, const int lane)\n+;; float32x2_t vfmlsl_laneq_high_u32 (float32x2_t r, float16x4_t a, float16x8_t b, const int lane)\n+;; Needs a bit of care to get the modes of the different sub-expressions right\n+;; due to 'a' and 'b' having different sizes and make sure we use the right\n+;; S or D subregister to select the appropriate lane from.\n+\n+(define_insn \"vfmsl_lane_high<vfmlsel2><mode>_intrinsic\"\n+ [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(fma:VCVTF\n+\t (float_extend:VCVTF\n+\t  (neg:<VFMLSEL>\n+\t    (vec_select:<VFMLSEL>\n+\t     (match_operand:<VFML> 2 \"s_register_operand\" \"<VF_constraint>\")\n+\t     (match_operand:<VFML> 4 \"vect_par_constant_high\" \"\"))))\n+\t (float_extend:VCVTF\n+\t   (vec_duplicate:<VFMLSEL>\n+\t     (vec_select:HF\n+\t       (match_operand:<VFMLSEL2> 3 \"s_register_operand\" \"x\")\n+\t       (parallel [(match_operand:SI 5 \"const_int_operand\" \"n\")]))))\n+\t (match_operand:VCVTF 1 \"s_register_operand\" \"0\")))]\n+ \"TARGET_FP16FML\"\n+ {\n+   int lane = NEON_ENDIAN_LANE_N (<VFMLSEL2>mode, INTVAL (operands[5]));\n+   int elts_per_reg = GET_MODE_NUNITS (<VFMLSEL>mode);\n+   int new_lane = lane % elts_per_reg;\n+   int regdiff = lane / elts_per_reg;\n+   operands[5] = GEN_INT (new_lane);\n+   /* We re-create operands[3] in the halved VFMLSEL mode\n+      because we've calculated the correct half-width subreg to extract\n+      the lane from and we want to print *that* subreg instead.  */\n+   operands[3] = gen_rtx_REG (<VFMLSEL>mode, REGNO (operands[3]) + regdiff);\n+   return \"vfmsl.f16\\\\t%<V_reg>0, %<V_hi>2, %<V_lane_reg>3[%c5]\";\n+ }\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n+(define_insn \"vfmsl_lane_high<mode>_intrinsic\"\n+ [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(fma:VCVTF\n+\t (float_extend:VCVTF\n+\t  (neg:<VFMLSEL>\n+\t    (vec_select:<VFMLSEL>\n+\t     (match_operand:<VFML> 2 \"s_register_operand\" \"<VF_constraint>\")\n+\t     (match_operand:<VFML> 4 \"vect_par_constant_high\" \"\"))))\n+\t (float_extend:VCVTF\n+\t   (vec_duplicate:<VFMLSEL>\n+\t     (vec_select:HF\n+\t       (match_operand:<VFML> 3 \"s_register_operand\" \"x\")\n+\t       (parallel [(match_operand:SI 5 \"const_int_operand\" \"n\")]))))\n+\t (match_operand:VCVTF 1 \"s_register_operand\" \"0\")))]\n+ \"TARGET_FP16FML\"\n+  {\n+    int lane = NEON_ENDIAN_LANE_N (<VFML>mode, INTVAL (operands[5]));\n+    if (lane > GET_MODE_NUNITS (<VFMLSEL>mode) - 1)\n+      {\n+\toperands[5] = GEN_INT (lane - GET_MODE_NUNITS (<VFMLSEL>mode));\n+\treturn \"vfmsl.f16\\\\t%<V_reg>0, %<V_hi>2, %<V_hi>3[%c5]\";\n+      }\n+    else\n+      {\n+\toperands[5] = GEN_INT (lane);\n+\treturn \"vfmsl.f16\\\\t%<V_reg>0, %<V_hi>2, %<V_lo>3[%c5]\";\n+      }\n+  }\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n ; Used for intrinsics when flag_unsafe_math_optimizations is false.\n \n (define_insn \"neon_vmla<mode>_unspec\""}, {"sha": "b3d2fcbc1243d716134c08bef4e32e55c4bdca73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eccf4d702029b48512d573382ef5534a5df23893", "patch": "@@ -1,3 +1,8 @@\n+2018-01-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.target/arm/simd/fp16fml_lane_high.c: New test.\n+\t* gcc.target/arm/simd/fp16fml_lane_low.c: New test.\n+\n 2018-01-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/arm/multilib.exp: Add combination tests for fp16fml."}, {"sha": "67f5fa5f04f3458704d2d539d41aa029036fc680", "filename": "gcc/testsuite/gcc.target/arm/simd/fp16fml_lane_high.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Ffp16fml_lane_high.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Ffp16fml_lane_high.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Ffp16fml_lane_high.c?ref=eccf4d702029b48512d573382ef5534a5df23893", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_fp16fml_neon_ok } */\n+/* { dg-add-options arm_fp16fml_neon }  */\n+\n+#include \"arm_neon.h\"\n+\n+float32x2_t\n+test_vfmlal_lane_high_u32 (float32x2_t r, float16x4_t a, float16x4_t b)\n+{\n+  return vfmlal_lane_high_u32 (r, a, b, 0);\n+}\n+\n+float32x2_t\n+tets_vfmlsl_lane_high_u32  (float32x2_t r, float16x4_t a, float16x4_t b)\n+{\n+  return vfmlsl_lane_high_u32 (r, a, b, 0);\n+}\n+\n+float32x2_t\n+test_vfmlal_laneq_high_u32 (float32x2_t r, float16x4_t a, float16x8_t b)\n+{\n+  return vfmlal_laneq_high_u32 (r, a, b, 6);\n+}\n+\n+float32x2_t\n+test_vfmlsl_laneq_high_u32 (float32x2_t r, float16x4_t a, float16x8_t b)\n+{\n+  return vfmlsl_laneq_high_u32 (r, a, b, 6);\n+}\n+\n+float32x4_t\n+test_vfmlalq_lane_high_u32 (float32x4_t r, float16x8_t a, float16x4_t b)\n+{\n+  return vfmlalq_lane_high_u32 (r, a, b, 1);\n+}\n+\n+float32x4_t\n+test_vfmlslq_lane_high_u32 (float32x4_t r, float16x8_t a, float16x4_t b)\n+{\n+  return vfmlslq_lane_high_u32 (r, a, b, 1);\n+}\n+\n+float32x4_t\n+test_vfmlalq_laneq_high_u32  (float32x4_t r, float16x8_t a, float16x8_t b)\n+{\n+  return vfmlalq_laneq_high_u32 (r, a, b, 7);\n+}\n+\n+float32x4_t\n+test_vfmlslq_laneq_high_u32 (float32x4_t r, float16x8_t a, float16x8_t b)\n+{\n+  return vfmlslq_laneq_high_u32 (r, a, b, 7);\n+}\n+\n+/* { dg-final { scan-assembler-times {vfmal.f16\\td[0-9]+, s[123]?[13579], s[123]?[02468]\\[0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmal.f16\\td[0-9]+, s[123]?[13579], s[123]?[13579]\\[0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmal.f16\\tq[0-9]+, d[123]?[13579], d[0-9]+\\[1\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmal.f16\\tq[0-9]+, d[123]?[13579], d[123]?[13579]\\[3\\]} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {vfmsl.f16\\td[0-9]+, s[123]?[13579], s[123]?[02468]\\[0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmsl.f16\\td[0-9]+, s[123]?[13579], s[123]?[13579]\\[0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmsl.f16\\tq[0-9]+, d[123]?[13579], d[0-9]+\\[1\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmsl.f16\\tq[0-9]+, d[123]?[13579], d[123]?[13579]\\[3\\]} 1 } } */"}, {"sha": "585f775fb57a2f1d479eb66b2728f279cf3e4faf", "filename": "gcc/testsuite/gcc.target/arm/simd/fp16fml_lane_low.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Ffp16fml_lane_low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eccf4d702029b48512d573382ef5534a5df23893/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Ffp16fml_lane_low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Ffp16fml_lane_low.c?ref=eccf4d702029b48512d573382ef5534a5df23893", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_fp16fml_neon_ok } */\n+/* { dg-add-options arm_fp16fml_neon }  */\n+\n+#include \"arm_neon.h\"\n+\n+float32x2_t\n+test_vfmlal_lane_low_u32 (float32x2_t r, float16x4_t a, float16x4_t b)\n+{\n+  return vfmlal_lane_low_u32 (r, a, b, 0);\n+}\n+\n+float32x2_t\n+test_vfmlsl_lane_low_u32 (float32x2_t r, float16x4_t a, float16x4_t b)\n+{\n+  return vfmlsl_lane_low_u32 (r, a, b, 0);\n+}\n+\n+float32x2_t\n+test_vfmlal_laneq_low_u32 (float32x2_t r, float16x4_t a, float16x8_t b)\n+{\n+  return vfmlal_laneq_low_u32 (r, a, b, 6);\n+}\n+\n+float32x2_t\n+test_vfmlsl_laneq_low_u32 (float32x2_t r, float16x4_t a, float16x8_t b)\n+{\n+  return vfmlsl_laneq_low_u32 (r, a, b, 6);\n+}\n+\n+float32x4_t\n+test_vfmlalq_lane_low_u32 (float32x4_t r, float16x8_t a, float16x4_t b)\n+{\n+  return vfmlalq_lane_low_u32 (r, a, b, 1);\n+}\n+\n+float32x4_t\n+test_vfmlslq_lane_low_u32 (float32x4_t r, float16x8_t a, float16x4_t b)\n+{\n+  return vfmlslq_lane_low_u32 (r, a, b, 1);\n+}\n+\n+float32x4_t\n+test_vfmlalq_laneq_low_u32 (float32x4_t r, float16x8_t a, float16x8_t b)\n+{\n+  return vfmlalq_laneq_low_u32 (r, a, b, 7);\n+}\n+\n+float32x4_t\n+test_vfmlslq_laneq_low_u32 (float32x4_t r, float16x8_t a, float16x8_t b)\n+{\n+  return vfmlslq_laneq_low_u32 (r, a, b, 7);\n+}\n+\n+/* { dg-final { scan-assembler-times {vfmal.f16\\td[0-9]+, s[123]?[02468], s[123]?[02468]\\[0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmal.f16\\td[0-9]+, s[123]?[02468], s[123]?[13579]\\[0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmal.f16\\tq[0-9]+, d[123]?[02468], d[0-9]+\\[1\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmal.f16\\tq[0-9]+, d[123]?[02468], d[123]?[13579]\\[3\\]} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {vfmsl.f16\\td[0-9]+, s[123]?[02468], s[123]?[02468]\\[0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmsl.f16\\td[0-9]+, s[123]?[02468], s[123]?[13579]\\[0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmsl.f16\\tq[0-9]+, d[123]?[02468], d[0-9]+\\[1\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {vfmsl.f16\\tq[0-9]+, d[123]?[02468], d[123]?[13579]\\[3\\]} 1 } } */"}]}