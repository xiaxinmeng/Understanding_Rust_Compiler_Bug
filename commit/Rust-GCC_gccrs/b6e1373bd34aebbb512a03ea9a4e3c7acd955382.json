{"sha": "b6e1373bd34aebbb512a03ea9a4e3c7acd955382", "node_id": "C_kwDOANBUbNoAKGI2ZTEzNzNiZDM0YWViYmI1MTJhMDNlYTlhNGUzYzdhY2Q5NTUzODI", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-06-08T19:43:03Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-06-08T19:43:03Z"}, "message": "PR middle-end/105874: Use EXPAND_MEMORY to fix ada bootstrap.\n\nMany thanks to Tamar Christina for filing PR middle-end/105874 indicating\nthat SPECcpu 2017's Leela is failing on x86_64 due to a miscompilation\nof FastBoard::is_eye.  This function is much smaller and easier to work\nwith than my previous hunt for the cause of the Ada bootstrap failures\ndue to miscompilation somewhere in GCC (or one of the 131 places that\nthe problematic form of optimization triggers during an ada bootstrap).\n\nIt turns out the source of the miscompilation introduced by my recent\npatch is the distinction (during RTL expansion) of l-values and r-values.\nAccording to the documentation above expand_modifier, EXPAND_MEMORY\nshould be used for lvalues (when a memory is required), and EXPAND_NORMAL\nfor rvalues when a constant is permissible.  In what I'd like to consider\na latent bug, the recursive call to expand_expr_real on line 11188 of\nexpr.cc, in the case handling ARRAY_REF, COMPONENT_REF, BIT_FIELD_REF\nand ARRARY_RANGE_REF was passing EXPAND_NORMAL when it really required\n(the semantics of) EXPAND_MEMORY.  All the time that VAR_DECLs were\nbeing returned as memory this was fine, but as soon as we're able to\noptimize sort arrays into immediate constants, bad things happen.\n\nIn the test case from Leela, we notice that the array s_eyemask\nalways has DImode constant value { 4, 64 }, which is useful as\nan rvalue, but not when we need to index it as an lvalue, as in\ns_eyemask[color].  This also explains why everything being accepted\nby immediate_const_ctor_p (during an ada bootstrap) looks reasonable,\nwhat's incorrect is that we don't know how these structs/arrays are\nto be used.\n\nThe fix is to ensure that we call expand_expr with EXPAND_MEMORY\nwhen processing the VAR_DECL's returned by get_inner_reference.\n\n2022-06-08  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR middle-end/105874\n\t* expr.cc (expand_expr_real_1) <normal_inner_ref>:  New local\n\tvariable tem_modifier for calculating the expand_modifier enum to\n\tuse for expanding tem.  If tem is a VAR_DECL, use EXPAND_MEMORY.\n\ngcc/testsuite/ChangeLog\n\tPR middle-end/105874\n\t* g++.dg/opt/pr105874.C: New test case.", "tree": {"sha": "b9073ac0a0039cde573021a048061da77a4bc2de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9073ac0a0039cde573021a048061da77a4bc2de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6e1373bd34aebbb512a03ea9a4e3c7acd955382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e1373bd34aebbb512a03ea9a4e3c7acd955382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e1373bd34aebbb512a03ea9a4e3c7acd955382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e1373bd34aebbb512a03ea9a4e3c7acd955382/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e94c6dbfb57a862dd8a8685eabc4886ad1aaea25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e94c6dbfb57a862dd8a8685eabc4886ad1aaea25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e94c6dbfb57a862dd8a8685eabc4886ad1aaea25"}], "stats": {"total": 41, "additions": 38, "deletions": 3}, "files": [{"sha": "c37a999053625e569ea6a9ab3f9a99f7cd2502d0", "filename": "gcc/expr.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e1373bd34aebbb512a03ea9a4e3c7acd955382/gcc%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e1373bd34aebbb512a03ea9a4e3c7acd955382/gcc%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.cc?ref=b6e1373bd34aebbb512a03ea9a4e3c7acd955382", "patch": "@@ -11181,6 +11181,13 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t   infinitely recurse.  */\n \tgcc_assert (tem != exp);\n \n+\t/* If tem is a VAR_DECL, we need a memory reference.  */\n+\tenum expand_modifier tem_modifier = modifier;\n+\tif (tem_modifier == EXPAND_SUM)\n+\t  tem_modifier = EXPAND_NORMAL;\n+\tif (TREE_CODE (tem) == VAR_DECL)\n+\t  tem_modifier = EXPAND_MEMORY;\n+\n \t/* If TEM's type is a union of variable size, pass TARGET to the inner\n \t   computation, since it will need a temporary and TARGET is known\n \t   to have to do.  This occurs in unchecked conversion in Ada.  */\n@@ -11192,9 +11199,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t\t\t   != INTEGER_CST)\n \t\t\t       && modifier != EXPAND_STACK_PARM\n \t\t\t       ? target : NULL_RTX),\n-\t\t\t      VOIDmode,\n-\t\t\t      modifier == EXPAND_SUM ? EXPAND_NORMAL : modifier,\n-\t\t\t      NULL, true);\n+\t\t\t      VOIDmode, tem_modifier, NULL, true);\n \n \t/* If the field has a mode, we want to access it in the\n \t   field's mode, not the computed mode."}, {"sha": "58699a6f03aeb7f2e0c8f3b3d3355f2f7fc14c20", "filename": "gcc/testsuite/g++.dg/opt/pr105874.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e1373bd34aebbb512a03ea9a4e3c7acd955382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr105874.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e1373bd34aebbb512a03ea9a4e3c7acd955382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr105874.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr105874.C?ref=b6e1373bd34aebbb512a03ea9a4e3c7acd955382", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -std=c++11\" } */\n+#include <array>\n+\n+static constexpr int NBR_SHIFT = 4;\n+\n+static constexpr int MAXBOARDSIZE = 25;\n+\n+static constexpr int MAXSQ = ((MAXBOARDSIZE + 2) * (MAXBOARDSIZE + 2));\n+\n+enum square_t : char {\n+        BLACK = 0, WHITE = 1, EMPTY = 2, INVAL = 3\n+    };\n+\n+const std::array<int, 2> s_eyemask = {\n+    4 * (1 << (NBR_SHIFT * BLACK)),\n+    4 * (1 << (NBR_SHIFT * WHITE))\n+};\n+\n+/* counts of neighboring stones */\n+std::array<unsigned short, MAXSQ> m_neighbours;\n+\n+int is_eye(const int color, const int i) {\n+    /* check for 4 neighbors of the same color */\n+    int ownsurrounded = (m_neighbours[i] & s_eyemask[color]);\n+\n+    return ownsurrounded;\n+}\n+\n+/* { dg-final { scan-assembler \"s_eyemask\" } } */"}]}