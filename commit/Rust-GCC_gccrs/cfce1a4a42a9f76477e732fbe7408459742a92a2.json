{"sha": "cfce1a4a42a9f76477e732fbe7408459742a92a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZjZTFhNGE0MmE5Zjc2NDc3ZTczMmZiZTc0MDg0NTk3NDJhOTJhMg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-12-14T21:58:19Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-12-14T21:58:19Z"}, "message": "PR middle-end/78786 - GCC hangs/out of memory calling sprintf with large precision\n\ngcc/ChangeLog:\n\n\tPR middle-end/78786\n\t* gimple-ssa-sprintf.c (target_dir_max): New macro.\n\t(get_mpfr_format_length): New function.\n\t(format_integer): Use HOST_WIDE_INT instead of int.\n\t(format_floating_max): Same.\n\t(format_floating): Call get_mpfr_format_length.\n\t(format_directive): Use target_dir_max.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/78786\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-7.c: New test.\n\nFrom-SVN: r243672", "tree": {"sha": "e743e6d8a689f55f3c3234066fdbbf8b2306b7d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e743e6d8a689f55f3c3234066fdbbf8b2306b7d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfce1a4a42a9f76477e732fbe7408459742a92a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfce1a4a42a9f76477e732fbe7408459742a92a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfce1a4a42a9f76477e732fbe7408459742a92a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfce1a4a42a9f76477e732fbe7408459742a92a2/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8000827901d090f62414ff75203e03b00acd4ca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8000827901d090f62414ff75203e03b00acd4ca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8000827901d090f62414ff75203e03b00acd4ca5"}], "stats": {"total": 343, "additions": 295, "deletions": 48}, "files": [{"sha": "7919ad8d2727c8a3ef95d6f323cab559a0fff376", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfce1a4a42a9f76477e732fbe7408459742a92a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfce1a4a42a9f76477e732fbe7408459742a92a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfce1a4a42a9f76477e732fbe7408459742a92a2", "patch": "@@ -1,3 +1,13 @@\n+2016-12-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78786\n+\t* gimple-ssa-sprintf.c (target_dir_max): New macro.\n+\t(get_mpfr_format_length): New function.\n+\t(format_integer): Use HOST_WIDE_INT instead of int.\n+\t(format_floating_max): Same.\n+\t(format_floating): Call get_mpfr_format_length.\n+\t(format_directive): Use target_dir_max.\n+\n 2016-12-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/78791"}, {"sha": "5909e054a613b53711700fca319fae6dc62bd3e2", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 97, "deletions": 48, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfce1a4a42a9f76477e732fbe7408459742a92a2/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfce1a4a42a9f76477e732fbe7408459742a92a2/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=cfce1a4a42a9f76477e732fbe7408459742a92a2", "patch": "@@ -84,6 +84,12 @@ along with GCC; see the file COPYING3.  If not see\n    to be used for optimization but it's good enough as is for warnings.  */\n #define target_mb_len_max   6\n \n+/* The maximum number of bytes a single non-string directive can result\n+   in.  This is the result of printf(\"%.*Lf\", INT_MAX, -LDBL_MAX) for\n+   LDBL_MAX_10_EXP of 4932.  */\n+#define IEEE_MAX_10_EXP    4932\n+#define target_dir_max()   (target_int_max () + IEEE_MAX_10_EXP + 2)\n+\n namespace {\n \n const pass_data pass_data_sprintf_length = {\n@@ -989,7 +995,7 @@ format_integer (const conversion_spec &spec, tree arg)\n \t  gcc_unreachable ();\n \t}\n \n-      int len;\n+      HOST_WIDE_INT len;\n \n       if ((prec == HOST_WIDE_INT_MIN || prec == 0) && integer_zerop (arg))\n \t{\n@@ -1214,11 +1220,73 @@ format_integer (const conversion_spec &spec, tree arg)\n   return res;\n }\n \n+/* Return the number of bytes that a format directive consisting of FLAGS,\n+   PRECision, format SPECification, and MPFR rounding specifier RNDSPEC,\n+   would result for argument X under ideal conditions (i.e., if PREC\n+   weren't excessive).  MPFR 3.1 allocates large amounts of memory for\n+   values of PREC with large magnitude and can fail (see MPFR bug #21056).\n+   This function works around those problems.  */\n+\n+static unsigned HOST_WIDE_INT\n+get_mpfr_format_length (mpfr_ptr x, const char *flags, HOST_WIDE_INT prec,\n+\t\t\tchar spec, char rndspec)\n+{\n+  char fmtstr[40];\n+\n+  HOST_WIDE_INT len = strlen (flags);\n+\n+  fmtstr[0] = '%';\n+  memcpy (fmtstr + 1, flags, len);\n+  memcpy (fmtstr + 1 + len, \".*R\", 3);\n+  fmtstr[len + 4] = rndspec;\n+  fmtstr[len + 5] = spec;\n+  fmtstr[len + 6] = '\\0';\n+\n+  /* Avoid passing negative precisions with larger magnitude to MPFR\n+     to avoid exposing its bugs.  (A negative precision is supposed\n+     to be ignored.)  */\n+  if (prec < 0)\n+    prec = -1;\n+\n+  HOST_WIDE_INT p = prec;\n+\n+  if (TOUPPER (spec) == 'G')\n+    {\n+      /* For G/g, precision gives the maximum number of significant\n+\t digits which is bounded by LDBL_MAX_10_EXP, or, for a 128\n+\t bit IEEE extended precision, 4932.  Using twice as much\n+\t here should be more than sufficient for any real format.  */\n+      if ((IEEE_MAX_10_EXP * 2) < prec)\n+\tprec = IEEE_MAX_10_EXP * 2;\n+      p = prec;\n+    }\n+  else\n+    {\n+      /* Cap precision arbitrarily at 1KB and add the difference\n+\t (if any) to the MPFR result.  */\n+      if (1024 < prec)\n+\tp = 1024;\n+    }\n+\n+  len = mpfr_snprintf (NULL, 0, fmtstr, (int)p, x);\n+\n+  /* Handle the unlikely (impossible?) error by returning more than\n+     the maximum dictated by the function's return type.  */\n+  if (len < 0)\n+    return target_dir_max () + 1;\n+\n+  /* Adjust the return value by the difference.  */\n+  if (p < prec)\n+    len += prec - p;\n+\n+  return len;\n+}\n+\n /* Return the number of bytes to format using the format specifier\n    SPEC the largest value in the real floating TYPE.  */\n \n-static int\n-format_floating_max (tree type, char spec, int prec = -1)\n+static unsigned HOST_WIDE_INT\n+format_floating_max (tree type, char spec, HOST_WIDE_INT prec)\n {\n   machine_mode mode = TYPE_MODE (type);\n \n@@ -1243,21 +1311,8 @@ format_floating_max (tree type, char spec, int prec = -1)\n   mpfr_init2 (x, rfmt->p);\n   mpfr_from_real (x, &rv, GMP_RNDN);\n \n-  int n;\n-\n-  if (-1 < prec)\n-    {\n-      const char fmt[] = { '%', '.', '*', 'R', spec, '\\0' };\n-      n = mpfr_snprintf (NULL, 0, fmt, prec, x);\n-    }\n-  else\n-    {\n-      const char fmt[] = { '%', 'R', spec, '\\0' };\n-      n = mpfr_snprintf (NULL, 0, fmt, x);\n-    }\n-\n   /* Return a value one greater to account for the leading minus sign.  */\n-  return n + 1;\n+  return 1 + get_mpfr_format_length (x, \"\", prec, spec, 'D');\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n@@ -1266,7 +1321,8 @@ format_floating_max (tree type, char spec, int prec = -1)\n    is used when the directive argument or its value isn't known.  */\n \n static fmtresult\n-format_floating (const conversion_spec &spec, int width, int prec)\n+format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n+\t\t HOST_WIDE_INT prec)\n {\n   tree type;\n   bool ldbl = false;\n@@ -1357,7 +1413,7 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \tres.range.min = 2 + (prec < 0 ? 6 : prec);\n \n \t/* Compute the maximum just once.  */\n-\tconst int f_max[] = {\n+\tconst HOST_WIDE_INT f_max[] = {\n \t  format_floating_max (double_type_node, 'f', prec),\n \t  format_floating_max (long_double_type_node, 'f', prec)\n \t};\n@@ -1372,10 +1428,10 @@ format_floating (const conversion_spec &spec, int width, int prec)\n     case 'g':\n       {\n \t/* The minimum is the same as for '%F'.  */\n-\tres.range.min = 2 + (prec < 0 ? 6 : prec);\n+\tres.range.min = 1;\n \n \t/* Compute the maximum just once.  */\n-\tconst int g_max[] = {\n+\tconst HOST_WIDE_INT g_max[] = {\n \t  format_floating_max (double_type_node, 'g', prec),\n \t  format_floating_max (long_double_type_node, 'g', prec)\n \t};\n@@ -1412,8 +1468,8 @@ format_floating (const conversion_spec &spec, tree arg)\n   /* Set WIDTH to -1 when it's not specified, to INT_MIN when it is\n      specified by the asterisk to an unknown value, and otherwise to\n      a non-negative value corresponding to the specified width.  */\n-  int width = -1;\n-  int prec = -1;\n+  HOST_WIDE_INT width = -1;\n+  HOST_WIDE_INT prec = -1;\n \n   /* The minimum and maximum number of bytes produced by the directive.  */\n   fmtresult res;\n@@ -1473,41 +1529,30 @@ format_floating (const conversion_spec &spec, tree arg)\n \n       char fmtstr [40];\n       char *pfmt = fmtstr;\n-      *pfmt++ = '%';\n \n       /* Append flags.  */\n       for (const char *pf = \"-+ #0\"; *pf; ++pf)\n \tif (spec.get_flag (*pf))\n \t  *pfmt++ = *pf;\n \n-      /* Append width when specified and precision.  */\n-      if (-1 < width)\n-\tpfmt += sprintf (pfmt, \"%i\", width);\n-      if (-1 < prec)\n-\tpfmt += sprintf (pfmt, \".%i\", prec);\n-\n-      /* Append the MPFR 'R' floating type specifier (no length modifier\n-\t is necessary or allowed by MPFR for mpfr_t values).  */\n-      *pfmt++ = 'R';\n-\n-      /* Save the position of the MPFR rounding specifier and skip over\n-\t it.  It will be set in each iteration in the loop below.  */\n-      char* const rndspec = pfmt++;\n-\n-      /* Append the C type specifier and nul-terminate.  */\n-      *pfmt++ = spec.specifier;\n       *pfmt = '\\0';\n \n       for (int i = 0; i != sizeof minmax / sizeof *minmax; ++i)\n \t{\n \t  /* Use the MPFR rounding specifier to round down in the first\n \t     iteration and then up.  In most but not all cases this will\n \t     result in the same number of bytes.  */\n-\t  *rndspec = \"DU\"[i];\n+\t  char rndspec = \"DU\"[i];\n+\n+\t  /* Format it and store the result in the corresponding member\n+\t     of the result struct.  */\n+\t  unsigned HOST_WIDE_INT len\n+\t    = get_mpfr_format_length (mpfrval, fmtstr, prec,\n+\t\t\t\t      spec.specifier, rndspec);\n+\t  if (0 < width && len < (unsigned)width)\n+\t    len = width;\n \n-\t  /* Format it and store the result in the corresponding\n-\t     member of the result struct.  */\n-\t  *minmax[i] = mpfr_snprintf (NULL, 0, fmtstr, mpfrval);\n+\t  *minmax[i] = len;\n \t}\n \n       /* The range of output is known even if the result isn't bounded.  */\n@@ -1834,9 +1879,13 @@ format_directive (const pass_sprintf_length::call_info &info,\n   if (!fmtres.knownrange)\n     {\n       /* Only when the range is known, check it against the host value\n-\t of INT_MAX.  Otherwise the range doesn't correspond to known\n-\t values of the argument.  */\n-      if (fmtres.range.max >= target_int_max ())\n+\t of INT_MAX + (the number of bytes of the \"%.*Lf\" directive with\n+\t INT_MAX precision, which is the longest possible output of any\n+\t single directive).  That's the largest valid byte count (though\n+\t not valid call to a printf-like function because it can never\n+\t return such a count).  Otherwise, the range doesn't correspond\n+\t to known values of the argument.  */\n+      if (fmtres.range.max > target_dir_max ())\n \t{\n \t  /* Normalize the MAX counter to avoid having to deal with it\n \t     later.  The counter can be less than HOST_WIDE_INT_M1U\n@@ -1850,7 +1899,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t  res->number_chars = HOST_WIDE_INT_M1U;\n \t}\n \n-      if (fmtres.range.min >= target_int_max ())\n+      if (fmtres.range.min > target_dir_max ())\n \t{\n \t  /* Disable exact length checking after a failure to determine\n \t     even the minimum number of characters (it shouldn't happen"}, {"sha": "8fb754ce7d5cf8899e4381f1c495ab99fff39335", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfce1a4a42a9f76477e732fbe7408459742a92a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfce1a4a42a9f76477e732fbe7408459742a92a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cfce1a4a42a9f76477e732fbe7408459742a92a2", "patch": "@@ -1,3 +1,8 @@\n+2016-12-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78786\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-7.c: New test.\n+\n 2016-12-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/78791"}, {"sha": "0069348a75b90c90415a6259631e9793400d0f5d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-7.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfce1a4a42a9f76477e732fbe7408459742a92a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfce1a4a42a9f76477e732fbe7408459742a92a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c?ref=cfce1a4a42a9f76477e732fbe7408459742a92a2", "patch": "@@ -0,0 +1,183 @@\n+/* PR middle-end/78786 - GCC hangs/out of memory calling sprintf with large\n+   precision\n+   { dg-do compile }\n+   { dg-require-effective-target int32plus }\n+   { dg-options \"-Wformat-length -ftrack-macro-expansion=0\" } */\n+\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-INT_MAX - 1)\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void sink (int, void*);\n+\n+char buf [1];\n+\n+#define T(n, fmt, ...)\t\t\t\t\t\\\n+  sink (__builtin_sprintf (buf + sizeof buf - n, fmt, __VA_ARGS__), buf)\n+\n+void test_integer_cst (void)\n+{\n+  T (0, \"%*d\",  INT_MIN, 0);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*d\",  INT_MAX, 0);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*d\", INT_MIN, 0);     /* { dg-warning \"writing 1 byte\" } */\n+  T (0, \"%.*d\", INT_MAX, 0);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%*.*d\", INT_MIN, INT_MIN, 0);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*d\", INT_MAX, INT_MAX, 0);   /* { dg-warning \"writing 2147483647 bytes\" } */\n+}\n+\n+void test_integer_var (int i)\n+{\n+  T (0, \"%*d\",  INT_MIN, i);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*d\",  INT_MAX, i);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*d\", INT_MIN, i);     /* { dg-warning \"writing between 1 and 11 bytes\" } */\n+  T (0, \"%.*d\", INT_MAX, i);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%*.*d\", INT_MIN, INT_MIN, i);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*d\", INT_MAX, INT_MAX, i);   /* { dg-warning \"writing 2147483647 bytes\" } */\n+}\n+\n+void test_floating_a_cst (void)\n+{\n+  T (0, \"%*a\",  INT_MIN, 0.);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*a\",  INT_MAX, 0.);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*a\", INT_MIN, 0.);     /* { dg-warning \"writing 6 bytes\" } */\n+\n+  T (0, \"%.*a\", INT_MAX, 0.);     /* { dg-warning \"writing 2147483654 bytes\" } */\n+\n+  T (0, \"%*.*a\", INT_MIN, INT_MIN, 0.);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*a\", INT_MAX, INT_MAX, 0.);   /* { dg-warning \"writing 2147483654 bytes\" } */\n+}\n+\n+void test_floating_a_var (double x)\n+{\n+  T (0, \"%*a\",  INT_MIN, x);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*a\",  INT_MAX, x);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*a\", INT_MIN, x);     /* { dg-warning \"writing between 6 and 24 bytes\" } */\n+\n+  T (0, \"%.*a\", INT_MAX, x);     /* { dg-warning \"writing between 2147483653 and 2147483658 bytes\" } */\n+\n+  T (0, \"%*.*a\", INT_MIN, INT_MIN, x);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*a\", INT_MAX, INT_MAX, x);   /* { dg-warning \"writing between 2147483653 and 2147483658 bytes\" } */\n+}\n+\n+void test_floating_e_cst (void)\n+{\n+  T (0, \"%*e\",  INT_MIN, 0.);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*e\",  INT_MAX, 0.);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*e\", INT_MIN, 0.);     /* { dg-warning \"writing 5 bytes\" } */\n+\n+  T (0, \"%.*e\", INT_MAX, 0.);     /* { dg-warning \"writing 2147483653 bytes\" } */\n+\n+  T (0, \"%*.*e\", INT_MIN, INT_MIN, 0.);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*e\", INT_MAX, INT_MAX, 0.);   /* { dg-warning \"writing 2147483653 bytes\" } */\n+}\n+\n+void test_floating_e_var (double x)\n+{\n+  T (0, \"%*e\",  INT_MIN, x);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*e\",  INT_MAX, x);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*e\", INT_MIN, x);     /* { dg-warning \"writing between 12 and 14 bytes\" } */\n+\n+  T (0, \"%.*e\", INT_MAX, x);     /* { dg-warning \"writing between 2147483653 and 2147483655 bytes\" } */\n+\n+  T (0, \"%*.*e\", INT_MIN, INT_MIN, x);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*e\", INT_MAX, INT_MAX, x);   /* { dg-warning \"writing between 2147483653 and 2147483655 bytes\" } */\n+}\n+\n+void test_floating_f_cst (void)\n+{\n+  T (0, \"%*f\",  INT_MIN, 0.);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*f\",  INT_MAX, 0.);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*f\", INT_MIN, 0.);     /* { dg-warning \"writing 1 byte\" } */\n+\n+  T (0, \"%.*f\", INT_MAX, 0.);     /* { dg-warning \"writing 2147483649 bytes\" } */\n+\n+  T (0, \"%*.*f\", INT_MIN, INT_MIN, 0.);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*f\", INT_MAX, INT_MAX, 0.);   /* { dg-warning \"writing 2147483649 bytes\" } */\n+}\n+\n+void test_floating_f_var (double x)\n+{\n+  T (0, \"%*f\",  INT_MIN, x);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*f\",  INT_MAX, x);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*f\", INT_MIN, x);     /* { dg-warning \"writing between 8 and 317 bytes\" } */\n+\n+  T (0, \"%.*f\", INT_MAX, x);     /* { dg-warning \"writing between 2147483649 and 2147483958 bytes\" } */\n+\n+  T (0, \"%*.*f\", INT_MIN, INT_MIN, x);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*f\", INT_MAX, INT_MAX, x);   /* { dg-warning \"writing between 2147483649 and 2147483958 bytes\" } */\n+}\n+\n+void test_floating_g_cst (void)\n+{\n+  T (0, \"%*g\",  INT_MIN, 0.);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*g\",  INT_MAX, 0.);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*g\", INT_MIN, 0.);     /* { dg-warning \"writing 1 byte\" } */\n+\n+  T (0, \"%.*g\", INT_MAX, 0.);     /* { dg-warning \"writing 1 byte\" } */\n+\n+  T (0, \"%*.*g\", INT_MIN, INT_MIN, 0.);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*g\", INT_MAX, INT_MAX, 0.);   /* { dg-warning \"writing 2147483647 bytes\" } */\n+}\n+\n+void test_floating_g (double x)\n+{\n+  T (0, \"%*g\",  INT_MIN, x);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*g\",  INT_MAX, x);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*g\", INT_MIN, x);     /* { dg-warning \"writing between 1 and 13 bytes\" } */\n+\n+  T (0, \"%.*g\", INT_MAX, x);     /* { dg-warning \"writing between 1 and 310 bytes\" } */\n+\n+  T (0, \"%*.*g\", INT_MIN, INT_MIN, x);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*g\", INT_MAX, INT_MAX, x);   /* { dg-warning \"writing 2147483647 bytes\" } */\n+}\n+\n+void test_string_cst (void)\n+{\n+  T (0, \"%*s\",  INT_MIN, \"\");     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*s\",  INT_MAX, \"\");     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*s\", INT_MIN, \"\");     /* { dg-warning \"writing a terminating nul\" } */\n+\n+  T (0, \"%.*s\", INT_MAX, \"\");     /* { dg-warning \"writing a terminating nul\" } */\n+\n+  T (0, \"%*.*s\", INT_MIN, INT_MIN, \"\");   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*s\", INT_MAX, INT_MAX, \"\");   /* { dg-warning \"writing 2147483647 bytes\" } */\n+}\n+\n+void test_string_var (const char *s)\n+{\n+  T (0, \"%*s\",  INT_MIN, s);     /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*s\",  INT_MAX, s);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+\n+  T (0, \"%.*s\", INT_MIN, s);     /* { dg-warning \"writing a terminating nul\" } */\n+\n+  T (0, \"%.*s\", INT_MAX, s);     /* { dg-warning \"writing between 0 and 2147483647 bytes\" } */\n+\n+  T (0, \"%*.*s\", INT_MIN, INT_MIN, s);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+\n+  T (0, \"%*.*s\", INT_MAX, INT_MAX, s);   /* { dg-warning \"writing 2147483647 bytes\" } */\n+}"}]}