{"sha": "6be2e1f88c80e2cb686d02ac55a518b819900ead", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJlMmUxZjg4YzgwZTJjYjY4NmQwMmFjNTVhNTE4YjgxOTkwMGVhZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-24T05:57:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-24T05:57:02Z"}, "message": "stmt.c (parse_input_constraint): Break out from ...\n\n        * stmt.c (parse_input_constraint): Break out from ...\n        (expand_asm_operands): ... here.  Loop over the operands twice,\n        the first time only calling mark_addressable.  Correct and simplify\n        the conditions for spilling an output operand to memory.\n\nFrom-SVN: r48298", "tree": {"sha": "6d28189f6a9214baf767d7ebb5253187bfd875e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d28189f6a9214baf767d7ebb5253187bfd875e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6be2e1f88c80e2cb686d02ac55a518b819900ead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be2e1f88c80e2cb686d02ac55a518b819900ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be2e1f88c80e2cb686d02ac55a518b819900ead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be2e1f88c80e2cb686d02ac55a518b819900ead/comments", "author": null, "committer": null, "parents": [{"sha": "99407cf2f159e6b4a86135b0cb48e76a9cfaee05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99407cf2f159e6b4a86135b0cb48e76a9cfaee05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99407cf2f159e6b4a86135b0cb48e76a9cfaee05"}], "stats": {"total": 455, "additions": 260, "deletions": 195}, "files": [{"sha": "4996eb1346d71e6052799f4fc0809d171bd6e8bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be2e1f88c80e2cb686d02ac55a518b819900ead/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be2e1f88c80e2cb686d02ac55a518b819900ead/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6be2e1f88c80e2cb686d02ac55a518b819900ead", "patch": "@@ -1,3 +1,10 @@\n+2001-12-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* stmt.c (parse_input_constraint): Break out from ...\n+\t(expand_asm_operands): ... here.  Loop over the operands twice,\n+\tthe first time only calling mark_addressable.  Correct and simplify\n+\tthe conditions for spilling an output operand to memory.\n+\n 2001-12-23  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (call_operand) [OSF]: Disallow virtual regs.\n@@ -46,13 +53,13 @@\n \n 2001-12-22  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000.h (rs6000_builtins): Add vsldoi variants.\n+\t* config/rs6000/rs6000.h (rs6000_builtins): Add vsldoi variants.\n \n-        * config/rs6000/rs6000.md (\"altivec_vsldoi_*\"): Same.\n+\t* config/rs6000/rs6000.md (\"altivec_vsldoi_*\"): Same.\n \n-        * config/rs6000/rs6000.c: Clean up some spacing and indentation.\n-        (altivec_init_builtins): Add tree types for builtins with 4 bit\n-        literals.\n+\t* config/rs6000/rs6000.c: Clean up some spacing and indentation.\n+\t(altivec_init_builtins): Add tree types for builtins with 4 bit\n+\tliterals.\n \t(bdesc_3arg): Add vsldoi variants.\n \n 2001-12-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n@@ -248,16 +255,16 @@ Fri Dec 21 17:30:15 2001  Jeffrey A Law  (law@redhat.com)\n 2001-12-20  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* config/arm/arm.c (arm_compute_save_reg0_reg12_mask):  New\n-        function. Compute which of registers r0 through r12 should be\n+\tfunction. Compute which of registers r0 through r12 should be\n \tsaved onto the stack during a function's prologue.\n-        (arm_compute_save_reg_mask): Use\n-        arm_compute_save_reg0_reg12_mask.\n-        (arm_compute_initial_elimination_offset): Use\n-        arm_compute_save_reg0_reg12_mask.\n+\t(arm_compute_save_reg_mask): Use\n+\tarm_compute_save_reg0_reg12_mask.\n+\t(arm_compute_initial_elimination_offset): Use\n+\tarm_compute_save_reg0_reg12_mask.\n \n-        (arm_expand_prologue): Do not mark as save of the IP register\n-        for an interrupt handler as being part of the frame creation\n-        code.\n+\t(arm_expand_prologue): Do not mark as save of the IP register\n+\tfor an interrupt handler as being part of the frame creation\n+\tcode.\n \n 2001-12-20  Richard Henderson  <rth@redhat.com>\n \n@@ -320,30 +327,30 @@ Thu Dec 20 16:58:46 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n 2001-12-19  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * doc/install.texi: Add documentation for --enable-altivec.\n+\t* doc/install.texi: Add documentation for --enable-altivec.\n \n-        * config.gcc: Add support for --enable-altivec.\n+\t* config.gcc: Add support for --enable-altivec.\n \n-        * config/rs6000/altivec.h: New.\n+\t* config/rs6000/altivec.h: New.\n \n-        * config/rs6000/linuxaltivec.h (SUBSUBTARGET_OVERRIDE_OPTIONS):\n-        Define.  Fix typo.\n+\t* config/rs6000/linuxaltivec.h (SUBSUBTARGET_OVERRIDE_OPTIONS):\n+\tDefine.  Fix typo.\n \n-        * config/rs6000/rs6000.c (vrsave_operation): Change unspec to\n+\t* config/rs6000/rs6000.c (vrsave_operation): Change unspec to\n \tunspec_volatile.\n-        (generate_set_vrsave): Generate the unspec here instead of calling\n-        an .md pattern.\n-        (generate_set_vrsave): Use gen_rtvec.\n-        (rs6000_emit_prologue): Replace call to gen_get_vrsave with\n-        gen_rtx_SET.\n+\t(generate_set_vrsave): Generate the unspec here instead of calling\n+\tan .md pattern.\n+\t(generate_set_vrsave): Use gen_rtvec.\n+\t(rs6000_emit_prologue): Replace call to gen_get_vrsave with\n+\tgen_rtx_SET.\n \n-        * config/rs6000/rs6000.md (\"*movsi_internal1\"): Add constraints\n+\t* config/rs6000/rs6000.md (\"*movsi_internal1\"): Add constraints\n \tfor setting special registers.\n-        (\"*set_vrsave_internal\"): Use unspec_volatile.\n-        (\"set_vrsave\"): Remove.\n-        (\"get_vrsave\"): Remove.\n+\t(\"*set_vrsave_internal\"): Use unspec_volatile.\n+\t(\"set_vrsave\"): Remove.\n+\t(\"get_vrsave\"): Remove.\n \n-        * config/rs6000/rs6000.h (REG_CLASS_CONTENTS): Add vrsave to\n+\t* config/rs6000/rs6000.h (REG_CLASS_CONTENTS): Add vrsave to\n \tSPECIAL_REGS.\n \n 2001-12-19  Bruce Korb  <bkorb@gnu.org>"}, {"sha": "5682a26868cd142b575de33f084b58b0b3bb04d5", "filename": "gcc/stmt.c", "status": "modified", "additions": 214, "deletions": 166, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be2e1f88c80e2cb686d02ac55a518b819900ead/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be2e1f88c80e2cb686d02ac55a518b819900ead/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6be2e1f88c80e2cb686d02ac55a518b819900ead", "patch": "@@ -397,6 +397,9 @@ struct stmt_status\n static int using_eh_for_cleanups_p = 0;\n \n static int n_occurrences\t\tPARAMS ((int, const char *));\n+static bool parse_input_constraint\tPARAMS ((const char **, int, int, int,\n+\t\t\t\t\t\t int, const char * const *,\n+\t\t\t\t\t\t bool *, bool *));\n static void expand_goto_internal\tPARAMS ((tree, rtx, rtx));\n static int expand_fixup\t\t\tPARAMS ((tree, rtx, rtx));\n static rtx expand_nl_handler_label\tPARAMS ((rtx, rtx));\n@@ -1307,13 +1310,8 @@ expand_asm (body)\n    Returns TRUE if all went well; FALSE if an error occurred.  */\n \n bool\n-parse_output_constraint (constraint_p, \n-\t\t\t operand_num,\n-\t\t\t ninputs,\n-\t\t\t noutputs,\n-\t\t\t allows_mem, \n-\t\t\t allows_reg, \n-\t\t\t is_inout)\n+parse_output_constraint (constraint_p, operand_num, ninputs, noutputs,\n+\t\t\t allows_mem, allows_reg, is_inout)\n      const char **constraint_p;\n      int operand_num;\n      int ninputs;\n@@ -1444,6 +1442,131 @@ parse_output_constraint (constraint_p,\n   return true;\n }\n \n+/* Similar, but for input constraints.  */\n+\n+static bool\n+parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n+\t\t\tconstraints, allows_mem, allows_reg)\n+     const char **constraint_p;\n+     int input_num;\n+     int ninputs;\n+     int noutputs;\n+     int ninout;\n+     const char * const * constraints;\n+     bool *allows_mem;\n+     bool *allows_reg;\n+{\n+  const char *constraint = *constraint_p;\n+  const char *orig_constraint = constraint;\n+  size_t c_len = strlen (constraint);\n+  size_t j;\n+\n+  /* Assume the constraint doesn't allow the use of either\n+     a register or memory.  */\n+  *allows_mem = false;\n+  *allows_reg = false;\n+\n+  /* Make sure constraint has neither `=', `+', nor '&'.  */\n+\n+  for (j = 0; j < c_len; j++)\n+    switch (constraint[j])\n+      {\n+      case '+':  case '=':  case '&':\n+\tif (constraint == orig_constraint)\n+\t  {\n+\t    error (\"input operand constraint contains `%c'\", constraint[j]);\n+\t    return false;\n+\t  }\n+\tbreak;\n+\n+      case '%':\n+\tif (constraint == orig_constraint\n+\t    && input_num + 1 == ninputs - ninout)\n+\t  {\n+\t    error (\"`%%' constraint used with last operand\");\n+\t    return false;\n+\t  }\n+\tbreak;\n+\n+      case 'V':  case 'm':  case 'o':\n+\t*allows_mem = true;\n+\tbreak;\n+\n+      case '<':  case '>':\n+      case '?':  case '!':  case '*':  case '#':\n+      case 'E':  case 'F':  case 'G':  case 'H':\n+      case 's':  case 'i':  case 'n':\n+      case 'I':  case 'J':  case 'K':  case 'L':  case 'M':\n+      case 'N':  case 'O':  case 'P':  case ',':\n+\tbreak;\n+\n+\t/* Whether or not a numeric constraint allows a register is\n+\t   decided by the matching constraint, and so there is no need\n+\t   to do anything special with them.  We must handle them in\n+\t   the default case, so that we don't unnecessarily force\n+\t   operands to memory.  */\n+      case '0':  case '1':  case '2':  case '3':  case '4':\n+      case '5':  case '6':  case '7':  case '8':  case '9':\n+\t{\n+\t  char *end;\n+\t  unsigned long match;\n+\n+\t  match = strtoul (constraint + j, &end, 10);\n+\t  if (match >= (unsigned long) noutputs)\n+\t    {\n+\t      error (\"matching constraint references invalid operand number\");\n+\t      return false;\n+\t    }\n+\n+\t  /* Try and find the real constraint for this dup.  Only do this\n+\t     if the matching constraint is the only alternative.  */\n+\t  if (*end == '\\0'\n+\t      && (j == 0 || (j == 1 && constraint[0] == '%')))\n+\t    {\n+\t      constraint = constraints[match];\n+\t      *constraint_p = constraint;\n+\t      c_len = strlen (constraint);\n+\t      j = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    j = end - constraint;\n+\t}\n+\t/* Fall through.  */\n+\n+      case 'p':  case 'r':\n+\t*allows_reg = true;\n+\tbreak;\n+\n+      case 'g':  case 'X':\n+\t*allows_reg = true;\n+\t*allows_mem = true;\n+\tbreak;\n+\n+      default:\n+\tif (! ISALPHA (constraint[j]))\n+\t  {\n+\t    error (\"invalid punctuation `%c' in constraint\", constraint[j]);\n+\t    return false;\n+\t  }\n+\tif (REG_CLASS_FROM_LETTER (constraint[j]) != NO_REGS)\n+\t  *allows_reg = true;\n+#ifdef EXTRA_CONSTRAINT\n+\telse\n+\t  {\n+\t    /* Otherwise we can't assume anything about the nature of\n+\t       the constraint except that it isn't purely registers.\n+\t       Treat it like \"g\" and hope for the best.  */\n+\t    *allows_reg = true;\n+\t    *allows_mem = true;\n+\t  }\n+#endif\n+\tbreak;\n+      }\n+\n+  return true;\n+}\n+\n /* Generate RTL for an asm statement with arguments.\n    STRING is the instruction template.\n    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.\n@@ -1472,7 +1595,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   rtx body;\n   int ninputs = list_length (inputs);\n   int noutputs = list_length (outputs);\n-  int ninout = 0;\n+  int ninout;\n   int nclobbers;\n   tree tail;\n   int i;\n@@ -1524,10 +1647,15 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n   last_expr_type = 0;\n \n+  /* First pass over inputs and outputs checks validity and sets\n+     mark_addressable if needed.  */\n+\n+  ninout = 0;\n   for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n     {\n       tree val = TREE_VALUE (tail);\n       tree type = TREE_TYPE (val);\n+      const char *constraint;\n       bool is_inout;\n       bool allows_reg;\n       bool allows_mem;\n@@ -1536,22 +1664,67 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       if (type == error_mark_node)\n \treturn;\n \n-      /* Make sure constraint has `=' and does not have `+'.  Also, see\n-\t if it allows any register.  Be liberal on the latter test, since\n-\t the worst that happens if we get it wrong is we issue an error\n-\t message.  */\n-\n       /* Try to parse the output constraint.  If that fails, there's\n \t no point in going further.  */\n-      if (!parse_output_constraint (&constraints[i],\n-\t\t\t\t    i,\n-\t\t\t\t    ninputs,\n-\t\t\t\t    noutputs,\n-\t\t\t\t    &allows_mem,\n-\t\t\t\t    &allows_reg,\n-\t\t\t\t    &is_inout))\n+      constraint = constraints[i];\n+      if (!parse_output_constraint (&constraint, i, ninputs, noutputs,\n+\t\t\t\t    &allows_mem, &allows_reg, &is_inout))\n+\treturn;\n+\n+      if (! allows_reg\n+\t  && (allows_mem\n+\t      || is_inout\n+\t      || (DECL_P (val)\n+\t\t  && GET_CODE (DECL_RTL (val)) == REG\n+\t\t  && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type))))\n+\tmark_addressable (val);\n+\n+      if (is_inout)\n+\tninout++;\n+    }\n+\n+  ninputs += ninout;\n+  if (ninputs + noutputs > MAX_RECOG_OPERANDS)\n+    {\n+      error (\"more than %d operands in `asm'\", MAX_RECOG_OPERANDS);\n+      return;\n+    }\n+\n+  for (i = 0, tail = inputs; tail; i++, tail = TREE_CHAIN (tail))\n+    {\n+      bool allows_reg, allows_mem;\n+      const char *constraint;\n+\n+      /* If there's an erroneous arg, emit no insn, because the ASM_INPUT\n+\t would get VOIDmode and that could cause a crash in reload.  */\n+      if (TREE_TYPE (TREE_VALUE (tail)) == error_mark_node)\n \treturn;\n \n+      constraint = constraints[i + noutputs];\n+      if (! parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n+\t\t\t\t    constraints, &allows_mem, &allows_reg))\n+\treturn;\n+\n+      if (! allows_reg && allows_mem)\n+\tmark_addressable (TREE_VALUE (tail));\n+    }\n+\n+  /* Second pass evaluates arguments.  */\n+\n+  ninout = 0;\n+  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+    {\n+      tree val = TREE_VALUE (tail);\n+      tree type = TREE_TYPE (val);\n+      bool is_inout;\n+      bool allows_reg;\n+      bool allows_mem;\n+\n+      if (!parse_output_constraint (&constraints[i], i, ninputs,\n+\t\t\t\t    noutputs, &allows_mem, &allows_reg,\n+\t\t\t\t    &is_inout))\n+\tabort ();\n+\n       /* If an output operand is not a decl or indirect ref and our constraint\n \t allows a register, make a temporary to act as an intermediate.\n \t Make the asm insn write into that, then our caller will copy it to\n@@ -1569,12 +1742,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  || ! allows_reg\n \t  || is_inout)\n \t{\n-\t  if (! allows_reg)\n-\t    mark_addressable (TREE_VALUE (tail));\n-\n-\t  output_rtx[i]\n-\t    = expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode,\n-\t\t\t   EXPAND_WRITE);\n+\t  output_rtx[i] = expand_expr (val, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n \t  if (! allows_reg && GET_CODE (output_rtx[i]) != MEM)\n \t    error (\"output number %d not directly addressable\", i);\n@@ -1597,18 +1765,11 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n       if (is_inout)\n \t{\n-\t  inout_mode[ninout] = TYPE_MODE (TREE_TYPE (TREE_VALUE (tail)));\n+\t  inout_mode[ninout] = TYPE_MODE (type);\n \t  inout_opnum[ninout++] = i;\n \t}\n     }\n \n-  ninputs += ninout;\n-  if (ninputs + noutputs > MAX_RECOG_OPERANDS)\n-    {\n-      error (\"more than %d operands in `asm'\", MAX_RECOG_OPERANDS);\n-      return;\n-    }\n-\n   /* Make vectors for the expression-rtx, constraint strings,\n      and named operands.  */\n \n@@ -1628,154 +1789,40 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n   for (i = 0, tail = inputs; tail; tail = TREE_CHAIN (tail), ++i)\n     {\n-      int j;\n-      int allows_reg = 0, allows_mem = 0;\n-      const char *constraint, *orig_constraint;\n-      int c_len;\n+      bool allows_reg, allows_mem;\n+      const char *constraint;\n+      tree val, type;\n       rtx op;\n \n-      /* If there's an erroneous arg, emit no insn,\n-\t because the ASM_INPUT would get VOIDmode\n-\t and that could cause a crash in reload.  */\n-      if (TREE_TYPE (TREE_VALUE (tail)) == error_mark_node)\n-\treturn;\n-\n-      /* ??? Can this happen, and does the error message make any sense? */\n-      if (TREE_PURPOSE (tail) == NULL_TREE)\n-\t{\n-\t  error (\"hard register `%s' listed as input operand to `asm'\",\n-\t\t TREE_STRING_POINTER (TREE_VALUE (tail)) );\n-\t  return;\n-\t}\n-\n-      orig_constraint = constraint = constraints[i + noutputs];\n-      c_len = strlen (constraint);\n-\n-      /* Make sure constraint has neither `=', `+', nor '&'.  */\n-\n-      for (j = 0; j < c_len; j++)\n-\tswitch (constraint[j])\n-\t  {\n-\t  case '+':  case '=':  case '&':\n-\t    if (constraint == orig_constraint)\n-\t      {\n-\t        error (\"input operand constraint contains `%c'\",\n-\t\t       constraint[j]);\n-\t        return;\n-\t      }\n-\t    break;\n-\n-\t  case '%':\n-\t    if (constraint == orig_constraint\n-\t\t&& i + 1 == ninputs - ninout)\n-\t      {\n-\t\terror (\"`%%' constraint used with last operand\");\n-\t\treturn;\n-\t      }\n-\t    break;\n-\n-\t  case 'V':  case 'm':  case 'o':\n-\t    allows_mem = 1;\n-\t    break;\n-\n-\t  case '<':  case '>':\n-\t  case '?':  case '!':  case '*':  case '#':\n-\t  case 'E':  case 'F':  case 'G':  case 'H':\n-\t  case 's':  case 'i':  case 'n':\n-\t  case 'I':  case 'J':  case 'K':  case 'L':  case 'M':\n-\t  case 'N':  case 'O':  case 'P':  case ',':\n-\t    break;\n-\n-\t    /* Whether or not a numeric constraint allows a register is\n-\t       decided by the matching constraint, and so there is no need\n-\t       to do anything special with them.  We must handle them in\n-\t       the default case, so that we don't unnecessarily force\n-\t       operands to memory.  */\n-\t  case '0':  case '1':  case '2':  case '3':  case '4':\n-\t  case '5':  case '6':  case '7':  case '8':  case '9':\n-\t    {\n-\t      char *end;\n-\t      unsigned long match;\n-\n-\t      match = strtoul (constraint + j, &end, 10);\n-\t      if (match >= (unsigned long) noutputs)\n-\t\t{\n-\t\t  error (\"matching constraint references invalid operand number\");\n-\t\t  return;\n-\t\t}\n-\n-\t      /* Try and find the real constraint for this dup.  Only do\n-\t         this if the matching constraint is the only alternative.  */\n-\t      if (*end == '\\0'\n-\t\t  && (j == 0 || (j == 1 && constraint[0] == '%')))\n-\t\t{\n-\t\t  constraint = constraints[match];\n-\t\t  c_len = strlen (constraint);\n-\t\t  j = 0;\n-\t          break;\n-\t\t}\n-\t      else\n-\t\tj = end - constraint;\n-\t    }\n-\t    /* Fall through.  */\n-\n-\t  case 'p':  case 'r':\n-\t    allows_reg = 1;\n-\t    break;\n-\n-\t  case 'g':  case 'X':\n-\t    allows_reg = 1;\n-\t    allows_mem = 1;\n-\t    break;\n-\n-\t  default:\n-\t    if (! ISALPHA (constraint[j]))\n-\t      {\n-\t\terror (\"invalid punctuation `%c' in constraint\",\n-\t\t       constraint[j]);\n-\t\treturn;\n-\t      }\n-\t    if (REG_CLASS_FROM_LETTER (constraint[j]) != NO_REGS)\n-\t      allows_reg = 1;\n-#ifdef EXTRA_CONSTRAINT\n-\t    else\n-\t      {\n-\t\t/* Otherwise we can't assume anything about the nature of\n-\t\t   the constraint except that it isn't purely registers.\n-\t\t   Treat it like \"g\" and hope for the best.  */\n-\t\tallows_reg = 1;\n-\t\tallows_mem = 1;\n-\t      }\n-#endif\n-\t    break;\n-\t  }\n+      constraint = constraints[i + noutputs];\n+      if (! parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n+\t\t\t\t    constraints, &allows_mem, &allows_reg))\n+\tabort ();\n \n-      if (! allows_reg && allows_mem)\n-\tmark_addressable (TREE_VALUE (tail));\n+      generating_concat_p = 0;\n \n-      op = expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);\n+      val = TREE_VALUE (tail);\n+      type = TREE_TYPE (val);\n+      op = expand_expr (val, NULL_RTX, VOIDmode, 0);\n \n       /* Never pass a CONCAT to an ASM.  */\n-      generating_concat_p = 0;\n       if (GET_CODE (op) == CONCAT)\n \top = force_reg (GET_MODE (op), op);\n \n       if (asm_operand_ok (op, constraint) <= 0)\n \t{\n \t  if (allows_reg)\n-\t    op = force_reg (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))), op);\n+\t    op = force_reg (TYPE_MODE (type), op);\n \t  else if (!allows_mem)\n \t    warning (\"asm operand %d probably doesn't match constraints\",\n \t\t     i + noutputs);\n \t  else if (CONSTANT_P (op))\n-\t    op = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n-\t\t\t\t  op);\n+\t    op = force_const_mem (TYPE_MODE (type), op);\n \t  else if (GET_CODE (op) == REG\n \t\t   || GET_CODE (op) == SUBREG\n \t\t   || GET_CODE (op) == ADDRESSOF\n \t\t   || GET_CODE (op) == CONCAT)\n \t    {\n-\t      tree type = TREE_TYPE (TREE_VALUE (tail));\n \t      tree qual_type = build_qualified_type (type,\n \t\t\t\t\t\t     (TYPE_QUALS (type)\n \t\t\t\t\t\t      | TYPE_QUAL_CONST));\n@@ -1786,9 +1833,10 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    }\n \n \t  else if (GET_CODE (op) == MEM && MEM_VOLATILE_P (op))\n-\t    /* We won't recognize volatile memory as available a\n-\t       memory_operand at this point.  Ignore it.  */\n-\t    ;\n+\t    {\n+\t      /* We won't recognize volatile memory as available a\n+\t\t memory_operand at this point.  Ignore it.  */\n+\t    }\n \t  else if (queued_subexp_p (op))\n \t    ;\n \t  else\n@@ -1798,12 +1846,12 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    warning (\"asm operand %d probably doesn't match constraints\",\n \t\t     i + noutputs);\n \t}\n+\n       generating_concat_p = old_generating_concat_p;\n       ASM_OPERANDS_INPUT (body, i) = op;\n \n       ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, i)\n-\t= gen_rtx_ASM_INPUT (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n-\t\t\t     orig_constraint);\n+\t= gen_rtx_ASM_INPUT (TYPE_MODE (type), constraints[i + noutputs]);\n     }\n \n   /* Protect all the operands from the queue now that they have all been"}, {"sha": "ffc5ac419ea43a1f56b9d08d5992928e0db56a55", "filename": "gcc/testsuite/gcc.c-torture/compile/20011205-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be2e1f88c80e2cb686d02ac55a518b819900ead/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011205-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be2e1f88c80e2cb686d02ac55a518b819900ead/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011205-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011205-1.c?ref=6be2e1f88c80e2cb686d02ac55a518b819900ead", "patch": "@@ -0,0 +1,10 @@\n+/* Failure to mark_addressable all operands before evaluation means we\n+   don't set up the proper temporaries, which leaves us with an asm that\n+   doesn't match its contraints.  */\n+\n+long foo()\n+{\n+  long x;\n+  asm(\"\" : \"=r\"(x) : \"m\"(x));\n+  return x;\n+}"}]}