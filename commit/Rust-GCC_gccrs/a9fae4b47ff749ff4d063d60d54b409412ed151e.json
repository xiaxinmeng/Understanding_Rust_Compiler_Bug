{"sha": "a9fae4b47ff749ff4d063d60d54b409412ed151e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlmYWU0YjQ3ZmY3NDlmZjRkMDYzZDYwZDU0YjQwOTQxMmVkMTUxZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-06-04T07:52:51Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-06-04T07:52:51Z"}, "message": "IPA ICF: rewrite references into a hash_map.\n\n2019-06-04  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-icf.h (struct sem_usage_pair_hash): New.\n\t(sem_usage_pair_hash::hash): Likewise.\n\t(sem_usage_pair_hash::equal): Likewise.\n\t(struct sem_usage_hash): Likewise.\n\t* ipa-icf.c (sem_item::sem_item): Initialize\n\treferenced_by_count.\n\t(sem_item::add_reference): Register a reference\n\tin ref_map and not in target->usages.\n\t(sem_item::setup): Remove initialization of\n\tdead vectors.\n\t(sem_item::~sem_item): Remove usage of dead vectors.\n\t(sem_item::dump): Remove dump of references.\n\t(sem_item_optimizer::sem_item_optimizer): Initialize\n\tm_references.\n\t(sem_item_optimizer::read_section): Remove useless\n\tdump.\n\t(sem_item_optimizer::parse_funcs_and_vars): Likewise here.\n\t(sem_item_optimizer::build_graph): Pass m_references\n\tto ::add_reference.\n\t(sem_item_optimizer::verify_classes): Remove usage of dead\n\tvectors.\n\t(sem_item_optimizer::traverse_congruence_split): Return true\n\twhen a class is split.\n\t(sem_item_optimizer::do_congruence_step_for_index): Use\n\thash_map for look up of (sem_item *, index). That brings\n\tsignificant speed up.\n\t(sem_item_optimizer::do_congruence_step): Return true\n\twhen a split is done.\n\t(congruence_class::is_class_used): Use referenced_by_count.\n2019-06-04  Martin Liska  <mliska@suse.cz>\n\n\t* c-c++-common/goacc/acc-icf.c: Change scanned pattern.\n\t* gfortran.dg/goacc/pr78027.f90: Likewise.\n\nFrom-SVN: r271900", "tree": {"sha": "caea9ae53d79fc99978fc3134f0a70780cfbf61a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caea9ae53d79fc99978fc3134f0a70780cfbf61a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9fae4b47ff749ff4d063d60d54b409412ed151e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9fae4b47ff749ff4d063d60d54b409412ed151e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9fae4b47ff749ff4d063d60d54b409412ed151e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9fae4b47ff749ff4d063d60d54b409412ed151e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "498be9cd4691055ac6d708aa946be4c794322d2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498be9cd4691055ac6d708aa946be4c794322d2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498be9cd4691055ac6d708aa946be4c794322d2d"}], "stats": {"total": 194, "additions": 117, "deletions": 77}, "files": [{"sha": "8fbeb6eb1fb560accbb7822e3e713fd4a20113e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9fae4b47ff749ff4d063d60d54b409412ed151e", "patch": "@@ -1,3 +1,35 @@\n+2019-06-04  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-icf.h (struct sem_usage_pair_hash): New.\n+\t(sem_usage_pair_hash::hash): Likewise.\n+\t(sem_usage_pair_hash::equal): Likewise.\n+\t(struct sem_usage_hash): Likewise.\n+\t* ipa-icf.c (sem_item::sem_item): Initialize\n+\treferenced_by_count.\n+\t(sem_item::add_reference): Register a reference\n+\tin ref_map and not in target->usages.\n+\t(sem_item::setup): Remove initialization of\n+\tdead vectors.\n+\t(sem_item::~sem_item): Remove usage of dead vectors.\n+\t(sem_item::dump): Remove dump of references.\n+\t(sem_item_optimizer::sem_item_optimizer): Initialize\n+\tm_references.\n+\t(sem_item_optimizer::read_section): Remove useless\n+\tdump.\n+\t(sem_item_optimizer::parse_funcs_and_vars): Likewise here.\n+\t(sem_item_optimizer::build_graph): Pass m_references\n+\tto ::add_reference.\n+\t(sem_item_optimizer::verify_classes): Remove usage of dead\n+\tvectors.\n+\t(sem_item_optimizer::traverse_congruence_split): Return true\n+\twhen a class is split.\n+\t(sem_item_optimizer::do_congruence_step_for_index): Use\n+\thash_map for look up of (sem_item *, index). That brings\n+\tsignificant speed up.\n+\t(sem_item_optimizer::do_congruence_step): Return true\n+\twhen a split is done.\n+\t(congruence_class::is_class_used): Use referenced_by_count.\n+\n 2019-06-04  Alan Modra  <amodra@gmail.com>\n \n \tPR target/90689"}, {"sha": "9f1e2c8f38e4a99600359694efa6b61554fa5260", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 41, "deletions": 63, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=a9fae4b47ff749ff4d063d60d54b409412ed151e", "patch": "@@ -138,14 +138,15 @@ sem_usage_pair::sem_usage_pair (sem_item *_item, unsigned int _index)\n }\n \n sem_item::sem_item (sem_item_type _type, bitmap_obstack *stack)\n-: type (_type), m_hash (-1), m_hash_set (false)\n+: type (_type), referenced_by_count (0), m_hash (-1), m_hash_set (false)\n {\n   setup (stack);\n }\n \n sem_item::sem_item (sem_item_type _type, symtab_node *_node,\n \t\t    bitmap_obstack *stack)\n-: type (_type), node (_node), m_hash (-1), m_hash_set (false)\n+: type (_type), node (_node), referenced_by_count (0), m_hash (-1),\n+  m_hash_set (false)\n {\n   decl = node->decl;\n   setup (stack);\n@@ -154,13 +155,18 @@ sem_item::sem_item (sem_item_type _type, symtab_node *_node,\n /* Add reference to a semantic TARGET.  */\n \n void\n-sem_item::add_reference (sem_item *target)\n+sem_item::add_reference (ref_map *refs,\n+\t\t\t sem_item *target)\n {\n-  refs.safe_push (target);\n-  unsigned index = refs.length ();\n-  target->usages.safe_push (new sem_usage_pair(this, index));\n+  unsigned index = reference_count++;\n+  bool existed;\n+\n+  vec<sem_item *> &v\n+    = refs->get_or_insert (new sem_usage_pair (target, index), &existed);\n+  v.safe_push (this);\n   bitmap_set_bit (target->usage_index_bitmap, index);\n   refs_set.add (target->node);\n+  ++target->referenced_by_count;\n }\n \n /* Initialize internal data structures. Bitmap STACK is used for\n@@ -171,20 +177,14 @@ sem_item::setup (bitmap_obstack *stack)\n {\n   gcc_checking_assert (node);\n \n-  refs.create (0);\n+  reference_count = 0;\n   tree_refs.create (0);\n-  usages.create (0);\n   usage_index_bitmap = BITMAP_ALLOC (stack);\n }\n \n sem_item::~sem_item ()\n {\n-  for (unsigned i = 0; i < usages.length (); i++)\n-    delete usages[i];\n-\n-  refs.release ();\n   tree_refs.release ();\n-  usages.release ();\n \n   BITMAP_FREE (usage_index_bitmap);\n }\n@@ -199,13 +199,6 @@ sem_item::dump (void)\n       fprintf (dump_file, \"[%s] %s (tree:%p)\\n\", type == FUNC ? \"func\" : \"var\",\n \t       node->dump_name (), (void *) node->decl);\n       fprintf (dump_file, \"  hash: %u\\n\", get_hash ());\n-      fprintf (dump_file, \"  references: \");\n-\n-      for (unsigned i = 0; i < refs.length (); i++)\n-\tfprintf (dump_file, \"%s%s \", refs[i]->node->name (),\n-\t\t i < refs.length() - 1 ? \",\" : \"\");\n-\n-      fprintf (dump_file, \"\\n\");\n     }\n }\n \n@@ -2230,7 +2223,7 @@ unsigned int sem_item_optimizer::class_id = 0;\n \n sem_item_optimizer::sem_item_optimizer ()\n : worklist (0), m_classes (0), m_classes_count (0), m_cgraph_node_hooks (NULL),\n-  m_varpool_node_hooks (NULL), m_merged_variables ()\n+  m_varpool_node_hooks (NULL), m_merged_variables (), m_references ()\n {\n   m_items.create (0);\n   bitmap_obstack_initialize (&m_bmstack);\n@@ -2341,13 +2334,8 @@ sem_item_optimizer::read_section (lto_file_decl_data *file_data,\n       node = lto_symtab_encoder_deref (encoder, index);\n \n       hashval_t hash = streamer_read_uhwi (&ib_main);\n-\n       gcc_assert (node->definition);\n \n-      if (dump_file)\n-\tfprintf (dump_file, \"Symbol added: %s (tree: %p)\\n\",\n-\t\t node->dump_asm_name (), (void *) node->decl);\n-\n       if (is_a<cgraph_node *> (node))\n \t{\n \t  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n@@ -2611,15 +2599,7 @@ sem_item_optimizer::parse_funcs_and_vars (void)\n \t{\n \t  m_items.safe_push (f);\n \t  m_symtab_node_map.put (cnode, f);\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Parsed function:%s\\n\", f->node->asm_name ());\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    f->dump_to_file (dump_file);\n \t}\n-      else if (dump_file)\n-\tfprintf (dump_file, \"Not parsed function:%s\\n\", cnode->asm_name ());\n     }\n \n   varpool_node *vnode;\n@@ -2745,7 +2725,7 @@ sem_item_optimizer::build_graph (void)\n \t      sem_item **slot = m_symtab_node_map.get\n \t\t(e->callee->ultimate_alias_target ());\n \t      if (slot)\n-\t\titem->add_reference (*slot);\n+\t\titem->add_reference (&m_references, *slot);\n \n \t      e = e->next_callee;\n \t    }\n@@ -2757,7 +2737,7 @@ sem_item_optimizer::build_graph (void)\n \t  sem_item **slot = m_symtab_node_map.get\n \t    (ref->referred->ultimate_alias_target ());\n \t  if (slot)\n-\t    item->add_reference (*slot);\n+\t    item->add_reference (&m_references, *slot);\n \t}\n     }\n }\n@@ -2987,13 +2967,6 @@ sem_item_optimizer::verify_classes (void)\n \n \t      gcc_assert (item);\n \t      gcc_assert (item->cls == cls);\n-\n-\t      for (unsigned k = 0; k < item->usages.length (); k++)\n-\t\t{\n-\t\t  sem_usage_pair *usage = item->usages[k];\n-\t\t  gcc_assert (usage->item->index_in_class\n-\t\t\t      < usage->item->cls->members.length ());\n-\t\t}\n \t    }\n \t}\n     }\n@@ -3106,10 +3079,11 @@ sem_item_optimizer::traverse_congruence_split (congruence_class * const &cls,\n       /* Release class if not presented in work list.  */\n       if (!in_worklist)\n \tdelete cls;\n-    }\n \n+      return true;\n+    }\n \n-  return true;\n+  return false;\n }\n \n /* Compare function for sorting pairs in do_congruence_step_f.  */\n@@ -3131,7 +3105,7 @@ sem_item_optimizer::sort_congruence_split (const void *a_, const void *b_)\n /* Tests if a class CLS used as INDEXth splits any congruence classes.\n    Bitmap stack BMSTACK is used for bitmap allocation.  */\n \n-void\n+bool\n sem_item_optimizer::do_congruence_step_for_index (congruence_class *cls,\n \t\t\t\t\t\t  unsigned int index)\n {\n@@ -3140,31 +3114,32 @@ sem_item_optimizer::do_congruence_step_for_index (congruence_class *cls,\n   for (unsigned int i = 0; i < cls->members.length (); i++)\n     {\n       sem_item *item = cls->members[i];\n+      sem_usage_pair needle (item, index);\n+      vec<sem_item *> *callers = m_references.get (&needle);\n+      if (callers == NULL)\n+\tcontinue;\n \n-      /* Iterate all usages that have INDEX as usage of the item.  */\n-      for (unsigned int j = 0; j < item->usages.length (); j++)\n+      for (unsigned int j = 0; j < callers->length (); j++)\n \t{\n-\t  sem_usage_pair *usage = item->usages[j];\n-\n-\t  if (usage->index != index)\n+\t  sem_item *caller = (*callers)[j];\n+\t  if (caller->cls->members.length () < 2)\n \t    continue;\n-\n-\t  bitmap *slot = split_map.get (usage->item->cls);\n+\t  bitmap *slot = split_map.get (caller->cls);\n \t  bitmap b;\n \n \t  if(!slot)\n \t    {\n \t      b = BITMAP_ALLOC (&m_bmstack);\n-\t      split_map.put (usage->item->cls, b);\n+\t      split_map.put (caller->cls, b);\n \t    }\n \t  else\n \t    b = *slot;\n \n-\t  gcc_checking_assert (usage->item->cls);\n-\t  gcc_checking_assert (usage->item->index_in_class\n-\t\t\t       < usage->item->cls->members.length ());\n+\t  gcc_checking_assert (caller->cls);\n+\t  gcc_checking_assert (caller->index_in_class\n+\t\t\t       < caller->cls->members.length ());\n \n-\t  bitmap_set_bit (b, usage->item->index_in_class);\n+\t  bitmap_set_bit (b, caller->index_in_class);\n \t}\n     }\n \n@@ -3180,12 +3155,16 @@ sem_item_optimizer::do_congruence_step_for_index (congruence_class *cls,\n   pair.cls = cls;\n \n   splitter_class_removed = false;\n+  bool r = false;\n   for (unsigned i = 0; i < to_split.length (); ++i)\n-    traverse_congruence_split (to_split[i].first, to_split[i].second, &pair);\n+    r |= traverse_congruence_split (to_split[i].first, to_split[i].second,\n+\t\t\t\t    &pair);\n \n   /* Bitmap clean-up.  */\n   split_map.traverse <traverse_split_pair *,\n \t\t      sem_item_optimizer::release_split_map> (NULL);\n+\n+  return r;\n }\n \n /* Every usage of a congruence class CLS is a candidate that can split the\n@@ -3206,9 +3185,8 @@ sem_item_optimizer::do_congruence_step (congruence_class *cls)\n   EXECUTE_IF_SET_IN_BITMAP (usage, 0, i, bi)\n   {\n     if (dump_file && (dump_flags & TDF_DETAILS))\n-      fprintf (dump_file, \"  processing congruence step for class: %u, \"\n-\t       \"index: %u\\n\", cls->id, i);\n-\n+      fprintf (dump_file, \"  processing congruence step for class: %u \"\n+\t       \"(%u items), index: %u\\n\", cls->id, cls->members.length (), i);\n     do_congruence_step_for_index (cls, i);\n \n     if (splitter_class_removed)\n@@ -3648,7 +3626,7 @@ bool\n congruence_class::is_class_used (void)\n {\n   for (unsigned int i = 0; i < members.length (); i++)\n-    if (members[i]->usages.length ())\n+    if (members[i]->referenced_by_count)\n       return true;\n \n   return false;"}, {"sha": "ede4c94dbd377bdb83d3a82143b6b4370e0fa403", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=a9fae4b47ff749ff4d063d60d54b409412ed151e", "patch": "@@ -126,7 +126,6 @@ struct symbol_compare_hash : nofree_ptr_hash <symbol_compare_collection>\n   }\n };\n \n-\n /* Semantic item usage pair.  */\n class sem_usage_pair\n {\n@@ -141,6 +140,32 @@ class sem_usage_pair\n   unsigned int index;\n };\n \n+struct sem_usage_pair_hash : pointer_hash <sem_usage_pair>\n+{\n+  static inline hashval_t hash (sem_usage_pair *);\n+  static inline bool equal (sem_usage_pair *, sem_usage_pair *);\n+};\n+\n+inline hashval_t\n+sem_usage_pair_hash::hash (sem_usage_pair *pair)\n+{\n+  inchash::hash hstate;\n+\n+  hstate.add_ptr (pair->item);\n+  hstate.add_int (pair->index);\n+\n+  return hstate.end ();\n+}\n+\n+inline bool\n+sem_usage_pair_hash::equal (sem_usage_pair *p1, sem_usage_pair *p2)\n+{\n+  return p1->item == p2->item && p1->index == p2->index;\n+}\n+\n+struct sem_usage_hash : sem_usage_pair_hash, typed_delete_remove <sem_usage_pair> {};\n+typedef hash_map<sem_usage_hash, auto_vec<sem_item *> > ref_map;\n+\n typedef std::pair<symtab_node *, symtab_node *> symtab_pair;\n \n /* Semantic item is a base class that encapsulates all shared functionality\n@@ -168,7 +193,7 @@ class sem_item\n   virtual void init (void) = 0;\n \n   /* Add reference to a semantic TARGET.  */\n-  void add_reference (sem_item *target);\n+  void add_reference (ref_map *map, sem_item *target);\n \n   /* Fast equality function based on knowledge known in WPA.  */\n   virtual bool equals_wpa (sem_item *item,\n@@ -216,18 +241,16 @@ class sem_item\n   /* Declaration tree node.  */\n   tree decl;\n \n-  /* Semantic references used that generate congruence groups.  */\n-  vec <sem_item *> refs;\n+  /* Number of references to a semantic symbols (function calls,\n+     variable references).  */\n+  unsigned reference_count;\n \n   /* Pointer to a congruence class the item belongs to.  */\n   congruence_class *cls;\n \n   /* Index of the item in a class belonging to.  */\n   unsigned int index_in_class;\n \n-  /* List of semantic items where the instance is used.  */\n-  vec <sem_usage_pair *> usages;\n-\n   /* A bitmap with indices of all classes referencing this item.  */\n   bitmap usage_index_bitmap;\n \n@@ -239,6 +262,9 @@ class sem_item\n \n   /* Temporary hash used where hash values of references are added.  */\n   hashval_t global_hash;\n+\n+  /* Number of references to this symbol.  */\n+  unsigned referenced_by_count;\n protected:\n   /* Cached, once calculated hash for the item.  */\n \n@@ -581,7 +607,7 @@ class sem_item_optimizer\n \n   /* Tests if a class CLS used as INDEXth splits any congruence classes.\n      Bitmap stack BMSTACK is used for bitmap allocation.  */\n-  void do_congruence_step_for_index (congruence_class *cls, unsigned int index);\n+  bool do_congruence_step_for_index (congruence_class *cls, unsigned int index);\n \n   /* Makes pairing between a congruence class CLS and semantic ITEM.  */\n   static void add_item_to_class (congruence_class *cls, sem_item *item);\n@@ -644,6 +670,9 @@ class sem_item_optimizer\n   /* Vector of merged variables.  Needed for fixup of points-to-analysis\n      info.  */\n   vec <symtab_pair> m_merged_variables;\n+\n+  /* Hash map will all references.  */\n+  ref_map m_references;\n }; // class sem_item_optimizer\n \n } // ipa_icf namespace"}, {"sha": "94dad4bd3bd1752b092893da1a2a585abba636e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a9fae4b47ff749ff4d063d60d54b409412ed151e", "patch": "@@ -1,3 +1,8 @@\n+2019-06-04  Martin Liska  <mliska@suse.cz>\n+\n+\t* c-c++-common/goacc/acc-icf.c: Change scanned pattern.\n+\t* gfortran.dg/goacc/pr78027.f90: Likewise.\n+\n 2019-06-03  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* gcc.target/powerpc/mmfpgpr.c: Delete."}, {"sha": "53d5dcfe85be0092fc903ad42077c96696dd0eac", "filename": "gcc/testsuite/c-c++-common/goacc/acc-icf.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc-icf.c?ref=a9fae4b47ff749ff4d063d60d54b409412ed151e", "patch": "@@ -44,6 +44,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump-times \"Not parsed function:\" 4 \"icf\" } }  */\n-/* { dg-final { scan-ipa-dump \"Parsed function:main\" \"icf\" } }  */\n-\n+/* { dg-final { scan-ipa-dump-times \"With total: 1 items\" 5 \"icf\" } }  */"}, {"sha": "52e5662be47e48d968cb21cb34ab9a473bac5ac5", "filename": "gcc/testsuite/gfortran.dg/goacc/pr78027.f90", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpr78027.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9fae4b47ff749ff4d063d60d54b409412ed151e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpr78027.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpr78027.f90?ref=a9fae4b47ff749ff4d063d60d54b409412ed151e", "patch": "@@ -19,6 +19,4 @@ real function f()\n    !$acc end parallel\n  end\n  \n-! { dg-final { scan-ipa-dump \"Not parsed function:f_._omp_fn.1\" \"icf\" } }\n-! { dg-final { scan-ipa-dump \"Not parsed function:f_._omp_fn.0\" \"icf\" } }\n-! { dg-final { scan-ipa-dump \"Not parsed function:f_\" \"icf\" } }\n+! { dg-final { scan-ipa-dump-times \"With total: 0 items\" 5 \"icf\" } }"}]}