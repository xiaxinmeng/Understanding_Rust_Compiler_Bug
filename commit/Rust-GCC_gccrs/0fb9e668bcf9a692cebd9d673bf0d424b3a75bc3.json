{"sha": "0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZiOWU2NjhiY2Y5YTY5MmNlYmQ5ZDY3M2JmMGQ0MjRiM2E3NWJjMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2018-07-27T22:13:36Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-07-27T22:13:36Z"}, "message": "constraints.md (wG constraint): Delete, no longer used.\n\n2018-07-27  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/constraints.md (wG constraint): Delete, no longer\n\tused.\n\t* config/rs6000/predicates.md (p9_fusion_reg_operand): Rename\n\tpredicate to reflect toc fusion has been deleted.\n\t(toc_fusion_mem_raw): Delete, no longer used.\n\t(toc_fusion_mem_wrapped): Likewise.\n\t* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Delete toc\n\tfusion mask bit.\n\t* config/rs6000/rs6000-protos.h (fusion_wrap_memory_address):\n\tDelete, no longer used.\n\t* config/rs6000/rs6000.c (struct rs6000_reg_addr): Delete fields\n\tmeant to be used for toc fusion.\n\t(rs6000_debug_print_mode): Delete toc fusion debugging.\n\t(rs6000_debug_reg_global): Likewise.\n\t(rs6000_init_hard_regno_mode_ok): Delete setting up fields for toc\n\tfusion and secondary reload support that were never used.\n\t(rs6000_option_override_internal): Delete TOC fusion, that was only\n\tpartially defined, and it did not work unless you also used the\n\t-mcmodel= switch.\n\t(rs6000_legitimate_address_p): Delete TOC fusion support.\n\t(rs6000_opt_masks): Likewise.\n\t(fusion_wrap_memory_address): Delete function, no longer used.\n\t(fusion_split_address); Delete TOC fusion support.\n\t* config/rs6000/rs6000.h (TARGET_TOC_FUSION_INT): Delete, no\n\tlonger used with toc fusion being deleted.\n\t(TARGET_TOC_FUSION_FP): Likewise.\n\t* config/rs6000/rs6000.md (UNSPEC_FUSION_ADDIS): Delete TOC fusion\n\tUNSPEC.\n\t(toc fusion spliter): Delete TOC fusion support.\n\t(toc_fusionload_<mode>): Likewise.\n\t(toc_fusionload_di): Likewise.\n\t(fusion_gpr_load_<mode>): Delete generator function, this insn no\n\tlonger needs to be named.  Rename predicate to delete TOC fusion.\n\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load): Likewise.\n\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store): Likewise.\n\t(fusion_vsx_<P:mode>_<GPR_FUSION:mode>_load): Likewise.\n\t(fusion_vsx_<P:mode>_<GPR_FUSION:mode>_store): Likewise.\n\t(p9 fusion peephole2s): Rename predicate to delete TOC fusion.\n\nFrom-SVN: r263039", "tree": {"sha": "91b79aad70bb05dbc73fed106b542659f1921e41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91b79aad70bb05dbc73fed106b542659f1921e41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/comments", "author": null, "committer": null, "parents": [{"sha": "96a54a499f62d099b466dc1d3ccdfc4a64baa2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a54a499f62d099b466dc1d3ccdfc4a64baa2bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96a54a499f62d099b466dc1d3ccdfc4a64baa2bd"}], "stats": {"total": 466, "additions": 66, "deletions": 400}, "files": [{"sha": "cc27dbc0505679befb6f9f2df11c995f13459258", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "patch": "@@ -1,3 +1,44 @@\n+2018-07-27  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/constraints.md (wG constraint): Delete, no longer\n+\tused.\n+\t* config/rs6000/predicates.md (p9_fusion_reg_operand): Rename\n+\tpredicate to reflect toc fusion has been deleted.\n+\t(toc_fusion_mem_raw): Delete, no longer used.\n+\t(toc_fusion_mem_wrapped): Likewise.\n+\t* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Delete toc\n+\tfusion mask bit.\n+\t* config/rs6000/rs6000-protos.h (fusion_wrap_memory_address):\n+\tDelete, no longer used.\n+\t* config/rs6000/rs6000.c (struct rs6000_reg_addr): Delete fields\n+\tmeant to be used for toc fusion.\n+\t(rs6000_debug_print_mode): Delete toc fusion debugging.\n+\t(rs6000_debug_reg_global): Likewise.\n+\t(rs6000_init_hard_regno_mode_ok): Delete setting up fields for toc\n+\tfusion and secondary reload support that were never used.\n+\t(rs6000_option_override_internal): Delete TOC fusion, that was only\n+\tpartially defined, and it did not work unless you also used the\n+\t-mcmodel= switch.\n+\t(rs6000_legitimate_address_p): Delete TOC fusion support.\n+\t(rs6000_opt_masks): Likewise.\n+\t(fusion_wrap_memory_address): Delete function, no longer used.\n+\t(fusion_split_address); Delete TOC fusion support.\n+\t* config/rs6000/rs6000.h (TARGET_TOC_FUSION_INT): Delete, no\n+\tlonger used with toc fusion being deleted.\n+\t(TARGET_TOC_FUSION_FP): Likewise.\n+\t* config/rs6000/rs6000.md (UNSPEC_FUSION_ADDIS): Delete TOC fusion\n+\tUNSPEC.\n+\t(toc fusion spliter): Delete TOC fusion support.\n+\t(toc_fusionload_<mode>): Likewise.\n+\t(toc_fusionload_di): Likewise.\n+\t(fusion_gpr_load_<mode>): Delete generator function, this insn no\n+\tlonger needs to be named.  Rename predicate to delete TOC fusion.\n+\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load): Likewise.\n+\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store): Likewise.\n+\t(fusion_vsx_<P:mode>_<GPR_FUSION:mode>_load): Likewise.\n+\t(fusion_vsx_<P:mode>_<GPR_FUSION:mode>_store): Likewise.\n+\t(p9 fusion peephole2s): Rename predicate to delete TOC fusion.\n+\n 2018-07-27  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* doc/extend.texi (Basic PowerPC Built-in Functions Available on"}, {"sha": "b951443c5871009c015096bd06c422dde2472cc3", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "patch": "@@ -157,11 +157,6 @@\n   \"Memory operand suitable for power9 fusion load/stores\"\n   (match_operand 0 \"fusion_addis_mem_combo_load\"))\n \n-;; Fusion gpr load.\n-(define_memory_constraint \"wG\"\n-  \"Memory operand suitable for TOC fusion memory references\"\n-  (match_operand 0 \"toc_fusion_mem_wrapped\"))\n-\n (define_register_constraint \"wH\" \"rs6000_constraints[RS6000_CONSTRAINT_wH]\"\n   \"Altivec register to hold 32-bit integers or NO_REGS.\")\n "}, {"sha": "40b0114a64f000df0ffd694d1495a2d3f8d9ba3d", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "patch": "@@ -406,13 +406,11 @@\n   return FP_REGNO_P (r);\n })\n \n-;; Return true if this is a register that can has D-form addressing (GPR and\n-;; traditional FPR registers for scalars).  ISA 3.0 (power9) adds D-form\n-;; addressing for scalars in Altivec registers.\n-;;\n-;; If this is a pseudo only allow for GPR fusion in power8.  If we have the\n-;; power9 fusion allow the floating point types.\n-(define_predicate \"toc_fusion_or_p9_reg_operand\"\n+;; Return true if this is a register that can has D-form addressing (GPR,\n+;; traditional FPR registers, and Altivec registers for scalars).  Unlike\n+;; power8 fusion, this fusion does not depend on putting the ADDIS instruction\n+;; into the GPR register being loaded.\n+(define_predicate \"p9_fusion_reg_operand\"\n   (match_code \"reg,subreg\")\n {\n   HOST_WIDE_INT r;\n@@ -1664,35 +1662,6 @@\n   return GET_CODE (op) == UNSPEC && XINT (op, 1) == UNSPEC_TOCREL;\n })\n \n-;; Match the TOC memory operand that can be fused with an addis instruction.\n-;; This is used in matching a potential fused address before register\n-;; allocation.\n-(define_predicate \"toc_fusion_mem_raw\"\n-  (match_code \"mem\")\n-{\n-  if (!TARGET_TOC_FUSION_INT || !can_create_pseudo_p ())\n-    return false;\n-\n-  return small_toc_ref (XEXP (op, 0), Pmode);\n-})\n-\n-;; Match the memory operand that has been fused with an addis instruction and\n-;; wrapped inside of an (unspec [...] UNSPEC_FUSION_ADDIS) wrapper.\n-(define_predicate \"toc_fusion_mem_wrapped\"\n-  (match_code \"mem\")\n-{\n-  rtx addr;\n-\n-  if (!TARGET_TOC_FUSION_INT)\n-    return false;\n-\n-  if (!MEM_P (op))\n-    return false;\n-\n-  addr = XEXP (op, 0);\n-  return (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_FUSION_ADDIS);\n-})\n-\n ;; Match the first insn (addis) in fusing the combination of addis and loads to\n ;; GPR registers on power8.\n (define_predicate \"fusion_gpr_addis\""}, {"sha": "ccc0eb128edd717f94ae6170987ce92ef2e7f525", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "patch": "@@ -135,7 +135,6 @@\n \t\t\t\t | OPTION_MASK_RECIP_PRECISION\t\t\\\n \t\t\t\t | OPTION_MASK_SOFT_FLOAT\t\t\\\n \t\t\t\t | OPTION_MASK_STRICT_ALIGN_OPTIONAL\t\\\n-\t\t\t\t | OPTION_MASK_TOC_FUSION\t\t\\\n \t\t\t\t | OPTION_MASK_VSX)\n \n #endif"}, {"sha": "f1d5dff57883f5a8eb416f48ff8d7b6827564a7c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "patch": "@@ -97,7 +97,6 @@ extern void expand_fusion_p9_load (rtx *);\n extern void expand_fusion_p9_store (rtx *);\n extern const char *emit_fusion_p9_load (rtx, rtx, rtx);\n extern const char *emit_fusion_p9_store (rtx, rtx, rtx);\n-extern rtx fusion_wrap_memory_address (rtx);\n extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n \t\t\t\t\t\t\t    enum reg_class);\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,"}, {"sha": "cbe186801156bea0ed6d4bdf253ad0ab3d2d67db", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 277, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "patch": "@@ -531,18 +531,8 @@ struct rs6000_reg_addr {\n   enum insn_code reload_fpr_gpr;\t/* INSN to move from FPR to GPR.  */\n   enum insn_code reload_gpr_vsx;\t/* INSN to move from GPR to VSX.  */\n   enum insn_code reload_vsx_gpr;\t/* INSN to move from VSX to GPR.  */\n-  enum insn_code fusion_gpr_ld;\t\t/* INSN for fusing gpr ADDIS/loads.  */\n-\t\t\t\t\t/* INSNs for fusing addi with loads\n-\t\t\t\t\t   or stores for each reg. class.  */\t\t\t\t\t   \n-  enum insn_code fusion_addi_ld[(int)N_RELOAD_REG];\n-  enum insn_code fusion_addi_st[(int)N_RELOAD_REG];\n-\t\t\t\t\t/* INSNs for fusing addis with loads\n-\t\t\t\t\t   or stores for each reg. class.  */\t\t\t\t\t   \n-  enum insn_code fusion_addis_ld[(int)N_RELOAD_REG];\n-  enum insn_code fusion_addis_st[(int)N_RELOAD_REG];\n   addr_mask_type addr_mask[(int)N_RELOAD_REG]; /* Valid address masks.  */\n   bool scalar_in_vmx_p;\t\t\t/* Scalar value can go in VMX.  */\n-  bool fused_toc;\t\t\t/* Mode supports TOC fusion.  */\n };\n \n static struct rs6000_reg_addr reg_addr[NUM_MACHINE_MODES];\n@@ -2373,7 +2363,6 @@ rs6000_debug_print_mode (ssize_t m)\n {\n   ssize_t rc;\n   int spaces = 0;\n-  bool fuse_extra_p;\n \n   fprintf (stderr, \"Mode: %-5s\", GET_MODE_NAME (m));\n   for (rc = 0; rc < N_RELOAD_REG; rc++)\n@@ -2382,9 +2371,12 @@ rs6000_debug_print_mode (ssize_t m)\n \n   if ((reg_addr[m].reload_store != CODE_FOR_nothing)\n       || (reg_addr[m].reload_load != CODE_FOR_nothing))\n-    fprintf (stderr, \"  Reload=%c%c\",\n-\t     (reg_addr[m].reload_store != CODE_FOR_nothing) ? 's' : '*',\n-\t     (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*');\n+    {\n+      fprintf (stderr, \"%*s  Reload=%c%c\", spaces, \"\",\n+\t       (reg_addr[m].reload_store != CODE_FOR_nothing) ? 's' : '*',\n+\t       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*');\n+      spaces = 0;\n+    }\n   else\n     spaces += sizeof (\"  Reload=sl\") - 1;\n \n@@ -2396,82 +2388,6 @@ rs6000_debug_print_mode (ssize_t m)\n   else\n     spaces += sizeof (\"  Upper=y\") - 1;\n \n-  fuse_extra_p = ((reg_addr[m].fusion_gpr_ld != CODE_FOR_nothing)\n-\t\t  || reg_addr[m].fused_toc);\n-  if (!fuse_extra_p)\n-    {\n-      for (rc = 0; rc < N_RELOAD_REG; rc++)\n-\t{\n-\t  if (rc != RELOAD_REG_ANY)\n-\t    {\n-\t      if (reg_addr[m].fusion_addi_ld[rc]     != CODE_FOR_nothing\n-\t\t  || reg_addr[m].fusion_addi_ld[rc]  != CODE_FOR_nothing\n-\t\t  || reg_addr[m].fusion_addi_st[rc]  != CODE_FOR_nothing\n-\t\t  || reg_addr[m].fusion_addis_ld[rc] != CODE_FOR_nothing\n-\t\t  || reg_addr[m].fusion_addis_st[rc] != CODE_FOR_nothing)\n-\t\t{\n-\t\t  fuse_extra_p = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (fuse_extra_p)\n-    {\n-      fprintf (stderr, \"%*s  Fuse:\", spaces, \"\");\n-      spaces = 0;\n-\n-      for (rc = 0; rc < N_RELOAD_REG; rc++)\n-\t{\n-\t  if (rc != RELOAD_REG_ANY)\n-\t    {\n-\t      char load, store;\n-\n-\t      if (reg_addr[m].fusion_addis_ld[rc] != CODE_FOR_nothing)\n-\t\tload = 'l';\n-\t      else if (reg_addr[m].fusion_addi_ld[rc] != CODE_FOR_nothing)\n-\t\tload = 'L';\n-\t      else\n-\t\tload = '-';\n-\n-\t      if (reg_addr[m].fusion_addis_st[rc] != CODE_FOR_nothing)\n-\t\tstore = 's';\n-\t      else if (reg_addr[m].fusion_addi_st[rc] != CODE_FOR_nothing)\n-\t\tstore = 'S';\n-\t      else\n-\t\tstore = '-';\n-\n-\t      if (load == '-' && store == '-')\n-\t\tspaces += 5;\n-\t      else\n-\t\t{\n-\t\t  fprintf (stderr, \"%*s%c=%c%c\", (spaces + 1), \"\",\n-\t\t\t   reload_reg_map[rc].name[0], load, store);\n-\t\t  spaces = 0;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (reg_addr[m].fusion_gpr_ld != CODE_FOR_nothing)\n-\t{\n-\t  fprintf (stderr, \"%*sP8gpr\", (spaces + 1), \"\");\n-\t  spaces = 0;\n-\t}\n-      else\n-\tspaces += sizeof (\" P8gpr\") - 1;\n-\n-      if (reg_addr[m].fused_toc)\n-\t{\n-\t  fprintf (stderr, \"%*sToc\", (spaces + 1), \"\");\n-\t  spaces = 0;\n-\t}\n-      else\n-\tspaces += sizeof (\" Toc\") - 1;\n-    }\n-  else\n-    spaces += sizeof (\"  Fuse: G=ls F=ls v=ls P8gpr Toc\") - 1;\n-\n   if (rs6000_vector_unit[m] != VECTOR_NONE\n       || rs6000_vector_mem[m] != VECTOR_NONE)\n     {\n@@ -2867,9 +2783,6 @@ rs6000_debug_reg_global (void)\n       char options[80];\n \n       strcpy (options, (TARGET_P9_FUSION) ? \"power9\" : \"power8\");\n-      if (TARGET_TOC_FUSION)\n-\tstrcat (options, \", toc\");\n-\n       if (TARGET_P8_FUSION_SIGN)\n \tstrcat (options, \", sign\");\n \n@@ -3537,135 +3450,6 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t}\n     }\n \n-  /* Setup the fusion operations.  */\n-  if (TARGET_P8_FUSION)\n-    {\n-      reg_addr[QImode].fusion_gpr_ld = CODE_FOR_fusion_gpr_load_qi;\n-      reg_addr[HImode].fusion_gpr_ld = CODE_FOR_fusion_gpr_load_hi;\n-      reg_addr[SImode].fusion_gpr_ld = CODE_FOR_fusion_gpr_load_si;\n-      if (TARGET_64BIT)\n-\treg_addr[DImode].fusion_gpr_ld = CODE_FOR_fusion_gpr_load_di;\n-    }\n-\n-  if (TARGET_P9_FUSION)\n-    {\n-      struct fuse_insns {\n-\tenum machine_mode mode;\t\t\t/* mode of the fused type.  */\n-\tenum machine_mode pmode;\t\t/* pointer mode.  */\n-\tenum rs6000_reload_reg_type rtype;\t/* register type.  */\n-\tenum insn_code load;\t\t\t/* load insn.  */\n-\tenum insn_code store;\t\t\t/* store insn.  */\n-      };\n-\n-      static const struct fuse_insns addis_insns[] = {\n-\t{ E_SFmode, E_DImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_vsx_di_sf_load,\n-\t  CODE_FOR_fusion_vsx_di_sf_store },\n-\n-\t{ E_SFmode, E_SImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_vsx_si_sf_load,\n-\t  CODE_FOR_fusion_vsx_si_sf_store },\n-\n-\t{ E_DFmode, E_DImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_vsx_di_df_load,\n-\t  CODE_FOR_fusion_vsx_di_df_store },\n-\n-\t{ E_DFmode, E_SImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_vsx_si_df_load,\n-\t  CODE_FOR_fusion_vsx_si_df_store },\n-\n-\t{ E_DImode, E_DImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_vsx_di_di_load,\n-\t  CODE_FOR_fusion_vsx_di_di_store },\n-\n-\t{ E_DImode, E_SImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_vsx_si_di_load,\n-\t  CODE_FOR_fusion_vsx_si_di_store },\n-\n-\t{ E_QImode, E_DImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_di_qi_load,\n-\t  CODE_FOR_fusion_gpr_di_qi_store },\n-\n-\t{ E_QImode, E_SImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_si_qi_load,\n-\t  CODE_FOR_fusion_gpr_si_qi_store },\n-\n-\t{ E_HImode, E_DImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_di_hi_load,\n-\t  CODE_FOR_fusion_gpr_di_hi_store },\n-\n-\t{ E_HImode, E_SImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_si_hi_load,\n-\t  CODE_FOR_fusion_gpr_si_hi_store },\n-\n-\t{ E_SImode, E_DImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_di_si_load,\n-\t  CODE_FOR_fusion_gpr_di_si_store },\n-\n-\t{ E_SImode, E_SImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_si_si_load,\n-\t  CODE_FOR_fusion_gpr_si_si_store },\n-\n-\t{ E_SFmode, E_DImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_di_sf_load,\n-\t  CODE_FOR_fusion_gpr_di_sf_store },\n-\n-\t{ E_SFmode, E_SImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_si_sf_load,\n-\t  CODE_FOR_fusion_gpr_si_sf_store },\n-\n-\t{ E_DImode, E_DImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_di_di_load,\n-\t  CODE_FOR_fusion_gpr_di_di_store },\n-\n-\t{ E_DFmode, E_DImode, RELOAD_REG_GPR,\n-\t  CODE_FOR_fusion_gpr_di_df_load,\n-\t  CODE_FOR_fusion_gpr_di_df_store },\n-      };\n-\n-      machine_mode cur_pmode = Pmode;\n-      size_t i;\n-\n-      for (i = 0; i < ARRAY_SIZE (addis_insns); i++)\n-\t{\n-\t  machine_mode xmode = addis_insns[i].mode;\n-\t  enum rs6000_reload_reg_type rtype = addis_insns[i].rtype;\n-\n-\t  if (addis_insns[i].pmode != cur_pmode)\n-\t    continue;\n-\n-\t  if (rtype == RELOAD_REG_FPR && !TARGET_HARD_FLOAT)\n-\t    continue;\n-\n-\t  reg_addr[xmode].fusion_addis_ld[rtype] = addis_insns[i].load;\n-\t  reg_addr[xmode].fusion_addis_st[rtype] = addis_insns[i].store;\n-\n-\t  if (rtype == RELOAD_REG_FPR && TARGET_P9_VECTOR)\n-\t    {\n-\t      reg_addr[xmode].fusion_addis_ld[RELOAD_REG_VMX]\n-\t\t= addis_insns[i].load;\n-\t      reg_addr[xmode].fusion_addis_st[RELOAD_REG_VMX]\n-\t\t= addis_insns[i].store;\n-\t    }\n-\t}\n-    }\n-\n-  /* Note which types we support fusing TOC setup plus memory insn.  We only do\n-     fused TOCs for medium/large code models.  */\n-  if (TARGET_P8_FUSION && TARGET_TOC_FUSION && TARGET_POWERPC64\n-      && (TARGET_CMODEL != CMODEL_SMALL))\n-    {\n-      reg_addr[QImode].fused_toc = true;\n-      reg_addr[HImode].fused_toc = true;\n-      reg_addr[SImode].fused_toc = true;\n-      reg_addr[DImode].fused_toc = true;\n-      if (TARGET_HARD_FLOAT)\n-\t{\n-\t  reg_addr[SFmode].fused_toc = true;\n-\t  reg_addr[DFmode].fused_toc = true;\n-\t}\n-    }\n-\n   /* Precalculate HARD_REGNO_NREGS.  */\n   for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n     for (m = 0; m < NUM_MACHINE_MODES; ++m)\n@@ -4422,17 +4206,14 @@ rs6000_option_override_internal (bool global_init_p)\n \t\t\t & OPTION_MASK_P8_FUSION);\n \n   /* Setting additional fusion flags turns on base fusion.  */\n-  if (!TARGET_P8_FUSION && (TARGET_P8_FUSION_SIGN || TARGET_TOC_FUSION))\n+  if (!TARGET_P8_FUSION && TARGET_P8_FUSION_SIGN)\n     {\n       if (rs6000_isa_flags_explicit & OPTION_MASK_P8_FUSION)\n \t{\n \t  if (TARGET_P8_FUSION_SIGN)\n \t    error (\"%qs requires %qs\", \"-mpower8-fusion-sign\",\n \t\t   \"-mpower8-fusion\");\n \n-\t  if (TARGET_TOC_FUSION)\n-\t    error (\"%qs requires %qs\", \"-mtoc-fusion\", \"-mpower8-fusion\");\n-\n \t  rs6000_isa_flags &= ~OPTION_MASK_P8_FUSION;\n \t}\n       else\n@@ -4470,28 +4251,6 @@ rs6000_option_override_internal (bool global_init_p)\n       && optimize >= 3)\n     rs6000_isa_flags |= OPTION_MASK_P8_FUSION_SIGN;\n \n-  /* TOC fusion requires 64-bit and medium/large code model.  */\n-  if (TARGET_TOC_FUSION && !TARGET_POWERPC64)\n-    {\n-      rs6000_isa_flags &= ~OPTION_MASK_TOC_FUSION;\n-      if ((rs6000_isa_flags_explicit & OPTION_MASK_TOC_FUSION) != 0)\n-\twarning (0, N_(\"-mtoc-fusion requires 64-bit\"));\n-    }\n-\n-  if (TARGET_TOC_FUSION && (TARGET_CMODEL == CMODEL_SMALL))\n-    {\n-      rs6000_isa_flags &= ~OPTION_MASK_TOC_FUSION;\n-      if ((rs6000_isa_flags_explicit & OPTION_MASK_TOC_FUSION) != 0)\n-\twarning (0, N_(\"-mtoc-fusion requires medium/large code model\"));\n-    }\n-\n-  /* Turn on -mtoc-fusion by default if p8-fusion and 64-bit medium/large code\n-     model.  */\n-  if (TARGET_P8_FUSION && !TARGET_TOC_FUSION && TARGET_POWERPC64\n-      && (TARGET_CMODEL != CMODEL_SMALL)\n-      && !(rs6000_isa_flags_explicit & OPTION_MASK_TOC_FUSION))\n-    rs6000_isa_flags |= OPTION_MASK_TOC_FUSION;\n-\n   /* ISA 3.0 vector instructions include ISA 2.07.  */\n   if (TARGET_P9_VECTOR && !TARGET_P8_VECTOR)\n     {\n@@ -9435,9 +9194,6 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n       if (legitimate_constant_pool_address_p (x, mode,\n \t\t\t\t\t     reg_ok_strict || lra_in_progress))\n \treturn 1;\n-      if (reg_addr[mode].fused_toc && GET_CODE (x) == UNSPEC\n-\t  && XINT (x, 1) == UNSPEC_FUSION_ADDIS)\n-\treturn 1;\n     }\n \n   /* For TImode, if we have TImode in VSX registers, only allow register\n@@ -35780,7 +35536,6 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"recip-precision\",\t\tOPTION_MASK_RECIP_PRECISION,\tfalse, true  },\n   { \"save-toc-indirect\",\tOPTION_MASK_SAVE_TOC_INDIRECT,\tfalse, true  },\n   { \"string\",\t\t\t0,\t\t\t\tfalse, true  },\n-  { \"toc-fusion\",\t\tOPTION_MASK_TOC_FUSION,\t\tfalse, true  },\n   { \"update\",\t\t\tOPTION_MASK_NO_UPDATE,\t\ttrue , true  },\n   { \"vsx\",\t\t\tOPTION_MASK_VSX,\t\tfalse, true  },\n #ifdef OPTION_MASK_64BIT\n@@ -37943,37 +37698,17 @@ emit_fusion_load_store (rtx load_store_reg, rtx addis_reg, rtx offset,\n   return;\n }\n \n-/* Wrap a TOC address that can be fused to indicate that special fusion\n-   processing is needed.  */\n-\n-rtx\n-fusion_wrap_memory_address (rtx old_mem)\n-{\n-  rtx old_addr = XEXP (old_mem, 0);\n-  rtvec v = gen_rtvec (1, old_addr);\n-  rtx new_addr = gen_rtx_UNSPEC (Pmode, v, UNSPEC_FUSION_ADDIS);\n-  return replace_equiv_address_nv (old_mem, new_addr, false);\n-}\n-\n /* Given an address, convert it into the addis and load offset parts.  Addresses\n    created during the peephole2 process look like:\n \t(lo_sum (high (unspec [(sym)] UNSPEC_TOCREL))\n-\t\t(unspec [(...)] UNSPEC_TOCREL))\n-\n-   Addresses created via toc fusion look like:\n-\t(unspec [(unspec [(...)] UNSPEC_TOCREL)] UNSPEC_FUSION_ADDIS))  */\n+\t\t(unspec [(...)] UNSPEC_TOCREL))  */\n \n static void\n fusion_split_address (rtx addr, rtx *p_hi, rtx *p_lo)\n {\n   rtx hi, lo;\n \n-  if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_FUSION_ADDIS)\n-    {\n-      lo = XVECEXP (addr, 0, 0);\n-      hi = gen_rtx_HIGH (Pmode, lo);\n-    }\n-  else if (GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM)\n+  if (GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM)\n     {\n       hi = XEXP (addr, 0);\n       lo = XEXP (addr, 1);\n@@ -37990,9 +37725,6 @@ fusion_split_address (rtx addr, rtx *p_hi, rtx *p_lo)\n    is the logical address that was formed during peephole2:\n \t(lo_sum (high) (low-part))\n \n-   Or the address is the TOC address that is wrapped before register allocation:\n-\t(unspec [(addr) (toc-reg)] UNSPEC_FUSION_ADDIS)\n-\n    The code is complicated, so we call output_asm_insn directly, and just\n    return \"\".  */\n "}, {"sha": "9ea5959ea1491ce9dd8d735ae34351023f5fd774", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "patch": "@@ -699,19 +699,6 @@ extern int rs6000_vector_align[];\n #define TARGET_FRSQRTE\t(TARGET_HARD_FLOAT \\\n \t\t\t && (TARGET_PPC_GFXOPT || VECTOR_UNIT_VSX_P (DFmode)))\n \n-/* Conditions to allow TOC fusion for loading/storing integers.  */\n-#define TARGET_TOC_FUSION_INT\t(TARGET_P8_FUSION\t\t\t\\\n-\t\t\t\t && TARGET_TOC_FUSION\t\t\t\\\n-\t\t\t\t && (TARGET_CMODEL != CMODEL_SMALL)\t\\\n-\t\t\t\t && TARGET_POWERPC64)\n-\n-/* Conditions to allow TOC fusion for loading/storing floating point.  */\n-#define TARGET_TOC_FUSION_FP\t(TARGET_P9_FUSION\t\t\t\\\n-\t\t\t\t && TARGET_TOC_FUSION\t\t\t\\\n-\t\t\t\t && (TARGET_CMODEL != CMODEL_SMALL)\t\\\n-\t\t\t\t && TARGET_POWERPC64\t\t\t\\\n-\t\t\t\t && TARGET_HARD_FLOAT)\n-\n /* Macro to say whether we can do optimizations where we need to do parts of\n    the calculation in 64-bit GPRs and then is transfered to the vector\n    registers.  */"}, {"sha": "56b8a30fef60658cbfefc8f3152edd1b6d2ffd48", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 11, "deletions": 67, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0fb9e668bcf9a692cebd9d673bf0d424b3a75bc3", "patch": "@@ -137,7 +137,6 @@\n    UNSPEC_FUSION_GPR\n    UNSPEC_STACK_CHECK\n    UNSPEC_FUSION_P9\n-   UNSPEC_FUSION_ADDIS\n    UNSPEC_ADD_ROUND_TO_ODD\n    UNSPEC_SUB_ROUND_TO_ODD\n    UNSPEC_MUL_ROUND_TO_ODD\n@@ -13621,66 +13620,11 @@\n ;; a GPR.  The addis instruction must be adjacent to the load, and use the same\n ;; register that is being loaded.  The fused ops must be physically adjacent.\n \n-;; There are two parts to addis fusion.  The support for fused TOCs occur\n-;; before register allocation, and is meant to reduce the lifetime for the\n-;; tempoary register that holds the ADDIS result.  On Power8 GPR loads, we try\n-;; to use the register that is being load.  The peephole2 then gathers any\n-;; other fused possibilities that it can find after register allocation.  If\n-;; power9 fusion is selected, we also fuse floating point loads/stores.\n+;; On Power8 GPR loads, we try to use the register that is being load.  The\n+;; peephole2 then gathers any other fused possibilities that it can find after\n+;; register allocation.  If power9 fusion is selected, we also fuse floating\n+;; point loads/stores.\n \n-;; Fused TOC support: Replace simple GPR loads with a fused form.  This is done\n-;; before register allocation, so that we can avoid allocating a temporary base\n-;; register that won't be used, and that we try to load into base registers,\n-;; and not register 0.  If we can't get a fused GPR load, generate a P9 fusion\n-;; (addis followed by load) even on power8.\n-\n-(define_split\n-  [(set (match_operand:INT1 0 \"toc_fusion_or_p9_reg_operand\")\n-\t(match_operand:INT1 1 \"toc_fusion_mem_raw\"))]\n-  \"TARGET_TOC_FUSION_INT && can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0) (match_dup 2))\n-\t      (unspec [(const_int 0)] UNSPEC_FUSION_ADDIS)\n-\t      (use (match_dup 3))\n-\t      (clobber (scratch:DI))])]\n-{\n-  operands[2] = fusion_wrap_memory_address (operands[1]);\n-  operands[3] = gen_rtx_REG (Pmode, TOC_REGISTER);\n-})\n-\n-(define_insn \"*toc_fusionload_<mode>\"\n-  [(set (match_operand:QHSI 0 \"int_reg_operand\" \"=&b,??r\")\n-\t(match_operand:QHSI 1 \"toc_fusion_mem_wrapped\" \"wG,wG\"))\n-   (unspec [(const_int 0)] UNSPEC_FUSION_ADDIS)\n-   (use (match_operand:DI 2 \"base_reg_operand\" \"r,r\"))\n-   (clobber (match_scratch:DI 3 \"=X,&b\"))]\n-  \"TARGET_TOC_FUSION_INT\"\n-{\n-  if (base_reg_operand (operands[0], <MODE>mode))\n-    return emit_fusion_gpr_load (operands[0], operands[1]);\n-\n-  return emit_fusion_p9_load (operands[0], operands[1], operands[3]);\n-}\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*toc_fusionload_di\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=&b,??r,?d\")\n-\t(match_operand:DI 1 \"toc_fusion_mem_wrapped\" \"wG,wG,wG\"))\n-   (unspec [(const_int 0)] UNSPEC_FUSION_ADDIS)\n-   (use (match_operand:DI 2 \"base_reg_operand\" \"r,r,r\"))\n-   (clobber (match_scratch:DI 3 \"=X,&b,&b\"))]\n-  \"TARGET_TOC_FUSION_INT && TARGET_POWERPC64\n-   && (MEM_P (operands[1]) || int_reg_operand (operands[0], DImode))\"\n-{\n-  if (base_reg_operand (operands[0], DImode))\n-    return emit_fusion_gpr_load (operands[0], operands[1]);\n-\n-  return emit_fusion_p9_load (operands[0], operands[1], operands[3]);\n-}\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n-\f\n ;; Find cases where the addis that feeds into a load instruction is either used\n ;; once or is the same as the target register, and replace it with the fusion\n ;; insn\n@@ -13702,7 +13646,7 @@\n ;; Fusion insn, created by the define_peephole2 above (and eventually by\n ;; reload)\n \n-(define_insn \"fusion_gpr_load_<mode>\"\n+(define_insn \"*fusion_gpr_load_<mode>\"\n   [(set (match_operand:INT1 0 \"base_reg_operand\" \"=b\")\n \t(unspec:INT1 [(match_operand:INT1 1 \"fusion_addis_mem_combo_load\" \"wF\")]\n \t\t     UNSPEC_FUSION_GPR))]\n@@ -13719,7 +13663,7 @@\n (define_peephole2\n   [(set (match_operand:P 0 \"base_reg_operand\")\n \t(match_operand:P 1 \"fusion_gpr_addis\"))\n-   (set (match_operand:SFDF 2 \"toc_fusion_or_p9_reg_operand\")\n+   (set (match_operand:SFDF 2 \"p9_fusion_reg_operand\")\n \t(match_operand:SFDF 3 \"fusion_offsettable_mem_operand\"))]\n   \"TARGET_P9_FUSION && peep2_reg_dead_p (2, operands[0])\n    && fusion_p9_p (operands[0], operands[1], operands[2], operands[3])\"\n@@ -13733,7 +13677,7 @@\n   [(set (match_operand:P 0 \"base_reg_operand\")\n \t(match_operand:P 1 \"fusion_gpr_addis\"))\n    (set (match_operand:SFDF 2 \"offsettable_mem_operand\")\n-\t(match_operand:SFDF 3 \"toc_fusion_or_p9_reg_operand\"))]\n+\t(match_operand:SFDF 3 \"p9_fusion_reg_operand\"))]\n   \"TARGET_P9_FUSION && peep2_reg_dead_p (2, operands[0])\n    && fusion_p9_p (operands[0], operands[1], operands[2], operands[3])\n    && !rtx_equal_p (operands[0], operands[3])\"\n@@ -13771,7 +13715,7 @@\n ;; reload).  Because we want to eventually have secondary_reload generate\n ;; these, they have to have a single alternative that gives the register\n ;; classes.  This means we need to have separate gpr/fpr/altivec versions.\n-(define_insn \"fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load\"\n+(define_insn \"*fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load\"\n   [(set (match_operand:GPR_FUSION 0 \"int_reg_operand\" \"=r\")\n \t(unspec:GPR_FUSION\n \t [(match_operand:GPR_FUSION 1 \"fusion_addis_mem_combo_load\" \"wF\")]\n@@ -13789,7 +13733,7 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store\"\n+(define_insn \"*fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store\"\n   [(set (match_operand:GPR_FUSION 0 \"fusion_addis_mem_combo_store\" \"=wF\")\n \t(unspec:GPR_FUSION\n \t [(match_operand:GPR_FUSION 1 \"int_reg_operand\" \"r\")]\n@@ -13802,7 +13746,7 @@\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"fusion_vsx_<P:mode>_<FPR_FUSION:mode>_load\"\n+(define_insn \"*fusion_vsx_<P:mode>_<FPR_FUSION:mode>_load\"\n   [(set (match_operand:FPR_FUSION 0 \"vsx_register_operand\" \"=dwb\")\n \t(unspec:FPR_FUSION\n \t [(match_operand:FPR_FUSION 1 \"fusion_addis_mem_combo_load\" \"wF\")]\n@@ -13815,7 +13759,7 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"fusion_vsx_<P:mode>_<FPR_FUSION:mode>_store\"\n+(define_insn \"*fusion_vsx_<P:mode>_<FPR_FUSION:mode>_store\"\n   [(set (match_operand:FPR_FUSION 0 \"fusion_addis_mem_combo_store\" \"=wF\")\n \t(unspec:FPR_FUSION\n \t [(match_operand:FPR_FUSION 1 \"vsx_register_operand\" \"dwb\")]"}]}